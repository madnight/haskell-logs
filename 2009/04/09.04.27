00:00:03 <copumpkin> and try writing this where it belongs
00:00:15 <copumpkin> as there's all sorts of painful stuff I'd need to be doing
00:00:37 <copumpkin> things like propagating let/where definitions, simplifying them, and so on
00:00:47 <hotaru2k3> > let n = 3 in (fst &&& (uncurry (:) . first last)) $ (span (<= n)) [1..5]
00:00:49 <lambdabot>   ([1,2,3],[3,4,5])
00:04:27 <Gracenotes> @type last
00:04:28 <lambdabot> forall a. [a] -> a
00:04:39 <Gracenotes> oh, duh
00:08:59 <copumpkin> mmorrow: did you see that the new GHC build system got merged in today?
00:09:09 <mmorrow> copumpkin: no, nice
00:09:54 <thoughtpolice> copumpkin: once hc-bootstrapping is in, ghc will hopefully be on 64-bit osx soon enough :)
00:09:59 <copumpkin> yeah :)
00:10:02 <copumpkin> and iphone :D
00:10:08 <ivanm> @seen sjanssen
00:10:09 <lambdabot> sjanssen is in #haskell-in-depth, #haskell-overflow, #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 21m 2s ago.
00:10:11 <voker57__> how to split list into N parts with equal (or less than equal for last part) number of elements?
00:10:25 <copumpkin> and then BSP can merge in his ghc plugins stuff, and I'll be very happy
00:10:42 <ivanm> sjanssen: how can I then use that monoid to find the first list of maximum size?
00:11:18 <copumpkin> ivanm: which monoid?
00:11:46 <ivanm> copumpkin: one that sjanssen @told me about for use in a fingertree ;-)
00:11:50 <coolsner> haha, my dual is "cool" :P
00:11:53 <copumpkin> ah
00:12:12 <dolio> Sounds like a brand of beer.
00:12:19 <sjanssen> ivanm: you use the split function
00:12:25 <copumpkin> voker57__: you could takeWhile (not . null) . map (take n) . iterate (drop n)
00:12:29 <dolio> After a hard day's work, crack open an ice cold coolsner.
00:13:06 <copumpkin> voker57__: where n in my case is the number of elements in each list, not the number of parts
00:13:14 <ivanm> sjanssen: but that won't tell me what the maximum length _is_
00:13:23 <ivanm> just that if I know what it is, I can split it
00:13:32 <sjanssen> ivanm: you use 'measure' to find what the maximum value is
00:13:38 <sjanssen> FingerTree caches that value
00:13:52 <ivanm> sjanssen: oh, so I can do "measure tree" ?
00:14:02 <ivanm> _that_ was what I couldn't work out!
00:17:31 <ivanm> sjanssen: is there then any easy way of converting a fingertree to a Sequence? I after finding the maximum list, I need to append the rest of them onto another "list" of lists, which I have to replace a sublist which == another list :s
00:18:26 <sjanssen> ivanm: I don't know of anything other than fromList . toList
00:19:27 <glguy> FingerTrees get toList from Foldable
00:19:58 <sjanssen> ivanm: could this other "list" be a FingerTree too?
00:20:09 <sjanssen> I guess I don't know what operations you need on that data
00:20:29 <ivanm> sjanssen: it can be
00:20:51 <guenni> how can I encapsulate a non IO Error, ie. a "read" error for instance?
00:20:53 <ivanm> but I would need to split it on (== someOtherList)
00:21:06 <ivanm> guenni: using Maybe or Either String ?
00:21:09 <glguy> guenni, make it an IO eror with readIO
00:21:27 <mmorrow> pumpkin: something like this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2250#a2250
00:21:29 <guenni> thx
00:21:42 <mmorrow> pumpkin: (which is the minimal skeleton i think)
00:21:53 <glguy> guenni, There is a can of worms that you can open called "asynchronous exceptions"
00:21:53 <mmorrow> copumpkin: i mean copumpkin
00:21:54 <copumpkin> oh wow, thanks
00:22:01 <glguy> but that is really just after your last resort
00:22:10 <glguy> :t reads
00:22:11 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:22:22 <ivanm> sjanssen: my main problem with FingerTree is that it seems you can't do anything that isn't covered by the monoid
00:22:22 <sjanssen> ivanm: oh, on equality, eh?
00:22:26 <ivanm> yup
00:22:27 <glguy> another way to safely use read
00:22:28 <sjanssen> ivanm: does the order you insert in matter?
00:22:31 <mmorrow> copumpkin: i've thought about this before, but never wrote anything down. i'm interested to hear how it does
00:22:39 <ivanm> so unless I make the monoid List (Int, [a])
00:22:43 <ivanm> sjanssen: yes
00:22:49 <copumpkin> mmorrow: I'd still eventually like to dip into the ghc plugins for this
00:22:55 <sjanssen> ivanm: that's what you'd do
00:23:03 <ivanm> *nod*
00:23:04 <copumpkin> as it seems like a more appropriate place to try it, but I'll play with TH in the mean time
00:23:14 <glguy> ivanm, you should newtype your custom measure, rather than adding a weird instance to a standard type
00:23:27 <ivanm> sjanssen: so "measure" is the overall mappend'd value?
00:23:28 <sjanssen> ivanm: you *must* do that unless you want O(n) lookup
00:23:35 <mmorrow> copumpkin: so in there, i tried to show (1) pprinting *abstract* syn, (2) pprinting *real* syn, and (3) splicing of ExpQ's into [|.... $(..here..) ...|]
00:23:38 <ivanm> glguy: yes, I realise this ;-)
00:23:40 <mmorrow> copumpkin: (3) is key
00:23:50 <sjanssen> ivanm: 'measure x' is the summarized value of x
00:23:59 <mmorrow> copumpkin: that's what took me the longest to figure out with TH
00:24:05 <sjanssen> ivanm: in the case of FingerTree, that is mconcat (allthevalues)
00:24:17 <ivanm> sjanssen: *nod*
00:24:25 <guenni> ivanm: using Maybe or Either how?
00:24:26 <copumpkin> mmorrow: so your meanFT is explicitly keeping the folds around as pairs?
00:24:35 <ivanm> guenni: depends on what you mean by "read error"
00:24:55 <guenni> ivanm: read "a" :: Int
00:25:02 <ivanm> oh
00:25:09 <mmorrow> copumpkin: ah, yeah so the "FuseTemplate" takes a combiner function, and a list of pairs of (iteratee, initial val)
00:25:10 <glguy> guenni, to catch errors in "read", you'll either use "readIO" or "reads"
00:25:15 <ivanm> @type reads
00:25:16 <copumpkin> mmorrow: I see
00:25:16 <lambdabot> forall a. (Read a) => String -> [(a, String)]
00:25:39 <ivanm> > reads "2a" :: [(Int,String)]
00:25:40 <lambdabot>   [(2,"a")]
00:25:50 <ivanm> isn't there a Maybe version of reads?
00:25:50 <mmorrow> copumpkin: and then "fuseIt" just does the strategy of tupling stuff up, and then using the combiner at the end
00:26:17 <glguy> ivanm, not in the Prelude
00:26:17 <copumpkin> mmorrow: so what I'd need on top of that is something that takes haskell, pulls out the folds from it, builds that structure, keeps track of the combinations, and outputs the final fold?
00:26:45 <glguy> read isn't really useful for anything bigger than an example program
00:26:50 <glguy> and in those you can assume good input
00:27:06 <mmorrow> copumpkin: hmm, yeah that could be interesting. i was thinking of the "user" supplying the FoldTemplate, but that would be even nicer
00:27:20 <mmorrow> (sounds possibly a lot of work though)
00:27:22 <copumpkin> mmorrow: that's what I was talking about when I said I was afraid of the complexity
00:27:23 <copumpkin> yeah :P
00:27:30 <copumpkin> because the folds may not be directly visible
00:27:37 <copumpkin> they may be hidden in a where/let
00:28:13 <mmorrow> yeah, taking arbitrary haskell code and extracting fusible fold automagically would be epic
00:28:21 <copumpkin> yeah :P
00:28:31 <mmorrow> (but awesome)
00:28:39 <copumpkin> that's why it feels more appropriate to be doing this at an early stage of the simplifier, using the ghc plugins arch
00:28:55 <copumpkin> there are fewer cases to be catching
00:29:05 <mmorrow> that's be cool
00:29:12 <mmorrow> *that'd
00:29:14 <copumpkin> but the ghc plugins thing isn't ready yet :P
00:29:21 <copumpkin> and this looks like fun so I'll play with it instead
00:29:33 <mmorrow> copumpkin: lemme know how it goes
00:29:42 <copumpkin> but I look forward to being able to supply plugins for specific optimizations
00:29:47 <copumpkin> sure thing!
00:29:56 <mmorrow> copumpkin: oh oops, this comment should've been deleted "- if TypeQ is @a@, then ExpQ :: (a -> a -> a)"
00:30:15 <mmorrow> (it's talking about something that doesn't exist anymore)
00:31:38 <copumpkin> ah :) ok
00:31:39 <ivanm> @seen matthew-_
00:31:39 <lambdabot> matthew-_ is in #haskell-blah, #ghc and #haskell. I last heard matthew-_ speak 18h 45m 15s ago.
00:31:58 <ivanm> @ask matthew-_ did you send out the emails about my taking over graphviz?
00:31:58 <lambdabot> Consider it noted.
00:36:06 * Berengal is having fun with applicative parsers
00:36:35 <voker57__> doesn't map work with IO functions? what's the alternative?
00:36:45 <voker57__> like 'map (print) [1,2,3]
00:36:55 <Berengal> voker57__: Use fmap
00:37:03 <Berengal> Wait
00:37:08 <Berengal> Use mapM
00:37:17 <Berengal> You could use map though...
00:37:23 <Berengal> @type map print [1,2,3]
00:37:25 <lambdabot> [IO ()]
00:37:34 <Berengal> But it's probably not what you wanted
00:37:41 <dolio> For that, you actually want mapM_.
00:37:41 <Berengal> @type mapM_ print [1,2,3]
00:37:43 <lambdabot> IO ()
00:38:08 <Berengal> @type mapM readFile ["fileA", "fileB", "fileC"]
00:38:09 <lambdabot> IO [String]
00:39:24 <Cale> voker57__: See, map print [1,2,3] gives you a list of actions, whereas you probably want to actually *run* those actions in turn.
00:39:42 <Cale> (which is what mapM/mapM_ are for)
00:40:45 <voker57__> ok, understood
00:40:49 <Berengal> Or you could use sequence...
00:40:52 <Berengal> @type sequence
00:40:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:40:55 <Berengal> @type sequence_
00:40:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
00:41:05 <Berengal> That's what mapM uses internally anyway
00:41:10 <voker57__> i needed to run actions and get values
00:41:39 <Berengal> Is the action always the same, just with different parameters?
00:42:12 <voker57__> yes
00:42:21 <Berengal> That's what mapM is for them
00:42:23 <Berengal> then*
00:42:26 <Berengal> @type mapM
00:42:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:42:28 <voker57__> so it works :)
00:42:56 <Berengal> Yeah, it takes a function to a monad and a list of values and gives you a monad of a list of values
01:16:13 <Berengal> Yay, primitive interpreter now complete!
01:16:56 <cothoughtpolice> for what?
01:17:17 <Berengal> A very simple non-turing-complete language
01:17:34 <Hunner> hq9+ ?
01:17:46 <Berengal> Not quite that simple
01:18:44 <Berengal> One of the first things I did in haskell was to write an interpreter for this language for an assignment. I decided to try writing a new one now to see how much I had improved
01:18:46 <ivanm> Berengal: how non-turing-complete?
01:18:54 <ivanm> and have you improved? :p
01:19:23 <ivanm> (though I fail to see how increased knowledge/familiarity with a programming language can indicate whether you as a person have improved...)
01:19:24 <Berengal> let (Right e) = parse expr "" "funlet F(x) = x in F(let y=3 in y)" in evalExpr e -- Just 3
01:19:28 <ivanm> ;-)
01:19:38 <Berengal> The above shows all it's features
01:19:42 <Berengal> And yes, I have improved
01:19:58 <Berengal> This one's about a third in size
01:20:09 <Berengal> And I could probably reduce it even further, but I was curious about existentials...
01:20:28 <Berengal> Instead of pattern matching on lists, I now use parsec for parsing
01:21:11 <Berengal> And I use a ReaderT Environment Maybe Int to evaluate the thing...
01:23:13 <Axman6> > fun "I'm a variable!" (var "i'm a function!)"
01:23:14 <lambdabot>   <no location info>: parse error on input `;'
01:23:20 <Axman6> > fun "I'm a variable!" (var "i'm a function!")
01:23:21 <lambdabot>       Ambiguous occurrence `var'
01:23:21 <lambdabot>      It could refer to either `Data.Number.S...
01:23:34 <Axman6> bah
01:29:20 <DrSyzygyFR> What's a good way to conditionally import ModuleA or ModuleB dependent on a compilation flag?
01:29:27 <DrSyzygyFR> I have the whole Cabal scaffolding in place...
01:29:46 <ivanm> DrSyzygyFR: use cpp
01:30:19 <DrSyzygyFR> Aight.
01:30:31 <DrSyzygyFR> And just #ifdef FLAG and stuff
01:48:33 <necroforest> What's wrong with this?
01:48:37 <necroforest> main = do
01:48:37 <necroforest>   args <- getArgs
01:48:37 <necroforest>   firstOne <- read (head args)::Integer
01:48:53 <necroforest> I get "    Couldn't match expected type `IO t' against inferred type `Integer'"
01:50:32 <C-Keen> :t read
01:50:33 <lambdabot> forall a. (Read a) => String -> a
01:50:55 <mlesniak> Does a function [[x1,y1,...], [x2,y2,...], ...] -> [[x1,x2,...], [y1,y2,...], ...] exist? I have the vague feeling that I overlook some obvious functional pattern here...
01:51:07 <copumpkin> :t transpose
01:51:08 <lambdabot> forall a. [[a]] -> [[a]]
01:51:13 <copumpkin> :)
01:51:15 <mlesniak> :D
01:51:42 <mlesniak> Sometimes it's so obvious it hurts mentally ;-)
01:51:43 <glguy> necroforest, read (head args) doesn't have a type of (IO _) which is required to use it with the <- syntax
01:51:51 <glguy> try: let firstOne = read (head args)
01:51:55 <necroforest> ah ok
01:51:59 <glguy> when you want to simply label a value
01:54:10 <DrSyzygyFR> Another basic question.
01:54:19 <DrSyzygyFR> I've broken up my program into 3-4 different modules.
01:54:32 <DrSyzygyFR> Now I want the single line import OperadGB to automatically also provide all the submodules.
01:54:35 <DrSyzygyFR> How do I do that?
01:54:55 <glguy> You can add modules to a modules export list
01:55:08 <glguy> so you'd have a OperadGB module that reexports all of the others
01:55:19 <swiert> da
01:55:34 <copumpkin> mn
01:55:41 <DrSyzygyFR> Ooooh.
01:55:53 <swiert> sorry. Some window stole my focus.
01:55:59 <copumpkin> :)
01:56:27 <glguy> DrSyzygyFR, this is what Control.Concurrent does, for example: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/src/Control-Concurrent.html
01:57:23 <DrSyzygyFR> So if I want to export everything from OperadGB too, but write an export list, can I just include OperadGB in its own list?
01:57:54 <swiert> Is there a way to let cabal configurations fail gracefully? Like if (test) then doSomething else fail.
01:58:19 <dcoutts> swiert: sort of, you can use buildable: False
01:58:19 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:58:31 <swiert> dcoutts: Great - thanks.
01:58:41 <dcoutts> swiert: but the error messages are not better, they're worse
01:58:45 <koeien_> DrSyzygyFR: no, 'module OperadGB'
01:59:42 <dcoutts> swiert: you might like to add yourself to the cc list of this ticket: http://hackage.haskell.org/trac/hackage/ticket/231
02:00:35 <swiert> dcoutts: It's not a big deal: the AppleScript package should only build on MacOS.
02:00:54 <swiert> It the build has a error in the Hackage build log.
02:01:11 <swiert> But it's a fairly simple check.
02:02:31 <DrSyzygyFR> koeien_: But if I write module OperadGB (SubModule1, SubModule2) where ...
02:02:39 <DrSyzygyFR> will I actually get anything from OperadGB out of it??
02:04:24 <koeien_> DrSyzygyFR: no, you will need to add any functions of the module OperadGB itself as well
02:05:08 <DrSyzygyFR> koeien_: Oh _joy_. :-/
02:05:45 <J-roen> Loading package Cabal-1.6.0.3 ... linking ... done.
02:05:46 <J-roen> *** Exception: 'parseField' called on a non-field. Consider this a bug.
02:05:49 <koeien_> DrSyzygyFR: you could avoid it by creating a separate file and importing that besides SubModule{1,2}
02:05:50 <J-roen> Should I indeed consider it a bug?
02:06:58 <koeien_> DrSyzygyFR: although i consider explicit export lists a Good Thing[tm] while annoying while developing
02:07:30 <J-roen> Forgot to mention: I get this when I call readHookedBuildInfo.
02:08:20 <DrSyzygyFR> Hahaha!
02:08:43 <DrSyzygyFR> koeien_: Didn't read your answer until I had already gone and created the wrapper.
02:08:59 <DrSyzygyFR> I agree, in principle, that explicit export lists are a good thing, and in the end certainly SHOULD be used here.
02:09:12 <DrSyzygyFR> However, I'm still enough in flux with development that I don't need one more hazzle.
02:09:49 <koeien_> DrSyzygyFR: but you need 'module Submodule1' instead of just 'Submodule1'
02:09:54 <koeien_> (in the export list)
02:16:50 <matthew-_> @tell ivanm no, not yet
02:16:51 <lambdabot> Consider it noted.
02:21:02 <SubStack> category theory is JUST A THEORY
02:21:14 <sjanssen> oh jeez
02:21:30 <SubStack> that is all
02:21:36 <DrSyzygyFR> As is all mathematics. So what?
02:21:49 <DrSyzygyFR> The "just" in "just a theory" very seldom is so just...
02:22:09 <sjanssen> DrSyzygyFR: sounds like creationist rhetoric
02:22:37 <DrSyzygyFR> What I said, or what SubStack said?
02:22:37 * SubStack is coming up with secondary titles, many of which involve haskell in some fashion
02:22:38 <Berengal> categoryTheory = Just Theory
02:22:43 <Berengal> Could be Nothing
02:22:43 <SubStack> heh
02:22:54 <SubStack> Berengal++ for the excellent punning?
02:23:08 <ray> category theory is a theory, not a fact, regarding collections of objects and morphisms between them
02:23:28 <ray> it should be approached with an open mind, studied carefully, and critically considered
02:26:30 * quicksilver peers around doubtfully.
02:27:02 <quicksilver> Berengal: if we know it's Just Theory, then we know it isn't Nothing ;)
02:27:18 <SubStack> Maybe
02:27:37 * bremner supports teaching of all of the alternative theories about categories in elementary school
02:27:58 <bremner> then some 8 year old can explain it to me
02:28:08 <Berengal> quicksilver: Could have been Nothing then ;)
02:28:37 <Berengal> My parser overflows the stack when parsing "3 + 5" :(
02:29:21 <SubStack> bremner: like the ones under which things are related because some intelligent actor willed it to be so?
02:32:26 <bremner> SubStack: well, if that is what the "scientific" community comes up with.
02:35:37 <xrfang> I would like to write a flatten function which does: [[1,2], [3, 4]] -> [1, 2, 3, 4]
02:35:44 <xrfang> I wrote:
02:35:48 <ray> look at the elegant way functors map every object and morphism in a category perfectly to another one
02:35:51 <xrfang> flatten [] = []
02:35:52 <ray> how can you not see a designer
02:35:53 <xrfang> flatten (x:xs)
02:35:53 <ivanm> matthew-_: well, hurry up and do so! :p
02:35:53 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
02:35:54 <xrfang>   |[x] = (flatten x) : (flatten xs)
02:35:56 <xrfang>   |otherwise = x : (flatten xs)
02:36:02 <xrfang> but [x] does not work in guard :(
02:36:39 <ray> i think there might be a library function for that
02:36:49 <Ferdirand> :t concat
02:36:50 <ray> @hoogle [[a]] -> [a]
02:36:50 <lambdabot> Prelude concat :: [[a]] -> [a]
02:36:50 <lambdabot> Data.List concat :: [[a]] -> [a]
02:36:50 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
02:36:51 <lambdabot> forall a. [[a]] -> [a]
02:36:59 <xrfang> ray: I am practicing and won't use lib functions :)
02:37:13 <sjanssen> xrfang: what is this function supposed to do?
02:37:17 <xrfang> also I want to flatten any level of nested list to one level
02:37:23 <xrfang> no matter how many level is nested
02:37:24 <C-Keen> @hoogle [a] -> Bool
02:37:25 <lambdabot> Prelude null :: [a] -> Bool
02:37:25 <lambdabot> Data.List null :: [a] -> Bool
02:37:25 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
02:37:31 <sjanssen> xrfang: ah, this is actually rather difficult in Haskell
02:37:33 <Ferdirand> you cannot have arbitrary nesting
02:37:58 <Ferdirand> well, at least not heterogeneous nesting levels
02:38:00 <xrfang> I just want the Haskell version of Ruby's Array#flatten
02:38:07 <xrfang> Ruby's list is not tat strict
02:38:23 <xrfang> ok, for the code I wrote, what if I want to test if x is a list or not?
02:38:30 <QtPlaty[HireMe]>   concat
02:38:31 <sjanssen> xrfang: you can't do that in Haskell
02:38:35 <Ferdirand> but you do not test for it
02:38:35 <koeien_> Haskell is statically typed, you cannot do that
02:38:40 <Berengal> xrfang: There's no need to test that. You know at compile time
02:38:42 <Ferdirand> the type is known at compile time
02:38:58 <C-Keen> xrfang: in your example you have explicitly a list of lists. and your functions signature is [[a]] -> [a] which is the same as [a] -> a
02:39:01 * bremner watches the clash of mental models with interest
02:39:18 <xrfang> hm...
02:39:19 <QtPlaty[HireMe]> :t concat
02:39:20 <lambdabot> forall a. [[a]] -> [a]
02:39:20 <quicksilver> multi-level flatten isn't difficult, given a model of multi-level list.
02:39:30 <Ferdirand> you could have a custom data type that is either an item, or a sublist (a n-tree basically). then you can match on the constructors.
02:39:31 <quicksilver> once you design the type, the function writes itself.
02:39:33 <xrfang> no dynamics of any?
02:39:34 <koeien_> you need some advanced type hackery for it
02:39:35 <matthew-_> ivanm: ok, at work right now, will deal with it tonight
02:39:35 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
02:39:46 <ivanm> matthew-_: good-o
02:40:27 <Jedai> xrfang: You don't need it, since the list are homogenous and you know their type at compile time
02:40:40 <xrfang> say I pass x to a function, this function handles Maybe a,
02:40:57 <DrSyzygyFR> Ehm.... WHERE in my Cabal-file do I put extension: CPP ??
02:40:59 <xrfang> in the function I want to test if x is Nothing or Just a, I need to write a case
02:41:08 <BONUS> maybe you can do a multi level list ith Data.Dynamic
02:41:24 <xrfang> anyway, what I am thinking is "to test or find out the data type of x".
02:41:34 <Jedai> BONUS: You can use HList if you want an heterogenous list
02:41:44 <BONUS> yeah or that even better
02:41:48 <Ferdirand> xrfang: but you already did. You have an implicit case matching either [] or (x:xy)
02:42:00 <sjanssen> xrfang: right, Haskell doesn't have anything like that.  We can't ask for the type, but the type is statically known by the compiler
02:42:05 <Jedai> xrfang: You can use typeOf but you don't need to (very probably)
02:42:24 <bremner> @hoogle HList
02:42:24 <lambdabot> package HList
02:42:43 <Berengal> Matching types is nonsensical. Matching constructors on the other hand makes perfect sense, but it's not the same
02:42:46 <BONUS> every type is known at compile time, so there's no need to see if some value is of some type
02:42:57 <sjanssen> let's stay away from Typeable, Dynamic and HList for now, xrfang is asking more basic questions
02:42:59 <Jedai> sjanssen: Except for Typeable instances (I agree that xrfang don't need that here but it's good to know that it exists)
02:43:03 <xrfang> ok, as my question comes out of an imaginery exercise I hope that won't happen in Real world programming tasks...
02:43:17 <BONUS> what is the exercise
02:43:22 <sjanssen> (also, HList, for a newbie?  Srlsly guyz)
02:43:25 <Jedai> xrfang: What was the imaginary exercise)
02:43:50 <BONUS> i hope it's not "find out the type of some value at run-time" hehe
02:43:54 <ivanm> sjanssen: is there some magic way of knowing which index something is at in a FingerTree?
02:44:02 <sjanssen> ivanm: no
02:44:11 <ivanm> or is it more for using like a Map replacement?
02:44:12 <xrfang> sjanseen: yes, I only want the basics to fully understand type and typeclass. I learned erlang before, and feel lambda, high order functions etc quite understandable, but type/typeclass is hard to understand
02:44:15 <sjanssen> ivanm: you can, of course, provide a Monoid that facilitates that
02:44:15 <Jedai> xrfang: I'm pretty sure that either it's a situation that don't arise in real Haskell program or you can find a solution without type matching
02:44:17 <ivanm> s/Map/Array/
02:44:20 <ivanm> sjanssen: *nod*
02:44:30 <ivanm> not that big a deal... I'll just split, alter, join
02:44:56 <xrfang> Jedal, that's what I conclude from here. thanks
02:45:12 <xrfang> but
02:45:23 <xrfang> still some newbie comments...
02:45:31 <sjanssen> sure, go ahead
02:45:36 <xrfang> Delphi (pascal) is statically typed
02:45:41 <BONUS> what did you say the exercise was again?
02:45:49 <xrfang> I often do type checking in delphi, also in java...
02:45:54 <QtPlaty[HireMe]> data MLlist x = Mlist [Either x (MLlist x)]
02:46:06 <xrfang> BONUS, the execise is simple, just to implement Ruby's flatten in haskell
02:46:18 <ivanm> xrfang: Haskell's type (pun! :p ) of static typing is different from Pascal's or Java's
02:46:35 <ivanm> hmmm... is there any non-functional lang that has a typing system similar to Haskell's?
02:46:35 <sjanssen> xrfang: you mean the "instanceof" keyword in Java?
02:46:46 <xrfang> sjanssen: exactly!
02:46:49 <Jedai> xrfang: Haskell type system is much more expressive than Java's or Delphi's
02:46:51 <xrfang> isn't that type checking?
02:47:03 <BONUS> oh that. i'd suggest picking a different one though, since this one isn't really idiomatic :) like asking how you would do air conditioning in space
02:47:09 <BONUS> there's no air in space, etc.
02:47:16 <xrfang> Jedal: any newbie-understandable example of what do you mean by "expressive"?
02:47:18 <sjanssen> xrfang: well, "type checking" as a phrase has a specific meaning in the jargon, so let's not call it that
02:47:23 <Berengal> In Haskell there's no need for instanceof since there's no subtyping
02:47:23 <xrfang> vs. java etc.
02:47:31 <ivanm> BONUS: sure there is
02:47:34 <ivanm> it's just very, very diffuse
02:47:42 <sjanssen> xrfang: what it really is is type introspection of a sort
02:47:49 <xrfang> ok, no subtyping, but here we have "typeclass" which is "super-typing"?
02:47:49 <BONUS> hmm i've never been there yeah so i wouldn't really know
02:47:50 <Jedai> xrfang: typechecking is a technical term that doesn't mean what you're speaking about, so use type matching or something like that
02:48:09 <ivanm> xrfang: "type-checking" in Haskell means "hmmm... what type does this function have? I'll use :t in ghci to work it out!"
02:48:11 <Adamant> ivanm: Ada has probably the strongest type system for imperative languages
02:48:15 <BONUS> xrfang: typeclasses are nothing like the classes in java
02:48:17 <ivanm> Adamant: *nod*
02:48:32 <xrfang> ok, Jedal, so, we don't call it type checking, but type matching...
02:48:34 <Adamant> SPARK extends it further, I think
02:48:44 <Berengal> Well, typeclasses are somewhat like interfaces, except you always know what class they're off
02:48:50 <xrfang> does that make sense if my haskell "flatten" to try "type matching"?
02:48:54 <Berengal> (Unless you delve into existentials, but that way be dragons)
02:49:04 <DrSyzygyFR> Is haskell.org unhappy? I'm getting insane load times. :-/
02:49:12 <quicksilver> xrfang: what makes sense is to first consider the type the function has.
02:49:13 <bremner> DrSyzygyFR: same here
02:49:20 <xrfang> i.e. if flatten is defined as: flatten :: [[a]] -> a
02:49:22 <quicksilver> xrfang: and to note that all haskell functions have a type.
02:49:27 <xrfang> then we DO NOT need type matching
02:49:36 <quicksilver> xrfang: [[a]] -> [a] makes sense - that's a one-level flatten.
02:49:43 <xrfang> but without the signature,
02:49:44 <Jedai> xrfang: Your flatten could probably be expressed with overlapping instances
02:49:58 <xrfang> e.g. imagine flatten takes literally any parameter
02:49:59 <quicksilver> xrfang: if you were to design "MultiLevelList a" then "MultiLevelList a -> [a]" would probably also make sense
02:50:08 <xrfang> flatten [[a]] -> a
02:50:11 <quicksilver> xrfang: (and be pretty easy to to write once you'd defined the type)
02:50:14 <xrfang> flatten any -> any
02:50:29 <quicksilver> typically we call 'MultiLevelList', 'Tree', though.
02:51:02 <BONUS> haskell is statically typed, you can't have any -> any
02:51:07 <BONUS> that would defeat the whole purpose
02:51:14 * ivanm wished it was possible for modules that have a lot of overlap with the prelude to have two import lists... custom symbols, operators, etc. and everything
02:51:14 <xrfang> ok, say, a function is sort of "polymorphic"...
02:51:22 <Berengal> @type id
02:51:23 <lambdabot> forall a. a -> a
02:51:25 <Berengal> @type unsafeCoerce
02:51:26 <lambdabot> Not in scope: `unsafeCoerce'
02:51:28 <BONUS> i'd say let go of this problem (for now) and move on to more productive things instead of trying to write ruby in haskell
02:51:30 <Berengal> Hmm...
02:51:31 <xrfang> func [a] = "a list a"
02:51:42 <xrfang> func (a) = "a tuple a"
02:51:44 <xrfang> blah blah
02:51:54 <ivanm> BONUS: well, you started it by porting a ruby-style tutorial to haskell :p
02:51:54 <xrfang> now func takes many types right?
02:52:01 <BONUS> haha :D
02:52:05 <ivanm> s/ruby-style tutorial/ruby's tutorial style/
02:52:06 <quicksilver> xrfang: No. YOu can't do that.
02:52:12 <quicksilver> xrfang: functions have a single type.
02:52:17 <xrfang> oops.
02:52:22 <BONUS> oh god what have i done :]
02:52:32 <ivanm> the closest thing to having arbitrary number of arguments of different types is by having optional arguments in a record
02:52:34 <quicksilver> xrfang: that's a very important lesson.
02:52:44 <ivanm> which IIRC, ndm made "popular"
02:52:47 <xrfang> indeed
02:53:02 <Berengal> ivanm: Well, typeclasses sort of provide the type as an argument
02:53:19 <quicksilver> ivanm: In systems which need that, I prefer the combinator approch which most of the GUI librarys have taken.
02:53:21 <xrfang> I hope to finish LYAH within 2 days. I think after Typeclass 102, I will know more ... :) thanks all
02:53:23 <ErhardtMundt> jour
02:53:24 <ivanm> Berengal: hmmm...
02:53:31 <ivanm> quicksilver: oh? like what?
02:53:36 <quicksilver> openNewWindow [ size := (400,400), colour := red]
02:53:39 <quicksilver> that kind of thing.
02:53:44 <ivanm> *shudder*
02:53:50 <quicksilver> why shudder?
02:53:57 <quicksilver> it's strongly typed + expressive.
02:54:16 <ivanm> I thought augustss putting C and Basic into Haskell was bad enough, without introducing Pascal into it ;-)
02:54:26 <ivanm> quicksilver: how does that type-check? through the magic of the := operator?
02:54:29 <ivanm> @type (:=)
02:54:30 <lambdabot> forall a b. a -> b -> Assoc a b
02:54:40 <quicksilver> it's not magic.
02:54:41 <ivanm> @src Assoc
02:54:41 <quicksilver> But yes.
02:54:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
02:54:43 <xrfang> @src Complex
02:54:44 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
02:54:46 <ivanm> what's Assoc?
02:54:51 <quicksilver> I just made up (:=)
02:54:55 <quicksilver> the name doesn't matter.
02:54:56 <ivanm> quicksilver: heh
02:54:57 <quicksilver> it's the idea.
02:54:59 <sjanssen> ivanm: it type checks via overloading on the property names, 'size' and 'colour' will be classes
02:55:03 <ivanm> well, lambdabot knew what you were talking about :p
02:55:09 <ivanm> sjanssen: *nod*
02:55:23 <QtPlaty[HireMe]> :infor (:=)
02:55:30 <quicksilver> you might have size :: Property (Int,Int)
02:55:33 <ivanm> but what voodoo type magic is required to have it not complain about different types in a list, even if they're in the same typeclass?
02:55:35 <QtPlaty[HireMe]> :info (:=)
02:55:51 <quicksilver> and then have (:=) :: Property a -> a -> Assignment
02:55:52 <ivanm> QtPlaty[HireMe]: I don't think lambdabot knows that ghci option :(
02:55:53 <quicksilver> or something like that.
02:56:00 <ivanm> @hoogle Assoc
02:56:00 <lambdabot> Control.Parallel.Strategies data Assoc a b
02:56:00 <lambdabot> Text.Parsec.Expr data Assoc
02:56:00 <lambdabot> Text.ParserCombinators.Parsec.Expr data Assoc
02:56:05 <ivanm> ahhhh
02:56:07 <quicksilver> and then openNewWindow :: [Assignment] -> IO ().
02:56:09 <quicksilver> it's not magic.
02:56:12 <ivanm> actually, which one?
02:56:13 <quicksilver> it's just a type system :P
02:56:21 <sjanssen> ivanm: not very much magic at all
02:56:30 <quicksilver> it doesn't even need type classes.
02:56:35 <ivanm> ahhh
02:56:38 <quicksilver> although it probably needs an existential.
02:56:48 <quicksilver> and you might *choose* type classes to extend it in clever ways.
02:56:50 <sjanssen> using := for several different properties is the biggest hurdle
02:57:08 <xrfang> how do I know all available lambdabot tricks e.g. hoogle??
02:57:14 <ivanm> @list
02:57:14 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:57:16 <ivanm> ^^ xrfang
02:58:01 <xrfang> @list
02:58:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:58:07 <xrfang> thanks ;)
02:58:10 <xrfang> ^^ xrfang?
02:58:27 <Berengal> ↑
02:58:39 <Jedai> xrfang: That's just IRC jargon for look at what I just said
02:58:44 <ivanm> Berengal: show off ;-)
02:58:48 <Berengal> 3↑↑↑3 = ???
02:58:49 <DrSyzygyFR> I'm getting compilation errors when trying to write quickcheck properties.
02:59:05 <ivanm> Berengal: isn't that 3^(3^(3^3))) or something?
02:59:22 <xrfang> Berngal, thanks
02:59:33 <DrSyzygyFR> I'm following the model in the quickcheck manual, where you write something like prop foo = bar x y z where _ = x :: Type1; ...
02:59:38 <Berengal> ivanm: I think it's 3^(3^(3^3)) ↑ 3 actually
02:59:41 <sjanssen> quicksilver: that style would be very convenient if we had OCamls variants
02:59:45 <DrSyzygyFR> And I keep getting parse errors.
02:59:55 <ivanm> isn't  ↑ == ^ ?
03:00:06 <ivanm> sjanssen: oh? what are they?
03:00:19 <DrSyzygyFR> Anyone able to point me towards a better way to do it?
03:00:28 <sjanssen> ivanm: extensible sum types
03:00:40 <Berengal> ivanm: 3↑3 is 3^3, 3↑↑3 is 3^(3^(3^3))
03:01:04 * Hunner uses ^^ as eyes.
03:01:17 <ivanm> Berengal: oh, that's right, ↑n means to the power of n n times
03:01:26 <Berengal> ^_O  ← monocle
03:01:29 <quicksilver> sjanssen: you mean extensible variants? they're a can of worms arne't they?
03:01:42 <Berengal> ivanm: I can't really remember. It's been a while since I've used them
03:01:49 <Jedai> DrSyzygyFR: If you're getting parse errors, there's a syntax problem, which means you really have to pate your code if you want help
03:01:53 <Berengal> And I never used them for anything real...
03:01:55 <sjanssen> quicksilver: they probably are, but they'd certainly be handy at times
03:02:41 <sjanssen> quicksilver: have you looked at an implementation for any of the property systems?  I wonder if there is a trick to avoid all this boilerplate
03:03:10 <quicksilver> sjanssen: well I wrote something simplistic along these lines for openGL
03:03:31 <quicksilver> sjanssen: but it's only a single use case, it doesn't need to restrict properties for different calls
03:03:38 <DrSyzygyFR> Jedai: I found the issue.
03:03:52 <DrSyzygyFR> I had an unfinished start of an attempt to write an Arbitrary instance. And that was what screwed it all up.
03:04:17 <sjanssen> quicksilver: ie. it sidesteps the tricky part :)
03:04:44 <DrSyzygyFR> However....
03:04:45 <DrSyzygyFR> -- All shuffles are shuffles
03:04:45 <DrSyzygyFR> prop_shufflesareshuffles = all isShuffle (allShuffles i j)
03:04:45 <DrSyzygyFR>     where _ = i :: Int
03:04:45 <DrSyzygyFR>           _ = j :: Int
03:04:52 <quicksilver> sjanssen: yes. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4242
03:05:02 <DrSyzygyFR> Why do I get "Not in scope: i" and "Not in scope j" on this??
03:05:50 <dolio> Because there's no i and j declared anywhere in it or elsewhere in the file?
03:05:54 <ivanm> DrSyzygyFR: without even looking at it, because you're using variables that don't exist
03:06:23 <DrSyzygyFR> In that case, what makes it different from this:
03:06:24 <DrSyzygyFR> prop_RevRev xs = reverse (reverse xs) == xs where _ = xs :: [Int]
03:06:24 <ivanm> "where _ = i" ?
03:06:26 <DrSyzygyFR> ??
03:06:37 <ivanm> DrSyzygyFR: I don't even think that's legitimate
03:06:42 <DrSyzygyFR> ivanm: Adapted straight out of the QuickCheck documentation.
03:06:42 <ivanm> saying "where foo _ = xs" is
03:06:50 <ivanm> saying "where _ = xs" isn't AFAIK
03:06:59 <ivanm> DrSyzygyFR: and that example defines what xs is
03:07:05 <ivanm> yours doesn't define i and j
03:07:05 <DrSyzygyFR> Ahhhhhh
03:07:10 <DrSyzygyFR> Now I get it!
03:07:22 <Berengal> ivanm: It's allowed
03:07:23 <ivanm> > (_ = 1)
03:07:24 <lambdabot>   <no location info>: parse error on input `='
03:07:28 <ivanm> Berengal: it is? wtf does it do?
03:07:35 <ivanm> > (_ = 1) 2
03:07:36 <lambdabot>   <no location info>: parse error on input `='
03:07:38 <Berengal> ivanm: In this case: define the type
03:07:40 <sjanssen> quicksilver: ah, I hadn't even thought about inheritance yet
03:07:50 <Berengal> Otherwise it's useless I guess...
03:07:51 <ivanm> Berengal: of what? xs?
03:08:02 <ivanm> everything is xs? :s
03:08:03 <sjanssen> quicksilver: I suppose one could just cheat and append the properties to a list, and make the implementation take the last
03:08:14 <Berengal> ivanm: Looking at his function it says "where _ = i :: Int"
03:08:31 <ivanm> yes
03:08:41 <ivanm> so how does that get read/parsed? everything equals i? :s
03:09:04 <Berengal> Well... there's a variable, which name we don't care about, that equals i, and i is of type Int
03:09:39 <Berengal> @type foo bar = bar where _ = bar :: Int
03:09:41 <lambdabot> parse error on input `='
03:10:12 <Berengal> @type let foo bar = let _ = bar :: Int in bar in foo
03:10:13 <lambdabot> Int -> Int
03:10:20 <ivanm> Berengal: that's the thing, to me it looks like "I don't know what this is, I'll look through the where clause... oh, the _ matches what I'm looking up, it must be what I want!"
03:10:45 <Berengal> ivanm: _ doesn't match any name
03:10:58 <Berengal> Can't look up something you don't know the name of...
03:12:17 <Berengal> It's an alternative to lhs type signatures I guess...
03:12:24 <sjanssen> quicksilver: one thing this model doesn't really address are default arguments -- one can't access the defaults programmatically
03:16:35 <ivanm> sjanssen: is there anything like mapAccumL for FingerTrees? or just write a fold using the Foldable instance?
03:16:42 * ivanm guesses the latter
03:17:10 <ivanm> oh, and isn't mapAccumL actually a right fold? :s
03:17:12 <sjanssen> ivanm: be aware that maps on FingerTrees are going to be a bit more expensive than lists
03:17:22 <sjanssen> the cached measurements have to be recalculated
03:17:32 <ivanm> sjanssen: yeah...
03:18:24 <ivanm> I'm wondering whether I should go back and forth from lists (OK, I'm only going from list to FingerTree in the middle) and by "replacing" a value with a list "in-situ" just concat'ing the map...
03:18:36 <ivanm> or try and do _everything_ with finger trees :s
03:18:42 <dibblego> haskell.org is grindingly slow
03:18:51 <ivanm> dibblego: it has been said already
03:18:56 <ivanm> so no, you're not special :p
03:19:04 <sjanssen> ivanm: I'd say only use FingerTree when you benefit from measurement or split
03:19:11 <ivanm> *nod*
03:19:14 <ivanm> OK, I'll do that then
03:20:11 <DrSyzygyFR> Hmmm. With break-on-error but without running with :trace - what kind of information can I gather at all about the stack overflow I'm running into?
03:20:17 <ivanm> oh, wait, damn, I can't use (second concat) . mapAccumL ... I _do_ have to use the new values when recursing :(
03:20:49 <ivanm> and there doesn't seem to be a mapExpandAccumL function :p
03:29:20 <dibblego> @hoogle FilePath -> IO Bool
03:29:20 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
03:29:20 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
03:29:20 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
03:29:27 <dibblego> @hoogle FilePath -> IO ()
03:29:27 <lambdabot> System.Directory createDirectory :: FilePath -> IO ()
03:29:27 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
03:29:27 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
03:29:50 <dibblego> how do I delete a file?
03:30:08 <Berengal> @hoogle removeFile
03:30:09 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
03:30:32 <dibblego> ta
03:45:09 <eden> Hi  folks, anyone experienced with parsec in today? I've used it myself, but have got kinda stuck...
03:45:35 <byorgey> eden: what's the problem?
03:47:18 <eden> I'm trying to write a java style unicode preprocessor before the parsing proper, but want errors to have to the column number as it was before preprocessing
03:48:13 <byorgey> yikes, that sounds complicated =)
03:49:41 <SamB> or at least fantastically inefficient
03:50:06 <SamB> eden: what are you doing with ... tabs?
03:50:10 <eden> it's why I'm stuck. Apparently haskell does this kind of preprocessing as well as java.
03:50:39 <SamB> first I've heard of it!
03:51:53 <eden> says so in the report under lexical structure. I'm going to use IndentParser, which handles the tabs.
03:52:12 <SamB> oh, that
03:52:45 <SamB> ... what does that have to do with Unicode ?
03:54:45 <eden> since I'm trying to make a preprocessor to convert \uXXXX into ordinary characters, it has nothing at all to do with tabs.
03:55:15 <SamB> I just meant with regards to the column numbers
03:56:06 <SamB> if you have "\t\\uDEAD\\uBEEF" as input, what column do you say that \uBEEF is in ?
03:56:41 <SamB> another question is: how do you parse \\?
03:56:49 <SamB> :t (\\)
03:56:50 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:57:04 <SamB> did you say you were doing this for Haskell?
03:57:23 <SamB> or that you are parsing some other language
03:57:46 <eden> No, I'm toying with some language ideas of my own.
03:58:07 <SamB> okay, because it would be kind of awkward to have to type \\\\ to get that operator ;-P
03:58:45 <SamB> (and plus it would be a real pain to tack your preprocessor onto an actual compiler ;-)
03:59:35 <sior|oifig> @src foldr
03:59:35 <lambdabot> foldr f z []     = z
03:59:35 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:00:00 <pozic> Why doesn't :i Testlike work in a module where import Test.Framework is done?
04:00:18 <SamB> pozic: is it spelled TestLike ?
04:00:28 <pozic> SamB: not according to the documentation
04:00:38 <SamB> pozic: okay, haven't used that
04:00:45 <pozic> http://hackage.haskell.org/packages/archive/test-framework/0.2.1/doc/html/Test-Framework.html#t%3ATestlike
04:01:02 <SamB> but I've run into problems where I use the wrong capitalization before, so I thought it was worth checking ;-)
04:01:44 <pozic> It seems the class is not exported, although it is visible in the documentation.
04:01:54 <SamB> now that's wierd!
04:02:06 <eden> That's exactly why I'm stuck. I could try to parse (Int, Char) lists, but that would be horrible, both stylisticlly and effeincy
04:02:20 <pozic> In ghci import Test.Framework :browse
04:02:53 <SamB> eden: not TOO much worse than String itself
04:02:56 <SamB> lets see ...
04:03:16 <SamB> how many words does a (,) take, and how many does an Int take?
04:03:38 <SamB> does (,) take 3 and Int take 2?
04:03:47 <SamB> (in the nursery)
04:04:59 <SamB> eden: maybe you should just include the handling at the low level of your lexer somehow
04:07:20 <eden> This was my original idea, but it's hard to know how to correctly parse identifiers (for example) that contain \\uXXXX, which when converted are legitimate.
04:07:48 <eden> I mean \uXXXX
04:08:06 <SamB> eden: that's why I say at the low level
04:08:55 <eden> okay, what sort of low level do you mean?
04:09:21 <ivanm> the bit under the high level ;-)
04:09:57 <SamB> well, you could write your own AlexInput, alexGetChar, and alexInputPrevChar
04:10:45 <SamB> http://haskell.org/alex/doc/html/api.html
04:12:13 <eden> right. I assume there's a way of hooking these into parsec. gives me something to look at anyway.
04:14:57 <eden> might make indentation based stuff hard, but I suppose I could copy Python's idea of inserting INDENT, NEWLINE and DEDENT tokens into the stream.
04:16:24 <SamB> eden: I'd not suggest using Parsec for anything this complicated, personally
04:22:47 <eden> it's very possible that you've got the right idea.
04:24:12 <trofi> @pl map (\((a,n), k) -> (a, n*k)) xs
04:24:13 <lambdabot> map (uncurry (uncurry ((. (*)) . (.) . (,)))) xs
04:24:54 <SamB> Parsec needs a ton of hand-holding if you use CharParsers, and a lot of it's functions only work for CharParsers :-(
04:26:14 <SamB> but don't feel like "argh! I might as well have used any language as Haskell, if I don't get to use a combinator library but have to use a lexer-generator and parser-generator!"
04:26:57 <SamB> because it's not true -- most of those require you to deal with a ton of messy state
04:27:30 <SamB> whereas Alex and Happy let you deal in essentially as much or as little state as you like
04:28:33 <SamB> hmm, interesting haskell.org favicon
04:29:12 * SamB wonders if the voting page(s) included favicon-sized renditions of the choices
04:29:22 <mmorrow> unfortunately alex doesn't do unicode directly, but iirc there's a way around that
04:29:43 <SamB> hmm.
04:29:59 <mmorrow> i think it's referred to as a "hack" ;) :/
04:30:21 * SamB wonders if there are any PhD or masters theses in that
04:32:42 <Berengal> Is there a way to make parsec parse not just streams of characters but streams of other types?
04:32:54 <byorgey> Berengal: yup.
04:32:59 <Berengal> How?
04:33:10 <byorgey> the parser type is polymorphic in the type of elements of the stream.
04:33:39 <Berengal> Are there any primitive polymorphic characters as well?
04:33:44 <Berengal> parsers*
04:34:04 <byorgey> Berengal: almost all of the primitives are polymorphic.
04:34:08 <byorgey> except 'char' and 'string'.
04:34:32 <Berengal> What's the analogous parser to those two then?
04:35:38 * Berengal currently has an ugly parser dealing with lots of whitespace and would like to tokenize
04:35:49 <quicksilver> "token"
04:36:22 <quicksilver> and friends.
04:36:42 <Berengal> I'll have to look into it
04:36:47 <Berengal> This made me very happy
04:38:01 <quicksilver> I always tokenise
04:38:19 <quicksilver> for anything except the most trivial cases
04:39:26 <Berengal> Parsec really is awesome...
04:41:16 <quicksilver> I don't like parsec.
04:41:36 * ivanm has never played that game
04:43:09 <Berengal> It beats writing your own parser or bringing out the big guns found in other languages
04:43:32 <ivanm> Berengal: Parsec-the-parser isn't a big gun?
04:43:43 <quicksilver> Berengal: I prefer other parser combinator librarys.
04:43:49 <quicksilver> Like one I might write myself in 10 minutes.
04:43:51 <quicksilver> or polyparse.
04:43:53 <QtPlaty[HireMe]> How does parsec parse?
04:44:10 <DrSyzygyFR> Combinatorially. :-P
04:44:42 <Berengal> I pretty much just imported parsec and wrote a parser for my (admittedly minimal) language in less than an hour
04:44:52 <Berengal> Having very little experience with it before
04:44:56 <Berengal> That makes it lightweight
04:45:05 <QtPlaty[HireMe]> I mean bottem up or bottem down?  Or is that just irrelevent
04:45:18 <QtPlaty[HireMe]> ?
04:46:03 <Berengal> Top-down I'd say
04:47:25 <Berengal> I, at least, just started with expr = try letExpr <|> try varExpr <|> try primOp ... and went from there
04:47:28 <QtPlaty[HireMe]> Has there been any work at building a bottem up combernational parser.
04:48:09 <wli> X-SAIGA
04:50:43 <eden>   
04:52:02 <trofi> @src iterate
04:52:08 <lambdabot> iterate f x =  x : iterate f (f x)
04:57:35 <wli> let iterate f x = let ys = x : map f ys in ys?
04:58:05 <ivanm> wli: need an extra "in" there...
04:58:33 <ivanm> but the definition given above is better
04:58:33 <EvilTerran> "iterate f x = ys where ys = x : map f ys"
04:58:39 <wli> I didn't mean to put the first one in in the first place.
04:58:42 <ivanm> yours you manually apply f multiple times to each value
04:59:01 <ivanm> whereas iterate just keeps applying it one extra time for the next value
04:59:20 <eden> SamB: Having had a quick peruse of alex, I think it leaves me with much the same problem.
04:59:56 <wli> ivanm: I'm not actually sure which one you said was better.
05:00:07 <ivanm> wli: the one actually defined
05:00:47 <ivanm> for the one you said, it comes down to being [x, f x, f (f x), f (f (f x)), ...] <-- how it is actually defined
05:01:04 <ivanm> whereas by doing x : iterate f (f x), it "shares" previous defs
05:01:51 <wli> i.e. the list is counterproductive?
05:02:20 <ivanm> ummmm.... I wouldn't say that
05:02:21 <dolio> ys = x : map f ys is something like O(n^2), where n is the number of elements you demand.
05:02:31 <ivanm> and iterate is O(n)
05:03:11 <ivanm> or maybe O(n log n)...
05:03:38 <wli> I don't seem to get quadratic behavior.
05:04:26 <dolio> Hmm, I may be wrong about that.
05:05:08 <dolio> Now I'm conflicted.
05:05:35 <uccus> in fact, I'm reading Bird & Wadler at the moment, and they seem to claim wli's version is better indeed due to sharing. I think the src version is better due to tail recursion. any thoughts?
05:05:49 <ivanm> wli: for index i, you're applying f i times
05:06:08 <ivanm> with iterate, index i only calls f one more time than (i-1)
05:06:34 <dolio> It isn't calling f i times, though, actually.
05:06:53 <jlaire> uccus: what tail recursion?
05:07:02 <ivanm> dolio: wli's map version
05:07:18 <dolio> Because the first time you get to an element, it gets memoized.
05:07:19 <uccus> jlaire: tail rec modulo cons? :D
05:07:20 <dolio> Right.
05:07:38 <ivanm> dolio: ummm.... I thought Haskell didn't have memoization?
05:07:48 <dolio> It does when values are shared.
05:07:58 <ivanm> dolio: how are they shared here?
05:08:15 <smtms> I thought nobody prevented any Haskell implementation from memoizing
05:09:02 <quicksilver> nobody prevents it, but they don't need to prevent it
05:09:10 <quicksilver> no implementation does anyway because it would be stupid.
05:09:22 <quicksilver> however, all implementations share explicitly named values.
05:09:29 <quicksilver> let x = f y in x + x
05:09:35 <quicksilver> ^^ x only calculated once, of course.
05:11:20 <trofi> @src group
05:11:21 <lambdabot> group = groupBy (==)
05:11:24 <trofi> @src groupBy
05:11:24 <lambdabot> groupBy _  []       =  []
05:11:24 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:11:24 <lambdabot>     where (ys,zs) = span (eq x) xs
05:11:35 <trofi> > group [1,2,1,2]
05:11:37 <lambdabot>   [[1],[2],[1],[2]]
05:11:47 <dolio> Well, there's an easy way to settle it...
05:12:11 <trofi> > group $ sort [1,2,1,2]
05:12:12 <lambdabot>   [[1,1],[2,2]]
05:14:19 <trofi> @hoogle ':: [(a,b)] -> [(a,[b])]'
05:14:20 <lambdabot> Parse error:
05:14:20 <lambdabot>   --count=20 "':: [(a,b)] -> [(a,[b])]'"
05:14:20 <lambdabot>              ^
05:15:25 <dolio> ivanm: Okay, so, it does have the same f-calling behavior as the library definition.
05:15:34 <QtPlaty[HireMe]> @dijin [(a,b)] -> [(a,[b])]
05:15:34 <lambdabot> Error: Undefined type []
05:15:55 * QtPlaty[HireMe] wonders why dijin doesn't know about lists.
05:16:09 <dolio> ivanm: The reason is that each element of ys only has to be computed once.
05:16:53 <kpreid> QtPlaty[HireMe]: recursion is hairy
05:17:01 <ivanm> oh, duh...
05:17:33 <dolio> ivanm: So when the outermost map f looks at the second element of ys (to generate the third element), it's already been computed, and so on.
05:17:56 <dolio> It looks bad when you inline definitions, because that doesn't show sharing.
05:18:10 <ivanm> *nod*
05:18:55 <LeCamarade> Is that function called intersperse? The one that puts x between all members of l?
05:19:05 <dolio> I was thinking that it did more cons construction/destruction, but I don't think it's O(n^2) there, either.
05:19:37 <LeCamarade> Yes. Data.List.intersperse.
05:19:44 <dolio> Probably only O(n) more work total, if that.
05:20:40 <ivanm> dolio: eh, the actual definition looks cleaner to me anyway
05:22:04 <eden> Ah well. I'll have to do a bit of harder thinking and some experimentation.
05:23:04 <dolio> ivanm: Well, certainly, I don't have to think about it to verify that it shares things right. :)
05:23:57 <dolio> And didn't have to use unsafePerformIO to convince myself. :)
05:24:38 <wli> check using vacuum?
05:24:39 <LeCamarade> What name is given to this kind of data type where this is the definition: data Void
05:24:57 <LeCamarade> That is, with no constructors?
05:24:58 <ivanm> LeCamarade: () ?
05:25:08 <ivanm> or Not ?
05:25:14 <ivanm> LeCamarade: oh, wait, no =...
05:25:19 <ivanm> that requires an extension IIRC
05:25:27 <LeCamarade> Yes, but I forget the name.
05:25:34 <LeCamarade> "Existential"?
05:25:40 <dolio> I haven't used vacuum. Will it tell me how many times a function is called to produce the same output list?
05:25:51 <idnar> LeCamarade: phantom?
05:25:55 <EvilTerran> LeCamarade, phantom type
05:25:56 <doserj> -XEmptaDataDecls
05:26:20 <dolio> I thought it just showed sharing, and the sharing in the output of both will be the same: none.
05:26:22 <LeCamarade> Phantom, yes.
05:26:23 <C-Keen>  
05:26:42 <ivanm> I thought phantom type was something like "newtype FooInt a = Foo Int" :s
05:26:51 <doserj> so did I
05:27:02 <ivanm> dolio: I think it shows so graphically
05:27:02 <wli> What do the two different iterate functions look like in vacuum?
05:27:05 <ivanm> have to ask mmorrow though
05:27:10 <ivanm> wli: have a look! :p
05:27:24 <dolio> That is, unless you do 'iterate id x' and the compiler optimizes map id to id, in which case the 'ys = x : map f ys' version will be better.
05:27:38 <ivanm> dolio: oh? why?
05:28:04 <dolio> Because then you get 'ys = x : map id ys = x : id ys = x : ys' which is a circular representation.
05:28:13 <dolio> But that's a pretty special case.
05:28:14 <ivanm> iterate id == repeat, right?
05:28:16 <EvilTerran> , let iter f x = x : iter f x in vacuum . take 4 $ iter (():) []
05:28:18 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,1])]
05:28:20 <ivanm> dolio: oh, can ghc pick that up?
05:28:26 <EvilTerran> , let iter f x = xs where xs = x : map f xs in vacuum . take 4 $ iter (():) []
05:28:28 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[5,1]),(4,[6,7]),(5,[]),(6,[5,3]),(7,[8,1]...
05:28:40 <dolio> It might have a RULE for map id = id.
05:28:42 <ivanm> oh, lunabot has a cut-down vacuum, does it?
05:28:46 <ivanm> dolio: *nod*
05:28:57 <EvilTerran> ^ for ghc, then, it seems the first one wins
05:28:59 <ivanm> so it'll become let ys = x : ys ?
05:29:12 <ivanm> EvilTerran: \o/
05:30:23 <EvilTerran> er, wait, my first one was wrong. hang on.
05:30:33 <EvilTerran> , let iter f x = x : iter f (f x) in vacuum . take 4 $ iter (():) []
05:30:35 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[5,1]),(4,[6,7]),(5,[]),(6,[5,3]),(7,[8,1]...
05:30:43 <EvilTerran> ... they're the same! :D
05:31:02 <ivanm> EvilTerran: :/
05:32:44 <dolio> iter f x = x : iter f x is definitely bad. That gets O(n^2) behavior.
05:32:58 <dolio> Er, x : map f (iter f x)
05:33:10 <opqdonut> err, not?
05:33:10 <ivanm> no sharing?
05:33:15 <EvilTerran> dolio, vacuum disagrees there
05:33:54 <mmorrow> , vacuum (fix (\x -> 0 : x))
05:33:56 <lunabot>  [(0,[1,0]),(1,[])]
05:34:14 <mmorrow> , vacuum (cycle [0])
05:34:16 <lunabot>  [(0,[1,0]),(1,[])]
05:34:18 <mmorrow> , vacuum (repeat 0)
05:34:20 <lunabot>  [(0,[1,0]),(1,[])]
05:34:30 <mmorrow> i thought that one was gonna get killed
05:34:40 <ygui> hi there :) I have a question about "import Control.Parallel" in "Haskell in 5 Steps", I got an error message saying it does not exist.  Do I need to install this package separately? I'm using GHC 6.8.2.
05:34:46 <dolio> , vacuum (iterate id 0)
05:34:53 <lunabot>  Killed.
05:34:57 <EvilTerran> , vacuum [(),()..]
05:34:59 <lunabot>  [(0,[1,0]),(1,[])]
05:35:00 <mmorrow> infinite list
05:35:08 <ivanm> ygui: probably
05:35:09 <opqdonut> , vacuum (iterate (const 0) 0)
05:35:16 <lunabot>  Killed.
05:35:17 <EvilTerran> , vacuum [0 :: Int,0..]
05:35:19 <opqdonut> hmm
05:35:23 <lunabot>  Killed.
05:35:30 <ygui> oh, ivanm, let me see...
05:36:05 <ivanm> ygui: yeah, you need the parallel library
05:36:16 <mmorrow> , let ntimes n = foldr (.) id . replicate n in fmap (vacuum . ($ 0) . flip ntimes id) [0..]
05:36:18 <lunabot>  [[(0,[])],[(0,[])],[(0,[])],[(0,[])],[(0,[])],[(0,[])],[(0,[])],[(0,[])],...
05:36:26 <dolio> Where does vacuum disagree with me? Because I already verified that 'iterate f x = x : map f (iterate f x)' calls f O(n^2) times.
05:36:55 <ygui> ivanm: then, where do I find this library? on haskell.org?
05:37:01 <ivanm> @hackage parallel
05:37:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parallel
05:37:03 <EvilTerran> dolio, well, vacuum indicates that the sharing is identical to "iterate f x = x : iterate f (f x)"
05:37:07 <ivanm> ygui: which OS/distribution are you using?
05:37:20 <wli> iterate f x = let ys = x : map f ys in ys is another story OTOH
05:37:33 <dolio> Right. That one's fine.
05:37:39 <EvilTerran> ah, i see the difference
05:37:45 <EvilTerran> yeah. i think we're in agreement, then :P
05:37:48 <mmorrow> , let iter f x = fix (\xs -> x : map f xs) in vacuum (iter id 0)
05:37:55 <lunabot>  Killed.
05:37:59 <ygui> I'm using DreamLinux 3.5, based on Debian Linux
05:38:07 <mmorrow> , let iter f x = fix (\xs -> x : map f xs) in vacuumTo (iter id 0)
05:38:08 <lunabot>  luna: Not in scope: `vacuumTo'
05:38:10 <mmorrow> , let iter f x = fix (\xs -> x : map f xs) in vacuumTo 4 (iter id 0)
05:38:11 <lunabot>  luna: Not in scope: `vacuumTo'
05:38:21 <vixey> ooh vacuum was in my dream I think
05:38:25 <dolio> Yeah, it's the same situation as "fix f = x where x = f x" versus "fix f = f (fix f)".
05:38:31 <mmorrow> vixey: ooh, yay!
05:38:53 <vixey> I think I was profiling something very meticulously and using vacuum a lot
05:39:08 <mmorrow> vixey: :)!
05:39:12 <ygui> ivanm, I'm using DreamLinux 3.5, a debian-based distribution.
05:39:16 <ivanm> ygui: no idea about that one
05:39:17 <vixey> (other people dream about flying and so on..)
05:39:28 <ivanm> you might be able to use debian packages, but I don't know what stage they're at either
05:39:39 <ivanm> ygui: your best bet is probably to get cabal-install and use that
05:39:42 <ivanm> @where cabal-install
05:39:43 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
05:39:44 <mmorrow> vixey: i updated vacuum-gl, it no longer segfaults when used with -threaded, since i realized that OpenGL uses thread-local state, so i have to forkOS
05:39:48 <ivanm> ygui: ^^ have a look there
05:40:16 <ygui> ok, ivanm, lambdabot, thanks!
05:40:20 <ygui> let me try.
05:40:32 <ivanm> good work, lambdabot :p
05:40:34 <ivanm> @bot
05:40:35 <lunabot>  :)
05:40:36 <lambdabot> :)
05:40:41 <ivanm> no, not you lunabot
05:40:41 <mmorrow> it's pretty stable too, -/+ zoom, arrows move, and it can handle, e.g., forkIO'ing 40 threads all inserting random values into an IntMap in an MVar, and 'view'ing every insert, so you can watch the tree grow in realtime
05:41:04 * mmorrow makes a screenvideo
05:41:13 <ivanm> mmorrow: control your bot, it keeps stealing all of lambdabot's snacks! :p
05:41:28 <mmorrow> ivanm: :)
05:43:32 <quicksilver> mmorrow: ooh, that sounds nice.
05:44:17 <dolio> Did you add some bloom?
05:44:35 <dolio> You last screenshot was severely lacking it.
05:44:58 <ivanm> dolio: you mean "boom"?
05:45:08 * ivanm wants to know where the earth-shattering kaboom was...
05:45:08 <ivanm> ;-)
05:45:15 <Berengal> How long until we can blast aliens inbetween fingertrees?
05:45:33 <dolio> No, bloom: http://en.wikipedia.org/wiki/Bloom_(shader_effect)
05:47:46 <mmorrow> quicksilver: it's neato. i've been looking through your forces too.
05:48:00 * mmorrow fails first attempt at a screenvideo
05:48:14 <mmorrow> http://moonpatio.com/repos/vacuum-gl/
05:48:24 <ivanm> mmorrow: how does neato compare to dot for the graphs?
05:48:37 <ivanm> or do you mean "neat-o", as in "cool", "rad", etc.? ;-)
05:48:43 <mmorrow> ivanm: oooh, it's pretty cool in some cases. one sec for a screenshot
05:48:57 <ivanm> that's more than one sec! :@
05:48:57 <ivanm> ;-)
05:49:02 <fasta> I would like to add another test executable to the cabal file, but I read somewhere that it's not intended to be used like that. I also don't want to copy all the information manually from the one cabal file to the other. I could write a program which does this, but that seems a bad idea also. Is there a sane solution for this?
05:49:13 <quicksilver> mmorrow: I'm sure yours is much cleverer than mine. Mine was merely an agreement with peter V's assertion that it "ought to be easy" ;)
05:49:17 * ivanm thinks mmorrow is lying about this vacuum app, and is doing everything by hand... using trained monkeys! :p
05:49:32 <ivanm> fasta: not sure what you're wanting here...
05:50:06 <dcoutts> fasta: the sane solution is to extend cabal, but perhaps you're looking for a quick hack?
05:50:09 <ivanm> and I always find it really annoying when devs include their QC, etc. tests in their packaged tarballs... surely they should either require an optional flag or be only found in the development repo?
05:50:18 <vixey> "you can watch the tree grow in realtime" -- sounsd cool
05:50:24 <mmorrow> ivanm: http://moonpatio.com/vacuum/gallery/neato_vac.png
05:50:54 <fasta> ivanm: I want to basically have cabal generate two executables. One is the real program, the other is a program which runs the test suite. I could also write shell scripts to do this, but then it won't work on Windows, without work.
05:51:03 <mmorrow> quicksilver: i've been using your code as examples for HsOpenGL stuff
05:51:22 <ivanm> mmorrow: my mum says it's "perty", but should be symmetrical... :p
05:51:45 <mmorrow> quicksilver: and i don't do any 3D, just 2D textures of image data slurped from graphviz
05:52:01 <fasta> mmorrow: dot can do symmetrical graphs too.
05:52:13 <mmorrow> ivanm: iirc neato uses a randomized algo, so no two neato renderings are ever the same
05:52:18 <mmorrow> fasta: oh nice
05:52:24 <ivanm> fasta: can it? dot is for hierarchical graphs, isn't it?
05:52:36 <ivanm> mmorrow: I'm pretty sure that it's pretty much the same all the time
05:52:41 <ivanm> at least by default
05:53:03 <ivanm> I recall playing around with random stuff in dot at least to see what changes it made to some of my graphs, and the answer was "not much" :s
05:53:40 <ivanm> mmorrow: but really... a haskell user like yourself, and you don't use xmonad? for shame!
05:53:41 <ivanm> :p
05:53:57 <ivanm> mmorrow: I like the message your script produces though :p
05:54:23 <Berengal> It's the new hello world
05:54:47 <Berengal> Didn't you get the memo?
05:54:56 <fasta> mmorrow: it appears neato does so, according to https://mailman.research.att.com/pipermail/graphviz-interest/2006q1/003336.html
05:54:59 <ivanm> Berengal: so you're saying we need to do a global "s/Hello World/O HAI/g" ?
05:55:14 <Berengal> ivanm: No that would be silly...
05:55:24 <Berengal> "s/foo/bar/g" is already global ;)
05:55:31 <ivanm> Berengal: global for that _file_
05:55:31 <xrfang> @src True
05:55:32 <lambdabot> Source not found. Maybe you made a typo?
05:55:37 <ivanm> I'm saying to do it over the entire _globe_
05:55:41 <xrfang> > let a = true
05:55:42 <lambdabot>   <no location info>: parse error on input `;'
05:55:49 <xrfang> > let a = True
05:55:50 <lambdabot>   <no location info>: parse error on input `;'
05:56:02 <xrfang> > let a = True in print a
05:56:03 <lambdabot>   * Exception: "<IO ()>"
05:56:21 <Berengal> ivanm: Which is everything with the right block device... stop correcting my mistakes :P
05:56:30 <beelsebob> gah
05:56:31 <xrfang> @list
05:56:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:56:34 <beelsebob> why doesn't ftgl work :(
05:56:36 <ivanm> Berengal: heh
05:56:42 <ivanm> beelsebob: you mean fgl?
05:56:48 <beelsebob> no, I mean ftgl
05:56:59 <beelsebob> freetype gl
05:57:02 <xrfang> > 1 == 1
05:57:03 <lambdabot>   True
05:57:06 <ivanm> ahhhhh
05:57:07 <Berengal> faster than greased lightning?
05:57:34 <Berengal> ?src Bool
05:57:34 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:59:03 * ivanm thinks someone needs to run sort on lambdabot's channel list shown by "@seen lambdabot"
05:59:07 <beelsebob> I managed to fix this before... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=1766
05:59:12 <beelsebob> but I can't figure out how the hell I did it
06:00:14 <mmorrow> anyways, i fail at screen-capture. here's the code to grow an IntMap with a bunch of threads inserting randomly http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2251#a2251
06:00:32 <xrfang> can I define a infix function without ` ?
06:00:45 <beelsebob> xrfang: yes, using symbols
06:00:55 <mmorrow> ivanm: heh, i use xmonad on-and-off... i like to switch it up
06:00:58 <quicksilver> mmorrow: Ah, ok. Cute.
06:01:03 <mmorrow> fasta: interesting
06:01:09 <beelsebob> > let x <^^^/+\^^^> y = x + y in 5 <^^^/
06:01:10 <lambdabot>   <no location info>: parse error on input `;'
06:01:11 <beelsebob> gah
06:01:16 <beelsebob> > let x <^^^/+\^^^> y = x + y in 5 <^^^/+\^^^> 6
06:01:18 <lambdabot>   11
06:01:19 <xrfang> beelsebob: you mean the function name contains only symbol, no letters?
06:01:23 <beelsebob> indeed
06:01:36 <beelsebob> there you go – 5 flying saucer 6 is 11
06:01:37 <mmorrow> quicksilver: yeah, i wish there was some sort of way to "instrument" the heap so, say, evaluating a node would cause it to be drawn or something
06:01:38 <fasta> mmorrow: graphviz is sort of amazing in that it has advanced algorithms, which are actually implemented.
06:01:56 <mmorrow> quicksilver: but i think you'd need to be in C-land to do that (or do it during compilation)
06:02:09 <mmorrow> fasta: yeah, graphviz is great
06:02:26 <fasta> mmorrow: most algorithms of that level are either only have proprietary implementations or only exist in some buggy version in a book (aka, does not exist).
06:02:43 <wli> I wish I were capable of implementing advanced algorithms.
06:02:49 <wli> fasta: Surely you mean a paper.
06:02:57 <Berengal> let 2 + 2 = 5; a + b = a - (-b) in (5 + 2, (3-1) + (1+1))
06:02:59 <xrfang> If I want to define a function %, I will need to write (%) right?
06:03:03 <fasta> wli: eh, yes.
06:03:05 <Berengal> > let 2 + 2 = 5; a + b = a - (-b) in (5 + 2, (3-1) + (1+1))
06:03:07 <lambdabot>   (7,5)
06:03:34 <fasta> wli: implementing advanced algorithms is not difficult, it's figuring out what the paper tries to communicate incompletely and incorrectly.
06:04:18 <EvilTerran> xrfang, you can write "x % y = ..."
06:04:30 <wli> fasta: That's already beyond me in all known instances.
06:04:42 <xrfang> EvilTerran: I am writing a subString function as an exercise
06:04:49 <xrfang> I choose to use % to name the function
06:05:02 <xrfang> I have to write (%) :: [a] -> [a] -> Bool
06:05:10 <xrfang> if I write % :: ... it does not compile
06:05:14 <EvilTerran> yeah, *there* you have to write it in ()s
06:05:22 <xrfang> tks
06:05:32 <EvilTerran> but not in the actual definition, just in the type signatures
06:05:44 <ivanm> fasta: heh, I was interested in implementing the VFLib isomorphism algorithm... it's very vague/general (note that they do have a C++ implementation though)
06:05:49 <Berengal> ?src (%)
06:05:49 <lambdabot> x % y = reduce (x * signum y) (abs y)
06:05:53 <Berengal> @type (%)
06:05:55 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
06:06:05 <ivanm> whilst it's bad and unreadable, at least the nauty paper's algorithm can be slogged out because it's all there
06:06:17 <ivanm> not just "hey, look, here's a high-level overview... isn't it cool?" :s
06:06:27 <wli> ivanm: What sort of isomorphism? Graph isomorphism?
06:06:32 <ivanm> yup
06:06:38 <ivanm> I know about hgal
06:06:51 <ivanm> it just seems to be very inefficient here :s
06:07:01 <ivanm> especially since nauty is often touted as being really fast :s
06:07:15 * ivanm is trying to re-implement it from scratch atm
06:07:33 <wli> I'm struggling hard enough with ways to factor polynomials over algebraic number fields or otherwise find roots in algebraic number fields.
06:08:12 <quicksilver> mmorrow: sounds like an RTS hook, yes, although not a stupid one to ask for.
06:08:13 <fasta> ivanm: is this going to be on Hackage or not? Either way, it will probably be hard to beat graphviz.
06:08:23 <quicksilver> mmorrow: currently vacuum forces as it goes, doesn't it?
06:08:28 <ivanm> fasta: graph isomorphism, not graph drawing ;-)
06:08:39 <ivanm> though matthew-_ is dumping his graphviz bindings onto me :s
06:09:38 <wli> I'm trying to do things like simplify (35*2^(4/5)+35*2^(3/5)+23*2^(2/5)+21*2^(1/5)+43)^(1/7) to 2^(1/5)+1
06:09:46 <fasta> ivanm: right
06:10:05 <xrfang> the notion @ can be used in lambda only or anywhere? e.g. l@(x:xs) etc.
06:10:16 <fasta> ivanm: I thought someone had written a P algorithm for graph isomorphism recently.
06:10:24 <EvilTerran> xrfang, anywhere in patterns
06:10:29 <xrfang> I try to define a function e.g. test x y, while x and y is list
06:10:32 <xrfang> tks
06:10:45 <ivanm> fasta: oh? AFAIK, the graph isomorphism problem is not know to be either P or NP :s
06:10:56 <fasta> ivanm:  http://pierre-menard.blogspot.com/2007/12/graph-isomorphism-is-in-p.html
06:11:01 * ivanm really should stop responding to people talking to him here and get some shut-eye...
06:11:31 <fasta> ivanm: yes, it was unknown for a long time, and arguably still is, until the "community" claims this result is correct.
06:11:33 <ivanm> fasta: a lot of these are proven to be wrong...
06:11:46 <fasta> ivanm: yes, that's what I said :)
06:12:07 <ivanm> heh
06:12:39 <vixey> fasta, *wonders if that blog is a hoax or not*
06:12:45 <ivanm> fasta: I find it interesting that the blog post is from 2007, but the paper is dated in feb last year...
06:12:53 <fasta> vixey: the paper isn't a hoax.
06:12:56 <vixey> fasta: I was reason proofs of P = NP on that webiste the other day
06:13:09 <vixey> arxiv
06:13:14 <fasta> vixey: yes, but that website is not a joke.
06:13:31 * ivanm really goes to bed this time
06:13:33 <ivanm> g'night
06:13:46 * vixey tries to decode  "In China today, Bill Gates is Britney Spears. In America today, Britney Spears is Britney Spears - and that is our problem."
06:14:29 <nanothief> With template haskell, is there a way to get the type of an Exp?
06:14:56 <QtPlaty[HireMe]> vixey: Bill Gates is a celbrity in china, Britney Spears is a celbrity in the US.  This is problem.
06:15:09 <wli> vixey: Apparently the Chinese reputedly find captains of industry to be worthwhile people, while usanians find drug-addled "recording artists" to be worthwhile people.
06:15:28 <Frontier> http://froni.mybrute.com come kill me
06:15:29 <vixey> oh cool I see
06:16:07 <Frontier> http://froni.mybrute.com come kill me
06:17:06 <wli> Apparently neither place value on science, engineering, or other such concerns.
06:17:10 <mmorrow> quicksilver: yeah, it's currently forcing as it goes... there's some weird segfault occurring if it doesn't force everything, but i think it must be something stupid i'm doing and not an inherent limitation..
06:17:29 <mmorrow> quicksilver: that would definitely be a nice hook to have
06:17:39 * juhp_ wonders why runghc is not working
06:18:24 * wli probably falls into some limbo since he regards drug-addled recording artists as degenerates of one stripe and captains of industry as degenerates of another.
06:21:34 <quicksilver> mmorrow: *nod*
06:21:45 <quicksilver> mmorrow: although, quite often, forcing as you go is definitely waht you want.
06:21:52 <quicksilver> I meant, that's a useful tool - observing sharing.
06:22:01 <quicksilver> observing incomplete evaluation is another useful tool, though.
06:29:26 <xrfang> I know the meaning of $ but I am still a little bit confused. e.g. take (length [1,2,3]) [1,2,3,4]
06:29:41 <vixey> well I don't see any $ in that xrfang
06:29:41 <xrfang> can I use either "." or "$" to rewrite this function to get rid of ()?
06:29:58 <xrfang> in another word, I am a bit confused by the precedence of functions in haskell
06:30:25 <xrfang> there are MANY error I made due to lack of () in function definition!
06:30:28 <jlaire> no, you can't
06:30:30 <mmorrow> quicksilver: yeah, true
06:30:41 <mmorrow> err, to both
06:30:44 <vixey> xrfang: it works like this  f x y z = ((f x) y) z
06:31:00 <xrfang> here we have 2 functions, take and length...
06:31:15 <vixey> xrfang: if you put any operator in e.g. *, then  f x * y z = (f x) * (y z)
06:31:46 <xrfang> * itself is a function...
06:31:54 <vixey> xrfang: don't bother with ($) it is silly
06:32:17 <xrfang> e.g. func x:xs... I must write func (x:xs), otherwise it becomes (func x):xs, right?
06:32:22 <jlaire> prefix functions (words) always come before infix functions (symbols) in precedence
06:32:27 <jlaire> right
06:32:37 <vixey> xrfang, yes
06:33:46 <xrfang> if I write: take length [1,2,3] [1,2,3,4], can haskell infer that the function length only take one parameter, so we can omit (), or it will think the function as (take length) [1,2,3] [1,2,3,4]?
06:34:09 <vixey> xrfang, not how it works...
06:34:13 <vixey> xrfang: it works like this: f x y z = ((f x) y) z
06:34:16 <xrfang> it should know how many (maximum) parameters a function can take?
06:34:19 <QtPlaty[HireMe]> xrfang: What do you wish to do with the other one?
06:34:20 <xrfang> ok
06:34:26 <vixey> take length [1,2,3] [1,2,3,4] = ((take length) [1,2,3]) [1,2,3,4]
06:34:41 <xrfang> I am not "wish" I just try to fully understand the syntax of haskell :)
06:34:57 <QtPlaty[HireMe]> :t take
06:34:59 <lambdabot> forall a. Int -> [a] -> [a]
06:35:05 <vixey> types aren't even relevant to this
06:35:23 <QtPlaty[HireMe]> vixey: I was just working out the paramitors for take.
06:35:26 <xrfang> ok, then (take length) is not valid ....
06:35:44 <QtPlaty[HireMe]> Thats right though take . length is valid.
06:35:55 <xrfang> then, just *suppose* it is valid to write  ((take length) [1,2,3]) [1,2,3,4], is that same as:  ((take.length) [1,2,3]) [1,2,3,4]
06:36:00 <xrfang> note the "." in it
06:36:01 <vixey> :t take . length
06:36:02 <lambdabot> forall a a1. [a1] -> [a] -> [a]
06:36:25 <QtPlaty[HireMe]> xrfang: Not quite
06:36:28 <jberryman> xrfang: also, you should realize that ($) and (.) are just regular, higher-order functions
06:36:37 <vixey> xrfang: ((take length) [1,2,3]) [1,2,3,4] is ___NOT___ valid
06:36:42 <jberryman> @type: (.)
06:36:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:36:44 <xrfang> a bit confused.
06:36:45 <vixey> xrfang: so it isn't the same as something valid
06:36:53 <QtPlaty[HireMe]> take (length [1,2,3]) [1,2,3,4]
06:36:56 <xrfang> I mean I try to understand the "."
06:37:09 <xrfang> func1 func2 func3 123
06:37:11 <xrfang> vs.
06:37:12 <QtPlaty[HireMe]> @src (.)
06:37:12 <lambdabot> (f . g) x = f (g x)
06:37:14 <Zao> xrfang: Glue the output of the latter function to the input of the former.
06:37:16 <xrfang> func1.func2.func3 123
06:37:23 <xrfang> oh
06:37:34 <xrfang> that . is right associative...
06:37:35 <xrfang> right?
06:38:10 <xrfang> > negate max 3 4
06:38:10 <jlaire> right
06:38:11 <jberryman> xrfang: take a look at the types an source for (.) and ($), and it will sink in
06:38:11 <QtPlaty[HireMe]> How do you mean?
06:38:12 <lambdabot>       No instance for (Num (a -> a -> a))
06:38:12 <lambdabot>        arising from a use of `negat...
06:38:23 <xrfang> > negate ( max 3 4)
06:38:25 <lambdabot>   -4
06:38:32 <xrfang> > negate.max 3 4
06:38:33 <lambdabot>       No instance for (Ord (a -> b))
06:38:34 <lambdabot>        arising from a use of `max' at <i...
06:38:51 <jlaire> > (negate . max 3) 4
06:38:52 <lambdabot>   -4
06:39:36 <xrfang> what is the diff: negate.max 3 4 vs. (negate . max 3) 4
06:39:51 <jlaire> negate . max 3 4 = negate . (max 3 4)
06:40:17 <xrfang> thanks jlaire
06:40:25 <xrfang> > (negate.max) 3 4
06:40:26 <lambdabot>       No instance for (Num (a -> a))
06:40:26 <lambdabot>        arising from a use of `negate' at...
06:40:41 <QtPlaty[HireMe]> xrfang: (max 3) is a function.
06:40:45 <nlogax> > (negate . max 3) 4
06:40:47 <lambdabot>   -4
06:40:48 <jlaire> > ((negate .) . max) 3 4
06:40:48 <xrfang> ok
06:40:49 <lambdabot>   -4
06:41:20 <Berengal> > fmap (fmap negate) max 3 4
06:41:21 <lambdabot>   -4
06:41:24 <QtPlaty[HireMe]> :t (megate . max 3)
06:41:25 <lambdabot> Not in scope: `megate'
06:41:39 <QtPlaty[HireMe]> :t (negate . max 3)
06:41:40 <lambdabot> forall b. (Ord b, Num b) => b -> b
06:41:45 <jlaire> :t fmap
06:41:46 <Saizan> negate . max 3 4 == \x -> negate (max 3 4 x);  (negate . max) 3 4 == negate (max 3) 4;   (negate . max 3) 4 == negate (max 3 4)
06:41:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:41:53 <wli> http://wli.pastebin.com/m11009a94 <-- still stumped wrt. modules
06:42:42 <wli> Where do signatures and sharing constraints go?
06:42:45 <phoebe1860> hi there
06:42:59 <phoebe1860> any body here?
06:43:17 <Berengal> Yes, hello :)
06:43:43 <QtPlaty[HireMe]> module Modules(TypeYouWishToExport(..),functions,to,export) where
06:43:59 * QtPlaty[HireMe] is disembodied.
06:45:41 <phoebe1860> dadada
06:45:41 <wli> Well, I've got export lists in the module bit of the AST.
06:49:04 <jberryman> is there a way to get GHC to derive Ord when my type contains a type that's not an instance of Ord?
06:49:49 <jberryman> seems like it should just ignore that part of the data type, if it can
06:49:54 <xrfang> > (negate.max 3) 4
06:49:56 <lambdabot>   -4
06:50:15 <xrfang> > (.) negate (max 3) 4
06:50:17 <lambdabot>   -4
06:50:36 <xrfang> > (.) negate max 3 4
06:50:36 <QtPlaty[HireMe]> jberryman: You wish force a type constraint?
06:50:37 <lambdabot>       No instance for (Num (a -> a))
06:50:37 <lambdabot>        arising from a use of `negate' at...
06:52:18 <kadaver> > (.) (+) 3 4
06:52:19 <lambdabot>       Overlapping instances for Show (b -> b)
06:52:19 <lambdabot>        arising from a use of `s...
06:52:32 <kadaver> > (.) (+ . *) 3 4
06:52:33 <lambdabot>   <no location info>: parse error on input `.'
06:52:34 <Berengal> jberryman: You mean like "data Foo = A Int | B Char | C foo" ?
06:52:37 <kadaver> > (+ . *) 3 4
06:52:38 <lambdabot>   <no location info>: parse error on input `.'
06:52:46 <kadaver> > ((.) + *) 3 4
06:52:48 <lambdabot>   <no location info>: parse error on input `*'
06:52:54 <kadaver> > ((.) + (4*)) 3 4
06:52:56 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
06:52:56 <lambdabot>      Proba...
06:53:02 <kadaver> > ((.) (+6) (4*)) 3 4
06:53:03 <lambdabot>       No instance for (Num (t -> a))
06:53:03 <lambdabot>        arising from the literal `6' at <...
06:53:08 <plash> > ((+) . (*)) 3 4
06:53:09 <lambdabot>       No instance for (Num (a -> a))
06:53:09 <lambdabot>        arising from a use of `+' at <int...
06:53:19 <kadaver> > (.) (+6) (4*) 3 4
06:53:20 <lambdabot>       No instance for (Num (t -> a))
06:53:20 <lambdabot>        arising from the literal `6' at <...
06:53:24 <jlaire> :t ((+) . (*))
06:53:25 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
06:53:28 * QtPlaty[HireMe] asks "Is there any projects in haskell that while not trival would be benifical to the Haskell community and I could work at.
06:53:30 <poucet> Please cut the spam
06:53:32 <kadaver> > (.) (+6) (min 2) 3 4
06:53:33 <lambdabot>       No instance for (Num (t -> a))
06:53:33 <lambdabot>        arising from the literal `6' at <...
06:53:46 <poucet> You can privmsg lambdabot
06:54:08 * QtPlaty[HireMe] is looking for something of 'Goldylocks' skill leval.
06:54:31 <Saizan> QtPlaty[HireMe]: the cabal's trac is full of them :)
06:54:47 <QtPlaty[HireMe]> Saizan: URL?
06:55:11 <dcoutts> QtPlaty[HireMe]: "easy" cabal tickets: http://hackage.haskell.org/trac/hackage/report/13
06:55:17 <kadaver> is darcs dying(because of git)?
06:55:32 <jberryman> kadaver: no
06:56:56 <ehird> kadaver: yes
06:57:03 <dcoutts> kadaver: afaict, development is quite active and the size of the user base is relatively stable
07:02:04 <ryanakca> How would I join two lists together? I've tried  myFunct xs = xs:xs ... but that doesn't seem to work...
07:02:18 <QtPlaty[HireMe]> ryanakca: ++
07:02:21 <xrfang> I wrote a function to check if a list is a sub-list of another: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2252
07:02:29 <ryanakca> QtPlaty[HireMe]: Ah, thanks
07:02:32 <xrfang> however, it does not compile: Could not deduce (Eq a) from the context ()
07:03:15 <xrfang> on line 16...
07:03:29 <Saizan> xrfang: the correct signature is "(%) :: Eq a => [a] -> [a] -> Bool"
07:03:41 <xrfang> ok, thanks, modifying
07:03:50 <Saizan> xrfang: because of your use of the (==) operator
07:03:55 <Saizan> ?type (==)
07:03:56 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:04:09 <QtPlaty[HireMe]> zrfang: You used == without constraning it to things that can be equal.  Add Eq a => to your signature.
07:04:14 <Axman6> xrfang: if you're unsure about a type signature, you should leave it out, and then get ghci to tell what it is
07:04:39 <DrSyzygyFR> Is there a good way to limit execution time for a haskell program without using ulimit?
07:04:57 <xrfang> so if I do NOT write it actually haskell CAN infer the correct signature? :)
07:05:02 <DrSyzygyFR> I wanna profile a program not likely to finish; but ulimit kills it before the profiler writes out.
07:05:04 <koeien_> xrfang: most of the time
07:05:05 <Axman6> xrfang: also, just a style thing, instead of xh:xt, x:xs is usually used, as it says this is the first x in a list of xes
07:05:19 <wli> There's not even that good of a way to limit execution time with ulimit.
07:05:25 <quicksilver> DrSyzygyFR: have a thread run a long threadDelay and then kill the worker thread?
07:05:27 <Axman6> xrfang: one of the best things about haskell is the type inference :)
07:05:34 <xrfang> Axman6: yes, but x is used to represent the entire list :p
07:05:38 <QtPlaty[HireMe]> xrfang: Most of the time yes.
07:05:49 <xrfang> I will modify it to make clearer
07:05:52 <Axman6> xrfang: well, xss is the usual name for that :)
07:05:52 <xrfang> thanks,
07:06:04 <Axman6> so you'd have xss@(x:xs)
07:06:13 <Berengal> I use any of (h:t) (x:xs) xx@(x:xs)
07:06:23 <DrSyzygyFR> quicksilver: Whu?
07:06:24 <Saizan> quicksilver: that doesn't guarantee much about termination
07:06:26 <xrfang> an "offtopic" question: ghci compiling is "real" or not? i.e. I make a hello world, the executable size is several hundred kb
07:06:34 <xrfang> is it a real compiled executable
07:06:37 <wjt> yes
07:06:46 <xrfang> or an intepreter with some script binded in?
07:07:02 <Berengal> It's real, it just includes lots of runtype info such as the garbage collector
07:07:06 <xrfang> a "hello world" worth xxx KB... hm...
07:07:08 <xrfang> ok
07:07:09 <Axman6> i thought it was bytecode
07:07:11 <xrfang> thanks
07:07:13 <Berengal> "info" being the wrong word...
07:07:20 <xrfang> ... :|
07:07:29 <Berengal> "code" being more corre... >_<
07:07:29 <Saizan> ghci interprets to bytecode
07:07:31 <wjt> stripping the binaries makes a *big* difference
07:07:31 <Axman6> which is between native compilation and interpretation (like java)
07:07:33 <Berengal> correct*
07:07:39 <Axman6> hoorah, i was right
07:07:43 <xrfang> I will try strip
07:07:49 <xrfang> just curious
07:07:54 <Saizan> what you get from ghc --make is a compiled binary
07:08:12 <quicksilver> DrSyzygyFR: what was unclear? Create a new thread. Run long running cmoputation you don't expect to terminate. Kill it after n seconds.
07:08:28 <quicksilver> Saizan: it guarantees clean termination which means you get a useful profile.
07:08:30 <Saizan> which has the runtime system linked in, the runtime system does things like scheduling threads and running the garbage collector
07:09:29 <xrfang> strip: 400430 -> 264084 (hello world)
07:09:31 <xrfang> quite good
07:10:15 <xrfang> Saizan: yes, I used exerb to generate ruby executable on windows, but that is actually ruby.exe binded with a "bytecode" version of the script ;)
07:11:25 <bastl> where can i find some condensed information on the history of haskell: why/how was it invented, what languages did precede it, what languages were displaced?
07:11:44 <Axman6> bastl: wikipedia says a bit
07:12:00 <DrSyzygyFR> quicksilver: I got it now.
07:12:05 <DrSyzygyFR> I never touched the threading interface.
07:12:09 <DrSyzygyFR> before.
07:12:11 * quicksilver nods
07:12:20 <quicksilver> well it's something of a hacky way to do what you asked
07:12:23 <quicksilver> but I don't know of a clean way :)
07:12:25 <Berengal> bastl: http://haskell.org/haskellwiki/History_of_Haskell
07:12:27 <DrSyzygyFR> What you were suggesting was clear. How to do it wasn't until I googled a bit.
07:12:31 <xrfang> on line 9 of http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2252
07:12:35 <Axman6> DrSyzygyFR: threading may seem a little scary, but trust me, in haskell, it's _really_ nice to work with :)
07:12:41 <xrfang> it says*** Exception: t.hs:18:18-29: Irrefutable pattern failed for pattern (_ : yt')
07:12:44 <cothoughtpolice> bastl: http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/
07:12:47 <xrfang> run time error :S
07:13:01 <xrfang> what is "Irrefutable pattern failed"?
07:13:18 <Berengal> xrfang: It means the pattern match failed. It expected to see a : but didn't, because the list was empty
07:13:49 <xrfang> ok, thanks, I will modify
07:13:55 <Saizan> xrfang: so in your case, at some point y' was an empty list
07:14:23 <xrfang> understandable, but I feel my program is being stupid
07:14:25 <xrfang> one moment
07:14:34 <BONUS> xrfang: what is your function supposed to do
07:14:41 <Berengal> Is this the sublist function?
07:14:55 <xrfang> it takes 2 lists
07:15:07 <xrfang> if [a] is a sublist of [b] return true, else false
07:15:21 <xrfang> an exercise while reading LYAH :)
07:15:31 <BONUS> ah :)
07:15:53 <Axman6> heh
07:16:03 <trofi> @pl \n -> (n,1)
07:16:04 <lambdabot> flip (,) 1
07:16:49 <Axman6> :t uncurry id
07:16:50 <lambdabot> forall b c. (b -> c, b) -> c
07:16:56 <Axman6> :t curry id
07:16:57 <lambdabot> forall a b. a -> b -> (a, b)
07:17:24 <QtPlaty[HireMe]> expn LYAH?
07:17:45 <wli> Learn You A Haskell, an extended Haskell tutorial
07:17:45 <xrfang> hi expn?
07:18:02 <QtPlaty[HireMe]> xrfang: Expand
07:18:10 <quicksilver> @where lyah
07:18:10 <lambdabot> www.learnyouahaskell.com
07:18:11 <quicksilver> ^^
07:18:27 <xrfang> the (_:yt')... match takes place in the let part, I don't know if I can use if... then in that part or not?
07:18:29 <xrfang> e.g
07:18:37 <Axman6> Learn you a haskell for great good QtPlaty[HireMe]
07:18:50 <xrfang> if y' == [] then ... else (_:yt') = y'...
07:18:51 <Saizan> xrfang: it seems you're doing too many things at once in your function, btw, the logic can be much simpler
07:18:56 <xrfang> but I think it does not make sence
07:19:05 <Axman6> > null []
07:19:06 <lambdabot>   True
07:19:08 <Axman6> > null [1]
07:19:09 <lambdabot>   False
07:19:19 <quicksilver> xrfang: case y' of [] -> .... ; (_:yt') -> ....
07:19:22 <xrfang> Saizan: I sure think so, that's why I think it is stupid, but I try not to use built-in functions or as little as...
07:19:25 <quicksilver> xrfang: this is what case is for.
07:19:40 <xrfang> I will try thanks
07:20:48 <bastl> would it be ok to say that haskell is the standardized successor of languages like ML, Scheme, Lisp and Miranda !?
07:21:38 <Axman6> it's a standardised successor to gopher at least
07:21:46 <Saizan> Miranda surely
07:22:04 <Axman6> ML, Scheme and Lips are all still used widely
07:22:12 <Axman6> Lisp*
07:22:23 <Axman6> "widely"
07:22:25 <Saizan> and you can say that it's in the ML family, for scheme and Lisp i'd not be very convinced
07:22:48 <dolio> Gofer didn't predate Haskell.
07:22:57 <Axman6> didn't it?
07:23:06 <Berengal> let rle l = map (head &&& length) . group $ l; let isSublist a b = let (a',b') = (rle.sort *** rle.sort) (a,b) in all (\(e,l) -> e `elem` (map fst a') && ((>=l).fromJust $ lookup e a')) b' in isSublist [1..10] [1,2,3]
07:23:06 <Axman6> i was mistaken then
07:23:09 <wli> I usually treat it like a "better ML," except I miss modules.
07:23:16 <Berengal> > let rle l = map (head &&& length) . group $ l; let isSublist a b = let (a',b') = (rle.sort *** rle.sort) (a,b) in all (\(e,l) -> e `elem` (map fst a') && ((>=l).fromJust $ lookup e a')) b' in isSublist [1..10] [1,2,3]
07:23:16 <dolio> It was based on 1.2, apparently.
07:23:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:23:20 <Berengal> :/
07:23:23 <Berengal> Works on my machine
07:23:54 <doserj> > let (%) = (or .) . (. tails) . map . isPrefixOf in  [3..11] % [1..12]
07:23:56 <lambdabot>   True
07:24:09 <Saizan> gofer was more like an experimental spinoff to try some new features
07:24:31 <Axman6> ah ok
07:24:40 <Axman6> like monad comprehensions? or was that in haskell?
07:24:44 <jlaire> let (%) = isInfixOf in [3..11] % [1..12]
07:24:46 <jlaire> > let (%) = isInfixOf in [3..11] % [1..12]
07:24:48 <lambdabot>   True
07:25:09 <Saizan> i think it was constructor classes, but i'm not that good at history
07:25:14 <dolio> Monads appeared in 1.3, so Gofer may have been the first to have them.
07:25:34 * DrSyzygyFR has a Gröbner basis system for operads. Wooooters!
07:25:39 <Axman6> dolio: you've been going on haskell for a while i take it?
07:26:10 <dolio> No, but I've looked up this stuff at various times.
07:26:22 <Axman6> fair enough
07:26:31 <bastl> I want to say how Haskell developed to the state it is in now: started as a standardized successor to XYZ, was quickly/widely adopted by language researchers, nowadays has a kind of open-source-flavour, rich infrastructure, general purpose language.
07:27:08 <poucet> bastl: http://en.wikipedia.org/wiki/Haskell_(programming_language)
07:28:22 <xrfang> how to view modified version of code I pasted at moonpatio.com? it seems I cannot modify the code there, (after modify I still see the old version)
07:29:03 <Saizan> xrfang: refresh and/or scroll down the page
07:29:03 <dolio> The motivation was that lots of people were experimenting with lazy languages at the time, apparently, and they decided they'd be better off if there was some common language for that, rather than a bunch of custom ones.
07:29:22 <bastl> poucet: thanks but the history section is to coarse, while being lazy whith class is too fine :-/
07:29:52 <dolio> And as I recall they wanted to use Miranda, but the author didn't want to just open source it. So Haskell was made instead (and it looks a lot like Miranda).
07:30:18 * QtPlaty[HireMe] preffs Haskell to miranda so much.
07:30:23 <bastl> dolio: really? is that citable?
07:30:34 * bastl never heard that.
07:30:42 <xrfang> thanks Saizan
07:31:06 <dolio> Which part? It's probably in the retrospective someone posted a link to a few minutes back.
07:31:17 <bastl> ok
07:31:23 <bastl> the open-source thing i mean
07:32:11 <dolio> That may be in there, too. I'm pretty sure that was the reason. Its author didn't want to just give up control of it to a committee.
07:32:17 <jlaire> the author also asked that Haskell has a sufficiently different syntax so people won't confuse it with Miranda
07:32:40 <QtPlaty[HireMe]> jlaire: How strong is the miranda community now?
07:33:15 <dolio> I don't think it's still being developed, is it?
07:33:26 <jlaire> I don't think so, either
07:33:37 <fasta> TFP is the last thing Turner did that I know of.
07:33:53 <ryanakca> Could I have some feedback on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4247#a4247 please (RWH p.69, #5, question and code included)... How is it style wise, etc.?
07:33:57 <centrinia> What is Turner doing right now?
07:34:52 <Axman6> ryanakca: might want to use tail btw
07:34:55 <centrinia> ryanakca, I'm pretty sure that myCheck runs in O(n^2) time.
07:35:05 <Saizan> ryanakca: take (length xs - 1) xs == init xs
07:35:08 <Axman6> instead of take (length xs - 1)
07:35:15 <Axman6> uh, or init even
07:36:06 <Axman6> how efficient is the isPalin xs = xs == reverse xs version anyway?
07:36:22 <Saizan> Axman6: O(n)
07:36:26 <BONUS> yeah use init. although take (length xs - 1) xs does not equal init xs for infinite lists :)
07:36:35 <ryanakca> What's init?
07:36:40 <BONUS> > init [1,2,3,4]
07:36:42 <lambdabot>   [1,2,3]
07:36:43 <centrinia> > let myCheck x = x == reverse x in myCheck $ filter (/= ' ') "madam im adam"
07:36:44 <lambdabot>   True
07:36:45 <Axman6> Saizan: which is about as good as it can get right?
07:36:45 <BONUS> first elements without the last
07:37:00 <BONUS> Axman6: yeah, although it has O(n) space complexity imo
07:37:25 <Axman6> > let myCheck x = x == reverse x in myCheck $ filter (/= ' ') "able was i ere i saw elba"
07:37:26 <lambdabot>   True
07:38:06 <ryanakca> Ah. That makes infinitely more sense.
07:38:07 <wli> isPalin "Sarah"
07:38:24 <QtPlaty[HireMe]> isPalin "Michal"
07:38:58 <johh> finding palindromes in linear time: http://johanjeuring.blogspot.com/2007/08/finding-palindromes.html
07:40:17 <ryanakca> Also, is there such a thing as vi keybindings for the ghci prompt?
07:40:51 <wli> ryanakca: I use the libreadline -based vi keybindings for ghci.
07:43:18 <ryanakca> wli: ... and how would I go by enabling that. While compiling libreadline? ghci?
07:44:01 <centrinia> > snd . (\z -> foldr (\y (x:xs,s) -> (xs,(y == x) && s)) (z,True) z) $ filter (/= ' ') "never odd or even"
07:44:03 <lambdabot>   True
07:44:10 <centrinia> > snd . (\z -> foldr (\y (x:xs,s) -> (xs,(y == x) && s)) (z,True) z) $ filter (/= ' ') "sarah palin"
07:44:11 <lambdabot>   False
07:44:48 <centrinia> Does that have sublinear space complexity?
07:47:11 <Saizan> centrinia: that uses linear stack, afaict
07:47:35 <centrinia> foldr uses a linear stack?
07:48:19 <Saizan> it does if the combining function is strict on its second argument
07:48:35 <dons> ?users
07:48:35 <lambdabot> Maximum users seen in #haskell: 658, currently: 613 (93.2%), active: 22 (3.6%)
07:49:26 <centrinia> Okay, how does one test if a string is a palindrome with sublinear complexity? :(
07:49:44 <centrinia> Uh, sublinear space complexity.
07:50:27 <Saizan> with an array?:)
07:51:33 <cjay> centrinia: normally you don't count the input as long as it doesn't get written to
07:51:35 <quicksilver> well you certainly need it in a structure which has fast access to both ends.
07:51:37 <cjay> at least with turing machines
07:51:48 <quicksilver> so a Seq or an Array or something special purpose
07:52:02 <quicksilver> and then just iterate in a way which doesn't build up thunks or stack.
07:52:27 <Berengal> If the input is a linked list, I don't think it's possible
07:52:28 * trofi seeks updateOrInsertIfNothing in Data.Map
07:52:47 <centrinia> So it is not possible to test if a linked list contains a palindrome in linear time complexity and sublinear space complexity? :(
07:53:08 <Berengal> You want to get a hold of both ends of the string at the same time, and that requires either looking for the end repeatedly, or pushing it into another structure
07:54:06 <quicksilver> trofi: "alter"
07:54:06 <EvilTerran> you might be able to do something cunning with some kind of O(log n)-sized str ucture
07:54:20 <trofi> :t alter
07:54:21 <lambdabot> Not in scope: `alter'
07:54:25 <trofi> :t M.alter
07:54:26 <centrinia> > let myCheck x = x == reverse x in myCheck $ filter isAlpha "dammit, i'm mad!"
07:54:26 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
07:54:28 <lambdabot>   True
07:54:38 <quicksilver> trofi: or insertWith
07:54:39 <trofi> quicksilver: thanks a lot!
07:54:40 <Berengal> @insertWith
07:54:40 <lambdabot> Unknown command, try @list
07:54:45 <Berengal> @hoogle insertWith
07:54:45 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
07:54:45 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
07:54:45 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
07:54:53 <quicksilver> Berengal: please don't do that.
07:55:10 <quicksilver> it adds no value to the help I just gave, and caused 6 lines of output including your failed attempt.
07:55:20 <quicksilver> I'm sure peopple can find the docs for Data.Map if they want them.
07:56:01 <wli> You should be able to remember where the halfway point is and so only check ceiling (genericLength xs / 2)
07:57:00 <centrinia> That's still linear with respect to genericLength xs :(
07:57:20 <wli> You can't do better than linear.
07:58:43 <byorgey> centrinia: I'm confused on what you mean by "sublinear space complexity".  You have to at least store the string being tested somewhere in memory.
07:59:04 <byorgey> you can never use sublinear space by definition.
07:59:19 <cjay> byorgey: you can, if you don't count the input
07:59:30 <centrinia> What if you write off the space requirements of the inputs?
07:59:33 <DrSyzygyFR> So sublinear _additional_ space.
08:01:22 <EvilTerran> i think "space complexity disregarding input space requirements" is one of those things where functional data structures will inevitably lose out
08:01:24 <beelsebob> DrSyzygyFR: I don't get the distinction
08:01:39 <byorgey> I guess my point is, if you're already using linear space to store the input, who cares about using additional linear space?
08:02:19 <centrinia> byorgey, maybe the input doesn't explicitly require linear space.
08:02:44 <centrinia> You might be able to compute the input on the fly.
08:03:20 <poucet> byorgey: oy
08:04:23 <byorgey> centrinia: well, I guess you can get into an interesting discussion of what "input" means.  But generally if you're computing something on the fly, then it isn't the input.  the input was whatever data you needed to construct this on-the-fly computation.
08:04:33 <byorgey> hey poucet
08:04:54 <poucet> byorgey: Hey :)
08:04:55 <EvilTerran> centrinia, if you're computing the input on the fly, it's not really a linked list
08:05:08 <poucet> byorgey: Life is limited, factors matter, O-notation is overrated :)
08:05:17 <dolio> What if it's lazy?
08:06:29 <EvilTerran> dolio, well, you'll still need to either force the entire thing in memory (in which case the "on-the-fly" aspect is irrelevant) or generate it repeatedly (in which case the data structure it happens to be passing through is a bit moot)
08:06:44 <wli> What are the inputs to fibs = let fs = 0 : 1 : zipWith (+) fs (tail fs) in fs?
08:07:31 <dolio> length [1..1000000] runs in O(1) space.
08:08:00 <dolio> (Hopefully.)
08:08:16 <poucet> > length [1..1000000]
08:08:17 <lambdabot>   1000000
08:10:02 <lpsmith> wli:  what do you mean?
08:10:23 <wli> It's a list generated on the fly so to speak.
08:10:46 <lpsmith> correct,  but what do you mean by "inputs"?
08:11:00 <wli> omfg someone else handle this
08:12:12 <poucet> wli: fibs is a nullary 'function', it has no inputs
08:12:17 <byorgey> poucet: maybe constant factors matter to you, but here in academia I am mercifully shielded ;)
08:12:26 <poucet> byorgey: until you try to run it on your machine?
08:12:59 <byorgey> what is this "running" you speak of?  all I ever do is write code and then typecheck it.
08:13:48 <poucet> And the typechecking occurs in the typechecker of the compiler?
08:13:49 <poucet> Smart
08:13:50 <poucet> Very clever
08:14:10 <poucet> so you don't evne have to run the compiler, you just typecheck it :)
08:18:35 <DrSyzygyFR> Btw, how do I make Cabal play nice with umlauts?
08:18:40 <DrSyzygyFR> Or Haddock for that matter?
08:18:54 <dcoutts> DrSyzygyFR: .cabal files are UTF-8
08:19:07 <dcoutts> DrSyzygyFR: as are .hs files
08:19:48 <DrSyzygyFR> dcoutts: Ah.
08:20:02 <DrSyzygyFR> Yeah, I seem to have saved everything in latin1 so far. *fixes*
08:21:07 <DrSyzygyFR> Another random Q. How do I make the haddock generated from the cabal description field not come out as a solid chunk of text?
08:22:02 <dcoutts> DrSyzygyFR: strangely, to get blank lines in fields in .cabal files you need the line to begin with a . and otherwise be blank.
08:22:14 <DrSyzygyFR> dcoutts: Aight!!
08:22:21 <dcoutts> crazy I know, I'll lift that restriction next time I rewrite the parser
08:22:40 <dcoutts> it used to be the case that blank lines separated sections
08:23:35 <DrSyzygyFR> I get Setup: operads.cabal:16: unrecognised field or section: "."
08:24:08 <dcoutts> DrSyzygyFR: I think it's got to be at the same indentation level
08:24:34 <DrSyzygyFR> Ah, ok!
08:25:47 <cinema> kosmikus: ping
08:25:47 <lambdabot> cinema: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:40:48 <Axman6> the google logo today is awesome
08:41:24 * quicksilver thinks Axman6 is too easily awed.
08:42:18 <Axman6> you juat wait ultil there's a quicksilver logo when you die and i think it's awesome ;)
08:42:30 <Axman6> just even
08:43:16 * gwern looks
08:43:32 <gwern> OH MY GOD. MY LIFE IS CHANGED FOREVER
08:43:41 <gwern> THIS CHANGES EVERYTHING
08:44:42 * Axman6 replaces awesome with pretty cool to cease the snide remarks
08:45:14 * gwern is always snide until smithers gives me my sponge-bath
08:45:17 <gwern> and caffeine
08:47:10 <ali_clark> hi, hope you don't mind if i ask a question to help me clear something up...
08:47:16 <mreh> i need a solution for testing for character presses, all the IO actions that I have wait for key presses
08:47:20 <mreh> ask away
08:47:47 <ali_clark> thanks, heres a function: foo x = case x of { 0 -> 0; y -> 1 / y }
08:47:56 <mreh> yup
08:47:56 <ali_clark> is foo 0 compiled straight to 0?
08:48:06 <mreh> nope
08:48:14 <ali_clark> okay, thanks!
08:48:25 <ali_clark> but if i wrote foo 0 = 0 that would be, right?
08:48:44 <gwern> mreh: you can't know that. that seems like a perfectly possible optimization to me
08:48:46 <mreh> well, i dont know about the compiled C code
08:49:02 <gwern> ali_clark: to know for sure you need to look at the code, and obviously use -O2
08:49:19 <mreh> when I hear compiled in my head I think of something else
08:49:24 <MyCatVerbs> ali_clark: the optimizer is both smarter and dumber than you might expect.
08:49:48 <mreh> can you help meeee now?!?!
08:49:53 <ali_clark> hmmms i thought it was merely a case that pattern matching a fn definition is strict but not otherwise
08:50:12 <ali_clark> ach nvm
08:50:16 <MyCatVerbs> ali_clark: it will easily compile { foo x = case x of { 0 -> 0; y -> 1 / y; } } and { foo 0 = 0; foo y = 1 / y; } to the same code.
08:50:41 <ali_clark> oh right thats what i was asking, thanks!
08:50:42 <quicksilver> ali_clark: for the specific case of numbers, I think not.
08:50:42 <mreh> use pattern matching
08:50:49 <mreh> your job isnt to optimize code
08:50:52 <quicksilver> hmm.
08:50:56 <quicksilver> actually, yes it will.
08:51:02 <quicksilver> it will inline and reduce that.
08:51:16 <MyCatVerbs> If you get paranoid, grab ghc-core off hackage ("cabal install ghc-core" should hopefully just work) and check the core output.
08:51:32 <MyCatVerbs> Otherwise, profile first, *then* worry.
08:51:59 <mreh> how can i check for a keypress if all my IO actions *wait* for a keypress?
08:52:00 * gwern looks at the core output. man i dunno
08:52:17 <MyCatVerbs> gwern: painful, isn't it? =)
08:52:22 <gwern> mreh: then by definition can't the io action assume a keypress?
08:52:32 <gwern> MyCatVerbs: yeah. it doesn't seem to even keep the identifiers
08:52:32 <mreh> no
08:52:53 <mreh> gwern: it's a reactive animation
08:53:10 <mreh> when users press keys, stuff moves
08:54:03 <mreh> so if the window tick is up, then it needs to refresh the animation
08:54:18 <lpsmith> gwern:  that case should get optimized if "foo" is inlined,  otherwise not.
08:54:38 <quicksilver> even without inlining that kind of thing can be optimised by SpecConstr
08:54:47 <quicksilver> (although probably not on numbers, which aren't normal constructors)
08:54:51 <mreh> i dont know what you mean by assume, gwern
08:54:56 <quicksilver> but with inlining it will collups completely.
08:55:01 <quicksilver> collapse.
08:55:04 <quicksilver> what a weird typo.
08:55:05 <mreh> hehe
08:55:14 <mreh> subconcious lolspeak
08:55:24 <DrSyzygyFR> Ooookay.
08:55:31 <quicksilver> mreh: as for your question the details depend on your reactive framework I'm sure.
08:55:41 <DrSyzygyFR> So now it starts closing in on being time to think about a good distribution point for this package.
08:55:41 <quicksilver> but you should have a way to refresh every tick
08:55:46 <quicksilver> irrespective of input
08:55:48 <gwern> mreh: if all the functions block until a keypress, then keypress implies running and vice versa; so we can infer a keypress from running
08:56:01 <DrSyzygyFR> My own academic webpage? Google code? Hackage? Somewhere else?
08:56:07 <DrSyzygyFR> Thoughts?
08:56:17 <gwern> mreh: this is like the cogito or anthropic arguments; if something must be true for us to consider the proposition at all, then it is true
08:56:27 <DrSyzygyFR> One thing that speaks against hackage might be the extreme domain specificity of this... (at least currently)
08:57:10 <mreh> gwern, i understand
08:57:23 <EvilTerran> DrSyzygyFR, what does it do?
08:57:29 <mreh> so is there a serparate IO framework, like an IO stream
08:57:30 <mreh> one I can read
08:58:12 <quicksilver> you don't want to mess with IO directly if you're using a reactive thing.
08:58:16 <quicksilver> you want ot use the facilities it gives you
08:58:23 <quicksilver> otherwise you'll just break everything.
08:58:24 <mreh> ill show you my code so far
08:58:28 <mreh> ill paste it
08:58:45 <MyCatVerbs> @where hpaste
08:58:45 <lambdabot> http://hpaste.org/
08:58:59 <mreh> yo
09:00:05 <pejo> DrSyzygyFR, distribute it through hackage, have your own homepage for it somewhere and just point to hackage.
09:00:15 <mreh> this should be enough for you to understand
09:00:16 <mreh> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4248#a4248
09:01:04 <quicksilver> mreh: oh, when you said reactive I thouhgt you meant 'Reactive'
09:01:12 <quicksilver> it's an API for FRP written by conal.
09:01:22 <mreh> :)
09:01:42 <quicksilver> the answer to your question lies in how SOE works, I guess.
09:01:46 <mreh> you assumed too much
09:01:47 <quicksilver> I've never used the SOE event stuff.
09:02:02 <DrSyzygyFR> EvilTerran: It computes gröbner bases for operads.
09:02:14 <EvilTerran> DrSyzygyFR, ok, i have no idea what that means. ;)
09:02:18 <DrSyzygyFR> Right now, I expect the audience to be no bigger than some 30-60 algebra and topology researchers.
09:02:20 <mreh> i think i have a solution somewhere, ill peek in that
09:02:28 <EvilTerran> DrSyzygyFR, there's already some pretty specialised stuff on hackage
09:02:51 <ErhardtMundt> bye
09:04:12 <pejo> DrSyzygyFR, even if it's a small audience it's really nice to be able to cabal install it.
09:05:41 <dcoutts> DrSyzygyFR: 30-60 is a big audience :-)
09:09:31 <dons> well done to eaton and tom hawkins for releasing Atom, http://www.reddit.com/r/programming/comments/8fukm/atom_is_a_dsl_in_haskell_for_designing_hard/
09:10:39 <roconnor> oh
09:10:47 <roconnor> so it has nothing to do with syndication
09:10:55 <dons> that's right.
09:11:10 <gwern> atom is a bad name
09:11:12 <roconnor> damn
09:11:14 <roconnor> :)
09:11:15 <gwern> that was my first thought too
09:11:22 <roconnor> I need a atom parser
09:11:28 <gwern> roconnor: don't worry, we already have an atom lib
09:11:31 <gwern> in that sense
09:11:33 <roconnor> and I have no hydraulic trucks
09:11:39 <roconnor> oh good
09:11:42 <gwern> rss, iirc, handles both rss and atom
09:11:47 <DrSyzygyFR> dcoutts: Point.
09:11:49 <gwern> or was it feed that handled both?
09:12:01 <dons> does take much for gwern to go off into the brambles :)
09:12:02 <DrSyzygyFR> dcoutts: Especially given that I'll probably need to hand-hold almost everyone. :-P
09:12:09 <dcoutts> :-)
09:12:18 <roconnor> I need to rewrite Akregator in Haskell
09:12:23 * gwern is a Bear of Little Brain, and Long Words confuse me
09:12:35 <roconnor> I should call it Krocodile
09:12:53 * MyCatVerbs pours hunny over gwern's head.
09:13:11 * gwern feebly reaches up, but drat these stubby arms
09:13:30 <MyCatVerbs> I'm surprised that you don't just tilt yourself.
09:13:40 <gwern> but then I should fall over
09:13:57 <MyCatVerbs> We could get you a stool.
09:14:06 <MyCatVerbs> Alternately, we could point at you and laugh. That's good too.
09:20:15 <ksf> almost every kde program needs a rewrite.
09:21:14 <roconnor> ksf: really?
09:21:24 * gwern amends that statement to make it even truer: almost every program needs a rewrite.
09:21:24 <roconnor> I find Akregator really really bad
09:21:32 <ksf> like konsole, which crashes on me every time i close it.
09:21:36 <roconnor> The number of articles in a feed is often negative
09:21:53 <gwern> roconnor: wow. so... it's sucking information out of you?
09:21:57 <roconnor> ya
09:22:12 <roconnor> ksf: crashing  on close doesn't sound so bad from a user's stand point
09:22:27 <roconnor> it is probably faster than traditional closing
09:22:50 <ksf> works here... but i suspect it to lag badly behind the actual rss feeds, and khtml suckage is a whole story on its own.
09:23:29 <ksf> somehow, khtml manages to be slower than firefox, and that isn't easy to do.
09:23:39 <Berengal> KDE does have overall buggier programs than the gnome defaults I've found. However, they're also better, despite the bugs...
09:23:47 <roconnor> we need an Hhtml
09:23:57 <ksf> don't get me started on ktype's keyboard layout and lesson editors.
09:24:02 <Berengal> Hmm... Haskell DE...
09:24:14 <roconnor> HDE
09:24:24 <Berengal> I'd join that project
09:24:33 <ksf> that'd be the desktop monad.
09:24:46 <roconnor> that is a lot of software ...
09:25:22 <ksf> html engine and toolkit are important things to have, though.
09:25:44 <Berengal> Speaking of monads, I find it awesome that a haskell program is nothing more than a value of IO a. You could import a bunch of them and sequence them if you wanted
09:26:02 <roconnor> import?
09:26:10 <Berengal> as in "import Foo"
09:26:16 <roconnor> yep
09:26:30 <gwern> Berengal: yeah but how often does anyone export their main for you to use?
09:26:31 <roconnor> import Random
09:26:48 <gnuvince> @index (=?_
09:26:48 <lambdabot> bzzt
09:26:49 <gnuvince> @index (=?)
09:26:50 <lambdabot> bzzt
09:26:58 <Berengal> gwern: True
09:28:30 <Berengal> I still like the idea though...
09:29:22 <quicksilver> I'm with berengal. The idea is nice.
09:29:36 <quicksilver> You can even use 'withArgs' to change the command line args for them.
09:29:58 <gwern> stdin/stdout might be tricky
09:30:53 <Berengal> Might have to write a shell monad to handle all the handles and pipes...
09:30:59 <ksf> hmmm... you can close both, I never tried that, but I think you could reopen them to different handles.
09:31:19 <Berengal> I get getContents opens them to a new handle
09:31:20 <ksf> don't listen to me.
09:31:49 <ksf> you still have to have different processes for them to point to different places.
09:31:52 <Berengal> Or at least, getContents >>= (\s -> getLine >>= (\s' -> putStrLn (s' ++ s))) throws an exception on getLine
09:31:54 <Ferdirand> sequencing independant programs in a single process sure would be funny
09:32:07 <Berengal> (But getContents continues to read afterwards if you catch it)
09:32:09 <ksf> so forkOS'ing the mains would'nt be a bad idea.
09:37:39 <DrSyzygyFR> Where can I find the recommended top level structure to put my package into?
09:38:23 <dons> http://haskell.org/haskellwiki/Hierarchical_module_names
09:38:33 <dons> out of date though. the current namespace of hackage is much much bigger
09:38:36 <dons> there's about 50 categories now
09:39:00 <DrSyzygyFR> dons: I think Algebra is suitable for this one though. :-P
09:39:03 <DrSyzygyFR> How do I set it?
09:39:04 <roconnor> I'm thinking I am never going to put anything in Data or Control ever again.
09:39:08 <dons> Math.*
09:39:18 <DrSyzygyFR> I need to make my source files and my Cabal file agree, right?
09:39:23 <EvilTerran> Control.Data
09:39:24 <DrSyzygyFR> module Math.Operad where (?)
09:39:25 <EvilTerran> Data.Control? :P
09:39:29 <roconnor> ahhhhhhh
09:40:23 <ksf> Data.Maybe is such a misnomer, you import it for the monad... and monads usually are Control.*
09:40:51 <copumpkin> what if you import it for maybe or fromMaybe
09:41:01 <copumpkin> or even fromJust
09:41:14 <uccus> hi guys! I want to put this somewhere on the wiki... which page would be most appropriate?
09:41:15 <uccus> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4249
09:41:21 <DrSyzygyFR> copumpkin: Such as I've done all over the place lately. :-P
09:42:23 <cnwdup> @pl liftM3 (.)
09:42:23 <lambdabot> liftM3 (.)
09:42:25 <EvilTerran> uccus, that last comment confounds "error" and "fail"
09:42:35 <cnwdup> Was there a special operator for that?
09:42:45 <EvilTerran> ?type liftM3 (.)
09:42:46 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m a -> m c
09:42:59 <EvilTerran> ?type (<=<)
09:43:00 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:43:11 <EvilTerran> derp
09:43:36 <uccus> EvilTerran: well a pattern match failure is an error, right? shouldn't it? am I missing something? I thought it's a cool demonstration that errors are... erm... nevermind
09:44:08 <EvilTerran> uccus, a pattern-match failure on the left of a <- results in an invocation of "fail" as defined by the monad, not "error"
09:44:29 <EvilTerran> ?undo do Just x <- foo; return x
09:44:29 <lambdabot> foo >>= \ a -> case a of { Just x -> return x; _ -> fail ""}
09:44:56 * monochrom parodes Marx. "The history of programming language is defined by a struggle between two classes: control and data. Every development re-draws the boundary between them."
09:44:57 <uccus> EvilTerran: :( got you
09:45:08 <Berengal> Would it be possible to restrict do-notation that could fail to instances of MonadZero?
09:45:19 <EvilTerran> Berengal, with -XNoImplicitPrelude, yes
09:45:20 <DrSyzygyFR> ehhhhhh
09:45:30 <DrSyzygyFR> How do I name my source files for this to work? *confused*
09:45:39 <EvilTerran> Berengal, and you can even have do-notation with no <- be in Applicative instead of Monad
09:45:46 <quicksilver> Math/Operad/Coolness.hs
09:45:50 <EvilTerran> (with (>>) = (*>))
09:45:51 <DrSyzygyFR> Ahhhh
09:45:57 <quicksilver> contains module Math.Operad.Coolness
09:46:00 <Berengal> EvilTerran: Hmm... awesome, maybe?
09:46:03 <DrSyzygyFR> And the module Math.Operad?
09:46:11 <EvilTerran> DrSyzygyFR, Math/Operad.(l)hs
09:46:12 <DrSyzygyFR> Math/Operad.hs so no collission. fine
09:46:17 <mmorrow> DrSyzygyFR: one naming scheme i like (for libraries that are logically a single unit, but have general applicability) is <Main-Category>.<Application/Library-Name>.<SubCategory>
09:46:26 <EvilTerran> Berengal, indeed, there is potential for awesome there.
09:46:30 <mmorrow> e.g.  Language.Haskell.Exts.Syntax
09:46:41 <uccus> so outside a monad if some value matches no equations what happens?
09:46:51 <EvilTerran> uccus, then "error" is invoked
09:46:57 <mmorrow> Math.LeetCalculator.Algebra.Ring
09:47:07 <uccus> so is there any way to "catch" that error?
09:47:12 <EvilTerran> (or equivalent; you end up with bottoms floating around, anyway)
09:47:14 <EvilTerran> not in pure haskell
09:47:15 <Berengal> EvilTerran: I'm assuming -XNoImplicitPrelude means you'll have to define your own Monad and MonadZero class though, and put fail in MonadZero instead?
09:47:22 <EvilTerran> Berengal, yeah
09:47:37 <EvilTerran> and import Prelude hiding (lots of things)
09:47:38 <Berengal> The rest is done by the desuggaring?
09:47:45 <uccus> or does it just mean that my program will collapse?
09:47:47 <cnwdup> EvilTerran, thank you.
09:48:19 <ksf> fail belongs into its own monad.
09:48:22 <uccus> Berengal: the GHC spec says it will use whatever (>>=), (>>), fail are in scope no matter watch they are
09:48:28 <EvilTerran> Berengal, as long as you give the right types to all the names the desugaring uses, it should work
09:48:43 <EvilTerran> (and, of course, follow the semantics :P)
09:48:46 <ksf> and monadic pattern failures can just call error directly if the monad does'nt implement fail.
09:49:04 <uccus> same for fromIntegral but I don't think it's that easy to mess with Num
09:49:31 <Berengal> ksf: The point is that fail is an ugly hack that shouldn't be in the Monad class. Anything that could potentially fail would therefore have to be a MonadZero, or you'd get a type error
09:50:01 <uccus> so? should I put it on the wiki? I mean I am quite sure a lot of people would want to look under to 'do' notation hood
09:50:04 <uccus> time and again
09:50:40 <ksf> Berengal, that, or have a compile switch that inserts calls to errors in the right places.
09:50:59 <ksf> it's an issue more or less orthogonal to top-level pattern match failures.
09:51:19 <ksf> *calls to "error"
09:51:25 <Berengal> ksf: Why would we want to throw in undefined values when we could have compile time checking?
09:52:03 <ksf> because i might not want to have it.
09:52:23 <ksf> ...i'm not compiling with pattern match warnings and -werror all the time, either.
09:52:29 <monochrom> static-checking-phobia
09:53:16 <ksf> that is, I don't want to have any different outside behaviour, just fail out of the Monad class.
09:53:42 <Berengal> well, error drops you all the way out to the outer IO monad...
09:54:02 <DrSyzygyFR> dons: HackageDB still tells me that my top-level path name is unallocated: Math.
09:54:03 <ksf> ...so does Monad IO's fail.
09:54:07 <ksf> ...as it calls error.
09:54:11 <ksf> most fail's do.
09:54:21 <quicksilver> in my version of truth, you can't catch error even in the IO monad.
09:54:28 <quicksilver> so it crashes the program
09:54:35 <quicksilver> it doesn't go to the outer IO monad.
09:54:50 <Berengal> The Maybe monad has a meaningful failure, so does the list monad. The IO monad, Reader, State... not so
09:55:04 <uccus> I wonder what should we call that class with just fail... Fallible? Gullible? Refutable?
09:55:11 <Berengal> MonadFail?
09:55:20 <uccus> that's ... mundane
09:55:22 <ksf> yeah. that's why the former can implement fail, and the rest can just crash and forget about fail.
09:55:40 <quicksilver> Berengal: actually the IO monad does have a meaningful fail.
09:55:51 <quicksilver> The IO monad officially and importantly has catchable exceptions.
09:55:54 <ksf> "Enterprise"
09:55:55 <quicksilver> that's a perfectly fine file.
09:55:56 <monochrom> Human <-- name for the class with just fail.
09:56:10 <quicksilver> it's the pure 'error' which shouldn't be catchable.
09:56:33 <Berengal> Yeah, okay, IO has a meaningful fail
09:56:40 <Berengal> Which is in fact an exception, I just checked...
09:56:43 <mopped> Is there an 'infinity' in haskell? like an identity element for minimum?
09:56:54 <monochrom> No.
09:57:08 <Berengal> mopped: There is for bounded types
09:57:25 <dons> DrSyzygyFR: that's ok.
09:57:29 <vixey> mopped: you can define it
09:57:32 <uccus> well.. this conversation would be over if meaningful fails where abandant
09:57:34 <vixey> data N = Z | S N
09:57:34 <Berengal> > let minimum' = foldl' min maxBound in minimum' []
09:57:36 <lambdabot>   ()
09:57:39 <vixey> infinity = S infinity
09:58:21 <wjt> I wish there were a Natural type
09:58:30 <vixey> wjt: data N = Z | S N
09:58:35 <vixey> I give you it
09:58:40 <uccus> what about the package nat?
09:58:43 <wjt> a newtype Natural = MkNatural Integer i mean
09:59:13 <Berengal> How would the Num instance for Natural look?
09:59:16 <wjt> it makes me sad that I wind up using signed Integers when I don't really mean to, but I don't think depending on an extra library is sensible
09:59:20 <wjt> Berengal: truncated
09:59:22 <Berengal> How would you implement negate?
09:59:34 <wjt> but it's a fair argument.
10:00:35 <monochrom> We widely agree that Num is unsatisfactory. We just disagree on what is satisfactory.
10:00:37 <Berengal> Natural just isn't a number the way Haskell defines it
10:01:03 <uccus> what about the package on hackage called nat?
10:01:06 <uccus> ?
10:01:10 <dons> slides on galois' experience using Haskell over the past decade, http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/  enjoy!
10:01:18 <bogner> anyone around who makes debian packages from cabal packages? the instructions on the wiki seem slightly broken
10:01:32 <dons> bogner: ask on the debian-haskell list
10:02:03 <bogner> thanks dons
10:02:28 <mmorrow> data N a where Z :: N (N ()); S :: N (N n) -> N (N (N n)); Inf :: N ()
10:03:24 <copumpkin> zomg a mmorrow
10:03:56 <mmorrow> omzg
10:08:40 <BONUS> dons: was the talk taped?
10:08:41 <DrSyzygyFR> Woot! I'm on hackage!
10:08:57 <dons> BONUS: nope.
10:10:07 <copumpkin> DrSyzygyFR: nice!
10:10:16 <gwern> mm. it's too bad you can't profile a binary and have multiple threads
10:10:49 <gwern> that'd make showing memory leaks easier, because gitit forkIOs requests; so I could do -N4 and get 4x request thoroughput, presumably
10:11:53 <dons> gwern: i heard a rumour that works in ghc 6.10.x
10:12:19 <gwern> dons: no, I just tried
10:12:51 <gwern> 6.10.2, that is
10:13:24 <dons> $ ghc -O2 -threaded -prof A.hs --make
10:13:24 <dons> Linking A ...
10:13:24 <dons> $ time ./A +RTS -p
10:13:24 <dons> "hello"
10:13:25 <dons> ./A +RTS -p  0.00s user 0.00s system 47% cpu 0.007 total
10:13:31 <BONUS> cool slides. it's just awesome how the combination of the type system, purity, and higher-order functions works so well to achieve robust applications and such a high-level of thinking
10:13:39 <dons> gwern: 6.102.
10:13:54 <dons> BONUS: :) excellent. that's what I hoped to convey.
10:15:02 <gwern> 6.102? man where am I gonna get that
10:15:13 <gwern> dons: ./A +RTS -p -N4 -RTS works for you?
10:15:46 <dons> ah no. that does not work. using the threaded runtime + prof only works with -N1
10:15:54 <goalieca2> > 5!
10:15:55 <gwern> yes, that's what I'm complaining about
10:15:55 <lambdabot>   <no location info>: parse error on input `;'
10:16:09 <dons> right. but you can use the threaded rts
10:16:16 <dons> so that's better than in 6.8.x
10:16:34 <goalieca2> > multiply [1..5]
10:16:35 <lambdabot>   Not in scope: `multiply'
10:16:37 <gwern> yeah, but what good is that? about all that does is avoid having to recompile
10:16:49 <goalieca2> > foldl (*) [1..5]
10:16:50 <dons> hmm?
10:16:50 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
10:16:51 <lambdabot>        arising from a use...
10:16:56 <goalieca2> > foldl (*) [1..5] 1
10:16:57 <lambdabot>       No instance for (Num [t])
10:16:57 <lambdabot>        arising from a use of `*' at <interact...
10:17:29 <dons> gwern: i think the burden is on you explaining why that isn't useful?
10:17:59 <BONUS> haha cool picture at the end. use haskell, finish soon, take left over time for vacation
10:18:06 <dons> :)
10:18:19 <dons> well, it was more that galois was some kind of oasis in the vast ocean :)
10:18:28 <dons> but vacation is also good
10:19:05 * Berengal wishes he could use Haskell at work, or even python, but no... Java is the One Language to Rule Them All :(
10:20:31 <monochrom> One >>= to bind them all. In the dark lands of Monads.
10:21:27 <gwern> @quote land.*of
10:21:27 <lambdabot> ghc says: jump island out of range
10:21:31 <gwern> @quote land.*of
10:21:31 <lambdabot> ghc says: jump island out of range
10:21:40 <gwern> bah. I was sure we had a mordor quote in there
10:21:52 <gwern> @quote bind.*them.*all
10:21:52 <lambdabot> No quotes match. Maybe you made a typo?
10:21:56 <gwern> :(
10:22:12 <gwern> monochrom: come up with a better full version and @remember it stat!
10:23:00 <vixey> @quote bind
10:23:00 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
10:23:02 <vixey> @quote bind
10:23:02 <lambdabot> ghc says: bindings for unlifted types aren't allowed
10:23:03 <monochrom> The broken one is @quote actually. It's dumb.
10:23:03 <vixey> @quote bind
10:23:04 <lambdabot> ghc says: Implicit-parameter bindings illegal in a parallel list comprehension
10:23:04 <vixey> @quote bind
10:23:04 <lambdabot> ghc says: bindings for unlifted types aren't allowed
10:23:05 <vixey> @quote bind
10:23:05 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
10:23:13 <vixey> ghc shouldn't be in there...
10:23:43 <gwern> dons: does galois just use cabal-install as a in-house dev's tool, or are actual customers using it?
10:24:36 <gwern> dons: also, how does the 'line/column for errors' thing work? is that just a convention, devs manually counting them and inserting them into error's string arg?
10:24:59 <BONUS> hmm what if you
10:25:12 <BONUS> yeah, what if some lines upward push some lines with error downwards
10:25:39 <gwern> BONUS: there are tricks to avoid manual things. like I uploaded a prelude replacement package which abused CPP to determine line numbers for non-total functions like head
10:25:56 <BONUS> ah co0l
10:26:31 <gwern> (interesting code. fortunately I rarely run into exceptions from prelude functions, or I know where they are)
10:27:31 <BONUS> i only sometimes get tripped up by div, but i've gotten used to checking for 0 now
10:28:44 <dons> gwern: hah, no. we use tools :)
10:29:05 <dons> "manually counting line/columns" is a bit ridiculous, don't you think? :)
10:29:07 <gwern> well, I sort of assumed. haskell-src-exts based parsing perhaps?
10:29:24 <dons> we've a few preprocessors lying around. i think they're cpp-based
10:29:44 <gwern> (I guess it could be a parser, which gets called as a preprocessors via the ghc -Fgmc trick)
10:37:01 <Berengal> I've got the feeling most Haskell code is BSD, am I right?
10:37:23 <Saizan> it seems like that
10:37:41 <Berengal> Are there any major GPLed Haskell projects at all?
10:37:48 <bremner> except that using n+k patterns
10:37:55 <McManiaC> is there a way to use the return of a io function like "a -> IO b" in a function that takes one arguemnt of type b without having to write an extra line like "f a >>= \b -> g b" ?
10:38:02 <gwern> Berengal: what, like darcs or yi?
10:38:05 <Saizan> anyone used the libsvm bindings?
10:38:06 <dons> Berengal: ~77% on hackage
10:38:12 <dons> darcs is GPLd
10:38:15 <Cale> McManiaC: You can just write  f a >>= g
10:38:16 <McManiaC> or do { b <- f a; return g b }
10:38:25 <Berengal> Interesting...
10:38:36 <Berengal> dons: You got stats for GPL as well?
10:38:36 <dons> apps are more likely to be GPLd than libraries
10:38:36 <gwern> not really. small languages want to be bsd-biased
10:38:38 <Cale> McManiaC: but you must use either do-notation, bind, or one of the other combinators to run the IO action
10:38:48 <gwern> it's the big languages that need gpl protection
10:38:53 <dons> 16% GPL
10:39:02 <McManiaC> Cale: bind?
10:39:05 <Cale> >>=
10:39:08 <McManiaC> ok
10:39:11 <McManiaC> pity
10:39:13 <McManiaC> :)
10:39:14 <Cale> g =<< f a  might be a nice way
10:39:24 <Cale> McManiaC: If you just pass the IO action as a parameter, it will mean that the *action* is passed as a parameter, not its result
10:39:26 <gwern> dons: that's a good point too. executables aren't linked into stuff in the same way libraries are, so people don't care nearly so much whether darcs is gpl or bsd
10:39:41 <Cale> McManiaC: This seems like it might be an inconvenience, but it has its advantages as well.
10:39:42 <dons> right
10:39:53 <dons> though cabal makes it more likely to use apps as libraries
10:40:12 <gwern> you mean the library/executable style is encouraged more?
10:40:16 <dons> yep
10:40:31 <dcoutts> aye, it's common to take an app, expose all the modules as a lib and make the exe dep on the lib
10:40:33 <dons> its trivial to turn a cabalised app into a library
10:40:38 <dons> unlike in almost every other build system
10:40:38 <Cale> McManiaC: In particular, you can write functions which take IO actions as parameters, and make use of them when and how they need to, like custom control structures.
10:40:45 <dcoutts> then refactor 'til the internal modules export a nicer API
10:40:46 <gwern> true. how would you even turn a autotools executable into a library?
10:41:10 <McManiaC> Cale: but if you want to use "if" with the result of "a -> IO Bool" for example you have to add another "myTest <- runTest foobar" line before the if block in a do-notation?
10:41:13 <dcoutts> dons, gwern: needs support for that cabal feature to let an exe dep on the lib in the same package
10:41:18 <Cale> McManiaC: Yeah.
10:41:20 <bremner> heh, don't get too proud until you can make shared libs :-)
10:41:30 <Cale> McManiaC: Or of course, you can write your own if :)
10:41:34 <dcoutts> dons, gwern: for it to be really convenient. otherwise it builds everything twice
10:41:37 <dons> IHG task, iirc
10:41:42 <Cale> McManiaC: There are 'when' and 'unless' in the Control.Monad library
10:41:46 <Cale> :t when
10:41:47 <dcoutts> bremner: we're working on it
10:41:47 <gwern> bremner: the power of shared libs is as nothing compared to the power of the force!
10:41:47 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:41:57 <Cale> er, well, that's a little different
10:41:59 <McManiaC> yup i already used them
10:42:13 <McManiaC> but u still have to write that line
10:42:16 <Cale> But it wouldn't be hard to write something of that sort which took an m Bool
10:42:25 <dcoutts> bremner: I'm currently updating the new ghc build system to handle shared libs (which had partial support in the old build system)
10:42:25 <Cale> If you have to do it a lot.
10:42:31 <McManiaC> ok
10:42:48 <grapey> Mollie_C_xo@live.co.uk
10:43:06 <grapey> smellie-x@hotmail.com
10:43:12 <Cale> grapey: ?
10:43:23 <Cale> what?
10:43:25 <gwern> spam
10:43:29 <bremner> spam?
10:43:36 <ali_clark> who benefits from that?
10:43:43 <mauke> spammers
10:43:49 <Raevel> girls? though maybe i'll pass on chatting with smellie-x
10:43:50 <McManiaC> whenM test run = do { t <- test ; when t run }
10:43:53 <Cale> Is he baiting spammers into taking those email addresses?
10:43:55 <bremner> dcoutts: cool.
10:44:06 <McManiaC> or just liftM when?
10:44:07 <McManiaC> ^^
10:44:19 <Cale> McManiaC: yeah, that works there.
10:45:01 <McManiaC> @type liftM2 when
10:45:02 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 Bool -> m1 (m ()) -> m1 (m ())
10:45:21 <McManiaC> @type (join.liftM2) when
10:45:22 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m ()'
10:45:22 <lambdabot>       Expected type: Bool -> Bool -> r
10:45:22 <lambdabot>       Inferred type: Bool -> m () -> m ()
10:45:26 <McManiaC> :o
10:47:24 <ali_clark> I got another fun beginner question for you guys...
10:47:32 <ali_clark> fun1 :: (Num a) => a -> a; fun1 = (+ 1)
10:47:37 <ali_clark> fun2 = ((+ 1) :: (Num a) => a -> a)
10:47:57 <McManiaC> @type join $ liftM2 when
10:47:57 <ali_clark> the second comes out with Integer -> Integer , is that expected?
10:47:58 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m ()'
10:47:58 <lambdabot>       Expected type: m1 Bool -> m1 Bool -> a
10:47:58 <lambdabot>       Inferred type: m1 Bool -> m1 (m ()) -> m1 (m ())
10:48:14 <gwern> ali_clark: sure. 1 defaults to Integer
10:48:23 <Berengal> Actually, it's the MR
10:48:30 <gwern> hush you
10:48:36 <ali_clark> gwern: then how come the first gets away with it?
10:48:51 <Berengal> (+1) is polymorphic, but when it gets bound to fun2 the MR defaults it
10:49:09 <Berengal> fun1 isn't defaulted because it has a type signature
10:50:15 <Cale> ali_clark: The monomorphism restriction means that pattern bindings without explicit type signatures must not be typeclass polymorphic.
10:50:28 <Cale> ali_clark: fun1 has an explicit type signature, so the MR doesn't apply
10:50:41 <Cale> ali_clark: Normally I just turn the MR off since it's a nuisance.
10:51:17 <ali_clark> okay thanks, I guess I can see how they're not really the same now
10:51:28 <Cale> (though, having to type  {-# LANGUAGE NoMonomorphismRestriction #-}  is also a bit of a nuisance)
10:51:37 * Berengal keeps the MR on unless it's severely hampering his style. Adding type signatures is good practice anyway
10:52:39 <ali_clark> but it is a bit weird, even : fun3 = let { f' = (+ 1); f' :: (Num a) => a -> a; } in f'    comes out as Integer -> Integer
10:53:06 <romildo> Hi.
10:53:36 <seliopou> monomorphism restriction?
10:53:36 <Berengal> ali_clark: It's all because fun3 is interpreted as a value, and values can't be polymorphic, even when they're functions...
10:54:01 <romildo> How do I get an editable CellRendererToggle in a TreeView in gtk2hs?
10:57:11 <ali_clark> I guess you guys must have thought this through alot already, I'll go read up on MR :)
10:57:28 <vixey> ali_clark: best thing is to just turn off MR
10:57:42 <Berengal> Or add type signatures...
10:57:56 <vixey> that's not also the best :p
10:58:07 <Berengal> It's good enough most of the time
10:58:29 <Cale> ali_clark: note that if it has an explicit parameter, it also avoids the MR
10:59:13 <skorpan> i've cabal installed parsec on my user account, but how do i make ghc recognize it without writing my own cabal file?
10:59:15 <Cale> ali_clark: The MR is both overzealous in what it applies to, and should not have been treated as a compile error (a warning would have done the same job in a less irritating way)
10:59:34 <dcoutts> skorpan: it'll be available automatically
10:59:46 <Berengal> Hackage needs an Acme hierarchy...
10:59:50 <skorpan> dcoutts: ghc --make can't find it though
11:00:01 <skorpan> i know it's installed, because cabal tells me so
11:00:03 <monochrom> http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:00:07 <dcoutts> skorpan: then it's not properly registered
11:00:13 <dcoutts> skorpan: ghc-pkg list parsec
11:00:34 <skorpan> dcoutts: yep, it's there alright
11:00:35 <Cale> ali_clark: Basically, it's there to prevent performance problems when something like  myBigNumber = product [1..100000]  gets re-evaluated every time it's used because it's polymorphic.
11:00:40 <skorpan> both globally and on my user account
11:00:54 <dcoutts> skorpan: ok, does ghci -package parsec work?
11:01:11 <skorpan> hm... no. :|
11:01:18 <skorpan> i get "couldn't find module Parsec"
11:01:19 <skorpan> weird
11:01:30 <dcoutts> skorpan: there is no module Parsec
11:01:35 <monochrom> Heh
11:01:41 <skorpan> then this documentation i'm reading is way old i guess
11:01:47 <skorpan> 2001, wow
11:01:49 <monochrom> Yes it is.
11:01:49 <uccus> anyone with a bit of time here: I have a really weird question. is ((->) a) an instance of Applicative? is pure = const here?
11:01:51 <dcoutts> skorpan: sounds likely
11:02:09 <mauke> uccus: yes
11:02:10 <Cale> uccus: yes
11:02:16 <mauke> uccus: it's not very weird :-)
11:02:20 <uccus> hehe thanks guys you are the best
11:02:23 <ali_clark> Cale: thanks i'd say that makes sense
11:02:26 <dcoutts> skorpan: ghc-pkg field parsec exposed-modules
11:02:30 <vixey> > pure () :: ()
11:02:31 <lambdabot>       Ambiguous occurrence `pure'
11:02:31 <lambdabot>      It could refer to either `Control.Appl...
11:02:32 <Berengal> uccus: ((->) a) is even a monad
11:02:35 <vixey> > pure () () :: ()
11:02:36 <lambdabot>       Ambiguous occurrence `pure'
11:02:36 <lambdabot>      It could refer to either `Control.Appl...
11:02:36 <Cale> If you know the SK calculus, the implementations of pure and <*> should be familiar
11:02:56 <monochrom> like, K and S respective? :)
11:03:00 <Cale> yes
11:03:17 <uccus> yes I have figured out that it is a functor and an applicative so I guess monads are the next natural step. pure is const, <*> is ap. id is id from category
11:03:28 <uccus> id is I
11:03:56 <Cale> > (do x <- id; y <- reverse; z <- map toUpper) "hello"
11:03:57 <lambdabot>   <no location info>:
11:03:57 <lambdabot>      The last statement in a 'do' construct must be an ...
11:04:01 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
11:04:03 <lambdabot>   ("hello","olleh","HELLO")
11:04:31 <Cale> ^^ an example of this monad :)
11:04:47 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
11:04:48 <lambdabot>   [5,7,10,25,32]
11:05:14 <Cale> > ap zip tail [1..5]
11:05:15 <skorpan> is there any up-to-date tutorial on how parsec works?  the old 2001 tutorial seemed so promising...
11:05:15 <lambdabot>   [(1,2),(2,3),(3,4),(4,5)]
11:05:18 <uccus> ok ok guys
11:05:49 <Berengal> skorpan: RWH has a chapter on parsec
11:06:07 <monochrom> Module names are about the only major difference.
11:06:19 <skorpan> thanks
11:06:44 <uccus> sheesh
11:06:47 <uccus> :D
11:06:58 <monochrom> A few of the functions are moved to from the Combinators module the Prim module, but you won't easily notice that.
11:07:29 <monochrom> The haddock pages of 3.x.x.x are fairly complete.
11:17:45 <Berengal> Acme.CurrentTime: Provides a pure way to get the current day, provided the package is kept up to date
11:17:59 * monochrom tries Berengal's "fix error" in ghci :)
11:18:20 <monochrom> hahahahaha
11:18:24 <mauke> @quote hint.*beg
11:18:24 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
11:18:45 <monochrom> Is that a real module?
11:18:48 <Berengal> Hehe. Rather the opposite
11:19:10 <Berengal> monochrom: No. I'm just looking through CPAN and wondering if it might be fun to port some to hackage
11:19:19 <mauke> http://search.cpan.org/~jesse/Acme-Current-Forever-1.00/lib/Acme/Current.pm
11:19:51 <monochrom> haha
11:21:36 <dons> Berengal: that's a good idea.
11:22:06 <dons> Berengal: also http://www.reddit.com/r/haskell_proposals
11:24:23 <gnuvince> dons: are your slides for the London Haskell User Group online yet?
11:24:46 <dons> yes.
11:24:58 <dons> http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
11:25:07 <gnuvince> Thanks!
11:25:39 <Hunner> Ooo, the FP conference is this Thursday
11:26:16 <Salve> **Looking for my shotgun**
11:26:30 <Salve> I think i've been playing to much left4dead
11:31:24 <gnuvince> dons: what does the expression "2 rungs above performance spec" mean?
11:32:01 <dons> application-specific requirements. we were two ratings higher than required.
11:32:51 <dons> i.e. perf. not an issue.
11:33:52 <gnuvince> ok
11:39:22 <pumpkin_> that point in your slides about BSD for static linking is interesting
11:41:43 <edwardk> dons: awesome talk
11:42:02 <pumpkin_> we need videos!
11:42:03 <pumpkin_> :)
11:42:10 <burp_> ghc for opensolaris, anyone tried it?
11:42:11 <pumpkin_> the slides are good
11:42:13 <gnuvince> dons: hope you don't mind: http://www.reddit.com/r/programming/comments/8fw51/talk_by_reddits_own_dons_presented_at_%CE%BBondon_hug/
11:42:33 <pumpkin_> edwardk: I made the fold into a ContraFunctor just for the fun of it
11:43:03 <edwardk> pumpkin_: fold?
11:43:21 <edwardk> pumpkin_: i've since lost context ;)
11:43:31 <pumpkin_> I've been playing with fold combinators like Taejo described in his blog a while back
11:43:44 <edwardk> which one in particular?
11:43:46 <pumpkin_> http://github.com/pumpkin/folds/blob/49a8fc30c57567067dce5fcf0c31bc585ef28c29/Fold.hs
11:43:50 <Hunner> burp_: I've been having a horrible time trying to get ghc on sol10, but haven't tried opensol yet
11:44:01 <pumpkin_> http://squing.blogspot.com/2008/11/beautiful-folding.html is the original post
11:44:18 <edwardk> ah an explicitly existential fold
11:44:31 <pumpkin_> my code turned ugly because I decided to make a Num instance for it
11:44:41 <burp_> Hunner, must be similar there then :(
11:45:07 <vixey> > naiveMean xs = sum xs / fromIntegral (length xs)
11:45:07 <lambdabot>   <no location info>: parse error on input `='
11:45:11 <vixey> why don't you call that one uglyMean :p
11:45:19 <pumpkin_> lol
11:45:44 <pumpkin_> it's not a good mean either, even if you could do it efficiently
11:45:48 <pumpkin_> but it's a fun example
11:45:50 <edwardk> pumpkinL i have a library i was working on after msfp that includes a generic version of that
11:45:59 <edwardk> i don't know that i ever posted it
11:46:07 <pumpkin_> ooh
11:46:09 <pumpkin_> generic how?
11:46:10 <edwardk> (that generalizes to any functor)
11:46:18 <Taejo> pumpkin: you could have fromInteger = pure
11:46:25 * vixey wants to know how to fuse  foldr f [] . foldr g []  without build
11:46:31 <pumpkin_> Taejo: true, not sure why I didn't put that in
11:46:47 <wli> @type uncurry (/) . foldr (\x (n, s) -> (n + 1, s + x)) (0, 0)
11:46:48 <lambdabot> forall a. (Fractional a) => [a] -> a
11:47:30 <pumpkin_> I did this using a GADT before
11:47:40 <pumpkin_> but the GADT-ness of it prevented it from fusing nicely
11:47:53 <pumpkin_> so I moved back to the function one
11:47:54 <edwardk> vixey: i was going towards implicit cata/build fusion by transforming the functor into build form. i'd had a nice few hour discussion with tarmo uustalu about it and went pretty deep in that space and a few days later wandered off and looked at something else shiny ;)
11:48:14 <pumpkin_> edwardk: release it! I'm hungry :D
11:48:39 <edwardk> pumpkin_: heh, i'll see if i can dig it up
11:49:12 <edwardk> i've been chewing through machines like popcorn over the last 6 months or so, so i'm not quite sure where all my little code odds and ends are at the moment.
11:49:30 <pumpkin_> Taejo: my next step is to play with the same idea in TH
11:50:00 <skorpan> @src ErrM
11:50:00 <lambdabot> Source not found. I feel much better now.
11:50:03 <skorpan> @hoogle Errm
11:50:04 <lambdabot> No results found
11:50:07 <Taejo> pumpkin: I'm not sure how you get there from here
11:50:08 <skorpan> what is ErrM? :P
11:50:08 <kadaver> what is the name of a good C mp3 lib, i always forget
11:50:25 <kadaver> @src flip
11:50:26 <lambdabot> flip f x y = f y x
11:50:34 <orbitz> kadaver: search freshmeat
11:50:42 <kadaver> @src zipWith
11:50:43 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
11:50:43 <lambdabot> zipWith _ _      _      = []
11:50:48 <skorpan> hm, nvm
11:51:09 <pumpkin_> the ideal would be BSP's ghc plugins
11:51:09 <pumpkin_> but it's not ready yet
11:51:09 <pumpkin_> Taejo: oh, I wouldn't be able to reuse much code, but the same basic idea, using a list of known folds
11:51:11 <edwardk> pumpkin: contrafold is pretty gratuitous, if you're a bifunctor that is contravariant in your first argument and covariant in your second, you're probably a Category, which expresses that much more intuitively.
11:51:36 <edwardk> pumpkin: though i didn't look in depth to make sure it would work
11:51:46 <pumpkin_> edwardk: oh, it was mostly as a joke :P I just saw that after was a nice fmap
11:51:55 <pumpkin_> and asked about a co-fmap :P so people pointed me to ContraFunctor and I used it
11:52:08 <ehird> What is the appropriate data structure to use for a very efficient 2D array?
11:52:18 <Botje> how spare is it?
11:52:23 <pumpkin_> anyway, gotta go :)
11:52:25 <pumpkin_> bbl
11:53:12 <ehird> Botje: Well, uh, it covers the whole range of signed platform ints, and only a miniscule amount of that, around the center, will generally be used
11:53:15 <ehird> So: Very.
11:53:21 <ehird> Sparse I assume you mean
11:53:31 <Botje> then you probably want a Data.Map or IntMap
11:53:39 <ehird> Botje: What's an IntMap?
11:53:46 <Botje> Map specialized for ints
11:53:49 <ehird> Ah
11:53:55 <ehird> Botje: So a nested IntMap or a Map on (Int,Int)
11:54:01 <Botje> ehh
11:54:09 <ehird> Still, I'm looking for mega speed for lookups here.
11:54:14 <ehird> Run in a very tight loop.
11:54:26 <Botje> IntMap only assuming you think it's worthwhile stuffing your coordinates in one Int
11:54:28 <ehird> A hash table of some sort would probably work best...
11:54:30 <Botje> otherwise, go for Map
11:54:36 <ehird> Botje: Impossible; it's (Int,Int)
11:54:51 <Botje> you can combine two ints into one
11:54:59 <Botje> if you're only going to use a miniscule amount
11:55:12 <ehird> Botje: In practice.
11:55:16 <ehird> Theoretically, any amount can be used.
11:55:18 <ehird> It's an interpreter.
11:55:21 <Botje> ah.
11:55:25 <Botje> then just go for a Map
11:55:28 <ehird> Kay. Thanks.
11:55:43 <Botje> Hash tables are available too, but if you're going to add to it you're boned
11:56:27 <ehird> mm
11:56:41 <ehird> Botje: Maybe I should use an unboxed (# Int, Int #) tuple?
11:56:50 <Botje> yeah
11:56:57 <Botje> I believe there's a strict-pair package on hackage
11:57:02 <wli> Well, you're best off rolling a flexible array by hand that avoids using arrays so large that the GC's lack of card marking kills you.
11:57:04 <edwardk> Data.HashTable should have some kind of {-# DEPRECATED #-} flag or something to scare people away
11:57:15 <Botje> Data.Strict.Tuble
11:57:18 <Botje> *Typle, even
11:57:20 <Botje> *TUPLE
11:57:24 * Botje stares at his keyboard
11:57:29 <Botje> always trying to sabotage me
11:57:31 <edwardk> botje: there are several, depending on how strict you want to me
11:57:44 <edwardk> adaptive-containers has one that even unboxes
11:57:52 <ehird> Botje: That's not unboxed.
11:58:04 <ehird> (# !Int, !Int #) would probably be the most raw thing that fits my purposes.
11:58:11 <eu-prleu-peupeu> is there any ffi to python ?
11:58:12 <Botje> oh.
11:58:20 <Botje> It's strict, not unboxed, yes.
11:58:22 <wli> AIUI the library hash table does not avoid taking hte huge hit from the GC on that front.
11:58:24 <Botje> sorry :)
11:58:26 <ehird> :)
11:58:45 <c_wraith> eu-prleu-peupeu: only through C.  And that sounds like a real pain.
11:58:58 <eu-prleu-peupeu> c_wraith: indeed :/
11:59:13 <ehird> Hmm...
11:59:18 <eu-prleu-peupeu> i guess ill have to endure it :/
11:59:19 <ehird> What is needed for (# !Int, !Int #)?
11:59:24 <ehird> MagicHash, BangPatterns doesn't work
11:59:27 <ehird> I get a parse error on !
11:59:44 <edwardk> ehird: the ! isn't legal there
11:59:45 <Saizan> you can't have ! in types like that.
11:59:48 <Valodim> aah, that new wiki logo is much better
11:59:57 <edwardk> ehird: you can use (# Int#, Int# #)
12:00:08 <ehird> edwardk: Ah
12:00:14 <ehird> And then make a strict constructor?
12:00:28 <edwardk> but you might have a better time just defining, data IntPair = IntPair {-# UNPACK #-} !Int {-# UNPACK #-} !Int
12:00:30 <ehird> edwardk: OTOH, that makes doing any maths on the coordinate a real pain.
12:00:31 <edwardk> and using that
12:00:32 <ehird> ah
12:00:33 <Saizan> data IntPair = IntPair {-# UNPACK #-} !Int {-# UNPACK #-} !Iint
12:00:33 <ehird> thanks
12:01:23 <Saizan> typing {-# on an it keyboard is a PITA
12:01:31 <edwardk> you can even omit the {-# UNPACK #-} -- and just rely on -funbox-strict-fields
12:01:38 <ehird> edwardk: is that wise, though?
12:01:38 <edwardk> saizan: heh
12:01:51 <edwardk> ehird: not terribly, i like to keep it in to be precise
12:02:03 <ehird> how does that work with record syntax?
12:02:11 <ehird> { {-# UNPACK #-} x :: !Int,
12:02:12 <ehird> ?
12:02:27 <edwardk> ehird: Foo { x :: {-# UNPACK #-} !Int, ...
12:02:33 <ehird> thanks
12:06:10 <ehird> data Point = Point { x :: {-# UNPACK #-} !Int
12:06:10 <ehird>                    , y :: {-# UNPACK #-} !Int }
12:06:13 <ehird> is what I want for
12:06:16 <ehird> with point !(!x,!y) = Point { x = x, y = y }
12:06:21 <ehird> *went
12:07:16 <edwardk> have any more !'s you want to throw in there? =)
12:07:27 <ehird> edwardk: Yes!!!!!!!!!!!!!
12:07:36 <edwardk> i the (x,y) is strict you don't need one around it
12:07:56 <ehird> I don't need any, the fields are strict :-)
12:08:06 <edwardk> thats where i was going next =)
12:10:35 <ehird> point (x,y) *will* always be inlined... right?
12:10:46 <ehird> w/ -O2
12:10:53 <edwardk> paranoid much? =)
12:11:19 <ehird> edwardk: My performance competitors include a guy whose code is C littered with branch prediction stuff and _posix_fadvise.
12:11:26 <edwardk> hahahaha
12:11:30 <edwardk> what are you doing?
12:11:58 <ehird> Writing a http://esolangs.org/wiki/Befunge -98 interpreter: http://cpansearch.perl.org/src/JQUELIN/Language-Befunge-4.10/lib/Language/Befunge/doc/bf98-specs.html
12:12:09 <p_l> ehird: is he also manually mainpulating cache? :D
12:12:13 <kadaver> what does unpack do?
12:12:19 <edwardk> the competition is so fierce, because the stakes are so small
12:12:20 <ehird> Possibly the most bloated, extensible (it has modules...) esoteric language on the planet
12:12:40 <ehird> kadaver: puts the ints directly in, instead of via a pointer, I think
12:12:43 <Berengal> ehird: There's Java...
12:12:51 <edwardk> kadaver: normally an Int is represented by a thunk in memory that can be forced to obtain the value. unpacking it forces it when you go to stick it in the field and then stuffs a real machine integer into the thunk directly
12:12:58 <ehird> Berengal: *groan*
12:13:10 <Berengal> I know, it was low...
12:14:04 <wli> Am I the only one who finds th "esoteric languages" unworthy of any attention/notice/etc. whatsoever?
12:14:16 <edwardk> kadaver: data Foo = Foo {-# UNPACK #-} !Int {-# UNPACK #-} !Double -- is a single constructor wrapped around an integer and double directly. while data Foo = Foo Int Double -- is a Foo tag wrapped around a pair of pointers, one to a thunk that evaluates to an Int and one that evaluates to a Double
12:14:22 <edwardk> wli: no
12:14:34 <Botje> some of them are worth thinking about/over
12:14:38 <ehird> wli: PROGRAMMING IS SERIOUS BUSINESS
12:14:50 <ehird> Fun is strictly forbidden, lest we write unmaintainable code!
12:14:54 <lament> the stuff edwardk does certainly seems esoteric to me
12:14:55 <dschoepe> wli: I think they are useful as exercises for compiler/interpreter writing
12:15:03 <ehird> Most of all, theoretical models are NEVER helpful to discover new concepts.
12:15:04 <dschoepe> Or simply entertainment
12:16:40 <edwardk> wli: i liked jot as a Goedel numbering, but I find most esolangs tedious
12:17:18 <vixey> seen one seen 99% of them
12:17:19 * wli suggests that there are better languages for exercises in compiler/interpreter writing.
12:17:31 <lament> the one where you can assign numbers to different numbers and control flow is done by line numbering is pretty clever
12:17:38 <ehird> wli: have you considered it's a fun timekiller?
12:17:54 <edwardk> wli: sure, any language with a sufficiently complicated module system, for instance ;)
12:18:03 <lament> ehird: do you remember the name of the one i'm talking about?
12:18:11 <edwardk> ehird: yes i've killed many a fun time doing that
12:18:12 <kadaver> can haskell call dll?
12:18:12 <ehird> lament: Forte.
12:18:21 <ehird> lament: http://esolangs.org/wiki/Forte
12:18:30 <edwardk> @faq can haskell call dll?
12:18:30 <lambdabot> The answer is: Yes! Haskell can do that.
12:18:33 <monochrom> wli: You are not the only one to pay no attention. You are just the only one who say you pay no attention. Me, for example, I pay so no attention that I don't even bother bringing it up. :)
12:18:41 <lament> ehird: thanks
12:18:52 <ehird> @faq can haskell be an esolang?
12:18:53 <lambdabot> The answer is: Yes! Haskell can do that.
12:19:10 <PeakerWork> the main Israeli bus company logo: http://egged.co.il/images/logo.jpg
12:19:25 <PeakerWork> my friend saw the Haskell logo and thought it was Egged :)
12:20:05 <Botje> "egged"
12:20:05 <monochrom> Yeah, everyone is finding the logo too similar to most railway logos etc. :)
12:20:16 <Botje> that's a fun company name :)
12:21:26 <wli> monochrom: In non-esolang-related affairs, slapping a higher-order module system atop basic FP lang constructs is proving difficult for me.
12:22:18 <wli> monochrom: http://wli.pastebin.com/m11009a94 is about as far as I've gotten wrt. cooking up AST ADT's for it.
12:22:29 <ehird> 20:21 wli: monochrom: In non-esolang-related affairs, slapping a higher-order module system atop basic FP lang constructs is proving difficult for me.  ← that's not esoteric‽
12:22:48 <monochrom> No, SML does that and not eso
12:23:06 <wli> Yes, that's why it's non-esolang-related.
12:23:07 <kadaver> is haskell defined in BNF?
12:23:07 <kadaver> how do you use dlls?
12:23:17 <monochrom> Hell, modula-3 does that and can even be imperative, not just functional.
12:23:20 <vixey> no about BNF
12:23:37 <edwardk> kadaver: can't be, layout doesn't fit BNF style
12:23:58 <ehird> ML is esoteric.
12:24:15 <Berengal> Define esoteric...
12:24:32 <vixey> no don't
12:24:40 <monochrom> I guess I have to look up "esoteric" for real. The word is so... esoteric... that I haven't bothered to. :)
12:24:42 <vixey> this is #haskell
12:24:44 <Berengal> Some research languages certainly border on esoteric
12:25:10 <edwardk> esoteric is any language stranger than what I could ever foresee myself getting paid to use some day. ;)
12:26:05 <Berengal> That's certainly a pragmatic view
12:26:31 <monochrom> I guess "esoteric" is defined by community size.
12:26:44 <edwardk> berengal: i'm sure there is a diagonalization argument available where someone hands me a $20 bill to slap together some malbolge some day, but, meh ;)
12:27:29 <monochrom> diagonalization is not supposed to be used like that! :)
12:27:48 <Berengal> edwardk: I once ran a contest where I offered to buy SM equipment for anyone who provided a malbolge entry
12:27:54 <edwardk> monochrom: there is a certain modicum of 'deliberately obtuse' that comes with the esoteric moniker
12:27:55 * ehird tries to come up with a nice binary operator for Point-construction
12:28:13 <kosmikus> cinema: pong
12:28:17 <edwardk> ehird: :*: is whats used in uvector for its strict pairs
12:28:27 <ehird> I tried .:. but it looks awkward
12:28:31 <ehird> Maybe ::
12:28:34 <edwardk> then its not just for construction, its the type operator
12:28:43 <ehird> O hwait
12:28:45 <ehird> that's taken, duhh
12:28:46 <ehird> *duh
12:28:50 <edwardk> hah
12:29:07 <edwardk> :*: has the benefit of indicating its a 'product'
12:29:30 <edwardk> :* is about as short as you could get and be a type operator, but its asymmetric
12:29:41 <edwardk> er 'is as short as you could get'
12:29:43 <ehird> Type operator isn't important, just operator :P
12:29:57 <edwardk> ehird: bah, support first class pattern matching ;)
12:30:25 <edwardk> otherwise you're stuck with contorting your code to work around this not being a pair
12:31:32 <ehird> how about .*.
12:31:59 <edwardk> ehird: at that point in time you might as well make them colons and get pattern matching syntax for free ;)
12:32:00 <ehird> aw that's not a type operator
12:33:32 <wli> Well, the point of what I'm on about is to interpret statically-checked FP crap that has modules in it.
12:35:40 <edwardk> data Point = (:*:) { x :: {-# UNPACK #-} !Int, y :: {-# UNPACK #-} !Int } deriving (Eq,Ord,Show,Read,KitchenSink) -- taxicab (a :*: b) = abs a + abs b
12:36:15 <edwardk> or taxicab p = abs (x p) (y p) -- god naming the fields x and y is horrific ;)
12:36:25 <vixey> why don't you use (,)?
12:36:44 <edwardk> vixey: he wants ridonculous speed or something
12:37:26 <ehird> yar
12:37:28 <ehird> unboxed strictity
12:37:46 <ehird> :*: is hard to type, I think I'll just have (Point x y) :-P
12:38:04 <edwardk> meh
12:38:47 <monochrom> windows (x p)  :)
12:39:07 <edwardk> better than windows (m e)
12:39:36 <PeakerWork> I dislike record fields being getters by default. I think they should be lens/accessors by default
12:39:45 * p_l is instantly reminded of the "Troubled Windows" Opening...
12:40:01 <edwardk> peaker: not a bad idea, had the idiom been established back when they added records to the language
12:40:14 <monochrom> Yeah, I think there is no good name for the two coordinates (either too common like "x" or too long like "x_coord"). Since there are only two fields, you don't need names that much. Perhaps call them "get_x" "get_y".
12:40:49 <edwardk> monochrom: except _'s aren't haskelly, so you get the ugly getX and getY
12:41:03 <monochrom> get'x get'y
12:41:06 <monochrom> Oleggy
12:41:11 <edwardk> *shudder*
12:41:18 <PeakerWork> edwardk: I hope it goes into Haskell'
12:41:32 <edwardk> peaker: doubtful, that would break a ton of code
12:41:40 <PeakerWork> I thought Haskell' was all about breaking code :-)
12:41:50 <monochrom> Not verily.
12:42:04 <edwardk> Peaker: nah, haskell' is about noting the fac tthat there has been a decade of progress since haskell 98, so lets pin some of it down and support it
12:42:29 <wjt> PeakerWork: "lens"?
12:42:47 <monochrom> My understanding is Haskell' is allowed to break some code but should not be too much.
12:43:14 <edwardk> the only thing being really broken in haskell 98 is n + k patterns, which were only supported in 98 for legacy reasons already! and if you listen to Richard O'Keefe the sky is falling and it will cause him years of rewrites.
12:43:17 <PeakerWork> wjt: "functional references", Data.Accessor, and various other isomorphic structures/aliases
12:43:23 <monochrom> It's more important mission is to legalize a lot of extensions since 98.
12:43:49 <PeakerWork> edwardk: surely an automated tool can fix   n + k   patterns automatically in code?
12:44:02 <edwardk> Peaker: thats the camp that i'm in
12:44:08 <vixey> what does fix n + k mean?
12:44:14 <PeakerWork> Python 3k have the python2to3 script
12:44:18 <edwardk> vixey: machine translate, etc.
12:44:22 <vixey> ?
12:44:26 <monochrom> "Haskell' : legalize cocaine and comonads now!"
12:44:28 <Saizan> i don't think (n+k) patterns are that evil either
12:44:48 <PeakerWork> vixey: translate n+k matches to subtractions/guards (I don't know the exact semantics of these patterns)
12:44:48 <Gracenotes> > let f 0 = []; f s@(n+1) = s:f n in f 10
12:44:50 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
12:44:50 <pumpkin_> they're not evil, but they're silly I think
12:44:58 <edwardk> monochrom: i don't know that the world is ready for comonads. lets take this slowly
12:45:12 <monochrom> Heh
12:45:31 <edwardk> introduce them for medical purposes on a State monad by State monad basis.
12:45:36 <vixey> what's the point it turning n+k into something equivalent
12:45:54 <Saizan> vixey: removing them from the language
12:45:56 <edwardk> vixey: to get them out of the language and to give the whiners a graceful exit path
12:46:17 <Gracenotes> come now, didn't you all want to pattern-match on addition since childhood?
12:46:25 <Gracenotes> are you taking this dream away from people too???
12:46:41 <uccus> what's (const id) . fa <*> fb?
12:46:46 <monochrom> Take the childhood away from the people.
12:46:50 <vixey> if you are removing n+k then I'm removing Prelude
12:46:55 <vixey> I hate Prelude it is a nuisance
12:46:58 <uccus> I'm removing Prelude
12:47:00 <monochrom> hehe
12:47:04 <Gracenotes> :o you wouldn't
12:47:09 <vixey> I'll do it
12:47:13 <uccus> yes I would
12:47:18 <neoswish> can anyone explain me, why its impossible to write type signatures in the same line with definition? =)
12:47:20 <edwardk> its funny at icfp06 during the haskell' get together there was a Credit Suisse guy panicking about how Haskell' would change his world, and at the time I stood up and joked that the only language feature anyone was even considering pulling was n + k, and at the time the entire room
12:47:31 <idnar> edwardk: why are n + k patterns broken?
12:47:31 <monochrom> See, this is why Haskell' will never finish.
12:47:37 <uccus> but what's (const id) . fa <*> fb
12:47:48 <edwardk> demurred that it was entirely a joke... now here we are 2-3 years later and folks are finally considering it in earnest
12:47:52 <vixey> uccus that's what it is you wrote it
12:47:56 <Gracenotes> @type (const id) . ?fa <*> ?fb
12:47:57 <lambdabot> forall a b a1. (?fb::a1 -> a, ?fa::a1 -> b) => a1 -> a
12:48:37 <ivan-kanis> can i tell at runtime if ghc is on Windows or Unix?
12:48:43 <edwardk> idnar: they can't rebind if you have a different '+' in scope and they rely on unverifiable semantics of Num's - and + method, and they mislead you into thinking that Haskell can do this magic for any method
12:48:43 <Saizan> it's fa, apparently?
12:48:48 <Saizan> ah, no, fb
12:49:07 <Saizan> ivan-kanis: System.Info should have that
12:49:10 <DrSyzygyFR> ivan-kanis: I saw something recently about macros being defined by the compiler.
12:49:11 <uccus> Saizan... please please guide me through your reasoning...
12:49:14 <idnar> edwardk: I don't think "broken" is an appropriate word, in that case
12:49:18 <DrSyzygyFR> Or listen to Saizan who as always makes more sense
12:49:18 <vixey> edwardk they never mislead me
12:49:22 <idnar> edwardk: the feature works exactly as intended
12:49:22 <edwardk> idnar: if i have n + k patterns, why can't i write foo (as ++ bs) = ...
12:49:22 <Gracenotes> neoswish: it's the way Haskell does it syntactically. If you mean in ghci, then you can do something like...
12:49:25 <Gracenotes> > let a :: Int; a = 4 in a
12:49:26 <ivan-kanis> Saizan: thanks i'll look
12:49:27 <lambdabot>   4
12:49:46 <Saizan> uccus: i was just judging by the type
12:49:47 <DrSyzygyFR> Prelude> System.Info.os
12:49:47 <DrSyzygyFR> "darwin"
12:49:52 <DrSyzygyFR> ivan-kanis: Like that.
12:49:53 <Gracenotes> neoswish: or just > let a = (4 :: Int)
12:50:13 <ali_clark> isn't it broken simply because  + is not a data constructor and it is just a special case?
12:50:13 <ivan-kanis> DrSyzygyFR: thank you
12:50:15 <edwardk> idnar: i understand the pedagogical reason for its initial inclusion, but its a wart. like unary minus not forming a section.
12:50:24 <PeakerWork> I thought there was a simple rule: You get to pattern match on data constructors.  Except n+k -- does anything else violate this rule?
12:50:34 <vixey> unary minus!! yes
12:50:38 <idnar> edwardk: warts are generally best fixed by a new language
12:50:38 <vixey> Get rid of that
12:50:39 <DrSyzygyFR> ivan-kanis: Thank Saizan - he's the one who pointed it out.
12:50:40 <ivan-kanis> can I do conditional import ?
12:50:44 <vixey> unary minus is worse than n+k
12:50:52 <Gracenotes> Peaker well, if you think in terms of Succ and Zero...
12:50:52 <DrSyzygyFR> ivan-kanis: Use the CPP extension.
12:50:53 <PeakerWork> vixey: I agree -- its also an easily automatable fix
12:50:58 <idnar> edwardk: Haskell' claims to not be a new language, so dropping n + k in Haskell' seems out of place
12:50:59 <wli> Heck, I don't see why not allow m*n+k patterns like fib (2*n+1) = (fib n)^2 + (fib (n+1))^2 ; fib (2*n) = (fib n)*(fib n + 2*fib (n-1))
12:51:00 <ivan-kanis> DrSyzygyFR: ok
12:51:02 <PeakerWork> Gracenotes: No, I mean *literally* data-constructors
12:51:03 <DrSyzygyFR> And THEN you'll want that there are platform macros around.
12:51:05 <vixey> Hey we shhould design a new Haskell
12:51:11 <edwardk> wli: thats the slippery slope =)
12:51:13 <monochrom> Yes, n+k is the only non-constructor-based pattern.
12:51:29 <idnar> call it Haskell 3000, or something :P
12:51:29 <PeakerWork> there's a good reason to get rid of n+k -- complicating the language for no good reason
12:51:29 <monochrom> Succ and Zero are constructors too.
12:51:36 <Gracenotes> PeakerWork: but it's *like* a data constructor. To mesh with the Succ/Zero definition of numbers
12:51:45 <PeakerWork> idnar: Python 3000 is just the project name, its really just called Python 3
12:51:51 <idnar> PeakerWork: yes, I know
12:51:54 <PeakerWork> it can be called Haskell 2
12:51:54 <Gracenotes> that's the motivation behind n+k. Perhaps silly, but at least that's where it comes from afaia
12:51:58 <ali_clark> it might be cool to have some kind of logic or inverse-of system to allow it though?
12:52:01 <idnar> PeakerWork: but if I said Haskell 3, the joke would be rather obscure
12:52:06 <monochrom> And Succ is more like plain "n+1" than general "n+54958".
12:52:13 <vixey> ali_clark: that's what Curry does
12:52:15 <PeakerWork> Gracenotes: as far as you...?
12:52:30 <Gracenotes> am aware
12:52:40 <edwardk> Gracenotes: if you want n + k, provide a framework for generalized views that gives you that functionality on the left side of the =. i'm not against the idea, but it is an unnecessary wrinkle
12:52:42 <idnar> PeakerWork: it was already as obscure as it is; my point was that Python 3000 was always supposed to be a joke, and the fact that the Python developers have forgotten why it was a joke is rather disturbing
12:53:07 <edwardk> the major tie breaker for it back in 98 was that there were published books that taught using it, i'd say that 11 years is enough to let that card play out.
12:53:10 <Gracenotes> monochrom: well. (Succ (Succ (Succ (Succ ... (Succ x) ... ))))
12:53:27 <monochrom> Yuck, but OK I see now.
12:53:31 <vixey> this is why S is better than Succ, it's so much shorter
12:53:41 <ehird> configure: error: readline not found, so this package cannot be built
12:53:44 <ehird> But I have readline!
12:53:46 <ehird> (cabal package readline)
12:53:46 <PeakerWork> idnar: why was it a joke? :)
12:54:12 <monochrom> Someone once asked "why does Num require Eq" and the answer is n+k pattern.
12:54:13 <idnar> PeakerWork: because breaking backwards compatibility like that is suicide for a "production" language
12:54:17 <dcoutts> ehird: it'll be looking for the C lib and headers
12:54:24 <PeakerWork> monochrom: Num is a horrible class, IMO
12:54:26 <ehird> dcoutts: yes - and they are there.
12:54:37 <idnar> PeakerWork: for Haskell, you can always claim that it's part of "avoid success at all costs", and Haskell certainly isn't trying to be Python or Java
12:54:45 <edwardk> vixey: bah, you should use a pair of base cases, T and F, and then ave O and I for the individual bits that prefix the infinite tail, that way you can reason about it in 2s complement constructors.
12:54:49 <PeakerWork> idnar: you know the "slow death vs. quick death" thing?
12:54:50 <monochrom> See, n+k makes Num horrible.
12:54:56 <dcoutts> ehird: check the detailed output from configure, see what goes wrong when it tries to find them
12:54:59 <Gracenotes> you're a mean one, Mr. Num. You really are a heel
12:55:06 <PeakerWork> monochrom: Num is horrible with or without n+k :)
12:55:08 <ehird> dcoutts: how can I do that with cabal-install?
12:55:11 <monochrom> Heh
12:55:13 <idnar> PeakerWork: none of the warts that are "fixed" in Python 3000 are fatal, either individually or collectively
12:55:14 <Gracenotes> you're as cuddly as a cactus, you're as charming as an eel
12:55:15 <edwardk> monochrom: bah, Num makes Num horrible
12:55:15 <PeakerWork> @type abs
12:55:16 <Gracenotes> Mr. Num
12:55:17 <lambdabot> forall a. (Num a) => a -> a
12:55:19 <PeakerWork> ^^ Just plain wrong, IMO
12:55:21 <wli> The solution is simple. Haskell' is to standardize extensions. Haskell 2 is to break backward compatible.
12:55:26 <dcoutts> ehird: run the ./configure script manually and look at the config.log that it generates
12:55:28 <idnar> PeakerWork: they're all irrelevant superficial blemishes
12:55:35 <wli> s/compatible/compatibility/
12:55:36 <ehird> dcoutts: I'm doing "cabal install readline".
12:55:44 <PeakerWork> idnar: well, backwards compatibility with non-fatal things is a slow death..
12:55:48 <edwardk> wli: that was the initial thought, but now it looks like Haskell' is a rolling wave, not a single event
12:55:51 <Gracenotes> PeakerWork: it makes sense for some non-real Nums, not so much others
12:55:52 <dcoutts> ehird: then cabal unpack readline first and cd into it
12:55:53 <idnar> PeakerWork: it's like buying a new car without an engine, because your current car has some scratches on the paintwork
12:56:02 <PeakerWork> idnar: also, you now have Python2 and Python3 as two separate languages, that's an ok situation, imo
12:56:05 <idnar> PeakerWork: sure, the new one looks better, but you can't drive it anywhere
12:56:10 <ehird> ah I think it wants a newer version
12:56:26 <uccus> let { view 0 = Zero; view n = Succ (n - 1); fac (view -> Zero) = 1; fac (view -> Succ n) = (n + 1) * fac n } in fac 5
12:56:27 <idnar> PeakerWork: separate languages is okay, the problem is that Python 3 has very little going for it
12:56:31 <monochrom> The number hierachy is hard.
12:56:36 <skorpan> > "sup dawg " ++ (fix "we heard you like recursion so " ++)
12:56:37 <lambdabot>   Couldn't match expected type `a -> a'
12:56:44 <idnar> PeakerWork: although people trying to pretend that they're the same language are muddying the issue
12:56:45 <ehird> > "sup dawg " ++ (fix $ "we heard you like recursion so " ++)
12:56:46 <lambdabot>       The operator `++' [infixr 5] of a section
12:56:46 <lambdabot>          must have lower prec...
12:56:48 <skorpan> > "sup dawg " ++ (fix ("we heard you like recursion so " ++))
12:56:49 <lambdabot>   "sup dawg we heard you like recursion so we heard you like recursion so we ...
12:56:50 <pumpkin_> aw
12:56:50 <vixey> yeah
12:56:59 <PeakerWork> Gracenotes: It makes sense for reals and subgroups of reals, but it should be   a->some kind of Real     for other types
12:57:19 <idnar> PeakerWork: anyhow, I'm ranting out of control here now; but coming back to my original point, Haskell' wasn't supposed to be a new language
12:57:21 <PeakerWork> idnar: it has a lot of support going for it -- everyone is trying to be Python3 compatible
12:57:24 <Gracenotes> -> Num, probably :\
12:57:43 <PeakerWork> Gracenotes: abs :: (Num a, Num b) => a -> b ?
12:57:45 <Gracenotes> of course, that's a general num, you'd have to construct it from +, -, /, etc.
12:57:49 <pumpkin_> we should start a new haskell standard with fixed numerical hierarchy :P
12:57:57 <pumpkin_> Haskell''
12:58:01 <PeakerWork> Gracenotes: you need b to a specific type depending on a
12:58:05 <monochrom> One may argue that "sup dawg " ++ (fix ("we heard you like recursion so " ++)) is really corecursion.
12:58:06 <edwardk> idnar: if you only add and never remove, you wind up with c++.
12:58:07 <wli> Haskell 2
12:58:12 <Gracenotes> PeakerWork: yes.
12:58:12 <PeakerWork> Yeah, I agree: Haskel 2
12:58:20 <Gracenotes> so now Num is a multiparam typeclass :)
12:58:24 <vixey> Haskell 1.618
12:58:26 <idnar> edwardk: well, Python isn't playing in the "research language" space
12:58:27 <PeakerWork> Gracenotes: I'm fine with   Num a => a -> Double
12:58:28 <Gracenotes> all of a single method
12:58:31 <Gracenotes> the solution indeed
12:58:43 <pumpkin_> Gracenotes: just make it match standard algebraic structures a bit more
12:58:53 <vixey> idnar: type systems research with python
12:58:55 <edwardk> idnar: sure, i was talking about n+k in haskell. i think the restraint of the haskell' folks is remarkable
12:58:56 <monochrom> Haskell ME, Haskell Vista
12:58:57 <Gracenotes> PeakerWork: and for Int instance? hm...
12:59:01 <PeakerWork> Yeah, "abs" can be a member of a multi-param type-class
12:59:05 <Gracenotes> pumpkin_: it's easy to go overboard though
12:59:07 <Valodim> Haskell 2 = Brooks
12:59:09 <maltem> On what structures is abs defined, mathematically, besides Complex numbers and subsets thereof?
12:59:13 <PeakerWork> without making (+) a member of a multi-param type-class
12:59:14 <siki> How can I provide or override a default implementation of a function in a class that is a sub-class of another type class?
12:59:18 <idnar> edwardk: in the Haskell space, I think a Haskell 2 (or whatever) could work out just fine, but I didn't think that's what Haskell' was supposed to be
12:59:27 <vixey> maltem: I supposed normed vector spaces
12:59:28 <Gracenotes> maltem: arguably, matrices, if you take abs = determinant
12:59:33 <PeakerWork> maltem: vectors in vector spaces
12:59:37 <Valodim> ie, Haskell Brooks Curry :)
12:59:39 <pumpkin_> Gracenotes: the current one is woefully inadequate though
12:59:39 <idnar> edwardk: Java would probably be a better-executed example than C++, though
12:59:41 <vixey> not every vector spac
12:59:42 <vixey> not every vector space
12:59:42 <edwardk> personally most of the monomorphisation of haskell 98 appalls me, there is a lot more i'd like to see reverted
12:59:43 <fynn> "Haskell 2"? what are you guys talking about?
12:59:50 <monochrom> Haha Valodim
12:59:52 <DrSyzygyFR> What kind of equations do people expect abs to fulfill?
12:59:53 <pumpkin_> edwardk: same here
12:59:53 <vixey> fynn just making things up as we go
12:59:54 <Taejo> Gracenotes: urgh... the determinant isn't a norm
12:59:59 <PeakerWork> siki: why is it being a sub-class relevant?
13:00:00 <DrSyzygyFR> It seems like it should be good for any norms.
13:00:02 <vixey> triangle inequality
13:00:05 <edwardk> idnar: nah, the c core is a pretty good analogy to haskell 98 in the modern context ;)
13:00:05 <idnar> edwardk: C++'s evolution has been... dismal and underwhelming
13:00:07 <Gracenotes> Taejo: well, it does yield a real value
13:00:08 <kadaver> isnt esoteric: created to be weird
13:00:09 <DrSyzygyFR> Which makes the determinant kinda ucky.
13:00:13 <pumpkin_> @users
13:00:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 633 (96.2%), active: 34 (5.4%)
13:00:14 <maltem> vixey, heh, I was going to add "and not counting arbitrary vector space norms"... I'm used to write those as ||·|| instead of |·|
13:00:19 <DrSyzygyFR> Wait ...
13:00:21 <DrSyzygyFR> :t abs
13:00:22 <lambdabot> forall a. (Num a) => a -> a
13:00:26 <DrSyzygyFR> Yup.
13:00:30 <DrSyzygyFR> That's a tricky bit.
13:00:31 <idnar> edwardk: Java's evolution has impressed me a lot, despite the fact that I still don't want to write Java code if I can possibly help it
13:00:31 <bremner> Gracenotes: err, non-negativity?
13:00:36 <siki> PeakerWork: I can't seem to be able to do it. Let me give an example
13:00:37 <edwardk> abs should be from a module on a ring to a ring ;)
13:00:45 <DrSyzygyFR> Very seldom is a norm really a map from something to itself.
13:00:46 <Gracenotes> edwardk: hush! before it spreads!
13:01:04 <maltem> The absolute value really is a special kind of norm, not vice versa
13:01:05 <DrSyzygyFR> edwardk: The joys of the horribly designed numerical typeclasses!
13:01:11 <Gracenotes> this conversation is lolz incidentally
13:01:24 <Gracenotes> -.-
13:01:33 <DrSyzygyFR> Gracenotes: SRSLY. They way Num is designed makes doing real mathematics in Haskell REALLY difficult and obnoxious.
13:01:38 <siki> Let's say I have: class A a where \ foo:: Double -> Double \ foo x = 1
13:01:51 * DrSyzygyFR defined some Num instances recently that were mainly undefined....
13:02:01 <PeakerWork> siki: you're not using the "a" type variable there
13:02:04 <bremner> DrSyzygyFR: try FORTRAN
13:02:15 <DrSyzygyFR> bremner: Yeah, because THAT's what I need.
13:02:15 <siki> and then  class (A a) => B a where \ foo x = 2
13:02:16 <bos> @seen dons
13:02:16 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 1h 29m 24s ago.
13:02:18 <PeakerWork> siki: you mean: class A a where foo :: a -> a \ foo x = x ?
13:02:28 <bos> Where can I find a PDF or similar copy of the current Haskell logo?
13:02:29 <siki> yes
13:02:31 <siki> sorry
13:02:36 <PeakerWork> siki: ah, override super-class default implementations.. I am not sure if that's possible
13:02:37 <bremner> DrSyzygyFR: well, you  might hate Haskell less
13:02:39 <monochrom> FORTRAN is real unless declared integer.
13:02:42 <Gracenotes> not to mention, the Num typeclasses don't have too many useful auxiliary methods. Generally when you write a Num-polymorphic method you have a specific type in mind
13:02:44 <bos> A Google search just gives me the contest page, with its million entries.
13:02:46 <dons> bos: yo
13:02:56 <dons> oh the svg?
13:02:58 <DrSyzygyFR> bremner: You seem to assume I hate haskell, instead of being a fierce advocate slightly annoyed with some quirks.
13:03:00 <siki> PeakerWork: yes that's what I want
13:03:00 <dons> i've got one you can use.
13:03:04 <bos> dons: SVG, PDF, anything at all :-)
13:03:24 <bremner> DrSyzygyFR: nah, just adding white noise to the channel
13:03:33 <bos> dons: it would be nice to have a canonical page on the wiki with pointers to various version
13:03:36 <dons> yes.
13:03:42 <dons> there is one
13:03:46 <dons> but doesn't have the final .svg yet
13:03:47 <PeakerWork> siki: maybe you really want function records instead of classes?
13:03:49 <bos> hmm, google reveals it not
13:03:51 <dons> i've a version though. gimme a sec
13:04:06 <Valodim> huh? it's on the contest page isn't it?
13:04:09 <eu-prleu-peupeu> hey dons, its been a long time :)
13:04:12 <Valodim> http://haskell.org/haskellwiki/ThompsonWheelerLogo <- that one?
13:04:35 <PeakerWork> siki: data A a = A { f :: a -> a }   ;   b :: A a ; b = A {f = id}
13:04:56 <bos> dons: ta much
13:05:49 <dons> http://www.galois.com/~dons/images/haskell-logo.svg
13:06:08 <PeakerWork> http://egged.co.il/images/logo.jpg
13:06:28 <kadaver_> is it complicated to use DLLs?
13:07:02 <siki> PeakerWork: well I have a bunch of instances of "class A" that I want to behave a certain way and then some more that I want behaving in some other way but all instances should have the same function so from the outside the look the same.
13:07:09 <siki> I'm not sure if that made sense
13:07:25 <kadaver_> to use a C Dll ? do I use the FFI as normal?
13:07:25 <kadaver_> http://www.haskell.org/ghc/docs/6.4/html/users_guide/win32-dlls.html
13:07:25 <kadaver_> isnt very clear
13:07:33 <dons> to use a C DLL is easy
13:07:37 <PeakerWork> siki: the question is whether it really has to be a type-class? Why not a record of functions?
13:07:53 <dons> where's haskell.org gone ?
13:08:24 <siki> I'm not sure what record functions are....let me look them up. I'm quite new to Haskell.
13:08:55 <PeakerWork> siki: a record is basically like a tuple except the stuff in it have not only positions but also names
13:09:07 <PeakerWork> siki: a record of functions is like a tuple that contains functions
13:09:15 <PeakerWork> siki: except the functions inside have names
13:09:20 <PeakerWork> siki: so its somewhat similar to a type-class
13:10:26 <PeakerWork> siki: with records of functions you get more control about the exact behavior -- and it doesn't have to be determined by the type - you can choose whatever "instance"/implementation you want - and you can do stuff like combining existing records of functions in various ways
13:10:41 <maltem> Why does the logo on haskell.org have a slimmer and colder look than what people voted for?
13:10:43 <kadaver_> dons ok but where does it say how to?
13:11:16 <PeakerWork> maltem: as Stalin said -- the voters don't have the power, those that count the votes do :)
13:11:41 <skorpan> how do i make an EOF in ghci?  e.g. when reading from stdin
13:11:50 <maltem> PeakerWork, so much for the power. What about the motivation?
13:12:30 <monochrom> Don't "make" an EOF. Detect it. You get an exception when you read with getLine or getChar.
13:13:08 <siki> PeakerWork: I'm trying to digest what you wrote. Basically, I want all instances to have a certain common behavior (function) but I want to be able to group them and give different default implementations of that function to each group.
13:13:20 <c_wraith> skorpan: do you mean to quit ghci?  ctrl-d on unix, ctrl-z on windows
13:13:24 <wli> PeakerWork: It was intended as a critique of e.g. the US. But all the more reason to grind out a CPO-STV module.
13:13:33 <skorpan> i don't want to quit ghci, i have a program which reads from stdin
13:13:43 <kadaver_> I want to use mpg123's dll to play mp3s but I can't find info on how to use DLL's
13:14:03 <seliopou> skorpan, you can't ctrl+c
13:14:05 <c_wraith> skorpan: once you close stdin, it stays closed...  Meaning ghci isn't going to do much, either.
13:14:09 <Zao> kadaver_: Grab a suitable header, foreign import, link against its import lib?
13:14:09 <seliopou> can, rather
13:14:25 <skorpan> seliopou: then it segfaults :|
13:14:38 <seliopou> o_O
13:14:43 <seliopou> that's 100% intense
13:14:50 <c_wraith> skorpan: You're using 6.10.2?
13:14:58 <skorpan> yes c_wraith
13:15:03 <c_wraith> Use 6.10.1
13:15:06 <c_wraith> It's less broken
13:15:06 <seliopou> You don't get "Interrupted."?
13:15:09 <seliopou> and then a prompt?
13:15:12 <skorpan> seliopou: no, it segfaults
13:15:20 <c_wraith> seliopou: 6.10.2 dies on ctrl-c
13:15:25 <skorpan> so you're telling me to use 6.10.1?  i thought 6.10.2 *fixed* bugs?
13:15:27 <monochrom> main = do { main' `catch (\ _ -> return ()) ; putStrLn "The End" };  main' = do { getLine >>= putStrLn; main' }
13:15:48 <c_wraith> From what I've seen, 6.10.2 only added bugs
13:15:59 * seliopou pets ghc 6.8.2
13:16:08 <ehird> Is there a way to make cabal use the git revision number as a version?
13:16:16 <skorpan> seliopou: let x = x in x ;P
13:16:23 <BONUS> 6.8.2 has a nasty scoping bug
13:16:43 <dcoutts> ehird: you'd need a bit of scripting
13:16:56 <ehird> dcoutts: how much? :-)
13:17:09 <dcoutts> ehird: sorry, not sure. I've not done it.
13:17:32 <hgolden> Hi. I tried to compile buddha-1.2.1 under ghc-6.10.2. It failed due to old references (lang package). Has anyone patched it? Does anyone use it? Thanks.
13:17:38 <ehird> If I only have one description should it be description or synopsis in .cabal?
13:17:56 <dcoutts> ehird: ideally you should use both. hackage displays both.
13:18:23 <ehird> dcoutts: So have them identical?
13:18:25 <dcoutts> ehird: a one line summary for the synopsis and a bit more (not repeating) for the description
13:18:35 <ehird> But I only have one thing to say :-)
13:18:37 <dcoutts> ehird: no, the description is in addition
13:18:50 <ehird> Right... but I have nothing to say.
13:18:54 <ehird> More than the synopsis.
13:19:02 <Saizan> "Duh"
13:19:09 <ehird> :-)
13:19:28 <dcoutts> ehird: then leave the description blank
13:19:44 <kadaver_> Zao: how do I link? and with lib you meant he dll?
13:21:46 <Zao> kadaver_: On windows, you don't link against DLLs directly.
13:22:03 <siki> Anyone else has any recomendation in how a sub-class can override its super-class' default implementation of a function?
13:22:12 <Zao> kadaver_: You link against an import library which which has stubs that call into the DLL.
13:22:20 <siki> if it can be done at all....
13:22:30 <Zao> You should have a header with the function signatures, an import library to link to and a DLL to run with.
13:22:56 <Zao> Some toolchains (probably mingw) can synthesise a decent import library from a DLL, provided you only want exported functions.
13:23:24 <ehird> Warning: 'license: MIT' is not a recognised license.         # :\
13:25:57 <kadaver_> exe's are never for linking?
13:26:43 <kadaver_> i have some dlls, a .h but not .lib
13:26:55 <p_l> kadaver_: You can open a dll manually
13:27:51 <p_l> link libraries are there to ease that part of the process (I guess it might have something to do with windows not using position-independent binaries except for some stuff on 6.1)
13:31:03 <Zao> You have LoadLibrary + GetProcAddress much like you have dlopen + dlsym on posixy boxen.
13:31:37 <Zao> ehird: That annoys me to no end.
13:32:49 <edwardk> ehird: there is a bsd-like entry you can use iirc
13:36:00 <kadaver> is the .def file the import lib?
13:38:48 <dons> it is kind of "industrial haskell" sort of day. 3 nice articles on commercial users
13:39:24 <kadaver> im to sexy for my body
13:39:30 <kadaver> where?
13:39:55 <p_l> kadaver: .def is used as input for import lib gen.
13:40:17 <p_l> kadaver: import libs usually end up as *.lib just like static ones
13:47:21 <dons> wow hackathon video: http://tom.lokhorst.eu/hac5/
13:47:40 <dons> with a soundtrack. fun fun
13:49:12 <kadaver> well there is no .lib
13:50:32 <p_l> heh, everyone with laptops. Where are the times you had to lug a desktop computer to a con? ^^;
13:50:40 * edwardk returns to bashing esolangs, not that oklopok is here ;)
13:50:44 <edwardk> er now that
13:51:23 <oklopok> i was here the whole time!
13:51:26 <kadaver> dons:did you use mpg123?
13:51:40 <edwardk> oklopok: yes, just in a form i didn't recognize ;)
13:51:41 <dons> in the past, yes.
13:52:09 <oklopok> i've done little work on esolangs recently, due to university bus..iness, so i'm fine with that.
13:52:15 <p_l> um, one of the guys looked familiar... except as far as I know I'm the only one in abdn-compsci society that used haskell...
13:52:30 <edwardk> ah, here i was eagerly awaiting some form of okloskell ;)
13:52:47 <oklopok> i don't mind things i don't waste my time on being stupid
13:52:53 <oklopok> what's okloskell?
13:53:00 <kadaver> brainskell
13:53:02 <oklopok> oh this is #haskell
13:53:05 <oklopok> right!
13:53:08 <edwardk> =)
13:53:24 <oklopok> well i was just looking at my old esolangs and thinking god i used to be smart
13:53:59 <Cale> which ones?
13:54:08 <oklopok> ef and graphica.
13:54:14 <oklopok> i'm sure you know them.
13:56:12 <Cale> Somehow the names seem familiar, but I can't find them :)
13:56:45 <oklopok> all that's online is a few examples
13:56:55 <oklopok> and ef doesn't have anything else in existance.
13:57:16 <Cale> Maybe you wrote some blog posts about them?
13:57:17 <oklopok> i mostly do vaporware, since i don't have the patience for programming or making specs.
13:57:29 <oklopok> Cale: well i don't have a blog per se.
13:57:57 <Cale> I just vaguely recall something linked from the programming reddit at some point
13:58:14 <oklopok> 8|
13:58:14 <vixey> http://www.esolangs.org/wiki/Ef
13:58:16 <oklopok> well that wasn't me :P
13:58:22 <vixey> http://www.esolangs.org/wiki/Graphica
13:58:26 <vixey> this is not working
13:58:30 <oklopok> hmm
13:58:45 <oklopok> well i don't exactly use wikis
13:58:48 <pumpkin_> hmm, Pointed is something you can stick something into?
13:58:50 <oklopok> scary.
13:59:11 <Cale> pumpkin_: something with an equivalent of 'return'
13:59:17 <pumpkin_> I see
13:59:31 <oklopok> but i wonder why the pages exist
13:59:36 <vixey> they don't
13:59:40 <oklopok> oh, right
13:59:40 <pumpkin_> so every Pointed is a functor, but not vice versa?
13:59:45 <Cale> right
14:00:20 <oklopok> didn't know that's the way to say page not exists.
14:00:36 <Cale> pumpkin_: The term comes by way of analogy with Set, where a function 1 -> A can stand in as a version of A with a special point identified
14:00:38 <pumpkin_> the latest email on -cafe seems to say that backwards though
14:00:45 <pumpkin_> "They are in order of power: every monad is an applicative; every applicative is a functor; every functor is pointed."
14:01:03 <pumpkin_> from the "Converting IO [XmlTree] to [XmlTree]" thread
14:01:11 <Cale> pumpkin_: So if you consider a natural transformation 1 -> T where T is some functor, that's rendered in Haskell as a polymorphic function: a -> T a
14:01:27 <pumpkin_> but ((->) a) is a functor and not pointed
14:01:31 <pumpkin_> ok
14:01:35 <Cale> Not every functor is pointed
14:01:40 <pumpkin_> ok :)
14:01:45 <pumpkin_> just making sure
14:02:41 <pumpkin_> outside of category-extras
14:02:50 <pumpkin_> what is this called? a Pointed functor?
14:03:00 <Saizan> ((->) a) is pointed.. unless you mean (Flip (->) a)
14:03:38 <Cale> Yeah, a pointed functor.
14:03:42 <edwardk> pumkin: ((->)a)  is pointed, its a monad =)
14:03:52 <pumpkin_> oh, true, hmm
14:03:58 <Cale> Most functors have more than one way of being pointed though.
14:04:03 <edwardk> but you are right that not every functor is pointed
14:04:09 <Cale> So it's not appropriate to call a functor pointed without picking one.
14:04:21 <Cale> and yeah, there are of course some which are not
14:06:14 <edwardk> pointed is just a way of saying there is a family of coalgebras that has a member for every object in the source category of the functor that you want to somehow point out as somehow canonical
14:06:36 <Deewiant> Yes, just that
14:06:46 <pumpkin_> edwardk: duh ;)
14:06:55 <pumpkin_> but yeah, I mostly understood that, which is encouraging
14:07:12 <edwardk> Deewiant: i should have capstoned that with the standard mathematician way of avoiding responses: "obviously" ;)
14:07:23 <Deewiant> :-)
14:07:54 <pumpkin_> edwardk: you gonna write a knol on dogamorphisms too?
14:08:21 <edwardk> pumpkin: i went home to do so, but my dogamorphism ate my homework.
14:08:33 <pumpkin_> onoes
14:08:48 <edwardk> catamorphic failure
14:09:03 <pumpkin_> epimorphic failure?
14:09:28 <pumpkin_> I guess I should drop the -ure
14:09:30 <edwardk> clearly there are several kinds of failure involved, so polymorphic failure.
14:14:15 <a_guest> I have a question regarding left and right folds. When folding over infinite lists, should my choice be left fold? Since a right fold needs to go infinite deep to reach [] which it starts from?
14:14:32 <Deewiant> > foldr f z [1..]
14:14:38 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f 14 (...
14:14:42 <Deewiant> > foldl f z [1..]
14:14:44 <edwardk> a_guest: in a strict language, yes, in a lazy language with a non-strict function you probably want foldr
14:14:49 <glguy> a_guest, only right folds make sense on an infinite list
14:15:04 <glguy> as they can produce a value before seeing the end of the list
14:16:30 <glguy> a_guest, the right fold doesn't actually start at the right end of the list
14:16:59 <skorpan> :t fmap
14:17:01 <idnar> @ping
14:17:01 <lambdabot> pong
14:17:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:17:07 <glguy> foldr f z (a:b)  -> f a (foldr f z b)
14:17:13 <ski> > foldr (const ()) undefined [0..]
14:17:16 <lambdabot>   Couldn't match expected type `b -> b' against inferred type `()'
14:17:16 <glguy> if f a _ can produce a value without inspecting the _
14:17:35 * kadaver commits hatakari
14:17:38 <glguy> then you'll see a value before you hit the end
14:17:59 <ski> > foldr (\_ _ -> ()) undefined [0..]
14:18:01 <lambdabot>   ()
14:18:16 <ski> > foldr (\x _ -> x) undefined [0..]
14:18:17 <lambdabot>   0
14:18:21 <c_wraith> I just *finally* managed to wrap my head around fix.  I'm not used to thinking like this.
14:18:28 <ski> > foldr (\x xs -> x:xs) undefined [0..]
14:18:29 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:18:49 <skorpan> :t sequence_
14:18:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:22:40 <ryanakca> Could someone help me with se noai
14:22:40 <ryanakca> ahttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=4264#a4264:se ai
14:23:10 <a_guest> So the prime building case of lists ([]) are not required for infinite lists?
14:23:47 <oklopok> > foldr (\x xs -> x:xs) 0 [0..]
14:23:49 <lambdabot>       No instance for (Num [a])
14:23:49 <lambdabot>        arising from the literal `0' at <inter...
14:23:51 <ryanakca> Ooops, *kicks screen*, could someone help me with ^^ please, question and code included, from RWH. I'm not sure what I'm doing wrong... it works in my head, just not in code :/
14:24:00 <oklopok> isn't it because undefined can be of type list too
14:24:35 <glguy> ryanakca, you can't ++ the head of a list into its tail
14:24:36 <a_guest> ((a : b) : c) : ... legal, but (a : b) : c not legal?
14:25:25 <oklopok> a_guest a:b is a list, and : takes a "value" as its left argument
14:25:26 <kadaver> > fix f (-1) in f
14:25:27 <lambdabot>   <no location info>: parse error on input `in'
14:26:28 <kadaver> @src fix
14:26:29 <lambdabot> fix f = let x = f x in x
14:26:36 <ryanakca> glguy: Ah, thanks, figured it out
14:26:47 <Gracenotes> :t fix ?f (-1) -- :<
14:26:48 <lambdabot> forall a t. (Num a, ?f::(a -> t) -> a -> t) => t
14:27:29 <kadaver> @type fix
14:27:30 <lambdabot> forall a. (a -> a) -> a
14:27:38 <a_guest> oklopok: if a, b are elements: the finite expression a : b is not valid.
14:27:54 <ErhardtMundt> hello
14:28:30 <oklopok> a_guest: that too
14:29:16 <a_guest> oklopok: but a infinite construction definition is legal?
14:30:32 <oklopok> a_guest: a finite one would be too, as long as the undefined isn't actually evaluated
14:30:50 <oklopok> > head (1 : 2 : 3 : undefined)
14:30:51 <lambdabot>   1
14:30:54 <oklopok> wow
14:30:55 <oklopok> that worked.
14:31:21 <a_guest> My first thought was that infinite lists should be defined from left, since a right definition would go infinite deep to reach the []
14:32:17 <oklopok> a_guest: basically the thing that creates the list is just an unevaluated trunk, when you need its head, you just evaluate it a bit until you get it, and the definition gives you the head after one step into the recursion
14:32:24 <oklopok> i'm not good at explaining.
14:32:26 <a_guest> ...Hence construct infinite lists with (++).
14:32:49 <oklopok> ah
14:32:54 <oklopok> i actually missed some context
14:34:23 <oklopok> and now i'm not sure what you're asking, but you've been given lots of answers, and i don't actually know all that much
14:34:28 <a_guest> oklopok: I thought that a list nescesscarly needed to be buildt from the prime case [].
14:34:34 <oklopok> a_guest: it is.
14:34:59 <oklopok> thing is you don't need to have the end of the list evaluated before you start using it
14:35:29 <oklopok> kinda like you can do (head [1..]) even though [] hasn't been reached yet
14:35:30 <koninkje> a_guest: lists only need to be build from [] if the (:) constructor is strict in its recursion, which is not the case in Haskell
14:36:45 <oklopok> > take 10 ((flip (:)) [1..])
14:36:47 <lambdabot>   Couldn't match expected type `[a]'
14:36:48 <oklopok> err
14:36:57 <oklopok> > take 10 (folrl (flip (:)) 0 [1..])
14:36:58 <lambdabot>   Not in scope: `folrl'
14:37:00 <oklopok> ...
14:37:05 <oklopok> > take 10 (foldl (flip (:)) 0 [1..])
14:37:06 <lambdabot>       No instance for (Num [b])
14:37:06 <lambdabot>        arising from the literal `0' at <inter...
14:37:12 <oklopok> i really should try this stuff in priv :P
14:37:20 <oklopok> > take 10 (foldl (flip (:)) [] [1..])
14:37:32 <koninkje> > take 10 . foldl (flip(:)) 0 $ [1..]
14:37:40 <lambdabot>   mueval: Prelude.read: no parse
14:37:42 <lambdabot>       No instance for (Num [b])
14:37:43 <lambdabot>        arising from the literal `0' at <inter...
14:37:53 <oklopok> koninkje: i'm trying to get foldl to make sense, probably doesn't make much sense
14:38:18 <koninkje> foldl is just like foldr except the arguments to the first function are swapped
14:38:33 <koninkje> (strictness and implementation details aside)
14:38:52 <Saizan> > foldl f z [1..3]
14:38:54 <lambdabot>   f (f (f z 1) 2) 3
14:38:58 <Saizan> > foldr f z [1..3]
14:38:59 <lambdabot>   f 1 (f 2 (f 3 z))
14:39:38 <a_guest> www.foldr.com
14:41:18 <mikm> I laughed, a_guest
14:41:43 <Saizan> www.foldl.com
14:41:55 <koninkje> http://en.wikipedia.org/wiki/File:Fold-diagrams.svg
14:43:04 <koninkje> if only http://cale.yi.org/index.php/Fold_Diagrams weren't down
14:43:14 <Cale> koninkje: oh...
14:43:16 <Cale> it's down?
14:43:26 <mikm> It's up for me
14:43:32 <koninkje> "can't find server" I'm told...
14:43:42 <Cale> koninkje: Maybe a bad dns cache
14:43:56 <koninkje> http://downforeveryoneorjustme.com tells me it's just me :(
14:44:20 <oklopok> it always does
14:44:20 <Cale> 99.247.248.73
14:44:28 <koninkje> working now
14:48:18 <a_guest> thank you for answers.
14:51:38 <equaeghe> how do I uninstall packages installed using cabal?
14:52:07 <dcoutts> equaeghe: you can unregister them with ghc-pkg, if you need the disk space you can remove the files with rm
15:01:57 <Cale> It would be nice if at some point cabal got an uninstall feature :]
15:02:07 <dcoutts> wouldn't it
15:02:19 * dcoutts invites volunteers
15:02:42 <dcoutts> the approach is just to install into a temp dir, record the list of files and stash it somewhere
15:02:53 <dcoutts> can all be done in cabal-install without any changes to the Cabal lib
15:06:14 <dons> quite easy, really
15:06:20 <dons> its a bit like fake install support, though
15:07:01 <kadaver> dman engineering is friggin easy after doing software
15:07:23 <Philippa_> engineers have better libraries ;-)
15:09:42 <lament> bigger, certainly
15:11:46 <Botje> .oO(checkinstall runhaskell Setup.lhs install)
15:19:33 <zoheb> Is anyone using ghci as a command shell?
15:19:57 <zoheb> I looked up Haskell Shell on google but saw nothing exciting
15:21:45 <Gracenotes> hshell? :)
15:22:03 <Gracenotes> hsh. gsh.
15:22:14 <bremner> s/hs//
15:22:30 <zoheb> I saw a Jun 2006 blog entry for it
15:23:14 <Gracenotes> Haskell would make a nice shell. monad/pipe analogies and the like
15:23:31 <zoheb> I did rather roll my own shell
15:23:36 <kadaver> i use ghci as a calculator, faster to fire up than windows calc or python
15:23:57 <zoheb> there doesn't seem to be much that the shells seem to do
15:24:20 <zoheb> It would be great if any of the shells had readline support
15:24:35 <zoheb> hshell doesn't seem to have it
15:24:38 <Gracenotes> argh. time to pkill firefox again >:[
15:25:05 <zoheb> also, has anyone tried installing the haskell readline library on windows?
15:25:18 <zoheb> It isn't in the default install?
15:25:36 <zoheb> some of the instructions are back from 2004
15:27:47 <zoheb> yet another question, Is there anyway to read a an arbitrary string and "compile" it into an arbitrary expression
15:27:59 <zoheb> arbit haskell expr
15:28:03 <zoheb> the way ghci works
15:28:06 <kadaver> firefox is really friggin memoryheavy
15:28:12 <kadaver> and crashes often lately
15:28:17 <kadaver> time for aa rewrite
15:28:18 <Axman6> yup
15:28:19 <kadaver> in haskell!
15:28:26 <zoheb> To put it another way, how would I write my own ghci
15:28:30 <Gracenotes> my firefox doesn't usually have the courtesy to crash, it just freezes
15:28:47 <Axman6> zoheb: interact
15:28:48 <Gracenotes> and then the pkilling begins! *eyes gleam*
15:28:55 <Axman6> :t interact
15:28:56 <lambdabot> (String -> String) -> IO ()
15:29:42 <zoheb> what I want to know is the eqvt of readS
15:30:01 <zoheb> for an arbitrary haskell expression
15:30:03 <mauke> zoheb: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval
15:30:37 <zoheb> that looks right
15:30:49 <zoheb> interact isn't good enogh
15:31:08 <Axman6> it's a start
15:31:23 <Axman6> but yes, mueval is what you want
15:31:26 <zoheb> does ghci use mueval
15:31:30 <Gracenotes> mauke: hm, using process? *eyes suspiciously*
15:31:45 <Gracenotes> ghci uses an evaluator with GHC primitives
15:32:44 <zoheb> Gracenotes, Is it part of a library somewhere?
15:32:58 <Gracenotes> the GHC source, in the compiler directory
15:33:06 <zoheb> ouch
15:33:24 <Lemmih> zoheb: There's a 'ghc' library but it isn't that easy to use.
15:33:33 <Gracenotes> http://darcs.haskell.org/ghc/compiler/ghci/
15:33:37 <zoheb> I guessed as much :-|
15:33:39 <Gracenotes> ghci itself
15:34:02 <zoheb> But the ghci prompt does not have readline like fnctionality
15:34:11 <Gracenotes> particularly see GhciMonad, InteractiveUI and GhciTags
15:34:16 <zoheb> like Ctrl-R to reverse look up command history
15:34:23 <Axman6> zoheb: it doesn't? o.O
15:34:48 <jeffwheeler> Is there a way to include a package when using runhaskell or similar? It seems like it should be -p name, or similar, but this doesn't seem to do anything.
15:34:52 <kadaver> getInfoOnMp3PlayingInHaskell >>= passInfoToKadaver
15:34:57 <mauke> zoheb: it does here
15:35:07 <zoheb> I am on windows
15:35:16 <zoheb> ctrl-r doesnt seem to work
15:35:50 <jeffwheeler> Oh, -package seems to work. How silly of me.
15:35:57 <zoheb> does it work on Unix?
15:36:44 <Saizan> zoheb: are you on 6.10?
15:36:49 <zoheb> yes
15:37:01 <Saizan> zoheb: try installing ghci-haskeline from hackage then
15:37:20 <Saizan> and using that
15:37:20 <zoheb> ok
15:39:39 <Baughn> kadaver: checkHackageForPackages >>= return
15:50:55 <kadaver> let onReturn (Person k) = "help" ++ "kadaver" in onReturn (Person "kadaver")
15:51:14 <kadaver> > let onReturn (Person k) = "help" ++ k in onReturn (Person "kadaver")
15:51:15 <lambdabot>   Not in scope: data constructor `Person'Not in scope: data constructor `Pers...
15:51:28 <kadaver> > let onReturn k = "help" ++ k in onReturn "kadaver"
15:51:29 <lambdabot>   "helpkadaver"
15:51:39 <zoheb> has anyone use cabal on windows? I think I am running into some firewall shit
15:52:14 <zoheb> C:\Windows\system32>cabal update Downloading the latest package list from hackage.haskell.org cabal: getHostByName: does not exist (no such host entry)
15:54:46 <ehird> Why do Map functions take the map last? It's quite irritating
15:55:24 <Axman6> thing `f` map?
15:55:28 <kadaver> hmm dont know sorry, mine just works
15:55:45 <glguy> ehird, usually what you want in the end is a function Map _ _ -> Map _ _
15:55:54 <glguy> so it is helpful to have the map parameter last
15:56:00 <ehird> I suppose.
15:56:06 <glguy> then you can write things like: modify (Map.insert a b)
15:59:39 <adamvo> @type flip  -- this isn't too irritating, ehird, is it?
15:59:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:59:48 <ehird> adamvo: insert :: Ord k => k -> a -> Map k a -> Map k a	
15:59:56 <ehird> it's not as simple as just a single flip
16:00:07 * Axman6 dislikes haveing to use flip
16:00:17 <ehird> Axman6: yeah, it's like using stack shuffling words
16:00:22 <ehird> in concatenative langs
16:00:54 <Axman6> i'm not really a big fan of pointfree style anyway
16:00:58 <adamvo> @type flip $ uncurry Data.Map.insert
16:00:59 <lambdabot> forall a b. (Ord a) => M.Map a b -> (a, b) -> M.Map a b
16:01:09 <ehird> curry . flip . uncurry?
16:01:09 <ehird> SRS?
16:02:24 <ehird> also, are nested "where"s bad style? ;)
16:02:35 <ski> no
16:05:43 <Cale> Well, they *might* be suboptimal, but sometimes they're totally appropriate.
16:06:12 <zoheb> Can someone do me a favor and try this ---------->    ping hackage.haskell.org
16:06:30 <zoheb> I cant ping this from my place
16:06:35 <mauke> 2 packets transmitted, 0 received, 100% packet loss, time 999ms
16:06:47 <ehird> ditto
16:06:51 <Cale> I can't ping, but I can get to the website.
16:06:51 <ehird> looks like monk is down
16:06:55 <jeffwheeler> Yep
16:06:59 <ehird> ah
16:06:59 <ehird> ditto
16:07:04 <ehird> monk's blocking pings, rather.
16:07:08 <zoheb> no wonder my cabal isn't updating
16:07:19 <ehird> i don't see why not
16:07:31 * Cale tries a cabal update
16:07:39 <jeffwheeler> Works for me.
16:07:42 <Cale> Seems to work, yeah
16:07:44 <zoheb> actually even my host name isn't getting resolved
16:08:04 <Cale> 69.30.63.197
16:08:06 <zoheb> I think its the firewall at my place
16:11:31 <zoheb> f this - this is some kind of workplace firewall
16:11:56 <zoheb> Is cabal useful without an internet connection?
16:12:03 <Cale> zoheb: somewhat
16:12:10 <Zao> You can always use it to build packages you already have source for.
16:12:12 <Cale> zoheb: You can use it to build packages easily
16:12:18 <Zao> It can probably unpack cached packages too.
16:12:33 <coolsner> cabal is not only a package manager, it's a build system too
16:12:33 <zoheb> download the package and cabal install from there?
16:12:40 <Cale> Issuing cabal <command>  without a package name from inside the top-level source directory of a package will work.
16:12:47 <Cale> yeah
16:13:00 <zoheb> what about updates?
16:13:12 <Cale> Well, you'd have to download them and install them by hand like that
16:13:38 <zoheb> ok
16:13:58 <Cale> Oh, updating the hackage database is unnecessary
16:14:10 <Cale> Since you'll only be installing the packages manually anyway
16:14:21 <zoheb> hmm
16:14:26 <Cale> And I don't usually recommend cabal upgrade anyway
16:15:22 <Cale> (it can inadvertently install versions of things where the version that comes with your copy of ghc would usually be better)
16:15:39 <Cale> (and then you end up with dependency hell)
16:18:24 <glguy> Didn't GHC get a new foreignptr in 6.10.2 or so?
16:18:30 <glguy> one that runs its finalizers
16:18:52 <pumpkin_> yeah
16:19:00 <glguy> what module was that added to?
16:19:01 <pumpkin_> well, the behavior definitely changed, I can't remember the specifics
16:19:09 <pumpkin_> they changed the existing one
16:19:18 <dons> there's a discussion about it on the list at the moment
16:19:35 <glguy> which list
16:20:02 <dons> glasgow-haskell-users@ i think
16:21:45 <glguy> a search on nabble shows no posts about foreignptr in the last month
16:21:48 <glguy> do you know the title?
16:21:49 <Saizan> re cabal with no connection: you can run cabal fetch foo when you're connected, and then cabal install foo later
16:21:59 <zoheb> Noob question -  I am looking at cabal docs, it seems you just cd into the dir and run setup.hs, so I dont really need cabal to perform a cabal install?
16:26:45 <Saizan> zoheb: you can runghc Setup configure; runghc Setup build; runghc Setup install instead of "cabal install"
16:26:51 <adamvo> is anybody here who can help me with my code.haskell.org / community.haskell.org account? It is supposed to be enabled today, but when I try to ssh in, I am asked for a password (and not my RSA private key)
16:27:09 <Saizan> zoheb: but that's becoming more and more an UI for scripts rather than for humans
16:27:11 <zoheb> yes, thats what the documentation said
16:28:22 <yav> kkjjkkj
16:28:31 <yav> (sorry, this was for vim)
16:31:09 <Igloo> adamvo: What username?
16:31:24 <adamvo> Igloo: aavogt
16:32:30 <zoheb> http://mibbit.com/pb/8A2Rh3
16:32:47 <zoheb> I suspect this isn't going to go too well
16:33:19 <Saizan> zoheb: well, you need to install those packages first
16:33:31 <zoheb> Yes
16:33:54 <zoheb> does it do automatic recursive updates
16:34:10 <Saizan> yes, if you run "cabal update" to download the index first
16:34:53 <Igloo> adamvo: Can you paste the end of your SSH public key please?
16:37:21 <Igloo> adamvo: Or actually, just send the key to support@community.h.o. The one we have seems to be corrupt
16:38:38 <amckinley> hey, newbie parsec/haskell question: im parsing a list with two different types of elements, and i need to invoke a different parser depending on the type of element
16:39:06 <adamvo> Igloo: thanks, I'll mail the public key then
16:39:21 <amckinley> what do i need to do to group all the elements of one type in one list, and all the elements of the other type in a different list?
16:40:34 <ski> @hoogle [Either a b] -> ([a],[b])
16:40:34 <lambdabot> No results found
16:41:00 <copumpkin> wasn't that partitionEithers ?
16:41:06 <copumpkin> or something along those lines
16:41:16 <ski> possibly .. istr seeing it on mailing list at some point
16:41:24 <copumpkin> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html#v:partitionEithers
16:41:28 <copumpkin> new in 6.10 I guess?
16:41:43 <copumpkin> there's also lefts and rights that do what you'd expect
16:42:01 <yav> but no mapEither?  we should add that
16:42:15 <amckinley> ski: i was thinking about using Either, but i thought Either was exclusively for a "good" Right case and a "failure
16:42:17 <vixey> what's mapEither??
16:42:20 <amckinley> " Left case
16:42:29 <copumpkin> amckinley: I hope not
16:42:43 <yav> mapEither :: (a -> Either b c) -> [a] -> ([b],[c])
16:42:50 <copumpkin> :t map . either
16:42:51 <dons> :t partition
16:42:51 <lambdabot> forall a c b. (a -> c) -> [b -> c] -> [Either a b -> c]
16:42:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
16:42:54 <yav> it is like mapMaybe
16:42:59 <vixey> why would you do that
16:43:03 <ski>   mapEither :: (a0 -> a1) -> (b0 -> b1) -> (Either a0 b0 -> Either a1 b1)  -- ?
16:43:04 <copumpkin> ah
16:43:05 <dons> :t mapMaybe
16:43:06 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
16:43:10 <amckinley> copumpkin: good deal :) im going through RWH; thats what it seemed to imply
16:43:13 <ski>   mapEither :: (b0 -> b1) -> (Either a b0 -> Either a b1)  -- ?
16:43:24 <copumpkin> mapNeither!
16:43:27 <dons> mmm
16:43:28 <yav> :)
16:43:28 <copumpkin> we need a function called that
16:43:55 <yav> mapNeither :: (a -> b) -> [Either x y] -> [Either x y]
16:43:58 <dons> ?let can't = False
16:44:00 <lambdabot>  Defined.
16:44:03 <ski> amckinley : that's the `Either e' monad, yes
16:44:05 <kadaver> who talked about cabal on widnows before?
16:44:10 <kadaver> i get the same error now
16:44:20 <kadaver> $ cabal update
16:44:20 <kadaver> Downloading the latest package list from hackage.haskell.org
16:44:20 <kadaver> cabal.exe: getHostByName: does not exist (no such host entry)
16:44:22 <ski> one could consider a different `Either e' applicative, though ..
16:44:53 <ski> @type mapMaybe
16:44:54 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
16:45:52 <ski>   instance Monoid e => Applicative (Either e)
16:45:54 <ski>     where
16:46:05 <ski>     pure a = Right a
16:46:24 <ski>     Left e0 <*> Left e = Left (e0 `mappend` e)
16:46:40 <ski>     Left e0 <*> _      = Left e0
16:46:51 <ski>     _       <*> Left e = Left e
16:47:05 <ski>     Right f <*> Right a = Right (f a)
16:47:37 <ski> you can use this for accumulating all the "reachable exceptions", e.g.
16:48:54 <Igloo> adamvo: Does it work now?
16:49:41 <amckinley> and so my type should be something like "statement :: Parser (Either Declaration Parameter)"?
16:49:48 <ski> yav : hm .. how would the corresponding map for lists look like ?
16:49:57 <amckinley> (where declaration and parameter are the two different types)
16:50:04 <ski> amckinley : possibly, yes
16:50:33 <yav> ski: which map?
16:50:43 <codebliss> isLoved = (<3)
16:50:52 <yav> ski: oh i see
16:50:59 <amckinley> ski: is there a different way you'd suggest doing it?
16:51:05 <yav> haven't thought about it, let me see
16:51:19 <ski>   mapList :: (a -> [] b) -> ([a] -> [] [a])  -- i suppose
16:51:46 <yav> ski: perhaps.  it makes more sense for simple "sum" types
16:51:55 <copumpkin> type Algebra f a = f a -> a
16:52:07 <yav> the idea is that you map, and then group the results according to their tags
16:52:07 <ski> (/me wonders whether there should possibly be a `transpose' or `sequence' in there ..)
16:52:10 <copumpkin> hmm
16:52:47 <ski> amckinley : it depends on what you want, i suppose
16:53:08 <ski> i don't really see why a "statement" should be either a "declaration" or a "parameter", myself
16:53:19 <adamvo> Igloo: it works, thanks
16:53:37 <ski> (erm s/[] [a]/[] [b]/ ..)
16:53:48 <amckinley> ski: if you have some time to get into it and help me, i can give you a little more context and you can tell me what other egregious beginner haskell sins im committing :)
16:54:10 <ski> (copumpkin : hm ?)
16:54:26 <copumpkin> from http://knol.google.com/k/edward-kmett/catamorphisms/3qi7x2qrdushx/2#
16:54:59 <ski> (yes)
16:55:30 <copumpkin> I don't really have a question, I just thought that was an interesting type
16:55:33 <copumpkin> :P
16:55:59 <ski> amckinley : i could take a look
16:56:36 <ski> (`mapList :: (a -> 1 + b * ..) -> ([a] -> 1 + [b] * ..)' .. hm)
16:56:54 <amckinley> ski: http://pastebin.com/me085169
16:56:59 <ski> @type mapMaybe id
16:57:00 <lambdabot> forall b. [Maybe b] -> [b]
16:57:05 <amckinley> im writing a parser for dhcpd config files
16:57:22 <ski> @type let mapEither :: (a -> Either b c) -> [a] -> ([b],[c]); mapEither = undefined in mapEither id
16:57:23 <lambdabot> forall b c. [Either b c] -> ([b], [c])
17:00:20 <ski> amckinley : oh ?! `conf-file' seems to be specified such that `parameter's and `declaration's are disjoint
17:00:51 <amckinley> ski: thats true
17:02:34 <amckinley> ski: dhcpd_config_file is obviously wrong right now; i was halfway finished writing it when i pasted that
17:02:58 <amckinley> what i think i want is something like this, which doesnt type-check:
17:03:07 <amckinley> dhcpd_config_file :: Parser DhcpdConfigFile
17:03:07 <amckinley> dhcpd_config_file = do
17:03:08 <amckinley>     stmnts <- many statement
17:03:08 <amckinley>     (ds, ps) <- partitionEithers stmnts
17:03:08 <amckinley>     return (DhcpdConfigFile ps ds)
17:03:49 <ski> i'm not sure why you have even written
17:03:51 <ski>   statement :: Parser (Either Declaration Parameter)
17:04:04 <ski> since you already have
17:04:08 <ski>       ds <- many declaration
17:04:09 <ski> and
17:04:13 <ski>     ps <- many parameter
17:04:19 <ski> in `dhcpd_config_file'
17:04:53 <amckinley> ski: yeah, im replacing those two lines with a single line that collects statements. the issue is that parameters and declarations can be interleaved in an arbitrary order
17:05:26 <ski> since (iiuc) `declaration's and `parameter's shouldn't be interspersed in a `conf-file', it seems the correct solution is to first parse the `parameter's and then the `declaration's
17:05:50 <ski> `Parser (Either Declaration Parameter)' would only be needed if you in some contexts could expect either of them
17:06:18 <ski> amckinley : oh .. so the can be interspersed .. the BNF said otherwise
17:06:26 <ski> s/the can/they can/
17:07:08 <amckinley> the bnf is a pack of lies :) i pulled it from the comments in the *actual* dhcpcd parser
17:08:08 <amckinley> although it *is* true that all the parameters for a given declaration should precede any additional declarations in the same scope
17:08:35 <ski> btw, instead of
17:08:40 <ski>        do d <- declaration
17:08:46 <ski>           return (Left d)
17:08:51 <ski> you could say
17:09:02 <ski>        Left `liftM` declaration
17:09:23 <copumpkin> or Left <$> declaration
17:09:53 <amckinley> copumpkin: oh, didnt know about that version of $, cool :)
17:10:03 <copumpkin> it's actually just fmap :P
17:10:18 * ski doesn't really like the applicative operator names .. and has not bothered to learn them yet
17:12:00 <amckinley> ski: so anyways, the problem that motivated all this is that my parameter parser breaks declaration parsing: because im parsing the beginning of the line and then case'ing on it, the parameter parser eats the start of declararations
17:12:34 <amckinley> my old parameter parser looked like this: http://pastebin.com/m75d6dbb2
17:12:55 <amckinley> which worked, because parameter_name is wrapped in a trt
17:12:57 <amckinley> *try
17:13:13 <amckinley> but its hideously ugly
17:13:22 <ski> `try' is ugly, yes
17:14:01 * ski prefers parsers with more symmetric disjunction
17:14:54 <amckinley> ski: so any ideas about how i should rewrite this? i feel like im doing more work than i have to
17:16:06 <amckinley> ive come up with a bunch of ideas, but im equally clueless about how to implement them
17:17:46 <ryanakca> Should one be able to do the RWH problems without having taken a course in algorithms? Refering to p.70, ``Create a function that sorts a list based on the length of each sublist.''
17:18:45 <Zao> ryanakca: I assume you've been introduced to sortBy and length already?
17:19:01 <amckinley> ryanakca: if you use the sortBy function, you can do it really easily
17:19:47 <SubStack> also Data.Function.on
17:20:19 <ryanakca> I've used length. I've been told to look at sortBy, but I have no clue how to use it.
17:20:27 <ryanakca> @src sortBy
17:20:28 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:21:02 <amckinley> hah! how cool is that implementation :) i havent seen that before
17:21:14 <monochrom> That is provably not the code used by GHC.
17:21:15 * SubStack has never used insertBy
17:21:43 <copumpkin> who gave lambdabot such a shitty sort?
17:21:48 <copumpkin> (source)
17:22:29 <amckinley> ski: if you can tell me how to rewrite my parameter parser so that doesnt consume input unless i match something in the case statement, that would solve my problem enough that i could continue
17:23:41 <ski> amckinley : why are you using `makeTokenParser', but not specifying `reservedNames' ?
17:23:58 <monochrom> Heh.
17:24:09 <monochrom> reservedNames will solve a lot of problems.
17:25:15 <amckinley> ski: monochrom: tell me more :) i was using reservedNames for storing the strings that prefix declarations (host, subnet, and group)
17:25:43 <amckinley> but im not sure how that would help me with the "other parser preemptively consuming my input" problem
17:25:46 <ski> all these `"authoritative"', et.c. should be parsed by `reserved {- lexer-} "authoritative"' usw
17:26:42 <amckinley> usw?
17:27:11 * kadaver has never used FooFactoryFactoryFactory()
17:27:18 <ski> sorry, "usw" = "und so weiter"(german) = "and so on"(english)
17:27:51 <ski> kadaver : never used a curried function of three arguments ?
17:29:18 <monochrom> «reserved "blah"» has an intrinsic «try» and so there will be backtracking done when alternatives fail.
17:29:20 <ski> i don't recall if it's in fact the case, but imo `reserved' in `TokenParser' ought to either consume a whole reserved identifier, or nothing at all (obviating the need for `try' or that ugly `case')
17:29:28 <ski> (if it doesn't i'd be surprised)
17:29:53 <ski> right
17:30:00 <amckinley> monochrom: yep. the only weirdness is that "reserved" doesnt actually check that the word in question is elem reservedWords
17:31:01 <monochrom> Correct. On the other hand «identifier» ensures that you are not seeing an elem of reservedName. That is important too.
17:31:14 <amckinley> right; i never understood why that was assymetrical
17:31:29 <monochrom> Lazy programmer.
17:31:48 <amckinley> :P
17:32:07 <ski> (ryanakca : heh, someone recently made a post on that problem on "stackoverflow")
17:32:23 <loupgaroublond> i'm curious, is there a way to do introspection in haskell, let's say i want to convert a command line argument to a name of a function, without having to write a dispatcher with all the values filled in ahead of time?
17:32:38 <kadaver> >>===
17:32:54 <ski> =>>
17:33:09 <copumpkin> loupgaroublond: not really
17:33:12 <monochrom> An library must make assumptions about how it is used; otherwise it would become intractible. There is an assumption that you use «reserved» reservedly. Under that assumption, there is no need to check.
17:33:37 <copumpkin> loupgaroublond: you could generate the boilerplate code automatically though in template haskell
17:33:48 <copumpkin> or using one of the other approaches
17:33:52 <amckinley> monochrom: im fine with that; i can change my code accordingly. although i dont really need to specify anything in reservedWords since im not using identifier anywhere
17:34:07 <monochrom> Ah, OK.
17:34:14 <amckinley> i may as well write "param_name name = try $ symbol name"
17:34:30 <loupgaroublond> copumpkin, that sounds like it will be good enough, though i'm curious what other approaches there are
17:34:53 <copumpkin> well the nice thing about haskell is that you can pass functions around as easily as anything else
17:35:07 <copumpkin> so you could just make a list of name, function pairs
17:35:09 <copumpkin> or a Map of them
17:35:45 <loupgaroublond> well, that's explicitely what i don't want, because it means if i have a module, i have to have a mapping for each function in the module
17:36:20 <amckinley> monochrom: so how do i set up a case-like structure that doesnt involve code that looks like this? http://pastebin.com/m75d6dbb2
17:39:05 <amckinley> monochrom: id like something thats as easy to follow/add additional branches as the case statement
17:39:58 <amckinley> one of the first things i tried was an alist mapping identifiers to the appropriate parser to finish off the parameter, but that didnt work because the types are all different
17:40:28 <monochrom> funny = [ ("hardware", liftM Hardware simple_param_value), ("authoritative", return Authoritative) ]
17:40:29 <zoheb> I have cabal installed a package, but how do I let ghci know where it is installed?
17:40:47 <zoheb> funny thing is winghci can load the package but ghci cannot
17:40:51 <monochrom> name <- choice (map fst funny)
17:42:31 <monochrom> case Data.List.lookup name funny in { Nothing -> this is bad; Just p -> p }
17:42:31 * ski wonders if one can do something with a GADT ..
17:42:35 <amckinley> monochrom: but id also like to avoid having an ADT that has one value for every option :P especially because im planning on pretty-printing this parsed config file and i dont want to have a corresponding number of cases for that
17:43:56 <amckinley> ski: GADT?
17:44:20 <ski> Generalized Algebraic Data Type
17:45:10 <ski> 8.4.6.Generalised Algebraic Data Types (GADTs) <http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt>
17:46:21 <ski> (but try monochrom's suggestion, first)
17:46:32 <zoheb> utils.o:fake:(.text+0x48): undefined reference to `haskelinezm0zi6zi1zi3_SystemziConsoleziHaskelineziMonadException_zdf3_closure'
17:46:45 <kadaver> how man LOC a day do you write in haskell?
17:46:49 <monochrom> If you don't want to design a data structure that has a million cases, you can always store strings instead. ("one-lease-per-client", "true")
17:46:55 <ray> kadaver: 2
17:46:58 <zoheb> I cabal installed hakeline
17:47:15 <amckinley> monochrom: thats what im doing now; check out the type definitions at the beginning: http://pastebin.com/m1f58d6c5
17:47:45 <ski> (amckinley : do you mean you want to avoid having the `Parameter' data type ?)
17:47:50 <amckinley> ski: thanks for the link. you think the "dispatch table" idea is the way to go?
17:48:04 <ski> no, niehter
17:48:06 <ski> neither
17:48:22 <amckinley> ski: no, im fine having Parameter the way it is, i just done want to have one value constructor for each option
17:48:29 <ski> i was just thinking one might use it to advantage, if other options don't work
17:48:31 <amckinley> *dont
17:48:54 <ski> you already have one constructor for each option in `Parameter'
17:49:25 <f4hy> I have a question about lazyness. If I take a giant list, and do: take 5 sort giantlist    will it only sort the first 5 elements, or sort the entire list?
17:49:27 <amckinley> ski: heres what i was doing before (which i dont like)
17:49:28 <amckinley> data Parameter =
17:49:28 <amckinley>     Hardware String
17:49:28 <amckinley>   | FixedAddress String
17:49:29 <amckinley>   | OneLeasePerClient Bool
17:49:29 <amckinley>   | Authoritative
17:49:30 <amckinley>   | DDNSUpdateStyle String
17:49:32 <amckinley>   | NextServer String
17:49:34 <amckinley>   | DefaultLeaseTime String
17:49:36 <amckinley>   | Filename String
17:49:38 <amckinley> -- dhcp options
17:49:40 <amckinley>   | OptionRouters String
17:49:42 <amckinley>   | OptionDomainName String
17:49:44 <amckinley>   | OptionDomainNameServers [String]
17:49:46 <amckinley>   | OptionNumeric String
17:49:48 <amckinley>   deriving (Show, Eq)
17:49:54 <ski> .. oh, maybe you mean the `POption',`POptionList',`POptionNum' constructors ?
17:50:09 <amckinley> right now, the parameter type has one constructor for each "type" of parameter: one for string options, one for bool options, etc
17:50:17 <ski> (me was thinking of "option" as in "alternative" (of the `Parameter' data type))
17:50:37 <monochrom> data P = P N V; data N = Hardware | Authoritative; data V = S String | B Bool.  That's one way to do it. There are some problems, but it is less verbose on the surface.
17:51:28 <amckinley> yeah, the terminology is confusing :P in the config file, you can specify regular "parameters", which apply to the server configuration, or you can specify "option" parameters, which map to actual dhcp "options" that you can specify for dhcp clients
17:51:32 <dmehrtash> Why isn't there a cabal uninstall command?
17:51:41 <kadaver> i have written ~ 6.5K LOC haskell totally. i code haskell well but still dont quite get the monads :P
17:51:44 <ski> f4hy : in general, depends on what `sort' does .. if `sort' is an insertion sort, it will probably just find the five smallest elements
17:52:01 <monochrom> Because you upgrade GHC every six months anyway.
17:52:05 <f4hy> ski: Well how do I figure out what the default sort is in Data.list
17:52:10 <amckinley> monochrom: i think what i have now is a pretty clean way of doing it
17:52:17 <amckinley> as far as the types go
17:52:30 <amckinley> i just need to find a way to use them cleanly :)
17:52:51 <ski> f4hy : you could time, i suppose ..
17:52:56 <ski> (or read the source)
17:53:35 <ski> (it might also just find the five smallest elements for some other sort algorithms .. but i don't know for sure)
17:53:36 <monochrom> If you have a million cases, you have to write a million lines of code no matter how you look at it. That's the brutality of "real" software.
17:53:37 <f4hy> ski: so probably a better solution is just to write my own method to just pick out hte top 5 elements yes?
17:53:39 <zoheb> can some one explain how one uses a package after cabal install - ing them?
17:53:56 <zoheb> Do I have to specify somethiing on the ghc command line?
17:54:10 <zoheb> i have the import statement in the .hs file
17:54:37 <zoheb> I get undefined errors from ghc utils.o:fake:(.text+0x48): undefined reference to `haskelinezm0zi6zi1zi3_SystemziConsoleziHaskelineziMonadException_zdf3_closure'
17:54:40 <amckinley> monochrom: im fine with writing a million lines of code, i just dont want to write n type definitions and then another n lines that construct them
17:55:11 <amckinley> id rather write m << n type definitions and a million lines that reduce those million options to one of a few simple types
17:55:21 <amckinley> because the set of types of parameters is much smaller than the set of parameters
17:56:43 <kerlo> @type liftM (show . sort . map (map toLower . filter isAlpha) . words) getContents >>= putStr
17:56:44 <lambdabot> IO ()
17:56:53 <yitz> f4hy: Data.List.sort is a merge sort that starts by dividing the list into pairs and sorting each pair, then gathering them into increasingly large clumps until you've got the whole list back.
17:57:09 <monochrom> A filename is a string. A fixed-address is a string too. But you will want to consider them two cases, since they have different semantics.
17:57:23 <copumpkin> kerlo: wouldn't interact be nicer?
17:57:34 <kerlo> Likely.
17:58:02 <kerlo> getContents >>= (putStr . (...)) would also be better than what I have.
17:58:29 <amckinley> monochrom: sure, but i dont care :D i dont mind filtering on the option name as a string instead of using pattern matching with a type when im manipulating various options
17:58:34 <yitz> dmehrtash: because no one has implemented it yet. dcoutts is looking for volunteers. interested?
17:58:54 <monochrom> Then I have already given a possible way.
17:59:15 <amckinley> monochrom: the "dispatch table" idea?
17:59:22 <monochrom> No.
17:59:52 <ski> > take 3 . foldr insert [] $ [5,7,1,4,2,8]
17:59:53 <lambdabot>   [1,2,4]
18:00:30 <ski> (yitz : hm, i wonder what behaviour that has wrt `take n' ..)
18:00:37 <zoheb> @t insert
18:00:37 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:00:43 <zoheb> :t insert
18:00:44 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
18:01:03 <ski> (yitz : is it a top-down or a bottom-up merge sort ?)
18:01:19 <ski> > foldr insert [] [5,7,1,4,2,8]
18:01:20 <lambdabot>   [1,2,4,5,7,8]
18:01:32 <yitz> ski: bottom up. it'll sort the whole list.
18:02:05 <yitz> ski: but f4hy has quit the channel.
18:02:20 <ski> ah. you are indeed correct
18:03:14 <amckinley> monochrom: the "reserved <foo>; liftM <whatever>" solution?
18:04:13 <dmehrtash> I am trying to install phooey and get the following error: cabal install phooey
18:04:13 <dmehrtash> Resolving dependencies...
18:04:13 <dmehrtash> cabal: cannot configure Stream-0.3.1. It requires QuickCheck >=2.0
18:04:13 <dmehrtash> For the dependency on QuickCheck >=2.0 there are these packages:
18:04:16 <dmehrtash> QuickCheck-2.1 and QuickCheck-2.1.0.1. However none of them are available.
18:04:20 <dmehrtash> QuickCheck-2.1 was excluded because checkers-0.1.3 requires QuickCheck <2.0
18:04:23 <dmehrtash> QuickCheck-2.1 was excluded because reactive-0.10.5 requires QuickCheck <2.0
18:04:27 <dmehrtash> QuickCheck-2.1.0.1 was excluded because checkers-0.1.3 requires QuickCheck
18:04:29 <dmehrtash> <2.0
18:04:33 <dmehrtash> QuickCheck-2.1.0.1 was excluded because reactive-0.10.5 requires QuickCheck
18:04:36 <dmehrtash> <2.0
18:04:37 <dmehrtash>  
18:04:40 <dmehrtash> any idea ?
18:04:47 <dmehrtash> how can I remove checkers and reactive?
18:06:56 <Saizan> dmehrtash: cabal install --constraint="Stream == 0.3.*" phooey
18:10:02 <zoheb> If cabal installs a package, is ghc supposed to automatically find it?
18:10:45 <Saizan> yes
18:11:19 <zoheb> I did a cabal instal but I had assocated my files with winghci
18:11:37 <zoheb> now I can use the functions only in winghci
18:11:42 <zoheb> not ghci or ghc
18:11:57 <Saizan> dmehrtash: oh wait, make that --constraint="Stream == 0.3"
18:12:10 <zoheb> it doesn't complain about the import statement
18:12:19 <zoheb> but gives me undefined references
18:12:56 <Saizan> zoheb: can you paste the error?
18:12:57 <zoheb> is there any param yo can pass to cabal.exe to ask it to install for ghc as well
18:13:01 <Saizan> on hpaste.org
18:13:03 <zoheb> on ghci
18:13:20 <zoheb> http://mibbit.com/pb/Tp5c98
18:14:07 <Saizan> zoheb: that's not an "undefined reference" error, that's because you've used undefined somewhere
18:14:11 <Saizan> > undefined
18:14:13 <lambdabot>   * Exception: Prelude.undefined
18:14:29 <zoheb> on ghc I get this
18:14:49 <zoheb> http://mibbit.com/pb/vktLth
18:15:01 <Saizan> zoheb: use --make
18:15:09 <zoheb> with ghc?
18:15:14 <Saizan> yes
18:15:24 <zoheb> ok
18:15:27 <zoheb> it works now
18:15:35 <zoheb> what about ghci?
18:15:55 <zoheb> thx Saizan
18:16:20 <Saizan> ghci seems to work fine, no?
18:16:30 <zoheb> no
18:16:40 <zoheb> ghc works and so does winghci
18:16:49 <zoheb> but not ghci
18:16:57 <Saizan> what's your problem?
18:16:58 <lispy> Not sure if lambdabot delivers messages reliably
18:17:08 <lispy> It just gave me a message I recived a few days ago
18:17:09 <zoheb> actually no
18:17:22 <zoheb> this is what the exectable prints out
18:17:34 <zoheb> exe built by ghc prints this
18:17:41 <zoheb> utils.exe: Prelude.undefined
18:17:57 <Saizan> yeah, that's a runtime error, cause by something in your code
18:18:03 <zoheb> ok
18:18:04 <Saizan> *caused
18:18:19 <lispy> if you've used undefined, you can replace it with error "Some hint"
18:18:24 <zoheb> thx Saizan
18:20:17 <zoheb> Well its some cut and pasted code from haskeline
18:20:26 <zoheb> it runs perfectly well on winghci
18:21:00 <zoheb> http://hackage.haskell.org/packages/archive/haskeline/0.6.1.3/doc/html/System-Console-Haskeline.html
18:22:32 <dmehrtash> <Saizan> thanks, I had to update my cabal and get the latest cabal, now it seems to go further
18:23:27 <dmehrtash> I am very confused about Cabal and ghc-pkg is there a place I can read about it?
18:24:36 <zoheb> I guess it is time to bug the haskeline folks
18:25:19 <vixey> does haskeline have the potential to be the best
18:25:19 <vixey> ?
18:26:08 <Saizan> dmehrtash: you can start here: http://www.haskell.org/cabal/
18:26:19 <zoheb> are you asking me vixey?
18:27:58 <yitz> vixey: it's hard to beat readline, but readline is gpl so not everyone can use it. it's easy to beat editline.
18:28:20 <vixey> what about haskeline?
18:28:36 <vixey> can we make it the best?
18:31:36 <yitz> vixey: it's very hard to make it the best overall. it may already be the best non-gpl.
18:32:04 <yitz> vixey: but then - i'm not sure it's best non-gpl for people who need a c api
18:32:28 <vixey> it's implemented in Haskell so that makes it hard for a C programmer to use?
18:33:52 <yitz> vixey: someone has to write an outward facing ffi wrapper. and then you'll always have the extra overhead of the haskell runtime for people who aren't otherwise using haskell in their app.
18:36:00 <gwern> yay?
18:36:52 <amckinley> how can i tell if a parser in parsec succeeded or not? i want to do "reserved <x>" where i have a bunch of strings in a list to try
18:37:25 <vixey> amckinley run the parser and the output is either  Left <error>  or  Right <success>
18:37:58 <vixey> if you meant inside a pasrer though, it's different you can use <|> there
18:38:47 <amckinley> vixey: my existing solution uses <|>, but i have a whole ton of cases, so i just want to put all the possible strings in a list instead of having so much boilerplate
18:39:09 <vixey> write a function tat creates the amckinley
18:40:08 <amckinley> vixey: so i can do something like map my parser on my list of words, filter for all the ones that evaluated to Right, and check if the list is empty?
18:40:18 <vixey> just like that yeah!
18:41:02 <zoheb> foldr <|>
18:41:20 <amckinley> zoheb: ooooo, that sounds a lot cleaner :)
18:43:56 <amckinley> zoheb: can you help me out a little more?
18:44:07 <zoheb> I guess you have a string
18:44:26 <zoheb> and have a fn that maps it to a monad lets say sM
18:44:36 <zoheb> sM "reserved"
18:44:53 <zoheb> yo want to <|> together all these words
18:45:28 <amckinley> zoheb: im with you so far
18:45:30 <zoheb> so foldr1 <|> $ map sM ["res1",res2"]
18:45:36 <zoheb> should do it
18:45:52 <amckinley> foldr1?
18:46:50 <zoheb> :t foldr1
18:46:51 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:47:01 <zoheb> :t <|>
18:47:02 <lambdabot> parse error on input `<|>'
18:47:07 <amckinley> :t (<|>)
18:47:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
18:47:18 <amckinley> gotcha
18:47:23 <idnar> wrong (<|>), but the signature is similar
18:47:34 <zoheb> yes I thought so
18:48:19 <zoheb> can some one get the type of <|> in parsec?
18:48:32 <amckinley> *Main> :t (<|>)
18:48:32 <amckinley> (<|>) :: GenParser tok st a
18:48:32 <amckinley>          -> GenParser tok st a
18:48:33 <amckinley>          -> GenParser tok st a
18:48:42 <zoheb> ouch
18:48:52 <idnar> that's the same signature, just with f = GenParser tok st
18:48:58 <idnar> (basically)
18:48:59 <vixey> where does it hurt zoheb
18:50:54 <zoheb> I was wondering if <|> creates a pair object
18:51:12 <zoheb> but I can't tell from the type
18:52:16 <vixey> no I don't think so
18:52:36 <vixey> it builds a new parser which tries the left or gives up and tries the right
18:54:06 <gwern> Fortunately, it turns out that we can avoid the problem of non ter-
18:54:07 <gwern> mination by introducing the concept of abortion.
18:54:37 <gwern> should've figured spj was a liberal - he's a dirty furriner
18:54:42 <gwern> at least, his name sounds furrin
18:54:58 <idnar> hahaha
18:55:07 <gwern> @quote simon
18:55:07 <lambdabot> legends says: the immortal heroes of Haskell, the simons, dons, quicksilver, Cale
18:55:13 <gwern> @quote SPJ
18:55:13 <lambdabot> SPJ says: will be a legend after his death
18:55:17 <gwern> @quote SPJ
18:55:17 <lambdabot> SPJ says: will be a legend after his death
18:55:40 <idnar> only after?
18:55:41 <idnar> also, quote fail
18:55:45 <gwern> @quote Peyton
18:55:45 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
18:55:47 <gwern> @quote Peyton
18:55:48 <lambdabot> chrisdone says: I think you mean Peyton `Simon` Jones.
18:55:55 <gwern> I guess we don't have many simon quotes
18:55:59 <gwern> @quote SimonPeytonJones Fortunately, it turns out that we can avoid the problem of non-termination by introducing the concept of abortion.
18:55:59 <lambdabot> No quotes for this person. You untyped fool!
18:56:02 <gwern> @remember SimonPeytonJones Fortunately, it turns out that we can avoid the problem of non-termination by introducing the concept of abortion.
18:56:02 <lambdabot> I will never forget.
18:56:41 <zoheb> for what its worth from some old non-compiling code I can see this  ->  opparse     = foldr1 (<|>) $ map (\(Ops x _ _) -> string x) opstable
18:58:14 <kadaver> ratingsMatrix[user][movie] = sum (userFeature[f][user] * movieFeature[f][movie]) for f from 1 to 40
18:58:27 <kadaver> should that be ratingsMatrix[user][movie] = sum ((userFeature[f][user] * movieFeature[f][movie]) for f from 1 to 40) do you think?
18:58:33 <kadaver> http://sifter.org/~simon/journal/20061211.html
19:00:50 <blackdog> heyo. anyone played around with vacuum? Is it normal for ghci to crash when you try to visualise a bytestring?
19:02:22 <cedricshock> I need to take the lazy cartesian product of two lists, possibly controlling the frequency of decent into the lists. Any suggestions?
19:03:21 <vixey> if you write it in haskell it's lazy
19:03:57 <cedricshock> Yeah, but it needs to visit every value eventually.
19:04:50 <cedricshock> So the naive approach doesn't work.
19:05:19 <vixey> I don't understand
19:05:24 <vixey> why not?
19:05:40 <Saizan> cedricshock: let me find a blogpost about a nice breadth-first monad
19:06:03 <sjanssen> vixey: consider the cartesian product of [1 ..] and [1 ..]
19:06:08 <vixey> ok
19:06:15 <dmehrtash> I am trying to install the latest phooey but it complains about Building phooey-2.0...
19:06:16 <dmehrtash>  
19:06:16 <dmehrtash> src/Graphics/UI/Phooey/WinEvents.hs:66:7:
19:06:16 <dmehrtash>     Could not find module `Data.Reactive':
19:06:21 <dmehrtash> It seems that Data.Reactive was in the 0.5 of the Reactive module, but the current version (0.10.5) no longer has the module.  Should I use the 0.5 or is there something wrong
19:06:21 <cedricshock> Say you have two lists, A and B, and you take the first element of A and every element of B. You'll never take the second element of A.
19:06:45 <vixey> that's not lazy
19:06:48 <vixey> it's diagonal
19:06:48 <cedricshock> Saizan: I didn't think of it that way. Perfect!
19:06:50 <vixey> right?
19:06:54 <sjanssen> the usual method (list monad or comprehension) is depth first, and won't enumerate every element of each
19:06:55 <BMeph> Didn't mmorrow golf that on -cafe? :)
19:08:01 <Saizan> cedricshock: http://www-ps.informatik.uni-kiel.de/~sebf/haskell/barefaced-pilferage-of-monadic-bind.lhs.html
19:08:11 <cedricshock> I tried doing this in python and got frustrated at the backtracking. For some reason I didn't see that as search backtracking.
19:08:32 <Saizan> cedricshock: also this from hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-monad-omega
19:09:30 <Cale> cedricshock: You can do it with the >>- operator from the logict package too
19:09:37 <Cale> hmm
19:09:54 <Cale> > [1..] >>- \x -> [1..] >>- \y -> return (x,y)
19:09:55 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
19:10:07 <Cale> good, it's in scope :)
19:10:08 <BMeph> There you are: http://www.nabble.com/Re%3A-Code-Golf-p23070683.html
19:10:18 <Saizan> the nice thing about the first i've linked is that it actually respects the monad laws
19:10:45 <Cale> hmm, I wonder how that works :)
19:10:47 <BMeph> Matt's solution uses *monoid* laws... ;p
19:10:54 <Cale> What order does it give?
19:11:31 <glguy> > [1..3] >>- \ x -> [4..6] >>- \ y -> return (x,y)
19:11:32 <lambdabot>   [(1,4),(2,4),(1,5),(3,4),(1,6),(2,5),(3,5),(2,6),(3,6)]
19:12:02 <glguy> > [1..3] >>- \ x -> [4..6] >>= \ y -> return (x,y)
19:12:03 <lambdabot>   [(1,4),(2,4),(1,5),(3,4),(1,6),(2,5),(3,5),(2,6),(3,6)]
19:12:25 <glguy> > [1..3] >>= \ x -> [4..6] >>- \ y -> return (x,y)
19:12:26 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
19:13:29 <cedricshock> Thanks for the great help. Exp[licit control of the ordering would be neat, but is hardly necessary right now.
19:19:10 <Cale> Um, Control.Monad.Omega is not really a monad.
19:19:39 <vixey> why not/
19:19:40 <vixey> ?
19:19:41 <glguy> what package is it introduced by
19:19:54 <Cale> Fails associativity.
19:19:55 <wli> Why not?
19:19:57 <vixey> Cale if you use the = of not caring what order the lists are in
19:20:05 <wli> Associativity?
19:20:14 <Cale> Well, yes, then it's okay :)
19:20:34 <wli> Which is associativity?
19:20:38 <glguy> (m >>= f) >>= g = m >>= (\x -> f x >>= g)
19:20:54 <glguy> easier to see with >=>
19:21:10 <glguy> (f >=> g) >=> h = f >=> (g >=> h)
19:22:16 <glguy> the other two, phrased with >=> are  return >=> f = f   and f >=> return = f
19:23:03 <vixey> :t (>=>)
19:23:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
19:23:32 * BMeph <3 >=>
19:23:46 <vixey> is
19:23:56 * BMeph waves... <3 >=>
19:23:59 <vixey> (n a -> m b) a arrow
19:24:22 <vixey> what about (n a -> m b)
19:24:23 <vixey> ?
19:25:04 <scutigera> do putStrLn "" putStrLn "" etc..  return 3.0 ; how do I recover the 3.0 from the calling function ?
19:25:25 * BMeph waves more... . . . . . . <3 >=>
19:25:25 <Cale> scutigera: you run the action, and bind the result in a do-block
19:25:33 <glguy> >=> is somewhat broken, however... its fixity is wrong
19:25:43 <glguy> stick with <=< :)
19:25:43 <Cale> like   do x <- foo; ... use x == 3.0 here ...
19:26:14 <BMeph> glguy: That one frightens me, it's headed right toward me!!! o.0
19:27:59 <Cale> scutigera: Only IO actions can run other IO actions (which is not a problem, because eventually main is an IO action too)
19:28:51 <scutigera> Cale: trying some code now.  I thought there was a way to "extract" results into "pure" code, maybe... ?
19:29:00 <vixey> @src Arrow
19:29:00 <lambdabot> class Arrow a where
19:29:00 <lambdabot>     arr, pure   :: (b -> c) -> a b c
19:29:00 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
19:29:00 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
19:29:00 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
19:29:02 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
19:29:04 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
19:29:09 <vixey> It's not arrow
19:29:25 <Cale> scutigera: Well, an IO action is allowed to run an IO action, get its result, pass it to a pure function and then take the result of that and do more I/O with it.
19:29:50 <Cale> scutigera: So if you need the result of some I/O, and you want your code to be pure, simply take the value as a parameter.
19:30:17 <BMeph> vixey: If one of those is a comonad, then sure. :)
19:30:38 <vixey> type What w m a b = w a -> m b
19:30:47 <vixey> A = What w m for a comonad w and monad m
19:30:48 <vixey> ¿
19:31:03 <scutigera> Cale: actually all I'm trying to do is use a bunch of putStrLn's before returning the result :-)
19:31:14 <BMeph> vixey: Not sure if it works both ways, so I guess that should be "if <whichever one works> is a comonad, then sure." ;)
19:31:52 <Cale> scutigera: Well, normally you'd separate it, and have a pure function which just plain produces the result, and let the I/O-performing code which uses that function print the newlines.
19:32:04 * BMeph closes his eyes, and clicks his heels: "Kmett, Kmett, Kmett!" ;)
19:32:11 <copumpkin> lol
19:32:42 <Cale> Kmett does seem more like a magic word than a proper name, doesn't it? :)
19:33:27 * BMeph waves his hands: "Kmetticus, Functoria!"
19:34:12 <scutigera> Cale: They are debug prints, i.e. I'm printing intermediate values in  a series of calculations, so I have to print them int the callee, the caller won't have access.
19:34:43 <Cale> scutigera: Ah, if you don't intend to leave them in the code, perhaps try Debug.Trace
19:35:32 <Cale> scutigera: Haskell code evaluates in a different order than you're probably used to though, so don't be surprised if the output is a bit confusingly ordered.
19:36:28 <scutigera> Cale: well it's numerical code and it likes to break every now and again, so I tend to turn them on and off.  In ML, I just wrap the prints in a thunk which checks the debug flag.
19:36:37 <Cale> scutigera: Usually this sort of thing can be avoided based on the fact that if a function produces a particular value for a given input, it will always produce that value, so you can generally test things separately. If you don't know what parameters a function is getting called with though, Debug.Trace can be useful for that.
19:37:10 <Cale> Another nice library to try is QuickCheck, which generates lots of random input in order to test if properties fail to hold.
19:37:26 <Cale> (and it gives you the inputs it found in the case that there's a failure)
19:38:23 <Cale> Printing things in the middle of evaluation makes more sense in a strict language though.
19:38:25 <gwern> @quote abortion
19:38:25 <lambdabot> SimonPeytonJones says: Fortunately, it turns out that we can avoid the problem of non-termination by introducing the concept of abortion.
19:38:41 <kadaver> is the GC in ghc less predictabe than Javas?
19:40:03 <Cale> kadaver: Hmm, less predictable? I'm not sure, but there's an RTS flag you can set to make a beep every time a collection is done.
19:40:13 <kadaver> lol?
19:40:22 <Cale> kadaver: Then you can listen to how regular it is in a given program :)
19:40:37 <kadaver> seriously?
19:40:39 <Cale> yes
19:40:45 <kadaver> pretty cool
19:40:47 <kadaver> do you knw which one?
19:40:58 <Cale> I'm just looking it up
19:41:02 <scutigera> Cale: well it's a bit of a long story, but the code can produce non-useful numbers.  For example a number which is too small to be useful.  So it doesn't blow up, like tries to divide by 0 or something.
19:41:51 <Cale> ah right,  +RTS --help works :)
19:42:06 <Cale>  -B       Sound the bell at the start of each garbage collection
19:42:57 <Cale> But for most programs, you'll just hear it constantly buzzing :)
19:43:12 <Cale> I suppose you can tell when the large collections happen if there's a lapse in the buzzing noise
19:43:17 <gwern> @quote bell
19:43:18 <lambdabot> Tac-Tics says: We also had a professor who spoke Chinese as his primary language. He mistyped "Pumping lemma" as "pumping lamma" and the entire semester, we just drew pictures of llamas with
19:43:18 <lambdabot> dumbbells on our homework
19:45:11 <scutigera> temp = do x <- foo show x;  Type error in final generator  Does not match : IO a
19:45:42 <Gracenotes> llamas are larger than frogs
19:45:58 <Gracenotes> allegedly
19:47:20 <wli> Quad, oct, 2*n for whatever n precision floats would be handy.
19:47:30 <Cale> scutigera: perhaps you mean  print x  ?
19:47:35 <Cale> print = putStrLn . show
19:48:17 <kadaver>  <prog> <args> [+RTS <rtsopts> | -RTS <args>] ... --RTS <args>
19:48:24 <scutigera> Cale: doh!  I keep forgetting that show produces a string ... thanks !
19:48:30 <kadaver> is it not for compilstion but for running it?
19:48:35 <Cale> kadaver: yeah
19:48:43 <Cale> kadaver: It works with any GHC-compiled program
19:50:02 <kadaver> wow friggin crazy annoying, ffreezes the computer lucky the progrsam wasn thuge
19:50:10 <Cale> kadaver: haha
19:50:14 <kadaver> but cool
19:50:21 <wli> Or maybe just saying how many bits of mantissa and argument is the way to go.
19:50:33 <Cale> kadaver: I've never had it freeze things, but it is really annoying :)
19:50:36 <scutigera> Cale: so once a called routine uses a "return "  the entire call tree must be IO functions, i.e. must all use the do construct ?
19:50:44 <Cale> scutigera: upward, yes
19:51:01 <Cale> scutigera: Well, that's not *quite* true -- return is a bit more polymorphic than that
19:51:07 <roconnor> Galois has been around for 10 years?
19:51:13 <Cale> scutigera: But for the IO monad, yes.
19:51:42 <Cale> scutigera: However, you can take the results of IO actions, and pass them as parameters to pure functions
19:51:43 * SamB tries to make some kind of a pun involving a field on which galois was built
19:52:17 <Cale> scutigera: and if a pure function has extra output to report, it can produce a tuple or other datatype
19:52:48 <Cale> scutigera: Generally, you only need to use the IO monad for the parts of your program which genuinely are doing input and output.
19:53:57 <SamB> if you work at it, yeah
19:55:12 <scutigera> Cale: I find my brain to be resisting... So even though the prints are pure side effect, and the return value is what's important, the prints cause the function to enter IO space, and once there, it, and it's result, can't leave ??
19:55:22 <Cale> right
19:55:30 <Cale> but you can easily separate the two
19:55:50 <SamB> also see Debug.Trace
19:56:02 <Cale> Suppose you have  myPureFunction :: Integer -> Integer
19:56:11 <Cale> You can write something like:
19:56:43 <Cale> displayMyPureFunction = print . myPureFunction
19:57:04 <Cale> and then  displayMyPureFunction :: Integer -> IO ()
19:58:29 <Cale> scutigera: The printing is a side effect, and functions in Haskell do *nothing* except to produce their result.
19:59:15 <SamB> Cale: tell that to Debug.Trace ;-P
19:59:32 <Cale> Well, right, Debug.Trace is magic.
19:59:56 <Cale> scutigera: Even displayMyPureFunction here only produces an IO action which is a description of some stuff to do -- the evaluation of displayMyPureFunction doesn't cause the printing to actually occur.
20:00:11 <SamB> (yeah, yeah, technically you have to redefine side effect in order to use Debug.Trace safely ...)
20:00:15 <BMeph> Oh, and SamB, trying to make puns off of Galois, is like climbing Mount Evariste... ;p
20:01:02 <Cale> Debug.Trace isn't particularly 'safe' with regard to semantics -- the order and number of times the messages are printed is somewhat indeterminate.
20:01:22 <SamB> Cale: that's why you have to redefine side-effect to make it safe
20:01:31 <glguy> roconnor, 10 years doesn't ring any bells...
20:01:39 <glguy> roconnor, it might account for work done before incorporation?
20:01:51 <SamB> you have to decide that "stuff getting printed to stderr doesn't count as a side-effect"
20:01:53 <scutigera> so if I want to print intermediate values in a way that makes sense then I would have to pass the values up the call chain and print them out in the penultimate caller, right ?
20:03:29 <Cale> scutigera: If you want to do it the right way. If you're just debugging and don't particularly care about the order or number of times the messages get printed, use Debug.Trace.
20:03:29 <SamB> why not the ultimate caller ?
20:03:50 <Cale> :t Debug.Trace.trace
20:03:52 <lambdabot> forall a. String -> a -> a
20:03:57 <SamB> well, actually, sometimes you do care about the order and number of times -- insofar is it helps you to debug
20:04:14 <Cale> It turns a value into one which when it is evaluated, will print the given message to stderr
20:04:38 <SamB> it's sometimes helpful to know something about the order in which things are evaluated
20:04:46 <scutigera> SamB: ultimate it is...
20:04:53 <Cale> But since evaluation order is up to the compiler, compiling with different options, or different versions of the compiler can cause that order to change :)\
20:05:39 <scutigera> so does pure refer to purely lazy ?
20:05:46 <SamB> no!
20:05:46 <gwern> no
20:05:48 <Cale> No, it refers to no side effects.
20:05:52 <SamB> it means "doesn't do random shit"
20:05:59 <Gracenotes> you can have purity in a strict language, although I don't know any major ones
20:06:02 <Cale> (like printing messages)
20:06:08 <Gracenotes> I think one or two has "pure blocks"
20:06:19 <gwern> Gracenotes: clean? but I guess it's not major
20:06:20 <SamB> well, the thing is, strict languages can get away with not having purity
20:06:22 <Cale> scutigera: Essentially what you're asking for is for purity to be broken.
20:06:23 <ac> isn't BitC working on something like that?
20:06:23 <adamvo> Cale: the order within pure code is still fixed by data dependencies, which may make Debug.Trace seem sensible sometimes, right?
20:06:32 <Cale> adamvo: yes
20:06:37 <Gracenotes> and if you have mutability, you probably have side effects
20:06:39 <SamB> plus, pure strict languages are less efficient than impure strict languages and pure lazy ones ...
20:06:39 <idnar> Gracenotes: does "const" in C++ count?
20:06:51 <idnar> hmm, I guess not really
20:06:58 <vixey> why is pure strict less efficient than pure lazy SamB?
20:07:04 <idnar> since you can still call other non-const stuff, just not on this
20:07:12 <gwern> vixey: it's just what the research says man
20:07:27 <Gracenotes> idnar: yeah. it seems.
20:07:29 <SamB> vixey: I don't have the citation at my fingertips for some reason :-(
20:07:43 <SamB> vixey: but you seriously haven't seen that one ?
20:07:47 <ac> speaking of BitC, I actually downloaded and managed to compile it (after a few minor compile errors), but I can't figure out how to install it
20:07:52 <vixey> I think pure strict you can compile to impure strict
20:08:15 <SamB> vixey: eh ?
20:09:15 <SamB> that doesn't mean you can occupy the whole space ...
20:09:48 <Cale> Oh, this is fun. I have a Reactive/FieldTrip program here which only works in ghci.
20:10:08 <Cale> Compile it, and it freezes after drawing the first frame of animation
20:10:20 <SamB> is it not pure ;-P?
20:12:19 <dons> Cale: need / don't need -threaded ?
20:12:28 <Cale> hmm, good point
20:12:48 <Cale> Aha, that was it
20:12:53 <Cale> Needs threaded
20:13:57 <scutigera> dons: if you are in pdx...Are there ever any meetings of the better haskell programming through beer drinking club ?
20:14:23 <dufflebunk> I'm sure there's an implementation of doubly linked lists somewhere, but I can't find one. Does anyone know of one?
20:14:41 <Cale> dufflebunk: Doubly linked lists are not all that useful.
20:14:58 <Cale> dufflebunk: At least, as immutable structures, they're just terrible.
20:15:27 <Cale> (because you can't share any part of the original structure when you make a new version by changing some piece)
20:15:44 <Cale> dufflebunk: If you want fast finite sequences, Data.Sequence is a good option
20:15:48 <Saizan> there's one in an oleg's post implemented emulating an heap with an IntMap on -cafe
20:15:55 <Cale> ah, hehe :)
20:16:02 <Cale> Yeah, you can do stuff like that
20:16:19 <blackdog> dons: heya. was fiddling with vacuum - why does it crap out if you try to visualise a bytestring?
20:16:22 <dons> scutigera: pdxfunc
20:16:22 * wli emulates heaps with Map and/or IntMap on a routine basis.
20:16:35 <dons> blackdog: it shouldn't. try upgrading vacuum
20:16:47 <dons> it'll draw it as a pair of a ForeignPtr and a couple of other bits
20:17:06 <scutigera> dons: cool...thanks.
20:17:24 * wli will return to pdx if by no other means than having his ashes scattered there posthumously.
20:17:56 <blackdog> using the latest vacuum, i get ARR_WORDS object entered
20:18:05 <blackdog> ghc-6.10.1
20:18:57 <dufflebunk> Cale: Yeah, I guess it would be tough. Sequence looks like it'll do. I need to be able to update elements, prepend, append, and move left and right one element at a time. Data.Sequence can do all that. Thanks.
20:19:05 <QtPlaty[HireMe]> Is there a typeclass of things that are composable?
20:19:30 <glguy> Category
20:20:27 <QtPlaty[HireMe]> Ah!
20:20:29 <chessguy> @src Monoid
20:20:29 <lambdabot> class Monoid a where
20:20:29 <lambdabot>     mempty  :: a
20:20:29 <lambdabot>     mappend :: a -> a -> a
20:20:29 <lambdabot>     mconcat :: [a] -> a
20:20:44 <chessguy> QtPlaty[HireMe], Monoid is sort of like that, i suppose
20:20:47 <blackdog> dons: http://pastebin.com/m3cb7e062
20:21:10 <blackdog> am i doing something hideously dumb?
20:21:14 <QtPlaty[HireMe]> chessguy: Not enought, but I think Category is.
20:21:17 <A1kmm> Hi, does anyone know of a way (either Haskell '98 or a ghc extension) to define record which has some named members and some unnamed members?
20:21:22 <chessguy> @src Category
20:21:22 <lambdabot> Source not found. :(
20:21:38 <Cale> A1kmm: I guess you can give it one named member which is a tuple.
20:21:56 <Cale> A1kmm: That would be about the closest thing.
20:22:55 <A1kmm> Cale: that's not really the same thing though... because then both members are collectively named.
20:23:12 <A1kmm> Rather than just naming one member.
20:23:52 <Cale> A1kmm: No, I mean, you use the tuple for the unnammed members
20:23:57 <Cale> unnamed*
20:24:29 <Cale> But yeah, if you only want one unnamed member, that solution sucks :)
20:24:36 <A1kmm> Ah... that doesn't really solve my problem, which is that I want to use ghc with -Wall -Werror
20:24:45 <Cale> what?
20:24:49 <A1kmm> and I need to use x { someMember=x } syntax
20:24:52 <A1kmm> But I get:
20:25:00 <A1kmm> QuadTree.hs:24:17: Warning: Defined but not used: `nwhere'
20:25:07 <A1kmm> because nwhere doesn't really need a name.
20:25:20 <Cale> Well, sure, because you didn't happen to use it yet.
20:25:30 <A1kmm> and I don't plan to use it.
20:25:37 <A1kmm> But I can't get rid of all the names because I use some of them.
20:25:48 <Gracenotes> you could probably ignore the warning
20:25:55 <Cale> So the obvious thing is just to ignore that warning
20:26:18 <A1kmm> Except I like to compile with -Werror so warnings are fatal, so I don't ignore them by accident.
20:26:19 <Gracenotes> point at the compiler and say "hush you :o"
20:26:37 <Gracenotes> mm. Maybe try a bug report then
20:26:44 <A1kmm> and I like getting legitimate defined but not used errors.
20:27:06 <Gracenotes> the function itself is not used
20:27:22 <A1kmm> Gracenotes: yeah... maybe if you use any of the records, not using all of them shouldn't be an unused error.
20:28:08 <Cale> A1kmm: You're sure you don't want to export the function from your module either?
20:28:24 <Cale> A1kmm: Apparently if something is exported, it counts as being used
20:28:56 <A1kmm> Well, it is an internal datastructure detail, so it would be unclean to export it, but that could be a workaround.
20:29:03 <Cale> -fno-warn-unused-binds should also specifically turn that off
20:29:57 <Cale> Oh, try naming the field starting with an underscore
20:30:06 <Cale> Not sure if that will work.
20:30:22 <Gracenotes> hackay
20:30:48 <Cale> It also tends not to complain if the name starts with an underscore, but I'm not sure if it applies in that case.
20:32:06 <Gracenotes> can you do Module Blah (...) where
20:32:09 <Cale> (It would be interesting to know)
20:33:23 <Gracenotes> it seems you can't. Module Blah where, is fine
20:33:46 <Cale> It would likely be two dots, anyway
20:34:15 <Cale> Since that's the syntax when you're expressing that you want all the constructors of a datatype exported
20:48:10 <andresj> hello! hey Im trying to install a program with Cabal, but it tells me this: "Warning: No remote package servers have been specified. Usually you would have
20:48:10 <andresj> one specified in the config file." I have no idea how to specifiy ther remote package servers...
20:48:22 <andresj> Any help? Thank you :)
20:49:02 <scutigera> does anybody know of a formatter which produces engineering notation, i.e. exponential with an exponent which is a power of 3 ?
20:49:13 <Saizan> andresj: backup ~/.cabal/config somewhere else, run "cabal update" that should produce one and download the index
20:49:20 <wli> Numeric.showGFloat
20:49:47 <Saizan> andresj: then you can restore the options from the backuped config, but also keeping the uncommented fields of the generated one
20:49:50 <andresj> oooh! It must be because i changed symlink-bindir, haha; thank you :)
20:50:46 <scutigera> wli: nope
20:57:04 <dons> andresj: your .cabal/config file should contain
20:57:06 <dons> $ cat .cabal/config
20:57:06 <dons> remote-repo: hackage.haskell.org:http://hackage.haskell.org/packages/archive
20:57:17 <dons> cabal update will solve it though.
20:57:30 <andresj> haha, thank you dons; yes, it sovled it once i deleted ~/.cabal/config
21:00:45 <scutigera> Instance of Integral Double required for definition
21:00:49 <scutigera> ??
21:01:36 <dons> probably you need to convert the integer argument to a Double
21:01:39 <dons> via fromIntegral
21:02:01 <scutigera> hmmm. looks like floor returns an Int ?
21:03:17 <dons> :t floor
21:03:19 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
21:03:33 <dons> to whatever Integral type you need (Int, Integer)
21:04:52 <scutigera> Yes - I actually couldn't quite make sense of that.  However I did floor 3.0 and then I had my answer :-) So there is  Double -> Double version of floor or do I apply an Int -> Double conversion (ML has realFloor)
21:06:03 <dons> fromIntegral . floor
21:06:10 <dons> is your Double -> Double version, I imagine.
21:06:20 <scutigera> double - doh !
21:06:52 <blackdog> dons: http://pastebin.com/m3cb7e062
21:06:57 <blackdog> i get that on mac and linux...
21:07:54 <dons> what version of vacuum?
21:07:59 <dons> that's typical of a very old version.
21:08:17 <dons> unpacking a few   too many closures.
21:08:24 <dons> check with mmorrow though, since that's his code.
21:08:25 <blackdog> 0.0.91
21:08:30 <blackdog> righto
21:08:36 <blackdog> actually, on a related note - has there been any talk of integrated bugtracking for hackage projects?
21:08:46 <dons> vacuum? 0.0.91?
21:08:56 <blackdog> yes
21:09:16 <dons> ah yes.
21:09:23 <blackdog> obviously if it's a big project you might set up your own, but it'd be a nice thing to centralise the way CPAN has
21:09:39 <dons> there's per-project trac's on trac.haskell.org (i think that's the url)
21:09:46 <dons> but they're up to the project maintainer to create
21:09:50 <dons> so not really integrated yet
21:10:18 <blackdog> dammit, first hpaste.org and now trac.haskell.org... is eveyrthing broken today?
21:11:23 <scutigera> significant n x = ...
21:11:25 <scutigera> significant :: (Floating a, Integral b, RealFrac a, Integral a) => b -> a -> a
21:12:06 <scutigera> could some kindly soul parse that, in particular I know the => is for classes, but why the 4 -tuple ??
21:12:21 <blackdog> scutigera: not really a tuple
21:12:33 <vixey> , means  and  here
21:12:35 <Zao> scutigera: The bit before the => are type classes the types have to satisfy.
21:12:36 <lunabot>  luna: Not in scope: `means'
21:12:38 <blackdog> that's saying that the type 'a' has to be a member of Floating, Integral, blah blah
21:13:09 <Zao> Much like , in deriving (Show, Enum, Ord) doesn't signify a tuple.
21:14:27 <leimy_> Can any of the Haskell web frameworks deploy a REST interface?
21:14:31 <leimy_> or is that yet a thing to be done?
21:15:20 <Saizan> define "deploy"?
21:15:53 <leimy_> implement for use?  :-)
21:16:18 <scutigera> blackdog: that's the type haskell derived, I could override it with an explicit signature, and constrain the types, right ?
21:16:30 <blackdog> scutigera: sure.
21:16:45 <blackdog> needs to be at least as specific as the one haskell derived, though.
21:17:23 <Saizan> well, REST is about the http interface your webapp offers no?
21:17:46 <Saizan> so i don't see how a webframework couldn't support that
21:17:50 <leimy_> Saizan: REST is just HTTP applied in a different way than some would have intended
21:18:07 <scutigera> eng 2 3.00E4 ... "30.0E3", it works... that would be showEngFloat.  Any chance I can lobby to have that placed in Numeric ?
21:18:12 <cothoughtpolice> dons: ping?
21:18:15 <leimy_> And it's that second part I'm wondering about.... Is it just going to serve pages or can I hook the URL to do something else  :-)
21:18:22 <scutigera> ;-)
21:18:41 <leimy_> I suppose if I use a RAW HTTP library I could stack what I want on it, I just wanted to make sure it wasn't done
21:18:48 <leimy_> google for "rest" doesn't yield much help
21:19:20 <Saizan> leimy_: well, most frameworks let you run arbitrary haskell code to generate a response
21:20:52 <Saizan> webserver /= webframework, in my understanding, that's why i was confused :)
21:29:44 <leimy_> Saizan: That ought to suffice
21:38:23 <cedricshock> What's wrong with this pattern(gives a parse error in pattern): successors (m, h:tail):others = (m, tail):(successors others)
21:39:03 <Saizan> cedricshock: successors ((m, h:tail):others) =
21:42:02 <cedricshock> Thanks. I remembered something funny with parentheses and :, but I tried them in all the wrong places.
21:42:39 <Saizan> : is the same as all the constructors in this regard
21:43:44 <Saizan> i.e. foo (Bar a b) needs the parentheses if 'a' and 'b' are the fields of Bar
21:48:01 <jbhatta> hey guys.  what's the difference between $ and . ?
21:48:05 <jbhatta> they both look like function composition to me
21:50:06 <Saizan> $ is function application
21:50:23 <inimino> jbhatta: precedence
21:50:34 <Saizan> a $ b == a b vs. a . b == \x -> a (b x)
21:51:00 <Saizan> ?src (.)
21:51:00 <lambdabot> (f . g) x = f (g x)
21:51:03 <Saizan> ?src ($)
21:51:03 <lambdabot> f $ x = f x
21:51:13 <Saizan> their definition is quite different.
21:52:35 <jbhatta> does f $ g $ x make sense if f and g are functions and x an argument to g
21:52:35 <jbhatta> ?
21:52:45 <jbhatta> will that evaluate to (f.g)(x)
21:52:46 <jbhatta> ?
21:53:23 * inimino misread the question
21:53:55 <Saizan> those two expressions are equivalent, yeah
21:54:19 <leimy_> Anyone got leskah working on Mac OS X?
21:54:20 <Saizan> though we generally write the latter (f . g) x
21:54:28 <leimy_> I'm not sure how to satisfy the GTK requirement so I don't need X11
21:54:59 <jbhatta> so if i leave out the rightmost application
21:55:09 <jbhatta> f $ g $ x = f $ g x = (f.g) x
21:55:10 <jbhatta> wtf
21:55:31 <jbhatta> does it associate in a weird way or something?
21:55:46 <Saizan> what's the problem you're having with that?
21:56:02 <Saizan> $ associates on the right
21:56:04 <newsham> f $ g $ x = f $ (g $ x) = f $ (g x) = f (g x)
21:56:56 <newsham> ?src (.)
21:56:56 <lambdabot> (f . g) x = f (g x)
21:58:50 <newsham> f $ g $ h $ i $ j $ k $ x = (f.g.h.i.j.k) x = f.g.h.i.j.k $ x
21:59:37 <jbhatta> ok, i think i get it
21:59:38 <jbhatta> thank you
22:00:36 <dons> thoughtpolice: ?
22:02:40 <leimy_> dons!
22:03:12 <leimy_> dons: do you know who was working the Mac OS X installer bits for the Haskell Platform stuff and found the documentation of the Leopard packaging to be well "woefully undocumented"?
22:04:10 <leimy> dons: I was wondering if they figured it out or needed help
22:04:40 <dons> let's see. its on the tickets.
22:05:08 <dons> Gregory Collins?
22:05:12 <dons> http://projects.haskell.org/pipermail/haskell-platform/2009-April/thread.html
22:05:14 <leimy> dons: reason I ask is I'm a co-author of that format :-)
22:05:31 <leimy> It was a toy project that Apple took seriously
22:05:32 <dons> http://trac.haskell.org/haskell-platform/wiki/OSX
22:05:36 <dons> heh
22:05:57 <dons> well, you can probably help out then :)
22:06:01 <dons> start talking to Gregory
22:06:09 <leimy> xar or "xml archive" is like tar but with an XML table of contents... I'll ask gregory.
22:06:35 <newsham> xml.  is there nothing it cant infect?
22:06:47 <leimy> newsham: it all started as a terrible joke
22:06:53 <leimy> and then RPM had a fork that used xar
22:07:04 <leimy> I mean one of our first releases was a xar file
22:07:06 <leimy> xar.xar :-)
22:07:58 <leimy> The only, arguably, cool thing that came out of that is if you have Mac OS X Leopard and a shell you can type "man xar" and they didn't bother to remove my email from the page... but they also used an old version that still has my ill fated OpenDarwin account :-)
22:08:03 <Axman6> i thought they were talking about the .pkg stuff
22:08:11 <leimy> .pkg is a directory :-)
22:08:15 <leimy> inside you'll find a xar :-)
22:08:19 <leimy> deep
22:08:41 <Axman6> ah right, yeah i remember reading about xar when it came out.
22:09:27 <leimy> Actually .pkg is a xar
22:09:29 <leimy> my mistake
22:09:33 <leimy> containing boms and such
22:09:40 <leimy> you can "xar -tvf" a .pkg file
22:09:49 <newsham> now do compression with the huffman table encoded as xml?
22:10:10 <leimy> Actually I wrote part of the compression pass for the TOC, because the binaries were ridiculously huge :-)
22:10:30 <leimy> and I was the one that took Rob's code initially and made libxar from it... another mistake :-)
22:10:32 <leimy> now it's being used.
22:10:41 <leimy> and I'm just so sorry for the world.
22:10:50 <newsham> leimy: they'll find you when the revolution happens
22:10:54 <leimy> yep
22:10:59 <leimy> my soul is forever damned
22:11:10 <leimy> We were joking "Everything is better with XML!"
22:13:15 <leimy> a very long time ago I thought about rewriting xar in haskell, but then decided that though HaXar was a neat sounding name... that it would just do more damage...
22:13:17 <Axman6> leimy: what's wrong with xar then? seemed like a good idea to me, having a easy to inspect index
22:13:58 <Axman6> i'm not an XML fan, but there's plenty of support out there for it
22:14:59 <newsham> the only thing easier than using an xml library is writing a parser for a simple ad hoc format.
22:15:15 <leimy> Axman6: it totally fubars streaming :-)
22:15:20 <vixey> XML is very complicated
22:15:32 <leimy> we had to rewrite xar so it didn't use DOM
22:15:35 <vixey> I have been reading some IDL files and XML DTD specs
22:15:35 <copumpkin> the SNR is low :)
22:15:41 <leimy> and made our own SAX-like thing.
22:16:04 <vixey> I't kinda amazing how detailed this stuff is -- and the kicker is all these specs are ignored right?
22:16:14 <leimy> Eh
22:16:20 <leimy> I think it was Rob Pike who said it...
22:16:32 <leimy> "XML doesn't solve anything we didn't already have solved, and it's not even particularly good at it."
22:16:51 <leimy> also XML in trying to be both human and machine readable is not really very good at being either.
22:16:55 <vixey> when you last use a XML lib .. did you feed it a DTD that it automatically verifies your input and buids a parse tree out of (not an XML parse tree but a relevant one to your program)
22:17:13 <vixey> there's something I know I never heard anyone doing, but it's possible with XML isn't it?
22:17:16 <leimy> vixey: Well-formed XML doesn't have to be valid XML
22:17:37 <leimy> valid XML can be validated against a DTD or if you're really picky a Schema or RelaxNG schema
22:17:45 <leimy> I know way too much about this horrible technology.
22:18:20 <blackh> leimy: XML is an excellent technology. Eat my shorts!
22:18:26 <leimy> hah
22:18:42 <leimy> CSV is better than XML :-)
22:18:46 <leimy> way simpler
22:19:05 <blackh> You sound to me like someone who has never had to write code in a commercial environment to handle CSV.
22:19:05 <Axman6> blackh: should've known you'd like XML :P
22:19:24 <newsham> someone should underspecify a vague RPC-slash-messaging layer on xml that can be everything you want (but probably nothing you need)
22:19:26 <mmorrow> blackh: heh
22:19:29 * leimy has about 4 pieces of a system using CSV that he designed himself that is going to ship soon :-)
22:19:29 <blackh> Or perhaps you are one of these people who isn't as old as me and therefore doesn't remember the dark ages before XML.
22:19:45 <Axman6> can you even heirarchial stuff in CSV?
22:19:49 <leimy> XML is like the reason we buy more RAM :-)
22:19:58 <leimy> You can encode anything you want in any ASCII stream :-)
22:19:59 <vixey> CSV  *lol*
22:20:02 <leimy> you just have to get creative :-)
22:20:08 <leimy> CSV is just incredibly easy to parse
22:20:19 <vixey> did what I was saying about IDL and DTD make sense though?
22:20:20 <leimy> and managers love it because it can go into Excel, and that's all they use
22:20:22 <leimy> so it's win win!
22:20:23 * mmorrow wakes up at night in cold sweats thinking of csv datadumps from AS\400's
22:20:26 <newsham> something like http://72.249.21.88/nonintersecting/?year=2006&monthnum=11&day=15&name=the-s-stands-for-simple&page=
22:20:29 * leimy is partially joking.
22:20:36 <vixey> hi mmorrow
22:20:43 <mmorrow> leimy: it's trickier than you'd think
22:20:48 <mmorrow> vixey: hi vixey
22:20:54 <leimy> mmorrow: not if you use a subset that you control
22:20:57 <blackdog> leimy: there's probably a case to be made for something like JSON over XML, though, especially for more casual use
22:21:08 <mmorrow> leimy: heh
22:21:28 <blackdog> mmorrow: is vacuum yours? It's crashing on bytestrings and making me sad...
22:21:31 <leimy> JSON is pretty good but I can use a reasonable CSV subset with a parser in Erlang or Haskell in like one page of code.
22:21:42 <newsham> blackh: in the dark ages before xml i've used ndr, xdr, plain ascii and lots of ad hoc encodings that all worked as well as and were better specified than xml
22:21:47 <mmorrow> blackdog: oh? which ByteString?
22:21:58 <newsham> asn.1 and ber aside
22:22:26 <blackdog> mmorrow: strict char8
22:22:30 <vixey> I guess I am not making any sense then...
22:22:36 <copumpkin> I'd expect lazy bytestrings to be the only ones that are interesting to see in vacuum?
22:22:54 <blackdog> mmorrow: http://pastebin.com/m3cb7e062
22:23:07 <mmorrow> blackdog: (unfortunately there's a current "bug" in ghc such that ghc coerces values to "HValue" (which is a type that is considered "enterable") which really aren't enterable, and there's no (simple) way to know from haskell
22:23:41 <leimy> I deal with ASN.1 too via SNMP
22:23:46 <mmorrow> so, the current work-around is to case on the con name string peeked from the info table, and then avoid the con fields with these "unpointed" closures
22:24:06 <mmorrow> blackdog: so basically, i have to add special cases for every such constructor
22:24:12 <blackdog> mmorrow: eesh. nasty.
22:24:37 <mmorrow> blackdog: ah, Char8. i'll definitely add that
22:24:46 <blackdog> glorious.
22:24:47 <mmorrow> blackdog: yeah :(
22:24:52 <newsham> leimy: you might enjoy http://www.ee.oulu.fi/research/ouspg/protos/testing/c06/snmpv1/
22:24:52 <mmorrow> weee :)
22:25:50 <newsham> (same protos group also tested other BER/DER based protocols)
22:27:19 <mmorrow> blackdog: (if there are any more of these "blah object entered!" situation that are coming up more than once, let me know. i want to try to cover as many commonly used constructors as possible)
22:28:38 <blackdog> mmorrow: no worries. am gonna have a look at the pretty graphs on one of my projects as soon as the bytestring bit works :)
22:28:41 <wli> I'm still stuck on the most basic aspects of modules.
22:29:12 <zoheb> All quiet ....
22:32:45 <zoheb> Is there a haskell IRC chat client?
22:32:45 <JesusJones> There were 2 people on a boat: /hop and /quit. /hop got off, who's still on the boat?
22:32:45 <gm|lap> remember, if you're starting a line with a /, type the / twice
22:32:45 <gm|lap> e.g //
22:32:45 <gm|lap> /
22:32:45 <newsham> /sign virgo
22:32:45 <newsham> oops
22:33:30 <mmorrow> @src ForeignPtrContents
22:33:31 <lambdabot> data ForeignPtrContents = PlainForeignPtr !(IORef [IO ()])
22:33:31 <lambdabot>                         | MallocPtr (MutableByteArray# RealWorld) !(IORef [IO ()])
22:33:31 <lambdabot>                         | PlainPtr  (MutableByteArray# RealWorld)
22:33:52 <dolio> Wow, that's actually in the database?
22:33:56 <mmorrow> hmm, this must not be the current source or something
22:34:01 <mmorrow> yeah, surprisingly
22:34:15 <QtPlaty[HireMe]> Which date libary is recomented?
22:34:34 <gm|lap> i don't know much about haskell, btw. do you know of a good haskell interpreter which runs well on unixy systems?
22:34:42 <gm|lap> ubuntu 8.10 specifically
22:34:42 <Chile`> ghc has ghci
22:36:05 <Chile`> alternately, if you're just playing around with haskell to learn it, hugs apparently has better error messages
22:36:20 <zoheb> hugs is very slow
22:36:35 <zoheb> ghci is pretty good
22:36:56 <zoheb> and you can compile your stuff, if needed
22:37:02 <ski> (there's also "Helium", specifically designed for teaching. is said to have better error messages (for beginners) because of language restrictions)
22:37:34 <blackdog> gm|lap: everyone and his dog uses ghc + ghci, though.
22:37:50 <blackh> blackh: Are you my dog?
22:37:53 <ski> (zoheb : istr a Haskell IRC client .. i think it might have been called "Hircules" or something like that ..)
22:37:55 <blackh> blackdog: ^^
22:38:02 <blackdog> blackh: it's funnier that way :)
22:38:04 <zoheb> yes saw that
22:38:10 <zoheb> 5 yrs old :D
22:38:17 <blackh> :)
22:38:35 <ski> so your question was answered in the affirmative
22:38:45 <zoheb> :)
22:39:10 <gm|lap> what about hugs98?
22:39:46 <gm|lap> i'll do hugs98 for now
22:39:48 <gm|lap> much smaller.
22:40:08 <ski> it's nice, imo. doesn't have as many extensions as ghc, though
22:40:23 <zoheb> I prefer ghci, it has a smaller install size
22:40:29 <zoheb> hugs has
22:40:29 <Chile`> gm|lap: if you just want to mess around a bit & get a feel for it, that's probably fine. if you ever want to do productive stuff though, as blackdog said, 'everyone' uses ghc(i)
22:40:45 <gm|lap> ok
22:40:55 <gm|lap> define "productive".
22:41:01 <gm|lap> wait.. is ghc a compiler?
22:41:05 <copumpkin> yeah
22:41:06 <zoheb> I wrote a program
22:41:16 <zoheb> took almost half hour to run on hugs
22:41:28 <zoheb> ran in ghci in under a minute
22:41:28 <blackdog> gm|lap: it's a bit mixed. ghci is an interpreter, but it can load compiled code
22:41:29 <Chile`> gm|lap: ghc is a compiler, but ghc packages have ghci which is an interpreter
22:41:52 <ski> @wn productive
22:41:53 <lambdabot> *** "productive" wn "WordNet (r) 2.0"
22:41:53 <lambdabot> productive
22:41:53 <lambdabot>      adj 1: producing or capable of producing (especially abundantly);
22:41:54 <lambdabot>             "productive farmland"; "his productive years"; "a
22:41:56 <lambdabot>             productive collaboration" [ant: {unproductive}]
22:41:58 <lambdabot> [6 @more lines]
22:43:07 <gm|lap> righty.
22:47:52 <mmorrow> blackdog: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.92
22:47:59 <blackdog> mmorrow: gracias
22:48:20 <mmorrow> de nada
22:50:54 <Sargun_screen> ww/window 21
22:54:08 * quicksilver laughs ironically at being included in an accolade with the simons.
22:54:13 <quicksilver> Poor deluded fool.
22:55:00 <Saizan> ?
22:55:05 <blackdog> mmorrow: lazy still dies, but strict bytestrings are fine - thanks
22:55:17 <mmorrow> blackdog: grr, /me fixes that too
22:55:30 <quicksilver> @quote legends
22:55:31 <lambdabot> legends says: the immortal heroes of Haskell, the simons, dons, quicksilver, Cale
22:55:57 <mmorrow> my "fix" for ForeignPtr seems to be failing (although i coulda sworn it worked at one point (?))
22:56:08 <blackdog> quicksilver: you're only semi-immortal?
22:56:17 <quicksilver> well, I've not died yet.
22:56:22 <quicksilver> that's 100% success rate so far.
22:56:45 <ramesh> hi i am looking for fast read of data of type int, integer from files. I am told that Bytestring is a good mechanism. . can you direct me to some tutorials, examples for this?
22:56:46 <copumpkin> hah
22:56:52 <dolio> Is that, like, he can only die if his head is cut off?
22:57:03 <dolio> And then his power is transferred to whoever does so?
22:57:20 <copumpkin> zomg
22:57:20 <Saizan> ?hoogle readInt
22:57:21 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
22:57:21 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
22:57:21 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
22:57:26 * copumpkin cuts quicksilver's head off
22:57:29 <copumpkin> I wantz ur powa
22:58:02 <mmorrow> ahh, i guess the ByteString in the ByteString.Lazy.Chunk is getting unpacked and disappearing, which is why my checking for the "PS" con is failing to find it (?)
22:58:36 <mmorrow> omg highlander
23:00:40 <mmorrow> yeah, the PS con disappears in ByteString.Lazy, and its contents get unpacked directly into the Lazy.Chunk constructor..
23:01:01 * wli ponders bounding searches for shortest Egyptian fraction expansions via Engel expansions.
23:01:04 <copumpkin> yeah, that makes sense
23:01:13 <newsham> ramesh: http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html talks about using bytestring
23:01:38 <newsham> ramesh: if you want to read binary packed data you might want to look at Data.Binary on hackage, too.
23:01:46 <wli> (e.g. if the Engel expansion has n terms search for an Egyptian fraction having at most n terms)
23:06:07 <blackdog> mmorrow: Data.Trie dies too, but that's probably lower on your list of priorities
23:06:12 * Saizan wants extensible gadts, ..and a pony!
23:06:51 <ski> GADTed records could be interesting
23:07:57 <Saizan> you'd have to stuff some richer type information in the labels
23:08:44 <quicksilver> can you extend the a la carte ideas to gadts?
23:09:28 <Saizan> yes, each functor can be a gadt
23:09:38 <copumpkin> more importantly, can you retain good type inference with a la carte ideas? :P
23:09:39 <mmorrow> blackdog: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.93
23:09:59 <Saizan> i kind of hate the data (f :+: g) a = L (f a) | R (g a)
23:10:03 <Saizan> though
23:10:05 <ski>   codata Foo :: * -> *
23:10:07 <ski>     where
23:10:13 <ski>     Bar :: Foo a -> (a,a)
23:10:18 <mmorrow> blackdog: hmm, i'll check that one out too, but it may be fixed with the ByteString.Lazy fix
23:10:19 <ski>     Baz :: Foo Int -> String
23:10:50 <cedricshock> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2261
23:11:09 <mmorrow> blackdog: (what i really should do is add a hook to supply Con names and a function to avoid certain of their children)
23:11:14 <ski> all `Foo a's have a `Bar' field, but they only have a `Baz' field if `a' is `Int'
23:12:07 <blackdog> mmorrow: checking now. Got a fun error with my Data.PerfectHash lib:
23:12:08 <blackdog> MUT_ARR_PTRS_FROZEN object entered
23:12:15 <mmorrow> heh
23:13:02 <quicksilver> this is the penance for mmorrow's sins :P
23:13:08 <mmorrow> blackdog: see the haddocks for GHC.Vacuum.ClosureTypes for the names of all the little beasts living in the heap
23:13:31 <mmorrow> quicksilver: hehe
23:14:23 <mmorrow> blackdog: all these guys slipping through is the result of unpacking i suspect
23:15:45 <mmorrow> blackdog: are you using the vacuum package directly? because if so i could add a function that takes Con names to side-step as a temp workaround.
23:16:06 <mmorrow> (i think i'm going to do that either way actually..)
23:16:22 <blackdog> mmorrow: using the ubigraph package - figured you'd prefer bug reports on the underlying package
23:16:38 <mmorrow> blackdog: cool, definitely
23:17:06 <mmorrow> ok, i guess i just need to suck it up and try to figure out how resolve the underlying issue.
23:17:32 <wli> 1/16 + 1/17 + 1/102 seems to be the best for 4/17
23:25:45 <harovali1> hi, of all the IO fuzz , what I can't get is that IO functions don't have the type of its signature, but another, more obscure one, like in
23:25:45 <harovali1> ioActions :: [IO()]
23:25:45 <harovali1> being
23:25:45 <harovali1> ioActions :: [RealWorld -> ((), RealWorld)]
23:26:13 <copumpkin> ?
23:26:26 <quicksilver> harovali1: I'm not sure what point you're making.
23:26:40 <quicksilver> "RealWorld -> ((),RealWorld)" is just one possible intuition
23:26:44 <quicksilver> it's not true, and not always useful.
23:26:55 <harovali1> mmmmpf
23:27:01 <quicksilver> the type of ioActions is [IO()]
23:27:07 <quicksilver> that's a perfectly reasonable valid type.
23:27:10 <quicksilver> and that is its type.
23:27:31 <harovali1> thanks quicksilver
23:27:34 <zoheb1> you may want to use sequence_ ioActions
23:27:55 <zoheb1> that should turn [IO()] to IO()
23:28:06 <quicksilver> good advice indeed.
23:28:14 <quicksilver> I wasn't entirely sure what harovali1 was asking though :)
23:28:54 <zoheb1> I guess he wanted to see something like [RealWorld -> ((), RealWorld)] instead of IO()
23:29:59 <copumpkin> mmorrow: you going to release your parallel ST stuff btw?
23:30:23 <A1kmm> hmm, I want to use Data.Heap, but the parameters to my compare function change at runtime. Anyone know a way to use a heap under these circumstances?
23:31:01 <zoheb1> won't you need to rebuild the heap if the compare changes?
23:31:16 <quicksilver> that's my thought.
23:31:20 <copumpkin> yeah
23:31:21 <quicksilver> changing the function should invalidate the heap.
23:31:25 <harovali1> zoheb1: that's what the IO inside tutorial says
23:31:26 <mmorrow> copumpkin: you mean that "M" monad?
23:31:32 <copumpkin> mmorrow: I think so
23:31:36 <mmorrow> copumpkin: i think people would lynch me :)
23:31:37 <A1kmm> zoheb1: I have a different heap for each parameter choice.
23:31:44 <mmorrow> copumpkin: (should i? ;)
23:31:55 <zoheb1> ok
23:31:57 <A1kmm> zoheb1: i.e. I am creating thousands of heaps with slightly different compare functions.
23:32:06 <copumpkin> mmorrow: I dunno actually, the parallelism break referential transparency now that I think of it
23:32:11 <zoheb1> you are looking for a heapBy like sortBy
23:32:23 <copumpkin> *can
23:32:39 <mmorrow> copumpkin: but as long as that's understood..
23:32:45 <copumpkin> do it!
23:32:45 <copumpkin> :P
23:32:51 <copumpkin> personal responsibility etc. etc.
23:33:07 <mmorrow> copumpkin: ok i will
23:33:13 <zoheb1> declare a new type with an extra fn field
23:33:24 <zoheb1> it is kinda ugly
23:33:46 <A1kmm> zoheb1: Won't that add a lot of overhead though?
23:33:50 <zoheb1> and you lose soem type safety
23:34:13 <zoheb1> yes that too, I am just trying to think
23:34:23 <copumpkin> data ArbitraryCompare a = ArbitraryCompare a (a -> a -> Ordering)
23:34:27 <mmorrow> copumpkin: it pretty much lets you unsafePerformIO safely (relatively speaking) by using ST instead of IO
23:35:00 <copumpkin> mmorrow: you still don't allow external side effects do you?
23:35:04 <mmorrow> copumpkin: and you can do cool stuff like have a Chan equivalent between two "pure" functions, and stuff
23:35:16 <mmorrow> copumpkin: oh no, you can do arbitrary things :)
23:35:21 <copumpkin> lol
23:35:23 <copumpkin> fun
23:35:47 <mmorrow> you can "implement" (in some shape or form) par
23:35:50 <mmorrow> etc
23:35:58 <copumpkin> you need to introduce some form of deterministic scheduling to it
23:36:09 <copumpkin> :P
23:36:10 <mmorrow> you can fork though
23:36:17 <copumpkin> yeah
23:36:19 <copumpkin> that's what I mean
23:36:21 <mmorrow> but you have MVars
23:36:52 <mmorrow> i dunno, it'll be fun to play with. i've only really messed with it for 10 minutes or so
23:37:00 <copumpkin> if you can ensure that all your forked threads always "interleave" in the same pattern, you'll be fine, but it sounds hard :P
23:37:21 <mmorrow> copumpkin: but what's the problem we're trying to avoid though?
23:38:03 <copumpkin> lack of referential transparency from ST?
23:38:14 <copumpkin> if I forkST a bunch of stuff
23:38:33 <mmorrow> you can escape ST with this M monad though..
23:38:41 <copumpkin> aha
23:38:46 <mmorrow> (which is its whole reason for being)
23:39:03 <copumpkin> but a more restricted form that somehow allowed deterministic forkage within ST seems useful too
23:39:14 <mmorrow> so s/forkST/fork/ :: a -> ()
23:39:29 <mmorrow> well, you'd probably want to do this so you forced the thunk
23:39:43 <mmorrow> fork :: a ->
23:39:52 <mmorrow> err, i guess there're a few options
23:39:55 <copumpkin> hmm, well, allowing some sort of Chan and *Var communication between the forked things
23:40:23 <mmorrow> the thing is that you have to start thinking about exactly what's forced and when (wrt "before that thing"/whatever)
23:40:47 <Saizan> don't par and laziness already do that?
23:41:05 <copumpkin> yeah, but they aren't as flexible as explicit interthread communication
23:41:21 <mmorrow> copumpkin: one neat thing is that you can have a function that returns a [a] in a streaming fashion, and then also be broadcasting a stream of 'b's over a chan as you walk the list
23:41:22 <copumpkin> but you can still have a parallel algorithm that is externall pure
23:41:42 <mmorrow> yes, you can always wrap all this stuff with a pure wrapper
23:42:00 <mmorrow> and an external observer would be none-the-wiser
23:42:07 <copumpkin> yeah, I was just wondering how possible it would be to allow parallelism in ST and hold people's hand while doing it
23:42:11 <copumpkin> preventing them from going bad
23:42:27 <copumpkin> anyway, you should still release your M
23:42:32 <copumpkin> :P
23:43:06 <mmorrow> it'd be trivial to go bad with this code :), so that would have to be in BOLD, and the lib for implementing things in new ways rather than "casual" use
23:43:44 <mmorrow> like, summoning unsafeCoerce would be just as easy as it is in IO
23:43:55 <mmorrow> (but not easy to do by accident)
23:44:06 <copumpkin> yeah
23:44:54 <copumpkin> I wonder what a good way to visualize lazy evaluation would be
23:45:27 <doctormach> How can I convert a Double to a Float?
23:45:32 <quicksilver> doctormach: realToFrac
23:45:34 <copumpkin> @hoogle Double -> Float
23:45:34 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
23:45:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:45:35 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
23:45:52 <doctormach> Thanks
23:46:08 <Ralith> hehehe
23:46:12 <Ralith> realToReal
23:47:16 <ski> mmorrow : is this (unpublished) `M' available for inspection, somewhere ?
23:47:21 <mmorrow> Saizan: but `par` doesn't give you any guarantee that it'll be eval in par
23:47:21 <ray> realToReal = id :: Real a => a -> a
23:47:33 <ski> (well, s/unpulished/unreleased/ maybe)
23:47:34 <mmorrow> ski: it's pasted, lemme find it
23:48:13 <mmorrow> ski: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1842
23:48:29 <copumpkin> are these references to james bond btw?
23:48:31 <copumpkin> M and Q?
23:48:39 <copumpkin> or is it just queue
23:48:54 <mmorrow> copumpkin: heh, no .. just by obsession with short names
23:48:59 <mmorrow> s/by/my/
23:49:13 <ski> (A1kmm,zoheb1,copumpkin : `ArbitraryCompare' looks possibly problematic)
23:49:14 <mmorrow> (Q for queue, M for ?)
23:49:17 <ski> mmorrow : ty
23:49:23 <ski> Monad
23:49:28 <copumpkin> ski: I wasn't being serious :)
23:49:47 <ski> ok
23:54:15 <A1kmm> ski: I think I will end up making my own version of Data.Heap that adds a way for dynamic compares for now.
23:55:16 <copumpkin> how would dynamic compares work on a heap? I still don't understand
23:55:45 <dolio> And black jack?
23:58:04 <sjanssen> data Heap a = Heap (Comparator a) (Heap' a); type Comparator = a -> a -> Ordering
23:58:16 <sjanssen> copumpkin: ^^^
23:58:37 <copumpkin> well yeah, but you'd need to rebuild the heap if you changed the comparator
23:58:43 <sjanssen> of course
23:59:34 <mmorrow> Data.{IntMap,Map,Set,IntSet} all Show/Read to a list..
23:59:37 <sjanssen> copumpkin: I think A1kmm means "dynamic" in the sense that the function is not known at compile time, but is fixed on construction of the heap
23:59:44 <copumpkin> ah :)
