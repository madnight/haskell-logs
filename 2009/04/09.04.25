00:02:48 <Gracenotes> > <
00:02:49 <lambdabot>   <no location info>: parse error on input `<'
00:03:10 <Gracenotes> > o <
00:03:11 <lambdabot>   <no location info>: parse error on input `;'
00:03:38 <Cale> candy fail!
00:09:00 <pumpkin_> lol
00:09:06 <pumpkin_> saturday night fail
00:09:19 * ski stumbles upon <http://stackoverflow.com/questions/788361/critique-this-late-night-noob-haskell-code> ..
00:10:18 <Axman6> http://startpanic.com/ uh wow...
00:10:29 <Axman6> little scared now
00:12:58 <ivanm> Axman6: oh no, it found out that I visited the graphviz site! :o
00:13:01 * ivanm starts running
00:15:10 <Axman6> zomgibrokereddit!
00:21:40 <ivanm> anyone here used Data.Sequence?
00:23:05 <pumpkin_> once or twice, why?
00:23:18 <ivanm> how good is it's performance?
00:23:49 <pumpkin_> it's not as good as a list for list-like behavior, but it's not what I'd call slow
00:23:54 <pumpkin_> I haven't done anything particularly huge on it
00:24:04 <ivanm> since I have to append stuff to the end of a "list" of values and traverse from left to right, Sequence looks appealing
00:24:25 <pumpkin_> yeah, it should be no slower snoc'ing than consing
00:24:28 <pumpkin_> you making a queue?
00:24:29 <ivanm> (DList sucks from what I can tell with getting the head/tail)
00:24:34 <ivanm> pumpkin_: nope
00:25:00 <ivanm> I'm just trying to implement an old imperative algorithm
00:25:04 <pumpkin_> ah
00:25:13 <pumpkin_> well, just keep in mind that many operations are logarithmic
00:25:23 <pumpkin_> but snoc is O(1)
00:25:36 <pumpkin_> so if you're just doing that and traversal, you should be fine
00:34:34 <ivanm> pumpkin_: only problem I see with sequence is that traversal involves pattern-matching the result of a function
00:34:56 <pumpkin_> ?
00:35:19 <pumpkin_> it's Traversable
00:35:27 <pumpkin_> oh, ViewL and ViewR are
00:35:30 <pumpkin_> I see
00:35:31 <ivanm> yup
00:35:40 <ivanm> @instances Traversable
00:35:41 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
00:35:54 <ivanm> @instances-importing Data.Traversable Traversable
00:35:55 <lambdabot> Maybe, []
00:36:23 <pumpkin_> I dunno, can't hurt to try and see how fast it ends up being
00:37:25 <ivanm> pumpkin_: my main point was that for pattern-matching, either I need to call viewL before passing the results to the function I'm actually using, or else use a case statement
00:39:22 <pumpkin_> ah
00:40:14 <Saizan> ivanm: you can use ViewPatterns
00:43:36 <hydo> In http://tinyurl.com/cwhul3 , line 18 specifically, \s is the current value of the state... but I should not think of it as passed as a parameter necessarily, correct?
00:44:40 <Saizan> hydo: can you elaborate?
00:46:09 <opqdonut> url doesnä
00:46:16 <opqdonut> *doesn't work for me
00:46:20 <hydo> Saizan:  Sure... when I looked at that definition and "\s" specifically, I immediately thought of passing parameters to lambdas... but that's not quite what's happening, correct?  The point here is that I don't quite understand the distinction between line 17 & 18 above and (\x -> x + 1) in the middle of a function.
00:46:28 <hydo> ack! really?  damn
00:46:56 <opqdonut> but anyway, to answer your question: the only way you can modify the state is with a function
00:46:57 <hydo> Try this: http://img.skitch.com/20090425-uhq5ak4pyaqajdhpqtfg8rxgb.jpg
00:47:08 <opqdonut> that receives the old state as a paramter and returns the new state
00:47:16 <opqdonut> that works
00:47:19 <Saizan> hydo: well, there's no difference, "s" actually a parameter
00:47:39 <opqdonut> yep
00:47:46 <Saizan> hydo: e.g. you could write returnSt a s = (a,s)
00:47:49 <pumpkin_> :t \x -> x x x
00:47:50 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t -> t1
00:47:50 <lambdabot>     Probable cause: `x' is applied to too many arguments
00:47:50 <lambdabot>     In the expression: x x x
00:47:59 <pumpkin_> fail
00:48:02 <Saizan> hydo: or returnSt = \a s -> (a,s)
00:49:59 <pumpkin_> returnSt = (,) ?
00:50:09 <opqdonut> that also :)
00:50:35 <hydo> Ok, so is it correct to think that get_st takes one argument even though the type definition says otherwise?  Or does it actually say that with ":: SimpleState  s s"?
00:50:57 <hydo> that = "it takes an argument"
00:51:08 <Gracenotes> > let lev s t = f s' t' where s'=length s;t'=length t;f i j=d!!(i*(t'+1)+j);d=liftM2 u[0..s'][0..t']; u i j|i==0=j|j==0=i|otherwise=minimum[f(i-1)j+1,f(i)(j-1)+1,f(i-1)(j-1)+(fromEnum$s!!(i-1)/=t!!(j-1))] in lev "pumpkin has a lot of fail today" "pumpkin has had no success today"
00:51:09 <lambdabot>   11
00:51:13 <Gracenotes> :o
00:51:15 <pumpkin_> lol
00:51:38 <pumpkin_> that looks awfully exciting
00:51:41 <Saizan> hydo: it says that it takes an argument, because "type" merely gives another name to the same type
00:51:57 <hydo> ok... now I get it.
00:52:01 <hydo> Thanks, Saizan
00:52:04 <Saizan> np
00:52:08 <Gracenotes> pumpkin_: oh, it is! :o
00:52:19 <Gracenotes> just Levenshtein distance
00:52:21 * pumpkin_ is listening to the end of Tosca
00:52:31 <pumpkin_> so dramatic!
00:52:33 <pumpkin_> :P
00:53:07 <pumpkin_> Gracenotes: that's pretty concise
00:53:12 <pumpkin_> how about damerau-levenshtein?
00:53:17 <pumpkin_> or whatever that was called
00:53:27 <Gracenotes> mm, possibly a bit more difficult
00:54:04 <ivanm> Saizan: hmmm? what are view patterns?
00:54:15 <Gracenotes> plain Levenstein is a good example of how dynamic programming with lazily read values can be concise and efficient
00:54:45 <Gracenotes> the above code basically makes a matrix from a plain list with an indexing system, f i j = d !! (i*(t'+1) + j)
00:55:32 <Saizan> ivanm: new in 6.10, you can write things like foo (viewl -> EmptyL) = ...; foo (viewl -> a :> as) = ...
00:56:59 <Saizan> Gracenotes: you could have used an Array
00:58:02 <Gracenotes> Saizan: yes, but at the cost of an import and more text!
00:58:25 <pumpkin_> is it necessarily more text? maybe you could've used pair indexing
00:58:32 <pumpkin_> and saved yourself some space with that
00:58:33 <pumpkin_> dunno though
00:58:49 <pumpkin_> it'd definitely be more efficient :P
00:58:52 <Gracenotes> it's just 202 characters as it stands. Probably can't be condensed to twitter length.
00:59:03 <pumpkin_> keep tryin'!
01:01:18 <SnailRacer> acos seems accurate enough (15 digits) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2212#a2212
01:01:18 <Gracenotes> pumpkin: I believe the Kolmogorov complexity of the algorithm is too great! :O
01:01:26 <pumpkin_> lol
01:01:38 <Gracenotes> actually, I could go with an even more inefficient version, which just uses plain recursion, no memoizing with the list
01:01:39 <pumpkin_> you could calculate it ;)
01:01:49 <pumpkin_> sounds good :)
01:01:52 <pumpkin_> but I'm gonna hit the hay
01:01:58 <pumpkin_> exhausting day
01:02:06 <Gracenotes> right.. at 4 AM..
01:02:18 <pumpkin_> what's wrong with that?
01:02:28 <pumpkin_> I needed to finish grading some homework :P
01:02:39 <Gracenotes> oh, aren't you such a TA!!
01:02:48 <pumpkin_> unfortunately
01:02:48 <Gracenotes> living the glamorous life
01:02:56 <pumpkin_> lol, no, I'd much rather not be
01:03:25 <Gracenotes> not be a TA?
01:03:28 <Gracenotes> :o
01:03:33 <pumpkin_> yeah
01:03:41 <pumpkin_> except I'd like to TA the haskell course
01:03:56 <Gracenotes> what class are you working with at the moment?
01:04:07 <Gracenotes> do you get your own little recitation session half the class doesn't show up to?
01:04:18 <Gracenotes> .. :(
01:04:24 <pumpkin_> a very intro course :P
01:04:26 <pumpkin_> and no
01:05:05 <pumpkin_> I'd prefer to be TAing a higher-level course though
01:05:25 <Gracenotes> yeah, I'd imagine
01:05:42 <Gracenotes> I actually have someone TAing two of my courses.. apparently there's a shortage
01:06:02 <pumpkin_> :o
01:06:02 <Gracenotes> one of which is intro, another is higher-level.. 160 and 350 respectively
01:06:32 <pumpkin_> means nothing to me :P
01:06:45 <pumpkin_> anyway, can barely keep my eyes open
01:06:57 <Saizan> do you have a TA on all your courses?
01:06:59 <Gracenotes> then twitter about it!
01:06:59 <pumpkin_> no fault of your course numbers!
01:07:23 <pumpkin_> Saizan: nope, only need to TA once to satisfy the degree requirements, so I'll probably do the minimum :P
01:07:37 <pumpkin_> Gracenotes: I only tweet about meaningful things ;)
01:08:10 <Gracenotes> for me, undergrad, there is usually a student assisting the professor, but only have sessions in the 2 classes (160 and 350)
01:09:07 <Gracenotes> being a TA might be interesting for a theoretical class. not so much a coding one
01:09:24 <pumpkin_> yeah, unless it's a haskell course :P
01:09:35 <pumpkin_> I might go out of my way to TA that
01:09:41 <pumpkin_> we'll see how busy I am that term
01:10:24 <Gracenotes> dare you degrade Haskell by calling it "coding"? Ã–
01:10:27 <pumpkin_> lol
01:10:32 <pumpkin_> guess so
01:10:37 <pumpkin_> interesting smiley you have there
01:10:47 <pumpkin_> anyway, ciao :P
01:10:57 <Saizan> notte :)
01:11:20 <Gracenotes> night
01:12:14 <dolio> Woo. Finally proved my insertion sort correct.
01:12:25 <dolio> @yow!
01:12:26 <lambdabot> What PROGRAM are they watching?
01:12:57 <Saizan> dolio: code or it didn't happen :)
01:16:41 <dolio> Oh, wait, I was premature. I finished proving that inserting something into a sorted list results in a sorted list.
01:16:50 <dolio> So I need one more theorem.
01:18:25 <Gracenotes> dolio: just that an empty list is sorted, I should imagine?
01:18:50 <thoughtpolice> dolio: coq?
01:19:19 <dolio> Well, I mean I need to write the theorem that says that insertion sort produces a sorted list. Apparently I forgot to write a sort function, too.
01:19:31 <dolio> I've been too caught up with the prerequisites.
01:19:35 <dolio> thoughtpolice: Agda.
01:19:48 <Gracenotes> ah.
01:27:04 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4215
01:27:12 <dolio> Saizan: Code ^^
01:43:44 <jekor> Anyone know of a way to convert UTCTime to CalendarTime?
02:11:59 <jedai> jekor: CalendarTime ?
02:15:01 <jekor> jedai: I ended up using the convertible library.
02:16:03 <jedai> jekor: if itjekor: Good choice I guess :) (a combination of formatTime and readTime would have worked too, though scarcely what one could call elegant)
02:16:45 <jekor> Thanks.
02:27:53 <score> morn
02:35:46 <jethr0> top of the morn
03:06:09 <ivanm> is there a map- or fold-like function that I can "shortcut" the results of, such that once a predicate is reached once I stop going through the list and return the remainder of the list?
03:08:19 <athos> > dropWhile (/= 3) [1,2,3,4,5,6]
03:08:20 <lambdabot>   [3,4,5,6]
03:08:44 <ivanm> nah, I want stuff from the beginning as well
03:09:00 <ivanm> what I'm wanting is a function that "splits out" the first value that matches a predicate
03:09:25 <ivanm> i.e. foo :: (a -> Bool) -> [a] -> (a, [a])
03:09:37 <ivanm> (Maybe a, [a]) is acceptable as well
03:10:10 <ivanm> atm, I'm doing a foldr with the conditional being (isNothing m && p a)
03:16:18 <Peaker> @hoogle deleteBy
03:16:18 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
03:16:30 <Peaker> @hoogle (a -> Bool) -> [a] -> [a]
03:16:30 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:16:30 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:16:30 <lambdabot> Prelude takeWhile :: (a -> Bool) -> [a] -> [a]
03:18:32 <Peaker> > splitBy (/=3) [1..10]
03:18:33 <lambdabot>   Not in scope: `splitBy'
03:18:44 <Peaker> @hoogle (a->Bool)->[a]->([a],[a])
03:18:45 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
03:18:45 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
03:18:45 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
03:18:52 <Peaker> > break (==3) [1..10]
03:18:54 <lambdabot>   ([1,2],[3,4,5,6,7,8,9,10])
03:19:41 <Peaker> ivanm: maybe break, head/tail and ++ ?
03:20:03 <ivanm> Peaker: yeah, but then I've got to re-create the list...
03:20:13 <ski> > break (const False) "abc"
03:20:34 <ivanm> *shrug* I'll just foldr over it... I might be recreating the entire list, but I'd have to do that for ++ anyway
03:20:48 <ski> @botsmack
03:20:48 <lambdabot> :)
03:20:48 <lunabot>  :)
03:21:08 <Peaker> ivanm: A DList break might be possible
03:21:20 <ivanm> ski: which of these two masochistic bots were you actually smacking? :p
03:21:33 <ivanm> Peaker: nah, I need to get the head of the list... which DList isn't good for
03:21:38 <ski> ivanm : the one who wouldn't answer
03:22:03 <ivanm> since AFAICT, head dlist requires converting the DList to a list, and then taking the head of it
03:22:20 <Peaker> ivanm: probably head on a DList is O(1) ?
03:22:29 <Peaker> ivanm: converting it to a lazy list
03:22:36 <ivanm> duh
03:22:43 * ski would try a `select :: [a] -> [] (a,[a])' ..
03:24:52 <Peaker> ivanm: let x = fromList [1..] :: DList Integer ; Data.DList.head x -- works   so it can't be O(N)
03:25:12 <ivanm> Peaker: *nod*
03:26:36 <ivanm> Peaker: though there's no break operation for DList
03:27:04 <Baughn> What's a DList, exactly? Doubly-linked list?
03:27:11 <ski> difference list
03:27:22 <Baughn> Like DiffArray?
03:27:23 <ivanm> Baughn: it's a wrapper around a function [a] -> [a]
03:27:36 <ivanm> the whole point of them is that concatenation is O(1)
03:27:45 <Peaker> ivanm: the constructor should be exposed
03:27:54 <ivanm> Peaker: duh, it is too
03:27:59 <ivanm> I thought it wasn't for some reason :s
03:28:08 <Peaker> ivanm: http://hackage.haskell.org/packages/archive/dlist/0.3/doc/html/Data-DList.html#1  gives that impression indeed
03:28:11 <Peaker> @type shows
03:28:12 <lambdabot> forall a. (Show a) => a -> String -> String
03:28:17 <ivanm> Baughn: because you don't actually perform the concatenation until you call toList, which then does the concatenation in the right order
03:28:23 <Peaker> Baughn: its a generalization of the ShowS type (String->String)
03:28:26 <ivanm> Peaker: yeah, I'm looking at that page
03:28:31 <ski> is there a point of having a `break' operation on difference lists ?
03:28:31 <Baughn> ivanm: Yes, I see. Wikipedia to the rescue.
03:28:41 <JoshTriplett> Does any magic package or option or similar exist which will allow code using Control.Exception to build as though that name referred to Control.OldException, so that I don't need to change the code in a backward-incompatible way?
03:28:44 <Baughn> ivanm: I've used those a lot, but explicitly as (++)
03:28:53 <ivanm> ski: the fact that I want a break function on normal lists, and Peaker is saying I should use DLists?
03:29:00 <Baughn> JoshTriplett: "build-depends: base < 4"
03:29:19 <JoshTriplett> Baughn: Ah.  Thanks. :)
03:29:24 <ivanm> Baughn: the point of DLIsts is that (a ++ b) ++ c is bad
03:29:24 * JoshTriplett tries that.
03:29:41 <Baughn> ivanm: Sure. And ++ is right-associative, isn't it? ;)
03:29:41 <ivanm> JoshTriplett: note that it is probable that your code will then not run with ghc 6.12
03:29:45 <ivanm> Baughn: yes
03:29:54 <ski> to implement `break' on a difference list, you have to apply it to `[]', so why is this better than using an ordinary list to begin with ?
03:29:54 <ivanm> but if you incrementally append new lists... *shrug*
03:30:12 <JoshTriplett> ivanm: Quite probably.  However, right now I just want to see if it'll build and run successfully, and then I want to port incrementally.
03:30:26 <Baughn> ivanm: RIght. No, I've been doing it via.. function composition. ++-composition, but..
03:30:30 <ivanm> ski: I suppose you might not have to fully convert it to a list *shrug*
03:30:32 <Baughn> Nice to have a name for it
03:30:34 <Peaker> ivanm: http://hackage.haskell.org/packages/archive/dlist/latest/doc/html/Data-DList.html#1 -- I was looking at an old version. DL is exposed in this doc
03:30:51 <ivanm> Peaker: *nod* I was thinking of an old version as well
03:30:53 <JoshTriplett> ivanm: Awesome, that worked perfectly.
03:31:00 <JoshTriplett> Er...
03:31:05 <ivanm> oh, that previous link was for an old version
03:31:05 <JoshTriplett> Baughn: Awesome, that worked perfectly. :)]
03:31:09 <JoshTriplett> :)
03:31:10 <ivanm> JoshTriplett: heh
03:31:23 <JoshTriplett> Baughn++
03:31:24 <ivanm> dammit, I didn't steal someone else's karma... :(
03:31:43 <ski> @type aDList
03:31:44 <lambdabot> [Char] -> [Char]
03:31:46 <Peaker> ski: break on DList is interesting for the fst list -- if you can attach it to the snd list
03:31:52 <ivanm> Peaker: how about a Sequence?
03:32:07 <ski> ivanm : please use `break' on `aDList' without "fully convert it to a list"
03:32:32 <ivanm> ski: I don't know how, I'm just saying it might be possible :p
03:33:09 * ski wonders
03:33:13 <Peaker> ski: I am not sure - but if break returns (DList a, DList a) then maybe you can get the fst DList to be tailed to the tail of the snd one, and avoid O(length fst) concat?
03:34:02 <ivanm> ski: actually, you're right:
03:34:13 <ivanm> you can't split up a DList into "chains" of DLists
03:34:18 <Peaker> @src break
03:34:18 <lambdabot> break p =  span (not . p)
03:34:23 <Peaker> @src span
03:34:23 <lambdabot> Source not found. Do you think like you type?
03:34:24 <ivanm> so you'd have to do toList
03:34:44 <ski> @let nBreak p dl = ((f ++),(b ++)) where (f,b) = break p (dl [])
03:34:44 <lambdabot>  Defined.
03:34:49 <ski> @type nBreak
03:34:50 <lambdabot> forall a a1. (a -> Bool) -> ([a1] -> [a]) -> ([a] -> [a], [a] -> [a])
03:35:59 <ski> (Peaker : i'm not sure what you mean by "get the fst DList to be tailed to the tail of the snd one")
03:36:21 <JoshTriplett> Oooh.
03:36:23 <Peaker> ski: basically: result = break ... ; (fst result ++ tail (snd result))
03:36:27 <ivanm> hmmm.... I could use sequence if only I can do stuff like "find the first value that does this" and deleting individual values...
03:37:02 <JoshTriplett> Baughn, ivanm: Even better, I can apparently pass --constraint='base<4' to Setup.hs configure, and then I don't need to modify the cabal file.
03:37:15 <ivanm> JoshTriplett: in the cabal file is better if you're making it public
03:37:21 <ivanm> which Baughn and I obviously assumed you were
03:37:22 <sjanssen> ivanm: I think you might want a FingerTree
03:37:30 <ivanm> but if you're just building it, then yes use that
03:37:35 <JoshTriplett> ivanm: Not yet.
03:37:37 <ivanm> sjanssen: isn't Sequence built on top of a finger tree?
03:37:40 <ivanm> JoshTriplett: *nod*
03:37:53 <sjanssen> ivanm: if your condition can be expressed as a Monoid, FingerTree is built exactly for "find the first value that does this"
03:38:01 <ivanm> :o
03:38:09 <sjanssen> ivanm: it is a specialization of FingerTree, yes
03:38:18 <ivanm> dammit, Sequence uses a custom FingerTree
03:38:31 <ski> anyway, the problem i see with `break' on difference lists is that if you difference list append a list returned from `break' with another list, you need to traverse and reconstruct the first list .. which is exactly what difference lists was supposed to avoid
03:38:32 <Baughn> JoshTriplett: Really, you should use "base >= 3, base < 4"
03:38:37 <sjanssen> ivanm: it's on hackage
03:38:41 <JoshTriplett> ivanm: Right now I wanted to verify that it'll build with GHC 6.10.  Apart from breakage with the new exceptions (in both the package itself and one of its dependencies), it does.
03:38:42 <ivanm> sjanssen: this is the "fingertree-0.0" package?
03:38:46 <ski> > nBreak isSpace aDList `fst` []
03:38:47 <lambdabot>   "cookies"
03:38:48 <sjanssen> ivanm: yes
03:38:50 <ivanm> looks weird to be version "0.0" :s
03:39:07 <ivanm> JoshTriplett: yeah, IIRC that was the only change in base 3 to 4
03:39:36 <JoshTriplett> Baughn: I would, yes, if I had any intention of continuing to use an old base.  Now that I've build-tested it, I want to do a little bit of smoke testing, and then start porting to GHC 6.10 and to newer versions of various dependencies as well.
03:39:45 * ivanm really wishes haddock maintained a central haskell doc page...
03:39:47 <JoshTriplett> On a related note...
03:40:08 <Baughn> JoshTriplett: In that case, make sure you add "base < 5", for the next version. ;)
03:40:12 <JoshTriplett> Regarding the new exceptions, how should I write a function which wants to catch any exception and then later rethrow it?
03:40:19 <JoshTriplett> Baughn: Yeah, I kinda figured that. :)
03:40:27 <Baughn> JoshTriplett: You can catch SomeException
03:40:37 <ski> @let nBreak' p dl = ((f ++),genericDrop n . dl) where f = fst (break p (dl [])); n = genericLength f
03:40:38 <lambdabot>  Defined.
03:40:43 <ivanm> sjanssen: so what are v and a in "FingerTree v a"?
03:40:48 <Baughn> JoshTriplett: Mind you, you can't really /do/ much with a SomeException
03:40:52 <Peaker> no point in making functions traverse dlists right?  Input lists, output dlists
03:40:55 <sjanssen> ivanm: read the finger tree paper
03:40:58 <Baughn> JoshTriplett: It's just a wrapper for the real one anyway
03:40:58 <malcolm__> I am trying to install mtl as a dependency for cabal on a fresh ghc 6.10.2 build - and I get """Setup: Error: Could not find module: Control.Monad.Cont with any suffix: ["hi"]""", anyone know what I need to do/install?
03:41:02 <ivanm> sjanssen: awww...
03:41:02 <JoshTriplett> Baughn: Except rethrow it. :)
03:41:03 <FunctorSalad> ivanm: it helps somewhat to order cabal to install all the haddocks into the same dir just one subfolder deep
03:41:04 <ski> > nBreak' isSpace anotherDList `fst` []
03:41:05 <lambdabot>   "cookies"
03:41:14 <ivanm> it's bad enough I'm trying to convert the algorithm from one paper... :(
03:41:15 <Baughn> JoshTriplett: Which begs the question of why you're catching it in the first place
03:41:24 <Baughn> JoshTriplett: If it's to do cleanup, bracket or finally are better
03:41:39 <JoshTriplett> Baughn: Won't quite work, though.
03:41:42 <ivanm> FunctorSalad: the biggest problem I have is that whenever I update a package or ghc, my bookmarks are all wrong :(
03:41:48 <JoshTriplett> Baughn: Well...
03:41:50 <JoshTriplett> Hmmm.
03:41:55 <Baughn> JoshTriplett: So, what are you going to do?
03:42:16 <dcoutts> malcolm__: sounds like you're trying to install without building first
03:42:27 * JoshTriplett thinks about if restructuring this code would let it use finally or bracket.
03:42:41 <Baughn> JoshTriplett: What does the exception handler /do/?
03:43:01 <Baughn> JoshTriplett: `finally` does everything "catch-and-rethrow" could let you do, except inspect the exception
03:43:09 <malcolm__> dcoutts: that is it, thanks for your help!
03:43:13 * malcolm__ slaps forhead!
03:43:21 <JoshTriplett> Baughn: Not quite.  finally won't let you distinguish between the exception and no-exception cases, AFAICT.
03:43:34 <Baughn> JoshTriplett: Oh, true. You want onError, then
03:43:34 <dcoutts> malcolm__: the error message could be nicer, feel free to file a ticket
03:43:39 <FunctorSalad> here's the relevant part of my .cabal/config fwiw http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4222#a4222
03:43:40 <JoshTriplett> Baughn: Ah.  Looking...
03:43:52 <ivanm> sjanssen: so is FIngerTree lacking newer versions because 1) there's nothing to update, it's done; or 2) now that the paper is written, etc. the authors can't be bothered touching it? :p
03:43:59 <Baughn> JoshTriplett: *onException. or bracketOnError.
03:44:18 <sjanssen> ivanm: I think its done, they got everything written the first time
03:44:33 <ivanm> *nod*
03:44:41 <ivanm> then why not 1.0 rather than 0.0?
03:44:44 <sjanssen> ivanm: what exactly are you looking to do
03:44:52 <FunctorSalad> if you remove the "$pkgdir" in htmldir you could even install all the haddocks into the same directory flatly
03:45:00 <Peaker> ivanm: not sure if its still relevant but: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4223#a4223
03:45:02 <FunctorSalad> but then the index.htmls will get overwritten
03:45:05 <Baughn> JoshTriplett: Rule #1: Assume there's already a library function to do it.
03:45:10 <ivanm> sjanssen: I'm finding jyp's implementation of nauty in HGAL slow, so I'm trying to re-implement it from scratch
03:45:21 <Baughn> JoshTriplett: People who forget that wind up on dailywtf.com. :P
03:45:29 <JoshTriplett> Baughn: Indeed.
03:45:31 <ivanm> FunctorSalad: but what happens if two packages have the same module?
03:45:31 <JoshTriplett> However...
03:45:44 <Peaker> ivanm: was more straightforward than I thought and I didn't event need DL :)
03:45:53 <JoshTriplett> Baughn: Rule #2: You will find that library function shortly after coding your own solution.
03:45:54 <JoshTriplett> :)
03:46:07 <FunctorSalad> ivanm: yeah that would cause overwriting too with the second variant (no $pkgdir)
03:46:08 <ivanm> Peaker: oh, you _cheated_
03:46:19 <FunctorSalad> ivanm: but isn't that very rare?
03:46:22 <Peaker> ivanm: where?
03:46:23 <ivanm> I thought you were doing (a -> Bool) -> DList a -> (DList a, DList a)
03:46:33 <Peaker> ivanm, I asked before: "no point in making functions traverse dlists right?  Input lists, output dlists"
03:46:37 <ivanm> FunctorSalad: no
03:46:42 <ivanm> mtl and transformers
03:46:50 <Peaker> ivanm: I don't think there's a point in walking dlists -- you have to convert them to lists first -- thing is you only convert the part you actually look at
03:46:53 <ivanm> which is why a lot of us can't build docs for gtk2hs :@
03:47:00 <Peaker> ivanm: due to laziness, so I think this has the proper O()
03:47:04 <ivanm> Peaker: but then I'll need to do that operation _again_!
03:47:09 <ivanm> since it recurses!
03:47:20 <Peaker> ivanm: what operation?
03:47:26 <ivanm> the breaking
03:47:32 <ivanm> later down the track
03:48:25 <JoshTriplett> Baughn: So, just trying to verify: if I do something like this...: do mightThrowSomething `onException` failureHandler ; successHandler
03:48:33 <sjanssen> ivanm: so what predicate will you be splitting the list on?
03:48:47 <Baughn> JoshTriplett: Sure, that'll work fine
03:48:49 <JoshTriplett> Baughn: Then failureHandler will only run on failure, and successHandler will only run on success (since the exception will get re-thrown)?
03:48:53 <Peaker> ivanm: ah, I am not sure that's problematic - but anyway you probably should be using Data.List.Split or so
03:49:00 <Baughn> JoshTriplett: Right
03:49:04 <JoshTriplett> Baughn: Perfect.
03:49:27 <Peaker> ivanm: Note that the dbreak only uses fromList on the untouched tail -- so if you use toList and break on it again, I don't think it destroys the O() but I might be wronghere
03:51:44 <JoshTriplett> Baughn: Hmmm.  I just realized that if I can rewrite this code using bracketOnError instead of onException, it should work with either base 3 or base 4.
03:52:25 <Baughn> JoshTriplett: ..base 3? Base 4?
03:52:41 <JoshTriplett> Baughn: Old and new Control.Exception?
03:52:45 <Baughn> That.. ought to be a non-sequitor
03:52:46 <Baughn> Oh
03:52:48 <Baughn> ^^;
03:53:07 <JoshTriplett> Baughn: onException seems new in base 4, but bracketOnError exists and has the same type in both base 3 and base 4.
03:53:47 <JoshTriplett> Baughn: So if I can use bracketOnError in my code that currently uses try and throwIO to catch and rethrow, I don't need to care which version of base I build with.
03:53:51 <Baughn> JoshTriplett: onException = bracketOnError (return ())
03:54:05 <Baughn> Plus a flip
03:54:37 <JoshTriplett> Baughn: Yup.
04:00:37 <pk1> how come haskell and yi can recompile so fast ?
04:00:50 <pk1> I meant, xmonad and yi
04:01:12 <ivanm> sjanssen: something like ((==) maxLen . snd)
04:01:33 <ivanm> pk1: they don't recompile much?
04:01:42 <ivanm> and probably almost no optimisations
04:02:06 <pk1> ho
04:02:29 <Peaker> ivanm: I think I was wrong -- and indeed all the toList/fromList in there are taking their toll
04:03:00 <ivanm> Peaker: of course you're wrong
04:03:02 <ivanm> duh
04:03:03 <ivanm> :p
04:03:27 <Peaker> ivanm: DList.fromList $ DList.toList $ x  -- should be O(1)
04:03:55 <sjanssen> Peaker: huh?  It certainly isn't
04:04:11 <Peaker> sjanssen: well, if its just putting the DL constructor around it and removing it?
04:04:26 <sjanssen> Peaker: that isn't what to/fromList do
04:04:31 <ivanm> sjanssen: I suppose to delete a value I can split it, remove the first element of the snd value then join them again?
04:04:37 <ivanm> which IMHO is a bit messy...
04:04:49 <sjanssen> ivanm: maybe you want something a bit zipper-ish?
04:04:50 <ivanm> Peaker: toList for DList does ($[]) to it...
04:04:55 <ivanm> sjanssen: could be
04:05:29 <Peaker> Yeah, for some reason I'm confused by O() analysis of lazy programs :)
04:05:43 <ivanm> OK, what I'm doing: generate a list of values xs, I then find the first value in that list with maximum length and seperate it out from the main list (xMax, xsOther)
04:06:36 <sjanssen> okay, that's easy.  Write your own recursive function, don't use span or break
04:06:42 <ScriptDevil> Can someone explain the meaning of the # operator in http://haskell.org/alex/doc/html/syntax.html
04:06:51 <ivanm> I have another list ws, where if some value == vk (where xs is defined from vk), then I append xsOther to ws
04:07:06 <ivanm> sjanssen: for the xs stuff, I've written one based on foldr
04:07:22 <ivanm> it's the appending on ws (which occurs recursively) that I'm worried about mainly
04:07:26 <sjanssen> ivanm: what else do you do with ws?
04:08:08 <ivanm> sjanssen: I need to be able to do head/tail on it, and then recurse
04:08:58 <sjanssen> ivanm: Data.Sequence should be okay at this
04:09:07 <ivanm> I have a third list vs: I basically do (vs', ws') = foo vs ws, then recurse on (tail ws)
04:09:27 <ivanm> sjanssen: for the ws stuff?
04:09:51 <sjanssen> ivanm: yes, because you have to append to it
04:10:00 <ivanm> how do you find what index something is at in a sequence?
04:10:31 <ivanm> so that I can replace a value in the Sequence?
04:10:34 <sjanssen> @docs Data.Sequence
04:10:35 <lambdabot> Data.Sequence not available
04:10:38 <sjanssen> bah
04:11:25 <sjanssen> it has functions to split the first element, like pattern matching on a list
04:11:45 <sjanssen> ivanm: in your example before, is maxLen static or dynamic?
04:11:57 <ivanm> dynamic
04:12:05 <ivanm> but I can do all my xs stuff with lists
04:12:35 <ivanm> sjanssen: I don't actually need the length; I just need the first list in the list of lists of maximum length
04:12:54 <sjanssen> ivanm: ooh, FingerTree would be great for this
04:13:01 <ivanm> heh
04:13:14 <sjanssen> just to be clear, you want maximumBy (comparing length)?
04:13:37 <ivanm> sjanssen: yes, as long as it is the _first_ such one
04:13:44 <ivanm> (which IIRC maximumBy does)
04:13:47 <ivanm> @src maximumBy
04:13:48 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
04:13:52 <ivanm> grrr....
04:14:07 <ivanm> sjanssen: I then have to remove that value from xs
04:14:17 <sjanssen> ivanm: so FingerTree would be able to find that item in O(log n) time rather than linear
04:14:33 <sjanssen> does that help your algorithm, or is that part not important?
04:14:51 <ivanm> e.g. [[1],[1,2],[1,2,3],[2,3],[2,3,4]] -> ([1,2,3], [[1],[1,2],[2,3],[2,3,4]])
04:15:03 <ivanm> sjanssen: it probably is important
04:15:23 * ivanm is only on p2 of 21 of the finger tree paper...
04:16:01 <Gracenotes> I know how that feels like
04:16:10 <Gracenotes> uh, reading papers... yeah...
04:16:12 <sjanssen> ivanm: by the way, what you've really got here is a max heap
04:16:21 <ScriptDevil> Is there a separate channel for alex?
04:16:33 <ivanm> sjanssen: hmmm...
04:16:39 <ivanm> ScriptDevil: I doubt it
04:16:52 <ivanm> there's at least two alex* nicks here :p
04:18:44 <ScriptDevil> ivanm: You know what I meant... http://haskell.org/alex/doc/html/syntax.html I would appreciate it if someone would tell me what # operator in BNF does
04:18:47 <ivanm> sjanssen: looking at the definition of Reduce in the finger tree paper... they say reduce{r,l} take two arguments but then provide three...
04:18:51 <mmorrow> this one is pretty: http://moonpatio.com/vacuum/gallery/xpose4_x3.small.png
04:19:00 <ivanm> ScriptDevil: yeah, I know what you meant ;-)
04:19:02 <mmorrow> , let xpose n a = transpose (replicate n a) in (xpose 4 . xpose 4 . xpose 4) [0..3]
04:19:04 <ivanm> and I don't know :(
04:19:05 <lunabot>  [[[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,0,0,0...
04:19:18 <ivanm> mmorrow: bored again? :p
04:19:26 <mmorrow> ivanm: heh
04:19:34 <ivanm> I like the semi-symmetry though
04:19:49 <mmorrow> ivanm: i'm playing with my new opengl vacuum viewer!!
04:19:52 <ScriptDevil> ivanm: Ok.. I will do it the hard way... Write a lexer using it and then try various inputs
04:20:17 <mmorrow> ivanm: if you vacuum anything from HughesPJ it's massive
04:20:30 <ivanm> mmorrow: that's the prettyprint library?
04:20:41 <ivanm> I'd believe so, what with the recursive definitions and all
04:20:51 <mmorrow> , let foo = parens . brackets . braces in foldr (.) id (replicate 5 foo) (int 42)
04:20:53 <mmorrow> yeah
04:20:53 <lunabot>  ([{([{([{([{([{42}])}])}])}])}])
04:21:07 <vixey> ([{([{([{([{([{lisp}])}])}])}])}])
04:21:10 <mmorrow> that there is unbelievably ginormous
04:21:28 <ivanm> vixey: your evaluation is slightly off... it's 42, not lisp!
04:21:49 <ivanm> mmorrow: "int" is pretty printing for integers I take it?
04:21:58 <ivanm> how many nodes does it generate?
04:22:28 <Gracenotes> there have been several papers on purely functional pretty-printing, actually...
04:22:45 <ivanm> and multiple libraries based on each of those papers...
04:22:48 <Gracenotes> quite a popular research area o-o
04:22:56 <ivanm> IIRC, mmorrow is responsible for at least one such library...
04:22:58 <tomh> @src int
04:22:58 <lambdabot> Source not found.
04:23:04 <ivanm> @hoogle int
04:23:05 <lambdabot> Text.PrettyPrint.HughesPJ int :: Int -> Doc
04:23:05 <lambdabot> Language.Haskell.TH.PprLib int :: Int -> Doc
04:23:05 <lambdabot> module Data.Int
04:23:19 <Gracenotes> int x = text (show x)
04:23:23 <Gracenotes> that's basically the source
04:23:28 <Gracenotes> for Text.PrettyPrint
04:23:31 <Gracenotes> at least
04:23:52 <ivanm> Gracenotes: Text.PrettyPrint just re-exports Text.PrettyPrint.HughesPJ IIRC
04:24:05 <ivanm> since they haven't bothered writing/including a better one
04:24:09 <Gracenotes> right.
04:24:23 <Gracenotes> other ones are available, but that one's built-in
04:24:46 <mmorrow> heh, here's that one Text.PrettyPrint graph http://moonpatio.com/vacuum/gallery/hughespj.small.png
04:24:48 <mmorrow> , let foo = parens . brackets . braces in foldr (.) id (replicate 5 foo) (int 42)
04:24:50 <lunabot>  ([{([{([{([{([{42}])}])}])}])}])
04:25:12 <ivanm> :o
04:25:16 * ivanm 's jaw drops
04:25:21 <mmorrow> i guess it's more that there're a lot of edges
04:25:34 <ivanm> mmorrow: what's all those values in a line?
04:25:47 <mmorrow> i'll upload the bigger version (i don't know)
04:26:24 <mmorrow> http://moonpatio.com/vacuum/gallery/hughespj.png
04:26:24 <Gracenotes> dot is kind of annoying like that
04:26:29 <ivanm> mmorrow: you could just look at the bigger version on your own machine and tell us... ;-)
04:26:36 <ivanm> Gracenotes: like what?
04:26:49 <ivanm> it doesn't increase the number of edges
04:26:58 <ivanm> just does its best to "prettify" the graph
04:27:04 <Gracenotes> sometimes it resizes it too small
04:27:07 <mmorrow> heh, that one node at the upper right that everyone's sharing is "False"
04:27:08 <Gracenotes> for svg particularl
04:27:10 <Gracenotes> y
04:27:16 <ivanm> mmorrow: have you tried comparing dot to neato for the vacuum stuff?
04:27:20 <ivanm> Gracenotes: true
04:27:26 <ivanm> mmorrow: lol
04:27:30 <mmorrow> ivanm: i haven't actually, but that's on my list
04:27:35 <ivanm> *nod*
04:27:50 <Gracenotes> very pretty graph
04:27:54 <ivanm> I've been thinking about that for my sourcegraph stuff, whether it might produce nicer graphs
04:28:09 <ivanm> because haskell code seems to be very wide and short :s
04:29:58 <ivanm> sjanssen: I was about to say that the paper's definition of a FingerTree only has one type parameter, not two... then I noticed that it gets expanded in later sections :s
04:30:44 <ivanm> wtf? a paper that includes exercises? :s
04:31:58 <mmorrow> ivanm: yeah, even a small amount of adding attributes/tweaking things with graphviz goes a really long way
04:32:05 <vixey> you were wanting to read the paper without thinking much ?
04:32:16 <ivanm> vixey: heh
04:32:34 <mmorrow> like, there're dashed and dotted arrows, which are nice when you don't want them to totally drown-out everything else
04:32:36 <Peaker> thinking is costly in nutrients
04:32:43 <mmorrow> and colors go a long way too
04:33:12 <ivanm> mmorrow: but automatically working out which colours to use can be annoying...
04:33:43 <mmorrow> there're also hierarchicallly nested subgraphs http://moonpatio.com/images/unwound.png
04:33:57 <mmorrow> graph [compound = true];
04:34:14 <Peaker> graphviz is very cool. Sometimes its positioning heuristics do a bad job though, imo
04:34:29 <mmorrow> Peaker: yeah, it's hit or miss
04:35:03 <Peaker> a friend of mine had a pet toy project of creating an animating gui around graphviz
04:35:17 <mmorrow> this is one of my favorite graphviz-rendered graph (wrt to the styles) http://moonpatio.com/images/tricolor.png
04:35:24 <Peaker> pygame/sdl made it pretty slow/unsmooth as soon as more than a few nodes were created
04:39:06 <mmorrow> Peaker: what do you mean by animated?
04:39:27 <Peaker> mmorrow: when you change anything, the graph may change significantly
04:39:34 <Peaker> mmorrow: its disorienting if the change isn't animated
04:39:54 <Peaker> mmorrow: stuff travels to their new location rather than just reappear there
04:39:56 <mmorrow> Peaker: how do you change things, via gui widgets, writing to the file?
04:40:13 <Peaker> mmorrow: you press a key to add nodes, different keys to connect them, various keys to change their attributes
04:40:25 <mxc> anyone using leksah on osx?
04:41:00 <hamishmack_> mxc: yes
04:41:13 <mmorrow> Peaker: oh cool, nice. i've thought about something or other along those lines too
04:41:32 <mxc> hamishmack_ wld you suggest using quartz GTK or X11 GTK?
04:41:48 * vixey cries
04:42:10 <hamishmack_> mxc: I use the quartz version
04:42:25 <mxc> and quartz/gtk is decent?
04:42:29 <hamishmack_> mxc: It requires XCode 3.1+
04:42:49 <mxc> got that
04:42:51 <hamishmack_> mxc: and lacks gtkglext
04:42:51 <mxc> thanks though
04:43:04 <mxc> yeah
04:43:16 <mxc> was thinkng, since i'm not doing anything in 3d, lacking GL isn't an issue right?
04:44:09 <vixey> mxc: u cn do 2d wth gl
04:44:17 <hamishmack_> mxc: Other than that it seems fine.  gtk apps don't come to the front when they start
04:45:59 <hamishmack_> mxc: If you want to use opengl you can still create non gtk opengl apps
04:46:34 <mxc> cool
04:46:35 <mxc> ty
04:47:13 <hamishmack_> mxc: make sure you take a look at the osx install section in the leksah manual
04:47:24 <mxc> reading it
04:52:58 * vixey wonders why people don't just type in real/full words
04:53:20 <mmorrow> wut
04:53:21 <ivanm> vixey: wat u tkn bout?
04:53:39 <bremner> me 2. thy l4me
04:54:14 <Baughn> vixey: wlel, it ins't rlealy rqueierd
04:54:25 <vixey> supercalifragilisticexpialidocious
04:54:43 <ski> Constantinopolitanischerdudelsackpfeifenmachergesellschaft !
04:54:58 <mmorrow> a
04:55:10 <vixey> aardvark
04:55:21 <mmorrow> snorkel fishermen
04:55:43 <ski> left Kan extension
04:55:43 * vixey found Nihilistendynamittheaterkaestchenssprengungsattentatsversuchungen
04:56:01 * ski gives bonus points to vixey
04:56:38 <Baughn> Buffalo buffalo Buffalo buffalo buffalo buffalo Buffalo buffalo.
05:03:38 <Baughn> http://specgram.com/CLI.2/03.bakery.disorder.html <-- This is somehow relevant
05:03:59 <Peaker> Better name for this action than mkSynchronized: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4227#a4227  ?
05:05:11 <Peaker> @pl \act -> withMVar lock (<$ act)
05:05:12 <lambdabot> withMVar lock . flip (<$)
05:05:28 <Peaker> @pl \lock act -> withMVar lock (<$ act)
05:05:28 <lambdabot> (. flip (<$)) . withMVar
05:06:22 <ski> (`makeSynchronizor' ?)
05:10:13 <Peaker> ski: do you know Java's "synchronized"?
05:10:23 <Baughn> So.. an MVar may be used as a mailbox, or a mutex (preferably for the value stored in the mvar). Has anyone here ever used a single one as /both/?
05:10:31 <Baughn> I'm wondering if the type should be split
05:10:58 <ski> Peaker : barely
05:11:20 <Peaker> ski: Basically, you "decorate" actions with that - and it will lock a mutex during their execution
05:11:48 <ski> (i don't recall what Java does on recursive call, e.g.)
05:11:50 <Peaker> ski: in Java, "synchronized" uses "The" instance's mutex, iiuc.  Here, you create a "synchronized" decorator and then whatever you use it to decorate will share the mutex
05:12:24 <ski> yes, i see
05:12:47 <eu-prleu-peupeu> Peaker: i like you
05:13:40 <Athas> I can't find any work on possibly improving Haskell's module system in a future revision or extension.  Has no work been done on the matter?
05:13:58 <ivanm> Peaker: you might want to consider running if you don't reciprocate eu-prleu-peupeu's advances... :p
05:14:06 <Athas> Apart from minor details on the Haskell Prime website, that is.
05:14:34 * Peaker runs as quickly as possible
05:14:41 <ivanm> Athas: AFAIK, the problem is a lot of people have a lot of opinions
05:14:44 <eu-prleu-peupeu> :D
05:14:47 <ivanm> but there's no clear consensus yet
05:15:05 <ivanm> Haskell' is meant to be an incremental, not evolutionary advancement of the language definition
05:15:16 <Peaker> I have never used ML, just Haskell - and I don't feel that I miss a more powerful module system
05:15:38 <Peaker> ivanm: incremental ~= evolutionary ?
05:15:54 <ivanm> Peaker: incremental: bugfixes, small changes, etc.
05:16:00 <ivanm> evolutionary: great big changes
05:16:10 <Peaker> ivanm: you mean revolutionary maybe?
05:16:15 <Gracenotes> hopefully adding a function or two to Prelude won't be considered a big change
05:16:19 <Peaker> ivanm: evolutionary typically means small gradual incremental improvements
05:16:20 <ski> (Peaker : since the action returns a (parameterized) action that, when invoked, will synchronize, i thought it appropriate to name it something like `makeSynchronizor', i.e. the returned value of type `IO () -> IO ()' is the synchronizor)
05:16:27 <Gracenotes> I could stand to see `on` there
05:16:38 <ivanm> Peaker: oh... what term am I thinking of then? :s
05:16:38 * ski idly wonders why not `IO (IO a -> IO a)'
05:17:01 <Peaker> ski: Yeah - I thought about synchronizer too, but that doesn't connect to the term that Java uses (which may be just as well)
05:17:30 * ski fails to see what Java has to do with the issue
05:17:39 <Peaker> ski: no good reason -- I'll fix it to be IO a -> IO a :)
05:17:53 <Peaker> ski: the current implementation forces that type
05:18:37 <Athas> SML's module system is really nice, but I wonder if anyone has come up with improvement since it was designed 20(?) years ago.
05:18:58 <Athas> The signature system is something I miss in Haskell (even if typeclasses can be used for some of the same things).
05:19:25 <Peaker> Athas: can you show an example of a case where you miss it?  not having used ML, I feel I might be missing on something here
05:19:43 <ski> @hoogle [[a -> [a]] -> a] -> a
05:19:43 <lambdabot> No results found
05:20:33 <eu-prleu-peupeu> http://google-code-updates.blogspot.com/2009/04/mercurial-support-for-project-hosting.html
05:20:38 <eu-prleu-peupeu> darcs is left out once again :/
05:21:01 <Athas> Peaker: it's sort of a type signature for modules, making it easy to work with different implementations.  Additionally, it permits facilities like functors, roughly a function from structures to a structure.
05:21:48 <Athas> As an example, a regexp-functor might take two structures as parameters, a parser/lexer and a matching engine, and return a usable structure.
05:22:18 <Peaker> Athas: Why isn't such "functor" already permitted by ordinary functions?
05:22:52 <Peaker> eu-prleu-peupeu: Someone managed to convinced me that the revision-based approach (ala git) is better than patch-based approach (ala darcs) at least when your patches are heuristic diffs
05:23:00 <Athas> Modules aren't first class values.
05:23:27 <Peaker> Athas: arbitrary limitation, or for good reason?
05:23:34 <Peaker> Athas: I mean, couldn't they be like records of functions?
05:23:36 <ivanm> Peaker: in what way is revision-based > patch-based?
05:23:50 <Athas> Not sure.  I suppose it might complicate static analysis.
05:24:13 <ski> modules also contain types (and classes,instances in haskell)
05:24:22 <eu-prleu-peupeu> i like revision based, i dont use patch base that much, but i have some eager to try it out
05:25:02 <Peaker> ivanm: well, a patch-based system is going to use some heuristic diff function. being heuristic it is flawed and will have false positives and false negatives w.r.t dependencies between patches.  When you discover/implement some better diff in the future, you cannot use it because your entire history is based on the previous diff implementation. Additionally, its less natural to mark sets of patches as "tested" (you test whole revisions, not particular patc
05:25:02 <Peaker> hes).
05:25:04 <eu-prleu-peupeu> as long as it works and its not too intrusive i guess its fine :/
05:25:17 <pejo> Athas, look at Derek Dreyer's research
05:25:31 <Peaker> ivanm: with something like git, each revision represents a whole tree -- you can always find new ways to compare that tree to previous trees with new and improved diff algorithms, without having to upgrade/change the entire history format
05:26:01 <eu-prleu-peupeu> git has linus torvalds on the team, thats a good enough reason for me to keep out :)
05:26:08 <ivanm> Peaker: hmmm...
05:26:14 <Peaker> eu-prleu-peupeu: I dislike him too, but "git" is really a great tool
05:26:43 <opqdonut> yeah
05:26:56 <ivanm> that sounds more like an implementation problem rather than a usage problem
05:26:59 <Athas> pejo: I will look it up, thanks.
05:27:02 <Peaker> ivanm: it does mean that git needs a lot more support code around "rebase" (that's missing right now) in order to make rebase operations and such more usable, though
05:27:05 <ivanm> eu-prleu-peupeu: what's your problem with torvalds?
05:27:25 <ivanm> Peaker: in terms of _usage_, which do you prefer?
05:27:34 <Peaker> ivanm: I've barely used darcs
05:27:41 <ivanm> I've never used any other DVCS other than darcs, so *shrug*
05:27:53 <ivanm> but I find the concept of patches rather intuitive
05:28:08 <ivanm> Peaker: what kind of haskellian are _you_ then? :o
05:28:47 <Peaker> ivanm: I only used darcs to get stuff. I found its command set confusing after I was already used to other dvcs's (which is what happens whenever anyone switches between dvcs's :)
05:29:18 <ivanm> heh, true
05:29:21 <eu-prleu-peupeu> ivanm: based on what i've read, i don't like him :)
05:29:29 * bremner already knows an editor and a dvcs. Not really interested in the "Haskell one's"
05:29:35 <ivanm> eu-prleu-peupeu: in what way?
05:30:09 <bremner> unless the new tools are massively superior, of course
05:30:16 <ivanm> Peaker: I find the darcs command set easier to use/remember than those I've seen of git, hg, etc.
05:30:19 <ski> @djinn Grz (Grz (a -> Grz a) -> a) -> a
05:30:20 <lambdabot> f (a, b) =
05:30:20 <lambdabot>     case b of
05:30:20 <lambdabot>     Nothing -> a (\ c ->
05:30:20 <lambdabot>                   (a (\ _ -> (c, Just (a (\ _ -> (c, Nothing), Nothing))), Nothing),
05:30:20 <lambdabot>                    Nothing),
05:30:20 <Peaker> eu-prleu-peupeu: you can watch the git talk on Google Tech Talk.   Torvalds makes a fool of himself there, IMO
05:30:22 <lambdabot>                   Nothing)
05:30:24 <lambdabot>     Just _ -> a (\ d -> (d, Nothing),
05:30:26 <lambdabot>                  Just (\ e -> (e, Just (a (\ f -> (f, Nothing), Nothing)))))
05:30:30 <eu-prleu-peupeu> ivanm: in a non-sexual way, kind of in a more "project leadership arrogance" way
05:30:32 <vixey> what's Grz!
05:30:37 <ski> hm
05:30:43 <Peaker> ivanm: I think git's command set is horrible and confusing. But I got used to it
05:31:03 <ivanm> Peaker: heh
05:31:08 <Peaker> @src Grz
05:31:08 <ski> vixey : Andrzej Grzegorczyk
05:31:08 <lambdabot> Source not found. Sorry.
05:31:16 <eu-prleu-peupeu> Peaker: yes, thats what i particularly dont like about torvalds, he is always boosting his ego, and, sincerely, he does not seem like an assertive person
05:31:16 <vixey> ohok
05:31:16 <ivanm> eu-prleu-peupeu: in that it's his way or the highway?
05:31:18 <Peaker> ivanm: now that I'm past the learning curve, the command set is OK
05:31:26 <ski>   type Grz a = (a,Maybe a)  -- for testing with djinn
05:32:00 <ski> (i would have tried with non-empty lists or streams, had djinn supported recursion)
05:32:16 <Peaker> eu-prleu-peupeu: Yeah, he said something like "SHA1 is a good hash function. It may be secure, but that's not why we use it in git. Anyone who tells you SHA1 is used in git for security purposes is an idiot".  5 minutes later he explains how SHA1 is a security feature in git
05:32:44 <eu-prleu-peupeu> yeah, what about the mails he sent to the gnome mailing list ? :P
05:32:44 <Gracenotes> surely it could support recursion, just use a different logical model (albeit undecidable)
05:32:47 <Gracenotes> so I've heard
05:32:53 <eu-prleu-peupeu> really ugly
05:33:08 <ivanm> Peaker: maybe he doesn't use it for security, but it does end up being a security measure?
05:33:24 * ski is slightly surprised that djinn managed to prove the proposition with that definition of `Grz' ..
05:33:28 <ivanm> eu-prleu-peupeu: the printing ones?
05:33:34 <ski> (.. now to understand it)
05:33:52 <ivanm> I've often be annoyed with the gnome/gtk+ stuff where gnome devs consider the two to be interchangeable...
05:33:54 <Peaker> ivanm: he does use it for security - he gives an example of a lost repo - and how he can take it from anywhere else knowing that if the SHA1 is right, its definitely unaltered
05:34:11 <vixey> being able to instantiate typeclasses would be cooler than recursion
05:35:34 <eu-prleu-peupeu> here: http://linux.slashdot.org/article.pl?sid=05/12/13/1340215 anyway, torvalds named an "OS" after his name... i guess that says a lot about him :)
05:35:41 <eu-prleu-peupeu> but enough
05:35:44 <eu-prleu-peupeu> this is haskell
05:35:50 <Deewiant> He didn't choose the name FWIW
05:35:51 <eu-prleu-peupeu> haskell is torvalds free
05:35:59 <ivanm> eu-prleu-peupeu: the original name was going to be phreex or something... IIRC, someone else said to call it linux
05:36:08 <vixey> Linux Torvalds
05:36:34 <eu-prleu-peupeu> ivanm: yes, he has his own share of ass-licking minions
05:36:34 <ivanm> vixey: yes, him
05:36:41 <Peaker> anyone knows if    result = (.) ; argument = flip (.)  are in any module anywhere?
05:36:49 <ivanm> eu-prleu-peupeu: the name was chosen _before_ linux was released
05:36:50 <vixey> I think LINUX Is Not UniX
05:36:59 <ivanm> vixey: it isn't
05:37:01 <Peaker> vixey: nice, never heard of that :)
05:37:06 <ivanm> it's a unix-like OS
05:37:07 <eu-prleu-peupeu> yeh, the world should be bsd
05:37:11 <eu-prleu-peupeu> dragonfly bsd :P
05:37:11 <ivanm> but it itself isn't UNIX
05:37:15 <ivanm> eu-prleu-peupeu: why BSD?
05:37:16 <bremner> eu-prleu-peupeu: I think if you let things like that influence your choices, "The terrorists have won".  Now the the ion3 dude, he is lunatic in a way that makes bad software
05:37:35 <ivanm> bremner: heh, true
05:37:39 <eu-prleu-peupeu> bremner: :D
05:37:53 <eu-prleu-peupeu> thats how i came to haskell
05:37:58 <Peaker> bremner: can you come to #-blah?
05:37:59 <eu-prleu-peupeu> i guess the hype is working
05:39:01 * ski should try install lunix sometime
05:39:18 <vixey> HASKELLs A Silly `Krazy' Egragarious Lunatic Language
05:39:22 <eu-prleu-peupeu> now ill just go to the gnome ml and call then "interface nazis" and code my dvcs tool with my ass-licking minions
05:42:25 <ivanm> VIXEY Is Xenophobically Eavesdropping Yellows ?
05:44:35 <eu-prleu-peupeu> GIT Is Torvalds
05:45:40 <cnwdup> Can I create a X11 event using Graphics.X11.Xlib or are those bindings missing? I cannot find them.
05:45:44 <ski> (vixey : `Grz' is a variant system of provability that preserves all theorems of `S4'. that proposition above is the axiom schema specific to it ..)
05:46:05 <ski> (s/provability/provability logic/)
05:46:29 <eu-prleu-peupeu> lets build a haskell tool that does something similar to java processing or c++ openframeworks :)
05:46:36 <CalJohn_> Is there a description of a dlist anywhere that is suitable for a beginner?
05:46:48 <ivanm> CalJohn_: RWH has a bit on it
05:46:53 <ivanm> eu-prleu-peupeu: _why_?
05:47:55 <eu-prleu-peupeu> ivanm: beacuse its cool :) haskell doesn't have anything like that (at least that i know of), and it would showcase haskell as a programming language for artists, designers and the like
05:48:21 <ivanm> what are you referrying to by "java processing" and "c++ openframeworks"?
05:48:22 <Peaker> this iteratee is not very nice: Hmm: http://hackage.haskell.org/packages/archive/iteratee/0.1.0/doc/html/Data-Iteratee-Base.html
05:48:41 <ivanm> also, why would artists and designers program?
05:48:47 <ivanm> surely that's not part of their job description...
05:48:57 <Peaker> ivanm: they already do first-order programming with tools like photoshop
05:49:07 <eu-prleu-peupeu> ivanm: programming should be accessible to everyone
05:49:18 <eu-prleu-peupeu> i feel thats part of my life purpose as an "evangelist"
05:49:20 <ivanm> Peaker: true
05:49:23 <Peaker> ivanm: applying parametric functions, but never creating them.  surely artists can benefit from creating such functions as well as applying them
05:49:26 <vixey> I bet the artists at pixar do lots of programming
05:49:52 <eu-prleu-peupeu> haskell could be the "lingua franca" of artistic programming
05:49:55 <ivanm> eu-prleu-peupeu: silly me, here I was thinking that all the evangelists died about 2000 years ago...
05:49:59 <nornagon> vixey: on the contrary, i bet their programmers do a lot of art
05:50:13 * ivanm agrees with nornagon 
05:50:22 <ivanm> eu-prleu-peupeu: you still haven't said what java processing means...
05:50:29 <eu-prleu-peupeu>  ?
05:50:31 <ivanm> I thought you were referring to something that processed java...
05:50:33 <nornagon> ivanm: it's a language built on top of java
05:50:35 <eu-prleu-peupeu> no
05:50:41 <nornagon> @go processing java
05:50:43 <lambdabot> http://processing.org/reference/compare/java.html
05:50:43 <lambdabot> Title: Compare \ Processing 1.0
05:50:44 <ivanm> <eu-prleu-peupeu> lets build a haskell tool that does something similar to java processing or c++ openframeworks :)
05:50:48 <ivanm> nornagon: oh
05:50:52 <CalJohn_> i don't think programming can be accessible to everyone, in the same way that undergraduate mathematics is not accessible to everyone
05:50:52 <eu-prleu-peupeu> check it out: http://www.processing.org/
05:51:17 <nornagon> CalJohn_: automation can be accessible to everyone
05:51:21 <ivanm> eu-prleu-peupeu: so you want an art-based EDSL?
05:51:25 <nornagon> so it depends how you define 'programming'
05:51:30 <eu-prleu-peupeu> ivanm: yeh, sort of
05:51:38 <ivanm> haven't we got some libs towards that already?
05:52:03 <eu-prleu-peupeu> yes, its just a matter of mixing them together in a monad  :)
05:52:06 <ivanm> though IIRC, all "every-man"-style languages have failed miserably
05:52:21 <ivanm> or been extremely awful languages
05:52:22 <ivanm> *cough* COBOL *cough*
05:52:26 <eu-prleu-peupeu> :D
05:52:28 <ivanm> eu-prleu-peupeu: why a monad?
05:52:36 <CalJohn_> nornagon: i'm don't understand what you mean by "automation can be accessible to everyone".  Isn't that obvious?
05:52:43 <ivanm> *cough* MUMPS *cough*
05:53:06 <ivanm> CalJohn_: because things like choosing options in gimp, etc. are really automation options
05:53:08 <ivanm> not programming
05:53:13 <nornagon> well
05:53:29 <nornagon> people who don't know how to program frequently perform repetitive tasks
05:53:35 <CalJohn_> well obviously, but gimps UI is not turing complete
05:53:42 <nornagon> which could be easily replaced with programs
05:53:46 <CalJohn_> programming is about using turing completeness
05:54:03 <eu-prleu-peupeu> ivanm: okey, an applicative functor will do
05:54:26 <ivanm> it's more "scripting" than "programming"
05:54:48 <vixey> no it's not CalJohn
05:55:01 <nornagon> so like i said, depends how you define programming
05:55:06 <vixey> 'turing complete' it completely irrelevant to programming
05:55:24 <CalJohn_> nornagon: well clearly, if you define "programming" in an extremely broad way, then lots of people do it
05:55:35 <eu-prleu-peupeu> there are some cool things in processing
05:55:40 <CalJohn_> but you are defining it so widely that it no longer makes sense
05:56:24 <ivanm> "turing completeness" is used to describe the _languages_
05:56:28 <ivanm> not how.what we program
05:56:49 <ivanm> s+.+/+
05:57:03 <eu-prleu-peupeu> turing was gay
05:57:15 <Gracenotes> eu-prleu-peupeu: :( sad story.
05:57:19 <ivanm> eu-prleu-peupeu: your point?
05:57:37 <eu-prleu-peupeu> he killed himself because of that
05:57:41 <ivanm> how is homosexuality related to turing completeness?
05:57:46 <CalJohn_> ivanm: and you don't think that languages are closely related to "how we program"
05:57:52 <Peaker> he killed himself because of the British persecution
05:57:56 <eu-prleu-peupeu> and some hormones they gave him
05:57:59 <ivanm> eu-prleu-peupeu: no, IIRC he committed suicide due to a lack of people's acceptance of his sexual orientation
05:58:06 <ivanm> not because of his sexual orientation per se
05:58:14 <Gracenotes> :(
05:58:28 <ivanm> CalJohn_: you can program in non-turing-complete languages
05:58:30 <codebliss> Woohoo Gracenotes is on!  My life is complete! =P
05:58:36 <Gracenotes> perhaps CS would be further along today. who knows.
05:58:36 <ivanm> e.g. EDSL's
05:58:47 <ivanm> codebliss: O...K... then...
05:58:49 <jethr0> during the war he was a hero for helping to break the enigma codes. But after the war he was again persecuted for his sexual orientation.
05:58:55 <ivanm> Gracenotes: maybe
05:58:58 <Gracenotes> ï¼ˆã€€Â´_ã‚`ï¼‰ . . o o O O ( :O )
05:59:07 <ivanm> jethr0: yes... but still, why bring this up?
05:59:12 <jethr0> i didn't
05:59:15 <codebliss> ivanm: You're just jealous of what we don't have.
05:59:25 <jethr0> it was an ad hominem argument by eu-prleu-...
05:59:32 <score> stop troll
05:59:36 <jethr0> or a trivia ;)
05:59:39 <ivanm> jethr0: ahhh
05:59:50 <Gracenotes> word association!
05:59:56 <Gracenotes> Turing .. gay .. etc.
05:59:56 <CalJohn_> Gracenotes: i doubt it, he was starting to change field by the time he died
06:00:06 <ivanm> CalJohn_: oh? what to?
06:00:25 <Gracenotes> CalJohn_: hm. Still, most of what he did was under wraps, since it was in a highly military context.
06:00:29 * ivanm wonders what it would be like if we weren't all using von Neumann machines...
06:00:31 <Gracenotes> cryptography in general was
06:00:40 <ivanm> Gracenotes: s/was/is/
06:00:47 <Gracenotes> heh. true.
06:00:56 <ivanm> RSA didn't invent RSA!
06:00:57 <CalJohn_> ivanm: mathematical biology, according to wp
06:01:04 <ivanm> CalJohn_: wordpress?
06:01:09 <CalJohn_> wikipedia
06:01:09 <Gracenotes> still, it's not like your government has to keep algorithms a secret for 20 years
06:01:10 <ivanm> ;-)
06:01:15 <ivanm> yeah, I know what you meant
06:01:26 <vixey> we have full specs of the enigma machine nowadays.. :p
06:01:26 <ivanm> Gracenotes: sure they do
06:01:29 <Gracenotes> unless 'algorithms' means breaking algorithms
06:01:34 <CalJohn_> vixey: so did he
06:01:40 <ivanm> they dont' want _everyone_ to know the algorithm for immortality! :p
06:01:45 <vixey> Didn't know that CalJohn
06:02:01 <ivanm> vixey: he had sample machines
06:02:03 <CalJohn_> vixey: he did, enigmas were used prewar, just in a different capacity
06:02:06 <ivanm> which helped him work out flaws in the system
06:02:13 <ivanm> CalJohn_: they made advances though
06:02:18 <ivanm> especially the subs IIRC
06:02:39 <ivanm> @seen sjanssen
06:02:39 <lambdabot> sjanssen is in #haskell-in-depth, #haskell-overflow, #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 1h 46m 27s ago.
06:03:22 <CalJohn_> ivanm: they weren't much different, frankly
06:03:31 <ivanm> CalJohn_: the underlying design, no
06:03:47 <jethr0> enigma machines also changed during the war. if i remember correctly there was a big roll-out of new much harder to break enigmas going to happen in '44/'45
06:03:54 <CalJohn_> i was at bletchley park about 3 days ago, they look almost identical
06:04:09 <CalJohn_> jethr0: i think you're refering to the kriegsmarine ones
06:04:23 <jethr0> could be, i just vaguely remember sth of the kind
06:04:32 <ivanm> sjanssen: I take it you use Measured in FingerTrees to do the equivalent of "sortBy (compare `on` snd) . map (\x -> (x, length x))" ?
06:04:44 <ivanm> CalJohn_: yes, the sub ones
06:05:00 <mmorrow> now our enigma machines are elliptic curves and finite fields
06:05:01 <CalJohn_> ivanm: oh, i see what you meant
06:05:21 <CalJohn_> ivanm: well, the kriegsmarine ones are basically an extra rotor and no plugboard
06:05:34 <ivanm> IIRC, he cracked enigma (except for some later kreigsmarine stuff) by personality engineering, i.e. finding duplicates due to laziness/inefficiency of the users
06:05:40 <ivanm> CalJohn_: *nod*
06:05:51 <CalJohn_> ivanm: have you been to the museum?
06:05:53 <ivanm> mmorrow: IIRC, elliptic curves have flaws...
06:05:55 <mmorrow> it's amazing how much has changed over the last century
06:05:58 <ivanm> according to schneier, anyway
06:06:04 <ivanm> CalJohn_: wrong country ;-)
06:06:09 <mmorrow> even more so the last 20 years
06:06:22 <ivanm> I'll probably go if funding pans out to go study in the UK though
06:06:23 <CalJohn_> ivanm: it's a little sad because it's so obviously lacking funding, but they've got a replica colossus and lots of machines
06:06:53 <ivanm> CalJohn_: I've seen wadler's blog posts to that effect
06:06:58 <CalJohn_> ivanm: where are you now, if you don't mind me asking?
06:07:11 <ivanm> CalJohn_: do a "/whois ivanm" and try and work it out ;-)
06:07:34 <ivanm> IIRC, the UK govenrment trashed colossus due to security reasons and because they figured it wasn't worth much anymore...
06:07:44 <ivanm> and then got the colonies to use enigma because of how "secure" it was :@
06:08:20 <ivanm> CalJohn_: I take it you've signed this? http://petitions.number10.gov.uk/BletchleyPark/
06:09:03 <CalJohn_> ivanm: i haven't, because I don't agree with that kind of government intervention, but that's another story
06:09:17 <ivanm> is Int a monoid? lambdabot doesn't say so... >_>
06:09:25 <ivanm> CalJohn_: you think it should be a private thing?
06:09:31 <CalJohn_> basically
06:09:33 <ivanm> I thought bletchley park was government owned :s
06:09:43 <ski> @hoogle Product
06:09:44 <lambdabot> Data.Monoid newtype Product a
06:09:44 <lambdabot> Data.Monoid Product :: a -> Product a
06:09:44 <lambdabot> Prelude product :: Num a => [a] -> a
06:09:46 <ski> @hoogle Sum
06:09:47 <lambdabot> Data.Monoid newtype Sum a
06:09:47 <lambdabot> Data.Monoid Sum :: a -> Sum a
06:09:47 <lambdabot> Prelude sum :: Num a => [a] -> a
06:10:49 <ivanm> ski: oh, Sum is a newtype of Int or something?
06:10:52 <ivanm> @src Sum
06:10:52 <lambdabot> Source not found. Just try something else.
06:10:58 <ivanm> s/Int/Num/
06:10:58 <Pellwurst> hey there.... i have got a [FilePath] and i'd like to remove all directories from that list....can i somehow use the filter-function for that?
06:11:04 <ski>   newtype Sum a = Sum a  -- i'd wager
06:11:18 <ivanm> Pellwurst: IIRC, there's an IO function for telling if something is a directory
06:11:29 <vixey> :t Sum
06:11:30 <ivanm> so you'll have to use filterM...
06:11:30 <lambdabot> forall a. a -> Sum a
06:11:39 <ivanm> ski: *nod*
06:11:41 <CalJohn_> ivanm: no, colossus was for cracking lorenz ciphers (the "german high command" ones).  i don't know why they did this, but i think it was relevant to the fact that russia had no good crypto in 1945, and picked up lorenz for their own use after the war
06:11:45 <ivanm> vixey: heh
06:11:49 <Pellwurst> k, i'll try that, thx
06:12:00 <Peaker> Hmm -- I created an alternative to Iteratee.  feedback welcome: git://github.com/Peaker/mlist.git  OR  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4228#a4228
06:12:08 <ivanm> CalJohn_: *nod*
06:12:11 <CalJohn_> anything to get at the russians
06:12:15 <ivanm> though note that it's s/Russia/USSR/g
06:12:18 <Peaker> The use example and the actual code are a little mixed up in there..
06:12:23 <ivanm> and s/russians/soviets/
06:12:31 <ivanm> CalJohn_: note that USSR /= Russia
06:12:37 <CalJohn_> right you are
06:12:44 <ivanm> in practice, it was equivalent to a new russian empire
06:12:48 <ivanm> :(
06:12:52 <ivanm> but that's beside the point
06:14:59 <CalJohn_> if we invaded germany for attacking poland, we should have at least invaded russia too. Anglosaxon invasions tend to be inconsistant (iraq over zimbambwe, etc)
06:15:47 <CalJohn_> i think that's far enough off topic for this channel for me to shut upo
06:16:27 <ivanm> CalJohn_: the Soviet Union wasn't invaded because: 1) Germany was seen as a bigger enemy/lesser ally than the USSR at the time, 2) afterwards, people were sick of war; 3) later on, the USSR + warsaw pact was seen as too big/deadly to tangle with directly (hence the cold war)
06:17:19 <ivanm> IIRC, slovakia also invaded poland at the same time...
06:23:07 <ecst> is there a complete introduction/reference to haskell with no syntactic sugar added?
06:23:40 <ecst> this sugar kind of keeps deterring me from recognizing the pure concepts
06:23:50 <ivanm> ecst: ummm... what's the point of a language without syntactic sugar?
06:24:02 <ecst> easier to understand?
06:24:02 <ivanm> or are you referring to cutesy "sub"-languages?
06:24:33 <ivanm> ecst: I like to think that something like [a,b,c] is a valid and easy-to-use syntactic sugar for a:b:c:[] when considering lists
06:24:58 <ecst> for practical programming practise, it is indeed nice to have such abbreviations
06:25:22 <ecst> but i tend to think when learning the language, one should start without the sugar and only add it when all core concepts have been understood
06:26:34 <ivanm> ecst: there isn't much sugar in haskell...
06:26:38 <ivanm> that list stuff is about it
06:26:48 <ivanm> and it's very useful, when doing stuff over lists
06:27:06 <ivanm> you _could_ pattern match on a:[], but doing it on [a] is nicer/easier to understand
06:27:20 * ivanm can't think of any other syntactic sugar in haskell
06:28:07 <ecst> infix operators? special notation mor monads? list comprehension?
06:28:08 <ski> `if'-`then'-`else'
06:28:08 <wh1t3_> [1..]
06:28:11 <ski> `do'
06:28:19 <ivanm> ski: ahh, yeah, do is
06:28:34 <ivanm> but how else would you do if-then-else? a case statement or something?
06:28:52 <ivanm> and yeah, list comprehension is also syntactic sugar
06:28:56 <wh1t3_> guards are translated into case as well i think
06:29:02 <ivanm> note that I usually don't use these, which is why I didn't think of them
06:29:17 <ivanm> wh1t3_: yes, but that's more of a compiler transformation rather than a sugar thing IMHO
06:29:17 <ski> > case compare `join` (1/0) == GT of True -> "yes" ; False -> "aye"
06:29:19 <lambdabot>   "aye"
06:29:43 <ivanm> as for infix functions (operators are _always_ infix...)...
06:29:50 <ivanm> can you consider `...` to be a function?
06:30:15 <ivanm> @type join
06:30:16 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:30:36 <wh1t3_> arent all syntactic sugar things compiler transofrmations?
06:30:53 <ivanm> ski: what does " compare `join` (1/0) " do? 1/0 should die, shouldn't it?
06:30:58 <vixey> wh1t3, aren't they?
06:31:01 <ivanm> wh1t3: true
06:31:09 <ski> ivanm : actually, i meant to do
06:31:10 <ivanm> but can't you also have preprocessor stuff?
06:31:12 <ski> > case compare `join` (0/0) == GT of True -> "yes" ; False -> "aye"
06:31:14 <ski> instead
06:31:19 <lambdabot>   "yes"
06:31:25 <ivanm> ski: shouldn't that also chuck an error?
06:31:33 <ivanm> > 0/0
06:31:34 <lambdabot>   NaN
06:31:49 <ski> god bless floating point arithmetic for don't erroring out on us
06:31:50 <ivanm> @type join compare
06:31:52 <lambdabot> forall a. (Ord a) => a -> Ordering
06:31:57 <ivanm> ski: heh
06:32:16 <ivanm> oh, it should return Eq, right?
06:32:20 <ivanm> > compare `join` 1
06:32:21 <ecst> the thing is, i would like to learn the language from a purely mathematical perspective
06:32:22 <lambdabot>   EQ
06:32:33 <ivanm> ecst: there's Haskell Road
06:32:38 <ski> > nan == nan  where  nan = 0 / 0
06:32:38 <ecst> and i have trouble differencing syntactic sugar constructs from "real" constructs
06:32:40 <lambdabot>   False
06:32:50 <ivanm> ecst: fundamentally, what's the difference?
06:33:06 <ivanm> realistically, the amount of sugar in Haskell is still rather low IMHO
06:33:13 <ivanm> ski: *nod*
06:33:16 <ivanm> > 1/0
06:33:17 <lambdabot>   Infinity
06:33:22 <ecst> syntacic sugar constructs can be expressed differently (without the construct)
06:33:26 <EvilTerran> > -1 / 0
06:33:27 <ivanm> ahhh, I thought /0 resulted in an error
06:33:27 <lambdabot>   -Infinity
06:33:28 <vixey> ecst: you know how sometimes you axiomatize a theory and you have some redundant axioms
06:33:30 <ecst> "real" (semantic) constructs not
06:33:39 <ski> > 15 `div` 0
06:33:40 <lambdabot>   * Exception: divide by zero
06:33:48 <ivanm> ski: ahh, floating point stuff indeed
06:33:48 <ecst> yeah, but usually you haven:t
06:33:52 <EvilTerran> > 1/0 :: Int
06:33:53 <lambdabot>       No instance for (Fractional Int)
06:33:54 <lambdabot>        arising from a use of `/' at <i...
06:33:54 <vixey> ecst: sometimes there could be multiple 'minimal' theories
06:34:01 <EvilTerran> oh yeah :P
06:34:08 <ecst> 1
06:34:10 <ivanm> ecst: I can't think of a single text that _doesn't_ introduce/use at the very least if-then-else
06:34:21 <ivanm> or `...` to make functions infix
06:34:39 <vixey> ecst: (this would be true of haskell I think)
06:34:46 <ivanm> newer ones usually include do-blocks if they're complete intros to the language
06:35:02 <ski> @type 1
06:35:03 <lambdabot> forall t. (Num t) => t
06:35:04 <ivanm> list-sugar is also usually introduced
06:35:18 <vixey> ecst: the most important primitives wrt. basic typechecking would be: lambda, application, variables, let and case
06:35:39 <ivanm> vixey: since where is sugar for let?
06:35:56 <ski> (vixey : .. and data constructors)
06:35:57 <ivanm> (with preference given to let over where due to do-block usage of let)
06:36:02 <ivanm> and classes
06:36:09 <vixey> ski, I think you can just pretend they are variables
06:36:19 <ski> not for `case'
06:36:34 <Pellwurst> is it possible to concat monad lists
06:36:36 <Pellwurst> ?
06:36:38 <ivanm> ski: or pattern matching in general?
06:36:38 <ski> (but i suppose one can do it in expressions ..)
06:36:39 <vixey> oh yeah that is true
06:36:47 <EvilTerran> ?type liftM2 (++)
06:36:48 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
06:36:57 <vixey> Pullwurst: if I knew what 'monad lists' were..
06:36:57 <ivanm> @hoogle (Monad m) => [m [a]] -> m [a]
06:36:58 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
06:36:58 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:36:58 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:37:14 <ivanm> Pellwurst: what are you referring to as monad lists?
06:37:20 <ivanm> [m a]? m [a] ?
06:37:34 <ski> @type mapM concat . sequence
06:37:35 <lambdabot> forall a. [[[a]]] -> [[a]]
06:37:40 <ivanm> list of monads, or a monad containing a list?
06:37:48 <ivanm> or a monad contanining a list of monads? :p
06:37:50 <ski> um
06:37:51 <Pellwurst> ivanm: e.g. [[IO String]] -> [IO String]
06:37:53 <ski> @type liftM concat . sequence
06:37:55 <lambdabot> forall a (m :: * -> *). (Monad m) => [m [a]] -> m [a]
06:37:58 <ivanm> Pellwurst: oh, that's just concat
06:38:07 <ivanm> who care's that there's monads in the sub-lists
06:38:18 <ski> s/monads/monadic actions/
06:38:24 <Pellwurst> hmm
06:38:27 <vixey> Pellwurst: yes just use the normal concat function
06:38:49 <ecst> the ghc compiler, for example, seems to desugar haskell into its own core language with only 8 constructors
06:38:56 <ecst> maybe i should start with this core language
06:38:56 <vixey> ecst: check out EHC
06:39:08 <vixey> ecst I'll link something in asec
06:39:18 <Pellwurst> it is too easy sometimes :)
06:39:27 <vixey> ecst: http://www.cs.uu.nl/wiki/bin/view/Ehc/Examples
06:39:38 <ivanm> Pellwurst: heh
06:39:48 <ski> (a type taking a monad transformer list and giving their composition might be interesting)
06:42:42 <cnwdup> dcoutts, are you there?
06:48:15 <ecst> seems like i will end up reading the language report: In this Report, the meaning of such syntactic sugar is given by translation into simpler constructs. If these translations are applied exhaustively, the result is a program written in a small subset of Haskell that we call the Haskell kernel.
06:49:14 <edwardk> hrmm. is there an easy way to ask GHC for something like a Language.Core.Syntax.Module without round tripping through a file?
06:49:44 <ivanm> edwardk: in what sense?
06:49:48 <Gracenotes> > 0.0
06:49:49 <lambdabot>   0.0
06:49:58 <gwern> a what? you want to dump the core for a module?
06:50:26 <edwardk> gwern: basically i want to compile up to core and stop
06:50:38 <ivanm> edwardk: yeah, there's a dump core option IIRC
06:50:40 <gwern> isn't there a --ddump-core option or something?
06:50:46 <ivanm> also see ghc-core
06:50:48 <edwardk> gwern: that would be basically a file =)
06:51:07 <ivanm> edwardk: oh? so what _do_ you want then?
06:51:07 * gwern doesn't see what's so bad about that
06:51:17 <gwern> also, what if it goes through stdin/stdout eh
06:51:24 <EvilTerran> could do something with, er, named pipes or something, to get around it?
06:51:30 <edwardk> what i'm looking for is a way using ghc as a library to ask ghc to generate a core ADT and give it to me
06:51:37 <ivanm> ahhhh
06:51:41 <edwardk> EvilTerran: i could be its intrinsically hacky
06:51:43 <edwardk> er but
06:51:44 * ivanm doesn't know about that
06:52:12 <edwardk> evilterran: that seems to be the route that LHC is going down
06:52:20 <edwardk> a least generate external core and then read the file
06:52:58 <gwern> a core adt... wonder if the ghc api can do that
06:53:38 <gwern> (hm, probably not. I don't remember seeing it back when I was looking at the api code; and hint doesn't have anything)
06:53:50 <edwardk> hrmm http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/GHC.html#v%3AcompileToCoreModule
06:57:17 <ski> > grzegorczyk [\(f:_) -> f 5 !! 2,const 42,\(_:f:_) -> f 3 !! 1]
06:57:19 <lambdabot>   3
06:58:19 <EvilTerran> ?type grzegorczyk
06:58:20 <lambdabot> forall a. [[a -> [a]] -> a] -> a
06:58:29 <EvilTerran> o.O
06:59:01 <EvilTerran> looks reminiscent of loeb
06:59:31 <ski> maybe it is
07:00:21 * beelsebob ponders if there's a compileAndRunCoreDyn somewhere
07:00:51 <EvilTerran> loeb :: Functor a => a (a x -> x) -> a x
07:01:07 <EvilTerran> not quite the same
07:04:34 <ski> it is an axiom in the system `Grz' .. i'm wondering if there's any sensible computational meaning one could attach to it
07:06:42 <vixey> this  [] ([] (a -> [] a) -> a) -> a  ?
07:06:47 <vixey> or it's actually _list_?
07:06:58 <ski> it's meant to be a stream, there
07:07:04 <vixey> ok
07:07:41 <ski> (but in the original, it's neither .. but there should be a theorem `[] a -> a', so i was thinking streams might work to test with)
07:08:53 <ski> @type grzegorczyk . (repeat const @@)
07:08:54 <lambdabot> forall a. [a] -> a
07:09:13 <vixey> :t (@@)
07:09:15 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
07:09:29 <EvilTerran> zipWith ($)? liftM2 ($)?
07:09:36 <ski>   (@@) = zipWith ($)
07:09:37 <vixey> > grzegorczyk . (repeat const @@) $ []
07:09:38 <lambdabot>   * Exception: <local>:6:71-179: Irrefutable pattern failed for pattern (as@(...
07:09:44 <vixey> > grzegorczyk . (repeat const @@) $ [()]
07:09:45 <ski> (since it's streams)
07:09:46 <lambdabot>   ()
07:09:49 <vixey> > grzegorczyk . (repeat const @@) $ [1,2]
07:09:50 <lambdabot>   1
07:11:04 <EvilTerran> ski, would copointed functors in general work, perhaps?
07:11:51 <EvilTerran> ("copointed" to get you the "[] a -> a" part)
07:12:38 <ski> well, `[]' should probably be a comonad, here
07:12:50 <ski> since we should have `[] a -> [] [] a', too
07:13:11 <ski> the proof of that in terms of `grzegorczyk' is more complicated, though ..
07:18:46 <ski> "Then by the propositional calculus, we have `K |- ((([] A -> [] [] A) /\ A) -> [] A) -> (A -> [] A)'" .. i don't see this :/
07:19:09 <ManateeLazyCat> Hi, all. I got problem with "mutually recursive modules".  I have two modules: `Window.hs` and `WindowsList.hs`, them import each other. So i write "import {-# SOURCE #-} WindowsList" in file `Window.hs`, and i have define file `WindowsList.hs-boot`. How to use GHC compile and link those modules? Thanks!
07:20:09 <koda> hi
07:20:31 <koda> is it possible to build universal apps in Mac OS X?
07:21:50 <Raevel> yes
07:22:05 <pejo> You're not going to get both PPC and x86-code out of the same GHC. Not sure if you can combine two different binaries with some other tools.
07:22:10 <Raevel> i think i answered another question
07:22:22 <score> ManateeLazyCat: probably good practice to break them down so they don't interdepend
07:22:39 <koda> i can combine two different archs into one universal program
07:22:48 <koda> but how to generate ppc code from a x86 haskell?
07:23:37 <ManateeLazyCat> score: But it's unavoidable in big project. Have too many modules....
07:24:32 <beelsebob> koda: you don't â€“ you install a PPC ghc too
07:24:37 <pejo> koda, you don't, you have to have two versions of GHC installed, or possibly build on two machines of different arch.
07:24:49 <beelsebob> having said that koda â€“ honestly, you care about PPC users still?
07:25:06 <beelsebob> the newest PPC in existance will be 3 years old, and massively slower than any intel mac
07:25:12 <burp_> oh
07:25:22 <burp_> ppc is still used widely
07:25:38 <ManateeLazyCat> score: I think problem not interdepend, i think GHC should fix this problem slef, and not take it to programmer.... Then programmer's life will more easier, now looks need programmer write ".hs-boot" self, and it's painful when in big and complex project.
07:25:43 <koda> well it's a small program so it can run on tiger too
07:25:54 <koda> and there are many ppc tigers out there
07:26:23 <beelsebob> burp_: NetApps stopped tracking PPC macs about 6 months ago, because their market share slipped under 0.25%
07:27:36 <p_l> There's more to PPC than Macs
07:27:44 <burp_> well I still use one ;)
07:28:02 <beelsebob> yes, but given that he's trying to produce universal binaries for MacOS, PPC Macs are what we're talking about p_l
07:28:18 <p_l> beelsebob: yeah, just noticed. Sorry for jumping in :)
07:28:40 <burp_> just build it for ppc and intel seperately
07:28:44 <burp_> I'd suggest
07:29:32 <koda> ok
07:29:43 <koda> but is it possible to have two ghc on the same machine?
07:29:56 <koda> one for x86 and the other for ppc?
07:30:14 <beelsebob> it is
07:35:48 <koda> hmm how about build ghc as universal application...
07:36:00 <koda> and then call the proper arch with the -arch flag?
07:36:28 <koda> (as here http://developer.apple.com/DOCUMENTATION/MacOSX/Conceptual/universal_binary/universal_binary_exec_a/universal_binary_exec_a.html#//apple_ref/doc/uid/TP40002217-CH210-240453 )
07:46:32 <koda> ok thanks for the info
07:46:34 <koda> bye
07:46:57 * Gracenotes watches Spirited Away..
07:53:15 <voker57_> how to convert String to ByteString?
07:53:38 <voker57_> nm
07:53:47 <EvilTerran> pack?
07:54:01 <voker57_> doesn't work. Have to encode it first
07:54:11 <EvilTerran> ?hoogle String -> ByteString
07:54:11 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
07:54:11 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
07:54:11 <lambdabot> Prelude read :: Read a => String -> a
07:54:43 <EvilTerran> if you're using ByteStrings to represent text, not binary data, it's easier to use the .Char8 variant
07:55:20 <damkor> I'm trying to compile something with ghc for ARM, the program uses gtk. When statically linked, the program compiles (and runs) ok, if I try to compile with "-dynamic", then I get "/usr/bin/ld: cannot find -lHSgtk-ghc6.8.2". Any clues?
07:55:25 <voker57_> aha, thanks
07:55:33 <Saizan_> and if you need an encoding that's not latin1 you can use the "text" package on hackage
07:55:41 <SamB> argh...
07:56:04 <Gracenotes> > BSC.pack "hello"
07:56:05 <lambdabot>   /tmp/442267156312150532:70:32: Not in scope: `BSC.pack'
07:56:09 <Gracenotes> :l
07:56:46 <Gracenotes> :t BSC.pack "hello"
07:56:47 <lambdabot> BSC.ByteString
07:57:05 <Gracenotes> [Â¬Âº-Â°]Â¬
07:57:28 * SamB doesn't like the response he recieved to debian bug 520680
07:57:55 <SamB> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=520680
07:58:03 <Zao> "you're silly, go away"?
07:59:09 <cnwdup> A user types via a handy keyboard. Thus a pressed button may mean a, b or c. I want to maintain a word list and match against that as the user types. I thus have to quickly reduce the word list for a growing list of possible words typed and I have to sort the list quickly.
07:59:15 <cnwdup> What would be a good data type for that?
07:59:32 <Zao> Some kind of trie?
08:00:08 <cnwdup> Is there already a haskell implementation of trees or do I have to write my own?
08:00:31 <kadoban> trie != tree
08:00:38 <cnwdup> Oh. What's a trie?
08:01:02 <cnwdup> Okay. Found a wiki article. Thanks. (:
08:01:04 <kadoban> also known as a "prefix tree" i believe.  google should have the basics
08:01:28 <vixey> data Trie a = Cons a [Trie a] | Nil
08:01:29 <SamB> Zao: more like "there are bigger -dbg packages, and we can't bother ourselves to increase the number of packages in the archive just to save you a few tens of megabytes of hard drive space! mwahahahahaha!"
08:01:31 <vixey> is that it?
08:02:08 <Botje> more like Trie a = Trie [(a, Trie a)]
08:02:16 <Botje> | Nil, i guess
08:02:40 <iago> someone could help me with a type-check problem ?
08:02:46 <vixey> Botje, doh, thanks
08:02:48 <roconnor> Trie [] good enough for Nil?
08:02:52 <SamB> Zao: and note that the package in question is libc6-dbg
08:02:52 <Botje> if you want to check whole words instead of prefixes you need an additional flag for "End node"
08:02:54 <EvilTerran> Botje, well, Nil would be redundant in that form, seeing as Trie [] would do
08:02:58 <Zao> SamB: The next logical step is obviously to merge all architectures into a single package for binaries too.
08:03:07 <vixey> how about newtype Trie = Trie (a -> [Trie a])
08:03:11 <edwardk> @seen Lemmih
08:03:12 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 1d 5h 3m 45s ago.
08:03:12 <SamB> Zao: so you read that?
08:03:48 <EvilTerran> data Trie k v = Trie (Maybe v) (Map k (Trie k v)) -- is what i think of when i hear "trie"
08:04:03 <Zao> I do not agree that "getting rid of things I will never ever have any use for on this platform" to be "no real gain"
08:04:31 <iago> is it possible to typecheck a recursive definition only knowing the types of the variables bound by lambda abstractions?
08:04:31 <Botje> a Map seems excessive
08:04:42 <vixey> iago, Yeah I think so
08:04:42 <iago> without type inference
08:04:48 <vixey> iago, eh??
08:04:52 <Botje> a B-tree of some sorts would be neat, though
08:05:02 <iago> vixey, I'm not talking about Haskell
08:05:13 <vixey> iago: "without type inference"
08:05:28 <Gracenotes> EvilTerran: why the Maybe v? :o
08:05:50 <Gracenotes> for epsilon?
08:06:29 <EvilTerran> Gracenotes, it makes it analogous to a Map [k] v
08:06:44 <Cale> cnwdup: I would just use Data.Set to start with.
08:06:56 <Gracenotes> hm... I suppose...
08:07:09 <Cale> cnwdup: and if that didn't give enough performance, then there are implementations of Tries and such on hackage.
08:07:27 <vixey> http://en.wikipedia.org/wiki/Trie#Algorithms
08:07:55 <edwardk> evilterran: i basically just use a ternary search tree to represent a trie when i can
08:08:18 <iago> vixey, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2213
08:08:20 <cnwdup> Cale, I think a Set will be too inefficient.
08:08:22 <cnwdup> vixey, thanks.
08:08:23 <iago> for example
08:08:25 <Cale> cnwdup: Why?
08:08:35 <vixey> iago: I don't know what you mean by 'without type inference'
08:08:36 <iago> but the type system doesn't support type inference with unification
08:08:41 <Cale> cnwdup: How many lookups/updates are you going to be doing per second?
08:08:42 <iago> that you can unify types
08:08:46 <iago> can't
08:08:50 <cnwdup> Cale, because I cannot efficiently filter. filter on a Data.Set is like on a list.
08:08:51 * EvilTerran notes that, with a Data.Set, you could use "\char -> fst . Set.split [succ char] . snd . Set.split [char]" to get all strings in the set starting with a given character
08:08:54 <vixey> iago: what are the type rulesL
08:08:55 <vixey> ?
08:09:13 <vixey> iago: You know unification isn't part of haskell type rules -- it's just an algorithm we use to implement the rules
08:09:16 <EvilTerran> in O(log n)
08:09:42 <edwardk> evilterran: data Tern k a = Tern !Int !k !(Maybe a) !(Tern k a) !(Tern k a) !(Tern k a) | Tip; data Trie k a = !(Maybe a) :> !(Tern k a) -- same general idea as the recursive map but you can weight the map using the 'mass' of the subtree rather than locally
08:09:58 <iago> vixey, well, unification is the way to solve type restrictions
08:10:00 <Cale> cnwdup: how often are you filtering and how large is the Set?
08:10:01 <iago> :?
08:10:51 <cnwdup> Cale, I filter once per entered character. I have about 10000 words to start with. The first sort would be the one most cpu demanding.
08:11:28 <Cale> Oh, then I don't think efficiency will be a problem.
08:11:49 <cnwdup> Cale, okay
08:11:59 <cnwdup> Then I start with a Set first. (:
08:12:03 <eu-prleu-peupeu> im finishing studying the xmonad architecture
08:12:17 <eu-prleu-peupeu> what other cool architectures in haskell are there to study ?
08:12:36 <Cale> cnwdup: What's the filter predicate like?
08:12:53 <iago> vixey, type rules are like that http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2213#a2215
08:12:59 <iago> without restrictions
08:13:01 <cnwdup> Cale, its isPrefixOf for each possible meaning of the word being written.
08:13:50 <cnwdup> Cale, since each button holds about 3 characters the ambiguity can produce many possible words which could be a problem to consider as well.
08:13:55 <vixey> iago: so you might check that  [] Z  is well typed (and a side effect would be you learn that it has type 'X' say),
08:14:09 <vixey> iago, then you might check  (cons Z (f(head X l)) (map (tail X l)))  is well typed (and learn it's got type Y)
08:14:41 <vixey> iago, at this point, you would unify X and Y -- not because any type rule says so, but because unification is sound wrt. the entire type system
08:14:56 <EvilTerran> cnwdup, you should be able to do that in O(log n) with split
08:15:09 <vixey> that is saying X and Y are unifiable iff there would be a type derivation that makes this if _ then _ else _ expression well typed
08:15:11 <SamB> Zao: I didn't mind until they ballooned the package by (iirc) adding the local variable information ...
08:15:21 <EvilTerran> cnwdup, well, if each button covers a contigous part of the character set, anyway
08:15:23 <SamB> Zao: didn't even notice, actually
08:15:45 <vixey> iago, but then again, if you have explicit type abstraction (which it seems you don't) then unification would never need to be done (just alpha conversion test)
08:16:01 <cnwdup> EvilTerran, thanks for the hint. I haven't used Data.Set much.
08:16:23 <Cale> cnwdup: Yeah, for a full Data.Set of 10000 words, filtering for a prefix of 1 character and printing the results takes 0.05s or so on my machine. I suspect most of the time is spent printing.
08:16:44 <Cale> For a prefix of 2 characters, it's 0.01 seconds
08:17:07 <EvilTerran> Cale, how does using split compare?
08:17:12 <Deewiant> ?hackage list-tries
08:17:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/list-tries
08:17:19 <iago> vixey, I have explicit type abstraction :? @X. @Z. \f:X->Z ...
08:17:26 <Cale> ah, I should try that :)
08:17:35 <vixey> iago, doesn't look like it to me
08:17:43 <iago> vixey, uhm? why
08:17:48 <vixey> you got
08:17:50 <vixey> \l : List X.
08:17:52 <vixey> rather than e.g.
08:18:01 <vixey> /\X. /\Y. \l : List X.
08:18:14 <EvilTerran> vixey, it says in the paste that iago's using @ for capital lambda
08:18:29 <iago> yep
08:18:34 <vixey> I'm not talking about @
08:18:40 <iago> @X.@Z.\f:X->Z.  \l : List X.
08:18:40 <lambdabot> Unknown command, try @list
08:18:44 <iago> ops
08:18:46 <iago> -- @X.@Z.\f:X->Z.  \l : List X.
08:18:55 <iago> X is bound by @X type abstraction
08:19:06 <Cale> about 0.03s
08:19:08 <vixey> ok I get it
08:19:17 <Cale> (for splitting at two points)
08:20:17 <iago> vixey, I think that I can't typecheck without unification
08:20:24 <vixey> iago: oh I think you can
08:20:45 <iago> "map" is an expression with an unknown type, and I can't assign to it an arbitrary type variable and call unification
08:21:21 <vixey> this use of map:  map (tail X l)
08:21:22 <Cale> In any case, that's a trivial amount of time for interactive use.
08:21:22 <vixey> looks wrong
08:21:32 <vixey> You write:  [] Z  in one place
08:21:37 <vixey> but you don't write  map X Y (tail X l)
08:22:05 <iago> well, yeah, the example isn't well typed
08:23:02 <iago> anyway, with the correct definition http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2216
08:23:11 <iago> I continue without can typecheck, or I don't have idea how
08:23:11 <iago> :S
08:23:19 <vixey> oh yeah you might need unification because of the recursion
08:23:22 <eu-prleu-peupeu> I need crazy cool haskell architectures to study :)
08:23:47 <iago> so the answer is no, no?
08:23:47 <Saizan_> eu-prleu-peupeu: yi?
08:23:58 <iago> I can't typecheck this recursive definition without unification
08:24:55 <iago> only to be sure
08:25:46 <Saizan_> what if you translate it into a form using a fixpoint combinator?
08:26:52 <iago> Saizan_, said to me?
08:27:39 <Saizan_> yes
08:27:46 <iago> exactly is what I'm trying to do
08:28:00 <iago> I look for recursive definitions for apply the fixpoint combinator
08:28:02 <iago> called Y here
08:28:11 <iago> but Y : forall A. (A -> A) -> A
08:28:18 <iago> I need to apply Y to some type
08:28:40 <Saizan_> ah, right
08:29:04 <eu-prleu-peupeu> Saizan_: ill look at yi
08:29:12 * vixey feels stupid telling iago a bunch of things they already knew
08:29:58 <iago> vixey, ?
08:30:52 <vixey> iago: just that I don't think I said anything useful yet
08:31:34 <eu-prleu-peupeu> anyone actually uses yi to code in haskell ?
08:31:54 <eu-prleu-peupeu> i really like the eclipse java refactoring abilities
08:32:05 <eu-prleu-peupeu> it would be nice to have something similar to haskell :D
08:32:20 <iago> vixey, well, don't worry, now I'm more convinced that I need unification, I though understand my teacher that I could do that without unification so I was becoming crazy thinking how, but perhaps I misunderstand something
08:33:33 <defun> Hi. I am making an application that is to handle a large amount of data. I have no experience using databases, let alone using them with haskell. Are there any significant reasons I'd opt for a database instead of a regular old text file(s) that would be parsed by parsec?
08:33:41 <vixey> iago, well it appears to need to be able to say 'most general agreeable type' from a set of types with holes in them
08:33:54 <vixey> which is basically the description of unification
08:34:53 <defun> Hi. I am making an application that is to handle a large amount of data. I have no experience using databases, let alone using them with haskell. Are there any significant reasons I'd opt for a database instead of a regular old text file(s) that would be parsed by parsec?
08:34:57 <defun> oops!
08:35:02 <Saizan_> defun: if the dataset is so big consider using a parsing library based on ByteString like attoparsec or polyparse
08:35:36 <defun> I see. So no need for a DB?
08:35:44 <iago> vixey, yep, to can typecheck that without unification I would need an explicit type signature like: map : forall X Z. (X -> Z) -> List X -> List Z
08:36:08 <iago> so I could assume it like true and type-check
08:36:43 <Saizan_> defun: a db is mostly useful for indexing, so it depends more on what you do with the data than on the size of it
08:37:04 <vixey> the thing is you have like: map : forall X Z. (X -> Z) -> List X -> ?
08:37:17 <defun> thanks.
08:37:19 <vixey> and one branch of the 'if' has List Z, the other has ?
08:37:40 <iago> yep
08:38:44 <iago> the problem becomes when I try to type-check the else branch
08:38:55 <iago> algorithm founds a variable an ask the context for its type
08:39:05 <iago> and Not_found is raised
08:39:17 <iago> so I need to give some type to "map" in the context to type-check
08:41:43 <edwardk> erm, went to install lhc and it bombs wanting 'libffi'
08:45:15 <Gracenotes> :O
08:45:17 <Gracenotes> http://gracenotse.cx/
08:47:09 * SamB wonders why binutils-gold conflicts with binutils-multiarch
08:47:47 <Axman6> turns your computer into a maccas store
09:00:13 <baskey> hello, I've started learning haskell 5 minutes ago following http://haskell.org/haskellwiki/Learn_Haskell_in_10_minutes. I got to an example that does: putStrLn "WhatIs 2+2?" x <- readLn; if x == 4 then putStrLn "You're right" else ..
09:00:50 <baskey> when running this the program waits for input before it prints out "what is 2 + 2?"
09:01:02 <baskey> I guess I'm missing something..
09:01:56 <Gracenotes> baskey: hm! It seems to work for me.
09:02:34 <Gracenotes> just copying and pasting that directly into a file, loading it into ghci, and running 'main'
09:02:46 <jkff> Works for me too. What's your ghci version/OS/whatever?
09:02:46 <Gracenotes> it works with 'runhaskell' too.
09:02:52 <Gracenotes> it might be your terminal
09:03:02 <Igloo> When compiled you might need to   hSetBuffering stdout LineBuffering
09:03:04 <Saizan_> baskey: maybe it's the buffering, you might need to call hFlush stdout, or use hSetBuffering
09:03:26 <edwardk> baskey: the problem has to do with buffering
09:03:27 <Cale> baskey: Out of interest, which version of GHC is that?
09:03:35 <baskey> 6.8.3
09:03:39 <Cale> hmm, okay
09:03:39 <Gracenotes> hm, buffering? odd...
09:03:49 <baskey> can't get 6.10.2 to compile on MacOSX10.4
09:03:50 <lpjhjdh> so I'm trying to build hmatrix against atlas.  What should I have in extra-libraries to get everything working?  I'm getting HShmatrix-0.5.0.1.o: unknown symbol `zgetrs_'.  I was getting a gsl error but added gsl and it works now.
09:04:02 <mc__> base_16: you dont have to compile it
09:04:05 <mc__> there are packages
09:04:27 <Cale> baskey: Basic rule: Never compile GHC yourself unless you're hacking on it. :)
09:04:31 <baskey> Mac's GCC dies of a painful death... is there a mailgroup for asking about this other problem?
09:05:29 <baskey> Cale: there's no binary for 10.4. The version I'm running is not compiled on my machine but downloaded as binary
09:05:55 <Cale> It appears there is.
09:06:16 <Cale> Oh, only for 6.10.1
09:06:33 <Gracenotes> is there a binary for Debian/Ubuntu that's 6.10.x? :)
09:06:47 <Cale> Gracenotes: The generic linux binary works okay.
09:07:25 <Cale> Gracenotes: But I've switched from 6.10.2 back to 6.10.1 due to an annoying problem with libedit. I can't wait for 6.12 to be out so we can finally be free of it.
09:07:53 <Gracenotes> hm. I see :o
09:07:57 <baskey> ah, ok.. I didn't spot the 6.10.1 one.. considering the bug you just mentioned.. is it worthwhile upgrading?
09:08:29 <Cale> I don't know if the bug I was having applies to mac, but the differences from 6.10.1 to 6.10.2 are small
09:08:45 <Gracenotes> okay, then I suppose I shall be struck with "wait-until-next-version" syndrome
09:09:37 * Saizan_ suggests ghci-haskeline to everyone using 6.10.x
09:10:06 <baskey> hrm.. no.. 6.10.1/Mac10.4 is only for ugly powerpc arch
09:12:57 <jkff> Are there any good sources about how to avoid using mutable state, or how to encapsulate it in a fine way? I'm writing a lecture on that, and the only things that I think of are purely functional data structures, streams and linear types. However, the students don't yet know what streams or linear types are (and I am not going to tell them yet), so I'll have to do some handwaving. Unfortunately, "Avoiding IO" on haskellwiki doesn't help
09:16:57 <baskey> jkff: I.m.o. recursion, folds, list comprehensions and accumulators are pragmatic things to explain.
09:17:39 <jkff> Well, I'm not talking about how to write simple list-based imperative algorithms without mutable state: they already know that. I'm talking about more architectural questions
09:17:40 <QtPlaty[HireMe]>  That works so much better (haskeline)
09:18:21 <Cale> Saizan_: I tried that, but it was almost worse. 6.10.2 segfaulted on Ctrl-C, ghci-haskeline did nothing at all.
09:18:45 <Cale> (making it even harder to kill nonterminating programs)
09:20:51 <Cale> Given that it's extremely common for Haskell expressions to generate an infinite amount of output, not having a way to stop it is unacceptable.
09:21:06 <conal> jkff: if one approaches architecture as questions about being rather than doing, then state & mutation don't arise.
09:22:08 <conal> jkff: and if the question "how to avoid using mutable state" arises, it's perhaps a sign that "doing" thinking has crept back in.
09:22:58 <jkff> conal: Well, but the approach of doing also has the right to exist, and my goal is now to teach the students how to minimize the negative impact of mutable state if they are, for example, writing in Java. I'm not teaching them Haskell, I'm teaching them the functional style in general (based on Scheme)
09:23:55 <conal> jkff: yeah.  my advice won't probably help much in your context.
09:24:05 <conal> (probably won't)
09:24:52 <jkff> It's not about avoiding mutable state at all, it's about how to deal with it if mutability exists in the problem domain (like, bank accounts or databases). However I'm feeling that I'm too unclear about what problems exactly I am going to cope with :-|
09:26:56 * jkff thinks he should just switch off the internet cable and take an hour or two for thinking on paper
09:28:37 <Cale> Bank accounts seem to be a common example for mutable state, but... it seems they're actually quite a special case, because you should always be updating them in a way that doesn't destroy previous information.
09:29:00 <cypher-> favourite example for concurrent programming class..
09:30:06 * harovali thinks that jkff and him are thinking about the same problem domain
09:35:10 <steveklabnik> this is actually one of the things that Haskell has helped me with when programming in other languages. I've become much better at minimizing the impact of state.
09:35:25 <steveklabnik> Seems like my objects are much more self contained, I barely ever use any globals, etc.
09:36:05 <steveklabnik> I'm not sure how to explain how to do that in a general way, though.
09:36:50 <steveklabnik> "Keep mutable state as minimal as possible" is nice to say, but it's not as if it helps you design anything directly...
09:37:03 * QtPlaty[HireMe] asks "Has there been any OOP language that had only imutable objects."
09:37:24 <cypher-> QtPlaty[HireMe]: OOHaskell? ;-)
09:37:29 <eu-prleu-peupeu> hmm
09:37:39 * vixey wonders what fixed point combinator to use for parsers with mutually recursive productions.. any ideas?
09:37:41 <conal> who is it who described mutation as a form of manual memory management?  (deciding that old versions of data no longer be available to other parts of a program)
09:37:47 <cypher-> I don't think there was, but Scala is a good example of an OO language that encourages FP style
09:38:00 <eu-prleu-peupeu> i need a type that is sortable and easibly extendable to pass around any kind of information, what do you recommend ?
09:38:25 * vixey has got this recursion pattern:   M <- M & S ; S <- S & U ; U <- M
09:38:34 <QtPlaty[HireMe]> eu-prleu-peupeu: Can you be more specific?
09:38:46 <pumpkin_> conal: I remember that too, hmm
09:39:03 <vixey> A <- B meaning the definition of A uses B
09:39:06 <conal> pumpkin_: i really liked that perspective.  an eye-opener for me.
09:39:14 <pumpkin_> yeah, trying to remember where I saw it
09:39:15 <EvilTerran> vixey, loeb?
09:39:18 <pumpkin_> whether it was reddit or in here
09:39:33 <steveklabnik> conal pumpkin_ : I'd be interested in reading something like that, if you can remember.
09:40:04 <steveklabnik> ah
09:40:05 <steveklabnik> google.
09:40:23 <steveklabnik> "Mutable state is actually another form of manual memory management: every time you over-write a value you are making a decision that the old value is now garbage, regardless of what other part of the program might have been using it."
09:40:27 <steveklabnik> Paul Johnson
09:40:41 <pumpkin_> oh yeah
09:40:45 * QtPlaty[HireMe] ponders
09:40:50 <eu-prleu-peupeu> i need a type that represents messages being passed around "machines", these messages dont carry any state, just pointers to what needs to be changed. these messages have to be sorted by "weight" associated with each state manipulation they represent. The messages can be extended to any number of situations and state... thats about it i guess
09:40:55 <vixey> well I was trying  m = fix (\m -> let u = ... ; let s = fix (\s -> ...) in ...)   for a while but it was not working well
09:41:01 <pumpkin_> http://debasishg.blogspot.com/2009/04/towards-combinator-based-api-design.html
09:41:34 <conal> yeah!  thx.  :)
09:41:51 * QtPlaty[HireMe] thinks a custom tupple type would work at first blush.
09:42:08 <vixey> you never saw people in java doing { <large algorithms> thing = null; } ?
09:42:33 <eu-prleu-peupeu> java is too academic :)
09:42:43 <QtPlaty[HireMe]> data Message = Message Int StateManipulation
09:43:07 * conal wonders how much academic is exactly the right amount
09:43:25 <eu-prleu-peupeu> can i have it like StateManipulation = a ?
09:43:26 <QtPlaty[HireMe]> data StateManipulation = Foo | Bar | Baz | ...
09:43:34 <eu-prleu-peupeu> okey, but that is not extendable
09:43:55 <QtPlaty[HireMe]> You add a new action by adding it to the list.
09:44:26 <eu-prleu-peupeu> changing the core code of my package for each extension ? :/
09:44:58 <vixey> data Message dynamicActions = Message Int (Either StateManipulationStaticActions dynamicActions)
09:45:10 <QtPlaty[HireMe]> eu-prleu-peupeu: Or newtype StateManipulation = StateManipulation (State -> State)
09:46:19 <eu-prleu-peupeu> StateManipulation is a datatype that carries a function that changes state ?
09:46:26 <eu-prleu-peupeu> and what is State ? State = a ? :P
09:46:41 <mc__> when I compile and run this program http://haskell.pastebin.com/m53513b17 it always hangs forever after outputting " [...] Collatz (113351,243)", but whe I triy to pass 113352 directly to iterCollatz, I get the result in a blink
09:47:16 <vixey> :( no more ideas about fixed points?
09:47:21 <eu-prleu-peupeu> i guess i would prefer StateManipulation = StateManipulation a, even though it feels like very sloppy :/
09:47:25 <QtPlaty[HireMe]> eu-prleu-peupeu: Yes.  And state would be a type that models the state of your machines
09:47:45 <eu-prleu-peupeu> okey, the problem is that each machine has its own state, different from each other
09:47:57 <eu-prleu-peupeu> but they all carry around the same interface, even though the state is different :/
09:48:19 <eu-prleu-peupeu> i would do it with handlers in C, but i dont know how to do it "nicely" in haskell
09:49:19 * QtPlaty[HireMe] suspects that the first step is working out how you are going to model the state of the machines.
09:49:35 <eu-prleu-peupeu> data State = State a :P
09:49:49 <pumpkin_> hm
09:49:55 <pumpkin_> where does that a come from? :P
09:50:00 <pumpkin_> either you'll need a forall
09:50:03 <QtPlaty[HireMe]> eu-prleu-peupeu: Um... The doesn't parse.
09:50:10 <pumpkin_> or you'll need to specify the a on the left
09:50:31 <QtPlaty[HireMe]> Well it parses but isn't syntatically correct.
09:50:31 <eu-prleu-peupeu> can't it be like a "generic type variable" ?
09:50:42 <eu-prleu-peupeu> okey
09:50:55 <QtPlaty[HireMe]> eu-prleu-peupeu: No, you can't have type variables free like that.
09:51:07 <eu-prleu-peupeu> ok
09:51:45 <QtPlaty[HireMe]> Are your messages routed to mechines?
09:51:45 <eu-prleu-peupeu> haskell is forcing me to ditch my "would fit nicely in C" architecture design :/
09:51:53 <Gracenotes> hm, I suppose "data State = State a :P" would be a valid declaration :)
09:52:00 <Gracenotes> if (:) weren't already taken for the list constructor
09:52:02 <eu-prleu-peupeu> Gracenotes: :D
09:52:06 <GoldyOrNugget> is this a nice way of coding a filter? http://codepad.org/pDW2VCNe
09:52:52 <GoldyOrNugget> ignore the ==True
09:52:53 <eu-prleu-peupeu> QtPlaty[HireMe]: machines generate messages, and these messages are then sorted by a dispatcher, and routes them to other machines that do IO and other ugly stuff
09:52:54 <EvilTerran> GoldyOrNugget, well, "f x == True" can be just written "f x"
09:53:01 <EvilTerran> but apart from that, looks pretty good
09:53:04 <GoldyOrNugget> yay!
09:53:05 <GoldyOrNugget> thanks
09:53:17 <Gracenotes> :D
09:54:26 <QtPlaty[HireMe]> eu-prleu-peupeu: One possablity I see would be to have the mechines represented as a Map between the ID of the machines and an Enumerated type repsenting the states that they can be in.
09:54:32 <vixey> write it as a foldr GoldyOrNugget
09:54:52 <eu-prleu-peupeu> 2 kinds of machines, first kind: handle assets and asset manipulations and generate a pretty message that represents all this stuff, second kind: handle messages and perform all the ugly IO stuff
09:54:54 <GoldyOrNugget> vixey, what's a foldr?
09:55:01 <eu-prleu-peupeu> in the middle there is a dispatcher :P
09:55:08 <vixey> filter p = foldr <something> <something>
09:55:17 <eu-prleu-peupeu> the idea is that the users can then extend this by coding machines
09:55:28 <eu-prleu-peupeu> and providing the specific messages
09:55:29 <conal> GoldyOrNugget: if you want, you can eliminate the repetition of "filter' f xs"
09:55:41 * QtPlaty[HireMe] needs to sleep now.
09:55:45 <eu-prleu-peupeu> hehehe
09:55:48 <GoldyOrNugget> conal, ahh, yes. a where statement?
09:55:48 <eu-prleu-peupeu> sorry to bother you
09:55:51 <eu-prleu-peupeu> and thanks for the advice
09:56:12 <conal> GoldyOrNugget: could be.  i was thinking of a way without where or let
09:56:13 <vixey> foldr will remove the repitition
09:56:40 <Gracenotes> foldr(TM) is the new Web 2.0 phenomenon!
09:56:40 <Gracenotes> http://foldr.com
09:56:52 <eu-prleu-peupeu> there should be a "functional pure design patterns" book :/
09:57:06 <conal> GoldyOrNugget: using a function-valued conditional.
09:57:07 <Gracenotes> :) you're not the first person to suggest that
09:57:44 <GoldyOrNugget> conal, a what???
09:58:06 <pumpkin_> eu-prleu-peupeu: not nearly as necessary in haskell as in other less expressive languages
09:58:28 <EvilTerran> ?type (\p x -> if p x then (x:) else id)
09:58:29 <lambdabot> forall a. (a -> Bool) -> a -> [a] -> [a]
09:58:39 <eu-prleu-peupeu> pumpkin_: i find it hard to think on how to do extensible stuff in haskell :/
09:58:49 <conal> GoldyOrNugget: a conditional whose "then" and "else" clauses have function type rather than list type.
09:58:49 <pumpkin_> extensible?
09:59:25 <GoldyOrNugget> i don't think i follow you... o_O
09:59:39 <eu-prleu-peupeu> yes, what alternatives are there to the usual "register a function pointer and get a handler" C approach ?
10:00:02 <EvilTerran> GoldyOrNugget, you could write an if/then/else where the "then" and "else" branches are both functions
10:00:15 <conal> yeah.  that.
10:00:17 <vixey> I think the best thing to do is write it as a foldr
10:00:18 <pumpkin_> eu-prleu-peupeu: give more details, is the handler supposed to return something that is used by the library algorithm, or can it do anything at all?
10:01:17 <GoldyOrNugget> EvilTerran, how would that work in my code?
10:01:19 <eu-prleu-peupeu> the handler is then used to access a basic common "interface"
10:02:03 <pumpkin_> eu-prleu-peupeu: you need to work out what the handler can do... is it allowed to launch a missle, or can it just return something to the main algorithm?
10:02:40 <EvilTerran> GoldyOrNugget, well, if you're trying to get rid of the repetition of "filter' f xs
10:02:41 <EvilTerran> ", without having to give it a name, you're going to have to pass it to a function of some description
10:03:15 <EvilTerran> GoldyOrNugget, so you need an expression, defined in terms of "f" and "x", that takes the value of "filter' f xs" as a parameter, and does what you want
10:03:18 <eu-prleu-peupeu> pumpkin_: it depends on the application, in my case the handler would be used to build "messages" according to the state that it manipulates
10:03:43 <pumpkin_> what I'm trying to get out is whether the handler needs to be impure
10:03:51 <eu-prleu-peupeu> it doesn't
10:03:54 <eu-prleu-peupeu> thats the point
10:03:57 <Gracenotes> @unpl (\p x -> bool (x:) id (p x))
10:03:58 <lambdabot> (\ p x -> bool (\ a -> x : a) (\ b -> b) (p x))
10:04:02 <Gracenotes> @pl (\p x -> bool (x:) id (p x))
10:04:03 <lambdabot> ap (flip bool id . (:))
10:04:05 <pumpkin_> then cram it into IO and forget about it
10:04:12 <EvilTerran> GoldyOrNugget, so, if "f x" is true, you'll want the expression to be a function that conses x onto the start of a list, and if "f x" is false, you want it to be a function that does nothing
10:04:33 <EvilTerran> GoldyOrNugget, can you see how to write that?
10:04:34 <pumpkin_> eu-prleu-peupeu: but I have the feeling that if you thought more about the overall problem, you could avoid putting the handler into IO
10:04:56 <GoldyOrNugget> EvilTerran, im thinking about it
10:04:57 <conal> @pl (\p x -> bool (x:) (const id x) (p x))
10:04:57 <lambdabot> ap (liftM2 bool (:) (const id))
10:05:53 <eu-prleu-peupeu> yes, what i want is to isolate the section where IO is done, and allow this section to be sortable (by providing a value to each set of operations according to their cost in cpu cycles) and extendable
10:05:55 <conal> or (liftA2 bool (:) (pure id) <*>)
10:06:09 <EvilTerran> GoldyOrNugget, try breaking it down into bits, if that makes it easier; how'd you write an expression representing a function that conses x onto the start of a list, say?
10:06:29 <eu-prleu-peupeu> i thought about using messages and registering "objects" and using handles, because my mind is still in C/C++
10:06:47 <pumpkin_> eu-prleu-peupeu: what is the algorithm doing?
10:06:58 <GoldyOrNugget> function list = x:list?
10:06:59 <Gracenotes> now, with if..
10:06:59 <Gracenotes> @pl (\p x -> if' (p x) (x:) id)
10:06:59 <lambdabot> flip flip id . (`ap` (:)) . (if' .)
10:07:06 <eu-prleu-peupeu> pumpkin_: rendering using opengl
10:07:16 <pumpkin_> eu-prleu-peupeu: what is it handling?
10:07:19 <Gracenotes> @unpl flip flip id
10:07:19 <lambdabot> (\ c f -> c f (\ g -> g))
10:07:42 <EvilTerran> GoldyOrNugget, well, that works as a definition of the function called "function" that does that, but it's not an expression
10:07:47 <eu-prleu-peupeu> pumpkin_: triangles, pixels, and opengl state ? :/
10:07:58 <eu-prleu-peupeu> and time flow
10:08:03 <pumpkin_> eu-prleu-peupeu: ...
10:08:12 <EvilTerran> GoldyOrNugget, the trick for maximum terseness is to use an operator section, and write (x:)
10:08:16 <pumpkin_> if you want it to be nice and functional, you need to break it up more than that :P
10:08:24 <pumpkin_> you might as well just say "everything"
10:08:39 <EvilTerran> GoldyOrNugget, which means the same thing as (\xs -> x : xs), or (let f xs = x : xs in f)
10:09:06 <pumpkin_> eu-prleu-peupeu: think about it maybe in terms of what it would take to pull the opengl part out
10:09:06 <GoldyOrNugget> this is very confusing
10:09:11 <GoldyOrNugget> i need time to process it all
10:09:29 <EvilTerran> > (1:) [2,3,4] -- operator sections in action
10:09:31 <lambdabot>   [1,2,3,4]
10:09:31 <eu-prleu-peupeu> pumpkin_: thats what i want... i want to isolate opengl
10:09:44 <EvilTerran> > map (*2) [1..] -- another example, different operator
10:09:45 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
10:10:20 <eu-prleu-peupeu> for instance, in my mind there would be a "texturing" machine, that would take messages to manipulate the opengl texture states
10:10:36 <GoldyOrNugget> EvilTerran, so i was meant to do x:list before?
10:10:44 <eu-prleu-peupeu> meh, i dont know :/
10:11:11 <mc__> when I compile and run this program http://haskell.pastebin.com/m53513b17 it always hangs forever after outputting " [...] Collatz (113351,243)", but whe I triy to pass 113352 directly to iterCollatz, I get the result in a blink
10:11:27 <eu-prleu-peupeu> ill just rip the xmonad structure, and find some way around it
10:11:34 <eu-prleu-peupeu> xmonad is extensible
10:11:39 <GoldyOrNugget> (x:) list
10:12:25 <GoldyOrNugget> wait, i think i get it!
10:12:41 <ray> i'll have to deal with hopengl one of these days, not looking forward to it
10:12:56 <ray> best case, haskell will totally defy expectations and it'll be a great experience
10:13:01 <eu-prleu-peupeu> the opengl state machine doesn't make any sense to me :/
10:13:01 <ray> (i doubt it)
10:13:31 <ray> i think i will be able to make a great shooting game engine that does not draw anything to the screen
10:13:36 <GoldyOrNugget> (if fx then (x:) else ()) filter' f xs
10:13:42 <GoldyOrNugget> or something like that
10:13:48 <eu-prleu-peupeu> ehehe
10:14:28 <eu-prleu-peupeu> ray: thats lazyness to the extreme:) a game that only displays the game-over screen
10:15:48 <eu-prleu-peupeu> back to riping xmonad code, thanks for the advices
10:17:33 <monadic_kid> this seems pretty cool http://tomasp.net/blog/imperative-ii-break.aspx
10:19:39 <Cale> conal: Is reactive-fieldtrip supposed to be installable?
10:20:08 <Cale> I'm getting interesting cabal dependency problems installing Stream
10:20:23 <Cale> hmm
10:20:44 <Cale> oh, interesting, I can build Stream separately.
10:22:15 <Cale> Stream-0.3.1 is installed, and yet when I try to install reactive-fieldtrip, it complains about not being able to configure Stream-0.3.1
10:23:03 <Cale> The errors seem to just be packages fighting over which version of QuickCheck to use. That's kind of silly.
10:23:08 <zoheb> @pl (\f xs -> [ f x | x <- xs ])
10:23:09 <lambdabot> flip flip [] . ((:) .) . (<-) . (| x) . ($ x)
10:23:10 <eu-prleu-peupeu> Cale: install stream 3.0
10:23:12 <eu-prleu-peupeu> it works
10:23:24 <Cale> cabal: There is no available version of Stream that satisfies ==3.0
10:23:38 <pumpkin_> 0.3.0?
10:23:40 <zoheb> :t (<-)
10:23:41 <eu-prleu-peupeu> cabal install reactive --constraint="Stream=3.0"  it should work
10:23:41 <lambdabot> parse error on input `<-'
10:23:42 <eu-prleu-peupeu> yes
10:23:43 <eu-prleu-peupeu> that
10:23:47 <eu-prleu-peupeu> 0.3.0
10:23:57 <Cale> ah
10:24:06 <Cale> 0.3
10:24:14 <eu-prleu-peupeu> sorry
10:24:40 <zoheb> @type  (<-)
10:24:42 <lambdabot> parse error on input `<-'
10:24:51 <Cale> aha
10:24:53 <Cale> There we are.
10:25:02 <pumpkin_> zoheb: maybe you want @kind ?
10:25:07 <pumpkin_> with ->
10:25:11 <pumpkin_> <- isn't much
10:25:17 <zoheb> @k  (<-)
10:25:17 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . ? @ v
10:25:30 <Berengal> Rather, it looks like pl fails at list comprehensions
10:25:35 <pumpkin_> @kind (->)
10:25:36 <lambdabot> ?? -> ? -> *
10:25:44 <Gracenotes> @let (-<) = "arrow .. ?" in length (-<)
10:25:45 <lambdabot>   Parse error
10:25:56 <Cale> Is it just me, or is it really stupid to have packages which despite having nothing to do with testing depend on particular versions of QuickCheck?
10:26:02 <Gracenotes> the lexer doesn't like it. even though the extension isn't enabled
10:26:02 <zoheb> yes looks like pl doesnt do list comprehensions
10:26:09 <Berengal> @pl (\f xs -> do x <- xs ; return $ f x)
10:26:09 <lambdabot> (line 1, column 22):
10:26:09 <lambdabot> unexpected ";"
10:26:09 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
10:26:13 <Gracenotes> > let (-<) = "arrow .. ?" in length (-<)
10:26:15 <lambdabot>   10
10:26:16 <pumpkin_> Cale: their tests might depend on a particular version of quickcheck though?
10:26:19 <Gracenotes> oops. so maybe it does like it.
10:26:30 <Berengal> @pl (\f xs -> do {x <- xs ; return $ f x[)
10:26:30 <lambdabot> (line 1, column 14):
10:26:30 <lambdabot> unexpected "{"
10:26:30 <lambdabot> expecting variable, "(", operator or ")"
10:26:31 <Cale> Yeah, but they probably shouldn't expose those modules.
10:26:47 <Cale> Or something.
10:26:51 <pumpkin_> Cale: I thought you didn't need to expose something to still have a dependency on it
10:26:57 <Berengal> @pl (\f xs -> do {x <- xs ; return $ f x})
10:26:58 <lambdabot> (line 1, column 14):
10:26:58 <lambdabot> unexpected "{"
10:26:58 <lambdabot> expecting variable, "(", operator or ")"
10:27:03 <Berengal> Bah...
10:27:12 <pumpkin_> normally when I've tried not putting stuff like that in as a dependency, it says the package I didn't explicitly list is "hidden"
10:27:15 <Cale> Or, the tests should be commented out before packaging.
10:27:38 <pumpkin_> hmm
10:27:44 <Saizan_> pumpkin_: the point is to not make the tests a part of the library itself
10:27:53 <pumpkin_> sometimes you want to make sure it works on the target machine though?
10:28:15 <pumpkin_> if you're doing funky things, at least
10:28:21 <Saizan_> though the current Cabal testing infrastructure is suboptimal, there's a ticket about improving it
10:28:24 <Cale> Perhaps we need to have  cabal test
10:28:42 <pumpkin_> with a separate dependency system, I guess
10:28:44 <Cale> which might involve a different set of dependencies for performing the tess
10:28:45 <pumpkin_> that'd be good
10:28:46 <Cale> tests*
10:29:06 <Berengal> Yeah, cabal test seems like a great idea
10:29:23 <Cale> It seems really bad to have packages which are not installable due to requiring conflicting versions of testing libraries.
10:29:25 <zoheb> @pl (\f -> foldr ((:).f) [])
10:29:25 <lambdabot> flip foldr [] . ((:) .)
10:29:52 <Berengal> If you put the testing dependencies by themselves you could make them optional
10:30:10 <Saizan_> http://hackage.haskell.org/trac/hackage/ticket/215
10:30:29 <Cale> Okay, now reactive-glut-0.0.4 fails to build with type errors...
10:30:41 <Cale> src/FRP/Reactive/GLUT/Adapter.hs:52:30:
10:30:42 <Cale>     Couldn't match expected type `t1 -> t'
10:30:42 <Cale>            against inferred type `FRP.Reactive.Reactive.Event a'
10:30:46 <Gracenotes> zoheb: or just 'flip map []'
10:30:59 <Gracenotes> er, 'flip map'
10:31:00 <pumpkin_> but some people integrate their tests in the files they're testing, because otherwise it's a pain to "get in"
10:31:10 <zoheb> I am trying to reduce map to point free code
10:31:17 <eu-prleu-peupeu> Cale: are you installing from cabal ?
10:31:20 <Cale> eu-prleu-peupeu: yes
10:31:21 <Gracenotes> oh, okay :)
10:31:26 <Phillemann> Is printf deprecated? There seems to be no Text module present on my machine
10:31:30 <conal> Cale: thx.  version skew, i guess.  when i'm in civilization, i'll download 6.10.2 and get things back to a consistent state.
10:31:39 <Cale> Phillemann: The module is Text.Printf
10:31:47 <zoheb> Actually I was wondering what code would look like
10:32:03 <Phillemann> Cale: Ahhh, of course. Thanks :)
10:32:09 <zoheb> if (.) was the default whitespace operator instead of ($)
10:32:21 <Berengal> @pl map f (x:xs) = f x : map f xs
10:32:21 <lambdabot> map = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . liftM2 flip (((.) . (:)) .))
10:32:30 <Gracenotes> o_O
10:32:37 <Cale> map f = foldr ((:) . f) []
10:32:38 * Gracenotes likes the foldr version
10:32:54 <Cale> @pl map f = foldr ((:) . f) []
10:32:55 <lambdabot> map = flip foldr [] . ((:) .)
10:33:05 <Gracenotes> yep, see above
10:33:09 <Cale> (but going that far is silly)
10:33:39 <Berengal> But my version was totally flippin...
10:33:50 <Gracenotes> zoheb: well, ($) is a function-identity operator, not entirely application, although in most cases the same thing. It's right-associative instead of left-associative
10:34:10 <Cale> ($) *ought* to be left associative though
10:34:13 <Gracenotes> > map $ negate $ [1..5]
10:34:14 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
10:34:17 <Berengal> Cale: Why?
10:34:21 <Berengal> We've got whitespace for that
10:34:34 <Cale> Berengal: The only important feature of $ is its low precedence
10:35:01 <Cale> Whenever you have something like f $ g $ h $ x currently, you can always rewrite it as f . g . h $ x
10:35:41 <Cale> But there are some things which if $ was left associative, we could remove the parens from, and we can't currently.
10:35:44 <conal> zoheb: juxtaposition (e.g., whitespace) is function composition in Backus's "FP" language.
10:35:58 <Cale> For example f (g x y) (h x z) (k y z)
10:36:01 <zoheb> oh really
10:36:15 <Cale> Could become:  f $ g x y $ h x z $ k y z
10:36:22 <zoheb> but coding in it seems to really difficult
10:36:32 <Gracenotes> conal: you know FP?
10:36:37 <maltem> zoheb, eh?
10:36:38 <Berengal> Cale: Yeah, I see that now
10:36:46 <Berengal> I'm not afraid of a couple parenthesises though
10:37:00 <Berengal> I just wish there was a cooler way to write sections...
10:37:01 <Gracenotes> conal: it seems to be an interesting language :) Very interesting.
10:37:02 <zoheb> I mean I have to use @pl after writing applicative code
10:37:04 <pumpkin_> still, its current right-associative behavior can be replaced by (.) a lot of the time
10:37:11 <Cale> Well, sure, but since function application is left associative, I think ($) should be too.
10:37:13 <conal> Gracenotes: i'm an admirer only.  didn't like it at first (in grad school).  came to appreciate much later.
10:37:15 <pumpkin_> so you might as well make it left-associative
10:37:16 <maltem> oh, so I just missed the context
10:37:18 <Berengal> Other than that, I don't worry too much about a bunch of parenthesis
10:37:21 <zoheb> to figure out the @pl version
10:37:24 <Gracenotes> conal: how'd you learn it?
10:37:31 <Gracenotes> or become familiar-ish.
10:37:41 <conal> zoheb: ease comes with practice, i guess.
10:38:01 <Cale> conal: So, should I install a previous version of reactive-glut? The one on hackage doesn't compile...
10:38:11 <conal> Gracenotes: from Backus's famous "can programming be liberated" paper.  one of my all time favorites.
10:38:24 <Cale> oh, wait
10:38:34 <Cale> Why is it trying to install 0.0.4?
10:38:40 <Gracenotes> ooh. sounds provocative :o
10:38:44 <wjt> Cale: i'm really not convinced that f a (b c) (d e) (f g) is less clear than f a $ b c $ d e $ f g
10:39:00 <Cale> wjt: It's not, but there are cases where it would be nice.
10:39:09 <Cale> wjt: Also, $! works better that way
10:39:14 <vixey> > f a $ b c $ d e $ f g
10:39:15 <lambdabot>   Couldn't match expected type `Expr -> a -> b'
10:39:16 <conal> @where+ liberated http://www.stanford.edu/class/cs242/readings/backus.pdf
10:39:16 <lambdabot> Done.
10:39:17 <vixey> > f a $ b c $ d e $ f g :: Expr
10:39:18 <wjt> Cale: now that is certainly true
10:39:18 <lambdabot>   Couldn't match expected type `Expr -> a -> b'
10:39:25 <Gracenotes> will changing ($)'s associativity break any existing code?
10:39:29 <wjt> Gracenotes: yes
10:39:34 <vixey> Gracenotes: it might do
10:39:47 <Cale> Gracenotes: Everyone's code who chains multiple $'s together.
10:39:48 <Gracenotes> ah. indeed! :,
10:39:57 <Cale> But the code is easy to fix.
10:40:07 <Gracenotes> well, the last thing we want is multiple $ operators :)
10:40:09 <Cale> You just replace all but the last $ with .
10:40:19 <Gracenotes> unless you want a Perl look-alike
10:40:28 <wjt> I think cale's operator should be Â¥
10:40:41 <Cale> That's way too hard to type :]
10:40:51 <Berengal> Perhaps that should be unsafePerformIO...
10:41:00 <Cale> I have to hit 3 keys to get Â¥
10:41:06 <Berengal> Â¥
10:41:11 <Berengal> Yeah, me too
10:41:14 <vixey> ¥¥¥¥¥
10:41:18 <vixey> I have to hit 15 keys
10:41:42 <Gracenotes> no, the cyrillic millions sign should be unsafePerformIO! :)
10:42:01 <wjt> but then, i think that Haskell should have defined a meaning for Â¬ to let en_GB people feel smug :D
10:43:00 <Berengal> I actually have Â¬ as well...
10:43:01 <Berengal> Huh
10:43:08 <Cale> conal: Heh, for some reason, cabal was trying to install reactive-glut-0.0.4 rather than the new version :P
10:43:14 <Gracenotes> (putStrLn "hi") â€®Ò‰ .unsafePerformIO
10:43:16 <Berengal> Exploring which mod-keys are enabled is fun
10:43:24 <Mzzz> Hello, is it for the same reason that declarations like 'data T = T a' and 'type T = [a]' are forbidden? And what's the reason(s)?
10:43:32 <Berengal> Gracenotes: O_o
10:43:45 <Cale> Mzzz: They are not forbidden.
10:43:49 <Cale> er
10:43:54 <Cale> Er, oops
10:43:54 <pumpkin_> Mzzz: they don't mention a on the left hand
10:43:56 <Gracenotes> â€®Ò‰ .What are you staring at, young man??
10:44:02 <Cale> You forgot the type parameter, yeah
10:44:06 <Cale> a isn't in scope
10:44:07 <Gracenotes> â€®Ò‰ .o_O
10:44:07 <pumpkin_> Mzzz: you can do it with a forall on the right, too
10:44:09 <Berengal> Ò‰WTF is this?
10:44:14 <pumpkin_> Mzzz: for very different behavior
10:44:26 <pumpkin_> Mzzz: but you need something that puts a in scope on the right
10:44:58 <Gracenotes> the miracle of Unicode bidirectionality
10:45:11 <Gracenotes> you see, when a mommy control character and a daddy control character love each other very much...
10:45:21 <Mzzz> pumpkin_: how?
10:45:40 <pumpkin_> Mzzz: the easiest way to fix it is: data T a = Ta :P
10:45:42 <conal> Gracenotes: :)
10:45:43 <Berengal> Gracenotes: Yeah, I know about those, but how did you type them?
10:45:49 <Saizan_> Mzzz: like data T a = T a, or type T a = [a]
10:46:35 <Mzzz> Saizan_: I know that. I'm just think, e.g. T = [Int] is OK, then why not T = [a]?
10:46:48 <Gracenotes> Berengal: they require a complicated-ish sequence of control characters, so copy-paste isn't uncommon.
10:46:55 <Cale> Mzzz: because a is not in scope
10:47:28 <pumpkin_> Mzzz: do you want it to "hide" the type of what it contains
10:47:29 <pumpkin_> ?
10:47:41 * Berengal needs to properly study unicode some day
10:47:42 <pumpkin_> or do you want it to just be of any type, but to keep that type visible
10:47:51 <Cale> Mzzz: in function type declarations, all type variables are automatically treated as bound by forall, but that doesn't apply to data declarations
10:48:06 <Gracenotes> Berengal: let's leave that to the mad scientists... ;)
10:48:19 <Berengal> Gracenotes: Who says I'm not mad?
10:48:28 <Mzzz> pumpkin_: Er, no, just wondering 'why such rules?'
10:48:32 <Cale> Mzzz: If you use a type variable, it must be a parameter to the type constructor you're defining
10:48:42 <pumpkin_> Mzzz: because a is a variable and you haven't made it visible anywhere :P
10:48:54 <Cale> Mzzz: What would the type T actually consist of?
10:49:03 <Cale> If we had  data T = T a
10:49:23 <Mzzz> Cale: I know that will be useless
10:49:40 <Cale> Mzzz: What would be the type of the data constructor T?
10:49:45 <Mzzz> Cale: But type T = [a] might be useful
10:49:48 <vixey> is that data T = foral a. T a?
10:50:00 <Cale> Mzzz: Okay, then in that case, what is it?
10:50:04 <vixey> i.e.  data T where T :: forall a. a -> T
10:50:07 <Gracenotes> is it implicitly data T b = T a b? :\
10:50:17 <Cale> If we have type T = [a], show me some values of type T
10:50:27 <Gracenotes> wait, no, that wouldn't make sense either >_>
10:50:31 <Cale> How do you get a value of type a?
10:50:32 <Mzzz> Cale: T :: a -> T
10:50:42 <Mzzz> undefined
10:50:51 <pumpkin_> ah, so you want the forall
10:50:53 <Cale> Only undefined, or any value at all?
10:51:06 <Mzzz> no
10:51:07 <pumpkin_> Mzzz: but that wouldn't be useful either :P
10:51:22 <Cale> With GHC extensions, you can write:
10:51:28 <Cale> data T where T :: a -> T
10:51:47 <Mzzz> Oh
10:51:52 <Cale> and then this will allow you to apply the T data constructor to any value at all, and get a value of type T
10:52:11 <Cale> But it will forget the type of the value you applied it to, so that value becomes useless upon pattern matching.
10:52:27 <Cale> (because you can't prove that it has any properties)
10:52:48 <Cale> Or, you can write...
10:52:56 <Cale> data T where T :: (forall a. a) -> T
10:53:00 <Berengal> Cale: What type would the variable the value was bound to in pattern matching have?
10:53:16 <Cale> Berengal: exists a. a
10:53:27 <Cale> Berengal: But GHC will never tell you that.
10:53:33 <pumpkin_> it just won't let you do anything withi t
10:53:36 <Mzzz> Cale: For type T = [a], we can have [] having type T
10:53:39 <pumpkin_> except unsafeCoerce and so on :P
10:53:56 <Gracenotes> unsafeC-C-C-C-COMBOBREAKER
10:54:12 <Berengal> Yeah, I was wonder because it couldn't be of type a, because that could be unified...
10:54:27 <Berengal> wondering*
10:54:28 <Cale> Mzzz: there are at least two things that could mean: it could mean T = [forall a. a] or it could mean T = forall a. [a]
10:54:47 <vixey> use the GADT syntax :p
10:54:47 <Cale> er, actually, it could also mean T = exists a. [a]
10:55:28 <Cale> (that's genuinely different :)
10:55:57 <EvilTerran> Cale, er, that's different to [forall a. a]?
10:56:06 * EvilTerran tries to work out the variances
10:56:09 <Cale> exists a. [a] is different
10:56:22 <Cale> but I think forall a. [a] and [forall a. a] are the same.
10:56:36 <Cale> Though, inside a data declaration, they are not :P
10:56:40 <EvilTerran> ah, yes, it's whether the list can be hetereogenous
10:56:45 <Cale> well...
10:56:47 <Cale> yeah
10:56:58 <Mzzz> Oh
10:57:12 <EvilTerran> [exists a. a], as it were, could have elements all of different types
10:57:21 <Cale> In a data declaration, if you write  data T = forall a. T [a], it's different from  data T = T (forall a. [a])
10:57:38 <EvilTerran> [forall a. a] and (forall a. [a]) would both require all list elements to be all types
10:57:44 <Cale> or data T = T [forall a. a] (which ought to be the same as the second)
10:57:49 <Cale> yeah
10:58:11 <EvilTerran> and (exists a. [a]) would have all elements be the same, unknown, type
10:58:33 <Cale> But we can't explicitly write exists, just to be clear.
10:58:37 <pumpkin_> it's a mystery!
10:58:37 <EvilTerran> indeed
10:58:44 <NEEDMOAR> You can in ehc, can't you?
10:58:46 <codebliss> Hello everyone =).
10:58:56 <pumpkin_> NEEDMOARQUANTIFIERS
10:59:07 <Cale> The GADT syntax is clearer about these things anyway
10:59:12 <EvilTerran> it's just easier to write "exists a. F(a)" instead of "(forall a. F(a) -> b) -> b"
10:59:24 <EvilTerran> (or whatever the equivalence is)
11:00:11 <EvilTerran> Cale, yeah, substantially. none of that potential confusion between types and constructors.
11:01:05 <EvilTerran> (and that's even before you get into existentials and whatnot)
11:01:47 <Blah12309> ×amsg×
11:02:04 <NEEDMOAR> How do you think of forall and exists types? I mean... the intuitive thing.
11:02:31 <NEEDMOAR> Do you think it of as a formula? Or sets or what?
11:02:55 <Blah12309> ×amsg×
11:03:03 --- mode: ChanServ set +o mauke
11:03:06 <EvilTerran> Blah12309, are you familiar with the Turing test?
11:03:10 <EvilTerran> oh, never mind
11:03:33 <monochrom> forall and exists are very intuitive to me as is.
11:04:05 <byorgey> NEEDMOAR: a forall type is like a function.  "forall a. foo" means if you input any type a, you get a foo.
11:04:30 <byorgey> NEEDMOAR: exists is like a pair.  "exists a. foo"  means you have a pair of some type a and some value of type foo
11:04:58 <byorgey> NEEDMOAR: does that help?
11:04:59 <pumpkin_> "-- Each function may be treated as a computation."
11:05:04 --- mode: mauke set -o mauke
11:05:42 <pumpkin_> would it be possible for me to rewrite Arrow without arr ?
11:05:42 <NEEDMOAR> byorgey: yep. I think the constructivist-proof thing is useful, but I'm just interested in how other people think of it.
11:06:07 <NEEDMOAR> byorgey: I'm afraid I understand in a complicated way, where there may be any simpler way, or something like that.
11:06:40 <monochrom> pumpkin_: You need a method for lifting all pure functions to your Arrow instance. If you don't call it "arr" you still have to call it something else.
11:06:41 <byorgey> NEEDMOAR: I know precisely what you mean. =)
11:06:57 <pumpkin_> monochrom: why do I need that?
11:06:59 <codebliss> Is there a way to say make a function point a -> a -> (Double, Double) where a can be integral or floating?
11:07:27 <monochrom> Because pure functions are always special cases of whatever you do.
11:07:53 <Saizan_> NEEDMOAR: i usually use the game semantics for higher-rank types in general
11:07:55 <EvilTerran> pumpkin_, the de-sugaring of arrow notation fundamentally requires arr
11:08:02 <pumpkin_> monochrom: yeah, but I don't get any introspection that way
11:09:07 <monochrom> I don't know what you mean by introspection. But since you say yeah to my statement, we're in agreement, and the question is settled.
11:09:20 <pumpkin_> meh
11:09:25 <pumpkin_> thanks
11:10:14 <EvilTerran> pumpkin_, you could have a useful subclass of Category that had something analogous to "first" etc but no arr
11:11:23 <pumpkin_> I'll play with that, thanks
11:12:20 <Saizan_> EvilTerran: can you elaborate that fundamentally above?
11:12:23 <monochrom> The best intuition is logic.
11:12:53 <pumpkin_> another helpful answer
11:12:57 <vixey> forall is intersection!!
11:12:57 <EvilTerran> Saizan_, in that you can have arbitrary expressions with variables bound by the arrow notation
11:13:07 <vixey> the TRUE way to think about polymorphic types :P
11:13:19 <EvilTerran> and you need some way of representing that
11:14:10 <NEEDMOAR> Saizan_: should look at that, thanks.
11:14:27 <NEEDMOAR> vixey: I'm not pretty satisfied with that way of viewing them.
11:14:31 <Saizan_> EvilTerran: ah, right, i see
11:20:19 <vixey> NEEDMOAR how not
11:20:37 <Gracenotes> lambdabot.. is melting.. in the dark. All the sweet green lambdas floooowiing down...! Someone left the IO out in the rain.
11:20:57 <vixey> what is this haskell haiku
11:21:23 <Gracenotes> http://www.youtube.com/watch?v=6H0BD2eWIww
11:21:40 <NEEDMOAR> "what the heck is haskell haiku" looks better.
11:21:59 <Gracenotes> @go haskell haiku
11:22:01 <lambdabot> http://haskell.org/haskellwiki/Haiku
11:22:01 <lambdabot> Title: Haiku - HaskellWiki
11:25:25 <NEEDMOAR> vixey: I don't like of thinking of types as sets, I guess.
11:25:50 <monochrom> What do you think types are?
11:25:50 <Gracenotes> you can think of them as lattices instead! :P
11:25:56 <Gracenotes> (half-joke)
11:26:02 <jinjing> anyone ever get a getModificationTime error during cabal sdist?
11:26:13 <Cale> NEEDMOAR: Why?
11:26:37 <nlogax> can i think of them as lettuces?
11:26:56 <vixey> NEEDMOAR of course it's just one view (the best one)
11:26:58 <monochrom> Some paper thinks of types as relations and proves some high-powered theorems. Look for "theorems for free!" by Phil Wadler.
11:27:14 <NEEDMOAR> More like properties you can proof. (yeah, I know... more of the same...)
11:27:39 <vixey> properties you can proof -- this is the type theory view I guess
11:27:42 <monochrom> I think of types as special properties, too.
11:27:48 <NEEDMOAR> monochrom: I prefer to see 'parametricy' more like the result of being a natural transformation, as you can do in more cases.
11:29:36 <vixey> NEEDMOAR what do you mean (about natural transforms)
11:30:01 <monochrom> natural transformations are fine, once you have established they are natural. how do you know you have natural transformations, that's the real question.
11:30:21 <Cale> If you start with the set of all values, you can restrict it via comprehension to consist of only those values which satisfy a given property. If that property corresponded to a type, then the resulting set is the set corresponding to that type.
11:30:29 <NEEDMOAR> vixey: the properties you can get by parametricy theorem, are the same as viewing a polymorphic function as a natural transformation.
11:30:47 <vixey> NEEDMOAR: that sounds perfect but how do I make it formal?
11:31:54 <Cale> This is sort of why set theory doesn't really need a type theory, because it's essentially its own type theory via the membership relation.
11:32:01 <NEEDMOAR> Cale: sure, but I talk about a way of "viewing" things, not about how equivalent they are.
11:32:32 <vixey>  polymorphic function as a natural transformation -- is it computable from the type
11:32:59 <NEEDMOAR> vixey: are you asking?
11:33:04 <vixey> yes
11:33:45 <NEEDMOAR> You can show it using the parametricy theorem :-P
11:33:55 <vixey> show what?
11:34:29 <NEEDMOAR> See a polymorphic function as a natural transformation
11:34:36 <vixey> yes what is the formal statement please
11:34:40 <monochrom> A parametricity theorem states that a certain programming language's polymorphic functions end up being natural transformations.
11:34:43 <vixey> say i have got  t : T
11:34:49 <vixey> what is the natural transform?
11:34:49 <NEEDMOAR> vixey: see Wadler's paper.
11:35:02 <vixey> I know it off by heart NEEDMOAR, yet I don't know what you're talking about
11:35:27 <monochrom> say you've got f : a -> [a]. f is then a natural transformation from the identity functor to the [] functor. That is all.
11:35:50 <NEEDMOAR_> Dmnti.
11:35:55 <NEEDMOAR_> Sorry.
11:36:08 <NEEDMOAR_> |= t : T, then ||= t : T, or something like that was Wadler's syntax for parametricy theorem.
11:36:16 <NEEDMOAR_> |-, the first
11:36:26 <vixey> where's the natural transform?
11:37:04 <NEEDMOAR_> You have to relation it with the semantical model which you consider a category, probably.
11:37:18 <NEEDMOAR_> Wadler never finished his paper about Theorems for free! in a categorical setting, tho :_/
11:37:39 <NEEDMOAR> |= t : T, then ||= t : T, or something like that was Wadler's syntax.
11:37:46 <NEEDMOAR_> Ha.
11:37:51 <NEEDMOAR_> That's pretty much lag.
11:40:30 <vixey> If F and G are functors between the categories C and D, then a natural transformation Î· from F to G associates to every object X in C a morphism Î·X : F(X) â†’ G(X) in D called the component of Î· at X, such that for every morphism f : X â†’ Y in C we have:
11:40:45 <vixey> Î·Y . F(f) = G(f) . Î·X
11:49:10 <monochrom> @free (\x -> [x])
11:49:10 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
11:49:16 <monochrom> @free map
11:49:18 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:49:23 <NEEDMOAR> vixey: uhm?
11:53:34 <byorgey> vixey: so suppose g and h are instances of Functor.  Then a natural transformation associates to every object of Hask---that is, every type a--- a morphism  eta :: g a -> h a.  So a natural transformation has type  forall a. g a -> h a.
11:54:42 <byorgey> furthermore, if  n :: forall a. g a -> h a,  then  for any  f :: a -> b,  we have  n [b] . fmap [g] f = fmap [h] f . n [a]
11:54:53 <byorgey> where I've written [-] for explicit type application
11:55:20 <byorgey> this last result is what one gets from a parametricity theorem---namely, that every polymorphic function satisfies a naturality condition like that.
11:55:49 <vixey> $map is really fmap then
11:56:00 <byorgey> er, sorry, fmap [g]  is bogus, but you get the idea I hope
11:56:04 <byorgey> vixey: right
11:56:07 <vixey> but where is n?
11:56:18 <vixey> oh, n is the @free n
11:56:21 <byorgey> right
11:56:41 <NEEDMOAR> @free reverse
11:56:42 <lambdabot> $map f . reverse = reverse . $map f
11:56:57 <byorgey> but I hope you see now how what I wrote corresponds directly to the definition of natural transformation you quoted
11:57:06 <vixey> byorgey yeah!
11:57:07 <vixey> @free ((a,b) -> c) -> (a -> b -> c)
11:57:08 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
11:57:13 <vixey> @free curry
11:57:14 <lambdabot> h . k = p . $map_Pair f g => h . curry k x = curry p (f x) . g
11:57:34 <vixey> this one doesn't correspond to a natural transform though?
11:57:46 <byorgey> @type curry
11:57:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:57:53 <vixey> it has to ahve only a single (->)?
11:58:00 <byorgey> sure it does, it's just a bit more complicated
11:58:14 <byorgey> well, you can read it as ((a,b) -> c) -> (a -> b -> c)
11:58:22 <byorgey> so there's one 'top level' (->)
11:59:42 <byorgey> don't ask me for the exact details =)
12:00:34 <vixey> @free eta :: [a] -> Maybe a
12:00:35 <lambdabot> $map_Maybe f . eta = eta . $map f
12:00:43 <vixey> @free eta :: f a -> g a
12:00:43 <lambdabot> Extra stuff at end of line
12:00:58 <vixey> @free eta :: ((->)e a) -> (e,a)
12:00:59 <lambdabot> g . h = k . f => $map_Pair f g (eta h) = eta k
12:01:17 <vixey> sooooo
12:01:30 <NEEDMOAR> So!
12:01:35 <vixey> it looks like having a hypothesis is the equivalent of   $map_->
12:02:06 <vixey> @free eta :: (a -> b) -> (b -> a)
12:02:07 <lambdabot> g . h = k . f => f . eta h = eta k . g
12:02:50 <NEEDMOAR> @free eta :: a -> a
12:02:50 <lambdabot> f . eta = eta . f
12:03:28 <NEEDMOAR> I didn't know of `@free'.
12:10:52 <guenni> how can I check for an existing function by type signature?
12:11:40 <Saizan> use hoogle
12:11:51 <guenni> Saizan: how?
12:12:07 <lpjhjdh> @hoogle a b c -> a b' c' -> a (Either b b') (Either c c')
12:12:08 <lambdabot> Control.Arrow (+++) :: ArrowChoice a => a b c -> a b' c' -> a (Either b b') (Either c c')
12:13:42 <guenni> lpjhjdh:thx
12:14:03 <athos> @hoogle Int -> Bool
12:14:04 <lambdabot> Data.Bits testBit :: Bits a => a -> Int -> Bool
12:14:04 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
12:14:04 <lambdabot> Data.IntSet notMember :: Int -> IntSet -> Bool
12:19:58 <Cale> conal: Is there a good reason for mousePosition not to be a Vector2 Double to begin with?
12:35:25 <conal> Cale: which lib?
12:36:04 <Cale> I suppose it's FRP.Reactive.GLUT.UI ?
12:36:19 <guenni> I'm using case x of Just x -> ... Nothing -> Nothing within an IO Monad, some the IO happens to return IO (Maybe a), how can I rewrite it so that the code doesn't wander off to the right? I'd basically need to "mix" the IO and Maybe monad.
12:36:38 <Cale> I'm finding that working with Anims seems to require a lot of (fmap . fmap), (liftA2 . liftA2) etc.
12:37:03 <wjt> is MaybeT in mtl or any of its rivals?
12:37:04 <Cale> I wonder if Anim would be better off as a proper newtype with instances...
12:37:22 <conal> Cale: in that case, yes.  i'm all for continuous-space mouse, so my space libraries are continuous.  since reactive-glut is a glut adapter, i didn't impose my continuous-space preference on users.
12:37:58 <Cale> Well... it's already a (Double, Double)
12:38:14 <conal> Cale: yeah (about the manual lifting).  in fran i also provided lifted versions of modules.  could be done for reactive.
12:43:56 <Cale> Oh, interesting, the coordinates which GLUT reports for the mouse don't seem to agree with the 2D coordinates used when translating objects.
12:44:38 * Cale wonders what the scale factor is...
12:46:22 <JoshTriplett> I have an app using HDBC, and the database has a table of users with names as a unique column.  Given a username (and other info), how can I insert the new user and return True if that username does not exist, or return False if the username does exist?
12:46:38 <JoshTriplett> I don't see an obvious way to deal with the "already exists" case.
12:46:53 <JoshTriplett> In a race-free way, I mean.
12:47:24 <olsner> Cale: doesn't that depend on what various projection matrices you've set in GL? I think if you use the glut utilities for setting an orthogonal 2d coordinate system of the same size as the glut window, it'll match up
12:48:31 <olsner> and I guess that the event functions always give you screen pixels
12:48:46 <Cale> olsner: I'm not sure that reactive-glut lets me do that?
12:48:51 <Cale> Does it?
12:50:15 <Cale> The coordinates that it's giving are not too far from reactive/fieldtrip's coordinates.
12:50:20 <conal> Cale: probably not in its present form.  it's pretty rudimentary.
12:51:02 <olsner> hmm, don't really know anything about reactive-glut :)
12:51:15 <Cale> I wrote a little program to try to have a small 2D disk follow the mouse cursor.
12:51:37 <Cale> but the 2D disk moves just slightly faster than the mouse :)
12:51:48 <conal> weird
12:51:59 <Cale> They line up when the mouse is right in the middle of the window though.
12:52:19 <conal> oh, sure.  some kind of scaling mismatch.
12:52:33 <Cale> right.
12:52:43 <conal> i always like to place zero in the middle and positive up.
12:52:59 <Cale> It's a nice convention, I agree. :)
12:53:19 <conal> a minority convention in my (graphics) experience
12:53:38 <conal> (i.e., experience of other people's graphics apis)
12:54:12 <Cale> Yeah, a lot of them will place (0,0) at the upper left corner and have the screen all be positive.
12:54:16 <pumpkin_> yeah, I'm not a fan of the 0,0 at the top-left
12:54:37 <pumpkin_> seems unnecessarily tailored to an old technology
12:54:59 <Renderwahn> anyone knows "the haskell road to logic" book who could show me how exercise 1.10 is solved with the knowledge presented up until this exercise
12:55:01 <conal> pumpkin_: books & teletypes?
12:55:08 <vixey> I don't care where O is as long as you don't change it tommorow
12:55:30 <pumpkin_> conal: I was thinking more of CRTs and the scan pattern, but I guess those probably caused the CRT pattern :)
12:56:03 <conal> pumpkin_: maybe so.  now i wonder.  thx. :)
12:56:16 <Cale> Renderwahn: sure...
12:57:30 <Cale> Renderwahn: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2218#a2218
12:57:58 <McManiaC> @pl \x y = putStr $ (++) x y
12:57:59 <lambdabot> (line 1, column 6):
12:57:59 <lambdabot> unexpected "="
12:57:59 <lambdabot> expecting pattern or "->"
12:58:14 <McManiaC> @pl \x y -> putStr $ (++) x y
12:58:14 <lambdabot> (putStr .) . (++)
12:58:20 <Cale> Renderwahn: I trust that all those bits have been introduced by then?
12:58:23 <McManiaC> hmm ugly
12:58:25 <JoshTriplett> Personally, when I have a choice, I tend to put (0,0,0) at the bottom left corner of the window, which makes all visible geometry have positive coordinates.
12:58:33 <conal> (fmap.fmap) putStr (++)
12:58:39 <JoshTriplett> But most modern graphics systems don't follow that convention. :)
12:58:45 <conal> or (result.result) putStr (++)
12:59:27 <Cale> I actually really like the convention of using complex numbers for 2D coordinate geometry.
12:59:30 <Renderwahn> Cale: hum, I'm not sure about the use of : to reconstruct lists, but maybe I missed it
12:59:40 <Renderwahn> but thank you
12:59:45 <Cale> Renderwahn: ah
12:59:47 <Cale> Renderwahn: okay
13:00:00 <vixey> it's interesting how complex numbers work for 2D and quaternions work for 3D
13:00:08 <conal> Cale: :)  that's what i'm doing for my current DSEL for functional imagery & 3d
13:00:15 <pumpkin_> vixey: work in what sense? as rotations?
13:00:30 <idnar> pumpkin_: or vectors
13:00:40 <Cale> Well, quaternions work for 2D the same way they work for 3D.
13:01:11 <idnar> quaternions are a sort of extension of complex numbers, in a way I don't fully understand
13:01:16 <Cale> It's really too bad there isn't a nice 3 dimensional division algebra over R :)
13:01:36 <Cale> It's fairly simple... you have units 1,i,j,k
13:01:36 <pumpkin_> idnar: someone expressed them interms of pairs of complex numbers I believe
13:01:43 <Cale> and i^2 = j^2 = k^2 = -1
13:01:44 <pumpkin_> *in terms
13:01:54 <Cale> and ij = k, jk = i, ki = j
13:02:07 <idnar> Cale: I have a reasonable grasp of the definition
13:02:21 <idnar> there's just a disconnect somewhere trying to relate them in my mind
13:02:24 <Cale> Ah, you want to see how they correspond to rotations/orientations?
13:02:27 <sampointon> hi #haskell
13:02:40 <idnar> Cale: no, I just mean the way complex numbers are related to quaternions
13:02:40 <pumpkin_> hi sampointon
13:02:57 <Cale> idnar: ah
13:03:01 <idnar> Cale: I mean, for complex numbers, you just have i^2 = -1
13:03:17 <pumpkin_> http://en.wikipedia.org/wiki/Cayleyâ€“Dickson_construction
13:03:27 <Cale> idnar: There's a certain construction you can apply which goes from the reals to the complex numbers, from the complex numbers to the quaternions, and from the quaternions to the octonions.
13:03:28 <Itkovian> hi sampointon
13:03:31 <idnar> Cale: but i there isn't quite the same thing as it is in the definition of quaternions
13:03:41 <Cale> idnar: You can think of it as the same.
13:03:47 <idnar> Cale: it doesn't behave the same, though
13:03:49 <Cale> idnar: C embeds into H nicely
13:03:52 <vixey> it does
13:03:52 <Cale> No, it does.
13:03:56 <idnar> Cale: multiplication isn't commutative
13:04:06 <Cale> But multiplication of complex numbers in H is.
13:04:06 <idnar> Cale: ij = k, ji = -k (I think?)
13:04:14 <Cale> yes
13:04:36 <vixey> idnar if {1,i,j,k} span the set H, and {1,i} span the set C
13:04:41 <vixey> C is a subset of H
13:04:41 <mercury^> http://en.wikipedia.org/wiki/Brauer_group
13:04:48 <Cale> If you have two numbers (a + i b) and (c + i d) in the quaternions, that is, they have no j or k part, then they behave exactly as complex numbers
13:04:49 <vixey> C is the complex numbers and H is quaternions
13:04:55 <idnar> I want to think of i as a "number", but it doesn't behave the way I'm used to "numbers" behaving
13:05:13 <Cale> "number" doesn't really mean much anyway :)
13:05:25 <idnar> sure
13:05:27 <pumpkin_> lol, "In modern language, quaternions form a 4-dimensional normed division algebra over the real numbers. "
13:05:27 <vixey> yeah not sure why you are vauging it up
13:05:30 <idnar> it's all just mental fiction
13:05:44 <iago> someone knows some reference for unification for polymorphic lambda calculus? (I looked for but I found more advanced stuff)
13:05:49 <idnar> but it throws my intuition off
13:06:00 <idnar> and I normal operate on an intuitive level, not a formal level
13:06:01 <NEEDMOAR> C is a subalgebra of H, right?
13:06:06 <idnar> *normally
13:06:25 <pumpkin_> how about matrices? they don't have commutative multiplication either
13:06:30 <mpwd> idnar: If you work at the formal level enough, you will gain intuition in the formal level :)
13:06:38 <Cale> idnar: You can still think of quaternion multiplication geometrically as a combination of rotation and scaling
13:06:40 <idnar> pumpkin_: I don't think of matrices (or vectors) as "numbers"
13:06:47 <pumpkin_> ah
13:06:49 <Cale> (just like you can do for complex multiplication)
13:07:14 <idnar> look, to be clear, I don't have a problem working with quaternions as "not numbers", it's the same as matrices or whatever
13:07:14 <mpwd> idnar: There is a matrix definition of the quaternions...
13:07:15 <Cale> But since the 4 dimensional rotation group isn't commutative, multiplication of quaternions isn't either.
13:07:30 <idnar> but I do think of complex numbers as "numbers", so I just feel like I'm missing a deeper intuitive link between complex numbers and quaternions
13:07:32 <mpwd> idnar: I can dig it up for you if you like.
13:07:37 <Cale> Matrices are another kind of number to me :)
13:07:43 <idnar> mpwd: yes, I've seen that, I think
13:07:49 <koeien_> Cale: "number" is vague
13:07:51 <JoshTriplett> idnar: I had the same problem with quaternions myself, for a while.
13:07:54 <Cale> koeien_: right.
13:07:55 <koeien_> matrices are numbers, sure :)
13:07:56 <vixey> idnar, I wish you sto pwriting "number" in quotes :p
13:08:04 <koeien_> functions are numbers, as well?
13:08:07 <pumpkin_> yeah!
13:08:10 <idnar> vixey: I'm putting it in quotes because it's a lie :P
13:08:10 <vixey> idnar, you didn't get the subset  bit I said?
13:08:10 <pumpkin_> I was just going to say :P
13:08:26 <idnar> vixey: but I don't have a better word to substitute
13:08:30 <vixey> N < Z < Q < R < C < H
13:08:36 <sampointon> I'm having some trouble with networking, closing handles and error types. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2219 is my code, as well as the error
13:08:40 <JoshTriplett> idnar: Complex numbers still feel like they have some connection to an underlying math principle, namely sqrt(-1), and all of their behavior gets derived from that.
13:08:41 <vixey> they all have the same * and +
13:08:46 <idnar> by "number", I just mean some vague undefined intuitive construct that only exists in my own mind
13:08:47 <koeien_> vixey: they are not all rings
13:08:49 <NEEDMOAR> Uhm.
13:08:53 <Cale> koeien_: I think I'd be willing to call anything a number if it has operations we're willing to call multiplication and addition which satisfy distributivity.
13:08:58 <vixey> koeien_: can't remember saying "these are all rings"
13:09:00 <sampointon> I expected hGetChar to throw an EOF error, not an invalid argument error, which seems very vague
13:09:06 <JoshTriplett> idnar: But then quaternions arbitrarily say "we have two more numbers which square to -1, and they don't equal i or each other.".
13:09:10 <pumpkin_> so a ring?
13:09:13 <idnar> JoshTriplett: right, the extension from N to Z to Q to R to C doesn't violate any intuitive concepts, it's just about removing limitations, as it were
13:09:15 <Cale> Less than a ring.
13:09:19 <JoshTriplett> idnar: Exactly.
13:09:20 <koeien_> Cale: so rings?
13:09:22 <NEEDMOAR> vixey: isn't it better to do not counter N,Z and think of subalgebras?
13:09:23 <pumpkin_> lol
13:09:24 <idnar> JoshTriplett: but then when you go from C to H... stuff breaks
13:09:25 <vixey> idnar, did you miss the bit I said about subset?
13:09:25 <koeien_> ah never mind
13:09:32 <idnar> vixey: no
13:09:37 <Cale> I'm not even going to require anything in particular from the two operations separately.
13:09:46 <Cale> It's the distributivity which makes things number-like to me.
13:09:48 <mpwd> idnar: You might like the move from R to R* (the hyper-reals)
13:09:53 <pumpkin_> Cale: wikipedia says there's something called a pseudoring
13:09:58 <pumpkin_> I guess that'd be your definition of number?
13:10:03 <koeien_> rng?
13:10:06 <JoshTriplett> idnar: I first learned about complex numbers in a way that built from "let's make up a name for sqrt(-1) and see what we get".
13:10:12 <mpwd> The only thing that breaks is the archimedean principle...
13:10:16 <idnar> vixey: but I suppose maybe that is the solution; I need to think of everything as a quaternion, not a "number"
13:10:17 <vixey> NEEDMOAR no
13:10:19 <pumpkin_> koeien_: yeah, I think so :)
13:10:22 <NEEDMOAR> vixey: why not?
13:10:27 <vixey> idnar, I wish you stop "number" n quotes :/
13:10:37 <idnar> vixey: do you have an alternative suggestion?
13:10:42 <vixey> NEEDMOAR what I said is what I wanted to say, not caring about rings or anything atm
13:10:44 <pumpkin_> numbr
13:10:45 <koeien_> i withdraw from this pointfree discussion :)
13:10:50 <Cale> pumpkin_: Is it the same as a ring without unity?
13:10:59 <mpwd> lol
13:11:00 <NEEDMOAR> vixey: you're hard with me!
13:11:14 <JoshTriplett> idnar: So, I have a suggestion which might help you with quaternions.
13:11:20 <pumpkin_> Cale: yeah
13:11:29 <Cale> pumpkin_: Not even quite as much as that then :)
13:11:34 <pumpkin_> lol
13:11:36 <sampointon> or, to put it differently: should I catch and treat an 'invalid argument' error as an EOF error? Or am I closing socket-handles the wrong way?
13:11:37 <NEEDMOAR> What book do you recommend on algebra, guys?
13:11:46 <koeien_> Cale's definition didn't want additive inverse?
13:11:50 <pumpkin_> Cale: what does it have that you don't want?
13:11:53 <idnar> I probably just need to integrate more mathematical knowledge on an intuitive level
13:12:13 <Cale> I don't care about inverses, commutativity, associativity or any of that.
13:12:19 <idnar> for example, I know about things like rings and groups, but when I think of "complex numbers" or whatever, those concepts are off in a different box
13:12:19 <JoshTriplett> idnar: With complex numbers, you can have multiple numbers which have similar properties about roots.  Actually, even with just reals.  You can have sqrt(4) = +2 or sqrt(4) = -2.
13:12:21 <pumpkin_> ah
13:12:29 <Cale> Just two operations, distributive laws.
13:12:55 <pumpkin_> so it's a Caloid
13:12:55 <JoshTriplett> idnar: So 2^2 = 4, and (-2)^2 = 4, but 2 != -2.
13:13:05 <JoshTriplett> idnar: Basic math, right? :)
13:13:23 <bavardage> or fun thinsg like
13:13:28 <bavardage> sqrt(-1) = i
13:13:37 <bavardage> but sqrt(a)sqrt(b) = sqrt(ab)
13:13:40 <JoshTriplett> idnar: Now apply it to quaternions.  You have several numbers which all square to -1, but they don't equal each other.
13:13:49 <bavardage> so sqrt(-1)sqrt(-1) = sqrt (-1*-1) = sqrt (1) = 1
13:13:49 <idnar> JoshTriplett: an infinite set of numbers, I believe
13:14:00 <JoshTriplett> idnar: Finite, I think.
13:14:04 <JoshTriplett> idnar: Multiple, but finite.
13:14:24 <idnar> JoshTriplett: well, there are three "base" elements, but I recall something about points on a circle
13:15:03 <idnar> ah, yes
13:15:28 <vixey> idnar: here's a hint toward proving it's got ot be i j or k, {1,i,j,k} spans H, let A = x1+yi+zj+wk; B = p1+qi+rj+sk; A*B = <expand> = -1 --> ___
13:15:36 <idnar> every quaternion corresponding to the vectors that comprise the unit sphere is a root of -1
13:15:55 <Cale> Hmm, reactive-fieldtrip seems to need some ways to control the initial geometry of the window and its other properties.
13:16:55 <JoshTriplett> idnar: A question for you: (-i)^2 = what? :)
13:17:28 <Cale> idnar: including 1?
13:18:03 <sampointon> so no-one's had similar problems when trying to close a socket?
13:18:14 <flippo> oh, boy, a non-abelean group of order eight
13:18:35 <JoshTriplett> idnar: Every complex number has N Nth roots.  In particular, 2 square roots.  sqrt(-1) = +i and sqrt(-1) = -i.
13:18:49 <pumpkin_> wasn't there some a cappella song like that?
13:18:50 <idnar> Cale: I'm not exactly sure what "1" means in H
13:19:09 <JoshTriplett> idnar: 1 + 0i + 0j + 0k. :)
13:19:19 <idnar> Cale: but unless I'm mistaken, q^2 = -1 iff ||q|| = 1
13:19:20 <Cale> idnar: It has all the properties that 1 normally has to.
13:19:24 <Cale> no
13:19:29 <Cale> Because 1^2 = 1
13:19:33 <Cale> but ||1|| = 1
13:19:45 <idnar> oh, sorry
13:19:49 <vixey> idnar, gave you hint toward proving it..
13:20:00 <idnar> let me rephrase that
13:20:08 <idnar> or restate that, rather :P
13:20:14 <vixey> seems like you prefer guessing and stuff though
13:20:46 <idnar> let q = bi + cj + dk; q^2 = -1 iff ||q|| = 1
13:21:02 <Cale> okay...
13:21:27 <JoshTriplett> idnar: So, given that sqrt(-1) has multiple values even in the complex plane, and those values have different properties and don't equal each other, just extend that to quaternions.  You choose two more completely arbitrary orthogonal values which square to -1, and define properties about them.
13:21:32 <idnar> which has infinitely many solutions for b, c, d, surely?
13:21:40 <Cale> idnar: yes, I can agree with that
13:21:42 <JoshTriplett> idnar: See http://blog.plover.com/math/i.html for an interesting discussion on the arbitrariness of i versus -i.
13:21:57 <Cale> idnar: It's that whole 2D sphere of points.
13:22:12 <JoshTriplett> idnar: Read that and quaternions will feel a lot less arbitrary.  Or alternatively, complex numbers will feel a lot more arbitrary. :)
13:22:27 <pumpkin_> > ((a * i) + (b * j) + (c * k)) ** 2
13:22:29 <lambdabot>   (a * i + b * j + c * k)**2
13:22:35 <pumpkin_> lol, thanks lambdabot
13:22:35 <FunctorSalad> JoshTriplett: is that written by someone on here?
13:22:44 <JoshTriplett> FunctorSalad: No idea.  Just found it via google.
13:22:44 <idnar> JoshTriplett: probably the latter
13:22:52 <JoshTriplett> idnar: Well, that works too. :)
13:22:58 <idnar> JoshTriplett: as I say, I think if I started thinking of everything as quaternions, it might help
13:23:00 <vixey> > reduce $ (a * i + b * j + c * k)*(a * i + b * j + c * k)
13:23:01 <lambdabot>   (a * i + b * j + c * k) * (a * i + b * j + c * k)
13:23:08 <pumpkin_> :P
13:23:13 <idnar> JoshTriplett: although lack of commutatitivity probably gets in the way of that
13:23:17 <FunctorSalad> what was the point of discussion about quaternions? :)
13:23:20 <pumpkin_> > (a * i + b * j + c * k) * (a * i + b * j + c * k)
13:23:21 <lambdabot>   (a * i + b * j + c * k) * (a * i + b * j + c * k)
13:23:25 * pumpkin_ gives up
13:23:31 * FunctorSalad admits he never really got into them
13:23:37 <vixey> > join (liftA2 (+)) [a * i , b * j , c * k]
13:23:38 <lambdabot>   [a * i + a * i,a * i + b * j,a * i + c * k,b * j + a * i,b * j + b * j,b * ...
13:23:40 <mauke> > (a * i) ^ 2
13:23:42 <lambdabot>   a * i * (a * i)
13:23:49 <JoshTriplett> idnar: You said earlier that the transitions from N to Z to R to C felt more natural.
13:24:27 <pumpkin_> > reduce $ a * i + a * i
13:24:29 <lambdabot>   a * i + a * i
13:24:58 <pumpkin_> I guess I can't really expect simple reflect to do all that for me :)
13:25:38 <younder> What does the $ mean?
13:25:41 <idnar> JoshTriplett: the thing is, -i and i are arbitrary, but the fact that there are two roots isn't arbitrary
13:25:52 <mauke> @src ($)
13:25:52 <lambdabot> f $ x = f x
13:26:08 <mle> younder: an operator that lets you remove parentheses, essentially.
13:26:24 <mle> a $ b c is like a (b c)
13:26:35 <younder> ahh, thanks
13:26:47 <pumpkin_> there's nothing special about it at all
13:26:58 <pumpkin_> its main "feature" is its low precedence
13:27:06 <BMeph> Oh, BTW -  http://blog.plover.com/ is Mark-Jason Dominus' blog. :)
13:27:09 <idnar> JoshTriplett: all positive numbers in R have two roots, so it seems natural to also give -1 two roots
13:27:21 <mle> pumpkin_: everything's special!
13:27:22 <JoshTriplett> idnar: Ah, I think I get your point now.
13:27:50 <JoshTriplett> idnar: You can get from R to C by saying that you want sqrt to work on negative numbers.
13:27:59 <pumpkin_> :)
13:28:05 <idnar> JoshTriplett: yeah
13:28:08 <JoshTriplett> idnar: So you wonder what operation on C motivates H. :)
13:28:19 <JoshTriplett> idnar: What can't you do on things in C that makes you want to invent H.
13:28:53 <JoshTriplett> idnar: Similarly, closure on subtraction motivates the transition from N to Z, and closure on division motivates the transition from Z to R.
13:29:11 <JoshTriplett> idnar: (or strictly speaking to the rationals, but then roots take you to R, or whatever).
13:29:32 <idnar> JoshTriplett: yeah
13:29:42 <kadaver> wow writing a compiler is a pretty damn massive thing ey
13:29:42 <FunctorSalad> either completeness as a metric space or order completeness gets you to R </nitpick>
13:29:46 <kadaver> must be
13:29:57 <kadaver> is efficient codegeneration the hardest part?
13:30:07 <kadaver> im learning asm right now
13:30:13 <Heffalump> kadaver: depends a bit
13:30:28 <idnar> JoshTriplett: when you go N -> Z -> Q -> R -> C, you're not "giving up" anything, it's like you're filling in gaps
13:30:38 <Heffalump> it's the biggest timesink, because the other parts are well defined (for a stable language)
13:30:40 <sampointon> kadaver: for static imperativish languages, probably
13:30:42 <JoshTriplett> idnar: Yeah, I do see your point.
13:30:57 <idnar> JoshTriplett: but from C -> H you actually add gaps (no more commutativity, for example); and I'm not actually sure what gap is being filled in
13:30:59 <vixey> idnar, you are giving up things
13:31:13 <JoshTriplett> idnar: I don't know of any operation on C that motivates H.  The motivation for H came more from "Hey, complex numbers represent a plane, what represents a 3D space?".
13:31:14 <FunctorSalad> you give up order from R to C
13:31:14 <vixey> idnar, you give up the fact that every set has a lowest element when you go from N to Z
13:31:20 <JoshTriplett> FunctorSalad: Point.
13:31:23 <idnar> vixey: sure
13:31:38 <vixey> idnar, you give up the fact that every bounded set is finite when you go from Z to Q
13:31:46 <FunctorSalad> JoshTriplett: but I agree that I don't see what "deficiency" of C H is supposed to correct
13:31:47 <vixey> idnar, you lose you head when you go from Q to R ..
13:32:23 <idnar> vixey: those are just obviously not part of my intuitive model
13:32:25 <BMeph> When you go from R -> C, you "gain" roots, but you "give up" order. From C on out, the things you "give up" are better known. :)
13:32:54 <kadaver> and geenrating code for prue functional langauges is easier?
13:33:04 <BMeph> Dang it, FunctorSalad! ;)
13:33:12 <kadaver> is there some sort of framework for a pure asm function?
13:33:16 <kadaver> how to say
13:33:33 <Heffalump> kadaver: do you mean in Haskell?
13:33:37 <Heffalump> If so check out LLVM and Harpy
13:34:07 <FunctorSalad> aren't R,C and H the only finite-dimensional real algebras with multiplicative inverses though?
13:34:15 <sampointon> so. What is the Right Way to close a socket-handle? Right now I'm just using hClose, but that's causing problems
13:34:16 <FunctorSalad> that would give some legitimacy to H I guess ;)
13:35:00 <koeien_> sampointon: iirc i used hClose as well.
13:35:05 <FunctorSalad> (not sure about that one)
13:35:06 <sampointon> that is, I mean just calling it and expecting the threads blocked on reading it to die gracefully with an eof error
13:35:12 <vixey> FunctorSalad: is it really? what about the rest of cliffords algebras
13:35:35 <sampointon> koeien_: something like http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2219 ?
13:35:39 <FunctorSalad> vixey: they don't have inverses do they?
13:36:40 <JoshTriplett> idnar: Honestly, to the best of my knowledge, no obvious mathematical property on complex numbers will give you the motivation for quaternions.  I wish one did; that would make them much more intuitive.
13:36:54 <alexsuraci> Hrm, something is very very wrong here. When I call a certain function the whole application halts, my RAM usage shoots to 99% (out of 6GB), CPU usage shoots up, and adding a "trace" doesn't output anything.
13:37:00 <koeien_> sampointon: you are expecting a character immediately ?
13:37:03 <alexsuraci> Will profiling work if I have to kill it before it finishes?
13:37:05 <vixey> JoshTriplett: Yeah the leap from C to H seems to be a huge creative achievement
13:37:11 <FunctorSalad> :)
13:37:12 <Heffalump> alexsuraci: use heap profiling
13:37:19 <Heffalump> that does work if aborted early
13:37:21 <Heffalump> time profiling doesn't
13:37:24 <sampointon> koeien_: no, but some might arrive
13:37:31 <Heffalump> but heap profiling should give you a pretty big clue in the situation you describe
13:37:32 <alexsuraci> Heffalump: Alright, thanks
13:37:40 <sampointon> koeien_: eg, if I connect with telnet, it works alright til it tries to close
13:37:42 <koeien_> sampointon: you are only waiting for 1 second?
13:38:09 <koeien_> sampointon: you are closing a socket while still reading from it
13:38:14 <sampointon> koeien_: this is a simplified version of some code from my MUD server, the delay is just to make sure that I can type stuff in
13:38:18 <koeien_> ok
13:38:33 <FunctorSalad> ah wikipedia confirms it http://en.wikipedia.org/wiki/Frobenius_theorem_%28real_division_algebras%29
13:38:38 <sampointon> koeien_: yeah, I know, but I'm expecting the hGetChar to raise an eof error, not an invalid argument error
13:38:46 <koeien_> sampointon: apparently you cannot read from a socket after you closed it
13:39:06 <sampointon> koeien_: in the Network docs, is this?
13:39:22 <koeien_> sampointon: yes
13:39:39 <koeien_> "All other [other than hClose] operations will fail."
13:39:43 <sampointon> koeien_: I really should have read those, I realise. I only read System.IO in great detail :)
13:40:36 <kadaver> i meant to implement a pure function in asm. i mean the coe generator have to be careful right? not to manipluate some register because some other vaue mgiht be there. so you ensure some sort of contract that functions must obey
13:41:08 <Heffalump> kadaver: things like LLVM and Harpy will sort that out for you.
13:41:24 <Heffalump> if you want to integrate deeply with GHC for absolute speed then that will be hard work
13:41:31 <Heffalump> I don't think the calling convention is documented or standardised
13:41:33 <sampointon> koeien_: in which case, seems like Network is being a bad citizen. The System.IO docs say that hGetChar raises an eof error if it's at the end of file, which would seem to be the right thing here too
13:42:09 <koeien_> sampointon: perhaps. hClose says that subsequent calls to hGetChar will fail, but does not specify in what way they'll fail
13:42:28 <koeien_> (the text was in System.IO by the way)
13:42:41 <Heffalump> hi Feuerbach
13:42:51 <sampointon> koeien_: yeah, but the eof error is specifically mentioned by the hGetChar description
13:43:00 * pumpkin_ is sitting outside in the sun, mmm
13:43:06 <sampointon> koeien_: this also begs the question of how to sanely do a multithreaded server
13:43:36 <FunctorSalad> pumpkin_: I read that it's too bright so I stay inside
13:43:37 <koeien_> hIsClosed, but then you have a race condition
13:43:41 <sampointon> koeien_: yep
13:43:47 <sampointon> koeien_: and a busy wait too
13:44:21 <koeien_> you can use Chans for messages
13:45:22 <koeien_> you can also end the thread if you get a bad file descriptor error
13:45:25 <sampointon> koeien_: hmm. That would require waiting on a Chan and a handle at the same time
13:45:40 <sampointon> koeien_: yeah, that's my thinking, but I don't know what else can cause that error
13:45:43 <pumpkin_> FunctorSalad: well, it's not too bright :)
13:45:55 <Heffalump> sampointon: is killing the thread remotely an option?
13:46:04 <Baughn> sampointon: The standard mechanism is something like "forkIO $ forever $ hRecv client >>= (putMVar chan . ClientMsg)"
13:46:18 <Baughn> sampointon: That is to say, to wait on multiple things, use multiple threads.
13:46:50 <sampointon> Heffalump: potential race condition again
13:47:56 <sampointon> Baughn: seems like an awful lot of infrastructure. 3+ threads for each connection?
13:48:03 * mofmog is amazed at how few registers are in an x86 machine
13:48:07 <Baughn> sampointon: They're lightweight threads
13:48:09 <osfameron> is currying monadic?  It seems to return a "normal" value at the end rather than one wrapped in a "currying monad"
13:48:14 <sampointon> Baughn: but I guess that's the best option so far
13:48:17 <jargonjustin> I'm having trouble getting GHC to produce an executable, using --make seems to only be producing object files, is there something I'm doing wrong or another step?
13:48:29 <koeien_> jargonjustin: did you define a 'main' function ?
13:48:29 <Baughn> jargonjustin: No, that should be it
13:48:47 <jargonjustin> koeien_: yep, main :: IO ()
13:48:59 <koeien_> sampointon: Haskell threads are very lightweight, you can spawn a lot of them without problems
13:49:01 <Baughn> jargonjustin: The main function must be in module Main (which is the default). Did you change that?
13:49:20 <jargonjustin> Baughn, ah no, I don't have a module main. I'll rename my script and give it another run
13:49:37 <Baughn> jargonjustin: It's the default. If you don't explicitly change the module name, it'll be Main.
13:49:43 <jargonjustin> Baughn, that did the trick, thanks!
13:49:48 <FunctorSalad> osfameron: hmm curry/uncurry are the isomorphism of an adjunction, so it should produce a monad like any adjunction
13:49:49 <jargonjustin> How would I go about changing it?
13:50:10 <koeien_> jargonjustin: changing what?
13:50:15 <Baughn> jargonjustin: I mean.. there's a "module Foo (...) where (...)" bit at the top of every .hs file, right?
13:50:25 <Baughn> jargonjustin: If you /don't/ include it, it defaults to "module Main () where"
13:50:42 <Baughn> jargonjustin: If you do, then that file can't be the entry point. Unless you explicitly set it to Main.
13:50:44 <osfameron> FunctorSalad: eeek!  that's a little over my head...  what I'm trying to do is (in Perl sorry, learning exercise) http://github.com/osfameron/acme--monads/blob/master/t/04_curry.t
13:50:48 <vixey> :t uncurry uncurry
13:50:50 <lambdabot> forall a b c. (a -> b -> c, (a, b)) -> c
13:51:01 <jargonjustin> Baughn, right is there a way to tell GHC to use a module Foo as if it were Main?
13:51:11 <ski> FunctorSalad : state
13:51:13 <Baughn> jargonjustin: Sure, the --main-is option
13:51:17 <koeien_> jargonjustin: --main-is
13:51:25 <jargonjustin> Baughn, koeien_, thanks!
13:51:31 <osfameron> at the end, I'm basically using "return" to return a normal value, rather than "munit" to return a wrapped value.  I'm not sure if they means I've misunderstood entirely, or if there's just a tweak I'd need to make for the approach to be useful
13:51:57 <FunctorSalad> ski: ah I suspected that... but I was still dizzy which one is the monad an which one the comonad here
13:52:31 <ski>   f a -> b
13:52:34 <sampointon> Baughn: also, if I'm using multiple threads to wait for either: a ConnectionClosed event from a Chan, or a Char from hGetChar, isn't there a race condition if hGetChar raises the 'invalid argument' error before the Chan can stop it?
13:52:34 <ski>   ========
13:52:35 <ski>   a -> g b
13:53:00 <ski> unit :: a -> (g . f) a
13:53:09 <ski> counit :: (f . g) b -> b
13:53:19 <ski> `g . f' is the monad, `f . g' is the comonad
13:53:23 <sampointon> Baughn: if you get what I mean. I can't control when that error will be thrown if I'm blocking on hGetChar
13:53:27 <Baughn> sampointon: There would be, yes. How do you get the COnnectionClosed event in the first place?
13:53:43 <sampointon> Baughn: presumably the writer thread would put it there when it calls hClose
13:53:53 <FunctorSalad> CoState a x = (a,a -> x) ? -- ski
13:54:00 <ski> `uncurry' maps from `f a -> b' to `a -> g b', `curry' in the other direction
13:54:09 <ski> FunctorSalad : state-in-context comonad, yes
13:54:10 <Baughn> sampointon: Huh? Hang on, are you using a pipe to communicate /inside one haskell process/?
13:54:36 <vixey> can you make Cont like that, with an adjunction?
13:54:41 <sampointon> Baughn: no, the pipe is external, but there are two threads: a writer thread and a reader thread, bth using the same Handle
13:54:43 * vixey (to see what co-Cont is)
13:54:59 <Baughn> sampointon: That's what I mean. Why would you do that?
13:55:13 <Baughn> sampointon: If the writer and reader threads need to communicate, why not have them use an MVar or a Chan?
13:55:21 <ski> the nice thing with state decomposed into `f' and `g' there is that `f' and `g' are both endofunctors
13:55:22 <sampointon> Baughn: the body of the MUD code is in STM
13:56:03 <Baughn> sampointon: I'm afraid I don't understand. How is that a reason?
13:56:04 <ski> there's nothing that guarantees "the" corresponding `f',`g' for e.g. the continuation monad to be endofunctors
13:56:24 <Baughn> sampointon: Why are you using a pipe at all?
13:56:39 <sampointon> Baughn: IO can't be done in STM, so it's buffered in TChans. The reader thread fills a TChan, and the writer thread writes from a TChan
13:56:42 <FunctorSalad> vixey: IIRC, you have (_ -> r) : Hask -> Hask^op, which is adjoint to itself?
13:56:50 <FunctorSalad> (to its op, more accurately)
13:56:54 <ski> you can decompose `Cont o' into `(-> o) . (-> o)', but that's not an adjunction (afaik)
13:57:12 <sampointon> Baughn: different TChans, too
13:57:15 <ski> (i'm not sure, actually)
13:57:42 <Baughn> sampointon: I think I'd need a diagram. Never mind, let me answer the more general question..
13:58:03 <Baughn> sampointon: If you have a control channel and a data channel, and the control channel can tell you both the channels are closing..
13:58:09 <FunctorSalad> ski: Hask(a,b -> o) ~ Hask^op(a -> o, b)
13:58:22 <FunctorSalad> the isomorphism being "flip" it seems
13:58:25 <Baughn> sampointon: ..you still need to handle EOF on the data channel, not least since the code on the other side may be buggy or malicious.
13:58:30 <ski> yes, you are correct
13:58:35 <Baughn> sampointon: So, yeah, hGetChar may throw an exception. Handle it.
13:58:55 <sampointon> Baughn: weirdly it works fine when the other end closes the socket, so that's not a problem (it seems)
14:00:00 <ski> istr, given a monad, one can make two extreme canonical decompositions into an adjunction : (a) via Kleisli category; (b) via Eilenberg-Moore category
14:00:21 <FunctorSalad> ski: yes, sounds right
14:00:32 <ski> (unfortunately, i know very little about Eilenberg-Moore ..)
14:00:40 <sampointon> Baughn: I think I see how to fix the race condition though, the writer thread just needs to wait until the reader thread confirms it's got the message before it actually calls hClose
14:00:45 <sampointon> Baughn: thanks!
14:00:47 <Baughn> sampointon: Socket? So, what kind of socket is this anyway? Unix domain socket? Network socket?
14:00:53 <sampointon> Baughn: netwok
14:01:06 <FunctorSalad> ski: it's just the category of F-algebras (if F is the 'free' part of the adjunction)
14:01:15 <sampointon> Baughn: the paste is simplified code from my MUD server
14:01:16 <Baughn> sampointon: ..why are you using a network socket to talk to yourself, anyway?
14:01:34 <sampointon> Baughn: well, atm it's talking to myself, but some day the MUD will have users :)
14:01:44 <ski> FunctorSalad : yes .. but what does that mean ? :)
14:01:46 <pumpkin_> :t liftW
14:01:47 <lambdabot> Not in scope: `liftW'
14:02:02 <Baughn> sampointon: And then it won't be possible to have some other way of detecting the socket being closed than, well, the socket closing
14:02:08 <ski>   liftW :: Comonad w => (a -> b) -> (w a -> w b)  -- ?
14:02:11 <Baughn> sampointon: Also. Paste?
14:02:21 <sampointon> Baughn: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2219
14:02:32 <pumpkin_> ski: yeah, I just wanted to see if lambdabot had category-extras
14:02:45 <McManiaC> @pl \d -> return $ d ++ ['a'] ++ "string"
14:02:45 <lambdabot> return . (++ "astring")
14:02:51 <sampointon> Baughn: heh, that discussion was likely to have been very confusing for you without that code for reference
14:03:00 <McManiaC> @pl \d -> return $ d ++ [c] ++ "string"
14:03:01 <lambdabot> return . (++ ([c] ++ "string"))
14:03:05 <Baughn> sampointon: NOt really. I see the problem now.
14:03:23 <Baughn> sampointon: I thought the reader and writer were connected to opposite ends of the same pipe. They're connected to separate pipes.
14:03:57 <Baughn> sampointon: TCP connections are two-way. Closing one half does not exactly close the other.
14:04:09 <FunctorSalad> ski: I think for the "algebraic" examples one actually recovers the category of algebraic structures (an F-algebra for F = "free monoid" being a monoid...)
14:04:21 <sampointon> Baughn: indeed, though I'd presumed that hClose did both
14:04:44 <Baughn> sampointon: That's impossible
14:04:57 <pumpkin_> edwardk: given up on your reimplementation of algebra in monoids?
14:05:04 <Baughn> Or at any rate would be a blatant misinterpretation of the POSIX spec
14:05:05 <pumpkin_> :)
14:05:07 <FunctorSalad> hmm it seems there's some coherence condition I'm missing which forces a function F S -> S to be a monoid (for F = free monoid, S a set)
14:05:30 <sampointon> Baughn: how do you mean? Telnetting to that server results in waiting for 1s, then having the connection closed
14:05:43 <Baughn> sampointon: Yes. The way this works..
14:05:57 <ski> `F' = "underlying set of free monoid of" ?
14:06:04 <Baughn> sampointon: You accept the connection. The writer waits one second, then closes the connection.
14:06:08 <FunctorSalad> ski: oh, right
14:06:18 <Baughn> sampointon: Telnet detects a remote close, and closes /its/ half of the connection.
14:06:19 <FunctorSalad> (so G F actually)
14:07:17 * ski has wondered a little whether one can define a category to be the one or other extreme adjunction splitting of a given monad ..
14:07:22 <sampointon> Baughn: yeah, but that would result in an eof error
14:08:00 <FunctorSalad> (more specifically, which condition forces the funcion GF S -> S to be the "eval" function of some monoid?)
14:08:00 <McManiaC> @pl \x -> p x >> h s >> g
14:08:00 <lambdabot> (>> g) . (>> h s) . p
14:08:04 <sampointon> Baughn: and it does, though the example is bugged in its handling of it :)
14:08:16 <sampointon> Baughn: umm, I mean, manually closing the connection
14:08:35 <Baughn> sampointon: Hang on. ISTR the GHC socket code is a mite screwy.. let me check something
14:08:52 <ski> S  >->  G . F $ S  >->  S  =  S
14:09:08 <ski> hm
14:10:51 <FunctorSalad> ski: yes (looked up the definition again) and the square involving the two paths (G.F.G.F) S >-> (G.F) S -> S
14:11:12 <FunctorSalad> (inner first or outer first)
14:11:31 <FunctorSalad> I mean, that is an axiom an "GF-Algebra" has to satisfy
14:12:41 <ski> yes, that was what i was trying to remember
14:15:31 <Baughn> sampointon: Can you add an `onException` handler to the hClose to make sure that actually completes correctly?
14:15:38 <Baughn> I have a sinking feeling about this.
14:16:19 <FunctorSalad> so a "list algebra" would be a function f: [A] -> A such that f [x] = x and f (join xss) = f (map f xss)
14:16:21 <Baughn> sampointon: Actually, not, this makes perfect sense, in a horrible way.
14:16:27 <pumpkin_> hmm, [] isn't a Comonad?
14:16:42 <Baughn> sampointon: The hClose closes the socket, and /closes the FD/, using close() instead of shutdown().
14:16:46 <FunctorSalad> ski: which forces f to be a fold with some associative unital binary operation I guess, IOW a monoid
14:17:03 <Baughn> sampointon: It fails to alter the Handle in any way. It's still storing the same FD number.
14:17:15 <Baughn> sampointon: Subsequent operations pretend it's still open, and thus get that error..
14:17:38 <sampointon> Baughn: that -would- explain the wording of the error
14:17:47 <Baughn> sampointon: ...but there's a race condition there. If you open a new socket/file between the hClose and a read - anywhere else in your program - you'd then read /that/ file instead
14:17:51 <Baughn> This is horrible
14:18:13 <sampointon> Baughn: yeah, looks like hClose is completing fine
14:18:23 <FunctorSalad> ski: e.g. f [f [x,y],z] = f (join [[x,y],z]) = f (join [x,[y,z]]) = f [x,f[y,z]]
14:18:50 <Baughn> sampointon: Yeah. I reported a bug a while back where hClose fails if the socket was closed remotely, but that's not it..
14:19:56 <ski> (pumpkin_ : not polymorphic in `A' ..)
14:20:07 <Baughn> sampointon: ..I'm not sure it's possible to write correct code here.
14:20:14 <Baughn> sampointon: Use Network.Socket instead
14:20:48 <Baughn> sampointon: Also, network-bytestring from hackage to simplify it a little
14:21:12 <pumpkin-> is [] not a Comonad instance?
14:21:18 <ski> FunctorSalad : i more or less remember this when you mention it .. but i don't think i have connected this to the right places in brain
14:21:23 <sampointon> Baughn: actually my code isn't using bytestrings yet >.> It's on my todo list
14:21:35 <ski> pumpkin- : there is no (total) `forall a. [a] -> a'
14:21:51 <Baughn> sampointon: No reason it should, really. It's a mud. Text decoding speed is /not/ an issue.
14:21:52 <sampointon> Baughn: unless network-bytestring has advantages besides the efficiency of bytestrings?
14:22:11 <Baughn> sampointon: It's a much, /much/ nicer interface to System.Socket than pointer manipulation
14:22:20 <pumpkin-> ski: I was just reading http://blog.sigfpe.com/2006/06/monads-kleisli-arrows-comonads-and.html and got the impression that duplicate on a list would give inits for that list, but maybe I misunderstood the post
14:22:27 <Baughn> sampointon: Layer utf8-string on top of that to get strings back
14:23:07 <Baughn> sampointon: The IO base code is up for a rewrite, but I don't expect you want to wait for ghc 6.12 or whatever
14:23:10 <sampointon> Baughn: does it share this problem I'm hitting up against, if it's more or less a drop-in replacement for Network?
14:23:22 <pumpkin-> ski: but yeah, I'm not sure how I'd write extend for it
14:23:25 <Baughn> sampointon: No, but it isn't
14:23:37 <Baughn> sampointon: Network.Socket is the raw BSD socket api
14:24:23 <Baughn> sampointon: Anyway, the sane way to shutdown a socket is to use Network.Socket.shutdown, not close
14:24:24 <FunctorSalad> ski: funny. I just had been thinking something similar (". o ( will I *ever* find this intuitive and obvious? )")
14:24:56 <Baughn> sampointon: (Well, you still need to close it at /some/ point, but you can do that after the reader and writer have both exited)
14:25:26 <Baughn> sampointon: Although, a different way to put that is that calling hClose on a socket when there are any threads waiting on it is the wrong thing to do. It shouldn't be, but..
14:26:13 <Baughn> sampointon: ..there are other reasons to use Network.Socket, though. Like that using Handles instead will make you leak file descriptors if the remote end closes abruptly
14:26:18 <sampointon> Baughn: as a stopgap, there's what you said before, with using a Chan to communicate. But if there's another race condition in there it ought to be avoided anyway
14:26:18 <Baughn> Which, for a mud, is prety much a certainty
14:26:28 <ski> FunctorSalad : similar to what ?
14:26:39 <Baughn> sampointon: That was based on a misunderstanding. Don't do it.
14:26:53 <Baughn> sampointon: But you don't want to leak FDs, do you? Don't use Handle.
14:27:06 <FunctorSalad> ski: "<ski> ... but i don't think i have connected this to the right places in brain"
14:27:28 <mc__> when I compile and run this program http://haskell.pastebin.com/m53513b17 it always hangs forever after outputting " [...] Collatz (113351,243)", but whe I triy to pass 113352 directly to iterCollatz, I get the result in a blink
14:27:46 <da-x> why 'let Just a = Nothing' evaluates? what's 'a' in that case?
14:27:56 <sampointon> Baughn: ok. Also, I just put an improved version of the testcase up on the paste, if you want to report the improper closing as a bug
14:27:58 <ski> pumpkin- : from "And in even more detail for the case of (lists considered as) streams." it appears to be not quite right
14:28:09 <pumpkin-> hmm
14:28:17 <Baughn> sampointon: Well, no. That bit's not actually a bug
14:28:20 <MyCatVerbs> da-x: a is (error "Pattern match failure...")
14:28:37 <Baughn> sampointon: It's more that it's your responsibility to kill readers before you close it.. actually, killThread should be fine for that
14:28:38 <MyCatVerbs> da-x: that won't necessarily blow up until you try to make use of a. But when you do, it definitely will.
14:28:52 <Baughn> sampointon: I'd /prefer/ it to be safe, but the standard doesn'T require it
14:28:53 <Asztal> Irrefutable pattern failed for pattern Data.Maybe.Just a
14:29:06 <Asztal> Why is it irrefutable?
14:29:10 <pumpkin-> did you put ~ in?
14:29:14 <sampointon> Baughn: hmm. killThread would need some careful careful thinking about race conditions
14:29:15 <Asztal> no
14:29:20 <pumpkin-> or Just a <- moo
14:29:44 <ski> pumpkin- : dpiponi there basically describes a function of type `forall a. Stream a -> Stream (List a)' .. which does not match `forall a. w a -> w (w a)'
14:30:01 <Baughn> sampointon: Wouldn't it? I think I'm going to rewrite Network myself.
14:30:06 <pumpkin-> ski: aha, so it's not quite a comonad
14:30:08 * Baughn needs a functional network module too
14:30:12 <roconnor> @hoolge anyof
14:30:12 <lambdabot> No results found
14:30:12 <ski> > let Just a = Nothing :: Maybe Int in ()
14:30:13 <sampointon> Baughn: in my application code I mean :)
14:30:14 <lambdabot>   ()
14:30:17 <ski> > let Just a = Nothing :: Maybe Int in a+1
14:30:18 <lambdabot>   * Exception: /tmp/8779504592271994986:71:40-68: Irrefutable pattern failed ...
14:30:33 <sampointon> Baughn: if there are extra race conditions in the network code, that's just extra fun
14:30:35 <Baughn> sampointon: Right, and you shouldn't have to do that
14:30:42 <Baughn> sampointon: And yeah. There are.
14:31:08 <ski> pumpkin- : you can make `Stream' into a comond .. but i think the closest to what dpiponi talked about there is the `NonEmptyList' comonad (since he talks about histories, and not futures)
14:31:18 <pumpkin-> hmm
14:31:34 <pumpkin-> but wouldn't the histories still be finite
14:31:36 <pumpkin-> and possibly empty?
14:32:44 <ski>   data NEList a = a :> [a]
14:32:52 <ski>   extract (a :> as) = a
14:35:52 <ski>   split as0@(_ :> as) = as0 :> loop as
14:35:57 <ski>     where
14:36:01 <ski>     loop [    ] = []
14:36:03 <ski>     loop (a:as) = (a :> as) : loop as
14:36:10 <ski> if i'm not mistaken
14:36:40 <athos_> :t (:>)
14:36:42 <lambdabot> Not in scope: data constructor `:>'
14:36:52 <athos_> >_>
14:36:53 <ski>   (:>) :: a -> [a] -> NEList a
14:37:13 <athos_> Okay.
14:37:19 <pumpkin-> does anyone know where I could get a simple adjacency matrix for web page linkages?
14:37:30 <pumpkin-> without having to parse html myself?
14:37:47 <pumpkin-> ski: I think I see
14:38:05 <ski> one way to think about this is to define
14:38:30 <ski>   data PosStream a = PS [a] a (Stream a)
14:38:49 <ski> the `[a]' is the history, the `Stream a' is the future
14:39:05 <pumpkin-> a bit like a zipper
14:39:11 <pumpkin-> but not quite
14:39:11 <pumpkin-> ?
14:39:12 <ski> yes
14:39:14 <ski> if you consider the stream
14:39:35 <ski> well, let's define
14:40:02 <ski>   data Stream a = a :< Stream a  -- just some differently named constructor
14:40:06 <ski> so
14:40:17 <ski>   0 :< 1 :< 2 :< 3 :< 4 :< ...
14:40:40 <ski> now, we say that we move the "current" time/position to `2' (as a zipper)
14:40:40 <ski> so
14:41:02 <ski>   PS (1 : 0 : []) 2 (3 :< 4 :< ...)
14:41:09 <ski> expresses this situation
14:41:31 <ski> this `PosStream' forms a comonad
14:41:39 <ski> we can define projections
14:41:53 <ski>   toNEList :: PosStream a -> NEList a
14:42:07 <ski>   toNEList (PS as a _) = a :> as
14:42:08 <pumpkin-> I see
14:42:19 <ski>   toStream :: PosStream a -> Stream a
14:42:27 <ski>   toSTream (PS _ a as) = a :< as
14:43:35 <ski> `NEList' is the comonad that has "causal" transformations (the "current" output value may depend both on "current" input and on "past" input)
14:44:21 <ski> while `Stream' is the comonad that as "anti-causal" transformations (the "current output value may depend both on "current input and on *"future"* input)
14:44:42 <ski> these transformations having form
14:44:49 <ski>   f :: w X -> w Y
14:44:57 <ski> for `w' being the comond in question
14:46:33 <alexsuraci> Is it a bug if running my code and it going into an infinite loop (which I still haven't found the cause for) doesn't cause GHC to kill it citing a stack overflow?
14:47:06 <Lemmih> alexsuraci: No.
14:47:17 <pumpkin-> it just means you didn't get a stack overflow
14:47:23 <pumpkin-> ...yet
14:47:27 <alexsuraci> figured, didn't know how possible that was yet
14:47:29 <pumpkin-> you might never!
14:47:39 <alexsuraci> well, it runs and fills my RAM to 100% and my computer starts to die, so I kill it
14:47:51 <pumpkin-> is it something like fix id?
14:47:55 <FunctorSalad> how do you write a pure loop that doesn't overflow?
14:48:36 <alexsuraci> pumpkin-: Not sure what that is
14:48:53 <pumpkin-> > fix id
14:48:54 <lambdabot>   * Exception: stack overflow
14:49:00 <pumpkin-> lol
14:49:36 <alexsuraci> reading up on it, no idea if that's the cause
14:50:11 <FunctorSalad> @src fix
14:50:11 <lambdabot> fix f = let x = f x in x
14:50:19 <alexsuraci> the problem just came out of nowhere, trying to trace it and had a problem where `show`ing one of the values halts the program as well (throwing it in a loop), with no output
14:50:50 <stork> can anyone give me a hand and tell me why this isn't parsing? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2223#a2223
14:51:27 <eu-prleu-peupeu> hi
14:51:50 <kosmikus> stork: that's not a parse error, but a type error
14:52:58 <stork> oh
14:52:59 <stork> my bad
14:53:51 <kosmikus> @type foldl
14:53:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:54:14 <alexsuraci> pumpkin-: I just ran "fix id" in my ghci and it just sat there, with no RAM/CPU increase, is that normal?
14:54:23 <pumpkin-> alexsuraci: yeah
14:54:43 <alexsuraci> Why wouldn't it cause a stack overflow like it did with lambdabot?
14:54:47 <kosmikus> stork: your needle is type String, your haystack is type [String[, so your addone function should have type String -> String -> String, but it hasn't
14:54:52 <centrinia> > fix id
14:54:53 <lambdabot>   * Exception: stack overflow
14:54:55 <stork> right
14:55:16 <stork> I'm confused, isn't foldl meant to sum up stuff? like keep a running total while it iterates over some data?
14:55:55 <kosmikus> that's a thing it can be used for. but "foldl" in general has nothing to do with the concept of computing a sum
14:56:01 <kosmikus> it's much more general than that
14:56:03 <alexsuraci> stork: foldl is for reducing something to a single value, generally. which has lots of applications, e.g. the length of a list
14:56:19 <stork> damn
14:56:22 <stork> so my approach was all wrong
14:56:31 <centrinia> foldl can also be used to construct a map function.
14:56:40 <LeoD> @src sum
14:56:40 <lambdabot> sum = foldl (+) 0
14:56:41 <FunctorSalad> it is like summing, except you get to insert anything for '+'
14:56:43 <pumpkin-> which makes a "single value" list out of it
14:56:46 <pumpkin-> :P
14:56:49 <kosmikus> stork: no, not necessarily
14:57:07 <skorpan> why is sum foldl and not foldr?
14:57:09 <centrinia> > foldl (\xs y -> (y+1):xs) [] [1,2,4,5]
14:57:10 <lambdabot>   [6,5,3,2]
14:57:24 <centrinia> It even reverses! :O
14:57:26 <FunctorSalad> it replaces all the ":"s by an operation of your choice
14:57:35 <FunctorSalad> (actually that's foldr)
14:57:55 <stork> that's witchcraft centrinia, put that shit away
14:57:56 <centrinia> > foldl (+) 0 [1,2,4,5]
14:57:58 <lambdabot>   12
14:58:05 <centrinia> > foldr (+) 0 [1,2,4,5]
14:58:06 <lambdabot>   12
14:59:50 <centrinia> > foldr (\y xs -> (foldr (+) 0 xs):xs) [] [1,2,4,5]
14:59:51 <lambdabot>   [0,0,0,0]
15:00:01 <centrinia> > foldr (\y xs -> (foldr (+) y xs):xs) [] [1,2,4,5]
15:00:01 <stork> owned
15:00:02 <lambdabot>   [31,16,9,5]
15:00:17 <stork> wtf is that?
15:00:26 <FunctorSalad> my thoughts
15:00:53 <centrinia> > foldr (\y xs -> (foldr (+) y xs):xs) [] [1,1,1,1]
15:00:54 <lambdabot>   [8,4,2,1]
15:01:00 <centrinia> Ah.
15:01:05 <stork> witchcraft.
15:01:44 <stork> > foldr (\y xs -> (foldr (+) y xs):xs) [] [1,1..]
15:01:46 <lambdabot>   [* Exception: stack overflow
15:01:54 <stork> > take 100 foldr (\y xs -> (foldr (+) y xs):xs) [] [1,1..]
15:01:55 <lambdabot>   Couldn't match expected type `[a]'
15:01:58 <vininim> > foldl (+) x [y,z]
15:02:00 <lambdabot>   x + y + z
15:02:00 <stork> aww
15:02:01 <skorpan> > take 100 $ foldr (\y xs -> (foldr (+) y xs):xs) [] [1,1..]
15:02:03 <vininim> > foldr (+) x [y,z]
15:02:05 <lambdabot>   [* Exception: stack overflow
15:02:05 <lambdabot>   y + (z + x)
15:02:28 <stork> what does the $ do?
15:02:28 <vininim> uhh... maybe f makes more sense
15:02:29 <jethr0> > scanl1 (+)  [1,2,3,4]
15:02:30 <lambdabot>   [1,3,6,10]
15:02:32 <centrinia> > uncurry (/) $ foldr (\y (s,l) -> (y+s,l+1)) [90,95,84,81,20]
15:02:33 <lambdabot>   Couldn't match expected type `(a, t)' against inferred type `[a1]'
15:02:35 <vininim> > foldr f x [y,z]
15:02:36 <lambdabot>   f y (f z x)
15:02:38 <vininim> > foldl f x [y,z]
15:02:39 <lambdabot>   f (f x y) z
15:02:53 <centrinia> > uncurry (/) $ foldr (\(s,l) y -> (y+s,l+1)) [90,95,84,81,20]
15:02:55 <lambdabot>       Occurs check: cannot construct the infinite type: b = (b, t)
15:02:55 <lambdabot>        Exp...
15:03:02 <FunctorSalad> > (reverse . take 4) iterate (*2) 1
15:03:03 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
15:03:11 <FunctorSalad> > (reverse . take 4) (iterate (*2) 1)
15:03:12 <lambdabot>   [8,4,2,1]
15:03:15 <pumpkin-> centrinia: fail
15:03:19 <FunctorSalad> that's the humane way to do it :p
15:04:07 <jethr0> what's with the output "f y (f z x)"? is that a write instance for functions??
15:05:17 <centrinia> > uncurry (/) . foldr (\y (s,l) -> (y+s,l+1)) (0,0) $ [90,95,84,81,20]
15:05:19 <lambdabot>   74.0
15:06:28 <jethr0> centrinia: is that a running average?
15:06:38 <alexsuraci> Found my problem. Yay.
15:06:43 <centrinia> Yes.
15:06:57 <centrinia> > uncurry (/) . foldr (\y (s,l) -> (y+s,l+1)) (0,0) $ [90,95,84,81]
15:06:58 <lambdabot>   87.5
15:07:37 <jethr0> > uncurry (/) . foldr (\y (s,l) -> (y+s,l+1)) (0,0) $ [1..1000000000]
15:07:39 <lambdabot>   * Exception: stack overflow
15:09:39 <pumpkin-> centrinia: like yves saint-laurent?
15:09:50 <pumpkin-> > uncurry (/) . foldl' (\(s,l) y -> (y+s,l+1)) (0,0) $ [1..1000000000]
15:10:09 <lambdabot>   mueval: Prelude.read: no parse
15:10:09 <pumpkin-> > uncurry (/) . foldl' (\(s,l) y -> (y+s,l+1)) (0,0) $ [1..10000000]
15:10:16 <Cale> Hmm... does anyone happen to know off-hand an easy way to model friction using Reactive?
15:10:25 <lambdabot>   thread killed
15:10:36 <pumpkin-> :(
15:10:50 <centrinia> > let agm' (a,g) = ((a+g)/2,sqrt (a*g)); agm tol x y = fst . until (\(a,g) -> abs (a,g) < tol) agm' $ (x,y) in agm 1 2
15:10:53 <lambdabot>       Overlapping instances for Show (a -> a)
15:10:53 <lambdabot>        arising from a use of `s...
15:11:01 <jethr0> it's all about strictness, tail-recursion and lambdabot's resource limitations ;)
15:11:04 <centrinia> > let agm' (a,g) = ((a+g)/2,sqrt (a*g)); agm tol x y = fst . until (\(a,g) -> abs (a,g) < tol) agm' $ (x,y) in agm 1e-5 1 2
15:11:06 <lambdabot>       No instance for (Fractional (a, a))
15:11:06 <lambdabot>        arising from the literal `1....
15:11:19 <pumpkin-> jethr0: given that I gave it the first two, I'd imagine it's the last :P
15:11:53 <jethr0> i wonder if you have to force the evaluation of the (+) applications
15:12:50 <wli> @type mapAccumL (\(n, s) x -> let n' = n + 1 ; s' = (fromIntegral n * s + x) / (fromIntegral n') in ((n', s'), s'))
15:12:52 <lambdabot> forall t x. (Fractional x, Integral t) => (t, x) -> [x] -> ((t, x), [x])
15:13:02 <jethr0> otherwise they might accumulate (like "0+1+2+...+1000000000"), which would be bad for the stack
15:13:16 <pumpkin-> jethr0: that was the point of the foldl'
15:13:45 <jethr0> k, even after all this time I'm still having trouble with strictness and space leaks ;(
15:13:56 <pumpkin-> @src foldl'
15:13:57 <lambdabot> foldl' f a []     = a
15:13:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:17:31 <alexsuraci> For anyone following, the source of the problem was the usage of "show" on a type that mutually referenced another type, resulting in an infinite string, which if course does not result in a stack overflow.
15:17:55 <alexsuraci> Just, no output, and your RAM/CPU usage skyrockets.
15:18:07 * alexsuraci should be more careful
15:18:34 <jethr0> ouch! and hard to find i imagine...
15:18:36 <olsner> would it be possible to have hoogle actually index the contents of packages on hackage rather than just package names?
15:18:44 <alexsuraci> jethr0: Yep, very. :P
15:20:11 <jethr0> not having stack traces and still lacking a full-blown debugger certainly take their toll in these situations.
15:20:49 <alexsuraci> yeah, all I had to go on was a heap profile, which didn't help at all (may be my lack of understanding of those)
15:21:46 <alexsuraci> I'll go celebrate my solving of that with an episode of Mythbusters. ;)
15:21:53 <jethr0> something like "hat" might have been of use, but seems not to be used/supported much any more
15:22:10 <jethr0> "the biggest explosion in Mythbuster history" ;)
15:23:44 <wli> > map (\(n, x) -> if n == 0 then 0 else x / fromIntegral n) $ scanl (\(n, s) x -> (n+1, s+x)) (0, 0) [1 .. 10]
15:23:46 <lambdabot>   [0.0,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0,5.5]
15:29:28 <olsner> @pl \f x -> f x x x
15:29:28 <lambdabot> join . join
15:30:29 <chessguy> @type join.join
15:30:30 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m a)) -> m a
15:30:54 <olsner> join f x = f x x, in the function monad
15:31:59 <jethr0> the function monad is still an enigma to me! simply haven't wrapped my head around it yet.
15:32:20 <jethr0> might be because i've never seen its definition and don't see on what data type it is defined
15:32:21 <ski> it's the same as `Reader', basically
15:32:28 <ski> aka environment monad
15:32:42 <jethr0> reader i get, but how does it work on functions (data types wise)?
15:32:58 <ski>   return x _ = x
15:33:18 <ski>   (f >>= k) rho = k (f rho) rho
15:33:31 <jethr0> "instance ? Monad where". What is "?" for the (->) monad?
15:33:32 <ski>   join f rho = f rho rho
15:33:52 <ski>   fmap f g rho = f (g rho)
15:34:07 <ski>   instance Monad (rho ->)
15:34:34 <jethr0> ok, thanks for the elaboration but i'm no wiser than i was before ^_^
15:34:39 <jethr0> let me ponder it a bit
15:34:43 <ski> except you have to say `((->) rho)' instead of `(rho ->)', because of no type sections
15:34:51 <dibblego> instance Monad ((->) t)
15:35:01 <gwern> @remember Anonymous As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
15:35:01 <lambdabot> I will never forget.
15:35:04 <gwern> @flush
15:35:15 <ski>   return :: a -> (rho ->) a
15:35:16 * Cale messes around with Reactive/FieldTrip... http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2224#a2224
15:35:20 <ski>   return :: a -> rho -> a
15:35:31 <gwern> @forget Anonymous As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
15:35:31 <lambdabot> Done.
15:35:36 <gwern> @remember OlinShivers As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
15:35:37 <lambdabot> Done.
15:35:39 <jethr0> what is rho supposed to be? a function or a function argument?
15:35:40 <gwern> @quote Olin
15:35:41 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
15:35:42 <ski>   (>>=) :: (rho ->) a -> (a -> (rho ->) b) -> (rho ->) b
15:35:56 <ski>   (>>=) :: (rho -> a) -> (a -> rho -> b) -> rho -> b
15:35:58 <gwern> @quote Olin
15:35:58 <lambdabot> astrolabe says: Below a certain level of competence, coding is a destructive act.  Like playing the violin.
15:36:04 <gwern> hm.
15:36:07 <gwern> @quote Shiver
15:36:07 <lambdabot> No quotes match. Are you on drugs?
15:36:08 <jethr0> hm
15:36:19 <gwern> @quote OlinShivers
15:36:19 <lambdabot> OlinShivers says: They look at me funny; they think I twitch a lot. I'm not twitching. I'm controlling my impulse to snag my 9mm Sig-Sauer out from my day-pack and make a few strong points about the
15:36:19 <lambdabot> quality of undergraduate education in Amerika.
15:36:26 <byorgey> jethr0: the type of some sort of "read-only environment"
15:36:37 <byorgey> jethr0: it's generally not a function, although it could be.
15:36:39 <astrolabe> I did not say that!
15:36:47 <ski> jethr0 : in the type signatures above, `rho' is the type of the function argument being distributed around (the "environment")
15:36:55 <gwern> @quote OlinShivers
15:36:55 <lambdabot> OlinShivers says: As my advisor said, the tragedy of Galois is that he could have contributed so much more to mathematics if he'd only spent more time on his markmanship.
15:37:12 <ski> jethr0 : in the definitions above, `rho' is a variable having type `rho'
15:37:13 <astrolabe> Oh.  Perhaps I did, a long time ago.
15:37:19 <gwern> @flush
15:37:20 <ski> (confusing naming ? yes :)
15:37:29 <byorgey> astrolabe: lambdabot does not lie!
15:37:42 <byorgey> @vixen do you ever lie?
15:37:43 <lambdabot> yes i do
15:37:49 <byorgey> ...oh.
15:37:50 <jethr0> hmm, so the (->) monad is really a reader specialized on functions? do you have to initialize rho with something like runFunctionMonad?
15:38:02 <ski> @vixen do you lie right now ?
15:38:03 <lambdabot> oh, good. i'm glad you think i'm right
15:38:06 <byorgey> jethr0: nope, it's just a general reader monad
15:38:17 <byorgey> jethr0: Reader r a  is just a newtype for  r -> a
15:38:35 <byorgey> jethr0: rho could be anything you like.
15:38:45 <jethr0> k, but with a normal reader monad you have to initialize the environment with runReader or the like, no?
15:38:51 <byorgey> like, say, a Map from variable names to values.  or the number three.
15:39:11 <byorgey> jethr0: right, in this case, to initialize the environment, you just apply the function.
15:39:38 <vixey> :t flip
15:39:39 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:39:45 <byorgey> since  if  m = ((->) r)  then  m a = r -> a.
15:39:49 <jethr0> *aahh*. not having programmed haskell in earnest in a while plus this weirdness makes my brain hurt...
15:40:00 <byorgey> hehe, that sounds normal =)
15:40:08 <chessguy> byorgey, the question is, can you believe vixey when she says she lies?
15:40:28 * jethr0 never tells the truth
15:40:38 <byorgey> chessguy: vixey, never.  but vixen, perhaps.
15:40:49 <chessguy> err, wh oops
15:40:50 <chessguy> haha
15:40:53 <byorgey> hehe =)
15:40:57 <jethr0> @vixen do you sometimes lie?
15:40:57 <lambdabot> why not always?
15:41:01 <chessguy> good catch
15:41:06 <gio123> does somebody knows  angelic and domenstic nondeterminism?
15:41:24 <jethr0> "domenstic"? daemonic?
15:41:58 <byorgey> no, domestic nondeterminism.  you know, like when you can't decide whether to watch a movie or play scrabble.
15:41:59 <jethr0> wasn't that something to do with continuations rather than nondeterminism?
15:42:00 <gio123> angelic and demonic nondeterminism
15:42:45 <gio123> where can i see defination of this?
15:43:08 <chessguy> see the paper "Angels and Demons" by Dan Brown (kidding)
15:43:12 <necroforest> So, I have this function 'randomList' that returns an infinite stream of random numbers; randomList :: (a,a) -> IO [a]
15:43:20 <idnar> chessguy: hahaha
15:43:28 <necroforest> I want to map this onto a pure function to do a simple primality test
15:43:31 <chessguy> ok, so it's a really long paper...
15:43:48 <necroforest> i.e map (test n) (take x (randomList (2,n-1)))
15:44:05 <necroforest> but "test" expects [a] insteaed of IO [a]
15:44:17 <gio123> where can i see defination of this?
15:44:21 <gio123> angelic and demonic nondeterminism
15:44:22 <gio123> ?
15:44:27 <jethr0> http://www.cs.chalmers.se/~augustss/AFP/problems/
15:44:27 <necroforest> how do i get rid of the 'IO' ?
15:44:29 <jethr0> ?
15:44:35 <jethr0> necroforest: hehe ;)
15:45:02 <jethr0> necroforest: the short answer is "you don't". the long answer is "you really don't want to". what are you trying to do?
15:45:13 <necroforest> jethr0, primality testing
15:45:14 <jethr0> @faq
15:45:14 <lambdabot> The answer is: Yes! Haskell can do that.
15:45:23 <jethr0> @where faq
15:45:48 <necroforest> run a test x times with different random numbers and 'and' the results
15:46:08 <jethr0> necroforest: basically, once you have something inside "IO" you cannot make it pure again, but rather have to use the IO value inside another IO action
15:46:25 <jethr0> until finally you call it from "main" which is of type "IO ()"
15:46:54 <jethr0> have you heard/read about using the IO monad in one of the haskell tutorials?
15:47:13 <necroforest> a little bit
15:47:26 <necroforest> i don't care if the final output of hte map is in the IO monad
15:47:30 <jethr0> if you want you can @paste the part of your code that is bothering you
15:47:32 <jethr0> @paste
15:47:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:47:54 <necroforest> that site is broked
15:48:42 <BONUS> ahaha lol. fix error
15:48:43 <necroforest> i think i want to use mapM
15:48:52 <BONUS> executing that in ghci
15:48:56 <jethr0> for example if you have "x :: IO Integer" and want to apply function "f :: Integer -> Integer" then you can use "x >>= f" or for more complex cases "do {x' <- x; return f x'}"
15:49:15 <FunctorSalad> BONUS: lol
15:49:31 <byorgey> or just "liftM f x "
15:49:32 <pumpkin_> @src mapM
15:49:32 <lambdabot> mapM f as = sequence (map f as)
15:50:25 <FunctorSalad> BONUS: I don't get why that throws more than once
15:50:31 <BONUS> me neither actually
15:50:36 <BONUS> trying to figure it out now
15:50:36 <jethr0> man, everything in my last line was wrong. i guess i'm too tired for this right now ;((
15:50:40 <FunctorSalad> fix error = let x = error x in x
15:50:46 <BONUS> it evaluates as error (error (error (error ...
15:50:54 <BONUS> ah sure
15:50:58 <BONUS> error takes a string
15:51:17 <BONUS> if you do error "blah", you get *** Exception: blah
15:51:20 <FunctorSalad> ok, so it specializes to error :: String -> String
15:51:27 <idnar> no
15:51:36 <BONUS> so here it does *** Exception: *** Exception: *** Exception
15:51:40 <FunctorSalad> but it doesn't *return* the error string
15:51:45 <FunctorSalad> it throws it
15:51:49 <idnar> when the exception occurs, it tries to print *** Exception: blah
15:51:53 <BONUS> yeah but it tries to print the string
15:51:57 <idnar> but it runs into another exception trying to print blah
15:51:57 <BONUS> so it has to evaluate it
15:51:58 <FunctorSalad> oh right
15:52:05 <BONUS> which is when the next one happens
15:52:10 <BONUS> how ironic that it's "fix error"
15:52:10 <FunctorSalad> I see
15:52:20 <idnar> o hai I fixed ur error!
15:52:24 <pumpkin_> why is it so hard to find a grammar for PDF?
15:52:41 <pumpkin_> there's an enormous spec file that I don't feel like reading to try to infer the grammar
15:52:44 <BONUS> pumpkin_: because I suspect that it's a jumbled mess much like all of adobe's formats
15:52:52 <BONUS> probably doesn't even have a grammar
15:52:57 <pumpkin_> hmm, maybe I shouldn't try to write a parser for it
15:53:50 <necroforest> hmm, what's wrong with this?
15:53:56 <necroforest> liftM (take 2) randomList
15:54:05 <necroforest> err, nm
15:54:09 <necroforest> got my types mixed up
15:55:12 <BONUS> tomorrow im gonna figure out why is it that ContT doesn't use the underlying monad's >>=
16:00:10 <necroforest> Hmm, is there a function like mapM that has a type signature :: (a -> m b) -> m [a] -> m [b] ?
16:00:20 <necroforest> mapM has no monad on the second parameter
16:01:16 <pumpkin_> :t sequence
16:01:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:01:45 <pumpkin_> necroforest: how would it behave?
16:02:06 <pumpkin_> you could liftM it and join
16:02:42 <necroforest> well, i want to map a list in the IO monad (IO [a]) accross a function a -> b and get IO [b] out
16:02:51 <necroforest> :t join
16:02:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:03:14 <dibblego> necroforest, fmap
16:03:21 <necroforest> :t fmap
16:03:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:03:24 <dibblego> er fmap . fmap
16:03:29 <dibblego> @type fmap . fmap
16:03:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:03:33 <necroforest> :t (fmap . fmap)
16:03:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:04:38 <byorgey> necroforest: that's because you need to lift the function  a -> b  across both the IO and the []
16:05:12 <BMeph> :t liftM
16:05:13 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:05:28 <BMeph> necroforest: ^^ -- like that? :)
16:05:38 <necroforest> well, i tried that
16:05:40 <jethr0> > (fmap . fmap) (+1) (return [1,2,3] :: Maybe [Int])
16:05:41 <lambdabot>   Just [2,3,4]
16:05:52 <necroforest> yeah, thats basically what i want
16:05:57 <BMeph> necroforest: Of course, fmap is just liftM "in its Original form." ;)
16:06:25 <pumpkin_> @type \f xs -> join ((liftM . mapM) f xs)
16:06:26 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
16:06:32 <byorgey> :t \f -> join . liftM (mapM f)
16:06:33 <pumpkin_> that's what I was talking about earlier
16:06:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
16:06:50 <byorgey> heh, good timing =)
16:06:52 <pumpkin_> :)
16:06:59 <byorgey> pumpkin_ wins
16:07:03 * pumpkin_ bows
16:07:32 <BMeph> necroforest: So, either "fmap . fmap" or "liftM . map" work. The second just makes it slightly more explicit as to what it is you're trying to do. It's all the same, though. :)
16:07:42 <byorgey> :t (join .) . (liftM . mapM)
16:07:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
16:07:44 <necroforest> ok, thanks
16:07:44 <dibblego> @type let k :: IO [Int]; k = undefined in (fmap . fmap) (+1) k
16:07:45 <lambdabot> IO [Int]
16:08:02 <pumpkin_> necroforest: but you'll need a join at the end, most probably :) which is what byorgey and mine did
16:08:07 <jethr0> sometimes i get the feeling that the whole IO monad thing is keeping us from getting real work done. these last minutes could be used as a joke on haskell for the question "how do I apply a function to a list of values"...
16:08:24 <BMeph> Oh, yeah - (a -> m b) -- yep, pumpkin wins. :)
16:08:24 <byorgey> it depends on the type of the function necroforest is mapping.
16:08:27 <ErhardtMundt> night
16:08:29 <dibblego> @type (<$>) <$> (<$>)
16:08:30 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:08:32 <jethr0> i know
16:08:44 <byorgey> I wasn't clear on that.
16:08:45 * pumpkin_ fmap fmap fmaps
16:08:49 <dibblego> necroforest doesn't want a -> m b
16:08:58 <pumpkin_> dibblego: that was his original question though
16:09:15 <jethr0> or just "do {xs <- ioList; return $ f xs}" for the less pure-minded ^_^
16:10:05 <necroforest> sorry if i wasn't very clear. my original function was a->b and i lifted it into a -> m b while trying to get it to work with mapM
16:11:08 <pumpkin_> oh, so you did want a -> b all along?
16:11:38 <necroforest> yeah
16:11:41 <pumpkin_> ah lol
16:11:50 <ski> @type (=<<) . mapM
16:11:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
16:11:52 <pumpkin_> so yeah, that's simpler )
16:12:08 <pumpkin_> ski: oh, that's much more elegant :)
16:12:33 <ski> ("obvious", no ?)
16:12:36 <gio123> ski: are you there?
16:12:45 <pumpkin_> ski: I guess so, in retrospect :P
16:12:56 <BMeph> jethr0: I much rather like "How do I apply a value to a list of functions?" ;p
16:12:58 <pumpkin_> gio123: sure doesn't look like it to me
16:14:23 <jethr0> > map ($4) [(+1), (*2), (+3)]
16:14:24 <lambdabot>   [5,8,7]
16:15:10 <pumpkin_> > [(+1), (*2), (+3)] `ap` [4]
16:15:11 <lambdabot>   [5,8,7]
16:15:18 <centrinia> I would rather like "How do I apply a list of values to a list of functions?" :p
16:15:35 <BMeph> > (map . flip id) 4 [succ,(*2),(2^)]
16:15:36 <lambdabot>   [5,8,16]
16:15:40 <pumpkin_> how do you apply values to functions?
16:15:48 <centrinia> > 4 id
16:15:49 <lambdabot>       No instance for (Num ((a -> a) -> a1))
16:15:49 <lambdabot>        arising from the literal ...
16:15:58 <centrinia> Beats me. :p
16:16:06 <BMeph> pumpkin: Think Churchly. ;p
16:16:12 <pumpkin_> lol
16:16:23 <vixey> > zipWith ($) [(+1), (*2), (+3)] [4,5,6]
16:16:24 <lambdabot>   [5,10,9]
16:17:10 <centrinia> > do { f <- [(+1),(*2),(+3)]; x <- [4,5,6]; return (f x) }
16:17:12 <lambdabot>   [5,6,7,8,10,12,7,8,9]
16:17:23 <BMeph> "Is it wrong that I reach for an LC textbook, when my folks tell me to 'go to church'?" ;p
16:17:24 <centrinia> @undo do { f <- [(+1),(*2),(+3)]; x <- [4,5,6]; return (f x) }
16:17:24 <lambdabot> [(+ 1), (* 2), (+ 3)] >>= \ f -> [4, 5, 6] >>= \ x -> return (f x)
16:17:32 <byorgey> > (id id) 6   -- a value applied to a function, amazing!
16:17:34 <lambdabot>   6
16:17:49 <pumpkin_> lol
16:18:14 <pumpkin_> > (\x -> x x) id 6
16:18:15 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
16:18:15 <lambdabot>    ...
16:18:17 <pumpkin_> :(
16:18:31 <jethr0> > [(+1), (*2)] >>= \f -> [1,2,3] >>= return . f
16:18:33 <lambdabot>   [2,3,4,2,4,6]
16:18:37 <centrinia> > map ($ 42) (take 10 $ iterate (`id` id)  id)
16:18:38 <lambdabot>       Occurs check: cannot construct the infinite type:
16:18:38 <lambdabot>        a = (a1 -> a1)...
16:19:29 <centrinia> > map ($ 42) (take 10 $ iterate (id `id`)  id)
16:19:30 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
16:19:43 <centrinia> > map (`id` 42) (take 10 `id` iterate (id `id`)  id)
16:19:44 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
16:19:48 <centrinia> There. :)
16:20:07 <jethr0> > map (const 42) (replicate 10 undefined)
16:20:08 <lambdabot>   [42,42,42,42,42,42,42,42,42,42]
16:22:13 <necroforest> BMeph, LC textbook?
16:22:27 * BMeph awards that match to jethr0!
16:22:44 <BMeph> necroforest: LC = "Lambda Calculus"
16:23:03 <necroforest> ah
16:23:14 * BMeph wants to see if he can be a preacher in the Church of Church!
16:23:17 * jethr0 taunts all other match participants
16:23:57 * necroforest wants to see Alan Turing vs. Alonzo Church mud wrestling
16:24:13 * BMeph lights jethr0's match
16:25:07 <jethr0> there are three commandments in the Church of Church: Alpha, Beta and Eta!
16:25:47 <jethr0> and Peano is its esteemed prophet
16:25:53 <dolio> What about iota?
16:25:56 <sampointon> it'd be better if omega had some conventional usage in the lambda calculus, then we could have alpha and omega
16:26:21 <jethr0> iota?
16:26:36 <jethr0> must be a later ammendment ^_^
16:26:37 <dolio> Coq has iota reduction, I think. I forget what it means.
16:26:38 <vixey> omega had some conventional usage in the lambda calculus -- omega is usually U U, U = \x -> x x
16:26:49 <dolio> Something to do with its data types.
16:26:52 <vixey> or omega just might mean any non terminating combinator
16:27:11 <rpglover64> Uh.. hi.  I have a question.
16:27:23 <vixey> coq doesn't have eta :(
16:27:45 <dolio> Neither does haskell.
16:28:17 <rpglover64> Is there any way to force haskell to interpret a source file even if there's an object file there?
16:28:31 <mauke> depends on your definition of "haskell"
16:28:38 <rpglover64> sorry
16:28:39 <rpglover64> ghci
16:28:50 <mauke> yeah, prefix the filename with *
16:29:24 <rpglover64> it says "Could not find module"
16:29:45 <necroforest> ghci *module ?
16:29:55 <necroforest> you might hav eto put a \* if you're on unix
16:30:08 <rpglover64> i'm using it from within ghci
16:30:17 <rpglover64> so :l *e26
16:30:25 <pumpkin_> :!ghci
16:30:30 <necroforest> rm -f <object file>
16:30:31 <necroforest> ;)
16:30:35 <rpglover64> where e26.hs is the name of the source file
16:30:36 <pumpkin_> YO DAWG, I HEARD YOU LIKED GHCI
16:30:39 <jethr0> yo umigh thav et opu ta \* i fyou'r e nunix
16:30:53 <rpglover64> well, yes, that _would_ work...
16:30:59 <necroforest> :(
16:31:01 <pumpkin_> jethr0: wow, that was impressive
16:31:10 <pumpkin_> lol
16:31:10 <dolio> mauke: What's your definition? Haskell 1.4?
16:31:45 <mauke> rpglover64: works here
16:31:59 <jethr0> that technique is amazingly effective at making something completely illegible *g*
16:32:00 <dolio> Oh, never mind, seq is still broken in 1.4.
16:33:34 <sampointon> jethr0: I wonder if that's down to the same kind of effect that makes you recognise words even if the middle letters are slightly jumbled. That is, fiddling with the start and end letters have a huge effect on readability
16:34:52 <jethr0> true.
16:41:34 <pumpkin_> Num a => Maybe a -> Maybe a -> Maybe a
16:41:46 <pumpkin_> how can I lift (-) into Maybe like that?
16:42:13 <pumpkin_> it takes two args, or I'd use fmap
16:42:30 <pumpkin_> (I mean elegantly) :P
16:42:30 <mauke> liftM2
16:42:36 <pumpkin_> oh, duh
16:43:27 <beelsebob> pumpkin_: <^(-)^>
16:43:32 <pumpkin_> lol
16:43:40 <pumpkin_> I don't do those weird infix applicatives
16:43:41 <mauke> :t (fmap .) . fmap (-)
16:43:42 <lambdabot> forall (f :: * -> *) a a1. (Num a1, Functor f) => (a -> a1) -> a -> f a1 -> f a1
16:43:53 <skorpan> :t liftM2
16:43:54 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:43:57 <mauke> :t fmap . fmap (-)
16:43:58 <lambdabot> forall a (f :: * -> *) a1. (Num a1, Functor f) => (a -> a1) -> f a -> f (a1 -> a1)
16:44:08 <pumpkin_> yeah, lift[MA]2 are perfect, I don't know why I didn't think of them
16:45:26 <rpglover64> mauke: so i make a file "e26.hs"; "e26.hs" does not have main; ghci -fobject-code e26.hs; this brings up ghci; :show modules gives Main ( e26.hs, e26.o ). :l *e26 does not work
16:46:21 <jethr0> > (-) <$> (Just 4) <*> (Just 5)
16:46:23 <lambdabot>   Just (-1)
16:46:46 <jethr0> @pl \a b ->  (-) <$> a <*> b
16:46:47 <lambdabot> (((-) <$>) .) . (<*>)
16:46:51 <jethr0> easy
16:47:23 <pumpkin_> that's equivalent to liftA2 :P
16:48:07 <beelsebob> > Just 4 <^(-)^> Just 5
16:48:08 <lambdabot>   Just (-1)
16:48:12 <pumpkin_> :P
16:48:32 <sampointon> <^(-)^> must be the best kind-of-operator I've ever seen
16:49:16 <beelsebob> > Just 4 <^(subtract)^> Just 5
16:49:17 <lambdabot>   Just 1
16:49:29 <jethr0> beelsebob: where is "<^" defined? i didn't find it in Applicative?
16:49:47 <beelsebob> jethr0: the InfixApplicative package on Hackage
16:49:53 <BONUS> > Just 3 <^(-)<*> Just 5
16:49:54 <lambdabot>   Just (-2)
16:50:03 <pumpkin_> lol, really clear
16:50:10 <beelsebob> hehe
16:50:13 <jethr0> oh, how very readable to the untrained observer...
16:50:22 <beelsebob> jethr0: hmm?
16:50:25 <BONUS> <^ = flip <$> it would seem
16:50:34 <beelsebob> <^ is indeed flip <$>
16:50:37 <beelsebob> and ^> is <*>
16:50:51 <BONUS> > Just 3 `flip <$>`(-)<*> Just 5
16:50:52 <lambdabot>   <no location info>: parse error on input `<$>'
16:51:01 <BONUS> > Just 3 `flip fmap`(-)<*> Just 5
16:51:02 <lambdabot>   <no location info>: parse error on input `fmap'
16:51:06 <BONUS> bleh
16:51:10 <sampointon> :t <^(<*>)^>
16:51:12 <lambdabot> parse error on input `<^'
16:51:25 <Gracenotes> haskell no likely many word in infix
16:51:35 <beelsebob> sampointon: unfortunately, it needs one or other side to have its argument provided :(
16:51:47 <beelsebob> but having said that â€“ if you don't want to use it infix, use liftA2 anyway :P
16:52:07 <sampointon> :t (<^(<*>)^>)
16:52:08 <lambdabot> parse error on input `)'
16:52:09 <Gracenotes> or <$> and <*>
16:52:20 <Gracenotes> :t (\a b -<^(<*>)^>)
16:52:22 <lambdabot> parse error on input `-<^'
16:52:29 <Gracenotes> premature enter
16:52:33 <Gracenotes> :t (\a b -> a <^(<*>)^> b)
16:52:35 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Applicative f, Applicative f1) => f (f1 (a -> b)) -> f (f1 a) -> f (f1 b)
16:55:10 <sampointon> > (pure 'h') <^(:)^> (pure "appyface!")
16:55:11 <lambdabot>       Ambiguous occurrence `pure'
16:55:11 <lambdabot>      It could refer to either `Control.Appl...
16:55:46 <pumpkin_> aw
16:56:08 <jethr0> i thought pure took a function
16:58:24 <Cale> jethr0: That's Control.Arrow.pure, rather than Control.Applicative.pure
16:58:41 <jethr0> oh
16:58:42 <BONUS> although in 6.10.x, pure is not in Control.Arrow anymore
16:59:04 <BONUS> which is cool cause it was just a synonym for arr, kind of like they placed it there just to introduce a name clash
16:59:28 <Cale> To be fair, Control.Arrow.pure was there first
16:59:42 * pumpkin_ never had the joy of 6.8
16:59:45 <ehird> So if the reverse state monad threads the state backwards ... can you thread the *computation* backwards?
17:00:10 <BONUS> what's the reason behind the name of pure in Control.Applicative
17:00:19 <BONUS> is it that it puts a value in a pure, default context
17:00:21 <BONUS> or what
17:00:23 <Cale> ehird: No, because >>= takes a function, and functions can't be applied in reverse.
17:00:32 <ehird> Cale: True enough.
17:00:36 <ehird> Darn. :)
17:00:46 <ehird> The "state reverse monad" would be fun.
17:01:45 <Cale> BONUS: Well, it constructs a computation which has no effects
17:02:03 <BONUS> yeah i thought so
17:20:39 <pumpkin_> \(JustS a) x -> JustS (f a x)
17:20:40 <pumpkin_> hmm
17:21:02 <pumpkin_> how can I write that interms of fmap? (JustS is a functor and behaves almost exactly like Just)
17:21:12 <pumpkin_> well, rather MaybeS is a functor and behaves almost exactly like Maybe
17:21:20 <pumpkin_> *in terms
17:21:43 <jethr0> @pl \(Just a) x -> Just (f a x)
17:21:43 <lambdabot> (line 1, column 8):
17:21:44 <lambdabot> unexpected "a"
17:21:44 <lambdabot> expecting operator or ")"
17:21:55 <BONUS> whre does the f come from
17:22:02 <Cale> conal: So I have a simple demo going where you can use the arrow keys to accelerate a disk. I'm curious what the easiest way would be to add a drag effect, a small acceleration opposite to the current velocity of the disk. The natural thing to write doesn't work for obvious reasons. Is there a way to 'infinitesimally' delay a behavior?
17:22:17 <EvilTerran> pumpkin_, i think that's fmap (flip f x)
17:22:20 <mauke> \m x -> fmap (\a -> f a x) m
17:22:25 <pumpkin_> oh, that would make sense
17:22:28 <pumpkin_> let me try that
17:22:52 <pumpkin_> hmm, not quite I don't thik
17:22:53 <EvilTerran> er, wait, the x comes after the JustS - you'd need to flip that again
17:22:54 <Cale> conal: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2224#a2224
17:23:36 <pumpkin_> hrm
17:23:47 <jethr0> cale, just talking here, but couldn't you add a factor when you calculate then new velocity "vel <- 0.9 * velCalculation"?
17:24:06 <EvilTerran> ?type flip fmap . flip ?f
17:24:07 <lambdabot> forall b a a1 c. (?f::a -> a1 -> c) => a1 -> (c -> b) -> a -> b
17:24:21 <EvilTerran> um
17:24:30 <mauke> :t flip (.) (flip f) . flip fmap
17:24:31 <lambdabot> forall a a1 c (f :: * -> *). (Functor f, SimpleReflect.FromExpr c, Show a, Show a1) => f a1 -> a -> f c
17:24:40 <Cale> jethr0: Normally, if the calculation was v' = v + a, I would just make it v' = 0.9 * v + a
17:24:46 <EvilTerran> ?type \f -> flip $ fmap . flip f
17:24:47 <lambdabot> forall a a1 (f :: * -> *) c. (Functor f) => (a1 -> a -> c) -> f a1 -> a -> f c
17:24:55 <Cale> jethr0: But in this case, I'm using reactive, and I have, velocity ui = integral (framePass ui) (accel ui)
17:24:58 <mauke> :t (. flip ?f) . flip fmap
17:24:58 <pumpkin_> mauke: that's  crazy but it works
17:24:59 <lambdabot> forall a a1 c (f :: * -> *). (Functor f, ?f::a -> a1 -> c) => f a -> a1 -> f c
17:25:17 <pumpkin_> mauke: what was it before you @pled it? :P
17:25:27 <mauke> pumpkin_: look 3 minutes into the past
17:25:37 <pumpkin_> oh I see
17:25:39 <pumpkin_> thanks
17:25:45 <Cale> jethr0: It's almost too declarative for its own good ;)
17:26:09 <mauke> @pl \m x -> fmap (\a -> f a x) m
17:26:09 <lambdabot> flip (fmap . flip f)
17:26:54 <pumpkin_> nice :)
17:27:00 <jethr0> Cale: i haven't used reactive, but i've used yampa and i think it should be possible to introduce a new acceleration depending on the velocity so that you have sth. like "velocity ui = integral (framePass ui) (accel ui + accel drag)" where drag is calculated as a derivate of the current velocity. but if it was easy you wouldn't be asking conal ;)
17:27:04 <pumpkin_> I almost had that but I wasn't composing
17:27:04 <Gracenotes> @pl x e = y a b c d e f g h
17:27:04 <lambdabot> x = flip (flip (flip (y a b c d) f) g) h
17:27:35 <Cale> jethr0: of the velocity we're defining right there?
17:27:52 <Cale> jethr0: My problem is that it becomes circular if you write the obvious equation :)
17:28:03 <jethr0> so? don't you have sth like fBy or whatever the function was called that accessed the last state of a variable?
17:28:09 <Cale> and I'm not sure if I'm expected to just solve the differential equation, or if there's another way
17:28:21 <Cale> That's what I'm asking for
17:28:29 <Cale> Behaviors are continuous though
17:28:34 <jethr0> hmm
17:29:04 <conal> Cale: what's the "obvious reason"?
17:29:22 <Cale> conal: It makes the equation circular and it becomes _|_
17:29:24 <jethr0> could you subtract from the acceleration before applying it (like "accel ui * 0.9")?
17:29:44 <Botje> @pl \x -> (\x -> burgers (,) x) . not $ bits x
17:29:44 <lambdabot> burgers (,) . not . bits
17:29:52 <Botje> @pl \x -> (\x -> burgers x (,) ) . not $ bits x
17:29:52 <lambdabot> flip burgers (,) . not . bits
17:29:54 <conal> Cale: probably a reactive bug.  that sort of circular equation (ODE) oughtn't produce bottom
17:30:02 <Cale> conal: hmm
17:30:32 <conal> Cale: i defined the semantics so that odes and self/mutually reactive systems would be well-defined.
17:31:34 <conal> Cale:  worked fine in fran and some other systems i've implemented.  has been tricky to implement correctly with reactive's efficient data-driven architecture.
17:32:01 <Cale> conal: Well, I can paste what it is that I tried.
17:32:34 <conal> Cale: better yet: would you please file a trac report?
17:32:40 <pumpkin_> wow, my epic folds are working finally
17:32:52 <conal> Cale: then it won't get lost
17:33:01 <pastah> whoa! 598 in here :D
17:33:05 <Cale> conal: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2226#a2226
17:33:08 <pastah> what is the current maximum?
17:33:18 <Cale> conal: Check that I'm not just doing something completely dumb if you will :)
17:33:42 <conal> Cale: i can't get to that port
17:33:45 <jethr0> @users
17:33:45 <lambdabot> Maximum users seen in #haskell: 658, currently: 598 (90.9%), active: 15 (2.5%)
17:33:47 <Cale> hmm
17:34:06 <conal> Cale: moonpatio works fine for me without the 8080
17:34:10 <Cale> ah, okay
17:34:18 <ehird> moonpatio.com=hpaste.org
17:34:25 <ehird> hmm
17:34:27 <ehird> not now it seems
17:34:40 <Cale> conal: Yeah, it still works without the :8080 :)
17:35:11 <conal> Cale: looks fine from a once-over.  i have to go now.  please do add a trac entry.
17:35:15 <Cale> okay
17:35:19 <conal> thx
17:39:08 <pumpkin_> boo, my epic folds aren't doing the right thing yet :(
17:39:46 <HeavensRevenge2> is hpaste.org borked??
17:52:09 <dolio> Epic folds?
17:52:56 <pumpkin_> dolio: trying to take taejo's blog post on fold composition/fusion further than he did
17:53:15 <dolio> Ah.
17:53:25 <pumpkin_> I have it all working, but it's significantly slower than the explicitly merged fold for some reason I have yet to figure out
17:57:02 <pumpkin_> what do I need to write to write a Show instance?
17:57:07 * michaelcdever is cabalising his file manager for release :D:D
17:57:31 <wli> showsPrec
18:01:45 <michaelcdever> hey, im setting up darcs, and I'm getting a darcs failed: Tree has already been initialized! error???
18:04:49 <jethr0> maybe you've done a "darcs initialize" already?
18:04:55 <michaelcdever> nope...
18:05:24 <jethr0> do you have a darcs directory in your work directory?
18:05:35 <michaelcdever> nope
18:05:50 <jethr0> hmm
18:06:28 <michaelcdever> hmm, sudo fixed it :<
18:07:15 <jethr0> sudo? for darcs? i assume you have user access rights for your working director?
18:07:35 <michaelcdever> yeah i do...
18:07:53 <jethr0> -    createDirectory darcsdir `catch`
18:07:54 <jethr0> -        (\e-> if isAlreadyExistsError e
18:07:57 <jethr0> -              then fail "Tree has already been initialized!"
18:08:12 <michaelcdever> maybe not actually, its a symlink to a folder on the host osx
18:08:16 <jethr0> very strange. can you create a directory as user?
18:08:19 <pumpkin_> hmm, whoops, I did it wrong
18:08:22 <jethr0> aahh
18:08:26 <michaelcdever> lol
18:08:33 <michaelcdever> i be an idiot
18:09:07 <pumpkin_> I've asked this before, but forgot the answer: how can I write foldl1 in terms of foldl, without pulling the head off the list explicitly (using a Maybe as the accumulator)
18:10:51 <jethr0> > let foldl1 f (x:xs) = foldl f x xs in foldl1 (+) [1,2,3]
18:10:52 <lambdabot>   6
18:10:57 <kpreid> > foldl (\acc v -> case acc of Just x -> Just (x + v); Nothing -> v) Nothing (1,2,3,4)
18:10:58 <lambdabot>       Occurs check: cannot construct the infinite type: b = Maybe b
18:10:58 <lambdabot>        Ex...
18:11:02 <jethr0> plus a case for single value or empty list?
18:11:02 <michaelcdever> if i want to add a folder with images to the darcs repo how do i do that?
18:11:05 <kpreid> > foldl (\acc v -> case acc of Just x -> Just (x + v); Nothing -> v) Nothing [1,2,3,4]
18:11:06 <lambdabot>       Occurs check: cannot construct the infinite type: b = Maybe b
18:11:06 <lambdabot>        Ex...
18:11:12 <michaelcdever> darcs add ./Icons/* ???
18:11:13 <pumpkin_> jethr0: as I said, without explicitly pulling the head off the list :P
18:11:14 <kpreid> > foldl Nothing (\acc v -> case acc of Just x -> Just (x + v); Nothing -> v) [1,2,3,4]
18:11:15 <lambdabot>   Couldn't match expected type `a -> b -> a'
18:11:28 <jethr0> :darcs add folder; darcs add folder/*" (i hope)
18:11:47 <kpreid> > foldl (\acc v -> case acc of Just x -> Just (x + v); Nothing -> Just v) Nothing [1,2,3,4]
18:11:48 <lambdabot>   Just 10
18:11:51 <pumpkin_> jethr0: my issue is that I need to "compose" this fold with other things
18:11:53 <kpreid> there we go
18:11:55 <michaelcdever> i just did darcs add Icons/* and it worked... well, no errors yet :D
18:12:00 <kpreid> :t maybe
18:12:00 <pumpkin_> kpreid: oh yeah, that makes sense, silly me :)
18:12:01 <pumpkin_> thanks
18:12:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:12:02 <jethr0> pumpkin: isn't the whole idea of the "1" in foldl1 to pull the head off explicitely?
18:12:04 <Gracenotes> pumpkin: didn't we already do this...? :.
18:12:11 <Gracenotes> with Maybe o_o
18:12:12 <pumpkin_> Gracenotes: yeah, as I said, I forgot the answer :P
18:12:20 <pumpkin_> ?
18:12:31 <Gracenotes> grep, mah friend
18:12:35 <jethr0> pumpkin: there is always the logs (http://tunes.org/~nef/logs/haskell/)
18:12:36 <kpreid> > foldl (\acc v -> maybe (Just v) (Just . (v+)) acc) [1,2,3,4]
18:12:37 <lambdabot>   Couldn't match expected type `Maybe b' against inferred type `[a]'
18:12:51 <pumpkin_> jethr0: I know, but I can't remember what day it was or what to grep for really :P
18:13:12 <Gracenotes> pumpkin.*foldl1. who knows :o
18:13:15 <jethr0> grep for foldl1 and your name, or something
18:13:22 <kpreid> > foldl (\acc v -> Just $ maybe v (v +) acc) [1,2,3,4]
18:13:23 <lambdabot>   Couldn't match expected type `Maybe b' against inferred type `[a]'
18:13:47 <kpreid> ok, what do I have wrong there?
18:14:04 <Gracenotes> you do need a starting value
18:14:14 <kpreid> > foldl (\acc v -> Just $ maybe v (v +) acc) Nothing [1,2,3,4]
18:14:16 <lambdabot>   Just 10
18:14:29 <kpreid> > foldl (Just . \acc v -> maybe v (v +) acc) Nothing [1,2,3,4]
18:14:30 <lambdabot>   Couldn't match expected type `b -> Maybe b1'
18:14:43 <pumpkin_> okay, it works!
18:14:57 <kpreid> @pl (\acc v -> Just $ maybe v (v +) acc)
18:14:57 <lambdabot> (Just .) . flip (ap maybe (+))
18:15:11 <kpreid> not an improvement
18:15:14 <pumpkin_> :)
18:15:16 <pumpkin_> thanks!
18:17:57 <olsner> > fix error
18:17:58 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:18:21 <ManateeLazyCat> Hi, all. :)
18:18:27 <olsner> > error (fix (1:))
18:18:28 <lambdabot>       No instance for (Num Char)
18:18:28 <lambdabot>        arising from the literal `1' at <inte...
18:21:25 <McManiaC> what happend to hpaste.org?
18:21:45 <pumpkin_> dunno, we'll have to wait until mmorrow comes back
18:22:00 <jethr0> > error . show $ fix (1:)
18:22:01 <lambdabot>   * Exception: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:22:03 <idnar> apparently the database is locked ;)
18:22:22 <pumpkin_> idnar: orly??
18:22:41 <pumpkin_> jethr0: that's a pretty exciting error
18:23:16 <jethr0> wait till you get to its end!
18:23:25 <jethr0> there's more
18:24:10 <idnar> yo dawg we heard you like errors
18:24:10 * pumpkin_ holds his breath
18:24:46 <Gracenotes> well, there's only one way to take care of that error
18:24:51 <Gracenotes> > fix error
18:24:53 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
18:24:57 <Gracenotes> D=
18:25:32 <Gracenotes> aw, already done, I see
18:25:47 <Gracenotes> well, surely the world could always do with more fix'd errors
18:26:21 <chessguy> @hoogle fix
18:26:21 <lambdabot> Data.Function fix :: (a -> a) -> a
18:26:22 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
18:26:22 <lambdabot> module Control.Monad.Fix
18:26:55 <pumpkin_> so something about my epic foldage is hiding fusion opportunities from ghc
18:27:28 <ManateeLazyCat> I put many modules in same directory. Those module is Manatee.ModuleName in file ModuleName.hs , when i use ghc build those modules, i will got error "Could not find module Manatee.ModuleName". Because those modules is not put at sub-direcotry "Manatee". But i found ghc won't report this problem with some package that use Cabal installed. Any tips? Thanks!
18:27:41 * Cale wants to hear "EPIC FOLDAGE" said by the Unreal Tournament announcer guy
18:27:51 <pumpkin_> lol
18:27:55 <pumpkin_> folding spree
18:28:06 <Cale> haha
18:28:30 <mauke> <pumpkin_> sorry, been very wrapped up in my folding
18:28:33 <ManateeLazyCat> Cabal register module place to GHC, so GHC won't complain?
18:30:37 <Cale> ManateeLazyCat: You can name the files Manatee.ModuleName.hs
18:30:46 <pumpkin_> manatees are cute
18:31:13 <Cale> ManateeLazyCat: Or you can create a cabal package and install it, but you'll still need to make a directory called Manatee, it just becomes part of the package.
18:31:57 <pumpkin_> harmonicF = bothWith (/) (fromIntegral `after` lengthF) (recip `before` sumF)
18:32:05 <pumpkin_> not too beautiful
18:32:08 <ManateeLazyCat> Cale: But i don't want do that. Have any super tips fix this problem and not need install? It's painful that i need install and i just want debug it
18:32:20 <Cale> ManateeLazyCat: you can also add it on the ghc commandline
18:32:32 <ManateeLazyCat> Cale: How?
18:32:50 <ManateeLazyCat> Cale: I use "ghc --make *.hs -o Manatee"
18:33:05 <Cale> ah, does that not work? Interesting.
18:33:05 <ManateeLazyCat> Cale: And above command line is work.
18:33:09 <Cale> oh
18:33:34 <ManateeLazyCat> Cale: But when some module contain "import {-# source #-} ...", it can't work.
18:34:05 <Cale> {-# source #-} ?
18:34:12 <ManateeLazyCat> Cale: GHC will complain it can't found some module if i write "{-# source #-}" in some module.
18:34:22 <ManateeLazyCat> Cale: I have two modules import each other.
18:34:26 <Cale> I don't get what that pragma means.
18:34:28 <Cale> oh
18:34:29 <Cale> hmm
18:34:42 <Cale> Usually I recommend avoiding mutually recursive modules.
18:34:48 <Cale> GHC is not good at handling them
18:34:52 <ManateeLazyCat> Cale: So i write "{-# source #-}" in module and create .hs-boot file for fix cycle import.
18:35:01 <Cale> Yeah, I've never done that myself
18:35:20 <ManateeLazyCat> Cale: It's unavoidable in big project.
18:35:37 <mauke> it's always avoidable
18:35:38 <sjanssen> ManateeLazyCat: it's never unavoidable
18:36:04 <ManateeLazyCat> I think problem is hope GHC can handle this problem self.
18:36:16 <ManateeLazyCat> I heard JHC have fix this problem.
18:36:46 <pumpkin_> the .hs-boot thing is ugly, and I think GHC could do a better job with it, but you can avoid circular dependencies too
18:36:49 <gwern> @quote DuncanCoutts Iâ€™m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
18:36:49 <lambdabot> No quotes for this person. Sorry.
18:36:54 <gwern> @remember DuncanCoutts Iâ€™m slightly embarrassed to admit that I spent three days at the Haskell Hackathon and wrote no Haskell code, only POSIX shell script and M4 autoconf macros!
18:36:55 <lambdabot> Good to know.
18:37:01 <pumpkin_> lol
18:37:34 <ManateeLazyCat> pumpkin_: Move some type or define from one to another to avoid cycle import?
18:37:56 <ManateeLazyCat> pumpkin_: But i want write code `module`, i just want some code in some file.
18:38:14 <ManateeLazyCat> pumpkin_: Then i can do interface, and not dump all code in one file.
18:38:35 <pumpkin_> then use .hs-boot :)
18:39:16 <ManateeLazyCat> pumpkin_: But GHC will complain it "can't found module" if i write {-# source #-} in some file. It's bug of GHC?
18:39:27 <michaelcdever> hmmm.... I'm getting an error about System.Posix.Files when doing runhaskell Setup build, its saying its hidden, but I dont get any errors when using ghc --make or ghci
18:39:56 <mauke> michaelcdever: is this a cabal package you wrote?
18:40:01 <michaelcdever> yep
18:40:16 <ManateeLazyCat> pumpkin_: Example, i write "import {-# source #-} Manatee.WindowsList" in file Window.hs, GHC will complain it can't found module `WindowsList`, even i use command "ghc --make *.hs -o Manatee"
18:41:02 <mauke> michaelcdever: list 'unix' in the build-depends part of your .cabal file
18:41:13 <michaelcdever> yep, just copped it
18:41:15 <michaelcdever> :d
18:42:13 <Rotaerk> is it wrong to treat a list like a .NET generic collection?
18:42:48 <Rotaerk> for instance, is "any" with a predicate passed to it (which checks equality to some value) comparable in performance to List.Contains
18:42:51 <michaelcdever> ok, another question, I depend on the FileManip package, which I know I have, but when I add it as a dependancy, it says at lease the following dependencies are missing FileMain -any   ???
18:43:20 <pumpkin_> gah
18:43:38 <mauke> > "FileManip" == "FileMain"
18:43:39 <lambdabot>   False
18:43:47 <QtPlaty[1ireMe]> Rotaerk: Are you hitting your specified time requirements?
18:43:48 <jethr0> Rotaerk: the comparison is probably a very dangerous one. lists are lazy for one thing. any is also lazy, meaning it stops when it finds one match
18:43:54 <pumpkin_> Foldable, is there no isEmpty or similar in it?
18:43:55 <michaelcdever> ah
18:44:00 <jethr0> > any (==1) [1,undefined]
18:44:01 <lambdabot>   True
18:44:27 <michaelcdever> sorry no idea what i was writing there, the error ends with FileManip -any not FileMain -any
18:44:30 <ManateeLazyCat> Cale: And i think make file named "Manatee.ModuleName" is stupid. If i need write module "A.B.C.D", i need named file with A.B.C.D.hs? And it's unnecessary. Have any tips tell GHC "ALL MODULE IS CURRENT DIRECTORY, JUST SEARCH IT!"?
18:44:45 <pumpkin_> I guess I could do null . toList on the Foldable instance but that feels ugly
18:44:55 <Rotaerk> I'm actually coding in F# atm, but I'm just trying to decide whether to use System.Collections.Generic.List versus the "list" type (which is probably very close to the haskell one)
18:45:06 <Cale> ManateeLazyCat: Try -i.
18:45:09 <jethr0> Rotaerk: also, lists have linear performance meaning that when you have performance issues lists are likely not your data type of choice. if you want to do lookups you could use for example a Data.Map instead
18:45:14 <Cale> (with the dot)
18:45:18 <ManateeLazyCat> Cale: Thanks.
18:45:24 <Rotaerk> hmm k
18:45:33 <Cale> ManateeLazyCat: Not sure if it will help.
18:45:48 <Rotaerk> so use lists only when they're meant to be processed primarily in a sequential fashion
18:45:53 <michaelcdever> any ideas?
18:45:58 <Rotaerk> rather than as versatile collection
18:46:09 <jethr0> i don't know much about F# so i'd be careful about drawing any comparisons between F# and haskell
18:46:20 <jethr0> yes
18:46:23 <Rotaerk> it's based on OCaml
18:46:30 <pumpkin_> and why doesn't foldable have foldl1' ?
18:46:32 <pumpkin_> grr
18:46:33 <pumpkin_> :P
18:46:38 <Rotaerk> and I'm pretty sure lists are comparable between the two
18:46:55 <Rotaerk> at least much more similar than either are to the .NET lists
18:46:56 <adamvo> @type foldr (const . const True) False
18:46:57 <lambdabot> forall a. [a] -> Bool
18:46:57 <jethr0> and even then there are sometimes reasons to switch to something else (for example for space use and maybe speed you might consider an unpacked array instead)
18:47:11 <dibblego> pumpkin_, doesn't need it, since it has foldl1
18:47:12 <mauke> michaelcdever: hmm, try runhaskell Setup configure --user
18:47:16 <jethr0> haskell is non-strict by default while ocaml is strict by default
18:47:22 <ManateeLazyCat> Cale: Can't work, i pass "-i ." to GHC.
18:47:33 <dibblego> @type Data.Foldable.foldr (\_ _ -> False) True
18:47:34 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> Bool
18:48:01 <Rotaerk> jethr0, ah
18:48:12 <michaelcdever> mauke: ahh, yep that worked
18:48:13 <michaelcdever> :D
18:48:22 <pumpkin_> dibblego: I know, I just didn't want to strictify it myself :P
18:48:34 <dibblego> pumpkin, it already is
18:48:43 <pumpkin_> foldl1 is strict?
18:48:50 <dibblego> iirc
18:48:57 <pumpkin_> why does Data.List have foldl1' then?
18:49:12 <adamvo> @check \x -> null x == foldr (const . const False) True x
18:49:13 <lambdabot>   "OK, passed 500 tests."
18:49:16 <dibblego> since Data.List.foldl1 uses foldl which is not strict
18:49:22 <ManateeLazyCat> Cale: Thanks for you help, i think i will add some "Makefile tips" to fix this problem.
18:49:39 <ManateeLazyCat> Thanks all. :)
18:49:47 <ManateeLazyCat> I love #haskell.
18:49:51 <Rotaerk> d'oh, System.Collections.Generic.List.Contains is linear anyway
18:49:53 <adamvo> > foldr (const . const False) True $ repeat ()
18:49:55 <lambdabot>   False
18:50:16 <michaelcdever> right fook it, im too tired to be doing this, it'll have to wait til tomorrow
18:50:22 <michaelcdever> nn all, thanks
18:50:34 <pumpkin_> dibblego: I find that puzzling, why would foldl1 be strict in Foldable but not in List?
18:50:47 <pumpkin_> we shouldn't have to know how they're implemented
18:51:14 <jethr0> well, we should know whether they are strict or not!
18:51:24 <adamvo> why did the null as foldr work for the infinite list?
18:51:41 <mauke> adamvo: why not?
18:51:47 <centrinia> @instances Foldable
18:51:47 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
18:51:53 <centrinia> @instances-importing Foldable
18:51:53 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
18:52:29 <pumpkin_> anyone have a better suggestion for null . toList on Foldable ?
18:52:32 <pumpkin_> to find if it's empty?
18:52:40 <pumpkin_> I'm trying to write foldl1Maybe on it
18:52:52 <adamvo> mauke: ah, I see now how laziness comes out of it
18:52:53 <mauke> > (const . const False) () (foldr undefined True [(),()..])
18:52:54 <lambdabot>   False
18:54:41 <adamvo> pumpkin_: a couple of minutes ago I wrote null in terms of foldr, but I think the  (null . toList) is clearer
18:54:54 <pumpkin_> oh I see
18:55:08 <centrinia> :t (==Nothing) . foldMap (const (Just ()))
18:55:10 <lambdabot> Not in scope: `foldMap'
18:55:18 <pumpkin_> the null. toList should only take O(1) though
18:55:41 <sjanssen> pumpkin_: for left associated structures, yes
18:55:50 <pumpkin_> oh, yeah
18:56:04 <pumpkin_> I can't believe there isn't a null in Foldable :P
18:56:24 <sjanssen> I think a foldr version is best
18:56:44 <pumpkin_> hmm
18:57:03 <ManateeLazyCat> Cale: I think named file with "Manatee.ModuleName.hs" can't work, i have try it, failed. I think GHC won't search "Manatee.Module.hs" first, it just split "Manatee.Module" and search "Module.hs" in sub-directory "Manatee".
18:57:18 <pumpkin_> sjanssen: won't that take O(n) to tell me something's not empty?
18:57:20 <Cale> Normally it does work
18:57:27 <pumpkin_> for a list, for example?
18:57:35 <sjanssen> pumpkin_: no, laziness
18:57:51 <mauke> Cale: wasn't that a JHC feature?
18:57:58 <sjanssen> > foldr (const $ const True) False [1 ..]
18:57:59 <lambdabot>   True
18:58:02 <Cale> ManateeLazyCat: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path
18:58:06 <pumpkin_> sjanssen: aha
18:58:14 <sjanssen> > foldr (const $ const False) True [1 ..] -- got that backwards
18:58:16 <lambdabot>   False
18:58:18 <centrinia> (==Nothing) . foldr (const (const (Just ()))) Nothing
18:58:23 <Cale> oh, hmm
18:58:32 <pumpkin_> I'll use the foldr then
18:58:32 <Cale> Maybe it really doesn't.
18:58:35 <sjanssen> centrinia: uh, why the Maybe?
18:58:46 <centrinia> sjanssen, Why the Bool?
18:58:51 <Cale> I was almost certain that I'd used that feature before
18:59:01 <Cale> ManateeLazyCat: Why not just make the directory?
18:59:17 <jethr0> > take 1 . reverse $ [undefined, 1]
18:59:19 <lambdabot>   [1]
18:59:28 <sjanssen> > (=="HAZ ELEMZ") . foldr (const $ const "HAZ ELEMZ") "NO HAZ ELEMZ" $ []
18:59:29 <lambdabot>   False
18:59:52 <pumpkin_> so now I just need to figure out why my folds are slow
19:00:01 <centrinia> Any datatype that contains at least two elements would work. :)
19:00:18 <ManateeLazyCat> Cale: I consider create directory and modified my Makefile.
19:00:43 <Cale> ManateeLazyCat: Any particular reason for using make?
19:00:53 <ManateeLazyCat> Cale: Emacs flymake.
19:01:02 <Cale> ah
19:01:25 <ManateeLazyCat> Cale: Flymake will check my syntax error at run-time.
19:01:39 <ManateeLazyCat> Cale: So i just compile it and won't got error.
19:03:01 <ManateeLazyCat> Cale: If now i'm writing Haskell code, flymake will copy my buffer and use GHC check whether have syntax error, then report place in my source code. Then i fix syntax error it. After i write complete, my source code is not syntax error, i just compile it.
19:03:19 <kadaver> "The unusual thing about Lisp-- in fact, the defining quality of Lisp-- is that it can be written in itself. " Paul Graham
19:03:25 <kadaver> all programming languages can be written in themselves right?
19:03:36 <ManateeLazyCat> Cale: Then it will save much time, otherwise, i need compile source code and got error then return to source code fix it.
19:03:47 <ManateeLazyCat> Cale: Why not fix syntax error in run-time?
19:04:35 <chessguy> kadaver, he's getting at code-as-data there i thinkk
19:04:42 <ManateeLazyCat> Cale: That's why i need Makefile.
19:04:43 <Cale> kadaver: If they're Turing complete, then yes.
19:05:35 <Cale> ManateeLazyCat: Okay. I only asked because usually make is a bit of a pain, and cabal is nice.
19:05:43 <ManateeLazyCat> Cale: Some module need special argument, and some module don't need it. Write those command everytimes is tired. So i write it in Makefile.
19:07:13 <jethr0> kadaver: not necessarily. a language may lack certain bit-twiddling functions necessary for its implementation... for most practical languages it is correct though.
19:07:13 <ManateeLazyCat> Cale: If i write "{-# OPTIONS_GHC -XFlexibleContexts #-}" in source code is better solution that avoid write different GHC argument with different source code.
19:07:26 <centrinia> Why does my array take less time to evaluate than my  function on an Int that returns an array? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2227#a2227
19:07:28 <ManateeLazyCat> s/If i/I think/
19:07:48 <jethr0> the beauty of lisp is how few lines it takes to implement eval and apply.
19:07:58 <Cale> ManateeLazyCat: Yeah, {-# LANGUAGE FlexibleContexts #-}  is better
19:08:06 <chessguy> jethr0, well that's a consequence of the beauty of lisp :)
19:08:45 <ManateeLazyCat> Cale: Have any different between "-# OPTIONS_GHC" and "-# LANGUAGE" ?
19:09:39 <Cale> ManateeLazyCat: LANGUAGE pragmas are supported by other Haskell interpreters and compilers
19:09:57 <Cale> But they only give you the equivalent of GHC's -X flags
19:10:13 <ManateeLazyCat> Cale: Oh, i see. Got a tips. Thanks :)
19:12:45 <ManateeLazyCat> Cale: But "{-# LANGUAGE PARAMETER #-}" will failed if other Haskell interpreters and compilers can't accept "PARAMETER"? Have a `standard` between different Haskell interpeters and compilers?
19:13:34 <ManateeLazyCat> Cale: I mean `standard interface` for different compilers and interprters.
19:14:04 <Cale> ManateeLazyCat: They'll know to report that they don't support the extension you're trying to ask for
19:14:19 <Cale> But many extensions are supported by Hugs as well as GHC
19:14:32 <thoughtpolice> and UHC! (and soon lhc)
19:14:41 <thoughtpolice> once i figure out how to steal ghc's entire frontend
19:56:13 <f4hy> LearnYouAHaskell mentions a function isInfixOf as being in Data.List but I don't see it there
19:56:35 <f4hy> is that function somewhere else? Or was it removed?
19:57:25 <plash> if you're using ghc, import Data.List to use isInfixOf
19:59:00 <plash> @hoogle isInfixOf
19:59:00 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
19:59:00 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
19:59:00 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
20:00:33 <f4hy> ok thanks
20:05:29 <f4hy> What is the best way to find all the locations of a given substirng. e.g. "is" "this is a test string" gives [2,5]
20:12:12 <plash> > let indexAll haystack needle = map snd . filter (isPrefixOf needle . fst) $ zip (tails haystack) [0..] in indexAll "this is test string" "is"
20:12:14 <lambdabot>   [2,5]
20:12:40 <plash> i think this is not best way to do it but it works
20:14:06 <f4hy> plash: thanks! I will play around with that
20:16:13 <f4hy> awesome
20:32:42 <vixey> <Gracenotes> â€®Ò‰ .What are you stari
20:32:54 <vixey> testing..
20:33:13 * vixey did not fix the IRC logs http://tunes.org/~nef/logs/haskell/09.04.25
20:33:27 <vixey> is it just me that half that textfile is backwards?
20:57:15 <rieux> i just uploaded a package to hackage and docs aren't appearing -- is there something i need to do to make that work?
20:58:22 <rdeshpande> hey guys
21:01:00 <thoughtpolice> rieux: they are processed in batches
21:01:05 <thoughtpolice> rieux: once every 12 hours i think
21:01:28 <rieux> i see.  i surmised that, but i looked at some recent packages, and it seemed like some newer ones have it and some older ones don't...
21:01:34 <rieux> but i'll wait and see for mine -- thanks.
21:03:46 <Cale> rieux: Sometimes if there's no documentation it's because there was a build failure on the hackage server
21:04:03 <Cale> rieux: But it tries to build the documentation, and there will be a log if it fails.
21:04:05 <rieux> yeah, i found something about that, but didn't see a fix
21:04:31 <rieux> ah.  are the logs publicly available?
21:04:46 <Cale> yes, it will link to them if there's a failure
21:05:11 <rieux> great, thanks
21:11:57 <pumpkin_> moo
21:11:59 <pumpkin_> it'd be nice if we could stick arbitrary expressions between backticks
21:12:01 <pumpkin_> as infix operators
21:12:03 <pumpkin_> x `liftM2 (-)` y kind of thing
21:17:06 <hotaru2k3> well you can do stuff like let f = liftM2 (-) in x `f` y
21:17:53 <xrfang> :t >
21:17:54 <lambdabot> parse error on input `>'
21:17:59 <xrfang> :t (>)
21:18:01 <lambdabot> forall a. (Ord a) => a -> a -> Bool
21:18:10 <pumpkin_> hotaru2k3: yeah, but that isn't as clear
21:18:15 <pumpkin_> (in my opinion :P)
21:18:31 <xrfang> why the ">" function needs a () to be used with :t?
21:18:46 <ray> it's an infix operator
21:18:56 <vixey> :t \x y -> x > y
21:18:57 <lambdabot> forall a. (Ord a) => a -> a -> Bool
21:19:09 <xrfang> ok tks ray
21:19:09 <ray> > 2 > 3
21:19:10 <lambdabot>   False
21:19:16 <ray> > (>) 2 3
21:19:17 <lambdabot>   False
21:19:28 <kerlo> > let inc x = x + 1 in (3 `inc`)
21:19:29 <lambdabot>   4
21:19:30 <ray> the parentheses let you use an infix operator like a regular function
21:19:31 <xrfang> :t elem
21:19:33 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:19:38 <xrfang> :t `elem`
21:19:39 <lambdabot> parse error on input ``'
21:19:47 <xrfang> 3 `elem` [1,2,3]
21:19:52 <xrfang> > 3 `elem` [1,2,3]
21:19:53 <lambdabot>   True
21:21:03 <xrfang> > compare 2 3
21:21:05 <lambdabot>   LT
21:22:12 <ray> letting you use infix and prefix where they're convenient is one of those killer haskell features
21:23:05 <xrfang> in ghci how can I check the type class of a type? e.g. Int => {Eq Ord} etc.
21:24:41 <kerlo> :i might be able to do that.
21:24:59 <xrfang> :i Int
21:25:16 <kerlo> :i definitely can tell you the instances of a class.
21:25:18 <ray> i don't think lambdabot has anything, but :i in ghci shows instances
21:25:34 <GoldyOrNugget> EvilTerran, can you continue helping me from last night?
21:25:43 <xrfang> ok, tks, bye for now continue later ;)
21:28:19 <pumpkin_> hmm
21:29:38 <ray> hmm, haskell
21:29:55 <pumpkin_> it's not inlining one of my functions
21:34:34 <GoldyOrNugget> how do you make a function which does nothing?
21:34:54 <ray> id
21:35:10 <vixey> GoldyOrNugget: no function does anything
21:35:31 <GoldyOrNugget> for my own filter function i want to do "filter' f x = (if f x then (x:) else ()) filter' f x"
21:35:46 <pumpkin_> I think my foldage is fundamentally flawed
21:36:02 <pumpkin_> so not quite as epic as I was hoping
21:36:06 <vixey> why don't you try to define it as a fold GoldyOrNugget?
21:37:09 <GoldyOrNugget> vixey, because i want to udnerstand this first
21:37:59 <pumpkin_> so I'm using a GADT to define fold combinators
21:38:18 <pumpkin_> and I have an applyFold function that simplifies the fold combinators and applies the fold
21:38:41 <pumpkin_> but I can't get it to apply fusion to the simplified fold
21:42:00 <Gracenotes> hm, my DFA minimization isn't going as well as I thought it would!
21:43:33 <Cale> GoldyOrNugget: id
21:43:42 <Cale> GoldyOrNugget: id x = x
21:44:16 <Cale> GoldyOrNugget: or you can explicitly write (\x -> x)
21:45:24 <adamvo> @pl \x -> f `id` x
21:45:24 <lambdabot> f
21:45:49 <pumpkin_> maybe I'm expecting too much from GHC
21:47:02 <pumpkin_> is there some way to say I want this partially applied function to be strictly partially applied? :P
21:49:54 <rdeshpande> should explicit type declaration on functions only occur when extra security is needed? or should it be applied to all functions?
21:50:03 <Axman6> pumpkin_: using lambdas?
21:50:04 <rdeshpande> what is the best practice for this?
21:50:20 <Axman6> f x y = \z -> g x x y y z z?
21:50:33 <pumpkin_> Axman6: well, so I'm constructing a function using combinators that I'd like to apply to values
21:50:48 <dolio> Many people recommend annotating all top-level functions.
21:50:54 <dolio> Or at least, most.
21:50:54 <pumpkin_> Axman6: the constructed function works fine, but fusion rules aren't firing
21:51:01 <Axman6> rdeshpande: up to you. it's usually a good idea, especially if you share the library since it gived good documentation
21:51:05 <pumpkin_> dolio: already told all of them to inline
21:51:22 <rdeshpande> does it have any performance benefit? i.e. ghc does not need to infer the types?
21:51:32 <dolio> pumpkin_: I was referring to rdeshpande's question.
21:51:34 <pumpkin_> oh :)
21:51:39 <Axman6> not really, GHC still checks the types anyway
21:52:37 <dolio> It can keep type errors more localized, so they're easier to find.
21:53:16 <rdeshpande> ah ok
21:53:20 <rdeshpande> thanks for the help
21:53:24 <rdeshpande> <-- haskell newbie :P
21:53:27 <dolio> It's conceivable that if you leave everything up to inference, the error that gets reported won't necessarily give you accurate information about what code you need to change.
21:54:18 <dolio> Since certain functions might get an inferred type that's okay, but isn't the one you want, and will cause errors where they're used, rather than where they're defined.
21:54:36 <dolio> (And so on.)
21:54:53 <Gracenotes> hm. Maybe I should just go straight with the O(n log n) algorithm instead of the more basic O(n^2) one
21:55:00 <rdeshpande> interesting
21:55:14 <rdeshpande> dolio: you wouldn't happen to have an example of this, would you?
21:55:28 <dolio> Not really. :)
21:55:51 <rdeshpande> also isn't it dangerous for ghc to infer the types multiple times during execution? why not just infer once and stick to it?
21:56:10 <dolio> Inference happens during compilation.
21:56:32 <rdeshpande> oh, right
21:58:15 <dolio> Writing type signatures shouldn't change the meaning of your program, unless you're using certain extensions, possibly.
21:58:58 <Axman6> or restricting the types for the function
21:59:15 <dolio> It might allow the optimizer to work somewhat better, if you give functions concrete types like "Int -> Int" where it'd otherwise be inferred as "a -> a" or something.
21:59:21 <Axman6> like add :: Integer -> Integer -> Integer; add = (+)
22:00:13 <dolio> Well, yeah, you could give types that aren't general enough to work, of course. That'd change the meaning, I suppose.
22:03:07 <dolio> There are only a couple situations where the compiler won't be able to infer the types needed without signatures, assuming the code is correct and you stick to Haskell98.
22:05:27 * kerlo attempts to write foldr while giving a type annotation to every subexpression
22:05:37 <pumpkin_> gah
22:05:43 <pumpkin_> I can't get my damn function to get out of the way
22:07:03 <Gracenotes> detonate it
22:07:06 <ivanm> Berengal: lol with your quote in HWN
22:07:20 <ivanm> Berengal: (both of them, actually...)
22:08:35 <pumpkin_> now I can't get at the stream representation of my uvector because it's hidden
22:23:08 <pumpkin_> > ([1..5], (+1)) <*> ([6..10], 5)
22:23:09 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],6)
22:33:12 <ivanm> @type <*>
22:33:14 <lambdabot> parse error on input `<*>'
22:33:18 <ivanm> @type (<*>)
22:33:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:33:25 <ivanm> I forget... is that fmap?
22:33:29 <pumpkin_> it's ap
22:33:34 <ivanm> ahhh
22:33:44 <pumpkin_> well, maybe not on pairs
22:33:45 <ivanm> how does it work for the lists above? where does the ++ come from?
22:33:53 <ivanm> > [1..5] <*> [6..10]
22:33:54 <lambdabot>       No instance for (Enum (a -> b))
22:33:55 <lambdabot>        arising from the arithmetic sequ...
22:34:03 <ivanm> :s
22:34:07 <pumpkin_> the applicative instance on (,) requires a monoid on the first
22:34:10 <pumpkin_> and mappends them
22:34:12 <pumpkin_> not sure why
22:34:13 <ivanm> ahhh
22:34:20 <ivanm> @instances Monoid
22:34:20 <pumpkin_> I don't think the monad instance does that does it?
22:34:20 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
22:34:31 <pumpkin_> > ([1..5], (+1)) `ap` ([6..10], 5)
22:34:32 <lambdabot>       No instance for (Monad ((,) [t]))
22:34:32 <lambdabot>        arising from a use of `ap' at ...
22:34:35 <ivanm> @src [] Monoid
22:34:36 <lambdabot> Source not found. My pet ferret can type better than you!
22:34:40 <ivanm> >_>
22:34:40 <pumpkin_> yeah, hmm
22:34:41 <dibblego> @users
22:34:41 <lambdabot> Maximum users seen in #haskell: 658, currently: 576 (87.5%), active: 12 (2.1%)
22:34:43 <dibblego> @users
22:34:43 <lambdabot> Maximum users seen in #haskell: 658, currently: 576 (87.5%), active: 12 (2.1%)
22:34:44 <ivanm> @src <*>
22:34:44 <lambdabot> Source not found. stty: unknown mode: doofus
22:34:44 <idnar> there's no (,) monad, is there?
22:34:52 <QtPlaty[HireMe]> case doesn't impose any strictness?
22:34:53 <pumpkin_> oh, guess not
22:34:55 <ivanm> dibblego: didn't you trust lambdabot the first time?
22:35:04 <dibblego> ivanm, bumped :)
22:35:09 <ivanm> idnar: I think there's an (a,) monad
22:35:14 <ivanm> @instances Monad
22:35:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
22:35:16 <pumpkin_> QtPlaty[HireMe]: it forces what you're matching against unless you have a ~ on the pattern
22:35:21 <ivanm> maybe not...
22:35:41 <Gracenotes> > case undefined of { _ -> 10 }
22:35:42 <lambdabot>   10
22:35:57 <pumpkin_> or that :P
22:36:58 <pumpkin_> so now I have two major challenges in my folds
22:37:09 <pumpkin_> 1) to allow sharing somehow (unlikely)
22:37:13 <pumpkin_> 2) to make the damn things fuse
22:37:23 <Gracenotes> The distinction between let matching and where matching is somewhat lost on me
22:37:33 <pumpkin_> Gracenotes: I didn't know there was one
22:37:51 <Gracenotes> I mean, case matching.
22:37:53 <Gracenotes> :o
22:37:56 <pumpkin_> oh
22:37:58 <thoughtpolice> pumpkin_: working on uvector?
22:38:18 <pumpkin_> thoughtpolice: not right now, although I'm working with it
22:38:40 <pumpkin_> my magic folds won't fuse
22:38:50 <thoughtpolice> pumpkin_: vacuum?
22:39:02 <pumpkin_> thoughtpolice: doubt it would help much here
22:39:05 <thoughtpolice> oh wait you said sharing; i might just be confused
22:39:16 <pumpkin_> oh, I meant a different kind of sharing :P
22:39:17 <thoughtpolice> yes
22:39:22 <pumpkin_> I'm building functions
22:39:34 <pumpkin_> and the functions I'm building are correct but refuse to fuse
22:40:06 <Gracenotes> @src partition
22:40:06 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
22:40:07 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
22:40:07 <lambdabot>                               | otherwise = (ts, x:fs)
22:40:11 <pumpkin_> what does __inline_me mean in ghc core?
22:40:14 <pumpkin_> I'd think it would mean to inline it
22:40:17 <pumpkin_> but it's not doing it :P
22:40:24 <pumpkin_> I have {-# INLINE function #-} on that function
22:40:31 <Gracenotes> surely all inline suggestions are just suggestions
22:41:01 <pumpkin_> yeah, but they're strong suggestions, and I see no reason for it not to inline this
22:41:18 <thoughtpolice> pumpkin_: how can you tell? core? where's the code?
22:42:00 <pumpkin_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2228#a2228
22:42:27 <pumpkin_> you see the unstreamU on the outside, an __inline_me in between, and a streamU on the inside
22:42:37 <pumpkin_> I just need to get them next to each other :P
22:43:18 <thoughtpolice> pumpkin_: i mean the actual code :)
22:43:52 <pumpkin_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2229#a2229
22:44:22 <thoughtpolice> yay
22:45:10 <pumpkin_> :)
22:45:31 <pumpkin_> if I can't get this working, I may ditch the GADT again
22:46:44 <pumpkin_> it gives me the ability to keep the entire structure around for large-scale transformations if I want them, but I'm not sure how much that buys me
22:47:04 <pumpkin_> this really isn't the kind of optimization I should be doing in code
22:48:00 <ivanm> pumpkin_: you're not meant to do optimizations? :s
22:48:34 <pumpkin_> well, I meant, it's something that I should really be doing somewhere on the compiler side rather than in a library-like thing
22:48:56 <pumpkin_> it's not even that useful, but I don't really have enough code transformation power outside of the compiler
22:50:04 <Axman6> hmm... i need to write a nice little assembly utility or something that'll run constantly to keep me warm
22:50:19 <Axman6> just loops around keeping the CPU working
22:50:35 <thoughtpolice> pumpkin_: don't you need a rewrite rule in order to specify fusion?
22:50:44 <pumpkin_> thoughtpolice: uvector has its own
22:51:07 <pumpkin_> thoughtpolice: I was hoping it would be enough to inline my function so as to put the streamU and unstreamU next to each other
22:51:18 <pumpkin_> it usually is
22:52:05 <pumpkin_> I could make a more hefty rewrite rule that catches unstreamU next to my applyFoldU and transforms that into a foldS
22:52:15 <pumpkin_> but foldS isn't exposed by uvector, and it'd feel hackish
23:01:09 <SnailRacer> is there something like filterBy :: (a->Bool) -> [a] ->[b] ->[b] somewhere?
23:02:28 <vixey> no you have to write it
23:02:40 <pumpkin_> okay, I'm pretty sure the GADT isn't disappearing :/
23:02:43 <vixey> try to do it without pattern matching only use filter and zip and so on
23:02:51 <vixey> why don't you paste the GADT code?
23:03:04 <pumpkin_> I did before
23:03:29 <pumpkin_> but I think I'm just misunderstanding
23:03:39 <pumpkin_> the constructors aren't disappearing
23:03:49 <vixey> well and then link it
23:04:02 <pumpkin_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2229#a2229
23:04:28 <SnailRacer> OK, I guess I can use zipWith and put them into Maybe, then filter on that
23:05:10 <vixey> since you have  applyFold,  then I don't think you also would use RULES
23:05:29 <vixey> maybe you aren't though
23:05:37 <idnar> @type filter
23:05:38 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:05:47 <pumpkin_> vixey: I'm not, but I expect my applyFold to "get out of the way" so the existing fusion rules can fire
23:05:47 <ivanm> gah... I can't just use the Data.Monad.Sum newtype wrapper to get a monoid instance on Ints to work properly... I need to use flexible instances! :@
23:05:50 <idnar> SnailRacer: what's the [b] for?
23:06:36 <da-x> is there a command-line equivalent of lambdabot I can download from somewhere?
23:06:37 <SnailRacer> just different types, the lists are the same length but different contents
23:06:41 <Peaker> da-x: hey
23:06:54 <Peaker> da-x: cabal install lambdabot  -- you can run it locally
23:06:54 <pumpkin_> but I think my main problem is that the compiler's never getting rid of the GADT constructors
23:06:56 <pumpkin_> anyway, bbiab
23:06:58 <Axman6> da-x: try lambdabot ;)
23:07:03 <Peaker> da-x: lambdabot doesn't easily compile on 6.10 though
23:07:06 <Axman6> it's on hackage
23:07:19 <idnar> @type \f xs ys -> map snd . filter (x `on` fst) (zip xs ys)
23:07:20 <lambdabot>     Couldn't match expected type `b -> b -> c'
23:07:20 <lambdabot>            against inferred type `Expr'
23:07:20 <lambdabot>     In the first argument of `on', namely `x'
23:07:22 <idnar> @type \f xs ys -> map snd . filter (f `on` fst) (zip xs ys)
23:07:23 <lambdabot>     Couldn't match expected type `Bool'
23:07:24 <lambdabot>            against inferred type `(a, b) -> c'
23:07:24 <lambdabot>     Probable cause: `on' is applied to too few arguments
23:07:31 <Peaker> da-x: http://haskell.org/haskellwiki/Lambdabot/Building
23:07:52 <idnar> @type \f xs ys -> map snd . filter (f `on` fst) $ (zip xs ys)
23:07:53 <lambdabot>     Couldn't match expected type `Bool'
23:07:53 <lambdabot>            against inferred type `(a, b) -> c'
23:07:53 <lambdabot>     Probable cause: `on' is applied to too few arguments
23:08:09 <ivanm> what does the undecidable instances extension do?
23:08:28 <idnar> ugh
23:08:34 <idnar> @type \f xs ys -> map snd . filter (f . fst) $ (zip xs ys)
23:08:36 <lambdabot> forall a b. (a -> Bool) -> [a] -> [b] -> [b]
23:08:39 <vixey> @let filteringMap p f = map f . filter p
23:08:40 <vixey> use this
23:08:40 <lambdabot>  Defined.
23:08:42 <da-x> actally, readline-1.0.1.0 failed to install
23:08:49 <vixey> it can be given an efficient implementation
23:08:58 <vixey> (map and filter are both folds)
23:09:11 <vixey> :t filteringMap ?p ?f . zip
23:09:12 <lambdabot>     Couldn't match expected type `[a]'
23:09:12 <lambdabot>            against inferred type `[b] -> [(a1, b)]'
23:09:12 <lambdabot>     Probable cause: `zip' is applied to too few arguments
23:09:36 <vixey> :t (filteringMap ?p ?f .) . zip
23:09:37 <lambdabot> forall b a b1. (?f::(a, b1) -> b, ?p::(a, b1) -> Bool) => [a] -> [b1] -> [b]
23:09:46 <idnar> @pl \f xs ys -> filteringMap (f . fst) snd (zip xs ys)
23:09:47 <lambdabot> (. zip) . (.) . flip filteringMap snd . (. fst)
23:09:47 <vixey> :t (filteringMap (?p . snd) ?f .) . zip
23:09:49 <lambdabot> forall b a b1. (?f::(a, b1) -> b, ?p::b1 -> Bool) => [a] -> [b1] -> [b]
23:10:00 <vixey> :t (filteringMap (?p . fst) snd .) . zip
23:10:02 <lambdabot> forall a b. (?p::a -> Bool) => [a] -> [b] -> [b]
23:10:02 <Peaker> da-x: for what reason? cabal install often fails due to missing headers
23:10:09 <Peaker> da-x: usually the solution is apt-get install somepackage-dev
23:10:26 <vixey> @let (..) = (.).(.)
23:10:27 <lambdabot>   Parse error
23:10:30 <vixey> @let (...) = (.).(.)
23:10:31 <lambdabot>  Defined.
23:10:37 <vixey> :t filteringMap (?p . fst) snd ... zip
23:10:38 <lambdabot> forall a b. (?p::a -> Bool) => [a] -> [b] -> [b]
23:10:41 <vixey> why can't you call it ..?
23:10:46 <vixey> .. is a good name isn't it?
23:11:51 <Axman6> because .. is reserved for lists isn't it? [1..10]
23:12:12 <vixey> oh yeah :(
23:12:31 <vixey> I think:  map f . filter p = foldr (\x ys -> f x : ys) [] . foldr (\x ys -> if p x then x : ys else ys) [] = foldr (\x ys -> if p x then f x : ys else ys) []
23:12:41 <vixey> but how do you go from the middle to the RHS?
23:12:52 <vixey> in general?
23:13:06 <da-x> Peaker: it's subtle... you need to have $HOME/.cabal/bin in $PATH but you have to figure it by yourself.
23:13:29 <da-x> yay, lambdabot works now.
23:14:12 <da-x> "lambdabot> list", I get "http://code.haskell.org/lambdabot/COMMANDS"
23:14:23 <da-x> that's silly.
23:14:26 <ivanm> Peaker: that is a really stupid "solution"
23:15:34 <vixey> foldr-fusion : {A B C : Set} ->
23:15:34 <vixey>   (h : B -> C) -> {f : A -> B -> B} -> {g : A -> C -> C} -> {z : B} ->
23:15:34 <vixey>    ((a : A) -> (b : B) -> h (f a b) â‰¡ g a (h b)) ->
23:15:34 <vixey>       âˆ€ (\x -> h (foldr f z x) â‰¡ foldr g (h z) x)
23:15:51 <vixey> that doesn't apply to this case does it?
23:15:53 <da-x> I mean, I have a complete, independent build of lambda bot. So, why the list command refers me to the Internet for the list of commands?
23:16:11 <ivanm> da-x: it's hard coded in, probably
23:17:33 <da-x> okay, so COMMANDS tells which external package provides which commands, that makes more sense
23:19:52 <hydo> In "data SM a = SM (S -> (a,S))", where does the S come from?
23:20:12 <vixey> hydo it should be defined earlier in the file or another module
23:20:14 <hydo> I'm assuming it's the current state of the monad?
23:20:25 <pumpkin_> so yeah, I realized I was expecting GHC to pattern match at compile time
23:20:25 <vixey> actually 'earlier' is nonsense -- it could be anywhere
23:20:29 <pumpkin_> which seems a bit much
23:20:31 <pumpkin_> there's a \ there
23:20:33 <pumpkin_> oh wait
23:20:35 <pumpkin_> lol
23:21:03 <vixey> do you know how to turn: map f . filter p
23:21:09 <vixey> into: foldr (\x ys -> if p x then f x : ys else ys) []
23:21:12 <vixey> ?
23:21:40 <hydo> vixey: Are you talking to me?
23:24:45 <Axman6> hydo: looks like the ST monad definition somewhat
23:24:48 <Axman6> @src ST
23:24:48 <lambdabot> newtype ST s a = ST (STRep s a)
23:24:57 <Axman6> ish...
23:25:24 <hydo> Yea, it's from a tutorial on the state monad.
23:27:16 <pumpkin_> it looks more like State to me than ST
23:27:30 <pumpkin_> although STRep is similar to State too
23:27:56 <vixey> hydo to anyone tdat could help me
23:28:17 <pumpkin_> vixey: oh, I thought you were being socratic with hydo
23:30:02 <pumpkin_> what do you mean by turn into?
23:31:46 <vixey> I define map f = foldr (\x ys -> f x : ys) [] ; filter p = foldr (\x ys -> if p x then x : ys else ys) []
23:32:06 <vixey> so can we transform  map f . filter p  into  foldr (\x ys -> if p x then f x : ys else ys) []
23:32:18 <vixey> and by transform I mean show they're equal without just inducting on the list
23:40:31 <pumpkin_> nice :D
23:40:37 <pumpkin_> removing the GADT allowed it to fuse
23:41:05 <Gracenotes> hurrah, sir.
23:44:02 <pumpkin_> and the code is simpler too
23:44:45 <vixey> glad I could help!!
23:45:17 <pumpkin_> :)
23:45:38 <pumpkin_> unfortunately, I can't do sharing in this system
23:45:56 <sjanssen> vixey: GHC automatically does the transform you mention
23:45:58 <pumpkin_> which means it's hard to do a numerically stable mean for example
23:46:02 <sjanssen> (assuming we're working on lists here)
23:46:18 <vixey> sjanssen: cool! I wonder how does GHC know to fuse together these folds?
23:46:28 <sjanssen> vixey: RULES pragmas
23:46:38 <pumpkin_> ?
23:46:58 <pumpkin_> oh, it doesn't fuse folds in general though
23:47:13 <pumpkin_> does it?
23:47:43 <pumpkin_> those just happen to be special list-producing folds
23:47:47 <vixey> I mean what is the justification of the RULE
23:47:48 <sjanssen> it fuses GHC.Base.{foldr,build}
23:47:49 <vixey> actually
23:47:55 <vixey> I will try to find this RULE
23:48:12 <sjanssen> vixey: see GHC/Base.lhs in a checkout of the base library
23:48:19 <dolio> foldr/augment, too.
23:48:35 <vixey> but I am not having foldr build, it's just foldr alone in my example (?)
23:48:41 <pumpkin_> so my fold for mean is faster than the one in Math.Statistics.Fusion
23:48:52 <sjanssen> vixey: yes, you'd need to use build to make it actually fuse
23:48:56 <vixey> :((((
23:48:57 <sjanssen> but this is a minor change
23:49:12 <mpwd> vixey:  Can you induct on lists in Haskell to prove two programs are equal?  I thought lazy lists were all about coinduction.
23:49:43 <vixey> mpwd: don't look under my rug that's all :p
23:49:44 <sjanssen> map f ys = build (\c n -> foldr (\x xs -> f x `c` xs) n ys)
23:49:49 <mc__> when I compile and run this program http://haskell.pastebin.com/m53513b17 it always hangs forever after outputting " [...] Collatz (113351,243)", but whe I triy to pass 113352 directly to iterCollatz, I get the result in a blink
23:49:54 <vixey> mpwd:
23:50:45 <zeno> @hoogle Int -> Float
23:50:46 <lambdabot> Prelude toEnum :: Enum a => Int -> a
23:50:46 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
23:50:46 <lambdabot> Prelude scaleFloat :: RealFloat a => Int -> a -> a
23:51:06 <zeno> > scalefloat 2
23:51:07 <lambdabot>   Not in scope: `scalefloat'
23:51:25 <zeno> > scaleFloat 2
23:51:26 <lambdabot>       Overlapping instances for Show (a -> a)
23:51:26 <lambdabot>        arising from a use of `s...
23:51:37 <copumpkin> can anyone think of a good way to share computation across parallel folds?
23:51:41 <zeno> > toEnum 2 :: Float
23:51:42 <lambdabot>   2.0
23:52:17 <copumpkin> I get the impression that I can't :P
23:52:21 <sjanssen> vixey: actually, I wonder if GHC could automatically introduce builds
23:52:40 <sjanssen> any expression that mentions (:) or [] can be rewritten to build
23:54:07 <QtPlaty[HireMe]> :t build
23:54:08 <lambdabot> Not in scope: `build'
23:54:27 <dolio> That might be complicated.
23:55:33 <dolio> If you rewrite "foldr (\_ xs -> [] : xs) [] l" into "build (\c n -> foldr (\_ xs -> n `c` xs) n l", that's likely to be wrong.
23:57:59 <dolio> Making the translation more type directed might solve that, but I don't know.
23:59:33 <sjanssen> dolio: hmm, yes
