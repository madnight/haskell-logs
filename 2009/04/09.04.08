00:00:01 <mib_i1xwpz8z> e.g.  case b of
00:00:05 <mib_i1xwpz8z> "" -> 1
00:00:08 <mib_i1xwpz8z> _ -> 0
00:00:11 <Saizan> you can't patten match on bytestrings
00:00:32 <Saizan> you've to use null in this case
00:00:40 <mib_i1xwpz8z> Okay, I guess I need an if statement to check if it's empty
00:00:46 <Saizan> ?type Data.Bytestring.Char8.null
00:00:47 <lambdabot> Couldn't find qualified module.
00:00:52 <Saizan> ?type Data.ByteString.Char8.null
00:00:53 <lambdabot> BSC.ByteString -> Bool
00:01:02 <Saizan> yeah, you can use guards
00:01:21 <Saizan> foo b | null b = ... | otherwise = ...
00:01:38 <mib_i1xwpz8z> Okay, I think that will get me going. Thanks.
00:02:09 <mib_i1xwpz8z> Saizan++
00:02:30 <mib_i1xwpz8z> Did I do the karma points right?
00:03:26 <lpsmith> Philippa__:  I should still be asleep,  but then I woke up.  ;-)
00:03:27 <Saizan> yup :)
00:04:40 <Philippa__> lpsmith: it's 8am here
00:07:41 <dan> :t repeat
00:07:42 <lambdabot> forall a. a -> [a]
00:07:49 <dan> :t repeate
00:07:50 <lambdabot> Not in scope: `repeate'
00:08:00 <dan> :t rep
00:08:01 <lambdabot> Not in scope: `rep'
00:08:03 <dan> hmm
00:08:09 <dan> @hoogle repeate
00:08:09 <lambdabot> No results found
00:08:11 <dan> waat
00:08:26 <kyagrd> does anyone know the url for "hello world" in java with Design Patterns, i believe it was in hpaste?
00:09:11 <kyagrd> It was fun and I tried to look it up again and I can't find it in my www browser history ...
00:10:31 <Saizan> dan: replicate?
00:10:37 <dan> oh yea..
00:10:40 <dan> :t replicate
00:10:41 <lambdabot> forall a. Int -> a -> [a]
00:10:54 <dan> > replicate 10 "hello"
00:10:55 <lambdabot>   ["hello","hello","hello","hello","hello","hello","hello","hello","hello","h...
00:10:57 <dan> cool
00:11:11 <dan> > replicate 10 'A'
00:11:12 <lambdabot>   "AAAAAAAAAA"
00:12:10 <rio> ++ "HH!" :P
00:12:24 <dan> xD
00:12:29 <dan> ?src replicate
00:12:30 <lambdabot> replicate n x = take n (repeat x)
00:12:36 <dan> i need replicate for some ml stuff
00:14:11 <Gracenotes> replicate works mainly because Haskell is lazy
00:14:23 <Gracenotes> you can define a recursive definition easily though. if ML doesn't have one already
00:15:22 <Gracenotes> using ML's pattern matching
00:18:20 <neoswish> hi, can anyone explain me how to stop cycles in import ? i.e. i want to import some function in module B from module A and vice a versa
00:19:13 <mjrosenb> what do i need to import to get Functor ((,),t) ?
00:20:05 <Gracenotes> instance Functor ((,) a) -- Defined in Control.Monad.Instances, according to :i Functor
00:20:30 <Gracenotes> it's also in Control.Applicative though
00:20:57 <Gracenotes> from CMI
00:22:25 <mjrosenb> also
00:22:38 <mjrosenb> trying to emulate >>= using `fmap` is *hard*
00:23:27 <Gracenotes> mm... it can't be done with only fmap though
00:24:40 <mjrosenb> it depends how big of a hammer you use
00:28:37 <mjrosenb> oh, that's the other function that i was using
00:29:27 <mjrosenb> pair :: m a -> m b -> m (a,b)
00:29:42 <neoswish> can anyone explain me how to stop cycles in import ? i want to import some function in module B from module A and vice a versa
00:30:01 <dan> does anyone here know ML?
00:30:06 <mjrosenb> dan: ja
00:30:24 <dan> can you tell me how to convert an ADT to a string ?
00:30:32 <Gracenotes> mjrosenb: oh, so a lax monoid?
00:30:37 <dan> such as derive show in haskell
00:30:50 <dan> or do i just need to make a function that returns strings, and carry it around when i need it
00:30:59 <mjrosenb> neoswish: you don't stop them.  you have ghc do a funky dance so they don't destroy the world
00:31:22 <mjrosenb> dan: write your own functions
00:31:27 <dan> rgr
00:31:37 <mjrosenb> if you're using sml/nj
00:31:46 <mjrosenb> you can define your own pretty-printer
00:31:59 <mjrosenb> but it's a *large* amount of black magic
00:32:04 <mjrosenb> and is not documented at all
00:32:37 <mjrosenb> however, that only pretty-prints things that the repl attempts to pretty-print for you
00:32:42 <Gracenotes> mjrosenb: the pair function is to do with a structure called a lax monoidal functor. apparently.
00:32:54 <Gracenotes> which is equivalent to the Applicative class
00:33:07 <mjrosenb> Gracenotes: i just called it pair.  it very well may have a different name
00:33:15 <Gracenotes> Applicative (pair) + Functor (fmap) = Monad. In a sense.
00:33:17 * mjrosenb needs to actually learn category theory
00:33:53 <Gracenotes> I'm not too familiar with the structure myself, but it's brought up in the Conor/Ross paper on Applicatives
00:34:18 <mjrosenb> well i got it by failing to write a parser combinator
00:35:12 <Gracenotes> a <*> b = fmap (uncurry id) (pair a b)
00:35:39 <Gracenotes> and pair a b = liftA2 (,) a b
00:36:03 <Gracenotes> <*> == ap
00:36:12 * beelsebob tries to understand what that's doing
00:36:23 * beelsebob can't help but get the feeling that it's an ininite loop
00:37:16 <mjrosenb> beelsebob: the definition of pair isn't using <*> at all
00:37:28 <beelsebob> mjrosenb: it's using something equivalent to it
00:37:40 <beelsebob> liftA2 f a b = f <$> a <*> b
00:38:00 <Gracenotes> it's brought up in the paper that they're isomorphic, that's all..
00:38:03 <beelsebob> but I'm struggling to see if it's on the same type
00:38:11 <beelsebob> ah, k
00:39:04 <Gracenotes> > let pair a b = liftA2 (,) a b in \a b -> fmap (uncurry id) (pair a b)
00:39:05 <lambdabot>       Overlapping instances for Show (f (b -> c) -> f b -> f c)
00:39:06 <lambdabot>        arisin...
00:39:15 <Gracenotes> @type let pair a b = liftA2 (,) a b in \a b -> fmap (uncurry id) (pair a b)
00:39:16 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
00:39:22 <Gracenotes> @type (<*>)
00:39:23 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:39:51 <Gracenotes> category theory is quite a neat perversion... :P
00:40:02 <beelsebob> haha
00:40:21 <beelsebob> that one even let you tie me up
00:40:25 <beelsebob> extra perverted :P
00:57:08 <boegel> yo gang
00:57:18 <boegel> a quick question (I have to catch my train in 5m)
00:58:07 <boegel> what would happen if I link a Haskell app using -threaded, and specify +RTS -N8 when I run it, without having used anything like par, pseq, parMap, or whatever?
00:58:28 <boegel> I would expect nothing to happen at all, i.e. it keeps running just one thread, but it seems like that's not the case
00:58:45 <boegel> I was seeing >700% CPU usage in top when specifying -N8, which surprised me
01:04:59 <mun> hi
01:05:10 <boegel> seems like it's too early/late to ask this here... I'll make another attempt later today, gotta run!
01:05:29 <mun> does anyone know what the => means in "class Show lid => Language lid"?
01:05:53 <doserj> Show is a superclass of Language
01:06:23 <doserj> i.e., every type that instantiates Language has to also instantiate Show
01:07:50 <mun> doserj: does the superclass usually need to be instantiated?
01:08:02 <anddy> hi
01:08:11 <anddy> what is RTS of GHC
01:08:39 <mc__> anddy: run-time system
01:08:44 <doserj> mun: I don't understand your question
01:09:09 <monadzilla> anyone know if there's a curses-esque library that is cross-platform?
01:09:16 <monadzilla> (as in works on windows and linux)
01:10:30 <anddy> sorry i wanted to know what RTS was forget about the ghc part
01:11:12 <anddy> Q does anyone use House os written in haskell
01:11:24 <anddy> Q does anyone use House os which is written in haskell
01:11:51 <mun> doserj: oh i get what you mean now. thanks
01:14:41 <mun> doserj: then with "class (Show a, Pretty a, Typeable a, ShATermConvertible a)   => PrintTypeConv a" does that mean Show, Pretty, Typeable, ShATermConvertible are all superclasses of PrintTypeConv?
01:15:01 <doserj> mun: yes
01:15:20 <mun> doserj: ah okay thanks
01:20:53 <dancor> @djinn (Monad m) => x -> m x
01:20:53 <lambdabot> Error: Class not found: Monad
01:21:36 <dancor> @djinn x -> Maybe x
01:21:36 <lambdabot> f = Just
01:21:39 <dancor> @djinn x -> Monad x
01:21:39 <lambdabot> Error: Undefined type Monad
01:27:40 <mun> can i use ghci to check the type of a constructor?
01:28:38 <doserj> sure, just like for any other function.
01:29:04 <mun> doserj: do i have to load in the module first?
01:29:27 <doserj> the constructor has to be in scope, of course
01:29:33 <mun> ok
01:29:34 <mun> thanks
01:37:46 <Gracenotes> @hoogle s -> (a, s)
01:37:46 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
01:37:46 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
01:37:46 <lambdabot> Control.Monad.State.Lazy runStateT :: StateT s m a -> s -> m (a, s)
01:38:06 <Gracenotes> @hoogle e -> s -> (a, s)
01:38:06 <lambdabot> Control.Monad.RWS.Lazy evalRWS :: RWS r w s a -> r -> s -> (a, w)
01:38:06 <lambdabot> Control.Monad.RWS.Strict evalRWS :: RWS r w s a -> r -> s -> (a, w)
01:38:06 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> d -> (a, d)) -> a -> d -> (a, d)
01:38:44 <Gracenotes> hm. surely there must be a few other functions that compose well with state
01:38:47 <Gracenotes> like splitAt
01:40:00 <mun> how many ways can => be interpreted? in a class definition, it can be interpreted as a super/child class relation, how about in "computeLocalLabelTheory :: Monad m => LibEnv -> DGNodeLab"?
01:40:30 <Gracenotes> hm. that seems.. unnecessary
01:40:40 <pozic> mun: as a compile error
01:40:59 <Gracenotes> you can have foo :: Monad m => Baz -> m Bar
01:41:02 <Gracenotes> for example
01:41:58 <mun> Gracenotes: right, but how is yours different to mine?
01:42:14 <mun> pozic: compile error?
01:42:38 <Gracenotes> it's just that m is actually used in mine,
01:42:44 <pozic> > undefined :: Monad m => ()
01:42:45 <lambdabot>   Add a type signature
01:43:14 <Gracenotes> if you have a typeclass constraint you should use it. This can result in a few sorts of errors.
01:43:14 <pozic> mun: undefined :: (Monad m) => ()
01:43:24 <pozic> mun: put that in ghci and see how it fails.
01:43:43 <Saizan> mun: bar :: Foo a => ..., means something like 'if a is an instance of Foo then bar has the type ..."
01:44:24 <mun> Gracenotes: so what does m Bar here mean?
01:44:42 <Gracenotes> @type let foo :: Monad m => String -> m Int; foo x = return (length x) in foo "Hello?"
01:44:44 <lambdabot> forall (m :: * -> *). (Monad m) => m Int
01:45:05 <Gracenotes> > let foo :: Monad m => String -> m Int; foo x = return (length x) in foo "Hello?" :: [Int]
01:45:06 <lambdabot>   [6]
01:46:13 <Gracenotes> in ghci (this was mentioned earlier, I think) if you don't specify the monad instance, it's just made into an IO Int
01:46:31 <Gracenotes> but foo can be used with any monad at all
01:48:06 <Gracenotes> so m Bar can be a Maybe Bar, [Bar], (a, Bar), IO Bar... etc
01:48:49 <Gracenotes> actually, not (a, Bar)
01:49:20 <Gracenotes> but (a -> Bar) would be allowed
01:52:38 <mun> ok thanks for that
01:58:51 <lpsmith> > System.Info.compilerVersion
01:58:52 <lambdabot>   /tmp/741930552334192794:70:32:
01:58:52 <lambdabot>      Not in scope: `System.Info.compilerVers...
02:14:26 <Axman6> @hoogle CReal
02:14:26 <lambdabot> No results found
02:14:30 <Axman6> ...
02:15:59 <Axman6> hmm, after upgrading to 6.10.2, ghc doesn't seem to know about any of my cabal-install installed libraries
02:17:36 <ejt> someone made a comment about cabal being broken on 6.10.2 yesterday
02:17:44 <Axman6> urgh
02:18:00 <ejt> I'm running one of the pre-releases, and that's working fine
02:21:36 <int-e> Axman6: that's normal, you have to reinstall them. there is no binary compatibility between ghc releases.
02:21:52 <Axman6> ...
02:22:11 <solidsnack> I read something recently about how MarkDown parsing is not too fast with Pandoc.
02:22:20 <Axman6> htf do i do that then? please tell me there's a simple command. i have hundreds of packages installed
02:22:58 <solidsnack> It looks like they are using Parsec with `String` -- so a `ByteString` Parsec could help.
02:23:12 <Gracenotes> oh, quite.
02:23:35 <solidsnack> However, I'm not sure what the state of that actually is -- I guess Parsec 3 has `ByteString`s but Parsec 3 is supposed to be beastly slow.
02:23:56 <solidsnack> Axman6: You are on *NIX ?
02:24:04 <Axman6> OS X
02:24:06 <Axman6> so yes
02:26:56 <solidsnack> Axman6: To get started: `ghc-pkg list`
02:27:39 <solidsnack> You'll notice there might be more than once package set in effect at once.
02:28:01 <Axman6> there's only one .cabal package, and that's one i just reinstalled
02:28:15 <solidsnack> Oh.
02:28:33 <solidsnack> Axman6: You still have the older ghc-pkg around though, I imagine.
02:29:02 <Axman6> no
02:29:05 <solidsnack> For example, I have `ghc-pkg-6.8.3` as well as `ghc-pkg-6.10.1`
02:30:45 <Saizan> Axman6: cabal-install is going to support a "world" file, but it's not there yet
02:31:19 <Axman6> Saizan: i've got the 6.8.3 one, but not the other one. i installed using macports, so the old one would have been overwritten
02:31:30 <Axman6> uh, solidsnack
02:31:38 <solidsnack> Yes?
02:31:46 <solidsnack> Hmm.
02:32:02 <solidsnack> Axman6: You upgraded from what to what?
02:32:13 <Axman6> 6.10.1 -> 6.10.2
02:33:50 <Axman6> i'm not happy that my almost 1GB .cabal folder is now apparently useless
02:34:25 <ivanm> Axman6: because you have to rebuild everything?
02:34:33 <Axman6> well yes
02:34:44 <Axman6> and because i don't know what everything is
02:35:07 <ivanm> Axman6: see, this is what you get when people use binary-based OSs/distributions
02:35:16 <ivanm> ;-)
02:36:15 <doserj> for i in `ls $HOME/.cabal/packages/hackage.haskell.org/` ; do cabal install $i ; done
02:36:28 <ivanm> doserj: do you need a * in there?
02:36:31 <solidsnack> ivanm: Well, it doesn't matter.
02:36:41 <ivanm> solidsnack: hmmm?
02:36:46 <solidsnack> ivanm: At present, source-based distros don't have very good support for Haskell.
02:37:01 <ivanm> solidsnack: I'd like to think that gentoo has good support for Haskell
02:37:31 <ivanm> considering we support a much larger range of package versions and architectures than arch, etc.
02:37:36 <solidsnack> ivanm: Consider also that the only OS X package managers are built on the BSD ports model.
02:37:42 <ivanm> and I'm told nix has good support
02:37:49 <doserj> ivanm: of course, one can also cd $HOME/.cabal/packages/hackage.haskell.org/ ; for i in * ; do cabal install $i ; done
02:37:53 <ivanm> solidsnack: you're referring to macport and fink?
02:38:02 <solidsnack> ivanm: Yes.
02:38:06 <ivanm> doserj: *nod*
02:38:22 <ivanm> solidsnack: well, gentoo's package management is based on the BSD ports model as well...
02:38:33 <solidsnack> ivanm: Yes.
02:38:37 <ivanm> and it's possible to have gentoo-prefix in OS X
02:39:00 <solidsnack> ivanm: All I'm saying is, this is not a source-based/package-based issue that Axman6 is having.
02:39:30 <ivanm> solidsnack: my original comment was referring to the fact that gentoo users are more used to having to rebuild half their system just because one package was upgraded
02:39:43 <solidsnack> ivanm: I administer Gentoo servers with an OS X machine. I use the prefix-portage so I have `ebuild` available for hashing.
02:39:56 <ivanm> *nod*
02:40:12 <solidsnack> ivanm: Yes, it's hard for people to get used to rebuilding for half a day and such.
02:40:40 <ivanm> OO.org is the worst :@
02:41:19 <solidsnack> ivanm: Yeah, what's the deal with a C++ program that requires you to build Java?
02:41:39 <ivanm> solidsnack: you don't _need_ java...
02:41:51 <solidsnack> If you set the flags right, yeah.
02:41:55 <ivanm> it's just that a lot of the wizards, etc. use Java
02:42:05 <solidsnack> ivanm: Last I checked, it couldn't export to HTML without Java.
02:42:14 <solidsnack> However, that was three years ago.
02:42:19 <ivanm> solidsnack: yeah, things like that
02:42:45 <ivanm> the only reasons I have Java installed are for OO, firefox plugin and I think there's one tex package (tex4ht maybe?) that needs it
02:43:24 <ivanm> does anyone know of any other implementations of graph isomorphism in haskell apart from jyp's hgal?
02:43:49 <ivanm> I found an IRC log from a year ago with Cale talking to someone else about it, but that's about it :s
02:44:09 <ivanm> oh, and a haskell version on reddit of the algorithm in a paper that most people thought was dodgy >_>
02:45:19 <solidsnack> ghc-pkg list | sed '/:$/ d' | sed 's/^    / / ; s/,$// ; s/,/\n/g ' | sed -r 's/-[^-]+$//' | sort | uniq | sed 's/^/cabal install/'
02:45:49 <solidsnack> Axman6: This will generate shell commands to install all the packages in your package list.
02:46:10 <solidsnack> For the future, I guess; it can't help you now :(
02:46:14 <Axman6> it would, if ghc-pkg knew about the packages i had installed
02:47:46 <Saizan> Axman6: check if you still have the old package.conf in ~/.ghc
02:48:12 <solidsnack> MacPorts should allow you to "reactivate" the old package.
02:48:32 <solidsnack> Though I'm not sure whether that will help you in all this.
02:48:40 <solidsnack> I rarely use the MacPorts system.
02:48:58 <solidsnack> ivanm: I haven't used Gentoo on the desktop in a while.
02:49:10 <Axman6> i didn't use macports to install the packages
02:49:17 <Saizan> you can point even the new ghc-pkg to it using -f package.conf, though you'd have most packages marked as broken
02:49:29 <solidsnack> Axman6: Yes, but I mean it will restore the old package.conf held by GHC.
02:49:35 <Axman6> i'm trying what doserj suggested, and it seems to be working
02:49:45 <solidsnack> That's a good method, too.
02:49:49 <Axman6> oh, no, i doubt that
02:50:09 <solidsnack> On a system where you have mostly global packages, though, it is more problematic.
02:50:26 <Axman6> all my packages were in .cabal
02:57:38 <Cale> ivanm: Isn't hgal an implementation of the algorithm that nauty uses?
02:57:49 <ivanm> Cale: it's _very_ slow :s
02:58:07 <ivanm> I tried reading through the paper nauty is based on, but it isn't easy to understand :s
02:58:19 <ivanm> (being an old-school type-writer-style one doesn't help :s )
03:02:32 <wli> Ah, yes, the days before (La)TeX.
03:03:37 <TSC> ivanm: Is that the one by McDonald?
03:05:33 <ivanm> TSC: no, by McKay
03:05:50 <TSC> Ah, that's who I meant (:
03:06:01 <TSC> I tried to read that once, I think
03:10:23 <dancor> lol :: (Monad m) => (m a -> m (Bool, (a, b))) -> m (a, b) -> m (Bool, (a, b))
03:10:34 <dancor> is it possible to do that
03:10:50 <dancor> (lol f) is f applied to the first elem of the tuple
03:11:47 <Saizan> lol f m = do (a,_) <- m; f (return a)
03:12:00 <Saizan> or
03:12:10 <Saizan> lol f m = f (fmap snd m)
03:12:18 <Saizan> the two are not equivalent
03:12:37 <dmhouse> fmap fst, surely.
03:12:40 <Saizan> err s/snd/fst/
03:12:42 <Saizan> yeah
03:13:06 * dancor tries to see how not equivalent
03:13:46 <Gracenotes> @src liftM
03:13:46 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
03:13:51 <Gracenotes> == fmap
03:14:33 <Gracenotes> so... hrm
03:14:36 <ivanm> Gracenotes: is that _guaranteed_ ?
03:14:43 <Gracenotes> hm... doesn't a monad law requires them to be equivalent?
03:14:47 <Gracenotes> -s
03:14:48 <ivanm> Gracenotes: no
03:14:58 <Saizan> > let f m = return 1; lol f m = do (a,_) <- m; f (return a); in f Nothing
03:14:59 <lambdabot>       No instance for (Show (m t))
03:14:59 <lambdabot>        arising from a use of `show' at <in...
03:15:03 <ivanm> because the monad laws were stated before the Functor class was developed AFAIK
03:15:17 <dancor> (m >>= f . return . fst)   vs   (f $ fmap fst m)
03:15:37 <Gracenotes> ivanm: that f (liftM snd m)?
03:15:59 <Saizan> > let f m = return 1; lol f m = do (a,_) <- m; f (return a); in lol f Nothing
03:16:00 <lambdabot>   Add a type signature
03:16:08 <Saizan> ?type let f m = return 1; lol f m = do (a,_) <- m; f (return a); in lol f Nothing
03:16:09 <lambdabot>     Ambiguous type variable `m' in the constraint:
03:16:09 <lambdabot>       `Monad m' arising from a use of `lol' at <interactive>:1:62-74
03:16:09 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
03:16:19 <ivanm> Gracenotes: tbh, I have no idea ;-)
03:16:26 <ivanm> I'm going off memory here
03:16:36 * ivanm normally doesn't directly use monads, functors, etc.
03:16:37 <mun> with "let a (b, c) d = do ..." does that mean the monad should return 3 things?
03:17:01 <Saizan> mun: that's defining a function named 'a'
03:17:19 <mun> ooh!
03:17:22 <Gracenotes> I mean, the >>= and return monad laws can be derived from the join/fmap laws, and vice versa
03:17:50 <Saizan> , [$ty| let f m = return 1; lol f m = do (a,_) <- m; f (return a); in lol f Nothing |]
03:17:54 <lunabot>  luna: Exception when trying to run compile-time code:
03:18:00 <mun> Saizan: so a takes in two arguments: (b, c) and d?
03:18:07 <Saizan> mun: yes
03:18:09 <Gracenotes> Saizan: might you need braces?
03:18:17 <Saizan> Gracenotes: maybe
03:20:09 <Saizan> ?type let f m = return 1; lol f m = do {(a,_) <- m; f (return a `asTypeOf` fmap fst m) } in lol f Nothing
03:20:10 <lambdabot> forall t. (Num t) => Maybe t
03:20:15 <Saizan> > let f m = return 1; lol f m = do {(a,_) <- m; f (return a `asTypeOf` fmap fst m) } in lol f Nothing
03:20:17 <lambdabot>   Nothing
03:20:32 <Saizan> > let f m = return 1; lol f m = f $ fmap fst m in lol f Nothing
03:20:33 <lambdabot>       No instance for (Show (m t))
03:20:33 <lambdabot>        arising from a use of `show' at <in...
03:20:39 <Saizan> > let f m = return 1; lol f m = f $ fmap fst m in lol f Nothing :: Maybe Int
03:20:40 <lambdabot>   Just 1
03:20:59 <Saizan> so, after lots of pain, i've showed how they are not equivalent..
03:21:20 * Saizan shouldn't write code in the morning
03:21:24 <Gracenotes> ...oh have you?!?? Equatorial proof and denotational analysis required!
03:21:41 <Gracenotes> or not >_<
03:22:04 <Saizan> nah, confutations are easier than that :P
03:25:45 <madinfo_work> hi
03:26:20 <wli> Equatorial proof?
03:27:09 <bremner> wli: get near enough to the equator, and it just doesn't matter anymore, so have a pina colada
03:27:48 <wli> Get near enough to the equator and it won't matter anymore because you've caught malaria or ebola or some such.
03:28:09 <madinfo_work> can sombody helpme doing a simple prints on haskell ? :)
03:28:26 <wli> madinfo: Sure. Show the code.
03:28:36 <dancor> so (f . fmap fst) will ignore sub-failure in some cases
03:29:14 <madinfo_work> wli:
03:29:15 <madinfo_work> module Main where
03:29:15 <madinfo_work> main = putStrLn "*"
03:29:15 <madinfo_work>        putStrLn "hello"
03:29:15 <madinfo_work>        putStrLn "world"
03:29:32 <wli> main = do putStrLn "*"
03:29:34 <wli> ...
03:29:54 <madinfo_work> damn forgot that
03:29:55 <madinfo_work> :P
03:30:03 <wli> You just need to put in the "do"
03:30:08 <madinfo_work> :)
03:30:09 <madinfo_work> tanks
03:30:12 <madinfo_work> lemme try
03:34:08 <beelsebob> madinfo_work: an asside though â€“ it's better to construct the thing to print in functional land
03:34:12 <beelsebob> and only use one putStrLn
03:34:44 <beelsebob> main = putStr $ unlines ["*","hello","world"]
03:40:10 <boegel> hiya all
03:40:11 <boegel> what would happen if I link a Haskell app using -threaded, and specify +RTS -N8 when I run it, without having used anything like par, pseq, parMap, or whatever?
03:40:15 <boegel> I would expect nothing to happen at all, i.e. it keeps running just one thread, but it seems like that's not the case
03:41:01 <Saizan> forkIO?
03:43:06 <doserj> parallel garbage collector?
03:43:38 <dobblego> is join (***) in the standard library?
03:44:24 <Saizan> i don't think so
03:44:32 <dobblego> k
03:44:41 <boegel> Saizan: you're saying IO will be done in parallel?
03:44:57 <boegel> doserj: is there such a thing yet in 6.10?
03:45:21 <doserj> yes: http://haskell.org/ghc/docs/6.10.1/html/users_guide/release-6-10-1.html#id2566010
03:47:23 <dobblego> can an Arrow instance be defined for (,) or Either?
03:47:54 <Saizan> boegel: well, -threaded allows for FFI calls to be done in parallel, if needed, but that shouldn't be affected by -N
03:48:07 <madinfo_work> can somebody help me?
03:48:10 <madinfo_work> single code ?
03:48:46 <bremner> madinfo_work: universal rule of irc: just ask the question.
03:49:16 <boegel> bremner: :)
03:49:25 <boegel> "don't ask to ask"
03:49:42 <madinfo_work> ok
03:49:43 <madinfo_work> :D
03:49:47 <madinfo_work> simple code
03:49:50 <madinfo_work> to generate
03:49:52 <madinfo_work> this:
03:49:53 <madinfo_work> *
03:49:54 <madinfo_work> **
03:49:55 <madinfo_work> ***
03:49:56 <madinfo_work> ****
03:49:57 <Gracenotes> dobblego: (->) and Kleisli are the only arrows I know of. if you don't require arr, you can have an instance for a 'reverse computation', like Reversible a b = Reversible (a -> b) (b -> a)
03:49:57 <madinfo_work> *****
03:50:01 <madinfo_work> never programed
03:50:04 <madinfo_work> this in my life
03:50:07 <madinfo_work> but here it goes
03:50:07 <bremner> @homework
03:50:08 <lambdabot> Unknown command, try @list
03:50:08 <madinfo_work> main = do
03:50:09 <madinfo_work>         int a,b
03:50:09 <madinfo_work>          for(a=0;a<=5;a++)
03:50:09 <madinfo_work>                  for(b=0;b<=a;b++)
03:50:09 <madinfo_work>                         putStr "*"
03:50:10 <madinfo_work>                  putStr "\n"
03:50:18 <Zao> madinfo_work: Pastesites are awesome.
03:50:33 <madinfo_work> Zao: i know but
03:50:34 <madinfo_work> its a small code
03:50:34 <Gracenotes> also, Enter is not quite punctuation O_O
03:50:39 <Zao> madinfo_work: No. It's not.
03:50:49 <madinfo_work> sorry guys
03:50:51 <madinfo_work> :|
03:50:54 <dmhouse> madinfo_work: <= 3 lines is generally acceptable in channel
03:50:57 <Zao> madinfo_work: Pastesites allow you to look at code to the side while the conversation continues, and has highlighting.
03:51:15 <boegel> @paste
03:51:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:51:19 <boegel> madinfo_work: ^
03:51:22 <Gracenotes> dobblego: there is also an ArrowChoice... for Eithers.
03:51:29 <dobblego> Gracenotes, great thanks
03:51:41 <EvilTerran> boegel, not that the syntax highlighting would work on that paste
03:51:46 <boegel> for(;;) in Haskell? wtf?
03:51:48 <Gracenotes> it's just like first, second, &&& and *** except it's either/or, not both
03:51:52 <Gracenotes> np
03:51:58 <madinfo_work> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3487#a3487
03:51:59 <EvilTerran> boegel, exactly :P
03:52:01 <Zao> So, you've got homework I assume?
03:52:02 <madinfo_work> here it is
03:52:05 <jedai> madinfo_work: putStr . unlines . tail . inits . repeat $ '*'
03:52:21 <boegel> madinfo_work: I suggest looking into Real World Haskell
03:52:30 <EvilTerran> jedai, just giving someone the answer to a question really doesn't help them
03:52:30 <boegel> jedai: urgh, don't do that :)
03:52:35 <madinfo_work> boegel: just want to do that
03:52:36 <madinfo_work> :D
03:53:03 <boegel> madinfo_work: now try doing the reverse, i.e. start with ***** and go down to *
03:53:13 <EvilTerran> jedai, especially if it looks like a homework question
03:53:22 <boegel> this must be
03:53:24 <jedai> EvilTerran: My intention is that he spent some times understanding how it works, do you really think a beginner in Haskell would do something like that ?
03:53:48 <madinfo_work> boegel: i just want to do that
03:54:03 <int-e> > iterate ('*':) ""
03:54:05 <lambdabot>   ["","*","**","***","****","*****","******","*******","********","*********"...
03:54:07 <EvilTerran> jedai, i find there's a tendency for people to take your answer verbatim without even trying to understand it if it seems to work
03:54:09 <madinfo_work> even that doesnt work...
03:54:11 <jedai> EvilTerran: If it's homework and he gives my solution without explanation the teacher is unlikely to like it much ^^
03:54:20 <boegel> jedai: then yoy shouldn't give him the whole thing, but just part of it :)
03:54:26 <EvilTerran> jedai, exactly; not helping, as i said :P
03:55:08 <boegel> jedai: btw, the solution int-e showed us is _way_ better imho ;-)
03:55:21 <wli> which solution to what?
03:56:46 <bremner> int-e: base case should be "*", I think
03:57:10 <jedai> boegel: It is :)
03:57:43 <int-e> bremner: you can make it "*\n" if you like. I just wanted to aboid using  inits
03:57:51 <jedai> boegel: it share better
03:58:44 <jedai> boegel: And how come int-e get praised and I get booed !! :'(
03:59:58 <bremner> cat, bag, outness
04:00:09 <wli> > let xs = '*' : map ('*':) xs in xs
04:00:10 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
04:00:30 <wli> You get the idea.
04:01:46 <int-e> > scanl (flip (:)) [] (fix ('*':)) -- yet another Data.List function
04:01:48 <lambdabot>   ["","*","**","***","****","*****","******","*******","********","*********"...
04:01:53 <Gracenotes> o nos :X
04:03:04 <Gracenotes> or you could scanr it. So the first element has an infinite number of *s, the second has infinity - 1 *s, the third has infinity - 2 *s... :P
04:03:19 <Zao> Bothersome to visualize :)
04:03:21 <int-e> jedai: btw I didn't mean to boo you if you took it that way.
04:04:39 <Gracenotes> > scanl (flip (:)) [] [' '..]
04:04:41 <lambdabot>   [""," ","! ","\"! ","#\"! ","$#\"! ","%$#\"! ","&%$#\"! ","'&%$#\"! ","('&%...
04:05:29 <jedai> int-e: I wasn't speaking about you :) You just gave a better solution.
04:06:15 <doserj> > sequence (map take [1..]) $ repeat '*'
04:06:16 <lambdabot>   ["*","**","***","****","*****","******","*******","********","*********","*...
04:06:34 <boegel> jedai: because int-e only shows part of the deal
04:06:51 <int-e> @type replicate
04:06:53 <lambdabot> forall a. Int -> a -> [a]
04:07:13 <jedai> boegel: my solution lacked a vital piece too :)
04:07:28 <boegel> jedai: I didn't even notice :)
04:07:38 <boegel> it's not my homework, you know :P
04:07:55 <boegel> I just finished reading Chapter 25 of RWH, and I must say it's an eye-opener
04:08:04 <boegel> I was aware of strictness and all that, but still...
04:08:08 <boegel> great food for thought
04:08:36 <doserj> > map (`replicate` '*') [1..]
04:08:37 <lambdabot>   ["*","**","***","****","*****","******","*******","********","*********","*...
04:08:38 <Gracenotes> omnomnomnomnom
04:09:46 <Zao> > take 5 [replicate n '*' | n <- [1..]]
04:09:48 <lambdabot>   ["*","**","***","****","*****"]
04:10:03 <Zao> Fun fact of the day, in private, lambdabot spams more lines :)
04:10:32 <Gracenotes> if you think lambdabot spams, just look at ghci! :O:
04:13:49 <Gracenotes> aha, got State working
04:13:51 <Gracenotes> > evalState (sequence . repeat . State $ (id &&& ('*':))) "*"
04:13:52 <lambdabot>   ["*","**","***","****","*****","******","*******","********","*********","*...
04:13:53 <jho> what's the preferred day to take "nth" element of a list? "head (drop n list)"?
04:13:58 <Gracenotes> not nearly as natural though
04:14:05 <Gracenotes> and there's no repeatM afaik
04:14:09 <int-e> jho: there's the !! operator for that
04:14:12 <boegel> jho: (!!)
04:14:14 <int-e> > [1,2,3] !! 0
04:14:16 <lambdabot>   1
04:14:19 <jho> ah, thanks :)
04:14:26 <boegel> > [1,3..11] !! 2
04:14:27 <lambdabot>   5
04:14:30 <boegel> argh, too late
04:14:49 <boegel> int-e: you must be waiting for people to ask stuff, right?
04:14:50 <boegel> :)
04:15:06 <Gracenotes> @hoogle repeatM
04:15:06 <lambdabot> No results found
04:15:10 <Gracenotes> :O
04:15:12 <Gracenotes> you cad, lambdabot!
04:15:41 <Saizan> that' called ~forever
04:15:47 <beelsebob> repeatA already!
04:16:00 <Gracenotes> Saizan: well. that would be repeatM_
04:16:06 <beelsebob> and repeatA_
04:16:07 <Gracenotes> with an underscore
04:16:34 * Saizan sends razor-sharp >>=s against applicative fanboys
04:16:41 <Gracenotes> can't say it would be amazingly useful overall though
04:17:21 * beelsebob throws his <*> ninja stars at Saizan
04:21:11 * dobblego runs away with all the <$>
04:22:02 <blackh> Hi all. I have been trying out Leksah today and I think it is really great. It hasn't reached its full potential yet, but it's very usable and very free of annoying things for a beta.  I would put it more at pre-beta.
04:23:34 <beelsebob> it is velsion 0.4.4 beta
04:23:39 <beelsebob> not 1.0 beta
04:24:15 <blackh> The best things are, 1. it compiles and takes you straight to the errors, and 2. the editor is not missing any important feature.
04:26:31 <blackh> beelsebob: Quite so - well, it's better quality than the version number might suggest.
04:26:40 <blackh> And it has ** source candy ** !!
04:27:52 <blackh> Another great thing about it is that it loads a .cabal file and there's your project!  No mucking about if you already have a .cabal file.
04:29:39 <beelsebob> :)
04:31:27 <Gracenotes> @elite , [((<$>)<<^(++)^>>($))<*>(>>=)]<*>((:[])<$>[1..5])<*>[:[]]
04:31:28 <lambdabot> , [((<$>)<<^(++)^>>($))<*>(>>=)]<*>((:[])<$>[1..5])<*>[:[]]
04:31:29 <lunabot>  luna: parse error on input `]'
04:31:33 <Gracenotes> pssh.
04:32:00 <Gracenotes> silly lunabot.
04:32:30 <Gracenotes> @elite , (+1) <$> [1,2,3]
04:32:30 <lambdabot> , (+1) <$> [1,2,3]
04:32:32 <lunabot>  [2,3,4]
04:33:53 <Gracenotes> unfortunately things like recursive functions are rather difficult. no let or wheres allowed
04:36:35 <RayNbow> > let splits xs = xs >>= \x -> return (x, delete x xs) in splits []
04:36:36 <lambdabot>   []
04:36:39 <RayNbow> > let splits xs = xs >>= \x -> return (x, delete x xs) in splits [1..5]
04:36:41 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
04:36:59 <edwardk> hrmm. never saw this book before but it uses Haskell throughout. http://tinyurl.com/ct6ju9
04:41:41 <mun> with the monad http://haskell.pastebin.com/m720ad15c, does g need to take in 2 arguments while y needs to take in 3?
04:44:18 <edwardk> mun ?
04:44:36 <edwardk> min x <- g w -- seems to indicate g takes one to me
04:44:46 <mun> edwardk: does g w correspond to p in the monad?
04:45:06 <mun> and p takes in s0
04:46:15 <edwardk> mun: p >>= k seems to be just the definition of the state monad's bind operation that you have there. g w gets placed in the location you have 'p' in that definition when used in x <- gw; ... that becomes gw >>= \x -> ...
04:46:41 <edwardk> @undo do x <- g w; y <- h w x; z <- i w x y; return z
04:46:42 <lambdabot> g w >>= \ x -> h w x >>= \ y -> i w x y >>= \ z -> return z
04:49:15 <RayNbow> edwardk: I can barely find any reviews on that matroids book
04:49:46 <mun> edwardk: but does p >>= k =... mean that k equals the entire right hand side?
04:49:48 <edwardk> RayNbow: yeah i got bored and started researching matroids and came across it
04:49:56 <boegel> > let list = take 100 $ map read (map show [1,2..]) in (inits list :: [[Int]]) `using` rnf
04:49:57 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[...
04:49:58 <mun> i.e. k= \s0 ...
04:49:59 <edwardk> mun yes
04:50:01 <boegel> is the `using` rnf part enough to ensure strictness of the elements of the sublists?
04:50:17 <boegel> I think it is, I just want to make sure...
04:50:27 <jedai> boegel: it is
04:50:33 <boegel> hmmk, great
04:50:36 <jedai> If the instance is correct
04:50:37 <mun> edwardk: right. so in my example, k is recursive, since q = k a?
04:50:44 <boegel> jedai: instance?
04:50:59 <jedai> boegel: rnf is a method of the NSData class
04:51:08 <RayNbow> edwardk: I'd like to know whether the book is accessible for CS students without a strong math background :)
04:51:10 <edwardk> (g w) >>= (\x -> h w x >>= ...) -- k makes use of >>=
04:51:12 <RayNbow> but so far I only found 1 review
04:51:15 <jedai> @type rnf
04:51:16 <lambdabot> forall a. (NFData a) => a -> Done
04:51:19 <boegel> NFData :)
04:51:51 <boegel> jedai: ok, so as long as there's an instance of NFData for the type of list elements I'm using, then I'm good...
04:52:11 <boegel> jedai: but if there's no instance, then the list elements will remain thunks?
04:52:32 <Gracenotes> then it can't be used
04:53:23 <mun> thanks edwardk
04:53:49 <jedai> boegel: We have to assume that the instances are correct (that is rnf really reduce its argument to normal form)
04:54:37 <jedai> boegel: It is of course the case of all the instances defined in Control.Strategies so in your case it's ok
04:55:02 <Gracenotes> any sort of data could probably be RNF
04:55:15 <Gracenotes> NFData, that is
04:55:24 <Gracenotes> any sort of computation, probably not.
04:55:29 <Gracenotes> of course the line gets blurry :X
04:55:39 <edwardk> RayNbow: i'm thinking of picking it up. i'm not exactly scared of too much abstraction ;)
04:56:18 <edwardk> the author does love his lists though
05:02:53 <RayNbow> edwardk: I have the problem I have to restrain myself from buying more books (since I still have several books to finish)
05:03:26 <mun> i'm looking at this code and the function has the type f :: A -> B -> C(D, E), but f returns a triple which isn't constructed using C. how come?
05:04:11 <Gracenotes> what's the exact type?
05:04:27 <mun> i've paste the code here: http://haskell.pastebin.com/m3e4f81d2
05:04:53 <Gracenotes> those are interesting naming conventions
05:05:09 <mun> the output type is Result (GENERICITY, GenericitySig, DGraph)
05:05:17 <mun> but it returns a triple
05:05:36 <Gracenotes> yes. Result is a polymorphic type
05:06:09 <Saizan> return :: a -> Result a, there
05:06:28 <Saizan> (i guess?)
05:06:49 <Gracenotes> you could have a Result ((a -> b), Maybe ([Int], Double, String)), for instance.
05:06:49 <Saizan> so you use it to embed the triple into Result
05:07:01 <Saizan> return isn't the same as in imperative languages
05:07:22 <mun> Saizan: oh you mean, they defined return themselves?
05:07:26 <Gracenotes> okay, maybe that wasn't a helpful example
05:07:50 <Saizan> mun: well, return is a method of the Monad typeclass
05:07:52 <Saizan> ?type return
05:07:54 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:07:55 <Gracenotes> return is a function. it's not a keyword or an operator
05:08:09 <mun> right
05:08:16 <Saizan> mun: so they defined its implementation for Result when they made the instance, but the type is fixed
05:08:19 <mun> so should i look at the Monad for result?
05:08:23 <mun> *Result
05:09:26 <mun> i see. i've pasted the monad in http://haskell.pastebin.com/mf86c776
05:09:32 <mun> what does the . after [] mean?
05:09:46 <zachk> mun: im a neophyte but it seems like you might want to break your big function into smaller functions
05:09:57 <Saizan> mun: it's function composition
05:10:08 <Saizan> ?src (.)
05:10:08 <lambdabot> (f . g) x = f (g x)
05:10:22 <Gracenotes> return x = Result [] (Just x)
05:10:30 <Gracenotes> ^ same thing
05:11:26 <zachk> > f 100 where f=sum.map(^4).enumFromTo 1
05:11:28 <lambdabot>   2050333330
05:11:46 <mun> i see i see
05:12:09 <zachk> mun: it gets even better, there are stranger things then monads :-D
05:12:30 <Gracenotes> I'm gonna guess it's a combination of a Maybe (failure) and list-Writer monad
05:12:41 <mun> so in that monad, are both return and >>= defined already?
05:13:32 <zachk> they return and >>= (bind) have to be defined for it to be a "warm fuzzy thing" (monad)
05:14:50 <mun> zachk: but is bind defined there? or is it just return?
05:15:33 <doserj> r@(Result e m) >>= f = ... defines >>=
05:16:17 <mun> Oh! i was reading it wrong.. i thought r@.. follows from Just
05:16:23 <mun> ok thanks
05:16:28 <zachk> mun: you need to define bind and return, they work different depending on which monad you are in
05:17:23 <zachk> > f 3 where f n=a<-[1..n];b<-[1..n];return (a,b)
05:17:24 <lambdabot>   <no location info>: parse error on input `<-'
05:17:34 <mun> so what should return = Result [] . Just be expected to do? how do you compose Result [] with Just?
05:17:34 <zachk> ack
05:18:18 <zachk> > f 3 where f n=do a<-[1..n];b<-[1..n];return (a,b)
05:18:19 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
05:18:50 <zachk> @sequence
05:18:51 <lambdabot> Unknown command, try @list
05:19:00 <doserj> mun: return x = Result [] (Just x)   as Gracenotes said
05:20:04 <Axman6> mun: you understand that data constructors are functions right?
05:20:13 <Axman6> :t Just
05:20:14 <lambdabot> forall a. a -> Maybe a
05:20:16 <mun> Axman6: yeah
05:20:34 <Gracenotes> if you can see the constructors :O
05:20:34 <doserj> to understand what Result [] (Just x) means, you have to look at the data type definition for Result
05:20:52 <Axman6> Gracenotes: good point
05:21:07 <Gracenotes> they still are functions though, even hidden
05:21:28 <Gracenotes> import GHC.Base
05:21:35 <Gracenotes> :t I#
05:21:36 <lambdabot> Not in scope: data constructor `I#'
05:21:45 <Gracenotes> I# :: Int# -> Int
05:23:10 <mun> doserj: in your opinion, why do they use (Just x) rather than x?
05:23:25 <Gracenotes> @go haskell pointfree
05:23:28 <lambdabot> http://www.haskell.org/haskellwiki/Pointfree
05:23:28 <lambdabot> Title: Pointfree - HaskellWiki
05:23:43 <Gracenotes> ^ info on that style
05:24:18 <doserj> mun: I have no idea what the Result type is supposed to do :)
05:24:53 <Gracenotes> probably so that failed Results have a log of where the computation went wrong
05:25:13 <Gracenotes> but so that they don't actually have a 'Result'. I think. I dunno too much though.
05:29:29 <yadddha> Hi and hello , are there any real-life tutorials for nonprogrammers to get started in haskell , e.g. building a gtk2app ?
05:29:47 <doserj> mun: It probably is because they want it to be type-correct :) I would guess that data Result a = Result [a] (Maybe a)
05:31:07 <doserj> well, data Result a = Result [b] (Maybe a), for some fixed type b, probably
05:31:47 <Axman6> yadddha: i'd start with LYAH (i don't think it goes into gtk2hs, but you need to know haskell before you can start with more advanced things like that)
05:31:51 <Axman6> @where lyah
05:31:51 <lambdabot> www.learnyouahaskell.com
05:31:58 <Axman6> yadddha: ^^^^^
05:33:41 <jedai> yadddha: once you have Haskell basis, and if you still wish to write a gtk2 app, go on the Gtk2Hs website, they have a nice tutorial on how to use Glade and Gtk2Hs, and doc for the API
05:33:42 <Gracenotes> For Great Good!
05:33:59 <Gracenotes> also there's a RWH chapter on it
05:35:20 <Gracenotes> in the <s>RWS</s> RWH monad
05:35:33 <Axman6> <s>?
05:35:49 <Axman6> </s> <!-- don't want to break IE -->
05:35:57 <Axman6> </Axman6>
05:36:03 <Axman6> ah, it's fucked already
05:36:14 <Gracenotes> indeed</Gracenotes>
05:36:39 <Gracenotes> </Gracenotes></Axman6>
05:36:53 <Axman6> this could take a while </Axman6>
05:37:37 <Axman6> bloody hell happy produces a lot of warnings
05:38:02 <wli> Yeah, it sucks for -Werror
05:38:28 <wli> Even -Wall without -Werror even.
05:38:42 <Axman6> bust reinstalling all my cabal packages
05:38:55 <Axman6> busy*
05:43:02 <yadddha> Axman6  wow ,didnt find that before ,so maybe no phd needed -ill defintely try that . thanks .just4fun :would you say (not by reason , by existing modules/libarys)gtk2 support and fastcgi support is stable/simple enough for writing small apps(given basic haskell skills) ?
05:43:45 <Axman6> possibly. but don't get ahead of yourself, it's the most unproductive thing you can do when learning anything.
05:45:44 <Axman6> @hackage typeof
05:45:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/typeof
05:48:24 <yadddha> Axman6 yes can be quite a desease (been there...), on the other hand i find learning along a practical example much easier ( simple editor etc) i thought about a simple vdrlike gui ...frontent for szap + cat should be easy enough
05:52:16 <morgo> Hi!
05:53:33 <Axman6> o/
05:54:34 <Axman6> i only learnt how makefiles work the other day. much simpler than i though they were
05:55:22 <morgo> I have a problem with function composition.
05:55:35 <Axman6> what's the problem?
05:55:37 <ivanm> Axman6: simple ones are simple...
05:55:38 <morgo> Well. Infact it's not a problem, more like a huge question.
05:55:50 <morgo> I'm studying Haskell.
05:55:50 <ivanm> but there's nothing that guarantees that they're simple :s
05:55:59 * ivanm has seen some really ugly Makefiles :s
05:56:12 <Axman6> oh, whoops, i said that in the wrong chan :P
05:56:29 <morgo> And I eventually go to function composition.
05:56:55 <ivanm> Axman6: heh
05:56:56 <morgo> I did not understand them at all.
05:57:06 <ivanm> morgo: OK, how much maths have you done?
05:57:06 <Axman6> morgo: what don't you understand?
05:57:17 <ivanm> because I'm wondering if I should go from a math perspective or not
05:57:18 <Axman6> > f . g . h $ x
05:57:19 <lambdabot>       Ambiguous occurrence `g'
05:57:19 <lambdabot>      It could refer to either `L.g', defined a...
05:57:21 <ivanm> or just a practical one
05:57:23 <ivanm> Axman6: heh
05:57:33 <Axman6> > f . g $ x
05:57:34 <lambdabot>       Ambiguous occurrence `g'
05:57:34 <lambdabot>      It could refer to either `L.g', defined a...
05:57:35 <morgo> until today.
05:57:39 <Axman6> > f . f $ x
05:57:40 <vixey> I don't know what to say to thtat
05:57:40 <lambdabot>   Add a type signature
05:57:44 <Axman6> > f . f $ x :: Expr
05:57:46 <lambdabot>   Add a type signature
05:57:50 <Axman6> -_-
05:57:50 <morgo> Then I finally understood them.
05:57:54 <mun> doserj: thanks :)
05:57:57 <morgo> or it.
05:58:00 <vixey> hi
05:58:07 <ivanm> morgo: so what's your question?
05:58:09 <EvilTerran> morgo, what's your huge question, then?
05:58:14 <ivanm> or do we have to drag it out of you? :p
05:58:23 <morgo> The question is small.
05:58:29 <Axman6> well ask it...
05:58:32 <morgo> It just needs some introduction.
05:58:38 <morgo> (which is not small :)
05:58:42 <ivanm> as in it's a small question, or the question is: "small"? ;-)
05:59:16 <EvilTerran> ?faq small?
05:59:16 <lambdabot> The answer is: Yes! Haskell can do that.
05:59:24 <morgo> Basically this is the question: Function composition is great and I'd like to learn more.
05:59:34 <EvilTerran> ?vixen small?
05:59:34 <lambdabot> isn't it obvious?
05:59:43 <ivanm> EvilTerran: you going for the spanish look or something, with question marks everywhere? ;-)
05:59:52 <ivanm> morgo: no, that's a statement
05:59:54 <morgo> Today I wrote a some sort of function composition
06:00:01 <ivanm> you can tell because it doesn't have a "?" on the end ;-)
06:00:12 <Axman6> morgo: do you think you could get to the point? :\
06:00:21 <morgo> And I do not know the name of the combinator I wrote.
06:00:45 <morgo> Is it a 'Kestrel' or is it a 'Tursh'
06:00:45 <ivanm> so your question is "does ______ have a formal name?"
06:00:46 <ivanm> ?
06:00:51 <morgo> Yes!
06:01:03 <morgo> I pastie ti!
06:01:04 <morgo> *it
06:01:14 <Axman6> @where hpaste
06:01:14 <lambdabot> http://hpaste.org/
06:01:16 <Axman6> ^^
06:01:18 <ivanm> morgo: didn't _really_ need that much of a wind-up... ;-)
06:01:24 <mun> with the monad defined in http://haskell.pastebin.com/m223f0f7c, how come Result [] can be composed with Just? is Result [] a function?
06:01:24 <morgo> :D
06:01:30 <ivanm> Axman6: if only the hpaste bot was still here... :(
06:01:37 <Axman6> yeah :\
06:02:06 <EvilTerran> mun, yes, Result :: [Diagnosis] -> Maybe a -> Result a
06:02:29 <EvilTerran> mun, you could ask ghci for the type of "Result [] . Just"
06:02:34 <morgo> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3492#a3492
06:02:45 <mun> EvilTerran: thanks
06:02:50 <EvilTerran> (it'll be "a -> Result a", so correct for "return")
06:02:50 <vixey> morgo: what
06:02:56 <Axman6> morgo: huh?
06:03:09 <morgo> It's not in Haskell, but the ppl at #javascript would not know anything about this...
06:03:25 * ivanm gives vixey a (++ " the")
06:03:33 <vixey> lol ok
06:03:33 <vixey> lol
06:03:35 <vixey> your mental
06:03:51 <EvilTerran> ... that's function composition? i don't see it
06:03:53 <ivanm> vixey: me or morgo? ;-)
06:04:10 <morgo> EvilTerran: toFinder returns a function which finds something
06:04:10 <vixey> morgo
06:04:23 <morgo> Or did I get this completely wrong.
06:04:39 <vixey> morgo: you said you wanted to learn more
06:04:42 <ivanm> morgo: function composition is a way of chaining functions together
06:04:43 <EvilTerran> what's that $(...) thing?
06:04:46 <vixey> morgo: why don't you learn Haskell then?
06:05:17 <morgo> vixey: I'd like to learn functional programming. Haskell seems to be most suitable for me.
06:05:19 <ivanm> i.e. (f . g . h)(x) = f(g(h(x))) in more mathematical parlance
06:05:46 <vixey> morgo: get GHC and read
06:05:47 <vixey> ?LYAH
06:05:48 <lambdabot> Unknown command, try @list
06:05:54 <vixey> morgo: thas is my advice if you want to learn Haskell,
06:05:57 <vixey> ?where LYAH
06:05:57 <lambdabot> www.learnyouahaskell.com
06:06:08 <morgo> vixey: I have a GHC
06:06:30 <Gracenotes> compile you a GHC
06:06:41 <vixey> then proceed to stage 2
06:06:49 <Gracenotes> for great executables
06:07:03 <morgo> I just try to use lessons I learned from RWH and The Haskell School of Expression in JS
06:07:39 <ivanm> Gracenotes: heh
06:07:58 <morgo> To some extent I can leverage my knowledge of Haskell in JS
06:08:07 <Axman6> what a waste
06:08:34 <ivanm> Axman6: at least it has the "S" on the end...
06:08:35 <ivanm> ;-)
06:08:47 <det_> Is there a good example of where multiple parameter type classes are useful in an obvious way?
06:09:03 <Axman6> Arrays?
06:09:29 <opqdonut> Maps also
06:09:59 <opqdonut> except they don't really have a type class in the prelude
06:10:07 <ivanm> does this mean that Arrays and Maps aren't valid H98 since they need an extension? :o
06:10:16 <det_> Could you be more specific? :-)
06:10:21 <ivanm> oh, wait, duh, type class
06:10:31 <ivanm> there's an example in RWH IIRC
06:10:45 <det_> !faq RWH
06:10:53 <ivanm> @where RWH
06:10:53 <lambdabot> is http://www.realworldhaskell.org/blog/
06:11:06 <det_> Thanks
06:11:09 * boegel benchmarks the hell out of his distance function, and it's performing horribly
06:11:30 <ivanm> boegel: how are you defining it?
06:11:33 <Axman6> boegel: what's up?
06:11:38 <opqdonut> det_: basically one has a typeclass "Array a e" that means "a" is an array with elements of type "e"
06:11:53 <opqdonut> det: and then via this type class one can provide a uniform interface to different types of arrays
06:12:00 <ivanm> is there any time multiparam type classes are used _without_ fundeps?
06:12:03 <boegel> ivanm, Axman6: I plan on pasting my code soon, but I want to figure some stuff out first :)
06:12:16 <Axman6> > runST (unsafePerformIO . putStrLn $ "test")
06:12:17 <lambdabot>   Not in scope: `unsafePerformIO'
06:12:26 * ivanm wished people would stop teasing the denizens of this channel with promises of future code/queries
06:12:28 <Axman6> > runST (unsafeIOToST . putStrLn $ "test")
06:12:29 <lambdabot>   Not in scope: `unsafeIOToST'
06:12:35 <boegel> I don't want to ask you guys how I can make it perform better, because then I'll never learn
06:12:35 <ivanm> Axman6: no IO, remember?
06:12:39 <Axman6> @hoogle unsafeIO
06:12:40 <lambdabot> Control.Monad.ST unsafeIOToST :: IO a -> ST s a
06:12:40 <lambdabot> Control.Monad.ST.Lazy unsafeIOToST :: IO a -> ST s a
06:12:48 <boegel> ivanm: sorry
06:12:53 <ivanm> boegel: OK, in that case profile the hell out of it ;-)
06:12:56 <Axman6> ivanm: i know, but wondering if there was a way around that
06:13:01 <ivanm> Axman6: no
06:13:11 <ivanm> lambdabot has no idea that IO even exists, AFAIK
06:13:25 <ivanm> the "real world" has been exorcised out of her
06:13:26 <ivanm> ;-)
06:13:31 <boegel> ivanm: then how does it communicate it's messages? :)
06:13:38 <Axman6> :t unsafeIOToST
06:13:39 <lambdabot> Not in scope: `unsafeIOToST'
06:13:45 <ivanm> boegel: people hacking into her brain...
06:13:52 <det> So, a generic sequence type class would necessarily have to be multi-parameter ?
06:13:53 <ivanm> OK, tbh it's mueval that doesn't know about IO
06:13:54 <Axman6> > runST (Control.Monad.ST.unsafeIOToST . putStrLn $ "test")
06:13:55 <lambdabot>   /tmp/2915566948849873096:70:32: Not in scope: `runST'/tmp/29155669488498730...
06:14:02 <bastl> I have a list of as and a list of bs and want to make sure that for each a there exists a b such that (a `correspondsTo` b) . What is the cleanest way to express that ?
06:14:13 <Axman6> > Control.Monad.ST.runST (Control.Monad.ST.unsafeIOToST . putStrLn $ "test")
06:14:14 <lambdabot>   /tmp/1602296664668279507:70:32:
06:14:14 <lambdabot>      Not in scope: `Control.Monad.ST.runST'...
06:14:21 <Axman6> @more
06:14:23 <ivanm> bastl: as in you want a test function?
06:14:27 <ivanm> or are you generating them?
06:14:37 <ivanm> if you're generating them, make sure you generate them properly ;-)
06:14:59 <Axman6> wait up, when did lambdabot get ops?
06:15:15 <bastl> ivanm: i have first order logic in my mind, and think about howto express it generically.
06:15:35 <bastl> especially quantifying.
06:15:52 <doserj> ivanm: something like class Coerce a b where coerce:: a->b ?
06:16:30 <ivanm> doserj: oh, that makes sense
06:16:40 <ivanm> when you have a direct link between them
06:16:54 <bastl> ehm, doserj, concerning my question?
06:17:17 <doserj> bastl: no
06:17:19 <ivanm> doserj: I take it you just have to be careful when using coerce to get the right instance for a given 'a' (or a given 'b')?
06:17:36 <bastl> doserj: fine :-)
06:18:14 <doserj> ivanm: if C programmers can do it, haskell programmers can do it, too :)
06:18:23 <ivanm> doserj: heh
06:19:24 <edwardk> doserj: sure, they just may have to do it in C ;)
06:20:36 <dayzman> hi
06:21:53 <dayzman> i'm looking at some code (http://www.ki.informatik.uni-frankfurt.de/doc/mirror/HSP/HSP.html) just to make sure, is the do block in acceptConnections using the monad for socket?
06:21:55 <dayzman> *Socket
06:22:32 <edwardk> that looks like it is just using IO
06:23:30 <singintime> hello everybody
06:23:37 <bavardage> o/
06:24:00 <Axman6> dayzman: defenitely using the IO monad
06:24:24 <beelsebob> Is it possible to get cabal to use a "local hackage database"
06:24:32 <boegel> singintime: y0!
06:24:39 <boegel> singintime: why don't you sing for us? :)
06:24:46 <beelsebob> we have private packages that we'd love it to build for us
06:25:06 <singintime> boegel: sure
06:25:14 <dayzman> edwardk ooh ok. i've checked the type for acceptConnections and it's Socket -> IO b, then is this the declaration? acceptConnections Monad b => Socket -> b IO?
06:25:30 <singintime> Io lo so che le cose poi / non sono mai come /
06:25:35 <singintime> come te le aspettavi te
06:25:41 <dayzman> Axman6: hmm how do you tell?
06:25:43 <singintime> io sono triste perÃ²
06:25:48 <singintime> io sono triste un po'...
06:25:49 <singintime> :)
06:25:53 <boegel> heh
06:25:53 <Axman6> dayzman: because there's a putStrLn in there
06:26:05 <vixey> hehe
06:26:10 <Axman6> and print
06:26:14 <boegel> singintime: I bet this isn't the first time you've been asked this
06:26:17 <Axman6> and forkIO (the biggest clue :P)
06:26:30 <singintime> actually, never on IRC ;)
06:26:41 <singintime> more often on stage :)
06:26:44 <Axman6> @hackage blas
06:26:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas
06:27:10 <basvandijk> Hello, I'm hacking some Happstack code and I have a small question about style. Which is better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3496#a3496 ?
06:28:21 <Axman6> i prefer instance MatchMethod ()               where matchMethod ()    _ = True
06:28:51 <hugo_> hi
06:29:04 <hugo_> i have just written a few modules and commented them with haddock
06:29:04 <Axman6> o/
06:29:06 <boegel> how do you tell, looking at Core code, that a value is unboxed or not?
06:29:10 <hugo_> how do i generate the documentation ?
06:29:12 <boegel> RWN isn't clear on this
06:29:12 <dayzman> if :type foo returns foo :: A -> b IO, what should be foo's type declaration? is it foo :: A -> IO b?
06:29:17 <hugo_> i tried haddock -h Module.hs
06:29:22 <Axman6> boegel: if the type has a #, it's unboxed
06:29:25 <Gracenotes> boegel: Real World.. Narwheagles..?
06:29:26 <hugo_> but it complains about ghc lib directory
06:29:27 <hugo_> :S
06:29:35 <hugo_> can anyone help me out please ?
06:29:36 <vixey> dayzman: A -> b IO
06:29:46 <boegel> Gracenotes: sorry :) RWH :)
06:29:50 <basvandijk> Axman6: Yes I think I do too. The (const . const) is to much
06:29:58 <Axman6> indeed
06:30:28 <vixey> basvandijk: write  const (const True)
06:30:29 <boegel> Axman6: in RWH, they explain that in (# Integer, Double #), the Double is unboxed, while the Integer is not?
06:30:36 <dayzman> vixey: i tried that but i got the error saying:  Couldn't match kind `(* -> *) -> *' against `* -> *';  When matching the kinds of `b :: (* -> *) -> *' and `IO :: * -> *'; Expected type: IO b1 Inferred type: b IO
06:30:53 <boegel> so Double# mean unboxed Double, but what about #Integer? or is this # part of the tuple?
06:30:55 <Axman6> boegel: i don't think that's right. that's an unboxed tuple
06:31:16 <vixey> dayzman: can you paste foo?
06:31:17 <Axman6> (#,#) is an unboxed tuple, so that's (#,#) Integer Double
06:31:29 <dayzman> vixey: sure
06:31:30 <bastl> can someone help me to make this "clean"? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3497
06:31:37 <boegel> Axman6: then, later on, they detail on (# Int#, Double# #), saying in that both the Double and the Int are unboxed
06:31:56 <trofi^w> Integer itself is complicated type
06:32:01 <basvandijk> vixey: Yes, that's what I had first but I wanted to write it in a more Conal Elliot style
06:32:03 <dayzman> vixey: foo is acceptConnections in http://haskell.pastebin.com/mc6bb975
06:32:10 <boegel> trofi^w: yeah, it's more expensive than Int, right?
06:32:26 <Axman6> boegel: yep. that's (#,#) Int# Double#, which means that there's a machine Int sitting next to a maching double (i think)
06:32:55 <vixey> dayzman: it says: acceptConnections :: Socket -> IO b
06:33:02 <vixey> dayzman: not: acceptConnections :: Socket -> b IO
06:33:07 <Axman6> boegel: it should be mentioned that only certain types can be unboxed (Int, but not Integer for example)
06:33:21 <EvilTerran> boegel, in (# Integer, Double #), the Integer might be treated differently because Integer is variable-length
06:33:31 <trofi^w> boegel: sure
06:34:20 <hugo_> where is the ghc lib dir ?
06:34:24 <hugo_> how do i know where it is ?
06:34:46 <Axman6> i think that (# Integer, Double #) means that there's a pointer to an Integer, and a pointer to a Double next to each other in memory. as opposed to (Integer, Double) which is a pointer to a tuple with pointers to an Integer and a Double
06:34:51 <boegel> Axman6: what the difference between (#,#) Int Double and (#,#) Int# Double#?
06:35:04 <boegel> Axman6: doesn't (#,#) force the elements to be unboxed?
06:35:11 <Axman6> Int# is a machine integer, like you'd have in C
06:35:12 <Axman6> no
06:35:26 <boegel> Axman6: hmm, k
06:35:28 <Axman6> it just reduces the overhead that a tuple would have
06:36:19 <boegel> so, then, in (#,#) Int Double, neither the Int nor Double will be unboxed? only the overhead of the tuple is lowered?
06:36:19 <hugo_> help please ?
06:36:36 <basvandijk> hugo_: You can also generate documentation using 'cabal haddock' Of course you need to have a .cabal file for your modules.
06:36:40 <Axman6> i think you can imagine (# Int#, Double# #) as something like struct tup2 {int x; double y}
06:37:01 <dayzman> vixey: oh indeed... my eyes..! thanks
06:37:01 <boegel> Axman6: while (# Int, Double #) would be?
06:37:14 <vixey> make you font size bigger
06:37:16 <vixey> your
06:37:20 <Axman6> and (# Integer, Double #) as struct tup2 {Integer * x; double * y}
06:37:36 <dayzman> vixey: so what is this b in Socket -> IO b?
06:37:46 <Axman6> where Integer would be some other struct
06:37:53 <Axman6> @src Integer
06:37:54 <lambdabot> data Integer = S# Int#
06:37:54 <lambdabot>              | J# Int# ByteArray#
06:38:11 <vixey> dayzman: look at the code foo x = ... >> foo y,  it never actually returns, so b could be anything
06:38:22 <hugo_> hmm ok
06:38:36 <hugo_> basvandijk: do i need to have one .cabal for each module ?
06:38:48 <Axman6> boegel: i could of course be totally wrong about this all, but this is how i understad it
06:38:51 <Axman6> nd*
06:39:00 <dayzman> vixey: i see. thanks
06:39:07 <basvandijk> hugo_: No just one for your whole program or library. Also see: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
06:39:34 <hugo_> thanks
06:39:44 <boegel> Axman6: hmm, thanks, that makes it more clear
06:40:06 <boegel> Axman6: but then, stating that in (# Integer, Double#) the double is unboxed is incorrect?
06:40:13 <Axman6> boegel: basically, the difference is that an unboxed type can be stored in a register, which makes it much faster
06:40:22 <Axman6> boegel: yes
06:40:42 <boegel> Axman6: then RWH is wrong on this... ? :-/
06:40:51 <Axman6> hmm, probably not...
06:40:53 <Axman6> what page?
06:41:09 <boegel> Axman6: see http://book.realworldhaskell.org/read/profiling-and-optimization.html, the Understanding Core part
06:41:34 <boegel> "is represented with an unboxed Double# value"
06:42:19 <Axman6> ah, you're not talking about the (# Integer, Double# #) part are you?
06:42:36 <Axman6> becausw that's different to (# Integer, Double #)
06:44:27 <Axman6> anyway, i have an exam tomorrow. need my sleep
06:44:29 <Axman6> night all
06:44:32 <GoldyOrNugget> hi, i just started learning haskell last night. why doesn't this work?
06:44:33 <GoldyOrNugget> range :: Int -> [Int]
06:44:33 <GoldyOrNugget> range n = [ a+1 | a <- range ]
06:44:53 <Axman6> well, range is a function...
06:45:03 <boegel> Axman6: I only see (# Integer, Double#) in the type signature?
06:45:11 <dmhouse> GoldyOrNugget: the syntax "a <- range" inside a list comprehension means "where a is drawn from the list range"
06:45:31 <GoldyOrNugget> dmhouse, i know, i did that on purpose. isn't that the aim?
06:45:33 <Axman6> boegel: probably a typo in the online version. it's (# Integer, Double# #) in the book
06:45:38 <vixey> GoldyOrNugget: that's crazy
06:45:39 <GoldyOrNugget> it should produce [1, 2, 3, 4...]
06:45:46 <boegel> Axman6: ah!
06:45:58 <boegel> Axman6: that explains a lot
06:46:09 <boegel> they should update the online version then :-/
06:46:16 <Axman6> heh, yeah
06:46:23 <Axman6> but then people wouldn't buy the book ;)
06:46:32 <dmhouse> GoldyOrNugget: right, well (1) you're defining range as a function taking a parameter, so you'd need to pass it one, (2) this isn't the right way to go about it
06:46:32 * boegel hides
06:46:54 <GoldyOrNugget> it takes 'n', doesn't it?
06:47:08 <dmhouse> GoldyOrNugget: yeah, but in "a <- range" you're not passing it anything
06:47:10 <boegel> Axman6: well, one reason I'm not buying the book is because I have the impression that the book needs more work, it has some annoying typos and such in it
06:47:19 <boegel> Axman6: but, I got that impression from the online version
06:47:25 <boegel> Axman6: so... :)
06:47:40 <Axman6> boegel: that's like not looking at the mona lisa because there's dust on it :)
06:47:53 <GoldyOrNugget> ah, so [ a+1 | a <- range n ] works
06:48:05 <GoldyOrNugget> and what's the right way of going about it?
06:48:16 * edwardk kinda wishes the unboxed types were a little prettier, but understands there is a conservation of ugliness principle involved.
06:48:26 <dmhouse> GoldyOrNugget: no, that probably still won't work
06:48:32 <Axman6> > let range n = [a+1 | a <- range n] in range 4
06:48:34 <lambdabot>   * Exception: stack overflow
06:48:47 <GoldyOrNugget> well, no compile errors anyway
06:48:49 <edwardk> but whoever thought up "{-# UNPACK #-} !Int" was a sadist
06:49:01 <Axman6> > let range n = n : range (n+1) in range 1
06:49:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:49:09 <doserj> boegel: the "is represented with an unboxed Double# value" refers to the Double# in lgo :: Integer -> [Double] -> Double# -> (# Integer, Double #), not to the Double in the result type
06:49:13 <dmhouse> > let range n = [n,..] in range 1
06:49:14 <lambdabot>   <no location info>: parse error on input `..'
06:49:23 <boegel> doserj: oh...
06:49:34 <zachk> man pointfree with fold is pretty cool 8-D
06:49:47 <dmhouse> > let range n = [n..] in range 1
06:49:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:49:57 <GoldyOrNugget> it appears my haskell learning is really lacking... i've never seen 'let' before :/
06:49:59 <Axman6> pointfree is not cool
06:50:14 <zachk> Axman6: no? why not
06:50:18 <boegel> doserj: then the discussion is highly confusing, becausde they also look at the Integer in the same paragraph
06:50:19 <edwardk> Axman6: bah =P
06:50:23 <tromp_> :t enumFrom
06:50:24 <lambdabot> forall a. (Enum a) => a -> [a]
06:50:33 <Axman6> it makes for unclear code imo
06:51:01 <edwardk> boegel: (# Double, Integer #) just strips off the overhead of the tuple it doesn't do any magic unboxing of the contents
06:51:28 <zachk> im just doing treesort, and it took 4 lines down to this: makeTree = foldr insertTree Tip
06:51:38 <doserj> boegel: what is so confusing?
06:52:04 <edwardk> axman6: it just changes the emphasis. neither extreme is all that appealing to me
06:52:10 <Axman6> edwardk: would i be right in saying that in (# Int#, Double# #), the result would be a machine int and a machine double next to each other in memory? (or registers even)
06:52:20 <edwardk> yes
06:52:27 <Axman6> whoot :)
06:52:44 <edwardk> not necessarily next to each other in memory but just a machine int and machine double ;)
06:52:44 <Axman6> i was pretty sure i was right, but not certain
06:53:07 <Axman6> yeah
06:53:13 <edwardk> they'll go wherever the register assignment dumps them
06:53:24 <GoldyOrNugget> http://learnyouahaskell.com/chapters   <--  hopefully this will be good
06:53:38 <Axman6> yep
06:53:41 * edwardk has been obsessing about unboxed types and the unpacker and what it can get away with the last couple of days
06:53:57 <Axman6> edwardk: sounds like fun :)
06:54:51 <boegel> isn't Data.Time supposed to be a part of GHC?
06:55:03 <dayzman> in line 18 http://haskell.pastebin.com/m25d10451, how come ghc complains about the variable 'e' is of an ambiguous type?
06:55:11 <doserj> boegel: not in ghc 6.10.2
06:55:17 <edwardk> right now i'm fighting with type level naturals to define a clean way to 'split' a tuple in a way that the compiler won't complain about. once i have that i should have most of the machinery i need for the generic packed tuple/set/map/sequence/tree/etc.. stuff
06:55:27 <boegel> doserj: oh... any reason why?
06:55:45 <boegel> doserj: building the cabal package is also failing (Warning: -ffi is deprecated: use -XForeignFunctionInterface or pragma {-# LANGUAGE ForeignFunctionInterface#-} instead)
06:56:07 <doserj> the maintainer of the time package wanted a more frequent release schedule, it seams
06:56:36 <doserj> boegel: that's just a warning, though?
06:56:47 <Axman6> edwardk: leading to performance awesomeness?
06:56:50 <kadaver> @slap dobblego
06:56:50 <lambdabot> stop telling me what to do
06:56:56 <boegel> doserj: yeah, and then "Failing due to -Werror."
06:57:08 <jedai> dayzman: The extension system has been modified in GHC6.10, it is now a very cool extensible, flexible, hierarchy of exception type
06:57:15 <kadaver> @slap kadaver
06:57:15 <lambdabot> go slap kadaver yourself
06:57:23 <kadaver> @eat kadaver
06:57:23 <lambdabot> Maybe you meant: eval fact faq ft keal let map part read what
06:57:56 <dayzman> jedai: hmm right. so do i have to explicitly give e a type?
06:58:00 <jedai> dayzman: write (\(SomeException e) -> ...) instead and you'll get the equivalent of the old semantic
06:58:18 <kadaver> @let eat x = x "tastes so good"
06:58:20 <lambdabot>  Defined.
06:58:29 <kadaver> eat "kadaver"
06:58:37 <kadaver> @let eat x = x ++ "tastes so good"
06:58:38 <lambdabot>  Couldn't match expected type `[a]'
06:58:41 <jedai> dayzman: Yes :) SomeException is at the top of the exception hierarchy so it should catch everything like the old catch
06:58:45 <kadaver> @let eat x = (x ++ "tastes so good")
06:58:46 <lambdabot>  Couldn't match expected type `[a]'
06:58:58 <kadaver> @let eat x = "tastes so good"
06:58:58 <lambdabot>  <local>:7:0:
06:58:58 <lambdabot>      Warning: Pattern match(es) are overlapped
06:58:58 <lambdabot>               In...
06:59:17 <kadaver> @let bite x = "tastes so good"
06:59:18 <lambdabot>  Defined.
06:59:23 <kadaver> @bite kadaver
06:59:23 <lambdabot> Maybe you meant: bid dice elite gsite time vote
06:59:33 <kadaver> > bite kadaver
06:59:34 <lambdabot>   Not in scope: `kadaver'
06:59:38 <kadaver> > bite "kadaver"
06:59:39 <lambdabot>   "tastes so good"
06:59:57 <kadaver> @undefine bite
06:59:58 <jedai> dayzman: Or you could use the old exception system
07:00:26 <jedai> dayzman: but since it's doomed to disappear in the distant future...
07:01:09 <boegel> seems like Data.Time is utterly broken in ghc 6.10 :-/
07:01:30 <jedai> dayzman: www.haskell.org/~simonmar/papers/ext-exceptions.pdf contains a good explanation of the new system
07:01:42 <EvilTerran> kadaver, @undefine doesn't take parameters, it undefines everything
07:01:55 <EvilTerran> (well, everything defined by @let, i mean)
07:02:03 <dayzman> thanks
07:02:18 <jedai> boegel: I don't think so. It's included in 6.10.1
07:02:50 <jedai> The move out of extra-library in 6.10.2 was for versioning or maybe license reason
07:03:03 <jedai> It should still work
07:04:40 <boegel> jedai: well, it's not
07:05:00 <boegel> jedai: it fails to compile because of warnings being generated, and -Werror being specified in several source files
07:05:15 <boegel> jedai: I can remove them, but I doubt that's the best way to go
07:05:25 <dayzman> jedai: i've imported SomeException but now I get an error saying the 'SomeException' is not in scope.
07:06:53 <dayzman> jedai: this is what i have: http://haskell.pastebin.com/m2b526f0d
07:07:16 <dayzman> jedai: http://haskell.pastebin.com/ma23c00b rather
07:07:34 <jedai> dayzman: import Machin (Blabla) only import the _type_ Blabla, it doesn't import its constructors
07:08:44 <jedai> You have to write import Machin (Blabla(Foo)) to import the constructor Foo or the type Blabla, or import Machin (Blabla(..)) to import all constructor of Blabla IIRC
07:09:18 <jedai> dayzman: Like PortId(..) in your Network import
07:09:28 <dayzman> jedai: i see
07:09:29 <dayzman> thanks
07:14:26 <edwardk> boegel: what is using -fffi?
07:15:08 <RowanD> Does anyone know how efficient the OBDD cabal package is compared to C and ML implementations?  Both in terms of time and memory.  Is it largely done strictly?
07:15:10 <edwardk> boegel: can you replace the flag on what is being compiled with the -XForeignFunctionInterface ?
07:16:43 <maxote> RowanD, what are the C and ML implementations of OBDD?
07:17:24 <RowanD> Well, there's many C implementations.  David Long's was the cannonical one for a long time.
07:18:05 <beelsebob> does anyone know if this is defined somewhere?
07:18:06 <beelsebob> f ac i = let b = ac i in b <^(:)^> f ac b
07:18:11 <beelsebob> hayoo doesn't get it
07:18:11 <RowanD> Now I guess it's Cudd.
07:18:25 <RowanD> But, a comparison with either would be fine.
07:18:59 <maxote> none of X implementation can be more efficient than Cudd in the sense of local-minimal ROBDD
07:20:14 <edwardk> RowanD: iirc the obdd stuff was not as efficient as the usual c or ml versions
07:20:33 <edwardk> RowanD: i looked at it when i was writing a datalog implementation as part of my type checker and passed on it
07:20:52 <RowanD> Maxote: For ML - there are many reasonably direct implementations that seem about a factor of 2 of Long's implementation.  Just ROBDDs.  I've worked with a couple of them.
07:20:52 <maxote> the another efficient OBDD implementation is buddy
07:21:37 <RowanD> Maxote: yeah, buddy is C++.
07:21:38 <edwardk> both buddy and cudd could learn a bit about decent packaging practices. they aren't bundled well
07:22:39 <EvilTerran> beelsebob, hackage://InfixApplicative
07:22:53 <codebliss> Ahoy yall haskell hackers!
07:23:08 <RowanD> I'm just wondering what the actual difficultly is in Haskell - having seen reasonably direct ML versions work within a factor of 2 of C.
07:24:22 <opqdonut> beelsebob: that's kinda like iterateA right?
07:24:25 <edwardk> RowanD: the haskell version was an attempt to actually employ a haskell like lazy approach using constructors for everything
07:24:38 <EvilTerran> beelsebob, ah, never mind, misunderstood you
07:24:39 <edwardk> iirc it was pretty good if you didn't use the entire bdd
07:25:04 <beelsebob> opqdonut: where's that defined?
07:25:06 <RowanD> I actually spent half of my summer project 15 years ago porting a system to use Long's implementation instead of a pretty naive ML one.  And the difference was pretty small in the end.
07:25:09 <edwardk> rowand: it'd be possible to write a bit-twiddly one that worked like something more traditional
07:25:11 <opqdonut> beelsebob: it isn't :)
07:25:14 <beelsebob> oh
07:25:15 <beelsebob> bugger
07:25:52 <dayzman> what does the $ sign mean in "while2 x y = ifM x (return ()) $ ifM y (return ()) $ while2 x y"?
07:25:54 <edwardk> rowand: yeah i just stopped using them and switched to doing my queries relationally. i was greatly amused by http://doop.program-analysis.org/docs/nepls09.pdf when i saw it a few weeks ago
07:26:10 <RowanD> edwardk: Yeah, just interesting that in ML this is easy, and in Haskell no one has managed it.
07:26:14 <codebliss> Imagine the $ is a ( and add another ) to the end of the expression
07:26:15 <maxote> edwark, the lazy approach is supposely a bit useless
07:26:18 <kadaver> does Haskell FFI link to source code or compiled files?
07:26:24 <edwardk> bravenboer and company just stopped using BDDs because they tend to suck when you make analyses tighter.
07:26:29 <RowanD> Personally, I think it is something Haskell should be able to do well.
07:26:31 <codebliss> foo $ bar  is   foo (bar))
07:26:40 <edwardk> rowand: i think its more of a matter of no one has bothered.
07:26:58 <edwardk> maxote: agreed
07:27:13 <codebliss> a . b $ c $ d <$> e    is    a . b (c (d <$> e))
07:27:30 <codebliss> Since haskell is left associative, that can make it right and save ()'s
07:27:46 <opqdonut> codebliss: you left that . there
07:27:50 <maxote> for very complicatd algorithms, ML is OK, C is not good.
07:28:05 <EvilTerran> ?src ($)
07:28:05 <lambdabot> f $ x = f x
07:28:13 <RowanD> edwardk - hmmm, many poeple have bothered with ML.  In fact it's so easy, that people just build their own when they need one.  I guess making things strict enough is a pain.
07:28:20 <EvilTerran> more explicitly, "f $ x = (f) (x)"
07:28:51 <edwardk> rowand: the few haskell things i've seen that use bdd's tend to just invoke a c lib for it
07:29:10 <EvilTerran> (i feel it more accurately captures the intent of using $ if you write it like thaT)
07:29:11 <edwardk> be it cudd of buddy or what have you
07:29:14 <edwardk> er or
07:29:33 <maxote> RowanD, start to write (if you want) your own ROBDD in ML from scratch.
07:29:47 <wli> parens around single tokens are meaningless
07:29:50 <edwardk> there was a package that interfaced to a bunch of different bdd implementations, but i think it just fell out of use and never made it into the modern hackage setup, etc.
07:30:06 <RowanD> edwardk - yeah, that makes sense, unless you're advocating Haskell as a general purpose language.  :)
07:30:22 <EvilTerran> wli, i know that, you know that, heck, most newbies've probably already worked that one out by the time they get to "what does $ mean?"
07:30:50 <RowanD> maxote: I have to prepare a project to hand out and a completely new lecture to give in the next 13 hours.
07:30:53 <edwardk> RowanD: meh, this is just a cause that no one has seen to fit to make into their 'purpose' ;)
07:30:55 <EvilTerran> wli, but i find "f $ x = (f) (x)" can provide more immediate insight than leaving those parens out
07:31:01 <wli> I still haven't figured out Chakravarty's modules + typeclasses paper.
07:31:36 <wli> Not much more than knowledge of application by juxtaposition provides.
07:31:38 <edwardk> wli: you should pick his brain about it. he's usually in here
07:31:38 <Duqicnk> wli: not totally meaningless, it makes an infix opr prefix
07:32:10 <EvilTerran> well, every little helps, eh
07:32:30 <dayzman> codebliss: thanks
07:32:56 <maxote> RowanD, inmho, there are 3 choices: ML examples using A) cudd library, B) buddy library, C) own BDD in ML from scratch. Doing wrappers for ML of A) and B) have the problem of that it's C++, and ML only has C for invoking.
07:33:06 <RowanD> edwark: I was thinking of including BDDs in the project I'm handing out tomorrow.  But, now I'm thinking not.
07:33:37 <maxote> i think that buddy is C
07:34:12 <RowanD> maxote: Yeah, there was a paper published explaining why the system I worked on was only a little better using the best C library compared to ML.
07:34:37 <RowanD> Buddy is C++.
07:34:55 <RowanD> I thought.
07:35:06 <kadaver> does Haskell FFI link to source code or compiled files?
07:35:09 <edwardk> its easy enough to slap a c wrapper on it though
07:36:11 <codebliss> @hooge (***)
07:36:11 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:36:21 <maxote> C, ML and Java  <-- do you remember the 3 books of Andrew W. Appel? they're fairly OK.
07:37:06 <EvilTerran> codebliss, if it makes it clearer, you can write that (albeit with an extension) as "Arrow (~>) => (b ~> c) -> (b' ~> c') -> ((b,b') ~> (c,c'))"
07:37:16 <wli> I've only seen the Java one. I discovered I hate Java in the course.
07:37:40 <EvilTerran> wli, heh. i made the same discovery in the first uni course they taught us java.
07:37:59 <wli> That was my first uni course using Java.
07:38:16 <RowanD> Maxote: yeah, I did my PhD at CMU, so I guess I'm part of the SML crowd.
07:38:22 <maxote> i love the triangle of Appel
07:38:42 <Duqicnk> java is a really good language for its niche.  that niche is allowing loads of not-terribly-intelligent people to write huge boring business apps
07:38:55 <RowanD> Maxote: with BDDs ML does even better - lots of allocation, and C implementations have to make their own closures anyway.
07:38:58 <Duqicnk> which like it or not is basically the foundation of our modern world
07:39:02 <maxote> pick any vertex most convenient of the triangle and you will win.
07:39:05 <Duqicnk> and i'd rather they use java than COBOL
07:39:07 <vixey> Duqicnk: Where do you get the impression these people are stupid
07:39:17 <Duqicnk> didn't say they all are
07:39:23 <dayzman> codebliss: that line of code i pasted "while2 x y = ifM x (return ()) $ ifM y (return ()) $ while2 x y" is supposed to "-- repeats two actions until either returns true", but how is that the case? isn't it equivalent to while2 x y = ifM x (return ()) (ifM y (return ()) (while2 x y))?
07:39:26 <wli> I'm not entirely sure where to start since I'd dispute effectively all of that.
07:39:47 <vixey> Duqicnk: you're just gonna say "didn't say they all are" and not answer my question?
07:39:53 <bastl> is there something like "fromJust" for Either types ? Or do I miss a trick? I would expect left :: Either a b -> a ...
07:40:06 <Duqicnk> that is an answer, i don't think they're all stupid.  i think extreme intelligence is not a prereq for programming in java.
07:40:18 <opqdonut> bastl: you see, that would be undefined when you have a Right value
07:40:20 <opqdonut> so not good
07:40:21 <opqdonut> but:
07:40:22 <opqdonut> :t either
07:40:24 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
07:40:26 <vixey> Duqicnk: so basically you don't actually mean what you said?
07:40:32 <opqdonut> takes too projection functions
07:40:40 <vixey> Duqicnk: since now you're putting a totally different spin on it..
07:40:43 <Duqicnk> no, you don't understand what "allow" means
07:41:01 <dayzman> codebliss: i've pasted it here: http://haskell.pastebin.com/m540e8eea
07:41:03 <vixey> Duqicnk: yeah that'll be it. I better go look it up...
07:41:13 <wli> The foundation for the modern world is not business apps but military and espionage.
07:41:30 <Duqicnk> well sure, that was hyperbole.  they're pretty important though
07:41:33 <wli> Computers (a) crack ciphers and (b) calculate missile trajectories.
07:41:35 <bastl> opqdonut: thanks.
07:41:36 <vixey> Duqicnk: since you've given me some great advice I'll give you some too:  Say things you mean
07:41:45 <EvilTerran> vixey, http://xkcd.com/386/
07:41:54 <EvilTerran> relas
07:41:55 <vixey> Duqicnk: even better if you can back it up with actual facts
07:41:56 <Duqicnk> vixey: i stand by the original statement.  you are misreading it, and i don't think it's worth arguing about anyway
07:41:56 <EvilTerran> *x
07:41:58 <maxote> wli, (c) find secret or doom numbers
07:42:20 <maxote> it's not the same that crack ciphers
07:42:27 <wli> maxote: Whatever.
07:42:35 <Duqicnk> (d) find name of god as 216-digit integer
07:43:00 <Gracenotes> Duqicnk: in base 1? Oh, that's easy
07:43:07 <EvilTerran> (e) find prediction of the apocalypse in the distribution of primes
07:43:10 <wli> There's a book called "when computers were human" or some such floating around.
07:43:26 <vixey> Duqicnk: (it's pathetic to just repeat some dogma you read off reddit or paulgraham.com or whereever you got this nonsense)
07:43:57 <maxote> sqrt(5+sqrt(5)) can't be handmade
07:43:57 <Duqicnk> vixey: you're right, there's no way i could have formed this opinion myself
07:44:00 <Duqicnk> since it is so complicated
07:44:50 <vixey> Duqicnk: If you meant what you said you would not have trouble to actually *explain* it -- since you just want to take pot shots at large groups of people with no backing I'm gonna stop bugging you about it now
07:44:59 <EvilTerran> vixey, i  think you're reading far too much into what struck me as an off-hand remark that wasn't meant to be taken entirely seriously
07:45:23 <dayzman> with ifM in http://haskell.pastebin.com/m540e8eea, how can p' be evaluated? isn't p' a free variable?
07:45:55 <vixey> dayzman: look: (\p' -> if p' then t else f)
07:46:02 <vixey> dayzman: lambda binds p' there
07:46:07 <Duqicnk> vixey: i think you're mistaking "some successful java programmers are dumb" for "all successful java programmers are dumb".  since i've explained which i meant at least twice by now, i'd guess you're being angry and defensive on purpose.  and anyway i didn't say dumb, i said "not-terribly-intelligent"
07:46:26 <Gracenotes> x^4 - 10x^2 + 20 = 0
07:46:31 <vixey> Duqicnk: already gone on too long...
07:46:36 <EvilTerran> Duqicnk, let it go already, geez
07:46:36 <Duqicnk> yup
07:46:57 <RowanD> edwardk/maxote: when I have time I'll try to convert my direct ML implementions to Haskell.  They don't do all the high level optimizations some implementations do, but having a basically good one for Haskell would be interesting, as would failing in the process.
07:48:27 <aLegendaryPengui> what are some good psychostimulants
07:48:52 <RowanD> You can close your eyes and program in Java as if it was Lisp.  You have to ignore a lot of syntactic noise though.
07:48:53 <marcot> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3500#a3500
07:49:09 <marcot> I've got this problem inside a code, and it was not so easy to get to this simple example.
07:49:12 <maxote> RowanD, i won't convert ML to Haskell, lazyness, monads, etc. don't help me.
07:49:24 <marcot> In it, h works, but g gives me the error in the title.
07:49:28 <lilac> i'm confused. looks like Duqicnk said that (1) Java allows less intelligent people to get certain work done, and (2) it is a good language for that purpose?
07:49:50 <orbitz> Java allows less itnelligent people to get a bad program working in my experience
07:49:56 <orbitz> it does not allow smart people to write better software
07:50:04 <Gracenotes> I think PHP wins that contest though
07:50:25 <aLegendaryPengui> what do you mean, it does not a llow smart people to write better software
07:50:39 <lilac> i think reading into that that e's saying "all Java programmers are stupid" or whatever is just silly
07:50:46 <RowanD> maxote: I guess the point of the exercise would be to see how much Haskell gets in the way when you have something that naturally works well it is strict.
07:51:20 <beelsebob> got a challenge for everyone... let iterateM n f i = sequence . scanl (>>=) (return i) $ replicate (n-1) f
07:51:24 <beelsebob> that's quadratic
07:51:31 <orbitz> aLegendaryPengui: java has a lot of tools for doing really dumb hings, like readign XML, maign GUI's, spawning threads.  but it doesn't have things for solving interesting problems.  for instance the containers suck, only classes and primitives are first class, etc
07:51:32 <beelsebob> can you write it so it's linear
07:51:37 <beelsebob> and not using primitive recursion
07:51:48 <lilac> beelsebob: can i use 'fix'? :)
07:51:52 <beelsebob> if you like
07:52:02 <beelsebob> but not in a way that's really just primitive recursion :P
07:52:03 <RowanD> beelsebob: can I use COBOL?
07:52:04 <aLegendaryPengui> whats dumb about making guis
07:52:07 <beelsebob> RowanD: bad :P
07:52:20 <aLegendaryPengui> or threads
07:52:29 <maxote> RowanD, do you see any benefit to use Haskell instead of ML? (e.g. the lazyness bounds some computation ...)
07:52:41 <osfameron> doesn't Java have some interesting lazy parallelism abstraction work going on recently?
07:52:43 <aLegendaryPengui> haskell has threading doesnt it
07:52:48 <beelsebob> yes
07:52:59 <beelsebob> it's one of Haskell's biggest strengths
07:53:07 <beelsebob> the threading is super-fast
07:53:13 <orbitz> aLegendaryPengui: GUI's do not require much, someone has to design a godo GUI but that is fairly independent of the devlopment, just attach soem listeners and you are done
07:53:24 <maxote> the dude is it really bounds the computation or not
07:53:28 <orbitz> java has a unch of threading primtives to maek life easier (arguably they suck)
07:53:36 <Gracenotes> beelsebob: why not forget the integer argument?
07:53:39 <vixey> maxote: can you try and make sense
07:53:53 <Gracenotes> if you have an infinite list it'd be lazy anyway
07:54:00 <beelsebob> Gracenotes: because not all monads are lazy
07:54:02 <EvilTerran> Gracenotes, no it won't
07:54:07 <EvilTerran> (well, not necessarily)
07:54:08 <beelsebob> specifically the one in question here isn't
07:54:23 <Gracenotes> even if the monad is not lazy the list will be
07:54:26 <maxote> i only use lazyness for lazy constructs as infinite lists, infinite trees and implicit iterators.
07:54:37 <EvilTerran> > sequence (repeat (Just ()))
07:54:39 <lambdabot>   * Exception: stack overflow
07:54:44 <opqdonut> indeed
07:54:48 <beelsebob> Gracenotes: no, because you need to find out that it is a list inside the monad
07:54:49 <EvilTerran> Gracenotes, ^ that's the problem, in a nutshell
07:55:03 <Gracenotes> maxote: perhaps you want something more like unfoldr
07:55:05 <dayzman> with monads, why is the right hand side of the bind a function?
07:55:20 <dayzman> e.g., p >>= k  =  \s0 -> let (s1, a) = p s0
07:55:32 <beelsebob> dayzman: it's clearer if you think about (=<<) instead
07:55:42 <beelsebob> then it's just a function transformer
07:55:48 <Gracenotes> @src Maybe (>>=)
07:55:48 <beelsebob> (a -> b) -> a -> m b
07:55:48 <lambdabot> (Just x) >>= k      = k x
07:55:48 <lambdabot> Nothing  >>= _      = Nothing
07:55:50 <RowanD> maxote: the only benefit of using Haskell will be that other Haskell programmers will be able to easily experiment with and improve it.  BDDs really benefit a lot from higher level optimizations, and I think these will be easier to experiment with in Haskell.
07:55:54 <nominolo> @hoogle Monad m => m Bool -> m a -> m a -> m a
07:55:54 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
07:55:54 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
07:55:54 <lambdabot> Text.ParserCombinators.ReadP between :: ReadP open -> ReadP close -> ReadP a -> ReadP a
07:56:12 <Gracenotes> sadly not, nominolo :\
07:56:35 <RowanD> Maxote: well, maybe - at least they are easier in ML than C or C++.  And Haskell people seem much more active than ML people these days for such things.
07:56:36 * wjt wants ifM too
07:56:40 <nominolo> Gracenotes: ifM really is an omission
07:56:40 <lambdabot> nominolo: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:56:52 <dayzman> beelsebob: hmm i don't know =<<
07:56:54 <wjt> wasn't there some discussion of a typeclass between Applicative and Monad that supports ifM?
07:56:55 <vixey> bool is the omission
07:56:59 <maxote> i will prefer a 2nd-class citizen ML instead of 1st-class citizen Haskell.
07:57:03 <Gracenotes> vixey: one omission
07:57:06 <beelsebob> dayzman: it's just the reverse of (>>=)
07:57:15 <beelsebob> (=<<) :: (a -> b) -> a -> m b
07:57:20 <beelsebob> woops
07:57:21 <beelsebob> no
07:57:30 <beelsebob> (=<<) :: (a -> m b) -> m a -> m b
07:57:33 <edwardk> rowand: i started to put together a lib for BDDs, but the pre-existing ones kind of made me feel like i'd have been spinning my wheels
07:57:49 <vixey> :t (join .) . liftM
07:57:49 <beelsebob> it's converting a function from something that returns a monadic item, into something that accepts and returns a monadic item
07:57:50 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
07:57:50 <nominolo> @index when
07:57:50 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:57:53 <edwardk> rowand: plus it was about 5 steps removed from my actual problem at the time ;)
07:59:13 <RowanD> Maxote: yeah, indeed that it what laziness is used for mostly.  But, Haskell supports strictness as well.  The question is how well.
07:59:32 <maxote> why? i'm afraid of the excess of lazyness
07:59:52 <maxote> inmho, lazyness everywhere is not good.
07:59:56 <lilac> iterateM n f i = reverse $ iterate (>>= f) (return i) !! n -- beelsebob ?
08:00:28 <RowanD> Maxote: I guess I somewhat agree.  I'd like to have more data points to make a proper comparison though.
08:00:29 <edwardk> rowand: programming strictly in haskell isn't so bad. liberal use of bang-patterns and unpacking can take care of 90% of your needs
08:00:51 <lilac> beelsebob: erk, forget the 'reverse', that was from a previous thing
08:00:53 <dayzman> beelsebob: right..
08:01:12 <RowanD> Edwardk: yeah, given that it's surprising that ML has numerous good BDD implementations and Haskell has none.
08:01:15 <Gracenotes> ^ see? lilac's solution uses an infinite list! :X
08:01:45 <Elly> I want to start a startup whose business model is "Program in Haskell"
08:01:50 <maxote> "Lazy languages are for lazy programmers, eager languages are for eager programmers." What's your opinion?
08:01:52 <Gracenotes> even if the monad is strict, that work. Which was my point :\
08:01:54 <beelsebob> lilac: that only produces the final value
08:02:03 <beelsebob> it's a fold, not a scan
08:02:23 <Gracenotes> perhaps you could forget the integer argument then
08:02:24 <edwardk> rowand: if i wasn't neck deep in projects i'd add it to my queue ;)
08:02:28 <lilac> @type \n f i -> sequence $ iterate (>>= f) (return i)
08:02:29 <lambdabot> forall t (m :: * -> *) a. (Monad m) => t -> (a -> m a) -> a -> m [a]
08:02:30 <lilac> better?
08:02:51 <Elly> Business plan: 1. Program in Haskell. Pay programmers in stock options. 2. ??? 3. Profit!
08:02:52 <beelsebob> lilac: doesn't terminate
08:02:57 <beelsebob> because it uses the infinite list
08:02:59 <lilac> @type \n f i -> sequence . take n $ iterate (>>= f) (return i)
08:03:00 <lambdabot> forall (m :: * -> *) b. (Monad m) => Int -> (b -> m b) -> b -> m [b]
08:03:01 <edwardk> maxote: bah, it takes a lot of effort to be sufficiently lazy ;)
08:03:02 <lilac> so picky
08:03:41 <stulli> Where can i find a list of symbols that are allowed to be used as/inside operators?
08:04:07 * zachk goes "HOORAY" as he comes to better grips with monads
08:04:17 <lilac> beelsebob: although it doesn't really solve the problem now does it? ;-)
08:04:26 <aLegendaryPengui> how do i work the lambda bot
08:04:30 <beelsebob> lilac: sec, just trying to unkill my terminal
08:04:38 <aLegendaryPengui> ??
08:04:58 <lilac> i now remember what i was trying to do in the first place, before i 'simplified' it and made it quadratic again :)
08:05:03 <aLegendaryPengui> (repeat 5)
08:05:13 <beelsebob> yeh
08:05:19 <edwardk> aLegendaryPengui: erm, there are a lot of things you can do, to evaluate something prefix the line with >
08:05:20 <beelsebob> it is quadratic still
08:05:22 <edwardk> > repeat 5
08:05:24 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
08:05:28 <aLegendaryPengui> oh, lol
08:05:42 <jedai> stulli: The reference for that kind of question is the Haskell98 Report
08:05:43 <aLegendaryPengui> can i set variables on lambdabot
08:05:50 <RowanD> edwardk: I think you could be right.  But, people say the same about ML - that programming lazily is very easy.
08:05:52 <Elly> Gracenotes: hey, do you have that haskell code that looked like a smiley handy?
08:06:00 <Gracenotes> @quote lol
08:06:00 <lambdabot> glguy says: lol, making lambdabot fight your battles
08:06:00 <jedai> @where report
08:06:01 <lambdabot> http://www.haskell.org/onlinereport/
08:06:04 <aLegendaryPengui> > let x = 5
08:06:06 <Gracenotes> @quote lol
08:06:06 <lambdabot> Gracenotes says: > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
08:06:06 <edwardk> the operator is reminiscent of the "bird tracks" used in literate haskell
08:06:09 <aLegendaryPengui> > x
08:06:11 <lambdabot>   <no location info>: parse error on input `;'
08:06:12 <lambdabot>   x
08:06:27 <aLegendaryPengui> @quote LegendaryPenguin
08:06:27 <lambdabot> No quotes match. My brain just exploded
08:06:27 <RowanD> edwardk: in fact, it's easier than strict programming in Haskell.
08:06:28 <edwardk> RowanD: meh, whatever someone else is doing is easy. whatever you are doing is hard. otherwise where is the value in what you are doing? =)
08:06:42 <Gracenotes> Elly: if you want you can replace o' o' with o' lol. which creates a circular reference (although it's never used)
08:07:06 <dayzman> with the monad at http://haskell.pastebin.com/m7b31c535, how come f w = (g w) >>= ...? doesn't (g w) replace p? in that case, x replaces s0 which is the argument of p, thus (g w).
08:07:09 <stulli> jedai, found it, thanks!
08:07:27 <RowanD> edwardk: no, I mean that do doing lazy programming is easy in ML.  Maybe easier than strict programming in Haskell.
08:07:27 <maxote> RowanD, in shootout, Clean is more efficient than Haskell, both are lazy langs, but Clean has commercial license or GPL i think.
08:07:45 <edwardk> RowanD: otoh you have that niggling value restriction, and all that crufty syntax =)
08:08:20 <RowanD> Er - the value restriction is never an issue.  An eta expansion at most.
08:08:30 <maxote> RowanD, is the efficiency your condition? convert ML to Clean can be a little better, but its language syntax is little bit longer and strange.
08:08:34 <RowanD> The syntax is more of an issue.
08:08:48 <edwardk> rowand: i think its a comfort zone thing. i personally find that lazy programming in ML is not as easy as haskell, at least not to the degree you can be lazy in haskell. when you stop to think about all of the things that in haskell are lazy its somewhat terrifying to think about manually delaying and forcing them all
08:09:09 <zachk> edwardk: whats a BDD?
08:09:26 <edwardk> foo (1,2) = ... forces 3 thunks
08:09:36 <edwardk> zachk: binary decision diagram
08:09:37 <lilac> @type \n f i -> foldM (\(x:xs) _ -> (:x:xs) `liftM` f x) (return i) [1..n]
08:09:38 <lambdabot> forall b a1 (m :: * -> *). (Enum b, Num b, Monad m) => b -> (a1 -> m a1) -> a1 -> m [a1]
08:09:53 <jedai> RowanD: In my experience programming lazily in OCaml is uncomfortable... and slow
08:09:56 <RowanD> Maxote: to me for ML, efficiency means within a factor of 2.
08:10:02 <edwardk> zachk: robdd's are a nice structure for storing things like relations in a decently compressed manner
08:10:04 <Elly> Gracenotes: you are a bad person, for the record :P
08:10:11 <RowanD> For Haskell I'd extend that to a factor of 4 of C.
08:10:32 <Gracenotes> :X
08:10:32 <maxote> RowanD, i did a half value of the efficiencies of some examples between Haskell, Clean and ML
08:10:53 <Gracenotes> where can I collect my accolade
08:10:59 <lilac> > let iterateM n f i = reverse `liftM` foldM (\(x:xs) _ -> (:x:xs) `liftM` f x) (return i) [1..n]    in iterateM 3 (\n -> [0..n-1]) 5
08:11:00 <lambdabot>   [[5,2,1,0],[5,3,1,0],[5,3,2,0],[5,3,2,1],[5,4,1,0],[5,4,2,0],[5,4,2,1],[5,4...
08:11:14 <edwardk> personally i find that when i relax my preconceptions about what has to be strict i can often get huge performance wins through fusion rules and laziness and still retain the conceptual clarity of writing completely separate definitions.
08:11:16 <RowanD> With similar values for the memory efficiency.  Maybe a bit more though - double is fine.
08:11:52 <RowanD> edwardk: try BDDs then.  I don't think they are like that.
08:11:55 <edwardk> every once in a while though you really need to touch everything, then strictness is a huge win
08:12:07 <edwardk> RowanD: bdds unfortunately usually require you to touch everything
08:12:31 <edwardk> because to do the ROBDD thing you need to basically hash cons it together. and that means inspecting it
08:12:35 <edwardk> so laziness is a loss
08:12:47 <RowanD> edwardk: I think many really good data structures are like that.  But, BDDs are maybe an extreme case.
08:13:05 <edwardk> they are, almost anything that hash conses like that tends to be a loss
08:13:19 <RowanD> Perhaps people just haven't designed equivalently good lazy data structures.
08:13:27 <maxote> Clean 2.2 vs Haskell 6.6.1, Clean is avg 6.88 times better than Haskell in speed, and avg 3.54 times better in memory.
08:13:51 <RowanD> But, until they do, people are going to want strictness.
08:14:35 <edwardk> RowanD: well, right now we're going through and putting together some nice strict libraries. dons and I have been working on a set of strict containers that automatically unbox
08:14:38 <RowanD> Jedai - that it's my experience.  The lazy programming I've done in SML has worked really well.
08:15:07 <RowanD> I was using monads and laziness in SML in a large system, and it worked really well.
08:15:26 <RowanD> Aside from the syntax having too many ()s.  :)
08:15:43 <edwardk> i'll admit that i tend to agree with robert ennals and some of the speculative evaluation/eager haskell folks that perhaps laziness is the wrong default. but I do like the clarity of thought that it permits
08:16:20 <edwardk> personally i really wish there was a viable implementation of the speculative eval stuff that ennals put together in use somewhere
08:18:40 <RowanD> edwardk: Cool, sounds like the right direction.
08:19:00 <RowanD> I guess you have control in the sense of having strict collections of lazy values, etc.?
08:19:14 <edwardk> yeah.
08:19:32 <RowanD> Yeah, that's basically what you want.
08:19:45 <edwardk> http://comonad.com/haskell/graphs/USet.gif vs http://comonad.com/haskell/graphs/Set.gif
08:20:04 <RowanD> Then you can start without thinking about evaluation order, and refine it if you need to.
08:20:06 <edwardk> nicely unboxed and packed away in the data structure
08:21:01 <edwardk> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/adaptive-containers has similar charts for unboxed lists
08:21:29 <nanothief> With the code http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2070#a2070 ,  I'm not sure why I am getting an UndecidableInstances type error. I want to write a default definition for ReaderAccessorThatCanFail for any types that are instances of ReaderAccessor. Any ideas, or better ways of doing this?
08:22:50 <RowanD> edwardk: nice, yes.
08:22:51 <dayzman> for http://haskell.pastebin.com/m540e8eea, there's no do block in while2, then is it using the monad?
08:24:28 <EvilTerran> dayzman, you don't need a do-block to be using a monad
08:25:19 * gwern reads about Ennal's 'Non-Non-Blocking Software Transactional Memory'
08:25:48 <edwardk> gwern: heh, giving up the guarantees does help make it faster =)
08:25:53 <dayzman> EvilTerran: so is a do block used to pass values around?
08:26:04 <EvilTerran> a do-block is nothing but syntactic sugar
08:26:19 <RowanD> edwardk: I'm kinda in between Haskell and ML these days.  Did my PhD at CMU in SML, been teaching in Haskell since because we had two courses in it.  Teaching in F# currently because both our FP course got merged with concurrency and other stuff into one course.  (Arg.)
08:26:23 <doserj> nanothief: what your instance declaration is actually saying is: every type is an instance of ReaderAccessorThatMightFail (and must be an instance of ReaderAccessor)
08:26:30 <EvilTerran> dayzman, see http://haskell.org/onlinereport/exps.html#sect3.14
08:27:10 <dayzman> EvilTerran: ok thanks
08:27:20 <codebliss> main = getLine >>= putStrLn        VS           main = do { x <- getLine; putStrLn x; }
08:27:23 <codebliss> Pick what you want lol
08:27:39 <doserj> nanothief: there is no simple thing for what you want to do, I think
08:28:02 <beelsebob> main = putStrLn =<< getLine -- this one please :)
08:28:06 <codebliss> RowanD: F# is cool too =).  I like pure much more though.  At least it's practical
08:28:08 <dayzman> EvilTerran: but with that code, the monadic if checks the value of p', but where does the value come from?
08:28:09 <edwardk> rowand: sounds messy. personally i _want_ to like f#, but the lack of a module system basically leaves me with nothing to love.
08:28:43 <codebliss> beelsebob: Hehe, just takes time to get a style that fits you
08:29:00 <codebliss> edwardk: It's really fun for euler problems.  Also the fact you can tie with .net
08:29:34 <edwardk> i also find that i use rank-n polymorphism a lot and i just can't get there in f# without cheating and doing ugly casts into and out of objects. if i'm going that far i should just use ironpython ;)
08:29:49 <edwardk> codebliss: i do enough .net for my day job =)
08:29:55 <nanothief> doserj, so the type isn't saying that: every type that is an instance of ReaderAccessor is an instance of ReaderAccessorThatMightFail (thats how I read that code).
08:30:02 <codebliss> edwardk: Then do haskell at home!  =P
08:30:36 <doserj> nanothief: not exactly, no
08:30:51 <Vq^> edwardk: then only by doing Haskell at home can you save your sanity! :o)
08:30:56 <edwardk> codebliss: thats pretty much my life ;)
08:31:01 <nanothief> doserj, well that explains why it isn't working then, thanks
08:31:29 <codebliss> edwardk: Hehe, sweet.  I found out about f# in the c# channel and immediately jumped on it.  Took me a while to understand functional, and have loved it since
08:31:41 <codebliss> edwardk: F# is just my first, so I give it more credit XD
08:32:07 <Vq^> i actually wrote a few codegenerators for C# when i worked with .net :)
08:32:10 <codebliss> Well, "extra" credit.  It's nowhere near as fun as haskell, but I can do practical stuff easier
08:32:15 <Vq^> (in haskell)
08:32:20 <codebliss> Vq^: In hs?  ah k
08:32:26 <codebliss> I heard a lot of stories about that lol
08:32:30 <codebliss> On some blog
08:32:37 <EvilTerran> dayzman, it's bound by the "\p' ->"
08:32:51 <EvilTerran> dayzman, vixey explained that earlier
08:32:54 <Vq^> codebliss: it beats coding C# directly ;)
08:33:15 <edwardk> f# is a great gateway drug to bring people in from c#. in that i can't complain. but it inherits all of the clunkiness of the ml syntax without the benefits. ML modules are awesome, but Don Syme doesn't see the point in module systems. and it fits better into the .net paradigm not to have them so its crippled =(
08:33:23 <codebliss> Vq^: Well C# was my first language I actually did useful stuff in, instead of learning the language but not actually doing anything useful (C++)
08:33:32 <codebliss> Vq^: I can still stand the redundancy (for now XD)
08:34:02 <edwardk> the thing is c# isn't bad to program in these days with linq and lambdas and extension methods i can fix most of what is wrong with the language APIs myself. ;)
08:34:26 <lilac> beelsebob: your problem is fundamentally quadratic, AFAICS. i've solved a different problem with the same type in a linear way, though
08:34:27 <dayzman> EvilTerran: yeah, but i don't quite get how p' is instantiated in while2
08:34:34 <codebliss> Hehe.  Haven't touched linq but from what I read it looks sweet.  Basically a monad.
08:35:15 <edwardk> linq is basically a monad comprehension + reflection on lambdas + some sort/order sugar
08:35:47 <codebliss> Yep =)
08:35:58 <adamvo> instance (Bounded a, Enum a) => Arbitrary a
08:35:59 <dayzman> EvilTerran: so if it was to evaluate "ifM x (return ()) $ ifM y (return ()) $ while2 x y ", x replaces p...
08:36:14 <edwardk> the reflection is nice because it can let linq translate things using the native syntax that no monad could translate in haskell. in that its a win for ease of use
08:36:28 <adamvo> is undecidable instances safe for such a thing, or do I have to decalare that instance for a newtype?
08:36:29 <lilac> beelsebob: your iterateM 4 f i = do i' <- return i; v1 <- f i; v2a <- f i; v2 <- f v2a; v3a <- f i; v3b <- f v3a; v3 <- f v3b; return [i,v1,v2,v3]
08:36:36 <edwardk> otoh, the semantics of everything are up for grabs once you give that much flexibility
08:36:56 <dayzman> EvilTerran: in that case, how is p' instantiated?
08:36:57 <lilac> beelsebob: i think you probably wanted 'iterateM 4 f i = do i' <- return i; v1 <- f i; v2 <- f v1; v3 <- f v2; return [i,v1,v2,v3]'
08:37:03 <edwardk> adamvo: that is a pretty sweeping instance, i wouldn't do it
08:37:06 <adamvo> ie. instance (Bounded a, Enum a) => Arbitrary (ClunkyNewtype a)
08:37:17 <lilac> beelsebob: in which case: iterateM n f i = reverse `liftM` foldM (\(x:xs) _ -> (:x:xs) `liftM` f x) (return i) [1..n-1]
08:37:20 <edwardk> adamvo: the ClunkyNewtype is the conceptually correct version
08:37:32 <lilac> > let iterateM n f i = reverse `liftM` foldM (\(x:xs) _ -> (:x:xs) `liftM` f x) (return i) [1..n-1]    in iterateM 3 (\n -> [0..n-1]) 5
08:37:33 <lambdabot>   [[5,1,0],[5,2,0],[5,2,1],[5,3,0],[5,3,1],[5,3,2],[5,4,0],[5,4,1],[5,4,2],[5...
08:37:39 <lilac> >  let iterateM n f i = sequence . scanl (>>=) (return i) $ replicate (n-1) f    in iterateM 3 (\n -> [0..n-1]) 5
08:37:41 <lambdabot>   [[5,0,0],[5,0,0],[5,0,1],[5,0,0],[5,0,1],[5,0,2],[5,0,0],[5,0,1],[5,0,2],[5...
08:38:11 <edwardk> the existing arbitrayr instances help focus on small cases, with just an Enum and Bounded you have no notion of where the zero' of the type is (well you could check to see if you fromEnum minbound and fromEnum maxBound if 0 lies in the middle and guess ;)
08:38:37 <lilac> beelsebob: here, my one (first) gives all consistent sequences (second element derived from first, third from second) whereas yours gives all possible sequences (any possible first element, any possible second, any possible third)
08:39:09 <edwardk> plus Enum and Bounded don't necessarily cover the type. for instance Floats are an Enum instance so you can use [1.0..3.0]
08:39:17 <edwardk> > fromEnum 1.5
08:39:18 <lambdabot>   1
08:39:43 <edwardk> > (maxBound :: Float)
08:39:44 <lambdabot>       No instance for (Bounded Float)
08:39:45 <lambdabot>        arising from a use of `maxBound'...
08:39:55 <edwardk> was curious =)
08:40:09 <doserj> instance Enum Float is arguably a wart, though :)
08:40:16 <edwardk> yeah
08:40:23 <lilac> beelsebob: likewise, in IO, "iterateM n (\n -> print n >> readLn) 0", your code will interact a quadratic number of times
08:40:28 <adamvo> edwardk: so it seems that the undecidable one won't break properties on floats?
08:40:33 <slide_rule> doserj: what do you mean by wart?
08:41:00 <adamvo> I'd hate to have to write fromIntegral [1 .. 100]
08:41:05 <aLegendaryPengui> didn
08:41:07 <EvilTerran> dayzman, the definition of >>= will pass a value to its second parameter
08:41:19 <doserj> it's ugly, there should be something nicer instead.
08:41:20 <lilac> slide_rule: Floats aren't enumerable in a sensible way; they're only in typeclass Enum to support enumFromTo etc
08:41:39 <lilac> > fromEnum (1.379 :: Float)
08:41:40 <lambdabot>   1
08:41:57 <edwardk> adamvo: the problem is in general that using undecidable instances because you don't want to make a bunch of definitions is risky especially if you define it in a 3rd party module. if you defined it where Bounded or Enum were defined? ok, fine. if you defined it in the module that defines Arbitrary, fine, but sitting on its own?
08:41:57 <doserj> @src Enum
08:41:58 <lambdabot> class  Enum a   where
08:41:58 <lambdabot>     succ                     :: a -> a
08:41:58 <lambdabot>     pred                     :: a -> a
08:41:58 <lambdabot>     toEnum                   :: Int -> a
08:41:58 <lambdabot>     fromEnum                 :: a -> Int
08:41:59 <lambdabot> [3 @more lines]
08:42:02 <adamvo> > fromEnum 1.5
08:42:03 <lambdabot>   1
08:42:13 <lilac> > succ 79.4
08:42:14 <doserj> Floats can support toEnum, but not fromEnum
08:42:14 <lambdabot>   80.4
08:42:26 <doserj> so the Enum class should be split-up
08:42:28 <lilac> > toEnum (fromEnum 79.4 + 1)
08:42:29 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
08:42:37 <lilac> > toEnum (fromEnum 79.4 + 1) :: Float
08:42:38 <lambdabot>   80.0
08:42:40 <aLegendaryPengui> > toEnum float
08:42:41 <lambdabot>   Couldn't match expected type `Int'
08:42:48 <edwardk> > fromEnum (1/0)
08:42:49 <lambdabot>   0
08:42:56 <edwardk> sweet
08:42:59 <lilac> > fromEnum (0/0)
08:43:01 <lambdabot>   0
08:43:04 <aLegendaryPengui>  > (1 / 0)
08:43:08 <dayzman> @src (>>=)
08:43:08 <lambdabot> Source not found. My mind is going. I can feel it.
08:43:16 <aLegendaryPengui> wheres my answer
08:43:23 <EvilTerran> dayzman, the definition of >>= depends on which monad you're using
08:43:26 <lilac> aLegendaryPengui: remove the leading space and try again
08:43:43 <EvilTerran> ?src Maybe >>=
08:43:44 <lambdabot> Source not found. :(
08:43:52 <EvilTerran> ?src Maybe (>>=)
08:43:53 <lambdabot> (Just x) >>= k      = k x
08:43:55 <lilac> @src Maybe (>>=)
08:43:55 <lambdabot> Nothing  >>= _      = Nothing
08:43:59 <lambdabot> (Just x) >>= k      = k x
08:44:01 <lilac> gah, too slow :(
08:44:03 <lambdabot> Nothing  >>= _      = Nothing
08:44:22 <lilac> lambdabot really needs 'someone else just did that' detection
08:44:33 <lilac> @src [] (>>=)
08:44:33 <lambdabot> xs >>= f     = concatMap f xs
08:44:33 <idnar> heh
08:44:42 <edwardk> hah
08:45:08 <EvilTerran> lilac, i agree
08:45:17 <edwardk> with a 'look 5 lines back' privmsg to confuse the hell out of people
08:45:21 <dayzman> EvilTerran: how many types of monads are there?
08:45:35 <dayzman> EvilTerran: we don't define >>= ourselves, right?
08:45:41 <dayzman> or do we
08:45:47 <edwardk> dayzman: there are an unbounded number of them
08:45:54 <lilac> dayzman: yes, we do, when we create a new monad
08:45:58 <dayzman> right
08:46:16 <edwardk> dayzman: in general you can get by with the ones from the MTL with a few extras when you need something strange
08:46:18 <lilac> dayzman: there are a countable infinity of distinct monads expressible in haskell
08:46:42 <dayzman> but in the case of http://haskell.pastebin.com/m540e8eea, which monad does ifM use?
08:46:49 <lilac> technically, you can get by with just Cont, but only if you're masochistic
08:46:50 <EvilTerran> any
08:47:09 <EvilTerran> ?type let ifM p t f  = p >>= (\p' -> if p' then t else f) in ifM
08:47:10 <lambdabot> forall (m :: * -> *) b. (Monad m) => m Bool -> m b -> m b -> m b
08:47:21 <edwardk> every monad supports >>= which is the only property ifM needs
08:47:21 <EvilTerran> that's the point of typeclasses
08:47:28 <vixey> countable infinity of distinct monads expressible -- what are they?
08:47:32 <EvilTerran> edwardk, well, and return (but every monad supports that, too)
08:47:43 <lilac> "for all monads m and types b, ifM has type m Bool -> m b -> m b -> m b"
08:48:01 <edwardk> evilterran: yeah but ifM didnt use return ;)
08:48:08 <lilac> vixey: you want me to explicitly enumerate them? :)
08:48:16 <EvilTerran> edwardk, ah, yes, that's just while2
08:48:18 <dayzman> sorry for being so confused...
08:48:20 <vixey> not one at a time
08:48:33 <lilac> vixey: countable because we can't compile infinite source code, infinite because we can construct an arbitrary stack of, for instance, state monads
08:48:50 <edwardk> dayzman: no problem. we were all new once. =)
08:49:01 <vixey> you don't have some specific universe of monads in mind then?
08:49:16 <dayzman> edwardk :)
08:49:31 <dayzman> if we are to step through while2, x replaces p, (return()) replaces t, ifM y ... replaces f
08:49:32 <lilac> vixey: i think a general proof that haskell permits the expression of a countable infinity is enough :)
08:49:40 <mib_i1xwpz8z> I'm working with Data.ByteString.Char8, trying to join strings. import qualified Data.ByteString.Char8 as B; B."foo" ++ B."bar" gives an error; ++ is looking for [a]
08:49:56 <vixey> every polynomial functor is a monad
08:49:57 <lilac> vixey: the universe of monads i'm thinking of is 'those monads expressible in haskell'
08:50:31 <mib_i1xwpz8z> oops I meant B.pack "foo" ++ B.pack "bar"
08:50:35 <vixey> I guess if you just throw liftA2 (->) into the polynomial functor that's every /type/
08:50:36 <dayzman> so it'll then read x >>= (\p' -> if p' then (return()) else ...)
08:50:40 <vixey> which ones of these are monads?
08:50:58 <dayzman> but what is p' instantiated to in the first round?
08:51:11 <vixey> (every type * -> * that is)
08:51:15 <edwardk> vixey: thats what we have the free monad for
08:51:36 <vixey> I don't think they are ALL monads.. and some might be multiple different monads
08:51:55 <RowanD> <edwardk> the reflection is nice because it can let linq translate things
08:51:55 <RowanD> 	  using the native syntax that no monad could translate in haskell. in
08:51:55 <RowanD> 	  that its a win for ease of use
08:51:58 <lilac> vixey: there is the free monad over each functor
08:52:10 <vixey> that's what "every polynomial functor is a monad" means
08:52:13 <RowanD> Is that true?  Can't you define a reflective monad?
08:52:34 <lilac> vixey: why the restriction to polynomial functors?
08:52:45 <edwardk> rowand: linq can inspect the AST directly and do things that even depend on the variable names you use
08:53:10 <lilac> vixey: also, the free monad is not the same as the original functor AIUI
08:53:42 <edwardk> not every functor is a monad, but given any functor you can make a monad out of it by wrapping it aroung an Either of a value and itself
08:54:09 <edwardk> and yeah the free monad is a different functor than the base functor over which its constructed
08:54:13 <RowanD> edwardk: yeah, I know.  But can't you define bind to be an AST representation?  I guess yes, but you can't get the AST for other things.
08:54:21 <mib_i1xwpz8z>  I think I figured it out: use `B.append` instead of ++
08:54:42 <edwardk> you can inspect the 'monadic bits' but the stuff that happens in there that is pure is opaque to you.
08:55:43 <edwardk> RowanD: when i've needed something like reflection before what i did was plumb around functors of values rather than values within the monad, so you couldn't use them except in predefined ways.
08:56:31 <RowanD> FLINQ uses quotations, but not reflection otherwise, I think.
08:56:38 <edwardk> RowanD: so make the interesting operations give you an 'm (f a)' and control the operations you expose on f. if you cps transform things right you can extract an equivalent series of operations from what the user did inside the monad
08:56:43 <lilac> edwardk: something like: data FreeMonad f a = Return (f a) | Bind (f a) (b -> FreeMonad f a) (IIRC)?
08:57:03 <lilac> ... Bind (f b) (b -> ...
08:57:15 <edwardk> lilac: for the inspection or free monad in general?
08:57:26 <lilac> for the free monad in general
08:57:41 <edwardk> lilac data Free f a = Return a | Free (f (Free f a))
08:57:44 <lilac> i suppsoe Bind (f (Freemonad f a)
08:57:54 <lilac> yeah, that :)
08:58:36 <mib_6m2dqg7b> Anyone available for newbie question?
08:59:07 <lilac> mib_6m2dqg7b: is that the question? if so, yes.
08:59:10 <RowanD> Yeah - that is essentially an explicit worlds style of modality/monad.
08:59:10 <mib_6m2dqg7b> Sorry for long nick; I haven't figured out how to change it on mibbit yet.
08:59:15 <mib_6m2dqg7b> meta question
08:59:56 <mib_6m2dqg7b> ++ doesn't seem to work with ByteString, so I'm thinking I need ByteString.append (maybe in backquotes). Is that right?
09:00:27 <adamvo> :t (++)
09:00:28 <lambdabot> forall a. [a] -> [a] -> [a]
09:00:37 <RowanD> edwardk/lilac: can you compose different f's with that rep in Haskell?
09:01:07 <adamvo> mib_6m2dqg7b: (++) is only for lists, ByteString.append should work
09:01:19 <adamvo> :t mappend
09:01:20 <lambdabot> forall a. (Monoid a) => a -> a -> a
09:01:45 <edwardk> rowand: that works for any functor, but you can't bind (>>=) :: f a -> (a -> g b) -> ??? if thats what you mean
09:02:44 <edwardk> man i just realized i left the crufty PFree based definition of Free in category-extras
09:02:44 <RowanD> edwardk: I mean can I define f as the composition of g and h.
09:03:07 <mib_6m2dqg7b> What library has mappend in it?
09:03:15 <RowanD> edwardk: I guess you can in GHC.
09:03:18 <edwardk> mib_6m2dqg7b: Data.Monoid
09:03:39 <edwardk> RowanD: yeah. you can use Control.Functor.Composition or typecompose and make a functor composition.
09:04:14 <RowanD> That is kinda nice.
09:04:58 <teqilatango> Has anyone tried to get haskell-tyrant (Tokyo Tyrant bindings for Haskell) to work on Mac OS X? I'm having trouble to get it working.
09:05:06 <mib_6m2dqg7b> thanks adamvo++ edwardk++
09:05:20 <edwardk> RowanD: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/ has a whole host of things you can do with functors ;)
09:06:24 <RowanD> Er - yeah.  Alas most of them probably aren't what I want to do.
09:06:26 <dayzman> with monads (still), in http://haskell.pastebin.com/m4a211860, line 5 tries to apply p to s0, but since (g w) replaces p, what is s0 in this case?
09:06:32 <edwardk> rowand: haha
09:06:35 <RowanD> But, composing monads is really nice.
09:06:56 <edwardk> rowand: you can't compose monads in general, only in particular cases where you have a distributive law
09:07:38 <edwardk> you can compose ideal monads, you can compose functors, you can make any functor into a free monad (which is a particular ideal monad), but composing monads requires the ability to 'move one over the other'
09:07:45 <RowanD> Huh?  Why?  I thought just you got different things for f.g and g.f
09:08:05 <edwardk> nope, monads are not closed under composition
09:08:35 <edwardk> http://www.haskell.org/haskellwiki/ListT_done_right gives an example using IO and []
09:08:41 <doserj> dayzman: whatever g w evaluates to
09:08:51 <RowanD> Hmmm - you can do it in ML, and nothing bad happens.  Unless Andrezj Filinski was wrong.
09:09:05 <edwardk> he was wrong =)
09:09:19 <RowanD> Really?  You sure about that?
09:09:39 <edwardk> i'm pretty darn sure that monads aren't closed under composition
09:09:58 <edwardk> i've seen enough proofs of non-compositionality over the years there isn't any real doubt
09:10:29 <EvilTerran> if monads were composable in general, we could have something analogous to IOT
09:10:38 <RowanD> Right, but perhaps there is a reasonable class of things that you can obtain by composing them that still works in the context of ML.
09:10:42 <vixey> you want to find two monads m n such that m . n isn't a monad?
09:10:58 <edwardk> the composition can fail associativity when both monads are associative individually
09:11:17 <edwardk> rowand: there is a reasonable class of monads that compose well, most of them are 'ideal monads' some aren't
09:11:54 <RowanD> Andrezj only included monads definable in ML.
09:11:56 <dayzman> doserj: so is g w supposed to return a function?
09:12:28 <RowanD> I'd be really surprised if his implementation broke.  Because it was really short and so obviously right.
09:12:29 <edwardk> shouldn't matter. you have delay and force in ML so you should be able to define some of the worst abusers
09:12:51 <dayzman> doserj: .. since it tries to apply g w to s0, right?
09:13:08 <vixey> RowanD: is it in a paper or something?
09:13:19 <RowanD> Andrezj's work?
09:13:27 <RowanD> yeah, let me get the references.
09:13:57 <doserj> dayzman: g w is the first argument to >>= so g w evaluates to some ST p
09:14:32 <edwardk> he had a bunch of stuff on layered monads is that what you mean?
09:14:54 <RowanD> Yeah, starting in 1990.
09:15:00 <RowanD> But, I mean his PhD work.
09:15:06 <dayzman> doserj: yes, but on the right hand side: ST( \s0 -> let (s1, a) = p s0, it applies p to s0, right?
09:15:21 <edwardk> i thought his phd was the value/continuation stuff?
09:15:21 <RowanD> And, I've been spelling his name wrong, should be Andrzej.
09:15:25 <dayzman> doserj: thus, g w to s0?
09:15:41 <ddarius> edwardk: If you are thinking of the symmetric lambda calculus, that was his Master's.
09:15:54 <edwardk> ah
09:16:07 <RowanD> No, I mean his PhD work.  We were students at CMU together.
09:16:12 <RowanD> http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/CE-abstract.html
09:16:28 <edwardk> anyways i think the representing layered monads paper is wrong because it includes both state and list in the composable monads list. i think none of the reviewers carefully checked that the associativity law held
09:16:39 <edwardk> it looks right at first glance but its a subtle flaw
09:17:25 <doserj> dayzman: no. g w ~> ST p and then you apply p to s0
09:17:33 <edwardk> unless i missed it and he doesn't define RMONAD for List, checking
09:18:05 <vixey> thanks
09:19:02 <RowanD> Pretty much the coolest ML code I've seen, even it doesn't always work.  :)
09:19:24 <edwardk> its good stuff
09:20:14 <edwardk> but even so he only models monads he can get to reflect through his framework, so its basically the MTL stuff in a slightly less arbitrary core. neil ghani has a similar construction in those ideal monads i mentioned, just the machinery differs
09:20:47 * edwardk went through those papers back when i was getting my head around haskell.
09:22:15 <RowanD> Well, he allowed you program with all kinds of monads, and swap back and forth between having the monad implicit or explicit.
09:22:23 <RowanD> And, without extending the underlying language.
09:22:24 <vixey> monadic reflection is soooooooooo cool :)
09:23:00 <RowanD> Um - "all kinds" = "some useful ones".
09:23:00 <edwardk> yeah. i don't challenge the niftiness of the feat ;)
09:23:03 <vixey> this stuff makes me wish scheme evaluated (<1> <2> ...) instead of any permutation of ..
09:25:52 <RowanD> Alas, continuations never made it into SML.  And probably never will.
09:26:36 <RowanD> Well, you can program in CPS, but then your head will hurt.  And strict vs non-strict becomes a non-issue.
09:26:52 <dayzman> so in the top part of http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm, what type should g be of? A->B or A->B->C?
09:27:04 <vixey> I thougth lots of SML implementations had continuations
09:27:19 <vixey> The requested URL /~theo/Misc/haskell_and_monads.htm, was not found on this server.
09:27:31 <RowanD> SML/NJ has callcc but not SML.
09:27:43 <dayzman> if it's A->B, then g w replaces p in the bind, which is then applied to s0.. so it has to accept 2 arguments, right?
09:27:44 <doserj> vixey: try without the ,
09:28:02 <vixey> doserj: mostly wondering why everyone adds commas to URLs
09:28:07 <edwardk> RowanD: anyways a major nicety of applicatives over monads is that they are closed under composition
09:28:19 <RowanD> And, they are often used in short fragments of code.  Just doing CPS everywhere is bad for your head.
09:29:00 <Muzzleflash> Hi everybody. I'm reading through real world haskell and have reached the excercises for chapter 3.. Why can't I do the following: myLength :: [a] -> Num  but I can do: myLength :: [a] -> Int ?
09:29:14 <edwardk> rowand: bah just use Cont, ContT or Codensity ;)
09:29:32 <rabideejit> dayzman: do you mean this bit? f w = (g w) >>= (\x -> (h w x) >>= (\y -> (i w x y) >>= (\z -> return z)))
09:29:34 <doserj> Muzzleflash: Num is not a type
09:29:58 <edwardk> Muzzleflash: look at fromIntegral
09:30:08 <RowanD> edwardk: Yeah, I'd better read up on applicative functors.
09:30:23 <edwardk> you can make myLength :: Num i => [a]  -> i
09:30:35 <doserj> @type genericLength
09:30:36 <dayzman> rabideejit: yes that's right
09:30:36 <lambdabot> forall b i. (Num i) => [b] -> i
09:30:48 <dayzman> rabideejit: and the p >>= k  =  \s0 -> let (s1, a) = p s0 bit
09:31:08 <edwardk> heya rabideejit, nice to see you on irc =)
09:31:10 <rabideejit> ( g w ) is of type s -> (s, a )
09:31:20 <doserj> dayzman: g w has to be of type StateTrans s a, i.e., s -> (s,a)
09:31:24 <rabideejit> edwardk: hello
09:31:42 <dayzman> rabideejit: but ( g w ) replaces p, and p is applied to s0 in p >>= k  =  \s0 -> let (s1, a) = p s0
09:31:44 <Muzzleflash> edwardk: Thanks, that worked.
09:31:58 <RowanD> edwardk: I still haven't seen a concept like monads that looks completely right to me.  To me, the curry-howard isomorphism points towards (non-strong) monads and comonads.  But, I don't know how to make that work.
09:32:10 <doserj> dayzman: yes, so?
09:32:16 <edwardk> RowanD: i have a library full of comonads
09:32:16 <Muzzleflash> I was just condused It would allow something like Int and not Num, when the length could be larger than representable in Int
09:32:29 <dolio> Not codensity, if you want callCC.
09:32:34 <RowanD> edwardk: do you have non-strong monads?
09:32:54 <edwardk> RowanD: every functor in haskell is strong, its a consequence of the fact that you can bind names.
09:33:21 <edwardk> dolio: yes, but if you just want to cps transform its fine
09:33:29 <dolio> True.
09:33:38 <edwardk> dolio: if you're using it to get the asymptotic shift
09:34:23 <RowanD> edwardk: yeah, I know.  But, still, modal logic is pretty fundamental, and modal possibility corresponds to a non-strong monad.  A monad requires mixing necessity and possibility in various ways.
09:34:37 <dayzman> doserj: then is f w also of type s -> (s, a)?
09:34:42 <edwardk> rowand: http://comonad.com/reader/2008/deriving-strength-from-laziness/ is something i wrote up a year back on the topic
09:35:37 <doserj> dayzman: yes.
09:35:40 <edwardk> rowand: i give you that url knowing it may arm you further in your internal strictness over laziness debate ;)
09:35:48 <dayzman> doserj: aah..
09:35:50 <dons> ?yow
09:35:50 <RowanD> Haha.
09:35:50 <doserj> dayzman: (the a may be different though)
09:35:50 <lambdabot> I want a VEGETARIAN BURRITO to go ... with EXTRA MSG!!
09:35:55 <dayzman> i get it now..
09:36:03 <dayzman> thanks so much for your patience!
09:36:43 <RowanD> edwardk: Yeah, I'm kinda neutral on that really.  Basically I'll argue against anyone either way, with the aim of getting some clarity.  :)
09:37:11 <lpsmith> RowanD:   I'm very interested in trying to understand the curry howard isomorphism with respect to monads
09:37:15 <edwardk> what i want to see is the speculative eval stuff fleshed out, eager evaluation where possible retaining lazy semantics and asymptotics is sexy
09:37:16 <lpsmith> Have any insight?
09:37:38 <RowanD> lpsmith: I can refer you to one of my papers then.  :)
09:38:22 <edwardk> ipsmith: in one sense, monads correspond to possibility, comonads correspond to necessity from intro modal logic.
09:38:31 <codebliss> I just made egg beaters, mushrooms, mozerella cheese, and tomato bits.  Oh my god it's so goooood
09:38:41 <edwardk> in another sense you can view the ! operator in linear logic as a comonad
09:38:50 <vixey> ooh
09:38:55 <vixey> yeah that makes sense
09:39:05 <ddarius> Not quite CH, but I like "A Judgemental Reconstruction of Modal Logic" (or something like that) by Pfenning (and others)
09:39:48 <edwardk> i have a whole family of commutative modalities that map onto commutative comonads that i was using for substructural logic. one of these days i'll have to package it up and publish it somewhere
09:39:56 <RowanD> Haha.  By Pfenning and me, actually.
09:40:07 <edwardk> rowand: =)
09:40:26 <ddarius> Well I follow Pfenning fairly regularly.
09:40:29 <vixey> :o
09:40:29 <rabideejit> I'm having to edge my way around some laziness/memory issues.  So I wrote it in c.  Is it expected that ghci will crash if some c code tries to create a socket and connect to it?
09:41:00 <lpsmith> rowand,  edwardk:  yeah,  I've read through Kobayashi's "Monad as Modality",    and CC Shan says that the logic of shift and reset is an multimodal intuitionistic logic
09:41:08 <edwardk> rabideejit: not generally
09:41:19 <lpsmith> I'm definitely game for more references though
09:41:30 <rabideejit> edwardk: It's rather peculiar you see!
09:41:42 <RowanD> Kobayashi is a bit weird.  Not really the natural intuitionstic thing.
09:42:03 <RowanD> Sorry his paper is a bit weird.  Not him.
09:42:50 <lpsmith> yeah,  unfortunately most of it went over my head,  although I was amazed at how much I managed to follow,  considering the context
09:43:03 <edwardk> ipsmith: my framework for thinking about them is a little strange because i was completely obsessed with substructural logic at the time i was learning monads as a functional programming tool. my preferred framework for dealing with modalities is in something like display logic
09:43:04 <lpsmith> I'll warn you,  my background in category theory and logic isn't particularly strong
09:43:11 <RowanD> http://www.cs.cmu.edu/afs/cs/user/fp/www/papers/mscs00.pdf
09:43:18 <lpsmith> I just have a pretty good understanding of monads and continuations :-)
09:43:50 <edwardk> ipsmith: i'd recommend trying to find a copy of the old nuel belnap papers on display logic. i think greg restall has a couple of things online on the topic as well, but it doesn't introduce the logic iirc
09:44:30 <RowanD> edwardk: there are strong philosphical and technical reasons to demand that connective be defined by introduction or elimination rules.
09:44:53 <codebliss> Does anybody have a recommendation for the best reference on category theory?
09:45:00 <codebliss> Still don't get it too well.
09:45:21 <edwardk> sure. i just find that display logic makes it easy to sidestep a lot of the boilerplate
09:45:32 <RowanD> Has anyone managed to apply curry-howard to display logic?  I've always considered it more of a hack, logic wise.
09:45:42 <edwardk> yes, i was doing so
09:45:55 <RowanD> Yeah?  Cool.  What do you get?
09:46:11 <edwardk> well, i got a whole morass of symbols and a very ugly type system ;)
09:46:20 <RowanD> Haha.
09:46:27 <edwardk> it was conceptually amazing, but very hard to get work done in ;)
09:46:32 <RowanD> I have millions of those.
09:46:55 <rabideejit> ahh.  Exit( ) was causing the segmentation fault, but why, I do not know.
09:47:08 <edwardk> i ultimately put it down, kept my pile of substructural comonads/modalities that derived from it and walked away
09:47:26 <RowanD> Right.  Sometimes you have to do that.
09:47:45 <edwardk> it actually led to my current language project, where i stripped most of the types out of the language and just kept the interesting bits.
09:47:54 <RowanD> I eventually walked away from non-strong monads too.
09:48:34 <RowanD> Although, I did figure out that they fitted pretty well with distributed programming, and some others at CMU followed up a bit later.
09:48:49 <edwardk> i can see that
09:49:08 <codebliss> What's the haskell chat channel again?
09:49:15 <dons> hmm...
09:49:16 <edwardk> #haskell-blah
09:49:20 <codebliss> lol thanks
09:49:29 <RowanD> They ended up with the S5 version.  And then classical S5 even.  :)
09:50:20 <amaron> anyone used haskell for generating printed reports?
09:50:31 <edwardk> i mostly obsessed about splitting up things into a series of modalities for linearity, affinity, relevance, and extending that to cover uniqueness as backwards facing temporal linearity
09:50:46 <dons> amaron: yeah, it's actually used for that commercially at a couple of places.
09:50:57 <dons> amaron: what format is the output? .pdf? html?
09:51:05 <edwardk> i wrote it all up and then before i finished my thesis advisor became dean
09:51:12 <anontest> I have somewhat of a stupid question, I've been banging my newbee head against it long enough that I thought I'd just ask: Say I have a function foo :: (Floating a) => a -> a. How do I do the simple thing of rounding down the argument? Whatever I try with fromInteger and floor gives me an outcome where something cannot be deduced.
09:51:16 <edwardk> i already had one masters at that point so i just walked away from it
09:51:17 <anontest> Sorry for my very basic question :P
09:51:41 <RowanD> edwardk: OO backwards facing?  Wow.  I guess you've probably already read some of my papers then.
09:51:56 <amaron> dons, I'm considering all options for now, but I thing pdf have more precise layout
09:51:59 <edwardk> rowand: not sure that i have
09:52:02 <dayzman> for ifM in http://haskell.pastebin.com/m540e8eea, which monad is it using? the one for Bool?
09:52:05 <dayzman> is there one even?
09:52:11 <edwardk> rowand: i'd appreciate references though =)
09:52:35 <vixey> The requested URL /m540e8eea, was not found on this server.
09:52:39 <amaron> dons: I'm looking at HPDF and HaruPDF, both are very low level ones
09:52:45 <edwardk> rowand: this was a couple of years back and my interests have shifted a lot since then but i'd like to see other stuff in this space. no one really seems to have a good story for this stuff
09:53:02 <RowanD> edwardk: I have two on C-H for modal logic, and one on temporal "next" that is basically a variant.
09:53:22 <edwardk> ah nice. would have been handy to have found =)
09:53:38 <doserj> dayzman: didn't we have that before? ifM works for any Monad
09:53:44 <RowanD> edwardk: The first two were back in 1996.
09:54:08 <edwardk> RowanD: i found a bunch of pfenning stuff, etc. but i don't think i ever found your work =(
09:54:13 <idnar> @type ifM
09:54:14 <lambdabot> Not in scope: `ifM'
09:54:50 <edwardk> oh wait. yes i have, the staged compilation tuff
09:54:57 * anontest retracts his question after seeing realflot
09:55:14 <edwardk> funny how everyone forgets your name on papers he's tagged on ;)
09:55:26 <RowanD> edwardk: Yeah, that was the first paper.  My first real paper, actually.
09:57:12 <edwardk> @seen dons
09:57:12 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6m 14s ago.
09:57:16 <RowanD>  edwardk: I'll grab you urls for the others.
09:57:19 <edwardk> oh hah
09:57:41 <edwardk> dons: still working on the generalized unpacker stuff, its proving trickier than i thought
09:58:02 <RowanD> Wow - what happens in "haskell-in-depth"?
09:58:13 <RowanD> Is this just the fluff version?
09:58:18 <lpsmith> RowanD:  do you have a homepage with a list of your papers and whatnot?
09:58:19 <edwardk> yeah =)
09:58:23 <idnar> that's where you get drowned in theory
09:58:39 <RowanD> Yeah, I do, but I'm lame so they are in PS still.
09:58:47 <idnar> many have entered, but few emerge alive ;)
09:58:53 <RowanD> http://www.csse.uwa.edu.au/~rowan
09:58:55 <idnar> actually, I think there's a wiki page about it
09:58:55 <edwardk> RowanD: #haskell-in-depth was created to keep me from scaring all the newbies with category theory.
09:59:01 <jmcarthur> i don't like that we have #haskell and #haskell-in-depth
09:59:07 <idnar> but the topic describes it fairly well
09:59:35 <RowanD> Oh, maybe I should go there.  I don't like category theory, but I like to argue with people who do.  :)
09:59:36 <dayzman> doserj: yeah, but isn't the behaviour of the bind different for each monad?
09:59:37 <jmcarthur> it seems like hiding the advanced stuff from everybody else
10:00:03 <RowanD> (Half kidding.)
10:00:39 <monochrom> hahaha
10:01:04 <edwardk> RowanD: hah, well i think a certain modicum of deep theory out here isn't bad when the channel is quiet
10:01:24 <edwardk> when you can't keep up with the scrolling its a better place to have longer discussions though
10:01:39 <edwardk> originally there was a #haskell-overflow but no one used it
10:01:41 <RowanD> Right, understood.
10:01:48 <edwardk> so they rebranded the idea
10:02:12 <ddarius> edwardk: #haskell-overflow is still active and gets used, but it doesn't have the same motivation as #haskell-in-depth
10:02:32 <RowanD> Of course, I'm actually just avoiding writing a project for my students.  Which I should get back to.
10:02:50 <Philippa__> dayzman: it is, but it should behave according to certain rules
10:03:04 <RowanD> Cause, it's halfway through semester now, and I promised they'd have it tomorrow.  Like in 11 hours.
10:03:13 <edwardk> ddarius: well, sure you could overflow a particularly long monad tutorial in #haskell-overflow, while that would be gauche given the mandate of #haskell-in-depth to do there ;)
10:03:47 <edwardk> rowand: very nice meeting you. swing by and chat some time
10:04:03 <RowanD> Yeah, will do.
10:04:04 <jmcarthur> "Naked recursion [in Lisp] is GOTO dressed up in a scholar's mortar and gown. Likewise naked monkey-patching [in Ruby] is GOTO dressed up in... Well, it isn't really dressed up, it's more baggy pants performing a frontside grab."
10:04:07 <dayzman> Philippa__: i see. what rules are these?
10:04:10 <RowanD> It's a nice chat here.
10:04:23 <RowanD> There's nothing equivalent at all for ML.
10:04:32 <edwardk> yeah hard to get this many pointy-headed people in one place.
10:04:52 <edwardk> the community is what ultimately sold me on haskell over ML
10:05:09 <Philippa__> dayzman: http://www.haskell.org/haskellwiki/Monad_Laws
10:05:10 <edwardk> the #sml channel was mostly smerdyakov whining that folks should be using coq instead ;)
10:05:14 <doserj> dayzman: yes, but it is always called >>=
10:05:23 <lpsmith> edwardk:  I had a bit of that experience as well.   Not to mention that Hugs was a lot easier to use.
10:05:26 <Philippa__> edwardk: heh, that figures
10:06:03 <skorpan> what happens if i break a monad law?
10:06:06 <edwardk> i can never bring myself to use hugs. i always want some language feature or other than they never implemented
10:06:08 <skorpan> serving time?
10:06:08 <doserj> dayzman: of cource, ifM will do different things for different monads
10:06:14 <edwardk> skorpan: you get taken to monad jail
10:06:23 <dayzman> i see
10:06:24 <dayzman> thanks
10:06:29 <lpsmith> skorpan;  Oleg comes and beats you up ;-)
10:06:56 <skorpan> who is this oleg fellow that i hear so much about?
10:07:05 <edwardk> lpsmith: nah, he only beats you up if you try to say that something can't be done in haskell's type system
10:07:07 <RowanD> skorpan: you move outside normal space and time.
10:07:22 <edwardk> skorpan: http://okmij.org/ftp/
10:07:28 <lpsmith> But seriously,   if you break a monad law,  then it matters not just *what* you write,  but also how you write it
10:07:37 <edwardk> oleg is quite the er... character
10:08:09 <skorpan> is this oleg character somewhat like bulat?
10:08:16 <edwardk> http://video.google.com/videoplay?docid=-7990603720514207956
10:08:41 <RowanD> lpsmith: isn't that always the case.  (ducks, runs away, actually does his work)
10:08:54 <Philippa__> skorpan: nah, I don't think we use 'bulats' as a unit
10:09:04 <skorpan> Oleg Kiselyov (born 11 January 1967) is a Russian handball player.
10:09:24 <vixey> edwardk: in ocaml he says people should use sml :P
10:09:32 <edwardk> oleg's main trait is that he is scary smart and not all that gifted at communicating ideas to people who aren't versed in delimited continuations ;)
10:09:37 <edwardk> vixey: haha
10:09:56 <skorpan> ooh, lisp
10:10:14 <skorpan> lisp is cool, lisp i can understand
10:11:08 <jmelesky> i liked sml. it was a beautiful language
10:11:20 <jmelesky> it's pretty dead, though.
10:11:40 <lpsmith> RowanD:  yeah, probably,  my statement was not fleshed out well enough
10:11:43 <lpsmith> :-)
10:11:48 <lpsmith> It's all relative
10:11:48 <skorpan> so self-application is the fix-point of call/cc?
10:11:50 <doserj> Oleg is a measure of type-class hacking proficiency. 1 milliOleg is roughly the amount needed to implement RSA on the type-level
10:12:27 <lpsmith> doserj:  not just type classes,  also continuations and macros
10:13:24 <lpsmith> skorpan:  I understand call/cc reasonably well now,  but I still don't understand that bit
10:13:36 <skorpan> i barely understand fix-points at all
10:14:21 <lpsmith> You might go to the library and obtain a copy of Richard Bird's "Using Circular Programs to eliminate multiple passes of data"
10:14:30 <lpsmith> Unfortunately, I don't think that's available online
10:14:46 <lpsmith> That might help you get a feel for fixpoints
10:15:12 <lpsmith> I can't say that I'm particularly an expert,  just that I understand a reasonable number of applications
10:15:34 <RowanD> I think the fixed point of callcc is not something to think about too much.  It certainly isn't self application.
10:15:55 <skorpan> but basically, isn't the fix-point for any function f the x for which of (f . f . f ...) x = x?
10:16:19 <skorpan> s/for which of/for which/
10:16:59 <skorpan> i'm not sure what that means.  that looks like nonsense now that i think about it.
10:17:19 <RowanD> Oh, maybe you are right, maybe it is self application.
10:17:19 <dolio> A fixed point of f is a value x such that f x = x.
10:17:56 <skorpan> dolio: so what is the fix-point of the identity function?  does it have one?  if so, is any value a fix-point for it?
10:18:09 <dolio> Any value is a fixed point of identity.
10:18:15 <RowanD> But, it's much less useful than fixed points and callcc.
10:18:15 <dolio> The least fixed point is _|_.
10:18:32 <skorpan> i always regarded _|_ as the bottom type?
10:18:34 <RowanD> What's the greatest fixed point?
10:18:38 <tromp_> :t fix
10:18:39 <RowanD> T?
10:18:39 <lambdabot> forall a. (a -> a) -> a
10:18:54 <dolio> There is no greatest value for a lot of types.
10:19:00 <dolio> If we're talking Haskell.
10:19:02 <skorpan> what does it mean for something to be a "less" fixed point than something else?
10:19:20 <RowanD> Yeah - a domain, not a lattice.
10:19:22 <lpsmith> dolio:  well,  it's not _any_ value,  but the fix point of id is any type
10:19:24 <vixey> skorpan: values form a partial order
10:19:42 <doserj> under the "more-defined-than" relation
10:19:45 <b_jonas> oh
10:20:01 <RowanD> Terminology: it's a fixed point.  Fix point is wrong.
10:20:10 <dolio> lpsmith: id 5 = 5, so that's a fixed point. id "foo" = "foo", so that's a fixed point, ...
10:20:27 <b_jonas> butâ€¦
10:20:36 <lpsmith> oh,  I thought you meant "fix id"  ;-)
10:20:40 <lpsmith> As in YI
10:20:52 <b_jonas> when you talk about searching the fix points, don't you fix a mono type for id and search a fix point for that type of arguments/
10:20:54 <skorpan> so what is the fixed point of "fix id"? :|  that one boggles me.
10:21:00 <skorpan> fix is basically the Y combinator no?
10:21:06 <RowanD> fix is a construct for creating fixed points.
10:21:10 <tromp_> yes
10:21:21 <vixey> prove that fix takes the least fixed point
10:21:24 <RowanD> Y combinator is an example.
10:21:34 <lpsmith> dolio:  I see what you are saying now.   any value is a fixed point,  but the least fixed point of id is only partially interesting
10:21:51 <b_jonas> so if a function is strict in its argument then _|_ is a fixed point of it so it's the least fix point,
10:22:06 <b_jonas> which aligns nicely with that the way fix is defined fix will give _|_ for that function
10:22:11 <b_jonas> cool
10:22:19 <dolio> skorpan: With respect to fixed points, "less" refers to the ordering of definedness. _|_ is the least defined value in any type, and what other structure there is depends on the type.
10:22:25 <lpsmith> skorpan:  yes,  fix is basically Y,  except that Y is traditionally expressed using self-application instead of general recursion.
10:22:37 <b_jonas> anyway, I think I know a solution for the problem I was pondering last time, namely detecting failed module loads in that ghci hack I'm writing
10:22:42 <skorpan> lpsmith: but fix is also expressed using itself?
10:22:44 <b_jonas> so now I just have to implement all that stuff
10:22:45 <skorpan> @src fix
10:22:46 <dolio> So, _|_ < i, for any integer i, and all other integers are incomparable.
10:22:46 <lambdabot> fix f = let x = f x in x
10:22:49 <skorpan> oh, it's not
10:23:18 <dolio> But for, say, lazy natural numbers, _|_ < everything else, S _|_ < S (everything else), etc.
10:23:29 <RowanD> The concept of fixed points exists beyond untyped lambda calculus.  Y is an implementation in untyped lambda calculus.
10:23:46 <RowanD> Haskell has fixed points, but not Y.
10:23:57 <b_jonas> > let { fix' f = f (fix' f); } in fix' ("hello " ++)
10:23:58 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
10:24:05 <b_jonas> > fix ("hello " ++)
10:24:06 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
10:24:16 <b_jonas> skorpan: I think that version also works
10:24:27 <skorpan> b_jonas: sure looks like it
10:24:47 * EvilTerran 's favourite version is "fix f = x where x = f x"
10:25:18 <EvilTerran> clearer than the let/in version, IMO
10:25:19 <b_jonas> skorpan: the difference is, however, that the library versoin will create a cyclic structure, whereas this can create an infinite strucutre (though it could be optimized to cyclic)
10:25:24 <lpsmith> EvilTerran: nice!  that's almost a palindrome
10:25:44 <korpios> (new-to-haskell) I'm trying to play with Text.JSON; encode [1,2,3] returns a string "[1,2,3]" as expected, but decode "[1,2,3]" always fails with "Ambiguous type variable `a' in the constraint: `JSON a' arising from a use of `decode'" ... should I be wrapping the string in something first?
10:25:49 <EvilTerran> the "fix f = x" equation doesn't get rudely interrupted by the definition of "x" in the middle :P
10:26:10 <vixey> extra points for palindromic programs
10:26:22 <rabideejit> korpios: try giving it a type signature
10:26:54 <korpios> I tried both ":: JSON a" and ":: Result a" ... neither seemed to work
10:27:17 <rabideejit> try a more explicit signature, without variables.
10:27:39 <rabideejit> though to be fair, I have never used jason, the ambiguous type error is what is says on the tin, as they say.
10:27:45 <EvilTerran> > ap (==) reverse . map toLower . filter isLetter $ "Doc, note I dissent. A fast never prevents a fatness. I diet on cod."
10:27:47 <lambdabot>   True
10:28:37 <lpsmith> @def ap
10:28:37 <lambdabot> Maybe you meant: bf let
10:28:52 <korpios> hmm, trying decode "[1,2,3]" :: [a] gives an error "Couldn't match expected type `[a]' against inferred type `Result a1'"
10:28:53 <lpsmith> ?def ap
10:28:53 <lambdabot> Maybe you meant: bf let
10:28:58 <EvilTerran> ?src ap
10:28:58 <lambdabot> ap = liftM2 id
10:29:03 <EvilTerran> :D
10:29:08 <lpsmith> lol,  thanks :-)
10:29:18 <EvilTerran> in this case, ap is the good ol' S combinator
10:29:21 <vixey> :t liftM3 id
10:29:22 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
10:29:42 <rabideejit> korpios: what I mean is, you need to replace "a" with an actual type - [ a] won't work because it expects a result of some kind - but you need to say what kind of result.
10:29:46 <Baughn> Is it possible to get /multiple/ arrays with STArray?
10:30:01 <b_jonas> Baughn: yes
10:30:21 <lilac> fix f = fix where fix = f fix
10:30:28 <lilac> i fixed your palindrome
10:30:28 <b_jonas> Baughn: or do you mean that safe freezing interface thing that converts an ST array to an IArray?
10:30:40 <EvilTerran> lilac, nice!
10:31:02 <Baughn> b_jonas: No, I mean code that hits multiple, differently sized and typed STUArrays at once
10:31:07 <Baughn> *mutates
10:31:16 <b_jonas> Baughn: yes, you can do that
10:31:21 <Baughn> b_jonas: Okay. How? :)
10:31:35 <b_jonas> inside a runST, you call the function that creates them multiple times
10:31:42 <b_jonas> um
10:31:45 <b_jonas> I mean
10:31:55 <b_jonas> you _run_ the _action_ that creates such arrays multiple times
10:32:00 <b_jonas> I'm not really good in writing ST code
10:32:05 <b_jonas> it confuses me
10:32:16 <rabideejit> korpios: it's like this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3505#a3505
10:32:43 <Baughn> b_jonas: Umh. Oh. Right, I suppose I don't /have/ to use runSTArray.
10:32:54 <Baughn> Right, no more sugar for me.
10:33:13 <lilac> Baughn: do notation getting you down? :)
10:33:15 <b_jonas> Baughn: actually runSTArray is not just sugar
10:33:25 <b_jonas> it's also an optimization
10:33:30 <b_jonas> so it doesn't copy the array
10:33:35 <Baughn> b_jonas: I know, it calls unsafeFreeze safely and all that
10:33:37 <b_jonas> you might not be able to do _that_ with multiple arrays
10:33:38 <korpios> rabideejit: aha!  ghci> decode "[1,2,3]" :: Result [Integer]
10:33:38 <korpios>  
10:33:40 <Baughn> I can do that on my own
10:33:45 <korpios> Ok [1,2,3]
10:33:47 <b_jonas> well, you can just copy them
10:33:55 <Baughn> Or call unsafeFreeze multiple times. ;)
10:34:04 <Baughn> Although, as it turns out I only need zero of the arrays.
10:34:09 <korpios> rabideejit: thanks!  I think that's what I needed to get over that hump ... I always learn by diving in at the deep end, heh
10:34:24 <b_jonas> sometimes you don't even need the output, you just run reads on them inside the ST
10:34:45 <RowanD> lilac: not a palindrom unless you spell it wherewh
10:34:56 <b_jonas> (you probably need reads anyway, if you didn't, you'd just construct iarrays with the array function which allows random writes)
10:34:56 <RowanD> Or maybe wherehw
10:35:10 <rabideejit> korpios: you're welcome :)
10:35:11 <b_jonas> (unless you need impure actions to generate the writes)
10:35:23 <lilac> RowanD: if you want a character-level palindrom you'd need to spell it fixif too...
10:35:41 <Baughn> b_jonas: Yep. I'm trying to write a fast, /pure/ DES implementation.
10:35:47 <lilac> RowanD: on the level of haskell lexemes it's a palindrom, though...
10:36:15 <b_jonas> Baughn: wouldn't you just bind a DES impl that's already written in C?
10:36:16 <Baughn> b_jonas: Lots of bit-shuffling.
10:36:20 <lilac> RowanD: also, i seem to be unable to type the last 'e' in the word palindrome today ;-)
10:36:22 <b_jonas> with FFI and unsafePerformIO
10:36:27 <Baughn> b_jonas: I would, but hsOpenSSL already does that
10:36:36 <b_jonas> heh
10:36:41 <Baughn> b_jonas: And it doesn't use unsafePerformIO, so.. I figure there's probably a good reason for that
10:36:51 <rabideejit> I saw a really nice unlambda palindrome yesterday...
10:37:07 <b_jonas> Baughn: it needn't, the FFI has a builtin unsafePerformIO in it
10:37:20 <b_jonas> Baughn: you can import a C function saying it's pure
10:37:26 <b_jonas> and FFI can't verify that
10:37:27 <Baughn> ...
10:37:32 <Baughn> It doesn't do that either, anyhow.
10:37:48 <b_jonas> so if it uses FFI it doesn't need to explicitly say unsafePerformIO
10:38:04 <b_jonas> do you mean it's written in haskell?
10:38:15 <rabideejit> @unlambda `.d`.c`.d`.c`.d`.c`.d``e`````````````.H.e.l.l.o.,. .W.o.r.l.dii```````````````iid.l.r.o.W. .,.o.l.l.e.H.`````````````e``d.`c.`d.`c.`d.`c.`d.`
10:38:16 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
10:38:20 <rabideejit> ooh.
10:38:30 <b_jonas> rabideejit: heh, nice
10:38:46 <lilac> @unlambda `..`.`.```
10:38:46 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
10:38:55 <lilac> i dunno guv, looks broke to me
10:39:04 <b_jonas> @unlambda `.ai
10:39:04 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
10:39:18 <Baughn> b_jonas: No, I mean hsOpenSSL has some very complex code for communicating with openssl, and it /doesn't/ use unsafePerformIO or anything similar, so the bindings are all in IO..
10:39:32 <Baughn> b_jonas: ...and I don't dare try changing that myself, for fear of heisenbugs
10:39:45 <Baughn> b_jonas: There's memory management going on, and.. all sorts of dangerous stuff.
10:39:46 <b_jonas> Baughn: oh, you're saying all its functions are IO
10:39:46 <b_jonas> I see
10:39:47 <b_jonas> sorry
10:39:54 <b_jonas> well, sure
10:40:12 <Baughn> So I'm rewriting a simple encryption function just to compare speeds
10:40:22 <Baughn> But it's openssl. I dare say the result will be obvious.
10:40:26 <b_jonas> didn't some other irc bot also have an unlambda interpreter
10:41:01 <rabideejit> I have a small one myself
10:41:27 <rabideejit> The main problem is trying to keep memory use down, so I can actually use it on my tiny server.
10:42:18 <rabideejit> to plug myself shamelessly, I'm very happy with it:  It has options so the total memory of its child processes can never exceed a given limit.
10:43:35 <b_jonas> that's nice
10:44:49 <Baughn> rabideejit: So, um, setrlimit?
10:45:36 <rabideejit> yes.  I'm a posix fan boy.
10:46:24 <rabideejit> It forks a child process, then as the child executes a couple of setrlimit before execing another program.
10:47:30 <rabideejit> The main problem seems to be that parsing lazy bytestrings still takes a lot of memory.
10:50:40 <b_jonas> rabideejit: but rlimit can't limit the total usage of some resource in all subprocesses, can it?
10:50:41 <jeffersonheard> I know threadpools are not "normal" for Haskell, but is there an implementation around anyway?
10:50:56 <jeffersonheard> The problem is that I have 1000+ HTTP requests to do all at once
10:51:02 <dons> jeffersonheard: yeah, multiple impls.
10:51:04 <b_jonas> all it can do is limit the usage of something in each process or limit the number of total processes for a user
10:51:08 <dons> the DPH arrays library uses thread pools
10:51:18 <codebliss> Is it good practice to swap between do-syntax and normal syntax depending on which is easier?
10:51:19 <jeffersonheard> dons: figures.
10:51:20 <dons> sparks also effectively work as runtime-supported thread pools
10:51:20 <rabideejit> b_jonas:  It keeps track of how much memory it assign for each subprocess
10:51:36 <Baughn> jeffersonheard: GHC essentially does threadpools internally already. There's no need to reimplement them.
10:51:39 <codebliss> I can't imagine the following being easier without do..     let main = do { a <- getLine; b <- getLine; print (a,b); }
10:51:40 <jeffersonheard> dons: sparks won't open too many file descriptors?
10:51:56 <dons> quite possibly :)
10:52:08 <Baughn> jeffersonheard: Though I suppose something like a listener with a fixed number of worker threads would limit load nicely
10:52:12 <jeffersonheard> Baughn.  Yes and no.  I've run into the too many file descriptors problem
10:52:14 <dons> jeffersonheard: have you read the new multicore rts paper?
10:52:17 <mauke> codebliss: main = liftM2 (,) getLine getLine >>= print
10:52:20 <dons> it talks all about exactly how the impl. works
10:52:21 <jeffersonheard> no, not yet
10:52:23 <jeffersonheard> on my reading list
10:52:28 <Baughn> jeffersonheard: Kernel problem? Or in ghc?
10:52:34 <vixey> :t getLine &&& getLine
10:52:35 <lambdabot>     Couldn't match expected type `a b' against inferred type `IO'
10:52:35 <lambdabot>       Expected type: a b c
10:52:35 <lambdabot>       Inferred type: IO String
10:52:36 <codebliss> mauke: So ya, I'm pretty new to monads, I'll look at that =P
10:52:36 <Baughn> jeffersonheard: If the former, you could increase the limit
10:52:50 <b_jonas> isn't that easier with applicable?
10:52:56 <mauke> main = join (liftM2 (,)) getLine >>= print
10:52:58 <jeffersonheard> Baughn, neither, really.  I would call it a GHC problem.  They're sockets, not normal files -- if I hit the server with all at once, then kaboom
10:52:59 <b_jonas> oh no it's not sorry
10:53:06 <jeffersonheard> not just on my side, but on the server side as well
10:53:15 <codebliss> @hoogle liftM2
10:53:15 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:53:17 <Baughn> Oh, hang on. GHC still uses select, doesn't it?
10:53:23 <jeffersonheard> Baughn, yes
10:53:50 <codebliss> Hm...that's hot =P
10:53:51 <Baughn> Well. Oops. ^^;
10:54:40 <codebliss> steam
10:55:04 <Baughn> jeffersonheard: So basically you need to limit the number of simultaneous connections. Having a few hundred worker threads all trying to take an MVar with the next incoming connection in would do fine, I suppose
10:55:20 <jeffersonheard> Baughn, Yeah...  that's probably the best plan
10:56:00 <Baughn> jeffersonheard: Of course that makes you really vulnerable to DoS attacks
10:56:15 <jeffersonheard> Baughn - I'm not taking incoming HTTP requests.  I'm making outgoing ones
10:56:23 <jeffersonheard> downloading tiles for a map
10:56:33 <Baughn> Ah. Not so much, then.
10:56:45 <jeffersonheard> I'm tring not to look like a DoS attack :-)
10:56:53 <Baughn> ..and wait, you're trying to download all of them at once? o_O
10:56:58 <Baughn> Yeah.. good idea...
10:57:17 <Baughn> A more sensible limit would be four to ten. :P
11:02:09 <ZsoL> anyone has any idea to fix this error message while compiling gtk2hs?
11:02:12 <ZsoL> unknown package: glib-0.10.0
11:02:34 <ZsoL> seems weird that it requires itself to compile (almost like ghc ;))
11:02:35 <codebliss> @hoogle liftA2
11:02:35 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
11:06:45 <ZsoL> on a completely different note, this:
11:06:48 <ZsoL> @type id
11:06:49 <lambdabot> forall a. a -> a
11:06:51 <ZsoL> @type flip id
11:06:52 <lambdabot> forall b c. b -> (b -> c) -> c
11:07:07 <ZsoL> @type foldl (flip id)
11:07:08 <lambdabot> forall c. c -> [c -> c] -> c
11:07:16 <vixey> Â±Â¿Â¿Â¿what
11:07:22 <vixey> ZsoL: are you getting ?
11:07:59 <ZsoL> what do you mean? with the gtk2hs issue?
11:08:43 <BMeph_> ZsoL: I.e., What about 'id', 'flip id' and 'foldl (flip id)'? :)
11:08:59 <ZsoL> nothing it just got me stunned for a moment
11:09:18 <ZsoL> the types, how do you get b-> (b -> c) -> c for flip id
11:09:32 <vixey> :t flip
11:09:33 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:09:37 <vixey> :t id :: a -> b -> c
11:09:38 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `a'
11:09:38 <lambdabot>       `a' is a rigid type variable bound by
11:09:38 <lambdabot>           the polymorphic type `forall a b c. a -> b -> c'
11:09:43 <vixey> :t id :: (b -> c) -> b -> c
11:09:44 <lambdabot> forall b c. (b -> c) -> b -> c
11:10:02 <ZsoL> yeah yeah, okay
11:10:15 <vixey> what does 'yeah yeah' mean
11:10:42 <codebliss> ok ok?
11:10:42 <codebliss> lol
11:10:58 <ZsoL> yeah yeah means yes I have already figured it out, just thought it looked kinda weird
11:11:22 <vixey> ZsoL: k not sure why I wasted my time trying to answer you then
11:11:31 <ZsoL> wasn't a quesiton
11:11:35 <BMeph_> ZsoL: How would it not "look weird" to you? Not trolling, I'm genuinely curious. :)
11:11:41 * vixey must have misread "how do you get b-> (b -> c) -> c for flip id"
11:11:44 <travisbrady> does lambdabot have a cmd to parenthesize something?  i'm confused by the evaluation order of "main = print =<< (map toUpper `fmap` fmap head getArgs)"
11:12:11 <codebliss> Haskell is left associative
11:12:30 <pumpkin> the whole thing??
11:12:32 <pumpkin> oh my
11:12:42 <pumpkin> is visual basic right associative?
11:12:59 <codebliss> The language itself always is.  That's why we use $ to make some parts easy to write without ()'s =)
11:13:00 <c_wraith> haha
11:13:12 <BMeph_> pumpkin: I'd say that vb was disassociative, but that's just me. ;)
11:13:15 <pumpkin> :P
11:13:16 <jmcarthur> codebliss, i think you mean function application is
11:13:21 <codebliss> I skipped my vb class
11:13:23 <travisbrady> pumpkin: the bit after the `fmap` specifically
11:13:31 <codebliss> I slept in past 9 on accident.
11:13:31 <codebliss> lol
11:13:47 <jmcarthur> travisbrady, (fmap head) getArgs
11:13:49 <vixey> careful you might miss something important, like the 'dim' keyword
11:13:50 <c_wraith> travisbrady: infix operators are always lower precedence than function application by juxtaposition
11:13:57 <codebliss> The chick I always help was pissed, I feel like an idiot.  Oh well.  LOL vixey
11:14:17 <codebliss> I have no idea how to do their loops, I make everything recursive lol
11:14:18 <lilac> vixey: defint a-m and defdbl n-z
11:14:21 <pumpkin> dim pumpkin as variant
11:14:24 <codebliss> I hope it's not on the test XD
11:15:25 <BMeph_> lilac: Seriously? It assumes 'n' is a Double? And I thought Haskell's defaults were silly...
11:15:41 <ZsoL> BMeph_: okay, weird is probably not the perfect word. I was merely surprised
11:16:14 <codebliss> travisbrady: Did you see what I wrote yesterday?  That's very similar to what I was working on
11:16:15 <lilac> BMeph_: in qbasic at least; not sure if that one was kicked out of VB or not
11:17:27 <codebliss> travisbrady: A better way to write what I think you're going for is..   let main = print =<< map toUpper . head <$> getArgs   OR   let main = print =<< fmap (map toUpper . head) getArgs
11:17:45 <codebliss> <$> is basically `fmap`
11:17:54 <idnar> lilac: hmm, I can't remember, but I think VB might have been defint a-z or defvar a-z depending on which way a particular flag was set
11:17:54 <lilac> BMeph_: afair, 'defint n' means 'all variables starting with 'n' and with no type stigmata attached are assumed to be integers'
11:18:16 <idnar> yeah, n$ would always be a string, n! would always be an int, and so on
11:18:30 <jmcarthur> codebliss, well, that is subjective, really. saying it's "better" might be misleading
11:18:40 <idnar> er wait, was ! long or int?
11:18:41 <lilac> idnar: stop it, the memories of basic are making my head hurt!
11:18:45 <lilac> idnar: % was int iirc
11:18:49 <codebliss> jmcarthur: Less complicated =)
11:19:17 <idnar> oh right, ! was single, % was int, & was long
11:19:57 <neoswish> guys, is there some extension in Haskell to define inverse functions? I saw this in J lunguange, its kinda fun :)
11:20:09 <codebliss> flip?
11:20:15 <neoswish> no
11:20:15 <pumpkin> not really, but you could make an ADT that encapsulates them
11:20:24 <kerlo> J sounds like a difficult language to Google.
11:20:27 <neoswish> like: inverse (+) == (-)
11:20:30 <pumpkin> haskell can't check that they're actually inverses
11:20:34 <codebliss> oh lol
11:20:45 <pumpkin> neoswish: I wouldn't call those inverses
11:20:45 <codebliss> kerlo: J programming language =P
11:20:57 <omnihil> neoswish, what's the inverse of odd :: Int -> Bool?
11:21:18 <pumpkin> not all functions are invertible
11:21:21 <kerlo> neoswish: (+), having type a -> a -> a, would surely have an inverse of type (a -> a) -> a.
11:21:27 <halberd> you could take the level sets
11:21:34 <kerlo> The inverse of (+x), on the other hand, is (-x).
11:21:37 <pumpkin> yeah
11:21:49 <codebliss> a -> a -> a is (a -> a) -> a?
11:21:52 <codebliss> That's currying
11:21:56 <pumpkin> no
11:22:05 <omnihil> the inverse of a -> a -> a is (a -> a) -> a
11:22:06 <pumpkin> that's fix :P
11:22:09 <travisbrady> codebliss: yes, i reading your discussion yesterday
11:22:09 <jmcarthur> a -> a -> a is a -> (a -> a)
11:22:11 <vixey> (a,a) -> a) -> (a -> a -> a) is currying
11:22:22 <idnar> a -> a -> a is a -> (a -> a)
11:22:26 <idnar> and that's just right-associativity :P
11:22:29 <vixey> a -> a -> a is  (->) a (a -> a)
11:22:30 <codebliss> travisbrady: Okay.  I'll msg you in priv and discuss it
11:22:40 <Baughn> pumpkin: Would be interesting to try writing a language where they all are, though
11:22:43 <neoswish> yes, not all functions, but there are some, for other just yield an error)
11:22:49 <pumpkin> Baughn: all functions are invertible?
11:23:03 <Baughn> pumpkin: Where you can't write a non-invertible one. For reversible computing, you know.
11:23:08 <pumpkin> ah yeah
11:23:19 <pumpkin> in many cases that might just amount to keeping the original arguments around though
11:23:23 <jmcarthur> @djinn (a -> b) -> (b -> a)
11:23:24 <lambdabot> -- f cannot be realized.
11:23:28 <Baughn> pumpkin: Well, though RC always meant to have irreversible ones, just.. not as frequently
11:23:31 <jmcarthur> ^^ can't do it in general
11:23:39 <kerlo> Well, in Haskell, you couldn't have a function invert :: (a -> b) -> b -> a.
11:23:49 <pumpkin> in general, you can't
11:23:54 <kerlo> It may be possible for certain a, and for b in Eq, and all.
11:24:25 <Baughn> pumpkin: Eh, not quite. Mechanically, it'd be very hard to unscramble the egg if you don't keep track of the intermediate states, too - but I suppose you'd interleave the unscrambling with the computation
11:24:41 <neoswish> dont need in general, just like some syntatic sugar will be good
11:25:04 <pumpkin> but you could do data Iso = Iso (a -> b) (b -> a) with applyIso (Iso f _) = f and invertIso (Iso f f') = Iso f' f
11:25:14 <jmcarthur> i don't think syntax sugar can get you there either, really
11:25:14 <pumpkin> but you'd need to prove them yourself
11:25:50 <halberd> you could write a language where instead of f :: X->Y you have f :: X->(X,Y)
11:25:58 <halberd> always including the input as part of the output
11:26:05 <halberd> that would allow invertibility
11:26:14 <pumpkin> yeah
11:26:33 <idnar> sorta like having an Invertible monad, and lifting everything into it?
11:26:37 <jmcarthur> only if you don't force that rule for the inverse functions
11:27:07 <jmcarthur> otherwise you'd have inverse f :: (X,Y) -> ((X,Y),X)
11:27:19 <jmcarthur> well, i guess that would still get you the inverse, but in a weird way
11:27:31 <halberd> yes you make an exception for inverses
11:27:38 <kerlo> @djinn (x,y) -> ((x,y),x)
11:27:39 <lambdabot> f (a, b) = ((a, b), a)
11:27:44 <kerlo> Wow, I never would have guessed.
11:27:45 <idnar> why do you need the exception, except as an optimisation?
11:27:47 <jmcarthur> but then the inverses could be inverted ;)
11:28:07 <pumpkin> that's fine!
11:28:11 <jmcarthur> idnar, i just mean that without that exception, it's not a true inverse
11:28:18 <jmcarthur> it's an "augmented" inverse
11:28:24 <idnar> jmcarthur: it's a lifted inverse :P
11:30:02 <jmcarthur> would basically amount to disallowing garbage collection ;)
11:30:23 <pumpkin> infinite memory
11:30:24 <pumpkin> mmm
11:30:36 <pumpkin> then we even have full TMs instead of LBA
11:31:01 <halberd> well
11:31:06 <halberd> it would only allow invertibility in theory
11:31:12 <b_jonas> and infinite speed too
11:31:22 <pumpkin> someone should invent something like that!
11:31:26 <pumpkin> and build one
11:31:26 <zloog> Is there a way to convert to/from lazy and strict bytestrings?
11:31:27 <Duqicnk> you can already build a real TM, it just needs a trust fund... when it runs out of RAM it waits until it can afford more, then buys it and pays someone to install it
11:31:38 <codebliss> @hoogle (<$>)
11:31:39 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
11:31:49 <jmcarthur> :t pack
11:31:51 <lambdabot> Not in scope: `pack'
11:31:57 <jmcarthur> :t Data.ByteString.pack
11:31:59 <lambdabot> [Word8] -> BSC.ByteString
11:32:02 <jmcarthur> :t Data.ByteString.unpack
11:32:04 <lambdabot> BSC.ByteString -> [Word8]
11:32:08 <jmcarthur> like that?
11:32:39 <zloog> Well I've been working with strict bytestrings and now I need to use the zlib library and it expects lazy ones
11:32:45 <pumpkin> fromChunks and toChunks
11:32:47 <b_jonas> Duqicnk: yes, that's how you can also write a function that goes back in time: it's just a stub waits until a real time machine module is implemented, then downloads and installs that and calls it (adding the extra time it waited)
11:32:50 <zloog> so I was wondering if there was a way around that
11:32:56 <pumpkin> but those aren't ideal
11:33:02 <jmcarthur> oh, converting _between_ lazy and strict
11:33:20 <Duqicnk> b_jonas: it's even easier, you just wait for someone from the future to tell you how to build a time machine
11:33:38 <Duqicnk> but this assumes that time machines exist and that they can go back to before they were invented
11:33:42 <zloog> yea
11:34:33 <halberd> yes and to create an infinite improbability machine all you need is to ask a finite improbability machine ;)
11:35:05 <b_jonas> halberd++
11:39:11 <b_jonas> ah great, so the LANGUAGE pragma need not be in the first line, it just has to come before the first non-comment line
11:39:24 <b_jonas> the ghc docs are confusing in this respect
11:42:58 <travisbrady> zloog: toStrict = S.concat . LS.toChunks where S and LS are strict and lazy bytestring libs imported qualified
11:43:09 <travisbrady> toLazy s = LS.fromChunks [s]
11:44:12 <zloog> travisbrady: thanks!
11:45:21 <travisbrady> zloog: sure, glad to help
11:46:55 <bmh> I'm grappling with a bug in cabal install. I instruct it to install something, then it begins resolving dependencies, runs for a while and the dies saying "Killed"
11:47:17 <monochrom> ghc doc confusing? ghc doc doesn't say "Certain pragmas are file-header pragmas. A file-header pragma must precede the module keyword in the file. There can be as many file-header pragmas as you please, and they can be preceded or followed by comments" verbatim?
11:47:21 <orbisvicis> the "runhaskell Setup.hs register --gen-script
11:47:46 <orbisvicis> " script creates depends on actual current installed version
11:48:13 <orbisvicis> instead of real dependencies i.e. utf8-string>=A.Number
11:48:26 <monochrom> Well I guess it doesn't say LANGUAGE is one of those file-header pragmas. It only says LANGUAGE replaces OPTIONS_GHC, OPTIONS_GHC is a file-header pragma.
11:48:41 <orbisvicis> can that be changed ?
11:49:33 <orbisvicis> its seems to be a problem with Distribution.Simple, not Setup.hs
11:50:03 <Saizan> ghc-6.6.1 had base-2, right?
12:03:08 <tomh> :t seq
12:03:09 <lambdabot> forall a t. a -> t -> t
12:03:15 <tomh> @src seq
12:03:16 <lambdabot> Source not found. Take a stress pill and think things over.
12:03:35 <tomh> is there a lambdabot command to see in what package some function is?
12:04:08 <bmh> tomh: hoogle won't do the trick?
12:04:20 <maxote> in the Turing Machine age, garbage collection didn't exist. How will be a garbage collection for the TM?
12:04:26 <tomh> it does the trick by giving 10k results :>
12:04:29 <tomh> @hoogle seq
12:04:29 <lambdabot> Data.Sequence data Seq a
12:04:29 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
12:04:29 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
12:04:32 <b_jonas> tomh: @hoogle sometimes works
12:04:38 <p_l> maxote: when you have infite tape, you don't need GC
12:04:53 <b_jonas> p_l: that's only if you don't care about execution time
12:05:17 <tomh> anyone here can quickly tell me in what package seq is? :)
12:05:22 <bmh> b_jonas: You're using a TM. You don't care about execution time. You're writing a proof.
12:05:24 <b_jonas> tomh: Prelude
12:05:29 <idnar> @index seq
12:05:29 <lambdabot> Prelude, Control.Parallel
12:05:38 <tomh> ok thanks
12:05:53 <p_l> b_jonas: TM was asynchronous and used quite possibly infinite speed tape... :P
12:06:03 <maxote> execution time can be trillions of trillions of lightspeed years if you don't care
12:07:21 <tromp_> lightspeed year is a distance:(
12:07:33 <maxote> TM running at lightspeed
12:07:49 <maxote> to the max. frecuency
12:07:56 <bmh> I find this entire conversation to be bordering on incoherency.
12:08:53 <Duqicnk> drop your computer into a black hole
12:09:10 <bmh> Duqicnk: That will only slow it down
12:09:24 <bmh> pumpkin: You've missed a brilliant discussion of efficient garbage collection on turing machines.
12:09:35 <jmelesky> bmh: from our perspective, yeah. but the computer will think it's finished the problem.
12:09:38 <cantor> maxote: with tachyons, above lightspeed
12:09:53 <b_jonas> bmh: yeha, this should go to #haskell-blah, matches the "blah" well
12:09:53 <BMeph_> Duqicnk: Drop yourself into a black hole, then all your results will work super-fast! ;p
12:10:16 <pumpkin> oh no!
12:10:44 <bmh> I'm only interested in computations that decrease entropy globally.
12:10:59 <b_jonas> we could just put the computer in a rocket that's sent away from earth fast then quickly turns back and comes back fast, then relativistic effects will make it appear as if it worked very fast
12:11:24 <bmh> b_jonas: Incorrect.
12:11:35 <cantor> b_jonas: it would work as low as the time slows down
12:11:35 <tromp_> n korea tried that...
12:12:04 <p_l> b_jonas: it would be as if it was very slow. It's "leave computer on earth and go NFTL for a while"
12:12:17 <b_jonas> if our industry wasn't so specialized on computers that break down after a few years, we could use that technique to factor numbers really fast
12:12:47 <halberd> relativistic effects would make it appear as if it worked very slow
12:12:58 <maxote> put a million of TMs in a GPGPU, it's equivalent to one TM but one million times faster.
12:13:20 <bmh> I can't get cabal to install things.
12:13:29 <bmh> It hangs while resolving dependencies and then says "Killed"
12:13:46 <b_jonas> halberd: are you sure? even if it turns back and comes back to Earth?
12:13:50 <bmh> This question is as relevant to this channel as garbage collection on turing machines is irrelevant to anything.
12:13:56 <halberd> you age slower as you travel rapidly in a spaceship
12:14:09 <tromp_> that's what i remember too
12:14:14 <b_jonas> halberd: hmm, maybe you're righht
12:14:21 <b_jonas> I'm not good in relativity theory
12:14:31 <tromp_> a returning astronaut finds everyone on earth aged much more
12:14:31 <Duqicnk> GPUs are terrible for simulating TMs
12:14:42 <Duqicnk> they would actually be better for simulating the prototypical quantum computer
12:14:44 <b_jonas> tromp_: yeah, you're right
12:14:46 <bmh> yes. The faster you go in your inertial frame of reference, the slower an observer perceives that you are traveling through time.
12:14:48 <b_jonas> that's the point of that Lem novel
12:14:56 <bmh> So, let's all put our heads together and help me fix cabal.
12:15:21 <Fortunately> yes but you experience everyone else as moving very fast and yourself as staying still
12:15:42 <Fortunately> to you, everyone else ages slowly
12:16:02 <bmh> go join #relativity.
12:16:35 <b_jonas> Fortunately: yes, the question is what happens when you come back
12:16:35 <Trafalgard> <Duqicnk> GPUs are terrible for simulating TMs
12:16:35 <Trafalgard> <Duqicnk> they would actually be better for simulating the prototypical quantum computer
12:16:39 <Trafalgard> Hmm, intelligent conversation
12:16:43 <Trafalgard> I must be in #haskell
12:17:07 <Fortunately> right, accelerating throws everything off
12:17:16 <pumpkin> quick, let's get a good ol' flame war going
12:17:20 <pumpkin> to remind people we're in IRC
12:17:38 <Fortunately> wiki has a good page on the twin paradox i think its called
12:17:38 <pumpkin> first of all, we need the arrogant know-it-all who takes every opportunity to prove he's smarter than you, any volunteers?
12:17:45 <bmh> pumpkin: I'll bite.
12:18:01 * p_l is having serious armchair psychology discussion in anime channel right now, you guys can flame
12:18:05 <Duqicnk> haskell sucks because functional programming will never be fast
12:18:07 <pumpkin> alright, then we need the "halp me, my assignment is due tomorrow" dude
12:18:11 <Duqicnk> you can't do IO without knowing category theory
12:18:13 <pumpkin> oh and the troll
12:18:13 <b_jonas> pumpkin: me too
12:18:15 <Duqicnk> besides, it's not applicable to the real world
12:18:15 <bmh> pumpkin: I can fill that role too.
12:18:22 <pumpkin> looks lik Duqicnk will be the troll
12:18:37 <pumpkin> alright, start playing your roles
12:18:37 <b_jonas> do we need an OT guy as well?
12:18:39 <pumpkin> oh yeah
12:18:44 <Duqicnk> C++ has functors too
12:18:44 <bmh> I can do blood, love, and rhetoric.
12:19:00 <b_jonas> because I'd like to know how to set up rlwrap so it doesn't put single-character lines in the history
12:19:12 <pumpkin> lol
12:19:15 <b_jonas> and I don't want to rtfm but I have to know it so please tell me
12:19:16 <Duqicnk> p_l: you're analyzing the psychology of people who watch anime?
12:19:44 <asgaroth> I have a problem with darcs(2.2.0): darcs amend-record --edit-description (as listed in the manpage) is not recognized as a valid option.
12:20:07 <pumpkin> bmh: don't forget to point out some minor technicality in every newcomer's question, and state that it makes their question invalid and the person an idiot
12:20:17 <p_l> Duqicnk: No, we are using anime-related channel to talk about berserker rage, using ourselves as study participants
12:20:30 <bmh> (15:04:20) maxote: in the Turing Machine age, garbage collection didn't exist. How will be a garbage collection for the TM?
12:20:30 <Duqicnk> pumpkin: this works better in languages with more than one spec version
12:20:35 <bmh> pumpkin: Like how that shit was incoherent?
12:20:39 <Duqicnk> "no, you idiot, it's not valid in C99 Rev. B Turbo Edition"
12:20:42 <pumpkin> bmh: sure thing
12:21:00 <b_jonas> oh yeah, I like language lawyering
12:21:10 <b_jonas> if you read the details, the C standard seems so imprecise
12:21:23 <pumpkin> bmh: but even things that do make sense, you should point out the inevitable assumption or error
12:21:45 <Duqicnk> about the worst thing haskellers do to noobs is bombard them with terrible analogies about what a monad is
12:21:53 <b_jonas> or should I assume the role I usually play, ranting about things no-one is interested in?
12:21:57 <pumpkin> clearly monads are burritos
12:22:05 <pumpkin> Duqicnk: I actually haven't seen much of that recently
12:22:10 <te> es!  yay!
12:22:33 <Duqicnk> granted the terribleness of an analogy is in the eye of the beholder
12:22:37 <Duqicnk> but i never found any of them particularly useful
12:22:46 <pumpkin> yeah, I just accept monads as monads :P
12:23:55 <halberd> not because they look like Tyson Bedford
12:23:57 <bmh> pumpkin: Imagine we're simulating a Turing Machine in a garbage collected monad. If we accelerate it to .999c, will parallelism keep working?
12:24:03 <pumpkin> lol
12:24:26 <b_jonas> I imagine monads as the special case of all useful monads I know nested, so they're like ContT, StateT, WriterT, (->), [], EitherT, IO nested an unbounded number of times in all order
12:24:35 * pumpkin makes the next internet hit video, 2 natural transformations, 1 functor
12:24:51 <b_jonas> of course IO is not nested, it's just at the bottom
12:24:59 <b_jonas> all the other transformers are nested
12:25:19 <Saizan> pumpkin: 2 functors, 1 natural transformation would actually make sense!
12:25:23 <pumpkin> I know!
12:25:27 <Apocalisp> @remember pumpkin makes the next internet hit video, 2 natural transformations, 1 functor
12:25:27 <lambdabot> Okay.
12:25:34 <pumpkin> but I want it to be like 2 girls 1 cup
12:25:55 <b_jonas> @quote pumpkin
12:25:55 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
12:26:12 <pumpkin> :)
12:26:25 <codebliss> @hoogle system
12:26:25 <lambdabot> System.Cmd system :: String -> IO ExitCode
12:26:25 <lambdabot> module Distribution.System
12:26:25 <lambdabot> package system-inotify
12:26:37 <Saizan> (why is \bot opped?)
12:26:49 <vixey> oh that is not good
12:26:53 <Apocalisp> I find it helps noobs best to explain monads as functors with join.
12:26:58 <pumpkin> Saizan: actually wait, I thought I saw how 2 functors 1 NT worked, but I don't think I o
12:26:59 <pumpkin> do
12:27:23 <b_jonas> Apocalisp: really? because I still don't understand that functors with join thing.
12:27:37 <Apocalisp> b_jonas: do you understand functors?
12:27:39 <boegel> wow? I'm impressed how much faster my dist function is using (UArr Double) instead of [Double]
12:27:41 <Saizan> type Natural f g = forall a. f a -> g a , in Hask
12:27:42 <b_jonas> Apocalisp: I do know it works theoretically because I've seen how you can define (>>=) from join
12:27:52 <b_jonas> but I don't really understand why that works or whta join really does
12:27:58 <Apocalisp> @type join
12:27:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:28:12 <pumpkin> boegel: UArr is awesome :D
12:28:24 <pumpkin> boegel: dist?
12:28:43 <Apocalisp> b_jonas, join for list concatenates a list of lists, for example
12:28:53 <b_jonas> Apocalisp: so it's concat there
12:29:00 <b_jonas> but for lists sequence does that too
12:29:12 <b_jonas> and for functions join is reflex: join f x = f x x
12:29:14 <Duqicnk> a monad is an idempotent functor?
12:29:17 <boegel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3509#a3509
12:29:19 <b_jonas> I don't get all the connection between thoe
12:29:24 <boegel> pumpkin: Euclidean distance, see ^
12:29:26 <pumpkin> b_jonas: sequence doesn't concatenate the lists
12:29:34 <boegel> I'm still trying to get it faster though...
12:29:36 <mun> if i want bidirectional communication via sockets between 2 programs, would i need both a client and server on both ends?
12:29:46 <b_jonas> pumpkin: hmm, you're right, it doesn't
12:29:48 <bmh> no.
12:30:01 <Apocalisp> @type sequence
12:30:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:30:11 <Apocalisp> sequence is traverse
12:30:13 <c_wraith> mun: the terms "client" and "server" aren't protocol-level terms.  They're terms that describe the function of each application.
12:30:17 <b_jonas> I'm just stupid there
12:30:23 <Apocalisp> @type Control.Traversable.traverse
12:30:24 <lambdabot> Couldn't find qualified module.
12:30:32 <Apocalisp> @type Control.Traversible.traverse
12:30:33 <lambdabot> Couldn't find qualified module.
12:30:36 <Apocalisp> oh bollox
12:30:36 <vixey> Can you define the Computation monad only using least fixed point data types?
12:30:41 <pumpkin> boegel: there's already a sumU that does what your sum' does, btw
12:30:43 <Duqicnk> c_wraith: they are protocol-level terms in terms of who listens for a connection and who initiates
12:30:58 <Duqicnk> but regardless of that, the resulting connection is bidirectional
12:31:00 <Saizan> mun: you need one listening and the other connecting to that port, but after you've estabilished a connection both ends can send and receive on it
12:31:01 <boegel> pumpkin: oh, k
12:31:05 <mun> c_wraith: well, i want them both to be able to send and receive messages
12:31:28 <mun> Saizan: right, so messages can be sent both ways using the same socket?
12:31:32 <c_wraith> mun: as others have pointed out, sockets are bidirectional.  You only need to open one, and you get communication both ways
12:31:37 <Saizan> mun: yup
12:31:41 <pumpkin> boegel: but I don't think you can get it much faster than that
12:31:43 <mun> thanks
12:31:48 <boegel> pumpkin: hmm
12:32:05 <boegel> pumpkin: how about not using zipWithU, but sum and zipping at the same time?
12:32:10 <b_jonas> yes, connected tcp sockets are basically symmetrical
12:32:16 <boegel> pumpkin: that would avoid running over the list twice, I guess
12:32:21 <boegel> s/list/lists
12:32:24 <Trafalgard> the one that's called the "server" is the one that starts out listening for connections
12:32:26 <b_jonas> before the connection is up you create them differently, but after that the two ends work the same
12:32:40 <Trafalgard> the "client" is just the one that connects to the "server"
12:32:41 <travisbrady> mun: the RWH chapter on network programming is pretty instructive if you're interested, http://book.realworldhaskell.org/read/sockets-and-syslog.html
12:32:45 <Trafalgard> once they're connected it's bidirectional
12:33:02 <pumpkin> boegel: it's can be hard to write your own traversal functions for UArrs
12:33:15 <Trafalgard> if it works in haskell like it works in winsock etc then the listening stuff is still open though
12:33:32 <mun> travisbrady: thanks
12:33:34 <bmh> pumpkin: If you were implementing a tree that supports the splay operation and parent pointers, how would you do it?
12:33:35 <boegel> pumpkin: doing it effectively though...
12:33:42 <Trafalgard> but presumably you'll find out about that if you look into it
12:34:45 <pumpkin> boegel: and with fusion you might not even be traversing the array twice actually
12:35:15 <pumpkin> bmh: not a clue, parent pointers are hard unless you represent the tree as a graph
12:35:18 <travisbrady> how come i can do "let m = map (++"xx")" but not "let f = fmap (++"xx")", the latter fails with "Ambiguous type variable `f' in the constraint"?
12:35:32 <Duqicnk> @type fmap
12:35:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:35:34 <Duqicnk> @type map
12:35:35 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
12:35:47 <pumpkin> gotta run
12:35:48 <bmh> pumpkin: Won't work. I'm trying to implement Dynamic Trees, which are a structure for efficient graph representation
12:35:48 <Apocalisp> @type (.)
12:35:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:36:06 <iago_> someone has problems installing darcs from hackage via cabalinstall?
12:36:20 <bmh> iago_: I can't install anything using cabalinstall.
12:36:31 <Apocalisp> b_jonas: Do you get the relationship between (.) and map?
12:36:32 <pumpkin> bmh: ah, might be hard then :P does okasaki's functional data structures book mention anything about it?
12:36:36 <bmh> iago_: But the people here are more interested in discussing garbage collection on TMs and relativistic physics than anything else
12:36:38 <bmh> pumpkin: no
12:36:46 <b_jonas> doesn't the view syntax cause an ambiguity with the pattern guards syntax? if the compiler sees "case x of { y -> z" how can it know if that's the start of a view in a pattern guard or a normal case arm?
12:36:48 <boegel> pumpkin: so it would be hard to improve over what I have now?
12:37:00 <b_jonas> Apocalisp: both are special case of fmap, yes
12:37:04 <iago_> bmh, lol
12:37:04 <Saizan> travisbrady: the dreaded Monomorphism Restriction
12:37:11 <b_jonas> Apocalisp: that's because of how functions work as a monad
12:37:34 <Saizan> bmh: which problem do you have with cabal-install?
12:37:41 <Saizan> iago_: you too
12:37:43 <pumpkin> boegel: I'd imagine... try writing the fastest one you can in c and see how they compare :P if you start bringing in SSE primitives that might be unfair, but I'd expect your UArr one to be pretty close to a good c one that doesn't use SSE
12:37:49 <boegel> pumpkin: would any optimization flags help out in any way?
12:37:56 <Saizan> iago_: darcs has many configuration flags, btw
12:38:02 <pumpkin> boegel: -fexcess-precision
12:38:09 <bmh> Saizan: cabal install hfuse... then it says "Resolving dependencies" after that it hangs for a while and spits out "Killed" and dies
12:38:23 <b_jonas> I don't dread it
12:38:29 <b_jonas> I like the monomorphism restriction
12:38:33 <iago_> Saizan, ? I'm getting an error compiling a c source file
12:38:38 <Saizan> bmh: cabal-install-0.5.x on ghc-6.10.x ?
12:38:39 <pumpkin> boegel: -O2 -fvia-C -optc-O3 (usually makes UArr code better)
12:38:46 <iago_> (cabal compile it of course, hscurl.c)
12:38:52 <idnar> b_jonas: the beloved monomorphism restriction?
12:39:04 <pumpkin> is there an epimorphism restriction? :o
12:39:09 <Saizan> iago_: ah, which error? maybe you don't have the C curl lib installed
12:39:19 <bmh> Saizan: cabal 0.5.2, ghc 6.10.1, cabal lib 1.4.0.2
12:39:22 <idnar> polymorphism restriction
12:39:29 <iago_> I'm looking for it Saizan
12:39:43 <iago_> although I hope that there are plans to include this kind of checks
12:39:45 <boegel> pumpkin: I'm doing just that :)
12:39:49 <pumpkin> ok :)
12:39:58 <Saizan> bmh: heh, you need to upgrade to cabal-install-0.6.x
12:39:59 <pumpkin> boegel: ask the c compiler to auto-vectorize etc. then :P
12:40:05 <pumpkin> see if you can squeeze any more performance out
12:40:19 <bmh> Saizan: I suppose `cabal upgrade cabal` won't do it
12:40:36 <jedai> bmh: it should
12:41:00 <jedai> cabal upgrade cabal-install
12:41:01 <Saizan> bmh: if you still have the an ghc around you can use it e.g. cabal update && cabal install -w ghc-6.8.2 cabal-install
12:41:17 <Saizan> s/an ghc/an older ghc/
12:41:25 <boegel> pumpkin: you mean use SSE and stuff, right?
12:41:31 <Apocalisp> b_jonas: Functor is "function application in a context". A function (b -> a) provides a context (b ->) from which to read. [b] is the same in that respect.
12:41:47 <Saizan> bmh: otherwise you can use the bootstrap.sh script if you're on unix, or download the binary on windows
12:42:09 <Duqicnk> can anyone comment on the truth of my statement "a monad is an idempotent functor"?
12:42:48 <edwardk> Duqicnk: its not.
12:42:55 <Duqicnk> i guess the existence of join doesn't tell you that f (f a) is (f a)
12:42:58 <Duqicnk> but it does relate the two
12:42:59 <b_jonas> what do you mean by idempotent there?
12:43:01 <edwardk> Duqicnk: in one sense it is, that is, join exists.
12:43:23 <edwardk> bind return = id
12:43:30 <vixey> f . f = f is idempotent,  join usually loses some information
12:43:32 <Saizan> but i'd not consider monoids idempotent just because mappend exists
12:43:36 <b_jonas> @src bind
12:43:36 <lambdabot> Source not found. Where did you learn to type?
12:43:38 <Apocalisp> Duqicnk: m (m a) implies (m a), but not the other way around.
12:43:40 <b_jonas> @type bind
12:43:41 <lambdabot> Not in scope: `bind'
12:43:43 <Duqicnk> @type mappend
12:43:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:43:44 <b_jonas> what's bind?
12:43:53 <edwardk> yeah
12:43:55 <jmcarthur> :t (>>=)
12:43:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:44:03 <edwardk> return . bind return != id
12:44:10 <edwardk> otherwise i'd agree
12:44:12 <vixey> if you have a tree of trees  Tree (Tree a) --> Tree a, you lose which branches got spliced together
12:44:15 <Apocalisp> b_jonas: (>>=) is sometimes pronouced "bind"
12:44:22 <b_jonas> oh
12:44:24 <Duqicnk> Apocalisp: but "return" is a proof of (m a) -> m (m a), no?
12:44:33 <b_jonas> I knew I heared bind somewhere
12:44:37 <Duqicnk> @type return . return
12:44:38 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Monad m) => a -> m (m1 a)
12:44:48 <Apocalisp> Duqicnk: Good point
12:44:58 <Apocalisp> I see what you're saying
12:45:00 <Duqicnk> but these are not bijections, necessarily
12:45:06 <Apocalisp> right
12:45:08 <edwardk> return says you can inject a value: a -> m a and consequently m a -> m (m a)
12:45:09 <vixey> join . return = id ; return . join isn't id for the reason I just mentioned
12:45:10 <Duqicnk> @type join . return . return
12:45:11 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
12:45:17 <Duqicnk> @type join . return
12:45:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
12:45:21 <edwardk> join says you can go from m (m a) -> m
12:45:24 <edwardk> er to m a
12:45:26 <Duqicnk> yeah i see
12:45:34 <Duqicnk> the type is the same as id, but it's not id
12:45:43 <edwardk> but return . (=<<) return is not id
12:46:41 <tromp_> @src join
12:46:41 <lambdabot> join x =  x >>= id
12:46:47 <MTK> I'm working on an assignment using Haskell just need some tips... It's to convert XML to plain text (with proper formatting).. I'm using the xml library
12:47:00 <dolio> return . (=<<) return = return.
12:47:25 <jedai> MTK: look at haxml or hxt
12:47:30 <Apocalisp> @type \f -> join . fmap f
12:47:31 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f a) -> f a1 -> f a
12:47:53 <Apocalisp> @pl \f -> join . fmap f
12:47:53 <lambdabot> (=<<)
12:48:04 <BMeph_> The important thing is: join . return == id, but return . join is not. -- Did I get the right order?
12:48:22 <Saizan> yep
12:48:23 <opqdonut> interesting
12:48:43 <opqdonut> ah, yes
12:48:59 <Saizan> id == join . fmap return, also
12:49:07 <BMeph_> I think there should be some 'fmap's in there somewhere. :\
12:50:37 <Apocalisp> @type join . fmap return
12:50:38 <lambdabot> forall a (m :: * -> *). (Functor m, Monad m) => m a -> m a
12:52:12 <BMeph_> @type fmap join . fmap return
12:52:13 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f (m a) -> f (m a)
12:52:50 <atom> hi peeps. I'm trying myself at writing a hash function (got a theoretical idea I want to put into practice), but I need to access individual bits of a the string. I'm pretty new to haskell (but I've already written the thing in python). I don't mind hardcoding the string at this point, but is there some lib that would enable bitwise instead of character-wise access?
12:52:53 * BMeph_ does the "happy Kirby " dance at his desk...then quickly looks around to see if anyone noticed.
12:53:23 <vixey> :t (fmap fmap fmap) (fmap join . return)
12:53:24 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (m :: * -> *) a (f2 :: * -> *). (Monad f2, Functor f2, Monad m, Functor f1, Functor f) => f (f1 (m (m a))) -> f (f1 (f2 (m a)))
12:53:29 <BMeph_> atom: Data.Bits is your friend. :)
12:53:33 <vixey> :t (fmap fmap fmap) (join . fmap return)
12:53:34 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a (m :: * -> *). (Functor m, Monad m, Functor f1, Functor f) => f (f1 (m a)) -> f (f1 (m a))
12:53:53 <atom> BMeph_: I thougt so, but I can't find any examples of turning a string into a sequence of bits.
12:54:29 <BMeph_> atom: Hint 2: Data.Char has ways of turning Chars into Ints. :)
12:54:31 <atom> Maybe it's just that I'm tired because of the concert last night (my ears are still ringing), but I just can't figure out how the stuff is used.
12:54:59 <atom> BMeph_: wait, doesn't that mean your input gets inflated 4-fold?
12:55:20 <BMeph_> atom: (Hint 0: Strings are treated as lists of Chars.)
12:55:29 <Saizan> atom: Char is already 32bits
12:55:30 <BMeph_> atom: ...huh?
12:55:49 <Saizan> atom: it's an unicode codepoint (or is it called scalar value?)
12:55:55 <atom> BMeph_: oh... chars are 32 bits? So... If I'm reading from a file I should read it as int?
12:56:18 <BMeph_> atom: Ah - listen to the Saizan. He's your paisano. ;)
12:56:46 <atom> Saizan: it's good to know Char is a unicode type in haskell :)
12:56:46 * BMeph_ facepalms
12:57:07 <codebliss> atom: Haskell never disappoints!
12:57:26 <atom> until your brain starts to hurt.
12:57:36 * BMeph_ runs off to play at the ^W^W^W conduct testing at the beaach
12:57:39 <codebliss> It never disappointed you now did it?
12:57:42 <Saizan> atom: however standard IO functions currently basically only use latin1, since they use only the last 8 bits
12:57:46 <codebliss> @hoogle string
12:57:46 <lambdabot> Text.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
12:57:46 <lambdabot> Text.ParserCombinators.ReadP string :: String -> ReadP String
12:57:46 <lambdabot> Text.ParserCombinators.Parsec.Char string :: Stream s m Char => String -> ParsecT s u m String
12:57:56 <codebliss> type String = [Char]
12:58:02 <codebliss> I forgot the command to see source
12:58:03 <codebliss> oh
12:58:07 <codebliss> @src Strng
12:58:07 <lambdabot> Source not found. I feel much better now.
12:58:10 <codebliss> @src String
12:58:10 <lambdabot> type String = [Char]
12:58:13 <codebliss> There.
12:58:14 <Saizan> atom: there are libriaries to deal with encodings on hackage, though
12:58:17 <gwern> hm. lb is opped?
12:58:18 <codebliss> Literally, that's all it is.
12:58:22 <gwern> didn't know it could do that...
12:58:23 <vishnooo> hi
12:58:30 <codebliss> Yep.
12:59:14 <atom> actually, I didn't really want to deal deal with strings of characters, I wanted to deal with pure bitstreams, but since the stuff is represented by char-arrays anyway (in C) I thought it would be pretty much the same in haskell. Big mistake I guess.
12:59:45 <codebliss> :t system
12:59:46 <lambdabot> Not in scope: `system'
12:59:55 <codebliss> :t System.Cmd.system
12:59:56 <lambdabot> String -> IO GHC.IOBase.ExitCode
13:00:08 --- mode: ChanServ set +o Saizan
13:00:13 --- mode: Saizan set -o lambdabot
13:00:22 --- mode: Saizan set -o Saizan
13:00:50 <Duqicnk> atom: in Haskell String is just an alias for [Char]
13:00:58 <Duqicnk> i.e. it's a singly-linked list of chars, not an array of chars
13:01:06 <Saizan> atom: char arrays is more like what you get with Data.ByteString
13:01:33 <Duqicnk> so if you have some function getBits :: Char -> [Bit], then (concatMap getBits) :: String -> [Bit]
13:01:47 <atom> Duqicnk: yeah, I know... What I'd really like is to read files as bitstreams. I don't particularly care how I get there. Suggestions welcome.
13:01:58 <Marko> Isn't Data.Binary a good fit for interfacing with such type of C data?
13:02:14 <vishnooo> could someone point me a way to pass file handles in FFIs? (I have a c function that needs a FILE* as an input and I never encountered that...)
13:02:20 <atom> Duqicnk: well, that... would pretty much do it, yes :)
13:02:53 <atom> Duqicnk: the only other thing I need is tight packing, because I don't really want my data to inflate 8-times just because each bool is its own byte.
13:02:54 <codebliss> OH GOD...  bin/ghc_auto.o: In function `sqr_info': (.text+0x75c): undefined reference to `processzm1zi0zi1zi1_SystemziProcess_system_closure' bin/ghc_auto.o: In function `suu_info': (.text+0x99f): undefined reference to `__stginit_processzm1zi0zi1zi1_SystemziCmd_' bin/ghc_auto.o: In function `r9m_closure': (.data+0x1d0): undefined reference to `processzm1zi0z
13:03:01 <Saizan> atom: this looks like what you want http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html
13:03:28 <Duqicnk> vishnooo: if Haskell doesn't open its files through libc's stdio, i'm not sure that conversion is well-defined
13:03:40 <b_jonas> oh, I seeâ€¦
13:03:44 <Saizan> atom: there's a readFile there, and the interface is based on Word8, which you can bit-fiddle with the functions from Data.Bits
13:03:48 <b_jonas> now,
13:03:48 <vishnooo> arf..
13:04:05 <Duqicnk> i.e. i don't know if you can make a libc stdio FILE* from any OS-level filehandle, you could ask in ##c
13:04:06 <Saizan> codebliss: missed --make ?
13:04:08 <atom> Saizan: yup, that looks exactly the way I'd like it to.
13:04:14 <atom> Saizan: thanks a bunch
13:04:19 <Duqicnk> unfortunately the OS-level FHs will be os-specific
13:04:26 <Saizan> atom: np :)
13:04:36 <b_jonas> I have to read docs...
13:04:48 <codebliss> Saizan: I've always done that lol.        ghc x.hs -o x
13:05:16 <codebliss> Saizan: brb 1 sec, you got a min so I can pastebin the code and see what's wrong?
13:05:26 <vishnooo> Duqicnk: i though i heard people managed to do that somehow with bytestring (maybe I could do a wrapper on the C side?)
13:06:11 <Duqicnk> don't know
13:06:59 <Saizan> codebliss: ok, but that's a linker error, so unless --make fixed it you've some problem with the installed libraries
13:07:03 <vishnooo> anyway, thanks :-) I'll continue my googling...
13:07:28 <Saizan> ?hoogle handleToFd
13:07:28 <lambdabot> No results found
13:09:55 * Saizan was sure there was a way to get a Fd from an Handle
13:10:43 <Duqicnk> fd should be easier than a FILE*
13:11:21 <codebliss> What looks wrong here?  =O  http://haskell.pastebin.com/m6481f208
13:11:31 <codebliss> Weird link error on compilation
13:12:05 <EvilRanter> what error?
13:12:17 <codebliss> Never mind.  Got it
13:12:59 <EvilTerran> ah, that's better
13:20:30 <mun> does anyone know if the example code for a server in http://book.realworldhaskell.org/read/sockets-and-syslog.html is supposed to handle multiple messages, i.e. it waits for the next message?
13:21:31 <shapr> mun: The syslog server?
13:21:42 <shapr> mun: Which server?
13:24:09 <paxcoder> <paxcoder> Duqicnk: can you give example of how types are harder in haskell plz?
13:24:13 <paxcoder> *than C?
13:24:22 <Duqicnk> meaning, more expressive, and more work to make the compiler happy
13:24:25 <mun> shapr: yeah that's right. the tcp one.
13:24:38 <Duqicnk> an example would be, in Haskell you can express "this function always produces XML conforming to this specific schema" as a type
13:24:48 <Duqicnk> and the compiler will prove for you that your function produces XML of this form
13:24:58 <paxcoder> that's neat
13:25:23 <shapr> mun: If you're talking about ch27/syslogtcpserver.hs, it should loop until you press control-c
13:25:28 <Duqicnk> if you're writing a compiler, when you compile your compiler it will prove things like "no optimization pass produces syntactically invalid code"
13:25:39 <shapr> mun: I asumme you're running it inside ghci?
13:26:02 <Duqicnk> a type is a statement about a program, and typechecking is the compiler automatically proving these statements
13:26:13 <Duqicnk> unlike C you don't have to write the types out very much
13:26:22 <Duqicnk> but it's nice to do, because it serves as machine-checked documentation
13:26:25 <vixey> how do you do XML conforming to this specific schema
13:26:35 <Marko> mun: at first glance i'd say it closes the connection after reading the message (but loops, so you can reconnect and send another one)
13:26:57 <Duqicnk> in the cases where you do have to write them out, you're basically telling the compiler "try proving this lemma first" or more often "don't try proving the big general statement, i only meant this more specific one"
13:27:09 <dons> shapr: btw, did you see I put up Peng Li's tcp stack on hackage?
13:27:15 <shapr> No, I didn't see that!
13:27:23 <dons> reminds me of that work you were doing on qc for house's network stack
13:27:31 <edwardk> heya shapr
13:27:32 <Duqicnk> paxcoder: the type system also keeps track of things like which functions can affect the outside world, which ones have mutable state and how these domains of mutable state interact
13:27:33 <jfredett> shapr: is there gonna be another bahug soon?
13:27:45 <Duqicnk> vixey: i forgot the name of the project.  basically it would turn a schema into an algebraic type
13:27:53 <Duqicnk> which you can sort of see how it would be possible
13:28:00 <MTK> Is it ok to copy/past lines to the channel?
13:28:00 <edwardk> jfredett: shapr is mutinying about organizing this whole affair
13:28:04 <MTK> paste
13:28:15 <paxcoder> Duqicnk: mutable state?
13:28:15 <edwardk> jfredett: mostly because he is a total spaz case about this mcmasters thing ;)
13:28:17 <jfredett> edwardk: we'll have to get him back into line... :P
13:28:21 <Duqicnk> paxcoder: assignment to variables
13:28:25 <jfredett> lol
13:28:29 <jfredett> mcmasters? what?
13:28:31 <dons> ?paste <- MTK
13:28:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:28:32 <jfredett> I'm confused....
13:28:33 <jmcarthur> with the right extensions, haskell's type system is powerful enough to encode some pretty amazing properties. unfortunately, things can get pretty ugly
13:28:35 <shapr> :-P
13:28:39 <shapr> hiya edwardk
13:28:46 <edwardk> me's trying to see if he can get a mcmasters degree.
13:28:50 <shapr> hah
13:28:54 <edwardk> hrmm, maybe we should move this to -blah
13:29:08 <jfredett> edwardk: hehe, I'm just curious, my summer jobs fell through, so I was looking for something to look forward to. :P
13:29:32 <edwardk> jfredett: i want one!
13:29:55 <edwardk> shapr just doesn't realize how cool they are because he didnt get to show up at the last one
13:29:55 <jfredett> edwardk: Summer job? Me too. :P
13:29:58 <shapr> dons: Is Peng Li's stack based on hOp/House?
13:30:07 <edwardk> i think its a of sour grapes
13:30:10 <vixey> jmcarthur: do you have any examples
13:30:12 <jfredett> hehe
13:30:25 <edwardk> i accidentally the whole sentence
13:30:35 <jfredett> edwardk: lol.
13:30:41 <vixey> @farmer
13:30:41 <lambdabot> I'm mad enough to fry a wet hen.
13:30:45 <vixey> ^^^ me too!
13:30:57 <jmcarthur> http://www.reddit.com/r/programming/comments/8a79o/modern_static_typing_less_code_better_code_or_how/c08p034
13:31:01 <jmcarthur> ^^ for vixey
13:31:17 <jmcarthur> although this won't be very amazing to you, vixey
13:31:34 <Heffalump> is there a public GHC branch for DPH?
13:32:07 <jfredett> @farmer -- awesome....
13:32:08 <lambdabot> We're teetering on the edge of the brink.
13:34:23 <MTK> I just put in the pastebin what I have to do... I just need some hints on how to best do it
13:35:00 <vixey> you cshoul link to it
13:35:00 <dons> shapr: no, it's a translation of Norrish's HOL4 spec of TCP
13:35:30 <MTK> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3515
13:35:59 <vixey> MTK: why don't you just use sed
13:36:28 <mib_6m2dqg7b> http://www.mibbit.com/pb/8M11rd
13:36:43 <mib_6m2dqg7b> Oops, please ignore
13:37:42 <MTK> vixey: it's an assignment...  I've been trying to figure it out for a few days.  I'm decent at C and Java but can't wrap my head around Haskell
13:38:29 <mib_6m2dqg7b> Question: I'm learning Haskell, and it does seem difficult to do "stateful" things. I would like opinions---are there applications for which you feel Haskell is just not appropriate and you use something else  (maybe OO/scripting like Python)? Or do you feel that once Monads etc. are mastered, Haskell is still the best choice for most tasks?
13:39:01 <vixey> mib_234nthoaeug: it's not difficult
13:39:06 <Heffalump> mib_6m2dqg7b: the biggest reason that makes it unsuitable for some tasks is the lack of libraries for those areas
13:39:07 <jmcarthur> mib_6m2dqg7b, my personal opinion is that haskell is suitable for most tasks, even highly stateful ones
13:39:31 <b_jonas> you know what sucks in writing this ghci hack?
13:39:32 <jmcarthur> Heffalump, fortunately the ffi is extremely easy to use
13:39:55 <b_jonas> haskell is so statically compiled that if I write a code that compiles then it likely works as well
13:40:04 <b_jonas> (unless I make an infinite loop)
13:40:07 <MTK> I regret taking BCS.. should have went into Business or something
13:40:15 <vixey> lol
13:40:18 <b_jonas> but here with ghci there's so much interpretted action that it's not like that at all
13:40:29 <vixey> MTK: Iyou aren't the only one
13:42:07 <Saizan> MTK: have you worked with lists in haskell before?
13:42:20 <MTK> Salzan: just very basic ones
13:42:29 <MTK> lists of integers, stuff like that
13:43:42 <Saizan> well Content is a bit different, since it has multiple contructors, but the basics are the same
13:43:51 <Saizan> MTK: are you stuck on something in particular?
13:44:56 <Saizan> the functions in Text.XML.Light.Proc looks quite handy to manipulate the whole list, anyway
13:48:27 <b_jonas> oh no, I've hit a problem
13:48:40 <b_jonas> if ghci fails loading a module, it stops loading the others
13:48:46 <b_jonas> even though there's no dependency between them
13:48:50 <b_jonas> each are loaded with :add
13:48:55 <MTK> Say I want to go through the list and everywhere where qName = "listitem" I want to append some to the start of cdData = "It was slow"
13:49:06 <MTK> some - something
13:50:57 <MTK> I mean everywhere where qName - "listitem" I want to change what is in cdData.. I know to use map, just not sure exactly how to do it
13:54:05 <b_jonas> in fact it seems that even if a module is unchanged, it's unloaded if there's an error loading another module
13:54:24 <b_jonas> how do I avoid this and keep the module loaded?
13:54:35 <b_jonas> must I make a package of it or something?
14:00:53 <Saizan> MTK: something like map (\x -> case x of Elem e | qName (elName e) == "listitem" -> Text (blank_cdata { cdData = ... }))
14:00:59 <Saizan> ops
14:01:07 <Saizan> MTK: something like map (\x -> case x of Elem e | qName (elName e) == "listitem" -> Text (blank_cdata { cdData = ... }); _ -> x)
14:01:32 <MTK> Thanks
14:11:05 <u_quark> I am compiling an example from HsOpenSSL and I get Module `OpenSSL.RSA' does not export `generateRSAKey'' witch is odd ... because OpenSSL.RSA' *does* export generateRSAKey'
14:11:56 <u_quark> I am using ghc 6.8.3 if thats an issue...
14:15:37 <johh> i have a list of primefactors of a number. How can I get the count of all divisors of that number easy?
14:16:17 <vixey> johh: like [2,2,3] -> [(2,2),(3,1)] ?
14:16:19 <tromp_> product . (map succ)
14:16:32 <aconbere> I'm interested in functional reactive programming, and I'm noticing that there appear to be a few differnt implimentations in haskell, does anyone know what is the prefered tools these days?
14:16:37 <tromp_> oops
14:16:59 <tromp_> are they grouped alrd?
14:17:09 <johh> nop
14:17:33 <johh> the problem is that some prime factors are occouring many times
14:17:39 <vixey> johh: like what then ?
14:17:59 <tromp_> > product . (map (succ . length)) . group . sort
14:18:00 <lambdabot>       Overlapping instances for Show ([a] -> Int)
14:18:00 <lambdabot>        arising from a use o...
14:18:12 <tromp_> > product . (map (succ . length)) . group . sort $ [2,5,3,2,3]
14:18:14 <lambdabot>   18
14:18:15 <johh> [2,2,3]-> [1,2,4,6,12]
14:18:16 <jedai> aconbere: Reactive seems to be the more recent approach, but Yampa with arrows is also interesting
14:18:33 <vixey> johh: in that case I think you should start by writing the first function I said
14:18:51 <vixey> johh: it's easy from that to produce this list [1,2,4,6,12]
14:19:02 <tromp_> 180 has 18 factors
14:19:20 <johh> thanks
14:19:37 <b_jonas> Why wouldn't this work?
14:19:45 <b_jonas> argh
14:20:14 <aconbere> jedai: yep, those are the two that I keep seeing come up
14:23:02 <b_jonas> hee hee
14:23:19 <b_jonas> I think I found an arguable bug in ghci
14:23:42 <b_jonas> well, not really a bug
14:23:46 <b_jonas> but what could be improved
14:24:05 <u_quark> I dont get it... it was renamed in generateKey from generateRSAKey ... why is that ????
14:24:08 <b_jonas> when I load a module, change it, then load it again within one second, the timestamp is the same so it won't read it again
14:24:28 <b_jonas> how can I force it to read the file again?
14:24:30 <EvilTerran> b_jonas, yay edge cases
14:24:46 <jedai> b_jonas: :reload
14:24:51 <EvilTerran> or just :r
14:24:56 <b_jonas> jedai: no, :reload doesn't help I think
14:24:59 <b_jonas> let me try again
14:25:39 <jedai> Well  it should !
14:25:42 <b_jonas> yep, if I :reload, it says it's compiling it, but it still gives the error for the old version
14:26:05 <b_jonas> so I guess it caches the source itself in memory, but recompiles or something
14:26:09 <b_jonas> this seems stupid
14:26:37 <jedai> u_quark: Probably because the module itself already say RSA
14:27:05 <u_quark> jedai: what do you mean ?
14:28:10 <b_jonas> hmm
14:28:20 <b_jonas> it seems there might be something _worse_ happening here than what I imagined
14:28:57 <jedai> u_quark: The idea is that the RSA in generateRSAKey was redondant, so they renamed the function to get rid of it, no ?
14:30:07 <u_quark> jedai: in the source files that I compiled the function exported is named generateRSAKey
14:30:31 <b_jonas> I don't get this...
14:31:03 <johh> tromp_ your code is exactly what I needed, but it produces 1 to much
14:31:22 <b_jonas> so do you know an easy way to force ghci to reload the module?
14:31:26 <jedai> u_quark: No :) I don't think that's the case. Probably outdated doc, or you compiled another more recent version or.. but there's no magical renaming of functions in Haskell
14:31:37 <b_jonas> (or the problem might be something else)
14:31:49 <gwern> @seen ndm
14:31:49 <lambdabot> I haven't seen ndm.
14:31:51 <tromp_> johh, can u give example?
14:32:23 <gwern> @ask ndm so I was reading your supero paper and you mentioned ghc's isSpace function had a performance bug. was that ever fixed?
14:32:23 <lambdabot> Consider it noted.
14:32:29 <johh> > product . (map (succ . length)) . group . sort $ [2,2,3]
14:32:30 <lambdabot>   6
14:32:32 <tromp_> eg. the number 2 has 2 divisors, 1 and 2
14:32:49 <tromp_> the number 12 has 6
14:32:54 <tromp_> including 1 and 12
14:33:02 <johh> 12 has 1,2,4,6 and 12
14:33:10 <tromp_> and 3
14:33:13 <johh> ah
14:33:14 <johh> oh
14:33:16 <johh> sorry
14:34:05 <u_quark> jedai: you are right ... older version tnx
14:34:25 <jedai> johh: You probably don't need sort there : generally when a function give the prime factors of a number they are already ordered
14:34:39 <tromp_> he said they are not in his case
14:34:41 <johh> no they aren't ordered
14:34:42 <b_jonas> ok, well,
14:34:49 <b_jonas> try this: http://erxz.com/pb/16908
14:35:02 <jedai> johh: And how the hell did you generate them ?
14:35:10 <b_jonas> it attempts to detect failed compilations and revert the change when it detects one
14:35:17 <b_jonas> then try it without the threadDelay statement
14:35:21 <b_jonas> and tell me what you think
14:35:35 <johh> (n) * (n1) / 2
14:35:35 <b_jonas> my guess is that it's a file timestamp precision thing but I'm not completely sure
14:35:55 <johh> s/n1/ n -1 /
14:36:07 <b_jonas> it's still my attempt on that module that allows top-level declarations in ghci
14:36:21 <b_jonas> it's not finished but I'm not sure what to do with this bug now
14:36:25 <rabideejit> b_jonas: that's really cool
14:36:46 <b_jonas> so I'll just go to bed now and try to think about this bug later
14:36:53 <b_jonas> and hope you solve it meanwhile
14:38:50 <rabideejit> hmm.  I've always been annoyed by not being able to define data types in ghci.
14:40:30 <rabideejit> I had an interesting haskelling experience earlier.  My program was too big in memory,  so I ran the profiler and saw it was in the function that that read bytestrings from a handle, and then split it by new
14:40:33 <rabideejit> lines.
14:40:55 <rabideejit> so I rewrote the network system in c
14:41:35 <rabideejit> and I made two interesting observations - firstly that it was much faster in c.  Secondly, that the process used 10mb more memory than before.
14:42:14 <rabideejit> Your opinions: Would you say that was an issue of strictness versus laziness?
14:43:20 <jedai> rabideejit: I think you could probably make it as fast in Haskell, IO code with bytestring can often be made as fast as C :)
14:44:00 <Gracenotes> well. there are always other bottlenecks, not to mention
14:44:46 <jedai> rabideejit: and it's very possible that the excess memory in C was due to strictness but without the specifics it's hard to tell
14:46:11 <duckinator> hi
14:46:56 <rabideejit> Hello.
14:47:10 <duckinator> whats up, rabideejit?
14:47:56 <rabideejit> Drooling at the mouth and biting people's ankles.  I made some food that was waaay too salty too, but I guess that's kinda off-topix.
14:49:40 <rabideejit> What's up with you?
14:49:41 <rabideejit> See, the C didn't leak, and ran in a very tiny process when I tested it using some more c, but when it talked to haskell, the whole thing got really big.
14:50:10 <rabideejit> I also used the unsafePack functions to talk to the ffi code, which are O(1)
14:52:32 <rabideejit> But really what my point is,  if one wants to write fast code in haskell, it's perhaps better to do it in haskell.  A lesson I have learned and gruntled am I.  But maybe you can help me
14:53:04 <clanehin> I thing remember on the mailing list was researching a typesafe way to hold and release mutexes, but I can't remember the terminology used to google it.
14:53:30 <clanehin> wow, "I think I remember someone on . . ."
14:55:05 <rabideejit> I'm sorry, I haven't heard.  google should publish a library.  That's the rummy thing about google: you should be able to search within categories of relevant data ( but perhaps that's a bit of a hard ai problem )
14:56:22 <rabideejit> Basically I have some commands coming in from a socket,  and they are seperated by a line feed.  Splitting these using bytestring "split" is O(n) and burns a lot of memory in this function.  Can you think of a smaller way of doing it?  ( I really don't care about speed, only memory )
14:57:29 <Eridius> bytestring split burns memory?
14:58:26 <dons> hmm?
14:58:33 <TomMD> @seen dcoutts
14:58:33 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #darcs, #haskell, #ghc and #haskell-overflow 2m 15d 16h 28m 52s ago, and .
14:58:38 <TomMD> That is a lie
14:58:44 <rabideejit> wait, I thought it was the split:  I'll go make sure!
15:01:15 <rabideejit> To be fair, it doesn't get too big: the program is about 60mb in ram, I need it to be about 40mb so it can run on my server.
15:02:07 <dons> TomMD: he's in morocco
15:02:14 <TomMD> That explains things
15:02:40 <TomMD> dons: I've made some minor progress on hackage-server but don't want to go too far and find out dcoutts had a different idea.
15:03:37 <TomMD> dons: At any rate, things seem to work OK, just some sub-systems and prettying is needed (user htpasswd changes, haddock building, build reports)
15:04:03 <Saizan> TomMD: cool! do you have a repo up somewhere?
15:04:18 <dons> he'll be back online towards end of next week.
15:04:36 <TomMD> dons: I'll just push forward and hope then.
15:04:45 <TomMD> Saizan: Nope, I desire to push straight to dcoutts repo.
15:05:11 <clanehin> rabideejit: ghc supports memory profiling
15:05:21 <TomMD> saizan: I could put one up on my c.h.o/~tommd/ site, but don't want people to regard it as a fork or alternative to the main one.
15:06:34 <bavardage> hmm parallelising quicksort doesn't seem to do much :D
15:07:02 <Saizan> TomMD: it'd be just to show what you've got until dcoutts returns, but i'm mostly just curious so it's not that important :)
15:07:11 <rabideejit> clanehin:  I know: that's where I've been getting this info from.  I'm pretty sure it's the split that causes most of the memory allocation in my program, but it does a couple of thing which I thought were evaluated later, but I'm going to strip it down and make sure it's positively the split before I go asking more questions :)
15:07:23 <TomMD> Saizan: I'll let you know if I put one up.
15:08:56 <Saizan> TomMD: k, thanks
15:28:59 <stulli> Can GHCi somehow accept unicode characters as input?
15:29:28 <stulli> I defined (€) just for fun and it loaded, but i couldnt type it in GHCi...
15:29:31 <pumpkin> sure, it lready does
15:29:55 <Saizan> on 6.10.1 it doesn't work because of editline, i think
15:30:21 <Saizan> try with ghci-haskeline, from hackage
15:30:29 <stulli> Hm, i installed 6.10.2 today and it still doesnt work
15:30:40 <stulli> Thanks, i will try that
15:31:11 <Saizan> .2 has the same problem, yeah
15:31:11 <pumpkin> > let ä½• = "wut?" in ä½•
15:31:12 <lambdabot>   <no location info>: lexical error at character '\20309'
15:31:16 <pumpkin> boo
15:31:45 <Saizan> , let ä½• = "wut?" in ä½•
15:31:48 <lunabot>  "wut?"
15:32:08 <pumpkin> ah, so it's just lambdabot failing
15:32:15 <Saizan> , [$ty| let ä½• = "wut?" in ä½• |]
15:32:20 <lunabot>  [] Char
15:32:22 <gwern> > 44 * 0.07
15:32:23 <lambdabot>   3.08
15:32:26 <mib_6m2dqg7b> test
15:33:19 <MTK> Saizan: I tried that code you posted earlier but I can't seem to get it to work
15:33:37 <stulli> Saizan, your solution worked, thanks
15:34:23 <ddarius> let å£ = Box
15:34:50 <Saizan> MTK: does it compile?
15:35:14 <MTK> No, gives the following:
15:35:51 <duaneb> how can I print a [[Integer]]?
15:35:56 <MTK> Couldn't match expected type '[Content]'
15:36:17 <MTK> against inferred type `String -> [Content]'
15:36:22 <Axman6> duaneb: print listOfListOfIntegers
15:36:49 <MTK> In the second argument of `map', namely `parseXML'
15:37:02 <duaneb> really?
15:37:03 <duaneb> :|
15:37:45 <Axman6> sure
15:37:49 <Saizan> MTK: can you paste the code? maybe it's a problem of misplaced parentheses
15:39:06 <skorpan> suppose i make a datatype and define (>>=), return, etc for it, all following the monad laws, but not as an instance of Monad.  is it still a monad?  *gets popcorn*
15:40:13 <Axman6> no!
15:40:26 <jedai> skorpan: Yes it is
15:40:53 <Axman6> that's like asking, if a tree falls in the forrest and there's no ground or anything for it to hit, is it still a tree!
15:40:57 <jedai> skorpan: except that you'll have plenty of name conflict and you won't be able to use the do-notation
15:41:02 <MTK> ok
15:41:27 <jedai> Axman6: Well it's not a Monad but it's still a monad
15:42:28 <halberd> if it looks like a duck and walks like a duck and quacks like a duck, it is a duck
15:42:51 <Axman6> or a furry
15:43:05 <halberd> that would be feathery
15:43:22 <evident> hellp
15:43:26 <evident> hello
15:43:33 <Axman6> if you call 'em that, they feel discriminated against
15:43:57 <skorpan> i didn't know duck typing (typeclassing) was available in haskell...
15:43:58 <pumpkin> moo
15:44:42 <pumpkin> step 1: cut a hole in the å£
15:44:46 <MTK> Saizan: it's pasted.. I know my function is supposed to return a string but I'm just trying to get the map working first
15:45:26 <Axman6> MTK: want to give the url perhaps? :\
15:45:32 <MTK> oops
15:45:41 <MTK> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3520#a3520
15:45:44 <dayzman> hi
15:45:55 <pumpkin> dayzman: hi!
15:45:56 <jedai> skorpan: It isn't. Anyway a monad is a mathematical concept and if you define a datatype, a "return" and a "bind" that respects the monad laws, the triplet is a monad, even if you don't write the Monad instance
15:46:51 <skorpan> jedai: but the mathematical concept has little to do with the actual typeclass as i understood it?
15:46:55 <Saizan> MTK: you should compose the map (..) and parseXml, not apply the first to the latter
15:47:13 <Saizan> MTK: also, the return type of the composition won't be String
15:48:23 <jedai> skorpan: What are you talking about ? The typeclass and the mathematical concept are very much linked. The only difference being that the typeclass won't automatically check if the monad laws are respected by an instance
15:49:02 <skorpan> jedai: chill out man, i'm not dead-serious...
15:50:37 <dayzman> does anyone know if the TCP syslog server shown in http://book.realworldhaskell.org/read/sockets-and-syslog.html can handle multiple messages, i.e. one message after another?
15:50:58 <jedai> MTK: also you should write a local function rather than a lambda, it's pretty ugly :)
15:51:13 <wli> I'm still dead in the water with Chakravarty's typeclass vs. module paper.
15:51:43 <wli> Rather, typeclass-capable module system paper.
15:52:49 <dolio> Does that one use modules to implement type classes?
15:53:04 <dolio> That seems like the easier way to combine them.
15:53:23 <wli> Yeah, that's the one.
15:56:10 <dolio> One of the difficulties of combining them is that when you make modules fancier, you have to decide where exactly type classes are in scope and whatnot. If type classes are sugar for fancy modules that can contain other modules, you've already figured that out.
15:56:24 <tieTYT> in all the examples I see poorly named parameters like, "x" and "xs".  Are these variables usually named better in real systems?
15:56:26 <dolio> Then you just have to figure out how to automatically fill things in for ease of use.
15:57:11 <wli> I have substantial trouble figuring out the type system -based descriptions of module systems and so on.
15:57:38 <wli> I can only get a grip on the simplest instances of them.
15:58:00 <halberd> tieTYT: typically xs means a list
15:58:14 <tieTYT> yeah maybe those are bad examples
15:58:19 <tieTYT> similar to an "i" in a forloop
15:58:20 <jedai> tieTYT: Those aren't poorly named parameters
15:58:27 <tieTYT> but then in lambda expressions, I see x y z
15:58:30 <tieTYT> and a b c in other places
15:58:35 <tieTYT> which I do consider poorly named
15:58:46 <inimino> why?
15:58:59 <jedai> tieTYT: it's just that they are so general that giving them a meaningful name isn't really possible
15:59:01 <tieTYT> because when I learn I have to do translations in my head of what they actually represent
15:59:16 <tieTYT> that's exactly what I do in any other language when something could be named better
15:59:33 <halberd> I use variables like x y z when their scope is limited
15:59:33 <tieTYT> this would be better with an example
15:59:44 <tieTYT> i'll see if i can find one
15:59:57 <halberd> if the scope is reasonably small and they aren't used in any complicated way then a descriptive name would be unnecessary
16:00:08 <halberd> in that case you can figure out what they mean more easily by just reading how they are used
16:00:27 <vixey> actually i is descriptive
16:00:36 <tieTYT> vixey: I agree
16:00:41 <tieTYT> if it's used consistently to mean one thing
16:00:42 <vixey> x y z are axis, i j k are loops or axis.. f g h are functions
16:00:44 <tieTYT> and because of tradition
16:00:50 <vixey> there are these connotations which do help
16:00:54 <tieTYT> yep, i agree with all of those
16:01:08 <dolio> k can be a continuation, too.
16:01:11 <tieTYT> but, i remember seeing a function where it was recursive inside of it's lambda
16:01:26 <halberd> I usually use x y z as "dummy" variables of limited scope
16:01:42 <tieTYT> and it was really hard for me to figure out
16:03:21 <wli> dolio: The things are just relatively innately complicated because there are 2 layers of language etc. involved.
16:04:33 * Axman6 would also put i, j and k into the vector bucket
16:04:34 <tieTYT> I found one here: http://book.realworldhaskell.org/read/functional-programming.html
16:04:45 <tieTYT> the function splitLines near the top
16:04:54 <tieTYT> i think pre/suf would be slightly better named as prefix and suffix
16:05:00 <tieTYT> if that's what they represent (they probably do)
16:05:51 <tieTYT> also, why "cs" there?  Why not "xs"?
16:06:07 <halberd> cs means characters
16:06:12 <tieTYT> ah
16:06:13 <halberd> list of chars
16:06:13 <jedai> tieTYT: because it's a list of characters
16:06:27 <halberd> I think that's descriptive enough
16:06:51 <halberd> the meaning would be clear even with x and y, so long as you know what break does
16:07:39 <jedai> tieTYT: frankly I prefer pre/suf to prefix/suffix, they're clear enough, especially since they're directly the results of a break and that keep the function concise
16:08:25 <tieTYT> jedai: I'd prefer to not waste that second wondering if this stands for "prefix" and "suffix"
16:08:48 <jedai> Sure they're a balance to keep and Haskell programmers often err to the too short names, but the alternative is no better for me
16:09:09 <Zao> (xs':xs's)
16:09:27 <wli> I use pfx and sfx.
16:09:34 <jedai> tieTYT: Do you really waste a second wondering that ? Even if it was called prefix suffix it wouldn't be very informative
16:09:38 <edwardk> wli: and there lies the problem with abbreviations ;)
16:09:45 <tieTYT> jedai: yes I do
16:09:56 <tieTYT> and unless it's a convention, I think everyone else would too
16:10:17 <edwardk> u hv 2 rmbr wt ppl abbrv'd to wn u go 2 call thm ;)
16:10:32 <jedai> tieTYT: the real information is in the break isLineTerminator and coupled with that nobody could really wonder if pre/suf are anything else than prefix/suffix (and I'm no native speaker)
16:11:18 <tieTYT> jedai: and is your attitude the same if this was procedural code or OO code?
16:12:14 <jedai> tieTYT: Maybe, but in procedural or OO, there's a chance the definition/declaration wouldn't make as clear as here what the variable are
16:12:18 <Saizan> i kind of hate abbreviations in function names, but variables don't need to convey much meaning by themselves, and long names can really obfuscate
16:13:10 <tieTYT> Saizan: although I think you should prefer concise names to long ones, I think it's worse to abbreviate
16:13:16 <jedai> Saizan: Right, if something must be long I prefer it be the functions name (though not too long please, we're not in Java)
16:13:28 <halberd> you only need long/descriptive names if there is a large scope
16:13:34 <inimino> Haskell seems to make it much easier to determine variables' purpose by examination
16:13:39 <tieTYT> halberd: based on what?
16:13:40 <halberd> like global variables and functions should have long names
16:13:48 <halberd> local variables should have shorter names
16:13:50 <tieTYT> halberd: why do you draw that line?
16:14:17 <wli> name clashes
16:14:23 <halberd> if the scope of a variable is large, you can forget what it means when you refer to it later
16:14:25 <inimino> short functions and immutability probably have something to do with it
16:14:43 <vixey> there isn't global and local
16:14:47 <jedai> tieTYT: local variables are defined and used very closely, global variables or functions may be used far from their definition
16:14:48 <halberd> so you should have a descriptive name to prevent that
16:14:59 <tieTYT> halberd: you can do that when it's short too
16:15:17 <tieTYT> halberd: either way, you have to see how it's used to figure out what it represents if you name things "foo", no?
16:15:20 <halberd> if the scope is local and small, you aren't going to forget what it means
16:15:29 <inimino> if you can see the entire scope of a variable in a few lines there's no need for it to be more than one character long
16:15:29 <halberd> if it's only used a handful of times, all in the same small place
16:15:30 <tieTYT> the fact that it takes less time if the scope is small does not change that, it just changes the effort
16:16:01 <tieTYT> there is a reason, because it takes more time to decypher the meaning
16:16:09 <halberd> also if the scope is small the variable doesn't have a complicated definition
16:16:09 <tieTYT> you write it once (or a few times), you read it lots of times
16:16:12 <Saizan> tieTYT: it changes the tradeoff between descriptiveness and verbosity
16:16:12 <tieTYT> make it convenient to read
16:16:37 <Saizan> verbosity harms readability too
16:16:41 <halberd> if the variable has a short definition, then reading the definition is easier than trying to guess what it means from the name
16:17:00 <tieTYT> Saizan: certain kinds
16:17:03 <tieTYT> this is not one of them
16:17:12 <tieTYT> if this function was 3x longer, yes
16:17:23 <tieTYT> if the names of the variables were 3x more descriptive, the opposite is true, IMO
16:17:54 <tieTYT> halberd: if you have to guess what it means by the name, you used a bad name
16:18:00 <Saizan> i guess it's a matter of taste there
16:18:06 <halberd> no
16:18:14 <tieTYT> halberd: yes, that's by definition
16:18:21 <halberd> whenever you try to determine the meaning of a variable solely from a descriptive name , you're guessing
16:18:23 <Saizan> i'd use (as,bs) rather than (pre,suf) actually
16:18:31 <tieTYT> halberd: fooBarBazHelper doesn't help me
16:18:58 <halberd> even if the name is something like connectionHandler, it still doesn't tell you exactly what it does
16:19:10 <tieTYT> halberd: it handles connections?
16:19:31 <tieTYT> usually when you use the word "handle" in your variable/class, you've picked a bad name though
16:19:33 <halberd> yeah, somehow, but for what it actually technically does you need to refer to its type and source code
16:19:40 <halberd> and documentation if there is some
16:20:30 <tieTYT> halberd: what's the relevance here?
16:21:13 <jedai> tieTYT: he is saying that even a good name doesn't provide as much information as a good declaration
16:21:13 <tieTYT> btw, consider the readability improvement of connectionHandler.connect(); vs x.connect();
16:21:29 <Saizan> tieTYT: the relevance is that names can't give you so much information if you don't want to write poems, so if that exact information is available nearby a very descriptive name loses a lot of importance
16:21:41 <tieTYT> jedai: he didn't say that at all.  He's talking about if you need to check the implementation of what the type does
16:22:12 <Saizan> and other factors like conciseness prevail
16:22:15 <halberd> no, that's more or less what I was getting at
16:22:18 <inimino> the relevance is that if you know what getConnectionHandler does and you see "ch â† getConnectionHandler", you know /exactly/ what ch is, you're not forced to guess if "connectionHandler" means what you think it does
16:22:24 <Saizan> obviously where to draw that line is subjective
16:22:30 <jedai> tieTYT: You're just not following the flow of the argument... Saizan said it well
16:22:47 <tieTYT> halberd: you may have been tryign to say that, but the only reason you care about what a connectionHandler does internally is if you're checking it's implementation
16:23:06 <tieTYT> in which case, it's not necessarily the fault of the name that you went into the implementation
16:23:40 <tieTYT> jedai: a lot of people are responding to me at once :)
16:23:52 <tieTYT> Saizan: while I agree with you, it still helps
16:24:04 <tieTYT> i'm not saying, "a poorly named global is just as bad as a poorly named local"
16:24:09 <tieTYT> I'm saying, "name them both well"
16:24:28 <inimino> what everybody is telling you is that local names have different criteria for good naming
16:24:34 <pumpkin> sometimes a long name obscures the "shape" of a function
16:26:25 <tieTYT> inimino: I've noticed
16:26:48 <tieTYT> pumpkin: perhaps, I'm not even a novice in haskell so I can't speak of that
16:27:07 <tieTYT> but it certainly doesn't in a java method
16:27:13 <MTK> I looked in Real World Haskell and on another website and I still don't understand how compose works
16:27:30 <pumpkin> that is, using something like currentObj:restOfList might look attractive, but then you litter the rest of your function with long names and it's harder to tell what functions are operating on what
16:27:35 <Saizan> java code has a quite different structure
16:27:37 <SamB> MTK: have you tried asking your algebra teacher ?
16:27:47 <tieTYT> pumpkin: yes so why wouldn't you use x:xs there?
16:27:52 <pumpkin> we would
16:28:01 <tieTYT> pumpkin: as I said, x:xs is a convention and i've got no complaint against that
16:28:11 <MTK> SamB: I haven't taken algebra in about 10 years
16:28:12 <pumpkin> ah, I missed the earlier discussion
16:28:21 <SamB> MTK: calculus?
16:28:27 <MTK> 9
16:28:31 <Saizan> ?src (.)
16:28:31 <lambdabot> (f . g) x = f (g x)
16:28:36 <SamB> do you remember any of it?
16:28:44 <tieTYT> yeah just like "i" in an OO for loop, it has a meaning that everyone reading the code should innately understand (if they understand their language)
16:28:45 <MTK> probably in nightmares
16:28:46 <pumpkin> tieTYT: but in general, having a long descriptive name inside a function might detract from seeing the chain of composition or whatever
16:28:53 <SamB> MTK: what the heck!
16:29:19 <pumpkin> people are way too complacent about not knowing math
16:29:21 <inimino> http://en.wikipedia.org/wiki/Function_composition (might be a little dense)
16:29:45 <jedai> tieTYT: Java has the inverse excess frankly... The only thing that make writing Java code ok is the good IDE with completion
16:30:17 <inimino> and for reading it there is no help :)
16:30:21 <SamB> MTK: I'm going to suggest trying again ;-)
16:30:23 <tieTYT> jedai: what's the inverse excess mean?
16:30:33 <halberd> names are too long
16:30:37 <SamB> perhaps if you took it at a community college, they'd have a teacher who could actually teach?
16:31:00 <jedai> tieTYT: Java naming convention are way too verbose...
16:31:07 <tieTYT> i disagree
16:31:23 <MTK> SamB: it's for a 4th year CS course
16:31:26 <tieTYT> they're descriptive, IMO
16:31:43 <pumpkin> MTK: you're in fourth year CS and you don't do math? :o
16:31:48 <tieTYT> i have a feeling if I learned haskell, I'd understand that i'm having this discussion with you in a different context
16:31:53 <SamB> MTK: no excuses!
16:31:58 <tieTYT> jedai: needing an IDE though, I agree
16:32:00 <MTK> I went back to university last year... after being away for a very long time.  I can't afford to start from the beginning and I do well in the vast majority of the courses
16:32:13 <SamB> (evidently some places they think CS is an excuse not to understand calculus?)
16:32:35 <Saterus> where is calculus not a first year course?
16:32:50 <inimino> MTK: the harsh truth is that without knowing algebra you should not be allowed to graduate from any CS program worthy of the name
16:32:52 <MTK> I took all my math courses in the first two years of my degree... actually 7 math courses and 3 stats
16:32:53 <tieTYT> jedai: shorter names help you write quicker
16:33:05 <tieTYT> you should put your effort in making things easier to read quicker
16:33:09 <SamB> MTK: community college is usually relatively inexpensive
16:33:15 <vixey> the harsh truth is that you CAN graduate a CS course without knowing math or cs
16:33:18 <jedai> tieTYT: Yes they are, and sometimes they're so long that they obscure the sense of the function, spreading it over too much space
16:33:24 <SamB> and the calc/nightmare association is probably a bad thing
16:33:25 <MTK> SamB: I graduate this year though...
16:33:36 <inimino> vixey: the harsh truth is that many CS programs aren't worthy of the name
16:33:38 <tieTYT> jedai: in which case you extract another function out of it to make it more concise
16:33:45 <pumpkin> inimino: indeed
16:33:47 <tieTYT> jedai: or, you've got a poorly named variable
16:33:53 <edwardk> vixey: its sad but true
16:33:55 <SamB> see, this is why I'm majoring in EE
16:34:06 <MTK> I was in EE
16:34:08 <pumpkin> edwardk: are bimorphisms common?
16:34:11 <ddarius> Can't get away from calculus in EE
16:34:13 <tieTYT> just cause a name is long doesn't mean it's bad.  just because it's concise doesn't mean it's good
16:34:15 <edwardk> vixey: whats worse is i've seen math majors do it
16:34:23 <jedai> tieTYT: Sure.
16:34:32 <SamB> edwardk: okay, now THAT is BAD
16:34:38 <inimino> tieTYT: most people here (I would guess) find short names more convenient
16:34:45 <Saizan> tieTYT: really, in haskell at least, i've found functions that were hard to read because the variable names were too long, and were crystal clear once i've "cleaned" them
16:34:47 <tieTYT> inimino: i'd guess that too
16:35:02 <pumpkin> another example of that is ghc core
16:35:03 <MTK> My problem is that the stuff comes back to me but I don't have the luxury of the time needed to refresh everything
16:35:13 <Gracenotes> more general naming conventions are also a good idea
16:35:15 <edwardk> samb: they usually skirt by by calling it a 'math education' degree, which is in many ways in my eyes a greater sin
16:35:17 <inimino> tieTYT: I think it has to do with the way people mentally read Haskell, which is something you have to experience yourself
16:35:17 <pumpkin> it typically spits out a haskell-like language called core, that contains fully qualified names
16:35:22 <Gracenotes> for example, underscores.. no like so much.
16:35:31 <pumpkin> but if I strip out all the explicit modules, it becomes quite readable
16:35:33 <edwardk> pumpkin: er yeah because every isomorphism is a 'split bimorphism' ;)
16:35:34 <SamB> edwardk: they shouldn't have those "education" degrees ...
16:35:36 <tieTYT> Saizan: so all you did was change the variable names to x and y and then you immediately understood what the function did without any more work?
16:35:46 <tieTYT> Saizan: or did you have to see what was being done inside the function next?
16:36:04 <pumpkin> edwardk: that's what I was wondering :P a monomorphism that's an epimorphism is supposedly a bimorphism but the wikipedia page didn't say much about it
16:36:07 <edwardk> samb: i agree, the whole 'lets make all the teachers get masters degrees' initiative didn't make the teachers smarter, it just deflated the value of the degrees
16:36:10 <jedai> tieTYT: But the point is the following : where in Haskell you would read 10 lines (admitedly concise) and understand a function, what it does and how it works, in Java you may have to read two screens and maybe have an idea of what it does in the end, having completely lost trace of how it does it
16:36:23 <tieTYT> inimino: i suspect that to be true.  But most here are saying they'd use these short names if they were writting procedural or OO code too so that makes me have my doubts
16:36:34 <SamB> edwardk: oh. I was just thinking teachers should take normal degrees in the subjects ;-P
16:36:39 <inimino> tieTYT: I didn't see anybody say that
16:36:41 <Saizan> tieTYT: i've read the code, obviously, but it was much easier once the names didn't clutter it anymore
16:36:44 <vixey> tieTYT: doubt they actually write java or smalltalk or anything
16:36:45 <MTK> I'm not aiming high with my degree anyways.. It's not like I'm going on to my masters.  I just want to get the hell out of here
16:36:55 <edwardk> samb: great, then NO one will get an education =P
16:36:56 <SamB> (at least *some* of the subjects they want to teach)
16:36:58 <halberd> it doesn't matter whether code is proedural or OO
16:37:13 <halberd> as far as name lengths go
16:37:16 <Gracenotes> I suppose: it is functional programming. The function names are more important than the variable names, really.
16:37:34 <inimino> halberd: I'm quite not so sure about that
16:37:38 <SamB> Gracenotes: well, the variable names are by and large x, y, xs
16:37:42 <Gracenotes> calling a function 'blah' or 'xs' is a bad idea.
16:37:42 <edwardk> samb: but then i had the misfortune of attending a college that was well known for producing teachers, so i'm somewhat biased on the topic
16:37:43 <SamB> so yeah ;-)
16:37:46 <inimino> but naming conventions in other languages are really OT
16:37:48 <Gracenotes> unless it if a variable
16:37:48 <jedai> halberd: it does matter I think
16:37:51 <Gracenotes> *is
16:38:03 <tieTYT> inimino: jedai said he might
16:38:12 <ddarius> Function names are variables.
16:38:21 <tieTYT> vixey: that may be true, that is important
16:38:30 * ddarius has called a function "xs" before.
16:38:32 <SamB> ddarius: now don't start on that!
16:38:46 <SamB> oh, do tell about the "xs" function
16:38:55 <tieTYT> in OO code it totally matters
16:38:59 <inimino> xs = tail
16:39:00 <tieTYT> it's all about naming
16:39:01 <jedai> tieTYT: I said I doubted that I would be able to express the same function cleanly enough to allow myself to use so short a name
16:39:02 <edwardk> ddarius takes everything to excess.. er wait, haskell the names too long. xs.
16:39:03 <pumpkin> > let xs (x:f) = f in xs [1..10]
16:39:05 <lambdabot>   [2,3,4,5,6,7,8,9,10]
16:39:13 <pumpkin> see, xs = tail!
16:39:13 <pumpkin> :P
16:39:15 <Gracenotes> pumpkin: hm... *suspicious*
16:39:35 <Gracenotes> tieTYT: yes, because in OO design patterns aren't built into the language. You have to be explicit about what you're doing.
16:39:39 <ddarius> SamB: It was, like I believe Gracenotes was trying to get at, an argument that happened to be higher order (actually I've done it more than once before)
16:39:42 <Gracenotes> in FP, you can abstract away design patterns
16:39:48 <jedai> tieTYT: that was a "Maybe but..." (well I still find Java naming convention too verbose even for its kind of language)
16:40:04 <tieTYT> Gracenotes: you hang out in #java right?  How good are you at haskell?
16:40:15 <edwardk> gracenotes: ah but wouldn't that practice be ... a design pattern? =)
16:40:18 <tieTYT> just learning or been using it for a while?
16:40:19 <Gracenotes> uh, pretty good, I guess.
16:40:23 <SamB> Gracenotes: I thought we just had different design patterns ;-)
16:40:30 <tieTYT> Gracenotes: so what's your take on this?
16:41:00 <pumpkin> tieTYT: I use long variable and function names in something like objective c, medium ones in ruby, and short ones in haskell :P
16:41:07 * ddarius wonders why we are having this conversation.  tieTYT can use whatever naming convention he desires and he is extremely unlikely to change the stylistic choices of an entire programming community.
16:41:08 <pumpkin> function names can be longer
16:41:09 <SamB> (higher order, maybe, but still!)
16:41:11 <edwardk> we have the 'tie the knot' design pattern, we have the 'move everything into a typeclass' design pattern, we have the 'design a parallel api in a qualified module' design pattern, etc.
16:41:31 <ddarius> pumpkin: Start programming in J.
16:41:39 <tieTYT> ddarius: you don't see the importance in being able to justify the decisions you make?  Sorry
16:41:41 <pumpkin> we have the C = typeclass and T = type pattern ;)
16:41:42 <SamB> edwardk: don't forget the "lets come up with a neat fold for that!" design pattern
16:41:44 <Gracenotes> tieTYT: well, I tend to think it does depend on the case.
16:41:47 <Gracenotes> *do
16:41:51 <Saizan> "move everything into a typeclass"? i thought that was bad! :)
16:41:51 <pumpkin> ddarius: yessir!
16:41:55 <edwardk> samb: and of course the pointless design pattern
16:42:00 <SamB> Saizan: it's called "oleg"
16:42:09 <tieTYT> Gracenotes: the case in haskell, the case in any language?
16:42:09 <edwardk> saizan: some of these may be antipatterns ;)
16:42:17 * inimino starts writing Design Patterns for Haskell
16:42:37 <Gracenotes> inimino: yes please
16:42:38 <wli> Object-oriented programming is an antipattern.
16:42:42 <edwardk> there is the 'go' idiom. maybe if we can start to speak their language they'll convert.
16:42:46 <pumpkin> co-pattern?
16:42:55 <ddarius> tieTYT: I haven't even stated a stance, but no, I don't see the importance is trying to convince you and regardless of how well or poorly justified the conventions are, I see only futility in you trying to change them.  If people don't have any justification then your efforts are even more futile.
16:43:12 <tieTYT> ddarius: i'm not trying to change anything
16:43:27 <Gracenotes> tieTYT: well, for instance, in some cases you're just implementing a mathematical algorithm, and all the variable names in the world can't help explain the mathematical basis behind the procedure
16:43:30 <tieTYT> ddarius: i'm trying to understand why people seem to write code this way in haskell
16:43:35 <edwardk> tieTYT: there are some things that are worth justifying, there are others that are easier to justify in terms of not having to justifying deviation from common convention
16:43:47 <orzo> which way, tieTYT ?  long names or short?
16:44:13 <tieTYT> edwardk: again, i think x:xs is fine
16:44:22 <tieTYT> Gracenotes: yep that seems true
16:44:30 <Gracenotes> I tend to use descriptive variable names in Java and not-as-descriptive in Haskell. But in Java, once you have an object, heaven knows what you're going to do with it. In Haskell, once you have an object you feed it into another function, or else don't really use it at all
16:44:42 <Gracenotes> or a 'value'
16:44:51 <Gracenotes> so it seems much more direct, not needing so much explanation
16:44:52 <edwardk> for instance, there is a guy around in the Haskell community that names all his types T and all of his classes C. Why? because he hates the module system and he wants everyone to use his stuff imported qualified and this is a common idiom in ML. I can't bring myself to use the code at all.
16:44:56 <SamB> usually if you're just doing something from math you try to pick names that correspond with the ones in the text book, yes?
16:45:14 <vixey> lol
16:45:14 <pumpkin> edwardk: it's a pity, because he writes interesting stuff (I think)
16:45:16 <vixey> what  a nut
16:45:16 <Gracenotes> SamB: yes, which creates a problem for those who don't have the textbook
16:45:17 <inimino> there's also probably some connection to mathematical thinking, writing papers, literate programming
16:45:19 <pumpkin> edwardk: but I feel the same way
16:45:35 <edwardk> pumpkin: yeah but its a case of 'get off my side, you're making me look bad!' =)
16:45:39 <SamB> Gracenotes: perhaps!
16:45:48 <inimino> in Haskell you are more likely to have a clear idea of an algorithm that's explained in prose
16:45:49 <Gracenotes> mathematicians overall don't seem to use descriptive variable names :)
16:45:54 <dolio> edwardk: He's clearly crazy, though. He disagrees with me about almost everything. :)
16:45:57 <edwardk> pumpkin: i can't judge anything about its quality because i can't read the haddock ;)
16:46:14 <pumpkin> edwardk: I mean, his libraries look cool at least :P even if I've never used any of them
16:46:21 <pumpkin> look cool in the human description
16:46:23 <Saizan> which libraries?
16:46:27 <jedai> pumpkin: The worst part for me is that Haddock don't qualify names in documentation so it's completely unreadable : you have a lot of T and C that aren't the same at all
16:46:27 <SamB> Gracenotes: I guess it depends on how much the textbooks differ on the formula(s) in question ...
16:46:32 <edwardk> saizan: numerical prelude, monoid-transformers
16:46:33 <Gracenotes> tieTYT: but, I think that the way that functions are chained with values gives more meaning to them than just doing Blah blah = blah.retrievedFromSomeMethod()
16:46:38 <Gracenotes> the values
16:46:53 <Gracenotes> *shrugs*
16:47:02 <edwardk> tieTYT: anyways i do believe that haskell names are a step too terse
16:47:12 <pumpkin> jedai: exactly, a change in haddock might help... if he wants people to use his libraries and maintain his current style, maybe he should take some time to add a flag to haddock that would make his libraries usable
16:47:17 <Saizan> edwardk: not on hackage?
16:47:28 <SamB> I don't think mathematicians would produce much better variable names even if they did use entire words ;-P
16:47:38 <edwardk> saizan: monoid-transformer numerical-prelude
16:47:39 <ddarius> SamB: That would be horrible.
16:47:47 <Gracenotes> there is of course a way to make everything much too terse in any language
16:47:47 <jedai> pumpkin: Yes, it would be nice too because the library do look interesting
16:47:49 <Gracenotes> except maybe J
16:47:51 <tieTYT> Gracenotes: i didn't understand that last comment
16:47:55 <SamB> I bet they'd be just as (if not more) meaningless
16:48:09 <ddarius> SamB: One of the problems with long names is that it significantly stifles paper and pencil calculation/manipulation.
16:48:13 <vixey> did you see that video of someone writing game of life in APL
16:48:19 <edwardk> er numeric-prelude
16:48:19 <pumpkin> jedai: even with qualified names in haddock, I still don't really like hte idea, but at least it'd be possible to determine in his documentation that (C a, C a, C a, C b) => a T -> b T -> Int does something that might help me
16:48:51 <SamB> I think they could use another couple of alphabets' worth of letters, though ;-)
16:48:55 <edwardk> pumpkin: heh
16:49:11 <ddarius> SamB: That's what fonts, Greek and Hebrew are for.
16:49:29 <pumpkin> it's bad enough with the two ByteStrings
16:49:33 <jedai> pumpkin: Well I hate the idea myself (we're in Haskell, not OCaml, and even for OCaml I didn't really like this convention already)
16:49:43 <edwardk> is it sad that my problem with the numeric prelude is that it isn't pedantic enough? =)
16:49:43 <SamB> ddarius: fonts are hard to hand-write
16:49:53 <vixey> haha
16:49:55 <ddarius> SamB: Not that hard.  Easier than writing a word.
16:50:04 <SamB> and I meant *besides* latin and greek
16:50:04 <pumpkin> having qualified names woudl help us figure out chunk -> ByteString (the strict one) -> ByteString (the lazy one) -> ByteString (the lazy one)
16:50:23 <tieTYT> anyway, thanks for the info
16:50:23 <pumpkin> so it wouldn't exclusively benefit Cs and Ts
16:50:23 <tieTYT> ttyl
16:50:30 <Gracenotes> tieTYT: well, once you have a variable in a function in Haskell, you can't just do nothing with it. You have to pass it somewhere, and that provides a context for why you have it in the first place. Since evaluation order doesn't matter, variables can be linked closely with the functions they're used with. Or so closely they're not even mentioned (applicative/pointfree style)
16:50:32 <Gracenotes> damn
16:50:34 <Gracenotes> :\
16:50:35 <pumpkin> dayum
16:50:58 <SamB> Gracenotes: sure you can do nothing with it!
16:51:03 <pumpkin> whoops, I meant chunk ::
16:51:06 <Gracenotes> SamB: if you're silly
16:51:12 <SamB> it's just, uh, not very useful most of the time
16:51:12 <Gracenotes> well. then I was going to mention that in do notation, people seem to use more descriptive variable names
16:51:15 <ddarius> SamB: Then "x" or even "_" is a perfectly fine name.
16:51:32 <SamB> ddarius: quite right ;-)
16:51:40 <SamB> _ is a most excellent name in that situation
16:51:52 <dolio> __variableI'mNotGoingToUse
16:52:01 <SamB> with the bonus that you won't even refer to the value by accident
16:52:06 <Gracenotes> it might just be me, but do notation seems to lend itself to more descriptive names (i.e. not just one-character)
16:52:14 <jedai> Gracenotes: True, and when they don't, it's often that they don't really need the do notation and should just desugar
16:52:20 <CalJohn> What is the value of "whole-program optimisation", like JHC says it uses?
16:52:59 <ddarius> CalJohn: Most optimization can be greatly strengthened if they don't have to mark parts of the program as "unknown"
16:53:31 <SamB> CalJohn: properties that don't show up when compiling the individual pieces of your program have a chance to appear later on and be used for optimization?
16:53:59 <edwardk> CalJohn: optimizing in a 'closed world' can yield a lot more efficient result than optimizing in an 'open world' in particular you can know what every single function that is in the world will look like.
16:54:06 <ddarius> As a simple example, if I have a publically accessible name, I can't remove it because some other module might use it, but if I can see the whole program I can perform dead code elimination on it if it isn't used anywhere.
16:54:14 <CalJohn> ddarius: how greatly is "greatly"?  what kind of improvements are possible?
16:54:30 <edwardk> CalJohn: hello world in jhc is about the same size as for C? =)
16:54:31 <CalJohn> ddarius: kind of line inlining everything?
16:54:32 <SamB> CalJohn: much is possible
16:54:41 <CalJohn> *like
16:54:55 <CalJohn> SamB: that is no more descriptive! :)
16:54:56 <edwardk> its at least in the scale of 20k and not megabytes like ghc;s
16:55:23 <SamB> you may notice that JHC isn't exactly finished yet ;-)
16:55:30 <c_wraith> CalJohn: Inlining long functions is rarely actually worth it.  Things that are more common are optimizing out checks for conditions that provably can't arise when you look at the whole program.
16:55:38 <ddarius> CalJohn: There are optimizations that are only possible/useful in whole programming situations, particularly representation specializations.
16:55:54 <edwardk> CalJohn: it can also optimize for things that aren't just size. if you know only one or two things can ever be done with a particular value at a particular spot then rather than jump to an unknown function pointer it can just test if its the first and otherwise do the second, etc.
16:56:31 <Gracenotes> inline my ackerman function, please!
16:56:49 <Gracenotes> +n
16:57:11 <pumpkin> sexist
16:57:13 <CalJohn> ok, interesting answers
16:57:17 <pumpkin> ackerwoman
16:57:22 * edwardk starts mining the numeric prelude
16:57:33 <vixey> for monoids?
16:57:35 <pumpkin> edwardk: for more structures to stick into your monoids?
16:57:36 * ddarius hangs a canary at the entrance.
16:57:50 <SamB> ddarius: your canary was dead ten minutes ago!
16:57:54 <edwardk> pumpkin: yeah just some obvious things i forgot, like i can fromInteger any ring.
16:57:56 <c_wraith> Isn't it more useful to take the canary down to the depths with you?
16:57:59 <ddarius> SamB: Lowest bidder.
16:58:08 <SamB> from the Prelude, I meant
16:58:22 <edwardk> pumpkin: i have an equivalent formalism in that every ring is a module over the Naturals but thats kinda pedantic to use
16:58:33 <edwardk> and fromInteger should go in my Data.Ring.Sugar
16:58:38 <orzo> the llvm makes a referentially transparent assembler language in order to get better optimizations
16:58:44 <pumpkin> edwardk: any ideas on the abs function? I seem to remember reading they had trouble doing that nicely
16:58:58 <edwardk> yeah i don't have one? =)
16:58:58 <orzo> apple says it gets a 30% gain
16:59:26 <SamB> orzo: for what?
16:59:31 <pumpkin> http://en.wikipedia.org/wiki/Normed_vector_space ?
16:59:31 <edwardk> fortunately you have the good old haskell numeric types to fall back on and i'm not trying to replace them
16:59:32 <SamB> compared to what?
16:59:37 <ddarius> SamB: Money obviously.
16:59:56 <edwardk> yeah a norm is basically what you are looking for
16:59:58 <ddarius> pumpkin: Start breakin' out the Banach spaces.
17:00:06 <orzo> SamB: comparing their non-llvm fork of gcc with their fork of gcc that uses llvm as a backend
17:00:10 <pumpkin> haven't come across those :o
17:00:13 * pumpkin looks
17:00:33 <edwardk> you'd say that your ring is a module over itself and say that the module has a norm
17:00:35 <SamB> orzo: is that compile time? run time? run speed?
17:00:54 <pumpkin> > abs (1 :+ 0)
17:00:56 <lambdabot>   1.0 :+ 0.0
17:00:59 <orzo> SamB: run speed
17:01:00 <pumpkin> (is gross)
17:01:04 <CalJohn> SamB: i think the default gain for compilers is run speed
17:01:32 <edwardk> usually i'd say start a little further down the spiral and work up from quadratic space to bilinear space or sesquilinear space and then build an inner product space over that
17:01:42 <ddarius> pumpkin: Other than you'd usually want a real, that's the correct answer at least.
17:01:59 <pumpkin> ddarius: oh yeah, it was the complex abs that disturbed me
17:02:12 <pumpkin> abs :: a -> a doesn't make much sense
17:02:14 <ddarius> > cis pi
17:02:15 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
17:02:22 <ddarius> Yay, 0
17:02:30 <pumpkin> @index cis
17:02:30 <lambdabot> Data.Complex
17:02:30 <ddarius> The number of many names.
17:02:39 <wli> abs is very painful for complex numbers
17:02:50 <Gracenotes> hm. how'd you translate do { s <- bar; foo; return s } to applicative? hrm
17:02:58 <ddarius> bar <* foo
17:02:59 <edwardk> pumpkin: yeah, what you want is that the complex forms a vector space over the reals and that should give you your properly valued norm
17:03:00 <Gracenotes> <*
17:03:01 <pumpkin> > cis $ 2 * pi
17:03:02 <Gracenotes> ?
17:03:02 <lambdabot>   1.0 :+ (-2.4492935982947064e-16)
17:03:04 <edwardk> er complex numbers
17:03:08 <pumpkin> aha
17:03:15 <Gracenotes> oh, okay. ddarius and for reverse ordering, *>?
17:03:31 <Gracenotes> or actually, just >> would do in that case
17:03:32 <pumpkin> I guess you could use an associated type to get abs to return the values you want?
17:03:38 <ddarius> Gracenotes: *> would perform the effects in the same order but return foo's result.
17:03:55 <edwardk> pumpkin: no because the complex numbers form a vector space over many rings/fields
17:03:55 <ddarius> @src (*>)
17:03:55 <lambdabot> (*>) = liftA2 (const id)
17:04:02 <Gracenotes> okay. so foo *> bar would be foo>>bar
17:04:06 <ddarius> Yes, (>>) is the same thing if your applicative is a monad.
17:04:19 <pumpkin> edwardk: but couldn't you resolve those with newtypes?
17:04:22 <edwardk> pumpkin: so you're staring and a multiparameter typeclass
17:04:23 <Gracenotes> right. Not much translation otherwise
17:04:26 <edwardk> er at a
17:04:31 <jedai> orzo: I would like to know what was benchmaked exactly, since I very much doubt that a single change like that could provide a gain of 30% over the already very well optimized output of GCC
17:04:39 <edwardk> pumkin: not very naturally.
17:04:49 <Gracenotes> @src (*>)
17:04:49 <lambdabot> (*>) = liftA2 (const id)
17:04:53 <Gracenotes> @src (<*)
17:04:54 <lambdabot> (<*) = liftA2 const
17:04:57 <Gracenotes> ..right
17:05:18 <orzo> jedai: i don't really know too much.  google apple's llvm promotions
17:05:23 <Gracenotes> mak sense.
17:05:35 <edwardk> pumpkin: i gave in and defined class (Ringoid r, Monoid m) => Module r m -- actually i defined LeftModule and RightModule then derived Module from those
17:05:36 <pumpkin> edwardk: fair enough
17:05:56 <duaneb> could someone look at my code?
17:05:57 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3522#a3522
17:06:01 <duaneb> slash make criticism
17:06:06 <edwardk> pumpkinL you use the scalar multiplication operators a lot.
17:06:26 <EvilTerran> duaneb, er, why're you using Int8 everywhere?
17:06:49 <gweiqi> to be a rebel
17:06:57 <jedai> orzo: Well it's promotion... If it's such a gain, no doubt we'll hear of it again
17:06:57 <ddarius> a rebel without a cause
17:07:08 <edwardk> pumpkin: that said, i do _have_ a newtype for a lot of those rings, like the naturals
17:07:37 <ddarius> Gaussian integers, ho!
17:08:05 <dolio> 127 should be enough for anybody.
17:08:14 <pumpkin> ah
17:08:17 <ddarius> and -128 !
17:08:20 <Gracenotes> linear combinations of
17:08:32 * pumpkin linearly combines Gracenotes' face
17:08:43 <SamB> 127 is always enough until you want to represent the negation of -128 ...
17:08:49 <wli> I'll let you know when I figure out modules well enough to feel better about them even though I can't write any meaningful code about them.
17:09:00 <monochrom> natural numbers should be enough for anybody
17:09:17 <ddarius> monochrom: Too bad they don't exist...
17:09:26 * ddarius runs off
17:09:29 <pumpkin> :o
17:09:32 <SamB> ddarius: they don't?
17:09:38 <jedai> duaneb: You don't have to indent your whole module like that
17:09:38 <monochrom> True.
17:09:40 <pumpkin> only in your hands
17:09:48 <SamB> oh well, let's just forget about that -- nobody actually understands that anyway
17:10:29 * monochrom changes tactic.
17:10:40 <monochrom> lambda expressions should be enough for anybody.
17:11:23 * monochrom braces for the next blast of "they don't exist either"
17:12:14 <duaneb> EvilTerran: because it doesn't need to be any larger than In8
17:12:16 <duaneb> Int8*
17:12:17 <halberd> is there a form of type theory that needs no functions?
17:12:46 <halberd> or not directly
17:12:58 <dolio> Cast off your decadent constructivism and embrace finitism.
17:13:16 <pumpkin> I don't see how it'd be interesting if it did exist
17:13:40 <pumpkin> aren't types used to decide what functions can be called on what values? values alone can't interact
17:14:10 <dolio> (Or ultrafinitism.)
17:14:33 * edwardk feels slightly dirty. r ^ n = getLog (replicate (Log r) n)
17:14:39 <halberd> based on and, or, and not, with no nand directly
17:15:01 <edwardk> ooh even worse. r ^ n = getLog (Log r .* n)
17:15:12 <edwardk> (yes i realize getLog should be 'exp' ;)
17:16:35 <pumpkin> .* = replicate? :o
17:16:49 <pumpkin> I'd define .* as zipWith (*) Ã  la matlab :P
17:16:51 <edwardk> over the naturals thats the action of the module
17:16:55 <pumpkin> hrrmpf
17:17:03 <edwardk> *. and .* are scalar multiplication
17:18:14 <pumpkin> ah
17:18:46 <edwardk> 2 *. x = 1 *. x + 1 *. x = x + x = replicate x 2
17:19:36 <wli> Next numerically compute Lambert's W function for real and complex arguments.
17:19:40 <pumpkin> so you've taken replicate?
17:19:53 <edwardk> pumpkin: its in Data.Monoid.Sugar
17:19:56 <pumpkin> ah
17:20:08 <pumpkin> do you actually decompose it like that? seems like you'd start doing integer partitions
17:20:26 <edwardk> or wait Data.Monoid.Combinators.  those are intended to be imported qualified
17:20:51 <edwardk> Combinators are qualified imports, Sugar are 'ok you really don't care about the Prelude, here are a bunch of operators'
17:21:05 <edwardk> pumpkin: i partition
17:21:28 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Combinators.html
17:21:49 <edwardk> i'm going to change that module slightly so it can only take a Natural in the next push now that I have them
17:22:05 <edwardk> the replicate in Data.Group.Combinators takes Integer
17:22:33 <pumpkin> ah :)
17:25:39 <vav> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3523 -- 'case blah of Nothing -> return Nothing' bugs me. Suggested improvements?
17:26:33 <travisbrady> vav: maybe you want Data.Maybe.maybe?
17:27:12 <vav> travisbrady: yeah, it got kind of ugly, maybe (no pun) you all can help me get it cleaner:
17:27:17 <vav>  maybe (return Nothing) (fmap (Just . show)) (fmap getName $ peek ws)
17:28:01 <Gracenotes> :o
17:28:40 <pumpkin> type Z = IO ?
17:28:44 <Gracenotes> @type traverse
17:28:45 <lambdabot> Not in scope: `traverse'
17:28:56 <Gracenotes> @type Control.Applicative.traverse
17:28:57 <lambdabot> Not in scope: `Control.Applicative.traverse'
17:29:03 <pumpkin> Traversable?
17:29:06 <Gracenotes> @type Data.Traversable.traverse
17:29:07 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
17:29:09 <vav> pumpkin it's actually X from XMonad
17:29:12 <pumpkin> oh
17:29:45 <vav> but yes functor, monad and all sorts of instances
17:30:25 <vav> sometimes if I type it out without the familiar names I see it more clearly
17:30:28 <Gracenotes> Maybe is both Applicative and Traversable. Perhaps this is relevant -- I'm not sure though.
17:31:01 <Gracenotes> and X is obviously a Monad, so an Applicative... hrm.
17:32:03 <Gracenotes> (a -> X b) -> Maybe a -> X (Maybe b)
17:32:27 <duaneb> ok, how the heck can I read an integer?!
17:32:43 <pumpkin> > read "10000" :: Integer
17:32:44 <lambdabot>   10000
17:33:41 <pumpkin> edwardk: you said you have Nat now, is that just the data Nat = Z | S Nat ?
17:33:47 <pumpkin> or did you represent them differently?
17:34:45 <duaneb> ok, could someone tell me what I'm doing wrong in doProgram?
17:34:46 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3524#a3524
17:34:52 <duaneb> in my head, all the types match
17:34:56 <pumpkin> what's your error?
17:35:11 <duaneb> subsets.hs:41:45:
17:35:16 <duaneb>  Couldn't match expected type `t -> [Char]'
17:35:27 <duaneb> against inferred type `String'
17:35:45 <duaneb> In the second argument of `(++)', namely `(show target) putStrLn'
17:36:11 <pumpkin> what's that let?
17:36:16 <pumpkin> you want that to be do
17:36:21 <pumpkin> I mean
17:36:22 <pumpkin> in do
17:36:38 <duaneb> hmm
17:36:38 <duaneb> yes
17:36:40 <pumpkin> or sequence them up yourself
17:36:48 <duaneb> but I'm still learning, and I *know* lets
17:36:54 <duaneb> I'm shaky on the `do`s
17:37:21 <pumpkin> let is fine, but you can't write multiple putStrLn without a do or some other way of sequencing them
17:37:34 <duaneb> oh, I forgot a do?
17:37:35 <duaneb> dammit
17:37:56 <vav> Gracenotes: traverse looks interesting, working through grokking. Thanks.
17:38:08 <duaneb> heh, didn't fix any of the erros
17:38:55 <Gracenotes> vav: sure. not certain if it's a useful abstraction in your case :)
17:39:16 <Gracenotes> another abstraction involving Applicatives is Foldable
17:39:46 <vav> Gracenotes: yeah, the description doesn't match the use case but the types match a related problem, maybe this one haven't matched it up yet.
17:40:36 <travisbrady> duaneb: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3524#a3525
17:41:22 <duaneb> ahh, got it to compile
17:41:30 <duaneb> the last error was a stupid mistake of mine
17:41:49 <duaneb> travisbrady: yea, that :P
17:42:11 <travisbrady> duaneb: yeah, you were close, just a $ instead of =<< basically
17:43:01 <duaneb> I need to get back in monad mood.
17:43:23 <duaneb> Ok, anything else people suggest?
17:43:27 <duaneb> In general?
17:43:30 <duaneb> to make it more haskellish?
17:45:26 <BMeph_> duaneb: If your version of GHC is high enough, you can replace your subsets with (Data.List.)subsequences, for one. That just caught my eye right off. :)
17:45:57 <duaneb> BMeph_: Actually, I'm offering this as an alternative to a java assignment I have
17:46:06 <duaneb> where we have to implement subsets
17:46:10 <duaneb> so I need to keep them :P
17:46:44 <duaneb> but thanks everyone!
17:49:17 <BMeph_> also, throw parens around the "aheight - bheight", otherwise it's only going to take the abs of the first. :)
17:49:26 <BMeph_> duaneb: ^^
17:50:43 <duaneb> dammit
17:50:51 <duaneb> yea, just realized that :P
17:51:59 <BMeph_> duaneb: If you don't have to implement "complement", you could use delete, otherwise, I'd recommend using foldl', not just foldl.
17:55:26 <vav> Gracenotes: nice! \ws -> traverse (fmap show . getName) (peek ws)
17:56:00 <Gracenotes> vav: neat :D
17:56:16 <vav> or traverse (fmap show . getName) . peek
17:56:42 <duaneb> BMeph_: thanks!
17:56:58 <duaneb> I couldn't find a `substract` function
17:57:41 <duaneb> or even better
17:57:46 <duaneb> foo \\ bar
18:05:28 <BMeph_> duaneb: You seem to do a bunch of conversions between Float and Int8 - why not leave your numbers Floats, and print them truncated?
18:14:47 <duaneb> hmm
18:14:49 <duaneb> yea, I'll try that
18:15:03 <duaneb> trying to make it 'fast' now
18:19:16 <duaneb> man, a "sumFaces = sum . (map $ sqrt)" is so much better than "float total = 0.0; for(int i = 0; i < vec.size(); i++) total += Math.sqrt((double)vec.get(i));"
18:20:35 <BMeph_> duaneb: Even better than that is "sumFaces = sum . map sqrt" ;)
18:21:29 <duaneb> bmeph_: operator precedence is an acquired skill :P
18:21:50 <duaneb> damn, java still beats the socks off ghc :/
18:22:00 <duaneb> I hate working on the powerpc
18:22:09 <duaneb> great platform, no maintainers :P
18:22:47 <pumpkin> duaneb: try using UArr
18:22:54 <wli> Numeric.showFFloat might come in handy.
18:23:09 <pumpkin> duaneb: already compiling with -O2 etc.?
18:23:30 <duaneb> pumpkin: yea
18:23:34 <BMeph_> duaneb: I'm throwing in a few more "haskellish" versions of your functions, since there're a lot of things that "you're doing 'wrong'"... ;)
18:23:45 <duaneb> BMeph_: Please!
18:23:49 <edwardk> pumpkin: was afk, no my Naturals are newtype Natural = Natural Integer
18:23:56 <pumpkin> oh
18:23:59 <pumpkin> :)
18:24:00 <BMeph_> duaneb: I mean, I'm putting the "improved" versions on your hpaste page. :)
18:24:24 <edwardk> with appropriate monoid and multiplicative instances and guarded "-" through Num if you really want them
18:24:35 <pumpkin> I see
18:24:41 <edwardk> Data.Ring.Semi.Natural
18:25:19 <pumpkin> http://twitter.com/pumpkingod/status/1480556739
18:25:25 <pumpkin> whoops, that was meant for blah
18:25:50 <duaneb> BMeph_: Ahh, ok
18:25:51 <duaneb> thanks
18:27:01 <BMeph_> duaneb: Heh-heh, don't thank me until you see it... ;)
18:28:00 <duaneb> haha
18:28:17 <duaneb> Nah, I need to learn the idiom half of haskell :P
18:30:17 <duaneb> I understand functional  programming, monads, lazy evaluation, etc
18:31:02 <BMeph_> duaneb: Here's some of it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3524#a3529
18:32:13 <duaneb> thanks
18:32:26 <duaneb> That's exactly the stuff for which I'm looking
18:33:13 <dev31212> hi...question about installing gtk2hs
18:33:21 <dev31212> I have installed ghc 6.10 on XUbuntu
18:33:37 <dev31212> I downloaded the latest gtk2hs..did a /configure...but I get the following error upon "make":
18:33:55 <dev31212> <command line>: unknown package: cairo-0.10.0
18:34:18 <dev31212> Not sure how to go about manually installing cairo
18:34:38 <dev31212> there is  a cairo directory, with its own files, in the gtk2hs directory
18:35:14 <dev31212> Anyone have an idea on how to proceed?
18:38:16 <clanehin> dev31212: I'm not sure, but cairo is installed in your distro?
18:38:46 <duaneb> dev31212: it's a separate package
18:41:22 <duaneb> bmeph_: what about, say, "b = [x | x <- nums, x `notElem` a]"
18:42:42 <BMeph_> duaneb: You could do that, but with that size, a filter would be most idiomatic ("haskellish"). :)
18:43:17 <BMeph_> duaneb: There, I put some comments in (as I should have done first), so yo uknow "kind-of" what's going on. :)
18:44:05 <aconbere> I have two variables, in one part of my program I want to coerce them into being strings, without ghc infering that their type is a string.
18:44:06 <dev31212> duaneb, ok,
18:44:08 <aconbere> (not sure that makes sense)
18:44:21 <duaneb> BMeph_: thanks :)
18:44:31 <aconbere> I guess I don't know how to copy a value, or maybe just how to wrap that operation such that the inferencing doesn't chain back
18:44:35 <aconbere> :P
18:45:38 <dev31212> I get the following when trying to do "cabal build" in the cairo directory:
18:46:09 <dev31212> cabal: cairo.cabal:12: Parse of field 'exposed-modules' failed.
18:46:52 <BMeph_> aconbere: In the immortal words of Inigo Montoya, "I do not think this word means what you think it means." :)
18:47:00 <pumpkin> ...prepare to die
18:47:03 <aconbere> haha
18:47:05 <aconbere> DAMN!
18:47:41 * BMeph_ notices pumpkin using *another* Montoya quote, and is scared...
18:47:53 <pumpkin> it's a quotesuffix
18:49:28 <bremner> BMeph_: but that is not Inigo, that is the Giant
18:49:42 <dev31212> Appologies for the newb questions
18:49:46 <dev31212> but Ive been at this 3 hours
18:49:55 <gwern> Andre the giant has a posse
18:49:56 <dev31212> anyone have an idea about my early question?
18:49:58 <gwern> OBEY
18:50:09 <aconbere> http://paste.pocoo.org/show/111693/
18:52:00 <BMeph_> bremner: I thought they both said it, at some point of another.
18:52:25 <bremner> BMeph_: pics or it didn't happen
18:53:31 * BMeph_ goes to netflix.com to get a copy of "The Princess Bride" so he can find the time index in question...
18:54:25 <bremner> awesome. Do you mind just transcribing the whole thing into the channel one line at a time over the next few weeks?
18:54:36 <BMeph_> Hmm, some point *or* another. :p
18:55:19 <BMeph_> bremner: Very much. I do enough dumb stuff on my own, I do not need "help" for more. :p
18:57:13 <gwern> ooh. for some reason syntax highlighting has just started working again in gitit, and now both my scheme and haskell sicp code is highlighted
18:58:40 <inimino> gwern: how far are you in SICP?
19:00:03 <gwern> inimino: I was hoping to do 1.2 this week
19:00:15 <gwern> (so far I've kept getting distracted)
19:00:19 <inimino> ah
19:00:32 <inimino> there is a group of us in ##SICP going through it
19:00:46 <gwern> it useful?
19:00:55 <inimino> yeah
19:01:18 <inimino> it's been quite helpful
19:01:47 <gwern> how official/long-term is ##SICP?
19:01:59 <inimino> not official at all
19:02:17 <gwern> well, I mean will it still be around in a year or two?
19:02:21 <inimino> someone posted a message on Hacker News about it, and we started going through it
19:02:42 <inimino> currently there's one set of us working through the book, we're in chapter 2 now
19:02:58 <gwern> chapter 2 == 1.2?
19:03:18 <inimino> no, 2.x
19:03:26 <gwern> ah. section 2 you meant
19:04:01 <gwern> that's a little far for me :)
19:04:25 <inimino> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
19:04:35 <inimino> chapter 2 "building abstractions with data"
19:05:41 <inimino> if there is enough interest maybe we could get another group started from the beginning
19:05:41 <gwern> I've been wondering how far I can get doing sicp in haskell
19:06:18 <inimino> I was originally going to do the exercises in both
19:06:28 <inimino> but I have only found the time to do them in Scheme so far
19:08:17 <gwern> inimino: it's best to do them simultaneously
19:08:29 <gwern> if you do one section in scheme and then go back alter... it's not a good idea
19:09:07 <gwern> an example: no webcomic that I've heard of has ever survived the decision by the author go back and redo the early strips until they've caught up to the present
19:09:46 * inimino doesn't see the connection
19:10:22 <inimino> it's too late for me to do most of it together, but I could try doing that in the rest of the book if I can find the time
19:10:36 <gwern> I thought it was obvious. going back and redoing stuff you've already done, but slightly different, is one of the most demoralizing boring things you can do
19:10:54 <inimino> oh, boredom
19:10:57 <gwern> it's not like writing essays or fictions where it can be very interesting to go back a few years later and edit it up to be better
19:11:06 <pumpkin> I'm looking forward to having time to work on lazy UArr
19:11:25 <inimino> well it would be interesting if you didn't know how to express the same algorithms in the new language
19:11:33 <gwern> it's code. mostly very basic simple code which there're only a few ways to write
19:11:46 <inimino> you'd be learning something in that case
19:12:04 <gwern> and then there's the overhead of recalling all the context and details. better to do the haskell version while it's fresh
19:12:18 <inimino> if it was all straightforward translation, yeah that would be boring
19:12:36 <gwern> inimino: right, but how far into sicp do you have to go to find something you couldn't do in haskell?
19:12:38 <inimino> I'd probably only do the ones where I thought the Haskell solution would be illustrative or different in an interesting way
19:12:50 <gwern> looking at section 2, it's still transliterable into haskell pretty easily
19:13:24 <mmorrow> gwern: does writing a scheme interpreter in haskell then doing it in scheme count?
19:13:53 <inimino> well, there's nothing you can't do
19:14:06 <gwern> mmorrow: no. because then you're working through Scheme in 24 Hours, not SICP :)
19:14:17 <inimino> but somewhere in chapten 2 you get into mutable state
19:14:20 <inimino> and then you'd have to do some things differently
19:14:21 <gwern> (at least, I think that's what the scheme interpreter in haskell textbook was called)
19:14:28 <inimino> which is why it'd be interesting
19:14:43 <gwern> inimino: I was just planning to use the state monad there
19:14:43 <inimino> ("write yourself a scheme in 24 hours")
19:14:57 <mmorrow> gwern: i mean just write a new scheme interp at the bottom of each module, then write the scheme program entirely in a ".." with no formatting.
19:15:03 <mmorrow> :)
19:15:18 <inimino> gwern: yeah, you could da anything like that
19:15:27 * mmorrow is clearly being ridiculous
19:15:44 <inimino> s/da/do/
19:16:01 <mmorrow> but not by much
19:16:17 <inimino> but I think those differences would be interesting
19:16:26 <gwern> well, I was thinking that on that distant day I finish sicp, scheme in 24 hours would be a good next thing
19:16:47 <mmorrow> gwern: i'd rather just print out the scheme spec and start hacking
19:16:49 <inimino> the differences of stuff in the early chapters like implementing car and cdr would be mainly just syntax differences hence boring
19:17:05 <bremner> they no longer start with sicp at mit, right?
19:17:18 <gwern> inimino: you *can* get mileage out of it; for example, in my write of chapter 1.1 I cover 'cond' and how one could do a quasi-cond in haskell, but can't really
19:17:18 <inimino> bremner: right
19:17:22 <gwern> but you have to try
19:17:28 <gwern> *write-up
19:17:34 <inimino> Write Yourself a Scheme is mainly useful if you don't already know Haskell, or Scheme (or maybe both)
19:17:39 <pumpkin> my school moved from SICP (a course based on it, at least) to haskell
19:17:39 <gwern> also, the lazy versus strict distinction is sometimes interesting
19:17:53 <dons> huh. the scheme workshop isn't going to be held with icfp this year.
19:17:54 <bremner> pumpkin: for first year?
19:18:02 <gwern> pumpkin: what was the haskell one based on?
19:18:17 <dons> so there'll be no lisp or scheme meetings at ICFP. that's kinda amazing.
19:18:20 <pumpkin> bremner: yeah, it's officially the second intro CS course (a prereq for the major)
19:18:22 <pumpkin> gwern: SOE
19:18:36 <pumpkin> bremner: but many take it as their first
19:18:49 <bremner> pumpkin: interesting.
19:19:22 <pumpkin> I took the SICPalike and enjoyed it a lot
19:19:50 <pumpkin> but didn't actually *want* to do functional programming until I was introduced to haskell
19:20:17 <inimino> gwern: well, you can't really do cond in any language that doesn't either already have it or has macros
19:20:50 <mmorrow> but if write an interpreter for a language, it can do anything that's possible
19:21:00 <gwern> inimino: I was thinking more of the returning-multiple-types issue
19:21:18 <inimino> ah
19:21:38 <inimino> well you'd probably have something like [Maybe IO ()] â†’ IO ()
19:21:42 <mmorrow> gwern: there's different levels you can interpret a language at
19:22:17 <inimino> well, that's not quite right
19:22:21 <mmorrow> you can implement a computer in the game of life
19:22:30 <inimino> you'd have to use some dynamic type
19:22:30 <gwern> 'cond :: [(Bool, a)] -> a\ncond xs = if head (fst x) then head (snd x) else cond (tail xs)'
19:22:34 <mmorrow> then throw linux on that thing and install ghc
19:22:34 <pumpkin> you can implement a game of life cell in the game of life
19:22:38 <pumpkin> it's awesome
19:22:49 <mmorrow> well sure that too
19:22:54 <mmorrow> yeah, it really is awesome
19:23:03 <pumpkin> of course, a computer is even cooler
19:23:08 <pumpkin> :P
19:23:17 <inimino> but slow ;-)
19:23:18 <mmorrow> the game of life is a computer!
19:23:25 <pumpkin> yeah, that's what I meant
19:23:56 <inimino> gwern: yeah, I don't think control structures would be as interesting as re-implementing some of the algorithms
19:24:01 <mmorrow> i was thinking the other day randomly about a good strategy to update the world in a game of life
19:24:10 <mmorrow> i think quadtrees could be nice
19:24:20 <mmorrow> turned inside out
19:24:33 <inimino> gwern: like doing the count-change thing in Haskell, considering laziness, comparing the complexity issues, etc
19:24:39 <mmorrow> (at leaves which contain active cells)
19:24:42 <mmorrow> or something
19:25:07 <pumpkin> http://en.wikipedia.org/wiki/Hashlife
19:25:09 <gwern> inimino: count-change?
19:25:12 <mmorrow> ooh
19:25:48 <pumpkin> mmorrow: sry, itz bin dun
19:25:51 <inimino> gwern: yeah, you have some number of coins and an amount of change and you have to give the number of ways to make that change using any number of coins of the kinds you have
19:25:59 <mmorrow> pumpkin: snap!
19:26:03 <gwern> I have a pdf of gosper's original hashlife paper if anyone wants it
19:26:14 <mmorrow> ooh, i love his glider gun
19:26:21 <mmorrow> sooo cool, and soo simple
19:26:37 <pumpkin> mmorrow: there are some awesome game of life programs
19:26:39 <mmorrow> well, maybe simple is a bad word
19:26:46 <pumpkin> with a whole bunch of awesome samples
19:26:50 <mmorrow> pumpkin: totally
19:27:21 <mmorrow> i at one point had this prog called "lucidlife" that was the best life implem i've seem (because of its lib of progs)
19:27:29 * mmorrow reinstalls that
19:28:06 <mmorrow> $ sudo yum install -y lucidlife
19:28:07 <mmorrow> weee
19:28:10 <pumpkin> omg yum
19:28:15 <pumpkin> mmorrow--
19:28:18 <inimino> gwern: I think it's in 1.2.  You write it and then you have to figure out the time and space complexity of this hairy recursive algorithm
19:28:18 <mmorrow> heh
19:29:33 <pumpkin> mmorrow++
19:29:33 <pumpkin> fine
19:29:55 <pumpkin> anyway, bbl
19:31:46 <mmorrow> here's a fullscreened lucidlife with a Rake Gun http://moonpatio.com/images/lucidlife.png
19:32:30 <mmorrow> and here are two animated gifs i forgot were in this dir:
19:32:33 <mmorrow> http://moonpatio.com/images/gosper.gif
19:32:40 <mmorrow> http://moonpatio.com/images/breeder.gif
19:33:21 <mmorrow> the breeder is sweet... it leaves behind a trail of glider guns
19:33:24 <mmorrow> forevar
19:34:25 <mmorrow> one thing that's unfortunate about gnome (that even windows has!!) is animated gif background images
19:35:56 * BMeph_ has the "41 ways" from the Project Euler website as his desktop background.
19:41:09 <mmorrow> oh nice, here's the original scientific american life article http://www.ibiblio.org/lifepatterns/october1970.html
19:41:30 <gwern> @quote burrito
19:41:30 <lambdabot> No quotes match. My pet ferret can type better than you!
19:41:37 <gwern> @quote space
19:41:37 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
19:41:37 <lambdabot> true functional programming), and you've got haskell
19:41:42 <gwern> @quote space
19:41:43 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
19:41:43 <lambdabot> true functional programming), and you've got haskell
19:41:44 <mmorrow> hehe "For long-lived populations such as this one Conway sometimes uses a PDP-7 computer with a screen on which he can observe the changes."
19:41:58 <mmorrow> (only sometimes)
19:42:08 <mmorrow> omg graphpaper!
19:42:10 <gwern> darn. I could've sworn lb knew a great quote about monad tutorials and burritos in spacesuits made out of nuclear waste
19:42:23 <mmorrow> preflex: quote octopus
19:42:23 <preflex>  no quotes found for octopus
19:42:27 <mmorrow> preflex: quote c++
19:42:28 <preflex>  no quotes found for c++
19:42:36 <gwern> @quote waste
19:42:36 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
19:42:39 <mmorrow> oh, that's by name i guess
19:42:42 <gwern> @quote waste
19:42:43 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
19:43:16 <gwern> @quote monad.*tutorial
19:43:16 <lambdabot> <BMeph> says: psygnisfive: In #haskell, you can't hardly be taken seriously w/o writing a monad tutorial...
19:43:31 <mmorrow> "Movement of a finite figure horizontally or vertically into empty space, Conway has also shown, cannot exceed half the speed of light."
19:43:46 <mmorrow> well of course it can't!
19:43:47 <psygnisfive> lol
19:44:07 <mmorrow> oh, "half"
19:44:09 <gwern> mmorrow: what's the of course?
19:44:17 <psygnisfive> mmorrow: in what??
19:44:25 <mmorrow> i thought that sentence said "cannot exceed the speed of light"
19:44:30 <mmorrow> and i was like "well, duh"
19:44:42 <mmorrow> but it say "*half* the speed of light"
19:44:52 <psygnisfive> mmorrow: in what?? GoL?
19:44:56 <mmorrow> apparently
19:45:03 <mmorrow> (i'm reading the original article)
19:45:07 <mmorrow> http://www.ibiblio.org/lifepatterns/october1970.html
19:45:09 <monochrom> Someone should make an xmonad plugin that plays haskell lecture videos on the background screen.
19:45:11 <gwern> it does make sense intuitively
19:45:12 <psygnisfive> that makes no sense then.
19:45:19 <gwern> since you can't move diagonally in life
19:45:25 <gwern> you can only move up then right, for example
19:45:34 <psygnisfive> GoL has no inherent coordinates mapable to real world space
19:45:43 <psygnisfive> so how do you make the speed analogy??
19:45:47 <mmorrow> imagine you build a gol circuit
19:45:55 <mmorrow> the cell's would have a size
19:46:01 <psygnisfive> sure
19:46:02 <psygnisfive> and?
19:46:03 <gwern> if something can move one cell a turn, then the speed of light is one cell per turn, always in the same direction
19:46:03 <mmorrow> time is "one tick"
19:46:12 <mmorrow> # cells moved / tick
19:46:22 <psygnisfive> ok, that works as a definition.
19:46:36 <mmorrow> (at least, that's what i assume they're using)
19:46:38 <gwern> but if you want to move to a diagonal cell and not an adjavent one, it takes 2 turns. therefore you can never go faster than / 2
19:46:40 <psygnisfive> but its somewhat arbitrary. and doesnt equate completely.
19:46:46 <monochrom> I guess the analogy is "physically imposed limit of signal propagation"
19:46:58 <mmorrow> hmm
19:47:07 <psygnisfive> gwern: except things that dont move diagonally!
19:47:12 <monochrom> Except that you don't get a theory of relativity out of this.
19:48:12 <gwern> psygnisfive: ?
19:48:35 <mmorrow> hmm, i wonder what relation this definition of speed has to the relativistic one (are they equivalent?)
19:48:45 <psygnisfive> you CAN go faster than half light, just not diagonally
19:48:55 <halberd> no they are not equivalent
19:49:28 <halberd> consider relative speed to a particle that is moving at light speed up, of a particle that is moving at light speed down
19:49:30 <mmorrow> i wonder then if there's any 2D finite automata that can propogate up/down faster than "the speed of light"
19:49:45 <halberd> for just a 2d finite automaton, the relative speed would be 2c
19:49:49 <mmorrow> (as defined by "# cells / tick"
19:49:50 <psygnisfive> depends on how you define the "speed f light"
19:49:52 <halberd> going against relativity
19:49:59 <psygnisfive> well morrow
19:50:11 <halberd> in general also, relative speeds would be additive, not the case in relativity
19:50:17 <psygnisfive> it depends on what you accept as "movement"!
19:50:21 <gwern> mmorrow: isn't the speed of light defined as the fastest any automata could travel?
19:50:34 <gwern> or is one cell per tick a good c?
19:50:43 <mmorrow> gwern: the limit that information can propogate at
19:50:45 <psygnisfive> gwern: except not all CAs work like that.
19:50:55 <inimino> information can move at one cell per tick
19:51:10 <psygnisfive> information propogates in a CA at infinite speed by that definition.
19:51:15 <mmorrow> inimino: hmm
19:51:20 <inimino> just not into empty space
19:51:32 <psygnisfive> well, sort of. i mean, CA's aren't actual motion, right
19:51:36 <psygnisfive> nor are they actual propogation of anything
19:51:46 <mmorrow> i wonder what definition that sentence from the article really is using
19:51:55 <inimino> information both moves and is propagated :-)
19:51:56 <psygnisfive> the "things" that you see in CAs are like wave crests
19:51:59 <mmorrow> (or if it's just written in by the author as filler)
19:52:06 <psygnisfive> they're not things
19:52:26 <psygnisfive> so just like light wave crests, they can move at infinite velocities, in some sense.
19:52:26 <kerlo> A CA with a range of 1 cell certainly can't propagate information faster than one cell per second.
19:52:47 <psygnisfive> ah but what do you mean by a range of one cell?
19:53:00 <psygnisfive> you mean where the state of any cell depends only on its immediate neighbors?
19:53:01 <kerlo> (Fast Forward Force Field notwithstanding.)
19:53:06 <kerlo> That, yes.
19:53:12 <psygnisfive> then sure, this is true then.
19:53:26 <mmorrow> "Movement of a finite figure horizontally or vertically into (1)*empty space*, (2)*Conway has also shown*, cannot exceed half the speed of light."
19:53:33 * mmorrow googles for (1) and (2)
19:53:35 <monochrom> You lack this axiom: "light" propagates from you to me at the same speed no matter what my relative velocity to you is.
19:53:36 <psygnisfive> no information should be able to propagate through that sort of system faster than light.
19:53:54 <kerlo> Cellular automata have a tendency to lack actual light.
19:54:00 <psygnisfive> yes ;)
19:54:17 <inimino> mmorrow: I think c is pretty well known and defined, though I couldn't find anything in a quick scan of the wikipedia article
19:54:19 <psygnisfive> here we're defining light, i GUESS as the radius of effect/time unit
19:54:37 <psygnisfive> so that i guess if a CA has a 1-cell radius of effect, then its speed of light is 1/1
19:54:47 <psygnisfive> but CAs dont have to have such simple definitions
19:55:13 <psygnisfive> for instance, you could define a CA where the state of any one cell is randomly determined by the entirety of the array
19:55:42 <psygnisfive> so whats the speed of that? certainly not anything we're normally thinking of.
19:55:45 <monochrom> Where are all the newbies?
19:55:52 <dolio> Randomly?
19:55:52 <psygnisfive> who knows.
19:55:59 <psygnisfive> dolio: yes, sure.
19:56:05 <kerlo> CA have limited range by definition, I believe.
19:56:18 <psygnisfive> well ok
19:56:24 <psygnisfive> suppose we have that
19:56:51 <psygnisfive> then you can define a CA where the behavior of a given cell is, lets say, a random field around the cell, within some maximum radius.
19:57:16 <psygnisfive> that has i guess a MAXIMUM speed, but what is its speed at any given moment? its hard to judge such a thing.
19:57:30 <psygnisfive> because not all the cells are affective.
19:58:35 * mmorrow bothers to read the next few sentences:
19:58:38 <mmorrow> "Can any reader find a relatively simple figure that travels at such a speed? Remember, the speed is obtained by dividing the number of moves required to replicate a figure by the number of cells it has shifted. If a figure replicates in four moves in the same orientation after traveling two unit squares horizontally or vertically, its speed will be half that of light."
19:59:11 <mmorrow> (http://www.ibiblio.org/lifepatterns/october1970.html)
20:00:09 <dolio> How fast do gliders move?
20:00:15 <dolio> The small ones, that is.
20:00:18 <psygnisfive> over one up one
20:00:19 <c_wraith> If I remember right, 1/4c
20:00:29 <mmorrow> i think the article just said gliders are one of the few that move at this speed
20:00:35 <psygnisfive> ah, yeah i guess thats correct actually
20:00:45 <c_wraith> Yeah, it's four steps to complete one shift.
20:00:48 <psygnisfive> im wary of calling diagonal motion like that
20:00:52 <mmorrow> "Figures that move in this way are extremely hard to find. Conway knows of only four, including the glider, which he calls "spaceships""
20:01:30 <c_wraith> Oh, right.  If you're using L1 distance, gliders move at .5c
20:02:21 <dolio> Wikipedia agrees with c/4.
20:02:46 <ddarius> I, for one, welcome our new publically editable overlords.
20:02:52 <psygnisfive> now i have some idea of the definition for movement he uses tho
20:03:01 <psygnisfive> the whole figure replicates somewhere else
20:03:01 <dolio> And says a "lightweight spaceship" moves at c/2.
20:19:50 <mmorrow> interesting http://arxiv.org/abs/math.DS/0503504
20:20:02 <mmorrow> (linked to from http://en.wikipedia.org/wiki/Life-like_cellular_automaton(
20:21:57 <ddarius> Are the entities of RealLife interesting?
20:31:18 <mmorrow> ddarius: i'm not sure how to answer that having only read the abstract so far
20:32:09 <ddarius> The answer then is "I don't know."
20:33:43 <mmorrow> "Remarks: (a) It is clearly impossible to exactly simulate a RealLife EA on a digital computer; the best we can do is simulate a large-radius Larger than Life CA. Theorem 2.1(a) guarantees this is will yield a â€˜good approximationâ€™of RealLife."
20:33:58 <dolio> Are you sure it isn't to take an arbitrary position and defend it from all comers?
20:34:01 <mmorrow> ddarius: i answered that way because i wasn't sure if that was a joke that i didn't yet get.
20:34:08 <sudish> {Uptime} [11:34pm up 6 days 4:02, 3 users] {Load average} [0.30, 0.21, 0.21]
20:36:04 <ddarius> mmorrow: I figured it wouldn't actually be implementable, but it was a serious question (that I doubt you'd immediately have the answer for).
20:37:29 <mmorrow> in that case, no sÃ© :)
20:38:02 <juhp> kind of hard to imagine what RealLife is or what LtL CA converges too
20:38:05 <monochrom> information wants to be free. monads want to eat newbies.
20:43:13 <maxote> has Haskell hashtables?
20:44:06 <Elly> has Haskell hashtables.
20:44:09 <Elly> Data.Map
20:48:26 <Apocalisp> @faq
20:48:26 <lambdabot> The answer is: Yes! Haskell can do that.
20:49:21 <monochrom> @vixen faw
20:49:21 <lambdabot> Are we just wasting time?
20:49:23 <monochrom> @vixen faq
20:49:23 <lambdabot> Uh-huh
20:52:17 <mmorrow> @vixen !
20:52:17 <lambdabot> hey, what's in a jack and coke anyhow?
21:08:13 <mib_6m2dqg7b> I'm working through Real World Haskell, Chapter 10, learning about parsers. The example works with data that is made of a series of different records....
21:08:38 <mib_6m2dqg7b> I'm wondering about data that can contain the repetition of a type of field any number of times...
21:08:54 <mib_6m2dqg7b> Something that would be parsed with a loop in imperative code.
21:10:01 <mib_6m2dqg7b> Chapter 10 talks about ways to pass state down a chain of functions...
21:10:01 <adamvo> mib_6m2dqg7b: wouldn't that data then be recursive, or contain other recursive data types?
21:10:50 <mib_6m2dqg7b> Example: <people><fred>Likes ties</fred><bob>Likes fries</bob></people>
21:11:17 <mib_6m2dqg7b> Records like fred and bob can be repeated N times within the <people>..</people> context.
21:12:15 <mib_6m2dqg7b> Chapter ten gets as far as defining a "glue operator" they call ==> but they don't explicitly talk about Monads until chapter 14
21:12:28 <adamvo> data Person = Person { name :: Name, likes :: [Person] }
21:12:41 <adamvo> mib_6m2dqg7b: you need to fill such a datastructure?
21:13:51 <mib_6m2dqg7b> actually data People = People [ Person ] ; data Person = { name :: Name, content :: String }
21:14:20 <mib_6m2dqg7b> So People can have any number of Persons in it.
21:14:55 <Gracenotes> yes. There is a "many" combinator that takes a Parser for one object and gives you a list of objects that it parses in succession
21:15:06 <Gracenotes> @hoogle many
21:15:06 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
21:15:06 <lambdabot> Text.Parsec.Prim many :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
21:15:06 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
21:15:17 <dolio> Presumably he wants to know how you'd implement many.
21:15:17 <mib_6m2dqg7b> The chapter 10 example sticks with reading record formats that are sequential of known field types and field lengths. Nothing repeated.
21:16:56 <mib_6m2dqg7b> Okay I'll write this down. It will probably take some time for me to absorb it. Thanks.
21:17:52 <dolio> The answer is 'recursion', although that may or may not help.
21:20:17 <bvck> Hi folks, a confusion on type constructor and class that I hope someone can quickly clear up.
21:20:30 <bvck> I am getting: Kind error: `c' is applied to too many type arguments
21:20:46 <bvck> for the following code:
21:20:55 <bvck> class Foo f where
21:20:55 <bvck>   bar :: (Eq a) => f a -> a
21:20:55 <bvck> class (Foo c) => Top c where
21:20:55 <bvck>   get :: (Eq a) => c a -> a
21:20:55 <bvck> data (Top c) => XX c = XX c
21:21:59 <dolio> Anything that is the type of a value has kind *.
21:22:16 <dolio> So when you say "data (Top c) => XX c = XX c", you're saying that XX contains values of type c.
21:22:22 <dolio> Which means that c :: *.
21:22:47 <dolio> But Top and Foo have it applied to another type, a, which means it has to have kind * -> *.
21:23:10 <dolio> So it's getting confused.
21:24:02 <bvck> dolio, I guess that is what *I* am confused about...:) I thought Top was a class??
21:24:18 <dolio> Yes, but its parameter, c, has kind * -> *.
21:24:39 <neoswish> guys, i asked you yesterday about possibility of implementing inverse function in Haskell, look what i did: (p (mul (5%9) <.> sub 32) 32) yields 0%1 and (q (mul (5%9) <.> sub 32) 0) yields 32%1 :)
21:24:48 <bvck> I think I see a glimmer of light...:) Let me read your response again and dwell on it. Thanks a lot.
21:24:49 <dolio> So in that data declaration, you're saying c has both kind * and kind * -> *.
21:24:55 <dolio> Why it selects that particular error, I'm not sure.
21:25:38 <bvck> How would I change it to be of kind * -> * then?
21:25:53 <dolio> What it's probably doing is looking at XX, inferring c to have kind *, then using that in Top, where it sees you're trying to do 'c a', and throws the error there.
21:26:35 <dolio> You need to apply c to something in the XX constructor.
21:26:51 <dolio> data Top c => XX c = XX (c Int) or something.
21:27:41 <bvck> Thanks. Let me play with that.
21:28:10 <dolio> Things with kind * -> * don't have values. Like, there are values of type [Int], but no values with type [].
21:28:50 <_dls> hey guys, I'm encountering the same error as http://www.nabble.com/how-to-use-a-literal-string-with-bystring-useAsCString-td21917375.html (second email in the thread)... basically I can't seem to convert from a string to a Word8, and the crypto library requires Word8s to do SHA1 hashes. any thoughts?
21:33:30 <leloup> any mac os x (ppc) users present ?
21:33:45 <bvck> dolio, wanted to thank you again. That worked like a charm.
21:33:52 <dolio> No problem.
21:34:05 <sjanssen> _dls: map (fromIntegral . ord)
21:35:28 <_dls> sjanssen: thanks :)
21:35:45 <sjanssen> _dls: you'll find ord in Data.Char
21:36:46 <saurik> I think Codec.Binary.UTF8.String's encode may be better for that (as the codepoints may be greater than what can be stored in a Word8 if you use fromIntegral)
21:37:45 <saurik> (assuming utf8 was the encoding of choice, of course)
21:40:14 * edwardk may have gone a little over on being pedantic in my last pass over the monoid lib. i now average more class definitions than functions =/
21:40:25 <edwardk> (per data type) =/
21:40:43 <pumpkin> :o
21:41:26 <pumpkin> sounds like you belong on freebase.com organizing knowledge
21:42:17 <_dls> saurik: woah. awesome, thanks!
21:42:26 <edwardk> BoolRing is Monoid Group Multiplicative Ringoid LeftNearSemiRing RightNearSemiRing SemiRing Ring Reducer (Module LeftModule RightModule Bimodule over Natural) and (Module LeftModule RightModule Bimodule over itself) oh and Normed
21:42:45 * edwardk tries to avoid freebasing ;)
21:42:55 <_dls> saurik: yeah. this is *perfect*
21:44:17 <pumpkin> saurik: wow, you're not idle!
21:44:38 <saurik> ;P
21:44:40 * edwardk hasn't yet given in and define a free module over every ring though yet at least
21:45:08 <pumpkin> saurik: port GHC to iphone!
21:45:16 <pumpkin> ;)
21:46:14 <leloup> I'm getting undefined symbols when trying to use a cabal package
21:46:29 <pumpkin> did you pass --make  to ghc?
21:49:11 <_dls> pumpkin: have you checked out JHC?
21:49:45 <pumpkin> not much, although I've played with LHC (before its GHC transition)
21:50:46 <_dls> pumpkin: JHC compiles to portable C, so it might make sense for the iphone (haven't checked though)... checking out LHC
21:51:01 <leloup> strange, ghc --make LU.hs works !  I tried this on another computer _without_ --make, and that also worked (?)
21:51:13 <halberd> giant hadron collider
21:52:18 <leloup> hmmm..  mac is ghc 6.10 and intel box is ghc 6.8...
21:52:24 <_dls> pumpkin: dude, this looks awesome. any luck getting it to compile for the iphone?
21:53:28 <edwardk> there should be a Bits instance for Bool
21:54:29 <Gracenotes> edwardk: mm. a lot of the functions would be redundant though
21:54:50 <edwardk> gracenotes yes but then i'd be able to make one Boolean ring instance just using its xor ;)
21:54:52 <Gracenotes> or useless
21:55:22 <Gracenotes> a lot of testing if the Int arguments are even or not :)
21:55:25 <edwardk> gracenotes it would also require Num Bool
21:55:35 <Gracenotes> oh, mm./
21:55:36 <edwardk> meh, most of them are just is it 0 or not =)
21:55:44 <edwardk> that isn't bad either from where i stand
21:55:46 <Gracenotes> well. rotating and such
21:56:03 <edwardk> you rotate any and you come back o the same guy
21:56:22 <Gracenotes> mm. right
21:56:36 <edwardk> shiftL > 0 would nuke, shiftR should preserve 'sign' =)
21:57:03 <Gracenotes> (+) for Bool = or
21:57:08 <Gracenotes> (*) = ... super-or?
21:57:11 <pumpkin> and
21:57:38 <edwardk> well, its a trade off (+) = or (*) = and is common for the semiring definition
21:57:41 <b\6> hey.
21:57:42 <Gracenotes> Does Boolean form a ring in which that's the case?
21:57:58 <edwardk> the ring itself is (+) = xor (*) = and
21:58:07 <edwardk> that gives you a boolean ring
21:58:15 <Gracenotes> oh. xor makes more sense.
21:58:34 <edwardk> but i'm going to give that one through the BoolRing newtype so it doesn't have to be the default definition
21:58:36 <Gracenotes> abs = const True, maybe
21:58:43 <edwardk> abs = id actually
21:58:49 <edwardk> by the requirement of Normed
21:58:57 <Gracenotes> which?
21:58:59 <edwardk> laws fail otherwise
21:59:02 <pumpkin> what's your Normed class def?
21:59:07 <leloup> just a friendly reminder: always try ghc --help before asking questions on irc :-(  ghc -c for compilation also works.
21:59:10 <pumpkin> or, have you uploadedyour latest version?
21:59:13 <Gracenotes> fromInteger = (/=0), I suppose
21:59:16 <edwardk> its not up yet
21:59:19 <Gracenotes> negate = not
21:59:23 <Gracenotes> (-) = wtf
21:59:31 <pumpkin> lol
21:59:36 <Gracenotes> signum = ... id, not much else you can do there
21:59:45 <glguy> - also = xor :)
21:59:52 <pumpkin> Gracenotes: a - b = a + (-b)
21:59:55 <pumpkin> so yeah
22:00:02 <pumpkin> x `xor` (not b)
22:00:04 <edwardk> an r-normed module m satisfies: abs m >= zero, abs m == 0 => m == zero, abs (m + n) <= abs m + abs n, r * abs m = abs (r *. m); abs m * r = abs (m .* r)
22:00:13 <Gracenotes> oh. creative, sir.
22:00:52 <edwardk> pumpkin: well i'm probably going to go with the semiring using and and or which is more intuitive for folks
22:01:04 <pumpkin> make a newtype for the xor ring :P
22:01:04 <Gracenotes> > let xor = (==) in [ a `xor` not b | a <- [False, True], b <- [False, True] ]
22:01:05 <lambdabot>   [False,True,True,False]
22:01:06 <edwardk> and they can get the xor/and boolean ring from using BoolRing over it
22:01:14 <Gracenotes> > let xor = (==) in [ a `xor` b | a <- [False, True], b <- [False, True] ]
22:01:15 <lambdabot>   [True,False,False,True]
22:01:19 <edwardk> pumpkin i already had one in Data.Ring.Boolean
22:01:30 <pumpkin> aha, always a step ahead
22:01:34 <Gracenotes> actually xor is /=
22:01:36 <pumpkin> or several
22:01:38 <Gracenotes> <=> is ==
22:01:41 <edwardk> pumpkin: i'm just going to extend than to all Bits instances and make a Num and Bits instance for Bool in the module
22:01:53 <pumpkin> yay more orphaned instances :P
22:02:34 <edwardk> pumpkin: meh, people seem to be picking them up and moving them down as time goes on, and its only been a couple weeks
22:02:45 <pumpkin> cool
22:03:14 <Gracenotes> so (-) is (==) in fact. Odd.
22:03:17 <edwardk> my BitSet is basically just a boolean semiring over an arbitrary Enum/Bounded
22:03:23 <pumpkin> you should send a patch for your UArr instance
22:03:30 <dolio> negate = id, no?
22:04:03 <Gracenotes> abstract algebra is hard, let's go shopping
22:04:07 <edwardk> dolio: depends on which environment, in the boolean ring? its not iirc, in the boolean semiring its undefined as its not a group
22:04:49 <dolio> Otherwise you get b - b = True, if b - b = b + (negate b) = b `xor` not b.
22:04:59 <b\6> how can i tell if, for example, System.Process rawSystem could throw?
22:05:25 <edwardk> dolio: then you may very well be correct. i hadn't implemented it ;)
22:05:33 <leloup> -XPatternSignatures. It is now XScopedTypeVariables. A simple example of what it's for ?
22:06:05 <pumpkin> > let f (x :: Int) = x + 1 in f 5
22:06:06 <lambdabot>   6
22:06:11 <pumpkin> pretty exciting, eh
22:06:25 <Gracenotes> boolean algebra is interesting.. so easy to reach a contradiction :)
22:06:28 <jeff__>  b\6 : http://www.haskell.org/ghc/dist/current/docs/libraries/process/System-Process.html#v%3ArawSystemhttp://www.haskell.org/ghc/dist/current/docs/libraries/process/System-Process.html#v%3ArawSystem
22:06:34 <Gracenotes> if you accidentally set up on small rule
22:06:39 <jeff__> er, doh, bad paste
22:07:06 <Gracenotes> *a
22:07:13 <pumpkin> nothing wrong with b - b = True is there?
22:07:23 <edwardk> dolio: i think you're right for the boolean ring
22:07:35 <pumpkin> should it be False?
22:07:35 <edwardk> pumpkin: only if you claim to be a ring and not a semiring
22:07:39 <pumpkin> yeah
22:07:44 <dolio> There is if you expect (b - b) to be the identity of + and annihilator of *.
22:07:48 <edwardk> ring a - a = 0
22:07:53 <pumpkin> the notion of - doesn't really work in a semiring
22:07:57 <pumpkin> ah, fair enough
22:08:03 <Gracenotes> so then (True - False) /= (False - True)?
22:08:34 <edwardk> (1 - 0) /= (0 - 1)
22:08:47 <Gracenotes> yes, but I'm wondering which definition would allow that
22:08:57 * Gracenotes has looked at groups, but not rings or semirings...
22:08:59 <leloup> aaahh. little slow.  so adding a type signature to args. That's it ? :-)
22:09:19 <edwardk> Gracenotes: i looked at them back in college, but i recently got obsessed with all this crap again
22:09:26 <pumpkin> leloup: not just function arg patterns though
22:09:29 <Gracenotes> mmmmm... I noticed!
22:09:33 <Gracenotes> :D
22:09:55 <Gracenotes> typeclasses make it very easy to make a hierarchy, it seems.
22:09:55 <pumpkin> > let f x = case x of (0 :: Int) -> 4; x -> 3 in f 0
22:09:56 <edwardk> =P
22:09:57 <lambdabot>   4
22:10:03 <edwardk> gracenotes: anything but actually
22:10:10 <edwardk> typeclasses make it a pain in my ass to make a hierarchy
22:10:15 <Gracenotes> heh
22:10:18 <edwardk> because i have to think of every level i want a priori
22:10:36 <Gracenotes> well, is the hierarchy a DAG at least?
22:10:39 <edwardk> so if i want to be pedantic later i need to be pedantic now or i break all my users
22:10:51 <edwardk> actually nope =)
22:11:01 <Gracenotes> ouch.
22:11:22 <pumpkin> it gives you a partial order doesn't it?
22:11:23 <edwardk> since you can make every monoid into a module over the naturals, every group into a module over the integers, every ring into a module/algebra over itself, etc.
22:11:46 <Gracenotes> well, a (+) might be canonically used for a binary operator in one structure and also in a different structure, even if they have different rules, I'm supposing
22:11:57 <edwardk> pumpkin: so to be pedantic since you can't force that they do those things the anal retentive version is to make things like class Module Natural m => Monoid m ;)
22:12:30 <edwardk> but then when you get up to Module, its class (Ringoid r, Module m) => Module r m
22:13:02 <edwardk> but since every ring(oid) should be a module over itself the more anal retentive versiown hich forces the availability of such a thing is
22:13:17 <edwardk> class (Module r r, Ringoid r, Module m) => Module r m
22:13:25 <edwardk> or
22:13:26 <edwardk> you make
22:13:34 <edwardk> class Module r r => Ringoid r
22:13:36 <edwardk> then
22:13:46 <edwardk> class (Ringoid r, Monoid m) => Module r m
22:14:04 <leloup> pumpkin: learned more from you in 5 min than 5 hrs of googling
22:14:08 <edwardk> lets just say its all a bit nerve wracking
22:14:11 <leloup> pumpkin++
22:14:58 <edwardk> anyways since i can't inject the first Module Natural m => Monoid m into the class system, i just have a replicate method that works over any monoid and natural
22:15:15 <edwardk> and encourage its use as the Natural instance, but i don't require the Natural module to exist
22:15:49 <edwardk> so you get a preorder anyways
22:16:01 <edwardk> but that doesn't say much
22:16:57 <Gracenotes> let me invite you down to my torture chamber... please, situate yourself comfortably in that commutative idempotent semiring
22:17:02 <edwardk> ah crap i can't define the Num instance in the Data.Ring.Boolean module it conflicts with the Normed 'abs' definition. hrmm, time to move it off into its Data.Monoid.instances with the other standard library ones
22:23:55 <pumpkin> aw
22:24:11 <pumpkin> we really need to break from h98 and fix the Num typeclass if nothing else :D
22:24:38 <edwardk> meh, i moved it, its fine now ;)
22:24:49 <pumpkin> seriously though, Num pisses me off :P
22:25:00 <pumpkin> as do RealFloat/Floating
22:25:38 <mmorrow> every day i like typeclasses less and less
22:26:19 <pumpkin> aw
22:26:22 <pumpkin> bbl
22:26:23 <mmorrow> (but i like the convenience of having an ad-hoc way to overload names)
22:27:01 <mmorrow> (in particular, i don't like the forced-on-you global scope of typeclasses)
22:29:31 <mmorrow> dolio: have you thought about also doing a bytestring-read?
22:30:23 <edwardk> bool instances added
22:30:40 <dolio> dons has a bytestring-lex package or something.
22:30:53 <dolio> Although that doesn't do much currently.
22:31:29 <mmorrow> iirc it's just an alex-produced lexer for Double
22:31:39 <mmorrow> (not that that isn't useful)
22:31:52 <dolio> Yeah. But it could do more. :)
22:34:23 <mmorrow> dolio: beyond literals though, alex would be pretty rough to use
22:34:54 <dolio> Yeah. Reading is a little more difficult, because you need to decide on a parser of some sort.
22:35:55 <BMeph> .
22:37:08 <mmorrow> my_strtod b = inlinePerformIO $ B.useAsCString b $ \ptr -> c_strtod ptr nullPtr
22:37:10 <mmorrow> :)
22:37:34 <mmorrow> ah, n/m
22:37:52 <mmorrow> for a second there i didn't see where alex was being used at all
22:38:59 <dolio> alex just verifies that it's a valid double syntax, I think.
22:39:18 <mmorrow> i have an online incremental csv parser that i really should upload to hackage
22:39:18 <mmorrow> dolio: yeah
22:39:40 <mmorrow> i use it all the time
22:39:47 <mmorrow> (the csv parser)
22:40:17 <dolio> Which might be a shame, since the C probably does that, too, but there's probably no easy way to get a nice result back from the foreign call if it fails.
22:40:44 <mmorrow> the problem with a type like :: ByteString -> Maybe [[Cellblah]] is that you lose all onlined-ness
22:42:23 <pumpkin> mmorrow: so what awaits us in future versions of vacuum? :o
22:44:42 <edwardk> this bool thing now makes me want to make BitSet into a Num and Bits
22:45:45 <mmorrow> pumpkin: ooooh man. i've revived my neutron webserver (which was in the "pending" directory because i was so bummed i couldn't use accept non-blockingly (i.e. not use ghc's iomanager)) and am gonna use that along with some javascript to make an "online" (not in the internet sense, but that too i guess) viewer like don's and the ubigraph one, but that shoots images to your browser
22:46:20 <mmorrow> so the webserver'll be able to "push" updates to the browser without the browser having to poll
22:46:50 <mmorrow> (this is the method http://www.obviously.com/tech_tips/slow_load_technique)
22:47:09 <pumpkin> :o
22:47:20 <pumpkin> oh, I've done that before
22:47:23 <inimino> mmorrow: what's neutron?
22:47:37 <mmorrow> it's pretty neat too. you can just sit in ghci, and wire it up so that you can send arbitrary stuff to the browser at your command
22:48:10 <mmorrow> inimino: a pretty lightweight webserver i have
22:48:15 <pumpkin> mmorrow: you mean to get something a bit like http://tryruby.hobix.com/ ?
22:48:47 <pumpkin> or is this for vacuum only?
22:48:57 <inimino> mmorrow: is it online somewhere?
22:49:06 <mmorrow> pumpkin: kind of. you could definitely hook the server up to ghc and for instance have lunabot-in-a-browser
22:49:27 <mmorrow> but the extra thing you get is that you can forkIO a thread in ghci, and
22:49:33 <pumpkin> I think I bought whyhaskell.org
22:49:51 <mmorrow> it'll do whatever and send whatever to the browser you have opened right next to your terminal
22:49:57 <mmorrow> pumpkin: heh
22:50:08 * mmorrow is the proud owner of unsafecoerce.com
22:50:10 <pumpkin> lol
22:50:19 <mmorrow> (.org/net/info too)
22:50:21 <mmorrow> ;)
22:50:42 <pumpkin> I wonder if some domain squatter will notice the trend and dredge haddock for domain names
22:50:42 <dolio> No .biz?
22:51:29 <lpsmith> hmm... has anybody tried out the new 10.2?
22:51:40 <mmorrow> so for instance, you can say "System.Vacuum.Neutron.view foo" and an image will instantly appear (or refresh if there's already one) in your browser window
22:51:47 <lpsmith> I'm getting segfaults when I use ^C
22:52:07 <mmorrow> dolio: heh, that one seemed a little too porned-out
22:52:45 <mmorrow> lpsmith: sucky. ^C works for me
22:52:55 <mmorrow> lpsmith: what are you on?
22:52:57 <dolio> Barely legal, point-free functions.
22:53:09 <lpsmith> e.g.   if I type   > let bot = bot in bot,   and then ^C causes segfault
22:53:13 <lpsmith> Ubuntu 8.04
22:53:31 <mmorrow> lpsmith: odd. that exact example works perfectly for me
22:54:02 <pumpkin> dolio: lol
22:54:14 <mmorrow> Linux monire 2.6.27.19-170.2.35.fc10.x86_64 #1 SMP
22:54:18 <lpsmith> mmorrow:  hmm...   are you an Ubuntu user as well?
22:54:21 <mmorrow> fedora
22:54:32 <lpsmith> ahh
22:54:51 <pumpkin> monire?
22:54:58 <lpsmith> did the binaries on the site work for you?   I had to compile my own...
22:55:51 <mmorrow> pumpkin: it was this one unix cpu server's name when i was in school (and which no longer exists)
22:56:03 <pumpkin> ah
22:57:15 <mmorrow> lpsmith: i built my own too
22:57:37 <mmorrow> (although not because the binaries didn't work, i didn't try any)
22:58:37 <mmorrow> pumpkin: also i guess i'm going to try to track down exactly why it segfaults if everything isn't forced
22:59:11 <pumpkin> :o
22:59:41 <pumpkin> I've found that segfaults are a real pain to deal with in haskell, but it may just be because I have no clue how the programs are structured under the hood
23:00:22 <mmorrow> i think it must have to do with the Storable instance for StgInfoTable for the ClosureTypes that non-forced closures have
23:00:26 <mmorrow> (or something)
23:00:49 <SubStack> pumpkin: so far I've been able to tell pretty easily where my segfaults are coming from
23:00:54 <mmorrow> because that's the only place where it's doing anything that could cause a segfault (pokes)
23:01:05 <SubStack> mucking about with pointers and such
23:01:07 <mmorrow> err, i meant peeks
23:05:24 <ski> > let bot = lambdaBot bot; lambdaBot = \_ -> bot in bot
23:05:39 <lambdabot>   thread killed
23:07:50 <mmorrow> ski: (i dunno if you've tried it yet, but) in 6.10.2 ghci you can actually do "let x = x in x" and break with ^C instead of having to ^Z + kill -9
23:08:17 <pumpkin> nice!
23:08:19 <ski> why's that ?
23:08:29 <mmorrow> (and it doesn't immediately go into consume-all-memory-as-fast-as-possible mode)
23:08:57 <mmorrow> ski: i'm not sure yet what exactly they did to fix that, but i'm gonna look for sure
23:28:06 <weilawei> why would these patterns be non-exhaustive? shouldn't (_:xs) also refer to something like 1:[] ?
23:28:07 <weilawei> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3543#a3543
23:28:28 <weilawei> i looked at the official version and I don't grok all the # signs
23:28:42 <mauke> weilawei: you misspelled L
23:29:13 <weilawei> mauke: awesome, i was pretty sure i understood more about haskell than that xD
23:30:03 <weilawei> so what does a # sign mean?
23:30:10 <mauke> in what context?
23:30:25 <weilawei> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
23:30:39 <Cale> weilawei: In the real implementation of length? #'s are used by convention in identifiers for unboxed-things.
23:30:40 <mauke> ghc internals
23:30:48 <mauke> Int# is an unboxed integer
23:30:48 <Cale> Yeah, and other ghc internal stuff.
23:31:04 <weilawei> unboxed?
23:31:15 <pumpkin> can't it figure out to unbox that automatically now?
23:31:27 <Cale> All normal values in Haskell have a uniform representation
23:31:39 <Cale> (in GHC Haskell)
23:32:01 <weilawei> oooh okay. i found a page explaining it
23:32:03 <Cale> Essentially, a pointer to code which returns the result somehow.
23:32:09 <mauke> http://arcanux.org/lambdacats/boxed.jpg
23:32:29 <weilawei> boxed cat is cubic
23:33:23 <Cale> This is what allows for polymorphism, but it also means an extra layer of indirection
23:33:36 <Cale> So ghc provides some primitive mechanisms to avoid it.
23:34:01 <pumpkin> wow, there's a lot of crap going on with take and drop in there
23:34:59 <Cale> heh
23:35:04 <Cale> Yeah, there is.
23:36:49 <GoldyOrNugget> is it better to have a function with if-statements or have several functions which do pattern matching?
23:37:15 <weilawei> GoldyOrNugget: maybe a mix of guards and patterns?
23:37:36 <weilawei> im pretty new to haskell, so i couldnt say and I dont know what the context is
23:38:20 <GoldyOrNugget> im a lot newer than you are
23:38:28 <GoldyOrNugget> i have absolutely no idea about any of this =S
23:38:59 <pumpkin> I tend to avoid if expressions unless they really fit nicely
23:39:13 <GoldyOrNugget> ok thanks
23:39:14 <pumpkin> but I'm not an old-timer either
23:39:28 <GoldyOrNugget> i come from imperative languages so i don't really get this stuff
23:40:02 <Ferdirand> pattern matchs and ifs probably both desugar to case statements anyway
23:40:26 <mauke> if c then t else e = case c of True -> t; False -> e
23:40:47 <sanguinev> How do I convert a the square root of an integer into an integer I can use in a list? The code I have now is: "(\n -> [1..(floor(sqrt(n)))])"...
23:41:00 <pumpkin> Ferdirand: yup
23:41:35 <mauke> > (\n -> [1 .. floor (sqrt (fromIntegral n))]) 42
23:41:36 <lambdabot>   [1,2,3,4,5,6]
23:41:55 <sanguinev> mauke: Thanks! :)
23:42:08 <pumpkin> sounds like eratosthenes
23:43:08 <Ferdirand> takeWhile (<=(n*n)) [1..] ?
23:43:12 <Gracenotes> I'm noting a conspicuous omission... http://pastebay.com/
