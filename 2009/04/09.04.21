00:00:20 <Reiver> Hmm. Problem in it anyway, which I now realise should have been obvious. It keeps recycling the front elements of the first list. Whoops.
00:00:20 <Reiver> Pity, that would have been really elegant. I suppose I need that extra list afterall. >_>
00:00:20 <Gracenotes> Reiver: what if they're equal!
00:00:20 <Reiver> Gracenotes: I was going to work on that one once I had the alograthmn working first.
00:00:20 <Gracenotes> you can do equality with only two guard cases
00:00:43 <Reiver> Alas, it currently sorts myMerge [1,3,5] [2,4,6] => [1,6,4,2,3,5], because it's inserting the largest of the second list into the first one after the first value.
00:00:48 <Reiver> A slight error, I fancy. ;)
00:02:31 <Gracenotes> yes. You'll only want to merge one value per recursion
00:02:48 <Gracenotes> taking either from the first list or the second one
00:02:57 <Gracenotes> at least, to keep it simple
00:07:14 <Reiver> One at a time... oh!
00:07:27 * Reiver fiddles it.
00:08:15 <Reiver> HAH!
00:08:19 * Reiver is rather chuffed with that.
00:10:25 <Reiver> Hm. Is there any fundamental way for Haskell to tell if a list has a single object in it, and so doesn't really need to be a list any more?
00:10:47 <Gracenotes> well... you can pattern match on a single-item list
00:11:25 <Reiver> ?
00:11:53 <Gracenotes> > let foo [] = True; foo [x] = False; foo (_:_:xs) = foo xs in foo [1..11]
00:11:55 <lambdabot>   False
00:11:58 <quicksil1er> f [x] = "this list has only one item"
00:12:08 <quicksil1er> f _ = "this list has somethign other than only one item"
00:12:33 <koala_man> you mean like how x and a tuple with only x is the same thing?
00:12:34 <Gracenotes> [x] is like saying (x:[])
00:13:16 <glguy> Reiver, I think you'll have to give an example
00:13:40 <Gracenotes> for merging, cases can fall back on each other in the right order
00:15:14 <wli> Hint: Don't let patterns overlap and don't let pattern matches be incomplete.
00:15:35 <Reiver> hm.
00:16:09 <dibblego> generally try to avoid overlapping patterns
00:16:24 <Reiver> I had meant being able to tell if [6] was by itself, which then meant it no longer needed to be in a list, but I realised that x:xs is able to do that anyway - just check if xs is [], and you're golden.
00:16:40 <Reiver> Minor brainfart :)
00:16:54 <glguy> Reiver, it needs to be a list if you want functions that expect a list to know what to do with it
00:16:56 <dibblego> if xs is [] then you may as well use [x] in the pattern
00:17:13 <Reiver> Yeah, I figured that.
00:17:28 <Reiver> The question was for a half-formed idea that turned out to be irrelevant, don't mind me~
00:18:05 <glguy> GHC can do some neat tricks though with specconstr
00:18:16 * Reiver just turned myMerge into mySort after overthinking it, then writing a total of three lines. One of which was the type, and the second the [] case. :P
00:19:18 <Reiver> I must admit, I'm rather enjoying this Haskell approach.
00:19:35 <Reiver> I keep trying to overthink things, but it's oh so very less painful than java. O.o
00:19:45 <QtPlaty[HireMe]> ":" is primitive.
00:19:56 <QtPlaty[HireMe]> ?
00:20:32 <beelsebob> http://noordering.wordpress.com/2009/04/21/cabals-default-install-location/
00:20:34 <Gracenotes> : .. o
00:21:06 <Gracenotes> : is a constructor and a function
00:21:08 <quicksilver> beelsebob: haha :)
00:24:07 <wli> @type M.toAscList . foldr (flip (M.insertWith (+)) 1) M.empty
00:24:08 <lambdabot> forall b a. (Ord a, Num b) => [a] -> [(a, b)]
00:24:37 <wli> That sorts, and counts, too.
00:25:10 <quicksilver> should be insertWith' though, really
00:25:26 <wli> @type S.toList . S.fromList
00:25:27 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:25:38 <wli> Oh, sorry, yeah.
00:26:06 <wli> I should probably more routinely prime things to avoid thunk buildup esp. since that stuff is all strict anyway.
00:26:15 <harovali> hi, is there a way of mapping persisten datastructres on to a db like postgres ?
00:26:43 <glguy> toList . fromListWith (+) . map (\x -> (x,1))
00:26:46 <mmorrow> can anyone think what is might be about a pair of fd's returned from (C) pipe() (that are now bot FILE*'s via fdopen) that would make code on the write-end just hang?
00:27:07 <wli> I guess there's also...
00:27:24 <blackh> mmorrow: Not reading the read end?
00:27:26 <wli> @type M.toAscList . Map.fromListWith (+) . map (flip (,) 1)
00:27:28 <lambdabot> Couldn't find qualified module.
00:27:40 <wli> @type M.toAscList . M.fromListWith (+) . map (flip (,) 1)
00:27:40 <lambdabot> forall a b. (Ord a, Num b) => [a] -> [(a, b)]
00:27:49 <quicksilver> mmorrow: buffering. deadlocks. stuff.
00:27:53 <mmorrow> blackh: hmm. so i'm assuming that the writer is going to finish.
00:27:59 <mmorrow> quicksilver: yuk
00:28:11 <mmorrow> FILE*s are nasty
00:28:26 <quicksilver> mmorrow: you can't safely use double-ended pipes without (a) forking or (b) carefully using non-blocking IO and select().
00:28:26 <blackh> mmorrow: The writer will block until the reader reads the data.
00:28:33 <blackh> mmorrow: At least I think so.
00:28:36 <mmorrow> blackh: snap
00:28:39 <mmorrow> quicksilver: snap
00:28:46 <quicksilver> the writer will write up to OS_DEFINED_BUFFER_SIZE
00:28:50 <quicksilver> traditionally 8K
00:28:54 <glguy> pipes aren't a big truck you can just dump things on
00:28:55 <quicksilver> and then wait for the reader to read some.
00:29:15 <glguy> they are a series of tubes
00:29:25 <mmorrow> damn, the thing is the reader is this code that's reading a .bmp, so blah ..
00:29:28 <mmorrow> crap, ok.
00:30:25 <mmorrow> i really would prefer using a memory buffer as intermediary
00:30:40 <quicksilver> there are two things which people always blame on the current language they're using (be it perl, haskell, python or whatever) which are actually just OS semantics - one is the difference between terminal buffering and file buffering, and the other is the deadlocks you get from bidirectional pipes. (Not that I'm accussing mmorrow of blaming a language).
00:30:45 <mmorrow> but graphviz is on the writer-end, and the code therein is horrifying
00:31:51 <mmorrow> quicksilver: yeah, buffered IO is a pain unless you wrote the buffering code :)
00:32:34 <quicksilver> I don't honestly think it's a big pain.
00:32:36 <mmorrow> hmm, well i guess now is a good time to learn about this
00:32:43 <quicksilver> it's just something you have to understand and that understanding doesn't come for free.
00:32:54 <mmorrow> quicksilver: i'm just bitching because i don't want to have to go rtfm ;)
00:34:39 <mmorrow> hmm, the unfortunate thing though in this case is, is that i think not just one but _both_ sides are incompatible with pipes-in-the-same-process
00:34:55 <mmorrow> haskell forkIO to the rescue
00:36:06 <boegel> I blinked once (really!), and now I have a backlog of almost 2000 mails in haskell-cafe I need to get through :-/
00:36:16 <dons> hehe, vote on where cabal should install by default: http://noordering.wordpress.com/2009/04/21/cabals-default-install-location/
00:36:21 <mmorrow> wait, now that i think about it, of course they would block. it's the fact that i'm in a single process that was messing with my head.
00:39:03 <wli> > let merge [] [] = [] ; merge xs@(_:_) [] = xs ; merge [] ys@(_:_) = ys ; merge xxs@(x:xs) yys@(y:ys) = case x `compare` y of { LT -> x : merge xs yys ; GT -> y : merge xxs ys ; EQ -> x : merge xs ys } ; foldb (x:y:xs) = merge x y : foldb xs ; foldb x@[_] = x ; foldb [] = [] ; singleOrNull xs = case xs of { _:_:_ -> False ; _ -> True } in until singleOrNull foldb $ map (:[]) "asdfasdf"
00:39:04 <lambdabot>   ["adfs"]
00:39:36 * mmorrow refuses to concede and use any temp files or any external processes
00:50:02 <harovali> is non-determinism what they use in financial haskell applications , to compute assets prices accross market variables ?
00:50:03 <Reiver> ... okay, there's a classic question. Hum.
00:50:29 <wli> harovali: No, it's numerical/statistical.
00:50:34 <Reiver> write a length function that doesn't use recursion.
00:50:59 * Reiver ponders where to start, given he's been trying to use recursion, recursion, recursion till this point...
00:51:10 <Baughn> > (\l -> snd . last . zip l [1..]) "testing"
00:51:11 <lambdabot>   Couldn't match expected type `a -> [a1]'
00:51:26 <Baughn> > (\l -> snd $ last $ zip l [1..]) "testing"
00:51:28 <lambdabot>   7
00:51:31 <Reiver> wut
00:51:38 <Baughn> What?
00:51:40 <jrx_> what does that mean if I get exception: array index out of range when interpreting the code and everything is running ok when I compile it?
00:51:48 <dons> huh
00:51:59 <dons> something's wrong.
00:52:18 <quicksilver> dons: how did the hackathon go? Is anyone writing a report?
00:52:43 <wli> > foldr (\_ x -> (+x) 1) 0 "testing"
00:52:44 <lambdabot>   7
00:52:44 <hotaru2k3> @src last
00:52:44 <lambdabot> last [x]    = x
00:52:45 <lambdabot> last (_:xs) = last xs
00:52:45 <lambdabot> last []     = undefined
00:52:48 <hotaru2k3> @src zip
00:52:48 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
00:52:48 <lambdabot> zip _      _      = []
00:53:26 <wli> > foldr (const (1+)) 0 "testing"
00:53:27 <lambdabot>   7
00:53:42 <wli> > sum $ map (const 1) "testing"
00:53:43 <lambdabot>   7
00:53:55 <mmorrow> ok, so i'm going to go for forkIO'ing both the reader and the writer C functions sitting on the R and W ends of two different pairs of pipes of fd's, turned into FILE*'s with fdopen. then just spin on the fd's of the inner two ends of each pair of pipes doing read/write until finished
00:53:58 <jrx_> dons: when I compile without optimizations it fails as well, how is called that tool to find out where the exception ocurred?
00:54:21 <Baughn> > sum (map (const 1)) "testing"
00:54:22 <lambdabot>   Couldn't match expected type `[a]'
00:54:50 <wli> @type sum . map (const 1)
00:54:51 <lambdabot> forall a a1. (Num a) => [a1] -> a
00:55:03 <dons> the projects are on the wiki, quicksilver , but yes, there should be a few write ups appearing soon
00:55:15 <dons> jrx_: the ghci debugger
00:55:20 <dons> it will help you step through the code
00:57:27 <quicksilver> dons: well, how did it go for you personally? :)
00:58:13 <dons> oh, it was awesome. got a lot done. met some new people. made good progress on the platform release
00:58:38 <quicksilver> excellent.
00:58:54 <dons> utrecht is a lovely city
00:59:03 <quicksilver> never been :(
00:59:29 <mmorrow> plumb :: (CFile -> IO a) -> (CFile -> IO b) -> IO (a, b)
01:00:52 <Baughn> That's crying out for a combinator
01:01:18 <quicksilver> and a limerick
01:01:50 <Baughn> There once was a CFile from Darling
01:02:29 * Baughn ponders
01:04:17 <beelsebob> who's plumming needed some Gnarling
01:04:32 * beelsebob waits for someone to fill in the next line
01:06:15 <quicksilver> he pulled out a lambda
01:09:47 <Reiver> nrLength :: [a] -> Int
01:09:47 <Reiver> nrLength xs = foldr count 0 xs
01:09:47 <Reiver>  where count _ = count + 1
01:09:58 <Reiver> ... unification would give infinite type? Whut?
01:10:10 <PeakerWork> ghc actually uses select to multiplex stuff right? Are there any plans to use epoll or libevent such?
01:10:58 <quicksilver> Reiver: you seem to be confused if count is a number or a function.
01:11:11 <Reiver> ... ah, right. Hum.
01:11:11 <quicksilver> PeakerWork: People have discussed it. There are some bindings on hackage.
01:11:15 <Reiver> Yes, that would do it.
01:11:29 <quicksilver> I'm not sure if there are active plans to change the RTS itself
01:11:34 <PeakerWork> select is a pretty horrible system call, scaling-wise
01:12:22 <quicksilver> well, that's a very popular meme on the internets.
01:12:29 <quicksilver> however it's not really as true as people make out.
01:12:44 <quicksilver> select works beautifully for hundreds of concurrent connections.
01:13:20 <quicksilver> and how many people are really writing programs with > 100s of concurrent live fds?
01:13:53 <Axman6> i wouldn't want to make any assumptions about something like that
01:14:01 <quicksilver> it's not about making assumptions.
01:14:23 <kalven> are there advantages to using select other than portability?
01:14:29 * Axman6 reads up, only read the last line
01:15:00 <quicksilver> it's about discussing teh scale of the problem(s).
01:15:07 <quicksilver> it's really popular to say "select() sucks"
01:15:41 <quicksilver> I'm just saying, select() actualy works really well for a wide variety of cases.
01:15:48 <quicksilver> I'm not denying there are ones where it is inappropriate ;)
01:16:09 <quicksilver> you can run a really very high traffice webserver on 100 live FDs.
01:16:46 <quicksilver> kalven: compared to epoll or libevent? portability + slightly simpler API, that's all.
01:17:17 <koala_man> I read "floppy drives" there for a second
01:22:34 <mmorrow> gahr
01:24:04 <mmorrow> so it's still blocking, but probably work-around-able. i'm gonna just use a tmp file for now... :/
01:24:11 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2169#a2169
01:26:04 <mmorrow> woot, and my opengl vacuum frontend works! :)
01:27:29 <Gracenotes> 2140568834 = TWO_BILLION_ONE_HUNDRED_FOURTY_MILLION_FIVE_HUNDRED_SIXTY_EIGHT_THOUSAND_EIGHT_HUNDRED_THIRTY_FOUR
01:27:57 <Gracenotes> number -> words... looks about right to me. :x could be a bit more natural though
01:31:36 <quicksilver> Gracenotes: 'FORTY' not 'FOURTY'
01:31:49 <quicksilver> Gracenotes: in british english we use commands and the word 'and', as well :)
01:32:04 <Axman6> Gracenotes: needs ands in there
01:32:11 <Axman6> bah, beaten to it
01:32:20 <Gracenotes> quicksilver: oh, right
01:32:38 <Gracenotes> I think I put too much effort into trying to spell FORTY correctly, knowing that there was a trick
01:32:54 <Gracenotes> ... but no brainpower whatsoever
01:33:11 <Gracenotes> yeah. I think I've worked out where 'ands' and commas should go
01:35:27 <Gracenotes> hm. effectful recursion can be nice.
01:35:45 <Gracenotes> not as easy to reason about though, I think
01:48:51 <Axman6> Gracenotes: what you're doing is actuallt one of the homeworks i'm supposed to be doing for one of my comp courses :)
01:49:53 <Gracenotes> Axman6: heh. Except, I'm doing it in Java
01:50:01 <Axman6> me too :P
01:50:15 <Axman6> though, i'm not doing it
01:50:20 <Axman6> because i cbf'd
01:50:34 <Gracenotes> it's actually a simple function, as it is. I'm doing sort of a foldl, accumulating on a StringBuilder
01:51:25 <Baughn> Axman6: cbf? Call by.. fragment?
01:51:40 <Axman6> can't be fucked
01:52:36 <Gracenotes> I have three arrays: one with ZERO -> NINETEEN, another with TWENTY -> NINETY by tens, another with orders by 3: THOUSAND, MILLION, BILLION
01:53:09 <nominolo> @seen dons
01:53:10 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 54m 15s ago.
01:53:16 <Axman6> and you're fixing it to handle all the X hundrex and y'ty y's?
01:53:52 <Gracenotes> no, don't have to. >_> The example given is 513782 -> FIVE_HUNDRED_THIRTEEN_THOUSAND_SEVEN_HUNDRED_EIGHTY_TWO
01:53:59 <Axman6> lame
01:54:18 <dons> nominolo: hey
01:54:48 <Gracenotes> no ur lame
01:55:33 <Gracenotes> but yeah. Finding whether or not to add in certain commas, ands, etc. might require more information
01:56:19 <beelsebob> Gracenotes: you're missing an AND_
01:56:23 <beelsebob> or two
01:56:36 <Axman6> apparently he isn't
01:56:38 <Gracenotes> five hundred and fifty thousand five hundred and fifty. No commas. one million, five hundred and fifty thousand five hundred and fifty. a comma.
01:57:30 <beelsebob> well no – that's the way english works – you put commas in until you get to the last one, and then you put an and/or in instead to tell the reader which kind of combination you meant
01:57:46 <beelsebob> the hundreds are the last point at which you would put such a comma
01:57:50 <beelsebob> so that's where the combinator goes
01:58:01 <Gracenotes> right. This is actually generating code containing number words.. it's the assignment
01:58:02 <nominolo> dons: I sent you a mail
01:58:04 <Gracenotes> :\
01:58:07 <nominolo> regarding tomorrow
01:58:19 <Gracenotes> I'm also going absolutely wild with mutation. if ((n %= 100) == 0) return;
01:58:20 <quicksilver> beelsebob: tehre is always an 'and' in "one hundred and forty two"
01:58:29 <beelsebob> quicksilver: exactly
01:58:35 <quicksilver> beelsebob: even when it isn't the final thing
01:58:53 <Gracenotes> the rules governing 'and' are simple than those governing commas
01:58:55 <Gracenotes> imho
01:58:55 <beelsebob> that is the final point at which you could insert a comma or and
01:59:02 <quicksilver> "one hundred and forty-two thousand, five hundred and twenty-nine."
01:59:05 <quicksilver> two ands.
01:59:26 <beelsebob> quicksilver: yeh – but that's because the left hand one is essentially a seperate number
01:59:40 <quicksilver> sure
01:59:43 <quicksilver> I was just clarifying :)
01:59:48 <Gracenotes> anyway, before doing the Java version I did a Haskell version that had both commas and 'and' and dashes :P
02:00:01 <Gracenotes> except grepping... I think I might've accidentally saved it in /tmp or something :(
02:00:04 <beelsebob> that's expressing (100 + 42) * 1000 + 500 + 29, not 100000, 42000, 500 + 29
02:00:12 <Axman6> heh
02:01:13 <Gracenotes> if ((n %= 1000) >= 100) .. *eyes gleam*
02:05:06 <Reiver> ... how do you get values out of a tuple?
02:05:28 <daf> Reiver: pattern match
02:05:42 <daf> or, failing that, use fst and snd
02:05:48 <daf> assuming it's a pair
02:05:51 <Axman6> :t fst
02:05:52 <lambdabot> forall a b. (a, b) -> a
02:05:54 <Axman6> :t snd
02:05:55 <lambdabot> forall a b. (a, b) -> b
02:06:02 <Reiver> So if I have (2,3) and I want to add them together, I can use fst + snd and call it good?
02:06:15 <piksi> man, switching to haskell paradigm is so hard :-\
02:06:15 <quicksilver> > let p = (2,3) in fst p + snd p
02:06:16 <lambdabot>   5
02:06:22 <quicksilver> Reiver: somethign like that.
02:06:35 <Gracenotes> 'uncurry' would also work in that case
02:06:36 <quicksilver> > let (a,b) = (2,3) in a+b
02:06:38 <lambdabot>   5
02:06:39 <quicksilver> or that.
02:06:40 <Reiver> Excelent. Thankye. :)
02:06:50 <Axman6> piksi: think that's the first time i've heard the word paradigm used in relation to haskell...
02:06:52 <Gracenotes> > uncurry (+) (49320, 43910)
02:06:53 <hotaru2k3> let p = (2,3) in uncurry (+) p
02:06:53 <lambdabot>   93230
02:06:59 <hotaru2k3> > let p = (2,3) in uncurry (+) p
02:07:01 <lambdabot>   5
02:07:19 <Gracenotes> a function combinator Haskell provides
02:08:32 * Axman6 :o :O  :() :( ) :(   ) :[   ] :[    ] :|     | Xo sneezes
02:08:33 <GoldyOrNugget> if im checking that all the items in a list are True, do i have to say "all (==True)?
02:09:00 <fasta> GoldyOrNugget: and
02:09:08 <Gracenotes> @src and
02:09:08 <lambdabot> and   =  foldr (&&) True
02:09:19 <Gracenotes> @src all
02:09:19 <lambdabot> all p =  and . map p
02:09:29 <GoldyOrNugget> > and [True, True]
02:09:31 <lambdabot>   True
02:09:34 <GoldyOrNugget> >and [True, False]
02:09:40 <GoldyOrNugget> > and [True, False]
02:09:42 <lambdabot>   False
02:09:44 <GoldyOrNugget> thanks!
02:10:10 <GoldyOrNugget> haskell makes me think :(
02:10:11 <GoldyOrNugget> *:)
02:10:21 <Reiver> Hrm. So how does one implement the let command into a line of code?
02:10:34 <quicksilver> you can certainly use let in a line of code.
02:10:42 <GoldyOrNugget> > let x = 5 in x*3
02:10:44 <lambdabot>   15
02:10:45 <quicksilver> would you like to show us some code you're trying to make work?
02:10:53 <Reiver> addEachPair :: [(Int,Int)] -> [Int]
02:10:54 <Reiver> addEachPair (x:xs) =
02:11:32 <Reiver> I'm just trying little bits and peices with the Hugs interpreter to get my head around things. I got things into tuples; now I'm trying to get them out. :)
02:12:21 <GoldyOrNugget> im also learning haskell
02:12:39 <Philonous1> > map (uncurry (+)) [(1,2),(2,5),(10,100)]
02:12:41 <lambdabot>   [3,7,110]
02:13:01 <bryan1> addEarParis((n1,n2):xs) = n1 : n2 : addEachPairs ns
02:13:38 <Philonous1> > map (uncurry (:)) [(1,2),(2,5),(10,100)]
02:13:39 <lambdabot>       No instance for (Num [a])
02:13:40 <lambdabot>        arising from the literal `2' at <inter...
02:13:50 <bryan1> :)
02:13:56 <GoldyOrNugget> > let addEachPair ((n1, n2):xs) = n1+n2:addEachPair xs
02:13:57 <lambdabot>   <no location info>: parse error on input `;'
02:14:01 <GoldyOrNugget> :(
02:14:03 <idnar> @type uncurry (:)
02:14:05 <lambdabot> forall a. (a, [a]) -> [a]
02:14:15 <Philonous1> > concatMap (\(x,y) -> [x,y]) [(1,2),(2,5),(10,100)]
02:14:16 <lambdabot>   [1,2,2,5,10,100]
02:14:31 <GoldyOrNugget> > let addEachPair ((n1, n2):xs) = (n1+n2):addEachPair xs
02:14:33 <lambdabot>   <no location info>: parse error on input `;'
02:14:36 <idnar> > let addEachPair ((n1, n2):xs) = n1+n2:addEachPair xs; addEachPair [] = [] in addEachPair [(1,2),(2,5),(10,100)]
02:14:38 <lambdabot>   [3,7,110]
02:14:45 <GoldyOrNugget> ah
02:14:46 <idnar> you need the base case and an "in"
02:14:57 <GoldyOrNugget> ok, ive never used lambdabot before
02:15:21 <Axman6> > map (uncurry (+)) [(1,2),(2,5),(10,100)]
02:15:22 <lambdabot>   [3,7,110]
02:15:41 <quicksilver> Reiver: addEachPair (x:xs) = (fst x, snd x) : addEachPair xs
02:15:44 <quicksilver> Reiver: is one way.
02:15:57 <quicksilver> Reiver: addEachPair (x:xs) = let (a,b) = x in (a,b) : addEachPair xs
02:15:59 <quicksilver> Reiver: is another.
02:16:08 <quicksilver> Reiver: and GoldyOrNugget showed you a third.
02:16:17 <Axman6> except that both of those are == id...
02:16:24 <bryan1>  [ x + y | (x,y) <- [(1,2),(2,3),(10,100)]]
02:16:47 <Reiver> hm.
02:17:05 <Axman6> dons: do you know who's in charge of the reddit_haskell tritter bot?
02:17:30 <Gracenotes> there's not really a one-list or two-list function. for the former there's 'return', although that's general for monads
02:17:39 <Gracenotes> @pl \a b -> a:b:[]
02:17:40 <lambdabot> (. return) . (:)
02:17:57 <Gracenotes> so-so
02:20:53 <PeakerWork> @type [(. return) . (:), (result . result) return (:)]
02:20:54 <lambdabot> Not in scope: `result'
02:20:54 <lambdabot> Not in scope: `result'
02:20:59 <PeakerWork> @let result = (.)
02:21:00 <lambdabot>  Defined.
02:21:05 <PeakerWork> @let argument = flip (.)
02:21:06 <lambdabot>  Defined.
02:21:08 <PeakerWork> @type [(. return) . (:), (result . result) return (:)]
02:21:09 <lambdabot>     Occurs check: cannot construct the infinite type: b = [b]
02:21:09 <lambdabot>       Expected type: b -> b -> b
02:21:09 <lambdabot>       Inferred type: b -> [b] -> [b]
02:21:11 <Gracenotes> (.).(.)
02:21:21 <PeakerWork> @type (. return) . (:)
02:21:22 <lambdabot> forall a. a -> a -> [a]
02:21:30 <PeakerWork> @type (result . result) return (:)
02:21:31 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> [a] -> m [a]
02:21:58 <PeakerWork> @type (result . argument) return (:)
02:21:59 <lambdabot> forall a. a -> a -> [a]
02:22:59 <PeakerWork> @let infixr 2 ~> ; f ~> g = argument f . result g
02:23:00 <lambdabot>  Defined.
02:23:14 <PeakerWork> @type (id ~> return ~> id) (:)
02:23:15 <lambdabot> forall a. a -> a -> [a]
02:23:44 <Gracenotes> .-. niec.
02:24:32 <hotaru2k3> ls
02:24:39 <PeakerWork> basically apply return on the rhs of (:) and otherwise don't do anything :)
02:24:39 <hotaru2k3> oops, wrong window
02:25:26 <PeakerWork> alternatively:
02:25:28 <PeakerWork> @unlet
02:25:29 <lambdabot>  Defined.
02:25:29 <PeakerWork> @undef
02:26:15 <PeakerWork> @let result = (<<<) ; argument = (>>>) ; infixr ~> 2 ; (f ~> g) x = f >>> x >>> g
02:26:15 <lambdabot>   Parse error
02:26:21 <PeakerWork> @let result = (<<<) ; argument = (>>>)
02:26:22 <lambdabot>  Defined.
02:26:28 <PeakerWork> @let infixr ~> 2 ; (f ~> g) x = f >>> x >>> g
02:26:29 <lambdabot>   Parse error
02:26:35 <PeakerWork> @let infixr 2 ~> ; (f ~> g) x = f >>> x >>> g
02:26:36 <lambdabot>  Defined.
02:26:41 <PeakerWork> @type (~>)
02:26:42 <lambdabot> forall (a :: * -> * -> *) b c c1 d. (Arrow a) => a b c -> a c1 d -> a c c1 -> a b d
02:26:53 <PeakerWork> @type result
02:26:54 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
02:26:56 <PeakerWork> @type argument
02:26:57 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
02:27:07 <PeakerWork> @type (id ~> return ~> id) (:)
02:27:09 <lambdabot> forall a. a -> a -> [a]
02:28:46 <GoldyOrNugget> is it possible to remove an element from a list based on what it is, not its position?
02:28:58 <GoldyOrNugget> like, [1,2,3] remove 2 == [1,3]
02:29:22 <Axman6> sure. delete
02:29:25 <Axman6> :t telete
02:29:26 <lambdabot> Not in scope: `telete'
02:29:29 <Axman6> :t delete
02:29:30 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
02:29:35 <GoldyOrNugget> > delete 2 [1,2,3]
02:29:37 <lambdabot>   [1,3]
02:29:37 <Axman6> > delete 2 [1..10]
02:29:38 <lambdabot>   [1,3,4,5,6,7,8,9,10]
02:29:43 <GoldyOrNugget> > delete 2 [1,2, 2,3]
02:29:45 <lambdabot>   [1,2,3]
02:29:48 <GoldyOrNugget> thanks!
02:29:56 <Gracenotes> yah, a one-delete
02:30:13 <GoldyOrNugget> thats what i wanted :)
02:30:18 <mmorrow> here's an initial (working) version of vacuum-gl http://moonpatio.com/repos/vacuum-gl/
02:30:35 <mmorrow> the code needs tidying ..., but it works
02:31:00 <TheRealMarko> > filter (\x -> x /= 2) [1,2,2,3,4]
02:31:02 <lambdabot>   [1,3,4]
02:31:41 <Ralith> > filter (/=2) [1,2,2,3,4]
02:31:42 <lambdabot>   [1,3,4]
02:31:45 <Ralith> TheRealMarko: ^
02:31:55 <GoldyOrNugget> It's telling me 'not in scope 'delete''
02:32:02 <Ralith> @hoogle delete
02:32:03 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
02:32:03 <lambdabot> Data.IntMap delete :: Key -> IntMap a -> IntMap a
02:32:03 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
02:32:22 <GoldyOrNugget> Prelude> delete 2 [1,2,3]
02:32:23 <GoldyOrNugget> <interactive>:1:0: Not in scope: `delete'
02:32:41 <TheRealMarko> GoldyOrNugget: :m +Data.List
02:33:16 <GoldyOrNugget> and how can i do that in a saved file?
02:33:29 <GoldyOrNugget> import +Data.List?
02:33:36 <TheRealMarko> yep
02:33:42 <TheRealMarko> wihtout the "+"
02:34:34 <GoldyOrNugget> thanks, works perfectly!
02:34:48 <TheRealMarko> :)
02:36:32 <GoldyOrNugget> yay, my first project euler problem done only in haskell!
02:36:33 <TheRealMarko> Ralith: thx, much better
02:36:40 <Ralith> ^^
02:36:40 <Ralith> np
02:37:08 <fasta> Is there any Haskell compiler/interpreter that works on the PS3?
02:37:25 <Ralith> (\x -> x foo bar) == (foo bar)
02:37:41 <Ralith> fasta: on ps3 linux it wouldn't be hard to port one
02:38:20 <fasta> Apparently, this guy already did it: http://xmonad.wordpress.com/2009/04/02/xmonad-on-the-playstation-3/
02:38:27 <Ralith> cool
02:38:40 <fasta> I am just not sure what exactly it is that the
02:38:44 <fasta> he* did.
02:41:43 <beelsebob> that would be *extremely* cool actually
02:41:55 <beelsebob> have one of the analog sticks dedicated to playing around with your windows
02:42:31 <Axman6> i really want a PS3 :(
02:42:40 <Axman6> and a T2 UltraSPARC :(
02:43:04 <p_l> heh
02:43:16 <beelsebob> my poll actually has come out with a really really good solution to the cabal install problem
02:43:25 <beelsebob> if it's running as root, it should do a global install
02:43:26 <Axman6> luckily i get to play with our uni's T2 later this semester :D
02:43:30 <beelsebob> if it's not, it should do a user install
02:43:47 <Axman6> beelsebob: makes sense to be
02:44:52 <dibblego> is zip derivable from any of the handy type-classes?
02:45:10 <beelsebob> dibblego: zip?
02:45:19 <dibblego> @type zip
02:45:20 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
02:45:27 <beelsebob> well that answers your question
02:45:30 <beelsebob> no type class in there
02:45:43 <tikel> :t ZipList
02:45:44 <lambdabot> forall a. [a] -> ZipList a
02:46:12 <dibblego> m a -> m b -> m (a, b)
02:46:43 <Axman6> that's just liftM2 (,) isn't it?
02:46:45 <Gracenotes> ZipList is my favorite Applicative-for-list instance :3
02:46:46 <Axman6> well, maybe not
02:47:34 <beelsebob> Axman6: you mean <^(,)^>?
02:47:48 <Axman6> git your crazy bats away from me!
02:47:49 <Gracenotes> @type liftA2 (,)
02:47:50 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
02:48:03 <Axman6> @src liftA2
02:48:03 <lambdabot> liftA2 f a b = f <$> a <*> b
02:48:30 <Axman6> oh wait up, i know GoldyOrNugget i think :o
02:48:37 <Axman6> maybe not
02:49:19 <dibblego> > merge [1,2,3,4] [10, 20, 30, 40]
02:49:21 <lambdabot>   [1,10,2,20,3,30,4,40]
02:49:34 <Gracenotes> @type let pair = liftA2 (,) in \a b -> uncurry ($) <$> pair a b
02:49:35 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f (a -> b) -> f a -> f b
02:49:50 <dibblego> > merge [1,2,3,4] [10, 20, 30, 40] -- really I want this but abstracting on []
02:49:51 <Gracenotes> @type (<*>)
02:49:52 <lambdabot>   [1,10,2,20,3,30,4,40]
02:49:52 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:53:04 <alar> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
02:53:04 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
02:53:12 <alar> broken bot :(
02:53:19 <Axman6> yes
02:53:20 <mmorrow> , [$bf|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
02:53:20 <Gracenotes> dibblego: to a list specifically? or to the same structure you put in?
02:53:22 <lunabot>  "Hello World!\n"
02:53:38 <Axman6> , text [$bf|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
02:53:40 <lunabot>  luna: Couldn't match expected type `GHC.Base.String'
02:53:41 <mmorrow> , [$bf2|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] ""
02:53:42 <lunabot>  ("Hello World!\n",(4,Mem (fromList [(0,0),(1,87),(2,100),(3,33),(4,10)])))
02:53:51 <Axman6> , text ([$bf|++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.|] "")
02:53:52 <lunabot>  Hello World!
02:54:08 <mmorrow> , [$bf|.+[.+]|] ""
02:54:10 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
02:54:39 <quicksilver> dibblego: what structure is more abstract than list but still supports that?
02:54:46 <alar> wow!
02:54:50 <dibblego> Gracenotes, the same that is put in
02:54:51 <alar> TH bot
02:55:05 <Axman6> yup
02:55:07 <mmorrow> , [|\x->x|]
02:55:08 <lunabot>  LamE [VarP x_0] (VarE x_0)
02:55:17 <Gracenotes> hm. Perhaps a monad could handle that .. fmap and join
02:55:23 <dibblego> quicksilver, a strict list for example
02:55:31 <Axman6> , [|\x -> x + x|]
02:55:32 <lunabot>  LamE [VarP x_0] (InfixE (Just (VarE x_0)) (VarE +) (Just (VarE x_0)))
02:55:43 <Axman6> , [|\x -> x +|]
02:55:44 <lunabot>  luna: parse error on input `]'
02:55:50 <Gracenotes> maybe you'd need a monoid too. hm.
02:55:55 <dibblego> Gracenotes, I can only think of using MonadPlus
02:55:56 <Axman6> , [|\x -> (x+)|]
02:55:57 <lunabot>  LamE [VarP x_0] (InfixE (Just (VarE x_0)) (VarE +) Nothing)
02:56:05 <Gracenotes> dibblego: ah, right. MonadPlus = monad monoid
02:56:14 <mmorrow> , ppDoc `fmap` [|\x->x|]
02:56:15 <lunabot>  \x_0 -> x_0
02:56:28 <dibblego> Gracenotes, yeah but it seems excessive, so I was thinking of Traversable perhaps -- but I'm a bit toasted atm
02:57:49 <Gracenotes> Traversable provides a means of going through the list, but not really generating anything
02:57:51 <quicksilver> traversable is not sufficient.
02:58:06 <quicksilver> traversable can only produce new things of precisely the same 'shape' as the old
02:58:11 <PeakerWork> @src Traversable
02:58:11 <lambdabot> class (Functor t, Foldable t) => Traversable t where
02:58:11 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
02:58:11 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
02:58:11 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
02:58:11 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
02:58:14 <quicksilver> it can never produce an 8-element thing from two 4-element things.
02:58:43 <quicksilver> I suspect you literally want to abstract over the definition of listt
02:58:49 <quicksilver> abstract over (:) and []
02:58:51 <Gracenotes> right. no generation, which monads and monoids can do... except those can't break apart a list
02:58:52 <quicksilver> but there's no point doing that.
02:59:07 <quicksilver> list itself is the initial object of things which have (:) and []
02:59:11 <Gracenotes> such that the elements can be interleaved
02:59:12 <quicksilver> so just use list :P
02:59:58 <dibblego> data StrictList a = Nil | Cons !a !(StrictList a)
03:00:19 <Gracenotes> type families?
03:00:35 <dibblego> Foldable in and MonadPlus out could do it I suppose
03:00:42 <Axman6> can a strict list like that ever be infinite? or does the whole thing need to be evaluated at once?
03:00:54 <beelsebob> Axman6: it can't
03:01:05 <Axman6> yeah didn't think so
03:01:20 <beelsebob> it's not that "all" of it needs to be evaluated
03:01:27 <beelsebob> the elements only get evelauted to WHNF
03:01:34 <beelsebob> but the spine does need to be evaluated
03:01:50 <Axman6> but you couldn't have toStrictList [1..] for instance
03:02:02 <dibblego> Axman6, that function won't terminate
03:02:11 <beelsebob> nope, you couldn't
03:02:11 <dibblego> except when it blows up
03:02:14 <Axman6> yeah, that's what i was wondering about
03:03:39 <Gracenotes> > let blah a b = join $ liftA2 (\x y -> pure x `mappend` pure y) a b in blah [1,2,3] [4,5,6]
03:03:40 <lambdabot>       Ambiguous occurrence `pure'
03:03:41 <lambdabot>      It could refer to either `Control.Appl...
03:04:00 <Gracenotes> @type L.pure
03:04:01 <lambdabot> Not in scope: `L.pure'
03:04:06 <Gracenotes> :\
03:04:15 <quicksilver> who's lambdabot are we using these days?
03:04:18 <quicksilver> is it stil cale's?
03:04:35 <Gracenotes> for that to work you'd need a ZipList, except monoid/monad isn't defined for it
03:05:56 <beelsebob> monad can't sensibly be defined for it can it?
03:06:03 <beelsebob> although monoid should be easy enough
03:06:19 <Reiver> annulus :: Radius -> Radius -> Region
03:06:20 <Reiver> annulus r1 r2 = Intersect (Shape (circle r2) (Complement Shape (circle r1)))
03:06:21 <beelsebob> (it's the same as for normal lists isn't it)
03:06:40 <Reiver> annulus :: Radius -> Radius -> Region
03:06:41 <Reiver> annulus r1 r2 = Intersect (Shape (circle r2) (Complement Shape (circle r1)))
03:06:43 <Reiver> er, sorry
03:07:08 <Reiver> I was just trying to ask if I'd done something wrong here, syntax wise.
03:07:57 <tikel> Reiver: did you mean Complement (Shape ...)?
03:08:17 <Reiver> There we go. Thank you. :)
03:08:53 <jedai> annulus r1 r2 = Intersect (Shape $ circle r2) (Complement $ Shape (circle r1))
03:09:08 <jedai> Reiver: Also you had a problem with the parentheses
03:09:13 <Reiver> What are the $ doing?
03:09:22 <Axman6> @src ($)
03:09:22 <lambdabot> f $ x = f x
03:09:23 <jedai> Reiver: Intersect had only one argument
03:09:53 <beelsebob> let sCircel = Shape . circle in annulus r1 r2 = (sCircle $ r2) `Intersect` (Complement . sCircle $ r1)
03:09:54 <Philonous1> Reiver: ($) has a low precedence, so it saves you some parens
03:10:11 <Reiver> Aaah. I've not seen those yet.
03:10:13 <beelsebob> s/in/;/
03:10:25 <Reiver> What would it look like without the $s, then?
03:10:38 * Reiver is trying to see what they do regarding clarity.
03:10:52 <beelsebob> Reiver: like you had it – lots of parentheses all over the place
03:10:59 <Philonous1> f $ g x = f (g x)
03:11:03 <jedai> annulus r1 r2 = Intersect (Shape (circle r2)) (Complement (Shape (circle r1)))
03:11:22 <Philonous1>  (Complement $ Shape (circle r1)) would become  (Complement ( Shape (circle r1)))
03:11:23 <jedai> Reiver: Isn't it ugly and clear as mud ?
03:11:24 <beelsebob> let sCircle = Shape . circle; annulus r1 r2 = sCircle r2 `Intersect` (Complement . sCircle $ r1) -- this is what I meant
03:11:34 <Reiver> jedai: Aha. Yes, it is rather less clear. :)
03:11:53 <Reiver> (And yet I'm rather used to it, given I've come from a java/C background... ;) )
03:12:01 <jedai> Reiver: Of course beelsebob version is probably even clearer
03:12:26 <Reiver> ... yeah, I tend to forget you can do that.
03:12:36 <Reiver> It's a nifty trick.
03:12:47 <beelsebob> in fact, better yet, let sCircle = Shape . circle; annulus = Intersect <$> (Complement . sCircle) <*> sCircle
03:12:51 <Reiver> "Oh, I'll just make this read more like english by shoving my function in /between/ my variables."
03:13:10 <Reiver> What are the dots doing?
03:13:18 <jedai> Reiver: Yes I know, I really appreciate ($) sometimes. Especially since comparing to C or Java we tend to compose more functions in Haskell
03:13:23 <beelsebob> and finally... annulus = (Complement . sCircle) <^(Intersect)^> sCircle
03:13:29 <beelsebob> Reiver: (.) means "after"
03:13:40 <Reiver> Hm.
03:13:41 <jedai> Reiver: The dot is function composition
03:13:42 <beelsebob> @src (.)
03:13:42 <lambdabot> (f . g) x = f (g x)
03:13:51 <Philonous1> Reiver: The dot composes two functions.
03:13:58 * Reiver stares at the last one.
03:14:01 <jedai> Reiver: like in math, (f . g)(x) = f(g(x))
03:14:38 <Reiver> I, uh, think I'll stick with my parenthesies for the moment. >_>
03:14:42 <beelsebob> hehe
03:14:53 <tikel> Reiver: do you know shell pipes?
03:14:57 <Reiver> $ and `function` are good to know, though.
03:15:02 <PeakerWork> @type function
03:15:03 <lambdabot> Not in scope: `function'
03:15:10 <beelsebob> Reiver: I'd try and make an effort to learn (.) and ($) - they save a lot of parens, but the <^ ^> version is a bit silly for a beginner
03:15:17 <jedai> Reiver: Yeah, the latest versions are pretty crazy (do they even really works ?)
03:15:28 <Reiver> beelsebob: Oh, I'm going to remember $, that one's nice.
03:15:41 <Reiver> The . syntax is a little less intuitive, but I'll work on it for a bit.
03:16:09 * Axman6 notes that (.) isn't syntax, it's also a function
03:16:10 <jedai> Reiver: The style you'll find in many Haskell program is a lot of (.) and a ($) to apply the pipeline
03:16:34 <beelsebob> Reiver: (.) is actually slightly more useful than ($)
03:16:39 <Philonous1> Reiver: Btw. ($) is usefull in other ways, too.
03:16:40 <jedai> > map (5*) . filter odd . takeWhile (<10) $ [1..]
03:16:41 <lambdabot>   [5,15,25,35,45]
03:17:01 <jedai> Reiver: like this ^
03:17:06 * Reiver eyes that.
03:17:14 <Philonous1> > zipWith ($) [(\x -> x+1), (\x -> x*2), (\z -> 5)] [1..3]
03:17:16 <lambdabot>   [2,4,5]
03:17:20 <beelsebob> Reiver: take your example there... I can write it as (Complement $ Shape $ Circle $ r2)
03:17:27 <beelsebob> meaning take r2
03:17:28 <beelsebob> apply circle
03:17:32 <beelsebob> apply Shape to that
03:17:36 <beelsebob> aply Complement to that
03:17:46 <Reiver> Right. And even that is better than parenthesis soup.
03:17:49 <beelsebob> alternatively I can write (Complement . Shape . Circle $ r2)
03:17:57 <beelsebob> this means build a function
03:18:04 <beelsebob> that applies Circle, then Shape then Complement
03:18:08 <beelsebob> and apply that to r2
03:18:16 <Reiver> ... aha. Hrm.
03:18:19 <mmorrow> , (negate . subtract 4 . (*3) . (id::Int->Int) . read . show . length . show) 42
03:18:19 <beelsebob> the advantage of this is that it's eaier to refactor
03:18:21 <lunabot>  -2
03:18:29 <beelsebob> I can go "hmm, Shape . circle is a useful function"
03:18:31 <beelsebob> and pull that out
03:18:38 <beelsebob> sCircle = Shape . circle
03:18:52 <beelsebob> now I can simplify the original code with (Complement . sCircle $ r2)
03:19:01 <Reiver> How so, if you don't mind my asking? It looks essentially the same as $. (Which of course means I've missed something~)
03:19:11 <mmorrow> print . length . lines =<< getContents
03:19:27 <beelsebob> Reiver: well, the two are very similar, but not quite the same
03:19:31 <beelsebob> (.) works on the function level
03:19:39 <beelsebob> it accepts two functions, and puts them together to make a new one
03:19:40 <mmorrow> @type (+1) . (*8)
03:19:41 <lambdabot> forall a. (Num a) => a -> a
03:19:45 <mmorrow> @type (+1) $ (*8)
03:19:46 <RayNbow> > getZipList $ ZipList [(\x -> x+1), (\x -> x*2), (\z -> 5)] <*> ZipList [1..3]
03:19:46 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
03:19:47 <lambdabot>   [2,4,5]
03:19:53 <Reiver> Right
03:19:54 <beelsebob> ($) works on the argument level though – it applies functions to arguments
03:20:00 <beelsebob> so ($) can't exist without any arguments
03:20:01 <romildo> Hi.
03:20:02 <Axman6> Reiver: in many cases they can be interchanged, but the general pattern is f . g . h $ x
03:20:07 <mmorrow> ($) is actually id
03:20:23 <mmorrow> , zipWith id [(*2),(+1),negate] [1..]
03:20:25 <lunabot>  [2,3,-3]
03:20:27 <beelsebob> :t (?f . ?g)
03:20:29 <lambdabot> forall b c a. (?g::a -> b, ?f::b -> c) => a -> c
03:20:36 <mmorrow> @type [id,($)]
03:20:37 <lambdabot> forall a b. [(a -> b) -> a -> b]
03:20:39 <RayNbow> mmorrow: except the fixity and precedence ;)
03:20:43 * PeakerWork has created a cool proof-of-concept class like Arbitrary -- but that allows IO'd user input to be used
03:20:46 <Reiver> ... so $ is used in place of a pair of parenthesis to make things clearer, while . is used to apply one function to another?
03:20:55 <jedai> mmorrow: Well it's a type restricted specialization of id, with fixity and precedence
03:20:56 <quicksilver> Reiver: to the result of another.
03:20:58 <beelsebob> Reiver: not to apply one function to another
03:21:09 <Zao> (.) is function duct tape
03:21:11 <beelsebob> what quicksilver said
03:21:13 <PeakerWork> @src TypeRep
03:21:13 <lambdabot> Source not found.
03:21:17 <PeakerWork> @src Typeable
03:21:17 <lambdabot> Source not found. My brain just exploded
03:21:28 <Reiver> Okay then.
03:21:29 <beelsebob> Reiver: think of it like | in shell scripting
03:21:30 <PeakerWork> Can TypeRep (or whatever its name is) be used to get a runtime string name of the type?
03:21:34 <romildo> I want to use regex to collect some information from text in an application I am rewriting from Java. It should deal correctly with unicode.
03:21:38 <beelsebob> only backwards
03:21:39 <quicksilver> "f . g" applies f to the result of g; or more accurately, "f.g" is that function which first applies g then applies f to the result of g.
03:21:43 <quicksilver> PeakerWork: yes, it has a show instance.
03:21:47 <beelsebob> you take the output from the right hand one, and push it through the left hand one
03:21:50 <quicksilver> PeakerWork: it's not very good though, it doesn't include module information.
03:21:57 <Reiver> The difference seems extremely subtle, but I'll take your word for it :)
03:22:10 <mmorrow> cat | od | head -20 | wc -l
03:22:11 <romildo> As this is the first time I use regex in a Haskell program, I am not sure which regex backend is the best for me.
03:22:11 <Axman6> Reiver: it is subtle :)
03:22:20 <jedai> Reiver: Try to use both for a time, you'll get the feel for it
03:22:25 <Reiver> Yeah. Hm.
03:22:44 <Reiver> I think I'll stick with the basics for the immediate moment, then come back to it once I've got my head around the nuances a little better.
03:22:56 <Axman6> Reiver: but in general, all you need to do it use them like f . g . h $ x and you'll be fine
03:23:00 <jedai> romildo: regex-pcre is pretty fast I think, it's supposed to be able to handle utf8 encoded ByteString but I never tried
03:23:26 <Reiver> Axman6: And that's the equivalent of f(g(h(x))) ?
03:23:30 <Axman6> yep
03:23:30 <mmorrow> (h . g . f)
03:23:39 <mmorrow> (f . g . h)
03:23:40 <mmorrow> :)
03:23:46 <jedai> romildo: you also have the recent regex-tdfa-utf8 which is an extension of regex-tdfa (regex engine used by Yi) for utf8
03:23:53 <Reiver> Hm. Okay.
03:24:07 <Axman6> Reiver: do you know about function composition in mathematics?
03:24:15 <mmorrow> Reiver: the functions become the arguments now
03:24:33 <beelsebob> > let f = (+1); g = (*2) in f . g $ 1
03:24:34 <lambdabot>   3
03:24:35 <Axman6> @src (.)
03:24:35 <lambdabot> (f . g) x = f (g x)
03:24:37 <Axman6> @src ($)
03:24:37 <lambdabot> f $ x = f x
03:24:38 <beelsebob> > let f = (+1); g = (*2) in f $ g $ 1
03:24:39 <lambdabot>   3
03:24:48 <romildo> I installed the regex-pcre package on my gentoo linux system, but when trying to use it in ghci, I get the error:
03:24:50 <romildo> Loading package regex-pcre-0.94.1 ... can't load .so/.DLL for: pcre (/usr/lib64/libpcre.so: invalid ELF header)
03:24:52 <beelsebob> @type let f = (+1); g = (*2) in (f . g)
03:24:53 <lambdabot> forall a. (Num a) => a -> a
03:24:56 <beelsebob> @type let f = (+1); g = (*2) in (f $ g)
03:24:57 <lambdabot> forall a. (Num (a -> a), Num a) => a -> a
03:25:09 <beelsebob> Reiver: look at those two type sigs
03:25:18 <beelsebob> see how the second one requires a num instance for functions
03:25:25 <Axman6> ok, now you're making things comfusing again beelsebob :P
03:25:26 <mmorrow> @type \n -> foldr (.) id . replicate n
03:25:27 <lambdabot> forall a. Int -> (a -> a) -> a -> a
03:25:32 <beelsebob> we can't apply f to a function
03:25:34 <PeakerWork> quicksilver: thanks
03:25:34 <mmorrow> "ntimes"
03:25:35 <beelsebob> because it expects numbers
03:25:50 <beelsebob> but we can do f *after* a function
03:25:54 <romildo> /usr/lib64/libpcre.so is a GNU ld script. It contains the lines:
03:25:56 <romildo> OUTPUT_FORMAT ( elf64-x86-64 )
03:26:01 <mmorrow> , (\n -> foldr (.) id . replicate n) 8 (*2) 1
03:26:01 <beelsebob> (as long as that function returns numbers)
03:26:02 <lunabot>  256
03:26:05 <romildo> GROUP ( /lib64/libpcre.so.0 )
03:26:34 <mmorrow> , (\n -> foldr (+) 0 . replicate n) 8 8
03:26:36 <lunabot>  64
03:26:39 <mmorrow> , (\n -> foldr (.) id . replicate n) 8 (*2) 1
03:26:41 <lunabot>  256
03:26:54 <Reiver> hrm.
03:27:22 <romildo> Because of that, regex-pcre is not working on my system. So I left it to be tested later.
03:27:28 <jedai> Reiver: You'll find that in time you'll get used to the idea that functions are value like any others
03:27:50 <Reiver> Yeah, I'm starting to get the feel for it, but it's still mighty strange :)
03:28:04 <romildo> jedai, regex-tdfa does not seems to handle unicode on String, as stated in his documentation.
03:28:21 <Reiver> Like the question that stumped me a while back: "What is the value of (2 *) ?"
03:28:34 <jedai> romildo: I said regex-tdfa-utf8, it's a new package on hackage, pretty recent
03:28:37 <beelsebob> Reiver: well, it's a function
03:28:42 <beelsebob> it's a function that multiplies things by two
03:28:48 <Reiver> Yeah.
03:29:00 <beelsebob> (+1) . (2*) is also a function
03:29:07 <beelsebob> it's a function that multipies things by two, and then adds 1
03:29:09 <dibblego> int method(int n) { return n * 2; } // you might remember it looks like this :)
03:29:21 <PeakerWork> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4011#a4011  -- I wonder if I can get rid of the type signature on run calls
03:30:04 <Reiver> dibblego: Hah, yeah.
03:30:10 <PeakerWork> I think its pretty cool I can:  (run (++"hello") :: IO String) >>= printLn     and get an automated IO String action that asks the user for a string
03:30:14 <Reiver> I got what it did, but the question "What is its value?" really threw me.
03:30:17 <romildo> jedai, isn't regex-tdfa-utf8 needed only if the string type is ByteString.Lazy?
03:30:23 <PeakerWork> However, it would be cooler if (run (++"hello")) >>= printLn    worked
03:30:37 <romildo> jedai, The documentation says: Depending on the text being searched this package supports Unicode. The [Char] and (Seq Char) text types support Unicode. The ByteString and ByteString.Lazy text types only support ASCII. It is possible to support utf8 encoded ByteString.Lazy by using regex-tdfa and regex-tdfa-utf8 packages together (required the utf8-string package).
03:30:59 <kadaver> so is there a hadoop interface in haskell?
03:31:38 <romildo> jedai, from that, I understand that regex-tdfa-utf8 is not needed for handling unicode with [Char]. Am I wrong?
03:33:31 <jedai> romildo: Maybe :)
03:34:28 <jedai> romildo: Though if you want to handle huge amount of text, you better have ByteString support anyway
03:35:15 <romildo> jedai, but it is not working without regex-tdfa-utf8:Prelude Text.Regex.TDFA> "jos. romildo" =~ "josé romildo" :: String
03:35:15 <romildo> ""
03:36:04 <tikel> romildo: isn't that the wrong way around?
03:36:37 <jedai> romildo: If you're trying in GHCi, it will probably not work, given that GHCi doesn't support unicode
03:36:45 <romildo> tikel, oh! :(
03:36:50 <tikel> my ghci does
03:37:31 <tikel> but you can check with 'map fromEnum "é"'
03:37:35 <PeakerWork> can anyone help get rid of the type signatures in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4011#a4011 ?
03:37:41 <romildo> tikel, the use of the operator should be    text =~ regex           right?
03:37:52 <tikel> I think so, yes
03:38:01 <lepassive> what is a factor and a term ?
03:38:28 <romildo> Prelude Text.Regex.TDFA> map fromEnum "é"
03:38:28 <romildo> [233]
03:38:53 <tikel> romildo: everything is ok there
03:39:12 <romildo> tikel, so I was reversing the operands. sorry. now it works.
03:40:52 <romildo> It seems that regex-tdfa does not implement the functions mkRegex and matchRegex. That are the ones I would like to use.
03:42:01 <jedai> romildo: It inherits regex-base, so it should
03:42:32 <jedai> tikel: what's your ghci version (here it doesn't seem to handle unicode) ?
03:42:51 <jedai> tikel: I use ghci-haskeline to get a nicer ghci
03:43:19 <PeakerWork> @where dons blog
03:43:19 <lambdabot> http://www.cse.unsw.edu.au/~dons
03:43:34 <Axman6> donsbot.blogger.com i think
03:43:41 <romildo> On my system I am trying:
03:43:41 <Axman6> go, maybe not
03:43:42 <romildo> Prelude> :m + Text.Regex.TDFA
03:43:42 <romildo> Prelude Text.Regex.TDFA> :t matchRegex
03:43:42 <romildo> <interactive>:1:0: Not in scope: `matchRegex'
03:43:43 <Axman6> no*
03:43:48 <lepassive> Hello can anyone explain it for me ?
03:43:53 <Axman6> wordpress.com even
03:43:56 <PeakerWork> I'm looking for the median optimization by dons, anyone has the link?
03:43:59 <lepassive> http://donsbot.wordpress.com/
03:44:09 <Axman6> lepassive: explain what?
03:44:17 <Axman6> oh, factor/term
03:44:33 <lepassive> Axman6, yes i got stuck there
03:44:42 * Axman6 has no idea
03:44:42 <romildo> jedai, Is there any other module I should load to have matchRegex with regex-tdfa?
03:44:50 <tikel> jedai: 6.10.2
03:45:03 <lepassive> :(
03:45:05 <kadaver> so is there a hadoop interface in haskell?
03:45:15 <kadaver> hmm i shouldmake one perhaps
03:45:20 <kadaver> ffi to c
03:45:39 <kadaver> can you ffi to c++?
03:45:53 <kadaver> was their some sort of mapreduce framework in data.Monoids?
03:45:53 <Zao> kadaver: Rather painfully as mangling will stab you in the face.
03:46:01 <kadaver> mangling?
03:46:21 <tomh> you can interact with c++ via c
03:46:22 <Zao> I believe you need to go via C wrapping, manual or generated.
03:46:55 <tomh> or you can use thrift which is the better option to interact within different languages
03:47:20 <Zao> SWIG or gccxml would probably do the C++ -> C step decently.
03:47:23 <PeakerWork> you could write an FFI support for C++, but it would be a huge pain. Easier to call C++ from C
03:48:34 <p_l> SWIG can do C++ -> C quite well afaik
03:48:36 <Zao> http://www.nabble.com/C%2B%2B-to-C-td22947590.html
03:48:46 <Zao> Sounds like you, SWIG seems to be incomplete.
03:48:50 <jedai> tikel: ghci 6.10.2 don't support unicode, sorry
03:48:58 <Zao> jedai: In what way?
03:49:17 <jedai> tikel: it uses editline which doesn't support unicode input
03:49:51 <jedai> tikel: You probably were in a non unicode terminal and é had code 233 in your 8-bit encoding
03:50:14 <Axman6> i don't think é is a unicode character...
03:50:19 <Axman6> or, special character at least
03:50:43 <jedai> Axman6: it is a 2 bytes character in most unicode encoding
03:50:47 <tikel> jedai: my ghci uses readline
03:51:10 <jedai> tikel: then it's not 6.10.2 (or it's a modified version)
03:51:56 <tikel> jedai: http://www.mail-archive.com/glasgow-haskell-users@haskell.org/msg15949.html
03:52:20 <jedai> Axman6: The important part is that if you're in a unicode terminal and you try to input é, it will send two characters and editline will think one is a control character
03:52:30 <Reiver> Gur.
03:52:33 <Axman6> hmm, ok
03:52:39 <Reiver> I think I'll get my head around this last problem, then I'll call it a night.
03:53:25 <ray> i'm guessing they switched to editline for the license?
03:53:38 <jedai> tikel: Thanks, as I said your ghci is a modified version. Personally I just use ghci-haskeline, it's pretty nice and handle unicode correctly
03:53:46 <jedai> ray: yes
03:54:01 <tikel> jedai: can it do custom keybindings?
03:54:05 <Reiver> data InternalTree a = ILeaf | IBranch a (InternalTree a) (InternalTree a)
03:54:06 <Reiver> treeZip :: InternalTree a -> InternalTree b -> InternalTree (a,b)
03:54:06 <Reiver> treeZip ILeaf _ = ILeaf
03:54:06 <Reiver> treeZip _ ILeaf = ILeaf
03:54:06 <Reiver> treeZip x y = treeZip (x,y)
03:54:47 <Reiver> It's supposed to take two trees, and make the internalTree data all tuples. I keep drawing a blank on the actual content line, though.
03:54:53 <Reiver> Then again, I hate trees >_>
03:55:02 <Reiver> So that might be part of it.
03:55:15 <Axman6> Reiver: what's the defintion for InternalTree?
03:55:21 <Axman6> oh, dw
03:55:23 <Axman6> m'bad
03:55:26 <DMKE> hi there!
03:55:30 <Reiver> You had me worried for a second there~
03:55:40 <tikel> treeZip (IBranch x l1 l2) (IBranch y r1 r2) = IBranch (x, y) (treeZip l1 r1) (treeZip l2 r2)
03:55:42 <DMKE> is there an xor operation for Int?
03:56:00 <tikel> > 5 `xor` 2
03:56:01 <lambdabot>   Add a type signature
03:56:03 <jedai> DMKE: yes, in Data.Bits
03:56:05 <tikel> > 5 `xor` 2 :: Int
03:56:06 <lambdabot>   7
03:56:25 <Philonous1> @hoogle xor
03:56:26 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
03:56:26 <DMKE> thank you
03:56:30 <Axman6> treeZip (IBranch x l1 r1) (IBranch y l2 r2) = IBranch (x,y) (zipTree l1 l2) (zipTree r1 r2)
03:56:48 <Axman6> god dman it tikel
03:56:51 <Axman6> damn too!
03:56:52 <Reiver> tikel: Hrm. I'm pretty sure you're right on that one, but how's it doing that?
03:56:55 <Reiver> ... ohhh, wait.
03:57:27 <Reiver> left goes to the left, right goes to the right, tuples all round.
03:57:52 <Reiver> Yeeaah, I was getting stuck trying to just have a tuple on the internal node, and wondering what the heck you do with all the spare branches.
03:58:00 <ray> the pattern matching is doing the work there
03:58:04 <romildo> jedai, on my system I get:
03:58:05 <romildo> # ldd /usr/lib64/ghc-6.10.2/ghc | grep line
03:58:05 <romildo> 	libreadline.so.6 => /lib/libreadline.so.6 (0x00007f2a723ca000)
03:58:14 <ray> once you go pattern matching you can't go back
03:58:29 <romildo> jedai, so my ghci is using readline, right?
03:59:05 <romildo> jedai, and if it is using readline, unicode should be handed correctly, right?
03:59:28 <jedai> romildo: Right
03:59:54 <jedai> romildo: But how did you get it to link to readline, what's your OS ?
04:00:39 <Axman6> jedai: ghci can use readline just fine if editline's not installed
04:00:45 <romildo> jedai, my system is Gentoo Linux, and I am using the packages provided by the gentoo-haskell team in his overaly.
04:01:15 <romildo> s/overaly/overlay/
04:01:54 <jedai> nice :)
04:02:15 <romildo> jedai, editline is not installed on my system.
04:02:30 <kadaver> ill fix it
04:02:45 <Reiver> ray: Yeah, pattern matching still throws me a little.
04:03:22 <Reiver> It starts to feel like a chunk of your code is a regex that you never explicitly wrote out ;)
04:03:28 <jedai> I'm just using the binary for linux i386, so I didn't really have a choice. (I don't particularly enjoy compiling GHC, it's too long)
04:03:46 <romildo> jedai (or anyone), do you know how to get mkRegex and matchRegex working with regex-tdfa? Justing import Text.Regex.TDFA does not bring them?
04:04:09 <jedai> Some modules from regex-base, no ?
04:04:23 <Berengal> Awesome, I just renamed libreadline to libedit, and now ghci works fine :)
04:04:56 <jedai> Maybe you can get haddock documentation for regex-tdfa on your computer, it would help
04:05:24 <jedai> Berengal: or you could just use ghci-haskeline for a "pure" haskell solution
04:05:36 <Reiver> Excelent, that worked.
04:05:38 <Reiver> Woo!
04:05:50 <Reiver> This stuff is so much easier when you can ask people what the heck you did wrong. >.>
04:06:14 <romildo> jedai, I am reading regex-tdfa docs from the darcs repository. Another problem I am having is that its documentation does not build on my system.
04:06:19 <Berengal> jedai: There's nothing pure about machine code anyway
04:08:27 <romildo> Running ./setup haddock on regex-tdfa-1.1.1 gives the error:
04:08:28 <romildo> Text/Regex/TDFA/Common.hs:106:25:
04:08:28 <romildo>     parse error on input `-- ^ identity of Position tag to set during a transition
04:09:09 <romildo> So I could not build regex-tdfa haddock documentation.
04:09:28 <romildo> Has anybody else hit this problem?
04:16:43 <Berengal> @users
04:16:43 <lambdabot> Maximum users seen in #haskell: 658, currently: 584 (88.8%), active: 14 (2.4%)
04:28:46 <trofi^w> @src words
04:28:46 <lambdabot> words s = case dropWhile isSpace s of
04:28:46 <lambdabot>     "" -> []
04:28:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
04:29:30 <ddvlad|> @src break
04:29:30 <lambdabot> break p =  span (not . p)
04:29:50 <trofi^w> @src unfoldr
04:29:50 <lambdabot> unfoldr f b  = case f b of
04:29:50 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
04:29:50 <lambdabot>    Nothing        -> []
04:30:27 <piksi> could someone give me a hint where my logic falls short in [x| x <- [1..100], not (all ( \y -> x `mod` y == 0 ) [2..x-1]) ]
04:31:01 <ddvlad|> piksi: hmm is that for primes?
04:31:02 <BONUS> piksi : what are you trying to get
04:31:19 <opqdonut> piksi: you want all (not (...))
04:31:34 <piksi> damn, i was using all which checks for modulo of true for all within range
04:31:47 <piksi> opqdonut: yeah exactly
04:31:50 <opqdonut> piksi: or more clearly "all (\y -> mod x y /= 0) [2..x-1]"
04:32:19 <piksi> btw what's with the `` in mod's etc? doesn't that just make the syntax harder to read?
04:32:44 <BONUS> `` makes a function infix
04:32:47 <Axman6> it makes it an infix operator
04:32:49 <ddvlad|> piksi: in my opinion, no -- it makes mod infix, just like in other languages, where it is an operator
04:32:54 <BONUS> > mod 2 4
04:32:55 <lambdabot>   2
04:32:57 <BONUS> > 2 `mod` 4
04:32:58 <lambdabot>   2
04:32:59 <BONUS> equivalent
04:33:05 <Axman6> like 3 `div` 2
04:33:12 <piksi> ah, so just a different notation
04:33:20 <Axman6> which translates to 3 / 2, but for integers
04:33:22 <BONUS> you can do that with any function. functions made of special symbols (like +, -, *) are infix by default
04:33:37 <BONUS> > (+3) `map` [1,2,3]
04:33:38 <lambdabot>   [4,5,6]
04:33:43 <Axman6> > 1 `(+)` 3
04:33:44 <lambdabot>   <no location info>: parse error on input `('
04:33:48 <Axman6> :\
04:33:49 <opqdonut> hehe
04:34:13 <piksi> thanks plenty
04:35:24 <Axman6>  (`max`) 2 3
04:35:26 <Axman6> > (`max`) 2 3
04:35:27 <lambdabot>   <no location info>: parse error on input `)'
04:35:37 <Axman6> how interesting
04:35:50 <RayNbow> > (`(`(+)`)`) 1 3  -- if it were allowed... :p
04:35:51 <lambdabot>   <no location info>: parse error on input `('
04:36:36 <Axman6> (`(`(`(`(*)`)`)`)`) <- the explosion operator
04:37:15 <burp_> awesome
04:37:23 <burp_> let's write an ghc extension that supports this
04:39:16 <Axman6> @bot
04:39:16 <lambdabot> :)
04:39:16 <lunabot>  :)
04:40:32 <Baughn> :t (`div`)
04:40:34 <lambdabot> parse error on input `)'
04:40:35 <Baughn> :t (`div` 3)
04:40:36 <lambdabot> forall a. (Integral a) => a -> a
04:40:44 * Baughn shrugs. Seems a mite pointless.
04:41:45 <byorgey> burp_: good luck with the parser =P
04:41:45 <Axman6> actually, could be rather useful for demonstrating the relationship between (*) and `f`
04:53:55 <neoswish> is it possible after "module A (module B) where", use definitions from B in A, w/o importing it?
04:54:14 <quicksilver> no
04:54:17 <tikel> highly unlikely
04:54:20 <quicksilver> that specifies you plan to export it
04:54:25 <quicksilver> you still need to import it yourself
04:54:42 <neoswish> ok, thanks
04:54:52 <johnbs> Is there a way I can tell Haddock where to find the built in library documentation when it's building docs for my project?
04:57:48 <jacobian> Best way to represent a graph reified as a data structure tree with links back to previous nodes?
04:58:23 <quicksilver> a set of nodes and a set of pairs of nodes?
04:58:40 <quicksilver> data Graph a = { gNodes :: Set a, gEdges :: Set (a,a) }
04:59:14 <Baughn> You'll want a map from nodes to edges, though
05:00:37 <jacobian> Cool
05:03:41 <quicksilver> Baughn: maybe. It depends what operations you are doing.
05:03:58 <quicksilver> you could replace gEdges :: Set (a,a) with gEdges :: Map a [a]
05:04:05 <quicksilver> if that was your main mode of operation.
05:04:25 <quicksilver> and you could then dump gNodes.
05:05:56 <Lemmih> @tell kosmikus '-- $' makes lhs2tex-1.14 generate invalid tex.
05:05:56 <lambdabot> Consider it noted.
05:07:46 <kosmikus> Lemmih: and "correctly" so; comments are text to lhs2TeX, so $ switches to math mode
05:07:47 <lambdabot> kosmikus: You have 1 new message. '/msg lambdabot @messages' to read it.
05:08:25 <ordwidr> I have a list of lists [[1,2,3],[5,6],[8,9]] and I want a list of all combinations if elements of the lists: [[1,5,8],[1,5,9],[1,6,8],[1,6,9]] etc...
05:09:30 <quicksilver> > sequence [[1,2,3],[5,6],[8,9]]
05:09:31 <lambdabot>   [[1,5,8],[1,5,9],[1,6,8],[1,6,9],[2,5,8],[2,5,9],[2,6,8],[2,6,9],[3,5,8],[3...
05:09:33 <quicksilver> ordwidr: like that?
05:09:47 <ordwidr> quicksilver: yes, thanks
05:10:13 <Lemmih> kosmikus: Ah, okay.
05:13:43 <ordwidr> quicksilver: how does sequence work? It takes advantage of the List monad, I suppose
05:13:52 <Baughn> @src sequence
05:13:52 <lambdabot> sequence []     = return []
05:13:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
05:13:53 <lambdabot> --OR
05:13:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
05:13:55 <opqdonut> not really
05:14:31 <ordwidr> haha my irc client puts a smiley icon into the definition...
05:14:43 <vixey> sequence [x,y,z] = do x' <- x ; y' <- y ; z' <- z ; return [x,y,z]
05:14:45 <vixey> oops
05:14:49 <vixey> sequence [x,y,z] = do x' <- x ; y' <- y ; z' <- z ; return [x',y',z']
05:15:30 <quicksilver> ordwidr: well, sequence is defined for all monads and it just happens that for the list monad it does that :)
05:16:04 <Baughn> ordwidr: Don't think "list monad", think "indeterminancy monad". ;)
05:16:10 <ordwidr> quicksilver: how would a a monadles version on lists look like?
05:16:16 <ordwidr> Baughn: ah, yes
05:16:22 <Baughn> There are other ways to define monads on lists, but this one's indeterminancy
05:16:31 <vixey> oh! what other ways?
05:16:51 <ordwidr> vixey: without using monads
05:17:00 <vixey> other ways to define monads on lists
05:17:17 <pejo> Lemmih, have any status update on lhc? :-)
05:17:20 <Baughn> Ah. That's..
05:17:46 <tikel> :t foldr (\xs xss -> [x' : xs' | x' <- xs, xs' <- xss]) [[]]
05:17:48 <lambdabot> forall t. [[t]] -> [[t]]
05:18:08 <Baughn> vixey: The examplewas in typeclassopedia. I don't remember the details, but basically it's zipping instead of cartesian product
05:21:02 <Lemmih> pejo: Everything is on schedule. My immediate (and ordered) TODO list is as following: heap points-to analysis, LLVM backend, GRIN optimizations.
05:21:22 <vixey> What is GRIN?
05:21:29 <vixey> I saw EHC uses that too
05:22:24 <Lemmih> vixey: It's a language specially designed for graph reduction (ie. running lazy, functional programs).
05:22:32 <vixey> oh cool
05:22:58 <Baughn> vixey: Something like.. pure = (:[]), <$> = map, <*> = map ($), join = concat
05:23:22 <Baughn> vixey: Oh, wait. <*> = zipWith ($)
05:23:54 <Lemmih> vixey: It's a strict, first-order, functional language with static single assignments.
05:24:35 <vixey> yikes it sound like hard work to compile haskell into that
05:25:56 <vixey> how does it go?
05:26:15 <Lemmih> It's actually surprisingly easy to remove laziness and higher-order functions from Haskell code.
05:26:26 <vixey> really!! what do you do?
05:26:48 <vixey> I know about CPS and closure conv. to turn strict higher order into strict first order but for lazyness that couldn't work
05:26:58 <Baughn> @src (>>=)
05:26:59 <lambdabot> Source not found. stty: unknown mode: doofus
05:27:14 <Baughn> @type (>>=)
05:27:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:27:44 <Baughn> @type (\a b -> a `ap` b)
05:27:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:27:57 <pejo> Lemmih, ah, nice. I've heard that GRIN somehow can do some kind of deforestation; do you have any pointers to examples or short explainations of why/how?
05:28:41 <Baughn> @src Monad
05:28:41 <lambdabot> class  Monad m  where
05:28:41 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
05:28:41 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
05:28:41 <lambdabot>     return      :: a -> m a
05:28:41 <lambdabot>     fail        :: String -> m a
05:29:38 <Baughn> Hmm. Wasn't there an fmap equivalent for Monad?
05:29:44 <EvilTerran> liftM?
05:29:47 <Baughn> Ah yes
05:29:49 <malosh> Hi. How do I find out the memory size of a value ?
05:30:31 <TheRealMarko> malosh: what for?
05:30:46 <malosh> choose a representation, for instance :-)
05:31:15 <tikel> the size depends on the representation
05:32:08 <malosh> yes, but if I want to find out how many bytes occupies an Integer ?
05:32:32 <malosh> since Integer may occupy a variable space in memory
05:32:43 <Baughn> @type liftM a b
05:32:44 <lambdabot>     Couldn't match expected type `a1 -> r' against inferred type `Expr'
05:32:45 <lambdabot>     In the first argument of `liftM', namely `a'
05:33:09 <EvilTerran> ?type liftM f x
05:33:10 <lambdabot>     Couldn't match expected type `m a1' against inferred type `Expr'
05:33:10 <lambdabot>     In the second argument of `liftM', namely `x'
05:33:20 <Baughn> malosh: Typically.. run performGC, check memory use, create value, run performGC again, compare
05:33:29 <Baughn> @type liftM ?a ?b
05:33:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m, ?b::m a1, ?a::a1 -> r) => m r
05:33:32 <malosh> ok
05:34:07 <tikel> enjoy your thunks
05:34:33 * vixey found The GRIN project
05:34:43 <Lemmih> vixey: In LHC we represent each function with a data structure.
05:35:03 <TheRealMarko> I'm only guessing here but i think malosh might be looking for Data.Word ?
05:35:58 <Baughn> @type \a b -> join $ liftM b a
05:35:59 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a1 -> (a1 -> m a) -> m a
05:36:00 <Lemmih> pejo: 'sum [1..n]' is one example of grin-style deforestation.
05:36:14 <Baughn> ..there we go.
05:36:24 <malosh> TheRealMarko : thanks, I just found Data.Storable.sizeOf
05:36:49 <Baughn> malosh: That doesn't do what you want
05:36:55 <Baughn> Probably. Exactly what do you /want/, anyway?
05:36:55 <malosh> ?
05:37:07 <quicksilver> there is no way to find out how much space an Integer takes in memory.
05:37:22 <quicksilver> a haskell implementation is free to use zero bytes to store it, or 10 megabytes
05:37:32 <quicksilver> as long as the implementation respects the semantics.
05:37:41 <quicksilver> there are no rules about how integers are to be implemented.
05:38:09 <quicksilver> IIRC JHC and GHC take different approaches. I daresay hugs does too.
05:38:10 <vixey> the first rule about how integers are to be implemented is you don't speak about how integers are implemented
05:38:18 <malosh> yes, but I want to know how much memory my ghc 6.10 with its gmp bindings will use to store an integer like 2^300
05:38:28 <Lemmih> Integer = Int, in JHC (:
05:38:29 <pejo> Lemmih, what happens with that expression?
05:38:52 <Baughn> malosh: Around 300 bits
05:38:56 <Baughn> Plus or minus a constant factor
05:39:11 <quicksilver> malosh: roughly what you would expect.
05:39:17 <quicksilver> precisely it surely doesn't matter.
05:39:28 <malosh> isn't there a function to know the precise amount ?
05:39:32 <quicksilver> No.
05:39:35 <malosh> ok
05:39:36 <Baughn> Why do you want to?
05:39:38 <quicksilver> because it can vary between implementations.
05:39:43 <quicksilver> therefore, such function cannot exist.
05:39:50 <quicksilver> Integers are abstract, not concrete.
05:40:14 <Lemmih> pejo: '[1..10]' will be inlined and the intermediate list will never be created.
05:40:18 <malosh> Baughn : I want to store arrays of values of a bounded type, and I need to decide what structure I need
05:40:35 <Baughn> malosh: What's wrong with Data.Array?
05:40:41 <pejo> Lemmih, would it work for [1..n] too?
05:40:42 <Baughn> Or uarray, for that matter?
05:40:47 <Lemmih> pejo: Yes.
05:41:21 <malosh> Baughn : Maybe an integer would be cheaper, since I always need a sequential access
05:41:30 <malosh> so quots and rems would be ok
05:41:43 <malosh> and need to know if it is really cheaper
05:41:56 <Lemmih> pejo: '[1..10]' generates a function akin to '\from to -> if from > to then Nil else Cons from (upTo (succ from) to)'.
05:42:12 <malosh> and maybe decide it during runtime to choose an implementation
05:42:44 <Lemmih> pejo: 'sum' looks something like this: '\acc inp -> case inp of [] -> acc; Cons h t -> sum (acc+h) t'
05:42:54 <pejo> Lemmih, so GRIN evaluates closed terms?
05:43:05 <Lemmih> pejo: Closed terms?
05:43:24 <pejo> Lemmih, terms without free variables, like "sum [1..10]"?
05:43:57 <Lemmih> pejo: The optimizer will then realize that case-of-case expressions can be joined.
05:44:06 <Lemmih> pejo: I still don't understand.
05:45:22 <Lemmih> pejo: The optimizer can see that 'Nil' ~> 'acc' and 'Cons h t' ~> 'sum (acc+h) t'.
05:46:00 <vixey> nice
05:46:03 <Lemmih> pejo: GRIN is a language. It doesn't evaluate anything.
05:46:17 <vixey> what does the output become?
05:46:29 <pejo> Lemmih, ok, rephrase: does the optimizer evaluate sum [1..10]?
05:46:53 <Lemmih> 'sum_optimized acc from to = if from > to then acc else sum (acc+from) to'
05:47:46 <vixey> that's way cool
05:48:37 <Lemmih> pejo: No, the optimizer only does inlining.
05:49:11 <Lemmih> pejo: You'd get the same result with 'sum [n .. m]'.
05:50:17 <Lemmih> pejo: I guess constant folding could replace 'sum [1..10]' with '55' but that's not related to deforestation.
05:51:12 <vixey> Lemmih what if you have a big chain like   sum . f . g . h $ [n .. m]  ?
05:53:39 <Lemmih> vixey: It should still work if 'f', 'g' and 'h' behave.
05:53:49 <pejo> Lemmih, there must be something more involved than just inlining if you get new function definitions though.
05:54:42 <vixey> would GRIN be the best thing for Haskell->Java?
05:57:32 <vixey> since java is first order and strict
05:59:50 <Lemmih> pejo: The optimizer does a whole bunch of things. What I meant before was that the optimizer doesn't do compile-time evaluation. It just does inlining which is a limited version of compile-time evaluation.
06:02:10 <Lemmih> vixey: Probably. There's a student working on a .NET backend for UHC.
06:02:42 <SamB> Lemmih: that stands for Unsafe Haskell Compiler ?
06:02:45 <vixey> is .NET similar to JVM?
06:02:49 <SamB> (Unclean?)
06:02:50 <poucet> ertai: ping
06:03:00 <SamB> vixey: in what way?
06:03:41 <SamB> .NET has a bytecode ...
06:03:58 <quicksilver> SamB: unsound.
06:03:59 <QtPlaty[HireMe]> vixey: There are both virtual mechains that run in a runtime envirmoment.
06:04:01 <SamB> which supports similar things
06:04:05 <Lemmih> SamB: It's the Unknown Haskell Compiler, I think.
06:04:23 <johnbs> Utrecht Haskell Compiler
06:04:29 <johnbs> or is that a different one?
06:04:43 <quicksilver> yes, it's Utrecht.
06:04:55 <quicksilver> I was being facetious due to its support of local instances.
06:05:15 <johnbs> ah
06:05:18 <SamB> quicksilver: ah
06:05:22 <SamB> I see what you mean then
06:05:45 <quicksilver> I'm actually totally in favour of experimenting with all kinds of haskell extensions and changes.
06:05:46 <SamB> Coq doesn't support that kind of nonsense ;-P
06:06:00 <quicksilver> It's just that one requires quite a lot of reworking of how we use typeclasses to be safe.
06:06:10 <SamB> which is to say, you technically need to specify which instances you are using
06:06:35 <SamB> (they are semi-implicit arguments)
06:07:03 <quicksilver> well you have to stop using typeclasses to guarantee data structure invariants
06:07:11 <quicksilver> or you have to attach the class to the structure.
06:07:20 <quicksilver> but that's not very satisfactory
06:07:26 <quicksilver> s/class/instance/ in the latter clause
06:08:11 <SamB> quicksilver: stick it in the structure's type ;-)
06:08:25 <SamB> that's how I'd write Data.Map in Coq
06:08:30 <QtPlaty[HireMe]> :t fmap
06:08:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:08:57 <QtPlaty[HireMe]> :t mzero
06:08:59 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
06:09:13 <vixey> :t fmap mzero
06:09:14 <lambdabot> forall a b (f :: * -> *). (Functor f, MonadPlus ((->) a)) => f a -> f b
06:09:16 <quicksilver> SamB: sure, but that's a non-trivial haskell extension.
06:09:24 <SamB> quicksilver: I know ;-)
06:09:26 <quicksilver> encoding instances in types.
06:09:46 <quicksilver> it does have the benefit that you can also encode the fact they pass the laws though :)
06:10:51 <SamB> yes, I was going to say, while I was at it, I'd use a class for actual total orderings, not just things providing a "compare" method ;-)
06:11:23 <SamB> or </<= checks
06:11:42 <SamB> oh, also with a decision procedure ;-)
06:12:05 <SamB> that's kind of important in order to navigate the tree ;-)
06:12:13 <vixey> SamB: I think that's in the std lib already though (?)
06:12:33 <SamB> probably
06:12:44 <SamB> I can't remember OTTOMH
06:13:01 * vixey idly wonders if those letters mean something
06:13:05 <SamB> there is probably not a typeclass-using Data.Map-style structure
06:13:11 <SamB> Of The Top Of My Head
06:13:13 <opqdonut> off the top of my head
06:13:14 <opqdonut> probably
06:13:15 <opqdonut> ah
06:13:16 <SamB> s/of/off/
06:13:20 <opqdonut> late yet again
06:13:20 <tomh> vixey: it triggered my IRC client for name highlighting atleast ;p
06:13:28 <opqdonut> :D
06:13:30 <SamB> opqdonut: but at least you spelled it right
06:14:07 <SamB> also, you help me to believe that I'm not just making up incomprehensible abbreviations ;-)
06:14:46 <vixey> I like the sound of this GRIN
06:14:49 <opqdonut> i'm pretty bad myself
06:14:58 <opqdonut> IYCMD
06:15:33 <poucet> if you can M D ?
06:15:45 <opqdonut> if you catch my drift
06:15:57 <poucet> ISWYM
06:16:50 <kadaver> who did Data.Monoid?
06:17:14 <SamB> it doesn't say at the top ?
06:20:35 <QtPlaty[HireMe]> Andy Gill
06:22:46 <ordwidr> how can I check that the elements of a list are pairwise inequal?
06:22:59 <ordwidr> [1,2,5,3] is ok [1,2,5,1] is not
06:23:18 <Botje> nub list == list
06:23:36 <ordwidr> Botje: thankxs
06:23:50 <kadaver> when is edwardk usually on?
06:24:03 <Botje> !seen edwardk
06:24:07 <Botje> argh
06:24:12 <opqdonut> hasn't been around for a while
06:24:13 <Botje> @seen edwardk
06:24:13 <lambdabot> I saw edwardk leaving #haskell 16h 6m 58s ago, and .
06:24:19 <Botje> silly arbitrary command letters
06:24:24 <Botje> *characters
06:24:29 <quicksilver> he was around yesterday.
06:24:33 <opqdonut> woops, i mistyped my lastlog command
06:24:34 <opqdonut> yeah
06:24:35 <quicksilver> so, not a very long while really.
06:47:48 <ashee> I am an experienced programmer but a Haskell newbie
06:48:06 <ashee> Is it appropriate to ask questions here?
06:48:16 <kpreid> YES.
06:48:17 <opqdonut> no
06:48:25 <opqdonut> just ask :)
06:48:48 <ashee> module Foo where  class Foo a where 	bar :: a -> a 	 instance Foo Int where 	bar i = i + 10
06:49:07 <ashee> compiler error as follows
06:49:16 <quicksilver> you don't want any indentation before the instance
06:49:20 <quicksilver> instances are a top-level thing.
06:49:26 <kpreid> if it's more than a few lines, use http://hpaste.org
06:49:30 <opqdonut> ah, wouldn't have spotted that myself
06:49:40 <quicksilver> it's easier to read your code if you paste it to http://hpaste.org/new yes :)
06:49:52 <quicksilver> hmm, eats shoots and leaves
06:50:03 <johnbs> heh
06:50:15 <opqdonut> :)
06:50:18 <kpreid> I wonder if the freenode unexplained-quit flakiness extends to not announcing excess-flood
06:50:34 <pumpkin> eats, shoots and leaves
06:50:50 <opqdonut> pumpkin: don't ruin it
06:50:56 <quicksilver> that was never an excess flood.
06:50:57 <pumpkin> :(
06:51:10 <kadaver> orwidr: did you solve it? exacrly how doyou mean? you can do:
06:51:24 <quicksilver> anyway, mibbit is flood-protecting isn't it?
06:51:28 <kadaver> > let xs = [1,2,5,1] in nub xs == xs
06:51:32 <lambdabot>   False
06:51:34 <kadaver> > let xs = [1,2,5,3] in nub xs == xs
06:51:35 <lambdabot>   True
06:51:45 <pumpkin> nüb
06:51:55 <romildo> What is the correct way of using makeRegex to compile a regular expression from a string? If I try      makeRegex "a|b"     I get the error      No instance for (RegexMaker regex compOpt execOpt [Char]).
06:51:56 <kadaver> > nub [1,2,5,1]
06:51:58 <lambdabot>   [1,2,5]
06:52:11 <QtPlaty[HireMe]> :t nub
06:52:13 <lambdabot> forall a. (Eq a) => [a] -> [a]
06:52:17 <EvilTerran> ñüb?
06:52:37 <Deewiant> ñüḃ.
06:53:36 <Saizan> romildo: you need to add a type annotation to make it pick one of the instances
06:54:46 <romildo> saiam, I am clueless to which type annotation I would use. Any clue?
06:55:27 <romildo> Saizan, , I am clueless to which type annotation I would use. Any clue?
06:56:16 <edwardk> ashee: any luck with hpaste?
06:56:40 <ashee> i am using mibbit as my irc chat client
06:56:59 <edwardk> likewise, just open it in another window
06:57:12 <Saizan> romildo: i've never used the regex library
06:57:30 <ashee> click on PasteBin?
06:57:44 <edwardk> @hpaste
06:57:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:58:00 <edwardk> just go to that url and paste there, we tend to use that site instead of whatever random one mibbit supports
06:58:38 <ashee> http://www.mibbit.com/pb/hqPcjj
06:58:46 <ashee> here's the error
06:59:13 <ashee> http://www.mibbit.com/pb/Gsc5Lv
06:59:21 <romildo> Which type annotation should be used with the expression:      makeRegex "a|b"     so that it compiles? With no type annotation it gives a no instance error.
06:59:58 <blackh> romildo: The regex library has a crazy proliferation of typeclasses. Look at the definition for the typeclass in the haddocks and pick one of the instances that looks sensible.
07:00:51 <edwardk> ashee: ah, so it compiles fine, but when you go to use it it doesn't know which bar you mean?
07:01:09 <edwardk> ashee: i.e. you compile it, and you go into ghci Foo -- and then you type bar 10 and expect it to work?
07:01:38 <edwardk> *Foo> bar 10 :: Int ==> 20
07:01:44 <romildo> blackh, I have looked at the doc and I found the types too complex. I could not figure out which annotation to use? Maybe if I was shown an example...
07:02:08 <blackh> romildo: I figured it out once - I'll take a look
07:02:13 <edwardk> ashee: numbers are overloaded in Haskell, they are usable as any Num instance, so it doesn't know what numerical type you meant
07:02:21 <ashee> yes
07:02:49 <ashee> but the compiler wants me to disambiguate between Num t and Foo t
07:03:25 <bastl> How should record-accessors be named? e.g. data Order = Order {id :: Int, name :: String, price :: Int}. In OO-languages you would have "myorder.getName", which is imho more readable than "name myorder". Any Tips or common patterns?
07:03:39 <edwardk> ashee: the compiler is fine, its the interactive interface that doesn't know which type you wanted. tats why i used "bar 10 :: Int"
07:03:41 <quicksilver> ashee: it doesn't want you to disambiguate between them.
07:03:49 <quicksilver> ashee: it's just listing the things it knows
07:04:03 <quicksilver> ashee: "I know t is a Num, I know t is a Foo, but I don't know which t you meant"
07:04:07 <blackh> romildo: http://hackage.haskell.org/packages/archive/regex-pcre/0.94.1/doc/html/Text-Regex-PCRE-String.html
07:04:16 <quicksilver> edwardk's solution told it specifically which you did want - Int.
07:04:19 <ashee> thx - that did it
07:04:21 <fasta> Regex is complicated because there is no intuitive mapping from types to behaviours. It just needs to be documented better, or maybe the whole type-class design is a mistake.
07:04:25 <blackh> romildo: The class RegexMaker is defined in regex-base.. you need a package like regex-pcre to get the instance.
07:04:28 <ashee> however, i have a secondary question
07:04:39 <edwardk> it knows that 10 has to be a Num instance, and it knows since you called bar with it as an argument it knows that you have to be using it as an instance of Foo as well
07:05:09 <edwardk> you can also fix the type by fixing the type of the input to that function as well bar (10 :: Int)
07:05:22 <blackh> romildo: So what you'd need to type would be...
07:06:02 <ashee> Let's say I want bar (in Foo) to support (a) add 10 to number types (b) concatenate "prefix:" to a String type. What's the best way?
07:06:25 <blackh> romildo: ...note that makeRegex is source -> regex and 'source' is the last one and 'regex' is the first...
07:06:35 <edwardk> ashee: well, the problem you have is this, what happens if someone comes along and makes String into a number?
07:06:42 <blackh> romildo: So if we pick "RegexMaker Regex CompOption ExecOption String"... then you need to say...
07:06:43 <edwardk> ashee: those two cases could overlap
07:07:02 <blackh> romido: let r = makeRegex "a|b" :: Regex
07:07:18 <blackh> romildo: There's a really simple interface lurking underneath that bewildering complexity.
07:07:46 <edwardk> ashee: that is what keeps you from doing it directly. if you just say instance Num a => Foo a where bar i = i + 10; instance Foo String where bar i = "prefix: " ++ i  -- then you have 'overlapping instances'
07:08:17 <edwardk> if you know for sure that its ok and that String will never be an instance of Num you can add a {-# LANGUAGE OverlappingInstances #-} language extension at the top of the file, but thats a bit of a hack
07:08:41 <edwardk> the right answer would be to say that you don't want Foo to do the +10 behavior for all Nums, just the ones you explicitly enumerate
07:08:57 <blackh> edwardk: Import Regex from Text.Regex.PCRE
07:09:01 <edwardk> and make: instance Foo Int where .. instance Foo Float where ..
07:09:07 <blackh> Oops.. getting late
07:09:08 <ashee> here's a legitimate use-case - let's say instead of bar we want "addTen"
07:09:15 <blackh> romildo: Import Regex from Text.Regex.PCRE
07:09:17 <edwardk> or you make a newtype wrapper
07:09:43 <edwardk> ashee: ok
07:09:57 <ashee> string version of addTen simply adds a suffix "10" while number version adds 10
07:10:38 <ashee> i am trying to do OOP polymorphism - part of the unlearning process :-)
07:10:43 <edwardk> ashee: yes, but the problem you have is that someone could define a String instance for Num, that seems counter intuitive
07:11:31 <edwardk> what happens when someone says instance Num String where a + b = a ++ " + " ++ b; ...
07:11:42 <ashee> is it then a best practice to use another function name?
07:11:54 <edwardk> now you have a conundrum your code wouldn't know if it should use the Num instance or if it should use your String special case
07:12:10 <edwardk> well, there are solutions, both are ugly seeming at first
07:12:22 <edwardk> one is the 'wrong solution', which is to use the OverlappingInstances thing  Imentioned above
07:12:28 <edwardk> that is a language extension that permits what you want
07:12:59 <edwardk> the other is to use a newtype wrapper to wrap any Nums, then String will lack the newtype and your 'instance heads' won't overlap
07:13:07 <romildo> blackh, that worked. Thanks.
07:14:18 <edwardk> newtype WrapNum a = WrapNum { unwrapNum ::  a } deriving (Eq,Ord,Show,Read,Num); instance Num a => Foo (WrapNum a) where bar i = i + 10
07:14:44 <edwardk> now the instance for Foo you'd use is the one for WrapNum Int, not for Int
07:15:18 <edwardk> the 'newtype' keeps you from having to concern yourself about string because [Char] and WrapNum a don't overlap
07:15:36 <edwardk> its counter intuitive at first, but you get used to the practice with time
07:15:47 <edwardk> also newtypes are 'free' they come at no runtime cost to use
07:16:23 <edwardk> (note that i abused the fact that i used newtype deriving to automatically inherit the instance of Num for WrapNum a from a.
07:16:52 <edwardk> so bar i = i + 10 -- uses the shiny new instance of Num for WrapNum a which exists whenever a is an instance of Num
07:17:00 <edwardk> it could be more explicit with
07:17:09 <edwardk> bar (WrapNum i) = WrapNum (i + 10)
07:17:28 <johnbs> edwardk: don't you need {-# LANGUAGE GeneralizedNewtypeDeriving #-} for that? or is it enabled by default?
07:18:10 <fasta> johnbs: yes, but specifying that everytime in IRC gets old quickly.
07:18:15 <edwardk> johnbs: you probably need GeneralizedNewtypeDeriving, I'm kind of blind to language extensions ;)
07:18:17 <dmead> chanell!!!!!!!!!!!!!!!
07:18:25 <johnbs> yeah, i was just checking
07:18:43 <edwardk> i just let the compiler complain and then fix them up as i go. ;)
07:18:53 <quicksilver> generalised newtype deriving is a rather non-controversial extension.
07:19:03 <quicksilver> I wonder if someone remember to propose it for haskll'
07:19:11 <edwardk> only time i give it any thought is when i use more extension annotations than code
07:19:16 * vixey wonders how it works
07:19:32 <EvilTerran> doesn't newtype deriving have some odd corner cases?
07:19:35 <Deewiant> quicksilver: It's a 'maybe', IIRC.
07:19:56 <edwardk> EvilTerran: the weirdest one for me is that you can't have an existential newtype =(
07:20:29 <edwardk> ashee: was that at all helpful or did i go too fast?
07:20:38 <Deewiant> http://hackage.haskell.org/trac/ghc/ticket/1496 seems to be a problem.
07:20:43 <QtPlaty[HireMe]> What is the diffrence between Int and Integer?
07:20:48 <edwardk> ashee: oh, hrmm. you probably missed my response =)
07:20:54 <EvilTerran> edwardk, i guess that's because of the nonexistent-at-runtime thing
07:21:05 <ashee> i almost got through everything including the wrapper stuff
07:21:07 <edwardk> EvilTerran: shouldn't matter really
07:21:19 <sgcummin> QtPlaty[HireMe]: Int's are machine integers, Integers are arbitrary lenght
07:21:19 <fasta> QtPlaty[HireMe]: Int computes modulo maxBound::Int
07:21:30 * QtPlaty[HireMe] nods
07:21:46 <edwardk> QtPlaty[HireMe]: modulo (maxBound :: Int) + 1 =)
07:21:49 <ashee> i get a different error when I try to create instance Foo String where ...
07:21:59 <Saizan> EvilTerran, edwardk: it matters only with a typeclass context
07:22:27 <edwardk> Saizan: yes, but without the typeclass context i should be able to have them ;)
07:22:35 <edwardk> saizan: then i could have an efficient left kan extension =)
07:22:49 <fasta> I wonder how many systems could be exploited in one way or another by overflowing some int somewhere.
07:23:05 <Saizan> edwardk: don't you need a product anyway for that?
07:23:13 <edwardk> well, maybe left kan extension is a bad example.... yeah
07:23:41 <fasta> "Nobody will ever do this or that 4 billion times" has surely been said by someone at some point in time.
07:23:43 <edwardk> but coend should hold up
07:24:15 <edwardk> ashee: toss it into a pastebin
07:25:07 <edwardk> newtype Colimit f = forall b. Colimit (f b) -- would also be handy
07:25:11 <EvilTerran> "instance Foo String" needs FlexibleInstances, doesn't it?
07:25:21 <edwardk> oh yeah, another language extension
07:25:28 <edwardk> instance Foo [Char] -- would be what you need
07:25:38 <edwardk> because String = [Char]
07:25:43 <ashee> yes
07:25:49 <fasta> Extension bingo!
07:26:04 <Saizan> you need FlexibleInstances anyway
07:26:22 <Saizan> because Char is not a variable
07:26:23 <ashee> same error with [Char]
07:26:57 <edwardk> i tend to just live in a world of FlexibleInstances, FlexibleContexts, GeneralizedNewtypeDeriving, TypeFamilies, MultiParamTypeClasses, ScopedTypeVariables, RankNTypes, ...
07:27:07 <edwardk> ashee: paste the error?
07:27:35 <edwardk> i'm slowly weaning myself off of ScopedTypeVariables
07:27:49 <ashee> http://www.mibbit.com/pb/A2haYE
07:28:02 <vixey> what's wrong with ScopedTypeVariables?
07:28:16 <edwardk> ashee: add {-# LANGUAGE FlexibleInstances #-} -- above the module declaration in your file
07:28:30 <osfameron> Apocalisp: I'm going to try to recreate your examples in http://apocalisp.wordpress.com/2008/09/02/a-better-future/ in Perl for a talk in a couple of weeks... wish me luck ;-)
07:28:38 <ashee> is it possible to do this without ghc specific options?
07:28:40 <edwardk> vixey: their behavior has changed at least once
07:28:44 <Deewiant> I try to live in a world which Hugs supports
07:28:46 <vixey> hehe
07:29:06 <edwardk> ashee: technically, no, you need a language extension to define any instance for a String directly.
07:29:15 <Deewiant> ashee: See the implementation of 'Show' in the Prelude, it's a bit of an ugly workaround
07:29:42 <edwardk> you can 'hack' your way towards it by making two instances but thats hardly a pretty solution
07:30:01 <edwardk> ashee: you managed to choose a pretty hairy example as your starting point for your foray into Haskell ;)
07:30:26 <ashee> i understand some of the other stuff
07:30:33 <ashee> at least conceptually
07:30:50 <fasta> edwardk: can you give a useful example of a RankN type as opposed to Rank2? I know the original paper contains some, but I never used those.
07:30:55 <edwardk> class FooList a where barList :: [a] -> [a]; -- then define barList the way you want bar to work on Strings, then define
07:31:17 <edwardk> then define instance FooList a => Foo [a] where bar = barList
07:31:41 <edwardk> haskell 98 only allowed instance heads that had a single constructor wrapped around variables.
07:32:05 <ashee> instance heads?
07:33:17 <edwardk> ashee: when you look at: instance (Foo a, Bar b, Baz c) => Quux (MyType a b c) -- the Quux (MyType a b c) is whats called the 'instance head'
07:33:49 <edwardk> the terminolgy derives from prolog if you flip the notation around MyType a b c :- Foo a, Bar b, Baz c -- the left hand side there is the 'head' the right hand side is the body
07:34:40 <fasta> I wonder who made up this char: ⋜.
07:34:43 <edwardk> inference of instances runs backwards from the head to the body. so when your compiler is trying to figure out what instance of Foo to use for [Char] -- it looks at [Char] and tries to pattern match it against each of the heads it has available
07:34:56 <ashee> So Quux belongs to the typeclasses Foo, Bar and Baz, right?
07:35:00 <edwardk> only one should match.
07:35:39 <edwardk> ashee: that particular instance of Quux for MyType a b c requires that a belongs to Foo and b belonds to Bar and c belongs to Baz.
07:35:40 <ashee> in case of multiple matches, how do I explicitly disambiguate for the compiler?
07:36:00 <edwardk> ashee: multiple matches are usually a sign of an 'engineering problem' =)
07:36:09 <ashee> k - :-(
07:36:26 <edwardk> ashee: like i mentioned before there are language extensions that allow you to work around it. you can use OverlappingInstances
07:36:31 <edwardk> or even IncoherentInstances
07:36:56 <edwardk> but in general the answer is that you should use a newtype wrapper to make your heads not overlap
07:37:03 <edwardk> like I did with WrapNum above
07:37:06 <ashee> is it considered "code smell" if you use these extensions?
07:37:18 <edwardk> OverlappingInstances is a bad code smell
07:37:39 <edwardk> FlexibleInstances FlexibleContexts MultiParamTypeClasses FunctionalDependencies, those are pretty much considered part of the language these days
07:38:00 <Deewiant> Yeah, just about every compiler supports those
07:38:07 <ashee> I have my homework cut out for me - thx a lot!
07:38:22 <edwardk> glad to help
07:38:36 <edwardk> i wish someone had explained the role of newtypes to me in the language when i first got here ;)
07:38:47 <Chani> uhoh
07:38:51 <Chani> big uhoh
07:38:52 <edwardk> not that i think that i did a very good job of it
07:38:54 <fasta> Yes, but there isn't even a compiler supporting Haskell 98 ;)
07:38:57 <jacobian> What's a sort of canonical mutual recursion example...
07:38:57 * vixey still doesn't know what newtypes are for
07:39:07 <vixey> jacobian: odd/even
07:39:09 <fasta> jacobian: even and odd
07:39:14 <jacobian> Ah brilliant, thanks
07:39:18 <Chani> the TA, who is horribly behind in marking our assignments, just found out he can't run mine.
07:39:21 <Chani> Parse.hs:1:13: unsupported extension: ViewPatterns
07:39:24 <edwardk> vixey: they resolve ambiguity in instance heads ;)
07:39:30 <Deewiant> Chani: He's got 6.8 or older.
07:39:34 <edwardk> ChanServ: he is using 6.8
07:39:57 * edwardk is sure that ChanServ doesn't care, but felt the need to inform the bot.
07:39:58 <Deewiant> And you've developed with 6.10 or newer, clearly.
07:40:25 <Chani> thanks
07:40:26 <Chani> what do I do if he can't upgrade?
07:40:31 <quicksilver> vixey: abstraction without losing efficiency?
07:40:43 <edwardk> Chani you can always remove them from your code and resubmit it to him if he's nice
07:40:45 <AnotherStolenKad> edwardk: is Data.Monoid a good way to implement some map-reduce lib on amazon ec2?
07:40:53 <Chani> (4 hours before final grades have to be submitted to the school. this TA lost a bunch of assignments and didn't admit it until yesterday)
07:41:01 <vixey> what abstraction?
07:41:14 <Chani> edwardk: iirc it's an important little thing
07:41:19 <edwardk> Chani: foo (view -> x) = ... can always be replaced with foo x' = case view x' of x -> ...
07:41:30 <Chani> hrmmm.
07:41:46 <vixey> I wonder why there's not a tool in GHC that translate view pattern code into non-view pattern code
07:42:00 <vixey> seems like that is what it does internally -- so why not let users have it too
07:42:05 <edwardk> does lambdabot need an unview?
07:42:12 <vixey> no GHC does
07:42:50 <fasta> vixey: because there is no benefit for the people who write GHC.
07:42:51 <vixey> now I'm wondering if we need to describe language extensions in a similar way to darcs patches
07:43:00 <edwardk> > let f (fst -> x) = x + 1 in f (1,3)
07:43:01 <lambdabot>   <no location info>: parse error on input `->'
07:43:13 <vixey> , let f (fst -> x) = x + 1 in f (1,3)
07:43:16 <lunabot>  2
07:43:24 <fasta> vixey: at least if you look at in a naive way.
07:43:38 <edwardk> vixey: talk to Philippa, she has a bunch of thoughts in that direction ;)
07:43:41 <vixey> fasta I guess, just that it seems like a really good design would make this sort of thing trivial
07:43:56 <fasta> vixey: if GHC would be implemented in Forth, it would be.
07:44:11 <vixey> I don't know forth well enough to get that
07:44:35 <fasta> The concept of annotating source code with the exact language being used, as opposed of it being part of the source code is a bad idea, imho.
07:44:44 <edwardk> vixey: "its turtles all the way down" basically a small set of combinators everything else is built on
07:45:23 <jmcarthur> would be nice to have do notation desugaring as a tool in ghc too, as another example
07:45:32 <edwardk> vixey: so you'd define the new syntax in terms of its translation to the existing base language
07:45:41 <vixey> fasta: what is the difference there?
07:45:50 <fasta> vixey: what do you mean?
07:46:03 <vixey> edwardk: oh yeah I heard her say something about screw you lisp macros
07:46:19 <fasta> The disadvantage of Lisp is that the GC is built-in.
07:46:29 <vixey> fasta annotating source code with language used vs part of the source code seems like the same thing to me.. so what's the distinction?
07:46:54 <vixey> I mean {-# LANGUAGE ... #-} could be described by either no?
07:47:01 <edwardk> vixey: she has some nifty scheme for viewing source transformations and language features in terms of various categories
07:47:14 <Saizan> many extensions aren't just simple desugarings,  however
07:47:49 <fasta> vixey: you would  not have to create access to all the "intermediate" languages, because by definition all those are needed.
07:48:29 <edwardk> fasta: well, you could 'ala carte' the language features, but i woulnd't want to maintain the lib ;)
07:49:09 <p_l> ... now this is the last place I suspected for finding "built-in GC is a disadvantage" :D
07:49:14 <dblhelix> anyone here already given uhc a spin?
07:49:23 <jmcarthur> p_l, why's that?
07:49:31 <fasta> edwardk: maintaining a Haskell compiler is also not easy, even the Simons are afraid to touch some code.
07:49:33 <Chani> edwardk: I'm having trouble with (viewl -> a:<pre)
07:49:58 <vixey> fasta: I think maintaining a haskell compiler should be easy
07:50:00 <Chani> edwardk: I can't actually remember what viewl even is and doin't have time :)
07:50:03 <edwardk> chani: foo bar = case viewl bar of a :< pre -> ...
07:50:14 <p_l> jmcarthur: I dunno about Haskell, but Lisp did start without GC. And while I sometimes do want to use more direct methods of memory allocation, I wouldn't like Haskell without GC :)
07:50:20 <edwardk> viewl probably comes from data.fingertree or data.sequence
07:50:26 <vixey> it's a really kick in the face how crap GHCs impl. is
07:50:35 <Chani> edwardk: ohhhh. duhh
07:50:37 <jmcarthur> vixey, to be honest i'm not sure i entirely understand your proposal. are you want saying you want extensions to be available as separate packages from ghc?
07:51:08 <vixey> jmcarthur: no just sort of making vague comments about how un-modular and awkward GHCs implementation is
07:51:27 <mattam> You should never fear the code. The code should fear instead :)
07:51:36 <edwardk> vixey: ghc does a lot of stuff, its easy to be modular when you are simple. its hard to be modular when you've had years of optimizations and cases piled on to make everything fast
07:51:47 <arabidopsis> hi! Anyone here knows how should I deal with haskell-cabal in Archlinux?
07:51:54 <fasta> vixey: yes, it is just that the scope of a complete Haskell compiler is quite large and the scope continues to be expanded. They should just have a feature freeze and first fix all the bugs before continuing, but alas, that's not how it works.
07:51:56 <Chani> edwardk: thanks :) it works again
07:52:09 <arabidopsis> I am trying to upgrade ghc, but haskell-cabal requires 6.10.1. Strangely, haskell-cabal AUR is GONE!Haskell-cabal is the dependency for so many packages
07:52:27 <vixey> the other problem is -- If I went, "oh screw this I'm going to do things right" .. I'd just be adding to the problem
07:52:38 <edwardk> vixey: hah
07:53:02 <edwardk> vixey: enter ehc, uhc, jhc, lhc, hbc ...
07:53:27 <fasta> vixey: UHC is supposed to be how compilers should be built.
07:53:48 <edwardk> fasta i'm sure every compiler author believes that about their baby ;)
07:54:37 <fasta> edwardk: that was when they were half way I guess. Someone should ask about the result, or I should just look at it some day ;)
07:54:52 <fasta> edwardk: but yes, you are right.
07:55:01 <AnotherStolenKad> hmm im thinking about writing my own random lib or just FFI to C. have an IORef to track the current seed. init when module is iportfrom system time
07:55:23 <quicksilver> edwardk: well, every compiler author believes there are a few particular things they are doing 'Right'
07:55:33 <quicksilver> edwardk: and they are less rigorous about the others.
07:55:33 <dblhelix> fasta, edwardk: we're pretty enthusiastic about AGs and used them quite prominently in implementing UHC... not because we *knew* that that was how it should be done, but because we thought that it *might* have some advantages
07:55:42 <edwardk> quicksilver: sure, otherwise they wouldn't be writing a compiler ;)
07:55:55 <dblhelix> edwardk: indeed
07:56:23 <dblhelix> and I'm quite sure that if we were to start all over again, we would make some fundamental changes...
07:56:40 <edwardk> dblhelix: fair enough, what would you say uhc gets right? and what would you say are the biggest flaws in the design?
07:57:00 <edwardk> (i like to try to learn from other people's mistakes) =)
07:57:29 <AnotherStolenKad> oh my i noticed the haskelllogo
07:57:40 <dblhelix> edwardk: I think the attribute grammars really keep things manageable
07:57:44 <edwardk> i.e. i love jhc/lhc, but the notion of region based collection is pretty severely flawed in a lazy language
07:57:55 <edwardk> dblhelix: hrmm
07:58:08 <dblhelix> edwardk: I myself am less enthusiastic about the incremental layering of features
07:59:18 <dblhelix> still, I'm not a member of the core ehc team... if any conclusions are to be drawn, it should be done by those who are
07:59:28 <edwardk> fair enough
08:00:12 <AnotherStolenKad> what does (<-) mean more exactly? cant everyhtign that is a Monad instanced be used with (<-)?
08:00:51 <edwardk> AnotherStolenKad: do x <- foo; bar -- becomes foo >>= (\x -> bar)
08:01:10 <edwardk> AnotherStolenKad: its just syntactic sugar for >>=
08:01:37 <dblhelix> AnotherStolenKad: I wouldn't write (<-): it suggest that <- is a "regular" operator... it isn't ... it's syntax, it's sugar
08:02:23 <quicksilver> dblhelix: some conclusions are best drawn by those outside the core.
08:02:42 <edwardk> dblhelix: less 'koolaid poisoning' =)
08:02:43 <vixey> something like  viewpatterns  &  do notation
08:02:49 <vixey> you could desugar them in either order right?
08:02:53 <vixey> they commute
08:03:03 <edwardk> vixey: sure they don't care about each other
08:03:47 <edwardk> unless you use do sugar in your view pattern ;)
08:03:50 <dblhelix> quicksilver: perhaps
08:04:15 <vixey> or view patterns in do ..   do (reverse -> x <- y ; ...
08:04:40 <edwardk> vixey: woo, never thought of that one
08:04:47 <AnotherStolenKad> isnt
08:04:48 <AnotherStolenKad> main = rand 10 >>= \r -> return $ r * r
08:04:56 <AnotherStolenKad> -- main = do
08:04:57 <AnotherStolenKad> --   a <- rand 10
08:04:57 <AnotherStolenKad> --   return a*a
08:04:58 <edwardk> a whole new era of obfuscation awaits!
08:04:58 <AnotherStolenKad> the same?
08:05:12 <Deewiant> main = fmap (^2) (rand 10)
08:05:19 <Deewiant> And yes, it's the same.
08:06:13 <edwardk> foo bar -> x <- something crazy -- is actually fairly clean compared to x <- foo bar <$> something crazy
08:06:18 <AnotherStolenKad> so why does the latter not work?
08:06:29 <edwardk> and avoids a superfluous map
08:06:36 <vixey> hehe
08:06:42 <AnotherStolenKad> oh wait
08:06:43 <AnotherStolenKad> $
08:06:51 <EvilTerran> AnotherStolenKad, you forgot a $ on the last line
08:06:52 <vixey> return (a*a)
08:07:03 <EvilTerran> it's currently parsing as (return a) * a
08:07:38 * EvilTerran gets to thinking about the possibility of monadic view patterns
08:09:20 <AnotherStolenKad> is there some way to have a global without having a running program?
08:09:33 <AnotherStolenKad> liek IORef is global but you still have to have some sort of main right?
08:11:49 <vixey> how do you compile Haskell into GRIN?
08:11:51 <edwardk> AnotherStolenKad: you can myGlobal = unsafePerformIO (newIORef)
08:11:59 <vixey> AnotherStolenKad: it's called Reader monad
08:12:04 <vixey> no clue what edwardk is talking about :p
08:12:11 <dblhelix> vixey: are you familiar with Boquist's thesis?
08:12:14 <edwardk> vixey: aha
08:12:16 <vixey> no dblhelix
08:12:42 <edwardk> vixey: the unsafePerformIO global hack is a reasonably acknowledged language wart ;)
08:12:42 <vixey> Code Optimisation Techniques for Lazy Functional Languages
08:12:44 <dblhelix> @google urban boquist thesis
08:12:46 <lambdabot> http://www.cs.chalmers.se/~boquist/
08:12:46 <lambdabot> Title: Urban Boquist
08:12:56 <AnotherStolenKad> @index unsafePerformIO
08:12:57 <lambdabot> System.IO.Unsafe, Foreign
08:13:00 <vixey> edwardk: honestly I do know that hack -- just don't like it
08:13:06 <vixey> or see why anyone would do it
08:13:11 <dblhelix> vixey: indeed, it's about grin (and compiling into it)
08:13:14 <edwardk> vixey: go through that paper and if you still have questions i'll happily answer
08:13:22 <vixey> dblhelix great, thank you!
08:13:25 <edwardk> boquists grin is just untyped
08:13:43 <edwardk> the one in jhc/lhc is a strongly typed variant, which is both good and bad
08:13:49 <dblhelix> edwardk: agreed
08:14:08 <edwardk> it makes certain transformations hellish, but makes it easier to lint pass over
08:14:19 <dblhelix> vixey: iirc, there are two (much shorter) articles by boquist that contain the highlights of the thesis
08:14:40 <dblhelix> vixey: http://dblp.uni-trier.de/db/indices/a-tree/b/Boquist:Urban.html
08:14:47 <edwardk> i was using a bastard child of the STG and GRIN for a while, mainly because that way eval didn't have to have the entire program available, but it increased the 'magic' of the system a lot
08:14:54 <jmcarthur> AnotherStolenKad, edwardk's answer was true to your question, but it should also come with the advice that you might want to rethink your design so you don't need to do it
08:16:10 <vixey> so how similar is GRIN to STG?
08:16:13 <edwardk> think of global references made with unsafePerformIO with the same general disdain people hold for singletons in OOP.
08:16:27 <edwardk> vixey: very different optimization strategies
08:16:28 <jinjing> is there a way to return the bytesize of a string?
08:16:54 <MyCatVerbs> edwardk: arguably it's worse.
08:16:55 <Zao> jinjing: In which encoding?
08:17:06 <edwardk> vixey: but ultimately they both represent things in terms of tagged thunks on the heap
08:17:14 <MyCatVerbs> edwardk: singletons don't break optimizations.
08:17:16 <jmcarthur> yeah i think the global trick in haskell is much worse than singletons in OO languages
08:17:21 <jinjing> Zao: the string is in utf8
08:17:35 <jinjing> Zao: no, sorry, in unicode
08:17:45 <Zao> jinjing: I assume you're talking about String?
08:17:55 <Xen0x> *joining the Global varibale discussion. Do you know a better way of defining a global queue among threads, than defining a global var using; unsafePerformIO $ newTVarIO []
08:18:04 <edwardk> vixey: the spineless tagless gmachine just makes the tag into a code pointer that knows how to evaluate down to whnf, GRIN on the other hand makes a defunctionalized 'eval' method that knows how to evaluate every thunk type in the world
08:18:09 <jinjing> Zao: yes
08:18:15 <jmcarthur> Xen0x, MChan?
08:18:23 <edwardk> vixey: the advantage of the latter is that it can specialize down really really far by inlining eval.
08:18:27 <jmcarthur> TChan, rather
08:18:29 <vixey> edwardk ah!
08:18:31 <Zao> jinjing: B.length . encodeUtf8BE . T.pack $ "mahstring"
08:18:35 <edwardk> vixey: the advantage of the former is that its got an open world
08:18:42 <Zao> Where T is Data.Text and B is ByteString
08:18:48 <mreh> ive got some algorithm that uses reactive animation, and it uses getWindowTick from HGL, documentation says its been deprecated, any idea what replaced it?
08:18:50 <edwardk> vixey: in my case I jit, so I can straddle the line between them
08:18:52 <TomMD> Xen0x: Partial application has yet to fail me.
08:19:17 <jinjing> Zao: cool, thanks :)
08:19:18 <edwardk> vixey: so i can pretend i have a close world within the jitted code and allow the escape valve of calling the thunk and falling out onto the slow path
08:19:27 <vixey> but with GRIN can you compile two modules separately?
08:19:27 <edwardk> vixey: thats why i said i was sort of the bastard child of both
08:19:32 <vixey> and use them together
08:19:46 <edwardk> vixey: nope. grin is a 'whole world' optimizing compiler. no separate compilation
08:19:49 <jmcarthur> Xen0x, or is your question about how to pass the reference to different threads without globals?
08:19:50 <Zao> jinjing: Or use the utf8-string package.
08:20:01 <vixey> ok
08:20:10 <edwardk> vixey: thats why i think the grin approach works better in a jit than in a compiler.
08:20:18 <jinjing> Zao: oh, i'm using the utf8-string package, should I just encode it in utf-8 and do length?
08:20:34 <mreh> i can have answer? :(
08:20:41 <Zao> jinjing: If you want the length of the utf8 string in bytes, sure.
08:20:42 <jmcarthur> Xen0x, if that's the case then your threads can be defined like myThreadFunc :: TRef a -> IO (), then call forkIO myRef to make the thread
08:20:56 <jmcarthur> Xen0x, or variations depending on what style makes the most sense for your program
08:21:11 <jmcarthur> forkIO (myThreadFunc myRef)
08:21:20 <jmcarthur> is what i mean
08:22:02 <mreh> no-one has used getWindowTick before?
08:22:02 <jinjing> Zao: thanks
08:22:11 <Xen0x> jmcarthur; thnx. But I was looking for a nice way of creating a send method for a GUI program. The send method has a Handle that refers to the created socket. And the send method is exported out of the module, so various methods can send information over the network using the send method.
08:22:47 <edwardk> mreh: apparently not
08:22:57 <Xen0x> jmcarthur; the way I solved it now, is that the 'data to be sent' is stored in a global queue, which is read by a thread. When a value is encountered it reads it, removes it and sends it :)
08:22:58 <mreh> :(
08:23:19 <mreh> it's part of that Haskell in Space paper if anyone has done that
08:23:28 <jmcarthur> Xen0x, i was addressing the globalness of the queue. it doesn't need to be global
08:23:34 <quicksilver> mreh: I wouldn't worry about the deprecation
08:23:39 <jmcarthur> Xen0x, you should be able to just pass the reference to the queue around
08:23:39 <quicksilver> mreh: if it still works, use it.
08:23:47 <AnotherStolenKad> main = do
08:23:47 <AnotherStolenKad>   a <- rand
08:23:47 <AnotherStolenKad>   b <- rand
08:23:47 <AnotherStolenKad>   return $ a * b
08:23:51 <AnotherStolenKad> i want to eb able to do that without passing around a seed
08:23:59 <jmcarthur> oh i get it, you don't want that to be visible?
08:24:17 <Xen0x> jmcarthur; the queue?
08:24:20 <quicksilver> AnotherStolenKad: MonadRandom on the wiki or possibly hackage.
08:24:20 <arabidopsis> hslogger requires "time" package, what is the package name for "time" under Archlinux?
08:24:21 <AnotherStolenKad> the whole point is i dont want to eff around with Syste.Random at all
08:24:21 <mreh> quicksilver: alright, i suppose if i was bothered about future compatability I could
08:24:41 <quicksilver> AnotherStolenKad: it's an obvious example of a monad, it's not clear why it's not a standard part of System.Random.
08:24:42 <mreh> would it be wise to assume that an old version of HGL will still work?
08:24:59 <jmcarthur> Xen0x, is that not your question?
08:25:04 <edwardk> aradopsis: installing cabal and just saying 'cabal install foo' works a lot better than using the random package names your distro comes up with
08:25:14 <johnbs> is there a partitionM function somewhere? (where partitionM is to partition as filterM is to filter)
08:25:30 <Xen0x> jmcarthur; yes that was my question :)
08:25:50 <AnotherStolenKad> globalSeed :: IORef Integer <- thats still a function right
08:26:04 <jmcarthur> Xen0x, yeah, you should be able to pass the queue around, and you can use a reader monad to hide it if you want
08:26:08 <cooldude127> anybody have a good resource for getting started using Yi?
08:26:15 <cooldude127> the documentation seems so sparse
08:26:32 <jmcarthur> newtype SomeRelevantName a = Foo (Reader QueueRef a)
08:26:44 <pumpkin> wow, people are harsh with UHC
08:26:49 <Xen0x> jmarthur; I am aware of the existince of the Reader Monad, but the 'global variable' hack is so much more easier to implement
08:26:58 <jmcarthur> or newtype SomeRelevantNameT m a = Foo (ReaderT QueueRef m a)
08:27:15 <quicksilver> pumpkin: "people"? or "Richard O'Keefe" ?
08:27:19 <jmcarthur> Xen0x, using the monad approach pays off in the long run, in my experiences
08:27:21 <pumpkin> well, even augustss
08:27:28 <pumpkin> "too hard; didn't install"
08:27:36 <pumpkin> "not enough coverage", "toy problems"
08:27:37 <pumpkin> etc.
08:27:38 <pumpkin> :P
08:27:43 <mreh> cooldude127: is that the haskell editor?
08:27:46 <cooldude127> ya
08:27:55 <mreh> i dont know anything about it, but good luck :D
08:28:04 <Xen0x> jmcarthur; in what way? Performance or coding problems?
08:28:09 <edwardk> pumpkin: they seemed to come down hard on the n+k pattern thing
08:28:21 <pumpkin> yeah, seems silly to me, but hey, I'm a noob :P
08:28:22 <quicksilver> edwardk: only idiots came down hard on the n+k pattern thing.
08:28:22 <edwardk> wait until they see no monomorphism restriction by default ;)
08:28:26 <cooldude127> i'm trying to get it to load a file into the running ghci, which it can do, i found the function. just don't know how to make the editor actually do it
08:28:52 <pumpkin> no monomorphism restriction sounds like a good thing to me, the points in favor of the MR seemed questionable
08:28:52 <edwardk> quicksilver: well, lennart spoke about it obliquely and i consider him pretty far this side of the idiot line
08:28:57 <jmcarthur> Xen0x, one thing it does is make it clear where you are and are not working with effects. another is the fact that you aren't potentially breaking the optimizer
08:29:00 <quicksilver> edwardk: lennart was fine with it
08:29:15 <quicksilver> "In the particular case of n+k I don't care, since I never use them"
08:29:34 <quicksilver> jon fairbairn was just being ignorant, I think
08:29:40 <mreh> i saw a german lecturer using n+k patterns
08:29:41 <pumpkin> he's still talking about it in terms of toy programs and being too hard though
08:29:48 <pumpkin> just sounded harsh :)
08:29:52 <mreh> on those viddy lectures
08:29:57 <quicksilver> uhc's h98 failings strike me as no worse than ghc's or hugs'
08:30:07 <quicksilver> pumpkin: well yes, although I didn't read that message with the tone you did.
08:30:09 <Xen0x> jmcarthur; I am aware of the effects of using the Global Variable, maybe I will rewrite my code using the Reader Monad, but for now my project is working :)
08:30:12 <pumpkin> ah
08:30:16 <jmcarthur> Xen0x, however, i don't think it's _ugly_ necessarily to have such a thing hidden, i just think the monad approach is "better"
08:30:18 <quicksilver> I just read that as "more people will use it if you make it easier to install"
08:30:21 <quicksilver> which is probably fair comment.
08:30:42 <int-e> I don't know, the release announcement to me read "Here's our code. A lot of stuff works. A lot of stuff doesn't work. Feel free to play with it."
08:30:46 <pumpkin> yeah, the h98 hangup seems generally silly... most of the code I've seen isn't tehcnically h98-compliant
08:30:48 <Axman6> oh god, someone shoot me. i've been capped to 72kbit :'(
08:30:52 <edwardk> quicksilver: the comment i was thinking of was the bit about the line above that: "I agree in principle; you should really implement the full Haskell98 if you claim to be a Haskell implementation"
08:31:22 <quicksilver> edwardk: substantially weakened by "in principle" and "should really" and his following comments, IMO :)
08:31:40 * pumpkin shoots Axman6
08:31:45 <Axman6> ta
08:32:00 <edwardk> and immediately thereafter: "If every implementor got to choose what subset of the standard to implement that all code would have to be written in the implemented intersection. I think thats a terrible idea"
08:32:11 <edwardk> quicksilver: hence why i said 'obliquely'
08:32:15 * quicksilver nods
08:32:42 <Xen0x> jmcarthur; thanx. I will take that into account. At least I can rewrite some code using the MyThread Func
08:33:29 <Axman6> lynx to the rescue
08:33:45 <Axman6> maybe i'll end up reading things i've bee meaning to
08:34:48 <fasta> Axman6: on a phone? ;)
08:34:57 <Axman6> ?
08:35:05 <Axman6> my phone does WAP, and that's it
08:35:11 <pumpkin> my iphone connection is faster than your internet
08:35:11 <fasta> Axman6: oh god, someone shoot me. i've been capped to 72kbit :'(
08:35:23 <quicksilver> edwardk: I don't think the thread would have seemed particularly critical if it hadn't been the storm of noise over cabal's default install location and the storm of noise over n+k
08:35:24 * pumpkin rubs it in Axman6's face and so on
08:35:29 <Xen0x> jmcarthur; one question. Where can i find the myThreadFunc()?
08:35:29 <Axman6> no, my home internet fasta
08:35:40 <quicksilver> edwardk: neither of which was remotely interesting :P I regret having contributed.
08:35:52 <arabidopsis> how to use "cabal" to install a package for ALL users? "sudo cabal install" seems not working
08:36:05 <jmcarthur> Xen0x, i was suggesting that that is one way you could define your function to take a reference that you created the "normal" way in the IO monad
08:36:09 <jmcarthur> as opposed to the global, i mean
08:36:25 <jmcarthur> the myThreadFunc would have been something of your own creation
08:36:46 <TomMD> arabidopsis: You want the -global flag.  This requires root, of coarse.
08:36:55 <pumpkin> very coarse
08:37:02 <TomMD> yeah yeah
08:37:05 <Axman6> that was odd... couchdb was using neigh on 200% CPU, and i don't think i've ever run it before
08:37:06 <Xen0x> jmcarthur; k. Maybe implementing the reader monad, is a better idea
08:37:39 <TomMD> arabidopsis: Correction, that is "--global"
08:37:44 <jmcarthur> Xen0x, if this is a small project i recommend going ahead and trying it. if it's larger and already working, maybe just try it next time ;)
08:38:25 <Xen0x> jmcarthur; It's a thesis project. And I want it to be as good as possible. And I'm still able to adjust everything :)
08:38:43 <jmcarthur> Xen0x, ah, i definitely recommend taking every nice abstraction you can get then :)
08:39:38 <IhateMIRC> MIRC sux *ss
08:39:53 <IhateMIRC> what is the standard way to get time?
08:40:05 <quicksilver> getCurrentTime
08:40:08 <quicksilver> from Data.Time.
08:40:39 <IhateMIRC> i cant find docs for SYstem.time even though it works importing it
08:40:49 <TomMD> @hackage time
08:40:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/time
08:40:52 <IhateMIRC> cant find module Data.Time
08:41:02 <TomMD> @hackage old-time
08:41:02 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/old-time
08:41:23 <TomMD> IhateMIRC: Data.Time requires the Time library.  old-time is probably what you've been using.
08:41:25 <TomMD> Its old.
08:42:28 <IhateMIRC> anyone wish we had bindings for Google's SparseHash?
08:42:47 <IhateMIRC> and is Data.Map slow? slow for not being a Map or slow compared to a hashtable?
08:43:10 <Eridius> whoa, wtf? I just ran `cabal install HaXml` and it installed 1.19.3 instead of 1.19.7
08:44:04 <TomMD> Eridius: cabal update.
08:44:11 <Eridius> TomMD: cabal's the one telling me that 1.19.7 is the latest
08:44:27 <TomMD> then cabal install the specific version and see what it says.
08:44:40 <Eridius> oh wait, it installed 1.13.3, not 1.19.3. wtf
08:45:15 <Saizan_> Eridius: there are some preferences built-in
08:45:23 <Eridius> why would 1.13.3 be preferred?
08:45:29 <Saizan_> more stable
08:46:12 <Saizan_> like parsec-2 vs. parsec-3
08:46:48 <TomMD> Eridius: You can specify the version number via 'cabal install HaXML-1.19.7' - its installing fine for me right now.
08:47:02 <IhateMIRC> is there no fucntion getCurrentTime->Int?
08:47:03 <ruby2haskell> Hi I am trying to learn Haskell. I know a little ruby, and I am trying to convert a small program that I wrote in ruby to Haskell. The first thing that my program does is to read two space-separated numbers from the first line of input and save them in variables n, k, respectively. The ruby line I have reads: (n,k) = gets.split.map{|str| str.to_i()} . How do I replicate this in Haskell?
08:47:07 <IhateMIRC> i really jsut want a seed
08:47:10 <TomMD> @type getCurrentTime
08:47:11 <lambdabot> Not in scope: `getCurrentTime'
08:47:18 <IhateMIRC> so the millinseconds
08:47:25 <IhateMIRC> Rand> getCurrentTime
08:47:26 <IhateMIRC> 2009-04-21 15:46:59.2140862 UTC
08:47:26 <IhateMIRC> *
08:47:39 <IhateMIRC> but how do I get the nbrs out of it?
08:47:53 <jmcarthur> :t getLine
08:47:54 <lambdabot> IO String
08:48:00 <jmcarthur> :t read
08:48:01 <lambdabot> forall a. (Read a) => String -> a
08:48:03 <arabidopsis> if I use "cabal install --global" to install a package, where is the package.conf then?
08:48:08 <jmcarthur> :t fmap
08:48:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:48:21 <ruby2haskell> jmcarthur: thanks
08:48:21 <Eridius> arabidopsis: ghc-pkg list
08:48:25 <poucet> What is the channel for hackage?
08:48:41 <jmcarthur> ruby2haskell, that's not everything you need, but it's a start
08:48:45 <TomMD> poucet: I didn't think there was a separate one.
08:48:55 <poucet> Do you know who runs it?
08:49:01 <poucet> Igloo: ping
08:49:07 <poucet> Igloo: Are you in charge of hackage?
08:49:27 <jmcarthur> :t words
08:49:28 <lambdabot> String -> [String]
08:49:29 <Zao> > map read $ words "42 3 5" :: [Int]
08:49:31 <lambdabot>   [42,3,5]
08:49:33 <Igloo> poucet: What's the problem?
08:49:47 <poucet> Igloo: Well, the fact that you have /cgi-bin/ in the path of URLs is a bit off
08:50:11 <Igloo> That's nothing to do with me, no
08:50:32 <arabidopsis> how to remove a package with "cabal"?
08:50:35 <TomMD> I'd ask ross - he does at least some of the admin, as specified on the accounts page.
08:50:45 <Axman6> arabidopsis: ghc-pkg unregister
08:50:54 <Zao> arabidopsis: unregister and remove files yourself.
08:50:57 <IhateMIRC> i can get to difftiem but how the hell do i jsut get to integer?
08:51:04 <TomMD> arabidopsis: cabal doesn't do uninstalls right now.  Youh have to use ghc-pkg, as others just mentioned.
08:51:21 <arabidopsis> thanks guys!
08:51:23 <Axman6> :t Data.Time.getCurrentTime
08:51:24 <lambdabot> IO time-1.1.2.1:Data.Time.Clock.UTC.UTCTime
08:51:34 <jmcarthur> :t map read . words <$> getLine
08:51:35 <lambdabot> forall a. (Read a) => IO [a]
08:51:43 <poucet> TomMD: not sure whta his nick is
08:51:43 <Saizan_> UTCTime has a constructor, no?
08:51:44 <Axman6> IhateMIRC: go look at the docs for Data.Time.Clock's UTCTime
08:51:46 <TomMD> IhateMIRC: Can't you use fromIntegral.
08:52:03 <TomMD> poucet: I'd just e-mail him.
08:52:09 <Axman6> @instances-importing Data.Time.Clock Num
08:52:10 <lambdabot> DiffTime, Double, Float, Int, Integer, NominalDiffTime
08:52:12 <poucet> TomMD: alright, thanks
08:52:24 <Axman6> @instances-importing Data.Time.Clock.UTC Num
08:52:25 <lambdabot> Double, Float, Int, Integer
08:52:32 <quicksilver> IhateMIRC: there is a built-in thing to get a seed from the time.
08:52:38 <quicksilver> :t newStdGEn
08:52:40 <lambdabot> Not in scope: `newStdGEn'
08:52:41 <quicksilver> :t newStdGen
08:52:42 <lambdabot> IO StdGen
08:52:44 <quicksilver> that one.
08:53:05 <ruby2haskell> how do I get the String out of IO String ?
08:53:18 <quicksilver> by using <-
08:53:24 <TomMD> We should have a platform independent library for getting good seeds.  Something based on the Windows crypt api and /dev/urandom.
08:53:38 <Axman6> you don't really, but yeah, using str <- ioStringThing in a do block will do it
08:53:51 <quicksilver> foo <- getLine; putStrLn ("You typed " ++ foo)
08:53:53 <quicksilver> for example
08:53:55 <fasta> TomMD: don't we already have that?
08:53:57 <quicksilver> inside a 'do' block.
08:54:05 <TomMD> fasta: Not that I know of, but I could have missed it.
08:54:10 <Axman6> ruby2haskell: check out http://axman6.homeip.net/blog/axmans-haskell-io-tutorial.html and let me know what you think, if you like :)
08:54:14 <fasta> TomMD: at least, we have the interface.
08:54:16 <IhateMIRC> no dont want it
08:54:22 <Axman6> should help understand IO in haskell enough to get you started
08:54:39 <ruby2haskell> axman6: thank you
08:54:44 <romildo> How to read unicode strings from stdin with ghc?
08:54:45 <ruby2haskell> quicksilver: thanks
08:55:03 <quicksilver> romildo: in what encoding?
08:55:13 <romildo> quicksilver, utf8
08:55:44 <IhateMIRC> a :: UTCTime i need to go from that to Int
08:55:52 <poucet> TomMD: email sent
08:55:58 <quicksilver> romildo: get the utf8-string package and use the utilities in System.IO.UTF8
08:56:04 <poucet> TomMD: Thanks for the pointer.
08:56:05 <quicksilver> IhateMIRC: what's wrong with newStdGen ?
08:56:11 <fasta> TomMD: we have getStdGen, but I see the problem.
08:56:31 <fasta> TomMD: getStdGen should have been built on top of getSeed
08:56:43 <fasta> TomMD: where getSeed is a non-existing function.
08:56:59 <fasta> TomMD: that was your point, right?
08:57:14 <romildo> quicksilver, thanks.
08:58:21 <dmead> i must say
08:58:22 <TomMD> fasta: Yes, thats it.
08:58:24 <IhateMIRC> sigh wtf
08:58:24 <IhateMIRC> how can i not get from UTCTIME to int?
08:58:32 <dmead> i like the ml syntax for lambda functions better than haskell
08:58:41 <romildo> quicksilver, and the program arguments, how do I get them as unicode strings?
08:58:51 <dmead> fn x => is more descriptive than (\x ->..
08:59:09 <dolio> romildo: The text package is also an option.
08:59:35 <quicksilver> romildo: that's an interesting point.
08:59:50 <quicksilver> romildo: I guess you have to treat them as bytes and re-decode them
08:59:53 <quicksilver> which is a bit ugly.
08:59:57 <dolio> Although I don't think there's lazy text yet...
09:00:00 <TomMD> IhateMIRC: That probably can't be done due to UTCTime being represented internally by several Integers - so converting them to an Int isn't exactly straight forward.
09:00:15 <quicksilver> c2w :: Char -> Word8 ; c2w = fromIntegral . ord
09:00:23 <quicksilver> then "decode . map c2w"
09:00:29 <quicksilver> where decode is the thing from utf8-string.
09:00:31 <quicksilver> yucky.
09:00:32 <fasta> TomMD: well, I totally agree :)
09:00:48 <quicksilver> IhateMIRC: answer my question.
09:00:53 <quicksilver> IhateMIRC: what is wrong with newStdGen.
09:01:11 <TomMD> We need a team of paid open source Haskell hackers that do nothing but community work.
09:01:31 <dolio> Haskell is so advanced that you don't need to seed the random generator youself!
09:01:53 <TomMD> It so advanced that you don't need to allocate the memory yourself...
09:01:56 <quicksilver> dmead: heresy ;)
09:02:08 <dmead> fn x => is waii kewler
09:02:41 <Eridius> aww, really? HaXml's httpParse doesn't even handle a very basic error (erroneous close tag with no corresponding open tag)?
09:02:51 <jmcarthur> @pl \x -> is waii kewler
09:02:51 <lambdabot> const (is waii kewler)
09:02:54 <fasta> TomMD: also, you cannot allocate all the memory yourself for a certain part of the program, even if you wanted it.
09:03:33 <TomMD> fasta: Whatever do you mean?  I can allocate by the megabyte and crash if the program tries to use more than allocated.
09:03:44 <TomMD> but I guess that isn't very good.
09:04:12 <IhateMIRC> does =<< take soemthing from IO?
09:04:37 <MyCatVerbs> Eridius: XML parsers are usually designed to be fussy. tagsoup, perhaps?
09:04:44 <fasta> TomMD: I was under the impression that even if your program is basically a C program, the GC still runs, how weird that may sound.
09:05:00 <EvilTerran> IhateMIRC, effectively, yes, although you need to go back into IO when you're done
09:05:05 <Eridius> MyCatVerbs: I'm looking at tagsoup now, but it's not very user-friendly. And yes, XML parsers are designed to be fussy, but HaXml has an httpParse function which theoretically is much more lenient about errors
09:05:38 <jmcarthur> IhateMIRC, "take" might be the wrong word. essentially it applies a function that takes a pure values and returns an action on the left and an action on the right, feeding the output of the right action to the left function
09:05:54 <jmcarthur> :t (=<<)
09:05:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:06:02 <TomMD> fasta: I don't think you can stop the GC from running, but you can stop it from requesting more memory from the system.  The issue is how to handle situations when the mutator requests more and there is no memory to be had.
09:06:10 <malcolmw> Eridius: HaXml's html parser is indeed less fussy, but there is a limit to how much it can correct/ignore
09:06:47 <malcolmw> tagsoup is much laxer, so probably more useful in your situation
09:06:55 <TomMD> fasta: Its my opinion that static analysis of a program that proves it won't ever use more than X MB of memory would be sufficient for most situations.
09:07:15 <Eridius> malcolmw: yeah, looking at that right now
09:07:33 <fasta> TomMD: what exactly is "running"? I mean the idea should be that it only walks over the heap when it actually is out of memory. So, if you only use malloc and so on, then it should be possible to write a real-time program.
09:07:41 <TomMD> fasta: But it seems most people in the field are working to make critical code segments be zero-allocation (i.e. so they can be used as interrupt handlers).
09:08:36 <fasta> TomMD: or they just prove that there is some upper bound on the amount of memory the application uses.
09:08:54 <TomMD> fasta: We have two separate goals (but not unrealated).  I desire to see memory bounds while you desire to have latency bounds, which is complicated by the GC.
09:10:41 <TomMD> Too bad knowing memory bounds can still leave an amazing amount of GC - the free memory can run out frequently, requiring a GC to find the memory to fill a current allocation request.
09:12:55 <fasta> TomMD: I changed my mind, regarding whether it is possible to write a real-time program using C Haskell. "When the RTS detects memory pressure the GC stops all the Haskell threads and then one thread that does the garbage collection and then resumes all the other suspended threads."
09:13:24 <IhateMIRC> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4054#a4054
09:13:24 <IhateMIRC> ^^ i want to take currenttime and place it into the IORef but it doenst want to come with me :P
09:13:24 <IhateMIRC> globalSeed = unsafePerformIO $ newIORef (timeToInt =<< getCurrentTime)
09:13:24 <IhateMIRC> shouldnt that work?
09:16:28 <TomMD> Nope, and I would try hard to avoid the unsafePerformIO global hack.
09:16:52 <TomMD> globalSeed = unsafePerformIO $ getCurrentTime >>= return . timeToInt >>= newIORef
09:16:53 <TomMD> Something like that.
09:17:17 <vixey> what does global mean?
09:17:49 <doserj> globalSeed = unsafePerformIO $ getCurrentTime >>= newIORef . timeToInt
09:17:51 <fasta> vixey: visible to every module importing it, AFAIK.
09:18:10 <doserj> but this is really not the way to do it...
09:21:25 <IhateMIRC> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4055#a4055
09:21:39 <IhateMIRC> ^^ isnt that simple module about 100 times more neat than System.Random?
09:22:02 <vixey> IhateMIRC: no
09:22:50 <IhateMIRC> it's so neat I want to hug it
09:22:59 <IhateMIRC> not 100% about the randWith function but it is from K&R the classic C-book
09:23:04 <vixey> guess you're not actualy interested in other peoples thoughts
09:23:50 <IhateMIRC> i am
09:24:01 <IhateMIRC> but you jsut said no without motivation
09:24:34 <fasta> The only objection I have to that code is that unsafePerfomIO has next to no semantics.
09:25:01 <IhateMIRC> what do you mean no semantics? i should add a random type?
09:25:28 <fasta> IhateMIRC: try to find out what unsafePerformIO does and then report back
09:26:22 <doserj> IhateMIRC: how is you rand nicer than System.Random.randomIO?
09:27:06 <vixey> tell me what you hope to improve on System.Random?
09:28:07 <araujo> http://alarmingdevelopment.org/?p=209
09:29:04 <ruby2haskell> how do I fix the indentation of Haskell files in Vim? Using gg=G screws up the indentation : I spent the last half an hour trying to figure out what the error "Illegal signature in pattern: IO () main" meant, and finally figured out that this was because Vim indented the code badly.
09:29:22 <IhateMIRC> neatness
09:30:18 <vixey> that's too subjective
09:31:18 <IhateMIRC> add this: {-# NOINLINE globalSeed #-} ?
09:32:08 <centrinia__> IhateMIRC, use (unsafePerformIO randomIO)
09:32:35 <ruby2haskell> found the answer: put the following file in ~/.vim/indent : http://tokyoenvious.xrea.jp/vim/indent/haskell.vim
09:32:38 <doserj> no, just use randomIO
09:32:52 <centrinia__> doserj, That involves the IO monad. :(
09:32:53 <Gracenotes> the way you go about your functionality isn't much different from the way System.Random does it
09:33:06 <Gracenotes> and, you have less functionality
09:33:14 <Gracenotes> (which I suppose it neater, but at quite a cost)
09:33:16 <doserj> centrinia__: so does IhateMIRC's code
09:33:17 <Gracenotes> *is
09:33:18 <IhateMIRC> somehow i have missed randomIO
09:33:45 <edwardk> IhateMIRC the consequence of allowing 'pure' code to invoke a random number generator is that you break equational reasoning. There is a reason why unsafePerformIO is unsafe.
09:34:52 <Gracenotes> I quote, from System.Random: theStdGen  = unsafePerformIO $ do { rng <- mkStdRNG 0; newIORef rng }
09:35:08 <Eridius> @pl \x -> f x || g x
09:35:09 <lambdabot> liftM2 (||) f g
09:35:11 <IhateMIRC> so what do you mean? how is the code not safe? once it is taken fromthe IO Monad it is safe anyway right?
09:35:14 <quicksilver> IhateMIRC: you've just reimplemented System.Random
09:35:19 <quicksilver> IhateMIRC: how is that better?
09:35:36 <quicksilver> IhateMIRC: your "rand" is just a reimplementation of "randomIO :: IO Int"
09:35:42 <IhateMIRC> neater
09:35:42 <IhateMIRC> not better
09:35:48 <IhateMIRC> i jsut wanted a non PITA way to sya ey man give me a lsit with random nbrs
09:35:50 <centrinia__> Is unsafePerformIO . return = id?
09:35:51 <quicksilver> it's not neater.
09:35:53 <quicksilver> it's THE SAME
09:35:56 <quicksilver> no neater at all.
09:36:02 <quicksilver> exactly the same thing with different names.
09:36:06 <edwardk> @type randoms
09:36:07 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
09:36:08 <IhateMIRC> > take 100 $ repeat "neat"
09:36:08 <quicksilver> and missing functionality.
09:36:09 <lambdabot>   ["neat","neat","neat","neat","neat","neat","neat","neat","neat","neat","nea...
09:36:10 <vixey> centrinia: who knows
09:36:11 <vixey> ?
09:36:18 <centrinia__> > randoms
09:36:19 <TomMD> dcoutts_: I've made a few more changes to hackage-server, but have held off most work while wondering if there is an issue with the happstack-0.2 patch I sent in (its not merged yet).  I've got midterms to worry about right now, but hope to get some real progress going after that.
09:36:19 <lambdabot>       Overlapping instances for Show (g -> [a])
09:36:19 <lambdabot>        arising from a use of ...
09:36:28 <centrinia__> > randoms (mkStdGen 1)
09:36:30 <lambdabot>   [7917908265643496962,-1017158127812413512,-1196564839808993555,128524678767...
09:36:36 <centrinia__> Those are random enough. :)
09:36:39 <Axman6> > randomRs (mkStdGen 18392) :: [Int]
09:36:40 <lambdabot>   Couldn't match expected type `(a, a)'
09:36:47 <Axman6> > randoms (mkStdGen 18392) :: [Int]
09:36:48 <lambdabot>   [218755229354549957,-4958475688756885885,5176392406896896137,34360146319006...
09:36:54 <Axman6> > randoms (mkStdGen 18392) :: [Int8]
09:36:55 <lambdabot>       No instance for (Random Int8)
09:36:55 <lambdabot>        arising from a use of `randoms' at...
09:36:59 <IhateMIRC> oh well I kind of just wanted to learn how to do a half-decent RNG anyway
09:36:59 <Axman6> > randoms (mkStdGen 18392) :: [Int32]
09:37:01 <lambdabot>       No instance for (Random Int32)
09:37:01 <lambdabot>        arising from a use of `randoms' a...
09:37:03 <Axman6> :o
09:37:06 <Gracenotes> lambdabot can haz heug Int?
09:37:07 <IhateMIRC> is the K&R function good?
09:37:16 <centrinia__> IhateMIRC, No.
09:37:24 <Gracenotes> C's rand is.. somewhat suspect
09:37:27 <centrinia__> It is not random enough.
09:37:42 <centrinia__> I don't think that it passed the spectral test with flying colors.
09:37:48 <omnihil> to get good random numbers you should take a cryptographic hash of a picture of a lava lamp.
09:37:48 <burp_> http://random.irb.hr/ check this for real random data :p
09:38:01 <edwardk> IhateMIRC: linear congruential PRNGs are hardly considered good random number generators these days =)
09:38:11 <IhateMIRC> how do you analyze periodicness of a RNG?
09:38:15 <edwardk> omnihil: not a picture, a video ;)
09:38:23 <centrinia__> @let randoms = const (const 9)
09:38:24 <lambdabot>  Defined.
09:38:26 <omnihil> edwardk, one frame per sample of random digits.
09:38:39 <edwardk> IhateMIRC: there are a lot of randomness tests that you can apply, chi square, etc.
09:39:01 <Gracenotes> http://en.wikipedia.org/wiki/Linear_congruence_generator lists a formula for conditions <=> full period
09:39:07 <edwardk> IhateMIRC: periodicity is hard to bound, but you can pigeonhole an upper bound
09:39:12 <centrinia__> IhateMIRC, the period of an RNG is at most the number of possible values that its state can take.
09:39:18 <edwardk> er hard to determine
09:39:41 <Axman6> this is a terrible error message:
09:39:42 <Axman6>     Could not find module `Control.Monad.State':
09:39:43 <Axman6>       it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2
09:39:55 <centrinia__> If you have an n bit state, then it can have a period of at most 2^n
09:40:04 <edwardk> axman: heh
09:42:18 <edwardk> @seen mmorrow
09:42:18 <lambdabot> mmorrow is in #yi, #ghc and #haskell. I last heard mmorrow speak 6h 15m 38s ago.
09:42:57 <IhateMIRC> > randoms
09:42:57 <IhateMIRC> > let quantumEntangle a = show a ++ "is all in with Schordinger's Cat" in quantumEntangle "edwardk"
09:42:58 <lambdabot>       Ambiguous occurrence `randoms'
09:42:58 <lambdabot>      It could refer to either `L.randoms...
09:42:59 <lambdabot>   "\"edwardk\"is all in with Schordinger's Cat"
09:43:22 <IhateMIRC> > let quantumEntangle a = show a ++ "is all messed up with Schroedinger's Cat" in quantumEntangle "edwardk"
09:43:24 <lambdabot>   "\"edwardk\"is all messed up with Schroedinger's Cat"
09:43:39 <Axman6> @hackage monads-fd
09:43:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monads-fd
09:43:59 <quicksilver> Axman6: bug report that :)
09:44:08 * edwardk tries not to get entangled with cats, they have claws and it hurts.
09:44:41 <Axman6> i would, but my internet's capped at 72kbit, so i'm trying to avoid the web as much as possible
09:45:19 <Axman6> quicksilver: you wouldn't happen to know what i'd need to do to fix that issue would you? trying to get uhc built
09:45:23 <IhateMIRC> > flip (-) 12 20
09:45:25 <lambdabot>   8
09:45:35 <Philonous1> I just found out that I can model existentals using closures. And now I wonder which one I should use
09:45:47 <IhateMIRC> > take 20 $ map (flip (-) 10) [1..]
09:45:49 <lambdabot>   [-9,-8,-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7,8,9,10]
09:45:53 <Saizan_> Axman6: ghc-pkg hide one of the two
09:46:19 <Axman6> any preference on which should be hidden?
09:46:28 <dolio> > map length ["subtract", "flip (-)"]
09:46:30 <lambdabot>   [8,8]
09:46:41 <edwardk> Axman6: probably the monads-fd one that no one uses
09:46:54 <Axman6> yeah, i was thinking that too. i've never heard of it before
09:47:10 <dolio> Using closures?
09:47:29 <Axman6> seems to be doing the job, thanks Saizan_ and edwardk
09:47:45 <edwardk> Axman6: i think it is a newer attempt to split mtl into two implementations one with fundeps one with type families
09:47:54 <dolio> You mean: exists a. P a = forall r. (forall a. P a -> r) -> r?
09:48:01 <Axman6> i see
09:48:09 <ruby2haskell> Axman6: Your tutorial was quite helpful : I have got my n and k in hand now :) Thanks
09:48:20 <Axman6> ruby2haskell: excellent :)
09:49:05 <adaw4da> hi all
09:49:14 <adaw4da> c++ is down then I ask here if I can..
09:49:17 <adaw4da> in term of efficency, is it better to use static members with a lot of parameters or instance members with few parameters?
09:49:38 <Axman6> yes
09:49:52 <vixey> adaw4da wtf
09:50:22 <ruby2haskell> Now I'd like to know how I can iterate over lines in the input, and do something for each line: in ruby that would be STDIN.each do { |line| code that uses line}
09:50:23 <Gracenotes> #c++ is fine
09:50:33 * Axman6 didn't know a language could go down
09:50:40 <edwardk> @type interact
09:50:41 <lambdabot> (String -> String) -> IO ()
09:50:49 <adaw4da> c++ isn't fine..
09:50:49 <Axman6> ruby2haskell: interact
09:50:56 <ruby2haskell> thanks
09:51:05 <adaw4da>  You've reached this channel because the channel you tried to enter has been configured with join throttling (+J). There may be a clonebot attack in progress there,
09:51:18 <vixey> adaw4da nothing to do with #haskell
09:51:18 <Axman6> adaw4da: well try again
09:51:37 <Gracenotes> (if you still can't join #c++, try asking in #freenode)
09:53:11 <IhateMIRC> adaw4da: you neeed to be logged in to C++ iotherwsie you get sent to overflow
09:54:00 <Gracenotes> /msg nickserv help register
09:54:10 <Gracenotes> ^ to get registered
09:57:25 <adaw4da> kk
09:57:27 <adaw4da> thx
09:57:28 <adaw4da> :)
09:57:46 <Axman6> _-
09:58:03 <FlippinCadavers> http://www.reason.com/news/show/131717.html
09:58:16 <FlippinCadavers> neanderthals brought back to life, would they hack haskell?
09:58:52 <vixey> what do you mean brought _back_ to life
09:59:21 <edwardk> i'm surrounded by them, but they mostly write c# these days
09:59:37 <edwardk> They like the new cave designer
10:00:03 <edwardk> and the "what you see is what you hit" interface design
10:00:42 <FlippinCadavers> what generator does System.Random use? mersenne twister?
10:00:59 <FlippinCadavers> vixey: i mean it literally
10:01:12 <FlippinCadavers> what moral rights would they have? -> philosophy
10:01:40 <Axman6> not sure, but System.Random.Mersenne does (Dons wrote that, and it's a lot faster than System.Random)
10:03:09 <Mr_Awesome> is it more random?
10:03:24 <ddarius> Mr_Awesome: Likely
10:03:43 <simplesimon> wooohooooo
10:03:55 <Axman6> yeah, i think it has a much larger period
10:04:20 <centrinia__> The period is 2^19937-1 :)
10:04:27 <quicksilver> mmorrow: cute. Who would have thought a moebius band was a local minimum for the graph of a hexagonal prism.
10:04:47 <vixey> huh??
10:05:06 <TomMD> quicksilver: He hasn't been in for hours, do you know if he checks his IRC history?
10:05:08 <Philonous1> dolio: The idea was to instead of an existential type Data Foo = forall a. Bar a => Foo a store a tuple with all functions in the class Bar already applied to the value.
10:05:09 <quicksilver> mmorrow: well ok, I lie. A band with a double twist.
10:05:13 <quicksilver> TomMD: I think he does.
10:06:52 <TomMD> @tell mmorrow Someone mentioned I should ask you about vacuum / GHC api having exceptions on "special" data types, such as MVars, IORefs, Ptrs (and thus ByteStrings).  Could you give me the low down on if this is being worked or if I should just regard it as a limitation of vacuum
10:06:52 <lambdabot> Consider it noted.
10:07:06 <zeno> @hoogle Integer -> Int
10:07:06 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
10:07:06 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
10:07:06 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
10:07:26 <FlippinCadavers> 2^~19K
10:07:34 <centrinia__> 2^19937-1 ;)
10:07:43 <centrinia__> > 2^19937-1
10:07:45 <FlippinCadavers> ah
10:07:45 <lambdabot>   431542479738816264805523551633791983905393504322671150516525054140333068013...
10:08:02 <pumpkin> > length . show $ 2^19937-1
10:08:03 <lambdabot>   6002
10:08:07 <pumpkin> zomg
10:08:15 <pumpkin> that's 2 * 3001!
10:08:29 <centrinia__> The minus one is important. It is related to the fact that the zero state is not valid. ;)
10:08:45 <pumpkin> @let (!) x = product . enumFromTo 1
10:08:46 <lambdabot>  Defined.
10:08:48 <pumpkin> crap
10:08:56 <pumpkin> @unlet
10:08:56 <lambdabot>  Defined.
10:08:59 <pumpkin> hmm
10:09:03 <pumpkin> @undef
10:09:24 <pumpkin> @let (!) x = product [1..x]
10:09:25 <lambdabot>  Defined.
10:09:30 <pumpkin> > 3001!
10:09:30 <lambdabot>   <no location info>: parse error on input `;'
10:09:31 <centrinia__> The most commonly used Mersenne twister corresponds to the cyclic group C_{2^19937-1}
10:09:33 <pumpkin> :(
10:09:44 <pumpkin> lies
10:09:49 <centrinia__> @undef
10:09:59 <centrinia__> @let (!) x _ = product [1..x]
10:10:01 <lambdabot>  Defined.
10:10:08 <centrinia__> > 3001 ! 0
10:10:09 <lambdabot>       Ambiguous occurrence `!'
10:10:09 <lambdabot>      It could refer to either `Data.Array.!', ...
10:10:15 <centrinia__> > 3001 L.! 0
10:10:17 <lambdabot>   124522281699170001107561581463529231250243087039903615629860924407503732539...
10:10:31 <centrinia__> That's pretty fugly. :(
10:10:34 <vixey> @undef
10:10:39 <vixey> @let (!) x = product [1..x]
10:10:40 <lambdabot>  Defined.
10:10:42 <vixey> > (4 !)
10:10:43 <lambdabot>       Ambiguous occurrence `!'
10:10:44 <lambdabot>      It could refer to either `Data.Array.!', ...
10:10:46 <vixey> > (4 L.!)
10:10:47 <lambdabot>   24
10:11:00 <centrinia__> > 4 L.!
10:11:01 <lambdabot>   <no location info>: parse error on input `;'
10:11:16 <centrinia__> Why does it have to be enclosed in parentheses?
10:11:49 <Axman6> h98 compatibility
10:11:51 <Axman6> >_>
10:11:56 <omnihil> > ([0..20] !! 3 !)
10:11:57 <lambdabot>       Ambiguous occurrence `!'
10:11:57 <lambdabot>      It could refer to either `Data.Array.!', ...
10:12:14 <omnihil> ([..20] !! 3 L.!)
10:12:23 <omnihil> er
10:12:25 <mofmog> you can make a partially evaluated type an instance of something right?
10:12:28 <omnihil> > ([1..20] !! 3 L.!)
10:12:29 <lambdabot>   24
10:12:32 <centrinia__> > [..20]
10:12:33 <lambdabot>   <no location info>: parse error on input `..'
10:12:34 <mofmog> for example, turn Either String into a monad
10:12:52 <vixey> mofmog: yes
10:12:53 <centrinia__> @instances Monad
10:12:54 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
10:12:57 <centrinia__> Yes.
10:13:02 <mofmog> unless it's already done for me
10:13:23 <mofmog> hrm, i just ask for error handling purposes
10:13:23 <vixey> mofmog: there's some weird Either monad with a Error constraint, no clue why
10:13:31 <centrinia__> > Left "foo" >> Left "bar"
10:13:33 <lambdabot>   Left "foo"
10:13:46 <centrinia__> I don't understand.
10:13:49 <mofmog> wait, i should use writer shouldnt i
10:13:52 <Axman6> @index readLn
10:13:53 <lambdabot> System.IO, Prelude
10:13:53 <mofmog> durrr
10:13:55 <vixey> > Left "foo" >> Right "bar"
10:13:56 <lambdabot>   Left "foo"
10:13:57 <Axman6> hmm
10:13:58 <vixey> > Right "foo" >> Right "bar"
10:13:59 <lambdabot>   Add a type signature
10:14:12 <vixey> > Left "foo" >> Right "bar" :: Either String String
10:14:13 <lambdabot>   Left "foo"
10:14:14 <vixey> > Right "foo" >> Left "bar"
10:14:14 <centrinia__> > Right "foo" >> Left "bar"
10:14:15 <lambdabot>   Left "bar"
10:14:16 <lambdabot>   Left "bar"
10:14:34 <centrinia__> Oh, so it is like Maybe String.
10:14:39 <vixey> yes
10:15:05 <mofmog> nevertheless, writer monad == better idea
10:15:14 <vixey> horrid use of ==
10:15:24 <Gracenotes> Righto
10:15:38 <centrinia__> Use a partial order instead. ;)
10:15:41 <wks> > Left 1 >> Right 2 >> Left 3 >> Right 4
10:15:43 <lambdabot>   Add a type signature
10:15:50 <kristofer> I can import Data.Generics in ghci, but I get this cabal building a package    Could not find module `Data.Generics':
10:15:53 <kristofer> any ideas?
10:16:06 <Gracenotes> unfortunately, there's not a general instance.. because of LANGUAGE FAIL
10:16:17 <wks> > Left 1 >> Right 2 >> Left 3 >> Right 4 :: Either Int Int
10:16:18 <lambdabot>       No instance for (Error Int)
10:16:18 <lambdabot>        arising from a use of `>>' at <inter...
10:16:29 <Gracenotes> literally because of fail, though
10:16:32 <Gracenotes> afaik
10:16:42 <Axman6> hmm, uhc doesn't know about readLn
10:16:57 <Cale> Axman6: That's an easy bug to fix :)
10:17:13 <Axman6> indeed
10:18:39 <byorgey> edwardk: ping
10:20:26 * mofmog is again cursing haskell-mode's :cd ~/.cabal's retardation
10:20:28 <Philonous1> dolio: Let me rephrase: All you can do with an existentially quantified value is call one of the functions in the class it is quantified over. You could however instead just partially apply all the functions in the class beforehand and store the results (might be closures or just plain values). Lazy evaluation will make sure both will result in the same behaviour.
10:22:38 <wli> Can things be existentially quantified over multiple types?
10:22:43 <Axman6> is there a h98 way to get commandline args? (for use with UHC)
10:23:22 <mofmog> actually, i should be using fail and a general monad
10:23:29 <wli> Can things be existentially quantified over multiple classes rather?
10:24:40 <mofmog> random thought: is there some way or language ext in the works that could automatically generate the zipper of a data type
10:24:51 <vixey> mofmog: I think it's been done in haskell
10:24:52 <Saizan_> wli: yes
10:25:10 <vixey> @go andreas multirec
10:25:11 <lambdabot> No Result Found.
10:25:19 <Saizan_> wli: data Foo = forall a. (Bar a, Baz a) => Foo a is perfectly valid
10:25:29 <ddarius> Philonous1: You can't always "just partially apply" all the methods because not all methods are t -> foo -> bar -> baz
10:26:20 <vixey> @hackage zipper
10:26:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zipper
10:29:02 <Eridius> hrm, does ghc --make not run hsc2hs for me?
10:30:04 <Axman6> i doubt it
10:30:32 <Ornedan_> Is there a generic string splitting function in the standard libraries? Like Java's String.split?
10:30:58 <Ornedan_> I can't seem to spot one in Data.List, at least
10:31:04 <skorpan> Ornedan_: there's words
10:31:06 <skorpan> :t words
10:31:08 <lambdabot> String -> [String]
10:31:14 <skorpan> > words "Hi there"
10:31:15 <lambdabot>   ["Hi","there"]
10:31:15 <vixey> @wiki Data.List.Split
10:31:16 <lambdabot> http://www.haskell.org/haskellwiki/Data.List.Split
10:31:27 <Ornedan_> _generic_
10:31:34 <skorpan> Strings are generic ......... ;P
10:31:35 <vixey> Orenedan check the link
10:33:02 <byorgey> Ornedan_: you should really look at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split, not the wiki page vixey linked to
10:33:20 <byorgey> the wiki page has all the messy details from the development process for the split package
10:33:31 <byorgey> but now you can just 'cabal install split' and away you go =)
10:33:36 <Ornedan_> Cheers
10:35:16 <Philonous1> ddarius: What kind of methods are not which I can use in the existential case?
10:35:37 <vixey> byorgey that's not linked from it ?
10:35:58 <byorgey> it is, but it's not particularly obvious
10:36:00 <vixey> oh still just says "1 A combinator approach?"
10:36:05 <byorgey> probably it should be edited to make it more clear
10:36:12 <vixey> yeah
10:36:22 <byorgey> but I don't have time at the moment =)
10:36:26 <Cale> Philonous: there are some (moderately contrived) examples, like methods involving other datastructures which are parametrised over the existential type
10:38:41 <ddarius> Philonous: You can use them with existentials, but you can't always mimic that by using partial application.  A trivial example, mempty.
10:40:48 <Cale> http://okmij.org/ftp/Computation/Existentials.html#eliminating-translucent
10:42:10 <Cale> ^^ cases like that one make translating away existentials arbitrarily complicated
10:42:36 <Cale> (I suspect it's even worse if the list data constructor is replaced by some abstract datatype)
10:42:48 <Eridius> is there any way I can have two instances for Foo, one being instance (Foo a) => Foo a, the second being instance Foo [Char], and have it actually work?
10:42:49 <Cale> Er, list *type* constructor
10:42:57 * Eridius notes that Char is not an instance of Foo
10:43:20 <Cale> Do you want the difference for Foo String to be different from Foo [a] ?
10:43:26 <Eridius> yes
10:44:17 <Eridius> I have a data type FooObj with multiple constructors, Foo String should produce a FooString String object but Foo [a] should produce a FooArray [FooObj]
10:44:47 * Eridius is trying to avoid requiring the client to throw extra type constructors around
10:44:50 <Saizan_> Eridius: OverlappingInstances
10:45:08 <Eridius> Saizan_: ah hah, thank you
10:45:14 * Eridius wonders why the ghc error message didn't offer that as a solution?
10:45:28 <Saizan_> not one of the most approved extensions, to be honest
10:45:46 <Eridius> whoa, now the Foo String works but not the Foo [a]
10:46:11 <Eridius> -XIncoherentInstances? o_O
10:46:29 <idnar> -XHelpImTrappedInACompiler
10:46:51 <Eridius> hrm, the GHC User's Guide links from the Haskell Prime Trac are broken
10:46:55 <Saizan_> the Foo [a] will work if you give enough context to tell that 'a' is not Char
10:47:22 <Eridius> I tested with convertToFooObj [1,2,3]
10:47:41 <Saizan_> try convertToFooObj [1::Int,2,3]
10:47:57 <Eridius> ok, that worked
10:48:15 <Saizan_> :t 1
10:48:16 <lambdabot> forall t. (Num t) => t
10:48:20 <Eridius> what does IncoherentInstances do? I can't find any docs
10:48:41 <Eridius> it actually makes the convertToFooObj [1,2,3] work
10:49:01 <Philonous> Cale: This paper seems to address exactly my "idea". Thanks a bunch.
10:50:14 <Cale> Philonous: I had the same idea. (and oleg did as well, seemingly :) It seems that in most cases it really is easily possible, but in somewhat more contrived ones, it gets arbitrarily hard.
10:51:47 <Saizan_> Eridius: arond the end of this section: http://haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
10:51:55 <ddarius> For using existentials to model objects, it should more or less always work out, but I'm pretty sure as soon as you start going beyond that/doing other things it will start to fail miserabley.
10:51:55 <Eridius> ah hah, thanks
10:53:05 <roconnor> > fmap tan randoms (mkStdGen 2009)
10:53:05 <ddarius> Certainly the fundamental observation, that we can replace an existential type with its observables, is sound, but precisely capturing those observables is difficult and likely impossible in some cases.
10:53:06 <lambdabot>       No instance for (Floating [a])
10:53:06 <lambdabot>        arising from a use of `tan' at <i...
10:53:17 <roconnor> > fmap tan (randoms (mkStdGen 2009))
10:53:18 <lambdabot>   [1.0168282589408242,0.885804451593544,0.3847833956756819,0.5791947467038132...
10:53:50 <roconnor> > sum $ take 100 $ fmap tan (randoms (mkStdGen 2009))
10:53:51 <lambdabot>   64.76952725857333
10:54:13 <jeffersonheard> As soon as I'm sure it's working, I'll release it, but it looks like I now have an OpenGL backend for Hieroglyph.  In addition, it's more semantically clean than before and text is now done using Text.PrettyPrint and Pango's markup.
10:54:23 <roconnor> oops
10:54:48 <Philonous> Well, my original problem was (and still is) whether I should use existentials or closures in a simple case.
10:55:01 <roconnor> > sum $ take 100 $ fmap tan (randomRs (-pi/2,pi/2) (mkStdGen 2009))
10:55:02 <lambdabot>   92.29842021206518
10:55:31 <roconnor> > sum $ take 1000 $ fmap tan (randomRs (-pi/2,pi/2) (mkStdGen 2009))
10:55:33 <lambdabot>   131.29043052804488
10:55:49 <roconnor> > sum $ take 10000 $ fmap tan (randomRs (-pi/2,pi/2) (mkStdGen 2009))
10:55:51 <lambdabot>   -32852.10021561583
10:56:41 <conal> jeffersonheard: sounds great!
10:57:13 <jeffersonheard> :)
10:58:27 <BONUS> hmm
10:58:34 <BONUS> is Kleisli an instance of Monad somewhere?
10:58:47 <conal> BONUS: of Arrow
10:59:11 <BONUS> yeah
10:59:15 <conal> BONUS: Kleisli wraps a -> m b as an arrow
10:59:36 <dschoepe> Is it intentional that there's no instance declaration in the `numbers' package for (Enum a) => Enum (Dif a) or is its lack accidental?
10:59:37 <BONUS> yeah, i was basically wondering if there's a transformer for the (->) r monad
10:59:49 <BONUS> and then i realized that it's just a->m b, which is kliesli
11:01:42 <conal> jeffersonheard: are you getting cairo/pango renderings into opengl buffer objects or some such?
11:02:52 <Saizan_> BONUS: ReaderT
11:02:55 <jeffersonheard> conal: yes and no.  I'm using cairo/pango for text only.  Everything else is written directly in OpenGL.  It doesn't support everything yet, namely line caps and different antialiasing modes, but most everything should look the same
11:03:18 <BONUS> haha of course, duh
11:03:29 <BONUS> that one was kind of obvious, silly of me
11:03:37 <jeffersonheard> I've got code in there to optimize geometry to buffer objects, but it isn't active quite yet -- using direct to render at the moment.
11:03:52 <jeffersonheard> Was trying to debug it before I went to buffer objects.
11:06:24 <jeffersonheard> direct to render... sorry, immediate mode
11:09:31 <Eridius> ok, I understand how you can use a foreign import to get access to a C function, but is there any way to use that to gain access to an a const extern value?
11:09:49 <Eridius> or rather, is there any way to gain access to a const extern value (whether or not it's achieved through some variant on foreign import)
11:12:08 <Eridius> ah, foreign import ccall "&" ?
11:15:07 <roconnor> > sum $ take 10000 $ fmap tan (randomRs (-pi/2,pi/2) (mkStdGen 2009))
11:15:08 <lambdabot>   -32852.10021561583
11:15:12 <roconnor> > sum $ take 100000 $ fmap tan (randomRs (-pi/2,pi/2) (mkStdGen 2009))
11:15:15 <lambdabot>   81441.36962914834
11:17:22 <cooldude227> does anybody have any idea how Yi works? i can't figure out the keymaps stuff. i just want to define a shortcu
11:17:25 <cooldude227> t
11:17:36 <Eridius> cooldude227: you might have more luck in #yi
11:18:56 <cooldude227> i didn't know that was there, thank you
11:19:34 <vixey> what are you looking fro roconnor?
11:24:09 <Eridius> whoa, using the "&" foreign import thing requires -fvia-C?
11:25:16 <glguy> keep reading
11:25:30 <Eridius> error message: Illegal foreign declaration: requires via-C or native code generation (-fvia-C)
11:25:57 <glguy> basically, you can't open it in ghci
11:26:04 <Eridius> ahh
11:26:18 <Eridius> well that's annoying
11:26:29 <Lemmih> Eridius: You can compile the module and then open it in GHCi.
11:28:19 <mercury^> Lemmih: how's the large hadron collider coming along?
11:28:46 <ikkebr> lmao, i swear I read: large haskell compiler
11:30:13 <Lemmih> mercury^: I've killed the last protester. Development will procede on schedule.
11:30:55 <Lemmih> And the LHC Haskell Compiler is also coming along nicely.
11:34:30 <mercury^> Lemmih: <3
11:38:37 <wli> Lemmih: It does weird things to the repl-visible namespace vs. an un-interpreted module, but anyway.
11:39:31 <wli> s/interpreted/compiled/
11:48:28 <virus> I'm new to Haskell and playing a bit with GHCi. Now I've written some functions and want to add test cases for them. Is there a standard way of doing it? There seams to be no assert() and I totally have no clue how to write a procedure which raises an error on a failed testcase in sane way.
11:48:58 <TomMD> virus: QuickCheck
11:49:22 <Xen0x> Can someone help me with Monads. I've read some tutorials Online, but still can't figure out how I can solve my problem.
11:49:59 <Lemmih> Xen0x: What's the problem?
11:50:05 <Xen0x> Now I've got a Global Queue, with the unsafePerformIO hack, but I want to hide the queue in a Reader Monad
11:50:36 <vixey> Xen0x: want to solve it without unsafePerfomIO?
11:50:52 <Xen0x> vixey: yes :)
11:51:07 <vixey> well you have an IORef for the queue in the reader monad I guess?
11:51:48 <Xen0x> Well, I've put the TVar Queue in my Reader Monad
11:51:51 <vixey> so is the problem you are not sure how to use monad transformers? I mean so you can use reader & IO together for example?
11:52:19 <virus> how about the simple way: myfunction_test = if (myfunction_test 1) /= 42 then error "test1 failed" else if (myfunction_test 2) /= 32 then error "test2 failed" else ... Is there a more clever way of doing it. I don't want to use an contrib package.
11:52:52 <Xen0x> I've read how I can use the Monad transformer. I've got a test method that used runReaderT to put my state in the Monad
11:53:16 <Xen0x> but how do I make sure my state is available in a method add for example
11:57:31 <Xen0x> Nobody?
11:57:38 <vixey> I don't understand
11:57:57 <Xen0x> Ok. Let me try to explain once more
11:58:43 <Xen0x> I want to use the Reader Monad to encapsulate a TVar (a Queue)
11:59:42 <Xen0x> First of all, I thought this was done using the runReaderT method
11:59:47 <Xen0x> is that right?
11:59:59 <mauke> what is "this"?
12:00:13 <Lemmih> Xen0x: runReader would do.
12:00:22 <TomMD> virus: QuickCheck comes with most distributions of GHC, there is no good reason I know of to avoid it.
12:00:36 <Lemmih> Oh, you want IO.
12:01:19 <TomMD> I think he wants to stack readerT and IO.
12:01:23 <Lemmih> Xen0x: Didn't it work?
12:01:35 <Xen0x> lemmih: runReader?
12:01:40 <TomMD> @hoogle runReader
12:01:41 <lambdabot> Control.Monad.Reader runReader :: Reader r a -> r -> a
12:01:41 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
12:01:42 <Lemmih> Xen0x: runReaderT.
12:01:47 <TomMD> @hoogle runReaderT
12:01:47 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
12:03:29 <Xen0x> Yes I can use runReaderT
12:03:52 <Xen0x> now the second argument (the 'r'), is encapsulated in my monad?
12:05:41 <Xen0x> Is it right, that the r argument is now encapsulated in my monad?
12:06:07 <Lemmih> What do you mean?
12:08:03 <virus> TomMD: ok. I'll have a look. For now I'll just use my simple approach. Even though it's by far not that elegant, but works for the stuff I write atm.
12:08:14 <Xen0x> Maybe, I'm the worst person in explaining things. I want that my monad contains a 'hidden' refrence to a Queue. Now what i understood, is that runReaderT adds the queue to my monad. Only now I want that other methods can use this monad (and thus the queue). The question is. Hoe can this be done
12:08:36 <jmcarthur> Xen0x, those would be in the Reader monad too
12:08:37 <mauke> what do you mean by "other methods"?
12:08:38 <jmcarthur> that's it
12:09:29 <Lemmih> Xen0x: You're not making a new monad. You're using the 'ReaderT r IO' monad.
12:10:25 <jmcarthur> if you previously had something like foo = write 5 globalVar, then you would now have something like foo = write 5 =<< ask
12:10:36 <Xen0x> Lemmih; so you say when I use the ReaderT monad, and I have added something to that monad. I can just give another method the type ReaderT IO or something, and there I can access my 'r'?
12:10:57 <mauke> Xen0x: no, you have the other method return a ReaderT IO something
12:11:13 <Lemmih> Xen0x: 'r' is the type of your read-only state.
12:11:58 <Xen0x> I now have a method called; 'addG'. It has the type addG :: String -> STM (). This used the global hack, but how can I now make sure I can access the 'r' in this method??
12:13:10 <Lemmih> Xen0x: You need a function with the type 'String -> ReaderT YourState IO ()'.
12:13:31 <Xen0x> Lemmih; is that all?
12:13:49 <Lemmih> Xen0x: Yes. Keep in mind what the reader monad actually is.
12:14:20 <Lemmih> Xen0x: ReaderT r m a  =  r -> m a
12:14:25 <CosmicRay> Is there some version of zip that would do something like this: zip [1, 2, 3] [1, 2, 3] = [(1, 1), (1, 2), (1, 3), (2, 1), (2,2), ...] ?
12:14:57 <Xen0x> Lemmih; It is a wrapper around another monad, just hiding a value?
12:14:57 <Lemmih> Xen0x: Your function would have the type: 'String -> YourState -> IO ()'.
12:14:58 <edwardk> > (,) <$> [1,2,3] <*> [1,2,3]
12:14:59 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
12:15:09 <bd_> CosmicRay: [ (a, b) | a <- [1,2,3], b <- [1,2,3] ]
12:15:25 <Lemmih> Xen0x: Yes, it just hides the passing of the real-only state.
12:15:26 <CosmicRay> thanks folks.
12:15:30 <edwardk> aka liftM2 (,)
12:16:25 <CosmicRay> right, so I knew it was pretty easy, just wondering if it was built-in
12:16:34 <CosmicRay> I guess the answer is "almost" :-)
12:16:43 <bd_> define built-in :)
12:17:11 <bd_> list comprehension is pretty close. and liftM2 is basically analogous to zipWith here
12:17:15 <Xen0x> once I've put the Read only state in the monad, I can just edit a method's signature from b to ReaderT State b, and there I can access my variable?
12:17:42 <mauke> Xen0x: yes
12:17:57 <virus> it it possible to write an anonymous inner function that calls itself recursively like in scheme or python? e.g. I have a public API, that calls that internal helper function with some default arguments. I'm really new to Haskell and just trying to figure out some details of the language by reading example code and doing some trial and error work :)
12:18:12 <mauke> virus: sure
12:18:18 <mauke> wait, anonymous?
12:18:19 <bd_> virus: If you want it to be totally anonymous, you can use fix
12:18:27 <bd_> but it's usually easier to give it a locally-scoped name
12:18:29 <mauke> I don't think python can do that
12:18:57 <Phillemann> Hmmm, how would you open a list of files, get their content and concatenate the contents into one string? I tried: contents <- mapM filecontent filenames, where filecontent is defined as: bracket (openfile name ReadMode) (hClose) hGetContents
12:19:12 <virus> mauke: I mean a scoped function that's only visible within the containing function. :)
12:19:14 <mauke> Phillemann: that's just readFile
12:19:18 <kpreid> virus: you mean where you have a recursive function and the public interface omits some arguments used in the recursion?
12:19:21 <Xen0x> It is that easy :)! So the compiler figures out how the variable gets there. I mean, by just adding another signature to a method and a 'hidden' value appears, seems weird to me :)
12:19:23 <bd_> > let fib = \n -> if (n < 2) then 1 else (fib (n - 1)) + (fib (n - 2)) in map fib [1..5]
12:19:24 <lambdabot>   [1,2,3,5,8]
12:19:26 <virus> mauke: so it doesn't neccesarily have to be an anonymous function
12:19:26 <mauke> virus: that's trivial :-)
12:19:31 <kpreid> virus: the best way to write that is usually with 'where'
12:19:54 <Phillemann> mauke: Ok, so I can delete the filecontent function. Good
12:19:56 <jmcarthur> Xen0x, as you get used to monads you will start to understand what kinds of things it's actually abstracting
12:20:00 <bd_> @pl let fib = \n -> if (n < 2) then 1 else (fib (n - 1)) + (fib (n - 2)) in fib
12:20:00 <lambdabot> fix (ap (flip if' 1 . (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
12:20:09 <kpreid> doWhatever foo bar = recursor foo 0 where recursor x acc = ...
12:20:10 <bd_> ^^^ this is why we don't make functions completely anonymous
12:20:46 <Phillemann> mauke: Ah, and that fixed the problems I was having. Nice :)
12:20:59 <mauke> Phillemann: oh yeah, that hClose is wrong
12:21:02 <jmcarthur> Xen0x, the reader monad is actually quite simple. Reader r m a is really just that same thing as r -> m a. it just hides that detail from you and carries the extra parameter on your behalf
12:21:14 <mauke> Phillemann: hGetContents "closes" the file
12:21:23 <maltem> > flip map [1..5] $ fix $ \f n -> if (n < 2) then 1 else f (n - 1) + f (n - 2)
12:21:24 <lambdabot>   [1,2,3,5,8]
12:21:26 <jmcarthur> *ReaderT r m a, i mean
12:21:37 <Phillemann> mauke: So it closes the file but the function still returns IO String?
12:21:57 <mauke> what do you mean by "but"?
12:22:12 <Xen0x> I understand now jmcarthur :) I think, I was thinking to hard on how the r is hidden and carried around
12:22:25 <Phillemann> Well, I'd expect that the lazy string is "unlazied" when hClose was called.
12:22:28 <Xen0x> while I just have to accept that it is done for me:)
12:22:33 <jmcarthur> Xen0x, yeah, the whole point is that that is done for you :)
12:22:35 <Phillemann> Maybe I don't really get what's going on there.
12:22:59 <mauke> Phillemann: it isn't (and that's one of the reasons why lazy IO is evil)
12:23:16 <Phillemann> Indeed it is. Hm...
12:23:26 <jeffersonheard> is backslash valid in an operator name?
12:23:36 <jeffersonheard> as long as it's not the first character
12:23:47 <virus> mauke, could you give an example "foo = (bar) where bar = 42" doesn't seam to work.
12:24:02 <mauke> virus: how does it not work?
12:24:12 <mauke> :t (\\)
12:24:13 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:24:24 <Lemmih> jeffersonheard: It can even be the first character.
12:24:41 <skorpan> :t (\)
12:24:42 <lambdabot> parse error on input `)'
12:24:57 <maltem> > let (+\\+) = mappend in [1,2] +\\+ [3,4]
12:24:58 <jeffersonheard> :t (%\%)
12:24:59 <lambdabot>   [1,2,3,4]
12:24:59 <lambdabot> Not in scope: `%\%'
12:25:18 <maltem> > let (+\+) = mappend in [1,2] +\+ [3,4]
12:25:19 <lambdabot>   [1,2,3,4]
12:25:23 <maltem> fancy
12:25:44 <skorpan> that's a great alias for mappend, i must say
12:25:57 <maltem> hm, I'm not sure myself
12:26:09 <maltem> the \ looks like it's stroken through, as in /=
12:26:29 <virus> mauke: "<interactive>:1:4: parse error on input `='"
12:26:43 <mauke> virus: that has nothing to do with 'where' or local functions
12:26:58 <mauke> virus: you simply can't write 'foo = ...' in the ghci repl
12:27:11 <vixey> > let (++) = mappend in [1,2] +\+ [3,4]
12:27:12 <lambdabot>   Not in scope: `+\+'
12:27:14 <vixey> > let (++) = mappend in [1,2] ++ [3,4]
12:27:15 <lambdabot>   [1,2,3,4]
12:28:08 <Hunner> > let (+/+) = mappend in [1,2] +/+ [3,4]
12:28:10 <lambdabot>   [1,2,3,4]
12:28:33 <kpreid> virus: what mauke said: I recommend getting used to keeping a file open in an editor and using the :r[eload] command in ghci
12:29:01 <virus> kpreid: I did that before, but for that simple example I tried it direcly on the interpreter. aww
12:29:09 <kpreid> virus: you can't use a large chunk of haskell from ghci (anything which is a toplevel definition)
12:29:24 <kpreid> > let foo = bar where bar = 42 in foo
12:29:26 <lambdabot>   42
12:29:30 <kpreid> that would work in ghci
12:29:52 <kpreid> the key is that 'let' lets you write local "... = ..." definitions
12:29:59 * maltem wants to create a website containing only the words, huge: “GHCI evaluates Haskell expressions. It doesn't accept arbitrary code. Yes, this in an FAQ.” 
12:30:03 <kpreid> you can't use let to introduce type decls though
12:30:18 <maltem> (Do we *have* an FAQ list?)
12:31:01 <Hunner> maltem: http://haskell.org/haskellwiki/GHC:FAQ#Why_doesn.27t_.22x.3D1.22_work_at_the_ghci_prompt.3F
12:31:03 <vixey> it's just a frequently asked question
12:31:22 <maltem> Hunner, right, that'll do
12:31:38 * Hunner likes the new logo
12:31:41 <dolio> @fact-set ghci only evaluates expression, doesn't accept arbitrary code
12:31:42 <lambdabot> Fact recorded.
12:31:46 <dolio> @fact ghci
12:31:46 <lambdabot> ghci: only evaluates expression, doesn't accept arbitrary code
12:32:03 <dolio> Crap, I'm missing an 's'.
12:32:30 <dolio> @fact ghci
12:32:30 <lambdabot> ghci: only evaluates expressions, doesn't accept arbitrary code
12:34:20 <virus> mmh, ok. now ghci gives me a "parse error (possibly incorrect indentation)". The trivial example worked fine. http://codepad.org/Z7GbWThN
12:35:48 <virus> ah... { } can be used for scopes :)
12:36:00 <dolio> virus: I think out-denting further than helper makes it think that you're adding another definition.
12:36:16 <virus> err... it's not a 'scope' in the usual sense of the word
12:36:20 <dolio> So that desugars into "where { helper b i = ; if ... }"
12:36:39 <mauke> virus: yeah, you misindented the if
12:37:24 <virus> jepp. I just found that myself. Didn't know about the indentation {}. I'm slowly starting to get a grip on that :)
12:37:26 <kadaver> @type mappend
12:37:27 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:37:31 <dolio> Actually it probably desugars to "where { helper b i = } if ...", since outdenting past the definitions closes the block.
12:38:12 <kadaver> @src mappend
12:38:13 <lambdabot> Source not found. You speak an infinite deal of nothing
12:39:08 <kadaver> > mappend 2 1
12:39:09 <lambdabot>   Add a type signature
12:39:20 <kadaver> > mappend 2 1::Int
12:39:21 <lambdabot>       No instance for (Monoid Int)
12:39:22 <lambdabot>        arising from a use of `mappend' at ...
12:39:46 <ddvlad|> > mappend 2 [1]
12:39:48 <lambdabot>       No instance for (Num [t])
12:39:48 <lambdabot>        arising from the literal `2' at <inter...
12:39:49 <edwardk> kadaver: import Data.Monoid.Instances ;)
12:39:56 <mauke> does that exist?
12:40:09 <edwardk> mauke: its in 'monoids'
12:40:20 <kadaver> what doesn amppedn do?
12:40:49 <kadaver> ah
12:40:51 <skorpan> it does whatever your instance of Monoid says it should
12:41:00 <kadaver> edwardk: its in instances
12:41:07 <mauke> edwardk: still no Num instances for Sum/Product :-(
12:41:13 <edwardk> mauke: includes instances for Int, Integer, etc. if you want the multiplication ones for those they are Multiplicatives in Data.Monoid.Multiplicative, and you can use mappend for that if you use Log to lower multiplication to addition
12:41:31 <edwardk> mauke: thought about it, Sum at least
12:42:28 <edwardk> mauke: use Data.Ring.FromNum it'll give you a monoid from any Num based on the addition, and is a Num instance itself
12:42:44 <edwardk> mauke: not quite what you want but its a newtype wrapper that offers both
12:42:55 <kadaver> mappend seems to be + and soemtimes ++
12:43:07 <kadaver> but mappend was in ghci before i imported Data.Monoid
12:43:17 <edwardk> kadaver: mappend can do lots of things
12:43:17 <kadaver> nio it wasnt
12:43:36 <edwardk> @src Endo mappend
12:43:36 <lambdabot> Source not found. You type like i drive.
12:43:47 * edwardk can never remember how to use that
12:43:54 <Eridius> hrm, what's the right way to convert from a Double to a CDouble?
12:43:57 <vixey> @src mappend Endo
12:43:58 <lambdabot> Source not found.
12:44:08 <mauke> Eridius: realToFrac?
12:44:09 <edwardk> @src Data.Monoid.Endo mappend
12:44:09 <lambdabot> Source not found. There are some things that I just don't know.
12:44:11 <vixey> mappend = (.)
12:44:13 <vixey> I guess/
12:44:17 * edwardk shrugs
12:44:25 <Eridius> mauke: ahh, there we go. I was having trouble finding that function
12:44:28 <vixey> or maybe it's like  Endo f `mappend` Endo g = Endo (f . g)
12:44:34 <edwardk> vixey: basically. Endo a `mappend` Endo b = Endo (a . b)
12:44:38 <edwardk> yeah
12:44:42 <mauke> partymind
12:45:07 <alexsuraci> is there a way to tell if a character is utf8/unicode? e.g. for specifying allowable characters in an identifier with Parsec
12:45:25 <mauke> do you mean characters as in Char?
12:45:35 <alexsuraci> yeah
12:45:50 <mauke> yeah, Char is unicode
12:45:52 <alexsuraci> isUtf8 'é' -> True
12:45:59 <alexsuraci> Something akin to that
12:46:05 <edwardk> alexsuraci: if its legally encoded as utf8? or if its higher than ascii
12:46:12 <alexsuraci> Parsec provides alphaNum but that's not enough
12:46:14 <kadaver> > foldl mappend 0 [1..10]
12:46:15 <lambdabot>   Add a type signature
12:46:21 <mauke> alexsuraci: that's not utf-8
12:46:33 <edwardk> alexsuraci: utf-8 does't mean quite what you think it means
12:46:41 <alexsuraci> figured
12:46:59 <edwardk> i think you mean whether or not a character requires multibyte utf-8 encoding
12:47:00 <mauke> isUnicode :: Char -> Bool; isUnicode _ = True
12:47:01 <kadaver> > import Data.Monoid.Instances; foldl mappend 0 [1..10]
12:47:02 <lambdabot>   <no location info>: parse error on input `import'
12:47:07 <alexsuraci> I ended up going with "any character that isn't this long list of punctuation" but that's a bit sketchy
12:47:10 <edwardk> mauke: =)
12:47:20 <mauke> alexsuraci: punctuation is also unicode
12:47:26 <alexsuraci> maurer: I realize this
12:47:42 <mauke> > isAlpha 'é'
12:47:43 <lambdabot>   True
12:47:49 <edwardk> alexsuraci: if you want 'has a single byte utf8 encoding' you probably just want to check to see if fromEnum x < 0x80
12:48:18 <Saizan_> maybe he just wants alphanum extended to unicode chars?
12:48:21 <edwardk> @google utf-8
12:48:22 <lambdabot> http://en.wikipedia.org/wiki/UTF-8
12:48:22 <lambdabot> Title: UTF-8 - Wikipedia, the free encyclopedia
12:48:25 <Saizan_> like in Data.Char ?
12:48:31 <omnihil> I think what edwardk suggested is what alexsuraci is trying to do
12:48:31 <edwardk> there is that
12:48:42 <BONUS> > appEndo $ mconcat (map (Endo . (+))) [3,4,2,5,3]
12:48:43 <lambdabot>   Couldn't match expected type `[a]'
12:48:53 <BONUS> > appEndo $ mconcat (map (Endo (+))) [3,4,2,5,3]
12:48:54 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a
12:48:54 <lambdabot>      Proba...
12:48:56 <BONUS> i love this
12:48:56 <BONUS> gh
12:50:03 <vixey> :t Endo . (+)
12:50:04 <lambdabot> forall a. (Num a) => a -> Endo a
12:50:12 <vixey> :t Endo (+)
12:50:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
12:50:13 <lambdabot>     Probable cause: `+' is applied to too few arguments
12:50:13 <lambdabot>     In the first argument of `Endo', namely `(+)'
12:50:16 <Saizan_> > (appEndo . mconcat . map (Endo . (+)) $ [3,4,2,5,3]) 1
12:50:17 <lambdabot>   18
12:50:37 <alexsuraci> edwardk: Thanks, I'll check that solution out
12:50:37 <BONUS> yeah i messed up the parens
12:50:42 <vixey> :t appEndo
12:50:44 <lambdabot> forall a. Endo a -> a -> a
12:51:00 <vixey> :t Endo . (.)`on`appEndo
12:51:01 <lambdabot>     Couldn't match expected type `(c1 -> c1) -> c'
12:51:01 <lambdabot>            against inferred type `Endo (a -> c1)'
12:51:01 <lambdabot>     Probable cause: `.' is applied to too many arguments
12:51:05 <alexsuraci> BONUS: semi-random, but props for Learn You A Haskell, it's the guide I link people to now :P
12:51:06 <vixey> :t Endo . ((.)`on`appEndo)
12:51:07 <lambdabot>     Couldn't match expected type `Endo a'
12:51:07 <lambdabot>            against inferred type `a -> a'
12:51:07 <lambdabot>     Probable cause: `on' is applied to too few arguments
12:51:15 <vixey> :t (Endo .) . ((.)`on`appEndo)
12:51:16 <lambdabot> forall a. Endo a -> Endo a -> Endo a
12:51:16 <alexsuraci> love the design of it
12:51:32 <BONUS> alexsuraci: thank you! :) be on the look out for more chapters soon and lyah in irl book form
12:51:48 <edwardk> irl book? woot
12:51:51 <BONUS> i love the fact that foldr f z xs = foldr (.) id (map f xs) z
12:52:07 <BONUS> yeah maybe, got an offer from a publisher and am in talks now :)
12:52:31 <edwardk> very cool =)
12:52:34 <alexsuraci> BONUS: cool, good luck
12:52:49 <edwardk> its good when they come to you =)
12:52:56 <BONUS> haha yeah
12:54:39 <jmcarthur> BONUS, nice!
12:55:59 <BONUS> yeah, i was kind of surprised cause i never aimed too much for an irl book
12:56:18 <Nafai> BONUS: I didn't realize you were the author of lyah.  Great stuff!
12:56:22 <Botje> BONUS: i'll give you EUR 5 for a poster of that caterpillar you use to explain head/tail/init/last :)
12:56:30 <BONUS> Nafai: thanks :D
12:56:41 <BONUS> haha Botje
12:57:08 <BONUS> maybe i should tell the publisher to print posters of the list monsters and add them as a present with the book
12:57:13 <BONUS> that's seriously a good idea
12:57:14 * edwardk needs to write a book on how to drive people away from Haskell with scary category theory diagrams.
12:57:23 <BONUS> haha
12:57:42 <BONUS> words that end with -morphism  ftw
12:57:49 <mauke> @quote rst.*cat
12:57:50 <lambdabot> Anonymous says: I'd love to explain to you how to write hello world in Haskell, but first let me introduce you to basic category theory.
12:57:52 <edwardk> one look at a generalized hylomorphism and they'll never look back
12:58:01 <BONUS> haha
12:58:30 <edwardk> mauke: thats basically how my tutorials go =)
12:58:37 <Botje> @quote
12:58:38 <lambdabot> <autrijus> says: using Haskell is like having the power of Reason. <autrijus> all bad guys listen to Reason.
12:58:38 <mauke> excellent
12:58:58 <edwardk> though i also try to mix in formal logic, modus ponens as function application, curry howard, ...
12:59:09 <edwardk> then i show someone how to add 2 + 2 ;)
12:59:13 <skorpan> @quote skorpan
12:59:13 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
12:59:19 <BONUS> hahaha
12:59:33 <BONUS> but seriously i really enjoy reading the comonad.reader
12:59:33 <edwardk> i figure i'm doing better than principia mathematica, it takes them 300 pages. i get to it by the end of a 4 hour lecture
12:59:40 <skorpan> comonad.reader?
12:59:47 <edwardk> my blog
12:59:53 <skorpan> splitter!
12:59:53 <edwardk> http://comonad.com/
12:59:54 <mauke> "Quantum bogosort is bounded by the available matter in the universe, and as such on the set which it is able to operate is O(1)."
13:00:11 <BONUS> haha
13:00:32 <BONUS> i remember reading about an O(1) sort algorithm somewhere, the only pre-requirement is that the input data is sorted already
13:00:44 <edwardk> mauke: bah, you should be able to exceed that bound if you are accelerating at a constant rate or are in the neighborhood of a blackhole
13:01:02 <dolio> Do they need all 300 pages, though, or are there lots of irrelevant digressions on the path to 2 + 2? :)
13:01:04 <mauke> edwardk: http://dis.4chan.org/read/prog/1240258746/  write a reply
13:01:30 <skorpan> @faq can haskell O(1) sort an unsorted list?
13:01:30 <lambdabot> The answer is: Yes! Haskell can do that.
13:02:03 <burp_> wow
13:02:06 <edwardk> > let whatever = sort [1..] in "Ooh.. shiny"
13:02:07 <lambdabot>   "Ooh.. shiny"
13:02:11 <inhahe> i made an o(n) sort algorithm, although it's probably slower than a regular sort
13:02:23 <mauke> I made a O(1) malloc
13:02:23 <burp_> @faq can haskell O(0) sort an unsorted list?
13:02:24 <lambdabot> The answer is: Yes! Haskell can do that.
13:02:30 <vixey> inhahe: I thought that was impossible
13:02:36 <dolio> > let !whatever = sort [1..] in "Look, it's ML!"
13:03:02 <lambdabot>   thread killed
13:03:12 <BONUS> the lowest bound for sorting is theta(n log n)
13:03:21 <BONUS> is it theta? the O with the line
13:03:21 <mauke> > let !whatever = 1 : sort [2..] in "optimized"
13:03:21 <inhahe> vixey: i don't know much about big-o notation, but what i do is take the binary representation of the element and then navigate a binary tree using it and place it in the appropriate leaf.  so it only does this once per element and the time it takes to do that is proportional to the number of bits in the element
13:03:25 <lambdabot>   "optimized"
13:03:31 <dolio> Heh.
13:03:34 <edwardk> thread killer! what did that thread ever do to you? it just sat there, enjoying itself, spinning, doing no one any harm at all
13:03:41 <mauke> BONUS: only for comparison based sorting
13:03:43 <BONUS> haha
13:03:48 <BONUS> mauke: that's true yeah
13:03:48 <skorpan> edwardk: don't worry, it was just a zombie
13:04:06 <dolio> O with the line is theta.
13:04:09 <skorpan> not that threads can actually be zombies...
13:04:22 <dolio> I can never remember which letter means which, though.
13:04:26 <mauke> Θ
13:04:42 <BONUS> theta is like the exact function i think
13:04:52 <Botje> yes
13:04:55 <BONUS> big O is that for a function, the function will eventualy grow larger
13:05:06 <edwardk> 'exactly' =)
13:05:10 <BONUS> and uh i forget what the opposite is cause it's kind of useless
13:05:12 <kadaver> when a type is 344.2929s
13:05:18 <kadaver> the is thst instance show as a string then?
13:05:25 <edwardk> big omega
13:05:25 <mauke> kadaver: what
13:05:27 <kadaver> it isnt really an s there?
13:05:44 <BONUS> ah
13:05:54 <Botje> kadaver: you're breaking up; try standing closer to the cell phone tower
13:06:24 <edwardk> they both find use in mathematics, i did a classical analysis class where the first thing the prof did was introduce big O, big Theta, etc. and then used them for calculus for the first couple of days
13:06:56 <Phillemann> ghc loads the package "bytestring" twice (different version though) and complains about it. How can I diagnose that?
13:07:13 <mauke> Terrible!
13:07:16 <edwardk> computer scientists always care about as n -> infinity, but you can use the same terminology for other limits.
13:07:45 <BONUS> what's it called when you give a function that grows always more slowly than the actual time for the problem based on the input set
13:07:48 <Phillemann> Can I output the path where ghc finds the packages?
13:07:52 <Botje> Phillemann: you could try unregistering the oldest bytestring and checking which packages complain
13:07:56 <Botje> Phillemann: check ghc-pkg list
13:08:07 <BONUS> when you give a function that is greater than or equal to its big O and when it grows as fast its theta, right
13:08:27 <Botje> BONUS: omega?
13:08:39 <edwardk> BONUS: there is 'equal which is omega, and there is little o when the inequality is strict
13:08:47 <BONUS> ah, that's right
13:08:51 <Phillemann> Ah, okay, one is in /usr/lib64/ghc-6.8.2/package.conf and one in my home directory. Can I block the global one (or can I generally favor local packages over global ones)?
13:08:53 <Eridius> whoa, Data.Encoding.encodeStrictByteString sticks a BOM on the result if you're using UTF16
13:09:25 <wh1t3> any1 use xemacs as an editor? if so, what does it mean when it says "symbol's value as variable is void: temporary-file-directory" when i try and switch to ghc?
13:09:30 <Zao> Eridius: There's Data.Text and Data.Text.Encoding if you don't like that.
13:09:44 <Botje> Phillemann: you can play around with ghc-pkg unregister
13:09:45 <Eridius> Zao: well apparently using UTF16LE skips the BOM
13:09:51 <Botje> and hen installing stuff with cabal you can add the --user flag
13:09:59 <Botje> but that's all i know, sorry :]
13:12:09 <kadaver> what is the type of List?
13:12:17 <kadaver> ie mempty :: Int -> 0. mempty :: [] doesnt work
13:12:30 <vixey> > mempty :: [Int]
13:12:31 <lambdabot>   []
13:12:37 <Phillemann> Botje: unregister and hide do not seem to be global solutions, hmmm.
13:14:15 <kadaver> is IORef built on top of ghc? or it is a hack?
13:14:16 <monadic_kid> who wants to see a hilarious error message?
13:14:26 <kadaver> > mappend (1::Double) (4::Double)
13:14:27 <lambdabot>       No instance for (Monoid Double)
13:14:27 <lambdabot>        arising from a use of `mappend' ...
13:14:29 <edwardk> Phillemann: my answer is to just write my code as a cabal package and include just the stuff i want in the build-depends section
13:14:36 <edwardk> cabal then hides everything else automatically
13:14:37 <kadaver> > mempty ::Int
13:14:38 <lambdabot>       No instance for (Monoid Int)
13:14:39 <lambdabot>        arising from a use of `mempty' at <...
13:14:47 <BONUS> kadaver: Int isnt a monoid
13:14:51 <kadaver> > mempty :: [Int]
13:14:53 <lambdabot>   []
13:14:56 <BONUS> a list is a monoid
13:15:02 <kadaver> BONUS: why does mappend 1 3
13:15:06 <BONUS> what's inside the list doesn't have to be
13:15:13 <edwardk> kadaver: Data.Ring.FromNum gives you a monoid for any FromNum
13:15:15 <BONUS> what?
13:15:17 <kadaver> work byd efault then when importing Data.Monoid.Instances?
13:15:29 <BONUS> oh hmm
13:15:31 <BONUS> let me see
13:15:33 <edwardk> er for any Num (via a newtype wrapper)
13:15:49 <BONUS> oh hmm Data.Monoid.Instances isnt in the standard libs, right?
13:15:50 <edwardk> kadaver: data.monoid.Instances only includes Int, Integer, and Ratio's
13:15:59 <edwardk> bonus: nah its one of mine
13:16:12 <leimy_> anyone know of a 9p implementation in Haskell?
13:16:15 <BONUS> ah. which monoid is chosen for Int? product or addition?
13:16:19 <BONUS> or some other
13:16:28 <edwardk> i didn't bother with all the others because I needed Int, Integer and Ratio for the appropriate free module definitions
13:16:54 <edwardk> bonus: addition, there is a Data.Monoid.Multiplicative that defines a similar looking class that is brought in for multiplication (with one and times)
13:17:09 <edwardk> bonus: i then use Multiplicative and Monoid together to build up Rings, etc.
13:17:17 <BONUS> ah, cool!
13:17:20 <monadic_kid> so funny, look at this error message i got from the fsharp comiler: http://pastebin.com/m561fdb1e
13:17:20 <BONUS> i'll czech tha tout
13:17:30 <kadaver> these Monoids are the new mystery, im kind of getting monads
13:17:42 <BONUS> monadic_kid: haha
13:17:44 <BONUS> awesome
13:17:59 <kadaver> what is the point of a monoid? what is ut supposed to abstract out?
13:18:23 <Philippa`> kadaver: it's a 'sequence' of sorts
13:18:30 <edwardk> the multiplicative stuff works well because the default monoid for a monad is generally the same as its monadplus instance, but i can transform its (>>) into a monoid as well
13:18:39 <leimy_> kadaver: it's a set that's closed under a binary operation:-)
13:18:50 <dolio> monadic_kid: You shouldn't be using 150-ples.
13:18:53 <leimy_> so implies certain rules and operations that are allowed on it.
13:18:54 <Philippa`> (in fact, the 'most obvious' monoid is lists/++/[])
13:18:58 <edwardk> though, i use a slight improvement on that since every monadplus wrapped around a monoid is a valid right-seminearring
13:19:16 <Philippa`> leimy: associative binary operation with an identity
13:19:31 <edwardk> leimy: and with an associativity law
13:19:38 <edwardk> leimy: and an identity
13:19:41 <monadic_kid> dollo: i'm not using any in the expresison it's referring to!
13:19:49 <dolio> :)
13:19:55 <leimy_> Oh and it must also contain at least one element
13:19:56 <BONUS> you have mempty :: m and mappend :: m -> m -> m
13:20:03 <BONUS> > [1,2,3] `mappend` [1,2]
13:20:05 <lambdabot>   [1,2,3,1,2]
13:20:09 <edwardk> leimy: "any old binary operation" is called a magma =)
13:20:09 <BONUS> > [1,2,3] `mappend` mempty
13:20:10 <BONUS> etc
13:20:11 <lambdabot>   [1,2,3]
13:20:13 <monadic_kid> i read mepty is numpty
13:20:21 <monadic_kid> *mempty
13:20:23 <vixey> magma is a useless notion in Haskell though
13:20:27 <leimy_> yeah
13:20:32 <vixey> we have types rather than sets so something being 'closed' isn't special anymore
13:20:48 <leimy_> Actually is closure always required?
13:20:48 <edwardk> vixey: well, if you want it just as a starting point for the numerical tower.
13:20:49 <leimy_> hmmmm
13:20:49 <BONUS> > All True `mappend` All False
13:20:50 <lambdabot>   All {getAll = False}
13:21:06 <BONUS> anyway, does anyone think mappend is kind of mis-named
13:21:13 <bavardage> is there an equivalent to 'all' for a list of conditions?
13:21:23 <bavardage> instead of list of things to be tested
13:21:23 <mauke> bavardage: and?
13:21:25 <edwardk> leimy: well, if you strip the 'closed' requirement off of a monoid you get a 'category'
13:21:29 <bavardage> I have one thing to be tested with a list of conditions
13:21:44 <bavardage> mauke: so map it?
13:21:48 <bavardage> and then use and?
13:21:56 <mauke> oh, like that
13:22:06 <tromp> :t all
13:22:08 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
13:22:14 <mauke> all ($ thing) [cond1, cond2]
13:22:38 <bavardage> oh kk :D
13:22:54 <monadic_kid> so whats sitution with reactive library, is almost complete yet? I mean the one thing about functional reactive that puts me off is that the area is still being developed
13:22:56 <bavardage> merci :D
13:23:26 <BONUS> @pl (\x xs -> and $ sequence xs x)
13:23:26 <lambdabot> (and .) . flip sequence
13:23:30 <BONUS> there's also this
13:23:44 <edwardk> > [const True, (==4)] `sequence` 4
13:23:45 <lambdabot>   [True,True]
13:23:49 <edwardk> hrmm
13:24:06 <Xen0x> Mmmm.... ok, I think I still don't understand the Reader Monad :(
13:24:08 <edwardk> > all ([const True, (==4)] `sequence` 4)
13:24:09 <lambdabot>   Couldn't match expected type `a -> Bool'
13:24:13 <BONUS> > ((and .) . flip sequence) 3 [(>2), (>1), (<300)]
13:24:15 <lambdabot>   True
13:24:37 <edwardk> > and $ [const True, (==4)] `sequence` 4
13:24:39 <lambdabot>   True
13:24:51 <monadic_kid> > False
13:24:52 <lambdabot>   False
13:24:56 <monadic_kid> good boy
13:25:01 <monadic_kid> @botsnack
13:25:02 <lambdabot> :)
13:25:02 <lunabot>  :)
13:25:41 <monadic_kid> so who's lunabot, lambdabot's gf?
13:25:51 <Xen0x> Still people around, who can help me with the Reader Monad?
13:26:02 <malouin> the lua version of lambdabot?
13:26:18 <edwardk> nah, 635 people on here, and not one of us understands the reader monad.
13:26:33 <Xen0x> nice sarcasm ;)
13:26:36 <DanielC> Hi. Can someone show me how to write a 'diff' function in Haskell? I tried to Google for it. A function that takes a function of one variable and returns its derivative.
13:26:37 <jeffersonheard> :t (flip (.))
13:26:38 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
13:26:45 <edwardk> 633 now, see how quickly you can drive them away?
13:26:52 <jeffersonheard> @hoogle  forall b c a. (a -> b) -> (b -> c) -> a -> c
13:26:52 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
13:26:53 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
13:26:53 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
13:27:13 <kadaver> why is int not a monoid? it fulfills the axioms. mconcat im not sure what makes the msot sensethough
13:27:15 <jeffersonheard> of course...  duh.  is there a standard reverse function composition operator?
13:27:18 <Lemmih> Xen0x: We'd love to help.
13:27:21 <jeffersonheard> the flip of (.) ?
13:27:29 <BONUS> >>>
13:27:32 <BONUS> :t (>>>)
13:27:33 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:27:35 <edwardk> kadaver: the reason has to do with the fact that there are many monoids that apply to Int
13:27:36 <Xen0x> Ok. I now have a function. test = runReaderT testT "test" and testT :: ReaderT String IO
13:27:49 <Berengal> kadaver: Sum and Product are monoid wrappers around Integer
13:27:55 <Xen0x> test = di v <- ask; liftIO $ putStrLn (show v)
13:28:00 <edwardk> kadaver: i.e. i have a Data.Ring.Boolean -- which provides a monoid for 'xor'
13:28:08 <Lemmih> Xen0x: So far, so good.
13:28:16 <Xen0x> en a function q
13:28:25 <Xen0x> q :: String -> ReaderT String IO ()
13:28:25 <edwardk> there is the Sum which is the 'obvious' monoid for many reasons, but there is also the monoid (*,1)
13:28:29 <jeffersonheard> BONUS: Thanks, and reverse application?
13:28:38 <jeffersonheard> flip $, in other words...
13:28:43 <jeffersonheard> sorry to ask you to do my work for me
13:28:49 <jeffersonheard> just trying to clean up code
13:29:03 <idnar> @pl flip (.)
13:29:03 <lambdabot> flip (.)
13:29:05 <idnar> hmm
13:29:06 <Xen0x> q s = do v <- ask; liftIO putStrLn ( show v)
13:29:13 <BONUS> haha, i dont know if there's reverse application in there
13:29:24 <idnar> @pl \f g -> g . f
13:29:25 <lambdabot> flip (.)
13:29:27 <jeffersonheard> BONUS: yeah, I realized that after I looked at the type sig
13:29:30 <idnar> guess it doesn't know that one
13:29:33 <BONUS> it would be cool if there was so that you could do
13:29:34 <edwardk> then you have the monoids (min,maxBound) (max,minBound), etc
13:29:35 <vixey> what would you use flip (.) for??
13:29:36 <Xen0x> so the test, adds "test" as a String in the Reader Monad, right ?
13:29:38 <Berengal> @pl \a b -> b a
13:29:38 <lambdabot> flip id
13:29:50 <idnar> vixey: composing functions in reverse order, obviously!
13:29:52 <edwardk> kadaver: so in general they decided not to pick a default monoid for Int, etc.
13:30:02 <BONUS> 3 >*> (+3) >>> (*2) >>> (*100)
13:30:06 <jeffersonheard> vixey, combined with flip ($), reversing a golfed function for slightly better readability
13:30:12 <jeffersonheard> in the cases where it's more readable
13:30:16 <jeffersonheard> to do it that way
13:30:17 <edwardk> the instances in Data.Monoid.Instances are based on the idea that i want a numerical tower that starts at Monoid and builds up
13:30:35 <BONUS> but yeah uh why are you using flipped composition though?
13:30:37 <Lemmih> Xen0x: I wouldn't use that terminology, but yes.
13:30:39 <edwardk> mainly because i needed seminearrings, which can't implement Num and I didn't want to 'lie'
13:30:50 <kadaver> does closure has any relation to programming-lang-closure
13:30:53 <jeffersonheard> say when you have a string of combinators operating on an initial value, it'd be nice to see the value you're operating on at the beginning instead of all the way at the end
13:31:23 <edwardk> kadaver is seeking closure on the issue of closure. how metacircular.
13:31:26 <jeffersonheard> x . y . z . a . b . c $ somevalue
13:31:32 <Xen0x> Ok, and when I now run the method q with a string as an argument. I get an instance error
13:31:47 <Xen0x> do I invoke the method wrong, or is the printing done wrong
13:32:10 <edwardk> @type flip ($)
13:32:11 <lambdabot> forall a b. a -> (a -> b) -> b
13:32:19 <edwardk> jeffersonheard: there ;)
13:32:20 <Berengal> @type flip id
13:32:21 <lambdabot> forall b c. b -> (b -> c) -> c
13:32:28 <Lemmih> Xen0x: You must use 'runReaderT' to run 'q'.
13:32:48 <jeffersonheard> vs somevalue $< c `o` b `o` a `o` z `o` y `o` x
13:32:53 <Lemmih> Xen0x: Just like you used 'runReaderT' to run 'testT'.
13:32:54 <jeffersonheard> HaXml does it
13:33:01 <jeffersonheard> using the `o` operator
13:33:31 <bavardage> what is the statement for 'if' without an else
13:33:33 <jeffersonheard> anyway, was mostly just wondering
13:33:41 <Berengal> I think (|>) works best as a flip ($) operator...
13:33:45 <jeffersonheard> bavardage: Control.Monad.when
13:33:45 <Xen0x> like .. runReaderT q "string"
13:33:45 <edwardk> jeffersonheard: meh, . vs ; vs |> vs whatever
13:33:46 <Berengal> Allusions to pipe etc.
13:33:54 <bavardage> jeffersonheard: ty
13:33:54 <Lemmih> test = runReaderT (testT >> q "arg") "reader state"
13:34:29 <edwardk> i'm used to seeing it as ; in papers on category theory
13:34:53 <edwardk> but i haven;t been able to convince anyone that would be a good symbol to give up in programming circles ;)
13:34:57 <Berengal> I think I actually defined (|>) to work in the IO monad once, and do unsafeInterleaveIO on the first argument...
13:35:06 <jeffersonheard> edwardk, heh
13:35:08 <vixey> > (do (+1);(*2);id) 3
13:35:10 <lambdabot>   3
13:35:10 <Berengal> So it'd be close to the shell pipe...
13:35:16 <jeffersonheard> algol used it as such
13:35:33 <edwardk> Berengal: cute
13:35:42 <BONUS> hmm just noticed something
13:35:44 <jmcarthur> :t (>==>)
13:35:45 <lambdabot> Not in scope: `>==>'
13:35:46 <Berengal> edwardk: Cute, perhaps, but not really useful
13:35:51 <Xen0x> lemmih: So the 'scope' of the hidden variable in the monad in limited to the methods called in runReaderT ?
13:35:54 <BONUS> if you keep doing :t flip, then :t flip flip, then :t flip flip flip
13:36:00 <BONUS> the type converges at three flips
13:36:04 <Lemmih> Xen0x: Yes, exactly.
13:36:10 <BONUS> is there any significance to this
13:36:11 <edwardk> Xen0x: yep!
13:36:22 <Berengal> @type flip flip flip
13:36:23 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
13:36:35 <edwardk> @type fmap `fmap` fmap
13:36:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
13:36:36 <Lemmih> Xen0x: That's the point of the Reader monad. (:
13:36:39 <BONUS> @type flip flip flip flip flip flip flip flip flip
13:36:40 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
13:36:45 <jmcarthur> :t (>=>)
13:36:46 <Xen0x> Ahhh... ok :) So there went something wrong in my way of thinking I assume.
13:36:46 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
13:36:48 <tromp> BONUS: three is the count, and thy shallt count to three...
13:37:10 <Berengal> "Three" is all you need
13:37:32 <BONUS> i wonder if this is interesting at all
13:37:40 <BONUS> my money is on: not
13:37:53 <jmcarthur> Berengal, (|>) = (>=>) ?
13:37:57 <vixey> lol
13:37:59 <jmcarthur> at least your IO version?
13:38:29 <Berengal> jmcarthur: Almost. My IO version did unsafeInterleaveIO
13:38:30 <edwardk> @type flip `fmap` flip `fmap` flip
13:38:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:39:10 <edwardk> @type flip `fmap` flip
13:39:11 <Xen0x> Lemmih; so wen I Create a method add :: String -> ReaderT Queue IO (). I can only use this method in the scope of a runReaderT
13:39:11 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
13:39:12 <Berengal> jmcarthur: getArgs |> catFiles |> grep "foo" |> print
13:39:13 <dolio> @type fix ($flip)
13:39:15 <lambdabot>     Occurs check: cannot construct the infinite type:
13:39:15 <lambdabot>       b = ((a -> b1 -> c) -> b1 -> a -> c) -> b
13:39:15 <lambdabot>     Probable cause: `$' is applied to too many arguments
13:39:35 <Lemmih> Xen0x: Yes, that's the point of the reader monad.
13:40:25 <kadaver> why do mathematicians do things like monoids and monads? i mean im an applida mathematician if im amathematician at all. i liek solving math problems because they are fun but my motivation come from the practical use. i use math to solve. i dont go to math and find a problem. i mean combinatorics, graph theory, geometry, linear algebra, statistics, fun math. but abstract algebra and stuff, I dont really get how it is useful? it has some 
13:40:33 <edwardk> BONUS: thats when the 'flips' have forced as many arguments as they'll need to have something to flip
13:40:45 <BONUS> aah
13:40:52 <Berengal> kadaver: Monads are useful...
13:40:57 <Berengal> kadaver: So are monoids
13:41:10 <BONUS> that is awesome in a way, just another showcase of how haskell's type system is awesome
13:41:15 <jmcarthur> kadaver, abstract algebra is useful because it's general
13:41:27 <edwardk> kadaver: i like monoids because associativity gives you the ability to decompose a problem into chunks by reparenthesizing and to not have to worry about the base case, because you have a unit
13:41:27 <kadaver>  but abstract algebra and stuff, I dont really get how it is useful? it has some applications in programming languages? that's good obv but there are func langs without category theory right? is the idea to build up more and more derivable stuff? so you cand erivea whole bunch of operations by sepcifying a few onws?
13:41:31 <kadaver> in case it got cut off
13:41:44 <Xen0x> Lemmih; OK :). But now I still have a problem (I Think). I have various methods, that want to use the add method, because they want to add something to the global Queue. How can i do that using the monad?
13:41:48 <jmcarthur> kadaver, you get stuff like "given an operation that is associative, i know i can do this and this and this with it"
13:41:55 <dolio> Why do mathematicians bother with groups and stuff? It's not like you'll ever use that in, say, physics.
13:42:07 <jmcarthur> kadaver, without that abstraction would you be stuck redefining the same properties for different things
13:42:08 <BONUS> well it's realy general, so if you can say things about nature in general, you can apply those things to specific things as well
13:42:11 <BONUS> such as computation
13:42:33 <burp_> you don't use groups in physics? ow
13:42:37 <burp_> thats very wrong :>
13:42:39 <BONUS> as we've seen, monoids and monads and the like and a whole lot of generalizations from CT are useful in haskell
13:42:39 <edwardk> kadaver: think of it as stealing machinery that someone else already developed for you. programming is a young science. when you can tie yourself to 50+ year of mathematics you get a whole host of new tools
13:42:59 <jmcarthur> you do use groups in physics. it may not be a useful abstraction to bring to light, though
13:43:02 <quicksilver> old tools
13:43:02 <kadaver> dolio: thats not the same, im wondering if groups have any use outide of abstract mathematics and if abstract mathematics have any use.
13:43:13 <burp_> they're of use in quantum mechanics
13:43:19 <BONUS> also, i like abstract algebra and stuff because you can tell or discover something new about the nature of the world around us
13:43:24 <Lemmih> Xen0x: Well, either use the Reader monad or use a global mutable variable.
13:43:27 <edwardk> kadaver: i.e. category theory has been around longer than LISP.
13:43:30 <burp_> http://en.wikipedia.org/wiki/Lie_group
13:43:31 <burp_> check this
13:43:44 <BONUS> that's why i really like haskell, cause it is sort of tied to that, the theory of types and the overlap with CT
13:43:53 <kadaver> hats what i meant, you can make the compiler derive things for you automatically to a higher extent?
13:43:58 <dolio> Is physics considered "abstract mathematics"?
13:44:01 <BONUS> you're just hacking away and suddenly you make a realization about the world around you
13:44:03 <tromp> some physicists conjecture that the standard model of particles will evolve to the biggest Lie group
13:44:06 <edwardk> kadaver: try writing a hashing function some time, you start thinking about groups, even if you don't know that you are
13:44:16 * AirCastle wonders if mathematics is just abstract physcis
13:44:18 <Berengal> kadaver: Who really cares if it's useful anyway? Lots of math was invented because some clever guy with his head in the sky had some idea, and then he had a great mind-trip
13:44:26 <Berengal> Sometimes it turns out to be useful 150 years later...
13:44:29 <kadaver> and/or, you can use operations in a certain why with certainty without thinking whether it is really correct or not
13:44:35 <Lemmih> Xen0x: If you call 'runReaderT' from 'main' and then hoist everything into the Reader monad then you should be fine.
13:44:58 <Phillemann> Ok, so I could reset my GHC_PACKAGE_PATH to just my local package.conf, but then ghc doesn't find "System.IO".
13:45:29 <Berengal> It does seem like if we declare a monad instance we should get all the functors and arrows for free...
13:45:38 <edwardk> kadaver: i use mathematical terminology rather than my own when given the choice because it lets me discover non-trivial relationships between what i'm doing and what has been done before
13:45:43 <Xen0x> Lemmih; can you give a coding example ?
13:46:09 <Berengal> Also, math is fun...
13:46:29 <BONUS> yeah i agree with Berengal
13:46:31 <edwardk> kadaver: having basically thrown away a decade of my life reinventing the wheel here so many different ways i'm sick of doing so ;)
13:46:39 <BONUS> it's fun. that's why i like haskell, it's fun
13:46:50 <kadaver> BONUS: example?
13:46:56 <Lemmih> Xen0x: main = runReaderT mainTwo ""; mainTwo = {- put your code here -}
13:46:58 <BONUS> of it being fun?
13:47:20 <burp_> the journey is the reward
13:47:26 <BONUS> > filterM (const [True, False]) [1,2,3,4]
13:47:28 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
13:47:29 <BONUS> woot
13:47:41 <Xen0x> Lemmih; mmm so simple :S
13:47:52 <Berengal> kadaver: When I first got functors, and groked the connection between map and (.), I was staring at the wall grinning stupidly for almost an hour. That's how much fun it was
13:47:54 <BONUS> > foldr (.) id (map (*) [1..5]) 1
13:47:56 <lambdabot>   120
13:47:56 <kadaver> edwardk: i wrote a hashfucntion
13:48:06 <BONUS> i sometimes giggle when i write haskell :)
13:48:39 <dolio> You guys are obviously nuts.
13:48:55 <dolio> BONUS at least. :)
13:49:01 <BONUS> hahaha
13:49:17 <Xen0x> Lemmih; Thanx (again). This really helps my project :)
13:50:20 <Berengal> > take 10 $ loeb $ const 0:[(+1).(!!(chain i - 1)) | i <- [2..]] where chain n = if even n then div n 2 else n*3+1
13:50:21 <lambdabot>   Not in scope: `loeb'
13:50:48 <Berengal> > take 10 $ loeb $ const 0:[(+1).(!!(chain i - 1)) | i <- [2..]] where {chain n = if even n then div n 2 else n*3+1; loeb x = fmap (\a -> a (loeb x)) x}
13:50:50 <lambdabot>   [0,1,7,2,5,8,16,3,19,6]
13:51:08 <BONUS> this conversation kind of reminds me of this funny quote
13:51:08 <BONUS> this conversation kind of reminds me of this funny quote  BONUS: > foldr (.) id (map (*) [1..5]) 1
13:51:12 <BONUS> whoops
13:51:19 <BONUS> i meant this http://www.youtube.com/watch?v=Dxff0k_TEzI#t=2m18s
13:51:26 <aheller> my googling is failing me: how do I alias a module name so I can do: import Control.Monad as M; import M.Error; import M.State; etc?
13:51:47 <Berengal> aheller: import qualified Foo as F
13:53:05 <leimy_> http://1.bp.blogspot.com/_UdzqQpb36Jo/Rzij_RFpOBI/AAAAAAAABHk/DsIrrCe5bCk/s400/y_combinator.jpg
13:53:12 <leimy_> That's a brave tattoo
13:53:50 <aheller> Berengal: Thanks; but it seems not to work.  import qualified Control.Monad as Mon; import Mon.Error gets "Could not find module Mon.Error"
13:54:15 <Berengal> aheller: Ah, well... I don't think you can do that...
13:54:17 <edwardk> aheller: i don't think you can use the qualified form for import statements
13:54:24 <edwardk> just for other things in the module
13:54:42 <edwardk> oh, and heya alec
13:54:48 <aheller> Hey Ed
13:54:53 <c_wraith> leimy_: Eh.  mine's not quite so on-topic for this channel, but still pretty close.  It's been touched up since this, so the line work and fills are all solid, but this gets the point across:  http://i23.photobucket.com/albums/b366/Joschaf/80e47a84.jpg
13:54:55 <edwardk> aheller: haskell /= ml ;)
13:54:57 <te> hey everyone -- im not sure how to fix the torrent of errors im getting shwn i startup xmonad
13:55:02 <te> it cant find any of my modules
13:55:11 <te> s/shwn/when
13:55:23 <aheller> It's much worse for Text.ParserCombinators.Parsec.ThisWon'tFitOnOneLine
13:55:49 <edwardk> aheller switching to parsec3 cuts that down a little
13:56:03 <edwardk> Text.Parsec.StillTooVerbose is at least a little better ;)
13:56:26 <dolio> Haskell = ~~ML
13:56:29 <aheller> Granted.
13:56:32 <dolio> Isn't that a Wadler paper?
13:56:40 <edwardk> dolio: =) greta paper
13:56:40 <edwardk> nah
13:56:43 <edwardk> ben rudiak gould
13:56:46 <dolio> Ah, okay.
13:57:21 <dolio> One just assumes that all good paper names are Wadler.
13:57:31 <dolio> Or maybe Conor McBride.
13:57:37 <edwardk> i went and obsessed about doing the same transformation that one used to any pure type system right before icfp 06
13:58:14 <zoheb> How do I get the indices of a STArray s (Int,Int) Int ?
13:58:23 <zoheb> I tried indices
13:58:25 <dolio> @type bounds
13:58:26 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
13:58:34 <edwardk> unfortunately the mixture of notations i picked up from that, pure type systems, and from playing with substructural logic limited my audience to more or less cc shan and oleg ;)
13:58:57 <BONUS> haha
13:59:11 <dolio> @type getBounds
13:59:13 <lambdabot> Not in scope: `getBounds'
13:59:17 <edwardk> i cornered simon PJ about the ~~ml paper at the time and he more or less shrugged and said it was entirely ben's stuff, he didn't really remember any details
13:59:22 <dolio> Well, that's it anyway.
13:59:37 <leimy_> c_wraith: I was more concerned with the correct balance of parenthesis :-)
13:59:54 <dolio> I haven't actually read it. It's something I downloaded long ago and never got to.
14:00:01 <c_wraith> leimy_: Hey, that matters for mine, too!  Though...  Not quite as hard to get right. :)
14:00:13 <edwardk> dolio: i really enjoyed it, and its only a few pages, well worth the read
14:00:26 <leimy_> c_wraith: yep!
14:00:41 <leimy_> http://qconlondon.com/london-2009/speaker/Tony+Hoare  <-- Apologizes for inventing null references :-)
14:01:07 <edwardk> dolio: an interesting exercise as you read it is to read it with wadler's down with the beaurocracy of syntax paper and apply the transformation to that
14:01:35 <zoheb> I am unable to use indices / bounds
14:01:39 <edwardk> dolio: you get a nice model of linear continuations, which you can then generalize to get a nice model for substructural/ordered/etc.. continuation
14:01:43 <zoheb> it gives me a type failure?
14:01:53 <dolio> zoheb: getBounds is for mutable arrays.
14:01:58 <edwardk> which basically drops out as your stack model
14:02:05 <zoheb> ok
14:02:08 <zoheb> thanks
14:02:10 <aheller> edwardk: what were you presenting in '06?
14:02:25 <edwardk> aheller: i just showed up to see if i wanted to be a type theory guy ;)
14:02:33 <aheller> Ah.
14:02:48 <edwardk> aheller: so i flew out to interview at galois and to find a decent ph.d.
14:02:50 <orbitz> leimy_: hahahaha
14:03:25 <edwardk> aheller: i got the offer to come out here right after i came back
14:03:37 <aheller> job offers are good.
14:05:29 <arssami> Check it out Here: http://www.000webhost.com/155136.html
14:05:41 <vixey> arssami: check what out there?
14:06:17 <arssami> just check out u will understant
14:06:29 <vixey> arssami: not going to look at it until you tell me what it is
14:06:56 <arssami> hahaha, u r funny
14:07:12 <skorpan> that's a reflink to a website which provides free web hosting
14:07:34 <arssami> thanks skorpan
14:07:42 <skorpan> don't thank me
14:07:58 <arssami> why?
14:08:04 * Botje clicks the "contact / report abuse" link
14:08:11 <skorpan> that's why
14:08:13 <vixey> ooh good idea , me too
14:08:21 --- mode: ChanServ set +o Saizan
14:08:29 --- mode: Saizan set +b *!*=arssami0@119.30.36.*
14:08:29 --- kick: arssami was kicked by Saizan (Saizan)
14:08:31 <vixey> then again, I always wonder if the abuse link actually /rewards/ them
14:08:41 <skorpan> vixey: i won't risk the spam
14:08:45 --- mode: Saizan set -o Saizan
14:08:46 <Botje> i have gotten at least two spammer's accounts closed so far :)
14:10:05 <Berengal> > let spam s = "spam " ++ s in fix spam
14:10:06 <lambdabot>   "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam...
14:10:26 <Botje> there we go
14:10:27 <mauke> @src cycle
14:10:27 <lambdabot> cycle [] = undefined
14:10:28 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
14:10:29 <jmcarthur> > fix ("spam " ++)
14:10:30 <lambdabot>   "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam...
14:10:33 * Botje goes to sit by his mailbox
14:10:58 * Berengal failed to fix the spam problem :(
14:11:21 <jmcarthur> > cycle "spam "
14:11:23 <lambdabot>   "spam spam spam spam spam spam spam spam spam spam spam spam spam spam spam...
14:12:03 <Gracenotes> lol upmodded hard
14:12:50 <Eridius> hrm, how do you declare foreign functions that take structs as arguments?
14:13:13 <kadaver> can someone give an example of a neat function that wouldt be enat without using id?
14:13:33 <sjanssen> Eridius: you can't
14:13:38 <Eridius> sjanssen: why not?
14:13:44 <Botje> kadaver: something involving foldr, i'd guess :)
14:13:49 <sjanssen> Eridius: the FFI spec just doesn't allow for it
14:13:52 <Eridius> :/
14:14:01 <Eridius> that's.. really lame
14:14:06 <sjanssen> Eridius: you have to write C wrappers that pass them by reference
14:14:14 <kadaver> where is fix?
14:14:20 <sjanssen> @hoogle fix
14:14:20 <lambdabot> Data.Function fix :: (a -> a) -> a
14:14:21 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:14:21 <lambdabot> module Control.Monad.Fix
14:14:24 <jmcarthur> > maybe mempty id Nothing :: [Int]
14:14:25 <lambdabot>   []
14:14:26 <Berengal> kadaver: Id is all over the place, but it's usually inlined by the programmer without him knowing about it
14:14:30 <jmcarthur> > maybe mempty id (Just 5) :: [Int]
14:14:31 <lambdabot>       No instance for (Num [Int])
14:14:31 <lambdabot>        arising from the literal `5' at <int...
14:14:43 <jmcarthur> > maybe mempty id (Just [5,6,7]) :: [Int]
14:14:44 <lambdabot>   [5,6,7]
14:15:17 <sjanssen> > fromMaybe mempty (Just [5, 6, 7])
14:15:18 <lambdabot>   [5,6,7]
14:15:27 <jmcarthur> @src fromMaybe
14:15:28 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
14:16:47 <kadaver> can a function take any mappendable?
14:17:11 <sjanssen> kadaver: you mean Monoid?
14:17:25 <RayNbow> hmm, does the Haskell 98 report mention anything about sharing?
14:17:26 <Botje> Mappendable sounds like a good alias for Monoid ;)
14:17:37 <Cale> f :: (Monoid m) => m -> ...
14:17:42 <sjanssen> Botje: bah, not this argument again
14:17:48 <sjanssen> RayNbow: I don't think so
14:17:55 <Botje> but i wasn't there in person! :)
14:18:25 <zoheb> I think I am missing something
14:18:35 <zoheb> Can someone explain why http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array-MArray.html#v%3Abounds
14:18:37 <jmcarthur> Botje, monoid is more than appendable things!
14:18:52 <Botje> they're also memptyish?
14:18:55 <zoheb> shows that bounds is available for Mutable Arrays
14:19:06 <jmcarthur> > getSum $ Sum 5 `mappend` Sum 7
14:19:07 <lambdabot>   12
14:19:20 <zoheb> but ghc doesnt accept mutable array as a pram for bounds
14:19:29 <zoheb> param
14:19:31 <roconnor> > length (replicate 5 () ++ replicate 7 ())
14:19:32 <lambdabot>   12
14:19:44 <jmcarthur> roconnor, tricky
14:20:01 <roconnor> the free monoid is the root of all monoids
14:20:04 <zoheb>     Couldn't match expected type `Array b e' against inferred type `STArray s (Int, Int) Int'
14:20:07 <jmcarthur> > getProduct $ Product 5 `mappend` Product 7
14:20:08 <lambdabot>   35
14:20:22 <zoheb> In the first argument of `bounds', namely `arr'
14:20:46 <roconnor> > log $ length (replicate (exp 5) () ++ replicate (exp 7) ())
14:20:47 <lambdabot>       No instance for (Floating Int)
14:20:47 <lambdabot>        arising from a use of `log' at <i...
14:20:55 <roconnor> oooh
14:21:00 <roconnor> > log $ genericLength (replicate (exp 5) () ++ replicate (exp 7) ())
14:21:01 <lambdabot>       No instance for (Floating Int)
14:21:01 <lambdabot>        arising from a use of `exp' at <i...
14:21:02 <sjanssen> zoheb: the docs at that link are way out of date
14:21:05 <sjanssen> @docs
14:21:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
14:21:10 <sjanssen> zoheb: use the above instead
14:21:12 <roconnor> oh ya, that won't work
14:21:15 <zoheb> I just googled
14:21:25 <zoheb> thanks for that
14:21:28 <roconnor> jmcarthur: lemme think about this one
14:21:31 <RayNbow> sjanssen: well, I asked Google... the word "share" is not mentioned often in the H98 report :p
14:21:44 <jmcarthur> > log . fromIntegral $ genericLength (replicate (exp 5) () ++ replicate (exp 7) ())
14:21:45 <lambdabot>       No instance for (Floating Int)
14:21:45 <lambdabot>        arising from a use of `exp' at <i...
14:21:50 <jmcarthur> oh, the exp
14:22:01 <kadaver> Tronoid
14:22:03 <kadaver> Tripnoid
14:22:11 <RayNbow> Arkanoid
14:22:14 <zoheb> sjanssen: Thanks
14:22:30 <roconnor> well
14:22:33 <roconnor> there is always
14:22:36 <jmcarthur> > log $ genericLength (replicate (fromIntegral $ exp 5) () ++ replicate (fromIntegral $ exp 7) ())
14:22:37 <lambdabot>   Add a type signature
14:22:45 <jmcarthur> oh duh
14:22:51 <roconnor> > product ([5]++[7])
14:22:52 <lambdabot>   35
14:23:06 <roconnor> :P
14:23:20 <Berengal> > 5*7
14:23:20 <jmcarthur> roconnor, completely cheating :P
14:23:21 <lambdabot>   35
14:23:37 <roconnor> jmcarthur: ya.  I'm not sure if it is completely cheating or totally the right way.
14:24:28 <Berengal> Is there really an empty type?
14:24:44 <Berengal> It can't really be empty, since bottom is a member...
14:24:54 <roconnor> > (getProduct . mconcat . map Product) ([5]++[7])
14:24:55 <lambdabot>   35
14:25:00 <pumpkin> lol
14:25:09 <vixey> yeah everything in haskell in inhabited
14:25:23 <Berengal> In haskell, yes, but what about other systems?
14:25:25 <jmcarthur> roconnor, grasping at straws ;)
14:25:27 <roconnor> There is a haskell extension that will give you the empty type
14:25:45 <sjanssen> roconnor: _|_ is still a member of that too
14:25:45 <pumpkin> sounds useful ;)
14:25:46 <jmcarthur> roconnor, really?!
14:25:47 <Berengal> Can you really say it's empty though?
14:25:53 <roconnor> sjanssen: yes
14:26:05 <jmcarthur> oh, still has _|_
14:26:10 <jmcarthur> EmptyDataDecls doesn't count then :P
14:26:12 <Berengal> Everything has _|_
14:26:17 <roconnor> Berengal: It is the empty type ... not necessarily empty.   Perhaps void type is a better name.
14:26:34 <Berengal> "The type with only _|_ in it"
14:26:34 <mauke> what's the kind of unboxed types?
14:26:46 <sjanssen> mauke: #
14:26:56 <Berengal> Wouldn't that type allow us to identify _|_ though?
14:26:58 <mauke> data Empty :: #  -- ?
14:27:06 <sjanssen> hmm
14:27:08 <jmcarthur> Berengal, "identify"?
14:27:17 <Berengal> I mean, if we have a value of the empty type, it has to be _|_
14:27:54 <jmcarthur> Berengal, semantically, does knowing whether it's _|_ or not make a difference?
14:28:02 <roconnor> There are many _|_, each with a different type.
14:28:04 <jmcarthur> the answer is _|_ whether we know or not
14:28:21 <Berengal> Well, it's nothing you wouldn't discover at compile time
14:28:46 <Berengal> But compile time is just a different sort of runtime
14:28:48 <mauke> if all you want is a type with only _|_ in it, you don't need any extensions
14:29:01 <Berengal> Edittime is the compile time with the programmer as the compiler
14:29:03 <jmcarthur> a -> b
14:29:14 <sjanssen> mauke: it seems GHC doesn't allow kind signatures on empty data decls
14:29:19 <mauke> sjanssen: aww
14:29:52 <sjanssen> newtype OnlyBot = OnlyBot OnlyBot
14:30:12 <mauke> singularity!
14:30:18 <vixey> type OnlyBot = forall a b. a -> b
14:30:28 <mauke> forall a. a
14:30:35 <sjanssen> those aren't Haskell '98
14:30:45 <Berengal> All values are members of forall a. a though, aren't they?
14:31:09 <sjanssen> all values are members of exists a. a
14:31:13 <skorpan> http://pastebin.com/d622f618 <- any help appreciated!
14:31:45 <roconnor> sjanssen: arguably members of exists a. a are dependent pairs.
14:31:46 <vixey> skorpan: myConstantA actually type checks?
14:31:49 <Berengal> I should probably go stare at the wall for half an hour before I clutter up the channel with too much random noise...
14:32:02 <skorpan> vixey: never tested it, but shouldn't it?
14:32:07 <vixey> you should test it
14:32:46 <skorpan> oh, my bad...
14:32:51 <skorpan> that was silly
14:33:35 <skorpan> http://pastebin.com/m7747b320
14:33:38 <skorpan> that ought to do it
14:33:55 <vixey> you tested that one?
14:33:57 <skorpan> yes
14:34:51 <dbueno> In ghc, when I profile my program with +RTS -hc -RTS, the .ps file hp2ps produces has legend entries that are partially elided, like "get_adyN/get_atea...".  How can I get the full list?
14:35:26 <zoheb> I am trying to create a list like this [(0,0) .. (3,3)] but it looks like pair (x,y) does not belong to Enum
14:35:34 <skorpan> @instances Enum
14:35:35 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:35:42 <Berengal> zoheb: range
14:35:44 <Berengal> @type range
14:35:45 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
14:36:04 <Saizan> dbueno: you can pass a flag to hp2ps to allow more chars
14:36:14 <zoheb> @ range [(0,0) ..(3,3)]
14:36:19 <dbueno> Saizan: the flag to let SCC's be longer?
14:36:25 <leimy_> > [(x,y) | x<-[0..3], y<-[0..3]]
14:36:27 <Berengal> > range (0,0) (3,3)
14:36:27 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
14:36:28 <lambdabot>   Couldn't match expected type `(t1, t2) -> t'
14:36:46 <zoheb> wow thx
14:37:05 <dbueno> Saizan: never mind, I was thinking ef the -Ln RTS option
14:37:23 <skorpan> vixey: i don't mean to be pushy, but did that question make any sense to you?
14:37:32 <vixey> not realy
14:37:38 <leimy_> >t mplus
14:37:39 <tromp> :t range
14:37:40 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
14:37:45 <Saizan> dbueno: uhm, maybe i'm wrong, i remember that there was a flag somewhere but nothing more
14:37:50 <leimy_> :t mplus
14:37:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
14:37:54 <tromp> > range 1 2
14:37:55 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
14:38:04 <leimy_> :t mconcat
14:38:06 <lambdabot> forall a. (Monoid a) => [a] -> a
14:38:17 <tromp> > range (1,2)
14:38:19 <lambdabot>   [1,2]
14:38:20 <leimy_> :t flip id
14:38:22 <lambdabot> forall b c. b -> (b -> c) -> c
14:38:24 <dbueno> Saizan: thanks, I'm trying out +RTS -L200 now, to see what it will do.  A flag to hp2ps wouldn't suffice, because inside the .hp file the names are also elided.
14:38:47 <tromp> > range ((0,0),(2,2))
14:38:49 <lambdabot>   [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2),(2,0),(2,1),(2,2)]
14:39:01 <leimy_> > (flip id) 3 (+) 1
14:39:02 <lambdabot>   4
14:39:04 <leimy_> woot!
14:39:17 <monadic_kid> i swear some people are just retards on reddit
14:39:26 <leimy_> id $ 3 (+) 1
14:39:36 <leimy_> > id $ 3 (+) 1
14:39:37 <zoheb> Any particular reason why range isnt automatically applied to declarations like [(a,b) .. (b,c)]
14:39:38 <lambdabot>       No instance for (Num ((a1 -> a1 -> a1) -> t -> a))
14:39:38 <lambdabot>        arising from ...
14:39:41 <mauke> s/on reddit/... in bed!/
14:40:07 <kerlo> > [(1,2)..(5,6)]
14:40:09 <lambdabot>       No instance for (Enum (t, t1))
14:40:09 <lambdabot>        arising from the arithmetic seque...
14:40:16 <monadic_kid> i got dowvoted for saying "One thing to note about Ct is that it is based on the ideas of nested data parallelism." o_0
14:40:16 <RayNbow> hmm, is it possible to delete a page from the Haskell wiki?
14:40:35 <kerlo> @type range
14:40:36 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
14:40:48 <mauke> > range ((1,0),(0,1))
14:40:49 <lambdabot>   []
14:41:03 <Berengal> It seems like it should easily be possible to declare an Enum instance for (a,b)...
14:41:05 <tromp> @instances Ix
14:41:05 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
14:41:37 <dbueno> Saizan: thanks! it worked.
14:41:40 <kerlo> zoheb: you can't define [ .. ] without defining fromInt and toInt.
14:41:43 <kerlo> I think.
14:42:26 <Saizan> dbueno: nice :)
14:42:36 <dbueno> Another question about profiling: it seems like type class methods get mangled but have type info in their mangled names.  Is there a recipe for figuring out e.g. what method "get_aeTr" maps to?
14:42:57 <zoheb> I was saying most people would expect .. to behave like range
14:43:44 <Gracenotes> kerlo: the type class allows you to override the definitions for '..'
14:43:49 <pejo> dbueno, isn't "_aeTr" some prefix, and the method is "get"?
14:43:53 <Gracenotes> what .. translates to, rather
14:43:59 <pejo> dbueno, err, I mean suffix.
14:44:20 <dbueno> pejo: I think so (suffix), and I know that the method is get -- but that's part of a typeclass.  Which instance is it part of?  That's what I'm looking to find out.
14:45:00 <dbueno> pejo: That is, in my profiling legend it points the finger at "get_aeTr" -- but I don't know which instance of Binary that refers to.
14:45:54 <Eridius> why is GHC_OPTIONS an unrecognized pragma?
14:46:04 <mauke> OPTIONS_GHC
14:46:44 <Eridius> whaaat? then why do I keep seeing references to GHC_OPTIONS?
14:47:00 <mauke> what, where
14:47:46 <Eridius> I don't remember where I originally saw that, but it got stuck in my head as the right way to do things, and a quick google on that phrase has results
14:48:31 <Eridius> damn, ghci can't dynamically use the -framework flag, I have to pass it at launch time
14:49:53 <osfameron> behold!  sections in Perl: http://github.com/osfameron/misc-opensource/blob/master/scratch/perl/sub-section/t/01_basic.t
14:50:54 <Peaker> I think Perl's "interesting" innovations are mostly syntactic (and thus superficial) -- and I think syntax is where you ought to be rigid, not flexible
14:51:34 <mauke> Perl got regex syntax right
14:51:41 <Eridius> ah, I finally finished my FFI code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4069#a4069
14:51:43 <mauke> that's important to me
14:51:44 <ingy> :)
14:52:03 <Eridius> it's a one-way bridge to generate OS X property lists from Haskell objects (and it doesn't even support Date, since I don't need that)
14:52:20 <mauke> osfameron: how did you do that?
14:53:02 <osfameron> mauke: Devel::Declare
14:53:27 <mauke> ןıʌǝawesome
14:53:41 <osfameron> mauke: the module is in the same repo.  mk_op parses the section (+2) or whatever, then D::D does crazy stuff to the source as you parse it
15:02:24 <kadaver> edwardk: why do you call it foldMapReduce? fold==reduce right
15:03:22 <Eridius> hrm, does runghc not support the -framework flag at all?
15:03:29 <monadic_kid> Reduce is  fold where the accum-state is usually the same type as elements you're folding
15:04:54 <monadic_kid> :t reduce
15:04:56 <lambdabot> Expr -> Expr
15:05:00 <monadic_kid> lol
15:05:15 <mauke> > reduce x
15:05:17 <lambdabot>   x
15:06:05 <monadic_kid> didn't know template haskell, well i'm assuming that is where the type Expr is coming from
15:06:19 <ddarius> That's not where it comes from.
15:06:24 <monadic_kid> *didn't know lambdabot supported
15:06:46 <monadic_kid> where is it coming from?
15:06:52 <ddarius> SimpleReflect
15:07:20 <ddarius> monadic_kid: You can't execute TH in lambdabot (but you can in lunabot), but you can use the TH libraries just fine.  They're just normal code.
15:07:42 <monadic_kid> yeah thats what i thought
15:07:43 <Peaker> mauke: regexps are one of the rare parts of my code that tend to evade work-on-the-first-try.  I really would prefer type-safe combinators to regexps
15:10:40 <British0zzy> Hi, I cannot seem to get unix-2.3.2.0 to install properly using cabal
15:14:01 <nominolo> @seen dons
15:14:01 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 2h 3m 17s ago.
15:19:40 <kadaver> can you add new syntax with template haskell?
15:20:05 <pumpkin> sort of
15:20:07 <pumpkin> not really though
15:20:39 <DerekN> Hi, I'm learning haskell and I wrote a pretty ugly function to split a String near a space (http://pastebin.com/d6f3f6573).  I was wondering if anyone could give me some ideas how how it could be written better? Thanks
15:21:48 <pumpkin> > words "hello I am a function who are you"
15:21:49 <lambdabot>   ["hello","I","am","a","function","who","are","you"]
15:22:05 <monadic_kid> hmm interesting, Ct is coming out around when Larrabee is released
15:23:33 <edwardk> pumpkin: thats a bit different than his function
15:23:52 <pumpkin> oh, I didn't even read it :P
15:23:57 * pumpkin is half alseep :)
15:24:14 <byorgey> hey edwardk
15:24:29 <edwardk> heya byorgey
15:24:35 <byorgey> I just sent you an email =)
15:24:42 * edwardk goes to check
15:25:06 <byorgey> edwardk: basically, it boils down to: any reason the constructor of Comp isn't exported from Control.Functor.Composition ?
15:25:15 <monadic_kid> you guys know that Ct is based on nested-data parallal model/
15:25:26 <edwardk> byorgey: the answer would be 'no reason whatsoever except that i forgot to export it' =)
15:25:37 <byorgey> edwardk: ok =)
15:25:40 <byorgey> edwardk: I'll send you a patch
15:25:44 <edwardk> i have a lot of cleanup i need to go back and do to that lib
15:26:55 <byorgey> edwardk: is there a public repo somewhere?
15:27:10 <Cale> > let ws = words "here are some words" in zip (drop 1 . scanl (+) 0 . map length $ ws) ws
15:27:11 <lambdabot>   [(4,"here"),(7,"are"),(11,"some"),(16,"words")]
15:27:18 <edwardk> byorgey: http://comonad.com/haskell/category-extras
15:27:19 <Botje> DerekN: i'd write the if isJust index as a case
15:27:24 <Botje> then you don't have to do fromJust
15:27:27 <byorgey> edwardk: thanks
15:27:56 <DerekN> Thanks Botje
15:28:02 <Cale> I suppose zipping doesn't really help, it's the indices that matter
15:28:04 <zoheb> you can use splitAt
15:28:15 <Cale> Right, once you find the index of the space that you're interested in.
15:28:27 <hydo> q: why isn't the last expression in this case statement catching everything else?  http://tinyurl.com/cc39fg
15:28:28 <Cale> however...
15:28:43 <Cale> I suppose you'd have to be a bit cautious with multiple spaces in that case.
15:28:50 <Cale> (in the case of using words)
15:29:18 <paul424> what is the best ide for haskell under windows currently ? I mean I want to have some interactive mode like in tuareg in ocaml ..........
15:29:28 <Botje> hydo: how is Value defined?
15:29:34 <DerekN> Cale: Yea, I had tried an implementation with words but had problems with multiple spaces or tabs in a row
15:29:42 <hydo> Botje: ah, oops.  One sec.
15:29:55 <Cale> DerekN: right.
15:30:29 <hydo> Botje: http://tinyurl.com/d793ob
15:30:42 <Cale> paul424: I don't know about under windows, but on linux, I just keep two terminal windows open side-by-side, one with my editor (usually vim), and the other with ghci
15:30:51 <Botje> hydo: well, that should catch everything.
15:30:54 <Cale> paul424: :r or simply : on the ghci prompt will reload
15:31:07 <paul424> ok
15:31:09 <wh1t3> xemacs is pretty nice on linux
15:31:15 <wh1t3> with haskell-mode that is
15:31:20 <hydo> Botje: That's what I thought.  Maybe it's a formatting issue or something.  Thanks for the confirmatioN!
15:31:22 <vixey> xemacs is horrid :/
15:31:51 <wh1t3> i like it
15:32:15 <hydo> emacs + haskell-mode = dance all nite.  imho
15:32:18 <jmcarthur> i like emacs-cvs. good font rendering, finally!
15:33:32 <mstr> what's new with font rendering compared to 22?
15:34:41 <zoheb> lookup ' ' $ drop 5 $ zip "Wallah ...fr" [1..]
15:34:45 <zoheb> >lookup ' ' $ drop 5 $ zip "Wallah ...fr" [1..]
15:34:52 <jmcarthur> xft, antialiasing, prettiness
15:35:38 <jmcarthur> > lookup ' ' $ drop 5 $ zip "Wallah ...fr" [1..]
15:35:39 <lambdabot>   Just 7
15:39:06 <kadaver> so do you use Data.Sequence a lot? what is it underneath? i wrote a split for normal strings. it needs to: reverse $ map reverse acc; in the end but Sequence can append to end with O(1) so I should use that instead. any clever way t do it with lists?
15:39:13 <zoheb> DerekN
15:39:16 <zoheb> Try this
15:39:18 <kadaver> (sorry if i psoted many tiems but i was kicked )
15:39:21 <zoheb> > (\n xs -> splitAt (fromJust $ lookup ' ' $ drop 5 $ zip xs [1..]) xs) 5 "alj gfg fgfdrt"
15:39:22 <lambdabot>   ("alj gfg ","fgfdrt")
15:39:44 <DerekN> zoheb: thanks, that looks alot nicer
15:39:55 <zoheb> Can someone improve the error catching in fromJust
15:40:15 <zoheb> using monads
15:40:19 <zoheb> maybe monad
15:40:24 <zoheb> i am not good with it
15:40:48 <zoheb> replace 5 by n in my code
15:40:57 <pumpkin> zoheb: yeah, fromJust isn't so good
15:41:08 <pumpkin> fromMaybe or use mplus maybe?
15:41:13 <kadaver> fromMaybe?
15:41:13 <kadaver> dont get what you mean
15:41:21 <pumpkin> :t fromMaybe
15:41:22 <lambdabot> forall a. a -> Maybe a -> a
15:41:48 <pumpkin> > fromMaybe 7 $ Just 4
15:41:49 <lambdabot>   4
15:41:52 <pumpkin> > fromMaybe 7 $ Nothing
15:41:53 <lambdabot>   7
15:42:17 <wpearson> Is there any terminology for stitching together partial functions with the same type signature to create a new one?
15:43:16 <pumpkin> partial functions?
15:43:40 <zoheb> fromMaybe looks good
15:43:55 <pumpkin> there's also maybe
15:44:02 <pumpkin> :t maybe
15:44:03 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:44:30 <zoheb> > (\n xs -> splitAt (fromMaybe 0 $ lookup ' ' $ drop n $ zip xs [1..]) xs) 5 "alj gfg fgfdrt"
15:44:32 <lambdabot>   ("alj gfg ","fgfdrt")
15:44:39 <zoheb> > (\n xs -> splitAt (fromMaybe 0 $ lookup ' ' $ drop n $ zip xs [1..]) xs) 5 "aljgfgfgfdrt"
15:44:40 <lambdabot>   ("","aljgfgfgfdrt")
15:45:18 <DerekN> zoheb: thanks again
15:45:19 <dancor> wpearson: in what way?  what's a meaningful combo of f :: a -> b -> c -> d and g :: a -> b -> c -> d
15:45:39 <flazz> i'm playing with opengl, is there a better way to have haskell infer types, i have a ton of "Vector3 0 0 (0::GLfloat)" all over the place
15:46:36 <Botje> dancor: h a b c = let res1 = f a b c in if res1 == undefined then g a b c else res1
15:46:39 <Botje> obviously >:)
15:46:58 <dancor> flazz: would synonymous functions with more specific types help
15:47:24 <flazz> what do you mean by synonymous functions?
15:47:31 <dancor> myVector3 :: (Num n) => n -> n -> GLfloat
15:47:38 <flazz> right
15:47:39 <dancor> -> something
15:47:42 <flazz> hmm
15:47:44 <dancor> myVector3 = Vector3
15:48:01 <flazz> or possibly the functions consuming them
15:48:01 <dancor> also something my0 = O :: GLfloat might help too
15:48:11 <pumpkin> what's that about not being able to read a string lazily from a socket?
15:48:21 <byorgey> edwardk: are you still around?
15:48:36 <dancor> > undefined == undefined
15:48:38 <lambdabot>   * Exception: Prelude.undefined
15:48:42 <dancor> Botje: lol
15:48:54 <dancor> there is a way to do that tho, with seq?
15:49:37 <dancor> or at least with amb..
15:49:50 <wpearson_> pumpkin: Did I reply before I lagged out?
15:49:53 <dolio> Woo! 50% time reduction on radix sort.
15:49:58 <pumpkin> wpearson_: not that I saw
15:50:01 <pumpkin> dolio: nice!
15:50:08 <pumpkin> uvector-algorithsm?
15:50:12 <dolio> Yes.
15:50:22 <pumpkin> wow, my typing sucks
15:50:23 <dolio> Finally figured out how to eliminate all the dictionaries it was shuffling around.
15:50:46 <wpearson_> pumpkin: Partial functions aren't defined over all their domain. head is an example of one in haskell.
15:50:53 <pumpkin> oh I see
15:50:59 <pumpkin> as opposed to total
15:50:59 <dancor> oh it was for undefined
15:51:06 <pumpkin> I misunderstood what you meant :)
15:51:16 <dancor> wpearson: you can definitely do it with Data.Unamb.amb
15:51:24 <dancor> but that puts you into IO iirc..
15:52:30 <dancor> if the partial functions are the same where they are both defined then you can use Data.Unamb.unamb
15:53:38 <dancor> idk specific "terminology" for that.. ask conal to invent some since he wrote them ;)
15:53:45 <wpearson_> dancor: I'd prefer to bias one way or the other I think
15:53:52 <Ferdirand> how does quasiquoting relate to TH ? (sorry, newbish question) Tried to read on both subjects, it only managed to liquefy my brain :(
15:54:37 <dancor> wpearson_: is going into IO acceptible?
15:55:05 <dancor> i think if they can differ and you don't want IO, then you have to give up referential transparency
15:55:29 <wpearson_> dancor: Probably not, my plan for using it was all fairly hazy and theoretical to be honest.
15:56:24 <dancor> i don't think you can "catch _|_" outside of IO without cheating
15:58:10 <wpearson_> I wanted to be able to stitch things like Data.Maps (which are partial functions in one way of looking at them) together with proper partial functions and total functions to get sort of editable functions.
15:58:41 <wpearson_> No particular purpose, but it seemed interesting.
15:58:45 <dancor> a Map is like a partial function ya
15:58:56 <dancor> and you can definitely "catch _|_" for a Map
15:59:31 <dancor> so you can definitely apply Map-lookup "overlays" to a real function
16:00:02 <wpearson_> Yep, that is what I wanted.
16:00:28 <dancor> but to overlay a real function on to something else, you would need IO/unamb-with-contract-programming/unsafePerformIO
16:02:56 <wpearson_> Thanks dancor.
16:03:18 * wpearson_ goes to read some of conal's blog on the subject
16:06:36 <Peaker> hmm.. fuse has fuseOpenDirectory :: FilePath -> IO Errno, fuseReadDirectory :: FilePath -> IO (Either Errno [(FilePath, FileStat)]),  fuseReleaseDirectory :: FilePath -> IO Errno,    -- so what's open/release good for?  refcounting or such?
16:06:52 <dancor> Ferdirand: i don't know anything but it almost seems from "5. Implementation" in http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/mainland07quasiquoting.pdf
16:07:14 <dancor> that quasiquoting is just TH + a-patch-to-calling-some-function
16:07:41 <dancor> and that there was only more work to do to get quasiquoting in GHC bc GHC doesn't fully support TH
16:08:09 <dancor> and you can def use just SYB to write quasiquoters instead of invoking full TH
16:08:45 <Ferdirand> pdf :( but thanks, time to melt more brain cells :)
16:09:10 <dancor> http://haskell.org/haskellwiki/Quasiquotation describes using SYB to write quasiquoters..
16:09:49 <Ferdirand> TH is way over my head, but quasiquotation seems more abordable
16:10:42 <dancor> i'm really not sure how it all fits together.  perhaps TH can basically almost do what SYB and QQ do, but TH is horrible.  so SYB and QQ exist (and are probably written mostly in TH) to do more specific things and be more bearable to use?
16:12:09 <Ferdirand> haven't looked at SYB yet
16:12:12 <Peaker> cool, I got fuse going :)
16:12:23 <Peaker> much easier than I thought it would be
16:12:54 <dancor> Peaker: the user-space filesystem?
16:13:03 <Peaker> yeah, with the hfuse bindings
16:13:29 <pejo> dancor, my understanding of SYB isn't that it's written in TH.
16:14:06 <dancor> ok
16:14:29 <dancor> QQ seems to be based on TH anyway, in that http://haskell.org/haskellwiki/Quasiquotation does
16:14:32 <dancor> import qualified Language.Haskell.TH as TH
16:14:35 <dancor> import Language.Haskell.TH.Quote
16:14:56 <dancor> maybe QQ was just added to the TH heirarchy when it was added
16:15:14 <Peaker> where's the stdlib wrapper for stat syscall?
16:15:15 <sjanssen> dancor: quasi-quoting is part of the TH machinery
16:15:27 <dancor> sjanssen: but SYB is not?
16:15:36 <sjanssen> Peaker: System.Posix.Files
16:15:41 <sjanssen> dancor: TH and SYB are unrelated
16:15:49 <Peaker> sjanssen: thanks
16:15:49 <dancor> what's the deal with Language.Haskell.TH.SYB
16:16:02 <perspectival> does anyone know if it's possible to compile a 32-bit binary on x86_64 (ghc --make --obscure-flag maybe?
16:16:24 <sjanssen> dancor: where do you see that?
16:16:25 <dancor> i guess that's old
16:16:31 <centrinia> perspectival, You can use ghc to generate C source files and use a cross compiler.
16:16:32 <dancor> http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Language-Haskell-TH-SYB.html
16:16:44 <dancor> empty page!  anyway doesn't seem to be in derive 0.1.4
16:17:02 <sjanssen> dancor: that just provides Data instances for the TH data types
16:17:29 <pejo> centrinia, is that approach working for you?
16:17:42 <centrinia> pejo, I have never tried it. :)
16:17:58 <sjanssen> dancor: that way, one can do SYB traversals on the TH syntax trees
16:18:15 <perspectival> centrinia: ok, thanks :-)
16:18:27 <dancor> so SYB and TH are two different approaches to metaprogramming, TH the more aggressive and difficult of the two, and they both involve extensions in the compiler?
16:18:51 <sjanssen> dancor: that's too general to say yes or no
16:19:37 <pejo> dancor, I find the first syb papers very readable.
16:19:49 <sjanssen> TH definitely requires extensions, and SYB may use compiler extensions, but they're not strictly required
16:24:26 <Saizan> sjanssen: you need at least Rank2Types for SYB, no?
16:25:01 <Saizan> but yeah, SYB is not an extension itself
16:25:36 <Peaker> hmm.. weird that fuse is forcing me to fill the uid of files -- can't fake non-mine can I?
16:26:11 <sjanssen> Saizan: yes, I believe Typeable is also required
16:26:52 <dancor> ah http://www.cs.vu.nl/boilerplate/#FAQ
16:27:30 <hydo> Is there a way to OR the cases of a case statement?  I know it doesn't work, but something like case x of  Object y || Number z -> ... ?
16:27:41 <sjanssen> hydo: no
16:27:51 <hydo> well ppt
16:28:27 <dancor> is that like pfft
16:28:42 <hydo> dancor: yep, but more sullen.
16:29:23 <dancor> for something like that especially how would you do stuff with y/z in the ..
16:29:53 <dancor> a lot of times i will write a function and call that from multiple case possibilities
16:30:26 <hydo> dancor: yea, that was a bad example... I was thinking more like Object y || Number y
16:30:35 <hydo> but my fingers weren't having any of that.
16:31:18 <dancor> ya i would probably do (let f y = .. in case ..)
16:31:23 <Peaker> how do I get: UTCTime -> EpochTime ?
16:31:26 <dancor> guards might be good to use too..
16:33:39 <hydo> Maybe I should just rewrite this whole function... I'm getting a non-exhaustive patterns error with a _ -> at the end.  It's making me a sad panda.
16:34:29 <Peaker> @hoogle Data.Time.Clock
16:34:30 <lambdabot> module Data.Time.Clock
16:34:30 <lambdabot> package hsclock
16:34:31 <dancor> Peaker: http://hackage.haskell.org/packages/archive/time/1.1.2.2/doc/html/Data-Time-Clock-POSIX.html#v:posixSecondsToUTCTime
16:35:12 <Peaker> hmm.. I don't have Data.Time.Clock or Data.Time.Clock.POSIX
16:35:28 <dancor> hydo: you could paste it..
16:35:41 <dabblego> psault, let us know when you're ready to start learning
16:35:49 <Peaker> ah, found it
16:35:51 <hydo> I did once about an hour ago, but I can again.  one sec.
16:36:00 <Peaker> dancor: thanks
16:36:23 <Peaker> I wish cabal package names were simply the package name in full.  cabal install Data.Time.Clock
16:37:19 <dancor> Peaker: well they can install multiple things.  but ya some built-in lookup for that would be nice
16:37:24 <ddarius> Data.Time.Clock isn't a package name, it's a module name, and packages don't need to contain just one module (tree) and can have the same modules as another package.
16:37:42 <hydo> dancor: http://tinyurl.com/dk4lqf
16:37:44 <ddarius> dancor: Isn't that what Hoogle and Hayoo do and Hackage will likely do more of.
16:37:53 <Peaker> ddarius: well, if there's ambiguity it could interactively help
16:38:20 <dancor> ddarius: i guess so?  hoogle is missing stuff all the time, and hayoo is like proprietary as far as i can tell
16:38:37 <ddarius> Peaker: How would you resolve the ambiguity?  If you add more names, you are just where you are now.
16:39:06 <vixey> heh  hoogle :: forall a. a
16:39:20 <vixey> hoogle "foo" :: Int ~> 3
16:39:28 <Peaker> ddarius: most of the time there is no ambiguity, when there is, it could say: "package1, package2, package3 all offer a module by this name. which one would you like to install?"
16:40:52 <dancor> hydo: my guess is your pattern match error is from kpath only being defined when first arg [String] is not []
16:41:06 <tomh> whats ~>
16:41:19 <dancor> hydo: but the error message would be clear that it's that and not a case stmt iirc
16:41:42 <dancor> well you know, clear as far as error messages go
16:41:45 <vixey> evalutates too
16:41:53 <tomh> ok
16:52:08 <hydo> dancor: yep, that was it!  Thanks a lot!
16:53:43 <Peaker> Use of   IO (Either ...)  could instead be:  EitherT IO ...  right?
16:53:55 <Peaker> The Either is used for error handling, so it'd make more sense to use EitherT there
16:54:39 <EvilTerran> the standard MTL has that weird ErrorT, though
16:55:39 <EvilTerran> ?unmtl ErrorT e IO a
16:55:39 <lambdabot> IO (Either e a)
16:57:02 <Peaker> EvilTerran: why is that weird?
16:57:32 <EvilTerran> i mean the class constraint on the "e" there
16:57:55 <Peaker> MonadError or such?
16:58:00 <Peaker> @info MonadError
16:58:00 <lambdabot> MonadError
16:58:05 <Peaker> @src MonadError
16:58:05 <lambdabot> class (Monad m) => MonadError e m | m -> e where
16:58:05 <lambdabot>     throwError :: e -> m a
16:58:05 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
16:58:13 <Peaker> @src ErrorT
16:58:13 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
16:58:24 <EvilTerran> um
16:58:38 <EvilTerran> ?type (>>=) :: Monad m => ErrorT e m a -> (a -> ErrorT e m b) -> ErrorT e m b -- this
16:58:39 <lambdabot>     Could not deduce (Error e) from the context (Monad m)
16:58:40 <lambdabot>       arising from a use of `>>=' at <interactive>:1:0-4
16:58:40 <lambdabot>     Possible fix:
16:59:41 <EvilTerran> Either e a -> (a -> Either e b) -> Either e b -- would've been a simpler example
16:59:45 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:47 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:49 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:51 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:53 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:53 <EvilTerran> ?where ops
16:59:53 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
16:59:54 <lambdabot> mauke
16:59:55 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
16:59:57 <manoleteee> http://barbaritoso.elbruto.es <- MOST ADDICTIVE GAME EVER SINCE YETISPORTS.
17:00:01 --- mode: ChanServ set +o glguy
17:00:09 <EvilTerran> ...
17:00:19 <lament> wow, i must check out this yetisports!
17:00:40 --- mode: glguy set -o glguy
17:00:45 <EvilTerran> maybe i should wait longer before pushing the ops button =/
17:01:26 <Peaker> ok this manoleteee dude is in #django and this is his ordinary nick, if anyone wants to annoy him back a little
17:02:05 <glguy> any reaction to the spam is best done out of channel
17:04:31 <morphir> anyone heard of DCI (Data Context Interaction) ?
17:06:33 <morphir> ref, http://www.artima.com/articles/dci_visionP.html
17:06:57 <morphir> I think this is where haskell falls short to OO
17:08:18 <Peaker> morphir: tl;dr, any summary? :)
17:09:59 <morphir> Peaker: basically its about segregating the procedures from the data, by creating dumb objects that has 'roles'. Roles or traits embody procedures.
17:10:24 <morphir> based on the context you are in, you will be able to execute the procedures
17:10:48 <Peaker> morphir: why does this relate to OO?
17:11:08 <morphir> it does OO more cleanly
17:11:24 <morphir> more agile friendly if you like..
17:11:27 <Peaker> morphir: how about FRP, as an alternative?
17:11:27 <paul424> hey what's wrong with this : problem1= sum [x| x <- [1..1000], (x mod 3 == 0) && (x mod 5 == 0)  ]
17:11:39 <morphir> FRP being?
17:11:41 <EvilTerran> paul424, `mod`, not mod
17:11:47 <Peaker> paul424: mod is a prefix function so it has to be used mod x 3   or x `mod` 3
17:11:55 <paul424> oh ok
17:11:59 <Peaker> morphir: Functional Reactive Programming
17:12:10 <EvilTerran> paul424, alphanumeric names are prefix, unless you wrap them in ``s, which makes them infix.
17:12:18 <Peaker> The Network "high-level" interface uses TCP, Unix sockets, or what? Doesn't seem to be documented
17:12:20 <Gracenotes> mm. unlike ML, all functions that have letters are prefix functions
17:12:32 <EvilTerran> (and punctuation names are infix, unless you wrap them in ()s, making them prefix)
17:12:44 <paul424> thanks very much
17:12:49 <dancor> > (`mod`) 10 3
17:12:50 <morphir> Peaker: thats a new word to me. But Im asking because Im curious if haskell can do this even more gracefully than say for instance scala.
17:12:50 <lambdabot>   <no location info>: parse error on input `)'
17:13:08 <Peaker> morphir: I think FRP is the future of doing reactive things gracefully :)
17:13:20 <Peaker> morphir: its basically composing reactive programs from simpler reactive programs
17:13:23 <dancor> but not quite the present :/
17:13:28 <morphir> Peaker: thanks for the heads up.
17:13:36 <Peaker> dancor: any idea if Reactive works well with ghc 6.10.2?
17:14:14 <Gracenotes> <codez> helo #haskell, i am st udent in senior year of computer scientist, plz send teh codez to mrishrnu9319@gmail.com thanx :) </codez>
17:14:24 <dancor> Peaker: no i'm still rocking 6.10.1   i'm referring more to some of the outstanding issues with reactive that are not clearly solvable to my simple mind
17:14:36 <dancor> conal will probably solve them tho
17:14:45 <skorpan> isn't it sad that the first impression you get of a programming language is most often the syntax?
17:14:50 <Peaker> dancor: one can count on conal :)
17:15:01 <Peaker> skorpan: it was also my last impression of Perl :)
17:15:03 <Gracenotes> skorpan: the first errors you get tend to by syntax errors
17:15:06 <Gracenotes> *be
17:15:12 <Peaker> skorpan: it turned me away from Haskell the first time I tried learning it
17:15:15 <morphir> Peaker: lol. Good one.
17:15:30 <skorpan> Peaker: what? but haskell's syntax is awesome?
17:15:36 <morphir> haskells syntax makes me cringe
17:15:38 <skorpan> f x = x * 2, how simple could it get?
17:16:25 <morphir> (define (f x) (* x 2))
17:16:28 <dancor> skorpan: layout is not simple to me, i still occassionally am frantically "fuzzing" layout to get something to compile
17:16:34 <mauke> morphir: ))))))))))))))))))))
17:16:46 <AxleLonghorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4075 How can this be made better?
17:16:46 <Peaker> skorpan: not at first, when you come from C/Python/et al
17:16:52 <skorpan> i don't speak any lisp but elisp...
17:17:06 <AxleLonghorn> it attempts to count the number of times a word appears in a text file
17:17:06 <dancor> in particular you can't align parens at times you thought you could and have to instead indent the closing paren
17:17:10 <skorpan> Peaker: not at first?  i think i missed something.  what?
17:17:17 <Peaker> skorpan: I like Haskell syntax now -- but I went through at least 3 weeks of *hating* it when I first learned it
17:17:34 <skorpan> ah, right
17:17:37 <morphir> lol. Thats bondage.
17:17:41 <mauke> (defun f (x) #$ * x 2)
17:17:46 <Peaker> skorpan: the multitude of encodings of the same concepts bugged me (guards, ifs, cases, pattern matches, definitions in where, in let, infix, prefix, etc)
17:17:57 <skorpan> well, i came from php, html and mirc scripting and stuff, i freaking loved haskell's syntax ;)
17:18:15 <Peaker> skorpan: Haskell was your first sane language?
17:18:44 <skorpan> Peaker: i had no experience with real OOP when i learned haskell, which is actually a good thing i believe
17:18:58 <QtPlaty[HireMe]> Peaker: Define 'sane'
17:19:30 <skorpan> sane = flip notElem [php, msl]
17:19:56 <Peaker> well, mainstream that is not PHP would be close :)
17:19:56 * morphir got the impression that haskell is the new cool kid on the block. Handing out buzzword t-shirts.
17:20:15 <QtPlaty[HireMe]> Peaker: Ok I'll accept that.
17:20:20 <dancor> with () and [] etc in layout, i get hit by more complex forms of this a lot i think: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2176#a2176
17:20:22 * QtPlaty[HireMe] laughs.
17:20:25 <paul424> suppose I have the 2nd problem from EP site: problem2 = sum [x| x<- fibbonaci, x `mod` 2 == 0], since the fibbonaci is already defined as infinite list of fibbonaci numbers. Is there a way to constraint the list in the sum function  to take only the numbers smaller than 4  000 000  ? i.e. to make it finite ?
17:20:25 <Peaker> reasonably well-thought-out-of languages
17:20:31 <skorpan> it's kind of weird when i think about it...  i knew nothing back then.  and this was only five years ago!
17:20:39 <Gracenotes> > let f (x:xs) n = if n == 0 || x then '(':f xs (n+1) else ')':f xs (n-1) in f (randoms (mkStdGen 49230)) 0
17:20:41 <lambdabot>   "()()(((())((())(((()()()()))(((()))(((()))(())())))))()())(((()))(()()())(...
17:21:02 <Peaker> paul424: you can use "take" or takeWhile on the result or input of the list comprehension
17:21:19 <Peaker> paul424: you can also replace the list comprehension with a simple "filter", which makes it more natural to use take/takeWhile
17:21:40 <paul424> ok thanks Peaker
17:22:10 <skorpan> i took three programming courses at my "gymnasium" (secondary education?), supposedly dealing with delphi, C++ and java...  they taught us nothing about the concept of classes.  ridiculous.
17:22:34 <mauke> no classes in java?
17:22:37 <skorpan> mauke: no classes.
17:22:40 <mauke> I am amused
17:22:52 <skorpan> we learned that "public class" was just supposed to be there.  "never mind that!"
17:23:14 <Peaker> teaching classes has little to do with CS IMO
17:23:20 <skorpan> the major difference in our delphi course and our c++ course was replacing a bunch of "." with "->"...
17:23:23 <Peaker> they should just teach Scheme or Haskell or such
17:23:44 <skorpan> Peaker: but then no one would get a job if they decided not to study further
17:23:46 <Philippa_> eh, secondary school isn't uni
17:23:54 <Philippa_> it's supposed to cover some practical stuff too
17:23:55 <Peaker> skorpan: win win
17:24:00 <skorpan> Peaker: true haha
17:24:26 * dancor is dealing with layout issue with do/<|>/if right now
17:24:42 <Philippa_> dancor: read the description of layout in the Report
17:24:45 <Peaker> so what is the "high-level" Network package doing?  TCP? Unix sockets?
17:24:51 <Philippa_> that ought to make everything clear enough for yuo
17:24:53 <Philippa_> *you
17:25:00 <skorpan> what's even weirder though is that the name of this education was "computer science and telecommunications" and was something of a preparatory education for chalmers.
17:25:10 <edwardk> @seen byorgey
17:25:10 <lambdabot> byorgey is in #haskell-overflow, #haskell-blah, #xmonad and #haskell. I last heard byorgey speak 1h 36m 49s ago.
17:25:13 <cooldude127> is it not possible to compose functions that take more than one argument? like say i have a function f :: a -> b -> c and g :: c -> d, can i get a function a -> b -> d ?
17:25:17 <edwardk> byorgey: back
17:25:26 <dancor> Philippa_: then i would just be collusive to its arcanity.
17:25:32 <Peaker> cooldude127: you can, but you need a slight shift in the way you think about it :)
17:25:50 <cooldude127> Peaker: what do you mean?
17:25:51 <Peaker> cooldude127: first, lets define the "result" combinator.  result = (.)   and applies a function to the result of another function
17:25:54 <Philippa_> dancor: no, you wouldn't. You'd be allowing yourself to realise it's damn simple if you actually RTFM and find out how it works
17:26:05 <edwardk> @type fmap . (.)
17:26:05 <Philippa_> (well okay, it's not /that/ simple, but the ways in which it's not aren't your problem)
17:26:06 <lambdabot> forall (f :: * -> *) b c a. (Functor f) => (b -> c) -> f (a -> b) -> f (a -> c)
17:26:07 <dancor> /ignore Philippa_
17:26:29 <Peaker> cooldude127: now, if we want to apply a function to the result of a result of a function, we can use:    result (result f) g
17:26:34 * Philippa_ shrugs
17:26:43 <Peaker> cooldude127: this can be spelled (result . result) f g
17:26:58 <edwardk> @type (.) . (.)
17:26:59 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:27:05 <Peaker> cooldude127: and you can read (result . result) as sort of a "path" to traverse before applying f, and g is the container in which this path is
17:27:09 <Gracenotes> :OX
17:27:17 <Peaker> @where semantic editor combinators
17:27:17 <edwardk> @type fmap `fmap` fmap
17:27:18 <lambdabot> I know nothing about semantic.
17:27:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:27:22 <Peaker> @go semantic editor combinators
17:27:24 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
17:27:24 <lambdabot> Title: Conal Elliott » Semantic editor combinators
17:27:37 <Peaker> cooldude127: The URL there ^^ goes to greater depth about this very cool technique
17:27:54 <Gracenotes> @type (liftM.liftM) `asTypeOf` ((.).(.))
17:27:55 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:28:10 <edwardk> @type liftM `liftM` liftM
17:28:11 <lambdabot> forall (m :: * -> *) a1 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
17:28:21 <Gracenotes> yah
17:28:22 <Peaker> cooldude127: the thing is this is more general than just applying to the results of functions:
17:28:30 <edwardk> @type liftA `liftA` liftA
17:28:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f1, Applicative f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:28:37 <Gracenotes> liftM.liftM is nice and compact. And there are many things you can do with variations
17:28:51 <Peaker> > (first . second . first) (*2) ((1,(2,3)),4)
17:28:53 <lambdabot>   ((1,(4,3)),4)
17:28:59 <Peaker> cooldude127: see that? ^^
17:29:06 <edwardk> @type fmap <$> fmap -- so many synonyms ;)
17:29:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:29:15 * Philippa_ also wonders vaguely whether dancor actually knows you can use explicit braces and semis instead, or which constructs use them. Once you've got that, you can write the code you intended just by remembering the one rule you might not have figured out explicitly, which is that newline + same indent => implicit ;
17:29:16 <cooldude127> i'm so lost in all the type signatures
17:29:20 <Gracenotes> liftM2.liftM2, liftM2.liftM, liftM3.liftM3.liftM3, etc.
17:29:41 * edwardk stops spamming
17:29:42 <Peaker> cooldude127: try to look at just the (first . second . first) example, ignore the types for a moment
17:29:48 <Gracenotes> for all your function-lift combinator needs
17:30:26 <cooldude127> i was just running into the case where i thought i could go point-free with a big chain of composed functions, but the last one is a binary operator
17:30:42 <cooldude127> or the first one i guess
17:30:47 <cooldude127> last one on the line but first one used
17:31:14 <cooldude127> but this doesn't look like it will make it shorter
17:31:15 <Peaker> > (result . result) (*10) (+) 1 2
17:31:17 <lambdabot>   Not in scope: `result'Not in scope: `result'
17:31:22 <Peaker> @let result = (.)
17:31:23 <lambdabot>  Defined.
17:31:24 <Peaker> > (result . result) (*10) (+) 1 2
17:31:25 <lambdabot>   30
17:31:32 <zoheb> @type result
17:31:34 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:31:41 <Peaker> cooldude127: I just applied a function to the result of a binary operator (+)
17:31:49 <cooldude127> oh hey
17:31:54 <cooldude127> let me try it out then
17:31:57 <zoheb> @type .
17:31:58 <lambdabot> parse error on input `.'
17:32:02 <Peaker> @type (.)
17:32:03 <zoheb> @type (.)
17:32:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:32:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:32:16 <zoheb> @type (result)
17:32:18 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:39:00 <Peaker> RWH doesn't have any examples involving Network, only Network.Socket and lower-level socket stuff
17:39:09 <edwardk> @pl \m -> lift (f m `catchError` h)
17:39:09 <lambdabot> lift . (`catchError` h) . f
17:39:20 <cooldude127> Peaker: thank you
17:39:42 <Peaker> cooldude127: sure thing, be sure to read conal's semantic-editor-combinators blog entry. Its great
17:40:00 <cooldude127> will do
17:41:21 <Gracenotes> > .
17:41:21 <lambdabot>   <no location info>: parse error on input `.'
17:43:54 <paul424> why ( (mod flip 2) == 0) is not of the type Int-Bool ?
17:44:23 <mauke> do you mean Int->Bool?
17:44:37 <mauke> it can't be a function because == always returns a plain Bool
17:45:14 <Axman6> :t (mod flip 2)
17:45:16 <lambdabot> forall a b c. (Integral ((a -> b -> c) -> b -> a -> c)) => (a -> b -> c) -> b -> a -> c
17:45:24 <Axman6> paul424: that's why
17:46:14 <BMeph> paul424: 'Maybe you meant: "mod `flip` 2"?" ;)
17:46:22 <MyCatVerbs> Were you after ((==0) . (flip mod 2)), perhaps?
17:46:38 <MyCatVerbs> Which would be the same as (even).
17:48:00 <BMeph> @let zeroP = (==0)
17:48:01 <lambdabot>  Defined.
17:48:16 <BMeph> ^^ For all you Scheme fans... ;)
17:48:48 <Axman6> is there a oneP too?
17:48:59 <MyCatVerbs> BMeph: wouldn't the Scheme fans want to call it "zero?" instead. ;P
17:49:54 <BMeph> MyCatVerbs: Eh, I dunno, I always get confused when the Scheme/CL religious wars break out.
17:50:05 <paul424> at least how to make GHCI more flexible : I mean to allow copy paste edit the expressions from window ?
17:50:07 <MyCatVerbs> > [1..10] <**> [even,((==0) . (flip mod 2))]
17:50:08 <lambdabot>   [False,False,True,True,False,False,True,True,False,False,True,True,False,Fa...
17:50:57 <morphir> is the haskell trolls a sleep?
17:53:11 <roconnor> > log (1/2)
17:53:13 <lambdabot>   -0.6931471805599453
17:54:45 <MyCatVerbs> @check \n -> (even n) == ((==0) . (flip mod 2) $ n)
17:54:46 <lambdabot>   "OK, passed 500 tests."
17:55:13 <Axman6> > logBase 1
17:55:14 <lambdabot>       Overlapping instances for Show (t -> t)
17:55:14 <lambdabot>        arising from a use of `s...
17:55:18 <Axman6> > logBase 1 (1/2)
17:55:19 <lambdabot>   -Infinity
17:55:21 <Axman6> > logBase 2 (1/2)
17:55:23 <lambdabot>   -1.0
17:55:25 <Axman6> bleh
17:56:32 <MyCatVerbs> Heheheh. lambdabot has become terminally confused.
17:56:59 <Axman6> more like i have
17:57:47 <MyCatVerbs> Well, in this case, somebody thought it was a good idea to add an instance (Show (a -> b)) where showsPrec _ = ("*function*"++).
17:58:42 <MyCatVerbs> Which is, well, fair enough. But now it sounds like somebody else might have added a second one or something. Ooops.
18:03:44 <byorgey> edwardk: I was just wondering which recursion scheme to use to achieve a particular goal, but I figured it out
18:03:58 <byorgey> it was just a catamorphism.
18:04:10 <edwardk> byorgey: ah
18:04:36 <edwardk> sitting here beating my head against various kan extensions =/
18:04:52 <idnar> MyCatVerbs: the instances are (Typeable a, Typeable b) => Show (a -> b) and (Test.SmallCheck.Serial a, Show a, Show b) => Show (a -> b)
18:05:05 <idnar> from ShowFun and Test.SmallCheck respectively
18:05:07 <roconnor> kaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaann!
18:05:25 <idnar> kahn?
18:05:28 <mauke> roconnor++
18:05:28 <edwardk> roconnor: definitely extended. ;)
18:05:34 <MyCatVerbs> Yes, "Kh"++(fix ('a':))++"n!" indeed.
18:05:58 <roconnor> no no kan
18:06:10 <edwardk> roconnor: i have a coworker that mocks the scream from wrath of kahn whenever i mention the phrase 'kan extension'
18:06:27 <roconnor> I'm so unoriginal
18:06:34 <roconnor> @karma- roconnor
18:06:35 <lambdabot> You can't change your own karma, silly.
18:06:43 <Axman6> heh
18:06:59 * Axman6 would argue that only you can chan ge your karma
18:07:10 <edwardk> roconnor++
18:07:14 <blackh> (1+) `fmap` roconnor
18:07:33 <edwardk> just to offset any damage you manage to do to your karma in the process of experimenting
18:07:57 <Axman6> @karma roconnor
18:07:58 <lambdabot> roconnor has a karma of 8
18:08:08 <Axman6> @ka
18:08:08 <lambdabot> Maybe you meant: karma karma+ karma- karma-all . ? @ bf faq ft id keal map pl rc v wn
18:08:22 <Axman6> hmm
18:08:24 <Axman6> @ma
18:08:24 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
18:08:29 <Axman6> o.O
18:08:34 <Axman6> @m
18:08:35 <lambdabot> Maybe you meant: map messages messages? more msg . ? @ v
18:09:01 <Axman6> thought there was a way to find what had the most karma
18:09:23 <ray> @karma-all
18:09:24 <lambdabot>  "moritz"              555
18:09:25 <lambdabot>  "pmichaud"            396
18:09:27 <lambdabot>  "lwall"               305
18:09:29 <lambdabot>  "pmurias"             259
18:09:31 <lambdabot>  "jnthn"               242
18:09:32 <Axman6> ah right
18:09:33 <lambdabot> [1196 @more lines]
18:09:42 <centrinia> How do you take the output of Lambdabot an apply a Haskell function to it?
18:09:47 * Axman6 wonders who those people are
18:09:55 <Axman6> @.
18:09:56 <lambdabot> Not enough arguments to @.
18:10:08 <Axman6> @. words karma-all
18:10:09 <lambdabot> Plugin `compose' failed with: Unknown command: "words"
18:10:14 <blackh> lwall = Larry Wall? I don't get this perl thing at all.
18:10:25 <Axman6> uh, right
18:10:29 <ray> perl hacked lambdabot
18:10:39 <edwardk> lambdabot sits in #perl6
18:10:51 <Axman6> @seen lambdabot
18:10:51 <lambdabot> Yes, I'm here. I'm in ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it, #
18:10:52 <lambdabot> haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-freebsd, #macosx, ##freebsd, #gentoo-uy, #gentoo-
18:10:52 <lambdabot> haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #haskell
18:10:57 <BMeph> edwardk: So, is there a central Kan extn? ;)
18:11:13 <edwardk> BMeph: =) extend it both ways?
18:11:15 <ray> i guess they're just implanting lots of dubious karma points into the poor bot
18:11:58 <edwardk> or should i say, erm, ask Kan, just make sure that you do so in a public place.
18:12:45 <sw17ch> @hoogle IO Bool -> b -> b -> IO b
18:12:46 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
18:12:46 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
18:12:46 <lambdabot> Foreign.C.Error throwErrnoIf :: a -> Bool -> String -> IO a -> IO a
18:13:03 <sw17ch> any one have ideas?
18:13:30 <Axman6> liftM3 if'?
18:13:31 <sw17ch> doIf a v1 v2 = a' <- a; if a then return v1 else return v2
18:13:40 <sw17ch> if'?
18:13:41 <BMeph> sw17ch: "Save the whales, collect the entire set"? ;p
18:13:42 <Axman6> :t liftM3 if'
18:13:44 <lambdabot> Not in scope: `if''
18:13:47 <Axman6> bah
18:14:02 <Axman6> :t let if' p t f = if p then t else f in liftM3 if'
18:14:04 <lambdabot> forall a2 (m :: * -> *). (Monad m) => m Bool -> m a2 -> m a2 -> m a2
18:14:20 <sw17ch> Axman6: is there an if'? :)
18:14:26 <Axman6> in Data.Bool
18:14:28 * sw17ch wishes if was first class
18:14:35 <dolio> @type \mb t f -> fmap (\b -> if b then t else f) mb
18:14:36 <lambdabot> forall b (f :: * -> *). (Functor f) => f Bool -> b -> b -> f b
18:14:55 <sw17ch> Data.Bool says ... no?
18:15:11 <Axman6> maybe not
18:15:15 <Axman6> @hoogle if'
18:15:16 <lambdabot> No results found
18:15:16 <sw17ch> dolio: that's exactly what i want
18:15:20 <sw17ch> now does it exist
18:15:31 <Axman6> thought it was there. it's pretty common in here
18:15:37 <dolio> It doesn't have a name, no.
18:15:48 <sw17ch> right, every one else wants if to be first class too
18:15:55 <ray> @let if' p t f = if p then t else f
18:15:57 <lambdabot>  Defined.
18:16:09 <Axman6> :t liftM3 if'
18:16:11 <lambdabot> forall t (m :: * -> *). (Monad m) => m Bool -> m t -> m t -> m t
18:46:44 <flazz> is there a way in haskell-mode to send the buffer or region to the running inf-haskell?
18:48:05 <QtPlaty[HireMe]> flazz: Reloading the current buffer?
18:48:21 <QtPlaty[HireMe]> C-c C-l
18:48:30 <QtPlaty[HireMe]> Or do you mean something elsE?
18:49:26 <flazz> i just want a way to get some code in my haskell source buffer into inf-haskell
18:50:47 <flazz> that seemed to do it
18:50:48 <flazz> thanks
18:57:16 <flazz> is there a way to get a list of all constructors of a type?
18:58:08 <adamvo> :info Type -- in ghci, and hugs too IIRC
19:14:31 <vixey> is there anything like graphvis implemented in haskell?
19:16:28 <blackdog> vixey: you can't just use the graphviz wrapper?
19:16:35 <vixey> yeah
19:17:40 <QtPlaty[HireMe]> vixey: Whats the problem your trying to solve?
19:19:43 <vixey> At the moment it is not totally concrete
19:20:26 <BMeph> vixey: So, like plaster? Or epoxy? ;p
19:20:42 <SamB> vixey: what are you pondering ?
19:20:46 <p_l> or worse, butter?
19:22:59 <vixey> I have an algorithm that generates some directed graphs, so we have two loops in this and we'd like to 1) display the graph to emphasize those two loops 2) be able to connect the loops (make a path from one to the other)
19:26:07 * QtPlaty[HireMe] thought that would be expressable in the graphviz language.
19:26:38 <vixey> yeah it is
19:27:50 <QtPlaty[HireMe]> So what is the problem?
19:30:36 <vixey> hmf I want to use dependent types in haskell
19:30:56 <vixey> I have fixed length vectors but I just have to use []
19:31:07 <vixey> it feels like I am keeping secrets from the type system
19:31:22 <dolio> You don't need dependent types for fixed length vectors.
19:31:40 <vixey> I do :p
19:31:52 <vixey> I mean I want to program with it too
19:33:01 <dolio> Of course, defining multiplication requires enabling undecidable instances, as I recall, which isn't ideal.
19:34:29 <RichN> Hello! Has anyone had success installing hscurses?
19:35:12 <RichN> When I try to configure, I get "* Missing header file: HSCurses.h".
19:35:33 <RichN> But that header file is in the "cbits" directory.
19:36:22 <RichN> The .cabal file mentions the 'cbits' directory, yet it never successfully configures the project directory.
19:37:44 <TomMD> RichN: I can install 1.3.0.2 without issue.
19:38:42 <RichN> I've installed many haskell libraries. This is the first with which I can't.
19:39:41 <TomMD> RichN: Do you have curses-devel installed?
19:39:52 <TomMD> err, libcurses, or whatever the package is.
19:40:02 <TomMD> @users
19:40:03 <lambdabot> Maximum users seen in #haskell: 658, currently: 579 (88.0%), active: 11 (1.9%)
19:41:00 <RichN> I have ncurses installed. It's a NetBSD system running GHC 6.8.3.
19:41:20 <TomMD> Is the development library installed, giving you the needed headers?
19:41:35 <TomMD> If so then perhaps this is an issue with cabal finding the right include directories.
19:41:55 <RichN> The development Haskell library? Or development ncurses library?
19:42:10 <TomMD> I'd run cabal install with -v3, or whatever the verbosity flag is.  I mean the dev ncurses library.
19:42:16 <RichN> It's ncurses 5.7
19:42:42 <RichN> Dunno if that's the "devel" library, but it's the latest in the NetBSD package system.
19:43:53 <rdeshpande> hello all
19:45:16 <pejo> RichN, is that under /usr/pkg or something similar? You probably need to point the configure script for hscurses to your headers.
19:45:57 <RichN> Okay, the '-v3' was a help. It looks like it's finding the curses.h header in /usr/include before it finds ncurses.h in /usr/pkg/include
19:53:36 <amz> sigh, I must be stupid, but what is the practical difference between interfaces in a language like C++ or Java and type classes in Haskell?
20:03:37 <tgdavies> amz: You can make an existing data type an instance of a type class without modifying the original data type
20:03:59 <amz> Ah-hah
20:04:03 <amz> I see, NOW it all makes sense
20:04:05 <amz> thanks :)
20:04:10 <pumpkin> typeclasses also allow you to specify more powerful constraints, I think
20:04:44 <dev31212> hello all
20:04:57 <pumpkin> allo
20:06:15 <dev31212> allo mon cher
20:06:16 <dev31212> ca va?
20:06:23 <pumpkin> alô
20:07:02 <dev31212> je suis louisianne creole....Afrique, Francais, un peu de...
20:07:12 <dev31212> le mot...
20:07:16 <dev31212> je ne sais pas
20:07:22 <dev31212> American Native?
20:07:23 <dev31212> ...etc
20:08:24 <Apocalisp> Hvað í andskotanum gengur á hér?
20:10:01 <dev31212> :o
20:10:30 <ray> 巴
20:10:39 <dev31212> Haskell is so cool..
20:12:23 <dev31212> lambdabot
20:12:32 <dev31212> lambdabot help
20:12:40 <dev31212> ,help
20:12:46 <lunabot>  type of an expression:      , [$ty| \x -> x |]
20:12:46 <lunabot>  get info for a type/class:  , src ''Monad
20:12:46 <lunabot>  get info for a var/con:     , src 'fix
20:13:03 <vixey> , src ''Monad
20:13:06 <lunabot>  class Monad m where
20:13:06 <lunabot>          (>>=) :: forall b a . m a -> (a -> m b) -> m b
20:13:06 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
20:13:13 <dev31212> src ''Maybe
20:13:21 <dev31212> hmm
20:13:27 <byorgey> @commands
20:13:27 <lambdabot> Unknown command, try @list
20:13:31 <byorgey> @list
20:13:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:15:30 <dev31212> ,let x = 4
20:15:32 <lunabot>  luna: parse error on input `)'
20:15:38 <dev31212> ,x=4
20:15:40 <lunabot>  luna: parse error on input `='
20:15:54 <dev31212> , foo x = x + 5
20:15:56 <lunabot>  luna: parse error on input `='
20:16:00 <dev31212> ...
20:16:35 <andresj> hey, I put: import System.Log.Logger (DEBUG, INFO, NOTICE, WARNING, ERROR, CRITICAL, ALERT, EMERGENCY) in the top of my haskell code, but it tells me System.Log.Logger doesn't export those... its supposed to, though. And when I: import System.Log.Logger; I can use DEBUG and all those pretty well. any ideas?
20:17:15 * QtPlaty[HireMe] wonders why scripting languages don't get much accedemic attention.
20:18:17 <dev31212> I hate when people say "scripting"
20:18:29 <dev31212> Programming is programming.
20:18:30 <vixey> dev31212: why?
20:18:36 <dev31212> pet peeve
20:18:38 <dev31212> I dunno
20:18:43 <dev31212> maybe because I do PHP for a living.
20:18:44 <andresj> prob because it makes them seeme like play-languages
20:18:48 <amz> Python is pretty popular nowadays
20:18:50 <dev31212> (but not much longer)
20:19:05 <QtPlaty[HireMe]> dev31212: I do as well, but what better term would you use?  I use P* but noone understanda that term.
20:19:08 <andresj> ues, Python is what I go back to after nirvana with Haskell ;P
20:19:11 <vixey> I wonder if we all have roughly the same idea what a scripting languages is
20:19:11 <dev31212> In all honesty though, I came to haskell because of its strong typing
20:19:22 <dev31212> and its ability to catch, not just syntax, but potential logic errors :)
20:19:31 <dev31212> So I am kind of rebelling
20:19:40 <dev31212> vixey, who knows
20:19:44 <dev31212> show me yours
20:19:47 <dev31212> maybe ill show you mine.
20:19:48 <amz> I really can't stand dynamically-typed languages
20:19:57 <amz> except for small projects or scripts
20:19:58 * QtPlaty[HireMe] has a strong dislike for PHP's type system it seems to the worst of both worlds.
20:20:01 <vixey> :p
20:20:01 <amz> (very small projects)
20:20:05 <andresj> amz, i totally agree with that
20:20:07 <dev31212> I went from c++, to java, toi php...prefoessionally
20:20:10 <inimino> QtPlaty[HireMe]: try P(ython|HP|erl|^HRuby) next time; much clearer
20:20:15 <dev31212> steadily easier jobs...and mor emoney
20:20:20 <amz> lol, inimino
20:20:34 <pumpkin>  PHP is an abomination
20:20:37 <dev31212> PHP is semi functional :)
20:20:40 <andresj> it is!!
20:20:42 <dev31212> it lets you pass functions as strings
20:20:43 <pumpkin> no it isn't
20:20:44 <dev31212> :)
20:20:47 <pumpkin> lol
20:20:49 <andresj> an abominations that is
20:20:51 <amz> PHP is an offense to the very concept of programming
20:20:55 <Gracenotes> indeed
20:20:59 <pumpkin> the only good idea they had was to allow inline "splicing"
20:21:04 <andresj> too bad its all that you get in most hosting services
20:21:06 <Gracenotes> hear, hear
20:21:07 <pumpkin> which isn't that exciting
20:21:13 <pumpkin> but is a nice feature anyway
20:21:13 <inimino> pumpkin: splicing?
20:21:20 <pumpkin> the <?php ?> stuff
20:21:23 <Gracenotes> forsooth, sirs
20:21:29 <inimino> pumpkin: oh, that wasn't new
20:21:31 <andresj> the only other option is Haskell  over CGI, but it might not be as performant
20:21:33 <pumpkin> I know
20:21:40 <pumpkin> I guess it wasn't their idea
20:21:41 <QtPlaty[HireMe]> I thought that started with ASP?
20:21:50 <pumpkin> but it was what made it easy to get into
20:21:58 <QtPlaty[HireMe]> mod_haskell?
20:22:05 <amz> gee, using Haskell to write a website, that'd be trippy
20:22:07 <dev31212> Mod_haskell
20:22:11 <dev31212> I am usuing fast_cgi :)
20:22:20 <dev31212> I am like a giddy school girl
20:22:26 <dev31212> But I am a 200 poung man
20:22:27 <dev31212> :)
20:22:38 <QtPlaty[HireMe]> In a away that would sort of work.
20:22:51 <dev31212> fast_cgi/Unbuntu/Leksah...
20:22:57 <dev31212> oh, and HStringTemplate
20:23:04 <inimino> @faq can Haskell make a 200 pound man giddy like a school girl?
20:23:04 <lambdabot> The answer is: Yes! Haskell can do that.
20:23:17 <amz> speaking of Leksah, I need a win32 build of that... it sounds royally annoying to build it manually :\
20:23:29 <TomMD> dev31212: Actually, Haskells type system doesn't allow that to happen.  What just happened was:
20:23:29 <TomMD> instance GiddySchoolGirl (Man LBS300) where ...
20:23:33 <dev31212> maybe a more wise cygwin person can do it
20:23:37 <dev31212> I gave up after 3 days
20:23:37 <andresj> dont forget GHC
20:23:45 <andresj> and LOL@lambdabot/inimo
20:23:45 <dev31212> @ amz
20:23:49 <andresj> inimino, i mean
20:24:33 <amz> I guess that making it annoying to use on Windows is part of the "avoid success at all costs" strategy ;)
20:24:47 <dev31212> amz,leksah is cool
20:24:51 <dev31212> have you used it on nix?
20:24:59 <amz> no
20:25:02 <amz> I think that I deleted my Linux VM
20:25:07 <dev31212> The only problem is, it needs to actually build the source to find problems...
20:25:15 <dev31212> but maybe that will be resolved when it goes beta.
20:25:19 <dev31212> oh
20:25:20 <pumpkin> GHC API sounds helpful
20:25:31 <pumpkin> but GHC is pretty slow at compiling stuff
20:25:36 <pumpkin> I wonder what takes the longest
20:25:53 <amz> Visual Haskell seems abandoned, EclipseFP is pretty useless...
20:25:58 <dev31212> amz, well I have step by step instructions for gettig a ghc/leksah system going bookmarked
20:26:01 <pumpkin> who needs an IDE anyway?
20:26:05 <amz> so I basically use a text editor -_-
20:26:16 <dev31212> if you are not a linux master, it will save you time..
20:26:22 <dev31212> pumpkin, no one
20:26:26 <dev31212> Its just cool
20:26:32 <amz> IDEs save time
20:26:32 <dev31212> it has these nice features
20:26:35 <dev31212> makes it fun...
20:26:37 * Cale has never really understood the attraction
20:26:40 <dev31212> Programming should be fun.
20:26:41 <dev31212> :|
20:26:47 <amz> and saving time is of utmost importance
20:26:49 <Gracenotes> :D
20:26:52 <dev31212> yes amz
20:26:52 <pumpkin> you don't need a big heavyweight program that does everything to do that
20:27:01 <amz> I really don't like Java, but damn, Eclipse makes writing Java almost fun
20:27:03 <dev31212> Leksah isnt heavyweight at all
20:27:04 <inimino> vim saves time
20:27:06 <andresj> it doesnt need to be hevyweight ;P
20:27:08 <amz> I swear, it writes half of my code for me
20:27:13 <amz> ctrl+1 works magic
20:27:16 <dev31212> The only heavy thing about it, is that it cand find errors without invoking GHC
20:27:20 <inimino> s/almost fun/almost humanly tolerable/
20:27:23 <dev31212> I am sure that will be solved eventually
20:27:45 <Gracenotes> :D
20:28:13 <dev31212> I like how Haskell uses the Cabal acronym
20:28:18 <dev31212> you all are like a cabal
20:28:23 <amz> I would be content with things such as error verification as I type, code navigation, refactoring, and autobuilding
20:28:24 <dev31212> with an evil conspiracy
20:28:28 <pumpkin> it's an acronym?
20:28:34 <dev31212> pumpkin, yes
20:28:40 <Gracenotes> D:
20:28:43 <blackdog> TINHC.
20:28:45 <dev31212> amz, check out leksah for a day or two
20:28:49 <pumpkin> I always assumed it was just a name
20:28:53 <dev31212> if you dont think it is on the verge of being awesome
20:28:57 <dev31212> ill give you your money back
20:28:58 <Gracenotes> blackdog: aha, I see what 'H' stands for
20:28:59 <amz> dev31212: well, as I mentioned, I don't have a Linux machine to play with atm
20:29:06 <Gracenotes> ... or do I?
20:29:06 <amz> I need a new HDD so I have space to set another one up
20:29:07 <dev31212> I use it on Virtual Box
20:29:14 <dev31212> Xubuntu over Virtual box
20:29:21 <amz> I had Kubuntu on vmware
20:29:38 <dev31212> right, and you deleted it.
20:29:44 <dev31212> well, I wont press you
20:29:46 <blackdog> dev31212: there was an interesting article a while back on the cultural divide between language hackers and tools hackers
20:29:47 <dev31212> I just think its cool
20:29:55 <Gracenotes> pumpkin: http://en.wikipedia.org/wiki/File:There%27s_no_cabal.png
20:29:59 <dev31212> makes packaging cabal projects pretty simple..
20:30:18 <dev31212> blackdog, oh?
20:30:18 <blackdog> can't find it now, but the main point was that if you require an IDE to have fun when you program, then your choice of languages is always going to be limited to the older, more conventional ones.
20:30:32 <dev31212> blackdog, that is interesting
20:30:38 <blackdog> which is why you tend to find a lot of emacs and vi users in the haskell community
20:31:04 <dev31212> well, you know, I should, by all rights like emacs..vi
20:31:06 <QtPlaty[HireMe]> I think its because the languages you need to use an IDE with tend to have alot of redundency.
20:31:11 <dev31212> because I began coding with a c64
20:31:13 <dev31212> no mouse...
20:31:25 <pumpkin> yeah, I'd want an IDE for java
20:31:26 <pumpkin> :P
20:31:28 <dev31212> but I stopped programming at puberty
20:31:36 <dev31212> so I guess I lost all that training..
20:31:41 <Cale> If you keep two terminal windows open, one with a text editor, and one with GHCi, it's basically as fun as using an IDE. You can just type :r or even just : in ghci whenever you save your file, and it'll reload the definitions so you can test them out.
20:32:03 <dev31212> Well leksah isnt that much an IDE
20:32:08 <dev31212> for me an IDE has to have a debugger
20:32:11 <dev31212> it doesnt have that
20:32:14 <Cale> ghci is a debugger
20:32:20 <dev31212> it has pretty syntax highlighting, and helps you package cabal files
20:32:22 <dev31212> thats about it...
20:32:26 <blackdog> QtPlaty[HireMe]: well, that's it, really. The response of the language-based group to redundancy in languages is to improve the languages - the tool-based group improves the tools.
20:32:31 <Cale> Though, a traditional kind of debugger is kind of useless for Haskell.
20:32:32 <dev31212> Step by step debugger?
20:32:33 <dev31212> tracing?
20:32:39 <Cale> Yes, it does have that
20:32:42 <monochrom> Ask dons and others who work with thousands of lines of Haskell code daily to see that they still work efficiently without an IDE.
20:32:44 <pumpkin> dev31212: define step by step :P
20:32:49 <Cale> But it's less useful than you might imagine
20:32:54 <dev31212> ok, let me first say I am a newb
20:32:59 <Cale> That's just not how you debug Haskell programs.
20:33:04 <dev31212> a regular here, named c_entrenia is a friend of mine
20:33:10 <dev31212> he convinced me to get into haskell
20:33:12 <pumpkin> dev31212: haskell doesn't really have "steps" unless you're in IO, I guess
20:33:12 * QtPlaty[HireMe] find the step by step debugger in ghci less usefull then I thought it would be.
20:33:13 <pumpkin> centrinia?
20:33:19 <Cale> Cool, hope you have fun with it
20:33:20 <dev31212> pumpkin yeah
20:33:26 <dev31212> I know whayt isaid makes no sense
20:33:28 <Cale> Let us know if you run into any problems :)
20:33:30 <hamishmack> Hi we are working on a debugger for Leksa
20:33:35 <RichN> Still having problems with hscurses. I was able to get it configured, except during the build, it complains that "dist/build/UI/HSCurses/Curses.hs:1:0: file name does not match module name `Main'"
20:33:35 <dev31212> yeah pumpkin
20:33:46 <blackdog> monochrom: also interesting to note that even in the Ruby community, where debuggers _can_ be used, there's a strong social pressure to prefer writing tests to long debugger sessions
20:33:48 <RichN> Turns out that file empty!
20:33:57 <RichN> Turns out that file is empty!
20:34:01 <hamishmack> You can check it out in the leksah-head branch
20:34:16 <blackh> hamishmack: brilliant!
20:34:17 <hamishmack> It is still very basic
20:34:19 <dev31212> You know what is weird?
20:34:25 <dev31212> That often I overthing haskell solutions
20:34:31 <monochrom> And pumpkin and QtPlaty[HireMe] has one reason. Haskell doesn't need a lot of boilerplate code like Java does, and so the benefit of a would-be-IDE would be diminishing.
20:34:33 <dev31212> like I would in PHP or Java
20:34:36 <pumpkin> hamishmack: how modular is the IDE? could we slap a cocoa front-end on it for mac os?
20:34:38 <hamishmack> But it runs GHCi then sends commands to it
20:34:39 <dev31212> usually the solution is easy.
20:34:41 <dev31212> I love it
20:35:04 <inimino> Cale: yes, that's how I write Haskell (vim with several other windows)
20:35:12 <pumpkin> there still seems to be more boilerplate than needed in some haskell though
20:35:15 <QtPlaty[HireMe]> blackdog: Interestingly TDD tends to drive your code towards something that is functional.
20:35:26 <RichN> Thanks, TomMD and pejo, for the help. I need to try a few more things.
20:35:48 <QtPlaty[HireMe]> As the more state based your code is the harder it is to right unit tests for it.
20:35:53 <blackdog> QtPlaty[HireMe]: yeah, it's enough of a pain to test for side-effects that you just don't do it
20:36:09 <pumpkin> or you avoid writing side-effectful code
20:36:10 <hamishmack> I think replacing GTK would be hard.
20:36:11 <dev31212> speaking of...
20:36:17 <pumpkin> it's more driving towards purity than functional though
20:36:26 <dev31212> the net.cgi package
20:36:33 <dev31212> it is very state based
20:36:38 <dev31212> HStringTemplate...
20:36:46 <dev31212> I guess there is no cleaner seperation?
20:38:00 <hamishmack> pumpkin: If you are using a Mac though make sure you install gtk-chtheme and try out some of the other themes
20:38:21 <monochrom> You still want an IDE for explaining type errors, explaining surprising executions (so-called debugging), refactoring. But each of those is way more advanced for Haskell than for mainstream languages, so no one has got around to do them comprehensively.
20:38:22 <Gracenotes> :D
20:38:49 <Gracenotes> monochrom: some static analysis would also be nice
20:39:31 <Gracenotes> with respect to laziness causing memory bloating, minor inefficiencies, 'unsafe' things, etc.
20:40:11 <blackdog> there's hlint
20:40:18 <blackdog> don't know how comprehensive it is
20:40:41 <dev31212> Why doesnt haskell have a truley pro level IDE?
20:40:43 <dev31212> seriously.
20:40:47 <dev31212> all bias aside.
20:40:59 <dev31212> Eclipse plugin just doesnt count.
20:41:13 <blackdog> because they take a lot of effort to produce, and most of the people who could do it would rather make the language better.
20:41:23 <dev31212> ok
20:41:39 <dev31212> Is the perception that haskell is academic?
20:41:42 <dev31212> not really practical?
20:42:00 <monochrom> haskell is 100% academic and 100% practical.
20:42:08 <blackdog> that's 200% awesome!
20:42:09 <dev31212> So far i agree.
20:42:10 <monochrom> 200% added together if you will.
20:42:27 <blackdog> ha. #haskell, where your questions are answered in glorious stereo.
20:42:31 <dev31212> It is fast, from what I see so far, easier to code in..shorter code...less bugs
20:42:31 <dev31212> etc
20:42:32 <loupgaroublond> dev31212, if you use xmonad and a bunch of terminals, you can arrange them like a professional IDE
20:42:59 <dev31212> Im not a IDE dependant person loupgaroublond...
20:43:03 <dev31212> I use scite mostly
20:43:07 <BMeph> Does Erlanf have an IDE, and if so...why? :\
20:43:12 <dev31212> I just like leksah
20:43:13 <BMeph> *Erlang
20:43:33 <inimino> the best programmers I've personally known haven't been IDE people either
20:43:56 <loupgaroublond> dev31212, i mean, the OS is a professional IDE if you use it right, using scite, or any other editor, that's just the editor pane of some other 'professional IDE'
20:44:22 <blackdog> (interesting counterexample would be smalltalk, but it's arguable that in an image-based system it's easier to get information about everything, and smalltalk is a much simpler language than almost every other one...)
20:45:21 <dev31212> true loupgaroublond
20:45:29 <dev31212> I guess I only want one thing.
20:45:35 <dev31212> tracing, not to help me code
20:45:42 <dev31212> you see, often I can make the program right
20:45:48 <dev31212> without 100% understandg it
20:45:52 <dev31212> that is the nature of haskell
20:46:05 <dev31212> so sometimes I wann see the trace, just to help me better understand...
20:46:26 <loupgaroublond> dev31212, if your tracer runs in a terminal (such as gdb), then there you go ;)
20:46:29 <Elly> dev31212: :help in ghci lists the existence of a ':trace' command
20:46:32 <andresj> so im trying to use hoogle to find it, but i cant--- I need a function (better if an operator) IO () -> a -> a that will execute the IO monad before calculating the value of a. is there such a thing?
20:46:33 <loupgaroublond> and emacs will integrate with a tracer for you
20:46:39 <dev31212> oh thanks elly
20:47:36 <cooldude127> is there an easy way to write (\ i -> drop (i+1)) without the lambda?
20:47:49 <andresj> more generally, i need a way to introduce a logger into a pure function. possibly changing the type of the function
20:47:55 <cooldude127> i can't help but feel it's unnecessary
20:47:57 <Elly> drop . (1 +)
20:48:02 <andresj> cooldude127,  drop .(+1)
20:48:07 <andresj> argh, u beat me to it, lol :P
20:48:22 <monochrom> @pl
20:48:22 <lambdabot> (line 1, column 1):
20:48:23 <lambdabot> unexpected end of input
20:48:23 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
20:48:31 <monochrom> @pl \i -> drop (i+1)
20:48:32 <lambdabot> drop . (1 +)
20:48:33 <andresj> @pl \i -> drop (1+i)
20:48:33 <lambdabot> drop . (1 +)
20:48:41 <andresj> LOL
20:48:47 <cooldude127> woah
20:48:56 <cooldude127> really?
20:49:02 <Elly> @pl is cool :)
20:49:02 <lambdabot> (line 1, column 10):
20:49:03 <lambdabot> unexpected ")"
20:49:03 <lambdabot> expecting white space or simple term
20:49:04 <monochrom> No, the computer is not always that smart. Yes.
20:49:05 <Elly> oops
20:49:15 <monochrom> s/Yes/Yet/
20:49:17 <andresj> hahahaha
20:49:43 <mmorrow> @pl \line -> ((line 1, column 10):)
20:49:43 <lambdabot> (:) . flip (,) (column 10) . ($ 1)
20:51:11 <cooldude127> thanks guys
20:51:11 <mhydronic> I'm having trouble coming up with a function to build a tree of the form Leaf Int | Node Tree Tree from two lists whose length differ by at most 1
20:51:22 <dev31212> hmmm
20:51:28 <dev31212> I probably cant help
20:51:34 <mhydronic> should i be trying to build from the bottom up or top down
20:51:42 <dev31212> but I am interested, as my first, non trivial project, was an enhanced BST,,
20:52:17 <dev31212> why is th elength of the list a problem?
20:52:57 <QtPlaty[HireMe]> mhydronic: Why two lists?
20:53:28 <mhydronic> the input is [Int] but it was advised, in order to build a balanced tree (sorry left out the balanced part), to first split the list in half
20:54:03 <QtPlaty[HireMe]> mhydronic: What would you do if your lists where singelton lists?
20:54:31 <dev31212> my Tree is not self balancing :(
20:54:50 <mhydronic> singleton meaning containg only one element?
20:55:01 <QtPlaty[HireMe]> mhydronic: Yep.
20:55:40 <vixey> how do you actually get a good layout from graphviz?
20:55:42 <mhydronic> each element is a leaf
20:55:57 <mhydronic> right/
20:56:04 <monochrom> [3] gives you Leaf 3.
20:56:05 <QtPlaty[HireMe]> Can you right a function for that?
20:56:08 <mmorrow> vixey: there are multiple graphviz programs, each using a different algorithm. so what kind of layout do you want?
20:56:08 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
20:56:19 <vixey> I got a GUI program
20:56:22 <vixey> it sucks :/
20:56:33 <vixey> and it won some design award apparentl
20:56:43 <mmorrow> vixey: hmm. a graphviz gui program?\
20:56:45 <vixey> I guess I can use the command line too though
20:56:53 <vixey> well it's basically a window with a render in it
20:57:23 <mmorrow> vixey: i have a cgi prog i find handy http://moonpatio.com/cgi-bin/graphedit.cgi
20:57:33 <mmorrow> the radio buttons are the different graphviz programs/algos
20:57:45 <mmorrow> dot/neato/fdp/circo/twopi
20:58:10 <mmorrow> the png's are ugly though for some reason, that machine must be missing libs or something
20:58:12 <mhydronic> QtPlaty[HireMe]: i would think something like make xs ys = Node Leaf xs Leaf ys
20:58:21 <vixey> oh circo is pretty good
20:58:38 <QtPlaty[HireMe]> Almost.
20:59:13 <QtPlaty[HireMe]> make (x:[]) (y:[]) = Node (Leaf x) (Leaf y)
20:59:16 <mmorrow> vixey: yeah, depending on the graph and whether it's directed or not, usually one of the progs is a clear win
20:59:32 <vixey> hehe The requested URL's length exceeds the capacity limit for this server.
20:59:40 <monochrom> haha
20:59:40 <vixey> I tried with a bigger graph
20:59:54 <pumpkin> mmorrow: nice, oh my, you need graphviz in js now
21:00:05 <mmorrow> vixey: hehe
21:00:12 <vixey> I think we can have a better graph layout algorithm than graphviz
21:00:18 <pumpkin> yeah
21:00:25 <vixey> it doesn't even look for patterns in the graph
21:01:06 <mmorrow> @seen TomMD
21:01:06 <lambdabot> I saw TomMD leaving #haskell, #xmonad, #ghc and #haskell-blah 6m 39s ago, and .
21:01:10 <mhydronic> QtPlaty[HireMe]: i'm guessing there will be a case similar to make ... = Node (make ..) (make ..) ?
21:01:13 <mmorrow> preflex: seen TomMD
21:01:13 <preflex>  TomMD was last seen on #haskell 37 minutes and 43 seconds ago, saying: instance GiddySchoolGirl (Man LBS300) where ...
21:01:24 <QtPlaty[HireMe]> mhydronic: Exactly.
21:01:48 <fynn> what's with the Haskell hate on this guy? http://fpmatters.blogspot.com/2009/04/haskell-still-very-difficult-to-write.html
21:01:57 <QtPlaty[HireMe]> You would part your list into two halves and pass it into your makes.
21:02:45 <mhydronic> hmm.. ok, thanks. lemme think on it for a bit.
21:03:22 <vixey> this is my awful graph http://img16.imageshack.us/img16/3459/picture19u.png
21:03:34 <vixey> completely unreadable :/
21:03:39 <mmorrow> holy crap
21:04:00 <QtPlaty[HireMe]> Basic rule when dealing with recursive algorthums, think of the most simple case.  Think of how to reduce the general case towards the simple case.
21:04:02 <mmorrow> vixey: oh yeah, so one trick to readability is to pipe the .dot through "tred" first
21:04:19 <mmorrow> vixey: it computes the transitive reduction
21:04:22 <vixey> transitive reduction filter
21:04:53 <Cale> fynn: I think it's possible that blog is written by a particular troll.
21:05:02 <Cale> fynn: He's rather subtle :)
21:05:04 <mmorrow> it would probably do wonders for that particular graph i'd imagine
21:05:12 <Berengal> Cale: Not really...
21:05:34 <vixey> I think I just got to give up on visualizing these graphs
21:05:40 <Cale> Berengal: Not really subtle, or not really written by a troll? :)
21:05:42 <mhydronic> QtPlaty[HireMe]: if a list is a singleton list, will the pattern x:xs work? i.e. xs = [] ?
21:05:48 <Berengal> Cale: Not really subtle
21:05:56 <mmorrow> vixey: i'd be interested to see that graph post-tred
21:06:09 <Cale> Well, I mean, his position *looks* reasonable to the uninformed.
21:06:21 <vixey> warning: has cycle(s), transitive reduction not unique
21:06:22 <QtPlaty[HireMe]> mhydronic: Yes.
21:06:31 <mmorrow> vixeyL yeah, just ignore that :)
21:06:34 <Berengal> mhydronic: A singleton list still has a : in it (a:[]). As long as it does, you can pattern match on it
21:07:59 <cooldude127> is it generally favored in haskell to use (.) over ($) when either works?
21:08:08 <Cale> cooldude127: yeah
21:08:23 <cooldude127> i thought so. i'm glad it was yes, i just did it to a bunch of code
21:08:28 <Cale> cooldude127: Generally, compose functions with (.), then apply the composite with ($)
21:08:33 <cooldude127> ok
21:08:38 <cooldude127> i've been doing that
21:08:50 <vixey> mmorrow that's the tred http://img10.imageshack.us/img10/8489/picture20wvh.png
21:08:51 <Cale> The nice thing about using (.) is that it's associative, which is to say that (f . g) . h = f . (g . h)
21:08:59 <dev31212> . is ledt
21:09:01 <dev31212> left
21:09:02 <dev31212> $ is right
21:09:05 <dev31212> yes?
21:09:07 <Cale> no...
21:09:08 <mmorrow> vixey: these are my default style-sdettings http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2177#a2177
21:09:10 <Gracenotes> :?
21:09:14 <dev31212> ok, shot in the dark
21:09:14 <Cale> they have different types
21:09:24 <Cale> (.) is function composition
21:09:25 <mmorrow> vixey: rankdir and splines make a big difference
21:09:27 <dev31212> I use $ all the time
21:09:32 <dev31212> havent had a need for (.) yet
21:09:34 <Cale> (f . g) x = f (g x)
21:09:37 <dev31212> yeah
21:09:42 <mmorrow> vixey: rankdir `elem` [TB,LR,RL,BT]
21:09:51 <dev31212> I remember that from calc
21:09:54 <Cale> ($) is function application
21:09:54 <mmorrow> vixey: ooh, awesome!
21:09:58 <Cale> f $ x = f x
21:10:01 <mmorrow> tred++
21:10:06 <dev31212> ok
21:10:07 <Cale> But $ has really low priority/precedence
21:10:14 <dev31212> yeah differnt precedence
21:10:16 <dev31212> yeah, sorry
21:10:17 <vixey> mmorrow: the tred doesn't really make sense though
21:10:23 <dev31212> I just was hoping to make a guess and sound profound
21:10:24 <dev31212> :p
21:10:28 <Cale> The funny thing (which I consider a mistake) about ($) is that it associates to the right.
21:10:30 <vixey> you can't just take the transitive closure of my graph
21:10:45 <Cale> Whereas normally, function application associates to the left
21:10:48 <dev31212> Saves keypressed
21:10:48 <mmorrow> vixey: yeah, sometimes the tred erases some semantic content
21:10:51 <dev31212> keypresses
21:10:56 <dev31212> I thought that was its only use.
21:10:59 <dev31212> Less Parens...
21:11:03 <mmorrow> vixey: it's mostly only useful with directed graphs i guess
21:11:04 <dev31212> so you dont have to be lisp-like
21:11:11 <cooldude127> Cale: isn't associating to the right the whole point of $?
21:11:16 <Cale> cooldude127: no :)
21:11:21 <Gracenotes> > map (head &&& length) . group . sort $ "greetings everyone"
21:11:22 <lambdabot>   [(' ',1),('e',5),('g',2),('i',1),('n',2),('o',1),('r',2),('s',1),('t',1),('...
21:11:23 <vixey> this sucks, It's just too complex to deal with
21:11:24 <QtPlaty[HireMe]> dev31212: Thats mostly its use.
21:11:31 <mmorrow> vixey: (at least it looks pretty ;)
21:11:32 * gigamonkey is annoyed at Real World Haskell for not explaining $
21:11:33 <dev31212> ok :)
21:11:34 <Cale> It's the low precedence. After all, you can always rewrite f $ g $ h $ x as f . g . h $ x
21:11:53 <cooldude127> Cale: i'm working on doing that in my code at the moment
21:11:53 <Cale> (and the latter is preferable)
21:11:56 <dev31212> giga
21:12:02 <mmorrow> vixey: yeah, maybe if you manually split out subgraphs-of-interest
21:12:05 <dev31212> Do a Haskell for a Great Good is the best:)
21:12:09 <inimino> $ seems to be rarely used where its associativity would be relevant
21:12:11 <ray> RWH doesn't explain $? i guess i didn't notice because i already knew about it
21:12:21 <gigamonkey> ray: unless I missed it.
21:12:25 <dev31212> When that guy finally comes up with a Monad tutorial, I might go gay and marry him
21:12:28 <dev31212> j/k
21:12:32 <ray> maybe you missed it because you already knew about it
21:12:41 <ray> one of us did!
21:12:43 <Cale> I'd actually prefer it if $ associated to the left. We'd be able to remove parens from even more expressions
21:12:47 <gigamonkey> The index entry points to page 248 which doesn't really explain it.
21:13:03 <dev31212> Cale, exmplae please.
21:13:05 <dev31212> example*
21:13:12 <Cale> For example, things like  f (g x) (h x y) (k z)
21:13:14 <inimino> Cale: I agree.
21:13:24 <Cale> Could be written  f $ g x $ h x y $ k z
21:13:48 <Cale> if $ associated to the left
21:13:48 <dev31212> what of the ubiquitous IO monad expressions
21:13:52 <dev31212> that make great use of $
21:14:00 <Cale> Like what?
21:14:01 <dev31212> you'd lose that sugar, no?
21:14:06 <mmorrow> vixey: what's that graph of btw?
21:14:08 <Cale> It wouldn't affect much.
21:14:09 <gigamonkey> ray: I only vaguely know about it. Enough to not bother looking it up but not enough not to be annoyed every time they use it.
21:14:18 <inimino> dev31212: usually only one of them is used, right
21:14:20 <dev31212> ok.... main - putStrLn $ foo x $ bar 9 19
21:14:20 <inimino> ?
21:14:21 <pumpkin> ?
21:14:23 <dev31212> I just see them everywhere
21:14:31 <pumpkin> dev31212: most people don't use that
21:14:34 <Cale> main = putStrLn . foo x $ bar 9 19
21:14:42 <dev31212> ok
21:14:46 <dev31212> so use composition instead
21:14:46 <mmorrow> vixey: the tred is neat (visually)
21:14:47 <dev31212> gotcha
21:15:13 <mmorrow> pumpkin: what did you mean by "you need graphviz in js now"?
21:15:23 <ray> i understand $ but i suck at the general concept of infix operators
21:15:33 <vixey> mmorrow: http://rafb.net/p/moUOKQ17.html
21:15:35 <pumpkin> mmorrow: an interactive graph layout system in pure js for web-based fun :D
21:15:39 <gigamonkey> Does RWH seem to be bringing in new Haskellers? (Haskellites?)
21:15:54 <mmorrow> pumpkin: heh
21:15:59 <ray> someone besides me bought a copy at my local bookstore
21:16:01 <mmorrow> vixey: neat
21:16:26 <Cale> gigamonkey: Would you like me to explain $?
21:16:33 <vixey> mmorrow: not really sure what I best do now though
21:16:44 <vixey> the complexity it too big
21:16:56 <gigamonkey> Cale: nah. I basically get it. And if I ever need to really grok it deeply, I'll find a tutorial that covers it.
21:17:04 <mmorrow> vixey: you should read the dot manual and look at the gallery on graphviz.org
21:17:22 <mmorrow> vixey: i think you might be able to get something useful with ranks maybe
21:17:30 <vixey> mmorrow: for this thing!! http://img16.imageshack.us/img16/3459/picture19u.png
21:18:07 <pumpkin> gigamonkey: Cale is the best tutorial out there
21:18:10 <Cale> gigamonkey: It's really just defined as  f $ x = f x  but its precedence is such that it "happens last", as if its parameters on the left and right are enclosed in parens.
21:18:11 <pumpkin> and he's interactive
21:18:31 <mmorrow> vixey: like this one maybe http://graphviz.org/Gallery/directed/world.html
21:18:46 <gigamonkey> Cale: so the magic happens in 'infix' declaration?
21:18:50 <mmorrow> vixey: haha, maybe not (but maybe)
21:18:50 <drhodes> it'd be cool to see a chart of #haskell population before and after RWH was released.
21:18:51 <Cale> gigamonkey: yeah
21:19:08 <ray> @users
21:19:22 <mmorrow> vixey: maybe circo or twopi also
21:20:15 <mmorrow> vixey: http://graphviz.org/Gallery/directed/world.gv.txt
21:20:25 <mmorrow> "{rank=same; S8 S24 S1 S35 S30;}"
21:22:14 <mmorrow> vixey: but yeah, it would be cool if there were other graph layout options (i was going through the graphviz code yesterday and it's horrifying)
21:22:50 <vixey> graphviz impl. is pretty nasty, unless you're a C programmer doing idiomatic C the lib falls apart really low quality
21:23:02 <lambdabot> Maximum users seen in #haskell: 658, currently: 588 (89.4%), active: 19 (3.2%)
21:23:37 <vixey> I'm well disappointed though, I have no idea what to do now
21:24:21 <mmorrow> vixey: let me know if you come up with something that works :)
21:24:23 <pumpkin> there doesn't seem to be much in the way of good graph layout libraries out there
21:24:36 <pumpkin> I've spent time looking
21:24:46 <mle> while you're at it see about making a pure-functional reimplementation of TeX, eh?
21:24:53 <mmorrow> pumpkin: yeah. although there are a few papers on the graphviz website, so the info is out there
21:25:03 <pumpkin> yeah
21:25:52 <mmorrow> this is interesting http://www.research.att.com/areas/visualization/papers_videos/abstract.php?id=DBLP-conf-infovis-GansnerKN04
21:26:08 <mmorrow> (linked to from http://graphviz.org/Documentation.php)
21:26:33 <pumpkin> oh yeah, IDA has something like that
21:26:53 <pumpkin> oh, maybe not that sophisticated :P
21:32:48 <Gracenotes> <3
21:35:17 <andresj> what type signature would make sense for a median function that also logs its procedures? Fractional a => [a] -> IO a doesnt seem right to me because the result will never change. maybe ... -> (a, IO ()) ?
21:35:19 <vixey> andresj:  [a] -> Logger a
21:35:27 <andresj> lol really?
21:35:30 <vixey> yes
21:35:45 <vixey> andresj: But you are to define Logger
21:35:48 <andresj> lol, i thought Logger was a type, not a class
21:35:55 <andresj> i mean, the one in System.Log
21:35:57 <vixey> ???????????????
21:36:38 <andresj> lol, well i thot that was the standard logging package, hslogger
21:37:10 <vixey> lol
21:37:45 <sizur> i have an unrelated question: how does an email client know what encoding to use for the Subject header?
21:37:48 <Gracenotes> Writer [] blah blah O(n^2) performance DLists blah
21:37:59 <Gracenotes> :3
21:38:18 <andresj> lol, thankfully i took a few hours to read about big O notation and stuff :P
21:38:24 <andresj> in Wikipedia, of course
21:38:35 <mhydronic> QtPlaty[HireMe]: if data Tree = Leaf Int | Node Tree Tree, does that mean only external leaves will have values?
21:38:51 <QtPlaty[HireMe]> mhydronic: Yes.
21:39:08 <andresj> vixey: logger would a class, right? a class that is a Monad.
21:39:15 <Cale> Gracenotes: Writer [] really should have linear performance, supposing that the lists that you write with each tell are not very long.
21:39:20 <sclv> sizur: i'd imagine that the choice of encoding is ad-hoc?
21:39:22 <vixey> mhydronic: you should use  data Tree a = Leaf a | Node (Tree a) (Tree a)  instead
21:39:56 <Gracenotes> Cale: I'd imagine a strict list mappend would not have that property, though.
21:40:04 <mhydronic> vixey: i would if i could. the exercise requires that other structure
21:40:14 <vixey> the exercise is stupid
21:40:19 <mhydronic> agreed
21:40:57 <sizur> sclv: so you mean it tries to guess what your input is encoded into?
21:41:07 <Cale> Gracenotes: (++) is linear in the length of its first argument, so if things are associated to the right, and the individual lists are of bounded length, then it's nicely linear.
21:41:26 <sclv> sizur: yep. there's lots of that gunk in the edges of various protocols.
21:41:48 <Gracenotes> Cale: wouldn't that only apply to Dual []?
21:41:51 <mhydronic> QtPlaty[HireMe]: i think i may have it. could you look it over for me? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2179
21:41:56 <Cale> Gracenotes: hm?
21:42:54 <Gracenotes> Cale: whenever you tell, it's mappend'd as the second argument
21:43:17 <QtPlaty[HireMe]> That isn't going to get you your balanced tree.
21:43:40 <Cale> Gracenotes: Writer gets you a right-associated bunch of mappends of all the tells'
21:43:46 <QtPlaty[HireMe]> QtPlaty[HireMe]: Most of its right but for your last bit.
21:44:16 <QtPlaty[HireMe]> Last line.
21:44:19 <Gracenotes> Cale: and if mappend is strict... this property won't hold, I take it?
21:44:29 <Cale> I don't get what you mean
21:44:37 <mhydronic> it seems to be working
21:44:41 <Cale> (++) is strict in its first argument
21:45:01 <Cale> Even if it's strict in both, it'll be right associated.
21:45:01 <mhydronic> can you think of an example that would result in an unbalanced tree?
21:45:03 <pumpkin> > take 10 $ [1..10] ++ undefined
21:45:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:45:29 <Gracenotes> how does right association make it efficient, then?
21:45:46 <pumpkin> saves you from adding to an ever-longer list each time
21:46:05 <QtPlaty[HireMe]> List of more then 4 elements.
21:46:12 <Cale> [1] ++ ([2] ++ ([3] ++ ...))
21:46:15 <Cale> is linear time
21:46:50 <Gracenotes> if it's strict, I mean.. not in the sense of _|_, but in terms of being fully evaluated
21:46:56 <Gracenotes> e.g. seq
21:46:58 <Cale> ?
21:47:03 <Cale> I don't get what you mean.
21:47:06 <Gracenotes> which would force left-association, I think. :\
21:47:13 <pumpkin> no?
21:47:22 <Cale> No, left/right association is totally separate from strictness
21:47:38 <Gracenotes> so: a mappend b = let q = a++b in q `seq` q
21:47:43 <Cale> It's about how the expression is built up in the first place, not how it's evaluated.
21:47:46 <Gracenotes> this would still be right associative?
21:48:01 <pumpkin> q `seq` q ?
21:48:02 <Cale> First of all,  q `seq` q  is always equivalent to q
21:48:03 <sjanssen> Gracenotes: q `seq` q = q
21:48:03 <pumpkin> doesn't do much
21:48:08 <QtPlaty[HireMe]> Anyway i'm ogg.
21:48:10 <QtPlaty[HireMe]> off
21:48:15 <pumpkin> vorbis!
21:48:26 <guenni> is there a limit for tuples, say 19 maybe?
21:48:30 <Gracenotes> fine. rnf q `seq` q, then? >_<
21:48:43 <pumpkin> lol, it happens by the nature of ++, not explicitly
21:49:02 <sjanssen> guenni: there are various limits related to tuples
21:49:12 <pumpkin> I think it's in the 60-something range isn't it?
21:49:18 <Gracenotes> okay, but to what extent *is* its efficiency implicit. Just the way ++ is defined?
21:49:24 <guenni> sjanssen: such as?
21:49:28 <mhydronic> ok, thanks for your help
21:49:41 <Cale> guenni: Yes, there is a limit, but if your tuples are any larger than 3 or 4 elements, it's probably time to create your own datatype.
21:49:57 <Cale> Gracenotes: Efficiency has to do with the way (++) is defined
21:50:03 <Cale> [] ++ ys = ys
21:50:10 <Cale> (x:xs) ++ ys = x : (xs ++ ys)
21:50:22 <pumpkin> <3
21:50:33 <Cale> This never pattern matches on ys, and hence its performance cannot depend on the length of ys
21:50:38 <guenni> I'm saying this because I use haskelldb and it blows when the "table" I construct is larger than 19 fields
21:50:45 <mhydronic> QtPlaty[HireMe]: how did you know a list of more than 4 would give incorrect tree?
21:50:46 <Gracenotes> okay. so, if appending like this is right-associative, then why do we have difference lists?
21:50:49 <guenni> the table type is a recurisve *type
21:51:06 <Cale> Gracenotes: Because if you append in the opposite direction, then you have problems.
21:51:17 <Cale> Gracenotes: But the Writer monad will not do that.
21:51:31 <guenni> so what woud be the max size for a tuple?
21:51:35 <Gracenotes> hm? with difference lists, you're just repeatedly adding stuff onto the end -- doesn't Writer do this?
21:52:33 <Cale> When you 'tell' something, you're adding something to the *beginning* of the *remainder* of the tells which will occur.
21:53:40 <guenni> cale: can you tell me what the limit is?
21:54:05 <Gracenotes> beginning in what sense :\
21:54:12 <sjanssen> guenni: the blow up is probably related to haskelldb limitations
21:54:29 <Cale> guenni: Hmm, I think it's around 64 for GHC, but the instances of various classes are only present for smaller ones.
21:54:47 <sjanssen> guenni: GHC supports tuples in the hundred range, and has standard class instances for smaller ones
21:55:04 <sjanssen> guenni: does haskelldb use Eq, Read or Show?
21:55:05 <mle> would adding a pattern like xs ++ [] = xs do anything other than improve performance in that one case (provided you don't mind choking on ys being _|_)?
21:55:06 <guenni> sjanssen: now that would be a damn shame, because it worked so fine
21:55:21 <shachaf> Is anyone in here planning to go to http://linuxfestnorthwest.org/ this weekend?
21:55:22 <guenni> sjanssen: don't know for sure
21:56:11 <guenni> sjanssen
21:56:32 <guenni> sjanssen: it propably does
21:56:40 <dev31212> hmmm
21:56:50 <dev31212> dont most things use Read and Show?
21:57:20 <dev31212> , commands
21:57:22 <lunabot>  luna: Not in scope: `commands'
21:57:27 <dev31212> ,?
21:57:28 <lunabot>  luna: Not in scope: `?'
21:57:30 <dev31212> ,help
21:57:33 <lunabot>  type of an expression:      , [$ty| \x -> x |]
21:57:33 <lunabot>  get info for a type/class:  , src ''Monad
21:57:33 <lunabot>  get info for a var/con:     , src 'fix
21:58:01 <dev31212> ,[let x = 10]
21:58:02 <lunabot>  luna: parse error on input `]'
21:58:08 <dev31212> hmm..
21:58:17 <inimino> note the space
21:58:27 <dev31212> oh
21:59:05 <inimino> , [1..10]
21:59:07 <lunabot>  [1,2,3,4,5,6,7,8,9,10]
21:59:56 <Cale> Gracenotes: http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2181#a2181
22:00:06 <mmorrow> vixey: maybe reorganize the data someway, then graph subsets or something http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2177#a2180
22:00:11 <Cale> Gracenotes: have a look at that program and then evaluate 'test'
22:01:20 <Cale> Gracenotes: I'm having it discard the cases where there was an mappend and one of the two was empty
22:01:41 <mmorrow> , [let x = 10]
22:01:42 <lunabot>  luna: parse error on input `]'
22:01:46 <mmorrow> , [let x = 10 in x]
22:01:47 <lunabot>  [10]
22:01:59 <Cale>     mappend Empty   (Foo y) = Foo (concat ["([] ++ ",y,")"])
22:02:06 <Cale> er
22:02:18 <Cale> no, it's the other case we're interested in...
22:03:08 <mmorrow> , $(tupE (fmap lift [0..64::Int]))
22:03:10 <lunabot>  luna: A 65-tuple is too large for GHC
22:03:11 <Cale>     mappend (Foo x) Empty   = Foo (concat ["(",x,"++[])"])
22:03:14 <mmorrow> , $(tupE (fmap lift [0..63::Int]))
22:03:15 <lunabot>  luna: A 64-tuple is too large for GHC
22:03:17 <mmorrow> , $(tupE (fmap lift [0..62::Int]))
22:03:19 <lunabot>  luna: A 63-tuple is too large for GHC
22:03:21 <mmorrow> , $(tupE (fmap lift [0..61::Int]))
22:03:22 <lunabot>  luna: No instance for (GHC.Show.Show
22:03:47 <Gracenotes> and if it yielded (((((((((x++x)++x)++x)++x)++x)++x)++x)++x)++x) (switching the two), would it be inefficient?
22:03:53 <Cale> yes
22:03:57 <mmorrow> just reverse
22:04:04 <Cale> It would be quadratic then
22:04:08 <mmorrow> then you get O(n) back
22:04:27 <Cale> mmorrow: But it's unnecessary, since Writer doesn't do that
22:04:37 <mmorrow> oh, i don't know the context here
22:05:04 <Gracenotes> I suppose it's a matter of requesting the next element of the list, and requiring the minimal amount of work to get it
22:05:18 <mmorrow> guenni: the tuple limit is 62
22:05:35 <guenni> thx
22:05:48 <Gracenotes> well, you can do :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
22:05:58 <mmorrow> , $(tupE (fmap lift [0..62::Int]))
22:05:59 <lunabot>  luna: A 63-tuple is too large for GHC
22:06:12 <Gracenotes> there are no instances for it, though
22:06:26 <Cale> Gracenotes: compare the performance of  foldl (++) [] (replicate 100000 "a")  with the same using foldr
22:06:31 <mmorrow> you can make an arbitrary size *type* for a tuple
22:06:38 <mmorrow> but not a value
22:07:05 <Gracenotes> Cale: yes, I'm familiar with it in a foldl/foldr sense
22:07:31 <Cale> It's similar here, Writer is effectively a big foldr sort of thing :)
22:07:37 <Gracenotes> I suppose the same is true for mappend application. Then I'm not sure why different lists are so useful >_>
22:07:58 <Cale> DLists are only useful if you have to work around unavoidable left association.
22:08:25 <Cale> So they're not particularly useful with Writer
22:09:08 <Cale> But if you're, say, making an inorder traversal of a tree, then they're useful, because the tree might lean left and ruin your performance.
22:09:27 <Cale> Though, I never actually use the DList library myself
22:09:32 <Cale> I just use functions
22:09:33 <Gracenotes> okay. That's all well and good, but there's still the fact that cons-ing tends to be more efficient than snoc-ing for singly linked lists :) I'm confuzzlingly tired, but it seems paradoxical
22:09:45 <Cale> It is more efficient
22:09:45 <Gracenotes> s/but/and/
22:09:50 <Cale> because you can share the tail
22:10:39 <Cale> If ys = x : xs, then ys can consist of a single cons cell which points to x and to xs, and the memory for the tail of ys and xs is the very same memory.
22:11:07 <Cale> But if ys = xs ++ [x], then you need to start allocating new cons cells.
22:11:13 <Cale> (for ys)
22:11:50 <guenni> mmorrow: it was a problem with the size of the context stack
22:11:55 <Cale> because the tails of ys are not likely going to match any tails of xs
22:12:04 <Cale> so the memory can't possibly be shared
22:12:08 <Gracenotes> hm. Well, I suppose repeated mappend-ing does allocate the cons cells, but you're going to traverse the list anyway
22:12:34 <Cale> It doesn't allocate them over and over, which is the only real problem.
22:12:41 <Gracenotes> and the head of the resulting list can be easy accessed, since it's the first argument
22:13:12 <Cale> Right, if you have  (x:[]) ++ ys, this reduces in one step to x : ([] ++ ys)
22:13:36 <Cale> at which point your pattern match to get the head will succeed
22:15:18 <Gracenotes> hm. Makes a bit more sense. I don't know where I recall hearing that Writer for lists is inefficient, then.
22:15:49 <Cale> Possibly someone who was mistaken about what order it would mappend things in.
22:16:28 <Cale> I suppose it's also a bit worrying if the lists which you 'tell' are potentially very long.
22:16:41 <Cale> mm... not that worrying really
22:17:11 <Cale> actually, right, that's not a problem at all
22:17:22 <Gracenotes> "Differences lists: a list-like type supporting O(1) append. This is particularly useful for efficient logging and pretty printing, (e.g. with the Writer monad), where list append quickly becomes too expensive."
22:17:41 <Cale> heh, no idea :)
22:17:58 <Cale> I promise you that I did not write that :)
22:18:39 <Gracenotes> of course {_{
22:18:47 <Berengal> Wait, difference lists like in prolog?
22:19:22 <sjanssen> Cale: the concern is when the 'told' lists are very long
22:19:49 <Gracenotes> Berengal: http://hackage.haskell.org/packages/archive/dlist/0.4.1/doc/html/src/Data-DList.html
22:20:06 <Cale> sjanssen: even then, it won't be too much of a problem.
22:20:23 <Gracenotes> I have a confession... I snoc when no one's watching. ;_;
22:20:50 <sjanssen> Cale: I think we can probably come up with an example that's asymptotically worse
22:20:51 <Cale> Berengal: It's just replacing lists with functions that append to the beginning of other lists
22:21:13 <Cale> Berengal: concatenation becomes composition, so it's O(1)
22:21:34 <Cale> sjanssen: I suppose you pay for your concatenations, but you have to pay to construct your long lists anyway
22:21:37 <Berengal> Cale: Right, so not quite the prolog kind then
22:21:44 <Cale> sjanssen: So I suspect it's at worst a constant factor
22:21:58 <sjanssen> Cale: yeah, I can't think of anything worse than a constant factor
22:22:04 <sjanssen> Cale: but those can matter, y'know
22:23:26 <Berengal> Surprisingly, constant factors aren't always constant...
22:23:48 <dobblego> dons, (or anyone) ever heard of the protium language?
22:24:18 <sjanssen> Cale: the pathological example is replicateM_ (tell longlist), where longlist can be shared
22:25:33 <British0zzy> Hi, unix-2.3.2.0 fails to build on my computer.
22:26:08 <sjanssen> British0zzy: I think that might be one of those packages you aren't supposed to upgrade
22:26:34 <British0zzy> hmmm, cabal upgrade seems to do it automatically
22:26:53 <sjanssen> British0zzy: and
22:26:59 <British0zzy> is it built into GHC?
22:27:05 <sjanssen> 'cabal upgrade' is one of those commands you aren't supposed to run :)
22:27:06 <blackdog> British0zzy: don't cabal upgrade :/
22:27:18 <British0zzy> oh
22:27:22 <blackdog> only need to get burned by that once
22:27:27 <sjanssen> British0zzy: it'll break stuff, avoid it like the plague
22:27:39 <Berengal> Last I checked, cabal upgrade doesn't do anything except tell you which packages is out of date...
22:27:41 <Heffalump> I think it's been disabled in more recent releases
22:27:49 <blackdog> when you end up with half your libraries depending on process-1.0.1.0 and the other half on process-1.0.1.1
22:27:57 <blackdog> you will hate your life and curse the haskell gods.
22:28:13 * blackdog exaggerates, but only recreationally
22:28:42 <British0zzy> what's the best way to stay up to date with the latest releases?
22:29:23 <sjanssen> blackdog: you don't exaggerate much.  GHC/Cabal's story for version compatibility is really really bad
22:29:25 <Heffalump> hackage
22:29:29 <Heffalump> i.e. use cabal install cabal-install
22:29:59 <sjanssen> British0zzy: hackage's RSS feed, then: cabal install 'widget > 2.1.4'
22:30:38 <British0zzy> alright, sounds good. thanks
22:32:32 <British0zzy> how can i get cabal to list the installed packages?
22:34:30 <blackdog> ghc-pkg list
22:36:04 <Gracenotes> yay, I just added "kill it with fire" as a legitimate comment to a piece of code :D
22:36:44 <Berengal> Gracenotes: Context?
22:37:20 <vininim> fireball monad
22:37:43 <Berengal> Needs more fireball, always...
22:37:47 <Gracenotes> one of those Java OOP things. There two were classes already for rabbits and foxes, which interacted on a 2D grid, population dynamics. We were required to add another class, so I made a fire that spreads and kills everything in its path
22:38:35 <Berengal> Fire wins?
22:38:40 <Gracenotes> the fire doesn't stick together... just moves in random directions
22:38:48 <blackdog> heh. reckon you could add a thermonuke class? Then you could take off and nuke it from orbit...
22:39:04 <inimino> kill Java OOP with fire?
22:39:07 <Gracenotes> Berengal: well, it does, so I have a MAX_FIRES field to prevent that
22:39:20 <Gracenotes> of course I could just adjust the percentages
22:39:26 <Gracenotes> hm... *tries that*
22:39:44 <Berengal> Gracenotes: MAX_FIRES = ~0; I hope...
22:39:54 <Berengal> No wait
22:40:06 <Berengal> Why do I always make these mistakes?
22:40:18 <Berengal> More importantly, why doesn't java have unsigned numbers?
22:40:33 <British0zzy> hmmm, I seem to be getting a build failure with the cabal-install-0.6.2 package
22:41:14 <Ralith> hay guys
22:41:19 <Ralith> can mueval run unsafe code?
22:41:23 <Gracenotes> the main problem is when the rabbits start overpopulating, then the fire *really* takes off
22:41:27 <Ralith> if asked to by the program author, that is
22:41:31 <British0zzy> is there a clean way of destroying all hackage packages and reinstalling them?
22:42:07 <Ralith> Berengal: java doesn't have unsigned numbers?
22:42:08 <Ralith> dear god
22:43:49 <divs> oh no this is like pandora's box for me. :(  i hate java so much
22:44:04 <Ralith> then answer my mueval question instead ^^
22:44:11 <divs> try writing code to communicate with a C client over the network where the C client relies on unsigned numbers
22:44:19 <Ralith> I'd rather not
22:44:36 <divs> (i have no idea about the answer to your question btw)
22:45:04 <Ralith> distract yourself by researching it for me :]
22:45:23 <divs> i'm working on a neural network at the moment :(
22:45:28 <vixey> o_o
22:45:35 <vixey> that's crazy I didn't know that about unsigned
22:45:42 <Ralith> distract the neural network by having it research it for me :]
22:45:49 <Ralith> then sneak in and destroy its memory cores.
22:45:50 <Berengal> char is unsigned, but that doesn't help much...
22:45:50 <dobblego> char is unsigned
22:45:55 <mmorrow> guenni: ah yeah, with haskelldb right? you can set the context stack (and need to for haskelldb-generated modules) ==> -fcontext-stack=N
22:46:08 <mmorrow> 20 is the default
22:46:28 <mmorrow> , nesty $(nat 19) (:[]) 42
22:46:30 <lunabot>  luna: Context reduction stack overflow; size = 20
22:47:10 <dolio> How big are chars in Java? I forget.
22:47:16 <Berengal> dolio: 16 bits...
22:47:17 <dobblego> 2^16
22:47:33 <guenni> mmorrow: thx I've found out how to redirect the error output and then I could read what to do
22:47:50 <guenni> mmorrow: are you using haskelldb too?
22:48:15 <mmorrow> guenni: i have at various points
22:48:39 <guenni> mmorrow: I love it! wish I had discovered it sooner
22:49:20 <mmorrow> i like it for generating modules which nicely specify a DB, and for its nice SQL prettyprinting, but for actual queries it's somewhat limiting
22:49:59 <mmorrow> for instance, suppose you need to do multiple levels on nested selects, each of which do joining and group by multiple cols
22:50:05 <mmorrow> you can't
22:50:13 <mmorrow> s/on/of/
22:50:43 <mmorrow> guenni: yeah, i really like the concept of it
22:51:19 <guenni> mmorrow: the project I'm working on got more and more complicated, I can't handle the Sql by hand anymore
22:51:21 <Berengal> Is it possible to persist closures?
22:52:06 <mmorrow> guenni: nice. yeah, sql can get totally out of hand quick
22:52:54 <mmorrow> Berengal: do you mean in the sense that the runtime system takes care of everything for you? (no)
22:53:10 <mmorrow> Berengal: but you can do essentially that yourself pretty easily
22:53:20 <Berengal> mmorrow: How do you mean?
22:53:23 <mmorrow> like, say with a Data.Map + Data.Binary or something
22:53:49 <mmorrow> slash, some datatype + Data.Binary
22:54:40 <Berengal> ... how exactly would that work?
22:55:00 <mmorrow> Berengal: what are you trying to persist in particular?
22:55:13 <Berengal> Nothing at the moment, I'm just curious about the idea
22:55:16 <mmorrow> ah
22:56:08 <mmorrow> well, say you have (data Info = Info {this :: [Int], that :: IntMap (Tree (Sequence (Double, Maybe Int)))})
22:56:11 <Berengal> I have this vague idea about building an EDSL for a business-app I'm working on. I'll never be able to do it, of course, but it's interesting as a what-if scenario
22:56:15 <harovali> hi, isn't it a bug that 'words' is not part of what http://haskell.org/hoogle/?hoogle=String+-%3E+[Strings]&start=21#more   yields ?
22:56:22 <mmorrow> then just create an (IntMap Info)
22:56:33 <mmorrow> and use Data.Binary.encode on it
22:56:40 <mmorrow> then write that to disk
22:56:50 <mmorrow> @type encode
22:56:51 <lambdabot> Not in scope: `encode'
22:56:55 <mmorrow> @hoogle encode
22:56:55 <lambdabot> package Encode
22:56:56 <lambdabot> Prelude encodeFloat :: RealFloat a => Integer -> Int -> a
22:56:56 <lambdabot> package bencode
22:57:12 <harovali> Berengal could you describe your would-be goal in that scenario ?
22:57:21 <mmorrow> encode :: (Binary a) => a -> Data.ByteString.Lazy.Internal.ByteString
22:57:21 <Berengal> mmorrow: So you still have to identify the parameters of the closure yourself?
22:57:39 <mmorrow> Berengal: yeah, you'd need to create a datatype
22:57:41 <Berengal> harovali: It's a task-tracker for the IT department of sorts
22:58:04 <mmorrow> it's not like scheme, where the runtime system will handle it for you
22:58:14 <Berengal> The goal would be to be able to describe the different tasks' flowstructure in an EDSL
22:58:15 <mmorrow> (it could be)
22:58:26 <Berengal> mmorrow: It should be...
22:58:37 <mmorrow> that would be nice :)
22:58:55 <Berengal> Someone should go apply science to it...
23:00:24 <mmorrow> "I'll never be able to do it, of course, but it's interesting as a what-if scenario"
23:00:31 <mmorrow> self-defeating statements--
23:00:35 <mmorrow> :)
23:01:39 <Berengal> mmorrow: I'm working there as an intern. When my mentor asked me to get started on migrating the old db, I said I could probably do it easily in jython...
23:02:09 <Berengal> He wouldn't let me. Java is the only language...
23:02:17 <Berengal> I very much doubt he'd allow Haskell :(
23:02:52 <mmorrow> well, then all you have to do is write your edsl in haskell, then quit, start your own thing, profit!
23:03:05 <mmorrow> ;)
23:03:20 <Berengal> mmorrow: That's the plan :)
23:04:10 <Berengal> mmorrow: The only hitch is the ??? you left out before profit ;)
23:05:00 <mjrosenb> is there any way of using a type synonym that has kind *->* as an argument to a type with kind (*->*)->*?
23:05:41 <vixey> yes I think that should work just fine
23:07:00 <mmorrow> Berengal: heh
23:07:21 <mmorrow> Berengal: therein lies the crux
23:07:32 <mjrosenb>     Type synonym `F' should have 1 argument, but has been given 0
23:08:10 <Berengal> mjrosenb: type Foo = Maybe ;data Bar a = Bar (a Integer)
23:08:16 <Berengal> Works fine on my machine
23:08:25 <mjrosenb> Berengal: i said
23:08:34 <mjrosenb> type F a = a
23:09:18 <vixey> mjrosenb: in that case you'd have to newtype or something
23:09:33 <mjrosenb> : (
23:11:19 <Berengal> mjrosenb: type F a = a has kind * -> *
23:11:58 <vixey> F :: * -> *, but it has to be fully applied incase you try and do something sneaky like programming with types
23:12:20 * mjrosenb does not want to program with types
23:12:41 * mjrosenb just wants to have a type synonym there
23:12:41 <Berengal> type Baz a = a; data Bar a = Bar (a Integer)
23:12:52 <Berengal> :k Bar Baz
23:12:54 <lambdabot> Not in scope: type constructor or class `Bar'
23:12:54 <lambdabot> Not in scope: type constructor or class `Baz'
23:13:02 <Berengal> Bar Baz :: *
23:19:53 <tsLight> I can deduce the types of both 'filter' and 'uncurry' functions, now I want to determine the type of 'filter . uncurry'. How can I procede?
23:20:05 <pumpkin> substitute
23:20:13 <pumpkin> taking care to not mix up the type variables
23:20:21 <tsLight> can you show me the steps? I have been trying for a while now
23:20:26 <tsLight> and I get it wrong
23:20:42 <tsLight> filter :: (a -> Bool) -> [a] -> [a]
23:20:48 <tsLight> uncurry :: (a -> b -> c) -> (a,b) -> c
23:20:54 <vixey> :t (.)
23:20:55 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:21:14 <tsLight> (.) :: (a -> b) -> (c -> a) -> c -> b
23:21:15 <vixey> so filter . uncurry unifies:
23:21:30 <vixey> b -> c = (a -> Bool) -> [a] -> [a]
23:21:40 <vixey> well
23:21:43 <vixey> to be clearer,
23:21:46 <vixey> b' -> c' = (a -> Bool) -> [a] -> [a]
23:21:54 <vixey> a' -> b' = (a -> b -> c) -> (a,b) -> c
23:22:13 <vixey> so once you do that unification, then the result (the type of filter . uncurry) will be c' -> b'
23:22:31 <vixey> tsLight, do you know how to unify?
23:22:33 <mc__> Hi! Has anyone got the haskell sdl bindings working under os x? I've installed the runtime framework and compiled sdl from source, everything went fine, cabal install of the SDL package also went fine. But when I try to import SDL I get the following error:  Loading package SDL-0.5.5 ... can't load .so/.DLL for: SDLmain (dlopen(libSDLmain.dylib, 9): image not
23:22:47 <mc__> found )
23:22:55 <tsLight> I am reading precisely that chapter on "The craft of functional programming"
23:23:22 <vixey> actually I should have put for ''s down
23:23:55 <vixey> the a in the type of filter might be a different a than the type in uncurry
23:24:15 <tsLight> so I should change the letters not to mess up
23:32:08 <tsLight> thanks, i got it right now =)
23:32:27 <tsLight> I renamed
23:32:36 <tsLight> x -> y  = (a -> Bool) -> ([a] -> [a])
23:32:40 <tsLight> w -> x = (b -> c -> d) -> ((b,c) -> d)
23:32:49 <tsLight> and unifying gives (b -> c -> Bool) -> [(b,c)] -> [(b,c)]
23:33:00 <tsLight> which is correct according to hugs :P
23:33:00 <vixey> :t filter . uncurry
23:33:01 <lambdabot> forall a b. (a -> b -> Bool) -> [(a, b)] -> [(a, b)]
23:33:03 <vixey> !!!
23:33:09 <tsLight> :)
23:33:23 <vixey> now you could even write a program to do it
23:33:42 <tsLight> in Haskell?
23:33:51 <vixey> yes
23:34:07 <tsLight> but a program that does what?
23:34:08 <tsLight> type checks?
23:34:19 <tsLight> or does the substitutions?
23:34:35 <vixey> say you had built in the constants filter . and uncurry then it does the process you did by hand
23:35:26 <tsLight> but how can I get type information and do the substitutions with code?
23:35:32 <tsLight> I have no idea how to do that :P
23:39:31 <tsLight> I still can't "intuitively" get what filter . uncurry means
23:39:49 <tsLight> although doing the type calculation it is easy to figure out
23:39:52 <tsLight> without it I am lost
23:40:47 <vixey> I don't know either it's a bit strang
23:40:51 <vixey> :t filter . uncurry
23:40:52 <lambdabot> forall a b. (a -> b -> Bool) -> [(a, b)] -> [(a, b)]
23:41:00 <tsLight> right
23:41:04 <tsLight> its not as one would use that
23:41:05 <vixey> I guess it's basically the same as filter
23:41:07 <vixey> :t filter
23:41:08 <Berengal> tsLight: you know what uncurry does, and you know what filter does. filter . uncurry simply takes a function, uncurries it, and gives it to filter
23:41:08 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
23:41:11 <tsLight> like filter . map
23:41:31 <vixey> :t \p -> filter (\(x,y) -> p x y)
23:41:32 <lambdabot> forall t t1. (t -> t1 -> Bool) -> [(t, t1)] -> [(t, t1)]
23:41:37 <Berengal> tsLight: The resulting function takes a list and filters it
23:42:03 <tsLight> I know, but the type of the list has to be (a,b)
23:42:07 <tsLight> and I couldnt see why easily
23:42:12 <Gracenotes> you can think of the second part after the (.) as 'absorbing' a function. So uncurry absorbs a function with (a -> b -> c), and that in turn (uncurry func) is used as the first argument of filter
23:42:40 <Berengal> tsLight: Well, it has to be of the same type as the function argument... uncurry returns a function taking (a,b) as an argument
23:42:41 <vixey> tsLight: I unfolded the definition of . and of uncurry
23:42:50 <vixey> thats' what \p -> filter (\(x,y) -> p x y) is
23:43:01 <Berengal> @unpl filter . uncurry
23:43:02 <lambdabot> (\ c -> filter (uncurry c))
23:43:25 <Gracenotes> (\f xs -> filter (uncurry f) xs)
23:43:39 <tsLight> ah
23:43:40 <tsLight> I get it now
23:44:05 <Gracenotes> an uncurry means that you're expecting a tuple, so that you can in turn send those values to your function f
23:44:15 <tsLight> uncurry has to result in a Bool for it to work together with filter
23:44:28 <tsLight> and also the argument for uncurry will have to be of the same type as the list elements
23:44:35 * Phyx- wonders
23:44:37 <tsLight> if not it doesnt make sense to use it as argument for filter
23:44:39 <Phyx->  :t (\p -> filter (\(x,y)-> p x y)) :: (forall a.(a->a->Bool) -> [(a,a)] -> [(a,a)])
23:44:44 <Phyx-> :t (\p -> filter (\(x,y)-> p x y)) :: (forall a.(a->a->Bool) -> [(a,a)] -> [(a,a)])
23:44:45 <lambdabot> forall a. (a -> a -> Bool) -> [(a, a)] -> [(a, a)]
23:44:55 <Phyx-> ah, works
23:46:24 <Berengal> @type fmap elem . (,)
23:46:26 <lambdabot> forall a b. (Eq b, Eq a) => a -> b -> [(a, b)] -> Bool
23:47:10 <tsLight> well, thanks everyone, you guys are really helpful
23:47:18 <tsLight> I guess I will be stopping by again soon enough
23:47:18 <tsLight> :P
23:48:20 <Phyx-> Berengal, just out of curiousity, what does unpl stand for?
23:48:24 <Gracenotes> :d
23:48:28 <Gracenotes> :D
23:48:31 <Berengal> Phyx-: Un-pointless
23:48:37 <Phyx-> LOL
23:49:41 <Gracenotes> people using fmap for functions instead of (.) .. *meow*
23:50:18 <Berengal> IMHO, fmap should be renamed to (.)...ø
23:50:20 <Gracenotes> I mean *rage*
23:51:04 <dobblego> mine too
23:51:21 <Berengal> (Although enderk pointed out that conflicts with the category use of (.))
23:51:59 <Berengal> ((I probably spelled his name very wrong. Must run!))
23:52:09 <Gracenotes> derk derk *sniggers*
23:52:15 <Phyx-> how can fmap be replaced by compose?
23:52:33 <Gracenotes> @type fmap
23:52:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:53:07 <Berengal> @type (\f -> fmap f (+1))
23:53:08 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
23:53:31 <Gracenotes> it's the function instance, which is ((->) r). So, the Maybe instance is (a -> b) -> Maybe a -> Maybe b, for example
23:53:37 <Berengal> @type (.)
23:53:38 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:53:57 <Phyx-> hmm
23:53:58 <Phyx-> right
23:54:02 <Gracenotes> then for functions .. (a -> b) -> (->) r a -> (->) r b
23:54:25 <Gracenotes> which is usually written (a -> b) -> (r -> a) -> (r -> b)
23:54:26 <glguy> . should no more be fmap than any of the other implementations of fmap should
23:54:32 <Phyx-> hmm, never saw it that way
23:55:24 <glguy> the only benefit to it would be clever, obfuscated function definitions in #haskell
23:55:27 <Gracenotes> a function can't hold a value in the same way that Maybe can, but -> has an extra type parameter at the end, so you can fit f a with r -> a.
23:55:59 <Phyx-> @type (->)
23:56:00 <lambdabot> parse error on input `->'
23:56:06 <Phyx-> @kind (->)
23:56:06 <lambdabot> ?? -> ? -> *
23:57:27 <pumpkin> whoa
23:57:35 <pumpkin> is that true?
23:57:42 <pumpkin> that seems odd
23:57:59 <Berengal> > let (.) = fmap in (*5) . [1..5]
23:58:01 <lambdabot>   [5,10,15,20,25]
