00:00:08 <orbitz> pumpkin: you see the Haskel BASIC DSL (dons calld it EDSL i think?)
00:00:17 <pumpkin> yup :)
00:00:21 <pumpkin> there's a c-like one too
00:00:26 <orbitz> what's the E stand for? estatic?
00:00:29 <pumpkin> embedded
00:00:30 <orbitz> pumpkin: do you know teh name?
00:00:32 <Eridius> hrm, compilation failed
00:00:40 <Eridius> gtk/Graphics/UI/Gtk.hs.pp:227:0:
00:00:40 <Eridius>     Failed to load interface for `Graphics.UI.Gtk.General.General':
00:00:41 <pumpkin> orbitz: maybe c-monad or cmonad in hackage?
00:01:51 <orbitz> not quite C
00:02:30 <Eridius> anybody know anything about my error?
00:02:41 * Eridius was just following the instructions from the Gtk2Hs wiki page
00:04:00 <Eridius> of course the worst part is it's not telling me what command caused that error. the previous command it printed was a rm -rf
00:04:14 <Eridius> oh wait no, there's a call to ghc that I missed, silly wrapping
00:04:38 <orbitz> pumpkin: how do tehse EDSL's work?  the basic one is the mos timpressive so far
00:15:58 <pumpkin> orbitz: epic haskell hackery
00:16:05 <pumpkin> especially the line number thing
00:16:35 <orbitz> heh
00:16:48 <orbitz> pumpkin: scala seems to be working hard at supporting this
00:16:58 <pumpkin> supporting what?
00:17:19 <orbitz> writing DSL's in a non hacky manor
00:17:30 <pumpkin> ah, most haskell DSLs aren't hacky
00:17:39 <pumpkin> but if you want to get almost exactly the original syntax of another language
00:17:49 <pumpkin> without actually parsing
00:17:54 <pumpkin> then you're going to need some hacks :P
00:18:05 <orbitz> pumpkin: i beleiv ea common use case in Scala is they have an XML DSL
00:18:14 <pumpkin> for generating it?
00:18:26 <pumpkin> haskell has some nice combinator libs for making it
00:18:38 <pumpkin> or xhtml at least
00:18:56 <orbitz> pumpkin: for writing it
00:19:17 <orbitz> pumpkin: you can do val x = <tag><oom>fejwl</oom></tag>
00:21:08 <pumpkin> it seems silly to build support for that into the language
00:21:50 <pumpkin> it shouldn't be hard to make a simple language equivalent to xml that feels more natural in the language
00:23:48 <orbitz> pumpkin: it's not built inito teh language, it's a DSL
00:23:55 <orbitz> pumpkin: scala is tryign to make it easy to defien DSL's in scala
00:24:04 <pumpkin> well, yeah
00:24:08 <orbitz> pumpkin: http://www.scala-lang.org/node/1403 there is teh BASIC version
00:24:12 <mmorrow> after x86 and x86_64, what would anyone say would be the next two most-commonly used architectures?
00:24:43 <pumpkin> ARM in mobile devices
00:24:47 <mmorrow> ("most-commonly used" being given no qualification on purpose)
00:25:45 * mmorrow adds ARM to the list
00:25:53 <pumpkin> what list is that?
00:26:07 <pumpkin> not sure what I'd put next
00:26:10 <pumpkin> maybe ppc?
00:26:11 <mmorrow> pumpkin: me neither
00:26:25 <pumpkin> sparc seems unlikely as a next one down
00:26:40 <mmorrow> i'm reading/collecting abi's and am wondering which other two to look at
00:26:52 <mmorrow> yeah, does anyone actually ever use sparc?
00:27:06 <pumpkin> ppc is boosted by all the Wiis and PS3s
00:27:14 <pumpkin> sun does :P
00:27:20 <mmorrow> i just looked at ghc's "tier 1" platforms and they're all x86 or x86_64
00:27:24 <pumpkin> the ARM ABI is pretty nice and simple
00:27:31 <pumpkin> I'm a big fan of the arch
00:27:48 <mmorrow> cool, i think i'll look at arm
00:28:07 <mmorrow> now that apple doesn't use ppc, it doesn't seem worth it
00:28:54 <pumpkin> yeah, although the cell CPU (and the fact that I own a ps3) makes it more attractive to me
00:28:59 <pumpkin> not quite enouh to make me interested in it
00:29:10 <mmorrow> oh, the cell is ppc?
00:29:17 <pumpkin> with extensions
00:29:26 <pumpkin> the main CPU is a regular ppc
00:29:41 <mmorrow> yeah, that reminds me. what about (common) gpus? what instruction set(s) do they use?
00:30:39 <pumpkin> no clue, not sure if they're even publicly documented
00:30:46 <pumpkin> or if you're expected to go through things like CUDA to use them
00:30:50 <mmorrow> hmm
00:31:31 <Ferdirand> ghc being able to use the cell spus would be completely awesome
00:31:48 <mmorrow> ah i just remebered i have the cell abi and a few other pdfs here http://code.haskell.org/~morrow/cell/
00:32:38 <mmorrow> which i apparently found here http://www.ibm.com/developerworks/power/cell/documents.html
00:32:51 <pumpkin> mmorrow: up to date ARM documentation is pretty hard to find
00:33:03 <mmorrow> pumpkin: really?
00:33:10 <mmorrow> (why?)
00:33:26 <pumpkin> not a clue, I guess they decided it was better to make people pay for it?
00:33:33 <mmorrow> ah, those bastards
00:33:46 <pumpkin> they decided to unify their thumb and arm asm syntax, and added a few more instrucitons that no one uses yet
00:33:50 <pumpkin> you aren't really missing much
00:34:10 <mmorrow> how's your assembler coming?
00:34:10 <pumpkin> compared to something like http://www.arm.com/miscPDFs/14128.pdf for example
00:34:25 <pumpkin> been too distracted with other stuff :P
00:34:31 <mmorrow> ooh, nice link
00:34:45 <pumpkin> the uvector work has a more direct benefit to my work/research
00:34:58 <mmorrow> ah nice
00:35:11 <mmorrow> how's that coming
00:35:28 <pumpkin> I've implemented the basic structure for lazy UArrs
00:35:48 <pumpkin> need to write all the functions on top of them and write the to/from Stream functions for them
00:35:53 <mmorrow> hmm
00:36:09 <pumpkin> most of it is generated by my l33t ruby script for now :P
00:36:13 <mmorrow> oh snap
00:36:56 <pumpkin> don't think it would be a very popular patch if I required GHC HEAD to compile the TH in it for generating associated types
00:37:12 <mmorrow> i love the feeling when you write some code that generates code and then you watch it spit out like 1000 lines of useable code :)
00:37:51 <pumpkin> yeah, it's nice
00:38:03 <pumpkin> I should use TH to call my ruby script
00:38:07 <pumpkin> and put the code in for me
00:38:46 <mmorrow> ooh, nice. there's code in haskell-src-meta that tranlates from the haskell-src-exts ast to the TH one
00:39:19 <mmorrow> (it's still not 100% complete though wrt the all the TH syntax, but i should update it...)
00:39:35 <pumpkin> ah, that'd be handy... so I could run my ruby, capture its stdout, run through haskell-src-exts, transform using your meta stuff, and spit it out in the TH?
00:39:39 <mmorrow> unfortunately you're screwed if you need GADTs or anything TH doesn't support
00:39:44 <pumpkin> associated types?
00:39:45 <pumpkin> :P
00:39:51 <mmorrow> pumpkin: exactly
00:39:52 * pumpkin gets ready to cry
00:39:56 * pumpkin cries
00:40:16 <mmorrow> well, you just have to wait til 6.12 for the associated types ("just" :/)
00:40:25 * Gracenotes reveals the onions he has been cutting
00:40:35 <pumpkin> lol
00:40:49 <pumpkin> well, who knows, I may end up taking so long to do it that 6.12 will be out by then
00:41:07 <pumpkin> but I'm not sure dons would want to accept a patch that broke compatibility with 6.10 at least, and probably 6.8
00:41:12 <mmorrow> (exactly @ "ah, that'd be handy... so I could run my ruby, capture its stdout...")
00:41:50 <jml> how do I convert a Char to a Word8
00:41:57 <pumpkin> fromIntegral . ord
00:42:14 <mmorrow> pumpkin: you can also add {-# OPTIONS_GHC -fpgm foo #-} and ghc'll run the foo preproc over the file first
00:42:19 <mmorrow> i almost forgot about  that
00:42:21 <mmorrow> hmmm
00:42:25 <pumpkin> oh cool
00:42:28 <pumpkin> that's pretty much what I need
00:42:36 <mmorrow> (i think that's the switch)
00:42:43 <jml> pumpkin: thanks
00:42:52 <mmorrow> ah not, that's not it
00:42:56 <jml> was bashing head against fromInteger, not fromIntegral
00:43:03 <pumpkin> :)
00:43:16 <pumpkin> mmorrow: I can look it up, I didn't even know it supported arbitrary preprocessors
00:43:27 * mmorrow is looking it up now
00:43:37 * mmorrow is going to start using this immediately
00:43:37 <pumpkin> -pgmF cmd
00:43:39 <pumpkin> I think
00:43:49 <mmorrow> man ghc | grep pgm
00:43:55 <mmorrow> shows a bunch of similar
00:44:03 * mmorrow wonders what they do
00:44:18 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html
00:44:28 <pumpkin> or grep -A 3
00:45:49 <harovali> is there something better than    ( tail . tail )   ?
00:46:06 <mmorrow> http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/flag-reference.html#id2652053
00:47:02 <pumpkin> harovali: drop 2
00:47:03 <mmorrow> looks like you need -F to enable a preproc, then -pgmF cmd to specify it
00:47:14 <harovali> pumpkin thanks
00:47:50 <pumpkin> ah
00:47:55 <mmorrow> wow, this can be abused super easily :)
00:49:18 <pumpkin> how so?
00:49:26 <mmorrow> i'm scheming..
00:49:30 <pumpkin> oh no
00:49:42 <pumpkin> you going to put a scheme-to-haskell preprocessor in?
00:49:56 <mmorrow> oh no, not that kind of scheming!
00:49:59 <pumpkin> :P
00:50:57 <mmorrow> you could have something like a program that takes a .hs as input, and if the first line is "NOODLES!", it compiles the rest with ghc, runs it, and returns its output as the source code for that module
00:51:16 <mmorrow> or any sort of variation on that
00:51:28 <pumpkin> :o
00:51:40 <mmorrow> the rest of it wouldn't even have to be haskell
00:51:50 <pumpkin> it could be rooby
00:51:54 <mmorrow> l33t
00:51:55 <mmorrow> !
00:52:11 * pumpkin bows
00:52:34 * mmorrow throws cabbage and seagulls
00:52:53 * mmorrow disappears
00:53:05 <Actium> pumpkin won't go hungry tonight!
00:53:16 <pumpkin> :o
00:56:31 <mmorrow> even better, you could have a program that takes an .hs as input, and if the first line is "NOODLES!" reads up until a single line containing "LOLMG!", compiles that with ghc, then runs it with the remainder of the file on stdin, and returns the output of *that* as the source of the module
00:57:25 <pumpkin> lol
00:57:26 <mmorrow> so it's a preprocessor-processor, allowing the preproc to be determined by the code up to "LOLMG!"
00:57:35 * mmorrow really disappears
00:57:38 <pumpkin> and the code is lolcode?
00:57:50 <mmorrow> ONE WOULD HOPE
00:57:58 * pumpkin goes to sleep
00:58:03 <pumpkin> to avoid any more mindrot from mmorrow
00:58:03 <mmorrow> night
00:58:06 <pumpkin> night :D
00:58:33 <dancor> is there a reasonable way to split lambdabot modding into 'secret' and 'public' parts so that the 'public' mods can be submitted for inclusion in lambdabot, while my 'secret' plugins/config-settings stay secret?
00:59:02 <dancor> the config part would be easy if there were a config file that is read at runtime, but it's a Config.hs
00:59:23 <dancor> to start with i have a public repo that is in a subdir of my private repo
01:00:27 <dancor> "various symlinks" seems like a reasonable possibility
01:00:47 <dancor> and a secret modified .cabal
01:07:04 <harovali> Do you think there is a better approach to "ciclar" function here? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2084#a2084
01:08:56 <Eridius> what is "circlar" supposed to do?
01:09:06 <vixey> harovali: takeT n = take n . map toUpper
01:09:12 <harovali> Eridius: down there is an example
01:09:56 <harovali> Eridius: it is suposed to "cycle" the phrase, so that different outputs are generated
01:10:19 <PetRat> I'm working through an example in the paper "Monadic Parser Combinators", and I wrote it out here: http://www.mibbit.com/pb/vk9OAT
01:10:21 <Eridius> vixey: takeT only uppercases the first arg
01:10:21 <Eridius> err, first char
01:10:27 <vixey> > filter (\(x:_) -> isUpper x) . map (take 15) . iterate (drop 15) . cycle $ "MoviDeClieYArti"
01:10:29 <lambdabot>   ["MoviDeClieYArti","MoviDeClieYArti","MoviDeClieYArti","MoviDeClieYArti","M...
01:10:39 <vixey> > filter (\(x:_) -> isUpper x) . map (take 15) . iterate tail . cycle $ "MoviDeClieYArti"
01:10:40 <lambdabot>   ["MoviDeClieYArti","DeClieYArtiMovi","ClieYArtiMoviDe","YArtiMoviDeClie","A...
01:10:51 <Eridius> harovali: you might want to define takeT 0 to return nothing, right now it will return one char
01:11:24 <harovali> Eridius: true
01:11:33 <PetRat> In this paper they use `bind` instead of ==> and "result" instead of return. In any case I tried to expand the application of the recursive parser "string", and I noticed that it constructs a lot of intermediate results which are discarded. Does that look right?
01:11:45 * Eridius points out that your nombres is still defined using foldl and (++), which is much less efficient than foldr
01:11:52 <harovali> I'd basically like to express better the whole thing, and in particular the ugly 'ciclar'
01:12:08 <Eridius> and actually, you could use concat
01:12:38 <vixey> PetRat: there is the chance lazyness means less unrequired work is done though
01:12:40 <Eridius> nombres q xs = '_' : concat (map (takeT q) xs)
01:12:52 <PetRat> ah...
01:13:30 <Eridius> nombres q = ('_':) . concat . map (takeT q)
01:13:36 <Eridius> PetRat: it's also possible that some stuff gets optimized away
01:14:12 <PetRat> I've noticed that the stuff I'm learning in Haskell is always very elegantly expressed. Is laziness a particular value because some elegant ways of expressing things would lead to a lot of inefficiency otherwise?
01:14:39 <PetRat> For example, in monadic construction of parsers, one chains together many, many functions, and many of those just discard their results.
01:14:46 <jedai> PetRat: Yes, I would say it's the most important quality of lazyness in reality
01:15:05 <vixey> PetRat: Very
01:15:19 <Eridius> circlar xs = map nombres $ take (length xs) $ tails $ cycle xs
01:15:35 <vixey> @src isInfixOf
01:15:35 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
01:15:42 <vixey> PetRat: for example this ^
01:16:56 <PetRat> Oh, because isPrefixOf immediately stops working if a single character doesn't match.
01:16:57 <jedai> circlar xs = map nombres $ zipWith (flip const) xs $ tails $ cycle xs
01:17:17 <vixey> yes
01:17:35 <Eridius> ooh, the zipWith (flip const) is a neat trick to avoid iterating the list twice
01:18:00 <jedai> PetRat: and the any similarly benefits from lazyness
01:18:02 <PetRat> Also I've noticed that having immutable data means that it can share state... for example (tails haystack) doesn't have to construct N separate lists, but just N separate "pointers"
01:18:03 <jedai> @src any
01:18:03 <lambdabot> any p =  or . map p
01:19:07 <jedai> PetRat: Yes, that's one of the benefit of the "sacrifice" FP does when it forsakes mutations
01:19:18 <PetRat> In imperative languages, we often encounter "optimized large data structures" (for example the QPixmap class in Qt) which share state. They also need to do work behind the scenes to untangle that shared state when you try to mutate it.
01:19:41 <PetRat> In Haskell, you simply decide not to mutate anything. Brilliant!
01:19:49 <vixey> PetRat: yeah that one is good and bad
01:20:12 <Eridius> dons: vacuum-cairo doesn't behave very nicely when I use the non-X11 GTK
01:21:01 <PetRat> My day job is C++/Python scientific programming, and I've already heard some interest in my company for moving to Haskell for multi-threaded applications.
01:22:07 <PetRat> And completely independently, on a mailing list about computer music someone brought it up for the same reason.
01:27:53 <jedai> rotations xs = let l = length xs in map (take l) . take l . tails . cycle $ xs
01:28:22 <jedai> circlar = map (nombres 4) . rotations
01:28:42 <jedai> harovali: ^
01:28:46 <dancor> how does (Data.Unamb.unamb x y) maintain referential transparency just by requiring that x == y when neither is _|_?
01:29:00 <harovali> jedai: !!!
01:29:14 <dancor> does replacing 4 with (error "death") "maintain referential transparency"?
01:29:26 <vixey> dancor actually it does
01:29:30 <dancor> ok
01:29:32 <vixey> error is interesting in that way
01:29:45 <dancor> i can see how that would be true if error hung forever..
01:29:49 <vixey> dancor, you know there is a way to catch errors, but /that/ uses IO
01:29:49 <vixey> a
01:30:03 <vixey> if it didn't that would break referential transparencly
01:31:20 <dancor> is the idea that error is "theoretically" (or whatever) equivalent to an infinite-hang, despite the fact that in practice the program actually terminates?
01:31:36 <vixey> yen
01:31:37 <vixey> yes
01:31:48 <dancor> so why is catching error ever ok, even in IO?
01:32:08 <vixey> it's ok in IO because IO can do side effects and stuff
01:32:54 <Eridius> IO is already nondeterministic
01:33:30 <Gracenotes> right, every time it's given a bad value, it causes control flow to leave non-IO code. Referentially transparent indeed.
01:33:58 <Gracenotes> (and IO code, if not caught :X)
01:34:16 <vixey> you are saying that it's not?
01:35:02 <Gracenotes> no
01:35:41 <Gracenotes> it's just odd for pure code to have, for bottom to be an exception that can be caught
01:35:59 <vixey> yeah
01:36:17 <Eridius> I've never actually seen a case where bottom is actually caught. Every instance of bottom I've seen has been represented by non-termination :/
01:36:54 <dancor> i guess that's necessary if you write an interpreter
01:37:37 <dolio> > error "foo"
01:37:39 <lambdabot>   * Exception: foo
01:38:56 <Gracenotes> and if you have IO handy, you can "throw NonTermination" :)
01:39:29 <Gracenotes> well, Control.Exception
01:39:44 <Gracenotes> both are defined in GHC.IOBase though
01:39:49 <harovali> jedai: thanks, thare you introduce a notation that I don't know, namely, rotations xs = let l =  .....
01:40:15 <harovali> jedai: which involves l in a way I can't devise
01:46:01 <mmorrow> Gracenotes: you can just define "error = error" if you think that'd be more useful ;)
01:46:51 <mmorrow> oops
01:47:01 <mmorrow> Gracenotes: you can just define "error x = error x" if you think that'd be more useful ;)
01:47:39 <mmorrow> err, error = error could still be String -> a i guess
01:47:56 <mmorrow> @type let x = x in x :: forall a. String -> a
01:47:58 <lambdabot> forall a. String -> a
01:48:19 <QtPlaty[HireMe]> Possably stupid question.  Is there any libary function of the type (a -> m b) -> ( b -> m c) -> a -> m c
01:48:28 <Gracenotes> @type (>=>)
01:48:29 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
01:48:36 <Gracenotes> if by m you mean monad :)
01:48:40 <mmorrow> damn, i was just about to hit enter
01:48:44 <QtPlaty[HireMe]> Thanks
01:48:53 <mmorrow> quickdraw mcgraw
01:49:02 <Gracenotes> it's a Kleisli arrow
01:49:11 <Gracenotes> well, composing em
01:49:20 <Gracenotes> 'til category theory-ish.
01:49:22 <Gracenotes> 'tis
01:53:50 <Eridius> ok, I'm confused. reactive requires QuickCheck (<2.0) and Stream, but Stream requires QuickCheck (>=2.0). How the hell are you supposed to install reactive?
01:54:39 <dancor> Eridius: that might mean that something needs to be recompiled but cabal-install isn't smart enough to figure it out?
01:55:17 <Eridius> dancor: no, I'm looking at the hackage pages to verify
01:55:41 <snoobino> why would a lib require quickcheck ?
01:56:02 <Eridius> I don't know. presumably so you can run its tests, but shouldn't that be optional?
01:56:32 <snoobino> Sure
01:57:34 <Eridius> I'm guessing reactive was last tested against Stream 0.3
01:57:38 <Eridius> which used QuickCheck (<2)
01:58:06 <dancor> ya
01:58:40 <Eridius> there we go, `cabal install --constraint='Stream == 0.3' reactive`
02:06:38 <Eridius> whoa, fieldtrip doesn't compile
02:06:45 <Eridius> src/Graphics/FieldTrip/Point3.hs:46:7:
02:06:45 <Eridius>     Not in scope: type constructor or class `AVector'
02:08:41 <Eridius> wait, what the.. it's trying to *define* the type AVector
02:10:22 <Eridius> actually it's trying to define an instance of the VectorSpace class
02:12:01 <Eridius> actually no, AffineSpace
02:12:33 <Eridius> ahh crud, the AffineSpace class changed in vector-space 0.5.2
02:12:39 <Eridius> reactive needs tighter dependencies :/
02:12:51 <Eridius> actaully this is fieldtrip
02:13:43 <dancor> but the QuickCheck dep was too tight ;)
02:13:52 <dancor> s/tighter/righter
02:16:09 <Eridius> huh interesting, the FPS display (http://haskell.org/haskellwiki/Reactive/Tutorial/A_FPS_display) runs at about 98fps on my machine
02:16:19 <Eridius> you'd think something that's *only* fps would run a bit faster
02:18:16 <dancor> that doesn't sound good
02:19:13 <MyCatVerbs> Gracenotes: I believe that the mdo example I gave yesterday was a bad idea because the scheduler is allowed to be arbitrarily mean and evil to you. There's no actual *guarantee* that the first expensive call in the first thread won't be completed before the second forkIO is even touched.
02:19:34 <flux> eridius, does it peg the cpu?
02:19:42 <Gracenotes> gotcha
02:19:45 <Eridius> nope
02:19:51 <Eridius> I suspect it's actually just not evaluating events very fast
02:19:55 <Eridius> every now and then it pauses for a second or two
02:20:00 <MyCatVerbs> Gracenotes: depending on some of the fine details of GHC's threading, it might be a race condition, albeit one with fairly low probability.
02:20:08 <Eridius> I don't know what causes reactive to evaluate events
02:20:32 <Gracenotes> MyCatVerbs: hm, an MVar race?
02:20:40 <MyCatVerbs> Much better to just be explicit about it, and hand the references to both threads out in an mvar.
02:21:45 <MyCatVerbs> The race condition I'm talking about there is the first thread managing to get all the way to (killThread tid2) before (tid2 <- forkIO (...)) gets hit, so that thread 2 is not actually running yet.
02:22:33 <Gracenotes> mm. Is that a matter of being able to refer to the value without it having a value?
02:22:40 <MyCatVerbs> Yep.
02:22:46 <Gracenotes> darn laziness! :o
02:22:56 <Gracenotes> .. that makes mdo work :)
02:23:12 <Eridius> err, but won't that then evaluate the value, which kicks off the forkIO?
02:24:20 <Gracenotes> although, something more race-y would be that the thread is scheduled for creation but not actually present when you have tid2.
02:24:27 <MyCatVerbs> Eridius: I've looked at the source for fixIO and I -believe- that it will just blow up in your face, but I'm not certain.
02:24:49 <Heffalump> I'm fairly sure it'd just blow up in your face.
02:25:14 <MyCatVerbs> Is it? I thought forkIO did not return until the new thread was running.
02:25:49 <Gracenotes> @src fixIO
02:25:49 <lambdabot> Source not found. Take a stress pill and think things over.
02:26:07 <Gracenotes> fixIO k = do { ref <- newIORef (throw NonTermination); ans <- unsafeInterleaveIO (readIORef ref); result <- k ans; writeIORef ref result; return result }
02:26:25 <MyCatVerbs> Otherwise (forkIO (...) >>= killThread) would have undefined behavoir, which strikes me as dodgy.
02:26:28 <Gracenotes> MyCatVerbs: that makes sense. You are allowed to sequence it after all
02:27:46 <Gracenotes> > return undefined
02:27:48 <lambdabot>       No instance for (Show (m a))
02:27:48 <lambdabot>        arising from a use of `show' at <in...
02:28:13 <Gracenotes> ^ defaults the IO in ghci, though... doesn't do anything
02:28:16 <Gracenotes> *to
02:28:58 <Gracenotes> so does 'mfix return'
02:32:46 <Gracenotes> hm. unsafeInterleaveIO does weird things..
02:34:15 * Gracenotes wonders what the writeIORef call is about :X
02:38:48 * Gracenotes reads Semantics of fixIO
02:39:35 <mmorrow> preflex: seen mauke
02:39:36 <preflex>  mauke was last seen on ##c 12 hours, 30 minutes and 30 seconds ago, saying: preflex: seen Zhivago
02:40:28 <mmorrow> @tell mauke hell.s for x86_64: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3655#a3655
02:40:28 <lambdabot> Consider it noted.
02:49:14 <mmorrow> @tell mauke better: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3655#a3656
02:49:15 <lambdabot> Consider it noted.
03:02:55 <jnwhiteh_> I'm reading the documentation on Control.Concurrent, and it mentions that when built with -threaded, safe foreign calls cause a spare worker thread to take over the multiplexing of threads.  What happens if a foreign call that might block is marked as unsafe (since it won't call back into haskell)... does the runtime block or utilize the worker threads?
03:03:10 <jnwhiteh_> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#10 is the text I'm reading, I'm just looking for clarification if anyone can provide it
03:06:50 <int-e> jnwhiteh_: As far as I know, it will block one worker thread, and it will prevent GCs from happening while it blocks.
03:08:52 <jnwhiteh_> int-e: But from reading the docs, the additional worker threads are only utilized for foreign calls marked as safe.
03:09:17 <jnwhiteh_> int-e: I may be reading it wrong, but that sounds to me that the runtime would block waiting for the foreign call to complete, which is certainly reasonable
03:09:23 <int-e> jnwhiteh_: I mean the RTS worker threads.
03:09:30 <jnwhiteh_> I'm just trying to better understand it
03:10:00 <jnwhiteh_> int-e: Okay, it sounds like I'm not sure of the distinction =/
03:10:58 <int-e> jnwhiteh_: there are Haskell threads; they're scheduled on one of several worker threads (called capabilities) by the RTS. On a safe call, an additional worker thread (of a different kind, not used for executing haskell code) is used for the foreign call.
03:11:19 <jnwhiteh_> Yes, I understand and follow you
03:11:44 <jnwhiteh_> You're just saying that when a blocking unsafe call happens. that RTS thread will block and GC cannot happen until it completes
03:12:30 <jnwhiteh_> although the other threads (which may be running safe foreign calls) will continue to run, along with any multiplexed System.IO work, etc.
03:12:35 <int-e> jnwhiteh_: on an unsafe thread, the haskell worker thread is used for the foreign call; so if it blocks the first thing that happens is that one thread less is executing Haskell code. That's the worker thread that I meant.
03:12:47 <jnwhiteh_> Okay, then I do follow you
03:12:50 <int-e> *on an unsafe call
03:12:51 <jnwhiteh_> thanks for the clarification
03:14:19 <int-e> And GC (at least major GCs, I don't know what the status of minor GCs is) involves a rendevouz of all Haskell worker threads, so if the unsafe call thread block, major GCs can't be started.
03:14:32 <jnwhiteh_> that makes perfect sense then, thanks!
03:15:41 <MyCatVerbs> int-e: is it safe calls or unsafe calls that can reenter GHC?
03:16:02 <int-e> safe calls
03:16:53 <MyCatVerbs> Right, so I don't have that backwards. Thanks.
03:17:23 <jnwhiteh_> the keywords confused me until I re-read it :P
03:17:35 <int-e> rendezvous. hard word.
03:47:20 <RayNbow> roconnor: I started reading a bit of TTFP, so far it's nice :)
03:47:59 <RayNbow> (in the logic introduction chapter I automatically linked a few of the proofs to certain functions :p)
03:52:42 <ClaudiusMaximus> greetings, i'm using Data.Array because i need array-cell-laziness at some points, but in other places i think i want to force the whole array - iterate' f !x = x : iterate' f (f x)  didn't seem to work, what should i be using instead?
03:53:20 <ivanm> orbitz: ping
04:02:10 <wli> TTFP?
04:02:24 <dolio> Type Theory for Functional Programming.
04:02:41 <dolio> Maybe and instead of for; I can't recall.
04:02:50 <wli> I've not heard of anything called that.
04:03:01 <bremner> Free?
04:03:12 <dolio> Well, I have it, so it must be.
04:03:18 <dolio> As a PDF, that is.
04:03:19 <RayNbow> @where ttfp
04:03:20 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:03:20 <bremner> Type Theory Free Function Programming (the revenge of Lisp)
04:03:48 <ivanm> ClaudiusMaximus: why do you want to force the array?
04:03:48 <ivanm> also, what type is your Array?
04:03:54 <ivanm> (because if it's one supported by UArray, one thing you could do is to convert the Array to the equivalent UArray and back again...
04:03:59 <ivanm> maybe do an amap?
04:04:59 <ClaudiusMaximus> ivanm: well, i was impatient i guess - program finished running after 12.5 minutes
04:05:13 <ClaudiusMaximus> ivanm: it's Array Int Float
04:05:24 <wli> got it
04:06:11 <ClaudiusMaximus> fwiw, here's the output of that program: http://img379.imageshack.us/img379/2471/secondfloorglo.png
04:13:21 <QtPlaty[HireMe]> @src (>=>)
04:13:21 <lambdabot> Source not found. You speak an infinite deal of nothing
04:14:15 <ivanm> ClaudiusMaximus: OK, so I think you can use UArray for that
04:14:17 <ivanm> but if you don't think it's fast enough, profile it first before blaming laziness ;-)
04:27:51 <EvilTerran> ?type (>=>)
04:27:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:29:44 <EvilTerran> ?type let (f >=> g) x = f x >>= g in (>=>)
04:29:45 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
04:31:44 <EvilTerran> "(f <=< g) x = f =<< g x" is nicely reminiscent of "(f . g) x = f $ g x"
04:34:21 <Saizan_> ?type (=<<)
04:34:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:37:41 <romildo> Hi.
04:40:13 <blackh> romildo: Hi!
04:40:53 <romildo> My system locale encoding is set to UTF-8 and there is a text file encoded in UTF-8. When the file is read by my haskell program, I get garbage instead of the accented letters in my program. Is there something that I have to do to get correct encoding?
04:41:16 <Peaker> Hey I just noticed that parameterized monads make the order of sequencing clear while normal monads don't...
04:41:29 <Peaker> ?type (=<<)
04:41:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
04:41:35 <Peaker> ^^ lacks that useful information
04:41:57 <blackh> romildo: The standard I/O stuff reads as if it was 8-bit characters, ... effectively iso8859-1 I think... if you want to use utf-8 you'll need to convert it...
04:42:43 <horms> roadwarrior: I have had good luck using utf-8 in conjunction with Data.ByteString and Data.ByteString.UTF8
04:43:00 <horms> though there are several diffrent approaches that work
04:43:13 <EvilTerran> Peaker, that one strikes me as being forced into order by the "a"
04:43:25 <Peaker> EvilTerran: oh, right, sorry :)
04:44:10 <EvilTerran> ?type flip (liftM2 const)
04:44:11 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a2 -> m a1 -> m a1
04:44:13 <Peaker> EvilTerran: more of a parameterized applicative problem than parameterized monad problem, I guess. (>>) should really be applicative, not monad
04:44:13 <blackh> romildo: The utf8-string package does what you want, but I can't remember the exact function
04:44:14 <EvilTerran> ?type liftM2 (flip const)
04:44:15 <lambdabot> forall a2 a1 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m a2
04:44:24 <EvilTerran> those two are ambiguous from the types, though
04:45:19 <blackh> romildo: I think it's Data.String.UTF8.fromString / toString
04:46:13 <horms> blackh: yes, thats what i used recently
04:46:30 <horms> seemed to work quite well for the task at hand
04:46:33 <EvilTerran> Peaker, while, with parameterised monads, those'd be something like "(x `m` y) a -> (y `m` z) b -> (x `m` z) b" and "(y `m` z) a -> (x `m` y) b -> (x `m` z) b", right?
04:46:52 <Peaker> EvilTerran: yep
04:47:05 * EvilTerran smells categories
04:47:19 <Peaker> EvilTerran: those really should be Applicatives, though
04:47:27 <EvilTerran> indeed
04:48:06 <Peaker> well,  a parameterized applicative is *->*->*->* and a Category is only *->*->*
04:48:16 <Peaker> @kind Arrow
04:48:18 <lambdabot> Class `Arrow' used as a type
04:48:21 <EvilTerran> Peaker, i mean categories with a small "c" :P
04:48:40 <Peaker> EvilTerran: ah
04:48:47 * EvilTerran has noticed that, with 6.10, -XNoImplicitPrelude and (>>) = (*>) get you "(do m; n) :: Applicative f => f ..."
04:49:15 <ledzippelin> hi :)
04:49:27 <blackh> hello!
04:52:12 <b_jonas> I found a nicer way to write this function I needed:
04:52:45 <b_jonas> let { maxMaybe :: (Ord a) => Maybe a -> a -> a; maxMaybe = maybe id max; } in (maxMaybe Nothing 5, maxMaybe (Just 3) 5, maxMaybe (Just 8) 5)
04:52:58 <b_jonas> > let { maxMaybe :: (Ord a) => Maybe a -> a -> a; maxMaybe = maybe id max; } in (maxMaybe Nothing 5, maxMaybe (Just 3) 5, maxMaybe (Just 8) 5)
04:53:00 <lambdabot>   (5,5,8)
04:58:12 <b_jonas> okay, try it now: http://erxz.com/pb/16972
05:06:16 <HECK3> Enter text here...kanalda t¸rkÁe bilen varsa beklerim
05:09:00 <ivanm> HECK3: hmmm?
05:09:41 <skorpan> he asked if anyone knows turkish
05:09:53 <skorpan> "if anyone in the channel knows turkish, i'm waiting" roughly translated
05:11:10 <ulfdoz> he fail waiting
05:11:26 <ledzippelin> I passed the Functional Programming exam - thanks to this channel :)
05:13:39 <b_jonas> ledzippelin: was it about implementing (++) tail recursively in standard ml?
05:13:45 <b_jonas> ours was like that.
05:15:30 <ledzippelin> b_jonas, proof by induction, writing a "synonym" for a combo of prelude functions, writing algos in haskell for data-structures, type inference, ...
05:16:48 <b_jonas> I see
05:22:37 <ledzippelin> b_jonas, interesting, the course was taught with SML as the functional programming-language (for the exercises) ?
05:24:24 <wli> (++) . tail?
05:24:30 <wli> never mind
05:33:52 <b_jonas> ledzippelin: yes, half of it
05:34:07 <b_jonas> the other half being logical programming with prolog
05:34:18 <b_jonas> it was quite an easy class, they didn't require too much
05:34:27 <b_jonas> we had to write some practical homeworks in both languages
05:35:02 <wli> I guess people would want to use Haskell and something typed on the logic language front to be more modern.
05:35:12 <ledzippelin> heh
05:35:42 <wli> I'm not sure what all there is out there. I'd say Mercury offhand but have an inkling it's not too popular.
05:36:07 <b_jonas> well, they want to teach the basics
05:36:25 <b_jonas> standard ml is good for that imo because it's the _flavorless_ functional language
05:36:33 <b_jonas> just like how scheme is a flavorless dynamic language
05:36:55 <b_jonas> it's good to illustrate the principles of coding functionally (even if the language also has mutable primitives actually)
05:37:02 <ledzippelin> b_jonas, same here (homeworks). but our course has a different 2nd part: Formal Methods (involving IMP, an imperative programming language.) and it covers proofs about software and so on...
05:37:29 <b_jonas> imperative language and proofs? ha ha ha
05:37:50 <ledzippelin> b_jonas, if you laugh -> you didn't get the idea :)
05:38:53 <Philonous> Is it possible that cabal install ignores --use-extra-libs ? If I build the package by hand it works, but cabal install doesn't.
05:41:46 <Philonous> I meant --extra-lib-dirs
05:45:26 * bremner thinks denotational semantics of imperitive languages is pretty similar to monads
05:47:24 <Saizan> that was their first purpouse in CS, afaiu
05:51:20 <wli> Moggi wrote the first monad tutorial before any programming language ever used monads?
05:53:57 <wli> Doubtless he used monadic monad tutorial writing combinators to generate it. ;)
05:59:47 <wli> -package parallel?
06:00:21 <b_jonas> ‚Äúmonadic monad tutorial writing combinators‚Äù, that's a good one
06:01:00 <wli> b_jonas: Note the immediately preceding line.
06:03:58 <b_jonas> wli: well, I think Church must have know about at least the state monad, even if not about monads in general
06:04:11 <b_jonas> you can use some monads in programming even if you don't have the monad class
06:04:40 <b_jonas> and I guess the monad tutorial writer combinators are like these
06:04:43 <wli> b_jonas: You did catch the part where all that was supposed to be humorous?
06:04:50 <b_jonas> yes
06:05:07 <b_jonas> I mean, I use regexen and regex concatenation can be thought of as (>>)
06:09:33 <ski> ("state-passing style")
06:20:54 <jelly12gen> hi
06:21:44 <jelly12gen> i would like to check if a list is orderd from low to high , how could i take
06:21:59 <jelly12gen> i just had this code in mind
06:22:20 <jelly12gen> all (\x -> x < (x +1 ) []
06:22:54 <beelsebob> no, that would test if all the values in the list were less that their own value plus 1
06:22:55 <ibid> well, that's not going to work
06:23:00 <beelsebob> and understandably, the answer would be yes
06:23:04 <enkrav> hello. I wrote a small but not too little program and when I ran it I got a head-on-empty-list-exception. Since there were a lot of heads and the program was somewhat complex I spent some time before finding out what head was the culprit. Was there an easier way analog to the infamous backtrace of a c crash?
06:23:11 <ibid> i'd probably just do my own recursive function, or use a fold
06:23:22 <beelsebob> think about doing it with primitive recursion, and then see if you can use a fold to replace it
06:23:37 <wli> enkrav: Usually you test smaller pieces with ghci
06:23:37 <beelsebob> yeh, what ibid said
06:23:48 <wli> enkrav: Show us the code e.g. on pastbin.com
06:24:15 * ibid does not use head or tail much
06:24:17 <wli> enkrav: pastebin.com
06:24:22 <ibid> pattern matching is often superior
06:24:37 <enkrav> wli: the problem is already fixed and I did it by testing small pieces. however that took time
06:25:10 <wli> ghci has new debugging funtionality
06:25:36 <wli> I myself am unfamiliar with it.
06:25:46 <EvilTerran> enkrav, you could try running your program through ndm's "catch"
06:25:50 <EvilTerran> ?where catch
06:25:50 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
06:26:42 <EvilTerran> it catches unsafe partial pattern-matches (such as "head" not matching the (x:xs) case) and suchlike
06:27:21 <EvilTerran> albeit with potentially quite a lot of false positives, depending on the structure of your program
06:27:38 <EvilTerran> but it errs on the side of caution, so won't miss any
06:28:59 <enkrav> that looks useful
06:29:38 <gwern> enkrav: you could use a package on hackage, which replaces the prelude with custom head definitions etc, which report the line number on crashing
06:30:01 <EvilTerran> it's usually possible to re-structure code so catch won't get any false positives; i believe a few projects have done this (including, iirc, xmonad)
06:30:23 <EvilTerran> s/re-//
06:31:12 <gwern> EvilTerran: I don't think we restructued xmonad-core, but ndm did check it with catch
06:31:15 <gwern> many versions ago
06:31:26 <gwern> (not that the core changes that oftne)
06:33:43 <EvilTerran> gwern, i guess how much change would be required (if any) varies substantially, depending on what implicit invariants and preconditions and whatnot you've got
06:34:15 <EvilTerran> (by "implicit" i mean "you didn't tell the compiler"; maybe there's a better word for that)
06:34:21 <jedai> jelly12gen: There is a nice solution with the functions "and" and "zipWith"
06:34:46 <EvilTerran> .away!
06:34:48 <EvilTerran> er
06:35:01 <EvilTerran> /, not .
06:36:23 <jelly12gen> jedai: well i just need to inster a list and as output a Bool
06:37:20 <jedai> jelly12gen: Yes, and the most elegant version I can think of use "and" and "zipWith"
06:37:42 <jelly12gen> jedai: ok will google
06:38:44 <jedai> > let growing xs = and . zipWith (<) xs $ tail xs in (growing [1..10], growing [1,2,3,2])
06:38:47 <lambdabot>   (True,False)
06:40:51 <jedai> jelly12gen: Use hoogle to search functions rather than google
06:40:56 <jelly12gen> ok
06:40:56 <jedai> @hoogle and
06:40:56 <lambdabot> Prelude and :: [Bool] -> Bool
06:40:57 <lambdabot> Data.Foldable and :: Foldable t => t Bool -> Bool
06:40:57 <lambdabot> Data.List and :: [Bool] -> Bool
06:41:02 <jedai> @hoogle zipWith
06:41:02 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:41:03 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
06:41:03 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
06:50:01 <wli> Maybe the Collatz problem and anagrams would be good monad tutorial example problems?
06:51:10 <wli> (more properly, finding the longest Collatz chain among integers in a given range or within some subset of integers)
06:51:59 <jedai> wli: How would you use a Monad to resolve this problem ?
06:52:19 <jedai> Well at least it would be original :)
06:52:43 <wli> I think it'd basically be a State monad affair for tracking some sort of result or other.
06:53:01 <ManateeLazyCat> How to handle global variable in Haskell?
06:53:32 <jedai> ManateeLazyCat: Do you mean global _variable_ or global constant ?
06:53:41 <ManateeLazyCat> I need update and query global variable, can someone show me simple code to do those? Just Int is okay
06:54:01 <ManateeLazyCat> jedai: global variable, i need modify and update it.
06:54:08 <jedai> ManateeLazyCat: Generally you try to avoid global variable in Haskell (even imperative programmers try to avoid that)
06:54:53 <jedai> ManateeLazyCat: But if you really need it, there's a page on the Wiki that explain how to do it
06:55:56 <Saizan> it's way better to just thread an IORef around in a ReaderT, you can even write a MonadState instance for it
06:55:57 <ManateeLazyCat> jedai: So if i need a object to store some value, i need modified and update it, have a better way in Haskell?
06:56:14 <benmachine> reads "4. cakes" == [(4,". cakes")] -- it bothers me that this is true
06:56:19 <benmachine> reads "4.0 cakes" == [(4,".0 cakes")] -- and this is false
06:57:15 <bremner> ManateeLazyCat: could use some kind of State monad
06:57:17 <ManateeLazyCat> Saizan: I know State Monad can do that in Haskell, but someone can show me code snippets for example, or show page link that have similar code? Thanks
06:58:02 <bremner> ManateeLazyCat: chapter 14 of real world haskell has examples of using state monad. look for random number generation
06:58:24 <ManateeLazyCat> bremner: Okay, thanks.
06:58:35 <jedai> ManateeLazyCat: Ok, if you don't know how to use a State Monad, start by learning that (and the ST, Reader and Writer monads for completeness), global variables are really ugly (in any language)
06:59:15 <jedai> ManateeLazyCat: You can find examples of State in plenty of monads tutorial, "All about Monads" for instance
06:59:22 <jedai> @where all
06:59:22 <lambdabot> I know nothing about all.
06:59:35 <benmachine> @where anything
06:59:35 <lambdabot> I know nothing about anything.
06:59:48 <bremner> @slap benmachine
06:59:48 * lambdabot beats up benmachine
07:00:03 <ManateeLazyCat> jedai: I know global variable is bad in Haskell, but now i can't use Monad experienced
07:00:10 * benmachine fully accepts the consequences of his actions
07:00:26 <ManateeLazyCat> Thanks all.
07:00:52 <jedai> ManateeLazyCat:  http://www.haskell.org/all_about_monads/html/
07:01:07 <ManateeLazyCat> jedai: Thanks, i will see in it.
07:01:50 <bremner> I seem to recall Cale's 'Monads as Computation'  covers this. Maybe it is madatory for monad tutorials
07:09:58 <wli> I don't seem to be able to maintain large seen sets in reasonable amounts of time.
07:12:34 <jedai> wli: For Collatz I always used Lazy Array in order to do dynamic programming, it was quite fast
07:13:27 <jedai> Of course that doesn't use any monads so...
07:13:58 <jedai> IntSet is not enough ? Maybe you could cut trying to remember above a certain limit ?
07:14:17 <wli> IntSet was what I used.
07:15:27 <wli> jedai: I don't remember offhand how one gets around knot-tying not including the cases where intermediate steps go above the range being searched.
07:19:12 * edwardk keeps playing with http://www.vim.org/scripts/script.php?script_id=2603 adding operators. woot
07:21:34 <ManateeLazyCat> When i type ":m Control.Monad.State" in ghci, it throw error: "it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2", how to fix it?
07:24:07 <maltem> ManateeLazyCat, hide the one (via ghc-pkg hide) you don't want to use
07:24:10 * EvilTerran solved the "longest collatz sequence starting (<x)" problem with a lazy array for values [0..x], and not caching the cases where it went above x
07:24:39 <EvilTerran> it scaled well enough for project euler, and that's good enough for me :P
07:24:44 <ManateeLazyCat> maltem: I don't know which one i need hide, any suggestion?
07:26:36 <maltem> ManateeLazyCat, hm, choose either. mtl is the ‚Äútraditional‚Äù transformer package, monads-fd is newer, I think
07:26:54 <ManateeLazyCat> maltem: Which is stable?
07:30:39 <ManateeLazyCat> maltem: My problem have fix when i hide mtl package, thanks! :)
07:32:26 <wli> EvilTerran: Seems to be slow over here.
07:33:03 <wli> 24.89user 0.30system 0:26.36elapsed 95%CPU (0avgtext+0avgdata 0maxresident)k
07:33:03 <wli> 0inputs+0outputs (0major+38976minor)pagefaults 0swaps
07:34:24 <wli> http://wli.pastebin.com/m35d20995
07:35:26 <wli> I wonder what IntSet is doing that it's getting such a huge space footprint.
07:36:14 <wli> I think 10^6 overflows 32-bit Ints in its intermediate results.
07:39:29 <benmachine> @src lex
07:39:30 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:47:13 <jeffheard> is there a paper reference out there on IO and denotational semantics in concurrent (and possibly separately) non-concurrent programs?
07:50:01 <maltem> I *really* like nice commit messages like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3660
07:50:07 <jeff___>  /join #haskell
07:50:11 <jeff___> ah heh
07:51:04 <maltem> (At the same time, a good lesson about redundant data type design)
07:52:27 <EvilTerran> wli, this took a few seconds for me, and got the right answer according to PE: http://wli.pastebin.com/md371d8e
07:54:21 <maltem> jeffheard_again, maybe you'll find something of interest in SPJ's papers, he's written quite a bit about concurrence
07:55:15 <jeffheard_again> maltem: thanks
07:56:05 <maltem> jeffheard_again, http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
07:56:44 <EvilTerran> wli, i think it's defaulting to Integer throughout there; putting in an explicit type sig suggests that, anyway
07:58:19 <jeffheard_again> maltem, I'm looking more specifically for denotational semantics of IO.  I remember we recently more or less agreed that denotational semantics break down in the case of concurrency, although they can be described in terms of a free data structure in the special case of non-concurrency
07:59:56 <ManateeLazyCat> How to write function (use State Monad) return a new increase value? Example, first call it return 1, second call return 2, third call it return 3....
08:00:21 <maltem> jeffheard_again, sorry, not sure about that specifically
08:01:24 <zachk> question: I am overflowing stack, default stack is at 8megs, how do i set the stack to like a gig?..+RTS -k1000000000 gives me a strange error
08:01:28 <maltem> ManateeLazyCat, you can use "modify" to alter the state, e.g. modify (+1), if the state is a number
08:03:10 <maltem> ManateeLazyCat, note, however, that you'll have to sequence the relevant actions somehow - you cannot use them in totally different parts of your program, for instance
08:03:54 <maltem> (This sounds rather vague... so maybe provide an example if you need a better explanation)
08:04:33 <jeffheard_again> zachk, better question, why are you overflowing stack?  and what's the error message you're getting?
08:05:01 <maltem> zachk, btw, if you don't want to count zeroes, you can write -k1G
08:05:03 <ManateeLazyCat> maltem: Example, I'm now develop editor, i need initial Window ID when i create a new Window, and then don't change Window ID anymore, but i need Window ID ticker for give new Window unique ID.
08:05:38 <zachk> jeffheard_again: using the list monad to construct a a bunch of lists recursively
08:06:23 <ManateeLazyCat> maltem: I still don't understand, if i use State Monad, i still need global object store initial value, then use modify update object state. Right?
08:06:59 <wli> I'm thinking something like a worklist, a seen set for things outside the worklist range, and a frontier set.
08:07:44 <ManateeLazyCat> maltem: I just want function generate increase ID number, i just use it in *one* module.
08:08:25 <maltem> ManateeLazyCat, right, in the state monad you have an initial state (e.g. 0) that you can "get", "put", and "modify" (which are the names of the functions involved)
08:09:25 <wli> One thing it may be possible to do is to try to knock out everything in the worklist dominated by some other number.
08:09:55 <maltem> ManateeLazyCat, for example, ‚Äúmodify (+1) >> get‚Äù will increment the number state, then return the incremented number
08:12:05 <wli> So, for instance, find the image of the interval under the Collatz step mapping, partition that image into the part disjoint with the original interval and the part intersecting it, and then knock out all candidates based on that since everything in the intersecting part of the image dominates something in the disjoint part of the original interval.
08:12:26 <ManateeLazyCat> maltem: And every state is new value? I mean Haskell create a new object to store a new state, even i use `modify'?
08:13:14 <maltem> What do you mean?
08:13:24 <wli> Everything between 1 and 500K, for instance, is dominated by its double which still lies within the original search interval.
08:16:01 <mmorrow> wli: i was intrigued by your IntMap collatz talk: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2085#a2085
08:16:10 <ManateeLazyCat> maltem: I mean `State Monad' create a new object (such as a new memory address) to return new state when i use `modify' function modified state?
08:16:23 <wli> Of the ones between 500K+1 and 10^6 any n congruent to 1 mod 3 is dominated by (n - 1) `div` 3
08:16:55 <mmorrow> (i used a threshold of 1000000 there above which i didn't add the length to the map)
08:17:02 <ManateeLazyCat> maltem: State infact is a *list*, and element of *list* is a State, right?
08:18:58 <maltem> ManateeLazyCat, er, what list?
08:19:39 <wli> mmorrow: I can't figure out what's going on there.
08:22:30 <mmorrow> the 't' param the is threshold above which not to memoize, and 'len' takes an IntMap, a thresh, and a starting number, and returns the length of the sequence gotten by iterating collatz until 1 is reached
08:23:01 <mmorrow> longest just folds len over an input list, accumulating the memoizing IntMap and the max length seen
08:23:11 <wli> okay
08:23:30 <mmorrow> the letrec in 'len' in the Nothing case is the highlight i suppose
08:23:30 <ManateeLazyCat> maltem: Example, I initial State object `A' with 0, when i `put' `A' with 1, and now `A' new state is `1', but Haskell use a new object to maintain new state `1', didn't change anything about original state '0'?
08:24:44 <bremner> ManateeLazyCat: are you worried about performance, or just understanding monads?
08:25:03 <ManateeLazyCat> bremner: Just understand monads.
08:25:10 <EvilTerran> ?go you could have invented monads
08:25:11 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
08:25:12 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
08:25:27 <EvilTerran> ^ explains quite nicely how the State monad works
08:25:28 <maltem> ManateeLazyCat, conceptually, the 0 isn't changed. Practically, it may be garbage collected at some later point in time.
08:25:42 <bremner> ManateeLazyCat: yeah, nothing is really being mutated in the State monad IIRC. But it could be in a different monad.
08:26:06 <wli> mmorrow: Hmm, ISTR a different answer.
08:26:13 <mmorrow> ruhroh
08:26:33 <maltem> ManateeLazyCat, also, the state monad user has no access to old states, so you might as well say that the old state has been overwritten. (Conceptually!)
08:26:37 <wli> mmorrow: 837799
08:26:45 <mmorrow> hmm
08:28:17 <EvilTerran> ManateeLazyCat, that uses the specific example of storing the current seed (a StdGen) for a random number generator as state; you can generalise from that to general state
08:28:21 <ManateeLazyCat> maltem: So `State Monad' just give me feeling i modified `State value', but Haskell is create New State (new memory addres object), and use GC collected the *old* `State', right?
08:28:25 <mmorrow> hmm, weird. yeah, len says 837799 has len 525
08:28:59 <EvilTerran> ManateeLazyCat, because this is pure haskell, nothing is being actually modified, in terms of the semantics
08:29:32 <maltem> ManateeLazyCat, right
08:29:46 <snigel_> Hi, anyone knows this error? `[]' is not applied to enough type arguments ?
08:29:52 <snigel_> isChild :: [] -> [Family] -> [Name]
08:30:02 <mmorrow> wli: hmm, i don't see the error
08:30:12 <wli> mmorrow: I don't either.
08:30:21 <snigel_> it complains about that row.
08:30:23 <snigel_> I don't get it.
08:30:27 <EvilTerran> snigel_, that type means "take a list of and a list of Families, and return a list of Names"
08:30:35 <maltem> snigel_, [] is not a type
08:30:59 <snigel_> maltem: ah of course. stupid me.
08:31:00 <EvilTerran> [] means "list of" in types; you have to specify what type of values contains
08:31:01 <snigel_> thanks.
08:31:02 <EvilTerran> *it
08:31:04 <ManateeLazyCat> maltem: And i think Haskell will waste too much memory, because GC just release memory when *old* State haven't any object point to it.
08:31:49 <maltem> ManateeLazyCat, the point of the state monad is that nothing points to the old state
08:31:53 <gwern> whoa. this is a major change for lhc
08:32:00 <EvilTerran> gwern, ?
08:32:01 <gwern> 'We're no longer a fork of JHC. Maintaining a complete Haskell front-end was too much of a hassle, especially considering we're only interested in optimization on the GRIN level. For this reason, LHC has reinvented itself as an alternative backend to the Glorious Glasgow Haskell Compiler.
08:32:33 <mmorrow> wli: maybe the letrec is borked in some weird way so that the length of 837799 doesn't come back as 525 when the map has the state it has after 1000000...837799
08:32:52 <pejo> ManateeLazyCat, you don't know how the compiler will optimize your written code.
08:32:54 <wli> mmorrow: There are Int overflows to be concerned about
08:32:55 * mmorrow googles for the real answer
08:33:11 <mmorrow> wli: hmm, what could be overflowing though?
08:33:12 <wli> mmorrow: project euler says 837799
08:33:18 <mmorrow> but the length?
08:33:22 <pejo> gwern, where does it say that?
08:33:23 <wli> mmorrow: I've done this before via the ordinary knot-tying.
08:33:39 <ManateeLazyCat> pejo: I don't know details of Haskell compiler, just for understand Monad.
08:33:40 <wli> mmorrow: The numbers above the caching threshold.
08:33:42 <gwern> planet haskell
08:34:00 <mmorrow> wli: oh. are you saying the length *starting* at 837799 is the longest, or that 837799 *is* the longest length?
08:34:16 <wli> mmorrow: The length starting at 837799
08:34:21 <mmorrow> heh, ok.
08:34:47 <jmcarthur> gwern: woah!
08:34:57 <mmorrow> oh, i think i have a fencepost error
08:35:07 <gwern> the posting isn't clear tho
08:35:15 <gwern> what's doing the Core->GRIN stuff? LHC?
08:35:21 <mmorrow> hmm, no
08:35:38 <pejo> gwern, everything haskell.org is extremely slow for me. Have a direct url?
08:35:45 <pejo> gwern, (is it slow for you too?)
08:35:50 <jmcarthur> yeah haskell.org is going sucky for me
08:36:15 <gwern> pejo: well I saw it in google rss reader
08:36:16 <gwern> no idea
08:36:19 <maltem> gwern: evidently core->grin is done by LHC?
08:37:01 <jmcarthur> http://lhc-compiler.blogspot.com/
08:37:13 <jmcarthur> pejo: ^^
08:37:14 <mmorrow> wli: i can't figure it out
08:37:25 * mmorrow saves it for later :)
08:38:11 <wli> mmorrow: There should be ways to blow away large fractions of the search space...
08:38:24 <pejo> jmcarthur, thanks. lhc isn't exactly easy to google for.
08:38:37 <thomastc> heh :)
08:39:05 <jmcarthur> yeah, there isn't much description of the architecture there...
08:39:57 <jmcarthur> ah yes, LHC does the Core->GRIN
08:40:27 <jmcarthur> http://lhc-compiler.blogspot.com/2009/04/new-beginning.html?showComment=1239448020000#c3298433689872708560
08:41:14 <wli> mmorrow: For starters, only [k | k <- [10^(6::Int), 10^(6::Int) - 1 .. 5*10^(5::Int) + 1], k `mod` 3 /= 1] are possibly candidates for the result.
08:41:51 <jmcarthur> heh, a graphic by dons http://galois.com/~dons/images/lhc.svg
08:42:04 <jmcarthur> that's a lot of transformations
08:42:10 <jmcarthur> major ones, i mean
08:42:57 <ManateeLazyCat> Thanks all for detail describe! :)
08:44:16 <wli> Then there are two-step dominations, n-step dominations.
08:45:12 <mmorrow> wli: got it. i was applying the continuation incorrectly
08:45:27 <mmorrow> i just ditched it and used a let in the above the threshold case
08:45:51 <pejo> Lemmih, would you like to expand some more on the lhc news?
08:46:03 <benmachine> can anyone explain to me what the purpose of the integer argument to readsPrec is?
08:46:35 <mmorrow> haha, and sharing the l+1 saves me 7 seconds :)
08:47:15 <Axman6> benmachine: it's a sekrit
08:47:30 <benmachine> :(
08:48:10 <mmorrow> wli: fixed and from 9.9 seconds to 2.6 http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2085#a2086
08:48:39 <mmorrow> (837799,525)
08:49:34 <mmorrow> wli: amazingly adding "l' = l+1" to the letrec instead of computing (l+1) twice shaves off 7 seconds
08:50:18 <mmorrow> that's friggin crazy
08:51:59 <mmorrow> bringing the threshold down to 100000 shaves off another second
08:52:19 <mmorrow> (but down to 10000 brings it back up to the same time as with 1000000)
08:52:28 <wli> second-order dominators need 2*n congruent to 1 mod 3 and have to be small enough, so 500K+3 dominates 750K+5 by that token.
08:53:09 <mmorrow> wli: oh, just saw your above
08:54:53 <wli> I'm trying to see if there's some way to avoid computing lengths and/or maybe even carrying around big tables.
08:55:22 <mmorrow> wli: hmm
08:55:36 <mmorrow> benmachine: it's for whether or not to parenthesize it
08:56:22 <wli> The singlepass fold is slick though.
08:56:30 <mmorrow> , fmap (\n -> showsPrec n (Just 42) []) [9..12]
08:56:32 <lunabot>  ["Just 42","Just 42","(Just 42)","(Just 42)"]
08:56:52 <mmorrow> wli: yeah, it is nice
08:57:22 <mmorrow> wli: i wonder what the optimal threshold is
08:58:07 <mmorrow> i think i'm gonna brute force it a little later and graph (threshold,time)
08:58:15 <benmachine> mmorrow: ok, thanks
08:58:19 <mmorrow> that should be interesting
08:59:02 <lysgaard> Hm.. I've got this problem installing haskell jack libraries. It needs st.h and i can't find it. I believe it orgins to the sox project but i cant find the header file in the CVS
08:59:08 <wli> I think you can do something like build up big congruences or something.
08:59:49 <wli> Or congruence/inequality combinations.
09:01:11 <wli> There's the moderately vague idea I've got floating around that progressively filtering out more of the field of candidates does something useful.
09:02:40 <wli> The general form of what I have thus far is that the starting field of candidates for [1 .. x] can be thinned to [y | y <- [x `div` 2 .. x], y `mod` 3 /= 1]
09:05:23 <wli> The trick there is that the memo table is immediately near-useless since the collatz steps carry everything there out of that range.
09:06:26 * shapr boings
09:08:45 <Meinte> Why have i never heard of Haskell
09:09:12 <tomh> you did, else you wouldn't join here
09:09:30 <Meinte> ./list
09:09:33 <wli> On a second forward step, the even numbers are noninformative since it's already been taken into account that they dominate their halves, and the odd numbers blow past the range. So that second forward step only needs to triple the odd numbers.
09:09:48 <edwardk> Meinte: that was my reaction at first too ;)
09:09:52 <shapr> Meinte: Well, you'll probably enjoy Haskell, welcome to this spiffy world!
09:10:16 <shapr> Meinte: You should try the lambdabot, and the wiki, and play with all the goodies on Hackage.
09:10:30 <shapr> I'm just installing the jack bindings myself.
09:10:45 <wli> On a second backward step, all the candidates' doubles are generated, and the division by 3 is noninformative.
09:10:59 <Meinte> :) I will
09:11:01 <shapr> lysgaard: Did you figure out which lib is required for st.h?
09:11:04 <shapr> Meinte: Got any questions?
09:11:53 <lysgaard> shapr: You mean wich library needs st.h? Thats the cabal package jack
09:11:57 <Meinte> Not really :)... I'll first figure some thing out on my own
09:11:58 <wli> So the second step wants to see where 3*n+1 for an odd n meets 2*n' for n, n' in the initial candidate set.
09:12:06 <shapr> lysgaard: Right, but which package has st.h? Did you find any info?
09:12:29 <shapr> Meinte: Ok, feel free to ask any questions. Oh, and check out http://book.realworldhaskell.org/ if you want to learn much in a short time.
09:12:52 <lysgaard> Nope, nothing at all, that's my problem. I've been googeling for hours
09:12:55 <shapr> frustrating.
09:13:00 <shapr> Who wrote the package?
09:13:23 <shapr> Ah, Henning Thielemann
09:15:00 <Meinte> thanks shapr
09:18:00 <wli> The next step is start = [k | k <- [10^(6::Int), 10^(6::Int) - 1 .. 5*10^(5::Int) + 1], k `mod` 3 /= 1, case (2*k) `divMod` 3 of { (q, 1) | q <= 10^(6::Int) -> False ; _ -> True} ] :: [Integer]
09:18:59 <wli> That list has only 166667 elements.
09:19:21 <lysgaard> shapr: http://linux.die.net/man/3/libst
09:19:47 * EvilTerran ponders how to best represent lambda calc w/ a set of constants/combinators (and a set of equations describing those constants' semantics)
09:19:58 <shapr> lysgaard: I don't see anything like that in debian/unstable
09:20:47 <monochrom> The semantic equations may suggest an interpreter.
09:21:05 <lysgaard> shapr: Nope, not in arch either, wich is what i use :/
09:21:48 <b_jonas> EvilTerran: well, the SKI calculus is ever popular
09:22:25 <b_jonas> the equations are I x = x; K x y = x; S x y z = x z (y z);
09:22:31 <gwern> b_jonas: no, he needs to do it with birds!
09:23:00 <wli> EvilTerran: data Expr = LitInt Integer | LitFlo Double | LitChr Char | IntCase Expr (Map Integer Expr) Expr | FloCase Expr (Map Double Expr) Expr | ChrCase Expr (Map Chr Expr) Expr | Case Expr (Map String (Map String String, Expr)) | Con String (Map String Expr) | Let (Map String Expr) Expr | Lam String Expr | App Expr Expr ?
09:23:05 <b_jonas> gwern: but I and K and S are words
09:23:15 <gwern> or maybe crocodiles and alligators
09:23:28 <b_jonas> gwern: yes, those too
09:23:31 <b_jonas> and eggs
09:23:46 <gwern> eggs are delicious and very appropos for the season
09:23:49 <bavardage> can anyone name some 'algorithms' for matching things to user preferences
09:23:57 <bavardage> I haven't really got any ideas how to approach thing
09:23:59 <bavardage> *this
09:24:14 <shapr> gwern: Colored crocs?
09:24:18 <bavardage> I have a list of tv programmes, and want the user to specify what they want in some way (keywords or something)
09:24:35 <gwern> shapr: they wouldn't go with the colored eggs
09:24:36 <b_jonas> I once defined a language syntax where let and case were the same, but that's of course because it's a strict language so they really are the same
09:24:39 <shapr> Oh
09:25:14 <shapr> bavardage: Sounds like you just solved your problem! Keyword search?
09:25:22 <EvilTerran> wli, that's rather more than lambdacalc + constants O.o
09:25:28 <gwern> no. regexps
09:25:34 <gwern> regexps make everything better
09:25:35 <shapr> Now you have TWO problems!
09:25:39 <gwern> or at least let you mock the user
09:25:45 <b_jonas> shapr++
09:25:46 <wli> EvilTerran: Okay
09:25:47 <bavardage> shapr: yeah but then what :D
09:25:52 <shapr> bavardage: Then you search?
09:26:05 <bavardage> nono but I mean soo.. I have a load of thinsg which match keywords
09:26:06 <bavardage> then what
09:26:08 <gwern> 'good grief, you could've done that with just '\[$-Z]*.?^_^', why are you bothering us'
09:26:08 <bavardage> how do I rank them
09:26:14 <bavardage> hehe
09:26:18 <bavardage> and yeah in haskell
09:26:21 <bavardage> to regex or not to regex
09:26:34 <bavardage> and then some sort of weighted rank
09:26:36 <shapr> Well, you rank them according to how many of the keywords they match?
09:26:42 <bavardage> yeah I guess
09:26:51 <EvilTerran> b_jonas, wli, parhaps a little more context would clarify; i'm planning on writing something that lets me reason equationally with expressions in the language
09:27:00 <bavardage> giving different weightings to keywords matching in different places
09:27:01 <bavardage> etc
09:27:03 <bavardage> so right
09:27:06 <bavardage> regular expressions?
09:27:11 <bavardage> or are there other methods in haskell
09:27:12 <shapr> I think that was a joke.
09:27:14 <wli> EvilTerran: I may be closer than you want me to be.
09:27:16 <shapr> regexes
09:27:21 <shapr> Yeah, tail inits!
09:27:23 <shapr> or something
09:27:32 <EvilTerran> with an eventual thought to maybe being able to manipulate haskell the same way, yeah, but i thought i'd start smaller
09:28:04 <b_jonas> I don't know how these proof systems work so I can't help here.
09:28:13 <orbitz> i swore there was a List.isInfixOf but it seems to not be there
09:28:26 <shapr> lysgaard: It's not libsox-dev either, sadly.
09:28:30 <pejo> EvilTerran, would that something guarantee correct transformations?
09:28:35 <Heffalump> orbitz: it was introduced in GHC fairly recently
09:28:39 <Heffalump> so probably isn't in 6.6
09:28:40 <EvilTerran> and, by "smaller", i mean "leaving out numeric constants, string constants, etc and the necessary palaver to use them for now"
09:28:44 <Heffalump> and perhaps not even in 6.8, I forget
09:28:53 <orbitz> Heffalump: i'm on 6.10.1
09:28:59 <gwern> @hoogle isInfix
09:29:00 <lambdabot> Data.ByteString isInfixOf :: ByteString -> ByteString -> Bool
09:29:00 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
09:29:00 <lambdabot> Data.ByteString.Char8 isInfixOf :: ByteString -> ByteString -> Bool
09:29:09 <Heffalump> then it should definitely be there
09:29:22 <shapr> lysgaard: I dunno, I give up. I emailed Henning Thielemann, perhaps he'll know.
09:29:33 <EvilTerran> pejo, yeah, that's the plan. i figure it'd basically be a proof assistant, only with lambda calc instead of predicate logic
09:29:38 <orbitz> ohh there it is
09:29:42 <orbitz> Heffalump: i was in List not Data.List
09:29:52 * b_jonas saves his module to http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2087 just to be safe
09:31:15 <bavardage> so, alternatives to regex?
09:31:45 <EvilTerran> and rather than "a => b => c => ...", it's "a ->_{\beta} b ->_{\beta} c ..." (or "a = b = c = ...")
09:32:12 <wli> mmorrow: One can start from each point and backward chain the n-th order dominators, say via iterate with backward iteration. Once there is a dominator in range the number may be filtered out. So you've got [(Integer, [Set Integer])] and at each iteration, you filter out where the top of the stack has Set.findMin less than the upper bound (10^6 in PE) and pop off the top of the stack.
09:32:40 <lysgaard> shapr: Thanks alot for your help anyways. I've used 3-4 hours on finding that library but haven't gotten anything. Gotta be a quite rare lib.
09:33:36 <roconnor> RayNbow: :)
09:37:25 <gwern> @where zlib
09:37:25 <lambdabot> http://code.haskell.org/zlib/
09:38:47 <gwern> @tell dcoutts next release of zlib, be nice to mention the repo address of http://code.haskell.org/zlib/
09:38:47 <lambdabot> Consider it noted.
09:38:51 <gwern> @flush
09:47:41 <bmh> hey #haskell
09:48:17 <wli> Hmm. ghci masks signals while doing tty IO it seems.
09:48:51 <wli> So basically any infinite loop that prints all the while is unstoppable save by killing it from elsewhere.
09:48:53 <Saizan> hey bmh
09:50:09 <bmh> unboxed arrays v. diff arrays. I assume that the constants associated with diff arrays are several orders of magnitude greater than those associated with unboxed?
09:50:38 <Saizan> they are quite slower, yeah
09:51:23 <Saizan> noone optimized them in recent times, so it's hard to find an use-case where they are a win
09:51:55 <bmh> are there unboxed mutable arrays?
09:52:00 * bmh engages in premature optimization
09:52:02 <EvilTerran> yes
09:52:14 <Saizan> yes, STUArray or IOUArray
09:52:29 <bmh> those seem like sensible names :)
09:52:36 <Saizan> but even UArrays are quite fast
09:53:13 <wli> I'm desperately hoping I can salvage the command line I hammered in that looped because it's only a very small modification to fix.
09:54:11 <bmh> I found something amusing in the System.Random source. In the instance declaration for Random Float:
09:54:15 <bmh> -- hah, so you thought you were saving cycles by using Float?
09:54:48 <wli> Maybe it's a tty control affair. Can kill -INT externally halt the loop without bringing the interpreter down?
09:55:01 <tomh> question about the "silly" function here http://www.haskell.org/haskellwiki/GADT, the error is because the y doesn't match right for silly in List x y ?
09:55:30 <Saizan> wli: with a few ^C i can usually get back to the ghci prompt
09:56:00 <wli> Saizan: It seems to be ignoring signals.
09:57:35 <deech> Beginner's Question: How do I print the value a protected mutable TVar variable? I tried to print a bank balance with the following code [1] but I get errors. [1] http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3664#a3664
09:57:39 <Saizan> tomh: yeah, you can't unify List a Empty and List a NonEmpty
09:57:40 <wli> kill -INT of the thing's pid didn't work either.
09:57:50 <tomh> ok thanks
09:59:25 <Saizan> deech: you need "atomically (printBalance somethinghere)"
09:59:27 <lysgaard> I'm having this problem installing supercollider-midi. I dunno what the compiler is complaining about but seems to be a quite generic error: http://hpaste.org/fastcgi/hpaste.fcgi/save
09:59:44 <Saizan> deech: but note that bankBalance will return a new TVar each time
09:59:49 <lysgaard> Sorry: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3665#a3665
10:00:25 <gwern> interesting error
10:00:53 <Saizan> lysgaard: which version of ghc?
10:01:19 <lysgaard> Saizan: 6.10.1
10:01:32 <Cale> lysgaard: It looks like an instance defined in that version of the array library which it's installing conflicts with an instance in the base library.
10:01:41 <gwern> well, yeah
10:01:45 <gwern> but what's the fix?
10:01:54 <vixey> preflex: seen jkff
10:01:54 <preflex>  jkff was last seen on #haskell 22 days, 2 hours, 30 minutes and 35 seconds ago, saying: Not all of them. There was a thread in haskell-cafe that provided counterexamples: iirc, they were about Either
10:01:59 <vixey> that's weird
10:02:19 <Cale> Either choosing a different version of the code, or else likely removing the excess instance.
10:03:44 <maltem> Looks like the requested package depends on a version of array that is newer than what is compatible with the installed base.
10:03:48 <lysgaard> My ghc package includes array ver 2.0
10:03:57 <Saizan> lysgaard: i think you should remove the && < 0. constraint for the array library in supercollider-midi.cabal and try if it still compiles with array-0.2
10:04:00 <maltem> er, or rather, older
10:04:19 <Saizan> *"&& < 0.2"
10:04:23 <lysgaard> Ok, i'll try
10:04:23 <gwern> hm. my error is with array itself
10:04:30 <gwern> same error tho
10:04:43 <deech> Saizan: Awesome thanks! But is there a better way? Why do I have to be in the STM monad when I'm only reading a value?
10:04:50 <Saizan> his error comes from bulding array too
10:04:56 <gwern> looks like henning will be getting some emails
10:05:26 <Saizan> deech: because what's in that value at that point depends on the interaction with the other transactions
10:06:01 <Cale> deech: The STM monad is for composing transactions which the system will maintain the illusion of happening all at once
10:06:15 <alexsuraci> With Parsec the compiler keeps asking for an instance for (Stream s m Char), but I can't find anywhere that implements that. Any ideas?
10:06:17 <Cale> deech: 'atomically' will turn STM actions into IO actions
10:06:30 <Saizan> well, the illusion of happening sequentially
10:06:56 <maltem> Saizan, "all at once" as in "nothing interferes"
10:07:19 <deech> Saizan, Cale: I see ... so once I read that value how do I pass it to a pure function? For example once I've read my bank balance I want to pass to a pure function that outputs the value in Yen.
10:07:24 <bremner> maltem: atomically is the word for that :-)
10:07:37 <Saizan> alexsuraci: try with {-# LANGUAGE NoMonomorphismRestriction #-}
10:07:40 <Cale> deech: Are you already familiar with normal IO in Haskell?
10:07:45 <Cale> deech: It's just the same.
10:07:48 <deech> Cale: Yes
10:07:56 <maltem> bremner: Really??? ;P
10:08:16 <deech> Cale: Oh ok, I see, so there is no real escaping from the STM Monad, just like IO
10:08:40 <Saizan> you can only go from STM to IO via atomically
10:08:42 <Cale> "escaping"
10:08:46 <alexsuraci> Saizan: That did it, thanks.
10:08:49 <wli> The erroneous assumption here is that longer chains imply a dominance relation; however, I seem to be getting results suggesting that 10 iterations are equivalent to the second-order backward chaining I mentioned.
10:09:31 <deech> Saizan, Cale: I think I understand it better now. Thanks!
10:10:55 <wli> IOW I think the affair has stabilized after merely second-order backward chaining, and accumulation loops' comparisons only need traverse the lengths of those.
10:12:04 <Saizan> alexsuraci: the other option is to annotate your parsers so that it knows which instance of Stream you want, e.g using the Parser type synonim
10:14:38 <jberryman> Just wrote up a GHC feature request email, without realizing I couldn't send it to the list. so I pasted it here: http://txtb.in/2eh  ... would appreciate any feedback.
10:17:24 <lysgaard> Saizan: I doesn't work even if i remove all the dependencies in the package, i get: Could not find module `Sound.OpenSoundControl.Transport.Monad': it is a member of package opensoundcontrol-ht-0.1, which is hidden
10:18:38 <Saizan> lysgaard: you must not remove dependencies
10:19:06 <Saizan> lysgaard: Cabal allows only modules coming from the dependencies to be imported from the code
10:19:27 <Saizan> lysgaard: you should only try to relax the dependency on array, so that it can use the installed one
10:20:05 <sjanssen> jberryman: it'd probably be better received if you provided rules for desugaring the new construct
10:20:18 <maltem> jberryman, maybe submit it to the ghc ticket tracker if you don't want it to be overlooked
10:22:04 <lysgaard> Saizan: Hm.. then i think i've done something wrong. How should i edit the cabal file of supercollider-midi to let it compile?
10:23:00 <jberryman> sjanssen: that's something I'm pretty ignorant about. I'll read up about that
10:24:03 <sjanssen> jberryman: just an informal rule to translate between the sugar to more basic syntax would be enough
10:24:24 <sjanssen> jberryman: see the report's definition of regular list comprehensions for an example
10:25:36 <jberryman> sjanssen: thanks, maybe a better syntax will be apparent when I look at that
10:26:34 <Saizan> lysgaard: on the line "Build-Depends: base >= 2, array >=0.1 && <0.2, containers >=0.1 && <0.2, random >=1.0 && <1.1
10:26:51 <ddarius> As far as I can tell, unless (perhaps) you have a rather complicated mix, parallel list comprehensions are worse than simply using zip.
10:27:01 <Saizan> lysgaard: replace "array >= 0.1 && < 0.2" with "array >= 0.1"
10:27:10 <Saizan> lysgaard: then run "cabal install" from that directory
10:27:24 <ddarius> everyThird xs = [x | (x,c) <- zip xs (cycle [1..3]), c == 1]
10:28:19 <lysgaard> Saizan: Ah, i tried to run cabal configure afterwards, then it got all crazy.
10:29:28 <Saizan> lysgaard: configure only considers the packages installed, not the ones on hackage
10:30:26 <lysgaard> Saizan: I see ;)
10:31:29 <jberryman> ddarius: maybe I hould have used the example of taking elements of a list that have an index which is a power of two:
10:31:32 <jberryman> > let f lst = [ b'  |  (x',b') <- [ (x,b) | a <- iterate (*2) 1, x <- [a, pred a..1] | b <- tail lst ], x' == 1 ] in f [1..10]
10:31:33 <lambdabot>   [2,4,8]
10:32:54 <jberryman> which could be expressed as: [ b, x' == 1  | a <- iterate (*2) 1, x <- [a, pred a..1] | b <- tail lst  ]
10:33:04 <jberryman> ...maybe
10:36:35 <ddarius> > let f lst = [b' | (x,b) <- zip [x | a <- iterate (2*) 1, x <- [a, pred a .. 1]] (tail lst), x == 1] in f [1..10]
10:36:36 <lambdabot>   Not in scope: `b''
10:36:41 <ddarius> > let f lst = [b | (x,b) <- zip [x | a <- iterate (2*) 1, x <- [a, pred a .. 1]] (tail lst), x == 1] in f [1..10]
10:36:43 <lambdabot>   [2,4,8]
10:37:18 <ddarius> > let f lst = [b | (x,b) <- zip (iterate (2*) 1 >>= \a -> [a, pred a .. 1]) (tail lst), x == 1] in f [1..10]
10:37:20 <lambdabot>   [2,4,8]
10:43:05 <lysgaard> Saizan: I got it working :D
10:43:22 <Saizan> lysgaard: cool :)
10:43:49 <Saizan> lysgaard: you might mail the maintainer to update the deps in a new release
10:55:59 <desp> Ugh.
10:56:05 <desp> I have an odd problem with interact...
10:58:23 <desp> > map (map read . words) (lines "1 2\n3 4") :: [[Int]]
10:58:25 <lambdabot>   [[1,2],[3,4]]
10:58:27 <desp> > map (map read . words) (lines "1 2\n3 4\n") :: [[Int]]
10:58:28 <lambdabot>   [[1,2],[3,4]]
10:59:12 <vixey> :t (map . map) read . (words . lines)
10:59:14 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
10:59:14 <lambdabot>       Expected type: String -> String
10:59:14 <lambdabot>       Inferred type: String -> [String]
10:59:54 <Saizan> :t (map . map) read . map words . lines
10:59:56 <lambdabot> forall b. (Read b) => String -> [[b]]
11:00:35 <Saizan> desp: that's too much suspanse, what's the error?
11:01:13 <desp> Saizan: one second, I'm trying to reproduce it in a small example
11:01:32 <desp> I think the trailing \n makes a difference for interact, somehow.
11:01:55 <dons> ?yow
11:01:55 <lambdabot> I'm young ... I'm HEALTHY ... I can HIKE THRU CAPT GROGAN'S LUMBAR REGIONS!
11:02:04 <Heffalump> hi dons
11:05:06 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3671#a3671
11:06:23 <desp> Here's the difference in behavior:
11:06:24 <desp> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3671#a3672
11:06:34 <dons> saturdays. the day of plans and schemes
11:06:39 <desp> Can someone explain this?
11:06:46 <desp> Saizan: ping :)
11:07:05 <Saizan> > lines "\n\n"
11:07:07 <lambdabot>   ["",""]
11:07:16 <Saizan> > lines "foo\n\n"
11:07:18 <lambdabot>   ["foo",""]
11:07:29 <desp> Ah, echo -n.
11:07:42 <Saizan> yeah
11:07:52 <desp> Thanks, I feel silly now.
11:08:55 <Saizan> np :)
11:09:08 <Berengal> Hi, I'm looking for golfing tips
11:10:01 <dons> ok.
11:10:04 <dons> have you used @pl ?
11:10:14 <dons> @pl (\x -> x + 1) 2
11:10:14 <lambdabot> 3
11:10:19 <dons> @pl (\x -> x + 1) id
11:10:19 <lambdabot> 1 + id
11:10:28 <pumpkin> @pl \q w e r t y -> y t r e w q
11:10:29 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
11:10:47 <Berengal> I have, it helped some
11:10:57 <Berengal> I'm trying to golf a basic calculator
11:11:06 <pumpkin> Berengal: maybe you need ***/&&&/first/second ?
11:11:13 <pumpkin> those are nice golfing functions ;)
11:11:17 <pumpkin> that @pl doesn't know about
11:11:34 <Berengal> Yeah, I've got those as well. The problem is parsing the operators
11:11:49 <Berengal> Right now I've just got a big lambda case expression
11:11:57 <Berengal> Also, / needs to divmod...
11:12:07 <Berengal> So I need to throw lots of &&& const Nothign
11:12:22 <Berengal> Or at least I think so
11:12:45 <pumpkin> :o
11:12:46 <pumpkin> ?
11:13:14 <Berengal> Part of the case: "*"->uncurry(*)&&&const Nothing;"/"-> second Just .uncurry divMod;
11:13:34 <Berengal> At least that's what I've got so far
11:13:35 <alexsuraci> What's the preferred way to use mutable state in Haskell? Using IORef? (e.g. for implementing a language)
11:14:29 <pumpkin> use STRef if possible
11:14:38 <pumpkin> stops you from polluting all your code with IO
11:15:55 <cognominal> instead of executing some 'do' code, I want to pass it as a parameter? what is the syntax to do that?
11:16:45 <alexsuraci> pumpkin: thanks, taking a look
11:17:14 <pumpkin> cognominal: ?
11:17:35 <pumpkin> Berengal: I don't get that
11:17:44 <pumpkin> :t uncurry(*)&&&const Nothing
11:17:45 <lambdabot> forall a a1. (Num a) => (a, a) -> (a, Maybe a1)
11:17:49 <ClaudiusMaximus> > length [ do{ a <- getChar; return a}, do{ putChar 'c'; return 'c' } ]
11:17:50 <lambdabot>   2
11:18:08 <pumpkin> Berengal: oh, you want to pass the remainder around?
11:18:20 <Berengal> > (uncurry(*)&&&const Nothing) (4, 6)
11:18:21 <lambdabot>   (24,Nothing)
11:18:27 <Berengal> Yeah
11:18:34 <pumpkin> why Maybe Int instead of just 0?
11:18:38 <pumpkin> I mean,
11:18:45 <dons> alexsuraci: STRef and STUArray
11:19:06 <Berengal> Well, 0 IS a valid remainder...
11:19:28 <Berengal> It's just a basic calculator, calculating strings on the form "123 * 321"
11:19:29 <pumpkin> Berengal: what's stopping you from just passing that around then?
11:20:21 <cognominal> pumpkin,  in yi I have implemented a read-only buffer mode, now I need to wrap code so that it execute in rw mode
11:20:31 <Berengal> Because multiplication doesn't have a remainder. Using that I can't tell the difference between the divmod operator and the others when the time to print comes
11:21:06 <cognominal> so where a 'do' block was executed, now it will passed as a parameter to my wrapper
11:21:25 <kadaver> does Cobol have pointers?
11:21:31 <cognominal> pumpkin, does what I say make sense?
11:21:35 <Berengal> Showtime: show***maybe""((' ':'r':).show)
11:21:48 <pumpkin> cognominal: I don't know anything about yi unfortunately
11:21:52 <bremner> kadaver: is this #cobol ? :-)
11:21:55 <Berengal> So "10 / 5" prints "2 r0"
11:22:08 <Trafalgard> does Cobol have dinosaurs?
11:22:35 <cognominal> pumpkin,  I explain the context, but my question is really unrelated to yi
11:22:35 <pumpkin> Berengal: what does (10 / 6) / 3 return?
11:22:45 <Berengal> it doesn't. Too many operators :P
11:22:50 <pumpkin> oh
11:23:15 <pumpkin> if you're just working immediately, I don't see why you need to keep a remainder
11:23:29 <pumpkin> keep it in a structure that is
11:23:33 <pumpkin> just print it out when you calculate it :P
11:23:54 <pumpkin> as far as I can see, there's no meaningful interpretation of passing a remainder along
11:24:16 <Berengal> Can I copypaste the code I've got? It's... uh... a one-liner, but about 300 chars long
11:24:23 <pumpkin> @paste
11:24:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:24:25 <pumpkin> :)
11:24:39 <pumpkin> it'll highlight the syntax and be more readable
11:24:46 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3673#a3673
11:24:56 <Berengal> I think readable isn't the right word...
11:24:57 <pumpkin> cognominal: I don't understand "passed as a parameter to my wrapper"
11:25:07 <pumpkin> oh god :P
11:25:27 <kadaver> Berengal: break it up int smaller ones and you might find it yourself
11:25:27 <pumpkin> you'd definitely save space by doing as I said
11:25:51 <pumpkin> all those &&&const Nothing s are wasting space only because of your division
11:26:00 <pumpkin> the other operations shouldn't have to compensate for it :P
11:26:12 <Berengal> Yes, I know, that's the crux of the problem
11:26:41 <Berengal> I mean, it's still shorter than the python variants I've seen (which doesn't abuse eval)...
11:27:42 <pumpkin> ahem: head.tail&&&head&&&head.tail.tail
11:27:43 <Berengal> I don't really see how I could get rid of the nothings though... I could put show code into the functions themselves, but that's going to duplicate that instead
11:28:04 <Berengal> Oh, and obfuscation is sort of the point as well...
11:28:07 <Berengal> ;)
11:28:14 <Berengal> (Though not overly)
11:28:19 <cognominal> wrap code = before code after  -- wrapper
11:28:23 <vishwesh> using parsec, how can i seperate a string, say aaaabcbbbabccccabc , to get ["aaa","bbb","ccc"] i.e break the string on seeing a "abc"
11:28:29 <pumpkin> Berengal: replace your (Int, Maybe Int) with Either Int (Int, Int)
11:28:41 <pumpkin> then all your &&&const Nothing s will turn into Left x
11:28:54 <cognominal> then  I have a do bloc, how can I pass it as a parameter to the wrapper?
11:28:57 <pumpkin> and your processor can be an Either
11:29:08 <cognominal> *block
11:29:09 <pumpkin> I mean,
11:29:10 <pumpkin> :t either
11:29:11 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
11:29:28 <Berengal> cognominal: Give your do block a name: "doIt = do ..." and pass that around
11:30:26 <Berengal> pumpkin: I think I see where you're going. I'll check it out...
11:30:41 <Gracenotes> @. djinn type either
11:30:43 <lambdabot> f a b c =
11:30:43 <lambdabot>     case c of
11:30:43 <lambdabot>     Left d -> a d
11:30:43 <lambdabot>     Right e -> b e
11:30:43 * SamB wonders what the heck he should write his macroeconomics paper about ...
11:30:57 <cognominal> Berengal, I want to avoid to name code that will never be called directly
11:31:02 <Gracenotes> SamB: pirates?
11:31:14 <Gracenotes> Somali
11:31:24 <cognominal> I would like it to be an anonymous function
11:31:26 <Gracenotes> why people give them ransom, how they game the system. dunno. :X
11:31:39 <Gracenotes> I'm afraid ninjas don't have much economic sway
11:31:50 <cognominal> but I don't know how to declare a parameterless function.
11:32:02 <pumpkin> there's no such thing :P
11:32:22 <Gracenotes> > (\x y -> x + y) 4954835439109 8358492045
11:32:23 <lambdabot>   4963193931154
11:32:26 <vixey> macroeconomics
11:32:52 <pumpkin> let x = do you will always be my do; oh baby in wrap x
11:33:04 <cognominal>  let toto = (\ -> 1 ) -- does not parse
11:33:18 <pumpkin> cognominal: that's because if it doesn't take a parameter, it isn't a function
11:33:23 <Berengal> or simply "wrap $ do whatever"
11:33:27 <pumpkin> yeah
11:33:51 <sjanssen> pumpkin: I don't think the second ; is legal
11:33:51 <pumpkin> I guess I still don't really get the issue :P
11:34:11 <pumpkin> sjanssen: but I only had one!
11:34:14 <Gracenotes> > (\_ -> 1) "ignored parameter, but still a parameter"
11:34:15 <lambdabot>   1
11:34:21 <pumpkin> sjanssen: it wasn't meant to be a serious suggestion though
11:34:23 <pumpkin> :P
11:34:25 <Gracenotes> in which case you should use (const 1)
11:34:50 <sjanssen> cognominal: Haskell is lazy, there is no need for parameter-less functions
11:35:13 <Berengal> cognominal: What's the type of the wrapper?
11:35:32 <Gracenotes> > let mylist = [0..] in (mylist !! 500) * 2
11:35:34 <lambdabot>   1000
11:35:42 <Gracenotes> ^ infinite list
11:36:16 <monochrom> > let infinite'loop = infinite'loop in head ['c', infinite'loop]
11:36:16 <lambdabot>   'c'
11:36:20 <cognominal> applyBufOpn ‚à∑  BufferM () ‚Üí BufferM ()
11:36:21 <cognominal> applyBufOpn o = do
11:36:21 <cognominal>    ro ‚Üê  getA readOnlyA
11:36:21 <cognominal>    o
11:36:24 <cognominal>    putA readOnlyA ro
11:36:24 <monochrom> ^^ it doesn't bomb
11:36:55 <cognominal> this makes sure that the buffer is rw when 'o' is executed
11:37:03 <pumpkin> applyBufOpn $ do my stuff
11:37:27 <cognominal> ok, I thought the do would be executed instead of being a parameter
11:37:58 <cognominal> happy to be proven wrong :)
11:38:02 <cognominal> I will test it
11:38:32 <Berengal> cognominal: In Haskell, actions are first class values. You can pass them around as you wish, but they will only be executed when put in a sequence with other actions that are also executed (starting with main)
11:47:48 <jelly12gen> i want to filter digits out of a string in to a list  example string 1233hello234"
11:48:30 <vixey> filter isDigit
11:49:09 <jelly12gen> vixey: filter (isDigit) "234hello" doesnt work
11:49:16 <Berengal> import Data.Char
11:49:26 <gnuvince_> > filter isDigit "123abc567"
11:49:27 <lambdabot>   "123567"
11:50:40 <jelly12gen> gnuvince_: ah i forgot to import that :(
11:50:53 <RayNbow> jelly12gen: are you a student?
11:51:07 <RayNbow> (just wondering :p)
11:51:08 <jelly12gen> RayNbow: yes
11:51:14 <RayNbow> TU Delft any chance? :p
11:51:22 <jelly12gen> damn you :D
11:51:26 <RayNbow> :D
11:51:41 <jelly12gen> RayNbow: and you are ?
11:51:44 * ddarius doesn't understand why people put parentheses around identifiers.
11:51:47 <b_jonas> import what?
11:51:52 <jelly12gen> import Char
11:51:54 <b_jonas> @index filter
11:51:54 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, Data.List, Prelude
11:51:58 <b_jonas> oh, isDigit
11:52:00 <b_jonas> I see
11:52:05 <b_jonas>  isDigit
11:52:06 <RayNbow> jelly12gen: a lab course assistant ;)
11:52:08 <b_jonas> @index isDigit
11:52:08 <lambdabot> Data.Char
11:52:31 <jelly12gen> RayNbow: ahah , so you are logging me :D
11:52:50 <RayNbow> not really
11:52:58 <RayNbow> if I logged #haskell, my HD would be full in no time :p
11:53:13 <dan__> > map (\x->2**x) [1,2,3]
11:53:14 <lambdabot>   [2.0,4.0,8.0]
11:53:16 <jelly12gen> RayNbow: are you assistent for the lab course of this year?
11:53:18 <dan__> hey channel
11:53:23 <dan__> can someone tell me how to do that in ML?
11:53:24 <luite> jelly12gen: better not cheat on programmeren and correctheid, he'll find out ;)
11:53:26 <RayNbow> jelly12gen: yes, since Thursday :p
11:53:29 <dan__> i can't find docs :?
11:53:31 <dan__> :/
11:53:57 <jelly12gen> dan__: i dont cheat , and yeah i can google
11:54:27 <jelly12gen> RayNbow: aha , well then i have seen you thursday :D
11:54:32 <dan__> huh
11:54:33 <b_jonas> I don't remember ml anymore
11:54:41 <b_jonas> if you don't get an answer here then try #sml
11:55:33 <b_jonas> "\x->" is spelled "fn x => " in sml
11:55:53 <b_jonas> and map is map in sml as well but I'm not sure if it's in the prelude or the list library
11:56:29 <alexsuraci> hm, is there any way I could do something like "type Env = ST s (STRef s [a])"? It doesn't like the "s"'s in there.
11:56:29 <luite> jelly12gen: you can impress RayNbow by writing all your code in points-free style
11:56:35 <dan__> it's in the prelude
11:56:40 <dan__> map is normally accessible
11:56:41 <dan__> tks
11:56:42 <vixey> type Env s a = ...
11:56:51 <dan__> so i guess
11:57:05 <alexsuraci> vixey: yep, thanks
11:57:16 <ddarius> RayNbow: I believe the logs for the past eight years of #haskell traffic are less than 2 gig.
11:57:17 <alexsuraci> I always get caught by the simple things. :x
11:57:23 <dan__> haskell: map (\x->2**x) [1,2,3]  SML: map (fn x => 2**x) [1,2.3]
11:58:56 <gwern> dan__: [1,2.3]?
11:59:04 <dan__> ;
11:59:16 <dan__> yea why?
11:59:36 <dan__> - map (fn x => 2*x) [1,2,3];
11:59:36 <dan__> val it = [2,4,6] : int list
11:59:37 <gwern> sml really uses two different delim chars in lists?
11:59:43 <dan__> ah
11:59:44 <dan__> sorry no
11:59:45 <dan__> type
11:59:47 <dan__> typo
11:59:58 <dan__> don't have my glasses on
11:59:58 <dan__> etc
12:00:45 <Berengal> Speaking of sml, is it worth learning if you know Haskell?
12:01:19 <ddarius> Berengal: Why not?
12:01:23 <Berengal> i had an introductory course on it last year, but I didn't buy the book, and there were few tutorials available online (at least that I could find).
12:01:25 <dons> it is worth being familiar with.
12:01:25 <araujo> Berengal, very subjective question .... I recommend you to give it a try for yourself :)
12:01:43 <dan__> Berengal, ml has an easier way of dealing with IO
12:01:45 <dan__> in that, it doesn't
12:01:47 <gwern> the only sml stuff I've heard that struck me as interesting  is the module system
12:01:49 <dan__> it has side effects
12:01:55 <Berengal> Well, learning a language takes time, and if it doesn't teach me anything new I don't really see the point of it
12:01:58 <dan__> yea, and it has a real module system
12:02:09 <Berengal> I've got lisp for impure functional programming...
12:02:15 <Berengal> The module system might be interesting...
12:02:20 <dan__> Berengal, you won't learn anything new
12:02:23 <gwern> now, typed scheme has always sounded interesting
12:02:40 <ddarius> Learning any language will teach you something new and is likely to be handy in one way or another.
12:02:40 <dan__> the revision dates for ML are a year older than haskell
12:02:48 <dan__> yet somehow the language syntax is fantastically more clunky
12:03:00 <ddarius> dan__: ML is quite a bit older than Haskell.
12:03:09 <Berengal> During the course i just used Haskell. The assistant wasn't very pleased as he didn't know it, but it was similar enough that I passed. On the exam I simply s/haskell-syntax/sml-syntax/g'ed and passed
12:03:16 <dan__> indeed, but i'm referring to ml 87 and 97
12:03:21 <gwern> ddarius: yeah, but I think we're discussing priorities here - if you already know haskell, how high on the list should be sml?
12:03:34 <dan__> gwern, very low
12:03:40 <dan__> i'm doing it because my prof requires it
12:03:43 <pumpkin> how does ocaml differ from sml?
12:03:56 <dan__> just the object system i think
12:04:03 <dan__> mostly..
12:04:06 <pumpkin> hmm
12:04:06 <ddarius> gwern: "Is it worth learning" is a yes or no question.
12:04:17 <pumpkin> a decision problem!
12:04:20 <b_jonas> my problem with sml is not the side effects, you can avoid those and put them to only a small place of the code if you want.
12:04:21 <EvilTerran> some of the syntax for the same things is a bit different between the two, iirc
12:04:26 <b_jonas> but haskell has a better type system,
12:04:26 <ddarius> pumpkin: There are quite a few differences.
12:04:28 <b_jonas> and more libraries.
12:04:30 <pumpkin> :)
12:04:37 <dan__> yea
12:04:52 <dan__> haskell is one of the few functional languages with good documentation on it's stdlib
12:05:18 <Berengal> The stdlib IS the documentation :P
12:05:18 <pumpkin> dan__: you mean like Monoid?
12:05:22 <pumpkin> @docs Monoid
12:05:22 <lambdabot> Monoid not available
12:05:25 <gwern> if you learn ocaml in addition to haskell, you double your employability. you can go to work for galois *or* jane street capital!
12:05:32 <dan__> i mean the std lib page on haskell.org
12:05:36 <dan__> it's like the java library stuff
12:05:40 <dan__> very easy to find things
12:05:40 <vixey> haskell is one of the few functional languages
12:05:58 <monadic_kid> F
12:06:14 <b_jonas> the haskell libraries are also really well designed, but that's also true to sml
12:06:26 <b_jonas> just look at the sml list and listpair libraries, they have every function you need
12:06:32 <Berengal> Haskell is the only language I've programmed extensively in that doesn't break when you put too much pressure on it
12:06:40 <pumpkin> if I want to use OPTIONS_GHC -F -pgmF <preprocessor here> is the preprocessor path relative to anything useful?
12:06:47 <b_jonas> they're really designed, not just random functions thrown together like some libraries have
12:07:01 <gwern> pumpkin: iirc isn't it selected from $PATH?
12:07:09 <pumpkin> ah, could be
12:07:20 <gwern> I mean, that'd make the most sense
12:07:24 <pumpkin> b_jonas: only the typeclasses are random collections of functions thrown together :P
12:07:51 <monadic_kid> f# will probably open up more jobs as well, it's gotten really sweet with the haskell influnce
12:08:08 <pumpkin> learning ocaml will get you enough f#-foo
12:08:13 <pumpkin> since they're very similar aren't they?
12:08:13 <dan__> one thing i'll say about sml vs haskell
12:08:18 <vixey> ocaml sml f# haskell
12:08:20 <ddarius> The whole .NET framework has a Haskell influence.
12:08:25 <dan__> sml uses hoare logic in it's type declarations
12:08:31 <Heffalump> ddarius: not really
12:08:32 <pumpkin> who you calling a ho
12:08:33 <vixey> dan__ you are kidding
12:08:35 <Heffalump> more of an ML influence
12:08:40 <vixey> ??
12:08:40 <dan__> where haskell uses types that are written like haskell code
12:08:48 <dan__> but it's still hoare, just easier to read
12:08:51 <Heffalump> well, I guess LINQ has a Haskell influence
12:08:54 <gwern> gah. gitit: /home/gwern/bin/lib/gitit-0.6.1/ghc-6.10.2/HSgitit-0.6.1.o: unknown symbol `gititzm0zi6zi1_GititziLayout_PageLayout_con_info'
12:08:55 <vixey> dan___: can you showe me it
12:08:57 <gwern>  gitit: gitit: unable to load package `gitit-0.6.1'
12:09:10 <dan__> datatype 'a BT = emptytree | bTree of 'a * 'a BT * 'a BT ;
12:09:17 <gwern> Heffalump: it better, the haskell history says so and I used that as a ref on wikipedia
12:09:21 * pumpkin pulls out his automatic linker error -> --make suggestion, but realizes it's probably not helpful in this case
12:09:47 <gwern> pumpkin: no, gitit's going through the ghc api
12:09:47 <dan__> * still means cartesian product like in hoare's logic
12:09:52 <dan__> but in haskell you don't have to write it
12:09:56 <vixey> omf
12:09:57 <Heffalump> the * and , distinction really confused a co-worker
12:10:04 <dan__> yea
12:10:05 <vixey> dan__, on thing, what is hoare logic?
12:10:06 <monadic_kid> pumpkin: F# started life as an attempt to port haskell to .NET but became an ocaml derivative which has over the few years diverged with haskell influnces
12:10:11 <pumpkin> ah
12:10:22 <dan__> vixey, hoare logic is what these langauges use to describe composite types
12:10:23 <pumpkin> they're making a big deal over their dimensional / unit extension
12:10:28 <Heffalump> monadic_kid: well, the attempt to port Haskell to .NET was stillborn, F# was starting from scratch I think.
12:10:36 <pumpkin> who you calling a ho?
12:10:36 <dan__> http://en.wikipedia.org/wiki/Hoare_logic
12:10:53 <dan__> whoooooore
12:11:03 <RayNbow> ddarius: there were days I didn't even have 2 GB of free space :p
12:11:25 <ddarius> RayNbow: There were days when I thought a 50MB hard drive was big.
12:11:26 <dan__> i don't like how in ml, you can have a type such as
12:11:28 <dan__> a*b
12:11:34 <dan__> but the code is written (a,b)
12:11:41 <dan__> in haskell the type matches the code
12:11:54 <dan__> (a,b) is used in code and type signatures
12:11:56 <maltem> dan__, blame mathematical notation
12:11:58 <pumpkin> Maybe a -> Just a / Nothing
12:12:21 <pejo> pumpkin, it appears very lightweight, and prevents you from doing some silly errors.
12:12:22 <RayNbow> ddarius: ah, true... but even in the days of large drives, I often tend to fill them up quickly... after which I keep postponing doing a clean ups :p
12:12:25 <dan__> the [] for lists is nicer in haskell too
12:12:32 <Berengal> One thing about sml I haven't found out: What's 'rec'?
12:12:33 <dan__> [char] in haskell is char list in ml
12:12:43 <pumpkin> dan__: I can think of two hacks where that's true, for lists and tuples, but both are pretty special
12:12:45 <dan__> rec?
12:12:47 <maltem> Berengal, recursive?
12:12:49 <monadic_kid> Berengal: recursive defitions
12:12:58 <monadic_kid> Berengal: *definitions
12:13:06 <monadic_kid> Berengal: let and let rec
12:13:10 <dan__> ah
12:13:17 <Berengal> ... I've made recursive functions without it...
12:13:18 <dan__> pumpkin, true, but thats used all over the place
12:13:32 <vixey> dan__ that looks different than the SML
12:13:59 <vixey> datatype 'a BT = emptytree | bTree of 'a * 'a BT * 'a BT ;  vs  {P} while B do S done {~B/\P}
12:14:07 <nvoorhies> rec is an ocaml thing, not sml
12:14:24 <monadic_kid> yeah sorry i haven't looked at SML in years
12:14:24 <Berengal> nvoorhies: I've seen it in sml as well
12:15:33 <monadic_kid> hmmm well apparently rec is in SML but is optional
12:15:48 <monadic_kid> val rec
12:15:57 <monadic_kid> instead of fun
12:16:00 <nvoorhies> Berengal: oh, it's implicit in fun but you can write val rec instead apparently?  weird
12:16:07 <pumpkin> is it possible to download the latest TH without the latest GHC?
12:16:13 <Berengal> Ah, I see, I think...
12:16:23 <monadic_kid> e.g. val rec fib =  fn n =>
12:16:23 <monadic_kid>    if n < 2
12:16:23 <monadic_kid>    then n
12:16:23 <monadic_kid>    else fib(n-1) + fib(n-2)
12:16:29 <monadic_kid> or
12:16:30 <monadic_kid> fun fib n =
12:16:30 <monadic_kid>    if n < 2
12:16:30 <monadic_kid>    then n
12:16:30 <monadic_kid>    else fib(n-1) + fib(n-2)
12:17:12 <Berengal> I've also seen 'val rec rec' somewhere...
12:17:19 <dan__> vixey, yea thats a weird syntax
12:17:19 <Berengal> I'm not sure I want to know why...
12:17:36 <monadic_kid> is that a "yo dawg" moment?
12:17:53 <edwardk> monadic_kid: =)
12:18:02 <nvoorhies> Seems like something to make things easier for generated code maybe?
12:18:04 <dan__> yo daw,g i put a function in your function
12:18:10 <dan__> so you can curry while you curry
12:18:16 <dan__> brb
12:18:17 <bavardage> Can anyone recommend some regex tutorials.. or maybe I don't even want regexes. Some things I've read have hinted (but haven't linked) that there's a better way to do it.
12:18:20 <sbahra> put some curry in my hummus
12:18:29 <pumpkin> lol
12:19:12 <monadic_kid> curry in humus? that sounds nasty
12:19:56 <EvilTerran> bavardage, for haskell, you mean? have you seen parsec?
12:20:02 <bavardage> nop I haven't
12:20:05 <bavardage> yes, for haskell
12:20:15 <EvilTerran> ?where parsec
12:20:16 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
12:20:17 <nvoorhies> "regular expressions" makes me think of the pleasant smile of an old man that eats lots of prunes
12:20:21 <bavardage> and btw yes, curry in humus sounds horrible
12:20:26 <bavardage> hehehe
12:20:50 <monadic_kid> i love humus, don't destroy the thing i love most!
12:21:12 <EvilTerran> bavardage, it comes with ghc, too :)
12:22:31 <bavardage> right
12:22:39 <bavardage> and these are better than regexes?
12:22:56 <EvilTerran> well, "better" is subjective
12:23:08 <Berengal> bavardage: Not if you want to use something other than Haskell
12:23:19 <ehird> bavardage: only for larger things
12:23:21 <bavardage> nono, haskell is fine
12:23:26 <ehird> if your regex would be <40 characters, use it
12:23:28 <bavardage> and hmm, that's what I'm thinking
12:23:31 <ehird> well
12:23:32 <bavardage> nono, these regexes would be tiny
12:23:35 <EvilTerran> ehird, i've used them for small jobs too
12:23:38 <ehird> bavardage: then use them
12:23:40 <bavardage> kk
12:23:43 <ehird> parsec can be quite verbose for small tasks
12:23:44 <bavardage> on the other side
12:23:47 <Berengal> Regexes have a tendency to.... grow...
12:23:49 <ehird> it's great for parsing, though
12:23:50 <bavardage> is there anything less powerful than regexes?
12:23:55 <ehird> Berengal: when they grow, replace them with parsec
12:24:00 <bavardage> as in 'is this word in this string'
12:24:00 <ehird> bavardage: plenty of things, but they're not useful.
12:24:02 <ehird> ah.
12:24:02 <ehird> yes.
12:24:03 <gwern> bavardage: globs?
12:24:10 <bavardage> gwern: who knows :D
12:24:11 <EvilTerran> bavardage, depends on what you need
12:24:15 <ehird> bavardage: isInfixOf+isPrefixOf+isSuffixOf
12:24:17 <edwardk> bavardage: strings? =)
12:24:22 <EvilTerran> (==)
12:24:29 <bavardage> well atm, I'm just looking for keywords
12:24:32 <gwern> ok, this is slightly more helpful... I can't do 'ghci -package gitit-0.6.1'
12:24:33 <bavardage> in strings
12:24:36 <Baughn> isInfixOf?
12:24:40 <ehird> bavardage: (x == "foo" || "foo " `isPrefixOf` x || " foo " `isInfixOf` x || " foo" `isSuffixOf` x)
12:24:53 <bavardage> ty :D
12:24:58 <bavardage> that's what I need for now
12:25:03 <bavardage> and then it may mutate into regexes
12:25:06 <bavardage> and then parsec :D
12:25:09 <bavardage> thanks...
12:25:15 <ehird> bavardage: hasWord s t = s == t || (s ++ " ") `isPrefixOf` t || (" " ++ s ++ " ") `isInfixOf` t || (" " ++ s) `isSuffixOf` t
12:25:20 <ehird> er wait
12:25:21 <ehird> make that
12:25:23 <EvilTerran> ...
12:25:34 <ehird> bavardage: hasWord s t = t == s || (t ++ " ") `isPrefixOf` s || (" " ++ t ++ " ") `isInfixOf` s || (" " ++ t) `isSuffixOf` s
12:25:41 <lysgaard> what does it mean when cabal says a package is "hidden"?
12:25:41 <ehird> then you can just do: foo `hasWord` "bar"
12:25:42 <Berengal> That'll find everything that isn't a word as well, for example it may match "hi" with "behind"
12:25:47 <ehird> Berengal: no
12:25:49 <ehird> note the spaces
12:26:00 <ehird> it's /\bfoo\b/
12:26:03 <Berengal> Ah, yes
12:26:16 <EvilTerran> um
12:26:19 <edwardk> lysgaard: it means that you didn't list it in your cabal file
12:26:33 <Berengal> Also, hasWord string word = word `elem` words string
12:26:35 <EvilTerran> s `hasWord` t = t `elem` words s
12:26:44 <Baughn> lysgaard: Package? Or module?
12:27:02 <lysgaard> Here's the output: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3675#a3675
12:27:27 <bavardage> EvilTerran: that looks much simpler tbh
12:27:31 <ehird> EvilTerran: ah
12:27:33 <Baughn> lysgaard: Ah. That's a very old package..
12:27:33 <ehird> stupid me
12:27:39 <edwardk> lysgaard: if i had to guess i'd say that was an old package from before base was split, and it doesn't mention 'array' as a dependency
12:27:43 <ehird> bavardage: yes, go for "myword" `elem` (words s)
12:27:44 <Baughn> lysgaard: It appears to predate the great splitting
12:28:12 <Baughn> lysgaard: Well, you can try adding array to the build-depends field in the .cabal file, but there's a good chance there are further problems
12:28:37 <EvilTerran> bavardage, if your keywords are space-separated, passing it to "words" once before you start looking for keywords at all might make sense
12:28:42 <pumpkin> edwardk: have you used TH much? I've noticed that the template-haskell package was updated right around when ChilliX said he added associated types
12:28:45 <lysgaard> Yeah. i have all these dependency problems, is there anyway to get rid of them. Id gladly reinstall everything if it solves the problem
12:29:07 <Baughn> lysgaard: I just told you how
12:29:12 <edwardk> pumpkin: i have, but TH doesn't support associated types except in head iirc
12:30:00 <cocon> is it wise to prefix data constructor names with the name of the data type?
12:30:05 <edwardk> lysgaard: basically the jack package needs some love, no one has touched it in a long time
12:30:09 <pumpkin> edwardk: that's what I'm talking about though... the template-haskell package was just updated a few days ago... why would they not put associated types in if it's been implemented?
12:30:43 <edwardk> pumpkin: they were going to do some further additions to support kind annotations, etc.
12:30:46 <vixey> no cocon
12:30:51 <edwardk> since you need those for good associated types
12:31:26 <pumpkin> edwardk: yeah, I need them :/
12:31:35 <edwardk> is there a geometric algebra library for haskell?
12:31:42 <cocon> I have several types that have some stuff in common, so they would clash
12:31:56 <cocon> do I have to put them in separate files?
12:32:10 <pumpkin> edwardk: not that I know of
12:32:18 <cocon> (I assume module=file in ghc)
12:32:24 <edwardk> cocon: the usual practice would be to put them in separate modules and import qualified or to prefix them enough to disambiguate if they are small
12:33:22 <cocon> can I make one large data type and then define subtypes/subsets?
12:33:30 <edwardk> longer constructor names is not a common haskell idiom
12:33:35 <edwardk> sort of
12:33:42 <edwardk> but the process is fairly involved
12:34:16 <edwardk> cocon: http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
12:34:28 <edwardk> and http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/ talk about how to do that sort of thing
12:34:29 <lysgaard> Baughn: Hm. that helped, but now the problem is that random i required too, the same fix?
12:34:59 <Baughn> Yep
12:35:22 <cocon> edwardk: thanks for the links
12:35:31 <edwardk> cocon: its not a practice i'd advise if you're just getting started though
12:38:29 * edwardk really wishes there was a simple deriving Functor that just automatically did the right thing since the construction is universal. =/
12:40:30 <dons> maybe upload a $(deriving foo) bit of TH to hackage
12:41:18 <skorpan> now that you're already on the subject, is TH or GHC hacking the only way to derive normally non-derivable type classes?
12:41:45 <Baughn> skorpan: Well, there's also the Derive package...
12:42:01 <skorpan> what does that do?  i mean what techniques does it implement?
12:42:09 <Baughn> Lots of template haskell, mostly
12:42:15 <dons> there's external things , a la Data.Data
12:42:30 <dons> i use SYb generics to generate instances
12:42:43 <bavardage> how do I specify a TypeClass in record syntax?
12:44:28 <edwardk> bavardage: ? you don't?
12:44:34 <bavardage> really :P?
12:44:36 <bavardage> dammit
12:44:41 <Baughn> Existensials?
12:44:46 <gwern> edwardk: would the same way you usually would in a function, foo :: Monad a => a -> m a, not work?
12:44:46 <Baughn> bavardage: Why do you want to, exactly?
12:44:49 <BONUS> what are you trying to do
12:44:57 <bavardage> well I want to make a type
12:45:06 <bavardage> where one of the things in a tuple is of a certain class
12:45:10 <bavardage> it doesn't matter what it is
12:45:14 <bavardage> it just has to be of that class
12:45:47 <edwardk> gwern: ?
12:45:49 <jelly12gen> ^ERROR - Undefined variable "variable"
12:46:00 <jelly12gen> ^sort [1,2,3]
12:46:19 <jelly12gen> i cant get sort working it just says undefined var
12:46:21 <BONUS> you can do: data Num a => Foo a = Foo {blah :: a, beh :: String}
12:46:25 <gwern> edwardk: one could not do 'Foo { ..., f :: Bar a => a -> a, ..} ?
12:46:25 <BONUS> but that's discouraged
12:46:37 <edwardk> bavardage: class Foo { bar :: a, baz :: b } -- seems kinda redundant to me =)
12:46:48 <bavardage> edwardk: how so?
12:46:53 <EvilTerran> ?hpaste, jelly12gen
12:46:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:46:54 <edwardk> since the class definition has to assign them all unique names anyways
12:46:54 <gwern> (bleh. gitit still isn't loading! maybe I need to reinstall from highlighting-kate)
12:46:57 <bavardage> BONUS: why discouraged
12:47:06 <ddarius> newtype Endo a = Endo (a -> a) deriving Functor ...
12:47:11 <Baughn> BONUS: Not really. It has a very specific purpose, and if it fits, that's all to the good.
12:47:13 <EvilTerran> jelly12gen, if we can't see your code, we can't really work out why that error's happening
12:47:19 <Baughn> bavardage: It isn't, really
12:47:21 <bavardage> edwardk: so I can just do typevariables
12:47:26 <BONUS> Baughn: which purpose would that be?
12:47:37 <bavardage> noop
12:47:37 <Baughn> BONUS: OO
12:47:39 <edwardk> bavarage: basically =)
12:47:44 <jelly12gen> EvilTerran: well it is in ghci http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3676#a3676
12:47:50 <bavardage> "Main.hs:22:44: Not in scope: type variable `a"
12:48:03 <Baughn> bavardage: But it allows a style of programming that is more similar to OO-based languages, but which is a bad idea when it can be avoided (in haskell)
12:48:14 <Baughn> bavardage: So it's discouraged because otherwise you migth overuse it
12:48:17 <bavardage> right
12:48:21 <edwardk> bavardage: if you want a type where one member can only be a member of some particular class use the trick BONUS mentioned or just make sure that everything that uses that type has that constraint, which would be preferable
12:48:29 <EvilTerran> jelly12gen, i don't see your "ERROR - Undefined variable "variable""
12:48:29 <BONUS> yeah, usually it's discouraged because you have to repeat the class constraint in any function that uses that data structure anyway
12:48:34 <dan__> hey doods
12:48:34 <bavardage> but how do I allow it to be any type then
12:48:37 <ddarius> Baughn: Type class constraints on data types doesn't really do anything.  It doesn't lead to an existential.  Using existentials and type classes will lead to something vaguely like an object.
12:48:38 <jelly12gen> EvilTerran: that is in hugs
12:48:43 <bavardage> since it's not liking my generic 'a' type
12:48:47 <Baughn> Hang on..
12:48:48 <BONUS> how so?
12:48:54 <jelly12gen> EvilTerran: but  do i need a module for sort ?
12:48:55 <dan__> whats the function called where you take a list of lists and convert it to one list
12:48:57 <dan__> ie
12:48:57 <lysgaard> is there any way to delete a package with cabal?
12:48:58 <Baughn> ddarius: I thought that /was/ an existential. The syntax looked slightly odd..
12:49:00 <jelly12gen> like Char for isDigit
12:49:03 <edwardk> i.e. data Foo a b = Foo a b; useFoo :: Enum b => Foo a b -> Int
12:49:04 <EvilTerran> jelly12gen, that's exactly the problem
12:49:16 <dan__> blah blah ["hello","world] => "helloworld"
12:49:19 <dan__> whats blah blah?
12:49:23 <dan__> transpose?
12:49:29 <dan__> :t transpose
12:49:30 <bavardage> http://paste.pocoo.org/show/112137/ <-- this
12:49:30 <lambdabot> forall a. [[a]] -> [[a]]
12:49:32 <BONUS> usually you just use a type parameter and then you put class constraints on the function that use that type
12:49:32 <jelly12gen> EvilTerran: where can i see wich module i need :P
12:49:35 <ddarius> dan__: Ask hoogle
12:49:40 <edwardk> putting the class constraint on the data type doesn't really help, all it does is provide a proof obligation it doesn't help.
12:49:44 <BONUS> just like Data.Map doesn't have an Ord constraint on the data definition
12:49:47 <dan__> @hoogle transpose
12:49:47 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
12:49:47 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
12:49:47 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
12:49:50 <Baughn> bavardage: Okay, ignore what I said. That was for existentials, which that line apparently was not.
12:49:56 <ddarius> dan__: Ask hoogle the type
12:50:00 <EvilTerran> jelly12gen, well, you can look through the docs and guess
12:50:01 <bavardage>  so how do I use a type parameter then in record syntax
12:50:03 <BONUS> but there is an Ord constarint on most of the functions that use Data.Map.Map
12:50:04 <EvilTerran> ?docs
12:50:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:50:09 <dan__> ah
12:50:20 <EvilTerran> jelly12gen, or you can use hoogle
12:50:20 <BONUS> bavardage: data Foo a = { blah :: a, boo :: String }, for instance
12:50:22 <EvilTerran> ?hoogle sort
12:50:22 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
12:50:22 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
12:50:22 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
12:50:33 <BONUS> or data Foo a b = { blah :: a, boo :: b }
12:50:35 <bavardage> BONUS: doesn't seem to work
12:50:37 <bavardage> oooh kk
12:50:38 <jelly12gen> EvilTerran: so i need data?
12:50:39 <bavardage> nm
12:50:41 <bavardage> *IDIOT ME*
12:50:42 <bavardage> ty
12:50:45 <BONUS> hehe np :)
12:50:52 <Berengal> dan__: concat
12:51:00 <dan__> ahhh
12:51:01 <dan__> thats right
12:51:04 <dan__> duh..
12:51:08 <EvilTerran> jelly12gen, well, that one suggests "Data.List" as having the function with the right type
12:51:09 <ddarius> @hoogle [[a]] -> [a]
12:51:12 <lambdabot> Prelude concat :: [[a]] -> [a]
12:51:12 <lambdabot> Data.List concat :: [[a]] -> [a]
12:51:12 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
12:51:18 <Berengal> ... or join, or (>>=id)...
12:51:30 <Baughn> bavardage: You can say "data Foo = forall a. Show a => Foo a Int" or some such, too (..may have gotten the syntax wrong), in which case you can stick anything that's in Show in there but can only use the functions in Show on it.. that's an existential
12:51:46 <EvilTerran> jelly12gen, or, if you want to stay in completely standard haskell, you can look through the libraries laid down in the report on http://haskell.org/onlinereport/
12:52:07 <Baughn> bavardage: Or, as C++ would call it, a virtual function, as opposed to the non-virtual normal use of typeclasses. That's a scarily good match..
12:52:12 <EvilTerran> jelly12gen, which would suggest "List" as the module to use
12:52:23 <Fortunately> +--
12:52:33 <Baughn> bavardage: (Well, the choice of whether it's virtual or not is made per-use, not per-function, so not quite perfect)
12:52:35 <EvilTerran> ?karma +
12:52:35 <lambdabot> + has a karma of 38
12:52:39 <EvilTerran> huh
12:52:41 <Baughn> +++
12:52:43 <jelly12gen> EvilTerran: <no location info>: module `List' is a package module
12:52:50 <jelly12gen> when :load List
12:52:58 <RayNbow> jelly12gen: in ghci?
12:53:01 <Baughn> ?karma +
12:53:01 <lambdabot> + has a karma of 39
12:53:05 <jelly12gen> RayNbow: yes
12:53:11 <EvilTerran> jelly12gen, ah; :load is for source files, use :module for libraries
12:53:12 <Berengal> ?karma C
12:53:12 <lambdabot> C has a karma of 1
12:53:14 <Fortunately> oops
12:53:18 <RayNbow> :m List -- so this doesn't work, jelly12gen?
12:53:29 <Fortunately> i have a cat, see?
12:53:30 <RayNbow> (btw, it's recommended to use Data.List instead)
12:53:55 <Baughn> Unless you're writing haskell '98 code, for whatever reason
12:54:12 <jelly12gen> RayNbow: ah that works , btw Sortby also need that module
12:54:41 <dan__> > concat ["hello", "world", "etc"]
12:54:43 <lambdabot>   "helloworldetc"
12:54:48 <RayNbow> EvilTerran: the problem is that users coming from Hugs are used to using :load for libs :p
12:54:48 <dan__> > concat ["hello", "world", "etc","poo"]
12:54:50 <lambdabot>   "helloworldetcpoo"
12:55:39 <EvilTerran> jelly12gen, btw, if you already have some modules loaded, and want to load some more, use ":m + ..."; just using ":m ..." would replace the current loaded modules
12:55:44 <Berengal> > ["hello", "world", "etc"] >>= id
12:55:45 <lambdabot>   "helloworldetc"
12:55:54 <EvilTerran> ?src join
12:55:54 <lambdabot> join x =  x >>= id
12:56:14 <jelly12gen> EvilTerran: thanks
12:56:52 <gwern> no one has any advice for this gitit/template-haskell error?
12:58:23 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3677#a3677
12:59:27 <Saizan> preflex: zdec gititzm0zi6zi1_GititziLayout_PageLayout_con_info
12:59:27 <preflex>  gitit-0.6.1_Gitit.Layout_PageLayout_con_info
13:00:10 <EvilTerran> preflex++
13:00:42 <gwern> yes, I can translate it as well but it doesn't help me
13:01:09 <sjanssen> gwern: looks like a missing module in the .cabal file
13:01:27 <gwern> hm
13:01:32 <gwern> how does that work?
13:01:59 <sjanssen> gwern: all modules must be in exposed-modules or the hidden modules list
13:02:14 <sjanssen> did you add a module, but forgot to add it to the .cabal?
13:02:32 <gwern> no, I mean how does a other-modules module show up as an erro when TH loads the gitit package?
13:03:16 <sjanssen> I don't see what this error has to do with TH
13:04:08 <gwern> well, the paste shows it. it shows up when a module is loaded by the gitit executable via ghc api, and also when you run ghci -package gitit-0.6.1, during the TH part
13:05:09 <sjanssen> is Gitit.Layout.PageLayout list in other-modules?
13:05:23 <gwern> yes, it is. I'm recompiling now
13:05:39 <sjanssen> gwern: oh, are you possibly in gitit's source directory when running that?
13:06:02 <gwern> no
13:08:42 <Gracenotes> > ($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>($)<$>(($)=<<)<$>[(-)]<*>[1..]
13:08:43 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:08:54 <Baughn> Gracenotes: NOOOOOO
13:09:13 <Baughn> Actually
13:09:14 <Baughn> What
13:11:03 <EvilTerran> i suspect a large prefix of that = id
13:11:32 <Gracenotes> id for a specific type
13:11:35 <EvilTerran> i say "i suspect", (($) <$>) = fmap id, so "i know"
13:11:40 <EvilTerran> :P
13:11:52 <Gracenotes> id .
13:12:20 <dons> hehe
13:12:50 <b_jonas> isn't (fmap id) the same as just id ?
13:13:04 <gwern> :t fmap id
13:13:05 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
13:13:05 <gwern> :t id
13:13:07 <lambdabot> forall a. a -> a
13:13:21 <Baughn> Well, with an added Functor restriction
13:15:49 <Gracenotes> > map (\o -> o-o) [1..]
13:15:50 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
13:16:01 <dons> shapr: you should see these giant delivery bikes they have in portland now.
13:16:04 <Gracenotes> o-o
13:16:23 <dons> shapr: http://www.flickr.com/photos/hollyandpatrick/3379706740/
13:16:42 <Baughn> > const [1..] <$> (<*>)
13:16:44 <lambdabot>       Overlapping instances for Show (f (a -> b) -> [t])
13:16:44 <lambdabot>        arising from ...
13:17:53 <cocon> edwardk: is there an implementation of the "data types √† la carte" article on hackage or somewhere?
13:18:19 <cocon> (I know it's not a lot of code, just wondering if it's already there)
13:19:00 <bmh> is there something like `amap` for arrays that gives me access to the indices while mapping?
13:19:17 <b_jonas> bmh: for IArrays?
13:19:19 <dons> bmh: for vectors/uvectors, yes.
13:19:23 <Gracenotes> unfortunately I don't think so
13:19:35 <Gracenotes> very unfortunate :\
13:19:53 <bmh> b_jonas: yes
13:20:00 <b_jonas> bmh: you can combine array and assocs
13:20:04 <b_jonas> or listArray and assocs
13:20:26 <b_jonas> and a map
13:20:33 <bmh> that's not pretty :)
13:21:00 <b_jonas> well, write a function in that case
13:21:32 <Gracenotes> amap itself essentially converts to a list and back
13:21:35 <dons> if you're doing a lot of transformations, uvector might be a better optoin.
13:21:41 <Baughn> > (fmap.fmap) pred $ Just "IBM"
13:21:43 <lambdabot>   Just "HAL"
13:21:46 <Gracenotes> amap f arr@(Array l u n _) = unsafeArray' (l,u) n [(i, f (unsafeAt arr i)) | i <- [0 .. n - 1]]
13:21:46 <dons> pumpkin_: should i just release uvector darcs today, as a minor revision?
13:21:50 <dons> anything you want to push in?
13:21:57 <Gracenotes> however, it uses fast internal operations
13:22:11 <Gracenotes> well, fast assuming random access
13:22:17 <Gracenotes> which Array has
13:22:44 <b_jonas> what's this uvector thing?
13:22:51 <Gracenotes> viva la uvector
13:23:18 <dons> fast arrays with a list-like interface
13:23:28 <dons> there are many nice array libraries on hackage.
13:25:52 * b_jonas looks this uvector up
13:26:17 <b_jonas> "uvector: Fast unboxed arrays with a flexible interface"
13:26:28 <gwern> bleh. gitit errors on a different module
13:26:36 <gwern> how many did john leave hidden...
13:26:38 <Gracenotes> in Soviet Russia, uvector looks up YOU with flexible interface
13:27:26 <gwern> in america, you have index of parties; in soviet russia, party has index of you!
13:28:24 <gwern> in america, you manipulate data; in Soviet Enterprise, Data manipulates you!
13:29:03 <athos> lol.
13:29:13 <gwern> finally! gitit runs
13:29:33 <gwern> took unhiding 4 modules, but it works at last
13:29:55 <b_jonas> I think this whole "co" prefix that people use in category theory is an elaborate Soviet Russia joke
13:29:57 <snoobino> what's the rule for GHC to GC something ?
13:30:16 <snoobino> is there a way to force it ?
13:30:17 <dons> bmh: oh my.
13:30:27 <Baughn> snoobino: call performGC
13:30:27 <bmh> dons: hm?
13:30:36 <bmh> dons: Did I break something?
13:30:41 <dons> co-monads / co-algebras / co-induction as an elaborate joke :)
13:30:50 <dons> oh, b_jonas
13:30:53 <dons> tab complete!
13:30:55 <Baughn> snoobino: Although, that's something you almost never want to do. GHC already automatically calls it if your program becomes idle.
13:30:56 <bmh> ha
13:31:05 <gwern> now all we need are something to name 'munist'
13:31:13 <Baughn> snoobino: (Handy to test finalizers, though)
13:31:14 <bmh> speaking of jokes... when I get the time I need to create an "Adult" category on Hackage
13:31:15 <gwern> so we can have co-munists
13:31:30 <b_jonas> bmh: lol
13:31:36 <Botje> co-pulation ?
13:31:36 <Baughn> gwern: Operative, perhaps?
13:31:44 <Baughn> co-operative
13:31:55 * sebaseba wonders what the bind strategy would be for the Adult monad
13:32:04 <b_jonas> :
13:32:06 <bmh> hackage seemingly blindly creates any category you ask it to. I wonder if I could use that to inject malicious js...
13:32:08 <gwern> sebaseba: I would hope it'd involve th chain rule
13:32:11 <b_jonas> /snigger/
13:32:23 <snoobino> Baughn: so, why's my data never garbage collected ?
13:32:31 <Gracenotes> In America, you enthusiastically leverage synergies; in Soviet Russia, synergies enthusiastically leverage you :\
13:32:33 <gwern> snoobino: perhaps you never throw it out
13:32:40 <Baughn> snoobino: Perhaps you're holding on to references
13:32:50 <Baughn> snoobino: Or perhaps they're Integers and you're using 6.10.1
13:32:53 <gwern> Gracenotes: mm. as a long-time connoisseur, I don't see it
13:32:56 <dons> bmh: it will almost certainly lead to your account being suspended.
13:33:21 <gwern> dons: we should know about vulnerabilities tho
13:33:52 <bmh> dons: Obviously. But if it's a bug, it ought to be fixed.
13:34:12 <Gracenotes> gwern: yes, mostly just meaningless wordplay.
13:34:25 <bmh> My goodness.. I haven't been threatened with arrest since summer of '07!
13:34:46 <Gracenotes> In America, you bind monads to state. In Soviet Russia, OMON binds state to YOU. >_<
13:34:59 <gwern> OMON?
13:35:28 <dons> bmh: yeah, unknown. i suspect it will just 'show' the 'category'
13:35:41 <dons> bmh: you can check out the src
13:35:50 <dons> i think the cabal file has to parse.
13:36:19 <amaron> dons: can I ask you again about printable report generator, if you recall
13:36:34 <dons> oh, i know people use things like hpdf
13:37:09 <dons> i've done some things with generated .tex for reports
13:37:13 <Gracenotes> gwern: I don't think you're thinking with nomads
13:37:37 <amaron> dons: ah, that, I saw it, I thought its very basic
13:38:16 <dons> yeah. what kind of thing are you looking for?
13:38:25 <dons> mostly, I build up things from Text.Pretty
13:38:38 <dons> hmm. should write about that.
13:38:42 <dons> it is underapprecated
13:38:49 <amaron> something like nice tunned tables, business reports, etc
13:39:17 <dons> so some kind of markup that you render to .pdf / .html
13:39:17 <dons> ?
13:39:30 <amaron> I prefer pdf for printer
13:39:46 <dons> pandoc might be the way to go. comprehensive markup haxoring: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pandoc
13:40:01 <dons> i think barclay's capital has their own pdf suite for haskell (?) (or doc toolchain anyway)
13:40:04 <dons> but nothing public.
13:40:26 <amaron> mmm, this looks tasty enough
13:40:53 <gwern> Gracenotes: I can think with nomads! it's a great system
13:41:16 <amaron> but there is no pdf support
13:41:21 <gwern> truly groundbreaking for its time, especially when you consider the Nomad was contemporary with things like the color gameboy or original gameboy
13:41:35 <wpearson> qwern: Your mind wonders?
13:41:53 <wpearson> Or wanders even
13:42:06 <wpearson> And make that gwern*
13:42:07 <amaron> I do my own documents in latex, but this app should run on windows too
13:42:10 <gwern> o.0 you know I was going to include the jsmath files in my personal wiki as managed files, but jsmath unpacks to 82 megabytes of stuff
13:42:21 <amaron> and I prefer not to install latex on those machines
13:43:04 <bremner> amaron: but nice pdf is much harder to generate than latex, I guess
13:43:07 <gwern> a large storage price to pay for pretty math :(
13:43:47 <bavardage> has anyone any experience with treeviews and treemodels?
13:44:00 <bavardage> specifically, how to turn a treepath into a treeiter
13:44:09 <bavardage> whilst dodging the horribleness of lots of maybes
13:44:49 <bremner> Maybe monad?
13:45:11 <dons> amaron: well, docbook -> pdf
13:45:53 <bremner> but a docbook toolchain is no lighter weight than latex, nor likely to install nicely on Windows I guess
13:46:23 <dons> yeah, i think you can just take your pick for .pdf generation, from the different markup/down formats
13:46:35 <bremner> amaron: maybe you should port lout to haskell.
13:46:36 <dons> oh, pandoc writes .pdf
13:46:47 <dons> http://johnmacfarlane.net/pandoc/
13:46:49 <bremner> oh right. it can't be that hard then :-)
13:47:01 <amaron> well I guess thats it
13:47:28 <bavardage> bremner: yeah but how the hell to do something useful with it
13:47:43 <bremner> are you sure it does? it doesn't mention it in the pandoc(1) manpage
13:47:53 <dons> pandoc home says so, at least.
13:48:08 <bremner> ok, I believe you :-0
13:48:08 <dons> http://johnmacfarlane.net/pandoc/markdown2pdf.1.html
13:48:26 <bremner> ahh, but it refers to pdflatex
13:48:36 <bavardage> http://paste.pocoo.org/show/112150/ <-- any ideas?!
13:48:59 <dons> users guide, http://johnmacfarlane.net/pandoc/README.html
13:49:25 <bremner> yeah, its a script, calls pdflatex :-<
13:50:15 <amaron> dons: thanks alot, I think this will solve my problem
13:50:34 <bremner> amaron: I bet you a nickel it doesn't
13:51:10 <dons> gwern: done much gitit hacking?
13:51:34 <bremner> amaron, dons: http://paste.debian.net/download/33220  (markdown2pdf script)
13:51:38 <Cale> bavardage: what is != ?
13:51:47 <bavardage> Cale: who knows
13:51:53 <bavardage> Cale: not equal :P
13:51:58 <amaron> I'm looking at this markdown sintax, and what can be done with it
13:51:59 <Cale> bavardage: That would be /=
13:52:04 <bavardage> Cale: right
13:52:06 <bavardage> Cale: but ignore that
13:52:12 <bavardage> Cale: how would I go about handling the two cases
13:52:17 <bavardage> within the io monad
13:52:23 <bavardage> i.e. the iter I got is nothing
13:52:24 <shapr> lysgaard: Did you NMU jack?
13:52:25 <bremner> amaron: you could generate html without much fuss
13:52:26 <bavardage> run away, stop hide
13:52:30 <bavardage> or the iter I got is valid
13:52:38 <bavardage> so actually extract the iter from the Maybe and do something with it
13:52:48 <Cale> bavardage: you need another do-expression in each of the branches of the if -- well, not the 'else', because it's just one action
13:52:56 <bavardage> right
13:53:01 <bavardage> and then, how do I get the value out?
13:53:01 <Cale> But 'case' would make more sense here
13:53:05 <bavardage> kk
13:53:06 <Cale> case iter of
13:53:11 <Cale>   Nothing -> print "..."
13:53:12 <bavardage> and I can pattern match in case?
13:53:20 <Cale>   Just iter' -> do ...
13:53:22 <bavardage> yay
13:53:25 <bavardage> ty
13:53:26 <bavardage> <3 Cale
13:53:44 <Cale> Also, when writing if-then-else, the convention goes like:
13:53:47 <Cale> if foo
13:53:49 <Cale>    then bar
13:53:52 <Cale>    else quux
13:54:01 <Cale> The 'then' and 'else' should always line up.
13:54:27 <Cale> (and start on a deeper column than 'if', because they're part of it)
13:54:39 <bavardage> oh kk
13:54:41 <amaron> bremner: I know about html, but I wanted to make pdfs, I'll play with this pandoc
13:54:58 <Cale> It's not as strongly enforced as some other parts of the Haskell syntax, but it's a good idea to do it like that anyway.
13:55:20 <Cale> For instance, in this case, that 'else' is off in a separate line of the containing do-block
13:55:35 <Cale> So you'd get a syntax error even after you'd fixed the one with the contents of 'then'
13:55:38 <bremner> amaron: ok, I'm only going to say this one more time :-)  pandoc uses latex to make pdf
13:56:17 <legalgold> guys
13:56:39 <amaron> bremner: auch, I didnt saw you saying first time...
13:57:04 <bremner> amaron: no problem, I like yelling.
13:57:13 <amaron> :)
13:59:40 <legalgold> you guys go to this link to get legal gold 100% safe and 100% legal!!!!!!!!  aprroved by blizzard! go to this link and watch a video - http://tuh10.luke13.hop.clickbank.net
13:59:51 <basti_> wtf
13:59:54 <legalgold> i strongly recommand it!!! go check it out guys
14:00:01 <legalgold> http://tuh10.luke13.hop.clickbank.net
14:00:04 <basti_> chanops?
14:00:11 <paper_cc> @ops
14:00:11 <lambdabot> Maybe you meant: docs oeis pl
14:00:13 --- mode: ChanServ set +o Heffalump
14:00:22 <basti_> shapr?
14:00:24 <athos> all hail Heffalump \o
14:00:37 <athos> Lol.
14:00:44 <basti_> *G*
14:00:58 <Heffalump> you just have to ask nicely ;-)
14:01:03 <athos> ;-)
14:01:22 <legalgold> no bannes no hacks
14:01:22 <legalgold> http://tuh10.luke13.hop.clickbank.net
14:01:24 --- mode: Heffalump set +b *!n=legalgol@84.228.158.103
14:01:26 <arjanb> or maybe less nice..
14:01:32 <ikkebr> lmao
14:01:38 <Philippa__> legalgold: wrong about the bans
14:02:03 <bremner> actually bannes is for marriage iirc
14:02:12 <Heffalump> I don't think those have an 'e'
14:02:12 <ikkebr> yet i was tempted to click on that link
14:02:32 <bremner> Heffalump: olde marriages?
14:02:55 <bavardage> nice @ spam
14:03:05 <bavardage> there was some spam just in #awesome on Oftc too
14:03:09 <bavardage> is there some event happening
14:03:13 <bavardage> the bots have taken to the irc networks
14:03:32 <ikkebr> bavardage skynet is going online today
14:03:42 <bavardage> hehe
14:03:45 <ikkebr> or maybe viral terminator 4 ads
14:03:46 --- mode: Heffalump set -o Heffalump
14:05:51 <alexsuraci> Does Parsec only consider an attempt in <|> failed if the first thing it tries fails?
14:06:11 <alexsuraci> It keeps stopping short at earlier ones with an error when later ones would work fine.
14:06:39 <Heffalump> alexsuraci: yes, I believe so
14:07:17 <Heffalump> there's always a trade-off between supporting backtracking like that and efficiency. I think with Parsec you are supposed to use 'try' to explicitly get backtracking.
14:07:58 <alexsuraci> was never clear on what "try" did, I'll look it up again
14:08:17 <Heffalump> I'm not sure I understand it well enough to explain either.
14:09:01 <alexsuraci> oh, look at that, prepending that to all of the things in the main expr list fixed it.
14:09:04 <Philippa__> "when backtracking may be necessary"
14:09:17 <Philippa__> where at least one token would otherwise be consumed looking down a possibly-wrong path
14:09:38 <Philippa__> for example, reading an arbitrary token and then checking a predicate on it needs try :-(
14:09:46 <alexsuraci> should I be worrying about performance if I use it for everything in the main expression assignment?
14:11:35 <Philippa__> alexsuraci: potentially, yeah
14:11:45 <Philippa__> but profile first
14:11:54 <Philippa__> also, LL(1) grammars won't need it
14:12:57 <alexsuraci> alright, noted
14:13:13 <alexsuraci> I've only got it on 3 things at the moment, I'll be sure to only add it when necessary
14:13:26 <cristi_ceata> hello! can anyone help me with debugging this .hs source. http://pastebin.com/d35509b38 main2.hs:7:11: Parse error in pattern
14:14:11 <cristi_ceata> I am new to haskell and I don;t have experience at debug
14:14:38 <bremner> either use braces and semicolons, or neither
14:15:26 <cristi_ceata> thanks. let me see if it works
14:17:09 <Cale> Well, you can use semicolons without braces.
14:17:24 <Cale> But if you use braces, you're required to use semicolons.
14:18:42 <cristi_ceata> now it says: parse error on input '}'
14:18:59 <cristi_ceata> all braces match
14:19:19 <Cale> Your let is strange.
14:19:46 <Cale> I think your if/then/else is meant to be part of the do-block above, rather than part of the let.
14:20:01 <Cale> If you'd like, I'll straighten the syntax out :)
14:20:09 <cristi_ceata> ok
14:22:27 <Cale> http://pastebin.com/m460c914b
14:24:22 <gwern> dons: you know I've done a fair bit of gitit hacking
14:24:38 <Cale> cristi_ceata: Or here, with braces http://pastebin.com/m24dad591
14:24:42 <gwern> (more than just about anyone except john or maybe mae)
14:25:16 <Cale> cristi_ceata: Also note  randomRIO  rather than  random  (just thought I'd correct that)
14:25:59 <cristi_ceata> Cale: thanks a lot
14:26:13 <Cale> cristi_ceata: Another thing which you might like to know is that the final 'do' is unnecessary, since there's only one statement in it. do-syntax is only really needed for gluing together more than one action in a chain.
14:26:17 <Cale> (into a larger action)
14:27:12 <mmorrow> <legalgold> i strongly recommand it!!! go check it out guys
14:27:13 <mmorrow> lol
14:27:39 <Zao> I strongly recommend using heterogeneous zygomorphicsms to ease your coinduction. Get recursive now!
14:28:05 <mmorrow> @remember legalgold you guys go to this link to get legal gold 100% safe and 100% legal!!!!!!!!  aprroved by blizzard! i strongly recommand it!!! go check it out guys
14:28:05 <lambdabot> Okay.
14:29:03 <Cale> Well, given the economy, I can understand how gold might be desirable.
14:29:49 * mmorrow wants to know whotf "blizzard" is
14:30:01 <vixey> blizzard writes games such as Warcraft
14:30:04 <gwern> mmorrow: blizzard, world of warcraft, in-game currency, gold farmers
14:30:09 <mmorrow> ahhhh
14:30:26 <Elly> hahahaha, "approved by blizzard"
14:30:38 <Elly> they demonstrate their approval by banning all involved parties!
14:30:52 <gwern> because they i from bizarro world
14:30:59 <mmorrow> i thought that was just crazy and was laughing my ass off
14:31:05 <mmorrow> *..crazy talk...
14:31:21 <Cale> Why does Blizzard actually care if people sell in-game currency?
14:31:38 <Elly> it causes massive inflation
14:31:39 <Zao> Cale: Breaks game balance.
14:31:41 <gwern> Cale: affects gameplay
14:31:58 <gwern> and it cuts them out of the loops
14:31:59 <Zao> The economy is carefully balancing with money sinks removing money from the game.
14:32:02 <Cale> But, can't they simply control gameplay with an iron fist?
14:32:07 <gwern> WoW is not built like Eve online
14:32:09 <Elly> there are ways to get gold that are time-efficient but not fun, so "real players" don't do them
14:32:24 <Elly> and "real players" are subject to many of the aforementioned gold sinks
14:32:30 <Elly> whereas gold farmers aren't
14:32:31 <Cale> Why not simply change the rules of the game so that it's no longer something people would want to do in that case?
14:32:31 <gwern> Cale: sure, but how do you hit only the gold farmers and leave liegimtate players alone?
14:32:38 <Elly> Cale: what, by removing currency?
14:32:39 <Zao> Cale: So if I decide to grind for some money as I really need it, I'm going to be banned for farming?
14:32:49 <Cale> Zao: No need to ban.
14:33:02 <Elly> how do you fix this behavior then?
14:33:11 <Elly> you can't make gold-farming undesirable without making gold undesirable
14:36:36 <Cale> You can make acquiring gold less of a mindless thing to do though.
14:36:58 <Elly> if monsters drop gold, killing a thousand monsters gets you a lot of gold, despite being boring as fuck
14:37:10 <obk> I need to do something like a "map" on a list, but I want to do something special for the last element. Is there a neat way to do it? (Doing something special for the first element is trivial of course)
14:38:02 <Saizan_> something special being?
14:38:19 <obk> A different function to apply to the list element
14:38:44 <Cale> Elly: Right, the first thing you can do is to ensure that killing the same enemies over and over doesn't give you gold, or has exponential falloff in the amount of gold you get. (Actually, should probably be the same way with experience)
14:38:45 <obk> I want to apply f to all elements except the last one and g to the very last one
14:38:46 <gwern> obk: copy the definition of map but use a case like 'map' (a:[]) = special a'?
14:38:55 <gwern> @src map
14:38:55 <lambdabot> map _ []     = []
14:38:55 <lambdabot> map f (x:xs) = f x : map f xs
14:38:57 <Cale> Well, or 1/x falloff or something.
14:39:19 <obk> Sure, I was just wondering whether there's something like that in the standard library
14:39:27 <gwern> map f g (x:xs) = f x : map f g xs; map _ g (a:[]) = g a
14:39:28 <Elly> Cale: if you do that, you need to have a lot of different enemies so legitimate players can level up
14:39:32 <b_jonas> map f (init a) ++ [g (tail a)]
14:39:33 <Cale> Elly: Right.
14:39:42 <gwern> (offhand, I don't know of anything in the stdlib)
14:39:43 <Elly> currently there are maybe five enemy types per zone
14:39:46 <obk> b_jonas: That's short enough ;-)
14:39:49 <Elly> and there's one or two zones per ten-level bracket
14:40:15 <Saizan_> > let foo f g xs = zipWith ($) (zipWith const (repeat f) (drop 1 xs) ++ [g]) xs in foo (+1) (+2) [1..5]
14:40:17 <lambdabot>   [2,3,4,5,7]
14:40:26 <obk> I do wish Haskell used difference-lists by default, so ++ wouldn't be so O-horrible
14:40:28 <Cale> Elly: I'm not saying there wouldn't be work involved in making the game not be tedious.
14:40:36 <Elly> yeah :P
14:40:44 <Saizan_> b_jonas: s/tail/last/
14:41:05 <obk> Seizan_ : yes, I noticed
14:41:14 <b_jonas> Saizan_: oh yeah, indeed
14:41:15 <Cale> But doing something like that would force you to design the game such that at least in one particular way, it's not tedious.
14:41:31 <Saizan_> obk: there's dlist on hackage
14:41:36 <b_jonas> or you could just write it somehow like gwern's solution
14:41:46 <wli> obk: Or maybe overloaded list syntax so difference lists (and possibly other things) could be manipulated without onerous syntax.
14:41:47 <mmorrow> , (\a -> (init a, tail a)) [42]
14:41:49 <lunabot>  ([],[])
14:41:53 <obk> I know, but it is a hassle to use compared to the neatness of using [ ]
14:41:57 <Saizan_> obk: the problem with difference lists is that you don't get as much sharing
14:42:17 <mmorrow> , (\a -> (init a, last a)) []
14:42:18 <lunabot>  luna: Prelude.init: empty list
14:42:25 <gwern> obviously this calls for more typeclasses
14:42:30 <obk> I do use dlists where it is important... most cases it isn't worth the extra headache
14:42:34 <mmorrow> i would just suck it up and write a directly recursive def :)
14:42:54 * Saizan_ loves zipWith const
14:42:56 <Cale> I never use the DList library, but I use that technique when it helps.
14:42:58 <mmorrow> because there's not really anything (in stdlibs) i can think of to do that
14:43:02 <obk> mmorrow: I was just going to do that, but stopped myself. "Surely there's a better way" and all ;-)
14:43:24 <mmorrow> obk: that always happens with me and Either :)
14:43:37 <mmorrow> (and there never seems to be..:(
14:43:49 <obk> I think b_jonas's solution is the neatest for me; the lists will be small (<10 elements)
14:44:06 <mmorrow> obk: just make sure you check for an empty list before calling init
14:44:11 <mmorrow> s/init/lkast/
14:44:17 <kyagrd> Is there good reference code that implements "first class module" as a Haskell idiom?
14:44:22 <obk> Yes, actually I know that they have at least 2 elements
14:45:31 <wli> I've been trying to figure out module systems for a while.
14:46:17 <wli> mmorrow: Did you get [k | k <- [10^(6::Int), 10^(6::Int) - 1 .. 5*10^(5::Int) + 1], k `mod` 3 /= 1, case (2*k) `divMod` 3 of { (q, 1) | q <= 10^(6::Int) -> False ; _ -> True} ]
14:46:50 <kyagrd> We can kind of implement module system either iwth type classes or records of functions if the function definitions inside modules are STATIC
14:47:02 <mmorrow> wli: i didn't.
14:47:51 <mmorrow> wli: i was thinking about collatz though, and realized that postdominators are applicable
14:48:31 <kyagrd> It gets trickier when you want to create such function definitions dynamically and package them around ... I wonder whether there is a common idiom people have been using
14:48:36 <wli> mmorrow: Backward chaining dominance elimination no longer improves things after 2 iterations, at least out to 10 iterations, so that's about as much thinning as actually improves things.
14:48:58 <mmorrow> hmm
14:50:23 <wli> mmorrow: Not all chain length differences arise from dominance relations.
14:54:13 <mmorrow> @let reach f a = let go seen a = let s = f a; as = S.toList (s `S.difference` seen) in foldl' go (s `S.union` seen) as in go (S.singleton a) a
14:54:14 <lambdabot>  Defined.
14:55:19 <wli> mmorrow: What I did was let step n = (2*n) : case n `divMod` 3 of { (q, 1) | q > 0 -> [q] ; _ -> [] } ; backChain = Set.fromList . (step =<<) . Set.toList ; iter m xs = [(n, ss) | (n, s : ss) <- xs, Set.findMin s > m] ; mkList m = [(n, tail $ iterate backChain $ Set.singleton n) | n <- [1 .. m]] in length . map fst . last . take 10 . iterate (iter 1000000) $ mkList (1000000 :: Integer)
14:55:51 <mmorrow> interesting
14:58:45 <mmorrow> @let collatz = let f n | n Data.Bits..&. 1 == 1 = 3 * n + (1::Int) | otherwise = n `shiftR` 1 in reach (S.singleton . f)
14:58:46 <lambdabot>  Defined.
14:59:13 <mmorrow> @let glb [] = mempty; glb (n:ns) = foldl' S.intersection (reachable collatz n) (fmap (reachable collatz) ns)
14:59:14 <lambdabot>  Couldn't match expected type `Graph'
14:59:22 <mmorrow> @let glb [] = mempty; glb (n:ns) = foldl' S.intersection (reach collatz n) (fmap (reach collatz) ns)
14:59:23 <lambdabot>  Defined.
14:59:29 <mmorrow> is what i was messing with
14:59:41 <mmorrow> , glb [3748,29993]
14:59:43 <lunabot>  luna: Not in scope: `glb'
14:59:46 <mmorrow> > glb [3748,29993]
14:59:47 <lambdabot>   fromList [1,2,4,8,16]
14:59:52 <mmorrow> > glb [3748,29993,927644]
14:59:54 <lambdabot>   fromList [1,2,4,8,16]
14:59:59 <mmorrow> > glb [3748,927644]
15:00:00 <lambdabot>   fromList [1,2,4,5,8,10,11,13,16,17,20,22,26,34,40,52]
15:01:55 <wli> mmorrow: Well, whatever I was doing stops at 2 iterations, which can be written out by hand to cut the search space down to 1/6 of its original size.
15:02:31 * mmorrow is groking
15:03:13 <mmorrow> (well, i guess that should be the "lub" in this case, but whatever)
15:06:23 <wli> Great, it's running dogslow and getting wrong answers.
15:06:33 <mmorrow> heh
15:06:42 <mmorrow> love that
15:14:08 <wli> mmorrow: crap for some reason it filters out the right answer!
15:14:25 <wli> no never mind
15:14:40 <wli> yeah it does argh
15:15:13 <EvilTerran> ah, the sound of science at work
15:15:27 <EvilTerran> "crap ... never mind ... argh ..."
15:15:33 <Zao> yes, no, yes, no
15:15:53 <wli> mmorrow: Because k `mod` 3 /= 1 is wrong; it needs to be case k `divMod` 3 of { (q, 1) | odd q -> False ; _ -> True }
15:16:19 <skorpan> @src odd
15:16:19 <lambdabot> odd = not . even
15:16:20 <skorpan> @src even
15:16:21 <lambdabot> even n = n `rem` 2 == 0
15:16:25 * mmorrow takes note
15:16:42 <mmorrow> @src rem
15:16:42 <lambdabot> Source not found. stty: unknown mode: doofus
15:16:43 <skorpan> are things like that "optimized" in GHC?
15:16:52 <skorpan> i.e. making odd = n `rem` 2 /= 0?
15:17:39 <mmorrow> skorpan: possibly some, but i'd be willing the bet ((==1) . (.&.1)) is a faster odd
15:17:46 <mmorrow> *..to bet..
15:17:59 <skorpan> @ src (.&.)
15:18:07 <mmorrow> Data.Bits
15:18:11 <skorpan> @src (.&.)
15:18:11 <lambdabot> Source not found. I am sorry.
15:18:14 <skorpan> okay
15:18:19 <skorpan> so that's bitwise and?
15:18:23 <mmorrow> yes
15:18:38 <skorpan> i see... i was almost afraid that was (. & . 1)
15:18:45 <mmorrow> heh
15:18:56 <wli> suckage
15:19:12 <skorpan> :t not.odd
15:19:13 <lambdabot> forall a. (Integral a) => a -> Bool
15:19:16 <skorpan> hm...
15:19:22 <wli> 85s ...
15:19:25 <skorpan> so using . without any whitespace is okay?
15:19:48 <mmorrow> skorpan: only if it's not ambiguous with a qualified name
15:20:20 <mmorrow> > Prelude.id.id
15:20:21 <lambdabot>       Overlapping instances for Show (a -> a)
15:20:21 <lambdabot>        arising from a use of `s...
15:20:28 <skorpan> ah
15:20:44 <skorpan> if i designed a programming language, i would never have allowed that... :P
15:20:47 <mmorrow> err, that actually worked
15:20:53 <Saizan_> ?type Prelude.id.id
15:20:53 <mmorrow> > Prelude.Just.id
15:20:54 <lambdabot> forall a. a -> a
15:20:55 <lambdabot>       Failed to load interface for `Prelude.Just':
15:20:55 <lambdabot>        Use -v to see a lis...
15:21:12 <mmorrow> > Prelude.Just .id
15:21:14 <lambdabot>       Overlapping instances for Show (a -> Maybe a)
15:21:14 <lambdabot>        arising from a use...
15:21:16 <EvilTerran> ?type Just.id -- minimal example
15:21:17 <lambdabot> Couldn't find qualified module.
15:21:24 <wli> Uppercase identifiers barf
15:21:36 <wli> Lowercase identifiers it can figure out, I think.
15:22:09 <EvilTerran> heirarchical modules using "." + operator "." + both modules and constructors having capital letters = ambiguity!
15:23:34 <kadaver> @slap mmorrow
15:23:34 * lambdabot slaps mmorrow with a slab of concrete
15:23:41 <kadaver> just for the hell of it
15:23:47 <skorpan> wasn't there some suggestion about changing stuff like "Prelude.."?
15:23:52 <kadaver> @slap Evilterran
15:23:52 <lambdabot> I won't; I want to go get some cookies instead.
15:23:54 <wli> mmorrow: The thinning code is wrong, too.
15:24:05 <kadaver> @cookie lambdabot
15:24:05 <lambdabot> Unknown command, try @list
15:24:11 <kadaver> @list
15:24:11 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:24:11 <wli> mmorrow: it needs the odd q check too, i.e. step n = (2*n) : case n `divMod` 3 of { (q, 1) | odd q && q > 0 -> [q] ; _ -> [] }
15:24:40 <EvilTerran> skorpan, i think the suggestion was to replace writing, say, (Prelude..) with Prelude.(.)
15:27:35 <EvilTerran> > [False..] -- a particularly daft example
15:27:36 <lambdabot>   <no location info>: parse error on input `]'
15:29:15 <BMeph> > [False ..]
15:29:16 <lambdabot>   [False,True]
15:29:23 <skorpan> > 5 `Prelude.mod` 3
15:29:25 <lambdabot>   2
15:29:29 <skorpan> interesting...
15:30:30 <EvilTerran> the first name after a [ *can't* be an operator, so, by the time it gets to the "..", it's already determinable that "False.." isn't one name
15:30:52 <wli> mmorrow: 84.91s elapsed... NFI WTF I'm doing wrong.
15:31:10 <skorpan> gtfo rtfm
15:31:14 <EvilTerran> OMG WTF IDGI?
15:31:14 <wli> Data.Map is probably sucking, along with a few other things.
15:32:00 <bremner> TLA FTW
15:32:13 <mmorrow> wli: IntMap is noticeably speedier (i've noticed)
15:32:28 <ddarius> mmorrow: It should be.
15:32:34 <mmorrow> but i don't think it's /that/ much speedier
15:33:11 <ddarius> I can easily believe an order of magnitude difference for a fairly large map.
15:33:14 <wli> mmorrow: Brute force hack to get integer overflows out of the equation, also no cutoffs on the caching/memoing.
15:33:32 <mmorrow> ddarius: for sure. but aside from the unpacked keys in the constructors, it's a different structure as well
15:34:05 <mmorrow> (i dunno how the different structures compare (on Ints))
15:34:16 <mmorrow> wli: hmm
15:34:19 <ddarius> Yes, I know.  It has better asymptotics which, by itself, could lead to an order of magnitude difference.
15:34:28 <wli> mmorrow: The thinning results suggest that while additional thinning occurs beyond 2 (and even 10) diminishing returns rapidly set in.
15:35:36 <mmorrow> ddarius: i wonder if patricia trees could be extended to any (Bits key)
15:35:37 <wli> mmorrow: Basically 2 passes get it to somewhere just above 190K and additional passes reduce things but not below 190K out to 25 passes or so.
15:35:39 <ddarius> > (logBase 2 (logBase 2 1000000), logBase 2 1000000)
15:35:40 <lambdabot>   (4.316983346365776,19.931568569324174)
15:36:11 <mmorrow> wli: hmm
15:36:20 <wli> (no idea what happens beyond 25 passes)
15:36:51 <wli> mmorrow: So starting with [k :: Integer | k <- [10^(6::Int), 10^(6::Int) - 1 .. 5*10^(5::Int) + 1], case k `divMod` 3 of { (q, 1) | odd q -> False ; _ -> True }, case (2*k) `divMod` 3 of { (q, 1) | odd q && q <= 10^(6::Int) -> False ; _ -> True} ] as the search space and memoing probably is as good as that sort of thinning gets.
15:36:59 <mmorrow> ddarius: really? (patricia trees are lg(lg n)?!)
15:37:57 <bremner> errr, shannon bound?
15:38:13 <mmorrow> ddarius: hmm, i must have misunderstood
15:38:18 <bremner> oh, wait, not comparison based?
15:38:23 <bmh> I just wish the suffix tree implementation on hackage supported O(n) construction.
15:38:33 <mmorrow> bremner: oh yeah, true
15:38:49 <tomh> stupid question: s -> (a, s)	has one argument but when I run it I need to pass in a state computation and the actual state, why is that?
15:39:08 <tomh> s -> (a,s) being runState
15:39:30 <skorpan> :t runState
15:39:31 <mmorrow> wli: a memoizing threshold of 100,000 was a full second faster than both 10,000 1,000,000 for my version
15:39:31 <lambdabot> forall s a. State s a -> s -> (a, s)
15:39:53 <tomh> ah there is the first argument -.-
15:40:01 <ddarius> mmorrow: Actually, according to the documentation, it's O(min(n,W)) for many operations where W is the bitwidth (i.e. 32/64)
15:40:28 <tomh> why is the first argument not mentioned in the newtype decleration or is it implicit or something?
15:40:49 <mmorrow> wli: the non-trivial/linear response to the thresh (and other things it seems) is interesting
15:40:52 <tomh> or thats part of the record functionality?
15:42:56 <skorpan> tomh: good question, now i'd like to know as well
15:42:58 <mmmdonuts> tomh, yes, that's part of record functionality.  e.g. consider newtype Foo = Foo { fld :: String }
15:43:01 <mmorrow> ddarius: hmmm, i wonder what the constant in Data.Map.insert is
15:43:11 <mmmdonuts> Then fld has signature: Foo -> String
15:43:56 * mmorrow reads how patricia trees work
15:44:18 <skorpan> how does she work?
15:44:33 <tomh> ah yeah, I should've known that, but its late :P
15:45:31 <tomh> skorpan: you can see records as data types which under the hood builds functions to gather parts of the constructor
15:46:41 <skorpan> i don't get it...  data F = F Int Int vs. data F = F { x :: Int, y :: Int }, is there any difference other than .........
15:46:43 <skorpan> i just got it. :)
15:46:50 <mmmdonuts> :)
15:46:51 <skorpan> x :: F -> Int
15:46:55 <skorpan> right?
15:46:57 <tomh> yeah
15:47:01 <skorpan> awesome, thanks
15:47:09 <bremner> skorpan: free constructors!
15:47:10 <skorpan> never thought of it like that before, even though i use it all the time
15:47:12 <wli> mmorrow: Down to 55s :(
15:47:13 <bremner> err accessors
15:47:27 <tomh> skorpan: yeah same here :p
15:50:37 <wli> mmorrow: I suspect the State monad may be slow.
15:51:05 <lpsmith> wli:  Control.Monad.State.Strict isn't too bad
15:51:09 <mmorrow> wli: are you using St
15:51:10 <mmorrow> yeah
15:51:26 <wli> No, Control.Monad.State
15:51:31 <dons> oh, adaptive state monads.
15:51:34 <lpsmith> but indeed,  ST is often better
15:51:48 <wli> Control.Monad.State.Strict runs in 1.43s
15:52:01 <wli> Problem fixed. :)
15:52:39 <mmorrow> wli: this is the State monad i use all the time. it's faster than Control.Monad.Strict http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2088#a2088
15:52:46 <wli> It's a little golfed... let me clean up a little.
15:52:53 <mmorrow> nice!
15:53:01 <mmorrow> 55s ==> <2s ??
15:53:09 <wli> 1.43s
15:53:28 <wli> The difference being Control.Monad.State vs. Control.Monad.State.Strict
15:53:29 <mmorrow> 55s ==> 1.43 ??!?!
15:53:36 <wli> Yes.
15:53:44 <lpsmith> mmorrow:  that's a strict monad,  and it's just StateT st (Cont o)
15:53:51 <mmorrow> wli: try that S. it'll probably be faster still
15:53:55 <lpsmith> ignoring the forall stuff
15:54:06 <mmorrow> lpsmith: but that can't be ignored :)
15:54:23 <lpsmith> yes and no...
15:54:24 <wli> mmorrow: I don't need it as fast as possible, just "good algorithm" fast.
15:54:26 <lpsmith> I used to like that trick
15:54:26 <mmorrow> lpsmith: (it's twice as fast as Control.Monad.State.Strict consistently)
15:54:34 <lpsmith> but now I generally avoid it myself :-)
15:54:42 <lpsmith> hmm
15:54:44 <lpsmith> interesting
15:54:49 <mmorrow> so 4seconds with Control.Monad.State.Strict ==> 2s with S
15:55:08 <lpsmith> (I use that monad myself some too... ;-)
15:55:26 <mmorrow> lpsmith: http://moonpatio.com/repos/MISC/state-bench/
15:55:50 <mmorrow> it beats unboxed tuples state too
15:56:02 <mmorrow> newtype S s a = S (s -> (# a, s #))
15:56:17 <edwardk> wli: nice
15:56:33 <edwardk> er mmorrow =)
15:56:55 <mmorrow> lpsmith: (i was floored when i first saw this, but ever since i only use that S :)
15:57:11 <edwardk> mmorrow: heh i was just getting ready to write an unboxed tuple based state, thanks for saving me the time ;)
15:57:24 <mmorrow> edwardk: :)
15:57:37 <lpsmith> mmorrow:  yes indeed,  I too have noticed the performance advantages with CPS under ghc,  not entirely sure why...
15:57:40 <dons> mmorrow: is it on hackage?
15:57:49 <mmorrow> edwardk: i believe the huge gain comes from not having to unpack then re-pack the tuple in (>>=)
15:57:49 <dons> mtl-cps
15:57:59 <edwardk> mmorrow: yeah
15:58:04 <mmorrow> dons: i'm not sure if dolio put
15:58:09 <mmorrow> it up
15:58:27 <edwardk> mmorrow: i was going through and testing if i could get speed wins from an unboxed writer, etc.
15:59:01 <edwardk> mmorrow: hrmm
15:59:13 <edwardk> mmorrow: i wonder how good the equivalent stateT would be
15:59:27 <lpsmith> Ok,  one downside of the StateCPS monad is that it's more strict than Control.Monad.State.  I'm not sure if it has the same semantics as State.Strict or not,  but that should be easy to work out
15:59:34 <mmorrow> edwardk: i have a repo of some minimal monads using that strategy here (C is iffy, probably just use regular Cont..) http://moonpatio.com/repos/monad-cps/
15:59:56 <mmorrow> i haven't benchmarked the W in there, but i bet it'd have the same benefits
16:00:04 <lpsmith> However,  StateCPS has the avantage that laziness can be recovered using an analog to the mapCont operator
16:00:24 <mmorrow> lpsmith: hmm
16:00:29 <edwardk> mmorrow: handy
16:01:06 <mmorrow> lpsmith: could that work though, since the o is forall'ed?
16:01:08 <edwardk> mmorrow: Id == Yoneda ;)
16:01:14 <score> mm, how can i find out what exceptions a function like 'writeFile' can throw?
16:01:15 <edwardk> er Yoneda Identity
16:01:15 <mmorrow> edwardk: totally! :)
16:01:20 <mmorrow> err, yeah
16:01:27 <lpsmith> mmorrow:   you are probably right
16:01:43 <lpsmith> mmorrow:   there is probably a parametric argument here that prevents the use of mapcont
16:02:26 <lpsmith> so,  good point...
16:02:33 <mmorrow> lpsmith: i've tried to sneak similar things into that, and it always gives you the "cannot match o against o1.."
16:02:54 <edwardk> mmorrow: My hypothesis is that basically if you only use the monadic value once the Writer, etc. here will probably be a win, but if you unpack the same Writer multiple times it'd probably lose. given the usual idiom of just sending a monad into >>= once thats probably a win
16:03:41 <lpsmith> edwardk:  ahh, the glorious glasgow haskell compilation system ;-)
16:04:24 <lpsmith> I have hypotheses too.   It can be hard to determine whether or not they are correct, however
16:05:02 <lpsmith> In my case,  I like to read ghc-core from time to time.   However,  I have one hypothesis that I'm going to need to study the assembly language for,  unless I come up with some other clever trick
16:05:05 <edwardk> lpsmith: well, i've observed this behavior with Yoneda/CoYoneda/Codensity/Density, these are just analogues ;)
16:06:17 <mmorrow> edwardk: yeah, for a single use of (>>=) they'll be (essentially) equiv i think
16:06:59 <edwardk> basically since Yoneda forces map fusion, if you use the intermediate mapped yoneda'd functors, you pay for all of the mapped applications each time.
16:07:41 <edwardk> similarly if you use the Codensity to change the asymptotics of a tree traversal, if you peek at the result of an intermediate traversal you pay in full each time
16:08:37 <mmorrow> interesting
16:08:49 <edwardk> anyways, a similar construction can be done on the comonads using the left kan extension and contravariant yoneda lemma
16:09:40 <edwardk> which is a categorical dual of janis voigtlaender's asymptotic performance improvements over the free monad paper
16:09:53 <mmorrow> score: probably only IOException
16:10:07 <edwardk> i keep meaning to write it up, but no one cares about comonads ;)
16:10:11 <mmorrow> score: (save heap/stack exhaustion and undefined)
16:10:13 <ddarius> edwardk: Meaning - free paper!  "Asymptotic Performance Improvements over Cofree Comonads"
16:10:20 <edwardk> haha
16:10:43 <bremner> meaning free paper. Who hasn't written a few of those
16:10:49 <edwardk> bremner: lol
16:11:59 <wli> Okay, I cleaned it up a little, though I hand-edited what I pasted into pastebin in its editbox.
16:12:03 <wli> http://wli.pastebin.com/m3af9cc83
16:12:13 <mmorrow> you should write a module that computes the categorical dual paper of any given input paper
16:12:19 <mmorrow> edwardk:
16:12:29 <mmorrow> then write a paper about it
16:12:34 <mmorrow> and run it on that!
16:13:04 * mmorrow thinks a mini blackhole would form and swallow the earth
16:13:24 <edwardk> haha
16:13:48 <ddarius> mmorrow: The paper should be a fixed point.  Frank Atanassow's paper would also be a fixed point.
16:13:49 <edwardk> mmorrow: nah, too many of them would require a programming language with coexponentials. ;)
16:14:03 <ddarius> edwardk: SLC
16:14:11 <saml> how can I read from stdin?
16:14:20 <wli> mmorrow: The ungolfing/cleanup slowed it down very slightly, 1.53s vs. 1.43s
16:14:49 <edwardk> ddarius: there is that whole poset problem if you admit them in general though.
16:15:06 <jedai> saml: getLine, getContents, ...
16:15:16 <saml> ah i'm stupdi
16:15:30 <jedai> saml: Look at the Prelude (and System.IO eventually)
16:15:57 <edwardk> coapply :: b -> (b - a) + a -- is still a beautiful type though ;)
16:16:54 * ddarius considers raising his (non-existent) child on non-commutative arithmetic.
16:17:02 <edwardk> ddarius: hah
16:18:00 <lpsmith> ddarius:   Frank Atanassow?   What paper are you referring to?
16:18:24 <mattam> b - a?
16:19:26 <ddarius> "Inferring Type Isomorphism Generically"
16:20:19 <lpsmith> seet, thanks!
16:20:23 <lpsmith> err, sweet ;-)
16:20:52 <saml> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3685#a3685  how can I optimize this?
16:20:58 <saml> input is quite large
16:21:16 <wli> mmorrow: Caching cutoffs don't seem to matter a whole lot for the algorithm I pasted.
16:22:12 <mmorrow> ddarius: interesting link
16:22:31 <wli> Fastest Collatz in the West?
16:22:47 <RayNbow> @seen dons
16:22:47 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 24m 58s ago.
16:23:22 <mmorrow> wli: nice
16:23:49 <dolio> edwardk: Is coapply an isomorphism?
16:23:50 <mmorrow> i'm at real	0m1.781s  with a thresh of 10,000
16:23:51 <dons> hey RayNbow. saw your comments
16:24:15 <mmorrow> (with my version), trying yours now
16:24:16 <RayNbow> dons: I'm not sure how the blog's author compiled it, but probably ghc -O2 --make
16:24:29 <ddarius> dolio: Presumably he means the unit of the adjunction.
16:24:45 <dons> Prelude> 17677692470 > fromIntegral (maxBound :: Data.Int.Int32)
16:24:45 <dons> True
16:25:19 <dons> still, with Integer, I get 0.3s not 2.3
16:25:41 <Gqdlr> What's the difference between haskell and python?
16:25:57 <dons> RayNbow: "Thanks for that link, also, I ran you code and it takes 0.29 seconds on the first run.
16:25:59 <RayNbow> dons: also, my version uses dropWhile (which could also be causing the slow done)
16:26:02 <wli> mmorrow: I've been benching the wrong function!
16:26:02 <dons> I‚Äôll average it now and update the post."
16:26:09 <dons> RayNbow: yeah, that's not needed
16:26:12 <dons> readInt* will skip whitespace
16:26:13 <RayNbow> *slowdown
16:26:14 <lament> Gqdlr: one starts with H, the other with P
16:26:19 <RayNbow> dons: it does?
16:26:29 <dons> Gqdlr: http://wiki.python.org/moin/PythonVsHaskell
16:26:33 <dons> RayNbow: yup.
16:26:44 <dons> iirc...
16:26:49 <dons> ah no.
16:26:51 <dolio> ddarius: Well, I was thinking we don't say apply : (b / a) * a -> b, so while (b - a) + a might be nice looking, I'm not sure it makes sense.
16:26:54 <dons> but we use tail to skip the whitespace
16:26:55 <mmorrow> wli: real	0m1.672s
16:27:06 <mmorrow> wli: runroh
16:27:11 <dons> RayNbow: so it relies on the input format being single char separated.
16:27:16 * RayNbow nods
16:27:19 <SubStack> dons: are they even applicable?
16:27:26 <SubStack> er, comparable
16:27:37 <dons> python v haskell?
16:27:39 <RayNbow> so it would probably blow up if the file uses DOS linebreaks
16:27:43 <dons> well, the python wiki has a comparison.
16:27:43 <wli> mmorrow: It's some golfed thing elsewhere in the original file.
16:27:52 <dons> RayNbow: i think the problem is underspecified anyway
16:28:09 <dons> it's one of those "do the task" problems
16:28:15 <dons> so anyway to get the correct result is ok.
16:28:17 <SubStack> I wouldn't class python as especially elegant as that page contends
16:28:18 <dolio> But I don
16:28:37 <RayNbow> dons: yes, that's why I cheated in my slow asm version :p
16:28:43 <dolio> Bah. I don't really know anything significant about what coexponentials lead to or anything, so maybe it does make sense.
16:28:47 <dons> hehe
16:28:52 <wli> mmorrow: http://wli.pastebin.com/m2cb5951f <-- the golfed thing that's 5 times faster than what I pasted on my machine
16:29:18 <lament> SubStack: you're surprised that the python wiki says python is elegant?
16:29:20 <iago_> @src fix
16:29:20 <lambdabot> fix f = let x = f x in x
16:29:54 <iago_> :t \f -> (\x -> x) f x
16:29:56 <lambdabot> forall t. (Expr -> t) -> t
16:30:21 <dons> edwardk: you've not done IntMap yet, is that right?
16:30:24 <dons> nor Data.Map?
16:30:29 <iago_> :t \f -> (\x -> x) (f x)
16:30:30 <lambdabot> forall t. (Expr -> t) -> t
16:30:31 <SubStack> lament: imagine!
16:31:26 <edwardk> dons: yeah i didn't bother considering i was benchmarking against it
16:32:06 <edwardk> dons: i was trying to see how the packing/unpacking affected the performance of the structure i have before i branch out since what i'm doing there will dramatically affect how i implement those
16:32:56 <dons> i'm going to do IntMap now then
16:39:09 <ikanobori> dons: I recompiled your comment and the C one, the haskell one now takes .05 seconds, c take .04 seconds, average over 10
16:39:13 <ikanobori> so they are pretty much even
16:39:54 <wli> How did the faster golfed version do?
16:40:51 <RayNbow> when Haskell code blazes at C-speed, it makes me go http://www.haskell.org/logos/logos/NarleyYe.jpg :p
16:41:04 <RayNbow> hmm
16:41:11 <RayNbow> I should actually get a T-Shirt with that
16:41:26 <RayNbow> and wear it when I'm assisting this semester's Haskell lab course :p
16:44:24 <ehird> http://ikanobori.jp/weblog/2009/04/11/language-performance-on-the-sum-of-a-file/ ‚Üê QUICK WE MUST MICROOPTIMIZE THE HASKELL VERSION
16:44:27 * ehird *ahem*
16:46:24 <wli> I'm not sure how the golfed version is different.
16:47:35 <wli> Never mind, the ungolfed version works fine when the threshold is set properly.
16:47:45 <RayNbow> ehird: dons already did :p
16:48:01 <ehird> RayNbow: yeah I made a bet with myself that he had in the comments ... and won!
16:48:03 <ehird> now i'm rich
16:49:22 <kadaver> so you cant run haddock with just exporting function types?
16:49:56 <Raevel> man, i had this question... but what was it
16:50:02 <luite> ikanobori: you accidentally the indenting on the C code
16:52:38 <ikanobori> luite: wordpress accidentally the whole
16:52:45 <ikanobori> i'll get to it
16:54:14 <wli> One could generalize the Collatz chain length maximization problem to maximizing the Collatz chain length over an otherwise arbitrary finite set of integers.
16:57:56 <dons> we can be happy now. http://ikanobori.jp/weblog/2009/04/11/language-performance-on-the-sum-of-a-file/
16:57:59 <dons> bytestrings yay
16:59:21 <dons> ikanobori: that's cool. and makes sense: those numbers match roughly what the shootout is doing
16:59:33 <dons> the universe is in balance :)
17:00:04 <luite> it proves that 8 times faster than asm!
17:00:12 <jml> dons: nice.
17:00:21 <luite> +haskell is
17:00:26 <dons> luite: hah. i bet you could just take the asm from C, and tune it... :)
17:00:39 <mm_freak> @faq can haskell solve social problems?
17:00:39 <lambdabot> The answer is: Yes! Haskell can do that.
17:01:06 <jml> I wrote a target solver in haskell the other day, it basically performed exactly the same as Python.
17:01:21 <dons> RayNbow: you know why it is ok to parse as Int, and return an Integer?
17:01:30 <wli> jml: Target solver?
17:01:48 <ikanobori> dons: better to have the universe in balance, would be a bad night out otherwise
17:01:52 <RayNbow> dons: not really?
17:01:54 <jml> wli: "Target" is a puzzle in the Sydney Morning Herald. Will find ...
17:02:00 <ddarius> The problem with the assembly is probably use of getchar
17:02:14 <dons> RayNbow: well, each literal fits in an Int, but our accumulator is an Integer
17:02:18 <jml> wli: http://www.smh.com.au/entertainment/puzzles/target.html
17:02:41 <luite> ddarius: that's true. RayNbow took an old version of my C code and translated it into asm (with some minor optimizations).
17:02:57 <RayNbow> dons: how does ghc infer the accumulator is an Integer?
17:03:02 <luite> ddarius: the old C version, which used getchar, was about as fast as the asm
17:03:22 <jml> I think if I read the word list using bytestrings I might gain some win.
17:03:32 <dons> RayNbow: readInteger says so
17:03:45 <dons> sorry, I mean. we could say so :)
17:04:02 <RayNbow> dons: ah ok
17:04:08 <RayNbow> by adding fromIntegral or something, right? :)
17:04:45 <luite> I wonder if there's some way to parse the ints faster than one byte at a time, given that each int is either 1-4 bytes, and all ints are separated by a single space or newline
17:05:25 <dons> RayNbow: yeah, we could do that.
17:05:33 <dons> but its easily fast enough anyway
17:06:53 <RayNbow> luite: the old C version which used getchar was actually slightly faster than my asm code :p
17:07:01 <RayNbow> about 0.05s :p
17:07:29 <luite> yes that's because you're a terrible asm coder :p
17:07:34 <RayNbow> indeed :p
17:07:53 <bremner> all the good asm coders are working on Clean
17:07:55 <RayNbow> I should just use Haskell+Lazy ByteString+readInt and be faster than asm :p
17:08:51 <RayNbow> luite, we should submit a BCD version for fun :p
17:09:00 <RayNbow> and make use of x86's BCD functions :p
17:09:05 <wli> A BCD version of what?
17:09:06 <RayNbow> *instructions
17:09:22 <RayNbow> wli: http://ikanobori.jp/weblog/2009/04/11/language-performance-on-the-sum-of-a-file/
17:11:14 <RayNbow> anyway, going to get some sleep... g'night #haskell :)
17:11:37 <Venar> nighty :)
17:12:41 <Venar> in ghci, if i do [1,2,3]++[2,3,4], i get [1,2,3,2,3,4] is there a way to remove duplicates?
17:14:40 <tomh> yeah
17:14:55 <tomh> with the amazingly bad named function 'nub'
17:15:09 <bremner> > nub [1,2,3]++[2,3,4]
17:15:10 <tomh> > nub $ [1,2,3]++[2,3,4]
17:15:11 <lambdabot>   [1,2,3,2,3,4]
17:15:11 <lambdabot>   [1,2,3,4]
17:15:18 <bremner> bah
17:15:30 <bremner> gotta sort, I guess
17:15:34 <tomh> > nub  [1,2,3]++[2,3,4]
17:15:36 <lambdabot>   [1,2,3,2,3,4]
17:15:38 <Venar> ok cause i get an error with nub
17:15:41 <tomh> > nub  $ [1,2,3]++[2,3,4]
17:15:42 <lambdabot>   [1,2,3,4]
17:15:58 <bremner> arghh. operator precedence
17:16:03 <tomh> :)
17:16:18 <Venar> Prelude> nub [1,2,3,3,4]
17:16:18 <Venar> <interactive>:1:0: Not in scope: `nub'
17:16:24 <byorgey> Venar: import Data.List
17:16:30 <Venar> lemme try the $ sign
17:16:36 <tomh> :index nub
17:16:41 <tomh> @index nub
17:16:41 <lambdabot> Data.List
17:16:49 <Venar> yes, i think that would help
17:17:02 <byorgey> =)
17:17:06 <tomh> $ is just () around whatever is after the $
17:18:04 <Venar> thank you very much! i needed to import the module :)
17:18:30 <Gracenotes> $.$
17:18:47 <kerlo> "nub" is a lot shorter than "remove duplicates", though I still don't see the logic behind it.
17:19:09 <bremner> uniq would have been better
17:19:11 <tomh> remove duplicates is not entirely what describes what it does
17:19:27 <tomh> uniqueValues is the best choice i have found
17:19:40 <Gracenotes> > let (^.^) = ($).($) in (+1) ^.^ (-1)
17:19:41 <dmwit> I think they wanted to avoid comparison to the Unix command uniq, which doesn't actually remove duplicates unless they're right next to each other.
17:19:42 <lambdabot>   0
17:19:53 <wli> Most of the time I do Set.toList . Set.fromList if I don't just use Set everywhere.
17:20:01 <bremner> dmwit: ack
17:20:15 <tomh> hehe is that more efficient?
17:20:17 <Gracenotes> generally one must sort it then
17:20:25 <dmwit> tomh: n log n instead of n^2
17:20:26 <Gracenotes> which can be slow
17:20:34 <tomh> ok
17:20:36 <dmwit> tomh: But requires Ord instead of Eq.
17:20:48 <dmwit> (Which usually isn't an issue.)
17:20:54 <tomh> yeah
17:21:47 <wli> I usually just try to use Set everywhere whenever such things are an issue.
17:22:00 <Gracenotes> > sortBy (const.const$EQ) [10,9..1]
17:22:01 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
17:22:25 <Venar> wow that bot is awesome
17:22:32 <tomh> >[10..1]
17:22:37 <vav> @botsnack
17:22:37 <lambdabot> :)
17:22:37 <lunabot>  :)
17:22:43 <tomh> >show [10..1]
17:22:52 <dmwit> tomh: Add a space after the '>'.
17:22:52 <tomh> > show [10..1]
17:22:53 <lambdabot>   "[]"
17:22:57 <dmwit> > [10..1]
17:22:58 <lambdabot>   []
17:23:00 <dmwit> > [10,9..1]
17:23:02 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
17:23:07 <Venar> haha verry cool
17:23:07 <wli> I've occasionally found Data.MultiSet handy, too.
17:23:11 <tomh> mm why is that?
17:23:20 <dmwit> tomh: Which thing?
17:23:28 <tomh> that 10..1 = []
17:23:32 <dmwit> What do people use for Unicode input on Linux?
17:23:33 <tomh> and 10,9..1 = that
17:23:34 <vav> > [10,8..0]
17:23:35 <lambdabot>   [10,8,6,4,2,0]
17:23:40 <dmwit> tomh: Because 10 < 1. ;-)
17:23:56 <tomh> so you need to hint it to go downwards?
17:24:02 <dmwit> tomh: Imagine [a..b] being the list of numbers at least as big as a and at most as big as b.
17:24:16 * shapr yearghs
17:24:21 <Gracenotes> yah. just the weird convention that's used.
17:24:29 <dmwit> tomh: Or, you can imagine it as the obvious continuation of the following pattern:
17:24:34 <Gracenotes> it's at least clear in code
17:24:43 <dmwit> > [[1..3], [1..2], [1..1], [1..0]]
17:24:43 <shapr> @tell lysgaard Henning Thielemann says st.h is part of SoX
17:24:44 <lambdabot> Consider it noted.
17:24:44 <lambdabot>   [[1,2,3],[1,2],[1],[]]
17:24:57 <tomh> ok
17:25:18 <tomh> > [1.1..10]
17:25:20 <lambdabot>   [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1]
17:25:24 <Gracenotes> > map (enumFromTo 1) [1..]
17:25:26 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
17:25:33 <tomh> > [1.1,1.2..10]
17:25:35 <lambdabot>   [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.5999999...
17:25:45 <tomh> hehe
17:25:57 <dmwit> > [1.5,3.5..10]
17:25:59 <lambdabot>   [1.5,3.5,5.5,7.5,9.5]
17:26:02 <dmwit> > [1.5,3.5..11]
17:26:04 <lambdabot>   [1.5,3.5,5.5,7.5,9.5,11.5]
17:26:04 <Gracenotes> > map <$> enumFromTo <*> enumFrom $ 1
17:26:06 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
17:26:07 <dmwit> Surprise!
17:26:21 <wli> BCD floats anyone?
17:26:32 <dmwit> ?seen Cale
17:26:33 <lambdabot> Cale is in #ghc, #haskell-in-depth, #haskell-overflow and #haskell. I last heard Cale speak 2h 43m 36s ago.
17:26:42 <Gracenotes> > map <$> enumFromTo <*> enumFrom $ 100
17:26:44 <lambdabot>   [[100],[100,101],[100,101,102],[100,101,102,103],[100,101,102,103,104],[100...
17:26:45 <tomh> ah thanks for the reminder, have to look up what <*> and <$> do for my exam -.-
17:27:14 <Gracenotes> it can also be written "liftM2 enumFromTo enumFrom", or liftA2
17:27:21 <dmwit> ?ask Cale I vaguely remember someone suggesting some input method for X that let you use TeX for Unicode symbols.  Was that you?  What was that method?
17:27:21 <lambdabot> Consider it noted.
17:27:29 <tomh> liftA2 ?
17:27:39 <dmwit> tomh: liftM2, but for Applicative instead of Monad
17:27:49 <Gracenotes> in this case, Applicative and Monad do the same thing for functions
17:27:55 <tomh> ok, so in the case that something is applicative and not monad?
17:28:08 <Gracenotes> right
17:28:12 <tomh> ok
17:28:46 <Gracenotes> if it makes more sense to deal with something as an Applicative
17:29:12 <Gracenotes> > liftA2 (,) head length $ "hello"
17:29:13 <lambdabot>   ('h',5)
17:29:32 <dmwit> > head &&& length $ "hello"
17:29:33 <lambdabot>   ('h',5)
17:29:34 <tomh> @src (.)
17:29:35 <lambdabot> (f . g) x = f (g x)
17:30:11 <Gracenotes> you mentioned an exam? Applicatives probably won't be on it :)
17:30:24 <dmwit> > [1.5, 3.5 .. 11] -- tomh, see if you can explain this one ;-)
17:30:26 <lambdabot>   [1.5,3.5,5.5,7.5,9.5,11.5]
17:30:43 <tomh> Gracenotes: no, i have to fear for far more difficult questions :)
17:31:05 <tomh> dmwit: just steps of 2  right?
17:31:21 <Gracenotes> tomh: really? :o
17:31:29 <tomh> Gracenotes: yeah
17:31:34 <dmwit> tomh: Check the bounds, and the last element of the resulting list. =O
17:32:04 <Gracenotes> applicatives are great for writing pointless programs. Er, I mean 'pointfree' of course.
17:32:17 <Saizan_> > [1,3 .. 11]
17:32:19 <lambdabot>   [1,3,5,7,9,11]
17:32:19 <tomh> dmwit: I just thought that was a weird concession of the implementation, first answer closed to the last one
17:32:30 <Saizan_> > [1,4 .. 11]
17:32:31 <lambdabot>   [1,4,7,10]
17:32:36 <tomh> Gracenotes: all the questions on the exam are about pointless programs
17:32:45 <tomh> else it would be too easy :)
17:33:09 <dmwit> > [2.5, 4.5 .. 12] -- tomh, your answer doesn't cover this case, though
17:33:10 <lambdabot>   [2.5,4.5,6.5,8.5,10.5,12.5]
17:33:15 <dmwit> err
17:33:18 * dmwit blinks
17:33:32 <tomh> i guess it also incorporates some rule about rounding down :P
17:33:47 <dmwit> > (round 1.5, round 2.5)
17:33:49 <lambdabot>   (2,2)
17:33:52 <tomh> > [2.9,4.9..11)
17:33:52 <dmwit> ;-)
17:33:53 <lambdabot>   <no location info>: parse error on input `)'
17:33:54 <tomh> > [2.9,4.9..11]
17:33:55 <lambdabot>   [2.9,4.9,6.9,8.9,10.9]
17:34:08 <tomh> > [2.51,4.51..11]
17:34:09 <lambdabot>   [2.51,4.51,6.51,8.51,10.51]
17:34:15 <dmwit> tomh: It's specifically an oddity with using halves, because "round" uses baker's rounding.
17:34:18 <tomh> > [2.5,4.5..11]
17:34:20 <lambdabot>   [2.5,4.5,6.5,8.5,10.5]
17:34:35 <tomh> huh
17:34:48 <dmwit> yeah
17:34:53 <Gracenotes> > map round [1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5]
17:34:55 <lambdabot>   [2,2,4,4,6,6,8]
17:35:05 <tomh> lambdabot	 [2.5,4.5,6.5,8.5,10.5,12.5]
17:35:13 <tomh> why did that go through and my sample didn't
17:35:15 <dmwit> Yeah, I don't understand that one either.
17:35:46 <Gracenotes> @. vixen run [2.5, 4.5 .. 12]
17:35:48 <lambdabot> what type of car do you drive?
17:35:48 <dmwit> > 12.5 == 25 / 2
17:35:50 <lambdabot>   True
17:35:51 <Gracenotes> a cdr!
17:35:55 <tomh> > [2.49,4.49..11]
17:35:57 <lambdabot>   [2.49,4.49,6.49,8.49,10.49]
17:36:07 <Gracenotes> speaking of pointless: putStrLn.unlines.(!!4).iterate((++)<$>((<$>)=<<(++).(>>" "))<*>(<$>)(((<*>).((.)<$>)<*>flip)(++)<*>takeWhile(==' ')))$[" /\\","/__\\"]
17:36:08 <tomh> > [2.49,4.49..12]
17:36:10 <lambdabot>   [2.49,4.49,6.49,8.49,10.49,12.49]
17:36:14 <tomh> > [2.49,4.49..10]
17:36:15 <lambdabot>   [2.49,4.49,6.49,8.49,10.49]
17:36:20 <Gracenotes> :) I just wish there was some way to make the 'flip' more confusing
17:36:20 <tomh> > [2.49,4.49..11]
17:36:21 <lambdabot>   [2.49,4.49,6.49,8.49,10.49]
17:36:30 <Gracenotes> oh wait, that's the wrong version. whatever though.
17:36:46 <tomh> > [2.49,4.49..11] == [2.49,4.49..10]
17:36:47 <lambdabot>   True
17:37:07 <tomh> hehe, I know some teachers would love to ask that as exam question :>
17:38:17 <dmwit> > round 12.5
17:38:18 <lambdabot>   12
17:38:34 <dmwit> > round (2.5 + 5 * (4.5 - 2.5))
17:38:35 <lambdabot>   12
17:39:02 <tomh> maybe it uses a customized rounding based on the interval
17:39:05 <dmwit> > round (2.5 + sum (replicate 5 [4.5 - 2.5]))
17:39:07 <lambdabot>       No instance for (RealFrac [t])
17:39:07 <lambdabot>        arising from a use of `round' at ...
17:39:12 <dmwit> oops
17:39:14 <Gracenotes> :o
17:39:16 <dmwit> > round (2.5 + sum (replicate 5 (4.5 - 2.5)))
17:39:17 <lambdabot>   12
17:39:21 <dmwit> hum
17:39:25 <pumpkin> wow
17:39:27 <pumpkin> why does round 12.5 == 12?
17:39:32 <dmwit> pumpkin: Baker's rounding. =)
17:39:33 <Gracenotes> dem baker
17:39:41 <dmwit> pumpkin: Halves round down for even numbers and up for odd numbers.
17:39:41 <pumpkin> that baker's a cheat!
17:39:43 <tomh> :k type A a = a
17:39:44 <lambdabot> parse error on input `type'
17:39:49 <pumpkin> oh wow, I've never heard of that
17:39:50 <Gracenotes> if it's good enough for engineers, it's good enough for you
17:40:00 * pumpkin apparently has a huge gap in his education
17:40:03 <pumpkin> I wonder what else I'm missing
17:40:03 <dmwit> pumpkin: It helps prevent systematic error.
17:40:21 <Gracenotes> well. assuming your data is well distributed
17:40:23 <pumpkin> makes sense now that I've heard of it
17:40:30 <dmwit> Gracenotes: Well, right.
17:40:47 <dmwit> But an assumption of a well-distributed data set is just as wrong as any other assumption. ;-)
17:40:54 <tomh> > round 12.51
17:40:55 <pumpkin> so it's round-to-even basically?
17:40:55 <lambdabot>   13
17:41:01 <tomh> > round 12.5
17:41:03 <lambdabot>   12
17:41:10 <pumpkin> > round 11.5
17:41:11 <lambdabot>   12
17:41:15 <pumpkin> that's no fair!
17:41:19 <pumpkin> :P
17:41:23 <Gracenotes> ur no far
17:41:36 <tomh> round 11.5 == round 12.5
17:41:41 <tomh> > round 11.5 == round 12.5
17:41:42 <lambdabot>   True
17:41:47 <tomh> thats just stupid -.-
17:41:49 <pumpkin> poor 11 gets no action
17:42:06 <dmwit> tomh: Why?
17:42:11 <dmwit> tomh: Is it stupid that
17:42:16 <dmwit> > round 11.51 == round 12.49
17:42:17 <lambdabot>   True
17:42:46 <Gracenotes> @check \a b -> let a' = round a; b' = round b in a' /= b' || even a'
17:42:47 <lambdabot>   "Falsifiable, after 36 tests:\n1.0\n1.125\n"
17:43:11 <tomh> well in python: >>> round(11.5) == round(12.5)
17:43:22 <tomh> >>> False
17:43:37 <dmwit> Sure, there are other choices.
17:43:41 <Gracenotes> @check \n -> let a = round n; b = round (n+1) in a /= b || even a
17:43:42 <dmwit> But that doesn't make this choice stupid.
17:43:42 <lambdabot>   "OK, passed 500 tests."
17:43:55 <pumpkin> rounding is stupid!
17:44:01 <Gracenotes> round n == round (n+1)  =>  round n is even
17:44:41 <tomh> dmwit: well a different rounding strategy just for the fact that a number is even or uneven doesn't make sense to me
17:45:02 <dmwit> tomh: Did you understand what I meant when I said it prevents systematic error?
17:45:13 <dmwit> tomh: If you understand that, it should start to make sense. =)
17:45:39 <tomh> whats that systematic error you talking about
17:46:14 <dmwit> > let roundedSum rounder = sum . map rounder $ [1.5, 2.5, 3.5, 4.5, 5.5, 6.5] in (roundedSum floor, roundedSum round, roundedSum ceiling)
17:46:16 <lambdabot>   (21,24,27)
17:46:23 <monochrom> You haven't heard of round-to-even and its superiority?
17:46:31 <dmwit> If you choose to round halves down, you get an error there; same if you choose to round halves up.
17:46:41 <dmwit> But with baker's rounding, you get the correct answer!
17:46:56 <monochrom> Look for "what every computer scientist should know about floating point" on the web.
17:47:11 <tomh> ok
17:47:29 <dmwit> Floating point bites.
17:47:33 <pumpkin> f**king bakers
17:47:37 <pumpkin> always complicating things
17:47:44 <pumpkin> I just want olives in my bread
17:48:09 <dmwit> Fucking consumers, not acknowledging the world's complexity.
17:48:19 <dmwit> ;-)
17:48:36 <ddarius> dmwit: I didn't pay to have a complex world.
17:48:55 * dmwit didn't get paid at all =/
17:49:08 <ddarius> dmwit: I blame the product you're peddling.
17:49:16 <dmwit> So you didn't pay enough to get a simple world. =)
17:49:47 <pumpkin> nA1828KcFz9q: that's quite the nick
17:49:54 <pumpkin> nA1828KcFz9q: what's its etymology?
17:49:59 <nA1828KcFz9q> identification
17:50:05 <tomh> meh time for sleep
17:50:20 <nA1828KcFz9q> and something else
17:50:24 <Gracenotes> hrm
17:50:39 <Gracenotes> > map (head &&& length) . group . sort . map round . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 8592)
17:50:41 <lambdabot>   [(0,500),(1,961),(2,1012),(3,1066),(4,974),(5,1026),(6,947),(7,985),(8,1025...
17:50:59 <Gracenotes> > map (head &&& length) . group . sort . map round . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 592)
17:51:01 <lambdabot>   [(0,477),(1,961),(2,1021),(3,1062),(4,954),(5,1016),(6,1011),(7,1010),(8,10...
17:51:36 <Gracenotes> seems about right.. lot of variance though ;
17:51:38 <Gracenotes> ;)
17:54:34 <wli> > Map.toList . Map.unionsWith (+) . map (flip Map.singleton 1 . round) . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 592)
17:54:35 <lambdabot>   [(0,477),(1,961),(2,1021),(3,1062),(4,954),(5,1016),(6,1011),(7,1010),(8,10...
17:55:25 <wli> Gracenotes: I find that a little slicker, though it should really be a fold.
17:55:48 <Gracenotes> yeah. forM_ with STArray if speed is really needed :)
17:56:22 <laprice> Am I correct in thinking that a function can return 1 and only 1 value (though it may be of complex type)?
17:56:32 <monochrom> Yes.
17:56:43 <wli> > Map.toList . foldr (flip Map.insert 1) Map.empty . map round . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 592)
17:56:44 <lambdabot>   [(0,1),(1,1),(2,1),(3,1),(4,1),(5,1),(6,1),(7,1),(8,1),(9,1),(10,1)]
17:56:48 <Gracenotes> :x
17:56:53 <wli> argh
17:57:06 <wli> > Map.toList . foldr (flip Map.insertWith (+) 1) Map.empty . map round . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 592)
17:57:07 <lambdabot>       Overlapping instances for Show (a -> a -> a)
17:57:07 <lambdabot>        arising from a use ...
17:57:38 <wli> > Map.toList . foldr (flip (Map.insertWith (+)) 1) Map.empty . map round . take 10000 $ randomRs (0 :: Double, 10) (mkStdGen 592)
17:57:40 <lambdabot>   [(0,477),(1,961),(2,1021),(3,1062),(4,954),(5,1016),(6,1011),(7,1010),(8,10...
17:57:48 <wli> Sorry it took so many tries.
17:58:22 <Gracenotes> nice
17:59:26 <wli> s/Map/IntMap/g for additional speed (I forget lambdabot's thing for that; IS?)
18:00:18 <pumpkin> mmorrow: O master of all things TH, do you know if the latest version of TH on hackage (released the day before yesterday) maybe supports splicing/generating associated types? I know that it was added to HEAD around then, but it seemed strange for them to release a new version on hackage at same time without it
18:02:46 <dmwit> :t accumArray
18:02:47 <mmorrow> pumpkin: there's the TH library side and the TH-in-ghc side, so you'd need a ghc with the corresponding functionality even if you had the new TH lib :(
18:02:47 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
18:03:03 <pumpkin> mmorrow: aw
18:03:28 <dmwit> :t accumArray (+) 0 (0, 10)
18:03:29 <lambdabot> forall e t. (Ix t, Num t, Num e) => [(t, e)] -> Array t e
18:03:53 <pumpkin> mmorrow: my issue with using ruby now boils down to the fact that I can assume it will be on mac os, but not on any other platforms
18:04:04 <pumpkin> linux is likely, windows probably not
18:04:06 <dmwit> > accumArray (+) 0 (0, 10) . map round . take 10000 . randomRs (0 :: Double, 10) $ mkStdGen 592
18:04:08 <lambdabot>       No instance for (Integral (t, e))
18:04:08 <lambdabot>        arising from a use of `round' ...
18:04:29 <dmwit> oh, right
18:04:47 <dmwit> > accumArray (+) 0 (0, 10) . map (round &&& const 1) . take 10000 . randomRs (0 :: Double, 10) $ mkStdGen 592
18:04:49 <lambdabot>   array (0,10) [(0,477),(1,961),(2,1021),(3,1062),(4,954),(5,1016),(6,1011),(...
18:04:57 <mmorrow> pumpkin: dargs get --partial http://darcs.haskell.org/ghc && cd ghc && chmod 700 darcs-all && ./darcs-all --extra get && bash boot && sudo mkdir /usr/local/ghc/ghc-HEAD && ./configure --prefix=/usr/local/ghc/ghc-HEAD && make -j5 && sudo make install
18:04:59 <mmorrow> ;)
18:05:02 <pumpkin> lol
18:05:06 <pumpkin> I have a built copy of it
18:05:10 <mmorrow> nice
18:05:15 <pumpkin> but I can't expect users of the lib to
18:05:27 <dmwit> wli, Gracenotes: How about something like that?  Can't get much better than Array for speed, I think.
18:05:27 * mmorrow initiates the above missile launch sequence in 3
18:05:28 <mmorrow> 2 1
18:05:32 <pumpkin> onoes
18:05:44 <pumpkin> you have dargs btw
18:05:49 <Gracenotes> looks nice
18:05:51 <pumpkin> that might stop your missile launch north korea style
18:06:09 <mmorrow> haha
18:06:11 <ddarius> The Typodong
18:06:17 <mmorrow> bash: dargs: command not found
18:06:21 <mmorrow> doh!
18:06:30 <wli> dmwit: I worry about card marking/GC/etc.
18:06:37 <dmwit> mmm
18:07:11 <dmwit> I would think you would worry about that even more with Map.
18:08:24 <wli> dmwit: Arrays have large pointer branching factors in their internal objects that render GC non-incremental; Map is a binary tree so it's nothing like the array case.
18:08:54 <wli> dmwit: Restoring incrementality requires not-yet-implemented card marking.
18:09:03 <dmwit> Okay, you likely know much more about it than I do.
18:09:35 <Venar> is it possible to make functions in ghci, without writing to file?
18:09:40 <Venar> kinda like in scheme?
18:09:42 <pumpkin> let f x = x + 1
18:10:08 <Venar> let function_name argument = body ?
18:10:14 <Venar> cool thanks :)
18:10:27 <wli> dmwit: When a memory buffer is traced for GC its internal structure (in particular which components of it are pointers) is known. Card marking incrementally traverses the set of pointers within large buffers. Otherwise all the pointers are traversed at once.
18:11:01 <c_wraith> Venar: it's more like "let <declaration>", since haskell doesn't really differentiate between functions and data.
18:11:15 <wli> dmwit: e.g. it'll traverse some fixed number of pointers within the buffer and record its position within the traversal of the whole.
18:11:24 <mmorrow> Venar:
18:11:26 <dmwit> c_wraith: data are nothing more than functions with no arguments. ;-)
18:11:30 <mmorrow> a <- readFile "/etc/passwd"
18:11:44 <dmwit> wli: ah
18:11:51 <dmwit> wli: Yes, I see what you're saying... I think.
18:12:02 <deech> Has anyone had issues with C-c C-l in haskell-mode consistently causing emacs to freeze?
18:12:20 <Venar> hmm
18:13:08 <Venar> yes, your right c_wraith
18:13:23 <Venar> mmorrow, what is that?
18:13:39 <mmorrow> Venar: you can run any IO action as if you were in a do-block
18:14:58 <wli> I'm still trying to decipher the typeclasses vs. modules affair.
18:15:37 <Venar> ok
18:15:52 <mmorrow> so, for instance you can do in ghci:
18:16:03 <mmorrow> a <- rubiks-cube-ify . trieify . querySqlDb ....."
18:16:23 <mmorrow> writeFile "what_would_have_take_2000_lines_of_sql.csv" (formatWithThePretty a)
18:17:51 <mmorrow> or
18:18:07 <mmorrow> let gogo sql = rubiks-cube-ify . trieify . querySqlDb $ sql
18:18:27 <mmorrow> mapM gogo <every table in the the entire thing>
18:18:40 <Venar> what is mapM?
18:18:45 <pumpkin> :t mapM
18:18:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:18:50 <pumpkin> it maps dat monad
18:18:56 <pumpkin> ;)
18:19:06 <Venar> haha ok :)
18:19:06 <mmorrow> (point being ghci is great for using haskell orchestrate massive operation at your whim :)
18:19:20 <Venar> any sick haskell tricks for fibonacci?
18:19:23 <mmorrow> *..to orchestrate ... operations...
18:19:26 <Venar> i have this, but its epically slow  let fib x = if x<2 then x else (fib (x-1)+fib(x-2))
18:19:28 <pumpkin> Venar: the typical one
18:19:34 <mmorrow> , fix ((0:) . scanl (+1) 1)
18:19:37 <lunabot>  luna: Occurs check: cannot construct the infinite type: a = b -> a
18:19:41 <mmorrow> , fix ((0:) . scanl (+) 1)
18:19:42 <wli> mmorrow: I do that kind of stuff all the time.
18:19:43 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
18:19:46 <pumpkin> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 20 fibs
18:19:47 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181]
18:19:51 <mmorrow> wli: me too :)
18:19:57 <pumpkin> but mmorrow's is even prettier
18:19:58 <Venar> whoa
18:20:01 <Venar> what just happened
18:20:24 <pumpkin> :t fix
18:20:25 <Venar> > :t fix
18:20:25 <lambdabot> forall a. (a -> a) -> a
18:20:26 <lambdabot>   <no location info>: parse error on input `:'
18:20:27 <Venar> hahaha
18:20:36 <pumpkin> it's a pretty scary type
18:20:41 <wli> Oh, yeah, that reminds me of a "fresh problem."
18:20:42 <mmorrow> , fix (\x -> 0 : x)
18:20:43 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:20:46 <Venar> ok and o: is the infite list
18:20:49 <Venar> err 0:
18:20:51 <pumpkin> nope
18:20:53 <mmorrow> , vacuum (fix (\x -> 0 : x))
18:20:56 <lunabot>  [(0,[1,0]),(1,[])]
18:21:12 <Venar>  > [0:]
18:21:14 <pumpkin> that's cool that vacuum catches it
18:21:19 <Venar> i thought :S
18:21:22 <pumpkin> :t (0:)
18:21:23 <lambdabot> forall t. (Num t) => [t] -> [t]
18:21:23 <mmorrow> , vacuum [0,0,0,0,0,0,0,0,0,0,0]
18:21:26 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
18:21:31 <wli> There are Fibonacci recurrences to compute F_{m*n+k} where m > 1 and 0 <= k < m given F_n and F_{n+1}.
18:21:37 <dmwit> Venar: (0:) is a function that takes a list and prepends 0 to it.  fix (0:) is the value that has (0:) applied infinitely many times.
18:21:42 <pumpkin> Venar: 0: is a function that takes a list and returns a list
18:21:48 <Venar> ohh i was thinking of [0..]
18:21:53 <pumpkin> :)
18:21:57 <pumpkin> even that isn't necessarily infinite
18:22:01 <wli> And also F_j for 0 <= j < m.
18:22:10 <pumpkin> > length [(0 :: Word8)..]
18:22:12 <lambdabot>   256
18:22:15 <dmwit> > last [0..] :: Int
18:22:20 <dmwit> Mine takes longer. =/
18:22:31 <lambdabot>   thread killed
18:22:33 <pumpkin> , last [0..] :: Int
18:22:39 <lunabot>  Killed.
18:22:40 <pumpkin> maybe luna will succeed where lambdabot failed
18:22:42 <pumpkin> guess not
18:22:55 <Venar> hmm, so.. fix(0:) adds 0 infinitely?
18:22:55 <dmwit> , maxBound :: Int
18:22:57 <lunabot>  2147483647
18:23:04 <pumpkin> Venar: not quite
18:23:05 <wli> So the task (somewhat like addition chain multiplication) is to find the smallest set of intermediately-computed Fibonacci numbers required to compute some set of Fibonacci numbers.
18:23:23 <pumpkin> fix feesa function's output into its input
18:23:27 <pumpkin> *feeds
18:23:36 <dmwit> ?src fi
18:23:36 <lambdabot> Source not found. You speak an infinite deal of nothing
18:23:37 <dmwit> ?src fix
18:23:38 <lambdabot> fix f = let x = f x in x
18:24:01 <dmwit> fix f = f (fix f) -- more readable, but less efficient
18:24:08 <wli> The recurrence is actually a bit more general than that; k can even go negative.
18:24:50 <Venar> so much to learn
18:24:53 <Venar> ! :)
18:24:54 <wli> I suppose one might also want to throw in the ordinary F_n + F_{n+1} = F_{n+2} recurrence atop the multiplication recurrences.
18:25:11 <Venar> :t scanl
18:25:13 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
18:25:32 <pumpkin> Venar: scanl is like a foldl that keeps its intermediate results around
18:25:38 <Gracenotes> > let the = (!); dog = realToFrac.length; (!) = id in let in the dog! []
18:25:40 <lambdabot>   0.0
18:25:43 <ddarius> , let fix f = f (fix f) in vacuum (fix (0:))
18:25:44 <Gracenotes> 0.0
18:25:48 <lunabot>  Killed.
18:26:34 <Venar> i don't know foldl either ! haah
18:28:15 <dons> potrace + inkscape are really cool. http://galois.com/~dons/images/logos/logo-shadow-line.svg
18:28:39 <dmwit> Gracenotes: That's pretty funny.  I especially like the empty let block trick. =)
18:29:03 <Venar> ok i get foldl now
18:29:05 <Gracenotes> yeah, I always found it a bit odd
18:29:16 <Gracenotes> always. like a month. >_>
18:29:21 <pumpkin> :P
18:29:41 <pumpkin> Gracenotes the Haskell old-timer
18:29:51 <Gracenotes> I always say 'always' to generalize
18:30:10 <pumpkin> one should never make generalizations ;) even about generalizations
18:30:43 <Gracenotes> dons: nice. A bit bleak
18:31:05 <dons> well, i'm more playing with what you can do once you get a vector of the logo
18:31:34 <dons> svg rocks
18:33:24 <Venar> :t fix
18:33:26 <lambdabot> forall a. (a -> a) -> a
18:34:35 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml  has explanation of fix.
18:35:15 <ddarius> , vacuum fix
18:35:17 <lunabot>  [(0,[])]
18:35:56 <jmcarthur> ... ", vacuum fix" ... seriously?
18:36:04 <jmcarthur> , vacuum [0..3]
18:36:05 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[])]
18:36:21 <jmcarthur> huh
18:36:26 <ddarius> , fix vacuum
18:36:41 <jmcarthur> that's gross
18:36:56 <jmcarthur> vacuum should definitely not be fixed
18:36:58 <Gracenotes> which vaccum function gives labels?
18:37:36 <ddarius> , iterate vacuum ()
18:37:37 <lunabot>  luna: Couldn't match expected type `[(GHC.Types.Int, [GHC.Types.Int])]'
18:37:48 <ddarius> , iterate vacuum []
18:37:50 <lunabot>  [[],[(0,[])],[(0,[1,2]),(1,[3,2]),(2,[]),(3,[])],[(0,[1,2]),(1,[3,4]),(2,...
18:37:58 <pumpkin> that's fun
18:45:08 <dons> this looks really cool http://www.haskell.org/pipermail/haskell-cafe/2009-April/059708.html
18:45:34 <pumpkin> yeah :) now we need that PhD position that was announced
18:45:35 <dons> take a fast existing library (BLAS/LAPACK), add haskell FFI, add resource management, add view patterns, add statically checked safety
18:45:35 <ddarius> They've been doing it in C++ for years.
18:45:40 <pumpkin> to make numeric types pretty
18:46:09 <dons> its a good instructive example of what you're expected to do when doing FFI stuff
19:03:12 <jml> http://codepad.org/d2zCRREa
19:03:35 <jml> for people who use emacs, python and haskell :)
19:04:15 <Botje> ... pick two  >:)
19:04:23 <Nafai> jml: Is that for flymake? :)
19:04:27 <jml> Nafai: yes.
19:04:47 <jml> Nafai: it's a Python version of the perl scripts on http://www.emacswiki.org/emacs/FlymakeHaskell
19:04:54 <Nafai> Cool
19:05:07 <jml> I guess I should have written it in haskell :)
19:08:00 <altmattr> hi folks, anyone tackled the name-supply problem
19:08:17 <altmattr> i.e. code where a sequence of fresh names is required in muliple places
19:08:30 <altmattr> easily solved in side-effecting langauages
19:08:35 <altmattr> ?
19:08:45 <altmattr> or is it side affecting?
19:08:51 <altmattr> anyway?
19:08:53 <wli> State monads do it fine.
19:09:02 <altmattr> wli: by
19:09:06 <altmattr> oops
19:09:28 <altmattr> by "fine" you mean every functions using them needs to use do-notation?
19:09:47 <altmattr> and I need to use monadic versions for (for example) SYB traversals?
19:09:56 <wli> yeah
19:10:01 <altmattr> believe it or not, I am finding it a little tricky
19:10:12 <altmattr> but now I know it is the best option, I will push on
19:10:17 <altmattr> thanks :)
19:11:59 <dmwit> I think there's a nice Supply comonad in category-extras.
19:12:06 <zong_sharo> i need some algorithmical help
19:12:20 <dmwit> Don't we all?
19:12:22 <dmwit> =)
19:12:29 <zong_sharo> http://dev.gentoo.org/~gentoofan23/pms/head/html/pms.html#x1-57001r1 <- how this can be expressed in less imperative way?
19:12:58 <zong_sharo> (spec is far from perfect, but this is the only spec they have)
19:14:38 <zong_sharo> spec is almost right, but for use.mask declarations order is matter -> foo; -foo == () and -foo; foo == (foo)
19:14:42 <dmwit> last $ False : [flag | Just flag <- depthFirstDependencies] ++ [flag | Just flag <- linesOfSpec]
19:15:10 <dmwit> zong_sharo: I don't understand your correction to the spec.
19:15:35 <zong_sharo> order of declarations affects meaning
19:16:10 <zong_sharo> if use.mask conain lines -foo and them foo; then result will be foo
19:16:28 <dmwit> Their spec says that.
19:16:43 <dmwit> Oh, I see what you're saying.
19:16:46 <zong_sharo> spec says '''contains'''
19:18:43 <twb> Anybody seen Marco T√∫lio Gontijo e Silva?
19:18:45 <zong_sharo> dmwit: child profile may override parent declaration
19:19:03 <twb> I want a quick word with him about libghc6-zlib-doc 0.5 in Debian.
19:19:28 <zong_sharo> parent says +foo in the use.mask, and child says -foo in the package.use.mask
19:19:32 <zong_sharo> result is ()
