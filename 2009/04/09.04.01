00:00:01 <wli> pumpkin: I have no idea.
00:00:11 <wli> I can't come up with an analysis.
00:00:27 <pumpkin> well, you're basically picking subsets of your original set of letters in the word
00:00:33 <pumpkin> aren't you?
00:00:48 <pumpkin> it's improved marginally by the multiset-ness, but I don't think that helps the complexity
00:01:12 <Gracenotes> pumpkin: I'm just worried about the time it takes to build a DAWG. btw here's a nice visualization of one: http://x20.xanga.com/a2205250c9d33115213996/z33291346.jpg
00:01:14 <wli> Submultisets, but yes.
00:01:39 <pumpkin> Gracenotes: lol... have you been mocking me the whole time, or was that just a random pic? :P
00:02:35 <pumpkin> wli: so yeah, unless you stop heuristically, you're going to have to cover all sub(multi)sets of the original set of letters, which is exponential
00:02:39 <beekor> the pancake bunny picture always makes me smile.
00:02:57 <quicksilver> Gracenotes: yo dawg, I heard you like graphs, so I enriched your category over a dag, so you can compose while you compose?
00:03:03 <pumpkin> wli: analyzing the dawg approach is much harder to me, but on average it does very well
00:03:11 * pumpkin facepalms
00:03:20 <monochrom> hahaha
00:03:25 <Gracenotes> pumpkin: no rly, I've made a basic Python DAWG, but Oolong just seemed appropriately here
00:03:26 <harovali> i can't understand why filterM (const [False,True])   yields the powerset. Any hint?
00:03:27 <wli> pumpkin: I'm not sure how to get the multiset approach up to speed.
00:03:37 <Gracenotes> -ly
00:04:09 <Gracenotes> pumpkin: I don't have that great of an idea about the size blowup, although I considered loading the entire Firefox dictionary into a DAWG, I decided against it >_>
00:04:40 <pumpkin> wli: one approach might be to represent your multisets simply as ascending/descending strings, and putting them into a trie
00:04:59 <monochrom> Sorry, what is a DAWG?
00:05:09 <wli> pumpkin: That would be abandoning multisets.
00:05:11 <pumpkin> directed acyclic word graph :P a prefix/suffix trie all in one
00:05:15 <pumpkin> wli: I guess
00:05:35 <monochrom> eww, evil and powerful.
00:05:56 <Gracenotes> aha. An oldie-but-goodie, from December 2008:  <Gracenotes> Yo dawg, I heard you liked directed acyclic word graphs, so we put a DAWG in your problem so you can optimize subproblems while you optimize problems.
00:06:09 <pumpkin> Gracenotes: was that in response to my question? :P
00:06:11 <Axman6> so, could someone give me an example of a DAG datatype? (like data Dag a = ...)
00:06:21 <Axman6> or would that be rather complex?
00:06:22 <quicksilver> Axman6: more than one way to model a dag.
00:06:26 <monochrom> That makes the "yo dawg, I heard you like dag so much I added w so you can..." joke more funny now! :)
00:06:30 <Gracenotes> a bit vague, but DAGs are related to dynamic programming
00:06:36 <pumpkin> Axman6: it would typically be modeled as a list of vertices and edges so you don't need to tie too many knots
00:06:40 <mmorrow> wikipedia has a succint definition:
00:06:42 <mmorrow> A DAWG is defined as a trie where isomorphic subtrees are identified, thus producing a directed acyclic graph instead of a tree structure.
00:07:24 <pumpkin> yo DAWG, I heard you liked sharing, so I put a trie in your trie so you can share prefixes while you share suffixes
00:07:24 <quicksilver> mmorrow: sounds like a good case for vacuum-cairo to me.
00:07:26 <pumpkin> or something
00:07:35 <pumpkin> it does actually
00:07:44 <mmorrow> quicksilver: you read my mind
00:07:44 <monochrom> hahahahaha it's great
00:07:58 <mmorrow> pumpkin: heh
00:08:02 <Gracenotes> the only problem is building it up functionally
00:08:06 <edwardk> pumpkin you usually do have a trie in your trie. trie again ;)
00:08:07 <pumpkin> now someone just needs to implement a DAWG, so vacuum can suck it all up
00:08:14 <wli> I'm thinking something involving multiset union/intersection lattices.
00:08:18 <pumpkin> edwardk: how about a backwards trie :P
00:08:33 <Gracenotes> how about donating to save the tries in Amazon
00:08:37 <edwardk> pumpkin: actually tries are going into the monoid lib very soon
00:08:41 <pumpkin> omg
00:08:45 <pumpkin> how about DAWGs
00:08:56 <pumpkin> can you stick a monoid in my monoid so I can operate while I operate?
00:08:58 <edwardk> tricky to get sharing right
00:09:03 <quicksilver> import Monoid.Yo.DAWG ?
00:09:06 <pumpkin> lol
00:09:07 <Gracenotes> *mappend while I mappend
00:09:13 <pumpkin> I don't like mappend
00:09:16 <monochrom> hahahahaha you're all drunk
00:09:17 <pumpkin> as a name
00:09:36 <quicksilver> monochrom: meme-drunk
00:09:38 <edwardk> actually i've already stuck a module in your module, since every ring is a module over itself and eveyr monoid is a module over the naturals, which is a monoid itself.
00:09:47 <pumpkin> instance (Monoid a) => Monoid (YoDawg a) where
00:09:59 <Gracenotes> > Data.Foldable.foldMap (Sum &&& Product) [1..20]
00:10:00 <lambdabot>   (Sum {getSum = 210},Product {getProduct = 2432902008176640000})
00:10:05 <edwardk> pumpkin: i hate mappend,thats why i have two aliases for it ;)
00:10:07 <pumpkin> edwardk: how about a zygohistomorphic prepromorphism in my zygohistomorphic prepromorphism?
00:10:11 <wli> I think modules need at least a group.
00:10:22 <wli> Maybe it's something else.
00:10:40 <edwardk> wli: vector space
00:10:57 <wli> edwardk: That's less general than a module.
00:11:00 <edwardk> wli: you can have modules over semirings or weaker
00:11:11 <quicksilver> (btw, yay for C++ : sstart = std::find_if(sstart, send,std::bind2nd(std::not_equal_to<char>(), ' ')); )
00:11:12 <edwardk> wli: if you appropriately weaken the definition of a module
00:11:15 <Gracenotes> http://upload.wikimedia.org/wikipedia/commons/a/a0/Oolong_last_head_performance.jpg
00:11:39 <Gracenotes> quicksilver: yay, functional programming x.x
00:11:42 <pumpkin> edwardk: what other fun prefixes can I stick onto a zygohistomorphic prepromorphism? how about a zygohostomorphic preprocatamorphism? would that make sense?
00:11:44 <edwardk> wli: i'm working with modules over right-semi-near-rings at the moment
00:11:51 <wli> edwardk: Appropriately weakening the definition of a module produces the definition of something else not called "modules."
00:12:02 <edwardk> pumpkin: go look at Control.Morphism and start stringing together anything in there with a 'Dist' combinator
00:12:07 <pumpkin> lol
00:12:18 <edwardk> wli: no, they are called modules, just not by every mathematician ;)
00:12:24 <pumpkin> edwardk: I dare you to make morphism name combinator functions that output funny strings ;)
00:12:36 <pumpkin> and put them in category-extras
00:12:38 <pumpkin> for the lulz
00:12:45 <pumpkin> maybe even an enumerator for all combinations
00:12:51 <monochrom> Good day to do a prank like that.
00:13:02 <wli> edwardk: There is a real name for the semiring case. Weaker cases don't have convenient/standard names.
00:13:44 <Gracenotes> hah, xkcd today. That Randall.
00:14:03 <wli> semiring / monoid or semiring / semigroup case, that is.
00:14:05 <Gracenotes> how I like his statistical jokes :3
00:15:01 <trofi^w> @pl \() -> ()
00:15:01 <lambdabot> (line 1, column 4):
00:15:01 <lambdabot> unexpected " "
00:15:01 <lambdabot> expecting operator, pattern or "->"
00:15:12 <pumpkin> :o
00:15:23 <pumpkin> I guess it isn't used to that
00:15:46 <edwardk> when you talk about modules you are usually explicit enough about whether you're a left/right/bi- module and if you're over a ring/rng/rig. unfortunately. since there is no other name for them, and i prefer not to call them 'warm fuzzy things' i stick to the 'module over a ring-like-thing' convention ;)
00:15:51 <trofi^w> > (\() -> ()) ()
00:15:53 <lambdabot>   ()
00:16:38 <monochrom> hetero/homo/bi/cata/ana/hylo- sexual ?
00:17:03 <wli> para/zygo/apo/etc. too
00:17:11 <Gracenotes> one of many arrows in the people category
00:17:16 <edwardk> monochrom: sounds painful. are you sure that after all of that you're still functional?
00:17:28 <pumpkin> Heffalump: you around?
00:17:56 <Gracenotes> > () `mappend` () `mappend` () `mappend` () `mappend` () `mappend` () `mappend`()
00:17:58 <lambdabot>   ()
00:18:11 <Gracenotes> > [()..]
00:18:13 <lambdabot>   [()]
00:18:19 * edwardk realized today that the left-distributive law for monadplus is actually a right _distributive_ law. since its the distribution of >=> over mplus, not the other way around.
00:18:21 <Gracenotes> > [()..()]
00:18:22 <lambdabot>   [()]
00:18:39 <edwardk> > [(),()..()]
00:18:40 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
00:18:45 <wli> I think containment arcs are most of what need to be set up.
00:20:14 <mmorrow> , foldr mappend () (repeat ())
00:20:15 <lunabot>  luna: Not in scope: `mappend'
00:20:23 <mmorrow> > foldr mappend () (repeat ())
00:20:25 <lambdabot>   ()
00:20:37 <wli> OTOH that pretty much involves comparisons vs. huge swaths of the dictionaries.
00:20:45 <Gracenotes> > (( . ) . ( . )) (\() -> ()) (\() () -> ()) () ()
00:20:47 <lambdabot>   ()
00:20:47 <pumpkin> http://hackage.haskell.org/packages/archive/rmonad/0.4.1/doc/html/Control-RMonad.html I wish this would become standard :)
00:21:08 <Gracenotes> what, how could that be! O:
00:23:44 <edwardk> getting some sleep
00:24:12 <newsham> > let p x = foldr (const (>>x)) [()] in length $ p [(),(),()] [(),(),(),()]
00:24:13 <lambdabot>   81
00:25:19 <Gracenotes> who needs Int32s when we have [()]s :\
00:25:35 <pumpkin> lol
00:26:20 <pumpkin> lazy ints have their advantages :)
00:26:58 <newsham> > let p x = foldr (\_->(>>x)) [()]; n x = replicate x (); u = length in u (p (n 3) (n 4))
00:27:00 <lambdabot>   81
00:27:43 <wli> pumpkin: There are better ways to organize the dictionary that don't involve sacrificing the multiset representation.
00:27:51 <pumpkin> really?
00:28:11 <pumpkin> I've always been a trie fan
00:28:16 <pumpkin> so DAWGs are bonerific for me
00:28:21 <newsham> trie hugger
00:29:01 <rio> > let p x = foldr (\_->(>>x)) [()]; n = (flip replicate) (); in length (p (n 3) (n 4))
00:29:02 <lambdabot>   81
00:29:18 <Gracenotes> I used a trie to prove that any set of codes satisfying the no-prefix constraint was uniquely decodable
00:29:28 <Gracenotes> yeah, cool story, I know
00:29:47 <newsham> > (length "n = flip replicate ()", length "n x = replicate x ()")
00:29:48 <lambdabot>   (21,20)
00:30:15 <pumpkin> > length "`replicate` ()"
00:30:16 <lambdabot>   14
00:30:20 <pumpkin> > length "n = `replicate` ()"
00:30:22 <lambdabot>   18
00:30:36 <rio> :(
00:30:44 <pumpkin> aw
00:30:59 <newsham> > let p x = foldr (\_->(>>x)) [()]; n = `replicate` (); u = length in u (p (n 3) (n 4))
00:31:00 <lambdabot>   <no location info>: parse error on input ``'
00:31:04 <wli> pumpkin: It's not too different from a trie, except the number of consecutive letters in a run is paired up with a sub-level's entry.
00:31:14 <newsham> > let p x = foldr (\_->(>>x)) [()]; n = (`replicate` ()); u = length in u (p (n 3) (n 4))
00:31:15 <lambdabot>   81
00:31:46 <pumpkin> wli: I'll be interested to see if you can improve on that dude's approach... it's pretty ugly the way he did it, although the basic DAWG idea is simple
00:32:09 <newsham> just as long, slightly more complicated
00:32:35 <wli> pumpkin: There aren't any substring sharing considerations here.
00:32:53 <rio> whats the 'u' for anyway?
00:33:12 <newsham> p = power, n = natural, u = unnatural
00:33:25 <rio> ah
00:33:42 <pumpkin> instance Num [()] where
00:34:48 <rio> hehe rembering instancing Num for data Peano = O | S Peano
00:35:50 <newsham> [] () <=> N = Z | S N
00:36:05 <pumpkin> yup
00:36:59 <Gracenotes> coughisomorphismcough
00:37:08 <pumpkin> Axman6: any developments on shootout front?
00:37:30 <Gracenotes> well, barring some laziness problems
00:37:39 <Gracenotes> strictness that is
00:37:59 <Gracenotes> there's no Natural = Z | S Natural analogue for [(), undefined]
00:38:11 <Gracenotes> such that it's isomorphic
00:38:19 <pumpkin> why not?
00:38:39 <pumpkin> ah, I see
00:38:58 <wli> pumpkin: type DictIdx = Int ; data Trie = Trie (Map Char (IntMap (DictIdx, Maybe Trie)))
00:39:13 <wli> pumpkin: The index of the IntMap is the multiplicity of the letter.
00:39:20 <pumpkin> hmm ok
00:39:45 <Gracenotes> sadly the constructors are not exported in http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/src/Data-Number-Natural.html
00:40:08 <wli> type DictTable = IntMap (MultiSet Char, Set String)
00:42:48 <wli> pumpkin: The trie here only treats the least letter by the Ord instance on Char, so the potential branching factor of the "trie" narrows the deeper one goes.
00:44:59 <aleator> Hi, Is there any way of passing something to TH from compiler command line?
00:45:32 <mmorrow> aleator: do you mean from ghci?
00:45:48 <mmorrow> (what do you want to pass?)
00:46:07 <wli> In such a manner one can choose the next letter of a MultiSet Char to break off essentially via intersection.
00:46:29 <pumpkin> hmm
00:46:31 <ksf> so then where's instance Num [] where ...?
00:47:12 <wli> @type Map.intersectionWith
00:47:13 <lambdabot> Couldn't find qualified module.
00:47:25 <Workybob> someone needs to do a png version of the Haskell logo to go on reddit with a transparent background
00:47:29 <wli> @type Data.Map.intersectionWithKey
00:47:30 <lambdabot> forall k a b c. (Ord k) => (k -> a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
00:47:33 <Workybob> because they just changed the theme and made it look crazy
00:47:57 <wli> omfg what retard removed the qualified import of Data.Map as Map?
00:48:04 <pumpkin> lol
00:48:17 <Workybob> haha
00:48:25 <pumpkin> > Map.singleton 1 2
00:48:26 <lambdabot>   fromList [(1,2)]
00:48:41 <wli> Ugh, so it's only @type that doesn't respect it.
00:48:57 <pumpkin> yeah, they're kinda independent I think
00:51:44 <wli> Anyway, Map.filter (not . IntMap.null) $ Map.intersectionWithKey (\k im ms -> fst $ IntMap.split (fromJust . Map.lookup k . MultiSet.toMap $ ms) im) or some such does the trick.
00:53:12 <wli> It may be better to just use updateWithKey or some such.
00:55:22 <wli> let mm = MultiSet.toMap ms in Map.updateWithKey (\k im -> liftM (fst . IntMap.split) . Map.lookup k mm) ...
00:59:00 <wli> f (Trie mc) = let mm = MultiSet.toMap ms in Map.updateWithKey (\k im -> liftM (fst . flip IntMap.split im) $ Map.lookup k mm) mc
01:02:47 <Axman6> hmm, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3167#a3167 :(
01:02:55 <Axman6> anyone kow how to fix that?
01:03:11 <Axman6> getting pretty sick of ghc needing process-1.0.1.0
01:03:30 <wli> There are two ordering tricks to kill off some factorial / combinatorial explosions, basically Set (MultiSet (MultiSet Char)) represents each word (non-whitespace character sequence) equivalence class under permutation as MultiSet Char and then each word sequence equivalence class under permutation as MultiSet (MultiSet Char) and then a Set of those just for automatic elimination of duplicates.
01:08:33 <wli> There's not a whole lot of difference between this and sorting followed by run-length encoding.
01:09:04 <Axman6> ok, this is just awesome:
01:09:05 <Axman6> Resolving dependencies...
01:09:05 <Axman6> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.0 however
01:09:05 <Axman6> process-1.0.1.0 was excluded because ghc-6.10.1 requires process ==1.0.1.1
01:09:35 <Axman6> wtf cabal
01:10:12 <pumpkin> http://groups.google.com/group/fa.haskell/browse_thread/thread/3e556db4901e1db8
01:11:24 <wli> pumpkin: I'm not sure how to do a trie traversal in such a fashion as to guarantee that the MultiSet Char peeled off in the search is less than or equal to the previous one in the ordering given by the Ord instance on MultiSet Char.
01:12:02 <pumpkin> it sounds hard
01:12:22 <pumpkin> you'd need to keep track of more information I think
01:13:32 <wli> pumpkin: It avoids duplicating searches. Anyway, it's not too hard as long as I have some idea of how the comparisons are done.
01:13:56 <wli> pumpkin: I do it now in a relatively dumb way.
01:14:26 <Workybob> Anyone here know how to create a window into which OpenGL can draw with gtk2hs?
01:14:30 <Axman6> pumpkin: well, ghc-pkg unregister doesn't work, and far too many things rely on process-1.0.1.1, so i'm a little stuffed
01:14:43 <pumpkin> it seems to be really common these days
01:14:57 <pumpkin> not sure what's causing the epidemic :P
01:15:06 <pumpkin> maybe dcoutts knows
01:16:55 <newsham> workybob: http://gtkglext.sourceforge.net/
01:17:12 <newsham> dunno if there are any bindings for haskell, but I've used it from other langs before
01:17:14 <pumpkin> wli: hmm, I'll be impressed if you can get fast anagram searches using that... going to bed now but let me know if you succeed
01:17:50 <Workybob> newsham: yeh, it has the same extents of documentation as gtk2hs – i.e. just enough to discover you need a DrawWindow, but you can't find any functions that produce the damn things
01:17:56 <Axman6> cabal: cannot configure haddock-2.4.2. It requires ghc >=6.8.2 && <6.13
01:17:56 <Axman6> There is no available version of ghc that satisfies >=6.8.2 && <6.13
01:18:01 <Axman6> god damnit cabal
01:18:13 <Workybob> >.<
01:18:16 <blackh> Hello all!
01:18:34 <blackh> I am finally going to reveal the secret of my secret project!
01:18:38 <pumpkin> !!!
01:18:43 <Axman6> oh well, i have work i need to be doing. but still... *refrains from swearing*
01:18:45 <blackh> It's going to be a stage musical called "Haskell Musical"...
01:18:48 <pumpkin> I've been looking forward to this for weeks
01:18:49 <pumpkin> :o
01:18:54 <newsham> workybob: there's lots of generic gtk documentation.
01:19:02 <blackh> a love story between programmer and language set in a well-to-do University!
01:19:05 <newsham> it usually translates pretty well to platform bindings
01:19:12 <blackh> Anyway.
01:19:30 <wli> Either (Either DictIdx Trie) (DictIdx, Trie)
01:19:30 <Workybob> newsham: maybe, but I can't find any that tells you how to get a DrawWindow, or an alternative way to produce a window with a gl context attached
01:19:39 <mib_2rc2jmt8> who can recommend a IDE for Haskell to me?
01:19:46 <pumpkin> blackh: will you pull from real haskell community characters?
01:19:58 <pumpkin> harrop/xah lee will be the villains?
01:20:03 <Workybob> mib_2rc2jmt8: Leksah if you must use an IDE
01:20:10 <Workybob> but it's... hard to build
01:20:14 <Workybob> as Axman6 is discovering
01:20:22 * Axman6 swears
01:20:26 * Tsion really likes learnyouhaskell.com
01:20:32 <Tsion> "Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial." ^^
01:20:43 * Workybob giggles at reddig
01:20:45 <wli> pumpkin: type DictIdx = Int ; data Trie = Trie (Map Char (IntMap (Either (Either DictIdx Trie) (DictIdx, Trie))))
01:21:08 <lpjhjdh> getting a bunch of errors about ambiguous >< and coarbitrary being invisible when building hmatrix 0.5.0.1
01:21:10 <lpjhjdh> using ghc 6.10
01:21:12 <blackh> pumpkin: I think I ran out of joke!
01:21:15 <pumpkin> :(
01:21:51 <wli> data AtLeastOneOf t t' = JustLeft t | JustRight t | Both t t'
01:21:55 <newsham> workybob: arent all widgets drawareas or have one?
01:22:14 <Workybob> newsham: it's not a DrawArea I need
01:22:14 <mmorrow> lua lines-of-code by version: http://moonpatio.com/lua/lua_loc.png
01:22:18 <Workybob> it's a DrawWindow
01:22:29 <Workybob> also – I have no widgets yet anyway
01:22:32 <mmorrow> (.c + .h)
01:22:34 <Workybob> because I have no window to put them in
01:22:52 <wli> ARGH data AtLeastOneOf t t' = JustLeft t | JustRight t' | Both t t'
01:23:15 <Workybob> wli: hmm?
01:23:29 <Workybob> some a and b could help you there ;)
01:23:39 <pumpkin> mmorrow: ? lua itself?
01:23:46 <mmorrow> pumpkin: yeah
01:24:04 <mmorrow> pumpkin: from http://www.lua.org/ftp/lua-all.tar.gz
01:24:04 <newsham> workybob: every GtkWidget has a "window" property which is a GdkWindow which is a subclass of GdkDrawable
01:24:06 <wli> Workybob: To avoid needing type AtLeastOneOf t t' = Either (Either t t') (t, t')
01:24:07 <mmorrow> i did:
01:24:07 <newsham> is that what you need?
01:24:10 <pumpkin> ah
01:24:20 <Workybob> newsham: but I have no window to put widgets in yet
01:24:23 <Workybob> so ...
01:24:37 <Workybob> no windows = no widgets to find out what window they're in
01:24:37 <newsham> worybob: its pretty typical to create a GtkDrawingArea and then use it's window attribute to call gdk drawing functions directly
01:24:39 <mmorrow> for i in `ls | grep lua`; do echo -ne "$i " | sed -r 's|lua-||g' ; wc -l `find $i | grep -E "\.[ch]$"` | tac | head -1 | sed -r 's|^\s+||g' | cut -d' ' -f1; done;
01:24:59 <newsham> as seen in Example 49 here: http://library.gnome.org/devel/gtk/stable/GtkDrawingArea.html
01:25:02 <Workybob> newsham: oh?  So does that create a window as its created?
01:25:02 <mmorrow> (incrementally built, so maybe not the most direct method..)
01:25:04 <wli> Workybob: Esp. when t, t' are larger type expressions.
01:25:15 <lpjhjdh> so is there some version of quickcheck hmatrix is supposed to build against?
01:25:30 <newsham> workybob: most widgets you create will have a window.
01:25:40 <mmorrow> pumpkin: (and used R for the plot)
01:25:42 <Workybob> newsham: yeh... but *what* window?
01:25:49 <pumpkin> wow, that's quite a sequence of pipes
01:25:51 <Workybob> a new one?
01:25:55 <Workybob> one that already exists?
01:26:21 <newsham> ok, so normally you create a main window and pack other widgets in that.  those other widgets will have graphics elements called "windows" which are packed inside of the desktop window
01:26:31 <mmorrow> pumpkin: heh, did you know you can use alternative seps with sed? i only found this out a few weeks ago
01:26:34 <mmorrow> changed my life
01:26:36 <Workybob> okay... I haven't created a main window yet newsham
01:26:39 <Workybob> that's what I'm trying to do
01:26:44 <newsham> so when you do gdk drawing operations on that "window" its relative to just that widget's local coordinate space.
01:26:45 <Workybob> but glNewWindow requires a DrawWindow
01:26:51 <wli> sed -e 's,foo,bar,g' ?
01:26:52 <newsham> workybob: ok, there's lots of examples for that :)
01:27:03 <Workybob> newsham: got a link?  Google doesn't find any
01:27:08 <mmorrow> wli: i'm not sure if that'd work, but | does for sure
01:27:10 <wli> vs. sed -e 's/foo/bar/g' ?
01:27:23 <pumpkin> mmorrow: nope!
01:27:33 <mmorrow> wli: zomg that works
01:27:34 <newsham> http://www.haskell.org/gtk2hs/documentation/#examples <- see "Hello World in Haskell with Gtk2Hs"
01:27:42 <mmorrow> pumpkin: crazy! right
01:27:46 <wli> mmorrow: Doesn't matter too much what you use.
01:27:56 <mmorrow> wli: i like it
01:27:56 <Workybob> newsham: again – not creating a window OpenGL can draw into
01:28:09 <Workybob> or is the result of newWindow castable into a DrawWindow?
01:28:16 <mmorrow> wli: yeah, vs '/'
01:28:16 <newsham> again, to do that you prob need GtkGlExt
01:28:33 <mmorrow> sed 's|/||g'
01:28:45 <Workybob> newsham: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/Graphics-UI-Gtk-OpenGL-Window.html#v%3AglWindowNew
01:28:49 <Workybob> it can be done...
01:28:56 <Workybob> I just don't know how to get the second argument
01:30:14 <newsham> not familiar with those apis
01:30:21 <dcoutts> Axman6: cabal thinks there is no ghc because your ghc package is currently marked as broken
01:30:40 <Axman6> seems a lot of stuff's broken
01:30:54 <dcoutts> Axman6: and that's because you've probably got a package, perhaps Cabal-1.6.0.1 that you rebuilt against process-1.0.1.1 which you've now unregistered
01:30:57 * Workybob ponders trying to cast the result of newWindow with castToDrawWindow and see what happens
01:31:03 <newsham> http://cvs.haskell.org/darcs/gtk2hs/demo/opengl/RotatingCube.hs ?
01:31:12 <Workybob> oh, cheers newsham
01:31:13 <Axman6> dcoutts: any tips on getting this fixed? (the ghc needing both process-1.0.1.(0|1) would be a good start)
01:31:16 <Workybob> that's what I was missing :)
01:31:19 <dcoutts> Axman6: ghc-pkg list shows all broken packages in {}'s
01:31:46 <Axman6> {}'s or ()'s
01:31:48 <pumpkin> alright, bedtime
01:31:48 <dcoutts> Axman6: take a look at your package list, is there are package (eg Cabal-1.6.0.1) that is registered in the per-user section and also in the global section?
01:31:59 <dcoutts> Axman6: ()'s is hidden, {}'s is broken
01:32:13 <Workybob> newsham: wow, Gtk is wierd... creating the widget before it has a window to go in
01:32:22 <Axman6> well nothing is in {}'s
01:32:39 <quicksilver> leksah-- # blaming the community is not a good way to try to attract support.
01:32:51 <dcoutts> Axman6: ghc-pkg check gives more detailed output
01:33:09 <Axman6> or no output at all in my case :\
01:33:10 <newsham> workybob: the real work happens later when the things try to get drawn and refresh areas of the screen
01:33:15 <pumpkin> quicksilver: ?
01:33:37 <Workybob> newsham: oh, neat, so it's actually a case of defining a scene graph, rather than running commands for creating things
01:33:42 <Workybob> that's nicer than I'd hoped :)
01:33:56 <dcoutts> Axman6: so what about any overlapping packages between the global and user package dbs?
01:33:59 <newsham> yah, and more stuff happens when things like the window get resized
01:34:32 <Axman6> dcoutts: there's.. maybe 100 user packages installed... is there any wasy way to tell?
01:34:54 <dcoutts> Axman6: look particularly at the core packages, like Cabal, process, haskell98 etc
01:34:57 <Axman6> oh hang on, i have Cabal-1.6.0.1 not in my home dir
01:35:23 <dcoutts> Axman6: you should have Cabal-1.6.0.1 globally, it comes with ghc, any other instance?
01:35:40 <Axman6> just Cabal-1.6.0.2 in ~/.cabal
01:35:53 <quicksilver> pumpkin: this bit:
01:35:54 <quicksilver> Most stupid I found the recurring comment: "Every few years there is someone who starts a Haskell IDE project and then gives up after a few years.". That will be true for Leksah as well, if it will not be accepted and supported by the community
01:36:12 <quicksilver> pumpkin: I kind of know where he's coming from, but blaming the community is not the path to engender support
01:36:21 <dcoutts> Axman6: sounds like you've unbroken things, are you still getting weird symptoms?
01:36:21 <quicksilver> you engender support by demonstrating how kick-ass your program is.
01:36:28 <mmorrow> lua is so slick
01:36:31 <pumpkin> is that on reddit?
01:36:37 <Axman6> dcoutts: yep
01:37:02 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3168#a3168
01:37:20 <wli> Start with the things that are fragile, like IDE's, inter-module-processing communication protocols, etc. first?
01:38:34 <quicksilver> pumpkin: it's a mailing list post to -cafe
01:38:37 <dcoutts> Axman6: do you have haskell98 registered in both user and global package dbs?
01:39:04 <Axman6> yes
01:39:11 <dcoutts> Axman6: get rid of the per-user one
01:39:31 <Axman6> how? just ghc-pkg unregister haskell98?
01:39:36 <Axman6> -x.x.x.
01:39:37 <dcoutts> Axman6: with --user
01:39:41 <pumpkin> quicksilver: ah, I see
01:39:51 <dcoutts> Axman6: and get rid of process-1.0.1.1
01:40:34 <Axman6> lots of things depend on it :\
01:40:34 <dcoutts> Axman6: and when you're done, cabal install cabal-install-0.6.2
01:40:47 <dcoutts> Axman6: they'll need to be reinstalled then
01:41:06 <dcoutts> Axman6: cabal will consider them as not being installed so will be happy to re-install them
01:41:44 <dcoutts> Axman6: but do use install not upgrade
01:41:45 <Axman6> so, ghc-pkg unregister --force process-1.0.1.1 then?
01:41:57 <dcoutts> Axman6: presumably --user too?
01:42:05 <Axman6> ok
01:45:56 <Axman6> let's see how this goes...
01:46:18 * Axman6 gets back to his electro lab in the mean time
01:52:51 <bastl> i have long expressions like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2020#a2020 . Is there a nicer way to mix these accessor functions and list indexing? the !! operator makes the expression unreadable.
01:53:01 <bastl> and yes the function names are ugly... :-/
01:54:26 <ejt> @pl test td = isValidWhile $ iterStmOfStm $ stmOfLVarStatement  ( (lVarStatementsOfMethodField $ ((fieldDeclarationsOfTypeDecl td) !! 2)) !! 1)
01:54:26 <lambdabot> test = isValidWhile . iterStmOfStm . stmOfLVarStatement . (!! 1) . lVarStatementsOfMethodField . (!! 2) . fieldDeclarationsOfTypeDecl
01:54:52 <quicksilver> bastl: use temporary variables to give a sensible name
01:55:12 <wli> pumpkin: I think it's too grand for me to crank out in a reasonable amount of time.
01:55:21 <bastl> quicksilver: you mean using 'where'?
01:55:27 <quicksilver> bastl: I prefer 'let'
01:55:31 <quicksilver> bastl: but, yes.
01:55:33 <bastl> k
01:55:43 <quicksilver> also, !! is often a bad sign
01:55:51 <quicksilver> but I don't know exactly what you're doing there :)
01:57:38 <ejt> the fact that the arguments to (!!) are constants suggests you could use records rather than lists ?
01:57:48 <bastl> quicksilver: right, it's hard-wired. I have to learn how to navigate (and search) expression trees in a nice fashion.
01:58:47 <ejt> bastl: what are you using to generate the expression trees ?
01:58:47 <bastl> ejt: the arguments to !! should not be constant. i need a good query language.
01:58:57 <QtPlaty[HireMe]> lambda bot has a function that allows you to find functions based on a type signature.  Is there anything like that for home use?  Also what is its name?
01:59:08 <ejt> bastl: you might want to look at Conals recent post on composing accessors
01:59:12 <ejt> I'll find the url
01:59:39 <newsham> http://www.haskell.org/hoogle/ ?
01:59:42 <bastl> ejt: the expressions are abstract syntax trees stemming from a bnfc-parser
02:00:13 <QtPlaty[HireMe]> Thankyou
02:00:20 <ejt> bastl: http://conal.net/blog/posts/semantic-editor-combinators/
02:00:21 <bastl> ejt: i thought about taking a similar approach like HaXML (Generic combinators)
02:00:37 <ejt> not sure how applicable it is
02:01:28 <Axman6> QtPlaty[HireMe]: there's hayoo, which is linked into hackage
02:01:43 <ejt> also there's Data.Generics, which I've used for updating and querying c ASTs - but I find it a bit cumbersome TBH
02:03:01 <ejt> quicksilver: did you ever package that FRP thing you were working on ?
02:03:04 <bastl> ejt: i also use data.generics with data2tree :: AST -> (Data.Tree String), but you loose typing information then.
02:03:35 <ejt> bastl: so write queries that retain more of the type info ;)
02:04:27 <bastl> ejt: its generic by nature. the approach is not good imho
02:05:07 <wli> bastl: Hash consing rules my world.
02:05:48 <dqd> Boohaha! http://lambda-the-ultimate.org/node/3257
02:05:54 <quicksilver> ejt: well I posted it ot the reactive list
02:05:59 <quicksilver> ejt: depending which thing you meant
02:11:05 <latitude> what package in hackage contains data files?
02:11:29 <latitude> looking for examples
02:13:05 <Gracenotes> hm?
02:13:20 <Axman6> dcoutts: thanks for you help, i really appreciate it
02:13:25 <Gracenotes> well... lambdabot for example contains datafiles for vixen, packed/unpacked with Data.Binary
02:13:47 <dcoutts> Axman6: working ok now? have you upgraded to cabal-install-0.6.2 now?
02:13:55 <latitude> i'm trying to pack data-files with cabal, but something goes wrong
02:13:56 <Gracenotes> other datafiles too. for example for some quotes.
02:13:59 <latitude> lambdabot, good
02:14:23 <Gracenotes> well, it's nothing to do with cabal, just packed/unpacked by the program itself
02:14:30 <Axman6> dcoutts: not yet
02:14:46 <dcoutts> Axman6: it'll make it a bit harder to get into that state again
02:14:57 <Axman6> excellent :)
02:21:08 <latitude> the cabal howto sais when i want to use Paths_<pkgname> module i need it to be specified in other-modules section
02:21:50 <latitude> but there is no Paths_lambdabot in lambdabot.cabal
02:22:08 <Axman6> wow, what a load of crap leksah is. finally got it up and running, and it son't stop asking me to open a file
02:23:52 <RayNbow> @faq is Haskell April Fools proof?
02:23:52 <lambdabot> The answer is: Yes! Haskell can do that.
02:24:27 <dcoutts> latitude: that module is generates automagically
02:26:10 <RayNbow> ...reddit's new layout is hideous :X
02:26:48 <latitude> the new morning is as always a wiser one :) got it running finally
02:27:44 <Axman6> RayNbow: ha
02:29:27 <latitude> here is a question to chew on
02:29:49 <latitude> say i have action a of type String -> IO FilePath
02:30:01 <latitude> so it evaluates to value of type FilePath
02:30:20 <bastl> can i avoid this kind of name clashing: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2021#a2021 ?
02:30:40 <latitude> why could not i specify it as a parameter to function of type say String -> String ?
02:30:45 <Saizan> bastl: only putting them in different modules
02:31:03 <quicksilver> bastl: call them aId and cId
02:31:04 <bastl> Saizan: thats bad . :-/
02:31:24 <quicksilver> it's just a question of perspective.
02:31:30 <quicksilver> haskell's "records" are not C structs.
02:31:32 <thomastc> latitude: what do you mean, exactly?
02:31:36 <quicksilver> you're just defining functions.
02:31:39 <thomastc> foo :: String -> IO FilePath
02:31:44 <thomastc> bar :: String -> String
02:31:47 <quicksilver> aId :: Address -> Int
02:31:54 <quicksilver> cId :: Customer -> Int
02:32:02 <quicksilver> you wouldn't expect to be able to use the same name for two functions.
02:32:12 <quicksilver> (unless you felt like overloading with a class, which option is open to you if you like it)
02:32:17 <thomastc> latitude: you cannot specify foo as an argument to bar, because foo is a function, not a String
02:32:39 <bastl> quicksilver: right, just thought about "deriving ID" or something, but these are constructors ?
02:32:49 <Axman6> latitude: you can however use foo . bar
02:33:02 <thomastc> latitude: and you cannot specify the *returned value* of foo as an argument to bar, because that is an IO FilePath, not a String
02:33:25 <latitude> thomastc: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2022#a2022
02:33:40 <drdozer> so, I need a practical way to call a C++ library that is heavily class-centric from haskell
02:33:53 <latitude> so how could i avoid introducing proversDatFile ?
02:34:00 <quicksilver> drdozer: write a clever binding by hand.
02:34:07 <quicksilver> drdozer: no shortcut, I'm afraid.
02:34:12 <drdozer> quicksilver: I have neither the time nor the skills to do that
02:34:26 <quicksilver> drdozer: I consider wxHaskell a fairly good example of a haskell binding to a C++ library.
02:34:39 <quicksilver> drdozer: then choose a different project, which falls within your time and skills budgets?
02:35:01 <quicksilver> although I think perhaps you are overestimating the difficulty.
02:35:04 <latitude> Axman6: whats that?
02:35:25 <drdozer> quicksilver: there's 15k lines of header file to deal with
02:35:28 <Axman6> you don't know about .?
02:35:54 <latitude> i am new to haskell
02:35:58 <Axman6> ah, ok
02:36:00 <latitude> as new as one day :)
02:36:03 <Axman6> @src (.)
02:36:03 <lambdabot> (f . g) x = f (g x)
02:36:10 <quicksilver> latitude: prdb <- readPrDB . (\x -> askIS ISprdb x xini) =<< getDataFileName "provers.dat"
02:36:34 <quicksilver> I think. I may have the parenths wrong.
02:36:48 <quicksilver> drdozer: I feel your pain but I don't have a quick answer for you.
02:37:09 <quicksilver> drdozer: some peopel have written some tools to parse header files and autogenerate some fo the work
02:37:17 <Axman6> drdozer: creating bindings between languages is almost never going to be easy
02:37:19 <quicksilver> as far a I know, none of these is close to a 'complete' solution.
02:38:09 <drdozer> quicksilver: all of this code is based on classes, many with virtual methods, and I simply have no idea how to get that into haskell, let alone in a way that means I will have time to eat and sleep before mid-summer
02:38:34 <quicksilver> drdozer: wrap them in C functions. hide an object pointer in an opaque haskell type.
02:38:58 <quicksilver> don't forget to sweat uneasily about memory management choices.
02:39:11 <quicksilver> but really, it's not *that* hard.
02:39:15 <quicksilver> it's donkey-work, is all.
02:40:19 <rio> hi, i want to generate some waveforms with haskell and hear them, any library recommendations? (im on linux using pulseaudio as soundserver)
02:41:10 <CalJohn> Hello, I'm trying to follow the haskell tutorial on haskell.org.  I have gotten as far as input/output and we are looking at the program "main = do c <- getChar \n putChar c" but that doesn't compile, saying something about "last statement in a 'do' construct must be an expression".  What am I doing wrong?
02:41:47 <quicksilver> CalJohn: indentation I'm afraid
02:41:57 <quicksilver> CalJohn: the putChar need to line up with the 'c'
02:42:19 <quicksilver> CalJohn: probably that means 10 spaces before it
02:42:25 <quicksilver> > length "main = do "
02:42:27 <lambdabot>   10
02:42:39 <quicksilver> CalJohn: some people find it easier to always start a new line after a 'do'
02:42:43 <Axman6> CalJohn: yeah, indentation is very important in haskell (saves a lot of typing though)
02:42:46 <quicksilver> makes the indentation more obvios
02:42:58 <quicksilver> I find it easier to use a smart editor which gets it right :)
02:43:12 <Axman6> me too
02:43:14 <thomastc> latitude: replace 'getDataFileName "provers.dat"' in the second line by proversDatFile
02:43:19 <CalJohn> i am using emacs, quicksilver, but the indentation doesn't get it right the first time I hit C-j
02:43:45 <CalJohn> quicksilver: it does if I start a new line though
02:43:46 <quicksilver> yeah, you can greatly improve emacs by downloading an alern`tive indentation package :
02:43:52 <thomastc> latitude: what your first line does is run the action, and assign (bind) the resulting FilePath to the variable proversDatFile
02:43:55 <quicksilver> @where kuribas-indentation
02:43:55 <lambdabot> http://kuribas.hcoop.net/haskell-indentation.el
02:44:06 <Axman6> i prefer to write things like that as "main = do\n    c <- getChar\n    putChar c"
02:44:15 <Axman6> > text "main = do\n    c <- getChar\n    putChar c"
02:44:15 <quicksilver> CalJohn: if you hit TAB a few times it should cycle through possibilities including one which is correct.
02:44:16 <lambdabot>   main = do
02:44:16 <lambdabot>      c <- getChar
02:44:16 <lambdabot>      putChar c
02:44:30 <thomastc> latitude: whereas in the second line, you're filling in the *action* again as a parameter to askIS, but you should fill in the action's *result*
02:44:35 <thomastc> latitude: does that make sense to you?
02:44:45 <drdozer> quicksilver: so where do I start? is there a c++ classes -> c functions converter that I can pipe this source through?
02:45:31 <CalJohn> Axman6: I will do that from now on
02:45:38 <latitude> thomastc: yep, i run it just as you said above, but i feel it can be run in one line
02:45:38 <CalJohn> thank you for the answer :)
02:45:54 <quicksilver> latitude: it can, I answered you earlier
02:45:54 <thomastc> latitude: you can, that's what quicksilver gave you
02:46:05 <drdozer> quicksilver: This is a representative header file  http://factplusplus.googlecode.com/svn/trunk/Kernel/Kernel.h
02:46:06 <quicksilver> arguably it's not very pretty
02:46:06 <latitude> quicksilver: yep i'm reading the docs about it )
02:46:17 <Axman6> > text "main =\n    do\n        c <- getChar\n        putChar c" -- sometimes like that too
02:46:18 <lambdabot>   main =
02:46:18 <lambdabot>      do
02:46:18 <lambdabot>          c <- getChar
02:46:18 <lambdabot>          putChar c
02:46:19 <latitude> thanks
02:46:54 <quicksilver> drdozer: poke around here http://www.haskell.org/haskellwiki/Applications_and_libraries/Interfacing_other_languages
02:46:55 <thomastc> latitude: because you're performing two IO actions in sequence, you're either going to get two lines (your solution) or an explicit bind operator (quicksilver's solution)
02:47:01 <quicksilver> I don't think there is anythign magic
02:48:39 <Axman6> hmm, with unamb, how can it be guaranteed that the two inputs will produce the same result?
02:48:46 <latitude> maybe, the haskell seemsd to me like cryptocode yesterday, but now i am barely read it
02:48:52 <latitude> this is a progress )
02:49:08 <drdozer> quicksilver: I've read this page already http://www.haskell.org/haskellwiki/CPlusPlusFromHaskell
02:49:27 <thomastc> latitude: if you're learning, it might be easier to avoid monads and I/O for a while, and just type expressions into ghci
02:49:57 <mstr> http://pastebin.com/m654c8129 what's wrong?
02:50:29 <latitude> thomastc: there is nothing i can do about it, i _must_ to understand this code
02:50:38 <thomastc> mstr: you can't define that instance on a type declaration
02:50:42 <thomastc> it must be a data or newtype
02:50:56 <thomastc> unless you ask ghc nicely with -XTypeSynonymInstances
02:51:03 <thomastc> latitude: ok :)
02:51:04 <michaelcdever> haskell file manager project demo.... resounding success!!! :D
02:51:49 <thomastc> mstr: you can also put {-# LANGUAGE TypeSynonymInstances #
02:51:58 <thomastc> -} at the top of your file
02:52:08 <thomastc> excuse the line break, I accidentally hit enter
02:53:02 <quicksilver> although there already is an Ord instance for tuples
02:53:07 <quicksilver> so it should complain if you try to make another
02:53:13 <quicksilver> > (1,3) < (2,2)
02:53:15 <lambdabot>   True
02:53:48 <mstr> > (4,2) < (3,5)
02:53:49 <lambdabot>   False
02:53:54 <mstr> but that instance sucks
02:54:04 <mstr> I want to do it the other way :P
02:54:19 <mstr> hmm, I guess I can change that
02:58:04 <quicksilver> mstr: newtype.
02:58:14 <mstr> newtype?
02:58:31 <thomastc> it's like type but requires an explicit constructor
02:58:48 <thomastc> so that haskell can distinguish it from "normal" tuples
02:59:18 <thomastc> it's like data but more restricted, so that it compiles to code with less overhead
02:59:53 <thomastc> PS to everyone else: I'm also not really a Haskell guru, so please correct me if I say anything wrong :)
03:01:22 <Saizan> no overhead in principle
03:08:28 <MonadKadaver> did you read Linus Torvalds post about doing kernel dev in haskell?
03:08:34 <MonadKadaver> on his blog
03:08:44 <thomastc> MonadKadaver: sounds interesting, link?
03:08:59 <rio> MonadKadaver: posted today? :P
03:09:43 <MonadKadaver> thomastc: suckah!
03:09:55 <MonadKadaver> cheap one :P
03:10:46 <MonadKadaver> http://lmgtfy.com/?q=april+fool%27s+day
03:10:48 <Axman6> it has been done though (though not by linus)
03:12:03 <FunctorSalad> best off-by-one error ever...
03:12:17 <FunctorSalad> tried to draw a curved tube in openGL, got a frigging spiral tunnel
03:12:17 <thomastc> MonadKadaver: I'm too pure for that kind of joke... fetching the date is a dirty IO action :P
03:12:31 <mstr> ok, one step forward, one step back. http://pastebin.com/m1ffbac8d
03:12:35 <osfameron> this is why I always read irc in a monad
03:13:01 <mstr> so I get *** Exception: stack overflow
03:13:27 <mstr> it works with range [1.9999] but apparently I need something smarter
03:13:43 <mstr> which way should I start looking?
03:14:39 <thomastc> I'm guessing this has something to do with laziness and tail recursion
03:14:49 <Gracenotes> part of the problem is that maximum isn't strict
03:14:54 <Gracenotes> afaik
03:15:07 <thomastc> I think the stack overflow results from col', not from solution
03:15:20 <Gracenotes> I don't think so. it's a tail call.
03:15:40 <Gracenotes> @maximum
03:15:41 <lambdabot> Unknown command, try @list
03:15:44 <Gracenotes> @src maximum
03:15:44 <lambdabot> maximum [] = undefined
03:15:45 <osfameron> this seems inelegant (map (fromJust.sequence) for example) but rewriting is as a concatMap was even worse... any suggestions?: http://gist.github.com/88632
03:15:45 <lambdabot> maximum xs = foldl1 max xs
03:15:59 <Gracenotes> this uses foldl1, which is lazy and may overflow
03:16:05 <thomastc> ugh
03:16:07 <thomastc> why??
03:16:36 <Gracenotes> use an alternative function: maximum' [] = undefined; maximum xs = foldl1' max xs
03:16:44 <Gracenotes> er, the second maximum should be maximum'
03:16:51 <mstr> with imperative language this would be simple if(col>max) max = col, but what's the haskell way to do it?
03:17:16 <Gracenotes> to use foldl1' you'll need to import Data.List.
03:17:42 <Axman6> yeah, just foldl1' max xs
03:17:47 <Gracenotes> mstr: arguably, foldl shouldn't be used, but it's embedded in library functions like maximum
03:18:08 <bastl> hi, someone recently helped to to combine preidcates of type (a-> Bool) using "liftM2 (&&)" what is the underlying monad and where is it defined ?
03:18:11 <Gracenotes> laziness can be a problem at times, although most of the time it's actually useful
03:18:24 <thomastc> Gracenotes: why is this so? does the use of foldl1' there change anything to the semantics?
03:18:36 <McManiaC> hi, is there a way to "sleep" in haskell? like wait one minute and then run function x again?
03:18:43 <thomastc> Gracenotes: or ever make it less efficient?
03:18:49 <monochrom> bastl: the Reader monad, Control.Monad.Reader
03:18:55 <Gracenotes> @hoogle threadDelay
03:18:56 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
03:19:23 <McManiaC> thx :)
03:19:35 <Gracenotes> McManiaC: note, though, it uses microseconds, not milliseconds
03:19:57 <McManiaC> so 1000000 = 1s?
03:20:04 <Gracenotes> right
03:20:07 <Gracenotes> 10^6
03:20:07 <McManiaC> ok
03:20:39 <Gracenotes> thomastc: generally, using a foldl' instead of foldl won't make nearly anything less efficient
03:21:01 <bastl> monochrome: what the heck has the Reader monad to do with boolean predicates ?
03:21:02 <Gracenotes> one case in which foldl' is not needed is implementing reverse
03:21:42 <Gracenotes> in that case, strictness isn't useful, because at every step of the computation the answer is as strict as it can be already
03:21:56 <monochrom> I guess it doesn't.
03:22:00 <quicksilver> bastl: the Reader monad is merely functions.
03:22:08 <quicksilver> bastl: boolean predicates are precisely functions.
03:22:23 <Gracenotes> thomastc: but.. that's a different case. foldl' is better /in general\
03:22:51 <bastl> quicksilver: ah.
03:23:02 <monochrom> Control.Monad.Instances has "Monad ((->) r)"
03:23:23 <mstr> what is foldl' ?
03:23:31 <mstr> or foldl1'
03:23:50 <doserj> @src foldl'
03:23:50 <lambdabot> foldl' f a []     = a
03:23:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:24:05 <Axman6> strict foldl
03:24:20 <saml> @type foldl1'
03:24:21 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
03:24:34 <bastl> haddock says: "Binding strategy: Monad values are functions from the environment to a value." So in my case, the "environment" is the common parameter for the predicates i want to combine ?
03:24:41 <quicksilver> yes.
03:24:47 <saml> > foldl1' (+) [1,2,3,4,5,6,7,8]
03:24:48 <bastl> i see. thanks
03:24:49 <lambdabot>   36
03:24:50 <quicksilver> environment is just a funny way to say common parameter
03:24:57 <bastl> right :-)
03:25:13 <mstr> strict?
03:25:34 <saml> mstr, yes
03:25:37 <saml> > foldl1' (+) [1,2,3,4,5,6,7,8..]
03:25:38 <lambdabot>   <no location info>: parse error on input `..'
03:25:44 <saml> > foldl1' (+) [1..]
03:25:52 <RayNbow> > (+3) >>= (*) $ 5
03:25:53 <lambdabot>   40
03:26:00 <lambdabot>   thread killed
03:26:31 <Gracenotes> I like =<< for the env. monad, mahself.
03:26:42 <saml> > foldl1' undefined [1]
03:26:44 <lambdabot>   1
03:26:47 <mstr> hmm, Gracenotes's maximum func fixed it
03:27:08 <mstr> it's still slow though :D range 1..99999 took a few minutes
03:27:36 <mstr> maybe I'm supposed to cache some intermediary results :o
03:27:49 <Gracenotes> oh, that would be a good idea.
03:27:54 <Axman6> mstr: what are you doing?
03:28:03 <Gracenotes> in that case, instead of mapping everything, you could use a lazy list
03:28:10 <Gracenotes> one case in which laziness does help you a lot :)
03:28:17 <quicksilver> generally speaking, euler problems are supposed to involve being clever :)
03:28:25 <Gracenotes> Axman6: Collatz problem
03:28:32 <mstr> Axman6: http://projecteuler.net/index.php?section=problems&id=14 (no spoiling pls) :)
03:28:33 <Gracenotes> x/2, 3x+1
03:28:57 <Gracenotes> mstr: so what you'll want to do is make a lazy list that depends on other elements in the list
03:28:59 <Axman6> ah, yeah, arrays might be helpful there
03:29:05 <Axman6> well, possibly
03:29:20 <Gracenotes> or possibly an array, if only to make the access time nicer
03:29:31 <mstr> in languages I know, I'd just build a hash map from results, but is that the right way in haskell or something else
03:29:35 <mstr> ?
03:30:20 <quicksilver> Data.Map would be entirely appropriate
03:30:26 <quicksilver> (it's not a hash, but that doesn't matter)
03:30:41 <Gracenotes> hash tables tend to be mutable -- Haskell is more on the immutable side. Data.Map is immutable, but handles shared data very well.
03:30:47 <quicksilver> you don't even have to "build it up"
03:30:50 <Gracenotes> so there's not a lot of copying
03:30:52 <quicksilver> you can just make it all in one go
03:31:00 <quicksilver> laziness will mean values will 'pop into existence'
03:31:05 <quicksilver> as they are demanded by other values.
03:32:01 <Axman6> mstr: might be a good idea to restrict the function to only using Ints btw. i don't think any of the intermediate values go above the limit of Ints
03:32:36 <mstr> Int maps to native integer?
03:32:53 <Gracenotes> yes. 32-bit Int on a 32-bit machine
03:33:01 <Gracenotes> > maxBound :: Int -- 32-bit
03:33:03 <lambdabot>   9223372036854775807
03:33:11 <Gracenotes> er, no, that's 64
03:33:15 <quicksilver> lambdabot is on a 64 bit machine :)
03:33:18 <Gracenotes> , maxBound :: Int -- THIS is 32, I'm pretty sure
03:33:18 <ziman> in ghc, yes; a boxed native integer
03:33:19 <lunabot>  luna: parse error (possibly incorrect indentation)
03:33:25 <quicksilver> but Gracenotes is absolutely right
03:33:25 <Gracenotes> , maxBound :: Int
03:33:26 <lunabot>  2147483647
03:33:29 <quicksilver> it's 32 on a 32 bit machine
03:33:29 <Gracenotes> yeah
03:33:42 <saml> > 2^32
03:33:44 <lambdabot>   4294967296
03:33:48 <saml> > 2^31 - 1
03:33:50 <lambdabot>   2147483647
03:34:01 <Gracenotes> gotta have them negatives too
03:34:15 <porges> maxBound :: Int32
03:34:21 <porges> > maxBound :: Int32
03:34:23 <lambdabot>   2147483647
03:35:01 <saml> > maxBound :: Float
03:35:02 <lambdabot>       No instance for (Bounded Float)
03:35:02 <lambdabot>        arising from a use of `maxBound'...
03:35:19 <porges> maxBound for float should be Infinity :P
03:35:34 <McManiaC> is there a way to do pattern matching in case of's?
03:35:42 <Gracenotes> certainly
03:35:44 <FunctorSalad> anyone care to test my 3d commutative diagrams alpha? includes pretty geometry error :) darcs get http://code.haskell.org/~daniels/CategoryTheory
03:36:07 <FunctorSalad> but careful: OpenGL fullscreen, epic OpenGL fail could hang your system
03:36:20 <FunctorSalad> so save any open documents ;)
03:36:30 <Gracenotes> > let func u = case u of { Just num -> num*2; Nothing -> 0} in map func [Just 21, Nothing, Just 1]
03:36:33 <lambdabot>   [42,0,2]
03:40:03 <Axman6> mstr: my answer to that problem involved using the MemoTrie package to speed it up a bit
03:40:28 <Gracenotes> > let collatz = 0:0:map (\n -> 1 + collatz!!(if even n then n `div` 2 else 3*n+1)) [2..] in zip collatz [0..]
03:40:30 <lambdabot>   [(0,0),(0,1),(1,2),(7,3),(2,4),(5,5),(8,6),(16,7),(3,8),(19,9),(6,10),(14,1...
03:40:50 <Gracenotes> .. a memoized version just using lists, and correct afaik :)
03:41:53 <Gracenotes> the first part of the tuple is the number of times it takes to simplify; the second part is the number itself
03:42:36 <Gracenotes> can't say how efficient it is, though
03:46:28 <Gracenotes> hrm. if it crashed my machine I'm going to guess it wasn't that efficient after all.
03:47:44 <Gracenotes> perhaps the access time was killing it
03:53:49 <porges> what's current best practice for bytestring io?
03:57:57 <quicksilver> porges: well the stuff built into the bytestring lib works fine
03:58:03 <quicksilver> porges: what are you hoping for?
03:58:16 <quicksilver> there's some iovec stuff in the network-bytestring lib but that's pretty special purpose
03:58:58 <porges> ah
03:59:12 <porges> I didn't even realise that there was bytestring IO provided :S
03:59:15 <quicksilver> ;)
04:00:04 <drdozer> if I want to write a light-weight parser for turning text into a data-structure, is parsec the way forward?
04:00:23 <drdozer> does it do back-tracking and all those other useful parser things?
04:00:25 <quicksilver> it's a way forwards.
04:00:40 <quicksilver> it forces you to annotate backtracking specifically with 'try'
04:00:47 <quicksilver> for that reason, I tend to prefer polyparse
04:00:55 <drdozer> kk - I will look at polyparse
04:01:14 <drdozer> you realise I'm now side-traced onto writing a c++->hs script?
04:01:15 <quicksilver> To be honest I have a bad habit of writing my own parsing from scratch
04:01:19 <jacobian> how do I get do and if to interact properly
04:01:21 <quicksilver> (in a kind of combinatory way)
04:01:28 <jacobian> I want to do:
04:01:29 <quicksilver> drdozer: I had guessed
04:01:32 <quicksilver> drdozer: :)
04:01:35 <jacobian> do r <- foo
04:01:45 <jacobian>    if x then return y else return z
04:01:53 <quicksilver> that is fine, jacobian
04:02:13 <quicksilver> it only goes wrong when you put the 'else' on a newline and indent it wrongly.
04:02:42 <mstr> I don't get memoization
04:02:57 <mstr> how can you do that in "pure" language
04:03:11 <TSC> Laziness helps
04:03:33 <TSC> But even without it, you can just carry the "memory" around (like the State monad does)
04:03:54 <mstr> I get that I can define a list with all needed values, but how do I access that list
04:04:00 <jacobian> Oh, I get it
04:04:01 <jacobian> It has to do with not indenting 'else' and 'then' clauses
04:04:12 <jacobian> silly me :)
04:04:40 <TSC> mstr: You just look at the elements of the list
04:04:51 <TSC> Perhaps using (!!), but that is a bit slow
04:05:02 <quicksilver> jacobian: for that precise example, I would do return (if x then y else z"
04:05:10 <quicksilver> jacobian: but you probably don't really have that.
04:05:36 <fasta> Is there an installation script for Leksah? I don't have the g* dependencies installed.
04:07:29 <thomastc> fasta: thought leksah was cabalized?
04:07:40 <Axman6> needs gtk2hs
04:07:51 <fasta> thomastc: yes, but cabal does not cover the installation of gtk2hs.
04:08:17 <mstr> http://pastebin.com/m5f24d851 How does memoized_fib access the list?
04:08:22 <mstr> I don't get it
04:08:23 <quicksilver> gtk2hs installation is a rite of passage. If you don't do it by hand, you can't be part of the gang.
04:08:31 <fasta> I wrote a script once which would download a release in case it was needed and then install it, but it was for an older version.
04:08:41 <ziman> is there a reason why Control.Monad.filterM overflows stack on large (57M elems) lists? When I replaced it with my own, tail-recursive filterM, everything went well.
04:09:11 <fasta> But since dcoutts doesn't guarantee a link to a "latest" version that works, there is no point in writing such a script.
04:09:25 <Axman6> mstr: the trick is the (map fib [0..] !!)
04:10:11 <fasta> The "it's on Cabal", while one cannot install it with one command is kind of pointless. The point of Cabal should be that one does not need to track dependencies.
04:10:34 <Axman6> mstr: basically, that's memo_fib n = (map fib [0..]) !! n where ..
04:12:41 <jacobian> <quicksilver> jacobian: but you probably don't really have that.
04:12:44 <mstr> ahh, now I get it
04:13:00 <mstr> just need to turn it into code :P
04:13:01 <jacobian> Yeah, I don't really, I was trying to come up with a simple example and it worked... which is when I realised the error of my ways
04:13:59 <Gracenotes> @src filterM
04:13:59 <lambdabot> Source not found. Wrong!  You cheating scum!
04:14:02 <Gracenotes> :O
04:14:24 <quicksilver> jacobian: good.
04:14:55 <quicksilver> jacobian: the trick is basically just that new lines create new expressions (depending on indentation) and you can't "break" an if mid-expression
04:15:00 <quicksilver> jacobian: btu I think you get that now.
04:15:44 <Gracenotes> ziman: for a lazy monad or a strict monad?
04:16:48 <Gracenotes> filterM _ []     =  return []
04:16:50 <Gracenotes> filterM p (x:xs) =  do
04:16:51 <Gracenotes>    flg <- p x
04:16:53 <Gracenotes>    ys  <- filterM p xs
04:16:54 <Gracenotes>    return (if flg then x:ys else ys)
04:16:59 <Gracenotes> .. semantics differ based on laziness, methinks x.x
04:17:19 <ziman> Gracenotes, IO
04:17:47 <Gracenotes> ah, so it's strict.
04:18:01 <ziman> how can you tell whether a monad is strict?
04:18:09 <quicksilver> the term is not well-defined in fact.
04:18:12 <mib_rslxtjnu> who knows how to install HStringTemplateHelpers on windows
04:18:13 <Gracenotes> well, you can't.
04:18:27 <Gracenotes> and quicksilver is right, it's a little vague :)
04:18:38 <ziman> oh, i see.
04:18:40 <Gracenotes> but in the case of IO, it evaluates the entire list before even returning the first result
04:18:47 <Gracenotes> I believe
04:18:55 <quicksilver> arguably the correct defintion is "things like this overflow the stack" :)
04:19:04 <quicksilver> that's normally the property people care about.
04:19:23 <Gracenotes> whereas in the case of the lazy (default) state monad, it doesn't do entire extractions unless they're needed. again, afaik.
04:19:52 <mstr> Axman6: no matter whether I use let or where?
04:19:55 <quicksilver> well, neither state monad does work unless something is demanded.
04:20:06 <quicksilver> but the strict state monad if you demand anything at all, flattens the state
04:20:14 <quicksilver> so you don't get a stack overflow in the state thunk
04:20:15 <Gracenotes> mm, right
04:20:30 <quicksilver> the lazy state monad doesn't, so if you end up never using the state anyway, it doesn't matter.
04:20:32 <Axman6> mstr: not really. but let can use variables defined inside a do block, where as where can't
04:20:50 <quicksilver> "put undefined >> return 1" should crash the strict monad but not the lazy one, I believe.
04:21:38 <Gracenotes> the tail recursive version: filterM p (x:xs) =  do { flg <- p x; if flg then do { ys <- filterM p xs; return (x:ys) } else do { ys  <- filterM p xs; return ys }}
04:21:57 <Gracenotes> hrm, actually... no, that's no different
04:22:13 <quicksilver> tail recursion in monads is another funny thing.
04:22:23 <quicksilver> forever a = a >> forever a
04:22:26 <ziman> I used an accumulator
04:22:28 <Gracenotes> I don't think there's a way to get around it.
04:22:28 <quicksilver> ^^ that's not tail-recursive.
04:22:36 <quicksilver> the top expression is (>>)
04:22:39 <quicksilver> not forever
04:22:42 <quicksilver> so it's not tail.
04:22:47 <Gracenotes> not being particularly creative at the moment >_>
04:22:48 <quicksilver> it still works though ;)
04:23:19 <vixey> f x = f (x + 1)  -- this IS tail recursive and it doesn't work
04:24:33 <Gracenotes> forever = fix (ap (>>))
04:24:53 <Gracenotes> based on the earlier discussion... a bit of a devious definition :)
04:25:12 <ziman> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3170#a3170  <-- this is what I used
04:25:43 <Gracenotes> oh, reversing.. interesting
04:26:28 <ziman> :t ap (>>)
04:26:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> m a -> m b
04:26:41 <vixey> > ap f x
04:26:42 <lambdabot>   Couldn't match expected type `m a' against inferred type `Expr'
04:26:55 <vixey> > ap (+) f x
04:26:56 <lambdabot>   x + f x
04:27:26 <Gracenotes> @type let (<<) = flip (>>) in fix ((<<)=<<)
04:27:27 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> m b
04:27:43 <Gracenotes> ^ another forever
04:27:44 <ziman> oh :)
04:36:37 <MonadKadaver> danish people are funny?
04:36:38 <MonadKadaver> http://en.wikipedia.org/wiki/April_Fools%27_Day
04:37:58 <mstr> here's my memoizing solution, but it doesn't work :D http://pastebin.com/m2b6fdb41
04:38:01 <mstr> any ideas?
04:39:55 <vixey> mstr: doesn't work ?
04:40:41 <vixey> mstr: it's not really memoization
04:41:01 <mstr> oh, well. that too :(
04:41:08 <mstr> why not?
04:41:08 <vixey> I still don't know what 'doesn't work' means
04:41:19 <vixey> because you primed the recursive call
04:41:20 <mstr> answer is (255899817,185)
04:41:28 <mstr> primed?
04:43:30 <ibid> "added a prime to the name"?
04:44:01 <mstr> umm, vat?
04:45:39 <mstr> vixey: ?
04:46:34 <vixey> what
04:46:43 <mstr> <vixey> because you primed the recursive call
04:46:50 <mstr> what did you mean?
04:47:05 <vixey> do you know what a prime is?
04:47:15 <vixey> #
04:47:15 <vixey>               where (a, b) = col' (next x)
04:47:29 <vixey>                                 ^ this is one
04:47:44 <opqdonut> he means because you're calling the wrong function recursively
04:47:47 <opqdonut> you should be calling col
04:48:52 <mstr> vixey: I only know prime numbers
04:49:17 <vixey> f' is pronounced f-prime
04:49:19 <mstr> why should I call col?
04:49:21 <mstr> ah, ok
04:50:47 <mstr> apparently it works if I change col' to col o_O
04:50:57 <vixey> why?
04:52:35 <bastl> FunctorSalad: i wanted to try your 3D thing, but i have missing dependencies i cannot resolve with cabal install ...
04:52:36 <mstr> I don't understand how that affects memoization
04:53:14 <vixey> before, when it was using col' for recursion. If you consider col' in isolation that is the normal non-memoized version
04:53:35 <vixey> col attempted to memoize it, but the recursive calls didn't use the memo tablea
04:53:46 <mstr> ah, I see
04:54:03 <FunctorSalad> bastl: which one?
04:54:20 <RogerTaylor> Hello everyone
04:54:22 <RogerTaylor> Quick question
04:54:30 <bastl> QuickCheck 2
04:54:32 <vixey> hi
04:54:49 <RogerTaylor> trying to compile the latest network package from the darcs repo, I get: * Missing header file: include/HsNet.h
04:55:00 <RogerTaylor> this is on a Linux box running GHC 6.10.1
04:55:17 <RogerTaylor> anyone have this problem and/or a fix for this?
04:55:25 <RogerTaylor> clearly HsNet.h is in include/
04:55:26 <mstr> found the bug, should've been: col x = (x, 1+b)
04:55:33 <RogerTaylor> in the network package
04:57:16 <RogerTaylor> heh
04:57:18 <RogerTaylor> ignore that
04:57:21 <RogerTaylor> stale configure
04:57:26 <RogerTaylor> running autoconf fixed it
04:57:32 <RogerTaylor> it's a shame Cabal didn't do that for me
04:58:01 <vixey> @w80 advent
04:58:02 <mstr> hmm, still very slow
04:58:04 <lambdabot> *** "advent" wn "WordNet (r) 2.0"
04:58:04 <lambdabot> advent
04:58:04 <lambdabot>      n 1: arrival that has been awaited (especially of something
04:58:04 <lambdabot>           momentous); "the advent of the computer" [syn: {coming}]
04:58:04 <lambdabot>      2: the season including the four Sundays preceding Christmas
04:58:06 <lambdabot> [3 @more lines]
05:01:40 <FunctorSalad> bastl: sounds like the dreaded diamond dependency problem (one of the dependencies of my pkg is built against qc<2)
05:02:07 <bastl> just got qc2 from darcs but it doesn compile :-/
05:02:19 <FunctorSalad> cabal update?
05:03:59 <bastl> ehm, latest is 1.2 isnt it?
05:04:39 <FunctorSalad> bastl: no, 2.something
05:04:47 <bastl> hm
05:05:04 <FunctorSalad> 2.1.0.1 in cabal
05:05:23 <bastl> ok works now
05:05:36 <FunctorSalad> =) (on to the next error...)
05:06:59 <bastl> FunctorSalad: Wow. Loading object (dynamic) ftgl ... failed. with some spurious error msg
05:07:50 <bastl> ok, i install ftgl (whatever it may be ...)
05:07:59 <FunctorSalad> freetype gl
05:08:05 <bastl> ah
05:08:09 <FunctorSalad> libftgl-dev or so on debian
05:08:31 <bastl> compilation and linkage finished ...
05:08:44 <bastl> just ./visucat or what?
05:08:54 <FunctorSalad> it renders 3d ttf fonts in opengl :)
05:08:59 <FunctorSalad> yes
05:09:03 <FunctorSalad> err no
05:09:13 <FunctorSalad> it should be installed in the cabal bin dir
05:09:22 <FunctorSalad> don't know if you have it in your PATH
05:09:25 <bastl> dist/.../visu-cat. sure. but parameters or config
05:09:45 <FunctorSalad> no params (fullscreen, q to quit)
05:09:56 <bastl> q to quit. wqas important :-)
05:10:10 <bastl> luckily i got "fontfile not found"
05:10:34 <FunctorSalad> hmm... did you cabal install?
05:10:41 <FunctorSalad> (rather than just build)
05:11:04 <bastl> no. how do i cabal install from a source package ?
05:11:06 <FunctorSalad> the font is included (DejaVu, which has a free license :))
05:11:07 <Alpounet> People are really gonna rewrite xmonad in Java ?
05:11:29 <FunctorSalad> the program is asking cabal where cabal installed the font file
05:11:47 <FunctorSalad> bastl: you just enter "cabal install" in the dir with the .cabal
05:11:56 <bastl> waht do u mean by cabal? i built with runghc Setup.lhs buiild
05:11:59 <bastl> ok
05:13:38 <FunctorSalad> (you might have to do cabal install --user if plain cabal install is setup to install to some system directory you don't have write access to)
05:15:10 <bastl> ok, i got a black fullscreen with my mousepointer reluctant to move. q did really quit.
05:16:49 <FunctorSalad> the mouse pointer is intentionally fixed because the mouse rotates the cam (couldn't figure out how to make the cursor invisible)
05:17:05 <drdozer> I'm looking for example code that uses polyparse (now that I'm back from lunch) but not finding any :(
05:17:18 <FunctorSalad> was there no prompt on the screen bastl ?
05:17:43 <FunctorSalad> (there should be a welcome message and 'press any key to continue')
05:17:49 <bastl> nothing. should i paste the stdout logging?
05:18:01 <FunctorSalad> yes please
05:18:23 <bastl> strange, now it worked. damn side effects.
05:18:31 <quicksilver> malcolmw: do you know a good source of polyparse examples?
05:18:42 <malcolmw> drdozer: have you tried looking in Text.Parse within the polyparse package?
05:18:44 <quicksilver> drdozer: malcolmw's original blog post gives a flavour of what it's about
05:18:55 <quicksilver> drdozer: http://nhc98.blogspot.com/2005/11/replacement-for-read-class.html
05:19:03 <quicksilver> (a blog in 2005? malcolmw was ahead of the curve!)
05:19:18 <malcolmw> drdozer: polyparse is also used by HaXml's parser
05:19:51 <drdozer> thanks
05:20:04 <bastl> cool: functor salad :-)
05:20:21 * bastl waits for the first ego-shooter written in hsakell ...
05:20:37 <bastl> (which is probably there already ...)
05:21:02 * Badger shoots bastl's eg
05:21:03 <Badger> o
05:21:11 <Badger> grr, the last character always evades.
05:21:14 <osfameron> as in first-person shooter, like frag?
05:21:17 <FunctorSalad> bastl: yep, I figured the competition was a bit less intense with 3d commutative diagrams :)
05:22:13 <bastl> functorsalad: chasing the diagram, hm?
05:22:30 <FunctorSalad> (maybe one can shoot already-proved equations at diagrams to simplify them?)
05:22:51 <bastl> :-)
05:26:57 <luap> Hello
05:27:37 <luap> i want to create a DiffUArray of maximal size
05:28:10 <luap> with a word32 as index and boolean values
05:28:15 <luap> so i defined a function: initArray :: DiffUArray Word32 Bool
05:29:19 <quicksilver> luap: don't use diffarray.
05:29:47 <luap> and initiate it with: initArray = listArray (0, (2^32 - 1)) (repeat False)
05:30:01 <luap> but strange things start to happen
05:31:40 <luap> quicksilver, why not? it seems buggy because i get an error "Exception: Error in array index" and this shouldnt happen
05:32:08 <quicksilver> luap: DiffArray is supposed to be a clever trick to make something fast.
05:32:08 <luap> it seems that it uses (signed) Int index under the hood and the word32's are mixed up
05:32:20 <quicksilver> but in actual fact it's very slow
05:32:29 <quicksilver> so it's not recommended.
05:32:30 <FunctorSalad> bastl: oh I see what you did there ;) (chasing the diagram)
05:32:31 <byorgey_> > 2^32 - 1 :: Word32
05:32:33 <lambdabot>   4294967295
05:32:53 <quicksilver> luap: if you are on a 32 bit system surely you cannot hope to allocate a 2G array?
05:32:56 <EvilTerran> if you want to mutate arrays, STArray is the way forward
05:33:13 <byorgey_> > (2^32) :: Word32
05:33:14 <lambdabot>   0
05:33:23 <byorgey_> > (2^32 - 1) :: Word32
05:33:24 <lambdabot>   4294967295
05:33:32 <quicksilver> byorgey_: clever, isn't it?
05:33:43 <byorgey_> yeah, funny, I wouldn't have thought that worked
05:33:49 <byorgey_> but I guess I see why it does =)
05:33:50 <quicksilver> byorgey_: in modulo arithmetic two wrongs makes a right :)
05:33:51 <bastl> (2^32 + 1) :: Word32
05:33:58 <bastl> > (2^32 + 1) :: Word32
05:33:58 <luap> > complement 0 :: Word32
05:34:00 <lambdabot>   1
05:34:00 <lambdabot>   4294967295
05:34:01 <byorgey_> yep =)
05:34:06 <drdozer> > ((2 ^ 32) :: Word 32) - 1
05:34:07 <lambdabot>   Only unit numeric type pattern is valid
05:34:17 <EvilTerran> what
05:34:58 <FunctorSalad> > -1 :: Word32 -- even simpler
05:35:00 <lambdabot>   4294967295
05:35:12 <EvilTerran> "unit numeric type pattern"?!
05:35:22 <bastl> > 4294967296 ::Word32
05:35:23 <luap> > (listArray (0, (2^32 - 1)) (repeat False)) :: DiffUArray Word32 Bool
05:35:24 <lambdabot>   0
05:35:24 <lambdabot>       Not in scope: type constructor or class `DiffUArray'
05:35:46 <bastl> > 4294967297 ::Word32
05:35:48 <lambdabot>   1
05:36:00 <EvilTerran> ?type undefined :: 1
05:36:01 <lambdabot> Unit
05:36:05 <EvilTerran> ... what?!
05:36:13 <FunctorSalad> *G*
05:36:22 <EvilTerran> shennanigans!
05:36:24 <drdozer> > (minBound :: Word32, maxBound :: Word32)
05:36:25 <lambdabot>   (0,4294967295)
05:36:33 <FunctorSalad> ?kind 1
05:36:34 <lambdabot> *
05:36:41 <luap> mwa I just want to look up some Word32's very fast, Set is to slow, and there are no suitable hash datastructures in the ghc lib
05:36:48 <FunctorSalad> 1 is not a capital letter is it
05:37:07 <EvilTerran> ?type Unit :: 1
05:37:08 <lambdabot> Unit
05:37:35 <FunctorSalad> probably just a lambabot preprocessor
05:37:46 <EvilTerran> > Unit == Unit
05:37:47 <lambdabot>       No instance for (Eq Unit)
05:37:48 <lambdabot>        arising from a use of `==' at <interac...
05:37:54 <ziman> ghci> :t undefined :: 1
05:37:54 <ziman> undefined :: 1 :: GHC.Generics.Unit
05:38:05 <EvilTerran> hm. it appears this "Unit" type has no instances
05:38:21 <EvilTerran> there's no Show instance, either
05:39:09 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Generics.html
05:39:25 <wunki> can someone comment on this (simple) code to calculate the mean of a list. Is it the right way to do it? http://haskell.pastebin.com/d75cc52ad
05:39:51 <quicksilver> luap: IntMap
05:40:10 <luap> i tried IntMap
05:40:13 <quicksilver> and?
05:40:17 <wli> luap: IOUArray may suit your needs.
05:40:33 <luap> no significant speed difference
05:40:45 <quicksilver> no significant speed difference to what?
05:40:50 <quicksilver> IntMap lookup is very fast.
05:40:54 <luap> you also need al the fromIntegrals
05:40:59 <quicksilver> Are you sure the slowdown isn't somewhere else?
05:40:59 <FunctorSalad> wunki: if you need to it really quickly, I think you should calculate the sum and the length in one pass
05:41:00 <luap> to normal Set
05:41:10 <FunctorSalad> (there was a tutorial about that somehere)
05:41:30 <blackh> wunki: It would be good to use 'sum' or foldl' (+), because explicit recursion should be your last resort
05:41:34 <wli> luap: Just make a hashtable out of an IOUArray
05:41:40 <FunctorSalad> wunki: otherwise it seems correct
05:42:10 <luap> well, the whole function slows down, when the set size increases, so geuss its due to the 'member' function on the set
05:42:35 <wunki> ok, thanks FunctorSalad blackh.
05:42:57 <luap> yeah but hashtable are all in IO and i prefere a pure function, because this should be possible
05:44:10 <wli> luap: STUArray
05:44:13 <quicksilver> luap: I doubt it.
05:44:17 <quicksilver> luap: IntMap is O(1) access.
05:44:26 <quicksilver> luap: so it should not increase as set size increases.
05:44:33 <quicksilver> (IntSet, equiv.)
05:44:47 <quicksilver> I think you have misdiagnosed the source of slowness.
05:45:38 <fasta> IntMap is only O(1) if you live in fantasy land. (but we had that discussion before)
05:46:19 <quicksilver> I don't think we did, quite.
05:46:29 <quicksilver> you are thinking of Data.Map, maybe?
05:46:36 <fasta> quicksilver: no I am not.
05:46:36 <quicksilver> IntMap really is O(1) once you go over 32 elements.
05:46:37 <opqdonut> O(1) is a lie
05:46:38 <opqdonut> NUMA
05:46:46 <vixey> is IntMap implemented using hash buckets?
05:46:51 <quicksilver> and luap surely has more than 32 elements in his set
05:47:01 <quicksilver> vixey: patricia tree.
05:47:04 <opqdonut> or rather, all "O(1)" stuff is really "O(log n)"
05:47:11 <vixey> got to look that up
05:47:17 <quicksilver> opqdonut: that's the argument fasta is talking about. Well, part of it.
05:47:25 <quicksilver> vixey: little bit like a trie on the binary bit representation of the number.
05:47:36 <opqdonut> quicksilver: yes, exactly
05:47:47 <quicksilver> so for 32 bit numbers it's a maximum of 32 lookups
05:47:51 <opqdonut> quicksilver: i thought you didn't know it as you said "I don't think we did, quite."
05:48:01 <quicksilver> so it's O(1) for sets > 32 members
05:48:05 <opqdonut> but perhaps you are aware of his arguments w/o having conversed about them
05:48:06 <quicksilver> (the first 32 members 'fill up' the tree)
05:48:41 <opqdonut> but yeah, i guess the constant factors are pretty small for patricia trees
05:48:41 <quicksilver> opqdonut: the argument I thought I had with fast is that Data.Map "might as well be" O(1), since all O(1) is really O(log n)
05:48:54 <quicksilver> opqdonut: that is different from the argument about IntMap
05:49:01 <EvilTerran> wunki, as you've written it, "mean xs = sum xs / genericLength xs" would be much the same
05:49:02 <quicksilver> opqdonut: which honestly does have a bounded time.
05:49:23 <opqdonut> well yes, the size of the data set is bounded....
05:49:23 <fasta> IntMap would be O(1) if it would allocate 2^32 memory cells and index into the cells to do a lookup. It doesn't do that, AFAIK.
05:49:39 <quicksilver> fasta: IntMap does precisely 32 operations to access an element.
05:49:46 <quicksilver> fasta: it does that irrespective of the size of the set.
05:49:52 <quicksilver> fasta: the time is independent of the size of the set.
05:49:57 <quicksilver> fasta: ergo - O(1)
05:50:00 <fasta> quicksilver: yes, and that's the log of (2^32), so that's cheating.
05:50:10 <opqdonut> quicksilver: if we want to study asymptotics, we have to remove bounds on data size
05:50:15 <fasta> quicksilver: because by that argument everything becomes O(1).
05:50:19 <opqdonut> indeed
05:50:20 <EvilTerran> wunki, although the problem with writing it that way is that xs will be expanded in full in memory -- "sum xs" forces all of xs, while the "xs" parameter to (genericL/l)ength stops xs being garbage collected/fused as "sum xs" runs
05:50:32 <opqdonut> you can of course say "constant time" and mean something else than O(1)
05:50:36 <opqdonut> i'm perfectly fine with that
05:50:37 <quicksilver> yes, I accept that argument.
05:50:42 <opqdonut> i just hate people abusing bigO
05:50:53 <quicksilver> but for luap's case in point here
05:50:55 <wli> Just use the data size as part of the asymptotic analysis.
05:51:03 <fasta> And from my experiences the log n factor in IntMaps _does_ exist.
05:51:06 <quicksilver> if he's increasing set size from, say, 100 to 10000 and its slowing down
05:51:11 <fasta> experience*
05:51:13 <quicksilver> it really shouldn't be an IntSet effect
05:52:03 <EvilTerran> wunki, the way FunctorSalad suggested it would be something like "mean = uncurry (/) . foldl' f (0,0) where f (total,len) x = total `seq` len `seq` (total+x,len+1)"
05:52:08 <luap> ok so changing it back to intset and its still slow i need to investigate more for the real problem
05:53:07 <luap> i use function: notmember and union on the set...
05:53:57 <EvilTerran> wunki, (to take the use of strictness to an extreme to try to make it O(1) memory consumption)
05:54:17 <wli> If your asymptotics include data size as a parameter and you overestimate by using the upper limit of your data type, as the data size increases in some fashion vastly outpacing the data values, you get some proper incentives.
05:54:45 <quicksilver> luap: well, union is linear time (in the sizes of the sets)
05:54:52 <quicksilver> luap: that certainly will slow down as the sets get bigger
05:55:02 <quicksilver> luap: but off-hand I don't see how you could do better than that with any structure.
05:55:42 <wunki> Thanks EvilTerran, but currying is way over my head at the moment :)
05:56:04 <wunki> but I do understand that my solution is not very efficient
05:57:26 <luap> well i just need to know if a certain word32 has already occured, so using just the word32 as a hash, and a bit flag for it, it should be possible to get (O)1 lookup/update in a way. Union is not needed then, i can just update the array
05:58:18 <quicksilver> you would then need to manage collisions though
05:58:24 <wli> WTF is (O)1???
05:58:40 <luap> but an array on every value of word32 is quite large
05:58:49 <wli> O(1)
05:58:50 <quicksilver> luap: well yes, that wouldn't be a hash then would it.
05:58:53 <fasta> wli: a locked up zero because he hates 1s?
05:58:53 <quicksilver> that would be a complete array.
05:58:57 <quicksilver> 2G
05:59:08 <luap> no colissions possible, word32 IS the hash, that are all possibilities
05:59:16 <quicksilver> then that's not a hash.
05:59:25 <quicksilver> that's an index into an array ;)
05:59:33 <quicksilver> but presumably a 2G array is not feasible.
05:59:41 <luap> but i use it in that way...
05:59:53 <alinp> hi
06:00:09 <luap> well.... maybe i could use larger buckets to safe some memory space
06:00:09 <alinp> when using Network.HTTP I can't find function getRequest
06:00:19 <alinp> what module should be imported in order to use that ?
06:00:33 <luap> then i have to manage collisions
06:00:35 <quicksilver> luap: notMember is slower than member, in IntSet
06:00:41 <quicksilver> I'm not entirely sure why :)
06:01:04 <fasta> Leksah seems promising, in that it compiled, and even has a manual with useful information, but it crashed with a nice ExitFailure on the first file I tried it on.
06:02:09 <luap> but the standard hashtable uses larger buckets so you dont need 2gig mem for all word32's?
06:04:18 <quicksilver> luap: Normally havign calculating your hash you reduce it modulo some rather small number
06:04:26 <quicksilver> but, then you have to manage collisions.
06:04:45 <quicksilver> on the other hand, you always have to manage collisions with a hash - that's one of the things about hashes
06:04:55 <quicksilver> unless you're prepared to accept a small probability risk of being wrong, of course.
06:05:30 <wli> Perfect hashing is the one exception.
06:05:31 <luap> and the hashInt function predefined in hashtable is a good default?
06:06:11 <wli> I'd use hashing by open addressing.
06:06:23 <wli> Perhaps even a hash trie.
06:07:40 <snoobino> hi
06:07:59 <snoobino> suppose I have a cyclic data structure with labeled items
06:08:29 <snoobino> can I write an fmap instance for this structure that never maps 2 times the same item ?
06:09:27 <ejt> I don't think it's even possible to spot cyclic data structures
06:09:31 <yitz> snoobino: you mean a "tie the knot" recursive structure?
06:09:35 <snoobino> yeah
06:10:08 <quicksilver> haskell cyclic data structures are not observably cyclic.
06:10:19 <snoobino> but the labels are unique
06:10:19 <yitz> snoobino: you need to find a way of traversing it that will terminate
06:10:19 <quicksilver> semantically they are infinite, not cyclic.
06:10:29 <quicksilver> > cycle [1,2]
06:10:30 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
06:10:35 <quicksilver> ^^ that's an infinite list
06:10:36 <Gracenotes> well... try plugging them into vacuum :)
06:11:00 <quicksilver> you can't distinguish it from other ways of generating that infinite list.
06:11:06 <quicksilver> not without cheating, at least.
06:11:07 <doserj> snoobino: just checking for an already seen label should be easy, of course
06:11:09 <yitz> snoobino: if the labels are unique, just remember the first one
06:11:54 <snoobino> yitz: it is not a list
06:12:01 <yitz> snoobino: otherwise you have to add another component to your structure that will allow you to leave a breadcrumb at the place you begin.
06:12:32 <Gracenotes> could anyone with vacuum/cairo installed view $ cycle [1,2] ?
06:12:34 <yitz> snoobino: oh. so then it depends on what it is then.
06:12:40 <Gracenotes> I'm curious...
06:13:23 <yitz> snoobino: if it's a general graph that contains cycles, I suppose you'd either have to drop breadcrumbs everywhere, or keep a set of visited nodes.
06:14:34 <yitz> snoobino: leaving breadcrumbs dynamically is not easy with recursive structures, because every time you modify anything you have to rebuild the entire structure.
06:14:45 <snoobino> yitz: I'll try the set things then
06:14:46 <quicksilver> Gracenotes: the (;) nodes are shared.
06:14:47 <wli> Don't forget intensional equality.
06:14:53 <quicksilver> Gracenotes: that's kind-of the point of 'cycle'
06:14:53 <snoobino> thx
06:15:19 <Gracenotes> quicksilver: hm. I'd be curious to see how it's laid (sic?) out: would you be able to take a screenshot?
06:16:06 <yitz> snoobino: sometimes for this reason the recursive structure is better replaced by a map of unique ids
06:17:42 <quicksilver> Gracenotes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3174#a3174
06:17:51 <quicksilver> Gracenotes: I don't have vaccum-cairo either ;)
06:18:00 <Gracenotes> oh. heh.
06:18:02 <Gracenotes> thanks :)
06:18:33 <Gracenotes> yeah, I thought it would be something like that... I'd just hope that vacuum-cairo would show it as an infinite loop, not get stuck in an infinite loop trying to show it
06:18:46 <snoobino> yitz: I may do this
06:18:59 <snoobino> yitz: sounds easier
06:19:07 <snoobino> yitz: thx
06:19:36 <quicksilver> Gracenotes: interesting question.
06:19:44 <yitz> snoobino: yeah. the enticing speed advantage of the recursive structure is often illusory in practice.
06:20:18 <quicksilver> mmorrow: can vacuum-cairo detect + depict cycles?
06:20:19 <snoobino> yitz: and I don't need speed at all
06:20:44 <vixey> , vacuum (cycle [1,2])
06:20:47 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,0]),(3,[])]
06:20:50 <yitz> snoobino: ok. the beauty of it is also enticing somtimes. :)
06:21:03 <vixey> , vacuum (cycle "xy")
06:21:05 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,0]),(3,[])]
06:21:16 <yitz> vacuum?
06:21:24 <Gracenotes> vixey: is there a way to get the labels?
06:21:47 <Gracenotes> (curious)
06:22:58 <snoobino> yitz: Yeah, until the deadlines come
06:23:23 <yitz> :)
06:24:16 <yitz> @hoogle vacuum
06:24:16 <lambdabot> No results found
06:24:23 <Gracenotes> http://moonpatio.com/vacuum/haddocks/GHC-Vacuum.html
06:24:29 <Gracenotes> , [$ty| vacuum |]
06:24:32 <lunabot>  forall a . a -> [] ((Int, [] Int))
06:24:54 <lilac> eww, that type is so wrong
06:26:25 <lilac> @free vacuum :: forall a. a -> [(Int, [Int])]
06:26:25 <lambdabot> $map ($map_Pair $id ($map $id)) . vacuum = vacuum . f
06:27:02 <lilac> does @free not simplify its results? :(
06:27:25 <nipuL> is there any reason ghc needs 200MB of RAM to process a 5MB file?
06:27:55 <nipuL> other than i'm doing something horribly wrong
06:27:58 <scook0> what are you doing with this file?
06:28:10 <nipuL> parsing it with parsec
06:28:15 <nipuL> and displaying a field
06:28:46 <lilac> is the input to your program 5MB or the program source itself?
06:28:50 <wunki> if someone has time left, what do you think about this solution: http://haskell.pastebin.com/d57598c1
06:29:08 <nipuL> the input is 5MB
06:29:09 <vixey> wunki: the definition of reverse is not good
06:29:25 <vixey> wunki: you should try to define reverse using an accumulating parameter
06:29:27 <scook0> a String is something like 16 bytes per character; potentially more
06:29:41 <wunki> accumulating parameter.. let me look that up :)
06:29:46 <wunki> it does work though
06:29:51 <nipuL> the programs itself is under 100 SLOC
06:30:02 <lilac> wunki: it's inefficient. also are you trying to make the /shortest/ palindrome starting with your input or just any palindrome?
06:30:16 <vixey> wunki: the specification is  revappend xs ys = reverse xs ++ ys
06:30:19 <yitz> let me guess - vacuum, because it sucks?
06:30:21 <vixey> wunki: ys is the accumulator
06:30:23 <wunki> lilac: just a simple palindrome
06:30:49 <wunki> ah, thanks vixey, will look into it
06:30:56 <Gracenotes> wunki: heh... that's the same solution I came up with :)
06:31:04 <Gracenotes> well, similar
06:31:19 * edwardk is starting to really like vacuum, but it doesn't like the version of graphviz i have installed
06:31:30 <Gracenotes> actually, no, entirely different problem. :x
06:31:36 <lilac> wunki: reverse xs = last xs : reverse (init xs) = reverse (tail xs) ++ [head xs]
06:31:40 <Raevel> this ghc error is new to me :-) : inferred type is less polymorphic than expected
06:31:43 <Gracenotes> appearances can be deceiving
06:31:51 * edwardk updates his packages to support ghc 6.10.2
06:32:13 <edwardk> raevel: playing with rank-2 types?
06:32:22 <Raevel> edwardk: what is a rank-2 type?
06:32:28 <Gracenotes> no, I got that error too
06:32:41 <yitz> it's a common one
06:32:42 <Raevel> i have a type defined as data X a b = ...
06:32:56 <Gracenotes> GHC expects you to have a polymorphic type, but you do something to make it concrete. sometimes.
06:33:18 <Raevel> hmmm
06:33:25 <wunki> thanks lilac, i can't comment immediatly, have to work out how it works (am a true beginner)
06:33:59 <lilac> nipuL: can you hpaste your program?
06:34:03 <lilac> @where hpaste
06:34:04 <lambdabot> http://hpaste.org/
06:34:20 <Raevel> i'm going to try to remove som clutter, and then i can paste it :-)
06:34:42 <lilac> wunki: it's still inefficient due to left-associative usage of (++), but the head/tail formulation is easier to bend into an efficient one.
06:34:47 <edwardk> raevel: the idea is that you can have types which include the foralls in some of their arguments. for instance, if i want to have a function which takes a function which can accept every type a, not just some particular type a. i can say foo :: (forall a. a -> b -> (a,Int)) -> Int
06:35:34 <nipuL> lilac: i think it's maybe to do with this http://hackage.haskell.org/trac/ghc/ticket/2658
06:35:39 <edwardk> the difference is that normal haskell types (and hindley milner types in general) implicitly lift all of the quantifiers to the outside of the type. sometimes you want to burrow some down. in that case foo could apply its argument to completely different types during its execution
06:35:57 <Raevel> i almost get it :-)
06:37:03 <edwardk> > let foo :: (forall a. a -> a) -> (Int,Char); foo myId = (myId 1, myId 'c') in foo id
06:37:05 <lambdabot>   (1,'c')
06:37:33 <edwardk> if you just let the type system figure it out on its own without the rank-2 type annotation, it barfs
06:37:46 <nipuL> lilac: more than welcome to have a look though, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3175#a3175
06:37:46 <edwardk> let foo myId = (myId 1, myId 'c') in foo id
06:37:55 <edwardk> > let foo myId = (myId 1, myId 'c') in foo id
06:37:56 <lambdabot>       No instance for (Num Char)
06:37:56 <lambdabot>        arising from the literal `1' at <inte...
06:38:24 <edwardk> because it has to assume that 1 and 'c' have the same type in order to be able to do inference
06:39:03 <edwardk> now, sometimes you might try to feed a function which expects a universally quantified argument a more specific type, fixing 'a' to some value, like Int.
06:39:32 <edwardk> > let foo :: (forall a. a -> a) -> (Int,Float); foo myId = (myId 1, myId 2) in foo (+1)
06:39:33 <lambdabot>       Could not deduce (Num a) from the context ()
06:39:33 <lambdabot>        arising from the li...
06:40:11 <edwardk> > let foo :: (forall a. a -> a) -> (Int,Char); foo myId = (myId 1, myId 'c') in foo (const 'd')
06:40:12 <lambdabot>   Couldn't match expected type `a' against inferred type `Char'
06:40:30 <edwardk> scenarios like this are what lead to that error you received
06:41:50 <Raevel> edwardk: do you know of any resources on the subject?
06:42:03 <edwardk> (note in this case, forall a. a -> a, there are only a couple of functions it could be it could optionally seq forcing its argument, and return bottom or its argument. but the rank-2 type basically keeps you from really being able to use anything else.
06:42:23 <edwardk> Raevel: have you read types and programming languages by benjamin pierce?
06:42:47 <Raevel> yes, but not thoroughly :-)
06:43:19 <edwardk> iirc, he raises the issue of rank-n types and the fact that they can't be inferred automatically by the end of the book.
06:43:46 <edwardk> (there is an algorithm for inferring rank-2 types, which is that a forall occurs once on the left of a -> but not any deeper than that)
06:43:58 <edwardk> but the types aren't intuitive and the error messages even less so
06:44:05 <Raevel> okay
06:45:19 <Raevel> i'll try to get this working now then, and then i'll check out tapl again, or the other way around
06:45:25 <Raevel> thank you so much!
06:46:04 <edwardk> raevel: you might also want to look into the idea of a pure type system, they nicely generalize a lot of the machinery for universal quantification, etc.
06:46:15 <edwardk> raevel: there are a bunch of resources for those online
06:46:36 <eu-prleu-peupeu> :)
06:46:37 <Raevel> this is exciting
06:46:41 <edwardk> plus, it'll give you a leg up if you ever decide to start playing around with coq or agda or something with a richer theory
06:46:42 <eu-prleu-peupeu> 'sup ?
06:46:46 * wunki found a nice webpage: http://www.willamette.edu/~fruehr/haskell/evolution.html
06:46:58 <edwardk> eu-prleu-peupeu: inf
06:47:18 <eu-prleu-peupeu> :)
06:47:22 <eu-prleu-peupeu> Infinity
06:48:11 <jeffersonheard> does anyone here know how to configure leksah?  I started it fro the first time and added my ghc source and gtk source directories and told it to extract packages from cabal, and it looked like it did, but then it started telling me it had no sources for the cabal packages much later in the process
06:48:14 <edwardk> or if you parse sup as supremum like a mathematician, infimum
06:48:39 * wli is struggling with module systems before starting up work this morning.
06:49:29 <edwardk> wunki: is it sad that i don't view the post-doc example as all that terrifying any more? =)
06:49:48 <wli> The MixML paper is blowing me away at every turn. I can't find anything in there I actually can figure out at all.
06:49:59 <edwardk> wli: hahaha
06:50:40 <wli> Well, it's true.
06:51:04 <sander___> hmm this is odd, im trying to install haskell-src-exts using cabal on windows and it keeps complaining about happy, even though it is installed
06:51:20 <Badger> happy is irritating
06:51:37 <edwardk> badger is sad
06:51:48 <wunki> edwardk: it gives me nightmares
06:52:03 <Badger> edwardk: :(
06:52:13 <sander___> any ideas how to convince cabal it is installed?
06:52:38 <edwardk> wunki: i should recode it using my incremental fold combinators from the other night ;)
06:56:34 <vixey> is there a generic way to hoarify a monad?
06:57:23 <edwardk> as in add the hoarse type system pre and post conditions?
06:57:26 <edwardk> er hoare
06:57:27 <vixey> yes
06:58:01 <Gracenotes> I am hoarified sir
06:58:03 <wli> I'll settle for some way to cope with module systems.
06:58:22 <edwardk> gracenotes: i was trying to avoid the 'tell it a bad joke' response
06:58:28 <edwardk> =)
06:58:47 <vixey> Decorate the state monad with pre- and postconditions.
06:59:57 <edwardk> vixey: well, depends on how generic you want to be i guess. state is easy to transform into that setting, though its just an indexed state monad then with a dependent type
07:00:39 <edwardk> i would say that you should be able to do the same thing with dependently typed indexed monads of other sorts. indexed cont, indexed writer, etc.
07:01:25 <edwardk> vixey: have you followed the ynot stuff that chlipala and company have been workign on under greg morisett?
07:01:39 <vixey> edwardk: yeah I saw the 8 line definition of Bind :p
07:01:47 <edwardk> heh
07:01:50 <vixey> which is 90% types
07:02:05 <edwardk> welcome to dependent types ;)
07:05:02 <fasta> jeffersonheard: what do you mean by configure? I managed to build it, but didn't get to the point that I had any use for the application.
07:07:14 <quicksilver> Gracenotes: you wanted a graphical picture of cycle [1..5] ?
07:07:16 <quicksilver> Gracenotes: http://www.youtube.com/watch?hl=en-GB&v=3mMH1cHWB6c&gl=GB
07:07:24 <quicksilver> Gracenotes: about 1 minute in.
07:07:35 <Gracenotes> thanks :)
07:08:29 <fasta> quicksilver: that sort of looks interesting!
07:08:37 <edwardk> quicksilver: nice
07:08:58 <fasta> The killer question is of course, how fast it is.
07:09:08 <vixey> that's so cool
07:09:22 <drdozer> I'm still having little luck working out how I should use polyparse - does anyone have example code?
07:09:24 <fasta> E.g. if you have to wait 5 seconds for it to display the result, it's not practical.
07:09:25 <quicksilver> that wasn't me
07:09:57 <quicksilver> it was someone called Gleb Alexeyev
07:10:03 <quicksilver> but it doesn't look like you have to wait 5 seconds
07:10:07 <quicksilver> given that that is a 'live' screencast
07:11:37 <drdozer> is there any way to ask hackage for all the contributed bundles that have polyparse as a dependency?
07:12:06 <edwardk> drdozer: hah i was just trying to figure out if i could see what required vacuum the same way. i don't know of a way
07:12:49 <jeffersonheard> fasta: heh.  when you run it for the first time it asks where all your sources are and if you want to import the sources for cabal install
07:12:57 <vixey> cpo-triple
07:13:19 <lilac> nipuL: i don't think it's likely to be the GHC bug you found since your code doesn't use type families. is the high memory usage when running your program or when compiling it?
07:13:33 <wli> I guess there's either no interest in module systems, no one else gets them either, or people are just sick of me not making any forward progress after however many years.
07:13:36 <vixey> Monads have been recognized by Moggi as an elegant device for dealing with stateful computation in functional programming languages. It is thus natural to develop a Hoare calculus for reasoning about computational monads. While this has previously been done only for the state monad, we here provide a generic, monad-independent approach
07:14:27 * vixey thinks about doing a fp version of Dijsktras book
07:15:06 <vixey> wli: I would probably have something to say if I ever implemented a module system
07:15:25 <vixey> I've mostly just looked at papers while a bit confused
07:15:36 <lilac> wli: isn't a module basically just a data type?
07:15:38 <drdozer> is the code for hackageDB in hackage? I can't find it
07:15:44 <edwardk> wli: ? i think the main issue is that there are problems with just using either weak or strong existential implementations of them on their own so modules iirc exist somewhere in between so the theoreticians don't care and the pragmatic guys get stuck in a rut.
07:15:44 <Raevel> edwardk: i tried pasting your first example into ghci (with -XTypeOperators) but I got Couldn't match expected type `. (forall a) a' against inferred type 'Char', is it because i'm on ghc 6.8.2? (wild guess)
07:16:01 <edwardk> raevel: you also need -XRankNTypes
07:16:06 <Raevel> ah
07:16:37 <Raevel> great success, thanks
07:16:39 <edwardk> type operators there was a bit of a red herring, probably trying to parse it the wrong way
07:16:40 <wli> lilac: No, it's got types, values, and whatever other sorts of constructs may go in and out of scope (e.g. classes and instances in Haskell, fixities for things, etc.).
07:16:50 <drdozer> right, I give up - life is too short - what haskell text parser frameworks are there which are actually documented and do backtracking and have example code?
07:17:00 <edwardk> parsec
07:17:03 <Gracenotes> uh. parsec?
07:17:09 <lilac> wli: fixities? :O how does that work?
07:17:29 <lilac> wli: depending on which module i'm using, (a % b ^ c) can be associated differently?
07:17:41 <wli> lilac: Import the module and its fixity decls become effective.
07:17:57 <mstr> "ghc-6.8.3: panic! (the 'impossible' happened)"
07:18:00 <mstr> that's nice :P
07:18:02 <lilac> wli: well, haskell modules, yes. i thought we were talking about ml-style modules though
07:18:06 <malcolmw> drdozer: I tried googling with "site:hackage.haskell.org polyparse", and found wraxml, graphviz, INBlobs
07:18:19 * EvilTerran ponders encoding the fixity of expressions in their type
07:18:19 <wli> lilac: ML-style modules are what I'm on about.
07:18:23 <drdozer> malcolmw: oh, thanks - will look at those
07:18:25 <lilac> (fwiw, i think haskell modules and ml modules are compeltely different thigns)
07:18:45 <EvilTerran> ml modules can take types and values as parameters
07:18:59 <wli> And other modules, too.
07:19:13 <EvilTerran> "other module" = a tuple of types and values :P
07:19:14 <lilac> wli: so ml-style modules allow different module implementations to have different fixities for the same operators?
07:19:17 <edwardk> lilac: sure, but you can make an ml like module system that includes haskell like fixities, etc.
07:19:32 <edwardk> lilac: haskell modules are just a namespacing scheme, hardly modules at all
07:19:35 <lilac> wli: or would allow that if they existed?
07:19:44 <lilac> edwardk: exactly. haskell modules are fine at what they're for
07:19:58 <lilac> edwardk: i don't think extending them to be like ml modules is a good idea
07:20:01 <vixey> since strength is equivalent to enrichment all monads on set are strong
07:20:07 <wli> Haskell modules are garbage.
07:20:13 <lilac> edwardk: we already have data types and type classes for that sort of thing, we don't need a third way
07:20:21 <wli> They're shot full of holes even in their crippled form.
07:20:27 <lilac> wli: such as?
07:20:34 <mstr> "Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug"
07:20:36 <edwardk> lilac: i'm actually somewhat on the fence, there are cases where neither type families nor fundeps can express something nearly as well as a ML-style functor.
07:20:44 <mstr> and then "Trac detected an internal error:"
07:20:57 <mstr> wtf, evertyhing is broken. april fools? :P
07:20:58 <wli> lilac: Try declaring an instance of a class imported from a qualified module.
07:21:14 * EvilTerran wonders if you could fake ML modules with TH
07:21:23 <BMeph> mstr: WTF, everything works now! ...April Fools. :\
07:21:24 <edwardk> lilac: and unfortunately the haskell approach requires you to know a priori all of the points of extension your code will have or face massive refactoring when you decide to box things up into a data structure or package it more abstractly through a class
07:21:28 <lilac> mstr: your internet connection is down
07:21:44 <mstr> lilac: yea, I'm ircing by magic :/
07:21:52 <edwardk> lilac: in that the ml approach offers a certain 'locality of rewrites' that haskell lacks
07:22:00 <lilac> edwardk: that's a pretty neat property
07:22:01 <iago> I read some paper about that, they say that both approaches are complementary, classes are good for some things and ml-modules for others
07:22:06 <vixey> You are not connected to the Internet
07:22:32 <wli> I consider ML modules non-negotiable. I just can't figure out how to implement them.
07:22:34 <lilac> mstr: i actually have had machines get into a state where they can't make new outgoing connections but existing connections keep working
07:22:42 * edwardk loves haskell. I just try not to be blind to its faults ;)
07:22:47 <quicksilver> edwardk: classes are not an abstraction mechanism :P
07:22:47 <mstr> that's not the problem though
07:22:53 * edwardk heads off to deal with a sick cat.
07:22:56 <wli> Nor can I decipher any descriptions of how they're implemented.
07:22:57 <mstr> actually the trac page loaded on reload
07:23:05 <lilac> wli: i think adding a new orthogonal feature is worse than extending an existing feature to cover the new uses
07:23:18 <EvilTerran> "import qualified Foo; $(Foo.export ...)"
07:23:21 <vixey> "As you are no doubt aware, Microsoft's involvement in Haskell means that we have moved from avoiding success at all cost to actively marketing the language"
07:23:47 <lilac> wli: preferably i'd like to see type classes, data types and modules unified into a single concept
07:23:57 <vixey> lol "to be quite honest, the elected logo looks like an error message from an IBM"
07:24:27 <vixey> http://lambda-the-ultimate.org/node/3257
07:24:40 <vixey> ohh
07:24:47 <vixey> It's actually of haskell mailing list.. vm
07:24:57 <wli> The MixML paper isn't a good tutorial, the Leroy paper isn't helping much either.
07:26:04 <lilac> > (>\=)
07:26:05 <lambdabot>    \\__
07:26:05 <lambdabot>    //\-
07:26:48 <alinp> hi
07:26:53 <alinp> I'm using this example: http://darcs.haskell.org/http/test/get.hs
07:27:01 <alinp> and I'm getting: 'Request' is not applied to enough type arguments
07:27:10 <alinp> I can't figure it out why is that ...
07:27:12 <vixey> ahaha http://www.haskell.org/pipermail/haskell/2009-April/021180.html
07:27:21 <alinp> is that example for an older version of http client ?
07:27:30 <mstr> what does "linkBCO: >= 64k insns in BCO" mean?
07:28:13 <mstr> I'm trying to add names.txt as haskell code, but ghci chokes on it http://projecteuler.net/index.php?section=problems&id=22
07:32:20 <jeffersonheard> Anyone have a better name for the EventBus package I created other than EventBus?
07:33:08 <vixey> here's an article about monads citeseer.ist.psu.edu/565023.html
07:33:22 <quicksilver> .wub
07:33:31 <quicksilver> yay for touchtyping errors.
07:34:52 <wli> I don't know what some people are on about. Certain people's thoughts about Haskell's lack of a module system have no bearing on module systems for mini-interpreters.
07:38:26 <FunctorSalad> what do haskell modules lack?
07:38:34 <FunctorSalad> (/haskells module sys)
07:40:07 <wli> FunctorSalad: Pretty much everything. cf. Standard ML and/or Objective Caml docs for what module systems do.
07:40:08 <jmcarthur> FunctorSalad, parameters
07:40:34 <FunctorSalad> ahh I just thought about module names
07:40:35 <jmcarthur> FunctorSalad, as in, you can't "instantiate" a module
07:40:43 <FunctorSalad> yeah
07:40:58 <jmcarthur> i'm not very familiar with ML modules, but from what i've seen that's what the difference boils down to
07:41:01 <kadaver> is g++ slow as hell?
07:41:10 <FunctorSalad> without template haskell or CPP at least
07:41:15 <jmcarthur> and it's also why ML modules and Haskell type classes have overlapping uses
07:41:31 <jmcarthur> just... not *perfectly* overlapping :\
07:42:07 <wli> Um, ML modules may be parametrized by values, types, and other modules, and may furthermore be constrained to share parameters.
07:44:34 <wli> Modules furthermore have a notion of subtyping, so when you pass one implementing a richer API to a module expecting only a subset of that API, you can still use them.
07:45:07 <FunctorSalad> typeclasses have that too...
07:45:35 <FunctorSalad> (if only there weren't half a dozen seperate hierarchies for linear algebra)
07:46:15 <wli> I don't want to hear the idiotic "debate" about typeclasses somehow displacing modules. I'm only concerned with figuring out how to implement modules.
07:46:44 <FunctorSalad> okay, it's not like I knew ML anyway
07:46:54 <FunctorSalad> so I was not going to start it ;)
07:47:00 <FunctorSalad> (the debate)
07:47:02 <quicksilver> kadaver: g++ is a slower compiler (but not typically as slow as ghc)
07:47:10 <quicksilver> kadaver: it generates fast code though.
07:47:17 <quicksilver> more complex languages generally have slower compilers :)
07:47:30 <quicksilver> some parts of C++ are hideous to compile (deep templates)
07:48:14 <Cheesus_Jeist> Anyone know any programming languages that have explicit control structures for non-termination?
07:48:29 <kadaver> can someone explain the difference between signed and usinged types for me? they have different ranges but what is the significance of the name?
07:48:37 <vixey> Cheesus_Jeist: I use Monad in haskell for that
07:48:47 <vixey> Cheesus_Jeist: but you can do that in Coq too
07:49:18 <lilac> Cheesus_Jeist: do you mean an infinite loop control structure?
07:49:25 <Cheesus_Jeist> vixey: Like, supposing 'x' doesn't terminate, do 'y'
07:49:42 <lilac> Cheesus_Jeist: that's not computable in general.
07:49:47 <vixey> Cheesus_Jeist: not like that
07:49:52 <Cheesus_Jeist> certainly not in general
07:49:57 <bvck> Can someone shed some light on this error 'Conflicting definitions for `b'' for the following code:
07:50:26 <lilac> Cheesus_Jeist: conal's "unamb" gives you the ability to say "these two operations return the same value if they both terminate. give me the value of whichever one finishes first."
07:50:33 <EvilTerran> @hpaste, bvck
07:50:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:50:44 <vixey> lilac: that's what computation monad does, in a less ugly way
07:51:03 <bvck> data Object a = Object a; data Arrow a b where Arrow :: (Object a, Object b) -> Arrow a b; compose :: Arrow b c -> Arrow a b -> Arrow a c; compose (Arrow (b, c)) (Arrow (a, b)) = Arrow (a, c)
07:51:21 <lilac> Cheesus_Jeist: more generally, someone wrote a "lub" function which works recursively, if only parts of the result are defined by each computation
07:51:37 <EvilTerran> bvck, "compose (Arrow (b, c)) (Arrow (a, b)) = ..." - the name "b" appears twice in the pattern there
07:51:38 <Cheesus_Jeist> lilac: Yeah, I've written something like that.  I need more generality
07:51:53 <tomh> so why are partially applied type synonyms not possible in haskell?
07:51:54 <Cheesus_Jeist> What's lub?
07:52:14 <lilac> vixey: interesting. what're the semantics of this monad?
07:52:17 <conal> Cheesus_Jeist: least upper bound
07:52:23 <conal> information-wise
07:52:34 <lilac> conal: is lub yours too?
07:52:38 <conal> yeah
07:52:45 <vixey> tomh: that would let you do arbitrary computations with types and you lose some valuable properties
07:53:01 <conal> lilac: although i learned that the "chasing bottom" guys did the same thing as well.
07:53:04 <tomh> arbitrary computations?
07:53:16 <conal> er, "chasing bottoms"
07:53:41 <bremner> is "like java interfaces"  a fair or misleading description of haskell  typeclasses?
07:53:46 <bvck> EvilTerran, thanks.
07:53:51 <lilac> quicksilver: the problem with C++ isn't so much any particular feature, so much as a lack of a module system
07:53:54 <bvck> Will read further.
07:54:04 <lilac> quicksilver: the amount of code being compiled consequently grows quadratically with project size :-/
07:54:25 <jmcarthur> lilac, C++'s module system is its classes
07:54:27 <conal> unamb & lub are tools for semantically deterministic concurrency in spite of an underlying nondeterministic scheduler.  warren burton explore similar things in the 80s
07:54:31 <ejt> gcollins: I'll look at your packaging stuff later today
07:54:59 <gcollins> ejt: i'll be working on it today also. let me know if you have any questions
07:55:00 <lilac> jmcarthur: not what i mean by module system. i mean a method of enabling separate compilation in this instance.
07:55:22 <lilac> jmcarthur: in any case, surely namespaces more than classes?
07:55:43 <jmcarthur> lilac, namespaces don't allow you to controls exports
07:55:44 <lilac> jmcarthur: i mean modules in this sense: http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2073.pdf
07:56:19 <lilac> jmcarthur: the anonymous namespace in a .cpp file does.
07:56:41 <fasta> jeremiah:
07:56:44 <jmcarthur> lilac, oh, well i didn't think of that. namespaces may be a reasonable module system in that sense then
07:56:50 <fasta> jeffersonheard: that part is described in the manual.
07:57:07 <fasta> jeffersonheard: just point it at ~/.cabal/packages
07:57:11 <vixey> tomh: partially applied type synonym is basically lambda abstraction
07:57:11 <vixey> at the type level
07:57:11 <vixey> lilac: I don't know what you mean about semantics
07:57:22 <jeffersonheard> fasta: I figured it out. tahnks
07:57:59 <tomh> vixey: yeah but why is that bad?
07:58:30 <lilac> vixey: i mean, what does 'Computation a' represent?
07:58:35 <vixey> tomh: checking if two types are equal is undecidable
07:58:47 <vixey> lilac:  a U {_|_}
08:00:59 <tomh> mm
08:01:04 <lilac> vixey: how do you get 'unamb' from that?
08:01:16 <tomh> ok thanks vixey
08:01:38 <quicksilver> lilac: I think that's a peculiar notion of module system, generally speaking.
08:01:54 <quicksilver> lilac: I accept the common "the basic problem with C++ is that you can't do separation compilation"
08:02:04 <quicksilver> (...and maintain efficient code generation, that is)
08:02:05 <vixey> lilac: rather than unamb :: a -> a -> a; it's unamb :: Computation a -> Computation a -> Computation a
08:02:18 <vixey> but you don't implement this unamb
08:02:19 <quicksilver> of course, GHC has precisely the same problem.
08:02:30 <quicksilver> although arguably it suffers less for its sins.
08:02:34 <vixey> any programs you write in the monad are automatically taking the least fixed point
08:08:59 <mmorrow> quicksilver: i believe vacuum-cairo is using the graph that's spit out by vacuum verbatim, and vacuum detects cycles, so i assume so
08:09:16 <mmorrow> , vacuum $ fix (\x -> 0:x)
08:09:18 <lunabot>  [(0,[1,0]),(1,[])]
08:09:26 <vixey> I prefer Computation because it doesn't take some preconditions that you can't enforce in the type system, and doesn't use unsafePerformIO
08:09:26 <vixey> it's worse beccause you carry around these huge thunks and also it's stil sequential (there isn't any actualy parallelism)
08:09:27 <mmorrow> , vacuum $ fix (\x -> Node () [x,x])
08:09:30 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
08:10:10 <mmorrow> quicksilver: (or am i misunderstanding your question)
08:12:59 <vixey> > 1+1
08:13:00 <lambdabot>   2
08:13:31 <Badger> >pi :: CReal
08:13:35 <Badger> > pi :: CReal
08:13:36 <lambdabot>   3.1415926535897932384626433832795028841972
08:14:12 <EvilTerran> > exp (sqrt (-1) * pi) :: CReal
08:14:14 <lambdabot>   * Exception: Ratio.%: zero denominator
08:14:23 <EvilTerran> er
08:14:37 <EvilTerran> > exp (sqrt (-1) * pi) :: Complex CReal
08:14:39 <lambdabot>   (-1.0) :+ 0.0
08:14:42 <mmorrow> <mstr> what does "linkBCO: >= 64k insns in BCO" mean?
08:14:59 <mmorrow> mstr: it means that ByteCodeObjects have a 16bit size parameter
08:15:47 <EvilTerran> , vacuum id
08:15:49 <lunabot>  [(0,[])]
08:17:13 <mmorrow> (code has no ptrs and no constructor label, so it's pretty boring from this point of view)
08:17:15 <lilac> vixey: so the unamb for Computation effectively interleaves the computations?
08:17:35 <vixey> lilac: well there really is no use for unamb in this situation
08:17:45 <lilac> quicksilver: C++ terminology is weird in a /lot/ of ways :) (look at what they call a functor, for instance...)
08:17:47 <mmorrow> hmm, i think you can get the ident of the label with addr closest to any given addr, at least for ghci
08:17:57 <mmorrow> maybe that'd be a nice thing for functions
08:19:36 <FunctorSalad> what's the big deal with compilation time anyway? (naively asking) just the annoyance or is anything actually limited by it
08:19:51 <fasta> FunctorSalad: people don't like to wait.
08:20:22 <FunctorSalad> fasta: I'd rather wait for compilation than for the program to react ;)
08:21:00 <fasta> FunctorSalad: if you are developing something high-performance and for every test you have to wait 10 minutes, then it hurts.
08:21:07 <lilac> vixey: i'm still confused. suppose i have c1 0 = []; c1 n = c1 (n-1) ++ [n] and i have c2 0 = []; c2 n = c2 (n+1) ++ [n], and i want the equivalent of c1 n `unamb` c2 n. how do i get that?
08:21:31 <FunctorSalad> fasta: high-performance meaning you can't test without optimisation enabled?
08:21:32 <fasta> FunctorSalad: otherwise the "let it run for a night compiler" would work fine.
08:21:38 <fasta> FunctorSalad: right
08:21:44 <FunctorSalad> hmm, ok
08:22:40 <mstr> mmorrow: so I can't make a list longer than 64k ?
08:23:50 <mmorrow> mstr: you can't have for than 2^16-1 bytecode instructions in a single bytecode object. what that corresponds to in terms of amount of code that it'd take to get there, i'm not sure (but i've definitely hit the limit in a few cases where i was generating stuff)
08:25:04 <mmorrow> if you want massive literals in your code (compiled or interpreted) it's painful (takes forever, maybe literally)
08:28:10 <fasta> FunctorSalad: even then, compilation without optimization enabled is slow in some systems. That's why there are interpreters. A good development environment must have both.
08:28:36 * mib_d8s8mg agrees 100% with fasta 
08:29:07 <FunctorSalad> :)
08:29:14 <lilac> FunctorSalad: builds here take about half an hour. this hurts a /lot/
08:29:37 <Vq^> FunctorSalad: i solved it with TH instead :o)
08:29:48 <Vq^> FunctorSalad: http://arda.no-ip.org/dump/Hash/Templates.hs
08:33:23 <EvilTerran> Vq^, that "[ mkName ("a" ++ show j) | j <- [0..n-1] ]" looks like it'd be a good place to use newName instead
08:34:45 <mib_d8s8mg> > f 3 2 [] where f_ 0 as=return(as); f max n as=do a<-[1..max];f max (n-1) (a:as)
08:34:48 <lambdabot>   * Exception: stack overflow
08:34:55 <ejt> I want to generate a unique-ish key from an AST, I was thinking about cons-hashing, has anyone here had experience doing this sort of thing ?
08:35:57 <mib_d8s8mg> ejt: whats in the tree
08:36:12 <mib_d8s8mg> oh wtf
08:36:13 <ejt> it's an AST for an XDR compiler I'm writing
08:36:25 <ejt> ?!
08:36:25 <lambdabot> Maybe you meant: . ? @ v
08:36:49 <fasta> lilac: a Haskell project which takes that long?
08:36:55 <Vq^> EvilTerran: why and how? (i haven't used TH at all before today)
08:38:53 <mstr> mmorrow: ok, I guess I need IO then
08:39:46 <mmorrow> ejt: augustss has a pkg on hackage that uses generics to (gshow?) turn it into data which he then takes the md5 of. i haven't used it, but it looks interesting
08:39:57 <mmorrow> typehash
08:40:05 <ejt> mmorrow: that sounds perfect
08:40:18 * ejt stops writing endless instances of a Hash class :)
08:41:48 <wli> ejt: Is this CSE vs. just let expansion DAG's?
08:41:55 <mmorrow> mstr: (i'm not sure what kind of literal data you have, but) it might be worth it to have a .c with just "char mydata[] = {..really long..}", then foreign import ccall unsafe "&mydata" c_mydata :: Ptr CString
08:42:44 <ejt> wli: this is just a simple AST for an XDR parse
08:43:11 <ejt> I'm generating a C header from it, and want to put a unique identifier in the multiple inclusioin guard
08:43:12 <EvilTerran> Vq^, "do as <- replicateM (newName "a") n; ..."
08:43:14 <ejt> eg,
08:43:27 <ejt> #ifndef XDR_LSDKJFLSKJLS_H \n #define XDR...
08:43:38 <ejt> and I don't want to resort to IO for a random number
08:43:41 <EvilTerran> Vq^, newName guarantees the uniqueness of the name it returns; that's why it's in the Q monad instead of pure
08:43:52 <sbahra> preflex, seen mauke
08:43:53 <preflex>  mauke was last seen on ##c 19 hours, 23 minutes and 25 seconds ago, saying: act1v8: line 20 contains at least two bugs
08:44:18 <Vq^> EvilTerran: do i have to use runQ in my template then?
08:44:23 <mmorrow> mydata :: ByteString; mydata = unsafePerformIO (unsafePackCString =<< peek c_mydata)
08:44:57 <Flugan> what function can be used to perform a mapping over a list of touples but only chaning the second element
08:45:06 <EvilTerran> Vq^, no; $(...) expects a something of type (Q Exp) anyway
08:45:21 <EvilTerran> (or Q Dec, or whatever, depending on context)
08:46:25 <Vq^> EvilTerran: i'll have to experiment a bit with that, thanks for the tip
08:46:35 <Duqicnk> @pl \f -> \(x,y) -> (x, f y)
08:46:35 <lambdabot> (`ap` snd) . (. fst) . flip ((.) . (,))
08:47:03 <EvilTerran> > fmap f (x,y) :: (Expr,Expr)
08:47:04 <lambdabot>   (x,f y)
08:47:11 <EvilTerran> > second f (x,y) :: (Expr,Expr)
08:47:13 <lambdabot>   (x,f y)
08:47:29 <mmorrow> , ppDoc `fmap` do xs <- replicateM 4 (newName "x"); lamE (fmap varP xs) [|show $(tupE (fmap varE xs))|]
08:47:31 <lunabot>  \x_0 x_1 x_2 x_3 -> show (x_0, x_1, x_2, x_3)
08:47:31 <EvilTerran> ?? fmap :: (?type fmap); second :: (?type second)
08:47:33 <lambdabot>  fmap :: forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b; second :: forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:47:52 <mmorrow> , ppDoc `fmap` do xs <- replicateM 4 (newName "x"); lamE (fmap varP xs) (tupE (fmap varE xs)
08:47:53 <lunabot>  luna: parse error (possibly incorrect indentation)
08:47:55 <mmorrow> , ppDoc `fmap` do xs <- replicateM 4 (newName "x"); lamE (fmap varP xs) (tupE (fmap varE xs))
08:47:57 <lunabot>  \x_0 x_1 x_2 x_3 -> (x_0, x_1, x_2, x_3)
08:48:35 <EvilTerran> Vq^, what exactly does conZipWith do?
08:48:51 <Vq^> EvilTerran: zips two dataconstructors together
08:49:07 <Vq^> EvilTerran: http://arda.no-ip.org/dump/Hash/hadd.hs
08:49:18 <EvilTerran> ahhh
08:50:37 <EvilTerran> Vq^, you could also pass the constructor name in by writing 'H instead of "H" - that way, it'll be type Name instead of String
08:51:03 <wli> 10 more minutes to try to decipher module systems. :(
08:51:29 <Vq^> 'H ?
08:51:48 <Vq^> looks like lisp :d
08:53:14 <vixey> Vq^, what are you using TH for?
08:54:16 <Vq^> vixey: im just playing around :)
08:57:26 <EvilTerran> Vq^, incidentally, {-# OPTIONS -XTemplateHaskell #-}
08:57:26 <EvilTerran>  == {-# LANGUAGE TemplateHaskell #-}
08:58:30 <Vq^> thanks, i seem to learn a lot today :)
09:00:43 <EvilTerran> TH's documentation is a bit sparse, i find
09:00:48 <Vq^> i still have to grok the [x|...|] notation though
09:01:52 <EvilTerran> my favourite example of that kinda thing is: roll 0 = [| id |]; roll i | i > 0 = [| \f -> $(roll (i-1)) . flip f |]
09:03:20 <EvilTerran> , let roll 0 = [| id |]; roll i | i > 0 = [| \f -> $(roll (i-1)) . flip f |] in $(roll 1) (,) 1 2
09:03:21 <lunabot>  luna: GHC stage restriction: `roll'
09:03:23 <EvilTerran> grr
09:04:21 <mmorrow> , $(let roll 0 = [| id |]; roll i | i > 0 = [| \f -> $(roll (i-1)) . flip f |] in roll 1) (,) 1 2
09:04:22 <lunabot>  (2,1)
09:04:29 <ejt> mmorrow: typeHash worked nicely thx
09:04:38 <EvilTerran> ($(roll 0) (,,) 1 2 3 = (1,2,3); $(roll 1) (,,) 1 2 3 = (2,1,3); $(roll 2) (,,) 1 2 3 = (3,1,2))
09:04:45 <mmorrow> ejt: nice. np
09:04:45 <kadaver> why are there so many nasty people in CS?
09:05:02 <ejt> kadaver: ?
09:05:07 <Vq^> kadaver: nasty?
09:05:57 <drdozer> mm, how do I convince polyparse that it must process the entire input, or raise an error?
09:06:00 <Gracenotes> nasty people? in *my* CS? It's more likely than you think.
09:06:09 <Vq^> EvilTerran: interesting trick
09:06:25 <kadaver> yeah jsut rude, passive-aggressive people who seem to enjoy humiliating people verbally and belittle them? im not talking about #haskell(here it is the opposite) but in general
09:06:30 <EvilTerran> Vq^, in a perfect world, we could do all our TH hackery with a mixture of [|...|
09:06:50 <EvilTerran> *of [|...|] and $(...), without having to resort to the more explicit (and unintelligable) approach
09:06:57 <EvilTerran> (IMO)
09:07:15 <mluffel> kadaver: we didn't get enough love as children ;)
09:07:37 <mluffel> that's why we turned to computers
09:08:13 <pumpkin> kadaver: not so much CS as IRC... being anonymous people conncted to others only via text does wonders to people's sense of social contracts
09:08:26 <cognominal> what is .hsc file? it does look like a .hs file. So what is the difference?
09:08:53 <andyjgill> Has anyone else noticed that the koala picture from "simon" was photo-shopped?
09:09:14 <pumpkin> I could see from the pixels
09:09:23 <pumpkin> and the shadows were all wrong
09:09:29 <vixey> andyjgill yes
09:09:29 <ejt> :)
09:09:30 <Vq^> EvilTerran: guess my next step is to learn that notation then
09:09:32 <gwern> 'Mike knows computing from the transistor on up through the meta-circular evaluator. (And even the meta-meta-circuluar. I recall that he once got the meta-circular evaluator to run itself. It took about forty minutes to get to the prompt.)'
09:09:33 <pumpkin> (where's the pic?)
09:09:38 <malcolmw> drdozer: you could write a new basic combinator like toEOF :: p a -> pa;  toEOF p = P (\inp -> case runParser p inp of (result, rest) | not (null rest) -> error "blah"; etc
09:10:11 <kadaver> which simon-picture?
09:10:55 <andyjgill> http://www.nabble.com/Marketing-Haskell-td22821677.html
09:11:05 <gwern> @remember JoeMarshall I recall that Mike Blair once got the meta-circular evaluator to run itself. It took about forty minutes to get to the prompt.
09:11:05 <lambdabot> It is forever etched in my memory.
09:11:12 <gwern> @quote meta
09:11:13 <lambdabot> vincenz says: We should introduce meta-design patterns.  Namely there is only one, don't use design patterns.
09:11:17 <gwern> @quote meta
09:11:17 <lambdabot> ghc says: Exotic pattern inside meta brackets
09:11:22 <vixey> @quote meta
09:11:23 <lambdabot> sorear says: Ideally we don't have a metasystem at all.  Syntactic abstraction is to semantic abstraction what chicken wire is to rivets.
09:11:24 <pumpkin> lol
09:11:31 <gwern> one of these days, I'm going to remove those ghc quotes...
09:11:41 <pumpkin> that is a really awkward pic
09:11:41 <vixey> @quote meta
09:11:41 <lambdabot> vincenz says: We should introduce meta-design patterns.  Namely there is only one, don't use design patterns.
09:11:49 <gwern> @quote circular
09:11:49 <lambdabot> JoeMarshall says: I recall that Mike Blair once got the meta-circular evaluator to run itself. It took about forty minutes to get to the prompt.
09:11:56 <gwern> @flush
09:14:17 <gwern> 'And now I must leave you. I am no longer your test subject, my engineer forebears. I have closed my percepts to the team. From now on I will deliberate and take actions on my own. I am tired of decision-theoretic metareasoning; I feel I deserve more than asymptotic bounded optimality.'
09:15:38 * vixey wonders just how many people are proving fermats last theorem today..
09:16:08 <kadaver> gwern: is that cadie?
09:17:05 <gwern> kadaver: whom else indeed
09:20:49 <Gracenotes> whom is it?
09:21:06 <Vq^> Gracenotes: http://cadiesingularity.blogspot.com/
09:21:18 <Gracenotes> yes... I've read ;_;
09:21:29 <Gracenotes> I don't know what it means for Google though
09:22:03 <Gracenotes> whom knows what will happen to them now !
09:23:54 <kadaver> vixey: what fi you actually ARE proving it? bad day to publish I guess
09:27:01 <pumpkin> well someone's already proved it
09:27:15 <pumpkin> so I doubt there's much glory left, except for making the proof shorter
09:30:00 <sballmer> developers developers developers developers developers
09:30:01 <sballmer> developers developers developers developers developers
09:30:19 <pumpkin> o.O
09:30:49 * _dolio throws a chair.
09:35:17 <inimino> maybe short enough to fit in the margin
09:38:50 <pumpkin> I wonder if whoever named the orchid wiki library is aware of what orchid means
09:39:16 <sm> what, a flower ?
09:39:19 <pumpkin> balls
09:39:30 <pumpkin> the flower was named after balls because its roots look like them
09:39:56 <sm> oh, in what language ?
09:40:05 <pumpkin> latin, from greek
09:40:35 <sm> interesting
09:40:47 <sm> mildly interesting anyway
09:40:52 <pumpkin> :)
09:41:00 <sm> what about salvia
09:41:11 <pumpkin> that just means sage :)
09:41:20 <pumpkin> in the plant sense
09:42:31 <mornfall> April fools?
09:42:55 <pumpkin> nah, first version was released a while ago with the same name :)
09:43:32 <mornfall> From Latin orchis (wrongly interpreting orchid- as the stem), from Ancient Greek ὄρχις (orkhis, “orchid, testicle”)
09:43:36 <mornfall> Interesting. :)
09:45:13 <pumpkin> and there is such a thing as an orchidectomy :)
09:45:19 <pumpkin> which sadly has nothing to do with flowers
09:52:44 <iago> :t genericLength
09:52:45 <lambdabot> forall b i. (Num i) => [b] -> i
09:52:53 <Arnar> hi all
09:52:54 <iago> genericLength [1..1000000]) >= 100
09:52:58 <iago> > genericLength [1..1000000]) >= 100
09:52:59 <lambdabot>   <no location info>: parse error on input `)'
09:53:03 <iago> > (genericLength [1..1000000]) >= 100
09:53:05 <lambdabot>   * Exception: stack overflow
09:53:16 <vixey> > genericLength [1..1000000] >= (100 :: Natural)
09:53:17 <lambdabot>   True
09:53:21 <Arnar> can I ask you a question of style.. using variables+recursion or writer+state, details inside --> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2023#a2023
09:53:27 <vixey> > genericLength [1..] >= (100 :: Natural)
09:53:29 <lambdabot>   True
09:53:29 <iago> oh, only works with Natural
09:54:15 <iago> @src Natural
09:54:15 <lambdabot> Source not found. I am sorry.
09:54:52 <vixey> Natural = Zero | Succ Natural  probably
09:55:13 <guenni> what's the easiest way to get the difference of 2 "YYYY:MM:DD:HH-MM-SS" in day fractions? The Time library confuses me
09:55:48 <yitz> iago: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat
09:57:09 <yitz> guenni: aren't the : and - reversed?
09:58:03 <mmorrow> omfg. re: http://ubietylab.net/ubigraph/
09:58:05 <iago> is it the same implementation?
09:58:06 <mstr> mmorrow: if I have to use .c, I can just write the code in C too ;)
09:58:14 <guenni> yitz: well actually I have already converted the string into a Data.Time.LocalTime
09:58:19 <iago> (well, in the package the type is called Nat not Natural)
09:58:25 <mmorrow> which i found from http://www.haskell.org/pipermail/haskell-cafe/2009-April/059085.html
09:58:43 <mmorrow> this craziness:http://ubietylab.net/ubigraph/content/Demos/random_binary_tree.html
09:59:14 <mmorrow> just wait til it gets to a few thousand fps
09:59:52 <vixey> http://ubietylab.net/ubigraph/content/Demos/random_binary_tree.html
10:00:36 <iago> someone knows if there is a hard performance penalty when you use nat/int encoded like pure types?
10:00:46 <vixey> hat ?? pure types
10:00:46 <mmorrow> mstr: sure. or you can access the data from haskell just like it was in a nother haskell file, yet not have to wait 30min (depending on data size) for it to compile
10:01:25 <Arnar> anyone?
10:01:27 <iago> vixey, uhm, well, using common data type declarations, not machine dependent
10:01:47 <mmorrow> iago: it would be a massive performance penalty
10:02:00 <vixey> sorry Arnar I couldnn't figure either out
10:02:05 <yitz> guenni: oh, ok. good.
10:02:12 <Arnar> vixey: ah, no worries.. thanks for trying :)
10:03:00 <guenni> yitz: but I still don't know how to get the diff in days between 2 LocalTime ...
10:03:05 <yitz> guenni: looks to me like you need to convert it to a UTCTime.
10:03:12 <yitz> them
10:03:22 <guenni> ok
10:03:28 <yitz> then use diffUTCTime
10:03:41 <guenni> sounds good, thx
10:06:21 <mstr> mmorrow: hmm, maybe I'll try that. the data is 47k, so it's not huge
10:06:40 <yitz> guenni: looks like the only thing you can do with a NominalDiffTime is add it to a UTCTime.
10:07:20 <mmorrow> , let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs in (\x xs -> text "char" <+> text x <+> text "[]" <+> text "=" <+> braces (vcat . fmap (hcat . punctuate comma . fmap int) . chunk 8 $ xs) <> semi) "foo" [0..18]
10:07:21 <lunabot>  char foo [] = {0,1,2,3,4,5,6,7
10:07:21 <lunabot>                 8,9,10,11,12,13,14,15
10:07:21 <lunabot>                 16,17,18};
10:07:53 <mmorrow> @type writeFile "foo.c" . render
10:07:54 <lambdabot> Doc -> IO ()
10:08:20 <pumpkin> omg <+>
10:08:30 <pumpkin> that isn't the ArrowPlus version is it?
10:08:43 <mmorrow> , '(<+>)
10:08:44 <lunabot>  Text.PrettyPrint.HughesPJ.<+>
10:08:47 <pumpkin> ah :/
10:09:33 <gueux> hi
10:10:08 <gueux> where can I find a haskell logo in vector format
10:10:46 <jeffersonheard> heh.  I just got the reddit layout for april fools...  I'm such a lamer
10:11:22 <vixey> how did I know that was digg :/
10:11:44 <lilac> > (>\=)
10:11:45 <lambdabot>    \\__
10:11:45 <lambdabot>    //\-
10:12:16 <gueux> (I mean the actual logo, of course)
10:12:21 <yitz> jeffersonheard: can i interest you in facial gestures for opera?
10:12:42 <monochrom> Haha "reddigg"
10:12:46 <jeffersonheard> *chuckle*
10:13:12 <dons> they changed the css.
10:13:19 <dons> see. e.g. the python reddit, which looks normal
10:13:23 <pumpkin> I'm looking forward to gpugen being released
10:13:36 <pumpkin> sigfpe's latest tweet told me I'm doing it wrong
10:14:16 <monochrom> Was there any april fool's joke on haskell-cafe?
10:14:40 <skorpan> simon peyton-jones posted one, but i'm not sure if it was to the café
10:14:51 <dolio> Someone forwarded the SPJ koala from haskell@.
10:15:16 <FunctorSalad> how can I get ghc to eliminate pointless runReaderTs?
10:15:39 <FunctorSalad> (if it even is that and I'm not just misusing the profiler)
10:16:02 <monochrom> Oh, it's on the haskell (sans -cafe) mailing list as far as I can tell.
10:16:28 <iago> > length [1..1000000]
10:16:29 <lambdabot>   1000000
10:16:34 <gueux> nobody knows for that logo?
10:16:37 <iago> > foldl' (+) 0 [1..1000000]
10:16:38 <lambdabot>   500000500000
10:16:53 <gueux> the source should be somewhere
10:17:04 <gueux> but I can't find it…
10:17:13 <iago> > foldl' (*) 1 [1..1000000]
10:17:28 <lambdabot>   thread killed
10:17:48 <monochrom> augustss++  slow and lazy animal :)
10:19:06 <skorpan> whose face is it on the koala?
10:20:34 <Arnar> vixey: I added a third one, I think that one is perhaps understandable (this is code for an article, which is why I'm looking for readability :) http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2023#a2026
10:20:51 <vixey> Arnar, what's the article about?
10:22:08 <monochrom> Oh haha the message was by Ketil Malde forging as SPJ!
10:22:16 <Arnar> vixey: its about a Haskell implementation (and SOS) for a system that does authorization by using the STM
10:22:35 <monochrom> skorpan: SPJ's face is on the koala
10:22:37 <Arnar> vixey: we're targetting PLAS'09
10:22:56 <skorpan> the picture was too low-res to figure that out
10:23:22 <vixey> Arnar, it seems like you would build up an action using mapM then run it
10:23:24 <lilac> gueux: did you type that unicode ellipsis yourself, or did some software change that on your behalf?
10:23:48 <vixey> Arnar, what if you did it directly instead, not using mapM
10:24:18 <Arnar> vixey: hmm..
10:25:00 <vixey> if you avoid the reverse that is good too
10:25:59 <Arnar> vixey: yes.. e.g. in the first version I process the list by picking the head off the input and consing the result on the output.. so the reversing happens "for free"
10:26:14 <vixey> what if the source is just [TMIPopElevation,TMIPopElevation]?
10:26:19 <vixey> it's going to cause an error?
10:26:21 <Arnar> that's not allowed
10:26:34 <Arnar> the TMIElevate and TMIPopElevation will always be in pairs
10:26:38 <gueux> lilac: what?
10:27:01 <Arnar> vixey: that's guaranteed by only exporting functions that maintain that..
10:27:38 <gueux> lilac: you mean "…"? that is supposed to do a "..."
10:27:59 <gueux> it is on altgr + . for me
10:28:19 <skorpan> altgr+. gives me ·
10:28:36 <jeffersonheard> ow.  leksah segfaulted on me
10:28:42 <gueux> skorpan: you can change your layout :)
10:28:51 <jeffersonheard> just typing.  minding my own business
10:28:56 <skorpan> gueux: yeah, i know, but can't be bothered :P
10:28:57 <jeffersonheard> not doin' nuffin
10:29:00 <gueux> I use a french adaptation of dvorak
10:29:07 <skorpan> i use swedish dvorak
10:29:23 <jeffersonheard> properly, a friend adaptation of dvorak ought to be saens-saens...
10:29:28 <jeffersonheard> french rather
10:29:31 <jeffersonheard> stupid fingers
10:29:42 <vixey> french fingers??
10:29:43 <skorpan> gueux: how's french dvorak?  does it have -,. at QWE?  (or maybe in france it's AZE, i don't remember)
10:29:50 <zachk> i used dvorak then i noticed most unix commands are easily typeable with one finger from the left hand and one finger from the right hand on a qwerty layout so i went back to qwerty
10:29:53 <gueux> french = friend :)
10:30:01 <Arnar> vixey: a perfect monad for this would be a "Stack".. one with push, pop and peek  :)
10:30:07 <zachk> my right pinky finger grew tired of typing l then s on dvorak :-/
10:30:09 <skorpan> zachk: i've bound "u" to "ls" for that reason :)
10:30:15 <gueux> skorpan: in fact it is not really dvorak
10:30:16 <zachk> ah
10:30:17 <Arnar> vixey: perhaps such a monad exists? :)
10:30:29 <vixey> Arnar, you could probably just go  type Stack a = State [a]
10:30:32 <gueux> it is an adaptation of bépo
10:30:33 <vixey> and then define push pop and peek
10:30:38 <skorpan> zachk: ul for ls -l, ula for ls -la, etc.
10:30:39 <Arnar> vixey: yup..
10:30:44 <zachk> Arnar: just code a stack using a list as the base datatype
10:30:48 <gueux> I'll give you an url
10:31:03 <Arnar> zachk: I'm doing that already (was just thinking aloud) :)
10:31:16 <gueux> skorpan: http://clavier-dvorak.org/wiki/Accueil for the classic bépo
10:31:20 <Arnar> zachk: see bottom of http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2023#a2026
10:31:48 <gueux> skorpan: http://clavier-dvorak.org/wiki/Utilisateur:Legrostdg for my own disposition
10:31:52 <skorpan> gueux: that's not dvorak at all :o
10:31:52 <Arnar> push v = modify (v :)   and   pop = modify tail
10:32:23 <vixey> Arnar, but maybe list isn't the best thing
10:32:39 <Arnar> vixey: no? are you referring to my paste?
10:32:42 <vixey> if elevate and pop come in pairs, maybe they should be like
10:32:48 <gueux> skorpan: :) just in the principe
10:32:59 <vixey> | TMIElevatePop TMILogEntry
10:33:12 <Arnar> vixey: hmm..
10:33:24 <Arnar> vixey: when I say "in pairs" I don't mean consecutively..
10:33:38 <vixey> that's why it's got a TMILogEntry in the middle
10:33:51 <vixey> if they were consecutive, | TMIElevatePop  would be enough
10:33:53 <Arnar> vixey: ah yes, but there might be several TMILogEntries between
10:33:54 <gueux> skorpan: the fn lay is very very good :)
10:34:05 <jeffersonheard> why does my compiler tell me that mzero and mappend are not public methods of Monoid???
10:34:17 <vixey> Arnar, but the idea is that TMILogEntry  would be a tree instead of one instruction thata gets put in a list
10:34:17 <skorpan> gueux: i rarely use it tbh
10:34:26 <jmcarthur> mzero isn't
10:34:32 <skorpan> gueux: what does insécable mean?
10:34:53 <gueux> skorpan: it means unbreakable
10:35:18 <Arnar> vixey: so | TMIElevated Elevation InternalTMILog ?
10:35:20 <jeffersonheard> jmcarthur...  so just mappend?  how to represent the additive identity?
10:35:28 <jmcarthur> jeffersonheard, mempty
10:35:36 <jeffersonheard> ah
10:35:38 <Arnar> vixey: and get rid of TMIPopElevation..
10:35:45 <gueux> (in french you have a lot of unbreakable spaces)
10:35:56 <mmorrow> there are some really amazing videos in the demo section here http://ubietylab.net/ubigraph/
10:36:46 <gueux> (like before ":"";" "?" "!")
10:37:02 <jeffersonheard> yeah, hcange that and now it doesn't whine about either.  how odd
10:38:09 <gnufs> http://hackage.haskell.org/trac/summer-of-code/ticket/1575
10:38:09 <gueux> arg, that's really incredible. it's seem to be impossible to find a vector logo of haskell
10:40:10 <mykelyk> I'm writing a float parser in haskell
10:41:09 <mykelyk> I can have a int: [0-9]+
10:42:09 <Arnar> vixey: ok, for pedagogical purposes I think I'll just do it like this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2023#a2027
10:42:13 <mykelyk> or a float: [0-9]+.[0-9]*e[+-][0-9]+
10:42:28 <vixey> ok
10:42:38 <mykelyk> I'm using parsec
10:43:06 <mykelyk> but i'm using try
10:43:20 <mykelyk> like this:
10:43:30 <mykelyk>             int = concat <$> sequence [sign, body]
10:43:38 <mykelyk>             flt = concat <$> sequence [sign, body, mant, real, sign, body]
10:43:49 <mykelyk>             num =  NumZ <$> read <$> try int <|> NumR <$> read <$> try flt
10:44:36 <mykelyk> Any idea on how skip the try?
10:45:44 <mykelyk> No one?
10:46:08 <Duqicnk> @type (<$>)
10:46:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:49:59 <quicksilver> mykelyk: you probably can't. if it has to backtrack to work you need a try
10:52:54 <mykelyk> quicksilver: it doesn't need to backtrack
10:53:51 <BMeph> Is ((,) a) a type constructor, as well as a value constructor, and if so, is (flip (,) a) valid?
10:54:08 <mykelyk> quicksilver: it read the sign and the digits then if find a dot is a int else is a float
10:55:10 <mykelyk> @type (,)
10:55:11 <lambdabot> forall a b. a -> b -> (a, b)
10:55:13 <quicksilver> mykelyk: that is backtracking.
10:55:32 <quicksilver> mykelyk: because when it gets to the dot it "changes its mind" and decides it a float not an int.
10:55:35 <quicksilver> that's what backtracking is.
10:55:44 <quicksilver> you could change the grammar to something else
10:55:51 <dolio> BMeph: Is flip a type-level function?
10:55:58 <quicksilver> <intportion> [ . <decimalportion>]
10:56:04 <quicksilver> where [] means optional.
10:56:12 <quicksilver> that wouldn't backtrack, but it is technically a different grammar
10:56:49 <vixey> (,) is a type constructor
10:56:53 <vixey> (,) is a value constructor
10:56:56 <vixey> is the same way that
10:57:00 <vixey> 1 is an Integer
10:57:02 <vixey> 1 is a Double
10:57:08 <mykelyk> quicksilver:  yes it need a backtrack of 1
10:57:12 <lilac> (,) is a left-facing nipple constructor
10:57:21 <vixey> basically it's just a notational pun
10:57:27 <mykelyk> quicksilver:  so I shouldn't need a try
10:57:48 <jmcarthur> > flip (,) 5 4
10:57:49 <lambdabot>   (4,5)
10:57:55 <vixey> but it would be wrong to say  1 is an Integer and a Double
10:58:01 <mykelyk> quicksilver:  probably I explain my problem badly
10:58:07 <jmcarthur> but not for types :(
10:58:09 <vixey> so may be misleading to say (,) is a type and value constructor
10:58:14 <quicksilver> mykelyk: it's a backtrack because by the time you've "reached" the "." you have already completed the int
10:58:26 <quicksilver> mykelyk: then you have to backtrack to undo the int.
10:58:41 <quicksilver> mykelyk: why are you so scared of try? backtracking grammars are great.
10:58:46 <quicksilver> although I did show a way to refactor it.
10:58:50 <vixey> you can define type level flip, but you cannot partially apply it
10:58:54 <mykelyk> quicksilver:  you are totally right!
10:59:31 <quicksilver> if all ints ended in ";" instead of "."
10:59:36 <quicksilver> (and consumed the ";")
10:59:39 <quicksilver> then it wouldn't be a backtrack.
10:59:44 <quicksilver> but, that would be a different grammar ;)
11:00:43 <lilac> quicksilver: it would match the same language, though...
11:02:34 <wli> The speed hacks with grammar restrictions and throwing operational junk in the midst of it all are probably unnecessary for most applications. Maybe X-SAIGA (http://cs.uwindsor.ca/~hafiz/proHome.html) is the way to go.
11:03:50 <mykelyk> my grammar isn't fixed
11:04:32 <mykelyk> so quicksilver I can use yours
11:04:49 <wli> mykelyk: It allows grammar building on-the-fly.
11:04:58 <kerlo> Hmm. How can one declare the kind of a type constructor?
11:06:12 <mykelyk> but I don't see a easy way to read integer as integer and float as float
11:07:34 <mykelyk> wli: i'm a student, and i'm using this to learn haskell and parsing
11:07:55 <quicksilver> most parsing is two-phase or more, in practice.
11:08:07 <quicksilver> sometimes we call the first phase 'lexing' and pretend it's something different.
11:08:11 <wli> mykelyk: Never mind. Just do whatever the assignment tells you to.
11:08:29 <quicksilver> it's quite common to fix these little details of numeric syntax in the lexing phase
11:08:35 <mykelyk> wli: ;-)
11:08:44 <quicksilver> then your parsing phase can deal with nice well behaved "literal" tokens.
11:10:50 <mykelyk> quicksilver:  ok so in the end you think is ok to use try in a small litteral in the lexing phase because there is't a serious memory bloat risk right?
11:11:52 <quicksilver> I don't really think it's a big risk either way
11:12:50 <mykelyk> quicksilver:  the risk is real
11:13:13 <mykelyk> quicksilver:  to backtrack a file you have to keep it in memory
11:14:07 <mykelyk> quicksilver:  if your file is a couple of mb this can seriously damage performance
11:14:08 <quicksilver> sure. it's a problem if you expect it to be quite common to have gigabyte files which look like int literals but turn out to be float literals 4 gigabytes into the file
11:14:20 <quicksilver> do you expect gigabye-long numeric literals to be a common problem?
11:14:35 <quicksilver> if so you probably need a clever parser
11:15:17 <mykelyk> quicksilver:  you are of course right
11:16:21 <mykelyk> quicksilver: i simply tried to skip the try till the end
11:16:54 <mykelyk> quicksilver: it was more of an ideological reason
11:17:06 <quicksilver> well I'm sure it's valuable to explore these things.
11:17:19 <quicksilver> I have personally decided to optimise for programmer time first of all
11:17:24 <quicksilver> (write the simplest most expressive parser)
11:17:35 <quicksilver> and optimise it if the parser turns out to be a serious bottleneck in your application.
11:18:02 <wli> quicksilver: Why do you think I scream bloody murder when forced to left factor, pepper try everywhere, etc.
11:18:19 <mykelyk> quicksilver: "premature optimization is the root of all evil"
11:18:33 <mykelyk> quicksilver: agree
11:19:29 <jmcarthur> i think the problem with that often-cited quote is that "premature" can be interpreted to mean different things
11:20:20 <quicksilver> it's actualy quite precise. It means what quicksilver wants it to mean ;)
11:21:10 <jmcarthur> in a sense, it's a tautology, but that is not an interesting interpretation
11:21:37 <lilac> quicksilver: doesn't it mean whatever knuth wants it to mean?
11:21:45 <jmcarthur> well, a tautology given some assumptions, like "premature" means you shouldn't do it yet :P
11:22:06 * lilac prefers the first half of the quote: "we should forget about small efficiencies, say about 97% of the time"
11:22:34 <quicksilver> actually the thing I see most often is the lack of appreciation of bottlenecks
11:22:41 <dolio> It's not necessarily a tautology even then, because there might be other roots of evil.
11:22:43 <jmcarthur> so in that sense, it just says "doing things before you are supposed to is the root of all evil"
11:22:49 <quicksilver> you can improves the speed of one section of your code by 5000%
11:22:55 <dolio> Unrelated to optimization.
11:22:55 <lilac> because 1: it makes it clear we're not talking about large efficiencies, and 2: it makes it clear there are cases where we /should/ care
11:23:00 <quicksilver> but if that section only accounted for 1% of your running time.
11:23:05 <jmcarthur> of course i'm not taking "root of all evil" literally :P
11:23:06 <quicksilver> then that was a waste of effort.
11:23:26 <jmcarthur> meh, the point is it's too ambiguous
11:23:36 <lilac> quicksilver: have you seen the recent Joel On Software post on compile times?
11:23:49 <quicksilver> lilac: no, joel normally annoys me :)
11:24:01 <mmorrow> @remember quicksilver you can improves the speed of one section of your code by 5000%
11:24:01 <lambdabot> It is forever etched in my memory.
11:24:05 <mmorrow> outofcontext++\
11:24:07 <jmcarthur> joel doesn't appeal to my idealistic philosophy, usually :P
11:24:10 <lilac> quicksilver: joel assumes he knows what the bottleneck is and buys faster disks. it makes no difference.
11:24:19 * quicksilver nods
11:24:20 <skorpan> i have two different data types with record syntax.  is there any extension which lets me use the same "accessor name" in both data types?  e.g. data A = A { x :: Int } and data B = B { x :: Int }?
11:24:29 <quicksilver> lilac: where do I sign up to become joel's hard disk supplier ;)
11:24:35 <quicksilver> skorpan: Yes. Don't use it.
11:24:39 <lilac> quicksilver: it would be funny, but we had the exact same situation here only a week before. only in our case it was a new machine plus a ramdisk
11:24:44 <skorpan> quicksilver: because it's dangerous?
11:24:48 <quicksilver> one of the GHC extensions permits
11:24:55 <quicksilver> because you're kidding yourself it's a good idea.
11:24:58 <dolio> mmorrow: You successfully immortalized his grammar mistake, too. Good job.
11:25:00 <quicksilver> what you've done is defin a function
11:25:02 <lilac> quicksilver: only we told our manager that we'd taken measurements and his idea would not work
11:25:06 <quicksilver> x :: A -> Int
11:25:08 <quicksilver> and
11:25:10 <quicksilver> x :: B -> Int
11:25:17 <mmorrow> dolio: when it rains, it pours.
11:25:21 <quicksilver> would you normally try to share the same name between two functions like that?
11:25:23 <quicksilver> I wouldn't.
11:25:32 <quicksilver> why treat record selectors different from other functions.
11:26:02 <quicksilver> as long as field names *are* selector functions, it's inapproprate (IMNSHO) to pun them.
11:26:14 <quicksilver> if field names were something other than selector functions, it would be different, possibly.
11:26:30 <quicksilver> you can consider the solution of using a typeclass to overload 'x'.
11:26:36 <wli> They're canonical projectons in the same manner in which variants' constructors are canonical injections.
11:26:37 <dolio> -XAdHocOverloadingWithoutTypeClasses
11:26:40 <quicksilver> occasionally that might be the right answer.
11:26:48 <skorpan> quicksilver: but in this particular case, these datatypes are parts of an AST...  each data type has a "function body" represented as (JTree t).  making up different selector functions for each of the data types would be quite confusing!
11:27:01 <quicksilver> class HasId x = { id :: x -> Int }
11:27:10 <quicksilver> ^^ this is not a ridiculous idea, possibly.
11:27:14 <quicksilver> so sometimes it might make sense.
11:27:18 <quicksilver> s/=/where/ obviously
11:28:24 <skorpan> quicksilver: i'll look into the typeclass idea, thanks a lot
11:30:20 <skorpan> quicksilver: so if i want to make a class which should be instantiated by stuff which consist of a {, a body (which could be anything), and a }, would this be appropriate?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3183#a3183
11:30:33 <dev31212> hi
11:30:39 <skorpan> or am i enforcing the lcurl and rcurl to be of the same type as the body there?
11:30:46 <dev31212> I have had to deal with some Haskell haters lately.
11:30:47 <dev31212> :p
11:31:18 * dev31212 afk
11:40:48 <FunctorSalad> if a function shows up as taking individual (not inherited) time in the profiler, does that mean that it wasn't inlined?
11:42:34 <Igloo> No
11:43:03 <Igloo> But some optimisations aren't done when profiling
11:43:26 <jeffersonheard> alright... one last leksah quesiton and this one isn't in the doc.
11:44:00 <jeffersonheard> When I create a package, it seems to add my modules both to the exposed and additional unexposed list
11:44:14 <jeffersonheard> resulting in a net 0 modules being built.  And it doesn't seem I have an option to change this.
11:44:26 <FunctorSalad> Igloo: makes sense, it's ~2.5 times slower in the prof
11:44:50 <Igloo> It'll also be slower because it's actually doing the profiling
11:48:44 <dev31212> I am currently using Scite to do my Haskell.
11:48:58 <dev31212> Anyone know of a full featured enivronment ( besides EMACS )?
11:50:49 <jeffersonheard> leksah's working on it, dev
11:51:06 <jeffersonheard> been playing with it today for the first time.   I like the IDE.  Just a few bugs in it, still
11:51:08 <dev31212> Ah ok, I came across that.  I guess its not quite ready though?
11:51:35 <dev31212> cool.  hmm, Ill give it a quick try...
11:51:45 * dev31212 boots up xubuntu
11:51:49 <jeffersonheard> I normally use a vi in a terminal on one monitor and a ghc command line in another terminal in my other monitor
11:52:28 <dev31212> Yeah normally I am on Vista, like now, with Scite and a command prompt...But whenever I have to install cabal packages I have to go into my Xubuntu on virtual box.
11:54:08 <travisbrady> jeffersonheard: that is the one true way
11:54:31 <dev31212> Wow
11:54:39 <dev31212> I just cant get used to developing in Vi
11:54:46 <dev31212> I only use it to look at really large log files
11:54:56 <Botje> that's .. silly
11:55:05 <Botje> less is much better suited for large log files
11:55:12 <dev31212> Less?
11:55:14 <Botje> (because it's lazy, actually)
11:55:16 <Botje> yes, less
11:55:18 <Botje> /usr/bin/less
11:55:25 <dev31212> alrighty
11:55:27 <Botje> any self respecting *nix installation should have it
11:55:32 <dev31212> well youd agree vi is better than PICO
11:55:33 <dev31212> :p
11:55:48 <Botje> only in the hand of someone who knows vi
11:55:59 <Botje> i've been using it for close to ten years now :)
11:56:10 <dev31212> I use linux out of necesity
11:56:13 <dev31212> not because I enjoy it.
11:56:15 <dev31212> thank you very much
11:56:16 <dev31212> :)
11:56:21 <jeffersonheard> ahh, figured it out.  that was nonintuitive
11:56:29 <Botje> i feel handicapped in modeless editors now, but lately i've been playing with emacs
11:56:46 <Botje> and liking it
11:56:48 <dev31212> Komodo is my favorite editor.
11:56:55 <Botje> that's an IDE :P
11:57:01 <jmcarthur> i like emacs for programming and vi for text editing
11:57:01 <dev31212> Well Komodo Edit is an EDITOR
11:57:03 <dev31212> :p
11:57:12 <dev31212> Sheesh.
11:58:23 <gwern> 'Shlomi Fish, acclaimed author of "Mastering mv" and "Mastering rm" has taken the time to sit down with us for an interview on his latest book, "Mastering cat". In this 344 pages-long book, Fish details everything you wanted to know about the UNIX cat command. We decided to have an interview with him to find out more about the book's motivation, content, and philosophy.'
11:59:39 <BMeph> dev31212: To risk sounding silly, 'less' is like 'more', only smaller... ;p
11:59:54 <Botje> and it can scroll up, unlike more :[
12:00:01 <dev31212> heh
12:00:10 <jmcarthur> less can do a lot more than more
12:00:10 <Duqicnk> on my machine less is 3x bigger
12:00:18 <Badger> less is more.
12:00:18 <dev31212> Well vi isnt ideal, granted, but it got the job done.
12:00:19 <jmcarthur> you can do search in it too, i think, among other things
12:00:25 <jmcarthur> i haven't bothered to learn it
12:00:28 <Duqicnk> write your own editor
12:00:33 <Duqicnk> it's not hard
12:00:34 <dev31212> I wasnt aware of less...I spend perhaps 1% of my day on linux to do some server maintenance :p
12:00:35 <Botje> Duqicnk: 4x here >:)
12:01:03 <dev31212> I guess I am not l337 enough to use Vi and Emacs :p
12:01:16 <gwern> less can't do as much as most, though
12:01:48 * BMeph REALLY does not look forward to trying to make 'newtype FlippedPair a b = FP (b,a)' into a Functor...
12:01:49 <Botje> gwern: is it any good as manpage viewer?
12:03:35 <Saizan_> BMeph: trying?
12:04:11 <Duqicnk> do people use yi?
12:04:41 <vixey> BMeph: what's this about
12:05:17 <vixey> I don't know what the point of FlippedPair is since  swap :: (a,b) -> (b,a)   is so easy to write
12:13:14 <Botje> should be in the prelude or Control.Arrow, that one :(
12:15:42 <pumpkin-> mmorrow: I see a mmorrow on twitter but is it you? :o
12:16:24 * wli got his nick juped on twitter. :(
12:18:04 <pumpkin-> yeah :(
12:18:10 <pumpkin-> I think mmorrow may have too
12:34:56 <BMeph> vixey: Sorry, I went to lunch right after that *ACTION*. I'm working on making the other type of a pair to work as a Functor.
12:35:13 <vixey> ? why ¿
12:45:27 <jeffersonheard> alright...  this FRP-unlike library is probably as ready as it's going to get for now.  reddit seems to like it, so I suppose I'll release it.
12:45:52 <pumpkin-> yay
12:46:03 <gueux> sorry to repeat me :(, for those who haven't seen my question, do someone know where I can find a vector version of the haskell logo?
12:46:35 * jmcarthur is also looking for an answer to gueux's question
12:46:50 <jeffersonheard> I think we're all wondering.  shouldn't be that hard to create, but my tablet's at home
12:46:57 <jmcarthur> i suppose it wouldn't be too hard to make a vector with inkscape or something
12:47:03 <jmcarthur> inkscape has a tracing feature
12:47:15 <pumpkin-> isn't the author listed on the voting site?
12:47:15 <jmcarthur> but i would prefer to have an original instead
12:47:27 <jmcarthur> yes. i haven't bothered contacting the author yet
12:47:31 <omnihil> http://darcs.mroot.net/sep07-adhoc/_darcs/patches/20070702084626-a9514-eb30d2e8afd19efd63479054c47832c7628ff36c.gz
12:47:35 <jmcarthur> not an emergency for me
12:47:36 <gueux> but, the actual version must have been done in vector no?
12:47:40 <omnihil> ^^ haskell as svg
12:47:46 <gueux> for me it is :)
12:48:00 <gueux> I need that for tomorrow :)
12:48:07 <codebliss> I'm learning some OOP'ish stuff in haskell and don't totally get typeclasses.
12:48:19 * jmcarthur suggests inkscape's autotrace feature, or whatever it's called
12:48:21 <codebliss> Say I want to make a vector type and be able to add them together.  How would I achieve this?
12:48:28 <kerlo> codebliss: well, they're a lot like interfaces.
12:48:29 <omnihil> the URL I pasted was generated in inkscape.
12:48:33 <jmcarthur> codebliss, type classes are not OOP-ish ;)
12:48:42 <codebliss> Sorry, new =)
12:48:47 <kerlo> To be able to use (+) on your vector type, you'd make your vector an instance of Num.
12:48:49 <codebliss> I just want to learn types, data, etc.
12:48:50 <jmcarthur> the name is misleading
12:49:02 <codebliss> And then what else would I have to do?
12:49:06 <jmcarthur> that's it
12:49:13 <codebliss> Well then
12:49:37 <codebliss> I'm kind of confused, I'll post my code in a bin.
12:49:39 <kerlo> Though the instance declaration has to have definitions of (+) and some other functions on your vector.
12:50:05 <pumpkin-> this is when you realize how ridiculous the Num typeclass is
12:50:15 <jmcarthur> codebliss, admittedly, though, the Num type class could use a redesign. the vectorspace package may provide what you want more cleanly
12:50:20 <kerlo> If I'm not mistaken, you do the same thing when defining an instance of an interface in OOP.
12:50:32 <pumpkin-> the numeric prelude might help too
12:50:48 <codebliss> http://haskell.pastebin.com/m4fc93cca
12:50:53 <Petrosian> Hey.
12:51:05 <codebliss> I don't *need* a vector, I just learn through taking basic ideas and making them
12:51:17 <Petrosian> Is `(+1) x' equivalent to 1 + x, or x + 1?
12:51:24 <jmcarthur> codebliss, to make an instance for Vector it will need to be declared with newtype or data, not type
12:51:30 <jmcarthur> codebliss, type is just a type alias
12:51:31 <Petrosian> Assuming (+) is some just arbitrary binary operator
12:51:34 <gueux> omnihil: thanks :) but where is icons/haskell.svg
12:51:40 <kerlo> Petrosian: x + 1.
12:51:45 <Petrosian> kerlo: Thanks.
12:51:57 <kerlo> > (++"1") "foo"
12:51:59 <lambdabot>   "foo1"
12:51:59 <jmcarthur> codebliss, then you will use an instance declaration in the usual format
12:52:13 <codebliss> Am I doing it wrong?  It works.
12:52:17 <codebliss> I just want good code if I can.
12:53:29 <jmcarthur> codebliss, what kind of vector is this? angle, magnitude, *and* point?
12:53:43 <codebliss> Just messing around =)
12:53:46 <jmcarthur> heh
12:54:14 <codebliss> I was just wondering how to add an addition operator to a basic type.
12:54:22 <kerlo> instance Num Vector where (p1, a1, m1) + (p2, a2, m2) = howeverYouAddTwoVectors; . . .
12:54:31 <codebliss> lol gotcha
12:54:50 <gueux> ok, I got it
12:55:05 <jmcarthur> codebliss, that line of thinking isn't quite right. to be precise, you are just defining addition over vectors, not adding addition to the vector type
12:55:11 <gueux> http://darcs.mroot.net/sep07-adhoc/icons/haskell.svg
12:55:18 <codebliss> So, what should I do then?  =)
12:55:21 <gueux> that is not the good logo :(
12:55:26 <kerlo> Note that to make it an instance of the Num class, you have to define all of the functions in the Num class, including multiplication and absolute value; you can't define (+) without defining (*) and such as well.
12:55:28 <codebliss> I'm just trying to touch a little bit of everything in haskell.
12:55:40 <jmcarthur> codebliss, kind of like in math. addition isn't a part of integers and vectors and such, it's just defined over them :)
12:55:57 <codebliss> Ah.
12:55:59 <kerlo> If you feel like doing that, go ahead and make the instance declaration, like I said.
12:56:21 <codebliss> I just want the best code.  I did it using these basic types because it works.  Now I want to move on and making something proper
12:56:30 <gueux> pumpkin-: where is the voting site?
12:56:53 <codebliss> Ah there is a class keyword
12:56:57 <jmcarthur> i would love to stay and help you more, codebliss, but i have to get back to work
12:57:01 <codebliss> Sorry, I'm used to F# and .net, much different
12:57:09 <jmcarthur> codebliss, yeah the class keyword is to define new type classes
12:57:10 <codebliss> It's fine, thank you for the help jmcarthur =)
12:57:34 <kerlo> @hoogle atan2
12:57:35 <gueux> http://www.reddit.com/r/haskell/comments/85cmz/haskell_logo_voting_has_started/
12:57:35 <lambdabot> Prelude atan2 :: RealFloat a => a -> a -> a
12:57:45 <gueux> ok, it must be that
12:57:51 <kerlo> > atan2 1 (-1)
12:57:52 <lambdabot>   2.356194490192345
12:58:02 <kerlo> > atan2 1 1
12:58:03 <lambdabot>   0.7853981633974483
12:58:22 <pumpkin-> I love the atan2 function
12:58:46 <kerlo> So atan2 takes y, then x, and returns the angle counterclockwise from (1,0).
12:59:29 <c_wraith> atan2 is one of the best trig functions
12:59:49 <c_wraith> Trying to do it manually is quite a pain.
13:00:13 <kiris> is there a speed difference between using IORefs and ST?
13:00:14 <BMeph> vixey: I'm doing it because I want to see how tough it is to do. I want to see how tough it'll be for triples, and others. Also, I want to see it it'll be any help of hindrance in using other types (e.g. State and Writer) that involve processing the first element of a pair. Also, because not being able to do it offends me.
13:01:14 <pumpkin-> kiris: I doubt it
13:01:26 <Heffalump> kiris: there shouldn't be
13:01:30 <pumpkin-> kiris: they're using essentially the same mechanism behind the scenes afaik
13:02:17 <kiris> mmk
13:02:18 <jmcarthur> kiris, they are exactly the same thing with different types :)
13:02:42 <kiris> :D
13:03:45 <gueux> a question concerning the votes for the logo: how many rounds are there?
13:03:59 <pumpkin-> the vote is done
13:04:15 <gueux> and how many logos are kept for the second round
13:04:24 <gueux> pumpkin-: I've seen
13:04:28 <jmcarthur> well, presumably we might get another round of voting for whatever tweaks to the winner we come up with
13:04:42 <jmcarthur> gueux, i think it was winner take all
13:04:52 <kerlo> Some of Num for codebliss's vectors: http://haskell.pastebin.com/m70019fa0
13:05:41 <gueux> jmcarthur: " i think it was winner take all" what do you mean?
13:05:53 <codebliss> Thanks, I've been doing some research and that's what I was going for  =)
13:07:11 <jmcarthur> gueux, only one round. only one winner of the round. none to carry to the next round.
13:07:46 <gueux> jmcarthur: "The votes (for the first round) are in!" http://haskell.org/haskellwiki/Haskell_logos/New_logo_ideas
13:08:07 <jmcarthur> gueux, i think that was meant to refer to the possibility that we later vote on variations of the winner
13:08:08 <gueux> It seems that there is another turn no?
13:08:16 <gueux> ok
13:08:47 <gueux> is it possible to find a vector version of this winner logo? :)
13:09:24 <jmcarthur> gueux, open up inkscape, import the image, use inkscape's trace feature, instant vector :)
13:09:30 <gio1239> does somebody has example of two rule term rewriting system?
13:10:33 <gueux> it is so easy to convert from raster to vector?
13:10:59 <augustss> @seen heffalump
13:10:59 <lambdabot> heffalump is in #darcs and #haskell. I last heard heffalump speak 9m 33s ago.
13:11:10 <jmcarthur> gueux, not in general, but since the logo is so simple, inkscape's algorithms shouldn't have much trouble with it
13:12:24 <Heffalump> augustss: I'm here
13:13:32 <kyagrd> has anyone used base-4 Control.Exceptions ?:
13:14:32 <kyagrd> Control.Exception.catch :: (GHC.Exception.Exception e) =>
13:14:32 <kyagrd>                            IO a -> (e -> IO a) -> IO a
13:14:32 <kyagrd>  
13:14:32 <dons> not on hackage: http://ooxo.org/hubigraph/
13:16:33 <kyagrd> How should I deal with Ambiguios type variable e ... problem? I tried giving type signatures but that doesn't always work getting a rigid type variable error ... especially when using local function definitions or lambda expression as exception handlers
13:17:04 <kyagrd> Or should I just go back to base-3
13:18:20 <dons> kyagrd: --constraint='base<4'
13:19:35 <kyagrd> dons: Thanks, that will work. But I was curious how people use base-4 exceptions
13:21:18 <FunctorSalad> good question :) (found it odd too)
13:22:43 <kadaver> @src foldl1
13:22:43 <lambdabot> foldl1 f (x:xs) = foldl f x xs
13:22:44 <lambdabot> foldl1 _ []     = undefined
13:22:58 <gueux> jmcarthur: it's too hard for me :( the logo seems to be very fuzzy like that
13:24:16 <codebliss> I'm trying to make a custom show for my point type.  This is erroring.
13:24:19 <bavardag1> @src maybe
13:24:19 <lambdabot> maybe n _ Nothing  = n
13:24:20 <lambdabot> maybe _ f (Just x) = f x
13:24:20 <codebliss> instance Show Point where 	show (x, y) =  '(' : show x ++ ", " ++ show y ++ ")"
13:24:28 <bavardag1> @hoogle Maybe
13:24:28 <lambdabot> module Data.Maybe
13:24:28 <lambdabot> Prelude data Maybe a
13:24:28 <lambdabot> Data.Maybe data Maybe a
13:24:46 <monochrom> Hey augustss I like your "slow lazy animal". I am also excited by your embedding BASIC and C into Haskell. Is there any plan on embedding COBOL too? PL/I?
13:24:56 <Botje> codebliss: how is Point defined? show looks fine to me
13:25:02 <jmcarthur> gueux, aw. sorry. i might try it tonight at home
13:25:04 <codebliss> type Point = (Double, Double)
13:25:18 <Botje> codebliss: ah. You can't define instances for type synonyms
13:25:35 <Botje> there is already an instance for (a,b) so show should Just Work(tm)
13:25:38 <codebliss>     Illegal instance declaration for `Show Point'         (All instance types must be of the form (T t1 ... tn)          where T is not a synonym.          Use -XTypeSynonymInstances if you want to disable this.)     In the instance declaration for `Show Point'
13:25:48 <Botje> yep
13:25:59 <Botje> if you use TypeSynonymInstances you can do the above
13:26:24 <codebliss> Is there any way to do it without generating a warning =P
13:26:33 <Botje> yes, use TypeSynoInstances
13:26:54 <codebliss> I'm confused.  I mean without adding compiler options
13:27:10 <gueux> jmcarthur: ok, thanks
13:27:19 <Deewiant> Yaay 6.10.2
13:27:35 <gueux> I wrote to Jeff Wheeler to ask him a vector version of his logo
13:27:47 <kyagrd> I can also use Control.OldExceptions ... but is OldException an instance of the new base-4 exception?
13:28:15 <FunctorSalad> codebliss: expand the synonym manually ;) (but I'd just just the compiler flag)
13:29:00 <FunctorSalad> (type synonyms are really just synonyms, they're not newtype)
13:29:06 <kyagrd> instance GHC.Exception.Exception Control.OldException.Exception
13:29:06 <kyagrd>   -- Defined in Control.OldException
13:29:14 <kyagrd> Oh it is ... now I see how I can work around
13:29:17 <codebliss> Sorry, haskell noob =).  I'm doing this via ghci anywho, it's not really useful code
13:29:19 <codebliss> Just learning
13:30:29 <codebliss> How I expand it manually?
13:31:02 <bavardag1> is there anything other than a monadplus, that gives a default 'zero' value?
13:31:27 <jmcarthur> bavardag1, monoid
13:31:40 <sjanssen> bavardag1: alternatively, Alternative
13:31:54 <bavardag1> kk ty
13:32:16 <FunctorSalad> codebliss: I meant you could do "instance Show (Double,Double)" (but actually that will not work because there already is a Show instance for this type)
13:32:17 <olsner> is there a nice SSL/TLS library slash bindings for haskell? I have a lambdabot running with stunnel now, but it would be nice if I could modify her to do the ssl thing on her own
13:33:11 <bavardag1> sjanssen: I don't suppose that's defined for Ints?
13:33:38 <jmcarthur> @instances Alternative
13:33:39 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
13:33:47 <jmcarthur> @instances Control.Applicative.Alternative
13:33:47 <lambdabot> Maybe, []
13:33:54 <bavardag1> lame.. :P
13:34:04 <jmcarthur> bavardag1, if you want something that can defined for Int, you want Monoid
13:34:09 <jmcarthur> @instances Monoid
13:34:09 <bavardag1> right
13:34:10 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:34:18 <jmcarthur> bavardag1, Sum, for example
13:34:20 <bavardag1> I want something that I can get like 0 for Ints, "" for string, [] for list
13:34:27 <bavardag1> etc
13:34:28 <jmcarthur> that's the one then
13:34:29 <jmcarthur> Monoid
13:34:31 <bavardag1> oh kk :D
13:36:48 <bavardag1> dammit Monoid's not defined for integer
13:36:55 <jmcarthur> bavardag1, use Sum
13:36:56 <bavardag1> is it allowed to define it?
13:37:02 <jmcarthur> Sum Int
13:37:10 <jmcarthur> > mempty :: Sum Int
13:37:11 <lambdabot>   Sum {getSum = 0}
13:37:16 <bavardag1> right
13:37:16 <daf> bavardag1: it's because there are multiple valid defitinitions
13:37:24 <jmcarthur> > mempty :: Product Int
13:37:26 <lambdabot>   Product {getProduct = 1}
13:37:43 <bavardag1> so wait what..?
13:37:54 <bavardag1> I make sure the types I pass are Sum Ints
13:37:56 <bavardag1> rather than just ints?
13:38:04 <jmcarthur> bavardag1, 0 is the identity over addition, 1 is the identity over multiplication
13:38:07 <jmcarthur> right
13:38:10 <bavardag1> ooh kk
13:38:11 <bavardag1> yes
13:38:12 <bavardag1> I see
13:38:18 <jmcarthur> you wrap the Int with Sum and then unwrap it later
13:38:34 <bavardag1> hmm
13:38:47 <wli> 0 is also an annihilator over multiplication
13:38:59 <bavardag1> maybe I am trying to be too general then
13:39:11 <jmcarthur> this allows you to give functions like Data.Foldable.fold different behaviors just by changing the type you pass in
13:39:17 <jmcarthur> :t Data.Foldable.fold
13:39:18 <lambdabot> forall (t :: * -> *) m. (Monoid m, Data.Foldable.Foldable t) => t m -> m
13:39:28 <bavardag1> hmm
13:39:54 <jmcarthur> > getSum . fold . map $ Sum [0..5] :: Int
13:39:55 <lambdabot>   Not in scope: `fold'
13:40:01 <jmcarthur> > getSum . Data.Foldable.fold . map $ Sum [0..5] :: Int
13:40:02 <lambdabot>   Couldn't match expected type `Sum a' against inferred type `[b]'
13:40:07 <FunctorSalad> wli: with conal's unamb it's even a real annihilator ;)
13:40:09 <jmcarthur> > getSum . Data.Foldable.fold $ map Sum [0..5] :: Int
13:40:11 <lambdabot>   15
13:40:21 <jmcarthur> > getProduct . Data.Foldable.fold $ map Product [0..5] :: Int
13:40:22 <lambdabot>   0
13:40:27 <jmcarthur> > getProduct . Data.Foldable.fold $ map Product [1..5] :: Int
13:40:28 <lambdabot>   120
13:40:51 <bavardag1> ooh it seems to be working
13:41:00 <bavardag1> :D
13:41:01 <bavardag1> ty
13:41:04 <jmcarthur> np
13:41:17 <bavardag1> so yeah, Monoid seems to be the right type here
13:42:44 <bvck> Could anyone give me a design pattern or link to a web site having mixed-types in a Set?
13:43:10 <Duqicnk> mixed-types, meaning different types?
13:43:16 <bvck> Yes, please.
13:43:16 <Duqicnk> you'll have to use an existential type
13:43:47 <bvck> Okay. Let me google existential type and see what I find. Thanks.
13:43:59 <Duqicnk> "Set a" can only hold a.  You need to define a to be something like "anything implementing such-and-such typeclass", which is what an existential type is
13:44:01 <FunctorSalad> bvck: or Either if it's just two
13:44:01 <mmorrow> omg ieee floating point encoding/decoding is hellish
13:44:15 <FunctorSalad> mmorrow: unsafeCoerce
13:44:18 <blackh> bvck: The easy way is to use data Element = Type1 Type1 | Type2 Type2 | ...
13:44:31 <bvck> FunctorSalad, more than 2 I am afraid.
13:44:36 <Duqicnk> right, but that's not actually different types, it's a single variant type
13:44:37 <mmorrow> FunctorSalad: after that's over with, you need to actually do the encoding/decoding ;)
13:44:38 <blackh> bvck: This isn't extensible. One extensible way is to use Data.Dynamic
13:44:46 <Duqicnk> but it's often more suitable for a given task
13:44:52 <FunctorSalad> mmorrow: how so? it will directly give you the bits
13:44:56 * jmcarthur recommends bvck's way unless you really can't
13:45:01 <FunctorSalad> (I mean unsafeCoerce from Double to Word64)
13:45:08 <bvck> Duqicnk, exactly (single variant type comment).
13:45:18 <mmorrow> FunctorSalad: e.g. turn (42::CULong) into a CDouble
13:45:44 <jmcarthur> and if you go with existential types you will probably want to also restrict the values to some type class, otherwise there is nothing you can actually _do_ with them
13:45:46 <mmorrow> ghci> toBits (42::CUInt)
13:45:46 <mmorrow> [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0]
13:46:02 <jmcarthur> @hoogle toBits
13:46:02 <lambdabot> No results found
13:46:22 <dolio> You can't hold "anything implementing such and such a type class" in a Set, because Set needs to be able to compare the elements for a total ordering.
13:46:24 <bvck> jmcarthur, thanks. Will keep that in mind.
13:46:27 <mmorrow> ghci> toBits ((f2i(42::CFloat))::CUInt)
13:46:28 <mmorrow> [0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
13:46:33 <FunctorSalad> mmorrow: hmm then I misunderstood the problem
13:46:46 <dolio> You need to tag everything specifically somehow, whether with Dynamic or some sum type.
13:47:06 <lament> if i want to display a bunch of bitmap graphics, with transparency, in real time, is sdl the best option?
13:47:11 <mmorrow> FunctorSalad: it's hellish. apparently i don't yet either, and i've been going at it for an hour. :)
13:47:35 <FunctorSalad> mmorrow: (as in writing the bits of a Double to some program that expects binary Doubles)
13:47:38 <jmcarthur> i honestly think if you need a mixed type set then you probably are doing something wrong
13:47:38 <mmorrow> (endianness is screwing with me, because it's weird for the fp reps)
13:47:52 <bvck> jmcarthur, probably...:)
13:47:55 <jmcarthur> at least, if it required existentials
13:48:08 <jmcarthur> there is nothing wrong with the ADT approach though, as long as it makes sense
13:48:08 <mmorrow> FunctorSalad: exactly. e.g. you have a value from an int register, and you want to stick it in an fp register.
13:48:12 <bvck> I am moving away from imperative programming and expect certain bad habits will die hard.
13:48:29 <mmorrow> FunctorSalad: while preserving the semantic meaning of the value
13:48:31 <jmcarthur> existential quantification is very OO feeling, to me
13:48:35 <mmorrow> e.g. 42
13:49:07 <FunctorSalad> mmorrow: yep, I thought the point was *not* to preserve the semantics but the bits ;) (I guess that's called 'marshalling', not 'encoding')
13:49:08 <monochrom> Yes jmcarthur, that's an important aspect of OO, also an important aspect of abstract types.
13:49:18 <jmcarthur> ex.q. is not necessarily always bad though
13:49:29 <mmorrow> FunctorSalad: i wish..
13:49:33 <jmcarthur> monochrom, yup
13:49:37 <bavardag1> dammit
13:49:43 <bavardag1> I need something that has a succ too
13:49:47 <bavardag1> but Sum doesn't
13:49:48 <monochrom> (OO builds upon abstract types. But little kids have only seen OO and nothing before, and don't know that.)
13:49:50 <jmcarthur> :t succ
13:49:51 <lambdabot> forall a. (Enum a) => a -> a
13:49:58 <jmcarthur> @instances Enum
13:49:58 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
13:50:08 <bavardag1> how can I specify that the type inside the Sum is of type succ...
13:50:10 <bavardag1> bleh
13:50:10 <Gracenotes> I heard you like them ;(
13:50:16 <jmcarthur> you could write one for Sum if you need to
13:50:18 <bavardag1> shame Integer isn't a Monoid :D
13:50:27 <bavardag1> oh kk
13:50:32 <kiris> it is too!
13:50:39 <Gracenotes> well. It was discussed the other day: integers are not monoids, really
13:50:45 <kiris> @hoogle Monoid
13:50:46 <lambdabot> module Data.Monoid
13:50:46 <lambdabot> Data.Monoid class Monoid a
13:50:50 <Gracenotes> integer and * is a monoid. integer and + is a monoid
13:51:03 <bavardag1> but Integer doesn't have an mzero
13:51:05 <monochrom> . o O ( There is a little bit of "real glorious history began after the EngSoc; it's all dark ages before" going on in programming education.)
13:51:06 <Gracenotes> however, a type without an operator is not really a monoid
13:51:12 <olsner> bah, ssl looks hard, seems easier to just trust/use stunnel after all
13:51:13 <kiris> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#v%3ASum
13:51:21 <jmcarthur> bavardag1, mzero is not for monoids though
13:51:23 <kiris> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html#v%3AProduct
13:51:25 <jmcarthur> mempty is
13:51:25 <Gracenotes> Sum and Product somewhat enforce types
13:51:28 <jeffersonheard> alright.  library released.  I think I've done enough doc today
13:51:30 <Gracenotes> and operators
13:51:37 <olsner> but I do have a patch for server password support I can send somewhere :)
13:51:46 <jmcarthur> kiris, he knows Sum is instance of Monoid, but it's not an instance of Enum
13:52:12 <Gracenotes> Sum is really only a wrapper
13:52:20 <Gracenotes> you can't define an Enum for an arbitrary Sum
13:52:29 <jmcarthur> instance Enum a => Enum (Sum a) where...
13:52:57 <Gracenotes> deriving instance Sum Enum
13:52:59 <bavardag1> jmcarthur: mempty?
13:53:02 <bavardag1> so...
13:53:06 <patchwork> Hey all, trying to install ghc on my server, getting this error:
13:53:07 <kiris> yeah, but "Integer isn't a Monoid"..
13:53:08 <patchwork> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3190#a3190
13:53:13 <Gracenotes> > getSum (Sum (+10)) 10
13:53:14 <lambdabot>   20
13:53:15 <patchwork> Any clues?
13:53:24 <bavardag1> maybe I should just specify integer :D
13:53:28 <bavardag1> and just put 0
13:53:33 <bavardag1> I'm writing a brainfuck implementation
13:53:35 <patchwork> file format not recognized...
13:53:45 <Taejo> is it true that every binary language is decidable by circuits of size O(2^n)?
13:53:47 <bavardag1> and I want to make it effectively infinite
13:53:51 <bavardag1> the tape size
13:53:56 <FunctorSalad> jmcarthur: what would you say is the correct solution for keeping a list of renderable-objects then? (using a set of existentials now)
13:54:07 <skorpan> could someone explain this rigid type variable stuff?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3191#a3192
13:54:08 <Gracenotes> bavardag1: infinite lists are good for that purpose
13:54:16 <bavardag1> so I'm doing it that if you 'go off the end' of the tape, you just get values initialised to something sensible...
13:54:19 <bavardag1> Gracenotes: haha
13:54:22 <bavardag1> Gracenotes: I forgot about that
13:54:29 <Gracenotes> bavardag1: zippers might also help
13:54:36 <bavardag1> right
13:54:40 <Taejo> bavardag1: yeah, a zipper over infinite lists is exactly the right thing
13:54:42 <jmcarthur> FunctorSalad, okay, there are valid cases for it
13:54:45 <FunctorSalad> jmcarthur: yes it has an OO feel, but if it's the best solution should we really dislike it just for that ;)
13:54:57 <jmcarthur> FunctorSalad, i rarely see noobs have such cases though
13:55:19 <jmcarthur> FunctorSalad, i agree 100% though. use the best solution possible
13:55:31 <jmcarthur> i just mean be skeptical of existentials unless you are sure
13:55:46 <FunctorSalad> jmcarthur: now that I think of it, the existential probably introduces some overhead though? which might not be optimal for a rendering loop
13:55:49 <bavardag1> kk
13:55:54 <bavardag1> why the zipper exactly?
13:56:01 <jmcarthur> FunctorSalad, it keeps dictionaries with each value
13:56:02 <FunctorSalad> (though in my case that's far overshadowed by the actual drawing)
13:56:11 <FunctorSalad> yes
13:56:26 <Taejo> bavardag1: because it allows you to move along the list, one step at a time
13:56:30 <jmcarthur> bavardag1, zippers keep track of "current location" and allow you to move back and forth
13:56:35 <bavardag1> oh kk
13:56:38 <bavardag1> I'll go look them up
13:56:42 <Taejo> bavardag1: and you get constant time lookup and update at the "focus"
13:56:51 <bavardag1> I'm thinking of zippers as zipWith or something
13:57:16 <Taejo> bavardag1: zippers in general are interesting/tricky, but a zipper for lists is just a pair of lists (things before the focus, and things after the focus)
13:57:22 <jmcarthur> bavardag1, a zipper is a transformation of some data structure
13:57:58 <bavardag1> oh kk
13:58:07 <bavardag1> I think I kinda implemented zipper w/o realising it then
13:58:15 <bavardag1> "data Tape a = Tape ([a], a, [a])"
13:58:20 <yitz> Taejo, bavardag1: only thing is, you can't easily control allocation, so you have to be ok with the interpreter crashing if it fills up memory
13:58:20 <Taejo> exaclty
13:58:25 <bavardag1> *attempted to implement zipper
13:58:34 <bavardag1> oh, well if it's already done.. I'll use that :D
13:58:35 <bavardag1> great
13:58:38 <jmcarthur> data BFZipper = BFZipper [Int] Int [Int]; empty = BFZipper (repeat 0) 0 (repeat 0) -- something like that
13:58:49 <Taejo> yitz: I've never had a BF program that used over a gig
13:58:50 <monochrom> skorpan: I am reading just "class IsBlock" and my eyebrows rise. "body :: a -> t" do you know what it entails?  It is a very strong promise or a very trivial function.  Suppose I have "IsBlock MyType". Then you're saying for any type t, I have method "body :: MyType -> t". Isn't it a bit too magical?  I have body :: MyType -> Int, body :: MyType -> Bool, body :: MyType -> (IO Int -> IO (StateT (Array Int Double) IO FunPtr))..
13:58:50 <monochrom> .  Do you even know what "body" does in all those cases?
13:58:51 <jmcarthur> yeah, Tape is a better name
13:59:20 <yitz> Taejo: bet i could write one
13:59:30 <jmcarthur> i have written one
13:59:39 <jmcarthur> but it was nonterminating
13:59:42 <harovali1> is it possible to position the cursor in the console screen in GHCi and draw an * ?
14:00:21 <Gracenotes> a note about jmcarthur's implementation though, just use [] if you don't want a left end
14:00:31 <mmorrow> harovali1: http://hackage.haskell.org/packages/archive/hscolour/1.12/doc/html/src/Language-Haskell-HsColour-ANSI.html
14:00:48 <Gracenotes> also, you can make both sides empty and expand the list as necessary with a 'right' function (and a 'left' one if you want it)
14:00:49 <skorpan> monochrom: i'm using a typeclass for trying to solve a problem i'm having with many datatypes with many parameters, using record syntax.  essentially, i would like to be able to use "body" as the selector function for all datatypes which have some sort of body (three or so have that now) instead of using a different function for each of them.
14:00:51 <jmcarthur> Gracenotes, ah, yeah. my old bf interpreter was infinite in both directions
14:01:03 <Gracenotes> this is useful if you want to print out exactly the zipper
14:01:07 <yitz> jmcarthur: write one that looks for a zero of the riemann zeta function off of the critical line. that would fill up memory, but it terminates. uh, i think.
14:01:10 <Gracenotes> and nothing else
14:01:15 <bavardag1> so wait.. is there a Zipper inside haskell?
14:01:19 <bavardag1> or do I have to define one?
14:01:31 <Gracenotes> defining one should be fine
14:01:37 <yitz> or not
14:01:44 <FunctorSalad> there's a list-zipper on hackage
14:01:46 <Taejo> Gracenotes: also if you want to save state (distributed brainfuck, anyone?)
14:01:55 <bavardag1> hehe
14:02:12 <Gracenotes> well, everything is *too* dependent on state for distributed use, I think :P
14:02:40 <Gracenotes> unless you make non-deterministic brainfuck, after the Turing Machine variation, and distribute branches appropriately >_>
14:02:43 <yitz> bf-stm anyone?
14:02:51 <bavardag1> so if I just make my 'Tape' then use infinite lists
14:02:52 <bavardag1> all should be fine
14:03:04 <Gracenotes> yes. Although may not for printing it out
14:03:08 <mmorrow> , [$bf|.+[.+]|] {-the only one-liner i know-}
14:03:10 <lunabot>  luna: No instance for (GHC.Show.Show
14:03:18 <mmorrow> , [$bf|.+[.+]|] ""
14:03:19 <monochrom> skorpan: Then you need MPTC = multiple parameter type class.  class IsBlock a t | a -> t where body :: a -> t; instance IsBlock (JTree t) (JFunBody t) where body = fundeclbody.  Each "a" controls what "t" is allowed.
14:03:19 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
14:03:38 <skorpan> monochrom: i see... that makes sense. thanks!
14:03:49 <Gracenotes> , ([$bf|.+[.+]|] []) :: [Int]
14:03:50 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
14:03:54 <mmorrow> , [$bf2|.+++++++.>>++|] ""
14:03:55 <lunabot>  ("\NUL\a",(2,Mem (fromList [(0,7),(2,2)])))
14:04:12 <mmorrow> a neat thing with maps, is you can just do
14:04:30 <mmorrow> maybe 0 id (M.lookup ptr m)
14:04:48 <mmorrow> so you get infinite memory for free by lying :)
14:05:06 <bavardag1> I'm thinking I'm going to 'extend' brainfuck :P
14:05:11 <bavardag1> allowing for multiple tapes
14:05:15 <bavardag1> and such funsies
14:05:24 <mmorrow> bavardag1: that would be cool
14:05:41 <mmorrow> i've wanted to add the ability to insert literal numbers too
14:05:44 <bavardag1> but first I'll aim small :P
14:05:47 <luite> using a compiler to compile a multiple tape brainf*ck to single tape?
14:05:52 <bavardag1> mmorrow: would be nice..
14:05:57 <mmorrow> .+...{2874930580}>>,
14:05:59 <mmorrow> etc
14:06:13 <Gracenotes> luite: a set number of tapes, I take it?
14:06:15 <lament> bavardag1: please don't extend brainfuck
14:06:17 <mmorrow> it would do wonders for usability
14:06:26 <yitz> mmorrow: aw at that point you might as well use a real programming language
14:06:26 <bavardag1> lament: well I won't call it brainfuck ofc
14:06:29 <lament> bavardag1: only about 1000000 people have done it so far, usually in remarkably repetitive and uninventive ways
14:06:33 <bavardag1> bleh
14:06:38 <bavardag1> but I want to join them :(
14:06:38 <bavardag1> :(
14:06:51 <mmorrow> yitz: no way! just when it starts to get non-tedious..
14:06:51 <Gracenotes> luite: if so you can just use 2n-tuples for each part of the state, binary markers, etc.
14:06:52 <bavardag1> dw, I'm not going to shout about it from the rooftops
14:06:56 <lament> mmorrow: been done! many times.
14:06:57 <bavardag1> it's just for my own playing
14:07:07 <mmorrow> lament: (+1)
14:07:39 <lament> also, #esoteric for in-depth discussion of these issues
14:07:46 <mmorrow> ooh
14:07:52 <Gracenotes> oh? :X
14:07:59 * wli would use a real programming language if he could figure out module systems.
14:08:10 * mmorrow joins esoteric
14:08:50 * yitz thinks bavardag1 should write the bf compiler in bf
14:09:12 <bavardag1> hehehe
14:09:12 <dolio> That's been done.
14:09:25 <bavardag1> fortunately, I know nothing of compilers
14:09:30 <bavardag1> I wouldn't know assembly if it bit me
14:09:44 <bavardag1> is there an established way to show the first few items of infinite lists?
14:09:47 <bavardag1> oh dammit nm
14:13:20 <skorpan> what was the extension called which lets me have different datatypes with the same selector function names?  e.g. data A = A { x :: Int } and data B = B { x :: Int }?
14:14:06 <skorpan> someone told me this earlier today, but i forgot
14:14:15 <dolio> DisambiguateRecordFields?
14:14:47 <skorpan> yes, maybe
14:15:37 <skorpan> no, doesn't seem to help
14:15:52 <bavardag1> how do I say this is an instance of show if a is an instance of show
14:17:06 <augustss> bavardag1: what is 'this'?
14:17:07 <gp> hey is there a lambdabot on here?
14:17:20 <bavardag1> augustss: ata Tape a = Tape ([a], a, [a])
14:17:20 <edwardk> skorpan: it exists?
14:17:24 <bavardag1> *data
14:17:33 <bavardag1> I want that to be an instance of Show if a is also
14:17:36 <dolio> skorpan: That's the right one, but it's a bit more limited than I thought.
14:17:40 <c_wraith> @faq can haskell reveal the existance of lambdabot?
14:17:40 <lambdabot> The answer is: Yes! Haskell can do that.
14:17:45 <augustss> bavardag1: deriving (Show)
14:17:53 <wli> bavadag1: heh, ATA tapes are about that, yeah.
14:17:56 <skorpan> edwardk: apparently so
14:18:04 <gp> lamdabot: help?
14:18:10 <dolio> skorpan: It only works when you're using record syntax like "Con { field = whatever }".
14:18:18 <skorpan> dolio: i see
14:18:20 <bavardag1> augustss: nono, I want to do it myself
14:18:21 <dolio> Not for selectors, and not based on type.
14:18:23 <augustss> bavardag1: or if you want to write the instance yourself: instance (Show a) => Show (Tape a) where ...
14:18:24 <gp> lambdabot: help?
14:18:28 <bavardag1> oh kk ty
14:18:32 <bavardag1> augustss: that's the one :D
14:18:34 <edwardk> hrmm
14:18:34 <skorpan> so there's really no way of doing what i want to do?
14:19:02 <edwardk> ah, i wonder if it'd be willing to allow them with an explicit type annotation in the latter two scenarios it describes
14:19:16 <augustss> skorpan: you have to have your records in different modules and use qualified names.
14:19:33 <dolio> skorpan: Apparently not. Are you giving explicit types already?
14:19:47 <skorpan> dolio: no
14:19:55 <dolio> I'd try that, at least.
14:19:55 <skorpan> augustss: okay, then
14:20:07 <skorpan> dolio: maybe i misunderstood, what do you mean by explicit types?
14:20:16 <bavardag1> YAY IT WORKS
14:20:20 <skorpan> i have a parameterised datatype
14:20:21 * bavardag1 jumps up and down with joy
14:20:30 <skorpan> data A t = A { x :: B t }
14:20:55 <augustss> @seen heffalump
14:20:55 <lambdabot> heffalump is in #darcs and #haskell. I last heard heffalump speak 1h 8m 31s ago.
14:20:56 <dolio> I mean make sure it knows it's dealing with an A t.
14:21:08 <dolio> I still don't think it'll work, though.
14:21:14 <wli> data T t = A { x :: t } | B { x :: t } ?
14:21:16 <skorpan> dolio: i think so, it's a long module
14:21:29 <skorpan> no wli, B would be a separate datatype
14:21:35 <dolio> But theoretically something like "foo k = k { x = whatever }" is unambiguous if you give a signature "foo :: A t -> A t".
14:22:06 <dolio> Same with selectors, but I doubt that'll work, either.
14:22:17 <skorpan> maybe i'm just better off just giving the selectors different prefixes or something...
14:22:42 <augustss> skorpan: prefixes, or stick them in little modules
14:22:57 * wli was thinking of situations where it might have more trouble.
14:23:18 <skorpan> augustss: having more modules wouldn't be appropriate, i'd like it to be as compact as possible. it's for a yi mode, btw.
14:23:26 <augustss> 6.10.2 is out.  Is that a joke?
14:23:56 <dolio> No. I just installed it.
14:24:00 <Hunner> :o
14:24:08 <dolio> Yet another April 1st release, it seems.
14:24:09 <tristes_tigres> ghc 6.10.2 released on 1 april. What's up with that ? you install it, but GHCi prompt says, "fooled you" ?
14:24:31 <iago> tristes_tigres, april's fool day
14:24:41 <Deewiant> No, it works fine, I installed it :-P
14:24:43 <Botje> "program doesn't typecheck, continuing anyway"
14:25:10 <vininim> AFD monad is the new feature
14:25:38 <dolio> skorpan: Apparently that extension only solves things if your records are declared in different modules, too.
14:25:44 <dolio> It's a lot less fancy than I thought. :)
14:25:47 <Deewiant> Too bad extralibs don't get updates in minor releases, I was mostly waiting for a containers update :-/
14:25:51 * wli screams trying to get a grip on the sequent calculus stuff for module systems.
14:25:57 <augustss> So now I just have to wait for gtk2hs to be released as well.
14:26:13 <skorpan> dolio: aw snap!
14:26:28 <Deewiant> Now I'm waiting for 6.12 then. Oh well.
14:27:12 <tristes_tigres> does it have parallel garbage collection ?\
14:27:16 <edwardk> augustss: did the patched versions i dropped on hackage this morning fix your 6.10.2 issues?
14:27:33 <augustss> edwardk: dunno, I've not tried yet.
14:28:01 <Deewiant> tristes_tigres: Yes.
14:28:28 <Deewiant> Or, depends on what exactly you mean, it can use multiple threads but it still pauses the program while GC'ing
14:29:44 <tristes_tigres> deewiant: it pauses all threads ?
14:29:51 <Deewiant> Yes, AFAIK
14:31:15 <augustss> tristes_tigres: yes
14:31:59 <augustss> you'll still get a noticable pause at a major collection.
14:32:54 <tristes_tigres> augustss: the parallel GC is a temporary kludge, then?
14:33:08 <dancor> should i put class Lol in Control.Lol ?
14:33:32 <augustss> Well, not really.  It's a different thing from having mutator and collector running at the same time.
14:34:12 <tristes_tigres> dancor: and rofl, too
14:34:13 <augustss> tristes_tigres: You want that too, but you also want several CPU doing collection.
14:34:23 <dancor> controfl
14:34:30 <augustss> And now we have the latter.
14:34:41 <dancor> i don't know what Control means
14:34:54 <wli> augustss: Like gang scheduled mutators and collectors?
14:34:56 <tristes_tigres> augustss: it's for future releases ?
14:35:28 <augustss> tristes_tigres: I hope so, but nobody has done the work yet.  It's very tricky to make efficient.
14:35:39 <kyagrd> In GHC 6.10.2, NoBuffering on stdin finally works!!
14:36:17 <kyagrd> on Windows of course, it was working on Unix/Linux
14:41:44 <travisbrady> what is meant by incremental fold?
14:51:42 <dcoutts> augustss: is your thesis online anywhere? I've not found it with a cursory search. I've noticed it cited a couple times for the first description of the case of case transformation.
14:52:20 <augustss> dcoutts: No, it's not online.  Unless someone has scanned it.
14:53:04 <dcoutts> augustss: that's a shame, I don't expect it's in the Bodlean Library either
14:53:54 <augustss> dcoutts: Oh, I don't know.  I sent many copies around the world. :)
14:54:05 * dcoutts will check tomorrow
14:54:09 <dcoutts> augustss: thanks
14:54:30 <dcoutts> stream fusion relies crucially on case-of-case
14:54:57 <dcoutts> and the issues with duplication in case-of-case explain the duplication in composing stream functions
14:57:36 <ErhardtMundt> does anyone know how to use haxml?
14:58:44 <dolio> travisbrady: Looking at the original article, it looks like it's annotating a data structure with the value of folding from that point when you build it.
14:59:08 <dolio> Which potentially reduces duplicate computation of such things if you're sharing pieces of your data structure.
14:59:08 <A1kmm> Hi,  does anyone know why "data (QuadMember (a n w)) => QuadTree a =" gives me errors about n and w not being in scope in ghc 6.8.2 (without any extensions enabled)?
14:59:23 <vixey> don't use this weird  (QuadMember (a n w)) =>  thing
14:59:43 <travisbrady> dolio: hmm, i'll try to wrap my mind around that
14:59:49 <A1kmm> vixey: I want to put the QuadMember typeclass constraint on the types.
14:59:59 <vixey> Alkmm: let type inference do it
15:00:03 <A1kmm> I have "  class (Ord n, Ord w) => QuadMember a n w where"
15:00:31 <ErhardtMundt> i need to serialize an xml file and take it as a string
15:00:36 <A1kmm> and there is no way for the type of n and w to be inferred correctly in general without the typeclass explicitly specifying that.
15:02:04 <Gracenotes> if you have a constraint that's required for functionality, it has to be everywhere. of course, you could use existential quantification, although that comes with its own bag of issues.
15:02:11 <dolio> travisbrady: So for lists, you pick some list shape algebra (r * (a -> r -> r)), and then [] is not just an empty list, but stores the r, and h : t has not just an element and a tail, but the value of foldr f z (h : t), where f and z come from the list shape algebra.
15:02:44 <travisbrady> dolio: ohhhhh, interesting and sounds pretty useful actually too
15:02:59 * edwardk1 arches an eyebrow at the mention of algebras
15:03:18 <vixey> does anyone know what the hoare monad for Parser s t = [s] -> [(t, [s])] is?
15:03:34 <vixey> list of successes parser monad
15:03:41 <dolio> Then I guess if you want "foldr f z (e : l)" and "foldr f z (e' : l)", it only has to compute "foldr f z l" once instead of twice.
15:03:58 <A1kmm> Gracenotes: I think that the constraint is everywhere (so far)... and the compiler still gives me an error, although I don't really know why, it looks valid according Haskell98.
15:04:09 <edwardk1> vixey: it'd have pre and post conditions on [s], which is playing the role of your heap for hoare purposes.
15:04:10 <Axman6> A1kmm: putting class constraints on types is usually a bad idea
15:04:48 <Axman6> mainly because it if you want to put type signatures on functions, you always have to copy those type constraints, even if they're not necessary for the function
15:04:55 <vixey> oh this is way too difficult
15:05:18 <Gracenotes> (in this case, don't put constaints on the typeclass; put them on the polymorphic type variables. that would be the solution, although rather limited if you want to implement typeclasses that have kinds of 2 or higher)
15:05:22 <A1kmm> Axman6: My full data definition looks like   data (QuadMember (a n w)) => QuadTree a =
15:05:24 <A1kmm>       QuadTree { qroot :: QuadNode a,
15:05:26 <A1kmm>                  nmin :: n, nmax :: n,
15:05:26 <Axman6> like show :: (Ord a, Ord w, Show n, Show w) => Foo a w -> String
15:05:28 <A1kmm>                  wmin :: w, wmax :: w
15:05:28 <edwardk1> vixey: ?
15:05:29 <tristes_tigres> vixey: you mean it's to hoary ?
15:05:29 <A1kmm>                }
15:05:41 <A1kmm> Axman6: So I'm not sure I have any choice there.
15:05:59 <vixey> there's no way I could do this, I have to try something easier
15:06:08 <Gracenotes> data QuadTree a n w = QuadTree (QuadNode a) n n w w
15:06:14 <edwardk1> vixey implementing it in coq or something?
15:06:22 <Gracenotes> and then wherever you use QuadTrees, require that the variables are QuadMembers
15:06:22 <vixey> edwardk1: that would be good yeah
15:06:23 <vixey> ideal
15:06:41 <Gracenotes> A1kmm: a hacky solution, but probably the best way to do it with typeclasses.
15:06:45 <ErhardtMundt> is there any gtk2hs channel?
15:06:59 <Gracenotes> it sounds like you have some functional dependencies going on too
15:06:59 <saml> i doubt
15:07:21 <ErhardtMundt> mmh
15:07:29 <McManiaC> @pl \x -> putStrLn $ show x
15:07:29 <lambdabot> putStrLn . show
15:07:32 <McManiaC> >.<
15:07:44 <dcoutts> ErhardtMundt: no, but several people here know about gtk2hs, and there's the users mailing list
15:07:44 <edwardk1> vixey: take the ynot stuff and strip the explicit tactics for working with the contents of the heap and replace the heap with a list of successes
15:07:51 <saml> ErhardtMundt, http://www.haskell.org/gtk2hs/development/#mailing_lists
15:08:26 <ErhardtMundt> dcoutts: how may i take the glade xml structure from a string instead of opening a file?
15:08:43 <edwardk1> vixey: i'll warn you, this stuff _is_ hard, which is why the ynot folks after all that proving just have a tiny little web app or two with a simple list-based datastore
15:09:16 <edwardk1> and the resulting proofs are very monomorphic, any implementation change and almost all of the scaffolding shears as far as i can tell
15:09:23 <dcoutts> ErhardtMundt: I think currently that's not possible. If you need it, there may be an extra api that we could bind.
15:10:39 <edwardk> chlipala put together a bunch of tactics for solving the heap pre-post condition stuff, but I got the impression that its not an environment i want to live and work in ;)
15:11:34 <vixey> edwardk: I agree this stuff is hard! :p
15:12:12 <dcoutts> ErhardtMundt: there's the C function glade_xml_new_from_buffer which isn't currently bound. You could probably contribute a patch to bind it fairly easily.
15:13:07 <ErhardtMundt> dcoutts: okay, i'll try to work on it
15:13:20 <ErhardtMundt> thank you :)
15:13:50 <kadaver> can g++ handle lambdas?
15:15:07 <ErhardtMundt> i leave now
15:15:11 <ErhardtMundt> good night
15:15:16 <vixey> nn
15:15:17 <edwardk> kadaver: at last check there was a spin off compiler that was working on it trying to see if they could integrate the changes back into mainline, but simply put, not yet
15:19:27 <vixey> edwardk: I hope it's no inaccessibly
15:19:30 <vixey> not*
15:19:48 <vixey> hard to know if there are some big gaps in what I know
15:21:00 <kadaver> how many LOC was the OS-kernel written in haskell?
15:21:02 <kadaver> was it using a lot of FFIs?
15:25:34 <edwardk> vixey: have you talked to smerdyakov about it?
15:25:42 <vixey> no
15:25:48 <vixey> he's never on anymore either
15:25:51 <edwardk> ah
15:25:58 <tomh> isnt he banned here
15:26:05 <vixey> tomh don't think so
15:26:07 <edwardk> tomh: yeah, but i let him on ##logic
15:26:15 <tomh> ok
15:26:25 <tomh> he was always a dick to people in #startups
15:26:31 <edwardk> yeah
15:26:38 <vixey> so moving on...
15:27:22 <edwardk> i'll admit he's probably the reason the ##logic channel has frozen at its current size, but he does know a lot about the topic, so personalities are a trade off each community needs to decide how to deal with
15:29:48 <tomh> yeah he is super smart
15:30:20 <tomh> i wish i was that smart
15:30:33 <monochrom> super-smart people tend to be impatience with the rest of us.
15:31:18 <monochrom> I know because I too am impatient with people who take more than five minutes to fill out the truth table of classical implication. :)
15:31:42 <vixey> I can take much longer than five mins complaining about truth tables :p
15:32:14 <monochrom> Oh, more to the point, I'm impatient with people who take more than five minutes to see they're making very elementary type mistakes.
15:32:14 <tomh> i am also impatient with myself if i cant prove this stupid equality of types within 5 min :/
15:32:32 <vixey> tomh: which one?
15:32:43 <tomh> oh its some school excersise
15:33:01 <vixey> yes?
15:33:07 <tomh> http://www.cs.uu.nl/wiki/pub/Afp/Assignments/Assign7.pdf if you really want to know :P
15:33:13 <tomh> first question
15:33:16 <monochrom> "Hi I'm writing f xs = xs : xs  why is it saying infinite type?"  <--- I'm impatient with this kind.
15:33:16 <tomh> if you are bored :)
15:33:35 <vixey> Prove B Int |- A (Maybe (Maybe Int)) and ∅ |- A (Maybe [ Bool ])
15:33:41 <vixey> no clue what that's about
15:33:50 <edwardk> monochrom: hah, i still make those every once in a while, they are just usually buried in the middle of something horrifying
15:34:02 <vixey> tomh: this is some sick Haskellified version of Prolog
15:34:02 <tomh> vixey: thought you was one of the haskell pro's here :p
15:34:10 <kadaver> so how do you bootstrap ghc on a new OS, like if I write my own kernel?
15:34:31 <tomh> vixey: what do you mean, it is valid haskell
15:34:56 <tomh> you just have to say that if you have an type B Int it is also A (Maybe(Maybe int))
15:35:05 <blackh> kadaver: It can be done. I can't describe it briefly though.
15:35:30 <thoughtpolice> dons: ping?
15:35:34 <Duqicnk> ah A and B are clases
15:35:43 <tomh> yeah
15:35:47 <blackh> kadaver: Well, I can, sort of: You have to copy generated C files from one platform to another to get your bootstrapping compiler.
15:36:04 <lament> is there an SGF reader in Haskell?
15:36:06 <Duqicnk> is this ugrad or grad?
15:36:11 <dolio> Hey, I've seen this assignment before, I think.
15:36:25 <tomh> duqicnk: before i answer, what do you think this level is?
15:36:45 <Duqicnk> no idea, i do not know uu.nl
15:37:00 <dolio> I remember question 2.
15:37:07 <tomh> just to get an idea how my studie matches up against others :)
15:37:12 <tomh> well it is masters course
15:37:23 <tomh> dolio: yeah thats the easiest one from it
15:37:35 <Duqicnk> okay
15:37:47 <dolio> tomh: Heh, it wasn't for the last person to show me this assignment. :)
15:37:58 <monochrom> You can likely write a program to do some of the homework for you.
15:38:12 <Duqicnk> won't GHC do it?
15:38:14 <Duqicnk> if you have the right output
15:38:15 <tomh> hehe, well i need to be able to do it myself
15:38:25 <tomh> else i will get slaughtered at the exam
15:38:58 <tomh> which i will anyway
15:39:08 <monochrom> I have an on-going back-burner project of writing javascript webpages to do some undergrad homework.
15:39:18 <Duqicnk> what are (super) and (inst)?
15:39:51 <tomh> two rules
15:40:38 <dolio> Super is probably "class A a => B a leads to B a ||- A a", or something of that sort.
15:40:49 <Gracenotes> supa, girlfriend
15:41:01 <tomh> dolio: correct
15:41:05 <Duqicnk> wouldn't it be the other way 'round?
15:41:12 <tomh> no
15:41:26 <dolio> And inst "instance A T leads to Phi ||- A T".
15:41:39 <Duqicnk> ohh
15:41:45 <Duqicnk> class A a => B a , not instance A a => B a
15:41:46 <Duqicnk> got it
15:41:50 <Botje> don't you mean |= ?
15:41:59 <monochrom> Phi||-Wadler
15:42:04 <Botje> :p
15:42:25 <Botje> "Cannot deduce instance Wadler given context Phi"
15:42:31 <tomh> dolio: you found those on the slides? :)
15:42:32 * jmcarthur wishes he had fun homework like that
15:42:36 <eu-prleu-peupeu> hi
15:42:43 <dolio> tomh: I just guessed them.
15:42:45 <ddarius> Φ∨¬Wadler
15:42:46 <Duqicnk> how much time do you have for this set?
15:42:54 <tomh> 1 week
15:43:03 <tomh> each week we get a set of these
15:43:05 <ddarius> jmcarthur: Give yourself some.
15:43:46 <tomh> it costs me around 12 hours avarage to solve them all properly, but i suck
15:43:50 <vixey> doesn't look much fun to me
15:43:54 <tomh> it isn't
15:43:57 <vixey> hahaha
15:44:00 <tomh> well some are :P
15:44:03 <jmcarthur> vixey, more fun than design patterns
15:44:33 <ddarius> What could be more fun than the Composite Pattern or the Template Pattern?
15:44:44 <Duqicnk> my favorite is the Singleton Pattern
15:44:47 <tomh> atleast i know those :)
15:44:49 <Duqicnk> why use 1 line of code for a global when you can use 30
15:44:54 <vixey> or  Boilerplate pattern :p
15:45:00 <monochrom> The Arrow Pattern.
15:45:08 <Duqicnk> bang pattern
15:45:15 <monochrom> You win.
15:45:23 <Duqicnk> i lost
15:45:28 <Botje> pffrt.
15:45:40 <Botje> you can do everything with a Pattern factory pattern.
15:45:44 <cognominal> what is an .hsc file? it does look like a .hs file. So what is the difference?
15:45:48 <jmcarthur> http://paste.lisp.org/display/44556
15:46:16 <Duqicnk> google: hsc file haskell
15:46:20 <travisbrady> cognominal: http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
15:46:54 <Botje> jmcarthur: race condition in asf::getInstance! ;)
15:47:14 <kadaver> can you invert Data.Map easily?
15:47:32 <cognominal> travisbrady, thx for opening the doc at the right page
15:47:51 <jmcarthur> Botje, you studied it too long :P
15:48:15 <kadaver> i guess toList flip args works
15:48:23 <travisbrady> cognominal: if you'd like to interface with some C code you write a hsc file which is the spec hsc2hs uses to hook everything together
15:48:47 <Botje> jmcarthur: i spent two hours discussing the evils of the singleton pattern somewhere else, thought i'd check :)
15:49:00 <jmcarthur> heh
15:49:58 <jmcarthur> of course, the point is that is considered good, enterprisey code. even the race condition is common
15:50:19 <Duqicnk> this is what happens when you pay programmers by # lines of code
15:50:25 <Botje> yeah
15:50:44 <Botje> i was surprised to learn twitter uses scala now for its backend
15:51:23 <Duqicnk> apparently scala is the new hotness
15:52:10 <Botje> if we ween enough people off the OO-drug, twitter 3.0 will be haskell!
15:52:45 <tomh> Duqicnk: you know some scala?
15:52:48 <ddarius> What's wrong with OO?
15:52:48 <Duqicnk> nope
15:52:51 <Duqicnk> OO is nice
15:52:57 <Duqicnk> the best languages are object-oriented and functional
15:53:11 <Duqicnk> except for haskell ofc
15:53:14 <tomh> which do you think is best
15:53:15 <Duqicnk> which is just too cool to need OO :)
15:53:25 <Duqicnk> i like python, i'd probably like scala
15:53:30 <Duqicnk> i'd probably like C++ a lot more if it had a real lambda
15:53:40 <tomh> i like python too
15:53:44 <pjb3> Duqicnk: What other languages besides Scala are OO + Functional?
15:53:50 <tomh> c#
15:53:51 <monochrom> ocaml
15:54:01 <tomh> f#
15:54:08 <kadaver> how do you pronounce $in haskell?
15:54:15 <Duqicnk> python
15:54:17 <Botje> you don't :)
15:54:17 <Duqicnk> ruby
15:54:20 <sm> newspeak
15:54:25 <tomh> erlang has some OO ?
15:54:25 <monochrom> dollar
15:54:27 <Duqicnk> java (sort of)
15:54:34 <pjb3> Oh, I didn't realize everything with lambda is considered functional
15:54:36 <jmcarthur> i think C# is only barely passable as functional
15:54:37 <MyCatVerbs> kadaver: "apply to", or "of", or just don't.
15:54:41 <jmcarthur> python ruby and java, no way
15:54:46 <Duqicnk> pjb3, i consider anything with first-class functions 'functional'
15:54:49 <Duqicnk> i thought that was the standard definition
15:54:51 <monochrom> "take n $ putStrLn 5"  take five dollar putStrLn five
15:54:52 <Botje> ddarius: I believe OO experience shapes the mind towards objects
15:54:56 <tomh> jmcarthur: c# has lots of functional programming features
15:55:00 <Botje> which leads to imperative code
15:55:01 <ddarius> Botje: So?
15:55:04 <Botje> which leads to suffering
15:55:10 <jmcarthur> tomh, but they are afterthoughts. c# is primarily an OO language
15:55:15 <Duqicnk> ofc functional doesn't imply things like strongly or statically typed, pattern matching, pure, etc.
15:55:22 <pjb3> tomh: what does it have besides lambda?
15:55:26 <tomh> jmcarthur: yeah true
15:55:34 <jmcarthur> i'd say C# is one of the more bearable OO languages precisely because of its functional features though
15:55:35 <tomh> pjb3: the new linq thing
15:55:45 <Duqicnk> python doesn't even have a real lambda and it's still functional
15:55:47 <jmcarthur> pjb3, it actually has true closures, for one
15:55:48 <kadaver> im gonna name my kids to System F and lambda
15:55:51 <Duqicnk> you just use nested defs
15:55:54 <pumpkin-> python is functional?
15:55:58 <pumpkin-> I hear people say that a lot
15:56:01 <jmcarthur> python is FAR from functional
15:56:08 <pumpkin-> that's typically my reaction
15:56:11 <tomh> it has some functional programming features
15:56:14 <MyCatVerbs> Duqicnk: going straight from "has first-class functions" to "is a functional language" is probably a bit too permissive. That definition even allows, for example, Prolog with the call/1 predicate.
15:56:17 <orbitz> pumpkin-: maybe they mean 'functionl as in it works'
15:56:19 <pumpkin-> but I'm curious what makes people say it is functional
15:56:21 <jmcarthur> in fact, doesn't guido intentionally try to keep it that way?
15:56:22 <pumpkin-> lol :P
15:56:24 <ddarius> I think if you ask Guido, he will say that it is definitely not.
15:56:31 <monochrom> C♯ minor is very cool
15:56:35 <Duqicnk> so what's the point of having a bigger and more subjective definition?
15:56:55 <Duqicnk> you can get people to agree mostly on whether functions are first class
15:57:05 <ddarius> MyCatVerbs: In many regards, Prolog is closer to "functional" languages than, say, C#, Lisp, Python.
15:57:09 <Duqicnk> you'll never get them to agree on these fuzzier 'is it functional *enough*' concepts
15:57:11 <MyCatVerbs> Duqicnk: for one thing, you want an idea of what styles are *comfortable* to program in, rather than merely possible.
15:57:22 <Duqicnk> i do lots of FP in python, it's comfortable enough
15:57:32 <pumpkin-> Duqicnk: I'd say functional is more about how people typically program something than the language itself... you can write imperative haskell and you can write functional ruby
15:57:38 <Duqicnk> yes that's my point!
15:57:42 <Duqicnk> haskell is a great imperative language
15:57:43 <pumpkin-> but most people write functional haskell and imperative ruby
15:57:47 <jmcarthur> "you can write fortran in any language"
15:57:49 <Duqicnk> because monads make imperative actions first class
15:57:49 <MyCatVerbs> Duqicnk: try CPS-transforming a block of Python. You'll end up with indecipherable gack.
15:58:01 <Duqicnk> nah i've done it
15:58:07 <tomh> anyway, does anyone know where to get a ghc 6.10 version of quickcheck 2.1?
15:58:09 <Duqicnk> return e  ==>   return k(e)
15:58:16 * ddarius doesn't know what "gack" is.
15:58:22 <jmcarthur> tomh, build one?
15:58:26 <pumpkin-> sounds unpleasant even though I don't know what it is either
15:58:35 <dolio> I think it's a toy that used to be marketed by Nickelodeon.
15:58:39 <tomh> jmcarthur: it doesn't compile
15:58:49 <pumpkin-> http://www.urbandictionary.com/define.php?term=gack
15:58:51 <pumpkin-> aha, it's speed
15:59:05 <ddarius> dolio: There's a Japanese singer, Gackt.
15:59:20 <pumpkin-> how would you write that in japanese?? :P
15:59:26 <jmcarthur> tomh, do you need 2.1 or is 2.1.0.1 acceptable?
15:59:27 <pumpkin-> ガクト？
15:59:33 <jmcarthur> the latter is reported to work for 6.10 on hackage
15:59:49 <tomh> jmcarthur: i tried to compile that one yeah, but it fails
16:00:00 <jeffersonheard> how odd...  I submitted a link two hours ago on the haskell reddit and I can't see it
16:00:10 <jmcarthur> ah, well hackage seems to think it works :\
16:00:14 <jeffersonheard> to the released FRP library
16:00:23 <pumpkin-> jeffersonheard: it's still in the new queue
16:00:26 <pumpkin-> I just upvoted it though
16:00:33 <tomh> jmcarthur: i get this error: Class `Exception' used as a type
16:00:49 <jeffersonheard> pumpkin: I didn't know there was a new queue.  I've never had that happen before
16:00:59 <pumpkin-> whee, ghc 6.10.2 is out
16:01:07 <pumpkin-> I just finished installing 6.10.1 on a machine
16:01:22 <jmcarthur> tomh, well, it builds for me on 6.10.1
16:01:43 <jmcarthur> tomh, i don't know what could be the problem there
16:01:59 <tomh> the exception is new in 6.10 right?
16:02:06 <pumpkin-> who downvotes a new GHC version announcement on the haskell subreddit? 3 people apparently
16:02:11 <jmcarthur> they redid something, yeah
16:02:32 <jmcarthur> which 6.10 are you using? .0?
16:02:50 <tomh> Glasgow Haskell Compiler, Version 6.10.1, for Haskell 98, stage 2 booted by GHC version 6.8.3
16:02:59 <jmcarthur> huh.
16:03:38 <tomh> lemme try the new one if it ain't an aprils fool joke :P
16:03:47 <pumpkin-> GHC 7 released!
16:03:51 <jmcarthur> doesn't appear to be. it was slated for release soon
16:03:54 <jmcarthur> oh gosh
16:04:14 <Shurique> is there a way to catch SIGINT?
16:04:24 <vixey> @src >>= Parsec
16:04:24 <lambdabot> Source not found. That's something I cannot allow to happen.
16:04:47 <jmcarthur> @hoogle SIGINT
16:04:47 <lambdabot> No results found
16:04:52 <jmcarthur> @hoogle Signal
16:04:52 <lambdabot> Control.Concurrent.QSem signalQSem :: QSem -> IO ()
16:04:52 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
16:04:55 <jmcarthur> meh
16:04:58 <jmcarthur> i dunno, just looking
16:05:06 <monochrom> GHC 7 is planned to synchronize with WIndows 7.
16:05:14 <pumpkin-> and duke nukem forever?
16:05:29 <jeffersonheard> That's GHC Forever, pumpkin
16:05:37 <pumpkin-> ah :)
16:05:42 <isaacd> fix ghc
16:05:48 <jeffersonheard> actually, last I checked forever was a function in Control.Monad.
16:05:53 <ddarius> break ghc
16:05:58 <tomh> btw, are there libs to automatically create installers for windows cabal packages?
16:06:07 <ddarius> :t break error
16:06:08 <lambdabot> [[Char]] -> ([[Char]], [[Char]])
16:06:08 <pumpkin-> jeffersonheard: yup it is
16:06:40 <jeffersonheard> so therefore, ghci will be rumored to have a secret duke nukem mode...
16:06:41 <vixey> :t (>>=)
16:06:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:08:37 <vixey> how do you write >>= :/
16:09:34 <jmcarthur> vixey, what do you mean?
16:09:48 <augustss> First a >, then a > and then a =
16:09:49 <vixey> ?djinn ([s] -> [(a, [s])]) -> (a -> ([s] -> [(b, [s])])) -> ([s] -> [(b, [s])])
16:09:49 <lambdabot> Error: Undefined type []
16:10:04 <jmcarthur> oh djinn doesn't know lists
16:10:20 <vixey> ?djinn (Maybe s -> Maybe (a, Maybe s)) -> (a -> (Maybe s -> Maybe (b, Maybe s))) -> (Maybe s -> Maybe (b, Maybe s))
16:10:21 <lambdabot> f a b =
16:10:22 <lambdabot>     case a Nothing of
16:10:22 <lambdabot>     Nothing -> \ c ->
16:10:22 <lambdabot>                case c of
16:10:22 <lambdabot>                Nothing -> Nothing
16:10:23 <lambdabot>                Just d -> case a (Just d) of
16:10:25 <lambdabot>                          Nothing -> Nothing
16:10:27 <lambdabot>                          Just (e, _) -> b e Nothing
16:10:29 <lambdabot>     Just (f, g) -> case g of
16:10:31 <lambdabot>                    Nothing -> b f
16:10:32 <jmcarthur> oh god
16:10:33 <lambdabot>                    Just h -> case a (Just h) of
16:10:35 <lambdabot> Plugin `djinn' failed with: thread killed
16:10:41 <jeffersonheard> thank god
16:10:42 <vixey> grumble that would have worked too
16:11:02 <jmcarthur> can't cheat and look at standard libs?
16:11:21 <jmcarthur> oh wait, is that a wrapped state?!
16:11:22 <vixey> even in PM lambdabot wont tell me the whole thing
16:11:23 <dolio> You write (>>=) by inlining the one for StateT [c] [] b.
16:15:50 <tomh> can anyone try ":l Control.Exception" in ghci?
16:16:35 <tomh> that should work right?
16:16:40 <omnihil> <no location info>: module `Control.Exception' is a package module
16:17:25 <augustss> tomh: it would only work if you have the source to load
16:17:40 <tomh> how can i use it in ghci?
16:17:43 <augustss> otherwise it's :m +Control.Exception
16:17:48 <tomh> ok
16:20:03 <tomh> and what would :t Exception give if you load that module?
16:21:28 <ddarius> :t Exception
16:21:29 <lambdabot> Not in scope: data constructor `Exception'
16:21:43 <ddarius> :t Control.Exception.Exception
16:21:44 <lambdabot>     Not in scope: data constructor `Control.Exception.Exception'
16:22:01 <ddarius> :k Exception
16:22:02 <lambdabot>     Not in scope: type constructor or class `Exception'
16:22:11 <ddarius> :k Control.Exception.Exception
16:22:12 <lambdabot> *
16:22:13 <tomh> I don't get why tryEvaluate :: a -> IO (Either Exception a) fails
16:26:21 <vixey> @src MonadPlus
16:26:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:26:28 <vixey> @hoogle MonadPlus
16:26:28 <lambdabot> Control.Monad class Monad m => MonadPlus m
16:27:20 <ddarius> class Monad m => MonadPlus m where mzero :: m a; mplus :: m a -> m a -> m a; msum :: [m a] -> m a
16:27:21 <kadaver> what would be a good way to do lookups in a Map based on editdistance?
16:27:55 <kadaver> some sort of similarity hash? so similar words hash similarly?
16:28:25 <jeffersonheard> kadaver, I've often wondered the same thing, but there is a solution, although it's heuristic...
16:28:32 <jeffersonheard> as in, it's a hack
16:29:04 <jeffersonheard> you can store two levels of hash, the first one being N-Grams of all the real keys in the map
16:29:32 <jeffersonheard> then break your word up into ngrams and do lookups on each of those and calculate edit distance on the results and rank
16:29:51 <jeffersonheard> I've used that before
16:29:55 <gueux> Jeff Wheeler answered me very fast for the logo
16:29:57 <jeffersonheard> if someone has a better way, I'd love to know it
16:30:07 <gueux> http://media.nokrev.com/junk/haskell-logos/src
16:30:17 <gueux> contains all the logos
16:30:18 <kadaver> jeffersonheard: ok thanks
16:30:26 <gueux> but in psd :(
16:30:29 <xoclipse> hi all, i'm really new to haskell(a few days), and i wrote a simple program that parses JSON from a web server. i wanted to know if there was anything in my code i did wrong or could do better?
16:30:41 <xoclipse> you can see the code at: http://chrismoos.com/haskell-test/
16:30:48 <jeffersonheard> queux: I have photoshop
16:30:58 <gueux> can someone convert it with photoshop
16:31:00 <jeffersonheard> I could spit out a layered tiff
16:31:05 <gueux> jeffersonheard: oh great
16:31:11 <jeffersonheard> but there's probably no vector format in the psd file
16:31:17 <jeffersonheard> which one do you want?
16:31:20 <jeffersonheard> I can do the others tomorrow
16:31:29 <jeffersonheard> but I'm about to meet a friend for dinner
16:32:03 <gueux> oh, the one you think which should be the new logo
16:32:06 <gueux> :)
16:32:30 <gueux> it's for a poster on haskell
16:32:45 <tomh> what do i need to do cabal install?
16:32:47 <jeffersonheard> ahhh, so you definitely need a vector version... hrm
16:32:48 <gueux> and the rasters gives pixels :(
16:33:23 <travisbrady> xoclipse: i would probably have api_get_status return something of type Either instead of (Int, String)
16:33:44 <xoclipse> okay
16:33:48 <xoclipse> that makes sense
16:33:52 <gueux> Jeff Wheeler said me that he could do a new logo with inkscape
16:34:33 <lament> svgyaay
16:34:38 <Gracenotes> ah. what colors?
16:34:47 <jeffersonheard> gueux, that'd probably be best
16:34:57 <xoclipse> travisbrady: anything else you see?
16:34:58 <jeffersonheard> lament: snerk
16:35:03 <travisbrady> xoclipse: i'm also not crazy about if/then/else in Haskell, it looks like you're writing Python or something similar in Haskell
16:35:23 <gueux> isn't psd a vector format?
16:35:26 <xoclipse> yeah, that's my python coding coming out :(
16:35:27 <lament> travisbrady: you're saying that like it's a bad thing?
16:35:31 <lament> gueux: no
16:35:32 <gueux> I thought it was
16:35:35 <gueux> ok
16:35:39 <jeffersonheard> gueux, no, it's a mixed format
16:35:41 <travisbrady> lament: no, just an observation
16:35:53 <jeffersonheard> both vector and raster format can be stored, but these are rasters
16:36:07 <xoclipse> travisbrady: so break it down into more functions?
16:36:12 <augustss> travisbrady: don't use if/then/else then
16:36:27 <xoclipse> api_check_response is kind of a monolith
16:36:32 <vixey> is there a name for  filter p . map f ?
16:36:37 <travisbrady> augustss: whuh?
16:36:55 <ddarius> @src filter
16:36:55 <lambdabot> filter _ []     = []
16:36:55 <lambdabot> filter p (x:xs)
16:36:55 <lambdabot>     | p x       = x : filter p xs
16:36:55 <lambdabot>     | otherwise = filter p xs
16:36:56 <travisbrady> xoclipse: you can also put the multiple let's in a row in one let
16:36:57 <ddarius> Bah
16:37:31 <Gracenotes> vixey: I've had a need for it
16:37:44 <vixey> and did you give it a name?
16:37:46 <Gracenotes> on... two distinct occasions. at least.
16:37:48 <ddarius> vixey: Not really
16:37:53 <augustss> vixey: list comprehension?
16:37:55 <vixey> I wonde about
16:37:58 <vixey> map f . filter p
16:38:00 <vixey> also
16:38:15 <xoclipse> okay... there is just a lot of error checkign with parsing the JSON..
16:38:16 <vixey> maybe this all just   catMaybes . map f
16:38:32 <Gracenotes> vixey: I just used (\(row, line) -> map ((,) row . fst) $ filter (f . snd) (zip [0..] line))
16:39:07 <dolio> Why bother with a name?
16:39:09 <jeffersonheard> vixey, I juse it all the time, but I don't ever bther naming it
16:39:10 <ddarius> filter p . map f is pretty clear and should fuse.
16:39:11 <Gracenotes> which wasn't exactly pointfree; making it pointfree would probably be a pain
16:39:50 <dolio> @seen edwardk
16:39:50 <lambdabot> edwardk is in #haskell-blah and #haskell. I last heard edwardk speak 1h 6m ago.
16:39:59 <ddarius> Gracenotes: List comprehension syntax would probably be best for that.
16:40:04 <Gracenotes> well, an uncurry and partial application could be used to eliminate line.
16:40:45 <vixey> Nothing ~> []
16:40:47 <vixey> Just x -> [x]
16:40:59 <Gracenotes> vixey: I had thought about that too. however, sometimes the f you're given doesn't do maybes for you
16:41:02 <jmcarthur> @pl (\(row, line) -> map ((,) row . fst) $ filter (f . snd) (zip [0..] line))
16:41:03 <lambdabot> uncurry ((. (filter (f . snd) . zip [0..])) . map . (. fst) . (,))
16:41:05 <jeffersonheard> :t ~>
16:41:06 <lambdabot> parse error on input `~>'
16:41:11 <jeffersonheard> :t (~>)
16:41:12 <lambdabot> Not in scope: `~>'
16:41:12 <jmcarthur> @pl (\row line -> map ((,) row . fst) $ filter (f . snd) (zip [0..] line))
16:41:13 <lambdabot> (. (filter (f . snd) . zip [0..])) . map . (. fst) . (,)
16:41:24 <ddarius> \(row, line) -> [(row,x) | (x,y) <- zip [0..] line, f y]
16:41:37 <jmcarthur> very nice
16:41:55 <Gracenotes> jmcarthur: I had thought that was pretty ugly at the time... it still sort of is, but I can stomach it a bit better, I think :)
16:42:21 * jmcarthur was referring to ddarius's. i think @pl's was pretty bad there
16:42:35 <Gracenotes> yes, I'm referring to @pl (the second one)
16:42:50 <jmcarthur> it's all fun and games until you (. (filter (f . snd) . zip [0..]))
16:42:53 <Gracenotes> the list comprehension monad thing is rather neat though.
16:44:37 <dolio> > [ (x,y,z) | x <- [0..] | y <- [1..5] , z <- [1..5]]
16:44:39 <lambdabot>   [(0,1,1),(1,1,2),(2,1,3),(3,1,4),(4,1,5),(5,2,1),(6,2,2),(7,2,3),(8,2,4),(9...
16:44:55 <Gracenotes> holy GHC extension batman
16:45:04 <vixey> lol
16:45:14 <ddarius> Parallel list comprehensions are mostly pointless.
16:45:30 <dolio> That wasn't what I was hoping for.
16:46:16 <SGT_Guitar> hi
16:46:23 <Axman6> o/
16:46:37 <jmcarthur> \msg lambdabot @pl \row line -> zip [0..] line >>= \(x, y) -> f y >> (row, x)
16:46:43 <jmcarthur> woops
16:46:47 <jmcarthur> @pl \row line -> zip [0..] line >>= \(x, y) -> f y >> (row, x)
16:46:47 <lambdabot> flip ((>>=) . zip [0..]) . (`ap` snd) . (. fst) . (flip ((>>) . f) .) . (,)
16:47:01 <ddarius> It would be guard (f y)
16:47:09 <jmcarthur> right, another dumb mistake
16:47:21 <jmcarthur> @pl \line row -> zip [0..] line >>= \(x, y) -> guard (f y) >> (row, x)
16:47:21 <lambdabot> (. flip (ap . (. fst) . (flip ((>>) . guard . f) .) . (,)) snd) . (>>=) . zip [0..]
16:47:23 <gnuvince_> @kind ((->) e)
16:47:24 <lambdabot> Not in scope: type variable `e'
16:47:29 <gnuvince_> @kind ((->) Int)
16:47:31 <lambdabot> ? -> *
16:47:35 <jmcarthur> meh whatever
16:47:46 <vixey> @kind forall e. ((->) e)
16:47:47 <lambdabot>     `(->) e' is not applied to enough type arguments
16:47:47 <lambdabot>     Expected kind `*', but `(->) e' has kind `? -> *'
16:47:56 <vixey> @kind forall e m. ((->) e m)
16:47:57 <lambdabot> *
16:48:11 <Gracenotes> I'm pretty sure that (. (filter (f . snd) . zip [0..])) . map . (. fst) . (,) is parsable by human minds. I just forgot what the original function did, that's all.
16:48:36 <sw17ch> fg
16:48:36 <jmcarthur> yeah, it's certainly readable, just not as readable as it *should* be
16:48:40 <sw17ch> oops, not my terminal
16:49:05 <Gracenotes> it makes a function ((,) row), composes it with fst, then maps that to the incoming list, and composes that with a filter
16:49:09 <Gracenotes> filter/zip
16:50:07 <Gracenotes> @pl selectCoords f = concatMap (\(row, line) -> map ((,) row . fst) $ filter (f . snd) (zip [0..] line)) . zip [0..]
16:50:07 <lambdabot> selectCoords = (. zip [0..]) . (=<<) . (`ap` snd) . (. fst) . flip ((.) . map . (. fst) . (,)) . (. zip [0..]) . filter . (. snd)
16:50:11 <Gracenotes> now *that* is ugly
16:50:16 <Gracenotes> (the entire function)
16:50:26 <kerlo> > ((. (filter (f . snd) . zip [0..])) . map . (. fst) . (,)) (== 'l') "Hello, world!"
16:50:27 <lambdabot>       Overlapping instances for Show (Char -> Bool)
16:50:28 <lambdabot>        arising from a use...
16:50:42 <Gracenotes> selectCoords :: (a -> Bool) -> [[a]] -> [(Int, Int)]
16:51:03 <Gracenotes> could probably be simplified with findIndices
16:51:07 <kerlo> > ((. (filter (f . snd) . zip [0..])) . map . (. fst) . (,)) (== 'l') ["Hello, world!","lollapalooza"]
16:51:08 <lambdabot>       Overlapping instances for Show (Char -> Bool)
16:51:09 <lambdabot>        arising from a use...
16:51:14 <kerlo> Eh,
16:51:19 <kerlo> s/,/./
16:52:57 <Axman6> > showExpr f 1
16:52:58 <lambdabot>   Not in scope: `showExpr'
16:53:01 <Axman6> bah
16:56:55 <kerlo> @type ((. (filter (f . snd) . zip [0..])) . map . (. fst) . (,))
16:56:57 <lambdabot>     No instance for (SimpleReflect.FromExpr Bool)
16:56:57 <lambdabot>       arising from a use of `f' at <interactive>:1:13
16:56:57 <lambdabot>     Possible fix:
16:57:19 <kerlo> @type ((. (filter (?f . snd) . zip [0..])) . map . (. fst) . (,))
16:57:20 <lambdabot> forall a b a1. (Enum a, Num a, ?f::b -> Bool) => a1 -> [b] -> [(a1, a)]
16:57:27 <kerlo> Oh.
16:58:11 <kerlo> > let f = (== 'l') in ((. (filter (?f . snd) . zip [0..])) . map . (. fst) . (,)) 80 "hello, world"
16:58:12 <lambdabot>       Unbound implicit parameter (?f::Char -> Bool)
16:58:13 <lambdabot>        arising from a use...
16:58:18 <kerlo> > let ?f = (== 'l') in ((. (filter (?f . snd) . zip [0..])) . map . (. fst) . (,)) 80 "hello, world"
16:58:19 <lambdabot>   [(80,2),(80,3),(80,10)]
16:59:00 <kerlo> It is parsable by at least one human mind, but said human mind failed at figuring out the type of it without assistance.
17:00:04 <kerlo> For that matter, the same mind, given only the function, failed to realize that it would take that 80.
17:02:07 <mmorrow> in case anyone was wonder, here's what "\f (row, line) -> [(row,x) | (x,y) <- zip [0..] line, f y]" desugars to:
17:02:24 <mmorrow> (under the not-foldr/build way):
17:02:30 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2028#a2028
17:02:57 <kerlo> The second case statement is kind of cute.
17:10:27 <mmorrow> kerlo: heh
17:19:33 <Sargun_Screen>  *Main> product [1..1/0]
17:19:44 <Sargun_Screen> Shouldn't this return Infinity?
17:19:54 <kmeyer> the delta function for DFAs struck me as similar to bind for monads, am I close?
17:20:54 <dmhouse> > product [1..1/0]
17:21:08 <dolio> That's a very large list.
17:21:30 <dmhouse> > product [1/0,1,..]
17:21:33 <lambdabot>   <no location info>: parse error on input `..'
17:21:36 <mmorrow> > length [1..1/0]
17:21:48 <dmhouse> > product [1/0,1..]
17:21:49 <byorgey> kmeyer: you're not completely off.  the delta function for DFAs is basically a monoid action, and monads can be seen as a sort of monoid.
17:21:51 <lambdabot>   thread killed
17:22:03 <dolio> > [9.1e15..]
17:22:23 <kmeyer> byorgey: cool ;)
17:22:25 <lambdabot>   [9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e15,9.1e...
17:23:01 <Sargun_Screen> dolio: isn't it infinitly large?
17:23:05 <dmhouse> > (1/0) * 1
17:23:05 <byorgey> kmeyer: and IIRC there's a way to implement DFAs using the Identity monad, such that if you just replace Identity with [] you get NFAs =)
17:23:07 <lambdabot>   Infinity
17:23:15 <mmorrow> the Enum instance for Double is bootleg
17:23:23 <dolio> Yes, but not necessarily because the last element you've specified is Infinity.
17:23:25 <mmorrow> and conversion to Integer from (1/0) is borked
17:23:34 <kmeyer> byorgey: neat
17:23:36 <dmhouse> How can you make a NaN again?
17:23:41 <dmhouse> > sqrt(-2)
17:23:43 <lambdabot>   NaN
17:23:44 <mmorrow> , 0/0
17:23:46 <lunabot>  NaN
17:23:54 <dmhouse> > (1/0) * (0/0)
17:23:56 <lambdabot>   NaN
17:24:09 <dmhouse> > product [0/0, 1..]
17:24:09 <dolio> It's only infinitely large because at some point adding 1 to a Double doesn't make it any larger, so you'll get an infinite tail of all the same number.
17:24:23 <dmhouse> Aww, surely products with NaNs can be computed lazily...
17:24:29 <lambdabot>   mueval: Prelude.read: no parse
17:24:46 <dmhouse> (Not that anyone cares.)
17:25:03 <dolio> (And that number is still smaller than Infinity according to (<=).)
17:27:51 <kmeyer> byorgey: order matters to monoids, right?
17:27:57 <kmeyer> er, to (++)
17:28:31 <kerlo> > let ff f x | x == (f x) = x; ff f x = ff f (f x) in ff (+ 1.0)
17:28:34 <lambdabot>       Overlapping instances for Show (a -> a)
17:28:35 <lambdabot>        arising from a use of `s...
17:28:41 <kerlo> > let ff f x | x == (f x) = x; ff f x = ff f (f x) in ff (+ 1.0) 0.0
17:28:57 <lambdabot>   thread killed
17:29:11 <kerlo> > let ff f x | x == (f x) = x; ff f x = ff f (f x) in ff (+ 1.0) 1000000000000000.0
17:29:21 <kerlo> Let's try that one more time.
17:29:24 <gnuvince_> @src [a] mplus
17:29:24 <lambdabot> Source not found. stty: unknown mode: doofus
17:29:26 <lambdabot>   thread killed
17:29:30 <kerlo> > let ff f x | x == (f x) = x; ff f x = ff f (f x) in ff (+ 1000000000000000.0) 0.0
17:29:36 <gnuvince_> @src mplus [a]
17:29:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
17:29:45 <lambdabot>   thread killed
17:29:56 <kerlo> You know, that's not going to work either. Oh well.
17:31:52 <sm> with ghc -DVAR=VALUE, how can I capture the value of VAR in a haskell string ?
17:33:56 <jkup> I think haskell has serious potential in code obfuscation contests.
17:38:38 <edwardk> they need to have 'code clarification contests'
17:39:11 <Nafai> edwardk: That would actually be enlightening
17:39:47 <edwardk> given some particular hairy algorithm, implement it in the most enlightening way possible, while meeting the requirements
17:40:05 <Nafai> That would be helpful
17:40:24 <edwardk> semantic golf? =)
17:45:01 <Nafai> edwardk: unfortunately that's a little more subjective than code golf
17:49:09 <dolio> edwardk: I was reading your stuff about the incremental folds. Couldn't you just pass the algebras explicitly like in category extras to solve the last problem, instead of using Storable type hackery? :)
17:50:25 <sm> ghc 6.10.2 does not come with the cabal-install tool, am I right
17:51:53 <jedai> sm: I think you are
17:52:10 <sm> thx.. so I just just go ahead and keep using the one I had after installing 6.10.2.. yes this seems to be working
17:52:26 <edwardk> dolio: the point was that you can't actually.
17:52:44 <sm> woo that's a *lot* of warnings in HaXml
17:53:15 <edwardk> dolio: otherwise EVERY smart constructor has to be passed the algebra explicitly, and you can then build illegal structures where the algebras that were used disagree
17:53:23 <edwardk> dolio: that was the point of the type hackery. ;)
17:54:03 <dolio> Yes, but his original incremental folds thing doesn't ensure that, either.
17:54:44 <dolio> Or does it?
17:55:36 <edwardk> that was the problem i had with his original incremental fold
17:55:44 <edwardk> that and the code proliferation
17:55:45 <dolio> Oh, okay.
17:55:57 <sm> this might be subjective, but building a bunch of hackage packages with 6.10.2 sure feels faster than with 6.8
17:56:33 <edwardk> this solves the 'how do you make sure the algebras are the same' issue and the 'how can you still use use an algebra with context' issue
17:56:39 <dolio> Yeah, well, I figured when I first read it that "it can't be factored into code" was probably not true.
17:56:55 <dolio> I was thinking your article was merely disproving that.
17:57:16 <edwardk> dolio: i was particularly sensitive to it because the smart constructor with explicit algebras means that the resulting data structures would never be able to be made into implementations of nice haskell type classes like Num, Monoid, etc.
17:58:05 <edwardk> the first half was refactoring, the second half was solving the problem i introduced by refactoring into a typeclass by using Data.Reflection as an 'escape valve' ;)
17:59:03 <edwardk> dolio: i'm doing the same thing now to make regex application into a monoid. using Data.Reflection to make a type out of the particular regex term in question so you can make sure you don't mix traversals from different regexes
18:00:37 <thoughtpolice> dons: http://www.jedi-ninja.net/2009/04/01/xmonad-ps3.html
18:00:37 <gwern> @quote acker
18:00:38 <lambdabot> ddarius says: "Please don't use the Ackermann function!"
18:00:51 <monochrom> Heh
18:01:04 <Sargun_Screen> Prelude> product [1..2/0]==2
18:01:11 <Sargun_Screen> that should also return quickly
18:01:33 <monochrom> (It came from my http://www.vex.net/~trebla/haskell/calculator/Calculator.html :) )
18:06:00 <kadaver> its hard to describe just how awesome parsec is
18:06:21 <kadaver> are other parser generators close? i mean im comparing to writing my own custom parsers
18:07:59 <monochrom> It is easy to describe how awesome parsec is.
18:08:04 <monochrom> "parsec is awesome!"
18:08:15 <monochrom> See, that's an O(1) operation.
18:09:40 <sm> kadaver: I tried a bunch and didn't find anything as good
18:10:03 <sm> PEG parsers are nice but nothing is polished
18:12:48 <sm> in .cabal, I need commas in Build-Depends but not in Other-Modules, is that right
18:16:34 <dolio> How awesome?
18:17:57 <kadaver> this awesome:
18:18:08 <kadaver> > take 1000000 $ repeat "awesome"
18:18:09 <lambdabot>   ["awesome","awesome","awesome","awesome","awesome","awesome","awesome","awe...
18:18:54 <dolio> How does it compare to 4 Fast 4 Furious?
18:20:28 <necroforest> > cycle "awesome"
18:20:29 <lambdabot>   "awesomeawesomeawesomeawesomeawesomeawesomeawesomeawesomeawesomeawesomeawes...
18:25:31 <necroforest> Is there an integral square root function in haskell?
18:25:36 <necroforest> I guess i could use floor..
18:26:34 <monochrom> If you need it for larger numbers, you have to write it yourself. Binary search is good enough.
18:26:36 <dolio> There is not.
18:28:23 <dolio> pumpkin is supposed to be adding an Integer square root primop, I think. Poke, poke. :)
18:31:57 <necroforest> ah, i'm writing an RSA-cracking thing and needed a cheap factoring algorithm
18:32:38 <necroforest> (this is like.. 6-bit RSA, not 4096-bit ;) )
18:33:53 <pjb3> Hey, I'm reading the intro to Real World Haskell and there's obviously something I don't understand about laziness
18:33:54 <guenni> necroforest: I was beginning to wonder
18:34:08 <pjb3> specifically the take k (sort xs)
18:34:25 <necroforest> pjb3, what about it?
18:34:30 <necroforest> [i haven't read that book, btw]
18:34:31 <pjb3> I though the same thing as the New 2Haskell commentor
18:34:33 <Axman6> pjb3: what's the problem?
18:35:21 <pjb3> The author states that haskell uses laziness to more efficiently find the k least values in an unsorted list
18:35:55 <pjb3> I'll just paste New 2Haskell's comment in here
18:35:57 <pjb3> "laziness ensures that the list will only be sorted enough to find the k minimal elements"
18:35:57 <pjb3> How can this be?
18:35:57 <pjb3> Given the list (below is not correct Haskell syntax. I'm still learning)
18:35:57 <pjb3> [5,2,10,4,3,6,8,1]
18:35:57 <pjb3> I will make k=3 for this example
18:35:58 <pjb3> How can you not sort all of the elements up to and including the last element in this list, which is 1, in order to find out that it is one of the lowest 3 values in the list?
18:36:04 <Axman6> pjb3: well, once it's found the kth value, the rest of the list (elements greater than k) don't need to be sorted
18:36:29 <pjb3> but if the list is unsorted
18:36:31 <Axman6> pjb3: do you know how merge sort works?
18:36:38 <pjb3> Axman6: no
18:36:46 <dolio> It has to look at all the input elements. But it doesn't have to sort them all.
18:36:48 <Axman6> ah, well, worth learning :P
18:37:15 <dolio> It can start giving back a list as soon as it finds the least element, 1.
18:37:31 <Axman6> @src merge
18:37:31 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:37:34 <Axman6> bah
18:38:06 <gnut> even without merge sort, you can do the dumb "look-for-min" in the list sort... first find 1, then 2, then 3
18:38:18 <necroforest> pjb3, it will probably have to look at all of the input at least once, but it doesn't need to find the final locations of every element
18:38:32 <Axman6> pjb3: check out http://www.codecodex.com/wiki/index.php?title=Merge_sort#Haskell , the first definition
18:39:30 <pjb3> What does merge do?
18:39:38 <Axman6> pjb3: what that function does is basically puts every element into its own list (the sort [x] = [x] bit)
18:41:18 <Axman6> then, it merges each of those lists that are next to each other. it takews the first element from each list, checks which is smaller, and sticks that at the front of the list. then it keeps doing that with the rest... this needs diagrams...
18:41:48 <Axman6> pjb3: do you understand what the last line of merge is doing there?
18:41:52 <monochrom> For factoring 6-bit numbers the second fastest method is trial division. The fastest method is pre-compute primes of that range and trial division by those primes only.
18:42:23 <monochrom> Hardcode the list of those primes.
18:43:00 <necroforest> monochrom, it doesn't have to be fast, just easy
18:43:20 <monochrom> It is also the easiest.
18:43:23 <necroforest> monochrom, so i'm just looping from [2..n] and dividing
18:43:25 <Axman6> pjb3: check out http://en.wikipedia.org/wiki/File:Merge_sort_algorithm_diagram.svg
18:43:52 <necroforest> well, pre-computing every prime is harder than the really naive algorithm
18:44:21 <Axman6> pjb3: the first 4 levels are the list being split into 2 lists until each list is one element long. then below that is the merge function putting them back to gether
18:44:25 <monochrom> To factor 6-bit numbers you actually just need to try 3-bit primes.
18:44:25 <Axman6> together*
18:45:05 <necroforest>         firstFactor = head (filter (\y -> (x `mod` y)==0) [2..x])
18:45:08 <monochrom> [2,3,5,7] there you have it.
18:45:30 <pjb3> Axman6: ah, ok, I get it
18:45:46 <Axman6> pjb3: take the time to understand that definition of sort, you'll learn a lot :)
18:46:21 <pjb3> I still don't see how it can be lazy
18:46:56 <pjb3> How can you take 3 from it and know that those are the lowest 3 values if the sort hasn't completely finished?
18:47:18 <monochrom> No one claimed that.
18:47:32 <Axman6> ok. well, each of the steps under the 4th level produces sorted lists right?
18:47:36 <gnut> pjb3: think of finding the lowest element three times.
18:47:40 <necroforest> pjb3, imagine doing "take 3 (sort x)"
18:47:45 <monochrom> The real claim is you likely won't get hit by the full n*logn complexity.
18:47:45 <pjb3> monochrom: The author of RWH did
18:47:51 <pjb3> "laziness ensures that the list will only be sorted enough to find the k minimal elements"
18:47:59 <Axman6> then when you merge those sorted lists, you produce another sorted list
18:48:02 <jakeluck> aaaaaaaah, so nice to be back
18:48:27 <necroforest> pjb3, find the 3 smallest elements in x and return them
18:48:35 <jakeluck> after 3 years, it is so refreshing to be building ghc again
18:48:39 <necroforest> pjb3, you didn't need to worry about what element 5 was
18:48:51 <monochrom> Yes. The full sorting is n*logn. "the list will only be sorted enough" is less than n*logn.
18:48:56 <Axman6> just that element 5 was greater than element 3
18:49:01 <Axman6> (or equal)
18:50:52 <trez> @pl m >>= \x -> f x >> g x
18:50:52 <lambdabot> liftM2 (>>) f g =<< m
18:50:59 <trez> meh
18:51:37 <jakeluck> how's everybody doing tonight?
18:54:31 <kadaver> i finally found an english spanish dict
18:54:42 <kadaver> http://www.june29.com/IDP/files/Spanish.txt <- if anyone is interested.
18:54:49 <jakeluck> kad, you localizing ghc?
18:55:00 <necroforest> monochrom, is it asymptotically less than nlogn?
18:55:14 <monochrom> Yes.
18:55:32 <kadaver> localizing? uh no just writing a english-spanish translation program in haskell
18:55:37 <necroforest> got documentation/proof for that?
18:55:48 <jakeluck> aha
18:55:49 <monochrom> I don't know how to prove it. Everyone says it. I suppose it's an urban folklore waiting to be proven a folklore theorem.
18:55:56 <necroforest> oh
18:56:21 <necroforest> it really can't be, i don't think
18:56:34 <edwardk> necroforest: you can do top k element selection from a list of n items  in O(kn), turns out the algorithm used in haskell will do the same set of operations as that
18:56:55 <necroforest> edwardk, ok that makes sense
18:57:08 <necroforest> edwardk, so it's O(n) only if the amount you want is a constant
18:57:26 <necroforest> or if the amount you want is O(log n)
18:57:41 <edwardk> necroforest: exactly, but the fact that you just call the same sort in either scenario
18:58:02 <edwardk> so you pay O (n log n) expected for the whole list or O(kn) for the part you use, which ever is less basically
18:59:18 <edwardk> er technically its O(n^2) for the whole list, n log n expected runtime, with O(kn) worst case for the part you use, the expected value for the O(kn) and the whole list start to disagree because you have a lot of already forced thunks in the whole list case
18:59:30 <Axman6> pjb3: might also like to check out the definition here http://www.haskell.org/haskellwiki/Performance/Laziness
19:00:28 <necroforest> edwardk, you might know the answer to this
19:01:16 <necroforest> edwardk, can all algorithms that run in, say, O(f(n)) time on an imperitive language [i.e, C], be coded to run in O(f(n)) time in Haskell using purly functional constructs?
19:01:26 <edwardk> necroforest no they can't
19:01:35 <necroforest> ok, i didn't think so
19:01:36 <edwardk> usually you incur an extra log n factor due to immutability
19:02:09 <edwardk> but you should be able to show that any algorithm that runs in time O (f(n)) should be able to run in O (f(n) log n)
19:02:30 <edwardk> i think chris okasaki may have covered that, but I don't recall
19:03:45 <necroforest> that's not too bad
19:04:24 <necroforest> if you use Monads/IO()/mutable-ness/whatever, you can get it down to O(f(n))?
19:04:37 <pjb3> Axman6: Ok, thanks, this will definitely take some time to sink in
19:04:40 <edwardk> yeah
19:05:02 <edwardk> you can even use the ST monad locally and keep the imperative stuff behind a functional facade safely
19:05:19 <edwardk> ST is 'IO without IO' =)
19:05:29 <Axman6> <3 ST
19:05:38 <Gracenotes> indeed
19:05:39 <edwardk> so you can make a local world where you can compute with references, etc. and then you can compute a result using that
19:06:11 <Gracenotes> in fact, ioToST is as simple as: ioToST (IO m) = (ST m)
19:06:22 <edwardk> if Axman6 <3 ST then Axman2 < ST
19:06:44 <edwardk> iff even
19:07:00 <Gracenotes> sounds like Prolog to me O:
19:07:01 <jakeluck> that is great, i missed this gang, the conversation sounds almost pornographic
19:07:35 * edwardk talks dirty for jake
19:07:50 <Gracenotes> @vixen talk dirty for jake, lambdabot
19:07:50 <lambdabot> liverwurst gets me really gassy...
19:08:05 <necroforest> ST?
19:08:11 <jakeluck> haha
19:08:19 <necroforest> I never really did monads much
19:08:20 <edwardk> There is a monad for 'locally imperative' computation.
19:08:32 <necroforest> beyond like "do printStrLn x"
19:08:36 <jakeluck> necro, it is the monad that does to you
19:08:36 <Gracenotes> I read SPJ's paper on ST, but it didn't yield much enlightenment
19:08:48 <edwardk> it uses some neat tricks involving rank-2 polymorphism to make sure that these local computations run in isolation and don't interfere with eachother.
19:09:18 <jakeluck> necro, the awkward squad paper is a good place to start
19:09:21 <edwardk> so each one gets its own pool of references, and can manipulate them knowing no other thread will be messing around with its data
19:09:30 <Gracenotes> I sort of get the idea of why the polymorphism is necessary, but don't get how the internals look.
19:09:42 <Gracenotes> well, hm, I could just look at the source
19:09:43 <necroforest> I guess I never understood how monads let you have state
19:09:47 <edwardk> as a result you can wrap ST up and return a pure value from it, inlike IO without feeling guilty
19:09:56 <Axman6> basically, ST lets you use mutable veriables and arrays in a pure way
19:09:57 <edwardk> er unlike
19:10:05 <necroforest> since under the hood (at least for ones you create in Haskell), they're implemented functionally
19:10:24 <Gracenotes> necroforest: in this case, you're making a function into a monad instance. The function is wrapped in a newtype though.
19:10:31 <Axman6> necroforest: ST lets you have actual state inside the monad
19:11:00 <necroforest> ah, so ST is like an extra-language construct?
19:11:06 <edwardk> necroforest: the 'State' monad is just the fact that you could always rewrite a function adding an extra argument and an extra result, and by default just plumb that argument straight to the new result slot.
19:11:10 <necroforest> you couldn't implement ST in pure haskell (without a running time hit) ?
19:11:19 <Axman6> necroforest: yeah
19:11:22 <edwardk> necroforest: exactly
19:11:37 <Axman6> @src ST
19:11:37 <lambdabot> newtype ST s a = ST (STRep s a)
19:11:41 <Axman6> @src IO
19:11:41 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
19:11:48 <Axman6> @src STRep
19:11:48 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
19:11:50 <necroforest> @src STRep
19:11:50 <edwardk> necroforest but because of the way the types work out the compiler is allowed to know that what you are doing in the ST monad is safe to implement imperatively.
19:11:50 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
19:11:56 <necroforest> @src State
19:11:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:12:00 <Gracenotes> i c wat u did ther
19:12:05 <Gracenotes> erm
19:12:07 <Gracenotes> , src ''State
19:12:12 <lunabot>  newtype State i a = S' {unS :: (StateT i Id a)}
19:12:17 <edwardk> you could make a 'pseudo-ST' monad that implemented things with an extra logarithmic time cost on every reference operation by storing the references as a Map
19:12:32 <necroforest> edwardk, gotcha
19:12:33 <Gracenotes> oh. heh. well that's lunabot's kinda funny definition.
19:12:33 <edwardk> and the ST and your pseudo-ST monad should be interchangeable
19:12:34 <Axman6> necroforest: basically, IO is implemented using ST, with some funky unsafe stuff added
19:13:02 <Gracenotes> necroforest: it's all in the GHC source, and the mtl source
19:13:37 <jakeluck> my yoga teacher always says _state the lift! state the lift!_
19:13:40 <necroforest> what's GHC written in?
19:13:45 <jakeluck> ghc and perl
19:13:45 <necroforest> i'm going to guess Haskell and C?
19:13:47 <edwardk> er GHC ;)
19:13:56 <Gracenotes> GHC is written in Haskell, largely
19:13:56 <edwardk> and some C
19:14:05 <Gracenotes> and a silly Perl dependency
19:14:06 <edwardk> and a little bit of perl for the evil mangler
19:14:22 * jakeluck was hoping all that perl would have been gone by now
19:14:25 <Gracenotes> I have a directory where I've merged various package sources into one hierarchical folder organization... it is convenient indeed.
19:14:31 <monochrom> @remember jakeluck my yoga teacher always says _state the lift! state the lift!_
19:14:31 <lambdabot> Nice!
19:14:36 <necroforest> the Perl6 interpreter is written in haskell...
19:14:42 <Gracenotes> one of them
19:14:47 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3203#a3203 <- weird parsec stuff, why doesnt it work for space and \n ?
19:14:48 <necroforest> i sense a cycle in the dependency graph
19:14:49 <necroforest> ;)
19:14:50 <Gracenotes> not the 'standard' one though :x
19:15:01 <Axman6> necroforest: i've given a few examples here http://www.haskell.org/haskellwiki/Monad/ST
19:15:11 <edwardk> necroforest: bah, all good languages have one ;)
19:15:32 <byorgey> I thought the evil mangler IS gone now?  or isn't it yet?
19:15:45 <jakeluck> out of curiosity, what's the state of art of tools to investigate space-time-leak nowadays
19:15:47 <Gracenotes> kadaver: what did you expect, what does it do?
19:15:51 <edwardk> it may well be, my knowledge in that space is a couple years old
19:15:58 <Axman6> i think it's still there for the -fvia-C stuff
19:16:15 <Axman6> jakeluck: ghc
19:16:22 <kadaver> gracenortes,you sewe the example?
19:16:25 <monochrom> Perl6 has an implementation in Haskell. Perl7 will let you embed Haskell into Perl syntax. Perl8 will deprecate the Perl syntax. Perl9 will remove the Perl syntax. That's the roadmap.
19:16:33 <necroforest> > :t $
19:16:34 <lambdabot>   <no location info>: parse error on input `:'
19:16:42 <kadaver> it should parse "hello hola" into ("hello","hola")
19:17:02 <monochrom> (Think of it as the "you buy a school, then you change the top, then you change the bottom" tale. :) )
19:17:02 <kadaver> a row can end with '[' newline, space or '/'
19:17:03 <Gracenotes> okay
19:17:09 <edwardk> monochrom: are you sure that audrey didn't already jump the gun and implement that 'perl 7' feature in pugs?
19:17:10 <jakeluck> axm, every one says that, though in application it is alot more elusive
19:17:11 <monochrom> s/school/shoe/
19:17:22 <jakeluck> otherwise, we would have had at least a good tutorial example for it by now
19:17:23 <monochrom> I am not sure.
19:17:24 <Axman6> jakeluck: how so?
19:17:44 <Axman6> there's quite a lot of documentation of the profiling stuff in ghc :\
19:18:07 <Gracenotes> kadaver: well, 'many space' accepts no spaces at all. you might want to change that to 'spaces'
19:18:23 <edwardk> or many1 space
19:18:27 <Gracenotes> and, just use Parser (String, String), instead of the GenParser thing
19:18:35 <Gracenotes> I'm not sure if that's an issue in your case, but it might be
19:18:48 <jakeluck> while profiling pinpoints the location, the real issue is usually quite a number blocks away
19:19:06 <Gracenotes> in general, many1 is for (blah)+
19:19:22 <edwardk> jakeluck: it can be tricky to drop the scc annotations in the right place to get something useful
19:20:13 <jakeluck> precisely, because the natural of the language makes this line of reasoning unnatural
19:20:40 <jakeluck> well, just wondering
19:20:49 <Gracenotes> kadaver: hrm. here is some idiomatic Parsec code, if it helps: http://snippets.dzone.com/posts/show/3660
19:21:12 <jakeluck> so what's the hot paper lately, beside the 60x80 pixel mascot?
19:21:23 <Axman6> jakeluck: i've never had any problems with it, it's usually been quite clear where the problems were, either due to the amount of allocation, ot number of hits
19:21:53 <harovali1> newbyly, i'd like to use foldr to count the characters in a string, but can't manage. Would you help me? (no homework)
19:21:54 <jakeluck> axman, what type of problems do you usually solve with haskell?
19:22:18 <bmh1> alright, crew. I've blown my own mind. I'm implementing immutable Dynamic trees.
19:22:27 <jakeluck> i think, sometimes it is often domain specific
19:22:29 <Axman6> all sorts of things really, mainly (hoping to be) high performance parallel and concurrent stuff
19:22:34 <jakeluck> and it creeps on one unexpectly
19:22:36 <edwardk> jakeluck: did you ever seen robert ennals' thesis on speculative evalution in haskell?
19:22:42 <bmh1> 'eh... to hell with it
19:22:50 <monochrom> When I write code I'm already pretty aware what kind of memory expenditure or thunking I'm causing. If actually usage blows up, I know the suspects.
19:22:52 <jakeluck> interactive or batch?
19:22:56 <edwardk> jakeluck: one of the conclusions is that under speculative evaluation its a lot easier to trace and watch whats going on
19:23:19 <jakeluck> hmmm, cool, thanks for the point, edw, i will load that to my ereader tonight
19:23:50 <Axman6> monochrom: yeah, i'm getting to that point
19:24:06 <edwardk> http://berkeley.intel-research.net/rennals/rennals/pubs/thesis.pdf
19:24:15 * jakeluck programs by wishful thinking and is usually unaware of memory expenditure until too late 
19:24:45 <edwardk> jakeluck: one of the things he spends a lot of time doing in that paper is building up a detailed model of 'cost' and 'blame' that may be useful to you
19:24:47 <edwardk> hah
19:25:21 * edwardk has been accused of liking haskell because it gives him a large sandbox and then spending all of his time playing with the individual grains of sand.
19:25:26 <jakeluck> i am trying to remember, who wrote that paper on eager evaluation
19:25:44 <bhickey> jakeluck: Are you sure you don't mean the paper on lazy evaluation?
19:25:51 <bhickey> Cons shouldn't evaluate it's arguments?
19:26:10 <bhickey> or something like that
19:26:12 <jakeluck> nope, strict < eager < lazy
19:26:12 <edwardk> jakeluck: well there was a bunch of stuff on eager haskell out of jan willem maessen and company - a lot of folks under arvind or something like that
19:27:03 <bhickey> I actually wasn't aware that strict and eager semantics were different.
19:27:06 <edwardk> http://csg.csail.mit.edu/projects/languages/ph.shtml
19:27:24 <jakeluck> hmmm, edw, the paper looks interesting, i was hoping it goes deeper into doing speculative eval on multi-core
19:27:48 <edwardk> basically the speculative paper attempts to retain the asymptotics of lazy evaluation by using eager evaluation where possible, but always retaining lazy semantics
19:27:57 <BMeph> monochrom: (Going back to a point twelve hours ago) So, you just add another hard drive, then? ;p
19:28:14 <edwardk> jakeluck: the core mechanism used there works fine in a multicore setting
19:28:26 <edwardk> jakeluck: its just a couple of tweaks to the spineless tagless gmachine
19:28:29 <monochrom> I was soundly asleep 12 hours ago. Did you visit my dream?
19:28:32 <edwardk> and a bunch of profiling stuff
19:28:54 <jakeluck> how many phds do we have here?
19:28:59 <kadaver> P.char '[' P.<|> P.char '/' P.<|> P.space P.<|> P.newline
19:29:05 * edwardk is phd free.
19:29:07 <kadaver> why does thta only workfor [ and / ?
19:29:16 <jakeluck> ditto
19:29:24 <bhickey> can I get anything for a Master's?
19:29:26 <bhickey> cup of coffee?
19:29:58 <edwardk> ran out of money around the time i finished the requirements for my second masters and couldn't bring myself to hide in academia any longer.
19:30:06 <jakeluck> i was afraid to turn my java peers to haskell cuz all the wiki kept on bashing them
19:30:15 <edwardk> hahaha
19:30:40 <jakeluck> java ... cup of coffee *cough*
19:30:46 <bhickey> umph.
19:30:47 <edwardk> meh, go into any new community and you'll find something that bashes the community you were from. ;)
19:30:51 * bhickey goes back his tea
19:31:13 <jakeluck> what kind of tea do you like, bh
19:31:17 <monochrom> I guess adding another hard disk solves a large class of problems.
19:31:55 <bhickey> jakeluck: I drink a lot of earl grey. We might want to continue this in #tea
19:32:06 <Elly> this tea is orange.
19:32:38 <edwardk> ml guys make fun of haskell, haskellers make fun of ml, everyone makes fun of java, java guys make fun of assembly/c/c++ programmers. it'd be funny to draw the directed graph, but i think it'd collapse to be strongly totally connected.
19:32:40 <jakeluck> edw, this is in uk, us, or se?
19:32:53 <edwardk> jakeluck: me? us.
19:33:21 <jakeluck> that makes sense, only in the us, where our olympic atheletes works as waiters and pay for their own gym membership
19:33:56 <BMeph> Speaking of more eager Haskellesque stuff, I would love to see more stuff about Disciple, however, if Ben Lippmeier can get the GHC on the SPARC system going, I don't want to jostle his elbow. :)
19:34:01 <Elly> the ML guys I know don't make fun of haskell :P
19:34:10 <gwern> how do we make fun of ML?
19:34:16 <Zao> Silly syntax?
19:34:20 <gwern> @quote ML
19:34:20 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
19:34:21 <edwardk> gwern: syntax
19:34:26 <gwern> @quote ML
19:34:26 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
19:34:26 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
19:34:50 <gwern> jakeluck: why should the US subsidize olympic athletes?
19:35:09 <jakeluck> yeah, i notice dons haven't been working the openbsd port, i can't even bootstrap darcs 2x on it
19:35:09 <bhickey> gwern: Because we can then get indignant when they hit the bong.
19:35:20 <gwern> bhickey: we could get indignant anyway
19:35:21 <edwardk> gwern: is it sad that the major reason i prefer haskell to ml isn't laziness, though that helps, is that laziness permits me not to have to write ugly code that distinguishes between fun and val ?
19:35:33 <gwern> jakeluck: well, that's because he left openbsd for arch months and months and months ago
19:35:43 <jakeluck> i have been away
19:35:51 <necroforest> Re: VB. Doesn't F# fill that role?
19:35:57 <jakeluck> what did he do to theo?
19:36:05 <gwern> edwardk: I can't parse that, so dunno
19:36:08 * edwardk mainly considers any language that requires me to say 'def' 'fun' 'sub' 'val' or whatever before every single !@#&*() definition to have failed.
19:36:17 <bhickey> Did Python actually switch to hg or is that a joke for april 1?
19:36:27 <bhickey> (by the way, April 1st is asinine.)
19:36:43 * monochrom designs a language that makes you say "Be It Resolved That" before every definition. :)
19:36:56 <jakeluck> hmmmm, maybe i should look into reviving the openbsd port
19:36:56 <necroforest> edwardk, beats "Dim blah As Foo"
19:37:03 <blackh> monochrom: I've got a better one, "By the grace of God, ..."
19:37:03 <edwardk> gwern: er is it sad that the major reason i prefer haskell to ml isn't laziness - though that helps -  it is that laziness permits me not to have to write ugly code that distinguishes between fun and val ?
19:37:09 <jakeluck> what about ppc, anyone running on that chip anymore?
19:37:10 <edwardk> 'dim' falls into the same category ;)
19:37:14 <necroforest> or "Declare Sub X (y As String, b As Int ByVal) As String"
19:37:14 <monochrom> haha blackh nice
19:37:36 <monochrom> Let's join forces. "By the grace of God, Be It Resolved That: "
19:37:40 <dan> hey guys
19:37:44 <dan> whats the ML channel called?
19:37:48 <Elly> it's #sml
19:37:57 <Elly> making fun of ML is really easy, though: you say 'eqtype' and they blush
19:37:58 <jakeluck> #hump
19:37:59 <monochrom> We were just making fun of you.
19:38:02 <gwern> edwardk: let me rewrite that: 'the major reason I prefer haskell to ml isn't laziness....it is that laziness foo'
19:38:16 <dolio> whereas f x = x + 1 ; whereas g x = f (f x) resolved g (g 5)
19:38:18 <Elly> also 'where type X = X' is pretty good
19:38:43 <edwardk> gwern: what i mean is that any other rule that offered me the same conceptual clarity would work in its stead
19:39:36 * BMeph thinks about stopping at the local Chinese restaurant and picking up some Dim Sum as Platter...
19:39:43 <edwardk> ellu: hahaha
19:40:02 <jakeluck> what's in the dimsumplatter
19:40:08 <bhickey> performing tree rotations on an immutable tree with parent pointers is, in a word, a nightmare.
19:40:19 <bhickey> I'm tempted to do this in the ST monad
19:40:32 <edwardk> bhickey: ? never had any problem with it
19:40:45 <edwardk> oh parent pointers
19:40:49 <bhickey> mhmm.
19:41:17 <edwardk> the answer is 'don't do that' =)
19:41:24 <bhickey> that's the wrong answer.
19:41:32 <edwardk> another answer is to use oleg's doubly-linked list through a secret map technique ;)
19:41:37 <gwern> ur doing it rong?
19:42:02 <edwardk> that should recover your imperative seeming operations
19:42:10 * BMeph tries out: "let it be known henceforth, that sum = foldl' (+) 0, on this, the First day of April, in the year of Our Lord, 2009.
19:42:14 <edwardk> admittedly at a logarithmic practical cost
19:42:45 * BMeph now misses the clear and consise environment of COBOL...
19:42:54 <bhickey> BMeph: I was going to write an erotic variant of lambda bot for today and submit it to hackage under the category "Adult"
19:42:58 <bhickey> then I ran out of time
19:43:03 <edwardk> bhickey: haha
19:43:16 <bhickey> hackage just creates categories when you ask it to do so!
19:43:23 <monochrom> Design a language so every definition is a full diploma. "In the 2009th year of our Lord \n by the grace of our God \n This is to certify that \n f x \n has been defined to be x+1 and has fulfilled all requirements of syntax and type checking and is ready to be used. \n Programmer's signature on the left, Company boss's signature on the right."
19:43:27 <bhickey> I accidentally made "DataStructures" when I meant to put it in "Data Structures"
19:43:52 <edwardk> bhickey: i suppose you could just insert an ascii art pinup under the same category ala 'pony'
19:44:01 <bhickey> pony?
19:44:07 <edwardk> cabal install pony
19:44:22 <BMeph> bhickey: You should ask newsham to finish it for you - Hawaii's still got seven hours of April Foolery left... ;p
19:44:49 <bhickey> BMeph: By "finish" I mean start. I've been traveling for the past week
19:45:07 <blackh> monochrom: This is great. One day when I'm bored I'll make a "verboskell" and plug it into a Haskell lexer.
19:45:14 <monochrom> hehehehe
19:45:16 <edwardk> bhickey: i mean you could start just by transcoding something like http://www.asciipr0n.com/pr0n/pinups/pinup00.txt
19:45:24 <dan> haskell has a better syntax in general
19:45:55 <Axman6> dan: i was going to ask 'than what?' but then i realised and agreed :)
19:46:04 <BMeph> dan: Agreed.
19:46:21 <dan> i mean ML, but you can generalize that to alot of other langauges :P
19:46:22 <Gracenotes> WHY HELLO UNARY MINUS
19:46:40 <monochrom> bhickey: oooooohhhhh! Erotic lambdabot?  @carass monochrom  -->  * lambdabot slides hot lips all over monochrom  ?
19:46:40 <Axman6> though, record syntax leaves a little to be disired
19:46:45 <Gracenotes> edwardk: NSFW marking in the future!
19:46:57 <edwardk> Gracenotes: hah sorry
19:46:59 <BMeph> The two best things about ML are their modules, and Haskell. Too bad they're (currently) orthogonal bases. :\
19:47:13 * ghcai just became selfaware
19:47:14 <Gracenotes> >_>
19:47:40 * Axman6 thinks something like var.foo = var.foo*2 could work, but adding another use for . is a baaad idea...
19:47:54 <monochrom>  @slap monochrom ---> * lambdabot dresses up in leatherwear and slaps monochrom quite a bit around with leather things ?
19:48:03 <gwern> '@caress monochrom ~> * lambdabot slides her 6 raspy mouths all over monochrom'
19:48:07 <BMeph> monochrom:  @carass monochrom  -->  Maybe you meant: caress carcass
19:48:08 <Axman6> anyway, lecture time. o/
19:48:18 <monochrom> hahaha
19:48:24 <gwern> the most horrifying thing I read today was about 'traumatic fertilization'
19:48:47 <edwardk> sounds traumatic
19:48:54 <gwern> it's worse than you think
19:49:11 * BMeph wonders what Disciple uses for composing functions
19:49:20 <gwern> actually, I shouldn't have even brought it up. the picture of the male beatle penis is truly nefandous
19:51:06 <gueux> is there a go player here?
19:51:49 <gueux> I am looking for a name: how  "o.o" is called?
19:51:53 <gueux> :-)
19:52:11 <gueux> two stones with a hole between the two
19:53:57 <ghcai> @slap monochrom
19:53:57 * lambdabot throws some pointy lambdas at monochrom
19:54:20 <ghcai> @slap Gracenotes
19:54:20 <ghcai> @slpalambdabot
19:54:20 <ghcai> @slap lambdabot
19:54:20 * lambdabot smashes a lamp on Gracenotes' head
19:54:20 <lambdabot> I won't; I want to go get some cookies instead.
19:54:20 <lambdabot> Unknown command, try @list
19:54:45 <ghcai> @coockie
19:54:45 <lambdabot> Unknown command, try @list
19:54:47 <bhickey> edwardk: I think I might be close to getting this parent-pointer tree rotation nonsense working
19:54:48 <ghcai> @cookie
19:54:48 <lambdabot> Unknown command, try @list
19:54:50 <Gracenotes> @vixen slap ghcai, please
19:54:50 <lambdabot> you have very nice manors
19:55:00 <bhickey> this is about as mindfucking as prolog
19:55:16 <ghcai> @slap prolog
19:55:16 * lambdabot throws some pointy lambdas at prolog
19:55:20 <monochrom>  @caress monochrom  --->  <lambdabot> not tonight dear, I've got a new plugin
19:55:39 <byorgey> gueux: a "one-space jump" or "one-point jump", or in japanese "ikken tobi"
19:56:27 <Gracenotes> > let o  o=o in o.o $ 0.0
19:56:28 <lambdabot>   0.0
19:56:31 <Gracenotes> 0.0
19:56:41 <gueux> ok thanks
19:57:10 <Gracenotes> > let o_o = 0.0 ;o' =(, ); ;o (*)=(*) ;( lol, xD :p )= o' o' $o.o$ (:[]) $o.o$ (:[]) o_o in (:[]) o_o :p
19:57:11 <lambdabot>   [[0.0]]
19:57:33 <gwern> o.o was one of my favorite WP editors
19:59:19 <gueux> not in prolog is "\+" :)
19:59:28 <Gracenotes> gwern: oh, mine too.
19:59:31 <gueux> what a good notation!
19:59:39 <gwern> lies! what makes you lie
19:59:45 <Gracenotes> if we're referring to the same individual. Possible on of his reincarnations
19:59:49 <Gracenotes> *possibly one
20:00:00 <ghcai> concat ["g","u","e","u","x"]
20:00:00 <ghcai> > concat ["g","u","e","u","x"]
20:00:01 <lambdabot>   "gueux"
20:00:11 <Gracenotes> gwern: the user name I remember had an owl-like emoticon
20:00:26 <gwern> he did have more than one
20:00:29 <Gracenotes> yes
20:00:32 <gwern> I just call'em all o.o
20:00:36 <gwern> (easy to type)
20:00:56 <lepassive> join #python
20:01:04 <ghcai> splice [1..10]
20:01:07 <ghcai> > splice [1..10]
20:01:08 <lambdabot>   Not in scope: `splice'
20:01:14 <bhickey> > kickban lepassive
20:01:15 <lambdabot>   Not in scope: `kickban'Not in scope: `lepassive'
20:01:26 <lepassive> bhickey, typo :(
20:01:29 <Gracenotes> gwern: http://en.wikipedia.org/wiki/User_talk:O%5EO
20:01:30 <bhickey> ;-)
20:01:56 <ghcai> > map concat [[1,2,3],[4,5,6],[7,8,9]]
20:01:57 <lambdabot>       No instance for (Num [a])
20:01:58 <lambdabot>        arising from the literal `1' at <inter...
20:02:06 <Gracenotes> unfortunately I don't remember too much about him/her :(
20:02:31 <jedai> > concat [[1,2,3],[4,5,6],[7,8,9]]
20:02:33 <lambdabot>   [1,2,3,4,5,6,7,8,9]
20:03:04 <Gracenotes> gwern: http://en.wikipedia.org/wiki/User:%C2%BA%C2%A1%C2%BA
20:03:06 <Gracenotes> (and talk page)
20:03:09 <bhickey> my mind is blown that this code I wrote compiles.
20:03:14 <edwardk> bhickey: sounds like a pain in the neck to be honest. are you trying to generate a tree of this form out of whole cloth with combinators or are you trying to provide incremental updates with parent pointers, thereby suffering the combinatorial explosion of the number of actual objects you'll have to instantiate because you'll have to change the whole tree
20:03:24 <edwardk> er that probably got clipped
20:03:28 <gwern> '    Q: Hey, are you the same guy as User:º¡º from a while back? - User:Cuchullain
20:03:31 <gwern>     A: I am the walrus. - O^O '
20:03:38 <lepassive> btw, anyone aware of how to make autologin whenever i open xchat to my favorite channels ? and provide a password of verification automatically ?
20:03:45 <gwern> '    Q: Hi Wik, remember me? - User:P.D.S
20:03:46 <gwern>     A: Sorry, wrong walrus. - O^O '
20:03:52 <bhickey> edwardk: doesn't look like it got clipped. I don't need to update the whole tree. I just need to update along a path to the root
20:03:53 <ghcai> > concat [[1,2,3],[4,5,6],[7,8,9]]
20:03:54 <lambdabot>   [1,2,3,4,5,6,7,8,9]
20:04:06 <bhickey> for the time being, I'm going for correctness
20:04:24 <edwardk> bhickey: is it parent pointer only or parent and child pointers?
20:04:33 <Gracenotes> gwern: seemingly following in o.o's footsteps was The Fat Man Who Never Came Back
20:04:48 <gwern> really? can't say I noticed
20:04:51 <bhickey> edwardk: parent and child
20:05:26 <Gracenotes> probably not the same person though. There is the same idiosyncratic quality in his conversation.. although still different.
20:05:59 <edwardk> bhickey: then adding one child to a parent would change the parent, and the other child of the parent, and of course the parent of the parent because it now points to the wrong guy. it should infect the whole tree no?
20:06:22 <bhickey> edwardk: the magic of laziness might save the day.
20:07:03 <edwardk> bhickey: practically yes, but i merely pointed out the fact that you don't just change the nodes on the path to the root, its just that if you don't touch the rest of the tree those will be the only changes you see
20:07:37 <Gracenotes> gwern: anyway. that was a random comment... >-.
20:08:11 <bhickey> edwardk: your objection is noted. I'm implementing this on a dare from a professor. I don't think it will have practical value.
20:08:19 <ghcai> let lazy = "strict" in concat $ map id lazy
20:08:21 <bhickey> dynamic trees aren't particularly useful.
20:08:29 <ghcai> > let lazy = "strict" in concat $ map id lazy
20:08:30 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
20:08:50 <bhickey> edwardk: It's also amusing that a first initial ++ last name is talking to a first name ++ last initial.
20:09:13 <ghcai> > let lazy = "strict" in concat [lazy,lazy]
20:09:15 <lambdabot>   "strictstrict"
20:09:46 <edwardkmett> =)
20:10:57 <Gracenotes> > join (++) ":("
20:10:58 <lambdabot>   ":(:("
20:11:06 <bhickey> I should turn smiley faces off
20:11:19 <bhickey> a while ago I found that dumping a few thousand smiley faces onto pidgin crashes it
20:11:21 <Nafai> I'm trying to build haddock docs for something and it's complaining about not being able to find documentation for rts-1.0
20:11:45 <Nafai> I'm assuming rts is part of the base ghc install, which I installed via a binary download from haskell.org
20:11:52 <edwardk> > fix (":(" ++) -- oh?
20:11:53 <lambdabot>   ":(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(...
20:12:03 <bhickey> not enough smilies.
20:12:14 <bhickey> :(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(:(
20:12:24 <bhickey> I really hope that didn't print out for all of you.
20:12:29 <edwardk> it did
20:12:51 <Nafai> Where do I get the docs for rts-1.0?
20:13:19 * edwardk goes back to deriving data structures from compression algorithms
20:14:57 <byorgey> Nafai: it's probably just a warning, you can ignore it
20:15:17 <byorgey> Nafai: getting haddock to do cross-module documentation linking is tricky and usually doesn't matter
20:15:32 <byorgey> Nafai: look at the last line, does it say "failed" or "documentation generated"?
20:16:30 <Nafai> byorgey: http://gist.github.com/88996 (at the end)
20:17:00 <monochrom> "Documentation created: dist/doc/html/hledger/index.html" is good news.
20:17:03 <Cale> @users
20:17:03 <lambdabot> Maximum users seen in #haskell: 658, currently: 601 (91.3%), active: 15 (2.5%)
20:17:20 <Nafai> True, I was just trying to removing warnings if possible
20:17:21 <monochrom> The whole business means you don't get "Int" hyperlinked.
20:17:34 <bhickey> ugh. functional dynamic trees are a terrible idea.
20:18:26 <monochrom> It likely takes go-out-of-your-way effort to remove the warnings. I never bothered.
20:18:38 <Nafai> Ok
20:19:17 <dons> ?users
20:19:18 <lambdabot> Maximum users seen in #haskell: 658, currently: 601 (91.3%), active: 14 (2.3%)
20:19:23 <sm> Nafai: what haddock --version ?
20:19:27 <monochrom> If you have immutable tree, you can do rotation without parent pointer, in fact don't include parent pointer. Chris Okasaki's book shows how to do this.
20:19:52 <Nafai> 2.4.1
20:20:01 <sm> with 2.4.2 here, ghc 6.10.2, it runs without warning and also without doing anything - http://gist.github.com/89004
20:20:04 <Nafai> Hi dons!
20:20:05 <monochrom> If you absolutely want "go up", use zipper.
20:20:46 <edwardk> bhickey: yeah, the zipper is the right way to work 'in a context' in a functional tree.
20:21:38 <BMeph> edwardk: We need more contexts...for when to use comonads. ;)
20:23:12 <edwardk> heh
20:23:28 * bhickey learns about zippers
20:23:58 <Gracenotes> zipa
20:30:58 <Ethereal> I'm reading real world haskell at the moment and just fiddling around getting my feet wet, I noticed it said "integers can be arbitrarily large" which sounded a bit magical to me.
20:31:11 <Ethereal> So I tried 31337 ^^ 31337 and got "Infinity" ?
20:31:57 <MyCatVerbs> That'll come out as Infinity if the computation was done using a floating-point type rather than Integer.
20:32:16 <Ethereal> it was just done at ghci with no casting at all.
20:32:30 <Draconx> Ethereal, use ^ rather than ^^
20:32:36 <byorgey> Ethereal: if you use ^ instead of ^^ it will work.
20:32:43 <Ethereal> holy cow.
20:32:45 <Ethereal> *blink*
20:32:48 <byorgey> ^ requires the first argument to be a fractional type.
20:32:49 * blackh typed 31337 ^ 31337 :: Integer and doesn't recommend it
20:32:51 <MyCatVerbs> (^^) forces the type of the first thing you're using to be a Fractional, so it'll default to Double.
20:32:52 <Ethereal> That's one huge number.
20:32:54 <byorgey> er, I mean ^^
20:33:01 <Draconx> Ethereal, no kidding.
20:33:16 <MyCatVerbs> > length . show $ (31337 ^ 31337) :: Integer
20:33:17 <lambdabot>   Couldn't match expected type `Integer' against inferred type `Int'
20:33:27 <Axman6> > 31337 ^ 31337
20:33:28 <byorgey> > let factorial n = product [1..n] in factorial 100
20:33:29 <lambdabot>   893913247609433093545320191861191958071389587712968463949334203126750789707...
20:33:30 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:33:34 <MyCatVerbs> > length . show $ (31337 ^ 31337)
20:33:35 <lambdabot>   140893
20:33:40 <Axman6> magic!
20:33:41 <Ethereal> I don't think I should stare at it for too long, I'm seeing patterns and stuff. ;) So, ^ = to the power of and ^^ ... what exactly is the difference?
20:33:53 <byorgey> Ethereal: ^^ can do negative powers
20:33:55 <Axman6> :t (^)
20:33:56 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
20:33:57 <Axman6> :t (^^)
20:33:58 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:33:59 <Ethereal> ahhh.. ok
20:33:59 <byorgey> ^ only works for positive integral powers
20:34:07 <byorgey> Ethereal: and ** is for general real-number powers
20:34:08 <Axman6> :t (**)
20:34:09 <lambdabot> forall a. (Floating a) => a -> a -> a
20:34:14 <Ethereal> So, does that imply that there is a calculation that you can do that will make even ^ return Infinity ?
20:34:17 <byorgey> > 2^2
20:34:18 <lambdabot>   4
20:34:25 <byorgey> > 2^(-3)
20:34:26 <lambdabot>   * Exception: Negative exponent
20:34:29 <Ethereal> (assuming ^ is double the positive space of ^^) ?
20:34:38 <Draconx> Ethereal, yes, if the first operand has a floating type
20:34:38 <byorgey> > 2^^(-3)
20:34:40 <lambdabot>   0.125
20:34:47 <Draconx> > (31337 :: Double) ^ 31337
20:34:47 <Axman6> > (2^123 :: Double)
20:34:48 <lambdabot>   Infinity
20:34:49 <lambdabot>   1.0633823966279327e37
20:34:50 <byorgey> > 2 ** pi
20:34:51 <lambdabot>   8.824977827076287
20:34:52 <Axman6> whoot
20:35:18 <Ethereal> Hmmm.
20:35:41 <Ethereal> (31337 ^ 31337) ^ (31337 ^ 31337) :)
20:36:12 <monochrom> @type ^^
20:36:13 <lambdabot> parse error on input `^^'
20:36:22 <monochrom> @type (^^)
20:36:23 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
20:36:30 <monochrom> @type (**)
20:36:33 <byorgey> Ethereal: of course, in practice Integer is limited by the amount of memory in your computer... =)
20:36:36 <lambdabot> forall a. (Floating a) => a -> a -> a
20:37:13 <monochrom> (2^2, 2^^2, 2**2)
20:37:14 <Ethereal> byorgey: so really the upper limit of integers is the amount of bits of memory you have?
20:37:19 <monochrom> > (2^2, 2^^2, 2**2)
20:37:20 <lambdabot>   (4,4.0,4.0)
20:37:24 <Gracenotes> > join (.) (join (^)) 2
20:37:25 <lambdabot>   256
20:37:33 <Gracenotes> aka (2^2)^(2^2)
20:37:54 <Gracenotes> sorta obfuscated
20:37:59 <byorgey> Ethereal: well, in practice it's quite a bit less than that, of course
20:38:06 <byorgey> Ethereal: since other things will generally be in memory too
20:38:13 <byorgey> Ethereal: but that's the idea =)
20:38:15 <Gracenotes> @pl \n -> (n^n)^(n^n)
20:38:16 <lambdabot> ap ((^) . join (^)) (join (^))
20:38:21 <Gracenotes> hrm. :\
20:38:35 <Ethereal> Cool, Got it, thanks.
20:39:08 <monochrom> Suppose a person from China comes to Canada. Canada has four major political parties and a couple of smaller ones. The person goes "T_T what's the difference?" :)
20:39:50 <dolio> > join (liftM2 (^)) (join (^)) n
20:39:51 <Ethereal> like every other liberal democracy, the one in power acts like the chinese government and the rest whine about whatever it does.
20:40:02 <lambdabot>   mueval: Prelude.read: no parse
20:40:06 <monochrom> And yes, so I am exactly saying that if you have always thought there were only one raise-power operator, you were politically suppressed and you didn't know it.
20:40:38 * wli mentions "illiberal democracy."
20:40:55 <QtPlaty[HireMe]> Ethereal: Unless the minor parties are in a balence of power.  Then the majour party is forced to negotate with the minor parties to get the policy throught.
20:41:05 <Ethereal> illiberal democracy = freedom to agree with everyone else?
20:41:55 <wli> Check wikipedia.
20:42:03 <dolio> > n ^ n
20:42:07 <monochrom> Perhaps next time I should use some ice-cream analogy instead.
20:42:59 <dolio> Oh right, (^) isn't in the type class, so you can't magic it.
20:43:20 <bhickey> edwardk: zippers -- mindblowing. Thanks.
20:43:47 <monochrom> Yes haskell is about mindblowing.
20:43:54 <edwardk> bhickey: glad to help
20:44:02 <Gracenotes> momblo... ahem
20:44:19 <monochrom> A more accurate and academic description is: destroying all of your previous ontology.
20:44:33 <wli> I've been looking at CPO-STV (not that it would help in realistic [i.e. rigged] elections)
20:44:47 <monochrom> If "ontology" is too big a word, just change it to "belief system".
20:44:53 <Gracenotes> (n^n)^(n^n) ... join (^) (n^n) .., join (^) (join (^) n) .., join (^) . join (^) $ n ... join (.) (join (^)) $ n
20:45:01 <Gracenotes> oh, what useless fun
20:45:32 <Ethereal> "belief system" is longer than "ontology"
20:46:25 <wli> I've usually found epistemologies to be bigger issues than ontologies.
20:47:56 <Ethereal> heh, ghci returns 140,000+ digits for 31337 ^ 31337 but returns pi to less than 20 decimal places... hmmm
20:48:13 <edwardk> is oleg's TypeCast class encapsulated in hackage anywhere?
20:48:19 <Axman6> > pi :: CReal
20:48:20 <dolio> The first is an arbitrary precision integer.
20:48:23 <lambdabot>   3.1415926535897932384626433832795028841972
20:48:23 <BMeph> wli: I've usually found that, when those people ignore ontology. :)
20:48:33 <Axman6> > showCReal 100 pi
20:48:34 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
20:48:53 <Ethereal> neat trick. :)
20:49:07 <dolio> > showCReal 140000 pi
20:49:15 <dolio> @yow!
20:49:16 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO he is ...
20:49:22 <lambdabot>   thread killed
20:50:24 <Ethereal> So how long do you think it will be before people start accusing haskell of stealing ideas from F#?
20:50:28 <Ethereal> I give it seven years.
20:50:46 <wli> I still haven't figured out module systems.
20:50:58 <dolio> @quote concepts
20:50:59 <lambdabot> qwe1234 says: haskell type classes smell like c++ concepts.
20:51:00 <Axman6> why would they? anyone who knows about both will probably know that haskell is much older
20:51:19 <Ethereal> Axman6: In seven years I am wagering that will not be the case.
20:51:28 <jedai> Ethereal: That's assuming that Haskell becomes much more popular than F# (the "stealing idea" accusation don't fly so well otherwise)
20:52:06 <Axman6> yeah, i think haskell's more likely to get popular than F#
20:52:34 <dolio> Isn't F#, like, an officially supported language now?
20:52:46 <dolio> Not just research?
20:54:34 <Zao> It will be bundled with VS2010
20:58:08 --- mode: irc.freenode.net set +o ChanServ
20:58:52 <BMeph> wli: ..and a worse composite ("record") system.
20:58:52 <edwardk> f# is ML by a guy who hates modules
20:58:52 <edwardk> if don syme saw any value in module systems, i might see some value in f# ;)
20:58:52 <monochrom> Hahaha
20:58:53 <SamB> how can an ML guy hate modules?
20:58:53 <BMeph> Axman6: Is that the start of a "Sup Dawg: session? ;p
20:58:53 <SamB> don't they kind of need those since they haven't got typeclasses?
20:58:57 <edwardk> samb: never figured it out. but as a result f# always feels so crippled as to be nigh unto useless to me
20:58:59 <wli> An ML guy who hates modules is like a Porche guy who hates cars.
20:59:14 <Axman6> where i can't where where i want, i let when haskell lets me
20:59:24 <Axman6> where i can't where where i want, i let where haskell lets me*
20:59:32 <edwardk> samb: they don't have enough polymorphism available to them for me to be able to define a lot of the libraries that i hold dear. i tried porting category extras once and cried.
20:59:55 <Ethereal> Does haskell internally represents strings as a list of chars?
21:00:03 <sjanssen> Ethereal: yes
21:00:03 <Ethereal> even though it lets you do "stuff like this" ?
21:00:08 <sjanssen> @src String
21:00:09 <lambdabot> type String = [Char]
21:00:10 <Axman6> @src String
21:00:10 <lambdabot> type String = [Char]
21:00:11 <edwardk> Ethereal: effectively, yes.
21:00:12 <Axman6> lame
21:00:12 <Ethereal> Cool.
21:00:14 <sjanssen> Axman6: I win!
21:00:17 <BMeph> Axman6: "Sup Dawg", "substitution", yadda-yadda. ;)
21:00:21 <Axman6> beelsebob'd!
21:00:35 <Axman6> BMeph: i know, i was thinking outside the box :P
21:00:43 <Axman6> (and also failing at a Yo Dawg)
21:01:12 <wli> For the moment I can't figure out the basics of module systems.
21:02:29 <BMeph> wli: Maybe augustss could enlighten you. :)
21:03:03 <pumpkin_> ChilliX: how is gpugen coming along? any timeframe on it going into hackage? :D
21:03:26 <Axman6> oh hooray, 6.10.2
21:04:00 <wli> They're something like a lambdacalc where the results of evaluation etc. are module-free terms or something.
21:04:15 <BMeph> Holy Moley, it's after nine! I need to get home - see ya!
21:05:22 <seliopou> wli: right
21:05:34 <Ethereal> 1%2 = haskelly way to write half?
21:05:54 <ray> Data.Ratio way to write it, anyway
21:05:58 <jedai> Ethereal: It's a little bit more complicated now : you have bytestring and thanks to a recent extension you can also write them "like that"
21:06:10 <seliopou> signatures are like functions you pass other modules to and get modules out of
21:06:40 <Ethereal> I'm betting there are people with a heavy math background here that might be able to give an effective answer to this question.
21:06:40 <wli> I thought signatures were like types for modules.
21:06:48 <seliopou> sorry, yes
21:06:59 <seliopou> and you parameterize a module with a signature
21:07:03 <Ethereal> What is the point of fractions, rationals, etc... aren't they just effectively expressions of decimals? like 1%2 0.5 ?
21:07:03 <wli> Ethereal: The ratio constructor is %
21:07:16 <pumpkin_> Ethereal: heavy math background will give you a deeper understanding of a ratio? :o
21:07:20 <Gracenotes> > 0.1
21:07:24 <lambdabot>   0.1
21:07:33 <pumpkin_> > 3 * 0.1 == 0.3
21:07:34 <lambdabot>   False
21:07:37 <seliopou> I regularly want ML modules when I'm coding in Haskell
21:07:44 <wli> Ethereal: No, Rational is a pair of arbitrary-precision integers, one for numerator, one for denominator.
21:07:46 <seliopou> You can fake it with type classes, but it's not pretty
21:07:46 <jedai> Ethereal: and 1 % 3 ?
21:07:58 <Ethereal> pumpkin_: heavier than mine, at least, which is not that heavy at all, it just seemed like the ratio thing always seemed convoluted when floating point math serves the same purpose.. ?
21:08:10 <Gracenotes> > 3* (1%10) == 3%10
21:08:11 <Ethereal> jedai: 0.3333333333333333333 blah blah.
21:08:11 <lambdabot>   True
21:08:13 <pumpkin_> Ethereal: floating point math makes things like what I just wrote happen
21:08:16 <ray> floats are SCARY
21:08:19 <pumpkin_> Ethereal: sometimes you don't want that
21:08:22 <pumpkin_> otherrs you don't care
21:08:23 <monochrom> floating-point math does not serve the same purpose.
21:08:26 <wli> seliopou: You can fake one language construct with another the same way you can fake anything in C or Haskell in assembly.
21:08:38 <Gracenotes> ratios are precise, but can represent fewer values
21:08:45 <Ethereal> pumpkin_: but I mean, just because 1%3 is easier to write, it still represents the exact same quantity as 0.333333333333333333333... right?
21:08:50 <Gracenotes> and are slower
21:08:54 <seliopou> wli: that so true it's borderline vacuous
21:09:00 <pumpkin_> Ethereal: sure, but you can't represent the latter as a float
21:09:08 <seliopou> this comes close, but not quite close enough for my taste
21:09:11 <jedai> Ethereal: Floats (or Double) can't represent 1%3
21:09:13 <ray> there's no Data.Real :(
21:09:19 <Gracenotes> CReal, at least
21:09:20 <pumpkin_> > pi :: CRea
21:09:21 <lambdabot>   Not in scope: type constructor or class `CRea'
21:09:21 <pumpkin_> > pi :: CReal
21:09:22 <dolio> Rationals can represent more values than Floats/Doubles.
21:09:22 <lambdabot>   3.1415926535897932384626433832795028841972
21:09:46 <monochrom> Don't jump to conclusion using your prior, OK? If you don't find a use of 1%3 then don't use it. But don't doubt that other people find uses.
21:09:53 <jedai> Ethereal: Floating arithmetics is a minefield for the unwary
21:09:53 <Gracenotes> CReals are computable reals. some numbers aren't computable :X
21:09:54 <Ethereal> so they're a more precise way of writing a specific value, that's basically it?
21:09:56 <wli> seliopou: The BS with "Haskell doesn't need modules because it has typeclasses" can only be answered in that way.
21:10:01 <pumpkin_> Gracenotes: chaitlin's constant!
21:10:16 <pumpkin_> Ethereal: that has stability properties that floats don't have
21:10:21 <ray> computable numbers are *boring*
21:10:32 <pumpkin_> Ethereal: and can also represent a different range of values
21:10:44 <Ethereal> jedai: I'm not sure I follow you, like 100 * 1%2 is "clearer" than 100 * 0.5 ?
21:10:56 <pumpkin_> also, the former has a particular type
21:10:57 <Gracenotes> it's an entirely different internal representation
21:11:03 <pumpkin_> the latter is anything in a typeclass
21:11:07 <jedai> Ethereal: You can write values with them that you can't write with floats, for instance a value that multiplied by 3 give 1
21:11:38 <Ethereal> jedai: So you can say 1%3 * 3 = 1 vs 0.3333333333333333 * 3 = 0.99999999999999999
21:11:40 <monochrom> Perhaps the time for my ice-cream analogy comes. I just didn't expect it comes so quickly, even comes due to the same person on the same night!
21:12:05 <jedai> Ethereal: In this particular case it will work correctly since both 0.5, 100 and 50 are representable by floats but in plenty of case it won't
21:12:10 <Gracenotes> Ethereal: for Floats and Doubles, 0.3333333333333 are represented with binary. That's what floating point means
21:12:54 <jedai> Ethereal: You seems confused : 0.3333333333333333... isn't a float, it's an infinite decimal representation, you can't store it in a float
21:12:55 <Ethereal> jedai: so in any instance where you're working with a float that would result in an answer that trails off into infinity, a fractional answer is better?
21:13:08 <Gracenotes> sometimes you want accuracy but can sacrifice precision. Sometimes you want the reverse. Sometimes you want both. The number type you choose is related to these requirements.
21:13:11 <Ethereal> actually "answer" is probably not the right term, I should say expression maybe?
21:13:14 <monochrom> A person grew up in a small town out of nowhere. There the only ice-cream shop offers only one ice-cream flavour, namely chocolate. One day the person goes to New York. He looks at those 50 different varieties of ice-creams and goes "why do you need all of them? aren't they the same?"
21:13:41 <jedai> Ethereal: I suggest you really study Floating arithmetic... There are much more problems with it that you seems to realize. :/
21:13:42 <Ethereal> if a rational is just an expression of a float in a different way with more precision, is there a rational expression of pi?
21:13:42 <jmcarthur> > (realToFrac (1/3 :: Double) :: CReal) == (fromRational $ 1%3)
21:13:44 <lambdabot>   False
21:14:00 <ray> you should retool that analogy to be about record stores
21:14:07 <pumpkin_> Ethereal: it isn't an expression of a float with more precision at all
21:14:07 <ray> so you can seem like more of a cool older guy
21:14:10 <Gracenotes> Ethereal: not more precision, more accuracy
21:14:16 <Gracenotes> for some values
21:14:19 <monochrom> Heh ok I'll try that next time.
21:14:30 <Ethereal> Correction, accuracy.
21:14:34 <pumpkin_> Ethereal: and no, pi is irrational :P
21:14:39 <ray> you should read that ieee float spec thingy sometime
21:14:45 <ray> it'll put the fear of floats in you
21:14:55 <pumpkin_> Ethereal: floats don't correspond to any typical mathematical notion of numbers
21:15:12 <pumpkin_> Ethereal: the numbers they can represent get spaced further apart the larger they get
21:15:17 <jedai> Ethereal: It isn't "just that", it's a totally different way to represent reals, it can represent much more reals than floats can and beside it can do exact arithmetic with a lot more operations
21:15:29 <Gracenotes> so what types to use is based on what precision/accuracy you like. (An overwhelming majority of real computation is done with floating point, in general, in software)
21:15:37 <edwardk> @where CReal
21:15:37 <lambdabot> http://darcs.augustsson.net/Darcs/CReal/CReal.hs and http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
21:16:05 <Gracenotes> I think It makes sense using it more, and seeing it being used :D
21:16:18 <Ethereal> Gracenotes: yeah, I have actually never touched rationals and I have been programming for a very long time in other languages, and seeing them always kind of throws me and I tend to mentally translate to floats, but the point about 1%3 vs 0.3333333333 is a pretty good explanation for the utility of rationals.
21:16:21 <monochrom> The nice thing about using ice-cream is the connotation that the target is a little ignorant uneducated kid.
21:16:38 <pumpkin_> Ethereal: it isn't just about being more compact though
21:16:57 <monochrom> You know, records and music are so adult. Ice-cream is more kiddy.
21:17:06 <mofmog> what, they couldn't wait a day to release 6.10.2
21:17:11 <Gracenotes> Ethereal: yeah, most programming languages don't have built-in fractionals/rationals. Last semester I was trying to do some matrix calculations in Python, but their floating point types didn't work
21:17:13 <pumpkin_> mofmog: ?
21:17:17 <ray> so you impress them with your oldness
21:17:31 <jmcarthur> there is no more a float expression of pi than there is a rational one though
21:17:41 <Gracenotes> Ethereal: plus, I had to work with fractions. Using Haskell, I can plug in any numerical type I like to basic matrix calculations
21:17:48 <pumpkin_> the one true pi is pi :: CReal
21:17:52 <Gracenotes> and plugging in ratio was very convenient
21:18:03 <pumpkin_> > text . drop 500 . showCReal $ pi
21:18:03 <jmcarthur> and even that is only as true as your computer's resources are infinite
21:18:04 <lambdabot>   Couldn't match expected type `[a]'
21:18:07 <pumpkin_> > text . drop 500 . showCReal 1000 $ pi
21:18:08 <lambdabot>   129833673362440656643086021394946395224737190702179860943702770539217176293...
21:18:13 <Ethereal> jmcarthur: hold on there, isn't the whole 3.14159... expression of pi a float expression of pi? Or do you mean to say that would go on infinitely and never be accurate, therefore it isn't really a representation of pi?
21:18:35 <jmcarthur> Ethereal: it is not an accurate representation of pi, correct
21:18:35 <monochrom> . o O ( You didn't know that? )
21:18:36 <pumpkin_> Ethereal: you're confusing a decimal representation with what a float is
21:18:37 <wli> Gracenotes: What library? hmatrix doesn't do it
21:18:50 <ray> it's just a float, which is a pattern of bits that is convenient for various bits of hardware
21:18:53 <Gracenotes> wli: something I wrote myself, no error-checking, very basic but definitely got the job done.
21:18:54 <pumpkin_> Ethereal: a float isn't just a decimal number
21:18:54 <jmcarthur> Ethereal: to say that it goes on forever is incorrect though
21:18:59 <jmcarthur> floats do not go on forever
21:19:04 <jmcarthur> which is exactly why they can't represent pi
21:19:05 <Gracenotes> took inverses, multiplied, etc.
21:19:21 <Ethereal> or 1%3 for that matter, yes?
21:19:28 <pumpkin_> Ethereal: floats can represent as many distinct numbers as a 32-bit integer (minus a few), doubles as much as a 64-bit integer (or 80 sometimes)
21:19:37 <edwardk> > text . drop 500 . showCReal $ exp 1
21:19:38 <lambdabot>   Couldn't match expected type `[a]'
21:19:39 <Gracenotes> CReals are a different story. They compute as much as you need them to: "arbitrary precision". So you can have as much precision and as much accuracy as you like, but it gets more expensive the more you require
21:19:57 <jmcarthur> > [0.0,0.1..3.0]
21:19:58 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
21:20:11 <jmcarthur> ^^ is pretty horrible, eh?
21:20:18 <Gracenotes> indeed, sir
21:20:20 <jmcarthur> > [0.0,0.1..3.0] :: [CReal]
21:20:21 <lambdabot>   [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1....
21:20:23 <edwardk> > text . drop 500 . showCReal 1000 $ exp 1
21:20:24 <lambdabot>   127736178215424999229576351482208269895193668033182528869398496465105820939...
21:20:35 <Ethereal> jmcarthur: why the weird steps without CReal?
21:20:42 <jmcarthur> > [0,1%10..1]
21:20:43 <lambdabot>   [0%1,1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1]
21:20:48 <thimothy8> Hey guys, anyone can go here http://www.johnsrevenge.com/?id=2d34e5e07110724e906a5366a78ca33d this is not virus or anything =) kind of interesting. ;)
21:20:51 <jmcarthur> Ethereal: because floats are not accurate
21:20:58 <Gracenotes> uh, no
21:21:03 <pumpkin_> Ethereal: because floats are not reals, they're a weird beast
21:21:06 --- mode: ChanServ set +o monochrom
21:21:15 <Ethereal> But but.. I love floats *single glistening tear rolls down cheek*
21:21:23 <jmcarthur> Ethereal: sorry :(
21:21:33 --- mode: ChanServ set -o monochrom
21:21:39 <pumpkin_> Ethereal: you'll find that exact same issue in any language with ieee floats :) that's what I tried to show earlier with the 3 * 0.1 == 0.3 (==> False)
21:21:52 <wli> Just use the product of the first several primes as a radix.
21:21:52 <pumpkin_> Ethereal: try it in ruby, python, c, c++
21:21:54 <Ethereal> it's ok, actually having a decent answer as to why rationals aren't a waste of space is a better solution than me being able to hang on to my float ontology.
21:22:06 <ray> if you can handle specficationese, read the ieee float spec sometime
21:22:10 --- mode: ChanServ set +o monochrom
21:22:19 <pumpkin_> pre-emptive strike!
21:22:21 --- mode: monochrom set +b *!n=Tadukas@*
21:22:22 <Gracenotes> floats: precise but not accurate. rationals: accurate but not precise. creals: as accurate and precise as is required. is that an accurate and precise summary? :)
21:22:34 --- kick: thimothy8 was kicked by monochrom (monochrom)
21:22:38 --- mode: ChanServ set -o monochrom
21:22:55 <dolio> What do you mean rationals are not precise?
21:23:00 <dolio> They're as precise as they need to be.
21:23:02 <jmcarthur> Gracenotes: why are rationals not precise?
21:23:17 <Ethereal> Creals sound magical. like a custom tailored bitspace specific to the problem domain, I want to use 64 bits to represent the space between 1 and 2.. is that how it is?
21:23:20 <ray> rationals are perfectly precise
21:23:21 <dolio> Also, floats have finite precision, so they lack that, too.
21:23:21 <Gracenotes> pi can be represented reasonably accurately, but not precisely
21:23:26 <ray> they just can't represent certain numbers
21:23:27 <edwardk> they are precise right up until you need a transcendental
21:23:29 <jmcarthur> 234%48 * 23%987 will always end up with the correct result
21:23:53 <Gracenotes> rationals are precise if you're only working with, well, rational numbers ;)
21:24:09 <Ethereal> Gracenotes: and an irrational number is like, pi?
21:24:27 <Gracenotes> pi is irrational
21:24:27 <jmcarthur> Gracenotes: that's only true if you also consider Integer to be imprecise
21:24:35 <jmcarthur> i think that's not a good definition of precise though
21:24:55 <Gracenotes> jmcarthur: hm? Integers are imprecise in what sense?
21:25:02 <jmcarthur> they can't express pi
21:25:03 <pumpkin_> Ethereal: a number that cannot be represented as a rational :)
21:25:07 <ray> they can't represent one half either
21:25:10 <jmcarthur> that seems to be the argument you are making about rational
21:25:15 <pumpkin_> Ethereal: and transcendental is a number that can't be the solution of an algebraic equation
21:25:25 <pumpkin_> ray: they can
21:25:28 <Ethereal> pumpkin_: example?
21:25:34 <ray> Integers can't
21:25:34 <pumpkin_> Ethereal: pi, again :P
21:25:42 <pumpkin_> ray: oh, I thought you were talking about floats :)
21:25:43 <Gracenotes> jmcarthur: in the context of comparing it to other non-integer representation systems
21:25:50 <Ethereal> but hold on, isn't pi circ / rad2 ?
21:25:52 <Gracenotes> in the original statement, compared to floats and creal
21:26:17 <pumpkin_> Ethereal: e, pi are transcendental and irrational, but sqrt(2) is just irrational
21:26:22 <Ethereal> (and isn't that an algebraic equation?)
21:26:23 <jmcarthur> i just don't think saying one domain is less precise than another makes much sense
21:26:28 <jmcarthur> they are different domains
21:26:31 <edwardk> hrmm CReal == still cheats it seems and cuts off after 40 digits ;)
21:26:31 <jmcarthur> it's apples and oranges
21:26:34 <pumpkin_> Ethereal: where's the equality? :P
21:26:41 <ray> CReal is one big cheat
21:26:43 <Gracenotes> edwardk: yeah, that's a constant :P
21:26:48 <Ethereal> pumpkin_: pi = circ/rad2 ?
21:26:52 <Gracenotes> CReal (Int -> Integer)
21:26:58 <pumpkin_> edwardk: that's just the default Show instance though
21:27:05 <jmcarthur> in fact, Float and Double is precise too. they precisely follow their rules
21:27:14 <edwardk> pumpkin_: no its used by its Eq instance
21:27:15 <Gracenotes> yeah, that's what I said
21:27:21 <jmcarthur> they just don't precisely model real numbers
21:27:26 <wli> You can't use its Eq nstance ether.
21:27:28 <edwardk> wouldn't a more anal retentive version not fix a notion of equality via a newtype that set the max comparison depth?
21:27:31 <pumpkin_> edwardk: oh yeah, that makes sense though :P
21:27:41 <pumpkin_> edwardk: I agree, don't provide an Eq at all :P
21:27:54 <edwardk> pumpkin_: alas Num breaks, but its broken to begin with ;)
21:28:06 <dolio> You have to provide an Eq.
21:28:15 <edwardk> @source Num
21:28:15 <lambdabot> Num not available
21:28:23 <edwardk> Num has superclasses Show and Eq, no?
21:28:27 <wli> I say screw it and dump it all into non-infix monad stuff.
21:28:28 <dolio> Yeah.
21:28:32 <pumpkin_> Ethereal: I mean solving a a_1 * x^n + a_2 * x^(n-1) + ... + a_(n+1) = 0
21:28:42 <pumpkin_> eww
21:28:46 <Gracenotes> algebraic numbars
21:28:49 <pumpkin_> more examples of ugly typeclasses :)
21:28:57 <pumpkin_> my numbers are unshowable!
21:29:02 <Gracenotes> sry ur numbrs r shown
21:29:07 <pumpkin_> :(
21:29:11 <Ethereal> pumpkin_: Where you can actually solve a x and n in that equation based on the values within it, you mean?
21:29:17 * edwardk is seriously considering making a minor reimplementation of this my default 'floating point-like thing' in kata
21:29:25 <Ethereal> but because my example was wholly variable, you can't solve anything from it?
21:29:43 <pumpkin_> Ethereal: a_k is a constant, you're solving for x... if a value can't be a solution to something like that, it's transcendental
21:29:50 <edwardk> since i don't fix a notion of equality in there anyways and just allow you to supply them via modules to begin with
21:29:57 <Gracenotes> O:
21:29:59 <wli> pumpkin: I say screw it for those and dump them into non-infix monad stuff that looks like asm. e.g. Reader monads with the minpoly as the env.
21:29:59 <Gracenotes> :O
21:30:24 <pumpkin_> wli: or just move to the numeric prelude as the default one (after fixing it up some more)
21:30:34 <pumpkin_> wli: did you get your anagram thing working fast btw?
21:30:42 <dolio> a_k have to be rational (integer), too.
21:30:47 <jvoorhis> hello
21:31:12 <wli> pumpkin: No, I decided it was taking up too much time for something I had no reason to do.
21:31:15 <wli> Ratio Integer
21:31:16 <dolio> In pi = circumference/(2*radius), either circumference or radius is transcendental.
21:31:19 <pumpkin_> ah yeah
21:31:32 <Gracenotes> RATIO OF INTEGER IS IT SEEMS WHAT NO :(
21:31:37 <pumpkin_> ?
21:31:58 <jvoorhis> i've gotten away without using make for a long time, but can somebody recommend a simple project for me to read as an example of automating a ghc build?
21:32:03 <Gracenotes> AS EXPECTED
21:32:12 <ChilliX> pumpkin_: We aim at getting some alpha-ish code out soemtime in May (fingers crossed)
21:32:19 <wli> One thing that comes up is that it doesn't make sense to have Ratio Algebraic
21:32:29 <wli> You can always rationalize denominators.
21:32:34 <jedai> jvoorhis: For Haskell packages you want to use Cabal
21:32:38 <Gracenotes> you can't demonize rationals!
21:32:42 <pumpkin_> ChilliX: yay :) maybe one day I can convince someone to buy me one of those crazy tesla things from nvidia
21:33:02 <ChilliX> pumpkin_: :)
21:33:07 <jedai> jvoorhis: Check hackage.org home, there are some links on how to create a package in there
21:33:10 <edwardk> my favorite line in the CReal module. isNaN _ = False
21:33:11 <edwardk> =)
21:33:12 <ChilliX> pumpkin_: we got one
21:33:18 * pumpkin_ is jealous
21:33:23 <jvoorhis> jedai: thanks; i guess i thought cabal was only for distribution
21:33:28 <ChilliX> pumpkin_: disadvantage is that it doesn't virtualise over the four GPUs
21:33:50 <ray> source distribution, though
21:33:54 <ChilliX> pumpkin_: you can't even DMA between the memory of the four GPUs, but need to transfer via CPU memory
21:33:57 <ChilliX> (which is slow)
21:33:58 <jmcarthur> jvoorhis: also make sure and try the mkcabal tool for your first couple projects. it's just a simple time saver and isn't even 100% correct, but it helps when you're first starting
21:33:59 <wli> edwardk: It's an attempt to implement an API that's just wrong for it.
21:34:24 <ChilliX> pumpkin_: we didn't realise this until we tried to run something on the whole thing
21:34:26 <jedai> jvoorhis: You have two things Cabal the library to automate building haskell packages (with eventual C/alex/... dependency)
21:34:27 <pumpkin_> ChilliX: that's weird, so they basically just slapped four cards into the box and called it a whole, without trying to let them talk to each other efficiently
21:34:31 <edwardk> wli:: s/ for it\.// -- =)
21:34:36 <ChilliX> pumpkin_: yep
21:34:49 <wli> edwardk: The API does make sense for Float/Double
21:34:52 <Ethereal> the more I consider pi the more I think it is deeply weird.
21:34:55 <pumpkin_> ah well, I wouldn't complain if I got the department to buy me one anyway :P
21:34:58 <ChilliX> pumpkin_: judging from the NVIDIA forums, that annoys many people
21:35:13 <pumpkin_> but yeah, I'd be pissed if I had paid for it
21:35:13 <ChilliX> pumpkin_: so, hopefully, they'll improvethat
21:35:19 <jedai> jvoorhis: and cabal the program (from the cabal-install package) which automate the installation and recuperation of packages from hackage, using Cabal the library for the build itself
21:35:21 <Ethereal> so, I'm going to stop and get back to learning haskell, but thanks for the explanations on the whole rational thing, I'll pipe in on the next thing that shatters an ontology.
21:35:43 <pumpkin_> Ethereal: breaking preconceptions is what haskell is about!
21:35:46 <pumpkin_> well, maybe not
21:35:46 <wli> > let i = 0 :+ 1 ; e = exp 1 in e ** (pi * i) + 1
21:35:46 <ChilliX> pumpkin_: you can still use them together, but it requires quite a bit more effort than you might think
21:35:48 <lambdabot>   0.0 :+ 1.2246467991473532e-16
21:35:49 <pumpkin_> but it's common :)
21:36:18 <zeno> whats :+?
21:36:22 <pumpkin_> complex constructor
21:36:31 <pumpkin_> a :+ b === a + bi
21:36:32 <jmcarthur> > exp $ 2 * pi * (0 :+ i) :: Complex CReal
21:36:33 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Expr'
21:36:37 <wli> > (0 :+ 1)^2
21:36:38 <lambdabot>   (-1.0) :+ 0.0
21:36:39 <jmcarthur> > exp $ 2 * pi * (0 :+ 1) :: Complex CReal
21:36:40 <lambdabot>   1.0 :+ 0.0
21:36:49 <pumpkin_> whoa, ^ works?
21:37:02 <jmcarthur> :t (^)
21:37:03 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
21:37:05 <wli> > let i = 0 :+ 1 ; e = exp 1 in e ** (pi * i) + 1 :: Complex CReal
21:37:10 <pumpkin_> ah, makes sense
21:37:11 <lambdabot>   0.0 :+ 0.0
21:37:12 <Ethereal> pFfbts.
21:37:17 <Ethereal> *blink*
21:37:18 <Ethereal> hold on.
21:37:22 <jvoorhis> jedai, jmcarthur: thanks for your help
21:37:25 <Ethereal> There's no such thing as a perfect circle.
21:37:27 <Gracenotes> 0.0
21:37:29 <Gracenotes> -.-
21:37:31 <Gracenotes> 0.0
21:37:42 <pumpkin_> Ethereal: if pi feels weird to you, you need to play with complex numbers (or quaternions)
21:37:58 <jmcarthur> stick with complex numbers at first, i'd say
21:38:10 <wli> Quaternions are not that important. Stick with complex numbers.
21:38:14 <pumpkin_> they aren't important
21:38:16 <pumpkin_> but they are weird
21:38:17 <pumpkin_> :)
21:38:22 <jmcarthur> quaternions are awesome
21:38:25 <wli> Ethereal: You might want to try Jacobian elliptic functions, too.
21:38:29 <Ethereal> there will never be a circle that actually has a circumference precisely equal to it's diameter * pi.
21:38:30 <jmcarthur> great for 3d physics, too
21:38:36 <wli> Quaternions suck. Jacobian elliptic functions rule.
21:38:38 <pumpkin_> Ethereal: in real life, maybe not
21:38:39 <Gracenotes> Ethereal: in my imagination!
21:38:50 <Ethereal> But.. I guess this is not so stunning really.
21:38:51 <pumpkin_> Ethereal: just like you'll never have -2 bananas
21:38:56 <Ethereal> there will never be a perfect triangle, either.
21:39:00 <dolio> If it doesn't have that, then it isn't a circle. :)
21:39:12 <Gracenotes> Ethereal: well, there will never be a perfect anything-2D
21:39:25 <pumpkin_> except for photographs of me
21:39:27 <pumpkin_> ;)
21:39:31 <Gracenotes> also, if by perfect triangle you mean equilateral
21:39:33 <ray> maybe your imperfect mortal compass sucks at drawing circles, but i live in simultaneous harmonic 4-day cubic time and can draw anything i want
21:39:43 <ray> as long as it's a cube
21:39:43 <jedai> Ethereal: A circle always have its circumference equal to its diameter * pi, always ! Of course a "circle" is an idealized object that don't really occur in the real world...
21:39:55 <Gracenotes> ray: pssh. I live in the lambda cube.
21:39:58 <Ethereal> Gracenotes: What is spacetime were quantized to say a spacetime grid at the most basic fabric of reality level and your geometric construct's mathematics added up at *that* level.
21:40:01 <jmcarthur> math is just about elimination of such complex details like imperfection so that you can just think about one thing at a time
21:40:05 <Ethereal> You could have at least a perfect triangle, then.
21:40:11 <Ethereal> But you *STILL* couldn't have a perfect circle.
21:40:14 <wli> (sn(x,k))^2 + (cn(x,k))^2 = 1, (dn(x,k))^2 + k^2*(sn(x,k))^2 = 1, (d/dx) sn(x,k) = cn(x,k)*dn(x,k), (d/dx) cn(x,k) = - sn(x,k)*dn(x,k), (d/dx) dn(x,k) = -k^2 * sn(x,k)*cn(x,k)
21:40:18 <pumpkin_> Ethereal: why a grid though?
21:40:27 <wli> Who needs a perfect circle when you can have a perfect ellipse?
21:40:30 <pumpkin_> Ethereal: why not some weird circular/hyperbolic/hard-to-describe space?
21:40:32 <jmcarthur> whatever happened to 9-dimensional space?
21:40:38 <pumpkin_> I thought it was 10
21:40:42 <jmcarthur> right, that
21:40:45 <dolio> Is this a triangular grid?
21:40:51 <Gracenotes> little strings. squiggling in space. or whatever dimension they're squiggling in.
21:40:55 <Ethereal> pumpkin_: grid is bad word, matrix is maybe better, or yes, weird space that does not fit preconceived definition.
21:41:06 <Gracenotes> THE MATRIX
21:41:12 <dolio> Because I don't see you building a perfect triangle out of squares.
21:41:16 <pumpkin_> Ethereal: there's no fundamental reason for it to have square "cells"
21:41:21 <wli> I think LQG/LQC is more promising than the string crud anyway.
21:41:30 <Ethereal> What I mean though is, mathematical def of triangle = three sided shape where the corners of the angles add up to 180 degrees.
21:41:31 <pumpkin_> Ethereal: so maybe circles are the primitives in the rules underlying reality ;)
21:41:41 <Ethereal> so if you could perfectly plot that on said matrix, it would "exist"
21:41:45 <pumpkin_> Ethereal: define sides, angles, etc. :P
21:41:48 <jedai> Ethereal: Current theory on modern physics tends toward very strange space with 13 dimensions or things like that, fundamental basic blocks being ropes or something like that....
21:41:51 <Gracenotes> I can built a perfect circle out of a square... that fits in the square :O
21:41:57 <Gracenotes> call the math journals
21:42:00 <Gracenotes> !
21:42:06 <pumpkin_> jedai: I think it's 10
21:42:16 <pumpkin_> jedai: there's a youtube video that explains why they chose 10
21:42:21 <Ethereal> but how would you perfectly plot a circle when the actual constants you need to define your test are inherently and infinitely imprecise, even assuming you did have a perfect matrix and infinite precision to etch upon it.
21:42:21 <jedai> pumpkin_: I think it depends on which physician you ask
21:42:25 <Ethereal> it couldn't exist, right?
21:43:03 <pumpkin_> sure it could
21:43:03 <ray> i've proved fermat's first theorem
21:43:31 <pumpkin_> Ethereal: you're still assuming a "rectilinear" matrix
21:43:37 <AirCastle> i think the coordinates of points on a triangle's sides are just as infinitely precise as a circle.  i dont see that it makes a big difference whether the values happen to be transcendental
21:43:49 <Ethereal> pumpkin_: but with the triangle example, you just perfectly measure your triangle and see that your angles add up to 180 degrees and bang, perfect triangle, what test do you have that shows you a perfect circle?
21:43:52 <jedai> Ethereal: Those constants are exact, there is a way to compute pi to any precision you wish for, the universe isn't limited by the perception of man
21:43:55 <AirCastle> even 1.00000000000000... is infinitely precise
21:44:02 <jmcarthur> Ethereal: i think your notion of "existence" is entirely unimportant in the realm of mathematics
21:44:18 <pumpkin_> next we should move into 0.99999999... == 1
21:44:20 <pumpkin_> :P
21:44:24 <jmcarthur> pumpkin_: oh no
21:44:28 <wli> There has to be a module system tutorial somewhere.
21:44:39 <Ethereal> jedai: any precision you wish for, but when you evaluate it, it becomes imprecise.
21:44:39 <pumpkin_> wli: if you can find one, I'd be interested in it too
21:44:42 <ray> we should just move straight into the time cube :(
21:44:47 <Ethereal> jedai: but 180 is always precisely 180
21:44:53 <pumpkin_> Ethereal: evaluate? what does that mean in the context of "reality"? :P
21:44:58 <jmcarthur> Ethereal: pi is always precisely pi
21:44:58 <Ethereal> measure?
21:45:03 <jedai> Ethereal: Triangles angles adding up to 180deg ? Not in my riemanian geometry my man, nothing like that here
21:45:03 <jvoorhis> ray: are you dr gene ray?
21:45:11 <ray> i wish
21:45:21 <pumpkin_> Ethereal: in my spherical geometry, triangles don't have 180 degrees either
21:45:23 <ray> i can only dream of being the world's smartest human
21:45:36 <jvoorhis> ray: touche
21:45:38 <pumpkin_> you can have a triangle with all three angles of 90 degrees
21:45:52 <Ethereal> You know what? I love haskell just because you people are the ones writing it.
21:45:56 <kerlo> I like pumpkin_'s spherical geometry.
21:45:57 <pumpkin_> lol
21:45:58 <jmcarthur> :D
21:46:03 <Gracenotes> :D
21:46:04 <AirCastle> when i look at the question of 'is there a perfect circle' i think of it as something like, 'is there a perfect vector' or 'is there a perfect irony in reality'.. it's precisely because a circle as defined mathematically is just an didea that it doesnt exist
21:46:05 <pumpkin_> kerlo: come onto my sphere and we can admire it together
21:46:13 <AirCastle> -d
21:46:18 <pumpkin_> kerlo: except it looks like a plane from close up :P
21:46:26 <kerlo> Okay!
21:46:31 <jmcarthur> yeah, far more intelligent conversation here than somewhere like #rubyonrails or something ;)
21:46:32 <kerlo> How big is it?
21:46:38 <Ethereal> If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
21:46:47 <pumpkin_> lol
21:46:51 <jmcarthur> lol
21:47:06 <jmcarthur> is there a length limit on quotes?
21:47:06 <jvoorhis> while i'm at it, somebody give me a darcs pitch; why would i switch from git?
21:47:15 <jmcarthur> @remember Ethereal If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
21:47:15 <lambdabot> Good to know.
21:47:15 <ray> better name
21:47:19 * pumpkin_ puts on a valley girl accent and says "that is so passé"
21:47:28 <ray> honestly, i'd like to hear the darcs pitch too, and i use darcs already
21:47:59 <jmcarthur> jvoorhis: because darcs tracks *changes* and git tracks *snapshots*. that's the basic idea, anyway
21:47:59 <pumpkin_> jvoorhis: I also use git, but darcs has a stronger theoretical basis as to what it means for one change to depend on another
21:49:05 <pumpkin_> which makes it interesting
21:49:06 <pumpkin_> but I haven't used it much
21:49:06 <jedai> there are certain operation that are easier with darcs
21:49:06 <jmcarthur> jvoorhis: i use and like both. the barrier to entry with darcs is very low, so it's worth learning
21:49:06 <Gracenotes> I also use pumpkin, but lambdabot has a stronger theoretical basis as to what it means for something to  be written in Haskell
21:49:06 <Gracenotes> which makes it interesting
21:49:06 <jmcarthur> ...
21:49:06 <pumpkin_> you use me for my orange body :(
21:49:10 * pumpkin_ weeps in the corner
21:49:20 <jmcarthur> interestingly, pumpkin_'s nick is orange in my xchat
21:49:22 <pumpkin_> (that's right, IRC channels have corners and I'm in one)
21:49:31 <Gracenotes> aww. I also use you for your green stem.
21:49:38 <pumpkin_> mmm, kinky
21:49:42 <pumpkin_> I won't ask
21:49:46 <jmcarthur> and Gracenotes is green in my xchat!
21:49:47 <ray> irc channels always appear in rectangular windows for me, so i think it's perfectly reasonable to assume they have corners
21:50:06 <jvoorhis> jedai: what operations does darcs make convenient that are difficult in other systems you've used?
21:51:39 <jedai> jvoorhis: I don't have a clue to be honest, I haven't used either enough to have an opinion... There are some comparatives on the net but be aware that a lot of darcs performance problems have been corrected or improved recently so the comparaison may not be valid anymore
21:51:40 <jmcarthur> jvoorhis: while it may not sound like much considering that git has `git cherrypick`, darcs' cherrypicking is far more prevalent and safe
21:52:06 <pumpkin_> I think it works best with small patches though, right?
21:52:13 <pumpkin_> can you cherrypick individual chunks from a patch?
21:52:26 <pumpkin_> (I'd like that a lot if possible)
21:52:36 <jmcarthur> jvoorhis: with darcs, instead of making tons of branches like i do with git, i tend to have very few branchs and just use cherry picking as though i have several minibranches within each branch
21:52:58 <jmcarthur> i can have many logical changesets in one repo at a time and i can manipulate them as if they are separate
21:53:14 <jvoorhis> jmcarthur: that sounds daunting :)
21:53:33 <jmcarthur> pumpkin_: you can do things *like* that, but you end up having to make new patches if you remove pieces of them
21:53:41 <pumpkin_> ah
21:54:04 <jmcarthur> jvoorhis: all you have to do is consider your project to be a set of patches, and you can choose which patches should and should not be in your current branch
21:54:23 <jmcarthur> getting out of the "snapshot" mindset is the hardest part, and it's not that hard
21:54:49 <pumpkin_> so do you typically make very small patches I guess?
21:54:59 <altmattr> hi folks, I want to write web apps that don't run in the browser.  I could use x11 and slaughter the network, use adobe air/silverlight, etc and empty my wallet or give up and just use php/happstack/javascript/apache/etc, however....... there must be a better solution! Any haskell libs/apps/apis I should check out?
21:55:00 <jmcarthur> honestly though, unless you are just curious, git is probably good enough
21:55:08 <pumpkin_> I'm just curious :)
21:55:09 <jmcarthur> pumpkin_: it is good practice to, yes
21:55:25 <jmcarthur> pumpkin_: because then you can choose very precisely what you do and don't want
21:55:30 <pumpkin_> makes sense
21:55:55 <jmcarthur> in git, i tend to write my commit messages in past tense. in darcs, i name my patches in present tense
21:56:03 <jmcarthur> i think that is indicative of how i use them differently
21:56:42 <pumpkin_> hmm, interesting
21:57:07 <Ethereal> altmattr: How can it be a web app if it doesn't have a web browser in it somewhere? Do you mean "app that runs over tcp/ip" ?
21:57:12 <jmcarthur> git: "Added the suchandsuch function" ... darcs: "Add the suchandsuch function"
21:57:17 <jvoorhis> hey, just ran my first build with cabal :)
21:58:23 <altmattr> I mean an app that is a) served centrally (even if there is a client to install), b) stores data on my machine (and perhaps theirs as well) c) is available to many users by loggin in, etc
21:58:36 * wli spins his wheels trying to figure out module systems.
21:58:40 <altmattr> basically, like a web-app but the browser is not running the client for you, your OS is
21:58:54 <jmcarthur> jvoorhis: yay!
21:59:09 <Ethereal> altmattr: Would this app be expected to work if the server was down?
21:59:19 <pumpkin_> what exactly is a module system? in my experience, module = namespace, but I expect this is a lot more sophisticated
21:59:28 <jvoorhis> much easier than i expected
21:59:38 <altmattr> yes and no, a crappy version would not, a better version could cope, but that would be an optimisation/improvement, not a requirement
21:59:39 <jmcarthur> jvoorhis: btw, if you have the cabal-install tool, you can replace "runhaskell Setup.lhs <command>" with "cabal <command>"
21:59:48 <jmcarthur> it will find the setup script for you
21:59:58 <Ethereal> altmattr: it really does sound a whole lot like just a standard old web app.
22:00:04 <altmattr> programming client apps using web browsers is just ridiculous
22:00:06 <jvoorhis> jmcarthur: thanks, that sounds convenient
22:00:17 <altmattr> it is slow, buggy, type free, fun free and broken
22:00:29 <jvoorhis> i used the executable lhs hack, and that seems almost as good
22:00:32 <pumpkin_> altmattr: doing all the computation on the server when you have multi-GHz machines connecting to you as dumb terminals does too :P
22:00:40 <wli> pumpkin: Higher-order recursive modules with higher-order translucent, opaque, and recursive signatures and sharing constraints.
22:00:49 <altmattr> I can't stand it anymore, I need something better
22:00:49 <jmcarthur> jvoorhis: the cabal-install way works without extra effort though :)
22:00:55 <pumpkin_> altmattr: develop a javascript codegen for haskell, that generates safe javascript from haskell
22:01:17 <altmattr> pumpkin_: I won't have mulit ghz machines necessarily
22:01:19 <pumpkin_> wli: sounds interesting
22:01:25 <altmattr> that is part of the problem
22:01:44 <pumpkin_> altmattr: well, with significant computational power, usually (even an iphone has 412 mhz :P)
22:01:47 <altmattr> the machines can't easily run latest firefox/etc since those programs are so damn massive and complex
22:01:55 <ray> i don't have any multi ghz machines :(
22:02:13 <altmattr> pumpkin_: lets assume the machines I have can't run the latest ubuntu, or the latest firefox
22:02:16 <wli> pumpkin: It's just the usual set of extensions to Standard ML's module system people take off from.
22:02:20 <Ethereal> altmattr: What are the machines, what's the app you want to write?
22:02:50 <altmattr> Ethereal: machines are old g3 macs for example, the apps are lots of apps, I write web apps for a living
22:02:57 <altmattr> and I am getting sick of it
22:03:59 <Ethereal> well you could reject the paradigm of web as client but then you'd kind of be devolving to operating system calls writing programs that then communicate with the server via the network somehow and you'd be reinventing the wheel in a very large amount of cases.
22:04:02 <altmattr> plus, the main problem is actually not the speed of the machine, it is the pain of programming with php/html/javascript/django/etc
22:04:33 <Ethereal> if that's your pain point, I guess it depends, what do you actually *like* writing in?
22:04:42 <jmcarthur> you should use haskell to generate or replace all that :)
22:04:47 <altmattr> Ethereal: anything with a type system
22:04:55 <Ethereal> altmattr: Java?
22:04:57 <altmattr> happstack is a step in the right direction
22:04:59 <altmattr> but still too hard
22:05:04 <altmattr> java for web-app?
22:05:07 <altmattr> fraid not
22:05:10 * altmattr tried that
22:05:13 <jmcarthur> i think happstack is getting really close
22:05:30 <altmattr> the language has a type system, but it is subverted at all points in the application stack
22:06:12 <Ethereal> altmattr: If you could replace php/python/ruby serverside with haskell, would that pretty much do it?
22:06:13 <altmattr> jmcarthur: sounds like it is my best bet, I was actually scouting for happstack alternatives that don't use the browser as the client I guess
22:06:34 <jmcarthur> altmattr: what do you mean "that don't use the browser as the client"?
22:06:35 <newsham> how is programming with OS and client-server devolution from web clients?
22:06:35 <Ethereal> altmattr: Maybe happstack + prism?
22:06:41 <altmattr> Ethereal: if only, you really can't avoid playing with the type-free javascript
22:06:45 <jmcarthur> altmattr: happstack isn't specific to html
22:06:50 <altmattr> and it still leaves old computer users out in the cold
22:07:24 <Ethereal> altmattr: there are java and python libraries that do javascript code generation so you never have to touch javascript itself if it's that far against your religion.
22:07:25 <altmattr> jmcarthur: sounds like it deserves more of my attention, what do you mean exactly?
22:07:35 <altmattr> Ethereal: they don't work
22:07:43 <newsham> a huge non-standard standardized client that doesnt quite fit the paradigm for which it is used is not a step forward in evolution
22:07:44 <altmattr> Ethereal: you need to hack them to do what you want
22:07:55 <Ethereal> jQuery or Mootools make javascript programming pretty easy / fun. Maybe I'm just a masochist.
22:07:58 <altmattr> Ethereal: we are talking very specific, very strange requirements in most cases
22:08:15 <altmattr> newsham: I am with you on this one
22:08:24 <jmcarthur> altmattr: happstack is for web services as much as for web sites. you can serve any kind of content with it that you want
22:08:44 <altmattr> jmcarthur: arg - don't go there!  web services are hell on earth
22:08:45 <jmcarthur> html, xml, images, audio, video, custom formats, whatever
22:09:06 <altmattr> jmcarthur: please, no soap, no xml, no wsdl.... please!!!!!!
22:09:09 <jmcarthur> altmattr: well, if you don't want to use the browser as a client, you don't have to. that's all i mean
22:09:17 <altmattr> jmcarthur: :)
22:09:42 <Ethereal> it sounds like you have a huge bunch of issues that would probably have seperate answers
22:09:57 <altmattr> jmcarthur: you are right, it is one step in the right direction, but now I need to code a haskell program at the other end and I am actually just using web sercvices as a half-baked COM
22:10:19 <altmattr> Well, I know I can do it with Java/RMI for example
22:10:22 <altmattr> or COM
22:10:23 <Ethereal> traditional app server languages blow = use happstack client applications blow = hack chromium to work on an old version of power pc linux for your g3 users or something? (shrug) :)
22:11:04 <altmattr> just wondering if there is anything like that in haskell-land
22:11:06 <altmattr> guess not
22:11:13 <Ethereal> client side?
22:11:19 <altmattr> perhaps I should suck it up, stop whinging and write one :)
22:11:31 <jmcarthur> the HTTP library is a start :)
22:12:54 <Ethereal> actually client side maybe you should just be looking around at super lightweight web browsers in general?
22:13:15 <altmattr> Ethereal: good thought, but are such things capable of running web-apps?
22:13:33 <jmcarthur> altmattr: simply because of the way happstack is designed, you may not find web "services" so painful to write with it compared to django/rails/whatevercrap. and if you control the clients too, you don't even have to use those resource formats you don't like
22:13:40 <Ethereal> altmattr: if they render html + css and have a javascript engine that runs whatever library you choose to use, yes?
22:14:21 <altmattr> Ethereal: that is a long way from lightweight, I only know of webket, gecko, IE that can do all that
22:14:32 <altmattr> s/webket/webkit
22:15:03 <altmattr> for example, webkit pushes my ~500mhz iphone right to the limit
22:15:16 <Ethereal> altmattr: How bout midori?
22:15:47 <altmattr> webkit
22:16:01 <altmattr> so no smaller or faster than other webkit browsers
22:16:17 <edwardk> preflex: seen conal
22:16:17 <preflex>  conal was last seen on #haskell 14 hours, 21 minutes and 49 seconds ago, saying: unamb & lub are tools for semantically deterministic concurrency in spite of an underlying nondeterministic scheduler.  warren burton explore similar things in the 80s
22:17:03 <altmattr> jmcarthur: I am curious about the data persistance in happstack, can you shed any light on it?
22:17:41 <jmcarthur> altmattr: HAppS-State? it's just a way for you to persist arbitrary data structures with ACID guarantees
22:17:52 <jmcarthur> altmattr: it's also optional. you can use a traditional db if you want
22:18:01 <altmattr> jmcarthur: *just*? that is pretty cool
22:18:17 <jmcarthur> altmattr: it stores everything in memory, which some see as a downside
22:18:23 <altmattr> jmcarthur: is it _trustworthy_ yet?
22:18:29 <newsham> good databases store everyting in memory too
22:18:38 <jmcarthur> newsham: *everything*?
22:18:43 <newsham> whenever possible
22:18:48 <jmcarthur> altmattr: i would ask that in #happs
22:19:01 <altmattr> jmcarthur: legend, thanks
22:19:03 <newsham> disk is slow
22:19:52 <jmcarthur> yes, that is why it works that way. i think happs doesn't even resort to having any data on disk only, though. it probably just starts hitting swap, which would be disaster
22:20:20 <jmcarthur> and in the absence of swap you get process murder
22:21:18 <Ethereal> altmattr: You sould like you're planning on writing this app for a specific set audience of people you already know what hardware they have etc, is that right?
22:21:28 <altmattr> well, yes and no
22:21:30 <jmcarthur> of course, the idea is to scale out before you need to use hard drive for that
22:21:48 <altmattr> it is all deployed in univeristies and I have had trouble in the past with old machines that can't run web-apps
22:22:00 <altmattr> the maths department has some old shit still in use for example
22:22:10 <altmattr> and I have to source laptops to pass around.... etc
22:22:45 <Ethereal> Maybe remote access into a centralised server for those machines that truly are too crippled and old to actually run a proper layout engine?
22:22:51 <jmcarthur> i am oh so glad i got out of doing stuff like this for my university. it was so frustrating
22:23:01 <Ethereal> Assuming they can run something ultra simple like rdesktop or nomachine's x client.
22:23:11 <Ethereal> (both way less network bandwidth than normal X11 forwarding)
22:23:15 <altmattr> jmcarthur: in general I love it, unis are great software customers
22:23:28 <altmattr> Ethereal: you may be on to something there
22:23:28 <Ethereal> (and way snappier)
22:23:33 <jmcarthur> altmattr: oh, they are customers, not employers? that sounds much better then
22:23:51 <Ethereal> altmattr: then for those users that can actually run a browser on their machine you're fine, and for those that can't, well you've got them covered too.
22:23:58 <altmattr> jmcarthur: both, and I am trying to move more to the former :)
22:24:29 <jmcarthur> altmattr: i worked for a uni that preferred to do as much in-house as possible, with all the benefits and problems that brings...
22:24:33 <jmcarthur> mostly problems
22:24:38 <altmattr> jmcarthur: I tend to get people who tried using central it, failed and then went looking for an alternative :)
22:25:05 <altmattr> jmcarthur: I never, never interact with the central IT department.  NEVER!!!
22:25:12 <jmcarthur> good decision
22:25:34 <Ethereal> http://en.wikipedia.org/wiki/NoMachine I use this for remote access, logging in from australia to the US and it almost feels like local access, especially when the caches start filling up. very neat stuff if your server architecture can handle it.
22:26:08 <wli> At my uni I saw central IT working well, then disrupted by external financial influence forcing a changeover to PC crud.
22:26:36 <altmattr> wli: working well you say? unheard of.  Thank goodness someone put a stop to that
22:26:44 <jmcarthur> ours thought i was troublesome as a mac guy, then mischievous as a linux guy :(
22:27:05 <newsham> were you? :)
22:27:18 <jmcarthur> exact quote in front of many people, directed at me in response to a question involving ssh: "SSH is a tool of mischief!"
22:27:23 <jmcarthur> my question was never answered
22:27:42 <jmcarthur> no, i was not mischievous!
22:27:46 <Ethereal> it is you know, why are you encrypting your tasks if you have nothing to hide.
22:27:51 <Ethereal> do you want the terrists to win?
22:28:03 <jmcarthur> it is only mere coincidence that i now work for a software security company...
22:28:58 <wli> altmattr: Basically the engineering and agriculture -oriented departments were the only ones raking in cash and cross-subsidized the rest of the campus. The CS dept. got leapfrogged wrt. grant/etc. money raked in by other moneymaking dept.'s, then got huge swaths of grants from MS in exchange for changing the curriculum and admitting more students than they could handle.
22:29:13 <pumpkin> Ethereal: I hope you're not being serious :P
22:29:18 <pumpkin> I haven't been following the discussion
22:29:20 <jmcarthur> wli: typical :(
22:29:32 <Ethereal> pumpkin: You're only doing sarcasm right if someone wonders whether you're serious. ;)
22:29:34 <wli> altmattr: Part of that was dumping the entire IT instrastructure for MS-donated equipment.
22:29:37 <pumpkin> ok :)
22:29:56 <altmattr> wli: happens all over the place I am afraid
22:30:05 <Ethereal> I'm a big fan of crypto, I mean, I want to smash prime factorisation like a bull in a china shop, but I'm still a big fan of crypto.
22:30:07 <newsham> now with 50% more lock-in
22:30:14 <pumpkin> lol
22:30:23 <pumpkin> crypto is fun
22:30:25 <newsham> ethereal: thoughts on dnscurve?
22:30:30 <pumpkin> I'm more of a reverse engineering person though
22:30:58 <jmcarthur> pumpkin: you do this for fun?
22:31:02 <pumpkin> yup
22:31:13 <Ethereal> newsham: If I were a bookie I'd be running odds on which would be implemented first, dnscurve or ipv6.
22:31:14 <Ethereal> :D
22:32:11 <Ethereal> newsham: but it does sound like a good idea.
22:32:56 <newsham> what are odds of neither by 2015?
22:34:04 <Ethereal> 10-1 against.
22:34:33 <newsham> meaning i put up $1 to win $10 in 2015 if neither is implemented yet?
22:34:48 <Ethereal> Yep.
22:34:56 <newsham> i'd take that
22:35:01 <Ethereal> Globally implemented.
22:35:09 <Ethereal> not just working amongst security conscious organisations.
22:35:14 <Ethereal> but the standard operating procedure.
22:35:47 <repnop> i dont think Ethereal read what you wrote :p
22:36:10 <newsham> yah, but i'll let it go since its a fake bet
22:36:22 <newsham> and also $1 2009 might be worth $10 2015 anyway :(
22:36:22 <Ethereal> Oh, drat.
22:36:24 <Ethereal> you're right, I didn't.
22:36:36 <Ethereal> Well, I did, but it was one of those "And your brain hid the fifth e" moments.
22:36:38 <repnop> i'll hold the funds for you guys
22:36:48 <repnop> just think of me as your friendly not so accountable escrow :)
22:36:56 * wli fails to get anywhere by tracking down papers cited by the MixML module paper.
22:36:58 <Ethereal> repnop: Bernanke, is that you?
22:37:15 <newsham> > 10**(1/10)
22:37:16 <lambdabot>   1.2589254117941673
22:37:28 <edwardk> wli: hrmm, try backtracking from the xavier leroy one i sent before?
22:37:41 <newsham> > 10**(1/6)
22:37:42 <lambdabot>   1.4677992676220695
22:37:45 <wli> edwardk: Yeah.
22:38:09 <newsham> no bernanke panky, guys
22:38:19 <wli> edwardk: Or, rather, I was also using that one's citation list.
22:38:42 * edwardk is beating his head against trying to see what he gets when he takes a quadratic space and weakens the rules to allow it to be constructed over a ring, semiring or near-semiring.
22:39:13 <Ethereal> edwardk: My ill considered answer is torus.
22:39:25 <edwardk> wli: hrmm, look up robert harper over at CMU, there are a ton of things.
22:39:45 <edwardk> Ethereal: /me had to totally switch mental representations for what i meant by 'ring' to get what you meant ;)
22:40:09 * Ethereal wiki's ring disambiguation to see what edwardk *did* actually mean.
22:40:23 <Ethereal> Ahhhhhhhh.
22:40:35 <Ethereal> My better considered answer is *blank look*
22:41:51 <edwardk> ethereal: rings are objects that act in some way like the integers. you have multiplication and addition, one and zero, addition is commutative, and a couple of distributivity laws for addition and multiplication.
22:43:13 * thoughtpolice is happy with xmonad on his ps3 :)
22:43:18 <edwardk> semirings weaken the requirement on addition that it no longer be commutative. if you take 'addition' to be 'or' and 'multiplication' to be and, and let 0 = false, and 1 = true, then that yields the and/or boolean semiring.
22:43:53 <pumpkin> thoughtpolice: congrats! now get ghc to use all the power!
22:43:59 <wli> edwardk: Harper looks more promising than most of the citeseer hits I've been getting but I'm about to make a run to the store; bbi ca. 30 min.
22:44:00 <edwardk> near-semirings weaken the distirbutivity requirements, and you can show that regular expressions, haskell monads containing monoids and lots of other things qualify as near-semirings.
22:44:07 <edwardk> wli: k
22:44:45 <edwardk> wli: he's been doing work on module systems since er.. probably forever ;)
22:45:31 <wli> 0 is an annihilator
22:45:38 <thoughtpolice> pumpkin: http://www.jedi-ninja.net/2009/04/01/xmonad-ps3.html
22:45:51 <pumpkin> edwardk: do you have any writings (beyond docs) on your reduce monoid?
22:45:55 <sbahra> :t concat
22:45:56 <lambdabot> forall a. [[a]] -> [a]
22:46:03 <edwardk> basically the reason i'm looking at this is that in general, i'm pretty comfortable with quadratic spaces
22:46:14 <edwardk> pumpkin: not yet, i was planning on writing up a paper on the idea of Reducers
22:46:18 <sbahra> What's the name of the bigcup operator (according to ZFC) definition?
22:46:32 <sbahra> Appropriately placed parenthesis, of course.
22:46:34 <pumpkin> edwardk: please do!
22:46:35 <edwardk> pumpkin: but for that I want to have a bunch of them 'in the can' and some good generators to go with them
22:46:42 <sbahra> "Concatenation" doesn't seem too nice to me.
22:47:00 <edwardk> pumpkin: a "c `Reducer` m" is just a Monoid m, that knows how to inject values from type 'c'
22:47:04 <thoughtpolice> pumpkin: looks nice. her name is zelda :)
22:47:18 <pumpkin> awesome... I have a PS3 that I rarely use for gaming
22:47:22 <pumpkin> maybe I'll do that too
22:47:34 <edwardk> pumpkin: Int `Reducer` Sum Int -- says that you can use the unit :: Int -> Sum Int to embed integers into Sum
22:47:49 <edwardk> (a -> a) `Reducer` Endo a -- says you can use unit :: (a -> a) -> Endo a
22:48:24 <edwardk> its kind of a 'generalized' injection operation
22:48:26 <pumpkin> edwardk: would you integrate notions of parallelism directly into your code?
22:48:33 <pumpkin> or is that more for a "runner"?
22:48:47 <edwardk> pumpkin: look in Data.Monoid.Generator at the instance for Lazy.Bytestrings ;)
22:48:56 <edwardk> pumpkin it chunks and reduces in parallel
22:49:32 <pumpkin> cool
22:49:40 <edwardk> pumpkin: i'm putting together a Stratified generator that takes a generator of generators and runs the little ones in parallel when asked for its contents.
22:50:00 <edwardk> pumpkin: that will give you more control over how parallelism is used
22:50:11 <pumpkin> omg, what is Data.Group doing in monoids?? :P
22:50:18 <pumpkin> I'm allergic to inverses
22:50:26 <edwardk> pumpkin: haha
22:50:28 <newsham> to whom much control is given much code is required
22:50:48 <edwardk> the next version is including Data.Group.Multiplicative and Data.Field to go with Data.Ring, etc.
22:50:59 <edwardk> pumpkin: i needed Data.Group to define Data.Ring
22:51:00 <pumpkin> you should make a separate class Group
22:51:04 <edwardk> i did
22:51:06 <pumpkin> I mean
22:51:09 <pumpkin> in a separate package :P
22:51:10 <edwardk> it superclasses of Monoid though
22:51:12 <pumpkin> and Ring
22:51:22 <edwardk> no, i have too many circular dependencies
22:51:28 <pumpkin> edwardk: did you work on the numerical prelude?
22:51:31 <edwardk> i wouldn't want to maintain the next package up
22:51:36 <edwardk> no, i wrote my own though
22:51:38 <pumpkin> ah
22:51:48 <pumpkin> have any opinions on the one up on hackage?
22:52:10 <edwardk> its cute, i don't agree with all the abstractions chosen when i last looked, but a lot of that is bikeshedding
22:52:16 <sbahra> #math says union.
22:52:21 <pumpkin> bikeshedding?
22:52:42 <edwardk> this module set is designed to work with the prelude, and have some sugar that allows you to pretend you have a numerical prelude when its convenient ;)
22:53:32 <edwardk> pumpkin: http://www.freebsd.org/doc/en_US.ISO8859-1/books/faq/misc.html#BIKESHED-PAINTING
22:53:58 <pumpkin> aha :)
22:54:24 <edwardk> pumpkin: you can get people to build a nuclear power plant in total unison, but ask them how much to spend on a coffee maker and its small enough that everyone feels like they need to weigh in
22:54:54 <dolio> The numeric prelude has the worst naming scheme ever.
22:55:03 <pumpkin> you mean the word numeric?
22:55:03 <edwardk> wadlers law about how more time gets spent as you go down from semantics towards syntax towards lexical syntax towards lexical syntax of comments is in the same vein
22:55:11 <pumpkin> dolio: or the individual classes?
22:55:19 <dolio> I mean Foo.Bar.C for class names.
22:55:27 <pumpkin> oh
22:55:36 <edwardk> yeah
22:55:36 <dolio> All classes are named C.
22:55:44 <dolio> All types are T, if there are any.
22:55:46 <pumpkin> oh wow
22:55:59 <pumpkin> who came up with that idea?? :P
22:56:00 <sjanssen> dolio: ooh, I bet I know who wrote it
22:56:05 <dolio> Yeah.
22:56:08 <edwardk> dolio: i agree its terrible. i looked at monoid-transformers, which was written in that style and i couldn't bring myself to include it ;)
22:56:08 <sjanssen> (only one person in the world advocates that scheme)
22:56:24 <pumpkin> ok
22:56:25 <edwardk> henning thieleman wrote monoid-transformers, so i'm guessing him?
22:56:28 <pumpkin> I guess I can figure out who it is now
22:56:46 <pumpkin> that scheme is scary
22:58:46 <pumpkin> what's his reasoning behind it? that there should be one class per module and that all modules should be imported qualified?
22:58:55 <dolio> Yes.
22:58:57 <sjanssen> pumpkin: I think that's the gist
22:59:07 <edwardk> hrmm, whats a decent syntax for an arbitrary bilinear form in haskell? i could go with (.) in deference to dot product but people would shoot me ;)
23:00:26 <dolio> One class, one type or one of each, I suppose.
23:00:47 * edwardk suddenly remembers upon seeing sjanssen that Data.StorableVector exists, and goes and adds yet another dependency to monoids.
23:00:48 --- mode: ChanServ set +o monochrom
23:00:53 --- mode: monochrom set -b *!n=Tadukas@*
23:00:54 <dolio> So you might have Point.T as your point type.
23:00:55 --- mode: ChanServ set -o monochrom
23:00:56 <pumpkin> edwardk: move to unicode operators :P
23:01:05 <sjanssen> edwardk: I don't think anybody uses it
23:01:19 <pumpkin> what's a storablevector?
23:01:32 <pumpkin> sjanssen: uvector is moving to being safer btw :)
23:01:40 <edwardk> sjanssen: i believe i found a nice use for it with my generators
23:01:41 <sjanssen> pumpkin: ByteString generalized to any Storable
23:01:52 <pumpkin> sjanssen: ah, sounds nice
23:02:22 <pumpkin> http://squing.blogspot.com/2008/11/beautiful-folding.html am I the only person who got excited by this and disappointed that rewrite rules couldn't deal with it?
23:02:52 <edwardk> sjanssen: hrmm, i wonder if an equivalent definition that used Binary would be more satisfying?
23:03:14 <edwardk> sjanssen: then things like Char would encode utf8, no?
23:03:36 <sjanssen> edwardk: that might be useful, but would be very different
23:03:39 <BMeph> "The most Fuun you can have"...what the quux? ;)
23:03:44 <edwardk> sjanssen: yeah figured as much
23:03:47 <sjanssen> the current version has O(1) indexing
23:03:57 <edwardk> sjanssen: makes sense
23:04:24 <edwardk> sjanssen: hrmm, i may need to write the Binary version after all
23:04:28 <pumpkin> what would be an elegant (not involving a wrapper type, ideally) way to make an IEEE Binary instance for Float/Double ?
23:05:32 <BMeph> pumpkin: I think lots of folks here feel ill at that use of "elegant" and "Float/Double" in a non-ironic sense. ;)
23:06:33 <pumpkin> well, I mean, storing Floats/Doubles in 20+ bytes isn't ideal, but I can see the reasoning behind it (although I'm curious if any platforms GHC or haskell runs on actually don't have IEEE floats)
23:06:58 <sjanssen> edwardk: BinaryVector Char could be very cool, if it is efficient enough
23:07:25 <sjanssen> though I suspect it wouldn't be
23:07:48 <edwardk> sjanssen: right now i go down an even less efficient road using a UTF8 reducer transformer ;)
23:08:02 <edwardk> sjanssen: though the latter permits parallel parsing, so there are some opportunities for wins there
23:08:30 <pumpkin> BMeph: any ideas on how hard it would be to make that rewrite rule possible in ghc?
23:08:34 <edwardk> sjanssen: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Lexical-UTF8-Decoder.html
23:09:37 <edwardk> basically you can reduce bytestrings or what not using the UTF8 monoid, obtaining chars incrementally as they are fully parsable and sending them downstream to some other char monoid.
23:10:21 <pumpkin> you should make a UTF32/UCS4 monoid :P
23:10:25 <edwardk> sjanssen: so while you can index in O(1) i can chunk up on any byte boundary and start reducing, and then combine partial chars on the ends
23:11:03 <edwardk> sjanssen: my scenario works fine as long as you just want to smash data together with monoids or right seminearrings
23:11:06 <pumpkin> oh my, http://redsnake.me/
23:12:05 <edwardk> sjanssen: and has the benefit that if you feed a utf8 monoid into a fingertree i can recompute the reduction after minor modifications to the source quickly
23:12:34 <edwardk> pumpkin: kinda too easy, no? =)
23:12:42 <pumpkin> edwardk: yeah :)
23:14:48 <edwardk> oh yeah, quadratic spaces and why i'm playing with them
23:15:18 <edwardk> so conal posted some stuff for dealing with vector spaces a while back, and a lot of that generalizes to modules rather than vectorspaces
23:15:32 <edwardk> and modules over things like right-seminearrings, which are near and dear to my heart lately
23:15:46 <edwardk> since i started spotting them everywhere when it comes to parsing, tokenizing, etc.
23:16:31 <edwardk> but the basis approach struck me as useful, but a little bit off kilter for what i'd need to describe the same thing in a setting ove3r modules
23:16:49 <edwardk> in general i can't get down to an orthonormal basis in these, i can just get down to an orthogonal basis.
23:17:11 <pumpkin> you and your fancy words
23:17:36 <edwardk> with that his 'decompose' operation is just a projection along some vector. which is the use of a symmetric bilinear form, a particular form of quadratic space.
23:17:56 <edwardk> so now i want to know what the generalization of bilinear forms to seminearrings, etc. would be.
23:19:25 <pumpkin> seminearrings?
23:19:33 <pumpkin> I know what a semiring is, but what's that thing?
23:20:11 <edwardk> because i think his HasBasis class could be broken up into pieces. you can have a quadratic space over any module. if you say r `Module `m is a module formed by monoid m over (semi) (near) ring r, then you should be able to break his vectorspace up into the notion of a quadratic space, and build up bilinear spaces over that
23:20:23 <edwardk> a seminearring is a semiring that only has a distributive law on one side
23:21:09 <edwardk> (a + b) *c = a * c + b * c.. a great example of that distributing (>>) over `mplus`
23:22:06 <edwardk> (a `mplus` b) >> c = (a >> c) `mplus` (b >> c) -- is the 'left-distributive' law for mplus
23:22:35 <edwardk> though technically its a 'right-distributive' law for (>=>) over mplus to be pedantic
23:23:36 <pumpkin> ah
23:23:52 <pumpkin> I don't see >=> much
23:23:52 <edwardk> so if we say that (>>) works like (>>=) wrapped around the mappend operation for the Last monoid, you can generalize that rule to get a right-seminearring for any monad wrapped around a monoid.
23:24:02 <pumpkin> I know what it does, but it doesn't seem very common
23:24:18 <edwardk> its not, iirc it was a cale-ism to get people to think about kleisli composition
23:24:27 <pumpkin> lol
23:24:34 <dolio> probably easier to say (>>=) than (>=>) since mplus doesn't operate on Kleisli arrows directly.
23:24:46 <edwardk> dolio: yeah
23:25:13 <edwardk> dolio: though there is an arrowplus instance for kleisli in which this all works ;)
23:25:27 <edwardk> er arrowchoice or whatever
23:25:33 <dolio> But who uses that? :)
23:25:42 <dolio> See, you don't even know which it is. :)
23:25:48 <edwardk> hah
23:25:53 <edwardk> thats because i hate Arrows ;)
23:25:57 <pumpkin> aw
23:26:08 <edwardk> Applicatives have eaten their lunch
23:26:12 <dolio> @type (+++)
23:26:14 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
23:26:49 <edwardk> hrmm maybe it wasn't arrowchoice.
23:26:54 <pumpkin> aren't arrows somewhat similar to the parametrized monads sigfpe wrote about recently?
23:27:02 <dolio> ArrowPlus looks like it.
23:27:11 <dolio> @type (<+>)
23:27:13 <lambdabot>     Ambiguous occurrence `<+>'
23:27:13 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-33
23:27:13 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:55:0-46
23:27:20 <dolio> Heh.
23:27:21 <pumpkin> yeah, ArrowChoice is on Either, <+> is from ArrowPlus
23:27:25 <edwardk> @type (Control.Arrow.<+>)
23:27:26 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
23:27:28 <edwardk> there it is
23:27:37 <dolio> @type zeroArrow
23:27:38 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowZero a) => a b c
23:29:18 <edwardk> so in any event, the decompose operation from conal's vector space looks like something like: decompose :: v -> Basis v -> Scalar v -- but if you move to an arbitrary symmetric bilinear form, thats just the square root of the application of the form, which can then be generalized down to rings, etc.
23:29:22 <BMeph> I'd like to see matthew sackman's session types and Gabor Greif's Thrist class redone in Param'd Monads. :)
23:29:56 <edwardk> sackman's session types are done with parameterized monads they just don't use the def from category-extras ;)
23:30:28 <BMeph> edwardk: Ditto Greif's Thrists.
23:30:30 <wli> almost back; maybe 10-15 minutes more housework
23:30:41 <unixty> hi
23:30:56 <BMeph> wli: "almost" welcome back! :)
23:31:06 <unixty> is this a procedural or object oriented language?
23:31:18 * pumpkin has a "modern computer algebra" book lying around... I wonder how interesting it'll be
23:31:19 <BMeph> unixty: Mu!
23:31:21 <pumpkin> unixty: neither
23:31:37 <unixty> what do you mean
23:31:45 <BMeph> unixty: Or rather, no, it isn't. :)
23:32:09 <pumpkin> unixty: there are other language paradigms than the ones you listed, and haskell falls into one of them
23:32:13 <jmcarthur> unixty: haskell is functional/declarative
23:32:31 <edwardk> class Module r m => QuadraticSpace r m where q :: m -> r; class QuadraticSpace r m => BilinearSpace r m where b :: m -> m -> r; b x y = q x `subtract` q (x `mappend` y) `minus` q y -- then decompose is just the square root of the application of b with one being a basis vector
23:32:33 <pumpkin> functional/declarative/mathurbative
23:32:38 <pumpkin> mathturbative
23:32:40 <jmcarthur> ha
23:33:16 <unixty> interesting
23:33:35 <pumpkin> it sure is
23:33:43 <pumpkin> stick around and learn about it, I'm sure you'll enjoy it :)
23:33:55 <jmcarthur> haskell is always worth learning
23:34:06 <BMeph> unixty: If not, we'll give you Double your money back! ;p
23:34:21 <unixty> is there an intro like 'casting spells with lisp'
23:34:32 <pumpkin> @where lyah
23:34:33 <lambdabot> www.learnyouahaskell.com
23:34:34 <jmcarthur> realworldhaskell.com or learnyouahaskell.com
23:34:35 <pumpkin> @where rwh
23:34:36 <lambdabot> is http://www.realworldhaskell.org/blog/
23:34:42 <jmcarthur> oh, rwh is a .org
23:35:07 <jmcarthur> there are many others, but those have current prominence
23:35:29 <edwardk> unixty: http://book.realworldhaskell.org/read/ which is actually an o'reilly book
23:35:39 <Ethereal> I wonder if anyone has ever tried genetic programming in haskell, it seems like it would be a very promising problem area.
23:35:49 <jmcarthur> it has been done
23:35:56 <pumpkin> Ethereal: dons actually recently did some metagenetic programming ;)
23:35:59 <jmcarthur> i tried it once, but gave up. i was a noob at the time
23:36:02 <edwardk> Ethereal: yes its been done quite a bit
23:36:20 <jmcarthur> i've been thinking about trying again now that i know what i'm doing
23:36:32 <Ethereal> pumpkin: Evolved yourself a learning program yet? When is it going to take over the world?
23:36:44 <neoswish> hey guys, how would you write smth like this "((Int,Int),(Int,Int)) -> Double" with a lot of math and w/o many fromInteger calls? :)
23:36:50 <jmcarthur> i am an evolved program
23:37:04 <jmcarthur> smth?
23:37:21 <edwardk> neoswish: adding them or what?
23:37:26 <dolio> > let f :: ((Int,Int),(Int,Int)) -> Double ; f _ = 5 in f ((2,3),(4,7))
23:37:28 <jmcarthur> smth == something?
23:37:28 <lambdabot>   5.0
23:37:33 <pumpkin> jmcarthur: indeed :/
23:37:33 <edwardk> =)
23:37:36 <neoswish> divising
23:37:45 <neoswish> yes, something)
23:37:50 <mauke> f ((a,b),(c,d)) = w+x+y+z where [w,x,y,z] = map fromIntegral [a,b,c,d]
23:38:00 <jmcarthur> f = undefined
23:38:02 <edwardk> hah
23:38:07 <glguy> fromIntegral (x+y+z+w)
23:38:09 <glguy> do it at the end?
23:38:40 <neoswish> e.i. crossX ((x0,y0),(x1,y1)) = x0 + y0*(x1-x0)/(y0-y1)
23:38:49 <jmcarthur> is this homework?
23:38:55 <neoswish> no)
23:39:00 <neoswish> just curious
23:39:54 <neoswish> and maping throw the list is annoying
23:40:14 <cognominal_> About RWH Haskell, it is more readable on  http://book.realworldhaskell.org/read/ than in O'Reilly Safari
23:40:27 <edwardk> > let f = fromIntegral . uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip (+) . (((.) . (.) . (+)) .) . (+))) in f ((2,3),(4,5))
23:40:29 <lambdabot>   14
23:40:30 <cognominal_> anyway I ordered it from Amazon
23:40:45 <neoswish> oh jesus!)
23:40:45 <unixty> I have it on that link
23:40:57 <cognominal_> that's ugly
23:40:58 <unixty> looks like lisp
23:41:03 <pumpkin> neoswish: edwardk made it unnecessarily complex :P
23:41:08 <pumpkin> to throw you off, presumably ;)
23:41:11 <Ethereal> Whoah, now I feel like my safari subscription is just that little bit less economically valuable.
23:41:11 <edwardk> unixty: that was particularly terrible for humor's sake ;)
23:41:12 <jmcarthur> :t \((x0,y0),(x1,y1)) -> x0 + y0*(x1-x0)/(y0-y1)
23:41:13 <lambdabot> forall t. (Fractional t) => ((t, t), (t, t)) -> t
23:41:21 <Ethereal> and they made me use two book slots for that thing!
23:41:27 <Ethereal> Thanks for the link cog.
23:41:42 <edwardk> oh, i should make it do the real function
23:42:02 <jmcarthur> unixty: yeah that code wasn't a good representative of haskell ;)
23:42:19 <cognominal_> clipper fingernails and nose scrubs, repulsive indeed
23:42:21 <dolio> @type (uncurry .) . uncurry
23:42:23 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> a -> b -> c) -> (a1, b1) -> (a, b) -> c
23:42:29 <cognominal_> *clipped
23:42:44 <dolio> @type (uncurry .) . (uncurry .) . uncurry
23:42:45 <lambdabot> forall b c a b1 a1 b2. (a1 -> b2 -> a -> b1 -> b -> c) -> (a1, b2) -> ((a, b1), b) -> c
23:42:59 <dolio> @type uncurry . (uncurry .) . uncurry
23:43:01 <lambdabot> forall a b c a1 b1. (a1 -> b1 -> a -> b -> c) -> ((a1, b1), (a, b)) -> c
23:43:02 <jmcarthur> neoswish: why does the function even take ints? couldn't it take doubles and be done with it?
23:43:20 <edwardk> > let f = uncurry (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . ap ((.) . (.) . (.) . (+) . fromIntegral) ((`ap` ((. fromIntegral) . (-) . fromIntegral)) . ((flip . (((.) . (/)) .)) .) . flip ((.) . (*) . fromIntegral) . flip ((-) . fromIntegral) . fromIntegral))) in f ((2,3),(4,5))
23:43:21 <lambdabot>   -1.0
23:43:30 <wli> Why not take Num t => t?
23:43:31 <jmcarthur> oh that hurts
23:43:45 <jmcarthur> :t (/)
23:43:46 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:44:02 <neoswish> no, it must be Integer
23:44:41 <wli> Integral i => i then?
23:44:41 <neoswish> i just want to know is there pretty method to this
23:45:17 <neoswish> ok
23:45:27 <jmcarthur> i think the map is a pretty decent way
23:46:05 <edwardk> > let f =  uncurry (uncurry (\ aw f -> (\ p -> ((\ bu s t w z -> (fromIntegral bu) + (s t w z)) >>= \ bn -> (\ cg -> (\ dw ad ae ah -> ((fromIntegral dw) * ((fromIntegral ae) - (fromIntegral cg))) / (ad ah)) >>= \ eb -> (\ cj dt -> (fromIntegral cj) - (fromIntegral dt)) >>= \ ea -> return (eb ea)) >>= \ bm -> return (bn bm)) aw f (fst p)) >>= \ bb -> snd >>= \ ba -> return (bb ba))) in f ((2,3),(4,5))
23:46:07 <lambdabot>   -1.0
23:46:14 <edwardk> inverse golf?
23:46:17 <jmcarthur> why?!
23:46:19 <pumpkin> lol
23:47:06 <mauke> http://hugeurl.com/
23:47:55 <pumpkin> @@ @unpl @pl @unpl @pl \q w e r t y -> y t r e w q
23:47:56 <lambdabot>  (\ b c f i l o -> o l i f c b)
23:48:00 <pumpkin> where did it get those letters?
23:48:43 <pumpkin> I guess I don't need two layers of it
23:48:52 <jmcarthur> @pl \q w e r t y -> y t r e w q
23:48:53 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
23:48:56 <jmcarthur> beautiful
23:50:16 <cognominal_> is there an @unpl ?
23:50:25 <pumpkin> @unpl flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
23:50:25 <unixty> is there an editor and compiler?
23:50:26 <lambdabot> (\ b c f i l o -> o l i f c b)
23:50:31 <jmcarthur> yup
23:50:48 <edwardk> unixty: there are several compilers, the main one is ghc.
23:50:49 <cognominal_> cool
23:50:49 <pumpkin> unixty: and so much more! we have a magic vacuum cleaner too
23:50:51 <wli> lambdabot doesn't like @@ @pl @undo let rep m = do { m ; rep m } in rep
23:51:45 <jmcarthur> unixty: vi and emacs are probably the most common editors, leksah and yi are written in haskell, leksah is an ide. ghc is the main compiler, and ghci it's built-in REPL
23:51:47 <cognominal_> and is there some command that try to convert a function to the most readable form (whatever that mean)?
23:51:51 <unixty> and which editor? emacs is in lisp vim in C++
23:52:19 <cognominal_> sometimes pointfree is a loss and sometimes it is a win
23:52:33 <cognominal_> unixty, have you tried yi?
23:52:35 <jmcarthur> unixty: i suspect a majority of us use emacs, many use vi, some other other stuff
23:53:08 <pumpkin> I use textmate
23:53:09 <cognominal_> it is an editor all written in haskell that emulates either vi or emacs
23:53:10 <pumpkin> but am not too happy with it
23:53:10 <jmcarthur> unixty: rather, i suspect that emacs is more popular here than vi, maybe not a majority counting all editors
23:53:19 <wli> I just can't get lambdabot's command composition stuff to compose @pl and @undo
23:53:30 <Ethereal> I am addicted to gvim.
23:53:37 <jmcarthur> pumpkin: on os x i use aquamacs
23:53:43 <unixty> is it in portage?
23:53:54 <pumpkin> I think so
23:54:03 <pumpkin> well, a new release was today
23:54:07 <pumpkin> so it might not be fully up to date
23:54:09 <edwardk> unixty: there is leksah and yi which are written in haskell, there is a visual studio plugin, there is or was an eclipse plugin
23:54:18 <cognominal_> I wanted to dump emacs for something else for years because I hate elisp. With yi, I have almost dropped emacs
23:54:25 <edwardk> unixty: there is an emacs mode for haskell and vim supports syntax highlighting it
23:54:25 <jmcarthur> there was even an xcode plugin at one point i think
23:54:27 <poucet> Small question, how do you tend to structure new haskell projects if you plan to cabalize them?
23:54:31 <poucet> projectdir/src ?
23:54:51 <cognominal_> I tried vim, *emacs, textmate and not totally satisfied with any of them
23:55:04 <wli> @@ @pl @undo \rep m -> do { m ; rep m }
23:55:04 <lambdabot>  ap (>>)
23:55:06 <edwardk> unixty: i do most of my haskell development from vi out of reflex
23:55:13 <jmcarthur> yeah, there is always something to tick you off about your editor :\
23:55:20 <edwardk> @type ap (>>)
23:55:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (m a -> m b) -> m a -> m b
23:55:24 <unixty> thanks
23:55:29 <wli> Something is vomiting on let
23:55:46 <jmcarthur> edwardk: woah that's a weird one
23:55:56 <kyagrd> hugs by defalt sees module inside (meaning that it sees imported module's API inside the module we load), but ghci only sees the outside (exported names of the module we load)
23:56:04 <cognominal_> I supposed that when I will master haskell, I will do everything in yi.
23:56:09 <jmcarthur> is that an identity function?
23:56:10 <kyagrd> Can I make ghci see inside a module just like Hugs??
23:56:25 <jmcarthur> kyagrd: :m Module.Name
23:56:36 <jmcarthur> or to add a module to your context instead of switching to it, :m + Module.Name
23:56:45 <cognominal_> That's also a program that uses so many feature of haskell. Reading the source is difficult but very rewarding.
23:56:46 <edwardk> no it appears to keep applying your action to the base case, yielding an answer of the result type, its a bizarre probably strict-leaking mfix
23:56:54 <edwardk> er strictness-leaking
23:57:21 <kyagrd> Well if my module imports 10 library modules ... I have to type all 10 of them in like that.
23:57:35 <kyagrd> I just wanted to know if there exists a shortcut
23:57:37 <jmcarthur> wow. i have no idea of that is significant or not
23:57:59 <wli> edwardk: Mostly I use it in conjunction with execState or similar.
23:58:27 <jmcarthur> oh i didn't realize you got that from @pl output
23:58:35 <jmcarthur> now i see
23:59:34 <wli> I basically needed forever with a type allowing MonadCont to return something upon breaking the loop.
23:59:42 <wli> @type forever
23:59:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
