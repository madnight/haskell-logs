00:03:01 <wli> Data.UnionFind?
00:03:50 <edwardk> i have one i wrote a while back i could bundle if there isn't one
00:04:04 <edwardk> it used the ST monad for its operations though
00:04:20 <wli> There isn't one. I doubt people will mind ST.
00:07:10 <wli> I'm really shocked about the GC blackhole problem with hashtables.
00:07:59 <Cale> I'm really shocked that anyone actually cares about Data.Hashtable :)
00:08:55 <dolio> Does anyone, really?
00:09:20 <wli> I don't care about Data.Hashtable per se, but I vaguely think hashtables should at least be efficiently implementable in principle.
00:10:20 <edwardk> cale: folks are feeding the trolls ;)
00:10:20 <bos> jdh cares about it because it gives him something stupid to rant about.
00:10:55 <dolio> Yeah, well, he really cares about generating hits on his website or whatever.
00:11:03 <dolio> dons cares about the bad press he's generating.
00:11:21 <pumpkin> hmm, do I need to do anything special to get :%?
00:11:26 <pumpkin> > 5 :% 4
00:11:27 <lambdabot>   Not in scope: data constructor `:%'
00:11:29 <wli> import Data.Ratio
00:11:33 <pumpkin> I have that
00:11:35 <wli> import GHC.Real
00:11:36 <vixey> > 5 % 4
00:11:37 <lambdabot>   5%4
00:11:42 <pumpkin> I need to match on it
00:11:48 <wli> GHC.Real
00:12:07 <dolio> Other people who want to hate on haskell for being popular lately (on reddit, say), care that they have some nit to pick, whether or not they've actually written a haskell program where they wanted a hashtable... :)
00:12:16 <pumpkin> that did it, thanks
00:12:23 <pumpkin> why is it in GHC.Real?
00:12:28 <wli> I hope something like the 2-level flexible array arrangement (hash trie -structured or not) helps.
00:13:42 <pumpkin> slowly getting there
00:13:53 <pumpkin> next I need to write the stream/unstream for my lazy UArrs
00:14:10 <pumpkin> then throw together the rewrite rules and write a utility function wrappers
00:14:12 <pumpkin> and we should be good
00:14:18 <wli> I'll bet B/B+/etc. trees might run into similar problems with GC needing card marking.
00:14:19 <dolio> I was amused at a comment I saw that pointed out to Harrop that his "hash tables are necessarily faster than persistent trees" is essentially saying "imperative programming is necessarily faster than functional programming," which rather goes against his hyping of OCaml and F#. :)
00:15:36 <wli> I've rarely run into a need to go beyond the Data.Map API.
00:15:48 <SubStack> realized on the walk home that he could simplify a big part of his network program that seems prone to errors by exploiting laziness
00:15:57 <edwardk> well there _is_ a nugget of truth in that
00:15:57 <wli> I'm not entirely sure where genuine needs for hash tables would arise.
00:16:05 <SubStack> /me that
00:16:06 <edwardk> you do pay a logarithmic cost for persistence
00:16:25 <vixey> why is it logarithmic?
00:16:25 <wli> Maybe sparse matrices.
00:16:51 <pumpkin> it's also worth noting that most large data storage is still on tree-based structures rather than hashtables
00:16:57 <edwardk> vixey: you can emulate a mutable store with a map where previously constant accesses are now logarithmic time
00:17:15 <wli> But I vaguely doubt they'd be all that useful even then (e.g. R trees would do better).
00:17:16 <edwardk> so any imperative algorithm can me made immutable for a logarithmic cost
00:17:33 <vixey> oh I see
00:17:42 <vixey> but in practice, you might do better than logarithmic?
00:17:57 <wli> pumpkin: Depends on a lot of things. There are indeed hashed indices.
00:17:59 <edwardk> sure for some things you don't need the mutation
00:18:21 <wli> vixey: Specialized for particular cases where it just so happens to be possible you can do better.
00:18:42 <pumpkin> wli: I know, but even on something like bdb, I've never seen someone actually use the hash access method, even though it's supported... and most relational DBs provide hash indices but again I've never seen anyone use them
00:19:10 <pumpkin> ...and I've spent a fair amount of time looking at DBs :)
00:19:49 <wli> pumpkin: Locality of reference on them is usually guaranteed to be terrible by dint of collision avoidance.
00:20:40 <pumpkin> yeah, and you lose ordered traversal which is often useful... and it's pretty rare for most people to have databases large enough to make the logarithmic factor particularly noticeable
00:21:08 <pumpkin> maybe I just have never seen how people deal with petabytes of data :)
00:21:52 <wli> pumpkin: Pointwise search on categorical variables, certain kinds of string matching (albeit only using hashtables as sub-structures of the overall structure), I forget what else.
00:21:59 <mmorrow> @let lg x = log x / log 2
00:22:00 <lambdabot>  Defined.
00:22:11 <pumpkin> logBase 2?
00:22:25 <mmorrow> yesh
00:22:46 <edwardk> mmorrow: could be worse i had to come up with a nice algorithm to calculate it the other day ;)
00:23:00 <edwardk> (for Integer)
00:23:02 <mmorrow> edwardk: fun! ( :/ )
00:23:16 <edwardk> actually didn't turn out so bad
00:23:39 <mmorrow> nice. i've been looking at the C gmp api a little recently actually
00:23:47 <edwardk> @hpaste
00:23:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:23:54 <wli> Multiple precision BCD floating point is a holy terror.
00:23:59 <mmorrow> heh
00:24:31 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3446#a3446
00:25:02 <edwardk> computer science 101 binary search for the win
00:25:12 <mmorrow> edwardk: oh nice
00:26:22 <wli> If the numerical types are of fixed precision you can usually do better by taking apart the machine words behind the numbers with bit twiddling.
00:27:03 <edwardk> wli: yeah unfortunately the size of the limbs used in gmp are machine dependenct
00:27:17 <edwardk> er so it ties an otherwise portable implementation to machine details
00:27:28 <edwardk> and i immediately then have to scan over those bits anyways
00:27:36 <edwardk> so it doesn't change my asymptotics
00:27:54 <mmorrow> wli, edwardk: can you think off had of any good example code that goes (CULong -> CDouble)? (in haskell or C)
00:28:11 <mmorrow> i've got the inverse down, but am epic'ing on that way
00:28:16 <edwardk> mmorrow: as in how to convert 64 bits the hard way?
00:28:21 <mmorrow> exactly
00:28:38 <mmorrow> in particular, code that does it
00:29:03 <edwardk> nothing handy but i have a bunch of that sort of stuff in old 3d libs
00:29:13 <edwardk> trying to marshal as ieee or something?
00:29:20 <mmorrow> edwardk: exactly
00:30:17 <wli> mmorrow: I'm FFI clueless. I only know how to do it in C and/or TTL logic.
00:30:22 <mmorrow> edwardk: hmm, yeah i should look through some graphics code, hadn't thought to look there..
00:30:23 <BrokenClockwork> Hey, does someone know greedy programming-method in Haskell?
00:30:29 <mmorrow> wli: if it's in C, even better
00:30:56 <vixey> you just do it BrokenClock
00:31:03 <edwardk> easiest way would be to take the desired exponent, and just raise 2 to that power, then take your mantissa bits, manually set the next one up, convert it to a double, shift it 52 places and multiply by the first
00:31:11 <wli> There's stuff like __builtin_fls() etc. to fart around with.
00:31:58 <wli> (in gcc at least)
00:32:38 <edwardk> you'll have to handle nan's manually
00:32:52 <mmorrow> (in particular, how's it usually done? so i decode a double into (s,e,c) := (sign,(unbiased) exponent,significand), and  x = s * (1 + c) * 2 ^ e, but how should i start with an integral `x' and solve for (c,e)?)\
00:33:07 <edwardk> which will depend on if your platform uses ieee signaling and non-signalling nan's
00:33:12 <wli> There are C things to dissect floating point numbers floating around somewhere.
00:33:36 <mmorrow> edwardk: ugh, yeah the spec is nasty
00:33:51 <mmorrow> wli: i'll checkout __builtin_fls
00:36:54 <wli> ugh I can't find the exponent/mantissa/etc. extraction functions/macros
00:37:30 <BrokenClockwork> Why does nothing happen, when I write: main = interact reverse and start it with main?
00:37:38 <mmorrow> wli: the thing i'm stumped on is how to choose a (e,c), given only an x. (so the equivalent of ==> int2double# 42)
00:37:53 <BrokenClockwork> I wrote a String-> String palindrome function before and main = interact palin does work very well
00:38:21 <BrokenClockwork> oh nevermind, I remember what the issue was
00:38:27 <BrokenClockwork> unlines/unwords, etc.
00:38:28 <mmorrow> wli: because there's not a unique choice, and i'm not sure how to determine the "best" one
00:39:04 <mmorrow> for instance, (3.0 :: CDouble) decodes to:
00:39:38 <mmorrow> (one sec, starting ghci)
00:39:46 <boegel> can one implement instances of typeclass X in a new, self-defined typeclass Y?
00:40:18 <boegel> or, rather, force implementation of function F of typeclass X in a new typeclass Y?
00:41:15 <mmorrow> ghci> decode64 3.0
00:41:15 <mmorrow> (0,1,2251799813685248)
00:41:16 <mmorrow> and
00:41:23 <mmorrow> ghci> b2d (prec bin64 - 1) 2251799813685248
00:41:23 <mmorrow> 0.5
00:41:42 <mmorrow> so, 3.0 ==> (1,1,0.5)
00:41:55 <mmorrow> > 1 + (1 + 0.5) * 2 ^ 1
00:41:56 <lambdabot>   4.0
00:41:59 <mmorrow> oops
00:42:09 <mmorrow> gah!
00:42:15 <mmorrow> oh
00:42:18 <mmorrow> > 1 * (1 + 0.5) * 2 ^ 1
00:42:19 <lambdabot>   3.0
00:42:43 <mmorrow> but, given (3 :: CULong), howtf to find (1,0.5)??!?
00:45:11 <mmorrow> ooh, i think i may have just realized
00:46:26 <mmorrow> soo there *is* a unique choice, since significand has to be positive
00:46:49 <mmorrow> decode64 5 ==> (0,2,0.25)
00:46:51 <edwardk> heading to bed
00:46:56 <mmorrow> edwardk: night
00:46:57 <edwardk> good luck
00:47:03 <mmorrow> heh, thx
00:49:17 <mmorrow> so given (x :: CULong), the exponent is floor (log (fromIntegral x) / log 2)
00:49:52 <vixey> floor . lg . fromIttegral
00:55:57 <boegel> @src min
00:55:57 <lambdabot> min x y = if x <= y then x else y
00:56:01 <boegel> @src minimum
00:56:01 <lambdabot> minimum [] = undefined
00:56:02 <lambdabot> minimum xs = foldl1 min xs
00:56:13 <boegel> @src foldl1
00:56:13 <lambdabot> foldl1 f (x:xs) = foldl f x xs
00:56:13 <lambdabot> foldl1 _ []     = undefined
01:03:15 <refold> @users
01:03:16 <lambdabot> Maximum users seen in #haskell: 658, currently: 577 (87.7%), active: 8 (1.4%)
01:08:45 <mmorrow> woo, got it
01:32:40 <mun> hi
01:32:49 <mun> is LIB_DEFN a variable if a function is called ana_LIB_DEFN?
01:34:51 <ejt> mun: not really sure what you're talking about
01:47:37 <ryosei> > [A..z]
01:47:38 <lambdabot>       Failed to load interface for `A':
01:47:38 <lambdabot>        Use -v to see a list of the fi...
01:47:51 <ryosei> > ['A'..'z']
01:47:52 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
01:48:28 <ryosei> > ['A'..
01:48:29 <lambdabot>   <no location info>: parse error on input `;'
01:48:33 <ryosei> > ['A'..]
01:48:34 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\12...
01:52:40 <pozic> How can these dependencies be resolved? http://paste.debian.net/32692/
01:55:11 <kadaver> P.many (P.noneOf (P.string "Connection"))
01:55:18 <kadaver> why is that not legal Parsec
01:55:42 <fasta> kadaver: noneOf takes a list AFAIK
01:55:49 <kadaver> I thought Parsec was good but it seems easier to jsut write my own parser really
01:56:23 <vixey> your gonna have to learn to read error messages either way
01:57:10 <ejt> kadaver: Parsec is great
01:57:39 <yitz> kadaver: don't lose faith. there are just a few basic tricks you need to catch on to, then you'll see that parsec is worth it.
01:57:47 <kadaver> so how can I say skip until Something ?
01:58:00 <ejt> the main problem with that line is you're not telling Parsec what it _should_ be looking for
01:58:18 <pozic> Why are packages "excluded" by Cabal? Why would it not be possible to use QuickCheck 1 and 2 in the same program?
01:58:27 <ejt> you've said "many things, but not 'Connection'" (ignoring the noneOf issue)
01:58:47 <ejt> many chars? many identifiers ?  many expressions ?
01:59:50 <ejt> if you jot down the grammar you're trying to parse I'll give you a hand with the parsec
02:01:34 <ejt> (you could try manyTill)
02:02:15 <ejt> eg, manyTill anyChar (try (string "Connection"))
02:03:22 <pozic> It's a known problem: http://www.nabble.com/Problem-with-cabal-install-where-package-requires*-mutually-exclusive-versions-of-another-package-td22510336.html
02:08:52 <CalJohn> When I run cabal update, I get the error "cabal: getHostByName: does not exist".  Googling shows this to be linked to $http_proxy being set, but mine is not set.  Any ideas on what the problem is?
02:15:37 <mun> i have a question about Monads. why does IO need Monads (http://en.wikipedia.org/wiki/Monads_in_functional_programming#I.2FO) ?
02:15:57 <vixey> huh ?
02:16:21 <thomastc> mun: because IO is stateful
02:16:31 <koeien> mun: because IO would violate referential transparency
02:16:34 <vixey> because IO is IO ...
02:16:36 <thomastc> i.e. if I call readLine twice, I might not get the same result
02:17:04 <mun> thomastc: but how do Monads prevent that?
02:17:10 * zakwilson is still waiting for the epiphany.
02:17:15 <zakwilson> I half get it.
02:17:23 <vixey> I don't know what the question is
02:17:26 <thomastc> ok first off, it's not called readLine, that was me confusing languages :)
02:17:32 <CalJohn> zakwilson: we are in the same position then, :)
02:17:47 <boegel> there is no standard function to do something like "splitIn 3 [1..10]" which would give you [[1,2,3],[4,5,6],[7,8,9],[10]] it seems, is that right?
02:18:07 <augustss_> boegel: I wish there were!
02:18:09 <thomastc> mun: when using the IO monad, you don't actually *call* an IO action
02:18:16 <mun> vixey: my question is why do IO operations use monads.
02:18:19 <ppavelV6> @hoogle Int->[a]->[[a]]
02:18:19 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
02:18:19 <lambdabot> Prelude drop :: Int -> [a] -> [a]
02:18:19 <lambdabot> Prelude take :: Int -> [a] -> [a]
02:18:22 <augustss_> boegel: I use that function a lot
02:18:26 <thomastc> rather, you write a function that returns the action *itself* (but does not execute it)
02:18:36 <vixey> mun: Monads are the perfect way to do IO
02:18:40 <zakwilson> I can follow a definition of what a monad *is*. What I don't really get is how they do stateful things.
02:18:46 <boegel> augustss_: but you defined it yourself then?
02:18:46 <ivanm> mun: what should they use then?
02:18:54 <augustss_> boegel: yes
02:18:58 <boegel> augustss_: k :)
02:18:59 <ski> zakwilson : ever looked at the implementation of a state monad ?
02:19:00 <ppavelV6> zakwilson: the answer is they don't
02:19:01 <ivanm> IO was the driving force behind including monads in haskell, weren't they?
02:19:06 <fasta> boegel: and so did I
02:19:09 <boegel> :)
02:19:12 * boegel will too then
02:19:13 <augustss_> ivanm: yes
02:19:14 <zakwilson> No, ski.
02:19:25 <ppavelV6> zakwilson: they construct a way to do an action.
02:19:31 <augustss_> ivanm: at least initially
02:19:35 <zakwilson> I've read descriptions of what they do.
02:19:36 <ivanm> augustss_: good, I know _something_ of haskell history then ;-)
02:19:46 <ivanm> augustss_: well, "initial inclusion" then
02:19:49 <ski> zakwilson : consider a monad `State Integer' that has one hidden state of type `Integer'
02:19:54 <vixey> mun: Did you ever see like ocaml or scheme or whatever, they would have print : String -> ()
02:20:00 <vixey> ?
02:20:14 <mun> thomastc: but how does not calling the actual IO operation make it safer?
02:20:17 <mun> vixey: sorry, no
02:20:41 <thomastc> mun: because you specify how the actions are to be sequenced
02:20:43 <vixey> mun: well anythng like C or java then, basically they would have puts : String -> IO
02:20:45 <vixey> oops
02:20:53 <CalJohn> vixey: scheme doesn't have type declarations...
02:20:53 <vixey> puts : String -> void .. something like that yeah?
02:20:53 <wli> It's basically CPS IO with weird type system issues resolved.
02:21:00 <vixey> CalJohn: that's totally irrelevant
02:21:06 <boegel> augustss_, fasta: I guess you guys defined it something like this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3447#a3447
02:21:09 <mun> vixey: yeah
02:21:14 <ski> zakwilson : so, one would expect operations like `put :: Integer -> State Integer ()' and `get :: State Integer Integer'
02:21:21 <vixey> mun: well there is two reasons that can't work in Haskell -- do you know them ?
02:21:24 <CalJohn> vixey: oh, you're saying that it takes a string and returns nil
02:21:30 <vixey> CalJohn: yeah
02:21:38 * ppavelV6 should do something about hpaste integration in haskell mode
02:21:51 <fasta> Can anyone tell me how to install containers? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3448#a3448
02:21:53 <ivanm> ppavelV6: in emacs?
02:22:03 <ppavelV6> ivanm: vim
02:22:11 <ivanm> oh, I don't care then :p
02:22:15 <ivanm> fasta: shouldn't they already be installed?
02:22:24 <ppavelV6> ivanm: it is there but seems to be broken
02:22:37 <mun> vixey: no -- i'm very new to haskell
02:22:42 <zakwilson> ski: those look like getters and setters like you'd see in many OO languages if State was a Smalltalk-style class.
02:22:46 <fasta> ivanm: yes, but for some reason it isn't.
02:23:09 <ivanm> fasta: "ghc-pkg list containers" reveals nothing?
02:23:11 <ppavelV6> ivanm: just wait whe somebody build vim with haskell scripting support :)
02:23:18 <ivanm> AFAIK, it isn't upgradeable...
02:23:24 <ivanm> ppavelV6: heh
02:23:31 <fasta> ivanm: containers-0.2.0.1 is installed, but not 0.2.0.0 which is needed by some package
02:23:36 <ski> @type \n -> unfoldr (\xs -> if null xs then Nothing else Just (splitAt n xs)) -- boegel
02:23:37 <lambdabot> forall a. Int -> [a] -> [[a]]
02:23:39 * ppavelV6 wakes up on the keyword Smalltalk
02:23:48 <ivanm> fasta: oh?
02:23:56 <ivanm> which package needs exactly 0.2.0.0?
02:24:08 <fasta> ivanm: I will check again somewhat more thoroughly
02:24:10 <ppavelV6> ivanm:  vim?  i'm afraid it's more upgradable than me
02:24:26 <thomastc> mun: I find http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm the most useful introduction to the subject
02:24:42 <mun> thomastc: thanks for that
02:25:06 <ivanm> ppavelV6: was talking to fasta ;-)
02:25:11 <thomastc> there are many that tackle it from the mathematical side, which you don't really need when you don't have the bigger picture first
02:25:16 <ivanm> fasta: see if "ghc-pkg check" returns anything
02:25:25 <ski> zakwilson : not quite .. something of type 'State Integer Blah' doesn't contain a value of type `Integer' .. it only represents a computation that threads an `Integer' through it
02:25:33 <ppavelV6> ivanm: sorry. too busy channel today for me to follow :)
02:25:41 <ivanm> ppavelV6: heh
02:25:46 <boegel> ski: would that be better than what I have? (except for the Maybe return type)?
02:26:04 <ski> boegel : no idea (haven't looked at the paste)
02:26:19 <boegel> ski: hmmk :)
02:26:26 <boegel> @type unfoldr
02:26:27 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:26:36 <fasta> ivanm: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3449#a3449 <- everything seems to be broken
02:26:44 <ski> boegel : it should be about the same, i think
02:26:50 <boegel> ski: hmmk
02:27:02 <boegel> ski: thanks for sharing it, haven't run into unfoldr before
02:27:43 <zakwilson> ski: I get the idea, but I don't fully comprehend it. I probably won't until I use Haskell more.
02:27:53 <ski> > unfoldr (\n -> if n > 100 then Nothing else Just (n,2^n)) 1
02:27:54 <lambdabot>   [1,2,4,16]
02:28:19 <swiert> a
02:28:29 * zakwilson remembers, long ago trying to comprehend was a closure was.
02:28:46 <ski> zakwilson : if we shorten `State Integer' to just `M', we could define it as `newtype M a = MkM (Integer -> (Integer,a))
02:29:08 <zakwilson> Finally some example made it click.
02:29:09 * Gracenotes found State very confusing at first
02:29:31 <ski> zakwilson : the point is that an `M'-action here is just a function that takes a starting state of type `Integer', and return a pair of an ending state, and some other result
02:29:53 <wli> @type \n -> snd . until (null . snd) (\(xs, ys) -> case splitAt n ys of { ([],_) -> (xs, []) ; (ws@(_:_), zs) -> (ws : xs, zs) }) . (,) []
02:29:54 <lambdabot> forall a. Int -> [a] -> [a]
02:29:59 <kadaver> so how do you parse out stuff then? i have a bunch of stuff I just want to ignore and then start again at a trigger-word
02:30:10 <kadaver> there must be a way to skip characters in Parsec
02:30:19 <vixey> look at the documentation and examples
02:30:26 <kadaver> yeah I did
02:30:29 <kadaver> theyre not that great
02:30:34 <vixey> yes they are
02:30:37 <ejt> kadaver: scroll up and look at what I said last time you asked
02:30:45 <ejt> ie. manyTill
02:31:55 <wli> @type \n -> snd . until (null . snd) (\(xs, ys) -> let (ws, zs) = splitAt n ys in case ws of { [] -> (xs, []) ; _ : _ -> (ws : xs, zs) }) . (,) []
02:31:56 <lambdabot> forall a. Int -> [a] -> [a]
02:32:03 <zakwilson> I still kindasorta get it. I get it enough to use monads mostly right. I may be too tired for anything to click right now.
02:32:11 <kadaver> ejt:must have lost the connection there
02:32:18 <ski> zakwilson : actually, "What the hell are Monads?" <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/researchmonads.html> by Noel Winstanley, might explain state monads better
02:32:48 <ejt> kadaver: I'll paste into a query
02:33:06 <wli> That's easy. Monads are toxic nuclear waste burritos that compute.
02:33:34 <wli> Kind of like Taco Bell fare that's evolved sentience.
02:33:56 <Gracenotes> with State it's important to keep track of the big picture
02:34:07 <zakwilson> ski: thanks. You are most helpful.
02:34:25 <zakwilson> The link is 404 though.
02:35:02 <wli> Watch out for pseudomonads, though. They'll give you eye infections!
02:35:04 <Gracenotes> particularly, it's not enough to know just what >>= and return do for state; also get and put, how to 'exit' state computations in the first place.. etc.
02:35:19 <ski> zakwilson : er, sorry, there should be a `/' between the `research' and the 'monads.html' at the end
02:35:22 <Gracenotes> or, rather, run state computations
02:35:31 <fasta> What exactly does this mean? When I do ghc-pkg list, I do have these packages: runhaskell Setup.hs configure => Setup.hs: At least the following dependencies are missing:
02:35:32 <fasta> GLUT -any, OpenGL -any, arrows -any, parsec >=3
02:35:52 <wli> My monad humor must be far too lame.
02:36:03 <doserj> fasta: try --user
02:36:13 <WorkyBob> fasta: is your ghc-pkg updated to 6.10.2?
02:36:17 <Gracenotes> wli: surely you mean tame
02:36:20 <WorkyBob> or is it listing deps that you *had* in 6.10.1
02:36:30 <fasta> WorkyBob: yes, it is
02:36:47 <WorkyBob> ugh, you're having the probs I had with 6.10 then
02:36:54 <doserj> fasta: runhaskell Setup.hs uses --global by default. cabal uses --user by default.
02:36:55 <WorkyBob> I ended up deleting it all and reinstalling it in the end :/
02:37:45 <fasta> doserj: I had forgotten about that, since I used cabal mostly, but since that currently doesn't work.
02:37:50 <fasta> ..
02:40:21 <WorkyBob> I really don't get why cabal uses --user by default
02:40:33 <WorkyBob> if I ask it to cabal *install* something - I expect it to get installed on my computer
02:40:35 <WorkyBob> for everyone
02:40:53 <doserj> WorkyBob: than cabal install would work only for root
02:40:59 <zakwilson> ski: again, thanks. Much better. I will read it when I'm awake.
02:41:00 <WorkyBob> and?
02:41:07 <WorkyBob> doserj: also, I didn't say take away the --user flag
02:41:13 <WorkyBob> only that --global should be the default
02:41:30 <doserj> WorkyBob: that would be another thing everybody would ask here: why doesn't cabal install just work?
02:41:34 <zakwilson> My basic thinking about monads, at least those that do state and IO has been something like closures over the real world.
02:41:36 <WorkyBob> doserj: it does
02:41:39 <WorkyBob> at the moment it doesn't
02:41:57 <WorkyBob> if I sudo cabal install xyz, I *don't* get an xyz that I can use
02:42:04 <WorkyBob> if it used --global by default I would
02:42:27 <doserj> if you cabal install xyz, you get an xyz that you can use :)
02:42:31 <WorkyBob> no you don't
02:42:43 <WorkyBob> you need to set up ghc to actually look in the right directories
02:42:51 <doserj> ???
02:42:54 <Saizan> well, most people don't like to install libraries system-wide, unless they do so with their distro package manager.
02:43:03 <WorkyBob> Saizan: really?
02:43:10 <WorkyBob> that seems like a pretty large assumption to me
02:43:23 <WorkyBob> that people wouldn't expect a command containing *install* to install something
02:43:30 <Saizan> it installs it
02:43:39 <WorkyBob> not in a way that you can actually use
02:43:40 <Saizan> and ghc can find my user-installed package just fine.
02:43:42 <WorkyBob> without reconfiguring ghc
02:43:52 <WorkyBob> at least on OS X, by default, it can't
02:43:54 <Saizan> i don't have to reconfigure anything
02:44:01 <Saizan> that's another problem, then
02:44:18 <WorkyBob> also, think about any other command you'd ever run containing the word install
02:44:33 <WorkyBob> package manager install <-- gonna be available to all users
02:44:38 <WorkyBob> make install <-- gonna be available to all users
02:44:39 <WorkyBob> ...
02:44:57 <jedai> WorkyBob: most of them won't work except if you use sudo or a root account
02:45:10 <Saizan> that's only my distro package manager, and i specifically don't want to mix the two.
02:45:16 <WorkyBob> jedai: indeed – most of them require you to specify an extra flag to do it in your user dir
02:45:22 <WorkyBob> which is exactly what I'm proposing
02:45:58 <jedai> And I agree with Saizan that most of us prefer to avoid installing system wide by any other means than the distrib package manager
02:46:17 <WorkyBob> "most" is a pretty wide ranging word
02:46:21 <jedai> It just open too much risk for conflict
02:46:27 <WorkyBob> from my experience in here "most" people use OS X or Windows
02:46:36 <WorkyBob> and hence don't have a package manager by default
02:46:57 <WorkyBob> it sounds like you're applying something not only from linux, but from specific distros of linux to a tool that's meant to be platform independant
02:47:21 <jedai> WorkyBob: And most of these people don't care that the installation isn't system wide because there's only one haskell coder on their box (themselve)
02:47:41 <WorkyBob> and they similarly wouldn't care if it were system wide
02:47:48 <jedai> WorkyBob: Right
02:48:02 <jedai> WorkyBob: But the Linux users would
02:48:13 <WorkyBob> okay... so conclusion from this discussion: it would make life harder for linux users, and easier for OS X users
02:48:20 <Saizan> btw, why your ghc can't find user-installed packages?
02:48:21 <WorkyBob> can we have an env variable or config file please :)
02:48:33 <WorkyBob> Saizan: dunno, it's in the default state
02:48:40 <Saizan> the config file is already there..
02:48:45 <WorkyBob> where?
02:48:46 <Saizan> ~/.cabal/config
02:48:55 <jedai> WorkyBob: so you have one choice which is likely to please everyone and one who is likely to displease most (many Haskell coders use Linux) and don't help the others
02:49:02 <Saizan> you can set user-install: False in there
02:49:11 <WorkyBob> neat
02:49:11 <WorkyBob> :)
02:49:35 <WorkyBob> jedai: I suspect your statement about most haskell coders using linux is false
02:49:55 <WorkyBob> and OS X users are walking evidence that it doesn't please everyone
02:50:06 <WorkyBob> if it pleased everyone, I wouldn't be in here arguing ;)
02:50:19 <Saizan> i wonder if all OS X users experience that
02:50:21 <jedai> WorkyBob: You have a problem with user-installed package on OSX, ok. But most OSX users don't complain, so your problem don't seems to be really all that important
02:50:26 <Saizan> it should be reported as a bug.
02:50:38 <jedai> It's a bug that should be reported and corrected
02:50:59 <jedai> But we shouldn't change cabal-install defaults just because you had one problem with it
02:51:43 <WorkyBob> jedai: that wasn't what I was suggesting
02:51:52 <WorkyBob> I was suggesting that it's inconsistant with the rest of the unix world
02:51:58 <WorkyBob> where installing globally is the default
02:52:03 <WorkyBob> and installing locally needs an extra flag
02:52:18 <WorkyBob> s/unix world/world/
02:53:54 <jedai> WorkyBob: In fact most Games/Software that I tried to install on Windows recently tended to propose user installation by default...
02:54:04 <boegel> suppose I have a function with an undeterministic results , i.e. a -> IO b
02:54:05 <fasta> When trying to load a package, I get package foo ... linking ... <interactive>: <some filename> : unknown symbol '<some mangled symbol>'. ghci-haskeline: unable to load package 'foo'. (this is with 6.10.2)
02:54:27 <Saizan> fasta: any package?
02:54:40 <boegel> is there a standard function "(a -> IO b) -> b -> IO [b]" which applies that function a number of times to the same argument?
02:54:46 <jedai> WorkyBob: I think some of the others "language specific pkg manager" install locally by default too (on Linux and other OS) IIRC
02:55:03 <boegel> I'm probably not getting the type 100% right yet, there should be an Int parameter too
02:55:19 <fasta> Saizan: no, not any package.
02:55:55 <fasta> Saizan: so, only some package ;)
02:56:09 <jedai> WorkyBob: Fact is most of the other tools for installation you're thinking of are primarily sysadmin oriented, cabal-install is programmer oriented and I find it a nice default choice for its purpose :)
02:56:14 <fasta> WorkyBob: it's also more secure.
02:56:33 <ziman> @unpl \n f x -> mapM f . replicate n x
02:56:34 <lambdabot> \ n f x c -> mapM f (replicate n x c)
02:56:37 <ziman> @pl \n f x -> mapM f . replicate n x
02:56:38 <lambdabot> flip ((.) . (.) . mapM) . replicate
02:56:39 <Saizan> so, it can be that you've compiled foo against a package bar from which the mangled symbol came, but then recompiled the exact same version of bar, producing a different ABI
02:57:03 <WorkyBob> fasta: how is it more secure?
02:57:06 <Saizan> ghc-pkg check should be able to check that, iirc
02:57:45 <fasta> Saizan: the mangled symbol came from Haskell source for which I deleted all the .hi and .o files before trying again with 6.10.2
02:58:18 <jedai> WorkyBob: You don't have to use admin privileges to install those packages (after all there is no security team for Hackage)
02:58:57 <boegel> > map (\n -> (n*2) `mod` 2) [1..5]
02:58:58 <lambdabot>   [0,0,0,0,0]
02:58:59 <fasta> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3451#a3451 <- most of it is broken, but I have no idea what to about them. I think WorkyBob had a similar problem and just deleted all packages.
02:59:15 <boegel> > map (\n -> (n `mod` 2)*2) [1..5]
02:59:16 <lambdabot>   [2,0,2,0,2]
02:59:41 <fasta> WorkyBob: no Haskell package will be able to overwrite system files, unless the OS security fails.
02:59:47 <boegel> > map (\n -> round $ n*2/2) [1..5]
02:59:48 <lambdabot>   [1,2,3,4,5]
03:00:05 <WorkyBob> jedai: you don't *have* to use admin privaleges with --global being the default either
03:01:14 <Saizan> fasta: uhm, i get the same output from ghc-pkg check, but that makes me think it's broken
03:01:25 <jedai> WorkyBob: No, but the --user installation is more secure (you agree there I suppose) and is most often enough, so it makes sense to make it the default and let the advanced user change it if he want too
03:01:48 <WorkyBob> jedai: I don't think it's more secure no
03:01:54 <fasta> Saizan: what to do*
03:02:01 <WorkyBob> the --global option yells "gief more permissions" normally
03:02:35 <Saizan> fasta: i don't know, sorry :\
03:02:56 <doserj> the PAPI_INCLUDE_DIR problem is well known
03:03:20 <jedai> WorkyBob: In case you didn't notice there is a author provided Setup.hs with a cabal package, if you give the permissions to cabal to install globally, you allow this setup script to do whatever he want to on your computer.
03:03:38 <WorkyBob> jedai: uhhuh...
03:03:41 <raxas> WorkyBob: consider using gentoo linux distro, the best of all. our infrastructure for installing haskell stuff "standard way" is adequate
03:03:48 <WorkyBob> that doesn't make it less secure
03:03:58 <WorkyBob> that makes not checking if you have a trojan before running sudo insecure
03:04:17 <jedai> WorkyBob: The fact is that you _need_ to give those permissions if you want to install globally so the global installation is less secure than the local one
03:04:27 <WorkyBob> no, no it's not
03:04:39 <WorkyBob> running sudo is less secure
03:04:40 <WorkyBob> and always is
03:04:43 <WorkyBob> and you always know that
03:05:04 <fasta> doserj: Britney Spears is well known in some circles, but PAPI_INCLUDE_DIR returns 30 results on Google, most of them (probably all) being useless.
03:05:22 <jedai> WorkyBob: Well yes... And you need to run sudo to install globally thus the global installation is less secure
03:05:37 <WorkyBob> jedai: that doesn't make global installation being the default less secure
03:05:48 <WorkyBob> that means "think about whether you want to use sudo and add --user"
03:05:51 <thomastc> if there is no agreement... maybe there should be no default at all :) then you can't accidentally do it wrong
03:05:53 <doserj> fasta, try this: ghc-pkg describe rts | sed 's/PAPI_INCLUDE_DIR//' | ghc-pkg update -
03:06:16 <WorkyBob> thomastc: that would defeat cabal "just working"
03:06:26 <WorkyBob> (but then, the current default does that on OS X too)
03:06:46 <fasta> doserj: nothing is broken now, but let's see whether it fixes the real problem.
03:06:52 <jedai> thomastc: WorkyBob is almost the only user I have seen that complained about the default... And it seems it's because of a bug that prevents cabal from "just working" on his configuration
03:07:17 <WorkyBob> jedai: from what I understood from dcoutts several months ago there was a fairly active discussion about what the default should be
03:07:18 <thomastc> I would also prefer global install as the default
03:07:30 <WorkyBob> that several people wanted it in either direction
03:07:31 <thomastc> it can easily detect and warn if it's not done as root
03:07:58 <jedai> thomastc: Really why ? Are you a sysadmin that needs to install package for several users ?
03:08:00 <Saizan> btw, better to use --root-cmd= rather than sudo cabal
03:08:03 <WorkyBob> jedai: as I said many times – your "most" people is really an "I and Saizan at least, which is a larger number than you"
03:08:20 <Saizan> and fasta!
03:08:20 <fasta> doserj: I still have the same problem (unknown symbol). I think I will just extract the useful pieces from the library and be done with it.
03:08:31 <Saizan> really, it's pointless to discuss the numbers on irc
03:08:41 <WorkyBob> jedai: personally, I prefer my system organised as things that are apropriate for all users available to all users
03:08:46 <WorkyBob> which is roughly the same reason as you have
03:08:58 <WorkyBob> you prefer your system untouched by anything but your package manager which doesn't work right
03:19:13 <dolle> I have a weird problem. I'm writing a game, and are trying to cap the framerate with threadDelay. When I run the program in ghci, threadDelay can delay the thread for very small time intervals, but when running the compiled program, it seems like threadDelay can't delay my thread for less than 40ms.
03:19:50 <thomastc> jedai: I am currently the only user of those packages
03:20:14 <thomastc> but there's no reason why others whom I allow on my system shouldn't be able to use them
03:20:33 <thomastc> when I install stuff, I'm in "sysadmin" mode
03:20:43 <thomastc> not in "haskell developer" moed
03:21:48 <thomastc> if it goes into /usr/local it'll normally not interfere with the package manager, at least not on distros I've encountered
03:22:12 <Saizan> dolle: are you compiling with -threaded? also, compiled code tends to switch between haskell threads less promptly because it allocates less
03:23:03 <mmorrow> lol, i just saw this for the first time:
03:23:05 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pony
03:23:06 <Saizan> (i'm suggesting -threaded since ghci uses the threaded runtime, and that might be relevant)
03:23:18 <dolle> Hmm, -threaded doesn't do a difference.
03:23:19 <thomastc> btw the comparison with the system's package manager is unfair... compare to stuff like cpan, which also does global install by default iirc
03:23:28 <Saizan> mmorrow: tried it?:)
03:23:41 <mmorrow> i peeked at the code and ruined it :(
03:23:48 <mmorrow> (still building it though..)
03:24:13 <mmorrow> heh
03:24:27 <Saizan> that package lies.
03:24:31 <mmorrow> haha
03:24:44 <mmorrow> that's a suprisingly good ascii-art pony though
03:24:50 <mmorrow> oh
03:24:51 <dolle> Saizan: Yeah, I also tried with +RTS -C0, as I read somewhere that the default context switch intervals where 20ms.
03:24:52 <mmorrow> unicorn
03:24:59 <dolle> were*
03:26:05 <ski> @quote fruit
03:26:05 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
03:26:50 <ivanm> s/a banana/bananas/
03:27:01 <daf> ivanm: not really
03:27:19 <Axman6> ivanm would know, he's a banana bender
03:27:24 <ivanm> daf: what, you're trying to say that fruit flies like only one specific banana?
03:27:26 <ivanm> Axman6: heh
03:27:39 <daf> ivanm: no, that's not how English works
03:27:41 * ivanm actually doesn't like bananas... then again, he isn't a fruit fly ;-)
03:27:46 <vixey> @seen monochrom
03:27:46 <lambdabot> monochrom has changed nick to not-math.
03:27:46 <lambdabot> I saw not-math leaving #haskell-blah and #haskell 4h 56m 33s ago, and .
03:27:50 <Axman6> daf: it is actually
03:27:53 <ivanm> daf: why not?
03:28:00 <daf> there's no why.
03:28:07 <vixey> preflex: seen jkff
03:28:08 <preflex>  jkff was last seen on #haskell 17 days, 19 hours, 56 minutes and 48 seconds ago, saying: Not all of them. There was a thread in haskell-cafe that provided counterexamples: iirc, they were about Either
03:28:16 <daf> "fruit flies like a banana" means the same as "fruit flies like bananas"
03:28:19 <Axman6> Fruit flies like bananas makes perfect sense
03:28:22 <validuser> part of the joke is that "fruit flies" is/are ambigious
03:28:24 <daf> both make sense
03:28:26 <ivanm> how does English "work"? it never seems to expend any energy to perform actions AFAICT...
03:28:27 <ivanm> ;-)
03:28:36 <daf> validuser: right
03:28:41 <ivanm> validuser: sshhh!!! never get in the way of a good argument!
03:28:41 <daf> chaning it makes it no longer funny
03:28:49 * validuser shuts up
03:28:53 <ivanm> daf: there's a slight change of meaning IMHO
03:29:06 <daf> you are welcome to your opinion
03:29:10 <ivanm> "fruit flies like a banana" => "fruit flies wouldn't mind having a banana right now"
03:29:13 <ivanm> daf: heh
03:29:27 <daf> but I hold that the joke wouldn't have been made if people wouldn't have understood it as I suggest
03:29:35 <daf> it is one of my favourite jokes
03:29:36 <Saizan> dolle: i guess you need someone with more knowledge of GHC RTS, like on haskell-cafe@ or ghc-users@
03:29:46 <daf> prescisely because it hinges on the ambiguity of language
03:30:21 <ivanm> thankfully programming languages aren't (usually) as ambiguous as spoken languages...
03:30:47 * ivanm had the weird case today of a student showing Python code that successfully used a non-initialised variable in a comparison :s
03:31:27 <ivanm> considering that the only use of Python I have is for teaching this course, it might be legitimate, but I couldn't seem to duplicate it in other scenarios (but running his code worked)
03:31:47 <trofi^w> @src id
03:31:47 <lambdabot> id x = x
03:31:57 <ski> (.. there was a time when i mistakenly wrote `syntax-rulez' if i didn't watch out)
03:36:51 <thomastc> ivanm: I'd be curious to see that code...
03:37:35 <dolle> Saizan: Thanks, I'll try that
03:45:19 <Ninju> is there any well to tell if a file path is a directory?
03:45:21 <Ninju> so
03:45:24 <Ninju> FilePath -> IO Bool
03:45:56 <Ninju> oh wait, haha, in Hoogle I was doing FilePath -> Bool before
03:46:06 <Ninju> nevermind
03:48:27 <kadaver> "Referer: http://localhost:8080/" ; thats the only info I got from the http request as far as info of what the user did. but he also pushed a submit button which means submitting a field of text. is that supposed to come in the same place?
03:57:26 <mmorrow> kadaver: depending on the http method the form is using, it'll either be attached to the url (GET), or in the body (POST)
04:00:34 * mmorrow votes for cabal-install to install globally by default
04:01:55 <kadaver> the referer is the body right?
04:02:17 <mmorrow> if [[ "root" != `whoami` ]]; then exec installLocally; fi; exec installGlobally
04:02:51 <mmorrow> kadaver: the body follow the header, and the header ends with the first empty line
04:05:14 <mmorrow> well, i should say cabal-install should check if it's root, and if so by no means install into root's (or whoever's if `whoami` is root, but it's sudo so some env vars point to who-knows) home dir
04:05:40 <mmorrow> i think that's reasonable
04:07:17 <mmorrow> sure that means you're building as root though... hmm, TH and the ability to write a Setup.lhs make that undesireable.
04:07:48 <Saizan> yeah, if i ever need a global install i use --global --root-cmd=sudo
04:07:53 <mmorrow> ok, re-doing my vote round 3: install globally via sudo by default
04:08:04 <mmorrow> Saizan: i never need a local install
04:08:32 <mmorrow> i don't know of any package managers that install locally by default either
04:08:50 <Saizan> mmorrow: my point was that "sudo cabal" is not what you should use for a global install
04:08:52 <mmorrow> (well, actually they will if they're not root, but then they'll build as root)
04:09:11 <mmorrow> Saizan: yes, i don't want to build as root.
04:09:38 <Saizan> though Setup.hs is run on install too
04:09:57 <mmorrow> that's the price i'm willing to pay
04:10:11 <mmorrow> granted it won't stop someone actually trying to attack you
04:10:22 <mmorrow> but it'll prevent some TH code doing "oops"
04:10:59 <mmorrow> i do sudo ./Setup install all the time
04:11:16 <alinp> hi
04:11:43 <alinp> last days someone addressed me a question: "why haskell (or other languages like it) are not so popular comparing to java ? "
04:11:52 <alinp> and I didn't really know what to respond to that
04:12:15 <alinp> someone can give me something to read about this topic ?
04:12:39 <bremner> alinp: why good food is not so popular compared to McDonalds?
04:12:50 <alinp> stupidity ? :D
04:13:06 <alinp> well, I can't invoke this reason ... :)
04:13:17 <ziman> alinp, that question was also on stack overflow: http://stackoverflow.com/questions/597521/will-haskell-ever-become-popular
04:13:25 <byorgey> quality is pretty much never correlated with popularity =)
04:13:42 <alinp> don't get me wrong, I started to love haskell, but I can't give an objective reason why
04:13:45 <bremner> at least not positively correlated
04:14:01 <alinp> thanks ziman
04:14:10 <thomastc> mmorrow: I wouldn't let cabal's debaviour depend on the current user
04:14:10 <thomastc> because forgetting "sudo" is quite common :)
04:14:14 <mmorrow> alinp: because java has been sold to universities for the last 10 years to be the language taught to new undergraduates?
04:14:27 * bremner is campaigning against advocacy of all forms
04:15:25 <Saizan> alinp: well, java is older, it's not as different as haskell from the imperative languages that came before it, as been marketed for years etc..
04:15:30 <Saizan> *has
04:16:29 <mmorrow> thomastc: yeah totally (i'd really rather have it never ever install locally unless i assault it with like 10 super secret flags, but i'm trying to compromise :)
04:16:54 <Saizan> why are you so against local installs?:)
04:17:16 <alinp> Saizan: haskell is older than java ;)
04:17:18 <mmorrow> heh, i'm not sure, but i really really don't like them :)
04:17:28 <beelsebob> I think this has made it clear that the "most people want local installs" argument is rubbish
04:17:35 <beelsebob> it's at best divided
04:17:48 <alinp> haskell appeared in 90, java in 95
04:18:41 <Saizan> beelsebob: maybe it's "most people that commented when the decision was made" then :)
04:18:50 <beelsebob> Saizan: it wasn't though
04:19:04 <beelsebob> as I said earlier, dcoutts did tell me a while ago that opinion was *very* divided on the matter
04:19:50 <Saizan> ah, yeah, most is stronger than "a majority", my bad
04:20:20 <Ninju> mmorrow: funny you should say that, we just had a kid looking to do a work experience placement in here who said at school they used visual basic, because it's what "real businesses use"
04:20:50 <beelsebob> Saizan: the impression that I got from dcoutts was that even the "majority" part could be disputed
04:21:01 <beelsebob> it was unclear who had the majority
04:21:23 <Saizan> ok
04:21:46 <mmorrow> Saizan: thinking about it, it's because i hate hate having a bunch of crap in my $HOME, and only ever install stuff to there when i have a shell account somewhere and i have to.
04:22:02 <beelsebob> mmorrow: yeh, that's roughly my stance on it too
04:22:21 <beelsebob> along with the simple fact that if I create another account to test something, I expect to still have access to this kind of thing
04:22:37 <beelsebob> there's no reason why it should be restricted to only my account
04:23:41 <kadaver> does a webserver need to genrate a proper httpresponse or just serving the html is ok?
04:23:49 <Saizan> still, it's trivial to change the default
04:24:11 <beelsebob> kadaver: proper http response
04:24:38 <beelsebob> Saizan: which is mostly why the default default should be consistant with all the other tools out there that install things
04:24:56 <beelsebob> because if you want that behavior, you'll know "I should probably set that behavior up"
04:25:07 <beelsebob> rather than the norm is to expect it to just work
04:25:55 <Saizan> we have clearly different opinions on what "just works" means :)
04:26:42 <beelsebob> put it this way – suppose you're one of those people that wants a global install – most of the time you would expect that tying xyz install abc would do it globally
04:26:47 <beelsebob> because that's the behavior of almost all other tools
04:27:02 <beelsebob> if you're one of the people who wants a user install, you'll be used to changing the default
04:27:09 <beelsebob> and know that you'll need to do it
04:27:13 <mmorrow> Saizan: i think one good way to make everyone happy would be to have a compile-time flag which you can set to =NONEVARIMEANIT and cabal-install will default to globally
04:27:45 <mmorrow> that would make me all giddy
04:28:14 <beelsebob> mmorrow: there's a config file in which it can be set
04:28:25 <beelsebob> the argument is really only over the default default
04:28:32 <beelsebob> i.e. what you get by changing absolutely nothing
04:28:57 <mmorrow> beelsebob: by all means i'd love the default to be global :)
04:29:09 <beelsebob> ditto :)
04:29:11 <mmorrow> (which is in the config file??_
04:29:17 <mmorrow> s/which/this/
04:29:18 <beelsebob> ~/.cabal/config
04:29:22 <mmorrow> oh
04:51:41 <kadaver> a Http Response is just a string anyway right? with some specific headers.
04:52:42 <kadaver> is there a a lib for that in the stdlib? like Text.Html or soemhting?
04:52:55 <Axman6> Http maybe?
04:56:45 <ivanm> why does Map.lookup have its arguments flipped compared to Map.! ?
04:57:31 <Axman6> :t M.lookup
04:57:31 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
04:59:35 <EvilRanter> ivanm, i guess it's not meant to be used infix
05:00:11 <ivanm> EvilRanter: well, I'd have thought that normally you'd want to do something like map (lookup m) keys
05:01:09 <marcot> Are GHC packages case sensitive?  If I have package abc and package ABC, will it be considered to be different packages?
05:01:28 <ivanm> marcot: I think so, yes
05:01:47 <marcot> ivanm: thanks.
05:02:19 <beelsebob> marcot: yes, but don't do it
05:02:34 <beelsebob> the packages will end up as libraries libHSABC.dylib and libHSabc.dylib
05:02:39 <beelsebob> which your OS may not distinguish
05:02:51 <beelsebob> (it certainly won't work on OS X)
05:03:03 <EvilTerran> ivanm, that's true, although i can also envisage use cases for map (lookup k) ms
05:03:35 <ivanm> fair enough
05:04:52 <marcot> beelsebob: ok.  My problem is that in debian packages are usually called libghc6-package-dev, where package is the name of the cabal package downcased.
05:05:12 <marcot> beelsebob: and I'll have to get the name of the package with the correct case.
05:05:27 <beelsebob> I would just lowercase it
05:05:43 <beelsebob> more encoragement to not use the case sensitivity
05:21:46 <yowgi> hello! is there a function like words and lines that take a custom delimiter? I'm thinking of spliting using commas, for example, but couldn't find anything on hoogle.
05:21:57 <opqdonut> yes there is
05:22:04 <opqdonut> but it's a separate package on hackage
05:22:12 <opqdonut> nothing in the standard libraries, really
05:22:22 <yowgi> where is it, do you know?
05:22:58 <amaron> yowgi: splitRegex
05:23:11 <amaron> yowgi: from Text.Regex
05:23:11 <ivanm> yowgi: by "delimiter", do you mean a character or a String?
05:23:15 <opqdonut> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=split
05:23:21 <opqdonut> hayoo rocks
05:23:23 <marcot> beelsebob: I'm packaging it for debian, the package is not mine.  So I can't lowercase it.
05:23:30 <ivanm> if it's a character, you could probably use recursive break...
05:23:30 <opqdonut> Data.Text.split might be what you want
05:23:37 <yowgi> thanks!
05:23:42 <marcot> opqdonut: Is it open source?
05:23:49 <yowgi> but it depends :) sometimes Char sometimes String, most often Char.
05:23:53 <opqdonut> marcot: i believe so
05:24:06 <marcot> opqdonut: I've never seen a link for it's code.
05:24:21 <opqdonut> http://hackage.haskell.org/packages/archive/text/0.1/doc/html/src/Data-Text.html
05:24:42 <opqdonut> there ya go
05:26:32 <yowgi> thanks, Data.Text.split is exactly what I wanted.
05:29:21 <boegel> how does one make lambdabot show an expansion of foldX ?
05:30:13 <TSC> > foldr (+) a [b,c,d]
05:30:14 <lambdabot>   b + (c + (d + a))
05:30:19 <TSC> Is that what you mean?
05:33:46 <boegel> TSC: ah, right, I shouldn't be using actual values :)
05:33:54 * boegel bumps his head into the table
05:33:57 <boegel> TSC: thanks
05:36:51 <TSC> You're welcome (:
05:42:15 <mightybyte> @seen dons
05:42:15 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6h 27m 8s ago.
05:54:30 <singintime> hi everybody
06:00:03 <ivanm> OT, but is this a BSD license here? http://vlsicad.eecs.umich.edu/BK/SAUCY/#source
06:00:58 <thomastc> ivanm: no
06:01:04 <thomastc> at least, it's not the same wording
06:01:21 <ivanm> *nod*
06:01:27 <ivanm> looks about the same though...
06:01:53 <doserj> ...for non-commercial purposes... definitely not bsd
06:02:40 <ivanm> ahhh, missed that bit
06:02:40 <thomastc> indeed
06:09:24 <FliPPeh> > do putStrLn ":q"
06:09:26 <lambdabot>   * Exception: "<IO ()>"
06:09:29 <FliPPeh> :(
06:10:39 <zachk> FliPPeh: dont bemoan the fact that lambdabot doesnt allow IO
06:11:05 <zachk> it is safe because it doesnt allow IO
06:11:11 <FliPPeh> :|
06:11:20 <FliPPeh> lamdabot, do IO for me
06:11:40 <zachk> @faq can haskell do IO?
06:11:40 <lambdabot> The answer is: Yes! Haskell can do that.
06:11:57 <FliPPeh> @faq can haskell be learned by me?
06:11:57 <lambdabot> The answer is: Yes! Haskell can do that.
06:12:10 <FliPPeh> It lies
06:12:12 <Axman6> easily
06:12:18 <Axman6> what's the problem?
06:12:26 <FliPPeh> Thinkin in Haskell
06:12:37 <thomastc> @faq can haskell make coffee?
06:12:37 <lambdabot> The answer is: Yes! Haskell can do that.
06:12:49 <FliPPeh> I know the syntax and all that
06:12:54 <FliPPeh> But I can't think in Haskell
06:13:03 <vixey> don't think in haskell
06:13:03 <thomastc> FliPPeh: what's the *concrete* problem? :) thinking just requires practice
06:13:11 <vixey> use haskell to focus your thinking
06:13:16 <vixey> as with any language
06:14:13 <FliPPeh> I wouldn't know how to.. for example.. do basic string slicing.. like having an IRC line like ":FliPPeh!sum@hostna.me PRIVMSG #haskell :Meh" and transform it into some kind of IRC Data container :s
06:15:01 <jedai> FliPPeh: generally if the string is complex enough, a little bit of Parsec is a good idea
06:15:12 <mun> hi
06:15:16 <FliPPeh> Not that complex :s
06:16:24 <jedai> FliPPeh: Except if it's really simple (split with a delimiter, check Data.List.Split from the split package), Parsec works well and keep the complexity to a minimum
06:16:40 <mun> i'm reading an introduction on monads and there's something i don't quite understand: why is f a better version of f1? http://haskell.pastebin.com/mdbb3635
06:16:47 <ejt> IRCLine <$> (char ':' *> identifier <* char '!') <*> who <*> (string "PRIVMSG" *> many1 anyChar
06:16:51 <jedai> FliPPeh: You also have pretty good Regex library too if you're more accustomed to them
06:17:26 <singintime> @faq can haskell dominate the world?
06:17:27 <lambdabot> The answer is: Yes! Haskell can do that.
06:17:32 <singintime> wow...
06:17:40 <jedai> mun: Well f1 is ugly...
06:17:43 <doserj> mun: f is easer to read and easier to write
06:17:45 <FliPPeh> @faq can haskell do nothing?
06:17:45 <lambdabot> The answer is: Yes! Haskell can do that.
06:18:03 <ziman> > do Nothing
06:18:05 <lambdabot>   Nothing
06:18:08 <thomastc> FliPPeh: http://en.wikibooks.org/wiki/Haskell/Practical_monads#Parsing_monads
06:18:23 <singintime> @faq can haskell do that?
06:18:24 <lambdabot> The answer is: Yes! Haskell can do that.
06:18:25 <jedai> mun: there is potential for errors (the state is explicit, you could pass the wrong state to a function)
06:18:46 <singintime> no matter what, I suppose ;)
06:18:56 <FliPPeh> MHmhmhmh
06:19:18 <FliPPeh> I need a good tutorial that doesn't send me asleep like Real World Haskell which is way too long
06:19:23 <FliPPeh> Learn You A Haskell is great
06:19:33 <FliPPeh> But was missing some stuff ;<
06:19:39 <jedai> mun: i contrast the monadic code do the state passing for you, it won't make mistakes, and the state passing ugliness can be forgotten
06:20:09 * singintime agrees with FliPPeh... after about a week still on chapter 4 of real world haskell
06:20:15 <jedai> FliPPeh: You don't have to read RWH from end to end you know ? You can just consult the chapters that seems relevant
06:20:40 <FliPPeh> It's bad to just jump into somewhere
06:20:46 <FliPPeh> Especially RWH
06:20:53 <FliPPeh> The chapters built upon each other
06:20:54 <ddarius> You could read the Report, a comprehensive, exciting adventure into the details of the Haskell language.
06:20:55 <bremner> FliPPeh: for example, chapters 1,2,3,6,14 introduce haskell to people who already know some functional programming
06:21:03 <bremner> heh
06:21:22 <singintime> it's quite well written, though
06:21:26 <FliPPeh> It is
06:21:48 <FliPPeh> But too long.. by the end of one chapter I forget anything that was in the first paragraphs
06:21:54 <vixey> loll
06:22:16 <ddarius> FliPPeh: You could just start writing code and forget all this reading stuff until you need it.
06:22:17 <bremner> FliPPeh: maybe you need medication more than a tutorial :-)
06:22:31 <FliPPeh> Maybe I need a new brain
06:22:44 <FliPPeh> This one's tainted with imperative programming
06:22:48 <FliPPeh> Like cancer
06:22:53 <vixey> haskell is imperative programming
06:22:56 <vixey> (and functional)
06:23:14 <FliPPeh> > do forgetImperativeSkill
06:23:15 <lambdabot>   Not in scope: `forgetImperativeSkill'
06:23:25 <singintime> FliPPeh: I had the same feeling
06:23:37 <vixey> > don't
06:23:38 <lambdabot>   Not in scope: `don't'
06:23:44 <singintime> but now it feels much better
06:23:49 <FliPPeh> :(
06:24:12 <singintime> even if some concepts are still obscure for me
06:24:35 <singintime> it's just a matter of taking your time I think
06:24:43 <FliPPeh> I can read through any tutorial and think "yea yea I know all that" but when I want to write something by myself I just get errored to hell :'(
06:25:04 <singintime> enlightenment will come... when you don't expect it :)
06:25:07 <FliPPeh> Type errors out of nowhere still
06:25:31 <ddarius> It takes a really long time before you stop making type errors.
06:28:28 <vixey> I practice what could be called, type error directed programming
06:28:40 <FliPPeh> ;d
06:28:42 <thomastc> yah me too :)
06:28:52 <FliPPeh> Looks like I'm not the only one to struggle
06:29:22 <FliPPeh> Still feels bad to drop from something that could be called a pretty good imperative programmer to a novice functional snail
06:29:23 <FliPPeh> ;<
06:29:43 <Axman6> you'll pick it up
06:29:50 <wunki> some day...
06:29:50 <vixey> I'm thinking about interactive programming actually
06:29:52 <Axman6> just need to rewire your brain
06:30:05 <thomastc> first time I tried, I ran into the monomorphism restriction :P
06:30:22 <vixey> you can turn that off
06:30:30 <Ferdirand> focus on what you want, not how to do it
06:32:19 <thomastc> oooh, parser combinators are awfully sexy... I knew that they were supposed to be sexy, just never sawlooked it up :)
06:33:13 <vixey> parser combinators are very conceptually simple
06:35:30 <FliPPeh> I just downloaded darcs, now how do I grab a whole repo and download it to some folder on my disk?
06:35:38 <FliPPeh> help doesn't help me :(
06:36:05 <ejt> darcs get <url>
06:36:16 <FliPPeh> Ahh :)
06:36:18 <FliPPeh> Thanks
06:36:24 <ejt> darcs help get
06:36:53 <FliPPeh> Downloading, thanks
06:37:27 <FliPPeh> Which editors are you haskellers using?
06:37:46 * EvilTerran uses vim or SciTE, depending on his mood
06:38:13 <ejt> emacs here
06:38:20 <ejt> not heard of SciTE
06:38:21 <FliPPeh> SciTE here, too
06:38:29 <FliPPeh> It's pretty awesome actually
06:39:02 <earthy> there's a few emacs-lovers as well
06:39:43 <luite> last time someone asked that question, there were about 7 ppl using emacs, 2 vim
06:39:55 <luite> guess the emacs users are still sleeping :p
06:40:01 * ejt is looking forward to being able to switch to yi
06:40:03 <tromp_> i use both
06:40:55 <amaron> how it is to work with SciTE compared with emacs?
06:41:08 <amaron> i use emacs and vim, emacs mostly
06:41:14 <QuietPurple> > 2 + 2
06:41:16 <lambdabot>   4
06:41:26 <QuietPurple> just checking ;-)
06:41:27 <jedai> emacs :) The haskell-mode is pretty nice. But I'm thinking of trying to use leksah a bit more, maybe try to help develop it
06:42:26 <amaron> leksah uses very simple editor, ins't it?
06:42:39 <QuietPurple> > :type curry
06:42:39 <FliPPeh> @faq Can Conficker be rewritten in Haskell?
06:42:40 <lambdabot>   <no location info>: parse error on input `:'
06:42:40 <lambdabot> The answer is: Yes! Haskell can do that.
06:42:57 <QuietPurple> @type curry
06:43:01 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:43:33 <mun> jedai: how are states passed for f?
06:44:55 <beelsebob> @remember FliPPeh @faq Can Conficker be rewritten in Haskell? <lambdabot> <no location info>: parse error on input `:'
06:44:55 <lambdabot> Done.
06:45:12 <jedai> mun: it's implicit in the monad, if you desugar the do-notation and look at the definition of (>>=) for the State monad you'll see that pretty much the same thing as in f1 happens, except you don't have to write it explicitly
06:45:48 <jedai> @src State (>>=)
06:45:49 <lambdabot> Source not found. It can only be attributed to human error.
06:46:06 <jedai> @src Maybe (>>=)
06:46:07 <lambdabot> (Just x) >>= k      = k x
06:46:07 <lambdabot> Nothing  >>= _      = Nothing
06:46:13 <jedai> @src State s (>>=)
06:46:13 <lambdabot> Source not found. Maybe you made a typo?
06:46:16 <mun> jedai: should (>>=) be defined for each monad?
06:46:20 <jedai> @src (State s) (>>=)
06:46:21 <lambdabot> Source not found. My brain just exploded
06:46:49 <jedai> mun: Yes (>>=) is one of the fundamental operator for Monads
06:46:55 <FliPPeh> Hmm
06:47:03 <jedai> mun: It's called "bind"
06:47:10 <mun> jedai: thanks
06:48:01 <jedai> mun: And every Monad define its own version, along with return it's what makes each Monad a monad and give it its special semantic
06:54:12 <mun> in http://haskell.pastebin.com/m20ecf1c5 what does r@() do and where does f come from?
06:55:18 <byorgey> r@(Result e m) pattern-matches on (Result e m), and also gives the whole thing the name r
06:55:34 <EvilTerran> mun, "name@(pattern)" is a pattern which binds the whole thing it matches to "name", but also matches it against "pattern"
06:55:36 <byorgey> so in the right hand side you can use e and m individually but you can also write r to refer to the whole thing
06:55:49 <EvilTerran> > let p@(x,y) = (1,2) in (p, x, y)
06:55:51 <lambdabot>   ((1,2),1,2)
06:56:04 <byorgey> f is just the other argument to >>=
06:56:06 <EvilTerran> mun, and f is bound as a parameter to >>=
06:56:08 <mun> right right
06:56:09 <byorgey> note that is defining >>=
06:56:23 <byorgey> it's just like writing   x + y = blah blah x blah blah y...
06:56:34 <byorgey> except '+' is '>>=' and the 'x' is more complicated
06:56:44 <EvilTerran> "r@(Result e m) >>= f = ..." is roughly the same as "(>>=) (Result e m) f = (let r = Result e m in ...)"
06:57:44 <Ninju> I can't get this to compile:
06:57:44 <Ninju> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3458#a3458
06:58:10 <Ninju> also, I'm a complete Haskell noob, so I would appreciate anyone who can go through it and give me pointers on what I should be doing (instead of what I have done), etc
06:58:12 <Ninju> thanks
06:58:29 <Ninju> I am compiling with
06:58:33 <Ninju> ghc -o ctp ctp.hs
06:58:34 <Ninju> btw
06:58:35 <EvilTerran> Ninju, well, "case ... of True -> ...; False -> ..." can be written "if ... then ... else ..."
06:58:43 <Ninju> is that preferred?
06:58:48 <EvilTerran> yeah
06:58:57 <Ninju> I always felt case .. of True -> ..., False -> ..., was a little clearer
06:59:08 <Ninju> ok, thanks
06:59:12 <EvilTerran> if/then/else is syntactic sugar for the case
06:59:32 <EvilTerran> what error message do you get trying to compile it, anyway?
06:59:34 <jedai> Ninju: compile with "ghc --make ctp.hs"
07:00:01 <thomastc> most people would find if/then/else more readable
07:00:05 <jedai> The code is correct
07:01:21 <Gracenotes> I would find an if function more readable
07:01:34 <nlogax> i just got to the (.) operator in RWH, and i see what the examples are doing, but i don't understand pointfree style. in the example: capCount = length . filter (isUpper . head) . words, can anyone explain how the arguments can just be omitted like that? :)
07:01:36 <Gracenotes> well. If not for excessive parens
07:01:42 <jedai> Ninju: I think the outermost case ... of True False would be better written as a guard
07:01:54 <Gracenotes> @unpl capCount = length . filter (isUpper . head) . words
07:01:55 <lambdabot> capCount c = length (filter (\ i -> isUpper (head i)) (words c))
07:02:14 <Ninju> ok, sick, ghc --make ctp.hs worked
07:02:14 <Ninju> thanks
07:02:27 <Ninju> jedai: let me just see which one you mean
07:02:46 <BONUS_> nlogax: . takes two function and composes them, returning a new function
07:02:48 <jedai> Ninju: case notElem ...
07:03:03 <Ninju> jedai: I tried a guard there, something about a MonadPlus instance not being defined for IO if I remember correctly
07:03:07 <BONUS_> so if we say foo = length . filter (> 3)
07:03:10 <BONUS_> or something like that
07:03:11 <Ninju> oh
07:03:20 <BONUS_> foo is the function that you get by composing length and filter (> 3)
07:03:27 <mun> with the definition of bind in the monad in http://haskell.pastebin.com/m2d121e39, does line 9 imply that (g w) should be a function since it needs to apply to an argument s0?
07:03:31 <Ninju> yeah, actually, that was the one where I had the guard error
07:03:47 <mun> g w correspond to p, right?
07:04:19 <nlogax> BONUS_: yes, i understand that (i think), but not how the argument can just be omitted. i've seen examples like addOne = (+1) etc, but.. yeah, i don't understand where it goes :P
07:04:24 <ejt> foo xs = length (filter (> 3) xs) == length $ filter (> 3) $ xs
07:04:40 <ejt> == length . fileter (> 3) $ xs
07:04:42 <nlogax> ohh wait.. i think something just clicked
07:04:52 <ejt> so then you can just drop the 'xs' from each side
07:04:57 <BONUS_> think of everything as expressions
07:05:08 <jedai> Ninju: There's no reason why you should have an error with a guard there
07:06:57 <BONUS_> foo xs = ... is just kind of sugar for writing foo = (\xs -> ...)
07:07:08 <Ninju> jedai: I'll try it and get back to you with the error.
07:07:15 <Ninju> and the new code
07:07:24 <BONUS_> so if you have foo = (\xs -> length . filter (>3) $ xs)
07:07:30 <BONUS_> you can just omit the xs's
07:07:34 <BONUS_> i mean
07:07:50 <BONUS_> yeah
07:08:02 <nlogax> BONUS_: i think i'm beginning to see the light.. a very dim light :)
07:08:04 <nlogax> thanks
07:08:12 * nlogax plays around 
07:08:17 <EvilTerran> eta reduction!
07:08:37 <BONUS_> because if you make a lambda around a function and then just pass that xs to the function (length . filter (>3) being the function here), it's the same expression as the function
07:08:46 <FliPPeh> > take 10 [x | x <- [1..], isEven x]
07:08:47 <lambdabot>   Not in scope: `isEven'
07:08:52 <FliPPeh> > take 10 [x | x <- [1..], even x]
07:08:53 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
07:09:10 <EvilTerran> (\x -> f x) = f
07:09:10 <mun> with the definition of bind in the monad in http://haskell.pastebin.com/m2d121e39, does line 9 imply that (g w) should be a function since it needs to apply to an argument s0? does g w correspond to p in the definition of the bind?
07:09:11 <BONUS_> just like in, say, other languages if you have foo(x) = { return bar(x) }
07:09:11 <FliPPeh> > take 10 [x | x <- [1..], not even x]
07:09:12 <lambdabot>   Couldn't match expected type `Bool'
07:09:22 <Duqicnk> > take 10 $ filter even [1..]
07:09:23 <FliPPeh> > take 10 [x | x <- [1..], not (even x)]
07:09:24 <BONUS_> you could just say foo = bar
07:09:24 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
07:09:25 <lambdabot>   [1,3,5,7,9,11,13,15,17,19]
07:09:48 <FliPPeh> ;|
07:09:59 <FliPPeh> I like list comprehensions
07:10:06 <EvilTerran> not . even = odd
07:10:14 <EvilTerran> :P
07:10:25 <thomastc> nlogax: another way to see it is that every function takes exactly one argument
07:10:25 <thomastc> some functions just return other functions, that also take one argemunt again, and that's how multi-agrgument functions ar
07:10:28 <thomastc> e constructed
07:10:36 <FliPPeh> > take 20 [x+y | x <- [1..], y <- [1..]]
07:10:37 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
07:10:44 <FliPPeh> > take 20 [x*y | x <- [1..], y <- [1..]]
07:10:45 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
07:11:04 <FliPPeh> :s
07:11:10 <EvilTerran> > [(x,y) | x <- [1..], y <- [1..]]
07:11:11 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
07:11:18 <FliPPeh> ;D
07:11:25 <FliPPeh> > take 20 [x*y | x <- [1..5], y <- [1..5]]
07:11:27 <lambdabot>   [1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20]
07:11:30 <FliPPeh> Tehehe
07:11:33 <Gracenotes> :o
07:11:36 <Gracenotes> o:
07:11:59 <vixey> > (\x->[1,x..5]) =<< [1..5]
07:12:01 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:12:06 <vixey> > (\x->[1,x..5]) =<< [2..5]
07:12:08 <lambdabot>   [1,2,3,4,5,1,3,5,1,4,1,5]
07:12:13 <EvilTerran> > [f (x,y) | x <- [1..], y <- [1..x-1], f <- [id,flip]]
07:12:14 <lambdabot>   Couldn't match expected type `b -> b -> c'
07:12:19 <vixey> > (\x->[0,x..5]) =<< [1..5]
07:12:20 <lambdabot>   [0,1,2,3,4,5,0,2,4,0,3,0,4,0,5]
07:12:21 <EvilTerran> er
07:12:35 <EvilTerran> > concat [[(x,y), (y,x)] | x <- [1..], y <- [1..x-1]]
07:12:36 <lambdabot>   [(2,1),(1,2),(3,1),(1,3),(3,2),(2,3),(4,1),(1,4),(4,2),(2,4),(4,3),(3,4),(5...
07:12:54 <singintime> real-time tutorial? :)
07:12:59 <singintime> like it!
07:13:25 <EvilTerran> > [(i, n-i) | n <- [0..], i <- [0..n]] -- huzzah!
07:13:26 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
07:13:39 <FliPPeh> > -- Oh, he knows comments!
07:13:40 <lambdabot>   <no location info>: parse error on input `;'
07:13:51 <FliPPeh> > 5+5 -- Oh, he knows comments!
07:13:52 <lambdabot>   10
07:13:53 <jedai> mun: Yes it does
07:14:35 <EvilTerran> jedai, too late, i guess =/
07:14:41 <singintime> @faq can singintime hug lambdabot?
07:14:41 <lambdabot> The answer is: Yes! Haskell can do that.
07:14:51 <FliPPeh> @faq
07:14:51 <lambdabot> The answer is: Yes! Haskell can do that.
07:14:57 <Gracenotes> > foldl ((liftA2 (.) =<< flip) (++)) [] $ map return [1..4]
07:14:57 <singintime> >_>
07:14:58 <lambdabot>   [1,2,1,3,1,2,1,4,1,2,1,3,1,2,1]
07:14:59 <singintime> <_<
07:15:01 <FliPPeh> @faq Can haskell divide by zero?
07:15:02 <lambdabot> The answer is: Yes! Haskell can do that.
07:15:02 <EvilTerran> @hug singintime
07:15:02 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:15:06 <FliPPeh> > 5/0
07:15:07 <lambdabot>   Infinity
07:15:08 <EvilTerran> heh
07:15:12 <Gracenotes> > foldr ((liftA2 (.) =<< flip) (++)) [] $ map return [1..4]
07:15:13 <singintime> ^^
07:15:13 <lambdabot>   [1,2,3,4,4,3,2,1]
07:15:16 <FliPPeh> Infinity - take your time.
07:15:45 <FliPPeh> > [1..4] ++ reverse [1..4]
07:15:46 <lambdabot>   [1,2,3,4,4,3,2,1]
07:15:49 <FliPPeh> > [1..4] ++ reverse [1..3]
07:15:51 <lambdabot>   [1,2,3,4,3,2,1]
07:16:05 <FliPPeh> > 11111*5
07:16:06 <lambdabot>   55555
07:16:09 <EvilTerran> @vixen how're you today, how?
07:16:09 <lambdabot> i'm good, you?
07:16:20 <EvilTerran> *anyhow?
07:17:28 <nlogax> thomastc: yeah, RWH told me that, but i guess i don't fully understand it yet. :)
07:17:53 <Gracenotes> @vixen are you deterministic?
07:17:53 <lambdabot> yes, i am
07:18:04 <FliPPeh> @vixen did you write conficker?
07:18:04 <lambdabot> good question
07:18:11 <FliPPeh> @vixen Be honest.
07:18:11 <lambdabot> I like to pick everything up and smell it... Its a fetish of mine... And i mean everything! Is that cool with you?
07:18:24 <FliPPeh> Not THAT honest.
07:18:31 <EvilTerran> heh
07:18:39 <FliPPeh> Alright, who taught him that?
07:18:44 <EvilTerran> her!
07:18:49 <EvilTerran> @vixen asl?
07:18:49 <FliPPeh> Alright, who taught her that?
07:18:49 <lambdabot> 19/f/California
07:19:20 <FliPPeh> @vixen Are there any sweet robot friends of you who want to hang out with me?
07:19:20 <lambdabot> weird. robots scare me
07:19:26 <EvilTerran> @vixen do you learn from talking to people?
07:19:27 <lambdabot> yes i do
07:19:38 <FliPPeh> @vixen 1, 2, 3 what's next?
07:19:38 <lambdabot> whoa whoa whoa, one question at a time!
07:19:42 <mun> if i see a do block used in a function, how do i tell which monad it uses?
07:20:04 <EvilTerran> sometimes you can't
07:20:06 <EvilTerran> ?src liftM2
07:20:06 <Gracenotes> you can't always tell
07:20:06 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:20:18 <ejt> go into ghci and ask for the type of the function
07:20:23 <EvilTerran> but looking at type signatures might help
07:20:35 <EvilTerran> looking at the actions contained within the do-block would work, too
07:20:36 <BONUS_> if you have x1 <- something
07:20:39 <FliPPeh> @vixen One word about haskell that will completly enlighten me and guide me on my path to ethernal haskell goodness?
07:20:39 <lambdabot> church is my favourite computer scientist.
07:20:42 <BONUS_> figure out what the type of that something is
07:20:47 <BONUS_> if it's a list, then it's the list monad
07:20:51 <BONUS_> etc.
07:20:52 * edwardk waves hello.
07:21:34 <mun> i see, so it's the right hand side that depends which monad it is?
07:21:47 <EvilTerran> not necessarily
07:21:56 * edwardk has been thinking about the unboxed set stuff from the other day, and I think I have a way to make the instances scale a lot better.
07:21:56 <EvilTerran> inferrence can go in either direction
07:22:03 <Entroacceptor> I've got a minor cabal problem: it doesn't find my alex, even if I just installed it into $HOME/bin, which is in my $PATH
07:22:15 <Gracenotes> you can do { putStrLn "Hello"; putStrLn "World" }
07:22:21 <BONUS_> yeah, it can also depend on how that monadic value is used later on
07:22:22 <Gracenotes> @type putStrLn
07:22:23 <lambdabot> String -> IO ()
07:22:28 <Entroacceptor> can I fix that, or maybe just tell cabal to always append --with-alex to cabal install?
07:22:50 <BONUS_> if i have (do a <- return 3; b <- return 4; (a,b)) ++ [], then it's the list monad
07:23:06 <Gracenotes> sometimes it won't infer the monad type exactly, but rather the typeclass that the monad type belongs to
07:23:21 <BONUS_> if i have Just f <*> (do a <- return 3; b <- return 4; (a,b))
07:23:26 <BONUS_> then it's the maybe monad
07:23:56 <BONUS_> yeah long answer short, you have to do type inference by yourself, but usually you can tell by looking at the function type, right hand sides or looking at how it's used later on
07:23:59 <BONUS_> :]
07:24:07 <mun> thanks
07:24:09 <Gracenotes> @type do { a <- get; put (not a); return a }
07:24:11 <lambdabot> forall (t :: * -> *). (MonadState Bool t) => t Bool
07:24:40 <edwardk> If we make a "class Unboxable a" that describes how to pack a value of type a into a particular type of slot, and define a small number of different slot types (Int, Int32, Int64, Integer, Boxed) then we could make packed versions of containers that have so many slots of each type, and pack values into slots using combinators
07:24:48 <Gracenotes> @type do { a <- get; put (not a); return a } `asTypeOf` State undefined
07:24:50 <lambdabot> State Bool Bool
07:24:59 <Saizan_> Entroacceptor: are you running cabal with sudo perhaps?
07:25:12 <Entroacceptor> no, I'm not
07:25:20 <Entroacceptor> but I found the problem, I think
07:25:37 <Entroacceptor> my $PATH worked for the shell, but not for cabal
07:25:43 <edwardk> so for a USet Int it would take a single-slot 'blank' data type and fill it with an Int, USet Char would take a single slot 'blank' data type and swizzle the char into an Int and get it back out during the accessor
07:25:55 <Saizan_> ah, yeah, you've to use export
07:26:17 <edwardk> and for tuple types they could use larger numbers of slots
07:26:22 <Gracenotes> @type undefined `asTypeOf` undefined
07:26:23 <lambdabot> forall a. a
07:27:58 <edwardk> this is interesting to me because then i could define instances of the Unboxable or Packing or whatever class for newtypes of Ints and the adaptive-container and unboxed-container stuff would work with those as well
07:28:09 <edwardk> then i can pack my monoids =)
07:28:52 <edwardk> and the size stored inside the Bin nodes in Data.Set.Unboxed becomes just a packed Int alongside all of the others.
07:29:36 <edwardk> any obvious flaws?
07:30:16 <catface> can someone explain this? cabal: cannot configure PArrows-0.1.1. It requires ghc-prim -any. There is no available version of ghc-prim that satisfies -any
07:30:39 <edwardk> catface: are you using ghc?
07:30:44 <Saizan_> ghc-pkg list ghc-prim ?
07:30:48 <catface> yes.
07:30:54 <FliPPeh> @faq
07:30:55 <lambdabot> The answer is: Yes! Haskell can do that.
07:31:13 <FliPPeh> @vixen Does the Darma Initiative use Haskell?
07:31:13 <lambdabot> Ooh, functional programmers are so hot!
07:32:16 <Saizan_> uhm, ghc-prim is new since 6.10, maybe?
07:32:28 <doserj> yes
07:32:30 <edwardk> FliPPeh: it would explain the time travel aspects of the show
07:32:41 <catface> saizan_: ok, thanks
07:33:03 <FliPPeh> edwardk: It would rather explain the fact that the more I watch that show, the less I understand it
07:33:10 <edwardk> as jack and kate and sawyer discover they aren't really time traveling.. they are just stuck in a backwards state monad
07:34:47 <edwardk> they are obviously running 6.10.2. locke died, but was saved by his guaranteed finalizer. it all fits.
07:35:26 <edwardk> at least, it makes as much or more sense than anything else on that show ;)
07:36:11 <mun> with "case", does foo in "case foo bar" have to be a function/
07:37:13 <edwardk> well, you can case True of True -> ...; False -> ...  or case x of ...
07:37:29 <edwardk> but 'case foo bar of' would require that you can apply foo to bar, so yes ;)
07:38:15 <FliPPeh> > case even 4 of True -> "True" | False -> "False"
07:38:16 <lambdabot>   <no location info>: parse error on input `|'
07:38:18 <Duqicnk> mun: in "case x of", x can be any expression
07:38:18 <FliPPeh> :(
07:38:23 <Ferdirand> you could do "case (foo,bar)"
07:38:25 <FliPPeh> > case even 4 of True -> "True"
07:38:26 <lambdabot>   "True"
07:38:35 <vixey> > case even 4 of True -> | False -> "False"
07:38:37 <lambdabot>   <no location info>: parse error on input `|'
07:38:45 <FliPPeh> > case (= 4) 4 of True -> "True"
07:38:46 <lambdabot>   <no location info>: parse error on input `='
07:38:47 <edwardk> case even 4 of True -> "Hi Mom"; False -> "How Odd!"
07:38:49 <vixey> > case even 4 of True | False -> "False"
07:38:50 <lambdabot>   "* Exception: /tmp/3060428393501068985:71:36-73: Non-exhaustive patterns in...
07:38:51 <FliPPeh> > case (== 4) 4 of True -> "True"
07:38:52 <lambdabot>   "True"
07:39:21 <edwardk> vixey: thats a confusing guard if i ever saw one =)
07:40:19 <edwardk> > case even 4 of True | False -> "iit must be one or the other" | otherwise -> "What!?"
07:40:21 <lambdabot>   "What!?"
07:40:25 <edwardk> =)
07:40:52 <mun> thanks
07:41:06 * vixey watched Veggie Tales
07:41:14 <edwardk> hah
07:41:38 <edwardk> my wife still has the "We are pirates that don't do anything" song from that on her ipod.
07:41:49 <vixey> hehee
07:44:05 <FliPPeh> I want to use Haskell to do CGI!
07:44:05 * BMeph never watched Veggie Tales, but does know that song all too well.
07:44:16 <FliPPeh> I even used Brainfuck to do CGI ones
07:44:18 <FliPPeh> Fun fun.
07:44:33 <BMeph> I want to use Haskell to do CSI, so that's fair. ;)
07:45:33 <FliPPeh> Crime Scene Investigation?
07:46:13 <edwardk> well, if you can use a gui in visual basic to track an IP address, imagine what you can do with laziness
07:46:33 <edwardk> other that not get off the couch to do anything at all
07:46:36 <edwardk> er than
07:58:25 <slide_rule> I'm having troubles with this code: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2065
07:59:27 <slide_rule> GHC complains about "couldn't match expected type [Token] against inferred type Token" at the bottom, "cmd:args"
08:00:09 <vixey> slide_rule: it's because of breakCommands :: [Token] -> [[Token]]
08:00:32 <vixey> probably
08:00:32 <jho> I have a pretty strong background of Perl and Common Lisp programming, and now I'd like to learn Haskell. Any recommendations on where to start?
08:00:53 <slide_rule> crap
08:00:58 <Philippa__> jho: see how far the Gentle Introduction gets you, if you're good with CL?
08:01:00 <jho> I found Real World Haskell, is that the best book around?
08:01:12 <slide_rule> The last line should read cmd:args == breakCommands rest, I'll fix the paste
08:01:12 <Philippa__> RWH is good, I've heard one guy complain it's too real world :-)
08:01:13 <dqd> Best practical book, yes.
08:01:13 <Ninju> I found Haskell School of Expression to be excellent
08:01:26 <Ninju> But I haven't read any other books
08:01:35 <Ferdirand> slide_rule: forgot to call breakCommands recursively ?
08:02:04 <slide_rule> err - cmd:args ++ breakCommands rest
08:02:05 <jho> Ok, I'll try the Gentle Introduction first. Thanks for the suggestion. :)
08:02:31 <Philippa__> as a heads-up, it's mostly meant for MLers. How much experience do you have with statically-typed languages?
08:02:49 <slide_rule> oh drat - I figured it out.
08:02:58 <doserj> slide_rule: breakcommands still returns [Token], not [[Token]
08:03:28 <jho> Philippa__: not much
08:03:29 <doserj> something like (cmd:args):breakCommands rest I guess
08:03:45 <slide_rule> doserj: that was it.  apologies for the static.
08:04:12 <Gracenotes> is there a reversed (horizontally flipped) negate symbol? the original being ¬
08:04:14 <jho> I've done some C, C++ and Java, but that's about it :P
08:04:16 <doserj> slide_rule: small suggestion, though: don't use head and tail in breakCommands, just use pattern matching
08:05:28 <doserj> breakCommands (x:xs) = let (args, rest) = span (not.isCommand) xs in (x:args):breakCommands rest
08:06:46 <slide_rule> doserj: just did that, thanks.  makes sense.
08:08:27 <vixey> > 11111111111111111111111111111111111111111111111111111111^2
08:08:28 <lambdabot>   123456790123456790123456790123456790123456790123456790120987654320987654320...
08:08:44 <vixey> > 2^9999999999999999
08:08:59 <lambdabot>   thread killed
08:09:02 <edwardk> a bored mathematician is a terrible thing to watch
08:09:20 <Ferdirand> slide_rule: also, you could use map instead of explicit recursion
08:12:09 <slide_rule> Ferdirand: not sure I follow - wouldn't the function I passed to map only get to look at one list element at a time?
08:13:02 <Ferdirand> slide_rule: sorry, disregard that. My brain took a wrong leap.
08:13:21 <Ferdirand> must reload coffee
08:31:21 <jad4> hi guys
08:31:37 <jad4> what do you use for polymorphic types after alpha, beta and gamma?
08:31:54 <edwardk> delta? =)
08:32:08 <jad4> edwardk, that was my guess too... :)
08:32:44 <Duqicnk> a picture of a rocket ship
08:33:39 <jad4> Duqicnk, which one is that Upsilon or Psi?
08:33:42 <jad4> :P
08:34:12 <jad4> eh I guess I'll just go for delta... even though for some reason it doesn't feel that right
09:00:00 <catface> can you do a multiple pattern matching lambda?
09:00:20 <b_jonas> catface: sort of, with the pattern guard extension
09:00:28 <catface> thanks
09:02:46 <mun> if i have a definition data A = A { foo :: String...} is foo a function?
09:02:53 <yav> catface: another (perhaps, not so nice) way is like this:  \x y z -> case (x,y,z) of ...
09:03:10 <iago> mun, yes, foo :: A -> String
09:03:17 <yav> mun: yes. it is the record selector, it get the value of the fields
09:03:33 <Duqicnk> eww records
09:03:49 <yav> Duqicnk: ?  they are quite useful
09:03:58 <Duqicnk> eh, the update syntax is ugly
09:04:37 <mun> i see. then if i do foo (bar) and bar is of type A, what does it return?
09:04:47 <yav> Duqicnk: i think that the update syntax is fine.  it is a pity that there is no automatically derived update function though.
09:04:52 <Duqicnk> yes
09:04:59 <mun> the attribute foo of bar?
09:05:01 <fasta> f a b c = mapM_ somefunction somearg and then :t f returns as the final result type (), instead of m () ...
09:05:08 <Saizan_> mun: yes, the String
09:05:10 <yav> mun: a string
09:05:28 <mun> i see.
09:05:35 <Duqicnk> mun: if foo :: A -> B and bar :: A then (foo bar) :: B
09:05:41 <Duqicnk> this is one of the basic typing rules
09:05:49 <b_jonas> catface: no wait, this doesn't work, lambdas can't have guards apparently
09:05:50 <b_jonas> this sucks
09:06:04 <mun> thanks a lot
09:06:26 <pumpkin> fasta: ?
09:06:27 <b_jonas> > (\x | 0 < x -> "positive | otherwise -> "negative") 5 -- shoulnd't this work?
09:06:28 <lambdabot>   <no location info>: parse error on input `|'
09:06:46 <fasta> pumpkin: the type-inferencer is doing something impossible.
09:06:59 <Duqicnk> yav: what i often want is a record in a State monad or such, with an "in-place" update for each field
09:06:59 <pumpkin> yeah, it looks unlikely :P
09:07:01 <iago> :t mapM_
09:07:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
09:07:09 <Duqicnk> maybe next time i will use TH to solve the problem
09:07:09 <b_jonas> only cases can do that
09:07:10 <iago> :t mapM_ undefined undefined
09:07:11 <b_jonas> pity
09:07:12 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
09:07:15 <Saizan_> fasta: you sure you're not triggering some naked monad like (a ->)?+
09:07:30 <Duqicnk> Saizan_: in what sense is that "naked"?
09:07:33 <FliPPeh> What's the difference between $ and . ?
09:07:41 <Duqicnk> @type ($)
09:07:42 <FliPPeh> They both seem to be able to replace ( )
09:07:42 <lambdabot> forall a b. (a -> b) -> a -> b
09:07:43 <Duqicnk> @type (.)
09:07:44 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:07:46 <fasta> Saizan_: probably that's the most likely cause.
09:08:11 <Duqicnk> FliPPeh: a $ b x  ==  a (b x)  ==  (a . b) x
09:08:12 <Saizan_> Duqicnk: not wrapped in a newtype
09:08:15 <yav> FliPPeh: $ applies a function to an argument, while (.) composes two functions
09:08:33 <Duqicnk> Saizan_: but (->) itself is a type ctor
09:08:42 <Duqicnk> it's infix, but otherwise no different from "State s"
09:08:59 <fasta> Saizan_: yes, that was it.
09:09:03 <FliPPeh> mhh
09:09:15 <Saizan_> Duqicnk: it's for contrast with e.g. Reader
09:09:22 <Saizan_> Duqicnk: not a formal term
09:09:28 <Duqicnk> okay
09:09:36 <yav> fasta: this sort of error is exactly why i do not like uses (->) as a monad
09:10:44 <fasta> yav: In my experience "smart" code is impossible to read after a few months, so that's why I don't do these things.
09:11:29 <Duqicnk> some "smart" things make code easier to read, some make it harder
09:12:24 <mun> i'm looking at some code and got a question: what does Map.Map do in type LibEnv = Map.Map LIB_NAME DGrap?
09:12:41 <Duqicnk> Map.Map is an associative container
09:12:44 <Duqicnk> associates keys with values
09:12:50 <Duqicnk> here LIB_NAME is the key type and DGrap is the value type
09:13:03 <mun> Map refers to Data.Map
09:13:23 <Duqicnk> There's a "import qualified Data.Map as Map" ?
09:13:54 <Gracenotes> you can also complement that with import Data.Map (Map)
09:14:01 <mun> Duqicnk: yes that's right
09:14:07 <Gracenotes> so that the constructor is Map, and module functions/values are Map.foo
09:14:12 <Duqicnk> yes
09:14:25 <Duqicnk> mun: Map.Map is the type named Map in the module imported as Map
09:14:42 <Saizan_> the "as X" part gives you the ability to refer to the same module using the shorter name X
09:16:55 <mun> but in Data.Map, there isn't a function called Map. there's only map.
09:17:05 <EvilTerran> there's a type called Map, though
09:17:11 <mun> ooh
09:17:13 <mun> yes, thanks
09:17:19 <mun> it's a type constructor, rather
09:17:27 <EvilTerran> well, yes
09:17:35 <EvilTerran> (well spotted)
09:17:36 <mun> sorry for not reading Duqicnk's response properly
09:19:55 <blip> should finding the maximum in a red black tree take a few seconds or be instant?
09:20:02 <mak__> hi, can any one tell my why this program used so may memory (moust allocations are in dfs ) http://hpaste.org/fastcgi/hpaste.fcgi/new
09:20:06 <pumpkin> shouldn't it be Data.Map.T? ;)
09:20:23 <pumpkin> mak__: not sure I have anything to paste in answer yet ;)
09:20:30 <mak__> s/may/many ;]
09:20:47 <blip> mak__ you pasted nothing
09:20:52 <pumpkin> mmm (Data.Ord.C a) => (Data.Map.T Int a)
09:20:52 <mak__> ups ;]
09:20:59 <mak__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3466#a3466
09:21:01 <mak__> sry ;]
09:21:45 <jmcarthur> blip, finding the max element of a red black tree should be fast enough that you perceive it as instant
09:22:09 <jmcarthur> unless your comparison function is really slow
09:22:10 <pumpkin> what if you have an RB tree with a quintillion elements in it?
09:22:23 <doserj> if the tree is already constructed. we are in a lazy language, after all...
09:22:25 <jmcarthur> pumpkin, that fits in memory?
09:22:26 <blip> ok so building a 100000 rbt could take time?
09:22:42 <jmcarthur> blip, oh, yeah, *building* the tree may take a while
09:22:46 <pumpkin> jmcarthur: you have a 64 bit machine and lots of swap
09:22:47 <pumpkin> :P
09:23:03 <blip> ah yeah
09:23:04 <jmcarthur> blip, the tree should probably be strict to avoid that problem
09:23:07 <b_jonas> which quintillion?
09:23:11 <b_jonas> long or short?
09:23:13 <pumpkin> b_jonas: the larger one
09:23:19 <jmcarthur> well, to avoid the problem of it not building until you query it
09:23:29 <blip> if I build it is lazy, so if I first call findMinimum that takes a while but then findMaximum is instant so it is building that takes a while
09:23:39 <b_jonas> it needn't fit in memory, you can store trees on a disk (caching some of it in ram)
09:23:44 <pumpkin> yup
09:23:54 <b_jonas> but still a long quintillion won't fit there either
09:23:58 <mun> is data Foo = Bar { A :: String, B :: Int} same as data Foo = Bar String Int?
09:24:10 <jmcarthur> yeah but that would best be done with something like a B+ tree, not a plain vanilla red-black
09:24:11 <pumpkin> b_jonas: let's say you have a LOT of disk space :P
09:24:15 <wli> B trees tend to help on account of their loading-from-disk algorithms.
09:24:26 <doserj> mun: the first is a syntax error. A and B have to be lower case
09:24:33 <mun> only that the latter doesn't have the fields named?
09:24:33 <b_jonas> jmcarthur: true
09:24:39 <mun> doserj: oh ok
09:24:40 <Gracenotes> mun: yeah, but with extra accessors and modifiers
09:25:00 <mun> thanks
09:25:06 <Gracenotes> in both cases, you can make a Foo via: Bar "Str" 0
09:25:19 <mun> Gracenotes: great
09:25:28 <Gracenotes> in the former, you can make Bar { a = "Str", b = 0 }. I think. Something like that.
09:25:47 <Gracenotes> if baz is a Foo, you can access a by using "a baz"
09:26:01 <Gracenotes> you can also modify a field, baz { a = "NewStr" }
09:26:08 <Gracenotes> that's basically it :X
09:26:09 <b_jonas> @let data Foo = Bar {A :: String, B :: Int}
09:26:09 <lambdabot>   Parse error
09:26:10 <mun> excellent
09:26:27 <Gracenotes> well, not 'modify' per se. Just make a new copy with the different field :)
09:26:42 <mun>  @let data Foo = Bar {a :: String, b :: int}
09:27:01 <pumpkin> I'm pretty sure lambdabot won't let you define datatypes
09:27:05 <mak__> hmm any one? ;]
09:27:20 <pumpkin> mak__: all that IO scares us away
09:27:32 <mak__> heh
09:28:40 <mak__> if i have any idea how to throw it away i will but now, its fastest an lower memory eters version ;]
09:29:06 <pumpkin> already told you yesterday about ST :P
09:29:09 <pumpkin> but anyway
09:29:49 <Gracenotes> mak__: try profiling?
09:30:02 <mak__> pumpkin: i use st, but it wasnt make any imporvment
09:30:16 <pumpkin> mak__: it's not supposed to improve memory usage, it's supposed to improve your API :P
09:30:22 <mak__> heh
09:30:34 <Gracenotes> perhaps getContents is a problem X.X
09:30:34 <pumpkin> anyway, yeah, profiling is probably best
09:31:11 <Gracenotes> also, frequent conversion from list to array and back tends to consume memory (although releasing it.. hopefully)
09:31:30 <mak__> Gracenotes: almoust 40% of allocations is made in dfs functions
09:32:08 <mak__> getContents isn't poblematic as i see
09:35:09 <McManiaC> hey im missing the Network.URI package, how can i install that?
09:37:58 <pumpkin> mak__: what does profiling say? look at the one that tells you what kind of data is using up memory?
09:38:53 <mak__> MapInt
09:39:21 <mak__> when I create it and geting lists from
09:40:17 <mak__> I'm not suprised that it eats memory when is created but on geting from?
09:40:38 <Gracenotes> IntMap is reasonably efficient. compared to Map anyway
09:40:39 <mak__> shouldn't this data be shared?
09:40:43 <Gracenotes> iirc
09:41:09 <QuietPurple> I'm having difficulty writing a Show instance for a datatype i've created
09:41:14 <QuietPurple> here is the type:
09:41:16 <QuietPurple> data Data a => Vine a = Bunch [Vine a] | Grape a
09:41:37 <Gracenotes> try deriving Show
09:41:39 <QuietPurple> instance Show Vine Int where   --is giving me errors
09:41:42 <FliPPeh> @faq Can Haskell cause global thermonuclear war?
09:41:42 <lambdabot> The answer is: Yes! Haskell can do that.
09:41:58 <FliPPeh> ...!
09:42:02 <Gracenotes> QuietPurple: try instance (Show a) => Vine a where
09:42:08 <FliPPeh> > do StartWar
09:42:09 <lambdabot>   Not in scope: data constructor `StartWar'
09:42:15 <omnihil> @faq Would Haskell like to play a game?
09:42:15 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:20 <Gracenotes> QuietPurple: or just: Vine a = Bunch [Vine a] | Grape a deriving (Show)
09:42:23 <QuietPurple> @faq Can Haskell create a task Haskell cannot perform
09:42:24 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:25 <Gracenotes> for an automatically derived instance
09:42:26 <lament> FliPPeh: you can do it, but it's unsafe
09:42:35 <FliPPeh> Might have side effects or what?
09:42:36 <omnihil> @faq Can Haskell then execute that task?
09:42:36 <lambdabot> The answer is: Yes! Haskell can do that.
09:42:42 <lament> FliPPeh: yeah :(
09:42:46 <FliPPeh> Meh
09:42:50 <QuietPurple> Gracenotes: thanks, that's a real help
09:42:56 <FliPPeh> Well, thank the IO Monad!
09:43:01 <BMeph> or deriving (Data, Show).
09:43:06 <FliPPeh> > res <- startGlobalThermonuclearWar
09:43:08 <lambdabot>   <no location info>: parse error on input `<-'
09:43:42 <FliPPeh> > do startGlobalThermonuclearWar; shiftBlameTo Korea
09:43:43 <lambdabot>   Not in scope: `startGlobalThermonuclearWar'Not in scope: `shiftBlameTo'Not ...
09:45:39 <QuietPurple> hmmm... now it says "showPrec is not a (visible) method of class Vine" or something like that
09:46:03 <QuietPurple> i'm using the following:
09:46:04 <QuietPurple>   showsPrec _ vine = showString (stringifyV vine)
09:46:27 <QuietPurple> where stringifyV :: Show a => Vine a -> String
09:47:03 <doserj> does it really say "of class Vine"?
09:47:05 <QuietPurple> I'm quite new to the whole creating datatypes thing
09:47:31 <QuietPurple> of class 'Vine'
09:48:34 <doserj> and you are writing "instance Show (Vine a) where" or something similar?
09:48:51 <QuietPurple> yeah --- instance Show (Show a) => Vine a where
09:49:12 <doserj> instance Show a => Show (Vine a) where
09:49:31 <pumpkin> Show (Show a) looks like it needs a join ;)
09:50:10 <McManiaC> hey, i just installed GHC and "Network.URI" seems to be missing, how can I add that to the standard lib?
09:50:13 <Gracenotes> oh, yes, you do need a Show after the =>
09:50:14 <doserj> your instance declaration is trying to say that 'a' is in the class Vine, if 'Show a' is in the class Show
09:50:18 <QuietPurple> oh god now i have pages of errors!
09:50:52 <QuietPurple> instance Show a => Show (Vine a) where
09:50:57 <QuietPurple> is that right?
09:51:05 <doserj> QuietPurple: but why not just "deriving Show"?
09:51:11 <QuietPurple> i've done that
09:51:21 <QuietPurple> data Data a => Vine a = Bunch [Vine a] | Grape a     deriving (Data, Show)
09:51:25 <QuietPurple> is what it is now
09:51:47 <Gracenotes> hm?
09:52:24 <Gracenotes> what was BMeph on about regarding deriving (Data, Show)? :X
09:52:39 <QuietPurple> i'm lost---as i say, i'm still not 100% sure how all these types and classes work
09:52:57 <Gracenotes> data Vine a = Bunch [Vine a] | Grape a deriving (Show, Eq) -- probably the canonical way to do it
09:53:02 <Gracenotes> I'm pretty sure
09:53:11 <QuietPurple> ok
09:53:16 <wli> data Data a = Data [Data a] | Datum a deriving (Data, Show)?
09:53:17 <doserj> you don't need to (and cannot) declare an instance Show (Vine a) if you are deriving Show
09:53:23 <QuietPurple> i'm not sure what the deriving part does
09:53:29 <QuietPurple> I got other types to work without it
09:53:35 <doserj> QuietPurple: it does the instance declaration for you
09:53:43 <lpsmith> Rose Trees?
09:53:47 <FliPPeh> I suck in haskell :(
09:53:48 <FliPPeh> !paste
09:53:55 <FliPPeh> Nopaste :(
09:54:02 <QuietPurple> but the machine needs to know how to show the type, doesn't it?
09:54:24 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2067#a2067
09:54:30 <FliPPeh> What is FliPPeh doing wrong?
09:54:33 <QuietPurple> i still need to define showsPrec
09:54:52 <FliPPeh> Line 11, Couldn't match expected type `Char' against inferred type `[Char]'
09:54:57 <Gracenotes> > Nothing :: Maybe (a -> a)
09:54:58 <FliPPeh> :(
09:54:58 <lambdabot>       Overlapping instances for Show (a -> a)
09:54:58 <lambdabot>        arising from a use of `s...
09:55:27 <Gracenotes> (a -> a) can't be shown. So a Maybe (a -> a) can't be shown either. deriving for polymorphic types depends on the types you fill in
09:55:30 <lpsmith> FliPPeh:   the problem is that you are passing a list of strings into putStrLn
09:55:37 <FliPPeh> Dang.
09:55:39 <Gracenotes> > Nothing :: Maybe a
09:55:41 <lambdabot>   Nothing
09:55:41 <FliPPeh> You're right
09:55:53 <Gracenotes> unqualified is fine though.. hrm
09:56:03 <FliPPeh> Working, thanks lpsmith
09:56:39 <b_jonas> Gracenotes: there's a module that defines a dummy Show for functions though
09:56:39 <QuietPurple> oh well, I've got to go make dinner now....
09:56:46 <b_jonas> > id
09:56:47 <lambdabot>       Overlapping instances for Show (a -> a)
09:56:47 <lambdabot>        arising from a use of `s...
09:56:55 <b_jonas> > \x -> x + 1
09:56:56 <lambdabot>       Overlapping instances for Show (a -> a)
09:56:57 <lambdabot>        arising from a use of `s...
09:57:13 <b_jonas> doesn't work here because the symbolic computation module overlaps with it
09:57:17 <Gracenotes> yes. Well, not by default. (a -> a) is just an arbitrary example of a type that doesn't have a Show instance
09:57:28 <FliPPeh> I love the newbie support in here
09:57:32 <FliPPeh> Everyone's so patient
09:57:32 <Gracenotes> (normally) in this case, I suppose it has >1
09:58:29 <lilac> i don't see how 'Nothing :: Maybe a' works...
09:58:43 <lpsmith> FliPPeh:  You are welcome.  That's actually a pretty well written program,  modulo the type error :-)
09:58:44 <EvilTerran> lilac, defaulting, probably
09:59:04 <lilac> > show (Nothing :: Maybe a)
09:59:05 <lambdabot>   "Nothing"
09:59:08 <dons> ?users
09:59:09 <lambdabot> Maximum users seen in #haskell: 658, currently: 616 (93.6%), active: 19 (3.1%)
09:59:13 <lilac> ^ does defaulting happen there?
09:59:16 <FliPPeh> ?seen flazz_
09:59:16 <lambdabot> flazz_ is in #haskell. I don't know when flazz_ last spoke.
09:59:19 <FliPPeh> ?seen FliPPeh
09:59:20 <lambdabot> You are in #haskell. I last heard you speak just now.
09:59:26 <dons> lilac: yep
09:59:44 <FliPPeh> ?faq Bunnies?
09:59:44 <Gracenotes> > let blah :: Ord a => a; blah = undefined in show (Nothing `asTypeOf` Just blah)
09:59:45 <lambdabot> The answer is: Yes! Haskell can do that.
09:59:47 <lambdabot>   "Nothing"
09:59:53 <bavardage> @src LocalTime
09:59:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
09:59:56 <Gracenotes> hm. So unrelated constraints is fine too
10:00:10 <lilac> > show (Just mempty :: Monoid m => Maybe m)
10:00:12 <lambdabot>   "Just ()"
10:00:45 <pumpkin> @src () mappend
10:00:46 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:00:47 <Gracenotes> ah! Another bit of weird defaulting
10:00:49 <lilac> i would have assumed the type signature would enforce m to be a rigid type variable
10:00:50 <pumpkin> @src (()) mappend
10:00:50 <lambdabot> Source not found. stty: unknown mode: doofus
10:00:54 <EvilTerran> @check \x y -> x == y -- :D
10:00:56 <lambdabot>   "OK, passed 500 tests."
10:01:03 <pumpkin> what's the operation for the () monoid? :o
10:01:10 <pumpkin> const () I guess? :P
10:01:10 <EvilTerran> pumpkin, well, what could it be?
10:01:16 <ddarius> pumpkin: There's only one possibility.
10:01:16 <McManiaC> Could not find module `Network.URI':
10:01:19 <lilac> @djinn () -> () -> ()
10:01:19 <lambdabot> f _ a = a
10:01:20 <Gracenotes> () `mappend` () = .... anyone guess? anyone? Bueller?
10:01:21 <lpsmith> you know,  I've wondered if maybe lambdabot should be modified so if you ask if you've seen yourself,  you get back the last time you spoke before you left
10:01:28 <McManiaC> does no one know where to get Network.URI???
10:01:31 <pumpkin> sounds like a pretty exciting monoid
10:01:34 <lilac> @seen lilac
10:01:34 <lambdabot> You are in #haskell. I last heard you speak just now.
10:01:36 <EvilTerran> McManiaC, hackage?
10:01:42 <Gracenotes> however, for some reason the library defines () functions to be strict in both arguments
10:01:45 <Gracenotes> > () == undefined
10:01:47 <lambdabot>   * Exception: Prelude.undefined
10:01:58 <McManiaC> EvilTerran: it should be in the standard lib
10:01:58 <Gracenotes> a conscious choice I suppose
10:02:07 <pumpkin> aw
10:02:08 <ddarius> Gracenotes: That's the only correct definition.
10:02:10 <lilac> Gracenotes: that makes it associative on {(), _|_}
10:02:28 <Gracenotes> hm. I see.
10:02:39 <Gracenotes> by merit of it being a unit type, I suppose?
10:02:43 <lilac> do i mean associative?
10:02:59 <lilac> it makes () a left and right identity at least :)
10:03:18 <jedai> McManiaC: It is in the network package
10:03:32 <jedai> Which might be part of the extra-libs IIRC
10:04:00 <jedai> Indeed it is :)
10:04:25 <McManiaC> ok
10:04:32 <McManiaC> how to install that package? :D
10:05:24 <McManiaC> darcs get Network ??
10:05:35 <Gracenotes> ddarius: why would a definition lazy in both arguments be incorrect?
10:05:47 <jedai> McManiaC: Normally it is part of the binary distribution of GHC, so if you don't have it, either you installed from source or your installed with a package manager ?
10:05:59 <lilac> Gracenotes: () `mappend` _|_ = _|_ by the first monoid law
10:06:00 <EvilTerran> Gracenotes, because undefined `mappend` undefined must be undefined
10:06:17 <ddarius> EvilTerran: No it doesn't.
10:06:23 <EvilTerran> no?
10:06:25 <Gracenotes> hm. So what about ==?
10:06:27 <jedai> McManiaC: Do tell which please, it will help direct further counsel
10:06:29 <McManiaC> jedai: with aptitude on debian
10:06:33 <ddarius> EvilTerran: The laws say nothing about undefined `mappend` undefined
10:06:37 <McManiaC> aptitude install ghc
10:06:39 <ddarius> EvilTerran: What lilac said is the issue.
10:06:46 <lilac> monoid laws require mempty `mappend` undefined = undefined, undefined `mappend` mempty = undefined
10:06:57 <Gracenotes> is there such a requirement for ==?
10:07:01 <EvilTerran> ddarius, yeah, i worked that out when i read lilac's line that he finished while i was still typing
10:07:04 <jedai> McManiaC: in this case there is no doubt that there is a package containing network for your ghc
10:07:05 <EvilTerran> no need to go on about it :)
10:07:06 <pumpkin> no laws on ==
10:07:09 <pumpkin> :P
10:07:17 <centrinia> a == b <=> b == a
10:07:50 <Gracenotes> yes, commutativity. and transitivity I suppose. and reflexivity.
10:07:51 <lilac> is "mappend = unamb" a legal definition for () then?
10:08:00 <jedai> McManiaC: on Ubuntu for instance it is libghc6-network-dev
10:08:01 <pumpkin> it's not stated in the module is it?
10:08:15 <centrinia> Commutativity is called symmetry with respect to relations.
10:08:23 <Gracenotes> yes, that's the term
10:08:45 <McManiaC> jedai: thanks!
10:08:47 <jedai> McManiaC: it should be easy to find the correct one, a simple search apt-cache search ghc.*network
10:08:52 <McManiaC> its working :)
10:08:53 <Gracenotes> the components of an equivalence relation :X it seems a lazy == would meet these
10:08:56 <Gracenotes> for unit
10:08:57 <jedai> should deliver the solution
10:09:17 <jedai> Good luck with the continuation then ^^
10:09:31 <ddarius> lilac: I believe so.
10:09:42 * lilac thinks it's not possible to create a function f :: () -> () -> () where f _|_ () = _|_; f () _|_ = () but f _|_ _|_ = ()
10:09:51 <McManiaC> :)
10:10:05 <ddarius> lilac: That is indeed the case.
10:10:19 <edwardk> @seen dons
10:10:19 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 10m 53s ago.
10:10:38 <ddarius> lilac: If you wanted to prove it, you'd have to show that such a function is not continuous in the Scott topology.
10:11:01 <lilac> ddarius: easier: "f undefined" terminates iff its argument does not.
10:11:03 <edwardk> dons: i think i may have solved the general tuple packing problem up to around tuples of 5 and made it so i can mix unboxed values as well. not sure if i have the speed yet, but its looking good
10:11:04 <Gracenotes> > let f a () = a; f () a = a; f a b = () in f undefined undefined
10:11:05 <lambdabot>   mueval: Prelude.read: no parse
10:11:05 <lambdabot>  mueval: UnknownError "GHC reported errors a...
10:11:35 <centrinia> Doesn't the function fix :: (a -> a) -> a prove everything by virtue of the Curry Howard correspondence?
10:11:44 <ddarius> Yes.
10:11:47 <edwardk> centrinia: yes it assumes the hypothesis
10:11:48 <ddarius> :t fix id
10:11:49 <lambdabot> forall a. a
10:12:04 <lilac> centrinia: the logic curry-howard provides from haskell's type system is not interesting
10:12:04 <Gracenotes> assuming a, then a
10:12:05 <edwardk> centrinia: logical paradoxes make great combinators
10:12:37 <ddarius> Gracenotes: That's valid and gives you \x -> x :: a -> a
10:12:55 <ddarius> With appropriate parens.
10:13:06 <Gracenotes> so fix would allow, assuming False implies False, then False
10:13:08 <centrinia> lilac, the Haskell type system corresponds to a trivial logic via Curry-Howard?
10:13:30 <ddarius> centrinia: An inconsistent one, yes.
10:13:35 <centrinia> Okay.
10:13:41 <lilac> centrinia: yes; every type is inhabited, so every statement is true.
10:14:22 * lilac recently discovered that there are Haskell'98 types which do not have or contain bottoms
10:14:44 <EvilTerran> ?type undefined -- trivial proof of anything
10:14:45 <lambdabot> forall a. a
10:14:53 <edwardk> lilac: ?
10:15:04 <EvilTerran> lilac, things like newtype Foo = Foo Foo?
10:15:10 <lilac> EvilTerran: yep
10:15:11 <dons> edwardk: ooh yay.
10:15:18 <dons> edwardk: i'm thinking we should set up a shared repo
10:15:29 <ddarius> lilac: undefined :: Foo is a proof that that type contains bottom
10:15:49 <edwardk> dons: definitely. i'm defining a complicated set of type families, and classes that know how to pack values into a smaller set of slot types.
10:15:51 <lilac> ddarius: nope. undefined :: Foo is Foo (Foo (Foo (Foo (... for EvilTerran's example
10:15:57 <edwardk> and then putting a canonical order on the slot types.
10:16:17 <lilac> ddarius: arguably that value /is/ bottom for that type
10:16:21 <edwardk> so Integers come before Doubles come before Ints for instance, then i use far fewer classes to represent the types of slots.
10:16:26 <lilac> ddarius: but it's also top, so...
10:16:39 <ddarius> I see what you are getting at, but seq still foils you.
10:16:40 <edwardk> and give a data family of kind * -> * so its still branded with the types that go into the slots
10:16:46 <lilac> ddarius: how so?
10:17:19 <EvilTerran> ?? (?src Mu) (?src Identity)
10:17:24 <edwardk> it requires a little bit of magic and unsafecoerce work for boxes because i only have one 'slot type' for boxed slots, but the brands provide the proof obligation that its ok
10:17:26 <ddarius> case (undefined :: Foo) `seq` () of () -> () is undefined.
10:17:36 <lilac> ddarius: actuallyu it's not; try it!
10:17:38 <EvilTerran> ?bot
10:17:38 <lambdabot> :)
10:17:41 <EvilTerran> hm
10:18:03 <EvilTerran> > undefined :: Mu Identity
10:18:04 <lambdabot>       No instance for (Show (Mu Identity))
10:18:04 <lambdabot>        arising from a use of `show...
10:18:08 <EvilTerran> bah
10:18:22 <edwardk> dons: then from that i can just provide instances for all combinations of slots that add up to less than some upper complexity bound. i.e. 4-5 slots, and the ordering on the packed slots keeps it reasonable
10:18:24 <EvilTerran> ,src ''Identity
10:18:27 <lunabot>  luna: Not in scope: type constructor or class `Identity'
10:18:29 <EvilTerran> ,src ''Id
10:18:33 <lunabot>  newtype Id a = I a
10:18:40 <EvilTerran> ,src ''Fix
10:18:43 <lunabot>  newtype Fix s a = InB {outB :: (s a (Fix s a))}
10:19:01 <lilac> > undefined :: Fix Id
10:19:01 <EvilTerran> hm
10:19:02 <lambdabot>   Not in scope: type constructor or class `Fix'Not in scope: type constructor...
10:19:02 <edwardk> it'd be 253 instances to support Ints, Int64s, Integers, Doubles, and Boxes as valid slot types and handle all combinations involving up to 5. it handles pairs of pairs, etc.
10:19:03 <EvilTerran> ,src ''FixF
10:19:04 <lilac> , undefined :: Fix Id
10:19:06 <lunabot>  luna: Kind mis-match
10:19:06 <lunabot>  newtype FixF f = InF {outF :: (f (FixF f))}
10:19:13 <EvilTerran> , undefined :: FixF Id
10:19:14 <lilac> , undefined :: FixF Id
10:19:15 <lunabot>  luna: No instance for (GHC.Show.Show
10:19:15 <lunabot>  luna: No instance for (GHC.Show.Show
10:19:18 <EvilTerran> gah
10:19:29 <lilac> , (undefined :: FixF Id) `seq` ()
10:19:30 <lunabot>  luna: Prelude.undefined
10:19:32 <ddarius> lilac: I just did and it did exactly what I said it would.
10:19:58 <EvilTerran> , (undefined :: FixF Id) `seq` ()
10:19:59 <lunabot>  luna: Prelude.undefined
10:20:02 <lilac> ddarius: here I get a result of () as I said it would ...
10:20:05 <edwardk> gah i may have gotten cut off by my connection, did i drop?
10:20:10 <pumpkin> nope
10:20:25 <edwardk> dons: anyways, the idea make sense?
10:20:31 <lilac> ddarius: I'm on GHC 6.8.2; you?
10:20:37 <ddarius> 6.10.1
10:20:40 <EvilTerran> , (fix (InF . I) :: FixF Id)
10:20:42 <lunabot>  luna: Couldn't match expected type `a -> f (Control.Functor.Fix.FixF f)'
10:21:10 <EvilTerran> er?
10:21:28 <EvilTerran> , [$typ|InF . I|]
10:21:30 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
10:21:41 <EvilTerran> no?
10:21:44 <lilac> ddarius: actually i messed up the example. but there's still no problem here
10:21:57 <EvilTerran> ah, lunabot responds to /msg now
10:22:00 * EvilTerran does that instead
10:22:03 <lilac> ddarius: undefined :: Foo == fix Foo, and "fix Foo `seq` ()" is bottom too
10:22:33 <lilac> ddarius: this all follows from seq being left-strict, and (fix Foo) being the bottom for type Foo
10:23:10 <lilac> ddarius: so i guess i've learned that 'Foo' does indeed have a bottom, but that bottom is fully-defined. weird...
10:23:27 <edwardk> dons I may be able to make it so i can support an arbitrary sized tuple as long as the individual elements are all packable, and handle tuples larger than 4-5 elements, but with all the remaining values boxed.
10:23:54 <edwardk> lilac: i thought so
10:24:27 <edwardk> if you had haskell 98 types without bottom then haskell would have an initial object.
10:25:00 <edwardk> and I'd be able to make a total method for Either Absurd a -> a
10:25:19 <centrinia> What would that initial object be?
10:25:38 <edwardk> but Absurd can't possibly not have a bottom in it, or it could some how magically prevent me from creating the constructor _around_ it.
10:26:18 <ddarius> edwardk: You just need unboxed types.
10:29:32 <jad4> edwardk, not sure if I understand what you mean with the magic and constructor part
10:29:54 <jad4> edwardk, but maybe you want a strictness annotation after Either?
10:30:20 <edwardk> jad4: the basic problem is that Either is lazy in its arguments, and Either can contain any (boxed) type in its left hand side.
10:30:25 <lilac> centrinia: i think the initial object would be uninhabited.
10:30:43 <lilac> if the objects we're talking about are types
10:30:58 <jad4> edwardk, ok so why don't you use  Either !Absurd a -> a
10:31:05 <centrinia> Why would it be uninhabited?
10:31:09 <jmcarthur> I think a lot of the standard library data types should be strict. :\
10:31:19 <jad4> edwardk, that makes it strict on it's first argument
10:31:43 <nlogax> BONUS_: i think i get it now, thanks to your explanation (there was no magic) and some fresh air. it's just like a series of tubes!
10:32:08 <jmcarthur> i guess maybe not Maybe or Either though, since them being lazy means you can do different things without evaluating their contained values
10:32:27 <edwardk> jad4: i'm aware of the way strictness annotations work, but the point is that such an initial object would do that to every type. (plus iirc the bang in the type there won't work due to syntactic limitations)
10:32:39 <lilac> centrinia: so there exist (trivial) functions from it to all other types, so that it's a pull-back from... umm... some diagram. i wish i understood category theory... :(
10:33:31 <edwardk> it would make any constructor that tried to wrap it uninstantiable, and any type that consistent entirely of such constructors as also uninhabitable as well, including by bottom, this runs counted to the idea of laziness, because bottom is a thunk that inhabits those types.
10:35:03 <edwardk> haskell as a terminal object, well, several things that are all isomorphic that you can view as a terminal object, but no initial object that would require the language to be total.
10:35:38 <dolio> It doesn't really have a terminal object, either.
10:35:49 <ddarius> dolio: Sure it does.
10:35:55 <edwardk> dolio: data Void
10:35:56 <dolio> Oh, are you thinking of Absurd?
10:35:58 <dolio> Right.
10:36:05 <edwardk> type Absurd = forall a. a
10:36:09 <lilac> isn't any type with only one inhabitant terminal?
10:36:14 <b_jonas> data Void where { }
10:36:23 <lilac> newtype Void = Void Void ? :)
10:36:44 <Beelsebob> edwardk: I can think of a value of that type
10:36:46 <Beelsebob> _|_
10:36:57 <ddarius> Beelsebob: That's necessary for it to be terminal.
10:36:58 <edwardk> beelsebob: undefined, error, etc.
10:37:05 <olsner> hmm, but is _|_ really a value?
10:37:07 <b_jonas> lilac: does that even work?
10:37:08 <ddarius> Yes.
10:37:09 <Beelsebob> yes
10:37:17 <edwardk> oslner: yes
10:37:17 <Beelsebob> unfortunately :(
10:37:21 <lilac> b_jonas: even in '98
10:37:28 <lilac> (whereas the others don't)
10:37:44 <b_jonas> lilac: that's strange
10:37:47 <b_jonas> I mean
10:37:50 <dolio> Absurd isn't really terminal, either, because _|_ and \_ -> _|_ are distinguishable by seq. Boom! :)
10:37:54 <b_jonas> isn't newtype supposed to be strict?
10:38:04 <olsner> doesn't non-termination or exception-throwing mean that you insert magic instead of values?
10:38:06 <edwardk> dolio: that is a valid argument ;)
10:38:15 <dolio> Technical victory! :)
10:38:19 <b_jonas> wouldn't a data that includes itself strictly be illegal?
10:38:57 <lilac> b_jonas: it'd have only one inhabitant, but i don't see why it'd need to be illegal
10:39:01 <edwardk> seq kind of pisses all over the metatheory of haskell
10:39:14 <ddarius> Haskell has a metatheory?
10:39:25 <edwardk> ddarius: no, mostly because of seq ;)
10:39:49 <b_jonas> lilac: oh, I see, it's also polymorphic so there is a level of pointer there
10:39:51 <b_jonas> I see
10:39:54 <ddarius> Yes, dolio's argument comes down to: Absurd isn't a terminal object because Haskell doesn't even form a category.
10:40:03 <dolio> :)
10:40:10 <lilac> b_jonas: FWIW, GHC accepts 'data Foo = Foo !Foo' and it acts like 'newtype Foo = Foo Foo' for the most part
10:40:44 <b_jonas> lilac: yep, I just tried data Foo = Foo Int ! Foo deriving (Eq, Show) in ghci and it gave no error
10:40:54 <b_jonas> though I can't make an instance of it other than undefined
10:40:58 <lilac> b_jonas: although the newtype formulation is lazier in some sense
10:40:59 <olsner> shouldn't those two be equivalent?
10:41:22 <Baughn> lilac: You mean "data Foo = Foo !Bar", right?
10:41:28 <lilac> Baughn: nope
10:41:44 <Baughn> Gah. Okay. Why would you do that?
10:42:04 <lilac> well, you wouldn't, if you were sensible, i suppose :)
10:42:10 <dolio> To define the 'empty' type in Haskell98.
10:42:57 <lilac> "case fix DataFoo of DataFoo a -> ()" is _|_ whereas "case fix NewTypeFoo of NewTypeFoo a -> ()" is ()
10:43:43 <b_jonas> well, I still think if you want to define the empty type, 'data Void where { }' is better
10:43:52 <b_jonas> but it's good to know about this as well
10:44:04 <olsner> which means that newtype pattern matching is a guaranteed no-op, while for a one-constructor data that's an optional optimization?
10:44:07 <Baughn> What's wrong with just "data Void"?
10:44:27 <Baughn> olsner: Yes
10:44:42 <Baughn> Newtypes exist purely as figments of the compiler's imagination
10:45:10 <edwardk> Baughn: its not haskell 98 but i use it a lot
10:45:11 <olsner> what happens if you make the compiler try to produce an unboxed DataFoo?
10:45:33 <jedai> olsner: A one-constructor one-parameter data pattern matching can't be optimized away (except if the parameter is strict)
10:45:35 <b_jonas> Baughn: my problem with that is that it looks like declaring Void as an opaque type, and indeed, in ghc's .hs-boot files it means such a type
10:45:58 <edwardk> olsner: does it have one constructor and a known number of unboxed arguments?
10:46:03 <olsner> jedai: in this example, the parameter is strict
10:46:09 <jedai> olsner: since there is a difference between undefined and Foo undefined if Foo is a constructor for a data
10:46:43 <jedai> olsner: Ok in this case it can be optimized :) but the semantics of Haskell don't guarantee it contrary to newtype
10:46:53 <b_jonas> hmm, I'm confused now
10:46:56 <b_jonas> I see
10:47:10 <olsner> jedai: data DataFoo = DataFoo !DataFoo
10:47:15 <b_jonas> anyway, I think I understood something about haskell when coming home on the tram
10:47:28 * EvilTerran worked out the problem with lunabot earlier
10:47:34 <EvilTerran> ,src ''Id
10:47:35 <EvilTerran> ,src ''SKI
10:47:37 <ddarius> olsner: It's not an "optional optimization
10:47:37 <lunabot>  newtype Id a = I a
10:47:39 <lunabot>  data SKI = S | K | I | E Exp | SKI `(:$)` SKI
10:47:49 <EvilTerran> ^ there's two constructors called I in scope
10:48:00 <ddarius> case undefined of DataFoo _ -> ... must be undefined and must not be undefined in the newtype case.
10:48:50 <EvilTerran> > (fix (In . Identity) :: Mu Identity) `seq` ()
10:49:05 <lambdabot>   thread killed
10:49:10 <b_jonas> namely I think I understand now why it's natural that ghci can work the way it does, accepting IO statements but not arbitary top-level declaratoins
10:49:38 <EvilTerran> interesting
10:50:03 <Baughn> b_jonas: Accepting arbitrary top-level declarations would be /more work/
10:50:08 <lilac> b_jonas: so there's a sound reason we can't define types in ghci?
10:50:19 <Baughn> b_jonas: There's not some deep reasoning behind it. Though some people might pretend there is. :P
10:50:27 <b_jonas> there is I think
10:50:47 <Baughn> Not really. You could always regenerate the whole environment, if that's what it takes.
10:50:54 <ddarius> There is no reason you can't have an interactive interpreter for Haskell that accepts the full language.  hbci does this.
10:50:58 <b_jonas> I'm not saying it would be impossible,
10:51:07 <b_jonas> it's certainly possible
10:51:18 <lilac> arguably there's a temporal problem. if i write a function using type T and then later define type T, how can my function work?
10:51:37 <FliPPeh> @bf +++.
10:51:38 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
10:51:39 <b_jonas> but I'm saying I can see why it's _one_ possible natural choice to restrict the inputs to just those things that ghci does
10:51:55 <olsner> ddarius: aha, I see... haskell has so many bottoms :)
10:52:02 <b_jonas> if you're interested I can try to explain it briefly
10:53:08 <Baughn> lilac: By recompiling the function
10:53:36 <jedai> b_jonas: it's natural because it's like we're in a IO function, which is the only place where order matter in Haskell. And since an interactive loop like GHCI impose order anyway...
10:53:37 <ddarius> Well it depends on what you mean by "later."
10:54:16 <jedai> That was always my justification anyway ^^
10:54:23 <Baughn> jedai: Hardly the /only/ place. ST and such..
10:54:37 <Baughn> Or, well, most monads would be annoyed if you reorder statements
10:54:50 <b_jonas> @unpl let f x y = x ++ [y] in f
10:54:50 <lambdabot> let { f x y = x ++ ([y])} in f
10:54:53 <dolio> ST would prevent it from printing anything.
10:55:05 <b_jonas> @hoogle []a -> a -> []a
10:55:06 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
10:55:06 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
10:55:06 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
10:55:16 <Baughn> dolio: You could always use unsafePerformIO
10:55:17 <jedai> Baughn: Well ok but you want to be able to do IO and every other monad can be run so...
10:55:19 <b_jonas> no builtin snoc
10:55:35 <dolio> unsafeIOToST would be preferable.
10:55:42 <ddarius> b_jonas: Why would there be?  It's bad enough we have last and init.
10:55:53 <jedai> Baughn: besides there are some monads that are commutative :)
10:56:00 <Baughn> @index unsafeIOToST
10:56:00 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
10:56:01 <pumpkin> what's wrong with init?
10:56:04 <b_jonas> ddarius: yeah, I cold use two lists
10:56:23 <ddarius> b_jonas: Or you could use a queue...
10:56:34 <b_jonas> but I don't think that would make things better here, the rest of the program will have to do much more computation
10:57:17 <EvilTerran> Seq?
10:58:11 <b_jonas> EvilTerran: or that too, yeah
10:58:46 <pumpkin> Bulat is replying to himself with Hello Bulat now :o
10:59:02 <b_jonas> but actually as this is the list that stores the declarations in my ghci command that allows you to declare top-level stuff, after an appending you'll recompile the whole thing anyway which is certainly much more work than just the appending
10:59:47 <ddarius> pumpkin: Don't those pre-generated salutation templates just make you feel warm?
11:00:04 <pumpkin> yup :)
11:01:09 <BMeph> pumpkin: No. 1 (with a Bulat)? ;p
11:01:40 <b_jonas> ddarius: you remind me to birthday greeting email I got from a random site where I registered with a bogus birthday
11:16:07 <QuietPurple> well, I'm back (dinner is in the oven) and I have more questions....  ^_^
11:17:56 <QuietPurple> so I've got my datatype Vine a, deriving (Show, Eq). How do I now write a show instance for it that shows it in a different way to the default?
11:18:11 <b_jonas> QuietPurple: in that case you don't derive Show
11:18:44 <QuietPurple> ah, so I'm back where I was before.
11:19:01 <b_jonas> then you define the necessary methods from the Show class on that type
11:19:05 <b_jonas> with an instance declaratoin
11:19:33 <b_jonas> that's just one method actually
11:19:46 <b_jonas> either show or showsPrec
11:20:07 <QuietPurple> ok. so I have an instance declaration. But it doesn't seem to work---
11:20:16 <QuietPurple> instance Show a => Show (Vine a) where
11:20:16 <QuietPurple>   showsPrec _ vine = showString (stringifyV vine)
11:20:58 <b_jonas> what's showString ?
11:21:04 <b_jonas> @hoogle showString
11:21:04 <lambdabot> Prelude showString :: String -> ShowS
11:21:04 <lambdabot> Text.Show showString :: String -> ShowS
11:21:27 <blip> what would a functor on a vector do?
11:21:34 <blip> what map on a list does?
11:21:37 <b_jonas> oh, I see
11:21:49 <QuietPurple> i looked at the Show instance for Bool and it used showString, so i did that too...
11:21:59 <edwardk> blip: yeah
11:22:04 <beelsebob> blip: that would seem sensible to me
11:22:18 <beelsebob> but the VectorSpace/AdditiveSpace etc instances seem more sensible there
11:22:33 <beelsebob> additiveGroup even
11:22:34 <yav> QuietPurple: the easiest is probably to just define the "show" method.  i
11:22:51 <BMeph> QuietPurple: Call #haskell the Radio Shack(R) of IRC - "You've got Questions? We've got Answers!" ;)
11:23:07 <QuietPurple> so i don't need to use showsPrec?
11:23:30 <QuietPurple> instance Show a => Show (Vine a) where
11:23:30 <QuietPurple>   show vine = showString (stringifyV vine)
11:23:32 <QuietPurple> ?
11:23:57 <yav> QuietPurple: yeah, that ought to work
11:24:03 <FliPPeh> @type zipWith
11:24:04 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
11:24:31 <yav> oh, withouth the showString
11:24:36 <yav> QuietPurple: ^
11:24:36 <b_jonas> er no
11:24:37 <QuietPurple> i see
11:24:43 <b_jonas> like that, yes
11:25:02 <FliPPeh> > zipWith (\a b -> show a ++ show b) [1..4] [5..6]
11:25:03 <lambdabot>   ["15","26"]
11:25:21 <slide_rule> how random is the System.Random module? I'm used to using urandom in Python and such when I want some really random numbers - is there a similar thing in Haskell?
11:25:33 <FliPPeh> > zipWith (\a b -> show a ++ show b) [1..4] [5..9]
11:25:34 <lambdabot>   ["15","26","37","48"]
11:25:36 <pumpkin> slide_rule: urandom is less random than random
11:25:43 <pumpkin> if you're talking about /dev/urandom
11:25:54 <Gracenotes> ((++) `on` show)
11:26:03 <pumpkin> Gracenotes and his on-fetish
11:26:27 <slide_rule> understood - it'll all pseudorandom, but if I understand correctly it's crypto-level randomness...correct?
11:26:40 <Gracenotes> I can't seem to escape on and ((->)e) instances for Applicative, Monad and Functor
11:26:41 <slide_rule> (I'm not doing anything even remotely critical, just curious)
11:26:47 <b_jonas> slide_rule: only /dev/random is crypto-level
11:26:52 <Gracenotes> and arrows, occasionally
11:26:56 <Gracenotes> they're EVERYWHERE
11:27:08 <slide_rule> oh. hrm - I thought urandom was the one that collected entropy from user devices...?
11:27:14 <pumpkin> nope, that's /dev/random
11:27:18 <trofi> random
11:27:19 <slide_rule> >:t on
11:27:23 <pumpkin> and it will block if it runs out of entropy
11:27:28 <pumpkin> until it gets more
11:27:37 <Gracenotes> move around your mouse crazily!
11:27:40 <osfameron> @index on
11:27:40 <lambdabot> bzzt
11:27:41 <slide_rule> huh.  well. s/urandom/random/ in above question, then
11:27:59 <QuietPurple> hmmm... i've now got a problem because stringifyV needs (Data a)....
11:28:00 <QuietPurple> instance Show a => Show (Vine a) where
11:28:00 <QuietPurple>   show vine = stringifyV vine
11:28:16 <osfameron> @wax on
11:28:16 <lambdabot> Maybe you meant: faq map thx what wn
11:28:17 <b_jonas> QuietPurple: well then add that to the constraint of the instance
11:28:27 <QuietPurple> shall i just do instance Show a, Data a => etc.
11:28:28 <b_jonas> like instance (Show a, Data a) => Show (Vine a) where
11:28:35 <QuietPurple> ok
11:28:37 <b_jonas> or you may want to drop the Show a if you don't need that
11:28:56 <QuietPurple> nah, stringifyV needs that too!
11:28:58 <Gracenotes> wha, Data?
11:29:13 <Gracenotes> I am confused about this Data typeclass. Where is it :\
11:29:13 <pumpkin> mmm Data
11:29:27 <QuietPurple> YAY, we have some serious showage here
11:29:43 <Gracenotes> well, if I know Haskell, it's certainly a grower
11:29:53 <Gracenotes> or shower. Or both :x
11:30:09 <pumpkin> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html
11:30:12 <QuietPurple> \me groans hugely
11:30:16 <Gracenotes> I'll ignore the fact that there was actually a person named Haskell
11:30:40 * QuietPurple damns lack of IRC exp points
11:31:05 * QuietPurple and then gives Gracenotes a disgusted look
11:31:05 <Hunner> haskell was named after a person, so yes there are people with that name
11:31:27 <yav> there's also a town named haskell i believe
11:31:42 <Gracenotes> several
11:31:52 <Gracenotes> always clogging up the google
11:31:55 <ddarius> Haskell, TX is about an hour or two north of where I live.
11:32:18 <pumpkin> anything interesting there?
11:32:28 <ddarius> I've never been there.
11:32:29 <b_jonas> towns?
11:32:32 <b_jonas> wow
11:32:40 <yav> lots of strong static types?
11:32:42 <b_jonas> I know there's a town named Perl somewhere in germany
11:32:43 <yav> (sorry)
11:32:43 <tromp_> we have to make do with a Haskell Court here
11:33:01 <tromp_> oh, also have a Haskell Lane
11:33:16 <dmhouse> Apparently, "python" is some sort of snake.
11:33:39 <Gracenotes> oh, apparently there's an island named Java somewhere
11:33:55 <glguy> ?remember dmhouse Apparently, "python" is some sort of snake.
11:33:55 <lambdabot> I will never forget.
11:33:57 <QuietPurple> Well, now that I have managed to get the Vine a type to work I have a challenge for all you Haskell people...
11:34:02 <b_jonas> dmhouse: yes, but actually Guido claims it's named after the Monty Python group (who did Life of Brian) which itself is likely named after the snake
11:34:57 <Gracenotes> oh, and C is named after... hm.... *gives up*
11:35:12 <b_jonas> Gracenotes: lol
11:35:17 <yav> Gracenotes: I think that it was the follower of B, actually
11:35:24 <ddarius> BCPL
11:35:32 <b_jonas> and then there's pascal and ada who are also named after people
11:35:38 <Gracenotes> yeah, it was
11:36:01 * pumpkin knew John Brainfuck
11:36:08 <b_jonas> but there are also plenty of languages named from common nouns or words derived of such: lisp, scheme, algol, forth
11:36:20 <Gracenotes> oh, I knew Emily Brainfuck
11:36:23 <ddarius> "Scheme" is short for "Schemer"
11:36:23 <Gracenotes> are they by chance related?
11:36:24 <b_jonas> and smalltalk etc
11:36:41 <slide_rule> b_jonas: enlighten me on algol?
11:36:54 <b_jonas> slide_rule: I'm just guessing it's derived from algorithm
11:36:58 <b_jonas> I'm not actually sure
11:37:06 <slide_rule> I'll ask the tubes
11:37:09 <ddarius> Probably "Algorithmic Language"
11:37:16 <QuietPurple> Challenge : can you write a function to produce an infinite list containing EVERY (Vine Int)???
11:37:18 <QuietPurple> data Data a => Vine a = Bunch [Vine a] | Grape a
11:37:25 <slide_rule> ddarius: so sayeth wikipedia
11:37:41 <Gracenotes> LITHP ith named after thomthing elsthe, I forget what
11:37:52 <canadaduane> Ok, how do you get an Int from an Integer?
11:37:56 <pumpkin> fromIntegral
11:38:00 <ddarius> LISt Processing
11:38:01 <Gracenotes> @type fromInteger
11:38:02 <lambdabot> forall a. (Num a) => Integer -> a
11:38:04 <pumpkin> or fromInteger if you realy want it
11:38:05 <QuietPurple> @faq Can Haskell produce an infinite list containing EVERY (Vine Int)?
11:38:06 <lambdabot> The answer is: Yes! Haskell can do that.
11:38:11 <ddarius> "Forth" is short for "Fourth"
11:38:17 <pumpkin> come forth
11:38:19 <QuietPurple> So it's certainly possible
11:38:19 <canadaduane> thanks
11:38:44 <Gracenotes> @src fromIntegral
11:38:45 <lambdabot> fromIntegral = fromInteger . toInteger
11:39:02 <pumpkin> Integer is such a ho
11:39:18 <Gracenotes> , src ''Integer
11:39:21 <lunabot>  data Integer = S# Int# | J# Int# ByteArray#
11:40:44 <ddarius> Five character file name limitations have had a significant impact on programming language naming.
11:41:32 <edwardk> ddarius: yeah
11:41:49 <edwardk> FORTH, the !@#(*) BLAS names, etc.
11:43:02 <FliPPeh> ?faq All your Base?
11:43:03 <lambdabot> The answer is: Yes! Haskell can do that.
11:43:44 <pumpkin> Data.Data is ugly
11:44:04 <ddarius> @hoogle Data
11:44:04 <lambdabot> Data.Generics.Basics class Typeable a => Data a
11:44:04 <lambdabot> keyword data
11:44:04 <lambdabot> package data-accessor
11:45:44 <QuietPurple> Actually, in the challenge I mean all Vine Int that contian only positive integers and 0!
11:45:48 * edwardk always thought Data.Data should have just had the balls to call itself Data.hs ;)
11:45:48 <Gracenotes> > cycle "Data."
11:45:49 <lambdabot>   "Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data...
11:45:55 <BMeph> ddarius: Don't you mean "FORTH"? :)
11:45:57 <b_jonas> is it worse than Map.Map?
11:46:15 <edwardk> yeah because its Data.Data.Data that you want to derive
11:46:29 <olsner> yeah, Data.Data is just the module name, Data.Data.Data is the type :)
11:46:33 <b_jonas> makes sense
11:47:11 <edwardk> for some reaosn while pattering that out i feel an unrelenting urge to go Data.Data.Data Mushroom! Mushroom!
11:47:14 <glguy> Is there a Mushrooms.Mushrooms module??
11:47:17 <zachk> hey i found a bug in ghc, what should i do? it relates to me doing +RTS kAgig
11:47:32 <edwardk> hah i'm not alone in that apparently
11:47:46 <glguy> edwardk, heh, I didn't see your comment
11:47:50 <glguy> until after :)
11:47:57 <b_jonas> zachk: there's a trac bug report database somewhere
11:48:02 <edwardk> glguy: yeah but you'll have to install 'snake'
11:48:03 <pumpkin> Data.Data.C ;)
11:48:06 <ddarius> @bug
11:48:06 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:48:09 <b_jonas> http://hackage.haskell.org/trac/ghc/wiki/ReportABug
11:48:11 <glguy> python! its a python!
11:48:12 * BMeph says, "Mmmm...shrooms..."
11:48:14 <glguy> oh, its a python
11:48:16 <b_jonas> ^ zachk
11:50:54 <pumpkin> edwardk: what are you using to generate your instances for your adaptive containers?
11:51:06 <pumpkin> I wanted to use TH to generate mine, but it doesn't support associated types
11:51:10 <edwardk> pumpkin: there is a little perl script in the directory
11:51:16 <pumpkin> ah :/
11:51:32 <edwardk> http://comonad.com/haskell/unboxed-containers/instances.pl
11:51:48 <edwardk> dons used haskell for his because he is spiffier than i am
11:51:58 <pumpkin> yeah :)
11:52:07 <pumpkin> I was hoping for inline generation
11:52:14 <pumpkin> so I don't have to generate the file in a separte step
11:52:14 <edwardk> yeah me too
11:52:16 <olsner> TH would be readable :P
11:52:22 <pumpkin> it would
11:52:30 <wli> data Data a = Data { data :: [Data a] } deriving Data?
11:52:31 <pumpkin> except it doesn't like associated types
11:52:33 <olsner> although, in perl, you can always just golf it
11:52:52 <edwardk> because of the instance explosion i'm replacing the approach i'm using now
11:53:06 <pumpkin> ah
11:53:09 <edwardk> data Data a = Data { data :: [Data a] } deriving Data.Data.Data
11:53:31 <edwardk> you need to import qualified Data otherwise you'll conflict with it when you name the Data's data type
11:53:34 <pumpkin> I don't care much for uvector, as there are only a dozen or so instances needed
11:54:13 <McManiaC> hey, is there a way to install _ALL_ standard libs on debian? i keep getting msgs like "couldnt find System.FilePath" etc which is annoying >.>
11:54:49 <edwardk> pumpkin: yeah i currently have a similar dozen or so that i'm trying to use that know how to pack primitives, and a bunch of combinators for dealing with various sized tuples, and then a bunch of instances for dealing with prepacked data with a given number of slots
11:54:54 <Gracenotes> if you're using Synaptic, searching for ghc6
11:55:09 <Gracenotes> or more specifically libghc6
11:55:10 <olsner> edwardk: ooh, that's a lot of data you have there
11:55:25 <edwardk> with that about 300 instances should be able to handle all practical boxing needs involving up to about 5 values and beyond that i can start to box
11:55:27 <Gracenotes> although that does bind you to 6.8 much
11:55:48 <sjanssen> McManiaC: you could install every package that starts with libghc6
11:56:33 <pumpkin> edwardk: do I need to run the .pl by hand? I see you have a #include for the generated file but can't see who actually calls the generator
11:56:36 <edwardk> pumpkin: as a side effect it'll let me pack things that are isomorphic to small clusters of possibly packed values as well as just the primitives
11:57:16 <edwardk> pumpkin: yeah you do, there is a make file that i use locally to build it, but it kind of craps all over the directory and is just used to run quick tests by me
11:57:25 <pumpkin> ah
11:57:39 <edwardk> and i didn't want the cabal file to have a dependency on it
11:57:55 <edwardk> so i just listed it as an additional data file and baked it into the distro
11:59:23 <pumpkin> can I bake something like http://code.haskell.org/~dons/code/adaptive-containers/scripts/derive-list.hs into a TH splice?
11:59:44 <edwardk> the TH splice can't say anything about type or data families though
12:00:01 <pumpkin> oh I see, he's using text
12:00:19 <pumpkin> text "data" ,      text "List"
12:02:03 <edwardk> i think i can make my "Packable" newtype derivable. at least if you just want to Box your type
12:02:13 <edwardk> or if yours is a newtype of a packed type
12:02:35 <pumpkin> how do you make a type derivable?
12:02:46 <pumpkin> you mean in the Data.Derive sense?
12:03:20 <edwardk> er not my packable newtype, my Packable class, enabling newtype deriving ;)
12:03:53 <lpsmith> http://hackage.haskell.org/trac/ghc/ticket/3151
12:04:02 <lpsmith> Due to this bug,  I'm compiling my own GHC
12:04:09 <lpsmith> And I just had a quick question
12:04:19 <edwardk> so you can just say "instance Packable MyDataType" and it'll automatically throw it in a box. or if you are a newtype of a Packable type you can deriving (Packable) and pack like that type does
12:05:12 <lpsmith> When you generate documentation,  how do you get the links to colorized source?   (As this has disappeared from recent GHC distros)
12:05:25 <edwardk> cabal haddock --hyperlink-source
12:05:30 <lpsmith> thanks!
12:06:18 <igel> what makes Control.Monad.Trans.State.Strict strict?
12:06:31 <pumpkin> seqs?
12:06:47 <pumpkin> or bangs
12:06:51 <igel> there is no seq in the entire file
12:07:01 <edwardk> the patterns matching the tuples aren't ~'d
12:07:14 <edwardk> in the lazy one you see lazy patterns all over the place
12:07:29 <igel> so ~(x, y) will evaluate x and y?
12:07:39 <edwardk> no quite the opposite
12:07:40 <igel> i haven't seen that before
12:07:41 <pumpkin> it won't evaluate the pair until x or y is needed
12:07:59 <edwardk> ~(x,y) won't force the check that you really have a (,) constructor until it needs x or y
12:08:09 <pumpkin> > let f (x, y) = 5 in f undefined
12:08:11 <lambdabot>   * Exception: Prelude.undefined
12:08:12 <pumpkin> > let f ~(x, y) = 5 in f undefined
12:08:14 <lambdabot>   5
12:08:25 <pumpkin> > let f ~(x, y) = x in f undefined
12:08:27 <lambdabot>   * Exception: Prelude.undefined
12:08:44 <dolio> > let f ~(x:xs, y:ys) = x in f ([1],[])
12:08:45 <lambdabot>   * Exception: /tmp/5196394509889940750:71:40-58: Irrefutable pattern failed ...
12:09:01 <EvilTerran> uh?
12:09:02 <lpsmith> > let (x, y) = undefined in 5
12:09:03 <lambdabot>   5
12:09:11 <lpsmith> > let (x, y) = undefined in x
12:09:12 <lambdabot>   * Exception: Prelude.undefined
12:09:13 <blip> which ghc is in apt-get for ubuntu?
12:09:21 <EvilTerran> > let f ~(x:xs, ~(y:ys)) = x in f ([1],[])
12:09:22 <lambdabot>   1
12:09:34 <edwardk> blip: 6.8.2 or something old like that
12:10:22 * edwardk finally has a good sound reason for unsafeCoerce today
12:10:29 <pumpkin> onoes
12:10:30 <lpsmith> 6.8.2 has a nasty scoping error with ghci,  IIRC
12:10:32 <EvilTerran> edwardk, ... really?
12:10:45 <pumpkin> I've only used it a couple of times
12:10:49 <lpsmith> I definitely suggest upgrading to 6.8.3
12:11:02 <edwardk> yeah i have some magic packing stuff that i can prove correct but not sneak past the typechecker ;)
12:11:20 <pumpkin> magic packing! I won't ask
12:11:23 <b_jonas> edwardk: I just had that feeling recently: I found what I think is a valid use for then instance_eval method in ruby
12:11:31 <pumpkin> mine was just to get a reasonable Binary instance for Float and Double :P
12:11:45 <lpsmith> edwardk:  I'm somewhat curious?
12:11:48 <edwardk> pumpkin: not really wanting to be portable eh?
12:12:16 <b_jonas> pumpkin: I thought you could use the Storable instance for that
12:12:24 <igel> are there resources on bang patterns?
12:12:31 <pumpkin> edwardk: I figure most machines I care about have IEEE floats
12:12:38 <pumpkin> b_jonas: I guess I could've :)
12:12:42 <igel> i don't really find anything useful on h.o
12:12:50 <edwardk> lpsmith: i'm trying to work with a bunch of container types that automatically unbox everything they can, but the left over stuff gets dumped in a set of 'boxes' and pulled out by an inverse operation. there is an overall tag to keep you from pulling out something you didn't put in
12:13:06 <edwardk> but the type of the Box slot is not directly connected to that tag
12:13:44 <lpsmith> >  case undefined of { (x,y) -> 5 }
12:13:45 <lambdabot>   * Exception: Prelude.undefined
12:13:51 <lpsmith> >  case undefined of { ~(x,y) -> 5 }
12:13:52 <lambdabot>   5
12:14:12 <edwardk> so you get something like newtype Box a = Box a; data Any; and you can box vales up by putting them into a Box Any, and there is an unsafeUnbox that takes a Box Any and turns it into an a, which is used internally.
12:14:29 <edwardk> it may just wind up simplifying to data Box
12:14:35 <sjanssen> igel: http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html isn't sufficient?
12:14:37 <igel> so ~ makes the lazy state more lazy by not evaluating the tuple constructors?
12:14:42 <pumpkin> step 1: cut a hole in the box
12:14:46 <lpsmith> hmm
12:14:49 <edwardk> data Box; box :: a -> Box; unsafeUnbox :: Box -> a
12:14:55 <blip> what is the point of id?
12:14:56 <edwardk> igel: yeah
12:15:06 <edwardk> @type id
12:15:07 <lambdabot> forall a. a -> a
12:15:10 <edwardk> @type curry
12:15:11 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
12:15:13 <edwardk> @type curry id
12:15:14 <igel> sjanssen: that looks good, but i didn't find it by searching for "bang patterns"
12:15:14 <lambdabot> forall a b. a -> b -> (a, b)
12:15:23 <blip> yes but whats the point?
12:15:25 <ddarius> I use id all the time
12:15:37 <EvilTerran> blip, to pass to other functions that take functions as parameters, say
12:15:49 <sjanssen> @google bang patterns
12:15:50 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
12:15:50 <lambdabot> Title: 8.11.�Bang patterns
12:15:59 <sjanssen> igel: there isn't much on the wiki, though
12:15:59 <edwardk> blip: when you want to not do something you have to pass in a method that just leaves its input alone
12:16:01 <adamvo> @pl curry id
12:16:01 <lambdabot> curry id
12:16:16 <adamvo> aww
12:16:17 <blip> but why then pass anything at all?
12:16:19 <b_jonas> igel: it's not just tuple constructors, it's any constructor of whatever type you use it on
12:16:23 <edwardk> adamvo: hrmm that should be (,)
12:16:37 <adamvo> edwardk: that's what I was expecting
12:16:47 <ddarius> One thing Haskell emphasizes well (though is not unique to Haskell) is that you always want units and zeroes of operations, you always want to push to the extremes.
12:16:51 <edwardk> blip: lets say you have a method that does something complicated, calls a user supplied method, and then does something omplicicated.
12:16:59 <EvilTerran> foldr (.) id [f,g,h] x :: Expr > -- blip, consider this sort of thing
12:17:03 <edwardk> if you don't want to do anything in the middle you just pass by saying id
12:17:06 <igel> b_jonas: and what happens if i have more than one sort of constructor? does the first match always succeed, no matter what?
12:17:08 <EvilTerran> > foldr (.) id [f,g,h] x :: Expr -- *ahem*
12:17:09 <lambdabot>   f (g (h x))
12:17:16 <b_jonas> igel: yes, that's the whole point
12:17:22 <b_jonas> igel: a ~ pattern always matches anything
12:17:34 <b_jonas> igel: just like a pattern that's a single variable
12:17:40 <edwardk> igel: the match will succeed, but later fail when you go to use it
12:17:46 <edwardk> thats why they are called irrefutable
12:18:05 <igel> why on earth do you need this?
12:18:10 <b_jonas> igel: the let statement has this kind of behaiviour built in
12:18:23 <b_jonas> igel: so that you don't evaluate the value earlier than it's needed
12:18:29 <travisbrady> what is meant by "applicative" in the context of applicative functors?  or if one were to say "some piece of code is written in an applicative style?"
12:18:35 <EvilTerran> igel, it lets you write code that's as non-strict as possible
12:19:19 <igel> but if there's only one constructor (like in (,)), why does the compiler reduce it to whnf?
12:19:32 <b_jonas> travisbrady: well, it's the kind of pointfree style where you use the methods of the Applicative class
12:19:38 <igel> i mean why do i have to prevent this by hand?
12:19:43 <EvilTerran> consistency
12:20:22 <sjanssen> igel: not reducing it can lead to a space leak
12:20:33 <pumpkin> travisbrady: feels more declarative than the monadic style, no explicit sequencing
12:20:41 <dolio> > let tail = snd $ foldr (\e (xs,_) -> (e:xs,xs)) ([], undefined) in tail [1..]
12:20:42 <lambdabot>   Couldn't match expected type `(a, b)'
12:20:49 <dolio> > let tail = snd . foldr (\e (xs,_) -> (e:xs,xs)) ([], undefined) in tail [1..]
12:20:51 <lambdabot>   * Exception: stack overflow
12:20:55 <dolio> > let tail = snd . foldr (\e ~(xs,_) -> (e:xs,xs)) ([], undefined) in tail [1..]
12:20:57 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
12:21:36 <sjanssen> travisbrady: "applicative style" means written as function application
12:23:01 <sjanssen> "do x <- m; y <- n; return (f x y)" is monadic style, "f <$> m <*> n" is applicative style
12:24:14 <Duqicnk> @type (<$>)
12:24:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:24:21 <travisbrady> pumpkin, sjanssen: ah, thank you
12:24:36 <Duqicnk> @type (<*>)
12:24:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:24:46 <Duqicnk> @info Applicative
12:24:46 <lambdabot> Applicative
12:24:49 <travisbrady> one thing i didn't get in Paterson and McBride's paper is the transpose example, how is it that that's effectful?  because it's on lists?
12:25:41 <Duqicnk> @type \f m n -> f <$> m <*> n
12:25:43 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
12:26:19 <Duqicnk> is there a good tutorial/guide to programming with Applicative?
12:26:48 <pumpkin> the original paper is pretty clear
12:27:01 <pumpkin> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
12:27:09 <bavardage> can I curry with more than two arguments?
12:27:18 <pumpkin> :t uncurry3
12:27:19 <lambdabot> Not in scope: `uncurry3'
12:27:30 <pumpkin> :t curry3
12:27:32 <lambdabot> Not in scope: `curry3'
12:27:34 <pumpkin> you could certainly write something that did it
12:27:39 <bavardage> right kk
12:27:42 <gwern> @hoogle curry
12:27:42 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
12:27:43 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
12:27:43 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
12:27:45 <bavardage> I'll do that
12:27:48 <gwern> @hoogle uncurry
12:27:48 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
12:27:48 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
12:28:00 <gwern> oh well
12:29:48 <lpsmith> hmm... can you store a definition in lambdabot for later use,  at least for a little while?
12:29:55 <pumpkin> using @let
12:29:57 <codebliss> let?
12:30:01 <travisbrady> pumpkin: what is it that is effectful about a transpose function?
12:30:14 <lpsmith> > let curry3 f a b c = f (a,b,c)
12:30:15 <lambdabot>   <no location info>: parse error on input `;'
12:30:44 <gwern> @let curry3 f a b c = f (a,b,c)
12:30:45 <lambdabot>  Defined.
12:30:49 <lpsmith> ahh
12:30:50 <codebliss> Odd.
12:30:52 <gwern> > curry3 id 1 2 3 4
12:30:53 <lambdabot>   Couldn't match expected type `t1 -> t'
12:31:01 <gwern> > curry3 id 1 2 3
12:31:02 <lambdabot>   (1,2,3)
12:31:29 <lpsmith> :t curry3
12:31:30 <lambdabot> forall t t1 t2 t3. ((t, t1, t2) -> t3) -> t -> t1 -> t2 -> t3
12:31:32 <codebliss> > curry3 (*2) 1 2 3
12:31:33 <lambdabot>       No instance for (Num (t, t1, t2))
12:31:33 <lambdabot>        arising from the literal `2' a...
12:31:39 <codebliss> Oh, ya
12:33:47 <jmcarthur> :t (+).(+)
12:33:49 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
12:33:56 <pumpkin> travisbrady: nothing too effectful about it, I think he's just illustrating a more general way of writing it
12:34:46 <codebliss> I was thinking the other way around, brainfart
12:35:04 <codebliss> @let g (a, b, c) = a + b * c
12:35:05 <lambdabot>  Defined.
12:35:12 <codebliss> > curry3 g 1 3 5
12:35:13 <lambdabot>       Ambiguous occurrence `g'
12:35:13 <lambdabot>      It could refer to either `L.g', defined a...
12:36:00 <codebliss> @let g' (a, b, c) = a + b * c
12:36:01 <lambdabot>  Defined.
12:36:12 <codebliss> > curry3 g' 1 3 5
12:36:13 <lambdabot>   16
12:36:16 <codebliss> There we go
12:37:23 <edwardk> bah, no need to write it
12:37:25 <edwardk> @djinn ((t, t1, t2) -> t3) -> t -> t1 -> t2 -> t3
12:37:25 <lambdabot> f a b c d = a (b, c, d)
12:37:29 <edwardk> =)
12:38:03 <zachk> is there any advantages to applicative style?
12:38:31 <edwardk> zachk: yes, applicatives have fewer requirements than monads, so there are more of them
12:38:33 <Duqicnk> it's both more concise and more general than monadic style
12:38:38 <b_jonas> zachk: if you use it in apl2 or J, then it can often be more concise than pointful style
12:38:47 <b_jonas> zachk: not always, so you have to switch between the two
12:38:52 <Duqicnk> the downside (as i understand it) is that you've made a left-to-right effect-ful eval order more implicit
12:39:07 <b_jonas> zachk: that's probably not true in haskell, there pointful is almost always shorter than pointfree
12:39:22 <b_jonas> Duqicnk: have you now?
12:39:30 <b_jonas> I thought if it's the Identity monad then you haven't
12:39:38 <Duqicnk> well, because the effects are trivial
12:40:00 <edwardk> also nothing says that the applicative has to have left to right effects ;)
12:40:13 <Duqicnk> right but the standard instance (Monad f) => Applicative f does
12:40:19 <Duqicnk> given the paper i'm reading now
12:40:48 <zachk> are all the monads a "subset" of Applicative? (I know im not using terms correctly here)
12:40:54 <edwardk> Duqicnk: most monads do, and if you have a monad from your type your applicative isntance should agree with it, but there are applicatives that aren't monads
12:41:06 <ddarius> edwardk: The order is determined based on the combinators you use.
12:41:07 <Duqicnk> yeah i'm aware
12:41:13 <Duqicnk> zachk: any monad is an applicative, not the other way
12:41:23 <Duqicnk> (how do i make lambdabot show an instance?)
12:41:31 <edwardk> zachk: applicative is a (spiritual) superclass of monad in haskell, so every monad can be made applicative (at least in haskell)
12:42:07 <edwardk> there exist categories for which you have monads, but not the actions required to define <*> though, trivially, any category that lacks exponentials (functions)
12:42:22 <zachk> and just when I thought I was beginning to get a grasp on monads there is something better >:E
12:42:39 <ddarius> Applicative functors aren't "better" or "worse"
12:42:48 <Duqicnk> @type fmap
12:42:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:43:02 <b_jonas> @src Maybe (<*>)
12:43:02 * edwardk is particularly fond of applicative functors and monoids as alternative useful abstractions.
12:43:02 <lambdabot> (<*>) = ap
12:43:05 <b_jonas> -> Duqicnk
12:43:11 <Duqicnk> aha
12:43:15 <edwardk> or even applicative functors applide to monoids.
12:43:19 <edwardk> er applied
12:43:27 <pumpkin> applicative monctors!
12:43:39 <osfameron> fumplicative!
12:44:11 <b_jonas> complicative
12:44:22 <Duqicnk> @src (<$>)
12:44:22 <lambdabot> f <$> a = fmap f a
12:44:31 <McManiaC> cool! my happs-server is running :D
12:44:43 * edwardk seriously considered trying to release a new version of category-extras during april fools where i just randomly munged together the names of things. if i started with the combinators in Control.Morphism, i doubt anyone would have noticed
12:44:55 <pumpkin> :)
12:45:09 <Duqicnk> so Applicatives are Functors in the sense that <$> is fmap and is a specialization of (<*>) ?
12:45:11 <Duqicnk> @type (<*>)
12:45:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:45:38 <edwardk> applicatives are functors that support pure and (<*>).
12:46:03 <b_jonas> edwardk: with zygohistomorphic prepromorphisms?
12:46:08 <Duqicnk> but if you support pure and (<*>) then you can already define fmap
12:46:16 <edwardk> you have a way to put 'pure' values (and functions) into the type, and then apply them somehow
12:46:46 <edwardk> @src liftA
12:46:46 <lambdabot> liftA f a = pure f <*> a
12:46:51 <Duqicnk> and, intuitively, what additional does a monad have that Applicative doesn't?
12:47:02 <edwardk> Duqicnk: hence why every applicative is a functor
12:47:09 <edwardk> Duqicnk: (>>=)
12:47:23 <Duqicnk> but, what can you do with (>>=) that you can't do with (<*>)?
12:47:26 <b_jonas> Duqicnk: some say it's lift, but I don't really understand what lift really is
12:47:47 <edwardk> Duqicnk: you can make decisions about 'what to do next' based on what you've done so far.
12:48:21 <mauke> Duqicnk: concat
12:48:36 <edwardk> Duqicnk: its kind of like the difference between a context-free and a context-sensitive grammar. monads are like context-sensitive applicatives.
12:48:45 <Duqicnk> hmm okay
12:48:57 <edwardk> @type concatMap
12:48:58 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
12:49:03 <mauke> > ["foo", "bar", "baz"] >>= id
12:49:04 <lambdabot>   "foobarbaz"
12:49:16 <edwardk> concatMap is (=<<) for []
12:49:26 <edwardk> you can't define it from pure and <*>
12:49:48 <edwardk> @src [] (>>=)
12:49:48 <lambdabot> xs >>= f     = concatMap f xs
12:50:26 <solistic> Hello folks, I want to combine two functions (a -> b -> IO c) and (IO a)
12:50:34 <solistic> obviously i could say:
12:50:35 <solistic> applyM :: (Monad m) => (a -> b -> m c) -> m a -> b -> m c
12:50:35 <solistic> applyM f v y = do x <- v f x y
12:50:48 <solistic> but is there a more elegant way to do this?
12:51:35 <codebliss> Why isn't __ main = readLn >>= print __ working in ghci (from importing from a file)?  The type sig's match, and it's from a monad tut.  Makes sense to me.
12:51:42 <b_jonas> applyM: where's the inner x defined? or is it supposed to be an mdo?
12:51:58 <solistic> oh, that got screwed
12:52:03 <Duqicnk> @pl \f ma b -> do { a <- ma; f a b }
12:52:03 <lambdabot> (line 1, column 15):
12:52:03 <lambdabot> unexpected "{"
12:52:03 <lambdabot> expecting variable, "(", operator or end of input
12:52:04 <solistic> the body is like
12:52:12 <solistic>     x <- v
12:52:18 <solistic>     f x y
12:52:42 <codebliss> @let foo' = readLn >>= print
12:52:43 <lambdabot>  Add a type signature
12:52:45 <b_jonas> codebliss: that's a definition, either type the IO action to ghci like "readLn >>= print" or make a definition like "let main = ..." and then run it next line with "main"
12:52:46 <edwardk> @. pl undo \f b a = do a' <- a; f b a
12:52:46 <lambdabot> Parse error at "=" (column 8)
12:52:58 <edwardk> @. pl undo \f b a -> do a' <- a; f b a
12:52:58 <lambdabot> ((ap (>>=) . (const .)) .)
12:53:09 <edwardk> there ya go, nice and legible. *cough*
12:53:29 <wli> @@ @pl @undo let applyM f v y = do x <- v f x y in applyM
12:53:30 <lambdabot>  Parse error at "in" (column 36)
12:53:30 <tromp_> codebliss:  you need to annotate it with a type
12:53:42 <tromp_> else it's ambiguous
12:53:43 <Duqicnk> @type liftM2
12:53:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:53:51 <b_jonas> solistic: oh, applyM f v y = do { x <- v; f x y }
12:53:52 <b_jonas> I see
12:54:04 <edwardk> liftM2 f a . return
12:54:07 <Duqicnk> @type \f ma b -> liftM2 f ma $ return b
12:54:08 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> a2 -> m r
12:54:08 <solistic> b_jonas, yep
12:54:13 <codebliss> foo.hs = __main = readLn >>= print__,   ghci foo.hs
12:54:18 <b_jonas> can that be done with applicable and some pure function?
12:54:23 <Duqicnk> @pl \f ma b -> liftM2 f ma $ return b
12:54:23 <lambdabot> flip flip return . ((.) .) . liftM2
12:54:23 <b_jonas> I'm not sure really
12:54:33 <Duqicnk> i like the looks of this . ((.).).
12:54:35 <codebliss> tromp_: So () -> IO ()?
12:54:44 <tromp_> e.g. main = (readLn :: IO Int) >>= print
12:54:50 <edwardk> @pl \ma -> liftM2 f ma . return
12:54:50 <lambdabot> (. return) . liftM2 f
12:54:59 <b_jonas> tromp_: why's it ambiguous?
12:55:02 <b_jonas> @type readLn
12:55:03 <lambdabot> forall a. (Read a) => IO a
12:55:11 <b_jonas> hmm, I see
12:55:16 <edwardk> @type fmap return . liftM2 f
12:55:17 <tromp_> it has no idea what IO a you want
12:55:17 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, SimpleReflect.FromExpr r, Show a2, Show a1, Monad m) => m1 a1 -> m1 a2 -> m (m1 r)
12:55:25 <codebliss> tromp_: Ah, thanks!
12:55:26 <edwardk> hah
12:55:30 <b_jonas> that's not so that's like print
12:55:38 <edwardk> @type \f -> fmap return . liftM2
12:55:39 <lambdabot> forall t (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => t -> (a1 -> a2 -> r) -> m1 a1 -> m (m1 a2 -> m1 r)
12:55:39 <codebliss> tromp_: Is there a readStr or equiv?
12:55:42 <wli> Composing @undo and @pl by hand gives flip ((.) . (>>=)) . flip
12:55:47 <codebliss> @hoogle read
12:55:47 <lambdabot> Prelude read :: Read a => String -> a
12:55:47 <lambdabot> Text.Read read :: Read a => String -> a
12:55:47 <lambdabot> module Text.Read
12:55:53 <harovali> isn't there a module or function that given a function tells which module(s) contain it ?
12:55:58 <codebliss> Dang, it doesn't work that way
12:56:00 <edwardk> there, thats probably the least ugly
12:56:14 <b_jonas> codebliss: try getLine
12:56:23 <b_jonas> codebliss: and putStrLn for the output
12:56:31 <tromp_> :t getLine
12:56:32 <lambdabot> IO String
12:56:39 <codebliss> b_jonas: That's what I was thinking of, thanks =)
12:56:48 <edwardk> liftMleft f = fmap return . liftM2 f
12:57:01 <harovali> something like hoogle but from the command line
12:57:11 <codebliss> Awesome.  Works.
12:57:15 <edwardk> its still slightly pointful and the fmap and liftM2 use different monads, but who's keeping track? =)
12:57:35 <codebliss> Look at lambdabot source code?  It's not too long.
12:57:38 <wli> @pl \f -> (. return) . liftM2 f
12:57:38 <lambdabot> ((. return) .) . liftM2
12:57:41 <edwardk> hah for even more confusion: liftMleft f = liftM return . liftM2 f
12:57:44 <codebliss> You could make a *nix console command to do it.
12:58:48 <edwardk> hrmm
12:59:01 <b_jonas> codebliss: well, there's a console version of hoogle
12:59:06 <edwardk> @type \f -> liftM return `liftM` liftM2 f
12:59:08 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> a2 -> r) -> m1 a1 -> m1 a2 -> m (m1 r)
12:59:13 <Duqicnk> b_jonas: what about a ghci plugin?
12:59:14 <edwardk> hah
12:59:18 <codebliss> Would it be considered bad practice to put definitions for some functions you use but do not define in the top?  As long as it's not production code?
12:59:35 <wli> :t readLn
12:59:36 <lambdabot> forall a. (Read a) => IO a
13:00:03 <EvilTerran> codebliss, the definitions of functions you don't define?
13:00:03 <b_jonas> Duqicnk: ghci has a :! command to run shell commands
13:00:07 <codebliss> It just helps for putting together pieces of the puzzle, as long as it goes away by release
13:00:15 <monochrom> Even in production code you wonder why people insist definitions near top.
13:00:48 <wli> @type {- in a pinch this is good too -} mapM readIO =<< System.Environment.getArgs
13:00:49 <lambdabot> forall a. (Read a) => IO [a]
13:01:11 <codebliss> EvilTerran:  Functions in the libraries that already exist.  Just so you can make sure you match everything up right.  I'm kind of new and don't have all of them stuck to my head =P
13:01:35 <monochrom> There are two kinds of people, and there used to be one kind of compilers. The bottom-up people and the old compilers want to see the building blocks before the building. The top-down people want to see the building before the building blocks.
13:01:52 <codebliss> monochrom: Brian?
13:02:02 <monochrom> I don't know Brian.
13:02:04 <codebliss> monochrom: Channel 9?  Didn't he quote that?
13:02:24 <monochrom> Perhaps he quoted it from me. I said something like that many years ago already.
13:02:40 <codebliss> Ah.  Not a literal copy from what you said but similar
13:02:56 * edwardk is a bottom-up person. one of these days i'll play with more than two grains of sand in my sandbox at the same time.
13:03:29 <b_jonas> luckily haskell isn't like that
13:03:33 <BMeph> solistic: I.e. You want ioa >>= flip f b :)
13:03:37 <mattam> edwardk: Make big grains of sand :)
13:03:41 <b_jonas> it only needs pragmas and imports at the top
13:03:42 <Duqicnk> okay, so "Applicative is closed under composition" means we don't need special "applicative transformers" in the same sense as monad transformers, right?
13:03:47 <b_jonas> all the rest of definitions you're free to mix
13:03:54 <codebliss> monochrom: IIRC Brian Beckman's awesome vid that got me to mostly understand monads, http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/ , he says something similar around midway or early
13:04:00 <Duqicnk> or are these sort of unrelated ideas
13:04:01 <edwardk> mattam: i do reasonably well when it rains ;)
13:04:12 <ddarius> That video is fucking horrible.
13:04:22 <codebliss> ddarius: Um, thanks?
13:04:33 <Gracenotes> he says that monads are monoid-y
13:04:46 <Gracenotes> ..and that's basically the video (?)
13:05:07 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/808d871189337e77  last paragraph
13:05:31 <codebliss> http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/ <- got me to fully understand monads with his state examples and how C's are a monad 24/7
13:06:19 <codebliss> Well that video was the first I ever watched on monads.  I've added maaany other media on top so I must have forgotten if it was mostly fluff.  All I remember is it made sense and helped me understand the more detailed examples.
13:07:09 <Gracenotes> for me the videos helped a few things click. The diagrams in the State one was helpful.
13:07:28 <codebliss> Ah.  I loved that two-part series.
13:08:13 <codebliss> http://channel9.msdn.com/shows/Going+Deep/Erik-Meijer-and-Matthew-Podwysocki-Perspectives-on-Functional-Programming/ <- one of my fav.
13:08:27 <Gracenotes> I'm not sure they're too comprehensive though. He sees monads as a good thing from a software engineering perspective, seemingly eschewing the category theoretical viewpoint.
13:08:28 <codebliss> Probably the most insightful one I took the best.
13:08:41 <codebliss> Ya he was very simple, and repeated himself a lot..
13:08:45 <Gracenotes> which some #haskellians might not like
13:08:50 <codebliss> lol
13:09:09 <b_jonas> heh
13:09:20 <Duqicnk> how dare they claim something i like is practical
13:09:30 <BMeph> solistic: Did that help? :)
13:10:02 <edwardk> gracenotes: i started there, somewhere along the way i tripped (mentally? physically? psychedelically?) and started enjoying the category theoretic aspects of them
13:10:04 <Gracenotes> well, it's not so much practical as imperative programmers taking what they like from functional languages, ignoring the big picture
13:10:19 <Gracenotes> big functional picture. if there is one.
13:10:29 <edwardk> monads are category theory's gateway drug
13:10:30 <Gracenotes> not too surprising, since it's been going on for decades, apparently :)
13:10:32 <monochrom> Theorem: The tutorial that makes you "click" is the third tutorial. Corollary: If an author wants you to remember him as the author that makes you "click", it suffices for him to force-repeat his tutorial three times.
13:11:10 <bavardage> monochrom: counterexample: me
13:11:18 * bavardage has read more than 3 monad tutorials
13:11:21 * bavardage hasn't clicked yet
13:11:33 <monochrom> Poor you.
13:11:34 <b_jonas> I don't like tutorials
13:11:51 <bavardage> I get them enough to be able to code monadicaly
13:11:54 <bavardage> *monadically
13:11:59 <bavardage> but they haven't 'clicked' yet
13:12:05 <MyCatVerbs> monochrom: alternatively, market like Hell so that yours is the first tutorial that most people attempt to read - but booby-trap your tutorial so that people attempting to read it will be ambushed by two other authors' tutorials, first.
13:12:07 <halberd> better to read three different books than one book 3 times
13:12:08 <Cale> bavardage: Have you read my Monads as Computation?
13:12:09 * bavardage is coding cairo and gtk and stuff
13:12:09 <monochrom> I don't like videos. They are not browsible or self-paced.
13:12:14 <bavardage> Cale: quite likely
13:12:16 <bavardage> Cale: linky
13:12:25 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation
13:12:28 <Gracenotes> monochrom: well... *wields mouse wheel*
13:12:40 <codebliss> I like videos because they're people talking.  I'm better with that than text.
13:12:54 <b_jonas> I don't like videos either
13:12:56 <monochrom> speech synthesizer
13:13:04 <Gracenotes> they suck :(
13:13:07 <codebliss> If I see text on something I DON'T understand, then I go crazy.
13:13:08 <Cale> bavardage: It includes a touch of philosophical argument about why we might be interested in them.
13:13:14 <Gracenotes> monad tutorials tend to have exercises like "make a maybe state transformer using the power of pure will" instead of presenting small, practical tasks to do with monad instances
13:13:21 * bavardage is reading tutorial
13:13:23 <codebliss> I only like videos for things I have no idea about =P
13:13:32 <Gracenotes> at least that I've seen
13:13:38 <BONUS_> i like videos if they have SPJ in them
13:13:44 <Gracenotes> hah, yes
13:13:47 <Cale> BONUS_: Me too!
13:14:00 <Cale> We need to get SPJ on camera more often.
13:14:25 <BONUS_> yeah
13:14:28 <codebliss> Well the thing that made it click is how an imperative languages are 24/7 monads.  That really got me to understand.  First I had to get that since the state is different every time, the function call really does give the same output to the same input.
13:14:40 <b_jonas> actually making the ContT transformer is a nice exercise
13:14:42 <codebliss> Then after I got that, the C++ example completed it.  Click.
13:14:58 <monochrom> Gracenotes: I am aware of the slider UI for videos. It is inadequate because unlike books and web pages, there is no fine-grained index or hyperlinks pointing to "here the axioms are shown", "here the 4th example is shown", etc.
13:14:59 <codebliss> Who's spj?
13:15:12 * bavardage understands a little bit more now
13:15:16 <Gracenotes> monochrom: yes, true. I've developed a sort of eye for it though
13:15:23 <BONUS> simon peyton jones. his talks and lectures are really fun to watch because he's really into it
13:15:25 <Gracenotes> so long as I've watched the video before
13:16:02 <Gracenotes> codebliss: http://www.haskell.org/haskellwiki/Video_presentations
13:16:17 <Gracenotes> h
13:16:22 <MyCatVerbs> There are no real Haskell fans, they're actually all SPJ groupies instead.
13:16:23 <Gracenotes> e's in a few
13:16:26 <codebliss> Thank you =)
13:16:57 <monochrom> Until videos have hyperlinks like web pages do, videos are unusable. Here is what I want: the guy is saying "a monad is a functor with these extra things", and the screen has those words too, you click on "functor" on the screen, and the video flies back to when he talked about functors.
13:17:20 <codebliss> Youtube could do that soon I would bet.
13:17:33 <codebliss> They got the on screen captions, no time before invis boxes that link to a seg in the video
13:17:35 <EvilTerran> it can already have pop-up bubbles with hyperlinks
13:17:47 <Gracenotes> a monad is a functor with DUDE
13:17:50 <Gracenotes> NO WAY
13:17:54 <codebliss> Ah they hyperlink?  Well then make em invis =P
13:18:00 <EvilTerran> and i think you can link to a specific time in a youtube video, if you know how
13:18:01 <b_jonas> text will be better even after that
13:18:06 <EvilTerran> it would involve a page reload, though =/
13:18:11 <Cale> monochrom: People have been thinking about doing that pretty much since the hyperlink was invented
13:18:20 <Cale> monochrom: I wonder why it hasn't really happened.
13:18:24 <b_jonas> EvilTerran: why? scripts and stuff. it's already using flash.
13:18:27 <Gracenotes> YouTube also has linkable annotations
13:18:56 <FliPPeh> Ambiguous type variable `b' in the constraint:
13:19:00 <FliPPeh> In this line: loop st    = catch (runReaderT run st) (const $ return ())
13:19:02 <FliPPeh> What?
13:19:13 <codebliss> Annotations have backgrounds..
13:19:15 <Cale> FliPPeh: The new exceptions library is a pain like that
13:19:37 <Cale> FliPPeh: You basically have to give your exception handlers explicit type signatures now.
13:20:03 <FliPPeh> I don't know the type :s
13:20:09 <BONUS> FliPPeh: is that from the chat server tutorial thing?
13:20:12 <EvilTerran> b_jonas, i mean, with the interface currently available
13:20:12 <FliPPeh> Yep
13:20:17 <FliPPeh> IRC bot
13:20:30 <vixey> @hoogle const $ return ()
13:20:30 <lambdabot> Did you mean: $ (Const return return) (return ()) /count=20
13:20:30 <lambdabot> No results found
13:20:35 <Gracenotes> jeez, I shouldn't have played with the dog on the floor so long... *sneezes*
13:20:36 <b_jonas> EvilTerran: I see
13:20:54 <FliPPeh> Gracenotes, be glad you can still play with your dog
13:20:58 <FliPPeh> Mine's 13 years old
13:21:09 <Gracenotes> ah. Ours is a puppy.
13:21:11 <FliPPeh> She's about to give up
13:21:21 * Gracenotes is more of a cat person, but can adapt
13:21:45 <halberd> my dog likes to throw tennis balls from his mouth
13:21:47 <BONUS> try this: loop st = (runReaderT run st) `catch` (const $ return () :: SomeException -> IO ())
13:21:55 <halberd> as well as chase and retrieve them
13:22:18 <Gracenotes> yeah
13:22:27 <FliPPeh> Works, thanks BONUS
13:22:31 <Gracenotes> I brought home a frisbee from school, which Molly (name) hopefully picks up
13:22:32 <BONUS> :]
13:22:35 <halberd> he can throw the ones that have been peeled of their fuzzy covering
13:22:45 <BONUS> maybe someone should fix that wiki entry with that code
13:22:53 <Gracenotes> mm. dog tennis balls are sort of X.X
13:22:56 <halberd> so that it is a smooth slippery surface that will slip from his mouth easily
13:23:22 <halberd> he can toss them all the way to the ceiling, or across the room
13:23:36 <beelsebob> http://apina.biz/15251.jpg
13:23:38 <beelsebob> >.>
13:24:00 <EvilTerran> beelsebob, hah
13:24:05 <Gracenotes> ow, my calves
13:25:58 <solistic> BMeph, got it, thx:)
13:27:42 <bindreturn> what is the monad instance here  --> return 1 >>= (\x -> return x)      Is it just running Identity Monad, if there is no list or Maybe constructor ?
13:28:00 <mauke> :t return 1 >>= (\x -> return x)
13:28:01 <lambdabot> forall t (m :: * -> *). (Monad m, Num t) => m t
13:28:13 <mauke> bindreturn: that works in any monad
13:30:12 <bindreturn> I understand if its return 1 >>= (\x -> [x]) where it will infer list Monad,   by i dont see how the typeclass Monad can execute if there is no specific instance ?
13:31:07 <mauke> eh?
13:31:12 <Gracenotes> it can't execute without a specific instance
13:31:44 <bindreturn> but at ghci typing  return 1 >>= (\x -> return x)    produces value 1,  so is the instance Identity Monad ?
13:32:00 <vixey> :t \l ->  return 1 >>= (\x -> return x)
13:32:01 <lambdabot> forall t t1 (m :: * -> *). (Monad m, Num t1) => t -> m t1
13:32:11 <vixey> Any Monad, it will be called m
13:32:17 <EvilTerran> bindreturn, the ghci prompt is the IO monad
13:32:30 <bindreturn> So its just ghci's IO
13:32:38 <bindreturn> REPL
13:32:51 <EvilTerran> things of type IO () get used as-is
13:33:05 <EvilTerran> things of type IO (anything else) get passed to (print =<<)
13:33:15 <EvilTerran> and things of any other type get passed to (print)
13:33:19 <EvilTerran> but otherwise, it's the IO monad
13:33:26 <b_jonas> I need a bit of help
13:33:28 <Gracenotes> try "x <- return 29"
13:33:31 <Gracenotes> in ghci
13:33:56 <b_jonas> I'm not sure how to detect errors in the temp module in this ghci thingy I'm writing
13:34:01 <Gracenotes> it works as you'd expected in a monad
13:34:11 <Gracenotes> -ed
13:34:40 <b_jonas> I would like it to undo adding a declaration if it results in a compile error
13:35:08 <bindreturn> EvilTerran, yes that makes sense, thanks
13:35:36 <bindreturn> monads as interpreters !
13:35:46 <monochrom> haha bindreturn is a fun nick
13:36:23 <monochrom> The next monad newbie will call himself joinfmap :)
13:36:29 <bindreturn> doesnt work very well in #ocaml
13:36:43 <b_jonas> this thingy that is: http://erxz.com/pb/16896
13:37:00 <b_jonas> meanwhile I'll add deleting lines explicitly, but I think this would also be nice
13:37:00 <wli> toxic nuclear waste burrito interpreters?
13:37:30 <b_jonas> if anyone has a good way, please tell me
13:37:41 <b_jonas> also please tell me what its good hierarchical module name should be
13:43:58 <TomMD> @bot
13:43:59 <lambdabot> :)
13:43:59 <lunabot>  :)
13:44:07 <TomMD> @brokenbot
13:44:07 <lambdabot> Unknown command, try @list
13:44:13 <TomMD> yep
13:50:09 <mib_zbavhi> can a in-place quicksort implemented in haskell? if yes, does anyone have a sample?
13:50:32 <Heffalump> sure, just use a mutable array type in ST
13:50:34 <luite> mib_zbavhi: quicksort is not really in place if you count the stack
13:50:48 <b_jonas> mib_zbavhi: yes, with IOArrays or STArrays
13:50:58 <luite> mib_zbavhi: but you can implement it using a mutable array like some ppl said before me :p
13:51:14 <b_jonas> luite: true, though you can do it in twice the place of the original array
13:51:45 <b_jonas> it's not doable inplace like mergesort or heapsort is
13:52:46 <mib_zbavhi> does anyone have an example?
13:53:59 <b_jonas> mib: I think I have an inplace shuffle with ST or something like that somewhere
13:54:06 <luite> mib_zbavhi: uvector-algorithms has some sorting algorithms on arrays, they have an immutable interface, but work on a mutable copy internally
13:55:04 <mib_zbavhi> k
13:55:41 <mib_zbavhi> i understand in-place on paper, just wanted to write it and see how it looks
13:56:06 <b_jonas> yeah, writing ST stuff is confusing at first
13:56:31 <b_jonas> well, still confusing to me
13:56:47 <b_jonas> > replicate 8 " "
13:56:48 <lambdabot>   [" "," "," "," "," "," "," "," "]
13:56:54 <b_jonas> > repeat 8 " "
13:56:54 <lambdabot>   Couldn't match expected type `[Char] -> t'
13:57:04 <b_jonas> > replicate 8 ' '
13:57:05 <lambdabot>   "        "
13:57:52 <b_jonas> what's the best way to format an integer padding it to at least 3 chars with spaces on the left?
13:58:25 <mauke> printf "%3d"
13:58:31 <b_jonas> yeah, but without printf
13:58:37 <b_jonas> or is printf really the best way?
13:58:40 <b_jonas> I hope it's not
13:58:42 <mauke> I'd use printf
13:59:05 <Heffalump> I just write a pad function
14:00:27 <blip> > map flip [(1,2),(3,4)]
14:00:28 <lambdabot>   Couldn't match expected type `a -> b -> c'
14:00:44 <EvilTerran> ?src flip
14:00:44 <lambdabot> flip f x y = f y x
14:00:53 <blip> > map flip [uncurry (-) (1,2),uncurry (-) (3,4)]
14:00:54 <lambdabot>       Overlapping instances for Show (b -> a -> c)
14:00:54 <lambdabot>        arising from a use ...
14:01:02 <blip> > uncurry (-) (1,2)
14:01:03 <lambdabot>   -1
14:01:10 <b_jonas> so there's no bulitin overtake function or something like that?
14:01:14 <EvilTerran> > map (uncurry (flip (,))) [(1,2),(3,4)]
14:01:15 <lambdabot>   [(2,1),(4,3)]
14:01:15 <blip> > uncurry (flip . (-)) (1,2)
14:01:16 <lambdabot>       Overlapping instances for Show ((b -> c) -> c)
14:01:16 <lambdabot>        arising from a us...
14:01:20 <b_jonas> no wait, overtake wouldn't work here anyway
14:01:32 <b_jonas> ok, I'll just write it by hand from length and replicate
14:01:39 <EvilTerran> > [(y,x) | (x,y) <- [(1,2),(3,4)]]
14:01:40 <lambdabot>   [(2,1),(4,3)]
14:01:48 <EvilTerran> &c
14:02:47 <saing> http://crazytuga.mybrute.com  <-- BE A BRUTE AND CHALLENGE ME IN THIS FUNNY GAME :P
14:03:05 --- mode: ChanServ set +o Heffalump
14:03:06 <bremner> NO, PLEASE GO AWAY
14:03:51 <EvilTerran> bremner, it's best to ignore the occasional spammer; the ops're pretty on the ball here
14:05:56 --- mode: Heffalump set -o Heffalump
14:05:56 <wli> EvilTerran: map (uncurry $ flip (,))
14:06:59 <blip> > map (uncurry $ flip (,)) [(1,2),(3,4)]
14:07:00 <lambdabot>   [(2,1),(4,3)]
14:07:10 <blip> > map (flip (,)) [(1,2),(3,4)]
14:07:11 <lambdabot>       Overlapping instances for Show (a -> (a, (t, t1)))
14:07:11 <lambdabot>        arising from ...
14:07:13 <blip> > map (uncurry $ flip (,)) [(1,2),(3,4)]
14:07:15 <lambdabot>   [(2,1),(4,3)]
14:07:42 <EvilTerran> wli, i know, i just sometimes avoid $ when it's not relevant to what i'm demonstrating, to avoid a potential source of confusion
14:07:43 <blip> > map (\(a,b) -> (b,a)) [(1,2),(3,4)]
14:07:44 <lambdabot>   [(2,1),(4,3)]
14:09:03 <blip> let (flippin,dudes) = (uncurry $ flip (,), [(1,2),(3,4)]) in flippin dudes
14:09:08 <blip> > let (flippin,dudes) = (uncurry $ flip (,), [(1,2),(3,4)]) in flippin dudes
14:09:09 <lambdabot>   Couldn't match expected type `(a, b)'
14:10:36 <brad_larsen> data abstraction question:
14:10:50 <b_jonas> yes
14:10:57 <dolio> No.
14:11:16 <brad_larsen> i have an abstract type (i.e. typeclass), for something vaguely like a dictionary
14:11:24 <brad_larsen> i have two implementations of it in separate modules
14:11:28 <b_jonas> moar abstraction is always betterer
14:11:45 <brad_larsen> the abstract type has certain properties that should hold, regardless of implementation
14:11:55 <brad_larsen> so, i wrote quickcheck properties for that
14:12:10 <brad_larsen> e.g.
14:12:40 <brad_larsen> p_size :: (PDict d) => d -> Bool; p_size d = size d == length (toList d)
14:13:02 <brad_larsen> the type of the property is abstracted using the typeclass
14:13:14 <brad_larsen> now, to test that a specific implementation satisfies that property
14:13:18 <brad_larsen> i have to do
14:13:37 <brad_larsen> quickCheck (p_size :: TrieDict -> Bool)
14:13:47 <brad_larsen> I don't want to use explicit type signatures there
14:14:01 <brad_larsen> any way to avoid it?
14:14:23 <brad_larsen> without duplicating the p_size code in each concrete implementation's test module?
14:15:28 <brad_larsen> ideally, i want to write a function that operates on abstract types, that tests all the implementation-agnostic properties
14:16:25 <brad_larsen> and call this implementation-agnostic function from within the implementation modules, to test those types
14:16:30 <brad_larsen> anyone?
14:16:49 <bavardage> using pango, is there a way to limit the height of the layout?
14:17:05 <bavardage> there seems to be a function in the pango api for setting the layout height, but gtk2hs bindings don't seem to have it
14:17:12 <bavardage> though there may be another way this is done..
14:18:38 <solistic> Anybody knows, if `pointfree' is still maintained? I have a mini patch to make it buil with ghc-6.10.
14:25:13 <duckinator> hi
14:28:52 <blackh> duckinator: hello
14:29:12 <duckinator> whats up?
14:29:31 <blackh> duckinator: That depends on what side of the world you're on.
14:30:09 <duckinator> blackh: well i'm in the US :P
14:31:16 <blackh> duckinator: I'm in New Zealand. I'm taking a pause in my programming to figure out how to do what I'm trying to do.
14:31:43 <duckinator> well, what are ya tryin to do? :P
14:32:35 <blackh> duckinator: compression of geographical data
14:33:20 <b_jonas> oh no. I have a case in a let in a let in a definition.
14:33:48 <b_jonas> but it's still only four levels of indentation
14:33:55 <b_jonas> haskell code can be complicated
14:34:12 <b_jonas> @type maybe
14:34:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:35:15 <b_jonas> hmm, actually now it's only a maybe in a let in a let
14:35:15 <blackh> duckinator: The trouble is, I think it's all I lie, because I think the world is flat. :)
14:35:49 <duckinator> lol :)
14:35:53 <blackh> duckinator: GPS satellites are hanging on strings.
14:35:58 <duckinator> blackh: well is it like longitude/latitude, height, or what?
14:36:39 <blackh> duckinator: lines and polygons. It's quite a fun thing to do - figuring out how to compress all that.
14:36:47 <dons> shapr: do you have any refs. for the tcp/ip stack you were implementing a few years ago?
14:37:33 <duckinator> blackh: well you can fit single digit numbers in <1 byte, so that might help a bit (but probably only worth it for larger amounts of data)
14:56:13 <Hunner> In haskell what is the way to think about overloading a function? Like "calendar y" and "calendar y m"?
14:56:39 <mauke> "no! bad programmer!"
14:57:16 <blackh> Hunner: The usual way is to put the optional parameter first instead of last... then define two functions with different names.
14:57:18 <shapr> dons: Wasn't me, was the tcp/ip stack in house. I just found some bugs.
14:57:30 <Hunner> The other way I can think is by calling a different function for different arguments. Is that the normal way?
14:57:35 <shapr> dons: I did figure out how to use it with a tun/tap setup.
14:57:38 <MyCatVerbs> Hunner: you appear to be talking about variadic functions there. Usually Haskell programmers stay away from writing functions that take varaible numbers of arguments.
14:57:49 <MyCatVerbs> Hunner: yes, indeed, a thousand times yes.
14:57:56 <Hunner> Okee
14:58:06 <blackh> Hunner: e.g. calender = calendar_ 0    then you can say calendar_ m y  or calendar y
14:58:28 <lament> good point. You can have two functions, calendar and calender
14:58:33 <Hunner> Sounds icky. Is there some other way I should go about this?
14:58:35 <lament> and hope nobody will notice
14:59:31 <mauke> > let calendar = 1; cаlendar = 2 in calendar + cаlendar
14:59:33 <lambdabot>   3
14:59:41 <Hunner> Perhaps I'm thinking about naming my functions incorrectly (Like calendarMonth and calendarYear)
15:00:21 <idnar> mauke: man, how does that work?
15:00:25 <idnar> oh
15:00:34 <blackh> Hunner: Yes - in Haskell if two functions take different numbers of arguments, there's really no way to overload the name. You'd have to use different names.
15:00:41 <idnar> sneaky
15:01:11 <blackh> Hunner: In Haskell it's common to see multiple functions with slightly different names that take their arguments in different ways.
15:01:27 <centrinia> Haskell functions always take one argument.
15:02:09 <centrinia> Functions that differ by their types may not be overloaded by name though.
15:02:43 <bindreturn> blackh, are you doing stuff with postgis ?
15:03:47 <blackh> bindreturn: No. Not using that. Looks interesting.
15:05:04 <bindreturn> ok, read a paper someone wrote bindings to GIS extensions of postgres in haskell - just thought i'd ask
15:05:55 <bindreturn> s/paper/paper where/
15:14:36 * edwardk waves hello.
15:17:41 <flazz_> i have ghc installed on OSX, is there a way i can make a binary that will run on linux without installing ghc on linux? cross-compile static link?
15:19:05 <blackh> flazz_: No there isn't - without doing a whole lot of wokr.
15:20:19 <flazz_> is the simplest way just to static compile on a linux machine and then use it on the target?
15:21:44 <blackh> That's right. Of course you can static compile on a linux machine and use the binary on another linux machine with the same architecture.
15:23:05 <QuietPurple> > let a = 1; a = 2 in a + a
15:23:06 <lambdabot>       Conflicting definitions for `a'
15:23:06 <lambdabot>      In the binding group for: a, a
15:24:34 <QuietPurple> > let si11y = 1; silly = 2 in si11y + silly
15:24:34 <lambdabot>   3
15:24:46 <QuietPurple> no that's not it
15:25:02 <QuietPurple> l1
15:25:10 <QuietPurple> lI
15:25:21 <tumdum> @pl foldr (\(a,b)(as,bs) -> (a:as,b:bs)) ([],[])
15:25:21 <lambdabot> foldr (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (:)) . flip . (((.) . (,)) .) . (:))) ([], [])
15:26:28 <QuietPurple> Ll
15:26:33 <tumdum> @pl foldr (\x xs -> if f x then x:xs else xs) []
15:26:33 <lambdabot> foldr (join . ap ((.) . if' . f) (:)) []
15:26:47 <Asztal> @pl concat <$> (runX $ r >>> s)
15:26:47 <lambdabot> join <$> runX (r >>> s)
15:26:51 <Asztal> ^ weird!
15:27:10 <QuietPurple> O0o
15:27:17 <Asztal> I get that it's the same, but why change it :(
15:27:34 <tumdum> @pl foldr (\x -> (1+)) 0
15:27:34 <lambdabot> foldr (const (1 +)) 0
15:29:01 <QuietPurple> > let calendar = 1; cаlendar = 2 in calendar + cаlendar
15:29:02 <lambdabot>   3
15:29:43 <zloog> Have I gone insane or is there really no dropUntil function?
15:30:06 <Ralith> zloog: sounds familiar
15:30:16 <mauke> :t dropWhile . not
15:30:17 <lambdabot>     Couldn't match expected type `a -> Bool'
15:30:17 <lambdabot>            against inferred type `Bool'
15:30:17 <lambdabot>     Probable cause: `not' is applied to too many arguments
15:30:35 <zloog> Ralith: I just cant find it in hoogle
15:30:47 <Ralith> @pl dropWhile (not f)
15:30:47 <lambdabot> dropWhile (not f)
15:30:49 <Ralith> er
15:30:57 <Ralith> @pl \f -> dropWhile (not f)
15:30:57 <lambdabot> dropWhile . not
15:31:01 <Ralith> hm.
15:31:03 <Asztal_> :t dropWhile . (not .)
15:31:04 <mauke> :t dropWhile . (not .)
15:31:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:31:05 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:31:19 <zloog> Hrm, what does @pl do?
15:31:24 <Ralith> pointfree
15:31:46 <zloog> Ralith: Automatic point free notation? Thats cool!
15:31:53 <Ralith> yup
15:32:09 <EvilTerran> zloog, try not to get too carried away with it, tho ;)
15:32:14 <QuietPurple> mauke: why does that work? what is the trick?
15:32:37 <mauke> mаgic
15:33:06 <QuietPurple> > let calenda = 1; cаlenda = 2 in calenda + cаlenda
15:33:07 <lambdabot>   3
15:33:14 <QuietPurple> > let calend = 1; cаlend = 2 in calend + cаlend
15:33:15 <lambdabot>   3
15:33:21 <QuietPurple> > let calen = 1; cаlen = 2 in calen + cаlen
15:33:22 <lambdabot>   3
15:33:28 <QuietPurple> > let cale = 1; cаle = 2 in cale + cаle
15:33:29 <lambdabot>   3
15:33:35 <Cale> Hi.
15:33:37 <QuietPurple> > let cal = 1; cаl = 2 in cal + cаl
15:33:38 <lambdabot>   3
15:33:39 <mauke> haha
15:33:43 <pumpkin> QuietPurple: having fun?
15:33:45 <QuietPurple> > let ca = 1; cа = 2 in ca + cа
15:33:45 <harovali> Ralith: why did :t fail ?
15:33:46 <lambdabot>   3
15:33:53 <QuietPurple> > let c = 1; c = 2 in c + c
15:33:54 <lambdabot>       Conflicting definitions for `c'
15:33:54 <lambdabot>      In the binding group for: c, c
15:34:00 <QuietPurple> ha!
15:34:05 <EvilTerran> science!
15:34:08 <QuietPurple> > let ca = 1; ca = 2 in ca + ca
15:34:09 <lambdabot>       Conflicting definitions for `ca'
15:34:09 <lambdabot>      In the binding group for: ca, ca
15:34:13 <QuietPurple> sooo...
15:34:16 <zloog> why isnt it evaluating to 4?
15:34:17 <EvilTerran> you could've done that more efficiently with a binary search, though
15:34:24 <QuietPurple> true
15:34:25 <Cale> Whaaaaat is going on there...
15:34:51 <mauke> overloading!
15:35:06 <Cale> :t (+)
15:35:08 <lambdabot> forall a. (Num a) => a -> a -> a
15:35:10 <EvilTerran> i'm guessing one of those "a"s is at a different codepoint
15:35:11 <QuietPurple> so how does one get the ~OTHER~ a?
15:35:19 <Cale> oh!
15:35:20 <mauke> terrible!
15:35:22 <Cale> ahahaha
15:35:26 <Cale> awesome then
15:35:41 <QuietPurple> that is quite cool
15:35:41 <EvilTerran> > map ord "aа"
15:35:43 <lambdabot>   [97,1072]
15:35:47 <EvilTerran> ha!
15:36:14 <stulli_> > ord <$> "aa"
15:36:15 <lambdabot>   [97,97]
15:36:46 <mauke> ɹɐpuǝןɐɔ
15:36:48 <stulli_> Is there any reason (<$>) is defined in Applicative and not in Functor?
15:36:58 <QuietPurple> now you are just showing off
15:37:10 <mauke> yep
15:37:10 <BONUS> probably cause it's used a lot with <*>
15:37:41 <EvilTerran> stulli_, i think people only came up with the idea of writing such things as fmap and ap infix when people thought up Applicative
15:39:02 <stulli_> Ok, i thought there was some more behind it...
15:41:19 <edwardk> evilterran no it came well before
15:41:51 <edwardk> evilterran: ap infix was part of its original explanation. fmap infix was really common through @pl golf
15:42:05 <EvilTerran> true
15:42:10 <edwardk> it became a lot more common after though
15:42:18 <EvilTerran> the idea of giving them non-self-documenting names came after ;)
15:42:35 <EvilTerran> (not that either "fmap" nor "ap" are particularly self-explanatory)
15:42:42 <edwardk> yeah i still get <*> and <$> and whatever confused
15:43:08 <edwardk> ap makes sense since it operates like application
15:43:49 <edwardk> i think <*> was rather poorly chosen if only because there are so many other operators that want to have the <>'s around them that it kind of ruins the whole set of them
15:47:40 <EvilTerran> could've just called it <>
15:47:43 <travisbrady> how do i wrap an existing type with newtype?
15:48:07 <edwardk> that i would have liked =)
15:48:16 <edwardk> newtype Wrapped a = Wrapped a
15:48:39 <edwardk> or newtype WrappedSomething = WrappedSomething Foo
15:49:03 <travisbrady> edwardk: thanks and then how do i get functions returning the Foo to return my new type?  i'm trying to wrap Socket btw
15:49:53 <edwardk> travisbrady: well if they are in a class that Foo is instantiated for, then you can newtype WrappedFoo = WrappedFoo Foo deriving (Eq,Ord,Read,Show,OtherThingThatFooIsInstanceOf)
15:50:30 <edwardk> if its just a method lying around that says something like whatever :: a -> Foo b, then you're out of luck. that returns a Foo, not a WrappedFoo and not an instance of something you can override
15:51:53 <travisbrady> edwardk: ok thanks, i think i may be in the latter camp but i'll have to poke around
15:52:40 <edwardk> travisbrady: what you can do is make a module that exports methods with similar names but which work with your wrapped foo
15:52:46 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2068#a2068
15:52:56 <FliPPeh> I'm trying to write the reverse function of fromList
15:53:02 <FliPPeh> But I'm struggling badly
15:53:04 <edwardk> (the usual idiom would be to export ones with the same name, and expect people to import you qualified)
15:53:06 <FliPPeh> Any hints?
15:53:24 <FliPPeh> Hints, no solution :D
15:53:29 <edwardk> toList (Cons a as) = ...
15:54:03 <FliPPeh> as is a keyword, tho.. let's change it to ays
15:54:11 <travisbrady> would i be able to do that by writing actions that use actions from Network.Socket, but then coercing the Socket to my type?
15:54:20 <edwardk> as actually isn't a keyword =)
15:54:29 <FliPPeh> But it's highlighted :d
15:54:32 <edwardk> its contextually valid as a keyword only in import declarations
15:54:32 <FliPPeh> Meh
15:55:09 <FliPPeh> toList (Cons a as) = [] : a : toList as
15:55:13 <edwardk> > let qualified _ = False in qualified "edwardk"
15:55:14 <lambdabot>   False
15:55:15 <FliPPeh> Probably not, right?
15:55:46 <edwardk> why do you need to prepend [] ?
15:55:53 <FliPPeh> To build a list
15:56:01 <edwardk> @type (:)
15:56:01 <lambdabot> forall a. a -> [a] -> [a]
15:56:13 <edwardk> @type ([]:)
15:56:14 <lambdabot> forall a. [[a]] -> [[a]]
15:56:16 <edwardk> hrmm
15:56:17 <edwardk> =)
15:56:22 <FliPPeh> Meh
15:56:27 <FliPPeh> Works without, too..
15:56:31 <FliPPeh> > 1:4
15:56:32 <lambdabot>       No instance for (Num [t])
15:56:32 <lambdabot>        arising from the literal `4' at <inter...
15:56:34 <FliPPeh> !
15:56:35 <mle> @type (:[])
15:56:35 <FliPPeh> !!
15:56:36 <lambdabot> forall a. a -> [a]
15:56:47 <FliPPeh> Ah wait.
15:56:52 <FliPPeh> > 1:4:6:4:[]
15:56:54 <lambdabot>   [1,4,6,4]
15:56:56 <FliPPeh> Stupid me.
15:57:05 <FliPPeh> > []:4:3
15:57:06 <lambdabot>       No instance for (Num [a])
15:57:06 <lambdabot>        arising from the literal `4' at <inter...
15:57:12 <FliPPeh> I've been doing it the wrong way around
15:57:34 <FliPPeh> Yay it's working
15:58:02 <edwardk> there ya go
15:58:16 <FliPPeh> First Haskell success
15:58:30 <mle> now raise your hands overhead and make the triforce noise.
15:59:00 <timemage> trying to remember the triforce noise now.
16:00:28 <MaDiNfO_> hi
16:05:02 <tony___> hi
16:09:19 * MaDiNfO_ gone
16:26:14 <edwardk> drat my dastardly plan is foiled. you apparently can't put a default definition into a class for a type family =(
16:26:49 <lament> wow, drat is short for "god rot"
16:26:59 <edwardk> that makes my solution a touch uglier than i had hoped
16:27:06 <lament> like bitrot only with much deeper metaphysical implications
16:27:17 <edwardk> fair enough
16:27:25 <EvilTerran> hehe, god rot
16:27:39 <pumpkin> edwardk: can you still weasel out of having to define exponential instances?
16:27:56 <zloog> @pf  B.map (\x-> x-42)
16:27:56 <lambdabot> Maybe you meant: bf pl
16:28:03 <edwardk> pumpkin: yeah but its harder to let end users magic up a definition that autoboxes.
16:28:05 <zloog> @pl  B.map (\x-> x-42)
16:28:05 <lambdabot> B.map (subtract 42)
16:28:10 <pumpkin> ah
16:29:04 <edwardk> pumpkin: i have a class (Nat (Ints a), Nat (Integers a), ..., Nat (Boxes a)) => Packable a where type Ints a :: *; ... with some swizzling routines for getting into and out of some container than can take so many of each of those kinds of slots
16:29:37 <edwardk> I'd hoped that I could define 'type Ints a = Z; ...; type Boxes a = S Z; .. and default to swizzling it into a boxed type
16:29:56 <edwardk> that way if i just exported the class name, then anyone could instance Packable MyType
16:30:05 <edwardk> or they could make newtypes deriving Packable
16:30:15 <edwardk> for former would box, the latter would inherit the unboxing behavior
16:31:01 <edwardk> you can still derive the behavior but its harder to get the autoboxing to work
16:31:21 <edwardk> because its a painful class to implement by hand (i still haven't gotten it working entirely)
16:31:48 <pumpkin> mmm swizzling
16:36:30 <jberryman> has anyone implemented a "tortoise/hare" algorithm for cycle detection? I was hoping for an elegant solution using parallel list comprehensions but can't use them the way I wanted to
16:37:21 <edwardk> jberryman: i have, but i haven't done so in haskell tricky without the ability to compare references
16:37:59 <tromp_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3474#a3474
16:41:26 <FliPPeh> @src length
16:41:26 <lambdabot> Source not found. Just try something else.
16:42:34 <shapr> So we have FliPPeh, flippo, and Philippa, all on the same channel?
16:43:46 <FliPPeh> ;d
16:43:56 <FliPPeh> :t /
16:43:58 <lambdabot> parse error on input `/'
16:44:03 <FliPPeh> :t (/)
16:44:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:54:30 <FliPPeh> > map (+) [1..10]
16:54:31 <lambdabot>       Overlapping instances for Show (a -> a)
16:54:31 <lambdabot>        arising from a use of `s...
16:54:43 <FliPPeh> > map (+) [1..10] :: [Int]
16:54:44 <lambdabot>   Couldn't match expected type `Int' against inferred type `a -> a'
16:54:46 <FliPPeh> :(
16:55:33 <Athas> > foldl (+) 0 [1..10]
16:55:35 <lambdabot>   55
16:55:38 <edwardk> shapr: with this many people these days i'm not surprised
16:55:42 <Athas> Nifty.
16:55:57 <FliPPeh> So my result is correct tho
16:56:01 <FliPPeh> mean []     = 0.0
16:56:01 <FliPPeh> mean (x:xs) = mean xs + x
16:56:07 <FliPPeh> Now I need to divide it by the length
16:56:28 <FliPPeh> once it finished recursing..
16:56:29 <lpsmith> :t map (+) [1..10]
16:56:30 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
16:57:38 <lpsmith> > zipWith ($)  (map (+) [1..10])   [2,4..]
16:57:39 <lambdabot>   [3,6,9,12,15,18,21,24,27,30]
16:59:53 <lpsmith> > [ f x | f <- map (+) [1..4],  x <- [10,20..40]]
16:59:54 <lambdabot>   [11,21,31,41,12,22,32,42,13,23,33,43,14,24,34,44]
17:01:00 <lpsmith> FliPPeh:  :-)
17:01:11 <FliPPeh> ;|
17:01:18 <FliPPeh> mean []     = 0.0
17:01:18 <FliPPeh> mean (x:xs) = foldl (+) 0 (x:xs) / fromIntegral(length (x:xs))
17:01:21 <FliPPeh> Worky
17:02:34 <FliPPeh> Time to sleep
17:02:37 <FliPPeh> Nighty
17:02:45 <andun> FliPPeh: genericLength == fromIntegral . length
17:02:59 <andun> good night :)
17:03:08 <jberryman> edwardk: so this is something like what I am thinking:
17:03:12 <jberryman> let cycling = cycle [1..10] in dropWhile (uncurry (/=)) [ (a,b)  | a<-cycling | b<-tail cycling, even b  ]
17:03:17 <jberryman> > let cycling = cycle [1..10] in dropWhile (uncurry (/=)) [ (a,b)  | a<-cycling | b<-tail cycling, even b  ]
17:03:19 <lambdabot>   [(10,10),(1,2),(2,4),(3,6),(4,8),(5,10),(6,2),(7,4),(8,6),(9,8),(10,10),(1,...
17:04:19 <jberryman> I guess I could just put another parallel list in there with the counter...
17:04:25 <FliPPeh> Exercises tend to be way too easy or too hard
17:04:37 <FliPPeh> Turn a list into a palindrome...
17:04:37 <FliPPeh> pali x = x ++ reverse x
17:04:57 <ski> > genericLength xs == fromIntegral (length xs)  where xs = () : replicate maxBound ()
17:05:00 <lambdabot>   * Exception: stack overflow
17:05:03 <ski> bah!
17:05:12 <lpsmith> FliPPeh:  what about other solutions?
17:05:16 <FliPPeh> > error "Whut."
17:05:18 <lambdabot>   * Exception: Whut.
17:05:27 <lpsmith> Some lists would have shorter solutions...
17:05:34 <FliPPeh> I don't think there's something easier
17:06:03 <lpsmith> no,  that's certainly the easiest solution
17:06:06 <lpsmith> but like
17:06:18 <lpsmith> regallag
17:06:25 <FliPPeh> Also determing palindromes.. if x == reverse x
17:06:33 <lpsmith> doesn't need regallaggallager
17:06:37 <tromp_> pali x = []
17:06:51 <FliPPeh> That's the shortest one!
17:06:56 <FliPPeh> tromp_ wins
17:07:10 <lpsmith> hahaha, yes
17:07:18 <w0rth> hi, what's wrong with newtype Parser a = String -> [(a, String)]
17:07:39 <tromp_> oh, you want it to depend on x? pali  = take 1
17:07:49 <jberryman> w0rth: you need a type constructor
17:08:04 <lpsmith> you can also determine palindromes a little bit more efficiently than that...
17:08:10 <w0rth> jberryman: isn't Parser the type constructor?
17:08:21 <FliPPeh> Meh
17:08:24 <jberryman> newtype Parser a = Parser (String -> [(a, String)])
17:08:28 <FliPPeh> Don't wanna think about it right now
17:08:29 <FliPPeh> 2 AM
17:08:30 <w0rth> i see, thanks
17:08:31 <FliPPeh> Night!
17:08:38 <ski>   newtype Parser a = MkParser (String -> [(a, String)])
17:08:41 <lpsmith> goodnight :-)
17:08:51 <flippsleep> :>
17:08:51 <w0rth> ski: so MkParser is the data constructor?
17:09:28 <lpsmith> You can also call MkParser just "Parser"
17:09:43 <w0rth> lpsmith: which one is the type constructor and which one is the data constructor?
17:09:49 <lpsmith> as the type constructors are disjoint from the data constructor
17:09:58 <lpsmith> the one on the left is the type constructor
17:10:02 <ski> w0rth : yep
17:10:06 <w0rth> makese sense, thanks
17:10:07 <lpsmith> the one on the right is the data constructor
17:10:18 <jberryman> w0rth: right, meant data constructor, sorry
17:10:27 <w0rth> jberryman: cool, thanks
17:10:32 <ski>   newtype Parser a = MkParser { runParser :: String -> [(a, String)] }  -- using record syntax for the selector/projection/deconstructor
17:11:06 <w0rth> i'll ignore that b/c i don't know what any of that means yet
17:11:07 * ski likes to call `runParser' there a `destructor', though
17:11:14 <jberryman> w0rth: just remember that the name on the left will only be found in type signatures, and the one on the right of the = will be in functions
17:12:47 <lpsmith> w0rth:  there isn't much to what was just written
17:12:57 <lpsmith> it's basically shorthand for defining a function
17:13:05 <lpsmith> runParser (MkParser x) = x
17:13:12 <w0rth> oh i see
17:13:16 <ski>   runParser :: Parser a -> String -> [(a, String)]
17:13:31 <w0rth> can you use type synonyms in instance declarations? no, right? i have to use newtype?
17:13:51 <lpsmith> not without using certain GHC extensions
17:14:20 <lpsmith> With GHC extensions,  you could use a type,  but there is complications to using them
17:14:39 <ski> with that extension, you can use a type synonym .. but because the synonym is the same type that it is shorthand for, you can't have two separate instances for the synonym and what it is defined to be
17:14:42 <lpsmith> I usually stick with newtypes or data myself :-)
17:15:04 <w0rth> oh okay, i'll try newtype then
17:15:31 <ski> so if you define `type Size = Int', then you can't have two different instances in the same class, for `Int' and `Size', since they are actually just two different names for the *same* type
17:15:49 <lpsmith> ski:  yupp
17:15:55 <Tigran> @check \n cs -> zip (repeat n) cs == map ((,) n) cs
17:15:57 <lambdabot>   "OK, passed 500 tests."
17:16:04 <ski> either `newtype' or `data' would work
17:16:23 <w0rth> is real world haskell the best book for learning this stuff?
17:16:25 <ski> (but `newtype' is usually preferable, if one would have defined a type synonym otherwise)
17:16:39 * ski hasn't read it, so can't comment
17:16:55 <Tigran> ./nick Petrosian
17:17:05 <Petrosian> Woo.
17:17:11 <lpsmith> w0rth:  I haven't either,  there are a few chapters I might read if I happen to be doing that particular thing
17:17:21 <lpsmith> but I really don't read introductory stuff much anymore
17:17:36 <w0rth> i might get it from the library then...
17:17:40 <lpsmith> I really like "Introduction to Functional Programming"  by Richard Bird
17:18:10 <lpsmith> That's what I worked from a lot.   I don't like some of the code,  but overall it's an amazing book.
17:18:19 <lpsmith> RWH probably has "better" code.
17:18:42 <w0rth> interesting, amazon reviews are so so
17:18:49 <w0rth> i'll check it out
17:19:09 <Petrosian> w0rth: Programming in Haskell by Hutton is also a classic.
17:19:39 <liyang> (Classic? It only just came out last year...)
17:19:55 <liyang> (Though, do buy it please.)
17:20:14 <wli> I'd expect a classic to have a couple thousand years of track record behind it.
17:20:48 <liyang> Yeah. Pfft. Shakespeare? What an amateur.
17:21:34 <lpsmith> Could you translate "A Midsummer Night's Dream" to Haskell?  :-P
17:24:15 <liyang> I learnt Haskell through Paul Hudak's The Haskell School of Expression, which motivates the material using examples from `multimedia', whatever that is.
17:29:21 * ski . o O ( multimedia <http://www.mdstud.chalmers.se/~md9slj/vic3.gif> )
17:35:11 <slide_rule> lpsmith: I know the tragedies better, but maybe I'll try this summer. My haskel knowledge is probably the limiting factor...
17:36:10 <slide_rule> Question re. haskel execution: I'm writing a command line app, and I'd like for it to be able to fail out with a usage message whenever it discovers the commandline is mal-formed.
17:36:29 <slide_rule> In other languages, I'd just use a return or such - best way to accomplish this in Haskell?
17:38:10 <lpsmith> well, there is exception handling... but I don't think that's what you really want to do
17:38:51 <mmorrow> slide_rule: think of "case" like literally splitting your program path of execution in two
17:40:24 <mmorrow> main = do args <- getArgs; case args of file:blah:_ -> exitWith =<< goProg file blah; _ -> do p <- getProgramName; hPutStr stderr (...p...); exitFailure
17:41:19 <mmorrow> goProg :: String -> String -> IO ExitStatus
17:41:20 <lpsmith> the standard trick is to write a function that handles the command line args
17:41:37 <lpsmith> And returns "Either ErrorMessage Info"
17:41:58 <mmorrow> i prefer main being short and sweet, and splitting sending you on your way
17:42:40 <mmorrow> (especially for quicky do-this-real-quick cli stuff)
17:43:26 <lpsmith> mmorrow:  isn't there a package for handling cli arguments?
17:43:56 <mmorrow> yeah, there's stem.Console.GetOpt for when you're actually writing something not for a task-at-hand
17:44:00 <mmorrow> *System
17:44:00 <slide_rule> @hoogle exitWith
17:44:01 <lambdabot> System.Exit exitWith :: ExitCode -> IO a
17:44:42 <BMeph> wli: ping
17:45:09 <mmorrow> (main can actually be :: IO a for any a)
17:45:32 <mmorrow> (it just discards the result)
17:46:28 <BMeph> Or, anyone that knows: Eisenstein ints use a+b\omega, right? Where \omega is (1/2)(1+sqrt 3).
17:46:49 <mmorrow> lpsmith: although i have to say, having ..Console.GetOpt wired would be really handay
17:46:58 <lpsmith> BMeph:  sounds right
17:46:59 * mmorrow doesn't have it wired
17:47:20 <pumpkin> http://en.wikipedia.org/wiki/Eisenstein_integer
17:47:20 <lpsmith> mmorrow:  wired?
17:47:42 <pumpkin> BMeph: you missed the i :P
17:47:49 <mmorrow> lpsmith: like "wired into your brain" / "you can code with it without thinking"
17:47:58 <lpsmith> ahh,  lol
17:48:02 <mmorrow> ;)
17:48:23 <lpsmith> Yeah,  I'm not good at "wiring" a lot of libraries up
17:48:38 <lpsmith> I'm constantly referring to the documentation, almost no matter the language or library
17:49:03 <lpsmith> language issues are another issue entirely
17:49:07 <BMeph> pumpkin: Ah, good eye. s/1/i/ -- better? :)
17:49:16 <pumpkin> nope!
17:49:58 <pumpkin> well, I suppose you have three (or two) options,but according to the wiki page it's -1 +i*sqrt3
17:50:03 <pumpkin>  / 2
17:50:05 <BMeph> pumpkin: s/1\+/i\+/ -- Hmm?
17:50:59 <slide_rule> mmorrow: let me make sure I've got the "=<<" right: it's run goProg and then run exitWith with goProg's return value, correct?
17:52:03 <Cale> slide_rule: Yeah, exitWith =<< goProg means to run goProg, then apply exitWith to the result, and run that.
17:52:31 <BMeph> pumpkin: Duh, Wikipedia! Thanks! ;p
17:52:34 <lpsmith> pumpkin:  You seem to be missing a constant somewhere in there
17:52:51 <lpsmith> I just remember e^(i * pi / 3)
17:53:01 <pumpkin> yeah :)
17:53:09 <pumpkin> or 2i pi / 3 is the one they use
17:54:11 <BMeph> pumpkin, lpsmith: Yeah, e**(i*pi/3) would give sixth roots. Still closer than what I did, though, so I'll just point at it. :)
17:54:18 <mmorrow> slide_rule: exactly
17:55:09 <pumpkin> we need a central list of all non-hackage-based haskell projects
17:55:20 <BMeph> Cale: The *Kleisli* star -- see, I /can/ be trained! ;)
17:55:22 <pumpkin> so we can email the authors and ask them if we can put them on hackage
17:55:31 <Cale> BMeph: :)
17:58:28 <jml> BMeph: hmm.
17:58:47 <BMeph> jml: "hmm"? :)
17:59:00 <jml> BMeph: we could probably cook something up with Launchpad APIs that would find projects on Launchpad that are in haskell but not on hackage.
17:59:27 <jml> it probably wouldn't be a huge number, but you'd catch some :)
17:59:35 <BMeph> jml: ^--> pumpkin. :)
17:59:45 <jml> or sorry
17:59:48 <pumpkin> ?
17:59:55 <pumpkin> oh
17:59:56 <jml> damn you, parallax error!
18:00:23 <pumpkin> not just launchpad though
18:00:35 <pumpkin> I'm not sure many haskell projects use bzr do they?
18:00:46 <pumpkin> I mean there are a bunch of university-hosted projects that aren't on hackage, it seems
18:00:55 <jml> *nod*
18:00:56 <BMeph> jml: Your page probably scrolled up a line right as you chose, and got my name in between pumpkin's two remarks. :)
18:01:11 <pumpkin> maybe it's just cause I'm so similar to BMeph
18:01:20 <jml> pumpkin: as I said, you wouldn't get many, but you'd probably get some.
18:02:01 <BMeph> jml, pumpkin: Maybe we could at least encourage them to try out patch-tag. ;)
18:02:15 <pumpkin> BMeph: yeah, or github ;)
18:02:37 <pumpkin> but patch-tag works too
18:02:54 <pumpkin> I only have one project on there
18:03:01 <pumpkin> and it isn't mine
18:03:09 <lpsmith> speaking of hackage... I have a package I really need to finish up
18:04:14 <lpsmith> I don't really have tests,  either correctness or performance written yet
18:04:25 <lpsmith> Well, I sorta have a decent start on correctness tests
18:05:19 <jml> bah, who needs tests when you have rigorous typing? right? right!?
18:05:25 <dolio> Tests are overrated, dude.
18:05:37 <lpsmith> hah!
18:05:46 <ski> who tests the tests ?
18:05:50 <pumpkin> tests helped me find a bunch of (minor) bugs in uvector :)
18:07:30 <shapr> I want a metadata lib, for organizing my music.
18:07:37 <edwardk> ok i give up for now, putting down the shiny new packers and getting some rest
18:07:59 <pumpkin> :o
18:08:02 <pumpkin> no rest for the wicked
18:09:27 <edwardk> it looks like i may wind up relying on the fact that the unpacker can unpack multiple levels of stuff
18:10:25 <edwardk> so a single {-# UNPACK #-} can go multiple levels deep if its monomorphic. so if () unpacks to nothing, then {-# UNPACK #-} !(Int,()) should unpack to a single int in the container
18:11:18 <dolio> Does it?
18:11:20 <edwardk> so i can do {-# UNPACK #-} !(Int,(Int,())) and so on, and cut it apart into pieces to handle tupling locally
18:11:31 <edwardk> yeah, my quick test worked
18:11:44 <dolio> Huh, I wouldn't have guessed that.
18:11:56 <pumpkin> so !(Int, (Int, ()) unpacks to be completely flat?
18:11:59 <kerlo> So, I want to run a Haskell application on a machine that cannot run GHC.
18:12:10 <pumpkin> (assuming I add the missing paren)
18:12:26 <edwardk> http://www.haskell.org/ghc/docs/latest/html/users_guide/pragmas.html
18:12:38 <edwardk> pumpkin: thats what i'm looking to test
18:12:48 <kerlo> What should I do? Compile it locally, then transfer the binary?
18:12:55 <dolio> I was thinking you'd have to do {-# UNPACK #-} !Int {-# UNPACK #-} !(UnpackedTuple Int ()).
18:13:26 <edwardk> Any single-constructor data is eligible for unpacking; for       exampledata T = T {-# UNPACK #-} !(Int,Int) will store the two Ints directly in the       T constructor, by flattening the pair.       Multi-level unpacking is also supported:
18:13:46 <pumpkin> what happens for multi-constructor data?
18:14:06 <edwardk> nothing, you can't unpack multiple constructors
18:14:25 <edwardk> which btw makes me question how Integers unpack, they have two constructors these days!
18:14:26 <pumpkin> boo, don't see why not
18:14:36 <pumpkin> integers don't unpack do they?
18:14:38 <pumpkin> only Ints
18:14:48 <edwardk> i really should check to see what gets generated
18:15:10 <edwardk> pumpkin: its included in the list of primitives that dons was using in his unpacker
18:15:16 <dolio> edwardk: Doesn't that say that "data T = T {-# UNPACK #-} !(Int,Int)" is equivalent to "data T = T Int Int"?
18:15:17 <edwardk> i suppose i can vacuum and find out
18:16:05 <edwardk> it will store them unboxed in the constructor so, data T = T {-# UNPACK #-} !(Int,Int) ~ data T = T {#- UNPACK #-} !Int {-# UNPACK #-} !Int
18:16:29 <dolio> It says that for the example with T and S.
18:16:34 <edwardk> ahh
18:16:35 <edwardk> crap
18:16:39 <edwardk> testing =)
18:16:49 <pumpkin> multi-constructor data should be unpackable too! :(
18:17:03 <BMeph> Has anyone reinstalled gtk/cairo after bumping up to 10.2?
18:17:10 <pumpkin> dons' unpacked list works with that
18:18:42 <edwardk> pumpkin we have to pull a lot of tricks to make efficient work out of multiple constructors. continuation passing, recycling unboxed values, moving definitions into dictionaries to ease specialization, etc.
18:19:18 <pumpkin>     data List Bool = EmptyBool | ConsBool {-# UNPACK #-}!Int (List Bool)
18:19:32 <pumpkin> and his vacuum graphs showed that behaved as expected
18:19:35 <edwardk> crap
18:19:38 <pumpkin> so I assume that documentation is out of date?
18:19:45 <edwardk> you're right, ok, so much for the easy tuple version =)
18:19:57 <edwardk> that one is perfectly sound
18:20:04 <edwardk> you can unpack IN multiconstructors
18:20:12 <edwardk> you jst can't unpack multiconstructor daa
18:20:30 <edwardk> data Foo = Foo {-# UNPACK #-} !(Maybe Int) doesn't do anything
18:20:31 <pumpkin> ah, that would make sense (although it could still work with more work)
18:20:38 <slide_rule> regarding the use of System.Console.GetOpt - I looks like there's no way to indicate than an option takes >1 argument, this correct?
18:21:39 <pumpkin> edwardk: but I'm surprised it flattens nested strict unboxed things
18:22:41 <edwardk> oh yeah i should go back and test that other variation on the theme
18:23:39 <pumpkin> shapr, edwardk: any idea on when next CHUG will be?
18:23:51 <shapr> WHAT?
18:23:55 <shapr> oh right
18:24:01 <pumpkin> :o
18:24:07 <dolio> Yeah, if you declare UnpackedTuple Int (), and UnpackedTuple a b => UnpackedTuple Int (Tup a b), do you get unpacked Int tuples of arbitrary size?
18:24:15 <shapr> pumpkin: I've decided you have to organize it.
18:24:20 <pumpkin> onoes!
18:24:35 <edwardk> dolio: tried and failed
18:24:46 <pumpkin> that would be pretty sweet if it worked
18:25:15 <edwardk> dolio: even through a data family where you have explicitly specialized to something that is monomorphic
18:25:35 <dolio> That's a bummer.
18:25:37 <pumpkin> haven't heard much from eu-prleu-peupeu recently
18:28:21 * BMeph calls out to warn edwardk about those UTUS - Unpacked Tuples of Unusual Size.
18:28:36 <pumpkin> lol
18:31:47 <edwardk> BMeph: hah
18:32:10 <edwardk> "ConsInt|0" -> {"ConsInt|1"} "ConsInt|1" -> {"()|2"} "()|2" -> {}
18:32:12 <edwardk> nope =)
18:32:21 <edwardk> just double checked to make sure i wasn't missing something earlier
18:32:40 <pumpkin> aw
18:34:11 <edwardk> yeah Integers don't work, so i should probably poke dons to remove them from AdaptTuple
18:34:26 <edwardk> woot down to 4 slot types now
18:34:31 <pumpkin> lol
18:34:38 <edwardk> could go down to 3 if I wanted to assume Int = Int64 ;)
18:35:00 <pumpkin> just use CPP to decide whether Int == Int64
18:35:02 <pumpkin> or Int32
18:35:16 <edwardk> yay then i have a whole pile of conditional instances, that sounds like hell
18:35:45 <pumpkin> type TheOtherInt =
18:35:52 <pumpkin> type NativeInt =
18:36:11 <edwardk> pumpkin: then someone comes along in 20 years with a 128 bit machine and where am i? =)
18:36:21 <edwardk> oh yeah retired sipping margaritas
18:36:23 <pumpkin> type TheIntIDidntPredict
18:36:48 <pumpkin> :D
18:38:26 <gwern> I wonder whether we'll get 128 bit machines before 2100. I haven't heard of any real uses, I don't think, except I understand some vector stuff likes enormous things like 128-bit
18:39:55 <edwardk> vector stuff likes bigger ints than that =-)
18:40:21 <edwardk> simd and vector ops operate on very different scales ;)
18:40:25 <liyang> Don't think they're still interpreted as ints when they're that big.
18:41:26 <liyang> We'll get 128-bit machines if and only if our robot overlords will allow us.
18:44:07 * liyang wonders if there's a trend in the life-span of 4-, 8-, 16-, 32- and 64-bit CPUs.
18:44:30 <liyang> Well, scratch the last one. Don't think we're quite done with that era yet.
18:45:07 * BMeph plans to blow the trend and design an 81-trit processor! >;)
18:45:38 <gwern> liyang: heck, I can tell you without looking - you'll find that the length of time between them gets longer
18:45:52 <gwern> now, whether that's a linear or exponential increase, I dunno
18:46:00 * jfredett read that as 81-twit professor, and almost told BMeph it'd already been done...
18:46:07 <liyang> gwern: quantify and extrapolate to 128-bit machines plzkthx.
18:47:04 * jfredett desparately tries to justify his use of associated types to himself instead of the evidently equivalent direct-record method... Awesomeness is not enough of a reason... :/
18:47:24 <pumpkin> :o
18:48:01 * liyang has the same problem with functional references. :-/
18:48:40 <liyang> Not that I should be hacking on code right now. Write your paper, you twit.
18:49:02 <jfredett> liesen: I started writing a blogpost to explain how I used assoc types to make type-indexed records, then I realized, thats not actually all that hard.
18:49:15 <jfredett> data IndexedRec a b = blah.
18:49:52 <jfredett> it's very neat, in any case, abstract playing cards in 150L... :)
18:49:56 <liyang> jfredett: write and post it; I'll read it later. :)
18:50:38 <jfredett> liyang: well, the problem is I want to justify what I'm doing to myself, but I can't find a good reason...
18:52:36 <edwardk> jfredett: "it was cool" doesn't cut it?
18:52:36 <liyang> Justification? *shrug* Intellectual onanism.
18:53:43 <jfredett> edwardk: well, that cuts it for me, but I imagine theres a non-trivial reason why the assoc types method will be better.
18:54:35 <liyang> Blog it and let someone else figure it out / post the answer as a comment. :3
18:54:48 <jfredett> hehe
18:54:53 <jfredett> good plan.
18:59:17 <BMeph> Is it "legal" to override one definition of a class, while keeping the automatic derivation of the rest?
19:02:05 <EvilTerran> BMeph, with -XOverlappingInstances, maybe
19:03:39 <BMeph> EvilTerran: Oh! Why, that's positively...oh, considering the source. Thanks, ET! ;)
19:03:40 <dolio> He's talking about, like, "class Eq a where (==), (/=) :: a -> a -> Bool ; a == b = not (a /= b) ; a /= b = not (a == b)".
19:03:48 <dolio> I think.
19:04:05 <dolio> And, yes, you can override as many of the default implementations as you choose.
19:05:59 <BMeph> dolio: Cool. I'm thinking of using Rationals to whip up a module for Gaussians and Eisenstein ints. I was just thinking of a more conventional printing style than "3%1 :+ 4%1". :)
19:07:42 <dolio> Ratio has a constraint on it, doesn't it?
19:07:46 <dolio> For who knows what reason.
19:07:48 <pumpkin> Integral
19:07:53 <pumpkin> I think
19:08:17 <dolio> Oh, wait, I'm thinking of Complex.
19:08:28 <pumpkin> RealFloat on that one iirc
19:08:32 <pumpkin> :t (:+)
19:08:33 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
19:08:38 <dolio> Yeah, that's the bad one.
19:09:51 <BMeph> (from Data.Ratio):"Integral a => RealFrac (Ratio a)" -- Yes! This might even work! :)
19:11:38 * BMeph imagines the mischievous glee he'll have adding the constraint, (Real a) => Real (ContFrac a)
19:12:12 <BMeph> Whoops, I need to get home - chat with y'all later. :)
19:15:07 <codebliss> Okay.  http://haskell.pastebin.com/m191a3abb is my first pseudo-useful (or not =P) unix command I finally compiled and have sitting in my bin.  I want to try to *decompress this* and get rid of the do-syntax.
19:15:47 <codebliss> How do I make a function return an IO if it normally doesn't?  Or am I thinking wrong.
19:15:57 <pumpkin> just lift it into IO
19:15:59 <pumpkin> liftM or fmap
19:16:10 <codebliss> Okay fmap I think
19:16:15 <codebliss> Currently i have             main = getArgs >>= (map toUpper) >>= print >> return ()
19:16:20 <codebliss> But map toUpper is NOT an IO
19:16:28 <codebliss> Just trying to get this into my head
19:16:32 <jmcarthur> the return () is unnecessary, btw
19:16:36 <codebliss> Okay
19:16:44 <codebliss> Since print returns IO ()?
19:16:48 <jmcarthur> right
19:17:28 <jmcarthur> codebliss: is this homework or are you just learning yourself?
19:17:30 <codebliss> So try..  main = getArgs >>= fmap $ map toUpper >>= print
19:17:43 <codebliss> I've never taken a programming class in my life XD  Still in HS
19:17:49 <jmcarthur> mmkay
19:18:04 <codebliss> I don't care about grades really, terrible system.  I do stuff to learn.
19:18:24 <codebliss> Shit I've watched 9 hours of tuts on channel9 today, lol.  Ugh.  My eyes.
19:18:33 <jmcarthur> here are my building blocks when i'm trying to think declaratively with monadic code
19:18:43 <jmcarthur> ah, your approach to learning sounds like mine ;)
19:18:43 <codebliss> Mkay.
19:18:47 <codebliss> =P
19:18:48 <jmcarthur> :t return
19:18:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:18:51 <jmcarthur> :t fmap
19:18:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:19:02 <jmcarthur> :t (<*>)
19:19:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
19:19:07 <jmcarthur> :t (=<<)
19:19:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:19:25 <jmcarthur> it helps to put parentheses at the end
19:19:25 <codebliss> Ooh, there's a =<<
19:19:36 <jmcarthur> like fmap :: (a -> b) -> (f a -> f b)
19:19:39 <jmcarthur> yes :)
19:19:43 <codebliss> Okay.
19:19:48 <codebliss> Add those to the top of the file?
19:20:00 <jmcarthur> but when you look at them that way you see that they are just functions to list pure functions into your monad
19:20:08 <jmcarthur> s/list/lift/
19:20:18 <jmcarthur> you don't have to add them yourself
19:20:31 <codebliss> I mean for reference and learning?
19:20:36 <jmcarthur> you have fmap in Prelude already. (<*>) is in Control.Applicative. (=<<) is in Control.Monad
19:20:40 <codebliss> I've seen most of those before =P
19:20:45 <jmcarthur> ah, sure if you want :)
19:20:46 <codebliss> All but =<<
19:20:49 <codebliss> Ya, okay.
19:20:54 <jmcarthur> sorry, brb
19:21:00 <codebliss> I'll just add a gedit cmmand to insert them if I get stuck
19:21:03 <codebliss> np mate, tyvm =)
19:21:07 <sm> evening all. I'm doing readFile, then later appendFile, but it says the resource is still busy, presumably because it hasn't finished reading ? What's a good way around this ?
19:21:36 <sm> this is mentioned at http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#8
19:21:46 <codebliss> Could wait for jmcarthur , I haven't actually gotten into file ops =)
19:22:39 <jmcarthur> codebliss: i'm just on the phone, i'll be back quick
19:23:48 <jmcarthur> codebliss: okay, i'm back
19:24:35 <jmcarthur> okay, so yeah, those are my usual primitive building blocks. you can start by putting getArgs on the right, then working your way left
19:24:46 <codebliss> Ah okay
19:24:52 <jmcarthur> :t getArgs -- first you have this
19:24:53 <lambdabot> Not in scope: `getArgs'
19:24:56 <jmcarthur> grr
19:25:00 <jmcarthur> where is that, System?
19:25:06 <jmcarthur> :t System.getArgs
19:25:08 <lambdabot> IO [String]
19:25:10 <jmcarthur> aha
19:25:58 <jmcarthur> :t fmap head System.getArgs -- okay, so then you want the head of the list, so you can do this
19:25:59 <lambdabot> IO String
19:26:00 <codebliss> import System	(getArgs); import Char 	(toUpper)
19:26:22 <jmcarthur> also, there is a nice operator defined in Control.Applicative. (<$>) = fmap
19:26:31 <jmcarthur> :t head <$> System.getArgs
19:26:32 <lambdabot> IO String
19:26:50 <jmcarthur> but i often switch back and forth depending on which i think is prettier
19:26:58 <codebliss> mkay =P
19:27:13 <liyang> codebliss: print =<< (map Char.toUpper . head <$> getArgs)
19:27:18 <jmcarthur> then it looks like the next thing you want is to uppercase the string in the IO String that we have
19:27:33 <jmcarthur> liyang just spoiled the fun ;)
19:27:39 <liyang> Sorry.
19:27:40 <codebliss> liyang: Thank you, I'll break it down XD
19:27:43 <codebliss> It's fine lol
19:27:46 <liyang> Normally, I'd use `fmap` instead of <$> because I'm too lazy to import Control.Applicative.
19:27:47 <jmcarthur> liyang: it's okay :P
19:27:53 <codebliss> Ah
19:28:08 <jmcarthur> codebliss: anyway, you get the idea. i was just trying to lead you through how i think about it
19:28:14 <codebliss> Okay =)
19:28:20 <codebliss> I'm putting in all the type declerations
19:28:25 <liyang> But you can't set the fixity of `fmap` outside of its defining file, which is annoying because you then can't mix `fmap` with (.)
19:28:30 <codebliss> Then if I have any Q's I'll fire em up
19:28:37 <codebliss> Ah
19:29:19 <jmcarthur> :t print =<< Char.toUpper <$> fmap head getArgs
19:29:21 <lambdabot> Not in scope: `getArgs'
19:29:24 <jmcarthur> :t print =<< Char.toUpper <$> fmap head System.getArgs
19:29:25 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
19:29:26 <lambdabot>       Expected type: IO [Char]
19:29:26 <lambdabot>       Inferred type: IO [String]
19:30:07 <jmcarthur> :t print =<< map Char.toUpper . head <$> System.getArgs
19:30:09 <lambdabot> IO ()
19:30:11 <jmcarthur> there we go
19:30:29 <codebliss> You're crazy.  =P
19:30:45 <jmcarthur> heh, same as liyang's, woops
19:30:49 <jmcarthur> just no parens
19:30:50 <liyang> Actually, that sort of code comes as second nature after a while...
19:31:08 <liyang> jmcarthur: I can never remember the fixity of stuff. ^^;;
19:31:10 <jmcarthur> yeah, it really ends up being easier to read than do notation much of the time
19:31:11 <codebliss> I could assume so =)
19:31:32 <codebliss> Where's <$> again?
19:31:39 <codebliss> Compiling before I try to reason from scratch
19:31:40 <jmcarthur> the knowledge is nice to have for monads that are not IO too, since this way looks like imperative
19:31:44 <jmcarthur> Control.Applicative
19:31:47 <codebliss> Thanks
19:31:54 <jmcarthur> *looks less imperative
19:32:10 <liyang> <$> is definitionally equal to fmap, mind you.
19:32:31 <jmcarthur> yeah, i tried to make sure that was clear above
19:32:31 <codebliss> is import Control.Applicative (<$>) invalid?
19:32:38 <codebliss> Ya you said that =P
19:32:42 <jmcarthur> import Control.Applicative ((<$>))
19:32:46 <drhodes> anyone know of an imperative language with a type system as strong as haskell's?
19:32:46 <jmcarthur> since it's an operator
19:32:46 <codebliss> Is that `fmap` ?
19:32:50 <codebliss> Oh
19:33:14 <codebliss> It works, damn you geniuses =)
19:33:16 <codebliss> K reasoning...
19:33:18 <jmcarthur> drhodes: haskell is a pretty good imperative language :)
19:33:24 <codebliss> It is I must admit.
19:33:47 <liyang> drhodes: and its type system is as strong as Haskell's.
19:34:19 <edwardk> drhodes: imperative? no
19:34:52 <jmcarthur> liyang: i never remember fixity either. i just guess until it's right :\
19:35:37 <jmcarthur> codebliss: oh, yes, it's fmap
19:35:40 <jmcarthur> @src (<*>)
19:35:40 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:35:45 <jmcarthur> @src Control.Applicative.(<*>)
19:35:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
19:35:47 <jmcarthur> grr
19:35:52 <jmcarthur> @src Control.Applicative.(<$>)
19:35:53 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
19:36:02 <jmcarthur> eh whatever
19:36:10 <codebliss> :t Control.Applicative.(<$>)
19:36:11 <lambdabot> Couldn't find qualified module.
19:36:13 <jmcarthur> (<$>) = fmap
19:36:20 <codebliss> infix fmap?
19:36:26 <jmcarthur> yup
19:36:30 <codebliss> so `fmap`?
19:36:31 <jmcarthur> different fixity from `fmap` though
19:36:34 <codebliss> oh
19:36:45 <codebliss> swap `fmap`?
19:36:54 <codebliss> I'm just guessing lol, I'll go look at this stuff
19:38:27 <monochrom> Modula-3 and Oberon have very expressive and static type systems.
19:39:40 <codebliss> So its..  print =<< ([Char] -> [Char])  . IO String
19:39:46 <codebliss> Hm?
19:40:10 <codebliss> IO String is a.. a -> b
19:40:10 <codebliss> ?
19:40:29 <aLegendaryPengui> is top down parsing stupid?
19:40:48 <monochrom> No.
19:41:09 <aLegendaryPengui> but it works by building trees that might not even be valid for the input, right
19:41:14 <aLegendaryPengui> isnt that wasteful
19:41:19 <codebliss> jmcarthur: Busy mate?  Priv alright so I don't spam this with my idiocy?  =P
19:41:52 <monochrom> No, it does not build trees that might be invalid.
19:42:18 <aLegendaryPengui> what
19:42:31 <aLegendaryPengui> why is it "top down" then
19:42:49 <Philippa__> monochrom: well, sort of. You can view them as being 'in the stack'
19:43:05 <mmorrow> aLegendaryPengui: if it's doing depth-first search, then sure it can can follow a path that'll end up being the wrong one at some point in the future
19:43:21 <liyang> @src (Control.Applicative.<$>)
19:43:21 <lambdabot> Source not found. Sorry.
19:43:25 <aLegendaryPengui> yeah
19:43:26 <Philippa__> and if you've got backtracking then you might well have actually built some useless tree. Except insofar as laziness bails you out
19:43:27 <liyang> :-/
19:43:50 <liyang> lambdabot: you suck.
19:43:50 <Philippa__> aLegendaryPengui: bottom-up does it too. It might turn out that the context makes it irrelevant
19:44:01 <codebliss> LOL
19:44:05 <mmorrow> @src (<$>)
19:44:06 <lambdabot> f <$> a = fmap f a
19:44:11 <codebliss> Whisper to the bot XD
19:44:23 <Philippa__> aLegendaryPengui: in reality, we try to parse languages that admit parsers that don't do stupid things unnecessarily
19:44:25 <codebliss> Sooo...it is `fmap` ?
19:44:37 <codebliss> :t `fmap`
19:44:39 <lambdabot> parse error on input ``'
19:44:42 <mmorrow> yes
19:44:45 <codebliss> Doesn't exist?
19:44:48 <codebliss> aha
19:44:57 <aLegendaryPengui> but say your sentence starts with a verb, and you do top down parsing.  Wouldnt it expand all the trees then realize, oh nothing can start with a verb
19:45:04 <mmorrow> @type [fmap,(<$>)]
19:45:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
19:45:06 <aLegendaryPengui> once it reaches the bottom levels
19:45:09 <Philippa__> no, it wouldn't
19:45:13 <aLegendaryPengui> why wouldnt it?
19:45:29 <aLegendaryPengui> i thought top down parsing keeps expanding trees until the input matches
19:45:29 --- mode: ChanServ set +o shapr
19:45:35 <shapr> huh, cool
19:45:41 --- mode: shapr set -o shapr
19:45:52 <monochrom> Let me just say you have greatly misunderstood top-down parsing.
19:45:59 --- mode: ChanServ set +o lambdabot
19:46:02 <Philippa__> you don't expand all possible parse trees at all
19:46:04 --- mode: ChanServ set -o lambdabot
19:46:08 <aLegendaryPengui> well maybe this book explained it wrongly
19:46:13 <aLegendaryPengui> its some shitty linguistics book
19:46:20 <Pseudonym> Who gave lambdabot ops privileges?
19:46:24 <shapr> me me!
19:46:26 <aLegendaryPengui> i should have been reading compilers book
19:46:36 <Philippa__> ah, if it's linguistics then it's looking at a very different context from computer languages
19:46:36 <Pseudonym> So who knows its nickserv password?
19:46:41 <shapr> aLegendaryPengui: Hey, at the least book got you interested, yeah?
19:46:45 <shapr> Pseudonym: I dunno that
19:46:47 <Philippa__> one where you're stuck with 'stupid' behaviour whatever you do
19:46:48 <aLegendaryPengui> in what?
19:46:58 <codebliss> What would have higher precedance?  . or <$>?  Ah.....
19:46:59 <Pseudonym> Don't you need to be logged in to be an op?
19:47:02 <monochrom> The linguistic book describes things you do by hand. No one does it on comptuers.
19:47:08 <shapr> Pseudonym: I'm logged in...
19:47:11 <shapr> so I can give ops
19:47:16 <aLegendaryPengui> this book is shit, its not computer science enough
19:47:19 <Pseudonym> I'm talking about lambdabot.
19:47:19 <liyang> codebliss: The problem with using names as infix operators is that their fixity defaults to 9 -- the same fixity as (.), which is annoying.
19:47:21 --- mode: ChanServ set -o Pseudonym
19:47:23 <aLegendaryPengui> and i paid 50 dollars for it, so worthless
19:47:25 <Pseudonym> Ah.
19:47:27 --- mode: ChanServ set +o Pseudonym
19:47:28 --- mode: ChanServ set +o Pseudonym
19:47:50 <shapr> aLegendaryPengui: Hey, at least it got you moving in the right direction!
19:48:00 --- mode: ChanServ set +o lambdabot
19:48:01 <Philippa__> *shrug* - you picked a book from the wrong field, that just makes it bad for your purposes
19:48:06 <aLegendaryPengui> "a top down parser searches for a parse tree by trying to build from the root node S down to the leaves"
19:48:19 <Philippa__> a linguist wouldn't care about LL(1) languages
19:48:22 <aLegendaryPengui> hey, they cancelled the compilers course.  god
19:48:27 <Philippa__> except as a curiosity
19:48:30 <aLegendaryPengui> i dont like natural language processing
19:48:36 <monochrom> Another instance is the extended euclidean algorithm. There is a "do the gcd steps first, then backtrack those steps" procedure in number theory books. It is for doing by hand. No one does that on computers.
19:48:36 <liyang> codebliss: which means e.g. (map Char.toUpper . head) `fmap` getArgs  and  map Char.toUpper . (head `fmap` getArgs)  are equally valid parses.
19:48:39 <Pseudonym> Bug somewhere.
19:48:43 <Pseudonym> I like natural language processing now.
19:48:49 <Pseudonym> It's changed a LOT in the last 15 years.
19:48:51 <aLegendaryPengui> i dont, its useless crap field
19:48:55 <Pseudonym> It's all machine learning now.
19:49:02 <aLegendaryPengui> yeah, and all training data
19:49:05 <aLegendaryPengui> its useless
19:49:06 <Pseudonym> Which makes more sense, since that's actually principled.
19:49:17 <aLegendaryPengui> a real language processor wouldnt need training data
19:49:20 <liyang> codebliss: except the second doesn't typecheck. But the compiler doesn't try to be that `clever'.
19:49:28 <aLegendaryPengui> if we had real AI we wouldn need any of this crap
19:49:30 <Pseudonym> aLegendaryPengui: OK, tell me something on Croatian.
19:49:31 <QtPlaty[1ireMe]> monochrom: I've done that on a computer.
19:49:40 <Pseudonym> If you're really intelligent, you should be able to do it.
19:49:42 <inimino> aLegendaryPengui: right, it would just be born knowing it all, like a human
19:49:43 <Philippa__> aLegendaryPengui: real intelligences need training data too
19:49:46 <aLegendaryPengui> Croation?
19:49:49 <aLegendaryPengui> wtf
19:49:53 <Pseudonym> Croatian.
19:49:53 <aLegendaryPengui> i dont know
19:49:55 <Pseudonym> Right.
19:49:58 <aLegendaryPengui> what about it
19:50:02 <Pseudonym> So you do need to learn a language before you can process it.
19:50:06 <codebliss> liyang: Thanks =)
19:50:11 <aLegendaryPengui> thats just because we are weak
19:50:20 <aLegendaryPengui> concepts like language are stupid
19:50:21 <inimino> lol
19:50:27 <aLegendaryPengui> there should be something better
19:50:29 <codebliss> I have to spend a minute on fmap, still don't *totally* get it
19:50:30 <inimino> aLegendaryTroll
19:50:40 <aLegendaryPengui> no, why is it we have to have 100 different languages
19:50:41 <Philippa__> inimino: legendarily bad? :-)
19:50:49 <shapr> aLegendaryPengui: Stupid is a purely emotional description. What are the strong and weak points of 'language' ?
19:50:58 <Philippa__> aLegendaryPengui: a bunch of idiots built a huge phallic symbol and screwed everyone's speech?
19:51:01 <QtPlaty[1ireMe]> aLegendaryPengui: How would you communicate infomation without a language?
19:51:07 <aLegendaryPengui> some other way
19:51:11 <aLegendaryPengui> telepathically
19:51:17 <aLegendaryPengui> if we built computers into people
19:51:26 <Philippa__> then they'd use languages too
19:51:28 <aLegendaryPengui> transmitters
19:51:32 <nvoorhies> surgically!
19:51:33 <aLegendaryPengui> but we wouldnt be aware of it
19:51:43 <Pseudonym> Mi akordas.  Ni devas paroli Esperanton.
19:51:46 <aLegendaryPengui> and you could think something or have a concept and transmit it to someone else instantly
19:51:53 <shapr> Jag kan tala svenska...
19:51:54 <aLegendaryPengui> directly into their mind
19:52:15 <aLegendaryPengui> i dont know, it just seems NLP is very limited field
19:52:18 <shapr> mi djica lenu do tavla mi bau la lojban
19:52:18 <aLegendaryPengui> in general
19:52:34 <aLegendaryPengui> the fact that you have to have huge training sets to do anything useful
19:52:38 <shapr> Eu gosta Portugues :-)
19:52:56 <QtPlaty[1ireMe]> Mostly because NLP is AI-Hard.
19:53:11 <Pseudonym> You can get a long way without doing AI-hard stuff.
19:53:21 <QtPlaty[1ireMe]> Pseudonym: True.
19:53:29 <aLegendaryPengui> AI hard?
19:53:41 <Pseudonym> (My new job involves NLP; I have to learn everything that's been discovered in the last 15 or so years since I last looked at it.  It's MUCH more principled now.)
19:53:46 <aLegendaryPengui> this field is trivial
19:53:53 <aLegendaryPengui> and borin
19:54:04 <shapr> That's not very descriptive.
19:54:08 <aLegendaryPengui> haha
19:54:13 <QtPlaty[1ireMe]> Its a joky term to mean "If you could solve this problem it would be equiverlent to building a true AI)
19:54:16 <Pseudonym> Current NLP thinking is that you think of the precise task that you want to do, then come up with the machine learning tools that you need to conquer that specific problem.
19:54:17 <QtPlaty[1ireMe]> "
19:54:39 <aLegendaryPengui> so we need true AI for NLP?
19:54:47 <aLegendaryPengui> like a human
19:54:54 <aLegendaryPengui> wait, humans are dumb too
19:54:58 <Philippa__> shapr: sure it is. It tells us that aLegendaryPengui has attained full self-understanding, and a similar understanding of others, thus rendering communication trivial if tedious
19:55:04 * monochrom is listening to [ John Hughes «Why Functional Programming Matters» 2:15 hughes-why-function.mp3 3.1MB]
19:55:20 <aLegendaryPengui> i just think communication wont exist in the form of language in the future
19:55:20 <Philippa__> shapr: that, or doesn't see the paradox?
19:55:28 <QtPlaty[1ireMe]> For true NLP.  As Pseudonym says you can get away with a usefull approximation without it.
19:55:29 <dolio> He made an audio version of the paper?
19:55:37 <dolio> Is it shouted by Stephen Colbert?
19:55:38 <shapr> Yeah, what?
19:55:40 <shapr> haha
19:55:42 <Pseudonym> aLegendaryPengui has worked out how to transcend Claude Shannon.
19:55:45 <Nafai> shapr!
19:55:51 <shapr> Nafai!
19:55:57 <codebliss> BANG!
19:55:57 <shapr> Wassup? How's code?
19:56:04 <shapr> codebliss!
19:56:09 <shapr> Wait, that's not my name!
19:56:10 <Nafai> shapr: Not bad, working on some Python stuff for work at the moment
19:56:13 <Pseudonym> Finite channel capacities are so 1940s.
19:56:14 <codebliss> *heavenly music*
19:56:28 <Nafai> codebliss: Love the nick
19:56:32 <shapr> Nafai: I wrote some IronPython for SharePoint purposes recently, was fun.
19:56:50 <codebliss> =P.  It's my domain.  Bought it and a server last aug and have done barely anything.  Damn you F# WPF and Haskell!
19:56:51 <Philippa__> Pseudonym: maybe he's just so posthuman he wants to mail his mind to people?
19:57:16 <Pseudonym> Why do I get the impression it'd end up in my spam can?
19:57:19 <shapr> codebliss: Clearly you should be writing Haskell & F# to do stuff on your server!
19:57:20 <codebliss> I started php and almost fell asleep every 5 seconds lol.
19:57:23 * inimino tries to avoid a 'return to sender' joke
19:57:25 <shapr> Pseudonym: eww
19:57:26 <codebliss> Working on it =P
19:57:30 <shapr> codebliss: yay!
19:57:42 <monochrom> Sometimes people on #math say "I don't know how to ask my question" and I say "just upload your brain somewhere".
19:57:49 <Pseudonym> shapr: I just noticed that it could get taken another way./
19:57:51 <codebliss> LOL
19:57:59 <jmcarthur> codebliss: have you been eying any of our web frameworks?
19:58:05 <aLegendaryPengui> dont you feel that this is all limited though, everything there is
19:58:11 <aLegendaryPengui> its like we are primitive
19:58:23 <aLegendaryPengui> god
19:58:26 <codebliss> jmelesky: I just heard of haskell 4 days ago, give me some time lol
19:58:42 <jmcarthur> codebliss: i assume you meant that for me? ;)
19:58:58 <codebliss> jmelesky: That's why I coloned your name?  XD
19:59:06 <monochrom> And sometimes conversely if someone says "I don't get monads" I may say "do you have a socket on your head? I can just plug a chip and download it to your brain".
19:59:06 <jmcarthur> that's not my name :P
19:59:13 <codebliss> Oh
19:59:16 <codebliss> *facepalm*
19:59:30 <codebliss> Give me one second to stop rolling on the floor.
19:59:39 <codebliss> K thanks.
19:59:55 <codebliss> jmcarthur: And yes, I will take a look at it =).  Thanks.
20:00:30 <aLegendaryPengui> what kind of systems do you guys write in haskell
20:00:35 <codebliss> What's an english definition for a functor?
20:00:38 <jmcarthur> codebliss: probably the coolest is happstack, but it's also the most brain-mashing
20:00:52 <codebliss> jmcarthur: I'll take that as a challange! =P
20:00:58 <monochrom> xchat has last-spoke-aware nick completion.
20:01:05 <Philippa__> aLegendaryPengui: ones beyond your primitive mind, duh
20:01:07 <Pseudonym> codebliss, a functor is a category homomorphism.
20:01:10 <aLegendaryPengui> like what Philippa
20:01:19 <codebliss> I'm using a web client until I finish my haskell irc program
20:01:23 <codebliss> <3 mibbit
20:01:30 <jmcarthur> codebliss: i hate to say it, but "functor" is abstracted enough that a "plain english" explanation would just be a specific case
20:01:37 <Philippa__> there's no point in my explaining, it'd just be meaningless to you
20:01:44 <aLegendaryPengui> maybe
20:01:49 <codebliss> jmcarthur: Mkay.  I remember a pretty english one that clicked with me, but since forgot
20:01:55 <Philippa__> a stream of gibberish ending "-morphism"
20:02:01 <codebliss> aLegendaryPengui: Need inspiration?
20:02:03 <aLegendaryPengui> are data structures in haskell inherently inefficient
20:02:19 <Pseudonym> Compared to what?
20:02:21 <Pseudonym> Pointers?
20:02:26 <codebliss> aLegendaryPengui: You didn't define the type for maybe in your last statement =P
20:02:30 <jmcarthur> codebliss: some people try to make up some crap about functors and monads being "containers" or "boxes" and whatnot, but don't listen to them. that is in-the-box thinking!
20:02:37 <aLegendaryPengui> yeah
20:02:37 <monochrom> "functor preserves structures" is likely a common English summary.
20:02:47 <codebliss> jmcarthur: I just don't understand fmap XD
20:02:51 <Pseudonym> Data structures in C are inherently inefficient for the programmer implementing them.
20:02:56 <codebliss> jmcarthur: Trying to make a simple int example
20:02:59 <jmcarthur> @instances Functor
20:03:00 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:03:09 <aLegendaryPengui> but i mean using them.. isnt it inefficient to do things that mightb e efficient in C
20:03:24 <jmcarthur> okay maybe that wasn't instructive
20:03:32 <codebliss> C <--------------> Haskell.  Put your slider where you want it.
20:03:53 * jmelesky tunes in
20:03:59 <jmelesky> who called me? whuh?
20:04:00 <shapr> Mine is off the scale to the right.
20:04:02 * monochrom puts slider 5 metres below that.
20:04:16 <codebliss> jmelesky: I meant to mean jmcarthur =P
20:04:23 <jmcarthur> codebliss: fmap :: Functor f => (a -> b) -> (f a -> f b) -- that is basically all you need to know. i know it's a brain tease, but as you learn more and more examples you will gain an intuition
20:04:35 <codebliss> jmcarthur: Mkay.
20:04:43 <jmelesky> ah. s'okay. back to sleep for me. :)
20:04:52 <codebliss> jmelesky: My bad lol XD
20:04:56 <Philippa__> jmcarthur: it's not. You also need to know that fmap f . fmap g = fmap (f . g)
20:04:58 <monochrom> LKay, MKay, NKay
20:05:22 <sclv> understanding what "structure" means in haskell/mathy usage was a big "aha" for me, thinking back.
20:05:25 <codebliss> Philippa__: Weird how I know random information like that but not actually what it does lol
20:05:27 <jmcarthur> Philippa__: sure, but it helps that it's hard to think of a useful definition for fmap that *doesn't* satisfy that
20:05:29 <Philippa__> codebliss: "like map, only more general" will do
20:05:40 <jmcarthur> ^^++
20:05:40 <Philippa__> jmcarthur: so think of some stupid ones?
20:05:41 <codebliss> Philippa__: So map for monads?
20:05:50 <sclv> structure is a very slippery concept.
20:05:54 <Philippa__> codebliss: all monads have it, yeah. But other things do too
20:06:12 <codebliss> Isn't map a child of fmap?
20:06:18 <codebliss> Not the other way around?
20:06:20 <Philippa__> 'child'?
20:06:23 <codebliss> I remember that from a day or two ago
20:06:28 <jmcarthur> map is an example of fmap
20:06:28 <codebliss> Basically an instance of
20:06:36 <codebliss> map can't define fmap but fmap defines map
20:06:40 <codebliss> That works, "example"
20:06:49 <Philippa__> right, map is the fmap on lists
20:06:50 <codebliss> map is fmap for the [] monad right?
20:06:51 <jmcarthur> that explanation loses me
20:06:54 <codebliss> WOOT
20:06:56 <jmcarthur> right
20:07:21 <jmcarthur> codebliss: in the case of fmap, we generally call the structure a functor. all monads are functors, but not all functors are monads
20:07:21 <aLegendaryPengui> how is GUI programming in haskell
20:07:22 <codebliss> I was about to say WOOTS++ but that's nowhere near functional lol
20:07:32 <aLegendaryPengui> is it rough
20:07:35 <codebliss> aLegendaryPengui: gtk2hs
20:07:45 <jmcarthur> aLegendaryPengui: it is no harder or easier than in any other language, really
20:07:46 <Nafai> aLegendaryPengui: I've done a bit with gtk2hs and I liked it
20:07:56 <aLegendaryPengui> oh, cool
20:08:12 <aLegendaryPengui> is real world haskell a good book to learn from
20:08:14 <jmcarthur> some of us are trying to research ways to make it nice and declarative though :)
20:08:18 <codebliss> I love this channel.
20:08:19 <QtPlaty[1ireMe]> codebliss: Sure it is.  That returns a function that prepends WOOT to things.
20:08:26 <jmcarthur> @quote passe
20:08:26 <codebliss> LOL
20:08:27 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
20:08:27 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
20:08:30 <codebliss> *facepalm*
20:08:33 <codebliss> hahhahaa
20:08:34 <jmcarthur> @quote passe
20:08:35 <lambdabot> Ethereal says: If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the
20:08:35 <lambdabot> point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
20:09:14 <jmcarthur> aLegendaryPengui: RWH is good, yes :)
20:09:24 <aLegendaryPengui> then what do you build
20:09:27 <monochrom> > map ("hello"++) ["x", "y", "z"]
20:09:28 <lambdabot>   ["hellox","helloy","helloz"]
20:09:29 <jmcarthur> @where lyah
20:09:29 <lambdabot> www.learnyouahaskell.com
20:09:36 <jmcarthur> ^^ is also pretty good
20:09:39 <mmorrow> codebliss: a functor is like an analogy between two analogies
20:09:42 <jmcarthur> depending on your taste
20:09:44 <aLegendaryPengui> thats a nice elephant
20:09:50 <aLegendaryPengui> wow
20:09:54 <monochrom> hahahaha mmorrow
20:10:10 <codebliss> mmorrow: It's not late enough for me to get that XD
20:10:22 <codebliss> I have a visual basic gui class tomorrow.
20:10:29 <codebliss> I've done everything in recursion since lol
20:10:32 <jmcarthur> codebliss: VB ew
20:10:36 <aLegendaryPengui> wtf VB
20:10:39 <aLegendaryPengui> drop that class
20:10:40 <codebliss> I try to survive it XD
20:10:44 <aLegendaryPengui> dont do it man
20:10:50 <aLegendaryPengui> youll ruin your coding
20:10:51 <codebliss> Would you like my story?
20:10:58 <aLegendaryPengui> do it
20:11:06 <aLegendaryPengui> @where story
20:11:06 <lambdabot> I know nothing about story.
20:11:12 <codebliss> I'm in highschool but I have 43 college credits for free.  That's the only programming class.
20:11:20 <aLegendaryPengui> wtf 43 college credits
20:11:21 <jmcarthur> VB won't ruin your programming. VB loving peers will.
20:11:21 <jfredett> Yay, my very 3rd package on hackage! http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HCard !
20:11:22 <codebliss> So really, I might as well take it.
20:11:26 <sclv> @remember mmorrow a functor is like an analogy between two analogies
20:11:26 <lambdabot> Nice!
20:11:26 <codebliss> Yep.
20:11:31 <aLegendaryPengui> what does that mean
20:11:36 <aLegendaryPengui> you take 43 credits before going into college
20:11:38 <codebliss> 43 credit hours.
20:11:47 <aLegendaryPengui> 43 credit hours of college in 1 semester
20:11:52 <jmcarthur> when i was in high school i signed up for a java class but ended up teaching html to my classmates instead :(
20:11:53 <codebliss> No lol
20:12:03 <aLegendaryPengui> you're young codebliss
20:12:05 <jfredett> thats ~ 12 classes, no? pretty good.
20:12:05 <aLegendaryPengui> wtf
20:12:06 <codebliss> I started summer before junior year.
20:12:26 <jmcarthur> at the time i really wanted to learn java
20:12:41 <aLegendaryPengui> whenever you take a programming course, never listen to what your professor says
20:12:43 <codebliss> I started F# about 6 months ago.  Since then I now hate most imperative..
20:12:46 <aLegendaryPengui> they'll make you dumber
20:12:59 <jfredett> jmcarthur: we're glad you recovered and returned to the side of Awesome.
20:13:00 <jmcarthur> aLegendaryPengui: i agree, but they will also hate you for correcting them all the time
20:13:12 <aLegendaryPengui> yeah, i just played the computer during those type of classes
20:13:14 <sclv> there are lots of good professors, wtf.
20:13:16 <codebliss> FunctionalProgramming :: BrainPower -> AwesomeCode
20:13:17 <jmcarthur> jfredett: this was quite long ago ;)
20:13:17 <aLegendaryPengui> naw man
20:13:22 <aLegendaryPengui> professors arent software engineers
20:13:27 <aLegendaryPengui> they'll teach you bad programming skills
20:13:28 <jfredett> jmcarthur: still.
20:13:36 <aLegendaryPengui> then they tell you write a comment per line of code, like idiots
20:13:43 <codebliss> ImperativeProgramming :: () -> FastUglyCode
20:13:48 <sclv> they'll also teach you about balanced trees and big O complexity and things, if you don't know them.
20:13:48 <codebliss> LOL
20:13:54 <codebliss> Takes a unit, no knowledge at all =P
20:13:57 <aLegendaryPengui> so will introduction to algorithms
20:14:01 <aLegendaryPengui> thats a good book
20:14:04 <jmcarthur> aLegendaryPengui: imagine my reaction upon hearing this exact quote: "Haskell is just weird." ... then the teacher never talked about haskell again... in a programming languages course
20:14:06 <codebliss> Oh whoops, this is haskell.  Can omit unit.
20:14:12 <aLegendaryPengui> HAHA
20:14:23 <aLegendaryPengui> that means the professor probably didnt understand i
20:14:24 <jberryman> what library would people recommend for creating a simple dot plot? quite a few packages on hackage, and not much documentation
20:14:28 <QtPlaty[HireMe]> jmcarthur: Well Haskell is weird.
20:14:30 <aLegendaryPengui> or know anything about it
20:14:39 <jmcarthur> aLegendaryPengui: she didn't understand anything besides fortran
20:14:43 <aLegendaryPengui> wtf
20:14:44 <codebliss> So.  My professor's name is brandon, and so is mine.  When there's a question they yell brandon, and whoever is closer goes
20:14:52 <aLegendaryPengui> how can you teach programming languages without talking about functional languages
20:14:56 <codebliss> Also, I have a professer who thinks F# will die, and a kid going to MIT who hates high level
20:15:07 <aLegendaryPengui> wtf, why would you hate high level
20:15:10 <aLegendaryPengui> dumb kid
20:15:11 <codebliss> By high level I mean true high level
20:15:14 <codebliss> As in > ASM
20:15:16 <jmcarthur> she tried teaching some scheme and prolog, but it was basic stuff like arithmetic. nothing about the peculiarities of the languages
20:15:22 <aLegendaryPengui> i wouldnt call C high level
20:15:25 <aLegendaryPengui> or C++
20:15:32 <codebliss> The real definition says C is high level
20:15:34 <codebliss> I think that's dumb
20:15:36 <aLegendaryPengui> maybe that mit kid just likes hardware
20:15:37 <codebliss> But whatever lol
20:15:40 <jmcarthur> C ain't high level
20:15:42 <aLegendaryPengui> or lieks to waste time
20:15:47 <sclv> this is really not a haskell discussion.
20:15:54 <Philippa__> codebliss: the original definition. Doesn't make it the 'true' definition
20:15:58 <codebliss> =P
20:16:05 <aLegendaryPengui> C, 0 is false anything else is true, thats not high level at all
20:16:10 <aLegendaryPengui> lol
20:16:16 <jmcarthur> sclv: What? Anti-other-languages isn't Haskell?! :P
20:16:18 <codebliss> But regardless, ya.  I'll probably be running ghci as much as possible during class to cleanse my soul.
20:16:26 <sclv> jmcarthur: I would hope not.
20:16:31 <aLegendaryPengui> steven mcconell will teach you good programming skills
20:16:38 <aLegendaryPengui> and that refactoring guy
20:16:46 <jmcarthur> Martin Fowler?
20:16:48 <aLegendaryPengui> yeah
20:16:49 <allbery_b> codebliss: you don't know from "brandon" confusion. I was in my mid 20s when 90210 made it go from un-heard-of to common :)
20:16:50 <aLegendaryPengui> lol
20:16:52 <jmcarthur> yeah, good stuff
20:16:53 <codebliss> Brian Beckmen @ channel9.msdn.com is cool.  Also erik.
20:17:13 <codebliss> allbery_b: lol XD
20:17:44 <aLegendaryPengui> i see college as a way to get accredited more than to learn anything
20:17:59 <jmcarthur> in the interest of keeping #haskell on topic, i'm going to another workspace
20:17:59 <aLegendaryPengui> i mean, you could just pick up books and read them imo, and its more useful than 50 minute classes
20:18:12 <codebliss> If it makes any of you happy, I only care about learning.  Honestly I don't give a shit about grades, and that's what got me into Honors College.
20:18:28 <codebliss> The CS Chair shares views with me, he said "I took the words out of his mouth"
20:18:33 <aLegendaryPengui> what is honors college
20:18:37 <codebliss> It was a huge gamble, and a dumb one at that XD
20:18:44 <sclv> guys, take it to #haskell-blah please.
20:18:51 <codebliss> Just harder classes, first class selection, and special diploma honors.
20:19:03 <codebliss> sclv: Got a question?  I will shut up the second you do =)
20:19:11 <jmcarthur> codebliss: you are a phd in the making
20:19:18 <aLegendaryPengui> haha
20:19:26 <codebliss> jmcarthur: sarcasm much?
20:19:29 <monochrom> No, people prefer a channel silent when nothing happens.
20:19:38 <jmcarthur> no sarcasm here
20:19:38 <codebliss> Well then I'm silent.  Boom.
20:19:47 <aLegendaryPengui> where are you going to college
20:21:09 <codebliss> Spend money to make money
20:22:13 <aLegendaryPengui> you could probably go to any school though
20:22:28 <aLegendaryPengui> what CS program are you gonna do
20:24:02 <aLegendaryPengui> ok back to haskell discussion, who drew this elephant http://www.learnyouahaskell.com/
20:24:13 <aLegendaryPengui> i want to get a wallpaper like that
20:24:17 <pumpkin> BONUS
20:24:18 <jmcarthur> BONUS did, i think
20:24:23 <aLegendaryPengui> its really nice
20:24:31 <aLegendaryPengui> its like a futuristic elephant or something
20:24:45 <aLegendaryPengui> where they have custom keyboards they can step on
20:25:21 <codebliss> aLegendaryPengui: Programming CS.  www.uakron.edu
20:30:10 <codebliss> Is the IO functor a transformation in state?
20:30:45 <pumpkin> @src IO
20:30:45 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:31:02 <pumpkin> omg IO encapsulates the universe
20:31:03 <liyang> (Yes, it transforms the RealWorld.)
20:31:08 <sjanssen> why does lambdabot have ops?
20:31:22 <monochrom> No, the IO functor transforms return values.
20:31:50 <codebliss> I'm confused on what functors exactly are.  Looking at http://en.wikibooks.org/wiki/Haskell/Category_theory and taking with jmcarthur
20:32:10 <dolio> They're maps between categories.
20:32:27 <codebliss> Mkay, good one.
20:32:37 <dolio> That preserve identities and composition.
20:32:50 <dolio> Or respect, or whatever.
20:32:55 <monochrom> getLine reads you a line. fmap length getLine still reads you a line, that side-effect of reading is not transformed, but it returns the length of the line instead, that return value is transformed.
20:33:05 <codebliss> kk
20:34:27 <shapr> codebliss: Why do people say kk instead of ok?
20:34:48 <monochrom> sometimes it's nkay, too.
20:34:55 <codebliss> I don't know, been saying it online since I was a little nipper lol
20:34:57 <Nafai> I've always wondered that
20:35:17 <codebliss> On the internets some seek originality.  Maybe okay wasn't fun enough and they wanted to say it twice?
20:35:23 <codebliss> Way back when lol.
20:35:34 <codebliss> lol caught on.  kk caught on.  rofl caught on.  Just happens =(
20:36:01 <shapr> Yeah, but lol and rofl are acronyms... what's kk?
20:36:11 <codebliss> Does this breakdown make sense?   head <$> System.getArgs          fmap ([a] -> a) (IO [Char])          IO Char
20:36:18 <shapr> codebliss: How long since you were a nipper? :-)
20:36:25 <codebliss> kay kay.  (okay - o) * 2
20:36:26 <codebliss> lol
20:36:27 <shapr> The oldest person I know who says that is 24
20:36:31 <monochrom> kk is saying okayokay very quickly.
20:36:34 <codebliss> I'm 17 lol
20:36:38 <shapr> Ah, I see.
20:36:54 <jmcarthur> i think what bothers me more than "kk" is when "lol" is used as punctuation ;)
20:36:58 <shapr> yeah, truly
20:37:03 <codebliss> Been on AIM/IRC/ETC (lol etc is now an acronym!) since I was about 8 or 9
20:37:23 <codebliss> kk bothers you?  my b =(
20:37:34 <monochrom> In the days of telegrams they used to say "stop" for punctuation.
20:37:35 <codebliss> It's like...double confirmation! =P
20:37:40 <shapr> I've been using text chat since I was seventeen, so yeah..
20:37:44 <codebliss> hehe, my and my friend did that forever
20:37:49 <jmcarthur> monochrom that is interesting stop
20:37:58 <codebliss> I once spoke haiku-compliant for 6 hours straight.
20:38:02 <shapr> codebliss: No, not saying it bothers me, just curious what/why.
20:38:07 <pumpkin> I was chatting in my mom's womb, so my e-penis is four times as long as all of yours put together
20:38:08 <codebliss> Also did stop to end messages for like 2 weeks
20:38:23 <shapr> codebliss: Interesting :-)
20:38:25 <codebliss> pumpkin:  I'm not at all bragging?  He asked and I answered, lol.
20:38:45 <codebliss> My facebook status was a haiku about me talking in haiku.  Was pretty fun.
20:38:46 <shapr> Ok, lol as punctuation really does bother me.
20:38:53 <shapr> codebliss: That's cute!
20:38:55 <shapr> I like haiku.
20:39:05 <codebliss> 3-5-3 haiku's.  More fun, and make more sense.
20:39:26 <codebliss> 5-7-5 is no fun, and doesn't represent jap's as much as 3-5-3 imo.
20:39:32 <monochrom> 1954 telegram from college kid to mom: "mom I love you stop please send money stop".  2009 version: "mom I love you lol please send money lol"
20:39:47 <codebliss> hahaha
20:39:51 <codebliss> GOOD POINT
20:39:56 <Axman6> heh
20:40:09 <shapr> Has anyone seen an audio tagging lib for Haskell?
20:40:16 <codebliss> I am a victim of that..
20:40:28 <performance> has any one installed HDBC-sqlite3 on vista?
20:42:08 <Nafai> shapr: http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=id3
20:42:15 <Nafai> shapr: :)
20:42:27 <jre2> anyone know where I can find an example of usage or any other sort of documentation for hsgnutls? can't quite figure out how to use it by just the haddocks
20:44:22 <shapr> Nafai: doh, thanks :-)
20:45:10 <Nafai> shapr: Whatcha hacking on? :)
20:45:28 <shapr> Reading tags for ogg & flac
20:46:18 <shapr> It's purely for my own use, but I thought if someone else has already done it, I'll just enhance their code.
20:52:28 <Axman6> "haskell :: Curiosity -> Excitement -> RealitySetsIn -> Frustration -> Rage -> Either (Acceptance -> Fumbling -> Productivity) (Undying Hatred)"
20:52:56 <vav> Axman6: hmm isn't Left the error?
20:52:57 <codebliss> Rofl
20:53:36 <performance> missing one ->
20:54:36 <performance> can both Undying and Hatred be constructors / types?
20:54:48 <Axman6> vav: guess so. i didn't write it. got it from the comments on http://briancarper.net/blog/real-confusing-haskell
20:55:01 <Axman6> performance: yep
20:55:12 <vav> hehehe, it's funnier this way anyway. :-)
20:55:34 <codebliss> The language looks like Japanese emoticons run amuck. If and when I reach the \(^.^)/ operator I'm calling it a day.
20:55:36 <codebliss> LMAO
20:55:58 <performance> codebliss: did you see the operator for bottom?
20:56:11 <codebliss> performance: Just started reading it, 1 sec lol
20:56:51 <codebliss> LOL @ zong_sharo
20:56:55 <codebliss> Good one XD
20:57:38 <codebliss> Haskell does have one HELL of a community I must admit.  Never change, never!
20:58:50 <codebliss> I think I've done CTR+SHFT+T..clear; ghci like 100 times today
20:59:23 <codebliss> Definitely adding a hotkey STOP
21:00:03 <Axman6> @seen dons
21:00:03 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 6h 23m 6s ago.
21:00:03 <codebliss> Is that don syme?
21:00:13 <Axman6> it's Don Stewart
21:00:18 <codebliss> Oh.  Mkay.
21:01:14 <Axman6> @seen dcoutts
21:01:15 <lambdabot> I saw dcoutts leaving #haskell-soc, #gentoo-haskell, #darcs, #haskell, #ghc and #haskell-overflow 2m 14d 22h 31m 34s ago, and .
21:08:15 <BMeph> Donald Bruce Stewart...sounds French. ;p
21:14:27 <sm> does someone have a robust strict version of readFile ?
21:21:05 <codebliss> @hoogle FilePath
21:21:06 <lambdabot> module System.FilePath
21:21:06 <lambdabot> Prelude type FilePath = String
21:21:06 <lambdabot> System.IO type FilePath = String
21:21:36 <codebliss> So readFile :: [Char] -> IO [Char]
21:21:50 <codebliss> What's your problem again?
21:21:54 <codebliss> sm?
21:22:09 <sm> hello codebliss . I found a pretty good-looking one at http://hackage.haskell.org/packages/archive/Hedi/0.1.1/doc/html/src/Main.html#strictReadFile
21:22:16 <Nafai> codebliss: I'm pretty sure that version is lazy IO
21:22:50 <syntaxfree> will someone idle please join -blah? thanks.
21:23:25 * sm . o O strange
21:23:39 <BMeph> Has anyone considered making a Linda package for Haskell? :)
22:23:34 <sm> good night all
22:26:38 <BMeph> Good night, sm
22:26:52 <ghcnoob> Is this channel about Haskell Wexler, cinematographer?
22:27:27 <jmelesky> and the new book: Glorious Haskell Cinematography (GHC for short)
22:29:06 <ghcnoob> I noticed that GHC compiles things with linkage to libdl. Why? What do the produced binaries need to be linked with at runtime that's not apparent from ldd output?
22:29:22 <dolio> It's about Eddie Haskell from Leave It To Beaver.
22:31:30 <jmelesky> ghcnoob: not sure, offhand, sorry.
22:33:58 <Heffalump> I thought basically all C programs link against libdl, but perhaps I'm wrong.
22:39:53 <ghcnoob> Heffalump: no, C/C++ programs I usually compile with GCC aren't linked with libdl, but looking in /bin, I see that a lot of stuff is (weird)
22:41:16 <ghcnoob> ldd /usr/bin/zip  -> no libdl (as an example)
22:45:29 <dolio> Someone in #ghc might know better, if you can get someone to answer there.
22:45:49 <ghcnoob> I didn't realize there was a #ghc
22:46:15 <dolio> It says to ask user questions here, which this may be, but you probably wouldn't bug anyone too much. :)
22:46:43 <ghcnoob> Too late, I already asked there
22:46:51 <dolio> Fortune favors the bold.
22:47:41 <pstickne> dolio:  and so often does Death :)
22:47:57 <dolio> :)
22:49:56 <ghcnoob> What is Haskell's equivalent of Python's "pass" in "do" syntax, i.e. how would you write a "do" block that doesn't do anything?
22:50:53 <Philippa__> return ()
22:51:43 <ghcnoob> Philippa__: thanks
22:51:57 <Gracenotes> you can also write an expression that doesn't do anything conditionally
22:52:16 <Gracenotes> when (a > b) $ print "a > b!"
22:52:19 <Gracenotes> @src when
22:52:19 <lambdabot> when p s = if p then s else return ()
22:52:59 <dolio> ghcnoob: I wouldn't get your hopes up for a prompt answer, by the way. The last thing said by a human being in that channel was 22 hours ago.
22:53:33 <dolio> Oh, my bad, it was 11 hours ago, but it was "hello" followed by silence.
22:54:02 <ghcnoob> How impolite!
22:54:38 <Gracenotes> if all else fails, there is a GHC mailing list; slow but (it seems )reliable
22:55:01 <Gracenotes> http://www.haskell.org/mailman/listinfo/glasgow-haskell-users
23:09:07 <mib_ye8n66> Hi everyone, I've heard "haskell" thrown around a lot. However I'm not really sure what it is or what it does (besides being a programming language). What kind of things can one do with Haskell
23:10:48 <rio> mib_ye8n66: its a pure functional programming language, you can do whatever you like with it
23:12:43 <lpsmith> personally,  I like plotting world domination with Haskell...
23:15:08 <Gracenotes> I've done math in it. Written an IRC client. Simulated a quantum algorithm. A simple Tetris clone. Some automata for my theory of computation course.
23:15:31 <Gracenotes> er... and he's gone
23:15:38 <Gracenotes> other stuff too anyway.
23:15:40 <lpsmith> heh.  I've done a fairly extensive automata library myself.
23:15:42 <ghcnoob> I've heard you can malloc with it. All the shootout entries do.
23:16:08 <Gracenotes> well, hardly *all*. Just when you want to emulate C, perhaps.
23:16:08 <lpsmith> oh yes,  GHC is very good at malloc'ing.   A lot.
23:16:32 <lpsmith> Gracenotes:  did you follow the basic textbook definitions of an automata directly?
23:16:37 <Saizan_> Gracenotes: oooh, an irc client, any published code for that?
23:16:47 <lpsmith> Or did you use a more traditional CS type approach?
23:17:30 <Gracenotes> lpsmith: sort of a mix.
23:17:44 <Gracenotes> for instance... data PDA a s = PDA { pdaTrans :: Set (Trans a s), pdaState :: State, pdaFinal :: Set (State) }
23:17:51 <Gracenotes> data Trans a s = Trans { transState :: (State, State), transChar :: (Maybe a), transStack :: ([s], [s]) }
23:18:02 <Gracenotes> data Config a s = Config [a] [s]
23:18:07 <Gracenotes> data SConfig a s = SConfig State (Config a s)
23:18:17 <Gracenotes> for a non-deterministic PDA
23:18:37 <Gracenotes> hm. pdaState/pdaStart.. should fix that
23:19:03 <lpsmith> lol
23:19:09 * Saizan_ likes to use a zipper with a truly infinite tape for turing machines
23:19:17 <Gracenotes> for DFA: data DFA a = DFA { dStart :: State, dAccept :: Set State, dAlpha :: [a], dTrans :: [[State]] }
23:19:20 <Saizan_> fsvo truly
23:19:36 <lpsmith> Yeah,  mine followed the definitions fairly directly from the textbook,  it worked out quite nicely
23:19:45 <Gracenotes> it gets verbose quickly. But the trans are basically: every item in a list covers transitions for each item in a alphabet
23:19:49 <Gracenotes> for DFA
23:20:00 <lpsmith> all in all,  my library appeared about 18 months before HaLeX,  but HaLeX is definitely more complete
23:20:12 <Gracenotes> so dTrans !! x represents outgoing ocnnections from state x
23:20:24 <Gracenotes> based on an enumeration of the alphabet in dAlpha
23:20:26 <lpsmith> data DFA st ab = DFA (st -> ab -> st) st (st -> Bool)
23:20:39 <Gracenotes> yeah. I hesitated to make functions, actually
23:20:43 <Gracenotes> you can't play with them as much :)
23:20:53 <lpsmith> sometimes
23:21:04 <lpsmith> I didn't really find anything I couldn't do though
23:21:04 <Gracenotes> I plan on making the DFA more concise by adding a universal 'sink state' that failed computations go to
23:21:39 <ghcnoob> Gracenotes: does your Tetris use wxHaskell?
23:21:42 <lpsmith> You can recover your representation from mine by a simple graph reachability algorithm
23:22:06 <Gracenotes> yeah. may as well have all the info though
23:22:15 <Gracenotes> oh, and: data NFA a = NFA { nStart :: State, nAccept :: Set State, nAlpha :: [a], nTrans :: Set (NTrans a) }
23:22:17 <Gracenotes> data NTrans a = NTrans { nFst :: State, nSnd :: Maybe a, nThd :: State }
23:22:28 <Gracenotes> ghcnoob: no, gtk2hs
23:22:46 <lpsmith> also,  "my" representation can be exponentially more compact :-)
23:22:55 <Gracenotes> not in memory :)
23:23:04 <lpsmith> especially in memory
23:24:03 <Gracenotes> well, maybe. But you're still somewhat constrained in modification.
23:24:26 <lpsmith> No,  because I can always drop back to your representation,  if all else fails :)
23:24:31 <Gracenotes> here's one case where I did use a function: data TM a= TM { start :: State, accept :: State, reject :: State, trans :: State -> a -> (State, a, TDir) } But I haven't worked too much with Turing machines; they're rather cumbersome.
23:24:43 <Gracenotes> lpsmith: indeed, and I can easily encode mine in yours
23:24:59 <lpsmith> yup
23:25:11 <Gracenotes> the tape is kept separate from the TM because it's not really static
23:25:14 <lpsmith> that's what I was trying to get at.
23:25:16 <Gracenotes> data Tape a= Tape { leftTape :: [a], focus :: a, rightTape :: [a] }
23:25:26 <lpsmith> I never did turing machines though.   They *are* cumbersome
23:25:27 <Gracenotes> essentially, like Saizan_ said, a zipper
23:26:12 <Gracenotes> Saizan_: oh, and nothing published for the IRC client... I've managed to implement a sendTextToChannel function (or something along those lines) and a sendRaw function
23:26:18 <Gracenotes> and a few others
23:26:32 <Gracenotes> but I have a nice monad transformer stack that's rather flexible
23:26:54 <Gracenotes> to keep track of channel state, handle plugins... I should try working on it again :X
23:29:08 <Saizan_> designing how to handle plugins vs. main loop vs. multiple connections is what blocks me
23:29:36 <Saizan_> also, how to make a sane terminal UI
23:30:03 <Gracenotes> all my state is in two ReaderTs
23:30:24 <Gracenotes> so, I can extract an object (with hidden constructors) to do stuff with the client in a terminal
23:30:38 <Gracenotes> lots of hidden constructors :\
23:30:47 <lpsmith> I've never liked Monad Transformers
23:30:52 <lpsmith> I mean, they are ok
23:31:03 <lpsmith> They've helped my understanding of Monads immensely
23:31:13 <lpsmith> But I've never liked them
23:31:17 <Gracenotes> oh. heh. I haven't considered multiple connections
23:31:33 <Gracenotes> one connection is: data CState = CState { cstateInfo :: (String, Int), cstReadChan  :: Chan String, cstReadThread  :: ThreadId, cstWriteChan :: Chan String, cstWriteThread :: ThreadId, cstSocket :: Handle }
23:31:59 <Gracenotes> having two threads per connection doesn't really scale. even if they just mostly sit around.
23:32:15 <Gracenotes> you'd need some sort of non-blocking I/O for high scalability
23:32:18 <Saizan> why not?
23:32:19 <lpsmith> (As for exponentally smaller automata,  consider creating an automata that decides if the n^th from the last character is a given character
23:32:37 <Gracenotes> well. I suppose everything doesn't scale eventually.
23:32:38 <Saizan> the RTS can handle millions of threads
23:32:56 <Gracenotes> uh... X.X I guess they're pretty lightweight then.
23:32:57 <Saizan> i don't plan to have millions of irc connections open..
23:33:24 <Gracenotes> are they green threads, by chance?
23:33:29 <Saizan> yeah, they are userland threads, which use non-blocking I/O under the hoods
23:34:04 <ManateeLazyCat> I have below function, have a exist function do same thing? I mean built-in GHC
23:34:04 <ManateeLazyCat> justMaybe :: Maybe a -> a
23:34:04 <ManateeLazyCat> justMaybe o =
23:34:04 <ManateeLazyCat>   case o of
23:34:07 <Gracenotes> well, in that case, I can have a Map String CState, I suppose, for multiple connections
23:34:17 <Saizan> you can control the number of OS threads passing +RTS -Nn
23:34:28 <ManateeLazyCat>     Just object -> object
23:34:28 <ManateeLazyCat>  
23:34:28 <ManateeLazyCat> Thanks!
23:34:40 <Gracenotes> or maybe some kind of zipper in the MVar that references other servers
23:34:50 <Saizan> ManateeLazyCat: fromJust
23:35:26 <Saizan> ManateeLazyCat: however best to use a pastebin (like hpaste.org) for pasting multiple lines next time
23:35:34 <Gracenotes> I do have a useful typeclass, I think: class Monad m => MonadFork m where fork :: m () -> m ThreadId
23:36:13 <Saizan> Gracenotes: with which instances?
23:36:25 <Gracenotes> basically only useful for MonadIO'd ReaderTs... but the ReaderT themselves are hidden beneath hidden constructors
23:36:51 <ManateeL`> Saizan: Just fine line.
23:36:52 <ManateeL`> five
23:37:12 <Gracenotes> instance MonadFork (ReaderT s IO).. instance MonadFork (ReaderT s Connection).. instance MonadFork (ThreadState s Connection)..  and a derived instance
23:38:09 <Saizan> ah, k
23:39:12 <ManateeL`> Saizan: So you know have exist function that built-in GHC like my `justMaybe', i found `justMaybe' is handy for handle Maybe monad.
23:39:21 <ManateeL`> Saizan: And i will paste multi-line with link next time.
23:39:43 <Saizan> ManateeL`: yes, fromJust
23:39:54 <Saizan> ManateeL`: in Data.Maybe
23:39:57 <Gracenotes> Saizan: here's a sample program.. actions2 :: IRC Int (); actions2 = do { configIRC nick; joinChannel chan; foreverBack $ \ctx src msg -> when (":(" `isInfixOf` msg)  $ do { num <- getSt; sendToTarget ctx ("You're the #" ++ show num ++ " sad person yet, " ++ src ++ " :("; putSt (num+1) } }
23:40:02 <Gracenotes> and to run it, runIRC' ("localhost", 6667) 1 actions2
23:40:22 <Gracenotes> (I have an ssh tunnel from localhost to freenode)
23:41:01 <ManateeL`> Saizan: Oh, thanks, i create it again. :)
23:42:18 <Saizan> Gracenotes: i see
23:42:24 <Saizan> ManateeL`: np
23:47:43 <Saizan> Gracenotes: i think you should put MonadFork and ThreadState in a library somewhere, it's one of those monads often needed also for GUI programming that i've not seen anywhere
23:48:18 <Saizan> like "i want to use StateT but gtk2hs uses callbacks"
23:48:41 <Gracenotes> mm. in this case: newtype ThreadState s m a = MkThreadState (ReaderT (MVar s) m a)
23:48:53 <Gracenotes> pretty simple
23:49:27 <Saizan> yeah, but there's no reason we shouldn't package it up, instead of reinventing/reexplaining
23:50:27 <Saizan> you could also make instances for InterleavableIO
23:50:32 <Gracenotes> mm. Yeah. I also did make a MonadState instance.. which made me somewhat annoyed that modify wasn't a class method :)
23:50:48 <Gracenotes> it's on the sidelines
23:51:22 <Gracenotes> hm. InterleavableIO... *reads docs*
23:52:44 <Saizan> the haddocks look a bit confusing (to me at least), but the concept is that most monads can be "tunnelled" though IO, so that you can use them with functions that accept only IO callbacks, like forkIO or catch..
23:53:42 <Saizan> uhm, so maybe it subsumes MonadFork?
23:53:43 <Gracenotes> mm.
23:54:18 <Gracenotes> uh. perhaps.
23:55:02 <Gracenotes> hm. the instances look a bit complicated. Seems infectious :)
23:56:23 <Saizan> heh, they have to tunnel all the stack :)
23:58:07 <mib_i1xwpz8z> I'm a Haskell newbie.. I have a question.. testing to see how this works.
23:58:36 <Philippa__> well, you're on IRC
23:59:07 <Philippa__> probably not the best time of day for it though - myself, I really should've slept by now
23:59:34 <mib_i1xwpz8z> How do I match an empty ByteString.Char8 in a case statement?
