00:00:32 <Axman6> @src Enum
00:00:32 <lambdabot> class  Enum a   where
00:00:33 <lambdabot>     succ                     :: a -> a
00:00:33 <lambdabot>     pred                     :: a -> a
00:00:33 <lambdabot>     toEnum                   :: Int -> a
00:00:33 <lambdabot>     fromEnum                 :: a -> Int
00:00:34 <lambdabot> [3 @more lines]
00:00:40 <Axman6> @more
00:00:41 <lambdabot>     enumFrom                 :: a -> [a]
00:00:41 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
00:00:41 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
00:02:27 * copumpkin tries to make his folds Applicative instances
00:04:28 <Axman6> class Copumpkin a where copumpkin :: Princess -> a -- Cinderella comonad... or something
00:04:43 <Peaker> ivanm: why is installing the headers a stupid solution to missing headers problem?
00:08:04 <ErhardtMundt> hallo
00:08:26 <QtPlaty[HireMe]> ErhardtMundt: Whats up?
00:13:12 <vixey> http://haskell.org/haskellwiki/Simon_Has_Fun
00:13:31 <vixey> just found some nice photos
00:15:00 <Raevel> http://haskell.org/sitewiki/images/e/ef/Spj-has-fun-7.jpg <-- looks computer animated!
00:17:12 <copumpkin> @src ((->)a) (>>=)
00:17:12 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:17:18 <copumpkin> @src ((->)a) join
00:17:18 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
00:17:30 <copumpkin> where are those instances actually defined?
00:17:37 <copumpkin> Control.Monad.Instances doesn't have any code in it
00:17:40 <vixey> @src ((->)e) >>=
00:17:40 <lambdabot> Source not found. Maybe you made a typo?
00:17:46 <Axman6> Data.function maybe?
00:17:46 <vixey> @src >>= ((->)e)
00:17:46 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
00:17:50 <vixey> @src (>>=) ((->)e)
00:17:50 <lambdabot> Source not found. stty: unknown mode: doofus
00:17:53 <vixey> @src (>>=) (->)
00:17:53 <lambdabot> Source not found. My brain just exploded
00:17:58 <Gracenotes> @src (->) (>>=)
00:17:58 <lambdabot> f >>= k = \ r -> k (f r) r
00:17:59 <vixey> @src (->) (>>=)
00:17:59 <lambdabot> f >>= k = \ r -> k (f r) r
00:18:08 <Gracenotes> @src join
00:18:08 <lambdabot> join x =  x >>= id
00:18:45 <idnar> http://haskell.org/sitewiki/images/e/ef/Spj-has-fun-7.jpg looks like something from 2001: A Space Odyssey
00:19:13 <copumpkin> thanks vixey :)
00:19:17 <Gracenotes> in Control.Monad.Instances I see instances for (->) functor, (->) monad, (,) functor, Either functor
00:19:32 <copumpkin> Gracenotes: in the documentation, but I dare you to find the instance in code :P
00:19:40 <vixey> Haskell este limbajul functional succesor al LISP-ului, Scheme-ului si ML-ului !!!
00:19:44 <Gracenotes> copumpkin: I'm talking about the source code
00:19:51 <Gracenotes> GHC's
00:19:55 <copumpkin> Gracenotes: oh you're right
00:21:27 <Gracenotes> I have a cute little directory, merging source trees for base, libraries, mtl, http, parsec, etc.
00:21:39 <Gracenotes> in the hierarchical manner. Makes it easy to find stuff.
00:22:33 <copumpkin> :) nice
00:22:38 <copumpkin> publish it online!
00:23:52 <Gracenotes> 'tis mainly just copying source trees! :o
00:24:08 <Gracenotes> doesn't have C /includes directories or anything
00:25:30 <hotaru2k3> is it really that hard to find "http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Instances.html" and click on the "Source code" link at the top?
00:25:34 <copumpkin> w00t, I have an applicative instance for my folds now
00:25:52 <copumpkin> hotaru2k3: you just had to
00:26:22 <copumpkin> hotaru2k3: I'd be interested to hear what kind of answer you wanted to that question :P
00:27:15 <hotaru2k3> well, i'm wondering how it could be so difficult when it only took me a few seconds
00:27:38 <copumpkin> well if you're really wondering and not just trying to say "RTFM you dumbass"
00:27:55 <copumpkin> it's because typically in documentation with hscolour links, I click on the little source links on the side
00:28:07 <copumpkin> usually, I find the instances next to the class declaration
00:28:14 <copumpkin> so I clicked on the little source links next to the Monad
00:28:18 <copumpkin> and got to GHC.Base
00:28:26 <copumpkin> and found no instance there
00:28:35 <Gracenotes> hotaru2k3: you can also grep local stuff
00:28:48 <copumpkin> since none of the little source links took me to Control.Monad.Instances, I assumed that it contained no actual code
00:28:55 <copumpkin> I have never actually noticed the source button on the top
00:28:58 <copumpkin> *had
00:29:05 <copumpkin> ...there
00:29:34 <copumpkin> was that satisfactory?
00:29:46 <hotaru2k3> yeah, that explains it
00:29:51 <Gracenotes> instance locations are interesting... the module location can be found with :i though in ghci
00:30:09 <copumpkin> :)
00:30:47 <ivanm> Peaker: I was saying it was a stupid solution to automatically suggest apt-get
00:30:56 <Peaker> ivanm: it wasn't automatic, I know da-x
00:31:06 <ivanm> oh, fair enough then
00:31:28 <Gracenotes> :d
00:31:57 <copumpkin> now, I wonder if I can make folds into a monad
00:32:03 <Peaker> I wrote something that I think is nicer than the Iteratee code
00:32:14 <copumpkin> ooh
00:34:00 <Peaker> hpaste is down?
00:34:03 <copumpkin> yeah
00:34:05 <copumpkin> I use moonpatio
00:35:00 <Peaker> I wonder how this compares to Iteratee and ListT: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2230#a2230
00:35:38 <Peaker> will taking up a cabal package name list "MList" for this be too namespace polluting?
00:35:41 <copumpkin> liftM and join aren't in the Monad class? that seems silly
00:36:46 <Gracenotes> fmap fmap fmap fmap fmap fmap
00:37:07 <idnar> Peaker: I don't know about polluting, but that sounds like a pretty awful package name :P
00:37:18 <Peaker> Data.MList
00:37:19 <copumpkin> lol
00:37:27 <Peaker> idnar: And DList is good? :)
00:37:35 <idnar> Peaker: no, that's pretty awful too :P
00:38:48 <Peaker> copumpkin: well, Monad was formulated before the apparent connection to the Functor/Applicative classes.. If it was an Applicative subclass it'd have just join
00:39:41 <copumpkin> Peaker: oh yeah, but in CT people typically express it in terms of join/fmap(liftM)/return, so it seemed more logical for them to start out that way too, whether or not they have a Functor subclass
00:40:01 <vixey> the thing is going via bind is more efficient
00:40:25 <copumpkin> ah yeah, I meant more along the lines of giving you one of those mutually defined set of methods
00:40:27 <vixey> in that.. the induced bind (from fmap and join) is some weird round trip
00:40:28 <copumpkin> like == and /=
00:40:40 <copumpkin> define one of them and the other one comes for free, or define both if you have more efficient ways
00:43:58 <idnar> there should be a way to indicate that you have to override at least one method in a group of methods
00:44:28 <copumpkin> yeah, lots of evil bugs waiting to happen
00:44:32 <idnar> so you get a compile error instead of an infinite loop
00:44:56 <copumpkin> yeah
00:45:27 <dolio> MList is roughly isomorphic to LogicT.
00:50:42 <Peaker> dolio: is it possible to share code, do you think?
00:51:16 <Peaker> I think == and /= are bad examples of "more efficient possible ways" because "not" is so cheap
00:51:49 <copumpkin> well, yeah
00:56:30 <dolio> Peaker: hGetLines could be rewritten in terms of mzero, mplus and lift, I think. The zip I don't think is in logict, but it could be (it'd be specific to the type though, I think).
00:57:10 <Peaker> dolio: I think this is much nicer than the Iteratee, a bit inspired by Python generators, perhaps
00:57:15 <dolio> Most of the other stuff probably already exists.
00:57:32 <Peaker> dolio: I'm now refactoring stuff to be built on top of more fundamental building blocks
00:57:44 <kmeyer> python generators annoy me because they're very different from ordinary python functions and yet they are defined using the same convention
00:57:47 <kmeyer> but otherwise they're powerful
00:59:31 <copumpkin> hmm, so close to making my fold into a monad
00:59:41 <Peaker> kmeyer: that's annoying but its just syntax
01:00:36 <Peaker> dolio: btw, I don't have any backtracking or anything here -- isn't LogicT all about backtracking?
01:01:48 <dolio> With append and (>>=), it's a nondeterminism monad.
01:02:12 <dolio> Backtracking happens due to lazy evaluation, just like the list monad.
01:04:05 <copumpkin> okay, making a Monad on my fold would defeat the point, so I won't
01:04:12 <Peaker> dolio: yeah. I wrote this code a while ago and now I'm re-figuring out parts of it :)
01:09:48 <Renderwahn> http://codepad.org/FlLog4QL why does this fail with "Non-exhaustive patterns in function prefix" for anything where both strings are not empty?
01:09:50 <Axman6> > take 64 [\0..]
01:09:51 <lambdabot>   <no location info>: parse error on input `..'
01:09:55 <Axman6> > take 64 ['\0'..]
01:09:56 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
01:10:27 <bd_> > drop 64 ['\0'..]
01:10:28 <lambdabot>   "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\1...
01:12:24 <copumpkin> meanF = (/) <$> sumF <*> genericLengthF
01:12:32 <Axman6> > text . take 64 $ ['\0'..]
01:12:34 <lambdabot>   !"#$%&'()*+,-./0123456789:;<=>?
01:20:30 <copumpkin> is there such a thing as a cofunctor? :P
01:21:06 <dolio> No.
01:21:17 <copumpkin> didn't think so
01:21:52 <lumi> Wouldn't a confunctor just be a functor again?
01:22:10 <copumpkin> I think so :)
01:22:49 <lumi> iiuc, "co-" means "draw all the arrows backwards"...
01:23:55 <vixey> for every category C you have C^op, any morphism f : A -> B in C has the dual f^op : A <- B
01:24:01 <copumpkin> yeah
01:24:12 <copumpkin> which would essentially mean flip fmap here, right?
01:24:31 <copumpkin> which isn't really any different from fmap
01:26:19 <lumi> cofmap :: (f b -> f a) -> (b -> a) -- ?
01:26:31 <vixey> :t fmap
01:26:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:26:48 <vixey> I think it's: (a -> b) => (f a -> f b)
01:27:01 <vixey> so fmap^op (a <- b) => (f b <- f a)
01:27:22 <lumi> Oh, OK, I flipped too many arrows
01:27:59 <Peaker> @type cofmap
01:28:00 <lambdabot> Not in scope: `cofmap'
01:28:04 <Peaker> @hoogle cofmap
01:28:04 <lambdabot> No results found
01:28:41 <Peaker> I thought cofunctor did exist: class Cofunctor f where (a -> b) -> f b -> f a
01:28:49 <Peaker> where cofmap :: ... that is
01:29:05 <dolio> It might, but that's not a name you'll find in category theory.
01:29:13 <copumpkin> how does that differ from Functor ?
01:29:22 <copumpkin> oh f b -> fa
01:29:33 <copumpkin> how would that work?
01:29:36 <dolio> That's a contravariant functor.
01:29:37 <Peaker> dolio: ah, it apparently is a semi-known Haskell class
01:29:54 <Peaker> copumpkin: for example, cofmap = flip (.)
01:30:06 <Peaker> @type flip (.)
01:30:07 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
01:30:19 <dolio> Which is a name you might find in categorty theory, but a contravariant functor from C to D is a covariant functor from C^op to D.
01:30:52 <dolio> But it isn't the categorical dual of a functor, so prefixing with co- doesn't really fit the usual pattern.
01:30:52 <copumpkin> Peaker: I don't follow
01:31:25 <Peaker> copumpkin: if a function (a->) is a Functor (on its result), then a function (->b) is a cofunctor (on its arg
01:31:46 <Peaker> copumpkin: fmap applies a function to a function's result.  cofmap applies a function to a function's arg
01:32:07 <copumpkin> yeah, but I don't get  (a -> b) -> f b -> f a that you wrote up there
01:32:13 <idnar> dolio: what is the dual of a functor?
01:32:20 <Peaker> copumpkin: f = (->c) there
01:32:38 <dolio> idnar: There isn't one. Or maybe it's functors, I don't know.
01:32:42 <Peaker> copumpkin: note how (B->c) becomes (A->c)
01:33:12 <dolio> idnar: You usually defined duals for constructions within a category, but a functor is a map between two categories, so they're somewhat different.
01:33:27 <copumpkin> Peaker: I understand the type, but don't understand how I could ever write such a thing
01:33:48 <copumpkin> and don't understand how flip (.) would be one :P
01:34:23 <dolio> Like, products are defined via diagrams involving objects and morphisms within a category. So coproducts are what you get when you look at that same diagram in the opposite category.
01:34:29 <Peaker> copumpkin: what do you mean:  class CoFunctor f where cofmap :: (a->b) -> f b -> f a ;   instance CoFunctor (->a) where cofmap = flip (.) -- now this is not really possible to type system limitations, but you could of course have a custom data type representing (->b)
01:34:31 <lumi> dolio: Oh, now I understand vixey's => notation
01:35:34 <copumpkin> so that would mean for the -> a instance that we'd get cofmap :: (a -> b) -> (b -> c) -> (a -> c)
01:35:40 <Peaker> copumpkin: data ReverseFunc a b = R (b->a)  -- instance CoFunctor (ReverseFunc a) where ...
01:35:44 <copumpkin> and there I  figured it out, lol
01:35:51 <copumpkin> as I was typing out the question I was going to ask you
01:35:57 <Peaker> copumpkin: :-)
01:35:59 <copumpkin> okay, I get it now :)
01:36:05 <copumpkin> that's kinda neat
01:36:29 <Peaker> @type arg
01:36:30 <copumpkin> is that in category-extras?
01:36:30 <lambdabot> Not in scope: `arg'
01:36:34 <Peaker> not sure
01:36:42 <copumpkin> Peaker: arg as in conal's construction?
01:36:44 <Peaker> @let arg=flip (.) ; result=(.)
01:36:45 <lambdabot>  Defined.
01:37:06 <Peaker> @type (arg . result)
01:37:08 <lambdabot> forall c b c1 a. (b -> c1) -> ((a -> c1) -> c) -> (a -> b) -> c
01:38:22 <copumpkin> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Contra.html
01:39:00 <copumpkin> I could define one of those on my fold
01:39:07 <copumpkin> sounds a little bit like overkill
01:41:37 <Renderwahn> http://codepad.org/FlLog4QL why does this fail with "Non-exhaustive patterns in function prefix" for anything where both strings are not empty?
01:42:18 <copumpkin> what happens when there is only one element in the first string, and the second one is empty?
01:42:43 <xerxes> does a chatbot exist, that is written in haskell or ocaml?
01:42:47 <Renderwahn> shouldn't this be matched by the second pattern?
01:42:52 <copumpkin> Renderwahn: oh you're right
01:45:06 <CerebrosuS> hi @ all
01:47:51 <voker57_> let conts = catch (ByteString.readFile fname) (\e -> ByteString.Char8.singleton 'no luck')
01:48:32 <voker57_>  Couldn't match expected type `IO ByteString'           against inferred type `ByteString'
01:48:43 <copumpkin> :t catch
01:48:45 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:49:22 <voker57_> do i have to convert ByteString to IO Bytesting somehow?
01:49:34 <voker57_> s/sting/String/
01:49:39 <copumpkin> return
01:49:44 <copumpkin> I guess
01:49:53 <copumpkin> why would you need to catch there though?
01:50:18 <voker57_> in case file doesn't exist, i want to return an arbitrary string
01:50:33 <voker57_> return works
01:50:48 <Peaker> nice, I managed to build some nicer primitives in my MList thing and now the code looks a lot more like the normal list code, except using different primitives
01:51:08 <Peaker> roughly one-to-one translation from @src to MList implementations of (++), concat, sequence, mapM, etc
01:51:18 <copumpkin> voker57_: you have it backwards
01:51:44 <copumpkin> oh wait, no you don't
01:51:54 <copumpkin> I need to go to sleep :P
01:54:07 <Peaker> much prettier MList: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2231#a2231
01:55:39 <copumpkin> that is much prettier
01:56:36 <copumpkin> so what does it do?
01:57:27 <voker57_> let conts = catch (Just (BS.readFile fname)) (\e -> return (Nothing) )
01:57:54 <voker57_> can i do use Maybe like this?
01:58:26 <copumpkin> almost
01:58:33 <copumpkin> you'd need an fmap Just instead of Just
01:58:42 <Axman6> probably don't want the return there right?
01:58:47 <Axman6> :t catch
01:58:49 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
01:59:08 <copumpkin> he does
01:59:09 <Axman6> or maybe you do
01:59:21 <copumpkin> he doesn't need the parentheses around the Nothing though :P
01:59:40 <voker57_> they are left over from something more complex
01:59:51 <smtms> it's less of a Nothing, if it got parantheses
02:01:33 <voker57_> @hoogle fmap
02:01:34 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
02:01:34 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
02:01:34 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
02:04:02 <Renderwahn> nooooooooo, I'm a blind idiot. instead of prefix I wrote prexix and I didn't see it
02:04:08 <Peaker> copumpkin: it seems my prettification broke something in there, so currently it does nothing :)   But in general - its basically like Iteratee
02:04:29 <Peaker> copumpkin: its a list that is allowed to have monadic effects in order to fetch the continuation of the list
02:04:40 <copumpkin> hmm fun
02:04:51 <Peaker> copumpkin: has the ordinary list operations, all of the results of which are in monads, accordingly
02:04:58 <copumpkin> so like an unsafeInterleaveIO that you have control over?
02:05:04 <Peaker> copumpkin: I intend for this to be a useful replacement for that, yeah
02:05:09 <Peaker> copumpkin: I hate lazy I/O :)
02:05:22 <copumpkin> yeah, I feel uncomfortable using it
02:05:49 <Peaker> copumpkin: so I have, for example, hGetLines which gives you an MList IO String -- and hopefully you'll be able to use it almost as conveniently as [String] but iterating it has to be inside IO
02:06:19 <copumpkin> now we just need that fancy à la carte IO that dolio pasted the other day ;D
02:06:45 <Peaker> what's that?
02:07:00 <copumpkin> have you read the data types à la carte paper?
02:07:09 <dolio> It occurred to me that that was probably a coproduct-of-monads sort of thing.
02:07:40 <copumpkin> what's a coproduct?
02:08:25 <vixey> the product X of A and B is defined by pi1 : X -> A ; pi2 : X -> B.. the coproduct is defined by nu1 : X <- A ; nu2 : X <- B
02:08:38 <vixey> so pi1 = fst ; nu1 = Left etc
02:08:50 <copumpkin> ah
02:08:52 <dolio> Each IO-with-additional-state can be translated into operations in StateT (combined-state-goes-here) IO, which you can use as the target for your coproduct extraction.
02:09:03 <copumpkin> I see
02:09:07 <vixey> (defined by meaning there some nice universal property about these morphisms)
02:09:30 <dolio> copumpkin: http://www.cs.nott.ac.uk/~nxg/papers/icfp02.ps.gz
02:10:15 <copumpkin> thanks :)
02:11:54 <dolio> Anyhow, the paper pitches monad coproducts as an alternative to transformers, but when I recently re-read it, I came to the conclusion that they don't work that way very well, since you need to already have a monad with all the capabilities you want to use to make practical use of the coproducts.
02:12:41 <dolio> However, since with specialized IO-with-extra-global-variables monads you have such a thing with StateT whatever IO, you can make use of them there.
02:12:43 <copumpkin> wasn't that what the à la carte paper was adding to the whole thing?
02:15:03 <dolio> Incidentally, I tried implementing the IO stuff using the free monad over functors, like the Data Types a la Carte paper, but it didn't work very well.
02:15:38 <copumpkin> do you think it would take another extension to make it easy to work with a broken-up IO?
02:15:53 <dolio> Well, I ended up using the prompt monad, which worked fine.
02:15:57 <Peaker> copumpkin: of course eventually I discover I had inserted no bugs, but just had used it incorrectly
02:16:29 <Peaker> I have   mforM_ :: (Monad m, Monad n) => MList m a -> (a -> n b) -> m (n ())   -- and I used this to try to print an IO list in IO, but of course I get IO (IO a) that I forgot to join :)
02:16:46 <Peaker> cool, mlist works :)
02:16:57 <Peaker> now I need to see if I can really replace lazy I/O with it, everywhre
02:18:13 <Peaker> well, writing new I/O-generating mlists is still ugly, need to figure out a way to make that pretty
02:18:44 * DrSyzygyFR read the HWN.
02:19:38 <DrSyzygyFR> fix error ... indeed!
02:21:45 <Peaker> cool, this isn't so bad: linesMList = while (fmap not $ hIsEOF handle) (hGetLine handle)
02:21:50 <Peaker> :-)
02:22:17 <copumpkin> :o
02:22:56 <Peaker> the type system doesn't really warn you when you have IO (IO a) instead of IO a -- makes it easy to forget the join there, inside do blocks
02:23:13 <copumpkin> yeah, that can be annoying
02:24:35 <Peaker> I'm renaming all my mStuff :: ... m (n ..)   to mnStuff :: ... and will put an mStuff = join $ mnStuff   -- to obscure these so you don't use them unless you must
02:24:45 <Peaker> I think mn prefix makes it clear :)
02:25:33 <copumpkin> onoes
02:25:36 <copumpkin> no prefixes kthx
02:25:41 <copumpkin> suffixes only D:
02:25:51 <copumpkin> use a P suffix for Peaker ;)
02:26:03 <Peaker> copumpkin: why suffix?
02:26:15 <Peaker> its not mSomething as in somethingM (monadic) its mSomething as in MList
02:26:25 <copumpkin> dunno :P I've spent too much time working with uvector and am used to odd suffixes :P
02:26:27 <Peaker> mSequence is like sequence but not quite sequence (the result is monadic)
02:27:14 <voker57_> how to extract value from Maybe?
02:28:28 <dolio> Match against it.
02:28:31 <copumpkin> voker57_: either use fromJust (not recommended), fromMaybe, maybe, or pattern match
02:28:33 <lilac> @type fromMaybe
02:28:34 <lambdabot> forall a. a -> Maybe a -> a
02:28:43 <copumpkin> voker57_: or use the fact that it's a Functor, Applicative, or Monad
02:28:43 <Peaker> I like maybe
02:28:51 <copumpkin> is that enough options?
02:28:53 <dolio> Yeah, maybe is good, too.
02:29:10 <Peaker> copumpkin: your last one sounds a bit too advanced an answer for the question
02:29:17 <voker57_> i think so
02:29:39 <lilac> voker57_: the answer is, it depends what you want to do with it... :)
02:30:15 <copumpkin> Peaker: but I left out the MonadPlus :P
02:30:43 * copumpkin invents a new class, MonadMinus
02:30:52 <Peaker> voker57_: is the result of your computation on the Maybe also a Maybe value?
02:31:17 <voker57_> let b = Just 2
02:31:50 <voker57_> fromMaybe b => No instance for (Show (Maybe (Maybe Integer) -> Maybe Integer))
02:32:35 * voker57_ thinks he is doing something wrong
02:35:57 <Peaker> If I unknowingly wrote LogicT's Monad instance in my MList that would be funny because I thought I hadn't understood LogicT
02:36:13 <Peaker> and I think I did actually write it - and in a completely different context
02:39:21 <dolio> Well, the difference is that LogicT uses continuation passing instead of building an algebraic data type.
02:40:12 <dolio> Which can be a bit trickier to think about.
02:42:12 <Peaker> ah
02:42:52 <Peaker> git clone git://github.com/Peaker/mlist.git :)   I'm slowly converting this to something I can cabalize
02:43:01 <Peaker> I'm pretty sure its worth cabalizing by now
02:43:03 <dolio> But it's the same as the difference between using "data [a] = [] | a : [a]" and "data [a] = Build { fold :: forall r. (a -> r -> r) -> r -> r }"
02:43:58 <dolio> And the second should probably be newtype, since then you get fold/build fusion "for free".
02:44:34 <Peaker> every ADT can be replaced with its catamorphism, no?
02:45:17 <dolio> Yeah, although figuring out the catamorphism for, say, nested types might be tricky.
02:46:11 <dolio> It's been a while since I read Initial Algebra Semantics are Enough!, so I don't remember how those turn out.
02:47:42 * copumpkin snores loudly
02:47:50 <copumpkin> night :P
02:54:52 <Peaker> ok, the main difference between lazy I/O and my MLists, is that lazy I/O caches the results in the resulting data structure, whereas my MList will re-execute the actions whenever it is iterated. Not sure which is a better approach, but I tend to think caching is a separate problem that can be solved by other combinators
02:59:01 <ivanm> @yow!!
02:59:01 <lambdabot> I'm totally DESPONDENT over the LIBYAN situation and the price of CHICKEN ...
02:59:38 <Axman6> me too!
03:00:12 <ivanm> I don't care that much about the Libyan situation, but the price of chooks is surely criminal...
03:03:21 <Peaker> ok, my cabal upload of 2KB took more than 40 seconds so I SIGINT'd it
03:03:26 <Peaker> now it says the package is already uploaded
03:03:30 <Peaker> but its not really there
03:04:34 <McManiaC> hey, is there a function to get rid of the "return ()" in "f a >> return ()" with f being of the type "Monad m => m a"?
03:04:36 <stork> sup guise
03:04:39 <Axman6> ust bump the version number
03:05:53 <Axman6> j*
03:06:13 <Peaker> McManiaC: ($>)
03:06:21 <Peaker> @type ($>)
03:06:23 <lambdabot> Not in scope: `$>'
03:06:28 <Peaker> @type (Control.Applicative.$>)
03:06:30 <lambdabot> Not in scope: `Control.Applicative.$>'
03:06:34 <Peaker> @type (Control.Applicative.<$)
03:06:36 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
03:06:54 <Peaker> @hoogle (Monad m) => a -> m b -> m a
03:06:55 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
03:06:55 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
03:06:55 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
03:07:30 <Peaker> McManiaC: you could use <$ because all monads are also functors, but if you're trying to be general to all Monads you might want to write a monadic rather than Functor-based <$
03:07:44 <Peaker> (so you don't get: (Monad m, Functor m) =>    instead of   Monad m =>
03:08:27 <xrfang> hello, is there a type called Ordering in haskell?
03:08:29 <McManiaC> :t void
03:08:30 <lambdabot> Not in scope: `void'
03:08:40 <Axman6> xrfang: yep
03:08:41 <monadic_kid> :t Ord
03:08:43 <lambdabot> Not in scope: data constructor `Ord'
03:08:45 <Axman6> @src Compare
03:08:45 <lambdabot> Source not found. You speak an infinite deal of nothing
03:08:46 <McManiaC> :t Foreign.Marsahl.Error.void
03:08:47 <lambdabot> Couldn't find qualified module.
03:08:48 <Axman6> @src compare
03:08:48 <lambdabot> compare x y | x == y    = EQ
03:08:48 <lambdabot>             | x <= y    = LT
03:08:48 <lambdabot>             | otherwise = GT
03:08:53 <Axman6> :t compare
03:08:54 <Axman6> even
03:08:54 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
03:09:04 <Axman6> @src Ordering
03:09:04 <lambdabot> data Ordering = LT | EQ | GT
03:09:08 <xrfang> Isn't Ord itself a "typeclass"?
03:09:12 <wjt> grgghgh. Gtk Windows don't have Ord
03:09:17 <wjt> so I can't keep a set of them.
03:09:18 <monadic_kid> xrfang: yeah
03:09:39 <xrfang> Enum members are sequentially ordered types — they can be enumerated. The main advantage of the Enum typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the succ and pred functions. Types in this class: (), Bool, Char, Ordering, Int, Integer, Float and Double.
03:09:39 <McManiaC> Foreign.Marshal.Error void :: IO a -> IO () <-- something like this, but why is this in foreign.marshal.error??
03:09:56 <xrfang> So Ordering is a "member" of the Enum typeclass?
03:10:17 <Axman6> yep
03:10:19 <ivanm> Peaker: ping dcoutts
03:10:21 <Axman6> > [LT..GT]
03:10:23 <lambdabot>       Failed to load interface for `LT':
03:10:23 <lambdabot>        Use -v to see a list of the f...
03:10:26 <ivanm> Axman6: lol
03:10:29 <xrfang> and Ordering == Ord?
03:10:30 <Axman6> > [LT .. GT]
03:10:31 <Axman6> -_-
03:10:31 <lambdabot>   [LT,EQ,GT]
03:10:33 <ivanm> @type LT
03:10:33 <xrfang> :t Ordering
03:10:34 <dcoutts> Peaker: upload problems?
03:10:35 <lambdabot> Not in scope: data constructor `Ordering'
03:10:35 <lambdabot> Ordering
03:10:36 <Axman6> xrfang: no
03:10:43 <Axman6> @src Ord
03:10:43 <lambdabot> class  (Eq a) => Ord a  where
03:10:43 <lambdabot>     compare      :: a -> a -> Ordering
03:10:43 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:10:43 <lambdabot>     max, min         :: a -> a -> a
03:10:48 <Axman6> Ord is a class
03:10:50 <Peaker> dcoutts: ah, it seems it did upload, though the command line "cabal upload .." got stuck
03:10:51 <Peaker> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mlist-0.0.1
03:10:51 <Axman6> Ordering is a type
03:11:07 <xrfang> Ordering is similar to Int right?
03:11:12 <dcoutts> Peaker: yeah, we're not quite sure what's going on there
03:11:21 <ivanm> dcoutts: you mean you stuffed something up? :o
03:11:24 * ivanm faints
03:11:28 <BONUS> xrfang: Ordering can take on three values--EQ, LT, GT
03:11:33 <BONUS> equal, greater than, less than
03:11:41 <dcoutts> ivanm: I'm not the author of the hackage server
03:11:49 <xrfang> oh, BONUS, I am reading your tutorial ;)
03:11:53 <ivanm> dcoutts: oh, I thought you meant it was a problem with cabal-install
03:11:55 <ivanm> *phew*
03:12:08 <dcoutts> ivanm: it's not clear if it's the server taking ages or if it's client/server comms that are breaking down
03:12:17 <ivanm> *nod*
03:12:28 <xrfang> a type can belong to 2 or more typeclasses, e.g. Int belongs to Eq, Ord and Bounded etc?
03:12:46 <Axman6> yes
03:12:54 <BONUS> oh hey nice :)
03:13:00 <Peaker> I think it would be good if hackage had some mechanism to mark packages reviewed for lack of malicious content -- I'd be scared to "cabal install" stuff as a company, as pretty much anyone can get a hackage user
03:13:08 <xrfang> sort like the mixin in Ruby... I feel
03:13:10 <BONUS> xrfang: it can also belong to just 1 or no typeclasses at all
03:13:12 <BONUS> but yeah
03:13:29 <xrfang> which type do not have a typeclass? e.g.?
03:13:59 <Peaker> xrfang: data MyNewType = Blah | Bleh | Bluh -- not an instance of any type-class.  *yet*
03:14:05 <BONUS> i dont know, most are in typeclasses
03:14:09 <BONUS> yeah but when you make your own type
03:14:18 <BONUS> its not in a typeclass until you add some deriving clauses
03:14:19 <dcoutts> Peaker: we cannot review everything, however we can make sure that users cannot subvert well-known names. So if you review one version and think the package author is ok then you should be able to have some confidence that subsequent versions by the same author are also ok.
03:14:19 <xrfang> ok, yes thanks
03:14:28 <Peaker> xrfang: I can add an instance for a type-class for any type I want - so all types are potentially members of type-classes
03:14:55 <Axman6> BONUS: or instance clauses of course
03:14:57 <xrfang> *instance* of a typeclass?  well...
03:15:02 <dcoutts> Peaker: we cannot go giving 100% guarantees of things not being malicious. It's too hard. You have to review yourself and take appropriate precautions like for other stuff downloaded from the net.
03:15:27 <Peaker> dcoutts: well, with "apt" I think (maybe incorrectly) that I'm getting reviews from the Debian team
03:15:41 <Axman6> xrfang: like instance Functor Thing where fmap f x = ...
03:15:49 <ivanm> dcoutts: you mean, there might be unsafe functions in hackage packages? :o
03:15:52 <ivanm> :p
03:16:04 <xrfang> Axman6: too advanced for me at this moment ;)...
03:16:10 <xrfang> :t Num
03:16:11 <lambdabot> Not in scope: data constructor `Num'
03:16:12 <dcoutts> ivanm: no, ones that rm -rf your home dir during package compilation
03:16:20 <xrfang> @src Num
03:16:20 <lambdabot> class  (Eq a, Show a) => Num a  where
03:16:20 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:16:20 <lambdabot>     negate, abs, signum     :: a -> a
03:16:20 <lambdabot>     fromInteger             :: Integer -> a
03:16:23 <ivanm> dcoutts: that counts as "unsafe" in my book ;-)
03:16:37 <xrfang> @src Ord
03:16:37 <lambdabot> class  (Eq a) => Ord a  where
03:16:37 <lambdabot>     compare      :: a -> a -> Ordering
03:16:37 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:16:37 <lambdabot>     max, min         :: a -> a -> a
03:16:41 <ivanm> dcoutts: so one way to start would be to be wary of any package that uses a non-standard Setup.[l]hs?
03:16:44 <Axman6> xrfang: Functor is a very nice class to get accquainted with, and a good place to start learning about classes :)
03:16:46 <xrfang> :t 20
03:16:47 <lambdabot> forall t. (Num t) => t
03:16:51 <Axman6> @src Functor
03:16:51 <lambdabot> class  Functor f  where
03:16:51 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
03:16:55 <dcoutts> ivanm: or that use TH
03:17:00 <Axman6> @instances Functor
03:17:01 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
03:17:05 <ivanm> dcoutts: hmmm...
03:17:08 <Axman6> ok.. that's confusing
03:17:09 <dcoutts> ivanm: or a ./configure
03:17:11 <xrfang> I noticed class, I hope to get on it after the LYAH tutorial :)
03:17:15 <ivanm> how does TH do anything?
03:17:20 <xrfang> another question about typeclass
03:17:25 <xrfang> if I do :t 20, it says Num
03:17:26 <ivanm> dcoutts: which packages on hackage use ./configure?
03:17:33 <dcoutts> ivanm: you can do arbitrary IO actions in TH
03:17:33 <ivanm> xrfang: yes
03:17:35 <xrfang> while I think a number,
03:17:38 <ivanm> it's a number
03:17:39 <dcoutts> ivanm: lots of packages use a ./configure
03:17:43 <xrfang> should also belong to Eq, Ord... etc?
03:17:44 <ivanm> but you haven't specified which type of number
03:17:48 <ivanm> dcoutts: *nod* (to both)
03:17:53 <xrfang> :t 20
03:17:54 <lambdabot> forall t. (Num t) => t
03:18:00 <ivanm> dcoutts: though I thought cabal replaced manual ./configure scripts... :s
03:18:09 <ivanm> @src Num
03:18:10 <lambdabot> class  (Eq a, Show a) => Num a  where
03:18:10 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:18:10 <lambdabot>     negate, abs, signum     :: a -> a
03:18:10 <lambdabot>     fromInteger             :: Integer -> a
03:18:19 <xrfang> the command :t is to get type of an expression or typeclass??
03:18:24 <ivanm> xrfang: ^^ all numeric types have to be able to convert Integer values to their own type
03:18:31 <dcoutts> ivanm: well that's why it's not the case that every package has one.
03:18:32 <ivanm> xrfang: gets the type of an expression
03:18:52 <xrfang> so Num is a type or typeclass?
03:18:56 <ivanm> dcoutts: *nod* but if you stick with .cabal for build, then you dn't have that problem, right?
03:18:58 <ivanm> xrfang: typeclass
03:19:02 <xrfang> :t 20
03:19:03 <lambdabot> forall t. (Num t) => t
03:19:12 <ivanm> the type of "20" is t, where t is an instance of Num
03:19:12 <xrfang> it does not say Int ... but Num
03:19:13 <dcoutts> ivanm: and avoid TH, maybe.
03:19:22 <xrfang> :t 20.0
03:19:23 <lambdabot> forall t. (Fractional t) => t
03:19:24 <ivanm> xrfang: because it can be any Num type thanks to fromInteger
03:19:33 <xrfang> hm...
03:19:46 <ivanm> dcoutts: and avoid custom Setup.[l]hs ?
03:19:58 <ivanm> that way, you can almost guarantee that the building of the lib is safe
03:20:05 <xrfang> is there "inheritance" in haskell. e.g. if we know a type is Num it must also a class of Eq.
03:20:09 <ivanm> dcoutts: assuming, of course, that we trust _you_ :p
03:20:11 <xrfang> e.g. Num inherits Eq?
03:20:12 <ivanm> xrfang: yes
03:20:13 <dcoutts> ivanm: I'd have to think about other attack vectors
03:20:23 <wjt> Hmm. <http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/> is great and all, but is only about using Haskell as a better imperative language for writing Gtk applications. I wish something similar existed discussing how to write them in a more functional style
03:20:23 <xrfang> ok, thanks ivanm
03:20:26 <ivanm> @src Num
03:20:26 <lambdabot> class  (Eq a, Show a) => Num a  where
03:20:26 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:20:26 <lambdabot>     negate, abs, signum     :: a -> a
03:20:26 <lambdabot>     fromInteger             :: Integer -> a
03:20:37 <Axman6> xrfang: that's what the first line says, sort of
03:20:38 <ivanm> xrfang: ^^ all instances of Num have to be instances of Eq and Show
03:20:39 <xrfang> class of Eq and Show
03:20:47 <xrfang> but NOT Ord or Bounded?
03:20:54 <ivanm> xrfang: not all Nums are bounded
03:20:56 <Axman6> xrfang: it says that to be a Num instance, it must first me an Eq instance and a Show instance
03:21:06 <ivanm> in practice, I can't think of any that aren't Ord instances
03:21:13 <Axman6> > 2^1234
03:21:15 <lambdabot>   295811224608098629060044695716103590786339687135372992239556207050657350796...
03:21:18 <Axman6> > 2^12345
03:21:19 <lambdabot>   164171010688258216356020741663906501410127235530735881272116103087925094171...
03:21:27 <Axman6> > length . show $ 2^12345
03:21:28 <lambdabot>   3717
03:21:29 <ivanm> xrfang: Integer isn't bounded
03:21:34 <ivanm> Axman6: is that all?
03:21:35 <xrfang> ok,
03:21:37 <ivanm> pfffttt
03:21:40 <xrfang> tks
03:21:40 <Axman6> > length . show $ 2^123456
03:21:42 <lambdabot>   37164
03:21:46 <Axman6> > length . show $ 2^1234567
03:21:48 <lambdabot>   371642
03:21:51 <Axman6> > length . show $ 2^12345678
03:21:59 <monadic_kid> lol
03:22:02 <lambdabot>   3716420
03:22:07 <Axman6> wow, it finished
03:22:12 <Axman6> didn't expect that to work
03:22:47 <ivanm> IIRC, I saw an ultra-condensed Python sudoku app the other day that checked whether each row, etc. has 1..9 by comparing it to some number expressed as a power that had each digit 1, 2, .. 9 exactly once
03:22:51 <monadic_kid> now nested data parallize it and  go nuts
03:23:01 <ivanm> > length . show $ 2^123456789
03:23:05 <ivanm> > length . show $ 2^1234567890
03:23:16 <lambdabot>   thread killed
03:23:20 <lambdabot>   thread killed
03:23:22 <ivanm> :(
03:23:57 <xrfang> @src Eq
03:23:57 <lambdabot> class  Eq a  where
03:23:57 <lambdabot>     (==), (/=)   :: a -> a -> Bool
03:24:04 <xrfang> @src Show
03:24:04 <lambdabot> class  Show a  where
03:24:04 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:24:04 <lambdabot>     show      :: a   -> String
03:24:04 <lambdabot>     showList  :: [a] -> ShowS
03:24:16 <xrfang> @src Num
03:24:17 <lambdabot> class  (Eq a, Show a) => Num a  where
03:24:17 <lambdabot>     (+), (-), (*)           :: a -> a -> a
03:24:17 <lambdabot>     negate, abs, signum     :: a -> a
03:24:17 <lambdabot>     fromInteger             :: Integer -> a
03:24:48 <wavewave> @Data.List
03:24:48 <lambdabot> Unknown command, try @list
03:24:57 <wavewave> @src Data.List
03:24:57 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:26:16 <monadic_kid> is lambdabot on a multi-core/process machine? i mean lets compute powers in parallel and see how high we can go. That should making a boring Sunday fun again
03:26:34 <Peaker> I just had a thought I think is interesting:  If I can view an "interpreter" as a "compiler" whose target language/result value is an (IO Result) value -- is there really an essential difference between an interpreter and a compiler?
03:26:45 <Peaker> And I think there is -- an interpreter is allowed to look at previous execution results, while a compiler is not allowed
03:26:57 <Peaker> so in a sense, an interpreter is monadic, while a compiler is an applicative, or an arrow
03:28:00 <monadic_kid> Peaker: well a multi-stageed interpreter is a compiler
03:28:36 <Peaker> what is a mluti-staged interpreter?  Compile&execute?
03:28:48 <wavewave> every turing complete machine is essentially same.
03:30:19 <Peaker> wavewave: I suppose you're writing this on an XT :)
03:30:41 <Peaker> or actually, there are no turing complete machines at all -- because machines are always finite :)
03:30:44 <monadic_kid> Peaker: multi-stagging is a form of metaprogramming,runtime partial evaluations/ors (not application
03:32:46 <McManiaC> @pl void f = f >> return ()
03:32:46 <lambdabot> void = (>> return ())
03:32:58 <monadic_kid> Peaker: using MetaOcaml/ML or template haskell
03:33:13 <Peaker> @type ($>())
03:33:16 <lambdabot> Not in scope: `$>'
03:33:23 <Peaker> @type (Control.Applicative.$>())
03:33:24 <lambdabot> Not in scope: `Control.Applicative.$>'
03:33:28 <Peaker> @type (()<$)
03:33:29 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
03:33:40 <Peaker> McManiaC: that's one option
03:34:09 <Peaker> monadic_kid: ah. I think I need to think about it more or maybe write some language in the form of an arrow or such
03:34:39 * Peaker urges people to try out http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mlist-0.0.1 and give me feedback -- I aim to get rid of lazy I/O -- could use some git branches with ByteString extensions and stuff :)
03:34:47 <Peaker> bbl
03:35:11 <Axman6> Peaker: announced it on -cafe?
03:35:20 <McManiaC> hmhm
03:35:46 <Zao> Hackage needs an "Author irc nick" field :)
03:36:00 <McManiaC> :D
03:37:15 <wavewave> What is the benefit of replacing lazy I/O?
03:37:54 <xrfang_> but should a Num also a Enum?
03:38:32 <McManiaC> ok thx Peaker :)
03:38:37 <McManiaC> i think i got it now
03:39:01 <Zao> What decides whether there's docs generated on hackage or not? Time? Non-broken haddock comments?
03:39:58 <Axman6> Zao: they're done once a day i think
03:40:04 <xrfang_> @src Integral
03:40:04 <lambdabot> class  (Real a, Enum a) => Integral a  where
03:40:04 <lambdabot>     quot, rem, div, mod :: a -> a -> a
03:40:04 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
03:40:04 <lambdabot>     toInteger           :: a -> Integer
03:40:21 <xrfang_> @src Floating
03:40:21 <lambdabot> class  (Fractional a) => Floating a  where
03:40:22 <lambdabot>     pi                                                      :: a
03:40:22 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
03:40:22 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
03:40:22 <lambdabot>     (**), logBase                                           :: a -> a -> a
03:40:30 <McManiaC> i think i have to take a look at functors / monads again
03:40:44 <xrfang_> @src Fractional
03:40:44 <lambdabot> class  (Num a) => Fractional a  where
03:40:45 <lambdabot>     (/)             :: a -> a -> a
03:40:45 <lambdabot>     recip           :: a -> a
03:40:45 <lambdabot>     fromRational    :: Rational -> a
03:40:57 <xrfang_> @src Real
03:40:57 <lambdabot> class  (Num a, Ord a) => Real a  where
03:40:57 <lambdabot>     toRational      ::  a -> Rational
03:41:16 <xrfang_> @src Complex
03:41:17 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
03:41:33 <xrfang_> hehe, complex number is not Ord...
03:41:42 <Axman6> @src RealFloat
03:41:42 <lambdabot> Source not found. stty: unknown mode: doofus
03:41:50 <Axman6> interesting
03:42:23 <McManiaC> xrfang_: that would be kind of... difficult ;)
03:49:56 <wavewave> is ghci haskell debugger able to notify the moment when a thunk evaluate?
03:50:33 <wavewave> i mean the very moment it evaluate an expression.
03:51:21 <wavewave> I am always confused when is when
03:52:21 <xrfang_> @src Complex
03:52:21 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
03:52:35 <xrfang_> what is ! and :+ in the above expression?
03:52:54 <dolio_> :+ is the constructor name.
03:52:57 <Axman6> xrfang_: ! means that the a's are strict
03:53:03 <Axman6> they can;t be thunks
03:53:08 <Axman6> i think
03:54:05 <xrfang_> ok, I ask about strict and thunks later ;) thanks Axman6
03:54:44 <Axman6> basically, a thunk is something like 1 + 2. it hasn't be evaluated to 3 yet (this is where laziness comes in)
03:56:01 <xrfang_> oh well
03:56:07 <xrfang_> @src RealFloat
03:56:07 <lambdabot> Source not found. :(
03:59:45 <demolithion> is it possible to make [2,3.. sqrt x] a list of integers?
03:59:48 <xrfang_> :t 2+3
03:59:49 <lambdabot> forall t. (Num t) => t
03:59:55 <xrfang_> :t 2+3 :: Int
03:59:56 <lambdabot> Int
04:00:22 <xrfang_> I think this is a type signature: (Num b) => length :: [a] -> b.
04:00:24 <xrfang_> right?
04:00:39 <xrfang_> if so, why it is not written as: length :: (Num b) => [a] -> b.
04:00:44 <beelsebob> demolithion: [2,3.. floor (sqrt x)]
04:01:02 <xrfang_> i.e. length is the function name, RHS of :: is the signature??
04:01:04 <beelsebob> or [2,3.. ceil (sqrt x)] -- depending on your desired semantics
04:01:45 <RayNbow> :t genericLength
04:01:47 <lambdabot> forall b i. (Num i) => [b] -> i
04:01:51 <RayNbow> :t length
04:01:52 <lambdabot> forall a. [a] -> Int
04:02:32 <xrfang_> BONUS? that's an example in LYAH :)
04:04:10 <xrfang_> :t fromIntegral
04:04:11 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:07:32 <xrfang_> :t length
04:07:33 <lambdabot> forall a. [a] -> Int
04:09:20 <xrfang_> @src factorial
04:09:20 <lambdabot> Source not found. My mind is going. I can feel it.
04:09:45 <xrfang_> > product [1..0]
04:09:49 <lambdabot>   1
04:09:57 <xrfang_> > [1..0]
04:09:58 <lambdabot>   []
04:10:11 <xrfang_> > product [0..1]
04:10:13 <lambdabot>   0
04:17:43 <matthew-_> @seen ivanm
04:17:43 <lambdabot> ivanm is in #gentoo-haskell, #xmonad and #haskell. I last heard ivanm speak 54m 22s ago.
04:18:32 <matthew-_> @tell ivanm I hereby offer you the maintainership of the graphviz package. I don't have the time or inclination to deal with it, and I'm currently getting about 2 emails a day telling me that polyparse has changed its api
04:18:32 <lambdabot> Consider it noted.
04:21:14 <matthew-_> maybe when a package changes its api, it should include in the package a diff which should be automatically applied to all other packages which now break as a result of the API change
04:21:24 <matthew-_> this could lead to enormous humour
04:23:35 <flux> matthew-_, that would be an nice thing to have. actually there is already something similar for C: http://www.emn.fr/x-info/coccinelle/#sp
04:35:06 * sampointon wishes for either an anonymous case expression or a caseM construct
04:41:18 <ivanm> matthew-_: :s
04:41:19 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:41:24 <ivanm> yay for me, I guess :s
04:41:39 <ivanm> dammit, just when I'm busy with some other code I'm working on :s
04:42:12 <ivanm> matthew-_: OK, send a message to haskell@ and haskell-cafe@ saying that I'll take over, but might not be able to get around to it for a week or two
04:45:20 <matthew-_> ivanm: well it's hardly going to be a deterioration from my maintainership then! ;)
04:45:56 <matthew-_> do feel free to say no, if you want
04:48:01 <Berengal> I do love applicatives...
04:48:11 <matthew-_> I love sausages
04:48:22 <Berengal> I just ate a couple...
04:48:28 <Berengal> Then I used a couple of applicatives
04:48:41 <matthew-_> bet the sausages tasted nicer
04:49:09 * mornfall reises eyebrows ...  just a little
04:49:14 <mornfall> raises*
04:49:19 <Berengal> They did, but applicatives aren't neccessarily bland either
04:49:40 <matthew-_> mornfall: some of us were managing to avoid the other interpretations ;)
04:49:51 <ivanm> matthew-_: nah, I need to update it anyway for my stuff
04:49:56 <Berengal> What other interpretations? ;)
04:50:04 <mornfall> Yeah, what other interpretations?
04:50:08 <ivanm> hmmm.... sausages...
04:50:10 <mornfall> You got me curious here...
04:50:14 <matthew-_> Yeah, what other interpretations? ;)
04:50:20 <ivanm> Axman6: you seen that sausages ad on TV?
04:51:06 <Axman6> ?
04:53:21 <ivanm> we've got an ad up here (for insurance maybe?) about a guy talking about how much he loves sausages whilst he's pushing them round on a BBQ
04:53:37 <ivanm> it seemed relevant to the OT conversation happening here ;-)
04:53:44 <dolio> That sounds amazing.
04:53:56 <Berengal> .... really?
04:54:11 <ivanm> yes
04:54:12 <ivanm> ;-)
04:54:39 <Berengal> That was aimed mostly at dolio
04:55:10 <MiniCow> Wow, this channel has changed! :)
04:55:17 <ivanm> from what?
04:55:20 <matthew-_> never underestimate the appeal of pushing sausages around on a BBQ
04:55:21 * ivanm looks around
04:55:34 <ivanm> MiniCow: oh, yeah, I see what you mean... that potted plant used to be in _that_ corner!
04:55:35 <ivanm> :p
04:55:46 <matthew-_> I'm not a plant!
04:55:48 <MiniCow> exactly
04:56:15 <MiniCow> Wait. is that plant moving by itself?
04:56:17 <ivanm> matthew-_: I wasn't referring to you... but if you interpreted it that way, then maybe you should go seek a specialist in this field to try and resolve your underlying issues...
04:56:18 * Berengal continues to play with functions as applicatives
04:56:46 <Berengal> until' done iter = if' <$> done <*> id <*> until done iter . iter
04:57:07 <matthew-_> Berengal: I would reject code by anyone who wrote that.
04:57:25 <matthew-_> such levels of higher order code tends to totally unmaintainability
04:57:52 <Berengal> Depends on how you use it
04:58:27 <Berengal> IMO it's clearer than the default implementation of until, though just barely...
04:58:30 <Berengal> ?src until
04:58:30 <lambdabot> until p f x | p x       = x
04:58:30 <lambdabot>             | otherwise = until p f (f x)
04:58:47 <matthew-_> yeah, the indentation there is questionable
05:00:19 <Berengal> applicatives does make custom control structures easier though
05:00:29 <matthew-_> I think your code is wrong actually
05:00:34 <matthew-_> you're calling until and not until'
05:00:41 <Berengal> Yeah, it's missing an aprostrophe at the end
05:01:03 <Berengal> Which while not really wrong doesn't make it recursive, just use the default until implementation
05:01:12 <matthew-_> well quite
05:02:30 <dolio> @type let if' b t f = if b then t else f in \p f -> fix $ \me -> if' <$> p <*> id <*> me . f
05:02:31 <lambdabot> forall c. (c -> Bool) -> (c -> c) -> c -> c
05:03:27 <dolio> @type let if' b t f = if b then t else f until p f = fix $ \me -> if' <$> p <*> id <*> me . f in until (>10) (+1) 0
05:03:28 <lambdabot> parse error on input `='
05:03:35 <dolio> > let if' b t f = if b then t else f until p f = fix $ \me -> if' <$> p <*> id <*> me . f in until (>10) (+1) 0
05:03:36 <lambdabot>   <no location info>: parse error on input `='
05:03:42 <dolio> > let if' b t f = if b then t else f ; until p f = fix $ \me -> if' <$> p <*> id <*> me . f in until (>10) (+1) 0
05:03:44 <lambdabot>   11
05:04:28 <jethr0> hehe, if only if' were in the standard libraries that code would be beautifully concise
05:04:52 <jethr0> stupid "then" and "else" keywords ;)
05:04:56 <sampointon> matthew-_: that's the problem I always have with the prime convention, I end up using x' where I should use x
05:05:31 <Berengal> I sometimes wish then and else weren't keywords so I could use them for myself
05:05:56 <Berengal> If I could choose, I'd get rid of the if-then-else construct from the language...
05:08:24 <jethr0> well, i think it's a nice gateway construct until you are more comfortable with FP. but it would definitely nice to have if' in the standard libraries (albeit under a better name)
05:08:47 <Berengal> Such as?
05:08:48 <dolio> bool :: a -> a -> Bool -> a
05:09:53 <jethr0> well, if' is obviously a rather bad name for a core functinoality, no?
05:10:10 <Berengal> dolio: Hmm.. Interesting argument order... I think we'll need both though
05:10:24 <jethr0> "when", "whether" ^_^
05:10:35 <Berengal> jethr0: "if" would be better...
05:10:46 <jethr0> i agree
05:10:47 <EvilTerran> dolio, do those two "a" parameters follow the order of if/then/else, or the order of the constructors in the data definition?
05:11:00 <EvilTerran> ?src Bool
05:11:01 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:11:18 <dolio> I don't really care. :)
05:11:31 <matthew-_> data True = TT; data False = FF ;)
05:12:17 <matthew-_> value level programming is so 2006
05:13:05 <Berengal> Yeah, if only all programs could be expressed as static function pipelines...
05:13:53 <Deewiant> Isn't that basically concatenative languages
05:14:38 <ray> some people ask why bool is in Ord, but i ask why it isn't in Enum
05:14:51 <dolio> It is.
05:14:56 <dolio> > [False ..]
05:14:57 <lambdabot>   [False,True]
05:15:04 <EvilTerran> > [minBound :: Bool ..]
05:15:06 <lambdabot>   [False,True]
05:15:24 <Deewiant> Bounded,Enum,Eq,Ord,Read,Show
05:15:26 <Berengal> ?instances Enum
05:15:27 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
05:15:37 <jethr0> > let {true x y = x; false x y = y; if' cond res alt = cond res alt} in if' true 4 5
05:15:39 <lambdabot>   4
05:15:48 <EvilTerran> that should really be "data Bool = False | True deriving (Read, Show, Eq, Ord, Enum, Bounded)"
05:15:51 <ray> ?instances Ix
05:15:52 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
05:16:14 <ray> ?instances-importing Data.Ix Ix
05:16:14 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
05:16:16 <EvilTerran> (according to the report)
05:23:09 <RayNbow> > let {true = const ; false = const id ; church True = true ; church _ = false } in church (3 > 4) (text "3 is larger than 4") (text "3 is not larger than 4")
05:23:10 <lambdabot>   3 is not larger than 4
05:26:20 <mornfall> You're all crazy people.
05:27:19 <Berengal> Perhaps I should go learn J
05:30:35 <dixie> hmm. what is other possibility for defining binary communication protocol than ASN.1?
05:31:53 <QtPlaty[HireMe]> Defining?
05:32:06 <Saizan> dixie: google's protocol-buffers?
05:32:08 <matthew-_> dixie: we might need a bit more information before we can answer than one...
05:32:18 <mauke> brain
05:32:23 <matthew-_> ddr3
05:32:32 <matthew-_> hypertransport
05:33:08 <jethr0> pci, ata, scsi?
05:33:12 <matthew-_> fast/fix, ethernet, amqp, pigeon
05:33:50 <QtPlaty[HireMe]> ELF
05:34:11 <jethr0> morse code
05:34:41 <matthew-_> in fact, is difficult to think of something that couldn't be used for binary communication
05:37:31 <matthew-_> boris johnson might qualify though
05:38:07 <jethr0> dixie: does that in any way address your question?
05:39:07 * matthew-_ isn't hopeful
05:39:13 <dixie> matthew-_: I think that mistake is that I post it on wrong channel :) this is not topic here - but details -> we have communication over TCP/IP between server which require less resource usage but high flexibility (like XML+XSD).
05:39:56 <dixie> ASN.1+BER is very good for that - unfortunately, we have limitation for using this technology because of lack of support on our "platform" :)
05:40:06 <matthew-_> right
05:40:14 <matthew-_> do you need the data to be self describing?
05:41:05 <mauke> here's a protocol: 4 bytes (unsigned integer, big endian), followed by that many bytes of data
05:41:07 <dixie> I'm not sure what self describing mean.
05:41:32 <matthew-_> dixie: hang on, I'm just trying to find what I'm thinking of
05:41:55 <matthew-_> ok
05:41:55 <matthew-_> - Opaque (if I hand you a message with nothing else, there's nothing
05:41:55 <matthew-_> you can do with it)
05:41:55 <matthew-_> - Self-Describing (if I had you a message with nothing else, there is
05:41:55 <matthew-_> some category of "interesting" things you can do with it).
05:42:07 <QtPlaty[HireMe]> dixie: Like XML.  You have a thingie that tells you how to parse it.
05:42:26 <matthew-_> popular solutions in this space are things like TibrvMsg
05:43:07 <matthew-_> there's also a project called fudge (Fast Unstructured Data Generic Encoding) but it may not be released
05:43:24 <matthew-_> but they're both self describing and binary
05:43:45 <matthew-_> which seems rarer - most self describing formats are text based eg xml, json etc
05:44:02 <ivanm> @seen sjanssen
05:44:02 <lambdabot> sjanssen is in #haskell-in-depth, #haskell-overflow, #haskell-blah, #xmonad and #haskell. I last heard sjanssen speak 5h 44m 29s ago.
05:44:14 <matthew-_> google protocol buffers, and thrift etc aren't self describing
05:46:23 <matthew-_> dixie: but if you really are in this space, and are doing messaging, I would encourage you to look at amqp and in particular, rabbitmq.com which is now in ubuntu, debian and gentoo (and yes, I'm one of the devs, hence the plugging!)
05:46:35 <dixie> Thanks. I'll take a look on that. Maybe that "flexibility" as I wrote is no needed so much.
05:48:42 <voker57__> @hoogle fromMaybe
05:48:43 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
05:49:09 <voker57__> aha, default value
05:51:18 <PeakerWork> @djinn a -> Maybe a -> a
05:51:18 <lambdabot> f a b =
05:51:19 <lambdabot>     case b of
05:51:19 <lambdabot>     Nothing -> a
05:51:19 <lambdabot>     Just c -> c
05:51:31 <ivanm> @ask sjanssen I take it to find the max, etc. of a FingerTree I use the Foldable instance?  if so, how can I use the v parameter to find the longest list from a "FingerTree (Sum Int) [a]" without recalculating the length each time (since the Foldable instance ignores the v)?
05:51:31 <lambdabot> Consider it noted.
05:53:16 <voker57__> @djinn Int -> Int
05:53:16 <lambdabot> Error: Undefined type Int
05:53:22 <voker57__> @djinn Integer -> Integer
05:53:23 <lambdabot> Error: Undefined type Integer
05:53:33 <ivanm> @djinn a -> a
05:53:33 <lambdabot> f a = a
05:53:41 <ivanm> voker57__: @djinn doesn't deal with specific types
05:53:49 <ivanm> @djinn Maybe a -> a
05:53:49 <voker57__> ivanm: i see
05:53:49 <lambdabot> -- f cannot be realized.
05:53:54 <ivanm> @djinn Maybe a -> a -> a
05:53:54 <lambdabot> f a b =
05:53:55 <lambdabot>     case a of
05:53:55 <lambdabot>     Nothing -> b
05:53:55 <lambdabot>     Just c -> c
05:54:11 <mauke> @djinn ()
05:54:11 <lambdabot> f = ()
05:54:14 <mauke> @djinn () -> ()
05:54:14 <lambdabot> f a = a
05:55:46 <ivanm> @djinn Maybe a -> Maybe a
05:55:47 <lambdabot> f a = a
05:55:50 <ivanm> @djinn Maybe a -> a -> Maybe a
05:55:50 <lambdabot> f a b =
05:55:50 <lambdabot>     case a of
05:55:50 <lambdabot>     Nothing -> Just b
05:55:50 <lambdabot>     Just c -> Just c
05:56:02 <ivanm> hmmm... I was hoping that Just c -> Nothing :(
05:56:27 <Axman6> @djinn Maybe a -> b -> Maybe b
05:56:28 <lambdabot> f a b =
05:56:28 <lambdabot>     case a of
05:56:28 <lambdabot>     Nothing -> Nothing
05:56:28 <lambdabot>     Just _ -> Just b
05:56:40 <ivanm> Axman6: heh
05:56:52 <voker57__> @djinn a -> a -> a -> Maybe a -> a
05:56:53 <Axman6> @djinn Maybe a -> b -> Maybe ()
05:56:53 <lambdabot> f _ _ a b =
05:56:53 <lambdabot>     case b of
05:56:53 <lambdabot>     Nothing -> a
05:56:53 <lambdabot>     Just c -> c
05:56:53 <lambdabot> f a _ =
05:56:55 <lambdabot>     case a of
05:56:57 <lambdabot>     Nothing -> Nothing
05:56:59 <lambdabot>     Just _ -> Just ()
05:57:01 <ivanm> @djinn b -> Maybe a -> Maybe b
05:57:01 <lambdabot> f a b =
05:57:03 <lambdabot>     case b of
05:57:05 <lambdabot>     Nothing -> Nothing
05:57:07 <lambdabot>     Just _ -> Just a
05:57:24 <voker57__> hey it just threw first two out, not fair :(
05:57:26 <PeakerWork> so, anyone up to give me some feedback on my MList thing?
05:57:44 <voker57__> ah no
05:57:49 <Berengal> @djinn Maybe a -> Bool
05:57:49 <lambdabot> f a =
05:57:49 <lambdabot>     case a of
05:57:49 <lambdabot>     Nothing -> False
05:57:49 <lambdabot>     Just _ -> True
05:57:54 <PeakerWork> cabal install mlist
05:58:17 <PeakerWork> cooler than the blasphemous lazy I/O :)
05:58:27 <QtPlaty[HireMe]> How does djinn know that nothing should be False?
05:58:44 <Berengal> How does djinn know what Bool is?
05:58:48 <PeakerWork> QtPlaty[HireMe]: arbitrary choice -- djinn just tries to prove the type is inhabitable by creating a valid value
05:59:08 <Berengal> I'm guessing it's either built in, or it's going by the constructor declaration order
05:59:14 <QtPlaty[HireMe]> @djinn Either a b -> Bool
05:59:14 <lambdabot> f a =
05:59:14 <lambdabot>     case a of
05:59:14 <lambdabot>     Left _ -> False
05:59:14 <lambdabot>     Right _ -> True
06:01:10 <PeakerWork> @djinn Bool
06:01:10 <lambdabot> f = False
06:01:39 <Berengal> @djinn a
06:01:39 <lambdabot> -- f cannot be realized.
06:02:10 <Berengal> @djinn (a -> Bool) -> (a -> a) -> a -> a
06:02:10 <lambdabot> f a b c =
06:02:11 <lambdabot>     case a c of
06:02:11 <lambdabot>     False -> b c
06:02:11 <lambdabot>     True -> c
06:03:18 <ivanm> PeakerWork: how is it blasphemous?
06:03:36 <PeakerWork> ivanm: it executes side-effects during evaluation
06:03:45 <RayNbow> @. pl djinn (a -> (b -> c)) -> (b -> (a -> c))
06:03:46 <lambdabot> f = flip
06:03:48 <ivanm> so? isn't that what you expect?
06:03:54 <PeakerWork> ivanm: when you program in Haskell? No
06:03:59 <kpreid> PeakerWork: it's fine if you don't get caught!
06:04:05 <PeakerWork> ivanm: I expect side effects to be in IO
06:04:07 <ivanm> @djinn (a -> b -> c)) -> (b -> (a -> c))
06:04:07 <lambdabot> Cannot parse command
06:04:16 <ivanm> @djinn (a -> (b -> c)) -> (b -> (a -> c))
06:04:17 <lambdabot> f a b c = a c b
06:04:22 <ivanm> PeakerWork: ummm... it is
06:04:23 <kpreid> i.e. if the interleavedness of the effects is not distinguishable from immediate effects
06:04:32 <ivanm> the side effects occur when the IO is evaluated...
06:04:51 <PeakerWork> kpreid: its better if you use lazy I/O in IO, rather than pure
06:05:06 <ivanm> PeakerWork: oh, is this that stuff that augustss brought up about the order that reading in a value and from stdin or something and then using it?
06:05:34 <PeakerWork> ivanm: the order at which your list evaluation happens affects when the file is read
06:05:49 <PeakerWork> ivanm: so if the file changes sometimes, evaluation order changes can affect the computation result
06:06:02 <ivanm> PeakerWork: *nod*
06:06:17 <ivanm> but how likely/often is that going to be a problem?
06:06:35 <PeakerWork> ivanm: I think its *ugly* and I think there's a better alternative
06:07:08 <ivanm> what?
06:07:13 <ivanm> uniqueness types? :p
06:07:33 <Axman6> PeakerWork: zomgmlistneedsmoarcomments!
06:07:48 <PeakerWork> Axman6: Thanks for feedback -- will document it some
06:08:16 <Axman6> i was hoping i'd be able to understand what was going on, but i have no idea
06:08:16 <QtPlaty[HireMe]> @djinn (a -> b -> (a,[c])) -> a -> [b] -> [c]
06:08:16 <lambdabot> Error: Undefined type []
06:08:57 <PeakerWork> Axman6: what part are you reading?
06:09:00 <PeakerWork> @hoogle LineBuffering
06:09:01 <lambdabot> System.IO LineBuffering :: BufferMode
06:09:23 <ManateeLazyCat> In current module i have a function named "id" conflict with Prelude.id, so i write CurrentModule.id to fix it. So have another *symbol* can reference current module function and i don't need binding "CurrentModule" with "id"?Thanks!
06:09:26 <Axman6> trying to understand zipWith atm (just the first thing i looked at, no particular reason for choosing it)
06:09:48 <ManateeLazyCat> Like self in C++?
06:10:04 <mauke> ManateeLazyCat: there is no 'self' in C++. also, C++ doesn't have modules
06:10:25 <voker57__> ManateeLazyCat: hide prelude's id
06:10:32 <ManateeLazyCat> mauke: I forgot which language, but i know 'self'.
06:10:40 <RayNbow> @djinn-add data List a = Nil | Cons a (List a)
06:10:40 <lambdabot> Error: Recursive types are not allowed: List
06:10:40 <mauke> uh, great
06:10:43 <PeakerWork> Axman6: its one of the more complicated part, I'd ignore zipWith at first :)
06:11:00 <Axman6> heh, ok :)
06:11:09 <ManateeLazyCat> voker57__: Yep, but i wonder have another way can reference current module.
06:11:20 * Axman6 tries to understand the definition of MList
06:11:21 <EvilTerran> ManateeLazyCat, afraid not
06:11:57 <EvilTerran> ManateeLazyCat, you may be able to do something with template haskell, but it'd be gratuitous
06:12:03 <ManateeLazyCat> voker57__: unlucky, i use Prelude.id in same module.
06:12:23 <EvilTerran> ManateeLazyCat, could you call your "id" something else?
06:12:30 <Axman6> PeakerWork: looks like something that a) needs a research paper, and b) needs a tutorial (/better/some documentation)
06:12:53 <ManateeLazyCat> EvilTerran: I just don't want function binding module name, because i will change module name someday.
06:12:56 <PeakerWork> Axman6: I just put it on cabal this morning -- am still refactoring stuff to look nice, and I think I just found an important bug
06:13:34 <Axman6> yeah, take your time, just thought the whole thing sounded interesting, and i'd like to be able to play with it :)
06:13:48 <PeakerWork> cool :)
06:14:08 <EvilTerran> , $(stringE . loc_module =<< location)
06:14:09 <lunabot>  ":Interactive"
06:15:13 <ManateeLazyCat> Never mind, i just wonder have have this way to reference current module, and this not big problem to me. :)
06:15:58 <ManateeLazyCat> s/have this/have a
06:16:30 <PeakerWork> ok, I have big bug in there :)
06:17:04 <Axman6> heh
06:19:11 <EvilTerran> ManateeLazyCat, you could "import Prelude hiding (id); import qualified Prelude"
06:19:33 <EvilTerran> ManateeLazyCat, which'd mean you could refer to your "id" as just "id", and the Prelude one as "Prelude.id"
06:23:52 <xrfang> I wrote a simple function to "strip off" Just:
06:23:58 <xrfang> noJust (Just x) = x
06:24:01 <xrfang> which works..
06:24:06 <beelsebob> that's called fromJust
06:24:08 <beelsebob> it's in the prelude
06:24:10 <xrfang> however, I tried to add a "signature" to it
06:24:16 <xrfang> noJust :: (Just a) -> a
06:24:25 <xrfang> which does not work!
06:24:26 <beelsebob> Just 5 does not have type Just Int
06:24:31 <beelsebob> it has type Maybe Int
06:24:40 <xrfang> oh
06:24:46 <beelsebob> in the mean time - consider using the maybe function to not crash and burn when you get a Nothing
06:24:57 <beelsebob> > maybe 0 (+2) (Just 4)
06:24:59 <lambdabot>   6
06:25:04 <beelsebob> > maybe 0 (+2) Nothing
06:25:05 <lambdabot>   0
06:25:36 <xrfang> beelsebob: that worked
06:25:45 <xrfang> I am only learning type and type classes
06:25:59 <xrfang> not a really useful function :)
06:29:21 <Berengal> Don't say that. You need to get out of Maybe often enough...
06:29:57 <beelsebob> you do – but if you do it with fromJust, you're doin it rong
06:30:08 <beelsebob> for no more reason than you can provide a better error with maybe
06:30:39 <ivanm> > fromJust Nothing
06:30:41 <lambdabot>   * Exception: Maybe.fromJust: Nothing
06:30:46 <Jedai> beelsebob: fromMaybe is pretty nice for this usage
06:31:00 <ivanm> > (\ (Just 2) -> 2) Nothing
06:31:01 <lambdabot>   * Exception: /tmp/5484332770210765634:71:41-55: Non-exhaustive patterns in ...
06:31:04 <beelsebob> jethr0: indeed
06:31:10 <Jedai> > fromMaybe (error "This shouldn't happen") Nothing
06:31:11 <lambdabot>   * Exception: This shouldn't happen
06:31:22 <ivanm> Jedai: sure it should... you told it to! :p
06:31:30 <beelsebob> > fromMaybe (error "I can tell myslef where I failed horribly if I do it like this") Nothing
06:31:32 <lambdabot>   * Exception: I can tell myslef where I failed horribly if I do it like this
06:31:41 <tibbe> am i right to assume that unpack has
06:32:04 <Jedai> tibbe: has ?
06:32:31 <ivanm> Jedai: unpack has nothing
06:32:36 <ivanm> duh
06:32:37 <ivanm> :p
06:32:41 <tibbe> am i right to assume that UNPACK has no effect on functions? e.g. data S = S {-# UNPACK -#} !(Int -> Bool)
06:33:17 <Jedai> tibbe: I think so
06:46:45 <maltem> Real-time space profiling as a GSOC project - as always, I'm curious :)
06:51:12 <Berengal> One of the first things I did with Haskell, about nine months ago, was build a small interpreter for a very basic functional language. I decided to try it again now that I know Haskell much better, and it's proving awesome
07:14:30 <xrfang> @src RealFloat
07:14:30 <lambdabot> Source not found. Wrong!  You cheating scum!
07:14:36 <xrfang> :t RealFloat
07:14:38 <lambdabot> Not in scope: data constructor `RealFloat'
07:14:48 <xrfang> @src Real
07:14:49 <lambdabot> class  (Num a, Ord a) => Real a  where
07:14:49 <lambdabot>     toRational      ::  a -> Rational
07:14:56 <xrfang> @src Float
07:14:57 <lambdabot> data Float = F# Float#
07:15:20 <xrfang> hello... what is RealFloat ?
07:16:37 <PeakerWork> > foldr (:) [] [1..10]
07:16:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:16:52 <gwern> @quote
07:16:52 <lambdabot> tez says: Anyway, I think the lesson is "don't drink and derive".  Or something.
07:16:52 <PeakerWork> what would be the closest foldl to this?
07:17:38 <PeakerWork> If I'm forced to use foldl instead of foldr - and I want to use something like (:) and [] as the args, how can I do it?  flip (:) to foldl would give me a reverse list and (++) would be inefficient
07:18:02 <kpreid> PeakerWork: you mean, construct a list in that order as the result? or just, accumulate period
07:18:18 <kpreid> because the only way it's going to be efficient, afaik, is if you do something equivalent to construcing a reverse list
07:18:20 <PeakerWork> kpreid: the first
07:18:48 <Berengal> Use functions?
07:18:53 <kpreid> you have to reverse it afterward
07:18:58 <kpreid> or pay the cost of ::
07:19:00 <kpreid> er, ++
07:19:01 <PeakerWork> kpreid: I'm implement MList
07:19:22 <sampointon> @hoogle (a -> m b) -> (a -> m c) -> a -> m c
07:19:22 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
07:19:22 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
07:19:22 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
07:19:25 <PeakerWork> kpreid: which is a bit like LogicT, except it is meant to replace "pure" lazy I/O
07:19:27 <kpreid> if I understand correctly, it is not possible to do otherwise
07:19:32 <kpreid> well, without some help from an optimizer or unsafe operations
07:19:44 <PeakerWork> kpreid: so I have:
07:19:46 <PeakerWork> data Monad m => MListItem m a = MNil | MCons a (MList m a)
07:19:46 <PeakerWork> newtype Monad m => MList m a = MList { unMList :: m (MListItem m a) }
07:20:15 <PeakerWork> then I can define:   sfoldr :: Monad m => (a -> b -> b) -> b -> MList m a -> m b    pretty easily
07:20:16 <xrfang> ? otherwise
07:20:23 <xrfang> @src otherwise
07:20:23 <lambdabot> otherwise = True
07:20:35 <sampointon> @pl (\ f g x -> f x >> g x)
07:20:35 <lambdabot> liftM2 (>>)
07:20:51 <Axman6> :t liftA2 (>>)
07:20:52 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Applicative f, Monad m) => f (m a) -> f (m b) -> f (m b)
07:21:03 <Axman6> :t liftM2 (>>)
07:21:04 <PeakerWork> kpreid: then I can define this:
07:21:04 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (m b) -> m1 (m b)
07:21:05 <PeakerWork> mnSequence :: (Monad m, Monad n) => MList m (n a) -> m (n [a])
07:21:05 <PeakerWork> mnSequence = sfoldr (liftM2 (:)) (return [])
07:21:39 <gio123> can somebody download for me this paper?
07:21:40 <PeakerWork> kpreid: now this has a problem that it has to bind the entire set of effects of the m monad, because of the foldr
07:21:41 <gio123> http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=1254370
07:21:43 <Berengal> PeakerWork: Could you use a difference list perhaps?
07:22:00 <PeakerWork> Berengal: Hmm.. maybe, I'll look
07:25:23 <EvilTerran> > foldl (\dl x -> dl . (x:)) id [1..10] []
07:25:25 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:25:48 <EvilTerran> ?type ($ []) . foldl (\dl x -> dl . (x:)) id
07:25:49 <lambdabot> forall b. [b] -> [b]
07:26:52 <PeakerWork> EvilTerran: cool, thanks
07:27:13 <sampointon> where does the Monad ((->) a) instance live?
07:27:24 <Lemmih> But that's O(n) just like 'reverse', isn't it?
07:27:25 <PeakerWork> I think foldr on MLists is kind of useless, so I'm going to have to formulate all my ops on top of foldl
07:27:25 <Saizan> Control.Monad.Instances
07:27:44 <sampointon> Saizan: ta
07:27:55 <QtPlaty[HireMe]> :t (2^2)
07:27:56 <lambdabot> forall t. (Num t) => t
07:28:28 <Taejo> @src inits
07:28:29 <lambdabot> inits []     =  [[]]
07:28:29 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
07:28:39 <Taejo> @src tails
07:28:39 <lambdabot> tails []         = [[]]
07:28:39 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
07:29:34 <QtPlaty[HireMe]> Ok this tells me that 2^2 has a value of type t where t is a Num.  Why can I show it without confining its type?
07:29:49 <QtPlaty[HireMe]> > show (2^2)
07:29:49 <Saizan> QtPlaty[HireMe]: defaulting
07:29:50 <lambdabot>   "4"
07:30:09 <kpreid> > show (2^2 :: Expr)
07:30:10 <lambdabot>   "2 * 2"
07:30:51 <QtPlaty[HireMe]> Saizan: How does haskell get told which way to default?
07:30:52 <burp_> @hoogle Expr
07:30:53 <lambdabot> module Text.Parsec.Expr
07:30:53 <lambdabot> module Text.ParserCombinators.Parsec.Expr
07:30:53 <lambdabot> Distribution.Simple.Program alexProgram :: Program
07:31:02 <kpreid> QtPlaty[HireMe]: for Num, as a special case, Integer (or what you declare) is the default if type inference doesn't resolve it
07:31:40 <QtPlaty[HireMe]> kpreid: So that can't be used for other type classes?
07:32:11 <kpreid> QtPlaty[HireMe]: it is a special case for Num and ... one other class, the floating point class
07:32:17 <kpreid> I forget which
07:32:47 <Berengal> Given that I have lots of functions with type "a -> Environment -> Maybe b", what's the best way to chain them together?
07:33:22 <QtPlaty[HireMe]> Berengal: By chain them together you mean compose them?
07:33:25 <Berengal> Right now I either have big case foo of ladders, or I keep track of an env variable all over the place
07:33:33 <Berengal> QtPlaty[HireMe]: Yeah, basically
07:33:38 <Saizan> Berengal: work in the "ReaderT Environment Maybe" monad and use (>>=) or (>=>)
07:33:45 <EvilRanter> ?unmtl ReaderT r Maybe a
07:33:45 <lambdabot> r -> Maybe a
07:33:46 <Taejo> :t (&&&)
07:33:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
07:33:57 <EvilRanter> ?unmtl MaybeT (Reader r) a
07:33:58 <lambdabot> r -> Maybe a
07:34:02 <Saizan> or do-notation
07:34:05 <EvilRanter> um
07:34:05 <Berengal> Saizan: Exactly what I was looking for, probably. Where does it live?
07:34:17 <BONUS> Control.Monad.Reader
07:34:51 <Berengal> Thanks... I haven't had time to get to know transformers yet, hopefully this'll provide some insight
07:35:01 <sampointon> why does everything I do now seem to involve applicatives somewhere?
07:35:04 <conal> Berengal: or define an arrow
07:35:14 * QtPlaty[HireMe] doesn't know any of the answers yet but is hopefully getting better at asking questions.
07:35:30 <Saizan> Kleisli (ReaderT Environment Maybe) is the corresponding Arrow :)
07:35:31 <BONUS> transofrmers aren't hard, like maybe the name would lead you to think
07:35:36 <sampointon> before I learned about them I couldn't see their use, now every problem can be solved by some applicative or another
07:35:49 <Berengal> conal: Arrows are a little bit out of my box right now...
07:36:04 <QtPlaty[HireMe]> BONUS: So there not more then meets the eye?
07:36:28 <BONUS> usually there is, but that doesn't mean that the basics are hard
07:36:57 <conal> Berengal: your example is probably a natural stepping-stone to arrows.  try using >=> as Saizan suggested.  it's equivalent to >>> (on arrows)
07:37:31 <conal> Berengal: in other words, use the monad interface in an arrow-ish style (>=>), and then you'll build up some arrow intuition.
07:37:54 <conal> just as using liftM2 and ap help one build a feeling for Applicative
07:38:18 <Berengal> conal: I actually learned applicatives at the same time I groked monads, so I wouldn't quite know how that works
07:39:33 <PeakerWork> mmapM :: Monad m => (a -> m b) -> MList m a -> m [b]  -- for strict monads, even the (fmap head) of the result must bind the entire monad :-(
07:39:35 <Berengal> I do love applicatives though...
07:39:43 <conal> cool :)
07:40:20 <PeakerWork> I think I can only have the equivalents of mapM_ and forM_ support lazy I/O, and not mapM and forM
07:40:50 <Saizan> PeakerWork: i'd use MList m b as result
07:41:03 <Berengal> So, is there a basic ReaderT tutorial somewhere? Just something short so I can get a feel for it?
07:41:14 <PeakerWork> Saizan: I am running the same thought through right now :)
07:41:42 <Saizan> Berengal: have you ever used Reader?
07:41:46 <BONUS> Berengal: search for "all about monads"
07:41:59 <Yrogirg> Hello, is there an easy way to first write an array into file and than get it from that file? May be there are some tutorials?
07:42:11 <Berengal> Saizan: Not Reader as such, no, but I've used functions as monads...
07:42:15 <PeakerWork> Saizan: I thought I could formulate the MList combinators similarly to the way list combinators are built (with foldr as a base and then sequence, mapM, etc) but foldr for example does not allow lazy I/O
07:42:19 <Axman6> Yrogirg: try Data.Random
07:42:28 <Axman6> uh, Data.Binary even -_-
07:42:44 <PeakerWork> ok, replacing blasphemous lazy I/O with proper I/O is a bit harder than I thought :)
07:42:48 <Axman6> though... in theory, Data.Random could do the same thing...
07:43:46 <Saizan> PeakerWork: foldr :: b -> (a -> m b -> m b) -> MList m a -> m b
07:43:46 <PeakerWork> Saizan: I discovered I accidentally made everything totally strict in: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2231  :-(
07:44:08 <PeakerWork> Saizan: Yeah, I have: mlistFoldr :: Monad m => (a -> b -> m b) -> m b -> MList m a -> m b
07:44:14 <PeakerWork> Saizan: (even the "b" there is monadic)
07:44:30 <Saizan> you missed an "m b"
07:45:36 <PeakerWork> Saizan: oh, why does it have to be "m b" there?
07:45:45 <PeakerWork> Saizan: ah!
07:45:53 <PeakerWork> Saizan: that might be a great idea, thanks :)
07:47:43 <Taejo> :w
07:47:51 <Taejo> oops, wrong window
07:54:20 <Taejo> I'm sending GHC into an infinite loop -- is there any way I can find out what phase (I *think* it's typechecking)
07:55:50 <Botje> uh
07:55:53 <Botje> impressive :)
07:55:56 <maltem> Taejo, are you using UndecideableInstances or something?
07:56:07 <Taejo> maltem: no extensions
07:56:11 <maltem> uh
07:56:16 <maltem> impressive really
07:56:17 <Taejo> the program *isn't* type-correct
07:56:22 <Botje> Taejo: can you show your code?
07:56:36 <Taejo> Botje: I'm working on minimalising (and removing the private stuff)
07:56:41 <Botje> oh, okay
07:58:15 <Renderwahn> what is the name for the [ x | x <- something ] syntax?
07:58:28 <michaelcdever> hey all, im building my filemanger package... i included the icons folder... darcs add Icons/; darcs add Icons/*, it builds ok but won't run... I know its something to do with accessing the icons because of the error message
07:58:33 <Taejo> it is GHC 6.8.2, so it might be fixed already
07:58:33 <Lemmih> Renderwahn: List comprehension.
07:58:39 <Axman6> list comprehensions
07:58:41 <Renderwahn> Lemmih: thanks
07:58:51 <conal> Renderwahn: named after "set comprehensions" from math
07:58:54 <michaelcdever> i checked the repo for the icons, and it only has read permissions on the icons, would that affect it?
07:59:18 <Renderwahn> just needed a name to google for it :)
07:59:27 <conal> will we ever get our monad comprehensions back?
07:59:54 <Axman6> sure... with toList >_>
07:59:55 <mc__> when I compile and run this program http://haskell.pastebin.com/m53513b17 it always hangs forever after outputting " [...] Collatz (113351,243)", but whe I triy to pass 113352 directly to iterCollatz, I get the result in a blink
08:00:02 <wli> I tried and failed to implement it.
08:00:11 <Renderwahn> if it is similiar to set comprehensions can I read the <- just like in, as x is in X
08:00:26 <michaelcdever> and if i check where it's been built to, the icons folder isn't there, I'm presuming it should be???
08:01:39 <Renderwahn> this is nice, now the syntax makes sense
08:01:57 <Taejo> @paste
08:01:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:05:24 <michaelcdever> ahhh... I have to do Data-Files in the .cabal?
08:05:36 <monadic_kid> am i the only who thinks scala is fugly?
08:05:50 <monadic_kid> i mean looks fugly
08:05:51 <EvilTerran> monadic_kid, no
08:06:02 <dcoutts_> michaelcdever: hmm?
08:06:06 <EvilTerran> its syntax is overly complex and unintuitive
08:06:13 <michaelcdever> if I do Data-Files:    Icons/*.png will that take them all or do I have to type all the names?
08:06:58 <Taejo> http://pastebin.com/m1e554800 seems to send GHC 6.8.2 into an infinite loop
08:07:07 <Taejo> Botje: there it is
08:07:08 <EvilTerran> the whole failure to make infix and normal names distinct can cause complete and utter unexpected breakage
08:07:53 <michaelcdever> dcoutts_: in the .cabal file, I need to include the image files that I use, so that they're available at run time
08:07:57 <voker57__> how to check if directory (or file) exists?
08:08:35 <michaelcdever> voker57: have a look at System.Directory
08:08:58 <Botje> Taejo: it makes my GHC stack overflow
08:09:01 <Botje> fishy indeed :)
08:09:05 <ivan-kanis> how do flush output of putStr ?
08:09:11 <Botje> 6.8.3 on ubuntu jaunty here
08:09:19 <Botje> ivan-kanis: hFlush stdout
08:09:26 <ivan-kanis> thanx
08:09:49 <voker57__> aha, it's doesDirectoryExists
08:10:01 <ivan-kanis> soji.hs:8:2: Not in scope: `hFlush'
08:10:01 <ivan-kanis> soji.hs:8:9: Not in scope: `stdout'
08:10:01 <ivan-kanis>  
08:10:11 <dcoutts_> michaelcdever: right, and Cabal generates a module that provides code to find the data files at runtime
08:10:16 <ivan-kanis> is it part of prelude or something ?
08:10:46 <Saizan_> Taejo: eh, i get a stack overflow in 6.8.3, but a proper error in 6.10.2
08:10:49 <EvilTerran> ivan-kanis, System.IO, i think
08:11:07 <Taejo> Saizan_: ok, thanks
08:11:56 <michaelcdever> dcoutts_: got it :D
08:12:02 <michaelcdever> it works :D
08:12:09 <bavardage> someone go write haskell bindings for webkit please :D
08:12:13 * bavardage wants a haskell browser
08:12:35 <ivan-kanis> EvilTerran: yes thanks you
08:15:06 <Axman6> aren't there gtk bindings for webkit?
08:15:46 <dcoutts_> Axman6: there are
08:16:19 <Berengal> I'm beginning to understand transformers now. They're sentinent machine-aliens come to defend earth against villains and prevent staircasing case statements
08:16:20 <Axman6> well, seems like a good route toward getting haskell/webkit working together
08:16:49 <Berengal> You'll never wrap my lines again, Maybe!
08:16:55 <BONUS> you know like hotruby is ruby translated to javascript
08:17:15 <BONUS> i wonder if it would be useful to make a haskell to javascript translator
08:17:21 <michaelcdever> if someone could tell me how to page up in irssi on osx, itd be a great help :D
08:17:23 <BONUS> slash compiler, whatever
08:17:29 <Botje> the LHC people have something that does that
08:17:42 <EvilTerran> BONUS, i think someone's written a javascript backend for one of the compilers
08:17:48 <BONUS> awesome
08:18:01 <koda> hi
08:18:04 <edwardk> bonus: i started down that road for GHC at one point, but there were too many primOps
08:18:10 <EvilTerran> BONUS, http://haskell.org/haskellwiki/Yhc/Javascript
08:18:19 <dcoutts_> Axman6: yes, it seems like the sane approach
08:18:20 <BONUS> hah
08:18:21 <lumi> michaelcdever: Try shift-pgup?
08:18:21 <BONUS> woo, interesting
08:18:41 <koda> i'm trying to compile powerpc code with the powerpc haskell on an intel machintosh
08:18:51 <koda> macintosh*
08:18:54 * edwardk heads off to see if he can adapt his jit to ghc's bytecode
08:19:10 <NEEDMOAR> What would you use to write a PHP parser in Haskell?
08:19:21 <BONUS> parsec
08:19:26 <koda> configure runs fine but at build time i get a lot of "no such instruction: `bctr'"
08:19:40 <dcoutts_> NEEDMOAR: yes, parsec or perhaps happy
08:19:44 <EvilTerran> NEEDMOAR, i'd use parsec, or alex+happy
08:20:03 <EvilTerran> actually, i wouldn't write a PHP parser at all, but i know what you mean ;)
08:20:20 <koda> am i missing something?
08:20:23 <dcoutts_> heh heh :-)
08:20:30 <NEEDMOAR> EvilTerran: ;-)
08:20:31 <wli> edwardk: ghc has bytecode?
08:21:14 <dcoutts_> wli: yes, but ghc primops are different from the ghci bytecode
08:23:31 <nanothief> I am trying to write an alternate show function, that acts like show for types that are instances of Show, except for String where it uses id. I have atm http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2234#a2234 . It works, but it also needs UndecidableInstances. Is the code safe, or is there another way to do it?
08:24:38 <Axman6> @instances Show
08:24:39 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
08:25:15 <dcoutts_> nanothief: use the same trick Show uses for displaying lists
08:25:36 <nanothief> dcoutts, what trick is that?
08:25:42 <nanothief> (finding source...)
08:25:48 <dcoutts_> nanothief: ever noticed how show for [Char] is different than for [Int]?
08:26:20 <nanothief> yes
08:26:23 <dcoutts_> > (show ['a', 'b', 'c'], show [1, 2, 3])
08:26:25 <lambdabot>   ("\"abc\"","[1,2,3]")
08:26:47 <dcoutts_> nanothief: it does that in pure Haskell98
08:27:41 <nanothief> ahh I see has showList as a class function, which is probably different for Char
08:27:52 <nanothief> that should work for me, thanks!
08:28:02 <dcoutts_> nanothief: exactly, and the instance for [a] uses showList
08:28:08 <edwardk> wli: its used by ghci
08:28:39 <nanothief> heh, maybe I'm becoming too dependant on ghc extensions :P
08:28:49 <nanothief> when pure old haskell98 shows me up
08:29:01 <dcoutts_> edwardk: in principle any program could use bytecode, the interpreter is in the rts, but we don't make much use of the feature.
08:29:24 <roconnor> Re: TCO, do objects being cleared on the stack have their finalizers called before the tail call is invoked?  Do Python objects have finalizers?
08:29:39 <roconnor> ... maybe not the best place to ask
08:29:52 <edwardk> dcoutts: yeah. what i'm thinking about is how to adapt my jit to handle ghc bytecode, the bytecode is large enough to be interesting but small enough to handle.
08:30:08 <edwardk> dcoutts: and i think a tracing jit would be pretty handy for longer running ghci tasks, etc.
08:30:08 <dcoutts_> edwardk: mm, interesting.
08:30:38 <dcoutts_> edwardk: I don't think the ghci bytecode has ever really been designed in a great deal of detail.
08:30:57 <dcoutts_> edwardk: eg nhc or yhc bytecode has had a lot more thought put in
08:31:04 <edwardk> dcoutts: and for that matter if i retain the x86-64 to x86-64 aspects of my jit for non bytecode stuff i could possibly trace other thunks as well.
08:31:22 <dcoutts_> edwardk: so what are you trying to do overall?
08:31:24 <edwardk> dcoutts: unfortunately both of them went the wrong way on the push/enter vs. eval/apply design decision
08:31:37 <dcoutts_> edwardk: ah right yes
08:32:36 <dcoutts_> edwardk: though it probably makes less difference in an interpreter. But if you're mixing generated code (either pre-compiled or jit) with bytecode then picking the right one is important.
08:32:47 <edwardk> dcoutts_: well, basically i have a tracing jit i designed for kata, which detects hot spots and starts logging traces, when a trace loops back to the same spot i've detected a loop, but its in the form of a basic block, so i can optimize the loop
08:32:55 <edwardk> dcoutts: it matters a lot to the efficiency of my jit
08:33:32 <dcoutts_> edwardk: using that Haskell in-memory code gen lib? (I can't recall the name)
08:33:53 <edwardk> dcoutts: nah, the jit itself is in c++ at the moment.
08:34:28 <edwardk> dcoutts: currently it jits x86-64 assembly to x86-64 assembly, but the tracing machinery could be adapted to trace arbitrary bytecode and only trace lower level stuff on library calls
08:34:43 <dcoutts_> edwardk: I see
08:35:00 <nanothief> dcoutts, actually, it didn't help as I still need the code instance (Show a) => Outputable a , and that needs UndecidableInstances
08:35:08 <edwardk> dcoutts: the major use of the jit is replacing jumps to unknown addresses with a poly inline cache. basically everything the STG does is a jump to an unknown address.
08:35:20 <dcoutts_> edwardk: right
08:35:24 <edwardk> so it could majorly benefit from my principal optimization
08:35:44 <kadaver_> is loop in asm slower than looping manually? ie dec ecx and test ecx,ecx myself?
08:36:01 <dcoutts_> edwardk: for the case where we mostly statically compose a bunch of things and call the result many times? ie when what is being called doesn't change too much
08:36:14 <edwardk> kadaver: on modern architectures, typically the CISC instructions like the LOOP prefix suck ;)
08:36:48 <edwardk> dcoutts: well, think of it like applying GRIN optimizations at runtime only for the paths that are actually executing
08:36:53 <dcoutts_> nanothief: that instance probably isn't strictly necessary
08:37:01 <kadaver_> ok
08:37:51 <edwardk> dcoutts: i've kicked this around before, but now i'm to the point where i might be willing to switch up my priorities to move ghc in front of my toy compiler. was talking to denis bueno the other day and it clicked that i'd get a lot bigger splash out of improving ghc's bytecode than i will out of improving my own ;)
08:38:13 <nanothief> dcoutts, how would you get rid of it? I want Outputable automatically defined for all showable types, and I don't know of any other way of doing it
08:38:32 <edwardk> dcoutts: also the nature of the jit allows it to do some things like strictness analysis and unboxing at runtime.
08:38:40 <koda> hey is it possible to produce ppc code on x86 machine?
08:38:48 <dcoutts_> edwardk: yes, and as I said earlier, I don't think people have looked that closely at ghci's bytecode
08:39:10 <dcoutts_> edwardk: either from the point of making the direct bytecode interpreter run faster or for making it easier to jit.
08:39:21 <edwardk> dcoutts: if no path in the trace doesn't evaluate the thunk, then i can evaluate it earlier. if a thunk is constructed and no reference to it leaves the trace then i can avoid constructing it and place its slots in registers
08:39:36 <edwardk> dcoutts: actually its a pretty good fit to my jit as is even
08:39:55 <Axman6> koda: i don't think ghc does cross compilation
08:40:07 <dcoutts_> edwardk: sounds like you'd want to start from an earlier level of code for that, no? eg from STG than from bytecode
08:40:22 <koda> Axman6: so i'd need a ppc machine :(
08:40:23 <dcoutts_> nanothief: you'd need instances for each type
08:40:34 <Axman6> though, since you're on an intel mac, installing the PPC ghc might work using rosetta
08:40:53 <edwardk> dcoutts: i thought about that, originally. in fact if you go through some old feature requests one of them was me asking for a version of stg i could dump like ext-core
08:40:58 <koda> well in fact i installed the ppc version of ghc
08:41:07 <koda> but it doesn't compile any program
08:41:10 <Axman6> hmm
08:41:15 <dcoutts_> edwardk: so what made you figure you can do it from later code?
08:41:26 <Axman6> well, shouldn't expect any more than that i guess
08:41:42 <Axman6> koda: maybe using -fvia-C and passing -arch flags to gcc could help
08:41:55 <koda> lemme try
08:42:31 <edwardk> dcoutts: but the bytecode is closer to the granularity i actually need. logging bytecodes and results is pretty much all i need for the trace, otherwise all i wind up doing is making a new bytecode up, and redoing the world the STG->bytecode compiler does
08:42:34 <dcoutts_> edwardk: btw, it was harpy I was thinking of
08:42:41 <nanothief> dcoutts, I see, I might try another solution in that case (since it is only needed for implementation)
08:43:10 <edwardk> dcoutts_: nah, i never liked harpy. the manual 'buffer checks' make me gag a bit.
08:43:36 <dcoutts_> edwardk: right, that should be automated (and I think it's doable too)
08:43:45 <dcoutts_> eg we do that in Data.Binary
08:43:59 <edwardk> dcoutts_: jit code emission works better in reverse anyways. you can always allocate fixed size buffers and build blocks backwards by allocating new buffers and jumping forward to the next block
08:44:02 <koda> Axman6: is the syntax correct? ghc --make hello.hs -fvia-C "-arch ppc"
08:44:13 <edwardk> dcoutts: building forwards always risks not having enough from for the jump
08:44:21 <Axman6> -fvia-C -optc "-arch ppc" i think
08:44:28 <dcoutts_> edwardk: interesting, I'd never thought of that
08:44:42 <edwardk> dcoutts: that also doubles as a good way to do dead code elimination in the last pass
08:44:54 <koda> cc1: error: unrecognized command line option "-arch ppc" :o
08:45:02 <edwardk> dcoutts: and register allocation works better in reverse too
08:45:17 <Axman6> koda: maybe -optc -arch -optc ppc
08:46:20 <edwardk> dcoutts: since you just use whatever opcode you want and aim towards free registers for its precursors and all your fixups can be dropped right inline. fewer fixups because the destination register is always right
08:47:14 <edwardk> and in general this sort of jit isn't mucking around with phi nodes, since its executing an actual trace, so its one superblock.
08:47:23 <dcoutts_> edwardk: right, for the fast linear style allocators you want to use in a JIT. I tend to think about the offline style more.
08:47:57 <wli> What gets me is when there are multiple destination registers.
08:48:00 <koda> Axman6: nope it doesn't work either :(
08:48:00 <edwardk> dcoutts: and historically i've been using this for jitting x86-64 -> x86-64 so i can recycle the previously done offline register allocation of the original code i traced.
08:48:17 <dcoutts_> edwardk: right
08:48:24 <edwardk> dcoutts: thats a less useful win here =)
08:48:27 <voker57__> can i get something like hayoo offline?
08:48:29 <dcoutts_> :-)
08:48:40 <dcoutts_> voker57__: you can use hoogle locally
08:49:00 <voker57__> dcoutts_: how?
08:49:09 <edwardk> wli: well, most of the time when there are multiple destination registers in x86 you don't get much choice. i.e. it goes to eax:edx, etc.
08:49:18 <voker57__> install it on my machine?
08:49:24 <Axman6> cabal install hoogle
08:49:29 <wli> That's not where the issues are.
08:49:36 <Axman6> you get a command line utility
08:49:37 <edwardk> and most register-register moves wind up just being relabeling on virtual registers
08:49:38 <dcoutts_> voker57__: right and check the hoogle docs for how to build up the local db of packages
08:49:47 <voker57__> cool
08:50:20 <koda> what's hoogle for?
08:50:38 <voker57__> @hoogle doesFileExist
08:50:38 <lambdabot> System.Directory doesFileExist :: FilePath -> IO Bool
08:50:44 <michaelcdever> hmmm i can't get into code.haskell.org :\
08:51:04 <edwardk> dcoutts: right now i'm trying to figure out the best way to hook in to replace the bytecode interpreter. ideally i'd like to run the jit out of haskell, which is dangerously metacircular i admit ;)
08:51:09 <wli> Multiple destination registers breaks a bunch of assumptions floating around. It doesn't so much cause things to break as it causes things to fail to realize optimizations/etc.
08:51:35 <dcoutts_> edwardk: having the jit in Haskell should be doable.
08:51:42 <Phyx-> koda, hoogle is an haskell search engine which allows you do do full text searches and full and partial type searches
08:51:43 <koda> it really seems i'd need ppc machine to do this
08:51:47 <edwardk> wli: well, even things like flags violate a lot of naive three address code assumptions
08:52:11 <edwardk> dcoutts_: i dislike the fact that i'd basically be rewriting my entire jit, but there are always things you learn by doing so
08:52:17 <michaelcdever> ah got it
08:52:20 <wli> flags being ZF and the like? condition codes?
08:52:25 <edwardk> wli: yeah
08:52:30 <koda> thanks Axman6 and Phyx-
08:52:31 <koda> bye
08:52:35 <dcoutts_> edwardk: if it's C you can put it into the rts, but the Haskell approach seems more fun.
08:52:41 <edwardk> wli: i usually treat the output flags of a computation as another 'register'
08:53:03 <edwardk> dcoutts_: yeah c is definitely out. my current one is very much c++ to the bone.
08:53:05 <wli> Flags are actually included as additional registers in all this.
08:53:15 <dcoutts_> edwardk: you might need to add a primop to handle the callback to the code gen when we call a function that needs to be jitted
08:53:36 <Phyx-> btw, the commandline utility for hoogle seems to return to many results sometimes to be usefull.. is there a way to say it to limit it to the top 10 ones?
08:53:51 <dcoutts_> edwardk: making a VM style Haskell RTS is an interesting project in general
08:54:10 <Axman6> Phyx-: --count n i think
08:54:21 <EvilTerran> Phyx-, | less?
08:54:43 <edwardk> dcoutts: well, one way would be to replace the interpreter function with a call back into haskell for the interpreter, and just replace the general interpretation as well as the jit path.
08:55:22 <edwardk> dcoutts: one of the huge wins i get in my current model is that my jit can jit itself
08:55:29 <dcoutts_> edwardk: heh heh
08:55:36 <Phyx-> Axman6, hmm ok, EvilTerran lol, yeah, forgot about more and less
08:55:47 <edwardk> dcoutts: and it rarely needs to execute all opcodes, so it gets some nice fast paths
08:55:54 <edwardk> and opcodes tend to arise in certain patterns, etc.
08:56:40 <edwardk> dcoutts: http://comonad.com/jit++/jit++/interpreting/opcode.h is an old version of the jit's main opcode loop (before i had it actually jitting)
08:56:54 <edwardk> dcoutts: you can see its very c++ ;)
08:57:41 <wli> The infinite temporary interpretation could easily have a register class for condition codes to deal with.
08:58:30 <edwardk> wli: when jitting i interpret condition codes logically, rarely do i actually have to retain all of the condition codes that arise in the original computation
08:58:48 <edwardk> dcoutts: basically the jit turns into an embedded dsl for describing x86-64 semantics.
08:58:54 <wli> Well, yeah, most of all that gets thrown away.
08:59:31 <dcoutts_> edwardk: mm
09:00:47 <edwardk> dcoutts: the notation in there is largely the same as http://sandpile.org/ia32/opc_1.htm
09:00:51 <edwardk> so it makes it fairly easy to check
09:03:03 <Berengal> I have a class with a function eval :: e -> ReaderT Environment Maybe Int. Now, one of the instances is LetExpr, which contains a binding (name and expression) and an expression. I need to evaluate the first expression, bind the result to the name and evaluate the second expression. I'm having trouble commuting the monads...
09:03:57 <edwardk> dcoutts: i figure i can rebuild that basic model for the much much simpler ghc bytecode, back it with llvm, or worse harpy, to avoid reinventing a code emitter and call it a day
09:05:11 <edwardk> dcoutts: llvm has the benefit that it has a ton of prebuilt optimization passes, but the downside that it can't see the stack, otoh, my usual problem with that was that i was interpreting x86-64 and had to rebuild the stack exactly when i took a side exit, but here i only have to rebuild the haskell stack... not the c stack.
09:05:20 <mauke> eval (LetExpr n d b) = do v <- eval d; local (extend n v) b
09:05:22 <Cale> Berengal: Are you really going to have separate datatypes for each of the cases in your language?
09:05:41 <Berengal> Cale: Yeah, I figured I was going to try that out
09:05:43 <dcoutts_> edwardk: can't "see" the stack?
09:06:15 <Berengal> Cale: It's a very simple language. It has ints, variables, function calls, lets and funlets
09:06:18 <Cale> Berengal: It seems like it ought to be problematic to me, but you might be able to get it to work.
09:06:37 <Cale> I would have one datatype for the abstract syntax.
09:07:10 <edwardk> dcoutts: in a tracing jit i have to be able to restore the state of the system to exactly as it would be had i executed the assembly up to a point should something go wrong in a trace. i.e. i encounter some newfangled opcode i don't knw about etc. to do that i basically interpret x86-64 assembly as i go during the trace
09:07:31 <Berengal> Cale: That's what I had the first time around. Honestly, I don't really see a big difference in how it works...
09:07:43 <edwardk> but afterwards i swap all sorts of operations around, i use entirely different registers, etc. and when i take a side exit because something unexpected occurred, i have to swizzle the stack back the way it should have been
09:08:02 <edwardk> i can't use llvm for that, because in llvm the stack is opaque. i know nothing about where it put what
09:08:10 <Cale> Berengal: Are you also using existentials?
09:08:12 <edwardk> and i don't know anything about what stackframes are made, etc.
09:08:18 <dcoutts_> edwardk: ah because llvm handles the stack layout
09:08:22 <Cale> Berengal: What's the type of the result of your parser?
09:08:26 <Berengal> Cale: It seems that thus far the type class only sums up the datatypes
09:08:33 <Berengal> Yeah, I'm using existentials
09:08:37 <Cale> ah, okay
09:08:46 <Cale> Then that has a decent chance of working :)
09:09:09 <edwardk> dcoutts: otoh, when i am executing a bytecode i don't have those issues, because i only have to restore the haskell stack for the current thread, not the c-stack.
09:09:20 <dcoutts_> edwardk: right
09:09:35 <edwardk> dcoutts: i.e. if i elided the construction of a haskell stack frame, i just make it right and write it out.
09:09:52 <Berengal> I can't define the eval instance for LetExpr though...
09:09:55 <Cale> It does seem like you'll need lots of extra typeclasses though.
09:10:05 <Berengal> Cale: How so?
09:10:12 <edwardk> if i skipped allocating a thunk in memory i just allocate it and dump the registers i'd unboxed it into into the slots
09:10:19 <Cale> Well, one for every function which acts on that datatype.
09:10:27 <Cale> er, those datatypes*
09:10:29 <Cale> ;)
09:10:44 <Cale> Perhaps you could paste a bit more of your code along with the error?
09:11:06 <Berengal> Cale: The problem is, I don't have much code yet because I don't know how to write it :P
09:11:14 * wli is having trouble figuring out how to typecheck stuff with modules.
09:11:37 <edwardk> dcoutts: right now my biggest concern is how often i'll be stepping into 'opaque' non-bytecode stuff, and how badly that will cripple the ability of the jit to see what it needs to do
09:11:42 <Berengal> Cale: I'm also in the middle of translating from eval :: e -> Environment -> Maybe Int to eval :: e -> ReaderT Environment Maybe Int
09:12:01 * monadic_kid existentially quantify's his existance
09:12:09 <edwardk> dcoutts: and since those transitions may trigger garbage collections, i may have to safepoint around them to some good deal of expense.
09:12:16 <dcoutts_> edwardk: all the lib functions you call in ghci will be generated code
09:12:48 <edwardk> dcoutts: generated as in bytecode?
09:13:25 <dcoutts_> edwardk: no, I mean pre-compiled binary code
09:13:29 <edwardk> dcoutts: last time i looked through the bytecode intepreter a few months back i noted there was support for calling native thunks, etc. i just never checked to see how often it cme up in practice.
09:13:34 <edwardk> yeah
09:13:55 <dcoutts_> edwardk: eg all calls to prelude/base lib functions
09:14:06 <dcoutts_> edwardk: in the ghci use case it'll happen all the time
09:14:22 <edwardk> hence why for kata i started from an x86-64 -> x86-64 jit, because i figured a lot of the untapped optimization possibilities come from tracing right through glibc rather than from what i can do in my own process ;)
09:14:34 <edwardk> er in my own code
09:14:40 <dcoutts_> edwardk: right, you'd need to do the same here
09:14:58 <edwardk> ugh, so basically this means transcoding the entire x86-64 -> x86-64 jit as well
09:15:09 <eu-prleu-peupeu> hi
09:15:26 <edwardk> or accepting the fact that those are opaque and 'fast enough'
09:15:30 <eu-prleu-peupeu> are there any girls in the haskell comunity?
09:15:41 <edwardk> eu-prleu-peupeu: yes
09:15:41 <Cale> eu-prleu-peupeu: Yes.
09:15:52 <mauke> yes, @vixen
09:16:18 <Berengal> Cale: http://codepad.org/PDrj6P3n
09:16:22 <edwardk> @vixen asl
09:16:22 <lambdabot> 19/f/California
09:16:26 <edwardk> see!
09:16:34 <sjanssen> eu-prleu-peupeu: there are some women at least
09:16:35 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
09:16:55 <sjanssen> not sure how many "girls" there are
09:17:19 <sjanssen> @seen ivanm
09:17:19 <lambdabot> I saw ivanm leaving #gentoo-haskell, #xmonad and #haskell 1h 47m 32s ago, and .
09:17:28 <Berengal> Well, I know of at least one Haskell coder, but I'm not sure she's a part of the community
09:18:35 <wli> Let's start with the stupidest language possible and throw in modules.
09:18:54 <Cale> wli: Malbolge + modules?
09:19:15 <sjanssen> @tell ivanm you don't use the Foldable instance, and you wouldn't want to use Sum Int for the measurement.  Use a Monoid where mappend = max and use split to locate the point where the maximum value is
09:19:15 <lambdabot> Consider it noted.
09:19:17 <Berengal> Brainfuck + modules? How would you resolve the namespace?
09:19:31 <edwardk> dcoutts: i think if i tackle this that i'll focus just on the bytecode case and ignore the boundary problems
09:19:49 <dcoutts_> edwardk: yes, much easier to start with
09:19:51 <wli> Cale: Not that sense of stupid.
09:20:18 <Cale> hehe
09:20:18 <eu-prleu-peupeu> hmm, do these women code ? or just lurk around ?
09:20:38 <edwardk> dcoutts: this started because i was seriously considering attaching this to the back end of lhc, but the ghc bytecode is a better fit for me than GRIN
09:20:44 <Cale> eu-prleu-peupeu: Why would you expect that they're any different from the males who code?
09:21:12 <dcoutts_> edwardk: hmm
09:21:14 <eu-prleu-peupeu> no
09:21:15 <olsner> wli: C plus modules?
09:21:24 <Cale> no?
09:22:02 <wli> olsner: Sure. No big deal about imperative.
09:22:12 <sampointon> wli: I'd suggest COBOL or MUMPS with modules, but I have a sinking suspicion that it's been done already
09:22:23 <edwardk> dcoutts: if you think about it GRIN is a closed world. a jit works well because it sort of incrementally builds a pseudo-closed world from an open one.
09:22:34 <wli> sampointon: Not that sense of the word stupid.
09:22:51 <dcoutts_> edwardk: right, makes sense
09:23:26 <wli> Let's say some typed lambda calc with Cartesian products, coproducts, and parametric polymorphism.
09:24:01 <wli> Now add modules. How do you typecheck?
09:26:05 <wli> (higher-order recursive modules, even)
09:26:23 <edwardk> sampointon: if your mumps develop modules, i would question the diagnosis
09:26:36 <michaelcdever> file manager released :D:D:D
09:28:14 <Saizan_> Berengal: there you've to insert the new binding into the environment while you evaluate the body, right?
09:28:24 <Berengal> Saizan_: Yes
09:28:46 <Saizan_> Berengal: as mauke showed above you can use "local" for that
09:29:18 <Saizan_> > runReader (do x <- ask; y <- local (+1) ask; return (x,y)) 0
09:29:19 <lambdabot>   (0,1)
09:29:39 <Saizan_> > runReader (do x <- ask; y <- local (+1) ask; z <- ask; return (x,y,z)) 0
09:29:41 <lambdabot>   (0,1,0)
09:30:07 <Berengal> Saizan_: The problem is I need to eval one expr before binding it
09:30:41 <Saizan_> Berengal: why is that a problem?
09:31:32 <trofi_> @src local
09:31:33 <lambdabot> Source not found. Just what do you think you're doing Dave?
09:32:12 <Saizan_> Berengal: do val <- eval expr; local (bind (name,Right val)) (eval inExpr) -- this should do it
09:33:09 <Berengal> Saizan_: Ah, yes, I was just coming to that conclusion myself
09:33:21 <Berengal> This is my first time using transformers
09:33:29 <Berengal> I'm confusing myself more than neccessary it seems
09:35:10 <Saizan_> yeah, they are fairly simple in the end, using the ReaderT constructor explicitly when in doubt might dispel some of the magic
09:39:14 <Taejo> @hoogle (a -> b) -> (a, a) -> (b, b)
09:39:14 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
09:39:14 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
09:39:14 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
09:40:12 <Saizan_> ?type join (
09:40:13 <lambdabot> parse error (possibly incorrect indentation)
09:40:18 <Saizan_> ?type join (***)
09:40:19 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:50:36 <wli> Berengal: The monad transformer thing makes it super-easy so long as you're clear on what the lang is supposed to do.
09:52:03 <FalconNL> Sigh. My bit-fu is failing me. I want to convert an unsigned int to a signed one. Does anyone happen to know the correct function f :: Word32 -> Int such that f (4294967295 :: Word32) == (-1 :: Int)?
09:52:06 <Saizan_> Berengal: at the end you might take a look at this paper, it's pretty similar to how you're building your interpreter http://web.cecs.pdx.edu/~mpj/pubs/modinterp.html
09:52:38 <Saizan_> > fromIntegral  (4294967295 :: Word32)
09:52:39 <lambdabot>   4294967295
09:52:41 <Saizan_> > fromIntegral  (4294967295 :: Word32) :: Int
09:52:43 <lambdabot>   4294967295
09:52:49 <Saizan_> > fromIntegral  (4294967295 :: Word32) :: Int32
09:52:50 <lambdabot>   -1
09:53:41 <FalconNL> doh. Thanks. Was trying fromEnum earlier, but apparently fromIntegral is smarter.
09:53:43 <Axman6> :t fromIntegral
09:53:45 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:55:05 <Taejo> > [(+), (*)] <*> [0, 1] <*> [0, 1]
09:55:07 <lambdabot>   [0,1,1,2,0,0,0,1]
09:55:27 <eu-prleu-peupeu> is it easy to convert a haskell program so that it uses reactive ?
09:55:56 <roconnor> > [(||),(&&)] <*> [minbound..maxbound] <*> [minbound..maxbound]
09:55:57 <lambdabot>   Not in scope: `minbound'Not in scope: `maxbound'Not in scope: `minbound'Not...
09:56:10 <roconnor> > [(||),(&&)] <*> [minBound..maxBound] <*> [minBound..maxBound]
09:56:11 <lambdabot>   [False,True,True,True,False,False,False,True]
09:58:19 <cnwdup> How would I translate a enum structure with 3 elements into haskell? Can I just use Word for that?
09:59:00 <eu-prleu-peupeu> if i jwant the inputs to my program (and corresponding modules) to be continuous, can i use the approach of design it with non-continuous inputs and then in the end stuff reactive onto it o they become continunous ?
09:59:03 <RayNbow> cnwdup: enum structure?
09:59:18 <Axman6> data Thingo = Element1 | Element2 | Element3 deriving Enum?
09:59:28 <cnwdup> typedef enum { foo, bar, zot } MyStrcture; in C @ RayNbow.
09:59:38 <RayNbow> see Axman6's answer :p
09:59:50 <cnwdup> Thanks then. (:
10:26:44 <rdeshpande> t
10:26:53 <cnwdup> What's a good tutorial about using the FFI?
10:27:26 <cnwdup> I want to add a few functions to gtk2hs and not having used FFI until now, I am quite a bit lost.
10:28:24 <eu-prleu-peupeu> cnwdup: read the rwh chapter on it
10:28:34 <eu-prleu-peupeu> its chapter 16 i think
10:28:45 <cnwdup> eu-prleu-peupeu, thank you.
10:31:48 <FalconNL> I just made by BMP importer 186 times faster by switching from a Parsec-based parser to a Data.Binary.Get-based one. O_O
10:32:13 <eu-prleu-peupeu> yeh, parsec is darn slow :(
10:32:51 <copumpkin> I didn't know anyone used Parsec for binary stuff
10:32:59 <FalconNL> It also uses about 1000 times less memory
10:34:03 <eu-prleu-peupeu> FalconNL: could you do png and exr loaders ? :D
10:35:04 <FalconNL> Heh, having spent the whole weekend trying to get all 30 variants of the BMP format working I'm kinda done with importers for a while :)
10:35:24 <Jedai> eu-prleu-peupeu: Using Parsec for a fixed binary format doesn't exactly seems a good choice... Parsec is pretty good to parse complex data structures
10:35:42 <eu-prleu-peupeu> yes, indeed
10:36:00 <eu-prleu-peupeu> for jpeg/png i use this package: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stb-image
10:38:09 <FalconNL> But now Haskell has a parser for BMPs that spits out a friendly data structure (Image Int Int [[Pixel]], where Pixel = Pixel Int Int Int Int). More usable than the bytestrings and StorableArrays in the current codecs in my opinion.
10:38:13 <vixey> FalconNL: that's really interesting  would like to see both programs if possible
10:38:44 <FalconNL> I still have some documentation to do, but it should be on Hackage later this evening or tomorrow at the latest
10:39:58 <eu-prleu-peupeu> FalconNL: nice, lets do a whole image package on it ? :)
10:40:18 <Cale> eu-prleu-peupeu: If you're familiar with Reactive, it's perhaps not *too* hard, depending on what it does, but it generally amounts to a rewrite. Writing things for Reactive demands a very different style of programming from the familiar imperative event handling sort of thing.
10:40:21 <FalconNL> The package is going to be Codec.Image.Simple
10:40:49 <FalconNL> exported methods are (currently) loadBMP, saveBMP, isValid, Image, Pixel
10:41:29 <eu-prleu-peupeu> Cale: yes, i really get my mind scratched whenever i think about it :/
10:42:17 <eu-prleu-peupeu> i really dont know how to think about reactive :/
10:42:26 <Cale> eu-prleu-peupeu: I've been playing around with it lately, and after some initial confusion, it's started to become clearer.
10:42:54 <monadic_kid> write a tutorial for use then :0
10:43:08 <Cale> I could. I have lots of nice simple example programs :)
10:43:26 <eu-prleu-peupeu> Cale: ive done some snippets also, but i dont know how to think about "continuous input fed functions" :(
10:43:27 <wli> What's a good simple example program?
10:43:36 <FalconNL> is HPaste down?
10:43:37 <monadic_kid> i'd like to see how to structure very stateful problems, in particular game states. "Canonical Game Loop" FRP style would be ideal
10:43:48 <vixey> something you can copy and paste? :p
10:44:36 <eu-prleu-peupeu> wli: darcs get reactive-glut and check the Test.hs
10:44:38 <Guest_23> any one in this room mybe able to help me im looking for a script a specail script
10:45:43 <eu-prleu-peupeu> monadic_kid: check the Test.hs in the reactive-glut pkg
10:46:11 * Cale makes a paste :)
10:46:35 <Cale> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2235#a2235
10:46:54 <Cale> Here's a program where you use the arrow keys to accelerate a small disk in various directions.
10:46:56 <FalconNL> I still have some tidying up to do, but for those interested in the BMP codec, 90-95% of the code can be seen at http://codepad.org/isewLTui
10:47:03 <eu-prleu-peupeu> fieldtrip is cheating :)
10:47:10 <Cale> Huh?
10:47:48 <monadic_kid> what does the Test example show exactly, i mean it's pointless unless it shows how to structure your states and manipulating them
10:47:50 <Cale> afaik, fieldtrip is what you're supposed to use with reactive :)
10:48:29 <eu-prleu-peupeu> hmm
10:49:28 <Cale> If you like, I'll get some even simpler ones :)
10:49:38 <eu-prleu-peupeu> yes, i was talking about designing stuff with behaviours and events, and their relationship
10:49:47 <Cale> Though, I've uncovered a few annoying bugs in just the short time I've been playing.
10:50:03 <monadic_kid> also i'm could imagine that there will be very idiomic haskell the problem is i'll probably how to go and read up a number of concepts before i can actually understand FRP itself
10:50:12 <monadic_kid> i mean in the examples
10:50:20 <eu-prleu-peupeu> i tried looking at the fieldtrip source, buts its way too hardcore for me :/
10:51:28 <Cale> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2235#a2236
10:51:54 <eu-prleu-peupeu> :)
10:51:55 <Cale> This reveals (what I consider) a bug in the coordinate transformations
10:52:19 <Cale> The GL coordinates don't match the FieldTrip coordinates.
10:53:32 <eu-prleu-peupeu> oh
10:54:01 <Cale> But it's only a slight difference, so the program is not totally messed up :)
10:54:42 <Cale> Well, I should probably say GLUT coordinates...
10:56:34 <eu-prleu-peupeu> :)
10:57:21 <Cale> http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2235#a2237
10:57:29 <Cale> er
10:57:35 <Cale> That was painfully named
10:57:51 <Cale> 'velocity' ought to be named 'position'
10:57:59 <Cale> mouse is now the velocity :)
10:59:26 * Cale fixes
11:07:04 <monadic_kid> so MyDisk, position, vel, accel are Behaviours in FRP terms right?
11:08:27 <rdeshpande> hello all
11:09:01 <monadic_kid> cale
11:09:39 <Cale> monadic_kid: yes
11:09:42 <Cale> er
11:09:56 <Cale> Well, they're functions of the UI
11:10:26 <gwern> > 4 `mappend` 5
11:10:27 <lambdabot>   Add a type signature
11:10:38 <Cale> monadic_kid: In Reactive/FieldTrip terms,  UI -> Behavior t  is called  Anim t
11:10:40 <gwern> hm.
11:10:43 <copumpkin> > Sum 4 `mappend` Sum 5
11:10:44 <lambdabot>   Sum {getSum = 9}
11:10:51 <gwern> sum?
11:10:57 <copumpkin> there are two monoids on the integers
11:10:58 <gwern> what the heck is Sum?
11:11:00 <copumpkin> Sum and Product
11:11:00 <gwern> @hoogle Sum
11:11:00 <lambdabot> Data.Monoid newtype Sum a
11:11:00 <lambdabot> Data.Monoid Sum :: a -> Sum a
11:11:00 <lambdabot> Prelude sum :: Num a => [a] -> a
11:11:00 <Cale> monadic_kid: But yes, the basic idea is that they're continuously changing values.
11:11:03 <copumpkin> simple wrappers :)
11:11:09 <copumpkin> > Product 4 `mappend` Product 5
11:11:11 <lambdabot>   Product {getProduct = 20}
11:11:17 <Cale> monadic_kid: Dependent on the behaviours and events in the UI.
11:11:20 <gwern> copumpkin: oh. I thought ints were like lists, only one monoid
11:11:29 <jethr0> > Sum 4 `mappend` Product 5
11:11:30 <lambdabot>   Couldn't match expected type `Sum t'
11:12:06 <copumpkin> gwern: yeah, although I'm not a fan of the newtypes :P
11:12:15 <copumpkin> can't be done any other way though, afaik
11:12:28 <Jedai> gwern: since there are two equally known monoids on them, it could trip people who would expect the one which is not chosen
11:13:23 <Jedai> gwern: at least that way everyone is surprised that there are no monoids on them and hopefully discover Sum and Product when they look for it
11:14:45 <gwern> mm. I guess I should've realized multiplication works as well as addition
11:16:04 <kerlo> > putStrLn "I have IO"
11:16:05 <lambdabot>   * Exception: "<IO ()>"
11:16:18 <sampointon> threadDelay is so underspecified in the docs :(
11:22:18 <gwern> ...gitit is so odd sometimes. john just added a 'deprofanizer' plugin, and the words it censors? '["darn", "blasted", "stinker"] '-- there are more, but this is a family program'
11:22:19 <byorgey> copumpkin: feeling dual today?
11:23:13 <copumpkin> byorgey: yes! I won't go into details about what changed direction to warrant the nick change, but it was scary
11:24:39 <gwern> wonder what a co-human would be like. would it consume feces and emit steak?
11:24:55 <vixey> yuck gwern
11:25:03 <copumpkin> so eating-centric :P
11:25:15 * ski . o O ( s/consume/nsume/ )
11:25:17 <gwern> vixey: but you could put a human and a co-human in a circle then
11:25:28 <copumpkin> lol
11:25:58 <copumpkin> @remember gwern wonder what a co-human would be like. would it consume feces and emit steak? you could put a human and a co-human in a circle then
11:25:59 <lambdabot> It is forever etched in my memory.
11:26:38 <byorgey> I am so NOT putting that in the HWN.
11:27:02 <copumpkin> :D
11:27:16 <jethr0> unfortunately, it is forever etched into my memory as well *argh*
11:28:02 <gwern> byorgey: man who died and make you editor of what quotes go in and don't?
11:28:39 <rdeshpande> what is the use case for not having a type constructor and value constructor match?
11:28:44 <byorgey> that would be dons, except for the dying part
11:28:50 <gwern> I say the world needs my homespun analogies to abstract concepts!
11:29:02 <rdeshpande> according to RWH, "Not only is it legal for a value constructor to have the same name as its type constructor, it's normal"
11:29:06 <rdeshpande> isn't this redundant?
11:29:11 <rdeshpande> data Foo = Foo ... ?
11:29:21 <byorgey> rdeshpande: you can have multiple data constructors, you know.
11:29:25 <Zao> Redundant to?
11:29:25 <gwern> for example, I've been pondering how monads are like tentacle-rape.
11:29:33 <byorgey> data Foo = Bar x | Baz y
11:29:34 <bd_> data Foo = Foo ... | Bar ... | Baz ...
11:29:43 <rdeshpande> oh cool!
11:29:59 <Berengal> Monads are like cars
11:30:06 <Berengal> And existentials are confusing me
11:30:07 <Zao> byorgey: Don't you need x and y defined somewhere?
11:30:32 <vixey> Berengal: I can' help
11:30:35 <Berengal> Someone tell me what a monotype is?
11:30:39 <vixey> Berengal: it's very simple existentials are like cars
11:30:58 <Berengal> vixey: exists Car, but GHC seems to disagree
11:31:09 <Berengal> It wants to know exactly what kind it is
11:31:15 <copumpkin> *
11:31:16 <Berengal> I'm content it has a steering wheel
11:31:41 <byorgey> Zao: sorry, I was just using x and y as metavaraibles.  Instead of x and y you could think "Int" and "Char"
11:32:10 <byorgey> Berengal: a monotype is a type that is not polymorphic.
11:32:23 <Zao> Or data Foo x y = Bar x | Baz y
11:32:25 <Berengal> But I want it to be polymorphic...
11:32:34 <Berengal> Just not too polymorphic
11:32:36 <monadic_kid> and have monobrow
11:32:36 <byorgey> Zao: right, you could do that too.
11:32:58 <byorgey> Berengal: what's the problem?
11:33:10 <Berengal> Right now I've got "type Environment = [forall e. (Expr e) => (Char, Either (Char, e) Int)]"
11:33:45 <Berengal> And now emacs died... just a sec
11:34:15 <byorgey> Berengal: that looks... strange.  are you trying to get a list where each element can have a different e ?
11:34:21 <Berengal> Yes
11:34:28 <Berengal> It doesn't complain about it there at least
11:34:32 <byorgey> well, I don't think what you've written will work.
11:34:44 <FalconNL> Berengal: I think I can help you
11:34:49 <byorgey> the forall e.  needs to be underneath a constructor
11:34:55 <FalconNL> I've tried several times to do something like that
11:34:59 <byorgey> so you'll need to make a new data type for the list elements.
11:35:03 <kadaver> was the idea of a compiler something revolutionary or obvious?
11:35:09 <FalconNL> In order to use your approach you would have to replace the forall with exists
11:35:10 <kadaver> back in the day I mean
11:35:20 <FalconNL> Unfortuntely, GHC only supports forall
11:35:56 <jethr0> kadaver: i think compilers evolved. they started out as macro substitution of assembly to machine language and then the assembly languages grew more complex
11:36:06 <sampointon> kadaver: how far back in the day? It used to be people laughed at machine translation because computers couldn't possibly craft assembly as well as human could
11:36:19 <FalconNL> The only way the currently do this is data MkEXpr = forall a. (Expr a) => M a, and have a [M a]
11:36:23 <byorgey> data ListElem = forall e. Expr e => LE (Char, Either (Char, e) Int)
11:36:49 <Berengal> http://codepad.org/JxESmT1f
11:37:01 <jethr0> but the step to higher-order languages and full-blown compilers was probably quite big. especially since in the beginning not much was known about grammers, parsing, etc.
11:37:17 <Berengal> There's quite some cruft on top... this was part of my sandbox file until I yanked it out
11:37:55 <vixey> FalconNL: EHC supports exists
11:38:17 <byorgey> does it? neat.
11:38:17 <Berengal> FalconNL: I did use a data MkExpr, and that worked. I was looking to find a way which didn't involve that though
11:38:17 <ski> vixey : in which positions ?
11:38:25 <vixey> ski everywhere
11:38:27 <FalconNL> vixey: yeah, and so does UHC. If only they would incorporate it in GHC :)
11:38:39 <jethr0> who are the main develops of UHC/EHC that are also on this channel?
11:38:42 <vixey> I want to use UHC
11:38:51 <FalconNL> Berengal: Join the club. I'm still waiting for exists in GHC too.
11:38:56 <jethr0> s/develops/developers/
11:38:57 <byorgey> Berengal: I don't think there is.
11:39:00 <ski> vixey : so `f :: forall a. Foo a => F a -> exists b. Bar a b *> G a b' is fine ?
11:39:22 <Berengal> This is the first time it's actually the implementation, not my brain, that is hampering my coding in Haskell...
11:39:36 <byorgey> hehe
11:39:41 <Athas> Are the fancy and apparently widely-used GHC extensions implemented anywhere else?
11:39:44 <byorgey> that's a good sign =)
11:40:07 <BONUS> Athas: some are. i think hugs has fundepds?
11:40:10 <vixey> ski, I don't know exactly but I think so
11:40:25 <jethr0> Athas: not uniformly, but many are implemented by other compilers uhc, jhc, ...
11:40:27 <vixey> ski, I mean it seems to let you ptu exists anywhere you could have forall
11:40:31 <Berengal> byorgey: Yes, I'm very pleased about that. I've been coding for almost two years now... In Java I reached the limits of the implementation after just two weeks
11:40:40 * ski know jhc has `exists', but only in positions where it could be expanded away to `forall', last time i checked
11:41:15 <ski> (i.e. like `f :: (exists a. F a) -> G', which is the same as `f :: forall a. F a -> G')
11:41:52 <jethr0> Berengal: not sure what you mean by "limits of the implementation". i recently revisited java and was appalled how much duplication and "routing around the damage" i had to do.
11:42:20 <ski> (.. Mercury has the equivalent of `newStore :: exists s. Store s')
11:42:59 <Athas> Haskell needs ON ERROR RESUME NEXT.
11:43:31 <jethr0> *NOOOOOOooooooo*
11:44:06 <ski> maybe someone should try to design a condition system (with restartable conditions), for haskell ?
11:44:13 <jethr0> "ON ERROR RESUME NEXT" combined with lack of assignment leads to a blissful "absence" of errors ;
11:44:16 <Berengal> jethr0: That's basically what I meant. One of the first things I encountered was having a GameBoard of GamePieces such a subtype Board could only hold a certain type of pieces, and a given type of piece could only interact with a given type of board. This proved impossible, and I had to use lots of casting
11:44:46 <jethr0> what annoyed me most in java (among many other things) was the absence of type aliases
11:45:09 <Athas> Restartable conditions are truly awesome in the languages that I'm used to, but I'm as of yet uncertain that they make sense (or are useful) in Haskell.
11:45:22 <jethr0> and cumbersome definition of data types that have such an incredibly low overhead in haskell
11:45:34 <Berengal> I had something like ChessBoard<ChessBoard, ChessPiece<ChessPiece, ChessBoard>>...
11:45:40 <vixey> you don't define "data types" in java :p
11:45:52 <jethr0> Athas: which languages have restartable conditions? would this be sth similar to STM?
11:47:10 <jethr0> i sometimes wonder why perfectly easy to implement features are lacking from programming languages. like type aliases from java or let-bindings from Excel.
11:47:18 <Athas> jethr0: I have experience with Common Lisp's condition system, which supports restartable conditions.
11:47:35 <Athas> I do not know what STM is.
11:47:45 <ski> Software Transactional Memory
11:48:44 <jethr0> ah, yes i've seen those in lisp. quite a nice feature especially for exploratory programming and prototyping. might not mix too well with laziness though(?)...
11:48:47 <Athas> I can't imagine that would have much to do with restartable conditions.  They are basically just really souped up gotos.
11:49:02 <jethr0> or continuations rather
11:49:37 <Athas> Quite likely, Lisp's condition handlers have dynamic scope.  That would certainly wreak havoc with laziness.
11:50:03 <Cale> Athas: You can have a monad for computations with first-class continuations
11:50:29 * bremner is waiting impatiently for Cale's scip in Haskell
11:50:41 <copumpkin> sicp?
11:51:04 <copumpkin> the structure and computation of interpreted programs
11:52:48 <bremner> uh, so impatient, I can't type
11:53:09 <kadaver> structure and interpretation of computer pgroams
11:53:11 <kadaver> if i may
11:53:23 <DrSyzygyFR> Graaargh!
11:53:23 <kadaver> structure and interpretation of computer programs
11:53:34 <copumpkin> kadaver: I was being silly :P
11:53:45 <DrSyzygyFR> Not very surprising, it turns out that once I've implemented the stuff I've been working on, the Complexity starts really killing me.
11:53:49 <vixey> continuations are not gotos or anything like goto at all
11:53:56 <copumpkin> kadaver: I've taken the course :P
11:53:56 <vixey> I wish people would stop thinking that
11:55:07 <Saizan_> DrSyzygyFR: maybe profiling will find some easy spot to optimize
11:55:12 <DrSyzygyFR> Saizan_: Yup!
11:55:13 <kadaver> and you coded a scheme compiler with gc in asm?
11:55:19 <kadaver> like a rela programmer
11:55:29 <mightybyte> Is there something similar to (.) that does :: (c -> d) -> (a -> b -> c) -> a -> b -> d ?
11:55:48 <mightybyte> ...on generalizes to even more arguments for the second parameter?
11:55:49 <vixey> :t (.).(.)
11:55:50 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
11:55:53 <DrSyzygyFR> The most expensive parts of the program are comparing my basic datatype, and generating the stuff needed in order to compare the datatypes.
11:56:04 <DrSyzygyFR> Each time I do any of these, I traverse my tree type<
11:56:22 <mightybyte> :t (.).(.).(.)
11:56:23 <lambdabot> forall a a1 b c a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
11:56:35 <mightybyte> Slick
11:56:37 <DrSyzygyFR> And most of the things I do are arithmetic on formal linear combinations of the tree type, stored as a Data.Map form the trees to my coefficient type.
11:56:52 <ski> these are traditionally (according to me) called `(.:)',`(.::)',..
11:56:55 <copumpkin> kadaver: nope, but I've done a fair amount of asm other than garbage-collecting scheme compilers ;)
11:56:57 <DrSyzygyFR> So, everytime anything is done in Data.Map, stuff gets compared, and everythign I do causes these comparisons.
11:57:19 <DrSyzygyFR> And the comparisons, in turn, are done by floodfilling a tree - on normally not more than, say, 5-6 vertices, but it gets done a LOT.
11:57:32 <jethr0> @compose pl djinn (c -> d) -> (a -> b -> c) -> a -> b -> d
11:57:32 <lambdabot> f = (.) . (.)
11:57:49 <jethr0> hehe
11:58:29 <Athas> Saucy.
11:59:11 <DrSyzygyFR> One computation I have running ended up breaking off due to too much stack consumed.
11:59:32 <DrSyzygyFR> So I'm experimenting setting strictness flags in my basic type definition.
11:59:45 <DrSyzygyFR> But I really could help some help above my own cargo cultishness.
12:00:43 <DrSyzygyFR> Hrm.
12:00:46 <DrSyzygyFR> *need some help
12:01:02 <Saizan_> DrSyzygyFR: can you paste the code? and do you know which function caused the stack-overflow?
12:01:10 <DrSyzygyFR> Saizan_: Yes. And no.
12:01:27 <DrSyzygyFR> Careful though, it's a bit of a read... :-P
12:02:22 <Saizan_> heh, i don't promise anything :)
12:02:32 <DrSyzygyFR> Saizan_: http://math.stanford.edu/~mik/Operads
12:02:41 <DrSyzygyFR> That's the whole she-bang.
12:02:58 <DrSyzygyFR> It starts out, though, with a bunch of not quite as domain specific basic definitions
12:04:10 <Saizan_> and you also have an example that triggers the overflow?
12:04:13 <DrSyzygyFR> So, actually, http://math.stanford.edu/~mik/Operads/src/OperadGB.html is the relevant bit.
12:04:22 <DrSyzygyFR> Saizan_: Yup. After about an hours execution :-P
12:04:54 <DrSyzygyFR> (running with -O2 and monopolizing one of my processor cores....)
12:05:42 <DrSyzygyFR> hpaste is down? What's a good pasting place instead!?
12:05:42 <Saizan_> arg, fortunately we can reduce the stack size with +RTS options
12:06:02 <Saizan_> DrSyzygyFR: http://moonpatio.com
12:06:58 <DrSyzygyFR> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2240#a2240
12:07:07 <DrSyzygyFR> This example (built to be easy to paste into ghci)
12:07:13 <DrSyzygyFR> And what I try to compute with this is
12:07:19 <DrSyzygyFR> head gbn1
12:07:41 <DrSyzygyFR> And that hasn't terminated as far as I've tried so far.
12:11:21 <eu-prleu-peupeu> whats the difference between existencial types and defining an instance of a type class ? :/
12:12:55 <eu-prleu-peupeu> probably the only place where they are related is in my mind :/
12:13:20 <DrSyzygyFR> Saizan_: How would I be able to tell why my stack is running out?
12:13:21 <jethr0> eu-prleu-peupeu: that was my first thought, yes ;)
12:13:31 <jethr0> eu-prleu-peupeu: what similarity do you see?
12:13:37 <DrSyzygyFR> Suppose I do set down my stack size, what do I do to diagnose?
12:13:46 <jethr0> DrSyzygyFR: stack/heap profiling
12:15:20 <Cale> eu-prleu-peupeu: Existential types allow some type involved in a piece of data to range over any of the instances of a class, and forget what type it was.
12:15:34 <Cale> eu-prleu-peupeu: (aside from the fact that it was an instance)
12:15:41 <Saizan> DrSyzygyFR: you can also run the code under :trace in the ghci debugger after :set -fbreak-on-exception
12:16:09 <Cale> eu-prleu-peupeu: If you have a specific instance of a class though, you might be able to do all sorts of other things to it.
12:16:16 <DrSyzygyFR> I've done that to find a few elusive bugs alread.y
12:16:29 <DrSyzygyFR> The history I get access to after that doesn't go very deep though.
12:16:35 <Cale> For example, there are lots of things you can do with Doubles which you can't just do with any instance of Num
12:17:07 <eu-prleu-peupeu> i see
12:17:12 <eu-prleu-peupeu> nice, its a constraint
12:17:24 <eu-prleu-peupeu> in xmonad they define this existential type: data Layout a = forall l. (LayoutClass l a, Read (l a)) => Layout (l a)
12:18:32 <Berengal> eu-prleu-peupeu: Yeah, it's basically a constraint. It gives you polymorphism without being too polymorphic
12:18:41 <eu-prleu-peupeu> hmm
12:19:01 <eu-prleu-peupeu> they address the problem i was trying to solve with messages in xmonad with a existential type
12:19:20 <Berengal> functions have existential types already
12:19:25 <Berengal> They're just implicit
12:19:25 <Jedai> eu-prleu-peupeu: existentials are the closest thing to objects you can have in Haskell without complex constructions
12:19:33 <DrSyzygyFR> I've done the ghc -prof && ./Function +RTS -p analysis already.
12:19:43 <DrSyzygyFR> I get about 10 deep according to the indents to the right.
12:19:47 <eu-prleu-peupeu> instead of just: data Message = Hide | ReleaseResources | ShowMonkey  (which would be highly inextensible)
12:20:02 <DrSyzygyFR> (at least after running it for 15 minutes, not until it ran out of stack...)
12:20:22 <eu-prleu-peupeu> they define an existential
12:20:25 <eu-prleu-peupeu> for message
12:20:52 <eu-prleu-peupeu> is like saying "hey a message is something that has this typeclass, but its up to you to define it"
12:21:25 <eu-prleu-peupeu> then i would only be able to mingle with them through the typeclass methods
12:21:27 <eu-prleu-peupeu> okey
12:21:37 <Cale> There's a sense in which existentials seem to me to be the refined essence of object oriented programming.
12:21:53 <kadaver> when doing genetic programming, for real hardcore stuff, would you use harpy to generate machine code?
12:21:54 <eu-prleu-peupeu> what is the dot (.) after the forall variable ?
12:21:57 <eu-prleu-peupeu> composing ? :P
12:21:58 <kadaver> rather than interpret
12:22:02 <Cale> eu-prleu-peupeu: just punctuation.
12:22:05 <eu-prleu-peupeu> forall a. Message a => bla bla
12:22:14 <eu-prleu-peupeu> ah
12:22:20 <Saizan> DrSyzygyFR: maybe the other method listed here will give more information? http://haskell.org/haskellwiki/GHC:FAQ#My_program_is_failing_with_head_.5B.5D.2C_or_an_array_bounds_error.2C_or_some_other_random_error.2C_and_I_have_no_idea_how_to_find_the_bug._Can_you_help.3F
12:22:20 <eu-prleu-peupeu> it reads like "in"
12:22:30 <Cale> It separates the list of variables being quantified from the rest of the type
12:22:31 <eu-prleu-peupeu> forall a "in" Message a ?
12:22:39 <Cale> forall a b. (a -> b) -> [a] -> [b]
12:22:45 <Berengal> Cale: Existentials are a natural extension of parameterized polymorphism to me
12:22:45 <eu-prleu-peupeu> ah okok
12:23:14 <eu-prleu-peupeu> cool
12:23:15 <Jedai> eu-prleu-peupeu: rather like a comma in english
12:23:42 <Cale> Berengal: yes, but at the same time, OO programming is all about *forgetting* what the actual type of something was and remembering only its behavioural interface
12:23:47 <Jedai> eu-prleu-peupeu: in mathematics, you say forall a, a == 5
12:23:54 <Cale> and this is exactly what existentials do
12:24:00 <DrSyzygyFR> Saizan: Setting things up....
12:24:28 <Berengal> Cale: OO is so many things, I don't think there's one good definition for it
12:24:44 <Berengal> You could say it's like encapsulation though
12:25:09 <Cale> The way that I look at it, OO programming is for the most part a consequence of this view of design.
12:25:32 <Cale> (Even when dynamically typed)
12:25:32 <eu-prleu-peupeu> its usefull in some specific areas
12:25:38 <eu-prleu-peupeu> like this of "message passing"
12:25:39 <Saizan> DrSyzygyFR: though i'm running it with -K32k and i'm not seeing a stack overflow, it takes a lot of time, eh?:\
12:25:47 <DrSyzygyFR> Well... yeah.
12:26:04 <eu-prleu-peupeu> even though i would like to know how i would do it with behaviours and events in reactive :D
12:26:08 <DrSyzygyFR> It seems to me to be quite lean on memory; and it took the better part of an hour to provoke that stack overflow.
12:26:17 <DrSyzygyFR> And since I got that, I added the strictness annotation in my basic datatype....
12:26:26 <DrSyzygyFR> Okay.
12:26:30 <DrSyzygyFR> Scratch quite lean.
12:26:38 <DrSyzygyFR> The big-ass researchproblem size computation I have running....
12:26:43 <Cale> Despite the fact that smalltalk doesn't have a static type system, one still must consider something like the "type" of an object when working with it, and that consists of the set of messages which it will accept.
12:26:51 <DrSyzygyFR> It's up to 2h30 processor time.
12:26:57 <DrSyzygyFR> Consumed just over 2M all in all.
12:27:14 <Cale> Which is more or less the same thing as saying that there exists a type which accepts those messages and is the real type of the object.
12:27:37 <Saizan> yeah, it uses very little memory
12:28:04 <Berengal> Cale: The way I see it, OO is just a convenient way to declare newtypes of structs and functions over them...
12:28:53 <Berengal> It doesn't fit all the time, but it fits most of the time, even in dynamic languages
12:29:14 <Berengal> OO is simply not well defined
12:30:03 <eu-prleu-peupeu> what does the type class Typeable defines ?
12:30:22 <Saizan> the most common feature of OO is open recursion
12:30:41 <Cale> Well, I tend to view OO and FP as somewhat dual in this sense that FP puts slightly more emphasis on universal quantification, and OO puts slightly more emphasis on existential quantification.
12:31:28 <eu-prleu-peupeu> the most common feature of OO is Eclipse
12:31:44 <eu-prleu-peupeu> "hey thats a nice feature"
12:32:54 <Cale> class Typeable a where
12:32:54 <Cale>    typeOf :: a -> TypeRep
12:33:05 <Cale> I think that almost speaks for itself.
12:33:16 <Cale> It gives you a way to get a representation of the type of something.
12:33:31 <Cale> But, the more magical part of the Typeable library is:
12:33:36 <Cale> cast :: (Typeable a, Typeable b) => a -> Maybe b
12:34:09 <Cale> Which is defined such that the result of the function is Just x if and only if a and b were really the same type.
12:34:20 <Cale> If the types don't match, you get Nothing.
12:34:38 <Cale> So it lets you recover forgotten type information.
12:35:10 <Cale> cast can't be implemented in Haskell though.
12:35:27 <Cale> You have to treat it as a language primitive, or expressible only in terms of unsafe functions.
12:35:53 <Cale> Actually, you shouldn't be allowed to write instances of Typeable by hand, because you can break Haskell's type system by doing so.
12:36:09 <Cale> (they really should only be derivable)
12:36:15 <Berengal> Cale: How so?
12:36:56 <mauke> http://okmij.org/ftp/Haskell/types.html#unsound-typeable
12:37:18 <Cale> You can write an instance which gives the wrong TypeRep, one which matches some other type, and then do a cast, and it will reinterpret the data as a member of the other type.
12:37:26 <Cale> (and possibly segfault)
12:38:17 <Berengal> Ah, so unsafeCoerce
12:38:23 <Cale> more or less, yes
12:39:48 <Berengal> This is the same problem found in OO though. Either you have to include RTTI or your casts won't be safe
12:40:04 <Cale> right
12:40:32 <DrSyzygyFR> SRSLY!
12:40:36 <xxgodsmackxx321> http://www.rewards1.com/index.php?referrer_id=281917
12:40:47 <DrSyzygyFR> Max residency of just a tad over 80k
12:40:53 <Cale> So Typeable basically implements RTTI, but writing instances by hand is bad.
12:41:29 <DrSyzygyFR> So ... ehh ... yeah, this program is insanely hard on the processor and hardly touches memory.
12:41:43 <DrSyzygyFR> I have a strong feeling that it's very parallellisable too.
12:41:45 <vixey> well what is the problem with typeab/e
12:41:58 <vixey> you can do a version without unsafeCoerce if you use a GADT
12:42:12 <Cale> vixey: Oh? Interesting.
12:42:14 <vixey> the thing is the GADT can't capture certain things, but are those things actually used dynamically?
12:43:15 <Cale> vixey: How does that work?
12:43:37 <vixey> Cale, there is a simple version here, http://muaddibspace.blogspot.com/2009/01/datadynamic-without-typeclasses-or.html
12:45:39 <Cale> vixey: ah, okay, I see
12:46:31 <Cale> The guarantee that typereps match their types is encoded in the way in which the constructors of the DYN type make use of the type parameter.
12:46:52 <Cale> and the fact that the type variables match in various other places
12:47:39 <Cale> But of course, that suffers from the problem of not being open.
12:47:58 <Cale> So you can't add new types to it in future modules.
12:48:55 <vixey> I suppose something like  DYN types t  rather than  DYN t  where types is a list of types would let you use more types
12:49:16 <vixey> but then you have to throw this big type level list around
12:49:18 <Cale> aha, yeah
12:49:27 <vixey> not sure how that would be like in practice
12:50:00 <Cale> I can imagine it would not be too much more convenient than a sort of wrapper around Either. :)
12:50:28 <Cale> Heh, a sort of dual to HLists
12:50:34 <Cale> Sums instead of products :)
12:56:48 * vixey is sad UHC doesn't implement GADTs
12:57:09 <vixey> I suppose it's possible to desugar GADTs into ADTs + exists or something though
13:00:22 <vixey> http://twan.home.fmf.nl/blog/haskell/non-regular1.details wow
13:00:34 <vixey> so much comments
13:01:05 <Cale> I'm more sad that GHC still doesn't have a nice polymorphic extensible record/variant system.
13:01:27 <copumpkin> yeah!
13:01:39 <copumpkin> they could have some sort of implicit typeclass for those
13:01:41 <ski> (you need `Equal', too)
13:01:50 <Cale> There's been a lot of messing about with typeclasses and GADTs to approximate such a thing, but none of them come close to being convenient for real use.
13:02:37 <FalconNL> Cale: couldn't agree more.
13:02:43 <ryanakca> Can someone please take a look at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2239 (Question and the relevant code)
13:03:23 <copumpkin> ryanakca: you don't need (xs) parentheses
13:03:39 <copumpkin> and you don't need parentheses around the RHS either
13:03:42 <copumpkin> x : toList xs
13:03:43 <vixey> ryanakca:  fromList = foldr Cons Nil
13:03:53 <vixey> ryanakca:  toList = foldList (:) []
13:04:02 <BONUS> ryanakca: also try toList $ Cons 'd' (Cons 'n' Nil)
13:04:15 <ryanakca> Woah. I'm only at chapter 3 of RWH ;)
13:04:28 <ryanakca> Thanks all :)
13:04:41 <BONUS> basically when you do toList Cons 'd' (Cons 'n' Nil)
13:04:54 <BONUS> it thinks you're giving Cons as the parameter to toList
13:05:01 <BONUS> instead of the whole Cons 'd' (Cons 'n' Nil)
13:05:06 <copumpkin> @tell mmorrow zomg hpaste is down
13:05:06 <lambdabot> Consider it noted.
13:05:13 <BONUS> also you can do toList (Cons 'd' (Cons 'n' Nil)
13:05:20 <BONUS> in what way is it down
13:05:24 <ryanakca> What do 'foldr', '$' stand for?
13:05:39 <copumpkin> fold right
13:05:45 <copumpkin> DOLLAR
13:05:45 <ski> "fold right","apply to"
13:05:51 <BONUS> $ is function application, only it has really low precedence
13:05:51 <Cale> ryanakca: foldr f z is a function which replaces each (:) in a list with f and the [] at the end with z
13:06:12 <ryanakca> Ah, I see :)
13:06:14 <BONUS> basically f (g x y) can be written as f $ g x y
13:06:17 <vixey> ryanakca: Every ADT has a corresponding fold function, for some weird reason they called it 'foldr' to try and hide that it's a general notion
13:06:19 <newsham> mmm primitive recursion on lists.
13:06:20 <BONUS> to avoid parens
13:06:32 <Cale> ryanakca: Similarly, it's common to write functions which replace the constructors of a datatype with other functions and values, and call them folds, or if you want to be fancy, catamorphisms.
13:06:41 <vixey> ryanakca, anyway if you define both folds it makes the isomorphism between [] and List strikingly clear
13:06:50 <BONUS> vixey: but doesn't every ADT have two fold functions?
13:06:55 <ski> nope
13:07:01 <vixey> BONUS: I only know one, what's the other?
13:07:11 <BONUS> uh well on lists it's foldr and foldl
13:07:15 <ryanakca> Ah, ok
13:07:18 <vixey> oh right
13:07:36 <vixey> foldr and foldl are not really related at all
13:07:47 <vixey> that's why I was saying it's weird they chose to name them like a pair of functions
13:07:59 <BONUS> well i see some similarities
13:08:24 <ski> BONUS : what's the "other" fold for `data Tree a = Node a [Tree a]' ?
13:08:38 * vixey thinks foldl and foldr are as similar as mother mary to a courgette
13:08:44 <copumpkin> they do seem related to me, it's just that foldr has a much more elegant and "fundamental" interpretation
13:08:47 <BONUS> ah yeah hmm ski i see what you mean
13:09:02 <copumpkin> they're related from a pragmatic point of view, rather
13:09:11 <newsham> there are several "relations" :)
13:09:16 <BONUS> i was going from the  Foldable viewpoint that if you implement foldMap you get foldr and foldl for free
13:09:21 <newsham> like foldr of reverse xs with flip f ?
13:09:30 <vixey> @go foldr foldl relation
13:09:31 <lambdabot> http://haskell.org/haskellwiki/Foldr_Foldl_Foldl'
13:09:31 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
13:09:37 <vixey> hm
13:09:43 <BONUS> i will have a read
13:09:49 <vixey> I didn't mean to link that
13:10:03 <copumpkin> I love these: http://foldr.com/
13:12:07 * glguy wonders how many bits are in a "long long time"...
13:12:30 <copumpkin> 726
13:12:50 * DrSyzygyFR starts thinking that those four (!) strictness annotations fixed my stack growth issue.
13:13:18 <copumpkin> I wouldn't be too surprised
13:13:29 <copumpkin> although I thought normally strictness annotations would fix heap growth?
13:14:05 <DrSyzygyFR> copumpkin: I don't know. I've had one stack overflow so far, and a few tweaks - one of which was these few annotations, and now I basically consume no memory whatsoever.
13:14:21 <copumpkin> I guess you'd build a huge thunk on the heap
13:14:26 <copumpkin> and evaluating it would cause a stack overflow
13:14:35 <DrSyzygyFR> Something like that maybel.
13:14:39 <DrSyzygyFR> I'm recursing a LOT.
13:14:58 <DrSyzygyFR> Every single operation is a tree search.
13:15:10 <DrSyzygyFR> Admittedly, my trees are small - very seldom larger than 5-6 vertices.
13:15:19 <DrSyzygyFR> But they get searched through and traversed a LOT.
13:15:30 <copumpkin> hmm
13:15:39 <copumpkin> what's the range of your keys?
13:15:49 <DrSyzygyFR> What do you mean?
13:15:54 <DrSyzygyFR> Maybe I should be clearer...
13:16:16 <DrSyzygyFR> I'm implementing a type of computer algebra that uses trees instead of variables and tree composition instead of multiplication.
13:16:40 <DrSyzygyFR> So I'm traversing the trees to keep track of their structure, and in order to extract information that will allow me to order them
13:16:53 <copumpkin> ah, interesting, what do the edges and vertices of the trees represent?
13:17:02 <DrSyzygyFR> Edges are irrelevant.
13:17:25 <DrSyzygyFR> Internal vertices represent a generalization of many-to-one algebraic operations.
13:18:00 <DrSyzygyFR> Leaf vertices represent "terms" in the resulting algebraic theory.
13:18:56 <copumpkin> :o
13:19:19 <copumpkin> DrSyzygyFR: you planning to release this? :)
13:19:25 <DrSyzygyFR> And we're trying to build a computer algebra systems
13:19:30 <DrSyzygyFR> Oh yes!
13:19:38 <DrSyzygyFR> And it's gonna make a splash in this corner of mathematics researhc!
13:19:39 <copumpkin> I look forward to seeing it :)
13:19:43 <copumpkin> awesome
13:19:53 <copumpkin> I have a book on computer algebra systems but I've only leafed through it
13:19:58 <DrSyzygyFR> But right now it would be nice to ... y'know ... being able to complete one single computation of something.
13:20:00 <copumpkin> haven't seen anything like this though
13:20:16 <DrSyzygyFR> copumpkin: This is all building on a preprint released last December, defining Gröbner bases for these gadgets.
13:20:31 <copumpkin> ah
13:20:39 <DrSyzygyFR> One of the coauthors of that and me have been coding every free minute for the last week (we're just outside Marseille at a conference now) to get this working.
13:20:56 <DrSyzygyFR> SAnd it turns out that if you CAN compute a Gröbner basis, then you can do all sorts of funky things.
13:21:20 <copumpkin> like what?
13:21:33 <DrSyzygyFR> The gadgets are called Operads.
13:21:43 <DrSyzygyFR> And it turns out that one important property an operad can have is being Koszul.
13:21:50 <copumpkin> :o
13:21:52 <DrSyzygyFR> If it is Koszul, there are VERY many cool things you can do with them.
13:22:07 <DrSyzygyFR> So people churn out papers about things like "The operad BLAH is Koszul"
13:22:12 <DrSyzygyFR> Now.
13:22:19 <copumpkin> lol
13:22:27 <DrSyzygyFR> If an operad has a Gröbner basis with all terms quadratic, then it is Koszul.
13:22:46 <DrSyzygyFR> So if this gets efficient, then it could be used to automate significant parts of this field. :-P
13:23:04 <copumpkin> :o
13:23:24 <DrSyzygyFR> Also, there seems to be one question in algebra, subject of at least one Fields medal for partial results so far, that can be rephrased as whether a certain operad has a Gröbner basis with specific properties.
13:26:50 <gio123> DrSyzygyFR: that is Buchberger basis
13:27:50 <kadaver> My high school paper: On Koszul circuits and temporary logic
13:28:24 <kadaver> On the behavioural economy of self-aware software
13:28:58 <kadaver> >>>===>>==>= monadrockets
13:29:12 <kadaver> im quitting software, going into electric cars instead
13:29:49 <Berengal> Software is like cars
13:30:19 <mstr> monads are like cars
13:30:34 <Berengal> Software is like monads
13:31:28 <copumpkin> cars are like software
13:31:31 <copumpkin> oh wait!
13:31:40 <mmmulani> is there an equivalent to the list-ref function from scheme?
13:31:42 <thoughtpolice> copumpkin: is this the bizarro you?
13:31:47 <copumpkin> thoughtpolice: yeah
13:31:51 <Berengal> Monad transformers are like "yo dawg, I herd u like monad composition so I put a monad in your monad so you can bind while you bind"
13:31:59 <thoughtpolice> i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
13:32:00 <mmmulani> that is, (list-ref 10 [2..15]) = 11
13:32:20 <Berengal> Hmmm... BizzaroMonad?
13:32:35 <Botje> @remember thoughtpolice i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
13:32:36 <lambdabot> Done.
13:32:46 <DrSyzygyFR> gio123: It's Gröbner basis.
13:32:55 <Toxaris> > [2..15] !! 10
13:32:56 <lambdabot>   12
13:33:01 <DrSyzygyFR> Just because Buchberger created them doesn't change their common name.
13:33:04 <mauke> @hoogle [a] -> a -> Int
13:33:05 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:33:05 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
13:33:05 <lambdabot> Prelude (!!) :: [a] -> Int -> a
13:33:13 <DrSyzygyFR> kadaver: Really? You did Koszul stuff in High school??
13:33:51 <Gracenotes> hm, I feel somewhat evil for recursively wgetting 85 MB of PDFs from my university website in approximately a minute
13:34:04 <Gracenotes> but, really, what could I do? rate limit? psssh.
13:34:10 <Gracenotes> ..
13:34:13 <Berengal> Universities have unlimited bandwidth
13:34:15 <mauke> -w5 --random-wait
13:34:44 <FalconNL> Hm. Can anyone tell me why the following function is so slow and memory-hungry (1.86 seconds and 261MB for 800x600 pixels)?
13:34:44 <Gracenotes> hm, I suppose. At least I don't have to download a PDF whenever I want to read a course description
13:34:45 <FalconNL> dummy :: [[Pixel]] -> [Word8]
13:34:47 <FalconNL> dummy = map fromIntegral . concatMap (foldl' (\ws (Pixel r g b _) -> b:g:r:ws) [])
13:34:56 <wli> What's this about Grobner bases?
13:34:57 <Gracenotes> er, except next semester
13:34:59 <Berengal> I unwittingly managed to dos norway's largest newspaper with my university's bandwidth for a few seconds using a recursive wget...
13:35:28 <Gracenotes> oops.
13:35:42 <Gracenotes> although that might say more about Norway than your University. just sayin.
13:36:02 <sampointon> I thought Norway had a pretty good network infrastructure
13:36:06 <Berengal> We do
13:36:32 <Berengal> Our universities have the best...
13:37:00 <smtms> you wanna DoS somebody? enroll in a university in Norway
13:37:11 <Berengal> Unless I'm mistaked the University of Oslo has a direct connection to NIX...
13:37:15 <Berengal> mistaken*
13:37:25 <Gracenotes> smtms: they should put that on all of their bulletins
13:38:05 <BONUS> hey ski
13:38:29 <BONUS> here's two folds on a Tree a = Node a [Tree a]
13:38:33 <BONUS> http://pastie.org/459001
13:39:20 <BONUS> does that look correct?
13:39:34 <Gracenotes> Berengal: well, I'm positive that your university's network infrastructure is better than mine. At least the residential end of it. :\
13:39:37 <Gracenotes> you'
13:39:51 <Gracenotes> you'd think the routers could do basic DHCP... but no...
13:40:08 <Berengal> Oh, I wasn't on a residential computer :)
13:40:13 <Gracenotes> it works most of the time at least >_<
13:40:19 <Philippa_> FalconNL: you're building an 800x600 list-of-lists and then flattening it. That's not too speedy :-(
13:40:52 <Philippa_> I wouldn't be too surprised if it was being done strictly too
13:40:52 <Luke> I'm trying to make class views but I can't seem to get the __call__() to work. I think I need to make an instance of my class and pass it that but I'm missing something
13:40:59 <Luke> here's what I'm trying to follow: http://docs.djangoproject.com/en/dev/topics/http/urls/#passing-callable-objects-instead-of-strings
13:41:06 <mauke> Luke: wat
13:41:47 <Luke> trying to use callable objects for views
13:41:52 <Luke> cant get it to work
13:41:57 <mauke> Luke: this is #haskell.
13:42:00 <Luke> haha
13:42:01 <Luke> dam
13:42:09 <Luke> clicked the wrong chan =)
13:42:11 <Luke> thanks
13:42:42 <wli> Let's say that one has \sum a_{i,j} x_i^j = c_j to supply n equations in n unknowns... construct an eigensystem describing the solutions of the equation as eigenvectors.
13:42:49 <BONUS> @seen ski
13:42:50 <lambdabot> ski is in #haskell.se, ##logic and #haskell. I last heard ski speak 34m 26s ago.
13:43:01 <ski> @seen BONUS
13:43:01 <lambdabot> BONUS is in #haskell. I last heard BONUS speak 11s ago.
13:43:11 <copumpkin> @seen bonuski
13:43:11 <lambdabot> I haven't seen bonuski.
13:43:13 <mauke> preflex: seen preflex
13:43:13 <preflex>  what
13:43:20 <BONUS> czech this out: two folds on a rose tree http://pastie.org/459001
13:44:49 <ski> (BONUS : fyi (only), my browser displays nothing at all, for that link)
13:45:02 <BONUS> strange, what's the other haskell paste?
13:45:24 <mauke> works here
13:45:57 <ski> <http://moonpatio.com>, i believ
13:45:58 <ski> e
13:46:12 <BONUS> ah it works now
13:46:16 <BONUS> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2243#a2243
13:46:53 <BONUS> basically the first one does it from the bottom right up and the second one from the bottom left up
13:47:27 <ski> BONUS : ok, now try `data Nest a = Node a (Nest [a])' and `data Bundle a = Node a (Bundle (Bundle a))'
13:47:56 <wli> So, one has a little language. How does one typecheck it when modules are added to it?
13:48:42 <BONUS> ah i see what you mean
13:48:56 <ski> (BONUS : or even `data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)')
13:49:00 <rdeshpande> BONUS: cool tutorial
13:49:10 <BONUS> so every ADT has a reducing function i.e. a fold, some have two but not necessarily?
13:49:15 <BONUS> rdeshpande: thankyou :)
13:49:24 <rdeshpande> i am reading it with RWH right now
13:49:30 <rdeshpande> my second day with haskell
13:49:33 <ski> (BONUS : or `data BinTree2 a = Tip | Node a (BinTree2 a) (BinTree2 a)')
13:49:44 <BONUS> i hear it is a good combination with RWH
13:50:15 <monochrom> In general there should not be any limit on the variety of folds.
13:50:28 * copumpkin tries to decide whether to make his epic folds into Monads or not
13:51:07 <ski> wli : assuming non-cyclic dependency graph amongst modules, try typechecking in toplogicical order, keeping tables of type signatures for exported operations ?
13:51:30 <DrSyzygyFR> copumpkin: Do it!
13:51:40 <copumpkin> hmm
13:51:44 <monochrom> Take binary tree for example. There are already in-order, pre-order, post-order folds. You could also have a fold that is in-order for the first level, post-order for the second level, ...
13:51:48 <copumpkin> I just don't see a benefit in defining a monad instance on it
13:51:54 <copumpkin> even though I could
13:52:04 <wli> ski: At least you responded.
13:52:12 <copumpkin> I guess I shouldn't assume someone else won't find a use for it though
13:52:23 <monochrom> The only general uniform thing you can say is a general recursion scheme over your ADT, then all folds are special cases.
13:52:47 <BONUS> aha, interesting
13:53:02 <ski> copumpkin : if it's a monad, then i say go for it (the instance)
13:53:24 <monochrom> Even with lists, why limit to just left and right? You could start your fold from the middle.
13:53:55 <monochrom> How about a list fold that's left for prime-indexed items and right for the rest?
13:54:10 <DrSyzygyFR> monochrom: That'd make sense with the (I think it is) comonads that you get by having your "current point", and then lists for left and right...
13:54:16 <DrSyzygyFR> Wouldn't it?
13:55:10 <ski> (copumpkin : btw, might you elaborate on what your `epic folds" are, and how they're monads ?)
13:55:17 <copumpkin> lol
13:55:24 <ski> wli : maybe your language doesn't fit that approach ?
13:55:25 <copumpkin> so I'm not positive they're monads yet
13:55:33 <copumpkin> but I feel like I could probably define an instance for them
13:55:40 <copumpkin> that satisfied the laws
13:56:01 <copumpkin> I just expanded on the work in http://squing.blogspot.com/2008/11/beautiful-folding.html
13:56:09 <copumpkin> it's not my idea by any means
13:56:18 <DrSyzygyFR> HAH!
13:56:23 <DrSyzygyFR> I _DO_ get stack overflows!!!!
13:56:34 <monochrom> <3 stack overflow
13:56:36 <Elly> DrSyzygyFR: a winner is you!
13:56:42 <DrSyzygyFR> It just takes a while.
13:56:53 <DrSyzygyFR> Elly: I was talking to Saizan earlier, but bad at reproducing them....
13:56:59 <copumpkin> ah, one of the comments even mentions the applicative instance I ended up writing for it
13:57:36 <copumpkin> so far I have functor and applicative, feel I could do monad, and I could probably make a ContraFunctor out of it too
13:58:35 <DrSyzygyFR> So, with stack overflows occurrins, my best bet is to run it +RTS -xc -RTS and check the results of the profiling?
13:59:04 <copumpkin> ski: one of my main concerns is whether there's any nice (elegant) way to allow sharing over parallel folds
14:01:03 <FalconNL> Bah, two strict folds and still slow. I'm doing something wrong, but I can't figure out what.
14:01:04 <FalconNL> dummy :: [[Pixel]] -> [Word8]
14:01:06 <FalconNL> dummy = foldl' (foldl' (\ws (Pixel r g b a) -> f a:f b:f g:f r:ws)) []
14:01:07 <FalconNL>         where f = fromIntegral
14:01:44 <copumpkin> FalconNL: lists are slow
14:01:54 <copumpkin> at the very least, try the stream-fusion package
14:02:25 <vixey> FalconNL: just curious, what's the def of Pixel?
14:02:41 <copumpkin> FalconNL: better would probably be uvector
14:02:55 <FalconNL> copumpkin: I know, but that's how I store them in the data structure. I can read a bitmap to this structure in 0.05 seconds, but writing is slow for some reason
14:02:56 <BONUS> red green blue alpha?
14:03:03 <FalconNL> data Pixel = Pixel Int Int Int Int
14:03:12 <FalconNL> BONUS: yep
14:03:13 <vixey> thanks
14:03:19 <copumpkin> not Pixel !Int !Int !Int !Int
14:03:24 <copumpkin> with -funbox-strict-fields ?
14:03:26 <copumpkin> you might as well
14:05:07 <ski> copumpkin : interesting. (i'll try to think a bit on this later). ty
14:05:28 <Philippa_> FalconNL: you don't want strictness here
14:05:31 <Philippa_> you want laziness
14:05:32 <BONUS> http://twan.home.fmf.nl/blog/haskell/non-regular1.details this is pretty awesome
14:05:35 <BONUS> i love recursion in types
14:05:45 <Philippa_> strictness forces you to build more than necessary
14:05:46 <FalconNL> Yeah, I tried the strict version and it seems to be slower
14:06:00 <copumpkin> ski: my current version is up at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2244#a2244
14:06:16 <ski> noted
14:06:17 <wli> I'm still completely stumped on modules.
14:06:26 <copumpkin> but it relies on an unreleased version of uvector :P
14:16:46 <FalconNL> So there's no faster way of converting a [[[a]]] to a [b] then two (foldl')s ?
14:16:58 <FalconNL> *than
14:17:19 <roconnor> foldr is lazier
14:17:35 <BONUS> what if you (map . map . map) and then (concat . concat)
14:17:39 <FalconNL> roconnor: that's what I tried originally. It's about equally slow
14:17:46 <roconnor> sure
14:17:47 <roconnor> but lazier
14:17:57 <roconnor> probably uses less memory
14:18:05 <FalconNL> true, but I need to convert every pixel anyway
14:18:24 <BONUS> > (concat . concat) . (map . map . map) ord $ [["hah","woo"],["woho","who"]]
14:18:26 <lambdabot>   [104,97,104,119,111,111,119,111,104,111,119,104,111]
14:18:27 <roconnor> I still expect it to use less memory, although it is not clear.
14:19:09 <roconnor> I suppose foldl' might be better for dealing with pixels if the foldl's are properly arranged
14:19:26 <vixey> > [["hah","woo"],["woho","who"]] >>= id >>= id >>= return . ord
14:19:27 <lambdabot>   [104,97,104,119,111,111,119,111,104,111,119,104,111]
14:20:17 <mle> Heh
14:20:26 <FalconNL> concat . concat . map (map (\(Pixel r g b a) -> [f a,f b,f g,f r])) has about the same characteristics as the others
14:20:34 <mle> <3 >>= as concatMap
14:21:02 <sjanssen> FalconNL: that seems cleanest
14:21:26 <BONUS> > [["hah","woo"],["woho","who"]] >>= id >>= ord
14:21:27 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
14:21:33 <BONUS> ah of course
14:21:34 <skorpan> i'm trying to write a little lexer generated using alex... i'm using the monadic wrapper and i get this error: templates/wrappers.hs:133:15: Not in scope: `alexEOF'
14:21:39 <skorpan> any ideas, anyone?
14:21:40 <beelsebob> > [x | z <- [["hah", "woo"], ["woho", "who"]], y <- z, x <- y]
14:21:42 <Deewiant> (>>= id) = concat
14:21:42 <lambdabot>   "hahwoowohowho"
14:22:01 <BONUS> we are pretty much horrible people
14:22:02 <beelsebob> > [ord x | z <- [["hah", "woo"], ["woho", "who"]], y <- z, x <- y]
14:22:03 <lambdabot>   [104,97,104,119,111,111,119,111,104,111,119,104,111]
14:22:04 <FalconNL> sjanssen: yeah, but it's about 40 times slower than loading the whole bitmap in the first place
14:22:26 <roconnor> FalconNL: well, if all you are doing is concat, then I'd definitely not use foldl
14:22:30 <copumpkin> use uvector :P
14:22:37 <roconnor> FalconNL: concat and map
14:22:40 <sjanssen> pixelComponents (Pixel r g b a) = [r, g, b, a]; map f . concat . concat . pixelComponents -- cleanest
14:22:46 <skorpan> nvm, googled it
14:22:49 <roconnor> FalconNL: I assumed you wanted to do some accumulating
14:22:59 <sjanssen> FalconNL: are you using foldl?
14:23:07 <hydo> In the RWH example code, is {-- snippet Something --} a folding lib?  For emacs perchance?
14:23:28 <vixey> :t concat . concat . ?pixelComponents
14:23:29 <lambdabot> forall a a1. (?pixelComponents::a1 -> [[[a]]]) => a1 -> [a]
14:23:35 <FalconNL> sjanssen: I tried foldl, foldl', foldr, concat . map. They're all pretty much equally slow
14:23:54 <sjanssen> FalconNL: foldl is just plain wrong
14:23:56 <copumpkin> you're building lists and taking them apart
14:24:00 <sjanssen> FalconNL: what's the type again?
14:24:20 <FalconNL> Which is weird, because I can convert a bytestring to a [[Pixel]] in no time flat, but the other way around is painfully slow
14:24:41 <copumpkin> what kind of bytestring?
14:24:50 <FalconNL> lazy bytestring
14:24:51 <sjanssen> FalconNL: oh, how are you creating the ByteString?
14:24:53 <Deewiant> FalconNL: Did you eval the list after that conversion?
14:25:03 <copumpkin> good point
14:25:13 <copumpkin> if it takes no time at all, you're probably doing the reading and writing in one step and timing that
14:25:15 <FalconNL> Deewiant: I assume that last . last should evaluate the whole thing
14:25:16 <Deewiant> If not, it could be that you're actually doing both conversions in the end :-P
14:25:51 <Deewiant> FalconNL: Only the heads of the non-last lists... whether that matters depends on how you convert it
14:25:52 <Saizan_> last . last can easily skip a lot of work
14:25:56 <copumpkin> FalconNL: an unboxed array would also allow you to point your bytestring at the memory chunk and "convert" in O(1)
14:26:04 <Deewiant> And of course, it ignores the elements themselves
14:26:15 <copumpkin> FalconNL: take Control.Parallel.Strategies.rnf
14:27:03 <FalconNL> ok, what's the easiest way to verify that a [[a]] has been fully evaluated?
14:27:16 <Deewiant> FalconNL: rnf, like copumpkin said.
14:27:21 <roconnor> add up all the avlues
14:27:23 <roconnor> values
14:27:32 <skorpan> :t rnf
14:27:33 <lambdabot> forall a. (NFData a) => a -> Done
14:27:35 <Baughn> FalconNL: evaluate . rnf
14:27:44 <copumpkin> `using` can be helpful too
14:27:44 <Deewiant> ?ty evaluate
14:27:45 <lambdabot> Not in scope: `evaluate'
14:27:51 <copumpkin> it's just a fancy name for seq
14:27:56 <Baughn> ?ty Control.Exception.evaluate
14:27:58 <lambdabot> forall a. a -> IO a
14:28:06 <Deewiant> (rnf x `seq`)
14:28:14 <roconnor> evaluate only gives you head normal form
14:28:20 <Baughn> Thus the rnf
14:28:25 <roconnor> ya
14:28:26 <copumpkin> using is the easiest way :)
14:28:32 <vixey> there isn't point in 'checking' it's been evaluated
14:28:32 <copumpkin> if you're importing C.P.S anyway
14:28:41 <Baughn> Yeah, but then you need to make sure the result of using is actually used. :P
14:28:49 <Baughn> Using evaluate makes sure of that
14:28:54 <copumpkin> ah
14:29:35 <Baughn> ..what I don't get is why the heck evaluate is in Control.Exception
14:30:04 <copumpkin> it does seem odd
14:30:08 <Deewiant> ?src evaluate
14:30:08 <lambdabot> evaluate a = IO $ \s -> case a `seq` () of () -> (# s, a #)
14:30:13 <sjanssen> Baughn: because it can turn _|_ into an exception in IO
14:30:34 <ski> (copumpkin : `Continuation.Passing.Style' ?)
14:30:49 <copumpkin> ski: I thought of that, but was too lazy to type out Control.Parallel.Strategies
14:30:54 <copumpkin> I added the periods to reduce ambiguity :P
14:31:19 <Baughn> sjanssen: Yes, sure, but you'll still want to pull in Control.Parallel.Strategies (most of the time) to do it, and anyway it's more useful for concurrent code than exceptions
14:31:38 <sjanssen> Baughn: I don't see how it is related at all to concurrency
14:31:51 <sjanssen> it's useful for benchmarks, that's about it
14:32:05 <sjanssen> hpaste is down?
14:32:06 <Baughn> sjanssen: Forcing a value in one thread before passing it to putMVar, say
14:32:18 <copumpkin> I don't even see why rnf belongs in parallel strategies myself
14:32:19 <Baughn> sjanssen: Although I'd use using for that.. some people like writing it out
14:32:21 <sjanssen> Baughn: putMVar v $! val
14:32:22 <copumpkin> it's useful on its own
14:32:44 <sjanssen> copumpkin: it belongs outside of that namespace, IMO
14:32:52 <copumpkin> yup
14:33:23 <copumpkin> maybe a Control.Evaluation with evaluate, rnf, using, whnf, and so on in it
14:33:25 <FalconNL> ah. loading the bitmap now takes about 5 seconds. so much for last . last evaluating the whole thing.
14:33:35 <Deewiant> :-)
14:33:37 <copumpkin> FalconNL: you should give arrays a go :)
14:34:09 <copumpkin> lists really aren't that good a fit for this
14:34:24 <copumpkin> ideally, the lazy uvector stuff would be ready, but I haven't had time recently
14:34:34 <FalconNL> I wanted to keep the resulting data structure as simple as possible, but I suppose I'll have to bow to efficiency
14:34:48 <ski> @type Control.Parallel.Strategies.wtf
14:34:49 <lambdabot> Not in scope: `Control.Parallel.Strategies.wtf'
14:35:07 <DrSyzygyFR> We should fix that. :-P
14:35:11 <Baughn> FalconNL: Foldable/Traversable are the same regardless. ;)
14:35:14 <Deewiant> WTData a => a -> Done
14:35:29 <copumpkin> FalconNL: the code will look almost identical with arrays as it does with lists :P
14:35:32 <copumpkin> well, it can
14:37:49 <yitz> @hoogle wtf
14:37:50 <lambdabot> No results found
14:38:36 <ski> "weak t?? form" ?
14:39:03 <Baughn> @instances-importing Control.Applicative Applicative
14:39:03 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
14:42:27 <Baughn> @type traverse
14:42:28 <lambdabot> Not in scope: `traverse'
14:42:34 <Baughn> @type Data.Traversable.traverse
14:42:36 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> t a -> f (t b)
14:43:52 * wli ponders modules even more.
14:44:45 * da-x ponders writing Linux kernel code in haskell.
14:44:58 <copumpkin> da-x: how?
14:45:14 <wli> da-x: I'm all ears.
14:45:41 <da-x> Let's see.. start with porting the RTS to a kernel module
14:45:57 <da-x> then, reduce stack consumption.
14:46:14 <Baughn> Or implement your own stack
14:46:15 <da-x> probably there a lot of more stuff to do
14:46:53 <da-x> I hope I'm not giving you some crazy ideas...
14:46:57 <Baughn> You are.
14:47:03 <Baughn> But don't worry, nothing will come of them.
14:48:05 <da-x> yeah, I'm sure none of the 604 other people in the channel excluding lamdabot are crazy enough to try it.
14:48:41 <yitz> @vixen will you write kernel code in haskell?
14:48:41 <lambdabot> Ooh, functional programmers are so hot!
14:48:56 <Baughn> Any who are, probably have their hands full with doomsday devices already.
14:49:20 * wli is just not convinced it's a good idea.
14:49:32 <monochrom> unsafePerformFusion
14:52:15 <Baughn> It's a mystery.
14:57:48 * wli prepares to paste something to add modules to.
14:58:12 <FalconNL> Shouldn't this pragma work? {-# OPTIONS -i../../.. #-}
14:58:40 <da-x> will probably be better to take House and add Linux user-space support for so it would be able to run Linux processes.
14:59:09 <copumpkin> FalconNL: what's the current directory?
14:59:57 <wli> da-x: There is FuSE for userspace filesystem driver support for Linux.
15:00:07 <FalconNL> copumpkin: D:\My Dropbox\Codec.Image.Simple\Codec\Image\Simple
15:00:39 <copumpkin> I meant more along the lines of, who is that relative path relative to?
15:00:49 <copumpkin> I'd imagine it's relative to GHC's current dir
15:00:52 <FalconNL> it works if I give the -i flag on the command line
15:01:18 <wli> da-x: Haskell libs to support implementations of filesystems via FuSE sound productive.
15:01:26 <da-x> wli: yep, halfs: http://haskell.org/halfs/
15:01:55 <da-x> sorry, hfuse: http://darcs.haskell.org/hfuse/
15:01:55 <wli> da-x: Spiffy.
15:02:10 <copumpkin> oh nice
15:02:46 <FalconNL> ghci -i../../.. BMP.hs works, but ghci BMP.hs (which includes the pragma) doesn't
15:04:46 <da-x> wli: then how about this - take Linux - keep arch/ but strip the file system layer, scheduler, memory management for userspace, and all drivers, and then reimplement them in haskell, keeping the same syscall interface.
15:05:19 <da-x> wli: we will have to bring alan cox back to rewrite the TCP/IP network stack in haskell
15:06:24 <wli> Is pastebin.com down or something? I can't seem to bring a page up.
15:07:17 <Zao> Apparently.
15:09:16 <wli> Okay, then. I'm then trying to add modules to http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2245#a2245
15:13:41 <wli> Where do I start on adding modules to it?
15:17:31 <jethr0> da-x: i assume you have seen house, the haskell "operating system"?
15:19:29 <davidL> FalconNL: where did you get BMP.hs?
15:19:53 <FalconNL> That's the file I'm writing
15:20:10 <davidL> ah
15:22:38 <ErhardtMundt> night
16:11:07 <gwern> hurm.
16:11:22 <gwern> a lambda in the gutter; its guts spilling out, run over by a `seq`
16:11:32 <pumpkin_> :o
16:11:36 <gwern> this language fears me. I have seen what it really is
16:11:45 <skorpan> is it creepy time now
16:12:02 <gwern> this language, with its bottoms being smacked by unsafePerformIOs; this overflowing filth of unused variables
16:12:07 <monochrom> gut is not creepy
16:12:12 <skorpan> seq is
16:12:17 <gwern> one day, it'll fill all the stacks, drown them
16:12:18 <pumpkin_> I'm getting quite convinced that there is no elegant way to do what I want :/
16:12:41 <gwern> and they'll look up at me, saying, 'Eval me!' and I'll look down and say, 'no'
16:12:44 <chessguy> oh!
16:12:47 <chessguy> Watchmen
16:12:53 <chessguy> i thought it sounded familiar
16:13:20 <chessguy> wild movie
16:13:31 <gwern> and chessguy takes the palm. (nothing for the rest of you illiterate punks)
16:13:42 <chessguy> palm?
16:13:51 <Cale> But who watches those who watch the Watchmen?
16:13:59 <skorpan> the men
16:13:59 <mauke> hah. I recognized it after "this language fears me. I have seen what it really is"
16:14:01 <gwern> funnily enough, when I wrote 'hurm.' I was expecting the next sentence to be about the memory leak in gitit, not a parody of anything
16:14:05 <gwern> funny how the mind works
16:14:58 <monochrom> The MPAA watches those who watch the Watchmen to make sure there is no stealing of movies. :)
16:15:14 <gwern> chessguy: you know, the award, the laurels
16:15:33 <gwern> (do people not use 'palm' in that sense any more? did I just date myself by a few centuries?)
16:16:09 <chessguy> gwern:  *shrug* i don't recognize the phrase
16:16:20 <mun> hi
16:16:29 <chessguy> hi
16:16:35 <skorpan> hi
16:16:49 <monochrom> I take the olives and eat them too.
16:16:50 <mun> i'm getting an error saying that "Bad interface file: /usr/local/lib/gtk2hs/imports/gtk/Graphics/UI/Gtk.hi  mismatched interface file versions (wanted "6101", got "6082")" which module do i need to update?
16:17:08 <gwern> (hm. gitit's now up to 5x memory usage now. 'ab' is decent enough for profiling I guess)
16:19:47 <gwern> duncan duncan duncan! i maked you a question, but then i eated it :(
16:20:14 <wli> Okay, not a peep on modules.
16:20:43 <dcoutts> gwern: :-)
16:22:08 <pumpkin_> wli: maybe the people in #ocaml might know more about it?
16:22:20 <pumpkin_> or a channel for a language with more sophisticated modules than ours
16:23:05 <wli> pumpkin: Well, I did write the AST stuff in Haskell.
16:23:20 <pumpkin_> yeah, but the module stuff is what you're not sure about, right?
16:23:54 <wli> Pretty much, yes.
16:24:23 * wli might have to dust off his ocaml for the occasion if it really comes to that.
16:24:35 <floyd> how would i go about applying a function to every element in a list of lists?
16:25:13 <dmhouse> > map (map (+1)) [[1..5], [6..10]]
16:25:14 <lambdabot>   [[2,3,4,5,6],[7,8,9,10,11]]
16:26:47 <floyd> thanks
16:43:14 <wli> I guess one of the first things is that qualified names have to be able to appear somewhere.
16:56:01 <wli> Things get very tricky very quickly with higher-order modules.
16:56:07 <pumpkin_> well, my folds are begging for CSE
16:57:00 <mmmulani> how do I make comments in haskell?
16:57:11 <ray> -- comment
16:57:18 <mmmulani> sweet
16:57:19 <mauke> {- comment -}
16:57:34 <wli> Adding room for type annotations is tricky, too, or otherwise painful.
16:57:45 <ray> {- multiline
16:57:48 <ray>    comment -}
17:04:04 <pumpkin_> wow, this is beastly
17:04:05 <pumpkin_> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2246#a2246
17:04:18 <pumpkin_> it begs for CSE
17:05:00 <monochrom> information wants to be freed? code wants to be CSEed?
17:05:31 <mauke> malloc() wants to be free()d
17:05:34 <pumpkin_> :P
17:05:41 <monochrom> hehehe
17:05:54 <monochrom> @remember mauke malloc() wants to be free()d
17:05:55 <lambdabot> I will never forget.
17:06:52 <pumpkin_> my code is so applicative
17:06:54 <pumpkin_> yet so ugly
17:08:05 <SubStack> rewrite it in c
17:08:09 <pumpkin_> lol
17:08:29 <SubStack> then it will look very pretty by comparison
17:08:47 <pumpkin_> I dunno, this is pretty ugly
17:09:07 <pumpkin_> it's a direct translation of http://github.com/unmarshal/hstats/blob/da695128f67a2e9e32337b30cc2abb17d16a5457/src/Math/Statistics.hs to my folds
17:09:11 <wli> I think pretty much everywhere expressions can recurse have to go from expr to (expr, Maybe typeQualifier) or some nightmare like that.
17:10:14 <ray> stop saying "my folds" pumpkin_
17:10:19 <ray> it's a bit creepy
17:10:20 <wli> A few other places need it, too, like left hand sides of let bindings, lambda-bound variables, and so on.
17:10:28 <ray> you might as well say "my pretties"
17:10:28 <pumpkin_> ray: my humps? my lovely lady lumps
17:10:57 <ray> i was thinking more wicked witch of the west
17:11:18 <mauke> oh, is that what www stands for?
17:11:20 <wli> Maybe even variables bound by label extraction in case statements.
17:13:17 <EvilTerran> pumpkin_, i think defining, say, (|*|), (|/|), and (|-|) as liftA2'd versions of (*), (/), and (-) would help
17:13:22 <EvilTerran> slightly
17:13:25 <pumpkin_> probably :P
17:13:37 <pumpkin_> <^^> looks kind of like a bat
17:13:56 <ray> <^_^>
17:13:57 * Axman6 was about to suggest ^*^, ^/^ and ^_^
17:14:03 * EvilTerran grumbles about the naming of <*>
17:14:15 <EvilTerran> otherwise, the obvious choice would be <*> </> <->
17:14:26 <ray> stupid applicative
17:14:28 * EvilTerran would've just called it <> or something
17:14:38 <EvilTerran> "f <$> x <> y <> z"
17:14:58 <pumpkin_> yeah
17:15:09 <pumpkin_> not a fan either
17:15:11 <adamvo> what about *>
17:15:20 <Axman6> Applicative i think
17:15:27 <Axman6> @hoogle (*>)
17:15:27 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
17:15:27 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
17:15:27 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
17:15:37 <EvilTerran> ... actually, <$> would make most sense as the name for <*>, as then an (OP) :: a -> b -> c would suggest (<OP>) :: Applicative f => f a -> f b -> f c
17:15:38 <mmmulani> is the expected type, the type present?
17:16:04 <ray> who writes these haskell standard libraries anyway, jeez
17:16:13 <mauke> mmmulani: expected type: what the context around it wants; inferred type: what the thing itself provides
17:16:18 <EvilTerran> (< ... >) as an outerfix adoperator
17:16:19 <EvilTerran> :P
17:16:33 <mmmulani> ouuuu
17:16:48 <EvilTerran> (the "ad-" in "adoperator" as in "adverb")
17:16:54 <mauke> >
17:17:02 <ray> operigatoni
17:17:07 <mauke> > 'x' == ()
17:17:08 <lambdabot>   Couldn't match expected type `Char' against inferred type `()'
17:17:24 <mauke> ('x' ==) is the context. it wants another Char
17:17:29 <mauke> () itself has the type ()
17:18:05 <mmmulani> would (map (\x->[x,x]) [1..10]) provide the type [[Int] -> Int]?
17:18:08 <adamvo> > map isUpper "()"
17:18:09 <lambdabot>   [False,False]
17:18:31 <mauke> :t map (\x->[x,x]) [1..10]
17:18:32 <lambdabot> forall a. (Enum a, Num a) => [[a]]
17:18:46 <mauke> no, just [[Int]]
17:18:49 <mmmulani> hmmmm
17:19:25 <gwern> @quote crap
17:19:26 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
17:19:29 <gwern> @quote crap
17:19:29 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
17:19:41 <gwern> @quote magical.*evil
17:19:41 <lambdabot> No quotes match. Are you on drugs?
17:19:50 <pumpkin_> well, the fold composition version doesn't stack overflow on large lists, and the hstats one does
17:19:53 <pumpkin_> so I guess that's my comparison
17:20:00 <gwern> @quote Gracenotes foldr chosen for its magical evil terminating powers
17:20:00 <lambdabot> No quotes match. :(
17:20:03 <gwern> @remember Gracenotes foldr chosen for its magical evil terminating powers
17:20:04 <lambdabot> I will remember.
17:20:18 <gwern> @quote lisp.*to.*haskell
17:20:18 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
17:20:18 <lambdabot> true functional programming), and you've got haskell
17:20:22 <gwern> @quote lisp.*to.*haskell
17:20:22 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
17:20:22 <lambdabot> true functional programming), and you've got haskell
17:20:35 <gwern> @remember uninverted Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:20:36 <lambdabot> Done.
17:20:40 <Axman6> gwern: that was me technically
17:20:51 <gwern> @forget uninverted Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:20:51 <lambdabot> Done.
17:20:51 <Axman6> the magical evil terminating one
17:20:58 <gwern> gah
17:21:02 <Axman6> heh
17:21:04 <gwern> @remember uninverted  Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:21:04 <lambdabot> I will remember.
17:21:11 <gwern> @forget Gracenotes foldr chosen for its magical evil terminating powers
17:21:11 <lambdabot> Done.
17:21:17 <gwern> @remember Axman6 foldr chosen for its magical evil terminating powers
17:21:17 <lambdabot> Good to know.
17:21:20 <gwern> phew!
17:21:21 <Gracenotes> wha
17:21:22 * pumpkin_ needs more power!!!
17:21:22 <Axman6> :P
17:21:28 <gwern> @quote infinitely.*fast
17:21:28 <lambdabot> Berengal says: [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
17:21:40 <gwern> @quote functions.*crap
17:21:40 <lambdabot> nikki93 says: After a bit more delving, I've come to see the power of haskell at last. You have to treat functions like crap, forget about the C idea that they're 'big things'. They're not.
17:21:48 <gwern> @quote fix.*error
17:21:48 <lambdabot> Berengal says: I was squashing a bug, got frustrated, and typed "fix error" in ghci...
17:21:51 <gwern> @flush
17:22:33 <Axman6> what's @flush do? saves stuff to dick?
17:22:38 <Axman6> disk -_-
17:22:47 <Gracenotes> actually, Axman6, I think I deserve credit for that quote
17:23:01 <Gracenotes> "Axman6's reinterpretation of Gracenotes"
17:23:05 <Axman6> well, you do, but that version of it was mine
17:23:12 <pumpkin_> @remember Axman6 what's @flush do? saves stuff to dick?
17:23:13 <lambdabot> Okay.
17:23:20 <ray> we'll settle this in the ring
17:23:21 <Axman6> >_<
17:23:27 <Gracenotes> I licensed it under CC-by-SA, you don't think you can get away with using it without attribution?
17:23:33 <Gracenotes> and an explicit CC license?
17:23:37 <Axman6> leave me alone, i just woke up and i haven't had nearly enough sleep :(
17:23:56 <Gracenotes> NO I WILL SUE IN A COURT OF LAW IN TRENTON, NJ
17:23:59 <pumpkin_> http://github.com/pumpkin/folds/blob/09863966c1b701da5f9cc5ecdc5f3246ca48a905/Folds.hs :P
17:24:06 <Gracenotes> YOU JUST WATCH IT SIR
17:24:08 <gwern> Gracenotes: come on, no one here knows that
17:24:10 <Axman6> gwern: good luck with the extradition :)
17:24:11 <Elly> best court case ever
17:24:14 <Axman6> uh, Gracenotes
17:24:24 <Gracenotes> gwern: just for you
17:24:32 * gwern feels obscurely pleased
17:24:36 <gwern> SOLLOG KNEW WHY
17:24:41 * Axman6 missed the joke
17:25:01 <floyd> is there any way to modify an element in a list of tuples?
17:25:17 <pumpkin_> map first/second f
17:25:19 <Axman6> :t first
17:25:21 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:25:28 <Gracenotes> [¬º-°]¬
17:25:30 <Axman6> :t first id
17:25:32 <lambdabot> forall a d. (a, d) -> (a, d)
17:25:37 <Axman6> hmm, bad example
17:25:38 <pumpkin_> > map (first (+1) (zip [1..10] [2..11])
17:25:39 <lambdabot>   <no location info>: parse error on input `;'
17:25:42 <pumpkin_> > map (first (+1)) (zip [1..10] [2..11])
17:25:44 <lambdabot>   [(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11)]
17:25:44 <Elly> what the hell? how is that first
17:25:50 <Axman6> :t first fromJust
17:25:51 <lambdabot> forall a d. (Maybe a, d) -> (a, d)
17:26:03 <Gracenotes> @type first `asTypeOf` (undefined::a->b->c)
17:26:05 <lambdabot> forall b c d. (b -> c) -> (b, d) -> (c, d)
17:26:05 <gwern> @hoogle first
17:26:05 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
17:26:05 <lambdabot> Data.Monoid newtype First a
17:26:05 <lambdabot> Data.Monoid First :: Maybe a -> First a
17:26:15 <gwern> oh, it's an arrow thing
17:26:22 <Gracenotes> @type second `asTypeOf` (undefined::a->b->c)
17:26:23 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
17:26:28 <Elly> @type id
17:26:29 <lambdabot> forall a. a -> a
17:26:32 <pumpkin_> Gracenotes: `asTypeOf` (undefined :: T) === :: T :P
17:26:38 <Gracenotes> o rly
17:26:45 <Gracenotes> @type second :: a->b->c
17:26:46 <lambdabot>     Couldn't match expected type `a' against inferred type `b -> c'
17:26:46 <lambdabot>       `a' is a rigid type variable bound by
17:26:46 <lambdabot>           the polymorphic type `forall a b1 c1. a -> b1 -> c1'
17:26:51 <Gracenotes> failure.
17:26:58 <pumpkin_> zomg
17:27:01 * pumpkin_ failz
17:27:05 <Axman6> -_-
17:27:12 <Gracenotes> yeah, just when you want to unify it, not type it
17:27:14 <mauke> :t second `asTypeOf` fmap
17:27:15 <lambdabot> forall b c d. (b -> c) -> (d, b) -> (d, c)
17:27:16 <pumpkin_> aha
17:27:23 <pumpkin_> nice
17:27:35 <Axman6> my laptop is not warm enough! i needs moar project euler
17:27:39 * pumpkin_ lurnz noo stuff evury day by being a douchebag
17:27:46 <Gracenotes> :t first `asTypeOf` fmap -- but :o
17:27:48 <lambdabot> forall b. (b -> b) -> (b, b) -> (b, b)
17:28:16 <gwern> dang it. I've been stressing with 'ab' gitit for an hour and a half now, and memory has only increased 1.8x
17:28:37 <gwern> is this enough for my profiling to tell me the memory? enquiring minds want to know but dare not kill gitit to find out!
17:28:54 <Gracenotes> pumpkin_: don't worry, I teach people things every day by being a douchebag! Okay, that was a joke, people.
17:29:05 <pumpkin_> I'm tempted to make folds into Num/Fractional/RealFloat instances
17:29:09 <pumpkin_> but that would feel really dirty
17:29:18 <ray> do it
17:29:29 <Axman6> gwern: it's a wiki right? edit a whole bunch of pages (or turn off any anti spam stuff for a few days)
17:29:30 <Gracenotes> weird Num instances are unnatural :o
17:29:37 <pumpkin_> it's cuz GHC isn't giving me the power I desire!!!!
17:29:42 <ray> weird num instances are the lifeblood of haskell
17:30:09 <Gracenotes> I mean, usually people think as Nums as concrete types -- they're working with typeclass methods, but thinking like they're Ints or Doubles or suchlike
17:30:17 <Axman6> pumpkin_: no my son, it is you who is not giving GHC the power it needs
17:30:25 <gwern> I recently enjoyed defining (+) on lists; but I kept it normal and just defined it as (++)
17:30:35 <pumpkin_> @src Num
17:30:35 <lambdabot> class  (Eq a, Show a) => Num a  where
17:30:35 <lambdabot>     (+), (-), (*)           :: a -> a -> a
17:30:35 <lambdabot>     negate, abs, signum     :: a -> a
17:30:35 <lambdabot>     fromInteger             :: Integer -> a
17:30:43 * Axman6 hopes you all read that in a deep fatherly voice
17:30:48 <pumpkin_> nice, I can define all of those :P
17:30:57 <Gracenotes> fromInteger 4 = replicate 4 undefined >_>
17:31:09 <Gracenotes> works for [a].
17:31:16 <pumpkin_> lol
17:31:26 <Gracenotes> well. fromInteger n. and you'd have go Integer -> Int
17:32:02 <Gracenotes> gwern: have you taken Eastern Religions?
17:32:06 <pumpkin_> oh, I can't do fromInteger
17:32:40 <wli> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2245#a2247 <-- still needs substantial work
17:32:41 <gwern> Gracenotes: I took a course on indian philosophy (focusing on buddhism & hinduism); just 'Eastern Religions' sounds way too basic for me
17:33:15 <Gracenotes> gwern: mm, yeah, I'd imagine. But it's a basic historical and cultural overview of Taoism, Buddhism, Hinduism, and Confucianism
17:33:29 <Gracenotes> AAS 102
17:33:34 <gwern> sounds seriously dull
17:33:42 <pumpkin_> okay, I really hate the numeric typeclasses
17:33:46 <pumpkin_> (just in case anyone wondered)
17:33:47 <gwern> those schools aren't interesting until you get into the details
17:33:50 <pumpkin_> !!!
17:34:09 <Gracenotes> hm. Well I need a DEC B >_>
17:34:18 <gwern> like nagargjuna and madhyamika is dull as heck to read about, until you read his verses on the middle way, and blow your brain trying to understand his arguments and how/whether they're fallacious
17:34:21 <Axman6> i had an idea last night about how to make my AVar semi-stomic variables into actually atomic variables
17:34:33 <Axman6> but i'll have to wait a week to implement it :(
17:34:36 <gwern> Gracenotes: why not take a higher course than that?
17:34:57 <Gracenotes> well, I have to take something in the DEC B category: http://www.sunysb.edu/ugrdbulletin/current/coursesbyDEC.pdf
17:35:22 <Gracenotes> The Bible as Literature is more high-level. But possibly boring I suspect, and filled with Christians
17:35:41 <gwern> Gracenotes: I'd avoid 'as Literature'; if it were real higher criticism, then it'd be worthwhile
17:35:51 <kerlo> > map (map (*)) [1,2,3] [4,5,6]
17:35:52 <lambdabot>   Couldn't match expected type `[t1] -> t'
17:35:57 <Gracenotes> mm. So any DEC B suggestions then? >_>
17:36:10 <kerlo> I didn't expect that to work anyway. :-P
17:36:11 <gwern> Gracenotes: but as literature is just an invitation for a load of bullshit and people rationalizing away the flaws and inconsistencies and politics
17:36:31 <mauke> > liftM2 (*) [1,2,3] [4,5,6]
17:36:33 <lambdabot>   [4,5,6,8,10,12,12,15,18]
17:36:37 <gwern> Gracenotes: from the looks of it, it's just listing the punishment detail^W^Wintroductory classes guaranteed to be offered
17:36:43 * kerlo applauds
17:36:56 <Gracenotes> gwern: yeah. required to take one.
17:36:59 <gwern> Gracenotes: I would seriously doubt that if you took one of the higher classes on the real philosophy/theology, that it couldn't be applied
17:37:31 <Gracenotes> oh, they apply. But for different categories.
17:37:46 <gwern> Gracenotes: why not ask one of the professors?
17:38:27 <floyd> how can i insert an item into a list by index?
17:38:28 <Axman6> quick question, what's the emacs curcor keyboard command (^W) for moving back a word?
17:38:35 <gwern> ..oh, this is real helpful output - 'MAIN 83% RAM'
17:38:41 <gwern> Axman6: M-b?
17:38:43 <Gracenotes> gwern: because I have no philosophical background whatsoever? :)
17:38:56 <gwern> sink or swim then!
17:39:02 <Axman6> gwern: seems to be it, ta :)
17:39:48 <Axman6> Gracenotes: intro to poetry, or intro to cinema
17:40:12 <Axman6> poetry's good stuff
17:40:33 <Axman6> gets the brain working in ways geeks like us are probably not all that used to
17:41:19 <Gracenotes> I'm disappointed there's no Japanese cinema course
17:41:31 <gwern> Gracenotes: you checked solar?
17:41:46 <Gracenotes> although there's an Asian cinema. And, still, a different DEC category
17:42:57 * Gracenotes watched Suicide Club yesterday. Weird film.
17:43:23 <mauke> what's the first rule of suicide club?
17:43:36 <Gracenotes> to be connected to yourself
17:43:46 <Gracenotes> ... sorta.
17:44:11 <pumpkin_> meanF = sumF / genericLengthF
17:44:22 <pumpkin_> geometricF = productF ** (recip genericLengthF)
17:44:24 * pumpkin_ feels dirty
17:44:48 <mauke> pumpkin_: here, have some fun: http://mauke.ath.cx/stuff/haskell/fun.hs
17:44:49 <Gracenotes> you might not able able to define a general Num instance, but maybe a qualified Num instance
17:44:59 <pumpkin_> mauke: you already showed me that, and it was awesome
17:45:05 <pumpkin_> but I had to take two showers after playing with it :P
17:45:10 <mauke> huhu
17:45:27 <pumpkin_> check out my abomination: http://github.com/pumpkin/folds/blob/5e28e1e13f590381d15e8bff8ef1c44716cfddcd/Folds.hs
17:45:42 <roconnor> Does Haskell FM use any reactive framework?
17:45:52 <Gracenotes> pumpkin_: just have "instance Eq (Fold a b)"
17:46:05 <pumpkin_> Gracenotes: then it bugs me
17:46:21 <pumpkin_> I guess I can define eq
17:46:25 <pumpkin_> and even show
17:46:26 <Gracenotes> the compiler will complain about unimplemented methods, but then you can just go right back and tell it to shut the hell up
17:46:30 <pumpkin_> but I refuse to, on principle
17:46:36 <Gracenotes> politely.
17:46:43 <pumpkin_> "shut the fuck up GHC"
17:46:48 <pumpkin_> like that?
17:46:59 <Gracenotes> perhaps. You just need some practice
17:47:24 <Gracenotes> compiler invective is an art, they say
17:47:43 <mauke> alias ghc='ghc 2>/dev/null'
17:49:06 <pumpkin_> lol
17:49:12 <pumpkin_> for the confident programmer
17:49:34 <gwern> @quote ghc
17:49:34 <lambdabot> ghc says: Oops!  Entered absent arg
17:49:51 <gwern> some programmers are absent-minded; ghc is absent-arged
17:50:53 <wli> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2245#a2248 <-- I still need help with this
17:52:02 <wli> e.g. where do signatures come in? where do sharing constraints come in?
17:57:45 <pumpkin_> oh, I can do my nasty stuff with applicative-numbers instead
17:58:52 <pumpkin_> conal: how do I use applicative-numbers? :P
18:00:49 <mmmulani> what is wrong with this code:
18:00:50 <mmmulani> let myfilter comp (a:as) (b:bs) = if (comp a b) then (a,b):(myfilter comp as bs) else (myfilter comp as bs)
18:00:50 <conal> pumpkin_: did you see the comments in the source?
18:01:00 <pumpkin_> ah, nope
18:01:17 * pumpkin_ looks
18:01:26 <Axman6> mmmulani: looks ok to me
18:01:30 <conal> pumpkin_: i better move them to the .cabal, so they'll show up on Hackage.
18:01:43 <mmmulani> Axman6: ghci gives me an indentation error with it :/
18:01:47 <Axman6> :t let myfilter comp (a:as) (b:bs) = if (comp a b) then (a,b):(myfilter comp as bs) else (myfilter comp as bs) in myfilter
18:01:49 <lambdabot> forall t t1. (t -> t1 -> Bool) -> [t] -> [t1] -> [(t, t1)]
18:02:14 <pumpkin_> I'll try it in a bit, thanks :)
18:02:29 <MyCatVerbs> mmmulani: looks like you want base cases for empty lists too, though.
18:02:48 <Axman6> oh yes, of course
18:02:53 <mmmulani> MyCatVerbs: yeah, I have that a line before
18:03:22 <Axman6> mmmulani: what's it look like?
18:03:45 <mmmulani> let myfilter comp [] [] = []
18:04:16 <Axman6> might want to make it myfilter comp [] bs = []
18:04:27 <Axman6> and myfilter comp as [] = []
18:04:40 <Axman6> :t curry
18:04:42 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
18:04:48 <MyCatVerbs> > let myfilter comp l1 l2 = filter (uncurry comp) (zip l1 l2) in myfilter (\a b -> (a + b) == 0) [0,1,2,3] [1,-1,-4,-3] -- shorter version, unless I made a typo somewhere.
18:04:50 <lambdabot>   [(1,-1),(3,-3)]
18:05:16 <mmmulani> MyCatVerbs: ouuuu
18:05:27 <Axman6> :t let f comp as bs = filter (uncurry comp) . zip as $ bs in f
18:05:28 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> [(a, b)]
18:05:34 <MyCatVerbs> That one handles lists of unequal lengths just by truncating the longer one (which behavoir it gets from the use of "zip").
18:07:07 <duaneb> how can I enquire about the host system?
18:07:11 <duaneb> i.e. endian
18:07:14 <MyCatVerbs> Unless you've put in cases for when one list ends before the other does, your myfilter will hit a pattern match error at the end of the shorter list. Also, you might want to use a name like "zipAndFilter" because that's what you're doing. =)
18:07:28 <mmmulani> ohhh
18:07:37 <mmmulani> I still need to learn zip
18:08:22 <duaneb> or even just the processor
18:09:31 <mmmulani> hmmm
18:09:42 <mmmulani> is there anything wrong with the following line in a .hs?
18:09:43 <mmmulani> let cs = (map (\x -> ((x^2),x)) [1..500])
18:09:51 <MyCatVerbs> duaneb: unless there's something on Hackage for it specifically (I haven't checked), I don't think there is anything in the standard libraries. Why do you need to know the CPU's endian-ness?
18:10:06 <mmmulani> I can run and view 'cs' fine in ghci
18:10:08 <duaneb> MyCatVerbs: binary io
18:10:10 <MyCatVerbs> mmmulani: you don't write "let" statements at toplevel.
18:10:23 <sjanssen> duaneb: there is an endianness package on hackage
18:10:30 <lpsmith> mmmulani:  just remove the "let"  and you'll be fine
18:10:31 <mmmulani> MyCatVerbs: *facepalm*
18:10:33 <MyCatVerbs> duaneb: is there some reason why you can't use Data.Binary?
18:10:42 <duaneb> Because that's not in the default install
18:10:44 <duaneb> and I'm lazy
18:10:51 <duaneb> I just want to know what endian I'm on
18:10:53 <sjanssen> duaneb: lame excuse
18:11:04 <duaneb> sjanssen: I shouldn't have to install 3rd party software....
18:11:06 * MyCatVerbs thwaps sjanssen with a rolled-up combinator.
18:11:18 <sjanssen> duaneb: do it with Foreign.*
18:11:31 <bremner> duaneb: if you care, you should be able to write a C program to check
18:11:33 <MyCatVerbs> duaneb: Hackage is Haskell's equivalent of CPAN. Everything in there is fine to use.
18:11:42 <dibblego> which extension allows me to load a source file with #ifdef into ghci?
18:11:50 <sjanssen> but if you're too lazy to install the available packages, I'm too lazy to write your code for you
18:12:12 <MyCatVerbs> duaneb: -XCPP, I think.
18:12:22 <duaneb> ok
18:12:24 <MyCatVerbs> Er, dibblego, not duaneb, sorry.
18:12:30 <duaneb> well
18:12:32 <duaneb> hrm
18:12:41 <dibblego> MyCatVerbs, that got it, ta
18:12:43 <duaneb> I'll look at what Data.Binary does
18:14:27 <MyCatVerbs> duaneb: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary <- reasonably fast, reasonably convenient, very well supported. Lets you write combinators that produce ByteStrings, and binary IO on ByteStrings is fairly quick.
18:16:08 <duaneb> ahh smart
18:16:18 <duaneb> it just lets Haskell do the work for it
18:16:31 <duaneb> huh
18:16:31 <duaneb> ok
18:16:36 <duaneb> MyCatVerbs: Actually, I will
18:16:39 <duaneb> !
18:16:58 <MyCatVerbs> \o/
18:17:23 <alkaid> hi, I'm new to haskell and I'm having a stack overflow problem
18:17:32 <alkaid> can someone help me ?
18:17:57 <alkaid> exit
18:18:21 <Axman6> o.O
18:18:22 <MyCatVerbs> ...
18:18:33 <duaneb> haha
18:18:44 <MyCatVerbs> I was in the middle of digging up the IMDB quote from "Demolition Man" to greet alkaid with.
18:19:02 <sjanssen> kids today can't wait more than 60 seconds for help
18:19:02 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
18:19:05 <MyCatVerbs> Talk about a short attention span. oO
18:19:20 <sjanssen> @seen ivanm
18:19:20 <lambdabot> ivanm is in #gentoo-haskell. I last heard ivanm speak 6m 19s ago.
18:20:15 <sjanssen> @msg #gentoo-haskell ivanm, sjanssen is available at this time, you do not need to use me as a proxy :)
18:21:52 <Axman6> alkaid: you right?
18:22:02 <Axman6> didn't even wait for an answer...
18:22:26 <MyCatVerbs> alkaid: Mellow greetings. What seems to be your boggle?
18:22:30 <alkaid> axman
18:22:36 <Axman6> hi
18:22:51 <alkaid> sorry, I didn't now how to use the irc client I was using
18:23:18 <Axman6> you had a stack overflow error?
18:23:20 <alkaid> I'm trying to make a very, very simple factorial function and it gives a stack overflow
18:23:31 <MyCatVerbs> Heh. And we were all just worried that you might've taken too many stimulants and ran off the deep end of your attention span. ;)
18:23:34 <Axman6> what's the code?
18:23:37 <MyCatVerbs> @where hpaste
18:23:37 <lambdabot> http://hpaste.org/
18:23:39 <duaneb> so how can I combine a Word8 and a Word16?
18:23:50 <MyCatVerbs> Please to be hpasting your code so we can read it. ^^
18:23:53 <MyCatVerbs> duaneb: combine how?
18:23:58 <Axman6> duaneb: fromIntegral
18:24:18 <duaneb> ahh fromIntegral
18:24:19 <alkaid> the simplest I could imagine: fac 0 = 1  fac n = n*(fac n-1)
18:24:31 <alkaid> (with line break)
18:24:40 <sjanssen> alkaid: you mean: fac (n-1) :)
18:24:48 <Axman6> and it crashes with large inputs?
18:24:49 <alkaid> hum...
18:24:56 <MyCatVerbs> alkaid: yep. That blows up because it builds up a long chain of, (n * (n * (n * (n ...)))
18:24:58 <Axman6> uh yes, you need fac (n-1)
18:24:59 <sjanssen> alkaid: what you wrote is "(fac n)-1" which is obviously an infinite loop
18:24:59 <duaneb> you're actually calling n*fac(n)-1
18:25:04 <duaneb> which is very different
18:25:16 <alkaid> any input will give an error message except 0
18:25:19 <duaneb> err (fac n)
18:25:27 <alkaid> Ahhhh!!
18:25:33 <MyCatVerbs> alkaid: function application binds tighter than the - operator.
18:25:41 <duaneb> do this instead: fac n = n * (fac (n - 1))
18:26:00 <alkaid> wow, that was a stupid mistake!
18:26:00 <alkaid> hahaha
18:26:04 <alkaid> thanks for your help
18:26:24 <Axman6> alkaid: there's a good chance it'll crash with large inputs too
18:26:27 <alkaid> I have to pay more attention to operator precedence
18:26:50 <alkaid> Axman - I see.
18:26:53 <MyCatVerbs> alkaid: just spam parens until you know it off by heart. :)
18:26:58 <Axman6> a tail recursive one will probably be more efficient
18:27:32 <MyCatVerbs> > let { fac 0 = 1 ; fac n = n * fac (n-1) } in fac 1000000
18:27:34 <lambdabot>   * Exception: stack overflow
18:27:41 <MyCatVerbs> > let { fac 0 = 1 ; fac n = n * fac (n-1) } in fac 100
18:27:43 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
18:28:00 <Axman6> let fac n = fac' n 1 where fac' 1 x = x; fac' !n !x = fac' (n-a) (x*n) in fac 10203040
18:28:01 <MyCatVerbs> Works for smaller values, aye? Up to about, oh, ten thousand or something?
18:28:13 <alkaid> right
18:28:19 <alkaid> thanks again
18:28:24 <Axman6> let fac n = fac' n 1 where fac' 1 x = x; fac' !n !x = fac' (n-a) (x*n) in fac 10203
18:28:29 <MyCatVerbs> Whereas the tail-recursive one, using an accumulator, works for arbitrarily big input.
18:28:38 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' !n !x = fac' (n-a) (x*n) in fac 10203
18:28:39 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
18:28:40 <alkaid> another thing: to make lambdabot evaluate an expression I just put it after a > sign?
18:28:41 <Axman6> duh
18:28:53 <MyCatVerbs> > "Yes, alkaid."
18:28:55 <lambdabot>   "Yes, alkaid."
18:28:57 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-a) (x*n) in fac 10203
18:28:59 <alkaid> nice!
18:29:00 <alkaid> :D
18:29:12 <MyCatVerbs> It's meant to mimic bird notation. :)
18:29:13 <lambdabot>   thread killed
18:29:33 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-a) (x*n) in fac 1020
18:29:41 <Axman6> ...
18:29:47 <alkaid> Axman - I'll need some time to understand this expression. Just a min.
18:29:48 <lambdabot>   thread killed
18:29:51 <sjanssen> Axman6: maybe take this to a PM?
18:30:12 <sjanssen> you can let us know when you find the limit :)
18:30:13 <Axman6> well now i'm curious why it's not working :)
18:30:23 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-a) (x*n) in fac 10
18:30:25 <sjanssen> Axman6: isn't fac 1020 really huge?
18:30:39 <lambdabot>   thread killed
18:30:39 <Axman6> urgh, i now
18:30:41 <Axman6> know*
18:30:45 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in fac 10
18:30:49 <lambdabot>   3628800
18:30:56 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in fac 1000
18:30:59 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
18:31:16 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in length . show . fac $ 10000
18:31:20 <lambdabot>   35660
18:32:00 <Axman6> surprised it didn't whinge about the a in that expression
18:33:12 <MyCatVerbs> sjanssen: eh, fac 100000 only takes eleven or so seconds to compute in GHCi on my machine. :)
18:33:24 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in length . show . fac $ 100000
18:33:39 <lambdabot>   thread killed
18:33:44 <duaneb> MyCatVerbs: you have too much time on your hands
18:33:48 <MyCatVerbs> Axman6: it's funny that it takes quadratic time and linear space anyway, just because the numbers being multiplied by gmp keep getting progressively larger. =)
18:34:05 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in logBase 10 . fromIntegral . fac $ 100000
18:34:21 <lambdabot>   thread killed
18:34:25 <Axman6> > let fac n = fac' n 1 where fac' 1 x = x; fac' n x = x `seq` fac' (n-1) (x*n) in logBase 10 . fromIntegral . fac $ 10000
18:34:44 <lambdabot>   thread killed
18:34:53 <alkaid> Axman - I think I understand your expression now, except for the `seq`
18:35:15 <alkaid> is this related to threading?
18:35:18 <Axman6> alkaid: it's just there to make sure that x doesn't form a huge thunk
18:35:51 <alkaid> this forces an evaluation or something like that?
18:35:51 <Axman6> no, seq evaluates its first argument to weak head ormal form, then returns its second argument.
18:35:54 <duaneb> wait, are lists in haskell linked?
18:35:55 <Axman6> yep
18:36:03 <Axman6> duaneb: yep
18:36:05 <duaneb> sadness.
18:36:09 <Axman6> ?
18:36:30 <duaneb> I'm trying to make a lookup table
18:36:38 * duaneb finds an array module
18:36:43 <alkaid> thanks again!!
18:36:46 <sjanssen> duaneb: Data.Map is most recommended
18:36:53 <Axman6> beat me to it
18:36:58 <alkaid> this is a very nice channel
18:37:05 <alkaid> :D
18:37:08 <alkaid> bye
18:37:14 <Axman6> o/
18:37:57 <duaneb> hmm
18:37:58 <duaneb> ok, that works
18:39:07 <duaneb> wait, is map a tree or something?
18:39:13 <Axman6> yes
18:39:17 <duaneb> ahh
18:39:17 <duaneb> ok
18:39:21 <duaneb> umm
18:39:25 <duaneb> how can I make one? :P
18:39:46 <duaneb> I  don't need much; just what might be an immutable array in c
18:39:49 <duaneb> a static array
18:39:57 <Axman6> fromList is one way
18:40:01 <duaneb> ok
18:40:23 <Axman6> (which is infact the way they're shown when you print them, fromList <the list of elements pairs>)
18:41:26 <Axman6> > fromList [(1,'1'),(2,'2')]
18:41:28 <lambdabot>   Not in scope: `fromList'
18:41:34 <Axman6> > Data.Map.fromList [(1,'1'),(2,'2')]
18:41:35 <lambdabot>   /tmp/3297113489689806087:70:48: Not in scope: `Data.Map.fromList'
18:41:39 <Axman6> lame
18:41:46 <Axman6> @hoogle fromList
18:41:46 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
18:41:46 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
18:41:46 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
19:20:05 <dibblego> does Josef Svenningsson (author Data.Set.BKTree) hang out here?
19:22:50 <Apocalisp> How about Jeff Wheeler?
19:23:13 <pumpkin_> @seen jeffwheeler
19:23:13 <lambdabot> I saw jeffwheeler leaving #yi 2h 1m 22s ago, and .
19:23:30 <Apocalisp> thanks
19:23:58 <Apocalisp> I want to submit a patch to pointedlist
19:24:18 <Apocalisp> Oh, his email's on Hackage
19:24:25 <Apocalisp> fancy that
19:24:32 <dibblego> yeah I just emailed Josef
19:29:07 <kadaver> http://www.reddit.com/r/programming/comments/8fj0p/some_misconceptions_on_tail_recursion/
19:29:17 <kadaver> ^^ does thta mean mergesort is O(n^2) in haskell ?
19:29:27 <kadaver> haskell doesnt do proper tailrecursion right?
19:29:32 <pumpkin_> :o
19:29:47 <pumpkin_> sure it does
19:30:13 <pumpkin_> but the waters are muddied by laziness
19:31:51 <roconnor> the whole idea of tail-recursion is made so bizarre by laziness it is hardly worth talking about at all.
19:32:07 <Gracenotes> laziness improves algorithmic time in many cases
19:32:41 <Gracenotes> immutability rarely improves time... but I suppose having it means that you can assume certain things and make little optimizations
19:32:42 <roconnor> is merge sort (in ML) really O(n^2) without TCO
19:34:51 <roconnor> that strikes me as really unlikely
19:35:30 <sjanssen> kadaver: where does it say mergesort is O(n^2)?
19:35:53 <glguy> if Haskell didn't do tail recursion, we'd be in a world of hurt as our programs are built up of >>= s
19:36:12 <pumpkin_> or tail-call optimization at least
19:36:28 <glguy> yes, tail calls
19:36:32 <roconnor> I don't even know that tail call means in Haskell
19:36:44 <roconnor> the guts of a function are evaluated at random times
19:36:59 <roconnor> a little here, a little more there
19:37:10 <roconnor> some at the end, some at the beginning.
19:37:23 <glguy> it means that your stack doesn't overflow when you use forever :)
19:37:39 <Gracenotes> let a = a in a :o
19:37:44 <mib_5674s90w> I am trying to install Tangible Values gui package and I get the follwing error:   cabal: dependencies conflict: ghc-6.10.1 requires old-time ==1.0.0.2 however old-time-1.0.0.2 was excluded because ghc-6.10.1 requires old-time ==1.0.0.1 daryoush@zanjan:~$ cabal upgrade old-time
19:37:48 <mib_5674s90w> any ideas>
19:37:50 <roconnor> sjanssen: ``A programmer would be surprised if he had coded up a mergesort with the expected O(n log n) asymptotic time complexity but found that the actual asymptotic time complexity on his computer was O(n^2)
19:38:11 <Axman6> mib_5674s90w: fun. talk to dcoutts_
19:38:18 <roconnor> I don't think the author is suggesting this happens with mergesort
19:38:32 <pumpkin_> mib_5674s90w: switching your nick might be helpful too :)
19:38:32 <Axman6> he helped me fix it before, but i can't remember how to do it
19:38:35 <sjanssen> TCO in Haskell means "let f x = g x in f x" uses no more stack than "g x"
19:38:50 <wli> Is there an example of a mergesort implementation for which this happens?
19:39:08 <roconnor> The author just wants to make the point that extra space complexity ought to be as surprising as extra time complexity would be, thought extra time complexity doesn't happen
19:39:59 <roconnor> I don't even think of stacks when working in Haskell, so saving the stack space strikes me as bizarre
19:40:09 <kadaver> ok
19:40:11 <pumpkin_> save the stack!
19:40:12 <kadaver> does a mergesort in haskell use a lot mroe space than in say java?
19:40:24 <kadaver> stacks are the shit!
19:40:28 <roconnor> I always have to work really hard to find a way of blowing the stack in Haskell without using primops.
19:40:51 <roconnor> and when I do manage to find a way, I still don't understand why. :)
19:41:21 <Axman6> fib n = fib (n-2) + fib (n-1)?
19:41:25 <Axman6> for large n
19:41:32 <Asztal> > sum [1..100000]
19:41:34 <lambdabot>   5000050000
19:41:37 <Asztal> bah.
19:42:08 <Axman6> > let fib n | n < 2 = 1; fib n = fib (n-2) + fib (n-1) in fib 10000
19:42:20 <Asztal> > sum [1..10000000]
19:42:20 <roconnor> (-) is a primop
19:42:23 <lambdabot>   thread killed
19:42:30 <Asztal> I see
19:42:30 <roconnor> (+) is a primop
19:42:31 <Axman6> > let fib n | n < 2 = 1; fib n = fib (n-2) + fib (n-1) in fib 1000
19:42:34 <lambdabot>   mueval: Prelude.read: no parse
19:42:49 <pumpkin_> it isn't quite a primop is it?
19:42:49 <lambdabot>   thread killed
19:42:55 <pumpkin_> I thought +# and -# were the primops
19:42:59 <roconnor> right
19:42:59 <Axman6> > let f x = f (f x) in f 1
19:43:11 <roconnor> (+) reduces to a prim op in this instance
19:43:19 <lambdabot>   mueval: Prelude.read: no parse
19:43:21 <Gracenotes> ja
19:43:28 <Axman6> mwhaha
19:43:38 <Axman6> > let f x = f (f x) in f x :: Expr
19:43:53 * Gracenotes listens to more MSTRKRFT :o
19:43:54 <lambdabot>   thread killed
19:44:01 <Axman6> > let g x = f (g x) in f x :: Expr
19:44:10 <roconnor> Axman6: does that cause a stack overflow
19:44:11 <lambdabot>   f x
19:44:17 <Gracenotes> wat
19:44:21 <Axman6> > let g x = f (g x) in g x :: Expr
19:44:23 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
19:44:39 <Axman6> roconnor: no idea actually, but i was hoping it would :)
19:44:43 <roconnor> I'd test it but I need to find out how to limit my memory first
19:44:48 <roconnor> how do I use ulimit?
19:45:38 <roconnor> Axman6: I think that runs in constant space
19:46:06 <sjanssen> kadaver: merge sort doesn't use any more memory in Haskell than something else
19:46:13 <roconnor> Actually, I'd love to hear an explain of when non-prim ops push a stack frame in GHC.
19:46:16 <sjanssen> kadaver: I think you're drawing bizarre conclusions from this blog
19:46:22 <myname> lambdabot
19:46:25 <myname> eixt
19:46:36 <Axman6> ...
19:47:15 <sjanssen> roconnor: case expressions on thunks will push a new stack frame
19:47:57 <roconnor> sjanssen: ah
19:48:14 <sjanssen> I think that's basically it
19:48:31 <Asztal> > fix tail
19:48:32 <roconnor> which also shows how stack allocations are more or less unrelated to function calls
19:48:33 <sjanssen> or things that are semantically like case, +#, etc.
19:48:34 <lambdabot>   * Exception: stack overflow
19:49:03 <roconnor> Asztal: nice
19:49:41 <roconnor> @src tail
19:49:41 <lambdabot> tail (_:xs) = xs
19:49:42 <lambdabot> tail []     = undefined
19:50:40 <maurer> 	/join #cslounge
19:50:57 <roconnor> and since stack allocations are unrelated to function calls, then the whole idea of TCO doesn't really have meaning anymore
19:51:02 <roconnor> I think ...
19:51:34 <alkaid> > tail []
19:51:36 <lambdabot>   * Exception: Prelude.tail: empty list
19:51:44 <alkaid> hum
19:52:02 <alkaid> undefined really means undefined
19:52:09 <roconnor> sjanssen++
19:52:15 <alkaid> it's not a special exception variable
19:52:19 <Axman6> yeah, lambdabot's definitions aren't the ones that are actually used
19:52:35 <Axman6> tail [] = error "empty tail"
19:52:43 <alkaid> hummmm
19:52:52 <wli> I'm not getting stack overflow from fix tail.
19:52:54 <roconnor> the actually source for tail [] is implemention specific,  but must be of the form error "something"
19:53:35 <roconnor> wli: what version of GHC?
19:53:49 <wli> 6.10.2
19:53:57 <wli> It just silently loops.
19:54:00 * roconnor gets a stack overflow is 6.8.2's ghci
19:54:12 <roconnor> wli: I guess 6.10 has TCO :P
19:54:52 <Asztal> my windows ghci (6.10.1) actually crashes...
19:54:59 <roconnor> ...
19:55:15 <Axman6> @src fix
19:55:16 <lambdabot> fix f = let x = f x in x
19:56:07 <Axman6> hmm, running fix tail in my ghci makes ghci use 0% cpu...\
19:56:54 <dolio> It should get caught by black hole analysis, but it can't throw exceptions from that in ghci for reasons I can't recall.
19:58:16 <dolio> > [1,2] \\ [2..]
19:58:32 <lambdabot>   thread killed
20:00:05 <dolio> > [1,2] \\ [2..1000000]
20:00:13 <lambdabot>   [1* Exception: stack overflow
20:00:15 <dolio> Boom.
20:00:49 <sjanssen> roconnor: I think TCO still applies
20:00:56 <scriptdevil> Is literate haskell a recommended practice?
20:01:15 * wli ponders what there might need to be tutorials about that he can actually write stuff for.
20:01:28 <sjanssen> roconnor: it's just that every function call in Haskell is essentially a "tail call"
20:01:47 <wli> (or, for that matter, what I can write code for at all0
20:01:53 <sjanssen> roconnor: also, function calls might make a heap allocation rather than a stack allocation
20:05:56 <roconnor> sjanssen: oh yes, I usually think of everything being allocated on the heap
20:06:08 <roconnor> in fact, the stack probably only contains pointers.
20:06:42 <roconnor> sjanssen: but I don't see why you think that TCO applies
20:07:22 <kw317> what is wrong with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4235#a4235? GHC complains about type of "x div y" in line 17
20:07:37 <roconnor> sjanssen: since function calls have nothing to do with stack allocations.
20:07:45 <glguy> 1``
20:07:47 <sjanssen> roconnor: yes, exactly
20:08:05 <sjanssen> TCO asks that tail calls don't make a stack allocation.  In Haskell, tail calls don't make a stack allocation
20:08:30 <roconnor> now you are just being silly
20:08:39 <tsLight> I am reading http://www.haskell.org/onlinereport/decls.html#sect4.5.4, and I am confused when it says "In an environment where x has type a, the type of g's definition is a ->b ->([a],b)". Why is that?
20:08:54 <sjanssen> I don't think so.  If a newbie comes to #haskell and asks "does Haskell support TCO?", we should say yes
20:09:11 <roconnor> Definitely not
20:09:19 <roconnor> we should say the concept is not applicable.
20:09:22 <sjanssen> well, rather GHC
20:09:28 <roconnor> to GHC
20:09:34 <sjanssen> roconnor: sure, if you want to spend 10 minutes explaining
20:09:44 <sjanssen> one of those long answer/short answer things
20:09:55 <roconnor> sjanssen: it's a terrible short answer
20:10:10 <roconnor> the newbie will go away and write tail recursive functions
20:10:16 <roconnor> and then come back with stack overflows!!!
20:12:00 <roconnor> kw317: x `div` y
20:12:08 <kw317> *sigh*
20:12:25 <kw317> maybe I shouldn't be trying to comprehend any code at 4am in the morning LOL
20:12:29 <kw317> roconnor: thanks!
20:12:44 <roconnor> roconnor++ is thanks enough
20:12:53 <Cale> roconnor: We should say "Yes, but since functions tend to be evaluated before their parameters, tail recursive functions tend to build large expressions which cause stack overflows."
20:13:21 <roconnor> But but ...
20:13:33 <roconnor> stack allocation has nothing to do with function calls
20:13:40 <Berengal> Also, some non-tail-recursive functions work just fine
20:13:41 <Cale> Right.
20:13:53 <roconnor> and TCO is all about preemtively removing a stack at the end of a function call
20:14:19 <roconnor> so, the whole idea of TCO presumes that functions entry/exit is pushing/popping a stack.
20:14:25 <roconnor> which just isn't true in GHC
20:14:50 <roconnor> I can probably safely say it isn't true in Haskell.
20:15:33 <scriptdevil> roconnor: You might put this in some online page and then whenever someone asks, point them to the explanation
20:16:33 <roconnor> scriptdevil: that seems much better
20:17:05 <roconnor> scriptdevil: I'll first try explaining it a few times to newbies until I get it right.
20:17:20 <scriptdevil> roconnor: :)
20:17:21 <Berengal> "Is Hask
20:17:24 <Berengal> Bah...
20:17:46 <Berengal> "Does Haskell have TCO?" "Short answer: Doesn't matter"
20:17:56 <Cale> I find it's easiest just to explain a reasonable model of Haskell evaluation in terms of rewriting expressions. The question about TCO is a bit misguided, yeah.
20:18:20 <roconnor> that's how I usually imagine haskell
20:18:40 <roconnor> which is why I found it so hard to understand when GHC pushes a stack at all.
20:18:50 <tsLight> can anyone take 5 seconds to help me with the question I posted? :P
20:19:05 <Axman6> tsLight: not if you don't ask it ;)
20:19:15 <tsLight> I am reading http://www.haskell.org/onlinereport/decls.html#sect4.5.4, and I am confused when it says "In an environment where x has type a, the type of g's definition is a ->b ->([a],b)". Why is that?
20:19:20 <tsLight> that was it
20:19:27 <Cale> He did ask it :)
20:19:37 <Axman6> yeah, but not on my screen :P
20:20:29 <Cale> tsLight: It's because since x :: a is an element of it, [x,y] :: [a], and so y :: a, and then z can have any type at all.
20:20:43 <Cale> (say b)
20:21:04 <Cale> and so then g takes parameters of type a and b, and produces something of type ([a],b)
20:21:22 <tsLight> I dont understand
20:21:26 <tsLight> how can [x,y] :: [a]
20:21:28 <tsLight> if x,y is a pair
20:21:33 <roconnor> tsLight: basically you cannot generalize over type variables that come from "outside" the subexpression.
20:21:36 <Berengal> It's not a pair, it's a list
20:21:36 <Cale> [x,y] is a list of two elements
20:21:41 <tsLight> ah right
20:21:43 <Berengal> And lists must all have the same element
20:21:43 <Cale> Its type is [a]
20:21:52 <Berengal> same type of element*
20:21:57 <tsLight> I messed up
20:21:57 <tsLight> :P
20:22:02 <Cale> just as  [1,2,3] :: [Integer], say
20:22:05 <tsLight> yeah
20:22:11 <tsLight> thanks
20:22:36 <roconnor> oh god, tsLight is about to read the dreaded section 4.5.5
20:22:43 <Cale> But the thing which the report is trying to point out is that while g accepts *any* type b, there's a *specific* type a which is required.
20:23:27 <Cale> (it's the same type as x, which is already in scope)
20:23:32 <tsLight> "only b can be universally quantified because a occurs in the type environment"
20:23:35 <tsLight> what does that mean?
20:23:47 <Cale> That's sort of what I just explained...
20:23:49 <tsLight> by specific type a you mean, the type of x?
20:23:53 <Cale> yes
20:23:57 <Berengal> That the type of a is already bound to a spesific type
20:24:00 <tsLight> ah
20:24:03 <tsLight> I get it
20:24:21 <Cale> Now, the type 'a' might later be generalised, but it'll be in the type of f which it's polymorphic
20:24:44 * scriptdevil goes into a dormant state
20:25:09 * Berengal wonders if it could be possible to reimplement prolog in the typesystem
20:25:17 <tsLight> so haskell cannot guess it
20:25:21 <tsLight> unless you tell it explicitely
20:25:29 <Cale> Cannot guess what?
20:25:43 <tsLight> x's type
20:26:07 <Cale> If it can't guess the type of x, generally that will mean that x can be any type at all, and it will get forall'd too.
20:26:13 <Cale> For example...
20:26:36 <Cale> If that '...' in the definition is something like, say,  g x x
20:26:56 <Cale> then the inferred type of f will be   f :: forall a. a -> ([a],a)
20:27:18 <tsLight> right
20:27:22 <Cale> which we normally write without the forall as  f :: a -> ([a],a)
20:27:34 <Cale> (because it's implied)
20:27:40 <tsLight> I am reading this to understand why the following functions give different inferred types
20:27:48 <tsLight> miAddUp  ns = (map (+ 1) . filter (>0)) ns
20:27:53 <tsLight> miAddUp3    = (map (+ 1) . filter (>0))
20:28:07 <Berengal> First guess: MR
20:28:10 <tsLight> miAddUp :: (Num a, Ord a) => [a] -> [a] but miAddUp3 :: [Integer] -> [Integer]
20:28:11 <Cale> oh, that's the monomorphism restriction, described in the following section
20:28:19 <Berengal> Yeah, MR
20:28:25 <Cale> I normally turn that off as soon as I notice it.
20:28:26 <tsLight> yes, thats why I was reading the introduction to Monomorphism :P
20:28:33 <tsLight> you turn what off?
20:28:40 <Berengal> You can give both an explicit type to override it
20:28:45 <Cale> You can add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your module
20:28:55 <Cale> and it'll stop overspecialising the type
20:29:04 <tsLight> ah
20:29:07 <tsLight> but its not a problem really
20:29:11 <tsLight> I just wanted to understand why it does
20:29:13 <Berengal> If you give miAddUp3 the type (Num a, Ord a) => [a] -> [a] it won't complain
20:29:40 <Cale> There's no *good* reason for it to do so in the case of functions
20:29:56 <Cale> But for non-function polymorphic values, there's sort of a good reason
20:30:02 <Berengal> Consider you have a function expensiveFunction (Num a) => Foo -> a
20:30:12 <Cale> For example,  myConstant = product [1..10000]
20:30:18 <Cale> It looks like a constant
20:30:25 <Cale> so you might expect it to be computed once
20:30:37 <Cale> However, it's really polymorphic, the inferred type is
20:30:43 <Cale> myConstant :: (Num a) => a
20:30:56 <Cale> and hence it's really a function of the Num instance which is supplied
20:31:18 <Cale> So if it were to remain polymorphic, it might be recomputed many times.
20:31:26 <Cale> (every time it is used)
20:31:51 <tsLight> what do you mean by "it's really a function of the Num instance which is supplied"?
20:31:56 <tsLight> isnt there only 1 Num instance?
20:32:03 <tsLight> unless I re define it or something
20:32:04 <Berengal> ?instances Num
20:32:05 <lambdabot> Double, Float, Int, Integer
20:32:08 <Cale> I mean that if you treat it as an Integer, it will be compute it as an Integer
20:32:08 <tsLight> ahh
20:32:16 <tsLight> I was confusing with Num class :P
20:32:18 <Cale> if you treat it as a Double, it'll be recomputed as a Double
20:32:26 <Cale> I'm referring to the Num class
20:32:43 <tsLight> I mean when I said "only 1 Num instance"
20:32:46 <tsLight> I meant class
20:33:00 <alkaid> hi
20:33:04 <Cale> ah
20:33:16 <Cale> Only one Num class, many instances :)
20:33:24 <tsLight> and how do I treat that function as Double, Integer or whatever?
20:33:30 <tsLight> using it from another function that expects that type?
20:33:30 <alkaid> would anyone help me clarify what Just and Maybe do?
20:33:33 <Cale> and it won't even generally be cached on a per-instance basis
20:33:43 <Cale> tsLight: yes
20:33:57 <tsLight> good
20:34:01 <Berengal> alkaid: Maybe is a type constructor. Just is a value constructor constructing a value of type Maybe a
20:34:29 <Berengal> @type Just
20:34:31 <lambdabot> forall a. a -> Maybe a
20:34:43 <alkaid> hum
20:34:44 <Cale> alkaid: A value of type Maybe t is either the value Nothing, or it is a value of the form Just x where x is of type t
20:35:00 <Cale> alkaid: So it's a way of representing cases where something might fail to produce a value.
20:35:13 <Cale> alkaid: Are you familiar with any other languages?
20:35:27 <Cale> (I might be able to relate it to something you already know)
20:35:31 <alkaid>  I've been programming in C and Python for a while.
20:35:49 <alkaid> I'm not a computer scientist though
20:35:53 <Berengal> ((Go go null pointer analogy!))
20:35:54 <Cale> okay
20:36:04 <alkaid> I
20:36:21 <alkaid> (i'm really just a physicist who likes computer science. :P)
20:36:39 <Cale> So yeah, in C, if a function wants to be able to fail to produce a result in some cases, it often returns a pointer to a value, and gives a null pointer if there was no result
20:36:55 <alkaid> right
20:37:04 <alkaid> this analogy really makes it clear
20:37:06 <Cale> So, Nothing acts like a safer version of a null pointer
20:37:10 <alkaid> clearer
20:37:23 <Berengal> A type of Maybe Int is sort of like saying "It's an Int, but it can also be Nothing/null if something went wrong"
20:37:33 <Cale> For example...
20:37:35 <Berengal> Anything that isn't Maybe cannot be null
20:37:48 <glguy> Maybe Cat is like a box , but you don't know if it has a Cat in it until you look...
20:37:50 <Cale> > lookup 3 (zip [1..] (words "here are some words"))
20:37:53 <lambdabot>   Just "some"
20:37:58 <Cale> > lookup 7 (zip [1..] (words "here are some words"))
20:38:01 <lambdabot>   Nothing
20:38:08 <dmehrtash_> testing
20:38:16 <Cale> dmehrtash_: We hear you :)
20:38:28 <QtPlaty[HireMe]> :t lookup
20:38:30 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
20:38:57 <alkaid> humm
20:39:09 <Cale> > zip [1..] (words "here are some words")
20:39:11 <lambdabot>   [(1,"here"),(2,"are"),(3,"some"),(4,"words")]
20:39:22 <Cale> Just so you can see what that looks like before the lookup :)
20:39:33 <alkaid> got it
20:39:55 <alkaid> so if there isn't anything to lookup, I get a Nothing
20:40:02 <Cale> lookup looks for a pair whose first component matches the supplied value, and if it finds one, returns Just applied to the second component, and if it doesn't, it returns Nothing
20:40:05 <Cale> yeah
20:40:13 <alkaid> nice
20:40:16 <Berengal> Not only is Maybe a safe null-pointer, it's pretty much awesome all around in ways you wouldn't think of in C...
20:40:44 * Berengal is thinking of among other things the monad instance of Maybe
20:40:56 <Cale> Yeah, the monad instance is nice when it works out for you.
20:41:03 <alkaid> you mean safer cause we don't have the danger of accidentaly allocating a null pointer
20:41:07 <Cale> alkaid: right
20:41:15 <Berengal> Or dereferencing it
20:41:17 <Cale> alkaid: Dereferencing a null pointer is rather bad
20:41:21 <alkaid> ahaha
20:41:21 <Berengal> Well, you can...
20:41:26 <alkaid> I do it all the time
20:41:32 <alkaid> Damn seg faults
20:41:40 <Cale> You can fail to pattern match all the cases in a case expression, but that's a little safer.
20:41:44 <alkaid> I'm not a very good programmer, you see?
20:41:48 <Cale> (it will result in an exception though)
20:41:49 <Berengal> Won't happen in haskell. When there's a chance you might get a Nothing, you'll know
20:41:53 <QtPlaty[HireMe]> alkaid:
20:41:55 <Cale> But it's harder to forget.
20:42:16 <QtPlaty[HireMe]> alkaid: No one is a goodprogrammer
20:42:20 <glguy> fortunately you can write let Just x = Nothing
20:42:33 <dibblego> I think the fromMaybe function is a little more appealing to people coming from C (e.g. C# calls it ??)
20:42:36 <Cale> > case lookup 3 (zip [1..] (words "here are some words")) of Nothing -> 0; Just xs -> length xs
20:42:37 <lambdabot>   4
20:42:58 <Cale> > case lookup 7 (zip [1..] (words "here are some words")) of Nothing -> 0; Just xs -> length xs
20:42:59 <lambdabot>   0
20:43:32 <Cale> Because you tend to decompose Maybe-values with pattern matches, it's hard to forget to pattern match both cases.
20:43:52 <alkaid> hummm
20:43:58 <alkaid> oh this is very nice!
20:44:20 <alkaid> it's very easy to verify if something returned nothing
20:44:36 <Cale> yeah
20:44:41 <alkaid> it's just a simple pattern matching
20:44:57 <Cale> Or, perhaps it's just hard not to do it :)
20:45:13 <Berengal> @type isJust
20:45:13 <alkaid> I've been told that haskell was difficult language
20:45:14 <lambdabot> forall a. Maybe a -> Bool
20:45:16 <Berengal> @type isNothing
20:45:18 <lambdabot> forall a. Maybe a -> Bool
20:45:26 <Berengal> > isJust Nothing
20:45:27 <lambdabot>   False
20:45:29 <alkaid> it is conceptually difficult
20:45:34 <Berengal> > isJust (Just 5)
20:45:34 <alkaid> of course it is
20:45:36 <lambdabot>   True
20:45:54 <Cale> In C, when something returns a pointer, it's not always clear whether or not it'll ever be null.
20:46:01 <Cale> And a lot of people forget to check.
20:46:14 <alkaid> a lot of people: o/
20:46:25 <Berengal> Haskell will melt your brain, but in a good way :)
20:46:26 <Axman6> o/
20:46:28 <Cale> But when it's Maybe, you can pretty much assume that in some cases it will be Nothing
20:46:48 <Cale> and that you basically have to check
20:47:01 <alkaid> if you don't check
20:47:03 <Cale> There is a way to fail to check though.
20:47:05 <alkaid> you have an incomplete pattern
20:47:08 <Cale> right
20:47:12 <Cale> > fromJust (Just 5)
20:47:13 <lambdabot>   5
20:47:14 <alkaid> and the compiler will complain about it
20:47:17 <Cale> > fromJust Nothing
20:47:18 <lambdabot>   * Exception: Maybe.fromJust: Nothing
20:47:18 <glguy> no
20:47:25 <Cale> Well, it might complain...
20:47:35 <Cale> But it'll just be a warning at most.
20:47:39 <alkaid> if you use the right flag, I mean
20:47:42 <Cale> yeah
20:47:48 <glguy> 20:47 < lambdabot>   * Exception: Maybe.fromJust: Nothing
20:47:53 <glguy> or a runtime error
20:47:54 <Berengal> It's not like it's easy to forget about Maybe either...
20:47:56 <Cale> There's fromJust, like I showed, which is not so safe to use.
20:47:58 <glguy> async exception
20:48:21 <alkaid> it just removes Just?
20:48:25 <Cale> yeah
20:48:34 <Cale> fromJust (Just x) = x
20:48:43 <alkaid> right
20:48:46 <Cale> fromJust Nothing = error "fromJust: Nothing"
20:49:08 <alkaid> and this last line is what is unsafe about it, right?
20:49:11 <Cale> yeah
20:49:19 <ryanakca> Could someone help me with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4236#a4236 please? (Code and question, from RWH, p.69, #2) ... I'm not sure if it's the best way to code it either...
20:49:21 <alkaid> it makes an exception when I could check for Nothing
20:49:22 <Cale> This sort of exception is not the sort you want to have to catch.
20:49:29 <Berengal> > let foo m = do {a <- lookup 2 m; b <- lookup 1 m; return (a ++ ' ':b)} in foo (zip [1..] (words "Here are some words"))
20:49:31 <lambdabot>   Just "are Here"
20:49:58 <glguy> alkaid, these exceptions will then arise at unexpected times due to laziness
20:50:09 <alkaid> humm
20:50:18 <Cale> So, it's best to try to avoid using fromJust entirely :)
20:50:36 <alkaid> got it
20:50:52 <alkaid> Now it's clearer
20:50:55 <Cale> It's like a way of saying "I'm *really* sure that it'll be a Just"
20:51:03 <glguy> similarly for head and tail
20:51:07 <glguy> and other partial functions
20:51:19 <alkaid> humm...
20:51:21 <glguy> usually you were sure at the time you used it
20:51:22 <tsLight> ryanakca, can't you use pattern matching? It would be much more natural to use primitive recursion to define length
20:51:23 <glguy> and then things change
20:51:27 <Cale> yeah, pattern matching is always better than head and tail because you don't tend to forget to handle the empty list case that way
20:51:36 <alkaid> right
20:51:39 <Cale> also, more readable
20:51:56 * ryanakca nods, thanks
20:52:31 <Berengal> Best of all is to use functions that handle the empty case themselves just fine, like the folds...
20:52:40 <Cale> ryanakca: yeah, comparing a list with [] using == is basically always something to avoid.
20:52:42 <Berengal> Not everything can fit into that though
20:53:09 <Cale> ryanakca: Mostly just style-wise, but also, as you can see from that error message, it introduces the need for Eq
20:53:22 <glguy> :t null
20:53:24 <lambdabot> forall a. [a] -> Bool
20:53:24 <Cale> There is also a function 'null'
20:53:26 <Cale> yeah
20:53:42 <Cale> Which is defined like:
20:53:45 <Cale> null [] = True
20:53:49 <Cale> null (x:xs) = False
20:53:56 <alkaid> It's difficult to abandon the imperative style of doind code. The first compulsion is always to use lots of ifs
20:53:59 <Cale> and that doesn't require Eq that way
20:54:15 <Cale> alkaid: and ifs without elses :)
20:54:26 * Berengal wants the if-then-else construct removed...
20:54:28 <Cale> (which the compiler won't let you get away with :)
20:54:37 <Cale> I like the if-then-else
20:54:43 <Cale> It has its place
20:54:47 <alkaid> oh yes, I already runned into it
20:54:48 <alkaid> :P
20:54:51 <glguy> so you'll end up using lots of "when" instead
20:54:54 <Berengal> It's fine, I just don't have a use for it and want its keywords :P
20:56:10 <Cale> It's one of those things which I suppose if it wasn't there, it might not be something I'd petition for, but it's something which I use anyway.
20:56:44 <Berengal> Yeah, I use it as well from time to time, but often enough I just use an "if'" function
20:56:48 <Cale> It's a bit nicer than using case/of
20:57:10 <Cale> and the 'then' and 'else' help delineate the branches better than an if function does
20:57:20 <alkaid> I just have this feeling that, although there are very difficult concepts and a very steep learning curve, Haskell is more easily used by a not very skilled programmer like me.
20:57:56 <alkaid> cause even if I'm not able to come up with the amazing code ppl often do in haskell
20:57:56 <Berengal> An if function can be given around like any other first-class member though
20:58:11 <alkaid> I still have a very clean code
20:58:13 <Asztal> I'd like an 'mcase' or something like that, for cases like: do x <- ...; case x of ...
20:58:27 <alkaid> with some litle tricks that are really useful and easy to emply
20:58:32 <alkaid> employ
20:59:08 <Cale> alkaid: and it's nicer to have the compiler catch things than to try to debug code which is running
20:59:42 <Cale> Berengal: that's true
21:00:06 <alkaid> Cale - I often spend hours in gdb trying to catch some small glitch
21:00:22 <Berengal> until' done iter = if' <$> done <*> id <*> until' done iter . iter
21:00:37 <alkaid> and my codes are rarely greater than 100 lines
21:00:55 <alkaid> well
21:01:02 <alkaid> thanks for your help
21:01:06 <ryanakca> ttp://hpaste.org/fastcgi/hpaste.fcgi/view?id=4237#a4237 works, but how is it style wise?
21:01:07 <Cale> no problem
21:01:27 <alkaid> I was twice very well served with very nice answers for trivial questions today
21:01:28 <alkaid> :D
21:01:40 <Berengal> We like trivial questions
21:01:42 <ryanakca> s/.*/h&/
21:01:44 <Cale> We like answering beginner questions, yeah :)
21:01:52 <Axman6> alkaid: it's what this channel's best at
21:01:54 <alkaid> I am studying this book  ''Real World Haskell''
21:01:57 * ryanakca has noticed, incredibly helpful people in hear
21:01:59 <Cale> Axman6: :]
21:02:15 <ryanakca> alkaid: Haha, so am I, you don't say! ;)
21:02:16 <alkaid> so I guess I'll return to the book
21:02:38 <alkaid> ryanacka - hahaha the book is very good
21:02:43 <Axman6> ryanakca: ... i don't like that code style wise :(
21:03:07 <alkaid> so, thanks again
21:03:07 <Cale> At a beginner level like that, not tuning for performance, I would go with:
21:03:09 <Cale> length [] = 0
21:03:13 <Cale> length (x:xs) = 1 + length xs
21:03:21 <alkaid> see you in my next trivial question
21:03:23 <alkaid> :P
21:03:24 <Cale> :)
21:03:32 <ryanakca> alkaid: Yes, my only quirk with it so far is that they always say ``We'll tell you about it in Chapter X, until then, take us on faith''... but oh well... Have fun
21:03:42 <Axman6> ryanakca: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4237#a4238 is more common
21:03:56 <Axman6> except that the alignment is messed up now, oh well
21:05:00 <Axman6> ryanakca: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4237#a4239 with proper indentation... almost (the second mL needs another space)
21:05:34 <Cale> If you're going to go with the helper function, you shouldn't pattern match
21:05:47 <Cale> (The helper should patter match the list)
21:05:51 <Cale> pattern*
21:05:52 <Berengal> length = foldl' (fmap (+1) . const) 0
21:06:45 <ryanakca> Axman6: So, just move mL 0 (x:xs) up to the previous line?
21:06:50 <Cale> Why not just  const (+1) ?
21:06:54 <Axman6> yeah
21:07:06 <Cale> oh
21:07:07 <ryanakca> Cale: Ah, that's interesting too. *tries*
21:07:13 <Cale> Needs flipping :P
21:07:19 <dolio> const . (+1)
21:07:28 <ryanakca> const? foldl? fmap?
21:07:29 <ryanakca> :)
21:07:44 <Cale> :t let length = foldl' (const . (+1)) 0 in length
21:07:45 <lambdabot> forall b a. (Num a) => [b] -> a
21:07:48 <Cale> yeah
21:07:58 <ryanakca> Don't worry, I'm about to go to bed, I'll surely read about it in RWH tomorrow
21:08:03 <Berengal> let length = foldl' (const . (+1)) 0 in length [1..10]
21:08:07 * Cale is too used to foldr :)
21:08:13 <Berengal> > let length = foldl' (const . (+1)) 0 in length [1..10]
21:08:15 <lambdabot>   10
21:08:22 <Gracenotes> improbable!!
21:08:32 <Cale> > let length = foldl' (const . (+1)) 0 in length "hello"
21:08:33 <lambdabot>   5
21:08:52 <Gracenotes> > let length = foldl' (const . (+1)) 0 in length [1..(10^7)]
21:08:56 <lambdabot>   10000000
21:09:04 <Cale> > let length = foldl (const . (+1)) 0 in length [1..(10^7)]
21:09:12 <Berengal> I must admitt, I first thought about using foldr for this, but then I realized this was the perfect case for foldl'
21:09:14 <lambdabot>   mueval: Prelude.read: no parse
21:09:18 <Cale> ...
21:09:23 <Asztal> @src genericLength
21:09:23 <alkaid> :t foldl
21:09:23 <lambdabot> genericLength []    = 0
21:09:23 <lambdabot> genericLength (_:l) = 1 + genericLength l
21:09:24 <Cale> no parse?
21:09:26 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
21:09:28 <Cale> heh
21:10:03 <Cale> alkaid: foldr is easier to explain than foldl
21:10:19 <Gracenotes> Cale:  10^7 is a value that tends to cause stack overflow
21:10:19 <alkaid> :P
21:10:21 <Berengal> I had a tougher time with foldr than foldl...
21:10:21 <Cale> alkaid: foldr f z is a function which replaces each (:) in the list with f and the [] at the end with z
21:10:22 <Gracenotes> s
21:10:32 <alkaid> I just saw this function being used in a comment in the book
21:10:45 <Cale> Gracenotes: I know, I just figured we'd see a better error message :P
21:10:54 <Berengal> I used foldr all the time when I first started out, but thought it meant "fold rightwards", or in other words, the way foldl folds
21:10:56 <Cale> Berengal: Does that description of it help?
21:11:08 <Gracenotes> foldr is interesting because it can be completely evaluated before the entire list is traversed
21:11:12 <ryanakca> Cale: How would you use it? foldr f z $ list   ?
21:11:14 <Gracenotes> "lazy semantics" you might say
21:11:18 <Cale> ryanakca: yeah
21:11:27 <Cale> ryanakca: or without the $ even :)
21:11:34 <Berengal> Cale: The replacement? Yeah, that's kind of how I see it now
21:11:35 <Gracenotes> however, if the folding function is strict, then it does behave very much like simply folding rightwards
21:11:46 <ryanakca> and foldl would?
21:12:00 <alkaid> Cale - let me think a bit about the description you gave.. 1 mn
21:12:01 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" [1,2,3,4,5]
21:12:04 <lambdabot>   "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
21:12:11 <Berengal> foldr takes an operator and inserts that operator inbetween the elements of a list in a right-associative manner
21:12:23 <Cale> Berengal: I don't like that description as much.
21:12:37 <copumpkin> > foldr f 0 [1..5]
21:12:38 <lambdabot>   Add a type signature
21:12:42 <copumpkin> > foldr f 0 [1..5] :: Expr
21:12:43 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 0))))
21:12:52 <Cale> But it does make the relationship with foldl easier to see :)
21:13:12 <tsLight> is there a way to make Hugs do that?
21:13:17 <tsLight> the foldr f 0 [1..5] :: Expr
21:13:18 <Berengal> Cale: Yeah, the relationship with foldl was the point of that description, not so much their operation itself
21:13:22 <Cale> > foldr (\acc x -> concat ["(f ",acc," ",show x,")"]) "z" [1,2,3,4,5]
21:13:23 <copumpkin> I don't think there's anything GHC-specific to that trick
21:13:23 <lambdabot>       No instance for (Num [Char])
21:13:23 <lambdabot>        arising from the literal `1' at <in...
21:13:24 <Gracenotes> depending on f, "f 5 0" might never get evaluated
21:13:25 <Cale> er
21:13:35 <Berengal> foldr and foldl overrides the associativity of the operators, if they have any...
21:13:44 <Cale> > foldl (\acc x -> concat ["(f ",acc," ",show x,")"]) "z" [1,2,3,4,5]
21:13:46 <lambdabot>   "(f (f (f (f (f z 1) 2) 3) 4) 5)"
21:13:56 <Cale> Right, forgot to change the r to l :P
21:14:08 <alkaid> Cale - I think I got it. This is something I can't imagine how to do in C.
21:14:17 <Gracenotes> > foldr (&&) True $ (replicate 10 True) ++ (repeat False)
21:14:18 <Cale> alkaid: So for instance...
21:14:19 <lambdabot>   False
21:14:24 <Cale> > foldr (+) 0 [1..5]
21:14:26 <lambdabot>   15
21:14:37 <copumpkin> > foldr (+) 0 [1..5] :: Expr
21:14:38 <lambdabot>   1 + (2 + (3 + (4 + (5 + 0))))
21:14:41 <Gracenotes> foldr can work nicely for infinite lists. foldl, not so much.
21:14:41 <Cale> > foldr (++) "" ["here", "are", "some", "strings"]
21:14:43 <lambdabot>   "herearesomestrings"
21:14:52 <Cale> > foldr (*) 1 [1..10]
21:14:53 <lambdabot>   3628800
21:14:58 <Berengal> > foldl (\acc x -> concat ["(acc," `f` ",show x,")"]) "z" [1,2,3,4,5]
21:15:00 <lambdabot>   <no location info>: parse error on input `)'
21:15:32 <alkaid> so
21:15:52 <alkaid> (\ n-> foldr (*) 1 [1..n])
21:15:57 <alkaid> is the factorial function
21:15:59 <Cale> yes
21:16:16 <alkaid> this is a very elegant way of doing it
21:16:27 <Berengal> > foldl (\acc x -> concat ["(",acc," `f` ",show x,")"]) "z" [1,2,3,4,5]
21:16:28 <lambdabot>   "(((((z `f` 1) `f` 2) `f` 3) `f` 4) `f` 5)"
21:16:30 <Asztal> the foldl thing would look nicer if it supported operators
21:16:39 <Cale> Asztal: it does?
21:16:40 <alkaid> and the performance is better than the plain recursion, right?
21:16:56 <Cale> alkaid: No...
21:16:58 <alkaid> it creates the final expression we want evaluate at once...
21:17:00 <Berengal> alkaid: It is plain recursion
21:17:00 <alkaid> no?
21:17:06 <Cale> alkaid: They're not primitives.
21:17:11 <Cale> alkaid: Just library functions.
21:17:15 <Asztal> Cale: oh, so it does
21:17:16 <alkaid> Oh, I see
21:17:20 <Cale> alkaid: They're implemented with recursion :)
21:17:26 <Berengal> ?src foldr
21:17:27 <lambdabot> foldr f z []     = z
21:17:27 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:17:27 <alkaid> I see
21:17:43 <alkaid> (this lambdabot is something, isn't it?)
21:18:08 <alkaid> I see
21:18:13 <Cale> alkaid: foldl' has a clever implementation though, in that it evaluates the function applications strictly, which can save on space in some cases, but left folds can't be used on infinite lists, and certainly not strict ones
21:18:28 <Cale> (that is, with the extra 'prime' like that)
21:18:34 <Berengal> ?src foldl
21:18:34 <lambdabot> foldl f z []     = z
21:18:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:18:36 <Berengal> ?src foldl'
21:18:36 <lambdabot> foldl' f a []     = a
21:18:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:19:05 <Cale> foldl' evaluates the  f a x  before continuing to recurse
21:19:06 <alkaid> humm
21:19:13 <alkaid> I see
21:19:19 <Cale> whereas foldl just builds up a large expression, recursing immediately
21:19:31 <Cale> This can matter if the lists are very large.
21:19:39 <Cale> > foldl (+) 0 [1..10000000]
21:19:52 <lambdabot>   mueval: Prelude.read: no parse
21:19:52 <Cale> (probably an error message...)
21:19:55 <Cale> > foldl' (+) 0 [1..10000000]
21:20:00 <lambdabot>   50000005000000
21:20:05 <alkaid> :O
21:20:08 <Cale> Normally the error message would mention the stack.
21:20:12 <Berengal> > maximum [1..10^6]
21:20:14 <lambdabot>   * Exception: stack overflow
21:20:18 <Berengal> ?src maximum
21:20:19 <lambdabot> maximum [] = undefined
21:20:19 <lambdabot> maximum xs = foldl1 max xs
21:20:35 <Berengal> There :)
21:20:44 <Cale> > foldl1' max [1..10^6]
21:20:45 <lambdabot>   1000000
21:20:55 <Cale> So sometimes, strictness really does matter
21:21:12 <alkaid> I see
21:21:14 <Cale> Thankfully, most of the cases where you really want strictness also happen to be left folds.
21:21:23 <Berengal> When you foldl you'll want to foldl'
21:21:37 <Cale> I could explain this better...
21:21:46 <Berengal> There are some cases where they're not equal, but most of the time they are
21:22:25 <Cale> alkaid: Do you know how lazy evaluation works?
21:22:37 <alkaid> a bit
21:22:58 <Cale> alkaid: It always proceeds by evaluating the outermost function first, substituting the parameters into the body of the function (with a small additional optimisation)
21:23:06 <alkaid> the expressions aren't evaluated until we need a value, right?
21:23:17 <Cale> That is, it doesn't evaluate the parameters before substituting.
21:23:26 <alkaid> hum
21:23:29 <Cale> An example I like to give is with this function:
21:23:30 <alkaid> if the parameter is an expression
21:23:37 <Cale> double x = x + x
21:23:47 <alkaid> right
21:23:55 <Cale> We can look at various ways of evaluating  double (double 5)
21:24:22 <Cale> Under strict evaluation, like C and most imperative languages use, it goes:
21:24:25 <Cale> double (double 5)
21:24:28 <Cale> -> double (5 + 5)
21:24:31 <Cale> -> double 10
21:24:34 <Cale> -> 10 + 10
21:24:35 <Cale> -> 20
21:24:42 <Cale> Nothing surprising there.
21:24:44 <alkaid> right
21:25:12 <Cale> Under plain outermost-first evaluation, also called "normal order evaluation" despite not being very common, it goes like:
21:25:15 <Cale> double (double 5)
21:25:21 <Cale> -> double 5 + double 5
21:25:26 <Cale> -> (5 + 5) + double 5
21:25:30 <Cale> -> 10 + double 5
21:25:33 <Cale> -> 10 + (5 + 5)
21:25:35 <Cale> -> 10 + 10
21:25:37 <Cale> -> 20
21:25:59 <Cale> But you might notice something here. It wasted work, computing double 5 twice.
21:26:14 <alkaid> so in this case you evaluate first the outer double
21:26:17 <Cale> yeah
21:26:26 <Axman6> Cale: you know what, you need to write a library that can do these expansaions and evaluations stepwise for you, you're so good at them :)
21:26:42 <Cale> Axman6: hehe
21:26:50 <Axman6> i know that simple-reflect has something like it though
21:26:55 <Cale> alkaid: So lazy evaluation does one extra optimisation
21:26:57 <Axman6> @hoogle Expr
21:26:58 <lambdabot> module Text.Parsec.Expr
21:26:58 <lambdabot> module Text.ParserCombinators.Parsec.Expr
21:26:58 <lambdabot> Distribution.Simple.Program alexProgram :: Program
21:27:11 <Axman6> @hoogle Expr -> [Expr]
21:27:11 <lambdabot> Warning: Unknown type Expr
21:27:11 <lambdabot> Prelude repeat :: a -> [a]
21:27:11 <lambdabot> Data.List repeat :: a -> [a]
21:27:17 <Axman6> bah
21:27:23 <Berengal> > foldl' (flip (:) [] [1..10]
21:27:24 <lambdabot>   <no location info>: parse error on input `;'
21:27:33 <Cale> alkaid: If a parameter to a function occurs more than once in the body, work on evaluating that parameter is shared between the copies.
21:27:34 <Berengal> > foldl' (flip (:)) [] [1..10]
21:27:35 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
21:27:56 <Cale> Berengal: That's the one case where I'd say foldl is better.
21:28:01 <Axman6> > let double x = x + x in reduction (double (double 5))
21:28:02 <lambdabot>   Not in scope: `reduction'
21:28:06 <Cale> heh
21:28:18 <Cale> I'd love to have something like that
21:28:20 <Axman6> , let double x = x + x in reduction (double (double 5))
21:28:20 <Cale> alkaid: So...
21:28:23 <lunabot>  luna: Not in scope: `reduction'
21:28:31 <Axman6> > let double x = x + x in Debug.SimpleReflect.Expr.reduction (double (double 5))
21:28:32 <lambdabot>       Failed to load interface for `Debug.SimpleReflect.Expr':
21:28:33 <lambdabot>        Use -v ...
21:28:37 <Axman6> gah
21:28:38 <Cale> Axman6: What are you doing?
21:28:43 <Axman6> i've seen it used here
21:28:44 <Berengal> Cale: Why? Memory?
21:28:48 <Asztal> it's probably version 0.1 of SimpleReflect
21:28:53 <Cale> Berengal: why does it share work?
21:29:24 <Axman6> > let double x = x + x in iterate reduce (double (double 5))
21:29:25 <lambdabot>   [5 + 5 + (5 + 5),10 + (5 + 5),10 + 10,20,20,20,20,20,20,20,20,20,20,20,20,2...
21:29:31 <Axman6> there we go :)
21:29:41 <alkaid>  Cale - I'm listening
21:29:49 <Cale> Berengal: Note that the outermost-first reduction of double (double 5) took more steps than the innermost-first one
21:29:53 <Axman6> iterate reduce -- the Cale function
21:29:56 <Cale> Berengal: because it evaluated double 5 twice
21:30:18 <Cale> alkaid: okay, so if you'll allow me to use let ... in ... to represent the sharing, it looks like this:
21:30:21 <Cale> double (double 5)
21:30:27 <Cale> -> let x = double 5 in x + x
21:30:35 <Cale> (so we still expand the outer double first)
21:30:43 <Gracenotes> Axman6: I thought I came up with it :( independently, anyway
21:30:44 <Cale> -> let x = 5 + 5 in x + x
21:30:50 <Cale> -> let x = 10 in x + x
21:30:54 <Cale> -> 20
21:31:03 <Gracenotes> Axman6: what is all this credit-stealing nowadays! Really!
21:31:10 <alkaid> hum
21:31:10 <Axman6> eh?
21:31:14 <Gracenotes> :P
21:31:23 * Axman6 is tehfused
21:31:25 <alkaid> so it just calculates the double 5 once
21:31:28 <Cale> right
21:31:36 <Cale> and shares it between the copies
21:31:54 <Gracenotes> >_>
21:32:11 <Cale> But, since it's still outermost-first, if the function were different, and part of the result was available before we needed x, then we might never have to compute x
21:32:17 <Axman6> Gracenotes: i know i've seen it used in here before, if it wsd yours, then nice work :)
21:32:36 <Cale> (but since it's just addition, we inevitably have to compute it to get a result)
21:33:08 <Cale> (+) on integers will demand the evaluation of both its parameters before it gives anything
21:33:37 <alkaid> I see. If we had a case where the result doesn't depend on x, it would be able to give the result without evaluating it
21:33:45 <Cale> You can think of it as being because (+) pattern matches, even though in the real implementation, it's primitive.
21:33:58 <Cale> Pattern matching is what forces evaluation to proceed.
21:34:17 <Cale> and things are only evaluated until they match a pattern
21:34:28 <Gracenotes> simple-reflect is a bit basic, though. To see a better representation of what gets shared in computation, try Debug.Traced
21:34:40 <Cale> alkaid: right
21:34:41 <Gracenotes> in ghci, "import Debug.Traced" and "showAsExp . reShare $ let double x = x + x in double (double 5)"
21:35:22 <Berengal> There's also vacuum...
21:35:24 <Gracenotes> > let _1 = 5 + 5; _0 = _1 + _1; in  _0 -- this is the result of the above snippet
21:35:26 <lambdabot>   20
21:35:37 <Gracenotes> right, although vaccum seems to be more for data structures
21:35:52 <Cale> Gracenotes: Hehe, you kids and your fancy evaluation tracers! In my day, we wrote out evaluation traces by hand on a blackboard, and we liked it that way!
21:36:09 <Berengal> Gracenotes: Well, yes, it doesn't show expressions...
21:36:16 <Gracenotes> > let _2 = 2 * 2; _1 = _2 * _2; _3 = _2 * 2; _0 = _1 * _3; in  _0 -- output for 2^7
21:36:18 <lambdabot>   128
21:36:23 <Gracenotes> Cale: hehe :)
21:36:43 <alkaid> thanks again Cale
21:36:43 <alkaid> and everybody else
21:36:55 <Cale> Seriously though, writing out some evaluation traces by hand can really help gain some intuition.
21:37:19 <Cale> The effect of lazy evaluation on performance takes quite a bit of getting used to
21:37:23 <BMeph> Cale: Have you mentioned finding the length of lists with undefined elements as an example? :)
21:37:32 <Cale> oh, right, we can do that :)
21:37:42 <Cale> > length [undefined, undefined, undefined]
21:37:43 <lambdabot>   3
21:37:46 <Cale> > undefined
21:37:47 <lambdabot>   * Exception: Prelude.undefined
21:37:59 <Cale> (if undefined is evaluated, it throws an exception)
21:38:01 <Berengal> > length [12,2,3,4,5/0,6,7]
21:38:03 <lambdabot>   7
21:38:23 <Cale> > let x = x+1 in x
21:38:25 <Berengal> > 5/0
21:38:26 <lambdabot>   Infinity
21:38:39 <lambdabot>   thread killed
21:38:49 <Berengal> Oh, and don't forget fix ;)
21:38:51 <Berengal> @type fix
21:38:52 <lambdabot> forall a. (a -> a) -> a
21:38:54 <Cale> > let x = x+1 in length [x,x,x]
21:38:55 <lambdabot>   3
21:39:08 <Cale> > fix (1:)
21:39:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:39:25 <Cale> > let x = 1:x in x
21:39:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:39:42 <Berengal> Hmm... loeb?
21:39:44 <Berengal> @type loeb
21:39:46 <lambdabot> Not in scope: `loeb'
21:39:48 <Berengal> :O
21:39:54 <alkaid> this is a list of infinite many 1?
21:40:00 <Cale> The reason it works is because only a finite amount of the list is needed to print the initial part of the result.
21:40:02 <Cale> yeah
21:40:24 <Berengal> @type let loeb x = fmap (\a -> a (loeb x)) x in loeb
21:40:26 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
21:40:58 <Berengal> > cycle [1..10]
21:41:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6...
21:41:11 <alkaid> :O
21:41:15 <Berengal> A cycled list takes up less space than a non-cycled one
21:41:18 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p^2 <= n) $ primes in primes
21:41:19 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:41:26 <Cale> ^^ infinite list of primes
21:41:41 <alkaid> oh, now you are kidding!!
21:41:52 <Berengal> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
21:41:54 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:42:00 <alkaid> ahahaha
21:42:02 <Berengal> Fibonacci
21:42:23 <copumpkin> > fix ((0:) . scanl (+) 1)
21:42:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
21:42:45 <Cale> I love the way that particular version of the primes works.
21:42:59 <Cale> Note the mutual recursion.
21:43:06 <copumpkin> it's pretty hot :)
21:43:23 <alkaid> I understood Berengal's fibonacci
21:43:23 <Berengal> My version of primes has mutual recursion on primes, isPrime and factorize...
21:43:41 <copumpkin> my e-penis is even bigger! but I haven't thought how yet
21:43:43 <alkaid> the other two I couldn't
21:43:54 <Cale> The fix version is sneaky.
21:44:03 <Berengal> Fix itself is very sneaky...
21:44:06 <Berengal> ?src fix
21:44:06 <lambdabot> fix f = let x = f x in x
21:44:15 <copumpkin> it does the mutual recursion for you! :D
21:44:19 <Cale> fix finds the least-defined fixed point of a function
21:44:37 <Cale> (so if undefined is a fixed point, that's what you'll get :)
21:44:39 <Berengal> > fix (const 6)
21:44:41 <lambdabot>   6
21:44:46 <Cale> > fix sin
21:44:47 <lambdabot>   * Exception: stack overflow
21:44:59 <tsLight> is there a way to open Hugs interpreter and be able to work with list functions, just like I do with Prelude?
21:44:59 <alkaid> hum
21:45:00 <Cale> (doesn't do any analysis ;)
21:45:04 <Cale> > fix (1:)
21:45:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:45:08 <tsLight> I mean without opening a .hs file that says Import List
21:45:12 <copumpkin> lol
21:45:20 <alkaid> > fix (\ x-> x*(1-x) )
21:45:31 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
21:45:33 <lambdabot>   3628800
21:45:36 <lambdabot>   thread killed
21:45:54 <copumpkin> the killed one was the first one :P
21:45:59 <copumpkin> lambabot should respond with your nick
21:46:08 <Cale> That's a good idea, it should
21:46:10 <Berengal> That would be nice
21:46:58 <alkaid> I still don't know if I got fix
21:47:09 <Cale> alkaid: another definition is  fix f = f (fix f)
21:47:12 <copumpkin> it isn't an intuitive function :)
21:47:17 <alkaid> > fix (\ x-> x)
21:47:20 <Cale> So fix f = f (f (f (f ...)))
21:47:29 <alkaid> it will crash again
21:47:32 <Cale> yeah
21:47:32 <lambdabot>   thread killed
21:47:38 <copumpkin> it's a good way to make those FFFFFFFFFUUUUUUUU ugly comics
21:47:46 <alkaid> humm
21:47:53 <DOKKA> gah
21:47:57 <DOKKA> hello
21:47:58 <copumpkin> except you never get to the U
21:48:00 <Berengal> > let loeb x = fmap (\a -> a (loeb x)) x in loeb (const 1:const 1:[(\l -> (l!!i)+(l!!(i+1)))| i <- [0..]]
21:48:01 <lambdabot>   <no location info>: parse error on input `;'
21:48:02 <alkaid> humm
21:48:03 <copumpkin> hello DOKKA
21:48:06 <MyCatVerbs> Cale: stupid question, but does fix f = f (fix f) have the same space usage characteristics as fix f = let x = f x in x?
21:48:14 <kadaver> > foldl (++) "" $ intercalate " " ["My","wife","is","a","milf"]
21:48:16 <copumpkin> no
21:48:16 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:48:17 <Cale> MyCatVerbs: no
21:48:23 <kadaver> > foldl (++) "" $ intersperse " " ["My","wife","is","a","milf"]
21:48:25 <lambdabot>   "My wife is a milf"
21:48:35 <Cale> alkaid: Part of the result of f must be available without looking at the parameter, or else you will just get an infinite loop
21:49:09 <MyCatVerbs> kadaver: one would hope so, for the sake of your marriage.
21:49:14 <copumpkin> > let fix f = f (fix f) in fix (1:) -- should work
21:49:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:49:18 <alkaid> I got it
21:49:19 <Cale> alkaid: Note that 1 : undefined is not the same thing as undefined
21:49:21 <MyCatVerbs> Cale: thanks.
21:49:24 <Cale> because, for instance
21:49:30 <alkaid> I was thinking imperatively again
21:49:31 <Cale> > head (1 : undefined)
21:49:31 <copumpkin> but in other cases it won't work
21:49:32 <lambdabot>   1
21:50:03 <Cale> So, since undefined is not a fixed point of (1:)
21:50:13 <Cale> fix (1:) cannot be undefined
21:50:33 <Cale> So it's got to be something more defined than that :)
21:50:45 <alkaid> ahahaha
21:51:05 <Berengal> Lazy evaluation is funny in that it has several levels of definedness. Strict evaluation has only two
21:51:12 <Cale> Whereas, everything is a fixed point of (\x -> x), and in particular, a nonterminating computation like undefined is, so fix (\x -> x) will be undefined.
21:51:32 <alkaid> oh, I got it!
21:51:39 <Cale> fix always gives you the *least defined* fixed point
21:51:39 <alkaid> the least defined fixed point
21:51:43 <Cale> right
21:52:02 <copumpkin> so if undefined is a fix point, it'll give you that :P
21:52:20 <copumpkin> meaning that most of the things you throw at fix are going to fail epicly :P
21:52:22 <alkaid> when you talked about fixed points I was thinking numerically
21:52:31 <alkaid> hahahha
21:52:36 <Cale> btw, we tend to equate all sorts of async exceptions and nontermination and such when talking about values like this
21:52:51 <Cale> alkaid: Well, it is sort of in the same sense.
21:53:11 <Berengal> undefined == bottom == _|_ == 1/0 == infinite loop
21:53:20 <Cale> in that if u = fix f, then u = f u
21:53:24 <copumpkin> you mean 1 `div` 0 :P
21:53:24 <Cale> In fact...
21:53:34 <alkaid> yes, but I can see undefined will be a fixed point of most numerical functions I can think of
21:53:35 <Cale> @src fix
21:53:36 <lambdabot> fix f = let x = f x in x
21:53:42 <Berengal> Right, 1/0 == infinity...
21:53:50 <Cale> alkaid: yeah :)
21:53:53 <Berengal> > (1/0, 1 `div` 0)
21:53:55 <lambdabot>   (Infinity,* Exception: divide by zero
21:53:56 <QtPlaty[HireMe]> Berengal: Not quite.
21:54:17 <copumpkin> 1/x gets unboundedly large as x approaches 0 :P
21:54:19 <copumpkin> how bout that
21:54:20 <QtPlaty[HireMe]> Berengal: Lim x -> 0 1/x == infinity
21:54:21 <Cale> alkaid: Because most numeric types are strict datastructures -- you don't have partially defined numbers.
21:54:28 <Berengal> > 1/0
21:54:30 <lambdabot>   Infinity
21:54:35 <Berengal> ^^ See?
21:54:37 <copumpkin> that's an actual value, though
21:54:39 <copumpkin> you can work with it
21:54:41 <copumpkin> it's not bottom
21:54:45 <Gracenotes> > (1/0) / (1/0)
21:54:47 <lambdabot>   NaN
21:54:52 <Gracenotes> but
21:54:55 <Gracenotes> > 1/0 :: CReal
21:55:05 <copumpkin> yeah, that fails
21:55:11 <lambdabot>   thread killed
21:55:17 <copumpkin> only IEEE floats are made of win
21:55:30 <copumpkin> l33tsauce, even
21:55:36 <Cale> It would be nice to have a CReal type which was practical.
21:55:48 <Cale> I hate IEEE floats.
21:55:51 <copumpkin> me too
21:55:57 <Berengal> Floats are ugly...
21:55:58 <copumpkin> they're an insult to math :o
21:56:08 <Gracenotes> CReals have teh pr3c1sion and accU5ac7
21:56:22 <copumpkin> doesn't GMP provide arbitrary precision decimal numbers too?
21:56:33 * Berengal likes his rationals
21:56:38 <Gracenotes> hm, I feel that was a 1337 failure
21:56:44 <Gracenotes> @elite precision and accuracy
21:56:44 <lambdabot> PRE(IzioN and ACCURacY
21:56:45 <Cale> Gracenotes: I was about to say...
21:56:48 <copumpkin> Gracenotes: you fail, clearly I'm l33ter than you
21:56:48 <QtPlaty[HireMe]> Well your never going to have a way of doing real maths on a church/turing computer.
21:56:54 <Gracenotes> @elite precision and accuracy
21:56:54 <lambdabot> PREcI$ION 4nD accuRa(Y
21:57:01 <Cale> Gracenotes: 5 is not an acceptable r ;)
21:57:17 <Gracenotes> maybe if you're not leet enough!
21:57:43 <QtPlaty[HireMe]> Its just an inaccurate r
21:57:55 <Cale> "threeleet"
21:58:20 <copumpkin> so yeah, it looks like gmp has decimals
21:58:30 <copumpkin> can't we provide primops to that?
21:58:51 <Cale> copumpkin: Arbitrary precision decimals isn't *quite* the same as computable reals, but it would also be good.
21:58:59 <copumpkin> true
21:59:17 <Cale> Is it really decimal?
21:59:21 <copumpkin> I was going to dig in and provide a modexp primop too
21:59:24 <Cale> (not binary?)
21:59:30 * QtPlaty[HireMe] ponders dealing with reals as functions (Natural -> Rational)
21:59:33 <copumpkin> oh I meant decimal in the very informal sense
21:59:40 <Cale> ah
21:59:47 <copumpkin> "High-level floating-point arithmetic functions (mpf). This is the GMP function category to use if the C type `double' doesn't give enough precision for an application. There are about 65 functions in this category."
22:00:01 <copumpkin> they also have fast rationals
22:00:09 <copumpkin> maybe I'll stuff a bunch of GMP primops in
22:04:16 <Cale> Hehe, by 6.12, we'll have arbitrary-precision floating point numbers in base :)
22:04:32 <copumpkin> really?
22:04:43 <Berengal> I wouldn't be sad if that happened...
22:04:45 <copumpkin> or do you mean because I plan on sticking the primops in? :P
22:04:52 <dolio> You could probably make a separate library out of the floating point/rational stuff.
22:04:52 <Cale> copumpkin: just that
22:05:08 <copumpkin> yeah, my main objective at first was just to stick modexp in
22:05:13 <copumpkin> and dolio wanted something too, but I forgot what :P
22:06:01 <dolio> The only reason I think you can't do Integer stuff like that easily is that GHC does fancy stuff with the GMP representation to get its internal representation of Integers.
22:06:13 <dolio> And I don't know how to work with that via the FFI.
22:07:06 <alkaid> ok ppl... It's 2 a.m. here in Brazil and I have a seminar to watch in a few hours
22:07:10 <dolio> If it were just wrapping a ForeignPtr or something it'd be clearer (though probably slower).
22:07:14 <alkaid> so, good bye
22:07:17 <Cale> alkaid: see you around!
22:07:23 <alkaid> see ya
22:09:01 <lpsmith> Cale:  why not exact real arithmetic as well?  :-P
22:09:42 <lpsmith> Is the GMP exact real,  or arbitrary precision,  in the sense that you can choose the precision needed for the computation beforehand?
22:10:07 <dolio> If I recall correctly, you choose the precision beforehand.
22:10:10 <Cale> lpsmith: I would like exact real, but GMP's implementation is only arbitrary precision, I think.
22:10:17 <lpsmith> ahh
22:10:21 <lpsmith> still useful :-)
22:10:40 <c_wraith> exact real is an... *interesting*...  concept. :)
22:11:17 <copumpkin> what percentage of all reals are computable? ;)
22:11:36 <DOKKA> hey yall, so anyways I'm a bit of a noob
22:11:40 <c_wraith> There are an uncountable number of reals without any finite representation. :)
22:11:40 <dolio> 0
22:11:47 <DOKKA> and I have a program for yall to look at
22:12:05 <lpsmith> lol,  yes,  0
22:12:05 <DOKKA> http://www.scuffmark.tk/listLen.txt
22:12:18 <copumpkin> so that's useless! :P
22:12:31 <lpsmith> Almost every real exists only as the limit of a infinite random process
22:12:35 <DOKKA> it's rediculously simple, yet it won't run
22:12:57 <lpsmith> copumpkin:  at least the computable reals are dense :-P
22:13:04 <copumpkin> so am I
22:13:29 <c_wraith> I claim the real numbers are too big of a set to be really useful. >_>
22:13:47 <roconnor> DOKKA: are you trying to run it in GHCi?
22:14:05 <DOKKA> yes
22:14:22 <lpsmith> c_wraith:  sometimes I agree.  I go back and forth.   Unfortunately real analysis isn't my strong suit.  :)
22:14:45 <DOKKA> I am trying to make a function that finds the length of a list
22:15:16 <QtPlaty[HireMe]> DOKKA: Rather then using the built in lenght function?
22:15:18 <DOKKA> it does load
22:15:35 <DOKKA> it's an excersize from the book
22:15:36 <lpsmith> two problems with the LHS of your definitions:
22:15:37 <QtPlaty[HireMe]> *length
22:15:39 <lpsmith> well
22:15:40 <lpsmith> three
22:15:43 <roconnor> *Main> listlen [1,2,3]
22:15:44 <roconnor> 2
22:15:53 <roconnor> DOKKA: runs for me
22:16:04 <lpsmith> oh
22:16:04 <roconnor> $ ghci /tmp/foo.hs
22:16:25 <roconnor> what's the question about exact real arithmetic?
22:16:43 <DOKKA> hmm
22:16:55 <DOKKA> what's a LHS?
22:16:59 <lpsmith> right,  you are defining two different functions.   Heh,  read that as one definition.   :-D
22:17:03 <Berengal> left hand side
22:17:03 <lpsmith> Left hand side
22:17:10 <DOKKA> ah
22:17:11 <QtPlaty[HireMe]> DOKKA: What should the lenght of [] be?
22:17:22 <DOKKA> oh crap I see it now
22:17:53 <lpsmith> roconner:  I'm not sure there was a question about exact real arithmetic,  other than clarifying that's not what the GMP will be adding
22:18:07 <lpsmith> roconner:  but feel free to expound on it,  by all means :-)
22:18:22 <roconnor> GMP only does integer arithmetic, right?
22:18:25 <DOKKA> it should be 0
22:18:39 <copumpkin> no
22:19:02 <copumpkin> it does int, rational, and "float"
22:19:06 <lpsmith> According to Cale,  the GMP will be adding arbitrary precision reals sometime soonish.
22:19:07 <QtPlaty[HireMe]> DOKKA: So would 'listlen [] = 0' work as your base case?
22:19:08 <roconnor> ah
22:19:15 <roconnor> copumpkin: I didn't know that
22:19:31 <Cale> lpsmith: Um, according to copumpkin, it already has them?
22:19:40 <DOKKA> I guess it would
22:19:50 <lpsmith> I dunno,  this is the first I heard of such things!
22:19:57 <Cale> lpsmith: (I was trusting copumpkin)
22:20:10 <QtPlaty[HireMe]> DOKKA: What would the lenght of (x:xs) be?
22:20:20 <dolio> It's also according to the documentation. :)
22:20:21 <DOKKA>  QtPlaty[HireMe]: 2
22:20:29 <mauke> QtPlaty[HireMe]: at least you're consistent :-)
22:20:34 <Cale> DOKKA: Remember that xs is another list.
22:20:36 <QtPlaty[HireMe]> DOKKA: Not quite?
22:20:40 <Mortomes> DOKKA: Out of curiousity, have you programmed in Prolog before?
22:20:50 <Cale> DOKKA: It might even be the empty list
22:21:01 <mauke> > length (42 : [])
22:21:03 <lambdabot>   1
22:21:05 <copumpkin>  that's cause I hacked their site and rewrote their documentation to further my own mysterious agenda
22:21:06 <DOKKA> nope, just java and
22:21:08 <Cale> DOKKA: However, you can express the length of (x:xs) in terms of the length of xs
22:21:10 <DOKKA> pythin
22:21:30 <Berengal> DOKKA: Also, tail calls in Haskell... don't do what you seem think they do
22:21:49 <DOKKA> ah, yeah
22:21:57 <QtPlaty[HireMe]> DOKKA: If you knew the length of xs could you work out the lenght of (x:xs) ?
22:22:01 <Cale> DOKKA: It's just one more element, right?
22:22:17 <DOKKA> right
22:22:27 <Cale> DOKKA: So what's the equation? :)
22:22:33 <QtPlaty[HireMe]> DOKKA: Can you write that as a haskell function?
22:22:43 <lpsmith> Berengal:  yes and no.  Tail calls work a little bit differently,  but they are still an important concept in Haskell
22:22:51 <DOKKA> hmm
22:23:16 <DOKKA> could this be done with recursion?
22:23:23 <QtPlaty[HireMe]> DOKKA: Yes
22:23:31 <lpsmith> DOKKA:  you are using recursion!
22:23:37 <Berengal> lpsmith: I wouldn't say "just a bit". They're different enough that you need to know exactly how they work
22:23:40 <tsLight> DOKKA, this is called primitive recursion =)
22:23:40 <DOKKA> I know
22:23:48 <mauke> it has to be done with recursion; [] is a recursive type :-)
22:23:53 <Cale> DOKKA: Basically, if you just write down "the length of (x:xs) is 1 more than the length of xs" in Haskell notation, you'll be done :)
22:24:17 <lpsmith> Berengal:  how so?
22:24:27 <QtPlaty[HireMe]> DOKKA: As long as you have the base case there already
22:24:27 <DOKKA> but how do I return the answer?
22:24:35 <lpsmith> tsLight:  DOKKA's code as is is not primitive recursive.
22:24:46 <lpsmith> It uses an accumulator
22:24:51 <tsLight> lpsmith, I am talking about using [] as base case and then x:xs as the recursive step
22:24:52 <Cale> DOKKA: the right hand side of the equation is the answer
22:25:01 <QtPlaty[HireMe]> DOKKA: The stuff on the right hand side is returned
22:25:44 <DOKKA> right
22:25:56 <Berengal> lpsmith: Well, tail calls can overflow the stack. non-tail-recursive recursion can run in constant stack...
22:26:29 <p_l> ... wasn't it the other way around?
22:26:34 <Cale> DOKKA: So, to summarize, it's just   length [] = 0; length (x:xs) = 1 + length xs
22:26:53 <QtPlaty[HireMe]> p_l: Lazyness screws around with that.
22:27:08 <Berengal> p_l: "Can", not "has to".
22:27:13 <mauke> abstract class List { int length(); }  class Nil extends List { int length() { return 0; } }  class Cons extends List { Object head; List tail; int length() { return 1 + tail.length(); } }
22:27:31 <DOKKA> Cale: wow you can do that?
22:27:31 <MyCatVerbs> p_l: if you tail call to a constructor, then you can run in constant stack.
22:27:32 <Cale> Berengal: Even saying that is a bit misleading, since the stack's purpose is entirely different in GHC.
22:27:38 <Cale> DOKKA: yep
22:27:44 <lpsmith> tsLight:  Ahh you are right,  I was getting primitive recursion mixed up with natural recursion.
22:27:59 <dolio> copumpkin: One issue with the floating point numbers is how you decide on a precision. Presumably with the type, but type-level naturals (for representing the size) are currently kind of a pain.
22:28:03 <kerlo> DOKKA: is there any reason in particular you would expect to not be able to do that?
22:28:14 <p_l> ok, so it's because lazyness makes such stuff interesting :D
22:28:17 <MyCatVerbs> p_l: e.g. map f (a:as) = (f a) : map f as -- in this case, you're tail-calling (:) on (f a) and (map f as).
22:28:18 <Berengal> Cale: Well, yes... Haskell code doesn't really have a concept of stack, at least not directly
22:28:20 <copumpkin> dolio: oh yeah, we need that PhD that was advertised on -cafe :P
22:28:32 <Gracenotes> mauke: you definition has made me a bit nauseous >_<
22:28:33 <tsLight> DOKKA, read on "pattern matching"
22:28:34 <Gracenotes> r
22:28:35 <lpsmith> Natural recursion might not have a precise definition,  but I've heard several FP gurus use the term.  Using an accumulator isn't "natural"
22:28:36 <MyCatVerbs> p_l: and you end up with a list cell where the car is (f a) and the cdr is (map f as). ^^
22:28:36 <tsLight> its really useful
22:28:44 <DOKKA> returning 1+listLen is just kinda strange
22:29:01 * kerlo shrugs
22:29:04 <tsLight> DOKKA, the thing is you are applying the function to a "smaller list"
22:29:06 <DOKKA> I wouldn'rt expect it to know what to do with the integer
22:29:09 <QtPlaty[HireMe]> DOKKA: You will get used to it.
22:29:13 <tsLight> so it will eventually reach the base case and finish
22:29:28 <QtPlaty[HireMe]> DOKKA: Why wouldn't you expect it?
22:29:34 <mauke> DOKKA: does my pseudo java code look more natural to you?
22:29:43 <Cale> DOKKA: well,  length xs  is a legitimate integer.
22:29:48 <DOKKA> because it has no arguments
22:29:59 <lpsmith> Berengal:  I haven't quite figured out how GHC's stacks work,  though I have a pretty good sense about how to make code run fast.   If you use tail calls,  you often need to make sure things are strict;  then they really are tail calls like in ML.
22:30:16 <DOKKA> so it just ads the +1's and returns them
22:30:16 <QtPlaty[HireMe]> DOKKA: 1 + (listLen xs)
22:30:22 <Cale> DOKKA: The only important thing to realise is that since xs is going to be shorter than (x:xs) each time, eventually you will reach length [], which will finally give 0
22:30:50 <DOKKA> right, because that is used to deconstruct the list
22:30:55 <QtPlaty[HireMe]> DOKKA: More or less.
22:31:00 <Cale> DOKKA: and so it won't just keep recursing forever, unless the list happens to be infinitely long
22:31:05 <Berengal> lpsmith: map isn't tail-recursive, yet runs in constant stack.
22:31:09 <Gracenotes> DOKKA: it evaluates something like this: length "hello"  ... 1 + length "ello" ... 2 + length "llo" ... 3 + length "lo" ... 4 + length "o"  ... 5 + length "" ... 5 + 0 = 5
22:31:13 <MyCatVerbs> > sum . map (const 1) $ [1..1000]
22:31:15 <lambdabot>   1000
22:31:41 <Cale> map is better than tail-recursive, it always produces a constructor application.
22:31:43 <Gracenotes> (Haskell being lazy changes it a bit, but that's what's going on)
22:31:46 <DOKKA> Gracenotes: that makes sense
22:31:49 <lpsmith> Berengal:  because it's constantly allocating thunks on the heap instead :-P
22:31:50 <Cale> So in some sense it's constant time ;)
22:31:57 <MyCatVerbs> > foldl (\a _ -> a+1) 0 [1..1000]
22:32:00 <lambdabot>   1000
22:32:07 <Baughn> lpsmith: The stack is used to evaluate thunks. Sometimes you need to recursively evaluate more thunks before you can finish the first one; that is when you can get stack overflows.
22:32:28 <Cale> (of course, it's really constant time per list element)
22:32:32 <MyCatVerbs> Cale: it tail-calls a constructor. ^_^
22:32:52 <DOKKA> like a fork bomb
22:33:13 <Berengal> lpsmith: And that's sort of the point...
22:33:19 <Gracenotes> DOKKA: except, on every recursive call, you're waiting for the results of the next call
22:33:27 <Cale> Gracenotes: That's not quite right, because you made use of the associativity of (+), and the compiler doesn't.
22:33:28 <DOKKA> righ
22:33:55 <lpsmith> Ahh, depth of thunks, that makes sense.  Well,  you definitely don't want to use the "natural recursive" definition of length then,  because it will blow the stack.
22:34:09 <MyCatVerbs> @pl \a _ -> succ a
22:34:10 <lambdabot> const . succ
22:34:12 <DOKKA> so the way that I wrote this program, would it work at all? -just curious
22:34:13 <Gracenotes> Cale: yeah. Easier than writing 1 + 1 + 1 + ...
22:34:23 <Baughn> lpsmith: Yep
22:35:01 <Cale> It's really like  length "hello" -> 1 + length "ello" -> 1 + (1 + length "llo") -> 1 + (1 + (1 + length "lo")) -> 1 + (1 + (1 + (1 + length "o"))) -> 1 + (1 + (1 + (1 + (1 + length "")))) -> 1 + (1 + (1 + (1 + (1 + 0))))
22:35:43 <Cale> -> 1 + (1 + (1 + (1 + 1))) -> 1 + (1 + (1 + 2)) -> 1 + (1 + 3) -> 1 + 4 -> 5
22:36:18 <Berengal> > let len xs = execState (forM xs (const $ do get >>= put . (+1))) 0 in len [1..10]
22:36:20 <lambdabot>   10
22:36:20 <Cale> DOKKA: You can use an accumulating parameter and a helper function if it suits you
22:36:27 <Cale> DOKKA: like:
22:36:36 <Cale> length xs = length' 0 xs
22:36:42 <Cale> length' n [] = n
22:36:52 <Cale> length' n (x:xs) = length' (n+1) xs
22:37:52 <Baughn> lpsmith: The return value of map, meanwhile, doesn't have that problem because the first thunk (the first list value) can be evaluated without knowing the value of the others
22:38:08 <Baughn> lpsmith: ..technically, you can figure that out by looking for constructors in the definition
22:38:15 <DOKKA> ok
22:40:00 <QtPlaty[HireMe]> Baughn: Can't you find the nth value of map without evaluating the other n?
22:40:29 <DOKKA> Well, thanks yall! I guess I'm gonna do some more reading
22:40:32 <lpsmith> QtPlaty[HireMe]:  Yes
22:40:32 <Cale> DOKKA: Normally, we'd also stick the length' definition inside of a 'where'
22:40:50 <Berengal> QtPlaty[HireMe]: Well, you need to evaluate the others to whnf...
22:40:57 <DOKKA> what is the ' for?
22:41:08 <QtPlaty[HireMe]> expn whnf?
22:41:09 <lpsmith> QtPlaty[HireMe]:  but at the cost of allocating a bunch of thunks,  which isn't a win for small computations.
22:41:26 <Cale> DOKKA: just a convention for modifying a name of something to name something related to it
22:41:47 <DOKKA> ah
22:41:56 <Cale> DOKKA: In this case, length and length' are separate functions, but length' only serves to help us write length
22:42:34 <DOKKA> ok, I guess I haven't gotten that far in the book
22:42:42 <Cale> Sometimes it indicates a version of a function which is stricter
22:42:53 <DOKKA> oh
22:42:59 <Cale> Like in the case of foldl and foldl'
22:43:03 <QtPlaty[HireMe]> DOKKA: Alot of learning is unlearning.
22:43:06 <mauke> > let x = 1; x' = succ x; x'' = succ x' in (x, x', x'')
22:43:07 <lambdabot>   (1,2,3)
22:43:11 <Cale> but in this case, it just indicates a variation
22:43:20 <monochrom> > (map id [undefined, undefined, 'c']) !! 2
22:43:21 <lambdabot>   'c'
22:43:30 <Baughn> QtPlaty[HireMe]: No
22:43:40 <monochrom> My example is for your discussion.
22:43:44 <Cale> DOKKA: (it's just a naming convention, an apostrophe is a valid character in variable names)
22:43:48 <Baughn> QtPlaty[HireMe]: By "values", here, I meant the spine of the list
22:43:49 <DOKKA> ok, I think i get it
22:44:13 <DOKKA> and yeah I am having to do a lot of unlearning
22:44:22 <Cale> Normally if you read it aloud, you say the ' as "prime"
22:44:26 <QtPlaty[HireMe]> Baughn: So you mean the pairs of thunks.
22:44:33 <Cale> It's a convention stolen from mathematics and physics.
22:44:35 <lpsmith> Yep,  apostrophes customarily come at the end,  but you can put them in the middle
22:44:36 <lpsmith> like
22:44:46 <Baughn> QtPlaty[HireMe]: The list spine.
22:44:49 <lpsmith> cale's_function  is a legitimate identifier
22:45:13 <DOKKA> i see
22:45:18 <QtPlaty[HireMe]> Baughn: Can you explain what you mean by the list spine?
22:45:19 <monochrom> Oleg always writes like zip'iterator
22:45:22 <mauke> > let don't _ = () in don't (error "!")
22:45:24 <lambdabot>   ()
22:45:54 <Baughn> QtPlaty[HireMe]: If you take a list, and change its type to [()], the spine is what is left of its structure
22:46:12 <lpsmith> monochrom:  hmm,  I almost like that better than camelCase  or ugly_underscores.
22:46:19 <Berengal> Basically, the spine of a list is it's cons cells...
22:46:24 <DOKKA> it is a very interesting language
22:46:27 <monochrom> Yes, it's refreshing.
22:46:27 <lpsmith> Honestly I wish hyphenated identifiers were legal.
22:46:43 <mauke> lpsmith: I agree
22:46:47 <DOKKA> and it causes you to think about how to write it before you write anything
22:47:03 <QtPlaty[HireMe]> lpsmith: Though it makes doing things like 2-1 interesting.
22:47:18 <Cale> DOKKA: Well, especially so when you're not used to writing things in a functional style
22:47:22 <mauke> DOKKA: I think that depends on how familiar you are with it
22:47:46 <DOKKA> true, this is my first week
22:47:50 <Cale> Eventually, it becomes a chore to figure out how to express your program imperatively, and the functional way is the first thing you think of.
22:47:59 <Cale> (at least, that's the case with me)
22:48:02 <Berengal> Haskell really starts to become fun when you can juggle folds, fmaps and flips like it was second nature
22:48:15 <DOKKA> that's what I'm looking for
22:48:18 <Berengal> Okay, that was badly worded...
22:48:30 <mauke> I cank think in Haskell and Perl and I have no problems with either
22:48:41 <mauke> but OCaml sits at exactly the wrong spot :-)
22:48:49 <Baughn> Haskell really starts to become fun when the arrow syntax makes sense to you and seems useful. ;)
22:48:58 <DOKKA> I want to be able to write shorter code that does more
22:49:02 <Berengal> I can still program Java just fine, except I now have a burning hatred for it's type system...
22:49:22 <mauke> Berengal: see, that's something Haskell and Perl programmers have in common :-)
22:49:54 <Berengal> mauke: Not surprised
22:49:58 <lpsmith> Berengal:  I have a burning hatred of pretty much all OO type systems.   At least the ones that aren't dynamic.
22:49:58 <mikm> I think anybody who has programmed in a different languages feels that way
22:50:02 <DOKKA> I don't really care for java, mainly because of all the objects you have to create to get a basic program running
22:50:58 <DOKKA> *gui program running
22:51:06 <Gracenotes> but see also Python's type system, where types are essentially tags with little other meaning
22:51:14 <Gracenotes> well, at least it stays out of your way
22:51:47 <QtPlaty[HireMe]> @pl l x = x
22:51:47 <lambdabot> l = id
22:51:59 <tsLight> data Rational = Integer : / Integer deriving Eq      -> what does the : / stand for?
22:52:21 <QtPlaty[HireMe]> @pl l x = case x of {[]->0;(_:xs) -> 1 + l xs}
22:52:21 <lambdabot> (line 1, column 17):
22:52:22 <lambdabot> unexpected "{"
22:52:22 <lambdabot> expecting variable, "(", operator or end of input
22:52:22 <mauke> tsLight: it's actually :/
22:52:31 <lpsmith> Gracenotes:  yep.  With a dynamic type system like Python's,  I can pretend I'm programming in HM (most of the time,  unless I see good reason not to) and the illusion works.
22:52:44 <mauke> tsLight: the ':' is an uppercase symbol. it's used to start infix constructor
22:52:45 <Gracenotes> Rational is :% incidentally
22:52:53 <Berengal> Gracenotes: I sort of like python's type system... Python generally discourages typed programming, letting the objects themselves take care of their types, which is how dynamic typing works best
22:52:58 <Gracenotes> maybe you're seeing it as :o/o
22:53:06 <Gracenotes> or something :x
22:53:06 <mauke> tsLight: it's equivalent to data Rational = R Integer Integer deriving Eq
22:53:15 <tsLight> ah
22:53:24 <mauke> Gracenotes: Rational is actually a 'type', not a 'data' :-)
22:53:34 <Gracenotes> yeah. the constructor, though
22:53:42 <copumpkin> Ratio
22:53:45 <Gracenotes> which I assumed we are all talkin' bout! come on nao.
22:53:47 <Gracenotes> :)
22:53:51 <tsLight> so 4 :/ 5 would be equivalent to 4 `R` 5 ?
22:53:53 <mauke> I don't think this is the Data.Ratio version
22:53:57 <mauke> tsLight: exactly
22:54:03 <QtPlaty[HireMe]> lpsmith: With type inference like in Haskell I can pretend I'm programing with a dynamtically typed language.
22:54:05 <Gracenotes> oh, I see
22:54:12 <tsLight> and the "/" can be anything I want?
22:54:20 <mauke> tsLight: well, any operator
22:54:25 <tsLight> ":Joe" wouldnt work?
22:54:26 <tsLight> :P
22:54:30 <mauke> :+??+ is valid, for example
22:54:45 <Gracenotes> anything that's a valid infix symbol is a valid infix constructor, with a : tacked on
22:54:53 <Gracenotes> as far as I know :o
22:55:24 <Gracenotes> and of course the most famous infix constructor of them all, :
22:55:32 <Berengal> data Emoticon = :) | :( | :$ | :/
22:56:07 <tsLight> lol that works?
22:56:11 <mauke> no
22:56:14 <tsLight> haha
22:56:23 <Berengal> No parenthesis unfortunately
22:56:31 <mauke> first of all, you're missing operands for the infix constructors
22:56:55 <Berengal> That too
22:57:43 <tsLight> and if I "string" them
22:57:51 <tsLight> data Emoticon = ":)" | ":(" | ":$" | ":/"
22:57:52 <Gracenotes> let (:|) = ":|" in (:|)
22:57:52 <Berengal> kweztshun = CanHas cheezbagah :) Lol
22:57:56 <Gracenotes> > let (:|) = ":|" in (:|)
22:57:57 <lambdabot>   Not in scope: data constructor `:|'Not in scope: data constructor `:|'
22:57:57 <tsLight> that would be an enumerated type?
22:58:12 <mauke> you can't string symbols
22:58:14 <Gracenotes> oh... I did not know that ":" was an exclusive data constructor
22:58:34 <tsLight> so how could I write that an emoticon is any of those strings
22:58:40 <tsLight> list them?
22:58:41 <Berengal> Gracenotes: It's like capital letters in regular identifiers
22:58:54 <tsLight> not declaring an algebraic type :P
22:58:54 <Gracenotes> perverted. but cool
22:58:55 <Cale> tsLight: Haskell doesn't have subtyping.
22:59:13 <tsLight> ah
22:59:33 <Cale> tsLight: So you could say   data Emoticon = Smile | Frown | DollarMouth | Disappointed
22:59:41 <Cale> But you can't make them actual strings
22:59:47 <tsLight> but I can define show for them :)
22:59:54 <Gracenotes> > text . unwords $ sequence [":;", "-", ")($/"]
22:59:55 <lambdabot>   :-) :-( :-$ :-/ ;-) ;-( ;-$ ;-/
23:00:08 <copumpkin> what about P ?
23:00:18 <copumpkin> no smiley is complete without the P
23:00:23 <Gracenotes> your command is my sequence!
23:00:28 <copumpkin> lol
23:00:38 <mauke> ·_·
23:00:55 <monochrom> data Emoticon = Int :> Bool | Bool :< Int
23:00:59 <Gracenotes> your cosequence is my cocommand
23:01:00 <Asztal> > let (・∀・) = (+) in x ・∀・y -- doesn't work :(
23:01:01 <lambdabot>   <no location info>: lexical error at character '\12539'
23:01:06 <copumpkin> ¬_¬
23:01:28 <mauke> your cosequence is my mmand
23:01:35 <Berengal> ·_˙
23:01:35 <copumpkin> lol
23:01:52 * copumpkin wants to use ContraFunctors
23:02:03 <Gracenotes> your comonad is my functor
23:02:09 <Gracenotes> allegedly
23:02:20 <mauke> ContraFungi
23:02:29 <Berengal> So what's a ContraFunctor?
23:02:54 <Berengal> funmap :: (f a -> f b) -> a -> b?
23:03:07 <monochrom> (a->b) -> (f b -> f a)
23:03:08 <copumpkin> (a -> b) -> f b -> f a
23:03:10 <Gracenotes> looks dangerous :o
23:03:17 <copumpkin> :P
23:03:42 <Gracenotes> and .. unusable
23:03:46 <Berengal> Isn't that just regular functors though?
23:03:49 <copumpkin> no
23:03:54 <copumpkin> :t fmap
23:03:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:04:03 <Gracenotes> what are some instances?
23:04:04 <copumpkin> notice that the b and a got reversed on the way out
23:04:15 <Berengal> Oh, right, didn't notice the flipped arguments
23:04:29 <Berengal> So how would that work anyway?
23:04:32 <copumpkin> the only instance I've been able to think of is a fold, but I'm sure there are others
23:04:51 <copumpkin> Berengal: it's got to do with you having (c ->) as the ContraFunctor instance
23:04:56 <copumpkin> I mean
23:05:00 <copumpkin> (-> c)
23:05:06 <Gracenotes> oh, yes, that came to mind
23:05:22 <Gracenotes> newtyped though >_>
23:05:25 <copumpkin> it has to be
23:05:32 <Gracenotes> no kind-fu
23:06:51 <copumpkin> I'm not sure what the right way to define an instance of ContraFunctor is though
23:07:42 <sw2wolf> I am haskell newbie, I want to know to write [[1,2,3,4,5],[6,7,8,9,10]] to file and read it back later
23:08:22 <Gracenotes> @type let cfmap :: (a -> b) -> f b -> f a; u = undefined in cfmap . cfmap
23:08:24 <lambdabot> Not in scope: `cfmap'
23:08:24 <lambdabot> Not in scope: `cfmap'
23:08:24 <lambdabot> Not in scope: `cfmap'
23:08:31 <Gracenotes> @type let cfmap :: (a -> b) -> f b -> f a; cfmap = undefined in cfmap . cfmap
23:08:32 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (a -> b) -> f (f1 a) -> f (f1 b)
23:08:37 <Gracenotes> ah.
23:08:51 <copumpkin> contramap
23:09:01 <copumpkin> is what edwardk called it
23:09:21 <Gracenotes> sw2wolf: well, a basic way to do it is to just "show" it and "read" it back again. read . show is supposed to be an identity.
23:09:57 <Gracenotes> for storing data in files, Data.Binary is essentially the Haskell pickling/serialization module
23:10:08 <Gracenotes> it's just a straightforward encoding to binary
23:10:42 <Gracenotes> @hackage binary
23:10:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
23:11:22 <sw2wolf> thank you
23:11:28 <Gracenotes> > read "[[1,2,3,4,5],[6,7,8,9,10]]" :: [[Int]]
23:11:29 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10]]
23:11:39 <copumpkin> newtype ContraFold a b = ContraFold { runContraFold :: Fold b a }
23:11:40 <Gracenotes> ^ less efficient, but definitely less work
23:11:51 * copumpkin feels l33t
23:12:01 <copumpkin> even though the newtype is too much of a pain to deal with
23:12:12 <copumpkin> so I'm just going to leave the instance there and not do anything with it
23:13:39 <Gracenotes> afaik Data.Binary isn't amazingly speedy either, but that's strings for you
23:14:16 <mmorrow> if anyone wants to try this out, it's in a working-but-i-still-want-to-tweak-it-plus-clean-the-code-up state http://moonpatio.com/repos/vacuum-gl/
23:14:17 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
23:14:29 <monochrom> The easiest examples of cofunctors come from comonads.
23:15:34 <mmorrow> lots of hair-ripping-out happened before i finally learned that OpenGL uses thread-local state, so you need to forkOS and make sure you stay in that os thread...
23:15:43 <copumpkin> ew
23:16:06 <mmorrow> i was segfaulting like crazy with forkIO + -threaded ;)
23:16:30 <mmorrow> (since the rts migrates threads between os threads at will)
23:16:37 <copumpkin> yeah
23:16:44 <copumpkin> mmorrow: I got the epic foldage working nicely
23:16:56 <mmorrow> copumpkin: ooh yay, link?
23:17:16 <mmorrow> ah, you mean with uvector stuff?
23:17:22 <copumpkin> well, in general
23:17:28 <mmorrow> cool
23:17:48 <copumpkin> http://github.com/pumpkin/folds/blob/6392dccfa870473364bfe5d9d5b1c2240b347f02/Folds.hs
23:17:54 <copumpkin> I abandoned the GADT
23:17:58 <mmorrow> heh
23:18:02 <copumpkin> I had it working with GADT, but it wouldn't fuse
23:18:22 <copumpkin> the flattening of the GADT was getting in the way, as far I could see
23:18:56 <mmorrow> yeah, i realized later that the GADT would make it impossible to fuse, since the compiler doesn't have access to the "final product", since it gets built at runtime
23:19:02 <copumpkin> yeah
23:19:09 <copumpkin> it'd be nice if it did
23:19:12 <copumpkin> they're constants
23:19:25 <copumpkin> it can work with other constants at compile time can't it?
23:19:26 <mmorrow> yeah, TH (or equiv) would be needed
23:19:36 <copumpkin> yeah, I've been thinking of trying this all in TH next
23:19:44 <copumpkin> because I still have a major problem with it
23:20:08 <copumpkin> namely that I can't share across parallel folds
23:20:20 <mmorrow> copumpkin: there's this one paper on using TH to optimize edsl's
23:20:26 <copumpkin> ooh
23:20:28 <mmorrow> you might find it relevant/interesting
23:20:30 <copumpkin> that could be helpful
23:20:45 <copumpkin> mmorrow: take a look at the ugly linregF beast btw :P
23:20:59 <mmorrow> http://haskell.org/th/papers/th-pan.ps
23:21:10 <mmorrow> heh
23:21:12 <copumpkin> that's the main reason I defined a Num instance for the folds, because all the infix-applicative stuff was getting ridiculous
23:21:19 <copumpkin> thanks :)
23:22:19 <copumpkin> but in the linregF, although I do it in one pass over the list
23:22:26 <copumpkin> a lot of stuff is recomputed unnecessarily
23:22:40 <mmorrow> copumpkin: i'm not sure the impact it would have, but maybe ! the intermediate thunks built up in the where (e.g. "beta = (n * sXY - sX * sY) / (n * sXX - sX * sX)")
23:22:57 <copumpkin> well, this is only building up the function itself
23:23:11 <mmorrow> hmm
23:23:19 <copumpkin> so the output of that is just a Fold
23:23:24 <copumpkin> with a monstrously complicated folding function
23:23:43 <mmorrow> but wouldn't those thunks start to accumulate?
23:23:48 <mmorrow> (as you fold)
23:23:58 <copumpkin> hmm
23:24:10 <copumpkin> I didn't think so, all the folds are strict by default
23:24:21 <copumpkin> the way I do them, at least
23:24:28 <mmorrow> , foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..10000000]
23:24:32 <lunabot>  luna: out of memory (requested 1048576 bytes)
23:24:38 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..10000000]
23:24:44 <lunabot>  Killed.
23:24:45 <copumpkin> oh, but I'm using strict pairs
23:24:46 <mmorrow> bah
23:24:56 <copumpkin> for doing all the parallel stuff
23:25:07 <mmorrow> , foldl' (\(!a,!b) c -> (a+c+c+c+c+c,b+c+c+c+c+c)) (0,0) [0..1000000]
23:25:10 <copumpkin> lol
23:25:13 <lunabot>  Killed.
23:25:17 <mmorrow> gah
23:25:20 <mmorrow> , foldl' (\(!a,!b) c -> (a+c+c+c+c+c,b+c+c+c+c+c)) (0,0) [0..100000]
23:25:22 <lunabot>  (25000250000,25000250000)
23:25:24 <mmorrow> , foldl' (\(!a,!b) c -> (a+c+c+c+c+c,b+c+c+c+c+c)) (0,0) [0..1000000]
23:25:30 <lunabot>  Killed.
23:25:58 <mmorrow> , foldl' (\(!a,!b) c -> let !d = c+c; !e = d + d in (a+e,b+e)) (0,0) [0..1000000]
23:26:01 <lunabot>  (2000002000000,2000002000000)
23:26:09 <mmorrow> , foldl' (\(!a,!b) c -> let d = c+c; e = d + d in (a+e,b+e)) (0,0) [0..1000000]
23:26:12 <lunabot>  (2000002000000,2000002000000)
23:26:18 <mmorrow> hmm, inconclusive
23:26:23 <copumpkin> but I'm not using regular pairs
23:26:37 <mmorrow> yeah, but that's only take care of the top level
23:26:56 <mmorrow> a regular pair with bangs is == to a strict pair (i believe)
23:27:02 <copumpkin> oh, I see what you mean
23:27:09 <mmorrow> (modulo ghc unpacking)
23:27:11 <copumpkin> so if someone was building a listi n the pairs
23:27:18 <copumpkin> you'd only force the head?
23:27:23 <mmorrow> yes
23:27:29 <copumpkin> hmm
23:27:57 <copumpkin> I still managed to convince myself I didn't need any strictness annotations here
23:27:59 <copumpkin> but maybe I do
23:28:19 <mmorrow> yeah, i'm not sure if it would or wouldn't have an impact
23:28:32 <mmorrow> i guess testing is the only way to know
23:28:39 <copumpkin> I've tested it on big data
23:28:43 <mmorrow> nice
23:28:44 <copumpkin> but I'm not sure it's big enough
23:28:50 <copumpkin> I was trying to compare to hstats
23:28:59 <copumpkin> but hstats just overflows its stack
23:29:03 <copumpkin> :/
23:29:14 <mmorrow> yeah, hstats needs to s/foldr/foldl'/ bigtime
23:29:31 <mmorrow> (if you do that, it runs ok)
23:29:36 <copumpkin> ah
23:29:45 <copumpkin> I wonder if my linreg is any faster than hstats with foldl'
23:29:52 <copumpkin> I translated it directly
23:30:02 <mmorrow> oh nice, that'd be interesting to see
23:30:05 <copumpkin> from the hstats one, which does several passes over the lists
23:30:53 <copumpkin> I'll convert its folds and try
23:31:19 <copumpkin> does cabal-install compile with -O2 by default?
23:31:31 <copumpkin> I think even the sum calls are failing because it's defined in terms of foldl
23:32:09 <mmorrow> ok, i got an example
23:32:12 <mmorrow> , foldl' (\(!a,!b) c -> let d = c + c + c + c; e = d + d + d + d; f = e + e + e + e + e in (a+f,b+f)) (0,0) [0..1000000]
23:32:18 <lunabot>  Killed.
23:32:20 <mmorrow> , foldl' (\(!a,!b) c -> let !d = c + c + c + c; !e = d + d + d + d; !f = e + e + e + e + e in (a+f,b+f)) (0,0) [0..1000000]
23:32:26 <lunabot>  Killed.
23:32:28 <mmorrow> grrr
23:32:29 <mmorrow> , foldl' (\(!a,!b) c -> let !d = c + c + c + c; !e = d + d + d + d; !f = e + e + e + e + e in (a+f,b+f)) (0,0) [0..1000000]
23:32:35 <lunabot>  Killed.
23:32:43 <mmorrow> it worked in /msg, i swear ;)
23:33:04 <copumpkin> riiiight ;)
23:33:05 <mmorrow> , foldl' (\(!a,!b) c -> let !d = c + c + c + c; !e = d + d + d + d; !f = e + e + e + e + e in (a+f,b+f)) (0,0) [0..1000000]
23:33:11 <lunabot>  (40000040000000,40000040000000)
23:33:14 <mmorrow> woohoo
23:35:38 <copumpkin> :)
23:37:23 <mmorrow> , foldl' (\(!a,!b) c -> let !d = c + c; !dd = d + d; !e = dd + dd; !f = e + e; !g = f + f; !h = g + e; !i = h + h  in (a+i,b+i)) (0,0) [0..1000000]
23:37:27 <lunabot>  (40000040000000,40000040000000)
23:37:28 <mmorrow> hehe
23:38:04 <mmorrow> (this is bytecode too, though... so no optims)
23:39:03 <Nafai> nominolo_: So did you get much done with Scion at the Hackathon?
23:39:10 <mmorrow> copumpkin: i like that Fold code, i'm gonna play with it
23:39:23 <copumpkin> mmorrow: :) couple of warnings
23:39:32 <copumpkin> it relies on an unreleased version of uvector for no real reason :P
23:39:45 <copumpkin> and I think the latest on I pushed doesn't compile due to a failed liftA2 (==)
23:39:53 <mmorrow> noted x2
23:41:34 <YMan> Is this where Eddy Haskel chats ?
23:42:01 <voker57__> how to insert value at certain position in list?
23:42:44 <mmorrow> voker57__: if you're doing that a lot, then lists aren't what you want.... but that being said, you can use splitAt
23:43:14 <voker57__> ok
23:44:00 <sjanssen> YMan: no
23:44:04 <mmorrow> , insertAt n x xs = let (ys,zs) = splitAt n xs in ys ++ [x] ++ zs in insertAt 9 42 [0..20]
23:44:05 <lunabot>  luna: parse error on input `='
23:44:10 <mmorrow> , let insertAt n x xs = let (ys,zs) = splitAt n xs in ys ++ [x] ++ zs in insertAt 9 42 [0..20]
23:44:11 <lunabot>  [0,1,2,3,4,5,6,7,8,42,9,10,11,12,13,14,15,16,17,18,19,20]
23:44:46 <Gracenotes> a foldr might work there, too
23:45:08 <mmorrow> voker57__: check out Data.Sequence maybe
23:45:29 <hotaru2k3> if i have a list like [1,2,3,4,5], is there an easy way to split it into ([1,2,3], [3,4,5])?
23:45:35 <mmorrow> voker57__: (or Data.IntMap)
23:45:55 <mmorrow> hotaru2k3: use splitAt and a case
23:46:01 <voker57__> mmorrow: that was just a one-time... and i've already found out that i don't really need it.
23:46:13 <mmorrow> voker57__: cool
23:46:19 <voker57__> but thanks for pointers anyway
23:46:26 <mmorrow> voker57__: (if you ever do though, Sequence or IntMap is the way to go)
23:46:33 <mmorrow> voker57__: np
23:47:35 <copumpkin> mmorrow: onoes, my single fold linreg is slower than the foldl'-multipass linreg in hstats
23:47:42 <copumpkin> being beaten in performance by hstats is rough
23:47:47 * copumpkin cries to himself
23:47:48 <mmorrow> , let split' n x xs = case splitAt n xs of (ys,z:zs) -> ys ++ z:z:zs; _ -> xs in split' 4 [0..9]
23:47:50 <lunabot>  luna: No instance for (GHC.Show.Show ([a] -> [a]))
23:47:57 <mmorrow> , let split' n xs = case splitAt n xs of (ys,z:zs) -> ys ++ z:z:zs; _ -> xs in split' 4 [0..9]
23:47:59 <lunabot>  [0,1,2,3,4,4,5,6,7,8,9]
23:48:02 <mmorrow> oops
23:48:11 <sjanssen> copumpkin: you just have to start doing it wrong
23:48:17 <hotaru2k3> mmorrow: i mean where it'd split [1,2,3,4,5] into ([1,2,3], [3,4,5]), and [2,3,4,5,6,7,8] into ([2,3], [3,4,5,6,7,8])...
23:48:20 <sjanssen> copumpkin: in fact, do it cowrong
23:48:24 <copumpkin> lol
23:48:26 <mmorrow> , let split' n x xs = case splitAt n xs of (ys,z:zs) -> (ys++[z],z:zs); _ -> (ys,[]) in split' 4 [0..9]
23:48:27 <lunabot>  luna: Not in scope: `ys'
23:48:30 <mmorrow> gah
23:49:06 <sjanssen> I actually meant to type "stop doing it wrong", but the other way is funnier
23:49:08 <mmorrow> hotaru2k3: so where you want to split is determined by the value to split on?
23:49:18 <hotaru2k3> yeah
23:50:12 <mmorrow> , let split' p xs = case break p xs of (ys,z:zs) -> (ys++[z],z:zs); _ -> (xs,[]) in split' (==4) [0..9]
23:50:13 <lunabot>  ([0,1,2,3,4],[4,5,6,7,8,9])
23:50:16 <mmorrow> span/break
23:50:18 <copumpkin> mmorrow: how easy is it for me to do transformations on the AST in a qq using haskell-source(-exts) ?
23:50:18 <mmorrow> @src span
23:50:19 <lambdabot> Source not found. Where did you learn to type?
23:50:23 <mmorrow> @src break
23:50:23 <lambdabot> break p =  span (not . p)
23:50:42 <copumpkin> [$fuse| lots of haskell code here |] would be fun
23:50:43 <mmorrow> copumpkin: hmm, harder than doing them on the TH ast
23:51:00 <mmorrow> copumpkin: yeah, that would. do you need stuff that TH doesn't have?
23:51:08 <copumpkin> don't think so?
23:51:11 <mmorrow> because the haskell-src-exts AST is way more complex
23:51:12 <copumpkin> I'm still TH-clueless
23:51:25 <copumpkin> how would I do it in regular TH?
23:51:47 <copumpkin> I mean, what would the syntax look like?
23:51:55 <mmorrow> copumpkin: so what's something (the most basic/simple example you can think of) that you'd want to do?
23:52:47 <copumpkin> mmorrow: take someone who wrote mean xs = sum xs / genericLength xs, build the folds like I did earlier, and output a "fused" fold
23:52:51 <hotaru2k3> > let n = 3 in (takeWhile (<= n) &&& dropWhile (< n)) [1,2,3,4,5]
23:52:52 <lambdabot>   ([1,2,3],[3,4,5])
23:53:18 <copumpkin> mmorrow: obviously with knowledge that sum and genericLength can be expressed as folds
23:53:29 <mmorrow> copumpkin: ok, cool. so what would be the result of fusing, in regular haskell syntax?
23:54:10 <copumpkin> uncurry (/) . foldl ((+) *** const . (+1)) (0, 0)
23:54:12 <copumpkin> or something like that
23:54:24 <copumpkin> minus the arrow dependency
23:54:36 <copumpkin> basically what the folds thing is already doing
23:54:44 <copumpkin> but without the applicative
23:55:31 <copumpkin> the benefit of the TH approach being that people can write their folds freeform, and that I can eventually reason about common subexpressions in the fold function
23:55:40 <copumpkin> and (I think safely) factor them out
23:56:16 <copumpkin> unlike the more general CSE issues that GHC avoids
23:57:26 <mmorrow> ok, thinking..
23:57:57 <copumpkin> so I'd basically be doing a restricted form of the simplifier in GHC, with more flexible rewrite rules
23:58:10 <copumpkin> and a lambdabot-like list of stdlib folds
23:59:58 <copumpkin> but maybe I should wait for BSP to finish his plugins
