19:00:59 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
19:00:59 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
19:34:07 <gaagaaga> Hi
19:35:04 <saml> hi gaagaaga
19:35:09 <saml> can i halp you?
19:35:31 <gaagaaga> I didn't use haskell for a long time....When I return to ghc 6.10.1, I found that some library such as OpenGL is removed from standard library
19:35:38 <gaagaaga> thanks
19:35:56 <saml> yes it was removed
19:36:06 <saml> you have to install it through hackage
19:36:46 <saml> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/OpenGL
19:39:20 <kbateman> bot?
19:40:00 <saml> > 1
19:40:01 <lambdabot>   1
19:40:09 <kbateman> thanks
19:40:16 <pumpkin> @botsnack
19:40:16 <lambdabot> :)
19:40:17 <lunabot>  :)
19:40:17 <kbateman> couldn't remember lambabot's name
20:05:33 <TomMD> With vacuum-cairo I get wonderful errors like "internal error: MVAR object entered!" are these errors being worked or should I just take them as a limitation of vacuum?
20:06:40 <TomMD> I don't so much care about the MVar, but its part of the rest of the structure I wish to visualize.
20:07:06 <ddarius> TomMD: I think it's a kinda bug in the current version of GHC that leads to that behavior.
20:07:20 <ddarius> TomMD: Talk to mmorrow for the details when he is around.
20:08:08 <TomMD> thanks
20:15:26 * ManateeLazyCat pasted "my module" at http://paste2.org/get/184917
20:15:27 <ManateeLazyCat> I have above module, i don't know how to write function that modified counter with modifyIORef, any help? Thanks
20:16:45 <Lemmih> ManateeLazyCat: Your code seems fine.
20:17:18 <ManateeLazyCat> Lemmih: But i don't know how to write function `updateWindowsCounter`
20:17:54 <Lemmih> updateWindowsCounter win = win{counter = counter win + 1} ?
20:23:52 <ManateeLazyCat> Lemmih: Looks fine, thanks! But i how to make function `windowsIDNew` return new value of `counter`?
20:24:13 <Gracenotes> hm, this is why I like functional programming a bit better: having to copy-paste a 13-line C++ function with the removal of just one if statement. :\
20:24:43 <Lemmih> ManateeLazyCat: readIORef. If you want thread-safety, use atomicModifyIORef or (better yet) MVars.
20:24:58 <bd_> Gracenotes: Even in C++ that's a bit ugly :/ Perhaps you should just pass in a flag, and use that at that if statement? <.<
20:25:05 <Axman6> ManateeLazyCat: imo, if you're using unsafePerformIO and you're not doing FFI stuff, you're doing something wrong
20:25:38 <ManateeLazyCat> Axman6: But now it can fix my problem, i will carefully.
20:25:51 <ManateeLazyCat> Axman6: is
20:25:53 <Gracenotes> bd_: the issue is that the if statement depends on values in one case, but not in the other case. In Haskell I'd use Maybe (Time, Time), but in C++ I'm using two Time parameters
20:26:02 <ManateeLazyCat> safe if trust programmer.
20:26:10 <pumpkin> Axman6: not always!
20:26:13 <ray> if you're using unsafePerformIO and you don't have a good expectation of referential transparency, you're doing it wrong
20:26:20 <pumpkin> there we go
20:26:25 <Axman6> aye
20:26:28 <ray> see Math.OEIS
20:26:29 <sebaseba> amen.
20:26:31 <Gracenotes> bd_: well... I could make a Pair object and pass a pointer to it. doesn't feel natural, though :)
20:26:31 <ray> man i love that library
20:27:49 <Cale> Heh, Math.OEIS is one of those offenders which I somehow can manage to forgive. Probably because the rate of change of the database is small enough, and it's mostly for amusement anyway.
20:27:50 <Gracenotes> bd_: but yeah, FP ftw.
20:28:45 <ManateeLazyCat> I think unsafePerformIO will go wrong when programmer abuse global value. But i will carefully.
20:30:00 <Cale> I would basically never use unsafePerformIO to create a global variable. I just find it's much nicer in general to use the parameters of functions to keep track of what parts of the program use what data.
20:30:27 <pumpkin> ManateeLazyCat: you have referential transparency in the example I originally gave you, so it isn't a problem, but it's ugly
20:31:11 <pumpkin> actually, maybe you don't
20:31:12 <pumpkin> hmm
20:31:33 <ManateeLazyCat> pumpkin: Someone give me suggestions that remove unsafePerformIO, but i need pass IORef to every functions, and it's troublesome.
20:32:30 <Zao> State transformer?
20:32:39 <newsham> you could hide the passing of global ioref with a reader or state monad
20:32:57 <Gracenotes> okay, "std::pair<Time, Time> *range = NULL". Feels hacky, but what can one do :X
20:33:08 <pumpkin> ManateeLazyCat: you could also use implicit parameters, but that's also kinda ugly
20:33:21 <pumpkin> you'd still be forcing all your functions into IO
20:33:22 <mib_bmia1bmx> Gracenotes: you might want to look at boost::optional
20:33:27 * Gracenotes consummates his love with Maybe
20:33:38 <pumpkin> which is why I think you should decide what functions need absolutely global state, and make them and only them live in IO
20:33:39 <Zao> Boost.Optional is Maybe in C++ :)
20:33:40 <pumpkin> and pass the rest around
20:33:51 <Gracenotes> mib_bmia1bmx: neat. can't use boost, though :\ school assignment, must compile
20:34:01 <Gracenotes> on any standard g++
20:34:01 <Zao> Aaw.
20:34:12 <kbateman> ManateeLazyCat: http://paste2.org/p/184921
20:34:38 <Gracenotes> *makes it a const reference for great justice*
20:34:41 <pumpkin> kbateman: why not modifyIORef?
20:34:54 <pumpkin> that's what I originally gave him
20:34:56 <kbateman> We still need to read the old value
20:35:03 <pumpkin> hmm
20:37:23 <Cale> ManateeLazyCat: The passing of IORefs is useful information for people trying to read it (and yourself) about how your program is structured.
20:37:46 <Cale> ManateeLazyCat: If you have a lot of them to pass around, you could consider making a record of all of them, and then it's only one parameter.
20:37:59 <ManateeLazyCat> Cale: Yep, but then, it's not reason to make global value exist.
20:38:12 <Cale> hm?
20:38:12 <pumpkin> that's the point :P
20:38:22 <Cale> Globals are bad.
20:38:24 <pumpkin> global state is considered bad in most languages
20:38:26 <pumpkin> not just haskell
20:38:32 <pumpkin> "bad"
20:38:36 <Gracenotes> > length "xxxxxxxxxxxx"
20:38:37 <lambdabot>   12
20:38:44 <Gracenotes> :o
20:39:04 <kbateman> > length $ replicate 12 undefined
20:39:06 <lambdabot>   12
20:39:24 <Gracenotes> :O
20:40:08 <mib_bmia1bmx> I'm new to haskell and just wrote a simple trim function (http://pastebin.com/d6f1fcfa).  I was wondering if anyone here could look over it and tell me any improvements I could make it more idiomatic haskell. Thanks
20:40:16 <ManateeLazyCat> pumpkin: Even local value, i still need make it live in `main` function to connected other modules.
20:41:08 <roconnor> ManateeLazyCat: how's it going?
20:41:15 <ManateeLazyCat> pumpkin: I need a *center* value like a bridge link two modules.
20:41:34 <Gracenotes> mib_bmia1bmx: it is nice :) just a bit inefficient, with singly-linked lists (which is what strings are)
20:41:42 <Cale> mib_bmia1bmx: Maybe something like  trim7 = dropWhile isSpace . reverse . dropWhile isSpace . reverse
20:42:13 <ManateeLazyCat> I will still use IORef still someday i can write complete stats moand code.
20:42:19 <pumpkin> I had a neat trim without reverses a while ago
20:42:19 <ManateeLazyCat> s/complete/complex
20:42:29 <roconnor> hmm, that trim doesn't seem as lazy as it could be :)
20:42:36 <Gracenotes> efficient tail-dropWhile is tricky.. best way I can think to do it is with a foldr with a (Bool, [a]) accumulator
20:42:44 <pumpkin> mine was nice
20:42:49 <pumpkin> ;)
20:42:54 <kbateman> mib_bmia1bmx: The biggest deal is that it wants to fiddle with stuff at the end of a list.  Lost of O(n^2) action there.
20:42:59 <Cale> roconnor: It is though.
20:43:04 <kbateman> s/Lost/Lots/
20:43:34 <Cale> roconnor: Since to know that you're at the spaces that you're meant to drop from the end of the string, and not just some other spaces, you need to go all the way to the end anyway.
20:43:36 <roconnor> Cale: I can imagine at trim that works on (repeat 'a')
20:44:00 <Cale> hmm
20:44:10 <Cale> Okay, perhaps you have a point there :)
20:44:37 <ManateeLazyCat> Cale: Example, i want separate module with my program, but if i pass IORef, i need write all *local value* in function `main :: IO ()`, and that's is not clean.
20:44:47 <kbateman> trim s = reverse $ trimHeadSpace $ reverse $ trimHeadSpace s
20:44:49 <Cale> ManateeLazyCat: What?
20:45:06 <Cale> kbateman: Just a style point, don't use $ that way, use .
20:45:13 <wli> What's trimHeadSpace?
20:45:22 <Cale> Presumably it's  dropWhile isSpace
20:45:24 <kbateman> what a pointless criticism
20:45:31 <wli> kbateman: Maybe Data.Sequence is the way to go.
20:45:32 <ManateeLazyCat> Cale: If you remove removePerformIO, you have pass IORef to all functions that need it.
20:45:32 <Cale> kbateman: It's not entirely pointless :)
20:45:42 <kbateman> or pointfree rather
20:45:45 <kbateman> :)
20:45:48 <Cale> kbateman: ah :)
20:45:51 <gwern> Cale: presumably the next step was a transformation to remove s
20:45:57 <Gracenotes> > let tailDropWhile f = fst . foldr (\a (xs, b) -> if b && f a then (xs, True) else (a:xs, False)) ([], True) in tailDropWhile isSpace "    hello there   "
20:45:59 <lambdabot>   "    hello there"
20:46:00 <kbateman> trimHeadSpace = dropWhile isSpace
20:46:07 <Cale> kbateman: Heh, I only suspected that joke after I said it ;)
20:46:11 <ManateeLazyCat> Cale: And this *local value* will live in function `main :: IO ()`, if just this one, it's okay.
20:46:15 * pumpkin tries to remember how he did it elegantly
20:46:15 <Gracenotes> better than reversing twice... arguably :X
20:46:23 <mib_bmia1bmx> Thanks for the alternative solutions, I obviously have a lot to learn.
20:46:28 <Cale> kbateman: But yeah, the nice thing about (.) is that it's an associative operator, so your code is easier to manipulate
20:46:41 <Gracenotes> pumpkin: you mean you didn't save it in a file like it told you to!!!!!?!!??
20:46:56 <Cale> ManateeLazyCat: I don't understand what the life of a value means.
20:47:06 <ManateeLazyCat> Cale: But if i add many *local value* that use IORef, i need move them all to `main :: IO ()`, and this is dirty'.
20:47:12 <Cale> ManateeLazyCat: You mean that you'll have to use newIORef from main?
20:47:16 <Gracenotes> > let tailDropWhile f = fst . foldr (\a (xs, b) -> if b && f a then (xs, True) else (a:xs, False)) ([], True) in tailDropWhile isSpace ("    hello there" ++ repeat ' ')
20:47:17 <lambdabot>   "* Exception: stack overflow
20:47:20 <pumpkin> Gracenotes: nope :P
20:47:23 <Cale> Not necessarily to main directly
20:47:30 <Cale> They could be created in any number of places.
20:47:31 <ManateeLazyCat> Cale: Yep,
20:47:35 <jfredett> among the various XML libraries, which one is the standard/most used/best supported/make my decision on which one to use for me kthnxbi.
20:47:37 <Gracenotes> hm
20:47:38 <jfredett> ?
20:47:40 <pumpkin> > let trim = concat . init . tail . group . (" " ++) . (++ " ") in trim "     hello     there     "
20:47:41 <lambdabot>   "hello     there"
20:47:43 <pumpkin> there
20:47:50 <roconnor> ManateeLazyCat: you can use newIORef  in any IO function, not just main
20:47:50 <Cale> ManateeLazyCat: Or you can create an IO action which creates them all and hands you a record of them.
20:47:59 <ManateeLazyCat> Cale: I need it's value communication with different modules
20:48:03 <pumpkin> the one I did last time did groupBy isSpace
20:48:15 <Cale> ManateeLazyCat: Normally parameter passing is all you need.
20:48:54 <Gracenotes> pretty trim. although possible extra work (heaven forbid)
20:49:03 <Cale> ManateeLazyCat: I even usually completely manage to avoid IORefs as well.
20:49:29 <pumpkin> > let trim = concat . init . tail . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in trim "  \t   hello     there     "
20:49:30 <Cale> ManateeLazyCat: Though there's occasion for them, especially when writing traditional sorts of event handlers.
20:49:31 <lambdabot>   "hello     there"
20:49:35 <pumpkin> Gracenotes: possible extra work?
20:49:36 <roconnor> ManateeLazyCat: you can pass IORefs as parameters to other functions
20:49:42 <pumpkin> Gracenotes: what extra work does it do?
20:49:50 <kbateman> I would think that reversing twice, though  it seems ugly, is no slower than something like init.
20:50:06 <ManateeLazyCat> roconnor: Yes, quicksilver have said that to me.
20:50:08 <Gracenotes> init isn't slow at all
20:50:11 <pumpkin> kbateman: init isn't slow, you need to traverse the list anyway
20:50:19 <Cale> Using init repeatedly is slow.
20:50:20 <Gracenotes> pumpkin: adding on two " "s... the horror
20:50:22 <roconnor> pumpkin: lies!
20:50:32 <pumpkin> I only use it once though
20:50:32 <roconnor> well, liesish
20:50:35 <Gracenotes> forsooth, Cale
20:50:41 <pumpkin> it feels a little ugly to prepend and append the spaces
20:50:50 <pumpkin> but it seems pretty decent otherwise
20:50:51 <kbateman> let trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace in trim "        hello     world              "
20:51:01 <Cale> init costs about as much as a single reverse
20:51:03 <kbateman> > let trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace in trim "        hello     world              "
20:51:05 <lambdabot>   "hello     world"
20:51:05 <ManateeLazyCat> roconnor: If i use pass IORef as parameters to function, and i think i need remove global value. no reason to use global value
20:51:51 <pumpkin> o.O
20:51:55 <roconnor> ManateeLazyCat: IORefs don't have to be global.  When the go out of scope, they will be available for garbage collection
20:52:02 <Gracenotes> Cale: depends on what you mean by 'costs'
20:52:18 <Cale> Gracenotes: by the time the resulting string is completely evaluated
20:52:50 <kbateman> > let trim = let a = reverse . dropWhile isSpace in a.a in trim "   hello world    "
20:53:10 <lambdabot>   "hello world"
20:53:12 <pumpkin> kbateman: Saizan did something like that last time this came up
20:53:12 <Cale> each reverse costs O(n), and each init adds O(1) cost to each cell evaluated, so they work out more or less the same
20:53:14 <Gracenotes> Cale: yeah. Except, you are doing it twice.
20:53:21 <Cale> *each* init
20:53:35 <pumpkin> > let trim = concat . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in trim $ "  \t   hello     there     " ++ cycle " " -- why doesn't this work?
20:53:36 <Cale> So if you do more than 2 inits, it starts costing more than reversing twice
20:53:37 <Gracenotes> each of the .. one inits used
20:53:41 <ManateeLazyCat> roconnor: Yep, I can write newIORef in any IO action, but it can communication with others modules when i write newIORef in `main` function
20:54:03 <Cale> init will end up being called in that code as many times as there are spaces at the end of the string
20:54:14 <pumpkin> Cale: ?
20:54:31 <Cale> oh, I wasn't referring to your version pumpkin
20:54:32 <pumpkin> oh
20:54:47 <pumpkin> but I still don't get why mine doesn't work on an infinite string
20:54:52 <Cale> I was talking about the original one
20:54:54 <pumpkin> ah
20:55:00 <Gracenotes> pumpkin: it does
20:55:09 <ManateeLazyCat> roconnor: Because others modules live in `main` function, they need communication each other.
20:55:10 <pumpkin> labmdabot still hasn't responded
20:55:16 <wli> let trim = let trimLeft x = case Seq.viewl x of { z :< zs | isSpace z -> trimLeft zs ; _ -> x } ; trimRight x = case Seq.viewr x of { zs :> z | isSpace z -> trimRight zs ; _ -> x } in List.unfoldr (\x -> case Seq.viewl x of { EmptyL -> Nothing ; z :< zs -> Just (z, zs) }) . trimLeft . trimRight . Seq.fromList in trim
20:55:20 <kbateman> pumpkin:  How does it know there isn't a nonspace after a bajillion spaces?
20:55:25 <Gracenotes> pumpkin: it's still looking for the character after the last space :)
20:55:37 <pumpkin> kbateman: it doesn't need to, it can already start producing the beginning of the list
20:55:41 <Cale> pumpkin: It can never tell if those spaces at the end are the last group of spaces
20:55:55 <pumpkin> oh yeah, I don't mean returning a finite list
20:56:02 <pumpkin> but it should be able to start producing the beginning of the list surely?
20:56:08 <Gracenotes> it's why any group of an infinite list with repeating elements at the end is destined to fail
20:56:13 <Gracenotes> or at least hang
20:56:37 <roconnor> let trim13  x = let x' = group (dropWhile isSpace x) in (concat (init x))++(if (null x' || isSpace (head (last x'))) then [] else (last x')) in trim13   "   hello world    "
20:56:41 <roconnor> > let trim13  x = let x' = group (dropWhile isSpace x) in (concat (init x))++(if (null x' || isSpace (head (last x'))) then [] else (last x')) in trim13   "   hello world    "
20:56:42 <Cale> pumpkin: it does
20:56:44 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
20:56:44 <wli> You can remember the last string seen before a run of spaces aas you go.
20:56:55 <pumpkin> Cale: but lambdabot didn't give me an answer just now
20:56:59 <Cale> let trim = concat . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in take 15 . trim $ "  \t   hello     there     " ++ cycle " "
20:57:00 <Gracenotes> > let trim = concat . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in trim $ concat (replicate 20 "  hello there ") ++ cycle " "
20:57:02 <pumpkin> it didn't even get killed, maybe it just doesn't like me
20:57:06 <Cale> > let trim = concat . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in take 15 . trim $ "  \t   hello     there     " ++ cycle " "
20:57:09 <lambdabot>   "hello     there"
20:57:16 <lambdabot>   mueval: Prelude.read: no parse
20:57:18 <pumpkin> oh, so it just doesn't like me
20:57:20 <Cale> Because it's buffered.
20:57:26 <pumpkin> ah
20:57:27 <Cale> No, I added a take 15
20:57:33 <pumpkin> ah
20:57:33 <roconnor> Ah right
20:57:34 <pumpkin> hmm
20:57:40 <Gracenotes> teh ghci shows teh behavior for realz
20:58:08 <pumpkin> ah, nice
20:58:15 <pumpkin> I was really confused
20:58:24 <roconnor> > let trim13  x = let x' = group ((dropWhile isSpace x++" ")) in (concat (init x'))++(if (null x') then [] else (last x')) in trim13   "   hello world    "
20:58:27 <ManateeLazyCat> kbateman: data WindowsList is necessary, because i will add other value in `WindowsList`
20:58:28 <lambdabot>   "hello world     "
20:58:30 <pumpkin> I thought I understood what was going on in terms of strictness and lambdabot made me question myself!
20:59:13 <roconnor> > let trim13  x = let x' = group ((dropWhile isSpace x++" ")) in (concat (init x')) in trim13   "   hello world    "
20:59:15 <lambdabot>   "hello world"
20:59:21 <roconnor> > let trim13  x = let x' = group ((dropWhile isSpace x++" ")) in (concat (init x')) in trim13  (repeat 'a')
20:59:32 <roconnor> > take 15 $ let trim13  x = let x' = group ((dropWhile isSpace x++" ")) in (concat (init x')) in trim13  (repeat 'a')
20:59:36 <lambdabot>   mueval: Prelude.read: no parse
20:59:43 <pumpkin> lambdabot sounds tired
20:59:47 <lambdabot>   thread killed
21:00:06 <roconnor> where did I go wrong
21:00:26 <Gracenotes> Mueval is actually the name of lambdabot's secret Brazillian lover, to whom she is surreptitiously attempting to communicate
21:00:50 <roconnor> ManateeLazyCat: in what way are these IORefs not global if every module needs access to it?
21:01:24 <Gracenotes> ..it's a theory
21:01:57 <roconnor> bah, Cale already solved it
21:02:02 <pumpkin> ?
21:02:05 <ManateeLazyCat> roconnor: `WindowsList` module control `window` add and remove, and other module need query information from WindowsList, and then decide what to do next.
21:02:08 <pumpkin> roconnor: what was wrong?
21:02:10 <roconnor> pumpkin: lazy trim
21:02:10 <pumpkin> I can't see it
21:02:21 <roconnor> > take 15 $ let trim13  x = let x' = group ((dropWhile isSpace x++" ")) in (concat (init x')) in trim13  (repeat 'a')
21:02:25 <ManateeLazyCat> roconnor: That's why i need `WindowsList` global.
21:02:33 <pumpkin> roconnor: I mean, why wasn't yours lazy
21:02:35 <kbateman> ManateeLazyCat:  http://paste2.org/p/184926
21:02:42 <roconnor> pumpkin, ya, I don't know
21:02:51 <dolio> > group $ repeat 'a'
21:02:56 <lambdabot>   ["aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:02:59 <ManateeLazyCat> roconnor: If it not global, the local value also need live in `main` function
21:03:16 <pumpkin> which is Cale's version?
21:03:39 <Cale> pumpkin: My version?
21:03:41 <roconnor> ManateeLazyCat: Sure, I understand it is global.  that makes sense.  But you seem to have been saying before that it was local.
21:04:30 <ManateeLazyCat> roconnor: If I drop global value, i write "localValue <- newIORef 0" in `main` function.
21:04:34 <pumpkin> Cale: of trim
21:04:48 <ManateeLazyCat> kbateman: Thanks, works fine.
21:04:59 <Cale> pumpkin: I just gave the simple two-reverses version at the beginning since it's easy to understand.
21:05:03 <pumpkin> ah
21:05:07 <Cale> pumpkin: I haven't given any others :)
21:05:13 <roconnor> <Cale> > let trim = concat . tail . init . groupBy ((&&) `on` isSpace) . (" " ++) . (++ " ") in take 15 . trim $ "  \t   hello     there     " ++ cycle " "
21:05:15 <wli> > let trim = dropWhile isSpace . trim' ; trim' [] = [] ; trim' (c : cs) = let s' = trim' cs in if null s' && isSpace c then [] else c : s' in trim "  hello there  "
21:05:16 <lambdabot>   "hello there"
21:05:23 <pumpkin> roconnor: that was mine :P
21:05:27 <roconnor> oh
21:05:35 <Cale> roconnor: that was pumpkin's version, I just added the take 15 so it would finish
21:05:41 <roconnor> you see my confusion though
21:05:47 <roconnor> :P
21:05:47 * pumpkin hates roconnor now
21:05:55 <Cale> haha
21:05:55 <ManateeLazyCat> roconnor: If i write newIORef in other IO function, it's value can't keep when out of function.
21:05:59 <roconnor> I have a short memory
21:06:13 <roconnor> ManateeLazyCat: yes you can
21:06:18 <Cale> ManateeLazyCat: You can return it as part of the result
21:06:41 <Cale> ManateeLazyCat: and you can pass it as a parameter to other functions
21:06:56 <roconnor> Like in C where you can new a pointer and return it
21:07:01 <pumpkin> roconnor: seems yours is lazy too
21:07:15 <ManateeLazyCat> Cale: So you mean, i pass *initValue* to function, and then use *newValue* store the value that return from function.
21:07:20 <ManateeLazyCat> ?
21:07:24 <pumpkin> roconnor: just not quite as lazy
21:07:51 <Cale> ManateeLazyCat: uh, that's one way to do things, if you want to avoid IORef altogether.
21:08:01 <Cale> ManateeLazyCat: If I understand you.
21:08:29 <Cale> ManateeLazyCat: But I just meant that it's possible to use newIORef to create a new IORef, and then return that IORef as part of the result
21:08:32 <roconnor> pumpkin: yours has the advantage of being more correct
21:08:37 <wli> I just said the heck with highfaluting stuff and did direct recursion.
21:08:41 <roconnor> as in, it is correct
21:08:58 <Cale> I like pumpkin's version with groupBy
21:09:24 <pumpkin> :)
21:10:04 <Cale> ManateeLazyCat: Which makes it accessible from the caller.
21:10:16 <Cale> ManateeLazyCat: It can then be passed along as a parameter to other functions
21:10:25 <ManateeLazyCat> Cale: I think i know what do you mean, you mean is use newIORef to create a new IORef, then pass it to a function to handle, and use writeIORef modified this IORef with the value that return from function.
21:10:48 <Cale> I don't think that's what I was saying either.
21:10:53 <Cale> I mean like...
21:11:01 <roconnor> > let trim = dropWhile isSpace . trim' ; trim' [] = [] ; trim' (c : cs) = let s' = trim' cs in if null s' && isSpace c then [] else c : s' in take 15 $ trim (repeat 'a')
21:11:03 <lambdabot>   "* Exception: stack overflow
21:11:13 <roconnor> wli:  it has issues
21:11:32 <wli> I don't see why that's supposed to work, but okay.
21:11:34 <roconnor> @type split
21:11:36 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
21:11:56 <roconnor> @hoogle (a -> Bool) -> [a] -> ([a],[a])
21:11:57 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
21:11:57 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
21:11:57 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
21:12:01 <roconnor> span
21:12:01 <hydo> I'm stuck on a very elementary thing :/  if anyone has a sec, i'd appreciate a glance... http://www.friendpaste.com/7YM0KSLftWUqF0tqhJ13js
21:12:30 <ManateeLazyCat> kbateman: What do you mean `this is not multithread safe!' ?
21:12:58 * pumpkin has been evangelizing haskell over twitter
21:13:37 <pumpkin> ManateeLazyCat: it's not atomic
21:13:39 <Cale> hydo: You can use pattern matching with either a case expression, or multiple function clauses
21:13:48 <andresj> hey anyone can help with a (sshud be simple, i must admit) question? :D  I got an `IO Int` and I want to use (!!) to get the item of a list. In other words, let randomItem xs = xs !! return randomIndex (length xs) where randomIndex  x = randomRIO (0, x - 1)      However, I dont know how to phrase the randomItem predicate.
21:14:04 <dobblego> andresj, you want to use liftM
21:14:18 <ManateeLazyCat> pumpkin: So it's will trouble when two thread use function `windowsIDNew`
21:14:19 <ManateeLazyCat> ?
21:14:19 <Cale> andresj: you want to run the IO Int to get an actual Int which you can use
21:14:20 <dobblego> andresj, that will get you a IO a
21:14:29 <pumpkin> ManateeLazyCat: if you're particularly unlucky, it could
21:14:41 <hydo> Cale: so take f and pass it to a function that looks for Array x where x will be the actual inner value?
21:14:48 <Cale> andresj: so  do n <- randomRIO (0, x - 1); return (xs !! n)
21:15:07 <Cale> hydo: perhaps, yeah
21:15:08 <hydo> Cale: rather, a set of functions covering all cases, I guess.
21:15:12 <ManateeLazyCat> pumpkin: I think i will use multi-thread mix `windowsIDNew` next step.
21:15:22 <Cale> hydo: or write   case f of Array xs -> ... ; ...
21:15:34 <andresj> Cale, oooo thats how u do it, lol---thank you!! :D    and dobblego, how would I use liftM? I am mostly a Haskell noob, specially on Monads :P
21:15:39 <hydo> Cale: thanks!  A nudge in the right direction :)
21:15:42 <pumpkin> ManateeLazyCat: atomicModifyIORef :: IORef a -> (a -> (a,b)) -> IO b
21:15:59 <roconnor> pumpkin: that exists?
21:16:10 <Cale> andresj: well, fmap (xs !!) (randomRIO (0, x-1))  is the same
21:16:14 <pumpkin> @hoogle atomicModifyIORef
21:16:15 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
21:16:17 <dobblego> andresj, (!! n) `liftM` myIOInt
21:16:19 <Cale> andresj: or liftM in place of fmap
21:16:19 <pumpkin> appears to :)
21:16:30 <roconnor> pfft
21:16:35 <roconnor> what do we even have MVars
21:16:50 <Cale> andresj: But I think understanding how to write it in do-notation is a better first step :)
21:16:51 <andresj> so fmap = liftM ?
21:16:59 <Cale> andresj: yes, basically
21:17:07 <Cale> andresj: fmap is slightly more general
21:17:12 <dolio> roconnor: Maybe you want your code to run more slowly.
21:17:24 <dolio> If so, you use MVars.
21:17:26 <andresj> Cale, well I understand most in do-notation :P I just didnt have the return part down ;D
21:17:44 <andresj> Cale: and, oh i see
21:17:51 <Cale> andresj: Ah, return v is an IO action which does nothing except to result in v :)
21:18:17 <Cale> (so putting it in the middle of a do-block does nothing)
21:18:45 <andresj> Cale: hahaha thank you :-) I inferred that from its type, but I didnt know how to put that in the do-block; maybe i didnt try hard enough, but its like taking shots in the dark w/o help :P
21:19:11 <wli> > let trim = dropWhile isSpace . concat . trim' ; trim' s = let (u, v) = break isSpace s in u : trim'' v ; trim'' s = let (u, v) = span isSpace s in if null v then [] else u : trim' v in trim $ repeat 'a'
21:19:13 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
21:19:13 <Cale> andresj: Yeah, it's a little strange to get used to at first, but one grows to like it :)
21:19:22 <roconnor> wli: better
21:19:47 <roconnor> wli++
21:19:48 <andresj> Cale: haha i already like it ;P
21:19:54 <Cale> andresj: One thing that I really love about this way of doing things is that you can pass IO actions around as parameters without fear of accidentally having them run too soon.
21:20:05 <ManateeLazyCat> pumpkin: But if i add multiple IORef in WindowsList, automicMOdifyIORef still can't work?
21:20:27 <andresj> Cale, do you mean by using do-blocks or `liftM`?
21:20:34 <wli> This is better: trim = concat . trim' . dropWhile isSpace
21:20:41 <pumpkin> ManateeLazyCat: you could arrange for a lock around them, but just make a single IORef of a record
21:20:58 <kbateman> yet another trim implementation: http://paste2.org/p/184931
21:21:56 <hydo> Cale: woo woo! I got it to work.  Thanks again!
21:22:05 <Cale> andresj: I mean if you pass an IO action as a parameter to another function, it can make use of that IO action if and when it pleases, as many times as it likes.
21:22:13 <Cale> hydo: great :)
21:22:39 <Cale> andresj: Rather than having the IO action run once first, and only passing the result.
21:22:54 <andresj> Cale: haha oh i see---well I havent played much with IOs yet :P Ive stuck to non-IO until now; but I wanted to use some random choices so i figured id step in :P
21:23:21 <wli> I like pumpkin's now.
21:23:27 <roconnor> @type randoms
21:23:28 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
21:23:31 <roconnor> @type randomsIO
21:23:32 <lambdabot> Not in scope: `randomsIO'
21:23:56 <andresj> By the way, what is the equivalent of liftM but its first argument is (a -> IO b) instead of (a -> b) ? Or any equivalent construct :P
21:24:07 <pumpkin> wli: \o/
21:24:19 <Cale> andresj: =<<
21:24:29 <Cale> :t (=<<)
21:24:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:24:38 <Cale> :t (>>=)
21:24:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:24:47 <wli> Well, sort of, but anyway.
21:24:51 <pumpkin> :P
21:25:01 <kbateman> :t flip (>>=)
21:25:03 <pumpkin> it definitely isn't as elegant as I'd like
21:25:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
21:25:09 <pumpkin> adding spaces and taking them off feels ugly
21:25:16 <kbateman> @src (>>=)
21:25:17 <lambdabot> Source not found. You speak an infinite deal of nothing
21:25:28 <kbateman> @src (=<<)
21:25:29 <lambdabot> f =<< x = x >>= f
21:25:38 <andresj> (>>=) = flip (=<<)
21:25:45 <roconnor> wli:  I like yours more than pumpkins
21:25:47 <QtPlaty[HireMe]> kbateman: The source of >>= is defined for the perticular monad your dealing with
21:25:51 <Botje> that @src looks like some weird spaceship operator
21:26:00 <andresj> thank you Cale, and everyone, haha :P
21:26:14 <Cale> andresj: no problem
21:26:16 <Botje> =<<x=x>>= # IM IN UR SKIES TAKING UR MOOMOOS
21:26:26 <pumpkin> :t (>=>)
21:26:27 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
21:26:36 <Cale> =<<x=x>>= # IM IN UR SKIES TAKING UR MONADS
21:26:41 <pumpkin> lol
21:26:50 <Botje> not so different from moomoos, i'd think
21:27:05 <Hunner_bb> @type (<=>)
21:27:06 <lambdabot> Not in scope: `<=>'
21:27:07 <Cale> Oh no... no no no no no
21:27:28 <Cale> We are not going to see a "Monads are just the same as cows" tutorial.
21:27:37 <andresj> LOL
21:27:46 <Botje> how about UFOs?
21:27:53 <Botje> can we do a UFO monad tutorial?
21:28:08 * Cale facepalms
21:28:30 <Axman6> do notation lets us take the cow out of the monad ship
21:28:45 <Botje> giggle
21:28:47 <Axman6> return returns the cow to its mother monad ship
21:29:01 <Axman6> >>= is like a hanburger factory
21:29:05 <Botje> Axman6++ # moonad!
21:29:06 <Axman6> hamburger
21:29:13 <Axman6> @karma
21:29:14 <lambdabot> You have a karma of 6
21:29:20 <Axman6> :)
21:29:25 <Cale> ハンバーガー
21:29:33 <andresj> I wonder if theres a more elegeant way to say putStrLn =<< (:[]) `liftM` randomItem letters
21:29:49 <Botje> (:[]) is return
21:29:59 <roconnor> wait what?  atomicModifyIORef works if you only have 1 IORef?!
21:30:03 <Cale> in the list monad ;)
21:30:04 <andresj> :t (:[])
21:30:05 <lambdabot> forall a. a -> [a]
21:30:06 <roconnor> plz explain!
21:30:18 <Cale> > return 5 :: [Integer]
21:30:20 <lambdabot>   [5]
21:30:27 <andresj> what!!!?
21:30:27 <pumpkin> roconnor: ?
21:30:35 <andresj> lol wow i wouldnt have imagined that was possible, lol
21:30:39 <roconnor> This function is useful for using IORef in a safe way in a multithreaded program. If you only have one IORef, then using atomicModifyIORef to access and modify it will prevent race conditions.
21:30:41 <Cale> > do x <- [1,2,3]; y <- [4,5,6]; return (x,y)
21:30:43 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
21:30:54 <Axman6> roconnor: whut? o.O
21:31:00 <roconnor> oh, maybe it just means that atomicModifyIORef cannot be used to lock 2 IORefs
21:31:21 <Cale> andresj: different monad :)
21:31:27 <pumpkin> roconnor: ah yeah :)
21:31:29 <pumpkin> I think that's it
21:31:33 <roconnor> oh
21:31:34 <roconnor> whew
21:32:30 <roconnor> pumpkin: I gather that readIORef and writeIORef are atomic then?
21:32:31 <kbateman> If you have two IORefs then you can't include them both in a proper atomic action.
21:32:44 <pumpkin> roconnor: atomic in what sense? they're only doing one thing aren't they?
21:32:46 <Cale> But you can with TVars :)
21:33:22 <roconnor> pumpkin: well, that is implementation specific.
21:33:23 <kbateman> roconnor:  They're atomic, but you can't consistently connect them with any other reads or writes.
21:33:59 <pumpkin> oh yeah, you couldn't read from one and write what you read to the other in one operation
21:34:06 <roconnor> kbateman: right, other than within a thread of course.
21:34:56 <andresj> my hopefully more elegeant code: (putStrLn =<<) $ liftM return $ randomItem letters
21:35:12 <andresj> comparing to putStrLn =<< (:[]) `liftM` randomItem letters
21:35:28 <pumpkin> use <$>
21:35:38 <andresj> :t <$>
21:35:40 <lambdabot> parse error on input `<$>'
21:35:44 <andresj> :t (<$>)
21:35:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:35:50 <kbateman> @src randomItem
21:35:51 <lambdabot> Source not found.
21:35:58 <roconnor> @index (<$>)
21:35:59 <lambdabot> bzzt
21:36:05 <andresj> kbateman: lol thats a function in my program, lol
21:36:19 <QtPlaty[HireMe]> roconnor: What doesn @index do?
21:36:22 <twb> I'm trying to package Unixutils for Debian.  I get this; what am I doing wrong?
21:36:27 <twb> Processing triggers for ghc6-doc ...  Warning: Cannot read /usr/share/doc/haskell-regex-base-doc/html/regex-base/regex-base.haddock: "Magic number mismatch: couldn't load interface file: /usr/share/doc/haskell-regex-base-doc/html/regex-base/regex-base.haddock" Skipping this interface.
21:36:36 <andresj> :t liftM
21:36:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:36:40 <roconnor> QtPlaty[HireMe]: I don't know.  I keep trying to get it to do something useful, but it never works.
21:36:56 <andresj> :t fmap
21:36:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:37:00 <kbateman> andresj:  @type randomItem  ?
21:37:10 <pumpkin> <$> is just fmap
21:37:21 <roconnor> aka liftM
21:37:26 <pumpkin> aka liftA
21:37:30 <Gracenotes> randomItem does have a nice efficient implementation osfameron unleashed to the blagowebsphere, http://osfameron.vox.com/library/post/random-pain-in-haskell.html
21:37:32 <Axman6> @help index
21:37:33 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
21:37:34 <andresj> [Char]->IO Char, altho i shud generalize it to [a] ->IO a
21:37:48 <roconnor> @index <$>
21:37:48 <lambdabot> bzzt
21:37:52 <roconnor> screw you
21:37:52 <andresj> lol so why so many names? lol
21:37:55 <Gracenotes> uses a selection algorithm
21:39:02 <pumpkin> andresj: many different structures allow the similar operation, but some have more rules than others
21:39:11 <ddarius> @index (<$>)
21:39:11 <lambdabot> bzzt
21:39:12 <pumpkin> so liftM is the most restrictive
21:39:15 <ddarius> @hoogle <$>
21:39:15 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
21:39:20 <pumpkin> liftA is less, and fmap/<$> are the least
21:39:34 <andresj> i wonder what would make more sense, then.
21:39:37 <Gracenotes> liftM is more. sometimes.
21:39:39 <andresj> to use in my application i mean
21:39:51 <andresj> i just use it to manipulate IO monads
21:40:07 <Gracenotes> liftM2 -> free liftA2, but not necessarily liftA2 -> free liftM2
21:40:28 <pumpkin> if your function could conceivably be used for other stuff, use the least restrictive one you can manage, I'd say :P
21:40:37 <andresj> it seems like generalizing would be good, but then it might lead to errors since i dont plan on using other monads nor functors instead of IO
21:41:11 <andresj> for example, randomPick xs = (xs !!) <$> randomIndex (length xs); that one will definetely be used with IO
21:41:25 <andresj> since randomIndex x = randomRIO (0, x - 1)
21:41:51 <pumpkin> what if you move to another random monad?
21:42:13 <pumpkin> still, it's a monad :P
21:42:24 <andresj> hum... wouldnt it be IO any---well thats true :P
21:42:30 <pumpkin> so I guess it doesn't matter :) and anyway, <$> is the most general one, so you're fine either way
21:42:38 <pumpkin> :t liftIO
21:42:39 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
21:42:44 <Gracenotes> andresj: as mentioned in the linked blag post, that is (n^2) in its full evaluation
21:42:48 <Gracenotes> O
21:43:01 <Gracenotes> but quite works
21:43:51 <andresj> hahaha, well i guess code first, optimize later? ;P plus this is just a little scratch project, lol :D Im just a sucker for elegance
21:43:57 <andresj> :help
21:44:02 <andresj> :commands
21:44:12 <andresj> !commands
21:44:16 <andresj> @src (<$>)
21:44:17 <lambdabot> f <$> a = fmap f a
21:44:25 <pumpkin> :P
21:44:26 <andresj> @module (<$>)
21:44:26 <lambdabot> Unknown command, try @list
21:44:30 <andresj> @list
21:44:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:44:43 <pumpkin> andresj: it's in Control.Applicative
21:44:52 <andresj> oh, thank you pumpkin :)
21:45:18 <Gracenotes> or liftM
21:45:23 <QtPlaty[HireMe]> So <$> is basically fmap spelt as an operator.
21:45:25 <andresj> I think Ill go with <$> ;D
21:45:36 <pumpkin> yup
21:45:42 <pumpkin> it's also got a nicer precedence than `fmap`
21:45:51 <pumpkin> unless of course you give `fmap` that same value :P
21:45:59 * QtPlaty[HireMe] nods.
21:47:59 <Gracenotes> hm. If there were a Haskell code golf, surely it wouldn't count import statements from base modules.. given that golfing opportunities in just Prelude are limited.
21:48:32 <roconnor> well, you count the import statements
21:49:07 <Gracenotes> seems like a tradeoff we shouldn't have to make. but, that's code golf for you... hm.
21:49:17 <pumpkin> import strategic base modules that import other stuff for you
21:49:56 <andresj> hum... is there a search engine to which i can give a type and will tell me the function that has that type?
21:50:02 <pumpkin> @where hoogle
21:50:03 <lambdabot> http://haskell.org/hoogle
21:50:04 <dobblego> andresj, @hoogle
21:50:07 <Gracenotes> indeed
21:50:13 <dobblego> @hoogle (a -> b) -> [a] -> [b]
21:50:13 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
21:50:13 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
21:50:13 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
21:50:17 <andresj> haha thank you :) I knew i had heard of it :P
21:50:19 <roconnor> golf: http://bushong.net/dave/comparisons/
21:50:49 <pumpkin> @hoogle ((a, b) -> (c, b)) -> a -> c
21:50:50 <lambdabot> No results found
21:51:17 <andresj> @src Integer
21:51:17 <lambdabot> data Integer = S# Int#
21:51:17 <lambdabot>              | J# Int# ByteArray#
21:51:35 <roconnor> @hoogle loop
21:51:35 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
21:51:36 <lambdabot> Control.Arrow class Arrow a => ArrowLoop a
21:51:48 <pumpkin> I guess hoogle isn't smart enough to figure out that arrow thing
21:51:51 <andresj> hum what is the class type for Integer?
21:51:55 <pumpkin> Integral
21:52:04 <pumpkin> or Num
21:52:06 <pumpkin> what do you mean?
21:52:10 <roconnor> @djinn ((a, b) -> (c, b)) -> a -> c
21:52:11 <lambdabot> -- f cannot be realized.
21:52:12 <Gracenotes> pumpkin: what sort of maddening function does that!!
21:52:12 <andresj> Awesome, I mean Integral :)
21:52:22 <pumpkin> Gracenotes: ?
21:52:36 <Gracenotes> what you hoogled
21:52:47 <andresj> @hoogle (Integral a) => a -> b -> [b]
21:52:49 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
21:52:49 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:52:49 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
21:52:55 <roconnor> loop f a = let (x,y) = f (a,y) in x
21:53:05 <Gracenotes> oh. I knew there was some dirty trick!
21:53:06 <roconnor> Gracenotes: loop f a = let (x,y) = f (a,y) in x
21:53:12 <andresj> awesome there it is :P
21:53:16 <pumpkin> Gracenotes: it's pretty fun :)
21:53:31 <pumpkin> Gracenotes: it's sort of half a fix
21:53:41 <pumpkin> or rather, half of it is a fix
21:53:58 <roconnor> ya, I was going to say it was a more symetric fix
21:54:08 <pumpkin> you can draw a nice diagram of how it works
21:54:14 <pumpkin> I think it's in the arrow paper or the page on it
21:55:36 <Gracenotes> now to answer pressing questions, like: why do Cheez-Its and yogurt taste so good together?
21:56:10 <roconnor> Gracenotes: that can't possibly be true
21:56:36 <andresj> @hoogle (Functor f) => (f a -> f b -> r) -> f a -> f b -> f r
21:56:37 <lambdabot> No results found
21:56:40 <Gracenotes> oddly, it is. at least the sort of yogurt I'm eating.
21:56:48 <pumpkin> I don't like US yogurt
21:56:51 <pumpkin> most of it at least
21:56:59 <andresj> @hoogle (Monad f) => (f a -> f b -> r) -> f a -> f b -> f r
21:57:00 <lambdabot> No results found
21:57:08 <andresj> hey guys any idea how to do that one?
21:57:30 <dobblego> @type liftM3 -- this one?
21:57:31 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
21:57:39 <dobblego> @type liftM2 -- this one?
21:57:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
21:57:46 <andresj> oooohh I think its liftM2, actually lol
21:57:53 <pumpkin> or liftA2
21:57:55 <dolio> @type ((.) return .)
21:57:56 <lambdabot> forall b (m :: * -> *) a a1. (Monad m) => (a1 -> a -> b) -> a1 -> a -> m b
21:58:01 <pumpkin> don't think it's possible with just a functor
21:58:12 <andresj> thank you :)
21:58:20 <pumpkin> :t liftA2
21:58:21 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
21:58:24 <dolio> @type ((.) return .) :: Monad m => (m a -> m b -> r) -> m a -> m b -> m r
21:58:26 <lambdabot> forall (m :: * -> *) a b r. (Monad m) => (m a -> m b -> r) -> m a -> m b -> m r
21:58:32 <Gracenotes> if you like pretty operators and have an applicative instance, a <$> b <*> c
21:58:34 <andresj> is an Applicative more general than a Functor?
21:58:46 <dobblego> no, other way around
21:58:49 <Gracenotes> every Applicative is a Functor
21:58:55 <Gracenotes> not every Functor 'tis Applicative
21:59:14 <Gracenotes> or, a `liftM` b `ap` c for monads
21:59:15 <dobblego> Applicative is more general than Monad
21:59:16 <andresj> hum...
21:59:34 <Gracenotes> dobblego: ?? every Monad can be an Applicative, not every Applicative can be a monad
21:59:47 <dobblego> Gracenotes, right
22:00:21 <Gracenotes> oh.. I see. it is more general.. but, in a sense, less powerful.
22:00:22 <andresj> there are times when i feel my head is very little :P
22:00:50 <pumpkin> Gracenotes: fewer rules = more of them
22:00:51 <pumpkin> :P
22:03:22 <andresj> ok I must understand why Gracenotes’ a <$> b <*> c works
22:03:33 <pumpkin> do you understand ap?
22:03:39 <pumpkin> cause <*> is just ap
22:03:44 <andresj> applicatives?
22:03:49 <pumpkin> nope, it's actually from Monad
22:03:52 <pumpkin> :t ap
22:03:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:04:06 <Gracenotes> @src ap
22:04:07 <lambdabot> ap = liftM2 id
22:04:07 <andresj> well i have nvr used ap :P
22:04:27 <andresj> liftM2
22:04:29 <andresj> hum
22:04:32 <andresj> :t liftM2
22:04:33 <Gracenotes> you can easily make a functor instance for any monad, by saying that fmap = liftM
22:04:34 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:04:55 <Gracenotes> in the same way, you can easily make a applicative instance for any monad, by saying that <*> = ap
22:04:56 <andresj> :t liftM
22:04:57 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:04:59 <Gracenotes> (and pure = return)
22:05:11 <andresj> :t pure
22:05:13 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
22:05:33 <andresj> :t (<$>)
22:05:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:05:44 <Gracenotes> @src liftM2
22:05:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:05:49 <andresj> :t (<$> id)
22:05:51 <lambdabot> forall b a. (a -> b) -> a -> b
22:06:11 <andresj> :t id
22:06:13 <lambdabot> forall a. a -> a
22:06:15 <andresj> f curs, lol
22:06:24 <mauke> > toUpper <$> "abc"
22:06:25 <lambdabot>   "ABC"
22:06:51 <andresj> so <$> is like a generalization of map?
22:06:54 <andresj> :t map
22:06:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:07:00 <mauke> yes
22:07:06 <andresj> List a -> List b
22:07:10 <mauke> [] is a Functor
22:07:18 <Gracenotes> @src [] fmap
22:07:19 <lambdabot> fmap = map
22:07:28 <andresj> ooh
22:07:30 <andresj> :t fmap
22:07:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:07:35 <pumpkin> andresj: a Functor is something that is "mappable"
22:07:42 <mauke> <$> is just another name for fmap
22:07:43 <Gracenotes> @src <$>
22:07:44 <lambdabot> f <$> a = fmap f a
22:07:48 <mauke> because we like to confuse you
22:07:59 <andresj> hahahaha lol i noticed, mauke ;D
22:08:15 <Gracenotes> > [toUpper, toLower] `ap` "abCdEfGhIJK"
22:08:15 * QtPlaty[HireMe] still thinks that mappend and fmap got mugged.
22:08:16 <lambdabot>   "ABCDEFGHIJKabcdefghijk"
22:08:20 <andresj> pumpkin: so... wow, no this makes more sense
22:08:28 <mauke> > fmap (+1) (Just 2)
22:08:29 <lambdabot>   Just 3
22:08:49 <andresj> :t ap
22:08:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
22:09:01 <andresj> :t (<*>)
22:09:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:09:11 <andresj> ooooh
22:09:18 <andresj> so a Monad is a one-valued Functor
22:09:35 <mauke> one-valued?
22:10:02 <andresj> as in there is no Just 3 4, but there is List 3 4 (assuming that was the notation)
22:10:30 <mauke> 3 : 4 : []
22:10:41 <andresj> u-hum
22:10:42 <mauke> but [] is a Monad
22:10:47 <andresj> ohh
22:11:00 <pumpkin> you can do fun things like
22:11:04 <mauke> > "hello" >>= \c -> [c, toUpper c]
22:11:04 <andresj> how about the type of [3, 4] ?
22:11:05 <lambdabot>   "hHeElLlLoO"
22:11:15 <pumpkin> > liftM2 (,) [1..3] [4..7]
22:11:16 <lambdabot>   [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
22:11:32 <mauke> andresj: what about it?
22:11:39 <pumpkin> > (,) <$> [1..3] <*> [4..7]
22:11:39 <andresj> is it a Monad too?
22:11:41 <lambdabot>   [(1,4),(1,5),(1,6),(1,7),(2,4),(2,5),(2,6),(2,7),(3,4),(3,5),(3,6),(3,7)]
22:11:58 <mauke> technically no, because only type constructors can be Monads
22:12:01 <pumpkin> :t [3,4]
22:12:02 <lambdabot> forall t. (Num t) => [t]
22:12:20 <mauke> so [t] (for some t) can't be a Monad, but [] is
22:13:00 <andresj> hum... ok i got it, where [] does not necesarrily mean the empty list, right?
22:13:37 <pumpkin> yeah, they reused [] for both the type constructor and one of the data constructors
22:13:58 <pumpkin> although you typically see [] a as [a]
22:14:06 <andresj> of course
22:14:15 <mauke> Maybe is a Monad. Maybe Int isn't. Nothing is not even a type :-)
22:14:33 <andresj> Nothing is a type constructor of the Maybe type
22:14:41 <mauke> no, Nothing is a data constructor
22:14:47 <andresj> oh yes
22:14:59 <andresj> is there such a thing as type constructor, then? what is the difference?
22:15:37 <dobblego> Maybe is a type constructor
22:15:51 <dobblego> give it a type and you'll have a type
22:15:56 <dobblego> Maybe Int <-- see
22:16:13 <mauke> Maybe :: * -> *;  Int :: *;  Maybe Int :: *
22:16:32 <pumpkin> lol
22:16:48 <pumpkin> andresj: types themselves have types, and they're called kinds
22:16:58 <andresj> lol wow
22:17:02 <pumpkin> * is the most common one
22:17:06 <andresj> *??
22:17:13 <andresj> where do you see this in haskell code/
22:17:16 <andresj> ?
22:17:16 <pumpkin> so when you did
22:17:18 <pumpkin> :t fmap
22:17:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:17:21 <mauke> andresj: basically, never
22:17:22 <pumpkin> look at that forall over there
22:17:34 <roconnor> @kind Maybe
22:17:36 <lambdabot> * -> *
22:17:37 <pumpkin> you don't need to explciitly deal with them very often
22:17:43 <mauke> I don't know if H98 even has kind syntax
22:17:50 <pumpkin> it doesn't afaik
22:17:52 <andresj> so Maybe is a Monad -> a Functor
22:18:12 <andresj> a Monad → a Functor, I meant
22:18:19 <andresj> to disambiguate with function notation
22:18:46 <roconnor> H98 has kind semenatics though
22:18:54 <pumpkin> well, a Monad gives you a functor for Free
22:18:57 <mauke> yeah, pretty much
22:19:05 <pumpkin> not sure why I uppercased that F
22:19:13 <pumpkin> I meant to do it on Functor :P
22:19:24 <roconnor> pumpkin: Free as in speech, free as in bear
22:19:25 <andresj> hahahaha lol :P
22:19:26 <roconnor> and beer
22:19:37 <pumpkin> free hairy bears
22:19:40 <pumpkin> :)
22:19:40 <mauke> frea as in bear
22:19:46 <roconnor> :)
22:21:05 <andresj> ok so ive gotten to how the type of replicate <$> (randomRIO (1, 6)) is IO (a -> [a])   Currying confuses sometimes :P gotta get used to it ;D
22:21:39 <mauke> here's a puzzle: what is the type of 'flip id' and what does it do?
22:21:58 <roconnor> a -> (a -> b) -> b
22:22:03 <mauke> no, not you
22:22:07 <roconnor> oh
22:22:23 <roconnor> you need to give out a warning
22:22:37 <andresj> hahahaha
22:22:38 <andresj> lol
22:22:50 <andresj> :t flip
22:22:50 <mauke> http://www.dawnofdaria.com/Kinten/happybara.jpg
22:22:51 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:23:01 <roconnor> ... and it does exactly what it's free theorem says it does
22:23:05 <roconnor> its
22:23:19 <mauke> @src flip
22:23:20 <lambdabot> flip f x y = f y x
22:23:21 <andresj> :t id
22:23:23 <lambdabot> forall a. a -> a
22:23:52 <andresj> ok i shall figure your puzzle out anyways mauke :P
22:32:31 <andresj> argh—my hacking is interrupted by gmail not working and a girlfriend in a trip wanting to email me
22:33:16 <johnw> girlfriends = bane of hacking
22:33:25 <johnw> if only you could hack your girlfriend...
22:33:27 <pumpkin> lol
22:33:35 * andresj searches bane on google :P
22:33:36 * pumpkin calls police on johnw
22:33:45 <andresj> LOL
22:34:22 <Gracenotes> okay, maybe I am a little too bored...
22:34:27 <andresj> hahaha pumpkin not even i got THAT image---i wouldve thot johnw meant hack your girlfriend by changing her
22:34:27 <Gracenotes> > fmap (uncurry ((map snd .) . filter . (. (ord . fst)) . (==) . length)) $ ((. zip) . (.) . (,) =<< join (++)) <$> Just "cat smuggling tortures innocent cats!! Stop the smuggling!" <*> Just "say no to kitten smuggling!"
22:34:28 <lambdabot>   Just "yes"
22:34:36 <andresj> hahahahaha
22:34:53 <andresj> lol Gracenotes did you just write that? lol
22:35:07 <Gracenotes> inspired by the fmap talk, yes
22:35:11 <andresj> hahahaha
22:35:59 <andresj> lol i cant figure out how mauke's puzzle works :P
22:36:17 <Gracenotes> what puzzle is that?
22:36:26 <andresj> :t flip id
22:36:27 <lambdabot> forall b c. b -> (b -> c) -> c
22:36:46 <Gracenotes> oh, I see. You have to do type unification in your head!
22:36:56 <andresj> well
22:36:57 <andresj> :t flip
22:36:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:36:59 <andresj> :t id
22:37:01 <lambdabot> forall a. a -> a
22:37:17 <andresj> i cant get a -> a to fit into a -> b -> c, i can only do the contrary :P
22:37:42 <andresj> (or more accurately, a -> a -> a into a -> b)
22:37:42 <mauke> andresj: a -> b -> c == a -> (b -> c)
22:37:53 <andresj> hum really?
22:37:57 <mauke> currying.
22:38:03 <andresj> thats my error then
22:38:16 <andresj> lol, ok i am practicing the flip of currying, or maybe this is the real one :P
22:38:28 <TomMD> @type map map
22:38:29 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
22:38:30 <Gracenotes> well, flip does have three arguments, and once you feed it 'id' it only has two. So it's not totally weird.
22:38:32 <TomMD> @type map map map map
22:38:34 <lambdabot>     Couldn't match expected type `[a -> b]'
22:38:34 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
22:38:34 <lambdabot>     In the second argument of `map', namely `map'
22:38:38 <TomMD> @type map map map
22:38:40 <lambdabot>     Couldn't match expected type `[a -> b]'
22:38:40 <lambdabot>            against inferred type `(a1 -> b1) -> [a1] -> [b1]'
22:38:40 <lambdabot>     In the second argument of `map', namely `map'
22:38:47 <Gracenotes> 'map map' is another one that's fun to reason about
22:38:49 <Gracenotes> right
22:38:56 <andresj> hahahaha
22:39:04 <Gracenotes> @type const id
22:39:05 <lambdabot> forall a b. b -> a -> a
22:39:21 <andresj> you know I think i will leave all this to rest in my head
22:39:27 <andresj> and focus on what i mastered
22:39:29 <davidL> w 24
22:39:42 <andresj> and then antoher day in this week ill come back to tackle new ways of currying ;P
22:40:09 <TomMD> Just fyi for the channel - there are a number of people right now with the homework assignement of thinking about and explaining various type signatures, such as "map map :: ?"
22:40:51 <Gracenotes> andresj: sometimes the reuse of names can be confusing :)
22:40:56 <Gracenotes> @type flip
22:40:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
22:40:58 <Gracenotes> @type id
22:40:59 <lambdabot> forall a. a -> a
22:41:07 <Gracenotes> @type flip id
22:41:08 <lambdabot> forall b c. b -> (b -> c) -> c
22:41:33 <Gracenotes> well, in this case it isn't. But sometimes. a 'b' in one equation might match up with an 'a' in another
22:41:46 <andresj> yes that happens quite a bit ive noticed
22:42:07 <andresj> hey thank you all for your help by the way, it is very appreciated :D
22:42:25 <mauke> andresj: the trick is to specialize the 'a' in id's type signature to 'b -> c'
22:42:55 <andresj> all as's?
22:44:10 <mauke> yeah, both of them :-)
22:44:41 <andresj> @src randomRIO
22:44:42 <lambdabot> Source not found. Sorry.
22:46:44 <cjs> Is there something like a 'pure' for monoids?
22:47:07 <roconnor> cjs: mzero ?
22:47:18 <mauke> not really, the kind is wrong
22:47:40 <pumpkin> cjs: what would it do?
22:47:49 <cjs> That's what I'm still trying to figure out. :-)
22:48:01 <pumpkin> :) then nope
22:48:03 <cjs> For the List monoid, it would be a -> [a].
22:48:13 <A1kmm> Does anyone know what it means if ghc gives an undefined instance error for two instances using tuple like syntax? Does that mean both instances in the tuple are undefined, or it is impossible to construct the tuple for some reason?
22:48:13 <mauke> and for the () monoid?
22:48:24 <cjs> a -> ()
22:48:48 <roconnor> mauke: I saw that response coming
22:48:48 <cjs> Maybe.
22:48:58 <mauke> and for Endo?
22:49:00 <pumpkin> lol
22:49:05 <pumpkin> id
22:49:11 <pumpkin> Endo id ?
22:49:22 <roconnor> const
22:49:25 <A1kmm> For example:     No instances for (Data.StateRef.Classes.ModifyRef
22:49:27 <A1kmm>                         sr m1 (PQ (Double, Double)),
22:49:29 <A1kmm>                       Data.StateRef.Classes.DefaultStateRef sr m1 (PQ (Double, Double)))
22:49:30 <A1kmm>       arising from a use of `newPriorityQueueBy' at QuadTree.hs:111:19-42
22:49:30 <roconnor> mauke: try asking about the Integer monoid
22:53:34 <quicksilver> A1kmm: the instances are in a 'pair' because that's how they appear in a context
22:53:45 <quicksilver> A1kmm: like, (Foo a, Bar a) => a -> a
22:53:59 <andresj> so i forgot, how do u force an IO to run at a certain point in the program?
22:54:08 <quicksilver> A1kmm: the fact that they are both in the error means both are missing.
22:54:33 <quicksilver> andresj: (a) don't use confusing interleaved IO (b) just put the IO where you want it to run.
22:54:35 <A1kmm> quicksilver: Ah... that's what I guessed, I just can't work out why.
22:55:15 <andresj> quicksilver: well I have an (IO Int) which is supposed to be a random number, but Haskell optimizes it and only runs it once
22:55:31 <andresj> and so i get strings like "zzzzzz" or "bbbb"
22:55:32 <quicksilver> I don't believe you.
22:55:46 <andresj> lol, do you wanna see the code, quicksilver? hahaha
22:55:53 <quicksilver> yes.
22:57:13 <roconnor> andresj: should you have an IO Char ?
22:57:30 <andresj> http://www.andresjriofrio.com/ChooseName.hs
22:57:54 <andresj> roconnor: oh yes, i meant IO Char, haha
22:58:07 <mauke> I don't think force makes sense there
22:58:13 <andresj> quicksilver: ignore the force, i added that to test it haha
22:58:25 <quicksilver> andresj: it's because you're using replicate
22:58:25 <andresj> ok its updated
22:58:31 <quicksilver> > replicate 3 'a'
22:58:32 <lambdabot>   "aaa"
22:58:40 <quicksilver> replicate is intended to repeat the same thing n times
22:58:42 <mauke> you replicate a random letter a random number of times
22:58:58 <andresj> well of course, but the second argument to replicate is an IO
22:59:02 <mauke> no, it isn't
22:59:02 <quicksilver> you're only executing 'randomLetter' once, then pasing the result to a pure function
22:59:12 <andresj> ooooh
22:59:15 <andresj> i got it
22:59:16 <quicksilver> replicate is a pure function
22:59:18 <mauke> <*> calls randomLetter once, then passes the result to replicate
22:59:24 <quicksilver> you've lifted it into the monad with <$> and <*>
22:59:27 <pumpkin> you could do replicateM or sequence . replicate
22:59:29 <mauke> well, to replicate n for some number n
22:59:39 <quicksilver> replicateM is what you want
22:59:44 <andresj> so how would i go---oh haha :P
22:59:45 <mauke> :t replicateM
22:59:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:00:04 <andresj> lol is there like a *M function for all? hehe :P
23:00:20 <quicksilver> (replicateM =<< randomRIO (3,6)) randomLetter
23:00:27 <quicksilver> I think
23:00:45 <mauke> do n <- randomRIO (3, 6); replicateM n randomLetter
23:01:37 <quicksilver> bah, yes.
23:01:41 <quicksilver> ignore what I said :)
23:01:44 <andresj> hahahaha
23:02:12 <quicksilver> bit early still here
23:02:20 <mauke> @. pl undo do n <- randomRIO (3, 6); replicateM n randomLetter
23:02:21 <lambdabot> flip replicateM randomLetter =<< randomRIO (3, 6)
23:02:50 <andresj> wait what did mauke just do? lol :P
23:02:56 <andresj> @. pl undo?
23:02:56 <lambdabot> Plugin `compose' failed with: Unknown command: "undo?"
23:03:06 <mauke> @undo do n <- randomRIO (3, 6); replicateM n randomLetter
23:03:06 <lambdabot> randomRIO (3, 6) >>= \ n -> replicateM n randomLetter
23:03:15 <mauke> @pl randomRIO (3, 6) >>= \ n -> replicateM n randomLetter
23:03:15 <lambdabot> flip replicateM randomLetter =<< randomRIO (3, 6)
23:03:57 <andresj> so is the flip applying to only the replicateM or flip replicateM randomLetter?
23:04:24 <quicksilver> you could also say "join (replicateM <$> randomRIO (3,6) <*> randomLetter)
23:04:33 <quicksilver> but it's probably clearer to use do notation
23:05:04 <andresj> yes, it is probably, even tho i like operators for their elegance :P
23:05:05 <quicksilver> no you couldn't.
23:05:17 <quicksilver> "join (replicateM <$> randomRIO (3,6) <*> return randomLetter)"
23:05:22 <quicksilver> that really is a bit odd though.
23:05:32 <Axman6> @. pl undo do n <- randomRIO (3, 6); replicateM n randomLetter
23:05:32 <lambdabot> flip replicateM randomLetter =<< randomRIO (3, 6)
23:05:52 <Axman6> @re
23:05:53 <lambdabot> Maybe you meant: read reconnect redo remember repoint rc
23:05:58 <roconnor> surely there is an operator for f <*> return g
23:06:05 <Axman6> @. . redo pl undo do n <- randomRIO (3, 6); replicateM n randomLetter
23:06:06 <lambdabot> Plugin `compose' failed with: Unknown command: ""
23:06:09 <Axman6> lame
23:06:30 <mauke> andresj: f x y == ((f x) y)
23:06:31 <andresj> wait but i dont understand why we use do there
23:06:46 <andresj> because doesnt "<-" strip the value of its IO?
23:06:58 <Axman6> in a way
23:07:16 <A1kmm> quicksilver: The libraries have "instance DefaultStateRef (STRef s a) (ST s) a" and "instance NewRef (STRef s a) (ST s) a", so I still don't understand why the error I'm getting should happen.
23:07:19 <andresj> oh lol nvm
23:07:23 <andresj> it makes sense now
23:07:27 <andresj> hahahaha, it is late here :P
23:08:09 <quicksilver> A1kmm: I don't follow; the error message you pasted didn't mention ST or STRef, how is that instance relevant?
23:08:30 <pumpkin> roconnor: hmm, can't think of a good use for it? how would you use that?
23:08:42 <pumpkin> then again, we have operators like >=> so not all operators need  be useful ;)
23:09:02 <quicksilver> pumpkin: as in the above example. read up :P
23:09:15 <pumpkin> oh, whoops :)
23:09:21 <pumpkin> sowwy
23:09:21 <quicksilver> A1kmm: oh, I have a guess. Maybe you *want* the answer to be polymorphic in monad + ref type?
23:09:34 <quicksilver> A1kmm: in that case, maybe it's ust the monomorphism restriction biting you?
23:09:50 <pumpkin> what would an epimorphism be in haskell?
23:10:07 <A1kmm> quicksilver: I can try enabling the language extension
23:10:27 <quicksilver> A1kmm: try that, see if it makes the error go away (or changes it! ;)
23:11:27 <quicksilver> pumpkin: a surjective function?
23:11:50 <pumpkin> in values?
23:12:00 <quicksilver> yes.
23:12:10 <quicksilver> Hask has types as objects, morphisms are functions.
23:12:18 <pumpkin> how is the monomorphism restriction related to an injective function?
23:12:21 <pumpkin> oh
23:12:28 <pumpkin> I think I see it
23:12:29 <quicksilver> In that respect it's a category rather like 'Set', so epi = srujective
23:12:33 <quicksilver> (including _|_)
23:12:48 <quicksilver> but including _|_ doesn't make surjection hard. _|_ is always covered.
23:12:56 <quicksilver> pumpkin: entirely unrelated.
23:13:01 <Axman6> argh, i want to write some more haskell >_<
23:13:02 <quicksilver> it's not even the same word.
23:13:07 <pumpkin> wait, hmm
23:13:14 <quicksilver> monomorphism there is the contrary to polymorphism
23:13:21 <pumpkin> weird
23:13:42 <pumpkin> I guess I was trying to stretch it to mean what I thought it meant :)
23:14:10 <pumpkin> seems more reasonable to call it a polymorphism restriction in that case :P
23:14:31 <pumpkin> a restriction of the polymorphism you might have had
23:15:44 <catface> is Hask in a package?
23:17:10 <A1kmm> quicksilver: Well, it made no difference when I added it to my source file, although I don't use DefaultStateRef myself - it comes from the priority-queue package.
23:17:23 <andresj> what function is [IO ()] -> IO () and executes the IO's in sequence?
23:17:46 <catface> sequence_
23:18:30 <andresj> haha uuh thank you :) why not sequence?
23:18:52 <pumpkin> sequence would give you IO [()]
23:20:02 <kerlo> Hey, don't tell me IO [()] isn't useful.
23:20:59 <pumpkin> for unary numbers maybe :P
23:21:11 <Axman6> ok, quick question. can anyone thing of a use for a program that does no input or output whatsoever? (i can think of one reason, i want more)
23:21:27 <pumpkin> Axman6: nope
23:21:34 <pumpkin> I'd be curious to hear your reason
23:21:37 <andresj> pumpkin: haha oh i see, haha
23:21:38 <Axman6> aww, you're not trying hard enough :)
23:21:54 <pumpkin> you considering "covert channels" as IO? :P
23:22:26 <Axman6> well, for one, benchmarking. a program that does a certain amount of work, anf you time the runtime
23:22:27 <catface> to test the compiler?
23:22:29 <Axman6> and*
23:22:37 <pumpkin> Axman6: ah, I consider that as producing an output :P
23:22:39 <Axman6> catface: oh nice one :)
23:22:53 <Axman6> the program itself produces no output
23:23:17 <pumpkin> it releases information in its timing
23:23:20 <pumpkin> :P
23:23:37 <Axman6> oh, thought of another one... heating!
23:23:44 <pumpkin> another covert channel
23:23:48 <pumpkin> :P
23:23:52 <Axman6> run something useless and CPU intensive, and my MBP makes a great heater
23:24:08 <sm> distraction for a runaway AI
23:24:17 <catface> there was a D program somewhere that produced its output at compile time as an error
23:24:45 <Axman6> heh
23:25:07 <twb> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
23:25:07 <twb> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
23:25:14 <twb> I hate compiling dependencies...
23:25:51 <Axman6> btw, the pipeviewer program is quite cool
23:26:31 <Ralith> Axman6: CPU stress testing
23:26:36 <Ralith> for overclockers
23:26:43 <Axman6> Ralith: yeah, i was thinking that too
23:27:24 <Axman6> hmm, i wonder if it's possible to write a program in assmelby that will use every single instruction the CPU handles, repeating them, and not crashing
23:27:44 <pumpkin> your program takes a CPU as input and produces a boolean saying "CPU might be good" or "CPU is bad"
23:27:48 <pumpkin> ;)
23:34:29 <andresj> so does anyone else wonder why randomRIO is not curried by default?
23:34:50 <Axman6> :t randomRIO
23:34:51 <lambdabot> forall a. (Random a) => (a, a) -> IO a
23:35:14 <andresj> most other functions are curried
23:35:15 <andresj> :t curry randomRIO
23:35:16 <lambdabot> forall a. (Random a) => a -> a -> IO a
23:35:41 <mauke> :t bounds
23:35:42 <lambdabot> forall i e. (Ix i) => Array i e -> (i, i)
23:36:38 <andresj> hum... now i must learn about arrays, lol :P
23:37:06 <andresj> hoogle and hackage to rescue :P
23:37:23 <pumpkin> arrays in haskell can usually be indexed any way you want
23:37:29 <pumpkin> so if you like base 1, that's fine
23:37:36 <pumpkin> base 1000, also fine :P
23:38:00 <pumpkin> not all arrays support this, but most do
23:39:37 <pumpkin> andresj: the Ix thing is the typeclass of valid array indices
23:40:01 <andresj> wow lol
23:40:15 <andresj> haskell is like learning deep mathematics :P
23:41:03 <pumpkin> :D
23:41:12 <Gracenotes> it's quite nice really, flexible indexing
23:41:18 <pumpkin> so for a 2d array, a simple way to do it is to index by (Int, Int)
23:41:38 <pumpkin> the Ix instance for (,) takes care of linearizing it for you
23:41:47 <Gracenotes> Arrays are immutable though
23:41:55 <Gracenotes> we have mutable ones too
23:41:57 <pumpkin> that's where the confusing MArray class comes in :P
23:42:12 <raxas_> Axman6: it depends on the meaning of "use"
23:42:15 <raxas_> Axman6: just a pure memory consumption by your program can have drastic effects in a comb^w real world depending on the role the computer is employed in
23:43:21 <andresj> lol
23:43:34 <Gracenotes> yo dawg, i herd u leik mutable arrays, so we put mutable arrays in your immutable arrays so you can be inefficient while you deal with weird monads
23:43:35 <andresj> i thot no objects were mutable in haskell
23:43:55 <mauke> depends on your point of view
23:43:56 <pumpkin> andresj: you can have mutability in the IO monad, or ST
23:44:07 <Gracenotes> here are some basic examples: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays
23:44:07 <pumpkin> mutability is modeled "purely" though
23:44:35 <mauke> I mean, you write stuff to stdout and you've used the global random number generator
23:44:40 <mauke> that's two mutable objects right there
23:44:46 <andresj> well that is true
23:44:59 <andresj> so is the mutable array similar to the IO, then?
23:45:31 <mauke> they have operations with results in IO
23:45:31 <pumpkin> some of them "live in" IO
23:45:44 <pumpkin> but they don't need to, there's a restricted form of the IO monad called ST
23:45:54 <Gracenotes> yes, it's implemented using IO, or ST, which is basically escapable-IO-without-the-IO
23:45:59 <mauke> oh yeah, ST is cool
23:46:12 <mauke> ST lets you create and use local mutable variables
23:46:21 <cjs> Does gransim work in the standard distribution of ghc 6.10.2?
23:46:33 <mauke> as long as you return a pure result, no one needs to know that your algorithm uses mutables inside
23:47:05 <pumpkin> as long as you look happy, no one needs to know that your soul is dying :'(
23:47:16 <Gracenotes> （　≖‿≖）
23:47:18 <pumpkin> :P
23:47:27 <mauke> runST i'mDyingSquirtle
23:47:51 <dibblego> is there a equalIgnoringCase :: String -> String -> Boolean
23:47:55 <andresj> hahahaha
23:48:27 <mauke> :t (==) `on` map toLower
23:48:28 <lambdabot> [Char] -> [Char] -> Bool
23:48:32 <cjs> When I try to compile something with the -gransim flag I get "<command line>: unknown package: concurrent".
23:48:55 <andresj> @module on
23:48:56 <lambdabot> Unknown command, try @list
23:49:32 <pumpkin> mauke: someone in ##c++ liked to point out that case-insensitive compare isn't the same as mapping to upper/lowercase and then comparing equality
23:49:36 <RayNbow> @hoogle on
23:49:37 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
23:49:37 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
23:49:37 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
23:49:49 <RayNbow> ^ andresj
23:50:11 <andresj> hahaha thank you RayNbow, i forgot there was hoogle in the channel too :P
23:50:43 <pumpkin> @index on
23:50:43 <lambdabot> bzzt
23:50:49 <pumpkin> that's the one you'd be looking for with @module btw
23:51:06 <andresj> lambdabot said bzzt, lol
23:51:18 <pumpkin> she also insults you if you ask her for source she doesn't know about
23:51:21 <pumpkin> @src moo
23:51:21 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:51:28 <andresj> @src hey
23:51:29 <lambdabot> Source not found. You untyped fool!
23:51:33 <andresj> LOL
23:51:39 <andresj> @src lambdabot
23:51:40 <lambdabot> Source not found.
23:51:47 <andresj> @src lambdabot
23:51:47 <lambdabot> Source not found. Take a stress pill and think things over.
23:52:03 <andresj> @src on
23:52:03 <lambdabot> (*) `on` f = \x y -> f x * f y
23:52:32 <andresj> (*) ? i thot one used "_" instead
23:53:00 <andresj> ooooh never mind, its a placeholder operator!! haha got it
23:53:05 <Gracenotes> oh, that's the djinn version
23:53:12 <Gracenotes> djinn guesses the wrong version
23:53:17 <Gracenotes> @. djinn type on
23:53:18 <lambdabot> f a b c _ = a (b c) (b c)
23:53:32 <andresj> @.
23:53:32 <lambdabot> Not enough arguments to @.
23:53:36 <Gracenotes> and even so, it still holds onto a
23:54:06 <pumpkin> why does djinn think there's an extra parameter?
23:54:09 <pumpkin> @type on
23:54:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
23:54:15 <pumpkin> oh
23:54:17 <pumpkin>  I see :)
23:54:25 <pumpkin> forgot it took two of them
23:54:59 <hydo> can you really not say " do blahblah return ( fx blah) where fx = (\x -> ...) ? ie, where after the return?  Or am I doing something else wrong?
23:56:24 <Gracenotes> yeah, you can.
23:56:41 <andresj> I would think where has to be at the same level as do
23:56:50 <hydo> ok, cool... I shall poke at it until it does what I want then.  Thanks!
23:57:05 <Gracenotes> sometimes alignment with do blocks is an issue
23:58:05 <nanothief> Whats the difference between an Alternative and a Monoid? They both seem to do exactly the same thing.
23:58:16 <Gracenotes> Alternative requires Applicative
23:58:52 <nanothief> Gracenotes, yes thats true, but anything else? (or is it just that requirement that makes it different)
23:59:42 <pumpkin> empty is not the same as mzero
23:59:50 <Gracenotes> well, speaking in terms of functions, there's mconcat
