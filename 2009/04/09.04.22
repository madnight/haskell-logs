00:00:11 <Phyx-> i assume ? and ?? mean abritary kinds can be use there?
00:00:24 <vixey> :k Int
00:00:25 <lambdabot> *
00:00:54 <dolio> No. GHC's kind system has subkinding.
00:01:30 <pumpkin> so how does @kind (->) give ?
00:02:04 <dolio> * is the kind of normal types, # is unboxed types, (#) is unboxed tuples, ?? is a superkind of * and #, and ? is a superkind of ?? and (#).
00:02:12 <Phyx-> Ah
00:02:33 <Phyx-> makes sense
00:03:18 <Phyx-> but then, why isn't the kind of (->)  ? -> ? -> * , that part still eludes me atm
00:03:40 <dolio> Unboxed tuples can only be returned from functions, not passed in.
00:03:40 <QtPlaty[HireMe]> What is a superkind?
00:04:23 <Phyx-> ah ok
00:04:30 <Phyx-> that explains it
00:05:18 <dolio> QtPlaty[HireMe]: Like subtype/supertype, but with kinds.
00:08:04 <Gracenotes> <$>
00:08:39 <QtPlaty[HireMe]> Ah
00:12:41 <mmorrow> top
00:12:46 <mmorrow> heh
00:13:53 <dobblego> "those pure functional programming languages still suffer the problem of actually doing something" <-- how do you combat this?
00:14:12 <Phyx-> lol
00:16:00 <sjanssen> actually, responding "lol" is not such a bad idea
00:16:58 <QtPlaty[HireMe]> dobblego: Who made such a comment?
00:17:10 * sjanssen bets it was a troll on reddit
00:17:53 <mc__> I have this  newtype declaration: newtype Collatz = Collatz (Int,Int)                     deriving(Show), how can I acces one of the integers stored in the Collatz tuple? I tried it with snd/fst but that does not work, because they expect (a,b) and not Collatz
00:18:23 <sjanssen> mc__: you have to pattern match on it: case foo of Collatz (a, _) -> a
00:18:56 <sjanssen> or, using the record trick: newtype Collatz = Collatz { getCollatz :: (Int, Int) }; fst . getCollatz
00:19:15 <mc__> sjanssen: thanks, I'll try the former
00:19:34 <dobblego> QtPlaty[HireMe], a person on the telephone in a conference call
00:19:51 <dobblego> QtPlaty[HireMe], who was trying to sell us a programming language
00:20:16 <Phyx-> heh, programming language telemarketers?
00:20:30 <hydo_> "Called Visual Basic, or something."
00:20:39 <Phyx-> "Good evening sir, I'm calling to sell go o++, the new hip programming language "
00:20:44 <dobblego> no I work from home -- they were at my place of employment (full of people who think Java is enterprise ready)
00:21:15 <Phyx-> i hope oracle takes java back to the drawing board and redesigns it. it needs it
00:21:17 <QtPlaty[HireMe]> dobblego: What programing language?  Personally I would never trust a programing languge that had to be sold.
00:21:23 <Phyx-> too many hacks in that language
00:21:29 <dobblego> QtPlaty[HireMe], Protium
00:21:41 <mc__> sjanssen: seems like I still dont really get it how to pattern match with custom types. this is what I tried.     (<) Collatz(a,b) Collatz(c,d) = b < d  , ghc says that the function only takes 2 not 4 arguments
00:21:44 <Gracenotes> @vixen I heard you avoid Visual Basic
00:21:44 <lambdabot> Can you really catch syphilis from Visual Basic?
00:21:49 <Elly> I hope oracle takes java back to the drawing board and leaves it there
00:22:19 <sjanssen> mc__: you need parens around (Collatz (a, b))
00:22:33 <mc__> sjanssen: tried that already
00:22:45 <Phyx-> Elly, i was trying to be nice :P
00:22:59 <Elly> Phyx-: waste of energy :)
00:23:02 <sjanssen> mc__: also around the latter
00:23:04 <Phyx-> sjanssen, around both of them
00:23:35 <Gracenotes> Java is good, for what it is
00:23:52 <Phyx-> Elly, lol. I'll say this though, tje java2d devs are friendly... helped me work around some bugs
00:23:53 <mc__> sjanssen: ah, of course, the error which remained had nothing to do with pattern matching but it was ghc complaining about collatz not implementing Eq, should have read that more carfully, thanks for your help again, its working.
00:23:57 * QtPlaty[HireMe] reads the first paragraph of the blurb "It is spiking my snake oil meter"
00:24:05 <sjanssen> dobblego: I just looked at the wikipedia page and understand only half the terms
00:24:27 <dobblego> sjanssen, my suspicions are aroused as well
00:24:51 <dolio> It's polymorphic in type, whatever that means.
00:25:03 <sjanssen> dobblego: the main point seems to be symbols rather than words, language independence?
00:25:09 <sjanssen> both uninteresting problems, IMO
00:25:12 <Phyx-> oh cool, so a language based on statistical modeling?
00:25:15 <dobblego> sjanssen, yes it seems so to me too
00:25:22 <sjanssen> dolio: with considerable character flexibility
00:25:33 <dolio> Yes. :)
00:25:37 <Phyx-> (wiki link i found was 3 lines)
00:25:38 <Phyx-> lol
00:28:17 <dolio> There isn't any code on the website.
00:28:22 <Phyx-> lol, i assume that "unpl" command isn't in ghc?
00:28:31 <Phyx-> ghci*
00:28:35 <dobblego> dolio, right I found getting meaningful information very difficult
00:29:16 <glguy> which website?
00:29:28 <dobblego> http://www.protiumblue.com/
00:29:30 <Gracenotes> @hackage pointfree
00:29:30 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
00:30:15 <Gracenotes> hm, that might only have the to-pointfree functions, not from-pointfree
00:30:18 <sjanssen> dobblego: there are numerous red flags that scream "Don't buy!"
00:30:18 <Phyx-> Gracenotes, ah cool, i was actually looking for the implementation. saves me the trouble
00:30:23 <QtPlaty[HireMe]> Yeah.  Lots of buzwords and boasts and nothing concreate.
00:30:28 <dobblego> sjanssen, thanks (I thought that too)
00:30:52 <Phyx-> Gracenotes, i only need to-pointfree. i'm looking to write an automatic haskell programs prover via induction
00:31:11 <Gracenotes> Phyx-: sure. note that they're hardly inverse functions.. pl uses quite a few idiomatic tricks...
00:31:35 * QtPlaty[HireMe] loves the "The first language that combines a runtime enviorment and an IDE" I thought that smalltalk did that.
00:31:47 <pumpkin> wow
00:31:53 <pumpkin> sounds like utter BS :P
00:32:13 <pumpkin> so their main selling point is supporting different human languages?
00:32:21 <QtPlaty[HireMe]> Yeah.
00:32:21 <Phyx-> Gracenotes, hmm ok, i'll have to see what it returns for my few testing functions
00:32:28 <Phyx-> wtf..
00:32:28 <Gracenotes> smalltalk is heug monolithic VM
00:32:47 * QtPlaty[HireMe] pulls the quote.
00:32:58 <Phyx-> that sounds.. so useless.. atm, even if i don't know greek, i can understand a greek programmer's code
00:33:09 <QtPlaty[HireMe]> 'Protium is a programming system for computers. It is a totally new paradigm in computing, a mixture of a programming language, a program development environment and a language interpreter runtime system.'
00:33:44 <dolio> Oh, wait, I was wrong. There is code.
00:33:52 <dolio> "<@ SAYLIT>Hello World</@>"
00:33:55 <sjanssen> dolio: oh, link?
00:34:04 <Phyx-> ...
00:34:09 <dolio> That's it.
00:34:25 <QtPlaty[HireMe]> dolio: And that fills me with concern.
00:34:27 <Gracenotes> XML -- not a substiute for s-exprs
00:34:39 <pumpkin> wow, protium is cool in the same way brainfuck is!
00:34:44 <pumpkin> no language-specific anything!
00:34:53 <sjanssen> Gracenotes: bastardized XML-like is worse
00:34:58 <Phyx-> yeah, but brainfuck is kinda fun...
00:34:58 <Gracenotes> but is it Touring-complete?!?!
00:35:02 <Phyx-> in a ... crazy kinda way
00:35:22 * Gracenotes tours the country in his Churchmobile
00:35:30 <ordwidr> hi
00:35:38 <McManiaC> hey
00:35:41 <Gracenotes> (｀･ω･´)ゝ ＜ Welcome to ＃haskell
00:35:43 * ordwidr is still exploring haskell ...
00:35:55 <McManiaC> i just installed an update of ghc and got this message:
00:35:57 <McManiaC>     ==> All cabalized and yaourt-installed packages need to be reinstalled now.
00:35:57 <McManiaC>     ==> See /usr/share/haskell/ and ghc-pkg list --user for a tentative list of affected packages.
00:36:28 <McManiaC> how can i get them back, what do i have to do with ghc-pkg??
00:36:36 <ordwidr> say i have any list of Ord, e.g. ["a","b","c"] and I want all sublists of size n where the elements are of ascending order.
00:36:47 <ordwidr> i have diagperms n vs = nub $ filter (\x -> nub x == x) $ map sort $ (sequence . replicate n) $ vs
00:36:58 <ordwidr> but runtime is rather bad
00:37:10 <sjanssen> McManiaC: all Haskell libraries have to be rebuilt, how to do that is specific to your distro
00:37:22 <McManiaC> sjanssen: archlinux
00:39:53 <Phyx-> is {- # already reserved by haddock? i can't remember
00:44:45 <McManiaC> so how do i rebuilt those pkgs?
00:44:54 <McManiaC> ghc-pkg register base
00:44:59 <McManiaC> Reading package info from "base" ... ghc-pkg: base: openFile: does not exist (No such file or directory)
00:45:18 <McManiaC> ?
00:46:08 <xrfang> hi there, while I try "quit" in ghci, it says: <interactive>:1:0: Not in scope: `quit',  how can I quit the interactive shell? thanks!
00:46:32 <Phyx-> McManiaC, idk, tried cabal update && cabal upgrade maybe?
00:46:42 <McManiaC> xrfang: :q
00:46:54 <Phyx-> xrfang, because it tries to find a function named quit
00:47:00 <Phyx-> ghci commands start with :
00:47:15 <Phyx-> so :quit ot :q appreviated
00:47:23 <xrfang> thanks, I am reading the "yaht.pdf",  I tried this:
00:47:24 <ordwidr> what's wrong? ["abc","cde"]::[Char]
00:47:27 <xrfang> fac 1=1
00:47:28 <ordwidr> Couldn't match expected type `Char' against inferred type `[Char]'
00:47:36 <xrfang> fac n = n * fac (n - 1)
00:47:42 <xrfang> but that also does not work in ghci
00:47:52 <xrfang> <interactive>:1:6: parse error on input `='
00:47:55 <Phyx-> xrfang, because that's a multiline definition of of a function
00:47:56 <xrfang> this is the error message
00:48:01 <Phyx-> you need to make a .hs file
00:48:07 <Phyx-> and put that text in it
00:48:08 <xrfang> all right! thanks
00:48:11 <Phyx-> and load that file into ghci
00:48:18 <McManiaC> Phyx-: nope, still get "Could not find module `Network.Curl':" for example
00:48:25 <ordwidr> xrfang: in ghci you ned to do a "let fac 1 = 1"
00:48:41 <McManiaC> what a stupid "update" >.<
00:48:41 <xrfang> ok, now just started learning, hope Haskell is easier than erlang, or not more difficult :D thanks all
00:48:48 <Phyx-> ordwidr, that would only allow that first definition
00:48:56 <ordwidr> phxy?
00:49:07 <Phyx-> fac is pattern matched over 2 cases
00:49:13 <Phyx-> fac 1 = 1
00:49:20 <Phyx-> and fac n = n * fac (n - 1)
00:49:20 <ordwidr> phyx: I see, so the second def wins
00:49:27 <xrfang> this is funny:
00:49:28 <McManiaC> ordwidr: String == [Char], u have a list of Strings, so it would be [[Char]]
00:49:29 <ordwidr> Phyx-: and i get a stack overflow
00:49:32 <xrfang> Prelude> let fac 1=1
00:49:34 <xrfang> Prelude> let fac n = n * fac(n-1)
00:49:36 <xrfang> Prelude> fac 10
00:49:36 <Phyx-> you can't do that in ghci, it'll override the old one
00:49:37 <xrfang> *** Exception: stack overflow
00:49:40 <ordwidr> McManiaC: oh, I see
00:49:49 <Phyx-> xrfang, yes, like i said, you can't do that in ghci
00:49:54 <xrfang> haha same error, I will try in hs file
00:49:58 <Phyx-> you have to put the function definitions in a file
00:50:00 <vixey> you can do it in ghci
00:50:01 <Phyx-> and not lets there
00:50:06 <Phyx-> vixey, you can?
00:50:08 <vixey> let fac 1 = 1 ; fac n = n * fac(n-1)
00:50:10 <vixey> fac 10
00:50:20 <Phyx-> yeah, ok, but i consider that cheating!
00:50:21 <Phyx-> :P
00:50:25 <McManiaC> lol
00:50:25 <vixey> no
00:50:26 <xrfang> btw, I am using linux, and installed emacs haskell mode, how do I write haskell code in emacs? there seems no hint -- I am not an emacs user
00:50:53 <horms> presumably you need to know how to use emacs first
00:51:22 <Vq^> xrfang: try  M-x haskell-mode
00:51:27 <Phyx-> vixey, it's much like you can create read and modify mutable arrays in ghci, you can, but it's fugly
00:51:39 <vixey> wtf are you talking abotu
00:51:40 <xrfang> emacs is an editor, if it is too difficult I will  give up, I am pretty interested in leksah, but it is distributed in source...
00:52:04 <inimino> start with an emacs tutorial first
00:52:14 <inimino> xrfang: emacs is extremely powerful but there is a learning curve
00:52:23 <Phyx-> vixey, meh, i've been up since 6am, i'm allowed to ramble incoherently!
00:52:24 <Phyx-> :P
00:52:29 <vixey> ok
00:52:31 <xrfang> I executed haskell-mode, I will try it...
00:53:05 <xrfang> I am quite familiar with vim, if emacs is more difficult, then I think my learning power should focus on haskell not emacs ;) thanks inimino :)
00:53:32 <inimino> xrfang: there are vi compatibility modes for emacs
00:54:00 <xrfang> but then, how about haskell-specific feature? If I want vi mode, I just use vi ;)
00:54:12 <inimino> but I recommend learning either a new language or a new editor at once but not both
00:54:28 <vixey> emacs isn't hard you just typea
00:54:35 <vixey> then you need to know how to save
00:54:50 <Phyx-> is there a decent theorem prover written in haskell?
00:54:53 <osfameron> and hten you need to know how to get out of a) emacs, b) a buffer, c) a minibuffer, d) other confusing things ...
00:55:04 <inimino> xrfang: the idea is that you can get the nice keyboard shorcuts of vi as well as the features of emacs
00:55:05 <osfameron> vim is just a case of hitting ESC lots of times and then :q!
00:55:09 <xrfang> now programming the fib function in emacs, see if that can actually run :)
00:55:36 <xrfang> haha anybody tried leksah? the screenshot is very nice
00:55:45 <osfameron> I didn't find any of the vi compat modes for emacs very usable (last time I tried)
00:55:47 <Phyx-> @google site:hackage.haskell.org theorem prover
00:55:48 <lambdabot> http://hackage.haskell.org/packages/archive/pkg-list.html
00:55:48 <lambdabot> Title: HackageDB: packages by category
00:55:55 <Phyx-> lame
00:55:56 <Phyx-> lol
00:56:32 <vixey> what does theorem prover mean
00:56:32 <vixey> ?
00:56:36 <ordwidr> oh
00:56:40 <ordwidr> ghci segfaulted
00:57:12 <xrfang> test.hs:4:7:
00:57:14 <xrfang>     No instance for (Num (IO t))
00:57:15 <xrfang>       arising from a use of `fib' at test.hs:4:7-12
00:57:17 <xrfang>     Possible fix: add an instance declaration for (Num (IO t))
00:57:18 <xrfang>     In the expression: fib 10
00:57:20 <xrfang>     In the definition of `main': main = fib 10
00:57:20 <QtPlaty[HireMe]> vixey: Do you understand what a proof is in mathmatics?
00:57:21 <xrfang> what does that mean pls
00:57:22 <jedai> Phyx-: Agda ?
00:57:47 <Phyx-> vixey, i need a higher order logic or sequent calculus prover
00:58:18 <Phyx-> jedai, i'll look at that and pesca
00:58:51 <jedai> xrfang: fib 10 is a number (a type of the Num typeclass), and main type is IO a, IO a is not an instance of Num
00:59:07 <xrfang> I just wrote, main = fib 10
00:59:23 <xrfang> now I tried: main = putStrLn (fib 10)
00:59:25 <jedai> xrfang: in other word, main must do I/O, and fib 10 don't do I/O
00:59:26 <xrfang> but still cannot compile
00:59:48 <jedai> xrfang: putStrLn takes a String as an argument, a String is not a number
00:59:51 <xrfang> I might be a little bit too fast in the tutorial, but since ghci does not work, I have to use main function...
00:59:54 <xrfang> ok
01:00:00 <xrfang> I guessed that...
01:00:03 <jedai> xrfang:  main = print (fib 10)
01:00:41 <Phyx-> xrfang, ghci works
01:00:43 <Phyx-> just do
01:00:46 <Phyx-> ghci test
01:00:53 <vixey> Phyx-: there's Ivor
01:01:08 <vixey> if you can get it to build ...
01:01:10 <xrfang> I did this: main = putStrLn(show(fib 10))
01:01:12 <xrfang> which worked...
01:01:24 <xrfang> I wonder, how can I read the number from command line ;)
01:01:25 <jedai> xrfang: this will work because print take anything of the Show typeclass as argument and fib 10 type will default to Int (or Integer whatever) which is an instance of Show like most of the basic types
01:01:42 <xrfang> ok, jedai, thanks, I don't know print until you told me
01:02:06 <jedai> xrfang: print x = putStrLn (show x)
01:02:29 <jedai> xrfang: Why do you say that ghci don't work ?
01:02:46 <Phyx-> vixey, hmm, i see hackage says ivor and pesca are provers, i'll try em both see which i can better use to build on
01:02:53 <xrfang> well I just asked, if I write fac 1=1, it gives me error, I must write let fac 1=1...
01:02:55 <jedai> xrfang: I never saw a case where ghci didn't work but ghc did
01:03:04 <wli> main = putStrLn . show . fib . read =<< getArgs
01:03:16 <jedai> xrfang: yes, but I wouldn't qualify that as "not working"
01:03:20 <Phyx-> xrfang, type ghci test
01:03:25 <zoheb> @t getArgs
01:03:25 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
01:03:35 <Phyx-> if you're in the same folder as the file test.hs
01:03:38 <xrfang> jedai, if I write 2 fib function the second will over write the first, and somve one above said to use ; to connect 2 def in oneline.
01:03:39 <Phyx-> that will load it up in ghci
01:03:40 <xrfang> :)
01:03:47 <vixey> Phyx-: what do you provthereoms for?
01:03:50 <zoheb> @type getArgs
01:03:52 <lambdabot> Not in scope: `getArgs'
01:04:11 <xrfang> read =<<... that's quite strange! I mean "=<<", not yet see that in the yaht.pdf file :D
01:05:07 <xrfang> ok, and masters, the reason that I am looking for a good ide is that I see that haskell is quite strict on indentation, like python, which I don't like, I hope the ide can help me layout source file automatically.
01:05:16 <jedai> xrfang: So ? If you're more confortable with the normal syntax, write your definition in a .hs file and load that in ghci, then play with the functions, it's much easier than writing a main and recompiling every time you want to test something else
01:05:38 <wli> @type let fib n = let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!n in print . fib . read =<< System.Environment.getArgs
01:05:39 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
01:05:40 <lambdabot>       Expected type: IO String
01:05:40 <lambdabot>       Inferred type: IO [String]
01:05:45 <xrfang> ok, jedai, thanks, I just got that idea...
01:05:56 <Phyx-> vixey, well, i'm board, so i'm trying to create something that i can say which given a proof t construct, will try via Equational Reasoning, and I thought i might be able to specify reduction rules for things like id in a prover, and have it solve it. given enough informaiton
01:06:02 <wli> @type let fib n = let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !!n in mapM_ (print . fib . read) =<< System.Environment.getArgs
01:06:03 <lambdabot> IO ()
01:06:33 <vixey> what!!
01:06:35 <jedai> xrfang: if you're accustomed to vim, there's a good haskell mode for vim apparently
01:06:42 <wli> putStrLn . show is just print
01:06:56 <wli> import System.Environment
01:07:01 <vixey> like turning reverse . reverse back into id?
01:07:07 <wli> main = mapM_ (print . fib . read) =<< getArgs
01:08:08 <xrfang> wli, you are too advanced ;) I just read about the "."... but I dont' know what is "mapM_".
01:08:30 <Phyx-> vixey, among others, I'll need to have a big set of properties about build in functions, since i can't inspect the code of those at compile time, (well i can, but would be slow)
01:08:33 <wli> print . fib . read is \x -> print (fib (read x))
01:09:28 <inimino> xrfang: since the layout is significant, the editor can't entirely determine it for you, instead you will learn the layout rule
01:09:57 <xrfang> ok...
01:10:31 <Phyx-> vixey, why, do you think the idea is impossible to make?
01:10:36 <vixey> no
01:12:47 <Phyx-> vixey, cool :) I'm just bored, so doing something productive to pass the time
01:12:48 <Phyx-> lol
01:13:09 <Phyx-> (re)building my haskell parser now to take the syntax
01:13:24 <wli> I'm just getting a cig and a few minutes of Sweeney Todd in before going back to bed.
01:15:35 <vixey> I did an equational reasoning assistant in prolog once
01:16:43 <Phyx-> ah, cool, i've never tried prolog
01:17:02 <Phyx-> come to think of it... for the past year i've been predominantly using haskell..
01:17:10 <wli> Prolog is okay now and then, but mostly I use Mercury when I want logic programming.
01:17:16 <mlesniak> I have a program which forks 1(!) thread (as the minimal case in which it should work). It works correct with +RTS -N1 but delivers wrong results with +RTS -N2. I'm a bit perplexed. Since I only use one thread shouldn't the other native thread be idle?
01:18:09 <quicksilver> mlesniak: "wrong" results?
01:18:18 <quicksilver> mlesniak: you may have to give us a little more information.
01:18:25 <quicksilver> if you fork once, you have two threads, I would think.
01:19:07 <mlesniak> quicksilver: Yes, I have an additional sequential testing implementation. Ok, if I fork once, I have two (right :-)). But the main thread does nothing then putMVar which is consumed by the forked one
01:19:25 <mlesniak> quicksilver: Using the test implementation I know if my parallel version works correct or not.
01:19:42 <sjanssen> mlesniak: I think we need to see some code
01:20:22 <quicksilver> mlesniak: you're really not giving me any information to work on :) My theory so far is that you are wrong about what "correct" means, and the RTS works fine ;)
01:20:34 <quicksilver> the burden of proof is on you to explain why the behaviour you are seeing is wrong.
01:20:39 <mlesniak> sjanssen: Hmmm, you're probably right. Will take some time to throw out the unnecessary parts. Just thought someone recognizes this problem as a "hey, had this too"
01:21:10 <sjanssen> mlesniak: what does the main thread do after putMVar?
01:21:13 <quicksilver> certainly there are programs which behave differently under -N1 and -N2
01:21:15 <mlesniak> quicksilver: Gnaah, I know that. The fact that the GHC and its RTS is so good that I can't blame them for my lousy coding ;-)
01:21:28 <sjanssen> note that if it exits, the whole program will exit
01:21:37 <mlesniak> sjanssen: Putting the next mvar on, just a second, I'll try to hpaste the necessary parts.
01:21:42 <mlesniak> sjanssen: Yes, I know
01:23:17 <mlesniak> The probably important part of my code are at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2183#a2183
01:23:58 <mlesniak> chunks is of type [[(Int, Int]]
01:27:00 <Phyx-> Berengal, pointfree is rather inconsistent
01:27:05 <Phyx-> PS > pointfree "map (+x) []"      == []
01:27:05 <Phyx-> PS > pointfree "map (+x) [6,8,9]" == map (x +) [6, 8, 9]
01:27:05 <Phyx-> PS > pointfree "map (+x) [6,8]"   == [6 + x, 8 + x]
01:28:02 <quicksilver> mlesniak: and what is the difference in behaviour between -N1 and -N2
01:29:26 <mlesniak> quicksilver: Using -N1 my program delivers the same results as the sequential test version, using -N2 there are incorrect results (which I have to take a closer look I know). My first thought was that I overlook something quite trivial. If it's not I have to examine the wrong result more deeply.
01:29:48 <mlesniak> It just seems a bit "strange" if you understand what I mean
01:29:59 <mlesniak> Using -N2 should do no harm
01:30:17 <quicksilver> it can cause things to happen in a different order
01:30:30 <sjanssen> mlesniak: do you use numCapabilities from GHC.Conc?
01:30:47 <mlesniak> sjanssen: No, I use a manually defined parameter
01:30:59 <sjanssen> mlesniak: what does distributeTasks do?
01:32:23 <mlesniak> It splits [[(Int, Int]], e.g. [[(1,1), (2,2)], [(3,4)]] such that first all "tasks" from 1,1 and 2,2 are worked on, than the next sublist. Using this to solve kind of diagonal parallelization in an array (cost and dirs are arrays)
01:32:56 <mlesniak> AFAIK there's no usable parallel debugger for GHC atm?
01:33:39 <mlesniak> I'd even take a non-usable one ;-) With -N2 the wrong result just occurs sometimes, making debugging quite enjoying...
01:34:49 <sjanssen> mlesniak: is there any other communication between threads?
01:35:11 <sjanssen> does 'work' write to any MVars?
01:35:13 <mlesniak> sjanssen: No. Just using the mvar to put new tasks from the main thread to the worker one
01:35:37 <sjanssen> mlesniak: so what does work do?
01:36:25 <mlesniak> sjanssen: Reading from the arrays cost, calculating something depending on the task (Int, Int) and writing to cost and dir arrays.
01:36:48 <quicksilver> concurrent array access is not safe.
01:36:54 <sjanssen> yep, there we go
01:36:58 <quicksilver> at least, I've not seen anyone guarantee it is.
01:37:18 <quicksilver> hide your arrays inside an mvar (for synchronisation)
01:37:45 <mlesniak> quicksilver: but with only one thread calling work there is no concurrent access. and the gc halts all threads afaik
01:38:28 <sjanssen> mlesniak: but there will be multiple threads concurrently calling work
01:38:29 <mlesniak> If I have more threads I'm going to use STM on the single cells, i.e. Concurrent...TArray
01:38:54 <sjanssen> unless the 'threads' argument to 'master' is 1?
01:39:09 <mlesniak> sjanssen: which it is at the moment leading to the error with -N2
01:39:51 <sjanssen> I think I see the problem
01:39:53 <mlesniak> I mean: currently this approach is not safe for multiple threads, but with only one thread working on the array it *should* (tm) just work
01:40:12 * mlesniak is very curious ;)
01:40:30 <sjanssen> 'master' exits when it has sent the termination signal of (-1, -1) to N times
01:40:45 <sjanssen> but one thread may still be working after that
01:41:36 <ezero> anyone know what I might be doing wrong (trying to implement a ADT Map using lists (k,v))
01:41:37 <ezero> add (Mymap map) k v = Mymap ((k,v) : map)
01:41:46 <ezero> its not adding it :( map remains empty
01:41:55 <mlesniak> sjanssen: Hmmm, I'll think about this.
01:43:21 <sjanssen> mlesniak: more specifically, your worker thread is stuck somewhere between 'work' and its final takeMVar, and the master thread has returned from 'master' and moved on to other code
01:44:21 <mlesniak> sjanssen: Hmm, but why does the errernous behaviour then just occur with -N2 and not -N1?
01:44:41 <sjanssen> mlesniak: the scheduler works just a bit differently between the two modes
01:44:52 <mlesniak> sjanssen: Ah, ok. That seems reasonable.
01:45:17 <sjanssen> mlesniak: this is classic race condition behavior, slight tweaks will expose or hide the problem
01:45:46 <mlesniak> sjanssen: Maybe I'm totally blind atm but is there any easy fix for this?
01:46:24 <quicksilver> make the master wait for all slaves to actually finish
01:46:27 <quicksilver> before it carries on.
01:46:29 <sjanssen> mlesniak: have the workers write to a "finished" variable and have the master read it N times
01:46:41 <mlesniak> quicksilver: sjanssen Argh! Yes, of course.
01:46:55 <mlesniak> Thanks for your help! I really appreciate it!
01:46:56 <doserj> ezero: how do you check whether it is empty?
01:47:08 <ezero> there is an isEmptyMap function
01:47:15 <ezero> isEmptyMap :: Map k v -> Bool
01:47:29 <ezero> emptyMap = Mymap []
01:47:35 <ezero> that creates a emptyMap
01:47:51 <ezero> here is "my map" newtype Map k v = Mymap [(k,v)] deriving (Eq, Show)
01:47:56 <doserj> so, "isEmptyMap (add emptyMap k v)" returns true?
01:48:03 <ezero> yes
01:48:40 <doserj> how is isEmptyMap defined?
01:48:49 <ezero> isEmptyMap (Mymap []) = True
01:48:49 <ezero> isEmptyMap (Mymap map) = False
01:49:24 <ezero> hmm that should be Mymap[(null,null)] ?
01:50:09 <ezero> no i think i did it right, that should say its an emptyMap
01:51:18 <quicksilver> ezero: that looks fine to me.
01:51:39 <ezero> yeah seems to work
01:51:40 <ezero> *Map> add ma "key1" "value1"
01:51:40 <ezero> Mymap [("key1","value1")]
01:51:48 <ordwidr> how can I get the cross product of two lists? [1,2,3]x[2,3] -> [[1,2],[1,3],[2,2],[2,3]...
01:52:12 <ezero> let ma = emptyMap  gives *Map> ma
01:52:13 <ezero> Mymap []
01:53:22 <ezero> ordwidr you want cartesian cordinates
01:53:37 <wjt> > [(x,y)| x<-[1,2,3], y <- [5,6]]
01:53:39 <lambdabot>   [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)]
01:53:42 <ordwidr> ezero: eh, yes
01:54:00 <mlesniak> sjanssen: quicksilver: Now it works. Thanks again :)
01:54:03 <ezero> wjt bet me to it :(
01:54:07 <wjt> > pure (,) <$> [1,2,3] <*> [5,6]
01:54:08 <lambdabot>       Ambiguous occurrence `pure'
01:54:08 <lambdabot>      It could refer to either `Control.Appl...
01:54:12 <wjt> >  (,) <$> [1,2,3] <*> [5,6]
01:54:13 <lambdabot>   [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)]
01:54:27 <wjt> > liftM2 (,) [1,2,3] [5,6]
01:54:28 <wjt> etc. etc.
01:54:28 <lambdabot>   [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)]
01:54:34 <ordwidr> wjt: ok, so far good. but when I have n lists: [[1,2],[2,3,4],[5,6,9]] -> [[1,2,5],[1,2,6]...[2,4,9]]
01:54:44 <doserj> > sequence [[1,2,3],[2,3]]
01:54:46 <lambdabot>   [[1,2],[1,3],[2,2],[2,3],[3,2],[3,3]]
01:54:46 <ezero> so many ways to do it lol i would ahve done it like he did first using an anonymous function
01:54:58 <ordwidr> ah, famous sequence
01:55:07 <ezero> although it gets tricky with infinite lists :P
01:56:26 <ezero> strange tho when i print out my map variable
01:56:28 <ezero> it says it empty
01:56:29 <ezero> *Map> ma
01:56:29 <ezero> Mymap []
01:56:53 <ezero> ah i might have to go
01:57:02 <ezero> ma = add ma "key1" "value1"
01:57:23 <doserj> ma' =  add ma "key1" "value1"
01:57:37 <wjt> ezero: ma = add ma "key1" "value1" does not do what you mean
01:57:49 <xrfang> hello, what is the problem with the code below:
01:57:54 <xrfang> rev [] = []
01:57:56 <xrfang> rev (x:xs) = rev(xs) ++ x
01:58:00 <xrfang> rev is a function to reverse a list...
01:58:05 <ezero> yes wjt that made an infinite map list lol
01:58:22 <quicksilver> xrfang: ++ joins two lists together
01:58:26 <quicksilver> xrfang: x is not a list.
01:58:36 <xrfang> ok, quicksilver: I will try again...
01:58:51 <ezero> let m = add m "key1" "value1"
01:58:55 <ezero> that added it but infinitely
01:59:18 <xrfang> yes that worked, thanks quicksilver
01:59:40 <ezero> *Map> isEmptyMap m
01:59:40 <ezero> False
02:00:16 <xrfang> there is a basic question
02:00:26 <xrfang> rev [] = [], wich is clear
02:00:31 <xrfang> but rev (x:xs) = ...
02:00:37 <xrfang> here I have a question about syntax
02:00:49 <xrfang> I tried rev x:xs without the (), then compiler report error
02:00:49 <ezero> why did it do it infinitely so many times? im not even using recursion in my add function
02:01:02 <xrfang> why I need to use () here, the rule is?
02:01:02 <ezero> yeah wouldn't rev [] = [] be clear?
02:01:09 <quicksilver> xrfang: "rev x:xs" is parsed as "(rev x) : (xs)"
02:01:13 <doserj> ezero: you are recursing in the let statement
02:01:25 <quicksilver> xrfang: makes it look like you're trying to define the operator ":" instead of the function "rev"
02:01:28 <ezero> add (Mymap map) k v = Mymap ((k,v) : map) ?
02:01:30 <xrfang> ok, so if I write x:xs, then xs is parsed as a list
02:01:36 <daf> the rule is that function application has higher precedence than infix operators
02:01:39 <xrfang> i.e. I can write x:ys or x:something
02:01:53 <xrfang> but not just x:xs or y:ys  right? xs is just var name...?
02:01:55 <doserj> ezero: let m = add m ... the m on the left is the same as the m on the right
02:02:03 <ezero> ah yes
02:02:04 <ezero> dam it
02:02:09 <QtPlaty[HireMe]> xrfang: The type of xs is infered to be a list of the same type as x
02:02:18 <ezero> so stupid
02:02:59 <xrfang> strange, this does not load in ghci:
02:03:01 <xrfang> rev x:ys = rev(ys) ++ [x]
02:03:08 <xrfang> so I must write x:xs?
02:03:26 <quicksilver> xrfang: no, you must put () round it
02:03:27 <ezero> sweet
02:03:27 <ezero> *Map> let m' = add m "key1" "value1"
02:03:27 <ezero> *Map> m'
02:03:27 <ezero> Mymap [("key1","value1")]
02:03:31 <quicksilver> xrfang: it doesn't matter what it's called.
02:03:50 <quicksilver> xrfang: rev x:ys will be parsed as "(rev x) : (ys)"
02:03:55 <xrfang> while I try :reload, it says test.hs:2:0 Parse error in pattern
02:03:58 <quicksilver> xrfang: again, that looks like you are defining the operator ":"
02:04:03 <xrfang> oh sorry I will check
02:04:12 <quicksilver> xrfang: You still need rev (x:ys)
02:04:22 <quicksilver> the names of the variables are totally irrelevant, by the way
02:04:31 <xrfang> my mistake I still forgot the ()
02:04:33 <quicksilver> rev (xs:truth) will work as well
02:04:34 <xrfang> thanks
02:04:39 <ordwidr> how many map must one nest to get insance
02:04:42 <quicksilver> and "xs" will be one element and "truth" will be the list.
02:04:43 <ordwidr> insane
02:04:53 <xrfang> right
02:05:14 <ezero> do i have to create a new variable everytime?
02:05:31 <ezero> it doesn't seem to retain the preivous result in the map
02:05:39 <ezero> *Map> add m' "key2" "value2"
02:05:39 <ezero> Mymap [("key2","value2"),("key1","value1")]
02:05:39 <ezero> *Map> m'
02:05:39 <ezero> Mymap [("key1","value1")]
02:05:55 <wjt> ezero: values in Haskell are immutable
02:06:37 <wjt> your 'add' function takes a map, a key, and a value, and returns a *new* map which has the items from the old map plus the new entry
02:07:36 <ezero> yes
02:08:10 <ezero> which is correct
02:08:46 <ezero> but when i print the variable holding that new map its lost the new entry is it because its new map everytime
02:15:52 <mmorrow> ezero: you're discarding the new map
02:16:04 <mmorrow> let m'' = add m' "key2" "value2"
02:16:36 <ezero> yea
02:16:44 <ezero> i need to rethink my logic
02:17:08 <ezero> some way to remember the "old map" inside the program
02:18:19 <mmorrow> > foldl' (\m (k,v) -> Map.insertWith' (++) k [v] m) Map.empty (take 10 (cycle (zip [0..] ['a'..'z'])))
02:18:20 <lambdabot>   fromList [(0,"a"),(1,"b"),(2,"c"),(3,"d"),(4,"e"),(5,"f"),(6,"g"),(7,"h"),(...
02:18:43 <mmorrow> > foldl' (\m (k,v) -> Map.insertWith' (++) k [v] m) Map.empty (take 10 (cycle (zip [0..4] ['a'..'z'])))
02:18:44 <lambdabot>   fromList [(0,"aa"),(1,"bb"),(2,"cc"),(3,"dd"),(4,"ee")]
02:18:53 <ezero> what does insertWith do ?
02:19:04 <mmorrow> it inserts with a combining function
02:19:06 <ezero> i am trying to implement my own Map
02:19:25 <ezero> so i dont have to use any of the haskell map
02:19:34 <mmorrow> which is nice, if you're inserting a (k,v) pair and there's already an entry with that key
02:20:07 <mmorrow> > Map.insertWith (++) 1 [42] (Map.fromList [(1,[99])])
02:20:08 <lambdabot>   fromList [(1,[42,99])]
02:20:12 <ezero> i will have to implement my own insertWith then :(
02:20:59 <mmorrow> ezero: if you're doing it "just for kicks", then by all means :), but you'd probably have to work pretty hard to get your map to approach the performance of Data.Map
02:20:59 <ezero> which checks for keys if its already in the map then just replace the value
02:21:14 <mmorrow> (and'd have to work 20x as hard to approach the perf of IntMap)
02:21:21 <ezero> yeah just the kicks .. im not looking for performance here :P just want to hack something up
02:21:28 <mmorrow> cool :)
02:22:06 <QtPlaty[HireMe]> > Map.insertWith (:) 1 42 (Map.formList [(1,[99])])
02:22:06 <lambdabot>       Failed to load interface for `Map':
02:22:07 <lambdabot>        Use -v to see a list of the ...
02:22:38 <mmorrow> form
02:23:11 <mmorrow>  Map.insertWith (:) 1 42 (Map.fromList [(1,[99])])
02:23:16 <mmorrow> > Map.insertWith (:) 1 42 (Map.fromList [(1,[99])])
02:23:17 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
02:23:18 <lambdabot>        Expect...
02:23:29 <mmorrow> > Map.insertWith (flip (:)) 1 42 (Map.fromList [(1,[99])])
02:23:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
02:23:30 <lambdabot>        Expect...
02:23:48 <mmorrow> um
02:23:54 <mmorrow> oh
02:24:12 <mmorrow> :: (a -> a -> a) -> k -> a -> Map k a -> Map k a
02:24:39 <ezero> yes i found an implementation of insertWith
02:24:41 <ezero> nsertWith :: Eq a => (b -> b -> b) -> a -> b -> Map a b -> Map a b
02:25:00 <ezero> i dont realy understand it so ill do my own
02:25:01 <ezero> http://www.cs.dartmouth.edu/~cs8/W2009/lectures/ADT_Map.txt
02:25:30 <xrfang> what is the "let" keyword doing?
02:25:33 <xrfang> by writing let guessNum = read guess
02:25:38 <xrfang> and guessNum = read guess
02:25:43 <xrfang> is it doing same thing?
02:28:06 <ivanm> xrfang: what in?
02:28:15 <Vq^> xrfang: are you talking about 'let' in the ghci shell?
02:28:29 <xrfang> no I am talking about a regular program
02:28:37 <xrfang> I am key in some sample program to test
02:28:46 <ivanm> xrfang: let creates a temporary variable/function inside another function
02:28:54 <xrfang> oh
02:29:15 <aleator> Is there some special magic to collecting foreignPtrs? I don't think I'm holding on to any references, but it still allocates all my memory and still doesn't finalize them until I quit the program.
02:29:26 <Vq^> guessNum = read guess  -- is a declaration
02:29:40 <Vq^> let guessNum = read guess in blah  -- is an expression
02:29:48 <mmorrow> i find it funny that all (well, 99% of) the people who are "for" longer line-length refuse to put any line breaks in their email messages :)
02:29:57 <mmorrow> (re: the haskell-cafe thread)
02:30:11 <mmorrow> it's probably because they're on windows though..
02:30:18 <ezero> Is this correct?
02:30:18 <ezero> insertWith ::  Eq a => (b -> b -> b) -> a -> b ->  Map a b ->  Map a b
02:30:18 <ezero> insertWith _ k v [] = [(k,v)]
02:30:37 <xrfang> but the problem is, it is already within a function, if I do not use "let" the variable should be still be "local" to the function, right?
02:30:38 <ezero> that returns type [a1] whereas its expecting to be a Map
02:31:09 <mmorrow> ezero: err, what is the def of "Map", and what about the other case?
02:31:10 <Vq^> ezero: i think you answered your own question :)
02:31:28 <ezero> yeah lol
02:31:48 <mmorrow> (of course, that would be correct if (type Map a b = [(a,b)]))
02:32:49 <ezero> ah they are using the haskell map
02:32:50 <ezero>  import qualified Data.Map as Map
02:33:28 <ezero> my type of Map is [(k,v)]
02:33:32 <ezero> newtype Map k v = Mymap [(k,v)] deriving (Eq, Show)
02:34:26 <ezero> i should look at how they implemented maps in haskell :D
02:34:47 <mmorrow> insertWith _ k v (Mymap []) = Mymap [(k,v)]
02:35:21 <mmorrow> type Foo a = a
02:35:30 <mmorrow> ==> 42 :: Foo Int
02:35:34 <mmorrow> ==> 42 :: Int
02:35:38 <mmorrow> newtype Foo a = a
02:35:43 <mmorrow> ==> Foo 42 :: Foo Int
02:35:45 <mmorrow> ==> 42 :: Int
02:36:58 <mmorrow> oops
02:37:02 <mmorrow> newtype Foo a = Foo a
02:37:07 <mmorrow> ==> Foo 42 :: Foo Int
02:37:11 <ezero> lol
02:37:12 <mmorrow> heh
02:37:16 <ezero> insertWith f k v (p@(k1, v1) : rest)
02:37:21 <ezero> what is @ ?
02:37:37 <ezero> > :t @
02:37:38 <lambdabot>   <no location info>: parse error on input `:'
02:37:39 <Ferdirand> alias match
02:37:42 <mmorrow> , let f a@(x,_) = (a,x) in f (0,1)
02:37:43 <lunabot>  ((0,1),0)
02:38:12 <mmorrow> , let f a@(x,b@(_,z)) = (a,b,x,z) in f (0,(1,2))
02:38:14 <lunabot>  ((0,(1,2)),(1,2),0,2)
02:38:37 <ezero> so that case it alias matches the keys
02:38:39 <ezero> cool
02:38:40 <mmorrow> , let f a@_ = a in f 0
02:38:41 <lunabot>  0
02:39:02 <mmorrow> it binds (k1,v1) to p
02:39:26 <mmorrow> while at the same time binding pieces of p to k1 and v1
02:39:47 <mmorrow> err, that may be a confusing way to say that, but you know
02:40:16 <ezero> i can't do this
02:40:18 <ezero> insertWith f k v (Mymap p@[(k1, v1)] : rest)
02:40:32 <xrfang> strange. in that function if I remove the "let" keyword, it does not compile!
02:41:43 <mmorrow> insertWith f k v (Mymap (p@[(k1, v1)] : rest))
02:42:08 <xrfang> test.hs:16:11: parse error on input `='
02:42:22 <mmorrow> xrfang: that seems to happen in C if you get rid of "while" in while loops too ;)
02:42:23 <xrfang> test.hs:16:11: parse error on input `='
02:42:42 <xrfang> ?? I don't understand, let me copy a portion of the code here
02:42:42 <lambdabot>  I don't understand, let me copy a portion of the code here
02:42:51 <xrfang> doGuessing num = do
02:42:52 <xrfang>   putStrLn "Enter your guess:"
02:42:54 <xrfang>   guess <- getLine
02:42:55 <xrfang>   guessNum = read guess
02:42:57 <xrfang>   if guessNum < num
02:43:03 <xrfang> the guessNum = read guess line is reporting the error
02:43:05 <mmorrow>   let guessNum = read guess
02:43:13 <xrfang> the original code is let guessNum = read guess
02:43:18 <xrfang> I know, but *why*
02:43:37 <mmorrow> because (guessNum = read guess) has no type
02:43:48 <mmorrow> it's not even valid syntax
02:44:08 <ezero> that alias match won't work
02:44:12 <ezero> Couldn't match expected type `(a, b)' against inferred type `[a1]'
02:44:17 <ezero> because rest is a type [a1]
02:44:20 <xrfang> no type??
02:44:24 <mmorrow> ezero: oh, oops yeah i missed that
02:44:31 <mmorrow> insertWith f k v (Mymap (p@(k1, v1) : rest))
02:44:42 <ezero> so yeah Mymap will go on the whole thing
02:44:55 <xrfang> mmorrow: I see syntax like fac x = x * fax (x - 1), which is function definition
02:44:57 <mmorrow> xrfang: so each line in a "do" block (say the monad is IO), is either:
02:45:04 <mmorrow> xrfang: exactly
02:45:07 <xrfang> but if I assine a number, I need to use let??
02:45:13 <mmorrow> there is no assignment
02:45:24 <mmorrow> you can bind values to identifiers with "let"
02:45:25 <xrfang> indeed it is in a do block,
02:45:34 <mmorrow> or in a do, with "let" or "<-"
02:46:01 <xrfang> ok, but if I am writing a line of code without do or what so ever, can I write a=1?
02:46:07 <xrfang> or I must write let a = 1?
02:46:21 <quicksilver> xrfang: "line of code" is not clear enough
02:46:26 <mmorrow> xrfang: if it's a top-level definition, or you're already in a "let" (or "where"), then yes
02:46:29 <quicksilver> there are (a) definitions, like at the top of a file
02:46:34 <quicksilver> (b) expressions
02:46:36 <quicksilver> (c) do-blocks.
02:47:11 <xrfang> a line of code, means, I open ghci, without loading any file
02:47:13 <quicksilver> defintions look like "a = b "
02:47:15 <xrfang> just type a = 1
02:47:18 <mmorrow> xrfang: if you do "let a = 1", then 'a' will always be 1
02:47:38 <mmorrow> xrfang: in ghci, you're "in an IO do-block"
02:47:44 <xrfang> oops
02:47:47 <quicksilver> well, not examctly.
02:47:52 <quicksilver> ghci you're either typing expressions
02:47:54 <xrfang> without let, it does not work
02:47:57 <quicksilver> like "1 + 1"
02:48:01 <mmorrow> quicksilver: ah, yes
02:48:01 <quicksilver> or you're in a do-block
02:48:07 <quicksilver> like "let a = 1"
02:48:13 <xrfang> so I *MUST* use let to do an "assignment" or "binding" in haskell, right?
02:48:16 <quicksilver> or indeed "putStrLn "hello""
02:48:21 <quicksilver> xrfang: no.
02:48:22 <mmorrow> +augmented IO do-block
02:48:34 <quicksilver> xrfang: a top-level definition is just like this "a = 1"
02:48:46 <quicksilver> xrfang: you can also have local definitions inside expressions
02:48:51 <quicksilver> they are introducted by 'let'
02:48:58 <quicksilver> and ended by 'in'.
02:49:05 <quicksilver> and you can have local definitions inside a do-block
02:49:12 <quicksilver> those are introduced by 'let' and ended by the ended of the line.
02:49:12 <xrfang> ok, in a function I need to use let, but top-level, I don't need let, right?
02:49:29 <quicksilver> in an expression you use "let .... in"
02:49:43 <quicksilver> an a do-block you use "let ... <ENDOFLINE>"
02:49:46 <quicksilver> (no 'in')
02:49:49 <xrfang> however, the line of code I am reading, it does not include an *in*.
02:49:54 <mmorrow> xrfang: one way to maybe think about it, is to imagine a haskell function as similar to a C function, that's ==> foo(..){return (..everything here..);}
02:50:00 <quicksilver> it's probaby in a do-block then
02:50:35 <xrfang> yes it is in a function called by the do block of "main".
02:50:39 <ezero> mmorrow : will this | otherwise = p : insertWith f k v rest change to | otherwise = p : insertWith f k v Mymap(rest) but it still gives wrong return type
02:50:44 <xrfang> the function itself is a do block
02:51:10 <mmorrow> ezero: you need to put parens around ... (Mymap ...) ...
02:51:15 <ezero> ah
02:51:36 <ezero> still wrong
02:51:36 <ezero>     Couldn't match expected type `[(a, b)]'
02:51:36 <ezero>            against inferred type `Map a b'
02:51:58 <mmorrow> oh, then ditch the Mymap..
02:52:33 <ezero> hmm
02:52:33 <ezero> against inferred type `[(a, b)]'
02:52:38 <ezero> now it wants that
02:53:20 <ezero> ah its the p : (rest) ..
02:53:52 <quicksilver> xrfang: is it clear now?
02:54:27 <xrfang> quicksilver: up-to-now it is clear. thanks. I will need much more reading now :D
02:55:11 <ciw6002> I am playing with monads for the first time and trying to use it in a parser. I noticed that in http://haskell.org/happy/doc/html/sec-monads.html makes a function failE wich seems like a wrapper around the Failed constructor. Why would one make it?
02:55:21 <ciw6002> Because a Constructor cannot be seen as a function?
02:55:42 <ciw6002> i.e. be used as a function, for example when supplied in a call?
02:55:57 <Ferdirand> no, a constructor can be used as a function afaik
02:56:01 <ivanm> ciw6002: constructors are functions
02:56:13 <ivanm> but they can be pattern matched, which normal functions can't
02:56:53 <quicksilver> ciw6002: just to hide the implementation, I think
02:57:00 <quicksilver> ciw6002: or to make the explanation more consistent.
02:57:03 <ciw6002> So there is no use for a wrapper function?
02:57:13 <quicksilver> no.
02:57:18 <ciw6002> quicksilver: ok
02:57:21 <ciw6002> Thank you.
02:57:25 <quicksilver> I think they're trying to make it more consistent with failP
02:57:28 <quicksilver> a few paragraphs down
02:57:31 <quicksilver> which isn't just a constructor.
02:57:57 <ciw6002> quicksilver: ok, I will just implement it and maybe later I will see the true reason for this.
03:12:55 <ezero> , let p = ("k1","v1")
03:12:56 <lunabot>  luna: parse error on input `)'
03:13:36 <ezero> > let p = ("k1","v1")
03:13:37 <lambdabot>   <no location info>: parse error on input `;'
03:13:43 <ezero> huh
03:14:49 <ezero> , let f a@(x,_) = (a,x) in f (0,1)
03:14:50 <lunabot>  ((0,1),0)
03:14:57 <quicksilver> ezero: lambdabot and lunabot evluate expressions
03:15:03 <quicksilver> what you wrote first was not an expression.
03:15:13 <ezero> so it has to be all done in one go
03:15:30 <ezero> yeah i thought it could do equations
03:15:42 <quicksilver> well, > can't
03:15:46 <ezero> let f a@(x,_) = (a,x) in f (0,1) <--- this is an equation
03:15:54 <quicksilver> no, that's an expression :P
03:16:03 <ezero> lol
03:16:12 <quicksilver> (which contains an equation between the 'let' and the 'in' parts)
03:16:18 <quicksilver> @let foo = "bar"
03:16:19 <lambdabot>  Defined.
03:16:22 <quicksilver> > foo
03:16:24 <lambdabot>   "bar"
03:16:29 <quicksilver> that's what @let is for.
03:16:34 <ezero> i see
03:16:49 <ezero> @let p = ("k1","v1")
03:16:50 <lambdabot>  Defined.
03:17:19 <ezero> , p : [("k2","v2")]
03:17:20 <lunabot>  luna: Couldn't match expected type `Luna.SimpleReflect.Expr'
03:17:41 <ezero> > p : [("k2","v2")]
03:17:42 <lambdabot>       Ambiguous occurrence `p'
03:17:42 <lambdabot>      It could refer to either `L.p', defined a...
03:18:06 <ezero> its a bit different
03:18:43 <ezero> > ("k1","v1") : [("k2","v2")]
03:18:44 <lambdabot>   [("k1","v1"),("k2","v2")]
03:18:55 <quicksilver> there is already a 'p' in scope
03:18:57 <quicksilver> unfortunately.
03:19:18 <ezero> yeah oh wel
03:19:30 <Deewiant> > L.p : [("k2","v2")]
03:19:30 <ezero> if that works
03:19:31 <lambdabot>   [("k1","v1"),("k2","v2")]
03:19:35 <ezero> then this should work too
03:19:36 <ezero> | otherwise = p : (insertWith f k v (Mymap rest))
03:20:12 <ddvlad|> hi, what does it mean when a pattern is preceded by `~'?
03:20:24 <quicksilver> lazy match.
03:20:30 <ezero> Couldn't match expected type `[(a, b)]'
03:20:30 <ezero>        against inferred type `Map a b'
03:20:46 <ezero> where Map is the type [(a,b)]
03:20:51 <quicksilver> obviously it's not.
03:20:58 <quicksilver> otherwise you wouldn't get that error.
03:21:00 <ezero> maybe i need another Mymap
03:21:02 <ddvlad|> quicksilver: thanks :)
03:21:03 <quicksilver> I imagine Map is a newtyp.
03:21:05 <quicksilver> yesk you do.
03:21:08 <ezero> yeah it is
03:21:20 <quicksilver> | otherwise = Mymap (p : ....)
03:21:53 <ezero> | otherwise = Mymap(p : (insertWith f k v (Mymap rest)))
03:22:01 <ezero> still says the same
03:22:14 <ezero> Couldn't match expected type `[(a, b)]'
03:22:14 <ezero>        against inferred type `Map a b'
03:22:19 <quicksilver> error is probably from a different bit now.
03:22:22 <quicksilver> I need to see the code.
03:23:07 <ezero> http://pastie.org/private/7exwpfel7ezl0pcmplwsa
03:24:16 <ezero> yeah it was happening on col 47 before now on col 53
03:24:41 <doserj> ezero: insertWith returns a MyMap, not a list.
03:24:46 <quicksilver> ertai: the RHS of the ":" is expecting a list
03:24:51 <quicksilver> ezero: oops that was for you
03:24:59 <ezero> yes
03:25:01 <quicksilver> but you are giving it a MyMap - the return value of insertWith.
03:25:04 <ezero> should i change it
03:25:41 <ezero> so rest is a list
03:25:49 <ezero> i.e [(a,b)]
03:25:58 <vixey> (\x y->x) = const
03:25:59 <vixey> btw
03:26:11 <doserj> e.g., otherwise = MyMap (p:r) where MyMap r = insertWith ...
03:27:05 <doserj> or, otherwise = add k1 v1 (insertWith ...)
03:27:33 <ezero> yea could call add
03:28:30 <doserj> or, otherwise = MyMap (p:r) where r = toList (insertWith ...) and you have to define toList :: MyMap k v -> [(k,v)]
03:34:47 <ezero> lol
03:34:51 <ezero> i still end up with the same problem doser
03:35:07 <ezero> this time its the other way round
03:35:08 <ezero>     Couldn't match expected type `Map a b'
03:35:08 <ezero>            against inferred type `[(a, b)]'
03:35:21 <ezero> | otherwise = Mymap (p:r) where r = toList (insertWith f k v rest)
03:35:52 <mmorrow> @tell thoughtpolice just added a function (vacuumToByteString :: GVFormat -> a -> IO ByteString) that gives you the output of graphviz in a ByteString without using any intermediary file
03:35:52 <lambdabot> Consider it noted.
03:36:17 <doserj> | otherwise = MyMap (p:r) where r = toList (insertWith f k v (MyMap rest))
03:36:33 <doserj> insertWith expects a MyMap, not a list
03:36:52 <ezero> toList arguments are now few
03:37:07 <ezero> toList :: Map k v -> [(k, v)]
03:37:07 <ezero> toList Mymap  k v = Mymap [(k,v)]
03:37:23 <doserj> toList (Mymap k v) = ...
03:37:29 <ezero> ah
03:38:02 <doserj> erm, forget that
03:38:14 <doserj> that's completly wrong
03:38:17 <ezero> yea
03:38:18 <ezero> lol
03:38:30 <doserj> toList (Mymap p) = p
03:39:20 <ezero> cool
03:39:21 <ezero> thats fine
03:43:14 <ezero> hmm still empty! and its replacing it
03:43:18 <ezero> *Map> insert "key" "value" m
03:43:18 <ezero> Mymap [("key","value")]
03:43:18 <ezero> *Map> insert "key1" "value1" m
03:43:18 <ezero> Mymap [("key1","value1")]
03:43:18 <ezero> *Map> m
03:43:20 <ezero> Mymap []
03:44:32 <RayNbow> your insert function returns a *new* map
03:44:40 <jedai> ezero: we're not in an imperative language
03:44:51 <jedai> ezero: function don't modify their arguments
03:44:52 <ezero> yeah true. i keep forgeting that
03:45:27 <ezero> so i have to make a new variable everytime
03:46:40 <jedai> ezero: right
03:47:11 <ezero> hmm still no go
03:47:11 <ezero> let m' = insert "k2" "v2" m
03:47:11 <ezero> m'
03:47:11 <ezero> [("k2","v2")]
03:47:52 <jedai> ezero: but in common usage, either you insert one or two keys in a Map in a function, or you do bulk insert and you use a fold, in any case you only need one new variable
03:48:04 <kadaver> fromList is always O(n) ? or is it jsut rmeoving some type annotation sometimes?
03:48:34 <kadaver> i mean toList
03:48:56 <ezero> this one
03:48:58 <ezero> toList :: Map k v -> [(k, v)]
03:48:58 <quicksilver> from Data.Foldable?
03:48:58 <ezero> toList (Mymap p) = p
03:49:15 <jedai> ezero: (I meant to say that the "everytime" may seems annoying at first until you realize that it's not really a problem in the real world)
03:49:21 <quicksilver> Data.Foldable.toList isn't overridable, it's defined as foldr (:) [
03:49:21 <quicksilver> ]
03:49:22 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
03:49:25 <quicksilver> so it's always O(b)
03:49:29 <quicksilver> O(n) sorry.
03:50:16 <ezero> jedai that makes sense creating a variable everytime but .. its meant to take the old map list and append it but instead its replace
03:50:27 <ezero> in other words this case is not happeing                           |   otherwise = Mymap (p:r) where r = toList (insertWith f k v (Mymap rest))
03:51:34 <Lemmih> ezero: Are you sure 'm' isn't empty?
03:51:43 <ezero> yeah it restarted ghci
03:52:14 <ezero> *Map> let m = emptyMap
03:52:14 <ezero> *Map> m
03:52:14 <ezero> Mymap []
03:52:26 <Lemmih> So it /is/ empty.
03:52:34 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4086#a4086 <- can this string-split function be made better? I tried using Data.Sequence but if I want to return a list anyway then I still have to do toList which i assume is O(n) ont he end so it end sup the same as reversing the list.
03:52:42 <ezero> *Map> insert "k1" "v1" m
03:52:42 <ezero> Mymap [("k1","v1")]
03:52:58 <ezero> *Map> m
03:52:58 <ezero> Mymap []
03:53:00 <Lemmih> ezero: That looks like it works.
03:53:06 <Lemmih> ezero: You cannot ever change 'm'.
03:53:13 <ezero> i see
03:53:16 <ezero> yeah thats okay
03:53:20 <ezero> that bit works
03:53:54 <vixey> m <- return $ insert "k1" "v1" m
03:53:54 <vixey> :p
03:54:00 <vixey> it's really a different 'm'
03:55:17 <ezero> this is what im getting
03:55:18 <ezero> http://pastie.org/454400
03:55:32 <ezero> *Map> let m' = insert "k2" "v2" m
03:55:32 <ezero> *Map> m'
03:55:32 <ezero> Mymap [("k2","v2")]
03:55:48 <ezero> where i did set up m with k1 v1
03:56:40 <Lemmih> ezero: Are you aware that you're discarding the results from the first two inserts?
03:57:05 <ezero> yea
03:57:23 <ezero> oh right
03:57:26 <ezero> so it never remembers what m is
03:57:37 <Lemmih> ezero: It does remember. 'm' is an empty map.
03:57:46 <ezero> yeah true
03:57:54 <ezero> so i shouldn't start with emptyMap
03:58:12 <Lemmih> Why not?
03:58:50 <ezero> true
03:59:08 <ezero> so what do i do to make it remember just use another variable?
03:59:20 <kadaver> cna you do an arrow-hack or applciabale or whatever to circumvent the reversing? or that just revrses in another way so still the same complexity?
03:59:29 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4086#a4086 ^^
03:59:36 <Lemmih> ezero: let m1 = emptyMap; m2 = insert ... m1; m3 = insert .. m2
04:00:18 <SamB> state monad? (reader? writer?)
04:00:41 <ezero> Lemmih so when i print out m3
04:00:45 <ezero> that will have m1 and m2 ?
04:00:46 <Lemmih> I think monads would just confuse the issue.
04:01:04 <Lemmih> ezero: Yes, m1 and m2 will still be around.
04:01:30 <ezero> ah yes it is
04:01:45 <Lemmih> ezero: You never destroy data in Haskell. You just create new data and eventually the old will go away.
04:02:31 <ezero> i see, yeah sorry was really confused starting to get the hang of functional language
04:02:36 <ezero> http://pastie.org/454404
04:02:39 <ezero> so it does work
04:03:01 <dev31212> I am still confused how Haskell manages to not overload my ram.
04:03:29 <dev31212> Like, witg a simple ADT, like a BSt...every opration "creates" many to trees.
04:03:42 <SamB> Lemmih: yeah, I guess so. he is kind of green for that, isn't he ;-)
04:04:15 <SamB> dev31212: well, it doesn't have to look at the stuff that gets dropped on the floor ...
04:04:35 <dev31212> hmmm
04:04:38 <dev31212> Lazy eval?
04:04:41 <doserj> dev31212: some parts may be shared. other parts may get garbage-collected
04:04:56 <dev31212> ok, I guess it figures all those details out.
04:05:12 <SamB> no, garbage collection consists of copying over all the heap objects that are referenced
04:05:24 <SamB> doesn't bother to look at what isn't referenced ;-)
04:05:32 <quicksilver> dev31212: it does use a fair amount of RAM compared to some other programming systems.
04:05:40 <quicksilver> generally it's considered a price worth paying.
04:05:52 <SamB> just discards whatever isn't copied to newspace
04:06:05 <SamB> er. tospace.
04:06:22 <quicksilver> of course, copying collection isn't the only kind of GC :)
04:06:24 * SamB got them confused because they rhyme, or so he thinks
04:06:25 <quicksilver> but, yes.
04:06:41 <SamB> quicksilver: well, I was describing the way GHC works by default, so ;-)
04:06:49 <ahamay42> why is my error not caught in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2187#a2187 ?
04:07:12 <quicksilver> ahamay42: because you must not try to catch errors raised by 'error'.
04:07:22 <quicksilver> it is a sign of poor morals.
04:07:49 <ahamay42> Well, I also tried my own Exception type with typeable etc.
04:07:56 <ahamay42> it didn't work either
04:08:00 <quicksilver> the error doesn't get forced in time for try to catch it.
04:08:18 <quicksilver> catching errors thrown from pure code is fiddly
04:08:26 <Lemmih> ahamay42: Because 'return $ f 42' doesn't throw an exception.
04:08:37 <quicksilver> E.try (return $! f 42) would probably work as you expected.
04:09:03 <SamB> dev31212: now, with a conservative collector it does have to look at every object -- and the objects are probably a good bit bigger, too (with headers/trailers/etc accounted for), and take longer to allocate (since it can't just increment a pointer like with moving collectors)
04:09:28 <ahamay42> oh, I thought it is possible and normal to catch errors thrown in functional code
04:09:37 <quicksilver> no, it's immoral and indecent ;)
04:09:49 <quicksilver> in pure code, use something like an 'Either' type.
04:09:55 <quicksilver> or ErrorT, which is similar
04:09:57 <Lemmih> ahamay42: It is. You just have to make sure they're actually thrown.
04:10:13 <SamB> ahamay42: it is! but you can't catch them in functional code ;-)
04:10:24 <SamB> (not when you use exceptions, I mean)
04:10:34 <SamB> (with Either etc. you can)
04:10:40 <Lemmih> ahamay42: Consider: 'take 2 [1,2,error "exception"]'
04:11:41 <SamB> and you can't catch NonTermination reliably in any case ;-)
04:11:48 <ahamay42> hmm
04:11:56 <SamB> ('tis the halting problem)
04:12:01 <ray> <<loop>>
04:12:05 <quicksilver> > take [1,2,error "exception"]
04:12:06 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
04:12:13 <quicksilver> > take 2 [1,2,error "exception"]
04:12:14 <lambdabot>   [1,2]
04:12:15 <SamB> ray: yeah, that's why I said reliably
04:12:37 <ray> it's very nice when it does work though
04:12:40 <ray> stupid halting problem
04:13:04 <SamB> I assume the presence of NonTermination in the actual library is due to <<loop>>
04:13:19 <ray> probably
04:13:34 <SamB> (I can't recall whether the paper needs it or not)
04:13:43 <Lemmih> ahamay42: Like the exception above, you're nesting the exception so deep in your structure that it isn't being thrown.
04:14:03 <ahamay42> so how do I make sure it is thworn?
04:14:07 <ahamay42> thrown
04:14:38 <SamB> ahamay42: well, you make sure that the expression that would throw it is evaluated in the context of the handler
04:14:42 <ahamay42> besides refactoring to using Either :) which might be a good idea
04:15:05 <SamB> with seq and friends
04:15:43 <ahamay42> but my error is thrown, actually
04:16:01 <ahamay42> I get an error message when starting runhaskell Try.hs
04:16:04 <Lemmih> ahamay42: Yes, it is thrown when you print the value.
04:16:33 <Lemmih> ahamay42: Which you do outside the context of 'try'.
04:16:51 <ahamay42> only if an error was raised :)
04:17:17 <ahamay42> ah, ok
04:17:23 <ahamay42> I'm starting to get it
04:17:27 <piksi> could someone point me to a tutorial for simple programs which show the imperative side of haskell? I've learned to do nice functions but combining those with the imperative part is what i'm having problem with and many tutorials deal only with abstract constructs but don't provide any "starters" for practical implementations...
04:17:40 <piksi> and i'm just a mediocre php/python/pascal programmer :->
04:17:50 <ahamay42> thx everyone, that should help :)
04:18:38 <Lemmih> piksi: Haskell for C Programmers: http://haskell.org/~pairwise/intro/intro.html
04:18:49 <Lemmih> piksi: Haven't read it myself but I hear it is decent.
04:19:30 <Lemmih> piksi: There's also Real World Haskell: http://book.realworldhaskell.org/read/
04:19:43 <ezero> pikis i really like thjis website learnyouahaskell.com
04:19:43 <McManiaC> hey, i upgraded vom ghc 6.10.1 to 6.10.2 today and it unregistered all my cabal packages. im running archlinux, how can i fix that so i can compile my programs again??
04:19:49 <kadaver> dons: what was that graph representation you liked: data Graph = Graph Map Set, hwo exactly?
04:19:50 <McManiaC> s/vom/from
04:19:55 <Xen0x> Piksi; The haskell book is very good that lemmih gave. I would try that
04:19:58 * SamB wonders how to get emacs TAGS for a QuickBasic program
04:20:01 <piksi> ezero: yeah that one was quite fun to read
04:20:23 * piksi shivers, quick basic...
04:20:26 <ezero> yeah the quality of that material is really good i enjoyed it still using it as a reference from time to time
04:20:58 * ezero looks at the book
04:21:08 <piksi> the most problem i'm having is that i started learning haskell by solving project euler problems, and those problems mostly can be squeezed to just one function and print so i never had to learn larger program constructs
04:21:37 <SamB> piksi: it's not my fault the program is written in QuickBasic!
04:21:40 <piksi> ;-)
04:21:41 <ezero> euler.. graph theory?
04:21:53 <piksi> ezero: http://projecteuler.net/
04:21:57 <piksi> those are fun to solve
04:22:45 <ezero> wow this will be fun to solve
04:22:46 <ezero> 	
04:22:46 <ezero> Find the largest prime factor of a composite number.
04:22:54 <ezero> i did a program that generates prime numbers :D
04:23:06 <ezero> not using division
04:23:09 <ezero> using lazy evaluation
04:23:31 <SamB> I've written one that used multiplication, I think
04:23:49 <SamB> it's WAAY faster than using division
04:23:55 <ezero> really?
04:24:00 <SamB> but you have to say how high you're interested in
04:24:00 <piksi> i wrote one that used modulo
04:24:03 <ezero> does that uses modulus
04:24:23 <ezero> modulo is division tho
04:24:30 <SamB> ezero: you just mark off the composites in a bitmap
04:24:38 <ezero> yes SamB
04:24:41 <piksi> [x|x <- [1..], all (\y -> mod x y /= 0) [2..x-1]] something like that
04:24:52 <ezero> the one i made also does it using composites
04:25:05 <ezero> so you generate like a blacklist
04:25:09 <ezero> of numbers that can't be prime
04:25:13 <SamB> by checking off every 2nd, every 3rd, every 5th
04:25:22 <SamB> and so on down the ones that haven't gotten crossed off yet
04:25:34 <SamB> but you have to pick how big a bitmap to make
04:25:36 <piksi> my implementation is quite stupid
04:26:40 <ezero> here is my implementation
04:26:41 <ezero> http://pastie.org/454423
04:26:51 <SamB> (you wouldn't NEED to use a bitmap, but it's easy enough when the {ST,IO,}UArrays use that representation for Bool anyway ;-)
04:27:12 <ezero> yeah BITMAPS are more efficient thats probably what makes your faster
04:27:18 <SamB> it does need to be a fixed-size array though
04:27:25 <ezero> because of their memory allocation
04:27:26 <SamB> ezero: well, I haven't benchmarked it
04:27:32 <SamB> exactly
04:27:39 <SamB> I mean I didn't try the other way or anything
04:27:59 <ezero> thats true i havn't tried piksi way either
04:28:02 <quicksilver> UArrays don't generate particularly good code for the bit fiddling, IIRC.
04:28:15 <quicksilver> so you get good memory efficiency but not awesome speed.
04:28:24 <quicksilver> of course sometimes memory efficiency gives you cache wins.
04:28:38 <ezero> yes
04:28:56 <SamB> quicksilver: yeah, so that's why I don't know if it's a win or a lose ;-)
04:29:05 <p_l> which sometimes trumps operation speed :)
04:29:06 <ezero> true
04:29:23 <xrfang> hi quicksiler, I think I am still not quite clear about let
04:29:28 <ezero> although working with infinite lists is more exciting on paper :P
04:29:30 <xrfang> see the following two lines:
04:29:34 <SamB> in the O(n), though, it doesn't matter whether or not you use a bitmap or a byte array or what
04:29:36 <xrfang> guess <- getLine
04:29:43 <xrfang> let guessNum = read guess
04:29:56 <xrfang> why the first one does not need let but the 2nd need? :)
04:30:03 <SamB> and the real seive is faster than the corrupted version they teach you in school ;-P
04:30:04 <quicksilver> xrfang: the first one is something completely different
04:30:11 <quicksilver> xrfang: <- is nothing like let, or =
04:30:17 <ezero> haha yeah SamB
04:30:19 <quicksilver> xrfang: <- is special monad syntax.
04:30:27 <quicksilver> you should no go and read at least 7 different monad tutorials.
04:30:29 <xrfang> so we cannot say num = getLine, right
04:30:29 <ezero> I did benchmarked seive
04:30:37 <xrfang> oh :)
04:30:41 <quicksilver> you could say it, but it would mean something entirely different
04:30:49 <quicksilver> it would set num to the command 'getLine'
04:30:54 <xrfang> I am reading the first tutorial recommended by haskell.org
04:30:58 <quicksilver> you could then execute num to read lines from the console
04:31:08 <quicksilver> which would be rather different.
04:31:32 <xrfang> I am not at all clear about monad... I also see a "return" which I am not sure why we need that statement.
04:31:40 <xrfang> I am just following the tutorial
04:31:40 <ezero> Thats pretty cool http://book.realworldhaskell.org/read/barcode-recognition.html
04:32:59 <quicksilver> xrfang: return is a way of embedding a pure value into a monad.
04:33:09 <quicksilver> xrfang: however, I'm not going to teach you monads from scratch in this channel
04:33:14 <quicksilver> (maybe someone else will!)
04:33:32 <xrfang> I guessed it is related to monad, because normally I don't see the need to use return in a function
04:33:45 <quicksilver> it's got nothing to do with return in other languages
04:33:50 <quicksilver> (well, very nearly nothing)
04:33:51 <quicksilver> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
04:33:59 <quicksilver> ^^ IIRC, I liked that one.
04:34:11 <xrfang> you don't need to teach me monad here, after I read the first tutorial, but still don't know monad, I will come back and please recommend some tutorial at that time... thanks quicksilver...
04:34:52 <ahamay42> I think now I've found the best solution for my previous "exceptions in pure code with lazy evaluation" problem: use evaluate isntead of return :)
04:35:02 <quicksilver> ahamay42: that's a terrible solution.
04:35:16 <ezero> lol
04:35:19 <quicksilver> try it with a list
04:35:29 <quicksilver> evaluate [1,2,error "oops I'm dead"]
04:35:37 <quicksilver> you'll find that doesn't get caught by E.try
04:35:38 <ezero> lol
04:35:50 <quicksilver> the solution is don't try to catch exceptions thrown from pure code.
04:35:53 <ahamay42> hm, too bad
04:35:59 <quicksilver> anything else and your immortal soul is in grave danger.
04:36:20 <ahamay42> lol okay, than I'll have a look at a possible refactoring :)
04:37:39 <Peaker> ahamay42: put your error in an Either, probably
04:38:53 <Phyx-> or just give up your immortal soul :P
04:39:02 <Phyx-> be a mortal like us common folk :P
04:42:53 <mmorrow> or just use reads
04:43:21 <mmorrow> (or analog)
04:45:10 * ordwidr is fighting with adt and type classes
04:47:51 <johnbs> is Data.List.sort a stable sort?
04:48:12 <EvilTerran> i believe so
04:48:18 <johnbs> ok
04:48:21 <EvilTerran> ?src sort
04:48:21 <lambdabot> sort = sortBy compare
04:48:23 <EvilTerran> ?src sortBy
04:48:24 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
04:48:52 <johnbs> oh, it does actually say it is in the docs, i just missed that the first time i read it (silly me)
04:48:58 <johnbs> thanks
04:49:18 <EvilTerran> ^ the actual implementation used by ghc (or whatever) will probably be more efficient than that insertion sort, but should have the same semantics
04:49:24 <johnbs> right
04:49:31 <xrfang> I would like to make a fault-tolerant factorial:
04:49:36 <xrfang> the original version is
04:49:38 <xrfang> fac 1 = 1
04:49:45 <xrfang> fac n = n * fac(n - 1)
04:49:56 <xrfang> how do I write a pattern so that all n <=1 will return 1?
04:50:08 <wjt> fac n | n < 1 = 1
04:50:09 <xrfang> eg. fac 0 or fac -1 etc.
04:50:09 <Deewiant> fac n | n <= 1 = 1
04:50:13 <wjt>       | otherwise = n * fac (n-1)
04:50:20 <xrfang> great, thanks!
04:50:28 <Deewiant> You don't need the | otherwise unless you want it
04:50:40 <Deewiant> Guards fall through to the next pattern
04:50:41 <hotaru2k3> fac = product . enumFromTo 2
04:50:42 <xrfang> I need many many more syntax tutorial :( need more patience :)
04:51:29 <DrSyzygyFR> I _LOVE_ cabal-install.
04:51:33 <DrSyzygyFR> Just throwing that out there.
04:51:40 * DrSyzygyFR is gearing up for a full afternoon of hacking.
04:51:42 <xrfang> hotaru2k3: product and enumFromTo are built-in?
04:51:48 <DrSyzygyFR> Wanna build a Gröbner basis computer for operads.
04:51:59 <DrSyzygyFR> Research grade symbolic algebra! In Haskell!
04:52:24 <kadaver> is: data Graph a = Graph (M.Map (S.Set a) (S.Set a)) a good way to rep a Graph?
04:52:29 <EvilTerran> ?src product
04:52:30 <lambdabot> product = foldl (*) 1
04:52:58 <EvilTerran> kadaver, surely Map a (Set a) would make more sense than Map (Set a) (Set a)?
04:53:58 <mmorrow> DrSyzygyFR: have you seen that one algebra package written by some russian(s)?
04:54:04 <mmorrow> i can't remember the name of it..
04:54:04 <DrSyzygyFR> Hmmm_
04:54:05 <DrSyzygyFR> ?
04:54:15 * mmorrow thinks
04:54:37 <dqd> Huh, why is not product defined as foldl1 (*)?
04:54:50 <hotaru2k3> primeswing is really *the* way to calculate factorials, tho
04:54:52 <EvilTerran> > foldl1 (*) [] -- because this
04:54:53 <lambdabot>   * Exception: Prelude.foldl1: empty list
04:54:55 <Deewiant> Because the empty product should be 1.
04:55:00 <dqd> Oh, I see.
04:55:15 <xrfang> monad is really a special stuff... I have another question I *think* related to that: I want to print out a list
04:55:23 <xrfang> e.g. the list is [1, 2, 3, 4, 5]
04:55:30 <kadaver> EvilTerran: yeha i confused myslef there
04:55:31 <xrfang> the output should be:
04:55:31 <mmorrow> DrSyzygyFR: oh nice, looks like it has a dir on haskell.org now http://haskell.org/docon/
04:55:38 <xrfang> number 1
04:55:41 <xrfang> number 2
04:55:44 <xrfang> and so on.
04:56:03 <xrfang> i.e. call the "print" function recursively, any ideas? :p
04:56:16 <Deewiant> mapM_ (putStrLn . ("number " ++) . show) [1..5]
04:56:20 <EvilTerran> xrfang, well, you could build up a string "number 1\nnumber 2\n..."
04:56:32 <EvilTerran> "unlines" would be useful for that
04:56:37 <mmorrow> DrSyzygyFR: it looks interesting and i've peeked at the code a little, but haven't really tried it out (yet)
04:56:48 <xrfang> hm... that's not bad. I will try it
04:56:50 <EvilTerran> and then putStr/putStrLn it
04:57:09 <Deewiant> Yes, in general you should try to do as little in the IO monad as possible.
04:57:30 <mmorrow> or just
04:57:32 <mmorrow> mapM_ print
04:57:48 <mmorrow> (very useful in ghci)
04:57:54 <Deewiant> That doesn't print "number 1", that prints "1".
04:58:00 <mmorrow> i mean in general
04:58:26 <Deewiant> Well yes, for cases like this I think using mapM_ is probably the best way
04:58:27 <mmorrow> my .ghci has:
04:58:29 <mmorrow> let pM_ a = mapM_ print a
05:04:13 <ahamay42> quicksilver: will this save my soul? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2187#a2188
05:04:34 <ahamay42> though I should use a custom error type, of course
05:06:35 <quicksilver> looks fine, although I wonder why you would bother using 'try' and 'funToMonad' together
05:06:40 <quicksilver> they almost cancel each other out :)
05:06:49 <DrSyzygyFR> Ehm ... what do I need to put in my cabal file in order to get it to recognize the BSD license?
05:06:49 <opqdonut> putting the fun in monads
05:07:28 <ahamay42> yeah, it's some interface stuff, as my different compilers all map to IO
05:07:33 <DrSyzygyFR> Pbtbtbtb. BSD3.
05:07:40 <ahamay42> maybe it's dirty, but it does the job :)
05:09:34 <ordwidr> what does this mean: 'xxx' is not a (visible) method of class 'yyy'
05:09:40 <ivanm> DrSyzygyFR: or BSD4, depending on which one you mean
05:09:52 <ordwidr> the line ghc reports the error on is the declarations of the instance / methdo
05:09:56 <ivanm> MIT (which is equivalent to BSD2) will be available in the next release IIRC
05:10:25 <Deewiant> ordwidr: Your instance declaration is trying to declare a method which isn't in the class
05:11:03 <ordwidr> Deewiant: hmmm
05:12:09 <DrSyzygyFR> Is there a librarized way to check whether a list is already sorted?
05:12:15 <Deewiant> sort x == x
05:12:52 <ordwidr> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4088#a4088
05:13:08 <ivanm> or you could do something like: \ xs -> all (\(a,b) -> a <= b) $ zip xs (tail xs)
05:13:09 <quicksilver> DrSyzygyFR: all $ zipWith (<=) xs (tail xs)
05:13:12 <ivanm> which doesn't require sorting
05:13:20 <ivanm> quicksilver: should that be and?
05:13:23 <ivanm> not all?
05:13:26 <quicksilver> probably
05:13:28 <Deewiant> ?ty all (uncurry (<=)) . (zip`ap`tail)
05:13:29 <ivanm> @type and
05:13:29 <lambdabot> forall b. (Ord b) => [b] -> Bool
05:13:30 <ivanm> @type all
05:13:30 <lambdabot> [Bool] -> Bool
05:13:32 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
05:13:36 <Deewiant> ?quote aztec
05:13:37 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
05:13:54 <quicksilver> > (and $ zipWith (<=) xs (tail xs)) [1,2,3,4]
05:13:56 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
05:14:05 <quicksilver> > (\xs -> and $ zipWith (<=) xs (tail xs)) [1,2,3,4]
05:14:07 <lambdabot>   True
05:14:13 <quicksilver> > (\xs -> and $ zipWith (<=) xs (tail xs)) [1,2,4,3]
05:14:14 <Deewiant> > all (uncurry (<=)) . (zip`ap`tail) [1,2,3,4]
05:14:15 <lambdabot>   False
05:14:15 <lambdabot>   Couldn't match expected type `a -> [(a1, a1)]'
05:14:22 <Deewiant> Oops
05:14:25 <Deewiant> > all (uncurry (<=)) . (zip`ap`tail) $ [1,2,3,4]
05:14:26 <lambdabot>   True
05:14:43 <xrfang> suppose number is a list like [1,2,3]
05:14:45 <xrfang> I want to do factorial to the list and print out:
05:14:46 <xrfang> factorial of 1 is 1
05:14:48 <xrfang> factorial of 2 is 2
05:14:50 <xrfang> factorial of 3 is 6
05:14:51 <xrfang> the code I write:
05:14:53 <xrfang> getfacs n = "factorial of " ++ (show n) ++ " is " ++ (show (fac n)) ++ "\n"
05:14:53 <ivanm> quicksilver: and I suppose your version is better than mine because Bools are cheaper to create than tuples you're just going to pull apart anyway?
05:14:54 <xrfang> nums = [1,2,3]
05:14:56 <xrfang> facs = foldl getfacs "" nums
05:14:57 <xrfang> main = putStrLn facs
05:15:01 <xrfang> but the line facs = foldl... gives compile error
05:15:23 <ivanm> xrfang: foldl is probably the wrong fold
05:15:29 <ordwidr> xrfang: facts = concat $ map getfacs nums
05:15:45 <ivanm> by the looks of things, you're going to want foldr with a mapM_ putStrLn on the results
05:15:48 <quicksilver> ivanm: probably, yes.
05:15:50 <vixey> mapM _(putStrLn . getFacs) nums
05:15:53 <xrfang> I think it may be totally wrong, I tried map, it should work well, but result is still a list, which cannot be printed out
05:16:17 <xrfang> ordwidr: I will try, thanks
05:16:20 <ordwidr> > concat ["abc","def"]
05:16:21 <lambdabot>   "abcdef"
05:16:33 <Deewiant> ivanm: In practice, they might get fused away.
05:16:37 <xrfang> but then what is the $ in it?
05:16:39 <ivanm> mapM_ putStrLn would be better than putStr . unlines IMHO if you're doing a really long list...
05:16:43 <ivanm> Deewiant: true
05:16:46 <quicksilver> Deewiant: GHC does not fuse away tuples
05:16:56 <ordwidr> anybody to care about my class instance problem? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4088#a4088
05:17:01 <Deewiant> Hence "might", I knew there was something like that. :-P
05:17:16 <Deewiant> Is it just unimplemented or are there some possible problems with it
05:17:54 <quicksilver> ordwidr: you meant instance 'A C'
05:17:59 <xrfang> ordwidr: it works well with concat, but 1) what is the $ in it; 2) from the definition I feel that either foldl or foldr can do same or similar thing ...
05:18:12 <Deewiant> ?src $
05:18:13 <lambdabot> f $ x = f x
05:18:19 <Deewiant> ?src concat
05:18:19 <lambdabot> concat = foldr (++) []
05:18:24 <quicksilver> Deewiant: well, removal of tuples was not in any of the fusion papers I read :)
05:18:40 <Deewiant> So I guess it's just unimplemented then :-P
05:18:48 <Deewiant> Or maybe fusion is the wrong word. Shug.
05:18:50 <Deewiant> Er, shrug.
05:19:14 <quicksilver> I'm not sure it's the wrong word
05:19:24 <quicksilver> people talk about trying to make zip fuse
05:19:30 <quicksilver> and I think they mean exactly what you're talking about.
05:19:39 <pejo> quicksilver, supero should be able to do that.
05:19:47 <Deewiant> Supero should be able to do anything!
05:20:10 <pejo> Deewiant, well, I think that's a bit of a stretch.
05:20:16 <Deewiant> supero <any program> --> main = putStrLn "answer"
05:20:47 <opqdonut> :D
05:20:53 <xrfang> lambdabot: f $ x = f x which means $ is optional, right?
05:20:56 <quicksilver> pejo: anything which works by church transforms is capable of removing tuples
05:21:09 <quicksilver> xrfang: well, it basically just affects parenthesisation
05:21:27 <quicksilver> xrfang: "a b c d $ e f g h" is "(a b c d) (e f g h)"
05:21:37 <pejo> quicksilver, what is a church transformation?
05:21:38 <ivanm> Deewiant: what happens if the program requires input?
05:21:38 <quicksilver> is church transform what I mean?
05:21:45 <quicksilver> where you convert tuples into functions.
05:21:52 <ivanm> quicksilver: I think so...
05:21:57 <quicksilver> I think augustss was talking about it yesterday.
05:22:05 <ivanm> oh? here you mean?
05:22:10 <quicksilver> it's one of the ways of translating ADTs into functions
05:22:12 <quicksilver> yes, here
05:22:14 <xrfang> ok quicksilver, so concat $ map ... actually means concat (map ...) right?
05:22:17 * ivanm might be doing a talk on church numerals, etc. in a couple of weeks
05:22:19 <quicksilver> xrfang: correct
05:22:29 <ivanm> I'll have to dig up the logs then
05:22:30 <quicksilver> xrfang: $ is just a way of reducing the number of () you have to type, normally.
05:22:31 <xrfang> or, can I write concat.map ... ? using the dot
05:22:41 <quicksilver> sometimes, yes
05:22:42 <ivanm> xrfang: note that it's better to do concatMap rather than concat . map
05:23:01 <xrfang> ok, ivanm: concatMap is another pre-defined function?
05:23:04 <ivanm> xrfang: you normally use the $ at the end of a chain of . operations, to actually get the final variable applied to the chain
05:23:06 <ivanm> xrfang: yup
05:23:08 <ivanm> @src concatMap
05:23:09 <lambdabot> concatMap f = foldr ((++) . f) []
05:23:15 <ivanm> it's slightly more efficient than concat . map
05:23:25 <ivanm> since it doesn't require an extra list constructed, etc.
05:23:30 <xrfang> what do you mean @src concatMap? is it a sort of IRC code or haskell stuff?
05:23:37 <ivanm> xrfang: a command to lambdabot
05:23:42 <ivanm> @src id
05:23:43 <lambdabot> id x = x
05:23:46 <RayNbow> doesn't fusion apply to concat . map ?
05:23:52 <ivanm> RayNbow: I think so
05:23:58 <xrfang> haha lambdabot is not a person ? :)
05:24:20 <ivanm> but IMHO, you shouldn't rely on it if there's an easy to use pre-done optimisation
05:24:24 <RayNbow> @faq Can Haskell give lambdabot a personality, allowing it to pass the Turing Test?
05:24:24 <lambdabot> The answer is: Yes! Haskell can do that.
05:24:24 <ordwidr> xrfang: do the turing test with lambdabot and you'll see
05:24:38 <ordwidr> heh
05:24:48 <RayNbow> great minds think alike? :p
05:24:56 <ivanm> if the result of the fuse is complicated, then rely on fusion... but concatMap isn't much harder than concat . map (and uses three less characters!)
05:25:21 <Deewiant> ivanm: "answer" includes all possible answers to all possible inputs. If you use the --quiet option to supero, it instead looks up the one you want in a lookup table.
05:25:36 <RayNbow> ivanm: we could also use (=<<), which is even shorter :p
05:25:44 <ivanm> Deewiant: heh
05:25:52 <ivanm> even for infinitely possible inputs?
05:26:01 <ivanm> RayNbow: yes, but concatMap looks cleaner IMHO
05:26:02 <bastl> i have to deal with Tree String and Tree (Int,String), where Int is just an ID. I have functions that convert between these objects. But im stumped how to write the functor that maps between these types. can anyone help?
05:26:08 <Deewiant> ivanm: Haskell supports infinite lists, remember ;-)
05:26:27 <ivanm> Deewiant: but doesn't support _storage_ of infinite lists
05:26:56 <Deewiant> ivanm: Of course it's compressed into a generating function to minimize space use, even when it's finite
05:27:07 <Deewiant> And we're back to the original, unsupero'd program ;-)
05:27:11 <ivanm> e.g. do let xs = [1..]; print xs; print (length xs) <-- it won't like this
05:27:20 <ivanm> Deewiant: heh
05:30:01 <ordwidr> is there a function like all but with [(a->Bool)] -> a -> Bool ?
05:30:35 <Deewiant> ?hoogle [a -> Bool] -> a -> Bool
05:30:35 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
05:30:36 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
05:30:36 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:30:41 <Deewiant> Meh
05:30:46 <ivanm> ordwidr: \ fs a -> all ($a) fs
05:30:58 <ivanm> @pl \ fs a -> all ($a) fs
05:31:00 <lambdabot> flip (all . flip id)
05:31:16 <ordwidr> flip id make my brain hurt
05:31:22 <xrfang> ok, I will study these sugar later. for now, another question, if I need to print out a file, line by line, I have to concat all of them??? this seems inefficient and use a lot of memory?
05:31:24 <Deewiant> flip id = flip ($)
05:31:28 <ivanm> @type flip id
05:31:29 <lambdabot> forall b c. b -> (b -> c) -> c
05:31:43 <ivanm> xrfang: or you can mapM_ putStrLn
05:31:54 <ivanm> or putStr . unlines
05:31:58 <RayNbow> @pl f bs a = and $ sequence bs a
05:31:58 <lambdabot> f = (and .) . sequence
05:32:05 <RayNbow> :t (and .) . sequence
05:32:06 <ivanm> due to laziness, the latter isn't that more inefficient
05:32:07 <lambdabot> forall a. [a -> Bool] -> a -> Bool
05:32:25 <Deewiant> xrfang: Haskell is lazy; if you do the input lazily and print a line at a time, you'll probably have only one line in memory at once (forgetting about I/O buffering)
05:32:39 <xrfang> ivanm: I feel that haskell is like ruby in this regard -- you have many ways to do one thing, but actually it adds complication for newbies
05:32:58 <ivanm> *shrug*
05:33:09 <ivanm> most languages are like that ;-)
05:33:23 <ivanm> there's the "obvious" way, and the "this is slightly better for my purposes" way
05:33:28 <xrfang> Deewiant: I know it is lazy... but... anyway I will need practices...
05:34:19 <xrfang> alright ivanm, too many things. I will ask after my first tutorial session :D
05:34:55 <ordwidr> > flip (all.flip id) $ [(>= 2), (<= 5)] 3
05:34:56 <lambdabot>   Couldn't match expected type `t -> [a -> Bool]'
05:35:07 <Deewiant> Lose the $
05:35:51 <ordwidr> Deewiant: aye
05:37:19 <dev31212> , type True == True
05:37:23 <lunabot>  luna: parse error on input `type'
05:37:28 <dev31212> , help
05:37:31 <ivanm> ,type True == True
05:37:32 <lunabot>  type of an expression:      , [$ty| \x -> x |]
05:37:32 <lunabot>  get info for a type/class:  , src ''Monad
05:37:32 <lunabot>  get info for a var/con:     , src 'fix
05:37:33 <lunabot>  luna: parse error on input `type'
05:37:34 <Deewiant> , [$ty|True]
05:37:35 <lunabot>  luna: lexical error in string/character literal at end of input
05:37:38 <Deewiant> , [$ty|True|]
05:37:41 <lunabot>  Bool
05:37:53 <dev31212> , [$ty|True == True]
05:37:54 <lunabot>  luna: lexical error in string/character literal at end of input
05:38:08 <dev31212> , [$ty|True|]
05:38:09 <ivanm> dev31212: need a `|' before the closing bracket
05:38:11 <lunabot>  Bool
05:38:15 <dev31212> thanks :)
05:38:17 <ivanm> , [$ty|True == True|]
05:38:20 <lunabot>  Bool
05:38:28 <dev31212> can one ocmmunicate with the bot in PM?
05:38:32 <dev31212> so I wont annoy others.
05:38:35 <ivanm> I believe so
05:38:36 <Deewiant> With lambdabot at least, yes.
05:38:37 <ordwidr> huh: what's that `v' is a rigid type variable bound by the type signature for 'validate' at...
05:38:39 <Deewiant> Not sure about luna.
05:38:48 <dev31212> ok
05:38:51 <ivanm> dev31212: you might find lambdabot's @type command more intuitive to use though ;-)
05:39:01 <Deewiant> ?ty True == True
05:39:02 <lambdabot> Bool
05:39:06 <dev31212> ahhh
05:39:11 <dev31212> definitely
05:39:30 <RayNbow> ordwidr: rigid type?
05:39:34 <gnuvince> Does anyone have an idea what Jon Harrop's angle is when he constantly disparages Haskell and other languages?
05:39:46 <dev31212> I do see lots of Haskell haters out there.
05:39:50 <ordwidr> RayNbow: yes
05:39:53 <RayNbow> ordwidr: are you using type annotations in a where clause or something?
05:40:25 <ivanm> gnuvince: to promote his F#/OCaml stuff
05:40:29 <ivanm> since that's how he makes his money
05:40:29 <kadaver> hey, does anyone want a better hashtable?
05:40:48 <dev31212> kadaver, I wouldnt mind seeing an implementation, to study from.
05:40:49 <ivanm> (IIRC, he once said that OCaml was better because there were paid blogs for it, but not for Haskell...)
05:40:50 <kadaver> and if so,would doing one by interfacing to C be ok?
05:40:56 <ivanm> kadaver: I don't...
05:41:06 <ordwidr> RayNbow: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4088#a4090
05:41:08 <ivanm> why not use a Map, or some other tree-based structure?
05:41:22 <ivanm> kadaver: that's cheating! :p
05:41:26 <kadaver> ivanm: well if you need a hashtable you need a hashtable
05:41:37 <kadaver> AVl-trees are good enough ig uess
05:41:40 <ivanm> when would you need one?
05:41:47 <kadaver> but we have the hastable there even if noone uses it
05:41:51 <dev31212> oh, using a C lib to get around the whole no-side-effect thing?
05:41:52 <dev31212> :p
05:42:02 <quicksilver> I don't claim AVL-trees are good enough, but I do claim that the various kinds of trie are good enough.
05:42:17 <ivanm> kadaver: http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
05:42:22 <kadaver> is the avl-treee on hackage faqster than data.map?
05:42:49 <ivanm> hmmm.... it's been a while since my data structure course, but I thought red-black trees > AVL trees...
05:42:55 <ivanm> (in general, at least)
05:42:57 <Deewiant> Depends what you're doing
05:43:01 <Deewiant> +on
05:44:16 <gnuvince> ivanm: It may just be me, but looking like a huge ass is not really a great way to promote yourself.  Not to mention that OCaml and Haskell seem to influence each other quite often, so why cause tensions between the two?
05:44:20 <gnuvince> Anyway
05:44:25 <ivanm> gnuvince: I agree
05:44:27 <gnuvince> I don't like that guy.
05:44:36 <ivanm> but that's what's been said when I've asked similar questions
05:44:42 <gnuvince> OK.
05:44:53 <quicksilver> gnuvince: You will find plenty of people here who don't like him ;)
05:45:10 <ivanm> (gnuvince: though when I started reading your comment I thought you were referring to me at some point, which was rather confusing... until I reached "OCaml" :p )
05:45:10 <quicksilver> it wouldn't surprise me to hear that being an ass makes him money, though.
05:45:27 <quicksilver> the more people who have heard of your, the higher chance someone will buy your services or your products.
05:45:31 <RayNbow> ordwidr: hmm...
05:45:43 <quicksilver> "no such thing as bad publicity" is not actually true, but there is a grain of truth to it.
05:45:54 <ivanm> quicksilver: do you think this fpmatters blog is by him?
05:46:23 <ordwidr> RayNbow: I'm new to typeclasses. the idea is to have same fieldspecs (e.g. StringFieldSpec min max) and some associated values (StringValue string). I want to validate a fieldvalue against a fieldspec
05:46:25 <ivanm> it's his general "style" (try to prove Haskell's philosophy is bad by what Haskellers say and taking it out of context) but the actual writing style seems different...
05:46:29 <gnuvince> ivanm: I should probably have said "oneself" instead of "Yourself", sorry.  English isn't my primary language, I sometimes make little mistakes like that.
05:46:38 <ivanm> heh
05:47:09 <ordwidr> RayNbow: but only stringfields against  stringfieldspecs and integerfields against integerfiedlspecs.
05:47:10 <ivanm> gnuvince: what is it then, since /whois doesn't reveal enough information to make a good enough guess?
05:47:14 <RayNbow> ordwidr, so: validate :: FieldSpec => fs -> v -> Bool
05:47:22 <RayNbow> for StringFieldSpec this becomes:
05:47:31 <RayNbow> validate :: StringFieldSpec -> v -> Bool
05:47:36 <gnuvince> ivanm: French.
05:47:37 <ordwidr> that's the idea
05:47:41 <ivanm> gnuvince: *nod*
05:47:55 <RayNbow> your definition of validate for StringFieldSpec however does not have that type
05:48:20 <kadaver> AVL trees perform better than red-black trees for lookup-intensive applicatio
05:48:22 <RayNbow> but has the type validate :: StringFieldSpec -> StringFieldValue -> Bool instead
05:48:35 <RayNbow> which is less general
05:48:37 * ivanm idly wishes he could mix and match the Maybe and List monads in his do-block...
05:48:43 <ordwidr> RayNbow: ok
05:48:49 <kadaver> but the geenral opinion from googling seems to say RBTs are better
05:48:52 <ordwidr> would it help to  turn it around so that validate lies in a fieldvalue typeclass
05:49:26 <ivanm> I'm basically wanting to fold over a list of functions, but as soon as I hit a failure value to immediately stop folding... what would be my best bet?
05:49:36 <ivanm> manual recursion?
05:50:06 <RayNbow> ordwidr: I'm not sure, but you might want to look into functional dependencies
05:50:10 <quicksilver> ivanm: foldM in an appropriate monad, is one way.
05:50:21 <ivanm> @type foldM
05:50:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:50:53 <ivanm> hmmmm..... is that a foldl style function?
05:51:36 <quicksilver> it's foldr-style
05:51:39 <quicksilver> but it threads a monad
05:51:47 <ivanm> @type foldr
05:51:47 <quicksilver> if that monad is maybe, for exaple, you get early termination.
05:51:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:51:57 <Deewiant> Or Either
05:52:06 <ivanm> it's function sig looks the wrong way round for foldr...
05:52:09 <quicksilver> the early termination of maybe is not so useful
05:52:12 <kadaver> how would you rep a weighted graph?
05:52:13 <ordwidr> RayNbow: ok, thanks. i'll look
05:52:13 <kadaver> data Graph a = Graph (M.Map a (S.Set a))
05:52:13 <kadaver>                deriving(Eq, Ord, Show)
05:52:17 <quicksilver> because it carries no value :)
05:52:25 <quicksilver> hence, either, as deewiant suggests
05:52:34 <quicksilver> with the 'Right' branch carrying 'partially complete computation'
05:52:41 <Deewiant> kadaver: S.Set (Int,a) ?
05:52:43 <RayNbow> ordwidr: I'll paste something in a sec
05:52:44 <quicksilver> and the 'Left' branch signallying 'stop now, I'm done'
05:52:44 <kadaver> is what i ahve  but how do i stick the wieght? Should it be S.Set (weight,e) ?
05:52:51 <ivanm> my function is of type [a -> Maybe Bool] -> Maybe [a -> Maybe Bool] (with each function returning "Just True" if the condition is met, so remove it from the list; "Just False" if failure so return Nothing overall, and "Nothing" if the conditions to try using that function haven't been met yet)
05:52:56 <Saizan> foldM is actually a foldl
05:53:07 <ordwidr> RayNbow: i'm reading http://haskell.org/haskellwiki/Functional_dependencies
05:53:26 <ivanm> kadaver: any particular reason for using a custom graph type?
05:53:45 <ivanm> Saizan: which is what I thought... and I don't want to change the order of my list of values :s
05:54:07 <Deewiant> ?src foldM
05:54:08 <lambdabot> foldM _ a []     = return a
05:54:08 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
05:54:25 <ivanm> @hoogle foldrM
05:54:25 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
05:54:36 <Deewiant> ?src [] foldrM
05:54:36 <lambdabot> Source not found. It can only be attributed to human error.
05:54:36 <ivanm> oh, missed the foldable bit :s
05:54:51 <ivanm> Deewiant: I don't think it's monad-specific
05:54:53 <RayNbow> ordwidr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4088#a4091
05:55:05 <EvilTerran> ?src foldrM
05:55:05 <lambdabot> Source not found. My mind is going. I can feel it.
05:55:52 <Deewiant> ivanm: I was trying for Foldable-specific
05:56:02 <Deewiant> But it isn't that either
05:56:10 <RayNbow> ordwidr: the paper linked on that wiki page is an interesting read
05:56:11 <ivanm> oh, I thought you were doing it for foldM
05:56:15 <ivanm> @instances Foldable
05:56:16 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
05:56:19 <Deewiant> foldrM f z0 xs = foldl f' return xs z0
05:56:19 <Deewiant>   where f' k x z = f x z >>= k
05:56:21 <EvilTerran> foldrM f z0 xs = foldl f' return xs z0 where f' k x z = f x z >>= k
05:56:37 <ivanm> @instances-importing Data.Foldable Foldable
05:56:38 <lambdabot> Maybe, []
05:56:38 <RayNbow> ( pdf version can be found at http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.7806 )
05:56:51 <ivanm> @doc Data.Foldable
05:56:52 <lambdabot> Data.Foldable not available
05:56:56 <ivanm> :o
05:57:01 <EvilTerran> strangely, foldrM is defined in terms of foldl, and foldlM in terms of foldr
05:57:20 <ivanm> EvilTerran: :o
05:57:25 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
05:57:27 <Deewiant> I wonder if that's a typo :-P
05:57:34 <Deewiant> That would amuse me
05:57:40 <EvilTerran> most Foldable instances are defined with the type, not with the class
05:59:13 <ivanm> Deewiant: what, using foldl rather than foldr?
05:59:20 <ivanm> I wouldn't think so...
05:59:36 <Deewiant> I guess there is some sense to it but I can't be bothered to think it through now
05:59:40 <ivanm> oh, damn, that won't work for me either...
06:00:30 <Deewiant> ivanm: In the past, what I've done for things like this is explicit recursion followed by sequence
06:00:48 <Deewiant> But then, I've usually been doing stuff that also involves looking at variably-sized parts of the list head
06:01:01 <ivanm> *nod*
06:01:40 <ivanm> basically, my functions are going to be expecting that the result of looking up a value in a Map a [b] return a singleton list... if not, to return Nothing
06:01:59 <ivanm> if the value _is_ a singleton list, to return Just (f b)
06:02:29 <ivanm> hmmm.... when using <- in a do-block, it can do pattern matching as well, can't it?
06:02:38 <vixey> yes
06:02:42 <Deewiant> Yes, and it calls 'fail' if the match doesn't succeed.
06:02:51 <ivanm> *nod*
06:02:58 <ivanm> which is what I want it to do
06:02:59 <ivanm> good-o
06:03:01 <Deewiant> ?undo do Just x <- mx; return (x+1)
06:03:01 <lambdabot> mx >>= \ a -> case a of { Just x -> return (x + 1); _ -> fail ""}
06:04:00 <ivanm> now, if only I could mix the non-determinism of the list monad in with the Maybe monad...
06:04:43 <ivanm> @undo do Just [x] <- mxs; return x
06:04:44 <lambdabot> mxs >>= \ a -> case a of { Just [x] -> return x; _ -> fail ""}
06:04:48 <EvilTerran> ivanm, wouldn't an appropriate transformer stack do that?
06:05:01 <ivanm> EvilTerran: maybe.... but I've never really touched transformers ;-)
06:05:15 <Deewiant> ?unmtl ListT Maybe a b
06:05:15 <lambdabot> Maybe [a] b
06:05:22 <ivanm> (I take it back... I used to own quite a few transformer toys when I was younger... :P )
06:05:24 <Deewiant> ?unmtl MaybeT [] a b
06:05:24 <lambdabot> [Maybe a] b
06:05:42 <EvilTerran> ...?
06:05:53 <trofi^w> @help unmtl
06:05:53 <lambdabot> unroll mtl monads
06:06:02 <EvilTerran> that "b" shouldn't be in either of those :P
06:06:25 <Deewiant> EvilTerran: unmtl wants a full type
06:06:32 <Deewiant> The b is just the return value of a function in that monad
06:06:35 <EvilTerran> ListT Maybe a = Maybe [a]; MaybeT [] a = [Maybe a]
06:06:36 <Deewiant> Er, return type
06:06:39 * ivanm might just apply all of the functions to all of the values, return Nothing if any ((==) (Just False)) is true, and go from there
06:06:39 <EvilTerran> Deewiant, no, that's the "a"
06:06:47 <EvilTerran> ?unmtl ListT Maybe a
06:06:47 <lambdabot> Maybe [a]
06:06:52 <EvilTerran> Deewiant, check the kinds
06:06:59 <Deewiant> Hmm, right
06:07:01 <Deewiant> True :-P
06:07:13 <Deewiant> ?unmtl [] a b c d
06:07:13 <lambdabot> [a] b c d
06:07:15 <Deewiant> Whee
06:07:39 <EvilTerran> ?unmtl ListT ListT a b
06:07:39 <lambdabot> [a] [b]
06:07:41 <EvilTerran> lol wut
06:07:52 <Deewiant> I'm just too used to stuff like State and Reader and whatnot which have a state in addition to the return type :-)
06:08:12 <dev31212> ?help
06:08:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:08:19 <dev31212> list
06:08:23 <dev31212> ?list
06:08:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:08:38 <bastl> are there ides that support simple refactorings like renaming of functions etc?
06:08:41 <EvilTerran> dev31212, you can talk to lambdabot via private message, if you're identified
06:10:40 <ivanm> @where hare
06:10:40 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
06:10:46 <ivanm> ^^ not an IDE though
06:10:54 <badkins> Considering learning SML before Haskell. Pros/cons to that approach for a functional newbie?
06:10:58 <ivanm> bastl: isn't a find/replace good enough for you? :p
06:11:38 <ivanm> badkins: people often consider the MLs a "stepping stone" to haskell since they allow side-effects... but it could then make it harder to learn haskell, because you keep wishing for side effects in your haskell code
06:11:38 <bastl> ivanm: across multiple modules?
06:11:45 <ivanm> bastl: sed?
06:12:11 <ivanm> recursively, or as the result of a find . -iname "*.hs" -exec ... command?
06:12:17 <quicksilver> bastl: the answer to your question is "no".
06:12:28 <quicksilver> however that kind of thing is within the scope of the 'HaRe' and 'scion' projects
06:12:35 <badkins> I guess another way to ask the question is if I just started with Haskell, would I be missing any important concepts that are unique to ML.
06:12:37 <quicksilver> I don't know if either is mature enough to actually do it.
06:12:45 <badkins> Because I doubt I'd pickup ML *after* Haskell
06:13:02 <ivanm> badkins: the only concept I can recall people talking about that ML has that Haskell doesn't is its module system
06:13:15 <ivanm> which some consider superior to haskell's classes
06:13:23 * ivanm has never used an ML, so wouldn't know
06:13:43 <quicksilver> well, ML variants have other things
06:13:43 <RayNbow> ML is hard to read when you're used to Haskell :p
06:13:49 <quicksilver> ocaml in particular has extensible records and variants
06:13:58 <quicksilver> including polymorphism over extensible variants
06:14:01 <quicksilver> which is cute
06:14:29 <badkins> If I were to go the ML->Haskell route, I expect it would be SML.
06:14:48 <ivanm> RayNbow: I know that ML's type sigs are harder to read...
06:15:00 <ivanm> though I suppose Int*Int is more mathematical than (Int,Int)
06:15:57 <dev31212> ?type
06:15:58 <lambdabot> <no location info>: not an expression: `'
06:16:03 <kadaver> so Modules in ML isn't modules as Module Blah where?
06:16:06 <dev31212> ?type (4,5)
06:16:07 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
06:16:13 <quicksilver> ML modules are a much more powerful thing
06:16:18 <quicksilver> haskell modules are really just namespace control
06:16:21 <dev31212> ?type (*6)
06:16:23 <lambdabot> forall a. (Num a) => a -> a
06:16:29 <quicksilver> ML modules can take parameters and be instantiated multiple times.
06:16:35 <kadaver> but do they have things for handling dispatch? allt he nameclashes in haskell are a bit meh
06:16:52 <quicksilver> most ML dialects let you open and rename modules locally.
06:17:06 <dev31212> ?let
06:17:07 <EvilTerran> and "can take parameters" means "can be parameterised by types and/or values"
06:17:07 <lambdabot>  Defined.
06:17:15 <dev31212> ?let x =5
06:17:17 <lambdabot>  Defined.
06:17:22 <dev31212> ?putStrLn x
06:17:22 <EvilTerran> which is pretty snazzy
06:17:23 <lambdabot> Unknown command, try @list
06:17:31 <EvilTerran> > x
06:17:32 <lambdabot>       Ambiguous occurrence `x'
06:17:32 <lambdabot>      It could refer to either `L.x', defined a...
06:17:39 <EvilTerran> yeah, should've seen that coming
06:17:41 <EvilTerran> ?undef
06:17:45 <dev31212> oh
06:17:50 <Deewiant> > f x
06:17:51 <lambdabot>   Add a type signature
06:17:52 <EvilTerran> ?type x -- there's already an x in scope
06:17:53 <lambdabot> Expr
06:17:54 <Deewiant> > f x :: Expr
06:17:55 <lambdabot>   f x
06:18:07 <Deewiant> Use names like 'foo' and you'll be fine ;-)
06:18:12 <EvilTerran> > sum [x,y,z] -- another clever trick
06:18:13 <lambdabot>   0 + x + y + z
06:18:29 <dbueno> quicksilver: Didn't someone prove ML models and type classes have the same expressive power, according to some definition?
06:18:36 <yango> > min [1,1,-1]
06:18:37 <lambdabot>       Overlapping instances for Show ([t] -> [t])
06:18:37 <lambdabot>        arising from a use o...
06:18:42 <Deewiant> > minimum [1,1,-1]
06:18:44 <lambdabot>   -1
06:18:45 <dbueno> quicksilver: http://www.cse.unsw.edu.au/~chak/papers/modules-classes.pdf
06:18:56 <Deewiant> > min [1,1,-1] [2,2,-2]
06:18:57 <lambdabot>   [1,1,-1]
06:19:00 <dbueno> I could be totally misrepresenting the results....
06:19:23 <quicksilver> dbueno: yeah, I should read that but I haven't.
06:19:59 <dbueno> quicksilver, oh but you were comparing Haskell *modules* to ML modules.  Sorry.
06:22:42 <DrSyzygyFR> I know I've gotten help with this particular bit from here before at one point.
06:23:21 <DrSyzygyFR> But if I want to update a tree, with leaves carrying some certain type, to replace the leaves with trees.
06:23:29 <DrSyzygyFR> Is there a good, concise, readable and fast way to do it?
06:23:36 <DrSyzygyFR> Or .. well .. any decent way to do it?
06:23:42 <quicksilver> DrSyzygyFR: that should be 'fmap'
06:23:42 <mmorrow> dbueno: it's not the case that type classes and ML functors have the same expressive power
06:23:55 <quicksilver> if your Tree type is a functor.
06:24:05 <DrSyzygyFR> Ok. How do I make my Tree type a functor?
06:24:17 <dbueno> mmorrow: What does the paper show?
06:24:27 <mmorrow> dbueno: but it is the case that modules + i can't remember what are equiv to functors
06:24:46 <DrSyzygyFR> quicksilver: I'm not just applying some function to the leaves (or rather , in some cases I amk, in others I'm not), I will actually want to replace the leaves with new trees.
06:25:01 * mmorrow tries to find what "i can't remember what" is
06:25:24 <quicksilver> DrSyzygyFR: sure, that's a map from 'Tree a' to 'Tree (Tree a)'
06:25:34 <quicksilver> DrSyzygyFR: which is fmap using a function "a -> Tree a"
06:25:40 <quicksilver> or it might even be a -> Tree b
06:25:49 <quicksilver> all assuming your Tree is a functor in the first place.
06:25:54 <DrSyzygyFR> And then I want to end up in Tree a again.
06:26:01 <quicksilver> that's when you need "join
06:26:02 <DrSyzygyFR> And I still don't see how to functorize my tree.
06:26:04 <quicksilver> which ass
06:26:10 <quicksilver> makes your tree into a monad
06:26:11 <Deewiant> That one!
06:26:19 <quicksilver> DrSyzygyFR: well, show us your Tree data type then?
06:26:49 <DrSyzygyFR> data DecoratedTree = DTLeaf Int | DTVertex [DecoratedTree]
06:27:06 <DrSyzygyFR> (with a bit of extra cruft left off from DTVertex
06:27:06 <quicksilver> generalise that
06:27:20 <quicksilver> data DecoratedTree a = DTLeaf a | DTVertex [DecoratedTree a]
06:27:35 <quicksilver> then make it a functor + a monad.
06:27:45 <quicksilver> step 3 profit!
06:27:56 <DrSyzygyFR> Well, to be specific, in the end I _don't_ want it to have generic leaf carrying capacity, due to domain constraints.
06:28:30 <quicksilver> sure, but in the end you set the type to DecoratedTree Int
06:28:39 <quicksilver> nobody need know it can secretly hold any type.
06:28:48 <DrSyzygyFR> Suppose I have that type floating around, then.
06:28:59 <quicksilver> this technique of adding parametricity which you don't use in your exported interface is a common one.
06:29:27 <DrSyzygyFR> fmap f (DTLeaf a) = DTLeaf (f a), and fmap f (DTVertex lst) = DTVertex (map (fmap f) lst)
06:29:31 <DrSyzygyFR> right?
06:30:01 <EvilTerran> looks about right
06:30:16 <EvilTerran> if it typechecks, it's probably right :)
06:30:58 <DrSyzygyFR> So how do I, with an fmap, distribute the leaf labels [1,3,2] onto DTVertex [DTLeaf 1, DTVertex [DTLeaf 2, DTLeaf 3]] ??
06:31:18 <quicksilver> distribute?
06:31:26 <quicksilver> you said you wanted to replace leafs with trees
06:31:31 <DrSyzygyFR> Yes!
06:31:42 <DrSyzygyFR> So if I have a list of trees, I want to insert them where the leaves were.
06:31:53 <quicksilver> ah
06:31:55 <DrSyzygyFR> So I could make a list of trees out of that thingie, by mapping DTLeaf over it.
06:31:57 <quicksilver> you have a particular list
06:32:00 <quicksilver> not a function
06:32:02 <DrSyzygyFR> Yup.
06:32:04 <mmorrow> dbueno: grr, i can't find the remark i'm looking for
06:32:09 <quicksilver> now you need a traversable instance :)
06:32:10 <DrSyzygyFR> Hence my confusion at fmap.
06:32:50 <quicksilver> :t traverse
06:32:54 <lambdabot> Not in scope: `traverse'
06:32:58 <quicksilver> :t T.traverse
06:32:59 <DrSyzygyFR> I have the doc page here.
06:33:00 <lambdabot> Couldn't find qualified module.
06:33:04 <quicksilver> @hoogle traverse
06:33:05 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
06:33:05 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
06:33:31 <DrSyzygyFR> So I need to implement Functor, Foldable and Traversable on my tree type?
06:33:46 <quicksilver> I'm not sure you need Foldable for the task at hand.
06:33:55 <quicksilver> although the instance for that is simple enough.
06:33:56 <nominolo> @seen dons
06:33:56 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 17m 56s ago.
06:33:59 <DrSyzygyFR> If I do newtype foo = bar, do I need to specify derivings for that?
06:34:03 <DrSyzygyFR> I don't, do I?
06:34:10 <quicksilver> with GeneralizedNewTypesDeriving
06:34:14 <quicksilver> you can just derive it
06:34:17 <quicksilver> typoes excvepted.
06:34:35 <ivanm> If I'm using a do-block for Maybe Bool, do all my usages of <-, etc. have to be for Maybe Bool as well? or just for any Maybe value?
06:34:44 <EvilTerran> any Maybe
06:34:48 <EvilTerran> ?type (>>=)
06:34:48 <zax> If I do something like sum' list | sum list != 3 = (list, sum list), it goes through list twice right? So I get n^2 complexity where n = length list
06:34:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:35:21 <ivanm> so why is ghci complaining about "Couldn't match expected type `[Value]' against inferred type `Maybe a" in my <- calls?
06:35:30 <mmorrow> dbueno: well, i'm not sure if your and my definitions of "expressive" are the same
06:35:37 <EvilTerran> ivanm, it's basically "do (x :: a) <- foo :: m a; ... :: m b) :: m b"
06:35:43 <DrSyzygyFR> What I mean is if I have a PreDecoratedTree type where I do all my instances, and then I declare the DecoratedTree type as a newtype, does it automatically inherit all instances?
06:35:59 <quicksilver> DrSyzygyFR: no, you have to add a 'deriving' clause
06:36:00 <EvilTerran> ivanm, it seems to think your do-block is in the [] Monad
06:36:00 <ivanm> duh, I'm doing Just [a] <- foo
06:36:06 <EvilTerran> or that
06:36:06 * ivanm facepalms
06:36:09 <quicksilver> DrSyzygyFR: but that's not too hard.
06:36:29 <ivanm> I forgot that using <- automatically ensures Just is the constructor
06:36:32 <DrSyzygyFR> type (Ord a, Eq a) => DecoratedTree a = PreDecoratedTree Int a deriving (Eq, Ord, Show, Functor, Foldable, Traversable)
06:36:35 <DrSyzygyFR> Right?
06:36:37 <EvilTerran> zax, well, it'd be 2n; you're only traversing the list twice, not once for each element in it (which'd give you the n^2)
06:36:47 <quicksilver> that's a type not a newtype.
06:36:49 <zax> Oh, I mean 2n ofcourse =)
06:37:00 <dbueno> mmorrow: modules + something = functor or did you mean type classes + something?
06:37:01 <zax> But there isn't any way to do that computation in n?
06:37:25 <mmorrow> dbueno: i meant haskell modules + something
06:37:30 <DrSyzygyFR> Can I import "everything but x,y,z" from Prelude easily?
06:37:38 <Zao> hiding?
06:37:43 <DrSyzygyFR> quicksilver: Point.
06:37:47 <doserj> import Prelude hiding (x,y,z)
06:38:06 <mmorrow> dbueno: but aside from that, i think haskell modules and the ML modules system really address two different needs
06:38:06 <DrSyzygyFR> Thanks.
06:38:10 <byorgey> zax: sure, like this:  sum' list | s /= 3 = (list, s)  where s = sum list
06:38:15 <DrSyzygyFR> quicksilver: And for type I don\t need to derive, right?
06:38:17 <byorgey> zax: then it will only compute the sum once
06:38:20 <mmorrow> dbueno: which are separate
06:38:43 <mmorrow> dbueno: i think that neither is a good substitute for the other
06:38:56 <byorgey> DrSyzygyFR: right. type is just an alias.
06:39:14 <mmorrow> dbueno: (but since haskell won't be getting ML modules anytime soon, i'm all for searching for ways to simulate them :)
06:39:29 <EvilTerran> ML modules seem to serve a similar role to haskell typeclasses to m
06:39:29 <EvilTerran> e
06:39:49 <mmorrow> EvilTerran: firstly, you have no control over instance selection
06:39:52 <quicksilver> IMO if you're using haskell typeclasses like ML modules you're abusing them.
06:40:02 <mmorrow> and, there's no way to have abstract types
06:40:08 <mmorrow> quicksilver: me too
06:40:09 <zax> byorgey: I was thinking in the way of doing it with the filter function, so just have the filter function being sum, but can really beat the typechecker. But that seems like an excellent solution, thanks
06:40:12 <quicksilver> haskell typeclasses are a mechanism for overloading which permits polymorphism over overloaded operations.
06:40:34 <quicksilver> they are not a general abstraction.
06:41:47 <EvilTerran> i said "similar", not "identical"
06:42:15 <dev31212> Random Question...Anyone here work as a Haskell programmer, Architect, etc...
06:42:17 <quicksilver> I don't think polymorphic overloading is very similar to modularisation/abstraction/implementation hiding.
06:42:21 <dbueno> mmorrow: Now I'm confused.  YOu started out by talking about type classes vs. ML functors, but now it's Haskell modules vs. functors?
06:42:31 <dev31212> and what slaray range do you have? 50-75? 75-150? more?
06:42:35 <quicksilver> (the latter triple being what ML modules+functors are for)
06:43:12 <mmorrow> dbueno: take any combo of haskell mechanisms ==> i don't think it is a substitute for something like the ML module system
06:43:17 <mmorrow> :)
06:43:27 <dbueno> hah.  Okay.
06:43:40 <luite>     *
06:43:40 <luite>     * Friday, 13.15-15.00 in BBL 505.
06:43:46 <luite> oops :(
06:43:49 <luite> wronge paste
06:43:55 <byorgey> I'll be there!
06:44:28 <luite> hehe, it's bbl at university of utrecht, same building as hac5 :p
06:49:00 <RayNbow> luite: bah... Utrecht... too far away :p
06:50:05 <kadaver> doesnt the graph lib Data.Graph have disjkstras shortest path?
06:50:47 <RayNbow> misspelling Dijkstra's name = getting your connection reset by peer?
06:50:47 <luite> RayNbow: hehe, it was actually something from a schedule of a course last year, so you probably wouldn't find me there friday :)
06:51:16 <drhodes> RayNbow: nickserv is a harsh spell checker
06:53:42 <bremner> oh sure, not only do I have to get to Europe by friday, but last year!
06:54:17 <Acteum> well, i managed it
06:54:39 <QtPlaty[HireMe]> bremner: THe international date line will not help you.
06:54:50 <ivanm> kadaver: FGL does
06:55:05 <ivanm> bremner: what for?
06:55:37 <bremner> ivanm: we are just teasing luite
06:55:42 <paul424> who could discuss with me one tutorial regarding monads ... i don't understand something not exaclty the monads but there's something odd at the beggining ...
06:56:01 <ivanm> bremner: he doesn't say which year though...
06:56:33 <EvilTerran> paul424, go ahead
06:56:38 <Berengal> Monads are like cars
06:56:40 <QtPlaty[HireMe]> paul424: Forget the tutorial, find anouther that makes sence to you.
06:56:52 <ivanm> how many monad tutorials are we up to now?
06:57:13 * ivanm wonders what kind of function models the number of monad tutorials over time...
06:57:30 <Berengal> @users
06:57:31 <lambdabot> Maximum users seen in #haskell: 658, currently: 629 (95.6%), active: 21 (3.3%)
06:57:35 <Berengal> ivanm: ^^
06:57:56 <ivanm> Berengal: 1) that's not a function, 2) it has nothing to do with the number of monad tutorials
06:58:22 <burp_> A*exp(t) ;)
06:58:47 <DrSyzygyFR> quicksilver: Still around?
06:58:51 <ivanm> burp_: so a growth rate of 1?
06:58:55 <ivanm> and what units is t in?
06:58:56 <DrSyzygyFR> I cannot wrap my head around how to actually implement traverse for my trees.
06:58:56 <Berengal> ivanm: 1) I know. 2) It was the first figure I could find for "# of haskellers"
06:59:03 <drhodes> seconds
06:59:03 <DrSyzygyFR> traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
06:59:05 <burp_> t is time..
06:59:11 <paul424> look at the : Implementing choose; says soimeone here at #haskell asked about a backtracing for list.
06:59:12 <paul424> -- Pick one element from the list, saving a backtracking point for later on.
06:59:12 <ivanm> # of haskellers /= # of monad tutorials
06:59:14 <paul424> choose :: [a] -> a, choose xs = ...
06:59:18 <burp_> dunno.. fit it to the data
06:59:21 <ivanm> _even_ if you have # == number
06:59:25 <DrSyzygyFR> And so, on a DTLeaf b I just return DTLeaf <$> f b
06:59:34 <DrSyzygyFR> So, specifically
06:59:40 <DrSyzygyFR>     traverse f (DTLeaf b) = DTLeaf <$> f b
06:59:49 <DrSyzygyFR> But what do I do to traverse down a list of stuff?
07:00:47 <DrSyzygyFR> So I need to end up returning something of type Applicative DecoratedTree labelType leafType
07:01:03 <EvilTerran> sequenceA may be useful
07:01:04 <EvilTerran> ?type sequenceA
07:01:05 <lambdabot> Not in scope: `sequenceA'
07:01:06 <mc__> has anyone gotten the haskell SDL bindings to work under os x? I've installed the runtime libraries and compiled SDL from source. Installing the cabal package went without any problems, but when I try to import SDL. I get this: Loading package SDL-0.5.5 ... can't load .so/.DLL for: SDLmain (dlopen(libSDLmain.dylib, 9): image not found)
07:01:10 <EvilTerran> ?hoogle sequenceA
07:01:11 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
07:01:11 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
07:01:14 <Berengal> @type sequence
07:01:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:01:20 <paul424> and the solution to it is :type Choice a = [a]             choose :: [a] ->  Choice a                choose xs = xs
07:01:27 <Berengal> wrong sequence...
07:01:35 <EvilTerran> ?type foldr (liftA2 (:)) (pure []) -- is what i was thinking of
07:01:36 <lambdabot> forall a (f :: * -> *). (Applicative f) => [f a] -> f [a]
07:01:51 <Lemmih> mc__: http://darcs.haskell.org/~lemmih/hsSDL/hssdl/MACOSX
07:02:16 <Saizan> paul424: yes, the point is that it uses [a] as the representation of backtracking computations
07:02:36 <DrSyzygyFR> EvilTerran: So I can use the fact that I have sequence for lists in Applicative to make thisthing traverse my list?
07:03:01 <quicksilver> DrSyzygyFR: see my implementation of zipwithTF on the wiki
07:03:19 <quicksilver> DrSyzygyFR: http://haskell.org/haskellwiki/Foldable_and_Traversable
07:03:19 <EvilTerran> DrSyzygyFR, well, you'll need to do something to each element of a list, and you'll need something like sequence to go from a [f a] to a f [a]
07:03:22 <mc__> Lemmih: thank you, that looks very interesting
07:03:29 <Saizan> DrSyzygyFR: yeah, or you can directly use the Traversable [] instance and use traverse
07:03:56 <DrSyzygyFR> EvilTerran: So something like sequence (map traverse myList) should work?
07:04:41 <EvilTerran> DrSyzygyFR, well, it'll complain if you try to use sequence itself, because that's got a Monad constraint instead of Applicative
07:04:45 <Saizan> sequenceA (map (traverse f) myList) == traverse (traverse f) myList
07:04:51 <Peaker> DrSyzygyFR: sequence after map f   is   mapM
07:04:53 <Peaker> @src mapM
07:04:54 <lambdabot> mapM f as = sequence (map f as)
07:05:27 <EvilTerran> similarly, mapM
07:05:43 <Peaker> mapM f = sequence . map f
07:05:56 <Saizan> Peaker: ok, but that's not useful here
07:06:12 <Peaker> Saizan: I just read that out of context :)
07:06:31 <Saizan> i imagined.
07:06:37 <paul424> Saizan: how one can use the [a] for the backtacing computation ? taking head and tail ?
07:06:43 <Peaker> @hoogle Applicative f => (a -> f b) -> [a] -> f [b]
07:06:44 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:06:44 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
07:06:44 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
07:07:08 <EvilTerran> for = flip traverse, iirc
07:07:11 <Peaker> ah, didn't know traverse was just the generalization of mapM
07:07:23 <Peaker> cool :-)
07:07:31 <dbueno> What's the easiest way to find out how the Ord instance for lists is implemented?
07:07:32 <EvilTerran> generalization in two different ways, at that
07:07:36 <Saizan> paul424: i think the rest of the tutorial should explain that
07:07:39 <Saizan> paul424: which is it?
07:07:45 <Peaker> @src [] (>)
07:07:46 <lambdabot> Source not found. stty: unknown mode: doofus
07:07:47 <EvilTerran> ?src [] compare
07:07:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
07:07:51 <EvilTerran> ?src [] Ord
07:07:51 <lambdabot> Source not found.
07:07:57 <EvilTerran> ...no?
07:07:58 <Peaker> ?src [] Monad
07:07:59 <lambdabot> Source not found. Maybe you made a typo?
07:08:04 <paul424> Saizan: http://www.randomhacks.net/articles/2007/03/12/monads-in-15-minutes
07:08:09 <Peaker> I think @src is only for single methods, not whole classes
07:08:13 <Saizan> dbueno: lexycografic ordering
07:08:28 <dbueno> Saizan: Yeah, I'm wondering about laziness properties
07:08:46 <dbueno> like if xs < ys will only force the head of each list
07:09:06 <dbueno> I guess I could use ghci
07:09:18 <EvilTerran> dbueno, i think it's specified as "data [a] = [] | a : [a] deriving (Eq, Ord)"
07:09:24 <DrSyzygyFR> quicksilver: I have the wikipage. What does it tell me? *too many functors*
07:09:55 <EvilTerran> Peaker, i find what is or isn't in @src to be fairly arbitrary
07:10:07 <dbueno> > [1..] < [2..]
07:10:10 <lambdabot>   True
07:10:12 <quicksilver> DrSyzygyFR: it shows you how to zip a list against your newly-traversable tree structure.
07:10:17 <dbueno> > [1..] > [2..]
07:10:19 <lambdabot>   False
07:10:20 <quicksilver> (actually any foldable, but you just want a list)
07:10:21 <dbueno> > [1..] == [2..]
07:10:22 <lambdabot>   False
07:10:22 <Peaker> EvilTerran: yeah, it could be awesome if it was automatically kept complete and up-to-date somehow
07:10:25 <dbueno> I guess it's lazy.
07:10:33 <quicksilver> Peaker: no it wouldn't.
07:10:40 <quicksilver> Peaker: it would be a godawful source of spam in this channel.
07:10:51 <quicksilver> if you want to read the library source, use your web browser :P
07:10:51 <Saizan> paul424: it doesn't give much details, but the point is that a backtracking computation is simply one that returns 0,1,or more results, and that's exactly a list of results
07:11:15 <Peaker> quicksilver: the web is much slower than lambdabot on IRC, for unknown reasons (possible web suckage)
07:11:34 <Saizan> paul424: in the end it models depth first backtracking, because of lazyness and the way join works
07:11:34 <Peaker> and lambdabot's UI is nicer, too
07:12:32 <paul424> Saizan: ohh I thought of backtracing as the way you try to explore the space of posibble solution like in Prologue, not as the possible set containning 0 or more solutions
07:12:41 <quicksilver> Peaker: if it was /query only that might be OK.
07:13:37 <Saizan> paul424: the nice thing is that, apart from cut, you get the same behaviour in the end
07:13:56 <DrSyzygyFR> Why won't this work?
07:13:57 <DrSyzygyFR>     traverse f (DTVertex t a ts) = (DTVertex t a) (sequenceA (map (traverse f) ts))
07:14:30 <Peaker> DrSyzygyFR: does it type-check?
07:14:30 <Saizan> DrSyzygyFR: what's your type definition?
07:14:32 <DrSyzygyFR> (given that ts is a list containing the thingies I'm instantiating Traversable on, and that I already have a working function for the DTLeaf ?
07:14:39 <EvilTerran> i thought DTVertex only had one parameter
07:15:05 <DrSyzygyFR> Saizan: My type is PreDecoratedTree a b = DTLeaf b | DTVertex a Int [DecoratedTree a b]
07:15:19 <EvilTerran> ah
07:15:20 <DrSyzygyFR> EvilTerran: I'm hanging the cruft back in now. :-P
07:15:33 <Saizan> ah
07:15:33 <DrSyzygyFR> EvilTerran: That way I can paste code, and discuss it.
07:15:39 <Saizan> you want <$>
07:15:40 <DrSyzygyFR> Doh.
07:15:44 <DrSyzygyFR> PreDecorated everywhere.
07:15:52 <DrSyzygyFR> Saizan: Where?
07:15:55 <Saizan> (DTVertex t a) <$> (sequenceA (map (traverse f) ts))
07:16:01 <DrSyzygyFR> Ah.
07:16:13 <EvilTerran> you can drop both the outer sets of ()s there
07:16:19 <DrSyzygyFR> WOOOOOOT!
07:16:22 <DrSyzygyFR> It compiles!!!!
07:16:25 <harovali1> is there a haskell functional dependency processing library ?
07:16:35 <Saizan> DTVertex t a <$> sequenceA (map (traverse f) ts) == DTVertex t a <$> traverse (traverse f) ts
07:17:00 <harovali1> functional dependency like "data dependency"
07:17:33 <kadaver> if you have fromList :: [a] -> Queue a; what do you expect to be in the front of the queue when you do: fromList [1,2,3] ?
07:17:47 <Saizan> 1
07:17:50 <EvilTerran> 1
07:17:54 <Deewiant> I expect the first thing to come out to be 3
07:18:00 <bremner> 5
07:18:12 <QtPlaty[HireMe]> kadaver: I dodn't expect anything unless I have a spec.
07:18:17 <bremner> err, 6
07:18:43 <kadaver> I mean when you do: pop on the queue, what do you expect to get?
07:18:47 <Saizan> Deewiant: why? don't you usually append in a list?
07:18:59 <Saizan> s/list/queue/
07:19:18 <QtPlaty[HireMe]> What makes the most sence though.
07:19:23 <QtPlaty[HireMe]> Its the first in.
07:19:23 <Deewiant> The default lists work a lot like stacks IMO, with (:) = push
07:19:28 <DrSyzygyFR> What's a good thing to test traversables with?
07:19:36 <Deewiant> Which is why I might expect (:) = enqueue also
07:20:02 <bremner> Deewiant: but that misses the point of a seperate type
07:20:02 <QtPlaty[HireMe]> Deewiant: I don't see it.
07:20:26 <Deewiant> bremner: How's that?
07:20:32 <Deewiant> QtPlaty[HireMe]: Which part?
07:20:33 <Saizan> DrSyzygyFR: print ?
07:20:37 <QtPlaty[HireMe]> enqueue q x = q ++ [x]
07:20:52 <bremner> Deewiant: (:) is an implementation detail
07:20:54 <Deewiant> No, enqueue = flip (:). :-)
07:20:59 <QtPlaty[HireMe]> I don't see using (:) for enqueue.
07:21:04 <DrSyzygyFR> Saizan: I mean ... what can I use as input to Traverse to get interesting results?
07:21:07 <Deewiant> bremner: Yes, of course, but we're talking about what fromList should do, given a list.
07:21:08 <pozic> QtPlaty[HireMe]: do you want to get an award for slowest implementation of a queue ever?
07:21:23 <mmorrow> @src quot
07:21:24 <lambdabot> Source not found. You untyped fool!
07:21:40 <bremner> Deewiant: I think fromList should call reverse
07:21:46 <QtPlaty[HireMe]> pozic: Give me some time I can think of a worse one.
07:21:55 <DrSyzygyFR> Also, to return this to my original question... Now that I have Traversable, how can I set the values at the leaves of my tree to be taken from a specific list?
07:21:58 <mc__> Lemmih: I do not have much experience with cabal, how do I use that SDL.cabal file?
07:22:14 <Deewiant> bremner: That's an option, certainly.
07:22:42 <mmorrow> @src quotRem
07:22:43 <lambdabot> Source not found. I feel much better now.
07:23:18 <QtPlaty[HireMe]> If your using a list to impmenent a queue either enqueue or dequeue is going to end up O(N)
07:23:21 <Saizan> DrSyzygyFR: you can use the state monad and a function like \_ -> do (x:xs) <- get; put xs; return x
07:23:47 <bremner> anyway, I think enqueue on left, dequeue on right is the most natural mental model, but maybe that is because I don't read Hebrew
07:23:47 <Saizan> DrSyzygyFR: and then runState using that list as initial state
07:24:10 <Deewiant> bremner: I agree.
07:24:24 <mlesniak> Anyone knows how good the GHC support for the Power6 architecture is (if it exists at all)?
07:25:27 <mmorrow> ummm, what is supposed to be the difference between `quotRem' and `divMod' ?
07:25:32 <DrSyzygyFR> Saizan: Huh??
07:25:52 <vixey> > quotRem (-13) 4
07:25:54 <lambdabot>   (-3,-1)
07:25:56 <vixey> > divMod (-13) 4
07:25:57 <lambdabot>   (-4,3)
07:26:22 <Saizan> > runState (mapM (\_ -> do (x:xs) <- get; put xs; return x) "hello world") [1..]
07:26:23 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11],[12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
07:26:35 <mmorrow> vixey: ahh, nice
07:26:41 <Saizan> > fst $ runState (mapM (\_ -> do (x:xs) <- get; put xs; return x) "hello world") [1..]
07:26:42 <mmorrow> wasn't considering negatives..
07:26:42 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
07:26:48 <Saizan> DrSyzygyFR: ^^^^
07:27:07 <Saizan> DrSyzygyFR: only with your tree instead of "hello world" and traverse instead of mapM
07:27:13 <Deewiant> @check quotRem a b == divMod a b
07:27:15 <lambdabot>   "Falsifiable, after 0 tests:\n"
07:27:23 <Deewiant> @check \a b -> quotRem a b == divMod a b
07:27:24 <lambdabot>   "* Exception: divide by zero
07:27:25 <vixey> lol
07:27:32 <Saizan> DrSyzygyFR: well, or Data.Traversable.mapM
07:27:36 <Deewiant> @check \a b -> b == 0 || quotRem a b == divMod a b -- gah
07:27:37 <lambdabot>   "Falsifiable, after 3 tests:\n-2\n3\n"
07:27:47 <Berengal> @check (\a b -> b /= 0 ==> let (q, r) = quotRem a b in (q*b) + r == a)
07:27:48 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
07:27:49 <lambdabot>           ...
07:27:57 <Deewiant> Bzzt. No ==> for you!
07:28:32 <Berengal> @check (\a b ->  let (q, r) = quotRem a b in b == 0 || (q*b) + r == a)
07:28:33 <lambdabot>   "OK, passed 500 tests."
07:28:42 <Berengal> @check (\a b ->  let (q, r) = divMod a b in b == 0 || (q*b) + r == a)
07:28:43 <lambdabot>   "OK, passed 500 tests."
07:29:37 <Berengal> Why no ==>?
07:29:46 <Saizan> bug
07:30:47 <DrSyzygyFR> Saizan: Big and obscure error message. :-(
07:32:50 <Saizan> DrSyzygyFR: can you paste the code and the error on hpaste.org ?
07:33:47 <Peaker> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html -- doesn't seem to document what kinds of sockets its using
07:33:54 <Peaker> any idea what sockets the "high-level" api is using?
07:34:33 <DrSyzygyFR> Saizan:     No instance for (Applicative (Control.Monad.State.Lazy.State [b]))
07:36:37 <Gracenotes> > "halo"
07:36:39 <lambdabot>   "halo"
07:37:54 <Saizan> DrSyzygyFR: right, you can either write that instance yourself, or use mapM that uses Monad
07:38:10 <Saizan> DrSyzygyFR: the mapM from Data.Traversable i mean
07:38:27 <DrSyzygyFR> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4092
07:38:50 <DrSyzygyFR> Wait.
07:38:59 <DrSyzygyFR> WOOOOT!
07:39:08 <DrSyzygyFR> mapM and keeping track of which should be what did the trick!!!
07:39:52 <kadaver> I mean when you do: pop on the queue, what do you expect to get?
07:39:57 <flazz> what is a good streetwise definition of a combinator? i think i wrote one but i'm not sure
07:40:00 <Peaker> @index mapM
07:40:01 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:40:12 <kadaver> pop $ fromList [1,2,3]
07:40:12 <quicksilver> DrSyzygyFR: I think we have lead you down a rather long path to your destination. I hope the journey was interesting ;)
07:40:14 <kadaver> 1 or 3?
07:41:03 <quicksilver> kadaver: 1 I
07:41:05 <quicksilver> suppose
07:41:09 <quicksilver> not sure it matters much :)
07:41:44 <DrSyzygyFR> quicksilver: It was. And I have quite a bit to go before this is done.
07:42:02 <DrSyzygyFR> But the things I've implemented to get THIS to work will be VERY useful later on.
07:42:30 <DrSyzygyFR> So ... now ... If I want to replace every leaf in a tree with a new tree given in a list, then I probably should be able to do something similar, right?
07:42:41 <Deewiant> kadaver: 3 IMO :-)
07:42:47 <Deewiant> If Queue, that is.
07:42:52 <Deewiant> For Stack, definitely 1.
07:43:28 <Gracenotes> flazz: in Haskell..? informally, probably something that takes 2 or more 'things' and makes a 'thing' that has behavior based on its components
07:43:54 <Saizan> DrSyzygyFR: that sounds like the above function + join for your tree
07:43:57 <Berengal> Assuming you're pushing and popping a queue an equal amount of times, wouldn't some other structure than a list be better?
07:44:03 <DrSyzygyFR> Let's see if I understand what we did... At each leaf, I introduce a monad action, that gets executed by runState, that reads the first thing off of a list. Right?
07:44:34 <Saizan> DrSyzygyFR: right
07:45:48 <Saizan> the actions are sequences in the order specified by your traverse
07:45:55 <Saizan> *sequenced
07:46:20 <quicksilver> not just that
07:46:32 <quicksilver> also the results are shoved into the shape of the structure
07:46:43 <quicksilver> whilst the actions are being sequenced
07:46:54 <quicksilver> it's doing both at once which is clever (and that's what Traversable is for)
07:47:13 <DrSyzygyFR> I think I got that!
07:47:36 <DrSyzygyFR> I didn't bother making an explicit monad instance, since I only want join specifically.
07:48:04 <DrSyzygyFR> But I now have a join (named glueTrees to help the operadchiks) and it works wonders, using my leaf relabeling to insert the trees before gluing them in place!!
07:48:16 <quicksilver> mwahahaha.
07:49:17 <kadaver> Berengal: it is Data.Sequence
07:49:29 <quicksilver> instance Monad (DecoratedTree) where return = DTLeaf; a >>= f = glueTrees (fmap f a)
07:49:35 <DrSyzygyFR> SRSLY?
07:49:36 <DrSyzygyFR> Thanks!!
07:49:38 <quicksilver> DrSyzygyFR: there's the monad instance which you don't want.
07:49:40 <quicksilver> I think
07:50:03 <quicksilver> quite possibly it's not actualy useful
07:50:14 <kadaver> well one would expecthe ooposit eof what a stack does sosovled, it returns 3
07:50:24 <DrSyzygyFR> But if it is that easy, I see no reason not to include it.
07:57:16 <mmorrow> i'm confused about arithmetic shift left on _signed_ numbers. so, 1000|0001 `shiftLArith` 1 == 1000|0010, right?
07:57:27 <mmorrow> (where the leftmost bit is the sign bit)
07:57:59 <mmorrow> i'm confused, because the (at least two) places i've read for a behavior spec have not said this
07:58:12 <mmorrow> but, both C and haskell have this behavior
07:58:31 <mmorrow> so either i'm reading the descriptions wrong, the descriptions are wrong, or i
07:58:35 <mmorrow> 'm insane
07:59:13 <Deewiant> That's not what the x86 instructions do, at least
08:00:17 <mdmkolbe> Is there some flag to either (1) allow kind declarations on type synonyms or (2) allow type synonyms to be only partially applied?
08:00:28 <mmorrow> > (\x->fmap ((.&.0x01).(x`shiftR`))[63,62..0]) (-1 :: Int)
08:00:29 <lambdabot>       Ambiguous occurrence `.&.'
08:00:29 <lambdabot>      It could refer to either `Data.Bits..&....
08:00:34 <Deewiant> I've always been taught that left shift is the same thing whether logical or arithmetic
08:00:35 <mmorrow> > (\x->fmap ((Data.Bits.&.0x01).(x`shiftR`))[63,62..0]) (-1 :: Int)
08:00:36 <lambdabot>   Not in scope: `Data.Bits.&.'
08:00:47 <Saizan_> mdmkolbe: KindSignatures ?
08:00:47 <Deewiant> mmorrow: ..&.
08:01:00 <mmorrow> Deewiant: yeah, that's what everywhere says, but then wouldn't (-1 << 1) be == 2 ?
08:01:12 <mmorrow> (because the sign bit gets shifted out)
08:01:17 <mmorrow> > (\x->fmap ((Data.Bits..&.0x01).(x`shiftR`))[63,62..0]) (-1 :: Int)
08:01:18 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
08:01:19 <Deewiant> Yes, it should be
08:01:27 <mmorrow> um
08:01:36 <mdmkolbe> Saizan_: that works, thanks
08:01:39 <mmorrow> , -1 `shiftL` 1 :: Int
08:01:40 <lunabot>  -2
08:01:40 <JaffaCake> ghc meeting over in #ghc, if anyone's interested
08:02:18 <doserj> mmorrow: -1 = 1111..1 in 2-complement binary
08:02:20 <mdmkolbe> Saizan_: I spoke too soon
08:02:33 <mdmkolbe> JaffaCake: what is the meeting on?
08:02:39 <Deewiant> doserj: Ah right, that's what I was confused about
08:02:45 <JaffaCake> whatever people want to talk about!
08:03:34 <morphir> should I choose lch or ghc? quite the difference in size :D
08:03:57 <Peaker> module-accessor being dot is pretty confusing
08:03:58 <EvilTerran> mdmkolbe, i don't think you can ever apply a type synonym less than it's applied in its definition; doing so would break things
08:04:00 <mmorrow> doserj: :o
08:04:03 <mdmkolbe> Saizan_: KindSignatures only seems to allow "type Foo (f :: * -> *) = ...".  I want "type Foo :: * -> * = ..."
08:04:19 * mmorrow clearly needs to learn about these computer things
08:04:29 <Saizan_> mdmkolbe: what do you have on the RHS?
08:04:38 <Peaker> mdmkolbe: just use point-ful notation?  type Foo a = ... a  ?
08:04:40 <EvilTerran> mdmkolbe, you can write things like "type List = []", and then List can be used without its parameter
08:04:45 <mdmkolbe> Saizan_: "type Foo = Either Int"
08:04:52 <mdmkolbe> which is legal
08:04:53 <EvilTerran> mdmkolbe, that should work on its own
08:04:58 <Saizan_> mdmkolbe: that should work as it is
08:05:14 <mdmkolbe> but for clarity I want to add the kind
08:05:36 <Saizan_> ah, ok, i don't think there's a way then
08:05:46 <Saizan_> you can add a comment
08:05:49 <mdmkolbe> (or actually add the parameter, but then I would have to partially apply the type synonym else where)
08:06:25 <mdmkolbe> yeah, I though about "type Foo {-b-} = Either Int {-b-}", but I'm not sure that is clear
08:06:44 <Saizan_> -- Foo :: * -> *
08:06:48 <EvilTerran> or "type Foo = Either Int -- * -> *"
08:07:04 <EvilTerran> "... -- :: * -> *" if you prefer :)
08:08:54 <mdmkolbe> Thanks for the input, gtg
08:10:56 <dev31212> ?type (Just 5)
08:10:57 <lambdabot> forall t. (Num t) => Maybe t
08:11:17 <dev31212> ?type error "Foo bared"
08:11:19 <lambdabot> forall a. a
08:11:37 <harovali1> is it bad to define classtypes in the prelude command line in ghci?
08:11:59 <harovali1> sorry
08:13:34 <titusg> I'm trying to use cabal to upgrade the unix package to 2.3.2 but it seems to be broken: error compiling Internals.hs Module `GHC.Conc' does not export `Signal'
08:13:52 <harovali1> well, i'm getting syntax error when I type     data MyType = MyValue1 | MyValue2          interactively in ghci . any hint ?
08:14:04 <quicksilver> harovali1: yes. you cannot define datatypes directly in ghci
08:14:09 <quicksilver> harovali1: put them in a file and load it in.
08:14:20 <harovali1> quicksilver: it would be very useful, wouldn't ?
08:15:58 <harovali1> anyway
08:15:59 <quicksilver> harovali1: yes.
08:16:03 <quicksilver> but there you go.
08:17:50 <harovali1> quicksilver: thanks
08:18:27 <Saizan_> titusg: you can't upgrade to that version of unix on ghc < 6.10.2, the unix.cabal is broken for not requiring base >= 4.1
08:19:24 <dbueno> titusg: if it's just the cabal file that's broken, you could try "cabal install unix --constraint='base >= 4.1'" I think
08:19:39 <titusg> Saizan_: thanks
08:20:01 <dbueno> never mind, I misunderstood.
08:25:54 <titusg> I don't understand why cabal wants to upgrade unix when upgrading xmonad - AFAICS there is no version no. in xmonad.cabal, just the package name.
08:27:30 <titusg> ah, cos my unix pkg is global and cabal is looking at user pkgs
08:41:39 <dbueno> > let leq (x:_) (y:_) = x == y in leq [1:undefined] [2:undefined]
08:41:40 <mholub> does anyone here try to use yi?
08:41:41 <lambdabot>   False
08:41:46 <dbueno> so far so good, but:
08:41:52 <dbueno> > let leq (x:_) (y:_) = x == y in leq [1:undefined] [1:undefined]
08:41:54 <lambdabot>   * Exception: Prelude.undefined
08:42:00 <dbueno> Why does that leq call blow up?
08:42:42 <vixey> > let leq (x:_) (y:_) = x == y in leq [1:undefined] [1:undefined]
08:42:43 <lambdabot>   * Exception: Prelude.undefined
08:42:50 <vixey> > let leq (x:_) (y:_) = x == y in leq [1] [1]
08:42:52 <lambdabot>   True
08:42:54 <int80_h> hey #haskell!
08:42:57 <vixey> > let leq (x:_) (y:_) = x == y in leq [1,undefined] [1,undefined]
08:42:59 <lambdabot>   True
08:43:05 <vixey> > let leq (x:_) (y:_) = x == y in leq (1:undefined) (1:undefined)
08:43:06 <lambdabot>   True
08:43:06 <dbueno> vixey, oh, ugh I'm a moron.
08:43:11 <vixey> no you are not
08:43:14 <dbueno> I see it now.
08:44:03 * QtPlaty[HireMe] doesn't.
08:44:04 <dbueno> thanks.
08:44:21 <QtPlaty[HireMe]> Oh I see it now.
08:44:28 <int80_h> once, a few months back, there was mention of an astronomy grad student using haskell in their work. I never made bookmarks of course, and now I need to find the relevant urls. Can someone help me find them?
08:44:42 <int80_h> I did some rudimentary searches on google, to no avail
08:45:21 <dev31212> google for "astronomy academic project haskell"
08:45:36 <int80_h> ah, my google search was wrong...okay I will
08:46:17 <dev31212> http://www.google.com/url?sa=U&start=4&q=http://www.absoluteastronomy.com/topics/Haskell_(programming_language)&ei=sjvvSbuzL5Xhtgf2l7HMDw&sig2=x0hFzGnL-D7aJW9Ve9aL6g&usg=AFQjCNHqDvezz3CaqZnXcMU7QxxkOcpmSw
08:46:24 <dev31212> check that link..maybe that is it
08:46:29 <dev31212> or can point you in the rigt direction
08:47:46 <int80_h> oh, yeah I found that page
08:47:56 <int80_h> nope that's no good
08:48:08 <int80_h> well, I can always send mail to haskell cafe.
08:50:30 <bremner> SETEC ASTRONOMY
08:51:22 <kadaver> where is zip4?
08:51:55 <kadaver> could you implement a zipX with fold?
08:52:17 <vixey> I think zip is an unfold
08:53:02 <kadaver> where is unfoldr?
08:53:06 <kadaver> and zip4
08:53:10 <TomMD> @hoogle zip4
08:53:10 <lambdabot> Data.List zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]
08:53:11 <lambdabot> Data.List unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])
08:53:12 <TomMD> there
08:54:34 <EvilTerran> ?hoogle unfoldr
08:54:35 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:54:35 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
08:54:35 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:57:52 <EvilTerran> > getZipList $ (,,) <$> ZipList [1..] <*> ZipList ['a'..] <*> ZipList (cycle [True,False])
08:57:56 <lambdabot>   [(1,'a',True),(2,'b',False),(3,'c',True),(4,'d',False),(5,'e',True),(6,'f',...
08:58:02 <EvilTerran> ^ there's a general zipper
08:58:47 <vixey> > map (\(x,(y,z)) -> (x,y,z)) $ zip [1..] (zip ['a'..] (cycle [True,False]))
08:58:48 <lambdabot>   [(1,'a',True),(2,'b',False),(3,'c',True),(4,'d',False),(5,'e',True),(6,'f',...
08:59:30 <EvilTerran> > let infixl 4 `zap`; zap = zipWith ($) in repeat (,,) `zap` [1..] `zap` ['a'..] `zap` cycle [True,False]
08:59:31 <lambdabot>   [(1,'a',True),(2,'b',False),(3,'c',True),(4,'d',False),(5,'e',True),(6,'f',...
09:02:49 <kadaver> show me an unfoldr
09:02:54 <kadaver> src unfoldr
09:02:58 <kadaver> @src unfoldr
09:02:59 <lambdabot> unfoldr f b  = case f b of
09:02:59 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
09:02:59 <lambdabot>    Nothing        -> []
09:03:30 <kadaver> hmm
09:04:13 <jmcarthur> unfoldr (\x -> if x >= 0 then Just (x, x-1) else Nothing) 5
09:04:23 <jmcarthur> > unfoldr (\x -> if x >= 0 then Just (x, x-1) else Nothing) 5
09:04:25 <lambdabot>   [5,4,3,2,1,0]
09:05:07 <jmcarthur> kadaver, see http://billmill.org/roman.html
09:05:27 <jmcarthur> my code, somebody else's blog
09:06:36 <dschoepe> Is there a reason there's no instance for Enum a => Enum (Dif a) in the numbers-package or has it just been forgotten?
09:07:23 <EvilTerran> Dif?
09:07:28 <dschoepe> Yes
09:07:33 <dschoepe> In Data.Numbers.Dif
09:07:52 <dschoepe> http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/Data-Number-Dif.html
09:08:58 <mholub> How can I install parsec 3 using cabal?
09:09:15 <EvilTerran> dschoepe, er, looks like an oversight
09:09:22 <int-e> dschoepe: there's a reason: Dif is a pair, so the conversion would be lossy
09:09:39 <EvilTerran> you might be able to "deriving instance Enum Dif" with the right extensions
09:09:42 <Saizan_> mholub: cabal install "parsec >= 3"
09:09:59 <mholub> oh..thanks.. I tried cabal install parsec
09:10:10 <kadaver> > readFile "Blah" >>= \r -> repeat r
09:10:11 <lambdabot>   Couldn't match expected type `IO b'
09:10:22 <EvilTerran> or the old-fashioned way, with dCon
09:11:30 <dschoepe> EvilTerran: Yes, it worked when I did that, I just wanted to know whether it should be in the package.
09:13:34 <kadaver> a = readFile "C:/ghc/ghc-6.10.2/progs/cabalfiles/Queue.cabal" >>= \r -> split r ' '
09:13:39 <kadaver> why wrong`?
09:14:07 <EvilTerran> ?type (>>=)
09:14:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:14:10 <int-e> @index split
09:14:11 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
09:14:33 <EvilTerran> kadaver, the function on the right of >>= must return an IO {something} in this context
09:16:46 <kadaver> a = readFile "C:/ghc/ghc-6.10.2/progs/cabalfiles/Queue.cabal" >>= \r -> split r ' '
09:17:40 <kadaver> isnt ouldn't match expected type `IO b'
09:17:40 <kadaver>            against inferred type `[String]'
09:17:40 <kadaver>     In the expression: split r ' '
09:17:51 <Phyx-> lol
09:18:04 <jmcarthur> kadaver, problems?
09:18:20 <kadaver> yeah
09:18:26 <Phyx-> kadaver, the error pretty much says what's wrong, the rhs of >>= must return a computation in a monad
09:18:40 <kadaver> rhs?
09:18:46 <jmcarthur> right hand side
09:18:55 <Phyx-> \r -> return $ split r ' ' would work
09:19:26 <Phyx-> also you probably meant to bind it to a instead of assigning to a. a <- instead of a =
09:19:30 <kadaver> i always forget return
09:23:07 <quicksilver> .... >>= return ... has a name
09:23:10 <quicksilver> it's called 'fmap'
09:23:13 <quicksilver> (or liftM if you must)
09:23:25 <Deewiant> Or liftA
09:23:36 <doserj> or <$>,
09:24:27 <kadaver> ah fmap words $ readFile blah
09:24:28 <kadaver> neat
09:24:43 <dbueno> words <$> readFile blah
09:24:50 <dbueno> (import Control.Applicative)
09:25:03 <guenni> how can I create a delay, or sleep?
09:25:06 <Deewiant> threadDelay
09:25:08 <quicksilver> guenni: threadDelay
09:25:09 <kadaver> liftM = outta tha monad, into tha monad
09:25:16 <guenni> thx
09:26:39 <kadaver> #emacs is dead, does anyoen know how to jump to a char in a dir-list?
09:26:47 <kadaver> the marker is at a i want to p
09:37:05 <kadaver> bah trying to implement dijkstars algorithm in haskell
09:37:17 <kadaver> is like drinking acid and trying not to scream
09:37:24 <kadaver> of pain
09:37:27 <kadaver> oh the agony
09:37:46 <Hunner> oh that acid
09:38:31 <kadaver> oh that huner
09:38:37 <seliopou> doesn't fgl have an implementation?
09:39:49 <jeffersonheard> kadaver, when you get done with that, tell me and I'll ask you to implement MDS in haskell
09:40:10 <seliopou> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-SP.html
09:54:02 <jeffersonheard> slience falls upon the crowd as they contemplate an N^2 array based graph layout algorithm implemented in Haskell...
10:01:09 <twanvl> Are there any Functors f for which there is a function of type   ((a -> b) -> (c -> d))  ->  ((f a -> b) -> (f c -> d))
10:02:48 <twanvl> I can think only of ((,) x)
10:03:46 <TomMD> @hoogle :: ((a -> b) -> (c -> d))  ->  ((f a -> b) -> (f c -> d))
10:03:47 <lambdabot> No results found
10:04:04 <dolio> Anything which is both pointed and copointed.
10:04:10 <Cadynum> hi. im looking into hosting a project on code.haskell.org (my first in haskell - code is probably ugly). it says you have to request it, how serious does the project have to be for the request to get accepted?
10:05:03 <twanvl> dolio: are there any functors besides Identity that are both pointed and copointed?
10:05:09 <Cale> Cadynum: They accept a lot of projects. You should also note that it's easy to add things to hackage.
10:05:18 <TomMD> Cadynum: More than a toy, but it doesn't have to be some full-blown industrial library.  The bar is a little too low imo, we should try to limit namespace pollution.
10:05:22 <dolio> twanvl: (,) x is one. :)
10:05:35 <twanvl> (,) x is not pointed, is it?
10:05:37 <dolio> For monoids x, on the pointed end.
10:05:43 <jeffersonheard> Okay, here's a weird one.  I have a package where I catch exceptions.  I initially just did something in the handler like (\ex -> ...).  That worked fine and built... once.
10:05:57 <twanvl> yes
10:05:57 <jeffersonheard> subsequent clean builds fail saying that the exception type needs to be nailed down
10:06:22 <jeffersonheard> so I added (\(ex::SomeException) -> ...) instead to the handler
10:06:34 <jeffersonheard> and that builds as well.   once.  then it whines that SomeException isn't in scope
10:06:38 <Cale> Cadynum: If you write a .cabal file and get an account on Hackage, you can upload your code there, supposing that you don't really need fine version control (like darcs).
10:06:43 <jeffersonheard> has anyone ever seen this behaviour?
10:06:58 <jmcarthur> twanvl,  streams are pointed and copointed, as well
10:07:28 <Cadynum> TomMD, its just an irc-bot with a game specific polling system (tremulous) and some other functions. its about 1100 lines
10:08:59 <Cadynum> Cale, alright. will keep that in mind. i would like some kind of revision control however, if anything for the experience. so if its not "serious" enough i can just stick it somewhere else and upload it to hackage nonetheless anyway i guess
10:09:16 <Cale> Cadynum: yeah
10:09:45 <pumpkin> the n+k patterns discussion is ridiculous
10:09:58 <pumpkin> so much hyperbole being thrown around :P
10:10:13 <pumpkin> "YOU'RE SAYING ALL MY PROGRAMS ARE WORTHLESS AND THAT I'M A TERRIBLE PERSON!!!!"
10:10:18 <Cale> pumpkin: People care about n+k patterns?
10:10:22 <pumpkin> on -cafe
10:10:27 <pumpkin> on the UHC thread :)
10:10:32 <pumpkin> apparently some do
10:11:12 <tromp> can't they just be considered syntactic sugar?
10:11:19 <Cale> They are.
10:12:01 <bremner> so are multiple equations
10:12:28 <tromp> i guess they seem a little inconsistent, since there's no n-k pattern
10:12:31 <Cale> I think we should have prime factorisation structure patterns
10:12:37 <tromp> or a 2*n pattern
10:12:40 <pumpkin> people just seem to be getting really worked up over it
10:12:50 <pumpkin> tromp: or an n*m pattern, as CAle said :)
10:13:07 <pumpkin> f (product x) = x
10:13:08 <pumpkin> :P
10:13:12 <Cale> p_1^n_1 ... p_k^n_k patterns
10:13:41 <pumpkin> f (product x) = rle x
10:13:44 <pumpkin> there
10:14:12 <tromp> isPrime (m*n) = False; isPrime p = true;
10:14:57 <dolio> They are rather evil. They're defined by tunneling through Integer, as I recall.
10:14:58 <pumpkin> it's just disconcerting how much crap is being thrown around in that discussion :P
10:15:20 <mercury^> Cale: that would be immensely useful for project euler...
10:15:25 <mercury^> But what algorithm to use?
10:15:26 <dolio> So they have nothing necessarily to do with (+) and (-) on your type.
10:15:46 <Cale> mercury^: Implementation specified.
10:15:53 <tromp> i cant say that n+k pattern offer a significant increase in readability
10:16:04 <pumpkin> yeah, me neither
10:16:30 <pumpkin> but the whole "you're disrespecting the H98 people by not implementing n+k patterns seems so ridiculous"
10:16:32 <tromp> not much difference between fib (n+2) = fib n + fib (n+1)  or fib n = fib (n-1) + fib (n-2)
10:16:37 <pumpkin> or "you think my software is worthless because it's not public"
10:16:52 <pumpkin> yeah, especially since both are ridiculously inefficient
10:17:00 <bremner> pumpkin: I actually agree with that :-)
10:17:07 <pumpkin> which bit?
10:17:15 <bremner> not public
10:17:22 <pumpkin> he wasn't saying that though :P
10:17:34 <pumpkin> he was saying that in the public code he surveyed, he didn't see any n+k patterns :P
10:17:40 <pumpkin> there's not much he can do beyond that
10:18:12 <pumpkin> taking offense at that statement is just derailing the argument
10:18:26 <bremner> possibly stupid question, are n+k patterns supported by a ghc extension, or is that the argument?
10:18:36 <pumpkin> they're supported directly in GHC
10:18:41 <pumpkin> it's H98
10:18:46 <pumpkin> but UHC didn't implement them
10:18:46 <Igloo> They're not an extension, they're in H98
10:18:52 <pumpkin> and that's where the argument started
10:18:56 * Peaker had to read the code of the Network package to understand that the "high-level" interface does TCP
10:19:04 <bremner> possibly stupid question. heh.
10:19:14 <pumpkin> like, "ZOMG YOU DIDN'T IMPLEMENT H98 YOU THINK YOU'RE SO COOL THAT YOU DON'T NEED TO FOLLOW STANDARDS"
10:19:21 <Peaker> are n+k patterns specifically for integral numbers or are they more general?
10:19:21 <pumpkin> :P
10:19:28 <pumpkin> just naturals
10:19:37 <pumpkin> they don't even work for negatives
10:19:38 <pumpkin> :P
10:19:41 <pumpkin> arguably a feature
10:19:42 <Peaker> so their benefit is avoiding subtraction?
10:19:54 <tromp> can be be negative?
10:19:56 <glguy> they use subtraction in the implementation
10:19:58 <tromp> can k
10:20:08 <glguy> no
10:20:17 <Peaker> Yeah, I mean avoiding subtraction in the code?  They sound pretty pointless
10:20:20 <glguy> n+k patterns only match positive numbers
10:20:30 <Peaker> I guess they sound meaningful if you read a lot of Haskell tutorials and see a lot of implementations of the factorial recursion :)
10:20:31 <pumpkin> yeah, that's what I meant, sorry
10:20:37 <glguy> :t let f (n+1) = n
10:20:38 <lambdabot> <no location info>: not an expression: `let f (n+1) = n'
10:20:39 <glguy> :t let f (n+1) = n in f
10:20:40 <lambdabot> forall t. (Integral t) => t -> t
10:20:50 <doserj> well, the k in n+k can only be positive. it can match against negative numbers, though
10:20:57 <glguy> no
10:21:02 <pumpkin> > let f (n+1) = n in f 0
10:21:04 <lambdabot>   * Exception: /tmp/7569453551156287514:71:44-54: Non-exhaustive patterns in ...
10:21:06 <tromp> so k cannot be 0 either?
10:21:17 <pumpkin> > let f (n+k) = n in f (-1)
10:21:18 <lambdabot>   <no location info>: Parse error in pattern
10:21:20 <pumpkin> > let f (n+0) = n in f (-1)
10:21:21 <doserj> ahh, true
10:21:22 <lambdabot>   * Exception: /tmp/3036093142527827221:71:44-54: Non-exhaustive patterns in ...
10:21:26 <pumpkin> :P
10:21:55 <doserj> it can only match numbers >=k...
10:21:57 <glguy> n+k patterns seem like a feature added to get someone on board on the committee
10:22:03 <dolio> @type let f abcd mab Nothing = abcd (const $ mab Nothing) undefined ; f abcd mab (Just c) = abcd (\a -> mab $ Just a) c in f
10:22:05 <lambdabot> forall b a a1 t. ((b -> a) -> a1 -> t) -> (Maybe b -> a) -> Maybe a1 -> t
10:22:15 * pumpkin thinks they're silly, and that all the discussion about it is mostly irrelevant due to H' not having n+k patterns anyway
10:22:30 <Peaker> Where is H' described in detail?
10:22:33 <doserj> I guess someone thought that n+k patterns look more like what a mathematician would write.
10:22:39 <Peaker> I have some strong opinions about what H' should have :)
10:22:43 <dolio> @type let f :: ((a -> b) -> (c -> d)) -> (Maybe a -> b) -> (Maybe c -> d) ; f abcd mab Nothing = abcd (const $ mab Nothing) undefined ; f abcd mab (Just c) = abcd (\a -> mab $ Just a) c in f -- TomMD
10:22:44 <lambdabot> forall a b c d. ((a -> b) -> c -> d) -> (Maybe a -> b) -> Maybe c -> d
10:22:49 <pumpkin> http://hackage.haskell.org/trac/haskell-prime/
10:22:59 <tromp> yeah, but mathematicians also write f (2*k) = ...
10:23:02 <pumpkin> anyway, bbl
10:24:36 <twanvl> dolio: a functio with that type allows you do define extract :: f a -> a
10:24:40 <Peaker> I agree with a friend who said its pretty terrible to name stuff blah' which is pronounced prime.  Names should have easy/clear pronounciations that don't have to be looked up :)
10:24:56 <Peaker> Haskell NG :)
10:24:57 <twanvl> so the Maybe instance is not correct
10:25:08 <dolio> twanvl: I don't think so.
10:25:22 <twanvl> ?type f (flip const) id
10:25:23 <lambdabot> forall a t. (SimpleReflect.FromExpr ((a -> a) -> t)) => t
10:25:30 <twanvl> ?type L.f (flip const) id
10:25:31 <lambdabot> Not in scope: `L.f'
10:25:46 <dbueno> When doing retainer profiling (-hr), the <MAIN.SYSTEM> retainer means the stack, right?
10:25:57 <twanvl> ?type let f :: ((a -> b) -> (c -> d)) -> (Maybe a -> b) -> (Maybe c -> d) ; f abcd mab Nothing = abcd (const $ mab Nothing) undefined ; in f (flip const) id
10:25:59 <lambdabot> forall c. Maybe c -> c
10:26:18 <Peaker> they're keeping dot as the module lookup syntax? :-(
10:27:24 <dbueno> I have a retainer profile where after a certain point the SYSTEM retainer blows up in size
10:28:21 <dolio> @type flip const
10:28:23 <lambdabot> forall a b. b -> a -> a
10:28:48 <dolio> Oh, I see.
10:29:56 <twanvl> it turns out that for what I need that type is a bit too general, and it suffices to use   Functor g => ((a -> g a) -> (b -> g b)) -> ((f a -> g a) -> (f b -> g b))
10:30:11 <twanvl> I haven't been able to make an extract out of that yet
10:35:01 <dlocpuwons> Hello everyone, I had a hopefully quick question about list comprehensions
10:36:26 <twanvl> dlocpuwons: just ask
10:36:48 <dlocpuwons> I have this method "isPrime n primes = length [ n | x <- primes, n `mod` x == 0 ] == 0"
10:37:34 <dlocpuwons> so it takes a number, and all the primes up until that point, does some modding, and if the length of the list is 0, it should be a prime number. Is there anyway I can make that terminate earlier as soon as it finds a number?
10:38:11 <twanvl> right now you are not looking at "all the primes up until that point", you are looking at *all* primes
10:38:17 <kadaver> I name helpers with ' instead of _aux
10:38:26 <kadaver> is _ abetter convention?
10:38:50 <dlocpuwons> it is all primes up until that point, another methods feeds that primes variable
10:38:53 <dbueno> dlocpuwons: Data.List.null?
10:39:04 <Deewiant> dbueno: Prelude.null
10:39:19 <dbueno> ah.
10:39:39 <dbueno> I think Prelude.null should terminate early if an element is found
10:39:40 <kadaver> mupptetFunction a = muppetFunction_ a 0
10:39:56 <zoheb> @type null
10:39:58 <lambdabot> forall a. [a] -> Bool
10:40:07 <dlocpuwons> so if I wanted to see if 8 was prime, my method would already know about 2, 3 and 5, so once it mods 8 by 2, it already knows it isnt prime, but it still tests 3 and 5
10:40:30 <dbueno> dlocpuwons: I think if you test whether the list is null, it won't test 3 and 5.
10:40:38 <dlocpuwons> ah ok
10:40:55 <dlocpuwons> I guess im not sure how to test the list actually being created
10:40:58 <tromp> dont use lenght [...] == 0
10:41:00 <Deewiant> ?src null
10:41:00 <lambdabot> null []     = True
10:41:00 <lambdabot> null (_:_)  = False
10:41:07 <Deewiant> O(1).
10:41:11 <Deewiant> ?src length
10:41:11 <lambdabot> Source not found. :(
10:41:16 <Deewiant> Aw, man
10:41:19 <Deewiant> Anyway, O(n).
10:41:41 <dlocpuwons> Im confused...
10:42:24 <dbueno> dlocpuwons: Try "null [ n | ... ]" instead of "length [ n | ... ] == 0".
10:42:31 <dlocpuwons> ok
10:42:57 <dlocpuwons> dbueno: so that will test the list every time?
10:43:01 <dlocpuwons> and not just at the end?
10:43:40 <dbueno> pass in something that will terminate if it's right, and not terminate with "length [...] == 0".
10:43:48 <dbueno> dlocpuwons: "every time"?
10:44:04 <dbueno> it will only evaluate enough of the list to find out if it's non-empty
10:44:16 <dlocpuwons> ah ok
10:44:42 <dlocpuwons> so it would evalutate the full list only if it will be a prime number?
10:44:58 <dlocpuwons> otherwise once it finds that its not null it will stop?
10:46:03 <dbueno> try passing the infinite list of primes and some non-prime (just for testing)
10:46:52 <dlocpuwons> does haskell have some built in lazy infinite list of primes? (im pretty new)
10:47:23 <dbueno> no, but lists are lazy -- as is all evaluation in haskell -- and you can get the infinite list of primes on the internets somewhere
10:48:07 <dlocpuwons> ok
10:49:02 <dbueno> > primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
10:49:04 <lambdabot>   <no location info>: parse error on input `='
10:49:20 <dbueno> dlocpuwons: there's some code for an infinite list of primes.
10:49:30 <dbueno> From here: http://haskell.org/haskellwiki/Prime_numbers
10:49:36 <dlocpuwons> ah yes, i just found that, thank you
10:49:46 <kadaver> do you prefer Node or vertex?
10:50:05 <kadaver> why do we have null?
10:50:07 <dlocpuwons> dbueno: thanks!
10:50:14 <dbueno> dlocpuwons: np
10:51:44 <kadaver> how do I declare type Node = a
10:51:58 <kadaver> not Node a = a
10:52:02 <kadaver> just Node = anytype
10:52:32 <dbueno> data Node a = Foo a
10:52:58 <kadaver> not what i asked for
10:53:25 <dbueno> type Node a = Integer?
10:54:31 <nominolo> anyone know the cabal-install config file option to keep the sources?
10:55:00 <nominolo> or how to get a list of possible configuration options, for that matter
10:56:06 <Nafai> nominolo: Doesn't ~/.cabal/config have all of them, just commented out?
10:56:21 <nominolo> Nafai: I thought so, too, but mine hasn't
10:56:28 <nominolo> maybe I deleted them at some point
10:56:42 <dbueno> nominolo: if you move ~/.cabal/config and run cabal update, it will re-create the file for you
10:56:49 <dbueno> ... with those options
10:57:46 <nominolo> dbueno: ah, nice, thanks
10:58:15 <dbueno> nominolo: np =]
10:59:56 <nominolo> @seen waern
10:59:56 <lambdabot> I saw waern leaving #yi, #ghc and #haskell 2d 22h 2m 42s ago, and .
11:08:30 <pumpkin> lol @ the reverse state monad
11:10:35 <Lemmih> alexj: How's the brokerage firm coming along?
11:10:35 <adkjsdh> quit
11:10:37 <adkjsdh> exit
11:10:54 <Lemmih> /quit
11:11:10 <gio123> is here anybody who is familer about functional logic programming?
11:11:20 <adkjsdh> a
11:11:22 <adkjsdh> q
11:15:41 <kadaver> we hate functionalprogramming
11:16:20 <pumpkin> lol
11:20:27 <lilac> functional programming is for wimps
11:20:33 <lilac> i do non-functional programming
11:21:15 <a_guest> Which are good haskell editors? I am currently using mostly kdevelop, but I search some editors which fix intendation for you. Is vim good for haskell if customized?
11:21:37 <zloog> emacs
11:21:38 <Peaker> a_guest: there's emacs, vim, yi, leksah
11:21:44 <pumpkin> leksah seems to be getting popular
11:21:55 <monochrom> I use emacs but vim is good too.
11:22:25 <monochrom> Bear in mind that Haskell indentation is undecidable.
11:22:51 <pumpkin> lol
11:23:49 <Peaker> It could be nice if it didn't assume you might mean to continue each subexpression on the line -- for example, the editor could insert newlines/indent when line is too wide and when you newline'd it'd know its not because of breaking up an expression
11:24:10 <Peaker> when editing the indentation of Haskell code I feel like I fight the editor much more than when editing indented Python code
11:25:00 <p_l> make whitespace visible?
11:25:42 <Peaker> its already visible -- its moving the text to the right :)
11:26:01 <a_guest> leksah screenshots looks fine. Maybe I should try it.
11:26:07 <Peaker> @type newIORef
11:26:09 <lambdabot> Not in scope: `newIORef'
11:26:24 <Peaker> @hoogle newIORef
11:26:25 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
11:30:54 <Peaker> I forget - can you build unsafe coerce only using IORefs?
11:31:22 <pumpkin> and unsafePerformIO
11:31:28 <dlocpuwons> Hey everyone I am getting an error I cant figure out in ghci using this method...."primeFactorsOf n = primeFactorsOf' n [0] (primesUpTo $ round $ sqrt n)
11:31:28 <dlocpuwons>     where primeFactorsOf' n xs primes
11:31:29 <dlocpuwons>         | n == 1                     = drop 1 xs
11:31:29 <dlocpuwons>         | n `mod` (head primes) == 0 = primeFactorsOf' (div n (head primes)) (xs ++ (head primes)) primes
11:31:29 <dlocpuwons>         | otherwise                  = primeFactorsOf' n xs (drop 1 primes)"
11:31:42 <dlocpuwons> oh... is there a better way to format that?
11:31:46 <pumpkin> @paste
11:31:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:32:09 * wli tends to align the | and = signs.
11:32:16 <monochrom> I don't understand why [0] is an initial value. It's unusual.
11:32:54 <dlocpuwons> Ok here it is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4094#a4094
11:32:56 <Peaker> pumpkin: can you build unsafeCoerce :: a -> IO b    with just IORefs?
11:33:04 <monochrom> Try to prove your program correct formally. Where you get stuck is likely where the problem is.
11:34:12 <dlocpuwons> monochrom: If you are talking to me, I tried that, I feel like it should work
11:34:18 <pumpkin> :t readIORef
11:34:19 <lambdabot> Not in scope: `readIORef'
11:34:27 <pumpkin> :t Data.IOReg.readIORef
11:34:28 <monochrom> Sorry, prove != feel
11:34:29 <lambdabot> Couldn't find qualified module.
11:34:51 <monochrom> Ha, but you're getting just type errors. Let me see.
11:35:07 <monochrom> Is it one of those times when you need...
11:35:11 <monochrom> @quote fromIntegral
11:35:12 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
11:35:49 <dlocpuwons> I shouldnt be dealing with double anywhere I believe, everything should be an integer
11:36:21 <monochrom> "sqrt n" requires n :: Double or something.
11:36:43 <monochrom> n `mod` ___ requires n :: Integer or something.
11:36:46 <monochrom> Contradiction.
11:37:04 <pumpkin> PeakerWork: yeah
11:37:10 <dlocpuwons> yeah, but I am doing round on it, because I only want the closest integer, so shouldnt it be all set?
11:37:19 <mc__> "something" ought to be a valid type xD
11:37:33 <pumpkin> Peaker: oh, actually not really, maybe
11:37:34 <pumpkin> hm
11:37:36 <monochrom> Please read again: "sqrt n" requires n :: Double or something.  I am talking about the parameter n, not the return value.
11:37:52 <tony_celtx> Hey folks, I'm pretty new to functional programming (and Haskell in particular). I'm trying a bunch of exercises that were originally for Prolog, and one of them involves using a random number, but I can't figure out how to do that.
11:37:58 <monochrom> > sqrt (1 :: Int)
11:37:59 <lambdabot>       No instance for (Floating Int)
11:37:59 <lambdabot>        arising from a use of `sqrt' at <...
11:38:24 <RayNbow> @hoogle mkStdGen
11:38:24 <lambdabot> System.Random mkStdGen :: Int -> StdGen
11:38:27 <pumpkin> Peaker: well, you can, but you need two unsafePerformIOs to make unsafeCoerce
11:38:30 <dlocpuwons> ooh... In ghci i was doing "sqrt 2" and it worked fine, does it convert it for you or something?
11:38:41 <pumpkin> and a -> IO b would still need one unsafePerformIO
11:38:42 <monochrom> "2" is polymorphic.
11:38:45 <tony_celtx> I'm confused about how to return a random number so I can use it in a pure function.
11:38:52 <tony_celtx> Can anyone explain that to me?
11:38:56 <Acteum> :t sqrt 2
11:38:58 <lambdabot> forall t. (Floating t) => t
11:39:12 <dlocpuwons> ahhh
11:39:22 <RayNbow> :t System.Random.next
11:39:23 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
11:39:42 <monochrom> > let x=2 in (sqrt x, x `mod` 2)
11:39:43 * wli has completely forgotten what it was supposed to do, but http://wli.pastebin.com/m237d0c8a
11:39:43 <lambdabot>   Add a type signature
11:39:45 <RayNbow> > let g = mkStdGen 1   in   next g
11:39:46 <lambdabot>   (39336,80028 40692)
11:39:53 <pumpkin> PeakerWork: the danger comes from unsafePerformIO $ newIORef undefined, really
11:40:10 <pumpkin> it gives you an IORef a, which you can write anything to and read anything from
11:40:52 <wli> dlocpuwons: That bit at pastebin should have some prime factorization affairs.
11:41:57 <monochrom> @type 2
11:41:58 <lambdabot> forall t. (Num t) => t
11:42:01 <dlocpuwons> yeah, Im really only using sqrt because the prime factors of something always fall under its square root, so theres no point in generating the other primes
11:42:33 <wli> The square root bit is only to terminate early for the last prime factor.
11:42:41 <dlocpuwons> yes
11:43:56 <dlocpuwons> Im still confused on where my error is
11:44:02 <Ferdirand> then don't use square root, square the other side of the comparison
11:44:07 <bremner> dlocpuwons: there is an algorithm for integer square root on www.haskell.org
11:44:20 <pumpkin> that's pretty general :P
11:44:29 <pumpkin> there is an algorithm for integer square root on the internet! ;)
11:44:31 <bremner> or that :-)
11:44:41 <pumpkin> Peaker: ohai
11:44:51 <Peaker> heh hai
11:44:53 <bremner> pumpkin: the one I pointed to is in Haskell.
11:45:12 <pumpkin> Peaker: [14:38:43] <pumpkin> and a -> IO b would still need one unsafePerformIO
11:45:35 <pumpkin> Peaker: the danger is from unsafePerformIO $ newIORef undefined
11:46:09 <Peaker> pumpkin, why isn't it dangerous without the unsafePerformIO?
11:46:28 <Peaker> pumpkin, can you show the one that does use unsafePerformIO?
11:46:42 <monochrom> Gosh, why are people blind today.
11:47:18 <Peaker> monochrom, me?
11:47:19 <dolio> Geeze.
11:47:37 <dolio> "It all adds to my suspicion that there is a real conspiracy of silence about this problem in the research community, like this is the problem that nobody wants (dares) to mention or admit exists."
11:47:50 <pumpkin> Peaker: unsafeCoerce x = unsafePerformIO $ do { let ref = unsafePerformIO $ newIORef undefined; writeIORef ref x; readIORef ref; }
11:47:53 <Elly> dolio: re what?
11:48:11 <pumpkin> Peaker: if you simply to something like x <- newIORef undefined, x gets a weird type
11:48:15 <pumpkin> GHC.Prim.Any
11:48:29 <pumpkin> but unsafePerformIO gives you an actual IORef a
11:48:30 <Peaker> pumpkin, why doesn't it get: forall a. a ?
11:48:31 <dolio> Elly: Using unsafePerformIO to create top-level references.
11:48:36 <pumpkin> Peaker: I'm not sure
11:48:54 <dlocpuwons> monochrom: Alright, it took me a second to understand what you were saying, but now that portion of it works fine, but Im still getting another error I dont understand. Its nt giving me a line number so I dont know where to go
11:48:58 <Elly> dolio: *confusion*
11:49:05 <inimino> dolio: ooh, a conspiracy
11:49:06 <inimino> dolio: where's that from
11:49:12 <dolio> comp.lang.functional
11:49:21 <inimino> oh
11:49:52 <dolio> pumpkin: You only get that type if you put that line in ghci.
11:49:53 <pumpkin> Peaker: still not too clear on why it seems to default like that
11:49:56 <pumpkin> ah
11:50:04 <inimino> trolls on usenet, story at 10
11:50:14 <pumpkin> dolio: so you can normally do x <- newIORef undefined otherwise and still get an IORef a?
11:50:32 <dlocpuwons> monochrom: heres the somewhat fixed version http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4095#a4095
11:50:45 <dolio> You can get an IORef a, but it's a monomorphic a.
11:50:48 <pumpkin> ah
11:51:13 <pumpkin> I see
11:51:32 <dolio> ghci has to choose a type, though. It's not in the context of some function that can be parameterized by a type variable or something.
11:51:34 <monochrom> Yeah, blah >>= \x -> ...  makes x monomorphic.
11:51:36 <dolio> So it picks Any.
11:51:39 <pumpkin> ah
11:51:45 <pumpkin> bbl :) thanks
11:52:19 <solistic> Is there some "alex" guru around. I'm puzzled by its behaviour. Not sure yet, if it is a bug.
11:53:38 <dolio> inimino: Well, I don't think he's a troll, but he seems to be under the impression that because most people don't seem to think having to use unsafePerformIO to dump more top-level mutable state into IO is a problem, that there's some conspiracy to silence all the people who actually agree with him.
11:53:43 <dolio> When I suspect most people just don't really care.
11:53:58 <monochrom> dlocpuwons: the code for primesUpTo would be helpful.
11:54:24 <inimino> dolio: oh, is this that issue about initialization again?
11:54:31 <dlocpuwons> ok
11:54:39 <dlocpuwons> my laptop is about to die, ill see what i can do
11:54:49 <monochrom> buy a new one
11:54:59 <dlocpuwons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4096#a4096
11:57:23 <Peaker> ghc needs some download mirrors, its horribly slow
11:57:35 <dbueno> whatever happened to Nicolas Frisby's fully lazy Data.Binary instances?
11:57:43 <dbueno> Relevant thread: http://www.mail-archive.com/haskell-cafe@haskell.org/msg32960.html
11:58:04 <dbueno> (he basically just had the one, for lists)
11:59:17 <dlocpuwons> monochrom: it should just divide n by the head of the primes as long as the head of primes is evenly divisilbe. Then when that number cant be evenly divided anymore, it drops it and moves to the next one, until n == 1
12:00:04 <dbueno> Does anyone know what a fully lazy Data.Binary.get/put for lists looks like?
12:01:07 <Lemmih> dbueno: Write out the cons and nil tags instead of the length?
12:01:14 <monochrom> xs ++ (head primes) is confused.
12:01:23 <monochrom> > [1,2,3] ++ head [4,5,6]
12:01:24 <lambdabot>       No instance for (Num [t])
12:01:25 <lambdabot>        arising from the literal `4' at <inter...
12:01:45 <opqdonut> > [1,2,3] ++ head [[4,5,6],[7,8,9]]
12:01:46 <lambdabot>   [1,2,3,4,5,6]
12:01:48 <opqdonut> :)
12:01:55 <monochrom> head [4,5,6] is 4.  You're talking about [1,2,3] ++ 4.
12:01:58 <dbueno> Lemmih: ah, good idea.  could you still do it with the length?
12:02:19 <dlocpuwons> yeah
12:02:24 <dlocpuwons> oooh..
12:02:29 <dlocpuwons> got it
12:02:44 <Peaker> if [t] had a Num instance - how could ++ work?
12:02:48 <Lemmih> dbueno: With the length?
12:02:53 <gio123> does haskel use unification?
12:03:24 <monochrom> If [t] had a Num instance, "4" would be converted to type [t], then ++ works.
12:03:41 <dbueno> Lemmih: so if you just want a lazy get--and it's okay that put forces the spine--can you write a lazy get if you know the number of elements you need to read?
12:03:44 <dbueno> @paste
12:03:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:04:03 <dlocpuwons> monochrom: thanks! I just added [] around that call
12:04:11 <dlocpuwons> it works fine now, even gave me the right answer
12:04:25 <Lemmih> dbueno: Sure.
12:04:37 <dlocpuwons> Im coming from python so Im viewing ++ as appending
12:04:56 <Peaker> monochrom, oh right :) thanks
12:05:22 <Peaker> dlocpuwons, Python doesn't have ++, it has + which works kind of like ++
12:05:34 <pumpkin> dolio: so x = unsafePerformIO $ newIORef undefined gives me an IORef a where a means anything at all, anytime, and x <- newIORef undefined gives me an IORef a where a means one out of any type?
12:05:56 <gio123> does haskel use unification?
12:06:04 <dlocpuwons> I know, i was just viewing ++ as the equivalent of list.append(4)
12:06:12 <Peaker> I wish apt allowed download-only to work even without taking the dpkg lock, silly
12:06:21 <dolio> pumpkin: Yes, something like that, but it's difficult to explain it in isolation like that.
12:06:26 <conal> about Num [a], there's a package that generates numeric instances for arbitrary applicative functors.
12:06:30 <conal> @hackage applicative-numbers
12:06:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/applicative-numbers
12:06:41 <dbueno> Lemmih: can you find something wrong with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4097#a4097
12:06:50 <pumpkin> dolio: I think I get it, but I'll play with it some more, thanks :)
12:07:28 <dolio> If you try: 'coerce :: a -> IO b ; coerce a = do r <- newIORef undefined ; putIORef r a ; readIORef r' you'll get an error...
12:07:37 <Lemmih> dbueno: That should work.
12:08:02 <dbueno> Crap.  It doesn't, for me.
12:08:05 <Peaker> dolio, the writeIORef forces the type of r to be a
12:08:14 <Lemmih> dbueno: How does it fail?
12:08:23 <Peaker> dolio, not sure why it doesn't happen in the unsafePerformIO one
12:08:25 <dolio> Because the 'c' in 'r :: IORef c' is monomorphic. It can't unify with both a and b in coerce's type.
12:08:29 <pumpkin> dolio: yeah, I thought so
12:08:51 <dbueno> Lemmih: I'm trying to debug a space leak that could be accounted for by the fact that the default Binary instance for lists gets the entire list and reverses it before returning it
12:09:09 <dbueno> It failse because retainer profiling shows a ton of data being retained by "getMany"
12:09:28 <dbueno> and even more by SYSTEM, but that's another story--I'm not sure what to do there.
12:09:30 <dolio> So you can set c = a, and get it to work for the write, but then it fails for the read, or you can set c = b, and it will work for the read but not the write.
12:09:56 <monochrom> pumpkin and dolio: When you write xxx >= (\x -> yyy), or generally f (\x -> yyy), or even just z = (\x -> yyy), that x becomes a rigid variable, something like monomorphic.  The do-notation gives you xxx >= (\x -> yyy), as you know.
12:10:05 <Peaker> dolio, I don't understand why the type of the IORef isn't forced to be a or b in the unsafePerformIO case
12:10:07 <dolio> Peaker: And the reason it works with unsafePerformIO is due to let polymorphism.
12:10:40 <pumpkin> ah, that makes sense
12:10:48 <dolio> Yes, rigid is probably the more correct word.
12:11:05 <Peaker> dolio, so let x = ... makes x more polymorphic than (\x -> ..) ... ?
12:11:08 <skorpan> if i have a function "lol" which uses another "global" function (i.e. not locally defined), can "lol" be a combinator?  or is that global function regarded as a free variable?
12:12:15 <DrSyzygyFR> Guh!
12:12:26 <DrSyzygyFR> I keep getting "Not in scope" when trying to write a quickcheck property
12:12:34 <DrSyzygyFR> prop_shufflesareshuffles = all isShuffle (allShuffles i j) where types = (i :: Int,j :: Int)
12:12:40 <DrSyzygyFR> What am I missing??
12:12:49 <monochrom> "let x =" is under the monomorphism restriction spell, too. Of course this one you can remove the restriction. But then "let x=" is not very useful for IORef games anyway.
12:13:07 <skorpan> i guess i keep making no sense...
12:13:12 <dolio> Peaker: The difference is roughly that in 'r <- newIORef undefined' r has type "IORef a", whereas in 'let r = unsafePerformIO (newIORef undefined)", r has type "forall a. IORef a", if that makes sense.
12:13:29 <dbueno> Lemmih: if you read haskell-cafe, you may have seen a post about space leaks while doing an external sort of a lot of data.  I'm still trying to solve that problem.
12:13:39 <dolio> Where the 'a' in the first one is some specific, rigid variable.
12:14:09 <Peaker> dolio, I thought   (IORef a) == (forall a. IORef a) --    its not (IORef (forall a. a)) ?
12:14:28 <skorpan> f x = g x, where 'g' is another function.  is 'f' a combinator?
12:14:54 <monochrom> IMO pretty much every function is a combinator.
12:15:11 <skorpan> monochrom: in the sense that all functions take exactly one argument?
12:15:18 <skorpan> uh... no wait.
12:15:18 <skorpan> what?
12:15:33 <monochrom> Oh! Oops, there is a standard definition. A function whose body does not use free variables.
12:15:48 <skorpan> yes, so 'g' is a free variable, right?
12:15:54 <seliopou> skorpan, yes
12:15:58 <monochrom> I guess so.
12:16:09 <skorpan> so how about: f x = x * x, that's not a combinator either right?
12:16:16 <seliopou> skorpan, correct
12:16:23 <skorpan> flip is a combinator though, right?
12:16:30 <skorpan> @src flip
12:16:30 <lambdabot> flip f x y = f y x
12:16:32 <seliopou> yes
12:16:35 <skorpan> awesome.
12:16:38 <skorpan> thanks
12:16:47 <Peaker> dolio, So ghc wouldn't like it if I said that the type of r in the first example is (forall a. IORef a) -- it would require me to have scoped type variables and refer to the a or b in (a -> IO b) of the func's type?
12:16:49 <monochrom> Ha, "*" is a free variable too.
12:17:08 <Peaker> dolio, if that's the case, the only thing I'm missing is what "let magic" means
12:17:10 <dolio> Peaker: Yes.
12:17:24 <wli> dlocpuwons: http://wli.pastebin.com/m6b4b4994 is somewhat better-written prime code
12:17:25 <monochrom> I forgot the definition for super-combinator. Is it something like "doesn't use anything at all"? :)
12:17:41 <skorpan> monochrom: que?
12:17:42 <lament> x = x
12:17:48 <lament> super
12:17:55 <skorpan> @src fix
12:17:55 <lambdabot> fix f = let x = f x in x
12:19:01 <Peaker> @type unsafePerformIO
12:19:02 <lambdabot> Not in scope: `unsafePerformIO'
12:19:06 <Peaker> @type System.Unsafe.unsafePerformIO
12:19:07 <lambdabot> Couldn't find qualified module.
12:19:35 <seliopou> @type System.IO.Unsafe.unsafePerformIO
12:19:35 <lambdabot> forall a. IO a -> a
12:19:56 <amckinley> not sure when it changed, but for what its worth i like the new haskell logo :)
12:20:25 <Peaker> dolio, shouldn't unification on the readIORef and the (unsafePerformIO (newIORef undefined)) force the type of the undefined to be a specific one?
12:20:26 <dschoepe> amckinley: fwiw, There was a poll about the new logo a few weeks ago.
12:20:34 <monochrom> Rather recent change. They invited designs and voted for the one you see now.
12:21:54 <dolio> Peaker: let generalizes the type as much as possible, so what type the term is used in one place has no effect on that.
12:22:31 <dolio> Peaker: Consider "let id x = x in (id 5, id 'c')", should id have some specific type because it's used as Char -> Char there?
12:24:07 <monochrom> > let i x = x in (i 5, i 'c')
12:24:09 <lambdabot>   (5,'c')
12:24:11 <dolio> Whereas '(\id -> (id 5, id 'c')) (\x -> x)' does fail, because id parameter does have to be given some specific type, because that's how lambda expressions are.
12:24:24 <wli> dlocpuwons: http://wli.pastebin.com/m59717b4 <-- a few more cleanups
12:24:38 <monochrom> > (\id -> (id 5, id 'c')) (\x -> x)
12:24:40 <lambdabot>       No instance for (Num Char)
12:24:40 <lambdabot>        arising from the literal `5' at <inte...
12:25:28 <dolio> Even if in general that type is something like "a -> a" in "(\id a b -> (id a, id b)) :: (a -> a) -> a -> a -> (a, a)".
12:25:36 <monochrom> Haskell98 defines lambda expressions to be not-so-polymorphic. There is a GHC extension to change it indirectly.
12:25:59 <dolio> If you try changing that b to have type "b", and have the return type be "(a, b)" it won't work.
12:26:43 <dolio> Now you might think about doing "newIORef undefined >>= \(r :: forall a. IORef a) -> ..." but that also doesn't work for reasons I'm going to have to think about now.
12:26:52 <monochrom> The extension allows you to write manually (\ (id :: forall a. a->a) -> (id 5, id 'c')) ((\x -> x) :: forall a. a->a)
12:27:59 <monochrom> The reason is that the type of >>= does not allow that much polymorphism.
12:28:42 <monochrom> >>= is defined rank-1.  newIORef undefined >>= \(r :: forall a. IORef a) -> ...  wants a rank-2 >>=.
12:29:02 <Heffalump> WTF is Harrop's latest troll getting 20 points on reddit?
12:29:14 <monochrom> Harrop has fans, you know.
12:29:21 <Heffalump> but 55 of them?
12:29:34 <monochrom> Also what did he write? Perhaps he wrote something a lot of people likes to hear.
12:29:37 <dolio> That's just Haskell getting what's coming to it. :)
12:29:53 <Heffalump> "When Haskell goes bad: ..."
12:30:00 <dolio> He didn't write anything. He's just linking to Adrian Hey complaining about top level IO.
12:30:05 <monochrom> For example if you go to reddit and write "I hate Haskell" you will get modded up too.
12:30:20 <conal> Heffalump: link?
12:30:27 <monochrom> For that matter, if you write "I hate African people" you will get a lot of fans too.
12:31:05 <Peaker> dolio, thanks for the explanation!
12:31:07 <monochrom> You can write a lot of falsehood, nonsense, immoral, irrational things and get modded up simply because people like to hear it.
12:31:15 <Heffalump> http://www.reddit.com/r/programming/comments/8egod/when_haskell_goes_bad_io_and_ffis/
12:31:50 <conal> thx
12:31:50 <Heffalump> conal: Adrian Hey wrote a somewhat bitter sounding post to comp.lang.functional about the whole top-level <- argument
12:31:51 <dolio> monochrom: I suppose it's newIORef's type, as well. (forall a. a -> IO (IORef a)) can be instantiated to (forall a. a) -> IO (IORef (forall a. a)), but I guess there's no way to instantiate it such that you get IO (forall a. IORef a) back.
12:32:02 <Heffalump> so he (jdh) is trying to make as much of it as he can
12:32:07 <monochrom> Oh yeah, newIORef is rank-1 too.
12:32:11 <conal> sigh
12:32:19 <Saizan_> dolio, monochrom: (return undefined :: IO (forall a. a)) >>= \(x :: forall a. a) -> return () <- this works with ImpredicativeTypes
12:32:31 <Saizan_> and Rank2Types, ScopedTypeVariables
12:32:54 <monochrom> Haha neat.
12:33:17 <Nafai> Adrian Hey seems to be happy to say that Haskell sucks lately
12:33:40 <monochrom> Yes, IO (IORef (forall a. a)) vs IO (forall a. IORef a) is the root of it.
12:33:51 <dolio> Saizan_: "newIORef undefined >>= \(x :: IORef (forall a. a)) -> ..." works, too, but that won't let you write coerce.
12:33:57 <Philippa_> Nafai: examples? Though I've got a checklist of things that suck about haskell too
12:34:16 <Philippa_> (admittedly most of them're things we barely start complaining about in mainstream languages because there's so much other crap)
12:34:48 <dolio> I think it's a bit much to say that there's an academic conspiracy to keep people from talking about your personal peeves.
12:34:52 <Heffalump> Philippa_: I think he's mostly annoyed about (a) the community's failure to adopt his container stuff and (b) the general hostility to top-level <-
12:34:55 <a_guest> Which tab length do you use when writing code?
12:35:01 <monochrom> We say "haskell sucks" because we have higher expectations.
12:35:14 <Heffalump> a_guest: we don't use tabs, because they're asking for trouble with an indentation-aware language like Haskell
12:35:17 <inimino> a_guest: use spaces instead; tabs are evil
12:35:21 <jmelesky> anyone know why harrop is targeting haskell in particular?
12:35:22 <monochrom> The same way we treat "refactoring in java" and "refactoring in haskell" differently.
12:35:29 <Heffalump> generally I indent sub-blocks 2-3 characters more than the block above
12:35:53 <a_guest> I do not use tabs, but with tablength i mean number of whitespaces.
12:36:02 <Heffalump> jmelesky: my best guess is because it doesn't suit his problem domain very well, and he views its popularity as a threat to his business
12:36:03 <dolio> jmelesky: It's been fashionable lately, and he doesn't sell it.
12:36:17 <Heffalump> also, he seems amazingly jealous of the success of RWH
12:36:45 <monochrom> If you see an IDE for java that can change a local variable to an object field, you call that a pretty cool java refactoring. But haskell refactoring --- you expect nothing short of "I have monadic code but I now want applicative".
12:37:04 <Heffalump> http://groups.google.co.uk/group/comp.lang.functional/tree/browse_frm/thread/fd11a86070f62a98/1794ad81fdf40677?rnum=11&_done=%2Fgroup%2Fcomp.lang.functional%2Fbrowse_frm%2Fthread%2Ffd11a86070f62a98%3F#doc_99b5579762c3af94
12:37:51 <Philippa_> monochrom: not to mention "here's a sequence of forms I want my code transformed through, stop here so I can do some hand-generalising
12:37:52 <Philippa_> "
12:37:53 <jmelesky> Heffalump: ah, hadn't thought of the RWH angle
12:38:04 <Philippa_> though really you want the generalising to be specifiable too
12:38:19 <Philippa_> jmelesky: not to mention that he's committed to the ML family, investment-wise
12:38:45 <Philippa_> he sells ML - and ML consulting - to exactly the sort of people who Haskell now at least somewhat appeals to
12:39:15 <jmelesky> Philippa_: see, i love SML. but Haskell seems to be a better successor to it than Ocaml
12:39:28 <Lexi> Oh i see.
12:39:30 <Heffalump> he's not all that fussy about who he attacks, though - he accused Xavier Leroy of academic dishonesty in one recent reddit post
12:40:07 <Philippa_> yeah, he's admitted that he stirs up controversy to gain mindshare
12:40:08 <dolio> Heh, jdh accusing someone of dishonesty is amusing.
12:40:11 <pumpkin> lol
12:41:50 <dolio> Heffalump: Is he angry about people not adopting containers? I've pointed people to it before when they say that there's no map-like abstraction, but according to hackage it doesn't build on 6.8 or 6.10.
12:42:34 <dolio> Er, collections.
12:42:53 <opqdonut> jdh?
12:42:57 <opqdonut> ah harrop
12:43:01 <Heffalump> dolio: I'm not certain, and I might be wrong about my impression. He's certainly annoyed about the top-level <- thing though.
12:43:04 <Philippa_> it can sometimes be a little tough to get 'useful' community support on making stuff work if you're enough of an outsider. I mean, I know my own experiences there've been more due to not knowing how to ask/what to ask for and having really needed someone else to maintain my own projects when they go public, but still
12:43:05 <jmcarthur> opqdonut, john harr-- yes, him
12:43:24 <Philippa_> Heffalump: I can understand the top-level <- thing. The problem is, the right solution is a more powerful module system
12:43:37 <Philippa_> and we all know how likely that isn't to happen
12:43:57 <Philippa_> it's part of the big typeclass/qualified type/... clusterfuck that comes courtesy of having invented typeclasses
12:43:59 <Heffalump> Philippa_: well, I'm not sure how that is the right solution either
12:44:03 <jmelesky> i do miss the SML module system
12:44:08 <dolio> Oh, I guess there are split up packages that build on 6.8/10.
12:44:08 <Heffalump> it's actually a fundamental problem in any language, IMO
12:44:25 <Philippa_> Heffalump: modules that're first-class enough to be able to explicitly initialise where needed
12:44:28 <jmelesky> but typeclasses are such a worthwhile improvement
12:44:46 <Heffalump> unless your language can somehow guarantee run-once semantics in scopes that cross the boundaries of its own runtime, it can't protect you against multiple copies of the initialisers running
12:44:55 <Philippa_> jmelesky: definitely. Haskell will have a well-deserved spot in the evolution-of charts for any non-dependent language, and I suspect many dependent ones too
12:45:03 <Heffalump> which for things like unsafe C libraries or hardware, is crippling
12:46:06 <Philippa_> Heffalump: yeah, you still need a space for init-once-only flags. You've got a chance to figure out the right structure for that independent of the monadic execution problem though
12:46:23 <Heffalump> "once-only" in what scope?
12:46:29 <jeffersonheard> ugh... I'm told I'm going to have to learn ActionScript next... they want web based visualizations
12:46:36 <pumpkin> :o
12:46:46 <pumpkin> jeffersonheard: haskell flash codegen :P
12:46:47 <jeffersonheard> is there a functional layer to actionscript or flash somewheres?
12:46:52 <Philippa_> well quite, it wants defining in an external language - the flag's an external resource, clearly
12:47:14 <Heffalump> it's not just a flag, it's the storage
12:47:32 <Philippa_> (ultimately, if it's /that/ unsafe you're just plain screwed - if you can't get the OS or something similarly definitely-top-level to babysit for you, it's breakable)
12:47:56 <Xen0x> jeffersonheard. No haskell flash codegen. I'm currently working on a thesis project that uses WxHaskell to communicate with a Flash Player :)
12:48:01 <Heffalump> "definitely-top-level" ==> "in the appropriate scope"
12:48:12 <Heffalump> which might or might not be top-level on the relevant hardware
12:48:15 * Philippa_ waves to the Theory of Everything
12:48:23 <pumpkin> NKS? :P
12:48:25 <jeffersonheard> *sigh*
12:48:43 <jeffersonheard> well, at least I won't have to use it for most stuff
12:49:00 <Philippa_> if it doesn't exist, it doesn't exist and you shouldn't try to spec it in the first place - it's clearly an external verification issue. Best we can do then's work out how to handle RTS-level
12:49:11 <Philippa_> and the RTS-level issue does crop up
12:49:31 <Philippa_> (similarly every scope under it, but those're easier once you've reached that stage)
12:51:18 <gueux> hi
12:51:48 <gueux> I can't find  Control.OldException with cabal
12:52:13 <gueux> and I don't know if it could be in a package on debian...
12:52:45 <dolio> debian is still 6.8, right?
12:52:59 <Heffalump> Philippa_: how would you suggest RTS-level be implemented?
12:53:09 <gueux> dolio: yes
12:53:20 <dolio> I think OldException might still be Exception in 6.8.
12:53:51 <Heffalump> if you need Control.OldException, I think you should just get extensible-exceptions and use Control.Exception instead
12:53:52 <Saizan_> yes, it's Control.Exception on 6.8
12:54:01 <Heffalump> the purpose of that is to wrap up the compatibility between 6.8 and 6.10
12:54:08 <Saizan_> Heffalump: Control.Exception.Extensible
12:55:26 <Philippa_> Heffalump: with careful thought. It seems to me that per-RTS we have some sort of guarantees about eg type-to-name and the like - it's the stuff that goes in the top levels of our modules as it is. But you've got a nasty question regarding what kinds of resources are okay to request there because clearly the issue's 'impure' ones. I'm not sure how much I disagree with Adrian's basic idea, tbh - though I'd want a way of separ
12:55:26 <Philippa_> ating pure modules from impure and that's going to open a bag of suck
12:55:28 <gueux> ok
12:55:54 <Heffalump> Saizan_: ok, sorry
12:57:03 <gueux> Heffalump: what is extensible-exceptions?
12:57:35 <gueux> oh ok, 21:54:08 < Saizan_> Heffalump: Control.Exception.Extensible
12:57:41 <Philippa_> ultimately, I'd end up wanting some kind of signature system to separate pure from impure modules (and y'know, may as well run with everything else at the same time) - hence my earlier comment. If I've got that, top-level <- isn't the most fugly way to define the resources
12:58:22 <Philippa_> but the thing is, that's not a (per-program, which may not be per-RTS) initialiser
12:59:36 <Cale> I think it's a good thing that top-level mutable variables are annoying to define.
13:00:07 <Philippa_> Cale: annoying I don't mind. Do we have a way to do it that doesn't require pragmas yet?
13:00:23 <Philippa_> (a safe one!)
13:00:36 <monochrom> Turn off all optimisations. That should do. :)
13:00:58 <Cale> I don't mind it being unsafe and implementation dependent. It should be as scary a prospect as we can make it. ;)
13:01:02 <Philippa_> monochrom: doesn't count, needs extra-module data
13:01:04 <Cale> So that nobody ever does it.
13:01:46 <monochrom> The global mutation tax? :)
13:02:13 * monochrom attempts one of those yo-dawg jokes.
13:02:17 <Philippa_> Cale: see, I do have a problem with it - if it's required to interact as safely as possible with the host environment, then someone will have a program to write that either requires doing that or wants writing in another language. I consider the latter answer near-xenophobic - may as well ditch all IO
13:02:43 <Apocalisp> monochrom: Double tax if you mutate pointy brackets.
13:02:51 <monochrom> Yo dawg, I heard your global mutable variables are environmentally-unfriendly, I decided to charge you a tax!
13:03:08 <Cale> Philippa_: It's nicer to just force them to make the variable local.
13:03:21 <byorgey> I think it's suppose to include "so we put a ___ in your ___ so you can ___"
13:03:34 <Philippa_> Cale: IOW, to force greater unsafety with the host environment
13:03:51 <Cale> I don't think it necessarily does that.
13:04:04 <monochrom> Yo dawg, I heard your global mutable variables are environmentally-unfriendly, so we put an unsafe requirement in your global mutable variable so you can unsafe!
13:04:09 <skorpan> > "sup dawg, we " ++ fix ("heard you like recursion so we " ++)
13:04:11 <lambdabot>   "sup dawg, we heard you like recursion so we heard you like recursion so we...
13:04:37 <monochrom> hehe
13:04:54 <Cale> They can always use the "continuation passing" way of managing resources.
13:04:59 <Philippa_> Cale: *nod*. I did include it as a condition of my previous statement though, so hey. If it's not, I just want some encoding of explicitly-initialisable modules - probably first-class
13:05:08 <monochrom> Anyway I'm just joking. Of course we want to provide safe global mutation.
13:05:18 <Philippa_> IO (Module Foo)
13:05:44 <Philippa_> the current way to encode that's still pretty painful, but that's still par for the course for a lot of stuff
13:09:49 <thoughtpolice> @faq can haskell end the current economic recession/depression?
13:09:50 <lambdabot> The answer is: Yes! Haskell can do that.
13:09:52 * wli dubs the situation "the Haskell module system crisis."
13:10:00 <thoughtpolice> wow!!! don't you love haskell. :)
13:10:01 <lambdabot> thoughtpolice: You have 1 new message. '/msg lambdabot @messages' to read it.
13:10:02 <holzensp> howdy folks... anyone here using SDL on OSX?
13:10:09 <skorpan> it would be much more fun if lambdabot sometimes claimed that haskell cannot do that
13:10:20 <pumpkin> thoughtpolice: don't read the message!
13:10:29 <pumpkin> thoughtpolice: if you do, in seven days something very bad will happen
13:10:43 <thoughtpolice> more like if you read it i then come into your home
13:10:49 <thoughtpolice> and take you away
13:10:50 <thoughtpolice> and erase you
13:10:55 <monochrom> @faq can haskell start another financial crisis?
13:10:55 <lambdabot> The answer is: Yes! Haskell can do that.
13:11:37 <holzensp> @faq can haskell figure out how to work with SDL, despite the broken Mac build-system? ;)
13:11:38 <lambdabot> The answer is: Yes! Haskell can do that.
13:11:59 <holzensp> that's good to know
13:12:01 <increpare> holzensp: hurrah! we are saved
13:12:11 <holzensp> it seems we are
13:12:25 <holzensp> there's a lot of very quiet folks on :D
13:13:48 <increpare> holzensp: they're, no doubt, sitting in quiet contemplation, waiting for the perfect moment to intercede in our affairs
13:14:12 <holzensp> back the serious business, though... I have tried getting sdl up and running on my mac. If I install sdl through macports, the haskell bindings will be cabalized (albeit with a lot of atom sorting errors from ld)
13:14:36 <holzensp> but then _SDL_main is missing; my linux installation (cabal) didn't have that problem
13:14:55 <holzensp> the SDL.framework from the SDL website doesn't even allow cabal to find it
13:19:32 <thoughtpolice> there is a flag for frameworks on OS X
13:19:54 <thoughtpolice> which might make a difference, but i couldn't tell you
13:19:54 <holzensp> well, ld has a -framework flag
13:20:05 <holzensp> I tried to cabal with --flages=-framework SDL
13:20:10 <holzensp> but that didn't change anything ;)
13:20:17 <holzensp> *flags
13:20:43 <holzensp> the thing is; there is this .m and .h file that come bundled with SDL
13:20:50 <holzensp> that you need to include to build with gcc
13:20:54 <snoobino> lala
13:21:12 <holzensp> gcc -I/Library/Frameworks/SDL.framework/Headers MyProgram.c SDLmain.m -framework SDL -framework Cocoa
13:21:35 <holzensp> that's how they recommend building... I might just as well use the macports build
13:21:44 <thoughtpolice> holzensp: try passing '-framework SDL' to ghc
13:21:46 <holzensp> but how do I stick in the SDLmain.m?
13:22:02 <holzensp> and forget about the .m-file?
13:22:17 <thoughtpolice> or you could add a 'frameworks: SDL' field in the cabal file
13:24:18 <increpare> [i'm also here regarding sdl/osx] i just tried "ghc --make Test.hs -framework SDL" on one of these simple examples, and it made little difference hmm
13:24:29 <increpare> (just produced a .o file)
13:24:30 <bavardage> http://omploader.org/vMWtiNw gtk2hs yaaay
13:24:54 <increpare> bavardage: that's quite pretty indeed :)
13:25:16 <bavardage> :D
13:25:56 <holzensp> increpare: can you -main-is your module?
13:27:19 <nathanic> bavardage: for those of us just tuning in, what is that a screenshot of?
13:27:39 <bavardage> nathanic: my gtk2hs app
13:27:45 <bavardage> it's an epg-type thing
13:27:48 <bavardage> to tell me what's on tv
13:27:50 <bavardage> that I may like
13:27:51 <holzensp> thoughtpolice: I just extracted $HOME/.cabal/packages/hackage.haskell.org/SDL/0.5.5/SDL-0.5.5.tar.gz and changed the .cabal file in the resulting directory
13:27:58 <bavardage> uses a basic keyword system
13:28:02 <holzensp> is that enough for "cabal install --reinstall sdl"?
13:28:04 <nathanic> bavardage: it certainly looks nice!  on hackage?
13:28:08 <bavardage> noop
13:28:11 <increpare> holzensp: then i just get a "Undefined symbols:
13:28:11 <increpare>   "_SDL_main"," message
13:28:13 <bavardage> I have no clue about hackage
13:28:26 <bavardage> I'll investigate at some point
13:28:42 <Nafai> bavardage: Looks nice!
13:28:43 <holzensp> because doing that (*and* disabling the macports SDL) just sends me back to SDL not being found at all and cabal messing up in the configure stage
13:28:45 <bavardage> :D
13:28:59 <Nafai> bavardage: I can do gtk2hs but I suck at making things look that nice
13:29:04 <bavardage> hehe
13:29:04 <nathanic> bavardage: is the code up somewhere public at all, so we can steal your ideas? ;-)
13:29:10 <bavardage> I'll update and push
13:29:17 <bavardage> but I'd advise against looking at the code
13:29:20 <bavardage> it's the ultimate mess
13:29:24 <nathanic> ha
13:29:36 <increpare> bavardage: maybe they can clean it up for you ;p
13:29:40 <bavardage> hehe
13:29:42 <bavardage> that would be nice
13:29:44 <Nafai> bavardage: Did you use Cairo for the timeline on the right?
13:29:59 <bavardage> yup
13:30:00 <kadaver> can you compile and get told about unused variables? like (a,b,c,d) and i only use b so i could do (_,b,_,_) ?
13:30:04 <bavardage> and for the program detail top right
13:30:19 <kadaver> how can I case x of x==10?
13:30:31 <orbitz> case x of 10 -> ...
13:30:54 <increpare> ( x=10.5? ;p )
13:31:05 <bavardage> http://github.com/bavardage/makria/tree/master <--- the code
13:31:53 <dbueno> question: are there strict variants of <$> and <*>, so that for example f <$> x <*> y seq's the values inside x and y before (strictly) applying f to them?
13:32:47 <Nafai> bavardage: Have you done GUI programming in other languages?  How does this compare for you?
13:32:57 <monochrom> No, but you can seq x and y yourself.
13:33:18 <bavardage> Nafai: I dunno
13:33:22 <holzensp> or include the seq in your own definition of <$> and <*>
13:33:22 <bavardage> python seems on the face of it easier
13:33:26 <bavardage> depends
13:33:28 <holzensp> maybe <$!>
13:33:30 <mk15> hi im running ghc version 6.8.2 (latest version in the ubuntu package manager)...I was wondering if theres any big advantage to get 6.10.2 and compile it from source?
13:33:41 <bavardage> I'm still a haskell noob anyway
13:33:42 <Philippa_> <$!> does seem staggeringly obvious, doesn't it?
13:33:44 <bavardage> so it's not really a fair comparisot
13:33:47 <bavardage> *comparison
13:33:50 <Heffalump> mk15: probably not a huge one
13:33:54 <dbueno> I can ... I was hoping I didn't have to.  I was hoping for <$!> and <*!>
13:34:06 <Heffalump> I'd suggest downloading a binary tarball or an experimental Debian package instead, anyway
13:34:11 <byorgey> dbueno: do you mean that strictly evaluates x and y, or strictly evaluates the "contents" of x and y (i.e. the a's if x and y have type  f a)?
13:34:13 <holzensp> mk15; there's some performance gain and some nice new type constructs
13:34:23 <byorgey> if the latter, it must be implemented separately for each applicative.
13:34:31 <holzensp> mk15: but if you haven't missed them so far, you probably shouldn't ;)
13:34:55 <dbueno> byorgey: so if the functor were also a monad, the effect wolud be: do{ x <- a; y <- b; return $! x `seq` y `seq` f x y }
13:35:01 <dbueno> byorgey: so what's inside.
13:35:18 <holzensp> oh, hey brent... I was wondering whether your typeclassopedia was going up soon?
13:35:26 <holzensp> (going up = being published, or new draft)
13:35:27 <byorgey> dbueno: right, I don't think you can do that generically for all Applicatives.  although I may be wrong.
13:35:35 <byorgey> holzensp: oh, it was published a while ago.
13:35:38 <byorgey> @go Monad Reader
13:35:40 <lambdabot> http://haskell.org/haskellwiki/The_Monad.Reader
13:35:40 <lambdabot> Title: The Monad.Reader - HaskellWiki
13:36:04 <byorgey> see issue #13.
13:36:15 <dbueno> hmm ... let me see if I can, then.
13:36:20 <holzensp> ah, so my last notes were late ;)
13:36:32 <mk15> holzensp: thanks, I definitely not missing anything yet seeing im learning only for two weeks :D
13:36:38 <byorgey> they... might have been, I don't remember
13:36:43 <holzensp> ;)
13:36:50 <byorgey> I do remember getting some additional comments after it was published =)
13:37:00 <byorgey> but I think most of them had already been addressed.
13:37:58 <holzensp> ah, good stuff... all in all it's nice material, especially to point students to, so thanks for that
13:38:08 <byorgey> you're welcome!
13:38:13 <holzensp> now it's back to getting SDL to work, for me ;)
13:38:19 <byorgey> heh, enjoy =)
13:39:09 <dbueno> @hpaste
13:39:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:41:10 <dbueno> Strict applicative application? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4098#a4098
13:42:09 <holzensp> yep, that looks right (typo in line 2)
13:42:15 <kadaver> is dijksttra's alogirhtm greedy or optimal?
13:42:27 <holzensp> euhm... neither :p
13:42:37 <dbueno> if you use that definition of <$!>, then (const 1) <$> pure undefined gives 1, but (const 1) <$!> pure undefined crashes
13:43:48 <holzensp> kadaver: in many cases, when you know more about your search space, you can add heuristics to dijkstra that will give you the shortest path, while visiting less nodes
13:43:48 <dbueno> holzensp: Thanks, typo fixed.
13:44:01 <dbueno> byorgey: I think you can do it generically -- see my paste
13:45:04 <holzensp> oh, by the way... does anybody know why stuff like sum and length are implemented with linear memory complexity (at least in GHC)?
13:45:18 <Heffalump> in GHC with optimisations on?
13:45:22 <holzensp> is there a reason against parameter-accumlated memory o(1)-ness?
13:45:35 <Heffalump> also, what did you actually try?
13:45:35 <holzensp> erm... I think so, yes
13:45:46 <Heffalump> for example let xs = [1..1000000] in sum xs/length xs
13:45:49 <holzensp> sum [1..100000000]
13:45:51 <Heffalump> will take linear memory
13:45:55 <holzensp> yep
13:46:12 <Heffalump> I'd be quite surprised if sum [1..10000000] did though
13:46:21 <holzensp> stack overflow
13:46:31 <holzensp> so... yeah
13:46:42 <holzensp> it does seem to unfold 1+(2+(3+...))
13:47:13 <Heffalump> so it does. That's a bit rubbish.
13:47:18 <holzensp> but I would imagine something like
13:47:22 <orbitz> sum is fold
13:47:26 <holzensp> sum' s [] = s
13:47:27 <monochrom> sum still uses the lazy foldl
13:47:38 <holzensp> sum' s (x:xs) = s `seq` sum' (s+x) xs
13:47:42 <Heffalump> oh, I guess the problem is that (+) isn't guaranteed strict
13:47:50 <Heffalump> holzensp: foldl' (+) 0 xs
13:47:51 <holzensp> it isn't?
13:47:52 <Heffalump> will be fine
13:47:59 <holzensp> why isn't it guaranteed strict?
13:48:00 <Heffalump> holzensp: no, because anyone can implement it how they like
13:48:01 <harovali> Heffalump: i think length is the culprit
13:48:04 <holzensp> mmmm
13:48:09 <holzensp> yes, true
13:48:15 <holzensp> but then length still shouldn't be
13:48:16 <Heffalump> length really ought to be strict
13:48:30 <Heffalump> @src length
13:48:30 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:48:34 <monochrom> GHC length is aggressively optimized.
13:48:35 <Heffalump> @src Data.List.length
13:48:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:48:43 <monochrom> @src length
13:48:43 <lambdabot> Source not found. Just try something else.
13:49:02 <holzensp> mmm, it isn't stack-overflowing
13:49:04 <monochrom> Oh well. But you can find it elsewhere and it's very agressive.
13:49:06 <harovali> length can't be lazy paced
13:49:19 <holzensp> that's quite sure, but [1..100000000000] probably is a bit steep ;)
13:49:27 <Heffalump> if I compile sum [1..whateveritwasyousaid] with -O2, it runs in constant space.
13:49:50 <holzensp> yeah, it runs constant... so it's sum
13:50:06 <holzensp> Heffalump: tell me more of this primed fold
13:50:07 <holzensp> ;)
13:50:12 <Heffalump> holzensp: it's strict
13:50:18 <holzensp> I figured as much
13:50:21 <holzensp> but where is it?
13:50:21 <Heffalump> but as I just said, sum does run in constant space with optimisations
13:50:25 <Heffalump> in the prelude
13:50:29 <Heffalump> @type foldl'
13:50:30 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:51:11 <holzensp> mmm
13:51:13 <holzensp> I get this: <interactive>:1:0: Not in scope: `foldl''
13:51:14 * Heffalump has now tried sum [1..whatever] with ghci, ghc, ghc -O and ghc -O2
13:51:14 <holzensp> in ghci
13:51:25 <Heffalump> it uses lots of space in ghci and ghc, and constant space in -O and -O2
13:51:31 <monochrom> http://www.haskell.org/haskellwiki/Stack_overflow explains foldl'
13:51:45 <byorgey> dbueno: hmm, <$!> looks good, but <*!> doesn't
13:51:50 <byorgey> dbueno: it doesn't even have the right type
13:51:56 <Heffalump> holzensp: try Data.List, sorry
13:52:00 <holzensp> ah, Heffalump, it seems to sit in Data.List, rather than Prelude
13:52:01 <holzensp> ah
13:52:01 <dbueno> byorgey: yeah, it doesn't.
13:52:01 <holzensp> yes
13:52:05 <orbitz> @src sum
13:52:06 <lambdabot> sum = foldl (+) 0
13:52:33 <holzensp> I've been wondering about a few of these optimizations
13:52:41 <holzensp> I would exact a program that's just this:
13:52:50 <holzensp> main = return $ sum [1..10000]
13:52:59 <holzensp> to compile to a program returning a constant
13:52:59 <dbueno> byorgey: maybe "ff <*> (id <$!> fx)"
13:53:02 <Heffalump> main = print $ sum ...
13:53:14 <holzensp> ah
13:53:16 <Heffalump> return would set the exit code
13:53:19 <Heffalump> which isn't very helpful
13:53:21 <byorgey> dbueno: that might work
13:53:27 <Heffalump> I guess it would still actually compute the sum, but still
13:53:36 <holzensp> well, either would do, because I don't actually run the code, but look at "ghc -O2 -S" output
13:53:43 <dbueno> byorgey: it has the right type =]
13:53:44 <Heffalump> ok :-)
13:53:53 <holzensp> and it's intimidating output
13:53:58 <Heffalump> but it definitely runs in constant space on my machine, with ghc 6.11.20090221
13:54:01 <orbitz> Heffalump: i dont' think main :: IO Int sets ane xit code
13:54:04 <holzensp> oh, sure
13:54:09 <Heffalump> orbitz: really?
13:54:10 <orbitz> Heffalump: one ahs to call a special funciton
13:54:15 <Heffalump> why bother with the Int then?
13:54:19 <Heffalump> oh, is main IO ()
13:54:19 <orbitz> Heffalump: main is supposdly supposed to reutrn IO ()
13:54:22 <Heffalump> ahem
13:54:26 <Heffalump> I do know Haskell, honest.
13:54:31 <holzensp> hehehe
13:54:35 <holzensp> my sentiment exactly
13:54:36 <byorgey> dbueno: it does have the right type, but it doesn't seem to work
13:54:48 <holzensp> holzensp: don't mix your languages
13:54:54 <Heffalump> well, don't tell my boss I don't, please..
13:54:54 <holzensp> mmm, IRC-note-to-self :D
13:54:57 <byorgey> *Main> [const 5, const 2] <*!> [2,3,undefined]
13:54:58 <byorgey> [5,5,5,2,2,2]
13:55:54 <jethr0> what's up with <*!>? is that a strict <*>? ^_^
13:56:03 <holzensp> byorgey: wasn't there an issue with Prelude.seq being less strict than DPH.seq?
13:56:19 <byorgey> jethr0: that's the idea =)
13:56:21 <holzensp> jethr0: it's just been defined to be a strict <*>
13:56:27 <byorgey> holzensp: I don't know
13:56:39 <dbueno> hm, why doesn't it work....
13:56:56 <holzensp> byorgey: I seem to recall from a DPH paper, being surprised, not believing it, testing it, being more surprised... you know the cycle ;)
13:57:06 <byorgey> hehe, right
13:57:16 <byorgey> well, I guess the problem is that seq only evaluates things to whnf
13:57:38 <dbueno> but "undefined `seq` _" is undefined, right?
13:57:42 <dbueno> That is, whnf should be enough.
13:57:58 <jethr0> > undefined `seq` 4
13:58:00 <lambdabot>   * Exception: Prelude.undefined
13:58:01 <byorgey> hmmm
13:58:09 <holzensp> [3,2,undefined] ; whnf = 3:_
13:58:28 <jethr0> > [3, undefined] `seq` 4
13:58:29 <lambdabot>   4
13:58:36 <holzensp> there you go
13:59:03 <jethr0> (3, undefined) `seq` 4
13:59:03 <dbueno> it should be seq'ing what's in the applicative.
13:59:10 <jethr0> > (3, undefined) `seq` 4
13:59:12 <lambdabot>   4
13:59:37 <jethr0> there's always deepseq...
13:59:58 <holzensp> > (3,undefined) `deepseq` 4
14:00:00 <lambdabot>   Not in scope: `deepseq'
14:00:09 <holzensp> not in lambdabot, there isn't ;)
14:00:17 <hoopy> > "hi"
14:00:19 <lambdabot>   "hi"
14:01:24 <jethr0> @hoogle deepSeq
14:01:24 <lambdabot> No results found
14:01:53 <jethr0> huh?
14:02:09 <dbueno> deepSeq is not in a std lib
14:02:18 <dbueno> @hoogle NFData
14:02:19 <lambdabot> Control.Parallel.Strategies class NFData a
14:02:44 <pumpkin> isn't deepSeq just like rnf x ?
14:02:48 <pumpkin> with a type like seq's?
14:03:05 <dbueno> sort of -- it's really "x `using` rnf"
14:03:15 <pumpkin> ah
14:03:24 <dbueno> er, at least that's one way.  rnf is a function.
14:04:02 <dbueno> byorgey: the problem is the laziness of <*>, whiche I use in the definition of <*!>
14:04:23 <dbueno> since the lhs of <*> is (const _), the rhs never gets touched.
14:04:48 <byorgey> yes, that's probably it
14:05:17 <holzensp> y `seq` ff <*> y
14:05:24 <holzensp> that should touch y, no?
14:05:49 <byorgey> well, ff <*!> fx = let x = (id <$!> fx) in x `seq` (ff <*> x)  still does not work
14:06:10 <dbueno> huh.
14:06:26 <byorgey> the problem is that the  x `seq` (ff <*> x) only needs to reduce x to whnf
14:06:51 <dbueno> yeah, and x is the applicative container, not its contents.
14:06:52 <holzensp> yeah... and for many Functors, their outer most structure is whnf
14:06:56 <byorgey> and to do that it need not do the <$!>
14:06:58 <byorgey> right.
14:07:12 <byorgey> so you need deepSeq instead of seq.
14:07:27 <holzensp> fmap feels like it should do something, no?
14:10:40 <Phyx-> there's  deepSeq.. hmm
14:10:45 <Phyx-> :t deepSeq
14:10:46 <lambdabot> Not in scope: `deepSeq'
14:10:56 <holzensp> hehehe, since nobody is jumping at my request for SDLonMac advice, I'm going to go for the public-speaker's alternative:
14:11:14 <holzensp> does anybody know of anybody *else* who knows about SDL on Mac? :p
14:11:36 <blackh> holzensp: I think you have struck a vein of deep ignorance. :)
14:12:01 <Lemmih> holzensp: Have you read: http://darcs.haskell.org/~lemmih/hsSDL/hssdl/MACOSX ?
14:12:02 <holzensp> striking a vein usually has a pleasant connotation
14:12:22 <holzensp> Lemmih, I have
14:12:43 <holzensp> however; that doesn't list any -lSDL test in the configure output
14:12:45 <holzensp> mine does
14:12:59 <dbueno> huh, well that sucks.
14:13:08 <holzensp> philip-holzenspiess-mac-pro:SDL-0.5.5 holzensp$ runhaskell Setup configure --with-hsc2hs myhsc2hs
14:13:08 <holzensp> Setup.lhs:2:2:
14:13:08 <holzensp>     Warning: In the use of `defaultUserHooks'
14:13:08 <holzensp>              (imported from Distribution.Simple):
14:13:08 <holzensp>              Deprecated: "Use simpleUserHooks or autoconfUserHooks, unless you need Cabal-1.2
14:13:09 <holzensp>              compatibility in which case you must stick with defaultUserHooks"
14:13:11 <holzensp> Warning: defaultUserHooks in Setup script is deprecated.
14:13:13 <holzensp> Configuring SDL-0.5.5...
14:13:15 <holzensp> checking for sdl-config... no
14:13:17 <holzensp> checking for sdl11-config... no
14:13:19 <holzensp> configure: error: *** SDL not found! Get SDL from www.libsdl.org.
14:13:21 <holzensp> If you already installed it, check it's in the path. If problem remains,
14:13:23 <holzensp> please send a mail to the address that appears in ./configure --version
14:13:25 <holzensp> indicating your platform, the version of configure script and the problem.
14:13:27 <holzensp> woops, sorry... didn't mean to flood
14:13:58 <Lemmih> holzensp: Do you have the development version of SDL installed?
14:14:11 <dbueno> you can write <*!> when the applicative is also a monad =P
14:14:51 <holzensp> Lemmih: do you mean the SDL-devel-extras?
14:15:10 <Lemmih> holzensp: No idea. I've never used a mac.
14:15:19 <holzensp> hehehehe
14:15:25 <Lemmih> holzensp: Whatever package that gives you sdl-config.
14:17:07 <holzensp> Lemmih: mmm, looking for it; there was an sdl-config with the macports of sdl (so, not the framework, but the as-much-like-gnu-as-you'll-get-on-a-mac)
14:17:21 <holzensp> and SDL will cabal with the macports version
14:17:35 <holzensp> but then none of my programs will build (missing _SDL_main symbol)
14:17:42 <Cadynum> hi again. can you with some argument to the compiler decide what is going to be compiled in to the binary? better example: http://pastebin.com/m45e9b4cb
14:18:48 <holzensp> Cadynum: I only know ++ as list concatenation
14:18:50 <glguy> ?get-shapr
14:18:51 <lambdabot> shapr!!
14:18:51 <Lemmih> Cadynum: You can use CPP.
14:19:38 <Cadynum> holzensp, well it is list concatenation in this context also
14:19:48 <Cadynum> Lemmih, thanks, i will check it our
14:19:50 <Cadynum> out*
14:20:14 <holzensp> Lemmih: re-installed the macports sdl library, cabal works (although apple's ld keeps giving these weird "atom sorting error" errors - that seem to be best ignored, I've been told)
14:20:40 <Phyx-> ?get
14:20:40 <lambdabot> shapr!!
14:20:42 <Phyx-> lol
14:20:54 <Phyx-> ?help
14:20:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:20:59 <holzensp> Lemmih: but how do I now proceed to build Test.hs?
14:21:05 <Phyx-> ?help get
14:21:05 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:21:53 <Lemmih> holzensp: Follow the instruction from the previously mentioned link.
14:21:59 <kadaver> anyoen want a hadoop/amazon ec2 interface for haskell?
14:22:25 <kadaver> man im gonna write dijkstra with an IORef then translate it to a functinal algorithm
14:22:59 <holzensp> kadaver: why?
14:25:08 <dons> IORef boo
14:25:48 <holzensp> Lemmih: I'm looking at the instructions; there's mention of a Test.hs *with* cabal definition
14:26:00 <holzensp> I fear I'm a bit blind tonight ;)
14:26:09 <holzensp> don't see the build definition
14:27:14 <Phillemann> Is it bad to do: contents <- readFile name; writeFile (editContents contents) name?
14:27:21 <Lemmih> holzensp: Oh, right. Hm, it seems to be missing.
14:27:38 <Phillemann> Uhm, with parameters to writeFile reverses of course...
14:27:44 <Phillemann> *reversed
14:27:58 <monochrom> Yes it is bad, there is a race condition.
14:28:00 <Lemmih> holzensp: Tough luck.
14:28:17 <holzensp> Lemmih: hehehe, booohooo :'(
14:28:22 <Gracenotes> as somewhat of an improvement, you could use a Handle
14:28:45 <byorgey> Phillemann: yes, the file is read lazily, so likely that will try to start writing to the file before it has been completely read.
14:28:56 <Gracenotes> @hoogle withFile
14:28:56 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
14:28:56 <lambdabot> Distribution.Simple.Utils withFileContents :: FilePath -> (String -> IO a) -> IO a
14:28:56 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
14:29:00 <Gracenotes> :"o
14:29:22 <Phillemann> Isn't there a non-lazy version of readFile? :>
14:30:41 <Gracenotes> Handle functions: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
14:31:42 <blackh> Phillemann: Also see Data.ByteString - the IO functions in there are strict. You'll need to convert from ByteString to String afterwards if you want a String as output.
14:32:00 <dbueno> Is there a doc somewhere for how to decipher the names the ghc profiler assigns to type class methods?
14:32:20 <dbueno> I keep seeing things like get_atko in my profiler output.
14:33:04 <Phillemann> blackh: I don't really have to use String, I could replace it with ByteString.
14:33:27 <Deewiant> Phillemann: There is, it's called 'fmap (seq =<< length) . readFile'
14:34:10 <Gracenotes> or 'rnf' is somewhat more reliable
14:34:30 <Deewiant> That requires an import though :-P
14:34:39 <blackh> Will that approach guarantee to close the file handle?
14:35:01 <Deewiant> I think readFile guarantees a close when all the data has been read?
14:35:19 <Gracenotes> > let u = [1, 2, 3, undefined] in u `seq` head u
14:35:20 <lambdabot>   1
14:35:26 <Gracenotes> > let u = [1, 2, 3, undefined] in rnf u `seq` head u
14:35:27 <lambdabot>   * Exception: Prelude.undefined
14:35:38 <Phillemann> I have no idea what this fmap statement does, can I just replace "readLine foo" by "(fmap (seq =<< length) . readFile) foo" and it'll work? :>
14:35:52 <Gracenotes> still, I recommend handles. *wink*
14:36:21 <Cadynum> so, included some very simple #ifdef's in my code and it seems to compile with the -cpp option. the next questions is how i give them values via cabal or ghc when im comiling? :)
14:36:43 <dbueno> Cadynum: Just like gcc.  ghc -DVAR=VALUE
14:36:49 <Phillemann> Gracenotes: I listened. I'll look into all of the handle functions later. :>
14:37:03 <Gracenotes> ;)
14:37:05 <Heffalump> Phillemann: I don't think it will.
14:37:24 <Heffalump> do xs <- readFile foo
14:37:44 <Gracenotes>    launchMissiles
14:38:02 <Heffalump>    evaluate (length xs)
14:38:05 <Heffalump> will work, I think
14:38:05 <Cadynum> dbueno, cool, thanks! and if i want to do it with cabal? (sorry for question spam)
14:38:07 <monochrom> Then there will be nothing left to read.
14:38:20 <dbueno> cabal --ghc-option="-DVAR=VALUE"
14:38:25 <dbueno> maybe it's --ghc-options, I forget.
14:39:55 <Cadynum> dbueno, it was without s. thanks a lot!
14:40:07 <dbueno> Cadynum: np
14:41:36 <Matthes> I have issues with implementing my own enum instance for Haskell tuples. The Enumeration follows cantor's paring function. The exact problem is calling toEnum, i have created an example: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2191#a2191
14:41:55 <Matthes> Would be nice if anyone could tell me how to call toEnum correctly.
14:43:31 <Cale> Matthes: Provide a more specific type
14:43:39 <Cale> toEnum 17 :: (Integer, Integer)
14:43:40 <Matthes> sorry this is cleaner: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2192#a2192
14:43:57 <Cale> It's ambiguous what type you want.
14:44:13 <Cale> It can't be polymorphic if you also want to print it.
14:44:22 <holzensp> Matthes: you can't force a type to a type variable; in order to choose an actual implementation (i.e. to choose a dictionary), there needs to be a concrete type
14:44:25 <Matthes> Ah thank u
14:44:39 <Matthes> Works, so my homework is done :)
14:44:50 <MarcWeber> Matthes Read functional dependencies up on the wiki. They would provide what you're looking fro to some degree
14:45:00 <Cale> er...
14:45:03 <Gracenotes> o:
14:45:08 * Cale doubts that :)
14:45:17 <Gracenotes> (づの‿の)づ
14:45:38 <holzensp> Matthes: for future reference: you're not just trying to get the type checker to stop complaining, you're trying to tell it to find how your overloading works
14:46:09 <kerlo> Sometimes, you do in fact just want the type checker to stop complaining.
14:46:14 <holzensp> so, to actually evaluate, it shouldn't just figure out that there exists a valid evaluation, but it needs to actually find it
14:46:25 <holzensp> kerlo: sure, but not in these cases
14:46:34 <holzensp> *and*... most of the time, you really don't ;)
14:46:35 <kerlo> Aye.
14:47:27 <holzensp> the type checker does a lot of annoying complaining in the context of fake dependent types, because it can't resolve stuff like (x ~ Pred (Succ x))
14:47:37 <kerlo> GHC: "Type error, line 34." Me: "Prove it!" GHC: "...nvm, you're good."
14:47:48 <kerlo> Fake dependent types? Sounds intriguing.
14:47:48 <holzensp> lol
14:48:01 <holzensp> mmm, you probably don't want to go there ;)
14:48:11 <Gracenotes> fake dependent types are illegal in 29 states
14:48:16 <holzensp> it's all very promising, until you start actually building stuff with it ;)
14:48:29 <monochrom> Every time the type checker complains, it's because the human is incomplete or inconsistent.
14:48:36 <kerlo> Nonsense. I want to go everywhere.
14:49:09 <holzensp> monochrom: Tell me how to prove to the type checker that x ~ Pred (Succ x)
14:49:09 <Gracenotes> surely the type system is inconsistent itself
14:49:10 <holzensp> :p
14:49:21 <kerlo> GHC: "Hey! By Goedel's incompleteness theorems, I have the right to complain!"
14:49:24 <Matthes> Cale: The proof: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2193#a2193 (some vars are in german)
14:49:30 <monochrom> I don't know who are Pred and Succ.
14:49:43 <Elly> Pred and Succ are best friends
14:49:50 <holzensp> and close relatives
14:49:51 <holzensp> :D
14:50:05 <Gracenotes> what is Pred (Succ x) if x is Zero?
14:50:13 <holzensp> Zero
14:50:24 <monochrom> Pred (Succ Zero)
14:50:24 <kyagrd> Anyone using yi ?
14:50:27 <holzensp> it's slightly more tricky to say what (Succ (Pred Zero)) is
14:50:27 <Gracenotes> oh... right
14:50:41 <Gracenotes> yes
14:50:51 <holzensp> because Pred Zero is... erm... blasphemous
14:51:14 <holzensp> prohibited by UN Charter :D
14:51:17 * kerlo darns his keyboard, being new and unfamiliar.
14:51:37 <kyagrd> Are there documentations for configuring gtk font for yi?
14:51:44 <jeffwheeler> kyagrd: I'm using yi
14:51:54 <jeffwheeler> kyagrd: I can help you with that
14:52:06 <jeffwheeler> First, it's only the Pango UI now; Gtk is deprecated.
14:52:19 <jeffwheeler> (Are you using the darcs version or the one on Hackage?)
14:52:37 <kyagrd> Oh, that's why it's not following the GTK settings (yes I am using the one on Hackage)
14:52:53 <jeffwheeler> Yeah, Pango has replaced Gtk.
14:52:58 <kyagrd> How do I change GUI frontend fonts for yi then?
14:53:12 <jeffwheeler> In your configuration file, do you see how to set the size?
14:53:23 <jeffwheeler> It's Nothing in the example/yi.hs file.
14:54:49 <kyagrd> Oh, yes that is documented as a comment what about the font families or multibyte fonts and those kind of stuff
14:55:14 <jeffwheeler> It's Name, instead of Size, and a Maybe String.
14:55:38 <jeffwheeler> So, configFontName "Monospace" works great on my Linux system.
14:56:12 <kyagrd> isnt it (Just "Monospace") since its type is Maybe String?
14:56:30 <jeffwheeler> Err, yeah.
14:56:36 <jeffwheeler> That's right . . .
14:56:48 <kyagrd> Ah, I got it beautiful, thanks ...
14:56:55 <jeffwheeler> no problem
14:56:55 <Gracenotes> :O
14:57:04 <kyagrd> jeffwheelr, can I ask you one more thing?
14:57:10 <jeffwheeler> kyagrd: go ahead
14:57:26 <kyagrd> The buffer in the Pango UI doesn't seem to be working well.
14:58:04 <kyagrd> The comand buffer line at the bottom.  Commands are workign but it doesn't show anything it's just black whenever I type any command.
14:58:06 <jeffwheeler> I don't remember how stable it was in the last release, but you might try the darcs version and see how that works for you.
14:58:13 <kyagrd> Do you have the same problem?
14:58:38 <jeffwheeler> It was probably more unstable back then; it's improved since, and seems to be reasonably stable now.
14:59:37 <kyagrd> Thanks again for your help :)
14:59:48 <jeffwheeler> kyagrd: no problem; go tell all your friends about Yi!
15:05:51 <Phillemann> Shouldn't ByteString.pack "foobar" convert the literal [Char] to a ByteString?
15:06:35 <dbueno> Phillemann: only if you import Data.ByteString.Char8
15:06:36 <holzensp> you want Data.ByteString.Char8
15:06:41 <holzensp> ;)
15:06:44 <Phillemann> Hehe, okay
15:10:00 <Acteum> :t _|_
15:10:01 <lambdabot> parse error on input `|'
15:11:25 <monochrom> _|_ is not a Haskell symbol. It's for ourselves only.
15:11:47 <holzensp> you can feed it omega, if you really want it;
15:12:06 <Acteum> oh
15:13:02 <morphir> why does my interpreter say 'prelude'?
15:13:30 <holzensp> morphir: which interpreter do you use?
15:13:32 <pumpkin> because that's the implicitly loaded module
15:13:39 <holzensp> and when do you want it to say "prelude"?
15:13:44 <Gracenotes> > let (⊥) = undefined in fst (3, (⊥))
15:13:45 <lambdabot>   3
15:13:51 <morphir> I feel like some dude is using the chewbaca-defense on me -> it doesn't make any sense!
15:14:02 <pumpkin> > let (⊥) = undefined in fst (3, ⊥)
15:14:03 <lambdabot>   <no location info>: parse error on input `)'
15:14:05 <pumpkin> boo :(
15:14:07 <Gracenotes> because haskell will play you pretty music
15:14:54 <morphir> so installed 500MB language pack. This language better kick some serious ass!
15:15:00 <SubStack> Data.Bits uses _|_
15:15:10 <Gracenotes> > let _l_ = undefined in fst (3, _l_)
15:15:11 <lambdabot>   3
15:15:14 <Gracenotes> SubStack: .|.
15:15:19 <SubStack> oh right
15:15:22 * SubStack forgets
15:15:22 <Acteum> so it is a usable symbol?
15:15:25 <Acteum> oh
15:15:33 <Acteum> :t .|.
15:15:34 <lambdabot> parse error on input `.|.'
15:15:35 <Gracenotes> _ is considered a character, . and | are .. symbols
15:15:44 <holzensp> morphir: it does, rather
15:15:47 <Gracenotes> me supposes.
15:16:01 <holzensp> morphir: but which interpreter are you using? GHCi? Hugs?
15:16:15 <morphir> GHCi
15:16:33 <holzensp> morphir: and when doesn't it say 'Prelude'?
15:16:50 <morphir> hm?
15:17:07 <holzensp> oh, d'oh
15:17:12 <holzensp> nvrmnd... I should learn to read
15:17:13 <holzensp> ;)
15:18:00 <Gracenotes> ;_;
15:54:02 <hatds> is there a standard way to define a function says "take this IO() value and run it n seconds from now"?
15:54:33 <tromp> @hoogle sleep
15:54:34 <lambdabot> No results found
15:54:40 <olsner> @hoogle delay
15:54:40 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
15:55:19 <jmcarthur> maybe something like: \action n -> forkIO (threadDelay (n*1000000) >> action)
15:55:26 <skorpan> ACTION HERO!!!!
15:55:58 <QuietPurple> please can someone answer a question about Arrays?
15:56:01 <hatds> thanks
15:56:21 <olsner> skorpan: that was funny, remind me to speak in random capitalized exclamations more often :)
15:56:22 <jmcarthur> QuietPurple, just ask
15:56:41 <QuietPurple> ok: i'm trying to use Arrays to do matrix arithmetic
15:56:41 <BMeph_> Yeah, who's written a Haskell Array tutorial yet? :)
15:56:48 <sizur> is there any RFC websites that have RFC's as nice PDF's ala LaTeX?
15:56:59 <sizur> s/is/are/
15:57:02 <olsner> BMeph_: maybe array's a monad?
15:57:13 <jmcarthur> BMeph_, i've been thinking about it. it seems to be a confusing topic, especially considering all the different kinds we have with different performance characteristics
15:57:16 <QuietPurple> is there some way to create a function Array Int Int -> Array Int Int that requires the bounds to be the same?
15:57:25 <BMeph_> olsner: Yeah, and maybe Bob's your Uncle... ;p
15:57:45 <olsner> BMeph_: instance Uncle Bob? :P
15:57:57 <jmcarthur> QuietPurple, look into phantom types and GADTs
15:58:00 <paul424> how does this rule makes sense : join (fmap return xs) == xs,  fmap is of the type  :fmap :: (a -> b) -> f a -> f b. Where is the function for fmap ?
15:58:06 * BMeph_ facepalms
15:58:11 <byorgey> QuietPurple: there is, but that way lies madness
15:58:16 <QuietPurple> phantom types? they give me the chills...
15:58:31 <byorgey> QuietPurple: you could easily do something like that in a dependently typed language, where the dimensions of a matrix could be part of its type
15:58:33 <hatds> fmap (return) (xs) essentially?
15:58:46 <sizur> QuietPurple: yeah, a type safe way of the type unsafe. ;)
15:58:50 <byorgey> QuietPurple: but in Haskell you'd have to sort of simulate dependent types using type-level arithmetic and so on.
15:58:55 <byorgey> it's been done.
15:59:11 <QuietPurple> sounds scary
15:59:13 <jmcarthur> QuietPurple, also take a peek at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix-static
15:59:17 <olsner> isn't there a gsoc project on getting type-level ints into ghc?
15:59:31 <QuietPurple> how would you recommend implementing matrix arithmetic? just using lists?
15:59:56 <byorgey> olsner: are you thinking of the project with Conor McBride?
16:00:02 <byorgey> it's not a gsoc project AFAIK
16:00:03 <BMeph_> paul424: Contrary to what you learned from Java, in Haskell, 'return' is a function. ;)
16:00:10 <olsner> or maybe I'm thinking about a phd student position
16:00:10 <jmcarthur> QuietPurple, it depends on your situation, but arrays would probably be nicer than lists for that in most cases
16:00:35 <paul424> BMeph_: I know just forgot tho read it as a left associative
16:00:54 <QuietPurple> ok, so i'll just use Maybe to cover the function's lack of totality i guess...
16:00:59 <dddddd> > let tenth (x:y:a:s:d:f:r:i:o:p:ys) = p in [1..10]
16:01:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:01:10 <dddddd> > let tenth (x:y:a:s:d:f:r:i:o:p:ys) = p in tenth [1..10]
16:01:12 <lambdabot>   10
16:01:16 <dddddd> > let tenth (x:y:a:s:d:f:r:i:o:p:ys) = p in tenth [1..20]
16:01:18 <lambdabot>   10
16:01:29 <dddddd> that is still o(10) right?
16:01:42 <jmcarthur> QuietPurple, http://hackage.haskell.org/packages/archive/hmatrix-static/0.1/doc/html/Data-Packed-Static-Matrix.html#t%3AMatrix
16:01:46 <byorgey> QuietPurple: you could also just have it throw an error if the dimensions don't match, and put a big warning in the function's documentation
16:02:01 <BMeph_> paul424: I rather prefer Eugenia Cheng's explanation. ;)
16:02:11 <byorgey> QuietPurple: if this is a function you will only be using internally, that might be nicer than always having to deal with a Maybe result
16:02:21 <olsner> > let tenth = head . drop 10 in tenth [1..20]
16:02:22 <lambdabot>   11
16:02:26 <olsner> > let tenth = head . drop 9 in tenth [1..20]
16:02:28 <lambdabot>   10
16:02:36 <olsner> embarrassing :/
16:02:39 <hatds> [1..20] !! 11
16:02:41 <pumpkin> why not use !! ?
16:03:17 <olsner> evidently, it's time to go to bed :)
16:03:20 <jmcarthur> > [1..20] !! 9
16:03:21 <lambdabot>   10
16:03:40 <QuietPurple> ok, that's what I did before---I'm just trying to be all growed up and monadic when really I should stick to the simple stuff :-)
16:03:42 <jmcarthur> @src (!!)
16:03:42 <lambdabot> xs     !! n | n < 0 = undefined
16:03:43 <lambdabot> []     !! _         = undefined
16:03:43 <lambdabot> (x:_)  !! 0         = x
16:03:43 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:04:23 <jmcarthur> that's... kind of a yucky definition
16:04:51 <QuietPurple> well, thanks guys
16:06:49 <BMeph_> he more I learn, the more I realize tthat there's a whole lot more to learn.... Exciting, and depressing, all at once! :\
16:06:56 <BMeph_> *The
16:07:00 <Botje> stop learning stuff :]
16:07:34 <BMeph_> Botje: s/learning/eating/
16:07:48 <paul424> BMeph_: is she some kind a category theory guru ? or something ...didn't get that ,,,,,,,,
16:08:07 <BMeph_> @go Catsters
16:08:08 <lambdabot> http://www.youtube.com/user/TheCatsters
16:08:09 <lambdabot> Title: YouTube - TheCatsters's Channel
16:08:20 <BMeph_> paul424: ^^ There ya go. :)
16:09:03 <BMeph_> paul424: Short answer, yes, she's some kind of category theory guru. She literally gets paid to do that stuff. ;)
16:21:57 <cads> greetings!
16:26:18 <dddddd> doesnt haskellers know that it is bad to force the programmer to knwo the internals of things?
16:26:28 <dddddd> i find a lot of haskell apis to be retty meh
16:26:37 <marcot> Hello, is there a type class like MArray but with a default index Int starting with 0?
16:27:04 <marcot> I wanted to define an instance of MArray for gtk2hs ListStore, but the problem is that ListStore only accepts Int as an index.
16:28:06 <pumpkin> dddddd: have anything specific?
16:28:06 <BMeph_> marcot: You'll likely have to newtype one up. :\
16:28:23 <marcot> BMeph_: =(
16:28:34 <Cale> dddddd: Like what?
16:29:10 <lpsmith> dddddd:  I think it's actually a very good idea to have at least a rough idea of the internals
16:29:16 <lpsmith> not gory details,  necessarily
16:29:19 <Saizan> BMeph_: how does newtype helps here?
16:30:46 <Cale> This is the first time I've heard someone complain that Haskell code is insufficiently abstract :)
16:31:30 <harovali> what do I have to import in order to define a new data ?
16:31:42 <Cale> harovali: nothing
16:31:43 <harovali> that involves Just and Nothng
16:31:57 <Cale> harovali: the Prelude has Maybe defined in it
16:32:07 <Cale> and it should be imported automatically
16:34:16 <Cale> harovali: If you mean you'd like to define a new datatype which uses those names for constructors, then you'll have to hide the Prelude's definition
16:34:34 <Cale> import Prelude hiding (Maybe(..))  ought to do it
16:35:16 <harovali> Cale: what's wrong here then ? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2194#a2194
16:35:27 * Cale has a look
16:35:34 <harovali> (please)
16:35:41 <Cale> harovali: Just is not a type constructor.
16:35:58 <Cale> It's a data constructor for types constructed with the Maybe type constructor
16:36:14 <Cale> data constructors are not allowed to appear in types
16:36:20 <dddddd> lpsmith: being able to find or get an idea of them yes
16:36:30 <stepcut> in GHC 6.10.1 you could do, ghc-pkg -f new.package.conf register foo.conf, where new.package.conf does not exist until you run that command. But in 6.10.2, it fails. Anyone know that is intentional?
16:36:30 <dddddd> having t figure them out to call a function ,no
16:36:50 <harovali> Cale: didn't know the difference between data and type constructors
16:36:54 <Cale> dddddd: Could you provide an example of what you mean?
16:37:22 <Cale> harovali: data constructors construct values, type constructors construct types
16:37:57 <harovali> Cale: i think dddddd means that if he mentios a function , ghci automatically imports the library where it lives ;-)
16:38:08 <harovali> s/mentios/mentions/
16:38:13 <Cale> It doesn't do that though.
16:38:24 <Cale> Unless that's new in 6.10.2 :P
16:38:30 <harovali> Cale: true, but it could, couldn't it ?
16:38:48 <Cale> I suppose, except that would often be ambiguous.
16:39:02 <harovali> Cale: non-determinism - ly
16:39:10 <hatds> auto imports would be nice when typing in a text editor
16:39:23 <Cale> heh, it tries all possibilities and displays results for every one which typechecks ;P
16:39:24 <harovali> hatds: very nice indeed
16:39:36 <harovali> Cale: why not ?
16:40:08 <stepcut> xb
16:41:43 <Cale> I can imagine that being irritating if you knew which one you wanted and just forgot to do the import.
16:42:04 <harovali> Cale: please peek http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2194#a2195
16:43:06 <Cale> There, you're defining a new data constructor called Maybe, and one called Nothing (which will conflict with the Prelude's definition)
16:43:15 <pumpkin> Just?
16:43:31 <pumpkin> oh, weird
16:43:32 <Cale> also, that type will be recursive
16:43:44 <harovali> yes?
16:44:12 <Cale> What are values of type Repr supposed to look like?
16:44:37 <harovali> Cale:  String Int Int
16:44:41 <harovali> or Nothing
16:44:43 <harovali> say
16:45:04 <Cale> Well, you shouldn't use the name Nothing, as it's already taken.
16:45:33 <cooldude127_> anybody in here using haskell-mode with emacs? when i enter a line at the repl, it gets copied down to the next line followed by a "^J". this just started after i upgraded ghc to 6.10
16:45:39 <Cale> data Repr = Empty | Something String Int Int
16:45:40 <pumpkin> even the name Maybe seems weird
16:45:50 <harovali> Cale: hmm
16:45:58 <Saizan> cooldude127_: install ghci-haskeline from hackage
16:46:02 <harovali> pumpkin: i see
16:46:10 <cooldude127_> Saizan: ok will do
16:46:21 <harovali> this is my first data model in haskell
16:46:24 <Saizan> cooldude127_: oh, and if you're using cabal-install be sure to upgrade it to 0.6.x
16:46:31 <Cale> harovali: Maybe is a type constructor, but you're reusing the name as a data constructor, which is permitted, but strange.
16:46:42 <cooldude127_> Saizan: my cabal-install was just reinstalled so i should be good
16:46:54 <harovali> Cale: i'd prefer not to
16:46:55 <Cale> You could also use:  data Repr = R (Maybe (String, Int, Int))
16:47:06 <Saizan> cooldude127_: yup, cabal --version anyway
16:47:08 <harovali> Cale: interesting
16:47:27 <cooldude127_> Saizan: 0.6.2 i'm set
16:47:31 <cooldude127_> it installed, now i get to test
16:48:37 <cooldude127_> Saizan: thank you very much, that fixed it right up
16:48:42 <cooldude127_> this is why i love irc
16:49:18 <Saizan> np :)
16:52:41 <dddddd> http://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-SP.html
16:53:07 <dddddd> 6ne exhttp://hackage.haskell.org/packages/archive/fgl/5.4.2.2/doc/html/Data-Graph-Inductive-Query-one example
16:53:33 <pumpkin> well, given that fgl has pretty light documentation, I wouldn't consider it a particularly good example
16:54:10 <pumpkin> it's not that the API requires you to know the internals, it's just that the author didn't document it
17:03:48 <Saizan> there's a paper/manual about fgl
17:05:04 <pumpkin> yeah, but it's a million years out of date
17:05:08 <pumpkin> a lot of the stuff has changed
17:05:20 <pumpkin> maybe even a million and one
17:18:55 <kyagrd> Has the new Haskell logo been officially announced?
17:19:41 <kyagrd> It seems that logo changed on the FrontPage of haskell.org but I see neither announcements nor changes in the logo related wiki pages.
17:20:57 <mofmog1> so a ton of "classic" algorithms rely on state
17:21:05 <mofmog1> how do people go around implementing them in haskell?
17:21:19 <mofmog1> eg alpha beta pruning or dijkstra's algorithm
17:21:33 <pumpkin> rely on mutable state?
17:22:02 <mofmog1> i can do a generic alpha beta pruning algorithm in python, simple
17:22:06 <mofmog1> but it seems a lot harder in haskell
17:22:09 <kyagrd> mofmog1: there are several ways, you can either do it just passing around the state arguments (if apha beta pruning it would be a tree) in a functional style
17:22:34 <mofmog1> wrapping in a state monad perhaps?
17:22:42 <kyagrd> If there are several bunch of states to consider and they have certain semantics you can package it with monad such as a state monad
17:22:47 <cooldude127_> Saizan: actually, i'm having that problem again in emacs
17:23:16 <kyagrd> Or, you can just use IO moand and mutable structures int he most imperative way.
17:23:28 <mofmog1> hrm, it just seems like you have to hack it in there
17:24:04 <EvilTerran> on the other hand, there's plenty of algorithms where immutable structures are a big win, too
17:24:05 <kyagrd> mofmog1: it's not hacking. not so much different once u get used to it.
17:24:31 <EvilTerran> list tail sharing and whatnot
17:24:38 <kyagrd> mofmog: most tree algorithms are more concise to implement in functional languages.
17:24:59 <mofmog1> of course of course
17:25:00 <kyagrd> Array updates is less natrual to do it.
17:25:15 <Gracenotes> wasn't it.. an algorithm that's O(n) imperatively can be implemented O(n log n) functionally?
17:25:20 <Gracenotes> or less
17:25:50 <mofmog1> does that scale?
17:25:56 <mofmog1> to other polynomials
17:26:01 * QtPlaty[HireMe] doesn't think that is the case in general.
17:26:06 <dolio> You can trivially implement it in O(n log n) by faking pointers with a map.
17:27:03 <dolio> You might be able to do a better job saving the same overall problem, though.
17:27:16 <dolio> Solving the same ... even.
17:27:32 <kyagrd> Note, someone also showed that there exists probems that require less time complexity for functional than imperative. (I don't know how practical and how many of those algorithms are like that. do anyone remember the reference for this?)
17:28:00 <mofmog1> you know it's funny
17:28:05 <dolio> Are you sure that's what you mean?
17:28:20 <mofmog1> solving problems in python isn't fun at all, but trying to do it in haskell is just cool
17:28:53 <dolio> There was a paper that showed that a lisp with mutable update could solve a particular problem asymptotically faster than a pure-functional lisp.
17:29:13 <dolio> And then someone came along and showed that lazy evaluation allowed you to regain the lost performance.
17:29:35 <Gracenotes> laziness is a bit harder imperatively, I'd imagine
17:29:42 <kyagrd> dolio: oh, it was maybe that one ...
17:29:51 <Berengal> Laziness is next to impossible in imperative languages
17:29:51 <mofmog1> can i get a link to that paper
17:31:47 <dolio> http://www.comlab.ox.ac.uk/people/richard.bird/online/BirdJonesDeMoor1997More.pdf
17:32:29 <dolio> The point would seem to be that laziness gives you just enough assignment. :)
17:35:38 * mofmog1 's fancy of learning the linux kernel just died
17:59:59 <Saizan> cooldude127_: did you set haskell-mode to use ghci-haskeline ?
18:12:11 <byteshack> has anyone installed ghc and ghc-devel via macports recently?
18:13:45 <Adamant> byteshack: I wouldn't unless you have to. ghc on Macports was flaky for quite a while
18:14:02 <Adamant> and I wouldn't be surprised it was flaky again now
18:14:19 <Adamant> get a binary copy from ghc's page
18:14:37 <byteshack> then install all else via cabal?
18:14:43 <Adamant> yes
18:14:46 <Adamant> should be fine
18:14:55 <pejo> Adamant, when was it flaky?
18:15:03 <byteshack> thanks, now to see how to remove macports
18:15:11 <Adamant> pejo: most of 2007 and into 2008
18:15:57 <pejo> I haven't had any problems with it and the only ghc I've been running is from macports.
18:16:34 <Adamant> ok, well I couldn't get it to compile for love or money in the Macports system and there was a longstanding bug in the database that took forever to get fixed
18:16:43 <Adamant> *bug database
18:17:03 <Adamant> there were a lot of other people who had the same problem I did
18:17:31 <pejo> Ok, just saying that my experience has been rather the opposite, the package maintainer was very quick to reply when I mailed him sometime during christmas hollidays.
18:17:36 <Adamant> the main problem with Macports is that the Mac packaging system efforts are split over too many systems
18:17:48 <Adamant> pejo: there may have been a new maintainer
18:18:41 <Adamant> in which case what I was implying could be completely wrong, but I was pretty frustrated that I couldn't build ghc from Macports when I first got my Mac
18:19:11 <Adamant> it was problem with doing it on Intel Leopard system or something, IIRC
18:19:15 <Adamant> *a problem
18:19:50 <Adamant> this was shortly after Leopard came out
18:20:41 <pejo> Ah, ok. I'm still not running Leopard, so that might explain why.
18:20:59 <zoheb> Is there a standard function that I can use instead of if-then-else
18:32:10 <twb> Is there a type class for `length`?
18:32:29 <twb> It would include lists and bytestrings and such, I think.
18:33:43 <pumpkin> IsString might be it
18:34:07 <pumpkin> guess not really
18:34:13 <twb> Bummer.
18:41:55 <Berengal> > let (.) = fmap in ((+5).(*2)) . [1..5]
18:41:56 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
18:42:06 <Berengal> > let a . b = fmap a b in ((+5).(*2)) . [1..5]
18:42:08 <lambdabot>   [7,9,11,13,15]
18:44:28 <dabblego> Berengal, I believe that's the MR
18:45:18 <dabblego> > let (.) :: (Functor f) => (a -> b) -> f a -> f b; (.) = fmap in ((+5).(*2)) . [1..5]
18:45:19 <lambdabot>   [7,9,11,13,15]
18:46:15 <Berengal> dabblego: Yeah, it was working fine on my machine until I noticed I had turned off the MR
18:49:40 <Berengal> (.) = fmap is fun. Makes lifting functions much clearer IMO
18:49:50 <Berengal> unlines . map (toUpper.) . words . getLine
18:50:45 <mjrosenb> hey, does anyone know when readProcess was added to the Standard Libraries?
18:50:57 <ray> what's fmap for functions normally?
18:51:03 <mhydronic> !seen QtPlaty[HireMe]
18:51:22 * QtPlaty[HireMe] waves his hand around like a man drowning.
18:51:30 <pumpkin> ray: composition
18:51:42 <ray> oh
18:51:43 <mjrosenb> ray: my guess would be composition
18:51:46 <mjrosenb> efb
18:51:48 <mjrosenb> by alot
18:51:49 <mhydronic> hey qt, i was hoping 'seen' would give me more helpful info
18:52:05 <pumpkin> > liftM2 (*) (+1) (+5) 4
18:52:07 <lambdabot>   45
18:52:23 * QtPlaty[HireMe] laughs.
18:53:41 <mhydronic> so what do you think of this: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2197
18:54:20 <mjrosenb> it seems like ghc-6.8.2 does not have readProcess
18:54:27 <mjrosenb> which is quite unfortunate
19:01:02 <mhydronic> QtPlaty[HireMe]: what do you think?
19:02:09 <mhydronic> it seems to return a balanced tree. its kind of an ugly tree but its balanced, i think
19:03:55 <QtPlaty[HireMe]> That makes more sence.
19:03:59 <Petrosian> Hey, anyone happen to know what the acronym "HBC" stands for, as in the HBC compiler?
19:04:01 * QtPlaty[HireMe] nods.
19:04:03 <dolio> You can probably do somewhat better by computing the length once at the beginning and passing it down.
19:04:36 <dolio> Instead of re-traversing lists at every level.
19:06:51 <mhydronic> dolio: why wouldn't it retraverse lists that way? this isn't really retraversing - just splitting
19:07:56 <dolio> mhydronic: I mean, At the top, you compute the length of the list, and split it in half. Then, at level 2, you compute the length of both lists, and split them in half.
19:08:18 <dolio> But you already know the lengths, they're n`div`2 and n - (n`div`2).
19:08:50 <dolio> And the arithmetic there is probably faster than calling length again.
19:10:57 <mhydronic> ah, i thought you meant something else
19:11:29 <dolio> You have to retraverse for splitAt every time, of course.
19:11:50 <dolio> But you're eliminating one traversal at each level (other than the first) for length.
19:12:41 <blackdog_> before i rewrite it for the nth time, is there a levenshtein library for bytestrings?
19:12:56 <mhydronic> ok thanks
19:17:31 <Techcreator> is someone online?
19:17:39 <Berengal> Is there a reason why maximum and minimum aren't strict?
19:18:15 <dolio> @src maximum
19:18:16 <lambdabot> maximum [] = undefined
19:18:16 <lambdabot> maximum xs = foldl1 max xs
19:19:25 <Berengal> > maximum [1..10^6]
19:19:28 <lambdabot>   * Exception: stack overflow
19:19:33 <Berengal> > let maximum xs = foldl1' max xs in maximum [1..10^6]
19:19:35 <Techcreator> i thinking just future what kind it be....If we not lived still in this society where we live now
19:19:35 <lambdabot>   1000000
19:20:09 <Techcreator> in future programs are great because we create them to humanity and not for selling them
19:20:18 <dolio> Well, the historical reason is that foldl' doesn't exist in  the Haskell98 report, so no prelude functions use it.
19:20:51 <dolio> GHC actually has a rule to use foldl1' for [Int] and [Integer], according to the source.
19:21:00 <dolio> But it seems that isn't kicking in here for some reason.
19:22:10 <Berengal> Well, it seems like there's no reason to not make it strict...
19:22:18 <cooldude127_> Saizan: how do i set it to use ghci-haskeline
19:22:33 <Berengal> Also, would it be an idea do define a maximum' = foldl' max minBound ?
19:23:33 <dolio> Depends. minBound isn't in the empty list, so it all depends what you want.
19:23:54 <dolio> Not everything has a min/maxBound, too. Integer is unbounded.
19:23:56 <Berengal> it's the identity though...
19:24:06 <Berengal> Yeah, that's why I suggested a new name
19:24:23 <Berengal> > sum []
19:24:24 <lambdabot>   0
19:24:29 <Berengal> > product []
19:24:30 <dolio> Also, if you're going to have a min and maxBound, you might want to use foldr, for short circuiting.
19:24:30 <lambdabot>   1
19:24:49 <Berengal> > let maximum' = foldl' max minBound in maximum' ([]::[Int])
19:24:51 <lambdabot>   -9223372036854775808
19:24:56 <dolio> (Although that's nevertheless strict in the "accumulator".)
19:25:33 <Berengal> Hmmm, yes, that could be possible
19:26:03 <dolio> Of course, short circuiting is more complicated than just foldr max, since I don't think max checks for a maxBound first argument before comparing.
19:26:10 <Berengal> foldr' (\a b -> if a == maxBound then a else max a b) minBound...
19:26:17 <dolio> Right.
19:26:59 <cooldude127_> Saizan: i figured it out, and that worked
19:27:13 <Techcreator> future, games will be very different from today, because everyone have access to new version of tech, so no worry anymore making "video settings" in game, because everyone can get best computer right away
19:27:32 <Techcreator> we do right now much waste with resources because we live still in monetary system
19:27:38 <Techcreator> much outdated versions is around
19:27:48 <Berengal> Transhumanism much?
19:28:12 <jedai> Singularity ! Singularity !!
19:28:33 <dolio> Berengal: Anyhow, the reason maximum doesn't use foldl1' always is that it has to agree with the strictness in the report, due to being in the prelude.
19:28:42 <Berengal> let singularity = iterate fix AI
19:28:58 <dolio> Since the prelude maintains H98 compatibility.
19:29:16 <dolio> I don't know why the optimization for [Integer] isn't firing.
19:29:31 <dolio> Maybe lambdabot isn't compiling with optimizations anymore.
19:29:40 <Berengal> dolio: It doesn't fire on my box either...
19:29:49 <dolio> Weird.
19:30:00 <Berengal> dolio: And some others I've asked...
19:30:05 <apsod> Is there a quick way to convert [a,a] -> (a,a)?
19:30:23 <Berengal> dolio: Anyway, isn't maximum strict no matter which foldl1 is used?
19:30:34 <blackdog_> split (a:b:_) = (a,b)
19:30:44 <blackdog_> horribly partial, though :)
19:30:55 <apsod> heh
19:30:59 <jedai> apsod: sorry but [a,a] isn't a type
19:31:08 <apsod> jedai: No, it isn't.
19:31:10 <dolio> Berengal: It's strict in the list, but seqing on the accumulator might produce different behavior depending on max.
19:31:23 <apsod> I'm just looking for a better way to do (\[x,y] -> (x,y))
19:31:30 <jedai> apsod: do you mean [a] -> [(a,a)] or [a] -> (a,a)
19:31:45 <apsod> [a] -> (a,a)
19:31:45 <jedai> apsod: There isn't
19:31:49 <blackdog_> apsod: there isn't really a good way of doing that :)
19:31:54 <apsod> nuts. I'll just use the lambda then :D
19:31:56 <apsod> Thanks guys :3
19:31:57 <blackdog_> what do you do if the list is empty?
19:32:00 <apsod> _|_
19:32:20 <blackdog_> that's not _|_, dammit
19:32:24 <apsod> :(
19:32:32 <conal> i missed the start, but i imagine there's a fairly nice way using &&&
19:32:40 <apsod> conal: That's what I thought I've seen before.
19:32:47 <conal> oh, okay.
19:32:51 <conal> :type head &&& (head.tail)
19:32:51 <jedai> head &&& head . tail
19:33:02 <conal> @type head &&& (head.tail)
19:33:03 <lambdabot> forall a. [a] -> (a, a)
19:33:11 <conal> lb's night off?
19:33:17 <conal> ok
19:33:23 <cooldude127_> @type (&&&)
19:33:24 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:33:25 <apsod> hurr, yeah, that works
19:33:54 <conal> apsod: there's always a way
19:33:58 <apsod> yup.
19:34:02 <jedai> I wouldn't qualify that as much better that (\[x,y] -> (x,y)) though, especially considering that the lambda at least is restricted to input that makes sense
19:34:07 * apsod nods at jedai 
19:34:24 <dolio> Berengal: Are you compiling with -O? "main = print (maximum [1..10^6] :: Integer)" works with -O here.
19:34:28 <apsod> And the intent of the lambda is certainly clearer at first glance
19:34:31 <conal> good point.  not equivalent.
19:34:37 <Berengal> dolio: I was working in ghci
19:34:46 <dolio> Oh, yeah, that'll do it, too.
19:34:49 <conal> they disagree for lists with more than 2 elements
19:34:52 <dolio> No optimizations in ghci.
19:35:13 <Berengal> dolio: I figured as much...
19:35:36 <Berengal> Anyway, that figured out, who's for removing if-then-else from the language?
19:36:07 <Techcreator> our tech and everything is mostly very low level because we keep this corrupted society running on still
19:36:16 <conal> Berengal: i'd like it to be less special (more general).  e.g. overloadable.
19:36:23 <Techcreator> so solution for this problem is take new step to forward
19:36:31 <jedai> Berengal: I'm for adding if' to the Prelude, but that's all (or what Conal said)
19:36:38 <dabblego> conal, Bool -> m a -> m a -> m a ?
19:36:57 <Berengal> Yeah, I'm for adding if' as well, but in the long run I could see if-then-else removed alltogether
19:36:58 <jedai> Techcreator: What political organization would have your favor ?
19:36:59 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1 max [undefined, maxBound]
19:37:01 <lambdabot>   ()
19:37:02 <conal> dabblego: very often i want f Bool
19:37:07 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1 max [undefined, maxBound] :: Integer
19:37:08 <lambdabot>       No instance for (Bounded Integer)
19:37:08 <lambdabot>        arising from a use of `max' at...
19:37:12 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1 max [undefined, maxBound] :: Int
19:37:13 <lambdabot>   9223372036854775807
19:37:18 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1' max [undefined, maxBound] :: Int
19:37:20 <lambdabot>   9223372036854775807
19:37:24 <dolio> Hmm...
19:37:38 <Techcreator> there is one great solution to this problem and its called "Venus Project" and its about Resource Based Economy
19:38:20 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1 max [undefined, 5, maxBound] :: Int
19:38:21 <lambdabot>   9223372036854775807
19:38:25 <dolio> > let max x y | y == maxBound = maxBound | x < y = y | otherwise = x in foldl1' max [undefined, 5, maxBound] :: Int
19:38:27 <lambdabot>   * Exception: Prelude.undefined
19:38:29 <dolio> There we go.
19:38:55 <Berengal> dolio: Yeah, I saw that coming...
19:39:43 <Berengal> dolio: Unless you redefine max though, this won't be happening, will it?
19:40:07 <Berengal> dolio: The difference, I mean
19:40:31 <Techcreator> its not perfect step to new society, because there is no utopia, because we are allways evolving, but its better society than what we have now
19:40:36 <dolio> Well, if I define 'newtype MyInt = I MyInt' and define max for it to be like the above, then the H98 report says that the first one is right, and the second is wrong.
19:40:51 <Berengal> ?index max
19:40:51 <lambdabot> Prelude
19:40:56 <Berengal> ?src max
19:40:57 <lambdabot> max x y = if x <= y then y else x
19:41:04 <dolio> @src Ord
19:41:05 <lambdabot> class  (Eq a) => Ord a  where
19:41:05 <lambdabot>     compare      :: a -> a -> Ordering
19:41:05 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
19:41:05 <lambdabot>     max, min         :: a -> a -> a
19:41:10 <Berengal> Ah, there we go
19:41:39 <Berengal> Yeah, okay, I can see it now
19:41:59 <Berengal> If min and max was moved out of the class, however, I would be right :P
19:42:03 <dolio> For Int it wouldn't make a difference, hence the RULE.
19:42:37 <tsLight> I have declared my own class Expr, which derives Show. Now I want to write my own show function for it. I get "Ambiguous variable occurrence "show"" error if I declare it normally, any ideas?
19:42:43 <dolio> Well, I think if you define "x <= y = if y == maxBound then True else ..." you get the same effect.
19:43:03 <Berengal> tsLight: Don't derive show, instead declare an instance manually
19:43:21 <tsLight> Berengal, I am trying to do that but I get other errors
19:43:38 <tsLight> instance (Show a) => Show (Expr a) where
19:43:58 <Berengal> tsLight: Paste?
19:43:59 <Berengal> @paste
19:44:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:44:05 <tsLight> Illegal type "Expr a" in constructor application
19:44:10 <tsLight> you want the entire source?
19:44:38 <Berengal> tsLight: I want the relevant parts of it and the error
19:44:45 <tsLight> ok
19:45:24 <Berengal> dolio: strictness analyzis makes my head hurt :( Why can't everything just work? ;)
19:45:40 <tsLight> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4107#a4107
19:46:04 <dolio> Berengal: You should program in a total language. Then reduction order doesn't matter. :)
19:46:49 <Berengal> dolio: Totality doesn't always work out nicely either.
19:47:02 <Berengal> I want my cake and eat it too dammit!
19:47:24 <Berengal> tsLight: I see no instance declaration in that code...
19:47:26 * pumpkin eats Berengal's cake
19:47:35 <tsLight> thats the old one
19:47:35 <Berengal> pumpkin: You can't have it!
19:47:40 <tsLight> if I change the show :: line
19:47:42 * pumpkin already did
19:47:45 <tsLight> for "instance Show Expr where"
19:47:52 <tsLight> then I get "Overlapping instances for class "Show""
19:47:57 <Berengal> pumpkin: No, you just ate it
19:48:18 * pumpkin "expels" the cake, and now "has" it
19:48:21 <Berengal> tsLight: You need to remove the "deriving (Show)" part from your data Expr
19:48:21 * apsod shakes his fist at FreeBSD ports -- when is GHC 6.10 going to become available ;_;
19:48:21 <QtPlaty[HireMe]> Is there anything of the form  [a] -> Int -> Maybe a ?
19:48:31 <lispy> ?hoogle [a] -> Int -> Maybe a
19:48:32 <lambdabot> Prelude (!!) :: [a] -> Int -> a
19:48:32 <lambdabot> Data.List (!!) :: [a] -> Int -> a
19:48:32 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
19:48:34 <pumpkin> QtPlaty[HireMe]: like a safe !! ?
19:48:40 <tsLight> Berengal, why is that? Its trying to use the default function?
19:49:07 <Gracenotes> hah. "most people use the term immutable for in-memory data structures that cannot be modified semantically (regardless of how shared versions are implemented), and persistency for techniques of writing stuff to disk and restoring it later. I just read half a book on Haskell and AFAIR it uses these definitions too." -- Guido
19:49:20 <Berengal> tsLight: It's trying to declare it an instance twice. If you want to make it an instance manually you can't have one made by the compiler around at the same time
19:49:24 <Gracenotes> only half??
19:49:26 <Gracenotes> o;o
19:49:38 <tsLight> Berengal, ok, thanks :)
19:50:07 <QtPlaty[HireMe]> pumpkin: Eactly.
19:50:10 <Berengal> Gracenotes: link perchance?
19:50:12 <lispy> Gracenotes: after the section on syntax he gave up?
19:50:35 <Gracenotes> in the comments for (incidentally) a post about http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html
19:50:36 <pumpkin> QtPlaty[HireMe]: hmm, don't know of one, but you can write one easily with a zip and a find... not ideal though :/
19:51:12 <Gracenotes> :D
19:51:27 <Berengal> @pl {safeIx (x:xs) 0 = Just x; safeIx (x:xs) n = safeIx xs (n-1); safeIx [] n = Nothing}
19:51:28 <lambdabot> (line 1, column 1):
19:51:28 <lambdabot> unexpected "{"
19:51:28 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
19:51:32 <Berengal> :/
19:51:50 <lispy> you could implement it via catch
19:51:52 <Gracenotes> coming away with the opinion "I don't think the benefits of enforcing side-effect-free code (even optionally) make up for the many work-arounds you have to use to get anything done in the real world. (Not even in Haskell, FWIW. :-)"
19:53:16 <lispy> Yeah, you can't tell someone the benefit of these things
19:53:24 <lispy> They have to see it or experience it, IMO
19:56:22 <Berengal> Python's dynamic nature makes juggling the code around in the compiler really hard
20:00:24 <tsLight> is there a pre-defined type for binary trees, or I have to define one myself?
20:03:04 <Gracenotes> not binary trees, no. n-ary trees is in Data.Tree, though
20:03:04 <Gracenotes> are
20:03:07 <Gracenotes> data Tree a = Leaf | Node (Tree a) a (Tree a)
20:03:28 <Gracenotes> or Node a (Tree a) (Tree a), that sort of thing
20:03:51 <tsLight> ok
20:08:16 <BMeph> K has some fun functions, but some ridiculous choices for functional variants.
20:11:07 <Axman6> K?
20:15:46 <deech> Hi all, In STM is there a safe way of reporting that a function is stuck in 'retry' without using unsafeIOToSTM?
20:24:21 <hatds> is there a concise way to write the following function?
20:24:23 <hatds> f :: IO () -> Maybe (IO a) -> Maybe (IO a)
20:24:28 <hatds> f y (Just x) = Just $ y >> x
20:24:33 <hatds> f y _ = Nothing
20:24:38 <hatds> ?
20:25:11 <pumpkin> fmap (y >>) ?
20:25:18 <hatds> ah
20:25:29 <hatds> thanks
20:25:42 <pumpkin> I think
20:25:59 <pumpkin> :t let f y = fmap (y >>) in f
20:26:01 <lambdabot> forall (m :: * -> *) a (f :: * -> *) b. (Functor f, Monad m) => m a -> f (m b) -> f (m b)
20:26:09 <Gracenotes> righto
20:54:27 <BMeph> Axman6: K has an odd collection of useful functions.
20:54:38 <Axman6> i'm assuming it's an language?
20:54:55 <Axman6> a language*
20:55:06 <Axman6> maybe it's an hero too
20:55:47 <BMeph> Axman6: Yes, it's a programming language, made by one of the guys behind APL.
20:55:57 <Axman6> fair enough
20:57:22 <jorizma> it is also utterly terrifying.
20:57:37 <BMeph> Axman6: One of the interesting twists about it is that it has a facility to "convert" all of those funny symbol operators into words. It looks remarkably like Forth afterwards.
20:57:38 <jorizma> .. and i do perl at work.
20:57:58 <tsLight> I have the function curry whose type is "curry ((x,y) -> z) ->  x -> y -> z", and "curry id :: (a -> b -> (a,b))". How can I do the unification of those two so as to get the type of curry (curry id))? I am not getting it right
20:58:06 <Axman6> BMeph: what sort of symbols?
20:58:46 <jorizma> K programs look like ascii puke.
20:59:00 * Axman6 has got to get going
20:59:38 <BMeph> Axman6: It uses ASCII. I guess he figured "the world wwasnt ready for APL art". ;)
20:59:48 <hotaru2k3> things like "x@>#:'x" and "{&/x!/:2_!x}"
21:00:32 <cooldude127> tsLight: not sure what you mean
21:01:03 <BMeph> I love "2_" (which is K for "drop 2"), but I haven't seen yet how far down the rabbit hole goes. :)
21:01:05 <tsLight> cooldude127, I want to get the type of curry (curry id), manually (i.e. doing it myself, not in hugs :P)
21:01:41 <cooldude127> tsLight: does curry (curry id) even make sense?
21:01:53 <tsLight> cooldude127, it does according to Hugs :)
21:01:54 <cooldude127> apparently it does
21:02:21 <BMeph> tsLight: Right, "curry id" doesn't have a way to "fit" as an argument to curry. :)
21:02:21 <cooldude127> alright let's break it down. curry id :: (a,b) -> a -> b
21:02:53 <tsLight> no
21:02:58 <BMeph> :t curry id
21:02:59 <tsLight> a -> b -> (a,b)
21:02:59 <lambdabot> forall a b. a -> b -> (a, b)
21:02:59 <tsLight> :P
21:03:13 <BMeph> Yeah, I thought it was the other way around. :)
21:03:28 <BMeph> :t curry (curry id)
21:03:29 <lambdabot> forall a b b1. a -> b -> b1 -> ((a, b), b1)
21:03:50 <cooldude127> tsLight: and curry :: ((c,d) -> e) -> c -> d -> e
21:04:09 <dolio> I was pointed at a language way back that appeared significantly worse. It actually used all sorts of letters for functions, whereas J and such tend to stick with symbols.
21:04:15 <BMeph> tsLight: Okay, there you go - a :: (c,d) works. :\
21:04:25 <cooldude127> nvm, i can't make sense
21:04:33 <tsLight> lol
21:04:35 <dolio> So stuff like "asJMsl:N8Lm#@mdk&*alm" might actually be code.
21:04:51 <cooldude127> this is why :t exists lol
21:05:08 <tsLight> haha
21:05:23 <tsLight> "((c,d) -> e) -> c -> d -> e" and "(c,d) -> e -> c -> d -> e" are exactly the same right?
21:05:34 <cooldude127> no
21:05:44 <cooldude127> -> is right associative, not left
21:05:49 <BMeph> dolio: It may, but you're missing a lot of operators, so it won't do anything interesting. "NEED MOAR CYMBALS PLZKTHXBAI!" ;p
21:06:01 <tsLight> ah you are right
21:06:26 <dolio> BMeph: No, I mean in the language I'm talking about, each one of those letters denotes a different function, in addition to all the non-alphanumeric symbols.
21:06:27 <tsLight> then why does a :: (c,d) work
21:06:37 <tsLight> shouldnt it be a :: (c,d) -> e ?
21:06:45 <cooldude127> idk, i'm so lost
21:07:29 <tsLight> :P
21:07:58 <BMeph> Let's work it out: "curry id :: a -> b -> (a,b)", and "a :: (c,d)", so "curry (curry id) :: (c -> d -> b -> ((c, d), b)"
21:08:32 <tsLight> why a :: (c,d)?
21:09:10 <tsLight> I mean, only looking at curry id's type and curry's type
21:09:13 <BMeph> dolio: Oh, right. So what language are you talking about? Is it one you've made up, or did someone else do it? :)
21:09:54 <BMeph> tsLight: Why not? It's better than (a1, b1), IMWHO. :)
21:10:09 <dolio> BMeph: It's a language I remember seeing linked on reddit way back. I'm trying to find it now.
21:10:23 <BMeph> tsLight: (Where the "W" means "worthless," natch. ;)
21:10:37 <tsLight> but I dont understand how you got a :: (c,d)
21:10:40 <tsLight> hwo did you figure that out?
21:11:44 <BMeph> tsLight: Because curry needs a function that takes a pair. "curry id"'s first argument is 'a', therefore 'a' must be a pair. :)
21:12:14 <tsLight> ah
21:12:14 <tsLight> :P
21:12:33 <cooldude127> that's what i was trying to show, but i couldn't figure it out
21:13:24 <tsLight> but why cant a :: (c,d) -> e ?
21:14:04 <BMeph> cooldude127: Don't worry, just re-read all of the logs where ddarius Cale dolio or conal talk. Type understanding will seep into your brain by osmosis! ;)
21:14:27 <Elly> don't forget dons
21:14:35 <cooldude127> i'm hoping it will eventually. i'm pushing through haskell, just hoping that it will eventually click like lisp did
21:15:21 <BMeph> Elly: I would, but dons tends to explain other programming issues, and leave the type stuff to those four. At least, that's how I read it. :)
21:16:56 <BMeph> tsLight: So tell us, why do you want "a :: (c,d) -> e"? What problem does making 'a' a function type solve? :)
21:17:56 <tsLight> that curry :: ((c,d) -> e) -> c -> d -> , the (c,d) -> e is parenthesized
21:18:48 <orbitz> because it takes a function
21:19:03 <cooldude127> so match (c,d) -> e with the signature of curry id
21:19:57 <tsLight> I dont get how a can match (c,d) only and not (c,d) -> e
21:20:31 <tsLight> if curry id were  (a -> b) -> (a,b) then I'd be ok with it :P
21:21:27 <BMeph> tsLight: Here's a helping hint: Function types are right-associative, so "curry id :: a -> b -> (a,b)" actually means "a -> (b -> (a, b))"
21:23:26 <BMeph> tsLight: So, if it's getting put into curry ("((x, y) -> z) -> x -> y -> z"), then 'a' matches '(x, y)' and 'b -> (a, b)' matches 'z'.
21:24:40 <tsLight> damn, I still dont get it
21:24:48 <tsLight> curry id :: a -> (b -> (a,b))
21:24:58 <tsLight> then we put it with ((x, y) -> z) -> x -> y -> z
21:25:18 <tsLight> the parenthesis around (x, y) -> z is what confuses me
21:25:27 <cooldude127> a -> (b -> (a,b)) ==> ((x,y) -> z)
21:25:44 <BMeph> tsLight: It's the type of the function that curry expects.
21:25:46 <cooldude127> a :: (x,y), b -> (a,b) :: z
21:25:50 <QtPlaty[HireMe]> tsLight: it means that it takes a funtion as an areument
21:26:19 <tsLight> yes I know that, but I cant see why it matches the 'a' only
21:27:37 <Cale> What are you trying to figure out? The typing for curry id?
21:27:56 <BMeph> tsLight: The parens tell you how to match up the functions. 'curry id' has to match up with the parened part of curry:
21:28:10 <leimy_> ByteString can be packed with non "Stringy" bytes?
21:28:38 <BMeph> a -> (b -> (a, b)) <==> (x, y) -> z
21:28:41 <tsLight> ahhhhhhhh
21:28:42 <Berengal> (a, b) -> c (first arg of curry) == a' -> a' (id, first arg of curry) => c == (a, b)
21:28:44 <tsLight> thats right!
21:28:57 <tsLight> the whole function should match against the parenthesis!
21:29:29 * BMeph cyber-high-fives tsLight -- good show!
21:29:38 <tsLight> lol
21:30:11 <Cale> curry :: ((a,b) -> c) -> a -> b -> c;  id :: d -> d, so in order to match, (a,b) -> c = d -> d, which means that (a,b) = d and c = d, and so the result of type a -> b -> c is the same as a -> b -> (a,b)
21:30:15 <hydo> I think I'm missing something key here.  I've started doing what I -think- is the accepted best practice:  I use as little code handling IO as possible and use pure functions as much as I can.  The problem is that I've started having to chain calls to liftM.  I can't imagine that there isn't a shortcut to this.
21:30:42 <hydo> Hrm.. maybe I should post the code I'm working on.
21:31:02 <Gracenotes> :t const id
21:31:03 <lambdabot> forall a b. b -> a -> a
21:31:09 <Cale> hydo: What do you mean by "chain calls to liftM"?
21:31:12 <BMeph> hydo: 1) hpaste code, please. 2) ... "ur doin it rong"? ;)
21:31:13 <mauke> :t flip const
21:31:15 <lambdabot> forall a b. b -> a -> a
21:31:26 <Cale> hydo: You know that liftM f . liftM g = liftM (f . g), right?
21:31:27 <Berengal> @paste
21:31:28 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:31:31 <Gracenotes> omg, it's like they're the same type !1!1
21:31:51 <BMeph> Gracenotes: !!!1!!one!1 ;p
21:31:52 <hydo> Cale: ooooo...
21:32:24 <BMeph> Cale: The "f . g" you talkin' about?!? ;p
21:33:02 <hydo> Cale: omigawd... thanks!  No I didn't know you could do that.  I think I should spend more time thinking about the implications of currying. (that's what makes that possible, right?)
21:33:17 <Berengal> > let a . b = fmap a b in unlines . map (toUpper.) . words . ["hello world how are you?"]
21:33:19 <lambdabot>   ["HELLO\nWORLD\nHOW\nARE\nYOU?\n"]
21:33:34 <Berengal> Now replace the list with an IO
21:33:44 <Gracenotes> fmap laws
21:34:00 <mauke> Berengal: (f . g) . x == f . (g . x)
21:34:18 * BMeph closes the bedroom door before the "fmaps" get too loud...
21:34:26 <Cale> hydo: currying? I suppose liftM is partially applied there :)
21:34:53 <Gracenotes> hydo: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t%3AFunctor
21:35:02 <hydo> Cale: then... in a way... sorta... I'm right?  hehe wheee!  I don't get to say that very often since I started learning haskell full time.
21:35:03 <Cale> hydo: But you can write the same law as:  liftM f (liftM g x) = liftM (f . g) x
21:35:09 <Cale> or...
21:35:20 <Cale> liftM f (liftM g x) = liftM (\u -> f (g u)) x
21:35:27 <Gracenotes> @type liftM
21:35:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:35:30 <Gracenotes> @type fmap
21:35:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:35:41 <Cale> Right, I usually just use fmap :)
21:35:58 <hydo> I think my next step is to learn about functors... they're still really hazy in my head.
21:36:16 <Berengal> Functors are like cars
21:36:30 <Cale> Berengal: haha
21:36:34 <pumpkin> I remember seeing that monads only gave you "free" functors in Hask (or at least not in all categories)
21:36:42 <NEEDMOAR> Berengal: so, functors are like monads?
21:36:46 <pumpkin> what's an example of one which doesn't?
21:36:57 <Berengal> Monads are like functors, more like
21:37:04 <mauke> @quote uns..ack
21:37:04 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
21:37:14 <cooldude127> is there a haskell function to take a list and give every pair of items (almost like the cartesian product of that list and itself)
21:37:17 <Berengal> (That's at least partially correct)
21:37:19 <Gracenotes> pumpkin: I thought a functor was a requirement for monadship
21:37:21 <Cale> NEEDMOAR: All monads are functors, but not the other way around.
21:37:29 <mauke> cooldude127: join (liftM2 (,))
21:37:44 <pumpkin> Gracenotes: it is, but I remember someone saying that the functor -> applicative -> monad didn't hold in all categories
21:37:49 <Gracenotes> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Categorical.html
21:37:49 <Berengal> \list -> zip list (tail list)
21:38:23 <Cale> Or if you don't want to import Control.Monad.Instances, you can go with  liftM2 (,) xs xs
21:38:56 <Cale> cooldude127: Or a list comprehension:  [(x,y) | x <- xs, y <- xs]
21:39:15 <cooldude127> i think the list comprehension is what i want
21:39:22 <NEEDMOAR> Cale: sure!
21:39:25 <Gracenotes> pumpkin: all monads are applicatives... all monads are functors... not all functors are monads... not all applicatives are monads... all applicatives are functors...
21:39:27 <mauke> :-(
21:39:27 <cooldude127> cuz then i can also stipulate that x /= y
21:39:34 <pumpkin> Gracenotes: I know that :P
21:39:35 <Gracenotes> *chanting*
21:39:44 <NEEDMOAR> Berengal always says that things are like cars!
21:39:45 <pumpkin> except I believe the applicative step may be specific to hask
21:39:51 <pumpkin> or so someone said once
21:39:57 <Berengal> NEEDMOAR: Everything in CS is
21:40:03 <Gracenotes> We shall chant our categorial dogma!
21:40:08 <hydo> Ok, here's another question... given the type http://tinyurl.com/c7bt8x , and I take a Value as a parameter knowing that there's a 99% chance that it's an Object, there has to be an easier way than saying case x of -> Object y -> y _ -> Null -- or is that the imperative programmer in me?
21:40:11 <mauke> > filter (uncurry (/=)) . join (liftM2 (,))  $ [1,2,3]
21:40:12 <lambdabot>   [(1,2),(1,3),(2,1),(2,3),(3,1),(3,2)]
21:40:42 <hydo> disregard... that was kindof a dumb question due to the type system.
21:40:48 <NEEDMOAR> Berengal: haha. Even co-stuff?
21:41:04 <Berengal> NEEDMOAR: They're like motorbikes, which are like cars
21:41:16 <NEEDMOAR> ;-)
21:41:53 * BMeph raises his fist at the unfairness of the world: This is the Future, dammit, where's my flying burrito-car?
21:42:25 <Cale> hydo: Well, there are things you could do... like write: obj (Object x) = Just x; obj _ = Nothing, and then use the Maybe monad.
21:42:27 <Gracenotes> @type \f a -> join (fmap (\g -> join (fmap (\b -> return (g b)) a)) f)
21:42:29 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => m (a -> a1) -> m a -> m a1
21:42:51 <Gracenotes> I am not certain why that would apply only to Hask... x.x
21:43:06 <Cale> hydo: (Might be a useful tactic if you expect a particular structure and want the thing to just fail if it doesn't match)
21:43:48 <Gracenotes> @pl \f a -> join (fmap (\g -> join (fmap (\b -> return (g b)) a)) f)
21:43:48 <lambdabot> (join .) . flip (fmap . (join .) . flip (fmap . (return .)))
21:44:13 <Cale> hydo: Actually, probably even more convenient to combine in the Map lookup.
21:45:02 <copumpkin> Gracenotes: oh, the functor bit was me being wrong :P
21:45:06 <copumpkin> a monad clearly requires a functor
21:45:15 <copumpkin> by definition :P
21:45:23 <copumpkin> but how about applicative?
21:45:25 <Gracenotes> no ur definishun lolz
21:45:50 <Gracenotes> well, given join and fmap you can construct ap
21:45:53 <Cale> hydo: Something like  objVal k (Object x) = Map.lookup k x; objVal k _ = Nothing
21:46:06 <copumpkin> Gracenotes: ap is in Monad :P
21:46:16 <copumpkin> well, not a method
21:46:25 <copumpkin> but it expects a monad
21:46:48 <Cale> If you have join, fmap and return, you have a monad.
21:46:51 <copumpkin> yeah
21:46:56 <Gracenotes> eh. I don't to think of it as /requiring/ as much as 'every X is a Y'. Every monad is an applicative. Not every applicative is a monad.
21:47:09 <Cale> hydo: Does that help?
21:47:15 <Cale> hydo: Then you can write things like...
21:47:32 <BMeph> Just remember: s/applicative/applicative*Functor*/ ;)
21:47:32 <copumpkin> Gracenotes: I know that every monad is an applicative in haskell :P
21:47:52 <Cale> do v <- objVal "foo" myObject; w <- objVal "bar" v; return w
21:48:00 <Gracenotes> BMeph: now now, we have no room for your pedantry in this channel!
21:48:11 <Cale> hydo: Which is just a convenient replacement for nested cases.
21:48:22 <copumpkin> the question is, does Monad m imply Applicative m in all categories, or just in hask?
21:48:30 <copumpkin> I honestly don't know :P
21:48:38 <copumpkin> I remember someone saying it didn't
21:48:40 <BMeph> Gracenotes: Pedantry is like Jell-O. There's always room, and it's fun to make it wiggle! ;p
21:49:12 <Gracenotes> copumpkin: confront them mightily!
21:49:14 <Cale> hydo: (if anything gives Nothing, the overall result is Nothing, if they all give Just, then the result is Just <something>)
21:49:33 <copumpkin> Gracenotes: I don't have the knowledge to confront them mightily! I don't even know what an applicative means in CT
21:49:39 <copumpkin> :P
21:50:01 <Gracenotes> according to the paper they are lax monoidal functors
21:50:20 <copumpkin> yeah, saw that :P I still don't know what it is
21:50:41 <Gracenotes> @type let pair = liftA2 (,) in \a b -> uncurry id <$> pair a b
21:50:42 <lambdabot> forall b c (f :: * -> *). (Applicative f) => f (b -> c) -> f b -> f c
21:52:03 <Gracenotes> I'm not sure if there is a monad that isn't one... :o
21:52:27 <copumpkin> hmm?
21:52:45 <copumpkin> all monads are applicatives in haskell
21:53:01 <_dls_> hey guys, can anyone help me with a type error? three lines: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2205#a2205
21:53:31 <Cale> _dls: sure
21:53:44 <Cale> _dls: (allCombos rst) would have to be a list of lists, right?
21:53:51 <_dls> yep
21:54:03 <Gracenotes> copumpkin: dunno what would make other categories different. :(
21:54:34 <Gracenotes> in terms of what can be defined in terms of what...? might be mistakeded.
21:54:39 <Cale> _dls: and it's the tail of a list of lists which is an element of this list comprehension
21:54:56 <Cale> _dls: So allCombos appears to be giving a list of lists of lists
21:55:18 <Cale> _dls: What you really want to do is to pick one particular combination, in all possible ways, to be the tail.
21:55:49 <Gracenotes> copumpkin: http://en.wikipedia.org/wiki/Monoidal_monad
21:55:51 <_dls> Cale: I'm not sure I follow the bit about "tail of a list of lists"... expected input is [[1,2],[3,4],[5,6]] w/ output of [[1,3,5],[1,3,6],[1,4,5]...]
21:56:35 <Cale> _dls: right. But... x : xs always has the same type as xs, right?
21:57:03 <_dls> Cale: x should be [a] w/ xs an [[a]] I think
21:57:08 <Gracenotes> copumpkin: not that it requires join
21:57:11 <Gracenotes> *note
21:57:11 <Cale> _dls: right.
21:57:25 <mauke> but you are inside another []
21:57:26 <_dls> Cale: ahh, misread. yes
21:57:27 <Cale> _dls: and what type is x here?
21:57:55 <Cale> xs:rst :: [[a]]
21:57:56 <Cale> so
21:58:00 <Cale> xs :: [a]
21:58:06 <Cale> and x <- xs, so x :: a
21:58:11 <Gracenotes> copumpkin: because Wikipedia is always right! *cough*cloak*
21:58:18 <Cale> but allCombos rst :: [[a]]
21:58:30 <Cale> and so in order for this to typecheck, we need x :: [a]
21:58:37 <_dls> Cale: thanks.
21:58:38 <copumpkin> Gracenotes: not sure I follow... it's talking about a monad, so it has the join NT
21:58:41 <_dls> you nailed it
21:58:44 <Cale> but if x :: a and x :: [a], that means that a = [a]
21:58:56 <Cale> (which isn't allowed)
21:59:16 <_dls> Cale: perfect. not sure what blinded me, but you fix it :)
21:59:19 <Cale> So what you really want to do is not to attach x as the first element to the list of all combinations of rst
21:59:32 <mauke> (I see it as typeof (allCombos _) = typeof [allCombos _])
22:00:03 <Gracenotes> copumpkin: it requires both lax monoidal functor (applicative functor) and join
22:00:05 <Cale> You want to attach your selected x to each of the combinations
22:00:19 <copumpkin> Gracenotes: ...and?
22:00:43 <Cale> allCombos (xs:rst) = [ x:ys | x <- xs, ys <- allCombos rst]
22:00:44 <copumpkin> Gracenotes: nothing in there implies that a monad always gives you a free lax monoidal functor
22:00:45 <Gracenotes> hmmmmmm. Well I suppose it's explicit in that case
22:00:49 <Gracenotes> yeah
22:01:09 <_dls> Cale: woah. I'd switched it to a mapping. thanks for pointing that version out
22:02:25 <Gracenotes> copumpkin: it's possible that the person was talking about how Hask is limited because of the prevalence of _|_s? ;_; otherwise, dunno, you musts ask them.
22:03:11 <dolio> edwardk says it doesn't work in all categories because not all categories have exponential objects.
22:03:17 <hydo> Cale: Yes, that definitely helps.  Thank you!  and re: the liftM chaining, I was thinking "duuh, why didn't I think of that?" when I was off getting coffee.  I'm hoping that if I keep at it these things will become obvious.  There seems to be a lot to keep in mind in order to do anything useful.  At least a lot more than other languages.
22:03:21 <dolio> So the type of (<*>) doesn't make sense in all categories.
22:03:48 <Gracenotes> dolio: what about all categories with monads..?
22:04:06 <dolio> But strong lax monoidal functors aren't defined in terms of exponential objects, so that doesn't tell you the answer to that version of the question.
22:04:25 <Gracenotes> awww.
22:04:48 <dolio> No, monads don't require there to be exponential objects.
22:06:14 <copumpkin> hask is special in that its monads imply lax monoidal functors?
22:06:22 <Cale> hydo: No problem :)
22:07:36 <Cale> hydo: Regarding the large amount of stuff to keep in mind, it's probably just the fact that it's a different sort of language, so there's a lot to get used to. Once that stuff gets natural, you don't have to constantly focus on it as much :)
22:08:36 <hydo> Cale: makes sense.  I can't wait until the first time I write a function of any size correctly the first time.  Then I'll be all *flex*
22:08:55 <mauke> write id!
22:11:31 <hydo> mauke: What is id for?  I looked it up on hoogle and it wasn't much help.
22:11:42 <mauke> @src id
22:11:42 <lambdabot> id x = x
22:11:51 <mauke> it's for doing nothing
22:12:12 <hydo> Well, ok then.
22:12:12 <Berengal> id is the simplest function possibly, yet you can do some fancy things with it
22:12:19 <Berengal> possible*
22:12:25 <Berengal> @type flip id
22:12:26 <lambdabot> forall b c. b -> (b -> c) -> c
22:13:00 <mauke> ask = id
22:13:42 <Berengal> @type (>>=id)
22:13:44 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
22:14:07 <Gracenotes> copumpkin: surely we need a CT help desk
22:14:13 <copumpkin> yeah :)
22:14:17 <copumpkin> #cthelpdesk
22:14:18 <copumpkin> :P
22:16:44 <Gracenotes> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
22:16:45 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) a b (f3 :: * -> *). (Functor f3, Functor f2, Functor f1, Functor f) => f (f1 (f2 (a -> b))) -> f (f1 (f2 (f3 a -> f3 b)))
22:18:01 <Berengal> Most of those fmaps turn into composition...
22:18:31 <Berengal> I think...
23:04:11 <xrfang> hello, what is the difference between f = \x y -> x + y, and f x y = x + y?
23:04:38 <johnw> f = \x y -> x + y is the same as f = (+)
23:04:54 <johnw> which is the point-free version of f x y = x + y
23:05:00 <Berengal> xrfang: Modulo the monomorphism restriction, they're the same
23:05:07 <johnw> also, use :type to inspect the types
23:05:43 <xrfang> what do you mean point-free version, johnw?
23:05:54 <johnw> a version that elides the arguments
23:05:54 <xrfang> the 2 version appears to be same, in effect,
23:06:02 <xrfang> but while I try :t on them
23:06:10 <johnw> all three are "f :: a-> a -> a"
23:06:20 <xrfang> it says Integer -> Integer -> Integer with the lambda version
23:06:20 <johnw> (effectively)
23:06:36 <xrfang> but (Num t) => t -> t -> t with the f x y version
23:06:53 <xrfang> this means the \x y version works with Integer only?? I feel not :S
23:07:00 <Berengal> xrfang: If you run ghci with -XNoMonomorphismRestriction, they should both be the same type
23:07:43 <xrfang> oh they are REALLY different!
23:07:52 <xrfang> strange, with the f x y, I can say f 2.5 3
23:08:03 <xrfang> but with the \x y edition I cannot use floating point
23:08:28 <xrfang> my question now is that while I define f = \x y -> x + y, where did I say that x y must be Integer ...
23:08:45 <xrfang> Berengal? :)
23:08:56 <Berengal> xrfang: You didn't, but it defaulted to it
23:09:05 <johnw> i think it depends on when the inference happens, xrfang
23:09:17 <Berengal> Because (+) is a function in the Num class
23:09:22 <johnw> with f x y, it can deduce the type of + (Num) from 2.5 + 3
23:09:39 <xrfang> ok, well... is this a GHCi restriction, or it applies to the ghc compiler too?
23:09:49 <Berengal> xrfang: It applies to the compiler as well
23:10:17 <Berengal> You can get around it by specifying the type to be specifically polymorphic, or turn off the monomorphism restriction
23:10:19 <xrfang> ok, for now, I will take it for granted that the \ (lambda) form of function definition is not necessary...?
23:10:50 <xrfang> I have not yet learned how to specify explicitly that the params can be poly or mono morphism
23:10:54 <Berengal> xrfang: No, it's not really. At least not functions that start with a lambda
23:11:18 <Berengal> xrfang: The monomorphism restriction is a wart. It's explained on the wiki...
23:11:36 <xrfang> alright, thanks
23:11:52 <Berengal> But basically, if you have a function "length" of type (Num b) => [a] -> b, it might have to call the function twice...
23:12:21 <Berengal> To avoid such hidden duplication of work, a restriction was put in place to make it explicit
23:12:45 <jmcarthur> it's a wart, but does exist to prevent something that could be perhaps _more_ confusing
23:14:22 <Berengal> I usually work with it off...
23:19:24 <cjs> So what is wrong with 'instance Metric [Char] where ...'? It gives me "Illegal instance declaration for `Metric [Char]'. (All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables*,..."
23:20:43 <Berengal> You can't specialize instances, I believe
23:20:55 <Berengal> You either have to make an instance of [a] or Char
23:22:50 <cjs> Which restriction goes away if you turn on FlexibleInstances, of course. I guess what I'm asking is, what's the reasoning behind that restriction?
23:23:35 <cjs> Especially given that, if I turn on TypeSynonymInstances but not FlexibleInstances, GHC is happy to accept "instance Metric String where...".
23:24:04 <altmattr> can anyone explain to me what tak.hs from the nofib suite does?
23:24:21 <altmattr> besides create lots of recursive calls :)
23:26:40 <jmcarthur> looks like that's really all it does. recursive calls with shuffled arguments
23:28:01 <altmattr> but what does the shuffling give us?  which dimension drives the explosion in size?
23:28:09 <altmattr> I think it could be a test of laziness
23:28:39 <jmcarthur> i suspect the shuffling is just to prevent a certain optimization
23:28:52 <altmattr> if you trace tak (0 1 0) I think it runs forever in a strict evaluation setting
23:28:58 <jmcarthur> having to do with accumulating parameters, perhaps
23:29:01 <altmattr> sorry (tak 0 1 0)
23:29:43 <dolio> tak 0 1 0 returns 0 immediately.
23:29:55 <jmcarthur> that theory doesn't seem to be in line with performance benchmarks
23:30:08 <jmcarthur> that sounds more like a correctness test
23:30:28 <dolio> tak 0 1 0 = if not (1 < 0) then 0 else ...
23:30:34 <altmattr> dolio: you are right, of course
23:30:39 <altmattr> I will look harder
23:30:46 <altmattr> got my nots knotted up :)
23:31:10 <dolio> Not sure why it uses not (y < x) instead of x <= y.
23:31:32 <jmcarthur> *instead of x >= y
23:31:42 <jmcarthur> oh, you switched the arguments
23:31:44 <jmcarthur> n/m
23:38:10 <dolio> Well, the first recursive call keeps decreasing x until it gets below y, then results in z.
23:39:19 <cjs> Ok, so I've got a channel over which I want to send arbitrary things of any type within a class: 'Metric a => Chan a'. Is Rank2Types the correct language extension to be doing this?
23:39:29 <dolio> So tak x y z = if x <= y then z else tak z (tak (y-1) z x) (tak (z-1) x y)...
23:40:24 <dolio> No.
23:40:46 <dolio> You need a Chan (exists a. Metric a => a)
23:41:13 <cjs> Would that be existential types, then?
23:41:25 <dolio> Which in GHC requires a wrapper. data MetricWrap = forall a. Metric a => MW a
23:41:35 <dolio> Yeah, the extension is ExistentialQuantification.
23:41:36 <cjs> That was sort of the feelnig I was getting...
23:41:47 <cjs> But the wrapper thing is annoying.
23:41:53 <dolio> Yeah.
23:45:22 <dolio> Of course, that sticking in of 'z' there assumes that y isn't the minimum possible integer. If it is, that branch never completes.
23:46:22 <dolio> > let tak :: Int -> Int -> Int -> Int ; tak x y z | x <= y = z | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y) in tak minBound minBound minBound
23:46:24 <lambdabot>   -9223372036854775808
23:47:02 <dolio> Oh, never mind. It's <=.
23:51:33 <dolio> I'm still probably wrong about sticking z there, though, now that I think about it.
23:52:06 <dolio> > let tak :: Int -> Int -> Int -> Int ; tak x y z | x <= y = z | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y) in tak 3 2 1
23:52:07 <lambdabot>   2
23:52:14 <cjs> This doesn't seem to be working for me. I think the problem is, that I want a single channel on which I can write any type that's a member of a given class. Is that possible?
23:52:20 <dolio> > let tak :: Int -> Int -> Int -> Int ; tak x y z | x <= y = z | otherwise = tak (tak (x-1) y z) (tak (y-1) z x) (tak (z-1) x y) in tak 4 2 1
23:52:22 <lambdabot>   2
23:52:24 <cjs> s/any type/a value of any type/
23:52:58 <dolio> Can you put some code on hpaste?
23:53:05 <dolio> To show what you've tried.
23:53:21 <cjs> That would be embarassing. :-) But yes, I can do so.
23:54:52 <cjs> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4114
23:55:17 <dolio> Oh, okay.
23:55:22 <dolio> You're wrapping the wrong thing.
23:55:43 <cjs> Oh.
23:55:55 <dolio> You've mad a Chan which transmits some particular type of Metric.
23:56:04 <cjs> Right. I figured out that much.
23:57:49 <dolio> So you want 'data SomeMetric = forall a. Metric a => SomeMetric a ; data MetricLog = NewLog (Chan SomeMetric) ; logMetric (NewLog mchan) x = writeChan (SomeMetric x)'
23:57:56 <dolio> I think that's right.
23:58:09 <bryan1> I'm running into a space leak and have put together a small app that can, very quicky, eat up all of you memory.  Does anyone have any thoughts on how fix this?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4115#a4115
23:58:59 <cjs> Ah, so I create a new data type that holds an arbitrary a where a is in the Metric class, and then the channel is parameterized by that data type.
23:59:28 <Elly> bryan1:
23:59:28 <dolio> Right. You send wrapped things. Wrapping them on the send end, and unwrapping them on the receive end.
23:59:29 <Elly>                ["modify"] -> doLoopWriteIORef  bloatRef
23:59:33 <Elly> ^ is that intentional? :P
23:59:39 <cjs> Ok, that makes perfect sense to me.
23:59:44 <cjs> Thanks, dolio!
