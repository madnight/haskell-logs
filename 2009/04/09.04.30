00:00:14 <mmorrow> *..behavior s/of/or/ all-at-once ..
00:00:16 <sjanssen> cjs: the guard/seq trick predates bang patterns
00:00:22 <sjanssen> cjs: and there should be no difference
00:00:35 <cjs> sjanssen: Right, so it's just to avoid enabling the language extension, then.
00:01:06 <Baughn> Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance.
00:01:32 <haskellnoob> mmorrow: I basically don't care about streaming vs. all-at-once, so long as it is fast. what then?
00:01:49 <mmorrow> haskellnoob: benchmark it and see :)
00:02:20 <Baughn> haskellnoob: Listen to the wise words of alexander graham bell.
00:03:09 <haskellnoob> What hath God wrought?
00:03:29 <mmorrow> i am become death, the destroyer of worlds?
00:03:35 <tiglionabbit> whoops, I messed that up.  Hm, I wanted to make a function that could reverse all the arguments of another function, but this seems difficult because 1: I don't know how many arguments that function takes, and 2: I'm not sure how to flip a third argument without feeding it one first
00:03:58 <Baughn> haskellnoob: "Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance."
00:04:07 <Baughn> - Baughn
00:04:29 <mmorrow> Baughn: <Baughn> - Baughn
00:04:44 <Baughn> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:04:45 <Cale> tiglionabbit: What will the type of your function be?
00:04:54 <Stinger> wasn't that jefferson?
00:05:06 <Baughn> Stinger: No, I'm pretty sure he never talked about laziness
00:05:10 <Stinger> haha
00:05:30 <tiglionabbit> Cale: are you hinting that I could not accept functions with an arbitrary number of arguments?
00:05:35 <haskellnoob> Hmm... Other than switching to lazy and checking if that works, is there something else that is obvious in the code that makes it slow?
00:05:41 <Stinger> ah Franklin
00:05:43 <Cale> tiglionabbit: not easily :)
00:05:45 <tiglionabbit> and expect to use all of them
00:05:47 <tiglionabbit> hm
00:05:54 <Cale> tiglionabbit: You could use a typeclass.
00:06:01 <Baughn> tiglionabbit: You could possibly figure something out with type-classes, but it'd be Fugly
00:06:06 <Cale> right
00:06:07 <hotaru2k3> @ty (flip .) . flip . (flip .)
00:06:08 <lambdabot> forall a b c a1. (a1 -> a -> b -> c) -> b -> a -> a1 -> c
00:06:36 <tiglionabbit> heh, I guess it wasn't designed to do this sort of thing.  I'd have to make a separate function for each number of arguments you'd want to flip
00:06:50 <mmorrow> acovea looks neat
00:07:01 <haskellnoob> for example, would it help if i got rid of the functions and wrote it all inside main?
00:07:02 * mmorrow has begun flipping through this gcc book
00:07:24 <haskellnoob> the code is here:  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2283#a2283
00:08:03 <Cale> haskellnoob: No, that wouldn't help.
00:08:21 <Cale> The compiler inlines things anyway.
00:09:11 <haskellnoob> ok.. and it would look mighty ugly, and take many tries (for me) to get all the indentation right as well!
00:11:07 <mmorrow> Baughn: <Baughn> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:12:54 <mmorrow> haskellnoob: try s/Integer/Int/ if there isn't the possibility of overflow
00:13:20 <mmorrow> Int is much faster when it's applicable
00:14:41 <mmorrow> haskellnoob: whoa, and get rid of the B.unpack
00:15:09 <mmorrow> that'll kill performance
00:15:20 <haskellnoob> mmorrow: Unfortunately there is: the number k and the total number of numbers can be as large as 10^7, and the remaining numbers can be as large as 10^9
00:15:49 <haskellnoob> let me check how large an Int can be, though!
00:15:55 <Baughn> mmorrow: < mmorrow> Baughn: <Baughn> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:16:21 <mmorrow> haskellnoob: the B.unpack is probably a large factor too
00:16:22 <Cale> > maxBound :: Int
00:16:24 <lambdabot>   9223372036854775807
00:16:32 <Cale> > maxBound :: Int32
00:16:33 <lambdabot>   2147483647
00:16:36 <cjs> Possibly the read, as well.
00:16:53 <Baughn> haskellnoob: You can ask for a 64-bit number explicitly, using Data.Int.Int64
00:17:00 <mmorrow> haskellnoob: yeah, if you ditch the unpack, you'll have to find an alternative to read as well
00:17:02 <Baughn> haskellnoob: Even on a 32-bit platform, that will be faster than Integer
00:17:12 <haskellnoob> but read expects a String as input, so how do I make that work?
00:17:21 <cjs> Well, what you want to do in that situation is write a little parser that operates on ByteStrings and just parses out what you need directly.
00:17:24 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy-Char8.html#v%3AreadInt
00:17:30 <ski> Baughn : <mmorrow> Baughn: < Baughn> Baughn: <loeb> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:17:44 <cjs> You wanted to learn how to write a monadic parser anyway, right? :-)
00:18:00 <Baughn> cjs:  ski> Baughn : <mmorrow> Baughn: < Baughn> Baughn: <loeb> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:18:02 <Cale> The ByteString library already includes custom Int and Integer parsers
00:18:08 <mmorrow> preflex: tell lambdabot <Baughn> cjs:  ski> Baughn : <mmorrow> Baughn: < Baughn> Baughn: <loeb> mmorrow:  < mmorrow> Baughn: <Baughn> - Baughn
00:18:08 <preflex>  Consider it noted.
00:18:16 <haskellnoob> cjs: me? no!
00:18:23 <mmorrow> oh, that'll never get displayed..
00:18:34 <cjs> But for your purposes, actually, you could probably just write a simple function to do the trick. Or just use the one that Cale pointed out.
00:18:34 <ski> @remember Baughn Those who would give up essential laziness for a little ephemeral performance, deserve neither laziness nor performance.
00:18:35 <lambdabot> It is forever etched in my memory.
00:18:35 <preflex>  lambdabot: you have 1 new message. '/msg preflex messages' to read it.
00:18:47 <ski> @msg preflex messages
00:18:47 <lambdabot> Not enough privileges
00:19:14 <haskellnoob> cjs: ok
00:19:24 <cjs> ski: Was that originally Baughn? I seem to recall dons or somebody mentioning that late last year....
00:19:25 * mmorrow just noticed that loeb snuck in there
00:19:44 <Baughn> cjs: Independent invention.
00:19:51 <ski> cjs : i don't know .. i was assuming Baughn made it up
00:19:57 <cjs> Ah. Well, your phrasing is slightly better.
00:20:06 <haskellnoob> would Int32 be even faster than Int ?
00:20:15 <cjs> No.
00:20:24 <Baughn> More predictable, though
00:20:28 <Ralith> haskellnoob: premature optimization: don't do it.
00:20:29 <ski> Baughn : "ephemeral" there is referring to "ephemeral" vs. "persistent" data structures, right ?
00:20:41 <cjs> Unless you're doing something tricky, such as storing packed arrays of them, and you happen to be on a 64-bit machine.
00:20:50 <Baughn> ski: Hmm. Yes, sure, that fits.
00:20:57 <cjs> (Large packed arrays, I mean, such that memory bandwidth becomes an issue.)
00:21:01 <mmorrow> haskellnoob: Int is always the size of a machine int
00:21:20 <mmorrow> well.. not according to the haskell standard
00:21:26 <mmorrow> but according to ghc
00:21:57 <olsner> isn't it >= 31 bits or something like that according to the report?
00:22:13 <mmorrow> i think so
00:22:38 <Baughn> Yep. Leaves room for a tag bit, even if we don't actually need one of those
00:23:27 <haskellnoob> thanks to all.. let me try these things and see.
00:24:36 <ski> > logBase 2 (fromInteger . succ . toInteger $ (maxBound :: Int))
00:24:37 <lambdabot>   63.0
00:25:15 <ski> olsner : istr 29 or 30
00:27:20 <olsner> ski: yeah, actually I meant to add "for some value of 31"
00:29:07 <MyCatVerbs> ski: Int is at least 30 bits wide signed. -2^29 to (2^29)-1, is how the Report phrases it. I don't think overflow behavoir is actually specified at all.
00:30:31 <ski> (yes, that's where the `29' came from .. i was wondering if `29' was with or without sign bit)
00:30:32 <Botje> > succ maxBound :: Int32
00:30:33 <lambdabot>   * Exception: Enum.succ{Int32}: tried to take `succ' of maxBound
00:31:23 <ski> (MyCatVerbs : hence i converted to `Integer' before adding one)
00:32:43 <MyCatVerbs> ski: sensible enough. Just thought, since I actually managed to remember something for a change, I might as well chip in and share it. :)
00:32:51 <haskellnoob> How do I read in a line of input using Data.ByteString.Lazy.Char8 ? There is a function that reads in the whole stdin, but not one that reads in just the first line.
00:33:24 <quicksilver> hGetLine
00:33:58 <quicksilver> hmm.
00:33:59 <Cale> Is hGetLine really missing?...
00:34:01 <quicksilver> no hGetLine in the lazy one
00:34:03 <quicksilver> that's odd.
00:34:07 <haskellnoob> quicksilver: doesn't seem to be there http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy-Char8.html#26
00:34:32 <quicksilver> I agree.
00:34:46 <quicksilver> Maybe they take the attitude that if you're getting line by line you should be using strict bytestrings.
00:35:38 <haskellnoob> I want to read in the first line, get a number out of it. then i want to process the rest of the input using some other logic, which uses the number i read from the first line. now if I read in the full stdin using getContents, will there be anything left for interact to work with?
00:35:41 <Trinithis> I just built ghc6.10.2 and when I use ghci, backspace and arrowkeys do not function properly. Anyone know what I can do to fix this?
00:35:54 <ski> what if the lines are really long ?
00:36:09 <ski> (or at least a few lines might be really long)
00:36:24 <haskellnoob> in this case i know that the lines are really short, but there are a lot of them. each line consists of a number that is at most 10^9
00:36:44 <Cale> haskellnoob: however, you are just applying lines to the rest of the input anyway
00:37:14 <haskellnoob> Cale: i am afraid the significance of that observation has escaped me!
00:37:14 <MyCatVerbs> Trinithis: you need libeditline and/or libreadline when you build GHC.
00:37:27 <Trinithis> ok
00:37:35 <haskellnoob> i don't know what that implies :)
00:37:56 <Cale> haskellnoob: So in this case, despite it being annoying that hGetLine is missing, you can just pattern match the list of lines and handle the x and xs from (x:xs) separately
00:38:00 <ski> haskellnoob : if you use `getContents', then that will suck all the characters out of standard input (but lazily). you can't then read from stardard input using `interact',`getLine',... anymore
00:38:43 <MyCatVerbs> Trinithis: there are some pesky licensing issues, so GHCi isn't built with readline by default. You'll have to poke the configure script to build in either readline or editline.
00:39:11 <MyCatVerbs> At least I think the option was the configure script, anyway. My memory sucks and it's been a while.
00:40:03 <tiglionabbit> okay, out of the depths of my silliness, I give you reverse3 f = flip (flip . (flip f)).  instead of reverse3 f x y z = f z y x like any sane person would write.  It was neat noticing that composing flip instead of applying it would flip the last arguments instead of the first ones
00:40:03 <Trinithis> mm
00:40:21 <haskellnoob> Cale: if i get it correctly, what you are saying is: use getContent and then lines to get a list of all the input lines. do the special processing for the first line by matching it against x in (x:xs), and then pass xs on to the remaining logic. did i get this right?
00:40:54 <Cale> main = do (x:xs) <- fmap B.lines B.getContents; ...
00:41:04 <Cale> yeah
00:41:09 <haskellnoob> thank you
00:41:15 <ski> @pl reverse3 f x y z = f z y x
00:41:15 <lambdabot> reverse3 = flip . (flip .) . flip
00:41:31 <tiglionabbit> @pl?
00:41:31 <lambdabot> (line 1, column 1):
00:41:31 <lambdabot> unexpected end of input
00:41:31 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:41:41 <ski> @help pl
00:41:42 <lambdabot> pointless <expr>. Play with pointfree code.
00:42:11 <Trinithis> ill try using both the --with-editline-libraries and --with-editline-includes options
00:42:19 <tiglionabbit> :D pointless.  So is that already in there, or did it generate that?
00:42:28 <ski> it generated it
00:42:32 <tiglionabbit> wow
00:43:06 <tiglionabbit> how does that program work
00:43:21 <MyCatVerbs> tiglionabbit: eeeevil.
00:43:58 <tiglionabbit> you mean awesome
00:44:40 <MyCatVerbs> tiglionabbit: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
00:44:43 <tiglionabbit> so many compositions in that -- I wouldn't have thought of it
00:45:10 <Cale> @pl reverse4 f x y z w = f w z y x
00:45:10 <lambdabot> reverse4 = flip . ((flip . (flip .)) .) . flip . (flip .) . flip
00:45:26 <tiglionabbit> hooray
00:45:38 <ski> flip (flip . (flip f))  =  flip ((flip .) (flip f))  =  (flip . (flip .) . flip) f
00:45:39 <tiglionabbit> what other tricks does it know
00:45:42 <Trinithis> i wonder if the pl is exponential in size
00:45:48 <Trinithis> for reerseN
00:46:25 <ski> @pl foo f x y = f x y x
00:46:25 <lambdabot> foo = (flip =<<)
00:46:32 <tiglionabbit> reverse = f a b c d e f g h i j k l m n o p = f p o n m l k j i h g f e d c b a
00:46:36 <tiglionabbit> oops
00:46:39 <Trinithis> @pl \ func a b c d e -> func e d c b a
00:46:40 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
00:46:48 <Trinithis> @pl \ func a b c d e f -> func f e d c b a
00:46:50 <lambdabot> flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
00:46:53 <tiglionabbit> @pl reverse = f a b c d e f g h i j k l m n o p = f p o n m l k j i h g f e d c b a
00:46:53 <lambdabot> (line 1, column 45):
00:46:53 <lambdabot> unexpected "="
00:46:53 <lambdabot> expecting variable, "(", operator or end of input
00:47:01 <Trinithis> @pl \ func a b c d e f g -> func g f e d c b a
00:47:02 <tiglionabbit> I failed it
00:47:04 <lambdabot> flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)
00:47:04 <lambdabot>  . flip . (flip .) . flip
00:47:06 <Deewiant> ?pl reverse10 foo a b c d e f g h i j = foo j i h g f e d c b a
00:47:07 <MyCatVerbs> Trinithis: short answer, yes.
00:47:09 <lambdabot> reverse10 = flip . ((flip . (flip .) . ((flip .) .)) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .)
00:47:09 <lambdabot> .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip . (flip .) .
00:47:09 <lambdabot>  ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((
00:47:09 <lambdabot> flip .) .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . flip . (flip .) . ((flip .) .) . flip . (flip .) .
00:47:09 <quicksilver> looks quadratic in size to me.
00:47:12 <lambdabot>  flip
00:47:13 <quicksilver> looks quadratic in size to me.
00:47:14 <Deewiant> Very.
00:47:14 <lambdabot> optimization suspended, use @pl-resume to continue.
00:47:17 <Trinithis> hah
00:47:19 <quicksilver> quadratic != exponential.
00:47:22 <MyCatVerbs> Trinithis: long answer, yeeeeeeeeeeeeeeeee... maybe.
00:47:44 <mmorrow> @pl \a b c d -> g (f a b c d)
00:47:45 <lambdabot> (((g .) .) .) . f
00:47:48 <mmorrow> @pl \a b c -> g (f a b c)
00:47:49 <lambdabot> ((g .) .) . f
00:47:52 <mmorrow> @pl \a b -> g (f a b)
00:47:52 <lambdabot> (g .) . f
00:47:56 <MyCatVerbs> quicksilver: Taylor expansion says you can't really tell til you've evaluated more'n three terms so there :P
00:48:07 <ski> @pl \g f a b c d -> g (f a b c d)
00:48:07 <quicksilver> MyCatVerbs: I can intuit.
00:48:08 <lambdabot> (.) . (.) . (.) . (.)
00:48:12 <ski> @pl \g f a b c -> g (f a b c)
00:48:12 <lambdabot> (.) . (.) . (.)
00:48:16 <ski> @pl \g f a b -> g (f a b)
00:48:16 <lambdabot> (.) . (.)
00:48:25 <quicksilver> the answer for reverseN is a composition of N terms, each of which contains < N flips.
00:48:25 <mmorrow> heh
00:48:27 <glguy> is GHC 64-bit on NetBSD a no-go?
00:48:48 <MyCatVerbs> glguy: people use NetBSD?
00:49:06 <ski> presumably some do
00:49:12 <glguy> ah IRC, always answering the question you didn't ask with a question :)
00:49:52 <mmorrow> omg this site is sweet http://www.sandpile.org/
00:49:56 <tiglionabbit> quicksilver: I think it takes n-1 + n-3 + ... flips, because you need to move the first member to the end, the next member to the almost end, etc
00:50:12 <mmorrow> @tell pumpkin dunno if you've seen this http://www.sandpile.org/
00:50:13 <lambdabot> Consider it noted.
00:50:19 <quicksilver> tiglionabbit: something like that, yes. so quadratic.
00:50:24 <cjs> I used to use NetBSD, until I finally despaired of all of the work to get new versions of GHC running on it.
00:50:30 <Trinithis> probably easy to see using induction, but too lazy
00:50:47 <quicksilver> glguy: I'm sure it really ought ot work, but I do recall some people have reported problems.
00:51:05 <quicksilver> glguy: netbsd-64 really isn't that different form linux-64 and I bet someone determined could fix it fairly quickly.
00:51:40 <Phyx-> hrm.. cabal has been "configuring" hscolour for a while now
00:51:54 <tiglionabbit> so I got an interview for a python job because I mentioned I'm interested in haskell.  Better study up before I go~
00:52:08 <tiglionabbit> am reading learnyouahaskell.com
00:52:21 <MyCatVerbs> tiglionabbit: how does that work? :)
00:52:52 <tiglionabbit> MyCatVerbs: I dunno.  I think they want people who are enthusiastic about programming in general
00:54:18 <Phyx-> ok, i think configure is hanging
00:54:18 <tiglionabbit> hope I don't disappoint.  I haven't used haskell for anything real.  Just appreciate it from an aesthetic point, and steadily approach its ideas as I use python and javascript
00:54:28 <Phyx-> it couldn't be taking this long can it?
00:55:38 <MyCatVerbs> tiglionabbit: sounds awesome. Good going.
00:56:20 <MyCatVerbs> Phyx-: it shouldn't be. IIRC, hscolour is pure Haskell and so shouldn't need to be forking out to a slow-as-molasses autoconf script or anything.
00:56:40 <tiglionabbit> using list comprehensions in python was great practice, and throwing functions around in javascript may have prepared me decently
00:56:44 <Phyx-> does anyone here have problems with configuring it?
00:57:27 <Phyx-> MyCatVerbs: i'm just trying to install it as a library
00:57:42 <Phyx-> but for some reason, configure is taking > 5 mins or hanging
00:59:13 <Gracenotes> > map (`mod` 21) (iterate (*2) 1)
00:59:14 <lambdabot>   [1,2,4,8,16,11,1,2,4,8,16,11,1,2,4,8,16,11,1,2,4,8,16,11,1,2,4,8,16,11,1,2,...
00:59:33 <Gracenotes> > map (`mod` 99) (iterate (*2) 1)
00:59:35 <lambdabot>   [1,2,4,8,16,32,64,29,58,17,34,68,37,74,49,98,97,95,91,83,67,35,70,41,82,65,...
01:00:06 <Gracenotes> wait... period... *looks at theorem again*
01:01:59 <Botje> > drop 30 $ map (`mod` 99) (iterate (*2) 1)
01:02:00 <lambdabot>   [1,2,4,8,16,32,64,29,58,17,34,68,37,74,49,98,97,95,91,83,67,35,70,41,82,65,...
01:02:03 <Cale> > elemIndices 1 (map (`mod` 99) (iterate (*2) 1))
01:02:05 <lambdabot>   [0,30,60,90,120,150,180,210,240,270,300,330,360,390,420,450,480,510,540,570...
01:02:07 <Botje> grin :)
01:02:10 <Gracenotes> ah, 33!
01:02:18 <Phyx->      34       6     1932       3668    46     0.02   7320 runghc
01:02:22 <Gracenotes> yeah, I forgot... it doesn't have to be a factor
01:02:24 <Phyx-> runghc hangs
01:02:30 <Phyx-> god damnit
01:02:30 <Gracenotes> but it has to gcd to a factor
01:02:43 <Gracenotes> I mean, a prime factor
01:03:01 <Gracenotes> >_>
01:03:17 <Cale> http://www.youtube.com/watch?v=UWRyj5cHIQA -- haha
01:03:28 <Gracenotes> actually, only 30. But yeah, it does gcd to it. Is there a name for the phenomenon?
01:03:42 <Gracenotes> besides neat modular period thingy
01:04:33 <Cale> Order of an element divides the order of the group?
01:05:25 <Gracenotes> ah, that'd describe it
01:05:31 <Gracenotes> it is a group
01:07:02 <Cale> Well, the group of units mod 99...
01:07:29 <Cale> Which is order 60
01:07:38 <Gracenotes> > length $ nub $ take 1000 $ map (`mod` 77) (iterate (*2) 1)
01:07:39 <lambdabot>   30
01:07:48 <Gracenotes> ..this is a bit odd though :\
01:07:51 <Cale> So the order of every unit mod 99 will divide that.
01:08:14 <wli> phi(3^2*11) = 3*(3-1)*(11-1) = 2*3*10 = 60
01:08:23 <Botje> Gracenotes: no, it's decidedly even >:)
01:09:03 <Cale> There are again 60 units mod 77
01:09:11 <Phyx-> what are the reasons a configure script would hang?
01:09:17 <Gracenotes> oh, right, the semiprime totient
01:09:30 <Gracenotes> *keeps on leaving out parts*
01:09:41 <Gracenotes> or whatever it's called :o
01:09:54 <Cale> The totient function counts them, yeah.
01:10:10 <Cale> Also known as Euler's phi function.
01:10:38 <ski> @let pascal = iterate (\xs -> zipWith (+) (0:xs) (xs ++ [0])) [1]
01:10:39 <lambdabot>  Defined.
01:10:44 <ski> > pascal
01:10:45 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
01:10:59 <ski> > zipWith (\xs n -> map (`mod''` n) xs) pascal [0..]
01:11:00 <lambdabot>   [[1],[0,0],[1,0,1],[1,0,0,1],[1,0,2,0,1],[1,0,0,0,0,1],[1,0,3,2,3,0,1],[1,0...
01:11:28 <wli> > let f n = length [k | k <- [1 .. n - 1], k `gcd` n == 1] in f 99
01:11:29 <lambdabot>   60
01:11:38 <Cale> @let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p^2 <= n) $ primes
01:11:39 <lambdabot>  Defined.
01:11:53 <ski> @let foo = zipWith (\xs n -> map (`mod''` n) xs) pascal [0..]
01:11:54 <lambdabot>  Defined.
01:12:28 <ski> > [[ foo !! (2*n) !! (2*i) | i <- [0..n]] | n <- [0..]]
01:12:30 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,0,0,5,1],[1,6,3,0,3,6,1],[1,7...
01:12:43 <ivanm> why do some devs still use QC-1.* rather than 2.*? is there something that the newer version doesn't have?
01:13:03 <Cale> ivanm: They're slightly incompatible?
01:13:17 <Cale> and people are probably lazy :)
01:13:20 <ivanm> Cale: yes, but why not use the new version?
01:13:20 <ivanm> heh
01:13:27 <ivanm> Cale: as in too lazy to learn the new API?
01:13:39 <Cale> Or to update their package
01:13:53 <ivanm> no, can't be: utility-ht never used to depend on QC
01:14:01 <ski> > map (map (`mod''` 10)) pascal
01:14:03 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,0,0,5,1],[1,6,5,0,5,6,1],[1,7...
01:14:04 <ivanm> also, why do packages require QC in cabal? surely the tests should be run whilst developing, not when they're released...
01:14:12 <ski> hm, not that
01:15:33 <glguy> ivanm, when the tests are conditionally built with a flag, then you can install the package without tests or the QC dep
01:15:44 <ivanm> glguy: AFAICT, they're not...
01:16:06 <glguy> they being every package on hackage?
01:16:06 <ivanm> oh, it is too...
01:16:19 <ivanm> glguy: I meant utility-ht, which I was looking at ;-)
01:16:31 <ivanm> hackage fooled me, by just listing QC as a dep
01:18:38 <Cale> > let phi = product . map (\(p:ps) -> (p-1) * p^(length ps)) . group . factor in phi 77
01:18:41 <lambdabot>   60
01:19:18 <Cale> @let phi = product . map (\(p:ps) -> (p-1) * p^(length ps)) . group . factor
01:19:20 <lambdabot>  Defined.
01:19:24 <Cale> > phi 99
01:19:26 <lambdabot>   60
01:19:48 <athos> 10:12:29 < ski> > [[ foo !! (2*n) !! (2*i) | i <- [0..n]] | n <- [0..]]
01:19:52 <athos> that's a neat one :)
01:20:09 <ski> @let pam = flip map
01:20:10 <lambdabot>  Defined.
01:20:46 <ski> > [0..] `pam` \n -> [0..n] `pam` \i -> foo !! (2*n) !! (2*i)
01:20:48 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,0,0,5,1],[1,6,3,0,3,6,1],[1,7...
01:20:57 <ski> > [0..] >>= \n -> [0..n] >>= \i -> return (foo !! (2*n) !! (2*i))
01:20:59 <lambdabot>   [1,1,1,1,2,1,1,3,3,1,1,4,6,4,1,1,5,0,0,5,1,1,6,3,0,3,6,1,1,7,7,7,7,7,7,1,1,...
01:21:38 <wli> Cale: d(n) and \mu(n) easily come out of that as well.
01:21:44 <athos> pam vs. paMtacnoc :)
01:22:03 <ski> (athos : btw, note that the zeroes there prevents it from being equal to `pascal' .. i was wondering what variation of `pascal' it was)
01:22:38 <Gracenotes> > iterate ((++[1]) . ([1]++) . (zipWith (+) =<< tail)) [1]
01:22:40 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
01:23:04 <wli> > factor 36
01:23:05 <lambdabot>   [2,2,3,3]
01:23:11 <ski> > factor 1
01:23:12 <Berengal> I just noticed, you can use guards on values...
01:23:13 <lambdabot>   []
01:23:15 <ski> > factor 0
01:23:17 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
01:23:20 <ski> foo !
01:23:22 <Badger> heh
01:23:23 <Gracenotes> ha.
01:23:32 <ski> (it should list all primes)
01:23:39 <Gracenotes> lambdabot has just solved a great mathematical mystery!
01:23:47 <Cale> It never gets done dividing out all the 2's :)
01:24:10 <Berengal> ski: It does show all the primes, but to the power of infinity (factorized)
01:24:12 <Gracenotes> I knew I should have trusted my math teacher when she said 0 was neither prime nor composite...
01:24:15 <ski> er, right .. this was prime-factors
01:24:23 <ski> (i was thinking all divisors, first)
01:24:29 <ivanm> Gracenotes: isn't 0 composite?
01:24:40 <wli> > let d n = product $ map (\ks -> length ks + 1) (factor n) in d 36
01:24:41 <lambdabot>       No instance for (Integral [a])
01:24:41 <lambdabot>        arising from a use of `d' at <int...
01:24:49 <ski> `0' is a prime element
01:24:50 <ivanm> n is prime if n and 1 are it's only (non-negative) divisors
01:24:51 <Gracenotes> in a trivial way, I guess
01:25:05 <wli> > let d n = product $ map (\ks -> length ks + 1) (group $ factor n) in d 36
01:25:07 <lambdabot>   9
01:25:12 <Gracenotes> well, composite isn't just 'not prime'
01:25:14 <ivanm> then again, most things to do with prime, etc. assume positive integers
01:25:25 <ivanm> Gracenotes: true... it's when there's more than 2 factors
01:25:32 <ivanm> 1 is neither comp nor prime
01:25:32 <Berengal> ivanm: And n > 1
01:25:34 <Gracenotes> otherwise, I could say your mother was composite, and we couldn't have that
01:25:37 <ski> `p' is a prime element iff `p' does not divide `1', and if `p' divides `a * b', then `p' divides `a' or `p' divides `b'
01:25:44 <ivanm> Berengal: ahh, it does have to be positive? couldn't recall
01:25:47 <ivanm> @slap Gracenotes
01:25:47 <lambdabot> Come on, let's all slap Gracenotes
01:25:51 <ivanm> @slap Gracenotes
01:25:52 * lambdabot secretly deletes Gracenotes' source code
01:25:54 <ivanm> Gracenotes--
01:25:56 <ivanm> Gracenotes--
01:26:10 <hotaru2k3> hmmm... http://pastebin.com/d16ac6c35
01:26:26 <Gracenotes> ivanm: if you have any future tirades over three lines please use the pastebin. it's linked in the topic
01:26:36 <ivanm> @slap Gracenotes
01:26:36 * lambdabot orders her trained monkeys to punch Gracenotes
01:26:37 <ivanm> ;-)
01:26:42 <hotaru2k3> any suggestions for how to make that work better?
01:27:04 <Gracenotes> preflex: karma gracenotes
01:27:04 <preflex>  gracenotes: -2
01:27:08 <Gracenotes> ;_;
01:27:11 <athos> :>
01:28:02 <athos> what the fuck.
01:28:05 <Badger> mathematics and your mother combined?
01:28:07 <Badger> Gracenotes++
01:28:11 <ski> (cf. : `p' is irreducible iff `p' does not divide `1', and if `p' is associated to `a * b', then `p' is associated to `a' or `p' is associated to `b')
01:28:14 <athos> that's the first time i see someone /part-ing #haskell
01:28:29 <athos> it has to be some lisp-spy
01:28:50 <Gracenotes> Badger: a correlation has neither been proved or disproved
01:29:37 <wli> hotaru2k3: What's that do?
01:29:37 * Badger ahem.
01:30:57 <wli> Since we're on number theory I've been hunting for natural numbers representible as a sum of n k-th powers in multiple ways.
01:30:59 <hotaru2k3> wli: look at the types of reverse2, reverse3, reverse4, etc.
01:31:58 <wli> hotaru2k3: I see but don't understand.
01:32:48 <yitz> wli: ramanujan was also interested in that
01:32:56 <hotaru2k3> wli: reverse2 is \f a b -> f b a, reverse3 is \f a b c -> f c b a, reverse4 is \f a b c d -> f d c b a...
01:33:40 <wli> yitz: Ramanujan was the inspiration indeed.
01:35:27 <hotaru2k3> i'm wondering if there's some way to make one function instead of writing a separate function for each one
01:36:06 <yitz> @pl \f a b -> f b a
01:36:06 <lambdabot> flip
01:36:10 <wli> hotaru2k3: Probably using typeclasses. The things I've seen for variadic functions are beyond me, though.
01:36:14 <yitz> @pl \f a b c -> f c b a
01:36:14 <lambdabot> flip . (flip .) . flip
01:36:23 <yitz> @pl \f a b c d -> f d c b a
01:36:24 <lambdabot> flip . ((flip . (flip .)) .) . flip . (flip .) . flip
01:36:42 <yitz> @pl \f a b c d e -> f e d c b a
01:36:42 <lambdabot> flip . ((flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .) . flip . (flip .) . flip
01:42:31 <Alpounet> @pl \f a b c d e -> f a e b d c
01:42:32 <lambdabot> ((((flip . (flip .) . flip) .) . flip) .)
01:42:46 <Berengal> Is there a nice way to browse the currently installed module hierarchy?
01:43:34 <mmorrow> Berengal: that's an excellent idea for a tool
01:43:49 <quicksilver> you shuld have a page liek this : http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
01:43:53 <quicksilver> (only a local version)
01:44:10 <Berengal> Yeah, something like that's what I'm talking about
01:44:14 <Berengal> (only a local version ;))
01:44:45 <Berengal> Wait, doesn't leksah have something like this?
01:44:58 <quicksilver> well your GHC install should have come with docs I think
01:45:08 <quicksilver> and when you cabal install stuff it can (does?) install haddock too
01:46:55 <Berengal> Yeah, cabal can make haddocks if you enable it
01:47:48 <Berengal> I just checked leksah, and it seems it has a system-level knowledge of which modules exist
01:48:14 <yitz> those haddock index pages really need a button to collapse all
01:48:40 <quicksilver> there was a very bloody fight over having javascript in the haddock ;)
01:48:51 <quicksilver> personally I'm happy using the search facility of my browser to navitage long pages
01:49:48 <yitz> eh, sometimes, but more often I'd rather just see the whole top level at once and click my way down
02:01:08 <Baughn> ss
02:01:14 <Cale> http://www.marriedtothesea.com/043009/gifts-for-the-queen.gif
02:08:20 <BONUS> i can't see why it can't use javascript but make it degrade nicel
02:08:20 <BONUS> y
02:08:39 <BONUS> so that if you don't have javascript, you can still use the page normally
02:09:34 <quicksilver> I don't think that was the problem.
02:09:39 <quicksilver> but I don't remember what the problem was.
02:11:55 <McManiaC> @pl     map (\x -> check $ Step nr x)
02:11:55 <lambdabot> map (check . Step nr)
02:14:05 <yitz> BONUS: haven't tried, but it looks to me like the haddock index should work fine with JS disabled.
02:14:58 <yitz> oh, here's malcolmw. perhaps he remembers what the fight was about regarding the use of javascript in haddock.
02:14:59 <BONUS> jumping to functions by clicking on their name in the listing at the beginning still doesn't work in opera but oh well i've gotten used to it
02:15:29 <yitz> BONUS: oh, in the haddock pages themselves.
02:15:36 <BONUS> yeah
02:16:08 <yitz> hmm. too bad. that shouldn't be too hard. why does that need JS?
02:16:32 <BONUS> it doesn't. just an association i got
02:16:51 <yitz> you have a problem with anchors?
02:16:55 <BONUS> oh wow, looking at the html source for the haddock pages right now, looks like it could be better
02:17:20 <pozic> Why doesn't matFromList (replicate 16 0) ::  Mat44D work? I get No instance for (Vec j Double Vec4D)
02:17:21 <BONUS> yeah, could be something to do that in my address bar i get, say .../libraries/base/Control-Applicative.html#v%3AliftA3
02:17:54 <cjs> So given a list like [1,2,0,3,4,0,5,6], what's the clever way to change it to [[1,2],[0,3,4],[0,5,6]], i.e., group it into chunks starting with 0?
02:18:13 <pozic> (From the Data.Vec library)
02:20:12 <yitz> BONUS: that looks right
02:20:24 <BONUS> what's with the v%3A though
02:20:37 <yitz> BONUS: the anchors do look like that
02:21:08 <BONUS> why though
02:21:52 <yitz> cjs: there's a state monad one-liner for that. is that what you mean? or do you want the map take . iterate drop idiom?
02:22:07 <cjs> I was thinking list-style.
02:22:17 <cjs> But the State monad one would be interesting....
02:22:27 <BONUS> why not just #liftA
02:24:25 <yitz> > map (takeWhile (/= 0)) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= 0)) $ [1,2,0,3,4,0,5,6]
02:24:27 <lambdabot>   [[1,2],[3,4],[5,6]]
02:24:35 <yitz> oops, lost the 0
02:24:55 <cjs> Oops indeed. I'm finding it harder than it looked at fist.
02:24:58 <cjs> s/fist/first/
02:25:18 <BONUS> what am i missing here: (ContT c) >>= f = f c
02:25:40 <BONUS> i mean
02:25:40 <BONUS> c f
02:25:41 <ManateeL`> Hi all, have any book or paper that discuss "Haskell API Design"? Thanks!
02:25:58 <BONUS> ContT c >>= f = c f
02:26:08 <yitz> > map (\(x:xs) -> x : takeWhile (/= 0) xs) . takeWhile (not . null) . iterate (drop 1 . dropWhile (/= 0)) $ [1,2,0,3,4,0,5,6]
02:26:09 <lambdabot>   [[1,2],[3,4],[5,6]]
02:26:19 <yitz> didn't help
02:26:34 <BONUS> for this instance it says cannot construct infinite type m = ContT r m, but it typechecks in my head, hmm
02:26:36 <yitz> oh
02:26:54 <yitz> > map (takeWhile (/= 0)) . takeWhile (not . null) . iterate (dropWhile (/= 0) . drop 1) $ [1,2,0,3,4,0,5,6]
02:26:56 <lambdabot>   [[1,2],[],[]]
02:26:58 <yitz> heh
02:27:33 <cjs> Gah, maybe I just groupBy 0 or not 0, and then join after?
02:27:40 <yitz> > map (\(x:xs) -> x : takeWhile (/= 0) xs) . takeWhile (not . null) . iterate (dropWhile (/= 0) . drop 1) $ [1,2,0,3,4,0,5,6]
02:27:42 <lambdabot>   [[1,2],[0,3,4],[0,5,6]]
02:27:44 <yitz> yay
02:27:51 <yakov> hey
02:27:54 <BONUS> what are you trying to do here
02:28:20 <cjs> Ah, but groupBy takes pairs....
02:28:57 <yitz> cjs: yeah, there is an implementation of groupBy that would work, but that's not the implementation we use
02:29:35 <cjs> I just need to start with split, really. Which never seems to exist when I need it, or exists in not quite the right form....
02:30:51 <yitz> > map (\(x:xs) -> x : takeWhile (/= 0) xs) . takeWhile (not . null) . iterate (dropWhile (/= 0) . drop 1) $ []
02:30:52 <lambdabot>   []
02:31:32 <glguy> how do you write a C cast to make something fit into a: int (x *)[1][2][3];
02:31:32 <glguy> ?
02:32:57 <Ralith> trial and error
02:33:04 <glguy> (other than  (void*)   :) )
02:34:59 <yitz> > let break1 p (x:xs) = let (h,t) = break p xs in (x:h,t) in takeWhile (not . null) . evalState (repeatM $ break1 (== 0)) $ [1,2,0,3,4,0,5,6]
02:35:00 <lambdabot>   Not in scope: `repeatM'
02:35:08 <yitz> still missing? hmph
02:35:41 <yitz> > let break1 p (x:xs) = let (h,t) = break p xs in (x:h,t) in takeWhile (not . null) . evalState (sequence . repeat . State . break1 (== 0)) $ [1,2,0,3,4,0,5,6]
02:35:42 <lambdabot>   Couldn't match expected type `s -> (a, s)'
02:36:12 <cjs> Also, yitz, these are starting to lack a bit in the beauty department. There's got to be something I'm missing here.
02:36:29 <yitz> cjs: I'm devastated
02:39:15 <yitz> > let break1 p (x:xs) = let (h,t) = break p xs in (x:h,t) in takeWhile (not . null) . evalState (sequence . repeat . State $ break1 (== 0)) $ [1,2,0,3,4,0,5,6]
02:39:17 <lambdabot>   [[1,2],[0,3,4],[0,5,6]* Exception: /tmp/8210129051388565408:71:80-130: Non-...
02:39:39 <yitz> non-exhaustive pattern, i know, i know
02:40:44 <yitz> > let break1 p (x:xs) = let (h,t) = break p xs in (x:h,t); break1 _ _ = ([],[]) in takeWhile (not . null) . evalState (sequence . repeat . State $ break1 (== 0)) $ [1,2,0,3,4,0,5,6]
02:40:48 <lambdabot>   [[1,2],[0,3,4],[0,5,6]]
02:41:06 <yitz> cjs: what could be more beautiful than that?
02:41:35 <cjs> Well, maybe starting with:
02:41:39 <cjs> > groupBy (\a b -> a/=0 && b/=0) [0,1,2,0,3,4,0,5,6]
02:41:40 <lambdabot>   [[0],[1,2],[0],[3,4],[0],[5,6]]
02:42:09 <yitz> @type (&&) `on` (/= 0)
02:42:12 <lambdabot> forall a. (Num a) => a -> a -> Bool
02:42:12 <cjs> BTW, try it with [1,2,0,3,4,0,5,6] to get [[1,2],[0,3,4],[0,5,6]]
02:43:18 <McManiaC> lookup _key []          =  Nothing
02:43:23 <McManiaC> what is _key ?
02:43:29 <McManiaC> the same as _ ?
02:43:56 <yitz> @src lookup
02:43:57 <lambdabot> lookup _key []          =  Nothing
02:43:57 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
02:43:57 <lambdabot>                         | otherwise = lookup key xys
02:44:17 <yitz> McManiaC: same as key. looks like a typo, but works anyway.
02:44:40 <doserj> _ at the start of an identifier is ahint to the compiler that the value is not needed on the right hand side, so he doesn't give false warnings
02:44:54 <McManiaC> doserj: so like _ but with a name?
02:44:57 <doserj> yes
02:45:16 <yitz> doserj: really? that's interesting. ghc extension?
02:45:23 <McManiaC> ok
02:45:28 <doserj> I think that's standard
02:45:39 <McManiaC> it should be
02:46:18 <yitz> doserj: actually, it's a totally compiler-dependent feature
02:46:35 <doserj> http://www.haskell.org/onlinereport/lexemes.html#sect2.4 second paragraph
02:46:47 <yitz> i like using just _ in that situation anyway.
02:47:54 <yitz> cjs: yeah, the groupBy approach will work, but there the messiness comes from deciding whether you've got a leading 0.
02:48:26 <cjs> I'm not sure. If you start with splitBy p = groupBy ((&&) `on` p), and then maybe do a joinNextBy of some sort....
02:51:13 <LeCamarade> Did the parse rules for GHC change from 6.4 to 6.10?
02:51:38 <LeCamarade> I have code here that compiled fine at home, but not at work. And ... it is a parse error I can't even seem to fix.
02:52:17 <doserj> what's the error?
02:53:13 <ddvlad> any archlinu users around? i'm thinking of installing it -- is x86_64 a good choice for haskell support or am i better off with x86?
02:53:46 <ddvlad> [sorry, i realise this is offtopic, but #arch-haskell isn't that active :) ]
03:02:50 <yitz> let groupsOf n = map (take n) . takeWhile (not . null) . iterate (drop n); splitBy p (x:xs) = (x : h) : (map concat . groupsOf 2 . groupBy ((&&) `on` p) $ t) where {(h, t) = break p xs} in splitBy (== 0) [1,2,0,3,4,0,5,6]
03:03:06 <ski> McManiaC : concerning what the program does, `_key' is a normal variable name, just like `head_and_tail'
03:03:07 <yitz> > let groupsOf n = map (take n) . takeWhile (not . null) . iterate (drop n); splitBy p (x:xs) = (x : h) : (map concat . groupsOf 2 . groupBy ((&&) `on` p) $ t) where {(h, t) = break p xs} in splitBy (== 0) [1,2,0,3,4,0,5,6]
03:03:08 <lambdabot>   [[1,2],[0,3],[4,0],[5,6]]
03:03:18 <yitz> urgh
03:03:42 <yitz> as I said, it's a synch problem here
03:03:53 <ski> McManiaC : one can ask GHC to tell if there's any unused variables in the program
03:04:23 <ski> McManiaC : say `x' is such a one .. then that might be a bug (typo or thinko or et.c.)
03:05:00 <yitz> cjs: it could be worked out, but I don't think this will come out nicer in the end.
03:05:00 <ski> McManiaC : if it was not a bug, then it would be nice to be able to tell GHC that we really did intend to not use `x'
03:05:45 <ski> McManiaC : either you can then replace `x' in the pattern with `x' .. or if you want to retain the informative (maybe not in this case) name `x', you can call it `_x'
03:06:31 <cjs> yitz: Ok, I give in. What's the State one-liner?
03:07:03 <yitz> > let break1 p (x:xs) = let (h,t) = break p xs in (x:h,t); break1 _ _ = ([],[]) in takeWhile (not . null) . evalState (sequence . repeat . State $ break1 (== 0)) $ [1,2,0,3,4,0,5,6]
03:07:05 <lambdabot>   [[1,2],[0,3,4],[0,5,6]]
03:07:42 <yitz> but yeah, you still need break1 to avoid the one-off issue inherent in this problem
03:08:35 <ski> BONUS
03:08:42 <Cale> ddvlad: I think dons perhaps uses archlinux
03:08:47 <ski>   (>>=) :: m a -> (a -> m b) -> m b
03:08:50 <yitz> perhaps?
03:08:56 <Cale> I can't remember
03:09:04 <yitz> dons *is* archlinux
03:09:08 <ski>   (>>=) :: Cont o a -> (a -> Cont o b) -> Cont o b  -- in your case
03:09:12 <ski> so in
03:09:17 <ddvlad> thanks for the tip :)
03:09:28 <ski>   well, actually
03:09:40 <ski>   (>>=) :: ContT o m a -> (a -> ContT o m b) -> ContT o m b  -- in your case
03:09:43 <ski> so in
03:09:48 <ski>   ContT c >>= f = c f
03:09:51 <ski> we have
03:10:01 <ski>   ContT c :: ContT o m a
03:10:06 <ski>   f :: a -> ContT o m b
03:10:11 <cjs> yitz: Well, here's as close as I get: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4418#a4418
03:10:18 <ski>   ContT c >>= f :: ContT o m b
03:10:32 <ski>   c f :: ContT o m b
03:11:00 <ski>   c :: (a -> m o) -> m o
03:11:17 <ski> so, the call
03:11:18 <ski>   c f
03:11:21 <ski> doesn't work
03:11:23 <ski> since
03:11:29 <ski>   a -> m o
03:11:33 <ski> is not the same as
03:11:38 <ski>   a -> ContT o m b
03:11:40 <Cale> yitz: btw, what is that list manipulation problem exactly?
03:12:02 <Cale> yitz: Group a list into chunks starting with 0?
03:12:15 <yitz> it's a one-off thing.
03:12:17 <yitz> yeah, that.
03:12:23 <yitz> cjs asked the question
03:12:47 <yitz> Cale: problem is that the first chunk might not have a 0.
03:13:27 <yitz> cjs: ok, that's reasonable
03:13:41 <quicksilver> it's one version of the old "split a string on commas" question
03:13:52 <quicksilver> it's the version where you keep the commas, attached to the item which comes *after*
03:14:17 <quicksilver> another similar one is splitAWikiWordIntoItsWords
03:14:56 <cjs> The real case is that I've got a file divided into several sections, some of which start with lines starting "COST CENTRE", and I want to reformat only those sections.
03:15:06 <Cale> > let f xs = u : groupBy (<) v where (u,v) = span (/= 0) xs in f [7,2,0,1,2,0,3,4,0,7,8,9]
03:15:08 <lambdabot>   [[7,2],[0,1,2],[0,3,4],[0,7,8,9]]
03:15:25 <Cale> Mildly cheesy :)
03:15:26 <yitz> yeah, this paradigm comes up all the time
03:15:35 <quicksilver> there are some combinators in tagsoup
03:15:39 <quicksilver> for this kind of thing
03:15:42 <quicksilver> partitions + sections?
03:15:47 <quicksilver> I don't remember exactly how they work though
03:15:54 <quicksilver> it's common in XML to try to do what cjs is doing.
03:16:06 <yitz> quicksilver: it's common everywhere
03:16:13 <Cale> > let (u,v) = span (/= 0) [7,2,0,1,2,0,3,4,0,7,8,9] in u : groupBy (const (/= 0)) v
03:16:14 <lambdabot>   [[7,2],[0,1,2],[0,3,4],[0,7,8,9]]
03:16:57 <yitz> Cale: I don't like tricking groupBy. whichever way you do it, someone will go and implement groupBy the other way.
03:17:19 <Cale> I'm not sure it's really okay to implement it another way.
03:17:24 <ski> > let f xs = u : groupBy (<) v where (u,v) = span (/= 0) xs in f [7,2,0,1,2,0,-3,4,0,7,8,9]
03:17:26 <lambdabot>   [[7,2],[0,1,2],[0],[-3,4,0,7,8,9]]
03:17:28 <yitz> why not?
03:17:37 <yitz> because the implementation
03:17:47 <yitz> full implementation is part of the report?
03:17:53 <cjs> Maybe I just want to be using a fold for this sort of thing.
03:18:02 <Cale> Well, the report provides a specification of what it should do.
03:18:27 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (`elem`",.") "127.0.0,1"
03:18:28 <lambdabot>   ["127","0","0","1"]
03:18:43 <Cale> > let f xs = u : groupBy (const (/= 0)) v where (u,v) = span (/= 0) xs in f [7,2,0,1,2,0,-3,4,0,7,8,9]
03:18:45 <lambdabot>   [[7,2],[0,1,2],[0,-3,4],[0,7,8,9]]
03:19:07 <yitz> Cale: I guess what bothers me is that the report's way is non-intuitive to me. I would expect it to compare adjacent elements.
03:19:24 <Cale> If you try to implement it, it will become obvious why it does it that way :)
03:19:48 <yitz> I know it's easier, but just seems like weird behavior.
03:20:09 <Cale> I've generally found this behaviour to be more useful.
03:20:24 <Twey> > uncurry (:) . second (groupBy $ const (/= 0)) $ span (/= 0) [7,2,0,1,2,0,3,4,0,7,8,9]
03:20:26 <lambdabot>   [[7,2],[0,1,2],[0,3,4],[0,7,8,9]]
03:21:29 <yitz> oh, that's a nice approach. then you don't even need the groupBy trick.
03:21:40 <doserj> > uncurry (:) . second (groupBy $ const (/= 0)) $ span (/= 0) [0,7,2,0,1,2,0,3,4,0,7,8,9]
03:21:41 <lambdabot>   [[],[0,7,2],[0,1,2],[0,3,4],[0,7,8,9]]
03:21:53 <yitz> oops. oh well.
03:22:41 <mmorrow> > let f xs = u : groupBy (const (/= 0)) v where (u,v) = span (/= 0) xs in f [7,2,0,1,2,0,-3,4,000000,7,8,9]
03:22:42 <lambdabot>   [[7,2],[0,1,2],[0,-3,4],[0,7,8,9]]
03:23:15 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (/= 0) [7,2,0,1,2,0,-3,4,000000,7,8,9]
03:23:16 <lambdabot>   [[],[],[0],[],[0],[],[0],[],[]]
03:23:25 <mmorrow> um
03:23:33 <mmorrow> oh
03:23:41 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (== 0) [7,2,0,1,2,0,-3,4,000000,7,8,9]
03:23:42 <lambdabot>   [[7,2],[1,2],[-3,4],[7,8,9]]
03:23:51 <Cale> groupBy (<) in particular is really a lovely function. It's handy if you have, say, a list of document sections which are broken up like 1.2.1.5 and such, and you want to make a tree from them. You can take off the head, which is your root, use groupBy, comparing the depths, and then recurse on each of the groups you get :)
03:23:56 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (== 0) [7,2,0,1,2,0,-3,4,000000,0,07,8,9]
03:23:57 <lambdabot>   [[7,2],[1,2],[-3,4],[],[7,8,9]]
03:24:05 <mmorrow> haha, i'm an idiot
03:24:13 <mmorrow> > let f xs = u : groupBy (const (/= 0)) v where (u,v) = span (/= 0) xs in f [7,2,0,1,2,0,-3,4,0,0,0,0,7,8,9]
03:24:14 <lambdabot>   [[7,2],[0,1,2],[0,-3,4],[0],[0],[0],[0,7,8,9]]
03:24:24 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (== 0) [7,2,0,1,2,0,-3,4,0,0,0,0,0,07,8,9]
03:24:25 <lambdabot>   [[7,2],[1,2],[-3,4],[],[],[],[],[7,8,9]]
03:26:48 <Cale> > let f (x:xs) = Node x (map f (groupBy (<) xs)) in f [0,1,2,1,3,3,1,2,3,2,3,1]
03:26:50 <lambdabot>   Node {rootLabel = 0, subForest = [Node {rootLabel = 1, subForest = [Node {r...
03:27:05 <cjs> I'm gonna use twey's, even though I don't have time to sit down and understand it.
03:27:08 <Cale> .oO(I hate Data.Tree's Show instance.)
03:27:56 <Twey> cjs: It was just a rephrasing of Cale's to use arrows instead of let.
03:30:47 <Twey> Cale: How else would it work?
03:31:08 <tux-foo> How can I cast a Double or Float to in Int(eger) ?
03:31:09 <Twey> drawTree isn't exactly a compact representation.
03:31:18 <Twey> tux-foo: round
03:31:25 <tux-foo> Twey, kk, thanx
03:31:33 <Twey> With round, ceiling, or floor
03:32:10 <doserj> @hoogle (Floating a, Integral b) => a -> b
03:32:10 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
03:32:11 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
03:32:11 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
03:32:27 <Cale> Twey: Well, I'd prefer to do without the record syntax
03:32:44 <cjs> Twey: Oh, really? I'll keep that one, too, then....
03:33:31 <Twey> Ah, true.  I suppose that would help some.
03:34:03 <Cale> I basically always define my own tree anyway
03:36:08 <tux-foo> Can one define own coersion in haskell, I.e. having a algebraic type: data Foo = II Int | BB Bool
03:36:38 <Twey> Haskell's not big on coercion, generally.
03:36:54 <tux-foo> can one define that a BB Bool can be converted to a II Int like BB False = Int 0 and BB True = Int 1
03:37:09 <yitz> Cale: http://www.archlinux.org/developers/
03:38:03 <Cale> tux-foo: What would that mean?
03:38:12 <tux-foo> Cale, I see problems indeed
03:38:23 <Cale> Suppose I write
03:38:27 <tux-foo> I am trying to define a (+) and a (*) for Foo
03:38:39 <Cale> f (II n) = "hello"
03:38:45 <Cale> f (BB b) = "yo"
03:39:00 <tux-foo> i.e. (BB False) * (II 5) = II 0
03:39:14 <tux-foo> whilst (BB True) * (BB True) =  True
03:39:27 <tux-foo> and (BB True) + (BB true) = BB False
03:39:33 <Cale> Oh, you're defining arithmetic operations, that's a little different from coercion.
03:39:34 <Twey> tux-foo: Implement Num
03:39:39 <osfameron> @index on
03:39:39 <lambdabot> bzzt
03:39:41 <tux-foo> correction:  (BB True) * (BB True) =  BB True
03:39:41 <osfameron> dammit
03:40:16 <Cale> tux-foo: There's nothing for it but to implement each of the cases.
03:40:27 <tux-foo> Twey, yes, of course, but this would mean I need to do patternmatichin on all possibilities, i.e. on BB + II BB + BB, II + BB and II + II
03:40:44 <Twey> Of course
03:40:47 <tux-foo> and that would mean -> duplicate code ^^
03:41:02 <Twey> It's not really duplicate code â€” there's no way to derive those automatically, is there?
03:41:11 <Twey> What's the pattern you'd like to implement?
03:41:27 <Cale> tux-foo: You could ostensibly want something different for any one of those cases.
03:41:31 <tux-foo> Twey, In the real life problem I not only Bool and Int types, but also Double.
03:42:34 <tux-foo> Cale: no, (+) is typically commutative and moreover, I have default casting methods. I.e. BB True is one in integer calculation and 1.0 in Double calculation.
03:42:42 <tux-foo> I.e. By definition.
03:42:59 <tux-foo> Cale, But I see the problem, So I will just implement Num.
03:43:05 <Cale> tux-foo: Right, but the Haskell compiler doesn't know that (+) is commutative.
03:43:40 <tux-foo> Cale, Neither do I ^^
03:43:41 <Cale> (It's just like any other function)
03:44:05 <tux-foo> Cale, I will implement it. Although I am still not sure why fromInteger is needed.
03:44:15 * hotaru2k3 just found a rather annoying bug in google
03:44:26 <yitz> tux-foo: if there is duplicate behavior in different cases, use a function or value that is shared between them.
03:44:28 <Cale> tux-foo: For Num?
03:44:44 <Cale> tux-foo: It's used to interpret integer literals as members of your type.
03:45:07 <tux-foo> Cale, this would imply all data is countable.
03:45:12 <Cale> No...
03:45:29 <Cale> It just implies that there's a homomorphism from the integers to your type of number.
03:45:32 <tux-foo> And of course, this is true for all digital data, but semantically this is not a propperty.
03:45:41 <tux-foo> Cale, kk
03:46:01 <tux-foo> I will then just implement it like fromInteger x = II x
03:46:05 <LeCamarade> modifyMVar is cool as ice. Christ of Nazareth. I'm watching a server sync clients because of one well-placed MVar!
03:46:09 <LeCamarade> ghc++
03:46:25 <Cale> There's no need for fromInteger to be injective or surjective. That is, it can miss out some elements of your type, and it can map some integers to the same element of your type.
03:47:35 <Cale> It should generally be the case that it splits over the arithmetic operations though: fromInteger (x + y) = fromInteger x + fromInteger y, and so on.
03:48:38 <Cale> (though even that fails for things like Double)
03:48:43 <Cale> er...
03:48:45 <Cale> hmm
03:49:04 * quicksilver thinks it probably doesnt, actually.
03:49:15 <Reiver> yay parsers
03:49:25 <quicksilver> doubles represent integers exactly as long as they are small enough to fit in the mantissa.
03:49:28 * Reiver tries to get his head around a really simple one so he can move on.
03:49:56 <ordwidr> can i "newtype" a function type?
03:50:05 <Cale> quicksilver: but once it starts rounding then you'll run into problems
03:50:09 <ordwidr> like newtype a = (Int -> Bool)
03:50:15 <dibblego> ordwidr, sure I do it all the time
03:50:24 <Cale> ordwidr: yes, but your syntax is off there
03:50:31 <ordwidr> dibblego: what about parametrized types?
03:50:33 <dibblego> newtype A a = A (Int -> a) -- perhaps
03:50:34 <Cale> newtype A = A (Int -> Bool)
03:50:39 <dibblego> ordwidr, especially then
03:50:56 <tux-foo> Cale, I see
03:51:12 <dibblego> ordwidr, it's not that much different to a type-class
03:51:21 <yitz> @check \x y -> (fromInteger x :: Float) + (fromInteger y) == fromInteger (x + y)
03:51:23 <tux-foo> Reiver, I am writing an interpreter atm
03:51:23 <lambdabot>   "OK, passed 500 tests."
03:51:41 <tux-foo> Cale, that would mean that fromInteger x = II x would work
03:51:45 <tux-foo> *means
03:51:51 <yitz> @check \x y -> (fromInteger x :: Float) - (fromInteger y) == fromInteger (x - y)
03:51:53 <lambdabot>   "OK, passed 500 tests."
03:51:57 <ordwidr> dibblego: thanks
03:51:58 <Cale> tux-foo: yeah, if II takes an Integer and not an Int
03:52:41 <tux-foo> Cale II takes an Integer in the real life problem (I mapped it to a simpler version to make it more suitable for discussion)
03:52:54 <yitz> @check \x y -> (fromInteger x :: Int) + (fromInteger y) == fromInteger (x + y)
03:52:55 <lambdabot>   "OK, passed 500 tests."
03:53:21 <tux-foo> Cale, In real life I have a parser for expression which returns Environment -> Calculated
03:53:51 <tux-foo> where: data Calculated = CalcBool Bool | CalcInt Integer | CalcFP Double
03:54:09 <Cale> > (fromInteger 7438190473291047398 :: Float) + (fromInteger (-7438190473291047397) :: Float)
03:54:11 <lambdabot>   0.0
03:54:26 <Cale> > fromInteger (7438190473291047398 + (-7438190473291047397))
03:54:27 <lambdabot>   1
03:54:32 <Cale> > fromInteger (7438190473291047398 + (-7438190473291047397)) :: Float
03:54:33 <lambdabot>   1.0
03:54:49 * Badger realises he now knows dibblego's fate
03:54:52 * Badger :)
03:54:52 <tux-foo> Cale: overflow propperties?
03:54:59 <Cale> Rounding.
03:55:11 <dibblego> Badger, ?
03:55:24 <tux-foo> > fromInteger 7438190473291047398
03:55:26 <lambdabot>   7438190473291047398
03:55:32 <tux-foo> > fromInteger 7438190473291047397
03:55:33 <lambdabot>   7438190473291047397
03:55:36 <Cale> > fromInteger 7438190473291047398  :: Float
03:55:37 <tux-foo> > fromInteger -7438190473291047399
03:55:37 <lambdabot>   7.4381907e18
03:55:38 <lambdabot>       No instance for (Num (Integer -> a))
03:55:38 <lambdabot>        arising from the literal `7...
03:55:47 <tux-foo> > fromInteger -7438190473291047399::Int
03:55:48 <lambdabot>   Couldn't match expected type `Int'
03:55:51 <Cale> > fromInteger (-7438190473291047399)
03:55:52 <lambdabot>   -7438190473291047399
03:55:59 <tux-foo> hmm, I will continue playing in my own ghci ^^
03:55:59 <Cale> the parens are required there
03:56:05 <Cale> > fromInteger (-7438190473291047399) :: Float
03:56:07 <lambdabot>   -7.4381907e18
03:56:13 <Cale> > fromInteger (-7438190473291047399) :: Int
03:56:15 <lambdabot>   -7438190473291047399
03:56:18 <tux-foo> Cale, for - to prefix to the int?
03:56:19 <Cale> > fromInteger (-7438190473291047399) :: Int32
03:56:21 <lambdabot>   2076892697
03:56:22 <yitz> tux-foo: you can also private msg lambdabot
03:56:23 <Cale> yeah
03:56:33 <tux-foo> yitz, ^^
03:56:52 <Cale> tux-foo: Otherwise, - is an infix operator :)
03:57:09 <Cale> tux-foo: So you get a type error for trying to subtract that number from fromInteger :)
03:58:04 <tux-foo> Cale, I see
03:58:29 <Twey> (yes, it's a bit ugly, so mostly we just use negate)
03:58:37 <Cale> Really?
03:58:46 <Cale> I like unary minus, myself :)
03:58:54 <Twey> But it's bonkers
03:59:05 <Twey> It doesn't curry nicely
03:59:18 <Twey> And it causes completely unintuitive issues like the above
03:59:33 <Twey> I'd rather make it whitespace-sensitive
03:59:54 <Twey> (-1) is a number, (- 1) is a section
04:00:07 <yitz> Twey: unary minus looks nice when it works. otherwise, negate.
04:00:07 <Cale> and (-x), again unary minus?
04:00:26 <Twey> Aye
04:00:48 <Twey> It's a bit magic, but it beats the pants off what we've got at the moment
04:00:51 <Cale> It seems perhaps a little funny for (-x) and (- x) to have two completely separate types, but it would work.
04:01:20 <quicksilver> I don't much like whitespace sensitivity.
04:01:26 <quicksilver> But then I don't like the current situation either.
04:01:30 <Twey> Actually, we could make all operators whitespace-dependent
04:01:47 <Twey> Then it would be consistent, and we could use symbols as parts of identifiers.
04:01:52 <quicksilver> is it ocaml where unary negation is ~ ?
04:01:55 <Cale> We could, but this is the first I've heard of doing it just for (-) and I actually like that idea a bit better.
04:02:13 <Cale> Since I really don't like having to put whitespace around certain operators
04:02:14 <osfameron> I thought the whitespace disambiguation had been proposed before?
04:02:18 <Cale> Particularly ^
04:02:22 <osfameron> or :
04:02:23 * doserj votes for removing unary - completely, but keep it as part of literals syntax
04:02:34 <osfameron> anyone for "x : xs" ? ;-)
04:02:35 <Cale> yeah
04:03:23 <Cale> I like that unary minus can be used just like in normal mathematical notation.
04:03:27 <Twey> What's wrong with x : xs?
04:03:59 <Cale> Somehow I'm more likely to put whitespace around : when constructing than when pattern matching.
04:04:32 <Twey> Why?
04:04:34 <osfameron> I prefer the compactness of x:xs unless x or xs are an expression
04:04:56 <Twey> I prefer the consistency of x : xs
04:05:00 <Cale> osfameron: Whitespace disambiguation has been proposed, but all the proposals I've seen extended it to all operators.
04:05:31 <Twey> Well, unary minus is the only unacceptable current situation it would fix
04:05:41 <Cale> yeah
04:06:04 <Cale> I also don't like our choice of . for the module path separator, but it's probably way too late to change that now.
04:06:09 <Twey> But it does kind of logically extend from there to other operators, for consistency
04:06:20 <Twey> (and we expand the identifier space considerably by doing so)
04:06:33 <Twey> Mind you, I suppose with Unicode that's not really an issue.
04:06:47 <ordwidr> how do I declare a function type that takes a function of the same type as an parameter
04:06:58 <ordwidr> (where each function is parametrized over a type)
04:07:20 <Twey> ordwidr: With a type declaration?
04:07:21 <Cale> ordwidr: Um... I'm not sure if I understand what you're describing...
04:07:22 <ordwidr> I think it's like with HCons
04:07:43 <Twey> type Foo = Foo -> Bar
04:07:43 <Cale> a -> (a -> b) -> ...
04:07:50 <Cale> oh
04:08:05 <ordwidr> Twey: like that but type Foo a = (Foo b) -> Bar
04:08:24 <Cale> ordwidr: Oh, if it's recursive, you must use newtype
04:08:35 <Cale> and b wouldn't be in scope there...
04:08:54 <ordwidr> Cale: rescursive but the applied type of the "nested" function is different
04:09:56 <Cale> newtype Foo a = F (Foo Bool -> a) ?
04:10:37 <Cale> (not sure what you're trying to accomplish with this :)
04:11:19 <Cale> newtype Foo a b = F (Foo b a -> a)  -- :)
04:11:30 <ordwidr> I think if the type changes on "recursion" I have to find a way to specifiy the end of recursion. I'll try type classes and to instances "empty" and "Foo" with another nested "Foo".
04:11:31 <Cale> bizarre type :)
04:11:40 <ordwidr> Cale: yes
04:12:19 <Cale> ordwidr: Are you trying to do something like make the Y combinator typecheck?
04:12:25 <dr4wd3> im trying to install cabal install and update the package list via cabal update from ubuntu using ghc-6.10.2 and bootstrap.sh from cabal-install-0.6.2 but i keep getting "cabal: user error (Codec.Compression.Zlib: premature end of compressed stream)"
04:12:38 <ordwidr> Cale: more like a heterogenous llist
04:12:56 <dr4wd3> any ideas?
04:13:10 <Cale> dr4wd3: hmm... that's interesting. Did a download get cut off?
04:13:20 <ordwidr> Cale: the type is endless recursive
04:14:16 <dcoutts> dr4wd3: probably a download failure
04:14:39 <Cale> ordwidr: But for a heterogeneous list, don't you just want something like a glorified nested bunch of pairs?
04:14:48 <dr4wd3> Cale: the 00-index.tar.gz seems fine
04:15:15 <ordwidr> Cale: yes. in my case I want a list of functions of  (a -> Bool)
04:15:32 <dr4wd3> Cale: but tar does spit out "tar: Unexpected EOF in archive"
04:15:59 <Cale> dr4wd3: delete it and try again and hope that the download doesn't get cut off, I suppose.
04:16:04 <ordwidr> Cale: I think newtype Foo a b = F (Foo a b -> a -> Bool) | E will do
04:16:15 <ordwidr> Cale: "E" marks the end of the list
04:16:28 <Cale> Well, that's not really heterogeneous.
04:16:37 <ski> that's a non-regular type
04:16:57 <ordwidr> Cale: hmm, yes. a and b are constant. That's not what I want
04:17:01 <ski> (i.e. if the recursive type parameters aren't the same)
04:17:32 <dr4wd3> Cale: perhaps manually downloading will help but the tar looks exactly the same (i see now that its not ok but died half way through)
04:17:36 <Cale> ordwidr: You'll need to encode the conses at the type level
04:17:49 <ski> ordwidr : that doesn't look like "a list of functions of  (a -> Bool)"
04:17:51 <ordwidr> Cale: what means?
04:18:18 <ski> (and you need to s/newtype/data/)
04:18:34 <ordwidr> ski: I'll try that
04:18:42 <Cale> ordwidr: data PCons a b = P (a -> Bool) b; data PNil = N
04:19:37 <ski> ordwidr : i missed that start .. could you restate what structure you are trying to encode ?
04:19:40 <dr4wd3> it looks like this bug http://hackage.haskell.org/trac/hackage/ticket/181
04:19:44 <ski> s/that/the/
04:19:45 <Cale> ordwidr: Then, for instance,  P null (P (> 0) N) :: PCons [a] (PCons Int PNil)
04:20:11 <ordwidr> ski: a heterogenous list of functions a -> Bool
04:20:31 <ski> i.e. `[exists a. a -> Bool]' ?
04:20:35 <Cale> ordwidr: It goes without saying that you'll be doing lots of typeclass hackery to write anything useful on a type like this.
04:20:41 <ski> (assuming we had `exists' in haskell)
04:20:45 <ordwidr> ski: jes
04:20:55 <ordwidr> I think
04:21:09 <Cale> ordwidr: Will you want to be able to apply the functions? (I think yes)
04:21:31 <ski> ordwidr : you can do that .. but presumably you want to do something with the function of type `a -> Bool', for appropriate `a's
04:21:36 <Cale> (exists a. a -> Bool) is a pretty useless type of function to have
04:21:48 <Cale> because you can never apply it
04:21:49 <ski> Cale :)
04:21:51 <ordwidr> Cale: I think thats the idea. I come from a classic oo background and digging into haskell.
04:22:04 <ordwidr> cale: a schroedinger type?
04:22:14 <ski> let foo :: exists a. a -> Bool; foo = ... in foo undefined
04:22:20 <ordwidr> cale: the cat dies as soon as you apply the function.
04:22:31 <Badger> :(
04:22:33 <Badger> poor cat.
04:22:41 <Cale> ski: Well, okay, you can apply it to undefined, but in that case, just store a Bool
04:22:59 <Cale> ordwidr: You can never prove that any particular value you have is of the right type.
04:23:21 <Cale> ordwidr: All you know is that there is some type which would be okay, but since you don't know if that's any particular type, it can't be applied.
04:24:01 <ski> ordwidr : assume that you could use a normal haskell list, `[f0,f1,f2,f3]' .. how do you intend to use this list ? i.e. how do you intend to use `f0',`f1',`f2',`f3' ?
04:24:01 <ordwidr> cale, ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4131#a4172
04:24:24 <ordwidr> that's the problem description. I wan't to model the a relational table definition which is basically a list of column definitions
04:24:28 <ski> ordwidr : we need to know the intended usage to be able to suggest a proper encoding in haskell
04:24:50 <ordwidr> ski: I have hlist of values which a want to apply to the hlist of functions
04:25:16 <Cale> * A table spec shall be modifiable at runtime. E.g. (add, remove columns)  -- this implies that the type of the table does not indicate the types of the columns
04:25:33 <Cale> Well, perhaps...
04:26:05 <ordwidr> cale: That's why I think the type of a table is basically a heterogenous list of column defs
04:26:07 <Cale> It sounds like you want to implement a small dynamic type system
04:26:15 <ordwidr> cale: basically
04:26:32 * ordwidr scraps his head. In java this is easy?!
04:26:41 <Cale> Is it?
04:27:45 <Cale> Using the Haskell type system to check your types is probably the wrong idea.
04:27:52 <Cale> Given what you're trying to do.
04:28:00 <ordwidr> cale: what would you suggest?
04:28:17 <ordwidr> cale:  runtime checking
04:28:20 <Cale> yes
04:28:22 <ski> hm, possibly you could use `Dynamic'
04:28:31 <Cale> Or just create a union type
04:28:48 <Cale> data Value = VInteger Integer | VBool Bool | VString String
04:29:05 <ordwidr> cale: I wanted my small type system to be open
04:29:16 <ski> (of course, that won't statically check that your code doesn't try to apply a list of functions to a list of arguments, where some function-argument pair can't be applied)
04:29:31 <ordwidr> ski: that would by ok for me
04:29:43 <ski> @type dynApply
04:29:45 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
04:29:49 <Cale> Yeah, you could use Data.Dynamic, I suppose
04:30:00 <Cale> I've never actually had cause to use it myself.
04:30:11 <ordwidr> ski: Is the an intro for Dynamic?
04:30:29 <quicksilver> Dyanmic is a sledgehammer.
04:30:32 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
04:30:38 <quicksilver> it's throwing out the baby with the bath water.
04:30:41 <Cale> There isn't much to it
04:30:42 <quicksilver> IMO.
04:30:52 <osfameron> those are truly terrible docs
04:30:57 <ordwidr> yes
04:31:00 <Cale> toDyn will convert a value (of any Typeable type) to a Dynamic
04:31:30 <Cale> fromDynamic will convert it back to a Maybe value, giving Nothing when you're asking for the wrong type
04:31:32 <ordwidr> cale: So I can defined function for a dynamic type?
04:31:42 <Cale> ordwidr: You can.
04:31:50 <ordwidr> f :: Dynamic -> Bool
04:32:01 <Cale> sure
04:32:12 <Cale> What do you want f to do?
04:33:00 <ski> > fromDynamic =<< dynApply (toDyn ord) (toDyn 'a') :: Maybe Int
04:33:02 <lambdabot>   Just 97
04:33:04 <ski> @type toDyn
04:33:06 <lambdabot> forall a. (Typeable a) => a -> Dynamic
04:33:11 <ski> @type dynApply
04:33:12 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
04:33:20 <ski> @type fromDynamic
04:33:21 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
04:33:29 <ordwidr> cale: e.g. check if a row is valid according to the table def. check :: [Dynamic] -> [Dynamic -> Bool] -> Bool
04:33:49 <Cale> oh, sure
04:33:53 <ordwidr> or: filter [Dynamic] -> [Dynamic -> Bool] -> [Dynamic]
04:34:11 <Cale> zipWith ($) ?
04:34:13 <Cale> er
04:34:31 <ordwidr> cale: zipWith / filter / all the list stuff
04:34:35 <Cale> followed by 'and'
04:36:28 <Cale> ordwidr: Another way to approach this problem is to figure out what operations you want to support on values, and rather than storing the values, store the operations.
04:36:49 <Cale> (or use an existential type)
04:37:32 <ordwidr> cale: It's interesting that after some time the discussion of this problem on #haskell always leads to existentials.
04:37:54 <ordwidr> cale: which I learned here are evel more evil than most other stuff :-)
04:38:07 <Cale> They're not so evil.
04:38:22 <Cale> But they are considered a bit of an advanced feature.
04:38:58 <ordwidr> cale: "advanced" not bad. how would thy fit into a "zipping" to hlist to a [Bool]?
04:39:11 <ordwidr> cale: which is what I consider the core of the problem
04:39:45 <Cale> ordwidr: Actually, I'm not altogether certain what you're trying to accomplish there.
04:40:02 <ordwidr> cale: saw the hpase link?
04:40:05 <Cale> yes
04:41:22 <ordwidr> cale: I want to model an api for a relation database. This has been done before, i know. But as an exercise I want the set of available column types to be open at compile type.
04:41:23 <Cale> What's important about a column type? That it be able to validate a piece of data, yeah?
04:41:52 <Cale> Let's suppose that you're using Dynamic for the actual data in your table.
04:41:53 <ordwidr> cale: that's a simple example. Later there is the need to serialize the value etc.
04:42:17 <Cale> Because you seem to want to keep things open, and dealing with more than one existential at a time is perhaps too much thinking for me on no sleep
04:42:30 <ordwidr> cale: hehe
04:43:38 <ordwidr> cale: but maybed dynamic is the way to go as how someone anazyled before I want to create a mini dynamic type system.
04:43:42 <Cale> So then we could indeed just model column types as Dynamic -> Bool functions. These are totally unserialisable.
04:44:02 <ultrakrankerhamp> @help
04:44:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:44:03 <ordwidr> cale: So think of String -> Dynamic (read from disk)
04:44:07 <Cale> So the approach would have to change drastically if you wanted to serialise things.
04:44:08 <ultrakrankerhamp> @list
04:44:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:44:14 <ordwidr> cale: oh
04:44:48 <ultrakrankerhamp> @pl length(elemIndices)
04:44:48 <lambdabot> length elemIndices
04:45:07 <ordwidr> cale: the whole picture is that I want to explore how a patch system on a relation data store can look like. For this I need a datastore first ;-)
04:45:26 <Cale> Basically, you have to make a decision: explicitly represent the things which are available (hard to extend and work with) and have it be easy to serialise, or implicitly represent them with functions (making it easy to extend and work with), and have it be hard to serialise
04:45:44 <ordwidr> cale: all patch systems I read about are either on files (think darcs / camp) or text editors (collaborative editing)
04:45:46 <Cale> Well, when I say the first is hard to work with, it's relative.
04:46:17 <ordwidr> cale: how can a function based representation look like?
04:46:50 <Cale> For validators? Basically just  Data -> Bool  for whatever type you choose for your data.
04:47:07 <Cale> But you can't serialise functions.
04:47:36 <Cale> So if you want to store the information to disk, you need to represent the available options explicitly
04:47:56 <Cale> Otherwise, how the hell is your parser going to know what it's reading? :)
04:48:33 <Cale> Well, it would be nice to be able to take a chunk of machine code representing a function and serialise it, but that wouldn't be so portable then.
04:48:38 <ordwidr> cale: validators is clear. but at runtime the available validators are fixed. the set of validators shall be open at compile type. they shall be parametrized over  maxlength at runtime but the functions and how to apply them is specified at runtime. of courese.
04:48:41 <boegel> is someone here familiar with using microbench?
04:49:16 <osfameron> I asked a while back if you could write a curried lambda as a monad:
04:49:17 <ordwidr> cale: I can use type classes
04:49:21 <boegel> I'm trying to benchmark different implementations of a simple function which takes two lists of Double as input parameters, but I can't seem to get around GHC's smartness
04:49:22 <osfameron> but I didn't explain my question very well
04:49:42 <osfameron> I was wondering if you could write: f a b = a + b  as something like: f = do { a <- getParam; b <- getParam; return a+b }  ?
04:49:44 <ordwidr> cale: which define String -> Validator
04:49:45 <Cale> ordwidr: Why do you insist on them being open at compile time? Is adding cases to a data-declaration and then to the various functions which need them so bad?
04:50:06 <Gracenotes> osfameron: looks dangerous :O
04:50:13 <osfameron> currying seems to be monadic
04:50:21 <osfameron> in that it takes a layer of a sub off at each parameter...
04:50:26 <ordwidr> cale: so basically because I don't understand why haskell makes it so hard to have an open type system whereas java e.g. gives it for free.
04:50:41 <Cale> ordwidr: The problem with open datatypes is that functions which operate on them are more or less always incomplete, unless they have a fall-through case which usually does something useless.
04:50:44 <Gracenotes> well. the layers you take off are meticulously checked by the type system
04:50:53 <boegel> I need to come up with a function of type "Int -> a", which uses the first argument as the number of times to apply my function on some input
04:50:54 <dibblego> osfameron, ((-> t) is a monad
04:51:11 <Cale> ordwidr: Java makes an opposite tradeoff to Haskell on this point. It forces you to fix the set of functions which are available.
04:51:12 <dibblego> boegel, replicateM perhaps?
04:51:18 <boegel> the problem is to avoid GHC from optimizing away the n applications, i.e. to give it different data each time
04:51:25 <osfameron> I prototyped something for it in Perl: http://github.com/osfameron/acme--monads/blob/master/t/04_curry.t (of course that doesn't have the strong typing issue)
04:51:32 <ordwidr> cale: I see. So with closed datatype you're safe in a sense of completion of function definition
04:51:35 <burp_> @src sum
04:51:36 <lambdabot> sum = foldl (+) 0
04:51:37 <osfameron> dibblego: and can you use (-> t) in the way I was suggesting?
04:51:38 <boegel> I don't want to benchmark the data generation too
04:51:40 <burp_> why doesn't sum use foldl'?
04:51:49 <Cale> ordwidr: And you can always add new functions to operate on the existing data.
04:51:53 <dibblego> osfameron, you can use it in do-notation at least
04:51:55 <burp_> is there any reason I might want sum lazy?
04:51:57 <osfameron> (the reason being I'm wondering what the best way to implement currying lambdas is, while I try to do it in Perl)
04:52:01 <MiniBob> burp_: because if it doesn't, it can generate numbers lazily
04:52:11 <MiniBob> for lazy numeric types, like church encoded naturals
04:52:14 <boegel> dibblego: will that avoid GHC from optimizing away n applications of a function to identical parameters each time?
04:52:19 <burp_> ok
04:52:21 <dibblego> @type \f g a -> f a + g a -- osfameron
04:52:22 <MiniBob> and then you can do < and > lazily on them
04:52:22 <lambdabot> forall t a. (Num a) => (t -> a) -> (t -> a) -> t -> a
04:52:44 <dibblego> oops
04:53:01 <dibblego> @pl \f g a -> f a + g a -- osfameron
04:53:01 <lambdabot> liftM2 (+)
04:53:13 <ultrakrankerhamp> @pointful length(elemIndices x xs)
04:53:13 <lambdabot> length (elemIndices x xs)
04:53:30 <dibblego> boegel, no, perhaps you want memoisation?
04:53:38 <ultrakrankerhamp> @pointless length(elemIndices x xs)
04:53:38 <lambdabot> length (elemIndices x xs)
04:53:42 <Cale> ordwidr: If I want to extend the set of methods which an object class has, then it's a pain, because I have to update all the subclasses with implementations of those methods. But if I add a new subclass there's no extra work.
04:53:52 <boegel> dibblego: I think I want to _avoid_ memoisaition, just to benchmark my function
04:54:02 <dibblego> boegel, Haskell does not memoise
04:54:07 <boegel> dibblego: I want to apply my function to some paramters n times, just to see how long it takes
04:54:12 <ordwidr> cale: Thats an interesting insight
04:54:25 <boegel> dibblego: ok, then I guess I don't know what memoisation is exactly :)
04:54:26 <Cale> ordwidr: This is somewhat dual to what we have in Haskell -- if I want to add a new case to a datatype, it's a pain, because I have to modify all the functions I've written to operate on it.
04:54:29 <osfameron> dibblego: ok.. you've lifted addition to 2 monad constructors f and g?
04:54:34 <dibblego> ordwidr, you can emulate closed data types in Java using a little known trick
04:54:35 <Cale> But if I want to add new functions, it's easy.
04:54:45 <ordwidr> dibblego: say
04:54:54 * ordwidr knows all java type system tricks 
04:54:57 * ordwidr perhaps
04:55:03 <boegel> dibblego: is it remembering the result of a function when it was applied to certain parameter values, so it won't be computed twice?
04:55:18 <Cale> ordwidr: So, Haskell and Java take two opposite approaches to this, which is also known as the expression problem.
04:55:20 <dibblego> osfameron, that's just a simple use of the ((->) t) monad
04:55:32 <dibblego> boegel, yes
04:55:53 <ordwidr> cale: I'll never would have thought that I will develope such a strong passion to type theory at some time
04:55:55 <dibblego> ordwidr, I bet not :)
04:55:58 <osfameron> dibblego: ah... ok, but it doesn't do the thing I'm playing with (i.e. reading a parameter and returning the next layer of monad) ?
04:56:15 <ordwidr> dibblego: would you mind to enlight me?
04:56:20 <boegel> dibblego: hmm, k
04:56:30 <dibblego> osfameron, it's not clear to me what you're trying to do -- so I'm just postulating possibilities
04:56:39 <dibblego> ordwidr, on what exactly?
04:56:47 <boegel> @hoogle replicateM
04:56:47 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
04:56:47 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
04:56:48 <ordwidr> the not well know trick
04:57:32 <Cale> ordwidr: I've never seen a programming language which doesn't make this tradeoff in one way or the other. I think closed datatypes / open methods is somewhat characteristic of FP, while open datatypes / closed methods is more characteristic of OO.
04:57:53 <dibblego> ordwidr, I used to have a Java trivia website -- here is a question: true or false a class with only private constructors can have no subclasses
04:58:30 <osfameron> dibblego: the example I had was something like: f = do { a  <- getParam; b <- getParam; return a+b }
04:58:46 <ordwidr> dibblego: true
04:58:51 <osfameron> dibblego: getParam takes a parameter and returns a function with the next layer
04:59:02 <boegel> dibblego: suppose I have a function f with result type 'IO Double', would "replicateM (f a b) 100" produce a list of 100 applications of that function, or would it produce a list of 100 results of the application of that function?
04:59:07 <Cale> dibblego: 'can have no subclasses' or 'can not have subclasses'?
04:59:17 <osfameron> the perl prototype of that approach "works" though it probably isn't well-grounded theoretically...
04:59:18 <dibblego> osfameron, what is the type of getParam?
04:59:22 <ordwidr> cale: where's the difference?
04:59:39 <dibblego> ordwidr, it is false
04:59:48 <ordwidr> dibblego: i forgot the default constructor
04:59:57 <Cale> ordwidr: well, I'd read the first as meaning that it's okay for it not to have any subclasses.
04:59:59 <ordwidr> dibblego: if it's false, the yes
05:00:03 <dibblego> ordwidr, that doesn't change anything
05:00:07 <osfameron> dibblego: in this case Int... so I guess, um, (->a) ?   In the same way as reader/state getting functions can return different types
05:00:27 <osfameron> hmmm, I should write this up to see if I can explain it any better
05:00:33 <Cale> and the second as meaning that it's not okay for it to have any subclasses
05:00:36 <ordwidr> dibblego: really? And a not default private consturctor?
05:00:37 <dibblego> osfameron, please do I'm foncused :)
05:00:48 <osfameron> hehe
05:01:08 <ordwidr> dibblego: beside the trivia where's the type system trick?
05:01:32 <ordwidr> dibblego: close types in java
05:01:39 <dibblego> ordwidr, a default constructor has the access of the enclosing class -- this does not alter anything
05:01:39 <dibblego> @where Functional Java
05:01:40 <lambdabot> I know nothing about functional.
05:01:42 <dibblego> @where FunctionalJava
05:01:42 <lambdabot> http://functionaljava.org/
05:01:58 <dibblego> ordwidr, a class with only private constructors can be subclassed by nested classes
05:02:12 <dibblego> ordwidr, this way, you can emulate closed types (Functional Java does this)
05:02:20 <ordwidr> dibblego: ouch
05:02:37 <Cale> Oh, neat trick :)
05:02:42 <Ferdirand> dibblego: ooh, cute
05:02:43 <ordwidr> dibblego: I see. Like enums
05:02:58 <dibblego> ordwidr, yes but with differing constructor arguments
05:03:07 <ordwidr> dibblego: altough I failed on the trivia I used this "trick" before
05:03:42 <dibblego> ordwidr, for more kicks and giggles with Java's type system, Functional Java has a heterogeneous list
05:04:41 <ordwidr> dibblego: I decided to learn haskell to escape from java's weired type system :-)
05:04:51 <dibblego> ordwidr, I highly recommend it :)
05:06:23 <ordwidr> I designed a table api like we discues before in java. I ended with interfaces parametrized on itself on to other types which are each parametrized on itself and the other to types. Like Enume<E extends Enum>> on crack.
05:06:26 <Cale> dibblego: ahaha, you've found something even worse than the type-level computation in Haskell
05:06:50 <Athas> Is there a standard map function with its arguments reversed?
05:06:53 <Athas> That is, forM without the M.
05:06:55 <ordwidr> Now I learn that in haskell land is forbidding for types to be on crack.
05:06:55 <Cale> flip map
05:07:01 <burp_> is there any good vector / matrix library?
05:07:02 <Cale> oh
05:07:03 <Gracenotes> Athas: no alas
05:07:05 <Athas> So no standard name.
05:07:08 <Cale> no
05:07:13 <Cale> (that's right)
05:07:14 <Athas> As Cale remarks, very easy to make myself, so no biggie.
05:07:36 <Gracenotes> "for" might be a bit of a deceptive name for it...
05:07:38 <Cale> burp_: hmm, you might try hmatrix
05:07:57 <Cale> burp_: I haven't really used it, but it looks like a fairly detailed binding to GSL.
05:07:58 <burp_> ok
05:07:59 <Gracenotes> "for" generally implies the imperative construct, with side effects and all. That's more forM_'s business
05:08:30 <Cale> burp_: There are a few other linear algebra libraries on Hackage as well...
05:08:34 <Gracenotes> mapWith, maybe
05:08:54 <Gracenotes> or... mapTo
05:08:59 <Gracenotes> dunnos.
05:12:01 <LeCamarade> Does GHC's PRNG (StdGen) use the Mersenne Twister?
05:12:06 <quicksilver> no.
05:12:10 <quicksilver> it's a naive linear congruence.
05:13:12 <Cale> It annoys me that the various other implementations of random number generators on Hackage don't even try to be instances of RandomGen
05:13:35 <quicksilver> there's an issue with mersenne twister and 'split' isn't there?
05:13:44 <Cale> I can't imagine what it would be
05:14:06 <yitz> quicksilver: it's not a naive linear congruence. but it's not as good as MT either.
05:14:10 <Cale> It seems you could write a reasonably decent split for any random generator which can be seeded randomly.
05:15:06 <Cale> To do a split, just generate two Word32's, and use those as your new seeds?
05:15:21 <quicksilver> well that's reducing the state space dramatically
05:15:31 <quicksilver> which is compromising the things which presumably make this generator good
05:15:39 <Cale> Does it?
05:15:50 <Cale> hmm
05:16:01 <quicksilver> that squeezes the state space through a hole only 2^32 wide.
05:16:10 <quicksilver> when it's supposed to be 2^256 or something.
05:16:42 <Cale> Then why doesn't it have a larger seed, I wonder?
05:16:45 <yitz> System.Random uses a generator by L'Ecuyer, which is designed better for functional use.
05:16:58 <yitz> but it's an older version - he has a newer one that is much better
05:17:05 <yitz> and more splittable
05:17:33 <yitz> probably as good or better than Mersenne
05:17:38 <Cale> oh, apparently  newMTGen  is broken.
05:17:44 <dibblego> ordwidr, Haskell is a stark contrast to Java with respect to its type system -- far far far less handwaving
05:17:50 <Cale> That would be a problem.
05:18:37 <quicksilver> yitz: interesting.
05:18:51 <Cale> ordwidr: If it's any consolation about open types being a pain, you can follow the convention of trying to always add fall-through cases to your functions at the bottom, after having handled all existing cases.
05:19:14 <Cale> ordwidr: That way, adding a new case to the data declaration hopefully won't cause them all to break.
05:19:26 <timbod> Does anyone else find nested folds need slightly too much brain effort to write?
05:19:32 <quicksilver> timbod: yes.
05:19:33 <Cale> We do need a proper extensible record and variant system though.
05:19:42 <Cale> Nested folds?
05:19:51 <quicksilver> timbod: I always factor the inner one out and give it a name.
05:19:59 <quicksilver> timbod: otherwise my head explodes all over the monitor.
05:20:14 <Cale> yeah, usually it deserves a name anyway
05:20:18 <mhb> Hello, I have a IO related question... have a function parsing a String into [Integer], and I need to write a simple function that uses getLine to read a line from the input, trigger the parsing function I mentioned earlier, and return the result. However, it's the action world and I have no idea what type should the returned value be and how to accomplish my task without changing the first non-IO function. Could someone give me a hint, please?
05:20:20 <burp_> basically I have to decide between hmatrix and numeric-prelude, let's see
05:20:24 <timbod> Yes - I seem to have to give each inner one a name, write it's type, and then fill it it
05:20:43 <Cale> mhb: It'll look something like...
05:20:58 <burp_> I guess hmatrix is faster because of gsl, blas, lapack backend
05:21:05 <Cale> do x <- getLine; return (myParser x)
05:21:14 <Cale> mhb: that is, if you don't want to just print it
05:21:16 <timbod> Cale - I'm not so sure the inner ones needing a name - in an imperative world, I wouldn't need to give each nested loop a name.
05:21:35 <Cale> mhb: The type of that will be  IO [Integer]
05:21:45 <timbod> (I seem to end up calling them f, g, h anyway)
05:21:52 <mhb> Cale: thank you!
05:22:27 <Cale> mhb: It's also possible to write that as   fmap myParser getLine
05:23:26 <Cale> timbod: Well, that's true...
05:23:34 <EvilTerran> mhb, note that, in that line, myParser :: String -> [Integer]
05:23:39 <Cale> timbod: I have no problem with nested forM's
05:23:48 <timbod> I was wondering on the say home if an a version of foldr  with different arg ordering would nest better: foldr' :: a (a -> b -> b) [b]
05:24:13 <Cale> timbod: That's probably the case. It's somewhat more natural as an arg ordering anyway
05:25:16 <Cale> Having a big lambda followed by a small initial element is awkward.
05:25:22 <timbod> oops, meant: foldr :: [a] -> (a->b->b) -> b -> b
05:25:23 <quicksilver> timbod: you can always change a foldr into a forM over some monad or other.
05:25:26 <Cale> oh
05:25:27 <quicksilver> and forM's nest better :)
05:25:34 <Cale> like that...
05:26:02 <Cale> Well, that one would be less useful, since it's usually the list which changes between calls
05:26:41 <twanvl> to me the most natural is   foldr :: (a -> b -> b) -> ([a] -> b -> b)
05:27:03 <ski> @let foldrUsingState cons as = State (\nil -> ((),foldr (evalState . cons) nil as))
05:27:04 <lambdabot>  Defined.
05:27:07 <ski> @type foldrUsingState
05:27:09 <lambdabot> forall a s. (a -> State s s) -> [a] -> State s ()
05:27:54 <ski> this is just `mapM_', right ?
05:28:11 <timbod> I think that's what I getting at - if you are using fold over a big structure to accumulate some state, it's convenient to have the state as the last argument.
05:28:26 <ski> actually, s/eval/exec/
05:28:32 <Cale> hmm
05:28:37 <Cale> Not the function?
05:28:40 <ski> @let foldrUsingState cons as = State (\nil -> ((),foldr (execState . cons) nil as))
05:28:41 <lambdabot>  Defined.
05:28:44 <ski> @type foldrUsingState
05:28:45 <lambdabot> forall a1 s a. (a1 -> State s a) -> [a1] -> State s ()
05:29:06 <ski> @type (mapM_ :: (a -> State s b) -> ([a] -> State a ()))
05:29:07 <lambdabot>     Couldn't match expected type `s' against inferred type `a'
05:29:07 <lambdabot>       `s' is a rigid type variable bound by
05:29:07 <lambdabot>           the polymorphic type
05:29:12 <ski> er
05:29:14 <ski> @type (mapM_ :: (a -> State s b) -> ([a] -> State s ()))
05:29:15 <lambdabot> forall a s b. (a -> State s b) -> [a] -> State s ()
05:29:19 <Cale> Usually my problem with nesting folds is that you have a big lambda somewhere that doesn't fit, and makes the expression hard to read. If it was at the end, it wouldn't be such a problem.
05:29:49 <halcyon10> hi all, i've written a simple program that's intent is to change the endianness of a file by swaping pairs of bytes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4419#a4419 now i'd like to write an equivalent program using ByteStrings. Is there a similar way to do the patternmatching (x:y:xs) as in my String-based program or what would be the best way to achieve this?
05:30:21 <Cale> Well, I really must get some sleep :)
05:30:23 * ivanm has never used bytestring, but doesn't recall any pattern matching stuff from when he read about them in RWH...
05:30:27 <LeCamarade> How do I import qualified Data.Map as DM in GHCi, again?
05:30:29 <ivanm> Cale: sleep is a good idea...
05:30:31 <ivanm> @time Cale
05:30:32 <lambdabot> Local time for Cale is Thu Apr 30 08:30:31
05:30:37 <Cale> :]
05:30:42 <ivanm> Cale: isn't it about time you got up anyway? :s
05:30:43 <LeCamarade> :-o
05:30:52 <Cale> heh, yes
05:30:52 <LeCamarade> Cale! That's illegal!
05:31:05 <ivanm> Cale: you're even worse than pumpkin! :o
05:31:05 <Cale> LeCamarade: sleeping?
05:31:10 <LeCamarade> Tomorrow's Labour Day in me country, so I can just hang out.
05:31:13 <ski> > foldrUsingState (\a -> modify (reverse a :)) ["hello","world"] `evalState` ["the","end"]
05:31:14 <LeCamarade> Cale, Yes.
05:31:15 <lambdabot>   ()
05:31:19 <ski> > foldrUsingState (\a -> modify (reverse a :)) ["hello","world"] `execlState` ["the","end"]
05:31:20 <lambdabot>   Not in scope: `execlState'
05:31:23 <LeCamarade> How do I import qualified Data.Map as DM in GHCi, again?
05:31:24 <ski> > foldrUsingState (\a -> modify (reverse a :)) ["hello","world"] `execState` ["the","end"]
05:31:25 <lambdabot>   ["olleh","dlrow","the","end"]
05:31:26 <ivanm> LeCamarade: on a Friday? :s
05:31:31 <ivanm> we have it on a Monday...
05:31:32 <ski> > mapM_ (\a -> modify (reverse a :)) ["hello","world"] `execState` ["the","end"]
05:31:34 <lambdabot>   ["dlrow","olleh","the","end"]
05:31:41 <timbod> I' just pasted an ugly multi level fold to hpaste: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4420#a4420
05:32:09 <ski> ok, so the `mapM_' corresponds to a `foldl' not a `foldr'
05:32:09 <timbod> as  an example that wasn't easy to write, and isn't that easy to read either :-(
05:33:16 <QtPlaty[HireMe]> :info foldrUsingState
05:33:34 <LeCamarade> ivanm, Yeah. :o) Thank God It's Thursday!
05:33:55 <LeCamarade> My country has the highest alcohol consumption per capita, and it's because of days like these.
05:34:22 <quicksilver> :t \commodity -> foldr (\a -> (commodity a:))
05:34:23 <lambdabot> forall a a1. (a -> a1) -> [a1] -> [a] -> [a1]
05:34:26 <ski> QtPlaty[HireMe] : i defined it just above
05:34:27 <Gracenotes> @type (foldr . foldr)
05:34:28 <lambdabot> forall a. (a -> [a] -> [a]) -> [a] -> [[a]] -> [a]
05:34:41 <Gracenotes> @type (foldl . foldl)
05:34:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [[b]] -> a
05:34:44 <quicksilver> timbod: that third foldr is a map, isn't it?
05:34:51 <ivanm> LeCamarade: which country is this?
05:35:08 <LeCamarade> http://en.wikipedia.org/wiki/List_of_countries_by_alcohol_consumption
05:35:13 <LeCamarade> Yay!
05:35:21 <rabideejit> halycon10: you certainly could do that with bytestrings, but be aware that cons using bytestrings is O(n) because it does a memcpy - you'd be better writing the results directly to a handle, instead of joining them together in memory
05:35:21 <quicksilver> foldr (\a -> (commodity a:)) cs (unMixedAmount $ tamount r) is "map commodity (unMixedAmount $ tamount r) ++ cs"
05:35:26 <McManiaC> @pl \x -> (f x) / (g x)
05:35:26 <lambdabot> liftM2 (/) f g
05:35:27 <ivanm> LeCamarade: uganda? :s
05:35:39 <LeCamarade> But the Ministry of Health is trying to control things.
05:35:44 <LeCamarade> ivanm, Yes. :o)
05:35:52 <ivanm> hmmmm.... we're only 37th... thought we'd have been higher...
05:36:18 <Gracenotes> England beats you pretty well
05:36:20 <LeCamarade> Yeah, AU should be higher.
05:36:22 <ivanm> LeCamarade: http://en.wikipedia.org/wiki/List_of_countries_by_beer_consumption_per_capita
05:36:23 <ivanm> ;-)
05:36:29 <ivanm> ^^ we're pretty high here ;-)
05:36:47 <ivanm> since most aussies drink either beer or wine, rather than spirits (they drink spirits, just not as much)
05:36:54 <Gracenotes> oh, AU beats UK there
05:37:21 <LeCamarade> Heh. :o) We've vanished of that list!
05:37:26 <ivanm> that's not taking the alcoholic content of beer into account though
05:37:35 <ivanm> LeCamarade: just pure raw spirits?
05:37:36 <ordwidr> ivanm: good point
05:37:54 <LeCamarade> But most people here swill hard, hard liquours. Barely healthy.
05:38:03 <ordwidr> ivanm: http://en.wikipedia.org/wiki/List_of_countries_by_alcohol_consumption
05:38:03 <ivanm> australia has been going more towards light beers recently, or else mid-strengths like XXX Gold rather than heavies
05:38:13 <ivanm> ordwidr: LeCamarade has already linked that ;-)
05:38:20 <ordwidr> I see
05:38:41 <timbod> quicksilver, ah yes it is a map, thanks.
05:39:02 <tux-foo> Should x::Double not cast x to a double, given it is an Integer ?
05:39:05 <McManiaC> > sum (liftM2 (/)) length $ [1..5]
05:39:06 <lambdabot>   Couldn't match expected type `[a]'
05:39:28 <quicksilver> timbod: aside of that, I think it would indeed be clearer if you'd chosen better names than 'f1' and 'f2'
05:39:32 <quicksilver> tux-foo: no.
05:39:36 <quicksilver> tux-foo: :: does not cast.
05:39:42 <quicksilver> tux-foo: it merely annotates the type.
05:39:51 <tux-foo> quicksilver, I was afraid of that
05:39:52 <quicksilver> tux-foo: if you have contradictory annotations, you get an error.
05:39:57 <quicksilver> > (1 :: Int) :: Double
05:39:58 <lambdabot>   Couldn't match expected type `Double' against inferred type `Int'
05:40:14 <quicksilver> tux-foo: if you want to convert an int to a double, use 'fromIntegral'
05:40:15 <tux-foo> quicksilver, how can I cast to a double from an int?
05:40:18 <tux-foo> ah
05:40:31 * quicksilver scores 1 point for 'answering question before it is asked'.
05:40:48 <Gracenotes> what did quicksilver score 1 point for?
05:40:55 <quicksilver> > (fromIntegral (1 :: Int)) :: Double
05:40:56 <lambdabot>   1.0
05:41:07 <timbod> yes - perhaps it's laziness, but all I'm doing it work my way around a structure, accumulating specific values. Naming the processor for each part of the structure seeemed unnecessary.... but perhaps it would be worth it for clarity.
05:41:09 <yitz> quicksilver++
05:41:29 <ordwidr> yitz: quicksilver is not mutable
05:41:41 <yitz> @karma quicksilver
05:41:42 <lambdabot> quicksilver has a karma of 9
05:41:51 <LeCamarade> I'll learn the Cabal motions when I release the Twitter API some time next week.
05:41:55 <LeCamarade> :o)
05:41:59 <quicksilver> timbod: would make it easier to read. May not make it easier to write ;)
05:42:10 <LeCamarade> Cabal and Hackage motions.
05:42:41 <yitz> timbod: laziness is a valued quality around here
05:43:25 <timbod> yitz: I think you'd qualify that, wouldn't you?
05:44:53 <timbod> laziness in evalation is sometime good, somtimes irritating. laziness on the part of a developer the same.
05:50:55 <Twey> So, when do we get to see (??) in mainstream Haskell?  :-P
05:51:27 <Twey> More often good than irritating, I think
05:51:43 <quicksilver> (??) ?
05:52:04 <gnuvince> Probably an asian smiley
05:52:38 <Gracenotes> ( ï¾Ÿ ãƒ®ï¾Ÿ)
05:52:40 <Twey> (y ?? n) p = if p then y else n
05:53:07 <Gracenotes> also known as 'bool'
05:53:24 <quicksilver> I've never felt the lack, really.
05:53:28 <Twey> It's one of the functions from chrisdone's higher-order booleans library that I find very handy and keep copy-pasting
05:54:34 <Twey> It's so handy to do things like map ('O' ?? 'X') [True, False, False, True, True, False, True]
05:55:52 <pozic> How does scalar multiplication work in Data.Vec?
05:55:54 <ivanm> > let (y ?? n) p = if p then y else n in  ('O' ?? 'X') [True, False, False, True, True, False, True]
05:55:55 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[a]'
05:56:05 <ivanm> > let (y ?? n) p = if p then y else n in map ('O' ?? 'X') [True, False, False, True, True, False, True]
05:56:06 <lambdabot>   "OXXOOXO"
05:56:19 * ivanm doesn't get what that's supposed to be...
05:56:48 <Twey> @let (y ?? n) p = if p then y else n
05:56:49 <lambdabot>  Defined.
05:57:16 <Twey> It's a string of Xs and Os.
05:57:36 <Twey> It was useful in something I was doing before.  *shrugs*
05:57:45 * quicksilver nods
05:57:47 <quicksilver> I can see that.
05:58:01 <quicksilver> I'd probably be more likely to define it prefix as 'bool' though.
05:58:17 <Twey> Anyway, it's a much handier way of solving the old why-isn't-if-a-function problem than if'
05:58:36 <Twey> There's a bool in there too
05:58:39 <quicksilver> yes, it seems nicer than if'
05:58:54 <Twey> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/higherorder
05:59:16 <ivanm> quicksilver: if' can also be handy
05:59:16 <Twey> Ah, bool is used for something else
05:59:21 <Twey> http://hackage.haskell.org/packages/archive/higherorder/0.0/doc/html/Data-Bool-Higher.html
05:59:26 <quicksilver> I have never found if' handy.
05:59:27 <Twey> bool :: (a -> b) -> (a -> b) -> (a -> Bool) -> a -> b
05:59:33 <Twey> I have never found if' handy
05:59:39 <ivanm> quicksilver: as a shortened form of normal if
05:59:44 <Gracenotes> Twey: ugh. don't like that definition :/
05:59:44 <ivanm> though I've never really used it either
05:59:48 <Twey> ivanm: But the arguments are all in the wrong order
05:59:55 <ivanm> Twey: in what sense?
05:59:56 <ivanm> @type if'
05:59:58 <lambdabot> Not in scope: `if''
06:00:01 <Gracenotes> I suppose it works though
06:00:07 <Gracenotes> by bool I mean a -> a -> Bool -> a
06:00:17 <ivanm> if' :: Bool -> a -> a -> a
06:00:20 <Twey> Using it usually involves either a lambda or an awful lot of flips
06:00:23 <ivanm> oh, whoops, I meant Gracenotes, not Twey
06:00:32 <quicksilver> Gracenotes's bool is the one I meant.
06:00:40 <Gracenotes> I know. the @pl version
06:00:54 <Twey> ivanm: Because currying on the â€˜elseâ€™ branch isn't very useful
06:01:20 <Twey> Most of the time, you want to be able to curry on the predicate
06:01:31 <ivanm> Twey: *shrug* most of my if-statements are pretty much "hard-coded" (as in not obtained from a list or something)
06:01:44 <Gracenotes> I don't particularly like the functionful definition of bool because there's no data per se to extract
06:01:50 <ivanm> Twey: do you? I can see you currying on the (then,else) stuff...
06:01:53 <yitz> timbod: I think you have something like: commods = concat [map commodity . unMixedAmount . tamount $ t | t <- etransactions e, e <- es]
06:02:03 <Gracenotes> with maybe or either, the data is passed to the function by removing the constructor
06:02:06 <ivanm> or do you mean having a default Else, and currying on the predicate and the then?
06:02:26 <Gracenotes> for Bool, no such constructor exists, and it's more of a choice function than anything. but.. I guess that's the point
06:02:30 <yitz> timbod: or: commods = es >>= etransactions >>= map commodity . unMixedAmount . tamount
06:02:39 <ivanm> Gracenotes: which definition? bool t e p = if p then t else e ?
06:02:48 <Gracenotes> no, the one with (a -> b) .. etc.
06:02:55 <ivanm> oh? which is that?
06:03:02 <ivanm> or are you referring to Church Booleans?
06:03:03 <ivanm> @hoogle bool
06:03:04 <lambdabot> module Data.Bool
06:03:04 <Gracenotes> Twey quoted the type above
06:03:04 <lambdabot> Prelude data Bool
06:03:04 <lambdabot> Data.Bool data Bool
06:03:20 <Gracenotes> I'd rather use bool on a function and then apply that
06:03:31 <ivanm> yeah..
06:03:49 <ivanm> I can see that bool being useful, but I usually have an else I want to apply rather than using a function
06:04:32 <Gracenotes> blah f x p = if p then x else f x?
06:04:56 <ivanm> Gracenotes: hmmm?
06:05:04 <Gracenotes> is that what you mean?
06:05:12 <timbod> yitz: what does this mean:   [x | x <- f b, b <= bs]  ??
06:05:30 <yitz> s/<=/<-/
06:05:31 <ivanm> I meant that I use standard if, rather than having my then and else branches being function application
06:05:42 <timbod> Is it the same as [ f b | b <- bs ]
06:05:45 <Gracenotes> timbod: <= is less than
06:05:50 <Gracenotes> @type (<=)
06:05:51 <lambdabot> forall a. (Ord a) => a -> a -> Bool
06:05:59 <ivanm> timbod: no, it's the same as: concat [ f b | b <- bs]
06:06:24 <yitz> timbod: it means iterate x over f b, and for each x iterate b over bs
06:06:27 <Gracenotes> ... if bs is a list, <- would make more sense. If it's a number, then interpret it as-is
06:06:35 <ivanm> Gracenotes: it's a list
06:06:43 <Gracenotes> aight, if you're sure
06:06:46 <timbod> <= was a typu
06:06:47 <ivanm> it's a type
06:06:47 <yitz> so oops let's fix that:
06:06:50 <ivanm> *typo
06:06:56 <timbod> :-)
06:07:07 <yitz> timbod: I think you have something like: commods = concat [map commodity . unMixedAmount . tamount $ t | e <- es, t <- etransactions e]
06:07:09 <Twey> ivanm: I've never curried on the then or the else branches, I have to say
06:07:25 <burp_> > MathObj.PowerSeries.approx [1,2,3] 4
06:07:27 <lambdabot>       Failed to load interface for `MathObj.PowerSeries':
06:07:27 <lambdabot>        Use -v to se...
06:07:30 <burp_> ok
06:07:30 <ivanm> Twey: I've never curried on any if usage ;-)
06:07:37 <ivanm> I prefer using guards or pattern matching
06:07:37 <Twey> Gracenotes: In the â€˜functionfulâ€™ definition, there *is* data to extract
06:07:41 <ivanm> I try to avoid if and case
06:08:04 <ski> timbod : list monad action / comprehension <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4420#a442>
06:08:08 <Twey> Although it's not directly from the bool, obviously
06:08:25 <Twey> Personally I would have named that bool boolOn or something
06:09:25 <yitz> ski: ok, much better
06:09:55 <timbod> ski - awesome - that is so much tidier. I think I need to revisit list comprehensions.
06:10:26 <yitz> timbod, ski: commods = es >>= etransactions >>= unMixedAmount . tamount >>= commodity
06:12:19 <timbod> I'd seen this sort of thing before: [ (x,y) | x <- xs, y <- ys], but not as you have it with the dependencies between the clauses.
06:12:46 <yitz> timbod: welcome to the list monad
06:12:50 <ski> yitz : i was trying to preserve timbod's variable names `e',`r',`a', instead of doing it pointless style .. but sure .. if timbod likes that better :)
06:13:14 <ski> > [(x,y) | x <- [0..3] , y <- [0..x]]
06:13:15 <lambdabot>   [(0,0),(1,0),(1,1),(2,0),(2,1),(2,2),(3,0),(3,1),(3,2),(3,3)]
06:13:21 <yitz> ski: absolutely. c or commod will probably be better than foo
06:13:45 <timbod> ski: that was almost exactly the test case I just tried...
06:14:27 <ski> hm
06:14:29 <ski> actually
06:15:24 <ski> i might have made a mistake with `commodity'
06:15:25 * ski ponders
06:15:42 <ski> (you know, this would be easier if i had the types of the used operations)
06:16:10 <quicksilver> infer them!
06:16:11 <quicksilver> ;)
06:16:31 <ski> (the mistake, if any, would be that instead of `foo <- commodity a' i should have `foo <- return (commodity a)' i.e. `let foo = commodity a')
06:16:43 <yitz> quicksilver: we've long learned to be too lazy for that.
06:17:05 <yitz> ski: no, I think it's [commodity a | ...
06:17:20 <yitz> ah, right
06:17:21 <ski> yitz : yes, that's the same as what i said :)
06:17:49 <ski> [foo | ... , let foo = commodity a]  =  [commodity a | ...]
06:18:09 <yitz> so: commods = map commodity $ es >>= etransactions >>= unMixedAmount . tamount
06:19:07 <timbod> Yes - it needs the let rather than the bind.
06:19:18 <timbod> (Compiles fine, btw)
06:19:38 <Baughn> If GHC can prove that () is () and not, for example, bottom - does it ever optimize it to a 0-bit representation?
06:20:00 <timbod> yitz, ski: thanks to you both - I really was just complaining about nesting folds, I didn't expect to learn a new trick.
06:22:04 <Botje> Baughn: then [()] would be a list of pointers ? that would be cool  :P
06:22:31 <timbod> And I think I like the (pointed) monadic version the best.
06:23:22 <Baughn> Botje: Well, it already is,really..
06:23:34 <Baughn> Botje: But it /could/ be optimized to an Int. :P
06:23:38 <Botje> ;)
06:24:17 <quicksilver> Baughn: hmm. Well if the pointer is never followed it doesn't matter too much that it exists ;)
06:24:18 <Botje> it would be pretty impressive to have GHC see "oh, but this list is just a silly encoding of Peano numbers. let me optimize that for you."
06:24:34 * Twey laughs.
06:26:46 <ski> timbod : fixed <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4420#a4424>
06:27:43 <vixey> omg I accidenaly hacked the matrxi
06:27:47 <ski> (you probably already fixed it yourself .. i just wanted to be complete in the paste)
06:27:47 <vixey> http://hpaste.org/fastcgi/hpaste.fcgi/del_annot
06:28:36 <yitz> vixey: cool
06:28:38 <Baughn> "Irssi: Pasting 368 lines to #haskell. Press Ctrl-K if you wish to do this Ctrl-C to cancel." <-- *phew*
06:29:05 * ski leaves for a while
06:29:32 <yitz> irssi++
06:29:33 <vixey> Vodka: Explaining 20 years of life story to all your friends. Press Ctrl-K if you wish to do this Ctrl-C to cancel
06:29:53 <ray> ctrl-k! ctrl-k!
06:30:48 <mmorrow> , vacuum ((),[(),(),(),(),(),()])
06:30:52 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[1,6]),(6,[1,7]),(7,[1...
06:33:38 <Botje> .. what?
06:33:52 <Botje> did those () absorb values from memory or something?
06:34:39 <vixey> , vacuum (0::Int,[0,0,0,0,0,0::Int])
06:34:41 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
06:34:52 <burp_> ,src vacuum
06:34:53 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
06:35:02 <trofi^w> what's vacuum?
06:35:41 <edwardk> Baughn: actually its not quite the same, mainly because it has an infinite element and you can compare lists with bottoms in them for inequality, etc.
06:36:13 <edwardk> trofi^w: vacuum takes structures in memory and tells you what links to what and how
06:36:27 <edwardk> trofi^w: you can use it to graph how data structures are connected
06:36:53 <Saizan> , vacuum "hello"
06:36:55 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
06:37:00 <trofi^w> whow, how does it that? does it compare GHC# internal refs?
06:37:03 <burp_> , vacuum 1+1
06:37:05 <lunabot>  luna: No instance for (GHC.Num.Num [(GHC.Types.Int, [GHC.Types.Int])])
06:37:09 <edwardk> trofi^w: yeah
06:37:23 <doserj> , vacuum (1+1)
06:37:24 <trofi^w> sounds very cool :]
06:37:25 <lunabot>  [(0,[])]
06:38:13 <edwardk> trofi^w: with the lib you can generate nice images of how things connect like http://comonad.com/haskell/graphs/Set.gif
06:38:43 <ray> , vacuum []
06:38:46 <lunabot>  [(0,[])]
06:38:57 <ray> , vacuum 6:[]
06:39:00 <lunabot>  [[(0,[])]]
06:39:15 <QP> , vacuum [1,2,3]
06:39:17 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[])]
06:39:22 <trofi^w> , vacuum (let x in [x,x,x])
06:39:23 <lunabot>  luna: parse error on input `in'
06:39:26 <trofi^w> , vacuum (let x = 1 in [x,x,x])
06:39:28 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[])]
06:39:47 <mmorrow> , vacuum (fix (\x -> 0 : x))
06:39:49 <lunabot>  [(0,[1,0]),(1,[])]
06:40:28 <QP> , fix (\x -> 0 : x)
06:40:29 <trofi^w> looks like adjacency list
06:40:29 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
06:41:18 <doserj> trofi^w: (a,b) means node a has pointers to the elements in b
06:41:44 <QP> , vacuum 2
06:41:46 <lunabot>  [(0,[])]
06:42:18 <yitz> http://hpaste.org/fastcgi/hpaste.fcgi/help
06:42:23 <QP> , vacuum $ array (1,2,3) [(1,0),(2,0),(3,0)]
06:42:24 <lunabot>  luna: Couldn't match expected type `(i, i)'
06:42:26 <mmorrow> , vacuum ((),())
06:42:28 <lunabot>  [(0,[1,1]),(1,[])]
06:42:32 <mmorrow> , vacuum ((),[])
06:42:34 <lunabot>  [(0,[1,2]),(1,[]),(2,[])]
06:42:37 <mmorrow> , vacuum ([],[])
06:42:39 <lunabot>  [(0,[1,1]),(1,[])]
06:43:09 <cnwdup> dcoutts, ping
06:43:17 <QP> @type vacuum
06:43:19 <lambdabot> Not in scope: `vacuum'
06:43:25 <QP> ?
06:43:29 <vixey> , vacuum $ array (1,3) [(1,0),(2,0),(3,0)]
06:43:31 <lunabot>  luna: Ambiguous type variable `t' in the constraint:
06:43:38 <vixey> , vacuum $ array (1,3::Int) [(1,0),(2,0),(3,0)]
06:43:39 <lunabot>  luna: Ambiguous type variable `t' in the constraint:
06:43:44 <vixey> :t array
06:43:45 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
06:43:48 <QP> wooops... :-)
06:43:52 <vixey> , vacuum $ array (1,3::Int) [(1,0::Int),(2,0),(3,0)]
06:43:53 <lunabot>  luna: No instance for (Data.Array.Base.IArray a GHC.Types.Int)
06:44:15 <trofi^w> , vacuum (let foo = 1:1:(zipWith (^) foo (tail foo)))
06:44:16 <lunabot>  luna: parse error on input `)'
06:44:26 <trofi^w> , vacuum (let foo = 1:1:(zipWith (^) foo (tail foo))
06:44:27 <lunabot>  luna: parse error on input `)'
06:44:47 <yitz> , vacuum $ array (1,3::Int) [(1::Int,0::Int),(2,0),(3,0)]
06:44:49 <lunabot>  luna: No instance for (Data.Array.Base.IArray a GHC.Types.Int)
06:44:51 <doserj> , vacuum (let foo = 1:1:(zipWith (^) foo (tail foo) in foo)
06:44:53 <lunabot>  luna: parse error on input `in'
06:45:06 <doserj> , vacuum (let foo = 1:1:(zipWith (^) foo (tail foo)) in foo)
06:45:14 <lunabot>  Killed.
06:45:20 <trofi^w> eh
06:45:38 <_boegel_> , vixen they are killing you, aren't they?
06:45:39 <lunabot>  luna: Not in scope: `vixen'
06:45:46 <_boegel_> @vixen they are killing lunabot!
06:45:46 <lambdabot> you sound like an awesome guy... are you single?
06:46:02 <_boegel_> @vixen no, I'm married... you're like a month too late!
06:46:02 <lambdabot> yeah, i like
06:46:11 <vixey> zipWith ^ won't have much interesting sharing
06:46:20 <_boegel_> I think lambdabot is drunk or something...
06:46:21 <vixey> It's just calculating a new result
06:49:26 <mmorrow> , vacuum (fix (\x -> Node () [x,x]))
06:49:28 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
06:52:05 <dcoutts> cnwdup: pong
06:53:42 <cnwdup> dcoutts, hi. I'd like to add a module to gtk2hs (gdk functions for Atoms and Properties), but I am a little lost on how to integrate it. Is there some kind of instruction for that?
06:54:02 <zever> hi guys, I get this error when trying to compile something with ghc, any clues? /usr/bin/ld: cannot find -lgmp
06:54:02 <zever> collect2: ld gaf exit-status 1 terug
06:56:32 <dcoutts> cnwdup: find the right module and follow the pattern. You edit .chs.pp files. Or if there's no .chs.pp then just the .chs file
06:57:19 <timbod> bye
06:57:27 <cnwdup> dcoutts, what if I want to add a new module? How do I tell gtk2hs to build and install it correctly?
06:58:14 <cnwdup> dcoutts, or do I have just to re-export it from Graphics.UI.Gtk?
06:58:22 <Saizan> zever: do you have libgmp installed?
06:59:37 <zever> Saizan: i have libgmp3c2 installed
07:00:16 <zever> maybe i need libgmp3 or -dev
07:00:20 <dcoutts> cnwdup: yes, export it from the top level module and add it to the top level Makefile.am
07:00:31 <zever> or -ocaml?
07:00:41 <cnwdup> dcoutts, okay. Thanks. I'll so how far I get with that. (:
07:02:44 <raxas> wow, under ghci that vacuum thingy is much more informative
07:02:49 <cnwdup> s/so/see
07:06:09 <zever> Saizan: apparently, i needed libgmp3-dev, it works now
07:10:32 <Saizan> zever: nice :) i'll remember to suggest that package in the future :)
07:21:58 <leimy> @users
07:21:58 <lambdabot> Maximum users seen in #haskell: 658, currently: 618 (93.9%), active: 14 (2.3%)
07:22:28 <leimy> @src flip
07:22:28 <lambdabot> flip f x y = f y x
07:22:33 <stork> sup guise, can anyone help me make a show function for my data type work properly? I can't find anything relevant on google :(
07:22:49 <leimy> flip can actually add an argument to functions that didn't have one
07:22:51 <leimy> interesting.
07:23:03 <beelsebob> how?
07:23:08 <leimy> :t id
07:23:08 <lambdabot> forall a. a -> a
07:23:12 <leimy> has one argument
07:23:14 <leimy> :t flip
07:23:15 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:23:20 <leimy> :t flip id
07:23:21 <lambdabot> forall b c. b -> (b -> c) -> c
07:23:33 <leimy> it creates a function that takes a b and  function of b -> c
07:23:35 <leimy> out of id
07:23:54 <leimy> > (flip id) 3 (+9)
07:23:55 <lambdabot>   12
07:24:04 <leimy> :t (flip id) 3
07:24:04 <lambdabot> forall b c. (Num b) => (b -> c) -> c
07:24:22 <mmorrow> @type [id,($)]
07:24:23 <lambdabot> forall a b. [(a -> b) -> a -> b]
07:24:56 <stork> anyone give me any pointers?
07:25:04 * beelsebob is not sure he'd think of that as adding an argument
07:25:14 <mmorrow> data A = A deriving(Show)
07:25:19 <beelsebob> but... yeh
07:25:20 <beelsebob> I guess so
07:25:32 <stork> yeah but how do I change how it's shown mmorrow
07:25:35 <leimy> beelsebob: well you can nearly think of it as that :-)
07:25:51 <leimy> it's really due to currying and binding of flip's arguments right
07:26:16 <mmorrow> instance Show A where show A = "B"
07:26:17 <beelsebob> stork: data A = A; instance Show A where show A = "B"?
07:26:22 <mmorrow> haha
07:26:31 <beelsebob> obviously that's the "correct" instance then
07:26:31 <stork> cool, thanks
07:26:32 <beelsebob> :D
07:26:32 <mmorrow> beelsebob: nice choice
07:27:02 <byorgey> leimy: right, it's not so much that it adds an argument, as that it specializes the return type to be a function.
07:27:02 <byorgey> all Haskell functions only take one argument, remember =)
07:27:51 <leimy> byorgey: sure but then you're just talking about return types :-)
07:28:00 <leimy> so it's how you want to think of the function
07:28:11 <byorgey> leimy: yeah, I know, just being pedantic =)
07:28:16 <leimy> it's a matter of punting the change from one end to the other :-)
07:28:25 <leimy> but I get it.
07:29:56 <stork> thanks beelsebob, mmorrow
07:30:10 <stork> sorry for phrasing my question like a spacker too, I'm tired :(
07:30:37 <ski> , [$ty| vacuum |]
07:30:40 <lunabot>  forall a . a -> [] ((Int, [] Int))
07:31:13 <ski> , [$ty| length |]
07:31:16 <lunabot>  forall a . [] a -> Int
07:36:42 <JoelMcCracken> what is wrong with the following: *Main> sqrt . fromInteger x
07:37:11 <doserj> fromInteger x is not a function, so you cannot compose it with sqrt
07:37:32 <JoelMcCracken> ah
07:37:42 <vixey> yeah it has to be (sqrt . fromInteger) x
07:37:45 <C-Keen> :t fromInteger
07:37:46 <lambdabot> forall a. (Num a) => Integer -> a
07:37:49 <ulfdoz_> Die war schon Öko bevor es cool wurde!!!111111111!!!!!!!!!111
07:37:52 <ulfdoz_> ewin
07:38:18 <JoelMcCracken> thank you
07:39:30 <tux-foo> If I do something like:    foldr (++) []  someting_of_[[a]]
07:40:11 <tux-foo> then on the result I do right recursion (i.e. check the head, check for a condition, if met return the head otherwise continue).
07:40:14 <ski> @src concat
07:40:14 <lambdabot> concat = foldr (++) []
07:40:48 <tux-foo> Then does lazy evaluation prevent a ++  from happening when the element to be found is in the first list of [[a]] ?
07:41:34 <ski> no
07:41:48 <tux-foo> for example:  head map (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]])
07:41:58 <tux-foo> sorry...
07:42:03 <cooldude127> head $ map ...
07:42:07 <tux-foo> head   (map (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]]))
07:42:19 <tux-foo> cooldude127, ^^
07:42:27 <ski> maybe you meant `filter' instead of `map' ?
07:42:38 <cooldude127> > head   (map (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]]))
07:42:39 <lambdabot>   False
07:42:52 <cooldude127> > head   (filter (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]]))
07:42:53 <lambdabot>   2
07:42:58 <ski> > head . filter (/= 1) . concat $ [[1,1,2], [2,2,1], [3,2,2]]
07:42:59 <lambdabot>   2
07:43:10 <tux-foo> ski, no, I meant span
07:43:16 <tux-foo> but filter is ok two
07:43:23 <tux-foo> head   (span (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]]))
07:43:43 <cooldude127> > head   (span (/= 1) (foldr (++) []  [[1,1,2], [2,2,1], [3,2,2]]))
07:43:44 <lambdabot>   Couldn't match expected type `[a]'
07:43:51 <ski> > span (/= 1) . concat $ [[1,1,2], [2,2,1], [3,2,2]]
07:43:51 <cooldude127> :t span
07:43:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:43:52 <lambdabot>   ([],[1,1,2,2,2,1,3,2,2])
07:44:09 <ski> > head . snd . span (/= 1) . concat $ [[1,1,2], [2,2,1], [3,2,2]]
07:44:10 <lambdabot>   1
07:44:28 <cooldude127> tux-foo: concat == foldr (++) []
07:44:39 <ski> @src concat
07:44:40 <lambdabot> concat = foldr (++) []
07:44:46 <cooldude127> lolz
07:44:59 <stork> what does infix do in haskell?
07:45:16 <cooldude127> stork: a + b instead of (+) a b
07:45:28 <stork> is there any way to ignore the function?
07:45:35 <stork> wait
07:45:36 <tux-foo> The point is, I need to find a value which is probably on one of the topmost lists of the list of lists, so concat is a little bit overdone when the lists of lists is very large.
07:45:40 <stork> ignore me :o
07:45:47 * ski never understood why people use `==' instead of `=' (in this channel) when they want to state that two expressions are equal
07:45:47 <true\false> /ignore stork
07:45:57 <stork> ow
07:46:07 <true\false> = denotes 'becomes'
07:46:10 <true\false> == denotes equality
07:46:18 <quicksilver> tux-foo: doesn't matter.
07:46:19 <ski> `=' denotes equality
07:46:27 <quicksilver> "=" denotes definitional equality.
07:46:29 <tux-foo> quicksilver, because of lazy eval?
07:46:34 <cooldude127> i believe so
07:46:34 <ski> `==' denotes computable equality
07:46:38 <quicksilver> right.
07:46:41 <quicksilver> tux-foo: yes.
07:46:47 <true\false> Not in programming terms.. It's too ambiguous in terms of if it's an assignment or equality comparison
07:46:57 <quicksilver> true\false: this is haskell.
07:47:03 <SamB> well, a binding or comparison
07:47:04 <quicksilver> true\false: in haskell "=" is not an assignment operator.
07:47:05 <ski> @type (==)
07:47:06 <lambdabot> forall a. (Eq a) => a -> a -> Bool
07:47:13 <quicksilver> our assignment operator is "writeIORef"
07:47:15 <SamB> even in provers they have different symbols for each
07:47:17 <quicksilver> we don't use it very often.
07:47:23 <true\false> quicksilver: Bah, learn C# and then judge my words :s
07:47:29 <quicksilver> true\false: I know C#.
07:47:35 <quicksilver> true\false: and java. and C. and C++. etc.
07:47:38 <quicksilver> but this is #haskell.
07:47:55 <SamB> strangely, they often use â‰¡ for equality and = for definition ;-)
07:47:55 <true\false> Heh ok, regardless. Time to hand in my work.
07:48:19 <ski> tux-foo
07:48:26 <tux-foo> quicksilver, thank you. This releaves me
07:48:29 <tux-foo> ski, yes.
07:48:39 <ski> tux-foo : the concatenation will only be done up to the element you were looking for .. not any more
07:49:17 <ski> (i.e. if you ignore the rest, after the element you were looking for)
07:49:52 <tux-foo> ski, awesome. I cannot test it because I cannot do 1/0 somewhere, which will then not be used since ghci will substitute this with Infinity.
07:49:56 <tux-foo> instead of an error.
07:50:04 <ski> sure you can
07:50:06 <dolio> > True == False == True
07:50:07 <lambdabot>       precedence parsing error
07:50:07 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
07:50:17 <tux-foo> ski, I can of course do error "foo" somewhere
07:50:33 <tux-foo> like:    [1,2,(error "foo")] !! 1
07:51:11 <quicksilver> tux-foo: that's the standard way to test these things, yes ;)
07:51:18 <ski> > findIndex (== 3) (concat ([1,1,2] : [2,2,1] : (3 : error "foo !") : error "bar !"))
07:51:19 <lambdabot>   Just 6
07:51:23 <quicksilver> stick and error in and see if it blows up.
07:51:24 <quicksilver> like that.
07:51:39 <kadaver> how is xemacs better?
07:51:40 <ski> > findIndex (== 5) (concat ([1,1,2] : [2,2,1] : (3 : error "foo !") : error "bar !"))
07:51:41 <lambdabot>   * Exception: foo !
07:51:56 <tux-foo> Does haskell (for example in the ghci of hugs implementation) cache all calculations/function calls?
07:52:04 <kadaver> are there hadoop bindings for haskell?
07:52:06 <tux-foo> to do lazy evaluation I mean.
07:52:17 <tux-foo> and prevent a call to be calculated twice.
07:53:07 <dolio> It caches shared values that are used elsewhere in the expression.
07:53:07 <tux-foo> I ran a few benchmarks to see what happend when calling something like ones = 1:ones
07:53:23 <tux-foo> dolio, and sees all as one big expression.
07:53:25 <tux-foo> ?
07:53:37 <dolio> That depends on how you're doing things.
07:53:54 <tux-foo> dolio, basically a haskell program always has the same result.
07:54:04 <tux-foo> except when using user io
07:54:10 <dolio> "let x = expensive 5 in x + x" will evaluate x once on the left side, and save it for the right side.
07:54:23 <quicksilver> tux-foo: it doesn't cache everything, no. It keeps named values for as long as you need them.
07:54:31 <dolio> Evaluate "expensive 5" once, even.
07:54:47 <dolio> But "expensive 5 + expensive 5" will evaluate it twice.
07:54:59 <quicksilver> it's not really about naming, but it can help to think of it that way.
07:55:01 <dolio> That is, most implementations will do this. There's nothing in the standard guaranteeing either.
07:55:31 <quicksilver> dolio: although the mere existance of the DMR betrays that the committee expected named values to be shared :)
07:55:38 <quicksilver> dolio: and that's in the standard.
07:55:44 <dolio> Yeah.
07:55:45 <quicksilver> so it's kind of implied but never stated.
07:56:01 <tux-foo> ah
07:56:10 <kadaver> or using random monad
07:57:15 <tux-foo> Thank you all.
07:57:24 * tux-foo leaves to continue coding
07:57:46 <dolio> And in most implementations, "ones = 1 : ones" is represented cyclically.
07:59:35 <doserj> in contrast to [1,1..]
07:59:48 <BONUS> @pl \k -> c (flip runCont k . f)
07:59:48 <lambdabot> c . (. f) . flip runCont
07:59:57 <dolio> , vacuum [1,1..]
08:00:04 <lunabot>  Killed.
08:04:05 <doserj> , vacuum (let ones=1:ones in ones ) == vacuum (cycle [1])
08:04:08 <lunabot>  True
08:13:52 <stork> how can I convert a rational to a double
08:14:01 <quicksilver> realToFrac
08:14:12 <quicksilver> > realToFrac ( 1.5 :: Rational ) :: Double
08:14:14 <lambdabot>   1.5
08:14:32 <stork> thanks
08:19:15 <solistic> Did somebody realize that unlines _is_not_ the reverse of lines, contrary to what http://www.haskell.org/ghc/dist/current/docs/libraries/base/Prelude.html#v%3Aunlines says?
08:19:21 <solistic> unlines $ lines "foo"
08:19:29 <vixey> solistic: yes
08:19:39 <cooldude127> unlines always adds an extra \n doesn't it?
08:19:44 <cooldude127> not at extra
08:19:49 <cooldude127> but always puts one at the end
08:19:56 <cooldude127> even if it wasn't there before
08:19:59 <vixey> they are using the term 'inverse' very loosely
08:20:02 <solistic> cooldude127: yes, not always..
08:20:33 <solistic> vixey: yes, true, they knew they did mess something;)
08:21:11 <doserj> it's even worse for unwords.words
08:21:23 <solistic> what exactly is _an_ inverse, I only have heard about f^(-1) == the inverse
08:21:23 <quicksilver> are they not half-inverses?
08:21:25 * quicksilver checks.
08:21:37 <poucet> heh
08:21:38 <poucet> not even
08:21:43 <vixey> f inverse of g should meant that f . g = id & g . f = id
08:21:50 <poucet> > words . unwords $ ["a", "b", "c", " "]
08:21:51 <lambdabot>   ["a","b","c"]
08:21:54 <vixey> but there is also concepts of left inverse, right inverse
08:22:00 <poucet> They're not any inverse
08:22:01 <ray> > unwords . words $ "hi       there"
08:22:02 <lambdabot>   "hi there"
08:22:17 <quicksilver> @check \x -> x == lines . unlines $ x
08:22:18 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `Bool'
08:22:23 <quicksilver> @check \x -> x == (lines . unlines $ x)
08:22:25 <lambdabot>   "Falsifiable, after 350 tests:\n[\"\\823686\\733191\\20175\\833427\\646721\...
08:22:26 <vixey> they are inverse if you put a suitable precondition on the input
08:22:33 <quicksilver> @check \x -> x == (unlines . lines $ x)
08:22:34 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\424530\\1048495\"\n"
08:22:38 <quicksilver> neither.
08:22:41 <vixey> I assume we (the library users) are suppose to figure that out
08:22:42 <poucet> > lines . unlines $ ["\n", " "]
08:22:44 <lambdabot>   ["",""," "]
08:22:48 <quicksilver> @check \x -> x == (unwords . words $ x)
08:22:50 <lambdabot>   "OK, passed 500 tests."
08:22:51 <poucet> quicksilver: not that complicated
08:22:55 <poucet> quicksilver: I've shown you exmaples that fai
08:22:56 <quicksilver> @check \x -> x == (words . unwords $ x)
08:22:58 <lambdabot>   "Falsifiable, after 0 tests:\n[\"\\726278\\500053\\224716\",\"\",\"\"]\n"
08:23:01 <poucet> > lines . unlines $ ["\n", " "]
08:23:03 <lambdabot>   ["",""," "]
08:23:04 <poucet> > words . unwords $ ["a", "b", "c", " "]
08:23:06 <lambdabot>   ["a","b","c"]
08:23:06 <quicksilver> unwords + words are half inverse though.
08:23:10 <poucet> no they're not
08:23:17 <quicksilver> @check \x -> x == (unwords . words $ x)
08:23:18 <lambdabot>   "OK, passed 500 tests."
08:23:19 <vixey> what's half inverse?
08:23:21 <poucet> only if your words do not contain white spaces
08:23:25 <poucet> quicksilver: look at my code please
08:23:28 <vixey> thank you poucet
08:23:41 <quicksilver> ah, right.
08:23:52 <vixey> never trust quickcheck
08:23:52 <quicksilver> probability of two successive spaces is less than 1/500
08:23:56 <quicksilver> bad quickcheck.
08:24:02 <vixey> or testing in general
08:24:08 <ray> bad  quickcheck
08:24:19 <poucet> "bad\n\nquickcheck"
08:24:21 <vixey> @check \x y -> x*y \= 7*11
08:24:22 <lambdabot>   Not in scope: `\='
08:24:25 <vixey> @check \x y -> x*y /= 7*11
08:24:26 <lambdabot>   "OK, passed 500 tests."
08:24:34 <vixey> so 77 is a prime number
08:24:46 <poucet> vixey: I thought you knew that
08:24:47 <tomh> hmm should i strip out comments in the tokenizer or parser phase?
08:24:49 <poucet> vixey: please stay with the times.
08:25:10 <vixey> tomh: some more context? ..
08:25:17 <tomh> compiler construction
08:25:22 <ray> 77 is a prime number, because it factors into itself and 1
08:26:16 <poucet> @check \x y -> x*y /= 4
08:26:18 <lambdabot>   "Falsifiable, after 2 tests:\n-1\n-4\n"
08:26:23 <cooldude127> 77 is not a prime number, we all know that right?
08:26:31 <poucet> vixey: might want to add more checks to that :)
08:26:35 <stork> haha
08:26:45 <poucet> @check \x y -> x /= 1 && y /= 1 ==> x*y /= 4
08:26:46 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
08:26:46 <lambdabot>           ...
08:26:50 <vixey> cooldude127: I am saying that testing is horribly flawed and should never be used
08:26:58 <poucet> @check \x y -> (x /= 1 && y /= 1) ==> x*y /= 4
08:26:59 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
08:26:59 <lambdabot>           ...
08:27:03 <quicksilver> if you are saying that, you are an idiot.
08:27:10 <quicksilver> testing has a purpose.
08:27:20 <quicksilver> but it does not solve all problems.
08:27:33 <doserj> @check \x y -> x == 1 || y == 1 || x*y /= 4
08:27:35 <lambdabot>   "Falsifiable, after 71 tests:\n-2\n-2\n"
08:27:38 <MyCatVerbs> quicksilver: yeah, it's a great way to double check your proofs. ;P
08:27:45 <poucet> why doesnt ==> work
08:27:57 <vixey> not sure you calling me an idiot and vauging it up with comments like "everything has it's place and stuff is good or bad depending on context" is gonna make me take you seriously
08:28:17 <ray> stamp out moral relativism
08:28:25 <poucet> moral absolutism is the new vogue
08:28:33 <poucet> einstein was mistaken.
08:28:44 <ray> if it were the new vogue, it'd just be moral relativism in absolutist clothing
08:28:51 <cooldude127> if you do testing right, checking the right properties, it is useful
08:29:31 <quicksilver> vixey: I have no interest in whether or not you take me seriously. But saying "testing is horribly flawed and should never be used" is just rubbish.
08:29:56 <cooldude127> checking useless properties does nothing
08:30:07 <vixey> not really into a debate about this seeing as we both know we're right
08:30:41 * doserj suggests to rename @check to @disprove
08:30:54 <poucet> doserj: unsafeDisprove
08:30:57 <vixey> doserj: yeah I 'disproved' that 77 isn't a prime earlier
08:31:19 <doserj> poucet: tryDisprove?
08:31:29 <poucet> doserj: 'halt'
08:31:56 <poucet> vixey: For a large class of problems, testing can help uncover many bugs, especially when used in conjunction with code coverage.
08:32:01 <augustss> 77 is not a prime?  so sad
08:32:34 <cooldude127> vixey: that was an abnormally poorly written property
08:32:56 <vixey> cooldude127: actually I crafted it specifically so it would give wrrong results :p
08:33:02 <cooldude127> exactly :)
08:33:26 <ski> (doserj : `refute')
08:33:42 <cooldude127> cuz normally, with quickcheck you would have a function to check if something was prime, then use quickcheck to check lots of numbers to make sure it gives the right results
08:33:45 <ski> vixey : also, there's pseudo-inverse
08:33:46 * SamB wonders how you tell what characters are provided, and how, by a scim table
08:33:49 <doserj> that's shorter, yes thanks
08:33:57 <vixey> ski, with a formal definition?
08:34:49 <ski> (quicksilver : btw, i don't know why there's a `definitional' in `definitional equality' .. unless it just means that it's the equality that is *e.g.* used in definitions)
08:35:14 <ski> vixey : `f' and `g' are pseudo-inverses iff `f . g . f = f' and `g . f . g = g'
08:35:28 <quicksilver> ski: you sometimes see "=^{def}" or "=^{\triangle}"
08:35:41 <sergio`> Hi, has anybody a short example using Data.Text.ICU? I'm fighting to have something running on windoze...
08:35:44 <ski> quicksilver : yes .. but i think it's silly
08:36:02 <quicksilver> ski: the point, I think, is to say 'these things are equal by definition' as distinct from 'these things are equal, but that requires a proof'
08:36:03 <ski> it's not that you use a special kind of equality to define things
08:36:16 <quicksilver> ski: so it's more of a pedagogical distinction than a real one.
08:36:28 <quicksilver> equal is equal, as you say ;)
08:36:44 <ski> defininitions (afaiui) are just a special kind of propositions that we assume (as axiom if you like)
08:37:06 <ski> the "special kind" meaning that we can prove that there exists a unique thing satsifying the definition
08:37:37 <ski> some definitions include `=' in the defining formula. some include `<=>' .. some include neither
08:38:42 <ski> vixey : what did you mean by `half-inverse' above ?
08:38:51 * SamB wishes for a way to add quote-marks to the selected text in gmail ...
08:38:56 <ski> vixey : a retract situation ? something else ?
08:39:32 <quicksilver> by half-inverse, I mean "f.g = id" or "g.f=id" but not both
08:39:41 <quicksilver> I assume that's what vixey meant too?
08:39:45 <ski> ok, that's the same as `retract situation'
08:40:11 <ski> (well, `retract situation' is if you have one of those .. you might have the other too .. or not)
08:40:35 <SamB> (you know, those > on the left?)
08:50:38 <vixey> ski: when I said "what's half inverse?"?
08:51:38 <roconnor> mmorrow: so there is no way out of a foldl by checking the accumulator?
08:52:04 <roconnor> mmorrow: that seems odd. The imperative people have no trouble.
08:52:14 <vixey> call it foldl'
08:53:18 <ski> vixey : yes, sorry. i confused which of you and quicksilver were mentioning it
08:53:31 <MyCatVerbs> quicksilver: shouldn't those be "left inverse" and "right inverse" or something to distinguish the cases from each other?
08:53:45 <dolio> The imperative people have a conditional branch on every iteration to decide whether or not to continue.
08:53:54 <dolio> In foldl, that branch is used by "is the list null?"
08:54:15 <quicksilver> MyCatVerbs: Yes. My understanding is that 'half inverse' means 'either left or right inverse'
08:54:24 <quicksilver> MyCatVerbs: (and implies but not both)
08:54:55 <roconnor> dolio: oh, okay.  So the foldl combinator just isn't flexible enough to say it.
08:55:25 <ski> `r',`s' forms a retract situation iff `r . s = id'. `r' is called a retraction of `s', while `s' is called a section of `r'
08:55:43 * quicksilver nods.
08:56:07 <ski> so `retraction of' is `left inverse of' (though i'd prefer `after/post -inverse')
08:56:30 <ski> and `section of' is `right inverse of' (though i'd prefer `before(?)/pre -inverse')
08:56:48 <dolio> Unless you're thinking of 'break' or something, which is clearly a use of continuations. :)
08:58:48 <ski> (if we had composable-continuation side-effects, then we could probably translate the internal iteration in `foldl' into an external iteration, at which point we could easily "break" the iteration anytime we wanted)
08:59:37 <Philippa_> vixey: testing is necessary any time you care about how something behaves in the real world. Why? Because you can't proceed from the informal to the formal by formal means
09:04:50 <luite> suppose you have 4 integers, [a,b,c,d] and an expected outcome e. you can use the operators (+), (-), (/), (*), and parentheses where necessary. you have to create an expression f using these operators, where f a b c d = e. how would you solve this in haskell (bonus points for solving the problem for an input list of arbitrary length :) )
09:05:08 <leimy> wrong button
09:05:10 <leimy> oops
09:05:49 <vixey> luite: generate every possible string and evaluate each one ?
09:07:03 <luite> vixey: that's possible of course, but in that case, there must be some very clever tricks using the list monad or something :)
09:07:25 <quicksilver> the list monad can help you generate all the possibilities
09:07:37 <quicksilver> it doesn't change the algorithm, though
09:07:44 <luite> I haven't found a really 'clean' way to do it. generating all permutations of the list, and then applying the operatiors sequentially, in rpn fashion, will not evaluate all possibilities
09:07:46 <quicksilver> just makes it look nicer on paper, perhaps.
09:07:47 <vixey> luite: 'list monad' isn't going to help unless you know what you're going to do with it
09:07:59 <quicksilver> are you allowed to use numbers more than once?
09:08:12 <luite> quicksilver: no
09:08:46 <quicksilver> so you have to account for different ways of nesting / paranthesising
09:08:53 <quicksilver> and possibly try to ignore commutation
09:08:56 <quicksilver> although maybe you don't care.
09:09:16 <luite> I don't think efficiency is very important for just four numbers
09:09:23 <luite> but it might be for longer lists
09:09:39 <vixey> luite: is there an algoritm better than brute forcing
09:11:30 <vixey> luite: (think about what's possible recursively)
09:11:42 <luite> vixey: I don't know, I just thought of this problem because someone in #math came up with a similare one. a special case is the one with an input of length four, where e = 24, which was used as a game on an old dutch toy called 'flippo'
09:11:58 <Saizan> for bruteforce i'd first generate all the tree shapes, and then fill each one with all the permutations, but i'd get many equivalent expressions this way i guess
09:12:02 <vixey> luite: yeah not sure what else I can say without just giving the game away
09:12:51 * ski . o O ( select :: [a] -> [] (a,[a]) )
09:13:52 <luite> there are some optimizations of course, such as reusing intermediate results, and bounds on the values of subexpressions, but I don't really see one that's much more efficient
09:15:07 <vixey> luite: I've got  3  and a bunch of other numbers, want to make 63 -- so can I make 60 with the other numbers?
09:15:59 <luite> vixey: why 60? you can also make 189? or 21?
09:16:15 <luite> or 66, in this case, 63 does not rule out any operator
09:16:24 <quicksilver> agreed.
09:16:28 <quicksilver> so you consider those two.
09:16:38 <quicksilver> but you have simplified the problem, because now you only have 3 numbers left.
09:16:42 <vixey> luite: because 60 + 3 = 63
09:16:45 <quicksilver> sorry, s/two/too/
09:17:17 <luite> quicksilver: but it's more complicated than that, you cannot just shave off one value
09:17:30 <luite> if the solution is something like (a+b)*(c+d)
09:17:44 <vixey> luite: (IF you want to write this algorithm in a declarative way then CLP is the way)
09:17:56 <vixey> luite: (but in haskell you would write it out explicitly)
09:18:18 <quicksilver> shaving off the 3 isn't the only thing you could do.
09:18:22 <quicksilver> but it is *one* of the things you could do.
09:18:30 <quicksilver> you try the other ones as well.
09:18:45 <quicksilver> there are two approachs - one generate all syntax trees and check the answer
09:18:56 <quicksilver> two - be more goal directed and work towards the answer
09:19:31 * roconnor would generate all the semantic trees -- screw syntax
09:19:58 <haskellnoob> I have a function, say "print", with the signature String -> IO() . My entire program consists of the following: 1) Obtain an array of type [String], and 2) Apply "print" to each element in this array. So I pull enough strings (eek!) inside the "main" function to obtain this array, say myArray, and then say: map print myArray . This is the last thing I do in main, and the compiler complains...
09:19:59 <haskellnoob> ...(rightly) that main's type is [IO()], while it is expected to have the type IO() . Is there a way to invoke print on each element of myArray except by explicitly recursing? Something similar to map that will just do something to each element of the array and not make an array out of the results?
09:20:38 <roconnor> @type sequence
09:20:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:20:49 <roconnor> @type sequence_
09:20:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
09:21:01 <haskellnoob> roconnor:thanks
09:21:05 <RayNbow> @type mapM_ print
09:21:07 <lambdabot> forall a. (Show a) => [a] -> IO ()
09:21:16 <doserj> and sequence_ . map == mapM_
09:21:29 <roconnor> @src mapM_
09:21:30 <lambdabot> mapM_ f as = sequence_ (map f as)
09:21:39 <RayNbow> roconnor: semantic trees?
09:21:49 <roconnor> doserj: (sequence_ .) . map :P
09:22:12 <edwardk> doserj: fmap sequence_ . map f
09:22:17 <edwardk> heh
09:22:17 <roconnor> RayNbow: you know like:
09:22:30 <edwardk> er drop the f
09:22:37 <roconnor> > [(+),(*)] <*> [3,4] <*> [5,6]
09:22:38 <lambdabot>   [8,9,9,10,15,18,20,24]
09:22:45 <roconnor> no syntax here
09:22:51 <roconnor> no parsing
09:23:05 <RayNbow> ah, Applicative Functors :p
09:24:11 <roconnor> > do { [f,g,h,i] <- sequence [(+),(*),(-),(/)]
09:24:12 <lambdabot>   <no location info>:
09:24:12 <lambdabot>      The last statement in a 'do' construct must be an ...
09:24:14 <roconnor> oops
09:24:28 <quicksilver> roconnor: it's still a syntax tree in the sense I meant.
09:24:36 <quicksilver> an op-tree if you like.
09:24:58 <vixey> roconnor: yo ucan pair up syntax and semantics
09:25:02 <edwardk> i do kind of wish <*> was just `ap` in Control.Applicative.
09:25:05 <luite> hmm, suppose you have a list of length n, the subproblems in one branch of the tree would be just the power set of the list, except the list itself and [], the other branch would be the complement
09:25:18 <luite> and you combine both subtrees with all possible operators
09:25:37 <RayNbow> > let powerset = filterM (const [False,True])   in   powerset [1..4]
09:25:39 <lambdabot>   [[],[4],[3],[3,4],[2],[2,4],[2,3],[2,3,4],[1],[1,4],[1,3],[1,3,4],[1,2],[1,...
09:26:05 <luite> and the result of each tree is a set of possible answers
09:26:19 <roconnor> > sequence (replicate 3 [a,b,c,d])
09:26:20 <lambdabot>   [[a,a,a],[a,a,b],[a,a,c],[a,a,d],[a,b,a],[a,b,b],[a,b,c],[a,b,d],[a,c,a],[a...
09:26:47 <vixey> > (nub . map nub . sequence . replicate 3 . const [a,b,c,d]) ()
09:26:48 <lambdabot>   [[a],[a,b],[a,c],[a,d],[a,b,c],[a,b,d],[a,c,b],[a,c,d],[a,d,b],[a,d,c],[b,a...
09:26:56 <luite> roconnor: in my original problem, you had to use each of the numbers exactly once
09:27:08 <roconnor> oh wait
09:27:09 <luite> you are free to modify the problem statement of course :p
09:27:19 <roconnor> quicksilver: you are right, you need the synatx tree
09:27:32 <roconnor> if you want to know what the right answer is
09:27:48 <roconnor> > show (+)
09:27:49 <lambdabot>       Overlapping instances for Show (a -> a -> a)
09:27:49 <lambdabot>        arising from a use ...
09:27:51 <haskellnoob> when I say MapM_ print myArray, do the print actions get executed one by one or all at once (strict or lazy)?
09:28:31 <roconnor> haskellnoob: are you asking if they happen in parallel?
09:28:35 <quicksilver> haskellnoob: that is not strict or lazy.
09:28:50 <quicksilver> haskellnoob: the actions happen one after another.
09:28:58 <quicksilver> I'm not sure what "all at once" would be? faster?
09:29:04 <roconnor> the actions all at once happen one after the other. :)
09:29:21 <roconnor> or is that happen one after the other all at once
09:29:42 <roconnor> but definitely not in parallel
09:29:58 <haskellnoob> sorry for the wrong wording -- if I had a thousand elements in myArray, will the printing *begin* only after all the actions have been computed, till the one for the last one in the array?
09:30:26 <roconnor> haskellnoob: in this case printing IS the action
09:31:08 <roconnor> haskellnoob: unless I misunderstood.
09:31:40 <quicksilver> the actions are "calculated" as they do
09:31:43 <quicksilver> as they go.
09:31:57 <quicksilver> not that there is much calculation involved in putting 'print' in front of an item.
09:32:05 <quicksilver> but technically that is 'calculating' an action I guess.
09:32:18 <haskellnoob> roconnor: ok... so the actions are *not* combined into one huge action (or some such) and then this huge action is executed at the end?
09:32:31 <mux> -threaded is the devil in disguise
09:32:41 <doserj> if the list is calculated lazily (i.e., not forced somewhere else), then printing begins before all elements are calculated, if that is what you are asking
09:32:46 <mux> it turns perfectly working code into dangerous space leak bombs
09:33:01 <mux> and other weird stuff (such as Data.Binary not being able to decode a file!)
09:33:17 <solistic> I frequently nee a function that strips all leading and trailing whitespace, like
09:33:20 <solistic> >let strip = reverse . drop . reverse . drop where drop = dropWhile $ flip elem " \n\t"
09:33:34 <solistic> Where is this in the standard bih?
09:33:45 <solistic> s/bih/bib
09:33:51 <roconnor> haskellnoob: arguable there is no difference between the two scenarios, but let's go with the actions are performed one at a time.
09:34:08 <solistic> > strip "        foo   bar        "
09:34:10 <lambdabot>   Not in scope: `strip'
09:34:30 <haskellnoob> roconnor: thanks, let me try that out.. there is a difference, in that the output starts appearing immediately or after a delay of five minutes :)
09:34:46 <edwardk> solistic @let
09:35:05 <quicksilver> haskellnoob: the actions are combined into one huge action, yes.
09:35:11 <solistic> edwardk: with leading birdtrack?
09:35:16 <mux> > let strip s = let s' = dropWhile isSpace s in reverse . dropWhile isSpace $ reverse s' in strip "  foo bar    "
09:35:17 <quicksilver> haskellnoob: that doesn't mean all the *calculation* underneath is done at once.
09:35:17 <lambdabot>   "foo bar"
09:35:33 <edwardk> @let strip = reverse . drop . reverse . drop where drop = dropWhile $ flip elem " \n\t"
09:35:35 <lambdabot>  Defined.
09:35:42 <edwardk> > strip "        foo   bar        "
09:35:43 <lambdabot>   "foo   bar"
09:35:44 <quicksilver> haskellnoob: it's combined into one big action which may well refer to incomplete calculations which will only be performed when needed.
09:35:55 <solistic> edwardk: nice:)
09:36:18 <haskellnoob> quicksilver: i am interested in whether the printing starts immediately, or only after all the different print actions have been computed
09:36:40 <quicksilver> haskellnoob: I've told you the answer, but it's the wrong question.
09:37:05 <mux> should I exepect such weird consequences when using the threaded RTS (Data.Binary going nuts etc)
09:37:05 <haskellnoob> quicksilver: no probs, let me try different things and check
09:37:07 <quicksilver> the print actions are computed on demand.
09:37:20 <mux> this doesn't seem right
09:37:46 <quicksilver> but as I pointed out, 'computing' a print action is not very slow.
09:37:48 <edwardk> @let strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
09:37:49 <lambdabot>  <local>:4:0:
09:37:49 <lambdabot>      Multiple declarations of `L.strip'
09:37:49 <lambdabot>      Declared at: <loca...
09:37:54 <haskellnoob> would "computing a print action" consist of figuring out what is to be printed, or actually printing it on the output?
09:37:58 <quicksilver> what matters is the computation of whatever data the actions are using.
09:38:04 <edwardk> > strip " This is more unicode friendly\n\t"
09:38:06 <lambdabot>   "This is more unicode friendly"
09:38:28 <edwardk> @unlet strip
09:38:29 <lambdabot>   Parse error
09:38:39 <edwardk> hrmm
09:38:43 <edwardk> whats the forget? =)
09:38:43 <roconnor> haskellnoob: check out main = mapM_ putStrLn (repeat "Hello World!")
09:38:52 <haskellnoob> assuming that the data is easily computed, but that there are lots of it -- very many elements in the array -- would the printing start immediately, or only after all the array has been processed?
09:38:59 <haskellnoob> ok, let me check these things out.
09:39:26 <edwardk> @undefine strip
09:39:32 <quicksilver> that depends on the array
09:39:36 <quicksilver> and how you calculate it.
09:39:42 <edwardk> @let strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
09:39:43 <lambdabot>  Defined.
09:39:45 <quicksilver> I don't think your'e talking about array here, though, but lists.
09:39:52 <quicksilver> the same answr applies though.
09:39:54 <quicksilver> "it depends"
09:40:08 <quicksilver> you can imagine calculations which take 5 minutes before they yield even the first element.
09:40:21 <quicksilver> and you can imagine other calculations which yield the first element after 10 milliseconds
09:40:29 <roconnor> haskellnoob: since (repeat "Hello World!") is an infinite list and mapM_ putStrLn (repeat "Hello World!") prints stuff, this clearly show that the entire infinite list of actions is not being "pre-computed" in any way
09:40:51 <haskellnoob> roconnor: that answers my question, thanks.
09:41:04 <quicksilver> it doesn't actually.
09:41:05 <quicksilver> ;)
09:41:08 <quicksilver> you just feel it does.
09:41:20 <roconnor> quicksilver is right
09:41:21 <quicksilver> Because your real question depends on how "myArray" is being calculated.
09:41:39 <quicksilver> in roconnor's example, the calculation (repeat "hello world!") has the property
09:41:44 <quicksilver> than the first element is produced quickly
09:41:53 <quicksilver> (and all the others are also produced very quickly. actually)
09:41:58 <quicksilver> but other calculations could be different.
09:42:12 <quicksilver> you could have calculations which have to do a *lot* of work before they produce even the first element.
09:42:50 <haskellnoob> ok.. even in my case, each element in the list is produced comparatively fast, though the whole list is quite long.
09:43:10 <quicksilver> then you're fine :)
09:43:30 <haskellnoob> as i said, let me try these out and see.. thanks a lot for your help
09:43:51 <roconnor> haskellnoob: it is important to understand that, in general, all IO operations only force enough computation to perform their action
09:44:09 <roconnor> A lot of people think that putting an expression in IO means it is evaluted then
09:44:12 <mux> does anyone know why otherwise perfectly working code using Data.Binary would suddenly fail with weird errors (such as too foo bytes, failed reading at byte position XXX) when using the threaded RTS?
09:44:14 <roconnor> but this isn't true
09:44:33 <solistic> mux, edwardk, so "strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
09:44:43 <solistic> mux, edwardk, is our best bet, right?
09:44:47 <mux> solistic: yup
09:44:58 <roconnor> all evaluation in haskell occurs as late a possible, the IO monad isn't special in this regard
09:45:13 <roconnor> the IO monad is really just as lazy as any other monad.
09:45:41 <solistic> mux, edwardk, would it be worth to discuss addition of strip on haskell-libraries?
09:45:55 <quicksilver> mux: does your code use threads?
09:46:13 <edwardk> Solistic: probably not, its kind of a hack ;)
09:46:22 <mux> quicksilver: well I was using runFastCGIConcurrent so yes; I'm not just using runFastCGI since -threaded makes things go wrong
09:46:24 <haskellnoob> It didn't seem very lazy in printing out those "Hello, World!"s :)
09:46:24 <edwardk> solistic: it gags on infinite lists, etc.
09:46:26 <mux> quicksilver: but I don't use any thread myself
09:46:41 <mux> s/not/now/
09:46:44 <quicksilver> mux: well, if you're reading/writing to the same FDs or files
09:46:49 <quicksilver> from different sessions
09:46:58 <quicksilver> then -threaded will make it more likely stuff gets interleaved
09:47:08 <roconnor> > runState (do {y <- get; put undefined; modify (+1); put 7; return y}) 6
09:47:09 <lambdabot>   (6,7)
09:47:18 <mux> quicksilver: this also happened with test code compiled with -threaded not using fastcgi nor threads
09:47:28 <roconnor> the undefined's cause no problems
09:47:31 <quicksilver> mux: is that test code small enough to share?
09:47:40 <solistic> edwardk: thats true for last too, but what is etc.?
09:47:44 <edwardk> solistic: a 'nicer' version would go through and handle the infinite cases properly by consuming any finite prefix of spaces, then starting to emit output, and would use an accumulator for euns of spaces until it knew if it was in the end case
09:47:45 <mux> quicksilver: I think so and I intend to post about this already
09:48:04 <edwardk> er runs
09:48:19 <mux> quicksilver: it's really weird; with -threaded the code starts leaking stack space like crazy, and I have to bump it with +RTS -K...
09:48:30 <edwardk> solistic the difference is the function you defined _can_ be made lazier, while last can't by construction
09:48:34 <mux> quicksilver: and then with a bigger stack I've got the Data.Binary errors
09:48:39 <quicksilver> hmm.
09:48:51 <mux> it works like a charm with the "normal" RTS
09:48:52 <quicksilver> -threaded makes FFI calls not block everything
09:48:57 <quicksilver> but that's only really noticeable if you're using threads.
09:49:05 <quicksilver> it changes thread scheduling
09:49:13 <quicksilver> ...again, that should only be noticeable if you're using threads.
09:49:50 <Gracenotes> by the way, my latex-beamer presentation is going very well so far :D great software for mathematical presentations
09:49:51 <mux> I'll have to verify my claims for the test code case; but even with FastCGI using threads I don't see why that would break things
09:50:03 <solistic> edwardk, we can wait for the first space after a non space to occur, then we have to see then end of the list, right?
09:50:12 <mux> quicksilver: after all, the FastCGI code is not supposed to touch my files
09:50:48 <quicksilver> but if you're touching your files, and the fastcgi code is giving you two threads
09:50:56 <quicksilver> or more
09:50:58 <mux> I'm only reading the file
09:51:39 <mux> mmm, however the file pointer being moved by two threads could cause this problem.
09:51:48 <edwardk> solistic: you start in phase 1 eating spaces, after you see a nonspace you emit runs of non-spaces in phase 2 then you trip to phase 3 where you are parsing a run of isSpaces by accumulating them. if you see the end of list in phase 3 you du,mp the accumulated spaces. if you see a non-space you emit them into the stream and return to phase 2.
09:52:17 <edwardk> solistic: then strip (cycle "   Hello\n ") -- will actually properly work
09:52:20 <mux> quicksilver: this is the same code that would just space leak before (with 6.10.1) and only worked under special circumstances with GHCi
09:52:31 <Saizan> you might have found a bug in the IO manager or bytestring, that'd be really interesting to investigate
09:52:49 <solistic> edwardk, ok, got it
09:53:36 <edwardk> solistic: the reverse reverse solution is easier, but less lazy
09:53:45 <Hunner> For anyone in portland: starting now http://web.cecs.pdx.edu/~mpj/fpworkshop/Content/Functional_Programming_Workshop.html
09:53:47 <solistic> edwardk, do you think it would be worth the effort?
09:53:59 <edwardk> solistic: not really ;)
09:54:12 <edwardk> solistic its a one liner to bang it out when you need it ;)
09:54:50 <Saizan> the more efficient version might be worth having somewhere
09:55:16 <dons> Hunner: yep. a bunch of people from galois are there now, or coming   later
09:55:18 <Saizan> just so it doesn't have the same hacky feeling
09:55:23 <dons> Hunner: how many people attending?
09:55:42 <Hunner> Looks to be about 50 atm
09:55:53 <dons> cool. should be a few more galois people after lunch.
09:55:56 <Hunner> It's free drop-in, so there's no registation count
09:58:32 <solistic> edwardk, but still very common when working with text, so maybe somewhat duplicated effort for the community as a whole?
09:59:17 <edwardk> hrmm
09:59:42 <Saizan> though maybe for text one should use something more like Data.Text
10:00:13 <edwardk> @hpaste
10:00:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:00:44 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4429#a4429
10:01:17 <vixey> quicksilver: fuck you btw there was absolutely no call for what you sai
10:02:02 <edwardk> ?
10:02:48 <edwardk> vixey apparently feel very passionate about -threaded
10:03:18 <eu-prleu-peupeu> vixey: i love you :)
10:03:21 <RayNbow> dons: I have to disagree with your opinion of Utrecht being beautiful ;)
10:03:31 <dons> well, it was beautiful last week.
10:03:39 <solistic> edwardk, nice
10:03:45 <edwardk> RayNbow: the city or the combinators or the compiler?
10:03:51 <dons> heh
10:03:57 <RayNbow> edwardk: the city :p
10:05:29 <edwardk> ok, i was going to say the parsing combinators made me twinge because they redefined Applicative, even though I understand the motivation for efficiency
10:06:34 <edwardk> though i do wish they'd at least kept the standard names for things like pure.
10:06:50 <dolio> They redefined applicative?
10:07:16 <edwardk> http://hackage.haskell.org/packages/archive/uu-parsinglib/2.0.0/doc/html/Text-ParserCombinators-UU-Parsing.html
10:07:32 <tux-foo> How can I get the where right in: http://pastebin.com/m7d940552
10:07:44 <edwardk> their Applicative = Applicative + Alternative with new names
10:07:46 <tux-foo> I get: main2.hs:1218:22: parse error on input `where' from ghc
10:07:57 <Deewiant> tux-foo: You need an = other the otherwise
10:08:03 <Deewiant> tux-foo: Er, after the otherwise*
10:08:18 <Saizan> edwardk: so the efficiency is in having only one dictionary around?
10:08:51 <edwardk> saizan: actually the efficiency is in ExtApplicative allowing them to define special cases for <*, *>, etc.
10:09:01 <tux-foo> Deewiant, thanx, it worked :)
10:09:06 <tux-foo> silly me
10:09:12 <tux-foo> I just didn;t see that.
10:09:15 <edwardk> but those should really be in Control.Applicative with default definitions, like >> is in Monad.
10:09:35 <edwardk> er in Control.Applicative's Applicative
10:09:58 <Saizan> edwardk: ah, ExtApplicative makes sense, the other Applicative doesn't to me
10:10:14 <edwardk> yeah, i misspoke a bit
10:10:40 <edwardk> as you may have noticed my fingers fly slightly in advance of my brain when typing ;)
10:11:47 <Saizan> 'k, that's not a problem :)
10:11:58 <edwardk> personally i'd rather just see Control.Applicative move the *> <* and <$ cases into the definition of Applicative with the existing definitions as defaults, and make the uuparsing-lib stuff just use the stock Applicative and Alternative
10:12:13 <Saizan> i'm just still baffled by the non-sensical redefinition
10:13:04 <edwardk> oh wait, the <* *> <$ are not what i thought
10:13:49 <edwardk> but the applicative could be ripped out and replaced with the standard one anywyas
10:14:14 <dolio> Where is ExtApplicative?
10:14:25 <QtPlaty[1ireMe]> Is it evil for me to create Char as an instince of Num?
10:14:26 <edwardk> its in that same module at the bottom
10:14:53 <edwardk> QtPlaty[1ireMe]: yes =)
10:14:56 <dolio> Oh. Geeze.
10:15:07 <dolio> This documentation seems extra-cryptic for some reason.
10:15:14 <edwardk> yeah
10:15:28 <edwardk> i had hope when i saw a new parsing combinator lib
10:15:40 <edwardk> i wonder if they'd take a patch that gutted their applicative nonsense
10:16:16 <edwardk> this code looks old though,m note it uses Char and Maybe not Data.Char and Data.Maybe, etc.
10:16:39 <edwardk> ok, yeah this code has to go
10:16:57 <edwardk> instance Applicative p => Functor p where fmap = (<$>) -- is backwards and a very bad instance
10:17:20 <edwardk> that one scares me, coz i don't know how many other screwed up instance heads are in there
10:17:20 <dolio> Heh.
10:18:25 <edwardk> i'll hack together a patch and send it to Doaitse
10:19:50 <Saizan> so uu-parsinglib is a spinoff of uulib?
10:20:14 <edwardk> apparently
10:22:37 <edwardk> at least the refactoring is easy
10:24:31 <kiris> should it be instance Functor f => Applicative f where (<$>) = fmap?
10:24:37 <edwardk> strange. P_f is even completely missing its (<$>) definition
10:25:04 <edwardk> kiris: no. it should exist as an instance at all. it hsould be class Functor f => Applicative f where...
10:25:09 <edwardk> because Functor is a superclass
10:25:26 <edwardk> what doitse tried to do there makes an ambiguous instance head so the ONLY functors would be applicative ones
10:25:32 <edwardk> any other instances would conflict
10:26:52 <edwardk> i really do not understand the layout of this source file at all
10:30:09 <edwardk> ugh, one of his applicatives isn't a functor
10:33:21 <eu-prleu-peupeu> a new version of the opengl package has come out :)
10:36:15 <edwardk> i really really don't like this case: l                       `best'`  r                =   l `best` r
10:36:29 <edwardk> oh, thats a best' =)
10:36:32 <edwardk> whew
10:45:45 <leimy> I have a boss that likes feature creep
10:45:49 <leimy> thank god for functional programming
10:47:27 * edwardk has officially given up understanding the spacing conventions used in the uu parsinglib
10:48:56 <ski> > (`runLinear` [a,b]) $ foldFood [(+),(*)]
10:48:57 <lambdabot>   [a + b,a * b,b + a,b * a]
10:49:03 <ski> > (`runLinear` map ((,) `ap` show) [1,2,3,4]) $ do (x,s) <- foldFood [plus,times]; guard (x == 20); return s  where (x,s) `plus` (y,t) = (x+y,concat ["(",s,"+",t,")"]); (x,s) `times` (y,t) = (x*y,concat ["(",s,"*",t,")"])
10:49:05 <lambdabot>   ["(((1*2)+3)*4)","((1*(2+3))*4)","(1*((2+3)*4))","(((1*3)+2)*4)","((1*(3+2)...
10:49:35 <poucet> :i foldFood
10:49:42 <ski> @type foldFood
10:49:43 <lambdabot> forall i. [i -> i -> i] -> StateT [i] [] i
10:49:51 <ski> @type eat
10:49:52 <lambdabot> forall i. StateT [i] [] i
10:49:55 <poucet> @src foldFood
10:49:55 <lambdabot> Source not found. :(
10:50:06 <ski> <ski> @let foldFood :: [i -> i -> i] -> StateT [i] [] i; foldFood ops = return' =<< eat where return' a = return a `mplus` do b <- foldFood ops; op <- lift ops; return' (a `op` b)
10:51:34 <ski> (basically like `foldFood ops = do eat `mplus` do (a,b) <- liftM2 (,) `join` foldFood ops; op <- ops; return (a `op` b)', except terminating)
10:51:51 <ski> (s/op <- ops/op <- lift ops/)
10:52:36 <ski> > (`runAffine` [a,b]) $ foldFood [(+),(*)]
10:52:37 <lambdabot>   [a,a + b,a * b,b,b + a,b * a]
10:53:49 <QtPlaty[HireMe]> Is there a generic equiverlent of words/lines?  Char -> String -> [String]
10:54:29 <edwardk> yay for paranoid instance declarations.
10:54:38 <haskellnoob> How do I append a single character to a string? I know of myString ++ [a] , but that is list's append -- is there some function that does this particular case faster?
10:54:58 <ski> > "foo" ++ ['!']
10:54:59 <lambdabot>   "foo!"
10:55:07 <ski> > '*' : "foo"
10:55:09 <lambdabot>   "*foo"
10:55:24 <cjay> QtPlaty[HireMe]: http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html#v%3AsplitOn
10:55:26 <ski> no, there is no faster way
10:55:34 <haskellnoob> ok. thanks
10:55:44 <ski> unless you use another data structure
10:55:55 <ski> (maybe bytestrings would be faster .. i don't know)
10:56:27 <ski> (probably something like a rope(?) would be faster)
10:56:47 <haskellnoob> a rope?
10:57:24 <ski> i think that was the name of the datastructure
10:57:37 <ski> i'm thinking of a datastructure where append is O(1)
10:57:50 <haskellnoob> ok.. the documentation for ByteString.snoc says that takes O(n) time
10:57:59 <ski> (basically a tree)
10:58:35 <haskellnoob> i am not that desperate yet :) thanks all the same
10:59:24 <dolio> Lots of people were writing rope libraries back during that one ICFP, but nothing seems to have materialized.
11:00:07 <Berengal> There's always DLists...
11:00:39 <Berengal> I haven't studied them, but everything seems to be O(1), except pulling the actual list out, which is O(n).
11:01:53 <dolio> Yeah, DLists have efficient snoc.
11:02:08 <roconnor> I still think FingerTrees of strict bytestrings are a good idea
11:02:10 <Twey> What's the difference between a DList and a Seq?
11:02:37 <roconnor> getting the last element of a Seq is O(1)
11:02:51 <dolio> DLists store an [a] -> [a] that represents prepending to some other list.
11:03:00 <ziman> if you snoc 10k times to a DList and then request the first element, does it need 10k operations to retrieve it?
11:03:10 <dolio> So you convert back to lists by 'toList (DList dl) = dl []'.
11:03:15 <roconnor> appending Seqs is O(log n)
11:03:49 <Twey> roconnor: Oh right â€” so DLists completely replace Seqs?
11:04:05 <Saizan> edwardk: i'd be really interested in the resulting patch to uu parsinglib, btw :)
11:04:06 <roconnor> appending for DLists is (1) isn't it?
11:04:13 <roconnor> O91)
11:04:15 <roconnor> O(1)
11:04:17 <ziman> seqs have other efficient operations, like random access, afaik
11:04:34 <roconnor> and Seqs are a memory pig
11:04:35 <dolio> Yes. snoc x (DList dl) = DList (dl . (x:))
11:05:04 <dolio> DList have plenty of bad operations, though.
11:05:16 <edwardk> saizan: i'm about halfway through it and mostly just want to run the code through a pretty printer because its maddening
11:05:29 <edwardk> i';m also very tempted to just start rampantly renaming things
11:06:26 <dolio> For instance, to map a DList, you have to turn it into a list, use map on the list, and turn it back into a DList.
11:06:35 <BONUS> observation: the real magic of ContT as opposed to Cont is the lifting operation. confirm/deny?
11:07:01 <c_wraith> BONUS: That's the magic of all the monad transformers
11:07:15 <roconnor> @src Cont
11:07:15 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
11:07:18 <roconnor> @src ContT
11:07:19 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
11:07:27 <BONUS> yeah but ContT doesn't use the inner monad's >>=
11:07:31 <BONUS> whereas the other ones do
11:07:47 <BONUS> but ContT's lift does use the inner monad's >>=
11:07:59 <dolio> You can rewrite the other ones not to, as well, by CPS transforming them. :)
11:08:09 <BONUS> haha
11:08:21 <roconnor> BONUS: if you only care about efficently, and don't want to make callCC's, then use the Codensity Monad.
11:08:36 <BONUS> ooh what's that
11:08:53 <dolio> It's what I said.
11:08:59 <roconnor> newtype Codensity f a = Codensity {
11:09:00 <roconnor>       runCodensity :: forall b. (a -> f b) -> f b
11:09:02 <roconnor> }
11:09:06 <c_wraith> Also, I think this line of code deserves a rewrite:
11:09:06 <c_wraith> Just `liftM` liftM (flip (,) Foo) $ liftIO $ Bar x y
11:09:07 <roconnor> http://hackage.haskell.org/packages/archive/mmtl/0.1/doc/html/Control-Monad-Codensity.html
11:09:35 <roconnor> BONUS: it is the same as forall r. ContT r m a
11:10:07 <edwardk> ah someone dumped a copy of the codensity monad in another lib, never noticed
11:10:59 <roconnor> edwardk: does the word codensity make your IRC client ding?
11:11:12 <edwardk> hahhahaa
11:11:17 <edwardk> it should
11:11:35 <edwardk> density codensity, kan extension, yoneda lemma, i could throw a lot of little buzzwords in there
11:11:47 <edwardk> but then pumpkin would figure out what they are and start playing a tune on my machine
11:12:43 <roconnor> BONUS: see also the density comonad, ... for when you want the opposite ...
11:13:58 <Berengal> Some day I need to figure out what co- means...
11:14:07 <roconnor> My big realization was that even though the Codensity monad operations don't require f to me a monad
11:14:25 <roconnor> the toCodensity and fromCodensity opertaions do require f to be a monad
11:15:34 <Twey> Berengal: Relevantly, â€˜counterpartâ€™
11:15:41 <Twey> A comonad is a counterpart to a monad.
11:15:43 <edwardk> technically you only need Pointed for lowerCodensity
11:15:58 * roconnor thinks that Codensity needs some MonadReader MonadWriter, etc instances.
11:16:00 <edwardk> so you can lower the codensity of an applicative
11:16:04 <roconnor> edwardk: true
11:16:14 <dolio> liftCodensity is the important one.
11:16:18 <edwardk> roconnor: i just never bothered to write them, send me a patch and i'll ad them
11:16:25 <dolio> Otherwise you may as well be using the identity monad or something.
11:16:29 <roconnor> edwardk: you develop the mmtl?
11:16:30 <edwardk> i need to finish codensity like i did Yoneda
11:16:46 <edwardk> no, i wrote category-extras, which has codensity in it as well
11:16:56 <roconnor> ah right
11:17:00 <edwardk> i presume he copied it because i was missing instances he needed
11:17:07 <roconnor> the category-extras version has some instances
11:18:45 <roconnor> edwardk: I've never seen a codensity that I want to lower that I didn't raise myself.
11:18:54 <roconnor> edwardk: not that I have much experience
11:20:07 <edwardk> yes, but i can make an Applicative codensity out of an Applicative, etc.
11:20:43 <roconnor> but you can't lift to it
11:21:35 <cnwdup> How would one "translate" void gdk_property_change(GdkWindow *window, GdkAtom property, GdkAtom type, gint format, GdkPropMode mode, const guchar *data, gint elements) to a haskell binding? The first argument is troubleing me. I ust Window for that, but chs infers DrawWindow. Does anyone know why?
11:21:48 <cnwdup> s/ust/use/
11:22:22 <roconnor> @quote heels
11:22:23 <lambdabot> musasabi says: <musasabi> no reason to reinvent the whole wheel  <musasabi> (usually reinvented wheels end up square)
11:22:40 <roconnor> @quote heels
11:22:40 <lambdabot> roconnor says: if you click your heels and say ``there is no binding like gtk2hs'' then dcoutts will appear and answer your question.
11:22:49 * Twey laughs.
11:23:35 <dons> that's true.
11:23:38 <dons> he has flying monkeys
11:23:59 <ray> @quote applicative
11:24:00 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
11:25:33 <tiglionabbit_> Is there a kind of map that maps an argument to a list of functions?
11:25:41 <edwardk> hrmm
11:25:50 <c_wraith> sequence?
11:25:52 <BONUS> > map ($ 3) [(+3),(+5)]
11:25:53 <lambdabot>   [6,8]
11:26:06 <c_wraith> well, flip sequence, I think
11:26:15 <c_wraith> @type flip sequence
11:26:16 <lambdabot> forall a b. b -> [b -> a] -> [a]
11:26:30 <BONUS> > sequence [(+3),(+5)] 3
11:26:32 <lambdabot>   [6,8]
11:26:34 <BONUS> lots of ways to go about it :)
11:26:40 <tiglionabbit_> Nice. Btw I'm reading your guide, bonus
11:26:48 <BONUS> nice :)
11:26:52 <BONUS> i am writing it also right nao
11:27:00 <edwardk> newtype C f a = C (forall b. (m (a -> b) -> m b))
11:28:40 <tiglionabbit_> Sweet. I lol'd at quick man. Good work - this is explaining a lot of these features better than other guides. Would be nice if there were exercises though
11:29:07 <BONUS> haha. yeah, i seem to have trouble coming up with them myself
11:29:08 <edwardk> then liftC f = C (f <*>)
11:29:20 <edwardk> and that would be a codensity-like structure for applicatives
11:29:45 <edwardk> but what the heck would it be called
11:29:47 <tiglionabbit_> Looking forward to the monads sections
11:30:18 <edwardk> and there would be a similar construction based on the density comonad using an existential
11:31:06 <edwardk> i guess to borrow from older terminology that 'density and codensity' it would be the 'applicative generated by a functor'
11:31:22 <edwardk> or the 'strong lax monoidal functor generated by a functor'
11:31:30 <edwardk> i smell a blog post
11:31:38 <BONUS> woo!
11:31:56 <tiglionabbit_> Hm, I liked the exercises in K&R's book when I was learning c. Oh and maybe check out hacketyhack for some interesting exercise ideas
11:34:58 <tiglionabbit_> edwardk: Those are some heavy duty terms
11:36:27 <edwardk> tiglionabbit: ask around, folkd here have just accepted that i'm a loon that comes on here and rambles on about something that vaguely resembles category theory
11:36:43 <edwardk> i just choose to use haskell as my language to express this stuff in
11:36:45 <tux-foo> Is there a way I can do this:      (5::Integer)/10^(5::Int)
11:36:54 <tux-foo> i.e. cast 5::Int to an Integer
11:37:11 <c_wraith> fromIntegral
11:37:17 <BONUS> > (fromIntegral (5::Int)) + (1000::Integer)
11:37:19 <lambdabot>   1005
11:37:21 <Twey> tux-foo: (5 :: Integer) / 10 ^ (fromIntegral (5 :: Int))
11:37:35 <tux-foo> Twey, kk, thanx
11:37:58 <edwardk> hrmm, looks like the density version would require coexponentials
11:42:18 <jmccrack_> No instance for (RealFrac Integer)
11:42:21 <jmccrack_> how is this interpreted?
11:42:38 <jmccrack_> Is this a data constructor?
11:42:51 <Twey> It means you're using an Integer somewhere that needs a fractional type (a type capable of representing fractions, like Float or Double)
11:42:54 <vixey> no it's a class
11:42:54 <Taejo> jmccrack_: RealFrac is a typeclass
11:42:55 <jmccrack_> (I mean the (RealFrac Integer) part)
11:43:01 <Twey> No â€” Integer is a type, and RealFrac a class
11:43:06 <Twey> (the class of real, fractional numbers)
11:43:26 <Taejo> jmccrack_: RealFrac has things like truncate, round, ceiling, floor
11:43:51 <Taejo> so you're trying to use one of those on an Integer
11:44:09 <Saizan> jmccrack_: you miss a fromIntegral somewhere
11:44:20 <Saizan> ?type fromIntegral
11:44:21 <lambdabot> forall a b. (Num b, Integral a) => a -> b
11:44:23 <jmccrack_> yeah
11:44:26 <jmccrack_> i'm using it
11:44:34 <jmccrack_> dunno where I'm missing it
11:44:50 <Taejo> do we have a working pastebin these days?
11:45:02 <Saizan> hpaste.org or moonpatio.com
11:45:24 <Taejo> jmccrack_: post your code on one of those
11:46:31 <jmccrack_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4435#a4435
11:46:43 <jmccrack_> I removed the truncate, though
11:46:59 <jmccrack_> now it's complaining about (Fractional Integer)
11:47:26 <jeffersonheard> has anyone ever written a WKT parser for Haskell?
11:47:51 <Saizan> jmccrack_: are you sure you don't want integer division there? i.e. `div` ?
11:47:51 <Taejo> jmccrack_: you're trying to divide an Integer
11:48:14 <Saizan> jmccrack_: that'd make the problem go away, probably
11:48:32 <jmccrack_> ah yes
11:48:34 <jmccrack_> that did
11:48:53 <jmccrack_> but even still, what was I doing wrong? how do i get to a fractional from an integer?
11:49:02 <Saizan> fromIntegral
11:49:20 <Saizan> can you tell us the type of try?
11:50:09 <Saizan> ?type truncate
11:50:10 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
11:50:21 <leimy> > truncate 3.0
11:50:23 <lambdabot>   3
11:50:55 <Saizan> try primes (p:so_far) (truncate (fromIntegral goal/fromIntegral p)) <- i think this should work too
11:51:01 <leimy> whatever happened to the discussion about floating point on computers needing to be in a Monad?
11:51:52 <leimy> or is IEEE float just accepted as a given? :-)
11:52:00 <Saizan> oh, sorry, try was the same function.. so yeah that should work
12:08:46 <jeffersonheard> you know... I've been programming haskell for long enough that when I go back and write python, I find myself writing entirely in list comprehensions and redefining the Prelude
12:09:32 <vininim> iirc, python libraries are quite preludish
12:09:44 <vixey> sounds like you should program haskell
12:09:52 <Berengal> There are some nice tools in functools and itertools...
12:10:11 <jeffersonheard> vixey: yes, generally, except when I don't have the option of installing Haskell on the machine that I'm working on
12:10:43 <jeffersonheard> plus, afaik, no-one has written a WKT parser for Haskell, and this has to be done tomorrow
12:11:47 <Berengal> What's the status of haskell GUIs on windows?
12:12:03 <jeffersonheard> Berengal: gtk2hs works on it just fine
12:12:14 <Berengal> Awesome
12:12:15 <jeffersonheard> only thing i'm not sure about is whether gstreamer works on windows
12:12:25 <jeffersonheard> and gnomevfs
12:12:28 <jeffersonheard> everything else should work
12:13:02 <Berengal> Well, if I was using this on linux I wouldn't have bothered about a GUI
12:13:33 <Berengal> Say, you wouldn't need cygwin or something to make gtk2hs work, would you?
12:13:38 <jeffersonheard> no
12:14:09 <jeffersonheard> you can't cabal-install it, though.  you have to go to http://haskell.org/gtk2hs and download the windows package
12:14:12 <jeffersonheard> it's got an installer
12:14:33 <Berengal> Hmm... I assume there's no way to link that statically?
12:15:11 <jeffersonheard> Berengal, I"m not sure, but you can install it on any machine without installing ghc as well.  It'll whine about some missing environment vars, but you can ignore that
12:15:48 <Berengal> Perhaps I should list my requriements a little more clearly: I've got a program converting text files and I need to be able to put it on a usb and run it directly from there, or copy it over, but no installation in the windows sense
12:16:00 <Berengal> It also needs to be user-friendly, which is why I need a GUI
12:16:32 <edwardk> hrmm that lax type is trickier than i thought
12:16:52 <edwardk> because it doesn't provide the magic needed for return
12:17:00 <tomh> Berengal: a GUI is not user friendly if its not made by people who know what they are doing
12:17:38 <Berengal> tomh: As I said, if it was to be used on linux I wouldn't have made a GUI, I'd have used pipes
12:17:50 <jeffersonheard> Berengal: you can use pipes on windows as well
12:17:54 <tomh> on windows you can do that too
12:18:01 <tiglionabbit_> BONUS: In the fold section you said last is better implemented with pattern matching. How?
12:18:09 <BONUS> uh really?
12:18:10 <Twey> Berengal: No, Gtk2Hs and GTK itself both run fine on Windows.
12:18:24 <BONUS> if i did then it's a mistake, i meant head probably
12:18:25 <BONUS> let's see
12:18:36 <Twey> You may have to include some libraries when distributing, of course.
12:18:40 <Berengal> But a GUI is semi-neccessary, both because the command line sucks compared to bash, and because the windows users who'll be using this will be much less experienced than the linux users
12:19:05 <Berengal> Twey: So static linking/packaging dlls will work?
12:19:06 <BONUS> yeah of course last can't be implemented with simple pattern matching, thanks for pointing that out, i'll fix that on my next uplaod
12:19:08 <jeffersonheard> Berengal, instead of a GUI per-se, why don't you just make it a CGI program and run it on a webserver
12:19:19 <jeffersonheard> everyone prefers web-based GUIs these days anyway
12:19:25 <Twey> Berengal: Yes
12:19:26 <Berengal> jeffersonheard: Did I mention no administrator priviliges?
12:19:40 <tiglionabbit_> Does haskell have an O(1) last? Should be easy if liasts are immutable.
12:19:43 <jeffersonheard> Berengal: no, but you can run a webserver without admin privileges
12:20:10 <jeffersonheard> but then, you could also just station it on some server where you do have admin privs
12:20:23 <tiglionabbit_> Though I doubt it would
12:20:35 <jeffersonheard> and point them to it
12:20:49 <jeffersonheard> *shrug*  I dunno. Just a thought. You have your requirements.
12:20:59 <gigamonkey> BONUS: I'm enjoying your tutorial quite a bit.
12:21:03 <Berengal> jeffersonheard: I don't have a server I could do that on. Also, the machines I'm talking about are rather locked down, not just in the no-admin sense
12:21:03 <BONUS> no, last is O(n). one of the reasons for this is laziness
12:21:06 <BONUS> why thank you :)))
12:21:06 <jeffersonheard> and it sounds like Twey said that you can statically link it
12:21:12 <jeffersonheard> ahh, that makes sense, then
12:21:31 <Berengal> It's just a simple GUI anyway. Select file, press convert.
12:21:41 <BONUS> say you have a list that's take 1000 (iterate some_really_complicated_function 1)
12:21:50 <BONUS> it has to compute the first 999 elements to get the 1000th
12:21:51 <Berengal> And statically linking makes this possible
12:22:07 <jeffersonheard> yep.
12:22:19 <tiglionabbit_> I'm thinking last could be stored whenever a list is created, like length is for strings in other languages
12:22:37 <jeffersonheard> Other thing is that I *believe* that dragging a file onto an executable will cause that executable to be run with that file as its first parameter
12:22:42 <jeffersonheard> on windows
12:22:57 <Berengal> Slightly off topic, but since pipes on windows were used, how would you do "<foobar.txt txt2xml >foobar.xml" ?
12:23:18 <Berengal> were mentioned*
12:23:38 <Berengal> jeffersonheard: Thanks, I'll have to check that out. Could be easier
12:23:39 <jeffersonheard> text2xml.exe <foobar.txt >foobar.xml
12:24:32 <Berengal> Windows has pipes like that? I'm astounded...
12:24:33 <Twey> They're not quite the same as *nix pipes
12:24:36 <Twey> They're strict
12:24:52 <jeffersonheard> Berengel: what Twey said
12:25:04 <Twey> So if you have a particularly big file, you're screwed
12:25:16 <Berengal> Twey: Strict as in read entire file before sending it into the program?
12:25:19 <Twey> Yeah
12:25:38 <Berengal> I won't have large files, probably, but I might have lots of them
12:26:57 <Berengal> Anyway, the help is much appreciated. Thanks :)
12:39:22 <flazz> what is the thesis of the LHC project?
12:40:21 <zoheb> Hi vixey
12:40:39 <gigamonkey> Are there easy ways of dealing with, say, UTF-8 encoded text in a ByteString?
12:40:52 <gigamonkey> A very cursory Hoogling didn't find anything.
12:40:56 <mauke> depends on your definition of "dealing"
12:41:02 <vixey> hey zoheb
12:41:06 <mauke> you can decode it to text
12:41:22 <gigamonkey> meaning to a String
12:41:27 <mauke> yeah
12:41:34 * ski wonders how to implement `allLolli'
12:41:37 <Zao> gigamonkey: The new and shiny Text library is nice.
12:41:55 <zoheb> Anyone knows how to figure out whos throwing an exception from the GHCi debugger
12:41:56 <vininim> hey, I guess a 60%/60% linear classifier isn't that bad
12:42:00 <Zao> http://hackage.haskell.org/packages/archive/text/0.1/doc/html/Data-Text-Encoding.html
12:42:01 <vininim> *baws*
12:42:24 <zoheb> I can't get this haskeline package to work at all
12:42:36 <Zao> Text.Encoding.decodeUtf8 :: ByteString -> Text   and Text.unpack :: Text -> String
12:43:30 <tomh> if you have a function with a guard, the guard fails, will it try the next pattern match?
12:43:37 <mauke> yes
12:43:39 <Twey> Yes
12:43:44 <ski> @let munch :: Eq i => i -> StateT [i] [] (); munch i = do i' <- eat; guard (i == i')
12:43:45 <lambdabot>  Defined.
12:43:45 <zoheb> http://projects.haskell.org/pipermail/haskeline/2009-April/000016.html
12:43:51 <gigamonkey> Zao: cool.
12:43:53 <tomh> ok cool
12:43:55 <Twey> Well, it'll try the next guard first, of course
12:44:17 <tomh> yeah but after all guards are done and no 'otherwise' is specified it just goes to the next pattern match right
12:44:29 <tomh> of the function
12:44:54 <vininim> @type eat
12:44:56 <lambdabot> forall i. StateT [i] [] i
12:45:19 <ski> > (`runLinear` [a,b]) $ foldFood [(+),(*)]
12:45:21 <lambdabot>   [a + b,a * b,b + a,b * a]
12:45:33 <ski> > (`runAffine` [a,b]) $ foldFood [(+),(*)]
12:45:34 <lambdabot>   [a,a + b,a * b,b,b + a,b * a]
12:45:45 <vininim> @type foldFood
12:45:45 <lambdabot> forall i. [i -> i -> i] -> StateT [i] [] i
12:45:59 <vininim> @where culinary
12:45:59 <lambdabot> I know nothing about culinary.
12:46:06 <ski> see about two hours back, for definition of `foldFood' and a few more examples
12:46:56 <ski> well, basically `foldFood' is
12:48:17 <ski>   foldFood ops = do eat
12:48:26 <ski>          `mplus` do (a,b) <- liftM2 (,) `join` foldFood ops
12:48:39 <ski>                     op <- ops
12:48:44 <ski>                     return (a `op` b)
12:48:47 <ski> except working
12:52:39 <Yoric[DT]> Wild guess: anybody from Edinburgh (or, more generally, Scotland) around here?
12:54:42 <solistic> /rant/ why the hell do we have Data.Map.assocs and Data.Map.toAscList ?
12:55:29 <BONUS> i think assocs doesn't guarantee an ascending list
12:55:30 <solistic> /rant/ not to forget about Data.Map.toList
12:55:32 * Yoric[DT] needs help in filling a Scottish application form.
12:55:32 <p_l> Yoric[DT]: You could say that two days ago :P
12:55:42 <Twey> BONUS: No, they're exactly the same
12:55:59 <BONUS> oh rly? ah, didnt know that
12:56:00 <BONUS> interesting
12:56:05 <Yoric[DT]> p_l: well, can I ask you for help in filling that Scottish form?
12:56:12 <Yoric[DT]> I'm somewhat baffled by the vocabulary.
12:56:27 <Twey> Oh wait
12:56:28 <p_l> Yoric[DT]: As long as it's in english, not gaelic
12:56:33 <Twey> No, they're not necessarily
12:56:42 <solistic> BONUS, all three of them are exactly the same
12:56:44 <Twey> elems = assocs
12:56:49 <Twey> By definition
12:56:50 <Yoric[DT]> p_l: well, it looks like English to me.
12:56:55 <Twey> O(n). Return all elements of the map in the ascending order of their keys.
12:56:57 * Yoric[DT] proceeds on /msg.
12:56:59 <Twey> O(n). Return all key/value pairs in the map in ascending key order.
12:57:14 <Twey> But toList doesn't specify any order
12:57:19 <tomh> @src isPrefixOf
12:57:20 <lambdabot> isPrefixOf [] _          = True
12:57:20 <lambdabot> isPrefixOf _  []         = False
12:57:20 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
12:57:24 <Twey> (although GHC does just implement it as toAscList)
12:58:15 <solistic> Twey, but still assocs an toAscList are, per definition the same...
12:58:42 <Twey> solistic: assocs doesn't have to be ordered
12:58:45 <Twey> Er
12:58:47 <Twey> Sorry
12:58:48 <Twey> Yes
12:58:54 <Twey> assocs and toAscList are the same
12:59:06 <Berengal> They are the same, but not by definition ;)
12:59:07 <solistic> /rant/ stupid
12:59:17 <Twey> Berengal: No, by definition
12:59:29 <ski> by possible definition
12:59:29 <solistic> Berengal, why not by def?
12:59:30 <Twey> http://www.haskell.org/ghc/docs/6.8.3/html/libraries/containers/Data-Map.html#14
12:59:37 <Twey> elems = assocs = toAscList
12:59:58 <solistic> Twey: no, elems has a different type
13:00:19 <Twey> Er, yes
13:00:21 <Twey> toAscList is scary
13:00:30 <solistic> how to as lambdabot about type of elems?
13:00:33 <Twey> Definition: O(n). Convert to an ascending list.
13:00:38 <Twey> @type elems
13:00:39 <lambdabot> forall i e. (Ix i) => Array i e -> [e]
13:00:50 <Berengal> Twey: Ah, yes, I was confusing myself...
13:01:00 <Twey> Is that ascending by keys?  Ascending by values?  Ascending by number of monkeys on the trees outside the building?
13:01:06 <solistic> @type Data.Map.elems
13:01:08 <lambdabot> forall k a. M.Map k a -> [a]
13:01:10 <ski> (hm)
13:01:35 <solistic> Twey: by keys
13:01:46 <Berengal> Twey: Who knows. If we take it to be ascending by keys, which is the most likely, then they are the same by definition
13:02:02 <Twey> So the source seems to say, but the definition doesn't specify that
13:02:15 <Berengal> Maybe it's ascending as in "you need to grab hold of it before it flies away"?
13:02:27 <Twey> Could be
13:02:37 <solistic> toAscList does not, assocs does
13:03:50 <tomh> @src any
13:03:51 <lambdabot> any p =  or . map p
13:04:58 <zoheb> what does the exception Prelude.undefined mean?
13:04:58 <roconnor> @. pl src any
13:04:59 <lambdabot> (line 1, column 1):
13:04:59 <lambdabot> unexpected end of input
13:04:59 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:05:00 <Berengal> It's interesting to note how sometimes even extremely small functions can be very helpful...
13:05:10 <roconnor> > undefined
13:05:11 <lambdabot>   * Exception: Prelude.undefined
13:05:28 <roconnor> zoheb: you tried to evaluate undefined
13:05:39 <tomh> @src flip
13:05:39 <lambdabot> flip f x y = f y x
13:06:26 <zoheb> Is undefined equal to bot?
13:06:38 <zoheb> I am actually trying to use a 3rd party library
13:06:41 <roconnor> the semantics of undefined is bottom
13:07:15 <roconnor> the semantic of (fix id) is also bottom
13:07:16 <Berengal> undefined is what you get when you divide by zero, get the first element of an empty list, a value which is itself plus one...
13:07:28 <roconnor> Berengal: that's not true
13:07:36 <roconnor> > 5 `div` 0
13:07:37 <lambdabot>   * Exception: divide by zero
13:07:39 <zoheb> what I am asking is -> will head [] also return the exception Prelude.undefined or someone has explictly used undefined in the source code
13:07:45 <roconnor> > head []
13:07:46 <lambdabot>   * Exception: Prelude.head: empty list
13:07:48 <zoheb> so that I can grep for it
13:07:48 <mauke> zoheb: explicit undefined
13:08:11 <Berengal> roconnor: All of those are bottom
13:08:12 <roconnor> Berengal: those all have the semantics of bottom, but only undefined throws a Prelude.undefined exception.
13:08:36 <roconnor> > error "Prelude.undefined"
13:08:37 <lambdabot>   * Exception: Prelude.undefined
13:08:38 <Berengal> roconnor: How's undefined different from any other exception when they're all bottom?
13:08:52 <Twey> Gives a different message
13:08:54 <Twey> :)
13:09:00 <roconnor> Berengal: when you catch the expection in IO, you can differentate them
13:09:10 <Berengal> Twey: Stop living in the real world :P
13:09:10 <Twey> Oh, truly?
13:09:16 <Twey> Hmnhmn
13:09:20 * Twey laughs.
13:09:28 <Berengal> Both of you
13:09:50 <Berengal> They're all _|_ to me ;)
13:09:50 <zoheb> Any ideas about how to debg an exception in a pre compiled module?
13:09:57 <zoheb> All I get is a Prelude.undefined
13:10:13 <Berengal> zoheb: Got some code?
13:10:22 <zoheb> yes
13:10:31 <Berengal> @paste
13:10:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:10:47 <Berengal> Your code plus the exception, please :)
13:11:04 <zoheb> http://projects.haskell.org/pipermail/haskeline/2009-April/000016.html
13:11:31 <zoheb> I figured out the exception is in getInputLine
13:12:11 <zoheb> I am sorry, I guess you guys wouldn't be haskeline experts :)
13:12:22 <Berengal> Well, I'm not. Someone else might be
13:12:24 <zoheb> But if I can get any kind of debugging tips
13:13:11 <zoheb> the exception is http://mibbit.com/pb/E9jXHr
13:14:26 <roconnor> haskeline 0.6.1.3 ?
13:14:29 <Berengal> Works for me
13:14:36 <zoheb> the latest
13:14:46 <zoheb> I am on Windows Vista
13:15:08 <Berengal> Ah, I'm on Ubuntu 9.04
13:15:13 <Berengal> Seems like this could be a bug
13:15:32 <zoheb> I checked the archives, it looks like they are testing on WIndows
13:15:37 <dons> Sitting in ICFP PC workshop.
13:15:49 <zoheb> I can't even get the sample code up and running
13:16:34 <roconnor> the undefined could be throw from one of the libs that haskeline depends on
13:16:37 <Berengal> How about something even simpler, such as "getInputLine "% " >>= outputStrLn" ?
13:16:49 <zoheb> I can try that
13:17:08 <zoheb> but it fails right away, much before it loops
13:17:28 <Berengal> That's weird
13:18:18 <Berengal> It doesn't really do anything before it loops, except for what's in runInputT...
13:19:57 <zoheb> the debugger showed that it is the getInputLine call thats failing
13:20:39 <zoheb> I know it manages to read the .haskeline file before failing
13:21:34 <zoheb> If I cut and paste the module source code, maybe I can debug deeper, what do you guys think?
13:23:05 <Berengal> I don't know. At this point I'd try to get a hold of one of the haskeline developers and pester him about it
13:23:47 <zoheb> I think there is just one guy, from all the tickets
13:24:01 <zoheb> Have sent a mail, fingers crossed
13:40:58 <Philonous> @hoogle String -> Char -> [String]
13:40:58 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
13:40:59 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
13:40:59 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
13:41:41 <Philonous> @hoogle [a] -> a -> [[a]]
13:41:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
13:41:42 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:41:42 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:41:55 <Gracenotes> :, what would it do?
13:42:24 <Gracenotes> Data.Split maybe?
13:42:50 <Philonous> Is there a function that cuts a list at a given delimiter?
13:42:58 <quicksilver> vixey: Apologies. No offence was intended.
13:43:14 <Gracenotes> @hackage split
13:43:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
13:43:36 <Gracenotes> @type break -- or if you like using this recursively
13:43:37 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
13:44:14 <Philonous> Ah right, thanks. I just keep forgetting that this funcition has it's own module
13:44:37 <Philonous> No, pairs are just fine, thanks
13:49:22 <tibbe__> what's wrong with this type: newtype Iteratee m a = Iteratee { runIter :: Stream -> m (State m a) } ?
13:50:04 <Ferdirand> kind of m ?
13:51:02 <quicksilver> m looks like a monad, so it can't be the first parameter of 'State'
13:51:12 <quicksilver> first parameter of 'State' has kind *
13:51:24 <tibbe__> why?
13:51:33 <Cale> tibbe__: because it's the state type
13:51:38 <Cale> State s m a
13:51:44 <Gracenotes> do you mean StateT?
13:51:51 <Cale> er, StateT, yes
13:51:57 <Cale> Or State s a
13:51:58 <tibbe__> it's similar to stateT yes
13:52:37 <Gracenotes> monad transformers are odd creatures. you either have them or you don't, sort of :)
13:52:50 <lament> Gracenotes: that's... really odd
13:52:54 <badtruffle> lol
13:53:01 <badtruffle> unlike most things, where you sort of have them
13:53:15 <tibbe__> Cale: I don't get it
13:53:30 <lament> sort of have them, but kind of don't
13:53:33 <Gracenotes> :k State
13:53:35 <lambdabot> * -> * -> *
13:53:38 <Gracenotes> :k StateT
13:53:38 <lambdabot> * -> (* -> *) -> * -> *
13:53:56 <quicksilver> tibbe__: the first parameter to state has to be a real, concrete type.
13:53:59 <quicksilver> tibbe__: like Int.
13:53:59 <badtruffle> :k (->)
13:54:01 <lambdabot> ?? -> ? -> *
13:54:02 <quicksilver> tibbe__: or Char.
13:54:03 <Gracenotes> the kind of "m" is (* -> *). We know this because you're applying (State m a) to it
13:54:12 <tibbe__> Gracenotes: sorry: data State m a = Done a Stream
13:54:12 <quicksilver> tibbe__: "m" isn't one of those, in your example.
13:54:12 <tibbe__>                | Cont (m (Iteratee m a)) (Maybe ErrMsg)
13:54:21 <quicksilver> oh.
13:54:27 <quicksilver> now you tell us ;)
13:54:27 <tibbe__> quicksilver: not the state monad
13:54:29 <tibbe__> :p
13:55:40 <monadic_kid> dons: when do you think there will be a second edition to RWH?
13:56:41 <tibbe__> figured it out
14:00:19 <badtruffle> 1	think	151887	mmorrow
14:00:29 <badtruffle> that's the number one repeated word in #haskell
14:00:41 <badtruffle> well, by a specific person
14:01:20 <quicksilver> heh.
14:01:27 <quicksilver> and did he say it 151,887 times?
14:01:28 <roconnor> > cycle "mmorrow "
14:01:29 <quicksilver> that's a lot.
14:01:32 <badtruffle> lol, no
14:01:33 <lambdabot>   "mmorrow mmorrow mmorrow mmorrow mmorrow mmorrow mmorrow mmorrow mmorrow mm...
14:01:39 <badtruffle> I misread, it just said "think" was last used by him
14:02:01 <roconnor> oh
14:02:02 <monadic_kid> @botsnack
14:02:02 <lambdabot> :)
14:02:03 <lunabot>  :)
14:02:05 <roconnor> > cycle "think "
14:02:06 <lambdabot>   "think think think think think think think think think think think think th...
14:02:09 <badtruffle> quicksilver: you're #4 btw :P http://www.cse.unsw.edu.au/~dons/irc/haskell.html
14:02:29 * quicksilver nods
14:02:35 <lament> > intercalate " and " $ replicate 3 "tomorrow"
14:02:36 <lambdabot>   "tomorrow and tomorrow and tomorrow"
14:02:36 <quicksilver> I used to be #2.
14:02:39 <quicksilver> I got a job :(
14:02:41 <badtruffle> aw
14:03:21 <copumpkin> wow, I need to get out more
14:03:37 <copumpkin> I'm almost on the top list
14:03:56 <Berengal> Heh, random lambdabot quote: "ops Help I'm being attacked!""
14:04:04 <quicksilver> copumpkin: you're the most talked about nick
14:04:11 <quicksilver> (ignoring 'has', which isn't primarily used as a name)
14:04:20 <copumpkin> huh?
14:04:36 <quicksilver> "Most referenced nicks : 2 pumpkin 3728"
14:04:41 <quicksilver> ,4,5,7,8,9,10,11,12,13,21,22,24,25,27,31,41,64]
14:04:41 <quicksilver> [#haskell]
14:04:44 <lunabot>  luna: parse error on input `]'
14:04:46 <quicksilver> http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html
14:05:23 <copumpkin> oh crap
14:05:27 <copumpkin> how am I up at the top there
14:05:42 <lament> haha
14:05:47 <lament> most used words are "haskell" and "think"
14:05:53 * lament loves this channel
14:06:16 <copumpkin> that is crazy, I really need to stop using IRC
14:06:45 <lament> "lambdabot has quite a potty mouth. 0.0% words were foul language. Gracenotes also makes sailors blush, 0.0% of the time."
14:07:19 <FunctorSalad> lament: the "think" is from "I think", I reckon...
14:07:26 <Taejo> Gracenotes: that's awful, learn to control yourself
14:07:38 <lament> FunctorSalad: I don't think so...
14:10:15 <Gracenotes> maybe we need a Haskell pisg ;)
14:10:24 <chromakode> pisg?
14:10:36 <Ferdirand> what's the timezone for these stats, btw ?
14:12:26 <burp_> myparser = endBy (many anyChar) eof
14:12:36 <burp_> shouldn't this give me the whole file for a file?
14:12:43 <burp_> (Parsec)
14:12:53 <burp_> instead it says: "parse.hs: Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string."
14:13:36 <FunctorSalad> burp_: mayb'e endBy is implemented through many?
14:13:39 <mauke> I don't know what endBy does but it shouldn't be there
14:13:44 <FunctorSalad> *maybe
14:13:45 <Berengal> burp_: endBy is like sepBy except it can optionally end in the separator
14:14:39 <FunctorSalad> you'd probably want "endBy anyChar eof" or just "many anyChar"
14:14:45 <burp_> hm, true
14:14:55 <Berengal> No, that'd just parse a single char I believe
14:15:00 <FunctorSalad> oops, discount the first
14:15:07 <burp_> "many anychar" does it
14:15:10 <FunctorSalad> I thought it was only "end" not "sep and end"
14:15:17 <burp_> building my thing from ground up ;)
14:15:45 <FunctorSalad> (there is a "sepEndBy" but that's "sep and optionally end by" iirc)
14:15:46 <Berengal> To get the whole file, many anyChar <* eof
14:15:52 <Berengal> Or simply many anyChar
14:16:17 <burp_> sadly http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html does not contain much documentation comments
14:17:08 <Berengal> It seems I got it somewhat wrong
14:17:20 <FunctorSalad> btw is there any good reason the parsec precedence parser is limited to endo-operations? (a -> a, a -> a -> a)
14:17:36 <Berengal> sepBy applies the first, then the second repeatedly until the first one fails, then returns a list of results from the first
14:18:01 <Berengal> endBy does the same, except when the first one fails it uses the second parser one more time, and it needs to succeed.
14:23:41 <Berengal> Some time ago I started going all lisp about haskell on a forum I frequent, and now it seems it's turned into one of the de-facto standard languages there (beside python). I don't know if it was my doing or what, but it makes me feel all fuzzy inside when I think about it.
14:24:51 <lament> nice
14:24:58 <lament> that's not the usual consequence when someone goes all lisp
14:25:09 <lament> i'd probably just get kicked out of said forum :)
14:25:39 <JuanDaugherty> they do tend to be a bit tendentious in #lisp
14:26:18 <monadic_kid> i didn't quite understand the statement, "started going all lisp about haskell"?
14:26:47 <Berengal> I've toned down my evangelicism a bit, but I still go on about it...
14:26:49 <monadic_kid> and become a de-factor standard langauge?
14:27:24 <Berengal> monadic_kid: goAllList foo = repeat (foo ++ "does that better and more elegantly than your language. ")
14:27:30 <Berengal> goAllLisp^:/
14:27:35 * JuanDaugherty mulls defactor lan gauge theory
14:28:06 <Berengal> de-facto = in actuality
14:28:36 <monadic_kid> on some lisp forum you posted that bit of code?
14:29:31 <Berengal> No, I posted "Haskell does that better and more elegantly than your language" repeatedly
14:29:31 <lament> @faq Can Haskell do everything better and more elegantly than my favourite language?
14:29:32 <lambdabot> The answer is: Yes! Haskell can do that.
14:31:11 <Berengal> There's been a steady stream of "Man, I need to learn Haskell!" posts for a while, and the stream of posts going "Man, my brain is all mushy and 'sploded because of Haskell!" is increasing as well
14:31:27 <monadic_kid> what website are you talking about
14:31:38 <Berengal> xkcd :/
14:31:56 <burp_> I love it, I wish I had a small ghci in my pocket for mobile use ;)
14:34:37 <cypher-> re haskell can do what your favourite language does: can you point me at at least one very good GUI application written in Haskell?
14:34:52 <c_wraith> which xkcd strip refers to haskell?
14:35:02 <p_l> c_wraith: there's also the blog of the creator...
14:35:15 <c_wraith> p_l: Who reads that? :P  (thanks)
14:35:16 <Berengal> c_wraith: and the forums...
14:35:48 <burp_>  sepBy (manyTill anyChar (try eol)) eol <- shouldn't this deliver all lines seperated? instead it just delivers the first line
14:35:52 <Berengal> cypher-: I can't, but I did read somewhere that "GUIs in haskell is an embarasement. This is the one domain where we're just as good as everyone else"
14:35:56 <dons> cypher-: leksah
14:36:06 <dons> cypher-: leksah.org, uses a lot of gtk2hs
14:36:21 <Berengal> I wouldn't say leksah is "very good" quite yet. It's awesomely nifty, but still beta...
14:36:34 <dons> it's gui is very good
14:36:48 <dons> == serious effort
14:36:53 <solidsnack> @help
14:36:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:37:02 <solidsnack> @help message
14:37:03 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:37:04 <lament> gmail is beta
14:37:17 <Berengal> dons: Yes, agreed, but it could also be better
14:37:42 <monadic_kid> dons: when do you think there will be a second edition to RWH?
14:37:44 <Berengal> lament: google has it's own definition of beta
14:37:44 <dons> shrug. what do you want? firefox? its as good as any other gui, imo...
14:37:48 <dons> monadic_kid: later this year
14:38:28 <cypher-> dons: thanks
14:38:38 * monadic_kid starts saving his pennies
14:38:55 <cypher-> I'm asking because I wonder about the state of the art
14:39:04 <Berengal> dons: Firefox is one example. I'm not complaining, rather just stating that I feel it'll get much better still, though good it may already be
14:39:33 <cypher-> also, how's integration with other languages?
14:40:27 <mauke> calling C from Haskell is relatively painless
14:40:31 <wli> Sometimes nonelementary, unlike differentiation from other languages. ;)
14:44:01 <sual> Hey guys I was hoping that any programmers could please go and check out my post about my current programming career situation (CodeJustin.com) any feedback/advice will help!
14:44:07 --- mode: ChanServ set +o mauke
14:45:33 <monadic_kid> lol
14:46:07 --- mode: mauke set -o mauke
14:50:58 <laz0r> hi, how can I just one function from a module, when that function is an operator?
14:51:18 <Berengal> laz0r: You mean when you import the module qualified?
14:51:42 <Saizan> laz0r: e.g. M.!
14:51:42 <laz0r> yes
14:52:12 <laz0r> import qualified Graphics.Rendering.OpenGL.GL.StateVar (($=)) <- i tried that, but i does not work
14:52:26 <laz0r> ($=) doesn't work either
14:52:52 <Saizan> what's the error?
14:53:18 <laz0r> anyways, i just noticed that it does not make sense to import it qualified for what I want to achieve, and without qualified it works as expected
14:53:39 <Saizan> you've to type Graphics.Rendering.OpenGL.GL.StateVar.$= if you leave it like that
14:53:47 <laz0r> the error is either a syntax error in the later case, or the compiler does not find the operator in the former case
14:56:21 <laz0r> ah, of course it doesn't find the symbol as long as I still import it qualified, but don't use the GL. or whatever prefix
14:56:43 <laz0r> however, problem is solved
14:57:02 <edwardk> ok, _almost_ have the uu parsinglib stuff recoded
14:57:52 <wli> A lot of times I'll import qualified with a short name like Map, Set, IntMap, IntSet, Seq, etc., except for infix operators I import unqualified and some constructors that rarely clash.
14:58:44 <wli> import Data.Sequence(Seq,(><),(|>),(<|))
14:58:52 <wli> import qualified Data.Sequence as Seq
15:00:08 <wli> import Data.Sequence(Seq,(><),(|>),(<|),(:>),(:<)) even maybe.
15:01:00 <Berengal> Is haskell running out of characters for new operators?
15:01:12 <wli> Not that I'm aware of.
15:01:21 <kerlo> @index (~)
15:01:22 <lambdabot> bzzt
15:01:24 <kerlo> No.
15:01:45 <mauke> ï¼µï½Žï½‰ï½ƒï½ï½„ï½…ï¼
15:02:03 <byorgey> wli: that's a nice idea.
15:02:07 <Cale> ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ‰
15:02:14 <Berengal> What's the haskell stance on unicode in source though?
15:02:21 <hatds> have they ever considered allowing even just regular letter in operators?
15:02:27 <mauke> IRON HORSE STANCE
15:02:34 <Cale> Berengal: It should be accepted in GHC.
15:02:42 <byorgey> hatds: well, the problem is that would greatly complicate parsing.
15:03:04 <solidsnack> @tell Baughn Let me know how your project turned out.
15:03:05 <lambdabot> Consider it noted.
15:03:09 <hatds> byorgey: really? even if it has to start with a non-letter?
15:03:28 <byorgey> hatds: yup.  how should this be parsed:  (x+y)
15:03:40 <hatds> good point
15:03:40 <byorgey> if you allow letters in operators, that might be an operator section (x +y)
15:03:44 <kynky> like \n
15:04:31 <byorgey> hatds: parsing Haskell is already complicated enough ;)
15:04:47 <da-x> is the sqlite package in hackage working for anyone?
15:05:34 <da-x> I can't install it for some reason with cabal, and also, runghc Setup.hs breaks for me,
15:06:32 <mauke> I just cabal'd it
15:06:37 <da-x> already, -v shows "Missing header file: sqlite3.6"
15:07:15 <da-x> libsqlite3-dev is installed in ubuntu
15:07:38 <da-x> there's a sqlite3.6 dir inside the package
15:07:51 <da-x> it contained one .c file
15:08:33 <da-x> guess it's trying to build the builtin sqlite3 but it doesn't work
15:09:48 <da-x> whoa! this worked: cabal install sqlite  --flags="-builtin-sqlite3"
15:09:57 <Baughn> @tell solidsnack Temporarily shelved due to exams. That, and for further research - reading the REST thesis, for one,
15:09:57 <lambdabot> Consider it noted.
15:11:24 <Baughn> @tell solidsnack (Also, it turned out I'll have to rewrite a fair bit of the GHC network stack)
15:11:24 <lambdabot> Consider it noted.
15:24:07 <Lemmih> @tell thoughtpolice Pass me a mail when you feel like hacking on LHC. I'm sure we can shake out some great solutions working together.
15:24:07 <lambdabot> Consider it noted.
15:32:19 <wli> They're also too dumb to give chase effectively.
15:32:45 <edwardk> ok, woot, got the cleaned up uu-parsinglib stuff to compile
15:36:57 <solistic> Does somebody know where I can get DrIFT by John Meacham? The links on his homepage are brocken.
15:41:28 <kadaver> anyone played with open vision?
15:41:38 <kadaver> is haskell fast enough for alrge scale image processing?
15:46:35 <tomh> most likely
15:47:25 <edwardk> hrmm somewhere along the way i think i broke something in the parsing lib
15:47:36 <edwardk> meh, i'll take it home and beat on it
15:50:52 <mdmkolbe> Any lhs2TeX experts here?  Is there a way to have it outline all \begin{code}\end{code} blocks in the resulting TeX/PDF file?
15:56:18 <kadaver> if java isnt fast enough or memory-efficient, is haskell?
15:56:46 <xcthulhu> mdmkolbe:  You need to use the listings package
15:57:13 <Berengal> kadaver: according to the language shootout, they're about equally fast. Those benchmarks have been properly profiled though
15:58:08 <mdmkolbe> xcthulhu: you mean this? http://www.pvv.ntnu.no/~berland/latex/docs/listings.pdf
15:58:24 <xcthulhu> That's the one :)
15:58:36 <xcthulhu> Let me see what I have in my preamble that makes this happen
15:58:41 <xcthulhu> one sec...
16:02:12 <xcthulhu> mdmkolbe:  To get a box around my code I use \lstnewenvironment{code}{\lstset{frame=single,aboveskip=10pt}}
16:02:54 <xcthulhu> But the listings docs have much more elaborate options I recall
16:08:59 <mdmkolbe> xcthulhu: hmm... tex is giving me greif.  Are you sure that is the complete line?
16:09:07 <kadaver> is ghc available on bsd?
16:09:47 <mdmkolbe> xcthulhu: I found it.  A {} as missing at the end
16:14:05 <MyCatVerbs> kadaver: on OpenBSD and FreeBSD, yes. OpenBSD's version is somewhat out of date, last time I checked, but can be used to bootstrap compile the newer versions.
16:16:53 <cypher-> hmm.. what would be the nicest way to generate a lists of lists, where i-th list contains n-th character from a string, starting at i, for some given n?
16:17:08 <vixey> what??
16:17:35 <cypher-> so "qwerty" with n = 2 -> [ "qet", "wry" ]
16:18:08 <cypher-> hmm.. I didn't phrase it quite well LOL
16:18:16 <vixey> wand "qwert" with n = 2 gives [ "qet" , "wr" ] ?
16:18:28 <Olathe> map (:[]) "qwerty"
16:18:30 <Olathe> > map (:[]) "qwerty"
16:18:32 <lambdabot>   ["q","w","e","r","t","y"]
16:18:53 <vixey> > transpose  ["q","w","e","r","t","y"]
16:18:54 <lambdabot>   ["qwerty"]
16:19:06 <burp_> Text.ParserCombinators.Parsec.Prim.many: combinator 'many' is applied to a parser that accepts an empty string.
16:19:09 <burp_> why is that a problem?
16:19:23 <vixey> > transpose [ "qet", "wry" ]
16:19:23 <c_wraith> because it doesn't know how man empty strings you meant right there
16:19:24 <lambdabot>   ["qw","er","ty"]
16:19:32 <vixey> > transpose ["qw","er","ty"]
16:19:33 <lambdabot>   ["qet","wry"]
16:19:34 <c_wraith> how many*
16:20:56 <Olathe> > let f n xs = map concat . transpose . takeWhile (not . null) . map (take n) . iterate (drop n) . map (:[]) $ xs in f 2 "qwerty"
16:20:58 <lambdabot>   ["qet","wry"]
16:21:03 <Olathe> > let f n xs = map concat . transpose . takeWhile (not . null) . map (take n) . iterate (drop n) . map (:[]) $ xs in f 3 "qwerty"
16:21:05 <lambdabot>   ["qr","wt","ey"]
16:21:21 <burp_> well, for each char the parser can apply it, so many $ return "" should result in an empty string
16:21:52 <vixey> cypher = transpose . chunk n
16:21:52 <c_wraith> but it can match the empty string unlimited times in a row
16:22:06 <c_wraith> It's an ambiguous grammer
16:22:41 <c_wraith> because the same input can generate <empty><empty>"foo" or <empty>"foo"
16:22:50 <kadaver> hmm what do you think of writing a Desktop on top of the linux kernel purely in haskell?
16:23:10 <burp_> hm, yes
16:23:38 <Olathe> kadaver: There's xmonad.
16:23:54 <Olathe> kadaver: Unless you mean an X replacement or something.
16:24:01 <burp_> didn't think of the parser passing empty strings around
16:24:16 * da-x must learn haskell before the swine flu gets him.
16:24:17 <cypher-> vixey: what module is chunk in?
16:24:47 <wli> da-x: What sorts of questions do you have?
16:25:12 <burp_> @faq can haskell save from swine-flu danger?
16:25:12 <lambdabot> The answer is: Yes! Haskell can do that.
16:26:24 <Olathe> > let chunk n = takeWhile (not . null) . map (take n) . iterate (drop n) in chunk 2 "hello"
16:26:26 <lambdabot>   ["he","ll","o"]
16:26:32 <Olathe> I don't think it's in any of the standard libraries.
16:26:51 <vixey> > (transpose . chunk 2) "qwerty"
16:26:52 <lambdabot>   Not in scope: `chunk'
16:27:00 <vixey> @let chunk n = takeWhile (not . null) . map (take n) . iterate (drop n)
16:27:02 <lambdabot>  Defined.
16:27:02 <vixey> > (transpose . chunk 2) "qwerty"
16:27:03 <lambdabot>   ["qet","wry"]
16:27:08 <da-x> wli: mainly about grasping monad-related concepts.
16:27:23 <wli> da-x: Sure. Like what?
16:30:00 <cypher-> great! thanks!
16:30:29 <da-x> wli: for example, how/where monad nesting helps. I'd need some good examples for it.
16:30:54 <wli> da-x: Monad nesting being monad transformer stacks?
16:31:02 <da-x> wli: yes
16:32:38 <wli> da-x: StateT over IO is pretty easy for repls.
16:34:46 <kadaver> is X-monad a desktop environment?
16:34:57 <da-x> okay, I'll read http://haskell.org/haskellwiki/Simple_StateT_use then.
16:34:58 <kadaver> i thought it was just a window manager(which btw im nott entirely sure what that is)
16:35:18 <sclv> kadaver: it is just a window manager.
16:37:06 <wli> da-x: I'd just maintain an environment of variables.
16:37:57 <wli> da-x: Parse each line and carry out assignments or variable deletions.
16:38:42 <Gracenotes> @botsnack
16:38:42 <lambdabot> :)
16:38:42 <lunabot>  :)
16:39:25 <da-x> wli: I was reading the code of hparse the other day and was particularly impressed with how the query string is evaluated into the parameters of the handler functions. pretty nice
16:43:45 <zoheb> for what its worth
16:44:12 <zoheb> let chop = (\n s -> zipWith ($) (map drop [0..n-1]) $ replicate n s)
16:44:19 <zoheb> @let chop = (\n s -> zipWith ($) (map drop [0..n-1]) $ replicate n s)
16:44:20 <lambdabot>  Defined.
16:44:53 <skorpan> > chop [1,3]
16:44:54 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
16:44:56 <wli> da-x: Okay.
16:44:59 <skorpan> > chop 4
16:45:00 <lambdabot>       Overlapping instances for Show ([a] -> [[a]])
16:45:01 <lambdabot>        arising from a use...
16:45:06 <skorpan> i don't get it
16:45:21 <zoheb> chop 4 "hellooo"
16:45:29 <zoheb> >chop 4 "hellooo"
16:45:50 <zoheb> let final = (\n s -> (map ((\n s -> map snd $ filter (\(x,y) -> x `mod` n == 0) $ zip [0,1 ..] s) 3)) $ chop n s) 3 "fdsfhndgfjvkujdfhgghbklfd"
16:46:05 <zoheb> > final 5 "qwertyuiopsafd"
16:46:07 <lambdabot>   Not in scope: `final'
16:46:20 <zoheb> @let final = (\n s -> (map ((\n s -> map snd $ filter (\(x,y) -> x `mod` n == 0) $ zip [0,1 ..] s) 3)) $ chop n s) 3 "fdsfhndgfjvkujdfhgghbklfd"
16:46:21 <lambdabot>  Defined.
16:46:23 <zoheb> > final 5 "qwertyuiopsafd"
16:46:24 <lambdabot>   Couldn't match expected type `t1 -> [Char] -> t'
16:46:36 <mmorrow> > final
16:46:37 <lambdabot>   ["ffdjufgkd","dhgvjhhl","snfkdgbf"]
16:46:58 <zoheb> my soln seems a lot uglier
16:46:58 <mmorrow> > chop 5 "qwertyuiopsafd"
16:46:59 <lambdabot>   ["qwertyuiopsafd","wertyuiopsafd","ertyuiopsafd","rtyuiopsafd","tyuiopsafd"]
16:48:01 <skorpan> looks like that could be done using some variant with scan
16:48:11 <mmorrow> > take 5 . tails $ "qwertyuiopsafd"
16:48:12 <lambdabot>   ["qwertyuiopsafd","wertyuiopsafd","ertyuiopsafd","rtyuiopsafd","tyuiopsafd"]
16:48:26 <skorpan> or tails... :|
16:48:57 <zoheb> :t tails
16:48:58 <lambdabot> forall a. [a] -> [[a]]
16:49:18 <mmorrow> > (\x -> take 5 . iterate ($ x) . fmap drop $  [0..]) "qwertyuiopsafd"
16:49:19 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
16:49:19 <lambdabot>      Proba...
16:49:32 <mmorrow> > (\x -> take 5 . iterate ($ x) (fmap drop [0..])) "qwertyuiopsafd"
16:49:33 <lambdabot>       Occurs check: cannot construct the infinite type: b = a -> b
16:49:33 <lambdabot>      Proba...
16:49:35 <skorpan> so haskell has tails, but not a "generic" split function?
16:49:54 <mmorrow> > (\x -> take 5 . fmap (($ x) . drop) [0..]) "qwertyuiopsafd"
16:49:55 <lambdabot>   Couldn't match expected type `a -> Int'
16:50:00 <mmorrow> > (\x -> take 5 $ fmap (($ x) . drop) [0..]) "qwertyuiopsafd"
16:50:01 <lambdabot>   ["qwertyuiopsafd","wertyuiopsafd","ertyuiopsafd","rtyuiopsafd","tyuiopsafd"]
16:50:05 <mmorrow> epic
16:50:19 <skorpan> i hate you
16:50:20 <zoheb> didnt know about tails
16:51:23 <mmorrow> > let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (`elem`",.") "127.0.0,1"
16:51:23 <mmorrow> @bot
16:51:23 <lunabot>  :)
16:51:23 <mmorrow> , let split _ [] = []; split p xs = let (ys,zs) = break p xs in ys : split p (drop 1 zs) in split (`elem`",.") "127.0.0,1"
16:51:23 <lunabot>  ["127","0","0","1"]
16:52:34 <glguy> > inits "what about this one?"
16:52:34 <lambdabot>   ["","w","wh","wha","what","what ","what a","what ab","what abo","what abou"...
16:52:35 <lambdabot> :)
16:52:36 <lambdabot>   ["127","0","0","1"]
16:52:40 <gOcOOl> is there a way to get ghci to display some help text for arbitrary functions ala man pages?
16:53:10 <mmorrow> gOcOOl: no, the closest you can get is ":info foo"
16:53:38 <mmorrow> which just tells you what module it's defined in above :T
16:53:41 <mmorrow> :t
16:54:46 <gnuvince_> @type forever
16:54:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:54:55 <Gracenotes> :.
16:56:27 <wli> da-x: Did you happen to want a concrete example of StateT usage?
16:57:56 <maltem> gOcOOl, you can do :!hoogle --info foo
16:58:13 <maltem> if you have hoogle installed, of course
16:58:41 <maltem> and you'll probably have to fully qualify foo
16:59:36 <gOcOOl> how do I install hoogle? is it available through my OS's package manager or something?
16:59:41 <da-x> wli: in a big program, along with other transformers? that can be useful.
17:00:56 <wli> da-x: Probably the easiest thing I can think of to do on that front is a calculator where one can save the results in named variables.
17:02:03 <maltem_> gOcOOl, obviously I don't know about your OS
17:02:09 <da-x> wli: e.g. in a Map String Float ?
17:02:15 <wli> da-x: Does that sound like the sort of thing that would help you along?
17:02:17 <maltem_> but you can download it from hackage, or cabal-install it
17:02:20 <wli> da-x: Yeah.
17:03:44 <da-x> yeah, I understand how it can be implemented.
17:17:45 <gOcOOl> I'm using Ubuntu linux and I don't see any cabal/cabal-install package
17:18:01 <gOcOOl> I guess I need to manually download and install it
17:18:09 <gOcOOl> does that sound right?
17:18:28 <Zao> gOcOOl: There's a bootstrap.sh script in the cabal-install tarball.
17:18:45 <Zao> Running that will grab all the packages it depends on and build/install it.
17:18:58 <mauke> that's the "manually download and install" part
17:19:10 <mauke> I don't know if you have to do it
17:22:53 <Cale> gOcOOl: yes
17:23:25 <Cale> gOcOOl: In fact, since Ubuntu's GHC package is way out of date now, it might be a good idea to install the generic linux binary of that at some point too.
17:23:47 <Cale> gOcOOl: But if you're just starting out, it probably won't make a huge difference to you
17:26:24 <Cale> gOcOOl: You can get it from... http://hackage.haskell.org/packages/archive/cabal-install/0.6.2/cabal-install-0.6.2.tar.gz
17:26:39 <Cale> gOcOOl: That package will include a bootstrap.sh which should get you set up
17:27:13 <Cale> If it complains about missing libraries, and you're using ubuntu's GHC, you can install the various corresponding libghc6-*-dev packages
17:29:21 <andresj> hello, do any of you use Haskell for graphic applications? (anything that outputs to screen&possibly can print, not only widgetsâ€”altho info on that would help too)  What library do you use? I'm trying to find a cross-platform library that is mantained.
17:31:19 <kadaver> andresj: i have just done simple stuff
17:31:24 <kadaver> but opengl+gsl
17:32:23 <andresj> haha, thank you; how was the performance on that? I am looking for a graphics library that, to give a comparison, could run Firefox or Safari.
17:32:41 <gOcOOl> Cale: I got as far as installing the various libghc6-*-dev packages, running bootstrap.sh now fails with Configuring HTTP-4000.0.4... Setup: At least the following dependencies are missing: mtl -any""
17:32:57 <gOcOOl> any clue as to what might be wrong?
17:33:30 <gOcOOl> ah, never mind, I'm missing the libghc6-mtl-dev
17:33:32 <blackh> gOcOOl: You need a package called libghc6-mtl-dev
17:34:10 <kadaver> andresj. you mean GUis? i have dome some stuff with GTK
17:34:38 <andresj> kadaver: well, i meant everything BUT the GUIs, lolâ€”the rendering the web page part
17:36:23 <Zao> Isn't it nice how debianbuntu splits everything up into a bazillion packages.
17:40:42 <Gracenotes> Acquired: 4 (four) Lowfat Fig Newtons
17:41:42 <povman> "Reactive should work okay as soon as GHC 6.10.2 is released" <-- is this true?
17:42:05 <ryanakca> @src sortBy
17:42:05 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
17:42:49 <Gracenotes> ryanakca: that is insertion sort. the actual sortBy uses mergesort
17:43:33 <Cale> povman: There are bugs, but for the most part you can get it to work if you install the correct versions of things.
17:43:45 <ryanakca> Gracenotes: Thanks. To use it... I'd go what, ``import Data.List (sortBy)'' ?
17:44:07 <povman> Cale: Cool. Are there details anywhere on exactly what does and doesn't work?
17:44:13 <Gracenotes> sure. Or, "import Data.List", which usually doesn't introduce any namespace clashes
17:44:25 * ryanakca nods, thanks
17:44:36 <Cale> povman: One moment and I'll make you a list of what works for me
17:45:06 <Cale> Actually, I'm using 6.10.1
17:45:33 <povman> oh wow
17:45:42 <Gracenotes> ryanakca: it might stack-overflow for very large data sets, but is reasonable efficient for a singly-linked-list sort
17:45:42 <povman> I have been deceived!
17:46:11 <ryanakca> Gracenotes: *nod*, thanks
17:46:14 <Cale> (I don't like 6.10.2 because of the ghci brokenness
17:46:17 <Cale> )
17:46:30 <ryanakca> I don't think I need to worry about that just yet, I'm not using it for anything serious, just an early RWH problem :)
17:46:35 <povman> ee, i'm scared now
17:46:47 <Saizan> isn't ghci broken on 6.10.1 too?
17:46:54 <Gracenotes> okay :)
17:46:55 <Cale> ghci segfaults on Ctrl-C in 6.10.2
17:46:59 <Cale> but not in 6.10.1
17:47:09 <Saizan> oh, nice
17:47:23 <Cale> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4439#a4439
17:47:40 <povman> Cale: Awesome, thanks for that
17:47:41 <dolio> They're planning a 6.10.3 due to that, apparently.
17:48:03 <povman> I'm super keen to get my game prototype going and I want to use Reactive if possible
17:48:40 <Cale> I've run into a few difficulties with Reactive that I'm not sure how to solve
17:48:49 <Cale> I've submitted bug reports about them though
17:49:08 <Cale> But I'm not yet doing anything so serious with it, just playing around
17:50:14 <ivanm> dolio: isn't .3 going to use haskelline or something?
17:50:27 <Cale> yeah
17:50:30 <dolio> That's what I hear.
17:50:40 <Cale> Because editline sucks
17:50:50 * Lemmih seconds that.
17:51:09 <kadaver> povman: what kind of game?
17:51:26 <povman> kadaver: A side scrolling platformer
17:51:38 <povman> kadaver: Except... AWESOME
17:52:21 <ivanm> Lemmih: which comment? the "editline sucks" one?
17:53:50 <kadaver> cool
17:53:50 <kadaver> i was getting starting on a shmup(2d-scroller shoot em up) but havent really got going with it
17:53:58 <Lemmih> ivanm: Yes, I'm still amazed that they released GHC with a nearly defunct ghci.
17:54:44 <ivanm> Lemmih: I'm guessing someone pretty influential was complaining behind the scenes about licensing issues with readline, so they quickly found the best alternative available...
17:54:53 <Cale> Not to mention that even when editline is mostly working it has absolutely ridiculous behaviour
17:54:59 <sjanssen> part of the reason I'm still on 6.8.2 is editline
17:55:16 <ivanm> tbh, the only problem I've had with editline is it's behaviour in emacs with literal ^J characters
17:55:36 <ivanm> sjanssen: well, I know that here in gentoo kolmodin has applied his readline patch to 6.10.* ...
17:55:36 <Cale> Like, what would you expect typing  abc<del>d to produce at the end of a line? If you guessed adb, you're right!
17:55:51 <Saizan> well, the fact that it doesn't handle multi-byte chars is pretty silly too
17:56:06 <ivanm> Cale: you're serious? del == delete previous char and move back a char? :s
17:56:12 <Cale> ivanm: yeah
17:56:20 <ray> kadaver: wait until i release my library :P
17:56:26 <solistic> editdilne just does not read your inputrc, that is the main problem, it behaves like it wants to behave, _not_ like you want it to behave
17:56:38 * ivanm wonders why the editline devs ever made a release if it's that buggy...
17:56:38 <povman> ray: ?
17:56:57 <ivanm> solistic: ummm.... I don't even have an inputrc...
17:57:14 <ivanm> I take it, however, that it's meant to be how you customise editline?
17:57:35 <ivanm> oh, you mean /etc/inputrc ?  since it's for readline, why _should_ editline read it?
17:58:15 <gnuvince_> Speaking of readline, here's a question: is it like ledit, but written in Haskell?
17:58:22 <solistic> ivanm, i also do not have one, otherwise ghci would behave different to say my shell, that is what I mean, I adopt to the software (== editline) not the software to me. software should save humans, not the other way around
17:58:24 <Cale> gnuvince_: what?
17:58:31 <Cale> gnuvince_: readline is a C library
17:58:42 <Cale> gnuvince_: There's a Haskell binding to it though
17:58:50 <ivanm> heh
17:58:50 <gnuvince_> Cale: I mean functionally.
17:59:18 <gnuvince_> Cale: I think I read that it gives you a command history, emacs- and vi-like keybindings and what not.
17:59:19 <Cale> gnuvince_: It's used to read lines of text and keep track of history, like, say the bash prompt.
17:59:27 <gnuvince_> Oh wai
17:59:50 <gnuvince_> wait*, I forgot the word "haskeline" from my original query
18:00:01 <Cale> haskeline is similar to readline
18:00:06 <gnuvince_> 
18:00:07 <gnuvince_> 
18:00:09 <gnuvince_> OK
18:00:11 <gnuvince_> Thanks
18:00:32 <ray> haskeline is its own library, not C bindings, right?
18:00:52 <Cale> right
18:00:55 <ray> povman: i'm working on a shooting game library (sorta)
18:01:20 <povman> ray: like ClanLib?
18:01:33 <ray> no
18:01:56 <gnuvince_> But Haskeline provides the same kind of functionality as readline or ledit, right?  History, emacs and vi keybindings and what not
18:02:03 <ray> more like bullet pattern combinators
18:02:10 <gnuvince_> (actually, I'm not sure ledit provides vi-like key bindings)
18:03:22 <BMeph> Haskeline: Is that Haskell mixed with gasoline, or Vaseline? ;)
18:03:56 <mmorrow> Valvoline iirc
18:05:40 <mmorrow> ghci os using haskeline starting next release i believe
18:05:46 <mmorrow> *ghci is ...
18:05:54 <ivanm> with PatternSignatures being replaced with ScopedTypeVariables, is this backwards-compatible? or 6.10 only?
18:06:14 <povman> ghci would make a terrible command shell
18:06:49 <ivanm> use lambdashell or something then
18:06:58 <Saizan> gnuvince_: it's a clone of readline, yes
18:07:20 <Saizan> ivanm: 6.10 only
18:07:52 <ivanm> Saizan: hmmmm.... so what should I do in terms of backwards compatability? leave PatternSignatures in for now? or forget compatability? :s
18:08:54 <younder> Do you all use darcs?
18:09:11 <Saizan> ivanm: leave it there :)
18:09:22 <ivanm> Saizan: heh
18:09:25 <ivanm> younder: a lot of us do
18:09:30 <ivanm> some don't for various reasons
18:10:42 <povman> I tried doing a darcs rec on 64M of new stuff and it didn't complete before I got bored
18:10:49 * younder ponders the use of zink in organ pipes for the 'right' resonance
18:11:33 <ivanm> povman: :o
18:11:39 <ivanm> as in binary data?
18:12:33 <povman> well it was /etc, some of it might have been binary
18:12:59 <povman> I didn't really look into it or report it. It used a lot of processing the whole time, too
18:14:03 <younder> ivanm: Well I have 6 (no less) version control sytems on my system. CVS, SVN, DARCS, GIT..
18:14:27 <glguy> lose data to darcs once, shame on me. lose data to darcs twice, I'm not going to lose data again...
18:14:31 <glguy> ;)
18:14:33 <ivanm> I have a lot too, but I personally only use darcs
18:14:47 <povman> I personally find Darcs to be the easiest to use of them all
18:15:01 <ivanm> povman: that's true from what I've seen
18:15:03 <povman> and git the hardest...
18:15:05 * glguy mixed up intentionally mixing that up :)
18:15:17 <ivanm> glguy: heh
18:16:49 <ivanm> Saizan: is RecordPuns only deprecated for 6.10 as well?
18:17:20 <Saizan> ivanm: i don't know
18:17:30 <ivanm> hmmm...
18:18:01 <povman> Here we go, just did { darcs init; darcs add * -r; darcs rec } on 27M of source & binaries, and it's stuck on "Removing from pending: 3880/4951"
18:21:52 <ivanm> hmmm.... where is the syntax, etc. for top-level module comments like Description, Maintainer, etc. for haddock defined?
18:22:46 <mmorrow> povman: yeah, darcs is painful when you add large amounts of data (large := (> 5/10M)
18:23:27 <povman> mmorrow: Moral: release early and often!
18:23:42 <mmorrow> weee
18:23:45 <wli> da-x: Still there?
18:25:19 <mmorrow> whenever i need to vcs binary and/or large amounts of data i use git, and for source code i use darcs
18:25:48 <mmorrow> darcs stores more information about the history from what i understand
18:26:11 <mmorrow> as in, git's history is lossy
18:27:07 <younder> I have no experience with GIT
18:27:34 <younder> But I have with CVS, SVN, and DARCS
18:29:27 * ksf bows to http://www.lmcs-online.org and open access in general
18:32:07 <i_tweedl3_dee_i> hello
18:34:06 <Cale> hi
18:35:02 <MyCatVerbs> 'lo Cale.
18:36:13 <ivanm> Cale: obviously you didn't respond fast enough to i_tweedl3_dee_i's "hello"!
18:36:17 <younder> I am here, but I am probably the worst person to ask as i am a total Haskell beginner myself
18:36:23 <ivanm> you should have replied _instantly_! not a minute later! :p
18:39:36 <MyCatVerbs> It was a minute fifty nine, according to my client.
18:40:12 <younder> whatever
18:45:22 <ksf> we could teach lambdabot how to nurse people like i_tweedl3_dee_i.
18:45:43 <ksf> otoh, she's got her dignity.
18:47:09 <mmorrow> @vixen do you dig the nitty-gritty?
18:47:09 <lambdabot> maybe. do you?
18:47:35 <ksf> mmorrow, you can git git's history.
18:47:35 <olsner> @vixen do you grit the nitty-diggy?
18:47:35 <lambdabot> i do occassionally, i guess
18:47:37 <mmorrow> @vixen that's what you are, but what am i?
18:47:38 <lambdabot> who's to say?
18:48:11 <younder> Ahh, a genuine AI
18:48:15 <kadaver> ray: what lib?
18:48:21 <mmorrow> ksf: but will you then need to git git's history that you just gitted?
18:48:24 <ivanm> @vixen are you human or a bot?
18:48:24 <lambdabot> no, how dare you ask if i'm a bot!
18:48:32 <younder> I might be able to provide that
18:48:37 <ivanm> @vixen do you think you can pass the Turing test?
18:48:37 <lambdabot> maybe. do you?
18:48:40 <ivanm> heh
18:48:40 <ksf> well, you can have them git each other.
18:49:02 * ivanm thinks that response was one of the only legitimate ones @vixen has come out with
18:49:10 <mmorrow> ksf: what the "they" here?
18:49:22 <ksf> in the end, you still have to publish your latest hashes regularily in newspapers to be half-way certain you didn't forge anything.
18:49:22 <younder> perhaps not
18:49:30 <mmorrow> ah, so you're saying each repo includes within it the history of the other?
18:49:51 <ksf> you can include the hashes of the history in the first git level...
18:49:58 <mmorrow> might as well include every repo's history within itself
18:50:00 <mmorrow> hmm
18:50:01 <younder> sigh
18:50:42 <mmorrow> ksf: i wonder if there's a general way to bootstrap any vcs into a completely lossless one using some strategy like this
18:51:01 <mmorrow> (i'm not sure though yet if this method even works in the first place though..)
18:51:09 <younder> use git
18:51:33 <younder> or better still DARCS
18:52:10 <glguy> or even better still, git
18:52:21 <Zao> hg!
18:52:33 <Zao> While we're throwing random DVCS names around :)
18:52:40 <ksf> you can always come up with things like your dog injecting code using a password your cat sniffed, in conjunction with your hamster washing your brain and your parrot being an illuminati and replacing all newspapers with newspapers with the "correct" hashes.
18:52:47 <younder> I have no experience wit git
18:53:08 <younder> so that might be true
18:53:29 <ivanm> Zao: TLA!
18:53:44 <younder> ARTWARK!
18:54:23 <younder> lol
18:54:33 <ivanm> younder: is that a real DVCS?
18:54:39 <younder> nop
18:54:50 <ivanm> wikipedia doesn't seem to think so...
18:54:55 <davidL> dons: was the workshop today video taped?
18:55:49 <younder> ivanm: I take it you men a Distributed Version Control System
18:55:54 <younder> mean
18:56:05 <ivanm> younder: yes
18:58:37 <wli> da-x: Well, I wrote an example for you.
19:09:26 <mmorrow> ksf: what are we talking about? i'm talking about how the graph of changes in git isn't retained in its entirety, while with darcs it is. (this is my understanding)
19:09:52 <mmorrow> i can't seem to find this camp demonstration video (youtube?) that i'm thinking of that illustrates this
19:10:08 <mmorrow> and i can't remember the example used in that
19:10:46 <gwern> (it was hosted on youtube yah)
19:10:50 <gwern> @seen Igloo
19:10:51 <lambdabot> Igloo is in #darcs, #ghc and #haskell. I last heard Igloo speak 3h 10m 20s ago.
19:11:02 <gwern> mmorrow: ask him when he comes back on? he does camp
19:11:05 <mmorrow> so i'm pretty sure that git'ing a repos history isn't enough for git to retain this, since you're git'ing the history with git
19:11:16 <mmorrow> gwern: good idea
19:11:27 <Igloo> http://projects.haskell.org/camp/unique
19:11:35 <mmorrow> wee, thx
19:12:35 <ksf> mmorrow, well, you can just commit the graph, recording more than the standard interface does.
19:13:15 <ksf> it's not done not because it can't be done in git, but because people like to clean up stuff before commiting it upstream.
19:13:15 <mmorrow> ksf: ok, so you mean doing manually what darcs does automatically? :)
19:14:03 <ksf> as in "let's delete all that nonsense, i might be able to look smarter than i am."
19:15:31 <ksf> of course, darcs' patch-centric view of things has other, related advantages that you just don't get with git.
19:15:53 <ksf> eg. you would get better history integrity, but still wouldn't be able to do much with it.
19:16:03 <ksf> s/eg/ie
19:16:40 <mmorrow> ksf: check out that video, i'm not sure we're talking about the same thing
19:19:11 <mmorrow> ksf: the thing i'm not sure about is what features of camp demonstrated there darcs also shares (or to what extent blah etc)
19:22:59 <ivanm> is there any way I can stop ghci from giving out warnings about deprecated pragmas?
19:23:39 <mmorrow> sudo rm -f `which ghci` # ?
19:23:52 <ivanm> @slap mmorrow
19:23:53 * lambdabot secretly deletes mmorrow's source code
19:23:57 <mmorrow> :)
19:24:18 <ksf> afaiu darcs, it can do the same... but I hardly know more about darcs than the webpage with the theory and "darcs get foo"
19:24:47 <mmorrow> ksf: i'm not familiar with the details either
19:26:01 <solistic_> Is there a replace function for lists? Like Char -> String -> String?
19:26:20 <JuanDaugherty> last I heard the promise of "the theory of patches" hadn't quite been realized but that may be out of date
19:26:29 <ksf> solistic_, map?
19:26:46 <ksf> :t map (\'c' -> 'a')
19:26:48 <lambdabot> [Char] -> [Char]
19:26:57 <SamB> JuanDaugherty: it's still true
19:27:02 <ksf> map (\'c' -> 'a') "clbuttic"
19:27:06 <ksf> > map (\'c' -> 'a') "clbuttic"
19:27:08 <lambdabot>   "a* Exception: /tmp/6787099636332917078:71:37-47: Non-exhaustive patterns i...
19:27:10 <SamB> Igloo is working on actually proving one, though, I think
19:27:14 <ksf> uhhhh...
19:27:15 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:15 <JuanDaugherty> s/heard/knew/
19:27:16 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:16 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:16 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:16 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:17 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:19 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:21 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:23 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:25 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:26 <Gracenotes> @where ops
19:27:26 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
19:27:27 <lambdabot> mauke
19:27:27 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:28 <ksf> well, that's the principle.
19:27:29 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:31 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:33 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:35 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:37 <H8EONLD91N2KLXR0> http://www.youtube.com/watch?v=QBJ-XOp5IR0
19:27:48 <Gracenotes> well that solved that
19:28:05 <Gracenotes> also, NSFW
19:28:10 <JuanDaugherty> they tend to come back
19:28:13 <wli> da-x: In case you actually look, http://wli.pastebin.com/m2401575d
19:28:31 <QtPlaty[HireMe]> Is there anyway to say "This newtype belongs to all the typeclasses of its perent?"
19:28:34 <MyCatVerbs> > map (\c -> case c of { 'c' -> 'a'; c -> c; }) "clbuttic" -- name shadowing for great justice!
19:28:35 <lambdabot>   "albuttia"
19:28:42 <Zao> At least they spammer could have the good taste to spam something good.
19:28:44 <ksf> :t concatMap
19:28:45 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:29:09 <QtPlaty[HireMe]> ksf: Oooh I was looking for that.
19:29:24 <ksf> > concatMap (replicate 2) "foo"
19:29:26 <lambdabot>   "ffoooo"
19:29:48 <roconnor> > (replicate 2) =<< "foo"
19:29:49 <lambdabot>   "ffoooo"
19:29:53 <ksf> > [replicate 2 x | x <- "foo"]
19:29:55 <lambdabot>   ["ff","oo","oo"]
19:30:13 <dibblego> QtPlaty[HireMe], deriving?
19:30:24 <Gracenotes> GeneralizedNewtypeDeriving
19:30:28 <ksf> duh.
19:30:48 <Gracenotes> you have to be specific about what typeclasses they belong too, though. You may need ScopedTypeVariables
19:30:56 <Gracenotes> probably not though
19:31:02 <ksf> that's why I don't like comprehension. I never remember where the binds are, and how many of them.
19:31:49 <Gracenotes> ksf: you just have to remember there's a 'return' at the end
19:31:50 <byorgey> QtPlaty[HireMe]: you still have to list all the type classes, but with GeneralizedNewtypeDeriving the compiler generates all the trivial wrapping/unwrapping instances for you
19:32:34 <ksf> anyway, concatMap is a wonderful way to understand more about monads than you can understand from the usual IO squabbles.
19:32:45 <Gracenotes> well >_> it makes more sense in terms of set-builder notation probably
19:33:27 <roconnor> damn it, the camp video won't play for me
19:33:31 <roconnor> such a tease!
19:33:31 <QtPlaty[HireMe]> Thanks.
19:34:29 <sw17ch> @seen dons
19:34:30 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 4h 56m 42s ago.
19:34:59 <ksf> hmmmm... am i correct to say that bisimulation doesn't bother about state?
19:35:19 <roconnor> huh?
19:35:20 <SamB> JuanDaugherty: note that I'm basing the claim that it's still true on the fact that he keeps asking questions in #coq ;-)
19:35:22 <ksf> ...or is state included in the transitions?
19:35:34 <SamB> ksf: yes, if needed
19:35:47 <SamB> that is, if there is any
19:36:10 <ksf> state is an illusion, anyway.
19:36:38 <ksf> I knew that since the age of 14 or something.
19:36:59 <roconnor> do not try to change the state ... that is impossible.  Simply realize the truth
19:37:15 * roconnor didn't quite get that parody right
19:37:19 <ksf> if it were possible to change the state, people would be forbidden.
19:39:02 <SamB> roconnor: yeah, you forgot the last bit
19:39:03 <SamB> :
19:39:08 <SamB> there is no state
19:39:54 <ksf> there's standing waves, though.
19:40:41 <ksf> as in stabilizing feedback loops.
19:41:23 <ksf> which, ironically, become more brittle the more power they accumulate.
19:41:36 <roconnor> ``Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
19:42:43 <ksf> "There's a thunk travelling around the world. It is the thunk of purity".
19:43:01 * SamB likes the trailer for our new "Enter the Lambda" tutorial
19:43:20 <ksf> ...gives a whole new perspective on that whole POE thing.
19:43:25 <roconnor> @remember MonadState Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
19:43:25 <lambdabot> Done.
19:44:41 <roconnor> my computer is being all wonky
19:45:54 <solistic_> @let reTab = concatMap f where f '\t' = replicate 8 ' '; f a    = [a]
19:45:55 <lambdabot>  Defined.
19:46:09 <solistic_> > reTab "\t foo"
19:46:10 <lambdabot>   "         foo"
19:46:13 <roconnor> tabs are more complex than that
19:46:32 <wli> Yeah, you need to keep track of columns.
19:46:33 <lispy> MonadState: You mean I'll be able mutate variables? GHC: No, You won't have to.
19:46:52 <roconnor> :D
19:46:54 <solistic_> wli, roconnor, true
19:47:12 <lispy> roconnor: you were doing a Matrix spoof, correct?
19:48:10 <roconnor> yes
19:51:36 <lispy> Anyone know of a Haskell to .pyc compiler?
19:51:54 <ksf> gosh i hate sites that offer you to pay for papers you can get for free
19:52:03 <lispy> I saw the Yhc bytecode interpreter implemented in python, but that seems silly
19:52:07 <novatrust> Anyone using haskell on windows?
19:52:14 <sjanssen> lispy: really?  Why would you want to target possibly the lamest VM in history?
19:52:17 <lispy> novatrust: I have in the past, what's up?
19:52:43 <lispy> sjanssen: Sadly, I ask that question daily and I'm told that it's just the way we do things here at $day_job
19:53:22 <lispy> sjanssen: granted, we usually write directly in python, but I'm looking for both short term and long term solutions to that problem :)
19:54:25 <novatrust> I think i'm ready to say good bye to my sanity and try learning haskell - but currently using Vista. 3 years c#, 6 years PHP & C++ - Any Tips?
19:55:02 <novatrust> Or should I start learning scala or F# instead?
19:55:04 <Cale> novatrust: Try not to rely too much on your past programming experience or expect Haskell to behave like the other languages you know.
19:55:16 <blackh> novatrust: My tip would be .. learn Haskell!
19:55:26 <Cale> Haskell is a lovely language to learn though.
19:55:40 <lispy> novatrust: Scala and F# are also excellent languages to pickup.  Haskell will be the biggest departure and hence you'll grow the most.  F# has the advantage you can still use .NET.
19:55:56 <Cale> It's just that it will probably be a bit like learning to program again :)
19:56:00 <Cale> (for the first time)
19:56:25 <novatrust> Has anyone here been paid to write any haskell code?
19:56:47 <novatrust> And thank you very much for all of the advice :-)
19:57:11 <lispy> novatrust: very much so.  There are some companies that use it almost exclusively and they pay well and make good money :)
19:57:28 <wli> Something like this might do.
19:57:30 <wli> reTab [] = return [] ; reTab (c:cs) | c == '\t' = do { k <- get ; let m = 8 - (k `mod` 8) ; modify (+m) ; s <- reTab cs ; return (replicate m ' ' ++ s) } | otherwise = do { modify (+1) ; s <- reTab cs ; return (c : s) }
19:57:31 <Gracenotes> ...if you can find them
19:57:35 <Gracenotes> >_>
19:57:41 <lispy> novatrust: I have used it to write prototypes at my job and been paid, for example :)
19:57:54 <Cale> novatrust: Make sure to stick around and ask questions if you get stuck.
19:58:11 <novatrust> will do
19:58:24 <solistic_> wli, tabs are ugly
19:58:28 <lispy> I'm starting to think no one has made a Haskell to .pyc compiler
19:58:40 <lispy> I wonder if this is worth my time or if I should pursue my other idea first...
19:58:45 <sjanssen> lispy: I really doubt it
19:58:58 <sjanssen> there isn't even a robust Haskell -> Java bytecode compiler out there
19:59:29 <lispy> sjanssen: but isn't that mainly because the changes were never fully accepted to GHC proper?  (I'm thinking of lambdaVM are you?)
19:59:53 <lispy> I'd settle for a less mainstream compiler such as Yhc
20:00:05 <sjanssen> lispy: I am, and I'm not sure whether that was the only reason
20:00:32 <sjanssen> lispy: programming with compilers other than GHC just isn't very fun
20:00:40 <lispy> It would certainly be nice if GHC were more ammenable to retargeting -- as I understand it there is a push in that direction now
20:01:16 <lispy> sjanssen: Well, i'd be happy if I could just implement parts of my program in Haskell instead of all of it, thus hopefully mitigating the need for advanced GHC features
20:01:30 <sjanssen> lispy: Python has an FFI, right?
20:01:36 <lispy> Yes it does
20:02:01 <lispy> http://wiki.python.org/moin/PythonVsHaskell
20:02:09 <wli> http://wli.pastebin.com/m7fb7a20b
20:02:09 <lispy> that page even details how to load a haskell .dll
20:03:06 <lispy> sjanssen: But, your point is well taken.  I can just as readily checkin a .pyc as I can check in a haskell source file that makes a dll.  My co-workers could edit either equally well :(
20:03:31 <lispy> sjanssen: I think that means I could work on my other ideas
20:03:50 <wli> solistic: http://wli.pastebin.com/m7fb7a20b <-- this should expand tabs properly
20:04:50 <gigamonkey> BONUS: you here
20:04:51 <gigamonkey> ?
20:05:56 <O_4> What are the 'Haskell libraries'?  Are they just a random collection of useful libs, and not standardized in any particular way?
20:06:05 <O_4> I.e. http://cvs.haskell.org/Hugs/pages/libraries/index.html
20:06:47 <sjanssen> O_4: you'll want to stay away from that page, it's outdated
20:06:49 <sjanssen> @docs
20:06:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
20:06:55 <mmorrow> O_4: the only libraries that are "part of the Haskell *language*" are those specified in the haskell98 report
20:07:15 <sjanssen> O_4: some are formally standardized in Haskell '98, others are informally standardized as part of a libraries submission process
20:08:47 <O_4> It seems like many of them ought to be a package, rather than a lib included in the GHC distro.
20:09:09 <sjanssen> O_4: what do you mean "a package"?
20:09:12 <O_4> I can see that it's nice to have stuff available out of the box.
20:09:29 <lispy> O_4: Take a look at hackage :)
20:09:34 <lispy> ?where hackage
20:09:34 <lambdabot> http://hackage.haskell.org/
20:09:36 <mmorrow> roconnor: i had to go to the youtube page for it to get it to play
20:09:36 <O_4> sjanssen: well, http://hackage.haskell.org/packages/archive/pkg-list.html
20:09:54 <sjanssen> O_4: all of those other than base can be installed separately, ie. they're all in that hackage index
20:10:33 <O_4> Right, that seems reasonable.
20:14:55 <solistic_> wli, very nice
20:19:39 <mmorrow> lol
20:19:45 <mmorrow> "Yes. STL is not object oriented. I think that object orientedness is almost as much of a hoax as Artificial Intelligence. I have yet to see an interesting piece of code that comes from these OO people. In a sense, I am unfair to AI:..."
20:19:56 <mmorrow> (http://www.stlport.org/resources/StepanovUSA.html)
20:20:15 <mmorrow> (lol at the start of the second sentence)
20:20:16 <wli> mmorrow: Sounds like a decent guy.
20:20:31 <mmorrow> that interview (Transcript) is interesting
20:23:41 <mmorrow> this interview makes me want to learn C++ templates, if for nothing else but to see his design decisions
20:24:37 <mmorrow> he's pretty hillarious too in his bluntness
20:24:38 <Gracenotes> mmorrow: who is he?
20:24:40 <mmorrow> "My approach works, theirs does not work."
20:24:57 <mmorrow> Gracenotes: the designer/creator of C++ templates
20:26:12 <lispy> What is not object oriented about the stl?
20:26:41 <ksf> templates are a turing-complete functional language with horrid syntax, abysmal typing support and a lot of fans.
20:28:31 <Gracenotes> proven Turing-complete?
20:28:45 <ksf> otoh, you might derive some fun implementing type inference using it, it's almost certainly possible.
20:29:09 <ksf> general recursion is a bit limited, but you can give the compiler a flag that increases the max depth.
20:29:21 <lispy> Gracenotes: yeah, pretty easily too because you can instantiate a template with values
20:29:50 <lispy> Gracenotes: so factorial, for example, can be implemented pretty directly in the template
20:29:59 <Gracenotes> yes, I've seen that
20:30:18 <lispy> So just implement a lambda calc evaluator and you're done with the proof :)
20:30:18 <Gracenotes> I know at least it can do structural recursion
20:30:23 <ksf> ...whereas you have to contort the whole syntax to pass in a higher-order function.
20:30:37 <Gracenotes> and presumably primitive, like Ackermann
20:30:59 <ksf> templates may take direct integer arguments.
20:31:19 <ksf> as in vec<4><double> or fac<20>
20:32:30 <programziz> hi
20:32:50 <ksf> if you wanna learn it, there's (allegedly) good books about template programming, but i'd recommend reading something like the phoenix or fc++ source.
20:33:30 <programziz> can someone explain to me how i can mess with my friends computer from mine via cmd
20:33:36 <lispy> Modern C++ Programming by Alexanderscue(sp?) is a fun read
20:33:52 <Gracenotes> however nice templating is, its actual integration with C++ is so-so
20:34:01 <Zao> programziz: No. Stop being a moron.
20:34:04 <Gracenotes> particular when it comes to compilation
20:34:21 <ksf> programziz, like this:? http://www.catb.org/~esr/faqs/hacker-howto.html
20:34:44 <mdmkolbe> programziz: I think you are asking in the wrong channel
20:34:56 <Zao> programziz: http://www.acm.org/about/code-of-ethics
20:35:12 <Zao> programziz: http://www.ieee.org/portal/pages/iportals/aboutus/ethics/code.html
20:35:17 <mdmkolbe> programziz: we're Haskers not Hackers
20:35:27 <ksf> mdmkolbe, you might not want to hear it, but we arz 733t0rz
20:35:53 <Zao> I wonder why the two large associations of computing professionals both have Code of Ethics pages :)
20:36:19 <roconnor> mmorrow: ooh, can I have camp-view for darcs?
20:36:33 <mmorrow> roconnor: ask Igloo
20:36:35 <ksf> Well, I'm sure arms manufacturers have similar codes, don't they?
20:36:57 <Cale> programziz: First spend 15 years studying computer security, but be careful to avoid becoming any more mature or responsible than you already are, because that would tend to get in the way.
20:37:00 <mmorrow> Igloo: is there camp-view for darcs??
20:37:09 <cjs> Hm. Why is fail in the Data.Binary.Get monad defined to evaluate to error?
20:37:14 <mmorrow> roconnor: (me too)
20:37:17 <mdmkolbe> Is there any advantage of using -XRank2Types instead of -XRankNTypes?  (Better portability? Better deciability? etc.)
20:37:20 <lispy> roconnor: it's certainly possible, and once upon a time there was an (inefficient) perl script to do it
20:37:33 <Cale> mdmkolbe: iirc, hugs supports the former but not the latter
20:37:35 <ksf> hmmm.
20:37:38 <ivanm> mdmkolbe: room for future consultancy contracts? :p
20:38:16 <ksf> has spying on girls via a cracked webcam more hacker-nature than spying on girls via a drilled hole in the wall?
20:38:45 <Saizan> cjs: there's no other way considering Get's implementation
20:38:50 <Zao> ksf: Hacking rooms is cooler than hacking computers.
20:39:10 <Saizan> cjs: you might consider attoparsec if you want to recover from parsing failures
20:39:15 <roconnor> what is doing the layout for camp-view?
20:39:20 <mmorrow> cjs: that's one of the things that i don't like about Data.Binary
20:39:33 <ksf> ...or polyparse, which lets you parse completely lazily.
20:39:56 <ivanm> hmmm.... it appears softpedia mirrors a fair amount of hackage...
20:40:06 <ksf> ...then have your ast include parse failures, and you're in for a lot of fun.
20:40:35 <ivanm> http://linux.softpedia.com/dyn-search.php?search_term=haskell
20:42:50 <cjs> Hm. And I guess the implementation can't be changed to be parallel to Data.Binary.Strict.Get due to compatability reasons?
20:43:24 <mmorrow> cjs: this is why i use a "personalized" version of Data.Binary
20:43:36 <cjs> mmorrow: Yes, I was just considering that.
20:44:12 <mmorrow> (well, by "this" i mean "these" (many resons))
20:44:18 <mmorrow> *reasons
20:44:24 <Saizan> cjs: the fear is to lose perfomance
20:46:02 <Saizan> cjs: so if e.g. using continuations, you're able to get similar perfomance but have a saner fail they'll accept the patch i think
20:46:04 <mmorrow> cjs: (i ditch Data.Binary completely, have everything work on [String.ByteString] instead of Lazy.ByteString, expose functions to poke/peek any (Storable a), and i think that's it)
20:46:32 <Saizan> what's String.ByteString ?
20:46:37 <mmorrow> oops
20:46:41 <mmorrow> Strict.ByteString
20:46:49 <mmorrow> Data.ByteString.ByteString (i mean)
20:47:51 <mmorrow> cjs: oh, and also use a different implementation of the Get datatype (which still has the same interface)
20:48:08 <lispy> interesting interview
20:48:13 <mmorrow> lispy: totally
20:48:15 <lispy> The comments about max are interesting
20:48:24 <lispy> "These are my litmus tests: if a language allows me to implement max and swap and linear search generically - then it has some potential."
20:48:46 <mmorrow> lispy: it's funny how everything he says he wishes a language had, makes you think of haskell
20:49:46 <ivanm> what does  -fno-warn-name-shadowing do?
20:49:56 <mmorrow> case xs of x:xs -> ...
20:50:04 <ivanm> ahhhh
20:50:06 <lispy> ivanm: try, let a a = a, with and without it in ghc
20:50:09 <Cale> lispy: who is that?
20:50:16 <ivanm> OK, I better leave that in there for now
20:50:24 <mmorrow> Cale: it's the designer/creator of C++'s templates
20:50:28 <Cale> ah
20:50:30 <ivanm> but apart from that, I believe I'm ready for my first release of graphviz as the maintainer! \o/
20:50:31 <mmorrow> Cale: http://www.stlport.org/resources/StepanovUSA.html
20:50:32 <lispy> Cale: http://www.stlport.org/resources/StepanovUSA.html
20:50:35 <ivanm> @seen matthew-_
20:50:35 <lambdabot> matthew-_ is in #haskell-blah, #ghc and #haskell. I don't know when matthew-_ last spoke.
20:50:36 <lispy> double paste!
20:50:47 <mmorrow> ivanm: nice
20:51:08 <ivanm> I was thinking of adding in support for Data.Graph graphs, but I think I'll leave that till later
20:52:46 <ivanm> with versioning on hackage... since matthew-_ has been using yearh.month.date format, I suppose I should stick to that to ensure new versions > old versions? :s
20:54:12 <mdmkolbe> ivanm: sounds like hackage needs a way to version the version number systems themselves ;-)
20:54:40 <Cale> My favourite graph representation is using Data.Map and Data.Set to represent adjacency information.
20:54:51 <ivanm> mdmkolbe: heh
20:55:12 <ivanm> Cale: *shrug* if I'm using libraries that do stuff, then they choose the data structure for me ;-)
20:55:25 <cjs> Saizan: why would one lose performance if we changed Get a to Get (Either String a)?
20:58:49 <mmorrow> Cale: mine too
20:59:39 <ivanm> if I want extensible-exceptions to work with base < 4, do I just need to add extensible-exceptions to .cabal? will base-4 still like this?
20:59:46 <mmorrow> ivanm: i'd make a graph rep not tied to any particular lib, then people can translate to your universal/simple rep
21:00:10 <ivanm> mmorrow: hey, I'm just updating this library! not designing a new one!
21:00:25 <mmorrow> ivanm: isn't it your library now? ;)
21:00:37 <ivanm> mmorrow: yes, but I'm only applying old patches to it! ;-)
21:00:42 <mmorrow> :)
21:00:43 <ivanm> I'll leave changing it for another time
21:01:34 <ivanm> though is it valid to create a class Graphs, where I can make all instances of FGL's Graph class instances of it without having to specify each one?
21:01:38 <mmorrow> ivanm: i just solve problems with base < 4 by putting "base == 4.*" in the build-depends: ;)
21:01:44 <ivanm> mmorrow: heh
21:01:56 <ivanm> I'm tempted, as then I can get rid of all the deprecated extensions...
21:02:19 <ivanm> but I'm trying to make this as backwards-compatible as I can for now
21:03:28 <mdmkolbe> What is the proper term for when you say "foo = bar baz" instead of "foo x = bar baz x"?
21:03:37 <mmorrow> ivanm: (personally) i'd avoid classes and use a record datatype
21:03:57 <ivanm> mmorrow: ummm.... and have lookup functions as well as the graph in the record?
21:04:13 <mmorrow> fromFGL :: (FGL.Graph g) => g .. -> Graph a
21:04:18 <ivanm> mdmkolbe: it isn't partial evaluation...
21:04:31 <mmorrow> ivanm: have only the functions you need
21:04:36 <ivanm> mmorrow: with Graph being the record?
21:04:57 <mmorrow> (i'm not familiar with the FGL graph class, but)
21:05:22 <ivanm> hmmm.... but then you're converting from an FGL graph to an internal graph and _then_ to a DotGraph...
21:05:29 <mmorrow> newtype G v = G (Map v (Set v))
21:05:34 <mmorrow> or
21:06:20 <mmorrow> newtype G e v = G (Map v (v, Map v e))
21:06:23 <mmorrow> or
21:06:24 <mmorrow> ...
21:06:41 <mmorrow> (those are two that i've used)
21:06:49 <ivanm> mmorrow: OK, fine, you've convinced me... I'll just make it use base == 4
21:06:55 <mmorrow> ivanm: heh
21:06:58 <ivanm> or should I make it base >= 4?
21:07:06 <edwardk> ok, i now understand the good parts of the utrecht parser combinators at least
21:07:10 <mmorrow> i'd do base == 4.*
21:07:16 <ivanm> *nod*
21:07:39 <BMeph> mdmkolbe: I think it's "eta abstraction", but one of "the Wise" needs to vet me. ;)
21:07:51 <mmorrow> ivanm: oh, if you already have a DotGraph type then i guess just use that as the target
21:08:16 <ivanm> mmorrow: thing is, I already have two functions for FGL style graphs
21:08:20 <mmorrow> ivanm: bah, these are all design decisions
21:08:26 <ivanm> _most_ of them are pretty generic
21:08:29 <roconnor> I'd even go as far as base == 4.1.*
21:08:38 <ivanm> * most of the functions are pretty generic
21:08:48 <ivanm> roconnor: oh? why not 4.0?
21:09:16 <roconnor> er I meant base == 4.0.*
21:09:34 <BMeph> mdmkolbe: Sorry, try: "eta conversion." :)
21:09:54 <mmorrow> ivanm: rewrite them? :)
21:10:13 <ivanm> roconnor: I have base-4.1.0.0 ...
21:10:19 <ivanm> mmorrow: heh, yeah
21:10:22 <roconnor> there is a base 4.1?
21:10:28 <ivanm> roconnor: 6.10.2 appears to have it
21:10:29 <mdmkolbe> BMeph: yeah, that would be one way to describe it
21:10:34 <roconnor> in that case base >= 4.0 && base < 4.2
21:10:36 <ivanm> mmorrow: I will, as soon as I can think of a good generic way of doing so
21:10:43 <ivanm> roconnor: why exclude 4.2?
21:10:59 <roconnor> because 4.2 may not work with your code.
21:11:34 <BMeph> That'd be a nice tool for the kit; an x.y => w.z "suggestor", like, what-is-it, 2to3 for Python. :)
21:12:30 <ivanm> roconnor: hmmm..... I doubt it will be incompatible
21:12:33 <BMeph> roconnor: Isn't "it might not work with your code" a premature abstraction? ;p
21:13:01 <ivanm> and IMO, it's less of a pain to make packages more restrictive later than too restrictive
21:13:05 <roconnor> BMeph: it is easy to release a new version of your code that bumps the acceptable base versions
21:13:14 <roconnor> It is impossible to do the opposite
21:13:19 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:13:20 <lambdabot> Unknown command, try @list
21:13:35 <kadaver_> http://wiki.python.org/moin/PythonVsHaskell
21:13:35 <kadaver_> ^^ how to do haskell in python?
21:13:39 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:13:40 <lambdabot> Unknown command, try @list
21:13:45 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:13:45 <lambdabot> Unknown command, try @list
21:13:50 <roconnor> @where ops
21:13:50 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
21:13:51 <lambdabot> mauke
21:13:52 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:13:53 <lambdabot> Unknown command, try @list
21:14:00 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:14:00 <lambdabot> Unknown command, try @list
21:14:04 <Zao> New DCC exploit, it seems.
21:14:05 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:14:05 <lambdabot> Unknown command, try @list
21:14:08 --- mode: ChanServ set +o dibblego
21:14:11 --- kick: jme_009 was kicked by dibblego (dibblego)
21:14:15 --- mode: dibblego set +b *!n=jmccrack@*.psc.edu
21:14:15 <jme_009> ?DCC SEND "ff???f?" 0 0 0
21:14:16 <lambdabot> Unknown command, try @list
21:14:18 --- mode: dibblego set +b *!*n=oke@*.dsl.bell.ca
21:14:30 --- mode: dibblego set -b *!n=jmccrack@*.psc.edu
21:14:41 <roconnor> I got to learn to do that
21:14:53 --- mode: ChanServ set +o allbery_b
21:15:20 --- mode: allbery_b set +b *!*@*.dsl.bell.ca
21:15:20 --- kick: jme_009 was kicked by allbery_b (allbery_b)
21:15:45 <roconnor> that seems like a pretty wide reaching ban
21:15:49 * roconnor isn't sure
21:15:53 <Axman6> indeed
21:16:08 <Axman6> all bell canada dsl users possibly?
21:16:09 <allbery_b> it does, doesn't it?
21:16:13 <Zao> roconnor: It only has to hold for the average retard attention span.
21:16:21 <roconnor> true
21:16:25 <roconnor> there may be no better way
21:16:45 --- mode: allbery_b set -b *!*@*.dsl.bell.ca
21:16:56 <roconnor> so what changed with base 4.1?
21:17:45 <lispy> loks like I missed all the fun
21:18:30 --- mode: allbery_b set -o allbery_b
21:18:35 <edwardk> heya lispy
21:18:46 <lispy> hey
21:18:47 <kadaver_> ^^ how to do haskell in python?
21:18:47 <kadaver_> http://wiki.python.org/moin/PythonVsHaskell
21:18:55 <ivanm> how does one link to Prelude using haddock?
21:19:10 <ivanm> "Prelude" doesn't work :s
21:19:51 <ivanm> (though 'Prelude.LT' creates a link to ghc-prim/GHC-Ordering :s )
21:20:20 <lispy> kadaver_: if that was directed at me, I don't think I can use it
21:22:41 <kadaver_> htm vs stm, go!
21:23:02 <lispy> htm?
21:23:09 <roconnor> stm!
21:23:17 <lispy> stm!
21:23:22 <ivanm> gah, how _does_ one refer to modules outside of the current code-base in haddock?
21:23:24 <lispy> (but, wait what was htm?)
21:23:43 <lispy> hyper text markup versus software transactional memory
21:23:48 <roconnor> max "stm"  "htm"
21:23:51 <roconnor> > max "stm"  "htm"
21:23:53 <lambdabot>   "stm"
21:24:16 <ivanm> > "stm" > "htm"
21:24:18 <lambdabot>   True
21:24:52 <lispy> ?google googlefight stm htm
21:24:53 <lambdabot> No Result Found.
21:25:18 <lispy> http://googlefight.com/index.php?lang=en_GB&word1=stm&word2=htm
21:25:33 <lispy> htm won in that case
21:26:40 <kadaver_> hardware transactional memory vs software transactional memory
21:27:13 <kadaver_> why?
21:28:08 <Axman6> why?
21:28:18 <ivanm> why why?
21:28:24 <kadaver_> why?
21:28:36 <kadaver_> > repeat "why?"
21:28:37 <lispy> what about ftm?
21:28:37 <lambdabot>   ["why?","why?","why?","why?","why?","why?","why?","why?","why?","why?","why...
21:28:46 <ivanm> gah, it seems you can't link to a different library's module (or else it's a bug in haddock) :s
21:29:14 <lispy> ivanm: Oh, there is a way to do it, IIRC
21:29:21 <lispy> ivanm: a command line param perhaps
21:29:50 <ivanm> hmmm...
21:30:06 <ivanm> lispy: well, even the docs on hackage fail...
21:30:22 <ivanm> http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-Core.html <-- click on the link for XMonad.Layout.PerWorkspace :s
21:30:47 <ivanm> lispy: the weird thing is, 'Module.function' works, but "Module" doesn't :s
21:30:56 <ivanm> so I think it's a bug in haddock
21:31:00 * ivanm could be wrong...
21:44:32 <TomMD> > (const "pong") "ping"
21:44:34 <lambdabot>   "pong"
21:49:12 <mofmog> noob question: i just installed cabal-install using the boot-strap script and i get this message "cabal: /home/XXXXX/.cabal/packages/hackage.haskell.org/00-index.tar: openBinaryFile: permission denied (Permission denied)" trying to run "cabal install"
21:50:19 <clanehin> what are you running when you get that message
21:50:47 <clanehin> oh, cabal install, sorry
21:51:06 <mofmog> im thinking i screwed up my path or something
21:51:56 <clanehin> I have a 00-index.tar file there
21:52:11 <bos31337> Hmm, my Haskell slides for talking to Erlangers tomorrow are a bit unbalanced.
21:52:18 <clanehin> I think that's the default path, unless you tried to install in someone else's home directory
21:52:27 <bos31337> Of the 40 slides so far, 20 are about types.
21:52:27 <matthewp> bos31337: unbalanced how?
21:52:27 <clanehin> did you run the boot-strap as root?
21:52:39 <matthewp> hos31337: oh
21:53:09 <mofmog> hrm
21:53:16 <matthewp> Sweet, Win7 and GHC 6.10.2 work perfectly together this time with no loading problems
21:53:17 <mofmog> if i installed it as root, itd be in /usr/bin right?
21:53:25 <mofmog> but it didnt work until i added .cabal/bin to my path
21:53:59 <clanehin> I'm trying think of reasons why you wouldn't have permissions.
21:54:08 <ivanm> cabal-install won't let me upload to hackage :s
21:55:42 <clanehin> I'm sorry, I'm shooting in the dark here.  Operating system?  cabal update?
21:56:09 <ivanm> gah, I need cabal-version: >= 1.6 specified
21:56:17 <clanehin> I did a cabal upload yesterday, wored for me.
21:56:19 <ivanm> why didn't cabal-install say that? :@
21:56:32 <ivanm> clanehin: yeah, but I'm using == 4.* syntax in the .cabal file
21:56:58 <clanehin> ivanm: I see.
21:58:00 <mofmog> hrm, ok i did "sudo ./boostrap.sh"
21:58:35 * ivanm will make the official announcement later, but graphviz-2009.5.1 has just been uploaded to hackage
21:59:02 <clanehin> oh, I wasn't recommending that
21:59:09 <mofmog> it wont install otherwise
21:59:14 <ivanm> bugger, forgot to specify the home page... *shrug* oh well
21:59:15 <clanehin> Although I don't imagine it would hurt anything.
22:01:07 <mofmog> hmmm
22:04:04 <mofmog> nvm it just started working
22:04:10 <sergio> Hello, I've trouble installing ghc-6.10.1 on Ubuntu because of libgmp...
22:04:34 <mofmog> why not 10.2?
22:05:15 <mofmog> nope, cabal update is borked
22:05:26 <sergio> I installed gmp (in ~/gmp/gmp-4.3.0), and added ~/gmp/gmp-4.3.0/.libs in LD_LIBRARY_PATH.
22:05:52 <clanehin> sergio: you can't install gmp with apt?
22:05:58 <sergio> This allowed me to pass the "./configure" step, but not the "(sudo) make install" step
22:06:51 <clanehin> what error message?
22:07:10 <sergio> <clanehin>: I tried "apt-cache search gmp" but it didn't produce any "gmp" in its results (bear with me, I'm not familiar AT ALL with apt)
22:08:21 <sergio> the error message I got in "make install" is "error while loading shared libraries: libgmp.so.3: cannot open shared object file: no such file or directory
22:09:07 <clanehin> the debian package is libgnp3-dev, should be the same on ubuntu
22:09:28 <clanehin> Usually it works for me to do aptitude install libgnp<bash-tab-completion>
22:09:57 <sergio> you type "libgnp"; did you mean "libgmp"?
22:10:06 <clanehin> yeah, libgmp
22:10:29 <clanehin> oopsed twice even
22:11:15 <clanehin> for some reason libgnp3-dev is 4.2.4: http://packages.debian.org/unstable/libdevel/libgmp3-dev
22:13:45 <sergio> it seems that installation is progressing smoothly now!
22:14:25 <clanehin> mofmog: I hope I didn't throw you off, how's your cabal coming?
22:14:30 <mofmog> um
22:14:32 <clanehin> at least not too far off.
22:14:37 <sergio> over now. At least ghci works fine! Many thanks!
22:14:47 <mofmog> if i do "sudo ~/.cabal/bin/cabal update"
22:14:48 <mofmog> it works
22:15:13 <mofmog> then i tried "sudo chmod -R +rwx ~/.cabal" or something similar and it still deosnt work right
22:15:35 <clanehin> same error message?
22:16:05 <mofmog> yeup
22:16:21 <mofmog> i was thinking that the bootstrap script set the permissions all screwy
22:16:41 <clanehin> yeah, what are the perms on that file?
22:16:45 <mmorrow_> this is (and could be made even more so) handay: http://moonpatio.com/repos/PackageTree.hs
22:16:59 <mmorrow_> $ ./PackageTree < package.conf > tree.html
22:17:24 <mmorrow_> (someone suggested this earlier in here, and i liked the idea)
22:17:40 <mofmog> woops
22:17:52 <mofmog> it shouldve been sudo chmod -R ugo+rwx ~/.cabal
22:17:54 <mofmog> now it works
22:18:12 <mofmog> the bootstrap script needs to be worked on it seems
22:18:27 <mofmog> oh great, but now yi wont install
22:19:24 <clanehin> something about quickcheck?
22:23:52 <mofmog> yes
22:26:18 <mofmog> clane did you respond?
22:26:20 <mmorrow> dunno how hands-on you wanna get, but this'll fix QuickCheck:
22:26:22 <mmorrow> for i in `find . | grep -v "_darcs" | grep -E "\.l?hs"`; do sed -ir 's/Control\.Exception/Control.OldException/g'; done
22:26:33 <mofmog> er i sorta dropped my connection fro a bit
22:26:39 <mmorrow> (run in root of QuickCheck-2.blah pkg)
22:29:40 <mofmog> mmorrow can you repeat that?
22:29:49 <mmorrow> for i in `find . | grep -v "_darcs" | grep -E "\.l?hs"`; do sed -ir 's/Control\.Exception/Control.OldException/g'; done
22:29:51 <mmorrow> that?
22:30:06 <mofmog> er, i asked a question about installing yi and there was a quickcheck problem
22:30:39 <mmorrow> so the QuickCheck package needs to have all occurences of Control.Exception changed to Control.OldException in the source code
22:30:49 <mmorrow> (this is one solution that i've used)
22:31:13 <mofmog> hrm doesnt work
22:31:16 <mmorrow> and that above sh spell does that to every *.hs recursively starting from the current dir
22:31:22 <edwardk> @seen saizan
22:31:22 <lambdabot> saizan is in #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell. I last heard saizan speak 1h 44m 50s ago.
22:31:48 <mmorrow> mofmog: wait! **important** that you are in the root dir of QuickCheck-2.whatever when you run that
22:32:15 <edwardk> @tell saizan http://comonad.com/haskell/uu-parsinglib-alt/Text/ParserCombinators/UU/Parsing.hs -- it doesn't quite work yet, but its a lot easier to read =)
22:32:15 <lambdabot> Consider it noted.
22:32:28 <mmorrow> (don't run that anywhere else that you don't want it do Exception->OldException all .hs files in the subtree)
22:32:46 <mofmog> uhh where does quickehcek reside
22:33:11 <mmorrow> phew :) i thought something bad had happened for a second there :)
22:33:21 <mmorrow> mofmog: i dunno
22:33:51 <mofmog> urghh
22:34:11 <clanehin> mofmog: back, sorry
22:34:18 <mmorrow> you can download it manually from hackage, unpack it, apply that fix, then cabal install that possibly
22:34:57 <kadaver_> > oncat $ map reverse ["Llib", "Setag"]
22:34:58 <lambdabot>   Not in scope: `oncat'
22:35:00 <mmorrow> how does everyone else get QuickCheck-2.* to install with base==4.* ?
22:35:14 <mmorrow> @type concatMap
22:35:15 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
22:36:05 <mmorrow> > concatMap reverse ["OH","HAI"]
22:36:07 <lambdabot>   "HOIAH"
22:36:12 <mmorrow> > reverse =<< ["OH","HAI"]
22:36:13 <lambdabot>   "HOIAH"
22:36:39 <mofmog> backwards monad??
22:36:58 <clanehin> =<< is concatMap or something roughly, iirc.
22:37:09 <mmorrow> @src [] (>>=)
22:37:09 <lambdabot> xs >>= f     = concatMap f xs
22:37:14 <mofmog> > ["OH","HAI"] >>= reverse
22:37:15 <lambdabot>   "HOIAH"
22:37:22 <mofmog> what i thought
22:37:50 <mofmog> why would you use =<<
22:37:50 <mmorrow> i like (=<<) since it plays nicely (wrt direction of flow) with (.)
22:38:07 <mmorrow> main = putStr . unlines . ....... . lines =<< getContents
22:38:25 <mmorrow> i don't use (>>=) very often
22:38:32 <mofmog> oh right, haskell makes you look at the data going in both directions
22:38:46 <kadaver> > concat $ map reverse ["Llib", "Setag"]
22:38:47 <lambdabot>   "bilLgateS"
22:38:57 <mmorrow> well, i use (>>=) when that way makes more sense either logically or aesthetically
22:39:17 <dibblego> > reverse =<< ["Llib", "Setag"]
22:39:18 <lambdabot>   "bilLgateS"
22:39:26 <mofmog> i jsut find it annyoing having to go back and forth sometimes when reading haskell code
22:39:30 <mmorrow> @src join
22:39:30 <lambdabot> join x =  x >>= id
22:39:40 <mmorrow> > id =<< ["Llib", "Setag"]
22:39:41 <lambdabot>   "LlibSetag"
22:39:46 <mmorrow> > concat ["Llib", "Setag"]
22:39:47 <lambdabot>   "LlibSetag"
22:39:51 <mmorrow> > join ["Llib", "Setag"]
22:39:53 <lambdabot>   "LlibSetag"
22:40:02 <mofmog> reverse =<< ["oh","hai"] >>= reverse
22:40:05 <mmorrow> > join (Just Nothing)
22:40:06 <lambdabot>   Nothing
22:40:13 <mofmog> > reverse =<< ["oh","hai"] >>= reverse
22:40:14 <lambdabot>       precedence parsing error
22:40:15 <lambdabot>          cannot mix `(=<<)' [infixr 1] and `(>...
22:40:16 <mofmog> dang
22:40:40 <kadaver> > concat $ map reverse $ (map . map) toLower ["Llib", "Setag"]
22:40:41 <lambdabot>   "billgates"
22:40:56 <kadaver> > unlines $ map reverse $ (map . map) toLower ["Llib", "Setag"]
22:40:58 <lambdabot>   "bill\ngates\n"
22:40:58 <mmorrow> > (reverse =<<) . (>>= reverse) $ [["oh"],["hai"]]
22:40:59 <lambdabot>   "hoiah"
22:41:26 <kadaver> > foldl (\a b -> a++ " " ++b) "" $ map reverse $ (map . map) toLower ["Llib", "Setag"]
22:41:27 <lambdabot>   " bill gates"
22:41:56 <kadaver> > foldl (\a b -> a++ " " ++b) "" $ map (toUpper . head) $ map reverse $ (map . map) toLower ["Llib", "Setag"]
22:41:57 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
22:42:47 <mmorrow> you're losing the rest of it with that call to head
22:44:46 <kadaver> > foldl (\a b -> a++ " " ++b) "" $ map (\x -> (toUpper $ head x)++(tail x)) $ map reverse $ (map . map) toLower ["Llib", "Setag"]
22:44:48 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
22:46:08 <kadaver> > foldl (\a b -> a ++ (map toLower (reverse b))) "" ["Llib", "Setag"]
22:46:10 <lambdabot>   "billgates"
22:47:36 <kadaver> is there no capitzliae?
22:47:36 <kadaver> > foldl (\a b -> a ++ " " ++ (map toLower (reverse b))) "" ["Llib", "Setag"]
22:47:36 <kadaver> > capitalize "hello"
22:47:39 <lambdabot>   Not in scope: `capitalize'
22:47:39 <lambdabot>   " bill gates"
22:54:13 <canvon> > map (zipWith id ([toUpper] ++ cycle [toLower]) . reverse) ["Llib", "Setag"]
22:54:14 <lambdabot>   ["Bill","Gates"]
22:56:05 <solidsnack> :t cycle
22:56:06 <lambdabot> forall a. [a] -> [a]
22:56:22 <solidsnack> Oh, wait. The type doesn't always tell you what something does...
22:56:54 <canvon> @src cycle
22:56:55 <lambdabot> cycle [] = undefined
22:56:55 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:57:30 <canvon> infinite/cyclic list, but zipWith stops as soon as one of both input lists is exhausted
23:00:20 <canvon> > concat . intersperse " " {-no intercalate on my system, can't test-} . map (zipWith id (toUpper : cycle [toLower]) . reverse) $ ["Llib", "Setag"]
23:00:22 <lambdabot>   "Bill Gates"
23:01:53 <canvon> (oh well, "repeat toLower" instead of cycle [toLower])
23:02:21 <Sentinel34> boxs =  unpack . map cols . pack (What do those dots mean?)
23:03:18 <johnw> Sentinel34: (f . g) x = f (g x)
23:03:19 <dibblego> Sentinel34, function composition
23:03:19 <dibblego> @src (.)
23:03:19 <lambdabot> (f . g) x = f (g x)
23:03:23 <Cale> Sentinel34: they're function composition
23:03:58 <Sentinel34> ohh
23:04:00 <Cale> Sentinel34: so boxs is the function which, when supplied with a parameter, will apply pack to it, and then map cols over the resulting list, and then unpack
23:05:04 <Sentinel34> I see
23:07:35 <Cale> A lovely property of function composition is that it's associative, that is, (f . g) . h = f . (g . h), no matter what functions f, g, and h are. This means that if you have a chain of function compositions, you can always just grab some part of it, and define it as a new function, and call that instead.
23:08:52 <Sentinel34> well if thats the case, I guess the parenthesis are pointless then right? I guess thats why the example I was looking at didn't use them
23:15:05 <hs2m> hi everyone can anyone tell me how to fetch a webpage in haskell and parse it for links?
23:15:55 <sjanssen> hs2m: sounds like a job for the tagsoup package?
23:15:59 <sjanssen> @hackage tagsoup
23:15:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/tagsoup
23:15:59 <Gracenotes> hs2m: you can use the HTTP library and tagsoup
23:16:19 <Gracenotes> here's a sample script that looks through a Wikipedia page and requests an archive of everything linked therein: http://en.wikipedia.org/wiki/User:Gwern/Archive-bot.hs
23:16:44 <hs2m> sjanssen: Gracenotes: thanks!
23:16:57 <Gracenotes> sort of hacky :) but very terse.
23:22:23 <solidsnack> -- Note that the use of forkIO means only some URLs will print
23:22:25 <solidsnack> ?
23:24:11 <quicksilver> what forkIO actually means is that his urls can get arbitrarily interleaved.
23:24:17 <hs2m> urgh how do i install that package?
23:24:38 <dmead> ?seen ski
23:24:38 <solidsnack> quicksilver: That seems more reasonable; but the comment is what it is :)
23:24:38 <lambdabot> ski is in #not-math, #haskell.se, ##logic and #haskell. I last heard ski speak 10h 23m 27s ago.
23:24:56 <quicksilver> solidsnack: yeah, I think gwern was misunderstanding some buffering effect maybe?
23:25:01 <quicksilver> who knows.
23:27:08 <Gracenotes> beamer produces such pretty slides :D
