00:10:18 <pumpkin> *crickets*
00:12:17 <Gracenotes> *random stabbing*
00:12:25 <edwardk> *random dying*
00:12:33 <Gracenotes> *a kitten moans banefully in the background*
00:14:52 * edwardk is lamenting having decided to break up the dependencies of monoids into flags
00:15:00 <edwardk> i'll never get done adding #ifdefs at this rate ;)
00:29:08 <harovali> i'm having trouble in trying to grasp  "on" function.
00:29:35 <c_wraith> :t on
00:29:36 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
00:30:02 <c_wraith> I think there's only one possible implementation for that.
00:30:22 <opqdonut> ?src on
00:30:23 <lambdabot> (*) `on` f = \x y -> f x * f y
00:30:30 <opqdonut> that's all there is to it, really
00:30:39 <Gracenotes> well, suppose you have a function with two arguments
00:30:40 <mmorrow> has anyone else noticed that by default haddock spits out an alternative frame view of docs? it's pretty cool
00:30:42 <mmorrow> http://moonpatio.com/vacuum/haddocks/frames.html
00:30:49 <dolio> No, there are choices.
00:30:55 <Gracenotes> `on` transforms those two values, and then applies them to the argument
00:31:01 <dolio> Like (*) `on` f = \x y -> f x * f x.
00:31:05 <opqdonut> mmorrow: reminiscient of java api docs
00:31:06 <dolio> But that makes somewhat less sense.
00:31:11 <Gracenotes> er, to the function. uh.
00:31:13 <mmorrow> it does it in at least 2.4.1/2
00:31:20 <Gracenotes> @. djinn type on
00:31:21 <lambdabot> f a b c _ = a (b c) (b c)
00:31:28 <opqdonut> indeed
00:31:30 <Gracenotes> heh
00:31:30 <mmorrow> opqdonut: heh, i remember those
00:31:39 <Gracenotes> apparently djinn had the same idea you had, dolio
00:31:43 <harovali> i trying !
00:31:49 <dolio> Woo!
00:32:01 <mmorrow> @yarrrrrrrrr
00:32:02 <lambdabot> Unknown command, try @list
00:32:05 <mmorrow> @yarr
00:32:05 <lambdabot> Smartly me lass
00:32:06 <dolio> Yeah, it's not always great about using all its arguments.
00:32:16 <Gracenotes> it tries though
00:32:37 <Gracenotes> > ((+) `on` length) [1,2,3,4] [1,2,3,4,5,6,7,7]
00:32:38 <lambdabot>   12
00:32:55 <Gracenotes> well, s/7,7/7,8/, if need be
00:33:05 <mmorrow> for some reason the frames.html is the newer hackage-produced docs don't work though
00:33:17 <mmorrow> (maybe 2.4.1 doesn't quite work)
00:34:42 <harovali> Gracenotes: it always works on 2 arguments, right?  Not more, I mean ....
00:35:30 <Gracenotes> harovali: well, the type is (b -> b -> c) -> (a -> b) -> a -> a -> c
00:35:42 <Gracenotes> you could manage more arguments, perhaps, if c itself was a function
00:35:48 <Gracenotes> (x -> y)
00:35:58 <Gracenotes> then the type would be (b -> b -> x -> y) -> (a -> b) -> a -> a -> x -> y
00:36:29 <Gracenotes> but the x value would not be modified; it would just be put on the end. It's the two arguments that are passed and modified
00:36:48 <Gracenotes> and the only cases I've really ever used it in
00:37:14 <Gracenotes> but, yeah, 2 is the magic number.
00:37:29 <harovali> It can be thought of function composition on 2 arguments ?
00:37:34 <opqdonut> yeh
00:38:18 <harovali> great, thanks
00:38:18 <Gracenotes> in a /sense/, but with the caveat that the two arguments are the same type
00:38:26 <harovali> Gracenotes: thanks
00:39:05 <Gracenotes> @type \f g -> (. g) . f
00:39:06 <lambdabot> forall b c a a1. (a1 -> b -> c) -> (a -> b) -> a1 -> a -> c
00:39:51 <c_wraith> dolio: Oh, right.  I suppose I can see 3 different implementations of that, but two are kind of degenerate.
00:40:05 <Gracenotes> (^) on f = undefined
00:40:06 <dolio> Yeah.
00:40:10 <Gracenotes> **
00:40:22 <dolio> And yeah, you can fill in undefined for even more degenerate.
00:41:58 <Gracenotes> @pl \f g h x y -> f (g x) (h y)
00:41:59 <lambdabot> ((flip . ((.) .)) .) . (.)
00:42:02 <Gracenotes> x.x
00:42:14 <pumpkin> edwardk: don't do it!
00:43:01 <Gracenotes> nos
00:43:07 <Gracenotes> @type (. (+))
00:43:08 <lambdabot> forall c a. (Num a) => ((a -> a) -> c) -> a -> c
00:43:33 <Gracenotes> @type ((.) . (+))
00:43:35 <lambdabot> forall b a. (Num b) => b -> (a -> b) -> a -> b
00:43:37 <harovali> is Data.map a list of pairs or a real hash?
00:43:46 <Gracenotes> a balanced tre
00:43:47 <Gracenotes> e
00:43:57 <harovali> thanks
00:43:59 <pumpkin> (so neither)
00:44:17 <Gracenotes> log n times and such, efficient for an immutable structure
00:44:24 <boegel> is there an easy way to read Double values from a ByteString?
00:44:37 <boegel> i.e. a Double version of Data.ByteString.Char8.readInt
00:44:38 <pumpkin> boegel: as decimal numbers, or IEEE?
00:44:57 <pumpkin> @hackage bytestring-lexing
00:44:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-lexing
00:44:58 <boegel> pumpkin: readDouble (pack "3.5") yielding 3.5
00:45:06 <edwardk> pumpkin: almost done actually
00:45:14 <pumpkin> boegel: that package will do it then :)
00:45:20 <pumpkin> edwardk: nooooooooooooooooooooooooooooooooooooooooooooo
00:45:21 <boegel> pumpkin: aha! cool, thx
00:45:32 <Gracenotes> :
00:46:03 <Gracenotes> : ...  ::  .. ::: .. :::::  .. :::::::: ..
00:46:07 <Gracenotes> :o
00:46:33 <edwardk> pumpkin: its not so bad, i just pick up about a dozen flags. i'm almost terrified to see what the combinations will look like on hackage
00:46:50 <mmorrow> edwardk: heh
00:47:01 <edwardk> maybe i could have thought that out better actually =)
00:47:13 <edwardk> coz it literally is a dozen
00:47:21 <pumpkin> :P
00:47:29 <edwardk> does that mean i'll get all 2^12 combinations written out in the description!?
00:47:34 * mmorrow is looking forward to seeing the onslaught of conjunction junction
00:47:50 <boegel> hmm, that module requires alex...
00:47:50 <mmorrow> (disjunction junction?)
00:48:04 <Gracenotes> disjunction, junction, what's your function
00:48:26 <edwardk> if its too terrible during preview i'll make a couple of metaflags like 'kitchen-sink' or something and get rid of the fine grained ones ;)
00:49:31 <edwardk> r ^ n = getLog (Monoid.replicate (Log r) n) -- i'm looking for an unpack operation for data Log m = Log m -- i'm thinking exp or mexp
00:50:27 <edwardk> exp is a little 'too cute', i think mexp or expm expM? wouldn't be too ugly
00:50:47 <boegel> and alex seems broken with GHC 6.10.2 :-/
00:50:49 <boegel> beuh
00:51:59 <mun> does anyone know how to extend the syslog TCP server in http://book.realworldhaskell.org/read/sockets-and-syslog.html to accept multiple messages, i.e. received one then wait for another?
00:59:58 <harovali> insert   copies the balanced binary tree every time ?
01:00:06 <opqdonut> no
01:00:14 <opqdonut> it shares unmodified parts with the old version
01:00:23 <opqdonut> O(log n) nodes copied at maximum
01:00:40 <harovali> opqdonut: is that a possibility in haskell ? or is it internal ?
01:01:23 <opqdonut> in haskell it's not possible to modify the tree in-place because of purity
01:01:31 <harovali> opqdonut: sure
01:01:36 <opqdonut> but it is possible to design a binary tree that works well under insertion
01:01:48 <opqdonut> because subtrees can be shared between versions
01:01:58 <opqdonut> persistent datastructure is the keyword here
01:02:11 <harovali> opqdonut: is htat a monadic thing ?
01:02:16 <opqdonut> okasaki's functional datastructures has some theory and background
01:02:19 <opqdonut> not at all monadic
01:02:57 <harovali> opqdonut: still obscure, but clearing & thanks
01:03:00 <opqdonut> for example if i say: "let ys = a:tail xs", the tail of x is shared between ys and xs
01:03:44 <harovali> opqdonut: interesting indeed
01:04:08 <mmorrow> boegel: i use this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2071#a2071
01:04:11 <Cale> harovali: If you want, it copies the nodes of the binary tree between the root and the place where the new element is inserted.
01:04:45 <Cale> (well, under balancing, it's perhaps a little more complicated than that, but not much)
01:05:10 <mmorrow> , vacuum $ fix (\x -> Node () [x,x])
01:05:10 <Cale> harovali: The rest of the subtrees are shared between the new tree and the old one.
01:05:16 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
01:05:24 <mmorrow> , fix (\x -> Node () [x,x])
01:05:24 <harovali> Cale: yes, I can get that; perhaps the obscure part is how to consider purity and persistance at once
01:05:26 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
01:05:31 <mmorrow> , levels $ fix (\x -> Node () [x,x])
01:05:32 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
01:05:55 <mmorrow> harovali: the sharing "just happens" with graph reduction
01:06:02 <mmorrow> you don't even have to try
01:06:43 <mmorrow> like, this is a node with a ptr to "0" and a pointer to itself
01:06:46 <mmorrow> , fix (0:)
01:06:48 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
01:07:01 <mmorrow> and it's an "infinite list"
01:07:04 <sm> has anyone seen haskell code working with ofx data ?
01:07:11 <harovali> mmorrow: Cale: opqdonut: thanks
01:08:03 <Cale> It might be clearer as  let x = 0 : x in x
01:08:30 <Gracenotes> fixing functions tends to be more interesting :X
01:08:36 <Cale> That list in memory looks like one cons cell whose tail is pointing to that one cons cell.
01:08:40 <Gracenotes> @type fix
01:08:41 <lambdabot> forall a. (a -> a) -> a
01:08:51 <Gracenotes> as with `on`, a can itself be a function
01:08:54 <boegel> mmorrow: I stole this from ByteString.Lexing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3547#a3547
01:08:59 <Gracenotes> ((x -> y) -> x -> y) -> x -> y
01:09:22 <boegel> mmorrow: ah, but yours reads a list of Doubles
01:09:33 <Gracenotes> > fix (\f x -> if x == 1 then 1 else x*f (x-1)) 5
01:09:34 <lambdabot>   120
01:09:35 <mmorrow> boegel: i just use the [] as a substitute for Maybe
01:09:44 <mmorrow> it's only ever 1 elt long
01:10:06 <boegel> mmorrow: then why just (:p) don't use Maybe?
01:10:10 <mmorrow> (like reads)
01:10:22 <mmorrow> boegel: Maybe annoys me sometimes :)
01:10:30 <opqdonut> :t listToMaybe
01:10:32 <lambdabot> forall a. [a] -> Maybe a
01:10:32 <opqdonut> :)
01:10:49 <mun> does anyone know what the >> operator means in  (\a -> handlerfunc clientaddr msg >> return a)?
01:10:51 <boegel> mmorrow: is it fast, your version of readDouble?
01:10:59 <opqdonut> mun: it means "and then"
01:11:00 <boegel> @type (>>)
01:11:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
01:11:06 <opqdonut> mun: it sequences too monadic actions
01:11:10 <mmorrow> boegel: i haven't benchmarked it actually, but i'd be interested to find out
01:11:20 <opqdonut> mun: kinda like >>= but with no information flow
01:11:30 <boegel> mmorrow: well, I think the function I'm using will be a lot faster
01:11:32 * boegel tries it
01:11:51 <mun> opqdonut: i see. thanks
01:11:56 <mmorrow> boegel: oh, yeah it will (i just looked at what you're using)
01:11:57 <opqdonut> mun: that line you pasted could be written as "f a = do handlerfunc clientaddr msg; return a"
01:12:22 <mun> opqdonut: so what's good about using the >> operator?
01:12:24 <mmorrow> boegel: but it also will fail badly (?) if the bytestring isn't a num
01:12:39 <mmorrow> (which was the function of alex in that pkg)
01:12:56 <opqdonut> mun: well there's nothing good or bad as such, sometimes it's what's needed
01:13:10 <opqdonut> it can be written with >>= tho
01:13:15 <opqdonut> ?src (>>)
01:13:16 <lambdabot> m >> k      = m >>= \_ -> k
01:13:47 <mmorrow> boegel: (also note that mine doesn't do scientific notation)
01:13:53 <opqdonut> mun: we use" m >> k"  when we're only interested in the side-effects of m
01:13:59 <opqdonut> not in the result
01:14:03 <mmorrow> although it'd probably be easy to add if desired
01:14:18 <mun> opqdonut: what do you mean by the side-effects of m?
01:14:50 <boegel> mmorrow: I don't know if mine does, I only care about stuff like "3.14"
01:15:17 <mmorrow> boegel: what happens on malformed input to strtod?
01:15:28 <opqdonut> mun: the monadic side-effects, kinda like: putStrLn "enter your name:" >> getLine
01:15:28 <boegel> mmorrow: no idea :)
01:15:34 <mmorrow> boegel: hehe
01:15:44 <boegel> mmorrow: but I'm not passing it malformed input, so I don't care (for now)
01:15:46 <opqdonut> mun: that first prints "enter your name:", then reads a line from the user and returns it
01:16:01 <mmorrow> boegel: ah nice, in that case you're golden
01:17:27 <mun> opqdonut: ah ok
01:19:25 <boegel> mmorrow: hmm, does your function care about spaces in the ByteString you're parsing?
01:20:06 <boegel> hmm, wait
01:20:09 <boegel> this is with my version
01:20:13 * boegel scratches his head
01:24:05 <boegel> mmorrow: no, it's not, it's in your version
01:24:24 <mmorrow> uhoh, what?
01:24:39 <mmorrow> (strtod return 0.0 on malformed input it seems)
01:24:56 <boegel> mmorrow: it's not parsing something my version is parsing, checking out what
01:25:10 <mmorrow> boegel: ah, yeah it doesn't drop spaces
01:25:16 <boegel> mmorrow: hmm, k
01:25:23 <mmorrow> (although that sounds like a good idea)
01:25:53 <mmorrow> , ord ' '
01:25:55 <lunabot>  32
01:26:36 <mmorrow> boegel: adding this to the first "case" does the trick
01:26:39 <mmorrow>   c | c == 32   -> readDouble (unsafeTail s)
01:26:42 <mun> opqdonut: i get it now. thanks
01:27:05 <mmorrow> (adding it as the first alt that is)
01:27:27 <mmorrow> well, i guess it doesn't matter which alt it is
01:27:33 <opqdonut> mun: you're welcome
01:28:32 <mmorrow> , read (('\n':) . show . negate $ pi) :: Double
01:28:34 <lunabot>  -3.141592653589793
01:28:46 <mmorrow> , filter isSpace ['\0
01:28:48 <lunabot>  luna: lexical error in string/character literal at character '0'
01:28:53 <mmorrow> , filter isSpace ['\0'..'\127']
01:28:55 <lunabot>  "\t\n\v\f\r "
01:29:05 <mmorrow> , fmap ord . filter isSpace $ ['\0'..'\127']
01:29:06 <lunabot>  [9,10,11,12,13,32]
01:29:23 <boegel> mmorrow: when reading in ~100k high-dimensional points (89-dim), my readDouble needs ~9.6s, while yours needs ~11.1s
01:29:42 <mmorrow> boegel: nice, not bad considering the competition
01:29:48 <boegel> mmorrow: of course, this isn't just the parsing, but everything else too
01:29:54 <mmorrow> ah
01:30:02 <mmorrow> well, still i guess
01:30:15 <boegel> I think we can make a rough estimate from this...
01:30:18 <mmorrow> boegel: (by your version you're referring to strtod, right?)
01:30:35 <boegel> mmorrow: yeah
01:30:39 <mmorrow> cool
01:31:03 <boegel> mmorrow: I'm parsing about 94*100k doubles in this, but also reading in all the data from file
01:31:15 <mmorrow> they're some ways that readDouble could be optimized too i guess.. the first that comes to mind is not handed the `negate' down through each function
01:31:34 <mmorrow> boegel: nice
01:31:54 <boegel> mmorrow: well, I think your version might be slower than you think
01:32:07 <mmorrow> boegel: how so?
01:32:14 <boegel> mmorrow: it's a 1.6s difference, _only_ because of your readDouble version
01:32:23 <mmorrow> yeah
01:32:35 <mmorrow> i don't think you could do much better in pure haskell
01:32:48 <boegel> mmorrow: oh, I'd have no idea
01:32:54 <mmorrow> it's even using unsafeTail
01:32:58 <boegel> mmorrow: I just need something _fast_ now
01:33:01 <boegel> mmorrow: which is?
01:33:10 <mmorrow> it doesn't bounds check
01:33:35 <boegel> mmorrow: oh, I see
01:33:36 <mmorrow> (but i still bounds check by checking for null (but just once))
01:34:18 <mmorrow> yeah, hmmm, i wonder if there's some way it /could/ be made as fast as C
01:34:59 <mmorrow> maybe peekElemOff'ing the raw ptr and other such
01:35:13 <mmorrow> bah, might as well just use C
01:35:45 <mmorrow> boegel: oh yeah, i think you should totally use the strtod version
01:35:57 <mmorrow> boegel: i'm gonna start using that one too
01:35:58 <mun> with the tcp syslog server shown in http://book.realworldhaskell.org/read/sockets-and-syslog.html, how come a message sent ending with newline by the client gets printed out by the server? where does it wait for the next message? how come the mapM_ line is run upon a newline character?
01:36:20 <mmorrow> (in cases where i don't care if malformed input will come back as 0.0 that is)
01:37:34 <boegel> mmorrow: :
01:37:35 <boegel> :)
01:37:49 <boegel> mmorrow: I don't know how it'll come back
01:38:02 <mmorrow> it gives back 0.0, i tried
01:38:55 <boegel> mmorrow: ah, k
01:39:10 <boegel> mmorrow: it would be better if it gives a warning though :-/
01:39:26 <boegel> mmorrow: now there's no way to tell if something went wrong
01:43:15 <mmorrow> yeah, that's the unfortunate part
01:44:03 <mmorrow> although it'd still be pretty fast to first strip spaces off the front, and check if the first non-space char (Word8) is a '-' or a digit
01:44:49 <mmorrow> (well, if it's a '-' then you have to check the next char too)
01:46:30 <boegel> I'm wondering if strtod handles the '-' well... that's rather important in my case
01:47:18 <mun> given the function to process incoming msgs from a client, http://haskell.pastebin.com/m63c75701, does it handle all the messages in a bulk or does it handle one message at a time?
01:47:27 <boegel> seems like it does
01:49:40 <fasta> mun: do you mean whether it happens in parallel?
01:50:03 <mun> fasta: well, for example, the client sends "foo\n" then "bar\n"
01:50:22 <mun> fasta: would the server print out the first line once it has received it?
01:50:31 <mun> fasta: assuming plainHandler to be used, that is.
01:51:29 <mun> fasta: i've tried it out but it seems to print out the line it has just received. but i don't see how it works because mapM_ applies the handler to all of the messages in one go, right?
01:52:46 <fasta> mun: according to that logic mapM_ launchNuclearMissile some_infinite_list will never destroy anything.
01:52:55 <fasta> mun: which is not the case.
01:54:01 <fasta> mun: does that make sense?
01:54:24 <mun> fasta: but, let's walk through this situation: client sends "foo" to the server, the variable messages would contain "foo", right?
01:55:00 <mun> then mapM_ applies the handler to "foo", so it gets printed out. but how about the second round when the client sends "bar"?
01:55:04 <mun> how does it loop back?
01:56:06 <fasta> mun: oh, I see what is bothering you.
01:56:30 <mun> fasta: i'm just not sure how it manages to loop back to process the next message
01:57:13 <mun> is hSetBuffering connhdl LineBuffering doing the magic? i can't seem to find much doc about what it actually does
01:58:36 <mun> fasta: FYI, this is taken from the TCP syslog server: http://book.realworldhaskell.org/read/sockets-and-syslog.html
01:59:35 <fasta> mun: I don't know enough of the exact semantics to explain you, but I think that the magic responsible is some kind of unsafeInterleaveIO in the definition of hGetContents.
02:01:20 <mun> hmm
02:02:30 <jedai> mun: It never "loops back"
02:03:34 <mun> jedai: yeah, i understand. but what i don't get is how it manages to handle a line at a time and waits for the next line.
02:03:43 <jedai> mun: The only "magic" in there is that the IO in hGetContents is lazy
02:04:03 <fasta> mun: the lazy IO can be implemented with unsafeInterleaveIO
02:04:18 <jedai> mun: it only reads as much as it needs, so it reads one line, that get passed to (handler...)
02:05:02 <jedai> mun: then throw away this line (or rather the GC free it) and read another line, and so on
02:05:16 <mmorrow> boegel: i think this is as fast as it can get with doing the error check on the haskell side http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3547#a3548
02:05:42 <boegel> mmorrow: ah, cool :)
02:05:52 <mmorrow> boegel: i'm interested to see how much overhead above plain strtod that version introduces
02:06:25 <boegel> mmorrow: I'll see if I can benchmark it
02:06:32 <boegel> mmorrow: I really need to finish up on stuff though
02:06:34 <mun> jedai: hmm so in the line with mapM_, messages doesn't already contain all of the input, right?
02:06:43 <mun> due to lazy IO?
02:06:44 <mmorrow> boegel: :)
02:07:44 <mmorrow> that'd be nice to wrap all the "strto*"s in stdlib.h like that..
02:07:47 <jedai> mun: Yeah, but you can treat it as if it did contain all the input (since we're lazy)
02:07:51 <mmorrow> i think i'm gonna do that
02:08:24 <edwardk> hrmm dependencies doesn't show flags that just add stuff?
02:08:34 <edwardk> no 'conjunction junction ;)
02:08:55 <mmorrow> awwww
02:08:56 <mmorrow> :)
02:09:04 <jedai> mun: Another way of saying it is that messages contains all the input, it will be there when you ask it, even if in reality it was only a thunk (a suspended computation) before your request
02:09:19 <[1]Jigg> http://gfg04.mybrute.com ... coolest game ever lmao
02:10:09 <edwardk> cut down the number of modules about 20% by consolidating stuff, parameterized it on a ton of flags, the only gratuitous dependency left is on category-extras
02:10:10 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/
02:10:31 <edwardk> kind of annoying to find 'Field' in Data.Ring, but i'll live with the quirks for now
02:11:14 <mmorrow> that seems logical to me
02:11:27 <edwardk> er woops Field should be DivisionRing f => Field f, meh, will catch it tomorrow
02:11:32 <mun> jedai: i see. but to understand the working, please correct me if i'm wrong: mapM_ applies the handler to a line each time, so hGetContents only reads one line a time?
02:11:53 <edwardk> mmorrow: i merged VectorSpace into Module alongside R-algebras
02:11:53 <mmorrow> siempre manana
02:12:02 <mmorrow> cool
02:12:06 * mmorrow darcs pulls
02:12:33 <edwardk> hrmm, checking to make sure i updated that repo ;)
02:12:55 <edwardk> pushed darcs
02:13:36 <edwardk> i work locally and have it upload my docs into a darcs repo in the 'dist' folder of the darcs repo upstream, coz it eases my workflow but it can get me a little out of sync some times
02:13:47 <mmorrow> gah, darcs failure darcs failed:  ./Data/Generator/Compressive/LZ78.hs: openBinaryFile: does not exist (No such file or directory)
02:13:47 <mmorrow> Your repository is now in an inconsistent state.
02:13:55 * mmorrow gets from scratch
02:14:24 <edwardk> ugh
02:14:24 <mmorrow> hmm, it still gives a:
02:14:26 <mmorrow> darcs: ./Data/Generator/Compressive/LZ78.hs: openBinaryFile: does not exist (No such file or directory)
02:14:31 <mmorrow> (but gets ok)
02:14:47 <jedai> mun: presumingly the handler evaluate the content of the command (pattern matching or whatever), so this parameter is forced, it corresponds to an element of the list passed to mapM_ which means lines have to evaluate one more list cell, so it has to read the handle until it find a newline
02:14:52 <edwardk> pull the tarball from hackage if need be, i need to fix that repository
02:14:58 <mmorrow> will do
02:15:41 <edwardk> with the hacked in num and bits for Bool http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Ring-Boolean.html#t%3ABoolean turned out kinda clean
02:16:42 <mmorrow> innteresting
02:16:45 <edwardk> i added similar instances to bitset so you can run a boolean ring over a BitSet a for any enumerable bounded type
02:18:11 <edwardk> getting a couple of hours of sleep before work
02:18:14 <edwardk> night
02:18:16 <mmorrow> night
02:19:58 <mun> jedai: thanks for that
02:20:01 <mun> fasta: thanks
02:38:33 <yakov> hello
02:38:53 <yakov> does anybody know where I can get Obsidian? /Haskell DSEL for CUDA programming/
02:39:22 <\stro> I'm interested too
03:10:16 <kadaver> if I hie bot List. foldr and foldl and Prelude foldr and foldl
03:10:26 <kadaver> how can i then use it in a instance Foldable
03:10:28 <kadaver> ?
03:10:33 <kadaver> because it works...
03:11:22 <vishnooo> hi
03:12:09 <Vq^> welcome to #Haskell Vishnooo
03:12:23 <kadaver> the nameclasehs in hskll are really annoying
03:12:55 <opqdonut> kadaver: import Prelude hiding (foldl,foldr)
03:12:56 <Vq^> yeah, i find myself hiding much of the Prelude when importing Foldable
03:13:03 <opqdonut> or, import qualified Foldable
03:13:19 <wli> Wait until you get nameclashes between classes and need to declare instances of them. ;)
03:14:19 <kadaver> it is jsut that the maximum given by foldable is a lot slower tha the one given by just traversing the Tree directly
03:14:33 <kadaver> i dont really find the foldable class allt hat helpful
03:15:25 <wli> mapM_, sequence, sequence_, toList, etc. are helpful
03:15:35 <wli> mapM from Traversable is too
03:17:34 <kadaver> but i had my own toList ,i had to implement that to do foldr in the first place
03:18:50 <Vq^> is that optimal?
03:20:52 <wli> It works a bit more nicely than various things one would otherwise use liftM for if they weren't of fixed arity/etc.
03:21:27 <wli> If they were of fixed arity rather.
03:21:29 <Vq^> foldr on your own datatype really shouldn't go via lists, not if you're talking about the Foldable functions being slow
03:22:28 <wli> e.g. LetExpr (Map var expr) expr loves mapM on its binding group Map
03:23:47 <wli> Mutatis mutandis for various things with whole collections floating around as internal components.
03:24:38 <wli> At other times I've used mapM_ on them.
03:49:27 <GoldyOrNugget> can pattern matching be used to check if both parameters to a functoin are the same? i want to do 'functionname par par = True', where it would return True if both parameters are the same.
03:49:51 <blackh> GoldyOrNugget: No - you have to use a pattern guard for that
03:49:53 <Ferdirand> you have to use a guard afaik
03:50:04 <GoldyOrNugget> ah, i haven't learnt those yet. i'll do that now.
03:53:02 <thomastc> functionname a b | a == b = true
03:53:29 <thomastc> *True
03:53:34 <thomastc> or, in this case, simply
03:53:42 <thomastc> functionname = (==)
03:53:56 <thomastc> ok, not necessarily ;)
03:56:13 <bremner> GoldyOrNugget: this is pretty well explained in Chapter 2 or 3 of Real World Haskell (book.realworldhaskell.org)
03:56:42 <GoldyOrNugget> i found a different tutorial, which i'm finding quite good
03:56:53 <GoldyOrNugget> thanks for everyones help
04:05:22 <mun> does anyone know where the type constructor for maybe is?
04:05:55 <__boegel__> pumpkin_: ping
04:07:16 <mun> oh nvm
04:08:01 <__boegel__> does anyone know if zipWithU from the uvector package streams the data it processes?
04:09:05 <__boegel__> I need to do something like "sumU $ zipWithU f l1 l2", where l1 and l2 are of type (UArr Double), and f is Double -> Double
04:09:28 <__boegel__> seems like combining sumU and zipWithU might not be the fastest way to implement this...
04:10:19 <__boegel__> or at least, it seems like it's a lot slower than a simple C function
04:11:12 <kadaver> but traversing a Tree naturally gors via lsits. a BST or RBT is traversed in order so i define a trverse function that takes a Tree and returns a list, then I implement foldr with that...
04:11:29 <mun> with http://haskell.pastebin.com/m74dbee48, how come i keep getting an error in line 15 saying "Couldn't match expected type `a -> a1'; against inferred type `IO ()'"?
04:20:06 <rio> mun: + vs. ++?
04:20:36 <mun> rio: oh yes, that was a typo. but that doesn't seem to be the cause of the error :(
04:26:51 <mun> i've pasted the error along with the code: http://haskell.pastebin.com/m34189a6a
04:27:56 <EvilTerran> mun, it's that $ that's tripping you up
04:28:19 <EvilTerran> plainHandler h addr msg = (putStrLn ("From " ++ show addr ++ ": " ++ msg) >> syslog h USER INFO) $ ("Message received: " ++ msg)
04:28:24 <EvilTerran> is what it's parsing as
04:28:45 <EvilTerran> if you re-write that as a two-line do-block instead of using >> explicitly, it'd be fine
04:29:17 <EvilTerran> mun, see http://haskell.pastebin.com/m5d16573d
04:29:51 <mun> EvilTerran: i see. so should i use () rather than $ if i want to keep the >> operator?
04:30:20 <EvilTerran> well, $ is lower precedence than >>, so that'd be necessary, yeah
04:30:27 <EvilTerran> but i think the do-block version would be clearer
04:30:36 <mun> EvilTerran: i see. thanks
04:31:31 * EvilTerran could see the use of, say, >>$ with the same precedence as $ for this kinda thing
04:32:26 <__boegel__> pfft, my Haskell k-means tool is still > 6x slower than a C equivalent
04:32:49 <__boegel__> tuning for performance in Haskell is _tough_
04:32:56 <EvilTerran> __boegel__, but is the C version >6x longer?
04:33:10 <__boegel__> EvilTerran: not really, no
04:33:13 <EvilTerran> aww
04:33:21 <__boegel__> EvilTerran: and all I care about is performance, not length of code
04:33:21 <blackh> __boegel__ - I might be able to offer some suggestions - does it fit in a paste?
04:33:38 <__boegel__> although I have to admit that I'm rewriting the tool in Haskell to make it more maintainable
04:33:49 <__boegel__> blackh: erm
04:34:12 <__boegel__> blackh: I could paste the whole app, but just take a look at this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3561#a3561
04:34:34 <__boegel__> blackh: that shows that it's still the distance function who's to blame, it seems
04:34:47 <__boegel__> even though I'm already streaming the data by means of UArr
04:35:46 <mun> does return () mean returns anything of the output type?
04:35:54 <EvilTerran> ?type return ()
04:35:55 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
04:36:09 <EvilTerran> ?type ()
04:36:11 <lambdabot> ()
04:36:18 <EvilTerran> ?src ()
04:36:19 <lambdabot> data () = ()
04:36:19 <blackh> Where does 'dist' get its input and what happens to its output?
04:36:36 <dobblego> () is the unit value
04:36:37 <EvilTerran> ^ that ?src isn't strictly true, but it captures the idea of ()
04:37:11 <__boegel__> blackh: you're suspecting thunks are being processed in the ds part of dist?
04:37:11 <mun> what does it mean by the unit value?
04:38:12 <blackh> __boegel__: Well, firstly I'm not really familiar with UArr... I am concerned about how you can avoid memory allocation
04:38:14 <__boegel__> blackh: the input comes from a list of (UArr Double)'s, and the output is thrown in a list, consumed by minimum
04:38:42 <EvilTerran> mun, the type "()" has only one value in it, "()". it's used for when you don't have any useful value to provide, but the type of an expression demands that you provide *some* value
04:39:20 <__boegel__> blackh: well, that might be part of the problem, yes, because I'm clustering ~11k data points in a 89-dimensional space :)
04:39:35 <mun> right, so it's like null?
04:39:50 <dobblego> mun, it's more like 'void'
04:40:09 <blackh> __boegel__: Is this DPH stuff\
04:40:11 <mun> i see
04:40:12 <mun> thanks
04:40:28 <Vq^> __boegel__: sounds fancy
04:41:10 <__boegel__> blackh: DPH?
04:41:18 <blackh> __boegel__: Ah, I see - it is. Well, I have not tried DPH (Data Parallel Haskell).
04:41:26 <__boegel__> Vq^: it's just clustering in a high-dimensional space, nothing special
04:41:35 <__boegel__> blackh: it's not, afaik :)
04:41:43 <Vq^> __boegel__: it still sounds fancy :o)
04:41:56 <blackh> __boegel__: What package does sumU come from?
04:42:08 <__boegel__> blackh: Data.Array.Vector (uvector)
04:42:27 <__boegel__> blackh: I was told it streams the data, rather than using a list (which is a lot slower)
04:42:31 <blackh> __boegel__: Then I am reading the wrong page in the haddocks!
04:42:39 <__boegel__> blackh: :)
04:42:47 <__boegel__> blackh: http://hackage.haskell.org/packages/archive/uvector/0.1.0.3/doc/html/Data-Array-Vector.html#v%3AmapU
04:43:39 <__boegel__> blackh: according to -sstderr, the tool only uses 95M max. live mem., and spends 10% in GC, which is fair I think
04:43:40 <SamB> __boegel__: what's the point of said clustering ... can it be used for graph-layout in 3-space or something?
04:43:49 <__boegel__> blackh: so I don't think memory usage is the problem
04:44:34 <__boegel__> SamB: well, I'm working with vectors describing pieces of execution in terms of features, stuff like how much ILP that particular execution window has
04:44:38 <blackh> __boegel__: Well, I wonder if the problem is that zipWithU is allocating memory - it shouldn't need to.
04:44:49 <__boegel__> because I have 89 features, each execution interval is described by a 89-dim vector
04:45:00 <__boegel__> blackh: I agree
04:45:20 <mun> i'm trying to write an echo server, does anyone know why when it tries to send the message back to the client, it crashes? http://haskell.pastebin.com/mb337fe0
04:45:22 <__boegel__> blackh: wouldn't I see more than 10% GC if it were allocating a lot of memory?
04:45:27 <mun> the line that echos back is line 84
04:45:48 <__boegel__> blackh: hmm -> total alloc = 751,694,104,672 bytes  (excludes profiling overheads)
04:46:08 <EvilTerran> __boegel__, 751GB? eek
04:46:09 <__boegel__> that's like 751G? or am I trippin'?
04:46:24 <__boegel__> but then, why is there only 10% GC??
04:46:37 <blackh> __boegel__: That seems likely, though I don't understand the problem.  Is there a toListU?
04:46:55 <__boegel__> blackh: yeah, fromU
04:47:41 <__boegel__> EvilTerran: something tells me those numbers just aren't right
04:47:43 <blackh> __boegel__: Try using plain old 'sum' and 'fromU' - this may not allocate memory. It may act as a 'producer-consumer'
04:48:22 <blackh> __boegel__: GHC unboxes arithmetic very well, and it fuses list processing very well too.
04:48:32 <__boegel__> blackh: well sum isn't the problem, zipWithU is
04:48:42 <blackh> __boegel__: If this is faster, then the conclusion might be that zipWithU is alocating memory.
04:49:11 <blackh> __boegel__: I mean use Prelude.sum, Prelude.zipWith and fromU
04:49:14 <__boegel__> blackh: my first implementation just simply used [Double] instead of (UArr Double), and was a lot slower
04:49:20 * __boegel__ tries
04:49:51 <bremner> sigh. Comment in student code: myFun has the type String to String
04:49:59 <blackh> __boegel__: Well, keep the input to 'dist' as a UArr.
04:50:18 <SamB> bremner: didn't they learn type sigs yet ?
04:50:22 <__boegel__> blackh: k
04:50:29 <bremner> Worse, the next line is the type signature
04:50:31 <blackh> __boegel__: Lists will be slow if they allocate memory, but they'll be fast if that part is optimized out.
04:50:45 * bremner is epic fail as teacher, obviously :-)
04:50:55 <SamB> bremner: lol
04:51:11 <Saizan> mun: do you get any error message?
04:51:20 <__boegel__> blackh: hmmk
04:51:23 <SamB> I guess you didn't do the "good comment/bad comment" thing yet -- or that student has trouble reading type sigs?
04:51:23 <blackh> __boegel__: Take a look at pidigits on the programming language shootout. That's a good example. That code looks really slow but actually it is very fast because there's no memory allocation at all in the number crunching part.
04:51:33 <__boegel__> blackh: but, if zipWithU allocates memory, then what's the use of UArr? :)
04:51:51 <bremner> SamB: to be fair, they have only been learning Haskell for 3 weeks.
04:53:07 <blackh> __boegel__: It all depends on how well the 'array fusion' works in UArr and I don't know the answer to that. But - if lists actually allocate memory, they'll be slower than UArr.
04:53:22 * SamB once wrote a comment to other students on a program in an exam ... though he doesn't think any of them has actually read it ...
04:53:45 <mun> Saizan: let me try to telnet again
04:53:52 <__boegel__> blackh: hmmk
04:54:45 <mun> Saizan: i get "<interactive>: <socket: 9>: hPutStr: illegal operation (handle is closed)"
04:55:55 <__boegel__> blackh: would there be another alternative to using zipWithU, instead of mapping it back to lists?
04:56:41 <mun> Saizan: would i be better off using some package?
04:57:36 <Saizan> mun: oh, that's because you use hGetContents on the same Handle, i guess
04:58:05 <__boegel__> blackh: at first sight, I'd say the version using fromU,zip,sum is slower, but I'm doing a profiling run too to make sure
04:58:09 <__boegel__> (which will take 15m :-/)
04:58:30 <blackh> __boegel__: Well, you could use !!U (whatever that's called) and write your own sum with an accumulating parameter, but GHC should optimize down to that.
04:58:39 <Saizan> mun: also, you open it in ReadMode
04:58:42 <mun> Saizan: yeah, i use hGetContents to read from the same handle. should i not?
04:59:16 <__boegel__> blackh: what's !!U?
04:59:39 <blackh> __boegel__: Fetch a value at a specified array index
04:59:55 <mun> Saizan: oh that's it! it is just the mode problem
05:00:10 <mun> Saizan: but typically i can use hGetContents on the same handle, can i/
05:00:43 <Saizan> mun: the documentation says that the Handle will appear as closed when you can hGetContents on it
05:00:45 <__boegel__> blackh: ah, you mean indexU
05:00:47 <gio123> does somebody knows leftmost inermost strategy?
05:00:50 <Saizan> s/can//
05:01:15 <Saizan> mun: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AhGetContents
05:01:58 <blackh> __boegel__: That's it - thanks.  You could try writing it usiing that, and an accumulating parameter.  You might also try forcing the output value to be strict.
05:02:20 <Saizan> gio123: that's applicative order i.e. call-by-value, no?
05:02:25 <blackh> __boegel__: Don't try indexU yet - try making the output strict...
05:03:09 <mun> Saizan: right. but i guess hGetContents closes the handle upon exit
05:03:27 <__boegel__> blackh: the output of dist?
05:03:36 <mun> Saizan: and when I send messages, hGetContents is still reading, right?
05:04:09 <blackh> __boegel__: I am still getting the hang of it myself a bit... try...  sqrt $! sum ds
05:04:44 <Saizan> mun: the handle is put in the semi-closed state immediately
05:04:57 <__boegel__> blackh: using sum or sumU?
05:05:24 <blackh> __boegel__: Using sum. How does the sum version compare to C with profiling turned off?
05:05:33 <gio123> Saizan:yes
05:05:44 <__boegel__> blackh: horribly slow :) (without $!)
05:05:47 <__boegel__> blackh: it's still running
05:05:55 <gio123> Saizan: I didnt undestand something there :(
05:05:56 <__boegel__> blackh: brb
05:06:10 <mun> Saizan: i see. what should be a better way to do this? use another handle for the same socket?
05:06:58 <Saizan> mun: if that's possible then yes
05:07:04 <blackh> __boegel__: So much for that idea! Still - based on my experience, this should work. The trick is to get it to optimize all the memory stuff out. This only works with implementations based on an accumulating parameter and I am pretty sure sum has one.
05:09:29 <mun> Saizan: thanks
05:09:51 <blackh> __boegel__: Yes, sum definitely uses an accumulating parameter
05:10:26 <mmorrow> gio123: what don't you understand?
05:10:30 <Saizan> sum is defined with foldl by default, though there are rules to convert that to foldl'
05:10:42 <blackh> __boegel__: fromU should translate into a sequence of memory fetches, and the arithmetic should all be unboxed.  That's the theory.
05:10:54 <mmorrow> i wouldn't (personally) rely on the strictness analyzer though
05:11:13 <blackh> __boegel__: Sum is very fast as long as its input can be generated quickly.
05:11:48 <__boegel__> blackh: so, you're saying the feeding dist two (UArr Double)'s, and using foldU on them to avoid memory allocation, should be the best way to implement it?
05:12:00 <Saizan> Prelude.sum and fromU might not fuse since one is based on foldr/build and the other on stream fusion
05:13:24 <blackh> __boegel__: Well, you can't do your algorithm without using a zip of some kind.  It could be that zip is the thing that's causing the problem.
05:14:30 <Itkovian> __boegel__: repo url?
05:14:52 <__boegel__> blackh: well, instead of using zipWith to combine two lists into a new list, I could zip and sum at the same time
05:15:10 <mmorrow> these are the foldr/build rules http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3567#a3567
05:15:15 <__boegel__> blackh: something like sumWith, with type "[a] -> [b] -> (a -> b -> c) -> c" or so
05:15:16 <mmorrow> sum is a foldl
05:15:28 <mmorrow> so it won't go away
05:15:53 <mmorrow> the best you can hope for is the strictness analyzer to make it a foldl' for you
05:16:09 <__boegel__> mmorrow: or I can make it a foldl'? :) right?
05:16:16 <__boegel__> sum' = foldl' (+) 0.0
05:16:18 <mmorrow> indeed :) that's what i'd do
05:16:36 <mmorrow> because then your code works in ghci too
05:17:02 <trofi^w> when we should prefer foldl over foldl' ?
05:17:17 <mmorrow> i almost never use foldl
05:17:21 <__boegel__> blackh: using fromU,sum,zipWith instead of sumU and zipWithU makes it ~20x slower
05:17:24 <mmorrow> @src reverse
05:17:24 <lambdabot> reverse = foldl (flip (:)) []
05:17:30 <mmorrow> that's the only on i can think of
05:17:31 <__boegel__> blackh: so 200x slower compared to C, roughly
05:17:45 <__boegel__> trofi^w: when space is a concern
05:17:47 <blackh> __boegel__: Try your sum'
05:18:08 <blackh> __boegel__: That's the problem, I think
05:18:45 <blackh> __boegel__: That is, try sum' with Prelude.zipWith and fromU
05:19:01 * __boegel__ tries
05:20:13 <blackh> __boegel__: I think laziness adds to Haskell's learning curve a fair bit - but you get so much power in return.  I've been doing algorithms that rely extremely heavily on it.
05:21:04 <__boegel__> blackh: I'm just finding it extremely hard to get decent performance out of Haskell code for large tasks
05:21:19 <__boegel__> blackh: I love it's expressiveness, but I can't tolerate losing performance of it
05:21:49 <mun> Saizan: regarding hGetContents, if the handle is put into semi-closed immediately, how come i can continue sending the server messages?
05:22:27 <mun> Saizan: i can send one message after another and the server still can receive and read them.
05:22:31 <__boegel__> blackh: hmm, doesn't seem to have helped much
05:22:39 <blackh> __boegel__: I agree it takes a lot of work to learn how to get speed out of Haskell, but I still think it's just a matter of knowing how. You have to understand what gets optimized and what doesn't - and you only learn that from experience.
05:24:04 <__boegel__> blackh: hmm, wait... (sqrt . sum') ds won't help me much right? I need to use sqrt $! sum' ds to enforce the strictness?
05:24:20 <__boegel__> or doesn't that matter?
05:24:37 <blackh> __boegel__: That shouldn't matter, because sum' has already done that.
05:24:39 <__boegel__> blackh: GHC should optimize it all, that would make it a lot easier ;-)
05:24:50 <__boegel__> blackh: right... well, then, doesn't seem to help much :P
05:25:04 <blackh> __boegel__: So - what's sum' relative to C?
05:25:22 <__boegel__> blackh: here's what I have now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3569#a3569
05:25:26 <__boegel__> blackh: it's pending, that :)
05:25:40 <__boegel__> but I'm guessing it'll also be 200x
05:26:36 <blackh> __boegel__: Well, it could be that it's optimized out to being the same. sum should be fast. OK - I can tell you a way that should work...
05:27:38 <__boegel__> blackh: :)
05:29:56 <blackh> __boegel__: blackhsZW l1 l2 0 = foldl' (\acc idx ->acc + euclidean ( l1 `indexU` idx) (l2 `indexU` idx)) 0 [0..(lengthU l1 - 1)]
05:30:24 * __boegel__ blinks
05:30:34 <Saizan> mun: hGetContents will continue to read from the handle even if it's semi-closed, the point of the semi-closedness is that no other function should use that handle anymore
05:30:53 <blackh> __boegel__: The point here is that `indexU` is simply a memory lookup, and foldl' should optimize right down to straight arithmetic.
05:31:15 <__boegel__> blackh: hmmk
05:32:09 <blackh> __boegel__: That's the theory.  It should inline automatically.
05:32:23 <blackh> __boegel__: That is, it should inline euclidean
05:32:49 <__boegel__> blackh: I could specify that
05:33:02 <__boegel__> {-# INLINE eucildean -#}
05:33:03 <__boegel__> right?
05:33:06 <__boegel__> #-} rather
05:34:34 <blackh> __boegel__: Yes, exactly so - you might have to put it at the top level.  I do agree with you that this is not the easiest thing in the world to achieve, but it definitely *is* possible to get GHC to execute this fast.
05:36:22 <blackh> __boegel__: I wonder if we mightn't find that after getting this to work, that it's no faster than your original implementation with zipWithU - but then we don't know until we try.
05:36:50 * __boegel__ hopes not
05:37:23 * __boegel__ still wonders about the 751G allocated memory reported by profiling, even though there was only 10% GC activity
05:37:31 <blackh> __boegel__: Think about how many machine instructions this code corresponds to - it's only about six.
05:37:53 <__boegel__> blackh: exactly :)
05:38:00 <__boegel__> blackh: that's why the C version is so damn fast
05:38:14 <__boegel__> blackh: getting this out of Haskell isn't so easy though :)
05:40:46 <blackh> __boegel__: No - it isn't that easy - but I think it's worth going through this exercise at least once. It makes it much easier to guess how fast your code is likely to execute.
05:48:36 <saml> without do block, is monad really special? or is it just a typeclass?
05:49:00 <vixey> "The dual of the pointfree notation is the pointwise one" ?  wtf ....
05:49:11 <Lemmih> saml: It's just a typeclass.
05:49:42 <saml> Lemmih, thanks
05:49:48 <gio123> does somebody knows leftmost inermost strategy?
05:49:49 <saml> vixey, where did you find that?
05:50:00 <SamB> well, technically it's a constructor class ;-P
05:50:04 <saml> gio123, that sounds like eager evaluation
05:50:10 <vixey> http://ulissesaraujo.wordpress.com/2009/04/08/anamorphisms-in-haskell/
05:50:11 <__boegel__> blackh: the version using zipWithU/sumU is definitely a lot faster still
05:50:36 <__boegel__> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3569#a3573
05:51:26 <blackh> __boegel__: Hmm... is accSum' any faster than the 200x ones?
05:51:44 <__boegel__> blackh: checking that now, will take like 10m or so
05:52:21 <__boegel__> blackh: I have the impression it is, but not much probably
05:52:24 <blackh> __boegel__: I can commend Microbench, except that it says 'ns' when it really means 'us'.
05:52:37 <__boegel__> blackh: Microbench?
05:53:08 <blackh> __boegel__: It's a package on hackage. It is useful for quickly and easily benchmarking a function.
05:54:36 <__boegel__> blackh: yeah, well, I'm trying to benchmark it in the tool it's going to be used in :)
05:55:11 <__boegel__> which isn't the best way, I know, but profiling is at least telling me that dist is the bottleneck
05:55:46 <blackh> __boegel__: Microbench has the advantage that it accurately measures things that take a very short time.
05:56:06 <__boegel__> blackh: right...
05:56:42 <__boegel__> blackh: I would need to figure out how to pass values to dist without risking of them being optimized away though ;:)
05:57:14 <ivanm> blackh: oh? sounds cool...
05:57:23 <blackh> __boegel__: Microbench has a way of dealing with that, and I have a different way, which is to put the input into an IORef and read it each time.
05:58:00 <blackh> __boegel__: With my way you have to force the input and output. I use rnf for that.
05:58:07 * ivanm benchmarks functions by compiling, timing whilst running, using other function, compiling, timing whilst running, comparing difference
05:58:17 <__boegel__> blackh: it seems the accSum' version isn't significantly faster than the ones using fromU
06:00:34 <__boegel__> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3577#a3577
06:00:36 <solidsnack> So what if open just gave us a list of monadic actions, e.g.  `open :: String -> [IO Word8]`
06:00:47 <solidsnack> What practical problems would that present?
06:01:05 <__boegel__> can someone explain me how I could be allocating 25G of memory, with only 20% GC in 50s??
06:01:13 <__boegel__> seems damn near impossible
06:01:27 <blackh> __boegel__: Well, I'm not surprised they're all about the same, but I am surprised it's so much slower than zipWithU.
06:01:42 <blackh> __boegel__: I can explain it. Are you using ghc 6.10.1?
06:01:48 <__boegel__> blackh: 6.10.2
06:01:59 <__boegel__> blackh: on 64-bit, if it matters
06:02:11 <blackh> __boegel__: Then I can't explain it.
06:02:14 <__boegel__> blackh: please do explain
06:02:22 <__boegel__> blackh: ah :(
06:02:31 <__boegel__> blackh: how would you explain it with 6.10.1?
06:02:37 <blackh> __boegel__: In 6.10.1 there's a bug where in certain cases GC happens much less often than it should.
06:02:53 <ddarius> solidsnack: Presumably each IO Word8 is a read function for a byte.  In that case, 1) how do you write, 2) the list itself would still need to be in IO, 3) seeking would be O(n).
06:03:38 <solidsnack> ddarius: Hmm, okay.
06:03:45 <mmorrow> fyi gio123 should probably be banned. he enjoys left-innermost evaluation and /msging about cock sucking
06:03:47 <__boegel__> blackh: that doesn't mean I would be able to allocate 25G of memory in 50s, with a 140MB of max. live memory, does it?
06:03:49 <ddarius> (You could avoid the list being in IO by making it infinite or taking a length, but both seem somewhat ugly.)
06:04:19 <solidsnack> ddarius: I was going to make it infinite and then throw an exception on EOF as a rough cut.
06:04:33 <mmorrow> so be warned should he want your help
06:04:37 <solidsnack> Seeking would be problematic, yeah.
06:04:37 <__boegel__> blackh: seems like something is wrong with the profiling to me... the 25G allocation part can't be right imho
06:05:07 <blackh> __boegel__: It sounds like it could be this same bug. I thought it was fixed.
06:05:20 <mmorrow> gio123: hi!
06:06:15 <__boegel__> blackh: but then it's just the reporting part right, it's not actually allocating 25G, or is it?
06:06:24 <solidsnack> Also, I think the handle would be embedded in every read operation in the last so you'd have the usual issues with concurrent mutation.
06:06:49 <vixey> solidsnack: Do you think it's better than iteratee
06:06:54 <blackh> __boegel__: Are you sure it's 25G? My machine dies at about 3G (Ubuntu amd64)
06:07:06 <solidsnack> vixey: I don't think it's better than iteratee, no.
06:07:29 <solidsnack> I'm just working through why such a seemingly simple solution is wrong.
06:07:47 <blackh> __boegel__: I am pretty sure that this bug is fixed in ghc 6.10.2, because it made pidigits use excessive memor.
06:08:48 <blackh> __boegel__: Oh right - that's total turnover, not total memory.
06:09:10 <__boegel__> blackh: it allocating 25G in total,  but only has 140M of live memory max.
06:09:12 <__boegel__> blackh: right
06:09:21 <__boegel__> blackh: still 25G is _a lot_ :)
06:09:26 <blackh> __boegel__: So what version of 'dist' are you profiling there?
06:11:30 <Lemmih> __boegel__, blackh: What program are you guys looking at?
06:12:02 <blackh> Lemmih: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3569#a3573
06:13:08 <Axman6> __boegel__: compiling with profiling info does tend to make things a lot slower
06:13:47 <blackh> __boegel__: Oh yes - I forgot to ask - Are you timing against C without -prof?
06:14:25 <Axman6> for something like this, i'd expect a massive overhead from the profiling. compile it with -O2, and no profiling, and then time it
06:15:59 <__boegel__> Lemmih: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3573
06:16:21 <__boegel__> blackh: this profile is for the fastest dist, with zipWithU and sumU
06:16:33 <Axman6> __boegel__: how's it compiled though?
06:16:37 <__boegel__> blackh: of course :)
06:16:42 <__boegel__> blackh: without -prof, it's about 8s
06:16:51 <Axman6> with -O2?
06:17:06 <__boegel__> Axman6: I compile with -O2 -fexcess-precision -fvia-C -optc-O3 -optc-march=core2 -optc-mfpmath=sse -optc-msse -optc-msse2
06:17:13 <blackh> __boegel__: What about my versions? Did you time without -prof?
06:17:21 <__boegel__> blackh: both with and without
06:17:32 <Axman6> because that code should be rather fast indeed
06:17:35 <__boegel__> blackh: the 200x slowdown compared to C is without profiling, of course :)
06:18:27 <__boegel__> if I run the profiled one, which shows the 25G mem. alloc., without profiling, it takes about 8s
06:18:30 <__boegel__> so yeah, huge overhead
06:18:36 <__boegel__> but the C version only needs ~1s
06:18:41 <blackh> __boegel__: In my experiments -fvia-C made it marginally slower
06:18:51 <__boegel__> blackh: hmm
06:19:08 <Lemmih> What input are you using?
06:19:19 <Axman6> yeah, sounds to me the slowdown is somewhere else
06:20:27 <Lemmih> And what does the C code look like?
06:21:05 <__boegel__> Lemmih: it's measurded as part of a k-means implementation, which clusters ~11k points in 10 or 100 clusters
06:21:15 * __boegel__ pasted the C code last night
06:21:37 <__boegel__> Lemmih: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3513
06:21:44 <__boegel__> Lemmih: this is just the dist function though
06:21:55 <__boegel__> Lemmih: not the k-means code that uses it
06:22:11 <__boegel__> Lemmih: but because profling (in Haskell) tells me most time is spent in dist, I figure I should concentrate on dist
06:23:11 * __boegel__ sighs
06:24:17 <__boegel__> maybe I shoudl be looking at the assembly being generated
06:24:30 <__boegel__> only problem is to figure out which part corresponds to dist :-/
06:26:48 <pejo> boegel, it's probably easier to start looking at core
06:26:50 <__boegel__> pejo: well, depends on your definition of 'easy' :P
06:26:50 <__boegel__> pejo: I tried that, but I was utterly confused
06:26:51 <pejo> boegel, more of the structure of your original program should be left in core.
06:27:49 <Itkovian> __boegel__: can you paste the complete program somewhere? I've some time while results are being parsed :-)
06:29:36 <mmorrow> __boegel__: you could also too just foreign import ccall unsafe "dist" c_dist :: ...
06:30:15 <__boegel__> this is the relevant Core code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3581#a3581
06:30:22 <__boegel__> Itkovian: I could
06:30:32 <Itkovian> __boegel__: Or is it in the repo?
06:33:15 <__boegel__> Itkovian: http://www.elis.ugent.be/~kehoste/kmeans_Haskell_draft.tgz
06:33:21 <__boegel__> Itkovian: not yet, I want it fast
06:33:25 <__boegel__> first
06:34:29 <__boegel__> mmorrow: I could
06:34:44 <__boegel__> mmorrow: maybe I should give that a try before I continue
06:35:05 * __boegel__ doesn't know what to try first anymore
06:35:07 <__boegel__> urgh
06:36:55 <Axman6> __boegel__: why are you pasting Core?
06:36:57 <__boegel__> the fastest dist function in the tarball is dist' btw
06:37:15 <__boegel__> Axman6: to try and figure out why it's allocating 25G of memory
06:37:29 <__boegel__> Axman6: although that seems bogus, because there's only 10% GC
06:37:35 <Axman6> just paste the actual program, like you've been asked to numerous times
06:37:48 <__boegel__> Axman6: I have, in the tarball I mentioned above
06:37:54 <Axman6> -_-
06:37:57 <__boegel__> Axman6: http://www.elis.ugent.be/~kehoste/kmeans_Haskell_draft.tgz
06:38:12 <__boegel__> Axman6: I consists of 3 modules, which is why I didn't hpaste it
06:38:31 <Axman6> ou could always past them as annotations
06:42:00 <mmorrow> @hoogle mallocArray
06:42:01 <lambdabot> Foreign.Marshal.Array mallocArray :: Storable a => Int -> IO (Ptr a)
06:42:01 <lambdabot> Foreign.Marshal.Array mallocArray0 :: Storable a => Int -> IO (Ptr a)
06:42:01 <lambdabot> Foreign.Marshal.Pool pooledMallocArray :: Storable a => Pool -> Int -> IO (Ptr a)
06:42:06 <mmorrow> @hoogle mallocBytes
06:42:06 <lambdabot> Foreign.Marshal.Alloc mallocBytes :: Int -> IO (Ptr a)
06:42:07 <lambdabot> Data.ByteString.Internal mallocByteString :: Int -> IO (ForeignPtr a)
06:42:07 <lambdabot> Foreign.Marshal.Pool pooledMallocBytes :: Pool -> Int -> IO (Ptr a)
06:42:30 <mmorrow> @hoogle peekArray
06:42:31 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
06:42:31 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
06:42:35 <mmorrow> @hoogle pokeArray
06:42:36 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
06:42:36 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
06:48:20 <mmorrow> __boegel__: the nice thing about hmatrix is that you get haskell convenience wrt the interface, and at the same time all the operations on vectors/matrices are either in C (LAPACK,cblas,gsl) or FORTRAN (via some C lib)
06:48:35 <mmorrow> so you get speed too
06:48:44 <mmorrow> i think it's win-win
06:49:27 <wli> (this doesn't help when you need linear algebra over e.g. algebraic extensions of K(x) where K is in turn an algebraic extension of Q)
06:49:48 <mmorrow> heh
06:54:19 <Lemmih> __boegel__: dist' seems fairly fast.
06:56:17 <__boegel__> Lemmih: but the whole app is still ~10x slower than a C equivalent
06:56:41 <__boegel__> Lemmih: and if I profile the app using dist', then it's telling my most of the execution time is spent in dist' ...
06:57:15 <__boegel__> Lemmih: and also that it allocates huge amounts of memory during the execution, but with a small amount of live memory
06:57:22 * __boegel__ has enough for today
06:57:39 <Lemmih> __boegel__: dist does 13 iterations in 50s, dist' does 56 in 30s.
06:59:44 <Lemmih> Both have allocation rates of ~600megs per second which is quite normal.
07:02:28 <Lemmih> __boegel__: The time it takes to garbage collect is a function of the amount of live data. GHC allocates huge amounts of short-lived data which is essentially free to clean up.
07:02:52 <mlesniak> Anyone knows of a possibility to download a snapshot of haskell.org (for offline use, leisure surfing, ...)?
07:03:07 <voker57> wget -r?
07:03:31 <Japsu> wget --mirror
07:03:45 <mlesniak> voker57: Puts the webserver under a heavy load, e.g. from http://senseis.xmp.net you can download a .tar.gz...
07:04:02 <mlesniak> (Ok, maybe Go is a special use case ;-)...)
07:04:10 <lpsmith> The problem with __boegel__'s code,  I think,   is the use of zipWithU
07:04:46 <gwern> wget -r is hardly a heavy load; it's rate-limited by default to a single thread making a page request every second or two
07:04:52 <flazz_> i put my source in src/ and added -i src to my ghc call, now i get Could not find module 'src'
07:04:52 <lpsmith> I bet it would allocate less and be a fair bit faster if you replace that with an explicitly coded loop
07:04:57 <flazz_> what could i be doing?
07:05:11 <mlesniak> gwern: Hmm, ok, sounds reasonable then...
07:05:14 <lpsmith> and allocate very little or nothing, properly done
07:05:19 <gwern> flazz_: out of curiosity, why not src/ ?
07:05:40 <gwern> mlesniak: now, there might be a local issue depending on whether wget will get all possible diffs on page histories
07:05:43 <flazz_> gweiqi: i did put my code in src/
07:05:44 <__boegel__> Lemmih: ok, but allocating 25G of memory during the run of a 50s program
07:06:20 <gwern> mlesniak: for example, I tried wget -r on a local gitit repo; while the repo is only about 10megs, the wgetted version wound up being about 40 because it got every pairwise-diff history page as well
07:06:31 <__boegel__> lpsmith: well, something must be going on there
07:06:44 <mlesniak> gwern: Hmm, maybe I have to play a bit with the exclude-filters...
07:06:56 <__boegel__> lpsmith: what do you mean by "explicitely coded loop"?
07:07:38 <gwern> mlesniak: of course, one could argue that that is what I asked for - a static version of all the dynamic content...
07:08:34 <mlesniak> gwern: Yes, right, but since I'd like only the newest version of each page a wget -m seems a bit overpowered ;-)
07:09:57 <Lemmih> __boegel__: That is quite normal. GHC allocates at the same rate when compiling your program.
07:10:04 <__boegel__> Lemmih: hmmk
07:10:27 <__boegel__> Lemmih: seems rather excessive though
07:11:14 <Lemmih> __boegel__: It may be but at least it isn't very expensive.
07:12:56 <ManateeLazyCat> I have a core *data* object, named 'DataCore'; And have three *display* object, named "Display1" "Display2" "Display3", and those *display* object for display the content of *data* object; *display* object can modified the value of 'DataCore' object, then 'DataCore' object will update all content of *display* objects, make them synchronous, so i want to how to implement those *communication mechanism* in Haskell style?
07:14:12 <ManateeLazyCat> I just study Monad, State Monad can do above work perfect?
07:14:41 <ManateeLazyCat> I just want to some suggestions before i study deeply. Thanks.
07:16:20 <pejo> ManateeLazyCat, what do you use your display objects for?
07:17:52 <ManateeLazyCat> pejo: Now, i'm develop editor, i want to use a data structure to store buffer content, then i split current buffer with some windows, i want to synchronous buffer content in different windows when i modified content in any windows.
07:18:52 <ManateeLazyCat> pejo: So i plain to implement a core data object to store buffer content, then use many window (my display object) to communication with buffer string.
07:19:46 <blackh> ManateeLazyCat: I would probably do this: editor :: [InputEvent] -> [UpdateEvent] where InputEvent is mouse clicks, key presses, etc, and UpdateEvent contains the whole DataCore object along with instructions on what parts of the display need to be updated.  [InputEvent] might need to come from a Chan.
07:19:56 <lpsmith> __boegel__:  I just uploaded a modified snippet to illustrate what I mean
07:20:05 <lpsmith> No promises that it even compiles
07:20:13 <lpsmith> or that it's exactly what you want
07:20:23 <lpsmith> but that style of code should be a bit faster in this context
07:20:46 <pejo> ManateeLazyCat, you might be interested in looking at the sources of "Yi" for inspiration.
07:21:32 <ManateeLazyCat> pejo: I have did it, but i don't want use Yi's implement method.
07:23:18 <ManateeLazyCat> blackh: Yes, i have implement separate module for different event. But i just want "one* copy of buffer content with split many windows, then i use callback synchronous all windows's buffer content when i modified buffer in any split window.
07:23:57 <ManateeLazyCat> So simple, i just want to know the *best* way to update some variable, then i study deeply.
07:24:56 <orbitz> design question, I have been using a design in a few apps recently where i maek the core app basically a bridge between plugins and teh actual functionality plugins, so i havea config fiel that lists all the functionality I want (modules) and dynamically load them at start up.  is this kind of design viable in haskell?  frowned upon for any reason?
07:24:59 <ManateeLazyCat> State Monad or other? Any suggestions?
07:25:08 <pejo> ManateeLazyCat, the problem with your approach is that you're thinking very imperatively. You are set on "updating a variable", which is not a very declarative way of thinking about programming. But yes, the state monad can give you mutable state.
07:26:14 <Saizan> if you really want to "update a variable" imperatively and destructively you've to use IORefs but that's not really haskelly anymore
07:26:17 <flazz_> i have a working cabal build file, what is a good workflow for development? i'm using emacs, should i just have <... configure> && <... build> as my compile string?
07:26:23 <ManateeLazyCat> pejo: Yes, sometimes i always use imperatively think solution even i use Haskell. Or you give me Haskell style?
07:27:04 <pejo> flazz, you don't need configure unless you're adding more modules/changing flags/etc; I normally just build.
07:28:17 <pejo> ManateeLazyCat, I don't have the solution, but I know that Yi is written by very good Haskell programmers, so it would be surprising if their solutions were as imperative as yours.
07:28:33 <blackh> ManateeLazyCat: editorCore :: [DocumentEditEvent] -> [Document]
07:28:33 <blackh> ManateeLazyCat: inputProcessor :: [(InputEvent, Pane)] -> [DocumentEditEvent]
07:28:33 <blackh> ManateeLazyCat: editor = editorCore . inputProcessor
07:28:33 <blackh> ManateeLazyCat: The code that paints the window would use Pane
07:28:38 * edwardk is trying to figure out if there is a good way to do unboxed monads
07:28:52 <edwardk> at least with the state, writer, etc. unboxed
07:29:48 <edwardk> writer works obviously, state is kind of taken by the state hack, but could theoretically use an unboxed tuple and/or unbox the state into the tuple if the state was packable
07:30:00 <ManateeLazyCat> Thanks all, i will explore deeply. :)
07:33:07 <blackh> ManateeLazyCat: You could think of your editor as a lazy 'foldl': foldl editor document inputEvents
07:33:39 <liyang> Quiet afternoon is quiet. Anyway, thought you'd enjoy this quote: ``15:45:29 < Jeremy> Cheesegrater of Eristhothenes!''
07:34:44 <ManateeLazyCat> blackh: Thanks for your suggestions. I will try it. :)
07:34:46 <nominolo> edwardk: can you compose CPS
07:35:07 <edwardk> ?
07:35:23 <edwardk> nominolo: in this half-thought out framework or in general?
07:35:34 <nominolo> the former
07:36:14 <nominolo> my guess would be that you should do this using some sort of composition of the CPS-formulations for each monad
07:36:29 <edwardk> nominolo: all i'm looking at is a few monad transformers with unboxed state/writers, and/or maybe a smart enough type family that can parameterize on monads upstream
07:36:33 <nominolo> the problem is that we don't have rules for rewriting data types
07:36:47 <edwardk> nominolo: how very er.. filinski of you =)
07:36:48 <nominolo> oh, right, type families
07:37:09 <ManateeLazyCat> Another question: In Haskell, how to handle the default value of function parameter? Example, i have 3 parameters in function declare, but i want last parameter will assign default value when i just give this function *2* parameters. Thanks
07:37:23 <nominolo> ManateeLazyCat: no
07:37:25 <edwardk> i view this as two steps. the first step is just getting the writer to unbox its log, the state monad to unbox its state
07:37:50 <edwardk> that can be done with just making a type class/family like
07:37:57 <nominolo> ManateeLazyCat: haskell doesn't have default parameters, it doesn't play nicely with partial application
07:38:42 <nominolo> edwardk: ah, ok, I thought you were trying to tackle the monadic composition problem ;)
07:38:51 <edwardk> class UW t where data UWriter t :: * -> *
07:39:15 <nominolo> i.e. data family UWriter t :: * -> *
07:39:20 <edwardk> (though the actual class would be more complicated because you want to support things isomorphic to the contents of the container so you need a notion of packability
07:39:45 <ManateeLazyCat> nominolo: So i just can pass parameters that corresponding function define?
07:39:48 <edwardk> nominolo: yeah but you need a class because you want to bundle methods for injecting/projecting
07:39:56 <ccasin> ManateeLazyCat : You could make the third argument an Option
07:39:57 <anakreon> Is there a library offering vendor independent access to schema information of a database?
07:40:52 <ccasin> sorry, I mean Maybe
07:40:59 <nominolo> ManateeLazyCat: yes,  you could write wrapper's though.  I.e. sipmleFoo x y = foo x defaultArg1 y defaultArg2
07:41:02 <edwardk> nominolo: i accept that generalized monad composition isn't possible ;)
07:41:22 <nominolo> edwardk: well, it's not commutative in general, no
07:41:51 <edwardk> nominolo: well, its not even closed in general
07:42:03 <ccasin> ManateeLazyCat: then just internally let bind a variable to (fromMaybe (default) (thirdarg))
07:42:12 <nominolo> edwardk: for example?
07:42:24 <ManateeLazyCat> nominolo: Bad, simpleFoo is not good idea when function have many parameters
07:42:33 <edwardk> IO [a] should fail associativity
07:42:40 <ManateeLazyCat> ccasin: Can you give me a simple example? Thanks!
07:43:34 <edwardk> you need a distributive law to mash monads together
07:43:59 <nominolo> hm
07:44:05 <ccasin> ManateeLazyCat : suppose I want the function which takes two or three numbers and adds them
07:44:06 <edwardk> either m (n (m a)) -> n (m a) -- m (n (m a) -> m (n a) -- or m (n a) -> n (m a)
07:44:10 <edwardk> any of the 3 will do
07:44:19 <ccasin> \x y zo -> x + y + (Data.Maybe.fromMaybe 0 zo)
07:44:38 <edwardk> each give rise to different compositions in some cases though and multiples may be present
07:44:55 <ccasin> ManateeLazyCat: when you want to call that function with two arguments, pass it "Nothing" for the third arg
07:45:29 <nominolo> edwardk: right
07:45:38 <ManateeLazyCat> ccasin: So i still need pass 'Nothing' for default parameter?
07:45:53 <nominolo> edwardk: do you know if delimited continuations help there?  I can't see how
07:46:00 <ccasin> ManateeLazyCat : Yes
07:46:51 <ccasin> ManateeLazyCat : no way around that, though it seems not much harder than dropping the third arg
07:47:16 <edwardk> nominolo: they give you a general way to think about how to compose some that are compsable but they arent a magic pixie dust
07:48:24 <nominolo> right, but state and exceptions aren't composable in general, and those are real big ones
07:49:11 <edwardk> yep.
07:49:42 <edwardk> personally i think the monad transformer solution, while a little hackish is pretty solid. it allows decent engineering practices
07:49:45 <ManateeLazyCat> ccasin: I want Haskell automatic decide and don't need type 'Nothing' (or any others placeholder) for default parameter, but thanks for your describe!
07:50:16 <edwardk> my biggest complaint is that i'd like a more general way to handle lifting of crap you dont care about
07:51:01 <nominolo> edwardk: yeah, lift sucks
07:51:03 <jmcarthur> i agree. monad transformers are nice. i think people get upset about them most of the time because they don't yet understand the good practice of making new abstractions with newtype
07:51:47 <nominolo> the only solution I found is to use something like:   class MonadException m where catch :: m a -> (e -> m a) -> m a
07:52:02 <ManateeLazyCat> I think my problem that i don't understand how to solution some problem with Haskell style. I will study deeply.
07:52:33 <nominolo> jmcarthur: I don't like them because they're slow
07:53:22 <jmcarthur> eh, monad transformers being slow is an implementation detail. they could be optimized better, surely
07:53:40 <jmcarthur> mtl is certainly slow, anyway
07:56:26 <nominolo> and I don't like modify if the state is a record
07:56:52 <nominolo> i.e, modify (\s -> s { foo = blab })
07:57:26 <nominolo> it'd be nice to write something like "sets foo blab", but that requires first class labels or similar
07:58:09 * nominolo -> meeting
07:59:10 <liyang> nominolo: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
08:01:33 <Lemmih> @tell __boegel__ I've gotten the allocation rate down from 600megs to 400megs per second.
08:01:34 <lambdabot> Consider it noted.
08:02:14 <__boegel__> Lemmih: how? :)
08:02:14 <lambdabot> __boegel__: You have 1 new message. '/msg lambdabot @messages' to read it.
08:02:22 <__boegel__> @vixen I know, I was here!
08:02:22 <lambdabot> what's worth more a flush or a full house?
08:02:43 <Lemmih> __boegel__: mean . getSingleFeature is less than optimal.
08:03:08 <vixey> first class labels ?
08:03:19 <vixey> foo = Label "foo"
08:03:42 <__boegel__> Lemmih: oh, I agree there are other opportunities for optimizing the code, but I was focusing on dist because profiling tells me that's the bottleneck
08:04:53 * Lemmih is just interested in reaching C speeds.
08:04:54 <__boegel__> Lemmih: anyway, gotta run
08:05:20 <__boegel__> Lemmih: if you have any more suggestions, don't hesitate to abuse lambdabot's scratchpad for it ;-)
08:06:38 * __boegel__ runs to the hills
08:11:11 <kadaver> os redblacktree a good replacement for a hashmap? is data.Map faster than a RBT?
08:14:28 <zsol> kadaver: hard to say generally
08:16:42 <zsol> kadaver: should be around the same except for a constant coefficient
08:30:26 <orbitz> kadaver: one generally writes interfaces in a way where the backign datastrucutre is irrelevant so one can profile it and swich out different backends as needed
08:32:03 <Lemmih> @tell __boegel__ Profiling prevented the fusing of zipWithU in Util.dist'.
08:32:03 <lambdabot> Consider it noted.
08:32:27 <Lemmih> @tell __boegel__ Here's a more accuate profile: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3591#a3591
08:32:27 <lambdabot> Consider it noted.
08:34:38 <Lemmih> @tell __boegel__ As you can see, dist is not a bottleneck. That was purely an artifact of profiling.
08:34:38 <lambdabot> Consider it noted.
08:35:32 <Lemmih> @tell __boegel__ Profiling tends to mess up tight loops, unfortunately.
08:35:32 <lambdabot> Consider it noted.
08:38:46 <jlaire> @pl \x y -> [x,y]
08:38:46 <lambdabot> (. return) . (:)
08:41:35 <marcot> Hello, is there a way to get which line of the file is being processed while parsing with Parsec?
08:41:54 <elbar> @pl \x y z -> [x, z, y, z]
08:41:55 <lambdabot> (. (ap (:) . (. return) . (:))) . (.) . (:)
08:42:29 <Lemmih> marcot: getPosition.
08:42:38 <marcot> Lemmih: thanks, I'll take a look.
08:48:15 <b_jonas> hello!
08:51:59 <saml> b_jonas, welcome
09:08:13 <jmcarthur> haskell has completely ruined my motivation to use imperative languages that my peers at work are familiar with :(
09:08:27 <jmcarthur> well, almost completely
09:08:43 <kadaver> why does hashtable have to be done imperatively?
09:09:12 <jmcarthur> kadaver, think what happens if it's not implemented with mutation... the entire array would need to be copied for every insertion or deletion
09:09:57 <kadaver> but how can arrays be done functioanlly then?
09:10:04 <jmcarthur> kadaver, we do have Data.Array.Diff, but i've never used it and heard it was slow
09:10:07 <kadaver> is Data.Array not really O(1) access?
09:10:23 <luite> kadaver: it is immutable
09:10:39 <FliPPeh> @src IO
09:10:40 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
09:10:45 <kadaver> so copied you mean?
09:11:16 <kadaver> basically implementing a hashtable functionally is against its own purpose?
09:11:25 <b_jonas> kadaver: sometimes it's useful to just construct  an array once from a pure list and then not mutate it
09:11:39 <b_jonas> kadaver: but if you must mutate it, then yes, it's copied
09:11:56 <jmcarthur> kadaver, well, if you only intend to use the hashtable for querying once it is first created, a purely functional hashtable is not a terrible idea
09:12:08 <b_jonas> (also mutation can work too if you mutate lots of elements at once, which the // operator does allow)
09:12:23 <jmcarthur> but only if the hash function still makes it faster to query than the compares for Data.Map
09:13:16 <jmcarthur> kadaver, there are some decent array libraries that offer fusion though
09:13:31 <jmcarthur> kadaver, and there is research (maybe implementation?) into array recycling
09:13:51 <jmcarthur> uvector has fusion, not sure about recycling
09:14:09 <b_jonas> what does fusion mean?
09:14:56 <jmcarthur> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
09:15:56 <jmcarthur> basically, a really nice optimization technique that allows you to use functional combinators with less fear of inefficiency
09:16:48 <jmcarthur> that paper describes stream fusion for lists, but we have it for some arrays too
09:17:49 <b_jonas> oh, that thing
09:17:50 <b_jonas> I see
09:17:54 <b_jonas> well, I don't really care about that
09:18:08 <b_jonas> I don't need efficent programs
09:19:08 <bremner> yet
09:19:40 <iago> b_jonas, no?
09:19:40 <jmcarthur> always nice to be able to drop in a more efficient library when you find that you _do_ need some performance
09:20:07 <jmcarthur> plus, the whole point of stream fusion is to _preserve_ functional style, so i wouldn't even consider it premature optimization
09:20:33 <iago> current ghc data.list uses stream fusion?
09:20:35 <jmcarthur> i believe it should be possible to replace Data.List with a stream fusion version without changing your code at all
09:20:42 <jmcarthur> not right now, but it should
09:20:59 <jmcarthur> i think the stream-fusion package offers a drop-in replacement for Data.List
09:21:07 <iago> jmcarthur, yep
09:21:20 <jmcarthur> i just always forget the name of the package
09:21:28 <iago> but should be better if the stream-fusion becomes default if possible
09:21:33 <jmcarthur> agreed
09:21:44 <jmcarthur> i don't like that i have to hide things from the prelude to use stream-fusion
09:21:59 <iago> stream-fusion is the package name
09:22:00 <b_jonas> I see
09:23:06 <jfredett> ... :( \bot doesn't cabal install nicely. :(
09:23:11 <jmcarthur> uvector is just the sequential dph array, right?
09:23:11 <jfredett> this makes me sad...
09:23:30 <jmcarthur> or is it modified in some way?
09:23:37 <gwern> jfredett: lb is a tough package
09:23:40 <b_jonas> jfredett: it's a complicated package really
09:23:52 <b_jonas> install only the parts you need
09:24:10 <jfredett> I just want the hoogle plugins -- the wiki told me to install \bot and take the vim plugins from there.
09:24:33 <b_jonas> jfredett: why do you need lambdabot for hoogle?
09:24:40 <b_jonas> wouldn't command-line hoogle work?
09:24:46 <jfredett> b_jonas: i just do what I'm told.
09:24:48 <b_jonas> or web-based hoogle
09:24:55 <jfredett> someone told me... hang on- I'll find the link
09:25:09 <b_jonas> you read things docs recommend? strange
09:25:19 <jfredett> http://www.haskell.org/haskellwiki/Hoogle#Vim_Integration
09:25:23 <b_jonas> so you're the dream user
09:25:27 <jfredett> lol. :)
09:25:31 <jfredett> I'm a follower.
09:25:59 <jfredett> I make the silly assumption that manuals know what they're talking about... call me naive, but I'm an optimist.
09:27:10 <b_jonas> they very often do, yes
09:28:04 <jfredett> b_jonas: I really just want to be able to add a little macro to vim which looks up the hilit word in hoogle and shoves the results in the little buffer at the bottom for me to troll through
09:28:17 <jfredett> I'm tired of bouncing between my ssh shell and FF...
09:29:57 <jfredett> I was under the impression that such a vim-script already existed.
09:30:01 <jfredett> perhaps I was incorrect
09:33:49 <gwern> wow, these vim scripts are terrible
09:33:53 <gwern> './lambdabot'?
09:33:59 <gwern> 'cd $HOME/lambdabot'?
09:34:11 <gwern> mein gott, let's just pretend these scripts don't exist
09:34:52 <Gracenotes> LAMBDABAT?
09:34:57 <Gracenotes> *swings*
09:35:09 <Gracenotes> >> homerun! <<
09:35:10 <b_jonas> okay, now can someone help me in this ghci command thing I'm writing?
09:35:12 <gwern> Gracenotes: yours is the ball that will pierce the heavens!
09:35:19 <b_jonas> here's the current state: http://erxz.com/pb/16933
09:35:27 <dons> anyone else seen sebastian visser's flux 3d demo in haskell? kinda mega awesome: http://www.reddit.com/r/programming/comments/8b8pf/first_haskell_flux_3d_demo/
09:35:30 <Gracenotes> or at least pierce the lambda cube
09:35:32 <gwern> b_jonas: why are you trying to do something so painful?
09:35:43 <c_wraith> gwern: That sounds like a line from a poorly translatede anime
09:35:57 <gwern> c_wraith: you got it half right
09:36:06 <b_jonas> but I'd like to know how to eliminate the threadDelay I added for the case when there's a compile error in a declaration
09:36:10 <c_wraith> gwern: the poorly-translated half?
09:36:21 <Gracenotes> (>^.^)>
09:36:22 <gwern> part of the fun of gurren lagann is the absurd lines; bad translation, good translation - they are absurd either way
09:36:22 * jfredett just wants some hoogle love... 
09:36:27 <b_jonas> I'm not even completely sure what causes it
09:36:34 <b_jonas> so please help
09:36:39 <jfredett> I suppose I'll just write my own \bot free script.
09:36:43 <b_jonas> gwern: what do you mean?
09:36:57 <gwern> b_jonas: nm, I thought you were writing in the actual .ghci command language
09:37:01 <gwern> not good ol' haskell
09:37:04 <c_wraith> gwern: Hmm.  I've heard a lot of people talk about it, but never watched any.  Maybe I should.
09:37:17 <b_jonas> gwern: there's a ghci command language?
09:37:19 <b_jonas> not meaningfully
09:37:26 <gwern> b_jonas: which is why it sucks so much
09:37:34 <b_jonas> gwern: well, it's a mix of the two
09:37:41 <b_jonas> because that language is the way I interface with ghci
09:37:52 <b_jonas> which is what makes this ugly
09:37:52 <gwern> c_wraith: it's a very niche anime, I should warn you, much more so than most of gainax's stuff
09:38:25 <b_jonas> so, when a (readFile x y) IO action finishes, can I be sure that the file is written out and closed, or could that be delayed?
09:38:59 <b_jonas> also, could someone test if this works correctly now as it is (with the delay)?
09:39:25 <c_wraith> The underlying filesystem can always delay writes, in some cases for over a minute. (ext4)
09:39:44 <c_wraith> Unless you make an explicit sync call, assume it's only queued to write.
09:39:55 <FliPPeh> :t sortBy
09:39:57 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:40:01 <FliPPeh> Ordering?
09:40:14 <adamvo> :t compare
09:40:15 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
09:40:31 <adamvo> @src Ordering
09:40:31 <lambdabot> data Ordering = LT | EQ | GT
09:40:50 <FliPPeh> > sortBy (+) [[1..3], [1..6], [1..4]]
09:40:51 <lambdabot>   Couldn't match expected type `Ordering' against inferred type `[a]'
09:40:54 <FliPPeh> :(
09:41:07 <FliPPeh> > sortBy (<) [[1..3], [1..6], [1..4]]
09:41:08 <lambdabot>   Couldn't match expected type `Ordering'
09:41:18 <FliPPeh> > sortBy LT [[1..3], [1..6], [1..4]]
09:41:19 <lambdabot>   Couldn't match expected type `a -> a -> Ordering'
09:41:21 <FliPPeh> Duuude
09:41:40 <adamvo> > sortBy (const LT) [1..]
09:41:41 <lambdabot>   Couldn't match expected type `a -> Ordering'
09:41:42 <FliPPeh> > sortBy compare [[1..3], [1..6], [1..4]]
09:41:44 <lambdabot>   [[1,2,3],[1,2,3,4],[1,2,3,4,5,6]]
09:41:45 <Gracenotes> (const . const $ LT)
09:41:49 <FliPPeh> Ahaha!
09:41:50 <b_jonas> c_wraith: oh, sorry, I don't care about that. rather, if another process or the same one opens it and reads, it will see the new content.
09:41:52 <FliPPeh> In your face lambdabot
09:42:02 <Gracenotes> IN UR FAEC!!
09:42:08 <FliPPeh> HELL YEAH
09:42:09 <b_jonas> but thanks, I just wasn't really precise.
09:42:18 <c_wraith> b_jonas: In that case, I have to ask why you were asking about the readFile call...  :)
09:42:33 <b_jonas> c_wraith: oh, sorry
09:42:38 <b_jonas> I mean (writeFile x y)
09:42:47 <b_jonas> must be a thinko
09:42:54 <b_jonas> ((readFile x y) is a type error)
09:43:10 <c_wraith> b_jonas: And I don't actually know the answer to that, though I'd assume it flushes on completion.  I'm just being a useless pedant.
09:43:10 <Gracenotes> > let readFile = (+) in readFile x y
09:43:11 <lambdabot>   x + y
09:43:16 <Gracenotes> :D
09:43:17 <Gracenotes> o:
09:44:58 <FliPPeh> > sortBy compare [[1..3], [1..6], [1..4]]
09:44:59 <lambdabot>   [[1,2,3],[1,2,3,4],[1,2,3,4,5,6]]
09:45:21 <FliPPeh> Why doesn't it work in my GHCI? :(
09:45:24 <FliPPeh> sortSubs :: [[a]] -> [[a]]
09:45:25 <FliPPeh> sortSubs = sortBy compare
09:45:55 <Gracenotes> @index sortBy
09:45:55 <lambdabot> Data.List
09:45:57 <Gracenotes> Data.List
09:46:02 <FliPPeh> I DID include it
09:46:08 <FliPPeh> import Data.List
09:46:10 <FliPPeh> :(
09:46:18 <c_wraith> import doesn't really work right in ghci
09:46:26 <c_wraith> you want to use :m + Data.List
09:46:26 <FliPPeh> I do compile it, tho
09:46:30 <c_wraith> oh
09:46:31 <Gracenotes> c_wraith: no
09:46:33 <FliPPeh> It fails compiling
09:46:36 <Gracenotes> import Data.List .. works fine
09:46:36 <c_wraith> I see
09:46:39 <Gracenotes> in recent versions
09:46:39 <b_jonas> so, um
09:46:49 <b_jonas> does this hack I pasted work for someone or doesn't work?
09:46:51 <b_jonas> could you try it?
09:47:06 <b_jonas> (and then fix the delay issue for me as well, in my dreams)
09:47:09 <Gracenotes> FliPPeh: well, take out the type signature and try it again
09:47:10 <FliPPeh> Could not deduce (Ord a) from the context ()
09:47:19 <FliPPeh> Works :(
09:47:25 <Gracenotes> right. then specify it's an Ord
09:47:31 <FliPPeh> kay
09:47:33 <Gracenotes> it has to be one, otherwise you can't use a comparison sort
09:47:37 <Gracenotes> @src sort
09:47:37 <lambdabot> sort = sortBy compare
09:47:40 <Gracenotes> ^ also use this instead
09:47:50 <Gracenotes> .. no method is really required
09:48:29 <FliPPeh> :t sortSubs l = sortBy compare l
09:48:31 <lambdabot> parse error on input `='
09:48:34 <FliPPeh> ;d
09:48:51 <Gracenotes> @type (sortBy compare, sort)
09:48:52 <lambdabot> forall a a1. (Ord a1, Ord a) => ([a] -> [a], [a1] -> [a1])
09:49:30 <FliPPeh> sortSubs :: (Ord a) => [a] -> [a]
09:49:34 <FliPPeh> Works
09:49:44 <FliPPeh> I guess Haskell knows more about my types than I do
09:49:45 <Gracenotes> just use sort >_>
09:49:51 <Gracenotes> <_<
09:49:55 <FliPPeh> <_>
09:49:59 <Gracenotes> _`
09:50:12 <FliPPeh> You win.
09:50:32 <Gracenotes> well, it was a shoplifted emoticon
09:50:47 <FliPPeh> Shoplifting doesn't pay off
09:50:54 <Gracenotes> _`
09:50:58 <zsol> hmm can I use case expressions inside a record field definition?
09:51:23 <zsol> like Rule { a = case ... of ... -> ... }
09:51:27 * Gracenotes goes shopping
09:51:41 <jmcarthur> zsol, try it and see :)
09:51:46 <jmcarthur> (yes)
09:51:52 <zsol> thanks
09:52:11 <zsol> am trying it, just stopped in the middle and asked if it's worth continuing
09:52:12 <zsol> :P
10:12:43 <LeoD> @pl \n x -> take n $ repeat x
10:12:43 <lambdabot> (. repeat) . take
10:16:58 <Frederick[SE]> if you have a function like this: fn_calc_spoons (x:_) spoons
10:17:14 <Frederick[SE]> what do you call the _?
10:17:20 <Frederick[SE]> as a concept of haskell
10:17:29 <___> wildcard pattern
10:17:54 <Frederick[SE]> 	fn_calc_spoons (x:_) spoons
10:17:54 <Frederick[SE]> 	 | isUpper x = spoons + ( (div spoons 20) + 1 )
10:17:54 <Frederick[SE]> 	 | otherwise = spoons + 1
10:18:00 <Frederick[SE]> and what are the |'s then?
10:18:06 <Frederick[SE]> thats normal pattern matching?
10:18:19 <___> guards
10:18:31 <flazz_> how can i search the api docs on my system?
10:18:33 <Frederick[SE]> ok, thanks for the help, all i need to know to get going again :)
10:18:51 <___> @where syntax
10:18:51 <lambdabot> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
10:18:58 <___> ^ a quick summary of stuff
10:21:23 <b_jonas> Frederick[SE]: "| foo  " is a guard
10:24:00 <Frederick[SE]> yeah, i understood that, but i need to make a report on my assignment and i need to note every programming concept ive used in my little haskell program
10:24:03 <Frederick[SE]> thanks anyhow :)
10:24:42 <b_jonas> ah, you need to document every detail?
10:24:47 <b_jonas> that sucks
10:25:00 <b_jonas> it encourages bad programming concepts
10:25:04 <b_jonas> s/concepts/methods
10:25:38 <vixey> bad monads
10:25:45 <FliPPeh> I suck at recursion :(
10:26:03 <vixey> FliPPeh: why
10:26:23 <BMeph> FliPPeh: "In the New Russia, ..." ;p
10:26:25 <FliPPeh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2074#a2074
10:26:41 <vixey> try not putting the type annotations down
10:27:00 <vixey> @type let intersperse' s (x:xs) = x : s : (intersperse' s xs) ; intersperse' _ []     = [] in intersperse'
10:27:01 <lambdabot> forall t. t -> [t] -> [t]
10:27:20 <vixey> @type let intersperse' s (x:xs) = x : s :  intersperse' s xs  ; intersperse' _ []     = [] in intersperse'
10:27:21 <lambdabot> forall t. t -> [t] -> [t]
10:28:02 <BMeph> vixey: Actually, without the type annotation, the problem isn't as immediately obvious. ;)
10:29:51 <dons> hehe. using hsjudy improves takes our hashtable perf. by 50x
10:30:06 <BMeph> FliPPeh: That function won't do [x] right, though. :)
10:30:35 <Frederick[SE]> <b_jonas> ah, you need to document every detail? << Yeah pretty much, the course is about programming concepts
10:30:36 <FliPPeh> :S
10:30:39 <BMeph> dons: What? Speak Enlgish, please. ;p
10:31:49 <tomh> who is hosting lambdabot?
10:32:15 <vixey> :t intersperse
10:32:16 <lambdabot> forall a. a -> [a] -> [a]
10:32:24 <vixey> BMeph: eh
10:32:28 <vixey> the problem was the type annotation
10:32:31 <FliPPeh> I want to write a function that joins sublists in a list
10:32:40 <FliPPeh> intersperse :: a -> [[a]] -> [a]
10:33:05 <vixey> :t intercalate
10:33:07 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:33:08 <BMeph> vixey: ^^ The type annotation was not the _only_ problem. :)
10:36:12 <dons> dolio, edwardk: hsjudy ftw and anti-troll powers :)
10:37:00 <b_jonas> FliPPeh: like concat?
10:37:05 <FliPPeh> Dunno
10:37:10 <FliPPeh> I just want to write it myself!
10:37:14 <lpsmith> Are Judy Trees persistent data structures?
10:37:14 <FliPPeh> Improving my haskell skills
10:37:20 <b_jonas> > concat [[2, 5, 1], [3, 7], [5]]
10:37:21 <lambdabot>   [2,5,1,3,7,5]
10:37:36 <FliPPeh> Nope, not that
10:37:50 <FliPPeh> joins a list of lists together using a separator value:
10:37:54 <FliPPeh> ;d
10:38:04 <b_jonas> like intercalate or intersperse then
10:38:06 <b_jonas> I see
10:38:15 <___> FliPPeh: so yourFunction 'x' ["abc", "def", "ghi"] = "abcxdefxghi"
10:38:20 <FliPPeh> Yep
10:38:31 <___> well, you're mostly there.
10:38:38 <FliPPeh> I know :(
10:38:41 <FliPPeh> Just some typing error
10:38:42 <vixey> yourFunction x = intercalate [x]
10:38:46 <b_jonas> > intersperse 'x' ["abc", "def", "ghi"]
10:38:48 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
10:38:55 <___> the problem, though, is that you can't put both 'x' and "abc" in the same list, they aren't the same type.
10:38:56 <b_jonas> > intercalate 'x' ["abc", "def", "ghi"]
10:38:57 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
10:39:02 <FliPPeh>  > intersperse "x" ["abc", "def", "ghi"]
10:39:12 <FliPPeh> > intersperse "x" ["abc", "def", "ghi"]
10:39:13 <lambdabot>   ["abc","x","def","x","ghi"]
10:39:19 <vixey> @let yourFunction x = intercalate [x]
10:39:20 <lambdabot>  Defined.
10:39:27 <vixey> > yourFunction 'x' ["abc", "def", "ghi"]
10:39:28 <lambdabot>   "abcxdefxghi"
10:39:34 <b_jonas> > tail (concat (map ('x' :) ["abc", "def", "ghi"]))
10:39:35 <lambdabot>   "abcxdefxghi"
10:39:42 <___> right, you need to change 'x' to "x" before interspersing, do you know how, FliPPeh?
10:39:47 <FliPPeh> > intercalate "x" ["abc", "def", "ghi"]
10:39:48 <lambdabot>   "abcxdefxghi"
10:40:01 <___> @type ('x', "x")
10:40:02 <lambdabot> (Char, [Char])
10:40:04 <FliPPeh> Make a List out of 'x'
10:40:10 <FliPPeh> > 'a':[]
10:40:12 <lambdabot>   "a"
10:40:30 <flazz_> how does one make constants in Haskell? just make functions that return the value?
10:40:39 <FliPPeh> Yes
10:40:42 <vixey> flazz_:
10:40:45 <vixey> x = 4
10:40:45 <dons> i.e. x = 2
10:40:57 <flazz_> thanks,
10:41:00 <gwern> however
10:41:01 <gwern> unix-2.4.0.0 was excluded because ghc-6.10.1.20090314 requires unix ==2.3.2.0
10:41:02 <gwern>  cabal: dependencies conflict: ghc-6.10.1.20090314 requires unix ==2.4.0.0
10:41:06 <___> FliPPeh: right, so the change to your function is to enclose the seperator in a list before using (:) to cons it onto the recursive value
10:41:13 <gwern> bleh. I hate these linking issues
10:41:23 <JoshTriplett> How do I find out what version of GHC or base or whatever matters introduced Data.Function.on?
10:41:42 <FliPPeh> I don't get it tho
10:42:15 <b_jonas> FliPPeh: (:) is a constructor like Just, and a list like [3,1,4] is really represented as 3:1:4:[]
10:42:26 <FliPPeh> I know that
10:42:45 <FliPPeh> :s
10:42:56 <FliPPeh> Still I don't really get forward due to typing problems
10:43:08 <BMeph> JoshTriplett: Previous versions of the GHC docs? ;)
10:43:17 <JoshTriplett> BMeph: Heh, point.
10:43:25 <centrinia> Maybe is just a List without subsequent elements. ;)
10:43:38 <___> flazz_: Data constructors are basically the only 'constants', save for a few in-built types.  They are introduced with newtype and data declarations.
10:43:52 <___> @src Bool
10:43:52 <lambdabot> data Bool = False | True deriving (Eq, Ord)
10:44:06 <___> ^ this introduces False and True as new 'constants'.
10:44:35 <b_jonas> FliPPeh: I guess I don't know what your problem with writing that function was
10:45:01 <___> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2074#a2075
10:45:39 <BMeph> It's Haskell. *Everything* is a constant. ;)
10:45:47 <b_jonas> > let { f x [] = []; f x s = tail (concat (map (x :) s)); } in f 'a' ["bc", "def", "g"]
10:45:48 <lambdabot>   "bcadefag"
10:45:49 <kyagrd> good moring (by PST) ~
10:45:57 <___> BMeph: thus the "scare quotes"  :)
10:46:39 <centrinia> ___, intersperse' s (x:xs) = x : s : (intersperse' s xs) would have x :: [a] and s :: a
10:47:30 <centrinia> > [1] : 2 : [[3]]
10:47:31 <lambdabot>       No instance for (Num [t])
10:47:31 <lambdabot>        arising from the literal `2' at <inter...
10:47:45 <___> centrinia: uh, right?  That's what FliPPeh wants.
10:47:53 <centrinia> Okay.
10:48:10 <b_jonas> try ++
10:48:15 <b_jonas> if you want to concatenate two lists
10:48:22 <b_jonas> like x with the rest of the output
10:48:34 <b_jonas> beucase : wants a single element of the list on the left
10:48:34 <BMeph> ___: What "scare quotes"? :)
10:48:39 <b_jonas> and x in that definition is not like that
10:48:47 <b_jonas> it's a whole list like "bc" you want to catenate in the output
10:48:53 <kyagrd> Is there a library that automatically generate stubs of OOP language (C++, Java, C# whatever) class heirarcy for a given Haskell ADT (with non higher order values)?
10:49:08 <___> oh, right, I forgot the concat step
10:49:26 <kyagrd> I'ts kind of opposite thing of c2hs
10:50:18 <BMeph> kyagrd: Not yet - you could be the one to write it and be Famous! ;)
10:50:53 <tomh> kyagrd: took a look at thrift or protocol buffers?
10:51:00 <Duqicnk> kyagrd: i thought about doing this for python the other day
10:51:08 <kyagrd> I think it is often useful when you try to call Haskell from C/C++/etc
10:51:30 <Duqicnk> not for haskell interop, just for having some more structured datatypes that would do a bit of typechecking for free
10:51:47 <Duqicnk> thrift is sort of the other way 'round too
10:52:45 <kyagrd> What I was thinking was, instead of using poor lex & yacc, we can let people use Parsec and all other beautiful things to symbolic preprocessing when they must use C/C++ in their main engin for some good reasons.
10:53:10 <Duqicnk> there's a Haskell library for outputting C code, right?
10:53:24 <Duqicnk> i've done C and C++ output from haskell, but not using any special lib
10:54:06 <BMeph> vixey: Did you see Ulysses' hylomorphism article today?
10:54:10 <kyagrd> Duqicnk: what project is it?
10:54:14 <vixey> no
10:54:22 <vixey> I saw this one about anamorphism
10:54:24 <Duqicnk> which?
10:54:26 <Plouj> anyone here dream of implementing their own multi-threaded Dwarf Fortress in haskell?
10:54:43 <BMeph> vixey: http://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/
10:54:44 <mauke> you may be obsessed if
10:55:08 <BMeph> vixey: He saw the need to redefine partition, but I'm afraid to ask why... ;)
10:55:12 <kyagrd> Duqicnk: if possible I'd like to consult what you did about doing out C C++ from Haskell?
10:55:35 <Duqicnk> oh
10:55:47 <Duqicnk> uh, one was a haskell EDSL for video filters that compiled to C++ and GLSL
10:56:14 <kyagrd> oh ... I'm trying to do a little bit different thing.
10:56:15 <Duqicnk> also a sort of load-time-compiler for a bytecode VM
10:56:21 <Duqicnk> stuff like that
10:58:17 <visof> hello
10:58:57 <kyagrd> When I have "data Tree = Leaf Int | Node Tree Tree" I want to generate three C++/Java/C# whatever classes, class Leaf : public Tree { .. }, class Node : public Tree { ... }, and the abstract superclass Tree
10:59:13 <Duqicnk> right
10:59:29 <centrinia> What does wood have to do with hylomorphisms?
10:59:31 <Duqicnk> well you'll need to introspect the type structure
10:59:39 <FliPPeh> I can't do it
10:59:42 <Duqicnk> you can either quote it using TH, or just parse it yourself
10:59:43 <FliPPeh> I can't do it!!
10:59:46 <tomh> thats quite easy to make if you don't use weird language extensions :>
10:59:48 <mauke> wouldn't that be xylomorphisms?
11:00:18 <centrinia> The prefix "hylo-" refers to wood.
11:00:28 <Duqicnk> kyagrd: also look at boost::tuple and boost::variant, which provide product and sum types resp. in C++
11:01:09 <Duqicnk> kyagrd: are you going to annotate the haskell type definition with a description of memory ownership semantics, or impose that globally?
11:01:22 <mauke> centrinia: maybe it's related to trees? :-)
11:01:57 <visof> there is a project euler problem that i get the idea for solving it and i can't implement my idea in Haskell, the problem http://projecteuler.net/index.php?section=problems&id=14
11:02:21 <Duqicnk> visof: you get the idea, meaning you understand what parts you need to write?
11:02:28 <kyagrd> Duqicnk: not thinking of memory ownership, but at least we must annotate the what field names to be used as a member variable to hold the subcomponent
11:02:42 <Duqicnk> kyagrd: you can use record synatx for that
11:03:00 <visof> Duqicnk sorta
11:03:10 <Duqicnk> bbl
11:03:37 * centrinia remembers creating a 1,000,000 element array for Problem 14.
11:04:15 <kyagrd> Duqink: oh that's a good way too
11:04:21 <glguy> You don't have to do anything clever for problem 14
11:04:22 <visof> Duqicnk 13->4->20->10->5->16-.........., we can ignore checking
11:04:30 <glguy> it runs fast enough to just check everything individually
11:04:41 <visof> the 40->20---------- elements
11:05:28 <centrinia> Wait, no. I used a Data.Map.
11:05:42 <visof> the elements 40 to 2 get chain smaller than 13
11:05:45 <glguy> My solution to 14 in Haskell runs in 3 seconds without any memoization
11:06:29 <visof> i can't implement what i thought in Haskell
11:07:10 <glguy> (and the naive C solution runs in 0.05s here)
11:07:33 <visof> pick the first element start= 3 then get the chain pick the next one that isn't equal to the resulting element of the chain 3
11:07:44 <wli> Collatz crud?
11:07:49 <visof> then it's 5 , get chain 5
11:08:07 <visof> anyone understand what i mean ?
11:08:34 <glguy> visof, that could work, but is completely unnecesary
11:08:56 <visof> glguy how ?
11:09:38 <glguy> just apply the even/odd rule repeatedly until you hit 1, count how many times you applied it
11:09:47 <glguy> no need to introduce data strctures
11:10:16 <visof> for every element ?
11:10:19 <glguy> yeah
11:10:25 <visof> from one to 10^6 ?
11:10:37 <glguy> you'll need to check them all to know the best one
11:10:38 <glguy> so yes
11:10:45 <glguy> 10^6 isn't that big
11:10:50 <wli> I don't remember the Collatz recurrence.
11:10:59 <visof> you can ignore a lot of steps
11:11:24 <glguy> but you don't need to
11:11:34 <glguy> and if you aren't careful about how you look them up, you'll slow down
11:11:52 <visof> glguy i don't understand
11:11:55 <glguy> it isn't enough to track the chains 1-1000000, the sequences grow outside of 1000000
11:12:12 <glguy> write it the obvious way first, and then start optimizing
11:13:03 <wli> What's the Collatz recurrence again so I don't have to fight browsers' massive memory footprints making them dogslow.
11:13:47 <mauke> even -> (`div` 2); odd -> succ . (* 3)
11:13:56 <glguy> wli, on even, `shiftR` 1
11:14:04 <glguy> otherwise (3*n+1)
11:16:35 <wli> What are you trying to find here? The longest chain of all numbers below 10^6?
11:16:56 <tromp_> @let collatz n = n' `div` 2 where n' = if even n then n else 3*n+1
11:16:56 <lambdabot>  Defined.
11:17:06 <aLegendaryPengui> @let x = 1
11:17:07 <lambdabot>  Defined.
11:17:10 <aLegendaryPengui> >x
11:17:11 <tromp_> > iterate collatz 7
11:17:12 <lambdabot>   [7,11,17,26,13,20,10,5,8,4,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
11:17:31 <aLegendaryPengui> thats advanced tromp_
11:17:32 <joga> will lambdabot forget the definitions?
11:17:36 <aLegendaryPengui> thats a high note
11:17:42 <aLegendaryPengui> the higher the better
11:17:51 <___> joga: when she's told to @undefine them
11:17:56 <joga> ok
11:18:00 <aLegendaryPengui> x + 5
11:18:05 <aLegendaryPengui>  > x + 5
11:18:13 <aLegendaryPengui> fool bot
11:18:18 <adamvo> > x+5
11:18:18 <jmcarthur> > x + 5
11:18:19 <lambdabot>       Ambiguous occurrence `x'
11:18:19 <lambdabot>      It could refer to either `L.x', defined a...
11:18:19 <lambdabot>       Ambiguous occurrence `x'
11:18:19 <lambdabot>      It could refer to either `L.x', defined a...
11:18:27 <aLegendaryPengui> how come yours works
11:18:36 <tromp_> @let col = takeWhile (/= 1) . iterate collatz
11:18:37 <lambdabot>  Defined.
11:18:38 <glguy> he didn't add a space like you did
11:18:40 <jmcarthur> you put a space before the >
11:18:43 <aLegendaryPengui> oh
11:18:43 <b_jonas> that looks wrong
11:18:45 <aLegendaryPengui> >x + 5
11:18:50 <aLegendaryPengui> wtf
11:18:52 <b_jonas> isn't the loop 4 2 1 4 2 1 4 2 1 ?
11:18:55 <___> > length (col 234)
11:18:56 <lambdabot>   16
11:19:00 <jmcarthur> needs a space after
11:19:03 <aLegendaryPengui> > x + 5
11:19:04 <lambdabot>       Ambiguous occurrence `x'
11:19:04 <lambdabot>      It could refer to either `L.x', defined a...
11:19:04 <tromp_> i divide by 2 in every step
11:19:05 <aLegendaryPengui> oh
11:19:12 <tromp_> since 3n+1 always even
11:19:29 <tromp_> > col 7
11:19:31 <lambdabot>   [7,11,17,26,13,20,10,5,8,4,2]
11:19:40 <b_jonas> > let { c x | even x = div x 2 | otherwise = 2 * x + 1; } iterate c 7
11:19:41 <lambdabot>   <no location info>: parse error on input `iterate'
11:19:42 <aLegendaryPengui> @let + = -
11:19:42 <lambdabot>   Parse error
11:19:44 <b_jonas> > let { c x | even x = div x 2 | otherwise = 2 * x + 1; } in iterate c 7
11:19:45 <lambdabot>   [7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143...
11:19:47 <jmcarthur> > 3*2 + 1
11:19:49 <lambdabot>   7
11:19:50 <aLegendaryPengui> @let (+) = (-)
11:19:51 <lambdabot>  <local>:4:59:
11:19:51 <lambdabot>      Ambiguous occurrence `+'
11:19:51 <lambdabot>      It could refer to either `L...
11:19:52 <b_jonas> > let { c x | even x = div x 2 | otherwise = 3 * x + 1; } in iterate c 7
11:19:53 <lambdabot>   [7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1...
11:20:02 <b_jonas> okay
11:20:06 <jmcarthur> > even $ 3*2 + 1
11:20:08 <lambdabot>   False
11:20:11 <b_jonas> there's also another version, the negative one
11:20:14 <b_jonas> > let { c x | even x = div x 2 | otherwise = 3 * x + 1; } in iterate c -7
11:20:15 <lambdabot>       No instance for (Num (a -> [a]))
11:20:15 <lambdabot>        arising from the literal `7' at...
11:20:15 <tromp_> ok, 3 * odd +1 always even:)
11:20:16 <aLegendaryPengui> > 5 + 1
11:20:17 <lambdabot>   6
11:20:19 <b_jonas> > let { c x | even x = div x 2 | otherwise = 3 * x + 1; } in iterate c (-7)
11:20:20 <lambdabot>   [-7,-20,-10,-5,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5,-14,-7,-20,-10,-5,-14,-7...
11:20:22 <b_jonas> which has multiple loops
11:20:26 <aLegendaryPengui> how do i redefine + for lambdabot
11:20:29 <jmcarthur> yup
11:20:32 <b_jonas> multiple known loops
11:20:44 <b_jonas> aLegendaryPengui: you can't, it's in prelude, you can only do it locally
11:20:50 <jmcarthur> @check \x -> odd x ==> even (3*x + 1)
11:20:50 <b_jonas> aLegendaryPengui: in a local scope you can:
11:20:51 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
11:20:51 <lambdabot>           ...
11:20:51 <aLegendaryPengui> oh
11:21:03 <jmcarthur> uh
11:21:05 <b_jonas> > let { (+) = (-); } in 5 + 1
11:21:06 <lambdabot>   4
11:21:23 <b_jonas> but not globally because you can't make lambdabot unimport (+) from the Prelude
11:21:32 <jmcarthur> @check \x -> if odd x then even (3*x + 1) else True
11:21:33 <lambdabot>   "OK, passed 500 tests."
11:21:38 <tromp_> > col (-1)
11:21:39 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1...
11:21:41 <aLegendaryPengui> (let (+) = (-) in 5 + 1)
11:21:50 <jmcarthur> dunno what's up with ==> there. maybe i remember it wrong
11:21:51 <aLegendaryPengui> > (let (+) = (-) in 5 + 1)
11:21:53 <lambdabot>   4
11:21:58 <aLegendaryPengui> sweet, no brackets
11:22:20 <aLegendaryPengui> > let (+) = (-) in 5 + 1
11:22:21 <lambdabot>   4
11:22:24 <aLegendaryPengui> why did you use {
11:22:30 <aLegendaryPengui> b_jonas
11:23:11 <b_jonas> I dislike the haskell layout syntax so I usually just use the fully bracketed syntax or something very close
11:23:16 <aLegendaryPengui> oh
11:23:27 <aLegendaryPengui> normally the in would be on the next line right
11:23:50 <jmcarthur> not always. just whatever you want
11:23:53 <aLegendaryPengui> but i guess you can do it on the same line? its weird
11:23:58 <aLegendaryPengui> but what about certain constructs
11:24:21 <jmcarthur> i'm always somewhat bewildered whenever somebody says they don't like the layout rules
11:24:28 <aLegendaryPengui> it confuse me
11:24:36 * ___ agree jmcarthur 
11:24:38 <aLegendaryPengui> and my emacs editor sucks, i hit tab and it does like 50 spaces
11:24:40 <aLegendaryPengui> garbage
11:24:45 <b_jonas> well, in lambdabot you always write everything in one line, in a program you may write long things in separate lines
11:24:48 <aLegendaryPengui> and its in haskell mode even
11:24:53 <aLegendaryPengui> god
11:25:26 <jmcarthur> aLegendaryPengui, there are two tab modes in haskell-mode, and one of them gives you different positions each time you hit tab so you can choose the indentation level you want
11:25:38 <aLegendaryPengui> why not set tab to be 1 space
11:25:41 <aLegendaryPengui> retarded emacs
11:26:07 <jmcarthur> you could set that yourself...
11:26:36 <aLegendaryPengui> god
11:26:50 <vav> hmm, anyone know how to link to haddock #label# anchors inside a single module? I have a different section I'm trying to link to from inside some comment text and not finding the right markup combination for the link or the anchor.
11:29:09 <BMeph> Collatz is more interesting in trinary. :)
11:29:59 <b_jonas> BMeph: is it?
11:30:36 <wli> What are you trying to find wrt. Collatz?
11:34:05 <aLegendaryPengui> how do I load lisst into prelude
11:35:02 <b_jonas> aLegendaryPengui: pardon?
11:35:10 <kadaver> module Mueval.Parallel where
11:35:17 <kadaver> spllellin ellor?
11:35:57 <BMeph> b_jonas: Very much so. In trinary, a number is even iff is has an even number of 1's. So, if in a Collatz sequence you get an odd number, you throw a 1 on the end of it. :)
11:36:14 <b_jonas> let's see
11:36:15 <BMeph> s/iff is/iff it/
11:36:15 <aLegendaryPengui> have any of u guys heard of fanbox
11:36:28 <b_jonas> @define cs = let { b3' x | 0 == x = "" | otherwise = toEnum (fromIntegral (48 + mod x 3)) : b3' (div x 3); b3 = reverse . b3'; c x | even x = div x 2 | otherwise = 3 * x + 1; cs = take 999 . intercalate " " . map b3 . iterate c } in cs
11:36:36 <b_jonas> @bot
11:36:37 <lunabot>  :)
11:36:37 <lambdabot> :)
11:36:39 <vixey> BMeph: that's neat
11:36:42 <b_jonas> @let cs = let { b3' x | 0 == x = "" | otherwise = toEnum (fromIntegral (48 + mod x 3)) : b3' (div x 3); b3 = reverse . b3'; c x | even x = div x 2 | otherwise = 3 * x + 1; cs = take 999 . intercalate " " . map b3 . iterate c } in cs
11:36:43 <lambdabot>  Defined.
11:36:47 <b_jonas> > cs 7
11:36:48 <lambdabot>   "21 211 102 1021 122 1221 222 111 1111 202 101 12 121 22 11 2 1 11 2 1 11 2...
11:36:49 <BMeph> aLegendaryPengui: Did you mean Liszt? ;)
11:36:52 <b_jonas> > cs 15
11:36:53 <aLegendaryPengui> List
11:36:54 <lambdabot>   "120 1201 212 2121 1022 10221 1222 12221 2222 1111 202 101 12 121 22 11 2 1...
11:36:56 <aLegendaryPengui> i want to use partition
11:36:58 <b_jonas> > cs 19
11:36:59 <lambdabot>   "201 2011 1002 10021 1122 211 102 1021 122 1221 222 111 1111 202 101 12 121...
11:37:02 <b_jonas> > cs 27
11:37:04 <lambdabot>   "1000 10001 1112 11121 2022 1011 10111 1202 12021 2122 21221 10222 102221 1...
11:37:50 <b_jonas> collatz in trinary
11:37:51 <aLegendaryPengui> those numbers look advanced b_jonas
11:37:58 <aLegendaryPengui> what is it
11:38:12 <b_jonas> well, BMeph said they would be interesting
11:38:14 <b_jonas> I had to generate them
11:38:22 <aLegendaryPengui> haha
11:38:23 <b_jonas> the b3 function just prints a number in binary
11:38:33 <b_jonas> and c generates the next element in the collatz sequence
11:38:39 <kadaver> module Mueval.Parallel where; <- Parallel is spelled Parallel isn't it?
11:38:55 <aLegendaryPengui> this?http://en.wikipedia.org/wiki/Collatz_conjecture
11:39:28 <b_jonas> 19 and 27 are too long for lambdabot to display
11:39:46 <BMeph> aLegendaryPengui: To load List (or better, Data.List) in GHCi, you can just type: "import Data.List"
11:40:23 <b_jonas> (but I can also load modules with an alias in ghci)
11:40:26 <kerlo> Does an installation of Hugs have a collection of Haddock docs anywhere?
11:40:53 <dons> hugs? boo
11:40:56 <kerlo> I know that GHC does.
11:41:11 <tromp_> > col 63
11:41:12 <lambdabot>   Not in scope: `col'
11:41:16 <dons> i don't think hugs ships with haddock. it is before haddock's time)
11:42:03 <kerlo> dons: yeah, well, fix GHC bug #2063. :-)
11:42:21 <dons> ?bug
11:42:21 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
11:42:34 <mmorrow> Duqicnk: re using haskell to write C: is there any code and/or info about some of the projects you were mentioning?
11:42:48 <Duqicnk> not readily available, sorry
11:42:51 <dons> oh, openbsd/x86_64
11:43:11 <kerlo> Can I at least see a list of modules I can import, and a list of things defined in a module?
11:43:17 <mmorrow> Duqicnk: ah. what general technique(s) did you use?
11:43:55 <BMeph> >  "201 2011 1002 10021 1122 211 102 1021 122 1221 222 111 1111 202 101 12 121 22 11 2 1"
11:43:56 <lambdabot>   "201 2011 1002 10021 1122 211 102 1021 122 1221 222 111 1111 202 101 12 121...
11:44:16 <BMeph> Yep, 19 is too long - but barely. :)
11:44:17 <mmorrow> like for instance, the what was the edsl you mentioned's interface like?
11:44:49 <___> karlo: http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-commands.html
11:44:56 <___> kerlo, rather
11:45:21 <___> for a list of modules:
11:45:22 <___> @docs
11:45:23 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:46:05 <Duqicnk> mmorrow: the video filter thing had two parts
11:46:24 <Duqicnk> a monadic EDSL for wiring filters into filtergraphs by connecting outputs to inputs
11:46:37 <Duqicnk> and an expression EDSL with phantom types for writing certain filters to be executed on the GPU
11:46:54 <Duqicnk> code output was all just manipulating ShowS which was ugly as hell
11:46:58 <mmorrow> hmm, interesting
11:46:59 <mmorrow> heh
11:47:01 <Duqicnk> should have written a real template engine or found one
11:47:32 <kerlo> ___: for a specific installation of Hugs, I mean.
11:48:39 <___> *shrug*.  Not really used Hugs.
11:49:18 <kerlo> ortmage: your name looks suspiciously similar to "Hortmage". Are you related?
11:49:34 <___> kerlo: http://cvs.haskell.org/Hugs/pages/users_guide/index.html
11:50:47 <kadaver> > map (fromMaybe 0) [Just 5, Nothing, Just 5]
11:50:48 <lambdabot>   [5,0,5]
11:50:56 <kadaver> > sum $ map (fromMaybe 0) [Just 5, Nothing, Just 5]
11:50:58 <lambdabot>   10
11:51:24 <lilac> > sum $ catMaybes [Just 5, Nothing, Just 5]
11:51:26 <lambdabot>   10
11:58:15 <MaDiNfO_> > putStr . unlines . take 5 . iterate (?*? :) $ ?*?
11:58:17 <lambdabot>   <no location info>: parse error on input `:'
11:58:36 <MaDiNfO_> > unlines . take 5 . iterate (?*? :) $ ?*?
11:58:37 <lambdabot>   <no location info>: parse error on input `:'
11:58:42 <MaDiNfO_> > take 5 . iterate (?*? :) $ ?*?
11:58:43 <lambdabot>   <no location info>: parse error on input `:'
11:59:17 <MaDiNfO_> > iterate('*' :) ""
11:59:19 <lambdabot>   ["","*","**","***","****","*****","******","*******","********","*********"...
11:59:29 <mauke> MaDiNfO_: (?*? :) is bogus
12:00:46 <mmorrow> Duqicnk: ah cool, how did this "load-time compiler for a bytecode VM" work?
12:02:42 <MaDiNfO_> does anyone knows intercal or befunge ? :)
12:02:43 <mmorrow> Duqicnk: did you use haskell to generate C/whatever which then would compile the bytecode? or was it haskell directly doing the compilation? (neither?)
12:04:33 <pythonist> Any Mac user in here?
12:04:43 <mmorrow> , [$bf|.+[.+]|] ""
12:04:44 <liyang> pythonist: yes.
12:04:45 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
12:04:53 <aLegendaryPengui> why o i have to use import instead of load for Data.List
12:04:55 <aLegendaryPengui> at prelude?
12:05:21 <pythonist> liyang: I got my first Mac ever today and I'm finding out the best way to install ghc.
12:05:38 <pythonist> liyang: Do you advise to download it from haskell.org?
12:05:39 <kadaver> when merging 2 trees is merge or union the better word?
12:05:41 <vixey> , [$bf|,[>,][.<]|] "foobar"
12:05:42 <liyang> pythonist: MacPorts if you're not bothered about getting the bleedin' edge.
12:05:43 <lunabot>  "*** Exception: bf blocked on input"
12:05:54 <vixey> , [$bf|,[>,][.<]|] "foobar\0"
12:05:56 <lunabot>  ""
12:05:56 <kadaver> it drops duplicates if that make a adifference
12:06:00 <pythonist> liyang: What do you mean by "bleeding edge"?
12:06:02 <vixey> , [$bf|,[>,]<[.<]|] "foobar\0"
12:06:03 <lunabot>  "raboof"
12:06:10 <liyang> pythonist: 6.10.2 isn't in MacPorts yet.
12:06:11 <aLegendaryPengui> bleeing edge
12:06:22 <liyang> (6.10.1 is, however.)
12:06:23 <pythonist> liyang: understood.
12:06:48 <pythonist> liyang: well, not. I'm coming from Linux so usually distros don't distribute the very latest version...
12:06:58 <pythonist> liyang: so, it'd be no problem at all.
12:07:24 <liyang> pythonist: otherwise, install the .tar.gz tarball to /usr/local/stow/ghc-version-num and GNU stow to symlink it in to the /usr/local hierarchy.
12:07:49 <mmorrow> , [$bf|,[>+>+<<-]>.>.|] "a"
12:07:50 <lunabot>  "aa"
12:07:53 <FliPPeh> @faq Can Haskell become THE GUY?
12:07:53 <lambdabot> The answer is: Yes! Haskell can do that.
12:07:58 <mmorrow> , [$bf2|,[>+>+<<-]>.>.|] "a"
12:08:00 <lunabot>  ("aa",(2,Mem (fromList [(0,0),(1,97),(2,97)])))
12:08:03 <liyang> pythonist: That way you can have multiple versions installed, and be able to switch between them. :3
12:08:30 <pythonist> liyang: mmmhhh... I'm wondering about the quality of MacPorts...
12:08:50 <aLegendaryPengui> @src Data.List.partition
12:08:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:09:10 <pythonist> liyang: thank you!
12:09:12 <aLegendaryPengui> help
12:09:14 <liyang> pythonist: MacPorts versus ...?
12:09:20 <mmorrow> , fmap ([$bf|,[>+>+<<-]>.>.|] . (:[])) ['a'..'z']
12:09:22 <lunabot>  ["aa","bb","cc","dd","ee","ff","gg","hh","ii","jj","kk","ll","mm","nn","o...
12:09:24 <pythonist> :)
12:09:41 <liyang> pythonist: it's the least painful way of getting a familiar GNU environment going.
12:09:45 <vixey> , [$bf|[,..]|] ['a'..'z']
12:09:46 <lunabot>  ""
12:09:51 <vixey> , [$bf|,[..,]|] ['a'..'z']
12:09:53 <lunabot>  "aabbccddeeffgghhiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz*** Exception: bf bl...
12:09:57 <pythonist> liyang: Fine. I'll go for it.
12:10:05 <liyang> :3
12:10:07 <mmorrow> , [$bf|,|] ""
12:10:09 <lunabot>  "*** Exception: bf blocked on input"
12:10:11 <vixey> , [$bf|,[..,]|] "I don't usually drink this much coffee"
12:10:12 <lunabot>  "II  ddoonn''tt  uussuuaallllyy  ddrriinnkk  tthhiiss  mmuucchh  ccooffff...
12:10:17 <mmorrow> heh
12:10:52 <mmorrow> @remember vixey [$bf|,[..,]|] "I don't usually drink this much coffee"
12:10:52 <lambdabot> Okay.
12:10:52 <aLegendaryPengui> what does partition look like?
12:10:54 <aLegendaryPengui> im confused
12:11:09 <edwardk> kadaver: the usual idiom would be 'union to match Data.Set/Map/Tree/IntSet/IntMap/...
12:11:27 <aLegendaryPengui> partition has to return like 2 lists right
12:11:46 <liyang> pythonist: I find it a good idea to keep a strict separation between stuff you install manually (in /usr/local) and stuff managed by MacPorts (in /opt/local), as well as the bits that came with OS X (in /usr)
12:12:09 <lilac> @type partition
12:12:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:12:16 <aLegendaryPengui> yeah but
12:12:35 <aLegendaryPengui> i dunno, its weird
12:12:41 <lilac> partition (<0) [-3,3,-2,4]
12:12:49 <lilac> > partition (<0) [-3,3,-2,4]
12:12:49 <lambdabot>   ([-3,-2],[3,4])
12:12:55 <aLegendaryPengui> how would i write one with the same signature
12:13:03 <lilac> @src partition
12:13:03 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
12:13:03 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
12:13:03 <lambdabot>                               | otherwise = (ts, x:fs)
12:13:21 <liyang> pythonist: also, if you're installing coreutils or findutils, make sure you specify the +with_default_names variant. Because the BSD versions suck. =)
12:13:47 <aLegendaryPengui> see, i knew partition was advanced
12:13:52 <lilac> partition p [] = ([], []); partition p (x:xs) | p x = (x:ys,zs) | otherwise = (ys,x:zs) where (ys, zs) = partition p xs
12:13:53 <liyang> pythonist: I'll stop spouting rubbish now. Have a look at http://liyang.hu/osx-survival.xhtml
12:14:23 <aLegendaryPengui> why did the source use select
12:14:29 <kadaver> type HashMap = RedBlackTree (String,Int), if I want to make a typesynonym like that but have any types,ie (a,a1) instead, how do you do?
12:14:35 <aLegendaryPengui> is that like a return
12:15:13 <lilac> aLegendaryPengui: probably so it could be written as a fold, for fusion purposes
12:15:21 <aLegendaryPengui> fusion>
12:15:40 <lilac> @where stream fusion
12:15:40 <lambdabot> I know nothing about stream.
12:16:32 <ziman> kadaver, type HashMap k v = RedBlackTree (k,v)
12:16:35 <mmorrow> , [$ski|S[f::Expr->Expr->Expr][g][x]|]
12:16:38 <lunabot>  f x (g x)
12:17:29 <aLegendaryPengui> lilac, could you use a let insteaad of where in that context
12:18:50 <lilac> aLegendaryPengui: not really, because i want it to scope over both guards
12:18:55 <mmorrow> , (\f x->[$ski|S[f][id][x]|]) (,) 0
12:18:57 <aLegendaryPengui> so let can't do that?
12:18:58 <lunabot>  (0,0)
12:19:00 <lilac> aLegendaryPengui: you could duplicate the recursive call
12:19:23 <aLegendaryPengui> is there a way to say like let xs, ys = w/e in , then do a guard there
12:19:35 <lilac> kinda
12:20:00 <lilac> partition p [] = ([], []); partition p (x:xs) = let (ys, zs) = partition p xs; result | p x = (x:ys,zs) | otherwise = (ys,x:zs) in result
12:20:59 <pythonist> liyang: thank you!
12:28:17 <aLegendaryPengui> how do you say 5..1
12:28:28 <aLegendaryPengui> [5,4..1]?
12:28:39 <mauke> yes
12:28:40 <bavardage> how do I convert a double to an int?
12:28:42 <aLegendaryPengui> why
12:28:50 <mauke> bavardage: round
12:28:54 <bavardage> oh ty
12:28:58 <aLegendaryPengui> [1..2] = 1,2 [2..1] = []
12:29:11 <roconnor> codensity++
12:29:17 <mauke> aLegendaryPengui: because the set of numbers >= 2 and <= 1 is empty
12:30:07 <TomMD> > floor 22.87
12:30:08 <lambdabot>   22
12:30:11 <TomMD> > ceiling 22.87
12:30:13 <lambdabot>   23
12:30:16 <TomMD> > round 22.87
12:30:17 <lambdabot>   23
12:32:50 <adamvo> > truncate 22.87
12:32:51 <lambdabot>   22
12:33:00 <adamvo> @type truncate
12:33:01 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:33:04 <adamvo> @type floor
12:33:05 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:33:12 <mauke> > fromEnum 22.87
12:33:14 <lambdabot>   22
12:33:21 <adamvo> is there at all a difference between truncate and floor?
12:33:31 <adamvo> @src truncate
12:33:31 <lambdabot> Source not found. It can only be attributed to human error.
12:33:37 <lilac> > takeWhile (not . null) $ iterate (>>= \(x:xs) -> (:x:xs) `liftM` [1..x-1]) [[4]]
12:33:38 <lambdabot>   [[[4]],[[1,4],[2,4],[3,4]],[[1,2,4],[1,3,4],[2,3,4]],[[1,2,3,4]]]
12:33:41 <mauke> > sequence [truncate, floor] (-1.7)
12:33:42 <lambdabot>   [-1,-2]
12:34:10 <mauke> @check \x -> truncate x == floor (x :: Double)
12:34:12 <lambdabot>   "Falsifiable, after 2 tests:\n-1.25\n"
12:34:29 <tromp_> :t sequence
12:34:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:34:38 <adamvo> @check \x -> truncate x == floor (x :: Double) && x >= 0
12:34:39 <lambdabot>   "Falsifiable, after 1 tests:\n-0.5\n"
12:34:53 <adamvo> @check \x -> truncate x == floor (x :: Double) || x < 0
12:34:54 <lambdabot>   "OK, passed 500 tests."
12:34:56 <lilac> @type sequence :: [a -> b] -> a -> [b]
12:34:57 <lambdabot> forall a b. [a -> b] -> a -> [b]
12:34:59 <roconnor> I wish I understood codensity
12:35:12 <lilac> i wish i understood dentistry
12:35:13 <mauke> @check \x -> x >= 0 ==> truncate x == floor (x ::Double)
12:35:14 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:35:14 <lambdabot>           ...
12:36:03 <lilac> @check \x -> x >= 0 && truncate x == floor (x :: Double)
12:36:05 <lambdabot>   "Falsifiable, after 2 tests:\n-1.0\n"
12:36:06 <tromp_> i have dentistry tonoght
12:36:09 <tromp_> tonight even
12:36:12 <lilac> @check \x -> x >= 0 || truncate x == floor (x :: Double)
12:36:13 <lambdabot>   "Falsifiable, after 6 tests:\n-1.6666666666666667\n"
12:36:23 <lilac> ok i suck
12:36:27 <lilac> @check \x -> x < 0 || truncate x == floor (x :: Double)
12:36:28 <lambdabot>   "OK, passed 500 tests."
12:37:14 <wli> You could try inverting the collatz mapping.
12:38:08 <Duqicnk> mmorrow: it was a fast implementation for a variant of the ant code VM from http://alliance.seas.upenn.edu/~plclub/cgi-bin/contest/
12:38:21 <Duqicnk> for a class whose prof decided to lift ICFP contests as class assignments :)
12:38:38 <Duqicnk> the idea was to test ants against each other very quickly for use as a genetic fitness function
12:38:43 <wli> n -> (2*n) : if (n - 1) `mod` 3 == 0 then [(n - 1) `div` 3] else []
12:38:57 <tromp_> collatz( k * 2^n - 1) = collatz (3^n * k - 1)        (k odd)
12:39:21 <Duqicnk> so it compiled the VM into C functions which ran in a little cooperative multitasking/co-routine system i wrote
12:39:28 <edwardk> roconnor: codensity?
12:40:11 <edwardk> roconnor: what did it do for you today? =)
12:40:19 <edwardk> @karma codensity
12:40:19 <lambdabot> codensity has a karma of 1
12:40:31 <edwardk> density++
12:40:49 <lilac> @karma density
12:40:49 <lambdabot> density has a karma of 1
12:40:51 <lilac> @karma codensity
12:40:51 <lambdabot> codensity has a karma of 1
12:41:23 <tromp_> erdos++
12:41:32 <tromp_> @karma erdos
12:41:32 <lambdabot> erdos has a karma of 1
12:42:15 <osfameron> has anyone done any work in calculating interest (for mortgage payments/savings etc.) in Haskell?
12:42:27 <mauke> erds
12:42:54 <edwardk> @karma lambdabot
12:42:54 <lambdabot> lambdabot has a karma of 0
12:43:01 <Tobsan> :(
12:43:02 <aLegendaryPengui> should i take amphetamines
12:43:05 <aLegendaryPengui> like erdos
12:43:18 <Duqicnk> osfameron: what do you mean
12:43:32 <Duqicnk> aLegendaryPengui: take modafinil instead
12:43:35 <Duqicnk> amphetamine is so last century
12:43:41 <aLegendaryPengui> what does that do
12:43:48 <lilac> osfameron: i would have thought it would be straightforward with a decent fixed-point arithmetic library
12:43:56 <aLegendaryPengui> i want something that makes me hyper
12:44:04 <osfameron> Duqicnk: I want to be able to play with some scenarios like: 5% for 2 years, calculated daily, then 3% but overpaying X for 1 year, taking a monthly summary of the results
12:44:07 <aLegendaryPengui> and euphoric
12:44:12 <Duqicnk> it helps you focus and also makes it so you don't have to sleep, at least until you die
12:44:19 <aLegendaryPengui> oh
12:44:28 <aLegendaryPengui> is that the stimulant w/o rebound effects
12:44:33 <osfameron> lilac: well, the actual calculations themselves are straightforward(ish) though interest is far more confusing (to me) than I thought it should be
12:44:40 <Duqicnk> a friend described it as "no, it's totally fine, they gave it to rats and they lived just as many awake hours as the control group"
12:44:46 <Duqicnk> just google / erowid it
12:45:15 <Duqicnk> osfameron: sounds like a good exercise
12:45:19 <Duqicnk> pure and mathy
12:45:23 <osfameron> but I'm not sure about the mechanism of "this scenario, then that scenario, then the other scenario" and taking data sequentially from it.  I'm sure it's not *difficult* but if there's prior art then I'd work with that :-)
12:45:38 <Duqicnk> after that write a massively parallel monte carlo valuation engine for complex derivatives ;)
12:45:46 <edwardk> > takeWhile (>0) . iterate ((subtract 1200) . (*1.03)) $ 10000
12:45:47 <lambdabot>   [10000.0,9100.0,8173.0,7218.1900000000005,6234.735700000001,5221.7777710000...
12:45:57 <edwardk> ;)
12:45:58 <Duqicnk> osfameron: you want to plot the scenarios against each other?
12:45:58 <osfameron> Duqicnk: yeah... thing is, it's also kinda useful to me (to help me calculate my mortgage ;-) so I'd be as happy with a "Here is a solution!" as with an enormous (but fun) yak
12:46:06 <Duqicnk> @type zip
12:46:07 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
12:46:18 <lilac> osfameron: ultimately, you're dealing with a single number (your balance) at each stopping point, so your scenarios can just be functions :: Balance -> Balance
12:46:32 <osfameron> right now I have a spreadsheet with some calculations
12:46:41 <b_jonas> what monad?
12:46:46 <osfameron> I have a "current interest", "length of contract", "interest after that"
12:46:48 <edwardk> er rather to be more actuarial:
12:46:53 <edwardk> > takeWhile (>0) . iterate ((subtract 1200) . (*1.03**(1/12))) $ 10000
12:46:54 <lambdabot>   [10000.0,8824.662697723037,7646.4266965852075,6465.284847613131,5281.229984...
12:46:57 <osfameron> but of course that's not very subtle... (i.e. there are only 2 states)
12:47:26 <lilac> osfameron: in which country are you? in the uk the solution is "it doesn't matter, the interest is nearly 0 anyway"
12:47:30 <Duqicnk> osfameron: you should define a preference function over payment schedules and then use gradient descent to find your optimal mortgage parameters
12:47:34 <osfameron> lilac: hehehe, yeah, UK
12:47:54 <lilac> osfameron: my building society keep sending me letters saying "we're going to charge you less if that's ok"
12:48:13 <osfameron> it's a really useful exercise: for me it was amazing to see that at my payment, it almost doesn't matter what the interest rate is, the fact of overpaying (even a small amount) has vastly more impact
12:48:39 <osfameron> lilac: yeah... I'm with nationwide who keep saying "We have a collar at 2%" and then keep dropping our rate below it... we're scared to speak to them in case they notice...
12:49:15 <osfameron> Duqicnk: eeeek!  that's even more sophisticated than what I'mlooking at, but yeah, it would fall out of it naturally I guess.
12:49:29 <edwardk> osfameron: overpaying helps a ton early on
12:49:31 <Duqicnk> yeah well it's haskell, you can do anything in 2 lines of code
12:49:36 <Duqicnk> !faq
12:49:41 <Duqicnk> err
12:49:42 <Duqicnk> @faq
12:49:42 <lambdabot> The answer is: Yes! Haskell can do that.
12:49:55 <osfameron> Duqicnk: yes... but it'll take you as long to write the 2 lines as it would have done to write a full program in $other_language ;-)
12:50:06 <edwardk> Duqicnk: sure, and you can use AD to find the gradient, etc ;)
12:50:07 <ray> @faq but can haskell do it in two lines of code?
12:50:07 <lambdabot> The answer is: Yes! Haskell can do that.
12:50:09 <Duqicnk> you have to understand the tao of the lambda first, yes
12:50:34 <osfameron> anyway... the answer to the "has someone already done it?" question seems to be no though ;-)
12:51:08 <lilac> osfameron: if you get a good answer, i'd be interested :)
12:51:15 <b_jonas> and the first line is a LANGUAGE pragma enabling type system extensions?
12:51:44 <lilac> b_jonas: that can be put on the same line as the definition of your One True Data Type
12:52:25 <b_jonas> one true datatype is for dynamically typed systems
12:52:28 <lilac> line 1 is a LANGUAGE pragma and a data type. line 2 is a hylomorphism via your type which elegantly solves the problem
12:52:37 <b_jonas> heh
12:53:00 <edwardk> b_jonas {-# LANGUAGE DoWhatIMean #-}
12:53:16 <Duqicnk> is there a lambdabot plugin that generates random category-theoretic gibberish?
12:53:20 <lilac> {-# LANGUAGE English #-}
12:53:44 <edwardk> Duqicnk: someone standing over my shoulder said yes, its called 'edwardk'
12:53:45 <lilac> Duqicnk: depends. do other people in this channel using @quote count?
12:53:50 <b_jonas> Duqicnk: heh
12:53:53 <Philippa__> Duqicnk: no, but someone ran a markov bot called Megamonad that did for a while
12:54:09 <b_jonas> @quote morph
12:54:09 <lambdabot> quicksilver says: someone with artistic talent should do a drawing entitled unsafePerformMetamorphosis
12:54:12 <Philippa__> it eventually passed the turing test in chan, someone thought it was taking the piss
12:54:17 <b_jonas> @quote morph
12:54:18 <lambdabot> ghc says: falls under the monomorphism restriction
12:54:18 <Duqicnk> hahaha
12:54:21 <lilac> @quote zygo
12:54:21 <lambdabot> EvilTerran says: [on category theory] the same place of nightmares that spawned zygohistomorphic prepromorphisms :P
12:54:22 <Duqicnk> @quote Megamonad
12:54:22 <lambdabot> No quotes match. My mind is going. I can feel it.
12:54:33 <b_jonas> @quote cata
12:54:33 <lambdabot> monochrom says: I know that one day you won't need to write the code for "interpret" yourself. You will just need to write the type signature, and add the word "catamorphism", and then the program
12:54:33 <lambdabot> will write itself.
12:54:45 <lilac> @quote hylo
12:54:45 <lambdabot> EvilTerran says: Hylo morphism batman!
12:54:47 <EvilTerran> ... except those whatevermorphisms are domain theory, iirc.
12:54:48 <Duqicnk> @quote markov
12:54:48 <lambdabot> shapr says: CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
12:54:55 <Duqicnk> @quote markov
12:54:55 <lambdabot> shapr says: CosmicRay ran a HiddenMarkov bot on four years of #haskell logs and it kept trying to talk to me about unicycling.
12:54:57 * edwardk needs to apologize for unleashing the zygohistomorphic prepromorphisms some day. 
12:55:05 <b_jonas> @quote commut
12:55:05 <lambdabot> DRMacIver says: I dread to think what category theory would look like after the software engineering world had got their grubby paws on it. Enterprisevariant functors. Commutative UML diagrams.
12:55:11 <lilac> @quote contravariant hom-functor
12:55:11 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
12:55:11 <b_jonas> LOL
12:55:20 <b_jonas> "Commutative UML diagrams"
12:55:22 <bavardage> is there a more elegant way to do this?
12:55:23 <Duqicnk> what about the Monad Design Pattern?
12:55:25 <bavardage> fromRational (toRational d) :: NominalDiffTim
12:55:31 <bavardage> where d is a double
12:55:41 <bavardage> *NominalDiffTime
12:55:46 <mauke> :t realToFrac
12:55:47 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
12:55:58 <bavardage> oh thanks :D
12:56:16 <edwardk> they were safely locked up, their body parts strewn across several thesis and papers, but when placed together its ability to terrify is somewhat disturbing
12:56:23 <Philippa__> Duqicnk: there was a page of megamonad quotes on the old wiki, IIRC. It may've been ported over
12:56:56 <lilac> @go megamonad quotes
12:56:57 <lambdabot> No Result Found.
12:57:01 <Duqicnk> http://www.mail-archive.com/haskell-cafe@haskell.org/msg06201.html
12:59:57 <___> @. elite yarr
12:59:58 <lambdabot> IS 7hAt a |-|0rnpiPE in yeR P0(kEt, OR arr YA Ju$7 HAPPY T4 SE3 m3?
13:00:56 <sacko> hey all, could someone help me with this error please? i really don't know whats wrong with it. http://haskell.pastebin.com/m7e8e0cbd
13:01:31 <mauke> your function's return type is not Bool
13:01:33 <___> sacko: do blocks require a monadic type
13:01:52 <___> what's the type of doesFileExist?  I assume something -> IO somethingElse
13:01:57 <mauke> also, wtf?
13:01:58 <sacko> IO Bool
13:02:06 <mauke> right = doesFileExist  -- shorter definition
13:02:06 <sacko> i added the wtf :-)
13:02:38 <___> right's result is an IO Bool
13:03:01 <sacko> i thought it was turned to a bool by the '<-'
13:03:17 <mauke> yes, but 'return' wraps it up again
13:03:19 <saml> sacko, x :: Bool
13:03:19 <___> also, it looks like right = id
13:04:01 <sacko> so return x?
13:04:11 <saml> @type doesFileExist
13:04:13 <lambdabot> Not in scope: `doesFileExist'
13:04:26 <saml> sacko, return :: a -> m a
13:04:32 <___> m = IO
13:04:40 <___> in this case
13:04:48 <b_jonas> okay, well from experimenting it does seem that the modify time matters
13:04:57 <saml> sacko, when you use return, Bool becomes   Monad Bool
13:05:10 <b_jonas> so please help me, how do I force ghc to reload a module even if the mtime of the source hasn't changed?
13:05:12 <Samuel> hi everyone (yes, i'm a newcomer!). Could you please tell me how can i check a variable type during runtime? (i wanna check if a variable is a string and the other is a number, for grouping purposes!)
13:05:24 <mauke> Samuel: you can't
13:05:34 <mauke> that would break polymorphism
13:05:37 <b_jonas> haskell is a statically typed language, like C
13:05:37 <sacko> oh, ok now i understand it. i need to think of a better way of getting at the boolean
13:05:38 <mauke> er, parametricity
13:05:56 <b_jonas> (more than C)
13:06:03 <Duqicnk> Samuel: look at the type "Either String Int"
13:06:24 <Gracenotes> Samuel: or define your own datatype
13:06:35 <Gracenotes> data MyData = MyString String | MyInt Int
13:06:53 <Duqicnk> which is isomorphic to Either String Int, but you can generalize this further
13:06:56 <Gracenotes> then there are two constructors for the value: MyString and MyInt. And you can do stuff with the value, depending on whether it holds an Int or a String
13:06:57 <saml> @hoogle m a -> a
13:06:57 <lambdabot> Data.Monoid getDual :: Dual a -> a
13:06:57 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:06:57 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
13:07:09 <Duqicnk> @src Dual
13:07:09 <lambdabot> Source not found.
13:07:11 <Gracenotes> Duqicnk: quite, but without the pesky polymorphism :)
13:07:23 <Samuel> oh no? no isInteger() stuff? Hm... that's why i didn't find anything on google =).
13:07:32 <b_jonas> Statically typed sort of means that the type of each expression in a program is determined at compile time. Well, that's what it means for C. It's a bit more complicated for languages like haskell.
13:07:37 <edwardk> data Dual a = Dual { getDual :: a }
13:07:43 <saml> > if (unsafePerformIO (do { return True })) then "yay" else ""
13:07:44 <lambdabot>   Not in scope: `unsafePerformIO'
13:07:55 <Gracenotes> Samuel: the compiler won't let you pass something that's an Integer to a function that's declared to expect an Integer
13:08:05 <Duqicnk> saml: no IO in lambdabot
13:08:05 <Gracenotes> er. *something that's not an Integer
13:08:06 <___> > if (unsafePerformIO (do { formatHardDrive; return True })) then "yay" else ""
13:08:06 <kadaver> does haddock come with GHC?
13:08:07 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `formatHardDrive'
13:08:10 <Duqicnk> for, err, obvious reasons
13:08:16 <edwardk> instance Monoid a => Monoid (Dual a) where mempty = Dual memoty; Dual a `mappend` Dual b = Dual (b `mappend` a)
13:08:26 <Gracenotes> > unsafePerformIO $ ddos "http://haskell.org"
13:08:28 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `ddos'
13:08:42 <Duqicnk> b_jonas: it's not more complicated for haskell, it's that the types themselves are more complicated
13:09:07 <Duqicnk> edwardk: it just makes your monoid go backwards?
13:09:22 <edwardk> Duqicnk: yep
13:09:27 <Duqicnk> @hoogle (Monad m) => m a -> a
13:09:27 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:09:27 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:09:27 <lambdabot> Control.Monad.Instances (>>) :: Monad m => m a -> m b -> m b
13:09:47 <edwardk> Duqicnk: a monoid is just a category with one object. every category has a dual category, thats just the dual monoid
13:10:04 <b_jonas> kadaver: yes
13:10:06 <edwardk> its the monoid over flip mappend
13:10:22 <edwardk> er using
13:10:25 <b_jonas> kadaver: though I'm not sure if it's in the main or the extralibs part
13:11:45 <Gracenotes> Hoogle needs to stop seeing duplicate imported definitions! :X
13:12:02 <Duqicnk> so the single object of the monoid-as-category is the set of elements in the monoid-as-set-with-binary-op ?
13:12:27 <Samuel> I'm still learning haskell, and don't know yet how to handle or create types... What i want is to group a string into pairs (String, Int)... i'll receive something like "day 12 month 14 year 1209 hour 12" and so on... i'd like to group them in pairs ("day", 12). perhaps i should check the words for a-z then digits... is that a good way to do it??
13:12:51 <Duqicnk> @type (Read a) => String -> Maybe a
13:12:52 <lambdabot> parse error on input `=>'
13:12:53 <gwern> one of the things that made me love computer science was when I finally got that the kolmogorov complexity of any one integer could be indefinitely greater than that of all integers
13:12:54 <pumpkin> edwardk: if you have a commutative monoid, is the dual of its category itself?
13:12:56 <Duqicnk> durr
13:12:59 <Duqicnk> @hoogle (Read a) => String -> Maybe a
13:12:59 <lambdabot> Prelude read :: Read a => String -> a
13:12:59 <lambdabot> Text.Read read :: Read a => String -> a
13:12:59 <lambdabot> Distribution.Text simpleParse :: Text a => String -> Maybe a
13:13:09 <Duqicnk> > simpleParse "Hello"
13:13:11 <lambdabot>   Not in scope: `simpleParse'
13:13:19 <Duqicnk> @type reads
13:13:20 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:13:29 <Duqicnk> @type listToMaybe
13:13:30 <lambdabot> forall a. [a] -> Maybe a
13:13:36 <edwardk> pumpkin: a + b = b + a, so sure
13:13:50 <Duqicnk> @type (liftM fst) . listToMaybe . reads
13:13:52 <lambdabot> forall a. (Read a) => String -> Maybe a
13:13:53 <gwern> @check \x y -> x+y == y+x
13:13:54 <lambdabot>   "OK, passed 500 tests."
13:13:58 <pumpkin> just making sure I understood what a category's dual is :)
13:14:25 <edwardk> pumpkin_: keep in mind you usually use (.) rather than mappend when you think about a monoid as a category
13:14:42 <edwardk> because + usually has a different connotation in that context
13:14:43 <pumpkin> even in general, mappend seems like a bad name to me
13:14:52 <edwardk> pumpkin yeah.
13:14:59 <kadaver> C:\ghc\ghc-6.10.1\progs\Data\Tree\RedBlack>haddock RedBlackTree.hs
13:15:00 <kadaver> Warning: main:RedBlackTree: could not find link destinations for:
13:15:00 <kadaver>     GHC.Show.Show GHC.Classes.Ord Data.Maybe.Maybe GHC.Bool.Bool GHC.Integer.Int
13:15:00 <kadaver> ernals.Integer
13:15:02 <Duqicnk> edwardk: how does the binary op on a monoid relate to morphisms of the monoid as category?
13:15:17 <gwern> (yarr, there be treasure buried over in mapp's end!)
13:15:42 <Duqicnk> @check \a -> a == a
13:15:44 <lambdabot>   "OK, passed 500 tests."
13:15:52 <Duqicnk> (how does it pick a type?)
13:15:57 <pumpkin> @check \a b -> a == b
13:15:59 <lambdabot>   "OK, passed 500 tests."
13:16:00 <pumpkin> it defaults to ()
13:16:01 <pumpkin> :P
13:16:02 <Duqicnk> haha
13:16:07 <pumpkin> @check \a b -> a == (b :: Int)
13:16:08 <lambdabot>   "Falsifiable, after 0 tests:\n0\n-2\n"
13:16:11 <edwardk> Duqicnk: the morphisms of the monoid as a category are the values in the monoid. the operation is concatenation of those arrows. since it is associative and binary, and every arrow connects to the same object. you meet the laws of a category trivially.
13:16:36 <edwardk> so you have arrows for, for instance 2 and 3 and when you use + you are concatenating those arrows to get an arrow 5.
13:17:26 <edwardk> Duqicnk: the perspective shifts a bit when you talk about rings, there you usually view the * operation as the arrows in the category, and just say the category is pre-additive
13:17:33 <edwardk> er
13:17:44 <Duqicnk> * as arrows or * as composition of arrows?
13:17:44 <vixey> gwern that doesn't make sens: /
13:17:47 <edwardk> you view the * operation as the concatenation of arrows in the category
13:17:50 <Duqicnk> right, okay
13:18:41 <edwardk> the pre-additive enriches your arrows internally with the structure of the category of abelian groups, which lets you do the addition
13:18:48 <Duqicnk> and the single object of the category is just some arbitrary point?
13:18:51 <edwardk> er the pre-additive condition
13:18:52 <Duqicnk> in a monoid i mean
13:18:55 <edwardk> yeah
13:19:07 <Duqicnk> ah, it's actually like church numerals
13:19:10 <edwardk> its useless in its own right, its just a place for your arrows to all attach to
13:19:12 <b_jonas> argh!
13:19:14 * mauke is tempted to make a Metroid typeclass
13:19:21 <gwern> vixey: don't go in Mapp End. it's the bad part of town
13:19:37 <b_jonas> unloading and the :add-ing the modules seems enough, but I can't uload it without knowing the full set of modules that were loaded
13:19:44 <b_jonas> I don't know what to do
13:19:53 <gwern> :show modules ?
13:19:55 <edwardk> Duqicnk: yeah, you have an identity arrow because you are a category, and a bunch of other arrows, and composition always exists and is associative, there all the definitions tie up nicely
13:19:59 <b_jonas> gwern: yeah, but
13:20:06 <b_jonas> automatically from a ghci command
13:20:15 <b_jonas> should I catch its output or something?
13:20:15 <Duqicnk> cool, thanks for the explanation
13:20:38 <gwern> well, it's possible to do ':redir hlintvar1 :show modules'
13:20:46 <gwern> and then you can manipulate hlintvar1
13:20:59 <edwardk> a groupoid is a category where all the arrows are invertible, and a group is just a monoid where all of the arrows are invertible or alternatively a groupoid with a single object.
13:21:01 <b_jonas> :redir?
13:21:03 <gwern> some of my hlint code: 'let hlintvar2 = map (fst . break (==',') . drop 2 . snd . break (== '(')) $ lines hlintvar1", ":cmd return (\":! hlint \" ++ (concat $ intersperse \" \" hlintvar2))", ":set +t +s"]'
13:21:05 <b_jonas> that's not in the docs
13:21:16 <gwern> no, it's one of the addons
13:21:17 <gwern> let { redir varcmd = case break Data.Char.isSpace varcmd of { (var,_:cmd) -> return $ unlines [":set -fno-print-bind-result","tmp <- System.Directory.getTemporaryDirectory","(f,h) <- System.IO.openTempFile tmp \"ghci\"","sto <- GHC.Handle.hDuplicate System.IO.stdout","GHC.Handle.hDuplicateTo h System.IO.stdout","System.IO.hClose h",cmd,"GHC.Handle.hDuplicateTo sto System.IO.stdout","let readFileNow f = readFile f >>= \\t->length t `seq` ...
13:21:23 <gwern> ... return t",var++" <- readFileNow f","System.Directory.removeFile f"]; _ -> return "putStrLn \"usage: :redir <var> <cmd>\"" } }
13:21:45 <b_jonas> I could also fake the mtime of the file
13:21:46 <Duqicnk> a groupoid with multiple objects doesn't have identity, because you are only guaranteed an identity arrow for each object
13:21:49 <b_jonas> but that seems like a kludge
13:21:54 <b_jonas> ghci sucks
13:22:18 <gwern> scripting ghci does indeed suck
13:23:00 <pumpkin> does TH have full access to the source/AST of the file it's being run from, or must you embed any code you want it to have access to in a QQ or the like?
13:23:00 <Duqicnk> err, maybe?
13:23:04 <edwardk> Duqicnk: correct, you have identity arrows for each object, so you locally always have something you can stick on the ends of something, but you effectively only have a partial binary function with those local identities and the invertability property
13:23:14 <pumpkin> , [$d| let x = 5 in x |]
13:23:15 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Quote.QuasiQuoter'
13:23:45 <Duqicnk> ah wait, i was confusing a groupoid with a semigroup
13:23:48 <pumpkin> hmm, I fail
13:24:20 <edwardk> Duqicnk: yeah semigroups unfortunately fail the nice model. you can have a category -of- semigroups, but not view a semigroup (directly) as a category.
13:24:21 <Duqicnk> the groupoid is not *total* because two arrows are not necessarily composable, i.e. not all arrows are endo-functions
13:24:27 <edwardk> yeah
13:24:34 <b_jonas> gwern: okay, thanks
13:24:40 <b_jonas> I'll think of what to do
13:24:52 <Samuel> hmm.. sorry.. i still coudn't make it. I have ["Name",  "john", "fergusson", "father", "me", "Day", "12" , "Month", "12", "Year", 1230", " hour",  132" , "day", "13" ]. i'd like to have it as ["Name",  "john", "fergusson", "father", "me", ["Day", 12] , ["Month", 12], ["Year", 1230], [ "hour",  132] , ["day", 13 ]... i'd like to pair only the [str-int] pairs..
13:24:54 <gwern> b_jonas: the pimped out .ghci I borrowed redir from is floating around the -cafe and hawiki fwiw
13:25:22 <pumpkin> Samuel: you can't do that, lists must be homogeneous
13:25:33 <pumpkin> Samuel: unless you make an odd wrapper type that you probably don't want
13:25:35 <gwern> Samuel: in that situation, I'd use an ADT
13:25:53 <gwern> pumpkin: it's not that odd. 'data Foo = Bar String | (String, Int)' would work wouldn't it?
13:25:54 <b_jonas> gwern: finding out which modules are loaded and then loading all but that one I want to reload with :load isn't really ideal either, as it will reinterpret all the other modules too I think
13:26:00 <BMeph> Samuel: You can, however pair them. ;)
13:26:10 <Samuel> ohhh... bad news for me then ^^
13:26:23 <edwardk> Duqicnk: you could of course take a semigroup and bolt on an identity yielding a category, nay, monoid, but you've basically just constructed "Maybe" which can take any semigroup and make it into a monoid.
13:26:26 <pumpkin> gwern: oh, I was talking about a forall'ed type
13:26:26 <Duqicnk> semigroups are not categories because there is no identity element, hence no identity morphism
13:26:31 <BMeph> gwern: Add a tag name for the pair. :)
13:26:31 <pumpkin> gwern: but yeah, that would be nicer :)
13:26:33 <edwardk> yep
13:26:38 <Duqicnk> i see
13:26:43 <gwern> BMeph: meh. the compiler would've told me that :)
13:26:53 <pcc1> would there be any interest in monadic versions of the map-updating functions (update, alter, adjust)?
13:27:03 <Duqicnk> so Maybe is a functor which turns any semigroup into a monoid?
13:27:08 <gwern> pumpkin: how would a forall type work?
13:27:22 <edwardk> functor in a loose sense, because its not coming from a category
13:27:27 <Duqicnk> by liftM2-ing the binary op?
13:27:30 <Duqicnk> ah yeah i see
13:27:41 <pumpkin> data X = forall a. (Show a) => X a
13:27:44 <Duqicnk> it is however an arrow in the category of haskell types which is sometimes what we mean by "functor", correct?
13:27:44 <pumpkin> one of those
13:27:51 <pumpkin> but probably with a typeclass more useful than show
13:28:17 <Samuel> hm... guess i'll have to read a little more =)
13:28:37 <Duqicnk> pumpkin: that's an existential type, right?
13:28:39 <edwardk> Duqicnk: well, Maybe is an endofunctor over Hask, the monoids in question there are just structures embedded into that larger category.
13:28:40 <Samuel> thank you for your time! you're really as nice as ppl say =)
13:28:49 <pumpkin> Duqicnk: yup, I think so
13:29:03 <Duqicnk> even that X is useful
13:29:11 <Duqicnk> you can accumulate a list of things to Show and then do them all in one go
13:29:41 <gwern> I wonder if [[Big O]] goes to the tv show or the cs stuff
13:29:50 <Duqicnk> or other things
13:29:54 <gwern> (a disambig. how boring)
13:30:16 <Raevel> edit the page!!
13:30:30 <gwern> how?
13:31:04 <b_jonas> anyway, good night
13:31:10 <Raevel> i'm confused
13:31:20 <Duqicnk> edwardk: this category Hask, its objects are Haskell types of kind *, and its arrows are Haskell types of kind * -> *?
13:34:40 <kadaver> so what do I need to pass to haddock more than the source fle?
13:34:57 <kadaver> Warning: main:RedBlackTree: could not find link destinations for:
13:35:15 <kadaver>     GHC.Show.Show GHC.Classes.Ord Data.Maybe.Maybe GHC.Bool.Bool GHC.Integer.Int
13:35:15 <kadaver> somehow all that too?
13:35:34 <gwern> ghc just doesn't come with all the docs, I vaguely remember being the xplanation
13:36:35 <edwardk> Duqicnk: no. objects are types, arrows are types of the form (a -> b). it has exponential objects so each of its arrows is also an object in the category, we just pun them and call them the same thing
13:37:11 <bavardage> @src liftIO
13:37:11 <lambdabot> Source not found. You untyped fool!
13:37:16 <bavardage> @hoogle liftIO
13:37:17 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
13:37:21 <bavardage> WTF
13:37:30 <bavardage> I use this function somewhere, yet I never import that module :|
13:37:33 <bavardage> I AM SO CONFUSED
13:37:44 <pumpkin> you use liftIO a lot? :o
13:37:51 <flazz_> () is read "unit"? is it equivalent to nil?
13:37:58 <gwern> bavardage: perhaps it was re-exported
13:38:01 <edwardk> Duqicnk: there should be a category for polymorphism which provides free theorems that would look like what you described, but thats not what is commonly referred to as Hask
13:38:12 <pumpkin> flazz_: I wouldn't say it's equivalent to nil, but you could treat it as such in some cases
13:38:17 <pumpkin> flazz_: but yeah, people call it unit
13:38:43 <pumpkin> :t undefined :: 1
13:38:44 <lambdabot> Unit
13:38:48 <pumpkin> !
13:38:49 <pumpkin> :)
13:38:53 <flazz_> nice
13:38:59 <flazz_> i guess if it were nil people would call it that
13:39:01 <gwern> lambdabot has a unit?
13:39:01 <pumpkin> :t () :: 1
13:39:02 <lambdabot>     Couldn't match expected type `Unit' against inferred type `()'
13:39:08 * gwern 's preconceptions are exploded!
13:39:09 <pumpkin> see, Unit /= ()
13:39:12 <flazz_> Nothing has more of a nil feeling
13:39:20 <pumpkin> flazz_: yeah, that's what it's supposed to be :)
13:39:24 <gwern> @vixen do you really have a 'unit' if you know what I mean?
13:39:24 <lambdabot> i'm not sure what i mean
13:39:33 <flazz_> i feel so relaxed when i make haskell code
13:39:48 <pumpkin> Prelude> :t undefined :: 1
13:39:48 <pumpkin> undefined :: 1 :: GHC.Generics.Unit
13:39:51 <gwern> we make-a the haskell the way you like-a!
13:40:00 <edwardk> flazz_: () is a type with one (non-bottom) value in it. we call Void or something like that a value that only contains bottom. where bottom is what we say a function 'returns semantically when it never returns.
13:40:01 <pumpkin> I have no idea why it got special treatment to get 1 treated as a type
13:40:09 <edwardk> > error "Ugh" :: ()
13:40:10 <lambdabot>   * Exception: Ugh
13:40:34 <edwardk> @type error
13:40:36 <lambdabot> forall a. [Char] -> a
13:41:07 <edwardk> error "foo" is a member of every type, so () has inhabitants () and any error type you think up
13:41:18 <edwardk> thats probably a lot more pedantic than you need
13:41:31 <fabjan> > error ()
13:41:32 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `()'
13:41:36 <fabjan> oops
13:42:11 <edwardk> anyways the type that only contains error 's (and undefined, which is just a particular error) and functions that never get around to giving an answer is usually called Void.
13:42:23 <edwardk> that would be closer to the conception of nil that you may have
13:43:41 <edwardk> er in the above i should have said any 'error message' you can think up
13:44:06 <edwardk> but there isn't (conceptually anyways) any way to see what error you got directly in the language
13:44:26 <edwardk> hence its indistinguishable semantically from a method that just spins forever
13:45:09 <EvilTerran> neither returns a value
13:48:36 <roconnor> edwardk: just vaguely following the thread on codensity in cafe
13:48:42 <roconnor> but not following enough to understand
13:50:03 <kadaver> "Tell GHC that that its lib directory is dir. Needed to do any processing. " exactly what is the lib directory?
13:50:23 <AnalogHole> Hey all. I'm pretty new to haskell and I'm playing around making my first program so I thought I'd use a little HOpenGL. First thing that noticed is that HOpenGL an GLUT like to use the  $= operator.  Am I to understand that this is a global state variable? Seems like kind of a headslapper considering how Haskell is supposed to avoid state like that.
13:50:40 <Duqicnk> AnalogHole: OpenGL is by design stateful
13:50:46 <Duqicnk> @src ($=)
13:50:46 <lambdabot> Source not found. Maybe you made a typo?
13:50:59 <bavardage> with gtk2hs, how do I add some value that's accessible everywhere
13:51:02 <bavardage> i.e. I want some state
13:51:03 <MyCatVerbs> kadaver: where it'll look for the compiled Haskell libraries.
13:51:13 <bavardage> (I want a backing pixmap for something I'm rendering with cairo)
13:51:19 <Duqicnk> AnalogHole: ($=) is in a typeclass such that it works on plain old IORefs as well as OpenGL's special variables
13:51:33 <pumpkin> bavardage: global state!!! what channel do you think you're in?? :P
13:51:39 <bavardage> hehe
13:51:44 <pumpkin> bavardage: (pass an IORef around, maybe?)
13:51:48 <bavardage> pumpkin: well what's a better way of having a backing pixmap then
13:51:50 <bavardage> kk
13:51:52 <bavardage> IORef
13:51:54 <bavardage> I'll look into it
13:51:57 <bavardage> (no clue what one is :D)
13:51:58 <Duqicnk> bavardage: isn't all the gtk stuff in IO already?
13:52:02 <Duqicnk> @src IORef
13:52:02 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:52:07 <bavardage> it is in IO yes
13:52:13 <bavardage> so how do I 'store' stuff in IO?
13:52:18 <bavardage> I dunno any of the terms
13:52:23 <Duqicnk> @type newIORef
13:52:24 <lambdabot> Not in scope: `newIORef'
13:52:40 <Duqicnk> just look at docs for Data.IORef
13:53:11 <AnalogHole> So I gather playing with  OpenGL might be a bad intro to Haskell programming? I mean, as far as best practices\
13:53:29 <Duqicnk> AnalogHole: it depends.  if your goal in learning haskell is to do stateful things, it's not a bad start
13:54:10 <Duqicnk> but i'd recommend you first learn the basics without using any monads, and then learn monads in terms of a nice one like Maybe rather than the very strange IO monad
13:54:16 <Duqicnk> and only then do IO-heavy stuff
13:54:45 <mauke> I recommend you learn the basics first, then IO, then later on monads (maybe)
13:54:58 <Duqicnk> mauke: the problem is that people take intuition from IO and extend it to other monads, where it doesn't apply
13:55:02 <AnalogHole> Well, i want to do something useful. I dont really learn much with trivial examples. I can't think of anthing useful that doesn't involve a lot of IO
13:55:07 <mauke> so don't learn "monads"
13:55:15 <pumpkin> burritos
13:55:15 <mauke> just learn IO
13:55:21 <Duqicnk> given that you have GHCi you can do a lot without any explicit IO
13:56:54 <bavardage> Duqicnk: so an IORef is analogous to an imperative pointerL
13:56:56 <bavardage> *?
13:57:00 <bavardage> and you just pass it around
13:57:02 <AnalogHole> I'm not sure what you mean. GHCi is more or less for testing simple one liners, no? How's that going to help me?
13:57:19 <Duqicnk> AnalogHole: you can make arbitrarily complicated "pure" functions and load them into ghci
13:57:24 <c_wraith> Well, you can load external modules.
13:57:30 <roconnor> heh, most haskell programs are one liners :P
13:57:30 <Duqicnk> bavardage: not quite, it also allocates the storage
13:57:33 <bavardage> GHCi is funky
13:57:41 <mauke> AnalogHole: do you know C?
13:57:43 <Duqicnk> it's exactly like a ref in OCaml
13:57:48 <c_wraith> So if you skip the IO parts, you can write programs, load them, and then run the IO parts via GHCI
13:57:56 <bavardage> Duqicnk: right, a better term then (yeah I'm not really a C programmer) would be like a reference in python?
13:58:08 <AnalogHole> mauke: I'm comfortable with C, but lately I've been doing mostly Ruby.
13:58:08 <bavardage> so really most variables in python
13:58:16 <mauke> ah, ok
13:58:27 <Duqicnk> bavardage: i would just think of an IORef as a name for a box
13:58:42 <Duqicnk> when you make a new IO ref, it creates a box, writes a new "name" on it, fills it with an initial value, and hands you the name
13:58:44 <bavardage> yup
13:58:47 <bavardage> sounds like python
13:58:48 <bavardage> kk :D
13:58:50 <mauke> AnalogHole: anyway, if you can formulate your useful programs as functions from stdin to stdout, there's a really easy way to make that happen :-)
13:59:35 <Duqicnk> bavardage: if you want to use IORefs in a context which isn't already IO-related, you can use STRef instead.  the advantage then is that you can "run" the computation and get the value out of the monad, in a provably safe way
13:59:46 <Duqicnk> and it's just as efficient
13:59:47 <mauke> the template for that is 'main = interact f' where f :: String -> String
14:00:14 <bavardage> Duqicnk: oh kk, but since this *is* all within IO
14:00:20 <bavardage> then it's better to use IORef?
14:00:23 <mauke> main = interact f; f = unlines . filter (not . all isSpace) . lines
14:00:24 <Duqicnk> yeah, go ahead and use IORef
14:00:25 <Philippa__> yeah
14:00:31 <Duqicnk> unless there's some chance you'll factor out the IO later
14:01:05 <AnalogHole> mauke: Well, I was thinking more like making a simple game.
14:01:12 <Philippa__> eh, even if you do it's not too hard to s/ST/IO
14:01:24 <Duqicnk> true
14:01:28 <mauke> AnalogHole: in that case you probably want to learn IO :-)
14:01:34 <Philippa__> learn to refactor well
14:01:46 <Philippa__> then you don't get trapped by your own defensiveness
14:01:53 <roconnor> depending on the game, you might not need a lot of IO.
14:02:05 <pumpkin> is it correct to say that ST only differs from IO in its type?
14:02:11 <Duqicnk> pumpkin: no
14:02:16 <bavardage> is ST also a monad then?
14:02:21 <vixey> yes
14:02:22 <Duqicnk> (ST s) is a monad
14:02:25 <Duqicnk> for any s
14:02:41 <pumpkin> how do they differ beyond that? I vaguely recall seeing one being unsafeCoerced into the other
14:02:52 <Duqicnk> generally s is kept abstract, i.e. it's a variable that's not instantiated
14:02:58 <mauke> ST only allows state variables, not IO
14:03:09 <Duqicnk> this is how you can "run" the ST action, unlike IO
14:03:09 <pumpkin> oh yeah, but I mean implementation wise
14:03:10 <Duqicnk> @type runST
14:03:11 <lambdabot> forall a. (forall s. ST s a) -> a
14:03:35 <Duqicnk> @hoogle ST RealWorld a -> IO a
14:03:35 <lambdabot> Control.Monad.ST stToIO :: ST RealWorld a -> IO a
14:03:35 <lambdabot> Control.Monad.ST.Lazy stToIO :: ST RealWorld a -> IO a
14:03:35 <lambdabot> Control.Monad.ST unsafeSTToIO :: ST s a -> IO a
14:03:59 <Duqicnk> pumpkin: STRefs and IORefs are implemented the same in ghc, i believe
14:04:09 <pumpkin> @src ST
14:04:09 <lambdabot> newtype ST s a = ST (STRep s a)
14:04:15 <Duqicnk> you can in fact implement ST in pure haskell, but it defeats the purpose
14:04:26 <pumpkin> Duqicnk: ah, that must be what I'm thinking of then
14:06:12 <AnalogHole> mauke: I'm not sure exactly what you mean by "learn IO". I mean, I know how to read/write files and such. I have a basic idea of what a monad is. I was really just put off by the heavy use of state in the OpenGL examples. Is there perhaps a better grahics library for Haskell that is better suited to functional programming?
14:06:16 <vixey> @src STRep
14:06:17 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
14:06:23 <mauke> AnalogHole: oh, oops
14:06:42 <mauke> AnalogHole: I don't know particular library, but I think FRP is going that way
14:06:45 <mauke> +a
14:07:13 <Duqicnk> which FRP library is the shiniest?
14:07:45 <Duqicnk> @src State#
14:07:45 <lambdabot> Source not found. My mind is going. I can feel it.
14:07:57 <flazz_> question about do notation: given a binding "name <- function; blah ..." bind may run the code "blah ..." as many or as little times as it wants?
14:08:32 <mauke> flazz_: what's the difference?
14:09:14 <flazz_> mauke: i'm trying to intuitively grasp how do notation works, >>= takes all code below and does *something* with it?
14:09:35 <vixey> @undo do name <- function; blah
14:09:35 <lambdabot> function >>= \ name -> blah
14:10:00 <flazz_> and blah is until the next semicolon or the end of the function?
14:10:18 <mauke> blah is all the rest
14:10:28 <mauke> what >>= does depends on which >>= we're talking about
14:10:32 <flazz_> right
14:10:43 <flazz_> that is why it could run it a billion times or not at all
14:11:05 <mauke> > "foobarbaz" >>= \c -> return (toUpper c)
14:11:06 <lambdabot>   "FOOBARBAZ"
14:11:14 <mauke> lists like to run it multiple times :-)
14:11:22 <___> @src [] >>=
14:11:23 <lambdabot> Source not found. Maybe you made a typo?
14:11:27 <___> @src Maybe >>=
14:11:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
14:11:33 <flazz_> but maybe doesnt
14:11:44 <mauke> maybe runs it 1 or 0 times
14:11:48 <___> @src [] (>>=)
14:11:48 <lambdabot> xs >>= f     = concatMap f xs
14:11:52 <___> @src Maybe (>>=)
14:11:53 <lambdabot> (Just x) >>= k      = k x
14:11:53 <lambdabot> Nothing  >>= _      = Nothing
14:11:56 <mauke> (Maybe is like a list of at most one element)
14:12:29 <flazz_> yep
14:12:47 <flazz_> but if there is a statement that is Nothing the rest of it wont matter
14:13:06 <BMeph> flazz_: Ah, but what's Nothing? ;)
14:13:15 <flazz_> a Value constructor :)
14:13:24 <mauke> data What a = No; instance Monad What where { return _ = No; No >>= _ = No }
14:13:36 <vixey> lol
14:13:43 <vixey> best monad ever
14:14:20 <c_wraith> Looks efficient!
14:14:47 <bavardage> what's the correct way to put together pure and monadic functions
14:15:00 <canadaduane> I have a data type "GameObject" that includes a foreign (i.e. C) data type.  The C data type has to be instantiated but that makes it so my "GameObject" cannot exist without side effects.  Is there a way to fix that?
14:15:01 <vixey> bavardage: anything that typechecks is fine
14:15:36 <pumpkin> @remember mauke data What a = No; instance Monad What where { return _ = No; No >>= _ = No }
14:15:36 <lambdabot> It is stored.
14:15:39 <bavardage> now' <- getZonedTime now <- return $ zonedTimeToLocalTime now'
14:15:54 <bavardage> (there should be a newline in between getZonedTime and now)
14:15:58 <bavardage> how do I put those together
14:16:00 <mauke> bavardage: let now = zonedTimeToLocalTime now'
14:16:17 <mauke> now <- liftM zonedTimeToLocalTime getZonedTime
14:16:28 <bavardage> oh kk
14:16:34 <___> @src liftM
14:16:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
14:16:40 <bavardage> ooh kk
14:16:43 <vixey> now <- zonedTimeToLocalTime . getZonedTime
14:16:52 <vixey> that's what I use with (.) = fmap
14:16:53 <mauke> where (.) = fmap
14:16:56 <mauke> :-)
14:17:07 <bavardage> @src fmap
14:17:08 <lambdabot> Source not found. You type like i drive.
14:17:16 <mauke> @src Maybe fmap
14:17:17 <lambdabot> fmap _ Nothing       = Nothing
14:17:17 <lambdabot> fmap f (Just a)      = Just (f a)
14:17:33 <mauke> @src [] fmap
14:17:33 <lambdabot> fmap = map
14:17:37 <___> fmap is another name for liftM, or should be anyway.
14:17:41 <vixey> (f :: a -> b) . (io :: IO a) :: IO b
14:17:44 <bavardage> oh kk
14:17:45 <Samy> ___, why?
14:17:47 <Samy> :t liftM
14:17:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:17:49 <Samy> :t fmap
14:17:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:18:00 <bavardage> fmap is less specific then
14:18:02 <Samy> Yes.
14:18:14 <bavardage> so yeah, any benefit of liftM over fmap?
14:18:20 <mauke> bavardage: not really
14:18:33 <___> generally, it seems wrong to give incompatible Monad and Functor instances for your types.
14:18:53 <___> Monad ought to inherit Functor, but it does not for historical reasons.
14:19:24 <mauke> you win 3 type hackery points if you can see how (.) is the same as fmap
14:19:31 <___> bavardage: no difference, save for an extra typeclass context in your types.
14:19:48 <bavardage> oh right, I thought Monad did derive functor
14:19:51 <bavardage> bleh
14:20:02 <bavardage> can't they say 'screw historical reasons'?
14:20:06 <___> mauke: That would require one to be familiar with Monad ((->) r).
14:20:11 <vixey> (f :: a -> b) . (io :: e-> a) :: e-> b
14:20:17 <mauke> it's all part of the learnings
14:20:30 <mauke> ___: not really, actually
14:20:38 <mauke> you don't need the monadic parts for fmap
14:20:55 <___> s/Monad/Functor/, then.
14:21:09 <AnalogHole> mauke: FYI, I have found what looks like an FRP implementation of GLUT. Reactive-GLUT
14:21:17 <mauke> cool
14:21:50 <AnalogHole> I have no idea how usable it is yet, but it is worth a look.
14:21:54 <kadaver> and where are the compiled ghc libs?
14:23:54 <MyCatVerbs> kadaver: type "cat `which ghc`" into a terminal.
14:24:20 <MyCatVerbs> kadaver: it's a shell script. The directory mentioned in that shell script is where the Haskell libraries and binaries have been installed.
14:24:44 <MyCatVerbs> Usually it's something like /usr/lib/ghc-6.10.1/
14:24:51 <AnalogHole> why in the world would you want to cat the ghc binary into a terminal?
14:25:06 <mauke> "it's a shell script"
14:25:11 <Heffalump> hi augustss
14:25:15 <AnalogHole> Oh :)
14:25:25 <MyCatVerbs> AnalogHole: "file `which ghc`" if you don't trust me. ;D
14:26:45 <bavardage> oh nice
14:26:57 <bavardage> also means you can do
14:27:01 <bavardage> ghc --interactive
14:27:06 <bavardage> no clue why you'd want to.. but :P
14:28:53 <dons> a quick intro to DPH, useful , http://www.reddit.com/r/programming/comments/8bcdu/getting_started_with_data_parallel_haskell/
14:36:37 <pcc1> why may I be getting an error like this: "Couldn't match expected type `a -> a' against inferred type `forall a1. a1 -> a1'" aren't they the same type?
14:37:03 <kerlo> pcc1: well, one has a forall in it, the other doesn't.
14:37:14 <skorpan> pcc1: i don't suppose there are rank 2 types involved?
14:37:31 <kerlo> I'm guessing your code looks something like this:
14:39:02 <pcc1> let me show you my code:
14:39:03 <kerlo> f :: (forall a1. a1 -> a1) -> String; f x = x "blah"; g :: (a -> a) -> String; g x = f x; h :: Int -> Int; main = print (g h)
14:39:25 <kerlo> ...and h x = x + 1
14:39:40 <kerlo> h and main aren't actually part of it, but they demonstrate the problem.
14:39:59 <mauke> yeah, g is invalid
14:40:23 <mauke> wait
14:41:14 <vixey> @type let f :: (forall a1. a1 -> a1) -> String; f x = x "blah"; g :: (a -> a) -> String; g x = f x; h :: Int -> Int; main = print (g h) in main
14:41:15 <lambdabot>     Misplaced type signature: h :: Int -> Int
14:41:15 <lambdabot>     You cannot give a type signature for an imported value
14:41:27 <vixey> @type let f :: (forall a1. a1 -> a1) -> String; f x = x "blah"; g :: (a -> a) -> String; g x = f x; h :: Int -> Int; h = id ; main = print (g h) in main
14:41:28 <lambdabot>     Couldn't match expected type `a1' against inferred type `a'
14:41:28 <lambdabot>       `a1' is a rigid type variable bound by
14:41:28 <lambdabot>            the polymorphic type `forall a1. a1 -> a1' at <interactive>:1:89
14:41:48 <kerlo> Interesting.
14:48:34 <pcc1> problem solved, thanks anyway (it was solved by foregoing built-in functions for my own implementation)
14:55:18 <w0rth> hah i'm still here
15:01:43 <___> @compose elite protontorpedo
15:01:44 <lambdabot> |-|ErE Iz0rz TH3 BIg oN3: iz IT Mr03 pR(tical th4N 5Ay PyThON?
15:02:44 <dolio> He really had a one-track mind.
15:03:48 <dolio> @keal
15:03:48 <lambdabot> obviously you never heard of Tier. theoretically it would work using nanobots
15:05:35 <vixey> @kael
15:05:35 <lambdabot> Maybe you meant: babel keal
15:05:37 <vixey> @keal
15:05:38 <lambdabot> proofs are no longer sound
15:05:41 <vixey> @keal
15:05:41 <lambdabot> can haskell compile flash animations and java apps?
15:06:16 <Deewiant> @faq
15:06:16 <lambdabot> The answer is: Yes! Haskell can do that.
15:06:19 <dmhouse> ?keal
15:06:19 <lambdabot> T could perform expressions 600mb and bigger
15:06:24 <dmhouse> I love the keal quotes
15:06:53 <Saizan> was he the same person as @protontorpedo?
15:07:05 <vixey> @protontorpeda
15:07:05 <lambdabot> how would haskell solve the following gnarley problem: many client distributed accross the usa, transfers must take palce in the form of file transfer, and data must be read from files, and recorded,
15:07:05 <lambdabot>  then other partners who apply taxes to this data and then give abck new files with taxes aded, then last transers to 4th parties who get us paid for the phone calls that are the product
15:07:06 <dmhouse> Don't think so...
15:07:11 <kadaver> if insert is O(log N) and M items need to be inserteddo you say O(M log N) then`?
15:07:17 <vixey> I thought protontorpedo is gavino
15:07:58 <kadaver> O(M log N), and if toList is O(M) then it is O(M + M log N)?
15:08:17 <kadaver> which is O(M log N)?
15:08:29 <Baughn_> Yes
15:08:43 <Baughn_> Mind you, chances are you can insert multiple items in less than O(M log N) time
15:08:47 <Saizan> well, you can have M = N there
15:09:17 <vixey> what's the complexity of merging two trees
15:09:21 <dmhouse> Quotes: http://code.haskell.org/lambdabot/Plugin/Quote/Text.hs
15:09:23 <Saizan> N gradually becomes M while you start from an empty map and insert M elements in it
15:09:30 <Baughn_> vixey: O(min(M,N)) is fairly typical
15:09:35 <Baughn_> But of course it depends on the tree style
15:09:49 <dmhouse> I recommend looking up the logs from the dates mentioned near keal's section as well, they're almost funnier in context
15:09:56 <Cale> Keal was way less sane than protontorpedo.
15:10:15 <Cale> protontorpedo was just a troll
15:10:23 <dmhouse> ?keal
15:10:23 <lambdabot> Keal angry @ dons
15:10:26 <dmhouse> ?keal
15:10:26 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
15:10:31 <bavardage> any ideas how I can maintain transparency when using a backing pixmap instead of drawing to the drawablearea directly with cairo?
15:10:32 <Baughn_> vixey: Although, on Data.Map it's O(n+m)..
15:10:41 <bavardage> I now draw to a pixmap and copy this with drawDrawable
15:10:56 <bavardage> but this gives a black background, rather than being transparent on the undrawn bits
15:11:12 <dmhouse> keal --"last day i was in my lab i had a diagram which might have removed pi"
15:11:19 <dmhouse> Looks like a genuine crank
15:11:55 <Baughn_> dmhouse: How do you differentiate a crank from a clever troll?
15:12:12 <povman> "It takes care to kill children when killed." - unamb comment
15:12:16 <w0rth> Lets say I define newtype MyMonad a = MyMonad (String -> [(a, String)]). Can someone show me the instance definition for instance Monad MyMonad where...
15:12:24 <dolio> protontorpedo just repeatedly asked about how haskell compared to various languages, and how it was for web apps, if the bot is any indication.
15:14:26 <kadaver> mcv: windows
15:15:07 <mauke> w0rth: unM (MyMonad x) = x; return x = MyMonad (\s -> [(x, s)]); MyMonad mx >>= f = MyMonad (\s -> concatMap (\(x', s') -> unM (f x') s') (mx s))
15:15:11 <mauke> or something like that
15:15:30 <povman> can someone explain what unamb does? i can see that it returns the argument which isn't undefined...
15:16:08 <w0rth> mauke: what's unM?
15:16:17 <mauke> unM (MyMonad x) = x
15:16:22 <w0rth> oh okay
15:16:38 <w0rth> thanks, ill try that
15:17:34 <povman> wow i understand it now
15:17:46 <povman> that's nuts
15:18:04 <kadaver> is there conde in haskell or the you use case?
15:18:31 <mauke> what's a conde?
15:19:41 <Baughn_> CL's cond?
15:19:58 <Baughn_> You can get something similar (if not identical) by using pattern guards
15:20:37 <Baughn_> @pretty case foo of t | bar -> bar'; | baz -> baz'
15:20:37 <lambdabot> "Parse error" at column 36
15:21:35 <mauke> use less ';'
15:21:45 <Baughn_> @pretty case foo of t | bar -> bar' | baz -> baz'
15:21:45 <lambdabot>  case foo of
15:21:46 <lambdabot>      t
15:21:46 <lambdabot>      | bar -> bar'
15:21:46 <lambdabot>      | baz -> baz'
15:21:56 <Baughn_> Righto
15:22:09 <Baughn_> kadaver: Um. You /did/ mean cond, right?
15:33:44 <kadaver> Warning: main:RedBlackTree: could not find link destinations for:
15:33:44 <kadaver>     GHC.Classes.Eq GHC.Show.Show GHC.Classes.Ord Data.Maybe.Maybe GHC.Bool.Bool
15:33:44 <kadaver> GHC.Integer.Internals.Integer
15:33:54 <kadaver> so do I need the path to the compiled libs for that?
15:34:33 <Baughn_> kadaver: More like the path to the documentation. Is your GHC built with documentation?
15:38:09 <kadaver> dont remember, it has a doc dir inside
15:38:25 <Baughn_> kadaver: Did you build GHC yourself
15:38:26 <Baughn_> ?
15:38:48 <kadaver> haddock: Can't find package.conf as C:\ghc\ghc-6.10.1\libraries\doc\inplace-data
15:38:48 <kadaver> dir\package.conf
15:38:48 <Baughn_> In that case, unless you explicitly enable it (and explicitly install it), it won't have documentation. No wonder, then.
15:39:14 <Nafai> 
15:39:19 <Nafai> Sorry
15:42:06 <kadaver> so I have to build from source?
15:43:47 <kadaver> 6.10.2 is out I see so I might as well
15:44:05 <Baughn_> kadaver: Not really, no. The binary distributions also come with documentation.
15:44:19 <Baughn_> kadaver: Well, the only thing I can offer is "works fine on unix" anyway..
15:45:32 <kadaver> but I have to tell the exe to build with docs?
15:45:57 <kadaver> but i do have the docs
15:55:03 <povman> i was told a couple of weeks ago that Reactive is broken atm
15:55:05 <povman> why?
15:55:13 <povman> (i got an edxample going
15:55:54 <Baughn_> Reactive requires quickcheck<2
15:56:02 <Baughn_> Reactive also requires Stream, which requires quickcheck>=2
15:56:10 <PetRat> I'm working through chapter 10 of Real World Haskell...
15:56:23 <Baughn_> It's certainly possible to install, but the cabal dependency checker isn't smart enough to do it on its own right now
15:56:48 <PetRat> It's about parsers. He is giving some examples to motivate the idea of creating a ParseState data type, and the use of a chaining function...
15:57:05 <povman> i cabally installed reactive o_O
15:57:17 <povman> ohhhh i gtg bbl
15:57:45 <kadaver> could the dependency checker be improved(fairly easily)? because from a user-perspective there are things to wish for
15:57:51 <PetRat> Then he defines a parser like this: newtype Parse a = { runParse :: ParseState -> Either String (a, ParseState ) }
15:58:15 <PetRat> (I understand the Either relates to the idea that the parser can return an error string)
15:59:04 <PetRat> My question is: why define it like this, as a structure with a runParse function, rather than just define an alias for Parse.
16:00:30 <Lemmih> PetRat: It compiles to the same thing. Using a newtype just makes the distinction more concrete.
16:00:53 <PetRat> The distinction? Between what and what?
16:01:45 <Lemmih> PetRat: The distinction between (ParseState -> Either ...) and Parse.
16:01:46 <PetRat> Why the structure? Why not newtype Parse a = ParseState -> Either String (a, ParseState )
16:02:04 <PetRat> or is that not syntactically valid?
16:02:08 <Lemmih> PetRat: 'type Parse a = ...' would work as well.
16:02:36 <Lemmih> PetRat: However, with newtype you can hide the implementation details.
16:02:50 <Cale> also, you're allowed to define new instances for the newtype
16:03:05 <Cale> So, for example, you're not stuck with the monad instance for functions here.
16:03:08 <dmhouse_> 21:31:24 <Keal> can haskell pipe the raw irrational megaequation into an analog device
16:03:11 <dmhouse_> I bloody loves these logs.
16:03:18 <PetRat> So the idea is that you can export Parse a without allowing users to run it?
16:04:21 <PetRat> Cale: in what cases are you not allowed to define new instances? With type A =? For instance, if you write type Size = Int, you can't make Size an instance?
16:04:39 <Cale> PetRat: Right.
16:05:01 <Cale> PetRat: Or, even with extensions, writing  instance Foo Size  will be the same as writing  instance Foo Int
16:05:15 <Cale> They're treated as the same type by the type system in that case.
16:05:27 <PetRat> Is it possible to export Parse without exporting its constructor?
16:05:35 <Cale> newtype defines a properly separate type, which just happens to be isomorphic to an existing type
16:05:40 <Cale> yes
16:05:48 <Cale> and that's also a common trick
16:06:39 <PetRat> Because it has a single constructor named Parse, what does the module statement look like?  module MyParsers ( Parse ) where
16:06:49 <PetRat> Does that not export the constructor?
16:08:00 <Lemmih> PetRat: Correct, that will not export the constructor.
16:08:03 <Cale> It doesn't export the constructor.
16:08:30 <Cale> If you want to export the constructors, you write something like  module MyParsers (Parse (..)) where ...
16:08:43 <Cale> Or, explicitly list them:
16:08:49 <PetRat> I see..
16:08:52 <Cale> module MyParsers (Parse (Parse)) where ...
16:09:21 <PetRat> Okay thanks guys Cale++ Lemmih++
16:14:10 <mmorrow> @seen pumpkin
16:14:10 <lambdabot> I saw pumpkin leaving #haskell.it, #haskell-in-depth, #haskell-overflow, #haskell, #ghc and #haskell-blah 1h 55m 3s ago, and .
16:14:31 <dobblego> pointed functor is pure + fmap right?
16:14:53 <Saizan__> yup
16:16:24 <Saizan__> mmorrow: do you happen to know how to calculate the size of a datastructure in memory? (vaguely related to what vacuum does)
16:17:00 <Heffalump> didn't Simon Marlow post something about that?
16:18:06 <mmorrow> Saizan__: the way that i know of to do this is to get its closure data by one means or another (vacuum exports `getClosure', which uses GHC.Prim.unpackClosure#), which gives you the numbers (ptrs,nonptrs) (where nonptr := sizeOf(Int))
16:18:19 <mmorrow> Saizan__: that's on my list to add to vacuum
16:18:24 <mmorrow> Heffalump: yes
16:18:49 <mmorrow> Heffalump: though he doesn't walk the graph and total the size
16:19:56 <stulli> So Catamorphisms are some kind of mathematical description of recursion? Did i get that right?
16:20:13 <Heffalump> stulli: of structural recursion
16:20:15 <mmorrow> dons has a file in this new tuple package somewhere (it's not in a pkg module) with JaffaCake's code
16:20:40 <mmorrow> (and there's the blog post with it too somewhere)
16:20:50 <kadaver> so whatsthe license for ghc? can i fork it?
16:20:57 <mmorrow> kadaver: yes
16:21:15 <skorpan> are you planning to? :)
16:21:17 <mmorrow> darcs get --partial http://darcs.haskell.org/ghc
16:22:24 <Saizan__> ah, yeah, i found the post, mine is just a tree so i can walk down it normally
16:22:43 <mmorrow> Saizan__: also you'll want to take into account the header
16:23:16 <mmorrow> (which is just the (Ptr StgInfoTable) i think)
16:24:08 <mmorrow> you might want to look at ghc/includes/*Closure*.h and InfoTables.h if you care enough
16:24:42 <stulli> Heffalump: Thanks for clarifying, im just looking up structural recursion :)
16:25:39 <kadaver> tinyghc
16:26:45 <kadaver> im gonna fork  ghc,call it -the-new-lisp- and sell it.
16:27:13 <shapr> Didn't that happen with BlueSpec?
16:28:33 <mmorrow> kadaver: have you looked at the code yet?
16:30:26 * mmorrow is not sure what would be harder: writing a compiler from scratch or morphing ghc (15+ years being developed, extended, patched, ..) into the compiler you want
16:30:31 * Saizan__ wants a paramorphism deriver
16:30:58 <mmorrow> Saizan__: ooh, what would that look like?
16:31:09 <mmorrow> say for []
16:31:52 <mmorrow> para f (x:xs) = f x xs (\ys -> para f ys) ?
16:31:53 <Saizan__> mmorrow: you also get the whole list at that point, instead of only the recursive reduction
16:32:00 <mmorrow> nice
16:32:45 <mmorrow> that would be interesting to have a deriver for an arbitrary datatype
16:33:06 <Saizan__> fac is an instance of a paramorphism for Nat
16:33:16 <mmorrow> it'd probably look pretty cool when you start running it over datatypes with like 40 constructors
16:34:12 <Saizan__> it's not that different from foldr
16:34:41 <kadaver> has there ever been a functionallanguage without garbage cllection?
16:34:52 <dons> implemented without a GC? yes.
16:35:09 <kadaver> mmorrow: which code?
16:35:54 <kadaver> dons: wouldnt that be a huge pita? do you allocate and free memory in each function?
16:36:29 <p_l> kadaver: depends how you organize your language, I guess
16:36:51 <mmorrow> one thing i've tried to work out (with varying amounts of effort at various points) is to start with a datatype A and a deriver for the (non-recursive) fold of an arbitrary datatype. then (using reify) find all datatypes reachable from A, compute the SCCs of this graph, then for the connected component A is in, use that non-recursive fold to derive a recursive traversal of (equivalently, starting at any type in) that component
16:37:35 <Heffalump> mmorrow: what are the difficulties beyond your description?
16:37:43 <mmorrow> i'm to the point where i can get the SCC and i have the non-rec fold deriver, but i'm not sure how to construct the traversal function
16:38:03 <gwern> kadaver: region inference languages, I understand, do that for you, and linear types come into it somehow
16:38:44 <Heffalump> it just follows the datatype, doesn't it?
16:38:45 <mmorrow> not sure in the sense that i'm not sure what it would actually do/what it would look like
16:39:19 <Heffalump> do you mean that you don't know how to write a mutually recursive fold, or am I misunderstanding?
16:39:39 <mmorrow> Heffalump: i think, but i think i've lost sight of what i was originally trying to do, then i ask myself "what was i originally trying to do?" and i'm like "crap"
16:39:56 <mmorrow> Heffalump: no no, that's exactly it
16:40:29 <Heffalump> hpaste an example type and I'll show you how to do the fold
16:40:30 <mmorrow> so this would be super useful with ASTs
16:40:44 <mmorrow> Heffalump: ok, give me a second
16:43:57 <mmorrow> (where it starts to get weird/design-decisiony (??) is when you want to have different fold strategies (bottom-up, top-down, ?) + sometimes a type B reachable from A means two different things depending on the context it appears in, so how do you hand this? etc..)
16:45:35 <Heffalump> by fold, I mean catamorphism
16:45:52 <Heffalump> if you want more complex traversal strategies, that's trickier
16:46:05 <Heffalump> (catamorphisms are implicitly bottom up, modulo laziness)
16:46:11 <Saizan__> i don't see the problem with mutually recursive types, i don't expect the fold for one type to be "spliced" in the folds of all the types that mention it
16:46:33 <Heffalump> you'd expect a mutually recursive fold function from a mutually recursive type
16:46:41 <Heffalump> otherwise your fold won't get very far
16:47:20 <mmorrow> that's what i'm going for (traversal strategies), but i need to work out the (mechanical) derivation of the mutually rec fold first
16:47:25 * mmorrow gathers code to paste
16:48:03 <mmorrow> Saizan__: that's what i'm going for though
16:48:38 <mmorrow> so maybe here i shouldn't be calling it a "fold" (maybe i should, i dunno)
16:49:05 <mmorrow> like say you have Exp,Stmt,Dec,Type,Name,Maybe,[],(,,,),Int  in a connected component
16:49:16 <mmorrow> err sorry
16:49:36 <mmorrow> i'm considering connected component + every type reachable directly from any member thereof
16:49:57 <mmorrow> so then you have all the info to walk around the CC
16:50:06 <mmorrow> and collect all Names (e.g.)
16:50:18 <mmorrow> or (Name -> Name) or something
16:51:10 <kadaver> sum $ filter isnt lazy rgiht?
16:51:25 <skorpan> @src sum
16:51:25 <lambdabot> sum = foldl (+) 0
16:51:30 <skorpan> foldl can't be lazy iirc
16:51:42 <skorpan> (maybe that's not the real source though)
16:51:54 <Saizan__> well, you can't lazily sum all the elements in a list..
16:52:27 <Saizan__> unless some of them represent infinity or similar
16:52:32 <skorpan> Saizan__: yeah, but maybe if he used that expression inside of another expression which somehow would make it lazy?  i'm not sure what i'm talking about.
16:52:46 <skorpan> e.g. 5 < sum (filter something [1..])
16:53:25 <Saizan__> it won't magically "fuse" the comparison inside the sum loop
16:53:41 <skorpan> okay then, because that's what i had in mind
16:53:47 <MyCatVerbs> skorpan: foldl forces the entire list spine when you try to evaluate anything calculated with it.
16:54:03 <skorpan> MyCatVerbs: yes, but i figured that maybe my example would be lazy if sum itself was lazy
16:54:12 <skorpan> but uh.. that makes no sense.
16:54:15 <skorpan> disregard me!
16:54:37 <Saizan__> that works if you use foldr and a lazy number type, like data Nat = Zero | Succ Nat
16:54:49 <skorpan> right, i remember having this discussion before
16:55:03 <Saizan__> yeah, it's a recurring one :)
16:55:25 <skorpan> hm... not being all that into strictness and everything, what about "data Nat = Zero | Succ !Nat"?
16:55:55 <skorpan> i guess that would somehow "force evaluation" of the natural number in the Succ?
16:56:02 <Saizan__> that won't work
16:56:03 <Saizan__> yeah
16:56:30 <skorpan> hm... "data Hello = World"
16:56:34 <skorpan> that
16:56:38 <skorpan> that's already strict, right?
16:57:02 <mmorrow> Heffalump, Saizan__: here are some graphviz graphs of the reachables and SCCs(+directly reachable) of some of the TH types (and other misc) http://moonpatio.com/graphs/
16:57:08 <skorpan> or does the terminology not even apply to that?
16:57:14 <mmorrow> while i'm finding all the relevant stuff
16:57:16 <Saizan__> World is not a function, so it can't really be strict
16:57:35 <skorpan> but it can't really be lazy either, right?
16:57:57 <Heffalump> so looking at Type, Type and Ctxt are the SCC?
16:58:16 <Saizan__> if by lazy you mean that you can have a thunk that if forced will evaluate to World then yes, it can
16:58:34 <mmorrow> Heffalump: yes, and you need to know how to deal with Name and Int too
16:58:40 <mmorrow> + Cxt = [Type]
16:58:47 <Heffalump> what are the constructors of Cxt and Type?
16:58:48 <mmorrow> (Cxt is just a typesyn)
16:58:54 <Saizan__> but it must be evaluated before you can pattern match on it, like any other constructor
16:59:07 <skorpan> Saizan__: so let's assume i have f :: Hello; f x = something; <- x doesn't always get evaluated here right?
16:59:19 <skorpan> uh wait
16:59:20 <skorpan> what
16:59:21 <Saizan__> skorpan: right
16:59:27 <Cale> If you have something like  data Foo = Bar Integer, then Bar is not a strict function, in the sense that Bar _|_ is not the same as _|_
16:59:35 <skorpan> that type was incorrect, but you seem to have understood it anyways
16:59:36 <mmorrow> data Type  = ForallT [Name] Cxt Type  | VarT Name  | ConT Name  | TupleT Int  | ArrowT  | ListT  | AppT Type Type
16:59:54 <Heffalump> and type Cxt = [Type] ?
17:00:01 <mmorrow> err, maybe having the Int there is too fine-grained
17:00:05 <mmorrow> Heffalump: yes
17:00:06 <skorpan> oh geez, now the _|_ stuff again... partial order and other stuff i don't fully grasp.
17:00:27 <Heffalump> ok, my confidence that I know how to do this weakened a bit with the appearance of Cxt
17:00:28 <Saizan__> skorpan: you can use undefined instead of _|_
17:00:31 <mmorrow> Heffalump: it's stuff this that i get hung up on
17:00:32 <MyCatVerbs> mmorrow: wouldn't it be TupleT [Type]?
17:00:42 <mmorrow> Heffalump: exactly! [] and Maybes are soooo annoying
17:00:55 <skorpan> Saizan__: i remember reading some thread at the caf about whether or not () is _|_ in haskell.
17:00:56 <Heffalump> but it should just be a case of writing a foldr
17:01:01 <mmorrow> , [t|(,,,,)|]
17:01:03 <lunabot>  luna: `(,,,,)' is not applied to enough type arguments
17:01:12 <Saizan__> IOW: const () (undefined :: A) == () regardless of which A you choose
17:01:14 <Heffalump> so, the fold, once given all its HOF parameters, will be Type -> a
17:01:16 <mmorrow> , [t|forall a b. (,,) a b|]
17:01:17 <lunabot>  luna: `(,,) a b' is not applied to enough type arguments
17:01:21 <mmorrow> , [t|forall a b. (,) a b|]
17:01:23 <mmorrow> gah
17:01:24 <lunabot>  ForallT [a_0,b_1] [] (AppT (AppT (ConT (,)) (VarT a_0)) (VarT b_1))
17:01:31 <mmorrow> gah
17:01:39 <kadaver> anyone here program in ruby?
17:01:59 <jmcarthur> kadaver, me
17:02:02 <mmorrow> , (TupleT 2 `AppT` ConT ''Int) `AppT` ConT ''()
17:02:03 <jmcarthur> well, used to
17:02:04 <Saizan__> skorpan: that's considering another order, i guess
17:02:04 <lunabot>  AppT (AppT (TupleT 2) (ConT GHC.Types.Int)) (ConT GHC.Unit.())
17:02:20 <skorpan> Saizan__: is it possible not to evaluate strict values, e.g. if we have "data Nat = Zero | Succ !Nat" (strict) and then "f :: Nat -> Nat; f _ = Zero"... will the argument be evaluated there?
17:02:21 <Heffalump> mmorrow: I think there are multiple ways to deal with it, but lets go with the foldr one as that's easy to transfer to other types like Maybe.
17:02:32 <mmorrow> Heffalump: ah yes, i have a deriver for that kind of fold
17:02:40 <mmorrow> cool
17:02:45 * mmorrow pastes code
17:02:58 <Baughn_> skorpan: Nope. The ADT element is strict, sure, but the ADT as a whole isn't.
17:03:16 <skorpan> Baughn_: so what about "f (Succ _) = Zero"?
17:03:19 <Saizan__> skorpan: no, you still need to pattern match on it, the ! only means that pattern matchin on (Succ x) also evaluates x
17:03:33 <Baughn_> skorpan: Then it gets forced.
17:03:43 <skorpan> i see
17:04:03 <jmcarthur> i like to explain laziness and strictness in terms of streams and vectors
17:04:27 <jmcarthur> data Stream a = Cons !a (Stream a); data Vector a = Vector !a !a !a
17:04:58 <ManateeLazyCat> skorpan: Haskell emacser?
17:05:07 <jmcarthur> the former is really a control structure in disguise. the latter is what we are used to as a data structure to just store values
17:05:12 <skorpan> ManateeLazyCat: yup :)
17:05:39 <mmorrow> Heffalump: ok, part one: here's a paste with the code to reify recursively all reachable nodes from a type and get SCCs etc http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1149
17:05:49 <ManateeLazyCat> skorpan: Haskell is different language.... :)
17:06:01 <jmcarthur> matching (Cons _ _) will force the head of the stream
17:06:07 <skorpan> ManateeLazyCat: yeah, but it's also the most interesting language i've used!
17:06:13 <jmcarthur> mathing (Vector _ _ _) will force all three elements of the vector
17:06:19 <mmorrow> Heffalump: that pastes from a while ago, but that code has only really changed cosmetically
17:06:51 <mmorrow> Heffalump: (that's what generated those .png's)
17:06:52 <ManateeLazyCat> skorpan: Yes, i explore in it, and it's a beautiful language.
17:07:22 <Heffalump> ok, so I'm a bit confused about what you mean about having a deriver - can you make a recursive fold for Type or not?
17:08:21 <skorpan> ManateeLazyCat: lisp is like a wall of graffiti, haskell is like mosaic... they're difficult to understand in the beginning, but for different reasons.
17:09:15 <ManateeLazyCat> skorpan: I agree, i need change my programming thinking when i use Haskell.
17:11:13 <mmorrow> Heffalump: ok, and here's the Fold generator + its output on TH.Exp http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2076
17:12:00 <monochrom> http://www.vex.net/~trebla/haskell/strict-field.xhtml  is also about ! in data declarations.
17:13:02 <mmorrow> Heffalump: i'm starting to think that "fold" is a bad choice of words.. well, actually i'm starting to wonder what it is exactly i'm after. basically, i want some quick-and-automated way to make my life simple! ;)
17:13:06 <Heffalump> can you show me the output on Type?
17:13:11 <mmorrow> one sec
17:13:22 <Heffalump> mmorrow: why not use some of the standard traversal infrastructure like Compos, SYB or Uniplate?
17:13:28 <Heffalump> it sounds closer to what you actually want
17:13:47 <mmorrow> Heffalump: i've been playing around with KURE some too
17:14:16 <mmorrow> but the lack of type families in TH (until last week!) put a wrench in that
17:14:23 <guenni> what does this error message mean: *** Exception: No match in record selector Data
17:15:31 <mmorrow> Heffalump: i think you're right, that really is what i'm after
17:16:01 <mmorrow> Heffalump: Type: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2076#a2080
17:16:53 <mmorrow> Heffalump: but at the same time, i think there's room for improvement in what my fold deriver is doing
17:17:13 <mmorrow> it can only see one level deep, and i feel like it could do more
17:17:17 <mmorrow> i'm just not sure what
17:17:36 <Heffalump> for it to go recursive, replace Type with r_0 in the type sig
17:17:59 <kadaver> dons what lib did you use for hmp3?
17:18:28 <skorpan> kadaver: mpg123/mpg321 iirc if that's what you mean
17:18:44 <mmorrow> Heffalump: do you mean s/Type/r_0/ or vice-versa?
17:18:59 <Heffalump> I mean that where Type is an argument to one of the sub-functions, replace it with r_0
17:19:01 <kadaver> windows
17:19:03 <Heffalump> so s/Type/r_0/
17:19:06 <mmorrow> ahhhh
17:19:28 <mmorrow> ohh, ok. i see it now
17:19:29 <wli> I've never actually looked at SYB or Uniplate.
17:19:44 <Heffalump> for Cxt, you need r_0 -> r_0 -> r_0 and r_0
17:19:50 <Heffalump> to use as arguments to foldr
17:20:03 <Heffalump> or something like that, anyway
17:20:40 <mmorrow> and my "plan" is/was roughly to apply the respective derived fold for each of the types encountered
17:21:16 <Heffalump> that would mean you only ever looked at primitive types when you actually call the fold
17:21:43 <mmorrow> hmm, right
17:21:52 <Heffalump> go for a generic traversal
17:22:01 <Heffalump> folds aren't what you want
17:23:03 * Heffalump is off to bed soon
17:23:50 <mmorrow> yeah, folds don't really seem to fit here
17:24:05 <wli> gmapQ et al I see
17:27:38 <wli> I have to confess that I've never been able to make heads or tails of Data.Generics
17:40:11 <Saizan__> the problem i've with it is that it makes your functions untyped, essentially
17:40:33 <Saizan__> (or dynamically typed, if you prefer)
17:41:04 <Saizan__> and so type signatures of combinators are not that informative either
17:41:33 <Saizan__> but the papers are a good read
17:43:26 * ManateeLazyCat pasted "my code snippets" at http://paste2.org/get/181195
17:43:27 <ManateeLazyCat> I have above code snippets that format "case ... of ... case ... of", have tips make those code more simpler?
17:44:02 <Baughn_> ManateeLazyCat: The Maybe monad
17:44:29 <ManateeLazyCat> Baughn_: How?
17:44:38 <skorpan> >>=
17:45:00 <Baughn_> > do foo <- Just 3; bar <- Just 4; return (foo+bar)
17:45:01 <lambdabot>   Just 7
17:45:06 <Baughn_> > do foo <- Just 3; bar <- Nothing; return (foo+bar)
17:45:08 <lambdabot>   Nothing
17:45:24 <Baughn_> I'm sure you see the relevance now. ;)
17:45:53 <dolio> > (+) <$> Just 3 <*> Just 4
17:45:55 <lambdabot>   Just 7
17:46:02 <skorpan> dolio: well OBVIOUSLY
17:46:27 <Baughn_> dolio: Pity he needs join too
17:47:54 <Baughn_> Hmm. Well, I guess not, actually..
17:48:10 <Baughn_> ManateeLazyCat: Maybe head . catMaybes instead?
17:48:35 <Baughn_> Misread the code snippet. It looks like you're trying a bunch of alternatives and picking the first that succeeds?
17:48:40 <Baughn_> head . catMaybes does that, just about
17:49:03 <dolio> mplus
17:49:11 <Baughn_> Ah yes. That too.
17:49:13 <dolio> > Just 3 `mplus` Just 4
17:49:14 <lambdabot>   Just 3
17:49:30 <Baughn_> > mconcat [Just 3, Just 4]
17:49:31 <lambdabot>   Add a type signature
17:49:36 <Baughn_> > mconcat [Just 3, Just 4] :: Just Int
17:49:37 <lambdabot>   Not in scope: type constructor or class `Just'
17:49:44 <wli> Hmm. There needs to be a stack in addition to a worklist so picking a particular item to do from the worklist can be respected.
17:49:46 <Baughn_> hmm. Wait..
17:49:51 <dolio> msum is the mplus one.
17:49:54 <Baughn_> Right
17:49:54 <dev31212> Hi, anyone know what ExitFailure 9 refers to when installing a cabal package?
17:49:56 <dolio> mconcat is from monoid.
17:50:28 <Baughn_> > msum [Nothing, Just 4, Just 3] -- ManateeLazyCat: Like that, then.
17:50:30 <lambdabot>   Just 4
17:50:42 <MyCatVerbs> dev31212: it means that some external program that Cabal tried to call failed with exit code 9.
17:50:53 <dev31212> ok, thanks
17:51:10 <MyCatVerbs> dev31212: I presume that this was in the "configure" stage?
17:51:20 <Baughn_> @src Monoid
17:51:21 <lambdabot> class Monoid a where
17:51:21 <lambdabot>     mempty  :: a
17:51:21 <lambdabot>     mappend :: a -> a -> a
17:51:21 <lambdabot>     mconcat :: [a] -> a
17:51:45 <Baughn_> Still, having both Monoid and MonadPlus seems very.. arbitrary
17:51:56 <dev31212> um actually it came upon "cabal install" when building leksah
17:51:59 <ManateeLazyCat> Baughn_: Thanks, i try.
17:52:03 <dev31212> maybe I skipped a step...hmm
17:52:05 <Baughn_> @src MonadPlus
17:52:06 <lambdabot> Source not found.
17:53:00 <wli> I'm not sure if monoids are more general than MonadPlus or not.
17:53:03 <Baughn_> dolio: I mean, why aren't they just Monoid1 and Monoid2?
17:53:47 <Baughn_> wli: MonadPlus has an added monad constraint, for whatever reason. Besides that they're identical, so..
17:53:57 <dolio> Instances of MonadPlus are required to implement their functions such that they interact a certain way with the functions from Monad.
17:55:00 <Baughn_> There is that, I suppose
17:55:18 <dev31212> rebooting ubuntu, ill say if it works or not after I try again
17:55:52 <dolio> Also, MonadPlus is a constructor class where instances must be monoids regardless of what type they're applied to.
17:55:56 <travisbrady> how critical is understanding Monoids to being a good Haskell programmer?
17:56:00 <dolio> There's no way to write a type like that with Monoid, I think.
17:56:20 <Baughn_> travisbrady: As critical as all the other standard typeclasses. They're very handy.
17:56:24 <dolio> "forall a. Monoid (m a)" is not a valid class context.
17:56:33 <Baughn_> travisbrady: Read the typeclassopedia, and you'll know about all the major ones
17:56:40 <travisbrady> Baughn_: really?  as important as Monad and Functor?
17:56:53 <Baughn_> travisbrady: Hardly
17:56:55 <travisbrady> Baughn_: i actually did read it but it was a bit formal for me
17:57:05 <Baughn_> travisbrady: But you /will/ see people using it, so you need to understand how it works
17:57:48 <dolio> travisbrady: From a general enough category theoretic point of view, monads are monoids. :)
17:58:21 <Baughn_> travisbrady: Oh yes. By what reasoning is the Functor instance for (a->) the correct one? ;"
17:58:49 <dev31212> MyCatverbs, turned out I forgot to run with "sudo"
17:58:51 <dev31212> =p
17:58:59 <dev31212> thanks
17:59:13 <travisbrady> yes, i'm friendlier with things like "here's what you'd want to do with a $x"
17:59:31 <dobblego> Monoid is far easier to understand than Monad + Functor
17:59:59 <MyCatVerbs> dev31212: ah! Heh. Sorry for the lack of response. This channel is fairly active, and you didn't trigger my highlight, so...
17:59:59 <Baughn_> dobblego: 'specially since you're missing Applicative from the middle there
18:00:08 <dev31212> nah its ok, thanks for listening.
18:00:55 <travisbrady> "a monoid is a type with a rule for how two elements of that type can be combined to make another element of the same type" <-- makes them seem very simple to me, but as usual with haskell i get intimidated by the nomenclature
18:01:24 <dolio> They are quite simple.
18:01:35 <dobblego> travisbrady, Monoid is so simple, it can be expressed in Java/C# type system -- have you used either language?
18:01:50 <travisbrady> so list is a monoid? Int?
18:01:55 <Baughn_> travisbrady: That's what they are. That's /all/ they are, which is why it isn't called Appendable or something - that would imply nonexistent structure.
18:02:02 <travisbrady> dobblego: i have yes, python mostly
18:02:04 <dobblego> (++) and [] forms a monoid
18:02:12 <Baughn_> travisbrady: Int is a monoid in two different ways, yes. :)
18:02:22 <dobblego> (+) and 0 forms a monoid
18:02:23 <Baughn_> > (Sum 4) `mappend` (Sum 5)
18:02:24 <lambdabot>   Sum {getSum = 9}
18:02:31 <Baughn_> > (Product 4) `mappend` (Product 5)
18:02:32 <lambdabot>   Product {getProduct = 20}
18:02:40 <travisbrady> Baughn_: ok, i'm partly curious now because the Bay area haskell talk is tonight and it's Dan Piponi on Monoids
18:02:47 <dobblego> interface Monoid<A> { A append(A a1, A a2); A zero() } // must satisfy identity + associativity
18:03:10 <dobblego> new Monoid<List<A>> { append = (++); zero = [] }
18:04:53 <Baughn_> travisbrady: Anyway, when you run into a strange and scary name in haskell - Monoid, Monad, Arrow, Applicative - chances are it's not using a more descriptive name because it's /simpler/ than what the more descriptive name would describe. Not more complex.
18:05:01 <dolio> Mmm, anonymous classes.
18:05:28 <Baughn_> travisbrady: Like, say, the monoid instance for lists appends - but there's no restriction in the monoid definition that it must work only for append-like functions
18:05:44 <travisbrady> good to know thank you, Arrow I've still not wrapped my head around, though I've used *** and &&&
18:06:04 <dolio> Nobody really uses arrows for anything but that. :)
18:06:18 <bremner> dolio: hxt
18:06:56 <travisbrady> haha, that's a hurdle for me with Haskell, i've written useful code, but i'm always thinking "i still don't understand most of the language, i'll be a noob forever"
18:13:27 <dolio> bos is no longer elite.
18:13:32 <Nafai> uh oh
18:14:03 * dolio downloads a garbage file from bos' computer.
18:14:08 <shapr> hmm
18:14:28 <idnar> bos uses a gibson?!
18:19:12 <kadaver>  foldr (\x y -> sum x + y) 0 [[1..10]]
18:19:22 <kadaver> can that be witten without the lambda?
18:19:41 <kadaver> > foldr ((+) . sum) 0 [1..10]
18:19:42 <lambdabot>       No instance for (Enum [a])
18:19:42 <lambdabot>        arising from the arithmetic sequence ...
18:19:46 <kadaver> > foldl ((+) . sum) 0 [1..10]
18:19:48 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
18:19:48 <lambdabot>        Expect...
18:19:51 <dobblego> @pl \x y -> sum x + y
18:19:51 <lambdabot> (+) . sum
18:20:06 <kadaver> which is what i dod...
18:20:09 <kadaver> did
18:20:22 <kadaver> > foldl ((+) . sum) 0 [[1..10]]
18:20:23 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
18:20:23 <lambdabot>        Expect...
18:20:27 <kadaver> duh
18:20:31 <kadaver> > foldlr ((+) . sum) 0 [[1..10]]
18:20:32 <lambdabot>   Not in scope: `foldlr'
18:20:36 <kadaver> > foldr ((+) . sum) 0 [[1..10]]
18:20:37 <lambdabot>   55
18:20:58 <bos> dolio: ?
18:21:15 <kadaver> @pl \x y -> x*x + y*y
18:21:15 <lambdabot> (. join (*)) . (+) . join (*)
18:21:26 <kadaver> @quote SPJ
18:21:26 <lambdabot> SPJ says: will be a legend after his death
18:21:27 <skorpan> @src join
18:21:27 <lambdabot> join x =  x >>= id
18:21:30 <kadaver> @quote SPJ
18:21:30 <lambdabot> SPJ says: will be a legend after his death
18:21:34 <kadaver> @quote dons
18:21:34 <lambdabot> dons says: Those who would give up essential type safety, to purchase a little liberty, deserve neither liberty nor type safety.
18:21:42 <kadaver> @quote dons
18:21:42 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
18:21:42 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:21:48 <dolio> bos: Nothing in particular. Sorry if I bothered you.
18:21:48 <skorpan> @quote kadaver
18:21:48 <lambdabot> No quotes match.
18:22:11 <kadaver> @quote skorpan
18:22:11 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
18:22:11 <bos> no prob
18:22:16 <kadaver> @quote skorpan
18:22:16 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
18:22:22 <dolio> You'd just taken the 31337 off your name.
18:22:23 <kadaver> @quote Cale
18:22:23 <lambdabot> Cale says: Woo! Lambda Calculus and lots of pretty colours!
18:22:26 <bos> kadaver: can you ask for quotes in privmsg, please?
18:22:29 <kadaver> @quote Cale
18:22:29 <lambdabot> Cale says: The perfect programming language is mathematics, but that only runs on mathematicians.
18:22:57 <kadaver> i love compsci but im afraid there are no women in the courses
18:22:59 <kadaver> ?
18:23:06 <TehZorroness> I'm looking into writing a synthesizer in haskell to take advantage of all sorts of fun things like function composition ect...
18:23:21 <Cale> Wait, I don't remember saying the pretty colours quote.
18:23:22 <TehZorroness> is there a good simple stable sound library I can use?
18:23:25 <Nafai> TehZorroness: Cool!
18:24:30 <TehZorroness> Nafai, don't get too excited, I'm not quite a seasoned haskell veteran yet :)
18:24:58 <Nafai> I'm not either, but it's a cool idea :)
18:26:42 <gwern> kadaver: well, how else can one go 'study' with a chick?
18:27:35 <ManateeLazyCat> Nafai: Hi.
18:29:15 <Nafai> Hi ManateeLazyCat
18:30:30 <ManateeLazyCat> Nafai: Last see you in dream... :)
18:31:45 <Nafai> Huh?
18:33:11 <ManateeLazyCat> Nafai: Last time concat you in #emacs and #haskell, and then i developing Haskell code auto-complete in Emacs, and so tried, so i complete code in *dream* status, forget?
18:33:21 <Nafai> Oh yeah
18:33:23 <Nafai> Heh
18:33:42 <ManateeLazyCat> s/tired/tried
18:38:51 <kadaver> can you compile 6.10.2 with any 6.x?
18:42:58 <Axman6> kadaver: should be able to. i'd probably recommend 6.6+ though
18:43:18 <kadaver> can you compile 6.10.2 with 6.10.2?
18:44:07 <Axman6> sure
18:44:33 <ivanm> kadaver: note that that's what we do on gentoo all the time
18:45:04 <ivanm> a dev builds a version of ghc using an older version, then the users use that pre-built version to build the same one from source for themselves
18:46:20 <kadaver> ok
18:46:34 <ivanm> so yes, it works ;-)
18:47:24 <kadaver> from __future__ import 7.0
18:47:53 <kadaver> so do you people despise python?
18:48:05 <ivanm> kadaver: ummmm.... wtf?
18:48:23 <ivanm> last I checked, there was no "7.0" option in __future__
18:48:44 * ivanm doesn't "despise" python... it's nicer than Java in many aspects :s
18:49:07 <dolio> That's some high praise.
18:49:12 <ivanm> dolio: heh
18:49:14 <kadaver> from __future__ import i_was_wrong_functional_programming_rocks//guido
18:49:24 <ivanm> kadaver: when did he say that?
18:49:52 <kadaver> april 1st?
18:50:01 <kadaver> he never said that
18:50:04 <ivanm> ahhhh
18:50:51 <dj_ryan> heh
18:52:15 <kadaver> instance ObjectOrientable Haskell where function f = object f
18:55:44 <sebaseba> has anyone had trouble with quickCheck consuming all memory when running a test?
18:57:22 <kadaver> sebaseba: codepaste?
18:57:50 <flazz> is there a way to browse haskell documentation on my local system?
18:59:25 <sebaseba> kadaver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3601#a3601
19:00:14 <sebaseba> when I run quickCheck prop_fromBinarytoBinary it quickly consumes all memory, with no output
19:09:10 <ivanm> flazz: if you install/build the documentation, yes
19:09:25 <ivanm> you can probably download it as well for ghc, but I"m not sure where
19:09:39 <ivanm> (if by "documentation" you mean mean haddock docs)
19:10:01 <flazz> the stuff at hackage.haskell.org
19:10:05 <monochrom> The ghc doc page has tarballs and zip files for download.
19:10:31 <kadaver> sebaseba: mighty weird, jsut calling the function is instant
19:10:41 <sebaseba> kadaver: yep
19:10:44 <kadaver> but using quickCheck it eats up all memory and processor power
19:11:34 <sebaseba> I tried limiting the number generated in the property to < 1000 but didn't help at all
19:12:59 <kadaver> negative numbers
19:13:04 <sebaseba> ah
19:13:16 <sebaseba> duh!
19:14:15 <sebaseba> thanks a bunch
19:15:01 <kadaver> np
19:15:46 <saml> p = np
19:16:08 <performance> depends on reimann hypothesis
19:16:17 <sebaseba> quickCheck (p == np)
19:23:36 <kadaver> *Binary> quickCheck (\s -> "p" == "np")
19:23:36 <kadaver> Falsifiable, after 0 tests:
19:23:36 <kadaver> ()
19:23:36 <kadaver> *Binary>
19:24:01 <kadaver> *Binary> quickCheck (\s -> "p" /= "np")
19:24:01 <kadaver> OK, passed 100 tests.
19:24:24 <ivanm> p and np are Sets though, not Strings...
19:24:44 <tromp_> sets of sets of strings
19:25:05 <ivanm> tromp_: no, sets of problems
19:25:16 <tromp_> that's what i said
19:25:30 <ivanm> tromp_: only if you specify a problem as being a set of strings
19:25:38 <ivanm> which I wouldn't...
19:25:41 <kadaver> those are not strings, it just looke like that
19:25:42 <tromp_> that's standard
19:25:53 <kadaver> " " is the symbol for Set
19:25:59 <kadaver> in 6.10.2
19:26:34 <ivanm> tromp_: can't be a set: in the mathematical sense, ordering is arbitrary (so you can re-arrange the Strings); in the haskellian sense they're ordered alphanumerically (so they probably won't make sense)
19:26:35 <kadaver> "".member "hello" "" -> True
19:26:38 <ivanm> @slap kadaver
19:26:39 <lambdabot> go slap kadaver yourself
19:27:40 <bremner> @slap yourself
19:27:40 * lambdabot slaps yourself with a slab of concrete
19:28:08 <ivanm> kadaver: that looks more like Python than Haskell...
19:29:15 <kadaver> <->
19:29:22 <kadaver> that looks like a starwars ship
19:29:36 <ivanm> *sigh*
19:30:09 <kadaver> what would a Jedi use to program?
19:30:21 <kadaver> gnight
19:30:23 <ivanm> kadaver: first of all, there's no such thing as "Jedis"
19:30:37 <ivanm> why ask the question if he wasn't going to stay around to hear the answer?
19:33:08 <gwern> a Jedi would program in the vaporator language
19:34:17 <orbitz> ivanm: hah
19:35:02 <orbitz> i think i found a program i want to writ ein haskell
19:35:25 <orbitz> i tinvolves a gui though and i hates gui's :(
19:35:53 <Axman6> make an awesoem cli interface
19:36:06 <orbitz> i don't think it iwll work well with CLI
19:36:17 <ivanm> orbitz: that's why I like writing non-interactive apps ;-)
19:36:24 <orbitz> hehe
19:36:25 <ivanm> give it the initial parameters, and let it run!
19:36:51 <orbitz> this program is meant to help memorie molecular structures, so i want it to be where you see the structure and then give the name, and get the name and draw the strucutre
19:37:02 <orbitz> maybe i can come up with some DSL the user can use to draw structures
19:37:17 <ivanm> orbitz: so it's a flash card app?
19:37:34 <orbitz> basically, but specifically for structures
19:38:01 <orbitz> drawing a structure seems to be important in learning it, for me
19:39:07 <orbitz> ivanm: what do you think?
19:39:53 <ivanm> *shrug* unless your program is going to draw the structures from scratch from "first principles", I think you'd be better off using an existing flash card app
19:40:43 <orbitz> i don't know of any flashcard app that lets you draw the structures though
19:40:57 <ivanm> yeah, that was my point
19:41:09 <ivanm> if you were just using pics of them, then I don't think there's anything new
19:41:34 <orbitz> yeah, the problem i find with pics is i just learn the differences between the pics to choose, not the entire strucutre
19:43:03 <ivanm> orbitz: well, from memory there's a java app/lib that generates the diagram, and there's java flashcard apps....
19:43:54 <orbitz> okay
19:47:38 <orbitz> ivanm: well now that you ruined my idea for an app you have to give me a new one
19:49:23 <gwern> ivanm: java? heresy!
19:50:01 <gwern> orbitz: not many flashcard apps would support a gui drawing widget
19:50:31 <orbitz> gwern: the actual drawing doesn't seem very generic thoguh.  i guess it could be useful for drawing graphs
19:50:57 <orbitz> i do need to actually work on a haskell project thouhg, been puttin git of ftoo long
19:51:01 <gwern> it's interesting to try to think of how one would do that
19:51:30 <ivanm> gwern: I'm just saying I _know_ of it
19:51:46 <ivanm> because my brother was employed to work on a website that used this java thing to draw chemical structures
19:52:24 <ivanm> orbitz: as for graph drawing, unless you have some specialised needs I'd leave it to graphviz
19:52:29 <gwern> perhaps there's some way to put up a mini-inkscape window, let the user draw the vector image, and then one can compare the SVG against the stored answer
19:53:28 <gwern> comparing the generated svg against the original is an interesting task all its own, actually. parse them into graphs and see how similar they are?
19:55:37 <orbitz> gwern: simplest method might be to just have nodes and edges and check for isoforms aye?
19:56:27 <gwern> dunno. what's an isoform?
19:57:10 <gwern> although if you can presupply nodes and edges, maybe then gtk2hs could do a drag-and-drop interface?
19:57:12 <orbitz> isoform..isomorph maybe?  a graph with the same 'shape'
19:57:21 <gwern> ah
19:57:57 <orbitz> i think comparing isomorphs is liek n^n problem, but that isnt' THAT bad to bruteforce since as a human i'm not going to have millino sof nodes
20:01:41 <wli> Memoizing the Collatz chain length crud seems to hit 32-bit virtual address space limits in rather short order.
20:04:37 <leloup> quit
20:05:26 <sebaseba> is there a way to throw an exception on overflow?
20:07:07 <wli> Sure. MonadError and wrap all the arithmetic ops.
20:07:23 <wli> newtype or some such.
20:09:08 <sebaseba> say you have some code that uses Int, and you suspect there's an overflow happening somewhere. How do you check that easily?
20:10:43 <c_wraith> sebaseba: if you can easily change it to Integer, you can see if it has different results.
20:12:33 <sebaseba> c_wraith: that's true, I just had a bug because I was using a polymorphic function in two different places, and in one an Int was inferred, in another an Integer...
20:16:43 <wli> STUArray may be required in order to cram it into the minimum space possible.
20:18:19 <orbitz> is the next revision of haskell being workd on?
20:18:37 <dolio> It's due out 3 years ago.
20:18:48 <orbitz> that's no goo
20:18:59 <wli> That's Haskell Prime, not Haskell 2.
20:19:23 <flazz> can a value constructor be used as a function?
20:19:33 <wli> Haskell 2 doesn't even have its name settled on yet, never mind timelines.
20:19:38 <wli> flazz: Yes.
20:20:42 <dolio> Well, clearly Haskell Prime has to come out before Haskell 2.
20:21:07 <orbitz> why is it taking so long?
20:21:12 <flazz> wli: when i do Just.abs it says failed to load interface
20:22:03 <dolio> Apparently people don't sit down and decide things like they used to.
20:22:07 <orbitz> let x = Just in x 4 ==> Just 4
20:22:35 <orbitz> what is Just.abs?
20:22:41 <dolio> Just.abs looks like a qualified name. Function abs in module Just.
20:22:43 <flazz> (Just).abs did it
20:23:03 <dolio> So you need to add spaces 'Just . abs'.
20:23:27 <flazz> maybe it was trying to match against (.)
20:23:39 <orbitz> ohhh
20:23:41 <flazz> hmm
20:23:43 <dolio> Also, some stuff slated to be decided on for H' is probably taking longer than expected.
20:23:45 <lpsmith> orbitz:   I would also guess that GHC pretty much has the command of what Haskell is right now.   Some of the extensions are de-facto standards
20:23:49 <flazz> spaces works too
20:23:50 <flazz> why?
20:24:24 <dolio> Like a fleshed out understanding of type families/associated types, and whether those should be settled on in lieu of functional dependencies.
20:24:26 <lpsmith> And I'm guessing that there just isn't enough interest at the moment, for whatever reason.   Necessity is the mother of invention :-)
20:24:42 <dolio> flazz: Because Just.abs looks like a qualified function name.
20:24:46 <orbitz> lpsmith: i have heard several people complain about various things, like the numeric typeclasses being screwy and some Monadic stuff being poorly designed and wondering if these thing swil be fixed in next release
20:25:19 <dons> ?yow #hhaskell
20:25:20 <lambdabot> Are the STEWED PRUNES still in the HAIR DRYER?
20:25:24 <dons> have we won yet?
20:25:32 <dolio> And the compiler doesn't do fancy stuff like deciding whether there actually is a module Just with function abs in scope before deciding how to parse that expression.
20:25:52 <dolio> Since that'd be even more complicated. :)
20:26:01 <lpsmith> orbitz:  Haskell is far from a perfect language,  but it really is very good.  Most of the complaints are minor compared to the major flaws in most other languages.
20:26:25 <dons> oh no. numeric type classes. we'll have to give up programming with numbers :)
20:26:30 <lpsmith> And yes,  I daresay numeric typeclasses are a prime candidate for revision ;-)
20:26:36 <dons> (yes, minor :)
20:27:00 <orbitz> lpsmith: word, i'm not argugin against it, just curious if that was on the table
20:27:08 <orbitz> or a planned thing ot address
20:27:14 <dons> there's a new numeric prelude you can try
20:27:20 <orbitz> i forget what the monadic complaint was.  maybe MonadPlus being poorly implemented?
20:27:22 <dons> but it breaks pretty much everything, so strictly for fun only.
20:27:26 <dolio> It would probably be ideal to decouple the libraries from the language standard.
20:27:32 <dolio> So that they can be updated more fluidly.
20:27:41 <lpsmith> I don't honestly know.   I haven't been paying attention to the Haskell' effort, honestly.
20:27:45 <dons> there's the small matter of millions of lines of haskell that we shouldn't break
20:27:48 <wli> Not really possible on account of their interactions with language features.
20:28:02 <dolio> Such as?
20:28:19 <dons> hmm. Enum ?
20:28:26 <orbitz> dons: write a progrma that fixes it  like python :)
20:28:48 <dons> i'm not sure really. I think you can funk up the numeric hierarchy without breaking *language* features. libraries however,...
20:28:50 <dolio> Yeah, I guess there's some sugar that depends on libraries.
20:29:07 <dolio> But that's hardly the interesting part of the language definition. :)
20:30:16 <dons> dolio: what are we going to do about world class container structures?
20:30:48 <kerlo> > "free will"
20:30:50 <lambdabot>   "free will"
20:30:54 <wli> Well, Haskell' doesn't really intend to do much.
20:32:49 <dolio> dons: I'm not sure I understand that sentence. Is there some context I haven't seen?
20:32:56 <dolio> Did Jon Harrop make another reddit post?
20:33:25 <w0rth> What does :: do in haskell?
20:33:37 <w0rth> for example, data Comp t = Comp { trans::(State -> (t, State)) }
20:33:39 <ddarius> It separates expressions/names from types.
20:34:12 <w0rth> But in this case it means something else?
20:34:29 <dons> oh, well, just in general, i want really fast, scalable, general purpose containers :)
20:34:36 <orbitz> it means trans has type (State -> (t, State)
20:34:41 <dons> and yeah, jdh is trolling me. he's in love, i think.
20:34:48 <dolio> Oh, yeah, tha'td be good. :)
20:34:54 <orbitz> dolio: do you get an influx of peopel hwen Jon posts?
20:34:54 <wli> Haskell' needs to happen but it's not the sort of thing one should look to for advancing the language etc.
20:34:54 <w0rth> orbitz: but what is trans?
20:35:07 <kerlo> w0rth: well, this is a special case.
20:35:12 <orbitz> w0rth: the name of an element in your record i beleive
20:35:28 <orbitz> dons: haah where do you get trolled?
20:35:30 <kerlo> That is the same, more or less, as "data Comp t = Comp (State -> (t, State)); trans (Comp x) = x"
20:35:34 <dolio> dons: It'd be nice if GHC had facilities for doing that container specialization without type/data families. Which I think sjanssen has mentioned before.
20:35:38 * orbitz reads his pot son ocaml mailing list when need a laugh
20:35:45 <w0rth> kerlo: excellent, that makes sense
20:35:49 <dolio> Having to declare thousands of instances isn't nice.
20:35:56 * dons is not going to link to trolls :)
20:36:12 <orbitz> dons you'r eno fun!
20:36:12 <dons> i had a play with hsjudy today , though.
20:36:15 <dons> underappreciated
20:36:17 <dons> orbitz: :P
20:36:28 <orbitz> is that a judy array impl?
20:36:32 <dons> anyone coming to  the haskell hackathon next week?
20:36:38 <dons> orbitz: a binding to it, yeah
20:36:41 <orbitz> where is it?
20:36:44 <dons> utrecht
20:36:50 <orbitz> i shall not be there
20:37:09 <dons> it's hard organizing a big hackathon in the US.
20:37:18 <dons> so far to travel. europe has the advantage.
20:37:29 * araujo still thinks we need a hackathon in south america
20:37:29 <orbitz> poor public transit!
20:37:53 * sebaseba thinks so too
20:38:14 <wli> araujo: Nice, you're on a bunch of programming language channels.
20:38:27 <dons> araujo is a well travelled hacker
20:38:29 <araujo> wli, hi there, oh, yeah.. a few :)
20:38:39 <araujo> dons, haha, hi there :)
20:38:50 <shapr> araujo: Clearly you should organize one!
20:39:10 <araujo> shapr, haha, I should _seriously_ think about it :P
20:39:14 <shapr> Yes you should!
20:39:16 <araujo> it'd be fun :)
20:39:18 <shapr> I don't want to have to visit!
20:39:21 <ivanm> since ozhaskell didn't happen, how about an oz hackathon?
20:39:25 <araujo> shapr, haha
20:40:03 * araujo thinks something in brazil _could_ work
20:40:10 <shapr> I would really like to visit Brazil.
20:40:25 <shapr> I recently found Elis Regina...
20:40:31 <shapr> And I love capoeira!
20:40:36 <araujo> shapr, yeah?.. hahaha
20:40:40 <shapr> araujo: Ok, where in Brazil?
20:40:55 <shapr> Brazil is not small.
20:41:09 <araujo> shapr, mmm.. I would think .. Sao Paulo , or Rio de Janeiro
20:42:11 <araujo> I just wonder, how much of the european and american guys could make it though ....
20:42:20 <shapr> I'd do my best to show up.
20:42:31 <araujo> shapr, awesome, good to know :)
20:42:45 <shapr> You could figure out what's easiest for the eu/us guys to travel to... and have the hackathon there.
20:42:47 <wli> I don't travel well due to health concerns.
20:43:53 <shapr> I love to travel!
20:44:05 <shapr> I especially want to go to Brazil!
20:44:39 <shapr> Bah, #haskell.br is empty!
20:45:21 <araujo> shapr, I think we have some haskell hackers in .br ....
20:45:40 <araujo> wli, oh, sad to know :(
20:45:51 <shapr> Perhaps they're part of the nokia.br scene?
20:45:58 <sebaseba> araujo: I would definitely show up, live in Curitiba, though my haskell skills are not that great
20:46:00 <shapr> What's the nokia research lab in br? I forget...
20:46:19 <araujo> sebaseba, everybody is (would be) welcome! :)
20:47:09 <sebaseba> shapr: that's in Recife
20:47:15 <shapr> ah
20:48:00 * araujo could make some census around to see if this is a viable idea
20:48:26 <shapr> I have a crazy question, does anyone know if infiniband adapters have a cross-connect mode like ethernet's "swap two pins" ?
20:48:37 <araujo> where is that haskell hacker world map?, the link
20:51:42 <performance> cocobanana :D
20:52:17 <clanehin> With STM, I wonder if it is legitimate to perform a writeTVar in an always clause.  Can I get a counter that is reset to zero at the end of any transaction?
20:52:48 <flazz> is there an alternative to using mapM_?
20:54:17 <ivanm> flazz: what do you want to do?
20:54:40 <ivanm> the obvious alternative is to manually re-implement mapM_ specifically for your mapping function...
20:55:04 <flazz> ivanm: i want to run a do block for every element of a list and not care about the returned value
20:55:14 <ivanm> flazz: well, that's what mapM_ is for
20:55:15 <flazz> i want to loop over a list essentially
20:55:22 <BMeph> flazz: mapM_
20:55:26 <ivanm> @hoogle sequence
20:55:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
20:55:26 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
20:55:26 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
20:55:33 <flazz> ok, just wondering if there was a different syntax for it
20:55:35 <ivanm> BMeph: he asked for _alternatives_ to mapM_ ...
20:55:49 <ivanm> @more
20:55:55 <BMeph> Uh...forM_? ;p
20:56:06 <ivanm> BMeph: that's what I was thinking of
20:56:10 <ivanm> couldn't remember the name though
20:56:13 <ivanm> @type forM_
20:56:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
20:56:15 <ivanm> @type mapM_
20:56:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
20:56:22 <ivanm> flazz: ^^ just switch the arguments around
20:56:24 <ivanm> @src forM_
20:56:25 <lambdabot> forM_ = flip mapM_
20:56:50 <BMeph> ivanm: "A funny thing happened on the way to the...forM_" ;)
20:57:04 <ivanm> BMeph: *groan*
20:57:23 <flazz> flip switches binary params?
20:57:38 <ivanm> flazz: yes
20:57:45 <flazz> nice
20:57:47 <ivanm> if by "binary" you mean switches first two parameters
20:57:51 <flazz> yes
20:57:54 <flazz> right
20:58:06 <ivanm> @hoogle (a -> b -> c) -> (b -> a -> c)
20:58:06 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
20:58:07 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
20:58:07 <lambdabot> Data.IntMap fold :: (a -> b -> b) -> b -> IntMap a -> b
20:58:22 <ivanm> wtf? how is Data.IntMap.fold relevant? :s
20:58:28 <ivanm> stupid hoogle...
21:11:09 <kerlo> @type sortBy
21:11:10 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:11:27 <kerlo> @type on
21:11:28 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:11:38 <kerlo> @type sortBy (compare `on` fst)
21:11:39 <lambdabot> forall a b. (Ord a) => [(a, b)] -> [(a, b)]
21:11:44 <kerlo> Woot.
21:15:01 <adamvo> @type typeOf
21:15:02 <lambdabot> forall a. (Typeable a) => a -> TypeRep
21:16:20 <orbitz> > typeOf 1
21:16:21 <lambdabot>   Integer
21:21:05 <scutigera> make :: BLAS3 e => Matrix (n, p) e
21:21:14 <scutigera> make = listMatrix (2, 2) [ 1.0, 2.0, 3.0, 4.0 ]
21:21:35 <scutigera>    Ambiguous type variable `e' in the constraint:
21:21:35 <scutigera>       `BLAS3 e' arising from a use of `make' at <interactive>:1:0-3
21:21:35 <scutigera>     Probable fix: add a type signature that fixes these type variable(s)
21:21:35 <scutigera>  
21:22:02 <BMeph> kerlo: (compare `on`) got so popular that it got its own name, 'comparing'. :)
21:22:21 <facedown> hows multi threading in Haskell as opposed to other languages?
21:22:22 <kerlo> @hoogle upper
21:22:23 <lambdabot> Text.Parsec.Char upper :: Stream s m Char => ParsecT s u m Char
21:22:23 <lambdabot> Text.ParserCombinators.Parsec.Char upper :: Stream s m Char => ParsecT s u m Char
21:22:23 <lambdabot> Data.Char UppercaseLetter :: GeneralCategory
21:22:28 <BMeph> The jury's still out on 'equating', though. :)
21:22:40 <kerlo> @hoogle toUpper
21:22:40 <lambdabot> Data.Char toUpper :: Char -> Char
21:23:00 <kerlo> @hoogle on
21:23:01 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:23:01 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
21:23:01 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
21:23:05 <scutigera> listMatrix :: BLAS3 e => (Int, Int) -> [e] -> Matrix (n, p) e
21:23:32 <kerlo> @src on
21:23:32 <lambdabot> (*) `on` f = \x y -> f x * f y
21:23:34 <BMeph> facedown: Much easier and integratable, unless you're talking about Smalltalk or Erlang. :)
21:23:41 <scutigera> Seem as though e should be inferred since list matrix is being given [ Double ]
21:24:02 <kerlo> @hoogle sortBy
21:24:03 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
21:24:04 <facedown> BMeph: based on what you know, what languages specifically is it easier than?
21:24:46 <BMeph> scutigera: How does it know that they're Doubles? :)
21:25:26 <dolio> comparing was around before on existed.
21:25:50 <dons> facedown: fast, ubiquitous, and we have thread sparks: no one else has that.
21:26:01 <facedown> whats a thread spark
21:26:16 <BMeph> dolio: Good to know, thanks. :)
21:27:45 <scutigera> [1.0,2.0,3.0,4.0]
21:27:45 <scutigera> it :: [Double]
21:27:45 <scutigera>  
21:27:53 <facedown> , dons?
21:27:55 <lunabot>  luna: Not in scope: `dons'
21:28:00 <facedown> oops
21:28:06 <scutigera> see, ghc just _knows_
21:28:22 <facedown> lol
21:30:27 <facedown> can anyone explain what a thread spark is?
21:30:42 * shapr bzzts facedown
21:30:44 <facedown> i'm googling but there isnt a super definitive definition
21:31:07 <shapr> I'm going to guess that it's a Haskell thread being created...
21:31:18 <shapr> And that Haskell thread will get handed to an OS thread when there's one available?
21:31:22 <shapr> That's pure guesswork though
21:31:33 <dons> facedown: it's an expression that will be turned into a haskell thread , if resources are available
21:31:41 <shapr> ah
21:31:44 <facedown> and no other languages have that feature?
21:31:47 <dons> haskell threads are multiplexed between OS threads (== cores)
21:31:58 <dons> not for speculative eval, like that, no.
21:32:04 <shapr> dons: Is that explained in RWH somewhere?
21:32:06 <dons> since it hardly makes sense in non-pure languages
21:32:08 <dons> shapr: yep
21:32:13 <facedown> o, link?
21:32:28 <ddarius> dons means par
21:32:31 <dons> the best reference is either RWH , or the new multicore runtime paper
21:32:35 <dons> yes, `par`
21:32:51 <dons> which introduces a thread spark (which might "fizzle" if no threads become available)
21:33:21 <facedown> fizzle = work, process?
21:33:50 <dons> definitely worth reading if you're  into multicore, http://ghcmutterings.wordpress.com/2009/03/03/new-paper-runtime-support-for-multicore-haskell/
21:35:10 <shapr> "sparking" is on page 547 of RWH
21:35:50 <facedown> thanks
21:35:57 <dons> yeah, `par` is lots of fun
21:36:13 <facedown> shapr: you have the print edition?
21:36:16 <shapr> facedown: Yes!
21:36:21 <facedown> what chapter?
21:36:23 <shapr> But I have yet to get it autographed by the authors :-(
21:36:29 <dons> hmm 23?
21:36:35 <shapr> 24
21:36:42 <facedown> correcto
21:36:54 <dons> so many chapters
21:36:57 <shapr> hah
21:37:01 <shapr> You did a great job dons!
21:37:21 <dons> heh. bos and john are heroes of great power
21:37:27 <facedown> huh
21:37:32 <facedown> is dons one of the authors?!
21:37:37 <facedown> don stewart?
21:37:40 <shapr> heh
21:37:41 <shapr> yup
21:37:49 <dons> now we're in crazy land, like this, http://dev.oqube.net/projects/beyond-tdd/plan.html#toc
21:38:02 <dons> people i've never heard of talking about haskell at conferences i've never been to
21:38:09 <dons> :)
21:38:50 <dons> and saying the things we've been staying for years in #haskell, too, fwiw
21:39:08 <dons> shapr: did you see http://wiki.github.com/sebastiaanvisser/flux
21:39:17 <dons> awesome 3D coolness. (opengl bindings ftw)
21:39:21 <shapr> Well, I like the idea of combining FITNesse and QuickCheck..
21:39:23 <shapr> FIT is really cool
21:39:28 <facedown> what languages did you guys use before Haskell?
21:39:38 <shapr> I used Python
21:39:40 <shapr> and Java
21:39:44 <facedown> and do you use them for the same purpose anymore?
21:39:47 <dons> java, perl.
21:39:49 <facedown> or still use them in general?
21:39:56 <dons> nope
21:39:59 <shapr> I use C# at work, and Haskell at home.
21:40:07 <wli> I used C, Standard ML, and OCaml.
21:40:11 <facedown> I went from PHP ( puke ) to Python and now reading like the first chapter of RWH
21:40:20 <dons> awesome :)
21:40:40 <dons> welcome !
21:40:49 <scutigera> I like SML, scheme.  Just picked up RWH today !
21:40:53 <wli> I think I sort of looked at Python once in 1998 or 1999.
21:41:18 <sebaseba> facedown: welcome, you're in for a fun journey!
21:41:53 <facedown> yeah.. some of the stuff goes over my head but i kind of want to learn non-C based syntax sorta
21:42:04 <wli> Somebody wanted a GUI for some eigensolver (which didn't seem to make sense to me).
21:42:22 <pumpkin> we need eigenIRCcharacters
21:43:20 <kerlo> Characters that are not modified by transmission via IRC?
21:43:52 <pumpkin> I meant as in human characters
21:44:49 <kerlo> > unwords (words "   f wa   g f  haa ")
21:44:51 <lambdabot>   "f wa g f haa"
21:47:42 <scutigera> Prelude Data.Matrix.Dense> listMatrix (2, 2) [ 1.0, 2.0, 3.0, 4.0 ]
21:47:50 <scutigera>     Ambiguous type variable `t' in the constraint:
21:47:50 <scutigera>       `Data.Elem.BLAS.Level3.BLAS3 t'
21:47:50 <scutigera>  
21:47:58 <scutigera> listMatrix (2, 2) ([ 1.0, 2.0, 3.0, 4.0 ]::[Double])
21:47:59 <scutigera>  
21:48:10 <scutigera> listMatrix (2,2) [1.0,2.0,3.0,4.0]
21:48:10 <scutigera> it :: Matrix (n, p) Double
21:48:17 <w0rth> Is there a difference between implementing fail as part of a Monad instance and just writing a fail function for my monad?
21:48:37 <scutigera> So it works with the explicit signature- why can't ghc infer ??
21:48:37 <pumpkin> yeah
21:49:03 <pumpkin> if you put it in your Monad instance, a failed pattern match within a do block will call your fail function
21:49:36 <w0rth> hmm... so lets say im building a parser monad, which one makes more sense?
21:50:17 <pumpkin> why not stick it in the instance?
21:50:24 <pumpkin> it'll just complain that you didn't define it if you don't
21:51:30 <w0rth> hm ok
21:51:32 <w0rth> thanks
21:52:17 <adamvo> Is it possible to define a function that can use an instance for an input, but also be able to be applied to arguments that are not an instance?
21:52:58 <adamvo> concretely I want to be able to `Show` something, but if the thing does not have a Show instance, I want to leave a default
21:53:50 <adamvo> hmm, it seems I can get around this with existentials
21:54:12 <wli> forward chaining vs. backward chaining Collatz
21:54:33 <kerlo> > unwords (words (cycle "foo   "))
21:54:35 <lambdabot>   "foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo foo fo...
21:55:08 <adamvo> but that's kind of clunky... but so is my problem
21:55:34 <kerlo> I think I need to strictify this: http://codepad.org/Wf9zGHJU
21:56:06 <adamvo> kerlo: better get on it right away
21:56:25 <wli> You can partition the space into eliminated, tied for current longest chain, and undecided.
21:56:37 <kerlo> And I think I don't know how, so can somebody help me. :-P
21:57:22 <adamvo> @type sequence_
21:57:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
21:57:33 <adamvo> @type sequence
21:57:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:57:39 <wli> Every time bfs descends a level you dump your entire current best into eliminated status, make the current level the current best, and peel those off from the undecideds.
21:58:41 <kerlo> @hoogle foldr
21:58:42 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
21:58:42 <lambdabot> Data.ByteString foldr :: (Word8 -> a -> a) -> a -> ByteString -> a
21:58:42 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
21:59:01 <kerlo> @hoogle foldl
21:59:02 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
21:59:02 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
21:59:02 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
21:59:05 <adamvo> kerlo: I'd use sequence_
21:59:08 <kerlo> What's the strict foldl?
21:59:11 <adamvo> @type mapM_
21:59:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:59:18 <adamvo> that'd be even better
21:59:48 <PetRat> I'm attempting to use fmap for the first time. I'm told that Maybe is a Functor. I defined x = [ Nothing, Just 3]. Then I typed at the ghci prompt fmap (*2) x. Got a type error. What's wrong?
22:00:08 <kerlo> @type \x y -> sequence_ (map x y)
22:00:09 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m a1) -> [a] -> m ()
22:00:56 <adamvo> PetRat: what's Nothing * 2 ?
22:01:09 <sebaseba> kerlo: unrelated to your problem: you can use readFile instead of openFile and hGetContents
22:01:56 <PetRat> adamvo: according to Real World Haskell page 246, fmap is defined on "_ Nothing" to return Nothing. So I thought this would work.
22:02:04 <adamvo> The list is also a functor
22:02:27 <PetRat> I just don't know where my misunderstanding is
22:02:31 <kerlo> PetRat: yeah, try map (fmap (*2)) x.
22:02:31 <ivanm> so you need to fmap your fmap
22:02:34 <sebaseba> PetRat: that fmap is mapping over the list
22:02:44 <ivanm> > let x = [Nothing, Just 3] in fmap (fmap (*2)) x
22:02:45 <lambdabot>   [Nothing,Just 6]
22:02:45 <kerlo> fmap words on individual Maybe a's, not lists of them.
22:02:52 <ivanm> PetRat: ^^
22:03:04 <kerlo> @src foldl'
22:03:05 <lambdabot> foldl' f a []     = a
22:03:05 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:03:47 <adamvo> kerlo: I don't think that its a strictness issue since you didn't run out of stack space
22:03:52 <PetRat> For lists map is the same thing as fmap?
22:04:15 <sebaseba> yes
22:04:26 <kerlo> adamvo: I modified it and managed to get a stack error instead, however.
22:04:32 <adamvo> yay!
22:04:35 <kerlo> @index foldl'
22:04:36 <lambdabot> Data.List
22:05:19 <PetRat> Oh, so I'm so used to thinking of "map" as operating on a conceptually large container, but fmap on Maybe operates on just one value.
22:05:31 <sebaseba> > fmap (*2) (Just 3)
22:05:32 <lambdabot>   Just 6
22:05:43 <sebaseba> > fmap (*2) Nothing
22:05:44 <lambdabot>   Nothing
22:05:56 <kerlo> PetRat: indeed.
22:06:25 <adamvo> > fmap (const Nothing) (Just undefined)
22:06:27 <lambdabot>   Just Nothing
22:06:29 <ivanm> PetRat: fmap == map for lists
22:06:35 <BMeph> PetRat: Just think of Maybe as a container that may be empty.
22:06:36 <kerlo> @type let collect bins (x:xs) = collect (map (add x) bins) xs
22:06:38 <lambdabot> <no location info>:
22:06:38 <lambdabot>     not an expression: `let collect bins (x:xs) = collect (map (add x) bins) xs'
22:06:40 <kerlo> ...
22:06:59 <kerlo> @type let collect bins (x:xs) = collect (map (?add x) bins) xs; collect bins [] = bins in collect
22:07:01 <lambdabot> forall a t. (?add::t -> a -> a) => [a] -> [t] -> [a]
22:07:01 <allbery_b> you need the "...in <expr>"
22:07:10 <BMeph> PetRat: Well, don't *really* think of it that way... ;)
22:07:23 <kerlo> Yeah, that was a copy-and-paste and it evidently copied a line break along with the line copied.
22:10:05 <kerlo> @pl collect bins (x:xs) = collect (map (?add x) bins) xs
22:10:06 <lambdabot> collect = fix (flip flip tail . (ap .) . flip flip head . ((.) .) . (. flip (map . flip (?) . add)) . (.))
22:10:10 <kerlo> Aaa.
22:11:56 <adamvo> can we write map with fix?
22:12:04 <adamvo> @type fix
22:12:05 <lambdabot> forall a. (a -> a) -> a
22:12:12 <pumpkin> sure!
22:13:58 <hornblower> i get an error,  "ERROR - Garbage collection fails to reclaim sufficient space" , when running this program: http://codepad.org/1s6Fi65r
22:14:26 <pumpkin> whoa, what haskell are you using?
22:14:31 <pumpkin> import List?
22:14:42 <hornblower> what do you mean what haskell?
22:14:47 <pumpkin> are you using ghc?
22:14:51 <hornblower> hugs
22:16:20 <allbery_b> pumpkin: That's Haskell 98 standard
22:16:29 <pumpkin> ack, weird :)
22:16:39 <pumpkin> I guess the dotted modules is an extension, so I shouldn't be surprised
22:17:28 <allbery_b> it has been 11 years...
22:17:41 <ivanm> pumpkin: that's why GHC still has List, Array, etc. that export a subset of Data.List, etc.
22:17:47 <pumpkin> ah
22:18:00 <pumpkin> I see :)
22:18:07 <pumpkin> I learn new stuff every day!
22:18:18 <hornblower> can you help me?
22:19:04 <Cale> hornblower: I'll have a look... hugs isn't really designed for performance at all, but it might be possible to do something...
22:19:23 <hornblower> how do i load it in GHC?
22:19:26 <hornblower> i don't know the commands
22:19:57 <Cale> You can use ghci similarly to hugs
22:20:08 <Cale> I think I can see why this would use lots of space.
22:20:19 <ivanm> isn't pretty much the only difference the "it" variable in ghci (can't recall what hugs calls it)?
22:20:25 <Cale> You can also try compiling with optimisations
22:20:33 <Cale> ghc --make MyProgram.hs
22:20:37 <Cale> ghc -O2 --make MyProgram.hs
22:20:50 <hotaru2k3> i wish i could get ghci on my n810, hugs runs really slow on it
22:21:39 <Cale> hornblower: But, I think the real problem with this program is that you're using lists of pairs instead of something like Data.Map
22:21:51 <Cale> hornblower: (at least as far as efficiency is concerned)
22:22:50 <Cale> Well, even then, you could write a much more efficient collect...
22:23:02 <Cale> something like...
22:23:44 <Cale> > map (\xs -> (head xs, length xs)) . group . sort $ "The quick brown fox jumps over the lazy dog."
22:23:46 <lambdabot>   [(' ',8),('.',1),('T',1),('a',1),('b',1),('c',1),('d',1),('e',3),('f',1),('...
22:24:10 <Cale> (followed by removal of the bins you're not interested in)
22:24:37 * kerlo implements Cale's collect
22:25:32 <flazz> i have an IORef and i find myself doing the pattern x <- get y; y $= fx. is there a cleaner way to do this?
22:25:38 <hornblower> how do i load  afile in GHC?
22:25:38 <flazz> *f x
22:25:55 <flazz> hornblower: :load
22:25:56 <Cale> :t modifyIORef
22:25:57 <lambdabot> Not in scope: `modifyIORef'
22:26:00 <Gracenotes> if you need something more efficient than Cale's solution, you can do something with STArrays
22:26:05 <Cale> modifyIORef :: IORef a -> (a -> a) -> IO ()
22:26:20 <Gracenotes> the classically imperative solution
22:26:27 <Gracenotes> which is much faster and more memory efficient in this case
22:26:41 <Cale> Or just Data.Map :P
22:27:12 <hornblower> what is the default directory for ghc?
22:27:14 <Gracenotes> well. it depends on how much data you're dealing with and how critical the operation is
22:27:18 <Cale> Right.
22:27:31 <Cale> I consider STArrays a bit of a last resort :)
22:27:37 <flazz> i'm looking at the docs for Data.IORef, and i don't see get or $= defined anywhere, what are they?
22:28:01 <Gracenotes> in the case of Shor's quantum algorithm where the whole thing is basically making a frequency map and taking a Fourier transform, it's important...
22:28:07 <Cale> hornblower: um, default directory in which sense? I think it doesn't change the working directory it was run from
22:28:21 <kerlo> hornblower: stick with Hugs for now.
22:28:42 <Cale> kerlo: Really?
22:29:03 <kerlo> "collect = map (\xs -> (head xs, length xs)) . group . sort" is saying "ERROR line 27 - Unresolved top-level overloading / *** Binding             : collect / *** Outstanding context : Ord b"
22:29:26 <Cale> kerlo: add a parameter or a type signature
22:29:35 <Cale> kerlo: It's the monomorphism restriction
22:29:40 <hamishmack> If I use forkIO and hGetContents to read from two Handles (stdout and stderr of a child process) is there a way to yield until both threads are blocked waiting for IO on those handles?
22:29:41 <kerlo> @type map (\xs -> (head xs, length xs)) . group . sort
22:29:43 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
22:29:48 <kerlo> Is that a good type signature?
22:29:51 <Cale> sure
22:30:02 <Cale> chop off the forall if you're using it in hugs, I think
22:30:04 <Gracenotes> mamamarphasm restraction
22:30:49 <Cale> hamishmack: hmm
22:30:52 <Gracenotes> ng..?
22:31:08 <Cale> hamishmack: That might be especially hard, since hGetContents is slightly magical.
22:31:43 <ivanm> Cale: oh? it's hard-coded rather than being haskellian in nature?
22:31:57 <Cale> ivanm: hGetContents uses unsafeInterleaveIO
22:32:08 <ivanm> *nod*
22:32:13 <adamvo> @faq can overlapping instances in haskell kill people?
22:32:13 <lambdabot> The answer is: Yes! Haskell can do that.
22:32:24 <ivanm> damn unsafe functions
22:32:43 <kerlo> hornblower: well, try this one: http://codepad.org/boZGv7gV
22:32:45 <Gracenotes> I never knew ol' Curry was homicidally inclined
22:33:36 <pumpkin> boo, no NSF GRFP for me
22:33:44 <pumpkin> maybe next year
22:33:45 <adamvo> is there a real answer?
22:34:06 <Cale> adamvo: About overlapping instances?
22:34:07 <hamishmack> Child process is ghci and wait when I see the prompt on stdout until all the errors have been read.
22:35:00 <kerlo> @faq Does Haskell support arbitrarily-traversable graphs?
22:35:01 <lambdabot> The answer is: Yes! Haskell can do that.
22:35:06 <adamvo> Cale: yes, though it seems that ghc picks the most specific one
22:35:07 <kerlo> Wait, I worded that wrong.
22:35:16 <hamishmack> Currently I end up getting errors out of order a bit
22:35:37 <Cale> adamvo: Ah, you want to know more about how it selects instances?
22:36:08 <hornblower> i saved my file to the ghc directory but its still not loading
22:36:11 * kerlo ponders Zipperable graphs
22:36:12 <hamishmack> Alternative might be to use the same pipe for stdout and stderr.  But then it will be harder to identify what is an error and what is output.
22:36:13 <Cale> http://www.haskell.org/ghc/docs/6.10.2/html/users_guide/type-class-extensions.html#instance-overlap
22:36:23 <Cale> hornblower: You don't have to do that?
22:36:46 <Cale> hornblower: If ghc/ghci is installed, you should just be able to run  ghci MyFile.hs  from wherever MyFile.hs is.
22:37:11 <allbery_b> output vs. errors also depends on what buffering the 5program chooses
22:37:14 <kerlo> hornblower: 'ghc --make frequency.hs' will compile your program.
22:37:28 <Cale> and -O2 will turn on optimisations
22:37:33 <kerlo> 'ghc --make -O2 frequency.hs' will do it with optimizations.
22:37:42 <adamvo> Cale: yeah, that description seems acceptably reassuring
22:37:47 <kerlo> Then what will the resulting .exe be called?
22:38:31 <adamvo> since I want to be able to have a default function that would be overridden when a specific class is visible
22:39:01 <Cale> adamvo: When a specific *class* is visible?
22:40:00 <adamvo> when the datatype has a instance of a specific class in scope?
22:40:23 <hornblower> kerlo: then how do i load oldman.hs  ?
22:40:33 <hornblower> i mean oldman.txt  the text file to be counted
22:40:35 <Cale> ah, okay
22:40:47 <adamvo> Cale: as in instance Show a where show = const ""
22:41:17 <Cale> adamvo: That sounds like you want incoherent instances, which are considerably more horrible than just overlapping.
22:41:19 <kerlo> hornblower: first, :set args C:\path\to\oldman.hs
22:41:34 <flazz> what is the difference between IORef and StateVar?
22:41:40 <kerlo> Then just type main
22:41:48 <Cale> er, hmm
22:42:22 <Cale> flazz: StateVar is the OpenGL's own abstraction around IORef-like things.
22:42:30 <Cale> the OpenGL library's*
22:42:34 <flazz> ok
22:42:49 <flazz> and IORef is something that can change state?
22:43:19 <Cale> Yeah, an (IORef t) is essentially a mutable cell which holds a value of type t
22:43:33 <hornblower> kerlo: it worked in GHC. but the values are given in scientific notation
22:43:44 <kerlo> Oh, that's weird.
22:43:50 <kerlo> What does it look like?
22:43:59 <flazz> is it really mutable or is there magic going on in the do notation combined with tail optimized recursion?
22:44:17 <Cale> flazz: It's really mutable, by IO actions.
22:44:33 <flazz> but i should pretend that i'm making a new copy of the universe?
22:44:35 <hornblower> 'e': 13075 (9.523408230482348e-2)
22:44:40 <flazz> and garbage collecting the old one?
22:44:45 <kerlo> > show 0.00002
22:44:47 <lambdabot>   "2.0e-5"
22:45:10 <kerlo> I didn't know it did that.
22:45:15 <hornblower> only the spacebar character shows up normal, i guess because its the biggest
22:45:27 <Cale> flazz: I would ignore that awful IO a = RealWorld -> (a, RealWorld) analogy... at least, I didn't find it very helpful.
22:45:27 <kerlo> Cale, tell GHC to stop using scientific notation.
22:45:55 <hornblower> how do i shut off scientific?
22:45:56 <Cale> kerlo: That's the normal behaviour for floating point numbers, but there are some functions in Numeric.
22:45:59 <ivanm> why?
22:46:08 <ivanm> what's wrong with scientific notation?
22:46:16 <ivanm> how else do you show really small numbers?
22:46:29 <hornblower> with lots of zeros
22:46:32 <kerlo> ivanm: 0.09 is not really small.
22:46:33 <Cale> > showFFloat Nothing 0.0002 ""
22:46:35 <lambdabot>   "0.0002"
22:46:37 <ivanm> that's ridiculous
22:46:38 <Cale> > showFFloat Nothing 0.0000002 ""
22:46:39 <lambdabot>   "0.0000002"
22:46:41 <ivanm> > show 0.09
22:46:43 <lambdabot>   "9.0e-2"
22:46:48 <ivanm> :t 0.09
22:46:49 <lambdabot> forall t. (Fractional t) => t
22:46:55 <ivanm> > show (0.09 :: Double)
22:46:57 <lambdabot>   "9.0e-2"
22:47:12 <kerlo> @index showFFloat
22:47:12 <lambdabot> Numeric
22:47:29 <kerlo> hornblower: at the top, add import Numeric, then in pretty, replace the second show with showFFloat.
22:47:37 <ivanm> hmmm.... that's weird...
22:47:47 <ivanm> I thought it went for smaller numbers before resorting to scientific notation
22:47:59 <pumpkin> > show 0.9
22:48:01 <lambdabot>   "0.9"
22:48:27 <ivanm> how do you get the smallest possible (absolute and non-zero) value for a given type?
22:48:51 <hornblower> in pretty?
22:48:53 <pumpkin> in Numeric.IEEE you can get the float/double ones
22:49:02 <hornblower> count text l = map (pretty l)
22:49:02 <ivanm> > show 0.0625
22:49:04 <lambdabot>   "6.25e-2"
22:49:17 <kerlo> hornblower: yes, in the very last line.
22:49:47 <Cale> flazz: You can think of a value of type (IO t) as just being an ordinary executable program which if it was run, would produce a value of type t. Normal Haskell evaluation doesn't cause IO actions to run though -- any more than reading an executable file would cause it to run.
22:49:59 <kerlo> Silly code organization idea: Whenever you modify a line of code, move it to the top of the program so it's easier to modify.
22:50:07 <Cale> flazz: In the end, you define an IO action called main, and that's what actually gets to run.
22:51:27 <Cale> flazz: IO actions themselves can do essentially anything your computer can do.
22:51:43 <Cale> (when run)
22:51:55 <flazz> and the compiler knows this and treats them specially?
22:52:12 <Cale> Well, they're just values which *describe* things to do.
22:52:29 <hornblower> kerlo: change this show?
22:52:33 <hornblower> ++ show n ++
22:52:36 <Cale> When I say they can do anything, I really mean they can describe any sort of action.
22:52:42 <kerlo> hornblower: no, the other one.
22:52:52 <kerlo> ++ show (fromIntegral
22:52:58 <Cale> Evaluating what that action is doesn't actually cause it to happen.
22:53:12 <Cale> But yeah, the compiler does have to treat one action in particular specially
22:53:40 <Cale> Specifically, the action 'main' actually gets to run.
22:54:05 <Cale> In turn, main will be built up from simpler actions.
22:54:28 <Cale> For example, in:
22:54:39 <Cale> main = do x <- getLine; putStrLn x
22:55:02 <hornblower> it should look like this?  pretty l (n,y) = "Frequency of '" ++ y : "': " ++ show n ++ " (" ++ show (showFFloat n / fromIntegral l) ++ ")"
22:55:03 <Cale> The do-notation glues together the actions 'getLine' and 'putStrLn x'
22:55:31 <Cale> hornblower: You don't need the extra show
22:55:41 <Cale> hornblower: and it should be  showFFloat Nothing n ""
22:55:46 <Cale> er...
22:55:56 <Cale> oh, if you want to divide it by fromIntegral l...
22:56:04 <Cale> it should be  showFFloat Nothing (n / fromIntegral l) ""
22:58:18 <kerlo> hornblower: you replace the show with showFFloat, not the fromIntegral.
22:58:44 <kerlo> pretty l (n,y) = "Frequency of '" ++ y : "': " ++ show n ++ " (" ++ showFFloat (fromIntegral n / fromIntegral l) ++ ")"
22:59:07 <hornblower> thanks, ill try that out now
23:04:16 <hornblower> i type 'ghci frequency2.hs'
23:04:21 <hornblower> and it says "out of scope"
23:09:48 <kerlo> hornblower: what does it say is out of scope?
23:10:59 <hornblower> i still got scientific notation
23:11:47 <hornblower> oh wait
23:11:51 <hornblower> didn't save the text.
23:11:52 <hornblower> nevermind
23:12:25 <ivanm> heh
23:13:41 <hornblower> now its sayin "showffd" not in scope
23:14:31 <hornblower> Not in scope: 'showFFloat'
23:17:45 <hornblower> halp!
23:18:17 <dons> import Numeric
23:18:20 <dons> ?hoogle showFFloat
23:18:20 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
23:18:47 * ivanm heleps hornblower by giving him a spell checker
23:18:53 <ivanm> @wn halp
23:18:56 <lambdabot> No match for "halp".
23:19:01 <ivanm> ^^ no such word! ;-)
23:19:07 <ivanm> s/heleps/helps/
23:19:08 <ivanm> :s
23:19:13 <hornblower> i saw some russkies write HALP , and i liked it. used that spelling ever since!
23:19:53 <ivanm> you trust `russkies' with your _English_? :o
23:20:08 <pumpkin> HALP
23:20:15 <ski> (Halperin ?)
23:20:17 <ivanm> @slap pumpkin
23:20:18 * lambdabot beats up pumpkin
23:20:23 <pumpkin> @slap lambdabot
23:20:23 * lambdabot loves lambdabot, so no slapping
23:20:30 <pumpkin> narcissist
23:20:45 <ski> @botsmack
23:20:45 <lambdabot> :)
23:20:46 <lunabot>  :)
23:20:51 <hornblower> HALP !!!
23:20:51 <pumpkin> lol
23:20:53 <Gracenotes> I am your Echo, lambdabot! :(
23:21:01 * Gracenotes pines
23:21:03 <ivanm> ski: yeah, lambdabot is a masochist
23:21:03 <hornblower> ivanm: no i don't, but they invented a cool mispelling.
23:21:15 <ivanm> I don't think so
23:21:37 <ivanm> according to my M*A*S*H DVDs, those living in the southern part of the USA did ;-)
23:21:53 <ivanm> (at least, Rizzo, etc. always say "halp")
23:21:58 <ivanm> or is that "hep"? can't recall...
23:22:47 <hornblower> ivanm, russkies say "HALP" when they speak in their accent. so it makes sense they mispell that way too.
23:23:31 <ivanm> hornblower: first of all, I was trying to hint to you with my usage of quotations that there are no such people as `russkies'
23:24:17 <ivanm> secondly, I don't think that's how Russians (or assuming your geographic and cultural knowledge is limited and you actually meant those of slavic descent) talk...
23:24:57 <hornblower> yes thats how they talk,  they say HALP, not HELP
23:25:40 <ivanm> no, they'd say something more like "" ;-)
23:26:18 <ivanm> if anything, their pronounciation is closer to "haelp" (i.e. over-emphasis on the beginning of the `e')
23:26:42 <pumpkin> HALP
23:26:47 <pumpkin> I pronounce it as I spell it
23:26:53 <ivanm> @slap pumpkin
23:26:53 * lambdabot slaps pumpkin with a slab of concrete
23:27:58 <hornblower> im still getting errors. http://codepad.org/YSVlIZP9
23:28:00 <hornblower> please halp
23:28:46 * ivanm once again helps hornblower by giving him a spell checker
23:28:52 <pumpkin> HALP
23:28:58 <pumpkin> @faq HALP
23:28:59 <lambdabot> The answer is: Yes! Haskell can do that.
23:29:04 <pumpkin> there you go
23:29:11 <ivanm> @slap pumpkin
23:29:12 <lambdabot> I don't perform such side effects on command!
23:29:19 <ivanm> not helping here, pumpkin!
23:29:19 <pumpkin> fail
23:29:25 <ivanm> grrr...
23:29:27 <ivanm> @slap bot
23:29:27 * lambdabot jabs bot with a C pointer
23:29:30 <pumpkin> lern 2 spel, itz halp
23:29:39 <hornblower> i need assitance.
23:29:54 <hornblower> assistance :)
23:30:12 <pumpkin> @hoogle showFFloat
23:30:12 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
23:30:19 <pumpkin> @src ShowS
23:30:19 <lambdabot> type ShowS = String -> String
23:30:22 <pumpkin> there you go
23:30:40 <ivanm> hornblower: OK, I'll pay that ;-)
23:31:07 <hornblower> so what should i change?
23:31:19 <ivanm> hornblower: why do you use (:) in pretty ?
23:31:26 <ivanm> it should be ++ !
23:31:43 <ivanm> (since you're joining two lists together)
23:31:49 <ivanm> oh, wait, that's not the error...
23:31:54 <ivanm> @type showFFloat
23:31:55 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
23:32:14 <ivanm> hornblower: ^^ you need to give showFFloat a String value as its last argument!
23:32:30 <pumpkin> and you need more than that
23:32:37 <hornblower> how do i do that?
23:32:40 <pumpkin> you need a Maybe first
23:32:54 <ivanm> hornblower: replace ` ++ ")" ' with just ")"
23:33:03 <ivanm> since that's what you want to do anyway ;-)
23:33:22 <ivanm> pumpkin: for the 0 case? it doesn't look like he'll get a 0 for l...
23:33:54 <pumpkin> ?
23:34:23 <ivanm> pumpkin: why do you say he needs a Maybe?
23:34:29 <Gracenotes> :O
23:34:31 <pumpkin> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
23:34:31 <ivanm> because of division by 0?
23:34:39 <ivanm> oh, didn't see that
23:34:44 <ivanm> @src showFFloat
23:34:44 <lambdabot> Source not found. I've seen penguins that can type better than that.
23:34:51 <ivanm> what's that Maybe for?
23:34:57 <pumpkin> showFFloat Nothing mahFloat mahString
23:35:09 <ivanm> s/mah/my/g
23:35:26 <pumpkin> halp, the grammer nazi iz aftur me
23:35:58 <ivanm> s/grammer/grammar/
23:36:02 <hornblower> ++ ")"  i replaced that with just ")"   still getting the error
23:36:08 <ivanm> s/grammar/spelling/ ;-)
23:36:12 <pumpkin> > hmm
23:36:13 <lambdabot>   Not in scope: `hmm'
23:36:20 <ivanm> hornblower: yeah, as pumpkin said you need a Maybe value as well
23:36:28 <ivanm> > showFFloat Nothing pi ""
23:36:29 <lambdabot>   "3.141592653589793"
23:36:36 <ivanm> > showFFloat (Just 3) pi ""
23:36:38 <lambdabot>   "3.142"
23:36:46 <ivanm> ooohhhh.... it rounds! :o
23:36:49 <harovali1> hi, i'm trying to build a lower to upper case map, like this  :   foldr (\a b -> insert (head b) (last b) a) Data.Map.empty $ zip ['a'..'z'] ['A'..'Z']
23:36:51 <pumpkin> > help
23:36:53 <lambdabot>   Not in scope: 'help', maybe you meant to type 'halp'?
23:36:54 <hotaru2k3> pumpkin: communicating properly is important: http://www.fmylife.com/sex/869850
23:37:05 <voker57> > halp
23:37:07 <lambdabot>   Yes, haskell can do that!
23:37:15 * pumpkin grins
23:37:27 <ivanm> @slap hotaru2k3
23:37:27 <lambdabot> why on earth would I slap hotaru2k3?
23:37:32 <ivanm> because he's a spammer!
23:37:34 <ivanm> @chans
23:37:35 <lambdabot> you are welcome
23:37:37 <ivanm> @chan
23:37:37 <lambdabot>  @where <key>, return element associated with key
23:37:39 <hornblower> how do i add a Maybe?
23:37:39 <ivanm> @ops
23:37:39 <lambdabot> Maybe you meant: docs oeis pl
23:37:42 <ivanm> grrr...
23:37:56 <ivanm> hornblower: showFFloat Nothing (fromIntegral .....
23:38:08 <ivanm> @chanops
23:38:09 <pumpkin> lol
23:38:09 <lambdabot> Unknown command, try @list
23:38:12 <ivanm> grrr.....
23:38:22 <PetRat> The haskell.org docs say Word8 is part of Data.Word. I'm using ghci... when I load a module that imports Data.Word, I get an error that Word8 is not defined. I'm not using "qualified"
23:38:23 <harovali1> i'm afraid i'm doing all sort of wrong things there, would you pleas give me some hints?
23:38:26 <pumpkin> ivanm: @where ops
23:38:30 <ivanm> @where ops
23:38:30 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
23:38:30 <lambdabot> mauke
23:38:32 <ivanm> \o/
23:38:38 <ivanm> ^^ someone kickban hotaru2k3 please?
23:38:43 <pumpkin> PetRat: your module isn't re-exporting it
23:38:49 <hotaru2k3> ivanm: why?
23:38:58 <pumpkin> #haskell wa hotaru no haka!
23:39:04 <pumpkin> ;)
23:39:18 <ivanm> hotaru2k3: did you see the message you gave to pumpkin?
23:39:19 <PetRat> Well, the use of Word8 is in my module...  import Data.Word;  x = Word8 2
23:39:24 <hornblower> i added  showFFloat Nothing (fromIntegral  ,  it still fails
23:39:39 <ivanm> hornblower: with what error message?
23:39:42 <pumpkin> PetRat: yeah, but you aren't making it available to people importing your module
23:39:50 <ivanm> oh, I think I know why...
23:39:55 <hotaru2k3> ivanm: it's a story about why communicating properly is important. what's wrong with that?
23:40:01 <ivanm> hotaru2k3: oh, sorry...
23:40:05 <ivanm> the link looked dodgy...
23:40:19 <harovali1> isn't possible to do list pattern matching in lambdas ?
23:40:22 <hornblower> ivanm: http://codepad.org/E5IttkOc
23:40:27 <PetRat> pumpkin: I'm not sure I understand. I'm just loading my own module. at ghci prompt:  :load myModule
23:40:42 <ivanm> it looked to me like you were a random that came in, found some random nick, and then gave them a random message with a NSFW link :s
23:40:55 * ivanm humbly requests hotaru2k3's forgiveness
23:41:01 <pumpkin> ivanm: nah, it's a fun site :P you should read it
23:41:16 <pumpkin> schadenfreude at its best
23:41:18 <ivanm> hornblower: you still need the String on the end
23:41:21 <ivanm> hornblower: yes
23:41:25 <ivanm> but you shouldn't
23:41:49 <ivanm> unless you're doing something like \ (x:xs) -> ..., and you know you won't have an empty list
23:41:49 <hornblower> how do i add the String?
23:41:57 <ivanm> hornblower: I already told you ;-)
23:42:10 <hornblower> remove the ++ ?
23:42:18 <ivanm> yeah
23:42:24 <ivanm> but that will probably get you another error
23:42:24 <hornblower> ahh that worked
23:42:25 <hornblower> thanks
23:42:33 <hornblower> it loaded this time actually
23:42:40 <ivanm> oh? it must do the function application before ++ then
23:43:18 <hornblower> sweet! it works
23:43:21 <PetRat> For example, import Data.List works fine... I can use isPrefixOf... according to the docs, import Data.Word promises to make Word8 (and Word64, etc.) available in the same way.
23:43:21 <hornblower> thank you my friend
23:43:34 <hornblower> no more scientific
23:43:48 <hornblower> how do i copy/paste the output ?
23:43:59 <ivanm> hornblower: as you normally would?
23:44:07 <ivanm> and what's wrong with scientific notation?
23:44:11 <hornblower> you mean highlight with the mouse?
23:44:24 <hornblower> because the values are not so small...
23:44:40 <ski> @paste
23:44:41 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:44:41 <ski> ?
23:44:56 <hornblower> ivanm: how do i copy the output?
23:45:31 <ivanm> hornblower: how would you normally copy the values and paste them somewhere?
23:45:43 <hornblower> highlight, ctrl-c , then ctrl-v
23:45:54 <zsol> bingo
23:46:02 <hornblower> it doesn't let me highlight.. nothing happens
23:46:09 <ivanm> which OS are you using?
23:46:15 <hornblower> XP
23:46:17 <ivanm> and what are you running ghci in?
23:46:17 <PetRat> bump: For example, import Data.List works fine... I can use isPrefixOf... according to the docs, import Data.Word promises to make Word8 (and Word64, etc.) available in the same way.
23:46:18 <zsol> are you using it from cmd?
23:46:26 <hornblower> it loads a DOS window, yes
23:46:30 <glguy> In XP you have to right-click, go to select
23:46:30 <PetRat> But they aren't
23:46:36 <glguy> or something similar
23:46:44 <hornblower> no clicks work in the window
23:46:46 <ivanm> eh, a deprecated OS :p
23:46:49 <glguy> possibly on the application icon
23:46:50 <zsol> yeah, rightclick, click on "mark"
23:46:52 <glguy> in the title bar
23:46:53 <zsol> then highlight the stuff
23:47:06 <glguy> Fedora is a free upgrade
23:47:08 <zsol> then rightclick again to let the hilite go away
23:47:10 <zsol> then you can paste
23:47:12 <PetRat> In XP you right-click, "Select All", then hit Enter to copy to the paste buffer
23:47:18 <hornblower> ok, mark worked. thanks
23:47:33 <PetRat> The highlighting goes away when you hit Enter
23:47:45 <hornblower> thanks everyone for your HALP!
23:47:52 <zsol> you're walcome
23:48:08 <pumpkin> > help
23:48:10 <lambdabot>   Not in scope: 'help', maybe you meant to type 'halp'?
23:48:19 <zsol> eheh
23:48:21 <ivanm> @slap hornblower
23:48:21 * lambdabot smashes a lamp on hornblower's head
23:48:21 <zsol> :t halp
23:48:22 <lambdabot> Doc
23:48:30 <pumpkin> sigbjorn is such a cool name
23:48:34 <ivanm> zsol: :o
23:48:49 <zsol> what?
23:48:57 <PetRat> bump: For example, import Data.List works fine... I can use isPrefixOf... according to the docs, import Data.Word promises to make Word8 (and Word64, etc.) available in the same way, but it's not. This is ghci on Windows
23:48:59 <pumpkin> I wish my name were sigbjorn
23:49:15 <pumpkin> PetRat: :m + Data.Word
23:49:43 <hornblower> now i'm going to calculate moby dick. hope it doesn't crash my puter'
23:50:08 <ivanm> pumpkin: there's this wonderful thing I believe called "deed poll"
23:50:13 <ivanm> it lets you change your name...
23:50:15 <PetRat> pumpkin: I type let x = Word8 1 and get "not in scope"
23:50:22 <ivanm> alternatively, there's always /nick ...
23:50:30 <ivanm> PetRat: Word8 is  _type_, not a _value_
23:50:46 <ivanm> > let x = 1 :: Word8 in show x
23:50:46 <pumpkin> > let x = 1 :: Word8
23:50:48 <lambdabot>   <no location info>: parse error on input `;'
23:50:48 <lambdabot>   "1"
23:50:53 <pumpkin> whoops, I failed :)
23:50:57 * pumpkin defers to ivanm
23:50:57 <ivanm> pumpkin: heh
23:51:01 <ivanm> of course you do!
23:51:01 <hornblower> crap... stack overflow
23:51:02 <ivanm> ;-)
23:51:18 <pumpkin> hornblower: add seq and all your problems will be gone!
23:51:25 <PetRat> well I wasn't using it as a value, but I was trying to use it as a constructor "let x = Word8 1"
23:51:27 <hornblower> how do i add seq?
23:51:28 <ivanm> pumpkin: sshhh!!!
23:51:37 <ivanm> don't get them hooked on seq this early!
23:51:41 <pumpkin> lol
23:51:41 <ivanm> PetRat: it isn't a constructor
23:51:49 <ivanm> it's a type
23:51:49 <pumpkin> ivanm: when is it ok to get hooked?
23:51:53 <ivanm> pumpkin: never
23:51:58 <pumpkin> oh
23:52:00 <pumpkin> boo :(
23:52:13 <PetRat> Okay I get it ivanm++
23:52:19 <ivanm> you should only use seq judiciously after enough profiling to determine your space/time leaks
23:52:23 <hornblower> pumpkin: please explain seq
23:52:25 <ivanm> PetRat: :D
23:52:28 <pumpkin> :t seq
23:52:29 <lambdabot> forall a t. a -> t -> t
23:52:42 <ivanm> hornblower: fix your algorithm up before resorting to seq
23:52:44 <pumpkin> hornblower: when you ask for seq's return value, it gives you its second parameter after evaluating* its first
23:52:58 <pumpkin> *where evaluating might not mean what you think it means
23:53:23 <zsol> seq is evil.
23:53:32 <sbahra> What's new, pumpkin?
23:53:34 <ivanm> hornblower: e.g. rather than using sequence (map ...), use mapM_
23:53:39 <sbahra> Any interesting Haskell projects?
23:53:40 <hornblower> where do i insert :t seq ?
23:53:45 <sbahra> hornblower, ghci
23:53:48 <ivanm> actually, you should have used sequence_ I believe...
23:53:58 <ivanm> @hoogle (Monad m) => [m a] -> m ()
23:53:59 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
23:53:59 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
23:53:59 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
23:54:08 <sbahra> :t sequence
23:54:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:54:10 <ivanm> yeah, sequence_
23:54:20 <sbahra> Ugly name
23:54:24 <pumpkin> sbahra: cramming a paper for next week for now, that unfortunately has nothing to do with haskell :( otherwise, been working on uvector, an arm disassembler, fold fusion, and a machine learning lib
23:54:35 <sbahra> pumpkin, cool
23:54:39 <sbahra> pumpkin, what's the status of uvector?
23:54:40 <hornblower> ivanm: its tell me not in scope again
23:54:48 <sbahra> pumpkin, is there some x86 hackery I can help with?
23:54:49 <hornblower> ivanm: its telling me not in scope again
23:55:10 <pumpkin> sbahra: it's getting safer and more thoroughly tested for now, and I've been working on adding lazy uvectors (a bit like a generalization of lazy bytestrings)
23:55:29 <hornblower> do i need to import something else to use MapM_ ?
23:55:42 <pumpkin> sbahra: it has almost no machine-specific code in it, but it probably could... you should discuss it with dons (I'm reluctant to make big decisions with regards to it in case he doesn't like them)
23:55:50 <sbahra> pumpkin, I see
23:55:51 <ski> @index mapM_
23:55:51 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
23:56:08 <sbahra> pumpkin, FFI is pretty expensive.
23:56:08 * edwardk waves hello.
23:56:13 <zsol> o/
23:56:14 <sbahra> Hi edwardk
23:56:21 <ski> morgen edwardk
23:56:43 <pumpkin> sbahra: yeah, I was thinking it might be more productive to add primops for them, since I've been exploring GHC some more
23:56:54 <sbahra> pumpkin, primops?
23:57:05 <pumpkin> primitive operations in GHC
23:57:08 <sbahra> http://hackage.haskell.org/trac/ghc/wiki/Commentary/PrimOps
23:57:21 <pumpkin> yup
23:57:23 * edwardk wants some kind of Storable than provides a type level natural rather than an Int for its size =/
23:57:23 <sbahra> Interesting
23:58:14 <ivanm> hornblower: mapM_, not MapM_
23:58:26 <pumpkin> sbahra: even just making one inline primop for each SSE instruction could be a good start, I've been thinking
23:58:43 <pumpkin> we'd need to add SSE to the cmm generator though
23:58:58 <sbahra> Not very useful though (that is, inline pimops for a single SSE).
23:59:25 <sbahra> Since you really need to schedule instructions in a certain way if you expect throughput.
23:59:54 <pumpkin> you'd be able to express order, but I guess it'd be clunky
