00:24:14 <tux-foo> given two mathematical Types:       data T1 = C1 Bool T2    and    data T2 = C2 foo bar.  Is there a function which can
00:24:27 <tux-foo> map [T2] to [T1] given a Bool ?
00:25:00 <tux-foo> i.e. can I apply the C1 constructor as a the function argument of a method as map ?
00:25:15 <Axman6> map (C1 bool) listOfT2
00:25:17 <Baughn> Sure. A constructor's a function too.
00:25:32 <tux-foo> Axman6, thanx, I was hoping that was allowed
00:25:39 <tux-foo> Baughn, thanx
00:25:51 <Axman6> data constructors are functions like anything else
00:25:59 <Axman6> well... like functions >_>
00:26:02 <Axman6> :t Just
00:26:03 <lambdabot> forall a. a -> Maybe a
00:26:10 <Axman6> :t (:)
00:26:11 <lambdabot> forall a. a -> [a] -> [a]
00:26:26 <Eelis> Axman6: i read in the log that you felt geordi's code could be improved, but you never seemed to get beyond saying that the problem was in the use of underscores in function names. if you have some more substantial suggestions, i'd love to hear them and learn
00:26:29 <tux-foo> Axman6, ^^
00:26:37 <mpeter> Axman6: want to hear a song i wrote
00:26:40 <mpeter> listen to it anyway
00:26:51 <mpeter> http://128.230.217.133/mll03/ometotchtli/nymph/sdy.mp3
00:27:09 <Axman6> Eelis: the code is far too cluttered and unclear. functions are fat too long etc
00:27:12 <Axman6> far*
00:27:36 <mpeter> put on some headphones and turn it up
00:27:41 <Eelis> Axman6: i'm curious, what's the "etc"?
00:28:01 <Axman6> i don't have the code anymore, so i can't remember
00:28:48 <Eelis> i see
00:29:41 <cnwdup> @type match
00:29:42 <lambdabot> Not in scope: `match'
00:29:59 * mpeter stares at Axman6 
00:32:45 <Saizan> mpeter: stay on topic
00:33:04 <mpeter> the topic seems to be bashing Axman6
00:33:09 <mpeter> at least i'm being nice about it
00:33:23 <Axman6> o.O
00:33:37 <mpeter> are you listening to my song Axman6
00:33:42 <Saizan> the topic is haskell.
00:33:51 <Axman6> no, my internet's being shitty and it won't load
00:33:52 <mpeter> well my song is named 'monad'
00:33:57 <mpeter> so there
00:39:59 * mpeter throws up a gallon of blood
00:41:32 <mpeter> observed condition a) dons is an op in #haskell
00:41:45 <mpeter> observed condition b) there is always an advertisement for 'real world haskell' in the topic
00:41:55 <mpeter> observed condition c) dons wrote 'real world haskell'
00:42:09 <mpeter> emergent theory a) operators use the topic to make money
00:42:39 <mpeter> you people are so boring
00:43:03 <Gracenotes> faulty conclusion a) assuming motivation
00:43:14 <mpeter> it's not a conclusion
00:43:16 <ziman> a quick observation: a) RWH is available on teh internetz for free reading
00:43:24 <mpeter> conclusions are definitive
00:43:50 <mpeter> only what appears to be a probable explanation
00:43:54 <mpeter> that or his own self-eggrandizement
00:44:24 <ziman> i think rwh is more benefit to the community than to the authors themselves
00:44:37 <mpeter> i like learn you a haskell more
00:47:43 <zakwilson> They're both good. I found LYAH to be a bit too basic for me, as I already knows the basics of FP.
00:47:45 <nlogax> i think they complement each other nicely
00:47:53 <ziman> rwh covers different, (surprise!) more real-world topics
00:48:03 <mpeter> well i don't like dons to begin with, either
00:48:13 <TheRealMarko> I think it's highly inprobable that dons is getting rich through rwh, if that's what you're concerned about. From what i hear writing cs books in general results in pretty bad money/hour ratio.
00:48:20 <mpeter> not that that would introduce an element of bias into my theory
00:49:08 <TheRealMarko> I wouldn't mind seeing LYAH in dead tree form though.
00:49:56 <zakwilson> I dunno... learn (trendy thing) in (n where n < 30) days might be profitable.
00:50:08 <zakwilson> Though niether that nor RWH are really CS books.
00:50:29 <mpeter> my fortune the other day was 'computer science is the post-during decline into formal systems theory'
00:50:47 <Gracenotes> sounds fun
00:50:59 <mpeter> post-turing*
00:51:27 <Saizan> it's funny that we get strong opinions on that from both sides in this channel
01:12:12 <tux-foo> I am using happy to generate a parser, and unfortunately, it says:    file.ly:<last_line>: Parse error
01:12:21 <tux-foo> can this be debugged some way?
01:43:01 <kadaver> what do you think is better, a delete from a tree should 1. just return the tree without the value and dont report if it was successfully deleted, ie if it isnt in the tree then just return the tree as it was. or 2. return the deleted value and the tree,ie (Maybe value, Tree) ?
01:44:17 <Zao> kadaver: I assume that values may not appear more than once in a tree?\
01:44:35 <kadaver> yes
01:49:37 <quicksilver> kadaver: (Maybe value, Tree) is the more general
01:49:44 <quicksilver> kadaver: it's simple to write the other from that.
02:04:54 <Kippetje> hello
02:05:17 <QtPlaty[HireMe]> Hi
02:07:32 <tux-foo> I have this grammar file http://rafb.net/p/vJfE2x41.html for happy, when I run happy over it it errors with no usable message, i.e. it says:
02:08:02 <tux-foo> herbert@foo-nix ~/svn/vb $ happy foo.ly
02:08:02 <tux-foo> foo.ly:44: Parse error
02:08:45 <tux-foo> I have been debugging the file for some time, and fail to see what is wrong (moreover, I simplified the grammar to what is shown in the paste).
02:08:47 <QtPlaty[HireMe]> tux-foo: Whats on line 44?
02:08:57 <tux-foo> QtPlaty[HireMe], line 43 is the last line.
02:09:24 <tux-foo> QtPlaty[HireMe], i.e. Mayve an EOF? I dunno.
02:09:26 <QtPlaty[HireMe]> Sounds like you have something left open that needs to be closed.
02:09:27 <quicksilver> that means it wasn't expecting the file to end yet
02:09:44 <tux-foo> quicksilver, well, yes
02:09:55 <tux-foo> quicksilver, I have copied the grammar from the manual, and tried that.
02:10:03 <tux-foo> But that also failed (same error)
02:10:24 <tux-foo> Moreover, the only error I can come up with is that I specify nowhere what the start symbol should be.
02:10:33 <tux-foo> but the manual doesn't do anything like this.
02:10:49 <tux-foo> http://haskell.org/happy/doc/html/sec-using.html
02:11:55 <tux-foo> Moreover, the haskell code in the grammar file does get accepted by ghci
02:13:34 <Kippetje> Does anyone know how I can run java programs from haskell?
02:13:58 <Axman6> sam as you'd run any other programs i assume
02:14:08 <Kippetje> and how do i do that
02:14:31 <QtPlaty[HireMe]> Kippetje: Via a FFI?  Or as an executable on the other end of a pipe?
02:14:36 <wahjava> Kippetje: System.Process.shell
02:14:41 <quicksilver> tux-foo: missing end of line at the end of the last line?
02:15:11 <tux-foo> quicksilver, might be, but then the close brace should not have a newline after it?
02:15:20 <tux-foo> or .. ?
02:15:28 <quicksilver> tux-foo: yes, it should.
02:16:17 <quicksilver> hmm
02:16:29 <quicksilver> I wonder why you're using happy and not parser combinators anyway ;)
02:17:08 <tux-foo> quicksilver, http://rafb.net/p/38m16H23.html
02:17:14 <tux-foo> it has a newline at the end.
02:17:51 <tux-foo> quicksilver, parser combinator?
02:19:27 <tux-foo> quicksilver, I see your point, still, the happy grammar file should work. The only mistake I can see is that I am inputting it wrong to happy.
02:19:46 <quicksilver> I can replicate your error btw.
02:20:27 <quicksilver> tux-foo: it's because you called it .ly
02:20:29 <quicksilver> that's a .y file.
02:21:25 <quicksilver> .ly - literate happy file
02:21:27 <quicksilver> which that wasn't.
02:23:06 <dons> hackathon underway
02:23:12 <dons> 52 people in two rooms. it's big!
02:23:21 <quicksilver> nice.
02:23:35 <quicksilver> hack well.
02:26:44 <tux-foo> quicksilver, ouch
02:26:47 <tux-foo> thanx
02:27:07 <tux-foo> quicksilver, that was rather stupid of me. sorry
02:27:14 <quicksilver> it's OK. I didn' tknow either.
02:27:17 <quicksilver> Mind you I've never used happy.
02:27:25 <quicksilver> parser generators are harder to use than parser combinators.
02:28:02 <tux-foo> quicksilver, This is an assignment, where it is required to use a parser generator.
02:28:09 <byorgey_> wow, 52 people?!
02:28:25 <quicksilver> ah, fair enough.
02:28:47 <tux-foo> quicksilver, it works! wow. now to try my real huge grammar file....
02:37:31 <kadaver> wow Pirate bay guys were sentenced to 4-5$millions in fines and 1 year in jail
02:38:40 <wahjava> kadaver: wtf
02:38:47 <wahjava> kadaver: judgement is out...?
02:39:07 <pejo> How about taking that in -blah?
02:54:39 <kadaver> wahjava: http://torrentfreak.com/the-pirate-bay-trial-the-verdict-090417/
02:54:48 <wahjava> kadaver: http://en.wikipedia.org/wiki/The_Pirate_Bay_Trial#Verdict
02:55:19 <kadaver> I heard the tracker is written in Haskell so they are bringing SPJ in for trial too
02:55:57 <quicksilver> -> -blah
02:56:28 <kadaver> im there ->
02:57:36 <wahjava> :-D
03:02:36 <da-x> neatest way to parse a whole text file that contains a list of show-able/read-able data intermixed with whitespace?
03:03:47 <quicksilver> doesn't sound unambiguous
03:03:53 <quicksilver> "Foo Bar Baz"
03:04:10 <quicksilver> how do you know if that's three unary constructors or one binary construct + its two parameters ?
03:04:34 <malcolmw> quicksilver: you mean nullary of course
03:04:51 <quicksilver> thank you.
03:05:02 <quicksilver> how do you know if that's three nullary constructors or one binary construct + its two parameters ?
03:05:30 <malcolmw> or one unary followed by a nullary, or a nullary followed by a unary...
03:06:57 <malcolmw> although, I suppose if you know the full type of data expected, it isn't so hard
03:44:05 <cnwdup> @pl (\(_,x,_) -> x)
03:44:06 <lambdabot> (line 1, column 7):
03:44:06 <lambdabot> unexpected ","
03:44:06 <lambdabot> expecting letter or digit, operator or ")"
03:44:06 <lambdabot> ambiguous use of a non associative operator
03:44:37 <cnwdup> @pl (\(a,b,c) -> b)
03:44:38 <lambdabot> (line 1, column 7):
03:44:38 <lambdabot> unexpected ","
03:44:38 <lambdabot> expecting letter or digit, operator or ")"
03:44:38 <lambdabot> ambiguous use of a non associative operator
03:44:41 <cnwdup> Hum?
03:44:44 <RayNbow> pl doesn't like triples
03:44:49 <cnwdup> Okay.
03:45:22 <BONUS> you can't pointlessly make an (a,b,c) -> c function, imho
03:45:23 <Gracenotes> you'll have to define your own functions
03:45:29 <Gracenotes> fst3, snd3, thd3
03:45:43 <cnwdup> Gracenotes, BONUS, okay. Thanks. (:
03:45:55 <Gracenotes> or, even better, make your own datatype with record names
03:45:58 <BONUS> @pl could give a better error though
03:45:58 <lambdabot> could give a better error though
03:46:00 <Gracenotes> if applicable :)
03:46:07 <BONUS> haha
03:47:01 <Axman6> @pl /me could give a better error
03:47:01 <lambdabot> (line 1, column 1):
03:47:01 <lambdabot> unexpected "/"
03:47:01 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:47:04 <Axman6> :(
03:47:09 <cnwdup> Gracenotes, I wouldn't need that anyways if I could correctly use regex in Haskell. :D It's only temporary until I know how to do it better. Thus I don't care if its dirty for now.
03:47:16 <RayNbow> @pl \x y z -> (z, y, x)  -- slight rectification, lambdabot doesn't have a problem with triples... as long as you don't use it in a pattern match :p
03:47:17 <lambdabot> flip (flip . flip (,,))
03:51:58 <Gracenotes> > let could = liftA2; give = flip map; a = const [111,32,114,108,121]; better = const chr in could give a better error
03:52:00 <lambdabot>   "o rly"
03:52:08 <Gracenotes> :\
03:52:19 <Gracenotes> TRULY AN EXCELLENT USE OF FIVE MINUTES
03:53:17 <Axman6> agreed
03:53:54 <koala_man> seconded
03:54:08 <RayNbow> @let say x = var x
03:54:09 <lambdabot>  Defined.
03:54:12 <RayNbow> > say "o rly"
03:54:14 <lambdabot>   o rly
03:54:55 <Gracenotes> but you couldn't give a better error!
03:59:00 <RayNbow> > really (cale == awesome)
03:59:02 <lambdabot>   ya rly!
03:59:10 * RayNbow has too much time on his hands :p
03:59:23 <Athas> Huh, I just had a segfault in my program.
03:59:27 <Athas> Is liftIO unsafe?
04:00:19 <Peaker> Athas: it should be safe
04:00:23 <Peaker> Athas: are you using opengl?
04:00:30 <Peaker> Athas: what libraries are you using?
04:00:33 <Athas> No, just regular print'ing.
04:00:58 <Athas> The line is just: liftIO $ print <somestring>
04:01:02 <Gracenotes> >:[
04:01:16 <Peaker> Athas: maybe you've had a problem from before this
04:02:42 <Athas> I can do it without problem elsewhere in the program.  Odd.
04:04:07 <Peaker> Athas: seg faults may mean anything - the problem doesn't necessarily lie in the exact place the seg fault occurs
04:04:17 <Gracenotes> ]:< .. man with sombrero
04:04:21 <lunabot>  luna: parse error on input `..'
04:04:29 <Gracenotes> wha.
04:05:50 <Axman6> C]:< <- bigger sombrero
04:15:52 <Gracenotes> @type awesome
04:15:53 <lambdabot> [Char]
04:16:03 <Gracenotes> > cale
04:16:05 <lambdabot>   "awesome"
04:19:45 <ray> > kale
04:19:47 <lambdabot>   Not in scope: `kale'
04:20:31 <kadaver> > intercalate '_' "ray"
04:20:32 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
04:21:09 <kadaver> > intersperse '_' "ray"
04:21:11 <lambdabot>   "r_a_y"
04:21:24 <kadaver> > intersperse '_' "razor"
04:21:26 <lambdabot>   "r_a_z_o_r"
04:21:39 <kadaver> > map toUpper "razor"
04:21:41 <lambdabot>   "RAZOR"
04:22:18 <kadaver> oneliners involving randomness are a bit tricky in haskell right?
04:22:31 <kadaver> > randomRIO (0::Int, 5)
04:22:32 <lambdabot>   * Exception: "<IO Int>"
04:22:57 <kadaver> no IO for lambdabot?
04:23:04 <Gracenotes> kadaver: usually you use an arbitrary number for a seed
04:25:33 <Peaker> @src intersperse
04:25:33 <lambdabot> intersperse _   []     = []
04:25:33 <lambdabot> intersperse _   [x]    = [x]
04:25:33 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
04:25:33 <Gracenotes> > randomsR (0::Int, 5) (mkStdGen 42)
04:25:33 <lambdabot>   Not in scope: `randomsR'
04:25:33 <Gracenotes> > randomRs (0::Int, 5) (mkStdGen 42)
04:25:33 <lambdabot>   [5,3,1,4,2,1,0,5,0,3,3,3,0,2,2,1,5,1,3,0,2,0,0,4,4,4,0,2,5,0,4,5,0,2,4,3,0,...
04:25:33 <Gracenotes> of course, that is useless in many applications, but it suffices for lambdabot
04:25:33 <Peaker> @type randomRs
04:25:33 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
04:25:38 <Gracenotes> also note that the StdGen is the last argument of random functions, so you can do "newStdGen >>= randomRs (0::Int, 5)" and then fmap that to the function using the list
04:26:45 <Peaker> @hoogle (RandomGen g, Random a) => g -> [a]
04:26:45 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
04:26:45 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
04:26:45 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
04:26:47 <kadaver> i want : > map (if odd rand then toUpper else toLower) "hello"
04:26:56 <Peaker> why not use randoms?
04:27:14 <Peaker> > take 5 . map (*2) . randoms $ 5
04:27:16 <lambdabot>   Add a type signature
04:27:29 <Gracenotes> Peaker: oh yeah, or that
04:27:30 <Peaker> > take 5 . map (*2) . randoms $ (5::Int)
04:27:31 <lambdabot>       No instance for (RandomGen Int)
04:27:31 <lambdabot>        arising from a use of `randoms' ...
04:27:34 <EvilTerran> kadaver, i think you can generate Bools randomly without going through Ints and odd/even
04:27:37 <Gracenotes> randoms is a shortcut
04:27:43 <Peaker> > take 5 . map (*2) . randoms . mkStdGen $ (5::Int)
04:27:44 <Gracenotes> is uses newStdGen behind the scenes
04:27:44 <lambdabot>   [15553123302608653886,5321184429618513146,-397869584307178280,-954572011769...
04:27:57 <Gracenotes> it
04:28:08 <Peaker> @type mkStdGen
04:28:09 <lambdabot> Int -> StdGen
04:28:18 <Gracenotes> but, regardless, the fmapping opportunities are endless
04:28:21 <Peaker> @type rands
04:28:22 <lambdabot> Not in scope: `rands'
04:28:23 <kadaver> > let r = take 1 $ randomRs (0::Int, 5) (mkStdGen 42) in map (\x -> if odd r then toUpper x else toLower x) "hello"
04:28:23 <kadaver> ^^ which wont work because it is the same for all
04:28:23 <kadaver> take length of wo i gues sorks
04:28:24 <kadaver> > let r = take (length "hello") $ randomRs (0::Int, 5) (mkStdGen 42) in map (\x -> if odd r then toUpper x else toLower x) "hello"
04:28:24 <lambdabot>       No instance for (Integral [Int])
04:28:24 <lambdabot>        arising from a use of `odd' at ...
04:28:25 <lambdabot>       No instance for (Integral [Int])
04:28:25 <lambdabot>        arising from a use of `odd' at ...
04:28:38 <Peaker> @let rands = randoms . mkStdGen
04:28:39 <lambdabot>  Defined.
04:28:41 <Peaker> @type rands
04:28:42 <lambdabot> forall a. (Random a) => Int -> [a]
04:29:16 <Peaker> > map (/0.0) . rands $ 0
04:29:17 <lambdabot>   [Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,Infinity,In...
04:29:27 <EvilTerran> > rands 0 :: [Bool]
04:29:29 <lambdabot>   [True,True,True,False,False,True,True,True,True,False,True,False,False,Fals...
04:30:30 <Peaker> > map not . rands $ 0
04:30:31 <lambdabot>   [False,False,False,True,True,False,False,False,False,True,False,True,True,T...
04:31:12 <kadaver> > map (\x -> if odd rands then toUpper x else toLower x) "hello"
04:31:13 <lambdabot>       No instance for (Integral (Int -> [a]))
04:31:13 <lambdabot>        arising from a use of `o...
04:31:43 <Axman6> > map (\p -> if p then '1' else '0') . rands $ 1234
04:31:44 <lambdabot>   "11101011110010011100010001110010010111001100001110001101011000100001001011...
04:32:01 <ray> 10100101010101010101010101010101101010001010001100101102
04:33:36 <Gracenotes> YOU HAVE NO CHANCE TO SURVIVE
04:33:46 <Gracenotes> MAKE YOUR TIME
04:34:51 <Axman6> @pl (\p -> if p then '1' else '0')
04:34:51 <lambdabot> flip (flip if' '1') '0'
04:34:56 <Axman6> >_<
04:35:30 <kadaver> > map (\x -> if odd (head rands) then toUpper x else toLower x) "hello"
04:35:31 <lambdabot>   Couldn't match expected type `[a]'
04:35:34 <kadaver> ?
04:35:35 <bavardage> any hints on how to make a lamba calc evaluator?
04:35:38 <Gracenotes> bool '1' '0'
04:35:59 <Gracenotes> bavardage: completely evaluate, with no free variables allowed?
04:36:06 <bavardage> I don't know
04:36:10 <bavardage> I have no idea how to approach this
04:36:20 <bavardage> even what I should try to achieve
04:36:29 <kadaver> > map Just x
04:36:30 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Expr'
04:36:33 <kadaver> > map Just [1,2,3]
04:36:35 <lambdabot>   [Just 1,Just 2,Just 3]
04:36:42 <bavardage> shoudl I by trying to apply alpha,beta,eta substitution?
04:36:47 <kadaver> > map Nothing [1,2,3]
04:36:48 <lambdabot>   Couldn't match expected type `a -> b'
04:36:51 <bavardage> and when do I stop 'eval'ing
04:36:59 <kadaver> > map (\_ -> Nothing) [1,2,3]
04:37:00 <lambdabot>   [Nothing,Nothing,Nothing]
04:37:07 <Gracenotes> bavardage: a complete evaluator would be less theoretical and slightly more intuitive
04:37:18 <bavardage> uhhuh
04:37:31 * pumpkin wants to be at the hackathon
04:37:32 <Gracenotes> no complicated substitution rules or de Bruijn indices
04:37:43 <bavardage> no clue what those are, so dw about that :D
04:37:54 <bavardage> but at what stage am I 'done'
04:37:59 <Gracenotes> they're covered in TAPL, if you'd like to look into it. and other places
04:38:03 <bavardage> what should the final result of evaluating something be
04:38:44 <Gracenotes> a somewhat intuitive way is to have an 'untyped' type
04:38:47 <bavardage> btw, I'm wanting untyped
04:38:59 <bavardage> yeah I'm not making a typed version
04:39:14 <Gracenotes> data U = F (U -> U) | B Bool | S Int .. this should be your final result, if you want Bool and Int extensions
04:39:32 <Gracenotes> you can have primitive Bool, primitive Int, and some function mapping between them.
04:39:56 <Gracenotes> even a function mapping between functions
04:39:58 <bavardage> > type Identifier = Char
04:39:58 <bavardage> > data Term = Variable Identifier
04:39:58 <bavardage> >     | Application Term Term
04:39:58 <bavardage> >     | Lambda Identifier Term
04:39:58 <bavardage> >     | Let Identifier Term
04:40:01 <bavardage> >     deriving ShowI have this atm
04:40:02 <lambdabot>   <no location info>: parse error on input `|'
04:40:02 <lambdabot>   <no location info>: parse error on input `|'
04:40:02 <lambdabot>   <no location info>: parse error on input `type'
04:40:02 <lambdabot>   <no location info>: parse error on input `|'
04:40:02 <lambdabot>   <no location info>: parse error on input `data'
04:40:04 <lambdabot>   <no location info>: parse error on input `deriving'
04:40:07 <bavardage> oops :P
04:40:12 <Gracenotes> ya right
04:40:25 <bavardage> soo. what should be the next step even
04:40:26 <Gracenotes> okay, so that's good so far. let might be a bit complicated
04:40:38 <bavardage> kk forget let then
04:40:45 <bavardage> I'll just ignore it for now
04:41:25 <Gracenotes> maybe adding a boolean extension will make it more clear, since you're not merely dealing with functions. | Boole Bool | Cond Term Term Term
04:41:47 <Gracenotes> so then your untyped type U = F (U -> U) | B Bool
04:41:50 <bavardage> can I not just use church booleans?
04:42:01 <Gracenotes> not in the evaluator itself
04:42:07 <bavardage> oh kk
04:42:10 <bavardage> so I make that type too
04:42:17 <Gracenotes> that's after you write it. An extra type can't hurt, though, for you to see results
04:42:26 <Gracenotes> and your evaluator will be of the type Term -> U
04:42:37 <Gracenotes> (I'd call it an Expr personally, but same thing :)
04:42:53 <Gracenotes> this is the way I implemented it, so YMMV
04:42:58 <bavardage> ooh kk
04:43:12 <Gracenotes> then you'll need an extra function with a parameter to keep track of the variables in scope
04:43:27 <bavardage> hmm?
04:43:28 <Gracenotes> like, Map Identifier Term -> Term -> U
04:43:45 <bavardage> that was what?
04:43:48 <bavardage> a function?
04:43:57 <Gracenotes> yes, the helper function that does most of the work
04:44:10 <bavardage> which maps an identifier to a paticular term?
04:44:13 <Gracenotes> so whenever you come across a "Variable blah", look for it in the Map
04:44:21 <bavardage> right
04:44:31 <bavardage> map, are we talking about an actual Map or a function named map
04:44:36 <bavardage> :s
04:44:55 <Gracenotes> an actual Map.
04:45:20 <bavardage> so the function takes  map and a term and returns a U
04:45:23 <Gracenotes> actually, it might be better for you to use a Map Identifier U.
04:45:41 <Gracenotes> but yes, that's the basic idea. You can use an association list if you like, or other stuff to hold information.
04:45:47 <bavardage> and what does this actually do?
04:45:54 <bavardage> you give it an identifier
04:46:03 <bavardage> and it gives you the 'result'?
04:46:33 <Gracenotes> you know how you have a term like.. (\x -> x) y?
04:46:38 <bavardage> yop
04:46:56 <Gracenotes> when you evaluate that, it's an Application
04:47:16 <bavardage> an application of y to (\x -> x)?
04:47:34 <bavardage> which evals to y/
04:47:44 <Axman6> :t (\x -> x x)
04:47:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:47:45 <lambdabot>     Probable cause: `x' is applied to too many arguments
04:47:45 <lambdabot>     In the expression: x x
04:47:46 <Gracenotes> right. so you transform (\x -> x) into a U, with the F constructor (making it a U -> U)
04:48:08 <Gracenotes> and y is a free variable, so you look it up in the Map, getting another U
04:48:23 <bavardage> yup
04:48:30 <Gracenotes> then with the first being an F (U -> U), and the second being a U, you apply them, yielding a U.
04:48:38 <bavardage> oh kk
04:48:39 <Gracenotes> in this model
04:49:11 <bavardage> and if y isn't in the map?
04:49:29 <Gracenotes> then you can throw an error, if you like, or whichever
04:49:33 <bavardage> yop
04:49:36 <bavardage> die ungracefully
04:49:38 <bavardage> I can do that
04:49:39 <Gracenotes> or give it a default value of "False", or something
04:49:51 <bavardage> kk
04:50:23 <bavardage> btw, does eval have type eval :: Term -> U?
04:50:23 <Gracenotes> when you transform a lambda expression like (\x -> x) into a U, you make it into an F (U -> U) that takes a U and returns a U, but you also have to make "x" refer to the U it takes
04:50:52 <Gracenotes> here's eval:... eval x = evalWith Map.empty x
04:51:16 <Gracenotes> evalWith :: Map Identifier U -> Term -> U
04:51:26 <bavardage> right
04:51:53 <Gracenotes> here are some example cases: evalWith env (Boole b) = B b
04:52:27 <Gracenotes> evalWith env (Variable c) = fromJust (Map.lookup c env)
04:53:02 <bavardage> kk
04:53:14 <Gracenotes> again, YMMV, but this is a reasonable framework. If you like you can add an Int extension too, in addition to Bool.
04:53:56 <bavardage> or I could use church?
04:54:03 <bavardage> and then when I get a result
04:54:07 <bavardage> call it with (1+) 0?
04:55:07 <Gracenotes> I suppose, but it wouldn't be a natural fold, since those don't necessarily compose well type-wise in Haskell
04:55:50 <bavardage> what wouldn't be a natural fold?
04:56:31 <quicksilver> it would be type safe if you interpose the write number of 'unU's in there
04:56:39 <quicksilver> or whatever you're calling it
04:56:43 <quicksilver> s/write/right/
04:58:11 <Athas> I'm having an issue debugging my program... for a given line in a function, I need information about the call stack at the time that line is reached.
04:58:15 <Athas> I use GHC.
04:58:27 <Athas> How would I go about getting this information?
05:00:15 <Gracenotes> bavardage: okay, here's a basic skeleton, hope I didn't screw it up.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3868
05:00:28 <nornagon> Athas: getting a call stack is inherently difficult in ghc
05:00:48 <bavardage> oh thanks :D
05:00:51 <nornagon> although i haven't looked too deep into ghci's debugging functionality
05:00:54 <skorpan> :t error
05:00:55 <skorpan> :t fail
05:00:55 <lambdabot> forall a. [Char] -> a
05:00:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
05:01:28 <Athas> nornagon: Right, I suspected that would be the case.
05:01:44 <byorgey> ghc's runtime doesn't even use a 'call stack' as such.  at least not in the same way as does, say, C.
05:01:46 <Athas> Is there a tool to generate who-calls information for Haskell programs, in that case?
05:01:46 <Saizan_> ?google ghci debugger
05:01:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html
05:01:48 <lambdabot> Title: 3.5.�The GHCi Debugger
05:01:49 <Deewiant> Athas: Have a look at http://haskell.org/sitewiki/images/0/0a/TMR-Issue10.pdf
05:02:24 <Deewiant> Page 16 onwards
05:03:03 <Saizan_> if you run the expression under :trace you can walk the history backwards to get that kind of information
05:03:08 <Athas> I shall, thanks.
05:04:05 <Gracenotes> bavardage: :) and if that works, Ints don't require much creative work. Like any dynamic-ish type system it gets ugly if there's a type mismatch, but what can ya do.
05:07:14 <bavardage> oh thanks
05:07:29 <bavardage> btw, I think I've worked out errors too
05:07:38 <bavardage> at this very early stage :P
05:11:57 <Gracenotes> bavardage: here's something to throw at it you're done... Application (Cond (Bool False) (Lambda 'x' (Boole True)) (Lambda 'x' (Application (Variable 'x') (Boole False)))) (Lambda 'x' (Variable 'x'))
05:12:27 <bavardage> right :P
05:12:57 <mun> hi
05:13:04 <lenni_-_> not stricly haskell but, is it possible to convert a unary operation into something that foldr/foldl accept?
05:13:06 <mun> does anyone know how i can generate the html for listing out all the functions and other info?
05:13:25 <kadaver> lenni: example?
05:13:51 <kadaver> > foldl (\_ len -> len+1) 0 [1,2,3]
05:13:53 <lambdabot>   4
05:13:58 <kadaver> eh
05:14:08 <kadaver> > foldl (\_ len -> len + 1) (-1) [1,2,3]
05:14:10 <lambdabot>   4
05:14:10 <lenni_-_> kadaver: i have a piece of coursework that asks me to re-write map using only foldr
05:14:54 <kadaver> > let f = (+1) in foldr (\acc i -> f i : acc) [] [1,2,3]
05:14:56 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
05:14:56 <lambdabot>        Expect...
05:15:01 <kadaver> > let f = (+1) in foldr (\i acc -> f i : acc) [] [1,2,3]
05:15:03 <lambdabot>   [2,3,4]
05:15:31 <Gracenotes> > (if False then (\x -> True) else (\x -> x False)) (\x -> x) -- bavardage.. like this.. okay, I'll stop bugging you :D
05:15:33 <lambdabot>   False
05:16:14 <lenni_-_> kadaver: now, how would I write that in miranda?
05:16:44 * Gracenotes does afk stuff for a bits.
05:18:21 <kadaver> lenni: i dont know miranda sorry
05:18:44 <bavardage> Gracenotes: this is something else to throw at it?
05:19:09 <kadaver> > foldl (\len _ -> len + 1) (-1) [1,2,3]
05:19:09 <bavardage> Gracenotes: wait what :P?
05:19:10 <lambdabot>   2
05:19:11 <Gracenotes> oh, that's just the Haskell translation of the above thing
05:19:12 <kadaver> > foldr (\_ len -> len + 1) 0 [1,2,3]
05:19:14 <lambdabot>   3
05:19:33 <bavardage> oh kk
05:20:34 <bavardage> > (if True then (\x -> x True) else (\x -> x False)) (\x -> x)
05:20:35 <lambdabot>   True
05:20:41 <bavardage> Gracenotes: you typoed ^^
05:21:01 <lenni_-_> kadaver: if it isn't asked too much could you explain what this does, i can translate it to miranda: (\i acc -> f i : acc)
05:21:26 <Gracenotes> bavardage: hm..? That's really the Haskell translation of Application (Cond (Boole False) (Lambda 'x' (Boole True)) (Lambda 'x' (Application (Variable 'x') (Boole False)))) (Lambda 'x' (Variable 'x'))
05:21:59 <bavardage> Gracenotes: did you not miss the x before the true?
05:22:02 <doserj> > foldr (const (+ 1)) 0 [1,2,3]
05:22:03 <lambdabot>   3
05:22:15 <bavardage> I was wondering why it was asymmetric
05:22:41 <bavardage> oh wait
05:22:42 <bavardage> yeah
05:22:50 <Gracenotes> in both cases it returns a Bool
05:22:50 <bavardage> that *is* the correct translation
05:22:57 <bavardage> oh kk
05:23:05 <Gracenotes> a'ight
05:23:15 <bavardage> oh, for the true bit, it just throws away the identifier?
05:23:20 <bavardage> Gracenotes: yeah sorry ;D
05:24:10 <Gracenotes> > (if False then const True else ($ False)) id
05:24:11 <lambdabot>   False
05:24:19 <Gracenotes> yeah.. a bit more idiomatic Haskell ^
05:24:51 <kadaver> lenni: f i applies the function f to i, ie i + 1; f i : acc means cons (f i) acc, cons is append to the beginning of the list.
05:25:38 <kadaver> > (+1) 3
05:25:40 <lambdabot>   4
05:25:48 <lenni_-_> kadaver: fantastic, thanks for your help
05:25:50 <kadaver> > (+1) 3 : []
05:25:52 <lambdabot>   [4]
05:27:06 <tromp> bavardage, you should read Lennart's paper on lambda evaluators
05:27:42 <tromp> http://www.augustsson.net/Darcs/Lambda/top.pdf
05:27:45 <bavardage> thanks
05:30:08 <tromp> you can also look at my implementation of binary lambda calculus
05:30:56 <Gracenotes> and, for that matter, Barengredt's book. hundreds of pages of just lambda calculus
05:31:01 <Gracenotes> x.x
05:31:09 <Itkovian> Any idea what might cause a memory leak when doing f $ take n xs rather than f $ xs ?
05:31:27 <Gracenotes> TAPL is a great book for a more practical, programming-languages-oriented perspective
05:31:31 <Itkovian> I agree that the take will form a new list, yet it can be freed immediately
05:31:44 <bavardage> Gracenotes: wtf
05:31:48 <bavardage> Gracenotes: it seemed to work
05:32:02 <bavardage> tromp: any papers/examples are helpful
05:32:10 <bavardage> *Main> eval test
05:32:14 <bavardage> False
05:32:16 <bavardage> :D
05:32:20 <bavardage> <3 gracenotes
05:32:38 <Gracenotes> nice :) could I see what you made?
05:32:52 <quicksilver> I quite liked barendregt
05:33:06 <bavardage> Gracenotes: sec
05:33:42 <Gracenotes> you should be able to implement the Y-combinator
05:34:21 <pumpkin> zomg don't
05:34:36 <Gracenotes> and, if you add Zero, Succ, and Pred to your terms, an addition function. and a multiplication function, and a factorial function, and fibonacci, and ackerman, and.. mwahaha
05:34:55 <Gracenotes> (or just use Church encoding :P )
05:35:09 <Gracenotes> oh, and you'll need IsZero
05:35:26 <bavardage> http://paste.pocoo.org/show/112936/
05:35:27 <Gracenotes> if you like.
05:35:59 <bavardage> I already have the code for quite a lot of that using haskell lambdas
05:36:03 <bavardage> hopefully I could translate it
05:36:49 <Gracenotes> bavardage: perfect! :D
05:36:53 <bavardage> :D
05:36:59 <bavardage> so next steps yeah
05:37:02 <bavardage> church numerals perhaps
05:37:21 <bavardage> convert all my existing stuff into this notation
05:37:26 <bavardage> maybe make some more prettier operators
05:37:36 <Gracenotes> yeah, see how that works. (perhaps some Term -> Int and Int -> Term helper functions for display might be useful)
05:37:46 <bavardage> yeah
05:38:02 <bavardage> hmm
05:38:06 <mun> if the datatype GlobCmd derives (Eq, Ord, Enum, Bounded) then what does the variable globCmdList :: [GlobCmd]; globCmdList = [minBound .. maxBound] contain?
05:38:07 <vixey> hey did you get pred yet?
05:38:16 <bavardage> vixey: not the non-pair no
05:38:18 <bavardage> *one
05:38:23 <bavardage> I accidentally found the pair one
05:38:28 <bavardage> so I won't use that
05:38:31 <Gracenotes> vixey: he hasn't had a dental operation lately, no
05:38:39 <vixey> how do you mean acidentally what happened?
05:38:46 <bavardage> I was reading up on something else
05:38:48 <bavardage> and BAM
05:38:51 <bavardage> there it was
05:38:58 <bavardage> I was looking for looping stuff iirc
05:39:04 <bavardage> since I couldn't get any recursion working
05:39:12 <bavardage> the whole (n+1,n) thing
05:39:22 <Gracenotes> http://en.wikipedia.org/wiki/Y-combinator
05:40:57 <Gracenotes> apply (apply (Y-combinator) (\f x -> if x is zero then 1 else x * f (pred x) )) 10
05:41:19 <Gracenotes> s/1/succ 0, if you like
05:41:38 <bavardage> is ~ a dissallowed symbol btw?
05:41:46 <bavardage> I wanted to use (~) for application
05:41:58 <ivanm> bavardage: it's reserved
05:42:01 <bavardage> fail
05:42:06 <ivanm> @src partition
05:42:06 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:42:06 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:42:06 <lambdabot>                               | otherwise = (ts, x:fs)
05:42:08 <Gracenotes> hm, this is fun.. I should experiment with the LC again
05:42:09 <ivanm> ^^ see?
05:42:23 * ivanm can never remember what it does though... foce evaluation or something?
05:42:34 <Gracenotes> lazy pattern-matchin
05:42:49 <jedai> mun: Well, if the instances are sane it should contains every GlobCmd
05:42:54 <ivanm> that's the one
05:43:39 * ivanm is debating whether he should restart his app that's been going on for > 20 hrs, at least half of which it hasn't produced any results for even though only 6 more are expected :s
05:44:15 <bavardage> it seems I'm not allowed + either
05:44:37 <bavardage> ivanm: don't give up
05:44:41 <ivanm> bavardage: no, strangely enough...
05:44:42 <bavardage> ivanm: real men don't give up
05:45:50 <ivanm> bavardage: I hate those kind of sayings
05:45:56 <bavardage> hehe
05:46:07 <ivanm> since first of all they don't make sense, and secondly you can't prove them
05:46:07 <bavardage> what does your app do?
05:46:45 <ivanm> generate latin squares (I _think_ up to main class... that's what I'm checking)
05:48:18 <bavardage> what are latin squares?
05:48:32 <bavardage> dw I wikid
05:50:02 <mun> jedai: right. then what should map GlobCmd globCmdList do? does this apply the type GlobCmd to every GlobCmd?
05:50:31 <mun> if data GlobCmd = Foo, would the map return a list containing the result of GlobCmd Foo?
05:50:56 <bavardage> why are all these symbols forbidden :(
05:51:00 <bavardage> @ is forbidden too
05:51:13 <jedai> mun: That's probably a syntax error
05:51:47 <jedai> mun: I don't think GlobCmd is a data constructor, it's just a type, you can't use it like a function and pass it to map
05:51:49 <Ferdirand> @ is for pattern aliases
05:52:09 <bavardage> ah yes :P
05:52:10 <bavardage> haha
05:52:11 <bavardage> shh
05:52:39 <jedai> bavardage: Just use unicode symbols :P
05:52:44 <mun> jedai: right. basically i'm looking at this code here: http://trac.informatik.uni-bremen.de:8080/hets/browser/trunk/Interfaces/Command.hs
05:52:52 <bavardage> jedai: yeah
05:52:57 <mun> jedai: e.g., line 270: map GlobCmd globCmdList
05:53:07 <kadaver> now I know! im watching shogun assassin the most bloody, funny,silly ninja samurai action movie ever.
05:53:16 <kadaver> i shallmake a ninja platform game in haskell!
05:53:20 <kadaver> with extra extra blood
05:53:23 <mun> jedai: and GlobCmd is a data type
05:54:14 <jedai> mun: GlobCmd is a data constructor for the Command type
05:54:46 <mun> jedai: ooh
05:54:59 <jedai> mun: So map GlobCmd [minBound .. maxBound] construct a list of all Commands that are GlobCmd
05:55:54 <mun> jedai: how do you tell that GlobCmd is a data constructor for Command rather than a type itself?
05:56:45 <jedai> mun: GlobCmd is two thing, depending on where it appears : a type in type annotation, a data constructor for the type Command in code
05:57:51 <jedai> mun: Those two namespaces are completely separated, the same name can design two different thing with no relation in one and the other (here there is a relation)
05:58:00 <mun> jedai: i see.
05:58:24 <mun> jedai: so, since commandList returns a list of Command, GlobCmd there acts as a data constructor?
05:58:50 <BoxMaster> how do i hack
05:59:10 <vixey> how do you hack hotmail??
05:59:16 <ivanm> BoxMaster: by "hack", you of course mean finding clever solutions to problems?
05:59:23 <bavardage> something is failing at unicode
05:59:26 <bavardage> be it emacs or haskell
05:59:31 <bavardage> any idea how I put emacs in unicode mode?
05:59:39 <jedai> mun: "commandList = map GlobCmd [...]" is an expression, not a type annotation, so GlobCmd here is the one from the value nameSpace, thus it's the data constructor
05:59:48 <bavardage> "parse error on input `�'
06:00:27 <Itkovian> Problem solved, by reverting to using [Double] rather than UArr Double. I still think it is strange that doing a take n of a larger list :: [(Double, Uarr Double)] poses such a problem to allocation and GC. The same algorithm using lists, i.e., on [(Double, [Double])] has no issues.
06:00:44 <Itkovian> GC reduced from 52% to 8%
06:00:46 <jedai> bavardage: look in the left low corner of emacs, is there a "u" ?
06:01:07 <bavardage> there's  big U
06:01:08 <mun> also, would GlobCmd 0 return the first value?
06:01:20 <mun> i.e., Automatic?
06:02:05 <jedai> mun: GlobCmd takes value of type GlobCmd, so "GlobCmd 0" would be a type error
06:02:34 <jedai> mun: You would have to use "GlobCmd (toEnum 0)" to get what you want
06:02:46 <mun> else, how does map GlobCmd [minBound .. maxBound] return a list of Commands of type GlobCmd? what does [minBound ... maxBound] actually contain?
06:03:15 <bavardage> I want to use a ¿ symbol
06:03:22 <bavardage> so I paste that into emacs
06:03:28 <edwardk> So what is this Haskell thing I keep hearing about?
06:03:37 <jedai> mun: try typing "minBound :: GlobCmd" in GHCi, you'll understand better
06:03:43 <bavardage> 119:2: parse error on input `\277'
06:03:49 <jedai> edwardk: A dead mathematician
06:04:11 <edwardk> Ah. Wow. A dead mathematician with 619 fans.
06:04:42 <vixey> he did give a nice round up of paradoxes in his book
06:04:46 <jedai> mun: Bounded is a typeclass that provides minBound and maxBound for a type
06:05:34 <jedai> mun: and the [a..b] notation comes from the Enum typeclass, it's short for "enumFromTo a b"
06:05:54 <Itkovian> Ignore previous message. darcs did not merge the (take n) :-/
06:05:58 <Itkovian> Back to the start
06:06:15 <bavardage> bleh, any idea for a nice unicode to represent Cond?
06:06:15 <edwardk> For some reason I can't seem to find a preview of his book through the google book previewer. Must be out of print =)
06:06:29 <mun> jedai: but then wouldn't globCmdList contain a list of functions?
06:07:12 <jedai> mun: so here the code is actually equivalent to "map GlobCmd (enumFromTo Automatic DropTranslation)"
06:07:25 <jedai> mun: No, why do you think that ?
06:07:49 <bavardage> ⌨ :D
06:07:56 <pumpkin> edwardk: haskell is epic fail
06:07:59 <mun> jedai: ooh i get what you mean
06:08:48 <edwardk> pumpkin: I mean look at the size of this channel. There are more people on #python for chrissakes!
06:08:57 <tux-foo> ghc gives me this warning:
06:09:03 <tux-foo> Warning: Pattern match(es) are overlapped
06:09:03 <tux-foo>              In a case alternative: _ -> ...
06:09:07 <mun> jedai: but what should the application of GlobCmd to Automatic return?
06:09:23 <jedai> mun: A value of type Command
06:09:30 <tux-foo> does it say: _ overlaps with other cases, i.e. this is in general the case ...
06:09:37 <edwardk> And sheesh, who uses python? All that silly indentation based control structure stuff. And don't get me started about not having to name the types of variables before you use them!
06:09:39 <tux-foo> since _ matches all.
06:09:52 <jedai> mun: remember GlobCmd is a data constructor here, its type is "GlobCmd -> Command"
06:09:54 <pumpkin> lol
06:10:00 <Axman6> tux-foo: we'd need the rest of the code to tell you for sure
06:10:09 <mun> jedai: oh yes.. Command = GlobCmd GlobCmd
06:10:10 <tux-foo> Axman6, kk, a minute....
06:10:11 <edwardk> You should use Foo foo = new Foo(); like God intended.
06:10:43 <mun> jedai: thanks a lot!
06:11:07 <jedai> mun: I know it can be confusing but that's a pattern you may see again, when you have a type that subsumes several types
06:11:23 <jedai> mun: I mean the naming convention here
06:11:31 <jedai> mun: You're welcome :)
06:11:47 <kadaver> haskell is the worst language evah!
06:11:48 <mun> jedai: yeah. thanks for your explanation!
06:12:08 <tux-foo> Axman6,  http://rafb.net/p/dydj5Y61.html ; line 871
06:12:22 <tux-foo> Axman6, it is generated code.
06:12:23 <da-x> the shorthand of 'map f $ map g $ ...' is ?
06:12:31 <Gracenotes> map (f . g)
06:12:36 <vixey> da-x: You an write it  map f . map g . ...
06:12:51 <vixey> and the rule is like Gracenotes says  map (f . g) = map f . map g
06:12:53 <Gracenotes> although GHC will transform map f . map g -> map (f . g)
06:12:55 <Axman6> > map f . map g $ [a,b,c]
06:12:56 <lambdabot>   Add a type signature
06:13:02 <Axman6> > map f . map g $ [a,b,c] :: [Expr]
06:13:03 <lambdabot>   Add a type signature
06:13:14 <Gracenotes> yeah
06:13:15 <Axman6> > map f . map (g::Expr -> Expr) $ [a,b,c] :: [Expr]
06:13:17 <lambdabot>   [f (g a),f (g b),f (g c)]
06:13:23 <tux-foo> Axman6, moreover, I could not find double occurences of the stug before '->'
06:13:30 <edwardk> kadaver: and sheesh list comprehensions? What is less comprehensible than [3*x for x in vec if x > 3] ? i mean the only thing worse than that would be some kind of set notation [ 3 * x | x <- vec, x > 3 ]
06:13:42 <vixey> lol
06:14:17 <tux-foo> Axman6, line 975 has the Token algebraic type
06:14:24 <tux-foo> where all Toke* constructors are located.
06:14:28 <tux-foo> *Token*
06:14:30 <Axman6> woah....
06:14:45 <tux-foo> Axman6, ^^
06:15:00 <da-x> thanks.
06:16:20 * edwardk snaps out of it.
06:16:33 <pozic> What is the differrence between placing a forall before a constructor and placing it in a field of a constructor?
06:17:03 <tux-foo> Axman6, I also always assumed haskell code was supposed to be short.
06:17:06 <edwardk> Just in time, too. I was just about to go into a rant about classes that don't have a notion of private/protected members.
06:17:23 <Axman6> tux-foo: it is imo
06:17:32 <edwardk> pozic: before, it really becomes an existential. after its a forall. =)
06:17:36 <tux-foo> ^^
06:18:13 <edwardk> data Foo x = forall y. Bar y => Foo x y -- really means there exists a y such that y is an instance of Bar and Foo wraps an x and that y
06:18:57 <edwardk> data Baz x = Baz x (forall y. y -> x -> y) -- indicates that Baz contains an x, and a functiont that can take any y and an x and give you a y.
06:19:43 <pumpkin>  eww, classes wth no private/protected members
06:19:49 <pumpkin> what kind of a shitty language is this
06:19:54 <edwardk> pozic: the only reason the word is forall before the constructor is they didn't want to add a new keyword.
06:20:09 <bavardage> Gracenotes: do you think it's valid to define a load of functions?
06:20:10 <Itkovian> Any idea what I can learn from the fact that there are more bytes moved during GC than there are allocated on the heap? (7G vs 2G, according to profiling -sstderr)
06:20:13 <edwardk> and i mean their modules are just a bag of names. like really! ;)
06:20:24 <bavardage> Gracenotes: or is that just naughty?
06:20:25 <pozic> edwardk: and what if you want to add a Bar class constraint to data Baz within the forall?
06:20:25 <ivanm> pumpkin: ummm.... if you think it's so shitty, what are you doing here? :s
06:20:36 <bavardage> Gracenotes: like define pred succ etc
06:20:39 <Gracenotes> bavardage: in what sense? I mean, you could make a bunch of Terms that you can compose
06:20:45 <bavardage> yeah
06:20:50 <bavardage> by functions I mean terms
06:20:51 <edwardk> posic: data Baz x = Baz x (forall y. Baz y => y -> x -> y)
06:20:57 <bavardage> is it naughty to make a load of terms?
06:20:59 <pumpkin> ivanm: just trolling, of course
06:21:03 <bavardage> not really I guess
06:21:05 <Gracenotes> bavardage: I mean.. add = Application ...
06:21:07 <edwardk> that would be an x and a function that works for any y that is an instance of Baz
06:21:10 <bavardage> yop
06:21:13 <Gracenotes> you mean additional data constructors?
06:21:22 <bavardage> well, just defining add = ...
06:21:28 <bavardage> no I guess not
06:21:29 <bavardage> dw :D
06:21:33 <Gracenotes> oh. That doesn't sound bad at all
06:21:38 <fasta> Itkovian: it could mean anything, but for long running processes it is always going to be a higher number than the available internal memory.
06:21:41 <Gracenotes> you could easily replace it with its value
06:21:53 <bavardage> yop
06:22:00 <edwardk> the existential version means only that there is some y that is an instance of Baz and that you have a value that is a member of that type
06:22:02 <Gracenotes> so long as you just define stuff with the Term constructors, not any funny business!
06:22:06 <bavardage> haha
06:22:06 <bavardage> noop
06:22:08 <bavardage> no sir
06:22:11 <bavardage> no funny business
06:22:22 <bavardage> or define new things with previous terms I defined?
06:22:27 <bavardage> like add in terms of succ?
06:22:44 <bavardage> and define some church numerals in terms of other numerals?
06:22:48 <edwardk> given data Foo = forall y. Foo y -- you can wrap anything in Foo, but you can't do anything interesting with it when you pull it out, because the type can't escape the local scope
06:22:59 <Gracenotes> right, that should be fine.
06:23:02 <pozic> edwardk: but aren't Foo and the newest Baz the same?
06:23:03 <bavardage> kk
06:23:18 <edwardk> given data Foo = Foo (forall y. y) you can pull y out and do literally anything with it, but you don't have anything interesting that you can put in!
06:23:24 <Gracenotes> defining the Y-combinator might be useful too, for recursive stuff
06:23:27 <Itkovian> fasta: Until now, I had alwas seen that the # allocated >> # moved
06:23:55 <edwardk> pozic: quite different
06:23:57 <Itkovian> Right now, I see it occuring when I take a number of elements off a list to process, rather than the entire list.
06:24:00 <QtPlay[HireMe]> Gracenotes: I thought that you can't define the Y combinator in haskell
06:24:05 <pumpkin> :t fix
06:24:06 <lambdabot> forall a. (a -> a) -> a
06:24:23 <Itkovian> @paste
06:24:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:24:34 <edwardk> data Foo = Foo (forall y. y) - the only valid members you can put into Foo would be bottoms, there isn't anything else that is a member of every type. you have infinite recursions and errors.
06:24:38 <quicksilver> QtPlay[HireMe]: you can, inside a model of LC, like newtype U = U (U -> U)
06:24:42 <Gracenotes> QtPlay[HireMe]: with data constructors for Variable, Application, and Lambda
06:24:53 <edwardk> data Foo = forall y. Foo y -- you can put anything in the Foo constructor.
06:25:01 <QtPlay[HireMe]> Oh ok.
06:25:05 <edwardk> but when you pull it out you have no operations that you know you can apply to it
06:25:11 <fasta> Itkovian: ok, I guess, I don't know about that. If it is a problem you should just look at the GHC source.
06:25:17 <Gracenotes> which could evaluate to an untyped type
06:25:29 <pumpkin> edwardk: so just unsafeCoerce it to whatever you want ;)
06:25:31 <edwardk> data Foo = forall y. Foo y -- reads better as data Foo = exists y. Foo y
06:25:37 <edwardk> pumpkin: *twitch*
06:25:38 <Itkovian> fasta: Teh problem is that take n xs seems to cause a lot of extra allocation
06:25:52 <Itkovian> And that I have no clue where to start looking for a solution
06:26:11 <quicksilver> Itkovian: take n xs allocates n new list cells, yes.
06:26:13 <quicksilver> (think about it.
06:26:23 <fasta> Itkovian: I doubt it is just take.
06:26:25 <Itkovian> quicksilver: yeahk the _spine_, but that should be it, no?
06:26:53 <bavardage> Gracenotes: yeah I need the Ycombinator too
06:26:53 <quicksilver> Itkovian: yes.
06:26:54 <Itkovian> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3871#a3871
06:26:56 <fasta> quicksilver: there is no need to do that in general.
06:27:06 <bavardage> but first I guess I'll define succ and pred and stuff
06:27:10 <bavardage> and for that, I need numerals
06:27:20 <Itkovian> the culprit seems to be the delta function
06:27:22 <quicksilver> fasta: if you knew the tail of the list was never going ot be used and you didn't mind mutating the nth cell, true.
06:27:22 <edwardk> pozic: given say. data Showable = forall y. Show y => Showable y -- the only thing you can do with the value when you pull it out is not use it, or pass it to something from Show, like show.
06:27:27 <quicksilver> fasta: however, GHC never does that.
06:27:28 <Gracenotes> depends on if you want an int extension or not
06:27:36 <quicksilver> I don't think GHC ever mutates cells.
06:27:47 <Itkovian> if I let out the take n, it works within acceptable memory limits and time bounds even for 'large' datasets (80K cases)
06:27:50 <Peaker> edwardk: which means you might as well have a String instead of that :)
06:27:51 <fasta> quicksilver: right, I think it's very silly that GHC doesn't try to do that. It's one of the reasons "functional languages" are slow.
06:27:57 <Itkovian> if I take a number of items off the list, it does not.
06:28:08 <edwardk> Peaker: nah, because you can use showsPrec, etc. on it
06:28:25 <edwardk> Peaker: and it'll get the parenthesization right, etc.
06:28:31 <quicksilver> fasta: I'm sure you're welcome to write the research paper which shows how to do that in an interesting number of cases. It's not obvious to me.
06:28:48 <pumpkin> fasta: functional languages are slow?
06:29:11 * pumpkin needs to add more busywork to his programs, then
06:29:16 <bremner> pumpkin: compared to disfunctional languages
06:29:28 <bavardage> Gracenotes: any idea how to convert church numerals to integers for display?
06:29:36 <bavardage> or should I just think about it lots
06:29:37 <edwardk> on the other hand you can have something like data ImThinkingOfANumber = Thinking (forall a. Num a => a) -- which will give you a member of your Num class for any Num. it may be constructed using an arbtirary mix of abs, signum, +, -, * , Eq comparisons, uses of Show, etc.
06:29:50 <pumpkin> my functional programs are just about as fast as their dysfunctional counterparts
06:30:10 <Gracenotes> bavardage: well, you could count the number of times to pred a value until it reaches zero
06:30:10 <EvilTerran> it's no good having a fast algorithm if you're not confident it's correct, anyway
06:30:11 <edwardk> but it'll use whatever Num class you demand of it, and you could extract from an ImThinkingOfANumber several different kinds of Nums.
06:30:12 <QtPlay[HireMe]> My code is fast enought.
06:30:20 <bavardage> Gracenotes: ooh kk
06:30:23 <bavardage> nice idea
06:30:24 <fasta> pumpkin: not as slow as most implementations of dynamic languages, but still lots of work is being done for nothing.
06:30:34 <quicksilver> bavardage: apply them to (+1).
06:30:36 <Gracenotes> bavardage: other ways too, I guess, depending on how you encode it
06:30:38 <quicksilver> bavardage: (and apply that to 0)
06:30:44 <bavardage> quicksilver: I can't
06:30:50 <bavardage> since I don't exactly have 'functions'
06:30:53 <fasta> pumpkin: then again, programming in a functional language is easier than always having to work with mutable variables and all that.
06:30:56 <quicksilver> bavardage: you can.
06:31:04 <bavardage> quicksilver: I have results of type (U -> U)
06:31:05 <edwardk> fasta: well, clearly we need uniqueness typing ;)
06:31:08 <pumpkin> fasta: really? have you compared good performance-conscious functional code with good imperative code?
06:31:21 <fasta> edwardk: people talk about that for > 5 years, I think.
06:31:21 <bavardage> before I was just applying to to (1+) 0
06:31:23 <bavardage> but hmm
06:31:29 <quicksilver> bavardage: you have to inject Integers (secretly) into U, or another type like U but bigger
06:31:35 <quicksilver> bavardage: and use them for models.
06:31:36 <edwardk> pumpkin: in general you pay a logarithmic time tax for immutability for some algorithms
06:31:41 <bavardage> hmm
06:31:41 <pumpkin> oh, definitely
06:31:42 <Gracenotes> as I said earlier, an Int extension
06:31:47 <pumpkin> but then you just use ST if necessary
06:31:52 <quicksilver> data U' = U' (U' -> U') | I Integer
06:31:53 <bavardage> Gracenotes: just for U?
06:32:03 <Gracenotes> bavardage: just like your Boole extension
06:32:04 <bavardage> or you mean for Term too?
06:32:08 <pumpkin> and that's just some algorithms, as you said
06:32:09 <quicksilver> you can keep it a separate type, or a secret
06:32:11 <edwardk> pumpkin: whenever you can close the world down to one thread and only need the fully formed result
06:32:11 <bavardage> yeah but I have a Boole in Lambda
06:32:14 <quicksilver> so that 'ordinary users' can use it
06:32:16 <Gracenotes> you can have it in Term
06:32:26 <bavardage> isn't that cheating?
06:32:35 <fasta> pumpkin: which is not really functional programming anymore. If you want relatively fast code, you can get it with GHC, given enough time.
06:32:36 <Gracenotes> or you can choose to not have it, converting at last minute when you want to have a result
06:32:55 <bavardage> yeah
06:33:17 <edwardk> fasta: arguably the semantics of ST are indistinguishable from an immutably constructed ST monad which uses a big Data.Map for its references.
06:33:19 <pumpkin> fasta: I've found that uvector has given me very fast code while still maintaining a nice functional feel to it, for example
06:33:31 <Gracenotes> if you expect the final result to be a Church numeral, eval blah $$ (\I x -> I (x+1)) $$ (I 0), something like that, I think
06:33:58 <pumpkin> fasta: it requires care, but we're getting closer to fast & functional rather than the fast and ugly MagicHash stuff
06:34:02 <fasta> edwardk: yes, that's true, but mentally you are thinking in terms of references.
06:34:17 <Gracenotes> actually, the second would have the constructor for the U -> U. I used F
06:34:23 * pumpkin shrugs :)
06:34:28 <edwardk> fasta: sure, but the reference as Map model applies to many such forms of mutable state.
06:34:57 <edwardk> mentally i'm thinking in terms of thunks as well, so i'm rarely purely functional in thought ;)
06:35:27 * quicksilver is shocked by edwardk's impure thoughts.
06:35:36 <amaron> anyone familiar with takusen?
06:35:38 <Gracenotes> bavardage: other implementations of the lambda calculus don't have to deal with Us... TAPL's ones are elegant and written in OCaml, which you can probably make into Haskell easily
06:35:47 <edwardk> Im not going to kick a functional programmer out of the club just because he thinks out performance. I mean, I'd hate to lose dons. ;)
06:35:48 <kadaver> uniqueness typing means no monads?
06:35:51 <edwardk> er about
06:35:56 <pozic> edwardk: How does that differ from data Showable = Showable (forall a. (Show a)=> a)?
06:35:56 <edwardk> kadaver: no
06:36:04 <bavardage> hmm
06:36:12 <bavardage> is OCaml as typed as haskell?
06:36:15 <Gracenotes> bavardage: in fact, http://code.google.com/p/tapl-haskell/source/browse/trunk/fulluntyped/?r=2
06:36:18 <bavardage> surely in haskell you need U to get around the typing thing
06:36:23 <bavardage> oh hmm
06:36:40 <Gracenotes> not complete, but some of the earlier chapters. randomly found it..
06:36:41 <edwardk> posic: the latter doesn't have any interesting inhabitants? you'd need something that can give you ANY showable a.
06:36:42 <pumpkin> oh nice, tapl-haskell :o
06:36:46 <edwardk> er any a you can Show
06:36:59 <Gracenotes> however, many of the OCaml idioms don't translate well to Haskell
06:37:09 <kadaver> whats the other music lib in haskell called? ie not hascore
06:37:21 <bavardage> Gracenotes: they cheat
06:37:25 <Gracenotes> for instance, Control.Exception used where Maybe would be the elegant Haskellian away.
06:37:30 <bavardage> Gracenotes: they have Float and Int and String in their Terms
06:37:30 <pumpkin> :o
06:37:32 <edwardk> kadaver: clean tends to avoid monads for IO because they have access to uniqueness, but they could just as well wrap up their uniqueness'd world  in a monad if they weren't so in love with uniqueness
06:37:33 <pumpkin> eww
06:37:49 <pozic> edwardk: that would only be undefined?
06:37:53 <bavardage> Gracenotes: so your way is fine D:
06:37:55 <bavardage> *:D
06:37:56 <edwardk> pozic: exactly.
06:37:58 <Gracenotes> bavardage: well, Int would probably be de Bruijn indices...
06:38:04 * uniqueness needs a couniqueness
06:38:05 <edwardk> pozic: whereas the existential type has lots of members.
06:38:23 <edwardk> uniqueness has a couniqueness, we call it linearity
06:38:24 <Gracenotes> but still, it is limited in a theoretical sense. TAPL still highly recommended... I made a few of my own translations
06:38:56 <edwardk> its just not commonly seen as such
06:39:16 <edwardk> technically couniqueness would be affinity
06:39:23 <kadaver> what is the easiest way to make music in haskell? for a game...
06:39:41 <edwardk> because uniqueness says nothing about relevance
06:40:43 <edwardk> tapl was great i got about half way through and then went off into pure type system lala land on my own, and then by the time I came back and the tail end was obvious ;)
06:40:56 <vixey> hehe
06:41:02 <edwardk> kadaver: call into the SDL?
06:41:19 <EvilTerran> what about ATTaPL?
06:41:52 <edwardk> EvilTerran: mixed bag. i liked walker's article, mainly because i was obsessed with substructural types. i liked a few of the others but overall less coherent than tapl
06:42:09 <EvilTerran> righto
06:42:34 <Gracenotes> atta..plboy
06:42:55 <bavardage> yay :D
06:43:04 <bavardage> Gracenotes: maybe I'll buy tapl at some point then
06:43:08 <edwardk> but sending them to walker's writeup is, i think, the easiest way to get someone to think about the ramifications of substructural types
06:43:17 <bavardage> I got a showInteger function working now :P
06:43:38 <edwardk> tapl is iirc responsible for the existence of pugs ;)
06:44:04 <vixey> I think bruce pierce is doing TAPL in Coq now
06:44:15 <edwardk> shapr recommended it to audreyt and audrey went off and wrote pugs to work through the processes in the book
06:45:11 <bavardage> http://paste.pocoo.org/show/112945/ YAY
06:45:21 <bavardage> vixey: what's 'Coq'?
06:45:37 <EvilTerran> ?where coq
06:45:37 <lambdabot> I know nothing about coq.
06:45:46 <edwardk> bavardage: proof assistant/dependently typed programming language
06:45:54 <bavardage> oh kk
06:45:54 <vixey> bavardage: if you like lambda calculus, http://muaddibspace.blogspot.com/2008/07/hoas-based-self-interpreter-for-lambda.html
06:46:11 * quicksilver points and laughs gently at bavardage for asking a question google could answer :)
06:46:18 <EvilTerran> ?where+ coq http://coq.inria.fr/
06:46:18 <lambdabot> I will never forget.
06:50:18 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3872#a3872 <- so i have trouble installing SDL
06:51:10 <edwardk> ugh, there was someone in here asking about how to fix that the other day.
06:51:14 <vixey> kadaver: You can use OpenAL for music
06:51:46 <vixey> although maybe in Haskell OpenAL is broken
06:53:32 <dav> broken how?
06:53:45 <edwardk> kadaver: http://substitut-fuer-feinmotorik.net/projects/haskellommage/introduction was maybe what you were thinking of?
06:55:02 <kadaver> hmm when i isntaleld it for C i had the same thing were i had to #undef main
06:55:08 <kadaver> but that was int he C program
06:56:34 <edwardk> there was something about using --hs-no-main or something
06:57:08 * quicksilver also remembers the conversations but not the answer.
06:57:22 <quicksilver> at least, I don't know why this either used to work on old versions of cabal, or works on other OSes.
06:57:28 <quicksilver> it clearly works or worked under some circs.
06:57:32 <quicksilver> I don't understand what changed.
06:57:36 <edwardk> er --no-hs-main
06:57:37 <edwardk> yeah
06:58:08 <edwardk> http://hackage.haskell.org/trac/ghc/ticket/2459 ?
06:58:15 <bavardage> Application (Lambda 'n' (Lambda 'f' (Lambda 'x' (Application (Variable 'f') (Application (Application (Variable 'n') (Variable 'f')) (Variable 'x')))))) (Lambda 'f' (Lambda 'x' (Application (Variable 'f') (Application (Application (Lambda 'f' (Lambda 'x' (Application (Variable 'f') (Variable 'x')))) (Variable 'f')) (Variable 'x')))))
06:58:19 <bavardage> that is three :D
06:58:20 <pozic> edwardk: Why do I get a type error for this? data A = forall a. (Show a)=> A a;data AC k = forall b. (Show b) => A1 (b -> k);i (A1 f) (A a) = f a
06:59:17 <edwardk> posic: the second one says that you have a function that can be applied to _some specific_ type b. not every type b.
06:59:29 <kadaver> unrecognized otion --hs-no-main
06:59:38 <edwardk> so you have two specific types, ghc, and logic, provides no indication they would be the same type
06:59:55 <EvilTerran> kadaver, maybe because that's not what edwardk suggested
07:00:05 <kadaver> msae with --no-hs-main
07:00:14 <kadaver> i had sdl working before but now i try on 6.10.2
07:00:40 <Gracenotes> bavardage: wat you say!
07:00:48 <bavardage> Gracenotes: that was three!!!
07:00:51 <edwardk> newtype AC k = A1 (forall b. Show b => b -> k) -- would be a container holding a function that can work on any showable
07:00:59 <Gracenotes> oic.
07:01:08 <kadaver> should it be for cabal install ot you talk about compilng froms ource?
07:01:09 <bavardage> Gracenotes: todo: write a nicer show for terms :P
07:01:22 <Gracenotes> you made it with succ?
07:01:35 <edwardk> kadaver: i don't know what the resolution was, or if one exists, dcoutts was on here talking to someone about it the other day.
07:02:54 <mads-> Hi. I'm trying to make a list of fibonacci numbers. what is wrong with : http://pastebin.com/f17eb61c0 ? :S
07:02:58 <Gracenotes> bavardage: hm.. you mentioned changing the type constructors earlier? Maybe Application to $$ (changing the other name), Lambda to (-->), Variable to Var.. stuff lie that
07:03:18 <Gracenotes> *like. If you can stand code like that
07:03:25 <bavardage> Gracenotes: I do have nice yeah
07:03:29 <bavardage> Gracenotes: for actually coding
07:03:48 <edwardk> mads: i understand the fib, but i have no idea what you're trying to do with makeList =)
07:04:02 <bavardage> Gracenotes: like this http://paste.pocoo.org/show/112947/
07:04:57 <Gracenotes> oic. Well, you can make constructors infix
07:05:02 <mads-> edwardk: makeList is supposed to work like "makeList [1..10] []" and then ys should be the list of fib numbers [fib(1),fib(2)..fib(10)] - I'm kinda new at Haskell, if you didn't notice.
07:05:04 <Gracenotes> so yeah
07:05:30 <bavardage> Gracenotes: infix constructors?!
07:05:30 <edwardk> mads: thats ok, i just thought I'd be frank =0
07:05:30 <gnuvince> mads-: do you know map?
07:05:33 <bavardage> Gracenotes: whut?
07:05:37 <edwardk> @type map
07:05:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:05:41 <vixey> mads-: [1,2..10] --> [fib 1, fib 2..fib 10]
07:05:50 <edwardk> map fib [1..10] -- would give you what you want
07:05:58 <mads-> aaah, thanks :)
07:06:15 <Gracenotes> bavardage: (:) is an infix constructor
07:06:18 <mads-> And this would be "the way" you would do it?
07:06:23 <pozic> edwardk: the wiki page could use a spelled out mapping between ghc types and logic. data A = A (x :: forall a. (Show a) => a -> k), something like if z::A, x z is a function taking any a which is in the Show class returning some result of type k.
07:06:28 <bavardage> Gracenotes: ooh right
07:06:36 <edwardk> mads: one of the things haskell teaches you is that you can compose functions using higher order combinators like map and get something much more legible than doing it manually
07:06:36 <Gracenotes> data [] a = [] | a : [a]
07:06:38 <edwardk> mads: yeah
07:06:41 <bavardage> Gracenotes: which ones would benefit from being infix?
07:06:51 <mads-> Thanks a lot
07:07:04 <bavardage> OIC :D
07:07:13 <bavardage> If I change the *actual* constructors
07:07:14 <Gracenotes> hm.. I forgot, though, don't infix constructors have to start with :?
07:07:14 <bavardage> yeah
07:07:16 <edwardk> mads: now, technically thats not how i would do it, because you get no sharing =)
07:07:22 <bavardage> oh well nm :P
07:07:33 <Gracenotes> bavardage: well, you can do something like :$ for application
07:07:33 <Axman6> you can always use `Constructor`
07:07:46 <edwardk> > take 10 $ fix $\fib -> 1:1:zipWith (+) fib (tail fib)
07:07:47 <lambdabot>   <no location info>: parse error on input `->'
07:08:04 <edwardk> > take 10 $ fix $ \fib -> 1:1:zipWith (+) fib (tail fib)
07:08:05 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
07:08:11 <Gracenotes> Var for variables, just to shorten... hm..
07:08:24 <edwardk> but that example is somewhat sadistic at this juncture
07:08:35 <Gracenotes> or that string literal extension :)
07:08:52 <bavardage> string literal extension?
07:08:56 <Gracenotes> whereby the compiler can automatically construct a type from a string literal
07:09:02 <bavardage> oh nice
07:09:07 <bavardage> I'll look for that
07:09:09 <edwardk> OverloadedStrings
07:09:11 <bavardage> would make things much cleaner
07:09:22 <Gracenotes> for making a Variable
07:09:23 <edwardk> and import Data.String for the IsString class
07:10:50 * edwardk kind of wishes the lifting of instance (IsString a, IsString b) => IsString (a,b)  etc was in Data.String
07:11:02 <Gracenotes> heh.
07:11:16 <edwardk> i feel kind of dirty defining it myself in Data.Monoid.Instances
07:11:18 <Gracenotes> bavardage: you can't make a data constructor for lowercase lambda λ... but you can make one for Λ :)
07:11:26 <bavardage> Gracenotes: yeah i thought about it
07:11:42 <Gracenotes> using uppercase couldn't hurt.. they look similar enough
07:11:54 <edwardk> Gracenotes: but usually connote different things
07:12:01 <Gracenotes> right, the downside
07:12:13 <quicksilver> edwardk: isn't IsString kind of dirty in itself?
07:12:44 <bavardage> well the capital technically denotes the set of valid expressions
07:12:44 <edwardk> quicksilver: nah, i like it for bytestring, etc. it just overloads syntax. we do it for [1..], do x <- y; ...; etc.
07:12:45 <bavardage> per wiki
07:12:47 <bavardage> I g2g
07:12:48 <bavardage> bbl
07:12:51 <bavardage> Gracenotes: thankyou :D
07:12:53 <Gracenotes> adieu
07:13:15 <mads-> Is there a way to limit the output of map? Let's say I want to map fib [1..whatever] only to calculate the fibonacci numbers until one of them exceeds a given value, let's say 10,000 ?
07:13:21 <edwardk> quicksilver: and i find its a lot easier to define a regex object directly from the string than to remember what constructor to wrap around it, etc.
07:13:26 <quicksilver> edwardk: it doesn't overload syntax all that usefully though.
07:13:34 <EvilTerran> mads-, takeWhile?
07:13:36 <quicksilver> edwardk: I think QQ is a better solution to this problem.
07:13:43 <edwardk> takeWhile (<1000) $ map fib [1..]
07:13:49 <QtPlay[HireMe]> mads-: takeWhile I think there is also a takeUntill
07:13:51 <quicksilver> edwardk: although I find the current QQ syntax slightly noisier than I'd like.
07:14:21 <mads-> This seems to come kinda easy to you :) I have been looking through some short guides. Is there a place where I can find a good guide?
07:14:36 <edwardk> quicksilver: i use it mostly for things like the noisy
07:14:41 <edwardk> string method in http://conway.rutgers.edu/~ccshan/wiki/blog/posts/WordNumbers1/
07:15:33 <edwardk> mads: well, there are a ton of functions in Data.List or just the Prelude in general that do useful things. you'll find as you go that most of the code you write exists in a generalized form somewhere in the prelude ;)
07:15:57 <edwardk> mads: skimming http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html does wonders
07:16:07 <mads-> edwardk: But you don't have a text or book you could recommend on Haskell in general? :)
07:16:14 <edwardk> mads: beyond that some folks on here wrote a pretty good book called Real World Haskell.
07:16:37 <edwardk> mads: and there is a slightly more tongue in cheek introduction called Learn You a Haskell for Great Good, which is also quite readable
07:16:56 <mads-> Superb.. I'll have a look at that then :) Thanks for your help
07:17:05 <quicksilver> both are available online
07:17:10 <TheRealMarko>  (both available online, ask the google)
07:17:10 <edwardk> http://book.realworldhaskell.org/read/ and http://learnyouahaskell.com/
07:17:11 <quicksilver> only RWH comes in dead-tree form too
07:17:20 <TheRealMarko> thanks, the google :)
07:18:53 <quicksilver> edwardk: it's not really that noisy to have a one-letter smart constructor like 's' in that case
07:18:57 <quicksilver> edwardk: IMO, anyway.
07:19:13 <quicksilver> edwardk: adding a typeclass is just noise unless you intend to be polymorphic over it.
07:19:30 <edwardk> quicksilver: kind of ugly to import from a standard library
07:19:34 <quicksilver> edwardk: do you expect to write functions of the form "IsString s -> a -> b -> s -> d"
07:19:44 <quicksilver> (why would you ever, anyway?)
07:19:55 <quicksilver> s/-/=/ obviously
07:21:07 <edwardk> quicksilver: mostly because it makes Bytestrings, etc. harder to use than their prelude equivalent. all the stupid windows c variant strings like T"...." are also just as ugly to my eyes as your proposal ;)
07:22:14 <quicksilver> since ByteStrings store bytes, not characters, they make a terrible instance of IsString :P
07:22:29 <quicksilver> unless you have a proposal for an encoding-parameterised variant of IsString.
07:22:39 <edwardk> yeah, but i have a bunch of Reducer Char monoids that work perfectly ;)
07:24:15 <amaron> anyone familiar with takusen?
07:24:34 <kadaver> i dont get the MIDI lib really, can you open a .wav file and play it?
07:24:41 <copumpkin> lol, I like mmorrow's quote on this HWN
07:24:49 <EvilTerran> kadaver, er, midis and wavs are rather different
07:24:56 <edwardk> and one of those is a utf-8 encoder that could feed a bytestring =P
07:26:18 <quicksilver> edwardk: nod.
07:26:27 <quicksilver> edwardk: I was playing devil's advocate to some extent.
07:26:35 <quicksilver> edwardk: I'm in favour of extensible syntax in general.
07:26:36 <TheRealMarko> kadaver:  midi files consist of the control codes (midi-commands) of midi enabled instruments afaik. So it contains rather "play an a for 200 ms" than the values for a wave @ 440hz
07:26:45 <quicksilver> edwardk: I just think IsString is a curiously limited and adhoc thing.
07:27:05 <EvilTerran> quicksilver, well, it's the same approach as numeric constants
07:27:10 <copumpkin> it's got a shitty name too
07:27:15 <edwardk> well, i also have lobbied for -XNoImplicitPrelude letting you rebind enumFromTo, etc.
07:27:24 * EvilTerran would've called it Stringy
07:27:27 <LeCamarade> copumpkin, That is a quote from some mathematician.
07:27:31 <edwardk> EvilTerran: haha
07:27:54 * edwardk doesn't care what its called as long as it exists ;)
07:28:14 <copumpkin> LeCamarade: who?
07:28:43 <quicksilver> EvilTerran: numeric bothers me less because Integers are quite a sane type.
07:28:48 <LeCamarade> copumpkin, It was Stefan Banach.
07:28:55 <LeCamarade> "Good mathematicians see analogies. Great mathematicians see analogies between analogies."
07:28:59 <quicksilver> EvilTerran: forcing all string-like things to go via a totally insane type (String) seems harsh.
07:29:10 <LeCamarade> And that was applied to functors in category theory.
07:29:13 <copumpkin> ah
07:29:33 <edwardk> LeCamarade: bah, there is clearly an analogy tower involved here. ;)
07:29:37 <copumpkin> how about analogies between analogies between analogies?
07:29:39 <copumpkin> NT?
07:30:04 <chessguy_work> arbitrarily nested analogies?
07:30:14 <edwardk> a real mathematician constructs the analogy tower kind system and sits atop that studying families of analogic relationship systems
07:30:46 <Gracenotes> LeCamarade: it came from a discussion about monads, actually
07:30:52 <copumpkin> a real mathematician constructs analogies between analogy towers, and analogy towers atop those
07:31:10 <edwardk> A = analogy | A -> A -- would of course be an initial object in the category of analogies...
07:31:18 <osfameron> an analogy stack?
07:31:20 <Gracenotes> we were talking about monad analogies, and I mentioned that functors were analoges between monad analogies
07:31:26 * vixey thought computing was about analogies and math was about .. math
07:31:41 <Gracenotes> it got pretty meta. I didn't know 'bout that quote, though.
07:32:01 <edwardk> bah, computing is clearly about digitalies. we try to avoid working in analog as much as possible.
07:32:10 <copumpkin> lol
07:32:12 <quicksilver> edwardk: computing is about puns.
07:32:22 <copumpkin> digitalies + analogies sounds painful
07:32:23 <daf> vixey: you're saying that math is homoanalogous?
07:32:27 <Gracenotes> x.x
07:32:34 <copumpkin> I'd not want a digit anywhere near my
07:32:40 <edwardk> ouch
07:33:07 <edwardk> that feeds into dafs homoanalogous bit in ways i don't want to consider
07:33:29 * Gracenotes wonder what a copumpkin is good for
07:33:37 * edwardk is firmly heteroanalogous
07:33:42 <copumpkin> lol
07:33:59 <copumpkin> Gracenotes: every day but halloween
07:34:29 <edwardk> clearly due to our seasonal pumpkin bias, a copumpkin is more useful 364 days out of the year.
07:35:00 <edwardk> However, I've yet to see a decent usecase for a copumpkin pie
07:36:48 <skorpan> you're a pie
07:37:42 * edwardk is sure there is a pie hole joke in here somewhere, but after the uncomfortable exploration of the implications of digitalies is somewhat scared to mention it.
07:41:29 <tux-foo> getContents returns a `IO String`, but somehow it can be used like getContents >>= putStr.
07:41:44 <tux-foo> This means, IO String gets coerced into String, is tis allowed?
07:41:46 <EvilTerran> ?type (>>=)
07:41:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:41:50 <tux-foo> *this
07:41:55 <EvilTerran> m = IO, a = String, b = ()
07:41:58 <EvilTerran> in this case
07:42:32 <tux-foo> EvilTerran, kk, thanx
07:43:21 <EvilTerran> tux-foo, >>= is the basic building block for linking monadic actions together
07:43:37 <tux-foo> EvilTerran,  kk
07:44:49 <EvilTerran> basically, "m >>= f" means "an action that, when you 'run' it, 'runs' m, feeds the result into f, then 'runs' the action given back by f"
07:45:45 <tux-foo> EvilTerran, kk, I am trying to get stdin as a [Char] which ends when stdin has an EOF.
07:45:50 <EvilTerran> what exactly 'action', 'run', and 'result' means in this context varies depending on what monad you're using
07:46:20 <orbitz> one thing tha took me awhile to udnerstand is it was teh >>= that was actually running the action.  i always thought somehow it was the m, but it's not (i.e. i didn't realize putStrLn really does *nothing* other than *make* something to be run)
07:46:46 <EvilTerran> tux-foo, well, something like "getContents >>= f where f :: String -> {whatever}; f stdinContents = ..." would work
07:47:01 <quicksilver> orbitz: actually >>= does *nothing* other than make a bigger something to be run (out of two smaller somethings) ;)
07:47:04 <EvilTerran> although, from the type of >>=, note that f would have to return an IO {something}
07:47:13 <orbitz> quicksilver: don't ruin my moment!
07:47:18 <quicksilver> ;)
07:47:31 <tux-foo>  EvilTerran, yes, thank you. I will think about it some more, since I am not quite familiar with monads yet.
07:49:57 <tux-foo> EvilTerran, This one seems to explain Monad and >>= rather nice: http://haskell.org/haskellwiki/Monad
07:50:05 <tux-foo> EvilTerran, thanks for your guidance.
07:54:20 <EvilTerran> tux-foo, no worries; monads aren't as scarey as they first appear :)
07:54:59 <tux-foo> EvilTerran, They have a tension between a formal definition and an intuitive reason (for their existance).
07:55:35 <EvilTerran> indeed
07:57:57 <cnwdup> How can I read from a named pipe?  I used openFile and hGetLine, but after the first read, I read EOF. I was expecting it would block until there's more to read.  Am I mistaking the concept of pipes?
07:59:48 <mun> if i have f that is of type data Foo = Foo { a :: T...} if the current value of a f is v, would f { a = w } change the field a from v to w?
08:00:23 <skorpan> yes
08:00:31 <mun> skorpan: i see. thanks
08:00:32 <skorpan> not *change*, but yes
08:00:41 <mun> skorpan: not change?
08:01:07 <skorpan> it would create a new Foo identical to f, but with the value of "a" modified
08:01:17 <skorpan> (i think?)
08:01:28 <mun> skorpan: so the old f still remains?
08:01:45 <skorpan> i'm just being pedantic, it would essentially "change" it, yes
08:01:59 <quicksilver> mun: yes.
08:02:03 <quicksilver> mun: nothing changes in haskell.
08:02:06 <quicksilver> values are imutable.,
08:02:19 <quicksilver> unlike my speling, which is very mutable.
08:02:59 <mun> thanks
08:03:00 <Berengal> quicksilver: Is this why haskell is said to be statically typed? ;)
08:03:13 <jmcarthur> this is why haskell is said to be pure
08:03:20 <TheRealMarko> *sigh*
08:04:09 <wli> Immutable variables!? Don't they have to vary?
08:04:12 <edwardk> Haskell is a total drag. Nobody does anything unless forced, and nothing ever changes.
08:04:31 <wli> How pointless! @pl ...
08:05:12 * TheRealMarko is pure and lazy
08:05:31 <mun> so only things only get created but not changed, then wouldn't that become a memory hog?
08:06:01 <edwardk> mun: no, because you lose references to things and then they get garbage collected
08:06:16 <mun> right
08:06:17 <mun> thanks
08:06:27 <edwardk> the stack itself is mutating behind your back
08:06:58 <EvilTerran> (if that's how your implementation does it)
08:06:58 <daf> but only if you're not looking at it
08:07:25 <TheRealMarko> think of variable as a short name for the stuff on the other side, not a memory location
08:08:15 <wli> mun: All the optimizing compilers know how to optimize it to in-place update where possible.
08:09:41 <quicksilver>  I'm not sure which compilers wli is talking about.
08:09:48 <quicksilver> none of the ones I know of, or use, do.
08:10:04 <dalo> mun: immutable data can save memory. Take a list x = [4,5,6], we can say y = 3 : x and z = 2 : x without copying x at all. We know x can't be changed, so theres no need to copy it.
08:10:08 <copumpkin> wlicc
08:10:22 <wli> quicksilver: eh? The whole \pi vs. u thing in the STG machine is to optimize for in-place update.
08:10:52 <quicksilver> the only in-place update that GHC does is replacing a thunk indirection with its value when done.
08:10:57 <wli> quicksilver: And without some form of it CAF's would be a catastrophe in essentially everything.
08:11:10 <quicksilver> sure, in-place replacing of thunk with value.
08:11:16 <quicksilver> but never of old-value with new value
08:11:26 <Axman6> aren't unboxed fuctions in core usually updating something in place?
08:11:40 <quicksilver> yes, in a sense; often registers
08:11:46 <quicksilver> but that's not quite what we're talking about here.
08:11:46 <Axman6> yeah
08:11:58 <quicksilver> given a data structure link mun's f {a = w}
08:12:05 <wli> quicksilver: Well, that's the in-place update I had in mind.
08:12:10 <quicksilver> 'w' is *never* written in place on top of the old value of the 'a' field in f
08:12:21 <quicksilver> wli: ok, but it's not what we were talking about.
08:12:48 <copumpkin> can an STRef or an IORef change ever be reduced down to a single register move?
08:13:00 <copumpkin> if the compiler figures out to unbox the value in it etc.?
08:13:36 <Axman6> i doubt it
08:14:54 <Peaker> copumpkin: in theory? yes :)
08:15:02 <copumpkin> well, yeah :P
08:15:07 <copumpkin> but can GHC do it, currently?
08:15:21 <copumpkin> a STURef seems like it'd be handy, if it existed
08:15:40 <orbitz> STFURef
08:15:46 <Peaker> :-P
08:15:49 <copumpkin> :'(
08:15:54 <Axman6> that's just a mutable variable right? like int x; in C
08:16:00 <Peaker> There needs to be a Ref type-class in the stdlib
08:16:01 <copumpkin> yup
08:16:27 <Axman6> copumpkin: with type safety?
08:16:36 <copumpkin> yup
08:16:46 <Axman6> or, referencial transparency
08:16:54 <copumpkin> and the ability to escape from ST
08:16:57 <copumpkin> yup
08:16:58 <Axman6> (being ST n' all)
08:17:14 <Axman6> seems like it should be possible actually
08:17:29 <copumpkin> except it holds *s
08:17:51 <Axman6> well, you'd have to make instances, like MUArray
08:21:09 <Axman6> @src STRef
08:21:09 <lambdabot> data STRef s a = STRef (MutVar# s a)
08:21:22 <Axman6> @src MutVar
08:21:22 <lambdabot> Source not found. My pet ferret can type better than you!
08:21:24 <Axman6> @src MutVar#
08:21:25 <lambdabot> Source not found. You type like i drive.
08:22:07 <kadaver> I want to declare newtype instead of type so there is no misunderstanding of using the wrong tyes
08:22:08 <kadaver> newtype Neuron = Neuron Inputs Weights Threshold
08:22:09 <copumpkin> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/ghc-prim/GHC-Prim.html#v%3AnewMutVar%23
08:22:13 <kadaver> newtype Neuron = Inputs Weights Threshold
08:22:16 <kadaver> fail
08:22:20 <kadaver> do I need a data for this?
08:22:29 <copumpkin> you want type I think
08:22:30 <Axman6> i think so
08:22:31 <quicksilver> you need a constructor
08:22:33 <skorpan> kadaver: newtype introduces a constructor, which "type" doesn't
08:22:49 <quicksilver> newtype Neuron = Neuron (Inputs Weights Threshold)
08:22:56 <quicksilver> but that rather implies Inputs is a binary constructor
08:23:01 <quicksilver> (type constructor)
08:23:10 <quicksilver> I suspect that isn't what you mean.
08:23:24 <quicksilver> I suspect you want
08:23:33 <quicksilver> data Neuron = Neuron Inputs Weights Threshold
08:23:53 <kadaver> quick: that diesnt work
08:24:00 <kadaver> yeah i use data like that
08:24:12 <quicksilver> newtype is for new names for old types
08:24:35 <copumpkin> newoldtype
08:24:36 <skorpan> as opposed to "type"? :P
08:25:39 <jmcarthur> kadaver, your problem is that newtypes only allow you to have one "field". in that sense, newtype is *only* a new type from an existing type
08:26:06 <jmcarthur> kadaver, Inputs Weights Threshold is not a type, (Inputs, Weights, Threshold) is
08:26:36 <jmcarthur> but then you are not really gaining any advantage over data Neuron = Neuron Inputs Weights Threshold
08:27:21 <cnwdup> How do I turn a Handle into a Fd?
08:27:23 <jmcarthur> and in fact, it may be to your benefit to have data Neuron = Neuron !Inputs !Weights !Threshold, which you can't do with newtype Neuron = Neuron (Inputs, Weights, Threshold)
08:28:26 <copumpkin> what is the (# #) type?
08:28:30 <copumpkin> without a comma in it
08:28:34 <copumpkin> I've seen unboxed pairs
08:28:46 <Axman6> unpacked oneple
08:28:47 <Axman6> >_>
08:28:57 <copumpkin> can you really have 1-tuples? :o
08:29:10 <jmcarthur> for consistency, it kind of makes sense
08:29:24 <copumpkin> yeah, but we don't have them in regular haskell
08:29:27 <Berengal> You can't in h98, can you?
08:29:44 <jmcarthur> Berengal, unboxed tuples aren't h98 anyway, afaik
08:29:46 <Berengal> What's the point one 1-tuples anyway?
08:29:57 <Axman6> making programs slower
08:30:27 <jmcarthur> Berengal, not much with out current tuple semantics
08:31:01 <Berengal> jmcarthur: Hmm, I see how they could be useful for things like TH
08:31:13 <EvilTerran> there's Identity
08:31:14 <quicksilver> jmcarthur: definitely not, no
08:31:16 <orbitz> TH?
08:31:23 <quicksilver> the (# #) stuff is GHC specific
08:31:27 <EvilTerran> ?src Identity
08:31:27 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:31:29 <tromp> in lambda calculus, a tuple <x,y..z> is represented as \f. f x y..z
08:31:41 <copumpkin> quicksilver: what does it give you over a regular unboxed type?
08:32:00 <jmcarthur> Berengal, but if our tuples were more like (a,b,c) == (a,(b,(c,()))), and this would imply that (c,()) is a "oneple"
08:32:01 <tromp> so there a singleton tuple would be useful
08:32:12 <tromp> but in haskell i dont see the point of having it
08:32:16 <Berengal> jmcarthur: That's not a tuple but a list though
08:32:20 <quicksilver> copumpkin: what do you mean by "a regular unboxed type" ?
08:32:29 <jmcarthur> Berengal, no it's not. it's type would be parameterized over each element type
08:32:31 <copumpkin> something ?
08:32:53 <idnar> it's a type-level list
08:33:08 <EvilTerran> Berengal, but (a,(b,(c,()))) is heterogeneous, fixed-length, and has the types of each individual element encoded in its type
08:33:20 <EvilTerran> so it's got more in common with tuples than with lists
08:33:21 <Berengal> That's true...
08:33:29 <Berengal> But there's not much we can do with that information currently
08:33:36 <EvilTerran> magic with typeclasses :)
08:33:38 <Berengal> We can't map over it for example
08:33:39 <jmcarthur> sure there is
08:33:42 <Berengal> Well that...
08:33:46 <idnar> Berengal: sure you can, you just need to write a type-level map :P
08:33:49 <jmcarthur> recursive functions definitions to work on n-tuples
08:34:02 <jmcarthur> *function definitions
08:34:13 <idnar> that sort of thing isn't very pretty, though
08:34:21 <jmcarthur> currently you have to write a separate overloaded function for every tuple length you may want
08:34:41 <EvilTerran> the thing to use would probably be something like "infixr :*:; data x :*: xs = x :*: !xs"
08:35:09 <quicksilver> you can do all kinds of horrific things with it
08:35:09 <EvilTerran> making the second parameter of the constructor strict would mean that you wouldn't end up with partly-defined tuples, which is probably a good thing
08:35:13 <quicksilver> those things have a name, collectively
08:35:18 <quicksilver> we call them 'HList'
08:35:22 <EvilTerran> quicksilver, olegian?
08:35:25 <EvilTerran> ah, or that :)
08:35:40 <quicksilver> and we fear them, like cthulhu
08:36:18 <vixey> Berengel: you can use GADTs to write programs like this
08:36:20 <sm> hi all.. what does the >>> mean in haskell weekly news ?
08:36:38 <alexsuraci> has anyone gotten the llvm package to work?
08:36:46 <Berengal> There's much type hackery I haven't looked at yet I see
08:36:59 <EvilTerran> ?hoogle >>>
08:36:59 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
08:37:04 <EvilTerran> sm, probably that
08:37:35 <sm> how so ? it appears before some links and not others
08:37:48 <EvilTerran> oh, right, it's not in code? never mind me, then
08:38:03 <jmcarthur> i've not given it an honest look, but HList seems far removed from the n-tuples i think i am talking about
08:38:27 <EvilTerran> jmcarthur, well, HList includes quite a few other things based around similar type hackery as well, iirc
08:38:35 <quicksilver> jmcarthur: HList is exactly the tuples you are talking about
08:38:41 <quicksilver> HNil takes the part of ()
08:38:46 <quicksilver> and HCons the part of (,)
08:39:14 <quicksilver> HList is actually just a bunch of typeclasses and typeclass functions over nested tuples.
08:39:59 <jmcarthur> looking at it now. i see
08:40:41 <quicksilver> of course, the name 'encourages' you to think of them as heterogenous lists.
08:40:46 <quicksilver> but they are tuples too ;)
08:40:57 <quicksilver> it's just a quesiton of viewpoint.
08:41:03 <quicksilver> and bottoms, if you care about them.
08:43:31 <sm> byorgey: what does >>> mean in HWN ?
08:44:19 <mun> hi
08:44:29 <mun> does anyone know what newemptymvar does?
08:44:40 <copumpkin> can :: be an infix type constructor?
08:44:42 <mun> newEmptyMVar
08:44:53 <copumpkin> or data constructor
08:44:57 <mun> how is newEmptyMVar different to newMVar
08:45:10 <jmcarthur> copumpkin, it's reserved afaik
08:45:20 <EvilTerran> copumpkin, it's reserved for type annotations
08:45:28 <copumpkin> boo
08:45:42 <copumpkin> I wanted to write x :: a :: b :P
08:45:47 <mun> is newEmptyMVar same as newMVar Nothing?
08:45:58 <EvilTerran> ?hoogle newEmptyMVar
08:45:58 <lambdabot> Control.Concurrent.MVar newEmptyMVar :: IO (MVar a)
08:46:05 <EvilTerran> ?hoogle newMVar
08:46:05 <lambdabot> Control.Concurrent.MVar newMVar :: a -> IO (MVar a)
08:46:20 <Axman6> mun: no
08:46:21 <jmcarthur> mun, newEmptyMVar means it's ready for a value to be placed in it
08:46:37 <jmcarthur> mun, newMVar means it is already filled and trying to insert something else will block
08:46:48 <mun> oh ok
08:46:56 <mun> thanks
08:46:57 <Axman6> mun: newMVar Nothing would create an MVar filled with Nothing, and not be empty
08:47:09 <sjanssen> mun: the result of newMVar Nothing has type MVar (Maybe a), the result of newEmptyMVar has type MVar a
08:47:14 * mux is getting really disappointed with the haskell community
08:47:21 <sjanssen> mux: ?
08:47:23 <jmcarthur> mux, why?
08:47:35 <Axman6> mux: too helpful?
08:47:53 <mux> I know this will probably sound harsh and/or weird - I've been helped a lot when I was still a beginner, but now that I'm asking more advanced questions on haskell-cafe@, I get 0 answers
08:48:05 <copumpkin> mux: try #haskell-in-dept
08:48:06 <copumpkin> h
08:48:07 <mux> I've sent 2 mails to this mailing list, and never got any single reply
08:48:11 <edwardk> mux: what is the question?
08:48:13 <mux> I tried haskell-in-depth too.
08:48:16 <Axman6> mux: well ask in here
08:48:17 <Sargun_screen> hat am I overengineering?
08:48:25 <vixey> mux -- link ?
08:48:26 <copumpkin> mux: could it be that your question is too hard or questionably phrased?
08:48:30 <copumpkin> :P
08:48:37 <jmcarthur> #haskell-in-depth is just too quiet. i stopped frequenting it. got tired of trying to watch extra channels
08:48:38 <mux> mmm, let me point you at my mail
08:48:55 <Axman6> mux: in my experience, haskell peeps are all to hapy to discuss very indepth topics if give the chance
08:49:00 <vixey> you can bring up some topic in #haskell-in-depth if it's too quiet :p
08:49:02 <Axman6> given*
08:49:08 <edwardk> hah
08:49:29 <Axman6> Sargun_screen: ?
08:49:30 <jmcarthur> @quote passe
08:49:30 <lambdabot> Ethereal says: If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the
08:49:30 <lambdabot> point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
08:49:32 <mux> http://www.haskell.org/pipermail/haskell-cafe/2009-April/059919.html
08:49:43 <mux> here you are
08:49:50 <vixey> mux oh it's about optimization.. boring
08:49:57 <mux> hah.
08:50:18 <mux> I think I know what the problem is now :-P the haskell community is bored by optimization questions
08:50:22 <jmcarthur> i say it is possible that nobody knows the best answer to that question
08:50:28 <edwardk> mux: ah i remember the post, the problem i had was i didn't have a good concrete response i could give
08:50:34 <mux> there are definitely some clues to be given
08:50:38 <edwardk> mux: we are =)
08:50:43 <sjanssen> mux: answer is probably "yes"
08:50:54 <sjanssen> unboxed arrays are a big win
08:51:01 <malcolmw> mux: you didn't exactly ask a question - more just gave some code and said "what do you think?"
08:51:02 <edwardk> mux: basically big arrays of boxed things hurt
08:51:08 <mux> sjanssen: yeah but that's not really answering the question
08:51:14 <edwardk> mux: its an issue that we've been actively looking into
08:51:14 <mux> malcolmw: yes, that's right
08:51:30 <mux> it seems to me that STArray involve the GC somehow too much
08:51:32 <copumpkin> mux: so he's right, but sjanssen didn't answer the question? :P
08:51:43 <malcolmw> mux: I expect all the optimisation hackers have been having a holiday break :-)
08:51:49 <mux> copumpkin: if I didn't really ask a question, yes cannot be the answer :-)
08:51:53 <edwardk> mux: the garbage collector has to rescan the entire array any time you mutate any element of it
08:52:06 <edwardk> mux: there is no cardmarking in the current gcs handling of mutable arrays
08:52:07 <Axman6> mux: could possibly try a STUArray for the indicies
08:52:08 <mux> edwardk: ah, that's already one thing I wanted to hear but didn't know :-)
08:52:21 <mux> Axman6: read my mail completely, there is a second version of the code that does just that
08:53:02 <Axman6> mux: did you notice the U there?
08:53:11 <mux> Axman6: yes
08:53:18 <copumpkin> he just says unboxed ST array
08:53:25 <mux> Axman6: the second version of the code uses an STUArray for the indices
08:53:27 <edwardk> Axman6:  idxs <- newListArray bnds [0..] :: ST s (STUArray s Int Int)
08:53:32 <edwardk> is in the second version
08:53:33 <copumpkin> what's with the .bin stuff?
08:53:38 <Axman6> ok, well i havent seen the code yet
08:53:41 <mux> copumpkin: I've been wondering that too!
08:53:52 <tux-foo> is IO String a constructor of some algebraic type?
08:53:58 <jmcarthur> "I'd be curious to hear about any possible improvements to it, and whether the performance of STArray of ByteString I'm observing corresponds to people's expectations."  <-- I think you would have received more direct answers with a more direct question.
08:54:00 <kadaver> what does ! mean there? strict? and what does strict mean in that way?
08:54:05 <EvilTerran> tux-foo, no, IO String is a type
08:54:07 <sjanssen> tux-foo: IO is an abstract type
08:54:17 <lilac> mux: if you use a boxed STArray for the indices, is the performance of the two about the same?
08:54:18 <mux> jmcarthur: yeah, I should have probably said that differently
08:54:26 <Axman6> anyway, battery's about to die, night all
08:54:46 <EvilTerran> tux-foo, and (IO a) is an abstract type, so you can't see whatever constructors it may have
08:55:02 <mux> lilac: didn't try this, but given what edwardk just said about STArray and the GC, I'd expect it to be still faster because there would be less scanning/copying involved
08:55:04 <tux-foo> EvilTerran, then how can I patternmatch on IO String ?
08:55:11 <tux-foo> to get the String out of it?
08:55:12 <jmcarthur> not that i'm just passing it off as "your fault, not ours," just that many people probably skim emails for questions before reading them more carefully to make sure they won't waste their time
08:55:16 <copumpkin> tux-foo: you can't
08:55:17 <EvilTerran> tux-foo, with >>=
08:55:24 <mux> tux-foo: foo <- bar; case foo of ...
08:55:32 <jmcarthur> and if the question isn't clear, it won't be clear whether time will be wasted
08:55:32 <edwardk> mux: w.r.t how to get the first version faster you can chunk the array and maintain a second spine of chunks, but thats just a bandaid to emulate cardmarking
08:56:05 <edwardk> mux: and in general i try to only use mutable arrays of unboxed values to avoid gc overhead so the second approach is in many ways more useful
08:56:06 <mux> edwardk: also, that's reinventing lazy bytestrings somehow
08:56:14 <edwardk> no sense adding a level of indirection
08:56:25 <tux-foo> EvilTerran, kk
08:56:42 <edwardk> mux: kinda, but lazy bytestrings use lists as the spine, not another array ;)
08:56:45 <mux> but the second approach is suboptimal algorith-wise
08:56:55 <mux> edwardk: *nods*
08:57:13 <EvilTerran> tux-foo, the thing about the way IO is done in haskell is that *anything* with real-world side-effects will have a type IO {something}; as such, you can only "extract" the (a) from an (IO a) in such a way that whatever uses the (a) also has an IO type
08:57:32 <edwardk> mux: basically a factor of 2 overhead?
08:57:36 <EvilTerran> ?type (>>=)
08:57:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:57:43 <edwardk> space wise anyways
08:58:10 <edwardk> its still asymptotically the same =)
08:58:11 <mux> edwardk: less, because the indices array is much smaller (it doesn't contain the strings)
08:58:22 <EvilTerran> ^ given an IO String, you can extract the value from it to pass to a function that expects a String (via >>=), but only if that function itself returns an IO {something}
08:58:41 <edwardk> mux: well, i meant the array of pointers vs an array of pointers and an array of integers, i was ignoring the cost of the strings which is included in both
08:58:48 <mux> ok
08:59:13 <EvilTerran> tux-foo, you can also use do-blocks, which de-sugar into uses of >>=
08:59:40 <edwardk> mux: other options would be to store StablePtrs to bytestrings, but i'd probably want to throw up if you did ;)
08:59:51 <mux> edwardk: I also have another incredibly evil 3rd version of the code that uses the ByteStrings internals to get a STUArray of CString
08:59:54 <mux> hah
09:00:01 <mux> just when I was mentioning it
09:00:17 <edwardk> well, how much faster is it?
09:00:18 <mux> it's really gory
09:00:31 <edwardk> i'm sure dons would love it =)
09:00:37 <quicksilver> edwardk, mux: I read mux's email. I was surprised, bt I couldn't answer it.
09:00:52 <mux> actually it's slower (for now) because I couldn't use unsafeUseAsCString because I need the terminating \0
09:00:53 <quicksilver> edwardk: he replaced an STArray of bytestrings with an STUArray of indices.
09:01:01 <edwardk> ah
09:01:02 <quicksilver> but surely that is very much what an STArray is!
09:01:07 <mux> quicksilver: ah!
09:01:11 <sjanssen> mux: ultimately, I think the UArray/STUArray Int solution is the best possible.  This way you can scramble a list of any type optimally
09:01:12 <mux> quicksilver to the rescue
09:01:13 <quicksilver> an STArray *is* an STUArray of pointers, isn't it?
09:01:22 <quicksilver> sadly not, I don't know the answer.
09:01:22 <sjanssen> quicksilver: no, it isn't
09:01:27 <quicksilver> sjanssen: why not?
09:01:27 <edwardk> quicksilver: not exactly, because he only shuffles.
09:01:28 <sjanssen> @src STArray
09:01:28 <lambdabot> data STArray s i e = STArray !i !i (MutableArray# s e)
09:01:34 <edwardk> quicksilver: he never loses a reference
09:01:34 <sjanssen> @src STUArray
09:01:34 <lambdabot> Source not found.
09:01:40 <edwardk> its just a braiding of the original aray
09:01:42 <mux> the answer is most likely 42. if only I could get the question
09:02:08 <quicksilver> sjanssen: that doesn't quite meaning anything to me. But isn't a boxed array an array of boxes?
09:02:10 <edwardk> quicksilver: if he added new elements or deleted elements, then the collector would have work to do
09:02:10 <mux> useByteStringsAsArray :: [ByteString] -> (IOUArray Int CString -> IO a) -> IO a
09:02:12 <quicksilver> and boxes are pointers
09:02:15 <mux> you know you want it. :-)
09:02:32 <sjanssen> quicksilver: STArray is a MutableArray#, STUArray is a MutableByteArray#
09:02:33 <mux> I'll have to polish this third version and send it off to dons
09:02:43 <quicksilver> sjanssen: Oh. That sounds odd.
09:02:54 <copumpkin> it's the same general idea though, isn't it?
09:02:56 <quicksilver> sjanssen: Why should there be a big difference between them?
09:02:56 <sjanssen> quicksilver: of course at some level they're all just arrays of bytes, but GHC treats the two things rather separately
09:02:59 <quicksilver> I mean, is my point clear?
09:03:00 <edwardk> quicksilver: what the indexing array lets him do is shuffle indexes without mutating the boxed array, mutating the boxed array flags it as dirty and forces the gc to rescan the whole thing. shuffling integer indexes in an unrelated array doesn't do that
09:03:07 <quicksilver> an array of boxes is an array of pointers
09:03:09 <sjanssen> quicksilver: garbage collection, I'm sure
09:03:11 <edwardk> quicksilver: yes, but he can't do as much
09:03:15 <quicksilver> an unboxed array of indices is much like an array of pointers.
09:03:19 <mux> quicksilver: you just achieved expressing my question much better than I did in my mail
09:03:26 <mux> it didn't seem right that the performance difference was that big
09:03:30 <edwardk> quicksilver: yes, but you have to chase pointers during garbage collection
09:03:37 <quicksilver> ah!
09:03:38 <edwardk> quicksilver: you don't chase integers
09:03:50 <quicksilver> OK, that makes sense, sort of.
09:03:58 <mux> why can't we "freeze" an STArray and get something resembling STUArrays more?
09:04:05 <edwardk> quicksilver: the gc contains a hack that knows not to rescan an array that doesn't change
09:04:05 <quicksilver> intriguing.
09:04:09 * quicksilver nods
09:04:09 <sjanssen> mux: freeze it how?
09:04:15 <mux> sjanssen: beats me
09:04:22 <edwardk> mux: because few applications solely 'braid' the contents of an array
09:04:37 <edwardk> mux: usually you introduce new references or delete them
09:05:23 <edwardk> http://en.wikipedia.org/wiki/Braid_group
09:05:37 <mux> so STArray's are not really designed with heavy mutability in mind?
09:05:56 <edwardk> mux: no, they are, you just use less than all of what they can do
09:06:26 <edwardk> mux: your integer index solution wouldn't work if you had to set the second element of your array equal to your first.. or rather it would, but it would leak the reference to the old second element
09:06:42 <edwardk> mux: because it would be present in the array, but unreachable
09:06:58 <kadaver> what does ! mean there? strict? and what does strict mean in that way?
09:07:01 <edwardk> mux: it also doesnt work if you need to introduce new elements into the array
09:07:04 <kadaver> data Neuron = Neuron !Inputs !Weights !Threshold
09:07:16 <kadaver> what is the significance of ! there
09:07:22 <copumpkin> kadaver: like sticking a seq on all those things when you construct it
09:07:24 <edwardk> because that will require you to mutate the big STArray, which in the absence of card marking requires rescanning of the entire array
09:07:27 <mux> edwardk: I'm not sure I follow you here
09:07:51 <edwardk> mux: Ok, say you have a reference to an STArray.
09:07:56 <mux> oh my, I had forgotten that the third version I've been writing uses bogus foreign imports to printf() :-)
09:08:10 <edwardk> From that array you can access anything in it by asking for a given element
09:08:19 <edwardk> so the arbage collector can't throw any of them away, right?
09:08:24 <mux> yep
09:08:30 <edwardk> until you lose the reference to the entire array
09:08:55 <edwardk> when you set the second element of the array to equal the value to the first. you 'lose' a reference to that oild second element. you've mutated the array.
09:09:13 <edwardk> during the next gc scan the garbage collector knows youve changed the array so it has to rescan the whole beast
09:09:28 <gnuvince> If I have a [FilePath] such as ["/etc", "/etc/passwd"] and I want to use System.Directory.doesDirectoryExist to filter out the dirs, how would I do that considering that doesDirectoryExist is FilePath -> IO Bool?
09:09:30 <copumpkin> how is a braid different from a permutation?
09:09:33 <edwardk> because then it can reclaim the memory used by that second element if no one else holds a reference
09:09:39 <edwardk> copumpkin: its not
09:09:43 <copumpkin> oh
09:09:45 <sjanssen> gnuvince: filterM
09:09:51 <gnuvince> :t filterM
09:09:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:10:02 <gnuvince> sjanssen: great, thanks!
09:10:09 <sjanssen> > filterM (const [True, False]) "abc"
09:10:10 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
09:10:12 <mux> edwardk: ok
09:10:20 <copumpkin> edwardk: oh, but it does look kinda different, in the 5th row example on that wikipedia page
09:10:54 <copumpkin> up until then it just looked like composing permutations
09:11:05 <edwardk> mux: if you used integer indexes from an STUArray to 'emulate' a mapping that wasn't a permutation, i.e. that could include repeats, then you prevent the garbage collector from reclaiming
09:11:10 <copumpkin> but it seems to retain twisty information
09:11:27 <mux> edwardk: yes I get that
09:12:07 <edwardk> mux: and if you go and introduce a new value by setting it you'd also force it to rescan, since you wouldn't have that in the original array, and the integer scheme would fail on that case as well
09:12:24 <mux> edwardk: surely the GC could coalesce the scans?
09:12:27 <edwardk> mux: so what you've done is found a way through the integer indexes to get the garbage collector to let you have your cake and eat it too
09:12:34 <edwardk> mux: but it'd still have to scan something
09:12:35 <mux> one scan per mutation does't sound like such a good idea
09:12:56 <sjanssen> there isn't one scan per mutation AFAIK
09:13:00 <edwardk> mux: its not one per mutation, its one per collection in which something was mutated since the last collection
09:13:09 <edwardk> you get a dirty bit set
09:13:10 <mux> ok
09:13:19 <edwardk> but those arrays can be huge
09:13:43 <edwardk> so when that array is a significant portion of your memory consumption in an app, thats a ton of busy work to do during a collection
09:13:57 <edwardk> just because somebody mutated something somewhere in the array
09:14:03 <edwardk> that is the benefit of cardmarking approaches.
09:14:14 <copumpkin> what is cardmaking?
09:14:52 <copumpkin> cardmarking :P
09:14:56 <quicksilver> "if this card hasn't changed since the last GC I don't need to scan it again"
09:15:02 <edwardk> cardmarking is the garbage collection practice of marking a 'page' as needing rescan rather than individual objects. it lets you trade off the amount of stuff that needs to be scanned vs. the space cost of including individual markings for every element
09:15:17 <copumpkin> ah
09:15:41 <edwardk> a page here could represent, say 8192 contiguous elements in the array
09:15:50 <quicksilver> I continue to have the sneaking suspicion that some simple region analysis could really improve GHC's GC, but no idea how to make a practical suggestion out of it.
09:15:54 <edwardk> then there is still some rescanning, but its not the entire 2 gigabyte array
09:15:58 <copumpkin> surely the only thing that really needs checking is whatever used to be in the array at the index you changed?
09:16:51 <edwardk> quicksilver: region analysis is painful in a lazy setting and often gets in the way. i speak as someone whose entire GC has correctness guarantees that rely on how I use regions. ;)
09:17:11 <edwardk> copumpkin: congratulations you just required a write barrier on all array mutations ;)
09:17:12 <quicksilver> edwardk: I didn't know you had a GC>
09:17:29 <quicksilver> that must explain why there is so much food in your beard. The GC will pick it up later.
09:17:35 <edwardk> quicksilver: =)
09:17:52 <edwardk> my wife doesn't like it when you call her the garbage collector.
09:17:54 * mux wishes he could have come to the fifth hackathon
09:17:54 * quicksilver doesn't know if edwardk has a beard, but by the modules he has written he clearly deserves one. 
09:18:06 <edwardk> she prefers personal hygienist ;)
09:18:07 <copumpkin> :P
09:19:53 <edwardk> basically what i do in my current gc is rely on the fact that only one logical thread is allowed to write into a region except to add references to pinned objects in other regions. when you gc you propagate the pins you placed in objects in your regions, and you can copy collect the rest
09:20:13 <quicksilver> that sounds sensible.
09:20:17 <quicksilver> so why don't you like it? :)
09:20:20 <edwardk> the pinned stuff may be accessed by other logical threads, so must be deferred to a bigger collection, it lets me gc most of my stuff locally
09:21:08 <edwardk> well, i can never lose a reference, because then the integrity of the entire system fails. i get away without either a read _or_ a write barrier and get separate collection, but i can't HAVE mutable arrays ;)
09:21:41 <mux> my program would be dramatically slow with your GC then
09:21:41 <edwardk> at least not via a straightforward translation
09:22:06 <edwardk> mux: actually you'd be able to get by on other guarantees to make it work, but the direct translation would suck ;)
09:22:47 <edwardk> the system works well for cilk or erlang style parallelism
09:22:58 <mux> edwardk: as long as I don't have to prove reflexivity of equality along the way, I'm fine with that
09:24:36 <alexsuraci> I'm writing a static, compiled language in Haskell - what is the best way to have it compile? (A pretty generic question, I know.) I've been looking at LLVM and it looks more like something you use in Haskell code itself. Plus I can't get it to work, I get an error when I try to compile.
09:24:56 <jeffersonheard> oy.  writing a GL backend to Hieroglyph is a pain.  80% done, though
09:24:58 <opqdonut> llvm worked nice for me
09:25:12 <opqdonut> there's a haskell dsl for generating llvm code
09:25:24 <alexsuraci> opqdonut: Thought that was the llvm package?
09:25:29 <edwardk> alexsuraci: you can use LLVM both in memory and to generate output
09:25:58 <alexsuraci> I get this error when trying to compile a basic Haskell + LLVM example: /usr/lib/ghc-6.10.1/base-3.0.3.0/libHSbase-3.0.3.0.a(Generics__1.o):(.text+0x2b): undefined reference to `__stginit_syb_DataziGenerics_'
09:26:02 <alexsuraci> collect2: ld returned 1 exit status
09:26:07 <edwardk> alexsuraci: lennarts examples are all about doing so directly in memory, but I've used LLVM almost exclusively to compile down to executables.
09:26:25 <edwardk> alexsuraci: did you forget to use --make or something?
09:26:36 <alexsuraci> edwinb: nope, "ghc --make llvm.hs"
09:26:43 <mux> yes, that means you're missing the package containing Data.Generics
09:26:51 <alexsuraci> I have syb installed
09:27:07 <quicksilver> you should get a compile error if the package isn't installed
09:27:09 <mux> alexsuraci: but you still have to use -package syb or use --make
09:27:17 <quicksilver> the fact you get a link error suggests the package is installed but broken.
09:27:18 <quicksilver> I think.
09:27:28 <quicksilver> like the libs have been deleted or moved.
09:27:30 <alexsuraci> quicksilver: that's what I'm thinking
09:27:33 <edwardk> I think perhaps your install of the package is broken
09:27:54 <quicksilver> perhaps you've recompiled some things against the new syb and some things still link to the old
09:27:57 <alexsuraci> I tried installing it via "cabal install syb", which failed because my base is 3.x and it was trying to install a newer version of syb
09:28:00 <quicksilver> diamond dependency for the lose.
09:28:12 <alexsuraci> So then I downloaded the syb-1.0.0.0 package and cabal installed from there
09:28:15 <edwardk> alexsuraci: what version of ghc are you using?
09:28:25 <alexsuraci> edwardk: 6.10.1
09:28:33 <edwardk> why base 3?
09:28:37 <alexsuraci> On Arch linux if that matters
09:28:50 <alexsuraci> I haven't the slightest idea, that seemed off, but I don't know how I'd upgrade it.
09:29:06 <alexsuraci> "cabal upgrade base" explicitly blocks it, probably for good reason (says "impossible")
09:29:36 <edwardk> you should have both installed with 6.10.2, it just defaults to 3 unless explicitly overridden by the package you are working with
09:29:44 <edwardk> er 6.10.1
09:29:58 <alexsuraci> hrm
09:30:53 <alexsuraci> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3874#a3874 There's the cabal output when I try to install syb 0.1.0.1
09:31:18 <da-x> is there a comman-line equivalent of hoogle?
09:31:44 <sm> yes, I think it's "hoogle"
09:31:47 <sm> also hoogle.el
09:31:57 <sm> or maybe that's part of haskell-mode now
09:33:14 <alexsuraci> edwinb: "cabal list base" shows that I have base 4.0.0.0 installed, too.
09:34:57 * da-x would like to know the APIs by heart so he wouldn't need to be 80% of the time on a browser when coding in Haskell.
09:35:23 <edwardk> alexsuraci: you should be able to build whatever you want inside of a cabal package that references a build-dependency on base >= 4 ;)
09:35:58 <edwardk> or add a spurious reference to one of my libs, because i don't think anything i write allows base < 4
09:36:03 <quicksilver> da-x: I have two browser tabs open permanently - the base API reference, and the hackage package list
09:36:05 <edwardk> =)
09:38:38 <bavardage> how do I get haskell to display unicode?
09:38:43 <bavardage> when I do print "λ"
09:38:53 <bavardage> I get either \0277 or a caret
09:39:08 <bavardage> » <-- is that called a caret? one of those anyway
09:39:10 <bavardage> dammit no
09:39:11 <bavardage> guillemots
09:39:13 <edwardk> bavardage: the problem is the default print stuff just take your char mod 256.
09:39:21 <bavardage> hmm
09:39:24 <quicksilver> ^ that's a caret
09:39:29 <bavardage> yeah I realised :D
09:39:31 <quicksilver> bavardage: utf8-string
09:39:32 <lilac> bavardage: probably your terminal
09:39:33 <lilac> ^
09:39:37 <lilac> ^ that's a caret
09:39:38 <bavardage> this is for show
09:39:40 <quicksilver> especially the IO part of it.
09:39:43 <edwardk> bavadage: the Binary instance for Char is utf8 encoding
09:39:48 <quicksilver> show will produce \0277
09:39:49 <bavardage>  show (Lambda i t) = "(λ "++show i++". " ++ show t ++ ")" <-- so I have this
09:40:11 <bavardage> but in gchi I get \0277 in emacs-shell and guillemots in urxvt
09:40:11 <quicksilver> bavardage: that's fine, as far as it goes
09:40:26 <quicksilver> you just need to not use putStrLn to print it
09:40:37 <quicksilver> (but rather something utf8-aware)
09:40:39 <bavardage> well I'm not printing it atm
09:40:41 <Saizan_> gah, another core package with a broken .cabal file
09:40:47 <quicksilver> ghci will always show you \0277
09:40:48 <Saizan_> ?bug
09:40:49 <bavardage> but I guess ghci isn't utf-8 aware either then?
09:40:49 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
09:40:52 <quicksilver> ghci is using the show instance (for string)
09:40:55 <quicksilver> bavardage: it is, actually.
09:41:00 <quicksilver> but it's still doing the right thing.
09:41:00 <bavardage> oh right
09:41:05 <edwardk> bavardage: the answer is not to print the string, you need to take that string and send it character by character through Data.Binary or do something else that spews utf-8
09:41:07 <bavardage> so why is it failing?
09:41:09 <quicksilver> the Show instance for string is supposed to escape to an 8 bit file.
09:41:16 <quicksilver> 7 bit even.
09:41:19 <bavardage> right
09:41:25 <bavardage> so how do I do that with lambda?
09:41:29 <quicksilver> and ghci uses the show instance if you just type a string.
09:41:36 <quicksilver> use System.IO.UTF8.putStrLn
09:41:37 <bavardage> rephrase my question
09:41:41 <quicksilver> (from utf8-string)
09:41:44 <bavardage> "How do I get ghci to give me a lamba for the show"
09:41:48 <bavardage> quicksilver: I don't want to print it
09:41:56 <bavardage> I just want ghci to show the thing properly
09:41:59 <bavardage> with a lambda
09:42:21 <edwardk> bavardage: you can't. ghci will use show, and then print it using the stupid mod 256 thing.
09:42:21 <quicksilver> it should do as long as you're not re-showing the string that got produced.
09:42:24 <alexsuraci> edwardk: http://hackage.haskell.org/trac/hackage/ticket/405
09:42:30 <alexsuraci> looks like I'm not alone
09:42:36 <edwardk> bavardage: now, that said, you _can_ sorta do it ;)
09:42:36 <quicksilver> edwardk: well, ghci uses show, not show.show
09:42:50 <quicksilver> ah, but ghci does use putstr
09:42:52 <quicksilver> duh.
09:43:22 <edwardk> bavardage: but the solution is ugly. just encode the utf-8 version of your string yourself. so now your Chars are bytes encoded as Chars, ugh the horror
09:43:56 <alexsuraci> ok, got syb 0.1.0.1 to install, same error though when trying to compile llvm.hs :/
09:44:06 <bavardage> oh god
09:44:08 <bavardage> edwardk: within show :P?
09:44:26 <edwardk> bavardage: yes
09:44:26 <bavardage> sounds yucky but I'll try
09:44:45 <edwardk> bavardage: it'll give you the appearance of what you want but it is completely the wrong solution
09:44:51 <bavardage> is there a library for this?
09:44:58 <bavardage> edwardk: this is really just for prettyness on the command line
09:45:02 <quicksilver> bavardage: incidentally you are abusing 'Show'
09:45:04 <quicksilver> don't do that :P
09:45:04 <bavardage> not going to be used for anything much
09:45:12 <bavardage> quicksilver: how am I abusing show?
09:45:18 <edwardk> bavardage: and yeah i'm with quicksilver =)
09:45:19 <quicksilver> show is for producing valid haskell code
09:45:24 <bavardage> oh fair enough
09:45:28 <quicksilver> which can be copy-pasted into test cases or back into your source
09:45:30 <bavardage> I'll stop doing what I'm doing
09:45:30 <edwardk> show ~ python's repr it should generate valid code
09:45:41 <quicksilver> pretty printing is a nice thing, it just deserves another name
09:45:44 <quicksilver> I tend to call it 'pp'
09:45:45 <bavardage> and make a 'toString' function or something
09:45:48 <bavardage> or pp
09:45:49 <bavardage> yup
09:45:51 <bavardage> I'll do that then :D
09:45:59 <edwardk> i usually make a nice class Pretty p where pretty :: p -> String -- to do what you're doing
09:46:14 <bavardage> shame you can't make ghci show pretty
09:46:17 <edwardk> or rather have pretty :: p -> Doc from Text.PrettyPrint.HughesPJ even
09:46:54 <edwardk> bavardage: if you figure out how, tell me, and i'll swap in a TeX renderer and get a decent texmacs command line
09:47:32 <quicksilver> texmacs isn't tex
09:47:39 <quicksilver> however, something like that would be really nice
09:47:40 <bavardage> edwardk: haha
09:47:45 <quicksilver> a workbook interface for gchi
09:47:54 <quicksilver> which can display all kinds of things including graphical results
09:47:58 <quicksilver> (cairo canvases?)
09:48:02 <bavardage> I guess it may be possible to build something like that over the top of gchi?
09:48:02 <edwardk> quicksilver: you're right, but it was easier than explaining in more detail ;)
09:48:23 <alexsuraci> oi, if it's this hard to get llvm working it seems like it'd be a bad choice for a compiler if users of the language would need to get it installed to compile.
09:48:25 <edwardk> quicksilver: embedded postscript was where i was going first, but yeah
09:48:33 <bavardage> someone go code something pl0x :D
09:48:41 <edwardk> alexsuraci: i never had a problem before
09:48:50 <bavardage> so make it use the class PrettyPrint
09:49:03 <bavardage> which has a toTex a toPrettyString ...
09:49:04 <bavardage> etc
09:49:21 <alexsuraci> Should it be saying base-3.0.3.0 here?: /usr/lib/ghc-6.10.1/base-3.0.3.0/libHSbase-3.0.3.0.a(Generics__1.o):(.text+0x2b): undefined reference to `__stginit_syb_DataziGenerics_'
09:49:22 <edwardk> bavardage: basically all i do is evaluate what i was going to do in ghci and say pretty $ in front ;)
09:49:25 <alexsuraci> that seems kind of off
09:49:34 <alexsuraci> you'd think it'd use base 4
09:49:45 <edwardk> alexsuraci: no it shouldn't
09:50:06 <bavardage> edwardk: yeah, but it would be good to have a ghci frontend :D
09:51:53 <edwardk> bavardage: i've put together a couple of texmacs front ends, the preferred messaging protocol isn't hard
09:52:13 <bavardage> these released anywhere?
09:52:16 <bavardage> screenshots etc?
09:52:46 <edwardk> bavardage: it was a few years ago, i might have some screenshots lying around, but they were for an old computer algebra system of mine that never got released
09:53:11 <copumpkin> computer algebra system in haskell? :o
09:53:27 <edwardk> bavardage: unfortunately i discovered haskell and couldn't bring myself to work on it any more ;)
09:53:33 <bavardage> hehe
09:53:34 <alexsuraci> looks like 6.10.2 is out, guess I'll upgrade and see what happens
09:53:44 <edwardk> actually it was more complicated than that, but the gist of that statement is accurate
09:53:45 <bavardage> how do I do the whole converting to bytes?
09:54:15 <edwardk> bavardage: just generate the utf-8 encoding of your lambda as a series of bytes
09:54:28 <bavardage> but how?
09:54:37 <bavardage> you mean don't actually type in a lambda in the source?
09:54:44 <bavardage> but me type in a series of bytes?
09:55:02 <edwardk> the latter
09:55:09 <bavardage> or do you mean via some function.
09:55:09 <bavardage> oh kk
09:56:44 <Baughn> So I'm back to lisp, to write a paper on it. That is.. on SLIME, rather. It's gotten scarily good over the last year..
09:57:05 <Nafai> SLIME is very nice
09:57:08 <wchogg> Baughn : what's changed in slime?
09:57:15 <Nafai> It would be nice to have something equivalent for Haskell
09:57:17 <wchogg> Baughn : I haven't really used it in the past year or two
09:57:31 <Baughn> wchogg: It's a lot more solid and.. lisp-machine-like, I'd have to say.
09:57:57 <Baughn> There's a class browser, presentations are thoroughly implemented and used, etc. etc. etc.
09:58:22 <edwardk> 0xCE 0xBB should be the encoding for lambda
09:58:41 <copumpkin> :o
09:58:44 <edwardk> so whatever the horrible haskell escape sequences are for literal characters, just encode the pair.
09:58:54 <copumpkin> in utf8?
09:59:12 <edwardk> copumpkin: i said up front it was a terrible hack ;)
09:59:19 <Baughn> Nafai: And yes, it really would. Geez.. I'm halfway tempted to try implementing it.. if only I had a spare year..
09:59:30 <Baughn> It'd need some deep hacking on ghc-api, though
09:59:32 <tux-foo> Does haskell know a EOF character?
09:59:49 <Nafai> Baughn: Agreed.
09:59:59 <Baughn> tux-foo: No, it doesn't run on DOS
10:00:00 <copumpkin> λ
10:00:07 <copumpkin> nothing uses EOF characters
10:00:08 <bavardage> edwardk: thanks..
10:00:15 <bavardage> edwardk: I just got that via python :D
10:00:15 <Baughn> copumpkin: Well..
10:00:19 <tux-foo> Baughn, kk
10:00:21 <edwardk> > "\xc3\xbb"
10:00:22 <bavardage> so lets find the escape
10:00:22 <lambdabot>   "\195\187"
10:00:39 <bavardage> > "\0c3\0bb"
10:00:40 <copumpkin> , text "\xc3\xbb"
10:00:41 <lambdabot>   "\NULc3\NULbb"
10:00:44 <lunabot>  û
10:00:48 <copumpkin> , utf8 "\xc3\xbb"
10:00:49 <lunabot>  luna: Not in scope: `utf8'
10:00:55 <bavardage> > "\c3\bb"
10:00:56 <lambdabot>   <no location info>:
10:00:56 <lambdabot>      lexical error in string/character literal at chara...
10:01:02 <copumpkin> , text "\xbb\xc3"
10:01:03 <lunabot>  ۃ
10:01:09 <bavardage> :D
10:02:14 <edwardk> bbiab, i think i've made it sufficiently clear that i do not endorse this plan ;)
10:02:28 <bavardage> >> "\0277"
10:02:33 <bavardage> > "\0277"
10:02:34 <lambdabot>   "\277"
10:02:39 <bavardage> > "\277"
10:02:41 <lambdabot>   "\277"
10:03:15 <copumpkin> I wonder if any editor for haskell supports "give me a list of things that match the type that the typechecker expects here" (extending the idea of autocomplete for haskell)
10:04:06 <Nafai> copumpkin: Oooo.  That's an interesting idea.  Something that calls Hoogle?
10:04:13 <Nafai> Intellisense via Hoogle?
10:04:27 <copumpkin> well, maybe using whatever went into hoogle even locally
10:04:31 <copumpkin> on the rest of the current file,
10:04:37 <lament> the problem with that is the haskell syntax
10:04:39 <copumpkin> but also pulling from other modules
10:04:48 <lament> in C#, you can write foo. <Tab>
10:04:56 <lament> and get completion for the methods of the class of foo
10:04:59 <copumpkin> well yeah, so the way I see it
10:05:03 <lament> in haskell, you begin by writing the function name
10:05:33 <copumpkin> say I type
10:05:54 <gal_bolle> lament: if you import your modules qualified, it's not a problem
10:06:02 <copumpkin> oh, I don't mean in that sense
10:06:43 <copumpkin> I type: flip map [1..5] <ctrl+tab> or something
10:07:05 <lament> gal_bolle: true. That type of completion already works at least in vim
10:07:20 <copumpkin> it should print out all things that match the type that is expected there
10:07:30 <sampointon> hi, does 6.10 support TH pattern brackets? It fails on my 6.8.2 install and I don't have an install of 6.10 handy to test
10:07:32 <copumpkin> :t flip map [1..5]
10:07:33 <lambdabot> forall a b. (Enum a, Num a) => (a -> b) -> [b]
10:07:45 <sampointon> I looked in the release notes but I didn't see a specific mention of it, too
10:07:51 <copumpkin> @hoogle (Enum a, Num a) => a -> b
10:07:51 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:07:52 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
10:07:52 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
10:07:56 <copumpkin> :P bad example
10:08:06 <copumpkin> but you know what I mean
10:08:24 <lament> this would force everyone to use flip map instead of map
10:08:36 <copumpkin> well, map was a contrived example
10:08:37 <lament> (it's called for?)
10:08:49 <lament> :t for
10:08:50 <copumpkin> flip mapM is forM, but is there a regular for?
10:08:50 <lambdabot> Not in scope: `for'
10:08:54 <lament> no for :(
10:09:09 <lament> @hoogle [a] -> (a -> b) -> [b]
10:09:10 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:09:10 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
10:09:10 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
10:09:17 <BONUS> there's a for_
10:09:21 <BONUS> in Foldable
10:09:26 <BONUS> @hoogle for_
10:09:26 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
10:09:43 <copumpkin> but the basic idea would be that the rest of what you write restricts what you could be writing where the cursor is at (and still be typesafe)
10:10:18 <copumpkin> so being able to pop up a list of completions or partial completions (a lambda that matches the correct constructor, for example)
10:10:36 <lament> you'd need to interact with GHC i guess
10:10:46 <lament> to determine the types of what's happening
10:11:28 <sampointon> lament: if I remember right, emacs' haskell-mode can do local type inference already
10:11:49 <lament> "local" meaning within one file?
10:12:31 <copumpkin> lament: yeah, it would definitely need to talk to GHC for something like that to work
10:12:34 <copumpkin> but it  could be cool
10:12:43 <lament> yeah
10:12:58 <copumpkin> but typical parameter orders would often make it less useful than it could be
10:12:59 <lament> also, mouse over expression to show its type :)
10:13:02 <wli> Not necessarily. You could just reimplement the type inference algorithms.
10:13:13 <copumpkin> wli: yeah, but do we want to do that? nope :P
10:13:20 <copumpkin> wli: especially considering all the extensions
10:13:28 <Peaker> sampointon: what inference does emacs haskell mode do?  I think it doesn't do any, only knows to show hoogle/syntactic references for certain built-in strnigs
10:14:01 <wli> copumpkin: The concern likely has more to do with the changes in the extensions than the extensions per se.
10:14:15 <sampointon> Peaker: looking at http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs , it can do it on any imported module
10:14:17 <lament> supporting this thing will certainly be Hell
10:17:10 <wli> I could envision wanting a type inference algorithm whose method of operation is different, and also wanting to worm one's way into the inner workings of it.
10:18:13 <copumpkin> it just seemed like a cool idea, probably not practical
10:18:34 <Peaker> we need non-textual editors, damnit :-(
10:18:53 <wli> Essentially for a style of error reporting more symmetric in the inconsistent usages, and also having the editor/IDE automatically go to the various sites of mutual inconsistency.
10:18:56 * Peaker is drowned with unfun C code at work, and can't work on his non-textual editor :(
10:20:22 <bavardage> does anyone know how to encode raw bytes in haskell?
10:20:26 <bavardage> similar to python's \x?
10:20:35 <copumpkin> same way
10:20:41 <wli> It essentially requires phase separation between constraint generation and constraint solution.
10:20:49 <bavardage> copumpkin: with \x?
10:20:52 <copumpkin> > "\x30"
10:20:53 <lambdabot>   "0"
10:20:56 <copumpkin> python didn't invent it :)
10:21:07 <sbahra> > "\x41"
10:21:08 <lambdabot>   "A"
10:21:23 <wli> One of the happy coincidences there is that if you've got the constraints sitting around somewhere as a dynamic set, you can just fiddle with the set of constraints when the code is modified.
10:21:53 <Baughn> bavardage: There's always the "use TH to read a file" solution
10:21:59 <bavardage> Baughn: I'm not reading a file
10:22:06 <bavardage> I just want to be able to put a lamba to ghci
10:22:36 <bavardage>  which is '\xce\xbb'
10:22:51 <Baughn> Well, sure, you can do that
10:22:51 <bavardage> Prelude> "\xce\xbb"
10:22:52 <bavardage> "\206\187"
10:22:55 <bavardage> Baughn: how ;P
10:22:58 <bavardage> I don't care that a 'can'
10:23:00 <bavardage> I JUST WANT TO :D
10:23:08 <Baughn> bavardage: You need to specify the unicode code-point, not the utf-8 encoded version
10:23:10 <bavardage> > "\206\187"
10:23:11 <lambdabot>   "\206\187"
10:23:17 <bavardage> Baughn: how?
10:23:17 <copumpkin> bavardage: your problem is that string captures unicode codepoints
10:23:28 <Baughn> bavardage: Go look it up on unicode.com
10:23:29 <bavardage> in urxvt I end up with guillemots instead
10:23:37 <Baughn> bavardage: "\x7123" or something
10:23:38 <bavardage> Baughn: but specify it where?
10:23:44 <bavardage> kk
10:23:46 <copumpkin> 03bb
10:23:55 <copumpkin> , text "\x03bb"
10:23:56 <lunabot>  
10:24:00 <copumpkin> hmm
10:24:18 <bavardage> Prelude> "\xce\xbb"
10:24:19 <Baughn> No, 03bb is double-greater-than or something
10:24:22 <bavardage> oops
10:24:24 <alexsuraci> gasp!
10:24:27 <Baughn> bavardage: That's /two/ letters
10:24:34 <bavardage> > "λ"
10:24:35 <lambdabot>   "\955"
10:24:41 <alexsuraci> upgraded to ghc 6.10.2, now llvm.hs compiles. hmm
10:24:41 <bavardage> :|
10:24:42 <Baughn> bavardage: putStrLn "\955"
10:24:51 <bavardage> Baughn: but I don't want putStrLn
10:24:57 <bavardage> I care about ghci's output
10:25:08 <Baughn> bavardage: Eh. Sounds like you'll need to rewrite ghci, then.
10:25:11 <bavardage> pfft
10:25:12 <Baughn> It escapes non-ascii.
10:25:22 <bavardage> ghci really should cope with unicode :(
10:25:24 <sampointon> that sounds like it ought to be an option
10:25:53 <copumpkin> Baughn: 03bb looks like lambda to me
10:26:01 <copumpkin> > "\30"
10:26:02 <lambdabot>   "\RS"
10:26:07 <copumpkin> oh, it's not hex?
10:26:07 <bavardage> > "\03bb"
10:26:08 <lambdabot>   "\ETXbb"
10:26:17 <bavardage> > "\03\bb"
10:26:17 <copumpkin> octal?
10:26:18 <Baughn> copumpkin: Yeah, I"m not sure what's with that. I think my terminal might be broken.
10:26:19 <lambdabot>   "\ETX\bb"
10:26:25 <copumpkin> wait, not octal either
10:26:25 <Cale> urxvt doesn't seem to like my IME at all :P
10:26:38 <copumpkin> Baughn: don't think it is
10:26:48 <Baughn> copumpkin: I'm not getting a lambda.
10:26:53 <copumpkin> yeah, me neither :P
10:27:10 <Baughn> ..you just said it "looks like lambda to me", though. -_-
10:27:17 <copumpkin> oh, I mean
10:27:22 <copumpkin> the unicode codepoint 03bb looks like a lambda
10:27:26 <Cale> hmm, I should upgrade ghc. I wonder if the new version supports unicode input yet :)
10:27:27 <copumpkin> in my unicode cheker
10:27:29 <copumpkin> checker
10:27:36 <Cale> (I mean, ghci :)
10:27:38 <copumpkin> > chr 0x03bb
10:27:39 <lambdabot>   '\955'
10:27:42 <copumpkin> aha
10:27:48 <Peaker> Cale: is it me or were you absent here for a while?
10:27:55 <Cale> Peaker: I've been around.
10:28:04 <copumpkin> what base is 955 in?
10:28:18 <Cale> Peaker: Lately I've been more focused on studying Japanese.
10:28:24 <copumpkin> :o
10:28:27 <Peaker> Cale: hai
10:28:31 <bavardage> I just get \955 displayed always
10:28:39 <copumpkin> oh
10:28:41 <copumpkin> 955 is decimal
10:28:42 <copumpkin> lol
10:28:50 <copumpkin> which is 3bb in decimal
10:28:55 <bavardage> *hex
10:28:56 <bavardage> yeah
10:28:58 <luite> Cale: just for fun, or are you going to do a jlpt?
10:29:11 <copumpkin> bavardage: *decimal
10:29:15 <Cale> Just for fun.
10:29:25 <lament> are you into anime?
10:29:28 <bavardage> oh nm
10:29:40 <copumpkin> bavardage: I admit it's ambiguous: P
10:29:42 <bavardage> copumpkin: yeah I get you
10:29:43 <Cale> lament: Well, moreso now that I've started learning.
10:29:46 <bavardage> I parsed it differently :D
10:29:50 <copumpkin> yeah :)
10:29:57 <copumpkin> FMA is a  good anima
10:29:58 <copumpkin> anime
10:30:05 <Peaker> lament: did you watch South Park's "good times with weapons" episode?
10:30:09 <lament> Peaker: no.
10:30:27 <Cale> But mostly I'm learning Japanese because ever since I learned kana and a few kanji when I was 4 or 5 years old, I've been annoyed that I don't really know Japanese.
10:30:35 <copumpkin> aw
10:30:36 <Peaker> lament: about Japanese Anime, and definitely one of the top 5 of South Park (IMO its #2 :-)
10:30:43 <lament> heh
10:30:46 <copumpkin> Cale: why did you start that early? :o
10:31:02 <Cale> copumpkin: An obsession with symbols that I apparently never quite grew out of.
10:31:07 <copumpkin> ah :)
10:31:22 * copumpkin is obsessed with unicode and kanji, which I guess is similar
10:31:33 <sampointon> Cale: I'm in awe, I couldn't stick learning the kana even with the promise that as soon as I learned the hiragana I'd start the interesting stuff
10:31:33 <lament> i'll have to learn Japanese eventually, but I'm trying to avoid it cause it seems everybody is doing it :)
10:31:54 <Cale> sampointon: It's fun.
10:32:18 <copumpkin> the language itself is relatively straightforward, it's the writing system that's pretty complicated
10:32:32 <Cale> Well, actually I've been finding kanji really manageable to learn.
10:32:32 <b_jonas> lament: lol
10:32:42 <Cale> It's not really any worse than learning how to spell English words.
10:32:48 <b_jonas> lament: everyday japanese or programming japanese?
10:32:53 <copumpkin> Cale: up to what point?
10:32:56 <wli> Try computer processing of the writing system and HCI issues surrounding input.
10:32:58 <copumpkin> jouyou?
10:32:58 <lament> b_jonas: everyday
10:33:05 <b_jonas> Cale: english spelling sucks
10:33:09 <Cale> copumpkin: I know around 1000 core meanings.
10:33:29 <copumpkin> ah
10:33:49 <Cale> They're all built up from simple components, so they're easier to memorise than one might expect at first.
10:33:55 <copumpkin> yeah, definitely
10:33:58 <QtPlay[HireMe]> What is known about string intropolation in Haskell?  Sticking strings together with (++) seems clubsy.
10:33:59 <lament> japanese is nice because it has a character for go, though
10:34:08 <Cale> QtPlay[HireMe]: I usually use concat with a list.
10:34:10 <bavardage> copumpkin: then use your obsession to work out how to display unicode in gchi :P
10:34:16 <copumpkin> but the japanese mapping from chinese character to sound is a lot more complicated than chinese, for example
10:34:19 <Cale> QtPlay[HireMe]: or unwords
10:34:20 <bavardage> s/gchi/ghci/
10:34:26 <copumpkin> many characters have a bunch of kun readings at least
10:34:33 <copumpkin> and at least one on reading
10:34:41 <Cale> copumpkin: Still, somehow I'm growing a subconscious sense for it
10:34:53 <bavardage> haha putStrLn gives \273 btw
10:34:58 <bavardage> just to make things more awesome
10:34:59 <Cale> I wouldn't sit down and memorise the readings for the kanji though.
10:35:02 <lament> i just remember that 山 is yama and san
10:35:04 <copumpkin> :)
10:35:06 <Cale> That seems like a total waste of time.
10:35:09 <b_jonas> QtPlay: you could use printf
10:35:21 <copumpkin> Cale: doing it in an unstructured way certainly is
10:35:36 <Cale> Just learn words which use the kanji, and you'll pick up the readings.
10:35:37 <QtPlay[HireMe]> b_jonas: Where does that live?
10:35:38 <lament> on the plus side, the chinese readings will help you learn chinese
10:35:41 <bavardage> and giving a lambda to getchar gives \206
10:35:51 <copumpkin> lament: most of them are pretty distorted though :P
10:35:57 <copumpkin> or from archaic chinese pronunciations
10:36:01 <lament> it still helps
10:36:07 <b_jonas> QtPlay: dunno, I never really used it. printf, anyone?
10:36:22 <copumpkin> anyway, bbl :)
10:36:25 <Cale> QtPlay[HireMe]: Text.Printf
10:36:29 <Cale> :t printf
10:36:30 <lambdabot> forall r. (PrintfType r) => String -> r
10:37:03 <QtPlay[HireMe]> Thankyou.
10:37:17 <Cale> > printf "Here, %s, is some interpolation. %i." "QtPlay" 5 :: String
10:37:18 <lambdabot>   "Here, QtPlay, is some interpolation. 5."
10:37:37 <Cale> But I don't really like printf
10:37:47 <QtPlay[HireMe]> Cale why not?
10:37:57 <Cale> It's not very typesafe.
10:38:04 <b_jonas> well, for interpolation, you could define a variant that's just String -> [String] -> String
10:38:07 <b_jonas> and handles only %s
10:38:20 <Cale> It's usually nicer just to use concat.
10:38:40 <QtPlay[HireMe]> How does it get past the type checker?
10:38:58 <Cale> It uses typeclasses to be really-super-polymorphic.
10:39:10 <Cale> But it will cause runtime errors if the types are wrong.
10:39:11 <b_jonas> > {- Cale: like this? -} let { x = show 5; y = show 8; } in concat ["I have ", x, " cats and ", y, "dogs."]
10:39:12 <wli> The arguments passed determine how it parses the format string.
10:39:12 <lambdabot>   "I have 5 cats and 8dogs."
10:39:18 <Cale> b_jonas: yes
10:39:31 <Cale> Or including the 'show' in the list literal
10:39:47 <Cale> > let { x = 5; y = 8; } in concat ["I have ", show x, " cats and ", show y, " dogs."]
10:39:48 <QtPlay[HireMe]> Oh I see.
10:39:49 <lambdabot>   "I have 5 cats and 8 dogs."
10:40:05 <Cale> You can also use unwords, if that suits you better.
10:40:15 <Cale> > let { x = 5; y = 8; } in unwords ["I have", show x, "cats and", show y, "dogs."]
10:40:16 <lambdabot>   "I have 5 cats and 8 dogs."
10:40:24 <Cale> (then you don't need the extra spaces)
10:40:36 <sampointon> Data.List.intercalate too, for things like comma separated lists
10:41:05 <b_jonas> Cale: yeah, I used unlines just to be able to write a constant multi-line message in a program nicer
10:41:13 <Cale> yes, I like that too
10:41:34 <b_jonas> > {- even though I know I can use -} "a\   \b\&c"
10:41:35 <lambdabot>   "abc"
10:41:38 <wli> For the most part I just write it all out as a large series of literal strings and function applications connected via (++)
10:42:57 <Cale> Yeah, there's a certain point at which concat/unwords/unlines starts to be nicer than connecting things up with (++) though
10:43:04 <wli> Format strings suck for efficiency as well as type safety.
10:43:18 <kadaver> copumpkin: but what is the point of having a strict data?
10:43:33 <Cale> One can create a typesafe printf, but it requires the formatting "string" to not just be a string anymore.
10:43:42 <wli> Sure, when the number of things to connect varies etc. Mostly you have to write it all out anyway.
10:43:43 <b_jonas> yeah
10:44:03 <mauke> TH
10:44:21 <b_jonas> it's like combining pattern match combinators instead of writing regexen as strings
10:46:13 <wli> Things get a little odder when you're trying to ensure column alignment etc. in reports/output meant to resemble tables.
10:47:21 <wli> One of the nastier ones is when you need decimal points to line up.
10:51:36 <cadr> Why when I have "($ 1)" does the 1 get bound to the second argument of $?
10:51:58 <c_wraith> cadr: that's what operator section syntax does.
10:52:39 <c_wraith> cadr: It binds the value provided to the side of the binary operator that you put it on.
10:52:40 <kadaver> copumpkin: but what is the point of having a strict data?
10:53:05 <kadaver> data Neuron = Neuron !Input, ok so if I give it a list [1..10] it will evaluate it when created not thn needed ?
10:53:06 <mauke> @hoogle [a] -> [(a, [a])]
10:53:06 <lambdabot> Data.Char readLitChar :: ReadS Char
10:53:06 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
10:53:06 <lambdabot> Prelude reads :: Read a => ReadS a
10:53:43 <cadr> c_wraith: how would I bind it on the other side?
10:53:50 <c_wraith> cadr: (1 $)
10:54:10 <sampointon> cadr: or, if you're feeling prefixy: ($) 1
10:54:15 <c_wraith> cadr: Of course, with $, the first argument needs to be a function, so that's probably a poor example. :)
10:54:46 <cadr> c_wraith: Thanks - that makes a lot more sense now
10:54:53 <mauke> c_wraith: instance (Num a) => Num (e -> a)
10:56:23 <orbitz> mauke: where are my 5 array types?!
10:57:55 <mauke> orbitz: what
10:58:07 <orbitz> wat
10:58:14 <mauke> ʇɐʍ
10:58:21 <ddarius> There are a lot more than five array types.
10:58:21 <orbitz> i don't speak unicdoe!
10:58:48 <mauke> why not?
10:58:55 <edwardk> unicode is like perl, i doubt anyone speaks all of it =)
10:59:18 <ehird> Unicode‽
10:59:24 <mauke> hey, I speak most parts of perl
10:59:25 <edwardk> you just stick to the subset that makes sense to you ;)
10:59:40 <mauke> ehird: ｙｅｓ
10:59:55 <ehird> mauke: I hope you feel kind of bad about that.
11:00:04 * edwardk too. but i know for instance that i deliberately don't know the horrible formatting stuff that they support.
11:00:05 <mauke> no, not really
11:00:43 <mauke> I've used fullwidth text before I'd heard of /prog/
11:01:24 <ehird> fullwidth text is fun and also completely useless.
11:02:07 <edwardk> unless you're in japan and trying to make the font fit with the characters around it
11:02:20 <sebaseba> その通り
11:02:22 <ehird> when in japan, type like the japanese
11:02:24 <mauke> just use halfwidth hiragana
11:02:48 <vixey> why don't you have english letters half the width but the same height
11:03:08 <ehird> becausetherewouldn'tbeanyroomtobreathe
11:03:56 <mauke> b r e a t h i n g   i s   o v e r r a t e d
11:04:11 <dancor> #eecummings
11:04:35 <ehird> dancor: i'm                                      not
11:04:37 <ehird>                sure that's
11:04:39 <ehird> a good idea
11:05:35 <dancor> l o lings
11:06:10 <bavardage> o h  d e a r
11:06:39 <ehird> what                                                      havewe done
11:06:42 <ehird>                    now I
11:06:45 <ehird>                                                                 wonder
11:06:45 <ehird>  ?
11:07:06 <dancor> can't everyone just convert the text to what they want to see locally
11:07:16 <ehird> no                               that is not artisticen
11:07:17 <ehird> ough
11:07:41 <dancor> who was talking about strictly-ast-based code-editing a while back
11:07:47 <ehird> peaker?
11:07:49 <dancor> ya
11:07:56 <ehird> a guess :-)
11:08:04 <ehird> since it's all he talks about :D
11:08:15 <dancor> the one thing that i'm not sure about
11:08:33 <dancor> is that ppl seem to decide when to stop an expression and call it something
11:08:42 <dancor> based on 80cols or something like that
11:08:53 <ddarius> They do?
11:08:58 * ddarius doesn't.
11:08:59 <ehird> only the bad ones :P
11:09:16 <dancor> well idk.  anyway it seems like if you are going to go pure-ast you might start doing seriously long expressions
11:09:27 <ehird> only if you're a bad programmer
11:09:38 <dancor> well, i am
11:09:47 <ehird> fix that ;-)
11:09:51 * dancor not ashamed
11:10:15 <sebaseba> fix (\programmer -> improve programmer)
11:10:29 <dancor> anyway what i'm concerned about is that there is this connection between layout and semantics
11:10:32 <dancor> and it scares me
11:10:43 <b_jonas> I don't stop expressions
11:10:44 <dancor> and i don't know what's going to happen if you try to remove layout
11:11:17 <b_jonas> oh, I don't use haskell layout usually
11:11:21 <b_jonas> only in very few cases
11:11:40 <dancor> everyone has completely different styles i've noticed
11:11:55 <dancor> i'm amazed anyone can work with anyone in the haskell community ever
11:12:17 <dancor> did eecummings collaborate
11:12:27 <b_jonas> work? what?
11:12:41 <dancor> i mean work on projects
11:12:49 <dancor> not like get paid
11:12:54 <ddarius> dancor: You use the coding style set by the project you're working on.
11:12:58 <dancor> we're talking about haskell here ;)
11:13:24 <c_wraith> Eh.  In what used to be a python shop, Haskell's whitespace rules are seen as "a good way to do it"
11:15:04 <Cale> dancor: Completely different?
11:15:24 <Cale> dancor: There's one main style which I think most people use, with a few notable exceptions.
11:15:34 <edwardk> dancor: i've actually done a fair chunk of the pure ast driven editing stuff, but gave up because of the tools i was using at the time
11:15:37 <kadaver> does Haskell ahve asserts?
11:15:46 <lament> dancor: why would you remove layout?
11:15:57 <b_jonas> in one way, python is worse because it doesn't have an alternative to layout, but in another way, python is better becasue it doesn't have the completely ambigous crazy layout rules of haskell
11:16:12 <lament> python is better, because it doesn't have an alternative to layout
11:16:20 <edwardk> b_jonas: haskell's layout rules are actually really simple, they have 4 cases, done.
11:16:22 <b_jonas> kadaver: which kinds of asserts? assert means at least two different things.
11:16:33 <b_jonas> edwardk: simple to state,
11:16:33 <Cale> I think having an alternative to layout is important, especially so for blind users.
11:16:49 <b_jonas> lament: I hate if a language tries to force a style to me
11:16:53 <b_jonas> whether it's syntax or semantics
11:16:58 <edwardk> of, let, do, where
11:17:02 <dancor> lament: well with pure-ast you wouldn't have layout.  so the question is why would you use pure-ast.  and my answer is that it's "closer" to the (semantic) code
11:17:03 <b_jonas> I want to use a style because it's good, not because it's forced on me
11:17:10 <b_jonas> edwardk: yes, that's no problem
11:17:24 <maltem> Isn't the point that Haskell has layout, while Python has indentation?
11:17:25 <edwardk> b_jonas: i use the style because its easier to read than any explicit alternative i've seen
11:17:26 <Cale> I actually wish that the rules surrounding 'if' were a little more strict.
11:17:29 <c_wraith> b_jonas: You must never maintain software written by other people.
11:17:49 <Cale> Also, I wish that tab characters outside of comments were treated as lexical errors.
11:17:52 <lament> oh jesus
11:17:52 <b_jonas> edwardk: the problem is how a layout block ends if it can't be parsed continuing
11:17:55 <c_wraith> b_jonas: The problem with you being able to choose whatever style you like is that the idiots who wrote the code you're trying to fix also chose whatever lack of style they felt like.
11:18:05 <lament> we just got a bug report from a customer
11:18:17 <lament> the bug is that we use the word "hack" in the comments in the source code
11:18:24 <dancor> there are advantages to OTW style and advantages to anarchy
11:18:32 <lament> we have to take "hack" out
11:18:35 <ehird> lament: http://www.jwz.org/doc/censorzilla.html
11:18:40 <edwardk> b_jonas: well, compared to things like automatic semi-colon insertion in javascript, thats even not that bad as lexical warts go ;)
11:18:48 <b_jonas> lament: lol
11:18:49 <Cale> lament: Why would you have to do that? :)
11:19:06 <dancor> lament: i had no idea fixing hacks could be so easy!
11:19:06 <ehird> Cale: HACK IS A CURSE WORD!
11:19:08 <Cale> Why does the customer even care about the comments in the source code?
11:19:08 <b_jonas> edwardk: yeah I know
11:19:09 <lament> ehird: hack is not a swear word.
11:19:14 <ehird> lament: now it is!
11:19:19 <b_jonas> edwardk: it's still much better than the crazy hacks perl and ruby has
11:19:21 <dancor> just strip the comments before delivery
11:19:26 <lament> Cale: because the source code is our product.
11:19:27 <b_jonas> edwardk: ruby's hacks are less visible but are still there
11:19:27 <ehird> b_jonas: please, this is a pg 13 channel
11:19:28 <Cale> dancor: haha, yes :)
11:19:35 <ehird> b_jonas: keep the rude words like "hack" to a minimum
11:19:48 <lament> the reason they want to take it out is not because it's rude
11:19:48 <dancor> it's like well-documented code, but a little more light-weight
11:19:56 <b_jonas> ehird: oh, I thought you meant "perl"
11:20:00 <ehird> :-D
11:20:02 <lament> it's because "hack" can be misinterpreted as a reference to illegal activity
11:20:03 <ehird> b_jonas: #@(*&~
11:20:07 <ehird> lament: wow
11:20:09 <edwardk> lament: lol
11:20:13 <___> lament: that... that's absurd!
11:20:15 <Cale> lament: What programmer would do that?
11:20:20 <lament> for the record the customer is Microsoft :)
11:20:25 <Cale> (would misinterpret it like that)
11:20:30 <b_jonas> lament: that reminds me to the documentation of abort in gnu libc
11:20:31 <ehird> lament: seriously?
11:20:34 <edwardk> replace it with 'kludge' and call it a day ;)
11:20:34 <dancor> programmers would never commit crimes
11:20:39 <ehird> I'd expect even Microsoft to be more competent than that.
11:21:16 <Cale> kadaver: Oh, you asked about whether Haskell has asserts -- what do you mean by that?
11:21:18 <edwardk> it maintains the same derogatory context, but ditches the l33t connotation
11:21:23 <b_jonas> edwardk: but it's not exactly the same. a programmer should be precise in formulating even natural languages
11:21:28 <ehird> Cale: assert :: Bool -> a -> a, i guess.
11:21:34 <Cale> kadaver: You can use 'error'
11:21:42 <ehird> assert c a | c = a | otherwise = error "lol assertion"
11:21:46 <Cale> kadaver: Along with a guard, perhaps?
11:22:00 * ___ cannot even begin to believe that not *one* line of comment in *any* Microsoft product does not contain the word "hack" by a disgruntled dev.
11:22:01 <pierre-> hello
11:22:03 <b_jonas> Cale, ehird: the problem is that there's also another meaning of assert
11:22:06 <adamvo> @hoogle assert
11:22:07 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:22:07 <lambdabot> Test.HUnit.Base assert :: Assertable t => t -> Assertion
11:22:07 <lambdabot> Test.HUnit.Base class Assertable t
11:22:15 <b_jonas> adding definitions dynamically which is what assert does in prolog
11:22:15 <ehird> ___: you seen the leaked windows src? tons of cursing
11:22:20 <lament> ___: it doesn't, because they all got removed as a matter of policy.
11:22:22 <Cale> b_jonas: Yes, I really don't know what he means.
11:22:30 <edwardk> b_jonas: meh, the customer is always right. if he wants me to call bugs 'happy butterflies', then I fix happy butterflies.
11:22:33 <maltem> lament, maybe they're just associating "hack" with free software, and any swear words with Torvalds :)
11:22:33 <b_jonas> Cale: let's wait if he answers. kadaver?
11:22:35 <ehird> ___: however. shit: going to the toilet isn't illegal. hack: hacking is illegal. QED.
11:22:36 <pierre-> my cabal-install hangs while "resolving dependencies", is that a bug?
11:22:42 <lament> MS has a tool called Policheck to check the source code
11:22:49 <___> lament: I... I'm not sure how to respond.
11:23:01 <___> I'm dumbfounded
11:23:09 <b_jonas> edwardk: maybe keep your own copy of source code which is different than the delivered product in small ways
11:23:10 <lament> eh, it's not a big deal
11:23:15 <ehird> policheck. polipolipolicheeeeeeeck
11:23:21 <Cale> I hate this usurpation of the word 'hack'.
11:23:39 <b_jonas> (edwardk: and insert automatic hungarian notation to the delivered one)
11:23:53 <ehird> hungarian notation: the poor man's semantic types!
11:24:16 <edwardk> b_jonas: i'll pass on the hungarian insanity, please ;)
11:24:38 <Cale> lament: haha, you should systematically replace each 'hack' with 'break security' and see if they notice ;)  Of course, the comments would become confusing then :)
11:24:43 * ___ seconds s/hack/kludge/g
11:24:55 <b_jonas> I mean this comment: http://www.gnu.org/software/libc/manual/html_node/Aborting-a-Program.html#index-abort-3142
11:25:01 <b_jonas> that's what hack reminds me to
11:25:13 <Cale> 'of'
11:25:29 <sampointon> what about replacing every occurrence of hack with 'CENSORED'?
11:25:50 <___> ooh!  You should make up some nonce word!
11:25:54 <ehird> instead of abort()ing after fork()ing, why not reparent your child process under another?
11:25:55 <edwardk> When Simonyi shuffles off this mortal coil, the sin he shall have to answer for most is foisting off Hungarian notation on the world.
11:26:04 <tromp> then ppl will write h@ck instead
11:26:18 <___> Flurble.  Hacks are henceforth to be called flurbles.
11:26:32 <ehird> -- terrible flurble
11:26:49 <mstr> do you think they succeed with the "shoot the hungarian notation guy into space, and let him stay there" this time?
11:26:50 <kadaver> init is a bad name for droplast, why not change that? init is a name i often want as avarname
11:26:57 <Cale> I don't understand that comment on the abort function.
11:27:02 <edwardk> the search and replace issues remind me of http://thedailywtf.com/articles/the-apocalypse-must-have-occured!.aspx
11:27:11 <ehird> Cale: Abortion.
11:27:18 <Cale> ehird: Oh, is that it?
11:27:20 <___> kadaver: then use it as one.  You can shadow names or even import Prelude hiding (init)
11:27:30 <ehird> Cale: Yes, thus my bad joke: 19:25 ehird: instead of abort()ing after fork()ing, why not reparent your child process under another?
11:27:36 <Cale> ehird: ah
11:28:00 <edwardk> fork() failed. try spoon()?
11:28:07 <b_jonas> mstr: if they wanted to get rid of him, they'd use a cheaper solution
11:28:12 <ehird> spork()
11:28:19 <ehird> starts a thread and makes a new process
11:28:25 <ehird> and runs the child code in both
11:28:29 <b_jonas> kadaver: you can have it as a variable name, just either not on the top level or hide it from importys
11:28:31 <mstr> b_jonas: they have less style
11:28:49 <b_jonas> edwardk: yeah, there's a pun for that too
11:28:54 <edwardk> spork(float) -- should take the ratio of spoon to fork to allow you to use any intermediate representation.
11:29:01 <b_jonas> edwardk: it uses the fact that spawn sounds like spoon
11:29:02 <Cale> You could also just use something like 'initial' for your variable name.
11:30:05 <edwardk> now, if you pass it a value out of bounds, bad things can happen that fall outside of the purview of the posix semantics of spork: http://xkcd.com/419/
11:30:06 <b_jonas> mstr: also, shooting someone to a space station just to kill him would count copycat now because an Anthony Horowitz book has that plot
11:30:10 <b_jonas> (sorry for the spoiler)
11:30:20 <___> import Prelude hiding (init); import qualified Prelude; droplast = Prelude.init
11:30:29 <b_jonas> kadaver: so which assert?
11:30:52 <b_jonas> ___: yeah, and also hide init from Data.List too if you import it
11:31:05 <b_jonas> (it's a useful module)
11:34:56 <kadaver> i can take random otu of the IO monad right+
11:35:15 <b_jonas> kadaver: yes, it has a built-in random seed in its state
11:35:20 <___> > take 10 $ randoms (mkStdGen 42)
11:35:22 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
11:36:09 <___> random number generation is pure, provided you have a pure source of randomness, in this case a StdGen.
11:36:37 <kadaver> I want to randomize a list of length x with values between -0.5 and 0.5
11:36:42 <___> you can use mkStdGen to get one with a constant seed, always giving the same results, or newStdGen to split off the one embedded in IO.
11:36:47 <___> @ty newStdGen
11:36:49 <lambdabot> IO StdGen
11:37:00 <kadaver> ive done haskell on and off for 6months and randomness i stillc ant do, i always forget how to do it
11:37:09 <___> randomize as in shuffle?
11:37:23 <edwardk> @type getRandomRs
11:37:25 <lambdabot> Not in scope: `getRandomRs'
11:37:37 <kadaver> randWeight ::  IO Double
11:37:37 <kadaver> randWeight = randomRIO ((-0.5) :: Double, 0.5)
11:37:54 <kadaver> but i dotn seem to be able to take x $ repeat randWeight and get that out of IO
11:38:11 <___> @type randomRs (-0.5, 0.5 :: Double)
11:38:13 <lambdabot> forall g. (RandomGen g) => g -> [Double]
11:38:25 <___> @instances RandomGen
11:38:27 <lambdabot> Couldn't find class `RandomGen'. Try @instances-importing
11:38:30 <edwardk> is the MonadRandom stuff bundled somewhere?
11:38:31 <edwardk> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
11:38:45 <sampointon> edwardk: it's on hackage, if that's what you mean
11:38:53 <edwardk> yeah
11:39:16 <b_jonas> kadaver: yeah
11:39:20 <sampointon> I was about to suggest it myself, I'm using RandT in my MUD and it's very handy
11:39:35 <b_jonas> kadaver: but lambdabot doesn't run io actions, so try in a ghci
11:39:42 <EvilRanter> ?type sequence
11:39:43 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:39:44 <b_jonas> ghci> sequence (replicate 10 (randomRIO (-0.5, 0.5 :: Float)))
11:39:48 <b_jonas> [0.13925177,0.16670649,-0.44647858,0.19454055,0.23124297,0.1320403,0.1646755,-0.29269662,0.28601396,7.124654e-2]
11:40:05 <edwardk> > randomRs (-0.5,0.5) (mkStdGen 1)
11:40:07 <lambdabot>   [-0.14074537533818404,-0.16937663340228065,-0.36351475873112554,3.864001483...
11:40:16 <___> randomRs (-0.5,0.5::Double) =<< newStdGen
11:40:16 <b_jonas> edwardk: oh yeah, that too
11:40:30 <b_jonas> which uses split
11:40:37 <___> :: IO [Double]
11:40:48 <EvilRanter> ?type randomRs
11:40:49 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
11:40:52 <kadaver> so basicallyt with moands you culd abstract out the assing around the seed part?
11:41:03 <edwardk> kadaver: thats what MonadRandom does
11:41:04 <sampointon> kadaver: yes, that's the idea behind MonadRandmo
11:41:11 <EvilRanter> ___, I think you mean "randomRs (-0.5,0.5::Double) <$> newStdGen"
11:41:37 <___> ah, indeed I do.
11:42:19 <edwardk> bah. randomRs (-0.5,0.5::Double) `liftM` newStdGen -- you yungins 'n yer fancy applicatives
11:42:40 <___> Applicatives are technically less fancy than Monads.
11:42:44 <b_jonas> edwardk: lol
11:42:54 <___> Functors even more so.
11:42:57 <b_jonas> ___: they are more fancy imo
11:42:57 <edwardk> yes, but more fancy in that you have to import something so your solution requires more typing ;)
11:43:10 <___> b_jonas: not *technically* so.
11:43:22 <EvilRanter> er, you have to import liftM, edwardk
11:43:27 <b_jonas> punctuation like <$> and <*> and stuff is more fancy than just >>= and liftM
11:43:30 <edwardk> hah fair enough
11:43:32 <edwardk> fmap ftw
11:43:32 <___> fmap is in prelude.
11:43:39 <___> s/p/P/
11:43:53 <ddarius> "fmaP is in the prelude." ?
11:44:10 <mauke> EXPERT REGEX USER
11:44:11 <edwardk> <$> always struck me as a bit gratuitious
11:44:16 <___> ddarius: where did the "the " come from?
11:44:49 <sampointon> ___: buggy implementation of sed, there are articles about it
11:44:49 <ddarius> P is a magic character...
11:44:51 * ddarius runs off.
11:45:39 <Apocalisp> Is there any such thing as a coapplicative functor?
11:45:45 <Apocalisp> applicative cofunctor?
11:45:53 <edwardk> Apocalisp: not in Hask
11:46:00 <edwardk> Apocalisp: it would require coexponentials
11:46:23 <edwardk> and there isn't a type in haskell that can be considered a coexponential, since hask isn't a poset.
11:46:54 <edwardk> you'd have coapply :: b -> (b - a) + a
11:47:11 <Apocalisp> edwardk: I see, kind of
11:47:17 <___> Anyway the point was that Applicatives are less fancy than Monads since they don't have join and (>>=).  Indeed, that's the whole point.
11:47:19 <kadaver> http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html looking at that i dont get it
11:47:24 <Apocalisp> I'm thinking of applicative contravariant functor then
11:47:27 <edwardk> and then coapplicatives would allow coapplication
11:47:37 <kadaver> i want: randomList :: [IO Double]
11:47:37 <edwardk> inside of the functor
11:47:59 <Apocalisp> (Functor f) => f (b -> a) -> f a -> f b
11:47:59 <___> @type randomRs (-0.5,0.5::Double) `fmap` newStdGen
11:48:00 <lambdabot> IO [Double]
11:48:18 <___> kadaver: I don't think you want a list of actions, you probably want IO [Double]
11:48:41 <___> IO Doubles are not Doubles.
11:48:43 <edwardk> Apocalisp: that would probably be better viewed as a contra-applicative
11:48:46 * ddarius hates infix fmap/liftM
11:49:08 <ehird> mwa `haha` ha
11:49:14 <b_jonas> oh, you're doing the co- game again?
11:49:16 <___> haha mwa ha?
11:49:16 <b_jonas> can I join?
11:49:25 <dancor> omglol
11:49:26 <___> b_jonas: only if you're monadic.
11:49:28 <Apocalisp> a game of contra
11:49:39 <edwardk> ddarius: i actually rather like infixing random functions
11:49:44 <Apocalisp> "Co et Contra"
11:50:12 <edwardk> > "hello" `const` "world" -- must drive ddarius nuts
11:50:13 <lambdabot>   "hello"
11:50:35 <kadaver> so i will write my own little randomLib i guess and be done with it once and for all
11:50:37 <___> > (+) `id` 2 `id` 3
11:50:39 <lambdabot>   5
11:50:44 <roconnor> > 'a' `const` 'b' `const` 'c'
11:50:45 <edwardk> > (1,2) `listArray` [3,4]
11:50:47 <lambdabot>   'a'
11:50:47 <lambdabot>   array (1,2) [(1,3),(2,4)]
11:51:01 <b_jonas> kadaver: why, what does Random and MonadRandom not do what you want?
11:51:05 <roconnor> const is a nice associative operation
11:51:12 <roconnor> it deserves to be infix
11:51:30 <___> kadaver: doesn't the the randomRs I gave you do what you want?
11:52:18 <orbitz> and why do you think writing your own lib will solve the issue?
11:52:19 <b_jonas> edwardk: just make sure you define random infix precedences for all `foo` in an aux module you import with a non-conspicious name, and use multiple `foo` in one expression
11:52:25 <kadaver> but i cant take 5 IO [Double]...sigh
11:52:30 <b_jonas> mixed with punctuation infixes
11:52:39 <b_jonas> kadaver: why coulnd't you?
11:52:52 <edwardk> b_jonas: i actually do assign infix precedences for `plus` `minus` `times`, etc. in the monoid lib ;)
11:52:54 <sampointon> kadaver: sequence $ replicate getRandom 5
11:52:55 <kadaver> Couldn't match expected type `[a]'
11:52:55 <kadaver>            against inferred type `IO [Double]'
11:52:57 <___> @type take 5 <$> (undefined :: IO [Double])
11:52:58 <b_jonas> kadaver: if you can't take it, how would you manipulate the lists anyway
11:52:59 <lambdabot> IO [Double]
11:53:31 <b_jonas> sampointon: I actually wrote something like that above but with the right order of arguments for replicate
11:53:33 <orbitz> kadaver: foo <- whatever_that_gives_IO_[Double], take 5 foo
11:53:45 <edwardk> kadaver: take the list of IO actions, and sequence them
11:53:46 <b_jonas> orbitz: with a semicolon instead of comma?
11:53:46 <sampointon> b_jonas: :( I can never remember which way round it is
11:54:00 <orbitz> b_jonas: and valid sytnax other places as well!
11:54:09 <b_jonas> sampointon: you needn't, the compiler will warn you anyway if you mix it
11:54:15 <b_jonas> orbitz: yup
11:54:18 <orbitz> > getRandromR (1, 10)
11:54:19 <lambdabot>   Not in scope: `getRandromR'
11:54:25 <orbitz> > getRandomR (1, 10)
11:54:27 <lambdabot>   Not in scope: `getRandomR'
11:54:32 <kadaver> got it
11:54:37 <b_jonas> sampointon: I can't remember how all the Data.List functions work either
11:55:08 <orbitz> @hoogle getRandomR
11:55:09 <lambdabot> No results found
11:55:24 <sampointon> 5 `replicate` getRandom?
11:55:41 <roconnor> sampointon: heh, that's going too far :P
11:55:43 <b_jonas> sampointon: sequence (replicate 10 (randomRIO (-0.5, 0.5 :: Float)))
11:56:35 <edwardk> sequence $ 10 `replicate` randomRIO (-0.5,0.5) -- get it right ;)
11:56:42 <edwardk> parentheses are evil ;)
11:57:00 <vixey> can you not infix sequence somehow
11:57:01 <kadaver> newtype Inputs = [Double] not allowd?
11:57:10 <edwardk> vixey: its unary
11:57:19 <kadaver> would be nice tio have typesynonyms with newtype quality
11:57:20 <___> kadaver: newtypes need constructors
11:57:43 <___> sequence $ 10 `replicate` randomRIO $ (,) (-0.5) 0.5 -- heh
11:57:45 <vixey> :t \x -> [sequence]`sequence`x
11:57:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> [m [a]]
11:58:01 <orbitz> kadaver: newtype Inputs = Inputs [Double]
11:58:18 <orbitz> could do
11:58:23 <orbitz> type Inputs = [Double] right?
11:58:48 <edwardk> @type \a b -> a `sequence` b
11:58:50 <lambdabot> forall t a. (Monad ((->) t)) => [t -> a] -> t -> [a]
11:59:01 <mauke> sort of unrelated: http://www.youtube.com/watch?v=drE5cHe6c3s&feature=PlayList&p=D53C52973A681677&index=0&playnext=1
11:59:40 <___> Hah, seen that vid before.  Love the campyness.
11:59:50 * b_jonas goes to read SIGBOVIK 2009 proceedings now
11:59:59 <b_jonas> matches my tired state
12:00:00 <edwardk> i'm totally using an infix `sequence` next time i want to map ($c)
12:00:03 <kadaver> ___: yeah but thats what i am saying, would be nice if normal typesynonyms had the quality of not being interchangeable
12:00:37 <___> wouldn't really be synonyms then, would they?
12:00:39 <edwardk> in fact i have code i'm writing right now i can abuse that in
12:00:40 <orbitz> then they wouldn't be synonyms
12:00:45 <orbitz> ___: dam you!
12:01:06 <b_jonas> someone recommended defining two operators to fake `( expression )` which isn't allowed in haskell
12:01:13 <___> orbitz: build a construction that holds back my considerable water pressure?
12:01:19 <b_jonas> it's actually doable
12:01:30 <orbitz> ___: only if i can hold you together with my finger
12:01:36 <orbitz> ___: did i just make a sexual reference? i can't tell
12:01:49 <___> *shrug*
12:02:49 * vixey lol at cDonalds Theorem
12:03:56 <therp> I apologize for this ugly question but is there a Prelude function that replaces the nth element of list (returning a new copy of the list of course)?
12:04:05 <vixey> no
12:04:05 <therp> s/Prelude/Data.*/
12:04:20 <b_jonas> therp: you can build it from splitAt
12:04:36 <b_jonas> therp: or you can use a Data.Sequence.Seq
12:04:37 <therp> b_jonas: yes, quite easily.
12:04:51 <b_jonas> therp: or you can use a mutable array if that suits what you're doing
12:05:25 <therp> b_jonas: no, not that complicated. I'm using some "untyped" (that is not properly converted to records) CSV data
12:06:04 <___> onElt i xs f = before ++ [f x] ++ after where (before, (x : after)) = splitAt i xs
12:06:15 <___> I've used something like that at least once before.
12:06:29 <vixey> wha for??
12:07:04 <___> convenience in creating a test value for checking a function.
12:07:05 <therp> [f x]?
12:07:18 <Cale> before ++ f x : after -- would be a bit faster generally
12:07:43 <vixey> @src ++
12:07:43 <lambdabot> []     ++ ys = ys
12:07:43 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:07:43 <lambdabot> -- OR
12:07:43 <lambdabot> xs ++ ys = foldr (:) ys xs
12:07:53 <vixey> is before ++ [f x] ++ after
12:07:57 <vixey> (before ++ [f x]) ++ after ?
12:08:05 <vixey> @info ++
12:08:05 <lambdabot> (++)
12:08:25 <tromp> (++) = flip $ foldr (:)
12:08:31 <Cale> Oh right, it's infixr anyway
12:08:51 <Cale> So it's not going to be seriously bad.
12:09:37 <___> it's still O(n).  You'd be better off with an array or something if it were important in your algorithm.
12:09:44 <mauke> if (++) is inlined, it's the same
12:09:50 <vixey> I don't like onElt
12:09:52 <vixey> it seems wrong
12:09:57 <___> how so?
12:10:08 <Cale> Well, yes, the whole idea of updating or accessing just the nth element of a list is a bit ill-conceived.
12:10:10 <vixey> it's just mean like cutting a worm in two
12:10:26 <Cale> Lists should be processed uniformly :)
12:10:49 <___> Needs a [] case, but it should work fine.
12:11:56 <b_jonas> Cale: it depends
12:12:25 <b_jonas> Cale: if you have to do such long things after each update that it dwarves the time of the update then it's not wrong
12:12:40 <Cale> If you're constructing a list by repeatedly updating random elements like that, then you probably should not be using a list at all.
12:12:40 <b_jonas> that's why I'm using a list to store the lines of this top-level ghci declarations extension
12:12:56 <___> I just used it for convenience.  I had a big list generated by words on a String, but one of the elements needed an embedded ' ' itself.
12:12:56 <b_jonas> because it will have to be haskell compiled after every insert
12:13:06 <b_jonas> so the update time doesn't matter
12:13:24 <Cale> Well, sure.
12:13:34 <Cale> If you don't care about performance, then that's fine :)
12:13:44 <b_jonas> yeah
12:14:26 <b_jonas> I have a mixed and sort of whimmy attitude about when I care for performance and when I don't
12:15:27 <___> generally you should only care about the innermost loops.  This goes for any language.
12:15:36 <kadaver> could one make neurla network combinators lib perhaps? :P
12:15:41 <mauke> good thing haskell doesn't have loops
12:15:42 <kadaver> combine layers and so no
12:15:51 <Cale> kadaver: yes.
12:15:58 <___> loop = 1 : loop -- nonsense :)
12:16:04 <b_jonas> here is the current state of that extension in case anyone wants to try it: http://erxz.com/pb/17084
12:23:04 <___> @yow!
12:23:05 <lambdabot> I'm having a tax-deductible experience!  I need an energy crunch!!
12:23:57 <dancor> what's the best way to allow prefix/postfix operators to be applied more than once in buildExpressionParser
12:23:57 <b_jonas> > 2**2**2**2**0
12:23:58 <lambdabot>   16.0
12:24:25 <dancor> i guess it's easy if you just have one and i can just <|> them maybe
12:24:38 <dancor> (i have two)
12:24:59 <b_jonas> (<|>) is the same as mplus, isn't it?
12:25:05 <b_jonas> @src (<|>)
12:25:05 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:25:10 <b_jonas> @src (<|>) []
12:25:11 <lambdabot> Source not found. You untyped fool!
12:25:13 <edwardk> b_jonas: yes
12:25:20 <maltem> @src <|>
12:25:21 <lambdabot> Source not found. Take a stress pill and think things over.
12:25:23 <b_jonas> but more general or something
12:25:27 <b_jonas> @type (<|>)
12:25:28 <___> @src [] (<|>)
12:25:28 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
12:25:29 <lambdabot> (<|>) = (++)
12:25:31 <b_jonas> @type mplus
12:25:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
12:25:36 <b_jonas> yeah
12:25:42 <b_jonas> thanks
12:25:55 <b_jonas> so that's how it comes up in parsers as alternative
12:26:15 <edwardk> b_jonas: the parser notation came first, chicken and the egg and all that
12:26:19 <dancor> ok that did work
12:26:30 <dancor> why do i only think of the answer after asking publically
12:26:44 <dancor> didn't work that time
12:26:45 <b_jonas> edwardk: I see
12:27:19 <sheyll> I have a type check question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3877#a3877
12:27:33 <b_jonas> edwardk: but [] and Maybe used for nondeterminism are the best exampels for MonadPlus anyway so the <|> name is natural anyway
12:27:34 <edwardk> now we just need FunctorPlus
12:27:40 <edwardk> oh wait, i wrote that once
12:27:50 <sheyll> I really do not understandt the compiler error message, I use ghc 6.8.2
12:28:00 <___> sheyll: where does b come from?
12:28:30 <sheyll> well it is supposed to be some typevar to be bound later
12:28:32 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Functor-Extras.html has it
12:28:49 <___> you don't have any useful information about b.  It can't have any useful value but _|_.
12:29:11 <___> do you mean op to have type a -> a -> a?
12:29:21 <sheyll> no
12:29:25 <sheyll> just b
12:29:47 <sheyll> a variable that can be bound to what I need as determined be the instance
12:29:55 <mauke> it's bound by the caller
12:30:04 <vixey> @quote
12:30:05 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
12:30:05 <mauke> the instance has to work with any crazy b the caller chooses
12:30:11 <___> op doesn't have any type information about i.  You can't (:) it onto a [Int].
12:30:12 <vixey> @quote
12:30:12 <lambdabot> gaal says: (ghc predicted a cpu death on my computer once.)
12:30:13 <dmwit> ?quote
12:30:13 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
12:30:16 <mauke> yours clearly doesn't as it requires b = Int
12:31:37 <sheyll> so how would I correct the example?
12:31:54 <___> you might want class TestClass a b | a -> b and instance TestClass D Int.
12:32:00 <sheyll> would I need to add a typevariable to the class defintion?
12:33:50 <___> also, {-# LANGUAGE FunctionalDependencies #-}
12:33:51 <dmwit> sheyll: Yes, how about class TestClass a b where ...?
12:34:01 <sheyll> now it complains about Too many parameters for class `TestClass'
12:34:12 <edwardk> sheyll: MultiParamTypeClasses
12:34:21 <___> that too of course
12:34:41 <sheyll> Am I thinking in a wrong way? It cant be that there is no haskell98 way of doing things...
12:35:06 <___> you could type op as a -> Int -> a.
12:35:13 <edwardk> sheyll: i tend to pretend that Haskell 98 doesn't exist ;)
12:35:15 <vixey> it can be
12:37:08 <b_jonas> anyway, I have questions about this data types a la carte thing. if you use this to build a really big type with lots of branches (for a syntax tree of an interpreter or the like), woulnd't it become slow becasue of the lots of extra constructors you have to unpack each time? (though I guess you could make it so only logarithmic number of data constructors are stacked.)
12:37:09 <kadaver> http://takinginitiative.wordpress.com/2008/04/03/basic-neural-network-tutorial-theory/ <- some math behind neural nets, i ont now all amth notation but does yk(1-yk)(dk-yk) mean yk*(1-yk)*(dk-yk)?
12:37:24 <b_jonas> also, is it better than using existential types?
12:37:51 <sheyll> I actually need to implement the monad interface
12:38:36 <orbitz> kadaver: juxtaposition is usually mutiplicatino yes
12:39:50 <edwardk> b_jonas: yes
12:40:02 <edwardk> b_jonas: er yes to the first one =)
12:40:58 <edwardk> b_jonas: the latter is awkward, because the existentials are more limited in some ways, if you know a priori all of the things you might want to do with the coproduct you can just use an existential packed up with the dictionary of what you want to do
12:41:46 <edwardk> b_jonas: but the ala carte solution lets you write more dictionaries as you see fit, which is how it addresses the expression problem in a way that an existential can't
12:42:02 <sheyll> Well guys thanks for the help, but I have found a diffrent more elegant solution, that doesnt require non haskell98 extension: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3878#a3878, what do you think?
12:43:00 <b_jonas> edwardk: I see
12:43:12 <b_jonas> thanks
12:43:23 <edwardk> b_jonas: i usually just pay the logarithmic cost and go from there ;)
12:43:33 <vixey> sheyll what is this
12:43:56 <b_jonas> but if I use a data with the existential inside, then I don't actually ahve to mention all the classes later, do I?
12:44:01 <sheyll> it is the fixed version of this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3877#a3877
12:44:05 <b_jonas> I just have to change the program at one place
12:44:18 <b_jonas> thouhg of course that's true if I just make a giant data type with lots of brances as well
12:44:25 <b_jonas> the point is not how much I have to change
12:44:29 <edwardk> b_jonas: here lies the crux of the expression problem. you'd always have to extend the existential
12:44:43 <sheyll> vixey: I a an absolute n00b when it comes to the typesystem
12:44:44 <b_jonas> yeah
12:44:56 <edwardk> and if you wanted a slightly larger type that had fewer of those, you'd be using a new existential ,etc.
12:44:57 <b_jonas> I'll think of this
12:45:11 <b_jonas> so logarithmic instead of a list
12:45:35 <b_jonas> I found it strange how that article handled the end of the type sum list btw
12:45:58 <edwardk> using Foo :*: Bar rathre than Foo :*: Bar :*: HNil ?
12:46:04 <b_jonas> shouldn't it have used a closing type at the end so that there's only two instance instead of three
12:46:07 <b_jonas> edwardk: yup
12:46:23 <b_jonas> it's not just for having only two instances
12:46:25 <edwardk> well, the idea there is it makes the type prettier and puts the burden on the library rather than the user
12:46:43 <kadaver> is there some way of declaring a type to be exactly a 3-tuple or 3-elem list? or I can only restrict to type?
12:46:45 <b_jonas> but also better instances
12:46:48 <b_jonas> edwardk: yeah, sure
12:46:52 <b_jonas> it's a great idea
12:47:05 <kadaver> wat ofc ther eis
12:47:07 <b_jonas> it's nice to know that the type system can do this even if I don't end up using it
12:47:15 <skorpan> kadaver: a 3-tuple is a different type than a 2-tuple.  you can't say 3-elem list though, as that is kind of dependent types
12:47:47 <skorpan> :t (5, 3)
12:47:49 <lambdabot> forall t t1. (Num t1, Num t) => (t, t1)
12:47:50 <___> I'm sure Oleg has already done it.
12:47:54 <skorpan> :t (5, 3, 2)
12:47:55 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => (t, t1, t2)
12:47:55 <edwardk> b_jonas: i use this encoding a lot for syntax or intermediate rep ADTs because i can define successive intermediate languages just by adding or removing some constructors 'ala carte'
12:48:16 <b_jonas> you can use a 3-tuple and a function that views it as a 3-list, you only have to check the 3ness when you create it
12:48:24 <edwardk> b_jonas: and i can encode selectors using duality
12:48:31 <skorpan> b_jonas: how so?
12:48:39 <Berengal> Just the other day I wondered what the best way to convert a a list of two-element lists into tuples...
12:48:44 <skorpan> oh, "that views it as", okay
12:48:58 <___> map (\[x, y] -> (x, y))
12:49:04 <___> seems good enough.
12:49:26 <edwardk> b_jonas: have you seen http://comonad.com/reader/2008/the-cofree-comonad-and-the-expression-problem/  ?
12:49:28 <Berengal> ___: Oh, and the inner lists were lists of monoids, and the last one could be of length one...
12:49:37 <b_jonas> edwardk: wow, another co-thingy
12:49:53 <edwardk> b_jonas: its not very scary
12:50:31 <b_jonas> edwardk: so you actually used that name Comonad.Reader ?
12:50:41 <edwardk> yeah
12:50:44 <b_jonas> I thought that waas just a joke
12:50:51 <___> Berengal: not sure how being monoids changes anything, but what do you do if there's a stragler?  Drop it?
12:51:06 <b_jonas> maybe #haskell-blah should be renamed #cohaskell
12:51:12 <edwardk> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Comonad-Reader.html =)
12:51:52 <Berengal> ___: Use mempty
12:52:02 <edwardk> b_jonas: only because i'm here and fail to stay hidden in the nice -in-depth box ;)
12:52:16 <edwardk> oh -blah
12:52:58 <hydo> heh... you can tell the people in the Hac5 pictures are writing Haskell code... almost as many of them are deep in thought as are actually typing. :)
12:53:24 <b_jonas> there are so many different conventions for off-topic channels, there's -cafe and ##not-math and stuff
12:53:28 <ray> half typing, half leaning back and lighting cigarettes
12:53:35 <ray> or they would be, if it were the 1930s
12:53:44 <b_jonas> and then there's the convention when the main channel is mostly off-topic discussion
12:53:51 <kadaver> god I hate math-notation, its worse than perl. why not just make proper names for things?
12:54:13 <b_jonas> kadaver: can you give an example for what you hate?
12:54:19 <orbitz> they are proper names
12:54:28 <edwardk> kadaver: What's wrong with haskell' ? =)
12:55:35 <kadaver> http://en.wikiversity.org/wiki/Learning_and_Neural_Networks
12:55:40 <Gabbie> hydo, where are the pics?
12:55:41 <edwardk> and that caret that Russell and Whitehead decided to stick over variables, that has made a nice notation ever since it started wandering around the page and became a lambda.
12:56:08 <hydo> Gabbie: http://martijn.van.steenbergen.nl/journal/2009/04/17/hac5-pt-1/
12:56:15 <Gabbie> Cheers!
12:57:08 <Berengal> They've got crates of beer...
12:57:57 <edwardk> 2ŵ+1 =>  ŵ. 2w + 1 => ^w. 2w + 1 => λw. 2w + 1 => \w -> 2 * w + 1 -- yay for ever drifting notation.
12:58:09 <kadaver> b_jonas ^^
12:58:16 <kadaver> and people also use the same symbols for dofferent stuff
12:58:32 <orbitz> peopel do that in any situation
12:58:36 <Cale> kadaver: In mathematics, it's fine, because you have lots of surrounding text to disambiguate.
12:58:47 <Cale> and it doesn't need to be machine readable
12:58:59 <edwardk> kadaver: shortage of symbols, bad namespacing scheme, surplus of analogies. lots of context to disambiguate.
12:59:07 <Cale> So you can choose a notation which is convenient for you.
12:59:28 <Cale> rather than something verbose enough to satisfy a machine
12:59:33 <b_jonas> edwardk: I don't usually like section signs, but the green _rotated_ section signs on your blog look good as a separator
12:59:43 <Berengal> Perhaps mathematicians should start using coloured pens to increase their symbol space...
12:59:56 <edwardk> thanks =)
13:00:11 <bavardage> edwardk: blame typesetters
13:00:41 <edwardk> bavardage: meh, it yielded a more consistent binder syntax than the mathematician would have on his own!
13:00:47 <___> why -> instead of . for the lambda body introduction anyway?  I guess it'd need a preceding space to disambiguate from Module.name.
13:00:54 <b_jonas> I seriously had a problem of running out of good single letter variable names when I wrote my msc thesis
13:00:58 <bavardage> edwardk: and lambdas look peerty
13:01:01 <b_jonas> I had to actually cascadingly rename stuff
13:01:02 <Cale> Personally, I like  w |--> 2w + 1
13:01:17 <Cale> (well, that's an ascii art representation of what I mean ;)
13:01:20 <orbitz> Cale: how come?
13:01:20 <b_jonas> doing find and replace but having to check at each place to rename only one use of a variable but not the other
13:01:26 <b_jonas> it was like hell
13:01:46 <Cale> orbitz: It goes nice with using --> at the level of sets.
13:02:11 <maltem> Borrowing |--> from maths looks quite appealing, and you save a symbol to mentally parse
13:02:14 <edwardk> ___: actually it predated the qualified module stuff iirc. but . wasn't originally used by the grammar directly i think until explicit foralls were added post 98.
13:02:32 <Cale> Well, I was talking about mathematics, myself :)
13:02:40 <edwardk> |--> looks particularly bad in many fonts though
13:02:52 <Cale> ↦
13:03:05 <___> edwardk: ah, so they didn't want to risk strealing . from user names?
13:03:09 <maltem> Cale, oh heh
13:03:10 <edwardk> c#'s => is passable aside from requiring unbounded lookahead
13:03:36 <orbitz> Scala uses => too
13:03:46 <kadaver> where is e
13:03:48 <kadaver> ?
13:03:53 <___> e?
13:03:55 <edwardk> ___: in kata i use the \ x . convention. it requires me to mentally stop and throw a switch every time i come back =-)
13:04:00 <Berengal> kadaver: Left of r?
13:04:01 <orbitz> e is a mathematical constant
13:04:06 <kadaver> 2.71
13:04:10 <Berengal> Oh, that one
13:04:16 <ddarius> > exp 1
13:04:16 <___> exp 1 :)
13:04:17 <edwardk> it also means i have like 4 different uses of . in the language. =/
13:04:17 <lambdabot>   2.718281828459045
13:04:30 <ddarius> edwardk: Humans are good with ambiguity.
13:04:49 <Cale> ↦
13:04:53 <Cale> oops
13:05:11 <b_jonas> edwardk: just four? some languages are much worse than that with some symbols. parnethesis, brackets, braces, and colons are the most common offendes.
13:05:26 <Cale> The ↦ character is too narrow and small in most fonts. The arrow should be at least twice as long.
13:05:31 <b_jonas> colons are becuase they're usually free at first and then they get used for ten different small things in extensions
13:05:45 <b_jonas> and suddenly all you see is colons everywhere
13:05:51 <edwardk> \x. foo, forall x. foo . bar = id, foo.bar, and foo .bar
13:06:09 <Cale> ⟼
13:06:19 <___> :: reserved for types and : as constructor operator is very nice =)
13:06:22 <Cale> That character is supposed to be longer
13:06:22 <edwardk> oh and case foo of x. whatever; y. whatever
13:06:22 <b_jonas> edwardk: don't you have 3.5 too?
13:06:35 <edwardk> b_jonas: actually currently, i don't ;)
13:06:36 <Cale> but it's not in this monospace font I'm using :P
13:06:53 <edwardk> b_jonas, but that'll add a 5th or 6th case eventually
13:07:18 <b_jonas> well, I did say if these non-ascii programming characters get used on this channel more commonly, I'll add them to my font
13:07:27 <b_jonas> I still won't use them but keep typing ascii
13:07:32 <edwardk> in a cleaner earlier grammar for the language i used to use , for the delimiter between the variables of a lambda and the body but that weirded people out.
13:07:53 <b_jonas> but when these chars are pulled in from non-matching substitution fonts isn't really nice
13:08:06 <edwardk> had nice symmetries for case though
13:08:21 <edwardk> foo = case x of y, y; z,z; ...
13:08:28 <b_jonas> edwardk: use =
13:08:35 <kadaver> sigmoid x = 1 / (1 + ((exp 1) ** (-x))) ; whats the derivate of that?
13:08:38 <b_jonas> edwardk: that will wierd everyone out more
13:08:39 <kadaver> :P
13:08:46 <edwardk> i don't like to use = except when you really mean = though
13:08:53 <edwardk> and for cases that becomes really muddled
13:09:04 <b_jonas> edwardk: don't care about weirding people out, care about the syntax being good in itself, not when compared to conventions
13:09:35 <maltem> as in, f x | x == y = g x
13:09:50 <edwardk> b_jonas: well = in the syntax in question for case doesnt really apply the same semantics as definitional equality
13:09:52 <b_jonas> edwardk: trying to use conventional meanings of characters like eg. / for division (which is actually not such a common operation compared to some others which have long alphabetic names) is what makes many programming syntax bad
13:10:04 <b_jonas> at least that's why I like apl syntax
13:10:12 <b_jonas> it doesn't try to stick to conventions
13:10:24 <b_jonas> edwardk: yeah, I know
13:12:09 * edwardk is sad. My monoidal regex engine is sloow.
13:12:33 <edwardk> Its great until you actually want some kind of output from it
13:14:17 <b_jonas> edwardk: make it compile those parts of the regex that it can to usual regex syntax and call an ad-hoc optimized regex library with no theory behind it for those parts?
13:14:35 <b_jonas> or get a faster machine
13:14:39 <b_jonas> or is it _that_ slow?
13:15:41 <snoobino> let strange = guard True >> (lift $ tell "a")
13:15:47 <snoobino> > let strange = guard True >> (lift $ tell "a")
13:15:48 <lambdabot>   <no location info>: parse error on input `;'
13:15:57 <snoobino> wtf ?
13:16:05 <___> @type guard True >> (lift $ tell "a")
13:16:06 <lambdabot> forall (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadWriter [Char] m, MonadTrans t, MonadPlus (t m)) => t m ()
13:16:29 <snoobino> why can't I define it ?
13:16:36 <edwardk> b_jonas: well, the conventional regex stuff would kind of defeat the purpose
13:16:47 <___>  > doesn't define things, it evaluates them.
13:16:57 <Cale> I wonder what the most complicated single unicode glyph is. 𒀱 must be up there :)
13:17:18 <edwardk> b_jonas: well, what i do right now is take an arbitrary dfa with edges decorated with values in some monoid
13:17:23 <___> Cale: sadly the glyph only shows the code point.
13:17:28 <snoobino> how can I define things ?
13:17:36 <___> in my font.
13:17:45 <adamvo> @let x = 5
13:17:46 <Cale> ___: It's this insane cuneiform thing.
13:17:47 <lambdabot>  Defined.
13:17:50 <adamvo> > x
13:17:50 <snoobino> thx
13:17:52 <lambdabot>       Ambiguous occurrence `x'
13:17:52 <lambdabot>      It could refer to either `L.x', defined a...
13:18:06 <adamvo> heh
13:18:15 <snoobino> @let strange = guard True >> (lift $ tell "a")
13:18:16 <lambdabot>  Defined.
13:18:19 <edwardk> and i map each character to an array of all of the transitions and monoidal values it would imply on the dfa.
13:18:26 <sampointon> Cale: is there an image of it anywhere?
13:18:49 <snoobino> > runWriter $ runStateT strange ()
13:18:50 <lambdabot>       No instance for (MonadPlus (Writer [Char]))
13:18:50 <lambdabot>        arising from a use o...
13:18:52 <___> http://www.fileformat.info/info/unicode/char/search.htm doesn't show anything useful for it.
13:19:15 <snoobino> I'm dazed
13:19:25 <___> @src guard
13:19:26 <lambdabot> guard True  =  return ()
13:19:26 <lambdabot> guard False =  mzero
13:19:35 <edwardk> so given a 50 node dfa, a character 'a' would map to an array of 50 integers (and potential monoidal reductions) representing the new states, which i then look up in a state tree trie to get  a canonical representation
13:19:49 <___> return () >> x is x, no?
13:19:59 <vixey> ___: yes
13:20:05 <vixey> return () is side effect free
13:20:10 <skorpan> @l \x y -> x >>= y
13:20:10 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . ? @ pl v
13:20:11 <skorpan> @pl \x y -> x >>= y
13:20:12 <lambdabot> (>>=)
13:20:16 <skorpan> @pl \x y -> x >> y
13:20:16 <lambdabot> (>>)
13:20:22 <skorpan> @pl \x y -> y >> x >>= y
13:20:22 <lambdabot> join . ((>>=) .) . flip (>>)
13:20:28 <Cale> http://www.unicode.org/charts/PDF/U12000.pdf  U+12031 CUNEIFORM SIGN AN PLUS NAGA SQUARED
13:20:30 <skorpan> damn you lambdabot for being so clever!
13:20:59 <edwardk> so basically a becomes a trie, which then gives back an integer, when you go to use b, i do the same thing and if b generates the same array as a they collapse to the same integer rep, then i mappend those integers, looking them up in a memo-table that contains
13:21:02 <Cale> You'll have to zoom in to see it properly unless you have a very high resolution display :)
13:21:11 <snoobino> @let strange = lift (guard True) >> (lift $ tell "a")
13:21:11 <lambdabot>  <local>:13:0:
13:21:12 <lambdabot>      Multiple declarations of `L.strange'
13:21:12 <lambdabot>      Declared at: <l...
13:21:30 <edwardk> int pairs, so as long as the monoid doesn't do anything its fast. you only explore the cases that come up in the source tree and life is good
13:21:42 <snoobino> @let verystrange = lift (guard True) >> (lift $ tell "a")
13:21:43 <lambdabot>  Defined.
13:21:51 <___> @type verystrange
13:21:53 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *). (MonadPlus m, MonadTrans t, MonadWriter [Char] m, Monad (t m)) => t m ()
13:22:15 <___> the lift wasn't on the (guard True) before.
13:22:35 <edwardk> when the monoid is very active, then you wind up not getting much use out of canonicalization, because the trie has to store (int,monoid) pairs for each step and if the monoid is a list of chars seen so far you get basically no sharing
13:22:37 <b_jonas> edwardk: I see
13:22:41 <___> in any case, guard True is defined as return (), so you might as well simplify.
13:23:11 <snoobino> ___, I see
13:23:38 <snoobino> ___, my problem is the error
13:23:48 <___> looks like all it does is tell "a" to the inner Writer.
13:24:23 <snoobino> ___, I want the "a" to be written only when the guard instruction evaluates to True
13:24:45 <snoobino> but I didn't have any problem with the condition so I put something silly instead
13:24:47 <___> when (...) (lift (tell "a"))
13:24:57 <Berengal> @type when
13:24:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:24:59 <___> @src when
13:25:00 <lambdabot> when p s = if p then s else return ()
13:25:00 <snoobino> ___, thx
13:25:04 <edwardk> b_jonas: so basically i have a map from 'chars' to representation #s, representation #s to an array of next-states, a trie of the array of next-state to representation #, and a memo map of the result of appending two representation #s to get a representation #
13:25:06 <ddarius> Cale: See 1231F
13:25:13 <snoobino> what's guard for then ?
13:25:34 <___> @src guard
13:25:34 <lambdabot> guard True  =  return ()
13:25:34 <lambdabot> guard False =  mzero
13:25:46 <___> mzeroing out the computation on False.
13:25:56 <snoobino> thx
13:26:12 <b_jonas> edwardk: and if you do the dfa like that, are you careful enough that even with unusual regexen the compilation to the automaton can't blow up exponentially?
13:26:26 <b_jonas> nor the executoin
13:26:35 <Cale> ddarius: Yeah, that one's pretty complicated too :)
13:27:00 <orbitz> :t mzero
13:27:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
13:27:28 <edwardk> b_jonas: without the monoid involved there is at most an exponential number of distinct compositions but capped by the length of the string you're matching against and small in practice. with the monoid you tend towards that latter upper bound
13:27:34 <orbitz> > mzero :: Maybe Int
13:27:36 <lambdabot>   Nothing
13:27:47 <orbitz> > mzero :: [Int]
13:27:48 <lambdabot>   []
13:28:18 <___> when p s = if p then s else return ();   guard p = if p then return () else mzero
13:28:50 <edwardk> b_jonas: the caches mostly just avoid making the majority of the costs proportional to the # of states and bring them down quite a bit in practice
13:29:01 <b_jonas> edwardk: I see
13:29:21 <Cale> Heh, 1235C 𒍜
13:29:43 <edwardk> b_jonas: i may have to make it so that i don't log an arbitrary monoid from the dfa, but instead allow certain edges to bookmark, and then reassemble the desired result from the bookmarks
13:30:03 <Cale> and 12356
13:30:15 <edwardk> that would cut me down to memoizing distinct sets of bookmarks which should increase sharing to the point where the system becomes usable
13:31:37 <edwardk> what i had been gunning for was to have, say the regex engine generate token streams by saying on the tail end of the keyword class on the space it emits a 'class' token into token Reducer/monoid
13:31:39 <b_jonas> edwardk: are you sure that's what makes it unusable
13:31:40 <b_jonas> ?
13:32:12 <edwardk> and if you need to match an identifier it'd accumulate characters until it saw the edge of the identifier and emit the accumulated identifier token
13:32:43 <edwardk> the tricky part is the whole recognizer is monoidal, so i have to deal with all n possible input states for each symbol
13:33:06 <b_jonas> and do you want to support just pure regexen or some extensions too?
13:33:14 <b_jonas> like depending on the value of the monoid or something
13:33:32 <edwardk> my first goal is to do basic regex stuff, enough that i can bootstrap a minimalist lexer over it
13:33:50 <edwardk> beyond that it'll be a function of how fast everything can be
13:34:17 <___> http://www.inference.phy.cam.ac.uk/cjb/codepoints.html
13:34:33 <b_jonas> great
13:34:38 <___> my favorite is probably THAI CHARACTER KHOMUT.
13:34:46 <kadaver> is: f $ a - b the same as f (a-b) ?
13:34:52 <kadaver> always
13:34:59 <edwardk> what i don't like is how ad hoc some of my strategies have had to become
13:35:03 <b_jonas> kadaver: how much always?
13:35:16 <b_jonas> if you redefine $ then it's not
13:35:23 <___> f Prelude.$ a - b = f (a - b), at least :)
13:35:37 <b_jonas> if it's not a whole subexpression but a non-subexpression token stream then it's not
13:35:39 <___> @src ($)
13:35:40 <lambdabot> f $ x = f x
13:35:40 <b_jonas> etc
13:35:43 <kadaver> always always
13:36:06 <___> then no, you could redefine ($) if you hate the next person to read your code.
13:36:12 <edwardk> well, f $ a - b c /= f (a - b) c -- in general ;) but if thats the end of the statement... ;)
13:36:54 <edwardk> kadaver: actually there is another case
13:37:09 <edwardk> $ makes your application monomorphic
13:37:20 <b_jonas> what?
13:37:28 <___> not polymorphic.
13:37:33 <edwardk> so if 'f' expects a polymorphic function, f $ x will fail
13:37:55 <snoobino> I don't get it
13:37:57 <b_jonas> oh, as in existential types extension?
13:38:01 <edwardk> > let f :: (forall a. a -> a); f x = x in f id 2
13:38:03 <lambdabot>   2
13:38:13 <edwardk> > let f :: (forall a. a -> a); f x = x in (f $ id) 2
13:38:14 <lambdabot>   2
13:38:21 <edwardk> erm.
13:38:40 <___> > let f :: ((forall a. a -> a) -> a -> a); f x = x in (f $ id) 2
13:38:42 <lambdabot>   2
13:38:45 <edwardk> anyways that can blow up
13:38:48 <orbitz> edwardk: doesn't work in ghci
13:38:56 <edwardk> i'm just not awake enough to make it blow up right now =)
13:38:58 <orbitz> on 6.4.2
13:39:07 <edwardk> oh hah
13:39:22 <edwardk> > let f :: ((forall a. a -> a) -> (forall a. a -> a)); f x = x in (f $ id) 2
13:39:25 <lambdabot>   2
13:39:25 <orbitz> edwardk: maybe lambdabot has some magix
13:39:45 <edwardk> *shrug*
13:39:49 <___> @vixen behave yourself
13:39:50 <lambdabot> you're turning me on :)
13:39:53 <___> !
13:40:03 * ___ runs quickly away
13:40:03 <b_jonas> which one doesn't work in ghci?
13:40:15 <b_jonas> with :set -fglasgow-exts I mean
13:40:29 <edwardk> anyways commonly when you need to define rank-2 types $ blows up on you
13:40:59 <orbitz> cale suggests one use f . g rather than f $ g
13:41:28 <___> f . g $ x rather than f $ g $ x
13:41:32 <b_jonas> well, I could pass a polymorphic function to another with $
13:41:35 <orbitz> oh yes that's it
13:41:37 <orbitz> sorry
13:41:38 <b_jonas> > let { f :: (forall a. a -> Int) -> (Int, Int); f x = (x True, x ()); g _ = 0; } in f $ g
13:41:39 <lambdabot>   (0,0)
13:41:40 <___> f . g /= f $ g of course.  =P
13:41:48 <orbitz> righr giht
13:41:52 <b_jonas> oh, (.) blows up
13:41:53 <b_jonas> yeah, that can
13:42:02 <b_jonas> but that's different from ($) isn't it?
13:42:15 <b_jonas> though I guess ($) could blow up too because it's not actually defiend as id
13:42:18 <b_jonas> @src ($)
13:42:18 <lambdabot> f $ x = f x
13:42:24 <b_jonas> @type ($)
13:42:25 <lambdabot> forall a b. (a -> b) -> a -> b
13:42:33 <b_jonas> dunno
13:42:50 <b_jonas> so can you blow it up with just ($) and without (.) ?
13:43:25 <b_jonas> also, can you stop all the blow-ups if you put the exisitential types inside a data ?
13:45:48 <b_jonas> I'm interested because you've already convinced me that existential types can at least sometimes be useful
13:55:24 <clanehin> I haven't seen that, how do you blow up rank 2 types?
13:55:44 <b_jonas> clanehin: I dunno either
13:55:58 <b_jonas> I have heared this claimed about (.) but I haven't seen a real example
14:01:38 <Peaker> b_jonas: how did he convince you?  I am not convinced either way - but each time I thought I needed existential types, I ended up not needing them when I refactored stuff to be nicer
14:04:19 <b_jonas> Peaker: there's ST and there's GADT which is sort of natural and there's also some connection with polymorphic recursion
14:04:26 <b_jonas> Peaker: I don't really know the exact arguments
14:04:35 <b_jonas> Peaker: ST should be clear enough though
14:04:39 <Peaker> b_jonas: haven't had a chance to use GADT's either yet
14:04:55 <b_jonas> I'm not saying it's very often useful, just occasionally
14:05:02 <vixey> what are yuo guys talking about
14:05:09 <b_jonas> vixey: existential types
14:05:14 <b_jonas> or higher-order types
14:05:15 <vixey> what's that
14:05:19 <b_jonas> those are the same, aren't they?
14:05:36 <Peaker> b_jonas: how is the existential used in ST? someone explained it once, and I forget
14:06:07 <Peaker> vixey: Higher-rank types, if I understand rank correctly
14:06:20 <b_jonas> Peaker: they're used to stop you from returning an STRef from a runST because if you could do that then you could pass them in another ST run which would be wrong
14:06:28 <Peaker> vixey: nested "forall" with contravariance (also, if I understand the definitions correctly)
14:06:38 <b_jonas> Peaker: and for that runST takes a funny type which doesn't let you do that
14:06:46 <Peaker> @type runST
14:06:46 <lambdabot> forall a. (forall s. ST s a) -> a
14:07:16 <b_jonas> Peaker: and you have to know that that s is a ghost parameter, and that an STRef depends on it
14:07:22 <b_jonas> @type newSTRef
14:07:23 <lambdabot> forall a s. a -> ST s (STRef s a)
14:07:38 <b_jonas> in an ST s monad, you can only create STRef s, not other STRef
14:08:01 <b_jonas> but such an STRef s can't leak out from the runST because
14:08:22 <gwern> 'John MacFarlane (philosophy of language, philosophy of logic) at the University of California at Berkeley has turned down the senior offers from the Departments of Philosophy at New York University and Harvard University. That's a major retention coup for Berkeley!'
14:08:26 <gwern> small world
14:08:29 <b_jonas> the ST action you pass to runST has to produce the same a from any s
14:09:00 <Peaker> b_jonas: I think I understand the trick.. its very nice.  Is there maybe a non-existential alternative, though?
14:09:20 <b_jonas> Peaker: I don't know
14:09:31 <b_jonas> there's of course doing everything in IO because IO can do anything that ST can
14:09:41 <b_jonas> I'm not sure if you can call that an alternative
14:11:23 <b_jonas> and then there's using Seq instead of mutable arrays
14:12:18 <b_jonas> good night
14:12:33 <RayNbow> @djinn-add class Functor f where fmap :: (a -> b) -> f a -> f b
14:12:39 <RayNbow> @djinn Functor f => f (f b -> b) -> f b
14:12:40 <lambdabot> -- f cannot be realized.
14:13:05 <RayNbow> aww
14:13:21 <Peaker> how do you realize it?
14:13:29 <RayNbow> it's the type of loeb
14:13:33 <Peaker> @type loeb
14:13:34 <lambdabot> Not in scope: `loeb'
14:13:45 <RayNbow> @let loeb x = fmap (\a -> a (loeb x)) x
14:13:47 <lambdabot>  Defined.
14:14:12 <RayNbow> > loeb [const 3, (!! 0), \self -> self !! 0 + self !! 3, const 999]
14:14:14 <lambdabot>   [3,3,1002,999]
14:14:43 <RayNbow> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html <-- I found loeb here btw :)
14:14:51 <___> > loeb $ Just (const 1)
14:14:53 <lambdabot>   Just 1
14:14:59 <Peaker> yeah, I see where you'd have an "f b", from the recursive result
14:15:11 <gnuvince_> :t loeb
14:15:12 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
14:15:14 * RayNbow nods
14:21:43 <Apocalisp> @users
14:21:43 <lambdabot> Maximum users seen in #haskell: 658, currently: 629 (95.6%), active: 16 (2.5%)
14:23:22 <Cale> djinn can't do recursion.
14:23:55 <skorpan> Cale: what does that even mean?
14:24:27 <Cale> It means it won't look for a recursive function that satisfies the type you give it.
14:24:32 <skorpan> isn't djinn the one which can generate functions from type signatures?  is there any type signature which implies recursion?
14:24:39 <skorpan> oh, i see
14:24:50 <BONUS> @pl (\t -> map ((+ head t) . (t !!) . (+1)) [0 .. length t - 2] ++ [0])
14:24:51 <lambdabot> (++ [0]) . ap (map . ap ((.) . (+) . head) ((. (1 +)) . (!!))) (enumFromTo 0 . subtract 2 . length)
14:24:58 <BONUS> oh my
14:25:51 <vininim> > loeb [(!! 3), const 1, const 2, const 3, const 4]
14:25:53 <lambdabot>   [3,1,2,3,4]
14:26:32 <Gracenotes> @unpl f . (.) . gw
14:26:33 <lambdabot> (\ g -> f (\ b c -> gw g (b c)))
14:26:56 <___> > loeb [(!! 1), (!! 0)]
14:27:12 <lambdabot>   thread killed
14:27:38 <johnw> what do @pl and @unpl do?
14:27:45 <___> @help pl
14:27:45 <lambdabot> pointless <expr>. Play with pointfree code.
14:27:57 <Gracenotes> you can make a nice Fibonacci with loeb
14:27:57 <___> @pl \x -> x + 1
14:27:58 <lambdabot> (1 +)
14:28:12 <johnw> thanks
14:28:46 <Berengal> What's the definition of loeb?
14:29:10 <___> <RayNbow> @let loeb x = fmap (\a -> a (loeb x)) x
14:29:23 <Gracenotes> @google sigfpe loeb
14:29:24 <lambdabot> No Result Found.
14:29:31 <Gracenotes> hm.. screwed up his name, didn't I
14:29:51 <___> looks right to me.  Signal floating-point exception.
14:29:58 <___> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
14:30:01 <vininim> > loeb [(!! 3), (!! 2), (liftm (+1)).(!! 4), (!! 1), const 4]
14:30:01 <Gracenotes> suppose google didn't pick it up.
14:30:03 <lambdabot>   Not in scope: `liftm'
14:30:04 <Gracenotes> yes
14:30:14 <vininim> > loeb [(!! 3), (!! 2), (liftM (+1)).(!! 4), (!! 1), const 4]
14:30:16 <lambdabot>       No instance for (Num (m a1))
14:30:16 <lambdabot>        arising from the literal `4' at <in...
14:30:21 <Gracenotes> 'tis the link in my copy/paste buffer
14:30:58 <vininim> uh
14:31:22 <___> > loeb [(!! 3), (!! 2), (+1).(!! 4), (!! 1), const 4]
14:31:25 <lambdabot>   [5,5,5,5,4]
14:31:32 <___> (!!) already escapes the [] Monad, no need for liftM
14:32:35 <vininim> :t (!! 1)
14:32:36 <lambdabot> forall a. [a] -> a
14:32:41 <vininim> :t (.)
14:32:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:33:01 <vininim> :t (+1)
14:33:01 <quicksilver> conor++ # not everyone gets SPJ to write new wiki pages in response to a mailing list post :P
14:33:02 <lambdabot> forall a. (Num a) => a -> a
14:33:33 <___> quicksilver: url?
14:34:06 <Berengal> ___: http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/Parser
14:34:09 <quicksilver> ___: http://www.haskell.org/pipermail/haskell-cafe/2009-April/059911.html
14:34:15 <Phyx-> :t forM
14:34:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:34:21 <quicksilver> (SPJ's message is three clicks on 'next message' later)
14:34:21 <Phyx-> eh?
14:34:24 <vininim> oh i was reading loeb type wrong
14:34:31 <Phyx-> :t forM
14:34:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
14:34:37 <Phyx-> wth
14:34:47 <quicksilver> Phyx-: what's up? the * -> * part?
14:34:47 <Phyx-> oh
14:34:51 <Phyx-> omits function name
14:34:59 * quicksilver nods
14:35:23 <Phyx-> quicksilver, nah, *->* is the kind m should have is it not?
14:35:31 <quicksilver> yew
14:35:35 <quicksilver> it's not haskell, though
14:35:42 <quicksilver> it's some extension lambdabot has turned on.
14:35:48 <Phyx-> thought so, didn't think it was legal to type that in haskell
14:35:55 <quicksilver> kinds can be inferred unambiguously, so there is no need to annotate them
14:36:03 <quicksilver> it's just to be explicit.
14:36:09 <quicksilver> (and haskell has no syntax for annotating them)
14:36:42 <Phyx-> i need to finish reading the haskell98 report one of these days
14:36:51 <w0rth> What is the equivalent of null or void in haskell?
14:36:55 <Phyx-> so i know what's haskell and what's ghc specific
14:37:02 <Phyx-> w0rth, undefined?
14:37:07 <quicksilver> w0rth: possibly 'Nothing'
14:37:10 <quicksilver> depends on the context.
14:37:17 <quicksilver> possibly ().
14:37:26 <w0rth> Hm, okay
14:37:36 <Gracenotes> there is no general null/void that can be a value of any type
14:37:49 <dons> alpha spec of the haskell platform: for your consideration, http://haskell.org/haskellwiki/Haskell_Platform
14:37:53 <w0rth> If I implement a linked list as a curried function (if that makes sense), what would I use as the base case?
14:38:21 <w0rth> so extend list name value = \x -> if name == x then value else list x
14:38:30 <w0rth> what would work as my empty list?
14:38:31 <sm> dons: nice logo!
14:38:33 <dons> Just value or Nothing ?
14:38:59 <w0rth> ah okay
14:39:01 <w0rth> makes sens
14:39:09 <Gracenotes> @type lookup
14:39:11 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
14:39:24 <Gracenotes> ^ the main association list lookup function uses Just/Nothing too
14:39:33 <sm> dons: should hoogle be added ?
14:39:50 <w0rth> so change it from Name -> Value to Name -> Maybe Value. got it
14:39:52 <Phyx-> lol, why is "bessed" between quotes
14:39:57 <Berengal> Gracenotes: undefined can be of any type and can be seen as null if stretched a bit.
14:40:03 <Berengal> It's rather useless though...
14:40:05 <dons> Phyx-: we don't actually do a blessing.
14:40:11 <Phyx-> awww :(
14:40:20 <dons> but i'll remove the quotes anyway
14:40:28 <Phyx-> that kinda moots the whole point of calling some of you haskell gods :P
14:41:08 <Gracenotes> Berengal: yeah, not analogous to the purpose of null in other languages at all
14:41:50 <Berengal> Gracenotes: Oh I don't know... Integer div(Integer a, Integer b){if (b.value == 0) return null; ...
14:41:54 <Gracenotes> well, for a loose definition of 'purpose'.
14:42:18 <Phyx-> lol, to bad i can't make it for the hackathon
14:42:23 <Phyx-> but too busy :S
14:42:28 <Berengal> Gracenotes: But yes, "undefined" is rather useless in haskell. You can't (==undefined)
14:42:31 <Gracenotes> right, used as a sentinel value of sorts.
14:42:45 <bavardage> Gracenotes: ping
14:42:49 <Gracenotes> hallo
14:43:00 <bavardage> Gracenotes: I've started on a parser 0o
14:43:05 <bavardage> *Main> showInteger $ run "(λ f (λ x (f x)))"
14:43:06 <bavardage> 1
14:43:38 <Gracenotes> Berengal: agree about undefined though. Maybe if had a lazy-in-the-second-argument Eq... for ()... which () doesn't have.
14:43:42 <Gracenotes> +you
14:43:51 <Gracenotes> bavardage: oh, neat :D parsec?
14:43:54 <bavardage> Gracenotes: indeed
14:44:04 <bavardage> thankfully the syntax is uber-simple :P
14:44:07 <bavardage> else I'd be screwed
14:45:41 <Gracenotes> bavardage: yeah. I sort of copped out for making an interesting parser for mine and just used postfix notation :)
14:45:56 <bavardage> I'm gonna go lisp-style
14:46:01 <bavardage> nice and easy ;P
14:46:13 <Gracenotes> by postfix I mean RPN
14:46:19 <bavardage> RPN?
14:46:25 <bavardage> oh kk
14:46:40 <bavardage> that's also a way to go I guess
14:46:47 <Gracenotes> .. >f >x >x @ @ #x >f >x >x @ @ #x @ #f fix >n ?0 >a >f >b @ >a >b + @ >n -1 @ ? #n #b #a #f @ 0 @ 1 @ 1000 @
14:46:56 <Berengal> RPN is almost too easy to parse...
14:47:05 <Gracenotes> gave you the 1000th fibonacci number :) with int and boolean extensions
14:47:08 <Gracenotes> and totally unreadable
14:47:20 <Berengal> I was playing around trying to make a stack-based language in python using it
14:47:48 <bavardage> Gracenotes: oh wait.. I still need to make a y-combinator
14:47:52 <bavardage> I AM GETTING AHEAD OF MYSELF!!
14:47:54 <bavardage> pfft
14:48:41 <Berengal> bavardage: I usually implement the parser and printer first (or second). Makes testing the language much easier later.
14:48:58 <bavardage> hmm the printer will be fun too
14:49:04 <bavardage> since my integers are church-style
14:49:12 <Gracenotes> you could also allow multi-argument lambdas. (λ a b (blah)), desugars to (λ a (λ b (blah)))
14:49:23 <bavardage> Gracenotes: yeah at some point
14:49:25 <Berengal> Does everything have to reduce to an int?
14:49:25 <bavardage> but not yet :P
14:49:38 <bavardage> Berengal: no.. I have Bools too
14:49:39 <Gracenotes> and remember, function application associates to the left! :X
14:49:44 <bavardage> maybe I should kill them
14:49:48 <bavardage> Gracenotes: yeah I got that much
14:49:53 <bavardage> Gracenotes: right would have been easier though
14:49:54 <Gracenotes> unless you're requiring parens for each application
14:50:01 <bavardage> since haskell prefers going forward
14:50:08 <Gracenotes> yeah. It's perhaps one appropriate time for a foldl.
14:50:24 <Gracenotes> perhaps if you parse the entire list between parens and foldl on that. or somethin.
14:50:38 <Gracenotes> but that's not parsec-y
14:50:56 <Gracenotes> and means possibly duplicating parentheses counting, etc.
14:51:59 <bavardage> atm I have a fairly ugly:
14:52:14 <bavardage> http://paste.pocoo.org/show/113017/
14:55:45 <tromp> makeApplication (a:as) = foldl a Application as
14:56:06 <bavardage> oh haha
14:56:10 <bavardage> I couldn't think how do do the identity
14:56:15 <bavardage> that is horribly obvious
14:56:16 <bavardage> ty
14:57:13 <tromp> btw, most ppl wld tire of writing Application
14:57:22 <tromp> so they just abbreviate it to App
14:57:39 <ErhardtMundt> back
14:57:41 <Gracenotes> also Variable to Var; sometimes Lambda to Lam
14:58:08 <Gracenotes> http://www.google.com/search?q=haskell+lame :)
14:58:19 <bavardage> yah, but hopefully I'm not going to be coding haskell for much longer :P
14:58:19 <Berengal> I find abbrevations to lessen readability...
14:58:36 <Gracenotes> bavardage: :o
14:58:49 <bavardage> Gracenotes: I'll be on to my own über language
14:59:09 <bavardage> I just need to work out how to make a let statement
14:59:20 <bavardage> then I can start writing a 'library' in the language itself
14:59:40 <bavardage> http://paste.pocoo.org/show/113018/ atm I have this as a 'standard library' :D
14:59:41 <Gracenotes> the type of let is really.. Let [(Identifier, Term)] Term
14:59:46 <bavardage> yeah
14:59:53 <bavardage> should Let be of type Term?
14:59:57 <Gracenotes> earlier you just had Let Identifier Term
15:00:01 <bavardage> I guess so
15:00:04 <bavardage> yeah
15:00:12 <bavardage> but I see the problem with that
15:00:13 <Gracenotes> I'd call Term "expression" personally. But it is an expression, in Haskell too.
15:00:21 <bavardage> I guess you could do chained lets :D
15:00:24 <bavardage> to avoid the list
15:00:27 <bavardage> if you were crazy
15:00:38 <Gracenotes> well. Chained lets can't be mutually recursive
15:00:46 <bavardage> yop
15:00:49 <bavardage> that reminds me
15:00:57 <bavardage> I need to test out the y-combinator
15:01:13 <bavardage> also, using Boolean booleans instead of church booleans..
15:01:20 <bavardage> how do you do the and,or,not operators
15:01:52 <Gracenotes> bavardage: by the way, http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
15:01:53 <tromp> my implementation of binary lambda calculus has a let
15:02:20 <bavardage> Gracenotes: nice :D
15:02:30 <bavardage> I really need to get myself an ebook reader or something
15:02:45 <bavardage> I'm not used to reading large amounts at the comp
15:03:08 <Gracenotes> bavardage: as primitives, you only need or and not
15:03:16 <Gracenotes> two of them, 'or' and 'not'
15:03:26 <luite> problem is that there aren't really any ebook readers suitable for reading papers (in hard-to-reflow formats)
15:03:28 <bavardage> haha the joys of english ambiguity
15:03:30 <bavardage> yeah
15:03:37 <Gracenotes> everything else can be implemented in terms of those. But you can make 'and' and 'xor' just to be nice, if you like
15:03:38 <bavardage> luite: 'hard-to-reflow'?
15:03:51 <bavardage> Gracenotes: oh so make those primitives
15:03:52 <bavardage> kk
15:03:54 <tromp> and = \x\y x y x
15:04:04 <bavardage> tromp: with church booleans, yeah
15:04:04 <Gracenotes> in Church terms, yeah
15:04:05 <tromp> or = \x\y x x y
15:04:11 <tromp> right
15:04:19 <bavardage> but I think I may use non-church booleans
15:04:28 <bavardage> though I am using church naturals
15:04:37 <luite> bavardage: yes, pdf or ps. have you tried the reflow option in adobe reader? its results are often terrible
15:04:45 <bavardage> what's 'reflow'
15:04:50 <bavardage> no, I haven't tried that
15:04:51 <tromp> actually those are the standard booleans, don't know any others
15:05:03 <bavardage> tromp: yeah, I'm using haskell booleans
15:05:08 <bavardage> possibly
15:05:31 <tromp> you mean language primitives?
15:05:37 <tromp> not lambda terms?
15:05:38 <luite> bavardage: oh sorry, that's when the reader layouts the text to fit on the screen. if you have a reflowable format, you can change the font size, line length etc
15:05:40 <bavardage> indeed
15:05:45 <bavardage> luite: oooh right kk
15:05:50 <bavardage> luite: no, I haven't tried that
15:06:11 <luite> bavardage: most ebooks are distributed in some reflowable format, but papers really have a fixed layout, so you need a larger screen, or lots of scrolling
15:06:24 <bavardage> oh kk
15:06:34 <bavardage> I have never bought any ebooks :P
15:06:38 <bavardage> so haven't come across this yet
15:06:41 <bavardage> hmm
15:06:48 <bavardage> I see that would be an issue
15:07:49 <Gracenotes> @hoogle (m a → m b) → m (a → b)
15:07:49 <lambdabot> Parse error:
15:07:49 <lambdabot>   --count=20 "(m a → m b) → m (a → b)"
15:07:49 <lambdabot>                    ^
15:08:00 <Gracenotes> @hoogle (m a -> m b) -> m (a -> b)
15:08:01 <lambdabot> No results found
15:08:15 <bavardage> I dunno, I'm tempted to use church booleans
15:08:20 <bavardage> just to stay pure-ish
15:08:47 <PetRat> Is there a more recent Parsec manual than this one? http://research.microsoft.com/en-us/um/people/daan/download/parsec/parsec-letter.pdf  It doesn't mention lookAhead.
15:09:25 <ddarius> PetRat: There's Haddock, but no newer manual.
15:09:38 <Gracenotes> that was the debut paper, wasn'
15:09:40 <Gracenotes> t it?
15:10:02 <PetRat> Pardon my newbieish, but what is Haddock? Is that the documentation linked off the homepage of haskell.org?
15:10:14 <bavardage> haddock is a doc generator
15:10:18 <lament> it's the tool used to generate that
15:10:33 <Gracenotes> it doesn't seem (m a -> m b) -> m (a -> b) is constructable in general, although (m a -> b) -> m (a -> b) is.
15:10:46 <ddarius> @hackage parsec
15:10:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
15:10:56 <vixey> (Maybe a -> Maybe b) -> Maybe (a -> b)
15:10:57 <lament> also, it's a fish...
15:11:27 <PetRat> I can't find where that documentation documents anything. For lookAhead, it gives the type signature, but no other info I can find.
15:11:39 <Gracenotes> vixey: well, it is implementable for MonadZero, always return mzero :)
15:11:41 <vixey> so suppose you put  Just a  into the first function, and you have Maybe b... there's no way to know in advance if the result is Nothing or Just
15:11:51 <Gracenotes> right
15:12:37 <ddarius> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html#v%3AlookAhead
15:13:36 <PetRat> ddarius thanks
15:14:20 <PetRat> Is there something called Hoogle that is for searching hackage?
15:15:02 <PetRat> never mind, just tried it and it worked
15:19:31 <Hire> http://hire.mybrute.com/
15:21:30 <RayNbow> oh great, mybrute spam in #haskell?
15:25:32 <skorpan> mybrute is so awesome
15:29:12 <bremner> > :t mybrute
15:29:13 <lambdabot>   <no location info>: parse error on input `:'
15:29:16 <RayNbow> skorpan: but spam isn't
15:35:37 * wli hammers out some Grobner code to cope with the box he's been loging into for Maple vaporizing.
15:36:42 <ddarius> I believe DoCon (http://haskell.org/docon/) already has some Grobner bases code.
15:38:45 <wli> ddarius: Thanks, but I'll roll my own for various reasons.
15:48:14 <soulofmyshoe> Question: is it possible to cons or concatenate onto a tuple the way you would onto a list?
15:48:57 <soulofmyshoe> or rather, to take an n-tuple and add an element, returning an n+1-tuple, if you don't know how much n is?
15:49:46 <ray> not possible, because there's no haskell type for "n-tuple"
15:49:53 <ray> just specific numbers
15:51:00 <soulofmyshoe> That's sort of what I was afraid of
15:51:03 <roconnor> Are there any "type systems" to prevent stack overflows?
15:51:23 <ivanm> roconnor: I fail to see how a type system can prevent stack overflows...
15:51:34 <ivanm> though I've only ever had one when using Haskell
15:51:34 <roconnor> ivanm: me too
15:51:36 <Peaker> roconnor: That probably boils to the question if there are type systems that can put a cap on memory use?
15:51:37 <soulofmyshoe> so it isn't really possible to create a zipMany function that takes the number of lists to zip as an argument?
15:51:44 <roconnor> Peaker, exactly
15:51:50 <ivanm> roconnor: though I've had heaps with Fortran, etc. ;-)
15:51:56 <vixey> roconnor: I think that's what these Hume guys are into
15:52:07 <roconnor> vixey: who are the Hume guys?
15:52:11 <vixey> http://www-fp.cs.st-andrews.ac.uk/hume/index.shtml
15:52:30 <vixey> roconnor and edwinb (I think he's on that team?) also posted a bit about being resource aware in Idris DSL
15:52:32 <ivanm> soulofmyshoe: IIRC, someone once said that that becomes transpose...
15:52:38 <vixey> maybe you saw that one already though
15:53:07 <Peaker> roconnor: I don't see a theoretical reason for why dependent types can't do that -- you might talk about the O() in your types and have it verified by the compiler, but except instead of O() it would be something more precise, where the primitives you use from the implementation specify their exact caps on memory use and the compiler propagates this through the types and verifies it matches compile-time or run-time memory limits
15:53:10 * roconnor grabs the Hume report
15:53:26 <soulofmyshoe> ivanm: I think that might be what I was looking for.  Thank you!
15:53:35 <roconnor> Peaker, I suspect it is more tricky than that
15:54:02 <Peaker> roconnor: I read that some dependent type system that can verify O() complexities existed, that's nearly good enough
15:54:23 <roconnor> unless the verification overflows the stack :)
15:54:25 <ivanm> Peaker: :o
15:54:27 <vixey> I think you are sort of just making speculation
15:54:46 <Cale> I feel that artificially limiting the stack is kind of silly anyway
15:55:02 <Cale> It ought to be the same as running out of memory.
15:55:04 <roconnor> Cale: well, stack overflows, and out of memory errors
15:55:12 <roconnor> I should have said both
15:55:35 <Peaker> well, stack can grow dynamically to just use all memory -- so its only a question of memory use (which is what I meant in my first reply)
15:55:37 <lament> Cale: i guess the assumption is that only buggy programs need so much stack.
15:55:51 <Cale> I have a feeling that any such type system would be annoying as hell to use.
15:55:56 <lament> which is reasonable given C and the like
15:56:17 <lament> and it's called the C stack, so...
15:56:22 <Cale> Unless you restricted the class of programs which it applied to, perhaps.
15:57:13 <roconnor> Cale: it bothers me when my provably correct and safe programs crash.
15:58:41 <vixey> provably correct ??
15:58:57 <roconnor> proved correct
15:59:04 <soulofmyshoe> Oh, right.  Since lists have to be of a single type, tranpose doesn't act like a fully-fledged zipMany :(  It would work for some circumstances, but isn't quite what I had in mind.
16:50:05 <roconnor> @users
16:50:05 <lambdabot> Maximum users seen in #haskell: 658, currently: 599 (91.0%), active: 4 (0.7%)
16:50:49 <Peaker> @users
16:50:50 <lambdabot> Maximum users seen in #haskell: 658, currently: 600 (91.2%), active: 4 (0.7%)
16:50:59 <Peaker> was I active or do commands not affect "active"?
16:51:11 <Tsion> @users
16:51:12 <lambdabot> Maximum users seen in #haskell: 658, currently: 600 (91.2%), active: 5 (0.8%)
16:51:20 <Tsion> heh :P
17:57:11 <roconnor> @users
17:57:12 <lambdabot> Maximum users seen in #haskell: 658, currently: 583 (88.6%), active: 2 (0.3%)
17:57:30 <roconnor> just me and you lambdabot
18:01:04 <PetRat> I'm here
18:01:27 <PetRat> Not paying much attention though.
18:02:22 <lpsmith> heh,  I'm lurking.   I agree with Cale by the way:   it would be really nice if GHC would get rid of stack overflows.
18:03:53 <lpsmith> of course, I do see one downside...  accidental infinite loops,  usually by referring to the LHS of a let or where expression  on the RHS,  would take longer to crash the system.
18:04:14 <lpsmith> 'cause GHCi often cannot ^C out of such beasts :-(
18:06:11 <sm> even 6.10.2 ?
18:06:37 <lpsmith> I doubt it,  this problem has been around for ages
18:06:54 <lpsmith> And 6.10.2 isn't working quite right on my system.
18:07:12 <lpsmith> so I can't really say.   Hitting ^C segfaults the interpreter,  always.
18:07:31 <gwern> @remember UmbertoEco I don't even have an e-mail address. I have reached an age where my main purpose is not to receive messages.
18:07:32 <lambdabot> Okay.
18:07:53 <gwern> @quote email
18:07:54 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
18:08:36 <lpsmith> @quote OlegFacts
18:08:37 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:13:46 <centrinia> @faq Can Haskell solve NP-Hard problems in O(N log N) time with its type system?
18:13:46 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:01 <centrinia> Haskell's type system can do that too!
18:14:15 <DarthArachides> @help
18:14:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:14:24 <DarthArachides> +help
18:14:27 <DarthArachides> +list
18:14:29 <DarthArachides> @list
18:14:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:14:52 <gwern> http://code.google.com/p/tapl-haskell/ <-- this could be useful. is tapl online?
18:15:43 <gwern> @quote Word32
18:15:44 <lambdabot> CosmicRay says: <CosmicRay> Is there a way to, say, convert from a Word32 to a Word8 when I know the data in question will fit in a Word8? ; <drlion> CosmicRay: just open the file and Word will ask
18:15:44 <lambdabot> you to convert it
18:15:47 <gwern> @quote Word32s
18:15:48 <lambdabot> Gracenotes says: And then the type system goes all crazy and demands that x and 1 are both Word32s!
18:16:07 <gwern> @quote instance.*Monad
18:16:08 <lambdabot> mauke says: data What a = No; instance Monad What where { return _ = No; No >>= _ = No }
18:16:24 <gwern> @quote natural.*transformation
18:16:25 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
18:16:33 <gwern> @quote analogies
18:16:34 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
18:16:44 <gwern> @quote Conficker
18:16:45 <lambdabot> FliPPeh says: @faq Can Conficker be rewritten in Haskell? <lambdabot> <no location info>: parse error on input `:'
18:16:53 <gwern> @quote harsh
18:16:54 <lambdabot> HairyDude says: The Haskell Type System is a Harsh Mistress.. there ain't no such thing as a free theorem.
18:17:03 <gwern> @quote cabbage
18:17:04 <lambdabot> LeCamarade says: Now, let's say the set is {Haskell, SML, Ruby, Tomatoes, Human, Cabbage, Noise, IRC}.
18:17:13 <gwern> @quote cars
18:17:14 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
18:17:23 <gwern> @quote travel
18:17:24 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
18:17:24 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
18:17:28 <gwern> @quote travel
18:17:28 <lambdabot> Babelfish says: And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
18:17:44 * gwern feels slightly disapointed at having nothing to @remember
18:22:39 <BMeph> Hail, #haskell! :)
18:22:59 <gwern> Hail Ilpallazo-sama!
18:28:19 <maxote> is there any interpreter implementation to understand the untyped lambda calculus and how to get evolved it into smaller fingerprint?
18:29:46 <orbisvicis> how do i define a function, say `++` infix so I dont get parse errors ?
18:30:12 <centrinia> > [1,2] ++ [3,4]
18:30:13 <lambdabot>   [1,2,3,4]
18:30:17 <lpsmith> maxote:  yes,  plenty
18:30:24 <centrinia> orbisvicis, ++ is already infix.
18:31:12 <lpsmith> Maxote:  not sure what you mean by smaller footprint,   the lambda calculus isn't a very usable language in and of itself
18:31:23 <orbisvicis> centrinia: no, im trying to define it myself: []  `++` b  = b
18:31:34 <maxote>  err, /fingerprint/footprint/
18:31:55 <centrinia> Call it something else or hide ++
18:32:06 <adamvo> @let x +++++ y = x+y
18:32:07 <orbitz> > let x ++ y = y in [1] ++ [2]
18:32:07 <lambdabot>  Defined.
18:32:09 <lambdabot>   [2]
18:32:47 <maxote> lpsmith, lambda calculus is very usable but not marshalling/unmarshalling the typed objects as does Haskell
18:34:37 <lpsmith> maxote:  not really.   The pure untyped lambda calculus only has three constructs:  lambda abstraction,  expression application,  and variables.
18:34:43 <maxote> i want to convert some of their lazier functions to eager functions, and i don't know how
18:35:13 <lpsmith> You really want to add some things into that mix,  like integers.
18:35:18 <gwern> drat. I was hoping tapl was online, but so far no good
18:35:25 <gwern> '-filetype:mli -filetype:mll -filetype:ml -yacc site:http://www.cis.upenn.edu/~bcpierce/tapl/' doesn't show anything
18:35:30 <lpsmith> Lazy/eager isn't a feature of LC per se.
18:35:36 <gwern> incidentally, it's really nice that google lets you combine operators like - and filetype
18:35:50 <lpsmith> I suggest reading the Essentials of Programming Languages,   by Friedman and Wand
18:36:32 * gwern finds a pdf of half of ATAPL, tho
18:36:46 <tromp> numbers are easy enough to define in lambda calculus
18:37:23 <orbisvicis> right, ++ gets me ambiguous occurences. But +++ work in prefix mode. Not in infix. both `+++` and `(+++)` get parse errors
18:37:34 <centrinia> How do you define lists in lambda calculus?
18:37:54 <QtPlay[HireMe]> centrinia: As pairs
18:38:05 <lpsmith> tromp:  efficient numbers are another matter ;-)
18:38:11 <centrinia> Pairs of elements and pairs?
18:38:28 <tromp> i defined numbers as bit lists
18:38:53 <maxote> one e.g., the fibonacci function can be marked as eager for more efficient execution/memory space, but i don't know when mark it.
18:39:33 <lpsmith> and how do you define bit lists?   If your language is augmented with those,  then it's not the pure LC
18:39:47 <tromp> lists are nested pairs
18:40:01 <tromp> pair = \x\y\z z x y
18:40:19 <tromp> nil = false = \x\y y
18:40:47 <lpsmith> I'm not arguing that it's impossible,  just that you don't really want to do it that way.
18:41:47 <lpsmith> And if you want an implementation with a smaller footprint than GHC,  look at some of the Scheme implementations.
18:42:11 <maxote> tromp, i will define numbers as bit trees
18:42:12 <lpsmith> Factor seems promising in this regard as well.
18:42:16 <centrinia> lpsmith, you can have a pair consisting of a boolean and a either another pair or nil.
18:42:28 <centrinia> The other pair can consist of a boolean and either another pair or nil.
18:42:45 <gwern> lpsmith: yeah, but haskell compiles to a smaller footprint :)
18:42:49 <maxote> and they are reals
18:42:50 <tromp> that seems unnecesarily complicated, maxote
18:43:09 <tromp> there is no simple bijection between numbers and bit trees
18:43:35 <lpsmith> centrina:  again,  I'm not saying that it's all impossible in the end,  I know full well it's doable.   I just don't think it's attractive
18:43:51 <lpsmith> especially once you start considering implementation issues.
18:43:57 <lpsmith> gwern:  lol
18:44:40 <lpsmith> gwern:  yes and no.   The problem is that most Scheme implementations aren't particularly good.
18:46:03 <maxote> tromp, what are the MSbit and LSbit of your bit list?
18:47:21 <aLegendaryPengui> whats a good reference for haskell functions
18:47:23 <aLegendaryPengui> ??
18:47:26 <tromp> LSB at front of course
18:47:27 <maxote> accesing either is O(log(N)) instead of O(N)
18:47:42 <lpsmith> And even bitlists suck when compared to hardware integers.   You definitely want your language to export hardware ints.
18:47:51 <maxote> if is used the bit tree instead of bit list
18:48:11 <lpsmith> You still aren't going to compete with hardware ints.
18:48:23 <lpsmith> not even same ballpark
18:48:26 <maxote> lpsmith, unless combinatoric computation
18:49:10 <centrinia> Using hardware accelerated integer arithmetic will only speed up your integer arithmetic by at most a constant factor.
18:49:59 <lpsmith> constant factors matter
18:50:24 <lpsmith> and,  yes and no:  64-bit arbitrary precision int libraries are 4x faster than 32-bit libraries
18:50:26 <centrinia> Linear factors matter more. Quadratic matters matter even more.
18:50:35 <tromp> of course i only use lc to prove something, not to be competitive with haskell in speed
18:51:40 <centrinia> However, using an asymptotically faster arithmetic algorithm makes more of a difference. ;)
18:51:51 <lpsmith> if an algorithm has the same asymptotic behavior,   but the constant factor is 100x slower,  that's not the same ballpark in my book :-)
18:52:00 <maxote> imagine an infinite list of bigger integers, the bit-level lazy computation bounds them then when they are >= a maximum, and the hardware int lazy computation doesn't bound them.
18:52:06 <centrinia> Using an O(n^2) multiplication algorithm is going to be slower than using an O(n^(log 3 / log 2)) multiplication algorithm for modest n.
18:52:25 <lpsmith> centrina:  depends on the size of the problem instance.   The GMP uses fast multiplication,  but not always.
18:52:44 <centrinia> Yeah, GMP falls back to O(n^2) multiplication.
18:53:00 <centrinia> Even its recursive fast multiplication successively fall back to slower algorithms.
18:53:01 <lpsmith> and even so,  the fast multiplication algorithm uses hardware ints.
18:54:28 <centrinia> There might be some merit in investigating the construction of adders that operate on the vector registers.
18:55:09 <centrinia> There might even be some merit in investigating multipliers that operate on the vector registers.
18:55:09 <adamvo> aLegendaryPengui: the haskell 98 report or library documentation that comes with ghc?
18:55:49 <maxote> i think factorial(n) is faster in the bit-list version than integer arithmetic when n is >= a bound.
18:56:56 <centrinia> Computing n! can be done very efficiently by taking the primes up to n to their respective powers.
18:58:20 <lpsmith> maxote:   I won't dispute that there aren't advantages to other representations of integers... but...
18:58:41 <lpsmith> You don't want to enforce the usage of those by edict
18:58:55 <lpsmith> For most things,  you want hardware ints,  in some form or another
18:58:57 <maxote> n! can be faster if extract all twoses of their factors, they shift to left the bits only
19:00:42 <maxote> there are always twoses their even numbers
19:01:11 <orbitz> hi, if i have banana :: (a -> t -> b) -> (t -> a) -> t -> b, isn't this basically composition?  banana f x = f . x
19:02:12 <ddarius> @djinn banana :: (a -> t -> b) -> (t -> a) -> t -> b
19:02:12 <lambdabot> Cannot parse command
19:02:18 <ddarius> @djinn  (a -> t -> b) -> (t -> a) -> t -> b
19:02:18 <lambdabot> f a b c = a (b c) c
19:02:21 <Gracenotes> @type (.)
19:02:22 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:02:23 <maxote> there are always twoses their even numbers, multiple of 4, multiple of 8, multiple of 8, and so on 2^i
19:02:28 <dibblego> looks like ap in (t ->) to me
19:02:32 <dibblego> or the S combinator
19:02:57 <dibblego> @type ap
19:02:59 <Gracenotes> looks a bit more like =<<
19:02:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:03:05 <orbitz> no cheats dibblego!
19:03:45 <lpsmith> orbitz:  there is definitely more to it than composition
19:03:55 <Gracenotes> orbitz: like composition, it's an interesting way of combining functions; but it isn't as straightforward
19:04:07 <ddarius> :t (=<<)
19:04:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
19:04:42 <Gracenotes> it's used here and there in idiomatic pointfree Haskell, afaik
19:04:42 <dibblego> orbitz, oh I just realised what you're doing, yes more like (=<<) ;)
19:04:43 <lpsmith> :t (>>=)
19:04:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:04:55 <Gracenotes> at least I use it
19:05:03 <orbitz> okay doing what ddarius suggested works, but do i necesiarly know c should be in thoe 2 places by the type sig (same type but same value?)
19:05:40 <dibblego> orbitz, try to write something otherwise
19:05:43 <Gracenotes> well, the only 'value' you're given is a t. You need to pass two values to a function to get a b
19:05:51 <Gracenotes> or whatever the final result is
19:06:34 <Gracenotes> .. or something like that.
19:07:05 <lpsmith> orbitz:  I think that's the only combinator of that type.
19:07:32 <lpsmith> without cheating and using bottom and stuff like that
19:08:28 <aLegendaryPengui> if im using foldl, but there is a case in the function where it encounters something unexpected and has to stop folding, how can you do that
19:08:58 <Gracenotes> well, you can do it with foldr. foldl might be a bit more difficult
19:09:00 <aLegendaryPengui> like say i want it to convert "325.132" to Int, but when it sees the . it should realize the input is bad
19:09:29 <dibblego> aLegendaryPengui, you could use foldr
19:09:47 <aLegendaryPengui> how would that differ
19:10:29 <aLegendaryPengui> like i dont want to prescan the input either
19:13:26 <aLegendaryPengui> looks liek the onyl solution is to use a function that will return some string every time the fold is applied?
19:13:39 <aLegendaryPengui> seems like calling error would be better though
19:14:04 <Gracenotes> well, for error handling you can use Maybe and Either
19:14:11 <Gracenotes> either/or
19:14:21 <Gracenotes> for a safer approach..
19:17:10 <Gracenotes> hm. I don't think that the problem of reading a String -> Int lends itself to foldr that well..
19:17:37 <aLegendaryPengui> yeah, I had to use foldl
19:18:00 <aLegendaryPengui> because you can multiply the left argument by 10 each time
19:18:31 <aLegendaryPengui> wonder how oyu would do that with foldr
19:19:20 <Gracenotes> painstakingly, I'd guess
19:19:46 <Gracenotes> but, you can still stop whenever you see a period by making a (Maybe Integer) your accumulator
19:20:10 <Gracenotes> and, when you that isDigit is false, yielding Nothing
19:20:32 <Gracenotes> unfortunately this will go through the string even after it finds a period, but it will do absolutely no work
19:22:17 <aLegendaryPengui> yeah, that seems bad
19:25:00 <Gracenotes> aLegendaryPengui: you could make your own version of foldl, where seeing a Nothing as the accumulator means immediately failing
19:25:16 <Gracenotes> @src foldl
19:25:16 <lambdabot> foldl f z []     = z
19:25:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:25:34 <dibblego> > foldM (\a b -> if isDigit b then Just (a * 10 + (digitToInt b)) else Nothing) 0 "325.132"
19:25:36 <lambdabot>   Nothing
19:25:37 <Gracenotes> take out the f parameter, since you'll embed it into the function, and add an extra case for when z is Nothing
19:25:44 <dibblego> > foldM (\a b -> if isDigit b then Just (a * 10 + (digitToInt b)) else Nothing) 0 "325132"
19:25:45 <lambdabot>   Just 325132
19:26:13 <Gracenotes> oh.. mm, right :) the semantics of foldM are better here
19:26:35 <Gracenotes> it basically does what I said automatically due to how the Maybe monad works. cute.
19:26:51 <Gracenotes> > foldM (\a b -> if isDigit b then Just (a * 10 + (digitToInt b)) else Nothing) 0 ("123.456" ++ [undefined])
19:26:52 <lambdabot>   Nothing
19:27:23 <Gracenotes> > foldl (\acc x -> acc >>= \acc -> if (isDigit x) then Just (acc*10 + digitToInt x) else Nothing) (Just 0) ("123.456" ++ [undefined])
19:27:24 <lambdabot>   Nothing
19:27:37 <aLegendaryPengui> @src takeWhile
19:27:37 <lambdabot> takeWhile _ []                 =  []
19:27:38 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
19:27:38 <lambdabot>                    | otherwise =  []
19:27:55 <aLegendaryPengui> lol this book im going through says to write takewhile with fold
19:27:55 <Gracenotes> of course.. that doesn't work if you force evaluation of x somehow
19:28:28 <Gracenotes> it still goes through every case, while foldM stops cold :o
19:28:44 <Gracenotes> aLegendaryPengui: Real World Haskell?
19:28:54 <aLegendaryPengui> yea
19:28:55 <Berengal> aLegendaryPengui: It's not too hard to write takeWhile with foldr...
19:29:02 <aLegendaryPengui> i know, its just dumb
19:29:08 <aLegendaryPengui> haha
19:29:18 <aLegendaryPengui> guess they want to make it challenging
19:29:29 <f4hy> >>=
19:29:34 <Gracenotes> foldr is a funny creature. The ways to think about it are somewhat different for lazy and strict functions
19:29:59 <Gracenotes> at least for me, in terms of intuition
19:30:57 <f4hy> What does (>>=) mean
19:31:02 <aLegendaryPengui> its a face
19:31:07 <aLegendaryPengui> double sad face
19:31:12 <f4hy> I knew it
19:31:16 <Gracenotes> @src Maybe >>=
19:31:16 <lambdabot> Source not found. You type like i drive.
19:31:34 <Gracenotes> @src Maybe (>>=)
19:31:35 <lambdabot> (Just x) >>= k      = k x
19:31:35 <lambdabot> Nothing  >>= _      = Nothing
19:31:41 <Gracenotes> ^ that's what it does in this case
19:32:26 <f4hy> ok so it takes a maybe, and if it is just something it does the function on it, otherwise it gives nothing?
19:33:05 <dibblego> @type (>>=)
19:33:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:33:24 <Berengal> @src [] (>>=)
19:33:24 <lambdabot> xs >>= f     = concatMap f xs
19:33:25 <Gracenotes> mm
19:33:43 <dibblego> it takes "an anything (m) of a" and a function from 'a' to "an anything (m) of b" and returns "an anything (m) of b"
19:34:09 <dibblego> > Just 7 >>= \x -> if even x Just (x * 2) else Nothing -- like this
19:34:10 <lambdabot>   <no location info>: parse error on input `else'
19:34:16 <dibblego> > Just 7 >>= \x -> if even x then Just (x * 2) else Nothing -- like this
19:34:18 <lambdabot>   Nothing
19:34:23 <dibblego> > Just 8 >>= \x -> if even x then Just (x * 2) else Nothing -- like this
19:34:23 <roconnor> > diff sqrt x
19:34:25 <lambdabot>   Not in scope: `diff'    Ambiguous occurrence `x'
19:34:25 <lambdabot>      It could refer to eit...
19:34:25 <lambdabot>   Just 16
19:34:34 <roconnor> > dif sqrt x
19:34:35 <lambdabot>   Not in scope: `dif'    Ambiguous occurrence `x'
19:34:35 <lambdabot>      It could refer to eith...
19:34:51 <roconnor> > deriv sqrt x
19:34:53 <lambdabot>       Ambiguous occurrence `x'
19:34:53 <lambdabot>      It could refer to either `L.x', defined a...
19:34:55 <Gracenotes> @type L.x
19:34:56 <lambdabot> forall t. (Num t) => t
19:35:00 <Gracenotes> > x
19:35:01 <lambdabot>       Ambiguous occurrence `x'
19:35:01 <lambdabot>      It could refer to either `L.x', defined a...
19:35:03 <roconnor> @undef
19:35:06 <roconnor> > deriv sqrt x
19:35:07 <lambdabot>   1 * recip (2 * sqrt x)
19:35:11 <ivanm> I've got a function "a -> [b]", the results of which I then filter and finally nubBy
19:35:18 <f4hy> hmm ok I am still confused
19:35:42 <ivanm> is there any way I can (lazily) go and write every nth value of the original results to a file before I filter and nubBy?
19:35:46 <f4hy> wait no i think i get it
19:36:04 <ivanm> I'm trying to work out if my app is just generating a lot of values that are duplicates, or whether it's frozen :s
19:37:35 <ivanm> everything that I've tried so far results in an out of memory error :s
19:37:53 <Gracenotes> ivanm: ..try tracing?
19:37:56 <Berengal> ivanm: There are some trace and debug things around...
19:37:58 <f4hy> > Nothing >>= \x -> Just (x*2)
19:38:00 <lambdabot>   Nothing
19:38:09 <ivanm> Gracenotes: yeah, but that goes to stderr, I was hoping to write to file :s
19:38:50 <Berengal> ivanm: Otherwise, a quick hack I've done a few times is simply to thread a string throughout and print that.
19:39:12 <ivanm> Berengal: hmmm?
19:39:53 <wli> Hmm. This smells ugly.
19:40:00 <Berengal> e.g filter trace p (x:xs) = (trace ++ show x, if p x then ..)
19:40:14 <Berengal> Although that quickly gets boring
19:40:21 <Berengal> You could probably write a monad for it...
19:40:39 <ivanm> Berengal: surely that doesn't typecheck...
19:40:53 <ivanm> @type filter trace
19:40:54 <lambdabot> Not in scope: `trace'
19:41:00 <ivanm> @type filter Debug.trace.trace
19:41:01 <lambdabot> Couldn't find qualified module.
19:41:03 <ivanm> @type filter Debug.Trace.trace
19:41:04 <lambdabot>     Couldn't match expected type `Bool' against inferred type `a -> a'
19:41:04 <lambdabot>     Probable cause: `Debug.Trace.trace' is applied to too few arguments
19:41:04 <lambdabot>     In the first argument of `filter', namely `Debug.Trace.trace'
19:41:05 <Berengal> ivanm: it does if you're redefining filter...
19:41:10 <ivanm> Berengal: heh
19:41:53 <ivanm> I'd rather have it write to file, rather than stderr (though I can always redirect it at the command line...)
19:42:16 <Berengal> ivanm: Redirecting at the command line is probably the best way
19:43:02 <Berengal> Or you could try a logging monad, which threads the strings implicitly...
19:46:06 <aLegendaryPengui> whats the point of point free programming
19:46:12 <monochrom> haha
19:46:39 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
19:47:26 <aLegendaryPengui> lol
19:48:23 <wli> http://wli.pastebin.com/m61ac91c8 <-- extremely naive implementation, but anyway.
19:49:25 * wli has forgotten what he wanted it for.
19:52:50 <aLegendaryPengui> monochrom why is there sarcasm tags around that
19:53:09 <aLegendaryPengui> do people really write code like that
19:56:08 * centrinia writes pointless functions all the time.
19:56:22 <aLegendaryPengui> lol
19:57:22 <Gracenotes> POINTLESS RAINBOW POWER
19:57:39 <aLegendaryPengui> like
19:57:44 <aLegendaryPengui> cant you write anything like that or no
19:57:50 <aLegendaryPengui> ??
19:59:38 <BMeph> monochrom: Have you given that link to slava? :)
20:00:04 <Gracenotes> you can write lots of stuff with it. how easy.. probably depends on the combinator functions you have at your disposal
20:00:35 <Gracenotes> a difficult part is simulating pattern matching
20:00:49 <Berengal> Also, pointfree programming helps you to think of functions as values.
20:00:51 <Berengal> At least I think so
20:00:53 <BMeph> aLegendaryPengui: Haskellers do it all the time, only they use '.' instead of using '|'. :)
20:00:57 <Gracenotes> for example, using 'if', which isn't pointfree, instead of a bool function
20:01:12 <Gracenotes> which doesn't exist in the libraries
20:01:26 <clanehin> in "Variable occurs more often in a constraint than in the instance head", what exactly is the instance head?
20:01:41 <Berengal> if' p t f = if p then t else f
20:01:57 <Gracenotes> it's extremely difficult to write pointfree code with triples without having accessors, like fst3, snd3, thd3
20:02:05 <BMeph> Gracenotes: That's one decision of the Collective that I feel Bites us on the big fat arse, now that Haskell's starting to get popular. :\
20:02:28 <wli> Gracenotes: typeclasses for fst, snd, etc. work.
20:02:55 <Gracenotes> and thd3?
20:03:12 <BMeph> Gracenotes: The decision of having constructs in the language that mimic Algol/C-style programs, some of which *almost* work the same way... :\
20:03:19 <Gracenotes> (,) is just one example; really, undoing constructors is overall difficult
20:03:21 <wli> class Fst t t' where fst :: t -> t' ; instance Fst (t, t') t where fst (x, _) = x
20:03:25 <Gracenotes> records make this easier
20:03:37 <centrinia> :t let (|) = flip (.) in filter (isPrefixOf "X-Spam-Level") | sort | nub | length
20:03:39 <lambdabot> parse error on input `|'
20:03:40 <Gracenotes> but it's still annoying
20:03:44 <wli> Maybe some kind of fundep or AT is needed.
20:04:00 <BMeph> wli: Darn, I was just about to mention that... :)
20:04:05 <centrinia> :t let (|||) = flip (.) in filter (isPrefixOf "X-Spam-Level") ||| sort ||| nub ||| length
20:04:07 <lambdabot> [[Char]] -> Int
20:04:20 <wli> @type (Control.Arrow.|||)
20:04:21 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
20:04:36 <centrinia> @type (||||)
20:04:37 <lambdabot> Not in scope: `||||'
20:04:39 <wli> (i.e. infix either generalized to arrows)
20:06:06 <Berengal> :t let if' p t f = if p then t else f in if' <$> (<3) <*> (*2) <*> subtract 1
20:06:07 <lambdabot> forall a. (Ord a, Num a) => a -> a
20:06:25 <Berengal> > let if' p t f = if p then t else f in (if' <$> (<3) <*> (*2) <*> subtract 1) 2
20:06:26 <lambdabot>   4
20:06:34 <Berengal> > let if' p t f = if p then t else f in (if' <$> (<3) <*> (*2) <*> subtract 1) 5
20:06:35 <wli> I feel like my reduction is incomplete.
20:06:35 <lambdabot>   4
20:07:02 <Gracenotes> <3
20:08:08 <roconnor> > (<3) 4
20:08:09 <lambdabot>   False
20:08:21 <Berengal> @let icecream = (<3)
20:08:22 <lambdabot>  Defined.
20:08:22 <wli> For instance, that code reduces s^4+c^4+d^4 mod {s^2+c^2-1,d^2+s^2/2-1} as -9*s^4 - 4*d^2 - 4*c^2 + 6*s^2
20:08:30 <roconnor> I thought it was a heart
20:08:38 <Berengal> So does everyone
20:08:38 <Gracenotes> it is!
20:08:42 <wli> I would expect -9*s^4 + 12*s^2 - 8
20:08:43 <Gracenotes> <3
20:08:47 <Berengal> Which is why I need to correct them ;)
20:09:16 <Gracenotes> ur rong, intarnet person!!
20:09:21 <Berengal> > until icecream (flip div 2) 16
20:09:22 <wli> This being grlex/grevlex.
20:09:22 <lambdabot>   2
20:09:31 <Gracenotes> ppl, <3 is luv
20:09:46 <Berengal> Everyone luvs icecream
20:09:47 <Gracenotes> i think we can all agree icecream is awesum but <3 isn't it
20:09:58 <Berengal> <3 isn't awesome?
20:09:59 <Gracenotes> @vixen don't you think that <3 is love???
20:09:59 <lambdabot> good question
20:10:10 <Gracenotes> @vixen don't tease
20:10:10 <lambdabot> i would never tease you
20:10:13 <centrinia>  <))) might be it. :)
20:10:14 <Berengal> Fine...
20:10:22 <Berengal> @let luv = (<3)
20:10:23 <lambdabot>  Defined.
20:10:31 <Adamant> <3 is love, baby don't hurt me, baby don't hurt me, anymore
20:10:34 <Gracenotes> @vixen r u lying
20:10:34 <lambdabot> i'm being totally honest
20:10:43 <wli> Basically once it can no longer make progress on the lead term, I'd expect one to pull off the lead term and reduce the rest.
20:10:49 <Gracenotes> @vixen send pix?
20:10:49 <lambdabot> No pic, sorry
20:10:53 <aLegendaryPengui> im trying to write mygroup, but it says something about infinite types..
20:11:03 <centrinia> @vixen asl plz?
20:11:03 <lambdabot> 19/f/California
20:11:21 <Gracenotes> aLegendaryPengui: it's like a type mismatch for infinite variables.
20:11:26 <Gracenotes> I mean, for polymorphic variables
20:12:34 <Berengal> i get this weird feeling from scala... On one hand it's not as awesome as haskell, but on the other hand it's much better than java.
20:12:39 <aLegendaryPengui> thats weird to write isnt it?  group with fold
20:12:45 <Berengal> However, on the gripping hand, I probably can't use it at work anyway...
20:13:27 <Gracenotes> what language model is Scala?
20:13:55 <Berengal> functional and object oriented
20:13:56 <Gracenotes> Yet Another Functional Programming Language? A mix like Ruby? Extremely imperative?
20:14:01 <centrinia> > let "Java" < "Scala" = True; "Scala" < "Haskell" = True; "Java" < "Haskell" = True; _ < _ = False in ("Haskell" < "Scala","Java" < "Haskell")
20:14:03 <lambdabot>   (False,True)
20:14:14 <aLegendaryPengui> they should make a semantic programming language
20:14:27 <Gracenotes> Berengal: so like Ruby, you'd say?
20:14:42 <Berengal> Gracenotes: Except with static types and stuff...
20:14:55 <Berengal> I've just started looking at it though
20:15:02 <Gracenotes> oh, I see! Are they manifest?
20:15:09 <Berengal> Partly
20:15:37 <Berengal> The inference engine can't infer everything
20:15:58 <Berengal> It also got rid of the damned semicolon... Linebreak ftw
20:16:58 <clanehin> Also, is it just me, or does type equality, as in ~, against anything other than a concrete type pretty much requires UndecidableInstances?
20:17:16 <gwern> Berengal: whoa! you used 'on the gripping hand'!
20:17:29 <gwern> that's an idiom I've only ever seen in a wikipedia article on the idiom
20:17:31 <aLegendaryPengui> @src groupBy
20:17:32 <lambdabot> groupBy _  []       =  []
20:17:32 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:17:32 <lambdabot>     where (ys,zs) = span (eq x) xs
20:17:37 <aLegendaryPengui> wtf thats much easier
20:17:39 <Berengal> gwern: It's a nice hand to have when you've used two already
20:17:43 <ray> it's one of those completely made up eric raymond things
20:17:50 <gwern> ray: not even close
20:18:08 <gwern> (it was made up by niven and pournelle)
20:18:12 <aLegendaryPengui> how can I do this with fold? http://pastebin.com/d25c8ca17
20:18:19 <ray> well, yeah
20:18:27 <ray> i mean eric raymond claimed it was widely used
20:18:34 <Gracenotes> whoa :x
20:18:35 <wli> Okay, I wrote a crush function that does that.
20:18:47 <gwern> Gracenotes: did you suddenly see the matrix?
20:19:04 <aLegendaryPengui> lawrence fishburn
20:19:06 <ray> worse, he saw linear algebra
20:19:06 <Gracenotes> like, no...
20:19:15 <Gracenotes> but I mean, whoa.
20:20:19 <wli> gwern: No, but I saw its eigenvalues. ;)
20:20:26 <gwern> kinky
20:21:09 <Gracenotes> once I inverted a matrix with a determinant of 0
20:21:25 <Gracenotes> it was a cool story... my friends and I took pics, but we lost them
20:21:42 <Gracenotes> well. not really.
20:21:48 <LeoD> i almost believed you :O
20:22:53 <Gracenotes> yeah, it's a great story for Bacchanalian revelries
20:27:24 <Berengal> > let groupby p = foldr (\a b -> if null b then [[a]] else if p a (head (head b)) then (a:head b):tail b else [a]:b) [] in groupby [1,1,1,1,2,3,3,3,2,2,3,3,4,4,4,4]
20:27:25 <lambdabot>   Couldn't match expected type `a -> a -> Bool'
20:27:38 <Berengal> > let groupby p = foldr (\a b -> if null b then [[a]] else if p a (head (head b)) then (a:head b):tail b else [a]:b) [] in groupby (==)[1,1,1,1,2,3,3,3,2,2,3,3,4,4,4,4]
20:27:39 <lambdabot>   [[1,1,1,1],[2],[3,3,3],[2,2],[3,3],[4,4,4,4]]
20:31:36 <Apocalisp> is there such a thing as cokleisli composition?
20:32:47 <jackdaw> cholesky?
20:33:17 <dibblego> (Comonad m) => (m b -> a) -> (m c -> b) -> m c -> a seems plausible
20:33:20 <Gracenotes> it there were, it would look like.. (w a -> b) -> (w b -> c) -> w a -> c,
20:33:23 <Gracenotes> I'd wager
20:33:34 <Gracenotes> :o
20:33:49 <Gracenotes> dibblego got first post!
20:35:18 <Apocalisp> I'll go with dibblego's. Looks legit.
20:35:33 <Apocalisp> @hoogle  (Comonad m) => (m b -> a) -> (m c -> b) -> m c -> a
20:35:33 <lambdabot> Warning: Unknown class Comonad
20:35:34 <lambdabot> No results found
20:35:37 <Apocalisp> heh
20:36:11 <Gracenotes> Apocalisp: ..mine is the same thing :) with arguments flipped, tho.
20:36:38 <wli> Something to parse and pretty print multivariate polynomials might help here.
20:37:08 * Gracenotes wonders which is 'more' correct
20:37:14 <Gracenotes> @type (>>>)
20:37:15 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
20:37:42 <Gracenotes> (b ~> c) -> (c ~> d) -> (b ~> d)
21:03:05 <wli> http://wli.pastebin.com/m7e434a92 <-- crush is the nicer reduction function
21:28:19 <mmorrow> mmorrow  11442  0.1  0.0 224368  5040 pts/2    Sl+  Mar17  65:33 ./lunabot +RTS -N8 -RTS
21:28:26 <mmorrow> 1 month up!
21:31:02 <wli> mmorrow: Impressive.
21:31:57 <wli> Somehow this ends up doing it all in some elimination order or some such.
21:56:42 <fi3uyhfb> !tutorial
21:57:18 <jmcarthur> @lyah
21:57:19 <lambdabot> Unknown command, try @list
21:57:24 <jmcarthur> @where lyah
21:57:24 <lambdabot> www.learnyouahaskell.com
21:57:27 <jmcarthur> @where rwh
21:57:28 <lambdabot> is http://www.realworldhaskell.org/blog/
21:57:32 <fi3uyhfb> @tutorial
21:57:33 <lambdabot> Unknown command, try @list
21:58:13 <aLegendaryPengui> @where metroid
21:58:14 <lambdabot> I know nothing about metroid.
21:58:16 <aLegendaryPengui> how can i add an entry
21:59:46 <Cale> @help where+
21:59:47 <lambdabot> where+ <key> <elem>. Define an association
22:05:39 <fi3uyhfb> I've never done functional before...
22:05:41 <fi3uyhfb> ><
22:06:02 <fi3uyhfb> should I read lyah or RWH first?
22:06:44 <pumpkin> lyah, then RWH
22:06:48 <fi3uyhfb> ok
22:06:49 <fi3uyhfb> thanks
22:08:49 <aLegendaryPengui> @src seq
22:08:49 <lambdabot> Source not found.
22:08:52 <aLegendaryPengui> you fool!
22:09:16 <aLegendaryPengui> @source seq
22:09:16 <lambdabot> seq not available
22:10:06 <aLegendaryPengui> what does seq look like
22:10:20 <ray> it looks like seq
22:10:26 <pumpkin> you can't really write it in regular haskell
22:10:29 <ray> it's magic
22:10:40 <pumpkin> you could maybe make a seq'able typeclass
22:11:10 <pumpkin> but seq saves you the effort :P
22:11:11 <aLegendaryPengui> lol
22:12:13 <BMeph> pumpkin: ...for when you're in a hurry to have seqs? ;p
22:12:19 <pumpkin> yup
22:12:24 <lpsmith> seq isn't *that* magical:  you can force evaluation using pattern matching,  but it won't be polymorphic in what you want to force
22:12:34 <BMeph> So, when *aren't you in such a hurry? ;p
22:12:46 <lpsmith> And there are a few things you can do with seq that you can't do with pattern matching.
22:14:38 <ray> here's a demented function: safePerformIO a = (unsafePerformIO a) `seq` ()
22:14:46 <aLegendaryPengui> what does this mean? strictList (x:xs) = x `seq` x : strictList xs
22:15:12 <pumpkin> ray: how does that make it safe?
22:15:25 <ray> it doesn't
22:15:30 <pumpkin> oh, ok :)
22:15:51 <aLegendaryPengui> x seq x isnt that dumb
22:16:00 <pumpkin> it just doens't do anything
22:16:08 <pumpkin> that's x `seq` (x : strictList xs)
22:16:22 <aLegendaryPengui> why
22:16:49 <aLegendaryPengui> what if its not a simple type
22:17:06 <aLegendaryPengui> doesnt seq only evaluate its second argument or something
22:17:10 <BMeph> aLegendaryPengui: It forces the spine. That is the right Haskell-babble phrase, right? ;p
22:17:17 <aLegendaryPengui> i dont know
22:17:22 <ray> seq evaluates both but only returns the second
22:17:42 <aLegendaryPengui> whats wrong with the one i wrote
22:17:56 <BMeph> ray: Unless the first one is bottom, then it doesn't eval the second. ;)
22:18:13 <ray> kaboom
22:18:38 <aLegendaryPengui> what if you give it (1 + 2) : (3 + 4)
22:18:45 <aLegendaryPengui> (1 + 2) : (3 + 4) : []
22:18:59 <BMeph> ray: "Any sufficiently advanced programming language is equivalent to Haskell." ;)
22:19:38 <ray> any sufficiently advanced haskell is.. something
22:19:44 <pumpkin> agda
22:19:54 <aLegendaryPengui> a thunk?
22:19:56 <BMeph> Now there's a nice tag line: "Haskell - it's 'sufficiently advanced!'" ;)
22:19:57 <aLegendaryPengui> yeah
22:20:14 <aLegendaryPengui> any sufficiently advanced haskell is a thunk
22:20:21 <aLegendaryPengui> that has a good ring
22:20:31 <BMeph> Who'd'a thunk that? ;p
22:21:03 <aLegendaryPengui> any sufficiently advanced haskell is pointless
22:21:07 <BMeph> Haskell' should have Futures built-in, and called "first-class thunks". ;)
22:22:25 <ray> i like to think of haskell' as being approached asymptotically, but someone'll probably ruin that for me :(
22:22:37 <aLegendaryPengui> stop crying
22:22:44 <aLegendaryPengui> watch :)
22:22:45 <aLegendaryPengui> see
22:23:07 <hydo> heh
22:23:26 <aLegendaryPengui> i should type those more often
22:25:01 <mmorrow> , let x = 1 + 1 in [isFullyEvaluated x, x `seq` isFullyEvaluated x]
22:25:03 <lunabot>  [False,True]
22:27:21 <mmorrow> , let bang a k = let !x = a in k x in let x = 1 + 1 in [isFullyEvaluated x, bang x isFullyEvaluated]
22:27:23 <lunabot>  [False,True]
22:27:43 <mmorrow> heh
22:27:50 <mmorrow> , let bang !a k = k a in let x = 1 + 1 in [isFullyEvaluated x, bang x isFullyEvaluated]
22:27:52 <lunabot>  [False,True]
22:28:34 <mmorrow> , let bang a k = a `seq` k a in let x = 1 + 1 in [isFullyEvaluated x, bang x isFullyEvaluated]
22:28:36 <lunabot>  [False,True]
22:28:59 <mmorrow> @src ($!)
22:28:59 <lambdabot> f $! x = x `seq` f x
22:29:04 <pumpkin> :t let f x = x x in f
22:29:05 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
22:29:05 <lambdabot>     Probable cause: `x' is applied to too many arguments
22:29:05 <lambdabot>     In the expression: x x
22:29:10 <pumpkin> boo
22:29:20 <mmorrow> @pl (\x -> x x) (\x -> x x)
22:29:24 <lambdabot> ap id id (ap id id)
22:29:24 <lambdabot> optimization suspended, use @pl-resume to continue.
22:29:28 <mmorrow> @pl-resume
22:29:34 <lambdabot> ap id id (ap id id)
22:29:34 <lambdabot> optimization suspended, use @pl-resume to continue.
22:29:37 <mmorrow> ooh
22:29:42 <pumpkin> it got stuck :o
22:30:55 <mmorrow> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
22:30:56 <lambdabot> ap (. join id) (. join id)
22:31:49 <mmorrow> @type let y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z in y
22:32:02 <mmorrow> !!
22:32:12 <mmorrow> @type let y f = let z x = f (unsafeCoerce x x); {-# NOINLINE z #-} in z z in y
22:32:21 <pumpkin> lol
22:32:22 <lambdabot> Not in scope: `unsafeCoerce'
22:32:22 <mmorrow> hmm
22:33:38 <lpsmith> is the @pl command for Pure untyped Lambda calculus?
22:34:03 <mmorrow> lpsmith: do you mean input or output?
22:34:22 <lpsmith> umm,  both-ish?
22:34:56 <mmorrow> i guess it's something like (untyped lambda calc -> some combinator thing)
22:35:25 <mmorrow> id,fix,ap,liftM(2),(.),concat,flip
22:35:30 <lpsmith> indeed
22:35:32 <mmorrow> and maybe others
22:39:19 <lpsmith> Of course,  a nice trick with self-application is to convert any recursive definition to one that uses self-application.
22:40:58 <lpsmith> @pl  (\fact n -> if n == 0 then 1 else n * fact fact (n-1))  (\fact n -> if n == 0 then 1 else n * fact fact (n-1)) 6
22:41:02 <lambdabot> (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) 6
22:41:02 <lambdabot> optimization suspended, use @pl-resume to continue.
22:41:10 <lpsmith> @pl-resume
22:41:17 <lambdabot> (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) 6
22:41:17 <lambdabot> optimization suspended, use @pl-resume to continue.
22:41:23 <lpsmith> ack
22:41:28 <lpsmith> that's going to take too long
22:41:37 <lpsmith> @pl-resume
22:41:50 <lambdabot> (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) (ap (flip (if' . (== 0)) 1) . ap (*) . flip ((.) . ap id id) (subtract 1)) 6
22:41:51 <lambdabot> optimization suspended, use @pl-resume to continue.
22:42:12 <lpsmith> ?help @pl
22:42:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
22:42:17 <lpsmith> ?help pl
22:42:18 <lambdabot> pointless <expr>. Play with pointfree code.
22:42:40 <lpsmith> ahh
22:42:43 <lpsmith> hmm
22:42:49 <lpsmith> ?help pl-resume
22:42:50 <lambdabot> pl-resume. Resume a suspended pointless transformation.
22:43:24 <lpsmith> ?list
22:43:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:44:08 <lpsmith> we need a pl-resume-star or some such command
22:45:50 <lpsmith> @pl 3 * 5
22:45:51 <lambdabot> 15
22:46:12 <lpsmith> @pl x * y
22:46:13 <lambdabot> x * y
22:46:27 <lpsmith> @pl \x y -> x * y
22:46:28 <lambdabot> (*)
22:46:38 <lpsmith> @pl \x -> (* x)
22:46:39 <lambdabot> (*)
22:46:47 <lpsmith> hmm
22:46:48 <lpsmith> that's wrong
22:47:32 <lpsmith> apparently @pl doesn't handle sections properly
22:47:51 <lpsmith> or maybe it's making use of commutivity?  I doubt it...
22:48:00 <lpsmith> @pl \x -> (++ x)
22:48:02 <lambdabot> flip (++)
22:48:05 <lpsmith> ok
22:48:15 <lpsmith> So my hunch was wrong
22:48:44 <mmorrow> lpsmith: you should check out the @pl code, it's pretty interesting
22:49:34 <lpsmith> mmorrow:  indeed
22:49:38 <mmorrow> it's in http://code.haskell.org/lambdabot/ in the Plugins/Pl dir
22:49:39 <ddarius>  @pl unsoundly uses certain identities such as commutativity of addition.
22:50:15 <mmorrow> @pl \xs -> [x | x <- xs ]
22:50:16 <lambdabot> return . ((x | x) <-)
22:50:19 <mmorrow> heh
22:50:20 <lpsmith> lol,  well,  any reasonable instance of the Num class should have commutative (+)
22:50:21 <pumpkin> lol
22:50:35 <lpsmith> and once you go pointfree,  it's easy to say  flip (*) == (*)
22:50:43 <ddarius> lpsmith: I can think of instances that don't that are reasonable.
22:51:20 <mmorrow> @check \x y z -> (x+y)+z == x+(y+z::Double)
22:51:28 <lambdabot>   mueval: Time limit exceeded
22:51:40 <pumpkin> aw
22:51:43 <mmorrow> @check \x y z -> (x+y)+z == x+(y+z::Double)
22:51:49 <lambdabot>   "Falsifiable, after 5 tests:\n2.333333333333333\n-2.0\n0.6\n"
22:52:18 <lpsmith> ddarius:   what,  like the dihedral groups?  :-D
22:52:30 <pumpkin> we can't even assume associativity!!
22:52:34 <pumpkin> let alone commutativity :P
22:52:34 <mmorrow> heh
22:52:59 * pumpkin revokes the monoid instance
22:53:35 <lpsmith> hahaha,  yes.   However floats are commutative,  just not associative.
22:53:49 <pumpkin> you sure?
22:53:55 <pumpkin> I vaguely remember them not being
22:54:03 <lpsmith> only 85% sure
22:54:16 <lpsmith> I really should take a formal numerical analysis class
22:54:18 <pumpkin> ah, wikipedia says it
22:54:22 <mmorrow> yeah they're commutative
22:54:25 <pumpkin> so it must be true
22:54:43 <lpsmith> hahaha,  yes, because Wikipedia is a primary resource :-P
22:54:58 <mmorrow>  @check with Double is amusing
22:54:58 <pumpkin> yup!
22:55:18 <mmorrow> @check \x -> x == (x+pi)-(pi::Double)
22:55:29 <lambdabot>   "Falsifiable, after 14 tests:\n1.3333333333333333\n"
22:55:46 <pumpkin> nice
22:57:15 <lpsmith> hmm,  how is @check generating random floats?
22:57:38 <pumpkin> ratios it looks like
22:57:41 <lpsmith> After all,  the effectiveness of a quickcheck type test depends a lot on the nature of the test,  and the nature of the generator
22:58:09 <lpsmith> My favorite counterexample to quickcheck is project euler problem #54
22:58:39 <lpsmith> which asks you to build a function that chooses the winner from two five-card hands of poker
22:59:23 <lpsmith> stern-brocot tree, maybe?
23:01:17 <lpsmith> And most of the solutions posted in the answer forum for #54 are flawed.
23:02:04 <pumpkin> I don't think I've done that one
23:02:41 <thoughtpolice> oh look a pumpkin
23:02:49 <pumpkin> zomg
23:02:52 <pumpkin> where?
23:03:12 <mmorrow> thoughtcrime!
23:03:21 * pumpkin eats awesome chocolate
23:04:22 * BMeph grabs some of the chocolate, and melts is down into awesome sauce!
23:04:26 <pumpkin> sooo I'm done with my paper deadline
23:04:41 <pumpkin> now, TAPL or one of the haskell projects I'm working on?
23:05:05 * BMeph meant 'melts it', but is coherent typing-challenged...
23:05:18 <pumpkin> don't melt this one
23:05:19 <pumpkin> it's expensive
23:05:41 <BMeph> pumpkin: But it'll still be awesome... ;)
23:06:04 <lpsmith> heh,  I've tried reading TAPL
23:06:07 <lpsmith> I get lost
23:06:18 <lpsmith> I mean,  I apply type theory all the time
23:06:31 <lpsmith> It's ingrained in me,  on a deep level.
23:06:49 <lpsmith> But I seem to have this weird hangup that I need a mental model to hold onto.
23:07:22 <lpsmith> So studying type theory itself has been the bane of my existence.   Although I would very much like to get over my hangups somehow
23:07:36 <pumpkin> aw
23:07:44 * pumpkin hypnotizes lpsmith
23:08:28 <lpsmith> lol,  if only :-)
23:10:02 <Cale> I find that type theory is mostly hard to study because while there are a fair number of decent theorems, most of them are not terribly surprising or exciting things. They seem to be mostly things which you would really want to have hold, or else your system would suck.
23:10:24 <lpsmith> Yes,  I think that's part of it too
23:10:36 <Cale> And the method of proof is almost always structural induction.
23:10:38 <lpsmith> I don't get why the theorems are interesting or useful
23:10:48 <lpsmith> Which I use,  a lot,  almost to a fault.
23:10:49 <ddarius> lpsmith: Just ignore most of the proofs/theorems, that's what most type theorists do.
23:10:52 <pumpkin> I just want to get a feel for the topic, not necessarily learn it by heart
23:12:30 <pumpkin> in other news, the awodey book reappeared at my lib, so I'll go pick it up soon :D
23:12:37 <ddarius> lpsmith: Most of the theorems aren't interesting and aren't particularly useful.  They are mostly hygienic, i.e. it's useful to know that they hold so that you know that your type system isn't completely broken.
23:12:41 <Cale> I guess most of the theorems are really things which I would call propositions.
23:13:01 <lpsmith> hmm
23:13:13 <lpsmith> well, I'll admit I have the same issues with logic.
23:13:17 <Cale> (My use of the word proposition is that it's a theorem which if it failed, you'd go back and change your definitions)
23:13:35 <ddarius> Odd definition of "proposition."
23:13:52 * pumpkin propositions Cale
23:13:54 <pumpkin> oh wait
23:14:25 <lpsmith> That one I literally lol'ed at.
23:14:37 <Cale> haha
23:15:17 <Cale> Well, really it's interchangeable with 'theorem' normally, I think.
23:15:27 <Cale> But that's how I tend to use it, anyway.
23:15:54 <lpsmith> Heh.  Zeilberger says that lemmas are not infrequently more important than theorems.
23:16:02 <Cale> Oh, sure.
23:16:02 <mmorrow> i like that def of proposition
23:16:48 <lpsmith> yeah,  it's an interesting definition
23:17:00 <mmorrow> propositions are like the first however many lines of a module where you're writing the utility/plumbing functions for the datatypes you just defined
23:17:13 <lpsmith> yes
23:17:29 <Hasbro> my apologies
23:17:55 <aLegendaryPengui> this sucks, i downloaded some old game and it wont run on vista
23:18:12 <aLegendaryPengui> its like, the DOS sucks or something
23:20:15 <wli> I'm trying to figure out how to simplify nested radicals. Argh.
23:21:23 <wli> Basically pretending I don't know where (2^(1/5)+1)^7 came from and then trying to smoke out how to take its 7th root.
23:22:38 * mmorrow shudders
23:22:51 <lpsmith> Hmm... that would be much easier to simplify mod 7 :-P
23:23:10 <wli> It's over Q(2^(1/5))
23:23:48 <wli> Thus far I think I have that the field automorphisms required to compute the norm require fifth roots of unity to be floating around somewhere.
23:24:51 <wli> (I think it's 35*2^(4/5) + 35*2^(3/5) + 23*2^(2/5) + 21*2^(1/5) + 43 but it's my own code that computed that vs. a real CAS.)
23:25:19 <lpsmith> hmm... but mod 7,  could you really justify division like that,  or would the algebraic properties break down?
23:26:12 <wli> lpsmith: I think the last time I choked on this things boiled down to something to do with p-adic fields where p-th roots were being taken.
23:26:42 <lpsmith> we,  you've definitely gone over my head there.
23:26:44 <lpsmith> Although
23:27:10 <wli> Well, I didn't understand it the last time I dealt with it.
23:27:13 <lpsmith> I'm told that p-adic analysis makes my best theorem I've discovered and proved myself to date "obvious to the experts"
23:27:20 <lpsmith> even though it might not explicitly appear in literature
23:28:36 <lpsmith> well, your answer agrees with Mathematica on this count... so that's a good sign
23:28:40 <lpsmith> or at least, it's not a bad sign
23:29:04 <wli> lpsmith: Does Mathematica say anything interesting for (35*2^(4/5) + 35*2^(3/5) + 23*2^(2/5) + 21*2^(1/5) + 43)^(1/7) ?
23:29:12 <lpsmith> I'm not a big fan of Mathematica,  but it's quite useful every now and then.
23:29:46 <wli> There we go. I've got Maple back. It doesn't simplify it.
23:30:52 <mmorrow> wli: have you ever used macaulay? i've meant to try it but've never got around to it
23:31:16 <wli> No, but it sounds interesting.
23:32:03 <lpsmith> well,  maybe there is a way to simplify it if I knew mathematica better
23:32:05 <lpsmith> but
23:32:09 <lpsmith> all it gives me iis
23:32:26 <lpsmith> Root[-3 + 5 #1 - 10 #1^2 + 10 #1^3 - 5 #1^4 + #1^5 &, 1]
23:32:29 <lpsmith> whatever that means
23:32:48 <wli> lpsmith: It doesn't simplify it.
23:34:20 <ddarius> > 11 * 0.6
23:34:21 <lambdabot>   6.6
23:34:59 <wli> mmorrow: I hammered out some dumb, comprehensible, standalone Grobner code a few hours ago.
23:35:14 <lpsmith> wli:  the thing I don't like about Mathematica and most CAS, for that matter,  is just the lack of discipline and rigor.
23:35:24 <lpsmith> Nice
23:35:31 <ddarius> > 11.4 * 0.62
23:35:32 <lambdabot>   7.0680000000000005
23:35:46 <mmorrow> wli: cool
23:36:18 <lpsmith> WLI:  Have you ever played with DoCon?   I've messed with it briefly,  but not enough to make heads or tails of it.
23:36:36 <wli> lpsmith: Yeah, it was kind of hard for me to deal with.
23:36:37 <lpsmith> And last I tried,  the documentation looked rather sparse and obtuse.
23:37:04 <lpsmith> I tried ages ago though... probably back around 2001
23:37:13 <lpsmith> I dunno if anything's changed since.
23:38:02 <wli> mmorrow/lpsmith: http://wli.pastebin.com/m4b503c4f
23:38:02 <Cale> > 11.4 * 0.62 :: CReal
23:38:04 <lambdabot>   7.068
23:38:06 <lpsmith> Yes, the sad part is that grobner bases make more sense to me than type theory.
23:38:49 <wli> They're not that hard.
23:40:24 <lpsmith> sigh,  it's been a while since I've played with grobner bases.
23:40:54 <wli> What I'm hoping to (eventually) do is to track artificially introduced anonymous variables for representing algebraic extensions of the field of constants, and then the rest track algebraic extensions of the multivariate rational function field, so eventually some sort of mappings back and forth between things need to happen.
23:41:24 <wli> That is, between variable names and internal variable indices.
23:41:46 <wli> Either Int Char might've been a wiser choice.
23:42:28 <Cale> I should really go over Groebner bases again at some point too. They seem more interesting a concept after learning a bit of algebraic geometry, but I studied them in my rings and fields course before that.
23:44:01 <wli> Cale: There's nothing to them, seriously. Just do multivariate remainders, then keep forming syzygy polynomials and reducing them and adjoining them to the set until convergence sets in.
23:44:11 * mmorrow is browsing around http://www.math.uiuc.edu/Macaulay2/
23:44:24 <lpsmith> I mostly studied them on my own,  because I was interested in coming up with a perfectly robust and efficient solution to finding the points of intersection of two arbitrary bezier curves
23:44:34 <lpsmith> I wasn't particularly successful thouhg
23:44:55 <lpsmith> lol,  nothing to them :-)
23:45:11 <lpsmith> they aren't that bad,  but I didn't get to understand them as well as I probably should
23:46:01 <lpsmith> I worked a couple problems by hand,   and thought about the properties which seemed intuitive enough, but I've since forgotten
23:46:02 <fed2black> hi guys
23:46:16 <mmorrow> wli: interesting (just looked at your paste)
23:46:29 <fed2black> i was wondering if anyone knows a good free ebooks that teaches haskell
23:46:33 <lpsmith> no grevlex ordering ;-)
23:47:22 <Cale> fed2black: "Real World Haskell" is available online for free, but it does move a little bit quickly. You might want to pair it with a tutorial like "Learn You A Haskell"
23:47:39 <Cale> @where rwh
23:47:40 <lambdabot> is http://www.realworldhaskell.org/blog/
23:47:47 <Cale> @where lyah
23:47:47 <lambdabot> www.learnyouahaskell.com
23:48:25 <fed2black> thanks you all
23:48:30 <Cale> @where+ rwh http://book.realworldhaskell.org/read/
23:48:31 <lambdabot> Done.
23:48:33 <lpsmith> fed2black:  if you can check out a copy of Introduction to Functional Programming using Haskell,  by Richard Bird,  from your local library I definitely recommend that as well
23:48:35 <Cale> @where rwh
23:48:36 <lambdabot> http://book.realworldhaskell.org/read/
23:48:38 <Cale> okay :)
23:48:51 <Cale> (that's probably a more useful link to have :)
23:49:15 <Cale> fed2black: There's also the wikibook
23:49:19 <Cale> @where wikibook
23:49:20 <lambdabot> http://en.wikibooks.org/wiki/Haskell
23:49:22 <fed2black> ok...i'll visit these sites...in addition as lpsmith suggested - i will check the library
23:49:27 <fed2black> 10x Cale
23:49:35 <lpsmith> Bird's book is a great introduction to structural induction,  although I don't particularly like the code examples.
23:50:01 <lpsmith> by and large.  The more applied the code is,  the less I agree with Bird on form and content...
23:50:01 <Cale> Oh yeah, and while at the library, maybe also see about Graham Hutton's book
23:50:12 <fed2black> :)
23:50:14 <Cale> It's supposed to be rather good for beginners.
23:50:26 * ddarius would like to read Algebra of Programming some time.
23:50:31 <lpsmith> Yes,  that looks great.  I'm definitely a fan of Hutton's papers,  but I haven't looked at his book yet.
23:50:50 <fed2black> btw, i am running arch-linux as my os. what compiler should i use? ghci?
23:50:59 <Cale> Yeah, ghc/ghci
23:51:04 <fed2black> 10x
23:51:25 <Cale> ghci is the interactive environment, ghc is the compiler proper
23:52:04 <lpsmith> The nice thing about GHCi is that you can easily compile a module using GHC,  and then pull it up interactively in GHCi
23:52:22 <Cale> That's nice, but sometimes also annoying :)
23:52:26 <lpsmith> compiled code tends to be much faster,   sometimes by orders of magnitude depending on what you ard doing.
23:52:30 <Cale> yeah
23:52:47 <lpsmith> I tend to do that a lot.   I have code I use that as a practical matter,  *must* be compiled.
23:53:41 <lpsmith> and more to the point,  must be compiled -O for the strictness analysis
23:54:02 <wli> Hmm, I guess I don't reduce the Grobner basis as is usually expected.
23:54:44 <lpsmith> wli:  are you working from Ideals,  Varieties, and Algorithms,  or something else?
23:54:56 <Cale> wli: Well, that's a really procedural definition you gave. I think I'd like to understand them better in terms of the properties they have.
23:55:02 <wli> lpsmith: For Buchberger? Memory.
23:55:21 <lpsmith> wli:  sweet.
23:56:26 <lpsmith> Never quite got to the point that the algorithms were ingrained in me.
