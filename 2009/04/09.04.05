00:00:48 <zakwilson> Hey! It compiled!
00:00:52 <BMeph> @hoogle something
00:00:53 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
00:00:56 <zakwilson> Thanks, pumpkin.
00:01:21 <wli> zakwlson: sequence_
00:10:09 <BMeph> Does any one know of a package where sum/product have been redefined to take a starting param?
00:10:19 <BMeph> I.e.: sum :: (Num a) => a -> [a] -> a
00:15:00 <Beelsebob> BMeph: why not just cons it onto the front of the list?
00:18:22 <ziman> :t foldl' (+)
00:18:24 <lambdabot> forall a. (Num a) => a -> [a] -> a
00:19:31 <BMeph> Baalsebob: No, you don't understand; according to GHCi, that /is/ the definition for sum that I'm stuck with - product, too, I checked.
00:19:38 <mightybyte> @pl (\a b -> compare (f a) (f b))
00:19:38 <lambdabot> (. f) . compare . f
00:20:04 <BMeph> I'm trying to find out why it got redefined, and how I can get it to quit. :\
00:21:27 <ziman> mightybyte, that's (compare `on` f) or (comparing f)
00:22:01 <mightybyte> ziman: Aha.  Now THAT is why I put this in #haskell. :)
00:22:12 <Axman6> :t comparing
00:22:13 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
00:22:39 <ivanm> comparing == compare `on` f ?
00:22:51 <ziman> :t compare `on` ?f
00:22:52 <lambdabot> forall b a. (?f::a -> b, Ord b) => a -> a -> Ordering
00:23:32 * pumpkin 's head explodes
00:23:48 <ivanm> :o didn't know you could do that
00:23:58 <ivanm> what extension or whatever let's you do the ?f stuff
00:24:08 <pumpkin> implicit parameters?
00:24:19 <Beelsebob> BMeph: oh, o.O
00:24:20 <ziman> yes, i think it's ImplicitSomething
00:24:23 <Axman6> @hackage lambdabot-wichcraft
00:24:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdabot-wichcraft
00:24:29 <pumpkin> XImplicitParams
00:25:37 <mightybyte> ziman: There's just so much to learn about haskell libraries.
00:26:15 <BMeph> @hackage pony
00:26:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pony
00:26:38 <BMeph> @hackage pony-1.0
00:26:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pony-1.0
00:26:54 <BMeph> Wonder when 2.0 comes out... ;)
00:27:23 <ivanm> BMeph: isn't dons replacing it with narwhal-1.0 ?
00:28:12 <dolio> Wow, the IntMap in gmap uses a lot of memory.
00:28:36 <ivanm> dolio: the gmap in FGL?
00:29:27 <dolio> gmap, the summer of code project to create a library for general but fast maps.
00:29:39 <ivanm> ahhhh
00:29:58 <ivanm> you mean a Data.Map replacement?
00:30:06 <dolio> Ostensibly.
00:30:17 <dolio> Although I'm not sure how well the library would be for that.
00:30:40 <dolio> In its current state, at least.
00:30:46 <ivanm> isn't the main reason IntMap is recommended over Map because Int's are pretty simple with an easy/efficient comparison?
00:30:54 <ziman> mightybyte, yeah :) Not only the functions, also the abstractions.
00:31:22 <dolio> Data.IntMap is a lot more efficent than Data.Map with Int keys, for various possible reasons.
00:31:44 <dolio> gmap has a Data.GMap.IntMap, but Data.IntMap is apparently significantly more efficient.
00:32:09 <hamishmack> BMeph: Hi, how did you get on with that regex-posix dependancy issue?
00:32:14 <dolio> I tried the Harrop benchmark with both, and Data.IntMap completes in like 10 seconds, and Data.GMap.IntMap makes my computer start swapping.
00:34:42 <ivanm> dolio: "Harrop"? as in the OCaml guy?
00:35:27 <dolio> Yeah. His recently popular benchmark showing that F#'s hashtable is better than Data.HashTable, as if that were new information.
00:38:09 <ivanm> since when did we have a HashTable?
00:38:25 <ivanm> and I thought a HashTable wasn't as useful in functional languages...
00:38:27 <dolio> Quite some time. But it's well known to suck.
00:38:40 <int-e> ivanm: it lives in IO
00:38:45 <ivanm> and even imperative programmers say that a Tree-based structure is better than a HashTable
00:38:48 <ivanm> int-e: ahhh
00:39:12 <int-e> read-only hashtables may actually be useful in a pure functional setting
00:39:35 <pumpkin> perfect ones?
00:39:37 <ivanm> int-e: in what way?
00:41:01 <int-e> Well, they can have better lookup times than trees.
00:43:09 <int-e> ivanm: Basically they need fewer random accesses to memory that will be uncached if the dictionary is large.
00:43:16 <ivanm> *nod*
00:43:45 <Martijn> Good morning
00:43:57 <ivanm> by "read-only", you mean either create it when the program starts and then never touch it again, or else read in a serialised one?
00:44:06 <ivanm> Martijn: Good evening
00:44:13 <Martijn> :-)
00:44:41 <int-e> ivanm: well, the idea is to provide a fromList :: Key a => [(a, b)] -> Hashtable a b.
00:44:55 <ivanm> *nod*
00:45:08 <int-e> (same as the pure arrays in Data.Array really)
00:45:26 <ivanm> but with faster lookup?
00:45:41 <ivanm> and Key has a hash ::a -> Hash function?
00:46:17 <int-e> but with different restrictions on the distribution of keys. (arrays need consecutive keys, or at least very densely packed keys from an enumerable range, after all)
00:46:42 <int-e> ivanm: right.
00:50:29 <jklk> > let e = concat [['"'], a, ['"']] where a = "xyz"
00:50:30 <lambdabot>   <no location info>: parse error on input `;'
00:50:39 <jklk> > concat [['"'], a, ['"']] where a = "xyz"
00:50:41 <lambdabot>   "\"xyz\""
00:51:25 <jklk> how do i turn this expression into a mappable one to loop over a list of strings?
00:52:23 <int-e> \a -> ...
00:52:41 <jklk> sure
00:52:54 <int-e> if you want to be cute, ("\"" ++) . (++ "\"")
00:53:16 <jklk> i LIKE that better
00:54:06 <jklk> thank you
00:54:46 <jklk> was using show, but it also turns all the newlines into \r\n in text, which i had to go back to resubstitute
00:55:47 <brix`> map ("\"" ++) . (++ "\"") ["abc", "def", "ghi"]
00:55:57 <jklk> yup, works like a charm
00:56:08 <int-e> brix`: needs one more pair of ().
00:56:23 <brix`> thought so
00:56:38 <jklk> when using multi-line .   , do you prefer to put the . in the front or at the end of the line?
01:00:00 <Gracenotes> jklk: front, I think
01:00:19 <jklk> i find the front style pleasing too
01:00:50 <Gracenotes> it forms a nice visual line down the code
01:01:16 <brix`> map ( ("\"" ++) . (++ "\"") ) ["abc", "def", "ghi"]
01:01:18 <Gracenotes> although possibly more than one composition per line
01:01:31 <int-e> Gracenotes: do you align the . with the = above? (where applicable)
01:01:31 <Axman6> is there much i can expect to break if i upgrade GHC to 6.10.2?
01:02:08 <jklk> cabal went up to .3 in 6.10.2
01:02:24 <jklk> where as before i had a lot of trouble reinstalling 6.10.1
01:02:24 <Gracenotes> int-e: that would look nice-ish, I think
01:02:44 <int-e> gtk2hs had finalizer problems (fixed in the darcs version)
01:03:22 <int-e> (of gtk2hs that is)
01:04:00 <pumpkin> what's a good way of simulating a foldl1 with a foldl?
01:06:36 <Gracenotes> identity element
01:06:50 <pumpkin> not everything has one
01:07:22 <Gracenotes> taking apart list
01:10:06 <Gracenotes> > let foldl1 f = foldl f <$> head <*> tail in foldl1 (+) [1..5]
01:10:07 <lambdabot>   15
01:10:14 <Gracenotes> :/
01:10:27 <pumpkin> not exactly what I was looking for :P
01:10:32 <Gracenotes> :\
01:10:36 <pumpkin> moving it into Maybe?
01:10:53 <pumpkin> the accumulator?
01:11:10 <Gracenotes> Maybe.
01:11:19 <int-e> > let foldl1 f = fromJust . foldl (\x y -> Just $ maybe y (flip f y) x) Nothing in foldl1 (+) [1..10]
01:11:20 <lambdabot>   55
01:11:35 <int-e> @pl \x y -> Just $ maybe y (flip f y) x
01:11:35 <lambdabot> (Just .) . flip (ap maybe (flip f))
01:11:36 <Gracenotes> right
01:11:48 <int-e> @pl \x y -> (`mplus` Just y) . fmap (flip f y) $ x
01:11:48 <lambdabot> flip (ap ((.) . flip mplus . Just) (fmap . flip f))
01:11:58 <int-e> ugly :)
01:11:58 <Gracenotes> :O
01:12:03 <Gracenotes> :O
01:12:27 <pumpkin> thanks :)
01:12:33 <pumpkin> sort of what I was looking for
01:13:07 <Gracenotes> you and your silly RULES (?)!
01:13:20 <Gracenotes> or is this just for pleasure?
01:13:47 <pumpkin> no rules, just combinators for now
01:13:58 <pumpkin> trying to get it working, but it's quite hard
01:16:08 <int-e> > let uncons (x:xs) = (x,xs); foldl1 f = uncurry (foldl f) . uncons in foldl1 (+) [1..10]
01:16:09 <lambdabot>   55
01:17:05 <int-e> (and note that uncons = head &&& tail)
01:17:06 <pumpkin> that's just hiding what Gracenotes did earlier :P
01:17:22 <pumpkin> can't do that approach easily
01:19:25 <Gracenotes> pumpkin: and don't forget to make a simple YourDataType -> foldl function ;)
01:19:41 <pumpkin> yup, already have one :P
01:20:03 <Gracenotes> good on ya, mate
01:20:15 <pumpkin> I'm getting buried in crazy types though
01:20:48 <Gracenotes> I bet I could get buried in 100 crazy types
01:25:29 <pumpkin> time to call it a night
01:25:37 <pumpkin> I'll play with this more tomorrow
01:26:06 <Raevel> why would cabal not be able to download the x11 package? the link on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11 works
01:27:09 <int-e> Raevel: cabal unpack X11 ... works?
01:27:41 <Raevel> unpack? that gives me "unrecognized command"
01:27:43 <int-e> (note the capital x)
01:28:45 <int-e> hmm. have you downloaded the package index at all? (cabal update)?
01:28:58 <Raevel> yes, just verified that
01:29:50 <Raevel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3319#a3319
01:29:58 <int-e> I don't know when 'unpack' was added, I just use it test fetching single packages without their dependencies.
01:30:49 <Raevel> i have cabal 1.6.0.1 and cabal-install 0.6.0
01:33:11 <Raevel> i got x11 installed by downloading it manually though, so it's not a big deal for me, just thought it was interesting
01:34:54 <Raevel> it works fine on my ubuntu box :-o, but not on os x
01:35:16 <int-e> odd.
01:36:38 <int-e> Raevel: fwiw, 'unpack' was added in cabal-install 0.6.1. 0.6.2 is the current version.
01:38:09 <Raevel> ah okay
01:38:33 <int-e> what else could go wrong ... is there any proxy involved?
01:40:00 <int-e> ... does cabal -v install X11  say anything useful?
01:40:16 <Raevel> now it works
01:40:22 <Raevel> i updated cabal-install
01:41:31 <Raevel> thanks int-e
01:45:52 <Raevel> that's what i get for installing from macports :-/
01:54:14 <mstr> http://pastebin.com/d6730d8f2 any obviuos reasons why this is too slow?
01:57:25 <dolio> Trial division up to the square root of the number in question is, I think, a better algorithm.
01:57:35 <dolio> Trial division by already known primes, that is.
01:59:59 <dolio> Technically that's what yours does, I guess, but that version of it is slow, probably because of repeated building of intermediate cons cells.
02:00:23 <mstr> so the lazyness again?
02:00:35 <dolio> That, and it divides each prime by all primes less than it, rather than all primes less than its square root.
02:01:12 <dolio> No, building intermediate lists would happen in a strict language, as well.
02:01:18 <ttmrichter> Is there some trick to make GHC 6.10.2 compile with editline?
02:01:20 <Dunearhp>     Could not find module `Control.Monad.Trans':
02:01:22 <Dunearhp>       it was found in multiple packages: transformers-0.1.4.0 mtl-1.1.0.2
02:01:46 <Dunearhp> which one do I want, had mtl been deprecated or vice-versa
02:02:02 <Dunearhp> ?
02:02:11 <ivanm> Dunearhp: this is building gtk2hs docs?
02:02:17 <Dunearhp> yes
02:02:17 <ivanm> or trying to import it yourself?
02:02:26 <ivanm> Dunearhp: it's a bug in the gtk2hs Makefile
02:02:39 <mstr> dolio: oh, you mean like in C I could just free a list item but in haskell we copy the list?
02:02:46 <mstr> in filter command
02:03:22 <dolio> Yes. You'd have to rebuild it in C, too, if you cared about persistent data structures.
02:03:43 <Dunearhp> Interesting... Thanks
02:03:57 <mstr> I this case I just care about fast results :)
02:04:14 <mstr> how does a haskell coder fix this? I have no idea
02:06:52 <dolio> > let primes n = let ps = 2 : filter (\n -> all (\p -> n `mod` p == 0) $ takeWhile (\p -> p*p < n) ps) [3,5..n] in ps in primes 100
02:06:53 <lambdabot>   [2,3]
02:07:07 <dolio> > let primes n = let ps = 2 : filter (\n -> all (\p -> n `mod` p /= 0) $ takeWhile (\p -> p*p < n) ps) [3,5..n] in ps in primes 100
02:07:08 <lambdabot>   [2,3,5,7,9,11,13,17,19,23,25,29,31,37,41,43,47,49,53,59,61,67,71,73,79,83,8...
02:07:18 <dolio> Try that one.
02:07:27 <dolio> Oops.
02:07:32 <dolio> > let primes n = let ps = 2 : filter (\n -> all (\p -> n `mod` p /= 0) $ takeWhile (\p -> p*p <= n) ps) [3,5..n] in ps in primes 100
02:07:33 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
02:07:37 <dolio> That's better.
02:08:13 <ivanm> dolio: is that the fake euclidian sieve?
02:08:29 <dolio> It's trial division.
02:08:40 <ivanm> *nod*
02:09:16 <mstr> hmm, takeWhile..
02:14:06 <ttmrichter> Is there some trick to make GHC 6.10.2 compile with editline?  The library is on my system as are the headers, yet when I build the editline library is not built and ghci is compiled without support provided.  Anybody available to provide some guidance on this?
02:16:16 <dolio> mstr: The one I gave takes 5 seconds here.
02:17:27 <mstr> dolio: took about a minute here to 2M, but works
02:17:50 <dolio> Are you compiling? With -O2?
02:17:53 <dolio> That might help if not.
02:19:09 <mstr> ah, I'm running in ghci
02:19:25 <mstr> maybe I should try compiling :)
02:21:45 <mstr> umm, how do I make a main function that outputs an integer?
02:21:56 <mstr> main = do putStrLn solution doesn't seem to work
02:21:56 <dolio> main = print your-integer-here
02:35:59 <blygis> so, a matrix stack, is that a stack which holds matrices?
02:36:42 <blygis> (ehm, I'm trying to read up on some basic 3D stuff..)
02:39:00 <adimit> hello guys. What would be the easiest way to redistribute my gtk2hs application as a Windows 32bit binary? I already managed to get it cross-compiled, now I need a neat package people can install...
02:39:18 <ivanm> how about one of those .exe thingies?
02:39:19 <ivanm> ;-)
02:39:44 <adimit> well, it seems even with gtk2hs and ghc installed, it doesn't run by simply redistributing the binary.
02:40:32 <ivanm> ummm... last I checked, haskell still used static linking...
02:40:46 <ivanm> you _might_ need the windows gtk+ run-time though
02:42:47 <adimit> ivanm: nope. gtk2hs comes with a full library. I compiled and run it on my own VM from nothing more than msys, ghc, and gtk2hs.
02:43:02 <adimit> yes, and that's what confused me. I thought static linking would work.
02:43:12 <ivanm> adimit: ummm... no, I'm pretty sure gtk2hs doesn't include gtk+
02:43:18 <ivanm> unless they've included it in there...
02:43:26 <ivanm> @go gtk2hs windows gtk+ runtime
02:43:27 <lambdabot> http://book.realworldhaskell.org/read/gui-programming-with-gtk-hs.html
02:43:28 <lambdabot> Title: Chapter 23. GUI Programming with gtk2hs
02:43:30 <ivanm> heh
02:44:17 <ivanm> adimit: I'm pretty sure you need the gtk+ runtime still
02:44:23 <adimit> yay. But, as I said, the app runs *without* having gtk+ installed. Maybe it's in mingw or msys?
02:44:40 <ivanm> adimit: oh? but copying it to a different machine doesn't work?
02:44:48 <adimit> by the way, RWH says you'd need the glade library, which isn't exactly true, works without, too.
02:44:57 <adimit> ivanm: didn't, no.
02:45:15 <adimit> I'll try it under wine again, unfortunately, I don't really have the time to set up another clean VM...
02:45:16 <ivanm> adimit: try installing the runtime on the other machine
02:45:25 <ivanm> adimit: glade is for designing the layout AFAIK
02:46:01 <adimit> ivanm: well, *apparently* the runtime is installed, and I do use glade.
02:46:40 <ivanm> *shrug* I've never used gtk2hs myself, let alone haskell on windows
02:46:59 <adimit> me neither, that's why I was confused and came to ask ;-)
02:47:20 <ivanm> isn't windows deprecated yet? :s
02:47:32 <adimit> I heard dons actually does target windows in his company. Or maybe it was someone else.
02:47:42 <adimit> ivanm: I wish it were so.
02:48:23 <ivanm> augustss_ does IIRC
02:50:14 <adimit> http://www.galois.com/company/people << hehe.
02:51:52 * ivanm hates it when there's an asterisk, but nothing underneath for that asterisk to go to :@
02:52:32 <augustss_> I'm unfortunate to use Windows at work, yes.  And Linux.
02:54:21 <adimit> augustss_: may I ask if there are any guides on compiling haskell applications into installable Windows packages?
02:54:55 <adimit> unfortunately, I had to develop a linguistic tool that one of my cow-orkers has to use on a Windows platform.
03:20:38 <aleator> Hi all. Silly question, but what did I need to tell ghc in order to link c++ code. (Error is same as if I'd run gcc instead of g++)
03:29:59 <bobf> Hello. I've just read this: http://www.haskell.org/haskellwiki/Haskell_in_5_steps - is there a particularly highly recommended tutorial to go to from here or should I just take my pick ?
03:30:23 <Axman6> try real world haskell
03:30:26 <Axman6> @where rwh
03:30:26 <lambdabot> is http://www.realworldhaskell.org/blog/
03:30:36 <Axman6> or learn you a haskell
03:30:41 <Axman6> @where lyah
03:30:41 <lambdabot> www.learnyouahaskell.com
03:30:50 <Saterus> i'd go with LYAH before RWH. it's a lighter book. if i was to do it again, i'd do LYAH first.
03:44:57 <andun> plus it's a fun read :)
03:48:25 <magthe> I'm looking for a way to write out times in my system's timezone (currently BST, i.e. +0100), I'm only able to get it written in UTC
03:52:05 <bobf> Axman6: Cool, thanks !
04:24:41 <trofi> > (read "\\x -> x" :: Int -> Int) 2
04:24:42 <lambdabot>       No instance for (Read (Int -> Int))
04:24:42 <lambdabot>        arising from a use of `read'...
04:25:04 <Eridius> hah
04:30:05 <Baughn> > (\x -> x) 2 -- Eridius: Hah
04:30:06 <lambdabot>   2
04:31:01 <Eridius> hah?
04:31:39 <Baughn> Ha ha ha
04:31:42 <Baughn> Mwa ha
04:31:48 <Baughn> BWAHAHAHAHAHA
04:32:59 <trez> m
04:34:37 <wunki> to much Haskell can drive you crazy
04:35:50 <Baughn> I'm not crazy. I'll show them! I'll show them all!
04:35:52 <Baughn> > show [1..]
04:35:53 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:36:02 <Eridius> > show [1.0..]
04:36:04 <lambdabot>   "[1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17...
04:36:06 <Eridius> huh
04:36:14 <Eridius> > show [1.1..]
04:36:16 <lambdabot>   "[1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1,11.1,12.1,13.1,14.1,15.1,16.1,17...
04:36:19 <Eridius> ok now that's just silly
04:36:33 <Baughn> > show [1.0,1.1..]
04:36:34 <lambdabot>   "[1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.500000...
04:36:57 <Baughn> > iterate (/2) 1
04:36:58 <lambdabot>   [1.0,0.5,0.25,0.125,6.25e-2,3.125e-2,1.5625e-2,7.8125e-3,3.90625e-3,1.95312...
04:37:25 <wunki> happy 13:37 (CET +1)
04:38:13 <Tobsan> :D
04:38:31 <Baughn> Happy 13:38
04:38:35 <wunki> thanks
04:38:42 <wunki> your to kind
04:38:58 <Saterus> > (dropWhile isSpace) . fromJust . (stripPrefix "foo" "foo     bar")
04:39:00 <lambdabot>   Couldn't match expected type `a -> Maybe a1'
04:39:06 <Baughn> It'll all be over soon.. ah yes. There we go.
04:39:15 <ehamberg> "you're", "too". sorry. :)
04:39:46 <Baughn> ehamberg: How dare you correct imperial english with your worthless twenty-first century spellings? -_-
04:39:49 <wunki> thanks ehamberg, will remember the next time
04:39:59 <wunki> you're too kind
04:40:17 <ehamberg> :)
04:41:31 <Saterus> any idea why that's not matching the expected types?
04:41:57 <Baughn> @type stripPrefix "foo" "foo  bar"
04:41:58 <lambdabot> Maybe [Char]
04:42:08 <Baughn> @type fromJust . stripPrefix "foo" "foo  bar"
04:42:09 <lambdabot>     Couldn't match expected type `a -> Maybe a1'
04:42:09 <lambdabot>            against inferred type `Maybe [Char]'
04:42:09 <lambdabot>     In the second argument of `(.)', namely
04:42:25 <Baughn> @type (fromJust . stripPrefix) "foo" "foo  bar"
04:42:26 <lambdabot>     Couldn't match expected type `Maybe a'
04:42:26 <lambdabot>            against inferred type `[a1] -> Maybe [a1]'
04:42:26 <lambdabot>     Probable cause: `stripPrefix' is applied to too few arguments
04:42:33 * Baughn blinks
04:42:40 <Baughn> Oh. Doh.
04:42:51 <Baughn> . doesn't work with multiple parameters. Not quite, anyhow.
04:43:26 <Baughn> Even if it did, function application (the stripPrefix "foo" "foo bar" bit) binds more tightly than ., so it wouldn't work
04:43:42 <Baughn> > dropWhile isSpace $ fromJust $ stripPrefix "foo" "foo     bar"
04:43:43 <lambdabot>   "bar"
04:44:03 <Baughn> @type (.)
04:44:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:44:31 <Baughn> @type (fromJust . stripPrefix "foo") "foo  bar"
04:44:32 <lambdabot> [Char]
04:44:43 <Baughn> @type (dropWhile isSpace . fromJust . stripPrefix "foo") "foo  bar"
04:44:45 <lambdabot> [Char]
04:44:53 <Baughn> Saterus: Does that help?
04:44:54 <Saterus> maybe i'm missing why using function application is different than using parens here...
04:45:13 <Saterus> yeah, im just a little confused why it didnt work the first way and why it works this way
04:45:29 <Baughn> Saterus: What do you think . does?
04:46:17 <Saterus> uses the value of the expression on the right of "." as the parameter(s) for the expression on the left
04:46:26 <Baughn> Sorry.
04:46:29 <Eridius> no, you're thinking of $
04:46:37 <Baughn> Indeed
04:46:53 <Eridius> . is composition, not application
04:47:11 <Saterus> gah. :S
04:47:14 <Baughn> No, . combines two functions and constructs a third function of one parameter, such that for a.b that parameter is first fed to b, then b's return value is fed to a, then you get a's return value
04:47:15 <Saterus> thanks
04:47:48 <Baughn> > (dropWhile (/= 2) . filter (/= 3)) [1,3,2,1,4,2]
04:47:49 <lambdabot>   [2,1,4,2]
04:48:18 <Baughn> @src (.)
04:48:18 <lambdabot> (f . g) x = f (g x)
04:48:26 <Baughn> Saterus: Like that
04:48:27 <Baughn> @src ($)
04:48:28 <lambdabot> f $ x = f x
04:49:03 <Baughn> (For $, the important bit is its associativeness and (lack of) precedence)
04:50:18 <Saterus> if (f . g) x = f (g x), how is that different from f $ g x?
04:50:35 <Eridius> it's not
04:50:45 <Baughn> The difference is when you don't specify x
04:51:00 <Saterus> ah
04:51:12 <Saterus> ok, that makes sense.
04:51:58 <Saterus> Baughn, Eridius: thanks. that helped.
05:02:29 <ivanm> anyone here familiar with the prof2dot output?
05:14:46 <Saizan> byorgey++ #HWN and the "comics"
05:15:43 <ivanm> Saizan: which comics are these?
05:16:00 <ivanm> hmmm.... #HWN doesn't seem to exist... ;-)
05:17:38 <Saizan> Haskell Weekly News
05:17:45 <ivanm> yes, I know
05:17:58 <ivanm> but the # seems to imply it's an IRC channel...
05:18:44 <Baughn> irc://freenode/#hwn?
05:21:53 <ivanm> Saizan: but what comics were you referring to?
05:23:39 <Saizan> ivanm: the quotes at the end
05:23:54 <ivanm> ahhh
05:23:56 <ivanm> not actual comics
05:27:00 <andun> @pl \(i,j) -> [i..j]
05:27:01 <lambdabot> uncurry enumFromTo
05:32:20 <Raevel> can someone think of a clever way to turn [(a,[1,2]),(a,[3]),(b,[1])] into [(a,[1,2,3]),(b,[1])]? :-)
05:32:40 <smtms> Raevel, turn?
05:33:00 <ivanm> Raevel: using groupBy
05:34:04 <ivanm> > map (head *** concat . unzip) . groupBy ((==) `on` fst) $ [('a',[1,2]),('a',[3]),('b',[1])]
05:34:04 <Lemmih> Raevel: Data.Map.fromListWith (++)
05:34:05 <lambdabot>   Couldn't match expected type `[[a]]'
05:34:22 <ivanm> eh, something like that
05:34:25 <Raevel> :-)
05:34:33 <ivanm> :t map (head *** concat . unzip) . groupBy ((==) `on` fst)
05:34:33 <lambdabot>     Couldn't match expected type `[[a]]'
05:34:34 <lambdabot>            against inferred type `([a1], [b])'
05:34:34 <lambdabot>       Expected type: [(a1, b)] -> [[a]]
05:34:46 <ivanm> :t groupBy ((==) `on` fst)
05:34:47 <lambdabot> forall a b. (Eq a) => [(a, b)] -> [[(a, b)]]
05:34:51 * boegel tries to implement a lazy distance function, but is experiencing the Sunday blues
05:35:08 <Raevel> i think Lemmih is the winner!
05:35:37 <ivanm> Raevel: well, then you need a toList as well to get it out of the List
05:35:51 * ivanm was trying to avoid extra data structures
05:37:26 <mux> what would you guys recommend for lazy (as in SAX) XML parsing with haskell? HXT? XaXml?
05:38:12 <ivanm> @seen jyp
05:38:12 <lambdabot> jyp is in #haskell and #yi. I don't know when jyp last spoke.
05:43:14 * mux eyes Text.XML.HaXml.SAX
05:43:39 <edwardk> hrmm, is anyone here familiar with the meaning of the J# and S# constructors in GHC.Integer.Internals?
05:44:43 <Lemmih> edwardk: Yes.
05:45:10 * edwardk is trying to quickly determine the maximum bit set in an integer, and is trying very hard to avoid constructing appropriately sized ints to do it. what is the integer in the first half of J# is that the number of bytes, words, int64s?
05:46:20 <edwardk> right now my check is O(d^2) with respect to the size of the integer, but it should be able to be O(d)
05:47:12 <edwardk> i figure i can take the number of mpz chunks and compute a maximum bit to scan from that for the jumbo case, and just slog through the small case
05:48:01 <Eridius> maximum bit set? Why can't you just take a log base 2 and truncate?
05:48:15 <Lemmih> edwardk: It's the number of bytes.
05:48:15 <Eridius> truncate . (logBase 2)
05:48:16 <edwardk> Eridius: is there a built in function?
05:48:31 <edwardk> > truncate (logBase 2) 123801293810293810239810293810293810238102938120931230
05:48:32 <lambdabot>       No instances for (Integral (t1 -> a), RealFrac (t -> t))
05:48:32 <lambdabot>        arising...
05:48:40 <Lemmih> Or so I think.
05:48:47 <edwardk> lemmih hrmm
05:48:54 <Eridius> (truncate . logBase 2) 123801293810293810239810293810293810238102938120931230
05:48:57 <Eridius> > (truncate . logBase 2) 123801293810293810239810293810293810238102938120931230
05:48:58 <lambdabot>   176
05:49:05 * Lemmih takes a look in the source.
05:49:16 <edwardk> Prelude GHC.Num GHC.Int GHC.Integer.Internals> let J# a _ = 123108230182301982309128301823091283091283123 in (I32# a) ==> 3
05:49:22 <edwardk> i hope that would take more than 3 bytes
05:49:52 <edwardk> hah woops
05:49:52 <edwardk> hrmm
05:49:55 <edwardk> @type logBase
05:49:56 <lambdabot> forall a. (Floating a) => a -> a -> a
05:50:09 <ivanm> @src logBase
05:50:09 <lambdabot> Source not found. I feel much better now.
05:50:23 <edwardk> i presume logBase has a fast implementation for Integer. thats a heck of a lot portable than my manual hack ;)
05:50:36 <edwardk> thanks
05:50:47 <Saizan> > logBase 2 (10 :: Integer)
05:50:48 <Lemmih> "An integer is represented as a pair consisting of an @Int\#@ representing the number of \'limbs\' in use and the sign, and a @ByteArray\#@ containing the \'limbs\' themselves."
05:50:48 <lambdabot>       No instance for (Floating Integer)
05:50:48 <lambdabot>        arising from a use of `logBas...
05:51:06 <edwardk> ok, i figured it was something like the mpz chunks
05:51:23 <edwardk> ugh
05:52:10 <edwardk> so now the problem is of course the interpretation of limbs can probably change based on platform.
05:52:53 <edwardk> and of course that if i use the J# constructor i tie myself to non-dotnet deployment
05:53:45 <arjanb> isn't that dotnet thing bitrotted?
05:54:00 <edwardk> probably
05:54:27 <ivanm> edwardk: if you use J# you have to use non-dotnet? I thought J# _was_ dotnet :s
05:54:29 <edwardk> i don't know enough about it, i just know there is a nice conditional compilation flag in the particular source file i'm looking at with the S# and J# constructors in it
05:54:38 <edwardk> ivanm: hahaha
05:55:01 <ivanm> oh, this isn't J# the language you're talking about? :s
05:55:04 * ivanm was serious
05:56:03 <edwardk> ivanm: in ghc.integer.internals there are constructors S# and J# for Integer. S# is for small ones J# is for stuff big enough to trouble GMP to calculate
05:56:11 <ivanm> ahhhhh
05:56:17 <ivanm> oh, OK
05:56:45 <edwardk> when some flags get flipped there is no J# constructor and instead there is a third constructor which uses the native dotnet BigInteger type
05:57:01 <edwardk> i have no idea how those flags would work or even if they do
05:57:25 <edwardk> as arjanb said, i think it is probably bitrotted
05:58:16 <tomh> anyone knows where to find the chat example for happstack using comet?
05:58:30 <Igloo> edwardk: You realise that code that relies on J# isn't guaranteed to work in future GHC versions, presumably?
05:58:59 <edwardk> i suppose i can always check on a doubling cube. check 2^1, 2^2, .., 2^n for inequality with the quantity in question, that should preserve my asymptotics
05:59:12 <edwardk> Igloo: yeah =/ i'm just looking for some way to back into the number i need ;)
05:59:34 <edwardk> er 2^(2^n)
06:01:01 <tomh> whats this notation : (?something::Type) ?
06:01:13 <edwardk> tomh: implicit parameters
06:01:37 <edwardk> tomh: a bad idea that is occasionally useful when you are trying to figure out types using :t or lambdabot
06:02:04 <Saizan> tomh: there was a chat example under HAppS-Server/Examples, though it didn't implement the comet protocol
06:02:05 <edwardk> @type (foldr (?x) [])
06:02:05 <lambdabot> forall a a1. (?x::a -> [a1] -> [a1]) => [a] -> [a1]
06:02:07 <tomh> what is the question mark infront of it? part of it?
06:02:19 <tomh> Saizan: no comet? mm ok
06:02:55 <edwardk> you can let ?x = foo in ... and the ?x gets propagated down into everything used by ... as an implicit argument.
06:02:57 <tomh> well comet is not really a protocol, its just very long lasting http conenctions
06:03:29 <tomh> ok
06:03:31 <edwardk> tomh: rather it gets plumbed down into everything in the ... that says it takes that implicit argument in its type
06:04:06 <paolino> :t map (?x)
06:04:07 <lambdabot> forall a b. (?x::a -> b) => [a] -> [b]
06:04:09 <tomh> ah so it just saves typing it in all the stuff it needs
06:04:25 <Saizan> when i looked at comet it looked like something more, like trying to bundle multiple requests in a single one, or having channels etc..
06:04:28 <edwardk> yeah, you can write anything you could write with implicit parameters without, its just sugar to avoid plumbing
06:04:39 <paolino> it's not working in ghci  or I need extensions ?
06:04:52 <edwardk> one of the things that made happs unmaintainable imho was the use of implicit parameters everywhere
06:05:11 <tomh> hehe and maybe the 30k language extensions it uses
06:05:13 <edwardk> paolino: its a -XImplicitParameters
06:05:13 * Saizan didn't see them
06:05:21 <paolino> k
06:05:24 <Saizan> they got removed later, i guess :)
06:05:31 <edwardk> i like language extensions =)
06:05:49 <tomh> i have to do a presentation tomorrow on happstack
06:05:57 <tomh> gonna be hard i guess :P
06:06:49 <Saizan> TH and type families are not that bad
06:07:20 <Saizan> you can avoid all the SYB stuff if you don't touch .Data.Xml
06:10:28 <Saizan> (bad as in hard to explain)
06:11:07 <edwardk> ok. i can preserve my asymptotics with that 2^(2^i) thing yay
06:11:43 <edwardk> not liking the constant so much, but hey
06:12:03 <edwardk> Igloo: any hope of smuggling a logBase2Integer :: Integer -> Int into GHC.Integer sometime? =)
06:13:44 <Igloo> edwardk: File a ticket for it
06:14:08 <edwardk> igloo: k
06:15:13 <Igloo> edwardk: What do you expect it to do for 0 and negative numbers?
06:15:53 <edwardk> Igloo: well, alas you don't have a natural type ;)
06:18:01 <edwardk> Igloo: in my case what i'm looking for is the logBase2 of |n|+1 where n is some integer because i need the largest bit that isn't the infinite tail of 1s or 0s
06:18:52 <edwardk> igloo so in that sense, what i need is always well defined, i just don't know if its standard library worthy
06:19:28 <Igloo> I think it makes sense to provide it, because the Integer library can do it more efficiently than you can
06:20:09 <Igloo> Maybe GHC.Num should wrap it and throw an exception if it gets something <= 0
06:20:10 <edwardk> yeah, i'll log a ticket with that extra verbage explaining what i'm looking for and why
06:21:23 <vixey> why not just a GMP lib with lots of Integer stuff
06:21:58 <edwardk> i always did wonder why a bigger GMP lib hasn't found its way onto hackage
06:22:02 <edwardk> or is there one?
06:25:49 <edwardk> Igloo: another thing is there is no way to quickly find the set bit count in an Integer. (i usually return a negative number from that operation if the integer is negative, negating the number of positive bits)
06:27:55 <edwardk> i suppose i could replace the Integer in my current setting with a ByteArray# or UVector# or something, since i'm only really using its abiliity to quickly do bit operations
06:28:00 <edwardk> er UVector
06:39:32 <boegel> @src minimum
06:39:32 <lambdabot> minimum [] = undefined
06:39:32 <lambdabot> minimum xs = foldl1 min xs
06:39:46 <boegel> @src foldl1
06:39:46 <lambdabot> foldl1 f (x:xs) = foldl f x xs
06:39:46 <lambdabot> foldl1 _ []     = undefined
06:40:24 <boegel> why not minimum (x:xs) = foldl min x xs ?
06:40:48 <boegel> or would that hardly make a difference?
06:40:49 <edwardk> boegel: thats foldr1 min xs =)
06:40:54 <edwardk> er foldl1
06:40:57 <trofi> > min []
06:40:58 <lambdabot>       Overlapping instances for Show ([a] -> [a])
06:40:58 <lambdabot>        arising from a use o...
06:41:05 <trofi> > minimum []
06:41:06 <lambdabot>   * Exception: Prelude.minimum: empty list
06:41:17 <boegel> edwardk: I know, but defining foldl1 seems overkill, no?
06:41:50 <edwardk> boegel: allows other rewrite rules to fire and makes it explicit that it doesn't work on empty lists
06:41:50 <koeien> no
06:44:51 <edwardk> now, a philosophical debate as to whether any uses of foldl1 should be around or if there should be a separate non-empty list type to support head,  foldl1, foldr1, etc. is another question ;)
06:56:06 * duckinator pokes Tsion 
06:57:01 * vixey pokes duckinator
06:57:13 <duckinator> hi vixey
06:57:42 * Axman6 is confused about how you duckinate something
06:58:14 <vixey> well I guess it's a bit like frobnicating ? except with extra quack
06:58:57 <Axman6> i see
07:01:56 <shapr> whee!
07:02:08 <duckinator> whoo!
07:04:57 <vixey> hey shapr did you try my juggling progam?
07:29:46 <kadaver> There will be monads
07:41:24 <shapr> vixey: No, where is  it?
07:44:45 <tomh> @src CaseE
07:44:45 <lambdabot> Source not found. My mind is going. I can feel it.
07:44:54 <tomh> @hoogle CaseE
07:44:54 <lambdabot> Language.Haskell.TH CaseE :: Exp -> [Match] -> Exp
07:44:55 <lambdabot> Language.Haskell.TH.Syntax CaseE :: Exp -> [Match] -> Exp
07:44:55 <lambdabot> Language.Haskell.TH caseE :: ExpQ -> [MatchQ] -> ExpQ
07:45:19 <vixey> shapr, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2003
07:46:12 <Nafai> nominolo: Around?
07:46:48 <shapr> vixey: Huh, utf-8 operator?
07:46:49 <tomh> @hoogle request
07:46:49 <lambdabot> No results found
07:47:05 <vixey> shapr you don't have UTF support :/
07:47:31 <shapr> I do, I just noted that x appears to be utf-8.
07:47:36 <vixey> it is
07:47:40 <shapr> nifty!
07:49:23 <nominolo> Nafai:  yup
07:51:07 <bremner> what is a good definition of a combinator. Does it really express nothing beyond "no free variables"? Then id is a combinator.
07:51:20 <Nafai> nominolo: scion looks interesting!  I'd love to help out, if at all possible.
07:51:20 <nominolo> bremner: it is
07:51:43 <Cale> bremner: There's more than one sense in which the word 'combinator' is used though.
07:51:51 <mauke> SKK
07:52:05 <Cale> bremner: That definition perfectly captures one of the senses.
07:52:10 <bremner> Cale: I guess I thinking of the >>== sense
07:52:17 <nominolo> Nafai: ah, nice.  sure it's possible.
07:52:25 <nominolo> Nafai: any particular ideas?
07:52:45 <Cale> More generally, a combinator is just any function which combines other computations in some way.
07:53:34 <shapr> Something is broken with my ghc6.10.1 in debian/unstable...
07:54:01 <bremner> shapr: oh? works for me, I think
07:54:03 <Nafai> nominolo: Not yet, I haven't played with it enough (just found it on Friday).  I just want something with these types of features.
07:54:28 <thomastc> Nafai: what are you planning to use it for? :)
07:54:30 <shapr> I'd previously installed the seereason versions, I wonder if that's conflicting.
07:54:52 <nominolo> Nafai: what's your programming environment?  Emacs?
07:55:14 <Nafai> Yes, Emacs.
07:55:56 <zloog> ?src reverse
07:55:57 <lambdabot> reverse = foldl (flip (:)) []
07:56:09 <zloog> funny
07:56:33 <bstamour> any reason why it doesn't use foldl' ?
07:57:36 <Beelsebob> bstamour: because you may not want to evaluate the values
07:57:44 <Beelsebob> strictness is not always good
07:57:48 <bremner> Cale: I guess combining computations is ok. Combinator seems like more of an interpretation thing, like "here we use g as a combinator".
07:57:50 <Beelsebob> in fact, it almost never is
07:58:08 <bstamour> ah, I see.
07:58:19 <bremner> shapr: if you have a simple test case, I can try it on my debian/unstable box
07:58:38 <bstamour> Now in the case where you're computing something over the list, like say a sum... then you'd probably want strictness to avoid a space leak... correct?
07:59:47 <arjanb> the strict foldl is mostly used to avoid stack overflows
08:00:09 <Beelsebob> bstamour: sum is not strict either
08:00:12 <Beelsebob> @src sum
08:00:12 <lambdabot> sum = foldl (+) 0
08:00:22 <Beelsebob> you can have lazy numeric types
08:00:29 <Beelsebob> e.g. church numerals
08:00:39 <Beelsebob> and then you can compute the sum lazily
08:00:45 <Cale> It would be nice if the libraries included a strict sum' though :)
08:00:51 <bstamour> I see.
08:01:04 <nominolo> Nafai: well, Scion has a bugtracker: http://code.google.com/p/scion-lib/issues/list :)
08:01:07 <bstamour> thanks for the insights :)
08:01:08 <Beelsebob> Cale: agreed, yeh
08:01:13 <bindreturn> I am trying to accumulate a sum for Double values elements in STUArray using foldM, and cant work out what it should look like
08:01:23 <bindreturn> here if anyone wants a look --> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3364#a3364
08:02:40 <Nafai> nominolo: cool, I'll play around with it and file some :)
08:05:21 <Martijn> Can someone please help me with this? If I run ghc --make myself, my executable is compiled against readline (which is good), but if I let cabal build my library it is compiled against editline (bad)
08:05:46 <kpreid> @hoogle (b -> m c) -> (m b) -> m c
08:05:47 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:05:47 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
08:05:47 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
08:06:00 <arjanb> nominolo: is there any editor project planning to integrate Scion?
08:06:15 <kpreid> @hoogle (b -> m c) -> (a -> m b) -> a -> m c
08:06:16 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:06:16 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:06:16 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
08:06:29 <thomastc> arjanb: I'm hoping to land a GSoC project to work on scion and EclipseFP
08:06:42 <nominolo> arjanb: marc weber is working on Vim support, and the Yi guys would like to use Scion as well
08:06:45 <thomastc> brb
08:07:23 <nominolo> arjanb: and, yes, thomastc wants to port EclipseFP to it
08:08:24 <arjanb> nice, and you can try convince leksah people at hac
08:12:11 <nominolo> arjanb: yep
08:15:26 <Saterus> anybody know of any good haskell network programming tutorials?
08:16:48 <nominolo> Saterus: network-bytestring has some examples
08:17:08 <Saizan> there's a nice paper about writing a simple haskell webserver too
08:18:27 <Saterus> Saizan: webserver stuff is probably a little more than I need. i'm trying to figure out how to make a REST call, and i've been looking through some of the source for hS3 and hs-twitter for some examples, but i havent made much progress.
08:19:55 <ezero> i wrote some code
08:20:01 <ezero> to find prime numbers
08:20:21 <ezero> using black list sort of formula .. building list of composites
08:20:31 <ezero> can it be improved? http://pastebin.com/d737e6f89
08:21:34 <arjanb> ezero: you might want to start with using pattern matching
08:21:40 <ezero> there is way to much recursion in that
08:22:03 <ezero> for example arjanb?
08:22:17 <Saizan> Saterus: well, the fundamentals about sockets are the same, i imagine, http://www.haskell.org/~simonmar/papers/web-server-jfp.pdf , you can skip the first part up to the code snippets
08:23:04 <Saterus> Saizan: ok, good point. I'll take a look. thanks.
08:23:47 <arjanb> ezero: mix [] [] = []   mix [] (y:ys) = y : mix [] ys
08:24:15 <ezero> i did that before that stuffs up because i can't catch for empty arrays
08:24:23 <ezero> it ends up with exhaustive function
08:26:11 <ezero> [2*** Exception: hello.hs:(5,0)-(6,28): Non-exhaustive patterns in function mix
08:26:14 <ezero> like i said
08:26:54 <arjanb> ezero: can you pastebin that function
08:27:06 <ezero> i did paste bin the whole thing
08:27:19 <ezero> http://pastebin.com/d4f2e30a6
08:27:49 <arjanb> the implementation with pattern matching i mean
08:28:03 <ezero> http://pastebin.com/d2e2fbba3
08:29:05 <arjanb> ezero: you need to convert the other cases, i only showed the first 2 as an example
08:29:09 <edwardk> can anyone thing of a stock set manipulation function that I forgot in http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Ring-Semi-BitSet.html ?
08:29:22 <ezero> oh right
08:29:39 <wli> I've got vacuum and vacuum-cairo now, albeit with no idea how to use them.
08:29:42 <ezero> so create a pattern match for all of them
08:29:51 <arjanb> right
08:29:59 <ezero> guess icould do the same for contains as well then
08:30:57 <arjanb> you should end up with no head or tail function
08:31:27 <ezero> right yeah
08:31:31 <ezero> ill try :)
08:32:45 <bindreturn> hmmm ok i solved my foldM and STUArray at http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3364#a3364
08:32:53 <bindreturn> just to avoid anyone wasting time with it
08:33:43 <edwardk> is it just me or does 'cabal upload' seem to take forever?
08:36:45 <ezero> cool pattern matching seems to have improved the performance
08:37:30 <ezero> CPU Utilization is not going any further then 50% and not much RAM usage
08:39:38 <ezero> lol cpu is definitly overheating tho judging by the fan speed
08:40:37 <Cale> ezero: You should generally not use == to test for an empty list
08:40:49 <Cale> But, maybe someone mentioned that :)
08:40:53 <ezero> yeah i learned pattern matching is better
08:41:03 <Cale> Or there's a function called null
08:41:06 <Cale> :t null
08:41:07 <lambdabot> forall a. [a] -> Bool
08:41:19 <ezero> oh
08:41:21 <Cale> But yeah, if you can pattern match, that's stylistically usually a good deal better.
08:41:38 <Cale> :t (\x -> x == [])
08:41:39 <EvilTerran> @check \xs -> null (xs :: [Int]) == (xs == [])
08:41:40 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:41:41 <lambdabot>   "OK, passed 500 tests."
08:42:50 <ezero> so isntead of this
08:42:51 <ezero> | c == [] = False
08:43:38 <ezero> but EvilTerran is using ==
08:44:12 <ezero> oh i just get rid of [] and thats it
08:44:32 <ArneB> He just demonstrated that null is equivalent to == [].
08:45:06 <ezero> i see, so hwo do i check if x == null ?
08:45:16 <trofi> :t (null ?x)
08:45:17 <lambdabot> forall a. (?x::[a]) => Bool
08:45:26 <RayNbow> > null []
08:45:28 <lambdabot>   True
08:45:29 <RayNbow> > null [1..]
08:45:30 <edwardk> @seen shapr
08:45:30 <lambdabot> shapr is in #haskell-blah and #haskell. I last heard shapr speak 51m ago.
08:45:31 <lambdabot>   False
08:45:39 <|jedai|> ezero: null x is the same thing as x == []
08:45:47 <ezero> | null c = False
08:45:59 <arjanb> you don't want null in that code
08:46:05 <kadaver> does ghc rewrite pattern matching to case?
08:46:50 <jedai> kadaver: Yes
08:48:22 <ArneB> ezero, you'll probably want to use: contains _ [] = False
08:48:34 <ezero> so do a pattern match :)
08:48:35 <ezero> cool
08:49:52 <ezero> thats far more elegant way of catching exception :D
09:00:53 <c_r> i want readonly access to a var bound in a calling scope (to avoid a@(B c d) = sub(a) everywehre) best solution is some monadic plumbing?
09:01:03 <c_r> basiclaly trying to keep Haskell as concise as the Ruby, DRY wise...
09:01:17 <c_r> i dont mutate ruby object fields, but the implicit self and accessors cut down on verbosity
09:02:37 <Saizan> c_r: a poor man solution is to define sub in a where clause in that lexical scope,
09:02:53 <Saizan> c_r: otherwise look at the Reader monad
09:02:56 <c_r> k
09:03:11 <c_r> im proably fliping out over the verbosity. i just have like 80 utlity functions that do one tiny thing
09:06:19 <Baughn> Which do you prefer - the explicit Reader monad, or the implicit (->r) one?
09:06:31 <vixey> implicit!!
09:16:58 <bobf> If I do  "[x * 2 | x <- [1..10], x * 2 < 4]", are the two "x * 2" calls optimised to a single call ?
09:17:28 <Botje> maybe
09:17:44 <MyCatVerbs> bobf: probably not, IIRC GHC still doesn't do common subexpression elimination.
09:17:53 <Botje> don't worry about it
09:18:02 <bobf> Cool, no worries.
09:18:05 <Botje> you can always write it as [y | x <- [1..10], let y = x * 2, y < 4 ]
09:18:13 <wli> CSE is not quite the same thing in lazy languages as elsewhere. They can cause space leaks.
09:18:14 <Deewiant> It might, for 'simple' cases like that where the math is probably done directly on the hardware
09:18:26 <Botje> if you really think that change is going to make a lot of difference, but meh
09:18:29 <b_jonas> Botje: does that work?
09:18:35 <b_jonas> isn't the y out os scope there?
09:18:42 <bobf> Botje: Aha ! I'm used to Python, where having the same call on both sides usually means you want a regular for loop.
09:18:42 <Deewiant> > [y | x <- [1..10], let y = x * 2, y < 4 ]
09:18:43 <lambdabot>   [2]
09:18:46 <b_jonas> > [y | x <- [1..10], let y = x * 2, y < 4 ]
09:18:47 <lambdabot>   [2]
09:18:51 <b_jonas> wow
09:18:56 <bobf> So that's pretty neat.
09:19:08 <Botje> bobf: remember, list comprehensions just desugar down to do-syntax
09:19:13 <bobf> Yep.
09:19:18 <Deewiant> > filter (<4) . map (*2) $ [1..10]
09:19:19 <lambdabot>   [2]
09:19:20 <b_jonas> so the let behaives like a do let {}; statement?
09:19:22 <Botje> i meant b_jonas there, but okay
09:19:32 <Botje> b_jonas: yeah. look up "monad comprehensions" some time
09:19:39 <Deewiant> ?undo  [y | x <- [1..10], let y = x * 2, y < 4 ]
09:19:45 <lambdabot> concatMap (\ x -> let { y = x * 2} in if y < 4 then [y] else []) [1 .. 10]
09:19:45 <Ferdirand> mhh
09:19:56 <Botje> list comprehensions used to be monad comprehensions but they were restricted to the list monad because they were too confusing to newbies
09:20:05 <Deewiant> Damn H98!
09:20:25 <Botje> We should totally start writing Haskell'
09:20:34 <Botje> is that coming out before or after duke nukem forever?
09:20:45 <bobf> :)
09:20:46 <Deewiant> Haskell' is just ghc -fglasgow-exts
09:20:51 <b_jonas> is there any case when they're actually simpler than the equivalent do notation?
09:20:52 <dons> ghc already implements it
09:21:21 <Botje> bobf: everything you know from python is probably wrong :
09:21:32 <trofi> :]
09:21:35 <b_jonas> Deewiant: actually H' only has the extensions that are easy to implement
09:21:48 <Deewiant> b_jonas: Yeah, and mostly ones that Hugs already has
09:22:12 <Deewiant> But in any case, there's nothing particularly exciting about Haskell' except being able to drop non-GHC compatibility without getting sad
09:22:35 <Saizan> Haskell'' is clearly the way to go
09:23:20 <Deewiant> That I can guarantee will be coming out after Duke Nukem Forever :-P
09:23:33 <Botje> Haskell'' = undefined
09:23:37 <bobf> Botje: Oh, I thought Python invented list comprehensions. :(
09:23:55 * bobf hides.
09:24:03 <Deewiant> bobf: Sorry, they were born in the 60s or 70s :-P
09:24:04 <Botje> bobf: SimonPJ was talking about them in Gofer in 1986, sorry :)
09:24:53 <b_jonas> I've recently read some parts of the smalltalk book and decided that ruby didn't invent anything: it's just smalltalk with different syntax and local variables and instance variables implicitly declared
09:25:08 <b_jonas> s/decided/realized/
09:25:16 <Eridius> who said ruby invented anything?
09:25:26 <b_jonas> well, I'm young
09:25:46 <bstamour> ruby is kinda nice though, even if it didn't invent anything.
09:25:53 <Botje> b_jonas: smalltalk doesn't even need the implicit local variable declarations
09:25:55 <bstamour> :)
09:26:17 <Botje> only if you add a block with local variable declarations, you damn well better include all the ones you use
09:26:32 <b_jonas> but it turns out that after machine code and algol and lisp and smalltalk, there's nothing new languages can do
09:26:43 <Botje> sure they can
09:26:58 <vixey> hahaha
09:26:59 <Botje> non-von neumann architectures are still pretty unexplored
09:27:24 <vixey> b_jonas: machine code, algol, lisp and smalltalk do not have: Curry-Howard
09:28:16 <trofi> [:
09:33:39 <wli> I think people have trouble envisioning concrete implementations of non- von Neumann architectures.
09:34:18 <vixey> I don't know why non von neumann matters.. we'd just do high level programming on them anyway
09:38:39 <arjanb> i don't understand why people want to classify architectures in von Neumann's and non
09:44:44 <rovar> arjanb, what classification method would you suggest?
09:44:44 <lambdabot> rovar: You have 1 new message. '/msg lambdabot @messages' to read it.
09:47:23 <arjanb> rovar: either none or one including more than dozen aspects
09:59:09 <lpsmith> b_jonas:   you'd also be missing continuations and lazy evaluation ;-)
10:00:49 <lpsmith> Algol 68 did have call by name,  but it wasn't very well developed... and due to the prevalence of side effects in most people's code,  a lot of good academic types came to the conclusion that call-by-name was unworkable and only of minor academic interest
10:03:05 <lpsmith> One of the major issues in language design is the _extreme_ nonlinearity of the problem and design space
10:03:05 <b_jonas> lpsmith: they did continuations in lisp,
10:03:19 <b_jonas> and lazy evaluatoin too, although only explicit lazyness, not implicit in all expressions
10:03:27 <lpsmith> In part
10:03:46 <b_jonas> well, it was basically just using nullary functions, nothing complicated
10:04:01 <lpsmith> The thing is the concept of a continuation is often subtly different in incarnation to incarnation
10:04:20 <lpsmith> and exactly what they can and can't do is often dependent upon such sundry details :-)
10:04:29 <b_jonas> yeah
10:04:38 <mib_juf82vce> hi
10:04:50 <bstamour> hello
10:05:17 <mib_juf82vce> I cant get wxHaskell to work. Can anybody help? It will have to be basic, as I only heard of haskell today
10:07:09 <dons> you should paste your error to the wxhaskell list
10:07:53 <Saizan> there aren't many wxHaskell users on this channel, it seems
10:08:34 <mib_juf82vce> i'm following a wikibook; i found the link from haskell.org it seems to mention 'cabal' a lot. What is cabal?
10:08:52 <b_jonas> right, we're all abstract theoretic guys, we don't write real programs
10:09:02 <b_jonas> mib: it's the package system for haskell modules
10:09:25 <mib_juf82vce> so i download it to install wxHaskell?
10:10:02 <Saizan> yeah
10:10:02 <b_jonas> I can't even get WxPerl to work so don't ask me
10:10:11 <mib_juf82vce> ok, thanks. I'll try that.
10:10:14 <mib_juf82vce> bye
10:10:48 <dons> cabal install wxcore
10:11:46 <vixey> b_jonas: "we're all abstract theoretic guys, we don't write real programs' says who?
10:12:11 <pumpkin> o.O
10:13:20 <bavardage> how do I convert strings to [Word8]
10:13:27 <bavardage> ideally I want to convert straight to a lazy bytestring
10:13:32 <bavardage> but it seems this isn't possible
10:13:43 <glguy> Data.ByteString.Lazy.Char8
10:13:50 <bavardage> (I want to decompress gzip data)
10:13:57 <bavardage> oh kk
10:14:29 <Saizan> .Char8 assumes latin1
10:15:17 <pumpkin> if it's gzip, just use a regular lazy bytestring
10:15:26 <bavardage> pumpkin: yeah but I have a string
10:15:35 <bavardage> how do I turn a string into a regular lazy bytestring
10:15:51 <bavardage> bleh now I have to turn this back into a string again for HXT :P
10:15:55 <bavardage> damn gzipped xml files
10:16:19 <Saizan> why are you starting from String?
10:16:51 <pumpkin> bavardage: pack . map (fromIntegral . ord)
10:16:56 <pumpkin> :P
10:17:06 <pumpkin> or find something that doesn't rely on strings so you can bytestring it all the way
10:17:19 * kowey hopes that somebody will take over http://projects.haskell.org/nlp/ someday :-)
10:17:21 <bavardage> Saizan, pumpkin: right, tell me the sensible way
10:17:31 <kowey> (and grow it into something awesome)
10:17:34 <bavardage> I want to get a gzipped xml file and use it with HXT
10:17:51 <glguy> start with bytestring, ungzip it to a bytestring, convert to UTF-32, XML parse
10:17:54 <Saizan> bavardage: if you're starting from a file you can read it with Data.ByteString.Lazy.readFile
10:18:18 <bavardage> I'm getting this file over a network
10:18:23 <pumpkin> network-bytestring!
10:18:24 <glguy> network-bytestring
10:18:24 <bavardage> so I'm using Network.HTTP
10:18:30 <bavardage> oh kk
10:18:42 <kadaver> does ghc rewrite pattern matching to case?
10:18:43 <kowey> dons: I'm really unhappy about the state of wxcore cabalisation... wish we could do better :-( ... part of the problem is http://bp2.blogger.com/_c6WmXt2id8U/R8HABBJjdjI/AAAAAAAAAHk/ZT_q6Ts53XY/s1600-h/components.png
10:18:52 <kadaver> oops nevermind that one
10:18:58 <kadaver> can you somehow call Octave from Haskell?
10:19:08 <bavardage> so I can get it like in Network.HTTP?
10:19:14 <bavardage> the package description is talking about sockets :(
10:19:34 <pumpkin> looks like HTTP still uses strings... that's odd
10:19:47 <pumpkin> http://hackage.haskell.org/packages/archive/HTTP/4000.0.5/doc/html/Network-BufferType.html
10:19:49 <kadaver> Im thinking about doing bindings for FLENS to haskell, it is a C++(and udnerneath blas lapack) matrixlib.
10:19:57 <pumpkin> so it does support ByteString buffers
10:20:00 <kowey> (for the interested, the way to install wxcore looks like sudo cabal install wxcore --global for now :-( )
10:20:13 <pumpkin> bavardage: both lazy and strict ByteString buffers
10:20:45 <bavardage> oh so I can just expect a string at it'll give me one?
10:21:04 <bavardage> bleh
10:21:46 <b_jonas> kadaver: just execute it
10:21:46 <pumpkin> you might not be able to use the simple interface in http
10:21:51 <pumpkin> but I'm sure it isn't too hard to change
10:22:00 <b_jonas> kadaver: you can pass numeric data in binary files
10:22:02 <Saizan> kowey: why?
10:22:07 <b_jonas> kadaver: I have a perl example somewhere, wait
10:22:21 <kowey> Saizan: why does one have to go through all these hoops?
10:22:37 <bavardage> pumpkin: so I should poke around in HTTP?
10:22:41 <Saizan> kowey: yeah, why the global, specifically
10:22:51 <bavardage> bleh I g2g
10:22:55 <pumpkin> bavardage: version 4000 definitely has support for ByteString buffers
10:22:59 <b_jonas> kadaver: maybe you just want to bind the c functions then, not call octave
10:23:00 <vixey> why is there no list of theoretical pearls?
10:23:06 <vixey> there is a list of functional pearls though..
10:23:21 <kowey> Saizan: the thing is that wxcore doesn't use the simple build method (or custom for that matter)... it uses the make method around a handwritten (argh!) configure script and makefile :-(
10:24:10 <kowey> Saizan: and it uses a makefile because of all the bits and pieces in the diagram... if only somebody clever could sit down a little bit and (a) divorce wxc into its own package (autotools) and (b) make wxcore proper cabal
10:25:03 <kowey> the wxhaskell team need some love from people who have experience cabalising hairy stuff
10:25:49 <monochrom> byorgey: "Beta of Leksah IDE available. Jrgen" on the HWN web page version.
10:26:04 <monochrom> @tell byorgey "Beta of Leksah IDE available. Jrgen" on the HWN web page version.
10:26:04 <lambdabot> Consider it noted.
10:26:23 <monochrom> (I hope lambdabot preserves the garbled letters.)
10:26:50 <Saizan> kowey: so wxc is a build-tool used to build wxcore, which is a build-tool for wx?
10:27:13 <kowey> wxc is a wrapper around wxWidgets that lets you program in C (instead of C++)
10:27:41 <kowey> wxdirect is a small haskell program that converts wxc headers and some Eiffel headers (from the old wxEiffel project) into haskell
10:28:10 <kowey> these converted files + some handwritten files are what make up wxcore
10:28:30 <kowey> there actually is a wxc project, but it looks pretty stagnant, and I wish somebody would take it over!
10:29:49 <kowey> here's that wxc project - http://wxc.sourceforge.net/
10:31:52 <stulli> @src Monoid
10:31:52 <lambdabot> class Monoid a where
10:31:52 <lambdabot>     mempty  :: a
10:31:52 <lambdabot>     mappend :: a -> a -> a
10:31:52 <lambdabot>     mconcat :: [a] -> a
10:33:05 <ddarius> @src MonadPlus
10:33:05 <lambdabot> Source not found. Are you on drugs?
10:34:58 <c_wraith> @quote hello world
10:34:58 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
10:35:05 <c_wraith> Bah, I can't remember who said it
10:36:32 * Beelsebob ponders if there's an exetension that lets us deal with things like Monoid that have multiple sensible definitions for some types
10:37:51 <Heffalump> Beelsebob: newtype + NTDeriving for the other classes?
10:38:08 <Beelsebob> oh, interesting idea  minus the NTDeriving
10:38:17 <Beelsebob> surely that would give us the same instances, no?
10:38:28 <Heffalump> for the other classes
10:38:35 <ddarius> Beelsebob: There are some proposed extensions, but none that look like they would be accepted
10:38:48 <Beelsebob> still, not so nice that Int has many possible definitions (1,(*)), (0,(+)) ...
10:38:55 <Beelsebob> and they wouldn't be able to interact
10:39:32 <ddarius> For situations like this, it's probably best to pass the dictionary explicitly.  You can even combine approaches.
10:39:39 <Beelsebob> true
10:39:43 <Beelsebob> good point
10:39:50 <Philonous> Can I have strictness annotations in type synonyms? Like type Foo = (!Bar, !Qux)
10:40:13 <ddarius> You could potentially also abuse implicit parameters for this purpose.
10:40:31 <ddarius> Philonous: No.  It wouldn't be a type synonym anymore.
10:41:26 <Philonous> Ah, beacuse bang is part of the constructor, not the type?
10:41:29 <ddarius> Anyway, strictness annotations in a data type just make the constructor strict in the relevant arguments, but there is no new constructor for a type synonym and it would be clearly wrong for it to change the semantics of (,)
10:42:03 <Philonous> I see
10:43:00 <Philonous> So if I want strict tuples I need to define them by myself?
10:43:29 <pumpkin> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
10:50:05 <b_jonas> Philonous: yes, as a data type
10:51:46 <Philonous> btw. the documentation of the strict package is incoherent. In the description the constructor for pairs is (:*:) but later it is (:!:)
10:52:04 <pumpkin> yeah :)
10:52:13 <pumpkin> uvector has its own :*: strict pair
10:52:36 <shapr> Huh, I found a bug in the latest cabal, or cabal-install, not sure which. if I uncomment "optimization: True" and then run "cabal list" I get "cabal: Command.optionToFieldDescr: feature not implemented"
10:53:27 <shapr> Same for uncommenting "verbose: 1"
10:54:08 <Baughn> shapr: The config-file format has changed. I suggest you delete and recreate it.
10:55:33 <shapr> This is the one that's automatically created by cabal 1.7
10:55:34 <Saizan> Baughn: it still has those commented fields
10:55:40 <a_guest> :quit
10:56:12 <Baughn> Saizan: Well, yes, but I saw similar weirdness when using an old-style config file with the new version
10:56:17 <Baughn> Recreating it fixed that
10:56:50 <dons> shapr: heh
10:56:56 <dons> shapr: might even be easy to fix.
10:57:14 <dons> Philonous: i could accept a patch!
10:57:31 * dons ponders self optimizing tuples with assoc. data types
10:58:59 <monochrom> A special case is self-optimizing couples. :)
11:00:59 <mib_q875e49s> does anybody know how to use cabal and/or wxHaskell please?
11:01:37 <rovar> i'm guessing the answer to that question is yes
11:01:43 <rovar> but that's probably not the answer you seek
11:01:59 <mib_q875e49s> can you tell me the answer u seek please?
11:02:06 <mib_q875e49s> *the answer i seek
11:02:22 <b_jonas> I'm writing haskell code!
11:02:25 <rovar> if you can tell me the real question
11:02:27 <bremner> mib_q875e49s: can you ask an actual question? :-)
11:03:03 <mib_q875e49s> how do I install wxHaskell on my Windows OS please?
11:03:03 <monochrom> I think the real question is "a complete guide".
11:04:11 <kowey> I would try http://www.haskell.org/haskellwiki/WxHaskell/Download
11:04:13 <b_jonas> haven't you already asked that once?
11:04:14 <kowey> the binary packages
11:05:53 <Taejo> :t liftA2 (/) sum length
11:05:54 <lambdabot>     No instance for (Fractional Int)
11:05:54 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
11:05:54 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
11:06:06 <Taejo> :t liftA2 (/) sum (fromIntegral . length)
11:06:07 <lambdabot> forall b. (Fractional b) => [b] -> b
11:08:05 <gwern> 'download packages from hackage, like this:
11:08:06 <gwern> cabal build [--global --root-cmd=sudo] satchmo
11:08:07 <gwern> oops!
11:08:41 <Taejo> foldr1 (!=) [True, False, True]
11:08:44 <dons> getting into sat solving, gwern ?
11:08:46 <Taejo> > foldr1 (!=) [True, False, True]
11:08:47 <Saizan> s/build/install/
11:08:47 <lambdabot>   Not in scope: `!='
11:08:51 <Taejo> > foldr1 (/=) [True, False, True]
11:08:52 <kowey> cabal install -f-gui GenI still tries to grab the wxhaskell dependency... hmm
11:08:53 <lambdabot>   False
11:09:01 <gwern> dons: not really since my cabalizing of minisat got rebuffed
11:09:07 <gwern> dons: my point being his docs are wrong :)
11:09:09 <dons> cryptol has this really cool :prove binding in its ghci, for calling out to a SAT solver for various numeric 'quickcheck' like properties
11:09:13 <dons> we should port it to ghci
11:09:37 <vixey> dons: I saw that it's so cool
11:09:47 <rovar> i like the sudoku solver implementation.
11:10:09 <gwern> dons: hm. but what does that get you over calling actual qc tests?
11:10:38 <gwern> just convenience or do qc not work well for numerics?
11:10:42 <dons> gwern: proofs
11:11:01 <dons> so you have increased assurance
11:11:27 <gwern> ah. do you have any examples handy?
11:11:33 <mib_q875e49s> I'm trying to use wxHaskell. I ran the register.bat and tried to open one of the samples, but it showed an error message 'this application has failed to start because the application configuration is incorrect'. Can anybody help please?
11:11:37 <dons> no, not yet. i hope we'll have a tech talk on it soon.
11:11:44 <gwern> 'k
11:11:46 <dons> gwern: but essentially it looks like: proof f x == g x
11:11:57 <dons> where f and g are say, crypto functions
11:13:44 <kowey> mib_q875e49s: please send a message to wxhaskell-users@lists.sourceforge.net
11:15:18 <rovar> I'm moving back to the west coast. Soon I'll be able to attend the tech talks :)
11:15:23 <rovar> joy
11:17:20 <rovar> after two years of working here, I've learned I'm philisophically at odds with Manhattan
11:18:02 <kowey> huh.. so cabal install -flags "-gui" does what I want, but not cabal install -f-gui
11:19:02 <pumpkin> Taejo: I've been playing with the idea you presented in your beautiful folds blog post! it's a neat idea... have you done anything on it since that post?
11:19:15 <gwern> rovar: how can one be philosophically at odds with a place?
11:22:09 <rovar> gwern, I'm philisophically at odds with the general ideas held by area employers and employees surrounding information technology and how to apply it.
11:22:58 <\stro> hi
11:23:16 <c_wraith> gwern: Have you lived on the east and west coasts?  It's not an unfounded stereotype to say that there are significant regional differences in attitude.
11:23:17 <rovar> specifically, I don't like hacking together quick apps with toothpicks and duct tape using 30 year old technologies
11:23:18 <\stro> is there any library implementing the reactor pattern?
11:23:44 <rovar> \stro: yes
11:24:04 <gwern> rovar: ok, that's more like it :)
11:24:12 <\stro> rovar: greatness! what is it called?
11:24:17 <rovar> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
11:24:26 <gwern> c_wraith: the one time I visited the west it was way too hot and I was too miserable to spend much time chatting with people
11:24:37 <c_wraith> gwern: That's fair enough. :)
11:24:44 <rovar> \stro: also, Haskell supports microthreads, which obviates the need for reactors in most cases.
11:25:16 <rovar> haskell as in GHC :)
11:25:26 <gwern> @quote mstr
11:25:26 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:25:36 <gwern> @remember mstr haskell is like f'gg'fggf'fg'g'fg'foldliftM2 f g ''f' :)
11:25:36 <lambdabot> Nice!
11:25:37 <rovar> gwern, where were you at? Sothern cal?
11:25:41 <\stro> I just liked the monadic handling of concurrent `threads' like in hsxmpp
11:25:45 <gwern> rovar: palm springs
11:25:50 <rovar> ah.. yea
11:25:51 <gwern> @quote simonmar
11:25:51 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:26:03 <gwern> @remember simonmar Wondering how popular Haskell needs to become for intel to optimize their processors for my runtime, rather than the other way around.
11:26:03 <lambdabot> It is forever etched in my memory.
11:26:07 <rovar> SF or Portland are definitely more my stile.
11:26:15 <gwern> @quote christmas
11:26:15 <lambdabot> LoganCapaldo says: all I want for christmas is monad comprehensions
11:26:18 <gwern> @quote christmas
11:26:18 <lambdabot> LoganCapaldo says: all I want for christmas is monad comprehensions
11:26:20 <gwern> @quote christmas
11:26:20 <lambdabot> LoganCapaldo says: all I want for christmas is monad comprehensions
11:26:22 <dons> PDX represent!
11:26:29 <rovar> :)
11:26:31 <gwern> geez. where did byorgey get this week of hwn quotes?
11:26:40 <gwern> @remember quicksilver [about uninstalling packages installed with cabal-install] packages are for life, not just for christmas.
11:26:40 <lambdabot> I will remember.
11:26:55 <gwern> @quote dimensional
11:26:55 <lambdabot> ray says: three dimensional zippers make my scalp hurt when i get my hair caught in them
11:26:58 <gwern> @quote dimensional
11:26:58 <lambdabot> ray says: three dimensional zippers make my scalp hurt when i get my hair caught in them
11:27:12 <gwern> @quote thereal
11:27:12 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
11:27:13 <dons> prob. should stop quoting once the screen is full
11:27:23 <skorpan> @quote skorpan
11:27:23 <lambdabot> skorpan says: i love the layout of lyah. makes me feel like having some chunky bacon.
11:27:23 <rovar> dons, I would move to Portland if I could find work there.  But it seems to have been hit hard by the recent economic dip
11:27:27 <gwern> @remember Ethereal If this conversation had been had in #python #ruby or #php it would have lots of angry people shouting about how it doesn't matter or isn't true or isn't important and what's the point, and no, you guys are like ahhh but no, your preconceived notions of dimensional space are so passe.
11:27:27 <lambdabot> It is stored.
11:27:36 <gwern> @quote monad.*chocolate
11:27:36 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
11:27:41 <gwern> finally!
11:27:56 <gwern> @quote Numerals
11:27:56 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
11:27:57 <lambdabot> arithmetic in Roman numerals.
11:28:03 <gwern> @quote Numerals
11:28:04 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
11:28:04 <lambdabot> arithmetic in Roman numerals.
11:28:16 <Raevel> soon, we won't have to make up new sentences to write, lambdabot can keep the channel alive by itself
11:28:19 <gwern> @remember jfredett I do all of my version numbers in Roman Numerals...
11:28:20 <lambdabot> I will never forget.
11:28:35 <gwern> @quote applied.*logic
11:28:35 <lambdabot> No quotes match. Sorry.
11:28:37 <c_wraith> woo, pdx! Um, I'm only a bit late with that.
11:28:42 <gwern> @remember Cale But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
11:28:42 <lambdabot> It is stored.
11:28:42 <rovar> Raevel: we need another instance of lambdabot so that the two may converse
11:28:47 <gwern> @flush
11:28:48 <gwern> @flush
11:29:43 <dons> gwern: plz do it in a side channel
11:29:45 <gwern> http://rubinmcgowaneh.blogspot.com/2009/03/irradiation-tracing-in-haskell.html <-- the english in this makes my head asplode
11:29:52 <Saizan> gwern: or query.
11:30:20 <c_wraith> that feels machine-translated
11:30:24 <rovar> yes
11:30:32 <Taejo> pumpkin: I have not... it seems to me to be one of those ideas that is fun to discover, but don't actually lead to all that much. Perhaps you have found different?
11:30:47 <gwern> c_wraith: I certainly hope so
11:31:00 * gwern has a sudden urge to write a beam tracer
11:31:12 <rovar> gwern, on the upside, this introduces an entirely new genre of technology topics
11:31:37 <rovar> "And there you travel: a beam tracer! Naturally, there are many things that ought to be amend."
11:31:46 <pumpkin> Taejo: I exploded my head yesterday trying to make a nice elegant set of combinators (that support foldl1-equivalents in conjunction with regular foldls) and thinking of ways to trick the system into rewriting stuff... I need to do real work today so have given it a break,  but I'll let you know if I get anywhere :P
11:31:50 <rovar> that is priceless babelfishery
11:32:21 <Taejo> pumpkin: cool
11:32:35 <pumpkin> Taejo: the foldl1s are mostly needed for things like maximum and minimum, but my interest at this point is mostly to see if I can do it :P
11:33:30 <edwardk> gwern: that guy's english does make my head spin
11:34:04 <byorgey> hah, wow, I didn't even read that before putting it in the HWN =)
11:34:05 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:20 <edwardk> it seems like a babelfish translation or something
11:34:27 <byorgey> yeah, definitely
11:34:34 <gwern> it's just so strange. it's not the misspellings or odd puncutation, it's that so much of it is done grammatically correct - but in an utterly alien idiom
11:34:58 <byorgey> "exlipcate the procedure I locomoted through" ?
11:34:58 <rovar> @remember Babelfish And there you travel: a beam tracer! Naturally, there are many things that ought to be amend.
11:34:58 <lambdabot> Done.
11:35:17 <vixey> this is wonderful
11:35:20 <rovar> exlipcate?
11:35:22 <byorgey> er, explicate
11:35:25 <byorgey> =)
11:35:29 <rovar> oh.. that's not as interesting :)
11:35:30 <edwardk> rovar: hah beat me to it
11:35:48 <gwern> but, I dunno. if it was machine-translated, wouldn't it have gotten exlipcate right?
11:35:59 <edwardk> it might not be babelfish he has a whole site full of that sort of thing
11:36:01 <pumpkin> inexplicatable choices contributioning to his verbiage
11:36:09 <vixey> it's just written by a complete maniac
11:36:09 <edwardk> -- I consider the church involves this revelatory Christological center of gravity to avoid getting functionally solipsistic.
11:36:22 <gwern> I mean, correcting that to 'explicate' is utterly trivial once your program can translate that well
11:36:30 <gwern> vixey: which restores its interest then
11:36:32 <byorgey> gwern: I just copied it wrong
11:36:47 <gwern> oh :(
11:36:47 <byorgey> it does say explicate
11:36:56 <vixey> "would n't"
11:37:12 <gwern> vixey: that is kind of logical
11:37:18 <vixey> logical???
11:37:24 <vixey> it's bonkers
11:37:52 <edwardk> maybe he runs it through the equivalent of a jive filter?
11:37:53 <gwern> not at all. why shouldn't there be a space there?
11:38:05 <edwardk> its all remarkably consistent
11:38:06 <gwern> they're 2 different words - would and not
11:38:15 <vixey> but wouldn't is one word
11:38:32 <vixey> or is it ?
11:38:51 <rovar> he's like Da Vinci, except instead of writing backwards, he obfuscates via babelfish so he is not discovered.
11:38:52 <gwern> see?
11:39:16 * bremner hands the channel an "English as a third language" text
11:40:08 <edwardk> heh
11:40:54 <gwern> bremner: but, I mean, how can you write a ray tracer and call it a beam tracer?
11:42:01 * edwardk is tempted to write a little program using one of the haskell NLP tools that just rewrites text randomly choosing something from the synonym list every few words
11:42:28 <gwern> (how do you understand the math well enough, know what to call it, write a working prototype, and so on - and mess up on the first word? it'd be like me learning french and going on about czar sarkozy; correct in a way, but also horribly peculiar)
11:42:56 <rovar> yea.. the window title is Ray Tracer
11:43:16 <bremner> this is one of those "true because vacuous things", since I'm about as likely to write a ray tracer as run the ironman
11:43:18 <rovar> so it's like he wrote it in english then translated it to Russian, then back to english (which is a fun way to kill time)
11:43:26 <jedai> gwern: Given the character I believe your "czar Sarkozy" would just be taken as irony
11:46:20 <rovar> jedai: maybe  "Fuhrer Netanyahu" would be a better example :)
11:46:55 <gwern> no, that's no good either. those political movements are too closely linked with fascism
11:47:31 <bremner> @remember RWH Beware of fail
11:47:31 <lambdabot> Done.
11:47:45 <wli> Jabotinski
11:48:52 <jedai> rovar: Right :/
11:53:50 <rovar> @type mapM_
11:53:51 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:54:16 <HECK7> Enter text here...
11:57:43 <Gracenotes> fromJust is justified finding in an infinite list, right?
11:57:55 <Gracenotes> @type find
11:57:56 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:57:59 <rovar> hrrm..
11:58:02 <skorpan> @src fromJust
11:58:02 <lambdabot> fromJust Nothing  = undefined
11:58:02 <lambdabot> fromJust (Just x) = x
11:58:16 <Gracenotes> no reason why it should fail
12:01:16 <b_jonas> Gracenotes: yes, I think so
12:02:57 <harovali1> it is funny that one starts learning haskell under the "no side effects" banner, and then, all real world examples are main :: IO()  :-)
12:03:32 <vixey> probaby your definition of real world
12:03:33 <kynky> using that *world* word agai
12:03:35 <kynky> n
12:04:00 <dons> harovali1: the goal is to minimize effects, to enable more fun things like parallelism and safety
12:04:15 <dons> but yes, it is kind of funny that the only way into a haskell program is through IO ()
12:04:43 <gwern> I've seen people say things like that, but I've never understood. what on earth other way could there be?
12:04:46 <rovar> i find I often need to pass the result of retrieving an item from a record from the state in a  StateT
12:04:51 <Gracenotes> gwern: lazy lists!
12:04:55 <kynky> not to minimize them, but put all the side effects in one big monad bag and not scattered everywhere
12:04:56 <rovar> is there a common idiom for this?
12:05:18 <gwern> Gracenotes: ?
12:05:19 <Gracenotes> rovar: 'gets rfunc'
12:05:19 <dons> gwern: you could imagine Main.hs being a reactive program
12:05:26 <dons> where you set up only pure handlers for messages
12:05:33 <Gracenotes> rovar: where 'rfunc' is the record function, like rfunc :: Type
12:05:45 <gwern> dons: but isn't that still IO? 'main = interact (unlines . lines)' is still IO after all
12:06:06 <dons> sort of. if you imagine that part boiled off
12:06:11 <rovar> Gracenotes: that's.. beautiful
12:07:02 <rovar> prettier than (get >>= liftM rfunc)
12:07:03 <rovar> :)
12:07:45 <C-Keen> I am trying to build unix-2.3.2.0 with ghc 6.10 and it fails in System/Posix/Internals.hs:10:17 complaining that GHC.Conc does not export 'Signal'. How can I fix it?
12:09:42 <gwern> A new challenger appears!
12:10:16 <Saizan> C-Keen: you really need base-4.1 that comes with ghc-6.10.2 for that version of unix
12:11:31 <tibbe> I'm trying to find all resumable parsers, parsers that return a continuation when they need more data, out there. I've only found binary-strict so far. Any others?
12:11:38 <C-Keen> how nice, it seems I have entered dependency hell
12:12:02 <b_jonas> isn't unix in ghci-extralibs?
12:12:43 <yakov> hey
12:12:43 <tumdum> @help pl
12:12:44 <lambdabot> pointless <expr>. Play with pointfree code.
12:13:01 <tumdum> @pl foldr ((const . const) False) True
12:13:02 <lambdabot> foldr (const (const False)) True
12:13:45 <EvilTerran> = null, i think?
12:13:52 <tumdum> yes
12:14:15 <Gracenotes> @type foldr ((const . const) False)
12:14:16 <lambdabot> forall b. Bool -> [b] -> Bool
12:14:39 <Gracenotes> ah
12:16:49 <tibbe> dons: I'm not sure if Hackage is building packages
12:16:58 <tibbe> dons: or it's lagging a lot :)
12:20:24 <mmorrow> tibbe: i've noticed this too
12:20:41 <rovar> it's got conficker
12:20:42 <tibbe> mmorrow: hmm
12:21:45 <dons> sunday's seem to be bad
12:21:49 <dons> maybe it's a cron job
12:23:05 <raxas_> with hackage being a single critical point of failure, maybe haskell people should reinvent mirrors
12:23:09 <Gracenotes> hrm. is there a flip liftM (or flip fmap, flip <$>) for expressions with long lambda abstractions?
12:23:14 <Gracenotes> in the manner of forM, etc.
12:23:23 <vixey> :t flip liftM
12:23:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> r) -> m r
12:23:30 <Beelsebob> Gracenotes: (<$> ....)?
12:23:48 <Gracenotes> hm. I suppose that'd work, with a $ after it
12:24:17 <Gracenotes> thanks. it's not terribly clear though
12:25:08 <b_jonas> if a haskell module lacks export declaration, does it only names it defines locally, or also names it imports from modules?
12:25:26 <mauke> I think the former
12:26:02 <b_jonas> I'd prefer the latter for what I'm doing now, but I'm not sure which one is better in general
12:27:26 <dons> what's a good word for something that is 'self optimizing'
12:27:39 <b_jonas> adaptive
12:27:43 <dons> ah ha :)
12:27:49 <dons> b_jonas wins a prize!
12:28:05 <dons> though i want it in the sense of statically adaptive
12:28:14 <dons> that'll do for now though
12:28:21 <b_jonas> np
12:28:40 <Gracenotes> dons: synergetic
12:28:42 <Gracenotes> *ducks*
12:29:08 <gnuvince_> "self optimizing" sounds a bit new age/self help book
12:29:23 <gnuvince_> psychic medium/healer maybe? ;)
12:29:38 <dons> so the idea is: user takes a polymorphic structure, picks the component types, library then picks the actual representation that works best
12:29:45 <dons> so say, [Bool] => BitSet
12:29:55 <dons> but the user only ever sees [Bool] interface
12:30:16 <dons> so the container type adapts to the component, statically
12:30:24 <dons> hmm. 'specializing'
12:30:38 <gnuvince_> dons: would a type error refer to [Bool] or to BitSet?
12:30:44 <Gracenotes> well, specializing is [a] -> [Bool]
12:30:55 <Gracenotes> I guess it's.. further specializing? >>
12:30:58 <dons> so this is super specializing. ([] Bool) -> BitSet
12:31:15 <dons> gnuvince_: you'd see it in terms of the class
12:31:19 <dons> but good questoin
12:31:21 <ddarius> What's wrong with "self-specializing?"
12:31:43 <dons> Data.SelfSpecializing.List ?
12:31:45 <EvilTerran> concretising?
12:31:49 <dons> Data.Adaptive.List ?
12:31:55 <vixey> Data.Optimizing.List
12:34:19 * edwardk arches an eye at BitSet given his current coding fixation.
12:34:30 <dons> hey. ... it's a monoid!
12:34:54 <edwardk> dons: actually its a semiring ;)
12:35:05 <ddarius> which is a monoid
12:35:13 <rovar> blarg
12:35:20 <edwardk> dons: any ideas how to make http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Ring-Semi-BitSet.html faster?
12:35:21 <dons> have you included bitset in your package?
12:35:30 <edwardk> i just rewrote it
12:35:48 <dons> mm
12:35:53 <edwardk> i had data.bitset as a dependency but i found ways to extend it and add a lot of functionality for complemented sets, etc.
12:36:00 <dons> the only bitsets i've played with are bit arrays
12:36:03 <dons> fusible ones.
12:36:11 <dons> but i think they have the wrong complexity for what you need
12:36:25 <rovar> what am I doing wrong? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3370#a3370
12:36:39 <edwardk> this guy is basically just using Integer as a glorified bit array, and tracking the exponent manually, because fromEnum can return negative values.
12:36:47 <edwardk> which the bitset code that was in hackage failed to manage
12:37:14 <vixey> rovar: using names like 'msg' instead of 'message'
12:37:16 <edwardk> it works really well for sets with lots of clustered values
12:37:20 <dons> hmm. using Integer as a bit array is probably non-optimal
12:37:32 <dons> uvector , UArr Bool would be faster (not a pinned structure)
12:37:50 <edwardk> I looked at UArr Bool but it didn't look packed
12:38:13 <edwardk> that means i'd spend several times the amount of space on it
12:38:25 <rovar> vixey: what's wrong with msg?  It's very clear to me that that universally means "message" but it takes up less space.
12:38:37 <edwardk> or did i misread the source code for uvector?
12:38:42 <dons> edwardk: yeah, it is entirely bit packed
12:38:54 <edwardk> it is? hrmm.
12:39:03 <kadaver> cant you do a fromData (_ v) = v, ie one for all, do you need to specifically pamtch against each instance of it?
12:39:04 <edwardk> going back to look again
12:39:04 <dons> the code. let me find it.
12:39:22 <vixey> rovar: same with plr instead player stuff that like, bad habit
12:39:32 <rovar> okay.. that one is a bit worse
12:39:34 <edwardk> i scanned uvector hoping to use it but when i looked at the UArr Bool instance it didn't seem to do anything special
12:39:35 <dons> look for Bool in this http://code.haskell.org/%7Edons/code/uvector/Data/Array/Vector/Prim/BUArr.hs
12:39:47 <dons>     case readWordArray# mba# j# s#                of {(# s2#, v# #) ->
12:39:47 <dons>     case if e# then v# `or#`  bOOL_BIT     i#
12:39:47 <dons>                else v# `and#` bOOL_NOT_BIT i#     of {v'#
12:39:49 <dons> in particular
12:40:01 <rovar> either way.. (gets gm_players) == Players
12:40:03 <edwardk> ah
12:40:10 <dons> edwardk: uvector uses associated data types to hide the representation type decision
12:40:13 <edwardk> i was looking a level up
12:40:24 <dons> so UArr Bool looks nice, but it's actually calling down into an underlying bit packed type
12:40:42 <dons> should be identical to a STUArray Bool, fwiw
12:40:47 <edwardk> alright, then is there a way to quickly and/or together uarrs of bools?
12:41:10 <dons> zip or ?
12:41:16 <dons> should fuse. good test!!
12:41:16 <edwardk> zip would go bitwise
12:41:21 <edwardk> i want to run through the words
12:41:21 <dons> yes.
12:41:31 <mmorrow> that would be handay
12:41:33 <Gracenotes> @hoogle modexp
12:41:33 <tibbe> edwardk: is bitset = byteset (e.g. 255 possible values)?
12:41:33 <lambdabot> No results found
12:41:36 <Gracenotes> :O
12:41:37 <dons> possible. never tried
12:41:43 <dons> we'd have to coerce to a UArr Word32
12:41:44 <dons> or something
12:41:55 <edwardk> tibbe: mine? no. can handle as large of a bitset as you can fit into an Integer on your machine
12:42:09 <tibbe> edwardk: oh, more like a bloom filter?
12:42:29 * mmorrow loves that he's finally on 64bit
12:42:31 <edwardk> tibbe: yeah actually this was a first step towards me putting together a nice monoidal bloom filter
12:42:39 <tibbe> edwardk: ah
12:43:03 <edwardk> tibbe: basically it tracks the index of the first element as an exponent and stores the bits of the mantissa as an integer
12:43:20 <edwardk> tibbe: the bloom filter instance would be a lot simpler actually
12:43:24 <dons> edwardk: ah so bos' nice bloomfilter isn't monoidal?
12:43:54 <edwardk> dons: fraid not, the type doesn't reflect knowledge of the hash function set used or the bucket count
12:44:08 <edwardk> dons: i can use the Data.Reflection stuff to pack that into a type level brand
12:44:20 <tibbe> edwardk: I see
12:44:28 <mmorrow> heh "brand"
12:44:33 <dons> mm
12:44:35 <dons> nice term
12:44:38 <edwardk> dons: besides i never ported by sorted linear bloom filters down to haskell from c#
12:45:46 <edwardk> dons: i've started using them all over the place now. i have a monoid for regex evaluation that brands itself with the regex object in question, a special reducer that turns any monoid into a branded reducer with a specified function, etc.
12:46:25 <edwardk> a simple modular arithmetic monoid that brands itself with the modulus, basically transcribed from oleg and shan's implicit configurations paper, etc.
12:46:48 <edwardk> er s/ported by/ported my/
12:47:41 <bindreturn> what would I use as an alternative to foldM to fold right associative  ?
12:47:46 <b_jonas> IT WORKS!
12:48:09 <edwardk> dons: so as it stands if i switched to uvector i'd basically grind to a performance crawl fiddling with bitwise ands and ors?
12:48:27 <b_jonas> I'm writing a module that lets me add arbitary declarations (data, type, newtype, instance, class etc) in a ghci session
12:48:32 <b_jonas> and it seems to work now
12:48:47 <edwardk> bjonas !?
12:49:01 <vixey> cool
12:49:01 <edwardk> how's it work?
12:49:01 <b_jonas> now I'll have to make it more tolerant to errors in those declarations:
12:49:18 <b_jonas> wait, I'll paste the current state so you can check it
12:49:23 * edwardk watches b_jonas complete our repl
12:49:58 <b_jonas> I'll have to allow erasing at least the last declaration, and perhaps automatically erase it if there's a syntax error
12:52:34 <b_jonas> http://erxz.com/pb/16834
12:52:42 <edwardk> dons: ok, so with the uvector stuff, BUArr has two integers at the top are those the size of the underlying array or the number of elements? or both?
12:52:46 <b_jonas> header comments contain instructions
12:52:59 <dons> size and elems, yeah
12:53:01 <dons> size in bytes.
12:53:02 <b_jonas> you have to save the module somewhere and add three lines to your .ghci to use it
12:54:04 <edwardk> ok, so with a little bit of magic i could just swizzle a BUArr Bool into a BUArr Word32 by swapping those and rescaling the second element? is there magic with regards to GC for ByteArray#s?
12:55:26 <dons> yep
12:55:27 <b_jonas> tell me if it works for you please. I'm using ghc-6.10.2
12:55:27 <edwardk> and would such a reshuffling rely on some magic behavior of ByteArray#'s rounding up to some integral number of words in length?
12:55:29 <dons> you can exactly do that.
12:55:48 <dons> you might have to be careful with the size, since BUArr Bool is in Word8 arrays
12:55:59 <dons> shows how to drop down to the fast level of array ops though
12:56:08 <edwardk> yeah
12:56:41 <edwardk> so is the right answer to just work with a BUArr of Int and index myself or to work with BUArr Bool and let you fuse things like counts, etc?
12:56:52 <edwardk> er BUArr Word32
12:57:10 <mmorrow> i wonder if the new AlignedByteArray# would be useful for anything here
12:57:11 <thomastc> b_jonas: sounds cool. maybe there should be some kind of :list command to show all decls
12:57:16 <dons> probably you'd want an aligned array type
12:57:27 <dons> then similar class operations to uvector, for moving between words and bits
12:57:28 <thomastc> b_jonas: and a way to remove arbitrary ones too
12:57:33 <b_jonas> thomastc: there is, it's called showdecl
12:57:48 <b_jonas> thomastc: :showdecl lists, :decl adds any
12:57:57 <thomastc> ah cool :)
12:58:03 <edwardk> the thing that is kind of making me ill here is that the gmp operations are nicely optimized, SIMD, etc. not sure we're there yet ;)
12:58:05 <kadaver> is it possible to passa round the actual data? ie data X = Y String | Z String. Z "hello"?
12:58:10 <thomastc> reminds me of the old BASIC days :)
12:58:24 <edwardk> dons: but i'd happily be proven wrong
12:58:59 <dons> yes. it would be cool to know if gmp was doing something smart
12:59:47 <edwardk> well, gmp knows that we asked it to and/or, and has a nice array to smash bits over.
12:59:58 <Gracenotes> hm. is there an elegant way to turn a sorted list of index/value pairs into a list? [(Int, a)] -> Int -> [a], the second arg being the length
13:00:29 <edwardk> is there a reason for the selection of a Word8 array for Bool? that seems awfully fine grained, do you gain anything from the small grain size?
13:00:34 <dons> {-# LANGUAGE TypeFamilies, MultiParamTypeClasses #-}
13:00:35 <dons> woo
13:00:46 <dons> edwardk: i think it makes no sense :)
13:01:42 <kadaver> if I have X that can be Z or Y. can I do (dataOf SOmevar) "hello" ?
13:01:53 <b_jonas> edwardk: the representation in memory is all the same and the optimized compiled code will use the bit array instructions on x86 anyway and those actually access the array word-wise
13:02:04 <kadaver> to make "hello" -> Z "hello" or Y "hello" ?
13:02:11 <dons> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3373#a3373 adaptive tuples
13:02:29 <dons> so, straight forward use of type families to pick representation types
13:02:36 <dons> now, how to make this useful.
13:03:02 <sjanssen> dons: you need a construction function as well
13:03:04 <mauke> kadaver: only if you write dataOf first
13:03:14 <dons> ah yes :)
13:03:17 <kadaver> is this legal: typeOf (GET v) = GET ?
13:03:21 <sjanssen> dons: but this is a clever idea
13:03:30 <dons> i think it will be most interesting on containers
13:03:41 <dons> where say, IntMap Int can remove one layer of indirection through the entire structure
13:03:46 <sjanssen> dons: will GHC actually unpacked nested applications like (Pair a (Pair b c))?
13:03:55 <edwardk> dons: that fixes your 'you can't make that polymorphic' kind of optimization problems, no? at least for the interesting cases
13:04:02 <mauke> kadaver: yes
13:04:03 <dons> sjanssen: yeah
13:04:18 <dons> edwardk: i think so.
13:05:05 <dons> and just as TH gets type family support
13:05:31 <sjanssen> dons: hmm, you're going to have to write O(n^2) instances with this approach
13:05:44 <dons> yeah, I think I need TH...
13:05:49 <b_jonas> I think I'll add line numbers listed in :showdecl and let you remove a declaration by number
13:05:52 <dons> there's what, 8 atomic types I care about?
13:06:06 <mmorrow> yeah, type families and TH is exciting
13:06:13 <edwardk> b_jonas: I just want to zipWith (&&) a pair of UArr Bool's and see it give me a nice superword level ands strided over the array -- and i want a pony. but i've already installed pony and it was a unicorn.
13:06:16 <b_jonas> so :undecl will remove the last line, :undecl 5 will remove line 5, and say :cleardecl will remove all lines
13:06:17 <mmorrow> GADTs will be also once they come around
13:06:37 <sjanssen> dons: you can get O(n) instances if you change things a bit
13:06:46 <b_jonas> it's easier than trying to implement searching the right declaratoin by name
13:06:48 <sjanssen> represent (a, b) as Pair a (Pair b ())
13:06:49 <dons> sjanssen: oh?
13:06:57 <dons> mm
13:07:00 <dons> clever
13:07:04 <edwardk> dons: TH support for type families isn't in 6.10.2 its going in in like 6.12 no? chakravarty implemented it the other week or so
13:07:08 <sjanssen> (standard HList representation)
13:07:09 <dons> edwardk: right
13:07:18 <dons> sjanssen: good idea. i'll see how the representations pan out
13:07:29 <b_jonas> edwardk: maybe try to interface the bitvec class from the c++ stdlib and hope it's optimized?
13:08:00 <edwardk> b_jonas: i think i may stick with Integer and rely on the fact that gmp does something smart until someone bitches about performance, since i at least have all the asymptotics fixed ;)
13:08:12 <agcorona> hi
13:09:00 <edwardk> still find it weird that there is no intrinsic way to find the largest bit set in an Integer and i had to concoct that goofy infinite range search.
13:09:06 <paolino> b_jonas: works on 6.10.1
13:09:18 <b_jonas> edwardk: gmp has a function for that I think
13:09:19 <edwardk> er rather the largest non-tail bit in an Integer.
13:09:21 <b_jonas> paolino: thanks
13:09:33 <sjanssen> dons: actually, I think my idea is bogus
13:09:48 <tibbe> dons: what can I use to parse bytestrings to Int64?
13:10:03 <dons> readInt ?
13:10:05 <mmorrow> b_jonas: are you using external files to simulate adding decls to the current cxt, or talking to ghc with the ghc-api, or?
13:10:23 <b_jonas> mmorrow: writing an external file
13:10:26 <dons> tibbe: and then patch it for other Int* types, add it to the bytestring-lexing package
13:10:31 <edwardk> b_jonas: yeah, but i haven't yet seen the way to easily swizzle an Integer into a gmp integer. I saw the GHC.Integer.Internals stuff has the J# constructor which has the limb count and the limbs as a ByteArray#, but from there i'd have to smash it around to get it into a form i could call the c API from.
13:10:41 <mmorrow> b_jonas: ah, interesting.
13:10:42 <edwardk> b_jonas: and that seems kind of like the wrong tool for the job.
13:12:11 <mmorrow> b_jonas: rwbarton did something similar a while back, but i'm not sure if his code is findable anymore.
13:12:12 <b_jonas> edwardk: it might be the wrong tool, but I don't want to mess with the ghc api
13:12:23 <mmorrow> speaking of rwbarton, i haven't seen him around here lately
13:12:33 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3374#a3374 <- Warning: This package indirectly depends on multiple versions of the same
13:12:33 <kadaver> package. This is highly likely to cause a compile failure.
13:12:40 <kadaver> how do I solve that(it works for me btw)?
13:12:58 <edwardk> @hpaste
13:12:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:13:34 <edwardk> b_jonas: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3375#a3375 is what i wound up doing instead
13:13:46 <mmorrow> b_jonas: yeah, using the ghc-api consists mostly of reading the code/misc other parts of ghc, then figuring out how to hack it :)
13:14:21 <b_jonas> ok, here's the same with the docs updated a bit: http://erxz.com/pb/16835
13:14:29 <b_jonas> it seems that include qualified also works now
13:15:05 <kadaver> {-# LANGUAGE ScopedTypeVariables #-} <- I had to add that once but dont remember why. now if I delete it it works fine. but is it possible that changes the behaviour of my program or the compiler will always react if it is needed and isnt there?
13:15:28 <edwardk> why the c style { }'s?
13:15:37 <b_jonas> anyway, it's getting late so I won't do the deletion part today
13:15:52 <paolino> b_jonas: a command to dump the GhciDecl.hs elsewhere would be nice
13:16:02 <edwardk> kadaver: the only time i could see if causing a problem that the compiler wouldn't react to is if you have incoherent instances
13:16:10 <kadaver> fromRequest (_ v) = v
13:16:10 <kadaver> fromRequest (GET v)  = v
13:16:17 <kadaver> why isnt the first one legal?
13:16:18 <b_jonas> paolino: currently the filename is shown if you say :showdecl so you can copy it
13:16:54 <b_jonas> I think I could probably detect errors in the declarations and maybe make it so that if a line you try to declare introduces an error then it's deleted immediately
13:16:56 <edwardk> kadaver: coz the ghc team hasn't come up with a name for a suitable language extension? =)
13:17:41 <kadaver> it seems like a fairly basic need...
13:17:41 <b_jonas> but I'll implement the normal command for deleting any one line first of course
13:17:47 <b_jonas> edwardk: I just like those
13:17:55 <dons> sjanssen: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3373#a3376 so now just need the TH to generate the rest of the instances
13:18:14 <dons> TH supports UNPACK, INLINE and type families , so should be ok.
13:18:34 <edwardk> ok. its not as bad as the numerical prelude -- just strange ;)
13:20:02 <mmorrow> yeah, the addition on UNPACK and INLINE is also really nice
13:20:43 <edwardk> dons: hrmm. i'm curious if using fromPair in a view pattern would optimize away.  foo (fromPair -> (a,b)) = ...
13:21:08 <edwardk> that would let you use those almost idiomatically
13:21:30 <dons> mm
13:21:33 <b_jonas> edwardk: I see. well I don't really have a good idea for that now.
13:21:33 * mmorrow dreams of the day that TH can do TH
13:22:00 <sjanssen> edwardk: I was just about to try a self-adapting tree using view patterns :)
13:22:07 <mmorrow> can do TH can do TH...
13:22:40 <dons> some strong medicine that's about ready for prime time: view patterns + type family adaptive structures
13:22:43 <edwardk> sjanssen: view patterns to let you traverse a split of it?
13:23:03 <sjanssen> class Treeable a where data Tree a split :: Tree a -> Maybe (Tree a, a, Tree a)
13:23:11 <edwardk> yeah
13:23:26 <edwardk> actually i have code for that that isn't in the Monoid lib yet for writing idiomatic parallelism code
13:23:29 <sjanssen> edwardk: that, and pray that GHC sufficiently optimizes the Maybe away
13:25:01 <b_jonas> hmm
13:25:20 <edwardk> in my case smashing down to 3 cases a data Par a = Nil | Leaf a | a :++: a -- class Parallel a where ...
13:25:35 <skorpan> i don't suppose there is anything in haskell-mode which lets me hide all function types on the fly?
13:25:56 <edwardk> the thought was i could take any generator in my monoid lib and provide a view pattern based on that that let you ask for recursive subdivision
13:26:16 <b_jonas> if this ghc extension allows a general pattern bind like "| pat <- expr" where "| cond" becomes a special case of "| True <- cond", then wouldn't it also make sense to allow "if pat <- cond then foo else bar" where "if cond" is a special case of "if True <- cond" ?
13:26:19 <sjanssen> did view patterns in GHC go with the Maybe and tuple sugar in the end?  I can't remember
13:26:25 <edwardk> the other piece i'm trying to do is see if i can use Data.Reflection to build a type-level brand for particular parallel chunking strategies
13:26:36 <sjanssen> b_jonas: at that point, why not use a case?
13:26:48 <edwardk> sjanssen: they just view down to any type iirc
13:27:14 <edwardk> foo (view -> bar) = ...  is equivalent to foo x = case view x of bar -> ...
13:27:45 <b_jonas> sjanssen: for a Maybe, "if Just (x, y) <- c then x * y else b" is shorter than "case c in { Just (x, y) -> x * y; _ -> b }"
13:27:54 <b_jonas> but yeah, usually you would use a case
13:28:36 <edwardk> b_jonas cute syntactic hack
13:29:06 <sjanssen> > length "if Just (x, y) <- c then x * y else b"
13:29:07 <lambdabot>   37
13:29:13 <b_jonas> anyway this pattern guard extension is useful already, it will allow me to write ugly code with lots of inline lambdas as I can put pattern matches to lambda guards
13:29:21 <Deewiant> Apparently quite a lot of people have figured out that such syntax would be nice
13:29:23 * edwardk refrains from saying that the latter is only longer because b_jonas runs the {}'s down across the next 4 lines ;)
13:29:23 <sjanssen> > length "case c of Just (x, y) -> x * y; _ -> b"
13:29:24 <lambdabot>   38
13:29:35 <sjanssen> b_jonas: okay, one character
13:29:49 <b_jonas> sjanssen: yeah, and I wrote case..in instead of case..of again
13:30:15 <sjanssen> b_jonas: the brackets don't count because they're not required
13:30:45 <edwardk> ok, playing devil's advocate b_jonas's syntax would start to be a bigger win as you added more clauses.
13:30:52 <mun> hi
13:31:02 <mun> what does the Just keyword mean?
13:31:08 <edwardk> if Just (x,y,z) <- a, Foo (bar,baz) then ... else ...
13:31:15 <sjanssen> mun: it isn't a keyword, it's a data constructor
13:31:20 <sjanssen> @type Just
13:31:21 <lambdabot> forall a. a -> Maybe a
13:31:24 <edwardk> er Foo (bar, baz) <- ...
13:31:36 <b_jonas> by the way, could you recomment a good name for this GhciDecl module I'm writing?
13:31:44 <b_jonas> a hierarchical module name that is
13:32:02 <sjanssen> mun: it is a constructor of the 'Maybe a' type, which you use when you might have a value (represented as "Just value") or you might not (represented as "Nothing")
13:32:08 <b_jonas> mun: it's not a keyword, it's a constructor of the Maybe type, it's the same as SOME in standard ml
13:32:31 <mun> i see
13:32:32 <mun> thanks
13:32:55 <edwardk> mun: just is 'just' a constructor like any other. you can make up your own constructors. data Color = Red | Green | Blue -- makes up three of them
13:33:35 <edwardk> @src Maybe
13:33:35 <lambdabot> data Maybe a = Nothing | Just a
13:34:29 <cristi_ceata> hi! can anyone tell me how to edit my ~/.vimrc file so I can indent lines accordingly to the Haskell syntax ?
13:35:17 <rovar> google for haskell.vim, put that file in  .vim/ftplugin
13:35:29 <edwardk> cristi_ceata: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3377#a3377 is what i use
13:35:41 <cristi_ceata> thanks!
13:35:50 <edwardk> its not all that earthshaking. but expandtab and smarttab are probably your most important pieces.
13:36:03 <RayNbow> @unmtl ListT (State s) a
13:36:04 <lambdabot> s -> ([a], s)
13:36:07 <RayNbow> @unmtl StateT s [] a
13:36:07 <lambdabot> s -> [(a, s)]
13:36:27 <vixey> @unmtl StateT [s] [] a
13:36:27 <lambdabot> [s] -> [(a, [s])]
13:36:28 <RayNbow> hmm
13:36:30 <edwardk> the f11 stuff just lets me paste without comments mucking me up
13:37:20 <RayNbow> in ListT (State s) a... how is the state threaded?
13:37:40 <edwardk> RayNbow: listT is generally not as good as you'd like it to be
13:37:46 <edwardk> its not a true monad transformer
13:37:58 <edwardk> see ListT done right in the haskell wiki
13:38:23 <vixey> RayNbow: I guess that the state doesn't get reset when you backtrack with that
13:38:40 * RayNbow opens http://www.haskell.org/haskellwiki/ListT_done_right
13:38:48 <b_jonas> what I'm not sure is how I'd make ghci remove the temp module when it exits
13:38:49 <vixey> I kinda prefer LogicT over ListT
13:38:51 <RayNbow> btw, Google doesn't like ListT as a search keyword :p
13:39:11 <b_jonas> currently this just leaves junk in /tmp
13:40:43 * tibbe wishes Maybe could be PACKED using (#tag, value#)
13:40:48 <tibbe> UNPACKED rather
13:41:07 <sjanssen> tibbe: what would value be?  _|_?
13:41:18 <tibbe> sjanssen: yes
13:41:20 <sjanssen> when tag == nothingTag
13:41:23 <dons> the hard part is value# when bottom.
13:41:41 <b_jonas> and I add to the todo that I have to make it use the env-var TMPDIR if it exists
13:41:45 <tibbe> dons: any value? as long as it's not visible to the programmer
13:41:57 <dons> any value with the same storage requirements I guess. nullPtr basically
13:41:59 <tibbe> dons: it's like a discriminate union in C
13:42:13 <b_jonas> anyway, if you know a good name for this module http://erxz.com/pb/16835 or have any comments, tell me (or leave me a memo if I leave). thanks.
13:42:20 <sjanssen> dons: well, it's easy if value is not an unboxed type
13:42:21 <kadaver> did you read Jon Harrop's latest article? apparently a an implementation of ant colony optimization done by a bunch of researchers is 225 times faster in F# than the Haskell-version dobe by a 8-year-old, thus F# is 225 times better than haskell!
13:42:24 <tibbe> dons: I'm having a bunch of Maybe Int
13:42:41 <dons> kadaver: heh
13:43:08 <RayNbow> edwardk: if ListT is broken, will it be replaced/fixed in the future? :)
13:43:15 <rovar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3378#a3379  <-- still stuck on this.
13:43:29 <dons> kadaver: he loves Harrop Product X vs Y for all Y
13:43:41 <rovar> the last error.. not the middle one.. i'm trying to figure out why gets is expecting a Player object instead of Players
13:43:47 <rovar> it's probably something stupid I did
13:44:36 <vixey> kadaver: heh
13:45:02 <edwardk> RayNbow: no one except oleg seems to care about the the kind of interleaved IO problems that emerge from using a ListT like approach
13:45:38 <dons> sjanssen: i love how vacuum shows precisely that the unboxing of pairs is working :)
13:47:03 <b_jonas> good night now
13:47:07 * edwardk <3 vacuum
13:47:14 <vixey> edwardk: oleg and me too :p
13:47:16 <mmorrow> :)
13:47:33 <BMeph> mmorrow++
13:47:33 <edwardk> unfortunately last time i tried to install vacuum-ubigraph it blew up because of haxr/http not being happy with each other
13:47:34 <dons>     Wrong category of family instance; declaration was for a data type
13:47:53 <edwardk> dons ?
13:48:04 <edwardk> trying the TH thing?
13:48:09 <BMeph> dons: That was for rovar, right? :)
13:48:21 <dons> just a new error msg i've not encountered before
13:48:25 <dons> yay for new parts of the compiler
13:48:37 <rovar> heh
13:48:38 <BMeph> dons: Oh, NM, then. Have fun... ;)
13:48:48 <rovar> that's good. because I had no idea what he was talking about
13:48:55 <dons> hehe
13:49:29 <rovar> @type gets
13:49:30 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
13:49:49 <BMeph> Just curious, but has anyone (else) tries recompiling Gtk2hs with (GHC) .2?
13:49:56 <BMeph> *treid
13:50:00 <edwardk> vixey: i'm also kind of annoyed by it but i haven't come up with a nice monad or whatever that can deal with tracking those resources.
13:50:00 <BMeph> **tried
13:50:22 <mmorrow> BMeph: not yet, but that's on my short list
13:50:36 * edwardk say newtype instances for the first time the other week. My head exploded.
13:50:37 * BMeph nods sagely
13:50:49 * BMeph then shakes parsely
13:50:55 <edwardk> newtype instances for data families that is
13:50:59 <mmorrow> BMeph: hehe
13:51:11 <tibbe> edwardk: me three
13:52:15 <rovar> this doesn't make any sense..
13:52:42 <mmorrow> lazy IO only bothers me when it's using sockets/handles
13:54:16 <skorpan> OT since #emacs won't answer:  i'm trying to make an (emacs lisp) regular expression which matches any whitespace character including newlines.  anyone?
13:54:31 * Heffalump wonders if anyone can be arsed to have a play with HLVM and post stupid blog posts showing how crap it is? :-)
13:54:54 * mmorrow wonders what hlvm is
13:54:55 <tibbe> mmorrow: it borrows me when I try to write Google style systems ;)
13:55:05 <mmorrow> tibbe: heh
13:55:48 <Heffalump> mmorrow: it's some attempt by Harrop to built a layer on top of LLVM for implementing functional languages
13:55:56 <mmorrow> tibbe: (i'm not sure exactly what that entails, but) i think the fact that haskell is a lazy language means that doing things in certain ways just don't work
13:55:58 <rovar> where is it even located?  http://www.hlvm.org  forwards to something unrelated
13:56:02 <dons> Heffalump: i think it is better to let it fail silently, hopefully after he invests a lot of effort :)
13:56:15 <mmorrow> (and obviously doing things in some other ways work beautifully)
13:56:25 <Heffalump> rovar: can't remember - he stole the name of something already done despite that thing being pointed out to him
13:56:34 <edwardk> its pretty terrible at last check
13:56:41 <Heffalump> s/stole/used/
13:56:53 <tibbe> mmorrow: basically you need to start up a bunch of jobs on different machines, take some distributed looks, collect the results, etc. Kinda hard to do all those side effects behind a function that is "pure" ;)
13:56:54 <dons> Heffalump: btw, sent you details on London visit.
13:57:02 <dons> is there enough time to organize a london hug meeting?
13:57:27 <Heffalump> dons: working on it, I emailed Ross
13:57:34 <Heffalump> should be enough time assuming he's available
13:57:44 <tibbe> mmorrow: s/looks/locks
13:58:11 <Heffalump> dunno what audience we'll get, a lack of a regular programme has thinned out the audiences a bit. But it's an opportunity to drink beer if nothing else.
13:58:40 <dons> woo
13:59:50 <mmorrow> tibbe: does it need to be non-monadic?
14:01:18 <rovar> gah
14:01:34 <tibbe> mmorrow: no
14:01:51 <jfredett> question about associated data types
14:02:02 <tibbe> mmorrow: but lots of the functions I would like to use (e.g. zlib compress) are written in such a way that I can't use them except in a lazy I/O way
14:02:08 <jfredett> is there a way to create a kind of "default" constructor
14:02:36 <jfredett> so that, say, if I wanted to have class which represents Playing Card like structures
14:03:08 <mmorrow> tibbe: ah, i see what you're saying now. yeah, you would have to write your own custom version of a lot of stuff in order to go at it that way.
14:03:10 <jfredett> I just want to be able to provide different Suit/Index definitions, so I'm creating essentially the same structure with the same accessors/constructors.
14:03:22 <tibbe> mmorrow: exactly
14:03:28 <tibbe> mmorrow: which is a shame
14:03:32 <augustss_> jfredett: classes can have default methods
14:03:34 <jfredett> I effectively want to write data CardT s i = CardT s i... is that possible?
14:04:34 <mmorrow> tibbe: but since lazy bytestrings are just basically [ByteString], i've found it pretty easy to just push a single strict bytestring through a ByteString.Lazy interface then i'm dealing with strict ByteStrings..
14:04:34 <jfredett> augustss_: right- but default associated type constructors?
14:04:45 <jfredett> maybe I should just try it... :/
14:05:14 <augustss_> jfredett: try it, it's not unreasonable
14:05:34 <tibbe> mmorrow: right for some libraries that work. I'd argue that those libraries should export lower level functions
14:05:38 <jfredett> nope, no dice...
14:05:44 <mmorrow> tibbe: yeah, true
14:05:46 <jfredett> parse error on '='. :/
14:05:46 <jfredett> hmm
14:06:07 <tibbe> mmorrow: e.g. if all a library does is to take each chunk in a lazy bytestring and apply an internal function to it it might as well export that external function too
14:06:18 <mmorrow> yes
14:06:19 <jfredett> hmm, really all I need is an associated newtype... hehe
14:06:31 <tibbe> mmorrow: but e.g. zlib does other things (initialization, etc)
14:07:02 <rovar> ah ha!
14:07:10 <mmorrow> tibbe: ah yeah, that could be painful..
14:07:57 <tibbe> mmorrow: that's why folds are attractive, the inversion of control makes it possible for the library to do the initialization and clean up but still provide a nice traversal interface
14:09:14 <mmorrow> tibbe: yeah, i do like the fold interface a lot for when you need to control socket/handle/etc use tightly
14:09:54 <jfredett> hmm, I don't think it's possible, it's not in the wiki or the ghc docs
14:10:02 <tibbe> mmorrow: I think the problems we (i.e. the people thinking about fold based I/O) is that the interface we have so far looks quite foreign to many Haskellers and it requires rewriting a non-trivial amount of code
14:10:26 <mmorrow> i think the stream interface and the fold interface each have their place in certain (different) situations
14:12:33 <tibbe> mmorrow: probably
14:13:52 <mmorrow> (i agree that the existing libs aren't very "fold-friendly")
14:13:54 <BMeph> Someone nneds to tell Jon that April Fools only goes for the first day, not all month: "Given that this bug had gone unnoticed for so long, the only logical conclusion is that the GHC FFI is immature because it has very few users. This concurs with our previous findings that no mature software has ever been written in Haskell."
14:14:44 <rovar> well it's such an obvious logical conclusion
14:14:56 <BMeph> Is that use of "our" the "royal plural", or just his admission of schizophrenia? ;[
14:15:03 <gwern> so long? I thought it had only popped up in the bug suite recently?
14:15:09 <rovar> BMeph: probably B and C :)
14:15:09 <gwern> BMeph: it's the corporate we
14:15:59 <dons> a tag cloud of his pronouncements would be interesting
14:16:29 <dons> "WE" "immature" "toy" "no" "never" "very few" "none" "nothing" "unused" etc
14:17:52 <gnuvince_> BMeph: link?
14:17:53 <mmorrow> tibbe: (and i should add to that, and in each of those different situations i think the other interface is a very poor substitute for the one suited to that situation)
14:18:21 <dons> gnuvince_: not worth him seeing thie hit count rise, honestly.
14:18:26 <tibbe> mmorrow: I actually don't know what a good interface would look like :(
14:18:54 <mmorrow> tibbe: yeah me neither, i guess i mean s/interface/way of doing things/
14:19:16 <idnar> gnuvince_: google is your friend
14:19:40 <tibbe> mmorrow: there's seems to be a split between two different kind of resources memory and everything else. Since memory is GCed we can write pure code, since the rest is not we can't write pure code when using those resources. All programs use both kinds of resources
14:19:45 <idnar> how on earth is Nazooka an "industrial" user?
14:20:35 <idnar> "You keep using that word; I do not think it means what you think it means."
14:22:15 <dons> idnar: i imagine it went like this: jdh watches haskell-cafe. peter reported a bug, it was fixed in stable already, it was to do with FFI/graphics stuff, harrop googles peter's name, finds out where he works. writes blog post on hyperbolic failure
14:22:40 <idnar> dons: sure, I'm just boggling at his failure to, uh, speak English
14:22:46 <dons> people doing graphics stuff are potential customers, so worth hammering on, to him.
14:23:04 <dons> jeff heard got similar emails, once he announced his opengl packages
14:25:40 <mmorrow> tibbe: totally, i agree. (personally) i don't have any problem with unsafePerformIO'ing peeks/pokes to malloc'ed memory, but since sockets/handles are much more scarce/exhaustible resources i like to have control over closing them which means sticking the {h,s}Close in a lazy thunk that hopefully'll get forced sometime is out
14:25:46 <dons> flies in the ointment.
14:26:13 <tibbe> mmorrow: same here
14:26:32 <tibbe> mmorrow: peeking and poking memory is not really unsafe in the same way as doing I/O
14:28:24 <gwern> are sockets and handles scarce for logical reasons, or is it just a hardware performance thing, perhaps soluble with a couple more turns of the moore's law crank?
14:28:49 <mmorrow> (.. is out when there's the remote possibility i'll run out of sockets/handles... but if i'm only streaming stdin->stdout then i think streaming is great :)
14:29:04 <tibbe> gwern: there are really two issues, the scarcity of the resource and the side effects performed
14:29:36 <tibbe> gwern: think of resource such as locks instead, you won't run out of them but you'd like to be able to reason about when they're taken and released
14:30:18 <tibbe> mmorrow: the problem I see is that people write libraries for your second use case
14:30:34 <tibbe> mmorrow: and then they don't "scale" to big programs
14:30:43 <tibbe> mmorrow: I failure in reusability I would say
14:30:52 <gwern> tibbe: so the lock analogy suggests a STM
14:31:05 <tibbe> gwern: for example
14:31:10 <idnar> it's pretty stupid that sockets / handles are a scarce resource
14:31:32 <tibbe> idnar: I guess
14:32:23 <Gracenotes> >:
14:32:45 * idnar blames stupid kernel programmers ;)
14:33:28 <tibbe> I really need to go to bed now
14:33:30 <tibbe> gnight
14:35:19 <gwern> Gracenotes: so, I'm going to the Mikado tonight. are you back in poughkipsie?
14:35:47 <Gracenotes> yes, I am. I actually was in the choir of Mikado in the 8th grade.
14:36:14 <Gracenotes> unfortunately I can't make it and relive the memories, but enjoy it :)
14:36:15 <gwern> that's interesting. seems like an odd play for a middle school to do
14:36:42 <gwern> Gracenotes: I suppose it'll depend on how well I can understand the lyrics. it's just not a good g&s experience if you can't follow the wordplay
14:38:00 <Gracenotes> gwern: mm. back then, as an 8th grader, I saw it more as a regular plot, with twists and turns, rather than G&S's somewhat satirical take on Japanese culture
14:38:08 <dons> i love writing 100 lines of code, and having it type check and work first time
14:38:13 <dons> type system woo! combinators woo!
14:38:44 <Vq^> dons: thats a nice feeling :)
14:38:56 <glguy> dons, if it type checked first time, then you didn't really use the type-checker for much ;)
14:38:57 <Gracenotes> gwern: I don't think many of the tunes are necessarily catchy. The choreography is quite good though, iirc
14:39:03 <Vq^> dons: misspellings in strings/messages becomes a larger issue thought
14:39:04 <gwern> Gracenotes: didn't have the background, eh
14:39:20 <gwern> Gracenotes: it's true, other G&Ss seem to have more popular tunes - like pirates of penzance
14:39:24 <dons> glguy: just a little (Data.Data stuff)
14:39:26 <Gracenotes> yeah. It was still fun though.
14:40:04 <Gracenotes> oh, yay! My quantum Shor's algorithm simulator is working! :D
14:40:13 <Gracenotes> after 5 tries, it factored 513 into (9, 57). A total of 19.12 seconds.
14:40:49 <gwern> now throw some ackermans in there to slow it down!
14:41:11 <Gracenotes> it's not a great model of a quantum machine -- I had to explicitly simulate entanglement -- but can be ported to a more quantum-y interface
14:41:46 <Gracenotes> > 10240 + 5120 + 5120 + 785
14:41:47 <lambdabot>   21265
14:42:06 <Gracenotes> wow. That's quite a few times to just call one function
14:42:12 <Gracenotes> namely.. euclid (a :+ b) = a*a + b*b
14:43:27 <Gracenotes> well, I can alleviate it by improving the dft algorithm. At the moment it's in O(n^2) time
14:45:18 <Saterus> simple question: in ghci, how do i unload all modules at once?
14:45:20 <Gracenotes> hm. I don't get these profiling results much.
14:45:48 <glguy> :m   ?
14:45:52 <kadaver> if I do : clientinput <- hGetLine h; where h is: (h,_,_) <- Network.accept ; ie a socket. so I get the http requests from the client. well why does it only print POST / http \r etc. where does submitted vakues come?
14:45:56 <trez> > ($1) <$> [(+1),(+2),(+3)]
14:45:57 <lambdabot>   [2,3,4]
14:46:02 <kadaver> like text from a box
14:46:35 <gwern> Saterus: you could do :show modules and then :module -foo
14:46:45 <gwern> or just, y'know, exit ghci
14:46:57 <glguy> if you type:   :m
14:47:02 <glguy> it reverts back to just Prelude
14:47:22 <Saterus> glguy: that was exactly what i was looking for. thanks.
14:47:50 <gwern> glguy: :help doesn't mention that
14:48:24 <Saterus> gwern: thats why i asked here. i checked help first. ;)
14:48:32 <glguy> it does:
14:48:33 <glguy>    :module [+/-] [*]<mod> ...  set the context for expression evaluation
14:48:43 <glguy> if you leave off the +/-, it is an absolute change
14:48:56 <gwern> but why would you infer that?
14:49:08 <Saterus> glguy: i kept trying to do :m -* and that wasn't working.
14:49:17 <glguy> why would I infer that the +/- are optional?
14:49:20 <glguy> because they are in []s
14:49:33 <dons> i love haskell.
14:49:33 <gwern> giving no argument is usually an error or a no-op, not an actual null argument!
14:49:55 <dons> deriving all my instances, syb style:
14:49:56 <dons> main = sequence_ [ deriveM t u | Box t <- types , Box u <- types ]
14:49:56 <dons> data Box = forall a. (Typeable a, Data a) => Box a
14:49:56 <dons> types = [ Box (undefined :: Int) , Box (undefined :: Char) ]
14:50:05 <gwern> dons: really? I always assumed you were an epic troll, who was eventually going to reveal that you were undermining haskell from day 1
14:50:09 <dons> hah
14:50:09 <glguy> gwern, no argument works on a number of the : commands in ghci
14:50:16 <mmorrow> kadaver: it looks to me like you only did a single hGetLine
14:51:19 <glguy> they should probably update the help to show:  :module [ [+/-] [*]<mod> ...]
14:51:27 <glguy> or add a new :module line
14:51:39 <glguy> like in the :edit case
14:52:23 <mmorrow> kadaver: have you looked at the http rfc?
14:53:50 <mmorrow> kadaver: http://tools.ietf.org/html/rfc2616
14:54:00 <mmorrow> (is the pretty html version)
14:55:16 <kadaver> mmorrow ok i seeIjsut need to read more lines
14:55:25 <mmorrow> indeed :)
14:55:53 <mmorrow> (the header ends with the first empty line)
14:56:11 <mmorrow> (and the (possibly nonexistent) body follows)
14:56:27 <mmorrow> kadaver: do you know the an http eol is?
14:56:38 <mmorrow> \r | \n | \r\n
14:57:09 <glguy> \r or \n are valid?
14:57:18 <mmorrow> glguy: unfirtunately yes
14:57:22 <mmorrow> *unfortunately
14:57:44 <dolio> How about \n\r? I think some MUD code I looked at back in the day used that.
14:57:48 <mmorrow> which makes parsing supar fun
14:58:07 <mmorrow> dolio: iirc \n\r is two eol's
14:58:16 <mmorrow> but \r\n\r is also two..
14:58:31 <mmorrow> and \r\n\r\r it 3
14:58:34 * mmorrow shudders
14:58:35 <dolio> It wasn't as far as the MUD was concerned. :)
14:58:37 <gwern> I'm confused, why isn't \r\n\r 3?
14:58:38 <sioraiocht_> if (->) is taken as a functor, and fmap is (.), what does the bifunctor on objects look like?
14:58:52 <mmorrow> gwern: because \r\n is a single eol
14:59:21 <gwern> but but
14:59:37 <gwern> madness!
14:59:42 <mmorrow> yesh
15:00:12 <dolio> (->) takes A x B to (A -> B), the set of arrows from A to B.
15:00:25 <sioraiocht_> thanks
15:00:56 <dolio> Or, maybe that should be (A, B).
15:01:13 <dolio> It's an object in the product category, not a product in the category.
15:01:40 <sioraiocht_> dolio: right, built from the product bifunctor
15:02:18 <inimino> :module
15:02:23 <dolio> The product bifunctor builds products in the category, doesn't it?
15:02:28 <inimino> whoops
15:02:53 <dolio> - x = : C x C -> C?
15:02:53 <mmorrow> eolP = choice [lfP>>return(),crP>>((lfP>>return())<++return())] :: ReadP ()
15:03:16 <mmorrow> (is my parser)
15:03:57 <mmorrow> (lfP = char '\n'; crP = char '\r')
15:07:59 <inimino> sometimes regexes really are more readable
15:08:20 <mmorrow> heh
15:09:10 <mmorrow> are you guaranteed that (a|b) will try 'a' before 'b' in a regex?
15:09:33 <idnar> I believe so
15:09:34 <mmorrow> because if not i'm not sure that you could use a regex for that
15:09:37 <mmorrow> ah, nice
15:09:39 <kadaver> mmorrow: i dont know  what the eol is. im reading an dprinting liek 8 lines, does this thing never ned :P
15:09:47 <inimino> yes
15:10:11 <pumpkin> "im reading an dprinting liek 8 lines, does this thing never ned "
15:10:18 <inimino> /\r\n|\r|\n/
15:10:43 <mmorrow> kadaver: so the punchline is that if you're talking to a bootleg server/client, you have to be careful using hGetLine (if you care enough)
15:11:48 <inimino> only \r\n is allowed by HTTP
15:12:01 <kadaver> so how do I read the whole thing?
15:12:57 <mmorrow> inimino: hmm, possibly that's the official standard, i don't recall, but checking for all that seemed the "standard" when i was looking at various webservers parsers
15:13:21 <mmorrow> inimino: i can't recall actually where i picked that up
15:13:38 <inimino> I've only ever needed to handle /r/n
15:14:18 <inimino> at least for HTTP itself, once you get into the message body of course anything goes
15:16:07 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3381#a3381 <- for some reason now after jut reading thatin the app doesnt wrok
15:19:53 <kadaver> is there nothin builtin to index a tuple except for fst and snd?
15:20:12 <idnar> well, there's always pattern matching
15:20:27 <idnar> let (_, _, _, _, x, _, _) in ... x ...
15:20:40 <idnar> but if you're doing lots of that sort of thing, you probably shouldn't be using a tuple
15:21:33 <kadaver> theyre handy because you stick different typrs in them
15:21:38 <pumpkin> kadaver: augustss_ posted a package recently on hackage that allows you to pull out indices from tuples
15:21:42 <kadaver> but you cant x:xs a tuple?
15:21:46 <pumpkin> no
15:21:59 <rovar> org
15:22:15 <rovar> is there a way to recover from a library calling error?
15:22:34 <Beelsebob> kadaver: why would yu be able to?
15:22:40 <Beelsebob> (:) is a Constructor for lists
15:22:44 <Beelsebob> not tuples
15:23:39 <kadaver> i meant something like it
15:23:54 <Beelsebob> well yes  (,)
15:23:57 <Beelsebob> (x,y)
15:24:13 <kadaver> but how do you rep a cons-like thing?
15:24:20 <Beelsebob> huh?
15:24:47 <kadaver> > let (a,b) = (1,2,3,4) in b
15:24:48 <lambdabot>   Couldn't match expected type `(t, t1)'
15:24:52 <kadaver> ...
15:24:54 <Beelsebob> you can't
15:25:01 <Beelsebob> being able to do that would break the type system
15:25:04 <idnar> kadaver: well, if you nest 2-tuples instead of using n-tuples, then you can just use fst and snd like head and tail
15:25:10 <Beelsebob> (a,b) is not the same type as (c,d,e,f)
15:25:28 <bremner> idnar reinvents cons :-)
15:25:38 <pumpkin> but then you have type-level "list" lengths
15:25:39 <Beelsebob> bremner: tbf  tuples should just be pairs
15:25:49 <Beelsebob> it's only an optimisation to make n-tuples thpethal
15:25:50 <pumpkin> (a, (b, (c, (d, ())))
15:25:56 <rovar> thrd (a, b, c) = c
15:26:11 <rovar> frth (a, b, c, d) = d
15:26:12 <idnar> cons = (,); car = fst; cdr = snd
15:26:14 <rovar> done :)
15:26:18 <inimino> "thpethal"?
15:26:30 <inimino> that's some typo :-)
15:26:31 <Beelsebob> special  only with more stupid added
15:26:40 <inimino> oh
15:26:41 <Beelsebob> (what's happened with tuples in Haskell)
15:28:47 <rovar> JSON.Generic calls error when a parse is invalid. Is there any way to recover from this?
15:28:54 <idnar> YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
15:29:42 <Tobsan> lol idnar
15:29:44 <rovar> tourrette's syndrome?
15:30:01 <MarcWeber> nominolo: You'r syb with class lib is broken due to changes in template haskell. I'm totally unfamiliar with this code yet. I can tell you the patch which broke it. Do you think you'll have a look into it wihtin the next days?
15:30:13 <idnar> @quote CAR
15:30:14 <lambdabot> monochrom says: data DesCarte = forall a. Think a => Exist a
15:30:16 <idnar> @quote CARS
15:30:16 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
15:30:21 <mmorrow> rovar: other than rip out the code and fix it, no
15:30:24 <nominolo> MarcWeber: sure
15:30:43 <idnar> @remember pjdelport YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
15:30:43 <lambdabot> It is forever etched in my memory.
15:30:59 <dolio> @quote metacircularity
15:30:59 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
15:31:14 * rovar rips out the code and fixes it.
15:31:24 <MarcWeber> nominolo Do you have a bleeding edge template/haskell + ghc setup ?  I can provide you one tomorrow
15:31:33 <mmorrow> @quote knuth
15:31:34 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
15:31:45 <nominolo> MarcWeber: I have 6.10.2
15:31:50 <kadaver> @quote kadaver
15:31:50 <lambdabot> No quotes match. Do you think like you type?
15:32:01 <kadaver> @quote Knuth
15:32:01 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
15:32:08 <nominolo> MarcWeber: or do you mean latest HEAD?
15:32:15 <MarcWeber> http://rafb.net/p/OvLADT21.html @ nominolo
15:32:17 <kadaver> @quote noob
15:32:17 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:32:33 <MarcWeber> nominolo I was talking about latest head (patch date  2009-03-19)
15:32:59 <MarcWeber> nominolo If you don't have time I'll try to fix it. But it'll probably take me some hours to get to know what is done here exactly
15:33:23 <nominolo> MarcWeber: no, I think that should be fairly straightforward to fix
15:33:58 <nominolo> the GHC SYB stuff is not very sophisticated, it's just instances
15:34:12 <MarcWeber> nominolo: line 160 does contain the important change from [Type] ->   data Pred | one constructor contains that [Type]
15:34:31 <nominolo> MarcWeber: er, wait
15:34:42 <nominolo> MarcWeber: syb-with-class is not maintained by me
15:35:07 <MarcWeber> nominolo Oh did I mix those libs up?
15:35:14 <RayNbow> > 3 `isMoarThan` 2
15:35:15 <lambdabot>   YARLY
15:35:22 <nominolo> MarcWeber: I only maintain ghc-syb
15:35:40 <nominolo> MarcWeber: SYB with class is based on the so-named paper.  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/syb-with-class
15:35:42 <MarcWeber> nominolo Sorry then.
15:35:46 <idnar> @quote dawg
15:35:46 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
15:35:47 * RayNbow wonders if anyone had time to spare to write lol-lambda
15:35:48 <idnar> @quote dawg
15:35:48 <lambdabot> pjdelport says: YO DAWG I HERD YOU LIKE CARS SO WE PUT A PAIR IN YO CAR SO YOU CAN CAR WHILE YOU CAR
15:35:49 <idnar> @quote dawg
15:35:50 <lambdabot> mauke says: YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
15:35:52 <idnar> aww
15:36:01 <RayNbow> > 3 `isMoarThan` 2
15:36:02 <lambdabot>   YARLY
15:36:08 <RayNbow> > 2 `isMoarThan` 3
15:36:09 <lambdabot>   NO WAI
15:36:47 <mun> hi
15:36:52 <nominolo> MarcWeber: np.  syb-with-class is a bit more magic
15:37:14 <kadaver> uh
15:37:22 <mun> does anyone know what the $ sign mean in Nothing -> A B $ C D?
15:37:27 <kadaver> how can jsut doin hGetLine stop the app from proceedin?
15:37:41 <pumpkin> @src ($)
15:37:42 <lambdabot> f $ x = f x
15:37:47 <pumpkin> mun: that's all it is :P
15:38:05 <Gracenotes> so, A B (C D)
15:38:06 <mun> pumpkin so is it sort of redundant?
15:38:11 <pumpkin> mun: not at all
15:38:16 <pumpkin> mun: it allows you to save parentheses
15:38:18 <pumpkin> ;)
15:38:32 <RayNbow> > map ($5) [succ, pred]
15:38:33 <mun> aah
15:38:33 <MarcWeber> nominolo: But this patch is for you.. http://rafb.net/p/ntO3sf44.html
15:38:34 <lambdabot>   [6,4]
15:38:35 <mun> ok thanks
15:39:12 <Gracenotes> sort of like how I'm saving parentheses every time someone makes an emoticon :)
15:39:21 <Gracenotes> oh wait
15:39:34 <nominolo> MarcWeber: ah, can you send it as a Git patch to <my-nick> @ gmail.com , so it'll contain your author name? :)
15:39:45 <mun> what is the equivalent of A B (C D) E? A B $ C D $ E?
15:40:01 <MarcWeber> nominolo I dont' care. Just add it
15:40:12 <nominolo> k
15:40:15 <MarcWeber> nominolo That's not much magic to be proud of :)
15:40:20 <skorpan> mun: what scale is that?
15:40:22 <skorpan> har har har
15:40:24 <Gracenotes> mun: not much of an equivalence, I don't think :\
15:40:37 <dolio> mun: There isn't one, due to the associativity of ($).
15:40:46 <skorpan> mun: the latter is equivalent to A B (C D E) afaict
15:40:57 <dolio> Unless you count (A B $ C D) E, which isn't really any better.
15:41:10 <pumpkin> dolio: do you know of an API in uvector for getting at the memory backing for talking to external code?
15:41:23 <mun> so i'd be better off using parenthesis like A  B (C D) E?
15:41:58 <therealadam> naive question: I'm trying to use the Network.HTTP package to fetch a URI, but when I import Network.HTTP, I end up missing functions like getRequest in GCHI; am I missing something?
15:42:05 <dolio> pumpkin: If you can see the constructors you can get the underlying MutableByteArray#s.
15:42:09 <skorpan> mun: yes, parentheses aren't harmful :)
15:42:17 <Gracenotes> @. unpl pl \a b c d e -> a b $ c d $ e
15:42:17 <lambdabot> (\ t f j m p -> t f (j m p))
15:42:19 <dons> hey guys. uploaded 'adaptive-containers 0.1' with self-optimizing tuples: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/adaptive-containers-0.1
15:42:20 <pumpkin> dolio: yeah, but I didn't think those were exposed normally
15:42:21 <mun> ok thanks
15:42:29 <pumpkin> dons: nice!
15:42:30 <dolio> No, I don't think they are.
15:42:32 <dons> i'd love feedback on the design, since i'd like to extend this idea to other sums/products/container types
15:42:36 <Gracenotes> a b $ c d $ e = a b (c d e), then. skorpan is teh right.
15:42:41 <skorpan> <- right!
15:42:42 <skorpan> =)
15:42:44 <nominolo> MarcWeber: right, I'll add a contributors file then.  I believe that it's very important to give credit in open source projects.
15:43:12 <pumpkin> dons: have any thoughts on providing an API in uvector to get access to the memory backing for talking to foreign libraries?
15:43:25 <pumpkin> I find myself needing one but it may not be appropriate
15:44:18 <MarcWeber> nominolo Don't do that because of that 4 lines patch. Get it done. That you keep mantaining things is enough work. I my case we can talk about a contributors file for the scion project (if I ever manage to do some valuable contribution.. :-) .. But a working haskell compiler is the first step to do so..)
15:44:29 <dons> pumpkin: mm.
15:44:35 <MarcWeber> nominolo: But that's my attitute
15:44:37 <dons> we'll have to pin things during the foreign call
15:45:17 <dolio> dons: Does that work? I though overlapping instances were unsound with type families.
15:45:20 <pumpkin> yeah, that's what I was thinking... it's related to the issues I was having with the bytestring serialization... maybe a wrapper call like withUArr :: (UA a) => UArr a -> (ForeignPtr a -> IO()) -> IO () or something
15:46:14 <Gracenotes> @index getArgs
15:46:15 <lambdabot> System.Environment
15:46:21 <Gracenotes> :X
15:46:22 <pumpkin> wow, adaptive tuples have a lot of instances!
15:46:36 <wli> Adaptive tuples?
15:46:47 <pumpkin> http://code.haskell.org/~dons/code/adaptive-containers/Data/Adaptive/Tuple.hs :)
15:46:57 <pumpkin> could TH help?
15:47:06 <wli> Could you just say what it is?
15:47:19 <pumpkin> wli: it's using associated types to get unboxed tuples for any combination of basic types
15:47:41 * dolio disappears.
15:47:51 <pumpkin> oh no, where did he go!
15:48:11 <Gracenotes> is there a way I can make profiling data more precise?
15:48:21 <dons> pumpkin: i'm using syb to generate the instances
15:48:25 <Gracenotes> one decimal point of a perfect don't help :\
15:48:29 <pumpkin> ah
15:48:30 <Gracenotes> *percent
15:48:41 <MarcWeber> nominolo: By the way: Which is the correct way to handle this? Do we need two branches? HEAD and stable? stable compiling with latest ghc release, HEAD with ghc HEAD?
15:49:05 <nominolo> MarcWeber: no, I just use cpp
15:49:20 <dons> regular list of pairs: http://code.haskell.org/~dons/images/vacuum/tuple-list.png
15:49:29 <kadaver> i still dont et where inputvalues from users come int he http requests
15:49:30 <dons> adaptive list of pairs: http://code.haskell.org/~dons/images/vacuum/pair-list.png
15:49:40 <dayzman> hi
15:49:51 <dayzman> does anyone know know what the ' in fold' A mean?
15:50:15 <dons> strict
15:50:21 <dons> it does a fold that is strict in the accumulator
15:50:43 <nominolo> dons: I'd like to see something like this for type-level lists.  The only thing I could think of is to have lots of instances to unpack into n-tuples
15:51:00 <dayzman> thanks
15:51:37 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3381#a3381 <- where in that lsit does user inut come?
15:51:43 <kadaver> if there is some
15:52:12 <Gracenotes> one line after the last header
15:52:14 <BMeph> What's the name for "numbers" described as Z/Q/R[whatever]?
15:52:32 <Gracenotes> blackboard?
15:52:33 <nominolo> dayzman: there are a few more functions like this, but there is no consistent convention for strict variants
15:53:06 <nominolo> BMeph: Ring/Field?
15:53:16 <Gracenotes> they're sets of numbers, and the special way of writing Z/Q/R is known as blockboard bold
15:53:34 <Gracenotes> unless you meant something different >_.
15:54:09 <Gracenotes> hm. Is there no way to make GHC profiling more precise?
15:54:11 <dayzman> nominolo: but why do functions like foldl sometimes need to be strict?
15:54:24 <BMeph> Gracenotes: Well, I was looking more into nominolo's answer, but I'll still file away the glyph info, thanks. :)
15:54:46 <Gracenotes> it's completely useless to know that I entered a method 432189 times and spent 0.0 of my time in it :\
15:55:09 <idnar> dayzman: if your accumulator isn't "productive" (not sure that's the right term), then you get a huge stack of thunks
15:55:18 <nominolo> @wiki Foldl
15:55:18 <lambdabot> http://www.haskell.org/haskellwiki/Foldl
15:55:20 <idnar> dayzman: on the other hand, if it is, then you can consume it lazily, so don't want strictness
15:55:26 * pumpkin pours on the unsafePerformIO juice
15:55:35 <EvilTerran> Gracenotes, i wouldn't call that useless - i'd call that a sign that you really don't need to optimise that method
15:55:42 <dayzman> thanks
15:55:42 <nominolo> dayzman: http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
15:55:59 <nominolo> dayzman: the second link
15:56:05 <Gracenotes> EvilTerran: it's useless when every single method except for the main one shows 0.0% time, 0.0% memory
15:56:16 <EvilTerran> ah. true.
15:56:59 <dayzman> nominolo: thanks
15:57:39 <pumpkin> dons: any suggestions on an efficient way to fold a monadic operation over a UArr? should I just do it on the stream side and unstreamU it?
15:59:26 <nominolo> dayzman: in general, when writing a tail-recursive function you should probably make it strict in the accumulator argument
15:59:43 <BMeph> pumpkin: How freshly squeezed is that juice? ;p
15:59:49 <pumpkin> BMeph: very!
16:00:07 <pumpkin> BMeph: I'm undoing ugly API that puts everything in IO
16:00:23 <dons> pumpkin: hmm. i think there might be examples of that in BUArr.hs
16:00:31 <pumpkin> oh ok, I'll take a look
16:00:32 <pumpkin> thanks
16:01:33 <Gracenotes> hm. There's no reason x**(-(0.5)) would be faster than recip $ sqrt x or sqrt $ recip x, I don't think?
16:01:57 <wli> It could (in principle) compile to a single instruction.
16:03:24 <kadaver> "Host: localhost:8080\r\nUser-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.0.8) Gecko/2009032609 Firefox/3.0.8 (.NET CLR 3.5.30729)\r\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\nAccept-Language: en-us,en;q=0.5\r\nAccept-Encoding: gzip,deflate\r\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\nKeep-Alive: 300\r\nConnection: keep-alive\r\n\r\n
16:03:39 <kadaver> so whre in that is data submitted byt he user supposed to come?
16:04:03 <rovar> before the last set of \r\n
16:04:04 <rovar> iirc
16:04:19 <kadaver> ok
16:04:34 <kadaver> but why does requesting the whole thing stop my webserver from going further?
16:04:37 <rovar> POST data should take place of the body, which would be there.
16:04:39 <kadaver> i mean i just process a string
16:04:49 <rovar> i've got no clue for ya there
16:04:59 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3385#a3385
16:05:03 <kadaver> ^^ the code
16:17:53 <pumpkin> @index unsafePerformIO
16:17:53 <lambdabot> System.IO.Unsafe, Foreign
16:17:56 * pumpkin grins
16:18:12 * Gracenotes :o
16:18:33 <kadaver> requesttype <- hGetLine h
16:18:33 <kadaver>   ah <- hGetContents h
16:18:33 <kadaver>   print ah
16:18:53 <kadaver> can doing hGetContents on the handle afterwards change whats in requesttype?
16:19:07 <kadaver> ie superunsafeperformRetardedIO?
16:19:27 <mauke> no
16:19:47 <Gracenotes> kadaver: the RFC for HTTP might help
16:20:03 <Gracenotes> but, anyway, do note.. hGetContents is notoriously lazy
16:24:10 <kadaver> but the print statement changes how the app behaves
16:24:14 <kadaver> then the app just stops
16:24:16 <kadaver> why?
16:26:28 <blackdog_> kadaver: why are you running hGetContents on it again anyway?
16:27:10 <rovar> yea.. why not hGetLine ?
16:27:35 <blackdog_> well, hGetContents is fine, but it's a promise to read the whole thing in anyway.
16:28:54 <rovar> what whole thing? what if there are two requests pending?
16:30:39 <blackdog_> but you get passed a new handle for each request, don't you?
16:30:51 * blackdog_ is not entirely sure of the architecture here
16:31:33 <kadaver> blackdog: uh just to see what comes :P
16:32:44 <blackdog_> kadaver: you're just tryin to work out the semantics of hGetContents, then?
16:33:10 <kadaver> yes
16:33:19 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3386#a3386 is there a nicer way of writing this?
16:33:41 <pumpkin> the case ... of Nothing -> Nothing makes me want to fmap
16:33:52 <pumpkin> but the IO is getting in the way
16:34:38 <mauke> maybe def castMXArray val
16:36:10 <mauke> def from Data.Default
16:36:15 <blackdog_> kadaver: I get "illegal operation, handle is closed"
16:36:42 <pumpkin> mauke: hmm?
16:37:19 <blackdog_> kadaver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3387#a3387
16:37:26 <mauke> pumpkin: hmm??
16:37:30 <pumpkin> mauke: castMXArray :: forall a. MXArrayComponent a => MAnyArray -> MIO (Maybe (MXArray a))
16:37:51 <mauke> MIO?
16:38:02 <pumpkin> just an alias to IO :P don't ask me why
16:38:16 <mauke> ok, then what's the problem?
16:38:30 <sioraiocht_> what is (are) the terminal object(s) in the category of sets and relations?
16:38:49 <pumpkin> mauke: I can't figure out how to avoid that case on the output for the Maybe
16:39:01 <mauke> what's wrong with 'maybe def castMXArray val'?
16:39:15 <pumpkin> oh I see
16:39:19 <pumpkin> I thought the maybe was english :P
16:39:23 <pumpkin> not the maybe function
16:39:41 <mauke> heh
16:40:18 <kadaver> blackdog:me to for your example but not when i do it in the other
16:40:31 <pumpkin> mauke: nope :/
16:40:43 <pumpkin> ah well, the case is fine
16:41:03 <mauke> pumpkin: what's the error?
16:41:23 <pumpkin>     Couldn't match expected type `Maybe a'
16:41:23 <pumpkin>            against inferred type `MIO (Maybe (MXArray a1))'
16:41:23 <pumpkin>     In the second argument of `maybe', namely `castMXArray'
16:42:09 <pumpkin> ah, return Nothing instead of Nothing
16:42:20 <pumpkin> makes sense
16:42:25 <mauke> ...
16:42:30 <blackdog_> kadaver: ok. perhaps you should just avoid trying to read the same handle twice with hGetContents until you're sure what you actually want :)
16:42:53 <mauke> pumpkin: the line I wrote doesn't contain "Nothing"
16:44:01 <pumpkin> mauke: I know, but I didn't feel like depending on default to write return Nothing :P and I missed the default instance for IO
16:44:02 <rovar> [19:42] <blackdog_> kadaver: ok. perhaps you should just avoid trying to read the same handle twice with hGetContents until you're sure what you actually want :)
16:44:19 <blackdog_> is there an echo?
16:44:31 <rovar> is there?
16:44:31 <ddarius> is there an echo?
16:44:49 <blackdog_> oy. straight man again.
16:45:06 <rovar> do you have a problem with straight men?
16:48:32 <Gracenotes> hm. presumably there is a better way to logBase 2 than 'ceiling $ logBase 2 $ fromIntegral n'... perhaps? :X
16:48:53 <Gracenotes> besides perhaps repeated bit-shifting. or... hm.
16:49:16 <Gracenotes> eh, fine as 'tis
16:49:21 <ddarius> length . takeWhile (/= 0) . iterate (`shiftL` 1)
16:50:23 <Gracenotes> uh. shiftR?
16:54:10 <kadaver> how do I say in Parsec: jump to next \r ?
16:54:44 <mauke> many (noneOf "\r") or something like that
16:55:58 <Gracenotes> kadaver: don't necessarily forget about continuations either
16:59:28 <sjanssen> lambdabot: @join #haskell-in-depth
16:59:37 <kadaver> what is so abd about regexes really? unmaintainable for bigger stuff I see but what else? slow?
17:00:31 <sjanssen> kadaver: they can only handle regular expressions
17:00:37 <MyCatVerbs> Slow iff you implement them as backtracking NFAs, which is only really necessary if you want to support backreferences.
17:00:46 <sjanssen> they can't, for example, match parentheses
17:01:39 <MyCatVerbs> DFAs like what lex compiles regular expressions into actually turn out to be really, astoundingly fast, precisely because they're so limited in power.
17:03:19 <Gracenotes> and people often need context-sensitive things like backreferences to compensate for things a context-free grammar could do very easily
17:05:15 <b\6> i have f :: .. -> IO (Either Bad OK). f uses some functions that return Maybes. is there a nice way to translate the Maybes to Eithers so i can make f more monadic?
17:05:52 <c_wraith> use the maybe function?
17:05:59 <TSC> :t maybe
17:06:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:06:43 <TSC> > maybe id (Just 2)
17:06:44 <lambdabot>   Couldn't match expected type `a -> a1 -> a1'
17:06:57 <TSC> Ah, missed that "b" (:
17:07:01 <Gracenotes> huh.. I don't get why separating this into a separate function would cause it to hang
17:07:16 <sjanssen> Gracenotes: clearly you did it wrong
17:07:39 <sjanssen> Gracenotes: one mistake I often make when refactoring is something like "let x = x"
17:07:47 <Gracenotes> yes, that's what I'm looking for
17:07:52 <Gracenotes> can't find anything like it though :\
17:08:21 <Gracenotes> evidence, circumstantial as it may be, shows that your assertion of
17:08:26 <Gracenotes> 'doing it wrong'
17:08:28 <Gracenotes> is correct.
17:08:46 <Gracenotes> argh :x
17:09:11 <ddarius> "You're doing it wrong" is almost always a safe bet.
17:10:09 <kadaver> again
17:10:09 <kadaver> browser <- (P.many P.letter >> P.char '/' >> P.digit >> P.char '.' >> P.digit)
17:10:24 <kadaver> how do i return the whole thing not jsut the last match?
17:11:17 <EvilTerran> save the return values of "P.many P.letter" etc and assemble them into a string?
17:12:30 <kadaver> yes
17:12:36 <kadaver> but >> P.char '/' >> P.digit >> P.char '.' >> P.digit
17:12:42 <kadaver> thayt art how do Imake them one?
17:12:50 <EvilTerran> pardon?
17:12:54 <kadaver> can I use something but >>
17:13:00 <kadaver> that passes ont he previous value
17:13:06 <kadaver> i dotn want to collect each
17:13:06 <mauke> >>=
17:13:18 <EvilTerran> ... sure. they're monadic actions. you can use >>=, or <- in do-notation
17:13:33 <Gracenotes> ah! A simple typo, it seems, caused the problem
17:13:50 <Gracenotes> it wasn't hanging infinitely, but rather would have until my system ran out of memory
17:14:21 <kadaver> version <- P.char '/' >> P.digit >>= P.char '.' >>= P.digit
17:14:22 <Gracenotes> trying to create a register with 2^(n*2) state superpositions instead of 2^n superpositions
17:14:27 <kadaver> Couldn't match expected type `Char
17:14:27 <kadaver>                                   -> Text.Parsec.Prim.ParsecT s u m a'
17:14:27 <kadaver>            against inferred type `Text.Parsec.Prim.ParsecT s1 u1 m1 Char'
17:14:27 <kadaver>     In
17:14:28 <Gracenotes> really makes a difference :\
17:15:22 <EvilTerran> ?type (>>=) -- i don't think >>= does what you think it does
17:15:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:15:44 <Saizan> kadaver: version <- P.char '/' >> P.digit >>= \d -> P.char '.' >> P.digit >>= \d' -> return (d ++ "." ++ d')
17:15:56 <Gracenotes> kadaver: perhaps you'd like applicative style rather than monadic there?
17:16:03 <Saizan> well
17:16:13 <kadaver> Gracenotes: beats me :P
17:16:30 <Saizan> kadaver: version <- P.char '/' >> P.digit >>= \d -> P.char '.' >> P.digit >>= \d' -> return [d, '.', d']
17:16:47 <Saizan> assuming P.digit :: Parser Char
17:16:47 <mauke> did someone say sequence?
17:17:01 <Gracenotes> no, I don't think so >_>  <_<
17:17:11 <Saizan> yeah, sequence is perfect here
17:18:07 <EvilTerran> (P.many P.letter <^(++)^> sequence [P.char '/', P.digit, P.char '.', P.digit])
17:18:32 <Gracenotes> well
17:18:48 <Gracenotes> sequence [P.digit, P.char '.', P.digit]) <* P.char '/'
17:19:00 <Gracenotes> or, P.char '/' >> sequence [P.digit, P.char '.', P.digit])
17:19:16 <EvilTerran> depending on whether the "/" is desired in the output
17:19:23 <EvilTerran> similarly for the "."
17:19:41 <Gracenotes> yeah. Just going by Saizan's version
17:23:50 <shapr> Which programs out there use STM?
17:24:15 <sjanssen> shapr: xmobar uses it a bit
17:27:03 <b\6> what kind of stuff is ST suited for? would it be desirable for stuff like games with lots of state elements needing to be updated really often?
17:27:27 <pumpkin> b\6: not really, I don't think
17:27:46 <b\6> pumpkin: better to use State and IORefs, or what?
17:28:00 <pumpkin> b\6: typically you'd use ST if you have a function that needs mutable state internally, but is still referentially transparent
17:28:05 <dons> b\6: well, it would be ok if you have a global array you're updating a lot
17:29:38 <sjanssen> b\6: I'd use ST if you need mutable arrays, or mutable references
17:29:43 <pumpkin> b\6: ST is basically IO with a fancy type that prevents mutability from escaping
17:29:45 <sjanssen> and don't need to do any IO
17:32:48 <b\6> hmm. thanks for answers.
17:34:17 <mib_olyq4zhd> Hi I am learning haskell via Learn yourself a haskell website. I just got past the Types and Typeclasses section and I have some questions.
17:34:31 <mib_olyq4zhd> How can I find out what types are covered in a typeclass?
17:34:55 <mib_olyq4zhd> For example: I'd like to know what types are in Num and what operations are possible on that Typeclass.
17:35:04 <sjanssen> mib_olyq4zhd: there are a couple places
17:35:07 <sjanssen> @docs Prelude
17:35:07 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
17:35:12 <mib_olyq4zhd> Is there a good reference for a newbie.
17:35:29 <sjanssen> mib_olyq4zhd: that link has the documentation for Prelude, which is the implicitly imported module
17:35:36 <sjanssen> mib_olyq4zhd: or, from ghci, you can type :info Num
17:35:53 <mmorrow> , let untilST p f x = mdo {k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref}; newton f f' t x = snd (runST (untilST (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(f x/f' x))) (x+t,x))) in newton sin (negate . cos) 0.0001 (pi/4)
17:35:55 <lunabot>  0.7853981633974483
17:36:03 <mmorrow> wee
17:36:24 <mmorrow> err, kinda boring cuz i gave it the answer i guess
17:36:32 <mmorrow> , let untilST p f x = mdo {k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref}; newton f f' t x = snd (runST (untilST (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(f x/f' x))) (x+t,x))) in newton sin (negate . cos) 0.0001 (pi/94)
17:36:34 <lunabot>  34409.86415311754
17:36:37 <mmorrow> gah!
17:37:13 <zakwilson> This regex I was using in a Python program gives me a parse error in Haskell. I assume I'm overlooking something simple: "[\|\&\;\<\>\(\{\$\`\\\"\'\%\?\[\]\~\=\*\ \#]"
17:37:25 <kadaver> so how do I say Parsec.jumUntil a string. P.many (P.noneOf (P.string "ISO")) dosnt work
17:37:38 <mauke> zakwilson: far too many backslashes
17:37:58 <mmorrow> ok that newton is borked
17:38:01 <mmorrow> or something
17:38:06 <zakwilson> mauke: Yes... the parse error suggested that.
17:38:30 <wli> mmorrow: Where's the bracketing and fallback code?
17:38:43 <mauke> zakwilson: "[][|&;<>({$`\\\"'%?~=* #]"
17:38:58 <mmorrow> wli: heh
17:39:48 <zakwilson> mauke: Thanks.
17:39:55 <mmorrow> wli: oh wait, yeah i fail
17:40:20 <wli> mmorrow: f' = cos not negate . cos
17:40:28 <mmorrow> heh
17:40:34 <mmorrow> no wonnnnder
17:40:37 <mmorrow> :)
17:41:08 <wli> mmorrow: Try f = cos, f' = negate . sin with an initial bracketing interval of (1, 2)
17:42:00 <mmorrow> , let untilST p f x = mdo {k <- newSTRef (readSTRef ref >>= \x -> if p x then writeSTRef k (return()) else writeSTRef ref (f x) >> join (readSTRef k)); ref <- newSTRef x; join (readSTRef k) >> readSTRef ref}; newton f f' t x = snd (runST (untilST (\(x,y)->abs(x-y) < t) (\(_,x)->(x,x-(f x/f' x))) (x+t,x))) in newton cos (negate . sin) 0.01 (pi/5)
17:42:02 <lunabot>  1.5707963267948963
17:42:07 <mmorrow> :)
17:42:17 * mmorrow was really confused for a while there
17:43:09 <kadaver> cant I say skip until "Connection"?
17:43:30 <mmorrow> i like the gratuitous and unnecessary use of mdo and STRefs for untilST ;)
17:43:57 <wli> You really need to maintain brackets on the roots and terminate when either the bracketing interval for the root fails to be narrowed or the residual interval fails to be narrowed.
17:44:12 <mib_olyq4zhd> Is there a  reason why the Num Typeclass implements the == operator but not the > or < operator?
17:44:47 <mmorrow> wli: yeah, i need to refresh my memory on numerical analysis stuff in general.
17:44:54 <wli> You can only really rely on checking against the tolerance (shouldn't there be separate tolerances for the bracketing interval length and residuals?) for early termination.
17:45:02 <wli> Well, this isn't too involved.
17:45:14 <sjanssen> mib_olyq4zhd: Eq (the class that provides (==)) is a superclass of Num because of numeric pattern literals
17:45:44 <sjanssen> mib_olyq4zhd: for example: fib 0 = 0; fib 1 = 1; fib n = fib (n-1) + fib (n-2)
17:45:49 <mmorrow> wli: heh, this is like chapter 1.1
17:46:21 <sjanssen> mib_olyq4zhd: (==) is needed so that we can tell whether the first parameter to fib is 0, 1, or neither
17:48:14 <mib_olyq4zhd> so class(Eq a, Show a) => Num a where means, the Num derives from Eq and Show??
17:48:19 <Pseudonym> mib_olyq4zhd: The other thing is that some numbers don't have a natural Ord instance.
17:48:21 <Pseudonym> Like Complex.
17:48:40 <sjanssen> mib_olyq4zhd: it means that all instances of Num must also be instances of Eq and Show
17:48:59 <Pseudonym> You can think of it as the class Num deriving from the classes Eq and Show.
17:49:05 <sjanssen> mib_olyq4zhd: the language we generally use for that is "Show and Eq are superclasses of Num"
17:49:05 <Pseudonym> If that helps.
17:49:14 <Pseudonym> But it's not quite what it means under the covers.
17:49:26 <mib_olyq4zhd> yeah that helps. Thank you.
17:49:49 <Pseudonym> The => is actually logical implication.
17:50:04 <wli> mmorrow: Not entirely. The fixed point theorem etc. required for quadratic convergence proofs is usually punted a few chapters out.
17:50:06 <Pseudonym> So it kind of means "if a is an instance of Eq and a is an instance of Show, then a can be an instance of Num".
17:50:19 <sjanssen> Pseudonym: I thought the implication is the other way around?
17:50:44 <sjanssen> "if a is an instance of Num, then a is an instance of Eq and Show"
17:50:46 <mmorrow> wli: hmmm, i think you're right
17:50:57 <Pseudonym> sjanssen: You can think of it that way.
17:51:16 * mmorrow wishes he could find his numerical analysis book
17:51:24 <Pseudonym> I think of it as: if a is an instance of Eq, and a 9is an instance of Show, then you can write an instance declaration to make a an instance of Num.
17:51:28 <pumpkin> analyze dem numburz
17:51:31 <mib_olyq4zhd> sjanssen: Pseudonym: is there a way to declare a variable that belongs to Num and Ord so I can do comparison??
17:51:39 <sjanssen> Pseudonym: I guess I find the "can be" strange in your statement
17:51:44 <Pseudonym> mib: Sure.
17:51:47 <mmorrow> pumpkin: ima lurn me some!
17:51:52 <Pseudonym> instance (Num Int) where ...
17:51:55 <Pseudonym> instance (Ord Int) where ...
17:52:08 <sjanssen> mib_olyq4zhd: foo :: (Num a, Ord a) => a
17:52:11 <Pseudonym> And this, mib, is the main difference between Haskell and OO languages.
17:52:15 <rovar> sjanssen: if you do a comparison, it would imply that it can the variable is a member of Ord unless indicated otherwise
17:52:30 <Pseudonym> You don't have to declare which classes a type belongs to at the time you declare the type.
17:52:35 <sjanssen> foo = if 0 < 1 then 0 else 1 -- silly example
17:52:47 <Pseudonym> You can make Int "derive from" any classes you like, and you don't have to change the definition of Int.
17:53:01 <sjanssen> hmph, that is wrong
17:53:07 <sjanssen> foo = max 0 1 -- actually has that type
17:54:20 <wli> Some sort of notion of a normed space so algorithms can share code between real and complex number types...
17:54:51 <ddarius> Pseudonym: "This" and about 50 other things.
17:54:52 <mib_olyq4zhd> chk :: Num -> String -- gives me an error but chk :: (Num a) => a -> String --  doesn't, why is that??
17:55:20 <Saizan> Num is not a type
17:55:25 <Pseudonym> Right.
17:55:30 <Pseudonym> mib, do you know any set theory?
17:55:36 <mib_olyq4zhd> Yes I do.
17:55:38 <Pseudonym> OK.
17:55:46 <Pseudonym> So you know about things like Russell's paradox
17:56:21 <loupgaroublond> how do i tell cabal to install files to /etc/foo/ ?
17:56:29 <Pseudonym> One of the ways that Russell's paradox was removed from naive set theory was by distinguishing "sets" (which behave themselves) and "classes" (which sometimes don't).  So "the set of all sets" is a class, not a seet.
17:56:30 <mib_olyq4zhd> No I don't I am looking it up.
17:56:41 <Pseudonym> Oh, OK.
17:56:46 <sjanssen> loupgaroublond: I think you have to do that manually by Setup.hs hooks
17:56:53 <Pseudonym> This is essentially what Haskell does.
17:56:59 <Pseudonym> A type is (more or less) a bag of values.
17:57:11 <Pseudonym> Like Char is '\0', '\1' and so on.
17:57:18 <Pseudonym> It's a "set" of values.
17:57:27 <Pseudonym> A class is a set of types.
17:57:39 <loupgaroublond> sjanssen, are there any examples out there in the wild of that?
17:57:43 <Pseudonym> i.e. set of sets
17:57:49 <Saizan> loupgaroublond: see --datadir  or similar in cabal install --help
17:57:51 <mmorrow> wli, anyone: do you have any suggestions for good numerical analysis books? i've actually been meaning to get one since i've lost my textbook and am on amazon now..
17:58:09 <mib_olyq4zhd> I see... so a Num is a class and it has Int, Integer, Float etc... whcih are sets... right?
17:58:15 <loupgaroublond> Saizan, thanks
17:58:22 <mmorrow> none of the ones in the results are jumping out at me as excellent
17:58:29 <Pseudonym> Right.
17:58:46 <Pseudonym> That's not entirely true, because types aren't quite sets for technical reasons, but that's the way to think about it.
17:58:48 <wli> I can't think of anything offhand except maybe Bulirisch & Stoer.
17:59:13 <Pseudonym> I like Burden and Faires.
17:59:42 <mib_olyq4zhd> Pseudonym: chk :: (Num a) => a -> String -- In that statement is a considered a set or a class
17:59:49 <wli> I'm totally unfamiliar with Burden & Faires.
17:59:56 <Pseudonym> I also recommend reading Acton's "Numerical Methods that Work".
18:00:22 <Pseudonym> That's a seriously practical book, but it doesn't contain some stuff that you might expect an all-round book to contain
18:00:22 <ddarius> Pseudonym: Does it have a companion "Numerical Methods That Don't Work"?
18:00:34 <sjanssen> mib_olyq4zhd: a is a type, types are sets of values
18:00:43 <dons> mm... auto-specializing lists: 45% faster sum 100M elem lazy list.
18:00:45 <kadaver> anyone here good with linear algebra(especially SVD) ?
18:00:47 <mmorrow> wli: nice, that one looks decent, and got me to a better place in the "you might also like this" amazon suggestion graph
18:00:51 <Pseudonym> ddarius: Actually, in the 1960s edition, if you remove the dust jacket, you can see the word "usually" imprinted in the cover, but not inked.
18:01:09 <mmorrow> Pseudonym: heh
18:01:12 <mib_olyq4zhd> sjanssen: so when I declare a variable to a type class it becomes a set??
18:01:20 <sjanssen> dons: code!
18:01:29 <wli> Was Fike a second author of that?
18:01:30 <Pseudonym> But Acton is a really hard-nosed practical book from someone in the trenches.
18:01:36 <sjanssen> mib_olyq4zhd: no, all types are sets
18:01:38 <Pseudonym> That's why I liked it.
18:01:46 <mib_olyq4zhd> sjanssen: sorry, when I declare a variable to a type class it becomes a type??
18:01:49 <dons> sjanssen: let me finish the rest of the List module
18:01:51 <sjanssen> mib_olyq4zhd: 'a' in your example isn't just a variable, it is a 'type variable'
18:02:00 <dons> sjanssen: note, this isn't with fusion. :) just removing the indirectoins
18:02:31 <sjanssen> dons: fusion would strip away the indirections anyway, right?
18:02:40 <sjanssen> (assuming a good day for the optimizer)
18:02:45 <mib_olyq4zhd> sjanssen:  But I delcared 'a' as Num, which is a typeclass.
18:02:53 <dons> nope. it'll turn it into a single loop over a list with directions
18:03:00 <dons> while here we'd get a single loop over a list with no indirections
18:03:10 <dons> well, actually, it might completely remove it, yes.
18:03:33 <dons> so i think the best world is adapting list + fusion
18:03:44 <dons> so that lists that do exist take up less space.
18:03:57 <wli> I don't think the Newton issues are all that deep; they're mostly just compensating for the various different ways things break.
18:04:04 <kadaver> wait
18:04:07 <jklk> hi, dons, good book, i picked up 2 copies last week
18:04:21 <kadaver> so "Keep-Alive: 300\r\nConnection: keep-alive\r\n\r\n"); <- int here. "Keep-Alive: 300\r\nConnection: keep-alive\r\nHIIAMTHEUSERINFO?\r\n")
18:04:45 <kadaver> so I could just reverse the string and parse from there would be easier
18:05:05 <sjanssen> mib_olyq4zhd: but you didn't declare a "as a" type class, you declared "as a member of a" type class
18:05:07 <dons> jklk: hehe cool!
18:05:12 <wli> e.g. check for progress reducing residuals, never take steps that would expand the bracketing interval, etc.
18:05:25 <Pseudonym> That's 20c for dons!
18:05:40 * ddarius wonders how much O'Reilly has made from RWH
18:05:56 <mmorrow> Pseudonym: ooh, the Acton on looks good
18:05:59 <Pseudonym> ddarius: Are you asking if they've recovered their costs first?
18:05:59 <mmorrow> *one
18:06:05 <Pseudonym> s/first/yet/
18:06:23 <ddarius> Pseudonym: I'm pretty sure they have, but yes, I'm wondering about a net gain (or loss)
18:07:34 <Pseudonym> mmorrow: It's also quite a fun read.
18:07:48 <Pseudonym> There are a bunch of geeky jokes and anecdotes in there
18:07:56 <dons> they're in the black for sure.
18:08:23 <dons> i think they were by the end of Dec.
18:10:07 * mmorrow goes with both Bulirisch & Stoer and Acton
18:10:28 <wli> mmorrow: Golub & van Loan "Matrix Computations"
18:10:34 <loupgaroublond> sjanssen, are there any plans to include a hook that can copy files to /etc or some other given directory in the future, in cabal?
18:10:47 <sjanssen> loupgaroublond: I wouldn't know
18:11:13 <loupgaroublond> oh well
18:11:14 <sjanssen> loupgaroublond: I think it is possible now, but you have to write some logic for it in Setup.hs
18:12:37 <mmorrow> hmm, deciding on amazon is so hard
18:14:10 <mmorrow> i'm tempted by this Numerical Recipes 3rd Edition: The Art of Scientific Computing
18:14:11 <kadaver> doesnt Parsec.eof mean dont parse more?
18:14:42 <kadaver> a = \n\rresu; would : P.char '\n' >> P.char '\r';  info <- P.string "resu" --(P.many P.alphaNum);  P.eof;  return info; parse that?
18:15:52 <Pseudonym> mmorrow: There's one problem with the Numerical Recipes book.
18:16:03 <mmorrow> Pseudonym: oh?
18:16:08 <Pseudonym> The material is good, you'll learn a lot about the algorithms etc.
18:16:16 <Pseudonym> But the recipes themselves are crap.
18:16:23 <mmorrow> ahh, interesting.
18:16:27 <Pseudonym> You should NEVER use NR code in a real system.
18:16:28 <Saizan> kadaver: no, it means "parse the end of the string"
18:16:37 <Pseudonym> At least this was true circa 2nd edition.
18:18:47 <kadaver> NR code+
18:18:49 <kadaver> ?
18:18:55 <kadaver> ah
18:19:04 <kadaver> Saizan: so how do I say stop parsing?
18:19:12 <kadaver> and which is the best Parsec tutorial?
18:20:36 <tessier> BONUS: Did you do LYAH?
18:20:45 <tessier> That nick is familiar....
18:27:52 <dons> don't see this often,
18:27:53 <dons>      go _  xs@[]  = xs
18:28:32 <mmorrow> heh
18:28:39 <ddarius> tessier: He is.
18:29:46 <blackdog_> dons: ... marking assignments? That's a weird construction...
18:30:16 <dons> I think I wrote it in 2006.
18:30:16 <ddarius> It occurs somewhere in the standard libraries I believe.
18:30:26 <dons> or it might have been something we stole from Data.List
18:30:51 <dons> i don't have to mark assignments anymore, blackdog_ :)
18:35:32 <rovar> what is the name of the view pattern that uses the @ symbol so I can search for it?
18:35:54 <rovar> ah.. as pattern
18:36:17 <blackdog_> dons: heh. yeah, point. although i think code reviews for junior devs are the moral equivalent :)
18:36:39 <Gracenotes> so, this *should* work, but with ST you can never know: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3391#a3391
18:37:19 <Gracenotes> I've tries a few combinations of explicit and implicit type declaration to give GHC hints. nothing working so far. Any ideas?
18:37:22 <Gracenotes> *tried
18:38:30 <mauke> lots of missing imports
18:38:48 <mauke> @index writeArray
18:38:48 <lambdabot> Data.Array.MArray, Data.Array.IO, Data.Array.ST, Data.Array.Storable
18:39:07 <Gracenotes> I've imported Data.Array.ST and Control.Monad.ST
18:39:16 <Gracenotes> sorry, that was a few lines up
18:39:23 <patch-tag> what flag(s) do I need to load Data.ByteString.Internal in ghci? I'm doing ghci -fglasgow-exts but get Illegal foreign declaration: requires via-C or native code generation (-fvia-C)
18:39:23 <patch-tag>     When checking declaration:
18:39:23 <patch-tag>         foreign import ccall unsafe "static stdlib.h &free" c_free_finalizer
18:39:27 <patch-tag>           :: FunPtr (Ptr Word8 -> IO ())
18:40:02 <dons> can't load that module in ghci , atm.
18:40:13 <patch-tag> ah, well.
18:40:49 <Gracenotes> of course, specifying the type from a to Int, Maybe [Complex Double], whatever will make it work
18:41:17 <Gracenotes> but it doesn't like 'a' having any polymorphism about it >:[
18:42:55 <mauke> Gracenotes: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3391#a3392
18:44:06 <Gracenotes> oh. I see, thanks. You'd think STArray wouldn't care about the type of its contents, though :/
18:44:46 <int-e> patch-tag: try -fobject-code ?
18:46:01 <Gracenotes> I wish there was some way to tell it what kind of MArray to use without implicating 'a' in the business
18:48:42 <pumpkin> dons: I couldn't find any information on monadic operations in the BUArr code, but I was thinking of adding in a monadic fold/map instance over UArrs, if you think that would be helpful. The one issue that's holding me back is a naming one. If I call something mapMU, it could be a map over MUArrs or mapM over UArrs...
18:48:43 <int-e> Gracenotes: you can do that. define a helper function, stSTArray :: ST s (STArray s e a) -> ST s (STArray s e a); stSTArray = id, then you can use  stSTArray $ newArray (0, size - 1) e
18:49:38 <patch-tag> int-e (and dons): -fobject-code does work
18:51:04 <Gracenotes> int-e: ah, that works. just (id :: ST s (STArray s e a) -> ST s (STArray s e a)) $ blah, although a bit verbose
18:51:09 <Gracenotes> also
18:52:20 <int-e> Gracenotes: http://int-e.home.tlink.de/haskell/ArrayM.hs is built around that idea.
18:55:12 <dons> pumpkin: just pick one :)
18:55:41 <pumpkin> I was thinking that MUArr might fit nicely with being called STUArr, but am wary of making a change that radical :P
18:57:06 <pumpkin> anyway, I'll play around with it :)
18:58:07 <patch-tag> What does this idiom do? go a _ | a `seq` False = undefined
18:58:17 <mauke> make go strict in a
18:58:35 <patch-tag> could it be equally accomplished with a bang patern?
18:58:43 <mauke> yes
18:58:51 <int-e> patch-tag: the idiom predates bang patterns, and it's Haskell98
18:58:53 <mauke> but bang patterns aren't H98
18:59:03 <patch-tag> i see
18:59:39 <mauke> http://okmij.org/ftp/Haskell/#making-function-strict
18:59:42 <patch-tag> oh, I get it, you never hit the undefined because the guard is always false. but you still eval a.
18:59:50 <pumpkin> yup
19:00:08 * sjanssen prefers the #define STRICT1 idiom
19:00:25 <ddarius> I'd personally recommend using bang patterns unless portability is really important to you.
19:00:25 <pumpkin> how does that work?
19:01:03 <sjanssen> pumpkin: #define STRICT1(f) f x | x `seq` False = undefined
19:01:07 <pumpkin> oh ok :)
19:01:25 <sjanssen> and so on for STRICT2, STRICT3
19:01:32 <sjanssen> is that still in the bytestring source?
19:01:41 <patch-tag> sjannssen: what language feature does that # belong to?
19:01:51 <pumpkin> CPP
19:02:03 <int-e> cpp is icky. (Try STRICT1(f'))
19:02:29 <patch-tag> sjannsen: you were joking that you prefer the idiom, or you really prefer it?
19:02:44 <sjanssen> patch-tag: very much joking
19:03:04 <pumpkin> has anyone used uniplate?
19:03:06 <pumpkin> (in here)
19:04:01 <MyCatVerbs> pumpkin: I am confused by the notion that anyone would be able to read that question, but need the clarification "(in here)"?
19:04:09 <pumpkin> lol
19:04:27 <pumpkin> I was afraid of someone snarkily responding to my question saying "well yes, its author has"
19:04:44 <int-e> pumpkin: I would, but ndm isn't here atm.
19:04:48 <pumpkin> :)
19:08:25 <Gracenotes> hrm. If Miller-Rabin returns composite, then the number is definitely composite, right?
19:09:46 <kadaver> [V;S;U] =svd(A); why is then SVD(V) a vector of 1s?
19:10:06 <pumpkin> kadaver: is that matlab? :P
19:10:12 <kadaver> octave
19:10:23 <kadaver> #haskell is all-knowing
19:10:25 <pumpkin> lol
19:11:05 <Gracenotes> :o
19:15:40 <int-e> Gracenotes: yes
19:16:14 <Gracenotes> okay. would be worrisome otherwise
19:25:15 <Gracenotes> nice. Replacing the sort/group with counting frequencies via STUArray counting yielded a speedup of 3x  O.O
19:25:31 <Gracenotes> and probably better speedup for higher test values
19:29:35 <orbitz> is the invoke stuff in chapter 20 of RWH POSIX-only?
19:32:01 <blackh> orbitz: You mean RunProcessSimple.hs?
19:34:35 <blackh> orbitz: I'm with ya. Yes - Looks POSIX-only to me.
19:37:31 <orbitz> blackh: thanks
19:44:27 <mmorrow> pumpkin: (as of maybe 3 weeks ago) uniplate barfs with "<your program name>: undefined" if you have any strict field in your datatypes
19:47:12 <mmorrow> patch-tag: just do "ghci -fobject-code"
19:47:32 <mmorrow> then you can load modules with foreign stuff
19:47:46 <mmorrow> (since :l Foo.hs will compile it to machine code)
19:48:21 <mmorrow> expressions defined at the prompt are still bytecode though
19:49:28 <mmorrow> patch-tag: ah, you got it
19:49:42 <mmorrow> heh, and apparently he isn't even here anymore :)
19:57:23 <dons> sjanssen: adaptive containers, now with lists: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/adaptive-containers-0.2
19:57:57 <ddarius> Wow, 0.1 didn't last long
19:58:09 <pumpkin> adaptive lists now!
19:58:53 <ddarius> dons: Nice use of vacuum.
19:59:36 <dons> ddarius: yeah. i think vacuum is helping motivate thinking about representation issues
19:59:39 <pumpkin> I like where this is going
20:00:21 * pumpkin dreams of the native list in GHC being super cool, adaptive, and using stream fusion :P
20:00:27 <dons> it's a good time. representation-changing polymorphic types are almost entirely unexplored
20:00:53 <ddarius> dons: There's tons of research about such things, but not too much practice.
20:01:15 <dons> yeah. it's also the canonical type families example, sort of.
20:01:27 <dons> not so much the unpacking automation, but the idea of choosing a hidden, separate representation
20:01:36 <dons> we've also not explored using view patterns on such things
20:02:41 <edwardk> dons: its why i started thinking about it again
20:05:13 <edwardk> dons: plans to make larger adaptive tuples for ternary? i realize beyond that it gets to be diminishing returns too fast
20:05:34 <dons> i think 3..7 make sense
20:05:36 <sjanssen> edwardk: are you going to write the O(n^3) instances? :)
20:05:47 <edwardk> sjanssen: he has a script =)
20:05:49 <dons> also seems like there should be a OverloadedStrings instance...
20:05:59 <dons> so we can get O(n) less indirections in our string literals :)
20:07:02 <edwardk> the IsString instance should be trivial
20:07:18 <sjanssen> dons: how many types are you covering so far?
20:07:26 <pumpkin> n^7 sounds painful
20:07:26 <pumpkin> won
20:07:33 <pumpkin> 't that slow down ghc compilation?
20:07:34 <dons> instance IsString (List Char) where fromString = fromList
20:07:50 <sjanssen> pumpkin: yeah, I have a feeling the object size will become huge
20:07:54 <dons> at some point we must demand compiler support :)
20:08:07 <pumpkin> yeah
20:08:10 <c_wraith> dons: can the compiler support be faked via template haskell?
20:08:10 <edwardk> well the ^3 instance is within reason. only a few thousand. i did more than that doing type level ints
20:08:20 <dons> yeah
20:08:24 <sjanssen> yikes
20:08:30 <dons> c_wraith: sure. same problem though.
20:08:38 <sjanssen> seems to me that anything involving a thousand instances is Doing It Wrong
20:08:53 <ddarius> sjanssen: This is more something that should be handled by the compiler.
20:09:11 <edwardk> sjanssen: to be fair, it was smaller with type level 2s complement, but type level 16s complement needed 16^3 instances for 2-3 things
20:09:13 <dons> deriving Unpacking
20:09:15 <dons> or something
20:09:19 <ddarius> sjanssen: At the library level, it probably makes most sense to let such things be made on an "as needed" basis by the (end) user
20:09:23 <sjanssen> dons: or just some TH
20:09:37 <dons> well, the TH still generates a thousand instances for the type checker
20:09:45 <dons> so it's the same issue as the current script approach, isn''t it?
20:09:50 <pumpkin> as needed sounds good
20:10:02 <pumpkin> make some TH that generates an instance for you if you need it?
20:10:03 <sjanssen> dons: I mean some TH for the end user
20:10:21 <Gracenotes> @src unzip
20:10:22 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
20:10:32 <sjanssen> dons: so you can provide just a few instances for the really common stuff, and have the user $( mkInstances ''MyType )
20:10:38 <dons> yeah.
20:11:00 <edwardk> how would compiler support work? can "{-# UNPACKED #-} !" only work for a limited set of types? if it was enlarged to cover other tuples of unpacked types then you could just make a few instances and it would flatten them
20:11:02 <sjanssen> I would provide that rather than 3-tuples -- most uses of 3-tuples really should be their own type anyway
20:11:08 <Gracenotes> hm. Why the tilde here?
20:12:04 <ddarius> Gracenotes: You want lazy functions in foldrs
20:12:06 <sjanssen> dons: sticking with only fundamental instances in the actual package will also avoid 30 minute compile times :)
20:12:15 <ddarius> Gracenotes: Without the ~ it would stack overflow on large inputs.
20:12:19 <dons> heh
20:12:28 <dons> yes, i like the TH approach
20:13:02 <edwardk> as soon as type family th support moves into a mainstream released compiler that'll even be viable, but its a long ways off
20:13:19 <ddarius> edwardk: Unless you make a patch...
20:13:28 <pumpkin> well, for now n^3 should be fine, right?
20:13:28 <edwardk> ddarius: chakravarty already wrote it
20:13:29 * dolio is still surprised that GHC accepts the code in adaptive-containers.
20:13:36 <dons> dolio: in what sense?
20:13:43 <dons> it is written in the modern style? :)
20:13:51 <dolio> Overlapping instances are unsound for type families, so I thought it was disallowed.
20:14:09 <dons> yeah, i can only get that trick to work on simple pairs with no context
20:14:23 <dons> oh, i was also getting segfaults with standalone deriving ....
20:14:24 <sjanssen> dons: next we need a Data.Adaptive.Set!  That can finally answer whether IntSet is faster thanks to tries or just data specialization
20:14:37 <Gracenotes> ddarius: hm... I think I see.
20:14:40 <dons> you can actually write, say, deriving instance Eq a, Eq b => Eq (Pair a b)
20:14:47 <dons> though i've no idea what ghc thought it was going to generate
20:14:57 <edwardk> sjannssen: i was just writing something like that in another window ;)
20:14:58 <dons> since it generates something that just crashes
20:15:10 <dons> sjanssen: mmm!
20:15:30 <dons> i bet this helps our tries on big tables too
20:15:32 <sjanssen> > 15^3
20:15:33 <lambdabot>   3375
20:15:43 <edwardk> dons earlier mention of the adaptive tuple stuff started me down a binge coding spree seeing what else from the stdlibs could be done that way
20:15:49 <dons> heh
20:16:01 <dolio> sjanssen: I tested out gmap's Int specialized AVL tree on Harrop's benchmark, and it used all my memory, instead of finishing in 10 seconds like IntMap. :)
20:16:01 <edwardk> now i even have a lib to work from
20:16:08 <dons> i love new performance avenues opening up like this.
20:16:18 <dolio> I don't know if that proves anything.
20:16:20 <Gracenotes> > ((!!100) *** (!!100)) $ unzip (repeat (0,0))
20:16:20 <sjanssen> pumpkin: as a person with not very much RAM, I'd rather not see triples in adaptive
20:16:21 <lambdabot>   (0,0)
20:16:37 <pumpkin> sjanssen: fair enough :)
20:16:44 <sjanssen> > 15^8 - 1
20:16:45 <lambdabot>   2562890624
20:16:50 <Gracenotes> > let unzip = foldr (\(a,b) (as,bs) -> (a:as,b:bs)) ([],[]) in ((!!100) *** (!!100)) $ unzip (repeat (0,0))
20:16:51 <pumpkin> :P
20:16:51 <lambdabot>   (* Exception: stack overflow
20:16:57 <Gracenotes> mm
20:16:59 <sjanssen> yeah, Tuple7 is not gonna work...
20:17:11 <ddarius> Gracenotes: Read the Stack overflow page on the wiki if you haven't already.
20:17:39 <dolio> dons: Anyhow, you should probably warn people not to write orphan instances for your library. I think that's where the unsoundness comes in.
20:17:55 <Gracenotes> I think I skimmed once
20:18:00 <sjanssen> dolio: which instance do you think is overlapping?
20:18:08 <Gracenotes> *reads*
20:18:12 <pumpkin> dolio: isn't the TH "as needed" approach going to make orphan instances?
20:18:18 <edwardk> dons: hrmm, thought, if you're already thinking Triple with <-> (,,) something that comes to mind is an unboxed Either a b, and  Either (a,b) c view, which should cover a lot of common data types.
20:18:25 <dolio> instance Pair a b overlaps with every other instance.
20:18:34 <dons> yeah Maybe and Either are next.
20:18:37 <edwardk> a little newtype wrapping and a whole host of things could just use those with views
20:18:54 <Gracenotes> dons: so.. to what extent is it truly adaptive? Can the compiler automatically transform (,) -> Pair?
20:19:09 <dons> that's what it is doing, yeah.
20:19:12 <dolio> Er, AdaptPair a b.
20:19:26 <Gracenotes> oh, really. I must have missed the part in the code where that happened >_>
20:19:30 <dons> see the little vacuumed images in http://hackage.haskell.org/cgi-bin/hackage-scripts/package/adaptive-containers-0.2
20:19:47 <sjanssen> dolio: I see it now, that is very strange
20:20:15 <dons> is it just luck it works? since it seems to work sensibly.
20:20:32 <dons> it doesn't work for List (Pair a b)
20:20:46 <dolio> Since you're only dealing with one module, it's not subject to problems, I think.
20:21:07 <dons> i could disable that "fall back to (,)" instance
20:21:08 <sjanssen> the test is case PUnit of PairPair () () -> ...
20:21:49 <dolio> The problem is when you have a value of type 'Pair A B' from the 'AdaptPair a b' instance, and use it some module where a specific 'AdaptPair A B' instance is in scope.
20:22:11 <edwardk> so you rewrite to strict streams like this by importing rewrite rules right? so importing this module makes any list of primitives strict in the sense that evaluating the cons cell evaluates the value in the list
20:22:12 <dons> then bang, I imagine.
20:22:24 <dons> edwardk: hmm?
20:22:55 <edwardk> well you've eliminated an indirection, just thinking what the consequences are and if any practical code cares.
20:22:57 <dons> these aren't strict lists though (and there's no rewrite rules), unless i misunderstand
20:23:09 <dons> they're only element strict, not spine strict
20:23:29 <edwardk> oh, you don't rewrite lists in and out of them? i thought i spotted some semblance of the stream fusion in there
20:23:43 <dons> no, not yet :)
20:24:51 <edwardk> ok, so you currently have to go through toList and fromList?
20:25:42 <dons> yep. or build it directly (enumFromTo, unfold etc)
20:25:44 <edwardk> and yeah i was just indicating that with rewrite rules it'd make all lists of primitives element strict.
20:25:58 <dons> i don't think it'll make the spines strict.
20:26:02 <dons> at least, it shouldn't.
20:26:11 <edwardk> i don't either. i was just talking about element strictness
20:26:13 <sjanssen> dons, dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3393#a3393
20:26:29 <edwardk> just trying to think what would care
20:26:52 <sjanssen> GHC bug!
20:27:05 <dons> ah ha
20:27:16 <dons> i wonder if that's the same thing i saw with standalone deriving
20:27:38 <dons> we probably shouldn't make the constructors available (?)
20:28:05 <sjanssen> dons: the constructors should theoretically be safe.  The type checker is failing us here
20:28:33 <dons> ah , it is the generic instance you're selecting
20:28:35 <dons> i see. yes.
20:28:38 <edwardk> sjanssen: PairPair is the (a,b) constructor and PUnit is the () instance?
20:28:40 <dons> how about i disable the generic instance.
20:28:46 <sjanssen> edwardk: yes
20:28:51 <dons> since this looks scary unsound
20:28:57 <sjanssen> dons: should also file a GHC bug
20:29:16 <dons> right.  the type checker should not allow it. rather than silently introducing evil
20:29:21 <dons> same for the standalone deriving case.
20:29:24 <edwardk> ah and the typechecker sees that the (a,b) instance overlaps so it thinks the () instance is just a refinement of it and allows the type refinement
20:29:28 <dons> i'll make notes
20:29:33 <dons> edwardk: yup
20:30:06 <edwardk> sneaky
20:30:24 <dons> trying to get at my representation types, eh?
20:31:23 <dolio> Huh, it catches it when I try to construct an example like in their paper. I wonder why it doesn't catch the one in dons' library.
20:32:26 <dons> maybe that patch is in the head?...
20:32:56 <dons> pushed those patches
20:33:21 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3395#a3395 faults in the same way
20:33:50 <dons> oh, that's a good test caes.
20:33:58 <dolio> That's definitely weird.
20:33:59 <dons> could you file that as the bug?
20:34:00 <dons> ?bug
20:34:01 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
20:34:05 <edwardk> yeah
20:34:50 <dolio> http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=3393#a3394
20:34:53 <dolio> Gets caught there.
20:35:51 <dolio> Maybe they only check for overlap between multiple modules, and not within a single module. :)
20:36:15 <dons> ah, that's the same one i get for List (Pair a b) -> List (Pair Int Int)
20:36:21 <Gracenotes> hm. are there benchmarks comparing STUArray and STArray?
20:36:30 <dons> boxed vs unboxed arrays?
20:36:34 <dons> no, not for a long time
20:36:35 <Gracenotes> yeah
20:36:38 <dons> they're wildly different
20:37:01 <Gracenotes> hrm. I'm wondering if I should make an STArray of Complex Doubles or two STUArrays of Doubles
20:37:21 <Gracenotes> the latter would require zipping/unzipping the Complex Doubles from a list though :)
20:37:52 * Gracenotes could try both and profile.. :x
20:38:29 <dolio> edwardk: Your example doesn't even require {-# LANGUAGE OverlappingInstances #-}.
20:39:17 <dons> Gracenotes: that's something you might want to actually use uvector for
20:39:20 <dons> UArr (Complex a)
20:39:28 <dons> it'll transparently zip two arrays for you
20:39:40 <dons> or at least use it as inspiration
20:40:56 <edwardk> dolio: yeah just TypeFamilies and FlexibleInstances
20:41:03 <edwardk> i noted that in the bug
20:41:03 <Gracenotes> neat :) it cabal-installs without an issue
20:41:17 <edwardk> http://hackage.haskell.org/trac/ghc/ticket/3150
20:41:48 <pumpkin> Gracenotes: the latest one on http://code.haskell.org/~dons/code/uvector/ has a few bugfixes, too
20:41:54 <pumpkin> (and more documentation)
20:42:19 <Gracenotes> neat. some bugs you've discovered?
20:42:44 <Gracenotes> or that have been generally 'discovered' o.o
20:42:46 <pumpkin> mostly minor stuff in some of the enumerable functions
20:42:54 <pumpkin> I'm still working on making it safer
20:43:49 <dolio> I actually don't get a segmentation fault on 6.10.2.
20:43:57 <dolio> Not sure how that's working.
20:44:08 <edwardk> interesting
20:44:40 <edwardk> what is the value you get out of case PUnit of PBar x -> x*2
20:44:45 <edwardk> ?  =)
20:45:03 <dolio> That won't work. x :: ().
20:45:07 <dons> dolio: hmm. interesting. i'm using 6.10.1
20:45:09 <edwardk> oh wait it assumes x :: ()
20:45:10 <edwardk> yeah
20:45:28 <edwardk> hrmm x `mappend` () ? =)
20:45:33 <edwardk> oh wait that defaults too
20:45:40 <edwardk> it ignores its args
20:45:41 <dolio> Oh, but get this. I changed it from Foo () to Foo Int.
20:45:56 <dolio> case PInt of PBar x -> x ==> 3530822653700252807
20:46:11 <edwardk> yeah its just randomly reading from the next word in memory after the constructor
20:46:16 <dolio> :)
20:46:53 <Gracenotes> it seems.. you can use STRefs with UArrs?
20:46:58 <edwardk> i suppose we could have all sorts of fun with data constructor confusion by making multiple constructors
20:47:12 <Gracenotes> somehow :X
20:47:16 <MyCatVerbs> How on Earth did that not fail to match the constructor?
20:47:33 <edwardk> mycatverbs: overlapping instances with data families
20:47:37 <dolio> Because overlapping instances for type families subverts the type system.
20:47:59 <dons> the overlapping just says "sure, that works"
20:47:59 <MyCatVerbs> Is this... wise?
20:48:06 <dons> and bam, unsafeCoerce#
20:48:09 <dolio> It's a bug.
20:48:13 <edwardk> it looks like another kind of 'woops' like back when newtypes could cause similar type family problems
20:48:22 <Gracenotes> also, overlapping delegations in wills for families subverts the inheritance system
20:49:05 <Gracenotes> see, why use a spacesuit metaphor when we have worse ones >_<
20:49:13 <edwardk> plus i don't know how fixable it is. if you allow them to overlap at all you have a problem. because if a later module exports an instance that overlaps with your pair (a,b) instance the compiler won't know about it
20:51:13 <dolio> If by "fix" you mean allow overlapping, but make it sound, I don't think you do it.
20:51:40 <dolio> One of their papers specifically points out that they disallow overlapping for this reason.
20:51:46 <edwardk> yeah
20:52:02 <edwardk> what i meant was there doesn't seem to be a way to allow the overlap
20:53:20 <dolio> The only way you could allow it, I think, is if instances were truly global.
20:54:15 <dolio> And take the most specific instance declared anywhere in the program and use it everywhere.
20:55:18 <dolio> Which means you have to potentially recompile all libraries a program depends on with it, as well, and so on.
20:56:02 <dolio> In fact, code in your program could actually cause code in a library it uses to become incorrect.
20:56:13 <dolio> So that's probably not particularly desirable. :)
20:59:36 <edwardk> trying to see if the same issue comes up with type families, because they don't get the 'you can infer that t a ~ t b -> a ~ b property'
20:59:57 <Tsion> @help pointfree
20:59:57 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:00:02 <Tsion> @help pl
21:00:02 <lambdabot> pointless <expr>. Play with pointfree code.
21:00:24 <dolio> Yeah, but you can have t A ~ () in one place, and t A ~ Int in another.
21:01:32 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3395#a3397 type families were still sound
21:02:24 <edwardk> are a bunch of type families sufficient to the cause? or will the lack of t a ~ t b => a ~ b be a problem?
21:08:37 <pumpkin> @hoogle Float -> Int
21:08:38 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
21:08:38 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
21:08:38 <lambdabot> Prelude exponent :: RealFloat a => a -> Int
21:10:55 <edwardk> trying to see if i can make that work with type families now by moving the data types out of the classes
21:11:21 <dolio> I have something that almost works, but it still raises a type error for reasons I can't figure out.
21:11:47 <kamysh> @hoogle (Monad m) =>  a -> [b] -> (a -> b -> m a) -> m a
21:11:47 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:11:47 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
21:11:47 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
21:12:03 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3395#a3398
21:12:30 <dolio> f v :: Foo (), but if I try to force it to Int, it says that it can't match Foo () with Int.
21:13:10 <dolio> But it doesn't match (), either.
21:13:18 <dolio> So apparently it just refuses to reduce it.
21:14:36 <jfredett> anyone care to help me w/ a State Monad error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3399#a3399
21:15:33 <edwardk> dons: i almost got it to work by ttranslating to type families, but its not happy about the Bounded, Eq, Ord and Show instances for Pair a b
21:15:51 <kamysh> @pl (a->b->c->d) -> (b->c->a->d)
21:15:51 <lambdabot> (line 1, column 3):
21:15:52 <lambdabot> unexpected ">"
21:15:52 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
21:16:08 <jfredett> also, associated types are awesome.
21:17:25 <dolio> jfredett: deck <- get in dealHands should be (Deck deck) <- get.
21:17:36 <jfredett> hmm
21:17:38 <jfredett> OH!
21:17:41 <jfredett> I'm an idiot
21:18:09 <jfredett> dolio++
21:18:16 <dolio> @karma
21:18:16 <lambdabot> You have a karma of 1
21:18:18 <dolio> Woo!
21:19:31 <kamysh> (a->b->c->d) -> b->c->a->d
21:20:00 <edwardk> hrmm, as i was worried about, the type family one doesn't like fromPair
21:20:19 <kamysh> @pl (a->b->c->d) -> b->c->a->d
21:20:19 <lambdabot> (line 1, column 3):
21:20:19 <lambdabot> unexpected ">"
21:20:19 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
21:22:27 <edwardk> dons: http://comonad.com/haskell/Tuple.hs
21:22:45 <edwardk> dons: still has issues from fromPair and the instances but it catches everything else
21:24:00 <edwardk> it seems anything that wants Pair a b in negative position (on the left of a ->) blows up
21:24:08 <dolio> Why are you rewriting it with type families?
21:24:38 <edwardk> dolio: because type families offer a weaker guarantee of 'sameness'
21:25:13 <edwardk> if the type checker was assuming that because t a ~ t (), that a ~ () thanks to t being a data family, this would fix that by disallowing the reduction
21:25:32 <edwardk> of course by disallowing it, it apparently keeps a lot of other things from happening =)
21:25:50 <edwardk> but it was just a few minutes and a couple of regexes to try
21:26:05 <disgrntld> http://pastebin.com/m24573138 can someone explain why I have to use "fromIntegral" on "secsToWeeks3"?
21:26:06 <dolio> But why is that an advantage here?
21:26:43 <edwardk> *Data.Adaptive.Tuple> case PUnit of PBool x y -> x                  ==>     Couldn't match expected type `PUnit' against inferred type `PBool'
21:27:02 <dolio> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3395#a3398
21:27:26 <dolio> You can still write unsound code, that GHC doesn't accept for some reason.
21:28:10 <edwardk> oh well
21:30:20 <disgrntld> anyone? I don't understand the necessity of fromIntegral on http://pastebin.com/m24573138
21:31:49 <dolio> Due to the monomorphism restriction, perWeek has to have a monomorphic type. For some reason, either Int or Integer is getting picked, despite the fact that you need it to be fractional.
21:32:44 <disgrntld> thanks, I need to look up what monomorphism is..
21:33:27 <edwardk> try comnpiling without the fromIntegral and -XNoMonomorphismRestriction and see if it goes away for you
21:33:41 <edwardk> er and add
21:33:45 <DarthArachides> I have been trying to get a Parser monad working but keep getting "Ambiguous occurrence" errors from ghci
21:33:59 <DarthArachides> Code in question is http://pastebin.com/d1c239803
21:34:07 <edwardk> then you should read up on the monomorphism restriction and see why type annotations are a good thing ;)
21:34:21 <DarthArachides> and the offending function is ++ on line 24.
21:34:24 <DarthArachides> Can anyone help me?
21:34:26 <disgrntld> ok edwardk, thanks
21:34:45 <disgrntld> was I supposed to add anything else besides -XNoMonomorphismRestriction ?
21:35:02 <orzo> hello
21:35:09 <orzo> I'm trying to use 32 bit ghc on os x
21:35:13 <dons> edwardk: interesting.
21:35:17 <orzo> but its 64 bit os x
21:35:28 <orzo> it works, except when it comes time to invoke the assembler
21:35:50 <orzo> ghc is invoking the assembler as if it's going to compile 64 bit code instead of 32 bit code
21:35:56 <edwardk> dons: it was worth a try but in the end i failed ;)
21:36:17 <orzo> is there a way to tell ghc some extra options for use with the assembler?
21:36:24 <dons> so no difference from the associated data types version, in the end?
21:36:27 <dons> orzo: yeah, -optl-foo
21:36:38 <edwardk> dons: differences yes
21:37:11 <edwardk> dons: you catch the case PUnit of PBool x y -> x -- but you can't define your instances, uncurry of fromPair
21:37:25 <edwardk> er uncurry or fromPair
21:38:24 <edwardk> er by instances i mean the uniform Bounded (Pair a b), etc instances
21:38:35 <dons> ah
21:38:54 <edwardk> because that is a type family, you can of course define it for each of the hundreds of data types individually
21:38:57 <DarthArachides> Is there any way I can tell ghc to give more preference to locally defined funtions, than to those imported from Prelude?
21:39:14 <edwardk> the fromChar and uncurry problem is more troubling though
21:39:14 <DarthArachides> It keeps getting confused, and spews out "Ambiguous occurence" errors
21:39:52 <edwardk> i suppose even THAT could be solved by changing the signature for AdaptPair a b
21:40:03 <pumpkin> is SPECIALIZE-generated code exposed in .hi files? if I specialize an exported function, will modules importing it use the specialized version if it's available?
21:40:33 <edwardk> class Projective (Pair a b) => AdaptPair a b where type Pair a b :: *; ... -- and move the fst and snd into Projective
21:41:12 <edwardk> that might be sufficient to solve the current set of problems. not enough to keep determined folks from pulling dolio's 'witness' trick but enough to get by perhaps
21:41:14 <orzo> dons, thanks, is there a way to tell configure to use these options when i'm bootstrapping?
21:42:47 <edwardk> it means about 7 times as many classes though being automatically generated, because you need to generate the Eq, Ord, Bounded, etc. and the Projective instance for each data type individually, along with the AdapPair for each pair of data types
21:43:54 * Heffalump reads the instances in Data.Adaptive.List, ewww!
21:44:10 <edwardk> oh woops. class (Projective (Pair a b), Fst (Pair a b) ~ a, Snd (Pair a b) ~ b) => AdaptPair a b where type Pair a b :: *
21:44:27 <edwardk> that should give you enough type constraints to get by
21:44:35 <Heffalump> do superclass constraints work now??
21:44:47 * Heffalump has been waiting for those for ages
21:45:32 <edwardk> testing
21:45:35 <edwardk> i might be mistaken
21:48:38 <edwardk> ah nope
21:48:54 <edwardk> does the oleg TypeCast trick still work? =)
21:49:06 <Heffalump> you can often just put them on all the instances instead
21:49:16 <Heffalump> tedious, of course
21:49:36 <orzo> hm
21:49:40 <edwardk> i don't think its sufficient in this case but i'll try
21:50:08 <orzo> i'm trying to build happy and Setup.lhs configure is failing with a type match error
21:51:01 <pumpkin> hah, writing monadic traversals for uvector is proving harder than I'd expected
21:51:15 <orzo> `Distribution.Verbosity.Verbosity' against infered type `Distribution.Simple.Setup.Flag Distribution.Verbosity.Verbosity'
21:51:59 <edwardk> well i got fromPair and uncurry to compile by moving the Fst (Pair a b) ~ a, Snd (Pair a b) ~ b declarations into them
21:52:27 <edwardk> er constraints
21:55:17 <pumpkin> how would things go wrong if sequence were defined in terms of foldl' instead of foldr?
21:55:24 <pumpkin> (with a flipped sequencing operator)
21:55:47 <dolio> Wouldn't that execute things in the wrong order?
21:55:57 <pumpkin> that sounds pretty wrong :P
21:56:03 <pumpkin> hmm
21:57:23 <DarthArachides> is ghci Can't ghc detect which definition of function to use depending on context?
21:57:35 <DarthArachides> err, s/is ghci/
21:58:12 <ManateeLazyCat> In "instance (Eq a) => Eq (Tree a) where", what is mean '=>' ? I don't understand how to use '=>'. Anyone describe it? Thanks.
21:58:40 <sjanssen> pumpkin: foldl' would be pretty wrong for sequence_, since it could take an infinite list
21:58:47 <pumpkin> sjanssen: hmm, yeah
21:58:53 <ManateeLazyCat> > :t (=>)
21:58:54 <lambdabot>   <no location info>: parse error on input `:'
21:58:58 <DarthArachides> ManateeLazyCat: That means that to define "Eq (Tree a)", there should be a way to equate values of type a
21:59:06 <dolio> > let sequence' = foldl (\ml me -> me >>= \e -> ml >>= \l -> return (e:l)) (return []) ; pop = do (e:es) <- get ; put es ; return e in (runState (sequence [pop,pop,pop]) [1,2,3], runState (sequence' [pop,pop,pop]) [1,2,3])
21:59:07 <lambdabot>   (([1,2,3],[]),([1,2,3],[]))
21:59:16 <DarthArachides> ManateeLazyCat: its a way to indicate prerequisites
21:59:28 <dolio> Hmm, maybe not.
21:59:40 <DarthArachides> :t sum
21:59:41 <lambdabot> forall a. (Num a) => [a] -> a
21:59:52 <pumpkin> I'm trying to define the various monadic traversal functions on UArr, and it's proving rather difficult given that UArrs can't contain arbitrary things (which rules out all the sequence . map stuff) and don't have foldr defined on them
22:00:10 <Gracenotes> okay, I've implemented the Cooley-Tukey FFT algorithm with STArrays, translated from a C++ version. As a result, it is an unbelievably ugly piece of code (but fast): http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3400
22:00:50 <Gracenotes> should be O(n log n) time
22:00:55 <pumpkin> I should hope so
22:00:59 <pumpkin> ;)
22:01:07 <dolio> > let sequence' = foldl (flip $ liftM2 (:)) (return []) ; pop = do (e:es) <- get ; put es ; return e in (runState (sequence [pop,pop,pop]) [1,2,3], runState (sequence' [pop,pop,pop]) [1,2,3])
22:01:09 <lambdabot>   (([1,2,3],[]),([1,2,3],[]))
22:01:16 <dolio> I guess it does work.
22:01:20 <ManateeLazyCat> DarthArachides: In ghci, i type ":t (>>=)", i will got "(>>=) :: (Monad m) => m a -> (a -> m b) -> m b", but i type ":t (=>)", return nothing, i want to know what is '=>'?
22:01:42 <DarthArachides> ManateeLazyCat: (=>) is not a operator
22:01:46 <pumpkin> dolio: so it wouldn't be terrible if I defined those functions in terms of foldl?
22:01:48 <DarthArachides> ManateeLazyCat: (>>=) is
22:02:02 <pumpkin> no danger of infinite lists
22:02:22 <ManateeLazyCat> DarthArachides: So '=>' is?
22:02:28 <pumpkin> syntax
22:02:32 <dolio> > let sequence'_ = foldl (flip (<<)) (return ()) ; acks = [tell 1, tell 2, tell 3] in (runWriter (sequence_ acks), runWriter (sequence'_ acks))
22:02:33 <lambdabot>   Not in scope: `<<'
22:02:40 <dolio> > let sequence'_ = foldl (flip (>>)) (return ()) ; acks = [tell 1, tell 2, tell 3] in (runWriter (sequence_ acks), runWriter (sequence'_ acks))
22:02:41 <lambdabot>   Add a type signature
22:03:06 <dolio> > let sequence'_ = foldl (flip (>>)) (return ()) ; acks = [tell [1], tell [2], tell [3]] in (runWriter (sequence_ acks), runWriter (sequence'_ acks))
22:03:07 <lambdabot>   (((),[1,2,3]),((),[3,2,1]))
22:03:12 <dolio> There we go.
22:03:13 <Gracenotes> :o
22:03:20 <DarthArachides> ManateeLazyCat: look at :t sum
22:03:20 <DarthArachides> :t sum
22:03:22 <lambdabot> forall a. (Num a) => [a] -> a
22:03:28 <pumpkin> hmm
22:03:32 <pumpkin> guess it breaks then :P
22:03:37 <DarthArachides> ManateeLazyCat: this means that to define a function sum, the type a should be a Num
22:03:49 <Gracenotes> @instances Num
22:03:50 <lambdabot> Double, Float, Int, Integer
22:04:06 <Gracenotes> so you could send a list of any of those to the sum function
22:04:28 <Gracenotes> it'll give you the sum, with the same type
22:04:55 <edwardk> dons: might have something
22:05:04 <Gracenotes> (a homogeneous list though: all Ints, all Doubles, etc.)
22:05:21 <ManateeLazyCat> DarthArachides: So '=>' just syntax character like '::' for describe the type?
22:05:29 <pumpkin> dolio: can you see any issues with defining a foldr on UArr? it's easy to define on the stream rep
22:05:39 <DarthArachides> ManateeLazyCat: yes! you won't ever use it in executable code.
22:05:42 <ManateeLazyCat> DarthArachides: More exactly, is 'indicate'
22:06:01 <DarthArachides> ManateeLazyCat: I would say "is a prequisite for"
22:06:18 <dolio> pumpkin: No, folding from either end of an array is about the same.
22:06:20 <ManateeLazyCat> DarthArachides: I see, clear enough. Thank you very much! :)
22:06:28 <dolio> If it's actually an array.
22:06:48 <ManateeLazyCat> I consider '=>' is operator before, it confuse me.x :)
22:07:07 <dolio> Of course, in uvector it'll all get rewritten to the streams anyway.
22:07:35 <pumpkin> dolio: yeah, and the stream foldr I can just copy and paste from stream-fusion
22:08:36 <Gracenotes> @src fromIntegral
22:08:36 <lambdabot> fromIntegral = fromInteger . toInteger
22:11:34 <edwardk> drat that version complains about the type families overlapping
22:12:43 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3395#a3401 is where i tried to take things
22:12:47 <BMeph> Would anyone be interested in a workup of Chars/Strings a la Slava?
22:13:51 <edwardk> by letting the tuple type own the fst and snd type, i can work around the lack of type equality constraints in instance heads, i can make the Bounded,Eq etc instances still inherit uniformly with a newtype wrapper, but i can't make the AdaptPair instances allow overlap any more
22:15:23 <dolio> Is PBool !Int !Int is the best representation for boolean pairs?
22:15:34 <edwardk> OTOH, it yields a fst, snd and curry that can be directly applied to (a,b) like the original ones
22:15:41 <edwardk> it was dons version i just stole it
22:15:42 <dolio> I mean, at least you could do it with one Int.
22:15:49 <dolio> Yeah, I know.
22:16:26 <dolio> And TT | FF | TF | FT might be just a tag byte?
22:16:40 <dolio> Or however it's represented.
22:16:51 <edwardk> yeah
22:17:45 <dolio> PBool !Int might be better, though. The 4 constructors might not unpack into other things.
22:17:49 <dons> dolio: it was abitrary. maybe look in scripts/size.hs
22:17:51 <dolio> I'm not really sure.
22:17:54 <dons> to work out the size of the constructor
22:18:07 <dons> it provides unsafeSizeofClosure
22:18:13 <dons> which can guide representation choices.
22:18:22 <dons> (though it's a little buggy with unpacked stuff, i think)
22:18:31 <dons> we could just put the tag in
22:18:37 <dons> getTag# ?
22:18:49 <dons> unpack arbitrary sums that way?
22:18:50 <edwardk> trying the tagged instance
22:19:06 <edwardk> hrmm
22:19:10 <dolio> I'd say PBool !Word8, but I seem to recall the underlying representation of all that stuff being the same Word#.
22:19:12 <dons> another thing would be to measure    the preformance of e.g. and
22:19:26 <dolio> So it probably doesn't make a difference up to Word32.
22:20:31 <edwardk> dolio: happier? http://comonad.com/haskell/Test.hs =)
22:21:12 <edwardk> dons: and yeah you should be able to fit it right into the tag bits
22:21:31 <pumpkin> alright, my local UArr now has a foldrU
22:22:44 <edwardk> dons: the version in that paste doesn't let you make pairs of boxed types into an instance of AdaptPair, but it also doesn't require it for all of the machinery. you have Tuple's which include (a,b) and the adaptable pairs, and AdaptPair which allows you to just ask for the fast pair for any pair of types
22:23:07 <edwardk> so it doesn't abstract over the fast/slow boundary but it does get you the ability to use the same fst, snd, pair, etc. combinators over each.
22:23:08 <steveklabnik> i just use vim
22:25:21 <lunabot>  luna: lexical error in string/character literal at end of input
22:28:34 <pumpkin>     Can't find interface-file declaration for variable mapMU_
22:28:34 <pumpkin>       Probable cause: bug in .hi-boot file, or inconsistent .hi file
22:28:35 <pumpkin> :o
22:29:33 <orzo> is there a way to upgrade ghc-pkg without upgrading ghc?
22:29:50 <haro> hi, i'm trying to write a function that works on the classic fibs function
22:29:55 <jfredett> ... is there a reason I can't quickcheck properties that require IO? I want to confirm my shuffle isn't frakking things up...
22:30:28 <mmorrow> pumpkin: are you in ghci with -fobject-code?
22:30:36 <haro> it would be au , and would zipWith (/) (last fibs) fibs
22:30:40 <pumpkin> nope, but I'd forgotten to add my new module to the .cabal file
22:30:44 <blackh> jfredett: There is a reason, but it's quite a philosophical one.
22:30:45 <pumpkin> Prelude Data.Array.Vector> mapMU_ print (toU [1..10])
22:30:45 <pumpkin> 1.0
22:30:45 <pumpkin> 2.0
22:30:45 <pumpkin> 3.0
22:30:50 <pumpkin> and so on
22:30:53 <mmorrow> pumpkin: ahh, i hate when that happens
22:31:10 <mmorrow> a half-second feeling of terror, then "ohhh"
22:31:12 <haro> but ghci complains saying  No instance for (Fractional Integer)
22:31:13 <pumpkin> :P
22:31:14 <blackh> jfredett: ...the short version of which is that ideally you want to eliminate IO from as much code as possible
22:31:31 <jfredett> blackh: hmm
22:31:37 <haro> where should I add that declaration? in the (/) ?
22:31:37 <jfredett> thats silly
22:31:48 <jfredett> damn academics and your ivory towers. :P
22:32:07 <pumpkin> mapM is going to be harder :/
22:32:18 <ddarius> jfredett: Go back to your pragmatic mathematics.
22:32:22 <jfredett> coming with invariants for this stuff is hard enough! :)
22:32:29 <blackh> jfredett: Well, you asked what the reason was, not "How do I get around... ?" :)
22:32:49 <jfredett> blackh: okay, consider it asked, how do I circumvent this limitation
22:32:56 <pumpkin> > mapM (\x -> [x, 1]) [1..5]
22:32:57 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,1],[1,2,3,1,5],[1,2,3,1,1],[1,2,1,4,5],[1,2,1,4,1],[1...
22:33:01 <blackh> jfredett: unsafePerformIO
22:33:03 <jfredett> ddarius: at least we mathematicians advertise our aim for uselessness.
22:33:09 <jfredett> blackh: makes my prop hang.
22:33:18 <jfredett> 0 tests... maybe it's just going slow? hmm
22:33:25 <pumpkin> crap, there's no way I'm getting mapM on UArrs :P
22:33:31 <jfredett> Thanks, I'll just have to muck with it.
22:33:36 <blackh> jfredett: Well, also it could be that unsafePerformIO doesn't work in this case, which is fairly likely.
22:33:36 <pumpkin> actually, I can
22:33:49 <blackh> jfredett: What IO is it doing?
22:34:02 <Gracenotes> haro: you shouldn't add the declaration :) try to convert between numerical types so it works out
22:34:04 <haro> filterM and mapM do so wierd things
22:34:21 <jfredett> it just needs to get some random numbers to shuffle the deck with
22:34:29 <pumpkin> my problem is that I can't take the easy way out of defining mapM
22:34:33 <Gracenotes> haro: to use an Integer with (/), fromIntegral it first
22:34:36 <jfredett> I'm checking to ensure my shuffled deck is the same as the original
22:34:50 <haro> Gracenotes: let's try
22:34:52 <jfredett> maybe I can hijack a RandomGen from QC...
22:34:58 <Gracenotes> > let a = 4 :: Int, b = 3 :: Int in fromIntegral a/fromIntegral b
22:34:59 <lambdabot>   <no location info>: parse error on input `,'
22:35:02 <Gracenotes> :O
22:35:04 <jfredett> are Gens Gen-able? hmm
22:35:08 <Gracenotes> > let a = 4 :: Int; b = 3 :: Int in fromIntegral a/fromIntegral b
22:35:09 <lambdabot>   1.3333333333333333
22:35:24 <Gracenotes> haro: however, if you just want integer division, use div
22:35:31 <Gracenotes> > let a = 4 :: Int; b = 3 :: Int in a `div` b
22:35:32 <lambdabot>   1
22:35:34 <ddarius> Does QuickCheck have QuickCheck tests?
22:35:51 <jfredett> ddarius: deep.
22:35:57 <Gracenotes> mu.
22:36:11 <blackh> jfredett: I am not really a quickcheck power user... However... QuickCheck can give you arbitrary things ...
22:36:17 <jfredett> hrm
22:36:26 <mmorrow> ddarius: happy uses itself to parse it's grammar for grammar specification
22:36:42 <pumpkin> ack, this is hard
22:37:01 <jfredett> I'll peruse the (incredibly obtuse) list of type sigs hoogle says is the "documentation" for QC. Onward!
22:37:04 <jfredett> :/
22:37:06 <blackh> jfredett: If your code was pure and used RandomGen, you could make RandomGen an instance of Arbitrary ...
22:37:18 <jfredett> hmm
22:37:24 <jfredett> suresure... that could work
22:37:34 <blackh> jfredett: Then you could say... "for an arbitrary RandomGen, is this invariant true?"
22:37:35 <Gracenotes> huh.
22:37:36 <jfredett> I'm just hijacking the recent random-shuffle library
22:37:39 <haro> Gracenotes: zipWith (\ x y -> (fromIntegral x)/(fromIntegral y)) (tail fibs) fibs    worked great
22:38:05 <haro> Gracenotes: I wonder how I can write that , freepoint style
22:38:10 <blackh> jfredett: Really the problem is that QuickCheck is only designed to work with pure code - at least I am fairly sure this is true.
22:38:11 <Gracenotes> using Data.Function.on
22:38:14 <pumpkin> @src foldM
22:38:14 <lambdabot> foldM _ a []     = return a
22:38:14 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:38:23 <Gracenotes> haro: (/) `on` fromIntegral
22:38:29 <Gracenotes> @type on
22:38:30 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:38:36 <Gracenotes> you have to import Data.Function though
22:38:37 <mmorrow> @type guard
22:38:38 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
22:38:39 <jfredett> blackh: yeh. is there an alternative? I've heard of smallcheck, but i don't know if thats any better.
22:38:48 <Gracenotes> hm.. let's see what pl says
22:38:51 <Gracenotes> @pl \x y -> (fromIntegral x)/(fromIntegral y)
22:38:52 <lambdabot> (. fromIntegral) . (/) . fromIntegral
22:38:52 <haro> Gracenotes: very magical :-)
22:39:17 <mmorrow> that's one of the purdier @pl's i've seen
22:39:25 <Gracenotes> yeah. imho on should be in the Prelude, put.. anyways :O
22:39:33 <haro> Gracenotes: what would complete the magic would that fromIntegral appeared only once
22:39:40 <blackh> jfredett: HUnit would work and could do what you want without much difficulty, but it's not as snazzy as quickcheck
22:39:56 <Gracenotes> haro: yeah. and (/) `on` fromIntegral does that well. .. hm
22:40:17 <haro> Gracenotes: yes, thanks!
22:40:17 <jfredett> well, HUnit => Unit testing => roll my own random-repeat-this-alot type check, right?
22:40:25 <jfredett> that'd be a pain... :/
22:40:30 <jfredett> I don't like pains
22:40:34 <jfredett> I'm lazy.
22:41:16 * jfredett |- error: Prelude.slothful.
22:42:32 <blackh> jfredett: That is true.  One way to look at it is this:  The IO monad is (in OO terminology) the ultimate "high coupling interface" and it'll tend to drag your whole program down...
22:42:44 <jfredett> yeh...
22:42:50 <haro> I think au is my first genuine haskell function :-)
22:43:01 <blackh> So the ivory tower thing of making your code pure does help you.  It's Good For You!!!!!!
22:43:07 <jfredett> lol
22:43:53 <jfredett> blackh: yah. I think I got this thing though- the arbitrary instance for RandomGen is pretty straightforward... so pure code prevails, (maybe)w
22:44:23 <pumpkin> is it not possible to write foldM using foldr?
22:44:33 <dibblego> @src foldM
22:44:33 <lambdabot> foldM _ a []     = return a
22:44:33 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
22:44:36 <blackh> You could try the RandomState monad. That'll make your code pure but you won't need to pass stuff around.
22:44:47 <blackh> You probably won't even need to change it much.
22:45:28 <Gracenotes> @type (.) <$> (>>>) <*> ((/).) $ fromIntegral
22:45:30 <lambdabot> forall b b1. (Integral b, Fractional b1) => b -> b -> b1
22:45:37 <Gracenotes> ^ a much more deviant way to write (/) `on` fromIntegral
22:45:41 <b\6> if i'm in ErrorT String IO a, do i need to put catch around stuff like writeFile?
22:47:12 <pumpkin> :t foldM f z = foldr (\x y -> f x =<< y) (return z)
22:47:13 <lambdabot> parse error on input `='
22:47:23 <pumpkin> :t \f z -> foldr (\x y -> f x =<< y) (return z)
22:47:24 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> a1 -> m a1) -> a1 -> [a] -> m a1
22:47:29 <pumpkin> not quite
22:47:53 <adamvo> isn't foldM a left fold?a
22:48:02 <pumpkin> sort of... hmm
22:48:13 <pumpkin> you're right
22:48:25 <Gracenotes> there's no foldrM
22:48:29 <Gracenotes> although there perfectly well could be
22:48:45 <dolio> @hoogle foldrM
22:48:46 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
22:48:46 <Gracenotes> ..I think
22:48:52 <Gracenotes> well, there you go
22:48:59 <pumpkin> :P
22:49:08 <pumpkin> I just care about foldM, I guess all I need is foldl
22:49:24 <dibblego> if foldM is a foldl then why isn't @src tail recursive?
22:49:51 <dolio> It's monadic tail recursive.
22:50:13 * Gracenotes sends a fax
22:50:35 <Gracenotes> or why-ever the temp variable was called fax
22:51:01 <Gracenotes> I suppose it's a cute combination of (f a x). sometimes I'll do things like (s:t:ring).. anyway.
22:51:17 <pumpkin> :t \f z -> foldl (\x y -> x >>= f y) (return z)
22:51:18 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> a -> m a) -> a -> [b] -> m a
22:51:22 <pumpkin> how's that look?
22:51:32 <pumpkin> :t foldM
22:51:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:51:36 <pumpkin> crap
22:51:57 <pumpkin> :t \f z -> foldl (\x y -> x >>= flip f y) (return z)
22:51:58 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:52:48 <Gracenotes> and so continues pumpkin's quest to fold the world into submission -.-
22:53:07 <pumpkin> indeed!
22:53:58 <pumpkin> what's a good simple test of foldM?
22:55:36 <Gracenotes> > foldM (:) 0 [[1],[2,3],[4,5,6]]
22:55:37 <lambdabot>   [0,4,5,6,2,4,5,6,3,4,5,6,1,4,5,6,2,4,5,6,3,4,5,6]
22:55:48 <Gracenotes> useless, but.. a test :X
22:56:04 <dolio> > runWriter $ foldM (\_ e -> tell e) () (map return [1..])
22:56:05 <lambdabot>       No instance for (Show (m a))
22:56:05 <lambdabot>        arising from a use of `show' at <in...
22:56:49 <pumpkin> Gracenotes: can't use lists :/
22:57:04 <Gracenotes> oh, your loss, sir.
22:57:54 <pumpkin> indeed
22:58:11 <pumpkin> don't have a UA [a] yet :P
22:58:17 <pumpkin> doubt we ever will
22:58:24 <dolio> > runWriter $ foldM (\_ e -> tell e) () (map (:[]) [1..10])
22:58:26 <lambdabot>   ((),[1,2,3,4,5,6,7,8,9,10])
22:58:34 <dolio> > runWriter $ foldM (\_ e -> tell e) () (map (:[]) [1..])
22:58:49 <lambdabot>   thread killed
22:58:54 <Gracenotes> pumpkin: ah. A bit of a porblem.
22:59:15 <Gracenotes> what are some requirements for UA instances?
22:59:32 <pumpkin> each element being of a fixed size and being unboxable
22:59:58 <adamvo> UA is UArray?
23:00:09 <Gracenotes> *looks at source* I see
23:00:11 <pumpkin> it's the class of types that can be UArr elements
23:01:01 <adamvo> thanks
23:01:15 <pumpkin> I wonder how to do the ones that use sequence, efficiently
23:02:03 <pumpkin> I can't actually write a useful sequence
23:02:15 <pumpkin> (sequenceU, that is)
23:04:16 <dolio> You might be able to do it, aside from the fact that you can't write sequence_U, either.
23:04:31 <pumpkin> sequence_U wasn't hard, actually
23:04:38 <pumpkin> oh actually
23:04:42 <pumpkin> yeah, I didn't write that either
23:04:45 <dolio> But UArrs can't contain monadic actions.
23:04:50 <pumpkin> but the _ forms of things are quite easy
23:04:56 <pumpkin> so I don't really need sequence_
23:05:33 <pumpkin> mapMU_ f = foldrU (\x y -> f x >> y) (return ()) (ignoring for now the name conflict with MUArrs)
23:05:46 <orzo> when trying to build happy, i get an error telling me that happy is required
23:05:51 <Gracenotes> ::(o:
23:06:16 <dolio> Anyhow, for each element of the array, you can generate an m (ST ()), where what's returned is an action that writes the result to the corresponding position in a mutable array.
23:06:38 <pumpkin> hmm, that's an interesting idea
23:06:45 <dolio> Then you somehow combine them all into an ST () that writes all the positions in the mutable array, and use newU to get the pure array using that.
23:07:01 <pumpkin> smart :P
23:07:09 <dolio> Or something along those lines.
23:07:43 <dolio> That probably isn't fast, though.
23:07:57 <pumpkin> probably faster than the naive translation of sequence . map
23:08:28 <dolio> Of course, sequence for streams is easy, so it may not matter ultimately. :)
23:08:51 <pumpkin> yeah, maybe I should just be writing this on the stream side of things
23:09:05 <pumpkin> instead of in terms of the exposed uvector API
23:10:04 <pumpkin> hmm actually it may still be quite hard to unstreamU that
23:11:42 <dolio> I doubt it will fuse nicely.
23:11:53 <pumpkin> me too
23:12:27 <pumpkin> but the ones I haven't had trouble writing so far shouldn't be bad
23:13:19 <pumpkin> maybe it'd be possible to do something using unfoldU
23:15:35 <dolio> I don't think you can make a sequence/etc. for streams that follows the usual rules for their optimization.
23:16:03 <dolio> Because you need to demand the whole stream before returning anything.
23:16:04 <pumpkin> mapMU (\x -> print x >> getChar) (toU [1..10]) this works now, but is probably the slowest code I've ever written :P
23:16:08 <pumpkin> yeah
23:17:01 <pumpkin> it feels like replicateMU should be possible to do quite simply using unfoldU
23:17:16 <pumpkin> actually, probably not again :/
23:17:27 <pumpkin> bah :P
23:17:28 <dolio> That has the same problem, really.
23:17:58 <pumpkin> oh well, I don't really need those
23:18:31 <pumpkin> the main goal is to be able to do ST-ish things by traversing UArrs
23:18:42 <pumpkin> not sure what yet
23:19:03 <pumpkin> but we could copy a UArr to a MUArr now, without using the built-in method
23:19:37 <haro> insidiouos question: does haskell "guess" which monad corresponds to a "do" based on the names in it ?
23:19:47 <pumpkin> haro: only by the types
23:19:56 <pumpkin> and no guessing is needed
23:20:11 <pumpkin> if it doesn't know what you're talking about, it'll tell you to tell it
23:20:13 <kerlo> > let N0+t|-|3m0$+s3(xxx|_||23o|=p4$$\/\/0|2|xxx)$xxx = 23 in N0+t|-|3m0$+s3(xxx|_||23o|=p4$$\/\/0|2|xxx)$xxx
23:20:16 <haro> pumpkin: just like type inference, say, monad inference ?
23:20:17 <lambdabot>   <no location info>: parse error on input `|'
23:20:21 <kerlo> Aww.
23:20:33 <pumpkin> haro: monads are no different from anything else
23:20:40 <pumpkin> it's just regular type inference
23:20:48 <pumpkin> there's just a Monad typeclass
23:21:01 <haro> interesting
23:21:16 <pumpkin> haro: do is just syntactic sugar for sequencing and binding
23:21:53 <haro> pumpkin how would one do sequencing and binding without do ?
23:21:57 <erikc> lifting and binding, sequencing depends on the Monad instance :)
23:22:01 <pumpkin> >> and >>=
23:22:27 <pumpkin> @undo do x; a <- y; f a
23:22:27 <lambdabot> x >> y >>= \ a -> f a
23:22:35 <newsham> ?undo do { this >>= that >> the >>= \x -> other x; return (x+5) }
23:22:35 <lambdabot> this >>= that >> the >>= \ x -> other x >> return (x + 5)
23:22:57 <newsham> ?undo do { this; that; x <- the; other x; return (x+5) }
23:22:57 <lambdabot> this >> that >> the >>= \ x -> other x >> return (x + 5)
23:22:58 <newsham> oops
23:23:42 <pumpkin> dolio: ah well, I can't really think of a good fusible way to do the ones based on sequence... I guess the other ones will have to do for now :P
23:24:01 <dolio> You could try looking at what they do in stream-fusion.
23:24:15 <pumpkin> I did, they don't even take it to the streams
23:24:21 <dolio> Heh.
23:24:28 <pumpkin> they just do the regular list version: sequence (map f xs)
23:24:30 <dolio> That doesn't surprise me.
23:24:40 <pumpkin> since streams can accomodate the monadic elements
23:24:43 <orzo> hm
23:25:04 <orzo> anybody able to build happy 1.17 ?
23:25:09 <pumpkin> *accommodate
23:25:23 <orzo> it's complaining to me that te program happy is requierd
23:25:33 <pumpkin> cabal install happy ?
23:25:38 <orzo> but of course, that's the program i'm trying to build and isntall
23:25:57 <haro> what does sequence function do ?
23:26:04 <pumpkin> @src sequence
23:26:04 <lambdabot> sequence []     = return []
23:26:05 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
23:26:05 <lambdabot> --OR
23:26:05 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
23:26:43 <haro> can i do @src in ghci ?
23:27:02 <pumpkin> nope
23:27:51 <orzo> i don't have a cabal binary
23:29:06 <haro> is sequence related in some obscure way to >>   ?
23:31:17 <pumpkin> sequence is kind of hard to explain, but it's more closely related to >>= than >> (which is just >>= that ignores the argument)
23:31:40 <pumpkin> sequence [putStrLn "ohai", putStrLn "moo"]
23:31:47 <pumpkin> will print ohai then moo
23:32:21 <mauke> :t sequence
23:32:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:32:38 <mmorrow> here's that monadLib Label/Cont/jump method in a nutshell http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2056#a2056
23:33:41 <mmorrow> (w/ slight mod to the monadLib type of Label)
23:33:47 <mauke> > sequence ["ab", ".", "123"]
23:33:49 <lambdabot>   ["a.1","a.2","a.3","b.1","b.2","b.3"]
23:34:05 <mmorrow> nice
23:34:24 <pumpkin> haro: I'll be impressed if you're new to haskell and you can see the link between the use of sequence I wrote and the one mauke wrote :P
23:35:37 <pumpkin> mauke: I ended up installing data-default :) it's a nice idea
23:35:44 <mauke> whee
23:36:08 <mauke> I think it's especially nice for some record types
23:36:22 <pumpkin> oh yeah
23:36:33 <pumpkin> ooh, new hash combinator lib on hackage
23:37:45 * mmorrow chuckles about how jon harrop gets things done for haskell
23:37:50 <pumpkin> ?
23:37:56 <pumpkin> oh, I see :)
23:38:06 <mmorrow> :)
23:39:38 <mmorrow> mauke: yeah, record with a Default/equiv class like that are supar handay
23:39:47 <mmorrow> records
23:39:51 <edwardk> mmorrow: yeah i should start a troll account and complain about how there are no good monoid libs, and people don't pay enough attention to parsing and see how much help i'd get ;)
23:40:20 <mmorrow> edwardk: hehe
23:41:17 <dolio> Parsing is practically the only thing people use functional languages for.
23:43:28 <pumpkin> I really want a fusion visualizer :P
23:43:46 <pumpkin> or general rewrite rule visualizer, I guess
23:44:08 <pumpkin> which would probably require a full visualization of all simplifier passes
23:44:17 <mmorrow> dolio: that and hippy dope smoking
23:44:35 <haro> how is it called when one wants to map over a list, doing a calculation that would resemble more a fold, being that each next element in the mapping depends on ints predecessor ?
23:44:36 <mmorrow> fibs too
23:44:45 <pumpkin> don't we also use functional languages to build ivory towers our academic safe havens?
23:45:04 <pumpkin> :t mapAccumL
23:45:05 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:45:20 <pumpkin> ?
23:45:28 <dolio> Yeah, but people don't write many papers on making lists of fibonacci numbers.
23:45:33 <dolio> There are lots of parsing papers.
23:45:37 <haro> pumpkin interesting !
23:45:52 <mmorrow> dolio: pfft
23:46:24 <edwardk> haro the scary answer? a generalized histomorphism but you probably don't want that ;)
23:46:36 <mmorrow> dolio: i like the monadLib Label thing
23:46:40 <pumpkin> zygohistomorphism!
23:46:41 <pumpkin> ;)
23:46:47 <haro> dolio: maybe there should be more papers on how many non-mathematical realities map on fibs ... :-)
23:46:53 <edwardk> nah, just a generalized one =)
23:47:04 <haro> edwardk: oh, yes i want that too
23:47:08 * pumpkin thanks edwardk for giving him awesome language to scare people with, even if I don't understand it all myself
23:47:15 <edwardk> pumpkin: haha
23:47:42 <haro> edwardk: please elaborate a little on generalized hostomorphisms
23:47:44 * edwardk never should have started combining multiple greek suffixes in category-extras 
23:47:52 <pumpkin> edwardk: I've already scared a few people following me on twitter by mentioning it (meaninglessly) in a tweet
23:48:23 <edwardk> haro: http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Morphism-Histo.html
23:49:01 <pumpkin> haro: beware of the zygohistomorphic prepromorphism, it lives under your bed
23:49:03 <edwardk> haro: er though the generalized histomorphism in that url is somewhat generalized beyond the standard definition of a generalized histomorphism... hrmm. that sounds like a yo dawg.
23:49:49 <edwardk> haro: there should be papers on the topic by varmo vene and possibly tarmo uustalu on the internet
23:49:54 <pumpkin> mmorrow: if I wanted to generate big chunks of repeated haskell definitions with a lot in common, would a TH splice be better, or a syb-based thingy?
23:50:17 <edwardk> a histomorphism has access to the 'path' taken so far. a generalized histomorphism can prune that set.
23:50:28 <edwardk> thats the conceptual tie anyways
23:50:32 <mmorrow> pumpkin: i'm not really a fan of syb other than the occasional use of (\f -> everywhere (mkT f))
23:50:39 <mmorrow> pumpkin: i'd use TH most definitely
23:50:46 <edwardk> haro: but they really are a black hole ;)
23:50:58 <pumpkin> mmorrow: are there any good facilities for building up chunks of code using TH, without writing out the AST by hand?
23:51:06 <haro> edwardk: thanks
23:51:58 <mmorrow> pumpkin: it depends exactly what you're writing. the only reason you have to resort to manually building ast pieces is when TH doesn't support splicing into a certain place (which happens slightly more than you'd like)
23:51:58 <pumpkin> mmorrow: say I wanted to write "instance Moo <x> where foo = f1; bar = f2" and repeat that for x = [t1, t2, t3..tn]
23:52:09 <mmorrow> pumpkin: but it's not that bad really
23:52:18 <mmorrow> oh that's be easy peasy
23:52:24 <pumpkin> mmorrow: how about associated types? :P
23:52:25 <mmorrow> *that'd
23:52:37 <mmorrow> pumpkin: i haven't played with those in TH yet
23:52:46 <mmorrow> (they're new as of like last week)
23:52:52 <haro> edwardk: i think most business systems could be abstracted away a really lot with this kind of techniques
23:52:54 <mmorrow> you'd probably need a ghc HEAD
23:52:56 <pumpkin> ah :/
23:53:35 <pumpkin> so probably several months off before I can assume people have it, and a couple of years before I can break backwards compatibility
23:53:43 <edwardk> haro: sure they could, whether the business could manage to hire anyone who could later understand them is another matter ;)
23:53:55 <mmorrow> pumpkin: so the trick is to first use metabrackets to show you what you need to build by making up a made up expression/decl/whatever
23:54:12 <mmorrow> , [d|instance Moo <x> where foo = f1; bar = f2|]
23:54:13 <lunabot>  luna: parse error on input `where'
23:54:15 <haro> edwardk: people should be more educated in abstraction usage and synthesis , i beleive
23:54:23 <mmorrow> heh
23:54:24 <mmorrow> , [d|instance Moo x where foo = f1; bar = f2|]
23:54:25 <lunabot>  luna: Not in scope: type constructor or class `Moo'
23:54:37 <mmorrow> , [d|instance Monad x where foo = f1; bar = f2|]
23:54:38 <lunabot>  luna: `foo' is not a (visible) method of class `GHC.Base.Monad'
23:54:45 <mmorrow> grr
23:54:46 <pumpkin> lol
23:54:54 <edwardk> haro: i doubt you'll find too many people that disagree with that sentiment in here ;)
23:54:58 <mmorrow> , [d|instance Monad x where return = (); fail = ()|]
23:54:59 <lunabot>  luna: `return' is not a (visible) method of class `GHC.Base.Monad'
23:55:05 <pumpkin> aw
23:55:05 <mmorrow> :o
23:55:12 <mmorrow> oh
23:55:16 <haro> edwardk: true  :)
23:55:18 <pumpkin> it's living elsewhere
23:55:20 <mmorrow> i guess it's actually  typechecking it
23:55:27 <pumpkin> oh?
23:55:28 <mmorrow> , [d|instance Monad x where return = undefined; fail = undefined|]
23:55:29 <lunabot>  luna: `return' is not a (visible) method of class `GHC.Base.Monad'
23:55:30 <edwardk> maybe dons. i'm pretty sure he'd program haskell if it was completely monomorphic as long as he could unbox everything
23:55:32 <mmorrow> wtf
23:56:19 <haro> edwardk: peirce called the abstraction operation abduction
23:56:57 <mmorrow> pumpkin: heh, i guess instance are a pita to make up
23:57:09 <mmorrow> or lunabot's TH instance-ness is bporked
23:57:26 <pumpkin> , [d|instance Functor x where fmap = undefined|]
23:57:27 <lunabot>  luna: `fmap' is not a (visible) method of class `GHC.Base.Functor'
23:57:29 <mmorrow> , [d|data A a = A | B a deriving (Show)|]
23:57:31 <lunabot>  DataD [] A [a_0] [NormalC A [],NormalC B [(NotStrict,VarT a_0)]] [Show]
23:57:49 <mmorrow> , [d|class Moo im a where cow :: really|]
23:57:50 <lunabot>  luna: Too many parameters for class `Moo'
23:58:01 <mmorrow> , [d|class Moo a where cow :: a|]
23:58:02 <lunabot>  ClassD [] Moo [a_0] [] [SigD cow (VarT a_0)]
23:58:42 <pumpkin> :o
23:59:00 <mmorrow> , [d|foreign import ccall unsafe "malloc" malloc :: {-CSize-}Int -> IO ({-Ptr a-})|]
23:59:01 <lunabot>  luna: parse error on input `import'
23:59:25 <mmorrow> hmm, i guess i don't have ForeignFunctionInterface flag on
23:59:45 <pumpkin> , [d|class Moo a where data MooData a; cow :: a|]
23:59:46 <lunabot>  luna: Illegal family instance for `MooData'
23:59:55 <mmorrow> lunabot's on 6.10.0
