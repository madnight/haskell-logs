00:01:02 <hornblower> ivanm: now i'm getting another error...  http://codepad.org/Ihq9RxFG
00:02:00 <pumpkin> hornblower: getLine is messing it up
00:02:15 <pumpkin> getLine >> return ()
00:02:25 <sbahra> pumpkin, maybe (I don't see it being any more clunky).
00:02:33 <pumpkin> I mean
00:02:36 <sbahra> pumpkin, I'm obviously not very familiar with internals of GHC.
00:02:47 <sbahra> I should change that.
00:02:49 <pumpkin> with one primop per SSE instruction, you could still express instruction ordering
00:03:06 <pumpkin> but that would be clunky (is what I meant)
00:03:16 <sbahra> pumpkin, sure, but how do you deal with register allocation?
00:03:33 <pumpkin> ah, true
00:03:49 <hornblower> i replaced getLine with return () but there is still an error:  http://codepad.org/2xfvDXF3
00:04:16 <pumpkin> sequence (map = mapM
00:04:21 <sbahra> Good night
00:04:22 <pumpkin> and you should probably use mapM_ or sequence_ there
00:04:28 <pumpkin> night!
00:07:29 <hornblower> im still getting an error
00:08:26 <hornblower> how do i replace this line?
00:08:34 <ivanm> hornblower: line 17?
00:08:38 <ivanm> oh, there...
00:08:44 <ivanm> hornblower: don't use map in count, use normal map
00:09:16 <ivanm> but replace " sequence (map putStrLn (count ctext l)) " with " mapM_ putStrLn (count ctext l) "
00:09:58 <ivanm> hornblower: and your collect function is a fold by the looks of things
00:10:26 <hornblower> ok i replaced it, its giving this error: http://codepad.org/iZZJW2QY
00:10:48 <ivanm> hornblower: what is collect meant to be doing?
00:11:16 <hornblower> i dont know
00:11:23 <ivanm> heh
00:11:32 <ivanm> hornblower: and don't use mapM_ for count, use normal map
00:12:03 <ivanm> hornblower: so you wrote code and you don't even know what it does or what it's meant to do? :o
00:12:05 <hornblower> ok i switched to normal map and it loaded ok
00:12:10 <hornblower> now i'll try loading moby dick
00:12:13 <pumpkin> unhalp!
00:12:53 <hornblower> rats... still a stack overflow
00:13:32 <ivanm> hornblower: OK, so it looks like collect is meant to be a fold...
00:13:45 <ivanm> what is collect meant to do?
00:13:45 <hornblower> how do i change it to fold?
00:13:58 <ivanm> actually, forget that
00:14:02 <ivanm> what is count meant to do?
00:14:44 <hornblower> count the characters maybe?
00:14:56 <hornblower> moby dick is 1.2 megs
00:15:06 <ivanm> hornblower: ummm.... who wrote that code?
00:15:10 <hornblower> kerlo
00:15:31 <ivanm> so.... I'm helping you debug someone else's code? :s
00:15:37 <ivanm> kerlo: what is count meant to do?
00:15:39 <hornblower> no, its mine now. i am doing a stats project
00:16:05 <ivanm> hornblower: OK, so you want it to count how many times each letter is used?
00:16:20 <ivanm> first of all, I can't use codepad, so let's shift to hpaste
00:16:22 <ivanm> @hpaste
00:16:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:16:27 <hornblower> to show the probability distribution of the English alphabet including the spacebar.
00:16:41 <ivanm> "spacebar"?
00:17:11 <ivanm> OK, first of all, let's make count just do counting
00:17:14 <hornblower> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3610#a3610
00:17:18 <ivanm> oh, and you're using hugs are you?
00:17:32 <hornblower> yes, the spaces only between words.
00:17:44 <hornblower> no, GHC.  hugs couldn't even process moby dick.
00:17:54 <hornblower> oops.. i mean it couldn't process even a small file, like old man and the sea
00:18:15 <ivanm> hornblower: do you actually care about this code? or are you wanting us to write it for you? :p
00:18:55 <hornblower> yes i care.. its very important for a stats project.
00:19:05 <ivanm> but you're meant to be writing this?
00:19:25 <hornblower> i must write it,  in order to compute the frequency of each character.
00:20:10 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3610#a3611 <-- OK, move the prettyfying to the main function
00:20:49 <ivanm> hornblower: do you care about _all_ letters, or just those in the text?
00:21:00 <ivanm> the latter makes it easier...
00:21:48 <hornblower> just those in the text
00:21:55 <ivanm> hornblower: but basically, the main problem with your code is the collect function: you shouldn't use a list for something like this
00:21:56 <hornblower> still a stack overflow with that revision
00:22:10 <ivanm> hornblower: OK, let's do that
00:23:40 <ivanm> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3610#a3612
00:23:46 <ivanm> try that one out
00:23:50 * ivanm -> dinner
00:24:25 <hornblower> that one gave me a parse error
00:24:49 <hornblower> parse error (possibly incorrect indentation)
00:25:04 <glguy> seems like for just counting letter frequency, you'd use accumArray on a UArray and be done with it
00:25:08 <glguy> vroom
00:25:55 <glguy> (or am I interrupting some kind of iterative teaching process?)
00:26:33 <hornblower> Error occurred
00:26:33 <hornblower> ERROR "t.hs" - Can't find imported module "Data.Function"
00:26:44 <hornblower> how do i fix that?
00:26:48 <glguy> upgrade ghc
00:26:54 <hornblower> i have the latest version
00:29:21 <Pellwurst> i am trying to zip a text with line numbers and use: (zip [1..]) . lines "texttext" ... but there seems to be a syntax error? am using the (.) operator the wrong way?
00:30:06 <glguy> use a $
00:30:28 <glguy> with the . you have:  (zip [1..]) . (lines "texttext")
00:30:38 <glguy> . expects two functions
00:30:46 <Pellwurst> oh, ok
00:31:54 <Pellwurst> glguy: the (zip [1..]) . (lines "texttext") doesn't solve the problem though
00:32:16 <glguy> right
00:32:21 <glguy> 00:30 < glguy> use a $
00:32:35 <glguy> I was trying to show you why the . didn't make sense
00:32:44 <Pellwurst> ok :D
00:52:46 <rio> topic
00:52:48 <rio> huch
01:19:46 <jelly12gen> hi i want to filte prime numbers of a list of Int's
01:20:05 <jelly12gen> i have a function with returns true iff the numbers is a prime number
01:20:26 <jelly12gen> but filter (isPrime) [1..10] doesnt work
01:20:32 <PetRat> jelly12gen: have you looked at filter?
01:20:56 <PetRat> :t filter
01:20:57 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:21:05 <PetRat> :t map
01:21:06 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:21:08 <monadic_kid> what's the type of isPrime? you shouldn't need () around it
01:21:37 <jelly12gen> isPrime :: Int -> Bool
01:21:47 <ivanm> monadic_kid: yeah, but it doesn't hurt...
01:21:53 <zeno> cabal: dependencies conflict: ghc-6.10.1 requires Cabal ==1.6.0.1 however
01:21:55 <zeno> Cabal-1.6.0.1 was excluded because of the top level dependency Cabal >=1.6.0.2
01:22:14 <jelly12gen> but using this is get an 99% usage of cpu when i run filter isPrime [1..10]
01:22:18 <ivanm> > filter (even) 1..10
01:22:19 <lambdabot>   <no location info>: parse error on input `..'
01:22:22 <ivanm> > filter (even) [1..10]
01:22:24 <lambdabot>   [2,4,6,8,10]
01:22:32 <ivanm> zeno: what gives you that?
01:22:33 <jelly12gen> lambdabot: i know that
01:22:41 <zeno> ivanm: cabal upgrade
01:22:42 <ivanm> jelly12gen: that was me ;-)
01:22:51 <ivanm> zeno: isn't cabal upgrade disabled?
01:23:06 <boegel> ivanm: heh @ lambdabot confusion :)
01:23:07 <monadic_kid> lambdabot can evalute expressions now? awesome
01:23:10 <jelly12gen> ivanm: i know that , but filter isPrime [1..10] fails  endless while loop :D
01:23:13 <ivanm> jelly12gen: your isPrime function is probably inefficient
01:23:14 <boegel> @vixen I think jelly12gen likes you
01:23:14 <lambdabot> :)
01:23:29 <zeno> ivanm: ah its what ive used, what should i be
01:23:33 <ivanm> monadic_kid: AFAIK, lambdabot has _always_ been able to do that
01:23:58 <jelly12gen> cool
01:24:03 <monadic_kid> anyways is skip/drop eagerly evaluted?
01:24:19 <ivanm> zeno: update cabal-install, cabal upgrade will then print all packages which have new versions, which you then check and manually install ilf they're non-core
01:24:34 <zeno> jelly12gen: http://www.haskell.org/haskellwiki/Prime_numbers
01:24:35 <ivanm> monadic_kid: _nothing_ is by default eagerly evaluated
01:24:40 <ivanm> and I have never heard of "skip"
01:24:43 <ivanm> @hoogle skip
01:24:43 <lambdabot> Text.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
01:24:44 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
01:24:44 <lambdabot> Text.ParserCombinators.Parsec.Prim skipMany :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
01:24:56 <monadic_kid> ivanm: i mean for evalution of a lazy sequence
01:25:09 <ivanm> monadic_kid: what's skip?
01:25:13 <zeno> ivanm: ah ok
01:25:14 <ivanm> and by "sequence", do you mean list?
01:25:53 <monadic_kid> ivanm: it's the same as drop, a list is sequence
01:26:14 <ivanm> well, the main dialects of haskell are lazy
01:26:16 <ivanm> not eager
01:26:21 <ivanm> (though there is eager haskell...)
01:26:29 <monadic_kid> ivanm: yes i know but some functions are more lazy than others
01:27:03 <ivanm> if by "more lazy" you mean that some (e.g. foldl') are at least partially strict... then no, take and drop are fully lazy
01:27:08 <ivanm> > take 10 [1..]
01:27:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:27:22 <yowgi> just curious, does this demonstrate it from drop?:
01:27:22 <yowgi> > head $ drop 1 [1,2,undefined]
01:27:24 <lambdabot>   2
01:27:49 <ivanm> yowgi: I think so...
01:28:02 <ivanm> > drop 1 [undefined, 1]
01:28:03 <yowgi> even better
01:28:04 <lambdabot>   [1]
01:28:04 <yowgi> > head $ drop 1 [undefined,2,undefined]
01:28:05 <lambdabot>   2
01:28:06 <yowgi> hehe
01:28:49 <ivanm> most list functions only (recursively) evaluate to the next required constructor
01:30:53 <monadic_kid> thats what i wanted to know, this is F# really but usiing sequence which are like lazy streams and they have a set of operations like unfold, filter yada, yada but i think some functions traverse the entire sequnce forcing evalution
01:31:38 <monadic_kid> Seq.skip is basically drop on lists
01:38:26 <monadic_kid> god side-effects are butt ugly sometimes
01:48:10 <cantor> may i ask something: i have installed cabal, and want to install a package from hackage with "cabal install [package]" in the terminal, but then i get "-bash: cabal: command not found" ,what does that mean, do i have to get into the cabal directory first? but i have tried that before.
01:48:36 <monadic_kid> cantor: cabal-install is seperate thing you need to install
01:48:55 <cantor> i have installed cabal libary, and cabal-install
01:49:05 <yowgi> is cabal in your PATH?
01:49:16 <cantor> maybe thats the problem
01:49:34 <monadic_kid> cantor: maybe you need to run "cabal update" first
01:49:35 <cantor> yowgi:how can i put it on my PATH?
01:49:46 <yowgi> first, find out where you installed it
01:50:08 <monadic_kid> oh wait  i see now
01:50:09 <yowgi> then open ~/.bashrc and add: export PATH=$PATH:/the/cabal/bin/folder
01:50:26 <yowgi> open a new shell and try with "whereis cabal"
01:50:34 <cantor> exactly export PATH=$PATH:/the/cabal/bin/folder?
01:50:42 <cantor> ok
01:50:58 <yowgi> well, of course replace "/the/cabal/bin/folder"  by whereever you installed it
01:53:47 <alinp> hi
01:54:07 <alinp> can anybody please help me with an explanation why this code doesn't work: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2081#a2081
01:54:08 <alinp> ?
01:54:15 <cantor> yowgi: better i reinstall it, how can i deinstall cabal and cabal-install?
01:54:24 <alinp> if I use Integer -> [Integer], is ok
01:55:08 <yowgi> @type (2^)
01:55:09 <lambdabot> forall t b. (Integral b, Num t) => b -> t
01:55:26 <yowgi> 2^x : x has to be an integral
01:56:09 <alinp> oh
01:56:10 <alinp> I see
01:56:11 <alinp> thanks
01:59:49 <ivanm> http://fpmatters.blogspot.com/2009/04/clean-programming-language-insanely.html <-- how is stuff in Haskell "unproven" technology?
01:59:59 <ivanm> people use it, ergo there is proof that it works *shrug*
02:01:10 <dolio> Four of his six examples aren't language features.
02:01:14 <pipedream> I need to install utf8-string-0.3.4 system wide (for all users) on ubuntu 8.04.2. I have untarred in /usr/local/src, ran runhaskell configure, build, install, and it put some stuff in /usr/local/lib/.
02:01:19 <dolio> And one is trivial sugar for seq.
02:01:21 <pipedream> How do I test if the average user can use this?
02:01:29 <pipedream> (I do not know any haskell)
02:01:44 <pipedream> (and did I miss the pre-packaged utf8-string package for ubuntu? I couldn't find it)
02:02:30 <ivanm> pipedream: to test if i'ts installed system-wide, run "ghc-pkg list" as root and see if it's listed there
02:02:30 <pipedream> How do I for instance, start haskell prompt and import System.IO.UTF8 ? what is an import or load module command?
02:02:42 <mauke> pipedream: ghci
02:02:50 <mauke> pipedream: import System.IO.UTF8
02:02:52 <ivanm> pipedream: for that, run ghci and then to ":m +System.IO.UTF8"
02:02:57 <ivanm> *do
02:02:57 <pipedream> It is listed there
02:02:58 <glguy> :m System.IO.UTF8
02:03:06 <ivanm> pipedream: so it's installed then
02:03:10 <pipedream> Prelude System.IO.UTF8>
02:03:13 <pipedream> that OK?
02:03:15 <mauke> you win!
02:03:16 <ivanm> yup
02:03:16 <pipedream> ok, thanks
02:03:27 <glguy> kind of... a number of the functions in Prelude and System.IO.UTF8 will collide
02:03:35 <ivanm> glguy: eh, I'm used to using + for :m so that I can remove modules to avoid having an extremely long ghci prompt :s
02:03:43 <pipedream> well, the students can get back to me if there are more problems.
02:03:47 * ivanm wished there was an option to only list the last part of the module in the prompt
02:03:52 <mauke> I just use 'import'
02:03:53 <pipedream> thanks, kbye
02:04:08 <glguy> ivanm, that's fine, I don't mind if you do that ;)
02:04:27 <ivanm> heh
02:04:39 <ivanm> mauke: hmmm... didn't know import worked in ghci
02:06:16 <hotaru2k3> what's the point of (^^)?
02:06:23 <ivanm> @hoogle (^^)
02:06:23 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
02:06:35 <glguy> hotaru2k3, support for negative exponents
02:06:42 <glguy> > 2 ^ (-1)
02:06:44 <lambdabot>   * Exception: Negative exponent
02:06:49 <glguy> > 2 ^^ (-1)
02:06:50 <lambdabot>   0.5
02:07:01 <hotaru2k3> > 2 ** (-1)
02:07:02 <lambdabot>   0.5
02:07:13 <glguy> > 2 ^^ (-1) :: Rational
02:07:15 <lambdabot>   1%2
02:07:27 <ivanm> @type (**)
02:07:28 <lambdabot> forall a. (Floating a) => a -> a -> a
02:07:37 <mauke> > (0 :+ 1) ^^ (-1)
02:07:38 <lambdabot>   0.0 :+ (-1.0)
02:07:40 <ivanm> hotaru2k3: (^^) is more efficient for integral powers
02:08:52 <hotaru2k3> whenever i've tried using (^^) (with floats or doubles and integral powers) it's ended up being slower than (**)
02:09:12 <hotaru2k3> i hadn't thought of the Rational thing
02:20:12 <samshel> hey, i am having a little problem with sockets. I have 2 sockets in 2 apps that have to talk to each other. they both start sending some data and then receive some data. Both programs remain stuck in the socket read part of the program. I think it's due to some lazness problems... but how can i force a socket send before a socket read happends?
02:26:54 <samshel> resolved removing buffering
03:00:18 <solidsnack> @undo do { c0 <- getChar ; c1 <- getChar ; print [c0, c1] }
03:00:18 <lambdabot> getChar >>= \ c0 -> getChar >>= \ c1 -> print [c0, c1]
03:01:17 <ivanm> @help undo
03:01:17 <lambdabot> undo <expr>
03:01:17 <lambdabot> Translate do notation to Monad operators.
03:01:21 <ivanm> ahhhh
03:37:33 <CalJohn> "cabal install foo" always fails for me, does anyone know why?  paste:http://haskell.pastebin.com/m11b65f7f
03:39:39 <Saizan__> CalJohn: it stops there?
03:39:54 <ivanm> CalJohn: well, I've never heard of any package called "foo"... ;-)
03:41:34 <dblhelix> ivanm: heh
03:41:45 <Saizan__> CalJohn: it looks like there's something wrong in your system proxy settings
03:42:59 <CalJohn> Saizan__: yes, I suspected that, but $http_proxy is unset
03:43:10 <CalJohn> Saizan__: apt-get works fine, also
03:44:16 <CalJohn> Saizan__: no, it doesn't stop there, that's just the stdout stuff. stderr also prints "ghc-paths-0.1.0.5 failed while downloading the package.
03:44:19 <CalJohn> haddock-2.4.2 depends on ghc-paths-0.1.0.5 which failed to install."
03:48:10 <Saizan__> CalJohn: HTTP_PROXY?
03:49:01 <CalJohn> also unset
03:52:23 <Saizan__> heh, i'm of no help then :\
03:53:08 <Saizan__> if you want investigate yourself the relevant module is Distribution.Client.HttpUtils, which is called from Distribution.Client.Fetch
03:55:47 <CalJohn> I'm not nearly good enough at haskell is investigate myself.  I will just have to download packages by hand
03:57:17 <zeno> cabal install base -> cabal: internal error: impossible (version problem or cabal cannot do period?)
04:03:05 <Saizan__> zeno: compilers don't let you upgrade the base package
04:03:36 <Heffalump> why is it on hackage then?
04:06:47 <ivanm> Heffalump: good question
04:06:53 <ivanm> reference for other compilers?
04:07:12 <ivanm> just a storage place?
04:09:36 <ppavelV6> @hoogle a->(a,a)
04:09:36 <lambdabot> System.Random split :: RandomGen g => g -> (g, g)
04:09:36 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
04:09:36 <lambdabot> Prelude quotRem :: Integral a => a -> a -> (a, a)
04:09:44 <ppavelV6> hmm....
04:09:49 <ppavelV6> :t id &&& id
04:09:50 <lambdabot> forall a. a -> (a, a)
04:10:02 <ppavelV6> :(
04:11:48 <zsol> :t (&&&)
04:11:49 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
04:12:52 <zsol> hm that took a while to decipher
04:14:04 <ppavelV6> nobody defined a function to convert a value to a pair of values? :(
04:14:31 <mauke> :t join (,)
04:14:32 <lambdabot> forall a. a -> (a, a)
04:14:34 <ppavelV6> id &&& id is just too smart i suppose
04:14:49 <ppavelV6> mauke:  Thanks!
04:19:09 <zsol> anyone has any idea about this error while installing ghc binary dist? http://hpaste.org/fastcgi/hpaste.fcgi/new?edit=1&id=3190
04:27:17 <QuietPurple> when you open a .hs file in ghci that says "import SomeModule" at the start, where does ghci look for "SomeModule"?
04:27:53 <b_jonas> QuietPurple: look at the ghc user's guide
04:28:24 <b_jonas> QuietPurple: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#search-path etc
04:28:30 <b_jonas> (it's also downloadable)
04:29:08 <QuietPurple> thanks
04:29:27 <QuietPurple> I was looking but I couldn't find the stuff I wanted
04:30:42 <QuietPurple> an interface file is .hi isn't it? sorry, I've been using haskell for ages, but I haven't really worried about stuff like this before.
04:40:47 <EvilTerran> QuietPurple, http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#output-files says yes
04:42:20 <Baughn_> Are there any interesting instances for Arrow other than the two in Control.Arrow?
04:42:57 <ivanm> @instances Arrow
04:42:58 <lambdabot> (->), Kleisli m
04:43:06 <ivanm> @instances-importing Control.Arrow Arrow
04:43:07 <lambdabot> (->), Kleisli m
04:43:16 <ivanm> not that lambdabot knows about...
04:43:23 <ppavelV6> FRP ?
04:43:43 <int-e> HXT?
04:44:02 <int-e> there must be parsers, too.
04:44:28 <vixey> I don't think Arrow is interesting ..
04:44:37 <Baughn_> Hmm. Yes, hxt has a lot of arrows..
04:44:50 <Baughn_> ...one wonders why. Should probably be split into a new package.
04:45:34 <int-e> arrow is interesting for parsers because you get access to the actual grammar, something that you can't do with monadic parsers.
04:45:58 <Baughn_> How so?
04:46:10 <int-e> which part?
04:46:56 <ppavelV6> vixey: they're just not an answer to every question :)
04:47:16 <Baughn_> int-e: Well, in what sense do you have more access to the grammar with arrows than monads?
04:47:50 <Baughn_> I'm looking at PArrow, and it looks nice enough, but I'm not quite seeing anything that special
04:48:32 <Baughn_> Hm..
04:48:41 <int-e> Baughn_: in that the structure of how grammar symbols are sequenced is fully expressed in terms of various arrow combinators (>>> and some alternative choice), while with a monad you can hide actual logic in the monad actions that you build. (foo >>= if unlikely_condition then something_magical_happens else bar)
04:49:33 <int-e> Baughn_: and that aspect severely limits the kind of optimizations that >>= could do.
04:49:39 <Baughn_> True enough
04:50:23 <Baughn_> That logic is very handy for, for instance, backtracking though
04:51:18 <int-e> Yes, of course. The idea is to give up some expressive power for better performance while parsing. That being said, I don't know of a library that does that, I have never looked for one.
04:51:38 <Baughn_> PArrows?
04:52:15 <int-e> I'll have to look at those.
04:53:09 <Baughn_> s/those/that/. It's a package.
04:54:14 <int-e> Baughn_: at first sight that looks pretty back.
04:54:34 <int-e> Baughn_: yes, I realized it was a package when you said it the second time. 'arrows' is still plural :)
04:55:08 <Baughn_> It could use a tutorial. I can't quite figure out how to match two words. >_<
04:56:12 <int-e> one of two words? MD has an ArrowPlus instance for that.
04:56:24 <Saizan__> the point is that you can't look inside (a -> m b) but you might be able to look inside a :-> b
04:56:46 <int-e> you said that so much simpler than I did. thanks
04:57:47 <Baughn_> int-e: No, not one of two words. Just.. two words.
04:57:50 <Baughn_> Returning both
04:58:22 <Baughn_> Hm, apparently I need the Category instance for that
04:59:02 <Baughn_> ..which still doesn't let me return /both/
04:59:55 <int-e> hmmm, how about &&& ?
05:00:09 <Baughn_> Ah. That works.
05:00:14 <Baughn_> Somewhat inconvenient, but.. works.
05:01:59 <Baughn_> Hmm. Wasn't there some arrow-notation..
05:02:07 <Saizan__> there is
05:02:27 <int-e> http://www.haskell.org/ghc/docs/latest/html/users_guide/arrow-notation.html
05:02:34 <Baughn_> Yep, found it already
05:10:27 --- mode: irc.freenode.net set +o ChanServ
06:04:06 <RickBarnev> ChrisR, ik denk dat dblhelix je wel kan helpen
06:05:11 <ChrisR> dblhelix, ik heb een probleem met het installeren van wxhaskell
06:05:52 <dblhelix> ChrisR: let me guess... you're running Windows? (we speak English here)
06:06:34 <ChrisR> yes vista
06:07:07 <ChrisR> when I try to run the MAIN of a WX file
06:07:13 <ChrisR> it gives an unknown error
06:07:33 <dblhelix> That's not very helpful.
06:07:54 <ChrisR> no indeed
06:08:45 <ChrisR> it says can't load .so/dll for: wxc-msw2.6.4-0.10.3 <addDll Unknown error
06:08:57 <ChrisR> so it does compile the module
06:09:14 <ChrisR> but I can't rus the wx program itself
06:09:43 <dblhelix> so, apparently it dies loading the dynamic library
06:10:34 <dblhelix> and you're absolutely sure that that particular .dll is the right location? wherever that may me... in the system32 folder, I guess? (I'm not a Windows user myself)
06:10:59 <ChrisR> let me take a look
06:11:04 <ChrisR> probably not though
06:11:38 <Baughn_> dblhelix: For program-specific DLLs, they should be next to the executable
06:12:15 <Baughn_> The alternative is the system folder, yes. Or.. arbitrary other places, but that gets annoyingly hard. ;)
06:12:30 <dblhelix> Baughn_: and you'd say that the wx dll is a program-specific library?
06:12:36 <Baughn_> dblhelix: Yes
06:12:52 <Baughn_> The program will have been compiled against a very specific version of wx
06:13:16 <Baughn_> The alternative is to use side-by-side assemblies, which is one of those "annoyingly hard" things
06:13:18 <dblhelix> But clearly multiple programs are to share that single version of wx
06:13:27 <Baughn_> Well, that's with SxS
06:13:35 <dblhelix> ChrisR: http://www.cs.uu.nl/wiki/bin/view/FP/QuestionsAndAnswers
06:13:41 <Baughn_> Or it *should* be by SxS, anyhow
06:13:52 <Baughn_> dblhelix: http://msdn.microsoft.com/en-us/library/aa376307.aspx
06:13:57 <dblhelix> ChrisR: there's some stuff on wx on vista there (mainly that it's a bad idea, but still)
06:14:19 <p_l> dblhelix: For distribution, you can use MSI to make all load paths maintained by system for you
06:14:20 <Baughn_> Honestly, I prefer the unix way of just sticking the version number in the filename. It's ever so much simpler.
06:14:55 <ChrisR> okay, thanks dblhelix
06:15:13 <dblhelix> Baughn_, p_I: I really don't want to look into that.  I don't want to become a Windows expert. So afraid it 'll take room in my brain that I can use for far more useful things. ;-)
06:15:28 <p_l> Baughn_: Microsoft does that on many of their own libs (with SxS added too), but... sue me, but windows (in)fame comes in big part thanks to awful "developers"
06:16:03 <Baughn_> The wx developers ought to know better. :/
06:16:24 <Baughn_> dblhelix: I suppose I can say this much: If the version number is embedded in the filename, then you really might as well just dump it in system32.
06:16:48 <p_l> Baughn_: wx I guess guesses that it's a job for the developer...
06:17:34 <p_l> well, Microsoft plans to eradicate all of that anyway :D
06:17:52 <Baughn_> Oh? What's their new plan?
06:17:53 <Baughn_> Hashes?
06:17:57 <dblhelix> It's a big pain every year getting it installed on students' laptops and such
06:18:51 <RickBarnev> dblhelix, I had no trouble, and I have a laptop with vista
06:28:22 <p_l> Baughn_: removal of native code
06:28:37 <p_l> s/native/unmanaged/
06:32:40 <Baughn_> p_l: I don't see how that stops DLL hell. Managed code also has libraries.
07:03:57 <p_l> Baughn_: they are required to include versioning information
07:04:33 <p_l> and the only real way to stop dll hell is to get rid of dlls...
07:10:20 <mopped> > filter (==True) [True, True, False, True]
07:10:24 <lambdabot>   [True,True,True]
07:11:25 <mopped> Is there anything inherently better/worse between something simple like: f x l = filter (== x) l, and f x l = [ y | y <- l, y == x]?
07:11:38 <Heffalump> the latter desugars into the former
07:11:47 <mopped> ah, ok
07:11:49 <Heffalump> well, something very close to it, if not the same
07:14:06 <jedai> The list comprehension can't be used nicely in a composition of function, using a list comprehension for a simple filter is inelegant in my book
07:14:12 <EvilTerran> mopped, the norm is to go for whichever is clearer in context
07:14:14 <byorgey> > filter id [True, True, False, True]
07:14:15 <lambdabot>   [True,True,True]
07:14:30 <mopped> @src id
07:14:30 <lambdabot> id x = x
07:14:38 <jedai> list comprehension are for more complicated operations IMHO
07:14:41 <byorgey> (==True) is a no-op =)
07:14:50 <mopped> ah, its how filter works inherently :P
07:15:00 <EvilTerran> ?src filter
07:15:00 <lambdabot> filter _ []     = []
07:15:00 <lambdabot> filter p (x:xs)
07:15:00 <lambdabot>     | p x       = x : filter p xs
07:15:00 <lambdabot>     | otherwise = filter p xs
07:15:14 <EvilTerran> @check \x -> (x == True) == x
07:15:16 <lambdabot>   "OK, passed 500 tests."
07:23:25 <vixey> hi
07:23:47 <edwardk> er.. hi =)
07:24:12 <vixey> I'm inventing a fixed point combinator
07:24:49 * edwardk hands vixey a Y combinator.
07:25:01 <vixey> mine it total though :p
07:25:05 <vixey> is*
07:25:23 <edwardk> working in a partiality monad or something?
07:25:37 <vixey> it's the Parser monad
07:26:09 <vixey> Parser s t = [s] -> [(t,[s])]
07:27:02 <edwardk> very -- listy
07:27:29 <vixey> [s] -> {(t,[s])} would be good
07:27:36 <vixey> if {}'s were some kind of bag or set
07:27:40 <edwardk> so erm, where does the totality kick in?
07:28:21 <vixey> well I've got pre and post conditions on it, the combinator requires you have eaten some tokens before you get to loop
07:29:02 <edwardk> ok, i buy it
07:29:34 <vixey> I basically figured out how to do completely formal proof that relates text to abstract syntax
07:29:49 <vixey> it's just so awkward to write this
07:30:10 <edwardk> still in haskell or off in coq somewhere?
07:30:27 <vixey> yeah it's in Coq
07:30:47 <vixey> I'm extracting it to haskell
07:31:01 <edwardk> ah, how well is haskell extraction working for you?
07:31:08 <vixey> it's fine
07:31:24 <edwardk> it usually makes me want to cry because i feel like i can't use any nifty haskell language features so it winds up fairly non-idiomatic
07:32:00 <vixey> I can do fixed grammars at the moment ok, but I want to define a universe of grammars and deal with them all in one go
07:32:17 <vixey> this bit probably wont happen due to being really difficult
07:32:43 <vixey> yeah the most annoying thing for me is unsafeCoerce, you have to be careful to not have these in the output
07:33:42 <rovar> are there any documents on using haskell to produce code in other languages? Like an eDSL whose output is a text file?
07:33:58 <vixey> rovar: that does not even make sense
07:34:08 <edwardk> rovar: well, there are a bunch of pretty printer combinators etc.
07:34:38 <edwardk> rovar: so if you can build an AST internally you can spew it into a nice source file for something else to consume
07:34:39 <Saizan__> e.g. Text.Html does that
07:35:06 <rovar> gotcha.. I'll have a look. Thanks
07:35:41 <edwardk> rovar: http://www.haskell.org/ghc/docs/latest/html/libraries/pretty/Text-PrettyPrint-HughesPJ.html
07:36:10 <vixey> edwardk: I got this idea it might be fun to build a dependently typed language in Ziggeraut
07:36:34 <vixey> edwardk: because you might be able to justify stuff like pattern matching in terms of the lower levels but still give a direct implementation of it
07:36:45 <edwardk> vixey: the lisp optimization tower thing?
07:36:48 <vixey> yeah
07:49:59 <edwardk> maybe if i could get over the fact that it was lisp ;)
07:50:06 * EvilTerran has previously had thoughts of a language explicitly defined in layers
07:50:57 <Heffalump> modular compilers do that kind of thing
07:51:07 <Heffalump> e.g. Intentional Programming (a now defunct MS project)
07:51:25 <Peaker> I think the STEPS project (Alan Kay) also has a language layer thing
07:52:35 <edwardk> one thing i always liked about the ziggurat approach was that it allowed high level overriding of the lower level language optimizations
07:52:59 <edwardk> so while you have the layers, they can interact in non-trivial ways
07:57:45 <dino-> I have a co-worker in disbelief that O'R actually gives away PDF and ePub books without DRM. I'm fairly certain that the files are exactly that, not marked in any way, however..
07:58:07 <dino-> Could someone here who has _Real World Haskell_ in PDF and ePub format generate an md5sum for me?
07:58:38 <vixey> yeah I might give a go
08:00:50 <bremner> dino-: gives away? I thought the free version was html
08:01:11 <dino-> bremner: That's true. But formatted as a decent book
08:01:19 <monochrom> The emphasis is on DRM-free, not price.
08:01:22 <dino-> from O'R. They're quite nice actually, the PDF and ePub formats.
08:01:57 <dino-> $ ls -l RealWorldHaskell.*
08:01:57 <dino-> -rw-r--r-- 1 dino dino 1788752 2008-11-16 12:35 RealWorldHaskell.epub
08:01:57 <dino-> -rw-r--r-- 1 dino dino 5557788 2008-11-19 09:45 RealWorldHaskell.pdf
08:01:57 <dino-> $ md5sum RealWorldHaskell.*
08:01:57 <dino-> 4a66cf7e845a343042dd4657d2f4188b  RealWorldHaskell.epub
08:02:03 <dino-> a97a8d7f1eaa1e24b93a7935d1e6984b  RealWorldHaskell.pdf
08:03:17 <vixey> why would different files have the same md5?
08:03:41 <Botje> evil hackers who want to confuse websites that rely on file  hashing!
08:04:11 <Botje> vixey: the point of DRM is that each file is tagged with a unique number
08:04:25 <Botje> so if two different copies of the file have the same md5sum, they're not tagged
08:04:51 <monochrom> Hypothesis: O'R PDF has DRM iff your hash is different from his hash.
08:05:10 <dino-> There's different 'levels' of this. One could be locking the book down to control how you can use it. This isn't that. But merely tracking people with "watermarking" I find objectionable in general.
08:05:10 <nlogax> can i get the PDF if i have the print version? the last page mentions the safari books thing, but no PDF.
08:05:40 <dino-> nlogax: I paid for both dead-tree and digital form.
08:05:56 <dino-> At once, with a discount on what those would have been individually to buy.
08:06:51 <dino-> Can anybody md5sum these files if they have them?
08:06:51 <nlogax> i see. i bought it from a store in sweden, so no discount for me i guess. :P
08:07:05 <kadaver> anyone like Clean?
08:07:41 <edwardk> kadaver: i like the uniqueness types
08:07:45 <wli> Never had a chance to try it.
08:07:51 <edwardk> kadaver: the rest of the language limitations i could deal without
08:08:32 <wli> I'd probably use it (like everything else) given the opportunity.
08:13:45 <dino-> Nobody here has the eRWH! :o
08:13:59 <edwardk> dino-: fraid not. i have the dead tree version
08:14:31 <dino-> edwardk: Not quite the same thing if we weigh copies of the book. Oh well.
08:14:38 * edwardk just handed it to his wife so she could try to figure out what the hell he is rambling about when he is talking about haskell (and not talking about himself in the third person)
08:17:05 <Peaker> edwardk: compute the md5sum in your head, silly
08:17:39 <dino-> Then we need to burn the book and do a mass spectrometer analysis.
08:17:57 <edwardk> peaker: um, 4, oh wait, no 12.
08:18:37 <edwardk> and i'm pretty sure there was a watermark on page twelve, or wait, maybe that was a coffee stain
08:18:49 <monochrom> There is rumour that if you throw the book into a black hole, the black hole has enough computation power to compute the md5sum of the book...
08:19:38 <dino-> monochrom: hm, that may actually work
08:19:39 <Baughn_> monochrom: It's entirely possible that black holes allow you to do (nearly) infinite computation, so.. yeah
08:20:07 <dino-> edwardk: You heard them. Throw it in the hole. It's for science.
08:20:15 <Baughn_> Possibly even just plain infinite. The idea that space-time is quantized has taken a few body-blows lately.
08:21:34 * edwardk is tempted to make a joke about the Plancks upon which we stand crumbling under the assault
08:21:49 <Baughn_> ..you just did. And I hate you for it.
08:21:52 <edwardk> but i could hardly bring myself to go to such er.. lengths
08:22:01 * Baughn_ groans
08:22:17 <wli> Baughn: How is that? Last I checked loop quantum gravity/cosmology had breakthroughs explaining how the big bang would come about in their theory/system.
08:22:59 <Baughn_> wli: Deep field telemetry. As it turns out, stars that are /really/ far off aren't blurred the way they should be.
08:23:31 <edwardk> what is the fastest way to get windows set up with ghc 6.10.2 and cabal? i installed the 6.10.2 exe and the cabal.exe but cabal can't seem to getHostByName, do i need to set an environment variable to tell it my proxy settings or some such? or am i missing a lib
08:23:39 <Baughn_> wli: This doesn't mean space isn't quantized, but it severely limits the ways in which it can be quantized
08:23:43 <Actium> Baughn_: why should they be blurred?
08:23:55 <Baughn_> Actium: Hm. Perhaps I should say "pixelated"?
08:24:03 <Heffalump> edwardk: it supports the http_proxy env variable
08:24:11 <Heffalump> as well as the standard Windows registry settings for proxies
08:24:22 <Baughn_> Actium: Because all our theories predict the universe has a limited (if rather high) resolution, that should show up in those photos. It doesn't.
08:24:30 <edwardk> Heffalump: hrmm, then it should just be working. will poke at it
08:24:44 <edwardk> i generally don't use ghc/cabal on windows
08:25:09 <Actium> Baughn_: is this possibly related to the 'lightspeed limit'?
08:25:29 <Baughn_> Actium: The what?
08:26:22 <wli> No. Just like energy and mass are discrete, these theories model length, area, and volume as discrete.
08:27:09 <edwardk> euclid would have a fit ;)
08:27:21 <wli> Because they do some optical/etc. artifacts should occur for sufficiently distant objects.
08:27:21 <Baughn_> Yep. And though you /could/ have quantized space and still get unblurry photos from ten billion years off..
08:27:29 <Baughn_> It depends on the exact way in which light propagates
08:28:01 <edwardk> so the er.. resolution to our problem is to just install the hubble webcam.
08:28:04 <edwardk> ;)
08:28:04 <Baughn_> Basically, if the resolution of the universe isn't infinite, you'd expect to get noticable loss of precision after umpteen quazillion one-planck-length propagations of photons
08:28:38 <Actium> i see
08:28:44 <Baughn_> Since we don't.. it /could/ just be propagating in such a way that there's no loss of precision, but it /could/ also be because the precision is infinite to begin with
08:29:01 <Baughn_> And if the precision is infinite, that opens a hole for infinite computations. So guess which one I'm hoping for. ;)
08:29:18 <edwardk> damn the system for using the equivalent of bresenham's algorithm
08:30:12 <Actium> maybe it's a kd-tree
08:30:19 <kar-1> maybe the reality is vector-graphics instead of pixels
08:30:30 <edwardk> actium: nah, collision detection is too good ;)
08:30:41 <Actium> :P
08:30:52 <Baughn_> kar-1: The expected reality is something weirder than either, but resolution's still expected to be finite
08:31:12 <Baughn_> It's not like there are literal boxes in a grid automaton somewhere..
08:31:42 <edwardk> unless you're smoking some of wolfram's crack.
08:32:01 <Baughn_> Anyway, vector graphics still has finite resolution. It's just a lot larger than pixel graphics. Normally.
08:35:03 <wli> I expected quantized space and time.
08:35:48 <kar-1> the problem with pixel array-like structure is, that all directions are not symmetric.. that would mean that physical laws are different in different directions
08:37:35 <Baughn_> kar-1: Yep. Mind you, we haven't ruled this out yet.
08:37:55 <Baughn_> The degree of symmetry breaking implied by grid structures at the planck level is really very tiny
08:38:08 <Actium> a distance field?
08:38:33 <Apocalisp> are you talking about distance as a physical thing?
08:38:36 <wli> kar-1: Solid angle may very well be quantized, too, amounting to a tessellation of space by polygons with large numbers of sides.
08:38:56 <Peaker> #haskell-blah ?
08:39:15 <Apocalisp> Space is not a thing. Space is a relationship between things. #haskell-blah
08:39:46 <Baughn_> #haskell. There's no need to go to blah if nobody's using this channel for haskell right now.
08:39:58 <Heffalump> I think there is, because you'll put people off from doing so
08:40:06 <Heffalump> and distract people like me that switch to the window when there's activity
08:40:15 <Apocalisp> What does <*> multiply?
08:40:17 <Baughn_> Eh, possibly. They're descending into math I can't follow anyway.
08:40:25 <Baughn_> Apocalisp: It.. doesn't?
08:40:32 <Heffalump> Apocalisp: it's the Applicative "apply" operation, isn't it?
08:40:35 <Peaker> @type (<*>)
08:40:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:40:50 <Apocalisp> applicative feels like multiplication
08:41:04 <Peaker> Apocalisp: its not about multiplication, but about: A) sequencing two "effects", B) applying a lifted function to a lifted argument (where "lifted" may also mean "boxed" or "computation result", at your wish)
08:41:07 <Apocalisp> it has that multiplicative texture to it
08:41:38 <jmcarthur> doesn't to me. maybe if the type was of the form (<*>) :: a -> a -> a
08:41:52 <Peaker> Apocalisp: Monads are not required to sequence computations together and combine their results, Applicative can do it..   Monads are only needed if computation results are themselves lifted/monadic and need to be used in the same computation
08:41:56 <Baughn_> <*> is possibly the wrong symbol, but it is what it is
08:42:12 <Baughn_> Peaker: Monads are a subclass of Applicative, though
08:42:14 <Baughn_> Except in haskell
08:42:19 <jmcarthur> i agree that <*> is probably a bad choice
08:42:25 <Peaker> Yeah -- sufficient but not necessary, is what I meant
08:42:59 <Baughn_> Right, but you can do that in any monad, so they all have to support it
08:43:37 <beelsebob> <$> would have been a rather nice choice actually
08:43:43 <beelsebob> shame they made that fmap
08:43:52 <jmcarthur> it makes sense for fmap too though
08:43:55 <beelsebob> actually – $> would be a good choice for fmap
08:44:00 <jmcarthur> ah!
08:44:05 <beelsebob> the > indicating *some lifting happens on this side*
08:44:07 <QuietPurple> Sorry, it's me again. Can I ask a quick question?
08:44:15 <beelsebob> so <$> indicates that lifting has happened on both sides
08:44:18 <Heffalump> just ask (assuming it's Haskell related)
08:44:19 <Baughn_> A symmetric symbol implies a symmetric operation
08:44:25 <beelsebob> while $> indicates on only the argument is lifted
08:44:26 <Baughn_> Neither <$> or <*> are symmetric
08:44:35 <QuietPurple> Is there a god?
08:44:40 <QuietPurple> Sorry just joking
08:44:46 <QuietPurple> I really want to ask:
08:44:48 <beelsebob> Baughn_: I've heard that argument with applicative/commutative in the place of symetric before
08:45:03 <beelsebob> I don't think it really indicates any kind of porperty
08:45:03 <jmcarthur> i think the notion of symmetry needs to be refined for haskell operators
08:45:05 <beelsebob> property*
08:45:06 <Baughn_> beelsebob: So I'm being inexact. So sue me. :P
08:45:11 <skorpan> does the identity monad have any practical value?
08:45:12 <QuietPurple> is there a way to define different instances of Show (Approx a)
08:45:18 <jmcarthur> and then that refined meaning could be applied to new operators
08:45:22 <Baughn_> skorpan: As the base for monad transformers. Yes.
08:45:23 <Heffalump> QuietPurple: of course, SPJ. Clearly a Haskell-related question.
08:45:24 <beelsebob> Baughn_: no, the point really was that it's a non-argument, because no one really knows what symetrical operators mean
08:45:44 * beelsebob quite likes the idea of $> and <$>
08:45:48 <Heffalump> QuietPurple: and no, you can't define different instances of the same class for the same type. You can use newtype to define "copies" of the type though.
08:45:50 <QuietPurple> for (Show a) and (RealFloat a)
08:45:52 <Peaker> skorpan: it allows auto-deriving a monad from its transformer
08:45:53 <jmcarthur> :t ($>)
08:45:54 <lambdabot> Not in scope: `$>'
08:45:59 <facedown> :t 3
08:46:00 <lambdabot> forall t. (Num t) => t
08:46:05 <skorpan> Peaker: so anything other than that?
08:46:07 <beelsebob> would lead to the obvious definition of <$ -- apply functions in boxes to arguments out of boxes
08:46:07 <QuietPurple> so how does that work?
08:46:20 <Baughn_> skorpan: That's sufficient. ;)
08:46:23 <QuietPurple> how can you have two identical types?
08:46:23 <Peaker> skorpan: possibly any function that's written for a monadic computation and you want to use purely?
08:46:33 <Heffalump> QuietPurple: how does what work, newtype?
08:46:37 <jmcarthur> beelsebob, oh that would be nice!
08:46:38 <Heffalump> it makes a wrapper around an existing type.
08:46:39 <Baughn_> skorpan: It means you can define a transformer and its monad without duplicating code
08:47:10 <Peaker> QuietPurple: newtype creates a non-identical type -- it has an identical set of values, but different instances
08:47:24 <QuietPurple> so I say newtype (RealFloat a) RealApprox a
08:47:27 <Peaker> QuietPurple: you can think of a type as a set of values, and a mapping of classes to Maybe instances
08:47:59 <beelsebob> jmcarthur: the rather odd thing about it though is that it suggests that > and < should both be pure
08:48:02 <beelsebob> but postfix and prefix
08:48:03 <Peaker> QuietPurple: newtype SomeNewTypeName type vars here = SomeNewDataConstructor (old-type-here)
08:48:11 <jmcarthur> > let fs <$ x = fs <*> pure x in [(+1), (5-), (*5)] <$ 6
08:48:12 <lambdabot>       Ambiguous occurrence `pure'
08:48:12 <lambdabot>      It could refer to either `Control.Appl...
08:48:26 <jmcarthur> > let fs <$ x = fs <*> Control.Applicative.pure x in [(+1), (5-), (*5)] <$ 6
08:48:27 <lambdabot>   [7,-1,30]
08:48:31 <beelsebob> jmcarthur: shiny
08:48:38 <jmcarthur> @hoogle pure
08:48:39 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
08:48:39 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
08:48:39 <lambdabot> package pureMD5
08:48:44 <jmcarthur> oh arrow, right
08:49:15 <Peaker> 6.10 no longer has pure in Control.Arrow, iirc
08:49:18 <QuietPurple> Peaker, Heffalump: thanks that is very helpful
08:49:30 <jmcarthur> Peaker, yeah, which is why i forgot about it! :P
08:49:32 <QuietPurple> I'm still at a very steep point in the learning curve!
08:49:46 <Peaker> QuietPurple: what have you learned so far?
08:49:55 <vishwesh> Hi, I am using Parsec to parse some data. Now i need to maintain some state information too. I guess I'll be using GenParser tok st tok , setState and putState . Earlier i used parse myparser "(stdin)" input to run the parser. Can someone tell me how will that change? (first time at #haskell)
08:50:13 <QuietPurple> in the last few days I got my head around Monads and Functors
08:50:15 <jmcarthur> :t (<*)
08:50:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
08:50:20 <jmcarthur> :t (*>)
08:50:21 <vixey> vishwesh: but why do you want state?
08:50:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
08:50:58 <QuietPurple> I feel like I have had a haskell coming-of-age!
08:51:20 <jmcarthur> beelsebob, what would those become? they would not parallel with (<$>) in place of (<*>)
08:51:39 <Peaker> QuietPurple: Applicative is a natural extension of Functor, and Monad is a natural extension of Applicative
08:52:09 <Peaker> vishwesh: maybe you can just use StateT?
08:52:11 <vishwesh> i m parsing email headers. if the Content-Type header has a boundary="blah" it indicates the presence of attachments seperated by "blah" otherwise only the body is present
08:52:15 <QuietPurple> Peaker: well that's not quite how I understand them
08:52:15 <edwardk> vishwesh: parsec 3 or the old parsec? now you'll use runParserT instead of parse
08:52:21 <Peaker> QuietPurple: how do you understand them?
08:52:29 <QuietPurple> Peaker: but i'm still filling in my knowledge
08:52:50 <Baughn_> vishwesh: http://www.rfc-editor.org/rfc/rfc822.txt <-- Well, not quite that simple. Here you go.
08:53:01 <QuietPurple> Peaker: a functor is a "automorphism" on the set of haskell types
08:53:10 <edwardk> runParserT :: Stream s m t => ParsecT s u m a -> u -> SourceName -> s -> m (Either ParseError a) -- as opposed to -- parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
08:53:23 <QuietPurple> Peaker: such that fmap behaves nicely
08:53:32 <jmcarthur> beelsebob, oh, i guess just (<<) and (>>) would be okay, but i'm not entirely sure that Control.Applicative.(*>) is the same thing as Control.Monad.(>>)
08:53:36 <edwardk> so you run a given ParsecT with your user state otherwise things look the same
08:53:37 <Peaker> QuietPurple: and what is it you might want to do with a Functor and can't?
08:53:56 <QuietPurple> Peaker: a monad is a special sort of functor with extra nice properties
08:54:00 <edwardk> er
08:54:05 <vishwesh> right now i m referring to http://cr.yp.to/immhf/token.html
08:54:15 <edwardk> actually if you're just using state and not another monad
08:54:18 <edwardk> runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
08:54:20 <Peaker> QuietPurple: yeah, a monad is indeed, but so is Applicative. A monad is also a special sort of Applicative with extra nice properties
08:54:40 <vishwesh> parsec 3.0.0
08:54:41 <edwardk> parse x = runParser x ()
08:54:50 <QuietPurple> Peaker: does Applicative have a CT analog?
08:54:55 <Peaker> jmcarthur: It should be...
08:55:02 <Peaker> QuietPurple: I am not sure, I'm not big on CT :)
08:55:06 <edwardk> quietpurple: strong lax monoidal functor
08:55:13 <jmcarthur> Peaker, i just never bothered to look into that yet
08:55:33 <QuietPurple> edwardk: wooaah... sounds fun...
08:55:40 <vixey> 'does Applicative have a CT analog'
08:55:52 <jmcarthur> @check \xs ys -> (xs *> ys :: [Int]) == xs >> ys
08:55:53 <lambdabot>   Couldn't match expected type `m a' against inferred type `Bool'
08:55:55 <vixey> @src Applicative
08:55:55 <lambdabot> class Functor f => Applicative f where
08:55:55 <lambdabot>     pure  :: a -> f a
08:55:55 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
08:55:57 <Peaker> jmcarthur: (>>) is sequencing while discarding the left-hand value.  Any monadic operation that does not use the result of previous operations (or only applies them as functions) should be analogous to Applicative
08:56:02 <edwardk> strong comes trivially. every functor in haskell is strong. its the 'lax monoidal' part that gives you 'ap'
08:56:34 <jmcarthur> @check \xs ys -> (xs *> ys :: [Int]) == (xs >> ys)
08:56:36 <lambdabot>   "OK, passed 500 tests."
08:56:39 <QuietPurple> edwardk: can you define lax and monoidal?
08:57:13 <jmcarthur> Peaker, that is my intuition as well. i just won't be able to internalize it until i prove it to myself though ;)
08:57:40 <QuietPurple> so is Applicative a Functor together with "return" (or "pure")? but without "bind" or ">>="
08:57:43 <jmcarthur> it seems trivial really. just never thought about it
08:57:52 <Peaker> jmcarthur: I think the proof is simply that Monad should be a subclass of Applicative, so giving Monad and Applicative differing semantics would violate that
08:58:06 <edwardk> http://en.wikipedia.org/wiki/Monoidal_functor is a starting point and includes the lax definition
08:58:08 <jmcarthur> Peaker, well, it would violate a law, surely
08:58:33 <Peaker> QuietPurple: not just together with return and without bind, it also has "ap" or <*>  which allows it to sequence container values together
08:58:47 <edwardk> quicksilver: it has return/pure and <*> :: f (a -> b) -> f a -> f b
08:58:47 <Peaker> QuietPurple: but you don't get to choose which container values to sequence together based on the previous contained results
08:59:08 <edwardk> quicksilver: i've taken to calling functors with just return 'pointed' functors
08:59:21 <vishwesh> yea...i think runParser is what i wanted :)
08:59:36 <edwardk> vishwesh glad to help
08:59:47 <Peaker> QuietPurple: while Monad does allow you to choose whatever container you want
08:59:48 <QuietPurple> <*> is a bit like fmap, but the function itself is monaded... that looks cool
08:59:57 <vishwesh> thanx a lot
09:00:00 <jmcarthur> monaded, heh
09:00:32 <Peaker> QuietPurple: that lets you combine results together in specific ways, and sequence the containers too
09:00:58 <edwardk> QuietPurple: yep. you can define fmap from return and <*>, so every applicative is a functor, but you can't define <*> given just return and fmap
09:01:05 <edwardk> @src liftA
09:01:05 <lambdabot> liftA f a = pure f <*> a
09:01:11 <jmcarthur> > [(+1), (+3), (5*)] <*> [4,5] -- QuietPurple :)
09:01:13 <lambdabot>   [5,6,7,8,20,25]
09:01:25 <edwardk> liftA would be a valid definition for fmap for any Applicative
09:02:19 <jmcarthur> > Just (+1) <*> Nothing
09:02:20 <lambdabot>   Nothing
09:02:24 <Baughn_> QuietPurple: The idea is that applying fmap with a function of multiple arguments gets you a lifted function, so you need <*> to supply the rest of the arguments
09:02:25 <jmcarthur> > Just (+1) <*> Just 2
09:02:27 <lambdabot>   Just 3
09:02:34 <jmcarthur> > Nothing <*> Just 2
09:02:36 <lambdabot>   Nothing
09:02:49 <Baughn_> > (+) <$> Just 2 <*> Just 3
09:02:50 <lambdabot>   Just 5
09:03:09 <jmcarthur> > liftA2 (+) (Just 2) (Just 3)
09:03:09 <lambdabot>   Just 5
09:03:13 <QuietPurple> ok, so what is <$>?
09:03:17 <Baughn_> (+) = fmap
09:03:19 <Baughn_> Er
09:03:21 <Baughn_> <$>
09:03:21 <jmcarthur> (<$>) = fmap
09:03:26 <QuietPurple> ok
09:04:59 <QuietPurple> > liftM2 (+) (Just 2) (Just 3)
09:05:00 <lambdabot>   Just 5
09:05:21 <Baughn_> QuietPurple: Monad is theoretically a subclass of Applicative, so liftM2 = liftA2. In theory.
09:05:26 <jmcarthur> liftM2 = liftA2
09:05:37 <QuietPurple> i see, A means applicative
09:05:43 <Baughn_> We can only hope base-5 makes that a reality too
09:06:37 <QuietPurple> base-5? is that a new language def? when is it belong to us?
09:07:01 <Baughn_> It's the expected version number of whatever ghc version breaks backwards compatibility next
09:07:04 <jmcarthur> base is the core libraries in ghc
09:07:07 <Baughn_> Probably 6.10.2
09:07:14 <Baughn_> Er.. 6.12.1, rather
09:07:15 <jmcarthur> we are on base 4 right
09:07:25 <Baughn_> Yep. 6.8 has base-3, 6.10 has base-4
09:07:45 <jmcarthur> i think you mean 6.12.0
09:07:56 <Baughn_> Seeing as 6.10 /also/ has base-3, it's a nice way to change interfaces without really breaking backwards compatibility. ;)
09:08:07 <Baughn_> jmcarthur: 6.12 series, perhaps. There's never going to be a 6.12.0 release..
09:08:28 <jmcarthur> wasn't there a 6.10 before there was a 6.10.1?
09:09:01 * BMeph_ wants to try out <*> in Quebec, so his functions can be Le-monaded
09:09:02 <Baughn_> QuietPurple: So.. Functor has fmap, Applicative introduces <*> and pure, Monad introduces join and a bunch of convenience functions that can be defined in terms of fmap, <*> and join (such as >>=)
09:09:28 <Baughn_> jmcarthur: Only in darcs, I'm pretty sure
09:09:41 <jmcarthur> huh. maybe my memory is bad
09:09:47 <Baughn_> QuietPurple: And return = pure
09:09:53 <BMeph_> jmcarthur: In HEAD buids, of course. :)
09:10:00 <QuietPurple> Baughn_: Ja, that looks pretty much understandable.
09:10:58 <Baughn_> > pure (2,3) :: Map Int Int
09:10:59 <lambdabot>       Ambiguous occurrence `pure'
09:10:59 <lambdabot>      It could refer to either `Control.Appl...
09:11:22 <Baughn_> Oh.. right, there isn't an applicative instance for map anyway. Yet.
09:11:49 <QuietPurple> here's a question: is (a ->) a monad?
09:12:02 <vixey> QuietPurple: yes it is a Monad
09:12:04 <Baughn_> QuietPurple: Yes, it's the anonymous variant of Reader
09:12:25 <QuietPurple> return x = const x
09:12:34 <vixey> > return 3 4
09:12:35 <lambdabot>   3
09:12:44 <Baughn_> Also, hm, not sure I /can/ define applicative for Data.Map
09:12:52 <vixey> > join (+) 3
09:12:54 <lambdabot>   6
09:13:17 <vixey> > sequence [reverse,tail,return . head] "foobars"
09:13:18 <lambdabot>   ["sraboof","oobars","f"]
09:14:19 <monochrom> (a ->) is a monad and it is declared so in Control.Monad.Instances using ((->) a)
09:14:29 <QuietPurple> cool
09:15:19 <QuietPurple> now... is (-> Bool) a monad?
09:15:42 <BMeph_> QuietPurple: ...
09:15:57 <vixey> type Choose x = x -> Bool
09:16:02 <QuietPurple> yeah
09:16:22 <vixey> fmap :: (a -> b) -> (Choose a -> Choose b)
09:16:38 <vixey> fmap :: (a -> b) -> (a -> 2) -> (b -> 2)
09:16:50 <vixey> ?djinn (a -> b) -> (a -> Bool) -> (b -> Bool)
09:16:50 <lambdabot> f _ _ _ = False
09:17:04 <vixey> I think that djinn is saying, this can't be a monad
09:17:15 <vixey> unless it's just always giving False
09:17:26 <BMeph_> vixey: ^^ ;)
09:18:01 <vixey> ?djinn (b -> a) -> (a -> Bool) -> (b -> Bool)
09:18:01 <lambdabot> f a b c = b (a c)
09:18:08 <vixey> maybe Choose could be a Comonad
09:18:21 <QuietPurple> i think it should be a monad... isn't it basically sets?
09:18:29 <vixey> well it's subsets
09:18:36 <Baughn_> vixey: I think you mixed up a and b, there
09:18:38 <QuietPurple> subsets of the type
09:18:46 <vixey> Baughn_: yeah I did :)
09:18:48 <Baughn_> ?djinn (a -> b) -> (b -> Bool) -> (a -> Bool)
09:18:48 <lambdabot> f a b c = b (a c)
09:18:53 <BMeph_> vixey, edwardk: Isn't 'Choose' the Context comonad?
09:19:59 <dons> ?yow
09:19:59 <lambdabot> I'm encased in the lining of a pure pork sausage!!
09:20:22 <monochrom> a->Bool is basically a set that cannot computability enumerate its elements.
09:20:31 <monochrom> s/computability/computably/
09:21:07 <QuietPurple> return x = (\n -> (n == x)); fmap f g = we need to know the inverse of f ?
09:21:44 <QuietPurple> so is a comonad a monad where fmap goes the other way?
09:22:07 <monochrom> the other monad methods go the other way too.
09:22:17 <QuietPurple> yes, i imagine
09:22:22 <vixey> returnº :: m a -> a
09:22:35 <QuietPurple> whhooaaahh!
09:22:55 <vixey> (>>=)º :: ¿¿ I don't know??
09:23:19 <BMeph_> vixey: You mean (=>>)? ;)
09:23:30 <vixey> joinº :: m a -> m (m a)
09:23:43 <vixey> fmapº :: (a -> b) -> (m b -> m a)
09:23:47 <vixey> is that all right?
09:23:56 <monochrom> Yes.
09:24:15 <monochrom> Perhaps (>>=)º can be figured out from the rest.
09:24:19 <QuietPurple> (>>=)^(little o) :: a -> (m a -> b) -> b      ???
09:25:21 <EvilTerran> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
09:27:51 <BMeph_> I'll look at cet-extras, but I think it's: (=>>) :: (Comonad w) => w a -> (w a -> b) -> w b
09:27:55 <QuietPurple> (=>>) :: Comonad w => w a -> (w a -> b) -> w b
09:28:12 <BMeph_> WOOT!
09:28:17 * BMeph_ high-fixes himself!
09:28:33 <vixey> ?djinn Maybe a -> (Maybe a -> b) -> Maybe b
09:28:34 <lambdabot> f a b =
09:28:34 <lambdabot>     case a of
09:28:34 <lambdabot>     Nothing -> Nothing
09:28:34 <lambdabot>     Just c -> Just (b (Just c))
09:28:39 <QuietPurple> w..w...w......  what?
09:28:47 * monochrom runs (fix BMeph_)
09:28:54 <EvilTerran> BMeph_, high-fix? does that get you the greatest fixed point?
09:28:58 * BMeph_ cringes, puts the scissors down, and low-fiVes himself instead.
09:29:41 <sacko> hi all, i don't suppose any of you know why createProcess isn't in scope, even when i import System.Process please?
09:30:57 <monochrom> @hoogle createProcess
09:30:57 <lambdabot> No results found
09:31:24 <monochrom> There is likely no such thing. System.Process is about runProcess.
09:31:36 <mauke> works here
09:31:39 <sacko> its the same with proc .. http://hackage.haskell.org/packages/archive/process/1.0.1.1/doc/html/System-Process.html#v:proc
09:32:14 <Baughn_> sacko: CreateProcess is a datatype (and constructor), not function..
09:32:21 <mauke> it is a function here
09:32:31 <mauke> createProcess :: CreateProcess -> IO (Maybe Handle, Maybe Handle, Maybe Handle, ProcessHandle)
09:32:34 <Baughn_> Oh, hang on, createProcess..
09:32:37 <mauke> FIRST THING ON THAT PAGE
09:32:45 <sacko> yep thats the one
09:33:05 <sacko> ghc doesn't like it.
09:33:09 <sacko> ghci even
09:33:16 <mauke> which version of process do you have?
09:33:19 <monochrom> createProcess is not in version 1.0.0.0.  http://hackage.haskell.org/packages/archive/process/1.0.0.0/doc/html/System-Process.html
09:33:25 <sacko> erm, how do i find out
09:33:33 <Baughn_> ghc-pkg list
09:33:36 <mauke> ghc-pkg list process
09:34:49 <sacko> 1.0.0.0, need to upgrade it, not sure why i didn't look for that
09:35:14 <sacko> thanks
09:38:03 <Baughn_> sacko: Given that process is a core package, the best way to upgrade it is to upgrade ghc. Though installing your own copy would /work/.. actually, should be pretty safe for process in particular.
09:40:43 <sacko> actually just thinking about it, i may just use the default one. along with runProcess.  all i'm trying to do is to run astyle over a file and direct the output to /dev/null
09:45:14 <edwardk> bmeph: back, hrmm, Choose?
09:46:18 <edwardk> type x = x -> Bool -- is a contravariant functor not a comonad
09:46:35 <edwardk> er type Choose x = x -> Bool
09:47:50 <mauke> so ghc-6.10.2 doesn't build for me: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3626#a3626
09:48:06 <edwardk> bmeph_: so it can't be a comonad, its from Hask^op -> Hask, not Hask -> Hask or equivalently Hask^op -> Hask^op
09:50:24 <edwardk> (>>=)º dualizes a little strange, the reason for the definition in category-extras for extract not lining up is the definition for (>>=) assumes the existence of exponentials in the category
09:51:14 <edwardk> consequently an equivalent definition with the arguments flipped in the order for >>= would want coexponentials at least to allow the easy 'run the arrows backwards' derivation
09:51:31 <edwardk> but switching from (>>=) to (=<<) you can get a nice definition
09:52:22 <dons> edwardk: we need a containers/tries task force :)
09:52:37 <dons> get adrian hey's latest AVL code, and start stress testing it.
09:52:43 <edwardk> i did the derivation of the category-extras comonads in http://comonad.com/haskell/Comonads_1.pdf
09:53:21 <edwardk> dons: k. i made some progress on general purpose packing the other night, but my wife wanted me to spend _some_ time with her ;)
09:53:47 <wli> dons: As Data.Map and/or Data.Set?
09:54:01 <edwardk> wli: i have a Data.Set.Unboxed
09:55:56 <edwardk> dons: what its looking like is we can define a small number of slot types like, Int, Double, and Box, then define embeddings from other types into a type-level known number of slots of each type.
09:56:35 <edwardk> so we'd only have to provide instances for up to a given number of slots, and the tuple 'Packable' instances for tuples would just require the number of slots of each of members of the tuple added together.
09:56:56 <edwardk> this means that the slots in the container go in a known order, and are of a smaller number of types than the number of things you can pack
09:57:41 <edwardk> so we go down to say 3-4 slot types and instead of dealing with 14^5 different containers for n^5 you only have about 235 instances to support all combinations of up to 5 slots
09:58:11 <edwardk> er that was for 5 different slot types, for 3-4 it goes down dramatically
09:59:27 <edwardk> and to support more than 5 slots or 4 or whatever cutoff makes sense, we can just add box slots and use them for overflow of any data type, since the packing overhead seems to stop making sense around 4 entries anyways
10:00:09 <edwardk> so a packed (Int, Int, Int, Int, Int, Int, Double) -- would probably want to start just using boxes for things
10:00:38 <edwardk> this has the benefit that newtype deriving can be used to pack things that are isomorphic to an int or bool or what have you
10:01:50 <amaron> dons: you mentioned yesterday some printable reports generator you made
10:02:19 <edwardk> gah, i hate laying out category theory diagrams in latex =(
10:03:08 <amaron> dons: does it make pdfs as output?
10:14:27 <duckinator> hi
10:16:29 * edwardk is tempted to shout "duck!" but can't decide if it is by way of greeting or warning.
10:18:26 <ErhardtMundt> hello
10:19:18 * b_jonas ducks
10:19:33 <edwardk> =)
10:20:44 <ErhardtMundt> how could i fetch an html page with haskell?
10:20:58 <edwardk> the HTTP package
10:22:59 <dons> ErhardtMundt: the download or download-curl packages
10:23:10 <dons> simple,    s <- openURI "http://haskell.org"
10:23:30 <edwardk> thats a bit simpler =)
10:23:34 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-curl
10:23:40 <dons> Loading a webpage as a ByteString:
10:23:40 <dons> doc  <- openURI "http://haskell.org"
10:23:43 <ErhardtMundt> dons: i only want to put the page into a string
10:23:58 <dons> openURI
10:24:24 <dons> it'll even parse it as xML or HTML for you.
10:24:44 <edwardk> dons: ^-- thoughts on any of the packing stuff above? --^
10:25:03 <dons> sounds good. have to work out what to do for arbitrary boxed values. FunPtr ? StablePtr ?
10:25:15 <edwardk> no, no need
10:25:22 <edwardk> not just int slots
10:25:37 <edwardk> int slot, double slot, and a an actual reference slot
10:25:42 <dons> ah ok.
10:26:07 <Saizan_> what's the flag to get stats about rules fired?
10:26:07 <edwardk> the type of the reference slot is opaque but a phantom type parameter on the whole thing should keep you from unsafecoercing the wrong thing out of it
10:26:17 <dons> Saizan_: -ddump-simpl-stats
10:26:18 <ErhardtMundt> dons: where may i find that module?
10:26:22 <Saizan_> thanks
10:26:24 <dons> ErhardtMundt: see the   link above
10:26:35 <ErhardtMundt> i'm currently using kubuntu 8.10
10:26:45 <ErhardtMundt> any .deb? :)
10:27:46 <edwardk> so if we just have one type that has 2 Ints, 2 Doubles and 1 Box, and you go to encode (Char,Double,Int,Foo a,Bar) where Foo a and Bar are Packable instances that use a Box and Double respectively, then it'll put the slots in canonical order
10:28:32 <dons> ErhardtMundt: prob. not. you should use cabal-install to build the lib.
10:28:43 <dons> edwardk: ok. so it flattens the structure, uvector style.
10:28:46 <edwardk> and (a,b,c,d,e) will get dropped in as Int2Double2Box a c b e d
10:29:24 <edwardk> yeah flatten and reorder so that you only need to consider the unique multiplicities of each slot type rather than the orders and multiplicities
10:29:57 <b_jonas> ErhardtMundt: there's also a haskell wrapper over libcurl
10:30:04 <b_jonas> it's called curl
10:30:10 <ErhardtMundt> oh
10:30:20 <edwardk> and since tuples of Packables are Packable you get encodings for things like ((Int,Int),(Double,Double))
10:30:29 <b_jonas> I'd recommend that over the http package, but I haven't used them yet, only looked at them a bit because I want to use them later.
10:30:43 <Heffalump> what's the point of flattening and reordering?
10:30:45 <b_jonas> If you want something simple you might use the http package as well.
10:30:55 <ErhardtMundt> dons: you mean the package named curl is actually an haskell binding to libcurl?
10:30:59 <b_jonas> The curl one is more customizable, it gives you almost all of libcurl's options,
10:31:04 <b_jonas> ErhardtMundt: yes
10:31:12 <ErhardtMundt> ops b_jonas
10:31:14 <ErhardtMundt> oki :D
10:31:16 <edwardk> i'm trying to figure out if i can also calculate that the packed ordering is the same as the unpacked ordering so you can sort, etc. in packed form
10:31:16 <ErhardtMundt> thanks
10:32:27 <edwardk> Heffalump: well, there are 14 or so primitive unboxable types that we like out of the box. supporting unboxed 5-tuples or so of those would require 14^5 monomorphic data family instances
10:32:38 <Heffalump> oh, right
10:32:42 <edwardk> so doing it directly is out
10:32:43 <Heffalump> this all feels kind of silly
10:32:46 <edwardk> > 14^5
10:32:47 <lambdabot>   537824
10:33:12 <Heffalump> can't you just be polymorphic over sizes?
10:33:16 <edwardk> but if i do some type level swizzling to work out a packing into a known number of slots i can get away with about 100-250 instances
10:34:24 <edwardk> the other thing is the Storable form is a less efficient packing mechanism than I'd like, since I want something that can be efficiently inlined, that and i'd need to add a type level fundep or family that knew the size of the Storables anyways
10:34:30 <dons> its kind of reminiscent of all the data packing support in the PSU Systems Haskell compiler
10:34:34 <dons> but in userland
10:34:37 <ErhardtMundt> b_jonas: i've just installed curl package, but i can't find any Network.Curl.Download module inside ghci
10:34:37 <edwardk> Heffalump: nothing in the unpacker handles polymorphism
10:34:52 <EvilTerran> edwardk, i'm guessing it wouldn't inline properly if it did?
10:35:41 <jedai> ErhardtMundt: Did you restart your ghci ?
10:35:56 <ErhardtMundt> jedai: yes, i did
10:35:59 <edwardk> ideally what i'd like is that the unpacker should be smart enough to unpack through data families it encounters iff the instance of the data family that it sees is not polymorphic in any of the types of its slots.
10:36:05 <dons> does:  ghc-pkg list
10:36:08 <dons> show any curl package?
10:37:16 <edwardk> that would still allow unpacking calculations to terminate, but would allow for a _lot_ of power from a very small number of data families/instances.
10:38:07 <ErhardtMundt> dons: nope
10:40:44 <edwardk> dons: oh yeah, why Integer instances in your Pairs? they don't seem to unbox at all
10:40:53 <dons> ErhardtMundt: then it isn't installed fully.
10:41:02 <dons> edwardk: yeah, mistake i think
10:41:13 <dons> should try to unboxe them as (# tag, Int#, Byte#)
10:41:28 <edwardk> ooh, hrmm
10:41:35 <dons> i wonder if we'd get a faster Integer type if we did that...
10:42:39 <edwardk> then rebox to S# and J# on output using the tag? what is the cost of the ByteArray# if its empty?
10:42:56 <dons> nullPtr ?
10:43:03 <ErhardtMundt> dons: so what you suggest me?
10:43:17 <dons> ErhardtMundt: i think you need to build it properly. runhaskell Setup.lhs install
10:43:38 <edwardk> does the bytearray# fall under GC?
10:43:54 * edwardk hasnt really worked with them
10:44:12 <edwardk> i mean is the array itself collected, not its byte contents
10:45:03 <Baughn_> @index bytearray#
10:45:03 <lambdabot> bzzt
10:45:25 <dons> just the box.
10:45:35 <jauaor> http://pastie.org/443002 , which one of the example, you find the syntax cleaner?
10:45:35 <jauaor> :)
10:45:51 <jauaor> (not a haskell question, but language design related)
10:46:05 <glguy> jauaor, neither! they both reek of ruby
10:46:11 <Baughn_> jauaor: I personally despise "end_foo" statements. Neither? ^_^
10:46:31 <glguy> Factor code is pretty on its own
10:46:42 <Baughn_> jauaor: But I'd have to say the first, seeing as the second one uses non-ascii characters
10:46:49 <jauaor> Baughn_: in the 2 example, forget end_foo , that is just a label, what matters is the '? ¿' and '! ¡' operators
10:47:00 <jauaor> Baughn_: ok, i see
10:47:06 <edwardk> glfuy: i'll pretend i never heard that =)
10:47:33 * jauaor goes to eat and be back to find a proper syntax for this
10:48:05 * glguy doesn't know why one would join ruby and apple script in the race to the bottom
10:48:51 <jauaor> glguy: btw, all you see there, it is quite declarative ... but yeah, it has OOP features
10:48:53 <c_wraith> I didn't know there was down to go after ruby. >_>
10:49:10 <vixey> ruby is popular in japan
10:49:24 <c_wraith> Ruby really strikes me as a brilliant example of why half of its language features are very poor ideas for long-term software maintenance.
10:49:27 <jauaor> vixey: i can assure you, not only there
10:50:00 <jauaor> it isn't such a bad language really, I know worse ones :P
10:50:12 * jauaor off to eat, brb
10:50:13 <c_wraith> Perhaps the core language isn't so bad.  But the libraries are.
10:50:25 <c_wraith> I've never better proof that open classes are a bad idea.
10:50:40 <vixey> if the billion other languages which were exactly the same didn't exist I wouldn't have anything bad to say about ruby (except a few things..)
10:50:44 <edwardk> c_waith: duck punching?
10:50:54 <jmcarthur> i think Io is awesome as a core language, but its libraries are even worse than ruby's
10:51:47 <jedai> Well as a language I far prefer Ruby to PHP
10:52:02 <c_wraith> I have to do a lot of development work in rails.  I'm starting to understand how rails work.  That causes me no end of mental anguish. :)
10:52:18 <c_wraith> *works
10:52:22 <jedai> But then I like both Haskell and Perl so I'm probably a bit weird anyway ^^
10:52:23 <jmcarthur> rails is horrible engineering
10:52:37 <c_wraith> The bit we've moved into Haskell is completely awesome in comparison. :)
10:54:11 <c_wraith> It's true, my view of ruby is colored by rails.  And rails is worse than you think, when you start trying to do things it's not explicitly designed to support.
10:54:50 <jedai> c_wraith: Do you use a framework in Haskell, if so which ?
10:54:55 * Heffalump swears at wxcore for ignoring my choice of prefix
10:55:04 <wli> I wish there were more Haskell spinoffs than there are.
10:55:19 <jmcarthur> what i don't understand about most ruby libraries is why people extend classes so much rather than just providing mixins that can be added by the developer case-by-case
10:56:01 <jedai> [19:54:49] <jedai> c_wraith: Do you use a framework in Haskell, if so which ?
10:56:04 <c_wraith> jedai: We're not.  At the moment, we're only handling two different URLs via the haskell server, and neither is generating html.
10:56:50 <jedai> Ok :)
10:56:54 <glguy> http://paste.factorcode.org/paste?id=567
10:56:59 <glguy> you can already write that in Factor
10:57:05 <glguy> no need to pollute it
11:00:55 <Peaker> jmcarthur: why mixins? Why share the "self" and not pass a value explicitly on which to call the methods?
11:01:15 <Peaker> mixins cause namespace collisions
11:02:19 <jmcarthur> Peaker, i only propose it as a better but close alternative. as for the namespace collisions, if the developer adds the mixins to objects only as needed, these should be very rare
11:02:26 <Nafai> wli: What do you mean by Haskell spinoffs?  Languages modeled after Haskell?
11:02:33 <Nafai> wli: Popular extensions?
11:03:33 <wli> Nafai: Languages modeled after Haskell to some extent. Large-scale sharing of syntax, semantics, and language features between the newly-devised languages and Haskell. etc.
11:03:33 <jmcarthur> i would even more prefer a mechanism like Io's prototypes whereby you can simply add an object as one of the prototypes for another object
11:03:53 <Nafai> wli: It would be interesting to see people experiment with things
11:04:28 <jmcarthur> because then you can also remove it or at least have more control over overloading/namespace problems
11:04:56 <wli> I think the only instances were O'Haskell, Mondrian, and Helium.
11:05:09 <orbitz> is O'Haskell still in development?
11:05:24 <wli> I used the past tense.
11:05:31 <orbitz> ah
11:05:34 <Baughn_> wli: Parallel haskell too, but I think that got folded into GHC wholesale
11:05:38 <orbitz> what about Timber?
11:05:43 <orbitz> i don't know if it's stilla ctive dev
11:05:43 <Heffalump> that is, yes
11:05:51 <Heffalump> Andy Gill and Johan Nordlander are doing stuff, look at their webpages
11:05:53 <Baughn_> wli: pH, that is
11:06:04 <orbitz> Heffalump: wtih timber or o'haskell?
11:06:09 <wli> Timber doesn't ring a bell.
11:06:13 * BMeph_ wonders if Ruby would be as popular in Japan if it hadn't been created in Japan
11:06:43 <seliopou> "I'm Huge in Japan"
11:07:10 <c_wraith> you're tom waits?  No, he was only big in japan
11:07:14 <monochrom> Godzilla is huge in Japan.
11:07:20 <orbitz> wli: http://www.timber-lang.org/haskell.html
11:07:22 <wli> I think Curry may have some large-scale syntax (and possibly more) sharing with Haskell, too.
11:07:32 <Heffalump> orbitz: Timber
11:07:38 <orbitz> Heffalump: cool
11:07:51 <BMeph_> wli: Don't forget Disciple, which I irrationally think will get more love once Lippmeier gets the OpenSPARC project somewhere solid.
11:08:31 <orbitz> Heffalump: is timber an offshootof o'haskell?
11:08:34 <wli> I've never heard of Disciple.
11:08:37 <BMeph_> Also, Omega - type-level functions are fun! ;)
11:08:42 <Heffalump> orbitz: I believe so
11:08:48 <Heffalump> I don'tknow anything more about it really.
11:09:21 <BMeph_> @wiki DDC
11:09:22 <lambdabot> http://www.haskell.org/haskellwiki/DDC
11:09:26 <BMeph_> wli: ^^ :)
11:11:00 <cads> Hello again, I got disconnected. Did anyone reply to my question?
11:13:44 <jberryman> cads: you can check the logs here: http://tunes.org/~nef/logs/haskell/?C=M;O=D
11:13:45 <jmcarthur> huh i never bothered to give disciple a very serious look. now that i'm looking again, this looks really cool
11:15:55 <pejo> orbitz, Nordlander had a big role in the design and implementation of both of them.
11:16:37 <orbitz> pejo: ah ok
11:21:19 --- mode: ChanServ set +o monochrom
11:21:24 --- mode: monochrom set -o monochrom
11:21:32 <monochrom> (Just testing a macro)
11:21:39 <glguy> SHOW OF FORCE!
11:21:59 --- mode: ChanServ set +o mauke
11:21:59 --- mode: mauke set -o mauke
11:22:07 --- mode: ChanServ set +o monochrom
11:22:21 --- mode: ChanServ set -o monochrom
11:22:27 <edwardk> peaker: mixins only provide namespace collisions when the language doesn't provide decent mechanisms for renaming on inheritance
11:22:55 <Peaker> edwardk: what untyped language does?
11:23:12 <Peaker> edwardk: also, why inherit when you can use an ordinary member?
11:23:15 <edwardk> peaker: kata? =)
11:23:31 <edwardk> peaker: wiring
11:23:58 <Peaker> edwardk: you mean saving the "self.blah"?
11:24:15 <edwardk> bbiab
11:27:40 <monochrom> We haven't had many newbies for a while. Does it mean we have conquered the world?
11:28:26 <trofi> [sf] ~:mueval -e '1+1'
11:28:27 <trofi> mueval-core: NotAllowed "Could not find module `Control.Monad.Cont':\n  it was found in multiple packages: monads-fd-0.0.0.1 mtl-1.1.0.2"
11:28:53 <trofi> someone care to add --hide-package to mueval?
11:29:06 <trofi> s/--/-/ :]
11:29:15 <b_jonas> monochrom: I still count as a newbie
11:29:51 <jmcarthur> monochrom, i've seen quite a few newbies in here lately, really
11:30:40 <nvoorhies_> I bet it's because there's more haskell primers that non-threatening
11:30:45 <Actium> monochrom: i am a newbie too
11:30:47 <nvoorhies_> that area
11:31:04 <monochrom> nice
11:31:12 <nvoorhies_> Or at least less threatening than you guys with your claws and sharp teeth.
11:31:18 <monochrom> haha
11:39:42 <BMeph_> monochrom: Aye, I suspect that the newbies come out more when you're not around, Not that I'm saying you have something to do with it, just observing. ;)
11:40:35 <glguy> :t let iterateM_ = fix . (>=>) in iterateM_
11:40:36 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m a) -> a -> m c
11:42:17 <adept> please help me out. There was an oldish article about typesetting alogorithm(s) with examples in haskell or even gopher. Does it ring a bell? I'm googling it, but SNR is rather low ...
11:42:17 <lambdabot> adept: You have 1 new message. '/msg lambdabot @messages' to read it.
11:42:33 <monochrom> BMeph_: I have something to do with it. People know that I say "I love newbies. I eat them for breakfast" once in a while. :)
11:42:45 <ddarius> @google functional latex
11:42:46 <lambdabot> No Result Found.
11:43:00 <wahjava> condom :-)
11:43:36 <ddarius> http://lambda-the-ultimate.org/node/2288
11:44:39 <b_jonas> @type (>=>)
11:44:40 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:45:24 <jmcarthur> hmm, something like this would be neat if it's possible... map :: (Arrow (~>), Traversable t) => (a ~> b) -> (t a ~> t b)
11:46:09 <cads> what the bleep is the ~> operator ?!?!
11:46:33 <adept> ddarius: nice one, thanks! But the one i'm looking for was more generic.
11:46:51 <b_jonas> cads: it's not an operator, it's a lower-case type variable but with infix notation
11:46:54 <mauke> cads: what is the t variable ?!?!
11:47:03 <jmcarthur> cads, it's not a defined one. i intended for that to be polymorphic
11:47:22 <apsod> Hrm, is there a GHC extension which lets me create a type synonym for a function with type constraints?
11:47:25 <b_jonas> cads: as a ghc extension you can use infixes as type variables (and also infixes starting with a colon as type names you define)
11:48:05 <b_jonas> I think we should call them smiley types
11:48:20 <jmcarthur> :->
11:48:39 <jmcarthur> ^-^
11:48:52 <b_jonas> yeah, you're getting the general idea
11:49:25 <BMeph_> monochrom: "I love newbies. But I could never eat a whole one." ;)
11:49:28 <adamvo> Is there some way to prevent an instance such as: instance Show a where show = const ""
11:49:38 <adamvo> from escaping a single module?
11:49:47 <cads> mauke: come to mention it, I don't really know the formal rules for those kinds of types, either... in that case would t be a monad that encapsulates a type a or b?
11:50:00 <mauke> cads: no
11:50:06 <cads> yay.
11:50:08 <mauke> t would be a Traversable
11:50:27 <adamvo> it needs OverlappingInstances,FlexibleInstances which would be best to keep isolated
11:51:17 <b_jonas> adamvo: if you're using OverlappedInstances, then you could define a MyShow type and have an instance MyShow (Show a) => a I think
11:51:21 <b_jonas> but don't trust me, I'm not good in classes
11:54:01 <adamvo> perhaps there is a better solution to defining an action that can take any value, but will use an apropriate Show instance if available
11:54:16 <cads> mauke: I think I can begin to understand that as soon as I know what the type notation Arrow (~>) => (a ~> b) is... could we also say Arrow f => (f a b)?
11:54:28 <mauke> yes!
11:54:45 <cads> hehe, sorry for being completely dense, I think I get it now
11:54:54 <BMeph_> cads: In fact, that's the point. :)
11:55:13 <glguy> :t flip fix 0 $ \ rec i -> print i >> rec (i+10)
11:55:14 <lambdabot> forall b. IO b
11:57:04 <cads> so, ah, jmcarthur's function, map, given an arrow on a and b, returns an arrow on traversible versions of a and b
11:57:25 <monochrom> Arrow generalizes functions, so it is notationally pleasing to generalize from a->b to a~>b
11:58:40 <cads> I don't understand how we can generalize a function in a way that's not equivalent to some more complicated function
11:59:08 <jmcarthur> cads, what do you mean?
11:59:19 <jmcarthur> :t map
11:59:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:59:21 <jmcarthur> :t fmap
11:59:25 <jmcarthur> :t mapM
11:59:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:59:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:59:37 <jmcarthur> :t Data.Traversable.mapM
11:59:38 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
11:59:49 <monochrom> You are correct, everything is a more complicated function.
12:00:21 <monochrom> "non-deterministic function" <= plain function that returns an aggregate
12:01:00 <b_jonas> we use funkshions for everything because they're soft
12:01:04 <b_jonas> no wait those are cushions
12:01:06 <monochrom> "side-effecting function" <= plain function that has implicit parameters and implicit return values such as state, world, files, ...
12:01:17 <b_jonas> I can has funksion
12:02:38 <EvilTerran> cads, the point, i think, is that (a -> b) is wholly abstract, while (a ~> b) can be more concrete
12:02:42 <monochrom> Some people also say: a natural number is some more complicated set.
12:02:47 <EvilTerran> (depending on your choice of (~>))
12:03:47 <cads> haha, the wikipedia arrow article sounds downright mystical
12:04:03 <cads> http://clojurescript.n01se.net/repl/
12:04:05 <cads> err
12:04:10 <cads> http://en.wikipedia.org/wiki/Arrows_in_functional_programming
12:04:23 <monochrom> Yes, every abstraction gets a mystical treatment. Monad has its infamous share in the last ten years.
12:04:43 <Peaker> I see Arrows as a generalization of functions -- though the classes in the stdlib need a reorganization
12:05:10 <cads> "Indeed! All Monads in Haskell are instances of Arrows of a certain kind!! OOOOO!"
12:05:37 <cads> monochrom: when a few axioms and simple examples usually suffice, I think
12:07:32 <monochrom> This is where collective efforts such as wikipedia fails.
12:08:42 <cads> I think wikipedia fails to capture the essence in almost any subject, but I have found their references to be pretty valuable
12:08:59 <b_jonas> I don't want to understand all of the standard typeclasses at once so I just think arrows don't exist.
12:09:12 <Peaker> arrows having "arr" really makes them at least as powerful as functions -- and thus much less useful
12:09:49 <edwardk> yeah, i like Category, and what i can build over it but arr is too powerful and hence too restrictive
12:09:51 <monochrom> An abstraction is bound to be understood by different common people in different ways. (Emphasis: common people.) Everyone thinks his perspective is helpful. (And everyone is wrong on this.) So you open up a web page to invite everyone to contribute, and sure enough you get millions of perspectives but no one understands.
12:10:17 <b_jonas> monochrom: is that like the buritto fallacy?
12:10:21 <monochrom> Recall the tale of a group of blind people exploring a big elephant or even a monad.
12:10:42 <monochrom> "So a monad is like a flap!"  "no no, a monad is like a hose!" ...
12:11:11 <nlogax> :D
12:11:19 <monochrom> @quote interpretation
12:11:19 <lambdabot> No quotes match. My pet ferret can type better than you!
12:11:36 <monochrom> @quote owns
12:11:36 <lambdabot> dolio says: Perhaps he's an epigram guy and frowns on Turing completeness.
12:11:43 <monochrom> eww
12:12:06 <c_wraith> I'm happy with a working understanding of monads.  I can use them to do what I want, even if I don't really understand the category theory behind them
12:12:35 <c_wraith> I even have a sort-of-working understanding of monad transformers. :)
12:12:40 <dmhouse> http://en.wikibooks.org/wiki/Haskell/Category_theory
12:12:41 <dmhouse> :)
12:13:22 <Peaker> monochrom: I explained my view of monads (starting with functors, then applicatives, then monads) as "boxes" that can be sequenced and the values combined to several people, and I think they all got it pretty quickly
12:14:12 <Peaker> fmap -- apply function to content of box.  pure -- put value in box.  <*> -- sequence boxes AND combine values in boxes via application.   join -- unwrap one box
12:15:09 <monochrom> @quote monochrom monad is about
12:15:09 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
12:15:09 <lambdabot> is not fixed.
12:16:21 <Peaker> I think the right way to explain monads is Functor,Applicative,Monad, and not dive directly to the most complicated one
12:16:56 <beelsebob> Peaker: amen!
12:17:13 * jmcarthur agrees
12:17:13 <beelsebob> that's why I wrote this... http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
12:17:27 * Apocalisp me-toos
12:20:25 <cads> It's not that hard!
12:20:37 <beelsebob> nope :)
12:20:51 <cads> But it seems like everyone i mention haskell to has already heard the dread-word "monad" and is already running scared :)
12:21:03 <beelsebob> yep, exactly
12:21:08 <beelsebob> even monads aren't hard
12:21:20 <beelsebob> as long as you build up to the idea through the others
12:22:16 <adamvo> @where monad spaceship
12:22:16 <lambdabot> I know nothing about monad.
12:22:31 <monochrom> perhaps spacesuit
12:22:35 <beelsebob> I should perhaps do a follow up to that article explaining the laws of each class
12:22:45 <beelsebob> and why they matter
12:24:26 <cads> beelsebob: ok well to be fair, I try to reassure those people with "it's just a few axioms over 3 objects, only a little more complicated than groups from abstract algebra"
12:24:32 <cads> and strangely that never helps
12:24:43 <beelsebob> hahaha
12:25:14 <beelsebob> I imagine that would help a small minority of people who all already know haskell
12:25:20 <monochrom> You are a repellant.
12:25:30 <adamvo> at least the word group isn't scary ... yet
12:25:38 <cads> I can see that putting a very big smile on a pure math person's face
12:25:47 <beelsebob> I can too
12:26:16 <beelsebob> I wish I knew more mathamatitians to see what they did when presented with Haskell as a language
12:26:29 <beelsebob> I suspect they'd probably say "wow, this is less powerful than mathematica"
12:26:40 <cads> hah
12:27:43 <cads> if mathematica was typed I'd respect it more
12:27:50 <beelsebob> hehe
12:28:13 <beelsebob> I'm currently trying to teach artists that Points, Normals and Colours are *not* all the same thing
12:28:39 <c_wraith> but they're all 3 numbers!
12:28:44 <c_wraith> They must be the same!
12:28:46 <beelsebob> hehe
12:29:02 <Zao> Except that they canonically have four, three and four components.
12:29:03 <beelsebob> 4 numbers actually, but yeh, same argument
12:29:35 <beelsebob> normals have 4 components too – but I guess if you see them as having 4, then points and normals really are the same things
12:29:55 <beelsebob> (x,y,z,0) <-- vector; (x,y,z,1) <-- point
12:30:27 <cads> what's the fourth component of a point? I might call it "wonderificity". Ah, affine points
12:30:28 <Zao> As normals by definition are vectors, having them in homogenous space is a bit of a waste.
12:30:39 <beelsebob> true
12:31:01 <Zao> cads: It's the magical component that allows for affine transformations.
12:31:26 <beelsebob> (read, it's a cludge that makes maths work out nicely for a limited set of operations)
12:31:38 <Zao> <wx, wy, wz, w> forms a line in homogeneous space which all represents the point <x,y,z>
12:32:05 <bremner> I wouldn't call homogeneous coordinates a kludge. To each their own I guess
12:32:21 <cads> they're an elegant algebra
12:32:25 <beelsebob> yes and no
12:32:32 <beelsebob> they only allow for limited transforms
12:32:39 <beelsebob> and seem rather tacked on to me
12:32:44 <cads> including the perspective projection
12:32:45 <beelsebob> but I don't know it well enough yet
12:32:50 <bremner> and anyway, fixing to 1 isn't the point. Any non-zero is the point.
12:32:59 <beelsebob> true true
12:33:08 <bremner> if  you'll excuse my unintentional pun
12:34:26 <bremner> beelsebob: when you see R^3 as a slice of R^4, then you will be enlightened :-)
12:34:42 <beelsebob> perhaps
12:35:32 <monochrom> The point of being an artist is to have such an associative mind that everything is the same as everything. How would you expect an artist to claim "I heard that abstract music and it inspired me to draw this abstract picture. You look at this picture and you can hear the music playing" otherwise?
12:35:41 <beelsebob> surely though all slices of R^4 at the same time?
12:35:59 <beelsebob> monochrom: haha
12:37:13 <Peaker> art is a scam :-)
12:37:20 <cads> beelsebob:  homogeneous actually afford a very elegant and natural treatment of perspective transforms used in 3d graphics
12:37:28 <Peaker> At least that's what I thought when I visited the Museum of Modern Arts in NYC
12:37:32 <cads> homogeneous coordinates*
12:37:33 <beelsebob> cads: yeh, I know
12:37:44 <beelsebob> but I'm not sure that I'd call them general, nor elegant
12:37:47 <beelsebob> just convenient
12:38:04 <nvoorhies_> 2d graphics as well
12:38:18 * beelsebob never got the difference between those two ;)
12:38:32 <monochrom> I don't think it is a scam. I don't think artists are dishonest. I just think they're a bit crazy.
12:38:39 <wli> Projective coordinates IIRC.
12:38:41 <nvoorhies_> not many people do projective transforms from 2d->1d though
12:38:52 <beelsebob> monochrom: I think the critics are dishonest
12:39:06 <Peaker> monochrom: from Family Guy: Do you know what the difference is between pornography and art?
12:39:16 <monochrom> haha
12:39:24 * beelsebob really wants to know
12:39:28 <Peaker> A government grant
12:39:29 <wli> Peaker: ISTR it has to do with a Mapplethorpe photo.
12:39:37 <monochrom> Oh! Great answer!
12:39:42 <cads> beelsebob: also there is a pretty large area of affine geometry, dealing with geometry in higher dimensional spaces that are divided into (linear, I think) equivalence classes corresponding to points in lower dimensional spaces... projective geometry, I think it's also called
12:40:43 <wli> algebraic geometry deals with projective spaces a lot (or all the intro books on it I've read have chapters on it)
12:41:03 <ehird> In Parsec, how can you say "Backtrack if foo"?
12:41:12 <beelsebob> ehird: try
12:41:20 <mauke> when foo (fail "")
12:41:21 <ehird> beelsebob: where foo is a boolean
12:41:24 <ehird> mauke: thanks
12:42:18 <wli> pzero may be a better option
12:43:00 <cads> beelsebob:  are these mathematica objects?
12:43:00 <monochrom> try (xyz; check for not-foo) <|> (do this when foo is true)
12:43:14 <mib_eo2myz4i> Good day, I have a question about Cabal. Is the is appropriate forum?
12:43:19 <beelsebob> cads: which?
12:43:32 <cads> I'm wondering how (x, y, z, 0) represents a vector
12:43:34 <wli> when foo pzero
12:43:37 <monochrom> That will backtrack to the point of before doing xyz.
12:43:42 <beelsebob> cads: subtract two points and you'll see
12:43:50 <cads> ah
12:44:30 <cads> hah, that's kind of neat
12:44:39 <beelsebob> :)
12:44:57 <monochrom> homogenous coordinates are elegant.
12:45:18 <cads> then, adding points together performs a kind of weighted average
12:45:59 <cads> wait, not really
12:47:04 <cads> (x1,.. 1) + (x2,.. 1) = ((x1+x2),.. 2) => ((x1+x2)/2,.. 1)
12:48:18 <cads> eeh, I need to get back to work
12:48:45 * cads goes back to being a lowly mechanic, heh
12:50:02 <vininim> ``I'm not a lawyer, so I couldn't give you a definitive answer, but in doing so, you would be incorporating part of Clean in your generated binary (statically linked runtime). This might not sit well with LGPL and the Free Software Foundation that may demand that you make your code open-source for doing that.''
12:50:09 <vininim> lolwat
12:55:00 <GomoX> Hey
12:55:06 <mib_eo2myz4i> I have an issue where the cabal install goes to 100% when installing certain packages.
12:55:34 <GomoX> How do I import a module from another directory? I am trying to use HUnit but I keep having to put all the files inside my main source folder (which is kind of messy)
12:55:41 <GomoX> (Using Hugs)
13:17:36 * edwardk looks up and sees the geometry discussion
13:18:51 <edwardk> beelsebob: projective geometry is actually both convenient _and_ elegant ;) you get rid of all of that euclidean 'this or that' crap. ;)
13:19:42 <edwardk> two lines in a plane either meet at a point 'or' are parallel translates to two lines in a plane meet a point. (that point may be a point at infinity) ;)
13:20:14 <edwardk> that elimination of specialness from those points gives you duality and all the other properties that make projective spaces a dream to work in
13:20:52 <deech> Hello, is this the right place to ask about Cabal issues?
13:21:08 <edwardk> deech: yeah
13:21:32 <edwardk> i asked about one a few hours back so i can't very well say no ;)
13:21:51 <deech> Thanks ... I am having an issue where 'cabal install <packagename>' goes to 100%
13:22:03 <edwardk> which package?
13:22:29 <deech> It is doing it on multiple packges.
13:22:33 <deech> I don't see a pattern
13:22:46 * edwardk is debating about saying that if its the spinal-tap package it should go to 110% ;)
13:22:55 <deech> :)
13:22:57 <deech> Nice
13:23:12 <edwardk> hrmm,
13:23:37 <edwardk> dcoutts or one of them would probably be the person to ask
13:24:01 <deech> So it just there at "Resolving Dependencies"
13:24:02 <b_jonas> stupid question, but when ghci prints "*** Exception: ", how do you know if that's an IO exception or a pure exception? or are those the same?
13:24:07 <edwardk> if no one else here speaks up you might try just messaging haskell-cafe, i'm sure there is some specific cabal forum, but that'll get you heard
13:24:30 <deech> I sent a message to Haskell-Cafe already.
13:24:33 <edwardk> deech: i wonder if you somehow got your ghc-pkg list in an invalid state
13:24:58 <GomoX> Hey, how do I import a module from another directory? I am trying to use HUnit but I keep having to put all the files inside my main source folder (which is kind of messy)
13:25:05 <deech> edwardk: I tried to eliminate this as a problem by removing my .cabal directory and reinstalling everything
13:25:17 <edwardk> ouch
13:25:21 <edwardk> platform?
13:25:29 <deech> Ubuntu Hardy
13:25:32 <edwardk> and cabal version?
13:25:54 <deech> cabal-install version 0.5.0
13:25:54 <deech> using version 1.4.0.0 of the Cabal library
13:26:01 <edwardk> ah
13:26:10 <edwardk> that looks old
13:26:19 <deech> Hmmm....You're right
13:26:34 <edwardk> upgrade cabal and you'll probably be fine
13:26:48 <deech> But my ghc-pkg list says:
13:26:51 <deech> /usr/local/lib/ghc-6.10.2/./package.conf:
13:26:51 <deech>     Cabal-1.6.0.3, HUnit-1.2.0.3, QuickCheck-1.2.0.0, array-0.2.0.0,
13:26:51 <deech>     base-3.0.3.1, base-4.1.0.0, bytestring-0.9.1.4, containers-0.2.0.1,
13:26:51 <deech>     directory-1.0.0.3, (dph-base-0.3), (dph-par-0.3),
13:26:51 <deech>     (dph-prim-interface-0.3), (dph-prim-par-0.3), (dph-prim-seq-0.3),
13:26:51 <deech>     (dph-seq-0.3), editline-0.2.1.0, filepath-1.1.0.2, (ghc-6.10.2),
13:26:55 <deech>     ghc-prim-0.1.0.0, haddock-2.4.2, haskell-src-1.0.1.3,
13:26:58 <deech>     haskell98-1.0.1.0, hpc-0.5.0.3, html-1.0.1.2, integer-0.1.0.1,
13:26:59 <deech>     mtl-1.1.0.2, network-2.2.1, old-locale-1.0.0.1, old-time-1.0.0.2,
13:27:01 <deech>     packedstring-0.1.0.1, parallel-1.1.0.1, parsec-2.1.0.1,
13:27:03 <deech>     pretty-1.0.1.0, process-1.0.1.1, random-1.0.0.1,
13:27:05 <edwardk> erm, hpaste =)
13:27:05 <deech>     regex-base-0.72.0.2, regex-compat-0.71.0.1, regex-posix-0.72.0.3,
13:27:07 <deech>     rts-1.0, stm-2.1.1.2, syb-0.1.0.1, template-haskell-2.3.0.1,
13:27:09 <deech>     unix-2.3.2.0, xhtml-3000.2.0.1
13:27:11 <deech> /home/deech/.ghc/i386-linux-6.10.2/package.conf:
13:27:13 <deech>     Cabal-1.6.0.3, HTTP-4000.0.4, X11-1.4.5, X11-xft-0.3,
13:27:15 <deech>     utf8-string-0.3.4, xmonad-0.8.1, xmonad-contrib-0.8.1, zlib-0.5.0.0
13:27:22 <edwardk> @hpaste
13:27:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:27:32 <deech> sorry, I don't normally use irc, please excuse breach of etiquette
13:27:38 <edwardk> no problem
13:28:14 <edwardk> you have a current version of the Cabal library, so it looks just like you have an old cabal-install
13:28:16 <cads> vininim: I think the LGPL allows you to statically link libraries cover by it into commercially licensed products
13:28:25 <edwardk> cads: no it doesnt
13:28:40 <deech> edwardk: I will try to manually update. Thanks a lot!
13:28:40 <edwardk> cads: thats one of my problems with the LGPL by default static linking is verboten
13:28:47 <wahjava> you just have to release LGPL'ed stuff's source code.
13:28:49 <cads> edwardk1: dynamically linked?
13:28:50 <flux> as long as you provide separate objects, so the user can choose to link another version of the library?
13:29:07 <edwardk> cads: some packages allow static linking but they have to put an explicit exception clause in
13:29:15 <wahjava> thats the whole point of lgpl, i think so.
13:29:18 <edwardk> dynamic links work fine and are within the letter ans spirit of the law
13:29:37 <cads> eh, I thought the LGPL was the one that was reasonable...
13:29:54 <edwardk> but you can't even provide both a dynamic and statically linked version of the app, you have to provide _just_ the dynamic version, which is what annoys me
13:29:58 <Peaker> b_jonas: I think *** Exception is printed for both IO exceptions and pure exceptions. Maybe they are even the same in ghc, but I don't think they are the same in Haskell genrally
13:30:15 <Heffalump> Haskell has no concept of exceptions generally
13:30:16 <edwardk> it _is_ reasonable. you can link cant you? =) gpl you can't even do that with closed code if you distribute it ;)
13:30:27 <cads> Quoting wikipedia: "The main difference between the GPL and the LGPL is that the latter can be linked to (in the case of a library, 'used by') a non-(L)GPLed program, which may be free software or proprietary software.[1] This non-(L)GPLed program can then be distributed under any chosen terms if it is not a derivative work. "
13:31:09 <edwardk> linked to but if you read the definition of linked to it rquires that that linking be able to be upgraded to newer versions of the LGPL library which has been legally interpreted to mean dynamic linking only
13:31:24 <b_jonas> Peaker: well, in haskell 89 you can't catch pure exceptions, so they can't be the same there.
13:31:41 <edwardk> haskell 89 == miranda? =)
13:32:04 <Peaker> @type error
13:32:05 <Heffalump> they don't exist at all in the standard..
13:32:06 <lambdabot> forall a. [Char] -> a
13:32:15 <Peaker> Heffalump: "error" isn't in the standard?
13:32:15 <Heffalump> you just have error, which aborts the program
13:32:17 <flux> edwardk, why would it not be ok to provide the statically linked version as long as you provide also the dynamically linked? that allows upgrading the lib?
13:32:21 <pejo> Where on the ghc trac wiki does one start new pages for project planning?
13:32:37 <cads> edwardk practically that means what; that you need to have the lgpled library included as a seperate file of your project, which is loaded at runtime?
13:32:47 <Peaker> Heffalump: ah, and ghc lets you catch error in IO instead of aborting?
13:32:51 <Heffalump> right
13:32:58 <edwardk> flux: i'm not the lawyer, i just recall this has come up on dozens of occasions and perens and company have come down hard against the 'provide two versions' option
13:33:01 <Heffalump> and in GHC there is no real distinction between a pure and an impure exception
13:33:09 <Heffalump> except that only some exceptions can emanate from pure code
13:33:13 <edwardk> cads: yeah as a dll or .so or what have you
13:33:16 <glguy> lgpl is good if you aren't writing in Haskell
13:33:19 <Heffalump> but all exceptions can be caught in IO (and only in IO)
13:33:21 <glguy> and don't care about freedom!
13:33:26 <glguy> :-0
13:33:31 <Peaker> Heffalump: s/impure exception/IO exception?  Because EitherT/etc could be said to be "impure exceptions" similarly to IO exceptions?
13:33:32 <edwardk> glguy: or javascript ;)
13:33:43 <b_jonas> Heffalump: okay, and are H98 IO exceptions that are raised on errors in system calls a type of these?
13:33:47 <Heffalump> Peaker: EitherT etc are very pure.
13:33:58 <b_jonas> I think they are because the docs say type IOError = IOException
13:34:14 <Heffalump> b_jonas: oh, does H98 define those exceptions? If so I sit corrected.
13:34:16 <b_jonas> where IOError is in Prelude and IOException is in Control.Exception.Base
13:34:35 <b_jonas> Heffalump: it defines only IO exceptions which you can't extend at all
13:34:36 <Peaker> @info ST
13:34:37 <lambdabot> ST
13:34:41 <Peaker> @src ST
13:34:42 <lambdabot> newtype ST s a = ST (STRep s a)
13:34:42 <b_jonas> Heffalump: but it does define a special catch for them
13:34:50 <b_jonas> so you can catch a failed file open for example
13:34:51 <Peaker> Heffalump: I'd like it if IO had no exceptions but instead there was EitherT (IO ..) for that.  and some other transformer for refs, etc
13:35:03 <Heffalump> ah, so it does. Sorry.
13:35:13 <b_jonas> okay, thanks
13:35:16 <Heffalump> Peaker: yeah, I think opinion is heading in that direction.
13:36:13 <Peaker> Heffalump: I think Haskell went along with the "seems inconvenient or even impractical at first" a lot, and eventually found solutions that were just as usable/practical, but also had neat properties. Same could be said of disintegrating IO into its components
13:36:27 <cads> hey, what are the differences between haskell and clean?
13:36:47 <glguy> Clean makes you manually thread the world around )
13:36:50 <glguy> :-)
13:36:53 <cads> and what might attract someone to study clean
13:37:04 <edwardk> cads: haskell has a lot more features, clean offers uniqueness types and treats them like its golden hammer ;)
13:37:17 <edwardk> i love uniqueness typing, i just hate the way they use it
13:37:45 <bavardage> can haskell never have uniqueness types?
13:37:54 <edwardk> if they caught up in terms of other language features, i'd use it
13:37:56 <cads> ooo, yeah, uniqueness types look interesting... are they similar to linear types?
13:37:58 <bavardage> (I saw clean on reddit, I didn't really read the article or what uniqueness types were)
13:37:59 <Heffalump> it could, but there's not a huge amount of incentive to implement them
13:38:05 <jmcarthur> random thought: i think a newtype whose sole purpose is to change type parameter ordering is somewhat ugly. for example, it occurred to me today that Kleisli and ReaderT are basically the same thing
13:38:15 <jmcarthur> except for type parameter ordering
13:38:16 <edwardk> bavardage: actually there isn't a problem with it in theory, just that the syntax is already used for other things
13:38:35 <edwardk> cads: yes and no. they have the same spirit, but from a technical perspective they differ a lot
13:39:18 <jmcarthur> is there any theoretical reason why type classes could be defined for alternate parameter orders of the same type?
13:39:22 <jmcarthur> *couldn't
13:39:23 <cads> would you say clean is not yet as polished as haskell, edwardk?
13:39:24 <edwardk> uniqueness is the property that a value hasnt been contracted (shared with anyone) yet, linearity is the property that it will be neither contracted (shared) or weakened (forgotten about and made garbage) in the future
13:39:55 <cads> aha
13:40:54 <cads> as always thanks all for the conversation
13:41:04 <edwardk> jmcarthur: well, there is on a related note, a big chunk of metatheory on why you can't have arbitrary type level functions that can swap argument order, and there is probably a gateway between the two notions of type level application some how
13:41:06 <cads> wish everyone a awesome weekend, as well
13:41:27 <edwardk> cads: clean has a very small dev team and long cycles between releases and hasnt seemed to have done anything for 2 years
13:41:41 <edwardk> cads: i love the idea of the language, but its definitely not as polished
13:41:45 <glguy> so you are saying they aren't at risk for contracting type families?
13:41:50 <glguy> interesting..
13:42:00 <edwardk> glguy: hahahaha
13:42:01 <jmcarthur> edwardk, yeah i can see why there would be problems. i just suspect there is probably a simple way to get around things like eg. ambiguity
13:42:18 <jmcarthur> maybe some some extra rules on when you are allowed to do it
13:42:43 <Saizan_> just flip and composition might still keep unification decidable?
13:42:51 <edwardk> jmcarthur there was a post on limited application of type level functions that satisfied certains rules not compromising the system's integrity
13:43:04 <edwardk> i wish i could remember who wrote it
13:43:11 * glguy wonders how different uniqueness typing is from continuation passing style in practice
13:43:32 <edwardk> glguy: very different beasts
13:43:44 <edwardk> i can see where you're going though
13:43:51 <edwardk> at least with regards to universe uniqueness
13:44:22 <edwardk> but the major application of uniqueness is ensuring that you have the only copy of something so you can mutate it in place. the fact that the universe is one such object is only one edge case
13:44:59 <edwardk> gah, gotta go
13:45:05 <Saizan_> jmcarthur: looks relevant:  http://portal.acm.org/citation.cfm?id=583852.581496
13:45:43 <edwardk> thats the paper
13:46:29 <edwardk> gone
13:47:52 <jmcarthur> Saizan_, thanks
13:58:12 <deech> I had an issue with cabal-install hanging on "Resolving Dependencies" but it turns out that rts package is in an invalid state.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3630#a3630
13:58:41 <deech> I installed libffi5, but this is still happening.
13:58:51 <GomoX> I just can't figure out how to put HUnit in a different folder than my source, can anyone help me?
14:01:06 <BMeph_> edwardk: Have you looked at Disciple any? :)
14:01:30 <bremner> GomoX: I guess not many people use hugs here.  Did you look at the hugs docs?
14:02:33 <BMeph_> edwardk: I'm still wading through the background paper to figure out what all of the symbols mean with respect to all of the different means to signify effects.
14:02:56 <GomoX> bremner: I did, i know I can alter the import path using a command line setting, but I'd like to use plain haskell and indicate that HUnit lives in the "HUnit" directory or somethign
14:03:12 <GomoX> sort of import HUnit/HUnit or something like that
14:03:45 <GomoX> That's why I came in here
14:03:56 <bremner> GomoX: won't that make your code very unportable (also I don't know how to do it :-)
14:04:25 <GomoX> bremner: I don't really know, most every language I have programmed in can do this
14:04:28 <GomoX> :/
14:04:40 <mauke> hugs is not a language
14:04:46 <glguy> ssh, that's a secret
14:04:51 <bremner> GomoX: hard code the paths of libraries into your source code?
14:05:13 <GomoX> Not
14:05:37 <GomoX> Just tell the interpreter/compiler/whatever that the module lives in subfolder called "bla"
14:05:45 <bremner> GomoX: in C, that would be like #include "/opt/foobar/special.h"
14:06:52 <GomoX> No one uses an absolute path when he means "subdirectory named bla"
14:07:17 <GomoX> import bla.mymodule will import mymodule from directory bla in python, for example
14:07:23 <GomoX> There's no haskell equivalent?
14:07:39 <bremner> GomoX: I see. Yes, this is a big security problem in python ;-)
14:07:54 <bremner> GomoX: I don't know, but I think the question is clear now.
14:08:27 <mauke> I think altering the import path is the Right Thing
14:08:33 <mauke> because that's what I'd do in other languages
14:08:44 <GomoX> Ok then I'll just go with that I guess
14:08:45 <GomoX> thanks
14:20:54 <b_jonas> > let { maxMaybe :: (Ord a) => Maybe a -> a -> a; maxMaybe x y = fromJust (max x (Just y)); } in (maxMaybe Nothing 5, maxMaybe (Just 2) 5, maxMaybe (Just 8) 5)
14:20:55 <lambdabot>   (5,5,8)
14:21:06 <b_jonas> @hoogle (Ord a) => Maybe a -> a -> a
14:21:07 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
14:21:07 <lambdabot> Prelude max :: Ord a => a -> a -> a
14:21:07 <lambdabot> Prelude min :: Ord a => a -> a -> a
14:21:42 <b_jonas> @hoogle (a -> a) -> Maybe a -> a -> a
14:21:42 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
14:21:43 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
14:21:43 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
14:22:36 <b_jonas> no, sorry, that's not what I need :(
14:24:00 * Peaker didn't realize 6.10.2 was released while he was skiin
14:24:10 <Peaker> did it fix Reactive's bugs?
14:24:19 <Peaker> (unamb's bugs and thus Reactive's bugs)
14:25:30 <b_jonas> this is supposed to be a simple program but I already included like eight modules
14:25:46 <b_jonas> Control.Monad and stuff
14:26:13 <Gracenotes> hah. that happens a lot.
14:26:19 <Gracenotes> no harm done though
14:26:28 <b_jonas> I haven't yet included Control.Applicative thoguh so it's not so bad
14:26:49 <b_jonas> Gracenotes: except that just because of a convenient function it won't run on ghc 6.8 I think
14:27:15 <Gracenotes> aww. well, you can always define convenient functions inline
14:27:28 <b_jonas> yep
14:27:29 <Peaker> if I install a new ghc -- will cabal install/upgrade   upgrade stuff to use the new compiler?
14:27:58 <Gracenotes> like where x &&& y = ... or <$> or .. what function is this?
14:30:17 <b_jonas> Gracenotes: Control.Exception.catchJust
14:30:50 <Gracenotes> ah
14:32:48 <sm> Peaker: I think not, you'll have to install --reinstall here and there
14:33:01 <sm> but not much
14:33:07 <Peaker> sm: thanks, I think I'll just rm -rf ~/.ghc ~/.cabal then - no big deal to do that
14:33:17 <Peaker> (I'd rather not have 6.10.1 stuff lying around not knowing which is which)
14:33:24 * sm just kept going, it's been fine
14:36:23 <b_jonas> I'm also using ghc extensions, though not the evil ones.
14:36:30 <b_jonas> and I'm getting a type error.
14:37:48 <b_jonas> ah, found the problem
14:38:00 <b_jonas> I like how haskell catches most errors in compile time
14:38:47 <thomastc> it almost makes the phrase "it compiles, ship it!" sensible ;)
14:40:12 <monochrom> Heh
14:40:48 <monochrom> Actually I have mixed feelings about that.
14:41:23 <monochrom> A lot of people say that, and of course I believe it's true for them.
14:41:35 <monochrom> But it isn't quite true for me.
14:42:14 <jmcarthur> if you are using types to verify properties, those are the only properties you don't have to test. there are many properties which are still difficult or impossible to verify with the type system
14:42:29 <monochrom> I think the difference is because common programmers make elementary errors and they get caught by type checking, and I make subtle errors.
14:42:32 <b_jonas> okay, somebody try it now please: http://erxz.com/pb/16962
14:42:45 <b_jonas> it's a module that allows you to add top-level declarations in ghci
14:42:46 <thomastc> hey, I did apply a semicolon-closingbrace postfix operator to my message ;)
14:42:57 <b_jonas> it's still not the final version, but I need testers
14:42:58 <b_jonas> thanks
14:44:02 <jmcarthur> i think people say their programs work the first time they compile just because they are used to far less feedback from other languages' compilers
14:44:45 <thomastc> and then they break on large input because something was not tail recursive :P
14:44:52 <b_jonas> jmcarthur: yup. I'm not saying it works the first time it compiles, but there's still a huge difference.
14:44:59 <thomastc> it is
14:45:12 <b_jonas> anyway, good night now. tell me later whether that module I pasted works for you.
14:45:58 <jmcarthur> tail recursion is not as obviously beneficial in haskell as in strict-by-default languages, to me
14:46:32 <jmcarthur> i mean, it doesn't seem to make a difference whether or not a function is tail recursive. controlling strictness is the important thing
14:48:12 <ddarius> monochrom is above the common programmer
14:48:33 <jmcarthur> if you squint your eyes a bit i think controlling strictness in haskell and controlling tail calls in strict languages can be seen as the same thing
14:48:38 <monochrom> Yes, and I found out the hard way.
14:48:43 <jmcarthur> except one is probably more general
15:07:06 <BMeph_> Ah, the joy of Arrows, to wit: "let (++++) = (++)+++(+)"
15:07:20 <EvilTerran> ?type (++)+++(+)
15:07:21 <lambdabot> forall a b'. (Num b') => Either [a] b' -> Either ([a] -> [a]) (b' -> b')
15:09:35 <BMeph_> It's almost like playing with Brainfuck, only more obscure. ;)
15:12:30 <kadaver> how hard would it be to do a Haskell FFI to Ada?
15:12:37 <EvilTerran> can ada FFI to C?
15:37:26 <alexsuraci> My usage of commaSep seems to be wrong here (it wants something like `identifier`, not `aArg`), anyone know a solution?: http://paste.pocoo.org/show/kMuB2kbeQdjKZmfeG297/
15:41:56 <monochrom> I don't understand the types. If aArg returns String, shouldn't commaSep aArg return [String]?
15:42:24 <alexsuraci> Yeah, that's what I thought, but looking at the documentation it wants something more complex. (This is Parsec 3.0.)
15:42:35 <alexsuraci> http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html#v%3AcommaSep
15:43:18 <monochrom> The more complex things can be simplified since you use Text.Parsec.String. But still it is Blah a -> Blah [a].
15:43:27 <EvilTerran> commaSep :: forall a. ParsecT s u m a -> ParsecT s u m [a]
15:43:58 <EvilTerran> type Parser = Parsec String ()
15:44:10 <EvilTerran> type Parsec s u = ParsecT s u Identity
15:44:19 <Gracenotes> @hoogle (a -> m b) -> m (a -> b)
15:44:19 <lambdabot> Test.QuickCheck promote :: (a -> Gen b) -> Gen (a -> b)
15:44:36 <EvilTerran> so that specialises to commaSep :: forall a. Parser a -> Parser [a]
15:44:39 <Gracenotes> @hoogle a -> (a -> m b) -> m (a -> b)
15:44:40 <lambdabot> No results found
15:44:42 <alexsuraci> Ahh, I get it, still don't know what I'm supposed to change though.
15:44:49 <alexsuraci> I'll paste the output, sec.
15:44:54 <EvilTerran> alexsuraci, no need
15:45:22 <EvilTerran> commaSep's result is a [String]; you've told the compiler that aArgs returns a String
15:45:43 <EvilTerran> (well, Parser [String] and Parser String respectively)
15:45:50 <monochrom> I get a type error too.
15:45:50 <alexsuraci> Oh, duh. /facepalm
15:45:52 <alexsuraci> Thanks.
15:47:25 <bavardage> any ideas as to why my program is dying with ** (test1:20796): CRITICAL **: gtk2hs_store_get_impl: assertion `GTK2HS_IS_STORE(store)' failed
15:47:30 <bavardage> though it compiles properly
15:47:53 <bavardage> I'm trying to wrap a list store in a sortableTreeModel
15:48:30 * BMeph_ is waiting for 'justTypeMe :: forall b u. ParsecT n o o b -> ParseT s t f u'
15:48:45 <alexsuraci> lol
15:49:08 <monochrom> It's available as "justKillMe".
15:50:39 <monochrom> @quote kind
15:50:40 <lambdabot> dcoutts says: jcreigh: you mentioned Haskell, so dons found you. He can smell that kind of thing.
15:50:46 <monochrom> @quote Nothing
15:50:46 <lambdabot> phobes says: Just Nothing :: Maybe Maybe Not
15:50:51 * BMeph_ found it - only, the name is 'lern2Pars'
15:51:24 <alexsuraci> in my defence I was converting it from a recursive method that just returned a string :[
15:52:33 <alexsuraci> defense, rather
15:52:43 <alexsuraci> man I'm drinking the failorade today.
15:53:40 <halberd> defence is the American spelling
15:53:52 <halberd> oh
15:54:02 <halberd> no, defence is the British spelling, defense is the American
15:54:39 <alexsuraci> i usually prefer british spelling, even though I'm american
15:54:52 <alexsuraci> teachers never called me on using "colour"
15:55:09 <halberd> for some reason defence is more natural to me, although I am also American
15:55:13 <halberd> I say color though
15:56:36 <Gracenotes> hm. Any useful things to do with fixIO..?
15:57:24 <vixey> Gracenotes: yeah
15:58:32 <MyCatVerbs> Gracenotes: obvious use for mdo is...
15:58:35 * BMeph_ finds it odd that some spell it 'colour', but say it 'cull-or'... ;)
15:59:05 <MyCatVerbs> BMeph_: you would. Freak. ;)
15:59:42 * BMeph_ wished the metal were spelled and said "aluminium", though. :)
16:00:22 <Gracenotes> okay. So what are these useful things..?
16:01:00 * Gracenotes doesn't see how the IORef semantics make it fix-y at all
16:01:40 <MyCatVerbs> Gracenotes: this is a bad idea for other reasons, but still: mdo { tid1 <- forkIO (do { result <- somethingExpensive1; killThread tid2; writeMVar mv result; }); tid2 <- forkIO (do { result <- somethingExpensive2; killThread tid1; writeMVar mv result; }).
16:02:58 <Gracenotes> MyCatVerbs: right. So a regular do would fail there?
16:03:50 <MyCatVerbs> Gracenotes: yes, because the first thread has a reference to tid2 and the second thread has a reference to tid1.
16:05:27 <Gracenotes> I see. So how does that desugar to mfix?
16:05:38 <Gracenotes> i.e. to fixIO
16:06:48 <Gracenotes> presumably tid1 and tid2 are passed as arguments..
16:07:06 <Gracenotes> and then.. something is done with them? :X
16:10:46 <monochrom> mdo { t1 <- f t2; t2 <- g t1; h } = mfix (\(t1,t2) -> do { t1 <- f t2; t2 <- g t1 }) >>= \(t1,t2) -> h
16:11:02 <monochrom> Not the canonical desugaring but should be equivalent.
16:11:14 <fynn> hey, so I read this blog post: http://fpmatters.blogspot.com/2009/04/clean-programming-language-insanely.html
16:11:18 <monochrom> oops
16:11:26 <monochrom> mdo { t1 <- f t2; t2 <- g t1; h } = mfix (\(t1,t2) -> do { t1 <- f t2; t2 <- g t1; return (t1,t2) }) >>= \(t1,t2) -> h
16:11:43 <fynn> "If your Clean program encounters a runtime error, like off-by-1 access, it will print a message naming the error and quit. This may have been good enough in the 80s, but these days I expect more finesse. Haskell allows you to handle these situations in a customized way."
16:11:52 <fynn> what Haskell feature is he refering to?
16:12:48 * Eridius goes to read that post
16:14:47 <Cale> fynn: I have no idea.
16:15:12 <Cale> fynn: Actually, that's what most Haskell runtime errors amount to as well.
16:15:24 <Cale> fynn: Though, I suppose there's a system of exceptions.
16:15:52 <Cale> Catching exceptions thrown by the evaluation of pure code is a tricky matter though.
16:16:24 <dons> fynn: async exceptions, I imagine.
16:16:50 <dons> which made it into haskell well after clean forked
16:16:59 <dons> (or, did not merge, I should say)
16:17:49 <ulfdoz> Does a thingy like runtime errors really exist in haskell?
16:18:00 <dons> > head []
16:18:01 <lambdabot>   * Exception: Prelude.head: empty list
16:18:07 <dons> yields an exception
16:18:29 <ulfdoz> @src head
16:18:30 <lambdabot> head (x:_) = x
16:18:30 <lambdabot> head []    = undefined
16:18:44 <ulfdoz> @src undefined
16:18:45 <lambdabot> undefined =  error "Prelude.undefined"
16:18:50 <Eridius> I rather like the theoretical approach of imprecise exceptions
16:19:54 <mmorrow> most of Clean's rts is handcoded in x86 asm :)
16:19:59 <ulfdoz> hmkay. it exists.
16:20:37 <dons> mmorrow: srsly?
16:20:47 <dons> that's uber cool + scary
16:20:54 <mmorrow> sorry, not only x86
16:20:55 <mmorrow> yes
16:21:04 <mmorrow> CPP'ed gas
16:21:11 <dons> no wonder they have portability issues.
16:21:14 <mmorrow> http://moonpatio.com/repos/MISC/Clean/RuntimeSystem/
16:21:29 <dons> crikey
16:21:30 <mmorrow> (i have a copy there that sends text/plain)
16:21:58 <mmorrow> heh, crikey is right
16:22:35 <gwern> any tex gurus around? would you mind translating '3x^2 + 14x - 5' into tex for me?
16:22:58 <dons> add a \ in front of ^
16:23:11 <gwern> is that it?
16:23:27 <gwern> dons: this is specifically for a gitit page
16:23:27 <halberd> he's messing with you
16:23:46 <dons> sorry
16:23:51 <gwern> halberd: given all the times I've messed with him, 'sonly fair
16:24:00 <dons> gwern: should be ok as is, not sure what the gitit markdown for tex mode is though
16:24:01 * gwern knows I really should learn tex/latex at some point
16:24:15 <gwern> well, http://johnmacfarlane.net/pandoc/README.html#inline-tex covers blocks of tex
16:24:27 <dev31212> Leksah is pretty cool :)
16:24:33 <gwern> but how to do it inline isn't too clear to me yet. on reflection may make things clearer
16:24:56 <gwern> math, specifically, I mean
16:25:07 <gwern> is there some \math{} that pandoc would see?
16:25:10 <Ninju> trying to use HOpenGL, but it's just showing a white window that doesn't do anything and ends up crashing, anyone know what's wrong?
16:25:24 <Ninju> I'm using Mac OS X, and here's the output when I install HOpenGL:
16:25:25 <Ninju> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3638#a3638
16:25:25 <andun> gwern: $3x^2 + ...$?
16:25:33 <Ninju> can't see any problems :-/
16:26:20 <mmorrow> wow, reading this hand-coded Clean rts asm is actually pretty interesting now that i know more about what it's doing (haven't looked at this in a while)
16:26:42 <gwern> andun: oh, thanks
16:26:49 <gwern> now I see the 'math' section, d'oh
16:28:50 <mmorrow> hehe, all the trig/math.h-ish stuff is hand-coded using MMX registers/instructions
16:28:53 <gwern> > let secondOrder x = 3*x^2 + 1*4x - 5 in secondOrder 1
16:28:54 <mmorrow> http://moonpatio.com/repos/MISC/Clean/RuntimeSystem/areals.s
16:28:54 <lambdabot>       No instance for (Num (t -> t))
16:28:54 <lambdabot>        arising from a use of `secondOrde...
16:29:13 <gwern> > let secondOrder x = 3*x^2 + 14*x - 5 in secondOrder 1
16:29:14 <lambdabot>   12
16:29:22 <dons> mmorrow: ffi it!
16:29:34 <mmorrow> heh, that would be pretty cool
16:29:35 <dons> mmorrow: import Clean.Prelude
16:32:34 <dons> you'll need C wrappers
16:34:06 <mmorrow> dons: i have this code that sbahra wrote using MMX and SSE(2?) code with C wrappers, so i'll check that for an example
16:34:12 <defun> Hey, guys. I am trying to compile a parser that I made. It contains a module called 'abbreviations'. For some reason, GHC refuses to compile this module. Could someone please help? Here is the error and the code: http://pastebin.com/f77a4c9d1
16:34:24 <mmorrow> hmm, actually it's right here: http://moonpatio.com/repos/MISC/sbahra-mmxsse2/
16:34:29 <dons> module names must be capitalized, defun
16:36:04 <defun> dons: it is. The above post is supposed to read 'Abbreviations'. Please the link for the error.
16:36:23 <defun> *please see the link...
16:37:07 <dons> oh, parsec3
16:37:22 <defun> ?
16:38:45 <defun> dons: please elaborate
16:38:46 <edwardk> well, your error mentions Text.Parsec.* which comes from parsec-3, so it sounds like you have that installed and are trying to use the Text.ParserCombinators.* stuff for which there is a thin compatibility wrapper
16:38:54 <Eridius> edwardk: yes, but it should still work
16:39:02 <edwardk> try changing to Text.Parsec, Text.Parsec.Language, etc. and start there
16:39:15 <defun> ok.
16:39:19 <defun> brb
16:39:36 <edwardk> yeah, but it'll give me ground I know ;)
16:40:47 <Eridius> I'm testing in GHCI and i get the same error with Text.Parsec (though it just says Stream instead of Text.Parsec.Prim.Stream)
16:41:23 <Eridius> heck, just noneOf ['a'] errors out
16:42:43 <edwardk> does it work with the type annotation: alphaNumerics :: Stream s m Char => ParsecT s u m [Char] ?
16:42:43 <defun> Now I receive an error for the language module of parsec: http://pastebin.com/f96a789d
16:42:57 <Eridius> I think the problem is the s variable there is too generic
16:43:06 <Eridius> there's an instance (Monad m) => Stream [tok] m tok
16:44:11 <edwardk> try importing it from Text.Parsec.Token
16:44:45 <defun> How do you mean? Isn't that what I am doing?
16:44:51 <edwardk> apparently Text.Parsec.Language doesn't actually export the contents of GenLanguageDef
16:45:00 <edwardk> just the fact that the d'ata type exists
16:45:09 <edwardk> while Text.Parsec.Token provides the full def
16:45:42 <Eridius> I don't see how that's relevant to this error
16:46:02 <defun> But LanguageDefinition.hs imports both Parsec.Token and Parsec.Language...
16:46:07 <edwardk> eridius: the second error he gets is Not in scopes for commentStart, etc.
16:46:14 <edwardk> defun yes but look at its export list
16:46:21 <edwardk> hrmm
16:46:23 <Eridius> oh I didn't read his second link
16:46:30 <Eridius> I see
16:46:33 <edwardk> yeah but you import token qualified
16:46:36 <mmorrow> oops, i meant sse2 regs/instructions (xmm*==sse), (mm==mmx)
16:46:40 <edwardk> T.commentStart
16:46:46 <edwardk> T.commentEnd T.commentLine
16:46:50 <defun> oh, I see...
16:46:53 <defun> d'oh
16:46:54 <benmachine> cabal install lambdabot is failing for me: Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
16:47:05 <edwardk> language apparently used to export token's contents
16:47:06 <benmachine> (also, hello!)
16:47:22 <edwardk> ddarius probably cleaned up the api when he changed namespaces
16:47:27 <benmachine> can anyone tell me why libncurses.so could be short
16:47:58 <benmachine> (I know it's not really a haskell problem but I got it while installing a haskell program so I thought someone in here might be familiar with it)
16:48:29 <pejo> Is your libncurses 0 bytes?
16:48:30 <defun> Now I am getting the abbreviations error again: http://pastebin.com/f35d03d47
16:48:38 <benmachine> pejo: no
16:48:44 <benmachine> hold on I may have been premature in asking
16:48:47 <ErhardtMundt> bye
16:48:47 <edwardk> defun: did you see my above signature?
16:48:48 * benmachine finds a *useful* google result
16:48:55 <defun> one sec.
16:49:19 <Eridius> again, I think the problem is there is no instance for Stream s m Char, but there is one for (Monad m) => Stream [tok] s m tok
16:49:31 <Eridius> so you need to restrict the type of alphaNumerics somehow
16:49:38 <defun> This one, right? (alphaNumerics :: Stream s m Char => ParsecT s u m [Char] ?)
16:49:38 <benmachine> oh, it's a linker script and apparently ghc doesn't support linker scripts
16:49:43 <Eridius> generally, that would be by actually using it somewhere
16:49:45 <benmachine> oh deer
16:49:57 <defun> brb
16:49:59 <edwardk> yeah i plucked it out of my butt but its my first thought
16:50:06 <Eridius> defun: if you actually end up using alphaNumerics by parsing a string, it should work
16:50:06 <mmorrow> benmachine: i just make symlinks when that happens
16:50:57 <defun> GHC is advising that I do this: "(Use -XFlexibleContexts to permit this)"
16:50:59 <defun> how?
16:51:27 <mmorrow> defun: in a {-# LANGUAGE FlexibleContexts #-} or on the commandline
16:51:31 <MyCatVerbs> defun: add -XFlexibleContexts to the line where you invoke ghc, or ghci.
16:51:35 <mmorrow> ghc .. -XFlexibleContexts ..
16:51:41 <mmorrow> or that too
16:51:43 <MyCatVerbs> defun: or as mmorrow says, LANGUAGE pragma at the top of the file.
16:51:47 <mmorrow> ghci> :set -XFlexibleContexts
16:51:54 <pumpkin> mmm
16:51:59 <MyCatVerbs> Putting the LANGUAGE pragma in the file is,  is the better option
16:52:17 <edwardk> Eridius: the existence or non-existence of any instances with the signature shouldn't matter as long as it lines up with the class definition. noneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
16:52:24 <MyCatVerbs> *is, IMHO, the better option.
16:52:45 <Eridius> edwardk: yeah, I'm just guessing wildly given that in ghci, the simple expression noneOf ['a'] gives the same error
16:52:51 <Eridius> even though that's clearly lining up with the definition
16:52:58 <edwardk> he has a list of chars. so thats Stream s m Char => ParsecT s u m Char, then applying many yields. Stream s m Char => ParsecT s u m [Char]
16:54:19 <pumpkin> @seen ozy`
16:54:20 <lambdabot> Last time I saw ozy` was when I left ##logic, #haskell and #haskell-overflow 2m 17d 18h 39m 49s ago, and .
16:54:24 <pumpkin> oh my
16:54:31 <pumpkin> @quote pumpkin
16:54:31 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
16:54:34 <pumpkin> @quote pumpkin
16:54:34 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
16:54:39 <pumpkin> hmm
16:54:47 <poucet> @quote vincenz
16:54:47 <lambdabot> vincenz says: Does a cow have least-fixed-point-nature?
16:54:47 <pumpkin> mystery of the missing ozy`
16:54:52 <poucet> @quote vincenz
16:54:52 <lambdabot> vincenz says: shapr: lambdas are curved like bananas, they return
16:54:54 <mmorrow> pumpkin: oh yeah, you were asking if it's possible to get at the code of the current file with TH?
16:55:00 <pumpkin> yup
16:55:10 <pumpkin> please say yes :P
16:55:13 <mmorrow> pumpkin: you can do this is a (somehwhat indirect way) yes
16:55:18 <defun> Thanks, guys. It works now. I used the ghc command line option. Though, if I wanted to use the pragma, where would I place it in the source file?
16:55:27 <pumpkin> ooh
16:55:28 <mmorrow> , src ''Loc
16:55:30 <\stro> hi
16:55:34 <Eridius> defun: on the very first line
16:55:35 <lunabot>  data Loc = Loc {loc_filename :: String,
16:55:35 <lunabot>                  loc_package :: String,
16:55:35 <lunabot>                  loc_module :: String,
16:55:36 <MyCatVerbs> defun: at the very top of the file, before the "module" line.
16:55:36 <\stro> is there any usable lazy http library?
16:55:42 <defun> thanks.
16:55:51 <mmorrow> you read the current file in, and parse it with haskell-src-exts... ;)
16:55:54 <MyCatVerbs> defun: so it goes, pragmas, module, imports, definitions. ^^
16:56:16 <mmorrow> pumpkin: how useful that is to you, i guess it depends
16:56:25 <Eridius> so the expression (noneOf ['a']) gives an error, but (parse (noneOf ['a']) "" "foobar" works. This lends credence to my theory that the type of noneOf is simply too general to use on its own
16:56:29 <Eridius> but parse restricts it
16:56:49 <EvilTerran> but you wouldn't use it on its own...
16:56:50 <wli> I'm trying to think of how to do some sort of meet-in-the-middle bullcrap wrt. collatz chain maximization.
16:57:02 <pumpkin> mmorrow: but can I replace the AST of the entire file?
16:57:05 <mmorrow> pumpkin: unfortunately you can't change anything about the file though
16:57:09 <pumpkin> fail
16:57:11 <pumpkin> :P
16:57:11 <mmorrow> yeah, that the sucky thing
16:57:24 <pumpkin> we need a more flexible approach to code transformations!
16:57:41 <EvilTerran> Eridius, surely you'll only ever use it within (at some level) something like parse that'll restrict the type?
16:57:46 <Eridius> EvilTerran: exactly. I'm guessing that defun is simply trying to compile before he's written code that actually uses this parser
16:58:18 <mmorrow> pumpkin: yeah, i'm sure these capabilities could be added to TH somehow, i'm just not sure exactly what would need to happen to support that
16:58:28 <pumpkin> ah
16:58:33 <MyCatVerbs> \stro: there is a curl binding on Hackage, but I do not believe that it is lazy.
16:58:50 <mmorrow> like, it would be soooo nice if you could add imports to the current module from TH code
16:59:08 <wli> I should probably try to work through some examples of Chakravarty's translation from typeclasses to modules.
16:59:10 <pumpkin> mmorrow: yeah!
16:59:11 <mmorrow> well, it would be even cooler if you could generate entire modules
16:59:20 <mmorrow> *that* would be a killer app
16:59:24 <pumpkin> yup yup
16:59:26 <pumpkin> let's bug ChilliX
16:59:35 <mmorrow> hehe
16:59:37 <mmorrow> i'm in
16:59:47 <MyCatVerbs> \stro: oh, there is also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/http-monad which is fairly new.
16:59:59 <pumpkin> @tell ChilliX this message is me and mmorrow bugging you
16:59:59 <lambdabot> Consider it noted.
17:00:05 <mmorrow> heh
17:00:09 <\stro> i just discovered the darcs repositories in http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
17:00:44 <gwern> \stro: I think those turned in http4k didn't they?
17:00:51 <gwern> *into
17:00:58 <pumpkin> Axman6: yo yo
17:01:26 <\stro> oh really? is Network.HTTP lazy?
17:01:32 <kadaver> how hard would it be to do a Haskell FFI to Ada?
17:01:39 <kadaver> can Ada ffi to C? dont know...
17:02:05 <mmorrow> kadaver: do you mean ffi to haskell *from* agda (easy)
17:02:18 <mmorrow> the other way you'd probably have to work a few things out
17:02:25 <kadaver> Ada,not agda
17:02:30 <mmorrow> (but agda is written in haskell so it's do-able somehow)
17:02:33 <mmorrow> oh
17:02:36 <mmorrow> i dunno
17:03:34 <wli> Two (or more) GC'ing RTS's coexisting simultaneously sounds hairy at best.
17:03:56 <wli> Not conceptually but in difficulty of implementation.
17:04:38 <alexsuraci> hrm, the IndentParser package seems to be dead or incorrectly documented. even copying the example code (with all the typos fixed) doesn't work, same errors I got when I tried using it.
17:04:50 <alexsuraci> http://hackage.haskell.org/packages/archive/IndentParser/0.2.1/doc/html/Text-ParserCombinators-Parsec-IndentParser-Token.html#v%3Aidentifier
17:08:06 <pumpkin> mmorrow: you a CS grad student?
17:08:14 <dolio> Hai guise! I was checking out Haskell prior to the 1.0 report, and it didn't have I/O. So I went with Clean!
17:09:04 <Actium> lol
17:09:05 <pumpkin> omg dolio turned into a n00b o.O
17:10:21 <MyCatVerbs> When did IO get introduced, anyway?
17:10:48 <dolio> IO the type constructor? Or input/output capabilities?
17:13:03 <b\6> could someone with ghci 6.10.2 please verify that it segfaults when ctrl-cd?
17:13:22 <gwern> I have 6.10.1.20090314
17:13:25 <dolio> Monadic IO got introduced in 1.3, but you could do IO from the beginning.
17:13:28 <gwern> does that count? it doesn't segfault
17:13:38 <monochrom> Andrew Gordon's thesis on monadic I/O dated back to 1994.
17:13:41 <dolio> Via the main :: [Response] -> [Request] model.
17:14:01 <b\6> gwern: ok, not sure. i only have one box with this version. thanks for trying.
17:14:05 <gwern> imagine having to program basically through 'interact'. ouch.
17:14:39 <wli> It could be awkard to do IO to files other than stdin and stdout.
17:16:04 <wli> I regress to progressively stupider and newbier over time.
17:16:06 <dolio> Apparently there was the continuation-based model on top of that, too.
17:16:24 <wli> dolio: That might help.
17:16:33 <dolio> Which probably looks a bit more like monadic IO.
17:18:49 <monochrom> But then during Gordon's thesis time, Haskell did not use monadic I/O yet.
17:20:35 <gwern> this pandoc/tex stuff is very awkward. I can't figure out what's licit and what not
17:20:54 <wli> I'm just going to try to figure out how Chakravarty is translating typeclasses to modules tonight and maybe hope that that eventually helps me figure out how the typechecking and inference is supposed to work.
17:20:57 <gwern> $3+x^2$ is just fine, but $\sqrt{2}$ isn't?
17:21:00 <gwern> what the heck john
17:21:10 <pumpkin> whoa, why not?
17:21:17 <monochrom> Yes, during Gordon's thesis time, Haskell used what dolio said, [Response] -> [Request] (plus the contraint that you must give the nth output before asking for the nth input), and then lots of utility functions that let you write in CPS.
17:21:26 <gwern> pumpkin: heck, I dunno. it just isn't
17:21:50 <gwern> pumpkin: you get '<i>/sqrt</i>{4}' basically
17:22:05 <pumpkin> wow, weird
17:22:14 <wli> It probably doesn't recognize the \sqrt macro.
17:22:15 <benmachine> doesn't sqrt have two parameters or something
17:22:44 <gwern> it does, but \sqrt{4}{2} doesn'
17:22:47 <gwern> t work any better
17:23:12 <gwern> (at least, these example expressions from WP have sqrt written that way)
17:23:21 <adimit> gwern: \sqrt is working with the basic help page (or at least, it's an example there)
17:23:52 <gwern> [Math InlineMath "\\sqrt{4}{2}"]
17:24:16 <gwern> but without the \, you get [Math InlineMath "sqrt{4}{2}"]
17:24:18 <gwern> huh
17:24:40 <adimit> I for one would be happy to get syntax highlighting to work with gitit...
17:24:46 <mmorrow> pumpkin: no, i haven't gone back to school (although i'm starting to think i might want to)
17:24:48 <halberd> you sure you need to escape the backslash
17:24:57 <gwern> adimit: need the right flags
17:25:03 <pumpkin> mmorrow: ah, not sure why I assumed you were a grad student
17:25:06 <gwern> halberd: no, that gives like \\\\ in the output
17:25:16 <halberd> pretty sure \sqrt has 1 argument by the way
17:25:18 <mmorrow> pumpkin: are you getting your master's?
17:25:21 <CalJohn> how do I assign in do notional?  I am trying let x = foo, and getting errors
17:25:39 <mmorrow> pumpkin: or in for the long haul?
17:25:42 <pumpkin> long :)
17:25:43 <adimit> gwern: not if cabal just ignores them and recompiles pandoc without 'em anyway...
17:25:45 <pumpkin> just started
17:25:47 <CalJohn> nevermind that
17:26:04 <mmorrow> pumpkin: nice. so this is your first year?
17:26:11 <pumpkin> yup
17:26:14 <mmorrow> cool
17:26:14 <gwern> adimit: basic help page?
17:26:59 <adimit> gwern: gitit's help page, sorry. So I assume it's supported, but maybe it'll need jsMath.
17:27:00 <gwern> oh
17:27:24 <mmorrow> pumpkin: what is (at least at this point) your intended research area?
17:27:39 <gwern> bleh. I give up. I'll just copy the quadratic formula from the help page
17:27:39 <pumpkin> mmorrow: machine learning, mostly
17:28:02 <pumpkin> mmorrow: although at this point programming language research sounds very attractive, but there's none of that here, so I'm sticking to what I started with :P
17:28:14 <pumpkin> I've also done a fair amount related to security
17:28:58 <gwern> @hoogle sq
17:28:59 <lambdabot> package sqlite
17:28:59 <lambdabot> Prelude sqrt :: Floating a => a -> a
17:28:59 <lambdabot> Text.Parsec.Token squares :: GenTokenParser s u m -> ParsecT s u m a -> ParsecT s u m a
17:29:06 <gwern> > sqrt 16
17:29:07 <lambdabot>   4.0
17:29:24 <adimit> gwern: http://zappa.sfs.uni-tuebingen.de:20501/Help#fnref1 << works here, it's in that table somewhere.
17:29:40 <adimit> but pandoc really just uses an <em> tag...
17:29:44 <pumpkin> mmorrow: if you were to go back to school, would it be in programming languages? did you do CS or math as an undergrad? (or both?)
17:31:12 <adimit> yup. pandoc just puts it in a "math" span and lets jsMath do the rest.
17:31:28 <Gracenotes> > let four _ = 4 in (four() `div` 2, four() * pi)
17:31:29 <lambdabot>   (2,12.566370614359172)
17:31:48 <monochrom> You won't get a monomorphism restriction this way.
17:31:54 <monochrom> In fact...
17:32:04 <monochrom> > let four _ = 4 in (four() `div` 2, four True * pi)
17:32:06 <lambdabot>   (2,12.566370614359172)
17:32:15 <gwern> > let quadraticRoot a b c = ((-b) + sqrt (b^2 - 4*a*c)) / 2*a in quadraticRoot 2 8 9
17:32:17 <lambdabot>   NaN
17:32:24 <mmorrow> pumpkin: ah, i see why the statistics now :)
17:32:31 <pumpkin> :P
17:33:06 <cads> what's it take to formulate another type system and plug it into haskell, or to remove haskell's type system and wrap it up as a module to use optionally in, say, a lisp environment?
17:33:07 <monochrom> ... / (2*a) please
17:33:11 <gwern> adimit: for highlighting, you need to build pandoc with -fhighlighting. kate-highlighting is such a bitch to compile and then link into gitit and pandoc I think it's off by default
17:33:18 <mmorrow> pumpkin: i'm not sure. i did math as an undergrad, but i'm starting to get really interested in programming languages and their implementation
17:33:33 <pumpkin> I'm not surprised
17:33:36 <gwern> cads: a lot of work. typed scheme alone generates tons of papers
17:33:42 <monochrom> Haskell sucks everything into programming language research.
17:33:43 <ddarius> mmorrow: Turn away from that dark path.
17:33:51 <pumpkin> I really wish I'd had more exposure to programming languages as an area of research
17:33:52 <monochrom> oops, s/thing/one/
17:33:53 <mmorrow> ddarius: heh, which one is the dark path?
17:33:55 <gwern> > let quadratic-Root a b c = ((-b) + sqrt (b^2 - 4*a*c)) / 2*a in quadratic-Root 2 8 9
17:33:56 <lambdabot>   Not in scope: data constructor `Root'Not in scope: `quadratic'Not in scope:...
17:33:57 <pumpkin> I just took them for granted
17:34:06 <cads> so not exactly a single person endeavor, gwern?
17:34:08 <gwern> oh right we can't use hyphens in function names :(
17:34:12 <gwern> cads: no, not really
17:34:24 <adimit> gwern: yup, I'm doing that. compiles pandoc just fine, works like a charm. Then, when I compile gitit, it ignores any flag, recompiles pandoc *without* highlighting support and links to and installs the new version.
17:34:26 <monochrom> quadratic'root
17:34:27 <mmorrow> pumpkin: yeah, i didn't really know much about the functional programming side of things until i started learning haskell
17:34:38 <gwern> cads: you'd be better off working on gradual typing stuff, imo, if you're interested in hot research
17:34:45 <wli> let quadraticRoot a b c | a /= 0 = let d = b*b - 4*a*c in Just $ Right ((negate b - sqrt d) / (2*a), (negate b + sqrt d) / (2*a)) | b /= 0 = Right $ Left (negate c / b) | otherwise = Nothing ?
17:34:46 <gwern> monochrom: that's so terrible!
17:34:58 <monochrom> haha Oleg does it, therefore it must be good
17:35:20 <wli> I've never even heard of gradual typing.
17:35:22 <gwern> terribly... good?
17:35:24 <mmorrow> pumpkin: and then haskell exposes you to a ton of such stuff
17:35:33 <pumpkin> yeah, it's so fun
17:35:38 <gwern> wli: you're missing out then. I think gradual typing is going places
17:35:50 <gwern> it's the bees knees for mainstream languages, if they ever catch up
17:35:53 <wli> Sounds great. What is it?
17:35:55 <ddarius> > let f'x' = 3; f 'x' = 4 in f'x'
17:35:56 <lambdabot>   3
17:36:29 <gwern> wli: in the same language, it lets you write a dynamicly typdd program, and then convert individual functions and expressions to static ones
17:36:36 * ddarius thinks gradual typing is going places where no one wants to follow.
17:36:38 * sm just got a nice pandoc dev environment set up
17:36:47 <cads> gwern, I've read a little hype paper on something called pluggable typing, and have heard gradual typing mentioned in relation to that. Pluggable typing seems compelling if it would create a general environment for computations where different type systems could be leveraged and work together
17:37:18 <b\6> i configured ~/.cabal/config, and cabal made a wacky directory like "~/.cabal/packages?library-profiling: True?executable-profiling: True...", i kid you not. is this really how it's supposed to work?
17:37:19 <cads> ddarius: what do you mean?
17:37:20 <wli> gwern: Sounds like something I saw Palsberg going on about at one point.
17:37:27 <gwern> ddarius: well, if people *wanted* to follow you then leadership would be no accomplishment :)
17:37:37 <gwern> b\6: sounds horribly broken
17:37:44 <CalJohn> i saw a presentation somewhere about adding gradual typing to python, but tbh, the "dynamic" type sounds like more trouble than it is worth
17:38:21 <CalJohn> i don't know enough about gradual typing to know if all systems use the dynamic type though
17:38:29 <mmorrow> pumpkin: (i initially started out as CS in undergrad, but switched to math half-way through)
17:38:42 <pumpkin> ah, I did the opposite :P
17:38:57 <wli> I think what I saw Palsberg doing was doing type inference until things broke down somehow, then dumping in coercions and other things to handle where type inference failed.
17:39:20 <mmorrow> pumpkin: but i took a few CS courses in the last two years
17:39:53 <gwern> wli: that does sound vaguely fmiliar
17:40:28 <mmorrow> pumpkin: (crypto, analysis/design of algorithms, and computer graphics)
17:40:49 <mmorrow> pumpkin: although the crypto wasn't programming
17:41:09 <pumpkin> ah
17:41:17 <pumpkin> those are fun
17:41:22 <pumpkin> no theory?
17:41:24 <mmorrow> yeah, it was pretty interesting
17:41:43 <mmorrow> pumpkin: err, do you mean wrt the crypto or wrt "CS theory"
17:41:57 <pumpkin> CS theory
17:41:57 <gwern> mmorrow: cs theory is the only logical reply
17:42:09 <mmorrow> gwern: not necessarily
17:42:10 <gwern> since if the cyprot wasn't programming, and it wasn't theory, then what could it be?
17:42:17 <wli> I never thought of it as anything special apart from optimizing dynamically typed languages by using some limited type inference to nuke dynamic typechecks.
17:42:30 <mmorrow> gwern: shopping?
17:42:37 <gwern> for barbies
17:42:43 <monochrom> crypto is crypto theory
17:43:01 <mmorrow> pumpkin: no, i went for the math dept in that case
17:43:14 <gwern> wli: well, a lot of good cs stuff can be made to sound trivial like that :)
17:43:22 <pumpkin> ah :)
17:45:07 <mmorrow> pumpkin: although i guess the algorithms one was considered part of the theory track
17:45:15 <pumpkin> yeah
17:45:50 <cads> how complicated can the gradual typing system be? Could it allow your programs to range from being completely dynamic, all the way to representing proofs in a dependent type system?
17:46:20 <wli> gwern: What I'm trying to figure out right now is this one thing Chakravarty came up with to get higher-order modules and typeclasses to interperate nicely by basically translating all typeclasses to modules.
17:46:32 <gwern> cads: I think the ideal is to go from fully dynamic to fully static, although I'm not sure I've heard of 'fully static' being anything more powerful than HM
17:46:36 <pumpkin> wli: ask him next time he appears in here!
17:46:50 <wli> pumpkin: What's his nick?
17:46:53 <pumpkin> ChilliX
17:47:49 <wli> argh he was just here
17:48:27 <pumpkin> he's here quite often
17:48:39 <gwern> @seen ChilliZ
17:48:39 <lambdabot> I haven't seen ChilliZ.
17:48:40 <gwern> @seen ChilliX
17:48:41 <lambdabot> I saw ChilliX leaving #ghc, #haskell-in-depth and #haskell 2d 14h 46m 8s ago, and .
17:56:14 <monochrom> @quote newsham 1 type
17:56:14 <lambdabot> newsham says: there are Just 1 types of people, Nothing and those who understand monads
18:04:45 <fynn> Cale, dons: does that post imply that Clean gets that excellent performance by using uniqueness typing (and maybe Haskell should too)?
18:05:17 <fynn> in that part:
18:05:18 <fynn> "You may have heard from Haskell advocates that Haskell is as fast as C. Well, it's really a half-truth. Sometimes, there is simply no substitute for a good old-fashioned array and mutation of it. It's the only data structure known to man that gives you O(1) read, write with a small constant factor to boot. Haskell can give you that, but your choices are: (1) state and other monads (that don't compose too well) with mutable arrays in GHC (that can cause i
18:05:19 <fynn> nsane GC slow-downs), defeating the purpose of using them or (2) malloc'ed array hacking. If you look at the Shootout entries, Haskell entries are ugly unsafePerformIO and malloc-using hacks with everything stuck into IO monad, where Clean is idiomatic and simple, and still faster!"
18:05:30 <fynn> whoops, that looked shorter on the page :(
18:05:44 <Cale> fynn: Well, uniqueness typing makes it easier to compile efficient code.
18:05:44 <Gracenotes> MyCatVerbs: by the way, why is your mdo example a bad idea? does it at least have expected behavior?
18:07:33 <Cale> fynn: However, the main reason (I think) that Clean has been traditionally faster has been that good code generation had been a priority for longer there.
18:09:09 <scutigera> why can't haskell compilers pick-up Clean compiler tricks ?
18:09:22 <Ralith> scutigera: feel free to submit a patch!
18:09:47 <Lemmih> scutigera: It requires effort.
18:11:13 <scutigera> I'm wasn't saying that someone should get to work on that, I'm just saying that clean appears to be open-source, so in principle couldn't haskell compiler writers use ideas form clean ?
18:11:37 <lament> clean is open-source?
18:11:47 <scutigera> says lgpl on the website
18:12:27 <idnar> but do they actually have source on the website?
18:12:57 <scutigera> well you would have to fill out the reg form to find out , grrr...
18:13:00 <Lemmih> scutigera: It's certainly possible to improve GHC's code generation. There just isn't enough developer time to do it.
18:13:12 <koninkje> scutigera: we could use the ideas (they're in academic press, even if not F/OSS) but the code would probably be harder to use due to differences in the AST representations
18:13:43 <pejo> scutigera, people are aware of lots of things that can be improved for performance in GHC. It's just that someone has to do it, and the usual suspects are busy doing multicore performance things, type system things, etc.
18:14:11 <dolio> They have at least one person working on code generation and optimizations.
18:14:19 <scutigera> the thing I was wondering about specifically was the comment about shoot-out code being ugly hacks.  I'll make the bold assumption clean code is not.  Is it a language design issue, or a compiler implementation issue ?
18:14:28 <pejo> dolio, Dias?
18:14:38 <dolio> I was thinking Max Bolingbroke.
18:14:43 <dolio> Maybe they have 2? :)
18:15:21 <pejo> Oh yeah, he seems very active.
18:15:49 <Lemmih> scutigera: I'm convinced it's a compiler issue but I guess I'm biased.
18:15:55 <pumpkin> Max Bolingbroke is doing Clean?
18:16:00 <dolio> No, GHC.
18:16:09 <wli> Arrays need card marking.
18:16:38 <scutigera> pejo: multicore performance things would be quite nice and is certainly a good use of developer time :-)
18:16:55 <koninkje> scutigera: If it's the array thing, then linear types give a big advantage for making it easy to generate good code. It may be possible to hack together the right monad to give the same assurances, but it's less straightforward
18:17:35 <scutigera> what are these linear types (sorry ML'er, new to haskell) ?
18:17:45 <skorpan> never heard of 'em
18:17:56 <pumpkin> they're used to climb to the top of the shootout
18:18:28 <koninkje> Clean's type system lets you give types which know whether they are only acceassible from one place (i.e. are linear) vs if multiple sources hold pointers to it
18:18:46 <jedai> scutigera: linear types are in Clean, they're based on linear logic. It's the base of the uniqueness typing in Clean
18:19:07 <koninkje> Thus, if a given value is of a linear type, then we can do mutations on it instead of allocating a new one (and noone can tell the difference)
18:19:10 <chrisdone> I've been looking at Clean's typing recently too!!
18:19:21 <Cale> Basically, linear types give you a way to express that the parameter to a function may only occur so many times in its body.
18:19:25 <gnuvince_> Everybody's been doing that since that article on Reddit :)
18:19:26 <Cale> (typically, once)
18:19:37 <pumpkin> so uniqueness types are linear types with n = 1?
18:19:45 <dolio> No.
18:20:00 <jedai> It's pretty cool. Though the syntax is arguably less nice than monads in Haskell
18:20:03 <Cale> Er, perhaps I'm confused there.
18:20:45 <koninkje> Uniqueness types and monads are orthogonal ideas. They only happen to both offer a story for how to deal with IO in a pure way
18:20:57 <dolio> Linear means you must use a parameter exactly once, essentially.
18:21:02 <dolio> No contraction, no weakening.
18:21:05 <scutigera> does it require annotation by the coder, or does the compiler figure it out ?
18:21:08 <Cale> Right, yes.
18:21:48 <mmorrow> i have a dir with the unpacked Clean src tarball (from a month or 3 ago) that sends text/plain if anyone wants to browse: http://moonpatio.com/repos/MISC/Clean/
18:21:52 <dolio> Uniqueness is somewhat different, in that it looks at what has been done with a variable in the past, if I recall edwardk's explanation correctly.
18:22:04 <dolio> And it doesn't worry about throwing away references, only duplicating them.
18:22:04 <mmorrow> 80% of the rts is hand-coded asm
18:22:17 <dolio> So, contraction and not weakining (I think).
18:22:18 <jedai> scutigera: Well it requires annotation, you have to tell in the type that a parameter is linear
18:22:25 <Cale> Yeah, even with uniqueness types, the IO monad would be nice to have.
18:22:42 <chrisdone> are variables copied upon assignment in uniqueness typed implementations?
18:22:47 <dolio> But if you haven't yet duplicated a reference, it's safe to mutate the thing that reference points to, essentially. So they have some overlap.
18:22:53 <chrisdone> I was reading some papers but it was confusing
18:22:59 <koninkje> It would be pretty easy to add monads to Clean, except that they don't have type classes as I recall
18:23:22 <Cale> koninkje: They have type classes I think, but maybe not constructor classes.
18:23:29 <dolio> They have type classes with one method each, at least.
18:23:40 <koninkje> chrisdone: linear variables become nonlinear on assignment, IIRC.
18:23:47 <dolio> Not that that's a problem if you structure your hierarchy right. :)
18:23:54 <mmorrow> clean has polymorphic dynamics too (which can be read/written from/to file)
18:24:14 <mmorrow> http://moonpatio.com/repos/MISC/Clean/dynamic/dynamics/
18:24:26 <scutigera> #  Type classes
18:24:26 <scutigera> and type constructor classes are provided to make overloaded use of functions and operators possible;
18:24:47 <Cale> Well, then it's entirely possible.
18:25:18 <mmorrow> and there's a bunch of interesting linker code (if anyone is looking for examples of such things) http://moonpatio.com/repos/MISC/Clean/dynamic/linkers/
18:25:39 <Cale> I heard something a while back about the Clean guys doing a Haskell implementation?
18:25:39 <mmorrow> ah, here too http://moonpatio.com/repos/MISC/Clean/tools/elf_linker/
18:25:48 <Cale> Has there been any noise about that?
18:26:02 <bremner> but hand coded asm, isn't kinda  a portability nightmare?
18:26:12 <wli> mmorrow: How about Clean's modules?
18:26:17 <scutigera> so my impression of monads is that they are a mathematically rigorous way of handling side-effecty things.  are uniqueness types similarly rigorous or a clever coding style ?
18:26:41 <pumpkin> preflex: zdec zh
18:26:41 <preflex>  #
18:26:47 <jedai> scutigera: Yes, they're rigorous, not just a clever style
18:26:55 <dolio> Uniqueness types handle mutability.
18:26:57 <Peaker> What if subclassing was seperated into: A) Superset-of-expressiveness  B) Definition/laws depend on them.  Then, B cases (e.g MonadPlus) could remain as is, but (A) could be specified independently with ever increasing accuracy without breaking existing code
18:27:07 <pumpkin> preflex: zdec zm
18:27:07 <preflex>  -
18:27:32 <koninkje> Monads don't really have much to do with side effects (IO being the exception), they have more to do with structure. Uniqueness types are rigorous, but they have more to do with resource management (hence linear logic)
18:27:33 <dolio> Monads give you formalisms for handling things other than mutability.
18:27:43 <mmorrow> wli: hmm, i haven't read anything about them, so i think they're probably along the same lines as haskell's
18:28:08 <Peaker> Most subclasses I see in Haskell aren't really required for the laws or definitions -- and mentioning them right there with the class creates an unnecessary dependence/knowledge between library components
18:28:23 <chrisdone> a wizard once said to me, "monads aren't useful if there's only one of them", or something like that. that wizard's name was Cale
18:28:48 <Peaker> One of the great things about Haskell is the fact it allows instances to be independent of the types (with orphans, even of the type and class) -- I think the same can be done about most "subclass" relationships
18:28:50 <scutigera> I'm looking at Clean language report and modules look similar to haskell (per my limited experience)
18:28:59 <Cale> chrisdone: Right, sounds like something I'd say :)
18:29:07 <wli> suckage
18:29:07 <mmorrow> one handy thing that clean has too (which is equiv to bang patterns, but possibly more convenient in some cases) is that you add the bangs in *the type sig* rather than on the params
18:29:24 <mmorrow> foo !x = x*2
18:29:27 <mmorrow> vs.
18:29:36 <dancor> how do you do multiple array indexing with exprParserTable?  my failed attempt at http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2082#a2082
18:29:37 <mmorrow> foo :: !Int -> Int = (*2)
18:29:38 <glguy> it makes more sense to put them in the types
18:29:39 <chrisdone> I noticed that
18:29:39 <Peaker> is Clean lazy?
18:29:48 <Cale> mmorrow: I think that having it be part of the pattern makes way more sense.
18:29:53 <scutigera> Peaker: yes
18:30:21 <Peaker> but Haskell types are denotational, not operational - so strictness in the types is a little out of place - also strictness can be partial and in some of the cases
18:30:54 <koninkje> Strictness in types means only that _|_ is no longer a member of the type (essentially)
18:30:56 <mmorrow> Cale: i think it depends on the situation
18:30:58 <dolio> Strictness is a denotational property.
18:31:33 <mmorrow> Peaker: haskell has bangs on the types in data decls
18:31:42 <mmorrow> just not in function/value sigs
18:31:56 <dancor> i guess i'll have to throw a many1 in there somewhere.  but i can't figure out why it doesn't work already
18:31:56 <pumpkin> she bangs she bangs
18:32:10 <Peaker> mmorrow: Its in the specification of a type - not in a type expression itself, though
18:32:26 <kyagrd> I think we should have bangs in type sinatures as well
18:32:31 <Cale> dolio: With higher-order and multiparameter functions, if you want to be able to express everything about strictness in the type, the types can get very complicated.
18:32:41 <mmorrow> Peaker: i don't see a difference
18:32:55 <dolio> The thing is, "foo 0 = 0 ; foo x = x * 2" is the same if you give it either type !Int -> Int or Int -> Int, because it matches against 0.
18:33:02 <Cale> For example, it's totally possible for a function of two parameters to be strict in the second parameter if and only if the first parameter was prime.
18:33:02 <Peaker> mmorrow: Well, bangs won't appear on the rhs of a ::, right?
18:33:16 <dolio> So, shouldn't it always have type !Int -> Int, if you're going to note that in the types?
18:33:29 <mmorrow> Peaker: not in haskell because it's illegal
18:33:49 <Peaker> mmorrow: that's what I mean -- bangs are not part of types, but part of data declarations specifically
18:34:33 <mmorrow> Peaker: they are part of the type in the data declaration though
18:34:53 <kyagrd> In Dana Xu's paper about "Static Contract Checking for Haskell", her work includes kind of that. Ok is essentially a type refinement of a bang type
18:37:14 <wli> refinement?
18:37:20 <dancor> i guess exprParserTable doesn't repeat any of the prefix or postfix ops
18:37:30 <dancor> but it does do so with the infix ones
18:38:25 <kyagrd> Cale: refinment is subtyping. !Int has all the values of Int except bottom.
18:39:04 <wli> unlifted sure
18:39:22 <mmorrow> gah! clean's codegen is written in C
18:39:26 <Cale> kyagrd: Yes, though if you want to express the strictness of functions in general, that can be somewhat inexpressive.
18:39:44 <deech> Beginner Question: if I have a type synonym: type Worth = Int
18:40:03 <deech> Why can't do something like: (15 :: Worth) / 5
18:40:15 <pumpkin> because you can't do / on Int
18:40:20 <pumpkin> `div` maybe
18:40:29 <deech> pumpkin: But I can do 15 / 5
18:40:30 <mmorrow> or fromIntegral it
18:40:37 <kyagrd> Try :t 15
18:40:41 <pumpkin> deech: have you tried (15 :: Int) / 5?
18:40:45 <Cale> for example, consider  f n m | isPrime n = Just m; f n !m = ...
18:40:49 <pumpkin> :t 15
18:40:50 <lambdabot> forall t. (Num t) => t
18:41:03 <mmorrow> , 15 :: Double
18:41:04 <lunabot>  15.0
18:41:05 <deech> 15/5
18:41:05 <mmorrow> , 15 :: Int
18:41:07 <lunabot>  15
18:41:15 <Cale> That mode of strictness is hard to express only using such types.
18:41:41 <deech> But GHCI evaluates 15/5 to 3.0
18:41:47 <mmorrow> :: Double
18:41:55 <deech> Oh I get it now
18:42:05 <deech> thanks pumpkin
18:42:06 <kyagrd> deech: yeah it's because 15 is overloaded
18:42:14 <mmorrow> you can use floor/ceiling/round to go from Double -> Int(eger)
18:42:27 <mmorrow> or just use div in the first place
18:42:37 <mmorrow> i guess it depends on what you're trying to do
18:43:20 <deech> Div is what I was looking for. Thanks!
18:44:23 <mmorrow> Cale: your example is impossible to express in the type
18:44:42 <Cale> mmorrow: Well, at least with such a simple kind of annotation.
18:44:51 <mmorrow> Cale: although, you could argue that since your example can be done with `seq` alone, it isn't a property of the type there
18:44:52 <PetRat> I'm reading "Monadic Parser Combinators" (Hutton, Meijer, 1996) and the demonstration language used is Gofer, which looks remarkably similar to Haskell. However, in Chapter 3 they introduce something called monadic comprehension syntax. Does Haskell have this? Is Haskell's "do" notation the same thing?
18:45:13 <Cale> mmorrow: It could be part of the type, if the type system were sufficiently expressive.
18:45:14 <gwern> no. those were dropped for '98 iirc
18:45:20 <mmorrow> Cale: true
18:45:28 <gwern> PetRat: do notation isn't the same either
18:45:30 <Cale> PetRat: do-notation is similar
18:45:42 <Cale> It's almost the same, modulo guards.
18:45:43 <Gracenotes> one can simply translate monad comprehensions -> do syntax
18:46:00 <pumpkin> can you translate monad incomprehension to do syntax though?
18:46:01 <Cale> and yeah, even guards have an easy enough translation, using the 'guard' function
18:46:08 <Cale> pumpkin: heh
18:46:09 <PetRat> I want to keep working the examples, but I'm not clear on the translation. Let me post an example...
18:46:11 <mmorrow> Gracenotes: assuming MonadPlus though
18:46:11 <pumpkin> monad incomprehension seems a lot more widespread
18:46:22 <gwern> pumpkin: sure. 'do f <- getChar; ???; return ()'
18:46:31 <PetRat> pumpkin: :)
18:46:31 <mmorrow> @type guard
18:46:33 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:46:35 <Gracenotes> mmorrow: right. well, you could use guards with fail
18:46:47 <Gracenotes> it might be somewhat disastrous though
18:46:53 <mmorrow> Gracenotes: yeah
18:48:38 <gwern> @quote raccoon
18:48:38 <lambdabot> No quotes match. I feel much better now.
18:48:45 <chrisdone> preflex: be poppavic
18:48:45 <preflex>  no quotes found for poppavic
18:48:53 <pumpkin> rocky raccoon
18:48:54 <chrisdone> @vixen don't fail me now
18:48:54 <lambdabot> why not later?
18:48:55 <dolio> fail wasn't in the Monad class back when monad comprehensions were around, so I'm not sure what the problem with requiring MonadPlus is.
18:49:11 <dolio> Except that it isn't MonadZero.
18:49:37 <gwern> 'T-rex, we put our minds to it and taught ourselves Haskell! let us explain monads to you using the metaphor of cephalopod rape!'
18:49:39 <Gracenotes> it should be, many say
18:49:44 <PetRat> Here is example of Monadic comprehension: http://www.mibbit.com/pb/GsUivZ
18:49:48 <Gracenotes> gwern: do want
18:50:01 <dolio> Well, it was MonadZero back then. That was another thing that changed with 98.
18:50:12 <gwern> Gracenotes: I wasn't being serious, just riffing on dinosaur comics
18:50:15 <PetRat> Can someone show me what the do notation would be?
18:50:16 <chrisdone> gwern: BONUS could learn a thing or two from you
18:50:25 <wli> gwern: I've seen a few animes like that.
18:50:39 <gwern> chrisdone: *everyone* could learn somethings from me. like how to wiggle their eyes
18:50:43 <gwern> and ears!
18:50:48 <Gracenotes> gwern: after reading your comment I immediately became disappointed, knowing there wasn't a qwantz comic about that
18:50:53 <gwern> (so few people can wiggle their ears, it's tragic)
18:51:03 <gwern> Gracenotes: you could submit a fancomic
18:51:07 <chrisdone> I can totally wiggle my ears
18:51:13 <Gracenotes> mm. or you :x
18:51:18 <gwern> (actually, that sounds like a good way to kill a few minutes)
18:51:49 <gwern> except my firefox pageaddict plugin has blocked me from webcomics for the day :(
18:51:54 <gwern> better go do something more productive
18:52:11 <Trafalgards> ooo, what is this pageaddict plugin? That sounds useful!
18:52:14 <mmorrow> gwern: wiggle your ears!
18:52:14 <chrisdone> does it block you from google?
18:52:16 * Trafalgards googles
18:52:26 <PetRat> bump-- Here is example of Monadic comprehension: http://www.mibbit.com/pb/GsUivZ  Can someone explain how to do this in "do" notation?
18:52:29 <gwern> chrisdone: if you set it to
18:52:43 <Gracenotes> I have leechblock, myself
18:53:08 <wli> what does leechblock do
18:53:10 <Gracenotes> no filters though :\ I seem to get by without it
18:54:10 <gwern> looks pretty similar to pageaddict, yes
18:55:06 <dons> ?yow
18:55:07 <lambdabot> Xerox your lunch and file it under "sex offenders"!
18:55:14 <Gracenotes> whoa thar.
18:55:37 <Cale> PetRat: do x1 <- p1; x2 <- p2; return (f x1 x2)
18:55:58 * Gracenotes imagines what the Firefox Add-ons website would be like if it were the Firefox Add-ons Store
18:56:02 <Gracenotes> *shudder*
18:56:37 <dancor> add-ons: when vanilla firefox isn't unstable enough
18:56:38 <sjanssen> bump++
18:56:51 <PetRat> Thanks Cale
18:57:06 <gwern> Gracenotes: 'Your application was rejected for violating our ad-partner's Terms of Services.'
18:57:30 * dancor was thinking about trying to build a vi-like browser on top of webkit
18:57:40 <gwern> ala vimperator?
18:57:43 <dancor> ya
18:57:48 <mmorrow> vimperator rocks!
18:57:54 <Gracenotes> apparently that's what this 'command line' Firefox feature is about
18:57:56 <dancor> it hasn't rocked my world
18:57:58 <Gracenotes> to an extent
18:58:24 <gwern> all you really need for a keyboard driven FF is something to number hyperlinks, honestly
18:58:26 <Gracenotes> when I first heard of it I expected it to be controlling Firefox from the command line itself, i.e. a shell. Was disappointed.
18:58:26 <sjanssen> there is only one bad thing about Vimperator: it has locked me in to Firefox
18:58:29 <gwern> stuff like conkeror is overkill
18:58:48 <kyagrd> PetRat: you can also rewrite it as    liftM2 f p1 p2
18:58:55 <kyagrd> liftM2 is in Monad module
18:58:59 <sjanssen> I don't ever want to go back to the old way of browsing
18:59:03 <dancor> everyone has a different idea of the perfectly minimal browser
18:59:06 <dmhouse> IMO browsing is a somewhat inherently mouse-driven exercise.
18:59:20 <sjanssen> gwern: the regular browser bindings are too awkward for exclusive use
18:59:22 <gwern> dancor: the ol 80-20 rule?
18:59:22 <dmhouse> The keyboard is not the tool to end all tools.
18:59:35 <sjanssen> eg. alt-left is annoying, shift-h is convenient
18:59:52 <gwern> sjanssen: they're not too bad. C-w, C-t, c-pgup, c-pgdwn are livable
19:00:16 <Trafalgards> I went and got a mouse with a mousewheel which can tilt left or right, and bound that to alt-left and alt-right
19:00:26 <dmhouse> I find I'm pretty productive with one hand on the mouse and the over hovering over CapsLock (rebound to Ctrl) and the far-left keys: I have Ctrl+s,Ctrl+f for switching left/right a tab, Ctrl+w for closing and Ctrl+t for opening a new tab.
19:00:41 <dmhouse> Ctrl+r for reloading... that's pretty much all you need.
19:00:46 <Trafalgard> so browsing really is mouse-driven :P
19:00:57 <sjanssen> gwern: d, t, c-n, c-p are all much nicer
19:01:03 <Trafalgard> don't even have to go looking for the back button, just push the mousewheel to the left
19:01:18 <liyang> *cough*gestures*cough*
19:01:45 <Trafalgard> Last time I had gestures on was in Opera, and I hated it
19:01:47 <mmorrow> dmhouse: how do you go back/forward?
19:01:58 <gwern> really, I've always found c-n and c-p annoying. pageup and pgdown are so much more reliable for my hand to find
19:02:16 <Trafalgard> It went something like "ghghkhkghkg stop changing the page when I don't want you to just because I accidentally pressed a mouse button while I was holding the other one already!"
19:02:17 <liyang> Right-Down drag-left release for Back.
19:02:34 <mmorrow> i hit shift-h
19:02:57 <Trafalgard> (when I was dragging a scrollbar for some reason)
19:02:57 <chrisdone> I tried vimperator but something was weird with it...
19:03:03 <dmhouse> mmorrow: hmm, I suppose that's missing from my set. I'm still on Alt+Left/Right
19:03:10 <liyang> Keyboard's alright on the laptop when my hands are on the trackpad and already near the keys.
19:03:26 <liyang> But with a real mouse, gestures rock.
19:03:26 <wli> I usually use stuff like 24k, 53G, etc.
19:03:48 <Trafalgard> technically Black & White is what REALLY turned me off mouse gestures :P
19:03:54 <dmhouse> ?localtime dmhouse
19:03:55 <mmorrow> laptops are nice because you can control the mouse and keyboard at the same time
19:03:55 <lambdabot> Local time for dmhouse is Sat Apr 11 03:04:01 2009
19:03:59 * dmhouse -> bed
19:04:14 <Trafalgard> but they're probably nothing alike
19:04:34 <Trafalgard> I just never bothered looking into it because they had the same name
19:04:36 <wli> Laptops are a struggle for me; I go for the biggest ones I can get.
19:04:40 <liyang> Trafalgard: I forget the name of the plugin I use in Firefox. It's like, totally configurable lol.
19:05:46 <liyang> (I end up disabling most of them, mind you. Scroll wheel on the tabs plus gestures for back and forwards is about enough for me.)
19:06:06 <wli> Speaking of struggling, this typeclass/module stuff is blowing me away.
19:07:19 <wli> I'm still screaming about the unavailability of 3-button mice (no, clickable scroll wheels are not adequate substitutes).
19:07:40 <liyang> wli: what's wrong with clickable wheels?
19:07:48 <pumpkin> I like my multitouch touchpad
19:07:55 <pumpkin> don't miss a mouse in the least
19:07:58 <wli> I don't want them. I want the middle button.
19:08:05 <liyang> pumpkin: Snap!
19:08:11 * mmorrow loves the thinkpad mouse
19:08:26 <pumpkin> the ****?
19:08:38 <liyang> wli: set your machine up to ignore scrolls. File down the knobbly bit with some sandpaper.
19:08:45 <mmorrow> i've got a trackpad on my new one, and it's killing me (since i always by accident brush against it and all kinds of random crap happens)
19:08:59 <mmorrow> (it has a trackpad and the standard thinkpad mouse)
19:09:05 <wli> liyang: No. Middle buttons are middle buttons.
19:09:08 <pumpkin> ah, the trackpads on macs are pretty good at avoiding accidental input (I've found)
19:09:20 <skorpan> what's a trackpad?
19:09:21 <pumpkin> by thinkpad mouse, you mean the little joysticky thing?
19:09:34 <liyang> pumpkin: nipples. I think he means.
19:09:38 <pumpkin> ah
19:09:43 <pumpkin> yeah, I've heard it called something else
19:09:48 <wli> Middle buttons are as wide as a finger and as deep as the outer two buttons.
19:09:50 <mmorrow> pumpkin: i think it's mostly just because i don't use it and the only times i ever notice it are when it gets in the way
19:09:50 <liyang> Well, nipple. Singular.
19:09:55 <pumpkin> ah
19:10:07 <liyang> wli: go back to the 1980s where you belong!
19:10:26 <mmorrow> pumpkin, liyang: yeah, the nipple thing
19:10:32 <wli> I mostly use the touchpads. I've mostly heard it described as analogous to certain portions of female genitalia.
19:10:38 <pumpkin> lol
19:10:38 <mmorrow> between the g,h,b
19:10:39 <skorpan> mmorrow: some touchpads are lockable: http://upload.wikimedia.org/wikipedia/en/a/a8/Compaq_touch_pad.jpg
19:10:40 <pumpkin> wli: same here :P
19:10:50 <mmorrow> skorpan: ooh, good idea
19:11:27 <skorpan> that does kind of give the user the idea that the touchpad sucks though :)
19:11:35 <wli> liyang: Time travel may not be possible, but I would at least like the option to buy old-style equipment.
19:11:59 <wli> s/equipment/input devices/
19:12:00 <liyang> (My touchpad doesn't react to my palm, even when I'm not typing.)
19:12:06 <pumpkin> same here
19:12:18 <mmorrow> sadly mine does
19:12:22 <wli> I do buy Sun Type 6 USB keyboards religiously.
19:12:25 <liyang> pumpkin: we have awesome laptops. =)
19:12:31 <pumpkin> liyang: mac?
19:12:41 <liyang> pumpkin: of course. =)
19:12:44 <pumpkin> HAI FAIV
19:12:49 <pumpkin> :P
19:12:55 <skorpan> maybe one should get some sort of special gloves for use with touchpads so that they only do something when you're actually using the tips of your fingers (which are not covered)
19:13:03 <pumpkin> but we don't get x86_64 in ghc :(
19:13:33 <liyang> pumpkin: only because no one's bothered to port amirite?
19:13:33 <pumpkin> skorpan: or they could just use better pads that can recognize your fingers :)
19:13:51 <pumpkin> liyang: both I and thoughtpolice have tried, and we've both failed so far
19:13:53 <skorpan> pumpkin: i like to think "what would macgyver do?"
19:14:11 <mmorrow> duct tape over it and use a thinkpad nipple
19:14:11 <mmorrow> ?
19:14:43 <liyang> I find nipples horribly inaccurate. :-/
19:14:56 <mmorrow> for the first few weeks you're in hell
19:14:57 <wli> That's a bit further up than the portion of anatomy I usually hear the Thinkpad pointer controller compared to.
19:15:00 <pumpkin> you can't do much instant movement with them
19:15:00 <skorpan> please, stop saying nipples... :P
19:15:06 <mmorrow> then all of a sudden you're professional at them
19:15:07 <liyang> (Someone ought to quote that.)
19:15:08 * bremner was mildly startled by discussion of duct tape and nipples on #haskell
19:15:09 <pumpkin> clits then? :)
19:15:37 <skorpan> duct tape over nipples... i'm sure i can find an image of that.
19:15:42 <liyang> Nipples are gender-neutral.
19:15:58 <mmorrow> liyang: the key to proficiency is realizing you have to apply a lot more pressure than you think you do
19:16:19 <liyang> You can't use pumpkin's suggestion in polite conversation.
19:16:34 * pumpkin looks guilty
19:17:08 <fynn> Cale: so basically, GHC will approach Clean's performance as it matures?
19:17:33 <skorpan> lol what the hell... "clit" on wikipedia: A Pointing stick (aka IBM TrackPoint) usually found on a laptop used as a pointing device.
19:17:41 <liyang> mmorrow: that's what she said.
19:17:53 <mmorrow> liyang: indeed
19:18:05 <fynn> maybe because "clit" is not the full scientific term.
19:18:13 <fynn> but a vulgar slang term.
19:18:25 <pumpkin> define vulgar
19:18:26 <pumpkin> http://en.wikipedia.org/wiki/Clit
19:18:33 <chrisdone> commander?
19:18:46 <skorpan> chrisdone: was that a reference to jay?
19:18:57 <chrisdone> it can be if you want it to be
19:19:07 <skorpan> i'm the commander of clit!
19:19:30 <dons> fynn: aren't they comparable at the moment? (re. GHC v Clean)
19:19:44 <dons> oh, Clean's not on 64 bit
19:19:47 <dons> grr.
19:20:03 <liyang> What image does ``Soft Rim, Classic Dome, Soft Dome'' conjure up in your head?
19:20:03 <dons> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=clean&lang2=ghc&box=1
19:20:16 <mmorrow> dons: i thought i saw a few %rip's in there?
19:20:34 <fynn> dons: *nod*, I'm just curious how it's possible to write nice idiomatic Clean and still get better performance than ugly, non-idiomatic Haskell over GHC
19:20:49 <dons> better code gen. runtime written in asm
19:20:54 <dons> (i think that's why)
19:21:14 <sjanssen> dons: really, in ASM?
19:21:20 <dons> i didn't know that till today.
19:21:22 <altmattr> what is the pretty printer of choice these days folks?
19:21:28 <chrisdone> it does full-program optimisation, I heard
19:21:31 <sjanssen> dons: 'splains a lot
19:21:33 <mmorrow> sjanssen: http://moonpatio.com/repos/MISC/Clean/RuntimeSystem/
19:21:33 <dons> so clean is like this stripped down F1 car.
19:21:34 * chrisdone steps back into the crowd
19:21:45 <dons> it isn't entirely road worthy, but it is fast if you put it in the right track.
19:21:55 <dons> while ghc is more like a big truck. go anywhere, run anything
19:22:16 <ivanm> dons: runs over anything in its path? ;-)
19:22:20 <dons> yep
19:22:22 <altmattr> dons: and goes fast if you really want it to and are happy to risk rolling in the corners
19:22:30 <dons> hehe
19:22:31 <sjanssen> I thought it was a series of tubes?
19:22:32 <Stinger> is driven by chunky fat blokes?
19:22:42 <liyang> dons: an Ariel Atom might be a better comparison.
19:23:03 <dons> liyang: yeah!
19:23:07 <liyang> (YouTube it.)
19:23:16 <dons> http://www.arielatom.com/images/homepage/home-top.jpg Clean.
19:23:31 <dolio> Which shootout benchmarks have Clean that looks significantly nicer than the Haskell?
19:23:50 <dons> not sure anymore. i thought we were mostly the same, but with less {#!a}
19:23:52 <fynn> dons: do you think GHC ultimately would improve in performance to the point that (at least for certain parts) it would perform as well as the Clean compiler?
19:23:56 <lament> no doors, no roof, no compromise!
19:24:02 <lament> good slogan for a house
19:24:09 <dons> fynn: it outperforms it already for a bunch of things.
19:24:20 <liyang> Atom on BBC Top Gear: http://www.youtube.com/watch?v=WaWoo82zNUA
19:24:24 <dons> look at  the link above: http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=clean&lang2=ghc&box=1
19:24:55 <dons> ghc's faster in the majority of programs that have been implemented in Clean.
19:25:07 <fynn> dons: isn't Quad Core sort of cheating? ;)
19:25:14 <dons> oh, good point.
19:25:23 <dons> yeah, Clean won't use the extra cores.
19:25:25 <fynn> it's well known GHC supports SMP very well.
19:25:32 <pumpkin> even better, recently
19:25:36 <dons> are there single core benchmarks anymore?
19:25:42 <ivanm> dons: oh, doesn't Clean parallelise/use concurrency?
19:25:49 <dons> well, there's concurrent clean.
19:25:55 <dons> about the same age as concurrent haskell
19:25:56 <ivanm> dons: the other architecture for the shootout?
19:25:56 <sjanssen> dons: can't be easy to support SMP if your RTS is written at such a low level
19:25:59 <pumpkin> http://shootout.alioth.debian.org/u64/
19:25:59 <dons> but the rts isn't parallel...
19:26:25 <fynn> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=clean&lang2=ghc&box=1
19:26:28 <pumpkin> http://shootout.alioth.debian.org/u32/
19:26:29 <pumpkin> yeah
19:26:32 <dons> there we go, http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=clean&box=1
19:26:46 <dons> clean and ghc on a modern 64 bit box.
19:26:56 <dolio> 1/1, 1/1, -, 1, 1, 1, 1
19:26:59 <maxote> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ats&lang2=ghc&box=1    ATS is faster atmost than Haskell except in threads
19:27:33 <pumpkin> ATS has a lot of inline c :P
19:27:34 <chrisdone> ATS makes me cry inside
19:27:36 <dons> similar on 32 bit as well. between 2x faster and 2x slower, evenly.
19:28:15 <gnuvince_> All the speed of C, four times the code
19:28:18 <fynn> dons: the point of that post was that these results are for clean Clean vs. ugly, non-idiomatic Haskell
19:28:19 <gnuvince_> What's not to like?
19:28:20 <pumpkin> lol
19:28:29 <dons> fynn: ah, you'd have to actually find an example :)
19:28:46 <dons> :: Bodies :== (!.{#Real},!.{#Real},!.{#Real},!.{#Real},!.{#Real},!.{#Real},!.{#Real})
19:28:49 <dons> scares me
19:28:50 <ivanm> gnuvince_: :o
19:28:57 <ivanm> why would you write four times the code? :s
19:29:13 <dons> cool type system, would be a good systems language.
19:29:13 <fynn> "If you look at the Shootout entries, Haskell entries are ugly unsafePerformIO and malloc-using hacks with everything stuck into IO monad, where Clean is idiomatic and simple, and still faster!"
19:29:17 <ivanm> dons: what's that type sig from?
19:29:33 <dons> fynn: i think that's FUD without actually looking at the code.  http://shootout.alioth.debian.org/gp4/benchmark.php?test=nbody&lang=clean&id=1
19:29:37 <mmorrow> yeah, imo most some of the Clean code i've seen (granted, i've only really seen Clean code while looking at the Clean compiler) is pretty fugly
19:29:42 <pumpkin> fynn: except that type sig might suggest otherwise, and I'm not sure where you'd find unsafePerformIO
19:29:43 <dons> they're both written to be as fast as possible.
19:30:11 <mmorrow> (fugly := syntactically fugly)
19:30:29 <dons> i actually translated clean to haskell for several of them.
19:30:31 <fynn> dons: I'm looking at it right now. I brought this up since I don't think I know enough Haskell to judge.
19:30:34 <pumpkin> well, I admit that putting # on all unboxed things in GHC does make it rather hard to read
19:30:45 <dons> fynn: the haskell is certainly in the low level range for some of them.
19:30:47 <pumpkin> maybe you get used to it though
19:30:49 <dons> particularly the mutable array programs
19:31:08 <dons> while clean has a lot of type system support and sugar for that kind of thing (array syntax, {#!} kind of types)
19:31:11 <mmorrow> convertDynamicPatternsIntoUnifyAppls :: !{# CommonDefs} !Int !*{! Group} !*{#FunDef} !*PredefinedSymbols !*VarHeap !*TypeHeaps !*ExpressionHeap (Optional *File) {# DclModule} !IclModule [String]
19:31:11 <mmorrow> 			-> (!*{! Group}, !*{#FunDef}, !*PredefinedSymbols, !*{#{# CheckedTypeDef}}, !ImportedConstructors, !*VarHeap, !*TypeHeaps, !*ExpressionHeap, (Optional *File))
19:31:16 <mmorrow> (Clean code :)
19:31:30 <ivanm> mmorrow: doesn't look clean to me...
19:31:33 <mmorrow> hehe
19:31:39 <dons> it's an old chestnut. clean was historically faster, but that's mostly because it is designed for working at a lower level
19:31:40 <chrisdone> a friend said he wants to learn ocaml because when using haskell he craves object oriented features. I said I've never wanted that. any of you guys ever crave more OOP stuff?
19:31:50 <dons> hmm.
19:31:57 <dons> nope.
19:32:02 <lament> brains
19:32:03 <mmorrow> what's OOP?
19:32:05 <lament> brrrraaaaaans
19:32:08 <lament> +i
19:32:09 <dons> zombies!
19:32:12 <pumpkin> chrisdone: nope, I get all the advantages of OOP without OOP
19:32:15 <pumpkin> in haskell
19:32:18 <wli> chrisdone: I want extensible variants quite often, but they're not like OOP which vaguely wants extensible records.
19:32:20 <sjanssen> I think they make a patch for those cravings?
19:32:27 <chrisdone> mmorrow: I imagine things like inheritance and stuff like that associated with typical java/c++ ish implementatinos of OO
19:32:34 <lament> zombie patch?
19:33:10 <lament> chrisdone: I am in agreement with your friend, but it's certainly a minority opinion in this channel.
19:33:18 <chrisdone> wli: what's an extensible variant?
19:33:27 <koninkje> chrisdone: I find type classes far more expressive than OOP
19:33:37 <pumpkin> me too
19:33:53 <Apocalisp> What's OOP exactly?
19:33:53 <chrisdone> lament: can you elaborate? I don't really know much about OO outside of haskell and CL
19:33:58 <ivanm> pumpkin: OOP has advancates?
19:33:59 * Apocalisp ducks
19:34:03 <ivanm> *advantages
19:34:15 <ivanm> Apocalisp: well, in OOP you'd write that as Apocalisp.ducks()
19:34:15 <ivanm> ;-)
19:34:25 <chrisdone> Actium: usually, it means polymorphism support, encapsulation, modularity, sometimes inheritance
19:34:26 <koninkje> In fact, they're one of the biggest things I crave when working in any other language (along with, y'know, a type system ;)
19:34:33 <bremner> OOP is what you say when you drop the BABY
19:34:44 <pumpkin> raganwald was just complaining about the lack of something like typeclasses in ruby
19:34:45 <Apocalisp> ooh, so OOP is lambdas with a dot in it
19:35:05 <dolio> You mean ApocalispFactory.getSingletonApocalispFactory().createApocalisp().duck()?
19:35:05 <fynn> dons: so you're saying that Clean just has more syntactic support for lower-level operations than Haskell?
19:35:20 <fynn> which of course works for its benefit in something like the Shootout tasks.
19:35:21 <pumpkin> http://github.com/raganwald/homoiconic/blob/0a456e3636b1a3c178e29d907498e09957c11320/2009-04-09/my_objection_to_sum.md
19:35:28 <koninkje> http://www.dreamsongs.com/Files/ObjectsHaveFailed.pdf
19:35:30 <dons> well, specifically is has array syntax, and ubiquitous unboxed types.
19:35:31 <ivanm> Apocalisp: IIRC, someone recently did a blog post trying to argue that prefix-style fuknction notation is equivalent to OOP's dot notation
19:35:39 <dons> which is considered a bit low level in haskell land
19:35:47 <koninkje> ^ should be required reading for all OOPers
19:35:51 <fynn> pumpkin: how do type-classes even make sense for Ruby
19:36:11 <lament> chrisdone: type classes provide the polymorphism given by interfaces in OO languages, but there's no equivalent of inheritance
19:36:17 <Apocalisp> http://apocalisp.wordpress.com/2008/12/04/no-such-thing/
19:36:26 <lament> chrisdone: modularity can be done with modules, though
19:36:32 <pumpkin> fynn: they don't, but there are a lot of things that could help ruby if it adopted such a system
19:36:44 <Apocalisp> Where's lambdabot?
19:36:46 <lament> chrisdone: (tell your friend that a module exposing one type is like a class)
19:36:47 <Apocalisp> @bot
19:36:47 <lambdabot> :)
19:36:48 <lunabot>  :)
19:36:53 <pumpkin> @botsmack
19:36:54 <lambdabot> :)
19:36:54 <lunabot>  :)
19:36:57 <fynn> dons: interesting. I was mainly wondering if, with such good performance for idiomatic code, Clean may become an interesting language choice.
19:37:03 <Apocalisp> Huh. I could have sworn she used to comment on links.
19:37:08 <liyang> We still don't have parameterised modules do we?
19:37:12 <pumpkin> Apocalisp: people turned it off
19:37:12 <fynn> possibly specifically for lower-level (systems programming) tasks.
19:37:14 <gnuvince_> dons: are the slides of your talk at the London FP group available online?
19:37:18 <pumpkin> liyang: nop
19:37:24 <koninkje> The most important things typeclasses give that OOP interfaces do not: (1) "factory methods", (2) constraints among multiple arguments. Consider for example mzero and (+)
19:37:33 <fynn> pumpkin: how do you mean?
19:37:40 * liyang is starting to find these things more and more annoying the more he works with Agda.
19:37:47 <dons> gnuvince_: not yet, i haven't given the talk. :)
19:37:54 <lament> liyang: no, and that may be another reason to pick ocaml? I don't know how modules work there, though
19:37:59 <gnuvince_> dons: will they be afterwards?
19:38:04 <pumpkin> fynn: he's complaining that it makes no sense for Array#sum to exist on non-numeric or heterogeneous arrays
19:38:05 * gnuvince_ can'T get to London :-/
19:38:11 <ivanm> dons: oh, don't you write your slides before you propose to do the talk? :p
19:38:12 <dons> fynn: i think it might have been an interesting choice 10 years ago, but it has died due to non-technical reasons
19:38:17 <mmorrow> fynn: i think a lot of systems programming is pretty un-doable with a gc'ed lang (that is, unless the entire os is running on a rts for that lang which itself is running on the metal)
19:38:18 <liyang> lament: better than Haskell, IIRC, but you lose laziness and purity.
19:38:19 <chrisdone> lament: I had suspected it might be inheritance that's the issue
19:38:25 <dons> gnuvince_: yeap
19:38:29 <fynn> dons: license and so forth, *nod*
19:38:33 <gnuvince_> ivanm: of course not, he writes them as he needs them
19:38:34 <gnuvince_> Duh
19:38:35 <gnuvince_> :)
19:38:38 <dons> and lack of open community involvement.
19:38:41 <maxote> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=lisaac&box=1   <-- GHC 6.8.2 can't be better than Lisaac except in threads, ohh, GHC is obsolete!
19:38:46 <lament> chrisdone: i certainly don't know how to do it nicely in haskell.
19:38:50 <dons> cathedral vs. bazaar etc.
19:38:57 <fynn> mmorrow: *nod*, I don't know, some people have become interested in that recently.
19:39:07 <fynn> I hope Haskell gains more mindshare, in any case.
19:39:07 <mmorrow> fynn: have you seen "House"?
19:39:12 <mmorrow> it's interesting
19:39:17 <dons> the reason why why now haskell has 1200 libs, and clean has 12.
19:39:19 <fynn> mmorrow: MD? :S
19:39:22 <liyang> Hugh Laurie is awesome.
19:39:25 <mmorrow> fynn: hehe
19:39:42 <mmorrow> fynn: http://web.cecs.pdx.edu/~kennyg/house/
19:39:50 <mmorrow> kenny G!
19:40:21 <dolio> We might want to downplay his association with Haskell.
19:40:26 <liyang> fynn: we don't want Haskell to be too popular now.
19:40:28 <TomMD> mmorrow: And the Haskell L4 is basically done too - its just some engineering tedium and polish work as far as I understand.
19:40:37 <wli> Systems programming with GC is not very workable IMHO. Even if you can ram it through you get the huge problem that you've confounded the implementation language's RTS with the program itself.
19:40:43 <mmorrow> TomMD: oh? what is this?
19:40:46 <liyang> fynn: avoid success at all costs.
19:40:56 <lament> you know you've been playing too much go when you read "haskell has 1200 libs and clean has 12" and think that haskell definitely wins the capture race...
19:41:08 <TomMD> mmorrow: If you read the original House paper it talks about an L4 implementation called 'Osker' (not its name anymore).
19:41:23 <mmorrow> TomMD: ah interesting, just found it
19:41:36 <TomMD> mmorrow: Well, that L4 implementation is more or less done, but the final touches won't be put in place till after a thesis is written.
19:41:49 <TomMD> err, dissertation.
19:42:39 <inimino> lament: surely Clean has made eyes by now :)
19:43:08 <pejo> wli, why is that a problem?
19:43:21 <araujo> Tomas, L4 implementation?.. of House?
19:44:11 <TomMD> araujo: No, no.  The House paper mentions a separate Haskell on metal project which implemented the L4.
19:44:30 <araujo> Tomas, oooh really?....
19:44:33 <araujo> er
19:44:36 <araujo> TomMD,
19:44:45 <araujo> that sounds quite interesting
19:44:51 <TomMD> Its really cool.
19:44:52 <araujo> TomMD, any link?
19:45:22 * araujo curious about how long is that haskell implementation considering the C++ one is just a little bit more of 10KLOC
19:45:23 <TomMD> araujo: No links - its only mentioned in the paper, but the primary researcher is finishing her dissertation now.
19:45:44 <araujo> TomMD, oh, I see ...
19:45:46 <koninkje> There's Mark Jones' work on L4: http://web.cecs.pdx.edu/~mpj/
19:46:00 <TomMD> araujo: So once a defense is done she'll finish.
19:46:10 <TomMD> koninkje: Yep, she studied under Mark.
19:46:21 <araujo> TomMD, sounds very good indeed ... is she one of the researchers of House?
19:46:23 <TomMD> koninkje: And mark implemented an L4 also - but that one is in C.
19:46:48 <koninkje> He has a one in Haskell too (not shure if she was involved in that)
19:46:58 <TomMD> araujo: Same group, but I dont' think she was directly involved with House.
19:47:27 <TomMD> koninkje: Its hers your talking about.
19:47:35 <TomMD> She has one and he was involved.
19:47:48 <araujo> TomMD, ok, so , so far the only information is the mention of it in the House paper?
19:50:17 <wli> Hmm. I can invert by doing egcd with the modulus instead of linear algebra. That'd likely be much faster, too.
19:51:08 <wli> (inverting elements of algebraic extensions of fields, that is)
19:52:10 <TomMD> araujo: Yep.
19:52:14 <TomMD> araujo: http://web.cecs.pdx.edu/~rebekah/
19:52:23 <TomMD> She mentions working on the L4 and has some good papers.
19:52:40 <maxote> if Haskell is purely functional then how manage efficiently the bigger data structures as vectors, hashmaps, etc?
19:53:16 <pumpkin> maxote: we use functional datastructures :)
19:53:25 <wli> Indirections, persistence, etc.
19:53:27 <araujo> TomMD, nice, thanks :)
19:53:37 <fynn> mmorrow: cool, but why did you link House in this discussion?
19:53:54 <pumpkin> maxote: and arrays with a functional interface... hashtables can be used (slowly) through IO, but they're not pretty common
19:54:00 <wli> maxote: I forget if there's any distinction between a hashmap and a hashtable.
19:54:27 <wli> pumpkin: The slowness is lack of card marking vs. GC.
19:54:29 <pumpkin> it seems like there shouldn't be
19:54:37 <pumpkin> wli: yeah, I've been following the discussion about it
19:54:39 <maxote> wli, assume similar
19:54:57 <mmorrow> fynn: because it's an example of an OS whose rts is running underneath it on "the metal"
19:55:09 <pumpkin> maxote: but people typically just use "hash" or "hashtable" to mean associative array or map, and we have the latter
19:55:09 <mmorrow> fynn: and the rts is in C
19:55:37 <wli> Just make a flexible array structure whose maximum branching factor of a primitive array type is low enough to prevent GC pathologies.
19:55:51 <pumpkin> wli: do it and we'll love you long time
19:56:00 <TomMD> mmorrow: But Kennys work on Lighthouse is to bring the smaller RTS design done by Peng Li to House.
19:56:10 <TomMD> mmorrow: Still C, but less of it.
19:56:21 <mmorrow> TomMD: that sounds interesting
19:56:45 <wli> pumpkin: Um... there's not a whole lot to it. It's for the most part just a radix tree.
19:56:58 <dons> maxote: haskell has regular mutable data structures too
19:57:03 <wli> How narrow of a branching factor do you need to avoid GC pathologies? 1024 at most?
19:57:11 <pumpkin> wli: but everyone wants a true hashtable :P or people will hate us for not having one (and blog about haskell being slow/stupid)
19:57:13 <TomMD> mmorrow: If you haven't seen Peng Li's RTS paper in which he handles most concurrency issues via STM primitives then you should take a look.
19:57:22 <maxote> dons, mutable? in purely functional?
19:57:25 <monochrom> lookup is no more about hashing than photocopying is about xerox
19:57:40 <dons> maxote: using monads to sequence the mutation
19:58:05 <mmorrow> TomMD: i haven't and will (although i admit my initial impression is skeptical judging by the performance of STM in haskell (vs. just MVars and "going it yourself"))
19:58:24 <dolio> I need some Band-Aids and Kleenex.
19:58:42 <mmorrow> dolio: scalpel!
19:58:52 <pejo> mmorrow, there's still room for improvement of the STM implementation in GHC. (Not saying that it's the right tool for all problems).
19:59:02 <maxote> i need to remember the SML lessons of using references to mutable structures
19:59:02 <TomMD> mmorrow: The off the cuff estimate I got from SimonM was 10x performance decrease with perhaps 2x possible if you optimize and preferrably have hardware support.
19:59:19 <liyang> dolio, mmorrow: A chance to cut is a chance to cure.
19:59:20 <mmorrow> pejo: that's nice to hear (i don't really know anything about the implem at this point)
20:00:05 <mmorrow> TomMD: 2x sounds nice. i wonder if there's anything stopping (approaching) 1x
20:00:19 <wli> pumpkin: I think it boils down to an ST/IO -based IntMap
20:00:21 <mmorrow> liyang: cutter!
20:00:31 <pumpkin> ah
20:00:33 <liyang> mmorrow: funding, mostly, I imagine.
20:00:41 <liyang> mmorrow: no, Matmos.
20:01:12 * araujo still a credulous boy who believes in using a Haskell OS someday
20:01:13 <mmorrow> liyang: ah
20:01:28 <ddarius> araujo: It ain't going to happen.
20:01:41 <TomMD> mmorrow, liyang: Well, with STM you have compares and retries that would otherwise be unncessary (or handled in different ways) so I wouldn't expect performance to fully compete - perhaps be acceptable.
20:02:13 <TomMD> araujo: Last time I said that someone asked me what a 'Haskell OS' means to me - so now I'm asking you.
20:02:16 <wli> pumpkkin: Then you do a radix tree with a fixed number of levels, maybe some path compression, and maybe even node compression by hashing via open addressing...
20:02:23 <TomMD> araujo: What does a 'Haskell OS' mean to you?
20:03:03 <araujo> TomMD, Pretty much ... a Haskell 'kernel'
20:03:21 <araujo> written (mainly) in Haskell
20:03:40 <TomMD> araujo: So if someone were to produce a Haskell L4, mix of Haskell and C systems services, and perhaps haskell init setup you'd be pretty happy?
20:04:09 <araujo> TomMD, and that for example.. I could write device drivers in Haskell, and access the OS syscalls through Haskell
20:04:12 <araujo> quite happy
20:04:13 <liyang> TomMD: on the other hand, there's no `acceptable' levels of *correctness*. ;)
20:04:14 <araujo> :)
20:04:22 <shapr> @quote araujo
20:04:23 <lambdabot> araujo says: [Ontolog] araujo: if you like Haskell so much why don't you marry it?! [araujo] Ontolog, I am .... internally .... i am
20:04:31 <araujo> shapr!!!!
20:04:33 <TomMD> araujo: So then you want a HaLVM like compiler for your haskell kernel.
20:04:40 <shapr> hi araujo!
20:04:46 <araujo> shapr, how it goes? :)
20:04:49 <shapr> Wait, is HaLVM released?
20:04:56 <TomMD> shapr: No
20:05:07 <shapr> Oh, where'd you hear about it?
20:05:20 <TomMD> All over - but Andrew Tolmach has some good slides on the internet.
20:05:23 <shapr> Ah
20:05:25 <shapr> ok then
20:05:30 <wli> pumpkin: The vague idea here being that you try to nuke big swaths of empty pointers whenever possible.
20:05:33 <TomMD> Why - you seen it?
20:05:36 <TomMD> shapr
20:05:39 <w0rth> what's wrong with this:
20:05:41 <w0rth> satisfy p = do x <- item
20:05:41 <w0rth>                if p x then
20:05:41 <w0rth>                    return x
20:05:44 <w0rth>                else
20:05:47 <w0rth>                    fail
20:05:51 <w0rth>  
20:05:57 <TomMD> w0rth: The else and then should be lined up.
20:06:01 <shapr> TomMD: I think I signed an NDA.
20:06:02 <liyang> TomMD: also, there's the matter of hardware assistance for STM. Given infinite funding I'm sure I can set up a fab and pump out a few designs.
20:06:07 <w0rth> TomMD: thanks
20:06:15 <TomMD> @type fail
20:06:17 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
20:06:19 <w0rth> TomMD: can you show me how it's normally formatted?
20:06:24 <TomMD> w0rth: and fail needs a string.
20:06:25 <shapr> liyang: Isn't there some hardware assist TM?
20:06:32 <TomMD> shapr: Damn those things.
20:06:48 <liyang> shapr: Sun has something, IIRC. Or was it IBM...
20:06:51 <w0rth> TomMD: well i defined fail
20:06:54 <wli> pumpkin: Arranging the upper and lower load thresholds appropriately on open-addressed hashtables and path compression do so quite effectively.
20:06:56 <wli> Sun
20:06:57 <shapr> I know I signed an NDA, but I don't remember exactly whether it covered what I know about HaLVM, or when it expires :-/
20:07:23 <TomMD> shapr: Who did you sign the NDA with?  I hope that isn't covered by NDA.
20:07:31 <pumpkin> wli: yeah
20:07:32 <shapr> I signed an NDA with Galois.
20:07:38 <TomMD> ahh, figures.
20:07:54 <TomMD> shapr: So you live in Portland?
20:08:02 <shapr> Nope, only visited once.
20:08:44 <shapr> I live in Boston at the moment, and lived in Birmingham AL when I signed the NDA.
20:08:47 <wli> I'm stranded away from home for an extended period of time. I'll be back in Portland soon.
20:08:54 <w0rth> Argh, this still doesn't work:
20:08:55 <w0rth>                if p x
20:08:55 <w0rth>                then
20:08:55 <w0rth>                    return x
20:08:58 <w0rth>                else
20:08:59 <fynn> shapr: why did you sign it?
20:09:02 <w0rth>                    fail
20:09:05 <w0rth>  
20:09:10 <fynn> w0rth: do use a pastebin.
20:09:11 <shapr> fynn: I was going to do some contract work for them.
20:09:12 <TomMD> w0rth: the then and else should be indented more than 'if'.
20:09:16 <liyang> (Herlihy and Moss, 1993 sketched a multicore hardware-assisted TM implementation based around existing cache-coherency protocols.)
20:09:19 <rovar> i'm trying to install Timber, it's asking for binary >= 0.4.2, which I'm pretty sure I have.
20:09:21 <w0rth> fynn: link?
20:09:25 <TomMD> @where paste
20:09:26 <lambdabot> http://hpaste.org/new
20:09:29 <w0rth> thanks
20:09:37 <w0rth> TomMD: why won't haskell-mode do that/
20:09:37 <koninkje> w0rth: the entire if...then...else is a single expression, and wherever you put the line breaks all lines after the first must be more indented than the "if"
20:09:45 <TomMD> w0rth: I don't use e-macs.
20:09:49 <liyang> w0rth: fail takes a string argument.
20:09:54 <w0rth> TomMD: what do you use?
20:10:01 <TomMD> w0rth: vim
20:10:02 <pejo> rovar, what does ghc-pkg list say for you? Are you using cabal-install?
20:10:03 <w0rth> liyang: I defined my own fail
20:10:17 <wli> nvi here
20:10:22 <TomMD> w0rth: I think that should be part of your name "w0rth - I define fail"
20:10:24 <liyang> w0rth: oh dear. That is confusing.
20:10:34 <rovar> pejo, binary-0.4.4, binary-0.5.0.1,
20:10:51 <w0rth> TomMD: har har
20:10:53 <rovar> both of which qualify, I would surmise. I'm attempting to install from the tarball
20:11:04 <rovar> using runhaskel Setup.lhs configure
20:11:24 <pejo> rovar, is binary installed globally?
20:11:42 <rovar> should be in my home dir
20:12:12 <rovar> yea. .both versions are under home
20:12:39 <w0rth> @paste
20:12:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:13:03 <shapr> @hpaste
20:13:03 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:13:04 <pejo> rovar, you probably need --user after configure, since global packages can't see your user packages. (Or install binary globally).
20:14:36 <shapr> @quote pejo
20:14:36 <lambdabot> No quotes match. My pet ferret can type better than you!
20:14:38 <shapr> aww
20:14:40 <shapr> @quote wli
20:14:41 <lambdabot> wli says: My solution is to stop reading haskell.org
20:14:46 <shapr> @quote fynn
20:14:46 <lambdabot> No quotes match. My mind is going. I can feel it.
20:14:48 <shapr> hmm
20:15:41 <pejo> shapr, I haven't said anything thoughtful yet, but I'm working on it.
20:15:58 <shapr> heh
20:16:06 <shapr> @remember pejo shapr, I haven't said anything thoughtful yet, but I'm working on it.
20:16:06 <lambdabot> Okay.
20:16:38 <w0rth> @quote TomMD
20:16:39 <lambdabot> TomMD says: Never trust IO
20:16:52 <chrisdone> shapr: coi pei
20:17:14 <shapr> coi chrisdone .i ma nuzba
20:17:50 <rovar> pejo, any idea what copyFile is and where the installer should find it?
20:18:28 <shapr> doi chrisdone komodo
20:18:30 <ddarius> @quote shapr
20:18:31 <lambdabot> shapr says: I think the Haskell approach works fine. That is, stick with research and do the best you can. Then after fifteen years of gestation, take over the world.
20:18:50 <araujo> @quote shapr
20:18:50 <lambdabot> shapr says: <shapr> Yeah, it does require more than an oleg of type-hackery. <poetix> oleg's now a unit? <autrijus> is oleg an unit now? <shapr> Yup, a rather large unit of type-hackery too.
20:18:58 <shapr> wah
20:19:01 <araujo> hah
20:19:04 <shapr> haha
20:19:05 <ddarius> Academics, always busting their deadlines or leaving half-finished projects.
20:19:43 <rovar> ddarius: the goal is not to implement, but prove that you can implement :)
20:19:44 <pejo> rovar, what version of ghc/cabal are you using?
20:19:59 <rovar> 6.10.1
20:20:10 <rovar> 1.6.0.2
20:20:35 <chrisdone> doi shapr mi cliva le lojbo gi'e co'u jundi ja selcinri ui nai ru'e a'u cu'i bu'o ru'e
20:21:00 <ddarius> They're doing it again...
20:22:49 <ddarius> Lojban has a minimal vocabulary because the only thing people talk about in lojban is talking in lojban.
20:23:02 <Marco___> Is there a type that encompasses all number (ie floats and Integers)
20:23:12 <ddarius> Not a useful one.
20:23:29 <chrisdone> ddarius: that's exactly what I just said in lojban to shapr
20:23:34 <pejo> rovar, it's supposed to be in the System.Directory module. What OS are you on?
20:23:39 <chrisdone> thus re-enforcing the point
20:23:46 <wli> I think I've backslid and Chakravarty's paper is now totally intelligible to me again where at some point I thought I understood something.
20:23:52 <rovar> pejo, heres' the funny part:
20:23:54 <rovar> Setup.lhs: dist/build/timberc/timberc: copyFile: does not exist (No such file or directory)
20:24:16 <rovar> ah.. is that saying that it's a copyFile error?
20:24:18 <Marco___> ddarius: so if I want a function that works on both Integers and Doubles, I have to write two functions?
20:24:28 <rovar> i just noticed the 2nd :
20:24:30 <bd_> Marco___: No, just make it polymorphic
20:24:37 <Marco___> okay
20:24:44 <wli> Marco__: Num t => t -> t
20:24:47 <dolio> It depends what exactly you mean by that.
20:24:47 <pejo> rovar, did your build step finish without errors?
20:25:27 <rovar> i thought so, will clean and rerun
20:26:42 <rovar> on a side topic, can someone point me to the haskell tutorial which doesn't actually cover haskell but cabal, hackage, and the rest of the toolchain?
20:27:42 <dons> RWH talks about that. (it's online)
20:27:48 <pejo> rovar, http://www.haskell.org/cabal/ has a quite good manual for cabal.
20:29:16 * ddarius wonders if people would read more documentation/manuals if we just posted the pieces as a series of blog articles (mind you, I'm not saying to change the style just the format)
20:29:20 <pejo> rovar, there isn't much error checking in the Setup.lhs for timberc, which is the reason for the strange error message you're getting.
20:29:37 <rovar> pejo, gotcha.. it installed correctly this time.
20:29:42 <rovar> I just compiled Primes.t
20:30:19 <dons> ddarius: making them more web friendly would help, at least.
20:30:46 <rovar> what is Primes.t supposed to do?
20:31:00 <pejo> rovar, any idea what steps you took to end up with the strange error message?
20:31:30 <rovar> pejo, inadvertently skipped the build step
20:32:17 <rovar> if you skip straight to install.. it tells you to run config, however, after running config, it will let you run install without build
20:32:25 <mmorrow> pumpkin: have/do you ever used R?
20:32:30 <pejo> rovar, print out the number of primes between 3 and the argument given to it.
20:32:32 <rovar> imo, install should  run configure/build/install
20:32:41 <pumpkin> mmorrow: nope, it's high on my todo list though
20:32:59 <mmorrow> pumpkin: the graphics are sweet, and it's like matlab for stats
20:33:05 <rovar> pejo, that's what I thought, however, there aren't 4 primes between 3 and 10 :)
20:33:18 <pumpkin> mmorrow: ...but does it have a pretty UI on mac os? :D
20:33:19 <mmorrow> pumpkin: there's a bunch of C code that could be ffi'ed too in there
20:33:29 <Eridius> pumpkin: actually yeah
20:33:33 <mmorrow> pumpkin: the graphics just output to pdf,png,X,blah
20:33:44 <mmorrow> pumpkin: oh, looks like it does :)
20:33:50 <pumpkin> :o
20:33:51 <Eridius> mmorrow: R.app can render graphics inside a quartz window
20:33:58 * ddarius doesn't see how a series of blog articles would be friendly at all.
20:34:05 <mmorrow> Eridius: interesting, i've only used it on linux
20:34:07 <Eridius> pumpkin: `port info R`
20:34:37 <Eridius> there's even a TextMate bundle for writing R code
20:34:38 <pejo> rovar, ok, print out the number of primes below the argument then. :-)
20:34:44 <pumpkin> nice
20:34:46 <pumpkin> speaking of textmate bundles
20:34:57 <pumpkin> has anyone heard from ozy` or anyone else who was working on the haskell bundle?
20:35:01 <mmorrow> (the C code being related to computational stats)
20:35:10 <pumpkin> I'd like to add some stuff to it
20:35:26 <Eridius> if you want to see something scary, I wrote a ridiculous function in R that generates a TextMate snippet for the function signature of an R function: http://github.com/kballard/textmate-bundles/blob/aca5ee2ef96689b23a64b648afb13730da6f2b8b/Bundles/R.tmbundle/Support/getSig.R
20:35:42 <pumpkin> :o
20:35:45 <mmorrow> hehe
20:36:24 <chrisdone> github<unicode-heart>
20:36:31 <pumpkin> :)
20:37:07 <pumpkin> Eridius: you do iphone work?
20:37:15 <Eridius> ❤
20:37:16 <rovar> pejo, that's still not correct, ya?  either way, i see this checkFrom 3..   something in the algorithm must be funky, but I can't see what it  is
20:37:17 <Eridius> pumpkin: yes I do
20:37:30 <Eridius> pumpkin: iPhone is what I've been working with for the past half-year
20:37:43 <mmorrow> (as a demo of some cool R graphics) here's (part of) some random R i wrote to generate this http://code.haskell.org/~morrow/code/R/territories.gif (and individual full-sized versions) for this insurance company http://code.haskell.org/~morrow/code/R/
20:37:43 <dons> ddarius isn't sure about the whole interweb thing
20:37:46 <pumpkin> Eridius: cool :) I suppose you don't touch jailbreak, given your non-jb emoji project :P
20:37:55 <pejo> rovar, 2, 3, 5, 7?
20:38:10 <ddarius> dons: 'seems to have more costs than benefits...
20:38:19 <Eridius> pumpkin: I jailbroke before the AppStore came out, but after I saw no point
20:38:40 * Eridius wants to test if the non-jb emoji project still works on 3.0, but he doesn't want to accidentally turn off emoji if he can't turn it back on..
20:38:52 <pumpkin> Eridius: ah :) I'm one of the jailbreak devs
20:38:59 <rovar> i always forget 5.. in either case, it shouldn't be counting 2
20:39:01 <Eridius> heh
20:39:10 <dons> we should go back to publishing manuals as .ps.Z
20:39:21 * Eridius just had his first self-published iPhone app released today: http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=305441017&mt=8
20:39:24 <dons> good enough for Wadler, good enough for me.
20:39:31 <pumpkin> cool
20:39:32 <ddarius> dons: We should go back to publishing manuals.  You have a (hard) copy of the Report, no?
20:39:34 <mmorrow> screw that. .txt
20:39:43 <dons> oh good idea.
20:40:06 <dons> yes. send 5 pounds to glasgow, with a self addressed envelope
20:40:23 <rovar> oh, nevermind
20:41:04 <pumpkin> Eridius: congrats
20:41:12 <Eridius> thanks
20:41:17 <dons> ddarius: http://groups.google.com/group/comp.lang.functional/msg/a5cc6ac1df70e358?hl=en&
20:41:46 <pumpkin> wow, that's a while ago
20:41:51 <dons> Sending 5 pounds to: The Haskell Project. Department of Computing Science University of Glasgow .
20:42:16 <dons> The .tar file contains the source document in Unix tape archive
20:42:16 <dons> format; alternatively the .dvi or .ps files may be used for printing
20:42:16 <dons> only
20:42:26 <Eridius> screw money, let's go back to the barter system. Send 1 pig or 2 sheep to: The Haskell Project.
20:43:20 <pumpkin> why is a pig worth more than a sheep?
20:43:25 <dons> "The FTP instructions sent on Monday seem to have confused some people
20:43:25 <dons> in the UK."
20:43:29 * wli attempts to translate the monad typeclass into higher-order modules to get an idea of what these things look like.
20:43:39 <Eridius> pumpkin: pork is yummy
20:43:40 <ddarius> http://www.amazon.com/Haskell-98-Language-Libraries-Revised/dp/0521826144/ref=sr_1_1?ie=UTF8&s=books&qid=1239421383&sr=8-1  I think I'll pay the five pounds.
20:43:49 <flippo> How about a box of personally harvested and waxed dental floss?
20:43:59 <Eridius> how do you harvest floss?
20:44:05 <rovar> flippo: used or unused?
20:44:05 <sm> dons: that's very cool :)
20:44:07 <dons> Wadler's back at Glasgow. I bet the mail makes it to him ...
20:44:08 <mmorrow> i think it grows as a small bush
20:44:19 <sm> boy, a lot of work under the bridge
20:44:20 <flippo> rovar, the rodents left it alone most of the time
20:44:33 <dons> whoa, that's a ridiculous price for the report.
20:44:41 <wli> mmorrow: Arbustico?
20:44:52 <Eridius> that's the Amazon Marketplace for you. One dude has it listed at a silly price
20:45:00 <mmorrow> wli: is that a kind of dental-floss bush?
20:45:29 <mmorrow> ahh, yeah i think that one's native to southern chile
20:45:37 <wli> mmorrow: Arbusto == Bush (e.g. the name of one of W.'s oil co.'s), -ico == "little"
20:45:47 <mmorrow> ahhh :)
20:46:06 <Nafai> So what's GRIN?  I'm reading the latest LHC blog post.
20:46:46 <chrisdone> GNU Revolutionary Indoctrination Network
20:46:53 <pumpkin> wli: you speak italian?
20:47:08 <Nafai> chrisdone: Ha!
20:47:11 <Marco___> Could someone help me out as to why this (only four lines) doesn't work: http://haskell.pastebin.com/m4afbf85
20:47:18 <Marco___> if I remove the type signature, it does work
20:47:19 <Lemmih> Nafai: Graph Reduction Intermediate Notation.
20:47:22 <dons> http://www.cs.chalmers.se/~boquist/ifl96-abstract.html
20:47:39 <pumpkin> Marco___: you need (Eq a) =>
20:47:48 <pumpkin> Marco___: the error probably told you that too :)
20:48:04 <Marco___> ya, it does.  But I'm not sure what (Eq a) means
20:48:08 <Lemmih> Nafai: It's a subset of C--. It's a language specially designed for modelling lazy, functional languages.
20:48:17 <Marco___> I know it means that a is of type Eq, but what is type Eq
20:48:30 <pumpkin> Marco___: it's basically saying "if you want to check whether two lists are equal, it must be possible to check if their elements are equal
20:48:32 <Nafai> Lemmih: Ah, thanks for the explanation.  I didn't realize a subset of C-- was used
20:48:56 <mmorrow> Lemmih: i dunno if i'd call it a subset of C--
20:48:56 <Eridius> Marco___: Eq is a typeclass
20:49:12 <mmorrow> Lemmih: in what sense do you mean?
20:49:13 <Lemmih> Nafai: It's a subset of C-- only in sense of its features.
20:49:34 <pumpkin> Marco___: somewhere in the haskell standard libraries is something saying if you want to use == on a list of a elements, you need to have Eq on the elements themselves
20:49:35 <mmorrow> ah, ok
20:49:47 <pumpkin> Marco___: which should make sense
20:49:55 <Marco___> that makes sense
20:50:15 <dons> Lemmih: so you've definitely concluded against LLVM?
20:50:15 <Marco___> the book I'm using Real World Haskell hasn't really covered that yet.  Thanks for the pointer
20:50:30 <dons> or are you thinking still GHC -> Core -> GRIN -> LLVM?
20:50:34 <Nafai> Lemmih: So you're on the LHC team? :)
20:50:54 <dons> Lemmih is BDFL of LHC :)
20:51:00 <Nafai> Sweet
20:51:37 <Lemmih> dons: Yes, an LLVM backend is still the plan. Just because LLVM sucks doesn't mean that there is anything better (:
20:51:51 <dons> right. plus you get free coolness points
20:52:24 <Eridius> LLVM sucks? That's the first time I've heard anyone say that
20:52:49 <Nafai> dons: Do you know if you London HUG talk will be / has been recorded?
20:52:55 <dons> you should blog the structure of the compiler as an image. a la, http://hackage.haskell.org/trac/ghc/attachment/wiki/Commentary/Compiler/HscPipe/HscPipe.png
20:53:03 <dons> Nafai: i don't know.
20:53:06 <Nafai> (it's not obvious from the announcement when it is)
20:53:12 <dons> i think it has been in the past.
20:53:19 <Nafai> cool
20:53:28 <Nafai> because it sounds like something interesting to hear
20:53:33 <Lemmih> Eridius: Well, it's not too bad. It just less than perfect.
20:53:57 <Eridius> perfect? nothing's perfect
20:54:02 <mmorrow> Eridius: it's not designed from the ground up to support functional languages, and who would ever want to touch c++?
20:54:11 <Eridius> I don't know, but Obj-C is useful
20:54:13 <mmorrow> :)
20:54:29 <Lemmih> Nafai: It wasn't recorded, I'm afraid.
20:56:06 <mmorrow> Eridius: (i meant in the sense that LLVM is written in C++)
20:56:31 <Eridius> ah
20:56:34 <mmorrow> :)
20:59:54 <Lemmih> dons: I wish I was better at making pretty graphs.
21:00:27 <mmorrow> Lemmih: read the graphviz dot manual pdf, and you'll be a pro
21:01:01 <mmorrow> http://graphviz.org/Documentation.php
21:01:12 <Lemmih> Can graphviz make diagrams as well?
21:01:25 <mmorrow> it can do all kinds of crap
21:01:43 <dons> Lemmih: inkscape?
21:01:44 <mmorrow> hmm, if your diagram is in some sense a graph
21:02:14 <mmorrow> Lemmih: like that one "the big picture" diagram for jhc is graphviz iirc
21:04:42 * Lemmih adds it to his TODO list and heads to bed.
21:06:52 <dons> Lemmih: http://galois.com/~dons/images/drawing.svg   (inkscapke :)
21:07:20 <harovali> hi, is it possible in a lambda to write this (\m -> head m) in a pattern match like (\[h:xs] -> h ) ?
21:07:32 <mmorrow> Lemmih, dons: http://graphviz.org/Gallery/directed/cluster.html
21:07:50 <dons> cute
21:07:51 <dons> harovali: ?
21:07:58 <dons> > (\m -> head m) "haskell"
21:07:59 <lambdabot>   'h'
21:08:42 <harovali> > (\[h:xs] -> h) "haskell"
21:08:43 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Char'
21:09:05 <Eridius> dons: the MIME type on that thing must be off. The XML plugin I have installed rendered that as XML instead of Safari rendering it as an SVG image
21:09:08 <harovali> why not?
21:09:20 <Eridius> yeah it was returned as text/xml
21:10:38 <dons> who knows what safari does with .svg
21:11:05 <Eridius> normally it renders it
21:11:13 <Eridius> but I have a plugin that renders XML nicely
21:11:31 <pumpkin> #webkit
21:11:35 <Eridius> Safari probably has heuristics to detect SVG in text/xml content, but the XML plugin is intercepting it first
21:11:46 <Eridius> pumpkin: it's a third-party plugin
21:11:49 <harovali> dons: why doesn't the second version work?
21:11:55 <pumpkin> Eridius: the .svg isn't
21:12:09 <Eridius> pumpkin: no, but SVG is supposed to be served with image/svg+xml
21:12:11 <pumpkin> webkit natively deals with svg
21:12:15 <pumpkin> ah
21:12:15 <dons> harovali: ah, (:)
21:12:24 <dons> > (\(x:_) -> x) "haskell"
21:12:26 <lambdabot>   'h'
21:12:33 <dons> you're matching the list constructor (:)
21:12:36 <Eridius> again, I assume Safari has heuristics to detect if a text/xml document is SVG anyway, but the XML plugin is taking over the text/xml handling and so those heuristics are never run
21:12:37 <dons> not the list syntax [,,,]
21:12:59 <harovali> dons: thanks !
21:13:09 <Eridius> dons: you should be serving up .svg files as image/svg+xml
21:13:20 <dons> ah could be the issue.
21:13:21 <Eridius> or actually just image/svg is fine
21:13:27 <kerlo> Yeah, "haskell" is ('h':"askell"), not ['h':"askell"].
21:13:44 <Eridius> well no, the original docs say image/svg, but a support.adobe.com issue says in 2000 it was changed to image/svg+xml
21:14:08 <Eridius> yeah SVG 1.0 was image/svg, SVG 1.1 is image/svg+xml
21:14:10 <Eridius> http://www.w3.org/TR/SVG11/intro.html#MIMEType
21:14:28 <dons> so it's apache's fault?
21:14:41 <Eridius> dons: Apache doesn't set up MIME types for a lot of stuff
21:15:03 <Eridius> but it's pretty easy to add a rule that sets the proper MIME type. Of course, I don't know what that rule is
21:15:20 <Eridius> or maybe Apache does normally handle SVG, but since you have a comment in there above the <svg> tag its heuristics are wrong?
21:15:24 * Eridius is just guessing here
21:15:53 <dons> works in firefox, fwiw
21:16:08 <Eridius> firefox's XML rendering is built-in, it probably includes the SVG detection heuristics
21:16:48 <dons> i mean, it has a big blinking <svg> tag straight after <xml> :)
21:17:40 <dons> so it is interesting safari realised it was xml, but then didn't do anything to read the <svg> tag
21:17:42 <Eridius> dons: it has a <!-- comment --> first
21:17:51 <dons> let me remove that, and we can try again
21:18:00 <Eridius> dons: safari detects the text/xml MIME type and looks for handlers. The XML plugin is registered as handling that, so it's given the document
21:18:13 <Eridius> I would assume that if there's no XML handler, Safari then employs heuristics to detect that it's SVG and render it
21:18:19 <dons> http://galois.com/~dons/images/drawing-xml.svg
21:18:33 <Eridius> hmm, nope
21:18:59 * Eridius removes the plugin
21:19:08 <Eridius> yeah Safari properly detects that it's SVG without the plugin
21:19:38 <Eridius> so it's like I thought. WebKit's built-in handling of XML detects SVG, but if a plugin registers to handle text/xml it's given priority
21:22:22 * Eridius removes the plugin entirely, it's just easier this way
21:23:11 <Elly> what's the most convenient way to find module documentation?
21:23:18 * pumpkin just googles for it
21:23:26 <Eridius> I use hoogle on the package name
21:23:30 <ivanm> @doc Module
21:23:31 <lambdabot> Module not available
21:23:37 <ivanm> @doc Data.Map
21:23:37 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
21:23:45 <pumpkin> except it fails
21:23:49 <ivanm> ^^ note that this fails for containers, arrays, etc. after base was split
21:23:56 <ivanm> pumpkin: yeah :(
21:23:56 <Elly> :(
21:24:14 <pumpkin> maybe I'll take some time and build docs for all packages in hackage and GHC, with source links
21:24:23 <pumpkin> it's a real pain that some have source links and others done
21:24:24 <pumpkin> don't
21:24:42 <ivanm> pumpkin: you have to enable hscolour support in haddock IIRC
21:24:48 <pumpkin> yeah
21:24:52 <ivanm> igel did some packages for the gentoo ebuilds...
21:24:59 <Elly> if I have a record type, is there a way to update it?
21:25:15 <ivanm> what I _really_ want is some central index automatically updated by haddock which lists all installed modules, etc.
21:25:24 <ivanm> Elly: you mean add extra fields?
21:25:25 <pumpkin> Elly: yup, old { field = newFieldValue }
21:25:57 <Elly> ivanm: no, I mean change the value of an old field
21:25:59 <Elly> pumpkin: that works? :D
21:26:07 <ivanm> yeah
21:26:11 <ivanm> that's the only way of doing it
21:26:20 <pumpkin> Elly: it gives you a new record with the field updated, obviously
21:26:28 <pumpkin> the rest is unchanged, a bit like first/second on tuples
21:26:32 <ivanm> which many people find annoying and bitch about endlessly
21:26:38 * pumpkin bitches about it endlessly
21:26:46 <pumpkin> @quote record syntax
21:26:46 <lambdabot> No quotes for this person. This mission is too important for me to allow you to jeopardize it.
21:26:46 <ivanm> see? I was right!
21:26:48 <ivanm> ;-)
21:26:51 <ivanm> @quote record
21:26:51 <lambdabot> ozone says: dons: hey, i have a 100% track record for "things i started in haskell and other people implemented" so far ;)
21:26:56 <pumpkin> @quote record
21:26:56 <lambdabot> ghc says: Empty record update
21:26:59 <pumpkin> :(
21:26:59 <Eridius> ivanm: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
21:27:01 <pumpkin> @quote record
21:27:02 <lambdabot> ozone says: dons: hey, i have a 100% track record for "things i started in haskell and other people implemented" so far ;)
21:27:06 <pumpkin> @quote pumpkin
21:27:06 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
21:27:11 <pumpkin> bah
21:27:22 <lament> @quote syntax
21:27:22 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
21:27:29 * pumpkin fails
21:27:36 <Eridius> @quote fail
21:27:37 <lambdabot> ghc says: Unexpected kind unification failure
21:27:57 <harovali> is there something I can type in ghci that gives me the source of a function ?
21:28:04 <Eridius> no but lambdabot can often help you
21:28:10 <ivanm> holzplatten: :info will give it if it's _your_ source
21:28:25 <harovali> Eridius: thanks
21:28:31 <pumpkin> how hard is it to build haddock for a package without building the package itself?
21:28:34 <ivanm> or else GOA integrated lambdabot into ghci, but I don't know if dons has kept updating it and even back then it didn't work properly :s
21:28:37 <harovali> ivanm: thanks
21:28:47 <ivanm> pumpkin: cabal haddock?
21:28:56 <pumpkin> ivanm: ah, it's that simple, nice
21:29:06 <ivanm> Eridius: hmmm.... looks pretty complicated too me (data-accessor)
21:29:14 <ivanm> pumpkin: I think ;-)
21:29:15 <Eridius> ivanm: I think you can derive data accessors with the right extensions
21:29:19 <ivanm> I don't use cabal-install that much
21:29:20 <pumpkin> I'll try it out and see :)
21:29:30 <Eridius> there's also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor-template
21:29:43 <pumpkin> ivanm: how about the GHC docs? can I build those without building GHC?
21:29:58 <ivanm> nope
21:30:12 <ivanm> at least, I don't think so
21:30:22 <ivanm> it's Makefile might have a specific doc target or something though
21:30:48 <pumpkin> ah
21:32:25 <pumpkin> wow, that's annoying
21:32:34 <pumpkin> the archive.tar hackagedb sends you
21:32:42 <pumpkin> will unpack all the packages into the current dir
21:35:08 <altmattr> i think I am missing something
21:35:22 <altmattr> in ghci, when I need to use functions from multiple modules
21:35:29 <altmattr> i need to :l X Y X
21:35:44 <altmattr> then :m + the ones that it loaded but are not current
21:35:50 <altmattr> (all but last?)
21:35:56 <altmattr> it is a real pain
21:36:00 <dons> pumpkin: yeah, i'm thinking we should have a 'latest of everything .tar.gz' only
21:36:00 <altmattr> is there a better way?
21:36:21 <pumpkin> dons: that would be nice
21:36:51 <dons> so did we get an .svg of the haskell logo yet?
21:38:13 <dons> http://evenmere.org/~bts/haskell-logo/potrace/logo7.svg
21:45:28 <pumpkin> how do I ask haddock to generate source links?
21:50:20 <dancor> sjanssen: lol why did you add notepad to ++ blacklist
21:51:01 <dancor> oh it's an actually editor
21:51:05 <dancor> s/ly/
21:55:13 <Gracenotes> > (\(x :: forall a. Num a => a) -> x) (3 :: Int)
21:55:14 <lambdabot>   Couldn't match expected type `a' against inferred type `Int'
21:55:21 <Gracenotes> > (\(x :: forall a. Num a => a) -> x) 3
21:55:23 <lambdabot>   3
21:55:25 <Gracenotes> :X
21:55:55 <Gracenotes> mak no sanse.
21:56:22 <Gracenotes> foralls are a bit tricky, re. escaping and all... :3
21:57:06 <Gracenotes> although, the entire expression can be ::Int'd
21:57:42 <harovali> i'd like to write a function that takes a list and does something n times, being n the length of the list. What can I use to iterate?
21:57:51 <dons> http://galois.com/~dons/images/logos/logo-bezier.svg
21:58:21 <Eridius> harovali: define "does something"
21:58:36 <dolio> That signature says that x must have type forall a. Num a => a. But Int is not that type.
21:58:36 <Gracenotes> does something to the individual elements n times?
21:58:59 <Nafai> sounds like map :)
21:59:17 <harovali> Eridius: calls a function of mine, and composes a list of each result
21:59:27 <Eridius> harovali: does your function accept the type of the list's element?
21:59:48 <Gracenotes> so map. Then.. the function's being applied n times to what?
22:00:16 <harovali> nombres q xs = foldl (++) "_" $ map  (takeT q ) xs
22:00:27 <harovali> is the function whose results i'd like to collect
22:00:30 <harovali> in alist
22:00:46 <harovali> given a "cycled" call of xs each time
22:00:59 <harovali> as many times as length xs
22:01:04 <Eridius> harovali: you almost certainly want to use foldr (:) '_'
22:01:25 <Gracenotes> or even foldr (++)
22:02:03 <scutigera> foldr' ?
22:02:13 <Eridius> ok foldr (:) '_' is the wrong arguments, but whatever, my meaning should be clear ;)
22:02:16 <Gracenotes> soldr1'
22:02:42 <Eridius> ('_':) . foldr (:) ""
22:02:58 <jmcarthur> '_' is an awesome smiley
22:03:16 <Eridius> <('.'<)
22:03:21 <Gracenotes> <(^.^<)
22:03:27 <Eridius> ah yes ^ is what I wanted
22:03:30 <Gracenotes> (>^.^)>
22:03:33 <Eridius> that should be valid syntax
22:03:42 <jmcarthur> (^")>
22:10:08 <erlanguid> hey, new to haskell here :D what order does the function application take place here myFoldl f z xs = foldr step id xs z
22:10:09 <erlanguid>     where step x g a = g (f a x)
22:10:18 <erlanguid> sorry
22:10:22 <erlanguid> myFoldl f z xs = foldr step id xs z
22:10:22 <erlanguid>     where step x g a = g (f a x)
22:10:37 <erlanguid> (foldr step id xs) z     ?
22:11:11 <Eridius> step, id, xs, and z are all treated as separate arguments to foldr.
22:11:24 <Gracenotes> (((foldr step) id) xs) z .. function application happens to the left side
22:11:25 <Eridius> foldr itself only takes 3, so the z ends up being an argument to the result of the foldr
22:12:01 <erlanguid> Thanks guys
22:12:24 <Gracenotes> Eridius: sort of a complicated way to think of it. Really, foldr is a function; foldr step returns a function; foldr step id returns a function; foldr step id xs returns a function; foldr step id xs z isn't a function
22:12:29 * Eridius notes that Gracenotes's answer is a lot more accurate, I was handwaving over the currying stuff
22:13:04 <Eridius> Gracenotes: yes it's more complicated once you're used to functional programming, but from the rest of the world's perspective, foldr takes 3 arguments, and it would be clearer to write (foldr step id xs) z
22:13:23 <Eridius> which would make it more "obvious" that foldr consumes 3 arguments, and that its result must be a function that takes (at least) 1 argument
22:14:22 <Gracenotes> mm, right.
22:15:25 <Gracenotes> what's happening in that definition, erlanguid, is that you're folding over a normal list and your accumulator is a function. makes the types interesting, at least :)
22:15:43 <erlanguid> that it does
22:15:59 <erlanguid> its from Real World Haskell
22:16:11 <erlanguid> and it looked difficult so I'm trying to work my way through it
22:17:08 <Gracenotes> yeah. I gave up on it first time I went around, actually, although coming back it made more sense.
22:17:54 <erlanguid> your confirmation of the function application means I had at least one correct assumption :D
22:19:03 <Eridius> what it's doing is it's starting from the tail of the list and building up a bunch of partially-applied functions
22:19:10 <erlanguid> right
22:19:14 <erlanguid> I understand foldr
22:19:18 <Eridius> in the step definition, the g there is (except in the very first instance) actually the partially-applied step from the previous iteration
22:19:30 <erlanguid> ahh
22:19:42 <erlanguid> thats what was killing me
22:19:46 <Eridius> g is a function that takes an accumulator and returns a new accumulator
22:19:46 <erlanguid> the damned a
22:19:50 <Gracenotes> I'd use 'acc' for that, personally :\
22:19:56 <Eridius> yeah, so would I
22:20:06 <Eridius> the key observation here is step takes one more argument than foldr gives it
22:20:16 <Gracenotes> @type foldr
22:20:16 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:20:41 <erlanguid> At least I saw that
22:20:47 <Eridius> also, that foldr is given id, so you know that the accumulator is a function that takes one argument and returns one argument. Since step takes one extra argument, you can realize that the partially-applied step ends up being foldr's accumulator
22:21:09 <Gracenotes> @type fix
22:21:11 <lambdabot> forall a. (a -> a) -> a
22:21:15 <Eridius> and then when the z is passed in at the end, it evaluates all of the steps in "reverse" order
22:21:15 <Gracenotes> > fix (\f a ->if (a == 1) then 1 else a+f (a-1)) 10
22:21:17 <lambdabot>   55
22:21:23 <erlanguid> and you've lost me
22:21:29 <erlanguid> :P
22:21:46 <Eridius> it's building up a computation from the inside-out
22:21:46 <Gracenotes> heh. Well, note the type of fix. Yet I'm feeding two arguments into the function
22:21:50 <erlanguid> gimme a couple minutes to take in what you've given me
22:21:58 <Eridius> then passes in the accumulator when it's done which starts "unwrapping" the compuatation
22:22:05 <Eridius> Gracenotes: don't confuse him
22:22:31 <Eridius> of course the best part about fix is the source
22:22:32 <Eridius> @src fix
22:22:33 <lambdabot> fix f = let x = f x in x
22:22:35 <Gracenotes> It's not that confusing. it's possible because in "(a -> a) -> a", a is itself a function. So the type is just ((x -> y) -> (x -> y)) -> x -> y
22:23:05 <Gracenotes> "((x -> y) -> (x -> y)) -> x -> y" is equivalent to "((x -> y) -> x -> y) -> x -> y"
22:23:11 <Eridius> it is interesting to note that you can actually pass in first-order functions to fix
22:23:13 <Eridius> though it bottoms out
22:23:28 <jmcarthur> @unpl fix
22:23:28 <lambdabot> fix
22:23:32 <jmcarthur> bleh
22:23:36 <Gracenotes> you see, you can drop (or add) the last pair of parens to a type
22:23:39 <glguy> :t flip fix
22:23:40 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
22:23:42 <Gracenotes> partial application allows this
22:24:24 <glguy> > flip fix 5 $ \
22:24:25 <lambdabot>   <no location info>: parse error on input `;'
22:24:43 <glguy> > flip fix 5 $ \ rec i -> if i == 0 then 1 else i * rec (i-1)
22:24:45 <lambdabot>   120
22:24:52 <Gracenotes> > id negate 10
22:24:54 <lambdabot>   -10
22:25:01 <Gracenotes> @type id
22:25:02 <lambdabot> forall a. a -> a
22:25:32 <Gracenotes> in this case id takes a function and returns the identical function: ((x -> y) -> (x -> y)). the function is negate.
22:25:43 <erlanguid> the result of foldr, to my understanding looks like:   step x (step x (step x zero))
22:25:56 <erlanguid> thats correct isn't it?
22:26:14 <travisbrady> is there some way in ghci or otherwise to tell where something was imported from?
22:26:15 <Gracenotes> right
22:26:19 <Gracenotes> travisbrady: :i
22:26:34 <erlanguid> and in this case zero is id
22:26:47 <Eridius> erlanguid: yeah
22:26:53 <Gracenotes> > foldr f z [a, b, c]
22:26:55 <lambdabot>   f a (f b (f c z))
22:27:04 <Gracenotes> > foldr (+) z [a, b, c]
22:27:06 <lambdabot>   a + (b + (c + z))
22:27:12 <erlanguid> step x (step x (step x id))
22:27:24 <travisbrady> Gracenotes: thank you
22:27:25 <erlanguid> what does id evaluate to there
22:27:54 <Gracenotes> erlanguid: where?
22:27:58 <Eridius> erlanguid: look at the definition of step
22:28:10 <erlanguid> step x (step x (step x id)) z
22:28:14 <Eridius>  that internal step can be replaced with (\a -> id (f a x)), or just (\a -> f a x)
22:28:42 <Eridius> you should probably use something like step x1 (step x2 (step x3 id)) z to make it clear that the x's are different
22:28:56 <erlanguid> sorry, you're right
22:29:21 <erlanguid> so in the case of (step x3 id) where is it getting its 3rd argument from
22:29:30 <erlanguid> I mean I realize its z
22:29:38 <erlanguid> but the parens looks like walls to me
22:29:58 <erlanguid> is that the partial application?
22:30:00 <Eridius> ok, look at the definition of step
22:30:11 <Eridius> step x g a = g (f a x)
22:30:34 <erlanguid> Eridius: with you so far
22:30:54 <Eridius> so (step x3 id) effectively becomes (\a -> id (f a x3))
22:30:56 <Eridius> does that make sense?
22:31:48 <Eridius> then (step x2 (step x3 id)) is (\a -> (\a -> id (f a x3)) (f a x2)) (note that the a's are different here)
22:32:20 <erlanguid> and here is where haskell breaks with my knowledge of other languages because you can pass less arguments and the function becomes something else
22:32:22 <Eridius> so (f a x2) is evaluated to produce a new accumulator, which is passed into the (\a -> id (f a x3))
22:32:51 <erlanguid> whats the term for this
22:32:53 <Eridius> would it help if step were written as step x g = \a -> g (f a x)
22:33:00 <Gracenotes> Or just an overall type explanation. the type of foldr: (a -> b -> b) -> b -> [a] -> b. As I mentioned, the accumulator is just a function. So if we replace 'b' with a function type (c -> c), you get: (a -> (c -> c) -> c -> c) -> (c -> c) -> [a] -> c -> c. And that's the particular sort of foldr you're dealing with.
22:33:04 <Eridius> partial application?
22:33:23 <Gracenotes> so the type of 'step' is (a -> (c -> c) -> c -> c)
22:33:23 <Eridius> Gracenotes: you're operating at too high a level. All those -> are scary :P
22:33:31 <Gracenotes> the type of id is (c -> c)
22:33:39 * erlanguid agrees with Eridius
22:33:41 <erlanguid> :(
22:33:59 <Eridius> (c → c)
22:34:12 <Eridius> (a → (c → c) → c → c) → (c → c) → [a] → c → c
22:34:16 * Eridius cackles
22:34:18 <Gracenotes> well, just if you want the 'types' to make sense. Understanding what's going on type-wise is half the battle :P
22:34:29 <erlanguid> basically because your doing a partial application the function call gets turned another function with the single argument a
22:34:49 <erlanguid> \a -> g (f a x)
22:34:59 <Eridius> effectively, yes
22:35:02 <erlanguid> and then gets passed up the line until a can be evaluated
22:35:06 <erlanguid> in this case z
22:35:15 <Eridius> yes, z is used as the value of the outermost a
22:35:25 <Eridius> and then (f z x) is used in the next step
22:35:34 <Eridius> (f (f z x) x2)
22:35:41 <erlanguid> and gets passed on down through
22:35:43 <Eridius> and then the next step, (f (f (f z x) x2) x3)
22:35:55 <Eridius> and this should look familiar if you've read the docs for foldl
22:36:02 <erlanguid> the partial application piece was what I was missing
22:36:14 <erlanguid> basically what the result would be
22:36:20 <Eridius> erlanguid: when you see a type like a -> b -> c, it's really a -> (b -> c)
22:36:21 <Gracenotes> yes. it's covered later in the chapter, that's all :)
22:36:33 <Eridius> so every single function really takes a single argument, and can return a function
22:36:40 <erlanguid> I was looking at (step x id) and scratching my head
22:36:47 <erlanguid> right
22:37:02 <Eridius> when you see the id there, you know its type, so that should immediately tell you that the second argument to step is a function (a -> a)
22:37:21 <erlanguid> right
22:37:24 <Eridius> which means that the entire result of the foldr is (a -> a)
22:37:33 <erlanguid> I did type on a definition of step
22:37:59 <Gracenotes> mm. it is less complicated than it seems, because many of the types are the same in this case.
22:38:24 <Gracenotes> the general step type is a -> b -> b for foldr... but this one is a -> (b -> b) -> (b -> b)
22:38:34 <Gracenotes> as Eridius said, this is the same as: a -> (b -> b) -> b -> b
22:39:54 * Eridius wishes ghci let you write toplevel expressions 
22:39:54 <erlanguid> I'm understanding about a quarter of your type discussion
22:40:08 <erlanguid> thank you guys for your help
22:40:17 <erlanguid> nice big leap in understanding
22:40:21 <Gracenotes> mm. have you checked out the section on partial application yet?
22:40:44 <erlanguid> nope thats about 6 subchapters down the list
22:41:06 <Eridius> is < common literate haskell syntax to mean code that's not supposed to be evaluated?
22:41:14 <Gracenotes> yeah. The rest of the chapter covers some stuff relevant to the definition
22:41:38 <erlanguid> great stuff really
22:41:47 <jml> is there a builtin (map . toUpper)?
22:41:52 <Eridius> Haskell really stretches your brain
22:41:58 <Gracenotes> erlanguid: the goal is to implement the Hindley-Milner type inference algorithm in your head by the time you're done with the book!
22:41:59 <jml> errr I meant (map toUpper)
22:42:09 <Gracenotes> :D
22:42:17 <Eridius> jml: is there a reason (map toUpper) is not good enough?
22:42:18 * erlanguid cries 
22:42:34 <jml> Eridius: no.
22:42:44 * erlanguid thanks Gracenotes and Eridius heartily
22:42:48 <Gracenotes> I am not away of a built-in map toUpper
22:42:52 <Gracenotes> aware
22:42:52 <jml> ok.
22:42:55 <jml> thanks
22:43:03 <Eridius> Gracenotes: I saw an example a while back of a slideshow where the author introduced an implementation of quicksort, where the type inference system actually recognized that the implementation was missing a base case and would never terminate, and raised a type error instead
22:43:21 <Gracenotes> for Unicode strings, it's not as simple as map toUpper
22:43:24 * Eridius has never been able to find that slideshow again, but he remembers it because he could never work out in his head exactly how the algorithm detected that
22:44:08 <Gracenotes> sometimes a character will change in uppercase depending on context, or will turn into two characters, etc.
22:44:36 <dolio> @type let qsort (x:xs) = qsort ls ++ [x] ++ qsort rs where ls = filter (<= x) xs ; rs = filter (> x) xs in qsort
22:44:38 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:45:19 <dolio> @type let qsort xs@(x:_) = qsort ls ++ qsort rs where ls = filter (<= x) xs ; rs = filter (> x) xs in qsort
22:45:20 <lambdabot> forall a a1. (Ord a) => [a] -> [a1]
22:45:29 <Eridius> dolio: I can't remember very well anymore, either it was a version of quicksort that was designed to be a bit more optimized, or it was actually not quicksort, just another algorithm that takes a divide-and-conquer approach
22:45:53 <dolio> Well, that's an example.
22:46:19 <dolio> [a] -> [b] is obviously the wrong type for a sort.
22:46:41 <Eridius> heh
22:46:58 <Gracenotes> not unsafeCoerceSort !
22:47:15 <dolio> It was the same case with the example you're referring to, although I don't remember the implementation they used.
22:47:17 <Botje> sort :: Ord a, Sorted [b] => [a] -> [b]
22:47:21 <Botje> obviously
22:48:03 <Eridius> the problem with the implementation was if a list of size 1 was given, it would split that into two lists of size 1 and 0, then sort those lists and recombine, which meant it spun forever on the list of size 1
22:48:21 <Eridius> and every single list of size > 0 would eventually divide into a list of size 1
22:48:44 <dolio> So does that one, effectively.
22:48:48 <Gracenotes> sort _ = []
22:49:02 <Gracenotes> If a sort is just defined to be "for all 0 > i > n, A[i] <= A[i+1], where A is the resulting array", the implement is very easy
22:49:05 <dolio> qsort [x] = qsort [x] ++ qsort [].
22:49:16 <Eridius> well, yours always spins forever on the very first division
22:49:17 <dolio> @type let qsort [] = [] ; qsort xs@(x:_) = qsort ls ++ qsort rs where ls = filter (<= x) xs ; rs = filter (> x) xs in qsort
22:49:18 <lambdabot> forall a a1. (Ord a) => [a] -> [a1]
22:49:20 <Eridius> but I see your point
22:49:36 <dolio> Adding the [] case still has the problem.
22:50:05 <Gracenotes> I'm just saying, sort _ = [], great algorithm, I know many Fortune 500 companies that have used it!
22:50:35 <Gracenotes> although, sometimes there's the pesky requirement that the result be a permutation of the input.
22:51:17 <Eridius> dolio: even if you add the [x] case yours should still be broken, no? I mean, the very first division it makes (the value of ls) will be the exact same division it always makes
22:51:37 <dolio> Heh, yeah, I guess so.
22:51:48 <dolio> The type system probably won't catch that, though.
22:51:50 <Eridius> since you leave the pivot in the division, it will just continue to pick the same pivot over and over
22:52:16 <Eridius> @type let qsort [] = [] ; qsort [x] = [x]; qsort xs@(x:_) = qsort ls ++ qsort rs where ls = filter (<= x) xs ; rs = filter (> x) xs in qsort
22:52:18 <lambdabot> forall a. (Ord a) => [a] -> [a]
22:52:20 <Eridius> damn
22:52:27 <vixey> lol
22:52:27 <vixey> sqrt _ = 7
22:52:27 <vixey> was tested and appears to work for at least one value
22:53:37 <Eridius> so the problem here with the incorrect version is it simply never has a case that establishes the result type of qsort
22:53:46 <Eridius> and since the result type of qsort is dependent upon the result type of qsort...
22:53:54 <Eridius> but with the correct version, the [x] in the middle does the trick
22:53:59 <mmorrow_> pumpkin: ./Setup haddock --hyperlink-source --hoogle --haddock-options=--html
22:54:58 <mmorrow_> (i dunno if the "--haddock-options=--html" is actually necessary)
22:55:41 <mmorrow_> the xchat scrollback from your previous session is handay
22:56:08 <pumpkin> ah, cool
22:56:23 <pumpkin> thanks :)
22:56:23 <Eridius> > fix (*3)
22:56:27 * Eridius cackles madly
22:56:38 <mmorrow_> pumpkin: de nada
22:56:38 <lambdabot>   thread killed
22:57:03 <mmorrow_> > let f !x = f (x+1) in f 0
22:57:04 <lambdabot>   Add a type signature
22:57:12 <Eridius> sheesh, haskell should be smart enough to know that fix (*3) is 0
22:57:14 <mmorrow_> > let f !x = f (x+1::Int) in f 0
22:57:15 <lambdabot>   Add a type signature
22:57:19 <Botje> > fix (fmap (*3)) $ Nothing
22:57:20 <lambdabot>   * Exception: stack overflow
22:57:23 <mmorrow_> > let f !x = f (x+1::Int) in f (0::Int)
22:57:24 <lambdabot>   Add a type signature
22:57:31 <mmorrow_> , let f !x = f (x+1::Int) in f (0::Int)
22:57:38 <lunabot>  Killed.
22:57:49 <pumpkin> aw
22:57:50 <mmorrow_> that one's bad news
22:57:56 <pumpkin> why?
22:58:04 <pumpkin> you wanted it to wrap around?
22:58:12 <mmorrow_> it doesn't allocate so ghc can't preempt it
22:58:17 <pumpkin> ah
22:58:18 <mmorrow_> and it never returns
22:58:26 <mmorrow_> but makes progress so it'
22:58:32 <mmorrow_> s not a blackhole entry
22:58:42 * mmorrow_ checks what happens in 6.10.2
22:58:42 <pumpkin> , let f 0 = 5; f !x = f (x+1::Int8) in f 1
22:58:43 <lunabot>  5
22:58:46 <pumpkin> whee :)
22:58:53 <mmorrow_> heh
22:59:08 <pumpkin> , let f 0 = 5; f !x = f (x+1::Word16) in f 1
22:59:09 <lunabot>  5
22:59:16 <pumpkin> , let f 0 = 5; f !x = f (x+1::Word32) in f 1
22:59:21 <Gracenotes>   pumpkin killed
22:59:22 <lunabot>  Killed.
22:59:25 <pumpkin> :(
22:59:31 <pumpkin> mmorrow_'s machine is too slow!!
22:59:33 <pumpkin> ;)
23:00:05 <mmorrow_> nice, it's killable in ghci-6.10.2
23:00:34 <mmorrow_> , let f 0 = 5; f !x = f (x+1::Word32) in f 1
23:00:39 <scutigera> is the result x+1 a word32 or is it forcing 1 to be word32 ?
23:00:39 <mmorrow_> come on!
23:00:40 <lunabot>  Killed.
23:00:43 <mmorrow_> aw
23:00:54 <pumpkin> scutigera: the result, but it's the same in the end
23:01:01 <pumpkin> since (+) :: a -> a -> a
23:01:03 <mmorrow_> scutigera: it's forcing the type of f
23:01:04 <pumpkin> in Num
23:01:17 <dancor> the lambdabot darcs repo does not give utf8 when i do 'darcs changes --xml-output'
23:01:19 <Gracenotes> forcing (x+1) to the Word32. And then the type system goes all crazy and demands that x and 1 are both Word32s!
23:01:27 <Gracenotes> the thought of it!!!!
23:01:32 <dancor> and this breaks using it with tailor.  what should i do?
23:01:40 <scutigera> right.. just a syntax check
23:01:41 <pumpkin> @remember Gracenotes And then the type system goes all crazy and demands that x and 1 are both Word32s!
23:01:42 <lambdabot> Okay.
23:02:03 <Gracenotes> !!
23:02:14 * pumpkin is playing GH3
23:02:33 <mmorrow_> general hospital 3?
23:02:37 <pumpkin> guitar hero
23:02:38 <pumpkin> :)
23:02:40 <mmorrow_> ahh
23:02:57 * Eridius should break out RB2
23:02:58 <mmorrow_> i've never actually played that game :(
23:03:00 <pumpkin> aw
23:03:03 <pumpkin> I have RB2 too
23:03:13 <Eridius> you have RB four? wow!
23:03:15 <Gracenotes> Gracenotes Hatin' 3
23:03:21 <pumpkin> but GH3 has more songs I like
23:03:24 <Gracenotes> :(
23:03:52 <pumpkin> One is so much fun to play
23:03:57 <pumpkin> oh wait, this isn't #haskell-blah
23:05:43 <dancor> i guess i'll make tailor take a --repo-encoding=latin-1 and do the conversion.  far be it from me to ask lboters to fix that repo
23:12:33 <mmorrow> what is libtinfo.so ?
23:12:53 <mmorrow> ah terminal
23:14:46 <mmorrow> nice, plugins-1.4.1  build without modification on 6.10.2
23:15:11 <mmorrow> awww
23:15:13 <mmorrow> plugs: /tmp/MYcAtW4723.o: unknown symbol `base_GHCziNum_zdf2_closure'
23:15:13 <mmorrow> plugs: user error (resolvedObjs failed.)
23:19:22 <vixey> > 123+4
23:19:23 <lambdabot>   127
23:19:36 <vixey> what is 123 in binar
23:20:58 <ezero> 1111011
23:21:00 <mmorrow> , let toBits a = let n = 32 in fmap ((.&.0x01) . (a`shiftR`)) [n-1,n-2..0] in toBits (127::Int)
23:21:02 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1]
23:21:09 <mmorrow> , let toBits a = let n = 32 in fmap ((.&.0x01) . (a`shiftR`)) [n-1,n-2..0] in toBits (123::Int)
23:21:11 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1]
23:23:43 <mmorrow> (toBits a = let n = 8 * sizeOf a in fmap ((.&.0x01) . (a`shiftR`)) [n-1,n-2..0])
23:23:59 <ezero> , toBits
23:24:01 <lunabot>  luna: Not in scope: `toBits'
23:24:06 <ezero> , a
23:24:09 <lunabot>  a
23:24:16 <ezero> , show a
23:24:17 <lunabot>  "a"
23:24:19 <mmorrow> that's SimpleReflect
23:24:22 <mmorrow> :: Expr
23:24:24 <ezero> cool!
23:24:26 <mmorrow> , sizeOf
23:24:28 <lunabot>  luna: Not in scope: `sizeOf'
23:24:37 <ezero> , :t map
23:24:38 <lunabot>  luna: Couldn't match expected type `((a1 -> b) -> [a1] -> [b]) -> [a]'
23:24:50 <Cale> > map (`mod` 2) . takeWhile (/= 0) . iterate (`div` 2) $ 123
23:24:51 <lambdabot>   [1,1,0,1,1,1,1]
23:24:52 <ezero> wow this is wicked :D
23:24:52 <mmorrow> , [$ty| map |]
23:24:57 <lunabot>  forall a b . (b -> a) -> [] b -> [] a
23:25:18 <ezero> which channel can i spam this bot?
23:25:26 <mmorrow> , foldl f 0 [a,b,c,d,e] :: Expr
23:25:28 <lunabot>  f (f (f (f (f 0 a) b) c) d) e
23:25:28 <Cale> ezero: Do it in private messages.
23:25:33 <ezero> cheers
23:25:34 <mmorrow> , foldr f 0 [a,b,c,d,e] :: Expr
23:25:37 <lunabot>  f a (f b (f c (f d (f e 0))))
23:27:47 <Gracenotes> , [ $ty | :t |]
23:27:48 <lunabot>  luna: parse error on input `:'
23:27:57 <Gracenotes> , [ $ty | :t map |]
23:27:58 <lunabot>  luna: parse error on input `:'
23:29:14 <orbitz> @help
23:29:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:29:20 <orbitz> @list
23:29:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:30:24 <vixey> I suck at writing
23:30:29 <vixey> how do you write ?
23:30:47 <orbitz> vixey: write what?
23:31:57 <mmorrow> > foldr1 g (scanl (foldl f) o (inits [a,b,c]) :: [Expr])
23:31:59 <lambdabot>   g o (g o (g (f o a) (g (f (f (f o a) a) b) (f (f (f (f (f (f o a) a) b) a) ...
23:32:01 <orbitz> @tell ivanm what about a fork/join implementation that can distribute jobs locally or acros machines, like a cheap map/reduce?
23:32:01 <lambdabot> Consider it noted.
23:32:31 <pumpkin> orbitz: code as data!
23:32:45 <pumpkin> send dat code to other machines
23:33:54 <mmorrow> Gracenotes:
23:33:56 <mmorrow> , [$ty| map |]
23:33:58 <lunabot>  forall a b . (b -> a) -> [] b -> [] a
23:34:02 <mmorrow> , [$tyQ| map |]
23:34:05 <lunabot>  ForallT [a,b] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT b)) (VarT a)...
23:34:12 <mmorrow> , [$ty| ty |]
23:34:15 <lunabot>  QuasiQuoter
23:34:20 <pumpkin> so meta
23:34:24 <mmorrow> so
23:34:32 <Gracenotes> so :t map?
23:34:44 <mmorrow> what is that supposed to mean?
23:34:48 <Gracenotes> , :t map
23:34:50 <lunabot>  luna: Couldn't match expected type `((a1 -> b) -> [a1] -> [b]) -> [a]'
23:34:52 <Gracenotes> I dunno, but it was parsed
23:34:59 <mmorrow> is that valid haskell? :)
23:35:05 <Gracenotes> don't think so
23:35:13 <Gracenotes> lunabot thinks so :O
23:35:15 <w0rth> @paste
23:35:16 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:35:24 <mmorrow> haha, oh i know why
23:35:42 <mmorrow> since it wraps the user expression in  "show ("++e++")"
23:36:09 <Gracenotes> heh. lunabot injection!
23:36:14 <mmorrow> (but you can't abuse that, since it's compiling it with dynamicCompileExpr)
23:36:32 <Gracenotes> > [$ty| (++:) |]
23:36:32 <mmorrow> so unless the result of it is a String, you'll get back nothing
23:36:33 <lambdabot>   <no location info>: parse error on input `]'
23:36:39 <Gracenotes> , [$ty| (++:) |]
23:36:42 <lunabot>  luna: Exception when trying to run compile-time code:
23:36:58 <Gracenotes> oh, gotcha
23:36:58 <w0rth> Can someone please tell me what's wrong with this code, I'm stumped: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3651#a3651
23:37:01 <mmorrow> , ) ++ show (
23:37:01 <orbitz> pumpkin: can i serialize functions in haskell?
23:37:02 <lunabot>  ()()
23:37:09 <pumpkin> orbitz: nope
23:37:16 <orbitz> what exactly is involved in serialize functions?  seems very har dto implement well
23:37:34 <mmorrow> orbitz: you would need an interpreted bytecode
23:37:52 <orbitz> and a JIt perhaps?
23:38:13 <vixey> w0rth why do you think somethings wrong with it?
23:38:21 <mmorrow> (or some way to translate machine code to some generic format, and then a way to tranlate that back to a (possibly different arch's) machine code at the destination (which sounds epic)
23:38:30 <Gracenotes> , )(
23:38:32 <lunabot>  luna: Couldn't match expected type `() -> a'
23:38:44 <orbitz> does anylanguage support this?
23:38:49 <mmorrow> Gracenotes: your expression has to be a String
23:39:11 <w0rth> vixey: it gives me a "cannot construct an infinite type: a = [a]" error
23:39:22 <mmorrow> Gracenotes: ("your expression" := eval ("show (" ++ e ++ ")") )
23:39:25 <vixey> w0rth does it tell you which line has that?
23:39:38 <Gracenotes> mmorrow: yes, but the error message is telling, me supposes.
23:39:39 <mmorrow> orbitz: yeah, or a jit
23:39:51 <w0rth> vixey: the powerSet (Set []) = set [[]] line, but if i comment the following line it also goes away
23:39:58 <altmattr> interesting bug
23:39:59 <altmattr> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2083#a2083
23:40:16 <mmorrow> Gracenotes: i'm not kidding when i say you can't inject code, because there's no surrounding context to inject it into :)\
23:40:30 <altmattr> I am wondering if the bahaviour is expected in ghc
23:40:42 <altmattr> I don't have any other compilers to check with
23:40:52 <orbitz> mmorrow: do you know of any language that can serailize functions?
23:40:59 <Gracenotes> , "aww, it can't handle" -- uh :\
23:41:01 <lunabot>  luna: parse error (possibly incorrect indentation)
23:41:25 <mmorrow> , ){- 42 -}show(
23:41:26 <lunabot>  luna: Couldn't match expected type `(a1 -> GHC.Base.String) -> () -> a'
23:41:32 <mmorrow> , ){- 42 -}++show(
23:41:33 <lunabot>  ()()
23:41:57 <mmorrow> orbitz: smlnj can do it, but it does it to machine code
23:42:08 <Eridius> altmattr: your let expression is binding k to part of the result of fac2tt, but passing k into that same expression
23:42:12 <orbitz> mmorrow: as in it sends machien code around?
23:42:13 <Eridius> altmattr: it's like the definition of fix
23:42:15 <Eridius> @src fix
23:42:15 <lambdabot> fix f = let x = f x in x
23:42:36 <mmorrow> orbitz: it can freeze the entire heap + code and write it to a file which you can resume
23:42:48 <altmattr> Eridius: thanks, that is a perfect explanation
23:42:52 <mmorrow> orbitz: but you couldn't resume it on another machine of a different arch
23:42:53 <altmattr> Eridius++
23:42:56 <Gracenotes> , ) `seq` "haha, I have injected a 3!" `seq` const 3 (
23:43:05 <Eridius> altmattr: this sort of thing is perfectly valid when the value doesn't depend on itself ;)
23:43:06 <Gracenotes> :O
23:43:06 <w0rth> module FinOrdSet (set, empty, member, memb) where
23:43:06 <w0rth> -- import the haskell List library
23:43:06 <w0rth> import Data.List
23:43:09 <w0rth> -- the set data type is based on the list data type
23:43:13 <w0rth> data Set a = Set [a]  deriving (Eq, Ord, Show)
23:43:16 <w0rth> module FinOrdSet (set, empty, member, memb) where
23:43:19 <w0rth> -- import the haskell List library
23:43:22 <mmorrow> orbitz: i guess any interpreted lang could do this (by def)
23:43:22 <w0rth> import Data.List
23:43:26 <w0rth> -- the set data type is based on the list data type
23:43:29 <w0rth> data Set a = Set [a]  deriving (Eq, Ord, Show)
23:43:30 <Gracenotes> @botsmack
23:43:30 <lambdabot> :)
23:43:31 <lunabot>  :)
23:43:32 <pumpkin> doesn't erlang do that?
23:43:32 <w0rth> empty :: Set a  -> Bool
23:43:35 <w0rth> empty (Set []) = True
23:43:36 <w0rth> empty (Set (x:_)) = False
23:43:39 <w0rth> set :: (Eq a, Ord a) => [a] -> Set a
23:43:42 <w0rth> set [] = Set []
23:43:43 <Eridius> for example, you could do a poor man's cycle with let x = 1:x in x
23:43:45 <w0rth> set xs = Set $ sort $ nub xs
23:43:49 <w0rth> member :: (Eq a) => a -> Set a -> Bool
23:43:52 <w0rth> member x (Set []) = False
23:43:55 <w0rth> member x (Set (y:ys))
23:43:57 <mmorrow> Gracenotes: it failed to compile
23:43:58 <w0rth> | (x == y) = True
23:43:59 <pumpkin> :t empty (undefined :: Set (a -> a))
23:44:00 <lambdabot> Not in scope: type constructor or class `Set'
23:44:01 <w0rth> | otherwise = member x (Set ys)
23:44:05 <w0rth> infixl 4 `memb`
23:44:05 <pumpkin> :t empty (undefined :: Set.Set (a -> a))
23:44:06 <Gracenotes> mmorrow: mm, I gathered :\
23:44:06 <w0rth> x `memb` s = member x s
23:44:06 <lambdabot> Couldn't find qualified module.
23:44:09 <w0rth> card :: Set a -> Int
23:44:09 <Eridius> the type constructor there provides a stopping point that you can bind against
23:44:12 <w0rth> card (Set []) = 0
23:44:12 <pumpkin> :t empty (undefined :: Data.Set.Set (a -> a))
23:44:14 <lambdabot>     No instance for (Alternative ((->) (S.Set (a -> a))))
23:44:14 <lambdabot>       arising from a use of `empty' at <interactive>:1:0-41
23:44:14 <lambdabot>     Possible fix:
23:44:15 <w0rth> card (Set (xs)) = length xs
23:44:19 <w0rth> equals :: (Eq a) => Set a -> Set a -> Bool
23:44:22 <w0rth> equals (Set []) (Set []) = True
23:44:25 <w0rth> equals (Set []) (Set (ys)) = False
23:44:25 <pumpkin> :t Data.Set.empty (undefined :: Data.Set.Set (a -> a))
23:44:27 <lambdabot>     Couldn't match expected type `S.Set (a -> a) -> t'
23:44:27 <lambdabot>            against inferred type `S.Set a1'
23:44:28 <w0rth> equals (Set (xs)) (Set []) = False
23:44:29 <Gracenotes> mmorrow: it /should/
23:44:31 <w0rth> equals (Set (x:xs)) (Set (y:ys))
23:44:34 <pumpkin> boo
23:44:35 <w0rth> sorry
23:44:38 <vixey> w0rth, you should have /quit
23:44:54 <Gracenotes> SACRIFICE YOURSELF FOR THE GOOD OF THE CHANNEL
23:44:55 <pumpkin> well, at least we have all of w0rth's codez na0
23:45:03 <mmorrow> pumpkin: i think erlang does, but with bytecode
23:45:07 <pumpkin> yeah
23:45:21 * pumpkin invents a new concept of wordcode
23:45:32 <pumpkin> or 7bitcode
23:45:37 <mmorrow> chompcode?
23:45:44 <mmorrow> nibblecode
23:45:48 <pumpkin> nybblecode
23:45:49 <mmorrow> gnawcode
23:45:57 <mmorrow> ah yeah, speling
23:46:40 <orbitz> wow so i'm looking at the BASIC package for Haskell, pretty interesting
23:52:25 <w0rth> vixey: why?
23:53:54 <mmorrow> w0rth: (just temporarily)
23:54:28 <w0rth> it was a right click with a bunch of code in my paste buffer, so it all happeened instatenously
23:54:36 <pumpkin> not for us
23:54:50 <pumpkin> and it can't have happened instantaneously for you either because the IRC server doesn't let you send all that at once :)
23:54:58 <pumpkin> maybe your client hid it from you
23:55:11 <w0rth> yeah maybe erc is really persistent
23:57:14 * Eridius reinstalls gtk2hs to use the GTK+ OS X framework
