00:03:12 <pumpkin_> class AbelianGroup (Sum a), Monoid (Product a) => Ring a where ...
00:03:16 <pumpkin_> that's not allowed I'd guess?
00:03:48 <pumpkin_> (this is not for any practical purpose, I just wanted to see how well I could model the structures in haskell)
00:04:27 <sjanssen> hmm
00:04:54 <sjanssen> the syntax is wrong: class (AbelianGroup (Sum a), ...) => Ring a where
00:05:14 <pumpkin_> oh wow
00:05:17 <pumpkin_> that was a simple fix :)
00:05:20 <pumpkin_> thanks
00:05:23 <ivanm> silly pumpkin_
00:05:25 <sjanssen> pumpkin_: it works?
00:05:28 <pumpkin_> yup
00:05:35 <pumpkin_> thanks
00:05:37 <sjanssen> you didn't even have to turn on FlexibleInstances?
00:05:42 <glguy> heh, i held off saying anything
00:05:42 <pumpkin_> nope
00:05:48 <glguy> I thought it would be nit-picky
00:05:52 * pumpkin_ glares at ivanm
00:06:17 * ivanm quickly holds up a mirror so that pumpkin_ glares at himself
00:06:24 * pumpkin_ turns to stone
00:06:34 <ivanm> mwahahahahahahah!
00:06:50 * ivanm pulls out a hammer, and gently taps the pumpkin_ statue on the head
00:07:26 * pumpkin_ is trying to decide where is best to introduce (+) and (*) in this hierarchy
00:07:38 <cjs> Is there a type for an IEEE 64-bit floating point number?
00:07:43 <pumpkin_> Double
00:07:45 <ivanm> pumpkin_: ummm....... what's the thing before groups?
00:07:51 <pumpkin_> monoid?
00:07:52 <pumpkin_> semigroup?
00:07:57 <ivanm> yeah, that's the one
00:08:16 <cjs> Hm. But I need the one that Data.Binary.put will spit out in that format, without the extra type information.
00:08:26 <ivanm> IIRC, (*) is used a the function for semigroups, except if you're talking about integers mod n, in which case it's (+)
00:08:34 <ivanm> @hoogle put
00:08:34 <lambdabot> Control.Monad.State.Class put :: MonadState s m => s -> m ()
00:08:34 <lambdabot> Prelude putChar :: Char -> IO ()
00:08:34 <lambdabot> System.IO putChar :: Char -> IO ()
00:08:47 <ivanm> @type Data.Binary.put
00:08:48 <lambdabot> forall t. (Data.Binary.Binary t) => t -> Data.Binary.Put.Put
00:09:48 <pumpkin_> ivanm: so for now, I have "op" under Magma (yeah, I know it's a silly one to build everything off of)
00:10:09 <pumpkin_> semigroup adds nothing, because I can't really say, "yo, you're associative"
00:10:13 <sjanssen> cjs: I don't think Data.Binary will use IEEE format for any of the floating types
00:10:16 <pumpkin_> actually, maybe I can with infix
00:10:23 <cjs> Oh, hm, it's not IEEE at all, instance Binary Double is using Prelude.decodeFloat.
00:10:31 <sjanssen> cjs: it is somewhat difficult to do portably
00:10:44 <cjs> Oof.
00:11:13 <cjs> Especially since this format is 25 bytes long.
00:11:38 <pumpkin_> I think someone recently added something to hackage for that
00:11:49 <pumpkin_> cause the interoperable format is a real pain
00:11:52 <cjs> What might I do to make it work on just machines that already use IEEE format?
00:12:05 <pumpkin_> unsafeCoerce from Word64 ?
00:12:07 <pumpkin_> it's a hack
00:12:14 <pumpkin_> look on hackage though
00:12:21 <cjs> I'm checking there now.
00:12:21 <pumpkin_> just a week ago or so someone added something for this
00:12:37 <pumpkin_> http://hackage.haskell.org/packages/archive/ieee754-parser/0.1/doc/html/Data-Binary-IEEE754.html
00:12:58 <sjanssen> IEEE is fairly flexible, right?  You've got to worry about endianess and such
00:13:12 <pumpkin_> yeah, that class takes care of it though
00:13:21 <ivanm> pumpkin_: what's Magma?
00:13:30 <ivanm> oh, right, that group theory construct
00:13:32 <pumpkin_> ivanm: the most boring structure ever, a set with a binary op
00:13:38 <pumpkin_> that's closed
00:13:39 <ivanm> heh
00:13:39 <pumpkin_> :P
00:13:43 <pumpkin_> kinda obvious
00:13:45 <ivanm> no identity or inverse?
00:13:51 <pumpkin_> nothing, not even associative
00:13:55 <ivanm> pumpkin_: doesn't _have_ to be closed...
00:13:56 <cjs> Wow, this was added a week ago? It's my lucky week.
00:14:05 <ivanm> you just can't do much about it unless it's closed...
00:14:11 <ivanm> cjs: what was just added?
00:14:21 <cjs> Data.Binary.IEEE754.
00:14:29 <pumpkin_> ivanm: well, that's the requirement for a magma, but since it's a set with an operation, it wouldn't make much set if the operation took you outside of the set
00:14:37 <pumpkin_> *much sense
00:14:39 <ivanm> yeah
00:14:59 <ivanm> well, you wouldn't be able to do much with it, that's all
00:15:07 <pumpkin_> anyway, bedtime, I'll think about it more tomorrow :)
00:15:09 <pumpkin_> thanks for the help
00:15:20 <ivanm> @time pumpkin_
00:15:20 <lambdabot> Local time for pumpkin_ is 2009-04-24 03:15:21 -0400
00:15:44 <ivanm> still haven't learnt how to get to bed at a sensible hour, eh? :p
00:16:05 <Badger> 3am is highly sensible!
00:16:07 <pumpkin_> this is early for me :P
00:16:13 <pumpkin_> I'm often up until 7 or 8 am
00:16:25 <pumpkin_> anyway, off I go :P ciao :)
00:16:47 <ivanm> pumpkin_: if you're up till 7 or 8, when do you actually wake up? :o
00:17:53 <fynn> what's a good Haskell library for scientific computation?
00:17:59 <ivanm> fynn: in what sense?
00:18:16 <ivanm> hmatrix has bindings to a large part of GSL, as well as providing an interface to LAPACK/BLAS matrix stuff...
00:18:20 <fynn> ivanm: stuff like matrix manipulation, for instance.
00:18:26 <ivanm> well, hmatrix
00:18:31 <ivanm> with hmatrix-strict if you want
00:18:43 <fynn> ivanm: ideally, I'm looking for something like numpy/scipy
00:18:51 <mmorrow> cjs: i've needed that too. you can use the Storable instance of CDouble (maybe Double too, i'm not sure)
00:19:15 <ivanm> fynn: you can then use chart for plots (but not 3D), or else gnuplot
00:19:49 <mmorrow> cjs: i had modify the Data.Binary code though (to expose some stuff). lemme check if modifying it is actually needed to get at the functions you'll need (i modified it to do other things too..)
00:21:41 <fynn> ivanm: can you compare numpy to hmatrix?
00:21:53 <ivanm> fynn: in what sense?
00:22:01 <ivanm> @hackage hmatrix
00:22:01 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
00:22:06 <ivanm> ^^ have a look at the docs
00:23:16 <mmorrow> cjs: unfortuantely you'll need to modify it
00:23:29 <mmorrow> cjs:
00:23:40 <mmorrow> putStorable :: forall a. (Storable a) => a -> Builder
00:23:40 <mmorrow> putStorable a = writeNbytes (sizeOf (undefined :: a)) (flip poke a)
00:23:42 <cjs> mmorrow: Hm. I think I'll try the iee754-parser package, first.
00:24:01 <mmorrow> is the single function you'd need to add to Builder
00:24:21 <fynn> ivanm: I meant, what subset of numpy hmatrix supports :)
00:24:26 <fynn> in any case, thanks.
00:24:30 <ivanm> I have no idea
00:24:42 <mmorrow> (or just export writeNBytes i guess)
00:24:55 <ivanm> since I haven't used numpy that much (only for teaching introductory scientific computing to first year science students)
00:25:01 <ivanm> and I didn't really use hmatrix that much either
00:25:27 <ivanm> fynn: besides, since hmatrix isn't a port of numpy, you can't really talk about what subset it supports
00:26:00 <mmorrow> cjs: (and in case you go the modify-Data.Binary route), the function in Get you'll need to expose or use is (getPtr :: Storable a => Int -> Get a)
00:26:10 <cjs> mmorrow: Thanks.
00:26:14 <mmorrow> np
00:27:18 <fynn> ivanm: it's OK. what I meant was that hmatrix probably doesn't support all the features of numpy/scipy (yet?), and wanted to know which major ones I'd be missing.
00:27:44 <ivanm> fynn: unless you define what the features are, you can't compare them
00:27:55 <ivanm> and as I said, it's not a port so comparing them is a bit iffy
00:28:17 * fynn nods
00:28:21 <ivanm> (whereas comparing numpy to matlab for example can be done, because numpy positions itself as an alternative)
00:28:43 <ivanm> fynn: however, AFAIK hmatrix supports a large (if not complete) subset of lapack/blas
00:28:59 <ivanm> which is the _standard_ matrix libs (matlab is based off them, IIRC; not sure about numpy)
00:29:12 <ivanm> and also a large (if not complete) subset of gsl
00:30:49 <fynn> hm, cool. who uses Haskell for scientific computing?
00:31:30 <davidL> is Data.Binary available on winhugs?
00:31:59 <ivanm> davidL: I would think not...
00:32:12 <ivanm> fynn: well, I did some stuff for it last year for a subject ;-)
00:32:24 <ivanm> but it was mainly random algs, not much matrix stuff, etc.
00:32:45 <ivanm> I mainly use haskell for math stuff (usually combinatorial)
00:33:48 <fynn> cool :)
00:34:03 <fynn> we're considering using it as an alternative for Python
00:34:23 <ivanm> fynn: I think you'll find the biggest difference is that the scientific stuff in Python is more "polished"
00:34:31 <ivanm> and integrates better
00:34:48 <fynn> Haskell obviously has some core advantages - Haskell expressions are more similar to math, better performance etc.
00:35:03 <fynn> but yeah, Python's scientific libraries are very hard to match at this point.
00:35:23 <mmorrow> fynn: i've used hmatrix to do some stuff i would've used matlab for, and had a nice experience
00:36:28 <mmorrow> hmatrix is really easy to hack to your needs to
00:36:56 <fynn> mmorrow: cool.
00:37:23 <ivanm> mmorrow: though from memory, it seems that it should be split into the lapack/blas part and the gsl part
00:37:31 <ivanm> since they two don't seem related... >_>
00:37:48 <mmorrow> ivanm: i suppose, but it's nice to have everything in one package
00:37:54 <ivanm> fynn: also, I suspect that most of the numpy stuff is "custom", whereas hmatrix uses well known/supported lapack libs
00:38:17 <ivanm> mmorrow: *nod*
00:39:22 <mmorrow> fynn: hmatrix Vector and Matrix types are ptrs to Double/Int/whatever, so if you want to write a custom C function that operates on them, you just bang out a quicky foo(double *vec, int n)
00:39:54 <mmorrow> and then can use it from ghci or whatever
00:40:30 <mmorrow> (also, of course you can write that "foo" in haskell too if you want..)
00:42:24 <fynn> ivanm, mmorrow: cool. anything else out there I should check out?
00:42:49 <ivanm> fynn: as I said, chart makes very nice (GTK+-based) graphs
00:42:59 <ivanm> there's also a (fairly limited IMHO) binding to gnuplot
00:43:11 <mmorrow> fynn: for what it's worth, looking at the NumPy reference, i don't see anything that either hmatrix doesn't already have or that couldn't be added to it with minimal effort
00:43:12 <ivanm> there's monte carlo libraries
00:43:33 <ivanm> fynn: what kind of stuff do you write?
00:43:35 <mmorrow> fynn: there also a "blas" haskell library, but i haven't used it
00:43:46 <fynn> ivanm: numeric calculations over large data sets.
00:44:13 <ivanm> of what kind?
00:44:19 <ivanm> just number crunching stuff?
00:44:26 <fynn> mmorrow: looks like hmatrix is basically bindings to parts of GSL, LAPACK and BLAS
00:44:39 <mmorrow> fynn: yes, exactly
00:44:47 <fynn> ivanm: mostly number crunching. some string manipulations.
00:44:57 <cjs> Argh! All that work to install ieee754-parser-0.1, and I just realized it doesn't have put methods!
00:45:02 <fynn> for very large mappings of string => string.
00:45:04 <ivanm> fynn: yes, I said that at least twice already ;-)
00:45:49 <fynn> ivanm: I make a habbit of repeating what wiser men have said
00:46:00 * ivanm bows
00:46:02 <ivanm> ;-)
00:46:20 <cjs> Oh, but they look pretty easy to write.
00:46:26 <ivanm> mmorrow: IIRC, the blas library has better (i.e. more complete) blas bindings than hmatrix
00:46:28 <fynn> ivanm: anyways, we do calculations related to genomics, if you're familiar with the subject.
00:46:29 <ivanm> but that's all it provides
00:46:34 <ivanm> fynn: a bit
00:46:44 <ivanm> though isn't that a bit more combinatorial in nature?
00:46:46 <fynn> ivanm: any specific library/advice for that?
00:47:02 <ivanm> well, there's fgl, etc. for graph stuff
00:47:08 <fynn> yes, there's a fair bit of combinatorial calculations involved, but not all of it is combinatorial.
00:47:15 <ivanm> but no actual combinatorial library that I can recall (though I'm working on a latin square library :p )
00:47:29 <fynn> hm, cool :)
00:47:48 <ivanm> fynn: see if anything else strikes your eye: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/
00:47:59 <ivanm> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hgalib <-- might be relevant
00:48:01 <ivanm> or not...
00:48:12 <ivanm> I saw "genetic", but not "algorithm" :s
00:49:02 <mmorrow> fynn: this pdf is a nice basic demo of hmatrix http://perception.inf.um.es/%7Earuiz/darcs/hmatrix/hmatrix.pdf
00:49:08 <ivanm> @hackage bio
00:49:08 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bio
00:49:10 <ivanm> ^^ maybe this
00:49:18 <Gracenotes> hm. I'm not sure why I'm not using IntMap
00:49:24 <Gracenotes> *switches*
00:49:54 <mmorrow> fynn: so, really the "killer app" here is how easy/nice haskell's FFI is
00:50:15 <Gracenotes> and IntSet, for that matter
00:50:51 <mmorrow> fynn: i've started to use haskell+ghci while i'm writing C code... (just quickly import all the C functions of interesting in a scratch module, then load that in ghci -fobject-code)
00:51:40 <ivanm> someone wrote matlab bindings? :o
00:52:08 <mmorrow> i think pumpkin has played with those some
00:53:08 <fynn> mmorrow: thing is, we're evaluating Haskell vs. Python, and I don't know how nice Haskell's C api is, but it would have a hard time competing against the rich and mature set Python has evolved over the years.
00:53:30 <mmorrow> fynn: NumPy seems like it's just an excersize in Python's FFI to me
00:53:55 <fynn> mmorrow: that's true. the vast majority of NumPy are C libraries that integrate tightly into Python objects.
00:54:10 <fynn> with Python's performance, writing these in Python would be suicide.
00:54:11 <cjs> fynn: Haskell's FFI is much, much better than anything else I've ever seen.
00:54:32 <fynn> cjs: really?  have you used Python's?  also, is there a short demonstration of it?
00:54:35 <cjs> Basically, you don't need to write C at all; you write C-like code in Haskell and get fantastic type checking for free.
00:55:01 <cjs> I've used Ruby's; I'm guessing python's is similar. I'm seriously guessing that in Python you need to write C code.
00:55:18 <fynn> that's sort of true. and yes, Python's is pretty similar.
00:55:24 <mmorrow> fynn: honestly, haskell's FFI is second-to-none
00:55:25 <fynn> cjs: what are you using Haskell for, btw?
00:56:07 <cjs> I use it to interface with the Microsoft Windows DDE library. This includes having to deal with the non-Unix calling conventions and having the Windows library call back into Haskell code.
00:56:10 <cjs> http://www.starling-software.com/en/blog/tokyo-functional-programming/2009/01/12.december-surprise-topic-haskell-ffi.html
00:56:39 <fynn> cool, thanks.
00:56:46 <cjs> I've done a fair amount of C, both as C itself and interfacing other languages with C, and Hakell's been by far the best of the bunch.
00:57:07 <cjs> (Oh, actually, I guess more generally we're using Haskell to write an automated options trading system.)
00:57:24 <hansfbaier> Vala is pretty nice.
00:57:24 <cjs> (The DDE stuff is to do real-time data displays in Excel.)
00:57:36 <hansfbaier> My choice for a realtime capable language
00:57:46 <hansfbaier> linux pro audio apps
00:58:15 <hansfbaier> How does Haskell to with realtime capability?
00:58:19 <hansfbaier> s/to/do/
00:58:32 <fynn> in what sense is Vala "realtime capable language"?
00:58:48 <cjs> We don't do real-time, we do "soft real time." GHC is good: faster than Java, and sometimes approaching C speed.
00:59:10 <hansfbaier> fynn: In realtime audio apps you might want to avoid calls that might block, esp malloc
00:59:29 <cjs> If you needed hard real time, well, you'd have to deal with whatever your RTOS gives you, for a start.
00:59:37 <hansfbaier> fynn: so there needs to be some way to keep those calls out of certain threads (the RT threads)
00:59:41 <fynn> cjs: cool. I was aware that there was use of FP in finances, but thought it was mostly O'Calm at Janes
00:59:55 <cjs> We're doing a pretty similar thing, though we're much smaller and newer.
01:00:10 <cjs> Standard Chartered is using Haskell as well, I believe.
01:00:25 <cjs> As was Credit Suisse before they switched to F#.
01:00:33 <fynn> cool. are you using that library SPJ wrote for valulations?
01:00:44 <fynn> *valuations
01:01:08 <cjs> Nope. Our current system is just simple options on a future on an index.
01:01:21 <hansfbaier> fynn: In haskell there is no way to influence memory allocation direclty IMHO
01:01:27 <cjs> What we're doing is really about doing very simple things very fast.
01:01:28 <hansfbaier> fynn: s/IMHO/AFAIK/
01:01:55 <cjs> If you needed to run a thread that didn't do any memory allocation, I'd guess you'd have to write that one in C.
01:02:15 <osfameron> hmmm, currying is a monad
01:02:20 <cjs> Well, you could be careful and possibly do it in Haskell. You do have direct access to unboxed types and so on.
01:02:59 <mmorrow> hansfbaier: yeah, if you need realtime guarantees you'll need to code in C
01:03:02 <ivanm> fynn: there's also a haskell interface to python...
01:03:19 <ivanm> mmorrow: because of GC?
01:03:42 <mmorrow> ivanm: yeah, ghc's GC doesn't have bounded collection time
01:03:51 <cjs> Hm. Any thoughts on how I'd take several arbitrary integers and pack them into a certain number of bits. Say, 1, 11 and 56 bits within a 64-bit word?
01:03:56 <fynn> ivanm: really?
01:03:56 <mmorrow> (although it's not noticeable in 99% of situations)
01:04:14 <Baughn> cjs: Data.Bits, shift-or?
01:04:17 <ivanm> fynn: missingPy or something IIRC
01:04:25 <cjs> Yeah, I could do it all by hand with that....
01:04:31 <Baughn> cjs: Wait, hang on.. 1, 11 and 56?
01:04:49 <Baughn> ..yeah, and you could use it to build functions to do it automatically, too
01:04:52 <cjs> Oops, I mean 1, 11 and 52.
01:04:57 <ivanm> @oeis 1, 11, 56
01:04:58 <lambdabot>  Triangular array T read by rows: T(n,0)=T(n,n)=1 for n >= 0; for n >= 2 and ...
01:04:58 <lambdabot>  [1,1,1,1,2,1,1,3,3,1,1,5,6,4,1,1,6,11,10,5,1,1,7,22,21,15,6,1,1,8,29,43,36,2...
01:05:05 <Baughn> So long as you /know/ it's 1, 11 and 52, no biggie
01:05:11 <ivanm> @oeis 1, 11, 52
01:05:12 <lambdabot>  Pascal (1,3) triangle.
01:05:12 <lambdabot>  [3,1,3,1,4,3,1,5,7,3,1,6,12,10,3,1,7,18,22,13,3,1,8,25,40,35,16,3,1,9,33,65,...
01:05:16 <Baughn> If the bit-sizes vary, then obviously you have to store that knowledge somehow
01:05:21 <ivanm> ^^ doesn't really seem relevant... ;-)
01:05:26 <hansfbaier> mmorrow: Vala is pretty nice there. It uses refcounting for memory management, and when using weak references, it is possible to keep memory allocation out of the realtime sections of the code
01:05:51 <hansfbaier> mmorrow: Since Vala is basically just syntactic sugar for C
01:06:23 <mmorrow> hansfbaier: interesting, i'll have to check it out. i haven't heard of it
01:06:34 <fynn> ivanm: heh, it's on a gopher site: http://quux.org:70/devel/missingpy
01:06:44 <ivanm> I notice that recent haddock chokes on packages which use "-- ^" markup... isn't this valid anymore?
01:07:02 <ivanm> fynn: hmmm.... IIRC, someone recently did a lib for evaluating python in haskell or something
01:07:18 <ivanm> part of a thesis where he did the first ever formal semantics for python or something
01:07:30 <hansfbaier> mmorrow: http://live.gnome.org/Vala
01:07:40 <mmorrow> hansfbaier: cool, thx
01:07:57 <cjs> Baughn: I don't think anybody will be changing the IEEE floating point interchange format any time soon. :-)
01:08:42 <hansfbaier> mmorrow: But I must admit that haskell performs very decently, too: I wrote the JACK MIDI bindings for Haskell, and the example clients performed well in a low latency setting too.
01:08:56 <hansfbaier> s/setting too/setting
01:11:57 <mmorrow> hansfbaier: nice, yeah i've never encountered a situation where the GC mattered for me (but i don't do much audio/graphics/space-shuttle-arm-controlling code either ;)
01:12:48 <ivanm> most of my apps are CPU-bound rather than memory bound
01:13:09 <ivanm> since I usually end up doing create-consume style list operations
01:13:10 <johnw> ivanm: i'm almost exactly the opposite
01:13:34 <ivanm> johnw: oh? what kind of stuff do you write?
01:13:49 <johnw> have 4x more memory would help me more than 4x more CPU
01:13:53 <ivanm> maybe you should stop believing Bill Gates that 16MB (or whatever value he gave) is all you need... ;-)
01:14:21 <joga> it was 640k ;)
01:14:35 <ivanm> that's right...
01:14:43 * ivanm was overly generous...
01:14:43 <johnw> ivanm: I am doing medium-scale enterprise apps in Java right now, using multiple virtual machines
01:15:03 <johnw> i have 3G of memory in my laptop, and it is woefully inadequate
01:15:50 <ivanm> oh, Java... there's your problem! :p
01:15:59 <ivanm> though having multiple VMs might also contribute...
01:16:13 <ivanm> johnw: so is it your actual code that has memory issues? or the environment you're using to test your code?
01:17:22 <johnw> mostly it's the environment
01:21:38 <johnw> the database is big enough that DB2 swaps, becasue I have to restrict its memory use in order for JBoss to avoid slamming into the heap boundary because of how many EJBs are needed to model everything in the DB2... it's just a scale problem
01:22:01 <johnw> the real problem is I'm using a laptop
01:22:29 * ivanm also uses a laptop
01:22:41 <ivanm> then again, I don't run multiple virtual machines, DBs, etc. ;-)
01:22:48 <ivanm> I just go and compile all my apps :p
01:22:49 <johnw> but since I'm not in the US, and can't readily go out and buy an 8-core server, I have to wait until Sep when I can
01:23:02 <ivanm> johnw: what does Sep have to do with it?
01:24:12 <johnw> so, you and I just need to share resources
01:24:21 <ivanm> heh
01:24:21 <johnw> i'll give you some of my CPU for your memory ;)
01:24:37 <ivanm> eh, I just left a job running at uni over the weekend
01:24:38 <johnw> i move back to the States
01:24:43 <ivanm> ahhh
01:24:46 * ivanm -> dinner
01:24:47 <johnw> i live on a small caribbean island, where goats are vastly more common than DDR3 modules
01:24:57 <quicksilver> how much memory does a goat have though?
01:25:07 <ivanm> quicksilver: it remembers that people are fun to hurt...
01:25:21 <ivanm> doesn't need to remember food, because a goat'll eat anything IIRC...
01:26:49 <johnw> they are very effective lawn mowers
01:27:02 <johnw> that seems to be their general use here
01:27:15 <mmorrow> lawn mower or lawn remover?
01:28:31 <Gracenotes> this DFA minimization algorithm... it refuses to work... ;_;
01:28:40 <johnw> oh, green things grow way too fast here for the goats to keep up
01:53:45 <McManiaC> how can i map "a -> IO b" to [a]??
01:54:05 <McManiaC> pairs <- mapM collectOne keys
01:54:35 <McManiaC> doesnt work
01:54:53 <McManiaC>     Couldn't match expected type `IO (m b)'
01:54:53 <McManiaC>            against inferred type `String -> IO (String, String)'
01:54:58 <xrfang> I see a function defined as cfold'... anyone pls tell me what is the basic rule of haskell's use of vairable/function names?
01:57:38 <doserj> xrfang: http://www.haskell.org/onlinereport/lexemes.html#sect2.4
01:58:30 <McManiaC> @pl \x -> liftIO $ collectOne x y
01:58:30 <lambdabot> liftIO . flip collectOne y
01:58:58 <xrfang> doserj: sorry that this kind of expressing is a little bit too academic to me... I would presume that use of ' in names is valid :p
01:59:51 <xrfang> I am still not clear about the us of "constructor" in haskell... for example:
02:00:03 <xrfang> data BTree a = Leaf a | Branch (BTree a) a (BTree a)
02:00:08 <xrfang> this is a Binary Tree
02:00:29 <xrfang> could anyone explain what is the role / purpose of the Leaf and Branch here
02:00:33 <xrfang> can't I just write:
02:00:36 <McManiaC> xrfang: yep, ' is used if you have two functions that differ only a little bit
02:00:54 <McManiaC> like "foldl" is a left fold and "foldl'" is a strict left fold
02:00:56 <xrfang> data BTree a = a | (BTree a) a (BTree a)
02:01:09 <ordnungswidrig> xrfang: Lead and Branch are to different constructors for a BTree value
02:01:27 <doserj> xrfang: read about pattern matching
02:01:38 <xrfang> McManiaC: you mean fold' is strict, which is saying that use of ' is *not* arbitrary, it has some lexical meaning?
02:01:40 <ordnungswidrig> xrfang: no, in the first clause "a" before "|" you're omitting the constructors name
02:01:43 <quicksilver> McManiaC: your mapM is the right way.
02:01:47 <quicksilver> McManiaC: must be something else wrong.
02:01:59 <McManiaC> quicksilver: yeh i got it, see that @pl :)
02:02:03 <ygui> xrfang: I think this is describing a tree node, which could be either a leaf node, or a node with children trees.
02:02:14 <xrfang> yes, I know BUT
02:02:35 <xrfang> what is the purpose of writing a so called "constructor" there, which only serves as a label?
02:02:43 <xrfang> from the point of view of a non-fp programmer,
02:02:51 <xrfang> function needs to be defined then used
02:03:02 <McManiaC> xrfang: its part of the name, like any other letter of foldl
02:03:05 <doserj> xrfang: to distinguish the type
02:03:08 <McManiaC> its a different function
02:03:09 <xrfang> while in haskell, the constructor appears in the RHS of the expression!
02:03:12 <xrfang> the first time
02:03:20 <doserj> Leaf x has a different type than x
02:03:22 <xrfang> i.e. being "used" without being defined first
02:03:49 <quicksilver> McManiaC: oh, good.
02:03:58 <ordnungswidrig> xrfang: it's like in oo the names for a class hierachy. "BTree" is a parent type and "Leaf" and "Node" are subtypes.
02:04:06 <xrfang> doesrj: yes I can understand/accept it :) but why we need to make a new type "Leaf x" but not use x directly?
02:04:17 <quicksilver> I don't think that is a good answer, ordnungswidrig .
02:04:23 <quicksilver> xrfang: because every term must have a single type.
02:04:25 <ordnungswidrig> quicksilver: yes, it's misleading.
02:04:42 <McManiaC> in java it would be "Leaf implements BTree" i guess (just started learning java) *g*
02:04:47 <McManiaC> *public class
02:04:48 <quicksilver> xrfang: the term "x" has type "a", the term "Leaf x" has type "Tree a"
02:04:56 <ordnungswidrig> I was refereing to the contect of different names, not the concept of class hierachires in oo
02:05:03 <ordnungswidrig> s/contect/concept/
02:05:24 <quicksilver> xrfang: you want to be able to distinguish between an item and a small tree containing that item, just like you want to be able to distinguish between an item and a single-element list of that item.
02:05:29 <xrfang> quicksilver: I don't see that?  "Tree a"? where is the word "Tree" defined?
02:05:36 <McManiaC> and "public class Branch implements BTree {..."
02:05:39 <quicksilver> xrfang: BTree, sorry.
02:05:47 <cjs> Gah! Int64 is endian!
02:05:55 <ordnungswidrig> xrfang: "data Tree ..." defines the "Tree"
02:06:20 <Workybob_> what's the extension that allows types like f :-> g?
02:06:27 <ordnungswidrig> xrfang: ... = "Leaf  ..."  defines a "type" of "Tree"
02:06:41 <xrfang> in another word, the compiler will infer that Leaf and Branch are of type BTree right?
02:06:42 <ordnungswidrig> Workybob_: -XEvilSmile?
02:06:45 <dolio> TypeOperators
02:06:52 <ordnungswidrig> xrfang: yes
02:07:14 <dolio> Leaf and Branch are not of type BTree, though.
02:07:33 <dolio> Leaf :: a -> BTree a, Branch :: BTree a -> a -> BTree a -> BTree a
02:07:49 <xrfang> ok dolio, I will think about that...
02:07:56 <xrfang> next question about this tree.
02:08:10 <dolio> Constructors are trivial functions, though. You just list the types that go in them, and you get their implementation for free, because there's nothing to do.
02:08:17 <xrfang> now I have this tree defined, how do I add some nodes to it? i.e use a newly defined type in my program
02:08:25 <dolio> They just stick their arguments together for observation later.
02:08:42 <xrfang> dolio, this is exactly the source of confusion, they are there without being defined
02:08:49 <McManiaC> btw: can i define a data like "data Foobar = Foobar Int Int" with a constructor that accepts only one parameter and uses the first to create the 2nd int?
02:09:11 <ordnungswidrig> xrfang: insert :: BTree -> a -> BTree a
02:09:18 <ordnungswidrig> xrfang: like that?
02:09:44 <xrfang> ordnungswidrig, the thing you give is a signature, again.. but how about the function itself?
02:10:05 <ordnungswidrig> xrfang: yes, the implementation depends on how you want it. example:
02:10:09 <xrfang> I presume that signatures are "nice to have" but not mandatory?
02:10:15 <dolio> Also, you probably want just Leaf, otherwise you can't represent empty trees.
02:11:15 <bastl> hi, someone recently showed my how to combine boolean predicates of type (a -> Bool) using "liftM2 (&&)" which lifts && to the Reader-monad. I want to explain that to someone who knows monads, but not haskell. Could someone help with some pseudo-code ? im thinking about somthing like: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4170 but more concise (and corrent), while abstracting away from to much haskell syntax.
02:11:25 <doserj> xrfang: there are many very good haskell tutorials online that would answer your questions just as good or better than we can do here in single line answers
02:11:47 <McManiaC> @pl \x -> u $ f a b x
02:11:48 <lambdabot> u . f a b
02:11:55 <xrfang> the reason I ask is that for the type like: data List a = Nil | Cons a (List a), if I want to add data to it I write: (Cons 1 (Cons 2 (Cons 3 (Cons Nil))))?  I don't think this is a good way to add data to this List type
02:12:02 <McManiaC> @pl \x -> u $ f a x b
02:12:02 <lambdabot> u . flip (f a) b
02:12:08 <mmorrow> @let pair (<>) f g = \a -> f a <> g a
02:12:09 <lambdabot>  Defined.
02:12:19 <ordnungswidrig> xrfang: why isn't it good?
02:12:23 <xrfang> doserj: I am reading one, by Hal, recommended by haskell.org
02:12:39 <mmorrow> > pair (&&) (1<) (<10) 7
02:12:41 <lambdabot>   True
02:12:44 <doserj> xrfang: good. keep reading then :)
02:12:55 <xrfang> ordnugswidrig: this is because I expect to see a function, e.g. I have 3 or 30 data, I don't want to add them by one expression
02:13:00 <xrfang> but to add one by one, when needed.
02:13:20 <xrfang> doserj: it is a bit too academic... I will try Real World Haskell in parallel...
02:13:53 <mmorrow> bastl: that "pair" function is liftM2 for the reader monad
02:14:55 <Axman6> mmorrow: i've often wanted that to be defined somewhere
02:15:17 <mmorrow> void *pair(void*(*o)(void*,void*),void*(*f)(void*),void*(*g)(void*),void *a){return o(f(a),g(a));}
02:15:24 <mmorrow> :/
02:15:43 <bastl> mmorrow. nice, wheres that from? but still, how would i explain that to my prof?
02:15:52 <Axman6> xrfang: i'd highly recommend the learn you a haskell for great good tutorial by BONUS
02:15:55 <mmorrow> bastl: where's what from?
02:15:55 <Axman6> @where lyah
02:15:55 <lambdabot> www.learnyouahaskell.com
02:16:11 <mmorrow> bastl: (pair? i just made that up)
02:16:22 <bastl> oh, ic
02:16:39 <mmorrow> but it's liftM2 for reader if you were to write it out explicitly
02:16:57 <mmorrow> so in that sense i guess it's not "made up"
02:17:05 <bastl> :-)
02:17:22 <quicksilver> xrfang: I recommend LYAH as well.
02:17:38 <bastl> but still, could i explain it in this "imperative" way i use in my paste?
02:17:46 <xrfang> quicksilver, what is LYAH?
02:17:51 <bastl> its not about programming, but presentation ...
02:18:01 <Axman6> xrfang: http://www.learnyouahaskell.com
02:18:01 <Axman6>  gogogogo
02:18:21 <xrfang> thanks!
02:18:41 <mmorrow> bastl: i would say "it takes two functions along with a combining function, and finally a single value, and then applies the combining function to the two results obtained by applying each of the two functions to the value."
02:18:50 <doserj> bastl: why not just write out the liftM2 definition?
02:18:58 <doserj> @src liftM2
02:18:59 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:19:09 <mmorrow> pair (<>) f g = \a -> f a <> g a
02:19:17 <mmorrow> seems pretty self-explanatory
02:19:22 <bastl> doserj: that was the right question :- ) thanks
02:19:44 <bastl> mmorrow: but depends on the haskell-level of the reader.
02:20:03 <mmorrow> yeah, true i suppose (at the syntax level), but not the idea-level i don't think
02:20:51 <bastl> right. so for syntax I switch to do notation as doserjs suggestion shows.
02:20:54 <xrfang> ok, now I have YAHT, LYAH, and Real World, for a beginner, what is the right order to read these 3 (i.e. from easiest to most difficult)?
02:20:59 <bastl> thanks so long
02:21:05 <mmorrow> bye :)
02:22:21 <mmorrow> (i think connecting the do notation to its particular interpretation in the reader-monad is no easy task (even if you know haskell) personally)
02:22:32 <quicksilver> xrfang: YAHT and LYAH have similar aims/levels but very different styles.
02:22:42 <quicksilver> if you found YAHT too academic then you may find LYAH more friendly.
02:23:06 <xrfang> quicksilver: thanks!  I do think yaht is a bit academic and from the lambda's point of view :)
02:23:19 <quicksilver> xrfang: RWH is more practical than tutorial; it will teach you interesting skills once you have the basics.
02:23:31 <alc> I think LYAH is very good for  a beginner, and also PiH
02:23:47 <xrfang> PiH is?
02:23:50 <Axman6> mmorrow: is there any actual difference, except symantically, between pair (<>) f g a = g a <> g a and pair (<>) f g = \a -> f a <> g a?
02:23:56 <alc> programming in haskell
02:24:00 <xrfang> ok, RWH will be last.
02:24:17 <Axman6_> woah... epic lag there
02:24:30 <xrfang> alc: do you mean this book: http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_sim_b_4
02:25:01 <doserj> Axman6: well, one compares g a with itself, the other compates g a with f a :)
02:25:07 <alc> xrfang: yes
02:25:32 <Axman6> doserj: uh, that was supposed to be f a <> g a
02:26:02 <mmorrow> Axman6: there's a difference in how GHC will compile those two
02:26:26 <Axman6> yeah, that was my main question i guess. mmorrow do you know what the difference is?
02:26:27 <mmorrow> (pair (<>) f g = \a -> f a <> g a) has arity 2, while the other has arity 3
02:26:37 <Axman6> i see
02:26:54 <mmorrow> the arity 2 version will perform better that the arity 3 will when partially applied
02:26:59 <mmorrow> err, sorry i meant arity 3 and 4
02:27:31 <mmorrow> *... the arity 3 version will perform better than the arity 4 will when partially applied to 3 args
02:27:48 <mmorrow> (which that function most often will be, probably)
02:29:46 <mmorrow> (and the flip side of that is that the arity 3 will have worse perf than the arity 4 when applied to 4 args)
02:31:19 <mmorrow> because to evaluate the arity 3 version when fully applied to 4 args (modulo ghc being smart and figuring this out, which i'm not sure happens), it would have to evaluate it on the first 3 args, get back another function, check its arity, see it's 1, then apply that to the final arg
02:31:35 <mmorrow> whereas the arity 4 version will be applied to all 4 args initially
02:32:03 <Axman6> hmm, can you get ghc-core to show you the output for a non main file?
02:32:13 <mmorrow> i'm not sure
02:32:24 <Axman6> i'm getting no main defined errors
02:32:38 <mmorrow> you can always do "ghc -O2 -ddump-siml -c Foo.hs"
02:32:49 <mmorrow> but it won't be cleaned up like ghc-core's output
02:33:00 <mmorrow> -ddump-simpl
02:33:26 <Axman6> o go
02:33:29 <Axman6> no*
02:34:14 <Axman6> problem is that if i don't use the two definition of pain in the file, it doesn't show them at all
02:37:20 <mmorrow> pain :: IO () {- :) -}
02:37:29 <ordnungswidrig> Possible fix:  add (Show a) to the context of the instance declaration
02:37:37 <ordnungswidrig> that means what?
02:37:46 <mmorrow> instance (Show a) => ...
02:38:03 <ordnungswidrig> mmorrow: thx
02:56:58 <Guest61350> Hi,
02:56:58 <Guest61350> I have a question, hope someone can help me:
02:56:58 <Guest61350> The first definition for '<<' works fine, however the second definition 'smaller' won't compile.
02:56:58 <Guest61350> xs     << []      =  False
02:56:58 <Guest61350> []     << ys      =  True
02:56:59 <Guest61350> (x:xs) << (y:ys)  =  x<y || (x==y && xs<<ys)
02:57:01 <Guest61350> smaller xs [] = False
02:57:03 <Guest61350> smaller [] ys = True
02:57:05 <Guest61350> smaller (x:xs) (y:ys) = smaller x y || (x==y && smaller xs ys)
02:57:07 <Guest61350> How can I solve this?
02:58:12 <wjt> Guest61350: well, what type do you want smaller to have?
02:58:44 <Guest61350> marceau a list type
02:59:04 <wjt> Guest61350: okay, so what type are x and y in the last clause
02:59:05 <Lemmih> Guest61350: smaller x y?
02:59:25 <Lemmih> Guest61350: Do you mean 'x<y'?
03:00:14 <Guest61350> lemmih ok i see it thx
03:04:34 <Axman6> Guest61350: in smaller (x:xs) (y:ys) = smaller x y || (x==y && smaller xs ys), what are the types of x and t if (x:xs) and (y:ys) have type [a]?
03:05:25 <Axman6> Guest61350: do you understand that smaller is not the same as <?
03:06:09 <Guest61350> Axman6: I wrongly used smaller x y in place of x < y. I guess that x < y works because it is overloaded.
03:06:27 <Axman6> well, not overloaded. it's a member of the class Ord
03:06:31 <Axman6> :t (<)
03:06:32 <lambdabot> forall a. (Ord a) => a -> a -> Bool
03:06:36 <Axman6> @src Ord
03:06:36 <lambdabot> class  (Eq a) => Ord a  where
03:06:36 <lambdabot>     compare      :: a -> a -> Ordering
03:06:36 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:06:36 <lambdabot>     max, min         :: a -> a -> a
03:06:56 <hotaru2k3> wouldn't "smaller xs ys = xs < ys" do the same thing?
03:07:19 <Axman6> i believe so
03:07:32 <Axman6> > [1..10] < [2..10]
03:07:33 <lambdabot>   True
03:08:07 <Guest61350> :t (<)
03:08:08 <lambdabot> forall a. (Ord a) => a -> a -> Bool
03:10:19 <Guest61350> It's not clear to my why (<) works both with an element an a list.
03:12:46 <doserj> because of an instance Ord a => Ord [a]
03:13:36 <Axman6> @instances Ord
03:13:37 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:14:45 <Guest61350> doserj, ok how can I make an Ord from smaller?
03:16:32 <doserj> @src Ord
03:16:32 <lambdabot> class  (Eq a) => Ord a  where
03:16:33 <lambdabot>     compare      :: a -> a -> Ordering
03:16:33 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
03:16:33 <lambdabot>     max, min         :: a -> a -> a
03:16:53 <Axman6> @src (<)
03:16:53 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
03:17:29 <doserj> it is sufficient to define compare or (<=)
03:18:08 <ivanm> better to define compare if you can
03:18:09 <doserj> but [a] is already an instance or Ord, so you cannot define your own
03:18:22 <ivanm> as it can be more efficient
03:18:33 <ivanm> doserj: so, just newtype it! :p
03:18:42 <doserj> yep
03:19:16 <Guest61350> ok thx everyone I will dive in the books now
03:19:34 <ivanm> Guest61350: ouch, that'll be painful
03:19:42 <ivanm> isn't water the preferred medium for diving into?
03:20:03 <Guest61350> o o my englis is bad I'm afraid
03:20:04 * doserj prefers milk (or money...)
03:20:26 <ivanm> doserj: ala uncle scrooge of disney fame? ;-)
03:20:46 <doserj> yep :)
03:20:56 <hotaru2k3> i'd think diving into money would be painful...
03:21:27 <doserj> I wouldn't mind the pain :)
03:22:16 <ivanm> hotaru2k3: notes is preferable
03:23:00 <Axman6> s/is/are
03:23:13 <ivanm> true
03:23:42 <Axman6> goodness me, you'd think they never taught you guys english up there :P
03:24:09 * Axman6 was never taught typing very well, so he makes a lot of typos though
03:24:33 <ivanm> Axman6: I was changing what I was saying in mid-type
03:24:40 <ivanm> and didn't bother changing what I'd already typed :s
03:24:56 <McManiaC> =)
03:25:06 <Axman6> yeah, i need to stop doing that, never works out well. i forget what i've written too banana split
03:25:12 <McManiaC> haskell is such a lovely language once it works :))
03:25:26 <Axman6> McManiaC: it always works, it's you who doesn't :o
03:25:27 <Axman6> :P
03:25:39 <McManiaC> Axman6: thats what i meant :P
03:25:55 <ivanm> Axman6: s/doesn't/don't/ ;-)
03:25:59 <McManiaC> once "my programm" works
03:26:13 <Axman6> ivanm: no, doesn't
03:26:17 <Axman6> i think
03:26:23 <Axman6> hmm, maybe you are right
03:26:51 <ivanm> since there's an implicit (++ " work")
03:26:51 <hotaru2k3> "you" is weird in english
03:27:39 <hotaru2k3> mostly because it used to be plural
03:27:51 <Axman6> no doesn't works
03:28:13 <Stinger> don't doesn't
03:28:27 <Stinger> or does it
03:28:27 <Axman6> 'it's you who doesn't work', not 'it's you who don't work'
03:28:30 <ivanm> Axman6: expand the contraction
03:28:47 <Axman6> yeah, it's you who does not work
03:29:00 <Axman6> see?
03:29:13 <ivanm> "it's you who do not work"
03:29:30 <ivanm> ^^ I think that one is slightly more grammatically correct
03:29:40 <Stinger> sounds worse to me
03:30:01 <Axman6> me too
03:30:20 <ivanm> eh, southerners *shrug*
03:30:43 <Peaker> "its you who don't work" is ok for plural "you" I think
03:30:47 <hotaru2k3> the subject of "do"/"does" in that sentence is "who", the antecedent of which is "it"
03:31:16 <Axman6> for those thinking this is off topic, we're talking about haskell, and a language, so s'all good
03:31:21 <Axman6> >_>
03:31:31 <hotaru2k3> if you use "do" instead of "does", you should use "they're" instead of "it's"
03:31:54 <Axman6> there we go
03:32:11 <McManiaC> Axman6: s/haskell, and // :P
03:32:27 <Stinger> cop that North boy
03:32:58 <Axman6> i've always been pretty good at english, but not knowing why what i was saying is actually correct (my mum's got a degree in english, and has always brought me up speaking well)
03:51:25 <ordnungswidrig> re
03:55:35 <blackh> I have *finally* figured out how to use Monad ((->) r. This has eluded me for a long time!
03:57:59 <ivanm> blackh: how?
03:58:21 <blackh> will turn this into a one-liner...
03:58:50 <mk15> hi, im doing some opengl programming in haskell, and my compiler is complaining im trying to use a GLuint as an int....how would I "cast" a GLunit to an int?
03:58:57 <blackh> @let monadr = do { x <- (5+) ; return $ "The answer is "++show x }
03:58:57 <lambdabot>  Defined.
03:59:07 <ivanm> @hoogle GLunit
03:59:07 <lambdabot> No results found
03:59:10 <blackh> > monadr 100
03:59:11 <lambdabot>   "The answer is 105"
03:59:20 <ivanm> blackh: cool!
03:59:23 <blackh> :t monadr
03:59:24 <lambdabot> forall t. (Num t) => t -> [Char]
03:59:30 <ivanm> so it' becomes function composition, etc.
03:59:32 <mk15> ivanm: i mean GLuint
03:59:38 <ivanm> @hoogle GLuint
03:59:38 <lambdabot> No results found
03:59:39 <mauke> mk15: if that's an integer type, try fromIntegral
03:59:44 <blackh> ivanm: Brilliant eh! Wonderful to have it figured out finally!
04:00:18 <ivanm> mk15: what are you using? glfw?
04:00:21 <ivanm> glut?
04:00:32 <ivanm> OpenGL?
04:00:34 <ivanm> OGL?
04:00:42 <ivanm> there's heaps of opengl packages on hackage :s
04:01:07 <blackh> And if you want to just get the value of the argument, it's x <- id
04:01:31 <mk15> ivanm: im using Graphics.UI.GLUT
04:01:44 <mauke> blackh: also known as 'ask'
04:01:51 * ivanm guesses GLUT
04:01:55 <ivanm> @hoogle ask
04:01:56 <lambdabot> Control.Monad.Reader.Class ask :: MonadReader r m => m r
04:01:56 <lambdabot> Control.Monad.Reader.Class asks :: MonadReader r m => (r -> a) -> m a
04:01:56 <lambdabot> package baskell
04:02:04 <ivanm> baskell? wtf?
04:02:31 <blackh> mauke: I just tried, and 'id' is indeed interchangeable with ask. Wo-hoo!
04:02:47 <mauke> @src (->) ask
04:02:47 <lambdabot> ask = id
04:03:02 <ivanm> mk15: gah, Graphics.UI.GLUT is just a meta-module
04:03:08 <McManiaC> is there a general commentation rule? i saw a few files with "-- | description" etc?
04:03:20 <ivanm> McManiaC: hoogle
04:03:24 <ivanm> I mean haddock
04:03:26 <mauke> McManiaC: that's haddock markup
04:03:50 <ivanm> mk15: can you do ":i GLuint" in ghci and tell me which module it's from?
04:04:16 <McManiaC> ivanm: any quick link to read sth about it? ^^
04:04:25 <ivanm> @where haddock
04:04:25 <lambdabot> http://www.haskell.org/haddock/
04:04:29 <ivanm> ^^ somewhere there
04:04:34 <McManiaC> ok
04:05:00 <ivanm> McManiaC: basically, use -- | to start the documentation for a function/module (each new line is just --, or else use {- | ... -} )
04:05:29 <ivanm> use 'foo' to refer to a function/value foo, @foo@ to typeset code
04:05:37 * ivanm thinks that's all the main stuff
04:05:43 <McManiaC> ok cool
04:05:43 <mauke> /foo/
04:06:16 <ivanm> mauke: that's italics, isn't it?
04:06:30 <mauke> probably
04:06:30 <mk15> ivanm: type GLuint = GHC.Word.Word32   -- Defined in Graphics.Rendering.OpenGL.GL.BasicTypes
04:06:42 <mauke> I only know I have to escape \/etc\/foo\/bar
04:06:47 <ivanm> ahhh, it's a Word32
04:06:50 <ivanm> @hoogle Word32 -> Int
04:06:50 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
04:06:51 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
04:06:51 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
04:06:54 <ivanm> heh
04:07:03 <ivanm> mk15: OK, use fromIntegral IIRC
04:07:14 <ivanm> > fromIntegral (10 :: Word32) :: Int
04:07:15 <lambdabot>   10
04:07:25 <ivanm> mauke: heh
04:07:33 <ivanm> at least you don't have to escape '
04:07:34 <mk15> ivanm: thank you :)
04:07:39 <ivanm> since 'this'' works
04:07:42 <ivanm> mk15: no worries
04:07:54 <ivanm> mk15: though mauke did say to try fromIntegral before ;-)
04:08:34 <mk15> ivanm: I did but I didnt use the syntax correctly...thanks mauke :)
04:08:49 <ivanm> mk15: heh
04:08:52 <ivanm> @type fromIntegral
04:08:53 <lambdabot> forall a b. (Num b, Integral a) => a -> b
04:09:02 <ivanm> @instances Integral
04:09:02 <Peaker> What's a Network.Socket.ProtocolNumber and defaultProtocol?
04:09:03 <lambdabot> Int, Integer
04:09:13 <ivanm> @hoogle defaultProtocol
04:09:14 <lambdabot> No results found
04:09:17 <ivanm> *shrug*
04:09:21 <Peaker> defaultProtocol documentation says "This is the default protocol for a given service. "
04:09:21 <ivanm> Peaker: from what library?
04:09:24 <ivanm> lol
04:09:25 <Peaker> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html#v%3AdefaultProtocol
04:10:06 <ivanm> Peaker: my guess if you don't specify anything, that's a "this won't do anything wrong" value
04:10:30 <ivanm> Peaker: at the top of that module it suggests you examine C/Unix docs
04:10:35 <ordnungswidrig> pfff cabal with NTML auth on proxy doesn't work... :-(
04:10:41 <ivanm> "consult your favourite Unix networking book"
04:10:43 <Peaker> ivanm: I forgot C sockets had a protocol number
04:10:53 <Peaker> ivanm: I used Python socket abstractions for so long I got spoiled :)
04:11:00 * ivanm has no idea what sockets are, so can't help much :s
04:11:04 <ivanm> Peaker: heh
04:12:47 <Peaker> ivanm: sockets are one side of a network channel. Sort of a virtual communication port
04:13:04 <ivanm> and what are ports? :p
04:13:26 * ivanm has always seen the term "ports" thrown around, but even with wikipedia's help never worked out wtf they are :s
04:13:29 <raxas> Peaker: /etc/services
04:13:49 <mauke> ivanm: you can have multiple programs using the network on a single machine/ip address
04:13:55 <ivanm> yup
04:13:57 <Peaker> raxas: its not that kind of protocol number -- its just a redundant parameter to "socket", or at least its redundant when using AF_INET or AF_INET6
04:14:02 <mauke> ivanm: they run on different ports
04:14:24 <ivanm> yes... but what _are_ ports?
04:14:26 <mauke> e.g. web servers are typically found on port 80
04:14:28 <mauke> numbers
04:14:33 <mauke> 16-bit integers
04:14:39 <ivanm> it's not like there's thousands of physical slots on the back of my computer! ;-)
04:14:56 <ivanm> mauke: virtual addresses/partitioning?
04:14:57 <quicksilver> it allows you to have 65 thousand connections per IP address
04:14:59 <quicksilver> that's the point.
04:15:00 <mauke> it's just a field in network packets that tells the OS which program to deliver the data to
04:15:19 <Peaker> a socket does not really correspond to a TCP or UDP port, which is likely what you mean by "port" being thrown around. I meant a different port, like a physical jack for communication, except its virtual.  What it basically means is that it can be connected to other jacks(sockets) to communicate, or send stuff to other such sockets without connecting, or broadcast stuff to every socket that is listening to such broadcasts, etc
04:15:27 <vixey> If Haskell is so good, how come it’s free?
04:15:30 <mauke> ports are a layer 4 concept IIRC
04:15:57 <Peaker> Yeah, though I find the layer numbering silly
04:16:04 <ivanm> vixey: because most math/CS academics (at least of the old school) think knowledge belongs to the world?
04:16:11 <Peaker> There are many ways to layer stuff with various levels of granularity
04:16:38 <Peaker> quicksilver: a lot more -- a connection is a quadruple ip/port/ip/port, not just one port
04:16:47 <Peaker> not just (ip,port) that is
04:16:52 <ivanm> mauke/quicksilver/Peaker: so it's just a virtual identification thing?
04:17:00 <maltem> ivanm, and because there's enough money at MS research's
04:17:01 <Peaker> ivanm: yeah, sort of
04:17:19 <ivanm> maltem: well, Haskell predated SPJ, etc. working at MSR, did it not?
04:17:28 <mauke> ip addresses aren't really real either :-)
04:17:32 <ivanm> mauke: heh
04:17:44 <maltem> ivanm, well sure, but MSR is the reason for the current state of GHC
04:17:47 <ivanm> so it's a virtual partitioning of a virtual adress? ;-)
04:18:00 <ivanm> maltem: indirectly, yes
04:18:06 <Peaker> ivanm: a socket is associated with a particular specific protocol like TCP, UDP or local "unix domain socket".  These different kinds behave differently
04:18:24 <ivanm> since it lets SPJ, etc. avoid the tedious student, etc. stuff and just get on with working on ghc for the rest of us :p
04:18:38 <maltem> right :)
04:18:52 <Peaker> ivanm: a single socket is associated with a single virtual address, yes, but the virtual address identifier can be changed dynamically
04:18:57 <hotaru2k3> this is why we should all be using plan 9
04:19:13 <ivanm> hotaru2k3: hmmm?
04:19:17 <ivanm> isn't Plan 9 dead?
04:19:39 <Peaker> ivanm: Ip
04:19:40 <Peaker> oops
04:19:43 <ManateeLazyCat> Have anyone compile gtk2hs (darcs version) success with GHC 6.10.2 ?
04:19:57 <hotaru2k3> ivanm: no, it's far from dead
04:20:19 <ivanm> ManateeLazyCat: not darcs...
04:20:27 <ivanm> but I have compiled the latest released version
04:20:31 <Peaker> ivanm: IP addresses are more physical than virtual (in the sense they must correspond to the layout of the network).  The ports "inside" an IP are virtual and sockets (at least TCP and UDP ones) are associated with a TCP or UDP port to work
04:20:45 <ivanm> the only problem I had was with haddock, since mtl and transformers both have a module with the same name...
04:20:56 <ivanm> Peaker: *nod*
04:21:00 * maltem was going to answer positively to ManateeLazyCat, then realized I'm still with 6.10.1 :/
04:21:53 <ManateeLazyCat> ivanm: You mean gtk2hs-0.10.0 can works with GHC 6.10.2?
04:22:03 <Peaker> ivanm: once you create a socket for a specific protocol (e.g UDP socket), you can "bind" it to a specific address [or let it be auto-bound by the OS], then you can connect/send messages to other sockets by specifying their IP/port or you can listen in for connections/messages from other sockets
04:22:15 <ivanm> ManateeLazyCat: yes
04:22:28 <ManateeLazyCat> ivanm: Thanks, i try it. :)
04:22:36 <ivanm> Peaker: I might leave all that to people who actually write networking stuff, and trust them to do it ;-)
04:22:47 <Peaker> ivanm: writing networking stuff is a lot of fun :)
04:22:55 <ivanm> ManateeLazyCat: again, haddock won't work if you also have transformers installed since the Makefile is dumb
04:23:05 <ivanm> dcoutts: hurry up and cabalise gtk2hs already! :p
04:23:13 <Peaker> one of the most fun projects I had was a real-time game UDP-based protocol :)
04:23:19 <georgehorse> i wouldn't say plan 9 is dead, but I think it's a lot less alive than some would want it to be.
04:23:34 <Peaker> I think Plan 9 is nicer than Unix but still the wrong approach to OS's :)
04:23:52 <ivanm> Peaker: so what's the right approach?
04:24:09 <ManateeLazyCat> ivanm: So just haddock can't work?
04:24:10 <ManateeLazyCat> ivanm: And have other problem?
04:24:14 <Peaker> ivanm: I'd like a statically typed language RTS to be the OS
04:24:29 <Peaker> ivanm: And get safety from the language, rather than from the CPU/MMU
04:24:30 <ivanm> ManateeLazyCat: everything else seemed to work IIRC
04:24:39 <ivanm> oh, right, enabling profiling failed for me when I tried
04:24:49 <ivanm> Peaker: heh
04:24:50 <ManateeLazyCat> ivanm: I see, thanks.
04:24:59 <ivanm> ManateeLazyCat: no worries ;-)
04:25:30 <Peaker> ivanm: I also think an OS should have no file system (a user "service" or "app" can be a database that others can communicate with), and everything should simply be orthogonally persistent
04:25:52 <Peaker> ivanm: Also, no ACL's, user IDs and ambient authority -- simple capabilities instead
04:26:28 <hotaru2k3> Peaker: how about inferno?
04:26:32 <ivanm> *shudder* everything in a databse? :s
04:26:37 <Peaker> hotaru2k3: haven't heard of it - what's that?
04:26:52 <hotaru2k3> Peaker: http://en.wikipedia.org/wiki/Inferno_(operating_system)
04:26:52 <Peaker> ivanm: A file system is a kind of database, a poor kind :)
04:26:55 <Peaker> ivanm: not very usefully searchable, etc
04:27:00 <ivanm> is there a list-like data structure which I can map over whilst updating?
04:27:36 <ivanm> more specifically, I need to be able to replace a value in this data structure with a "list" of values
04:28:06 <Peaker> hotaru2k3: they still seem to be using ACL's, user ids, and file system persistency
04:28:17 <ivanm> I can do manual looping if necessary, but I'd prefer to avoid having to do foo (x:xs) = ... foo (xs' ++ xs) :s
04:28:32 <Peaker> ivanm: updating -- as in destructively?
04:28:47 <ivanm> Peaker: pure is preferred
04:28:56 <ivanm> I try to avoid using ST, etc.
04:29:10 <Peaker> ivanm: Do you know roughly the type you need?
04:29:17 <ivanm> I'd use lists, but I'm worried that continually doing ++ to the front will be less than efficient
04:29:26 <ivanm> Peaker: something like a list
04:29:31 <Peaker> ivanm: DList is a list with efficient (++)
04:29:34 <hotaru2k3> Peaker: the inferno file system, like the plan 9 file system, is very different from the unix file system
04:29:53 <Peaker> hotaru2k3: do things persist only if they are mmap'd or write'n explicitly into a file?
04:30:04 <ivanm> Peaker: yeah, but I then need to map over the updated "list"
04:30:07 <Peaker> hotaru2k3: and in such writes, you better not write any pointers?
04:30:11 <ManateeLazyCat> ivanm: Now gtk2hs-0.10.0 compiling.... Sweet... :)
04:30:22 <Peaker> ivanm: I am not sure, but I think DList should fit the bill
04:30:37 * ivanm goes off to have a look-sie
04:31:43 <ivanm> Peaker: it looks ugly to "map" over whilst adding elements
04:31:45 <hotaru2k3> Peaker: how else would you have things persist? having the operating system automatically write *everything* to disk?
04:32:23 <ivanm> Peaker: admittedly, the ++ calls shouldn't be too bad because I'm always adding them to the front, not the back
04:32:38 <ivanm> which IIRC is the main usage for dlists (continual appending)
04:32:44 <Peaker> hotaru2k3: there are very efficient ways to automatically write everything - I can explain one of them
04:32:59 <Saizan_> ivanm: (xs ++) is O(length xs)
04:33:07 <vixey> ivanm: don't avoid ST, it is wonderful
04:33:28 <vixey> (of course don't just use ST all the time for no good reason either)
04:33:29 <ivanm> Saizan_: yes, but if I then have to "map" over the elements anyway...
04:34:09 <georgehorse> re: filesystem as database, i'm reminded of this: https://bugs.launchpad.net/ubuntu/+source/linux/+bug/317781/comments/45
04:34:29 <Saizan_> ivanm: yeah, if you only prepend the overall cost is still linear, so it's not that bad
04:34:31 <georgehorse> "The final solution, is we need properly written applications and desktop libraries. The proper way of doing this sort of thing is not to have hundreds of tiny files in private ~/.gnome2* and ~/.kde2* directories. Instead, the answer is to use a proper small database like sqllite for application registries"
04:34:38 <ordnungswidrig> georgehorse: hehe
04:34:43 <hotaru2k3> i've tried persistent operating systems before... they were all pretty slow, and every single one eventually got into a state where things were completely broken, and would stay broken after rebooting
04:34:48 <Peaker> hotaru2k3: Basically you get accounting of which pages were modified (dirty) for free from the MMU, and you can write only those. You can do that in the background just like its already done (swapping), and even allows you to use a fast portion of the disk not just as swap space but as a cache of slower areas of the disk.
04:34:53 <ordnungswidrig> georgehorse: windows registry?
04:35:00 <Peaker> hotaru2k3: Which ones did you try?
04:35:42 <Peaker> hotaru2k3: you might want to implement a "restart" thingie for broken software - that still doesn't mean removing the burden of persistency from almost all user applications is not a good idea
04:35:44 <ivanm> what I'm doing is (if I'm reading this algorithm correctly) is going through the list of elements, sometimes replacing the first value in-situ with a list of values and then recursing on the tail of the list
04:35:57 <georgehorse> ordnungswidrig: just something i was reminded of
04:35:59 <hotaru2k3> i don't remember, it was years ago... i tried three of them, all of them were fairly new at the time and are probably long dead by now
04:36:17 <Saizan_> ivanm: that looks like concatMap
04:36:36 <ivanm> Saizan_: yes, but concatMap won't use the new values when mapping
04:37:04 <ordnungswidrig> http://twan.home.fmf.nl/blog/haskell/non-regular1.details
04:37:12 <ordnungswidrig> How is this different from HLists?
04:37:13 <ivanm> e.g. foo (x:xs) = if (p x) then x' : foo (xs' ++ xs) else x : foo xs
04:37:24 <ivanm> ordnungswidrig: what's an HList?
04:37:33 <ordnungswidrig> Heterogeneous lists
04:37:42 <Peaker> hotaru2k3: Have you tried KeyKOS or EROS-OS?
04:37:43 <ivanm> ordnungswidrig: aka [a] ?
04:37:54 <Peaker> hotaru2k3: I think they are the only ones that attempted efficient orthogonal persistency
04:37:54 <ordnungswidrig> ivanm: remeber my change of a table access api?
04:38:00 <Peaker> hotaru2k3: EROS improved on that of KeyKOS further
04:38:01 <ivanm> *shudder*
04:38:05 <Badger> Peaker: the latter sounds like mature content :P
04:38:08 <ordnungswidrig> ivanm: no, a list of _different_ types
04:38:32 <ivanm> ordnungswidrig: *double shudder*
04:38:34 <wli> Existential quantification?
04:38:38 <Peaker> Badger: well, it was a research project, I think he moved the ideas from there into a "real OS" (Coyotos) which he's writing in a C replacement language he created (BitC)
04:38:40 <ordnungswidrig> wli:?
04:38:51 <Badger> replacing C/ the very thought
04:38:54 <Badger> *?
04:39:09 <hotaru2k3> Peaker: i think KeyKOS may have been one of the ones i tried
04:39:50 <Peaker> hotaru2k3: KeyKOS was just for the IBM/360, I believe. Did you have one of those?
04:40:08 <Peaker> Badger: ?
04:40:17 <hotaru2k3> well then it wasn't one of them... i just remembered that one of them started with a "K"
04:40:26 <ivanm> Peaker: I'm wanting to do something like this, which isn't covered by concatMap: foo (x:xs) = if (p x) then x' : foo (xs' ++ xs) else x : foo xs where (define x' and xs')
04:40:37 <Badger> Peaker: nevermind me, I don't know any anyone is talking about. :)
04:40:48 <Saizan_> ordnungswidrig: it doesn't have so much in common with HList, because the types contained have a strong relationship to each other
04:41:09 <ordnungswidrig> Saizan_: i see
04:41:38 <ivanm> ordnungswidrig: in that FunList, you only have two types
04:41:45 <Peaker> ivanm: if xs' is small I think ++ should be ok there
04:42:09 <ivanm> *nod*
04:42:13 <ivanm> it probably won't be that big
04:44:42 <eu-prleu-peupeu> hi
04:44:51 <eu-prleu-peupeu> how do i apply a patch to a haskell package ?
04:45:49 <eu-prleu-peupeu> i have this patch for OpenGL that i want to apply to it before i install it on my system
04:46:05 <ivanm> eu-prleu-peupeu: send the patch to the maintainer
04:46:17 <Peaker> hotaru2k3: well, I think the approach of dumping dirty pages to disk in the background and "checkpointing" once in N minutes (N~=5) where you CopyOnWrite everything and dump the rest of the dirties to disk and mark it a stable snapshot should be really fast
04:46:35 <ivanm> eu-prleu-peupeu: Maintainer: Sven Panne <sven.panne@aedion.de>
04:46:41 <eu-prleu-peupeu> ivanm: i think the maintainer is aware of the patch, btw its no my patch, i found it on the internets
04:46:56 <Peaker> hotaru2k3: Also, I think that there's a probable move towards cheap persistent memories -- so non-persistent memory might not be an issue anymore anyway
04:47:06 <ivanm> eu-prleu-peupeu: well, it's up to the maintainer to apply the patch
04:47:11 <Saizan> eu-prleu-peupeu: what kind of patch?
04:47:18 <ivanm> http://www.haskell.org/haskellwiki/Opengl
04:47:21 <Saizan> ivanm: maybe he wants to apply it for himself?
04:47:26 <ivanm> ^^ maybe send the patch to the darcs repo listed here
04:47:30 <ivanm> Saizan: hmmm... could be
04:47:37 <Peaker> hotaru2k3: in either case I don't think its right to expose persistency issues to applications.. it too complicated to get right anyway.  I think very few apps are truly capable of dealing with crashes during writes. Especially as unix/plan9/etc have a difficult time guaranteeing write ordering between independent files, etc
04:47:53 <eu-prleu-peupeu> Saizan: this patch: http://code.haskell.org/~bkomuves/
04:48:16 <moonlite> does anyone know if there are docs for regex-tdfa? Couldn't find on hackage, the webpage linked from hackage or hoogle...
04:48:17 <eu-prleu-peupeu> the last link of the page is the patch
04:48:51 <moonlite> id like to compile a regex and then perform something like match :: String -> Bool
04:49:30 <Saizan> eu-prleu-peupeu: that's a darcs patch, you can darcs get the hopengl repo and then run "darcs apply path/to/patch" from that directory
04:49:43 <eu-prleu-peupeu> okey
04:49:44 <moonlite> (eh sorry, match :: Regex -> String -> Bool :))
04:50:03 <ordnungswidrig> quicksilver: ping
04:50:09 <eu-prleu-peupeu> its a huge patch, i wonder why it isn't applyed to the opengl package ? :/
04:50:17 <eu-prleu-peupeu> it seems to fix quite some stuff
04:50:49 <ivanm> eu-prleu-peupeu: 1) the maintainer _isn't_ aware of it, 2) it's _bad_
04:50:53 <eu-prleu-peupeu> shaders, fbo's, work-arround glu bugs
04:51:05 <eu-prleu-peupeu> 3) the maintainer is lazy  :)
04:51:17 <eu-prleu-peupeu> ill just mail it to him then
04:51:44 <eu-prleu-peupeu> something tells me i wont get an answer for a long long time :P
04:51:45 <ivanm> eu-prleu-peupeu: "bad" could mean: 1) regressions, 2) bugs, 3) scalability, 4) platform/distribution issue, 5) poor coding style
04:52:30 <eu-prleu-peupeu> yes, im aware, thanks
04:52:31 <SamB> or juste 6) too big to easily review
04:53:53 <SamB> also, the maintainer could be busy or dead, perhaps
04:54:07 <eu-prleu-peupeu> SamB: im would bet on it :)
04:54:36 <SamB> but I think 6) is probably applicable
04:54:45 <eu-prleu-peupeu> i mean, by looking at the patch, some of this stuff seems pretty urgent bug fixes
04:54:56 <eu-prleu-peupeu> fbo's, shaders, etc...
04:55:00 <SamB> I mean, why is it just one patch ?
04:55:20 <SamB> eu-prleu-peupeu: what happens without the patch? SIGSEGV?
04:55:21 <ivanm> SamB: well, that _could_ come under 5)...
04:55:28 <eu-prleu-peupeu> i haven't tested it
04:55:56 <eu-prleu-peupeu> the binding just sucks
04:56:00 <eu-prleu-peupeu> and thats a sad true
04:56:03 <eu-prleu-peupeu> i mean
04:56:04 <SamB> ivanm: I think the way you send patches doesn't count as coding style precisely
04:56:06 <eu-prleu-peupeu> look at this:
04:56:06 <ivanm> eu-prleu-peupeu: in what way?
04:56:11 <SamB> development style, maybe
04:56:13 <ivanm> SamB: it's related though, surely
04:56:32 <eu-prleu-peupeu> -      glTexImage3DEXT
04:56:32 <eu-prleu-peupeu> +      glTexImage3D  -- glTexImage3DEXT
04:56:32 <eu-prleu-peupeu> +                    -- was promoted to core in OpenGL 1.2, and these days the EXT is usually not supported
04:56:39 <SamB> coding style is about the way the source code looks at each point in the process, I believe
04:56:44 <Saizan> moonlite: send a mail to the maintaner telling him that the haddock docs can't be built
04:57:03 <ivanm> SamB: poor coding style usually implies poor developmental style, surely
04:57:14 <eu-prleu-peupeu> did you guys even look at the patch ? :/
04:57:23 <ivanm> eu-prleu-peupeu: well, I didn't...
04:57:31 <quicksilver> ordnungswidrig: hello?
04:57:44 <eu-prleu-peupeu> i could keep going on with things like the one i pasted here
04:57:44 <ivanm> moonlite: haddock-2 doens't like "-- ^" style annotations for some reason
04:57:48 <ivanm> so the tdfa docs fail
04:57:50 <moonlite> saizan: ah yeah. I'm browsing code now but should obviously do that too.
04:58:02 <ivanm> AFAIK, however, you should just use the regex-base interface anyway
04:58:13 <eu-prleu-peupeu> anyway, i sent an email to the maintainer
04:58:29 <eu-prleu-peupeu> and i have this feeling it will be a LOOONGGG time before he answers
04:58:36 <SamB> ivanm: I bet it's GHC's fault ;-P
04:58:38 <ivanm> eu-prleu-peupeu: could be the maintainer no longer needs opengl, so has no pressing need to know what changes there are/it should have
04:58:38 <ordnungswidrig> quicksilver: hi, yesterday you mentioned a design for my table columns spec using list of functions and existentials, remember?
04:58:42 <ivanm> SamB: oh? in what way?
04:58:49 <quicksilver> yes.
04:59:00 <quicksilver> eu-prleu-peupeu: the binding doesn't suck. You're talking utter rubbish.
04:59:02 <SamB> ivanm: GHC is now where the docstrings are parsed
04:59:14 <ivanm> SamB: yes, but IIRC it's not a parsing issue
04:59:19 <SamB> I think they wanted to shift more of the work back to haddock
04:59:22 <SamB> ivanm: oh
04:59:27 <quicksilver> eu-prleu-peupeu: hopengl is one of the most comprehensive and least buggy opengl bindings I've seen, and it works well on all three platforms. That's not bad.
04:59:32 <quicksilver> sure, it has missing features.
04:59:38 <ivanm> SamB: take it back, it might be
04:59:44 <quicksilver> I've never seen the authoer of that patch discuss it on the hopengl mailing list?
04:59:48 <ivanm> " parse error on input `-- ^ common prefix' "
04:59:52 <eu-prleu-peupeu> quicksilver: im talking based on what i saw on the patch
05:00:06 <ivanm> SamB: though this means that haddock won't necessarily work with other compilers :(
05:00:18 <SamB> so that haddock could extend the syntax by itself, with no GHC changes
05:00:21 <SamB> ivanm: I know that
05:00:38 <quicksilver> ordnungswidrig: sure, although I never fully understood your problem.
05:00:49 <ivanm> SamB: oh, I thought you said they wanted to shift it more to GHC :s
05:01:06 <SamB> no! other way round
05:01:25 <ivanm> quicksilver: I think his problem is that he needs a Gibbs-style (from NCIS) whack to the head :p
05:01:28 * ivanm ducks
05:01:30 <ordnungswidrig> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4131
05:02:15 <SamB> ... whoever is maintaining haddock has realized that having GHC parse the markup within haddock docstrings is undesirable since that makes it a lot harder to extend the markup
05:02:50 <quicksilver> ordnungswidrig: OK, I understand better than I did yesterday.
05:02:50 <ivanm> SamB: that's waern, isn't it?
05:02:52 <moonlite> ivanm: i should? What backend will that default to?
05:03:04 <SamB> ivanm: yeah, I think so
05:03:12 <ivanm> moonlite: AFAIK, you just import the tdfa module and the regex-base module
05:03:13 <SamB> I was going to say that but got distracted
05:03:23 <ivanm> SamB: why did they shift the parsing to ghc anyway?
05:03:35 <ordnungswidrig> quicksilver: so the table spec is basically a heterogenous list of col specs if the col specs isn't a adt, right?
05:03:37 <ivanm> moonlite: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-base
05:03:42 <SamB> I think so that GHC could resolve identifier references within the docstring
05:03:58 <ordnungswidrig> quicksilver: to be able to add col type later, the col spec must not be an adt
05:04:08 <Saizan> and because GHC kept extending haskell's syntax breaking haddock's parser
05:04:16 <SamB> it certainly isn't done in the Haskell parser, so it isn't that ...
05:04:29 <SamB> Saizan: I'm talking about after it extracts the docstrings
05:04:37 <SamB> it then goes on to parse the markup *inside* them
05:04:40 <Peaker> @pl (\f -> f x y)
05:04:40 <lambdabot> flip ($ x) y
05:04:41 <ivanm> moonlite: even more specifically, http://hackage.haskell.org/packages/archive/regex-base/0.93.1/doc/html/Text-Regex-Base.html
05:04:43 <quicksilver> ordnungswidrig: open column types at compile time does mean you need a typeclass + existential
05:05:01 <quicksilver> ordnungswidrig: no. A table spec is a plain list of column specs.
05:05:09 <SamB> which makes it a lot harder to add things to the markup
05:05:14 <ivanm> moonlite: so import Text.Regex.TDFA (I think, it isn't listed there for some reason) and use the docs from Text.Regex.Base
05:05:17 <Peaker> quicksilver: not necessarily a type-class, follow your first rule :)
05:05:37 <Peaker> quicksilver: you can use a record of functions on an existential -- or better, just a record of results of applying those functions to the existential, getting rid of the existential
05:05:38 <ordnungswidrig> Peaker: what instead of a type class?
05:05:54 <ordnungswidrig> Peaker: ok, do you have an example?
05:06:07 <SamB> but the tricky thing is to allow haddock to do the parsing of the docstrings, but still get GHC to resolve the identifiers in them
05:06:19 <moonlite> ivanm: aah got it.
05:06:25 <moonlite> thanks a lot!
05:06:27 <quicksilver> Peaker: true.
05:06:29 <ivanm> no worries
05:06:34 <ivanm> SamB: *nod*
05:07:12 <ivanm> SamB: so what did haddock-0.x use? haskell-src or something?
05:07:37 <ordnungswidrig> peaker: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4174#a4174
05:07:58 <Peaker> if I had: class Blah b where x :: b -> Int ; y :: b -> String          and:  (forall a. Blah a => a)   then I can instead have:   data Blah b = Blah { x :: b -> int ; y :: b -> String } ; and (forall a. (Blah a, a))   ;  and this can be translated to:  data BlahF = BlahF { x :: Int ; y :: String } ; type Blah b = b -> BlahF ; and then:  (forall a. (Blah, a))  and then you can just apply the a to the Blah and get (BlahF) -- no existential
05:08:11 <SamB> ivanm: I'm not sure
05:08:18 <SamB> possibly it's own parsing code
05:08:28 <ordnungswidrig> Peaker: cool. thanks
05:08:40 <SamB> if you look at http://www.haskell.org/ghc/docs/latest/html/libraries/ghc/HsDoc.html#t%3ALHsDoc you can see just how restrictive this way is
05:08:43 <quicksilver> Peaker: he can't just apply it.
05:08:48 <ivanm> SamB: yeah, looks like it did
05:08:51 <quicksilver> Peaker: he has lots of different 'a's
05:08:53 <quicksilver> one per row.
05:08:54 <quicksilver> that's the point.
05:09:19 <ivanm> SamB: heh, no idea what I'm looking at there :p
05:09:20 <Peaker> quicksilver: instead of holding [(forall a. (a, a->b))] you can hold [b]
05:09:34 * ivanm presumes HsDoc is the haddock API stuff?
05:09:44 <SamB> that's what GHC hands back to haddock right now
05:09:50 <ivanm> *nod*
05:09:50 <Saizan> Peaker: s/forall/exists/g :)
05:10:02 <Peaker> Saizan: point still holds :)
05:10:07 <quicksilver> Peaker: no, because you need to be able add new rows
05:10:21 <quicksilver> Peaker: and check they satisfy the requirements.
05:10:24 <quicksilver> it's one spec, many rows
05:10:28 <quicksilver> not one spec per row.
05:10:41 <SamB> the problem being that you can't add a new constructor (or the syntax that would be used in a haddock string to express it) without changing GHC
05:10:54 <quicksilver> I'm fairly sure this *is* a case for typeclasses.
05:10:56 <Peaker> ordnungswidrig, quicksilver: Maybe you can paste the whole thing?
05:11:03 <quicksilver> Peaker: there isn't a whole thing.
05:11:06 <quicksilver> it hasn't been written yet.
05:11:12 <quicksilver> ordnungswidrig did paste the spec though.
05:11:16 <Peaker> quicksilver: What's the difference between a type-class and a record of functions in the context of existentials?
05:11:27 <ordnungswidrig> peaker: there is no thig but the spec: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4131
05:11:31 <quicksilver> Peaker: the fact that GHC's type inference engine chooses the dictionary for you
05:11:38 <quicksilver> Peaker: which is precisely what ordnungswidrig wants here.
05:11:44 <kadaver> > ord 120
05:11:45 <lambdabot>       No instance for (Num Char)
05:11:45 <lambdabot>        arising from the literal `120' at <in...
05:11:52 <kadaver> > `ord` 120
05:11:53 <lambdabot>   <no location info>: parse error on input ``'
05:11:56 <Peaker> quicksilver: But the code that chooses a type knows the type and could choose a dictionary
05:11:57 <kadaver> how?
05:12:02 <Saizan> > chr 120
05:12:03 <lambdabot>   'x'
05:12:06 <SamB> it seems that the way it should be would be something more along the lines of (Env, String)
05:12:13 <Saizan> > ord 'x'
05:12:15 <lambdabot>   120
05:12:29 <quicksilver> Peaker: yes, but it's boilerplate to do so.
05:12:37 <quicksilver> probably.
05:12:41 <quicksilver> it depends on the exact implementation.
05:13:10 <SamB> where Env has the information that Haddock wants about bindings in the scope of the docstring, and String is just the content of the docstring
05:14:01 <SamB> and then Haddock would go back and ask GHC to resolve any identifiers referenced in the docstring after parsing the docstring itself
05:14:51 <quicksilver> Peaker: the technique of 'just applying' the functions is not a general technique for existentials.
05:14:58 <ordnungswidrig> quicksilver, peaker: thanks for now. I'll thinking about existentials and typeclasses on my trip to berlin.
05:15:16 <quicksilver> it only applies to something like show, or generally of the form exists a . (a,a -> b,a -> c,a -> d)
05:15:22 <quicksilver> which might as well be (b,c,d)
05:15:26 <xrfang> hi there, how to make haskell support unicode?  I try to do: main = print "<some chinese text here>", it print out the code in \12345 format
05:15:27 <Peaker> ordnungswidrig: I'm looking at your spec -- can you narrow it down though to just deal with the difficult existential part? I'm pretty sure the min/max string length is not necessary?
05:15:30 <quicksilver> however, in the general case you don't have that.
05:15:43 <quicksilver> exists a . (a, a -> a -> c)
05:15:46 <mauke> xrfang: that's what it's supposed to do
05:15:48 <SamB> ivanm: then, it would be much easier to add new markup ;-)
05:15:48 <quicksilver> for example.
05:16:17 <SamB> such as a way to indicate a summary line for a module within a package
05:16:17 <ivanm> SamB: \o/
05:16:18 <xrfang> mauke: but that's not human readable text, in a "real world" program, how to print out actual text?
05:16:20 <Peaker> quicksilver: what can you do with  exists a . (a -> a -> c)   except apply it with the same arg twice?
05:16:30 <mauke> xrfang: well, not with 'print'
05:16:35 <SamB> then we could display those down the right side of the table of contents
05:16:38 <quicksilver> well the point is here he has a whole column of values.
05:16:46 <xrfang> ok, mauke, thanks
05:16:47 <mauke> xrfang: System.IO.UTF8.putStr probably
05:16:51 <quicksilver> so it's more like exists a . ([a] , a -> a -> c)
05:16:55 <mauke> (that's in utf8-string)
05:16:56 <quicksilver> there are lots of permutations.
05:16:59 <quicksilver> I often have
05:17:08 <quicksilver> exists a . (a , a -> a)
05:17:17 <quicksilver> and then you can apply it any number of times, and stuff it back in.
05:17:29 <Peaker> quicksilver: I agree not all existentials can be got rid of - but the  exists a . ([a], a->a->c) can be
05:18:00 * SamB wonders where he can get refactoring tools for Turbo Pascal
05:18:01 <xrfang> mauke, System.IO.UTF8... not in scope...
05:18:11 <quicksilver> by storing every binary combination? that's not very sensible it is?
05:18:12 <mauke> xrfang: did you import System.IO.UTF8?
05:18:23 <Peaker> quicksilver:  exists a . (a, a -> a, a -> b)  may be interesting (otherwise you can apply it any number of times, but not get anything interesting), right?
05:18:28 <xrfang> I am trying to figure out which one to import :) let me try
05:18:38 <Peaker> quicksilver: no, by creating a function, for example,  f :: Int -> c or such
05:18:52 * SamB supposes he could try writing his own in Haskell
05:18:53 <Peaker> quicksilver: whatever is efficient for the function to generate the permutation
05:18:58 * quicksilver nods
05:19:06 <dolio> exist a. (a, a -> a) is roughly equivalent to ().
05:19:11 <SamB> shouldn't be too hard to do ;-)
05:19:11 <xrfang> cannot find module... ok, I will give up for now, and continue tutorial, thanks mauke
05:19:16 <quicksilver> yes, more like exists a . (a, a->a, a-> IO ())
05:19:17 <ivanm> SamB: your own what?
05:19:19 <quicksilver> in practical cases.
05:19:23 <ivanm> haddock replacement? :p
05:19:27 <bastl> does someone know a good reference for performance of haskell vs c ?
05:19:27 <SamB> ivanm: Turbo Pascal refactoring tool
05:19:35 <Peaker> quicksilver: so exists a. (a, a -> a, a -> b) is equivalent to (Int -> b)
05:19:36 <dolio> exists a. (a, a -> a, a -> b) can be encoded as the infinite list of possible observations.
05:19:37 <ivanm> oh, missed that comment of yours
05:19:37 <SamB> you must have missed that /me ;-)
05:19:37 <mauke> xrfang: then you need to install the utf8-string package :/
05:19:42 <ivanm> SamB: do I dare ask why? :s
05:19:48 <ivanm> isn't TB dead?
05:19:56 <ivanm> (since it was for _DOS_!)
05:19:58 <Peaker> quicksilver: or just [b]
05:20:02 <ivanm> s/TB/TP/
05:20:03 <SamB> TP, and perhaps so
05:20:08 <xrfang> mauke: I don't know how to install package, but I am not in a hurry -- I am completely haskell newbie :p
05:20:11 <xrfang> later...
05:20:14 <mauke> oh, ok
05:20:29 <dolio> More translucent existentials like exists a. ([a], a -> b) are the more pain causing ones.
05:20:38 <SamB> but I'm trying to reverse ZZT since Tim Sweeney was careless enough to lose the source
05:20:42 <Peaker> dolio: (Int -> b) ?
05:20:52 <mauke> anyway, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4175#a4175 works here
05:20:55 <Peaker> dolio: or [b] ?
05:21:02 <Peaker> dolio: I mean, why is that painful?
05:21:02 <SamB> and it would be nice to be able to rename fields and variables once I figure out what they are for, no?
05:21:13 <ivanm> to install a package (for haskell newbies): Step 1: stop being a newbie; Step 2: as you are no longer a newbie, you should already know how to do this! ;-)
05:21:40 <dolio> Peaker: Assuming there are any as in the list, you can build as many other lists as you want, shuffling and duplicating elements and such.
05:21:52 <dolio> And then turn some into bs and so on.
05:22:25 <dolio> So representing the full range of possible observations isn't easy.
05:22:35 <Peaker> dolio: I still don't understand -- if you store [b] instead of ([a], a->b) -- what do you lose?
05:23:10 <Peaker> dolio: you can shuffle duplicate the b's instead of the a's
05:23:26 <dolio> Yeah, that's probably not that bad.
05:24:05 <dolio> If you added, say, an a -> a -> a, that'd be worse.
05:24:12 <Peaker> The only convincing existential case I know of (which is hardly to say there aren't many more, I just don't know any) -- is the ST case
05:24:34 <Peaker> @type runST
05:24:35 <lambdabot> forall a. (forall s. ST s a) -> a
05:24:35 <Acteum> did someone say ZZT???!!
05:24:42 <Badger> They did now!
05:24:47 <dolio> That's not an existential.
05:24:52 <Saizan> would you really store all the permutations in [b] ?
05:25:29 <SamB> Acteum: I did!
05:25:36 <SamB> I said I'm trying to reverse it
05:25:43 <mauke> Acteum: trigraph detected
05:26:31 <Peaker> dolio: well, maybe I should say "nested foralls" -- are there uses of "forall" that aren't tied to existentials?
05:26:35 <Acteum> SamB: what do you mean reverse it? turn all the ruffians into players and vice versa?
05:27:02 <dolio> Saizan: His point was that no matter how much you shuffle and duplicate things, the only thing you can do other than that is turn them into bs, so you might as well just have the original list turned into bs.
05:27:05 <SamB> Acteum: create some source code again
05:27:45 <Saizan> dolio: yeah, but that does convince me that we need existentials, since i'd never accpet to use that encoding instead
05:27:49 <Acteum> SamB: i'm sure that has already been attempted, but not in haskell certainly
05:28:14 <SamB> Acteum: what? I'm not doing the work in Haskell ;-P
05:28:28 <Acteum> and why not? =P
05:28:33 <SamB> I don't know of anyone else who just tried to write the same thing in Turbo Pascal again ...
05:28:48 <Saizan> dolio: ah, wait, i was thinking of the case where we've an (a -> a) too
05:28:58 <Acteum> ZZT has so many weird bugs and tricks that you need to replicate
05:29:01 <dolio> Yeah, that'd be bad.
05:30:06 <xrfang> how to convert a "Just x" to x?
05:30:09 <quicksilver> dolio, Saizan : my real examples are things like evolving particle systems.
05:30:16 <mauke> xrfang: pattern matching
05:30:23 <quicksilver> you don't really want to replace all the existential particles with all their possible future evolutions.
05:30:27 <xrfang> I wrote:
05:30:33 <xrfang> largest [] = Nothing
05:30:41 <SamB> xrfang: well, you could case over it, you could use the "maybe" function, or you could use the unsafe function "fromJust"
05:30:46 <mauke> xrfang: btw, I wrote http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4175#a4175 and it works here :-)
05:30:48 <xrfang> largest (x:xs) = max (Just x) (largest xs)
05:31:15 <xrfang> tks
05:31:24 <mauke> xrfang: largest (x:xs) = case largest xs of Nothing -> Just x; Just y -> Just (max x y)
05:32:06 <xrfang> thanks mauke
05:32:26 <RayNbow> why not wrap maximum in a Just?
05:32:52 <RayNbow> largest [] = Nothing ; largest xs = (Just . maximum) xs  -- something like this?
05:33:04 <xrfang> I must install some package mauke :)
05:33:21 <ivanm> RayNbow: you mean in general?
05:33:31 <McManiaC> can i do something like "map (x <- f a) [..." ?
05:33:34 <xrfang> RayNbow, what if I want to compare the max with some other number, which is not Just...
05:33:39 <mauke> McManiaC: no, what would that do?
05:33:59 <SamB> xrfang: could continue working in Maybe monad ...
05:34:13 <xrfang> ok
05:34:27 <McManiaC> mauke: i have something like do { x <- readfile ... ; x <- set x "key" "value" ; x <- set... }
05:34:30 <mapreduce> Howdy.  How would you iterate over, say, 0..100000000 in a psuedorandom order, without having to have all 100000000 numbers in memory at once?
05:34:36 <McManiaC> i wanna map a list of (key,value) pairs over it
05:35:34 <ivanm> mapreduce: doStuff $ sortRand [0..10000000000000]
05:35:37 <quicksilver> mapreduce: depends how pseudorandom you need.
05:35:38 <McManiaC> its import to change the same x everytime
05:35:53 <opqdonut> ivanm: sortRand will keep them all in memory, right?
05:36:25 <ivanm> opqdonut: depends on how you do it...
05:36:36 <ivanm> if you use a random less than, it might not
05:36:36 <mapreduce> @src sortRand
05:36:36 <lambdabot> Source not found.
05:36:41 <ivanm> mapreduce: I made it up ;-)
05:36:44 <mapreduce> heh
05:36:53 <quicksilver> mapreduce: you can probably devise deterministic paths which are hard to predict. multiples of a large prime taken module 1000000
05:37:00 <ivanm> mapreduce: basically, flip a coin if v1 <= v2 or not
05:37:20 <quicksilver> ivanm: it's not obvious to me  you can implement that without quite a large expected memory usage. n/2 or so.
05:37:32 <mapreduce> quicksilver: And can I guarantee that they'll cover all numbers in the range?
05:37:55 <quicksilver> mapreduce: there are some number theoretic properties which guarantee that in some cases, yes.
05:37:57 <mapreduce> [and preferably none twice]
05:38:00 <mauke> McManiaC: readfile ... >>= \x -> foldM (\x (k,v) -> set x k v) x kvs ?
05:38:16 <mapreduce> I see, thanks.
05:38:48 <McManiaC> mauke: hey, that could work :) thx
05:39:20 <quicksilver> > take 20 $ map (`mod` 20) [7,14..]
05:39:21 <ivanm> quicksilver: yeah
05:39:22 <lambdabot>   [7,14,1,8,15,2,9,16,3,10,17,4,11,18,5,12,19,6,13,0]
05:39:32 <quicksilver> mapreduce: it works because 7 is coprime to 20.
05:39:37 <ivanm> amortized O(n/2) mem usage probably
05:39:58 <quicksilver> basically if (n * 7) `mod` 20 == 0 for any n < 20
05:40:05 <quicksilver> then you'd have a contradiction.
05:40:18 <quicksilver> not sure I can remember the proof but ISTR it's obvious if you think hard enough :)
05:41:34 <quicksilver> (n*7) = k * 20; look at prime decomposition.
05:41:49 <quicksilver> none of the prime factors of 20 occur in '7' so they must all occur in 'n'
05:41:50 <quicksilver> QED.
05:42:37 <georgehorse> assuming the fundamental theorem of arithmetic, yes
05:42:52 <quicksilver> I think I'm allowed to assume that. May I?
05:43:18 <georgehorse> only if you can prove it >.>
05:43:28 <mapreduce> quicksilver: Great, I'll have a read.
05:43:38 <quicksilver> I have a really elegant proof, but the margin of this IRC channel is too small to contain it.
05:44:38 <ivanm> @hpaste
05:44:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:44:41 <ivanm> ^^ here you are quicksilver
05:44:46 <ivanm> use that instead!
05:46:01 <Peaker> dolio, Saizan: Even if you have: (exists a. ([a], a->a, a->b)) I think its ok to instead have: ([[b]]) -- going to the "next list item" is no more expensive than applying a->a again
05:46:52 <dolio> Yes, but it starts getting more complex from there.
05:47:40 <xrfang> anyone pls give me a simple example of a "strict version of function (non-lazy)" -- now reading LYAH... thanks
05:47:48 <xrfang> what does the "strict version" mean
05:47:54 <Peaker> I think its still nicer to have this kind of complexity than lost runtime type information
05:48:04 <quicksilver> why?
05:48:08 <quicksilver> justify that, Peaker ?
05:48:14 <quicksilver> you've just shown they're equivalent
05:48:16 <quicksilver> so why is one better?
05:48:39 <Peaker> quicksilver: I think its better because it does not inhibit potential optimization -- when you have all of the type information in compile time
05:49:00 <dolio> Existential types don't involve any runtime type information.
05:49:29 <quicksilver> GHC doesn't invole any runtime type information, full stop.
05:49:32 <Peaker> dolio: IIUC, the compiler has less information about a value of type exists a. a  than some compile-time known type
05:49:44 <quicksilver> GHC erases all types, whether it is compiling an existential or not.
05:50:37 <Peaker> Maybe I misunderstand, but if I have a list of Ints or whatever compile-time known type, I'd expect the compiler to have more optimizations available than when I have a list of existentially-typed values
05:51:41 <quicksilver> but your solution eliminates the compile time type as well :P
05:51:49 <quicksilver> the existential solution leaves the 'a' there, but unknown.
05:51:58 <quicksilver> your solution removes 'a' from the picture entirely.
05:52:10 <quicksilver> it certainly doesn't expose any optimisations on 'a'. It's not there!
05:52:54 <Peaker> quicksilver: [exists a. (a, a -> Bool)] cannot be optimized into a bitmap, whereas if it is reduced into [Bool] which the compiler happens to know is a strict list of strict bools -- it can be
05:53:09 <Peaker> (Just as an example I made up in a second :-)
05:53:16 <dolio> Heh. Good luck with that.
05:54:42 <Peaker> I guess the compiler can recognize a lot of special cases with existentials and optimize them away
05:55:21 <Peaker> (exists a. (a, a->b)) ==> b   and  (exists a. (a, a->a)) into [a], when combined with (a->b) becomes [b]
05:59:24 <ivanm> if I want to find the longest list in a list of lists, will "maximumBy length" calcualte the length of each list more than once as it compares them?
05:59:52 <pumpkin_> yeah
06:00:25 <ivanm> OK, back to map fst . maximumBy snd . map (\xs -> (xs, length xs))
06:02:37 <quicksilver> ivanm: that is the point of the schwartzian transform.
06:02:46 <quicksilver> ivanm: to avoid the recomputation of the measure.
06:03:30 <ivanm> quicksilver: what's the schwartzian transform?
06:04:12 <ivanm> s/map fst/fst/
06:04:15 <doserj> http://en.wikipedia.org/wiki/Schwartzian_transform
06:04:49 <doserj> quicksilver's perl background shows through...
06:04:55 <ivanm> heh
06:05:47 <xrfang> @src null
06:05:47 <lambdabot> null []     = True
06:05:47 <lambdabot> null (_:_)  = False
06:09:01 <ivanm> if I want to split the list such that I find the maximum and break it at that point, I'd need two passes, right?
06:09:38 <McManiaC> hey i need some advice... im want to save a password to a config file, but of course i want to encrypt it
06:09:47 <McManiaC> now i dont know which lib to use =) any ideas?
06:10:02 <McManiaC> md5 wont work since i cant get it back..
06:10:06 <ivanm> McManiaC: are you writing some kind of password storage app?
06:10:12 <McManiaC> ivanm: kind of
06:10:18 <ivanm> blowfish is cool, but I don't know if there's a haskell implementation
06:10:19 <McManiaC> i have login data saved to a config file
06:10:41 <ivanm> McManiaC: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto
06:10:53 <ivanm> it has blowfish! \o/
06:10:56 <McManiaC> ok =)
06:11:10 <gnuvince> blowfish sucks; it has a backdoor in it.
06:11:13 <ivanm> McManiaC: really, it depends if you want it symmetric or asymmetric
06:11:17 <gnuvince> I know: they said so in 24!
06:11:17 <ivanm> gnuvince: bullshit
06:11:22 <ivanm> heh, oh, yeah, that
06:11:27 <gnuvince> :)
06:11:33 <McManiaC> ivanm: what does that mean?
06:11:42 <McManiaC> i have no idea of encryption
06:11:47 <ivanm> McManiaC: symmetric: the encryption key == decryption key
06:12:02 <ivanm> asymmetric (aka public key cryptography): encryption key /= decryption key
06:12:18 <McManiaC> oh i think symmetric will do
06:12:20 <ivanm> so use symmetric if it's a private thing, asymmetric if it's shared (I encrypt it, but only you can decrypt it)
06:12:27 <McManiaC> since its all stored on the users hdd
06:12:30 <ivanm> McManiaC: in that case, I highly suggest blowfish
06:12:45 <pumpkin_> you aren't really gaining much by asymmetric crypto as far as I can see
06:12:53 <pumpkin_> yeah
06:12:58 <ivanm> IIRC, the only reason the NSA didn't choose it for AES was they had chosen an arbitrary block size which blowfish doesn't work for
06:13:09 <ivanm> s/suggest/recommend/
06:13:24 <pumpkin_> twofish?
06:13:34 <pumpkin_> that was the contender for AES I thought
06:13:38 <ivanm> you can tell blowfish is good, because it's by Bruce Schneier!
06:13:45 <ivanm> pumpkin_: sounds familiar...
06:13:58 <ivanm> blowfish is much easier to understand than AES, and it has a cool diagram!
06:13:59 <McManiaC> encrypt :: Integral a => a -> Word64 -> Word64 <-- how can i use that with my pw-string?
06:14:11 <McManiaC> convert string to word64?
06:14:32 <ivanm> actually, schneier recommends twofish :s
06:14:32 <pumpkin_> ivanm: I mean, twofish was an extended cooler version of blowfish that was a contender in the AES competition
06:14:36 <kadaver> does ghc/compilers in general generate machin code or asm?
06:14:45 <kadaver> does ghc/compilers in general generate real machine code or asm?
06:14:52 <pumpkin_> kadaver: um
06:15:00 <ivanm> pumpkin_: yeah
06:15:11 <pumpkin_> kadaver: the two should be isomorphic :P
06:15:17 <ivanm> I'd never covered twofish, we only did stuff like DES, blowfish and AES in my crypto course :s
06:15:22 <pumpkin_> kadaver: I believe ghc generates textual asm though :P
06:15:51 <ivanm> hmmm.... twofish is slower than AES for 128-bit, but faster for 256
06:15:55 <quicksilver> yes, ghc relies on an assembly to generate the final opcode.s
06:16:05 <quicksilver> asm files are easier for humans to read when debugging the compiler.
06:16:11 <quicksilver> "an assembler"
06:17:04 <Berengal> Assembly and machine code aren't completely isomorphic...
06:17:11 <Berengal> Assembly has labels
06:17:18 <pumpkin_> true
06:17:22 <pumpkin_> and indentation, and comments :P
06:17:25 <Berengal> And macros and whatnot...
06:17:30 <kadaver> asm is for weaksauces, realprogrammers code asm
06:17:40 <kadaver> asm is for weaksauces, realprogrammers code hexadecimal
06:17:46 <pumpkin_> kadaver: right ;)
06:18:04 <georgehorse> with butterflies
06:18:10 <maxote> kadaver, profesional programmers code OO
06:18:10 <Berengal> My first programing experience was hexadecimal...
06:19:09 * doserj distinguishes between real and professional programmers
06:19:13 <Berengal> I was "modding" a DOS game in a hex editor, and somehow I realized the hex values I was pushing off the internet corresponded to some reference I had
06:19:25 <Lutz_Ifer> http://imgs.xkcd.com/comics/real_programmers.png <-- this is, what REAL programmers use
06:19:49 <Berengal> Lutz_Ifer: What, emacs?
06:19:51 <mk15> Hi, Ive spent two days trying to solve this problem, so Im asking here.....Im making a simple game and all I need is to keep track of the state of every block in an 8x8 checkerboard (empty, occupied white, occupied black). Im trying to use an array of Ints...is there a way to make this array global so I can access it from every function? If not do I have to create it in main and pass it down via every function call?
06:20:27 <burp_> mk15, StateT
06:20:33 <maxote> mk15, to pass a pointer as parameter
06:20:52 <McManiaC> how can i convert a string into Word64 ??
06:21:01 <ivanm> mk15: what's  wrong with passing it around?
06:22:31 <ivanm> McManiaC: read
06:22:38 <ivanm> > read "2" :: Word64
06:22:39 <lambdabot>   2
06:23:23 <McManiaC> *** Exception: Prelude.read: no parse
06:23:26 <doserj> that's not what he wants.
06:23:49 <McManiaC> > read "foo" :: Word64
06:23:51 <lambdabot>   * Exception: Prelude.read: no parse
06:23:58 <Berengal> Passing it around isn't as harsh as it might sound...
06:24:16 <Berengal> Wow, sometimes I'm slow...
06:24:35 <doserj> map (toEnum.fromEnum) might be closer
06:24:58 <ivanm> doserj: how do you know?
06:25:10 <ivanm> he wanted String -> Word64
06:25:11 <doserj> the context was encryption algorithm
06:25:16 <ivanm> @hoogle String -> Word64
06:25:16 <lambdabot> Prelude read :: Read a => String -> a
06:25:17 <lambdabot> Text.Read read :: Read a => String -> a
06:25:17 <lambdabot> Prelude error :: String -> a
06:25:23 <doserj> and he really wanted String -> [Word64]
06:25:27 <ivanm> doserj: ahhh
06:25:50 <mk15> ivanm: Its not a real problem, but im curious if theres "cleaner" way....passing around a variable through 6 functions just so that last one can use it seems a little messy to me
06:26:04 <McManiaC> doserj: why [Word64]?
06:26:19 <ivanm> mk15: *shrug* you can use state, but IMHO using a monad is even messier
06:26:26 <ivanm> I routinely pass values around a fair bit
06:26:46 <ivanm> McManiaC: "foo" isn't a number...
06:27:04 <ivanm> so how do you expect to turn it into a Word64?
06:27:10 <McManiaC> ivanm: yeh, but how am i supposed to encrypt text?
06:27:26 <ivanm> McManiaC: *shrug* never used that lib
06:27:28 <McManiaC> encrypt :: (Integral a) => a -> Word64 -> Word64
06:27:33 <McManiaC> -- | Basic Blowfish encryption which takes a key and a block of plaintext
06:27:37 <McManiaC> im confused :S
06:27:46 <ivanm> McManiaC: convert text to a number first
06:27:56 * ivanm -> bed
06:28:01 <doserj> McManiaC: did you look at Codec.Encryption.Modes ?
06:29:09 <Peaker> @hoogle finally
06:29:09 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
06:29:27 <Peaker> how can you safely use finally? inside a "block"?
06:29:32 <doserj> "encrypt" is for encrypting a single block of a fixed bit length. for arbitrary length data, like a string of text, you need a something more, and a simple map encrypt is not really secure.
06:30:00 <Peaker> block $ do { resource <- getResource ; do { unblock ; doStuffToResource } `finally` releaseResource? }
06:30:13 <Peaker> the question mark was on the whole thing, accidentally inside :)
06:30:16 <McManiaC> doserj: so use cbc with blowfish?
06:30:22 <QtPlaty[HireMe]> You need something like CBC
06:30:33 <doserj> McManiaC: for example
06:31:06 <Peaker> oh, I'd hope bracket is safe, instead
06:32:06 <Peaker> does bracket call the resource creation under "block"?
06:32:09 <Peaker> @src bracket
06:32:09 <lambdabot> bracket before after thing = block $ do
06:32:09 <lambdabot>     a <- before
06:32:09 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
06:32:09 <lambdabot>     after a
06:32:09 <lambdabot>     return r
06:32:18 <Peaker> ah, cool :-)
06:33:09 <Peaker> @index block
06:33:10 <lambdabot> Control.Exception
06:34:39 <Peaker> @src finally
06:34:39 <lambdabot> a `finally` sequel = block $ do
06:34:40 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
06:34:40 <lambdabot>     sequel
06:34:40 <lambdabot>     return r
06:35:47 <eu-prleu-peupeu> im trying to work out an architecture in haskell, can someone help me out plz ?
06:35:54 <Peaker> eu-prleu-peupeu: architecture of what?
06:38:52 <McManiaC> so how do i use cbc? i cant figure this out =(
06:41:28 <doserj> cbc encrypt iv key data
06:41:50 <McManiaC> iv?
06:42:03 <doserj> encrypt is the encryption function, iv is an initialization vector, key is the key, data::[Word64] is what you want to encrypt
06:42:42 <McManiaC> what is a vector?? sorry, i know vectors only from math & physics :)
06:43:38 <Peaker> block $ forkIO act -- will act run blocked/
06:43:44 <kadaver> vector in programming is usually a dynamic array thingie
06:43:49 <doserj> here it is just some value iv::Word64
06:43:51 <kadaver> listarray
06:44:13 <quicksilver> Peaker: I think threads inherit blocked state from their fork point, yes.
06:44:35 <McManiaC> ok
06:45:41 <Peaker> quicksilver: thanks
06:46:20 <doserj> McManiaC: it doesn't really matter what value iv is, it also doesn't have to be secret, you just shouldn't reuse it.
06:46:47 <alexsuraci> Is there any "essential" book I should read before writing a compiler (specifically, to LLVM, but I'd like to read one on the basic concepts first, like K&R is for C)?
06:46:47 <McManiaC> doserj: what do you mean by reuse?
06:47:08 <doserj> McManiaC: don't encrypt two messages with the same key and the same iv
06:47:42 <McManiaC> hmm
06:47:56 <McManiaC> so how can i get a "good" key/iv?
06:48:05 <maltem> alexsuraci, a Haskell compiler, or in general?
06:48:06 <McManiaC> i have to store it too, aint i?
06:48:35 <centrinia> alexsuraci, Get the Dragon Book. ;)
06:48:37 <alexsuraci> maltem: In general - I'm writing a language that compiles to LLVM, and I'd like a good book to read before I dive in.
06:48:56 <maltem> hm then I don't know
06:49:00 <alexsuraci> centrinia: You mean this, right? http://en.wikipedia.org/wiki/21st_Century_Compilers
06:49:05 <McManiaC> doserj: mind if i convo you for this? :)
06:49:09 <doserj> McManiaC: you can just randomly generate the iv.
06:49:12 <centrinia> alexsuraci, Yes.
06:49:20 <doserj> McManiaC: and yes, you will have to store the iv too
06:49:36 <alexsuraci> centrinia: Okay, thanks. I'd heard about this before, nice to see a confirmation. :)
06:51:46 <pejo> centrinia, I find the dragon book hard to read. On the other hand I'm not aware of a good replacement either.
06:53:06 <kadaver> how do i get ord of a nbr?
06:53:10 <kadaver> > ord 120
06:53:11 <lambdabot>       No instance for (Num Char)
06:53:11 <lambdabot>        arising from the literal `120' at <in...
06:53:19 <kadaver> > ord 120 :: Char
06:53:20 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
06:53:30 <kadaver> > ord '120'
06:53:31 <lambdabot>   <no location info>:
06:53:31 <lambdabot>      lexical error in string/character literal at chara...
06:53:38 <alexsuraci> > chr 120
06:53:39 <kadaver> @type ord
06:53:39 <lambdabot>   'x'
06:53:39 <alexsuraci> ?
06:53:41 <lambdabot> Char -> Int
06:53:47 <kadaver> ord '5'
06:53:54 <kadaver> > ord '120'
06:53:55 <lambdabot>   <no location info>:
06:53:55 <lambdabot>      lexical error in string/character literal at chara...
06:53:56 <centrinia> > length [minBound..120]
06:53:57 <lambdabot>   Add a type signature
06:53:59 <kadaver> > ord 'a'
06:54:00 <lambdabot>   97
06:54:05 <kadaver> > ord 'x'
06:54:06 <lambdabot>   120
06:54:08 <centrinia> > length [minBound..120 :: Int8]
06:54:09 <lambdabot>   249
06:54:22 <kadaver> > chr 120
06:54:23 <centrinia> > length [minBound..120 :: Word8]
06:54:24 <lambdabot>   'x'
06:54:24 <lambdabot>   121
06:54:33 <centrinia> > length [minBound..120 :: Word16]
06:54:34 <lambdabot>   121
06:54:38 <centrinia> > length [minBound..120 :: Int16]
06:54:39 <lambdabot>   32889
06:54:55 <mmmulani> why does ghc give me a parse error with the following code, but typing it into ghci works fine?
06:54:57 <mmmulani> code: http://pastebin.ca/1401918
06:55:07 <centrinia> > length [minBound..120 :: Int32] -- I hope this finishes in 3 seconds.
06:55:23 <lambdabot>   thread killed
06:55:28 <centrinia> Darn. :(
06:55:38 <tchakkazulu> Hey, I just got a strange bug in GHCi ('impossible' happens, etc) when adding a function definition that doesn't seem to change anything I'm using.
06:55:43 <tchakkazulu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4182
06:55:53 <centrinia> > filter (\x -> (0 == (600851475143 `mod` x))) [1..775146]
06:55:55 <lambdabot>   [1,71,839,1471,6857,59569,104441,486847]
06:55:56 <Berengal> mmmulani: Expressions aren't allowed at the top level, only bindings
06:56:02 <mmmulani> ohhh
06:56:02 <Peaker> forkIO makes things tricky!  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4183#a4183
06:56:05 <byorgey> mmmulani: ghc only accepts complete programs; that's just an expression
06:56:10 <araujo> morning
06:56:12 <tchakkazulu> Could someone with a GHC > 6.10.1 check if that behaviour still occurs?
06:56:20 <mmmulani> ahah, I'm coming from Scheme. that explains it :P
06:56:32 <byorgey> mmmulani: try putting something like   'main = print (...)'  in a file, where ... is replaced by that expression
06:56:39 <byorgey> that's essentially what ghci is doing
06:56:42 <mmmulani> oh okay
06:56:57 <mmmulani> so ghc executes the main function?
06:57:00 <byorgey> right
06:57:19 <Berengal> ghc executes and IO value, defaulting to the one called main...
06:57:26 <Berengal> s/and/any/
06:57:39 <mmmulani> ouu
06:57:42 <mmmulani> that worked perfectly
06:57:43 <mmmulani> thanks a lot
06:57:45 <Peaker> Can anyone review the correctness of block/forkIO here?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4183#a4183
06:58:01 <byorgey> can you really change which IO value gets executed?
06:58:40 <tchakkazulu> byorgey: with main-is Module.function, yeah.
06:59:04 <byorgey> oh, neat, I knew you could do  -main-is Module, I didn't know you could say Module.function
06:59:19 <Berengal> tchakkazulu: I can load that file of your just fine in 6.10.2
06:59:35 <tchakkazulu> Loading works fine here too, try showing "Done 2"?
06:59:47 <Berengal> Works
06:59:56 <tchakkazulu> Ah, okay. Then it has been fixed :)
07:00:05 <tchakkazulu> Thanks for trying.
07:00:16 <Peaker> is there an existing function like:
07:00:18 <Peaker> synchronized :: MVar () -> IO () -> IO ()
07:00:18 <Peaker> synchronized lock act = withMVar lock (<$ act)
07:00:20 <Berengal> I remember having some trouble with that myself. Restarting ghci (and sometimes bash too) seemed to cure it
07:01:56 <quicksilver> levitation[A]:
07:01:58 <tchakkazulu> No luck. A fresh bash/ghci still gives the 'impossible'.
07:02:00 <quicksilver> Peaker: no.
07:02:18 <quicksilver> Peaker: there is a suprising paucity of obvious combinators built over MVars.
07:02:28 <quicksilver> I have often thought it was strange.
07:04:11 <mmmulani> how do I include the List library? (I'm getting a "not in scope: sortBy" error)
07:04:20 <byorgey> mmmulani: import Data.List
07:04:21 <Peaker> quicksilver: someone said the other day a function is a combinator only if it uses only its arguments and no free variables?
07:04:23 <kadaver> > chr 5
07:04:24 <lambdabot>   '\ENQ'
07:04:27 <mmmulani> byorgey: thanks
07:04:29 <Peaker> > chr 10
07:04:30 <lambdabot>   '\n'
07:04:44 <Berengal> > chr 0
07:04:45 <lambdabot>   '\NUL'
07:04:47 <kadaver> > chr 100
07:04:48 <lambdabot>   'd'
07:04:49 <Berengal> > che (-1)
07:04:50 <lambdabot>   Not in scope: `che'
07:04:56 <Berengal> > chr (-1)
07:04:57 <lambdabot>   * Exception: Prelude.chr: bad argument
07:05:09 <byorgey> Peaker: eh? how can a function use anything other than its arguments?
07:05:32 <byorgey> oh, you mean if it doesn't use other functions that have been defined previously
07:06:04 <byorgey> that seems like a rather useless definition of 'combinator' to me
07:06:46 <maltem> Doesn't "combinator", in Haskell land, just mean "it's convenient to use"?
07:06:52 <byorgey> those are 'combinators' in the sense of S, K, I and so on
07:07:06 <Peaker> "A higher-order function that solely uses function application and earlier defined combinators on its arguments"
07:08:02 <maltem> Peaker, which is... any function?
07:08:37 <Peaker> this definition seems to exclude recursive combinators
07:08:43 <maltem> Ahh
07:08:49 <maltem> Hence "earlier defined"
07:08:55 <Peaker> though I'm not sure its an intended thing
07:08:56 <Berengal> Peaker: Like Y?
07:09:09 <byorgey> so a combinator is any non-recursive function?  that still seems like a useless definition to me =)
07:09:45 <Peaker> yeah, for a "useless word" you hear a lot of it in the Haskell world :)
07:09:54 <Berengal> Y = Î»fÂ·(Î»xÂ·f (x x)) (Î»xÂ·f (x x))
07:09:58 <Berengal> ^^ Recursive
07:10:39 <Peaker> Berengal: yeah, the definition doesn't exclude recursive functions in general, only in Haskell
07:10:51 <Peaker> Berengal: or languages with Haskell's type system limitations
07:11:37 <byorgey> Peaker: I wasn't arguing that 'combinator' is a useless word, only that that particular definition is useless.
07:11:47 <Peaker> byorgey: what definition is useful?
07:12:01 <byorgey> well, that's a good question.
07:12:02 <maltem> I think I'll get back to "a function that is convenient to use"
07:12:34 <byorgey> it certainly isn't used as a technical term, so I doubt you could come up with a precise definition.
07:12:39 <Berengal> Well, combinators obviously have to combine things
07:12:47 <Berengal> It makes sense to be able to chain combinators
07:13:16 <Berengal> So combinators must return something similar to their arguments
07:14:03 <byorgey> that sounds right.
07:14:21 <Berengal> Often with polymorphism
07:14:45 <byorgey> generally a given combinator library is devoted to building up objects of some type X in a compositional way.
07:14:52 <Gracenotes> often it's not possible to ascertain the behavior of the components until you execute them
07:15:21 <Gracenotes> (in the context of the larger combinators)
07:15:53 <CirceMagica> This is about the notFollowedby parser combinator in the Parsec library
07:15:56 <Gracenotes> of course, you feed it to the combinator, but the behavior of the larger part is dependent on the behavior of the smaller part. often.
07:16:29 <CirceMagica> as it is defined, it seems to be able to take only parsers which would return just a single token
07:16:57 <Berengal> Gracenotes: The smaller parts act independantly, but their interaction is determined solely by the combinator
07:17:12 <CirceMagica> In particular its type is notFollowedBy :: GenParser tok st tok -> GenParser tok st ()
07:17:15 <Gracenotes> indeed
07:17:45 <Berengal> So it's not too hard to separate the different kinds of behaviour
07:18:01 <Gracenotes> CirceMagica: the choice that's mainly made there is to fail the parser or to continue
07:18:15 <CirceMagica> and it is defined as notFollowedBy p = try ( do{c <- p; unexpected (show [c])} <|> return ())
07:18:47 <Gracenotes> yeah
07:20:55 <CirceMagica> Gracenotes: But what is wrong with the following definition, which seems to have slightly more functionality: notfollowedBy' p = try (do {c <- (try p); unexpected (show c)} <|> return ())
07:21:23 <CirceMagica> which would work for any p which is guranteed to consume some input to succeed?
07:21:47 <Peaker> how would I call a function of type :: IO (IO a -> IO a) -- which returns a function that wraps actions with withMVar ?
07:22:06 <CirceMagica> in particular the type now is (Show a) => GenParser tok st a -> GenParser tok st ()
07:22:08 <Peaker> An (IO a -> IO a) is like Java's synchronized
07:22:23 <Peaker> IO (IO a -> IO a)  -- is a factory of synchronized's
07:22:29 <Gracenotes> @type (<*>)
07:22:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:23:10 <CirceMagica> @type (<||>)
07:23:12 <lambdabot> Not in scope: `<||>'
07:23:20 <CirceMagica> @type (<|>)
07:23:21 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
07:24:12 <Gracenotes> :t \f a -> (f >>= ($a))
07:24:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> m b) -> a -> m b
07:24:30 <Gracenotes> thar you go, Peaker. just don't try extracting it in ghci... Any might attack :(
07:24:45 <Peaker> Gracenotes: ?
07:24:51 <CirceMagica> Gracenotes: Am I doing something wrong in the definition with notFollowedBy'?
07:24:56 <Gracenotes> CirceMagica: does it yield incorrect results?
07:25:03 <CirceMagica> It does not!
07:25:25 <CirceMagica> Gracenotes: But I was wondering why is this not the definition in the library in that case.
07:25:36 <Gracenotes> how about if you remove the outer try?
07:25:40 <Peaker> Gracenotes: I could convert   IO (IO a -> IO a)  into:  IO a -> IO (IO a)  or even: IO a -> IO a  -- but that means I need the (IO a) arg before I can do anything -- and cannot create "groups" that share the same lock
07:26:16 <CirceMagica> Gracenotes: The outer try is essential: as notFollowedBy must guarantee that it does not consume any input
07:26:37 <Peaker> I use:   synchronized <- mkSynchronized ; let handle = (result . result) synchronized printMsg    -- if its not IO (IO a -> IO a)   it won't work
07:26:56 <Gracenotes> CirceMagica: if p is the only thing that consumes input, shouldn't it be guaranteed not to consume anything?
07:26:59 <Peaker> "How would I call a function..." is ambiguous -- I meant "how would I name a function..."
07:27:15 <CirceMagica> Gracenotes: Pardon?
07:27:26 <Gracenotes> if you have an inner try
07:27:38 <CirceMagica> but p may succeed
07:27:42 <CirceMagica> in which case
07:27:56 <CirceMagica> even the inner try might have consumed input
07:28:13 <Gracenotes> in which case the parser will fail anyway. Or is there some form of error recovery?
07:28:25 <CirceMagica> this is circumvented by immediately failing using unexpected and then the outer try
07:28:51 <CirceMagica> but if I remove the outer try, and p succeds, then the parser which fails
07:28:56 <CirceMagica> is not enclosed in a try
07:29:08 <mmorrow> preflex: cdecl void(*xs)(int)[]
07:29:10 <CirceMagica> and hence notFollowedBy would have consumed input
07:29:17 <mmorrow> preflex: seen preflex
07:29:17 <preflex>  what
07:29:19 <Gracenotes> ah. I see you're more familiar with Parsec's internals than me :)
07:29:26 <mmorrow> preflex: help
07:29:26 <preflex>  try 'help help' or see 'list' for available commands
07:29:27 <Gracenotes> I
07:29:32 <mmorrow> preflex: list
07:29:32 <preflex>  8ball: [8ball]; Factoid: [+, -, ., ?, delete, get, store]; Help: [help, list]; Karma: [++, --, karma, karmabot, karmatop]; Nickometer: [nickometer]; Nickr: [nickr]; Seen: [seen]; Tell: [ask, clear-messages, messages, tell]; Rot13: [rot13]; Quote: [be, quote, remember]; WCalc: [calc, wcalc]; Version: [version]; ZCode: [zdec, zenc]
07:29:34 <mauke> mmorrow: functions can't return arrays
07:29:39 <Gracenotes> CirceMagica: so doesn't that explain it :?
07:29:44 <CirceMagica> Gracenotes: :-) Not at all
07:29:54 <mmorrow> mauke: heh, i'm glad you're here. i want an array of function ptrs.
07:29:55 <CirceMagica> Gracenotes: Not exactly
07:30:12 <mauke> mmorrow: #haskell-blah?
07:30:19 <CirceMagica> because my implementation of notFollowedBy' can handle p = string "abc"
07:30:28 <CirceMagica> which the library implementationcannot
07:30:41 <CirceMagica> and that was my point of contention
07:31:04 <CirceMagica> the library designers must have had their reasons for persisting with their definition
07:31:18 <CirceMagica> and I am still clueless with regards to those :-(
07:31:54 <Gracenotes> :t let blah :: IO (IO a -> IO a) -> IO (IO a -> IO a) -> IO (IO a -> IO a); blah = liftM2 (.) in blah -- .... Peaker?
07:31:56 <lambdabot> forall a. IO (IO a -> IO a) -> IO (IO a -> IO a) -> IO (IO a -> IO a)
07:32:07 <Gracenotes> :o
07:32:14 <Peaker> Gracenotes: what?
07:32:19 <codebliss> I LOVE HASKELL <3
07:32:44 <Berengal> @type liftM2 (.)
07:32:45 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
07:32:54 <Berengal> Seems obvious enough...
07:33:05 <codebliss> Does anyone know how to points-free the following or would it be not worth it?
07:33:06 <codebliss> anySatisfy condition datas = foldl (||) False $ map condition datas
07:33:16 <Berengal> @pl anySatisfy condition datas = foldl (||) False $ map condition datas
07:33:16 <lambdabot> anySatisfy = (foldl (||) False .) . map
07:33:29 <CirceMagica> Berengal: :-)
07:33:39 <codebliss> LOL
07:33:42 <quicksilver> codebliss: "foldl (||) False" is called "or"
07:33:44 <quicksilver> :t or
07:33:45 <lambdabot> [Bool] -> Bool
07:33:48 <Gracenotes> @src any
07:33:49 <lambdabot> any p =  or . map p
07:33:50 <Gracenotes> @src or
07:33:51 <lambdabot> or    =  foldr (||) False
07:33:55 <Gracenotes> :)
07:33:55 <quicksilver> your whole thing is called 'any'
07:34:01 <codebliss> I'm still learning,  use as little premade functions as possible
07:34:02 <quicksilver> as Gracenotes just showed :)
07:34:07 <quicksilver> ok, fair enough.
07:34:10 <codebliss> =)
07:34:20 <zoheb> @pl
07:34:20 <lambdabot> (line 1, column 1):
07:34:20 <lambdabot> unexpected end of input
07:34:20 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
07:34:21 <CirceMagica> codebliss: Way to Go!
07:34:33 <codebliss> Maybe if I was doing production code I'd use more than map/filter/scan XD
07:34:36 <zoheb> @pl (\x -> x+x)
07:34:36 <lambdabot> join (+)
07:34:47 <zoheb> :t join
07:34:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:35:02 <centrinia> @let or' = any id
07:35:03 <lambdabot>  Defined.
07:35:13 <centrinia> > or' [True,False]
07:35:14 <lambdabot>   True
07:35:17 <zoheb> what the hell is @pl
07:35:19 <CirceMagica> Are there any well known Arrow instances apart from (->) and Kleisli arrows?
07:35:21 <centrinia> > or' [False,False]
07:35:23 <lambdabot>   False
07:35:30 <zoheb> does it convert code to point free style?
07:35:32 <codebliss> Pointless
07:35:34 <codebliss> I think
07:35:38 <quicksilver> zoheb: yes.
07:35:43 <Peaker> Gracenotes: are you saying IO (IO () -> IO ()) does not make sense?
07:36:04 <CirceMagica> codebliss: Point free code is "affectionately" called Pointless :-D
07:36:10 <zoheb> Does it ship with ghci?
07:36:14 <quicksilver> no.
07:36:14 <Peaker> Gracenotes: converting it to IO () -> IO (IO ()) loses a bit of power, and converting it to   IO () -> IO ()  loses a lot of power
07:36:15 <codebliss> I've always been curious.  It's impossible to have side effects without knowing from the type sig?
07:36:16 <zoheb> the @pl
07:36:17 <FunctorSalad> does alex in "monad" mode work for anyone currently?
07:36:24 <quicksilver> you can install your own lambdabot
07:36:26 <EvilTerran> zoheb, btw, (\x -> x+x) could also just be written (*2)
07:36:29 <Berengal> zoheb: It's part of lambdabot. You can download her from hackage...
07:36:30 <quicksilver> although it's not terribly easy.
07:36:32 <codebliss> CirceMagica: I know, that's why I said that XD  Just noticed the irony lol
07:36:38 <EvilTerran> likewise, (\x -> x*x) = (^2)
07:36:39 <Gracenotes> @hackage pointfree
07:36:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pointfree
07:36:40 <zoheb> yes
07:36:41 <Peaker> codebliss: in principle yes.  There are "hacky" things that can have side effects without saying so in the type - but for most valid purposes, you can ignore their existence
07:36:45 <FunctorSalad> the file alex produces fails to compile with "templates/wrappers.hs:133:15: Not in scope: `alexEOF'"
07:36:50 <FunctorSalad> looks like an internal error
07:36:50 <zoheb> I was just trying out @pl
07:36:59 <Gracenotes> Peaker: no... it can do a lot of things... I'm not sure how to do any of those things without >>=ing it
07:37:14 <Peaker> Gracenotes: well, most IO actions require >>= them, what do you mean?
07:37:27 <codebliss> Peaker: Okay.  I was just wonderif if you could have like foo :: a -> a -> a with side effects and not know.  Lots of people new to functional programming love absolutes, regardless of the ridiculousness of their claims XD
07:37:28 <Gracenotes> feed the function as the first argument of >>=
07:37:38 <zoheb> @t join
07:37:38 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:37:38 <Peaker> Gracenotes: the idea is that IO (IO () -> IO ())   generates a new "locker" for each activation. You can use the "locker" to create synchronized versions of actions
07:37:40 <CirceMagica> codebliss: Oops :-)
07:37:52 <zoheb> :t join
07:37:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
07:37:55 <codebliss> CirceMagica: It's fine.  I posed a noob question and got a noob answer XD =P
07:38:03 <Gracenotes> but, got to go, class!
07:38:07 * Gracenotes brbs
07:38:10 <zoheb> :t join(+)
07:38:12 <lambdabot> forall a. (Num a) => a -> a
07:38:16 <codebliss> Gracenotes: Me too =(.  Good luck!
07:38:22 <CirceMagica> codebliss: Do you know of any other Arrow instances apart form -> and Kleisli arrows?
07:38:23 <Peaker> codebliss: you can have  foo :: a -> a -> a    that has side effects, but that would be considered a bug, and it is valid to assume the absolute in Haskell, unlike most other languages
07:38:37 <CirceMagica> I had heard there is a parser library base on Arrows
07:38:42 <codebliss> CirceMagica: All I can think of are Functions and monad-like functionality
07:38:50 <codebliss> CirceMagica: I haven't read into it mroe than a couple pages
07:39:00 <Peaker> CirceMagica: there are the FRP/Yampa arrows
07:39:10 <CirceMagica> though I'd stick with Parser anyday :-)
07:39:16 <CirceMagica> Peaker: Thanks
07:39:18 <codebliss> Peaker:  Perfect, thank you =]
07:39:19 <zoheb> I am confused, Is (+) of type m(m a) ?
07:39:29 <zoheb> :t join(+)
07:39:30 <lambdabot> forall a. (Num a) => a -> a
07:39:31 <kadaver> is ADD and MUL implemented in the hardware? ie it is a circuit?
07:39:34 <codebliss> (+) :: Num a => a -> a -> a
07:39:35 <EvilTerran> zoheb, if m = (a ->), yes
07:39:38 <Berengal> zoheb: Yes, for a given value of m
07:39:39 <zoheb> @t join
07:39:40 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
07:40:12 <EvilTerran> "m (m a) where m = (a ->)" = "(a ->) ((a ->) a)" = "a -> a -> a"
07:40:24 <zoheb> ok thx
07:40:38 <zoheb> whats -> called?
07:40:38 <codebliss> LOL @ http://www.facebook.com/ext/share.php?sid=92649409902&h=zP9xX&u=HUdvC&ref=nf .  Pushpin industry thriving in recession! XD
07:40:38 <CirceMagica> Peaker: Wow! Haskell continues to amaze!
07:40:43 <Peaker> zoheb: when join is used on functions (on the function monad) it generally just duplicates the argument
07:41:03 <zoheb> I didn't know about the Function Monad thx
07:41:16 <zoheb> where do you guys learn about this stuff?
07:41:23 <zoheb> Do u study haskell at uni?
07:41:36 <Peaker> CirceMagica: oh, another interesting arrow (if you ignore the existence of "arr", like many interesting arrows), is the reversible-computation arrow
07:41:44 <Peaker> "arr" is nothing but trouble :)
07:41:59 <quicksilver> that's not an arrow.
07:42:09 <quicksilver> so certainly not an interesting one.
07:42:17 * Berengal is an autodidact
07:42:19 <CirceMagica> Peaker: "arr"  is in arr :: (b -> c) -> a b c?
07:42:25 <quicksilver> ignoring the existence of 'arr' gives you something else.
07:42:34 <Peaker> quicksilver: what do you call that something else?
07:42:40 <Peaker> quicksilver: I just called it "arrow if you ignore arr" :)
07:42:46 <quicksilver> Control.Category, perhaps?
07:42:59 <codebliss> zoheb: Blogs, google, hoogle, and this channel are life! =P
07:43:09 <Berengal> I like the reversed state monad...
07:43:12 <codebliss> I got to go to calculus.  Time to do the derivatives of natural logs!
07:43:19 <Peaker> well, you can have first, second, swap, etc without arr in many arrows
07:43:25 <codebliss> Good day everyone.
07:43:31 <CirceMagica> Peaker quicksilver : What are reversible computation arrows? Can you give me some references? Thanks!
07:43:42 <Peaker> CirceMagica: do you know Control.Category?
07:43:49 <Peaker> @src Control.Category.Category
07:43:49 <lambdabot> Source not found. stty: unknown mode: doofus
07:43:50 <CirceMagica> codebliss: Enjoy your calculus
07:43:54 <CirceMagica> Peaker: No
07:43:59 <quicksilver> CirceMagica: to answer the question you technically asked, the parsers are the only interesting arrow I know of that isn't Kleisli.
07:44:00 <codebliss> CirceMagica: Psh.  The fun stuff is over for the year XD
07:44:16 <quicksilver> CirceMagica: I have often wondered why that is.
07:44:30 <EvilTerran> what about for reactives?
07:44:38 <CirceMagica> Peaker: Will have a look
07:44:40 <Peaker> CirceMagica: its a simple:   class Category (c :: * -> * -> *) where id :: c a a ; (.) :: c mid end -> c start mid -> c start end
07:45:02 <EvilTerran> ?type (.)
07:45:03 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:45:24 <Peaker> CirceMagica: if we change the "c" there to an infix name like (~>) instead, its easier to read:   class Category (~>) where id :: a ~> a ; (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
07:45:58 <CirceMagica> The (.) type looks bery much like the arrow (>>>) type
07:46:04 <Peaker> CirceMagica: note that (a ~> b) is equivalent to (~>) a b   so using (~>) is just renaming c to (~>)
07:46:16 <CirceMagica> so is this is an attempt to model Category a la Mathematics/
07:46:19 <Peaker> CirceMagica: indeed, (.) = (<<<) for categories that are arrows
07:46:25 <CirceMagica> oh
07:46:30 <Peaker> CirceMagica: (<<<) = flip (>>>)
07:46:43 <pumpkin_> hat non-arrow category instances are there?
07:46:53 <CirceMagica> Peaker: oh yes, sorry for that goof up
07:47:04 <Peaker> CirceMagica: so,   lets do:  data ReversibleComputation a b = ReversibleComputation { aToB :: a -> b, bToA :: b -> a }
07:47:12 <zachk> is there a better timing library then System.Time?
07:47:18 <quicksilver> zachk: Yes, Data.Time
07:47:22 <quicksilver> System.Time is deprecated.
07:47:38 <CirceMagica> ok
07:47:50 <Peaker> CirceMagica: instance Category ReversibleComputation where id = ReversibleComputation id id ; f . g = ReversibleComputation (aToB f . aToB g, bToA g . bToA f)
07:48:06 <Peaker> CirceMagica: following that?
07:48:27 <CirceMagica> Peaker: yes
07:48:35 <Peaker> CirceMagica: so when you compose reversible computations with (.) you're composing them in both directions and then you can use them to convert a's to b's or b's to a's
07:49:26 <quicksilver> reversible computations are obviously useful.
07:49:32 <quicksilver> except, I never seem to need them in practice.
07:49:34 <quicksilver> odd :)
07:49:35 <CirceMagica> Peaker: ok, so the problem with making this a full fledged arrow will be a lack of a natural first definition?
07:49:48 <Berengal> Yeah, I quickly saw a thousand use-cases flash by in my mind
07:49:50 <CirceMagica> *natural definition for first
07:50:03 <CirceMagica> Thanks Peaker
07:50:06 <Peaker> CirceMagica: nope, lack of "arr"
07:50:12 <CirceMagica> oh yes
07:50:15 <CirceMagica> of course
07:50:17 <pumpkin_> ARR MATEY
07:50:27 <Peaker> quicksilver: as conal likes to say -- self-fulfilling prophecy :)
07:50:28 <CirceMagica> Sorry :-)
07:50:53 <Peaker> quicksilver: when you don't have libraries that make something accessible/easy, you just don't do that something -- so if you anticipate it not being useful, you'll end up not using it and fulfill your prophecy
07:51:11 <zoheb> where can I find the Functioon Monad ?
07:51:11 <Peaker> CirceMagica: arr :: Arrow (~>) => (a -> b) -> (a ~> b)
07:51:11 <Berengal> quicksilver: I can see them being useful for translations... ord-chr, read-show for example?
07:51:23 <zoheb> Data.Function doesn't seem to be right
07:51:23 <CirceMagica> yes
07:51:27 <Berengal> zoheb: Control.Monad.Instances
07:51:29 <Peaker> CirceMagica: how can you convert (a->b) into both (a->b) and (b->a)? Obviously you can't
07:51:33 <zoheb> thx
07:51:39 <CirceMagica> I can see that given f :: (a->b)
07:51:50 <CirceMagica> there is definitely no natural f' :: (b->a)
07:51:52 <CirceMagica> Thanks
07:51:57 <suchsuch> Peaker: how did you compose aToB f . aToB g  up there?
07:51:58 <Peaker> CirceMagica: yeah, so "arr" really demands of arrows that they are at least as powerful as Haskell functions -- which inhibits a lot of interesting arrows
07:52:00 <quicksilver> Berengal: in principle, certainly.
07:52:16 <quicksilver> Berengal: I'm just saying in practice I've never needed them.
07:52:20 <Peaker> CirceMagica: because reversible functions are less powerful than all functions
07:52:25 <CirceMagica> yes
07:52:33 <EvilTerran> zoheb, the instances of Functor, Monad, etc for ((->) e) can be worked out almost directly from the types, anyway
07:52:37 <Peaker> suchsuch: do you mean, how it works type-wise?
07:52:38 <EvilTerran> ?type fmap
07:52:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:52:48 <quicksilver> Peaker: I reject your argument.
07:52:48 <suchsuch> Peaker: yes
07:52:56 <EvilTerran> ?djinn (a -> b) -> (e -> a) -> (e -> b)
07:52:56 <lambdabot> f a b c = a (b c)
07:53:02 <Berengal> quicksilver: Well... neither have I, but my blub detector is firing slightly when I agree to that
07:53:02 <quicksilver> Peaker: It's *so* easy to write the reversible funciton data type that I would do so in an instance if I ever neeed it.
07:53:05 <CirceMagica> quicksilver: which argument?
07:53:07 <quicksilver> Peaker: I just never have.
07:53:13 <centrinia> @pl \a b c -> a (b c)
07:53:13 <lambdabot> (.)
07:53:18 <CirceMagica> Oh ok
07:53:25 <CirceMagica> Sorry to poke my nose in :-)
07:53:26 <quicksilver> CirceMagica: "wehn you don't have libraries to make something accessible easy etc"
07:53:31 <Peaker> quicksilver: In retrospect with some thought, I can recognize cases where I could have used the Writer monad and my code would be more elegant, but I didn't
07:53:37 <Peaker> quicksilver: maybe that is similar?
07:54:03 <quicksilver> sure, but that's in retrospect and you probalby wouldn't make that mistake again.
07:54:16 <quicksilver> I've been looking out for uses of the invertible function arrow for months
07:54:19 <quicksilver> and never found one.
07:54:20 <Peaker> suchsuch: well, the "forward" part of f and g will compose forwardly, so the "backward part" will obviously compose in reverse order.  if (.) worked between a and b, then  flip (.) will surely work between b and a
07:54:52 <Peaker> quicksilver: Building compression functions, maybe?
07:55:06 <quicksilver> sounds plausible :)
07:55:37 <Peaker> quicksilver: well, there's the parser/builder thing too - but a parser is usually lossy so its hard to reconcile that
07:55:38 <Berengal> "decode someEncoding encodedData" "encode someEncoding decodedData"
07:56:26 <quicksilver> Peaker: invertible parsers are interesting.
07:56:30 <quicksilver> there are some papers on them.
07:56:45 <Berengal> Hmm, +/- are reversible...
07:57:08 <quicksilver> yes indeed.
07:57:15 <quicksilver> although they're binary not unary
07:57:18 <quicksilver> btu I know what you mean.
07:57:18 <Peaker> quicksilver: http://conal.net/blog/posts/designing-for-the-future/ -- is what I was talking about before, btw
07:57:41 <Berengal> Well, they'd have to become unary, so one argument applied...
07:57:53 <Peaker> (+x) and (subtract x) are reversible, yeah
07:58:02 <Peaker> also (x-) and (x+) of course
07:58:07 <hoopy> > 'a' ++ 'b'
07:58:08 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
07:58:12 <hoopy> what do ya do
07:58:16 <Peaker> > "a" ++ "b"
07:58:17 <hoopy> > "a" ++ "b"
07:58:17 <lambdabot>   "ab"
07:58:19 <lambdabot>   "ab"
07:58:28 <hoopy> but what if you want to concatenate a few chars?
07:58:46 <georgehorse> 'a' is one character, "a" is a list of characters that happens to have length 1
07:59:01 <Liskni_si> is there any way to hide instances in an import?
07:59:26 <quicksilver> instances are global. Any attempt to pretend they are not leads to insanity.
07:59:29 <mauke> Liskni_si: no
07:59:32 <hoopy> georgehorse: interesting, how would you make a two character string out of two chrs
07:59:36 <EvilTerran> hoopy, "a" = ['a'], you can make use of that
07:59:39 <quicksilver> (Yes, you can hide them by putting them in a separate module. There's no point, though)
07:59:42 <hoopy> ['a','b']
07:59:45 <mauke> > ['a', 'b']
07:59:46 <lambdabot>   "ab"
07:59:47 <EvilTerran> > ['a', 'b']
07:59:48 <hoopy> ah
07:59:48 <lambdabot>   "ab"
07:59:51 <hoopy> nice, thank you
07:59:53 <EvilTerran> > 'a' : 'b' : [] -- or this
07:59:54 <lambdabot>   "ab"
08:00:04 <Liskni_si> mauke: too bad :(
08:00:04 <tromp> > 'a':[]
08:00:05 <lambdabot>   "a"
08:00:14 <EvilTerran> > ('a' : ['b'], 'a' : "b") -- etc, etc
08:00:15 <tromp> no, that's good
08:00:15 <lambdabot>   ("ab","ab")
08:00:24 <Liskni_si> i'm having real trouble with this instance (MonadReader r m) => MonadReader r (StateT s m)
08:00:47 <quicksilver> make a newtype.
08:00:50 <quicksilver> then choose the instance you want.
08:00:50 <Liskni_si> since I want to define instance MonadReader r (StateT r []) where
08:00:52 <hoopy> > [ [a,b,c] | a <- "12346", b <- "sdc", c <- "rn" ]
08:00:53 <lambdabot>   ["1sr","1sn","1dr","1dn","1cr","1cn","2sr","2sn","2dr","2dn","2cr","2cn","3...
08:01:15 <hoopy> will that produce every combination of a,b,c ?
08:01:16 <Liskni_si> newtype for what? StateT?
08:01:28 <mauke> hoopy: yes
08:01:33 <hoopy> mauke: i lurve haskell
08:01:33 <quicksilver> Liskni_si: newtype for your actual concrete monad, probably.
08:01:42 <hoopy> and thank you
08:01:44 <quicksilver> Liskni_si: but you could also make a newtype for StateT if you do this often.
08:01:48 <mauke> > sequence ["12346", "sdc", "rn"]
08:01:50 <lambdabot>   ["1sr","1sn","1dr","1dn","1cr","1cn","2sr","2sn","2dr","2dn","2cr","2cn","3...
08:01:58 <hoopy> ah, more succinct
08:02:07 <EvilTerran> hoopy, but do you know how it works? :P
08:02:13 <hoopy> EvilTerran: nope :D
08:02:15 <Liskni_si> quicksilver: okay, i will try that
08:02:17 <Berengal> Less readable unless you grok the lost monad...
08:02:24 <Berengal> list*
08:02:25 <EvilTerran> ?type sequence
08:02:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:02:36 <EvilTerran> ?src sequence
08:02:36 <tromp> hmm, lost monad, sounds interesting
08:02:36 <lambdabot> sequence []     = return []
08:02:36 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:02:36 <lambdabot> --OR
08:02:36 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:02:44 <EvilTerran> ?src liftM2
08:02:44 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:02:49 <EvilTerran> whee!
08:02:53 <Peaker> @src liftA2
08:02:54 <lambdabot> liftA2 f a b = f <$> a <*> b
08:03:06 <EvilTerran> ?src [] (>>=)
08:03:06 <lambdabot> xs >>= f     = concatMap f xs
08:03:17 <burp_> ?src (+)
08:03:17 <lambdabot> Source not found. You untyped fool!
08:03:18 <Peaker> @pl xs >>= f     = concatMap f xs
08:03:19 <lambdabot> (line 1, column 14):
08:03:19 <lambdabot> unexpected "="
08:03:19 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
08:03:29 <hoopy> yeah whatever
08:03:33 <hoopy> mind = blown
08:03:34 <Peaker> @pl fff xs f     = concatMap f xs
08:03:35 <lambdabot> fff = (>>=)
08:03:38 <Berengal> > (,,) <$> [1,2,3] <*> [4,5,6] <*> [7,8,9]
08:03:40 <Peaker> heh
08:03:41 <lambdabot>   [(1,4,7),(1,4,8),(1,4,9),(1,5,7),(1,5,8),(1,5,9),(1,6,7),(1,6,8),(1,6,9),(2...
08:14:17 <georgehorse> ?type <$>
08:14:19 <lambdabot> parse error on input `<$>'
08:14:42 <mauke> (Functor f) => (a -> b) -> f a -> f b
08:15:32 <Liskni_si> quicksilver: thanks; actually the easiest way was to define my own MonadReader class
08:17:27 <byorgey> ?type (<$>)
08:17:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:17:41 <byorgey> it's a synonym for fmap
08:18:19 <FunctorSalad> anyone else getting "templates/wrappers.hs:133:15: Not in scope: `alexEOF'" with current alex/ghc6.10.2? :-(
08:19:26 <quicksilver> Liskni_si: heh.
08:19:44 <Liskni_si> maybe i'm just lame with newstate
08:20:26 <Liskni_si> but this really seems to work since my MonadReader probably expresses something else than what mtl's
08:28:00 <dev31212> centrinia, did you read the monad tutorial I recommended yet?
08:29:30 <centrinia> No.
08:30:21 <dev31212> ok.  It might assist.
08:32:08 <zachk> how come cabal install (say yi) needs alex, doesnt install alex, i do cabal install alex, then cabal install yi works?
08:32:17 <Peaker> is there any standard implementation of a framing protocol or such in the Network package?
08:32:29 <zachk> peaker: what do you mean by framing protocol
08:32:38 <zachk> packet frames?
08:33:47 <Peaker> zachk: over TCP, yes
08:34:00 <Peaker> Frames/messages over TCP
08:34:28 <mmorrow> mauke: sweet. (http://mauke.ath.cx/stuff/javascript/wargarbl.html)
08:34:52 <vixey> heh M-x zone
08:37:33 <opqdonut> hehe
08:39:42 <byorgey> zachk: cabal doesn't yet know how to deal with tool dependencies
08:40:09 <byorgey> zachk: yi doesn't need the alex package, it needs the alex executable to be installed
08:40:16 <byorgey> so alex isn't listed in the package-depends
08:40:32 <mmmulani> what is the symbol for empty list?
08:40:39 <byorgey> mmmulani: []
08:40:40 <quicksilver> mmmulani: []
08:40:43 <mmmulani> thanks
08:40:46 * quicksilver awards byorgey one point.
08:40:56 <byorgey> heh
08:41:15 <byorgey> I think you're still ahead by quite a few =)
08:41:55 <quicksilver> well, I'm keeping score. Of course I'm ahead :)
08:43:22 <byorgey> according to my records, the score is 17 to Q
08:43:23 <alexsuraci> does anyone know if irssi can do per-channel hilighting rules? people keep mentioning "alex" in here and I get all excited and realize they don't mean me and I'm tired of crying myself to sleep :(
08:43:37 <bavardage> P
08:43:38 <bavardage> *:P
08:43:44 <bavardage> alex...
08:43:49 <alexsuraci> D:
08:43:53 <bavardage> ..ander is NOT my name
08:43:59 <bavardage> alexsuraci: not you
08:44:01 <quicksilver> alexsuraci: yes, it can.
08:44:06 <bavardage> the whole world doesn't revolve around you
08:44:06 <quicksilver> alexsuraci: -channels option to /hilight
08:44:10 <quicksilver> alexsuraci: /help hilight
08:44:17 <alexsuraci> bavardage: lol
08:44:21 <alexsuraci> quicksilver: great, thanks
08:46:00 <alexsuraci> quicksilver: I guess that'd be "channels = '#foo, #bar'" in the config?
08:46:25 <quicksilver> alexsuraci: I've never actually used it. presumably :)
08:47:03 <alexsuraci> I'll just wing it and see what happens.
08:47:57 <bremner> anyone know how to get suraci working from hackage?
08:48:04 * bremner ducks
08:48:18 <alexsuraci> haha, I don't have that hilight set
08:48:27 <alexsuraci> ...but please no one make a package named "suraci"
08:48:50 <quicksilver> too late, I can't cancel the upload now :P
08:49:01 <alexsuraci> curses
08:49:02 <opqdonut> :D
08:51:14 <alexsuraci> I wish irssi had better documentation
08:51:56 <quicksilver> so do I.
08:51:58 <alexsuraci> no idea how I'd do a list in their config syntax, which is what it wants for the channels setting
08:52:05 <quicksilver> the irssi IRC channel is helpful though.
08:52:18 <quicksilver> you can also use the command to set it manually, then do a /save
08:52:24 <quicksilver> and look athte format of the config it /saved ;)
08:53:42 <Gracenotes> alexsuraci: real men determine functionality from reading the source
08:53:47 <Gracenotes> blind-folded
08:54:06 <quicksilver> real men scatter iron filings in the air above the hard disk containing the source
08:54:12 <quicksilver> and watch the way they fall
08:54:24 <quicksilver> listen to, rather.
08:54:56 <Gracenotes> smell
08:55:33 <quicksilver> ok, you win.
08:55:41 <alexsuraci> sigh, asked in #irssi, that was useless
08:55:57 <alexsuraci> their topic says not to edit the config file by hand, which I guess is because they're too lazy to properly document its syntax
08:56:57 <quicksilver> ;)
08:57:02 <quicksilver> well, perhaps so.
08:57:15 <quicksilver> It's free software you can fix it, you can stop using it, or you can ask for a full refund ;)
08:57:21 <quicksilver> using "/save" works for me.
08:57:29 <alexsuraci> ...aand the generated syntax from /save is wrong even
08:59:29 <alexsuraci> there we go
08:59:43 <alexsuraci> ("#foo", "#bar")
08:59:56 <alexsuraci> the reason they can't just properly document that in 1 line of text on their site escapes me
09:01:25 <vixey> "real men" are pretty daft!
09:01:40 <Cale> So apparently (for anyone following my thread of annoyance with HGL), it doesn't seem as simple as isEmptyChan blocking.
09:01:58 <Cale> I think I should just find something else to use :)
09:03:35 <zachk> Cale: I have HGL questions myself. in http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4184#a4184  I have to have a print statement and move the mouse in the window to get my text to float nicely. is there a workaround something like a flush on the graphic window, or a constant event cycle?
09:04:08 <Peaker> @type bracket
09:04:09 <lambdabot> Not in scope: `bracket'
09:04:14 <Peaker> @type Control.Exception.bracket
09:04:15 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
09:04:59 <Cale> zachk: That's my friend's problem too. My program works just fine on my machine, but on hers, maybeGetWindowEvent never returns Nothing, and it seems to even get stuck on getWindowTick too.
09:05:13 <Gracenotes> how long did it take you xmonad users to get used to it?
09:05:32 <Gracenotes> i.e., use it as efficiently as your previous window manager
09:05:45 <alexsuraci> Gracenotes: not too long, there are some quirks but the power it gives me with dual monitors makes it indispensible
09:05:55 <Cale> zachk: you have a different sort of loop though
09:06:02 <alexsuraci> I absolutely love that I can have different workstations on the individual displays
09:06:05 <Gracenotes> ah. I has no dual monitors. I'm hoping it's worth it though...
09:06:18 <Gracenotes> trying it on my second laptop (not this one)
09:06:30 <alexsuraci> It's a great WM in its own right.
09:06:46 <Gracenotes> do you just do something like xmonad --replace, to start it?
09:06:47 <zachk> cale: yeah i tried getWindowTick it just seemed to hang. I am wanting to move my code from hopengl because my ubuntu linux install's opngl drivers do not work 100% with my hardware. They are really iffy and messy.
09:06:53 <Cale> zachk: If you use openWindowEx, you can set a time in milliseconds between ticks, and then getWindowTick w is supposed to wait for the next tick to occur (presumably after you've handled events)
09:07:34 <zachk> Cale: What do i set the Maybe Time field to. Just 100 say for a 100 milliseconds loop?
09:07:36 <Cale> But yeah, there seems to be some strange problem where it just hangs on my friend's machine if she's not providing it with events, and often it hasn't even processed her newest events when it hangs.
09:07:46 <Cale> yeah
09:09:08 <mc___> is there something like repeat, but which repeats a list instead of a single element?
09:09:16 <Cale> mc___: cycle?
09:09:21 <Cale> > cycle [1,2,3]
09:09:23 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
09:09:36 <mc___> Cale: yeah, exactly :) thank you
09:09:39 <georgehorse> Gracenotes: it took me very little time to get used to xmonad. and I didn't know haskell at all when I began to use it
09:10:02 * Berengal has been wondering about xmonad for a long time
09:10:25 <Berengal> I'm sort of weird about my WMs though...
09:10:40 <Cale> zachk: Out of interest, what windowmanager are you using?
09:10:53 <Berengal> I went for weeks on arch with just twm and xterm, but then I switched to KDE4 and turned the bling to 11
09:11:17 <Gracenotes> georgehorse: ah, do you find knowing Haskell better makes it easier to use?
09:11:19 <georgehorse> but to be fair I don't ask much of my WM.
09:11:58 <georgehorse> Gracenotes: Not using per se, but configuring.
09:12:12 <Gracenotes> right.. http://haskell.org/haskellwiki/Xmonad/Config_archive
09:12:20 <zachk> Cale: gnome? default for ubuntu intrepid ibex :-/ I tried gentoo :and arch and gentoo didnt recognize my ethernet cards, and i couldnt get arch working with my router. so default for ubuntu intrepid ibex
09:12:27 <zachk> not sure which one it is
09:12:30 <zachk> how do i check?
09:12:49 <Cale> zachk: Probably metacity, if it's Gnome's default.
09:12:50 * Gracenotes mans the man xmonad
09:13:07 <Cale> zachk: Will you try my program?
09:13:44 <Cale> zachk: http://cale.yi.org/share/GraphicsDemo.hs
09:14:43 <Cale> Oh, apparently my friend just discovered that compiling with -threaded fixes the problem.
09:15:03 <Cale> Which I find fairly mysterious.
09:15:11 <Cale> But if it fixes it, it fixes it.
09:15:35 <quicksilver> -threaded makes FFI calls non-blocking.
09:15:49 <quicksilver> that is a pretty significant change to certain kinds of API design.
09:15:56 <quicksilver> You need -threaded to make my reactive code work properly.
09:15:58 <Cale> mm, interesting
09:16:17 <quicksilver> (I mean they still block that thread, obviously, but with -threaded they allow other haskell threads to proceed)
09:16:49 <Cale> The extra strange thing is that the code works fine without -threaded on my machine, and blocks while not actively receiving window events on my friend's.
09:17:09 <Cale> Maybe it's a difference between versions of some underlying C library :P
09:17:30 <alexsuraci> Gracenotes: feel free to peek at my config: http://github.com/vito/dotfiles/blob/acf84629f0f983d6aaf0682d59286e5113c6793c/.xmonad/xmonad.hs
09:17:40 <Gracenotes> *peeks*
09:17:45 <georgehorse> same versions of GHC, same flags/options compiling every package?
09:18:05 <zachk> Cale: I get a small flickering black dot on a cyanish background
09:18:37 <Cale> zachk: you should be able to use the arrow keys
09:18:43 <Cale> zachk: to push it around
09:19:23 <Cale> zachk: if that doesn't appear to work, move the mouse around in circles on the window and see if it works then
09:19:27 <zachk> cale: oh sweet didnt check those. now it has a little cone of exhaust
09:19:31 <Cale> yeah :)
09:19:40 <Cale> okay, so it works on your machine -- without threaded?
09:20:05 <zachk> i just did ghc --make GraphicsDemo ; ./GraphicsDemo
09:20:10 <Cale> okay, cool
09:20:19 <zachk> is there a way to get rid of the flickering?
09:20:43 <Cale> DoubleBuffering is *supposed* to do that, but I'm not sure why it hasn't. It's probably something I'm doing wrong.
09:21:16 <Cale> Just to be sure, the dot actually moves, yeah?
09:21:25 <zachk> yes, Cale
09:21:28 <Cale> okay :)
09:22:01 <Cale> On my friend's machine it won't move without something like constantly moving the mouse in circles over the window
09:22:05 <zachk> you might want to try a different draw command. there was directdraw and something else. Thanks for the help so far, i have to go run errands, peace all
09:22:17 <Cale> (it stops whenever there are no events coming in, without the threaded runtime)
09:22:18 <zachk> Cale: sounds like what is happening with my code without threading
09:22:22 <zachk> yea
09:22:24 <zachk> latter
09:22:26 <Cale> later
09:26:18 <mmorrow> , vacuum (cycle [0])
09:26:20 <lunabot>  [(0,[1,0]),(1,[])]
09:26:48 <mmorrow> , vacuum (take 10 [0..])
09:26:50 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
09:26:57 <mmorrow> , vacuum (take 10 (cycle [0]))
09:26:59 <lunabot>  [(0,[1,2]),(1,[]),(2,[1,3]),(3,[1,4]),(4,[1,5]),(5,[1,6]),(6,[1,7]),(7,[1...
09:27:05 <EvilTerran> ... how does one interpret vacuum's output?
09:27:07 <mmorrow> oh
09:27:35 <EvilTerran> , vacuum (repeat 0)
09:27:36 <Saizan_> Graph = [(Node,Children)]
09:27:37 <lunabot>  [(0,[1,0]),(1,[])]
09:27:39 <mmorrow> EvilTerran: this vacuum function is an early one, so it's different from the one in the vacuum package (it's equiv to (toAdjList . vacuum))
09:27:45 <mmorrow> but
09:27:45 <EvilTerran> i see
09:27:49 <mmorrow> yeah, that Saizan said
09:27:59 <mmorrow> , fix (0:)
09:28:01 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:28:07 <mmorrow> , vacuum (fix (0:)) {- i meant -}
09:28:10 <lunabot>  [(0,[1,0]),(1,[])]
09:28:18 <EvilTerran> in this case, "v0 = v1 : v0; v1 = 0"
09:28:25 <quicksilver> it's a directed adjacency list
09:28:25 <mmorrow> two nodes, the first of which has a ptr to itself and one to the second node
09:28:35 <quicksilver> so the nodes with no 'neighbours' are the actual numbers
09:28:39 <quicksilver> the atoms.
09:28:53 <mmorrow> yeah, constructors with only literals
09:29:03 <mmorrow> , vacuum 1
09:29:05 <lunabot>  [(0,[])]
09:29:18 <mmorrow> , vacuum (Just 1)
09:29:20 <lunabot>  [(0,[1]),(1,[])]
09:29:28 <quicksilver> I don't think you said what you mean.
09:29:33 <QtPlaty[HireMe]> Whats vacuum
09:29:35 <quicksilver> Surely it's nullary constructors, literal or not.
09:29:51 <mmorrow> Int# 42# == 42
09:29:53 <quicksilver> , vacuum True
09:29:55 <lunabot>  [(0,[])]
09:30:05 <mmorrow> it's not showing the literals here
09:30:17 <quicksilver> that's a funny sense of the word 'literal'
09:30:24 <mmorrow> so *any* constructor with no ptrs comes out as [(0,[])]
09:30:29 <quicksilver> you mean it's not showing the underlying unboxed bit.
09:30:38 <quicksilver> "123" is a literal, you know? :)
09:30:39 <mmorrow> quicksilver: literal := machine {int,float,double,..}
09:31:01 <mmorrow> yeah, i guess i should clarify what i mean by "literal"
09:31:11 * quicksilver nods
09:31:15 <quicksilver> I know what you mean, in fact.
09:31:26 <quicksilver> I was either clarifying out of pedantry, or to help other people listening.
09:31:30 <quicksilver> depending how kind you feel :)
09:31:31 <mmorrow> you're a trickster
09:31:37 <mmorrow> :)
09:31:40 <quicksilver> that I am.
09:32:11 <mmorrow> QtPlaty[HireMe]: http://moonpatio.com/vacuum/
09:32:16 <quicksilver> it works quite well,  because it ends up not exposing GHC internals
09:32:21 <quicksilver> (like the Int# stuff)
09:32:32 <quicksilver> it ends up being more or less an implementation independent view.
09:32:55 <quicksilver> , [$ty | vacuum]
09:32:56 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
09:33:06 <quicksilver> how do you do that?
09:33:08 <mmorrow> quicksilver: yeah, the version in the package though return an (IntMap HNode) representing the heap graph, which contains GHC-specifics though
09:33:16 * quicksilver always forgets luna syntax.
09:33:25 <mmorrow> (but you can do (toAdjList . vacuum) to get the [(Int,[Int])]
09:33:26 <mmorrow> )
09:33:31 <mmorrow> , help
09:33:33 <lunabot>  type of an expression:      , [$ty| \x -> x |]
09:33:33 <lunabot>  get info for a type/class:  , src ''Monad
09:33:33 <lunabot>  get info for a var/con:     , src 'fix
09:33:45 <mmorrow> , [$ty| help |]
09:33:48 <lunabot>  Doc
09:33:52 <QtPlaty[HireMe]>   /win 23
09:34:08 <quicksilver> , [$ty | vacuum|]
09:34:10 <lunabot>  luna: parse error on input `|]'
09:34:15 <quicksilver> , [$ty | vacuum |]
09:34:16 <lunabot>  luna: parse error on input `|]'
09:34:23 <quicksilver> , [$ty| vacuum |]
09:34:26 <lunabot>  forall a . a -> [] ((Int, [] Int))
09:34:30 <quicksilver> damn syntax.
09:34:34 <mmorrow> heh, i guess the parser for QQ syn is finicky
09:36:13 <mmorrow> quicksilver: that original "transpose" one is still my favorite http://moonpatio.com/vacuum/gallery/transpose.html
09:36:45 <Axman6> http://twan.home.fmf.nl/blog/haskell/non-regular1.details been a while since i was really amazed by something in haskell
09:37:01 <Phillemann> Isn't there something more comfortable than (ByteString.pack "foobar") to write ByteString literals? :/
09:37:17 <twanvl> Axman6: :)
09:37:32 <Axman6> twanvl: that was yours?
09:37:40 <twanvl> yes
09:37:58 <Axman6> well nice work :D pretty awesome stuff
09:38:06 <Cale> Phillemann: you can import the ByteString library as B or something so that it becomes B.pack
09:38:47 <mmorrow> you can use overloaded strings too
09:38:50 <Phillemann> Cale: Yes, that's what I currently do.
09:38:58 <Axman6> can @ be used anywhere in haskell apart from in pttern matches?
09:39:04 <mmorrow> Axman6: no
09:39:09 <Axman6> shame
09:39:13 <mmorrow> (well, you can do (@@))
09:39:15 <quicksilver> mmorrow: yes, it illustrates quite a lot.
09:39:18 <Phillemann> mmorrow: What's that?
09:39:39 <Axman6> i was thinking that something like @"thing to become a bytestring" might be handy
09:39:55 <mmorrow> Phillemann: the ghc manual would probably do a better job of explaining it than me, i've only used it once
09:39:56 <quicksilver> you can make a one-letter name for pack if you like
09:40:02 <quicksilver> p = B.pack
09:40:04 <Axman6> much like String objects in Objective-C
09:40:16 <quicksilver> p"thing to become a bytestring"
09:40:23 <quicksilver> overloaded strings let you remove that one characters
09:40:30 <quicksilver> seems like a waste of an extension to me
09:40:36 <quicksilver> but obviously someone liked it.
09:40:39 <mc___> the type signature of  decrypt' here is really freaking me out, I thought that it would simply take a tuple, but it seems to want a function, may someone explain that to me?
09:40:49 <doserj> overloaded strings also allows pattern matching against literals
09:41:05 <Cale> mc___: What is the type?
09:41:10 <Cale> mc___: (what library?)
09:41:19 <mc___> ah forgot to paste, sorry http://haskell.pastebin.com/m34e6bceb
09:41:28 <Axman6> heh
09:41:48 <Cale> ah
09:42:00 <Axman6> mmorrow: `xor`
09:42:07 <Axman6> uh, mc___
09:42:08 <quicksilver> doserj: doesn't quite convince me either :)
09:42:26 <Cale> :t xor
09:42:27 <lambdabot> forall a. (Bits a) => a -> a -> a
09:42:46 <Cale> mc___: You're passing xor as a parameter to the first component of the tuple t
09:42:55 <Axman6> mmorrow: you meant xor to be infix right?
09:43:05 <Axman6> mc___*
09:43:06 <Axman6> -_-
09:43:13 <mc___> ah, thank you :) stupid mistake
09:43:18 <Axman6> sorry mmorrow :)
09:43:24 <mmorrow> :)
09:43:54 <Cale> At first I didn't see how you'd defined decrypt' there, and thought it was some kind of strange unfold :)
09:44:33 <kadaver_> @index xor
09:44:33 <lambdabot> Data.Bits, Foreign
09:44:48 <doserj> quicksilver: yeah. pattern matching strings is not so frequent anyways. I would like to have "s++t" patterns, though :)
09:44:59 <Axman6> :t Foreign.xor
09:45:00 <lambdabot> forall a. (Bits a) => a -> a -> a
09:45:25 <mmorrow> doserj: then you could have non-terminating patterns
09:45:56 <Axman6> well it'd probably have to be in the form of "this is a literal string"++xs right?
09:46:07 <mmorrow> (\(_++(x:42:_)) -> x) (repeat 0)
09:46:18 <mmorrow> but whatever
09:46:19 <doserj> yes. inspired by the glorious n+k patterns :)
09:46:22 <mmorrow> heh
09:46:36 <kadaver_> > xor 1 0
09:46:37 <lambdabot>   Add a type signature
09:46:51 <vixey> you already have non terminating patterns
09:46:52 <kadaver_> > xor (1::Bit) (0::Bit)
09:46:53 <lambdabot>   Not in scope: type constructor or class `Bit'Not in scope: type constructor...
09:46:58 <vixey> something as simple as () could not terminate
09:47:10 <mmorrow> vixey: but not as a result of the pattern
09:47:28 <mmorrow> as a result of evaluating the value to match _against_ it
09:48:04 <mmorrow> well, it's a meaningless distinction i guess, because a ++ pattern would just get translated into an expression anyways
09:48:19 <Peaker> newtype Void = Void Void  -- if newtype adds no new bottoms, where does   undefined :: Void   come from? :)
09:48:53 <mmorrow> what?
09:49:01 <EvilTerran> Peaker, well, (undefined :: Void) = Void (Void (Void (...))), iirc
09:49:15 <mmorrow> Void undefined == undefined == Void (Void undefined)
09:49:26 <mmorrow> yeah
09:50:19 <Peaker> Well, given:  newtype N = N O     N has the same number of bottoms as O, right?
09:50:58 <EvilTerran> yeah
09:51:04 <EvilTerran> so Void has the same number of bottoms as Void
09:51:10 <Saizan_> Peaker: you miss the axiom: every type has one bottom
09:51:12 <EvilTerran> (durr hurr :P)
09:52:07 <Baughn> One or more bottoms
09:52:12 <Saizan_> (and exactly one, depending on how we consider equality/identity)
09:52:36 <Baughn> I find it convenient to distinguish between Just undefined and undefined
09:52:49 <Saizan_> except that Just undefined is not bottom
09:53:16 <Berengal> > let qs f l = if null l then [] else let (h:t) = l in f (filter (<=h) t) ++ h:f (filter (>h) t) in fix qs [1,23,5,3,2,4,6,7,4,4]
09:53:17 <lambdabot>   [1,2,3,4,4,4,5,6,7,23]
09:53:19 <Saizan_> since undefined < Just undefined
09:53:57 <DrSyzygyFR> How do I use the UserHooks in Cabal to hook into ./Setup test ??
09:54:22 <doserj> > isJust undefined
09:54:23 <lambdabot>   * Exception: Prelude.undefined
09:54:29 <doserj> > isJust (Just undefined)
09:54:30 <lambdabot>   True
09:54:34 <QtPlaty[HireMe]> Saizan_: I didn'r think they woud be comparable
09:55:05 <Saizan_> QtPlaty[HireMe]: the term bottom comes from lattice theory, the order i use that is the one of "definedness"
09:55:15 <Saizan_> s/that/there/
09:55:17 <Baughn> Saizan_: I can always use reallyUnsafePointerComparison#
09:56:10 <gueux> hi
09:56:15 <Saizan_> Baughn: are you assuming Just is the constructor of a newtype there? i don't see how that matters otherwise
09:57:06 <Baughn> Saizan_: Hm. If it were, they'd be the same thing, though
09:57:31 <Saizan_> and if it isn't what does comparing the pointers get you?
09:57:39 <gueux> I would like to compile my program to windows and I'm on linux... is it possible?
09:57:47 <Baughn> Saizan_: Oh, that's to distinguish between bottoms
09:58:01 <Baughn> Saizan_: THough I could also point to exceptions for that one
09:58:15 <Saizan_> Baughn: ok, but Just undefined is not bottom at all
09:58:28 <Saizan_> gueux: no
09:58:42 <gueux> arg :(
09:58:48 <Baughn> gueux: Perhaps. The best way would probably be to setup kvm and actually run windows on your linux so you can compile while you compile
09:58:50 <Saizan_> gueux: you might use a virtual machine
09:58:57 <doserj> http://haskell.org/haskellwiki/GHC_under_WINE
09:59:25 <Baughn> ..you can do that? oO
10:00:49 <Saizan_> so you'd be using wine to emulate windows to use msys to emulate unix?
10:03:09 <stulli> Hi. Is it possible to make a Type like data Temp = C Float | F Float and be able to calculate C 4 + F 6?
10:03:18 <Peaker> I can structure my protocol code as:   Protocol { lineReceived = handle it, eofReceived = handle it }   or as an action:  do { c <- hGetContents ; forM_ (lines c) $ handle line ; handle eof }
10:03:20 <vixey> stulli: what would the result be
10:03:26 <Peaker> I am wondering what is preferable..
10:03:42 <Baughn> stulli: Yes. Read about type-classes, then instance Num
10:03:44 <Peaker> (for the general case, of course, and not simple line receivers)
10:03:54 <Baughn> stulli: Although, I am curious about why you want such a structure..
10:03:55 <stulli> vixey, thats what i would want to define
10:03:59 <alexsuraci> has anyone mentioned "alex" within the last hour?
10:04:00 <vixey> stulli: what would the result be..?
10:04:05 <vixey> C 4 + F 6 = ?
10:04:41 <Peaker> stulli: it might be a better idea to separate temperatures into different types:  newtype Farenheight = F Double ; newtype Celcius = C Double ; f2c f = ... ; c2f c = ...
10:04:49 <Baughn> stulli: data Tag = C | F; data Temp = Tag Float
10:05:09 <Peaker> data Temp = Temp Tag Float there
10:05:25 <ddarius> data Temp = Temp !Tag !Float
10:05:40 <stulli> vixey, depends on the implementation. lets say C <result>
10:05:53 <vixey> stulli: ok so my suggestion is instead to write:  c 4 + f 6
10:06:08 <vixey> then you have c = id, f = convertFToC
10:06:15 <vixey> this way you can just use the normal +
10:06:17 <stulli> Peaker, thats what i already did, but i think the f2c functions are pretty annoying
10:06:32 <Baughn> c = convertCtoK, f = convertFtoK
10:06:55 <Baughn> stulli: But sure, instance Num all you like
10:07:03 <Peaker> stulli: then vixey is right -- have: data Temp = MkTemp Double -- the fact this Double is in celcius and even MkTemp itself can be a hidden implementation detail
10:07:14 <EvilTerran> but then you get into multiplying temperatures and it gets a bit odd
10:07:15 <edwardk> bah, so much more fun to make C and F into constructors and define a Num instance functions from each. ;)
10:07:19 <vixey> that's not what I said ...
10:07:42 <Peaker> stulli: fromF/fromC and toF/toC might be better names (Temp -> Double, Double -> Temp, ....)
10:07:49 <edwardk> so that you can say 4 C => -32 F ;)
10:07:55 <edwardk> er >=
10:08:18 <Peaker> vixey: sorry, I agreed with the function thing but still thought an abstract data type was nice there
10:08:20 <edwardk> er Num instance for functions from
10:08:56 <stulli> Ok, thanks for the tips so far. I guess a Temperature Monad is a silly idea?
10:09:09 <vixey> yes that is really silly
10:09:26 <Peaker> stulli: in order for it to be a monad it would have to be of kind *->* and that makes little sense for temperatures
10:09:29 <edwardk> stulli: it just doesn't really fit what a monad is
10:10:23 <Peaker> stulli: a temperature can't hold a value of *any* type whatsoever "inside" it
10:11:39 <edwardk> stulli: there is a notion of a completely different kind of monad that can apply mathematically, but you don't really want to go through the trouble of finding out what a galois connection is just so you can model some adjunction between converting between fahrenheit and celsius and converting back.
10:12:29 <b_jonas> lol
10:12:54 <stulli> Heh, i think i will stick with vixeys idea then :)
10:12:58 <tcb_> Hi, I have a function getCpuTemperature :: Int -> IO Int, which gives me the temperature of a core. Now I wanted to get the temperature of all cores as a list. So is there way to "map getCpuTemperature [0..numCpus]"? Sorry, I'm kind of new to haskell and haven't really got a clue of the IO-Monad yet.
10:13:13 <vixey> tcb_: mapM
10:13:20 <vixey> just look at the types
10:13:26 <Peaker> stulli: a Temp abstract data type might help you get compile-time errors if you try to use temperatures in a wrong way (add a temperature with a number or such)
10:13:33 <tcb_> thank you, will look at that.
10:13:35 <Baughn> tcb_: Control.Monad has a bunch. mapM, forM, forever.. lots of control structures
10:13:41 <vixey> @let getCpuTemperature :: Int -> IO Int; getCpuTemperature = undefined
10:13:42 <lambdabot>  Defined.
10:13:48 <vixey> :t map getCpuTemperature [1..10]
10:13:50 <lambdabot> [IO Int]
10:13:51 <vixey> :t mapM getCpuTemperature [1..10]
10:13:53 <lambdabot> IO [Int]
10:14:07 <b_jonas> that reminds me, how is sequence defined?
10:14:09 <vixey> tcb_, (those)
10:14:09 <b_jonas> @src sequence
10:14:10 <lambdabot> sequence []     = return []
10:14:10 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:14:10 <lambdabot> --OR
10:14:10 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:14:39 <Peaker> the fact its defined in terms of return and liftM2 which exist in Applicative as pure and liftA2 shows that its really an Applicative operation, btw
10:14:50 <Peaker> @src sequenceA
10:14:50 <lambdabot> Source not found. That's something I cannot allow to happen.
10:14:54 <Peaker> @type sequenceA
10:14:56 <lambdabot> Not in scope: `sequenceA'
10:15:01 <Peaker> @hoogle sequenceA
10:15:02 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:15:02 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
10:15:25 <b_jonas> Peaker: hmm
10:15:27 <FunctorSalad> anyone else getting "templates/wrappers.hs:133:15: Not in scope: `alexEOF'" with current alex/ghc6.10.2? :-(
10:15:32 <FunctorSalad> sorry
10:15:34 <FunctorSalad> wrong window :)
10:15:59 <b_jonas> @hoogle (Applicative m) => [] (m a) -> m ([] a)
10:15:59 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:15:59 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:15:59 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:18:06 <b_jonas> Peaker: I see
10:18:39 <Peaker> > Data.Traversable.sequenceA [[1,2],[3,4]]
10:18:40 <lambdabot>   [[1,3],[1,4],[2,3],[2,4]]
10:18:51 <b_jonas> yeah
10:20:27 <b_jonas> basically (Foldable a) means a value of type (a b) can be converted to ([] b)
10:21:03 <b_jonas> and Traversable means more, it means you can convert it to a list and then convert a modified list back to a value of the same shape with new contents
10:21:52 <b_jonas> or something like that
10:22:44 <edwardk> b_jonas: not quite
10:22:53 <edwardk> b_jonas: you don't have to be able to convert a list back into it
10:23:09 <edwardk> just have to be able to stream out to a list basically
10:35:12 <quicksilver> mmorrow: my simple force-based layout code sent to haskell-cafe
10:35:17 <quicksilver> mmorrow: FWIW which isn't much.
10:35:27 * quicksilver kind of hopes it spurs someone to turn it into something realy cool, though.
10:36:57 <Berengal> Force as in star wars?
10:37:21 <quicksilver> hell yeah.
10:37:21 <quicksilver> (sadly not)
10:38:04 <Peaker> Anyone here has any strong opinions about whether to define protocol implementations in Haskell as explicit state machines - vs code-flow based state machines?
10:38:23 <Peaker> event-driven  VS  synchronous read calls?
10:38:29 <Nafai> Peaker: What's the difference between the two types of state machines?
10:39:01 <Baughn> Peaker: Doesn't "event-driven" mean "synchronous takeMVar calls"?
10:39:14 <edwardk> i rather like code flow rather than data driven state machines as the 'final coalgebra' vs. an 'initial algebra' interpretation as oleg would put it. i find it reads more naturally.
10:39:36 <edwardk> or did i misparse what you asked
10:40:08 <Peaker> Nafai: Example:  explicit state machine might have a current state and entry point actions that handle events and advance the state explicitly.  code-flow-based would be something like:  forever $ do { msg <- recvNextMessage ; if msg == "HELLO" then do { .. we're in the implicit HELLO state here .. }
10:40:36 <Peaker> Baughn: nah, I'd call that synchronous recv-based.. I'd define event-driven as having different actions to handle different events
10:40:49 <edwardk> peaker: did you ever read the 'finally tagless' paper?
10:40:55 <Peaker> edwardk: nope
10:41:12 <edwardk> http://lambda-the-ultimate.org/node/2438
10:41:27 <Peaker> edwardk: I think you didn't misparse what I ask.. it can read more naturally, especially in the simple cases
10:41:43 <Peaker> edwardk: I have a hunch (that might be wrong) that explicit-state machines might have more power in some situations
10:41:57 <quicksilver> explicit can be optimised by clever combinators.
10:41:59 <edwardk> it targets a different domain, but if you read between the lines it offers a nice model
10:42:08 <quicksilver> code-flow can only be optimised by a clever compiler, which is out of your hand.
10:42:13 <edwardk> as can implicit, as that paper shows ;)
10:42:18 <quicksilver> on the other hand, the compiler *is* fairly clever.
10:42:39 <quicksilver> hmm.
10:42:49 <edwardk> ultimately you 'interpret' the nice explicit data structure, the tagless approach there basically just eliminates the intermediate data structure
10:42:50 <quicksilver> functions can't be introspected in haskell, that was my point.
10:42:55 <quicksilver> Am I missing something?
10:43:30 <edwardk> take a look at the paper, its a different perspective than you might be thinking i am advocating
10:43:48 <edwardk> i'm not saying 'use arbitrary functions instead'
10:44:00 <edwardk> i'm saying don't build up some silly ADT just to tear it down
10:44:00 <Peaker> parallel-execution/performance-wise, there shouldn't really be a difference right? I can execute each event handler in its own Haskell thread
10:44:20 <quicksilver> edwardk: ok, well that's not what I understood by code-flow based state machines :)
10:44:33 <quicksilver> probably my mistake.
10:45:16 <edwardk> quicksilver: http://okmij.org/ftp/tagless-final/APLAS.pdf is the paper in question (the link before was broken)
10:45:24 <Peaker> I am really worried about "indeterministic-by-default" that threading might bring.  I've written my network stuff in Python's Twisted before
10:45:34 <Peaker> and have barely touched Haskell threads yet
10:45:43 <mc___> What the heck? http://haskell.pastebin.com/m1e8e4ee9 the file loads in ghci, but I cant compile it...  this is the file http://haskell.pastebin.com/m6ecbb923
10:46:19 <edwardk> page 6 or so defines a class 'Symantics' which basically shows how to instead of building up some ADT based representation you can work with a bunch of combinators in a typeclass instead
10:46:32 <Baughn> Peaker: http://www.cs.kent.ac.uk/projects/ofa/chp/tutorial.pdf <-- Have a look at this
10:46:36 <edwardk> then you can put together your codeflow based engine using combinators, and compile or do whatever you want
10:47:12 <edwardk> basically HOAS without the constructor noise
10:47:21 <mc___> nevermind my problem ...
10:47:22 <Gracenotes> I wonder if 'combinator' can be considered a buzzword
10:47:38 <Gracenotes> in light of the recent discussion about it. It's so generic and good-sounding, it certainly has potential!
10:47:40 <b_jonas> edwardk: http://erxz.com/pb/17229
10:47:44 <edwardk> Gracenotes: hah
10:47:50 <Peaker> Baughn: looks cool, thanks
10:48:05 <Peaker> Baughn: do you know if it is a good match for network servers handling multiple connections/etc?
10:48:14 <b_jonas> edwardk: that's what I mean: I can construct the traversable from a list using another traversable as a pattern for its shape
10:48:19 <edwardk> b_jonas: sure
10:48:38 <Baughn> Peaker: Shouldn't be a problem
10:48:46 <b_jonas> eg if I have a tree of some shape, I can create the same shape with different values, with thsoe values read from a list
10:48:50 <edwardk> b_jonas: but you have to have a shape lying around to 'rotoroot' out all of the existing values and plumb in new ones ;)
10:49:00 <b_jonas> edwardk: yeah
10:49:06 <Baughn> Peaker: I don't know how good a match it is, but it's written to remove the nondeterminism you were worried about
10:49:15 <edwardk> b_jonas: although the correctness of your approach relies on you having enough a's lying around in your list
10:49:16 <Peaker> Baughn: Weird that I've never heard of it before
10:49:35 <b_jonas> edwardk: yeah, you can't really do anything if the list is empty of course
10:49:46 <Baughn> Peaker: It's based on the Communicating Sequential Processes seminal paper.. sadly, lots of places seem to have forgotten about it
10:49:50 <Peaker> Baughn: its not cabalized?
10:49:56 <Baughn> Peaker: cabal install chp
10:50:18 <Peaker> Baughn: oh cool, thanks
10:50:29 <Zao> Does #haskell-in-depth have much traffic? I saw the announce now when catching up on -cafe but can't join as I'm out of channels.
10:50:42 <Peaker> Baughn: seems to be unmaintained (bad .cabal file for ghc >=6.10)
10:50:48 <b_jonas> by the way, is there a consumer monad transformer somewhere on cabal which is like state but with the state being a list and you can only modify it by consuming an element from its start (maybe you could also peek it)
10:50:53 <b_jonas> ?
10:51:05 <edwardk> zao: yeah it gets a fair bit
10:51:28 <Baughn> Peaker: Yeah, I noticed that. It's not quite unmaintained, but..
10:51:45 <Baughn> Peaker: Still, easy to fix the .cabal file
10:52:11 <EvilTerran> b_jonas, well, it'd be a fairly trivial wrapper around StateT
10:52:15 <EvilTerran> StackT, eh?
10:52:22 <edwardk> hrmm is the CHP stuff basically just session typing with kind of boring sessions?
10:53:13 <b_jonas> EvilTerran: I think ReaderT would be a good name for it becuse it's the pair of Writer, but Reader is already used up
10:55:43 <Saizan_> b_jonas: i've seen it called MonadSupply
10:55:46 <Peaker> Build-Depends has: "base<4" but cabal install is still complaining that "it is a member of the hidden package `base'"
10:55:54 <b_jonas> Saizan_: supply? I see
10:56:03 <Baughn> Peaker: old-exception is in base-4, not base-3
10:56:09 <b_jonas> EvilTerran: it might also be a simple wrapper over parsec
10:56:10 <Peaker> oh, whoops
10:56:25 <Peaker> Baughn: thanks
11:05:07 <da-x> Peaker: do you remember Waiters in znwr? That was kind of a preface to functional programming, before we bumped into Haskell
11:05:53 <Peaker> da-x: yep
11:06:34 <Peaker> da-x: and also the reason I got to Haskell is because I discovered I was reinventing functional programming when I was working on livec -- and was wondering how it was possible to functionally get rid of the destructive updates altogether.  funny conal should enter just now :)
11:07:23 <b_jonas> what's livec?
11:07:29 <Peaker> I had figured out a bit of the puzzle (the UI view was defined functionally in terms of the changing model) but not the part where I define the model as a function of user input
11:07:54 <edwardk> peaker: haha thats basically how i got drawn in. i'd reinvented so much of haskell working on a toy language that it was nice to have a much better realized version of all of my goals already built
11:08:05 <Peaker> b_jonas: an experimental non-textual editor for C that me and a few friends created in Python.. It never got beyond the toy level - as we discovered we really should switch to Haskell
11:08:15 <b_jonas> oh
11:08:29 * Cale tries to google znwr and gets nowhere :)
11:08:29 <b_jonas> I remember you mentioned something like that I think
11:08:57 <Peaker> b_jonas: I still hope to work on that -- but I'm going to have to accumulate some money and work on it full time as I discovered I cannot maintain a mentally challenging project alongside a full time job
11:09:50 <amaron_> takusen gives me a trouble with postgres and boolean fields
11:09:59 <Peaker> conal: chp seems interesting -- maybe it can serve as a better foundation for the implementation of Reactive than IO threads
11:10:12 <amaron_> first, it reads boolean fields as "t" or "f", as String
11:10:25 <suchsuch> non-textual editor?
11:10:59 <edwardk> peaker: the channel protocols it supports seem somewhat weaker than I would expect. I was looking for something like the session type stuff and there doesn't seem to be a model for richer channel protocols.
11:11:04 <Baughn> Peaker: I doubt it. IO threads can be harder to use, but that doesn't make them very /hard/ to use
11:11:15 <amaron_> then when I try to update some boolean field with bindP someBoolVar, it gives me an error that I'm trying to set boolean field with string value
11:11:19 <Baughn> Peaker: And there's a real risk of abstraction inversions.. not to mention it'd be basically slower than needed
11:11:52 <amaron_> anyone used takusen around?
11:12:59 <Peaker> Baughn: sounds like you don't recommend CHP for real use?
11:13:12 <Peaker> Baughn: why would it be very slow? What abstraction inversions?
11:13:16 <Baughn> Peaker: Not for implementing another library on the level of CHP
11:13:53 <Baughn> Peaker: I can't recommend CHP for anything, since I haven't used it much myself. It probably /is/ useful for application programming, when there are a lot of calls to thread functions.
11:13:56 <Peaker> Baughn: Reactive is very different to CHP, though - and I'd say higher-level, I don't think there'll be any inversions
11:14:35 <Baughn> Peaker: But for implementing reactive, there would be only a few calls, used often. That makes it a lot easier to write correct low-level code, and low-level code gives you more control and, typically, performance. I think it's probably a good trade-off.
11:15:29 <Baughn> Peaker: That's not to say I know that for certain, it's just my prior probability rating on the issue - prior to learning CHP properly, that is
11:15:45 <mc___> my programm is running into memory problems (it uses over 500mb...) I think this is due to lazy evaluation, I know there was a function which strictly evaluates its argument, what was it called again?
11:15:57 <Peaker> Baughn: maybe. I think Reactive has had significant implementation difficulties, so it might help
11:16:33 <Baughn> mc___: There are a variety, for use in different situations. There is no magic fairy dust.
11:16:44 <Peaker> mc___: there are plenty.. foldl' $! and many others
11:16:47 <Baughn> mc___: And rnf usually isn't the answer
11:18:09 <Cale> amaron_: I've never used it, but I know that the authors are on the Haskell and Haskell-cafe mailing lists, so you might try one of the two.
11:20:13 <Baughn> mc___: FUndamentally, you need to understand the graph-reduction evaluation model GHC uses
11:20:43 <Baughn> mc___: ..even then, it'll still trip you up. Like, say, a list not being GC'd because another list /would be/ generated from it, were its thunk ever evaluated
11:21:01 <Peaker> Baughn: hmm -- there's something strikingly ugly in CHP -- the (<->) choice operator has special treatment for the "first" event waiter in each of the given monadic actions
11:21:02 <mc___> well than I should probably be more specific, this is my programm http://haskell.pastebin.com/mf0b1672 , my understanding of haskell is very limited, but as far as I understand the try_solutions function does not actually create a list containing the numbers, but instead a list containing thunks, I want to those thunks to be evaluated immediately
11:21:26 <Peaker> Baughn: they should have had (<->) force both sides to yield a value of the same type and just wait for the whole block
11:21:50 <Peaker> Baughn: it "digs" inside into your monadic action to figure out what's the first wait in there, yuck
11:22:22 <Baughn> mc___: It doesn't, actually. map creates a thunk that, if evaluated, will evaluate to /one/ list element - plus another thunk. And so on.
11:23:13 <Baughn> mc___: maximum will hold on to at most two list elements at a time, and any other can get GC'd. So, no issues there; your memory leak is elsewhere.
11:23:37 <Peaker> mc___: "putStrLn $ show $ maximum $ try_solutions inpStr"  is nicer written as: "putStrLn . show . maximum . try_solutions $ inpStr" -- because you can then refactor parts of it more easily
11:23:39 <Peaker> @src print
11:23:39 <lambdabot> print x = putStrLn (show x)
11:23:46 <Peaker> print = putStrLn . show
11:23:51 <Baughn> mc___: That's why you can have infinite lists, and map infinite lists, etc.
11:23:59 <Peaker> mc___: so already you can see "putStrLn . show"  there can be replaced by "print", for example
11:24:19 <mc___> Baughn:  but when I remove maximum  the programm works
11:24:52 <Cale> @src maximum
11:24:52 <lambdabot> maximum [] = undefined
11:24:52 <lambdabot> maximum xs = foldl1 max xs
11:25:18 <Cale> mc___: How about when you compile with -O2 or -O?
11:25:28 <Baughn> mc___: Oh, and you're trying to decrypt a string..?
11:25:33 <mc___> I compiled it with -O2
11:25:36 <Peaker> @src replicateM
11:25:36 <lambdabot> replicateM n x = sequence (replicate n x)
11:25:40 <Cale> mc___: okay
11:25:42 <mc___> Baughn: yeah, its for project euler problem 59
11:25:53 <Peaker> mc___: you use sequence . replicate N   there, so it can be replicateM too
11:26:01 <Cale> mc___: How about foldl1' max in place of maximum then?
11:26:12 <Baughn> mc___: If it's supposed to decrypt to human-readable text, you'll find that trying to compress the decrypted text is a whole lot more reliable way of spotting the correct key than matching common words
11:26:18 <Cale> If that doesn't help, then it's not the fault of maximum.
11:26:40 <Baughn> mc___: Any wrong key will produce essentially random output, which is not compressible. Human-readable text is highly compressible. So you rank the solutions by compressibility.
11:26:55 <Cale> oh!
11:27:03 <Cale> I see
11:27:15 <mc___> Baughn: sounds like a good idea, I'll try that, but first I'd like to get this solution working :)
11:27:23 <Cale> Your instance of Ord for Collatz doesn't involve looking at the first components of the pairs
11:27:32 <Baughn> mc___: And instead of actually /compressing/ you can use a measure of internal entropy
11:27:41 <Cale> So when you compute the maximum, there are these unevaluated expressions hanging around.
11:28:19 <mc___> Cale: so I should make Collatz a strict datatype then?
11:28:30 <Baughn> mc___: Like.. computing the average length of a huffman encoding of the decrypted data. Huffman's a compressor, but you can compute the compression factor for that without actually compressing, a lot faster
11:28:34 <Peaker> mc___: I've made minor changes to your post: http://haskell.pastebin.com/m4b7bca82
11:29:43 <Baughn> mc___: Also, you should use the hackage Split library instead of cooking your own
11:29:46 <Cale> mc___: well... the a and c there are lists, so forcing them won't likely help all that much
11:30:01 <Cale> However, we can try it.
11:30:19 <mc___> guys, thanks for all your help! unfortunately I have to go now! but you already helped me alot
11:30:53 <Baughn> Cale: Doesn't quite make sense. When the COllatz is constructed, the snd depends on the entirety of the fst already
11:31:15 <Cale> Baughn: ah, I didn't see that far.
11:31:25 <Peaker> Baughn: yikes, they have a "pipeline" function that is basically foldr (.) id  -- unnecessarily limiting the types, and not saving the programmer any typing (meant to be used: pipeline [a,b,c,d] instead of a.b.c.d). the authors might be lacking in combinator design
11:32:04 <Baughn> Peaker: Maybe you should just read the original CSP paper instead. :)
11:32:40 <Peaker> Baughn: I'm reading the tutorial -- just noting a few non-beautiful things about the API.  Maybe I'm spoiled by more modern Haskell blogs
11:32:41 <Baughn> > length $ sequence $ replicate 3 [0..255]
11:32:48 <lambdabot>   16777216
11:32:54 <Peaker> > length . sequence . replicate 3 $ [0..256]
11:33:01 <lambdabot>   16974593
11:33:11 <Baughn> Peaker: ..I want a left-associative $
11:33:11 <da-x> Peaker: I think now I know enough haskell now so I can read House and make sense of it
11:33:33 <Peaker> da-x: cool
11:33:58 <da-x> when I tried to read it before I wrote some haskell code it was really tough to understand anything
11:34:08 <Peaker> da-x: Haskell is a pretty big community with very different ideas thriving in it. The House folks, I think, have very different ideas from the FRP folks.  I'm with the FRP guys :)
11:34:31 <Peaker> though House might have cool ideas too
11:34:34 <Cale> Peaker: Are you going to write an FRP operating system?
11:34:47 <da-x> No, but maybe I will :)
11:35:05 <Peaker> Cale: luqui is
11:35:08 <Gracenotes> FRP for Dummies, please
11:35:10 <da-x> Peaker likes to write editors for now :)
11:35:11 <Peaker> Cale: or at least, planning to
11:35:14 <pumpkin_> FRP FRP FRP
11:35:25 <Gracenotes> ..with working code, not confusing psuedocode
11:35:26 <Peaker> da-x: I wish I could, the full-time job is draining my mental energies
11:35:34 <Gracenotes> :,x
11:35:58 <Baughn> @pl \keys -> map (\key -> (key, foo key)) keys
11:35:59 <lambdabot> map (ap (,) foo)
11:36:22 <Baughn> > maximum $ sequence $ replicate 3 [0..255]
11:36:24 <da-x> from what I understood so far it doesn't look like a whole OS in FRP is even practical to write.
11:36:50 <lambdabot>   thread killed
11:36:54 <Peaker> da-x: well, there will be an imperative platform underneath the FRP one -- but I think that it can be FRP at a pretty low level
11:37:10 <conal> Peaker: oops -- just noticed your comments.  what's chp?
11:37:31 * EvilTerran suspects "nice in theory, but will run like molasses. in december. in canada."
11:37:31 <Baughn> @src maximum
11:37:32 <lambdabot> maximum [] = undefined
11:37:32 <lambdabot> maximum xs = foldl1 max xs
11:37:36 <EvilTerran> (cf hurd :P)
11:37:42 <Baughn> ..well, this can't be right
11:38:03 <Peaker> conal: it seems to be a library for concurrent threading that removes some of the indeterministic behavior in IO threads.  I have read a bit more of its tutorial now and found a few things I consider pretty ugly, though
11:38:58 <conal> Peaker: ah, thx.  url?
11:39:12 <Baughn> mc___: Okay, so the problem is in fact maximum..
11:39:15 <Baughn> mc___: Probably.
11:39:22 <Peaker> conal: from Baughn: http://www.cs.kent.ac.uk/projects/ofa/chp/tutorial.pdf
11:39:37 <conal> Peaker: thx :)
11:39:40 <Baughn> conal: It's an implementation of CSP, basically
11:39:49 <conal> Baughn: oh, okay.
11:39:56 <EvilTerran> "communicating haskell processes"?
11:40:03 <Baughn> Yep
11:40:09 <Peaker> conal: sure
11:40:31 * EvilTerran considered doing that himself when he was being lectured in concurrency
11:40:39 <EvilTerran> i even planned on calling it CHP :P
11:40:46 <Baughn> mc___: As a patch.. hang on
11:42:34 <Baughn> mc___: http://haskell.pastebin.com/m7dcc7f79 <-- Try this code
11:42:40 <Peaker> conal: I think the (<->) thing is a show stopper in CHP though (I mentioned it before reading the tutorial).  (<->) executes two actions in parallel, but only until one of them successfully waits for an event - once it did, it kills off the other one.  The action is thus not considered opaque by (<->)
11:42:48 <Baughn> mc___: (Changes on lines 4 through 8)
11:44:01 <Peaker> I think if you have:  do { x <- wait1 ; write stuff ; ... }  <-> { ... }  -- and someone changes "wait1" to not actually contain any wait -- you're screwed
11:45:42 <Peaker> (>>) being associative results from the monadic laws, right?
11:46:06 * da-x reads about arrows
11:46:09 <da-x> cool
11:46:13 <Peaker> its weird the CHP tutorial mentions it as a "CHP law"
11:46:27 <da-x> looks like multi-dimensional monads :)
11:47:09 <da-x> I really like the example in http://www.haskell.org/arrows/syntax.html where it would seem to me as if f() and g() can run in different threads
11:50:21 <Peaker> da-x: I think of arrows as "generalized functions" -- where you get to write the code that composes the values and the type of the values - so its kind of like non-opaque function values.  except "arr" re-inserts opaqueness so I ignore it :)
11:51:32 <Peaker> da-x: I gave a Category example the other hour - its simpler to understand than arrows and more general
11:52:07 <conal> da-x: i second Peaker's remarks.  and add that the transparency allows static analysis & optimization.
11:52:55 <kerlo> Hmm. It'd be cool to have an elegant mapping from [0,1]x[0,1] to the set of Haskell types, so that we have a fancy fractal of them.
11:53:50 <vixey> kerlo, you mean like.. associating a type of (0.55252,0.62727)?
11:53:57 <vixey> s/of/to/
11:54:29 <kerlo> Yep.
11:55:10 <kerlo> I guess Jot can do something similar.
11:55:13 <amaron_> Cale: thanks for the info
11:56:16 <da-x> I am interested in being able to transform functional code into readable imperative code. For example, when you'd like to design a embedded real-time system in functional programming but you are a control freak and want to read the produced imperative code so you know exactly what the hardware's going to do at any given moment and where evaluation/garbage collection might cause latency. I'm also interested in careful resource management
11:56:16 <da-x>  and pre-allocation (CPU and memory).
11:56:48 <vixey> da-x: just compile it
11:58:00 <Cale> I've also thought it would be interesting to come up with a simple functional language and a simple OO language with translations back and forth which were not too lossy.
11:58:55 <Peaker> is this right? f2c = mul (5/9) . add (-32)
11:59:10 <vixey> :t (-32)
11:59:13 <lambdabot> forall a. (Num a) => a
11:59:39 <Peaker> vixey: I have my own add/mul for a bidirectional computation example
11:59:59 <Peaker> I'll rephrase: f2c = (*5/9) . (subtract 32)
12:00:48 <Gracenotes> you need parens
12:01:00 <b_jonas> isn't that an syntax error?
12:01:03 <Cale> It seems right.
12:01:06 <iago_> am I wrong if I say that is "standard" in Haskell use camel case?
12:01:07 <b_jonas> @type (*5/9)
12:01:08 <lambdabot>     The operator `*' [infixl 7] of a section
12:01:08 <lambdabot>         must have lower precedence than the operand `(/)' [infixl 7]
12:01:08 <lambdabot>         in the section: `(* 5 / 9)'
12:01:10 <da-x> Cale: I'll let you know if I come up with something :)
12:01:12 <b_jonas> yeah
12:01:13 <Gracenotes> otherwise it gets confused about sections... a rather annoying 'feature'
12:01:21 <da-x> being a low-level dude I was disappointed when I found that the C code that ghc generates is very close to the bytecode and practically unreadable.
12:01:24 <b_jonas> either (*5).(/9) or (*(5/9))
12:01:32 <kadaver> what is the basic instructions needed for turingomcplete-ness? loop,inc?
12:01:46 <b_jonas> because x*5/9 means ((x*5)/9)
12:02:23 <Gracenotes> kadaver: whatever it takes to be a universal turing machine
12:02:24 <Peaker> da-x: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4196#a4196 -- here's an example of the "Category" class which is like an arrow, except simpler and better :)
12:02:35 <tromp> incr + decr_or_jump
12:02:49 <tromp> for counter machines
12:03:09 <burp_> > [ x | x <- [1..], x > 5, x < 10]
12:03:11 <Peaker> Cale: why simple OO language?  what characteristics of OO are useful to take?
12:03:24 <lambdabot>   thread killed
12:03:27 <burp_> :(
12:04:26 <conal> Peaker: maybe the closure/object connection
12:04:41 <Cale> Peaker: Well, I'm just figuring it's easier if the languages are kept simple. There's a certain duality between the way that things are expressed in FP and the way they're expressed in OO
12:04:44 <Peaker> conal: what's that?
12:05:14 <conal> Peaker: a closure is a single-method object.  an object is a record of closures with a common environment.
12:05:17 <paolino> > [x | x <- [1..12] , x > 5, x < 10]
12:05:18 <lambdabot>   [6,7,8,9]
12:05:48 <Peaker> Cale: well, I think abstract data types in imperative programming have been associated with "OO", but I think that takes out too much of the meaning from the term.  I think OO is about inheritance and polymorphism through inheritance, as encapsulation and abstract data types have been around before that.  And I think that inheritance is a bad idea
12:07:16 <Peaker> conal: well, "a record of closures with a common environment" is too broad to be associated specifically with OO, IMO.
12:08:13 <paolino> uh, I thought OO was about memory managment via stateful records
12:08:23 <Peaker> I do give OO the credit for raising awareness of encapsulation and polymorphism -- and leading to people creating much simpler and better designs
12:08:37 <BONUS> @seen dons
12:08:38 <lambdabot> dons is in #haskell-in-depth, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 20h 32m 38s ago.
12:08:39 <Peaker> paolino: The term is very overloaded
12:08:52 <BONUS> does anyone here know a rough word count of RWH?
12:11:44 <bremner> BONUS, not me, but some lynx --dumping | wc hackery could probably get it for you off book.realworldhaskell.org
12:11:57 <BONUS> hmm yeah, i'll give it a go
12:12:43 <conal> a closure's environment can be viewed as private instance variables
12:15:44 <hydo> "In order to keep track of a bunch of state stuff (for instance, for a non-trivial parser), learning the State monad is the first step to Great Justice"  Confirm/Deny?
12:15:56 <BONUS> confirm
12:16:19 <eu-prleu-peupeu> is using iorefs a good thing ?
12:16:35 <hydo> BONUS: Thanks!
12:16:46 <vixey> for parser I use
12:16:55 <vixey> [s] -> [(a,[s])]
12:16:59 <sjanssen> eu-prleu-peupeu: is using a screwdriver a good thing?
12:17:01 <conal> hydo: state for parsers?
12:17:16 <vixey> s would be Char for example, and a is the result of a parse
12:17:22 <conal> sjanssen: :)
12:17:29 <BONUS> hydo: i did a little explanation of the state monad on a forum once, maybe you're interested http://forums.somethingawful.com/showthread.php?threadid=2841145&pagenumber=6#post346173552
12:17:42 <vixey> @src State
12:17:42 <lambdabot> Source not found. :(
12:17:51 <sjanssen> eu-prleu-peupeu: IORefs are good when you need them, but you usually shouldn't need them
12:17:52 <vixey> @unmtl State s a
12:17:52 <lambdabot> s -> (a, s)
12:18:08 <b_jonas> no, hammers are much better
12:18:09 <vixey> @unmtl State [s] a
12:18:09 <lambdabot> [s] -> (a, [s])
12:18:11 <vixey> that's almost it
12:18:19 <vixey> but there isn't any non determinism
12:18:22 <hydo> BONUS: Oh yea, that's right!  I forgot about that.
12:19:10 <burp_> > filter (\x -> x > 5 && x < 10) [1..]
12:19:19 <hydo> BONUS: Hopefully that thread has picked up new steam... last time I looked at it it was stagnating a bit.
12:19:25 <lambdabot>   thread killed
12:19:59 <BONUS> nah, it's gone off a bit :) interestingly enough, writing that post made me think "i should write a tutorial" and then i started writing LYAH
12:20:38 <hydo> BONUS: LYAH is a work of awesomeness.... I've got the feed in my reader in ANXIOUS ANTICIPATION of the monad chapter.
12:20:44 <BONUS> quick query: do you think LYAH should get published as a color print or a b&w print
12:20:59 <hydo> BONUS: color
12:21:08 <vixey> color!!
12:21:24 <BONUS> haha! :) there's thousands of monad tutorials on the net until then
12:21:43 <BONUS> yeah, im gonna see what the publisher says about the price of color vs. b&w
12:22:12 <hydo> BONUS: yes, there are thousands of a lot of tutorials on the net... but there's a reason why books like yours and why_'s get a following... they speak to a certain type of developer.
12:22:12 <BONUS> i'd really like it to be color as well, but that might make it kind of expensive, so we'll see
12:22:22 <BONUS> haha
12:24:01 <BONUS> hunch: i think people would understand monads a lot better if they understood the type system, functors and applicative functors well beforehand
12:24:06 <BONUS> that's the approach i'm gonna take here
12:24:18 <Gracenotes> hm. I'm not sure if applicative functors help that much
12:24:42 <BONUS> Gracenotes: i think kind of from a stand point of "what they really are"
12:24:51 <BONUS> i remember when i was learning about monads and i couldn't imagine one
12:25:05 <Gracenotes> I think they help in showing code written in a monadic *style* vs. an applicative *style*
12:25:18 <BONUS> but i think if you know that all monads are applicative functors that allow some extra actions, you can use all the stuff you know from applicatives
12:25:32 <BONUS> like the result contained in a context, lifting a value to a default context, etc.
12:25:37 <Gracenotes> but at first they seem pointless. "Okay, so you wrap a function up in an applicative just to apply it to something? What's the point in that?"
12:25:49 <vixey> applicative parsers
12:25:52 <Gracenotes> a good explanation is required, plenty of examples. the style they lead to has advantages
12:25:55 <Peaker> I think Applicative Functor is a very important step between Functor and Monad
12:26:03 <BONUS> yeah, but once you see the examples you usually get it
12:26:05 <Gracenotes> yes, showing applicative *style* vs. monadic *style*
12:26:05 <Peaker> I see Applicative as adding sequencing/combination to Functor, and Monad as adding dynamism to Applicative
12:26:08 <Gracenotes> particularly parsers
12:26:13 <BONUS> i rely on a lot of examples, people are very good at seeing patterns
12:27:00 <b_jonas> applicative does make sense for just reader too
12:29:05 <conal> BONUS: sounds like a great plan to me.  i'd also like to see people learn Functor and Applicative before Monad.  so they get that Monad is nothing special and often overkill.
12:29:58 <Gracenotes> Functor, definitely. Applicative must be pretty clear though, non-trivial examples. Lest they be scarred for life!!!!!!
12:30:00 <Gracenotes> :o
12:30:07 <BONUS> i see it as a sort of onion thingy. if you know the inner layers, just getting the outer layer doesn't seem that scary
12:30:16 <BONUS> but if you try to eat the whole onion at once, your eyes may tear up
12:30:44 <b_jonas> BONUS: I think I understand all the examples of monads (readert, statet, contt, writert, eithert, listt, io, etc) better than monads in general
12:31:08 <edwardk> BONUS: or it may just pass through undigested... er wait this is becoming a fairly disgusting analogy
12:31:11 <BONUS> b_jonas: i think that then you probably understand monads
12:31:16 <BONUS> edwardk: lol haha
12:31:54 <conal> b_jonas: there's perhaps not much to "monads in general".  examples plus simple interface plus a few common laws
12:31:56 <b_jonas> what helps is that it's easy to imagine the side effects these have, and I've met most of these side effects already in impure languages and know what just that one side effect is capable of
12:32:14 <b_jonas> conal: sure,
12:32:22 <b_jonas> but basically I can't really imagine new monads
12:32:29 <BONUS> yeah, "monads in general" is just a type constructor, bind, return, and some laws
12:32:32 <b_jonas> I can imagine compositions and special cases of these
12:32:51 <b_jonas> which is quite a lot actually
12:32:52 <BONUS> every new monad i think of turns out to be a specialized case of State
12:33:05 <b_jonas> yeah
12:33:17 <conal> b_jonas: i see.  a trick that may help is to always ask yourself for a type Foo: what could be join :: Foo (Foo a) -> Foo a
12:33:18 <edwardk> b_jonas: well, in the type system you're in basically every monad is going to be some combination of the ones you know, or minor specializations of them anyways
12:33:26 <b_jonas> you can even compose parsec from state and either and list transformers and taking special cases
12:33:32 <BONUS> i think most normal people (unlike conal and edward, etc.) can't really come up with completely new monads
12:34:01 <b_jonas> conal: yeah, I'm still not completely sure I understand join though
12:34:05 <edwardk> b_jonas: and yeah as conal says, figuring out 'how join works' is the biggest barrier to constructing a new monad.
12:34:08 <b_jonas> but at least I think I half understand it now
12:34:18 <BONUS> join is pretty important yeah
12:34:24 <Peaker> b_jonas: I imagine Functor as a box containing some value you can modify without modifying the box (modify-in-a-copy).  I imaging Applicative as a similar box, except you can take two boxes and combine their values together while also "sequencing" the boxes.  However, when choosing boxes, you cannot look at their contents.  Monad removes this last restriction
12:34:26 <b_jonas> applicatives and functors are even harder because they're too general
12:34:30 <Gracenotes> I dunno. Seems like joining makes more sense from a category-theoretical perspective
12:34:35 <conal> b_jonas: start with the type of join.  if you can satisfy the type, you likely have a monad.
12:34:40 <Gracenotes> which I get only partially
12:34:43 <BONUS> also that join (fmap f m) = m >>= m
12:35:11 <conal> i don't think of myself as coming up with monads (or applicatives etc).  i come up with types (meanings/models, really), and then wonder if they fit standard interfaces like Monoid, Monad, etc.
12:35:15 <BONUS> Peaker: i like that way of thinking
12:35:16 <edwardk> gracenotes: i find [[a]] -> [a] to require me to figure out less than [a] -> (a -> [b]) -> [b]
12:35:21 <b_jonas> by the way the teacher just mentioned abstract category theory stuff like functors on algebraic topology class yesterday
12:35:30 <BONUS> conal: i also like that way of thinking
12:35:37 <conal> :)
12:35:37 <Gracenotes> edwardk: heh. Just combine that with fmap and you're good
12:35:38 <BONUS> that's what i like about typeclasses and haskell in general
12:35:46 <BONUS> you make something and then ask yourself "what can this act like?"
12:35:49 <b_jonas> though he did say that you don't need to know the general abstract algebra to understand those proofs he did
12:35:50 <edwardk> maybe thats because to me every time i look at a monad, the order of arguments for (>>=) screws me up
12:36:06 <b_jonas> he's a real algebra guy who does commutative diagram chasing for proving simple things
12:36:09 <edwardk> gracenotes: exactly, which is why i tend to start from the category theoretic notion of a monad, rather than the haskell one
12:36:28 <conal> BONUS: i got a lot more conscious of my process over the last two years.  i've tried to describe it in http://conal.net/papers/type-class-morphisms
12:36:30 <b_jonas> conal: that's a good thing, yes
12:36:30 <Peaker> BONUS: easier to visualize, I think :)
12:36:50 <BONUS> nice conal, i'll give that a read
12:37:57 <conal> i read people's ideas of what a monad (etc) *is* (containers etc), and i don't really relate to the question.  for me, type classes cut across (are independent of) what something is.
12:38:15 <BONUS> yeah, i think of them as what stuff can act like
12:38:19 <BONUS> which behaviors does it support
12:38:55 <conal> BONUS: i experience the same inner dissonance with that description (behaviors/act like).
12:39:16 <BONUS> ah, interesting
12:39:20 <conal> just a personal report.  not right/wrong.
12:43:59 * FunctorSalad finds it funny how gray is "black" and black is "dullgray" in ansi-wl-pprint (but otherwise that package is great)
12:44:11 <FunctorSalad> eh s/dullgray/dullblack
12:46:31 <Baughn> System.Vacuum.Cairo.view $ sequence $ replicate 2 [0..3] <-- Oh my
12:47:13 <byorgey> Baughn: screenshot plz!
12:47:20 <Baughn> Sure, give me a moment
12:48:22 <Baughn> http://brage.info/~svein/screenshot.html
12:48:26 <Baughn> (SVG support needed)
12:48:56 <Gracenotes> > sequence $ replicate 2 [0..3]
12:48:57 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[1,0],[1,1],[1,2],[1,3],[2,0],[2,1],[2,2],[2,3],[3...
12:49:11 <Baughn> Hang on, let me make an actual screenshot
12:49:19 <byorgey> does Firefox not support SVG?
12:49:20 <dons> wow
12:49:25 <dons> Baughn: that's wild
12:49:26 <edwardk> cute
12:49:31 <byorgey> I just see a bunch of (:)'s and stuff
12:49:37 <Gracenotes> me too! I've been cheated!
12:49:40 <Baughn> dons: Yeah..
12:49:48 <Baughn> Give me a.. hmm.. where's xgrab>
12:49:57 <byorgey> I assume the point is that the 1, 2, 3 are shared among all the lists =)
12:50:01 <dons> xwd ?
12:50:03 <Baughn> There are two 0s, though. :P
12:50:07 <Baughn> Ah, thanks
12:50:14 <bavardage> does anyone here use arch and has had success installing the haskell-package
12:50:18 <BONUS> hey dons thanks for the email! just one more question, do you know what the approximate word count of RWH is?
12:50:20 <bavardage> *haskell-platform
12:50:29 <conal> Gracenotes: if you link to a .svg file instead of embedding in html, i think i could view it in firefox
12:50:45 <jethr0> Bonus: word count ^_^
12:50:54 <Gracenotes> oh, yeah
12:50:57 <dons> bavardage the haskell-package?
12:51:00 <ray> if you didn't name your svg files with .html
12:51:03 <Gracenotes> I noticed that Firefox had trouble guessing the .svg extension
12:51:08 <bavardage> dons: indeed
12:51:11 <dons> bavardage: it's not supported yet. close, but not quite.
12:51:15 <Gracenotes> I tried to open a PNG file, with a PNG header and all, but with an .svg extension
12:51:16 <bavardage> oh dammit
12:51:22 <bavardage> dons: how so?
12:51:22 <Baughn> http://brage.info/~svein/wild.png
12:51:25 <Gracenotes> Firefox just showed an error with the SVG parser
12:51:26 <dons> i'll put up a release in a couple of days
12:51:27 <Baughn> So.. yeah...
12:51:36 <bavardage> dons: oh so you're the arch-haskell guy?
12:51:37 <BONUS> oh my lol
12:51:38 <byorgey> whoa, crazy =)
12:51:41 <dons> bavardage: yeah
12:51:46 <bavardage> dons: is there an arch-haskell ml or anything :D?
12:51:47 <Baughn> That's "sequence $ replicate 2 [0..3]
12:51:50 <dons> bavardage: yep
12:51:53 <Gracenotes> pure awesomeness!
12:51:58 <bavardage> dons: so atm I should just use the aur packages?
12:52:05 <dons> bavardage: for now
12:52:21 <bavardage> dons: also, are there any plans to solve the reinstall everything on ghc update?
12:52:24 <dons> haskell's remarkably concise syntax for generating interesting trees
12:52:27 <conal> yow.  cool picture.
12:52:34 <dons> bavardage: there are plans to solve it. but no solution yet
12:52:49 <Baughn> That's not a "tree". That's proof of the Flying Spaghetti Monster!
12:53:08 <jethr0> BONUS: my estimate would be 270000 words in the book RWH. Based on 450 words per page * 600 pages
12:53:08 <dons> well, 1 , 2 and 3, are shared in a complicated way
12:53:14 <dons> 720 pages.
12:53:15 <Baughn> And why are there two copies of 0, anyway?
12:53:31 <bavardage> dons: gdgd
12:53:35 <BONUS> ah, that's cool. i have a projected final word count of 120k words for lyah
12:53:41 <BONUS> + some pictures and code blocks
12:53:42 <byorgey> there are not two copies of 0.
12:53:46 <byorgey> one is 0 and one is [].
12:53:49 <dons> i think its more lik 120k or so, rwh.
12:53:51 <jethr0> lyah?
12:53:59 <dons> BONUS: that would be a big book i think
12:54:01 <BONUS> @where lyah
12:54:01 <lambdabot> www.learnyouahaskell.com
12:54:08 <jethr0> cool
12:54:08 <BONUS> dons yeah that's what i'm worried about
12:54:13 <dons> how much do you have?
12:54:22 <BONUS> so far 80k words, not counting code blocks
12:54:27 <dons> big!
12:54:32 <BONUS> yikes!
12:54:41 <dons> you might want to get it into a final .pdf template soon,  so you know for real how many pages
12:54:56 <BONUS> yeah
12:55:10 <byorgey> jethr0: 450 words per page is a LOT
12:55:13 <alexsuraci> merge every third word together, problem solved
12:55:17 <byorgey> most books are much smaller than that, I think.
12:55:41 <BONUS> the pdf of the stuff so far has about 200 pages but no pictures
12:55:46 <jethr0> byorgey: i did an extremely quick lookup on google and that's what the first page i looked at said ;)
12:55:52 <BONUS> so yeah i think i might get away with around 400 pages
12:55:59 <byorgey> jethr0: heh, ok =)
12:57:21 <dons> BONUS: i think you'll be surprised how big it already is , once typeset
12:57:21 <edwardk> bonus: so it'll wind up fairly meaty
12:57:43 <dons> hooray for BONUS !! hooray for new haskell books!
12:57:49 <BONUS> haha :D
12:58:09 <BONUS> my biggest fear is that it will be too big and expensive to print. but the guys at the publishing house seem really cool so i'm sure we'll figure something out
12:58:10 <edwardk> bonus: for some reason i kept visualizing it as being about as thick as 'the haskell school of expression' but it sounds like you're well past that
12:58:31 <dons> will learnyouahaskell have a blog soon, to talk about the book?
12:58:31 <BONUS> text on the net is deceptive, yeah
12:58:37 <dons> with a pre-order button ?
12:58:43 <BONUS> dons yeah that's a good idea!
12:58:51 <BONUS> gonna think about setting that up
12:58:56 <edwardk> dons: woooh, and per-paragraph comments... ;)
12:58:56 <Nafai> BONUS: I'll be in line to order!
12:58:57 <jethr0> personally i found to be a bit on the expensive side. but definitely worth it...
12:59:06 <edwardk> bonus: i'll buy a copy
12:59:11 <BONUS> awesome :)
12:59:12 <dons> get ready to take over the internet if you announce :)
12:59:29 <BONUS> haha, yeah not ready to announce yet, still in talks with the publishers
12:59:31 <dons> there's a good market for haskell books :) we need more! so many topics to write about
12:59:34 <wunki> learn you a haskell is great! :)
12:59:39 <wunki> thank you for it
12:59:42 <bavardage> I think I may buy learn you a haskell :D
12:59:46 <BONUS> haha
13:00:06 <BONUS> i've seen that a lot of people find rwh and lyah complementary, which i find kind of cool
13:00:14 <tromp> i'll buy one too
13:00:15 <dons> BONUS: yes, i've heard that too
13:00:16 <Nafai> I agree
13:00:25 <dons> practice and foundations, together.
13:00:25 <BONUS> lyah holds your hand through the language, while rwh actually teaches you useful stuff to do with it
13:00:45 <tromp> gonna keep the name?
13:00:52 <dons> i'd have to , no?
13:00:52 * edwardk just needs to write 'bore you a haskeller with category theory for great justice' or something and the trifecta will be complete ;)
13:00:57 <dons> being an internet sensation and all that.
13:01:00 <BONUS> probably yeah
13:01:05 <BONUS> hahah
13:01:06 <dons> edwardk: excellent!
13:01:14 <dons> haskell: the hard bits
13:01:16 <BONUS> edwardk: i would so buy that ten times
13:01:32 <demolithion> i'd rather have a haskell for dummies
13:01:43 <bavardage> shame rwh doesn't have free pdfs
13:02:09 <Peaker> dons: my friend really loved chapters 1-5 of rwh, but said chapter 6 about type-classes was very difficult to understand (he's a very smart guy)
13:02:28 <dons> interesting! people always seem to pick _different_ chapters as the hard ones.
13:02:28 <Peaker> dons: do you guys keep track of new comments on the online version?
13:02:37 <dons> i think people are still adding comments
13:02:43 <dons> we'll go over them all again soon i hope.
13:02:48 <conal> i loved "the little lisper", which was my first exposure to functional programming.  maybe something similar for haskell.
13:02:53 <edwardk> bonus: i keep revisiting how to tackle enough category theory to make it useful without completely losing people with pacing
13:03:15 <dons> edwardk and sigfpe could write a joint epic work.
13:03:21 <BONUS> yeah definitely
13:03:25 <dons> edwardk providing the practice, sigfpe the theory :)
13:03:42 <edwardk> dons: i tried to interest him back at MSFP 08 actually, but he sounded a little too buried.
13:03:43 <dons> sigfpe could publish his blog, as is.
13:03:57 <dons> just need to put it into a single site like lyah
13:04:11 <dons> learn you a zygohistoprepomorphism!
13:04:15 <BONUS> haha
13:04:34 <Peaker> dons: he said you're using Either and Right in the examples there before introducing Either (but I'm just quoting here) :)
13:04:34 <edwardk> dons: prepro ;)
13:05:02 <BONUS> sometimes stuff like that is unavoidable
13:05:34 <edwardk> peaker: is that the blog post that found its way onto reddit about if RWH deserved the praise it was getting?
13:06:32 <Peaker> edwardk: nope -- just my roommate. He really liked the book - I think he got mad at chapter 6 :)
13:07:31 <edwardk> peaker: my wife got confused somewhere around there as well
13:12:48 <Peaker> hmm.. I think I'll go for the synchronous blocking model (flow-control-based state machine). I think it makes parallel execution's operational semantics clearer
13:13:24 <bavardage> gaah
13:13:28 <bavardage> gtk2hs won't install
13:13:54 <edwardk> peaker: and if you want to revert, you can just cps transform it and hold onto the continuation as state
13:14:38 <Peaker> edwardk: yeah, cool idea :)
13:14:57 <bavardage> http://paste.pocoo.org/show/114094/ any ideas anyone?
13:15:02 <edwardk> gotta run
13:17:24 <Peaker> bavardage: what ghc are you using?
13:17:29 <bavardage> Peaker: latest
13:17:41 <bavardage> well, 6.10.2
13:17:46 <Peaker> bavardage: its complaining you don't have base-4.0.0.0
13:17:58 <bavardage> which is/which means?
13:18:08 <Peaker> bavardage: you can use: ghc-pkg list base
13:18:12 <bavardage> if gtk2hs wasn't compiled with latest ghc, will this matter?
13:18:14 <Peaker> bavardage: to show what "base" package version you have installed
13:18:25 <bavardage> /usr/lib/ghc-6.10.2/./package.conf: base-3.0.3.1, base-4.1.0.0
13:18:27 <Peaker> bavardage: I think 6.10.2 may have upgraded base from 4.0.0.0 to 4.1.0.0
13:18:30 <bavardage> yop
13:18:38 <Peaker> bavardage: you can try to edit the gtk.cabal file in the package
13:18:41 <bavardage> so I need to recompile or something?
13:18:44 <bavardage> kk
13:18:49 <bavardage> pfft
13:18:54 <bavardage> I'll get investigating
13:19:02 <Peaker> bavardage: see where it says: base==4.0.0.0 and replace it with 4.1.0.0 or base >= 4 or such
13:19:07 <bavardage> kk :d
13:19:14 <Peaker> bavardage: but maybe they knew what they were doing when restricting base version to be 4.0.0.0 and nothing else
13:19:20 <bavardage> hmm
13:19:22 <bavardage> perhaps
13:19:33 <bavardage> would be lame if gtk2hs doesn't work with latest ghc
13:19:33 <laz0r> anyone has a suggestion how i can call a c function that expects a pointer to another c function as argument, and a function pointer that is a callback into my haskell code?
13:19:35 <bavardage> I would cry
13:19:35 <Peaker> bavardage: did you get rid of your old compiler with which you compiled gtk2hs?
13:19:46 <bavardage> Peaker: I upgraded ghc
13:19:51 <bavardage> I didn't personally compile gtk2hs
13:19:54 <bavardage> it was a distro package
13:19:54 <Peaker> bavardage: did you get rid of the old ghc?
13:19:58 <bavardage> indeed
13:20:07 <bavardage> my distro just pushed the new ghc into repos
13:20:07 <Peaker> bavardage: ah, gtk2hs depends on the old one you removed
13:20:21 <bavardage> I'll attempt a recompile myself
13:20:25 <laz0r> i already solved the problem by writing a little helper library, that just exposes a function that takes only my haskell callback as argument, and supplies the c function pointer itself
13:20:31 <Athas> Has any work been done on improving Haskell's module system in the future/an extension?
13:21:15 <fynn> hey. I've asked this yesterday, but wanted to get more opinions:
13:21:18 <laz0r> but it would be nice if it did work without such a helper lib
13:21:25 <fynn> how's Haskell for scientific computing?
13:21:57 <burp_> best you can get
13:22:09 <bavardage> hmm this isn't a cabal package
13:22:19 <bavardage> Peaker: I can't find it mention base anywhere
13:22:35 <fynn> burp_: I'm not so sure; scipy has some pretty neat features.
13:22:42 <bavardage> oh, I guess these are the files within the gtk2hs tarball or something
13:22:51 <bavardage> GAH
13:23:16 <burp_> fynn, true, but it's not written in haskell ;)
13:23:17 <Peaker> conal: it appears that Stream depends on QuickCheck>=2.0 and reactive/checkers (who depend on Stream) depend on QuickCheck<2 - so it seems that you can't compile reactive with ghc-6.10.2 atm (at least not simply, with cabal install)
13:23:53 <beelsebob> > 29.6 * 12.2 + 0.2
13:23:58 <lambdabot>       Ambiguous occurrence `*'
13:23:58 <lambdabot>      It could refer to either `Prelude.*', imp...
13:24:05 <beelsebob> o.O
13:24:13 <burp_> @undefine (*)
13:24:16 <burp_> > 29.6 * 12.2 + 0.2
13:24:18 <lambdabot>   361.32
13:24:22 <conal> Peaker: glad to know.  i'll grab 6.10.2 soon and get it sorted out.
13:24:26 <beelsebob> ah, I was wondering
13:24:30 <burp_> seems someone has overwritten multiplication :p
13:24:35 <conal> Peaker: when i'm in civilization (fast internet)
13:24:48 <beelsebob> conal: from my testing, unamb appears to work flawlessly on 6.10.2 now :)
13:25:02 <conal> beelsebob: terrific. :)
13:25:10 <burp_> fynn, but python is fine too, though not functional :>
13:25:57 <beelsebob> conal: did you see peter had an interesting idea of using vacuum's reflection technique to discover if one or other argument was already in WHNF?
13:26:07 <earthy> 5
13:26:08 <Peaker> beelsebob: cool!
13:26:17 <bremner> I wonder if python with a single assignment store would work at all.
13:26:30 <conal> beelsebob: no, i missed it.
13:26:42 <conal> beelsebob: isn't there a isWHNF somewhere?
13:26:53 <beelsebob> conal: not that I know of
13:26:56 <dons> ?hoogle isWHNF
13:26:57 <lambdabot> No results found
13:27:02 <dons> i'm sure Andy Gill implemented it once.
13:27:08 <dons> he loves that kind of thing :)
13:27:25 <conal> beelsebob: it'd be great to optimize unamb for already-whnf
13:28:18 <bos> fynn: ah :-)
13:28:37 <burp_> @karma-all
13:28:37 <lambdabot>  "moritz"              558
13:28:37 <lambdabot>  "pmichaud"            388
13:28:37 <lambdabot>  "lwall"               306
13:28:37 <lambdabot>  "pmurias"             254
13:28:37 <lambdabot>  "jnthn"               232
13:28:39 <lambdabot> [1182 @more lines]
13:29:07 <BONUS> i have a feeling that in 6.10.1 you could do data family Foo :: * -> * but in 6.10.2 you have to do data family Foo a :: *, i.e. provide one explicit parameter
13:29:11 <Gracenotes> who :o
13:29:27 <dons>  #perl6
13:29:38 <BONUS> i would have to go get my laptop to test this, can anyone confirm/deny off the top of their heads?
13:29:38 <Gracenotes> ah. lwall
13:29:51 <Gracenotes> last seen... 4 years ago
13:30:07 <Peaker> conal: ok, replacing "Stream" with "Stream < 0.3.1" in the reactive .cabal file seems to be a working workaround
13:30:19 <thoughtpolice> dons: have you read any/got a copy of harrison's new logic book?
13:30:22 <conal> Peaker: nice :)
13:30:35 <thoughtpolice> dons: i was thinking of buying it, it's just so new i'm not sure I want to invest the $120 for it
13:33:23 <thoughtpolice> oo, speaking of that! conal: i'm getting segfaults with fieldtrip and reactive is a major pain to currently install. :(
13:34:36 <conal> thoughtpolice: segfaults on which os?  and what kind of install pains?
13:35:17 <thoughtpolice> conal: mac OS X. afaics I also get them on linux. the main problem with installation is the fact a) reactive has not really been updated, coupled with b) all the libraries it depends on have been upgraded
13:36:22 <thoughtpolice> conal: for example, reactive uses quickcheck < 2.0. the latest stream library (0.3.1) uses 2.0 <=, so when you try to cabal install, cabal immediately dies with an 'unresolvable dependency error'
13:36:28 <thoughtpolice> the solutio is to just install Stream 0.3.0
13:36:36 <thoughtpolice> also, vector-space has been upgraded numerous times
13:36:41 <thoughtpolice> but reactive hasn't been updated with it
13:36:58 <thoughtpolice> e.g. reactive 0.10.5 currently depends on vector-space-0.5.1 - but the latest is like 0.5.9!
13:37:28 <conal> thoughtpolice: thx.
13:37:46 <conal> (jotted down)
13:37:52 <thoughtpolice> welcome. :)
13:38:15 <Peaker> thoughtpolice: I just described that and a workaround
13:38:33 <thoughtpolice> conal: why has reactive development slowed so much? i remember it was an RTS issue - has it been fixed?
13:38:49 <Peaker> thoughtpolice: beelsebob just said unamb seems to work flawlessly so it sounds like a yes :)
13:39:21 <beelsebob> Peaker: yeh, oddly though, e = integral (atTimes [0..]) e does not seem to work atm
13:39:28 <beelsebob> I remember managing to get that to work
13:39:56 <beelsebob> :(
13:40:01 <Peaker> beelsebob: recursive behaviors, you mean?
13:40:27 <deech> Hi there, is there a list function that generates subsequences of a list sorted by list length from min -> max? For subsequences [1,2,3] =>[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]], but what I want is [[],[1],[2],[3],[1,2],[1,3],[2,3],[1,2,3]]. example,
13:40:28 <beelsebob> well no, I know I hadn't got recursive behaviors in general working, but I'd thought that was to do with the runtime bug
13:40:32 <beelsebob> but I know I'd got that simple one working
13:40:37 <beelsebob> and a few more complex one
13:40:39 <beelsebob> ones*
13:40:44 <beelsebob> but none seem to work any more :(
13:41:23 <deech> Also I need to read that list lazily.
13:41:49 <Gracenotes> deech: so you want all lists of length 0, then 1, then 2, etc.
13:42:01 <Gracenotes> by the time you finish length 1, the entire list will be read.
13:42:03 <deech> Gracenotes: yes,
13:42:28 <conal> thoughtpolice: a few reasons for reactive development slow-down: external support ended unexpectedly; i took time to mull over licensing issues that would help support me post-market-plunge (still unresolved); debugging burn-out; icfp paper writing; enthusiasm over new functional->gpu project.
13:43:18 <monadic_kid> oh, interesting
13:43:20 <Gracenotes> deech: you could write such a function
13:43:33 * Cale notices that it seems most of the time spent in the ubuntu upgrade process is spent running updmap-sys every time some TeX thing installs.
13:43:43 <monadic_kid> i was just wondering whats been the status of reactive and FRP
13:43:46 <deech> Gracenotes : So basically I want to be able to do a 'take 4 $ magicSubsequenceFunction [1,2,3]' and have it [[],[1],[2],[3]] without evaluating all the combinations.return
13:44:18 <Cale> > take 4 . filterM (const [False, True]) $ [1,2,3]
13:44:19 <lambdabot>   [[],[3],[2],[2,3]]
13:44:25 <Cale> ah, wrong order :)
13:44:58 <deech> Cale : I don't follow your thought process
13:45:09 <Cale> deech: Well, it is lazy regardless.
13:45:20 <jethr0> Cale is reciting haskell canon ;)
13:45:21 <deech> What does filterM (const [False,True]) do?
13:45:22 <Cale> deech: But it's not in the order you want.
13:45:27 <Gracenotes> I'm not sure there's a simple algorithmic way to do it. If you want, just "sortBy (comparing length)"
13:45:32 <Cale> > filterM (const [False, True]) $ [1,2,3]
13:45:34 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
13:45:39 <Cale> > filterM (const [True, False]) $ [1,2,3]
13:45:40 <Gracenotes> which, granted, does read the entire list
13:45:40 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
13:45:45 <Cale> subsequences
13:45:54 <Cale> (or sublists)
13:46:05 <deech> > :t filterM
13:46:06 <lambdabot>   <no location info>: parse error on input `:'
13:46:07 <harovali1> powerset
13:46:20 <Cale> :t filterM
13:46:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:46:30 <harovali1> deech: is a monadic feature of lists
13:46:30 <Cale> It's in the list monad that we're using it
13:46:40 <Gracenotes> if you have an algorithm in mind, implement it as you want it to behave -- unfortunately, I don't think by-length would be very efficient, possibly requiring you to traverse the list several times
13:46:54 <Cale> It says "for each element of the list, regardless of its value, either keep it or drop it."
13:46:58 <Gracenotes> it's possible I just might not be feeling creative today
13:47:28 <Gracenotes> but subsequences as it is is nice and lazy
13:47:33 <Cale> So, yeah, I suppose if you want to get them in order of size, that's trickier
13:47:36 <Gracenotes> it's not an arbitrary order :)
13:48:36 <Cale> I would first write the function which gets all the sublists with exactly k elements.
13:48:43 <deech> Cale, Gracenotes : I'll have to look at this some more. That filterM thing kind of blew up my mind. Thanks for your help!
13:49:10 <Gracenotes> sure. good luck :)
13:49:15 <Peaker> deech: you could use: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4202#a4202
13:49:33 <Gracenotes> also, if you don't want the whole list, maybe you could just do less.
13:49:53 <Peaker> deech: time-complexity-wise, it might not be good, but it might be better memory-wise, not having to keep around a big list for sorting
13:52:34 <Zao> I wonder if the author of chalkboard lives on a big-endian machine.
13:52:42 <Zao> PPMs rendered with it are in BGR :)
13:53:26 <p_l> Zao: BGR was quite common in media, afaik
13:53:43 <Peaker> conal: someone raised a Reactive issue in the mailing list that Reactive supposedly makes efficient computation of exact collision-point between a ball and a wall impossible -- do you think this is a problem in Reactive's current interface?
13:54:22 <Zao> p_l: writePPM "bar.ppm" (boardToArray (200,200) 3 (pure red))  shouldn't yield a full-green image.
13:54:44 <p_l> true
13:54:58 <Zao> Unless the Gimp is broken on this box, but I doubt that.
13:55:05 <conal> Peaker: no i don't think so.  i vaguely remember seeing the comment and not understanding the reasoning behind it.
13:56:18 <conal> Peaker: did it make any sense to you?
13:56:50 <Peaker> conal: yeah, sorry for late reply.
13:59:31 <Zao> p_l: I'm really confused now. The PPM seems to have the bytes in the right order but both imagemagick and gimp shows (pure red) as green.
13:59:54 <p_l> Zao: I guess it's time to check on code and PPM spec? ;)
14:00:42 <Zao> Spec (well, man page and wikipedia) agrees about RGB being the proper order.
14:02:47 <Zao> Oh no. There's CRLF line endings in it.
14:02:51 * Zao facedesk
14:03:58 <monochrom> Nice hear to that you have empty space on desk to face on.
14:04:07 <Zao> I had to prepare a patch.
14:07:52 <davidL> the md5sum of a 200x200 red ppm6 should be about 32996c4cd50430317a9043217f2f58e9 ;)
14:08:12 <Zao> Now, time to find out how to stop writeFile from translating newlines.
14:12:03 <ukl> hello. I'm in trouble setting up xmonad on arch linux.... xmonad-contrib-darcs needs haskell-utf8-string which fails to install with something about failing registration...
14:12:24 <ukl> sorry about my hardly helpful description, but maybe someone ran into the same issue...
14:12:28 <Zao> There we go, withBinaryFile and magic :)
14:12:31 <Peaker> deech: did you see my solution?
14:12:45 <davidL> Zao: do you get the same checksum?
14:13:53 <Zao> davidL: No, but it's red alright :)
14:14:01 <davidL> hmm
14:14:20 <davidL> I'm working on a PPM and BMP library at the moment
14:15:34 <Zao> davidL: http://www.acc.umu.se/~zao/bar.ppm
14:17:04 <davidL> Zao: ah, it looks like it only differs by a newline
14:17:11 * codebliss loves haskell
14:17:45 <codebliss> Does anyone else love haskell?  Hm?  How long has it been since you've proclaimed your love for haskell?
14:18:04 <aeolist> you need to get out more
14:18:12 <codebliss> I just got back! XD
14:19:11 <codebliss> aeolist: Don't worry I'll be having some fun tonight =)
14:19:19 <aeolist> coding?
14:20:25 <codebliss> aeolist: Psh.  I coded the last couple days.  I'm just going to get some in now and maybe sunday night XD
14:23:12 <codebliss> So I just want to get a second opinion again.  A function with no appearance of side effects in the type signature, which actually does have side effects, is a bug and not considered to exist in practical code?
14:23:51 <pk> I have a project that needs Opengl and Glut. I know that those files that depends on Opengl and Glut won't change. Can I compile them on linux, then link on windows ?
14:23:53 <Peaker> codebliss: not just side effects, dependence on the state of the outside world too
14:24:04 <codebliss> Peaker: Thank you sir =)
14:24:34 <p_l> pk: only if you have a cross compiling environment for linux->windows :)
14:24:43 <pk> mingw ?
14:24:56 <p_l> might work
14:25:34 <adamvo> ukl: you can't use the haskell-utf8-string binary package from community: that one should be recompiled with the newest ghc
14:25:47 <pk> so I'll avoid the dreaded GLUT instalation ?
14:26:18 <p_l> pk: nope :)
14:26:27 <Zao> codebliss: Needs warningful documentation and a really cumbersome and boding name.
14:26:37 <adamvo> ukl: it might be better to take this into the lower traffic #arch-haskell or #xmonad channels if that isn't enough of a hint
14:26:51 <codebliss> Zao: That's alright.  I need to bring a point to my professor to whom I'm teaching fprogramming
14:26:54 <Zao> codebliss: I both love and hate Haskell.
14:27:05 <codebliss> Zao: Why?
14:27:28 <Peaker> codebliss: hmm.. I guess I may be mistaken -- lazy I/O actually violates that
14:27:30 <ukl> adamvo: I can't use the one from aur either, it just fails:  haskell-utf8-string not found in AUR
14:27:46 <Zao> I love it because it's awesome, I hate it because I'm not proficient in it yet and because it sinks my free time :)
14:27:49 <Peaker> codebliss: lazy I/O means that as you consume a pure list, it does actual I/O (side effects) to populate the continuation of that list
14:27:52 <ukl> adamvo: thanks, didn't know about this #arch-haskell channel. :)
14:27:54 <codebliss> Peaker: Within practical productive reasoning.  Most things have exceptions
14:28:21 <Peaker> codebliss: there are those that love lazy I/O and those that hate it. I hate it because its one of the very few things that do violate this side effect rule
14:29:10 <Gracenotes> :o
14:29:26 <gio123> I have an algorithm which does not compute what is supposed can I say this algorthm does not has soundness property?
14:29:55 <jethr0> maybe the algorithm or your implementation have an error...
14:29:59 <jethr0> s/have/contain/
14:30:00 <opqdonut> well it's an understatement but certainly :)
14:30:50 <gio123> jethr0: agorthm has a problem, I am interested whether I can use termin algorithm is not sound or soundness
14:31:27 <codebliss> Peaker: Reading about Lazy IO on realworldhaskell.  Seems powerful but kind of risky.  Thanks for the info
14:31:28 <jethr0> hmm, how about incorrect, error-laden, error-ridden? ^_^
14:32:03 <Peaker> codebliss: the side-effects lazy io does have are basically just reads, not writes -- so it restricts the domain. However, reading from the network/etc is definitely an observable side-effect
14:32:21 <codebliss> Peaker: Good point.  Thanks.
14:33:26 <Peaker> I wish lazy I/O in the stdlib was tagged as such somehow -- unsafeGetContents,  etc
14:33:44 <Gracenotes> oh, you all get off my lawn! In my day, the only way to do it was with lazy IO, and you either liked it or you encoded your input into the program! Why, we had to walk 20 miles to the computer lab with a backpack full of bricks just to run the program, uphill both ways! And we were glad if it didn't cause the machine to spontaneously catch fire!
14:33:59 <codebliss> Oh god not you again XD
14:34:11 <sjanssen> Peaker: it isn't unsafe in the same way the other things are unsafe
14:34:21 <opqdonut> gedaffamoylawn
14:34:23 <opqdonut> :)
14:34:30 <codebliss> Does Lazy IO violate the rules of haskell?
14:34:42 <Gracenotes> codebliss: that's what happens when you've been coding in Haskell for... uh... 4.5 months. :P
14:34:43 <sjanssen> codebliss: in my opinion, no
14:34:45 <codebliss> Like...does it still follow the rules like same input -> same output?
14:34:58 <codebliss> Gracenotes: Hehehe.  I'm on week 3 lol
14:35:04 <codebliss> Gracenotes: I can only imagine =P
14:35:07 <tromp> haskell has no rules on IO, only conventions:)
14:35:46 <codebliss> Well what I'm asking is if it's a hack.  I understand it's a bit controversial, but does it fit in the confines of haskell?
14:35:56 <Peaker> codebliss: I think its a hack
14:36:00 <Peaker> codebliss: others disagree :)
14:36:12 <codebliss> Peaker: You're tough to get info from XD
14:36:16 <sjanssen> codebliss: I would say it bends the rules, but does not break them
14:36:22 <codebliss> sjanssen: Thanks.
14:37:00 <Peaker> It doesn't break the rules in purely observable ways because to observe the breakage you'd have to go into IO -- and to get the breakage you had to get a value from IO in the first place
14:37:07 <ddarius> It makes Haskell not pure by Amr Sabry's definition, but I don't believe it violates referential transparency.
14:37:24 <codebliss> What would the world be without geeks <3
14:38:00 <lament> codebliss: awesome?
14:38:21 <BONUS> if you have an interleaved I/O action of type IO String, and you bind that to something, then it matters *when* you try to evaluate that string
14:38:37 <tromp> if you getcontents of an empty file, then append to that file, and then print contents, what do you get?
14:39:20 <codebliss> lament: Pshhh, we'd have no technology.  No fun!  I'd be like..something boring like a lawyer if not for comp sci lol
14:39:24 <BONUS> herein lies the can of pants, i still can't make up my mind as to what exactly my opinion on interleaved I/O is
14:39:49 <Peaker> I think lazy I/O is going the easy way instead of the right way
14:40:01 <Heffalump> I like lazy I/O
14:40:04 <Heffalump> we just need to tame it nicely
14:40:36 <sjanssen> Heffalump: how?
14:40:44 <BONUS> lazy I/O is like alcohol. good in small doses and if you can control it
14:40:46 <Heffalump> dunno :-)
14:42:15 <quicksilver> I think BONUS summarised it nicely.
14:42:15 <BONUS> for instance, with lazy I/O you might think yourself being able to write a truncated file while reading it before it was truncated
14:42:19 <quicksilver> interleaved IO is a can of pants.
14:42:20 <monochrom> Oh everything is good in small doses and under control. That's a tautology.
14:43:10 <BONUS> Dr. R. Lee Obvious
14:43:11 <monochrom> It's damn hard to get a small dose of lazy I/O and under control.
14:45:44 <quicksilver> the effort taming interleaved IO might be better spent devising elegant interfaces or combinators around iteratees.
14:45:48 <wli> I don't really notice or care about the issue.
14:46:14 <Heffalump> quicksilver: but iteratees break the concept of laziness providing a nice interface boundary
14:46:28 <quicksilver> eh?
14:47:02 <Heffalump> the idea that you can just send a lazy list across an interface and the client decides how much to use
14:47:12 <quicksilver> iteratees don't break that.
14:47:29 <quicksilver> you can send over a iterator which the client can decide how much to use.
14:48:12 <Heffalump> I meant implicitly
14:48:25 <Heffalump> it's just much uglier to have to do so explicitly
14:48:58 <Peaker> I think a lot of Haskell's greatness arose when a nice solution for difficult problems had to be devised.. working around those problems avoids finding great solutions. I think lazy I/O is one such workaround
14:49:15 <monochrom> I feel that iteratees preserves that nice boundary, too. But I'll think more about it.
14:49:52 <wli> I'd be fine without hGetContents or whatever.
14:50:10 <Peaker> where are Iteratees?
14:50:35 <Peaker> I wrote something that someone later told me was almost exactly the same as iteratees (which turns out really similar to the list monad transformer, too)
14:51:16 <quicksilver> in its simple form, it's just an inversion of control
14:51:29 <quicksilver> instead of providing a list of data, you provide a function which you call.
14:51:44 <quicksilver> and you pass to that function, a function of your own which processes "one chunk" of data.
14:52:18 <quicksilver> then the clever bits arise when you add the ability to rearrange chunks, stack filters, provide explicit support for early exit, etc.
14:52:36 <Peaker> and higher-order combinators that hide the inversion of control
14:52:46 <quicksilver> yes.
14:53:01 <quicksilver> which is what I was getting at when I said "devise elegant interfaces or combinators..."
14:53:07 <wli> I use getLine and/or readLn more often than getContents/hGetContents.
14:53:20 <quicksilver> hide the whole thing behind something like signals or streams
14:53:35 <quicksilver> (not specifically either of those, but *like* them in the sense of high level and composable)
14:53:41 <Heffalump> inversion of control, that's the key phrase I was looking for
14:53:46 <wli> What irks me more is the error handling with respect to IO.
15:00:10 <BONUS> hmm ... monoid attempt
15:00:26 <BONUS> mempty = repeat mempty, mplus = zipWith mplus
15:00:44 <BONUS> does this look like a monoid?
15:01:32 <Heffalump> yes
15:01:47 <BONUS> i wonder if it's useful or interesting
15:01:50 <BONUS> probably not
15:02:16 <conal> BONUS: s/mplus/mappend/ ?
15:02:23 <BONUS> yes of course
15:02:31 <BONUS> i always mix those two up
15:02:42 <conal> BONUS: it (nearly) fits a general pattern of mempty = pure mempty ; mappend = liftA2 mappend
15:02:46 <pumpkin_> that's cause they're basically th same thing :P
15:03:20 <BONUS> yeah only it's sort of a ziplist-like monoid
15:04:05 <Heffalump> conal: why only nearly?
15:04:23 <FunctorSalad> BONUS: looks like a sort of infinite direct sum of monoids
15:04:40 <BONUS> > liftA2 mappend ["hey","ho"] ["lets","go"]
15:04:41 <lambdabot>   ["heylets","heygo","holets","hogo"]
15:04:42 <FunctorSalad> (except that since the lists can be infinite it isn't actually a direct sum)
15:04:44 <conal> Heffalump: because [] /= ZipList
15:04:48 <eu-prleu-peupeu> i need help in designing a simple 3d rendering architecture, i know what i want, i just dont know how to map it to haskell the best way :/
15:04:49 <FunctorSalad> :)
15:04:49 <BONUS> this would do
15:04:54 <Heffalump> oh right
15:05:04 <BONUS> > zipWith mappend ["hey, "ho"] ["lets","go"]
15:05:05 <lambdabot>   <no location info>:
15:05:05 <lambdabot>      lexical error in string/character literal at chara...
15:05:05 <Heffalump> it's very different then IMO. Matter of perspective really :-)
15:05:07 <BONUS> FunctorSalad: yeah
15:05:32 <FunctorSalad> "computable direct product"?
15:05:40 <conal> eu-prleu-peupeu: do you want functional or imperative?  i.e., modeling or rendering?
15:06:10 <pumpkin_> there's a correspondence?
15:06:47 <conal> pumpkin_: in my head at least.
15:06:58 <pumpkin_> interesting, how?
15:07:16 <eu-prleu-peupeu> i want it to generate interactive images at a certain rate based on a user defined state :) i guess that fits "rendering" more than modeling
15:07:47 <eu-prleu-peupeu> the plan is it must not be general, but extensible
15:08:51 <FunctorSalad> well, if you don't mind it using all the CPU, you could just use a loop ;)
15:08:58 <conal> eu-prleu-peupeu: with that description, i think you could easily go either way, depending on whether you want to describe what images (or 3d models) are or how to display them.
15:09:25 <conal> eu-prleu-peupeu: e.g., ++ vs putStrLn
15:10:27 <wli> The thing that really gets me is that the error handling is all done via exceptions, which is pretty aggravating when it's actually part of the expected behavior like sockets disconnecting or tty's generating signals.
15:11:01 <eu-prleu-peupeu> i was planning on using a set of user defined renderparts, that would generate "commands" into machines that would produce the render
15:12:55 <eu-prleu-peupeu> i.e. a "planetRenderPart" would "register" a sphere mesh and a planet texture into a meshMachine and a textureMachine in the init phase.
15:13:16 <eu-prleu-peupeu> in the render phase it would generate a render command based on these handlers and on the changes to the assets that must be made...
15:14:52 <eu-prleu-peupeu> i can only see monoids, and monoids and monoids of monoids when i think of doing it in haskell :/
15:16:03 <eu-prleu-peupeu> the main idea is to be extensible, and, if possible, stateless
15:20:05 <eu-prleu-peupeu> the idea of using a command instead of opengl directly, is to be able to sort commands, preventing duplicate operations, and also separate and isolating the opengl "state machine" from all of the architecture
15:23:05 <wli> Also, the IO error types don't line up with what come back from the system.
15:27:35 <eu-prleu-peupe1> :/
15:28:09 <hatds> 8)
15:30:00 <Gracenotes> :O
15:30:57 <Gracenotes> Ã–
15:31:24 <Gracenotes> Öµ×¡
15:33:33 <sw17ch> Gracenotes, having fun? :)
15:34:25 <Gracenotes> á¹
15:35:14 <Orien> Hi peoples
15:35:23 <eu-prleu-peupeu> Â¨Â¨Â¨
15:37:53 <Orien> I've just started looking at Haskell
15:38:02 <eu-prleu-peupeu> Orien: welcome :)
15:38:10 <Orien> it's very interesting
15:38:32 <sw17ch> Orien, that it is
15:39:33 <Orien> I'm going through the tutorial at http://learnyouahaskell.com/
15:39:55 <jn> I understand that instances of Functor, Foldable, and Traversable will soon be derivable. Where can I find the complete list of GHC's derivable classes and what the requirements are?
15:43:46 <hatds> afaik the only derivable instances are in the haskell 98 report
15:44:51 <georgehorse> Eq, Ord, Enum, Bounded, Show, Read
15:44:58 <icheishvili> So after reading the RWH book for a little bit, I still feel like I don't know how to approach this problem at hand: I'm trying to parse a certain integer value out of a file if a line in that file beings with a certain string.  Can anyone give some help?
15:45:37 <Botje> okay
15:45:42 <Botje> so you have finding the line with that value
15:45:45 <icheishvili> My current "solution" of take, compare, and drop are very inelegant
15:45:46 <Botje> and parsing out the value
15:45:52 <Botje> which are you having trouble with?
15:46:13 <icheishvili> Well, for one, hardcoding the widths of everything is bad idea.
15:46:21 <Botje> can you put your current solution on a pastebin somewhere?
15:46:52 <icheishvili> I would like to be able to use a regexp to match the line and then another to get the value out--at least that's the way my imperative programming mind wants to do it.
15:47:02 <icheishvili> Botje: sure, thanks for helping :)
15:47:52 <icheishvili> Botje: http://pastebin.com/d6f6ff3b9
15:48:51 <Botje> icheishvili: you could use the words function to split your line up into a list of words
15:48:56 <BONUS> Orien: hello i hope you are enjoying it :)
15:48:57 <Botje> then check if the first is "Active:"
15:49:21 <Botje> also, returning "" seems very unhaskellish to me
15:49:32 <icheishvili> Botje: That's a good idea, I'll try that--I'm also having trouble grasping how I need to change the mainloop function if I want to return Nothing when I don't find anything useful
15:49:36 <Botje> why not use Maybe
15:49:46 <Botje> ah :)
15:49:50 <Botje> icheishvili: start with the words thing
15:49:59 <Botje> then you'll have clean code to think about
15:50:05 <icheishvili> Yeah, I tried that last night and it was definitely proving to me how much of a paradigm shift haskell is :)
15:50:14 <Orien> BONUS:  yes, thanks - it's quite different from the Java I have to write at work
15:51:49 <kadaver> hmm, 15LOC into 103000 LOC,ghc -exe to asm!? that is a bunch of ghc stuff to i presume :P
15:52:15 <Botje> kalven: yes, all of the ghc runtime plus every package you use
15:52:30 <Botje> or is that just the runtime, hmm
15:59:26 <kadaver> > foldl (flip (:)) [] [1..10]
15:59:27 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
15:59:31 <kadaver> > foldr (flip (:)) [] [1..10]
15:59:33 <lambdabot>       Occurs check: cannot construct the infinite type: b = [b]
15:59:33 <lambdabot>        Expect...
15:59:40 <kadaver> > foldr (:) [] [1..10]
15:59:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:59:52 <kadaver> how can I reverse with foldr?
16:00:05 <BONUS> use ++
16:00:13 <kadaver> foldr (\i acc -> i : acc) [] [1..10]
16:00:18 <kadaver> > foldr (\i acc -> i : acc) [] [1..10]
16:00:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:00:22 <Botje> icheishvili: so, figured it out?
16:00:30 <BONUS> > foldr (\x acc -> acc ++ [x]) [] [1..10]
16:00:31 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
16:00:35 <kadaver> > foldr (\i acc -> ) [] [1..10]
16:00:36 <lambdabot>   <no location info>: parse error on input `)'
16:00:42 <icheishvili> Botje: I'm still trying ;)
16:00:48 <kadaver> BONUS: isnt that O(n^2)?
16:00:55 <BONUS> yeah, it is
16:00:59 <BONUS> no one said it was efficient
16:01:04 <BONUS> that's why there's the foldr
16:01:05 <kadaver> no just asking
16:01:08 <BONUS> hey jfredett
16:01:32 <BONUS> anything involving ++ [x] is usually fishy
16:01:36 <kadaver> > foldr (++) [] [[1,2,3],[4..10]]
16:01:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
16:02:57 <monochrom> ++[x] is a direct translation of imperative linked-list building.
16:04:48 <wli> And how is one supposed to handle anything when catch returns the same type as the IO action it's catching the exceptions from?
16:05:21 <icheishvili> So I can slice the string up into words, but I can't figure out how to return 1 word without ghc complaining about what I'm doing
16:05:34 <BONUS> wli: i don't see a problem there
16:05:56 <BONUS> do_something `catch` (\e -> handle >> return blah)
16:06:16 <BONUS> the point in the catch is usually the side-effects it causes, not the result it yields
16:07:03 <ddarius> wli: Um, the overall expression has to have one particular type.  If you really want to have different types that's doable in terms of catch and is called try.
16:07:04 <ddarius> :t try
16:07:05 <lambdabot> Not in scope: `try'
16:07:11 <ddarius> :t Control.Exception.try
16:07:12 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
16:07:42 <wli> That might be more useful.
16:08:40 <ddarius> :t flip catch (return . Left) . fmap Right
16:08:41 <lambdabot> forall a. IO a -> IO (Either IOError a)
16:09:50 <ddarius> :t \m h -> try m >>= \x -> case x of Right a -> return a; Left e -> h e
16:09:51 <lambdabot> Not in scope: `try'
16:10:00 <ddarius> :t \m h -> Control.Exception.try m >>= \x -> case x of Right a -> return a; Left e -> h e
16:10:02 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
16:19:05 <icheishvili> Botje: So after an epic struggle, I got the first part, but it's still not very Haskellish in that it still returns the empty string when it doesn't match--http://pastebin.com/d574cbff0
16:19:44 <icheishvili> I'm going to try to use the Maybe monad...I'm unsure about how much success I'll have with it though
16:20:48 <EvilTerran> icheishvili, it's not even necessary to think of it as a Monad here
16:20:54 <EvilTerran> it's just a data structure
16:20:56 <EvilTerran> ?src Maybe
16:20:57 <lambdabot> data Maybe a = Nothing | Just a
16:21:18 <EvilTerran> "Nothing" for when there's no result, and "Just {something of type a}" when there is
16:21:41 <icheishvili> EvilTerran: yeah, I just happen to know that it *is* a monad--on the topics of its correct usage, or what monads are in general, I would not yet pretend to be the expert :)
16:21:57 <Botje> icheishvili: head . tail $ parts is just parts !! 1
16:22:13 <Botje> show (parts !! 1)
16:22:27 <Botje> as for the maybe issue:
16:22:33 <Botje> you can return Nothing instead of ""
16:22:40 <EvilTerran> icheishvili, as i said, the fact that Maybe is a monad is nothing but a distraction in this case
16:22:54 <icheishvili> EvilTerran: ok, I will think of it as a data type
16:22:57 <Botje> icheishvili: and there's only one logical place to put Just :)
16:23:03 <BONUS> you don't have to deal with that fact yeah, unless you find yourself constantly checking a value if it's Nothing on every step
16:23:16 <BONUS> only then might you find its monad property useful
16:23:22 <pumpkin_> the maybe datatype, the maybe functor, the maybe applicative, the maybe monad
16:24:07 <icheishvili> Yeah, thanks guys :)  I'll give it a shot here...
16:26:11 <Botje> icheishvili: you'll have to check if your function returned a Just or a Nothing in your mainloop
16:27:09 <BONUS> the other day i made a monad instance for Kleisli m a before it dawned on me that i had just rediscovered ReaderT
16:27:12 <BONUS> duh
16:27:17 <leimy_> Anyone here wworking the haskell platform stuff for mac?
16:27:20 <icheishvili> Botje: By the way, since google isn't good at handling queries for "!!", what does that function do?
16:27:33 <pumpkin_> icheishvili: hoogle!
16:27:37 <pumpkin_> :t (!!)
16:27:38 <lambdabot> forall a. [a] -> Int -> a
16:27:41 <BONUS> > "hello there" !! 2
16:27:42 <lambdabot>   'l'
16:27:42 <pumpkin_> > [1..10] !! 4
16:27:44 <lambdabot>   5
16:27:44 <BONUS> > "hello there" !! 0
16:27:46 <lambdabot>   'h'
16:27:57 <leimy_> I saw a complaint that the binary format was "woefully undoxumented"
16:28:02 <edwardk> bonus: =)
16:28:29 <leimy_> It is a xar archive
16:28:45 <pumpkin_> binary format?
16:28:48 <leimy_> On leopard anyway
16:28:51 <icheishvili> oh nice, that's useful, I'll have to remember that one
16:29:00 <leimy_> For packages
16:29:05 <edwardk> @seen mmorrow
16:29:05 <lambdabot> mmorrow is in #haskell-in-depth, #haskell-blah, #yi, #ghc and #haskell. I last heard mmorrow speak 6h 39m 38s ago.
16:29:38 <Botje> icheishvili: it takes the nth element of a list, counting from zero
16:30:10 <leimy_> If you have leopard and a shell type "man xar"
16:30:12 <f4hy> If I want a modular addition what is the best way to do so?
16:30:21 <icheishvili> Botje: Couldn't one argue that in certain cases, head . tail O(1) would be faster than !! (which seems to be O(N))?
16:30:24 <leimy_> I am one of the authors of xar
16:30:36 <Botje> icheishvili: nope :)
16:30:48 <Botje> @src (!!)
16:30:49 <lambdabot> xs     !! n | n < 0 = undefined
16:30:49 <lambdabot> []     !! _         = undefined
16:30:49 <lambdabot> (x:_)  !! 0         = x
16:30:49 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:30:49 <f4hy> Like ((`mod`26) . (+)) gives me an error, what am I missing
16:31:00 <leimy_> But i do not know who was having problems with iy! :-)
16:31:05 <Botje> it's implemented in exactly the same way, except it uses pattern matching
16:31:07 <leimy_> Er it
16:31:10 <edwardk> f4hy: import Data.Ring.ModularArithmetic? =)
16:31:18 <leimy_> Bad iphone keyboard
16:31:18 <Botje> @pl \x y -> x+y`mod`26 -- f4hy
16:31:19 <lambdabot> (. (`mod` 26)) . (+)
16:31:19 <icheishvili> Botje: ah, I see--so in that case it's the exact same speed--nice
16:31:31 <Botje> icheishvili: don't worry about speed :)
16:31:38 <Botje> let the GHC people do that for you
16:31:41 <edwardk> @pl \x y -> (x + y) `mod` 26
16:31:42 <lambdabot> flip flip 26 . (mod .) . (+)
16:31:53 <Botje> oops
16:32:00 <edwardk> f4hy: you passed the wrong number of args to the (+) basically
16:32:04 <icheishvili> Botje: Just curious :)
16:32:46 <f4hy> edwardk: thanks, that lambda looks good to me
16:33:04 <Botje> edwardk++ # passing out good lambdas :)
16:33:06 <f4hy> edwardk: not sure I fully understand what you mean aobut the wrong number of args though
16:33:27 <leimy_> What is @pl?
16:33:42 <edwardk> @pl \x -> (`mod` 26) . (+) x
16:33:42 <lambdabot> ((`mod` 26) .) . (+)
16:33:57 <edwardk> (.) only plumbs 'one argument through'
16:34:05 <edwardk> @type (.)
16:34:06 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:34:08 <leimy_> Does it make point free code?
16:34:09 <f4hy> ahh ok
16:34:12 <edwardk> leimy yeah
16:34:20 <edwardk> @type (.).(.)
16:34:21 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
16:34:52 <f4hy> I keep hearing abuot point free code, but do not get the use. Is there some real advantage, or is it just style
16:34:52 <kadaver> what is better: mov Acc,eax; or push eax; pop Acc; ?
16:34:54 <edwardk> @type ((.).(.)) (`mod` 26) (+)
16:34:55 <lambdabot> forall a. (Integral a) => a -> a -> a
16:35:05 <BONUS> f4hy: easier to read sometimes
16:35:17 <leimy_> I forget the benefit of point free
16:35:20 <Peaker> f4hy: allows avoiding names for stuff too little to bother naming :)
16:35:29 <Peaker> I think point-free can be a gateway drug towards more genericity too
16:35:32 <edwardk> f4hy: it has uses, in particular when you start playing around with lots of category theory its sometimes easier to see the dual operation when its expressed point free
16:35:55 <edwardk> f4hy: usually i only use point free style to elide the last argument or two off of a function if its just being plumbed through
16:35:57 <kadaver> and I think when you pass a function to another function you cant use $ ?
16:36:00 <leimy_> Makes sense
16:36:12 <f4hy> Well I got three answers of increasing complexity. But I will go with BONUS's responce ;-)
16:36:21 <BONUS> \m -> f (g (h x y (j m))) vs. f . g . h x y . j $ m
16:36:27 <Cale> > (map $ (*2)) [1,2,3]
16:36:29 <lambdabot>   [2,4,6]
16:36:37 <BONUS> or uh
16:36:43 <Cale> ;)
16:36:45 <edwardk> BONUS nay even better f . g . h x y
16:36:50 <edwardk> er . j
16:37:05 <BONUS> yeah uh the $m shouldnt be there whoopsie
16:37:16 <edwardk> f4hy: at this point in time i'll admit i'm just golfing it a bit for myself ;)
16:37:34 <leimy_> :t f . g . h x y
16:37:36 <lambdabot>     Ambiguous type variable `c' in the constraints:
16:37:36 <lambdabot>       `SimpleReflect.FromExpr c'
16:37:36 <lambdabot>         arising from a use of `g' at <interactive>:1:4
16:37:47 <leimy_> Hmm
16:37:49 <f4hy> edwardk: sounds good.
16:37:53 <BONUS> > map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]
16:37:54 <lambdabot>   [-14,-15,-27]
16:38:00 <BONUS> > map (negate . sum . tail) [[1..5],[3..6],[1..7]]
16:38:01 <lambdabot>   [-14,-15,-27]
16:38:08 <Peaker> ah - there're also some advantages to using:   f . g . h . i $ x   over f (g (h (i x)))) or f $ g $ h $ i $ x.  A) You can get rid of the x.  B) No paren counting.  C) You can easily "cut & paste" parts of this "pipeline" into a function
16:38:23 <edwardk> @type (fmap fmap fmap) (`mod` 26) (+)
16:38:24 <lambdabot> forall a. (Integral a) => a -> a -> a
16:38:30 <f4hy> Golfing is fun, but the haskell community seems to put a much higher weight on it than any other lanaguage
16:38:32 <edwardk> woot
16:38:37 <EvilTerran> fmap fmap fmap!
16:38:38 <f4hy> fmap?
16:38:41 <edwardk> @type fmap fmap fmap (`mod` 26) (+)
16:38:42 <lambdabot> forall a. (Integral a) => a -> a -> a
16:38:44 <BONUS> f4hy: except maybe perl
16:39:01 <edwardk> @type fmap
16:39:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:39:09 <EvilTerran> ?src Functor
16:39:09 <lambdabot> class  Functor f  where
16:39:09 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:39:11 <BONUS> > fmap fmap fmap (*3) [[1,2,3],[3,4,5]]
16:39:12 <lambdabot>   mueval: Prelude.read: no parse
16:39:18 <georgehorse> f4hy: I think it's partly because golfing in haskell can actually lead to better code
16:39:27 <f4hy> BONUS: I do not know a single line of perl so I guess I dont have a good reference
16:39:32 <BONUS> what's wrong with lambdabot these days
16:39:37 <edwardk> f in this case is being chose to be (->)c in most of those, its a pretty scary solution, but comes from the fact that (.) can usually be replaced with fmap
16:39:42 <Peaker> fmap fmap fmap  is just (result.result)  -- meaning:  Take the next arg and use it to edit the result of a result of a function
16:39:45 <leimy_> What is * -> * again.  A kind?
16:39:49 <pumpkin_> yup
16:39:52 <BONUS> f4hy: basically perl looks like )#(#$$my#$:=)#)f3faasf
16:40:01 <Botje> BONUS: not really :(
16:40:03 <edwardk> > fmap fmap fmap (`mod` 26) (+) 23 4
16:40:05 <lambdabot>   1
16:40:05 <leimy_> So an "arrow"
16:40:06 <EvilTerran> BONUS, nah, far too many letters in there
16:40:07 <pumpkin_> leimy_: it's saying that the type constructor takes a type and returns a type
16:40:08 <leimy_> ?
16:40:18 <f4hy> BONUS: Well thats obvious what that code does. So I see their point
16:40:19 <BONUS> Botje: yeah i know i'm being a bit cheky hehehe >:)
16:40:23 <pumpkin_> leimy_: not an arrow in the Control.Arrow sense
16:40:49 <leimy_> But in the category theory sense right?
16:40:49 <Botje> and perlmongers invented the whole golf thing :p
16:40:57 <Peaker> what golf thing?
16:41:02 <Botje> code golf!
16:41:21 <BONUS> i just realized why they call it code golf
16:41:26 <pumpkin_> leimy_: I think that'd be true, but my CT is severely lacking :P
16:41:27 <leimy_> Gentlemen only ladies forbidden == golf
16:41:29 <f4hy> BONUS: really? haha
16:41:30 <BONUS> im such an idiot
16:41:32 <BONUS> haha
16:41:39 <Peaker> code golf?
16:41:47 <f4hy> BONUS: becuase of the sand traps...
16:41:51 <EvilTerran> "fewer (key)strokes is better"
16:42:09 <BONUS> f4hy: or maybe because you look like a wanker while doing it
16:42:14 <edwardk> leimy: in one very restricted sense. a type of kind * -> * is a type that takes a type and returns a type, so in that sense you could view it as a functor on the category of types, but its not a haskell 'Functor', and we like arrows in the category of types to be functions
16:42:43 <edwardk> bonus: fewest # of strokes =)
16:42:45 <f4hy> BONUS: That was the original definition, for sure.
16:42:50 <BONUS> haha
16:42:59 <Peaker> EvilTerran: with modern editors, its tough to tell how many keystrokes stuff took
16:43:09 <icheishvili> sigh...I messed up my indentation at some point and I have no idea how to fix it
16:43:14 <edwardk> peaker: yeah agda should have a pretty bad handicap
16:43:20 <leimy__> pumpkin_: I think that's right it maps objects of domain A to codomain B
16:43:22 <Botje> icheishvili: how so?
16:43:23 <mc__> I dont get where I'm leaking memory here http://haskell.pastebin.com/m6d6a7ad5 but it has have to do something with "maximum" cause without maxium I dont have the problems
16:43:47 <icheishvili> Botje: GHC complains about a parse error after I introduced the check (isJust)
16:43:52 <EvilTerran> Peaker, well, that's just the analogy; the Prelude.length is what counts
16:44:12 <Peaker> EvilTerran: surely token length is more interesting
16:44:26 <Peaker> aReallyLongNameIsJustOneThing
16:45:01 <edwardk> peaker: thats why folks tend to compare gzipped source file lengths instead
16:45:06 <EvilTerran> eh. i didn't invent the sport, that's just how people seem to compete
16:45:13 <edwardk> peaker: then idiomatic language use affects you less
16:45:26 <Botje> icheishvili: make sure it's on the same level as the other code
16:45:27 <edwardk> not for golf, but for things like the shootout, etc.
16:45:40 <Botje> and make sure your editor didn't sneak a tab in there :)
16:47:12 <Peaker> edwardk: but gzip doesn't compare token count any better, at least for tokens you use once
16:47:30 <Peaker> it lets you define long names a little more cheaply, but not use library ones
16:47:42 <edwardk> peaker: sure, but it tends to help relax how bad things are like different indentation styles between languages, etc
16:48:05 <edwardk> peaker: its a passable approximation of kolmogorov complexity
16:48:15 <icheishvili> Botje: yeah, I think emacs' Haskell mode might be a little overrated, I'm going to try by hand in a different editor
16:48:50 <Peaker> emacs haskell mode is annoying indeed
16:49:06 <mc__> why? I tried it once and liked it
16:49:23 <f4hy> It is. emacs haskell mode is far from perfect
16:49:31 <f4hy> It works, but still has some bugs
16:49:40 <EvilTerran> mc__, surely you preferred some other method, if you only tried it once
16:50:11 <mc__> EvilTerran: nah, I'm just to lazy to set it up again, now I'm using the haskell textmate plugin which is kinda crappy
16:50:18 <Botje> mc__: re your problem: you need to define either compare or (<=)
16:50:20 <Botje> you defined (<)
16:50:23 <mightybyte> @pl app f g a = f <$> g a
16:50:24 <lambdabot> app = (.) . (<$>)
16:51:07 <edwardk> heh thats another fmap fmap fmap
16:51:36 <mc__> Botje: I see, but why does that result in a memory leak?
16:51:37 <edwardk> @type \f g a -> f <$> g a
16:51:38 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (a -> b) -> (t -> f a) -> t -> f b
16:51:48 <edwardk> @type fmap fmap fmap
16:51:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:51:52 <Botje> mc__: if you look at the definition of Orc, as in http://www.zvon.org/other/haskell/Outputprelude/Ord_c.html
16:52:03 <Botje> you'll see that all operations are defined in terms of eachother
16:52:43 <georgehorse> So you need to define at least enough to determine all of the others.
16:53:00 <Botje> if you only define <, max x y will call >=, which calls compare, which calls <=, which calls compare, etc
16:53:27 <Botje> so your program gets stuck in an infinite loop and terminates very early ;)
16:53:58 <mc__> i see, thank you :)
16:54:12 <Botje> it's one of those things you have to know :)
16:54:37 <Botje> of course for your needs you could've just reimplemented max >:)
16:55:26 <mc__> well, but defining a type is "more beautiful" isn't it?
16:55:46 <Botje> yup
16:57:06 <Botje> although i'd use Collatz a b then
16:57:13 <Botje> instead of Collatz (a,b)
16:57:31 <Botje> oh, but it's a newtype
16:57:32 <Botje> nevermind :]
16:59:16 <mc__> mkay
17:01:16 <ksf> am I right that polyparse is what I want if I want to force partial results before parsing the whole input?
17:01:23 <georgehorse> someone said emacs haskell-mode isn't perfect; are there viable other options for editing?
17:01:30 <ksf> if so, why did I use parsec, all the time?
17:01:38 <ksf> vim.
17:01:40 <ksf> yi.
17:01:42 <ksf> leksah.
17:02:41 <monochrom> I find emacs haskell-mode perfect.
17:02:43 <tessier_> georgehorse: isn't perfect? What is?
17:03:00 <monochrom> Please tell your someone that "someone said it's perfect".
17:03:17 <georgehorse> tessier_: not looking for perfect, but better.
17:03:27 <georgehorse> ksf: thanks, I'll take a look at yi and leksah.
17:03:34 <tessier_> georgehorse: You can always fix/improve it.
17:03:36 <tessier_> It's just elisp.
17:03:44 <tessier_> What doesn't it do that you want?
17:04:03 <tessier_> And if you don't know what about it is imperfect why would you care?
17:04:07 <monochrom> Yes polyparse has a module for partial parsing. Pretty neat.
17:05:55 <tessier_> polyparse practices partial parsing perfectly proficiently
17:05:57 <icheishvili> I can't figure out why this would be a parse error: http://pastebin.com/d4e1fad71
17:06:05 <dolio> I don't know, I prefer the alternate indenting mode written by kuribas.
17:06:09 <dolio> And that isn't perfect, either.
17:07:05 <ksf> but.... but... polyparse doesn't support any stream type except lists.
17:07:21 <FunctorSalad> wait, parsec isn't lazy? in the sense that "many anyChar" starts returning stuff before the whole stream is read in?
17:07:31 <monochrom> Until we take the human out of the loop, there is no perfect indenter for Haskell.
17:07:32 <dolio> Also, emacs doesn't color type families/instances correctly.
17:07:55 <adamvo> icheishvili: haskell requires that you also specify the 'else' branch with 'if'
17:08:01 <ksf> FunctorSalad, yes, like in "there could be an error afterwards, so I can't decide on Right, right now".
17:08:05 <icheishvili> adamvo: ah, what would I put in it though?
17:08:16 <FunctorSalad> ksf: oh, right
17:08:21 <pumpkin_> icheishvili: the when function might help
17:08:21 <icheishvili> just leave it empty?
17:08:25 <monochrom> ekse return()
17:08:25 <pumpkin_> :t when
17:08:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
17:08:28 <f4hy> The only trouble I have had with emacs was indenting the module declaration at the top. And since it indented that wrong it wouldnt intdent the rest of it correctly. But that is the only problem I have had
17:08:58 <QtPlaty[HireMe]> f4hy: What do you mean wrong?
17:09:00 <heatsink> monochrom: Probably impossible since there are multiple syntactically valid ways of indenting code
17:09:19 <monochrom> Precisely. Human minds are unguessible.
17:09:21 <ksf> hmmm... I think I can hack around that list-thing quite easily. Is polyparse decently fast?
17:09:41 <zoheb> @pl \x -> map (x+)
17:09:42 <lambdabot> map . (+)
17:10:08 <heatsink> Speaking of which, what bugs me most about emacs is that sometimes an empty line causes the indenter to forget about the current nesting scope.
17:10:10 <pumpkin_> @pl \x -> map (+x)
17:10:10 <lambdabot> map . (+)
17:10:11 <QtPlaty[HireMe]> monochrom: True, but there are things that are unlikely.
17:10:12 <pumpkin_> tsk tsk
17:10:30 <heatsink> *about haskell indent in emacs
17:10:41 <f4hy> QtPlaty[HireMe]: It would try to indent the functions declared that were in the module, when they should be not indented at all. And it wasnt like it would cycle through, the only indent emacs said was valid was indented. I was in here before asking about it and someone contacted the author of haskell-mode
17:10:58 <icheishvili> ok, well at least that takes care of my parse error--GHC still doesn't like me passing Maybe String into putStrLn
17:11:16 * QtPlaty[HireMe] 's copy doesn't do that, perhaps its been fixed.
17:11:19 <pumpkin_> icheishvili: I wouldn't expect it to
17:11:46 <pumpkin_> icheishvili: what's your current version?
17:11:55 <monochrom> What new error do you get?
17:12:20 <icheishvili> I'm using ghc 6.10.1 (which is pretty recent I think)
17:12:30 <pumpkin_> icheishvili: I meant of your code :P
17:12:41 <pumpkin_> icheishvili: btw, in haskell people don't typically write f(x)... it's syntactically ok, but it's a lot more common to see f x
17:12:41 <icheishvili> Couldn't match expected type `String' against inferred type `Maybe String'
17:12:58 <pumpkin_> icheishvili: that if you have is probably best made into a case
17:13:08 <adamvo> :t concat . maybeTolist
17:13:09 <QtPlaty[HireMe]> pumpkin_: Or (f x)
17:13:09 <lambdabot> Not in scope: `maybeTolist'
17:13:11 <pumpkin_> case result of Just x -> putStrLn x; _ -> return ()
17:13:25 <monochrom> Oh! Yes, putStrLn wants String, no substitute.
17:13:58 <icheishvili> Ok, I'll try that, thanks :)
17:14:04 <monochrom> You shouldn't use and if-then-else to begin with.
17:14:08 <monochrom> s/and/an/
17:14:33 <adamvo> @hoogle whenJust
17:14:33 <lambdabot> No results found
17:14:38 <pumpkin_> lol
17:14:59 <EvilTerran> ?type fromMaybe (return ())
17:15:00 <lambdabot> forall (m :: * -> *). (Monad m) => Maybe (m ()) -> m ()
17:15:07 <icheishvili> Hmmm, that worked...can someone explain to me what the difference is between checking for isJust and doing the stuff in the case?
17:15:22 <pumpkin_> the case just pulled out the value from the Just in this case
17:15:23 <ksf> w00t. querying part of the parse result while parsing another part is going to be fun.
17:15:27 <pumpkin_> there are other even more elegant ways of doing it
17:16:28 <ksf> ...hoping that I don't trigger a second pass run, by accident.
17:16:34 <adamvo> ?type \f -> maybe (return ()) f
17:16:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
17:16:37 <ksf> s/pass/parse
17:16:38 <monochrom> Using "case" you have pattern matching, which not only determines which value you've got, but also gives names to parts of the value such as: "Just x" gives the name x to the string inside your Just.
17:17:05 <monochrom> Pattern matching is always preferred.
17:17:35 <monochrom> It is a reason why Haskell code is leaner than Scheme code.
17:17:52 <icheishvili> Ok, thanks, makes a little more sense--I guess it'll get better for me as I write more things.
17:18:55 <eu-prleu-peupeu> what packages can i look for nice examples of architecture design in haskell ?
17:19:10 <heatsink> as in, software architecture?
17:19:15 <eu-prleu-peupeu> im looking at happstack, which i quite like, but i would like to see some more
17:19:27 <eu-prleu-peupeu> heatsink: yes
17:19:27 <ksf> try the xmonad sources and source walkthrough.
17:20:09 <solrize> xkcd on why Int is evil:  http://www.xkcd.com/571/
17:20:23 <monochrom> ha
17:20:24 <Botje> that's Word16, really
17:20:34 <Botje> Int16? if such a beast exists
17:20:40 <gwern> hm. given a type like 'data Unary = Nil | Un Unary', how does one write a length on it?
17:20:43 <ksf> Word* is unsigned
17:20:44 <monochrom> as though "long int" would be any better
17:20:46 <pumpkin_> Botje: yeah
17:20:46 <zoheb> Anyone here worked with concatenative prog languages?
17:20:47 <gwern> @hoogle Int16
17:20:47 <lambdabot> Data.Int data Int16
17:21:02 <pumpkin_> zoheb: the intersection of #concatenative and here probably has
17:21:04 <solrize> Int is like Int31 or something like that, same problem, bigger numbers
17:21:15 <zoheb> I was wondering what [+] map translates to
17:21:28 <gwern> solrize: thought Int was Int32 or Int64 depending on your platform
17:21:35 <zoheb> is it map (+) or map.(+) in haskell
17:21:45 <solrize> i thought they went to tagged ints?
17:21:53 <zoheb> @t map (+)
17:21:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:21:55 <pumpkin_> on GHC it is, afaik, but the report only requires it to be 29 or something bits?
17:21:59 <ksf> length Nil = 0; length  Un u = 1 + length u
17:22:04 <zoheb> :t map(+)
17:22:05 <lambdabot> forall a. (Num a) => [a] -> [a -> a]
17:22:06 <ksf> ...are you testing the channel?
17:22:07 <zoheb> :t map.(+)
17:22:08 <monochrom> gwern: "f Nil = []; f (Un x) = () : f x", then use "length . f"
17:22:08 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
17:22:29 <georgehorse> > maxBound :: Int
17:22:30 <lambdabot>   9223372036854775807
17:22:47 <solrize> > log 9223372036854775807 / log 2
17:22:49 <lambdabot>   63.0
17:22:51 <heatsink> I'd love a bounded int type that requires static proof of non-overflow, but that would take something more powerful than Haskell's type system to be useful.
17:22:53 <gwern> monochrom: ah. I guess I might as well just define 'type Unary = [()]' then if I'm going to translate it into lists first
17:22:55 <monochrom> lambdabot dreams in long int, as the xkcd comic suggests. :)
17:22:57 <georgehorse> > 2^63 :: Integer
17:22:58 <lambdabot>   9223372036854775808
17:23:02 <pumpkin_> > maxBound :: Word
17:23:03 <lambdabot>   18446744073709551615
17:23:36 <monochrom> gwern: Actually, write some folds for Unary, then a lot of things get easier.
17:23:42 <roconnor> , maxBound :: Word
17:23:44 <lunabot>  4294967295
17:23:51 <solrize> I'd be happy with a bounded int type with a runtime overflow check and exception
17:24:13 <heatsink> > 1 + maxBound :: Word32
17:24:15 <lambdabot>   0
17:24:23 <gwern> monochrom: lots of things? I'm just here doing a little doodling to show that addition in unary is isomorphic to addition in decimal
17:24:44 <monochrom> "a bounded int type with a runtime overflow check and exception" was once widely available 40 years ago when everyone coded in assembly. Just check the carry flag.
17:24:52 * EvilTerran envisages some shocking olegian fundep hackery involving numbers encoded as phantom type parameters for your numeric type to indicate the min & max values possible during runtime
17:24:52 <mansy35> hi any doctors in here?
17:25:05 <pumpkin_> in the medical sense?
17:25:11 <monochrom> Someone decided to ignore the carry flag when they moved to high-level languages.
17:25:13 <Botje> in the sexy sense?
17:25:16 <solrize> mansy35, probably several math ph.d's, does that help?
17:25:20 <gwern> mansy35: no. all the people here are dead-end phd students
17:25:26 <mansy35> haha
17:25:39 <mansy35> i really need to know something
17:25:52 <solrize> who's the "land of lisp guy"?  drcode?
17:25:59 <mansy35> any REAL one out there:-)
17:26:12 <pumpkin_> you mean medical doctors ;)
17:26:20 <mansy35> yes pumpkin
17:26:23 <solrize> http://lisperati.com/haskell/
17:26:25 <mansy35> *G*
17:26:31 <solrize> that was written by an m.d. :)
17:26:53 <mansy35> i'm a CA if that helps... med doctor willing to help CA?
17:26:56 <mansy35> hmmm
17:27:13 <solrize> certified astronaut?  cellular automaton?
17:27:21 <mansy35> haha
17:27:25 <Botje> mansy35: sorry, this channel only cures imperatively challenged people
17:27:29 <mansy35> chartered accountant buddy
17:27:41 <edwardk> monochrom: the lack of a carry bit occasionally pains me in higher level languages
17:27:49 <davidL> what is the absolute fastest way to dump a [Word8] to a file?
17:27:49 <monochrom> This channel is about a programming language called Haskell. If you're looking for an M.D., well, I wouldn't want to say you're in the wrong place, but let's just say you should consider your probabilities.
17:27:51 <mansy35> come on..
17:28:13 <solrize> heh
17:28:16 <mansy35> jees
17:28:22 <hatds> shouldn't it be easy to implement a check for the carry bit?
17:28:24 <mansy35> where could i find one on this server?
17:28:25 <edwardk> mansy35: lots of ph.d.s in here not many m.d.s
17:28:33 <Botje> #medicine, maybe?
17:28:43 <mansy35> lol
17:28:45 <mansy35> yeah
17:28:47 <mansy35> by invite
17:28:48 <monochrom> I haven't heard of one single M.D. on IRC, for what it's worth.
17:28:51 <mansy35> im clearly not invited
17:28:53 * QtPlaty[HireMe] wouldn't trust anyone on irc for medical advice.
17:28:57 <gwern> davidL: bytestring? I guess BS's writeFile would be fasted
17:29:17 <Botje> " and you shouldn't worry about the excessive bleeding"
17:29:18 <solrize> probably data.binary.put
17:29:19 <QtPlaty[HireMe]> I mean #haskell is going to have PhD's and there students.
17:29:31 <solrize> is Word8 lifted?
17:29:36 <davidL> gwern: so far IOUArray Int Word8 is fastest by my crude benchmarks
17:29:45 <heatsink> solrize: yeah, but -O usually unboxes it
17:29:59 <ddarius> Botje: How excessive could it be if you are still worrying?
17:30:09 <solrize> heatsink, hmm neat
17:30:16 <ddarius> edwardk: Ich liebe carry bits.
17:30:18 * ksf wants safeAdd :: Num a => a -> a -> Maybe a
17:30:21 <mansy35> there are 602 users online
17:30:26 <mansy35> not one M.D???
17:30:40 <mansy35> make that 600..
17:30:49 <gwern> mansy35: I'll bet there's not a single brain surgeon here either
17:30:54 <gwern> I wonder how that could be
17:31:01 <ksf> or rather packed in an either, Left signalling that bits dropped off the left side.
17:31:02 <solrize> there might be some married ones though
17:31:06 <hatds> haskell is a form of brain surgey at times
17:31:17 <Botje> @quote brains
17:31:18 <lambdabot> lambdabot says: Listen, broccoli brains, I don't have time to listen to this trash.
17:31:20 <heatsink> I thought it was rocket science.
17:31:32 <solrize> haskell = brain surgery if "making head explode" counts as surgery
17:31:40 <adamvo> @quote surgery
17:31:40 <gwern> @quote rocket
17:31:40 <lambdabot> No quotes match. Do you think like you type?
17:31:40 <lambdabot> No quotes match. Just what do you think you're doing Dave?
17:31:55 <edwardk> heatsink: its brain surgery while doing rocket science
17:32:02 <solrize> @faq can haskell do brain surgery?
17:32:03 <lambdabot> The answer is: Yes! Haskell can do that.
17:32:13 <eu-prleu-peupeu> are there any other extensible architectures in haskell besides xmonad ?
17:32:22 <mansy35> damn
17:32:36 <mansy35> disease of the mind
17:32:39 <adamvo> @go hs-plugins
17:32:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
17:32:41 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
17:33:24 <gwern> adamvo: hs-plugins is deprecated
17:33:51 <adamvo> gwern: what happened to it?
17:33:57 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
17:34:12 <solrize> does that replace it?
17:35:19 <gwern> adamvo: it got old and broken and dons put it away with his velveteen rabbit
17:35:41 <adamvo> eu-prleu-peupeu: also look at yi, but that's the same architecture as xmonad iirc.
17:38:33 <eu-prleu-peupeu> hmm ok
18:08:49 <kadaver> so >>= im gonna write ghc in masm32
18:08:54 <kadaver> ill be back in 6 months
18:09:19 <icheishvili> s/6/60/
18:09:37 <Ralith> s/60/i/
18:15:20 <kadaver> @pl (map . map) (+1)
18:15:21 <lambdabot> map (map (1 +))
18:15:33 <kadaver> @pl map (map (1 +))
18:15:33 <lambdabot> map (map (1 +))
18:21:03 <kadaver> > let flippinmapski = (map . map) (flip (+(-1))) in flippinmapski [[1,2,3],[4,5,6]]
18:21:04 <lambdabot>       Overlapping instances for Show ((a -> c) -> c)
18:21:04 <lambdabot>        arising from a us...
18:21:19 <kadaver> > let flippinmapski = (map . map) (+1) in flippinmapski [[1,2,3],[4,5,6]]
18:21:20 <lambdabot>   [[2,3,4],[5,6,7]]
18:21:31 <kadaver> > let flippinmapski = (map . map) (flip (-1)) in flippinmapski [[1,2,3],[4,5,6]]
18:21:32 <lambdabot>       Overlapping instances for Show (a1 -> c)
18:21:32 <lambdabot>        arising from a use of `...
18:21:41 <kadaver> > let flippinmapski = (map . map) (flip (+(-1))) in flippinmapski [[1,2,3],[4,5,6]]
18:21:42 <lambdabot>       Overlapping instances for Show ((a -> c) -> c)
18:21:42 <lambdabot>        arising from a us...
18:21:51 <kadaver> > let flippinmapski = (map . map) (flip (sub 1)) in flippinmapski [[1,2,3],[4,5,6]]
18:21:52 <lambdabot>   Not in scope: `sub'
18:22:00 <kadaver> > let flippinmapski = (map . map) (flip (subtract 1)) in flippinmapski [[1,2,3],[4,5,6]]
18:22:01 <lambdabot>       Overlapping instances for Show ((a -> c) -> c)
18:22:01 <lambdabot>        arising from a us...
18:22:15 <kadaver> > subtract 1
18:22:16 <lambdabot>       Overlapping instances for Show (t -> t)
18:22:16 <lambdabot>        arising from a use of `s...
18:22:18 <kadaver> > subtract 1 2
18:22:19 <lambdabot>   1
18:22:32 <kadaver> > let flippinmapski = (map . map) (subtract 1) in flippinmapski [[1,2,3],[4,5,6]]
18:22:34 <lambdabot>   [[0,1,2],[3,4,5]]
18:26:08 <Gracenotes> > (1-) $ 10
18:26:09 <lambdabot>   -9
18:49:49 <ryanakca> Could someone help me with http://pastebin.ca/1402463 (RWH, p.39#2) please? I can't seem to load it in a ghci prompt. However, the last line, minus the ``else'' works in it...
18:50:03 <ryanakca> The error is ``Occurs check: cannot construct the infinite type: a = [a]''
18:51:22 <Axman6> ah, i think that may be an impossible function to satisfy for all xs
18:51:55 <Axman6> ryanakca: try using take 1 (drop ((length xs) - 2) xs)
18:52:27 <Axman6> head has type [a] -> a, but your type signature says that you must return a [a]
18:52:39 <ryanakca> Lovely, thanks
18:52:54 <ryanakca> Axman6: If I had had [a] -> a, would it have worked?
18:53:10 * ryanakca checks
18:53:28 <ryanakca> Nope :)
18:53:31 <Axman6> no, in if null xs then xs ... part makes it return a list
18:59:49 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4209#a4209 <- sndLast ryancaka
19:01:15 <kadaver> i think retuning Maybe a makes more sense
19:07:03 <kadaver> liftGod :: Person -> Maybe SPJ
19:09:00 <adamvo> @quote god
19:09:01 <lambdabot> SleepDeprivation says: <Speck> Oh my god. Crickets in the basement. <Speck> Hundreds of them.
19:09:33 <adamvo> @quote spj
19:09:33 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
19:19:12 <skorpan> OT: has anyone here registered a domain with domain.com?
19:20:35 <kadaver> god.com
19:51:56 <NEEDMOAR> Is there any recommended package to work with matrices in Haskell?
19:52:24 <NEEDMOAR> Some package like LinearAlgebra or like that.
19:52:26 <wli> hmatrix
19:52:53 <NEEDMOAR> wli: thanks.
19:54:55 <wli> It's only floating point, but that's what most people want.
19:58:57 <wli> (I happen to want other things, but anyway.)
19:59:48 <kadaver> wli: for what?
20:00:49 <wli> Linear algebra over number fields.
20:04:00 <wli> Also possibly over algebraic extensions of rational function fields.
20:10:32 <_dls> wli: are you doing reed-soloman encoding? I think hmatrix includes a matrix over numberics, so if you just implement the basic operations over your field it should take care of the rest
20:10:55 <wli> No, not Reed-Solomon.
20:11:18 <wli> I've not seen the matrix over Num or whatever.
20:16:47 <wli> I'd think it would have to be over Integral or Fractional.
20:18:43 <_dls> wli: okay, a brief look at the docs makes it look like such a thing is possible (Matrix is w/o reference to what it holds), but I'm not sure :-/ anyone else know?
20:19:08 <_dls> *defined w/o reference*
20:21:13 <wli> I've written fraction-free Gaussian elimination albeit it didn't really work.
21:41:17 <ivanm> @yow!
21:41:18 <lambdabot> I can't decide which WRONG TURN to make first!!  I wonder if BOB
21:41:18 <lambdabot> GUCCIONE has these problems!
22:10:12 <SnailRacer> How accurate are the trig functions in GHC? I was comparing some results of acos from different sources and they're different by more than I expected
22:11:33 <rich0y> hey ppl
22:11:38 <dolio> I'd expect them to be about the same as C, assuming you're using Float or Double.
22:12:22 <dolio> Perhaps I'm off base, though.
22:13:24 <rich0y> i am trying to run this code :
22:13:24 <rich0y> http://rafb.net/p/d0GxjE16.html
22:13:24 <rich0y> but i get this error : exception : Prelude.maximum:empty list
22:13:28 <SnailRacer> the other results are indirectly from C++, they're the same to about 5 places, I really expected six places or better, but now I'm not sure which implementation is the noisy one
22:15:19 <rich0y> ???
22:18:25 <SnailRacer> hmm it's saying that the maximum list is empty
22:18:51 <rich0y> well - what does it mean?
22:19:36 <dolio> Well, acos for Float and Double are just defined in terms of a primop acosFloat# or acosDouble#.
22:20:25 <rich0y> what?
22:20:57 <SnailRacer> OK, so the accuracy of acos is the same as gcc probably
22:21:44 <dolio> One would expect. But I don't know how the primop is defined.
22:21:55 <dolio> I'm trying to find it.
22:22:10 <BMeph> rich0y: It means that you're trying to find the maximum of an empty list, and the compiler's calling your bluff. ;)
22:22:39 <Axman6> :t acos
22:22:40 <lambdabot> forall a. (Floating a) => a -> a
22:22:58 <Axman6> > acos pi :: CReal
22:23:00 <lambdabot>   * Exception: Ratio.%: zero denominator
22:23:09 <Axman6> > acos (pi/2) :: CReal
22:23:10 <lambdabot>   * Exception: Ratio.%: zero denominator
22:23:14 <Axman6> > acos (pi/3) :: CReal
22:23:15 <lambdabot>   * Exception: Ratio.%: zero denominator
22:23:17 <dolio> Heh.
22:23:18 <Axman6> rawr
22:23:38 <Axman6> i always hated arc* trig functions
22:24:26 <dolio> Well, I don't think I'm going to find a definition for acosDouble# anywhere.
22:25:12 <dolio> It's probably handled by the compiler directly, not in any primop file or anything.
22:26:31 <Ralith> > acos (pi/3.0)
22:26:32 <lambdabot>   NaN
22:28:54 <dolio> > acos 1 :: CReal
22:28:55 <lambdabot>   0.0
22:33:10 <SnailRacer> maximum[(a*b)|a<-gena ,b<-genb, 10000000 > (a*b), isPerm (a*b) ((a*b)-a-b+1)]
22:33:52 <SnailRacer> that's a little better... it's an empty list instead of an error, I don't think it likes let in there
22:47:56 <SnailRacer> hmm gcc -funsafe-math-optimisations can mess with acos
22:48:38 <Axman6> you mean it's not safe? :O
22:48:46 <pumpkin_> lol
22:48:58 <Axman6> they should document that somewhere!
22:49:01 <Berengal> Who would've thunk it?
22:49:45 <hydo> Hrm... I think I pissed my system off by installing the 6.10.2 binary over the top of 6.10.1... Control.Monad.State is apparently MIA. :/
22:51:37 <SnailRacer> it makes it use the system implementation on the chip, which means it varies by system
22:52:31 <codebliss> Hello.  I love late night haskell (-5GMT)!
22:53:17 <codebliss> What are some of the useful normal applications of curry and uncurry in day-to-day coding?  I think I'm missing something obvious
22:54:34 <hydo> codebliss: Agreed... late night coding is really nice.  No distractions or interruptions...
22:54:37 <hydo> it's almost...
22:54:39 <hydo> blissful...
22:54:42 <codebliss> LOL
22:54:46 <pumpkin_> codebliss: sometimes a function will give you or take a pair and you don't want it to
22:54:51 <codebliss> Stop making fun of my domain =P
22:55:10 <codebliss> pumpkin_: That's what I assumed.  For tuple deconstruction and construction? (well (,) works, but that's no fun!)
22:56:08 <codebliss> I haven't gone out much past prelude, monads, Data.List etc so it's seemed not too useful as of late.
22:56:58 <codebliss> Is it possible to do say.. type Point = Num a => (a, a)
22:57:15 <codebliss> It errors, and I'm wondering if I'm missing something dumb =)
22:57:22 <codebliss> Should I just make it Double, Double?
22:57:59 <codebliss> Should I make my own Class that can manipulate strings, floats, and ints?
23:03:04 <pumpkin_> codebliss: it's fine, but people typically don't put constraints on types
23:03:24 <pumpkin_> codebliss: you'd need a data though, not a type, I think
23:04:16 <codebliss> pumpkin_: Thanks, messing with that atm.  Cool syntax!
23:04:52 <BMeph> codebliss: Just an aside, though: it'd probably like it better if you used that 'a' on the LHS somewhere.... ;)
23:05:51 <Axman6> codebliss: if you really want to do it, it's be data Num a => Point a = P a a (or P (a,a)
23:05:54 <Axman6> )
23:06:29 <codebliss> LHS?
23:06:42 <codebliss> Ah, gotcha
23:07:03 <codebliss> I was just thinking maybe I could make it so a coord could be a [Char], Integer, or Double
23:07:06 <codebliss> Just for fun
23:10:31 <codebliss> data Num t => Point t = Point (t, t) {- THANKS! -}
23:17:12 <Gracenotes> @botsnack
23:17:12 <lunabot>  :)
23:17:12 <lambdabot> :)
23:17:45 <Gracenotes> > text "I think I have a lag of 2 minutes"
23:17:46 <lambdabot>   I think I have a lag of 2 minutes
23:18:00 <hydo> If I install an older version of Cabal over the top of a newer one, do I have just the older one or do I have both versions available?  Trying to install leksah on 6.10.2 and the darcs version required and older version of Cabal.
23:18:46 <hamishmack> hydo: you should amend leksah.cabal instead
23:19:00 <hydo> hamishmack: ah, ok... even better.
23:20:02 <ivanm> if I'm doing a semi-custom recursion through a list, and then appending another list on the end, should I just go and do the full thing by hand and have the case for the empty list be appending list?
23:20:19 <codebliss> Pointless (ahem)  â€œPoints-freeâ€ Haskell programmer   	(studied at Oxford)   fac = foldr (*) 1 . enumFromTo 1
23:20:21 <codebliss> LOL.
23:20:56 <pumpkin_> product . enumFromTo 1
23:21:24 <ivanm> yeah
23:21:37 <ivanm> > product []
23:21:38 <lambdabot>   1
23:21:46 <ivanm> good-o, it does deal with empty lists
23:21:55 * ivanm wasn't sure if it maybe used foldr1 or something
23:21:56 <Gracenotes> > mempty :: Product Int
23:21:56 <pumpkin_> it's just the foldr
23:21:57 <lambdabot>   Product {getProduct = 1}
23:22:31 <BMeph> product . enumFromTo 2, I'd say. ;p
23:22:37 <ivanm> hydo: I would question why leksah needs a specific version of cabal
23:22:48 <ivanm> BMeph: that's just an optimisation!
23:23:22 <pumpkin_> > let zero = product . enumFromTo 0 in zero 5
23:23:22 <hydo> ivanm: yea, I did as well...  But I didn't quite know how packages work in ghc/cabal...
23:23:23 <lambdabot>   0
23:23:28 <ivanm> hydo: a major version of cabal maybe (e,g, 1.6.*)...
23:23:48 <hydo> ivanm: I just changed it to >= instead of == and it built just fine.
23:24:12 <hydo> Now whether it runs correctly or not... heh
23:24:28 <ivanm> hydo: which version did it have, and which version do you have?
23:24:58 <ivanm> hmmm.... head of a DList is a pretty expensive operation...
23:24:59 * ivanm passes
23:25:13 <hydo> ivanm: it wanted 1.6.0.1 and I have... hrm... whatever comes stock with 6.10.2...
23:25:28 <ivanm> .3 or something...
23:25:39 <ivanm> but yes, I don't know why it specified 1.6.0.1...
23:25:46 <ivanm> maybe the dev only tested it with that version? :s
23:27:49 <ivanm> how is Data.Sequence implemented?
23:28:10 <hydo> grr... ghc still can't find control.monad.state...
23:28:15 <hydo> hulk smash!
23:28:19 <hamishmack> ivanm: It was a bug in the last release, has been fixed in leksah-head
23:28:28 <ivanm> hamishmack: *nod*
23:28:37 <ivanm> @hoogle Control.Monad.State
23:28:38 <lambdabot> module Control.Monad.State
23:28:38 <lambdabot> Control.Monad.State.Lazy newtype State s a
23:28:38 <lambdabot> Control.Monad.State.Lazy State :: s -> (a, s) -> State s a
23:28:50 <ivanm> hydo: probably needs another library
23:28:53 <ivanm> not sure which though :s
23:29:11 <hydo> Oh yea? i thought it was a core module...
23:29:27 <hydo> Oh, i see... like Control.Monad.State.Lazy or the like...
23:29:51 <ivanm> hydo: mtl I think...
23:30:17 <hydo> yea, mtl... which is hidden.
23:30:34 <ivanm> hydo: methinks another bug in the .cabal file ;-)
23:30:42 <hydo> No, this is my own code.
23:30:52 <hydo> I've been yak shaving to get it to compile correctly.
23:31:54 <hydo> hrm... maybe you're right.  If it wasn't just in my own code how did all of this stuff from cabal build without a problem?
23:31:58 <hydo> the plot thickens...
23:33:28 <hydo> Isn't it redundant to include base in build-depends?  It's there by default if you have ghc installed, correct?
23:33:50 <ivanm> hydo: no
23:33:55 <ivanm> since you need to specify version, etc.
23:34:10 <ivanm> and if you have split-base (>=6.8), you need to specify which other libs you need
23:40:29 <pumpkin_> :o
23:41:08 <ivanm> pumpkin_: what?
23:41:15 <dolio> @yow!
23:41:15 <lambdabot> I want a VEGETARIAN BURRITO to go ... with EXTRA MSG!!
23:41:18 <pumpkin_> I just like that smiley
23:41:29 <ivanm> heh
23:44:23 <cYmen> hat aber nix gentzt
23:44:29 <cYmen> woah..sorry :)
23:44:50 <ivanm> so you should be! :p
23:48:26 <dolio> We speek ainglish in this channul.
23:48:44 <ivanm> dolio: isn't that "spaek"?
23:48:47 <SnailRacer> I heard if you put enough MSG in a piece of bread and feed it to a dog, the dog will die
23:48:50 <dolio> Wutever.
