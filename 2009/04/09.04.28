00:00:44 <quicksilver> mmorrow: well, to syntax along the lines of "fromList [...]"
00:01:02 <mmorrow> quicksilver: yeah..
00:01:11 <quicksilver> mmorrow: of course one of the bugs in Show,Read and Typeable is they don't understand the module system.
00:01:14 <quicksilver> Module.Fail.
00:01:16 <A1kmm> sjanssen: Yes. Data.Heap already has a 'policy', but it is at present always undefined and used solely as a type helper... so it would be natural to extend policy and provide an extra heap construction function.
00:01:22 <quicksilver> (let alone the package system)
00:04:45 <mmorrow> oh, here's my go at "fixing" how Chan.isEmptyChan blocks if there's already a thready waiting in a readChan in another thread: http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/Q.hs
00:04:46 <sjanssen> A1kmm: it would be nice to be able to pass in the comparator, even when using one of the static policies
00:05:21 <sjanssen> A1kmm: in the current code, you have to give an explicit type signature to set the policy, which is annoying
00:05:21 <mmorrow> glguy pointed that out yesterday and i thinks it's a bug, since it's not documented behavior
00:05:47 <ski> A1kmm : do you need to change the comparator of existing heaps (presumably reordering) ? .. or just use different comparision on the same heap type in different heaps ?
00:06:02 <copumpkin> sjanssen: I've felt the same way about quickcheck before, for arbitrary instances
00:06:16 <copumpkin> being able to have a "lambda typeclass instance" would be cool :P
00:06:20 <A1kmm> ski: I don't need to re-order, only to set the comparison function dynamically when I create the heap.
00:06:39 <ski> ok
00:06:57 * mmorrow started using <$> instead of `fmap`, and takes back all the bad things he said about <$> :)
00:07:10 <ski> (dynamic ML-style module functors could do that .. i wonder how to emulate it in haskell ?)
00:07:23 <ski> (mmorrow : heretic ;)
00:07:29 <mmorrow> heh
00:07:41 <mmorrow> it saves 3 chars!
00:07:51 <copumpkin> !!!
00:07:52 <ski> ("that" being what A1kmm wanted)
00:08:00 <copumpkin> I just like it cause it has better precedence
00:08:16 <mmorrow> (although "import Control.Applicative" is annoying to have to start adding everywhere)
00:08:24 <quicksilver> copumpkin: you can pass in arbitrary instances to quickcheck
00:08:24 <ski> mmorrow : butbut, the operation is not in the least symmetric, while the operator name is !!
00:08:31 <quicksilver> copumpkin: that's what the 'forall' combinator does.
00:08:42 <copumpkin> quicksilver: oh, awesome, I guess I've been doing it wrong so far :P
00:08:42 <quicksilver> or whatever it's called.
00:08:54 <quicksilver> there is some combinator to pass in an explicit Gen.
00:09:16 <ski> quicksilver : i believe copumpkin want things like `data Showable = forall x. Show x => S x',`instance Arbitrary Showable'
00:09:16 <mmorrow> ski: true, i only like <$> because it's shorter
00:09:41 <mmorrow> and i only use it for fmaping in monads
00:09:48 * ski would have nothing against `<$' or `<@' or `$<' or `@<'
00:10:05 <copumpkin> ski: well, I was thinking more along the lines of lambda notation for making up typeclass instances on the fly, somehow
00:10:06 <ski> mmorrow : not in applicative functors (in general), then ?
00:10:11 <mmorrow> ie i only use <$> when i would use fmap instead of liftM
00:10:28 <mmorrow> ski: i don't use Control.Applicative really
00:10:48 <mmorrow> maybe i'd like it if i started, but i never have
00:10:55 <mmorrow> (never have started (to use it))
00:12:18 <ski> (copumpkin : "lambda typeclass instance" then meaning ?)
00:12:18 <copumpkin> aw, you should!
00:12:27 <quicksilver> ski: I quite like <@
00:12:29 <ski> (copumpkin : better precedence ?)
00:12:32 <quicksilver> is @ allowed in opertors?
00:12:38 <ski> istr so
00:12:46 <mmorrow> as long as it's not (@)
00:12:50 <quicksilver> > let (<@) = (+) in 1 <@ 2
00:12:52 <lambdabot>   3
00:12:54 <ski> > let x >@ f = f x in 5 >@ sin
00:12:56 <lambdabot>   -0.9589242746631385
00:13:09 <mmorrow> yeah, (<@) is pleasing on the eyes
00:13:21 <quicksilver> I think there should be a great operator renaming.
00:13:30 <mmorrow> ooh
00:13:34 <mmorrow> sounds exciting
00:13:36 * quicksilver wants +> for mappend
00:13:52 * mmorrow is all for anything for mappend other than "mappend"
00:13:53 <copumpkin> ski: well, the lambda syntax allows you to define a "throwaway" function, among other things... say I wanted to use a function that used an Ord instance, but didn't provide a *By version allowing me to pass my own comparator. Being able to define an Ord instance on the fly for your type might be fun, but might not be appropriate for all cases
00:14:02 <copumpkin> ski: anyway, just a random thought, probably uselss :P
00:14:02 <mmorrow> wel, anything that's an operator
00:14:02 <Gracenotes> quicksilver: well. that wouldn't make so much sense for commutative stuff
00:14:05 <Gracenotes> imho
00:14:10 <ski> (i prefer `@<' or `$<' for some reason (possibly because it seems to stress which side is the inpute better ?) .. but those two other are acceptable, too)
00:14:20 * mmorrow votes for (++) for mappend
00:14:41 <mmorrow> everyone makes you import libs qualified anyways..
00:14:41 <ski> (i.e. consider `f <@ x <@ y <@ z' vs. `f @< x @< y @< z')
00:15:18 <mmorrow> i like (<@) for purely aesthetic reasons
00:15:31 <Gracenotes> a bouquet of roses, just for you!
00:15:49 <quicksilver> Gracenotes: monoids in *general* are non-commutative. So the general mappend is OK to look non-commutative.
00:15:54 <ski> i'm ok with a "symmetric" operator name for `append'. because if you flip the operator in a monoid, you still get a monoid
00:16:00 <quicksilver> if a particular monoid happens to commute, fine.
00:16:12 <Gracenotes> quicksilver: yes. I think (++) makes sense in both cases though
00:16:20 <quicksilver> ski: but mappend = (+>) lets you define (<+) = flip mappend.
00:16:23 <quicksilver> and that's handy.
00:16:27 <ski> *nod*
00:16:32 <Gracenotes> hm. good point
00:16:32 <mmorrow> yeah true
00:16:40 <quicksilver> then we can compose Endo's either way.
00:16:49 <Gracenotes> sounds hard to parse though
00:16:58 <Gracenotes> I mean, by humans
00:16:59 <ski> how about something like `</>' vs. `<\>' (or some other pair of mirroring "middle" characters) ?
00:17:00 <dolio> Dude, just wrap it in Dual/getDual. That's so much easier!
00:17:16 <ski> dolio : it's often distracting to have to do that
00:17:18 * quicksilver keeps meaning to check if type qualities let you write "instance (a ~ b) => Monoid (a -> b)
00:17:23 <quicksilver> I think dolio was being sarcastic.
00:17:55 <dolio> I wouldn't do that, would I?
00:17:59 * ski 's sarcast-o-meter is out on service
00:18:15 <Gracenotes> maybe (++) for monoid, (+>) and (<+) as utility functions
00:18:57 <mmorrow> @remember dolio Dude, just wrap it in Dual/getDual. That's so much easier!
00:18:57 <lambdabot> Okay.
00:18:59 <mmorrow> lol
00:19:11 <ray> if only <3 could be an operator
00:19:17 <Gracenotes> +> and <+ would be nice utility functions anyway
00:19:24 * ski idly wonders what's the dual of `lol' is
00:19:32 * mmorrow always does "import Monoid(Monoid(..))" out of protest
00:20:04 <ray> ♥ could probably be an operator
00:20:31 <Gracenotes> UnicodeSymbols
00:20:41 <mmorrow> @let (♥) = text "Segmentation fault"
00:20:42 <lambdabot>  Defined.
00:20:48 <mmorrow> > (♥)
00:20:50 <lambdabot>   Segmentation fault
00:20:54 <Hunner> lol
00:20:55 <mmorrow> heh
00:20:58 <blackdog> that's cold, man.
00:21:04 <blackdog> Love hurts?
00:21:10 <ray> you broke my heart
00:21:17 <mmorrow> just the best i could come up with
00:21:20 <Gracenotes> UnicodeSyntax, actually
00:21:22 <copumpkin> http://img519.imageshack.us/img519/3169/post828081178375042thumox7.jpg
00:21:28 <poucet> you opened windows to my heart
00:21:39 <ray> you allocated memory in my heart
00:26:51 <Jedai> @src replicateM
00:26:52 <lambdabot> replicateM n x = sequence (replicate n x)
00:27:15 <quicksilver> ski: the dual of lol is (\x -> I did it for the x)
00:27:37 <copumpkin> lulz?
00:27:43 <copumpkin> zlul
00:28:23 <copumpkin> zomg http://hamletdarcy.blogspot.com/2008/07/morphisms-for-masses.html
00:28:25 <Gracenotes> that's a corruption
00:29:01 <wli> Morphisms for masses?
00:36:08 <dolio> Any blog with a picture of a unicorn and a rainbow has to have good category theory stuff on it.
00:38:59 <dolio> "hylo" is wood? How'd they end up using that?
00:39:08 <copumpkin> that's the same pic that bonus has on his twitter iirc
00:39:28 <copumpkin> or maybe not
00:39:30 <copumpkin> similar though
00:40:03 <quicksilver> we should get haskell baseball caps which say 'Hylo Sailor'
00:40:11 <copumpkin> dolio: apparently it means matter or substance too
00:40:36 <dolio> Is that what it says in the banana paper? It's been a long time since I read that.
00:40:50 <copumpkin> I haven't read the banana paper :P
00:40:56 <copumpkin> sounds fascinating though
00:41:02 <dolio> Geeze. Get with the times!
00:41:20 * copumpkin is trying to catch up!
00:41:34 <copumpkin> searching for haskell banana didn't get me much
00:41:35 <copumpkin> @where banana
00:41:35 <lambdabot> I know nothing about banana.
00:42:08 <dolio> @go Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire
00:42:10 <lambdabot> http://wwwhome.cs.utwente.nl/~fokkinga/mmf91m.ps
00:42:15 <copumpkin> oh my
00:42:59 <quicksilver> is there a wellknown mapping from N to colours such that each initial segment has "well-spaced" colours?
00:43:24 * quicksilver supposes a gentle inward spiral on HSV is probably the way to do it.
00:43:58 <QtPlaty[HireMe]> quicksilver: What do you mean by well-spaced?
00:44:07 <Gracenotes> yeah, cos/sin spirals tend to yield a pretty range of colors
00:44:21 <dolio> On a cursory skimming, this doesn't seem to say where the names come from.
00:44:36 <Gracenotes> not sure how interesting it would be for higher values of N, but if you have something specific in mind, maybe
00:50:45 <younder> As I am a Haskell beginner I have been implementing the algorithms in Barnsley's "Fractals eveywhere" in Haskell and gnuplot
00:52:50 <younder> Not the most efficient for Mandebrot fractals and Julia set's, but fine for line diagrams
00:55:44 <younder> gnuplot that is
00:56:52 <dolio> You could write your own PPM output function. Who hasn't done that?
00:57:06 <dolio> Someone should, like, make a library.
00:57:15 <p_l> lol
00:58:21 <dolio> Oh, I guess hackage has something for a few image formats.
00:58:46 * p_l recalls someone working on PPM or PBM library few days ago
00:59:05 <dolio> stb-image does JPEG, PNG, TGA, BMP and PSD.
01:00:30 <dolio> Wait, this only loads/decodes images.
01:07:08 <xrfang> I defined a type data Weekdays = Sunday|Monday...
01:07:10 <xrfang> and do:
01:07:17 <xrfang> read "Sunday" :: Weekday
01:07:19 <xrfang> it works fine
01:07:37 <xrfang> however, if I do:  read "Sunday" :: [Char], it does not work?
01:07:51 <Botje> well, no
01:08:00 <opqdonut> you have to say read "\"Sunday\"" :: [Char]
01:08:07 <Botje> read is designed to work as the opposite of show
01:08:22 <Botje> so read (show "Sunday") should equal "Sunday" :: [Char]
01:08:39 <Botje> you can check what show "Sunday" is yourself
01:08:40 <pozic> Is polar matrix decomposition implemented anywhere in Haskell?
01:08:41 <xrfang> ok thanks
01:08:43 <Botje> or just read what opqdonut said
01:08:53 <xrfang> yes it worked.
01:09:32 <Botje> of course, using read to get back a [Char] doesn't make much sense usually
01:10:13 <xrfang> Botje, indeed, I am just trying my best to understand things that I "think" is peculiar. :)
01:10:56 <quicksilver> QtPlaty[HireMe]: mutually distinguishable by naked eye
01:11:23 <quicksilver> QtPlaty[HireMe]: approximately 'maximally' so, given the constraint of the number of colours
01:11:32 <luqui> does anybody know if beta-eta normal form is canonical?
01:11:53 <luqui> i.e. two functions which are equal and both have normal forms will always have the same normal form?
01:13:01 <tsLight> id (+1) 0 is associated like (id (+1)) 0 (because of function binding power), am I right?
01:13:07 <xrfang> I am still not sure what is the difference between "." and "$", please see these 2 functions:
01:13:15 <xrfang> findKey key xs = snd . head . filter (\(k,v) -> key == k) $ xs
01:13:22 <xrfang> findKey key xs = snd $ head $ filter (\(k,v) -> key == k) $ xs
01:13:36 <xrfang> they all seems work, what's the difference?
01:13:36 <Botje> xrfang: . is for composing functions
01:13:50 <Botje> head . [ 1..10 ] is nonsense
01:13:55 <luqui> (snd . head . filter ...) xs     vs.   snd (head (filter ... xs))
01:13:56 <Botje> whereas head $ [ 1..10] works
01:13:59 <xrfang> Botje: I know the "definition" (although maybe I am wrong. but I don't know why
01:14:25 <Botje> . takes two functions, $ takes a function and a value
01:14:50 <xrfang> if I don't know haskell, from a C/Java/... whatever language programmer's point of view, the thing is to do: funcA(funcB(funcC(param))), right?
01:15:02 <xrfang> that's a VERY clear thing, although too many ()s :)
01:15:06 <Botje> yes
01:15:14 <Botje> however, java does not have function composition
01:15:28 <quicksilver> tsLight: yes.
01:15:34 <xrfang> so what do you call this: funcA(funcB(var)))
01:15:41 <xrfang> that's not a "composition"?
01:15:53 <Botje> it's a composition that's applied
01:16:05 <Botje> you'd write that as: \x -> funcA . funcB $ var
01:16:06 <Botje> OR
01:16:12 <Botje> \x -> (funcA . funcB) var
01:16:13 <Botje> OR
01:16:15 <tsLight> quicksilver, thanks
01:16:16 <Botje> uh
01:16:19 <Botje> \x -> (funcA . funcB) x
01:16:20 <Botje> even :)
01:16:25 <Botje> and go from there to funcA . funcB
01:16:44 <Botje> but when you actually want the value, you can apply it
01:17:05 <ski> quicksilver : hm .. why ?
01:17:07 <xrfang> but in java , we just write public funcC(var) { return funcA(funcB(var))}
01:17:14 <Botje> in foo . bar . baz . qux $ value, that last $ can never be a .
01:17:17 <xrfang> that's the different with that and the haskell composition?
01:17:27 <Botje> you can _ALSO_ write it as foo $ bar $ baz $ qux $ value
01:17:30 <xrfang> Botje, yes, but the . can be $
01:17:43 <Botje> but the advantage of . over $ is that you can leave off the $ value
01:17:44 <quicksilver> ski: why to my colour point? Automatically choosing 'attractive' colours for diagrams
01:17:46 <Botje> and get a function
01:17:53 <quicksilver> ski: not necessarily knowing how many I'm going to need in advance.
01:17:58 <Botje> whereas foo $ bar $ baz is something different than foo . bar . baz
01:18:23 <cedricshock> How do you add flags like -auto-all to cabal?
01:18:28 <ski>   public static <A,B,C> Fun<A,C> compose(Fun<B,C>,Fun<A,B>);  // can't you do something like this in newish java ?
01:18:46 <ski> quicksilver : sorry, no. to the "dual of `lol'" point
01:19:00 <Botje> xrfang: you can take any part of a foo . bar . baz . qux pipeline and still have a function, not so with foo $ bar $ baz. That's the main difference
01:19:07 <xrfang> Botje:   I think the place to use ., which makes it TRUELY different than $ is things like newFunc = func1.func2.func3
01:19:12 <xrfang> i.e. function definition.
01:19:22 <Botje> yes, that's what i was saying, but not as clear
01:19:24 <xrfang> while you use the function, actually . and $ are not much different
01:19:31 <xrfang> ok to say that?
01:19:41 <Botje> make it a bit more rigourous :)
01:19:42 <ski> quicksilver : wouldn't it be nice if you parameterize "how fast the spiral turns inward" .. i.e. the spacing of two adjacent turn ?
01:20:06 <quicksilver> ski: well, one definition of dual is annihilator.
01:20:14 <quicksilver> ski: and "I did it for the lulz" is a kind of unit.
01:20:17 <quicksilver> (obviously)
01:20:29 <Botje> if you're applying a function to a value, function application is equivalent to function composition and then application
01:20:34 <quicksilver> ski: perhaps, but that requires me to know how many colours in advance :)
01:20:37 <Botje> bleh
01:20:43 <Botje> maybe it's too early :)
01:20:47 * Botje goes off to write a bit
01:21:23 <xrfang> function application is actually a composition, isn't it? e.g. a function expect 2 params, I give it one, then the result is a function expecting the onther param
01:21:29 <xrfang> isn't that "application"?
01:21:33 * ski mentions the "reverse the associativity of `$' !" argument
01:21:38 <quicksilver> that is application, it is not composition.
01:21:45 <quicksilver> composition is composing two functions.
01:21:53 <quicksilver> not applying something and then applying the result of that.
01:21:58 <xrfang> ok, thanks.
01:22:18 <xrfang> next question (many :)):  I see this in LYAH:
01:22:20 <xrfang> findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:22:21 <ski> > map (sin . cos) [0,pi/2 .. 2*pi]
01:22:23 <lambdabot>   [0.8414709848078965,6.123233995736766e-17,-0.8414709848078965,-1.8369701987...
01:22:31 <xrfang> I think it is not very "effective"?
01:22:47 <_dls> uh guys... I think I must be using QuickCheck wrong.... let t =  a == (reverse a) in quickCheck t.... _passes_
01:22:51 <xrfang> foldr will NOT break while findKey actually found a key?
01:23:11 <ski> > filter (not . null) ["abc","","de","f","","ghij","","","k"]
01:23:12 <dolio> _dls: You must have an 'a' in scope somewhere.
01:23:12 <lambdabot>   ["abc","de","f","ghij","k"]
01:24:12 <xrfang> anybody?
01:24:16 <_dls> @check \a -> (reverse a) == a
01:24:17 <lambdabot>   "OK, passed 500 tests."
01:24:22 <quicksilver> xrfang: that's right, it finds the 'last' one.
01:24:33 <xrfang> ok, that's clear. thanks.
01:24:40 * _dls guesses lambdabot has an 'a' in scope :p
01:24:50 <ski> > findKey "dog" (("cat",42):("dog",17):error "oops")  where  findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:24:50 <dolio> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey 5 $ zip [1..] [1..]
01:24:52 <lambdabot>   Just 17
01:24:52 <lambdabot>   Just 5
01:25:03 <ski> > findKey "dolio" (("cat",42):("dog",17):error "oops")  where  findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:25:04 <lambdabot>   * Exception: oops
01:25:08 <Botje> _dls: can you try fixing the type of t to [Int]
01:25:09 <xrfang> how do I define a "infinite" data type? e.g.:
01:25:10 <quicksilver> _dls: type defaulting.
01:25:15 <Botje> _dls: because if the type defaults to [()] ... :)
01:25:17 <ski> > findKey "dolio" [("cat",42),("dog",17)]  where  findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:25:18 <lambdabot>   Nothing
01:25:31 <quicksilver> _dls: it's working on the type [()], and all lists in [()] are indeed palindromes.
01:25:34 <saurik> shouldn't quicktest support some kind of "oh, the type here can be arbitrary, let's randomly select possible types"?
01:25:38 <xrfang> data Shape = Circle Point Float | Rectangle Point Point
01:25:42 <_dls> is there a way to have it check with arbitrary types? (so char, int, etc.?)
01:25:52 <_dls> I want to test if it's overgeneralized, etc.
01:25:54 <xrfang> I can continue define Triangles if I want
01:26:02 <_dls> thanks guys, btw
01:26:04 <quicksilver> xrfang: you can't. data types are local and static.
01:26:04 <xrfang> but how to define: Polygon Point Point.....
01:26:09 <ski> > findKey "cat" [("cat",42),("cat",17)]  where  findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:26:10 <lambdabot>   Just 42
01:26:13 <quicksilver> xrfang: oh, I misunderstood.
01:26:19 <quicksilver> xrfang: Polygon [Point] perhaps ?
01:26:23 <ski> quicksilver,xrfang : so not the last one
01:26:38 <xrfang> ok, so I can define:
01:26:48 <quicksilver> ski: "last" counting form the right, isn't it?
01:26:52 <quicksilver> ski: becuase it's a foldr.
01:27:03 <xrfang> data Shape = Circle Point Float | Rectangle Point Point | CustomShape [Point], right?
01:27:08 <quicksilver> xrfang: yes.
01:27:11 <xrfang> thanks
01:27:18 <ski> xrfang : i.e. it only traverses (and computes) the list until it finds the value, the rest of the list is not evaluated by this (it might be evaluated by other code, of course)
01:27:37 <xrfang> but when use this I need to use CustomShape differently than other Shapes, i.e. the Constructor takes a list, right?
01:27:53 <ski> quicksilver : i'm not sure how to interpret that ..
01:28:11 <xrfang> ski sorry I overlooked your example, one moment
01:29:07 <dolio> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey 5 [(5,"foo"),(5,"bar")]
01:29:08 <xrfang> ski, "not last one", you mean "Just <last one>" right?
01:29:08 <lambdabot>   Just "foo"
01:29:38 <quicksilver> ski: Oh, I was just plain wrong.
01:29:40 <xrfang> or if you fold from the right, then it is "Just <first one>"?
01:29:48 <quicksilver> apologies xrfang .
01:29:53 <ski> xrfang : i mean that if you use `findKey' on the association list `[("cat",42),("cat",17)]' and search for `"cat"', you will find the `42' value, not the `17' value
01:30:14 <xrfang> right, that's the "last" value the foldr traverses
01:30:18 <ski> xrfang : i.e. the value part of the *first* (not last) pair containing the key you're looking for
01:30:39 <xrfang> yes, that's why I think it is a bit "inefficient".
01:30:41 <ski> maybe we have different definitions of "first","last", i don't know ..
01:30:56 <ski> in `[1,2,3]' i consider `1' to be the first element and `3' the last element
01:31:01 <xrfang> no matter how we define first or last
01:31:16 <xrfang> the key point I ask, is that this function will loop though the entire list
01:31:24 <dolio> No.
01:31:24 <xrfang> not stop when it find one
01:31:41 <dolio> It stops as soon as it finds one.
01:32:02 <xrfang> why?
01:32:08 <dolio> Laziness.
01:32:09 <ski> so, the point is that it is *not* inefficient in the sense that it will have to start looking from the "right" .. instead, it will start looking from the "left", and cut of searching as soon as it finds a matching key
01:32:20 <xrfang> dolio, no I don't understand,
01:32:23 <xrfang> pls explain.
01:32:39 <xrfang> where it "cut"?
01:32:47 <ski> look at
01:32:52 <ski>   findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:33:00 <pao> Hi all...
01:33:14 <ski> in the lambda, `acc' is the result of the folding on the "rest" of the list
01:33:35 <ski> the point to note is that `acc' is *not* evaluated in the `then' branch of the conditional
01:33:38 <pao> can anyone tell me how to convince cabal to link libstdc++ statically instead of dinamic linking to my package?
01:33:46 <ski> this is because of laziness
01:33:51 <dolio> findKey 5 [(5,5), ...] = (\(k,v) acc -> if 5 == k then Just v else acc) (5,5) (findKey 5[...]) = if 5 == 5 then Just 5 else (findKey 5 [...]) = Just 5
01:34:03 <dolio> It doesn't need to look at findKey 5 [...] to return an answer.
01:34:18 <xrfang> > let findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing in findKey "a" [("a", 1), ("b", 2)]
01:34:19 <lambdabot>   Just 1
01:34:21 <dcoutts> pao: hmm, try --ghc-options=-optl-static
01:34:50 <pao> dcoutts: I'll try...
01:35:19 <xrfang> dolio, ski, a bit confused
01:35:19 <ski> xrfang : in your example there, first it checks whether `key' i.e. `"a"' is the same as `k', i.e. `"a"' .. since it is, it will return `Just v', i.e. `Just 1'
01:35:37 <xrfang> ski: it return Just 1 to acc, right?
01:35:46 <xrfang> acc is used throughout fold
01:36:09 <Gracenotes> @src foldr
01:36:10 <lambdabot> foldr f z []     = z
01:36:10 <xrfang> while acc get "Just 1", it should go to the next element, and pass the next element and acc to the lambda?
01:36:10 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:36:26 <ski> xrfang : in your example, the `acc' in that else branch is basically `foldr (\(k,v) acc -> if "a" == k then .. else ..) Nothing [("b",2)]
01:36:50 <Gracenotes> the function takes two values: x, and the accumulator. If the function ignores the accumulator, then no further foldr-ing needs to be done, really
01:37:10 <ski> xrfang : *if* haskell were a strict language, `foldr' would have to evaluate that *before* the "outer" `if' test happens (to pass the result of that expression as `acc' to the lambda)
01:37:49 <xrfang> Gracenotes: you mean, in the branch "if key == k then Just v", the acc is NOT used, then haskell some how knows that it should break out??
01:37:57 <ski> xrfang : but since haskell is non-strict, `acc' need not be evaluated until it's actually needed. and since we find a matching key immediately, it is not needed at all
01:38:16 <xrfang> ski: HOW does haskell know that you are find a key??
01:38:21 <xrfang> what if, say
01:38:34 <xrfang> you want to find the maximum value in a list??
01:38:43 <ski> that's another story
01:38:45 <xrfang> it then cannot break out in middle
01:38:50 <ski> right
01:38:58 <ski> to find the maximal element, you have to look at every element
01:39:07 <xrfang> so what is the "rule" or logic to make it breakout in the findKey example?
01:39:17 <ski> (well, maybe not if your datatype has a global maximum, and you've found it in the list)
01:39:26 <ski> let's evaluate and see, ok ?
01:39:39 <xrfang> ok,
01:39:47 <Gracenotes> xrfang: in the foldr definition, what you feed to f is (foldr f z xs). Haskell is lazy, so if you don't use the value, it isn't calculated
01:39:58 <ski> first, recall that
01:40:00 <ski>   findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:40:04 <ski> we also need to see
01:40:07 <ski> @src foldr
01:40:07 <lambdabot> foldr f z []     = z
01:40:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:40:17 <ski> now, we want to evaluate
01:40:43 <ski>   findKey 3 [(3,31),(2,25)]
01:40:46 <xrfang> data is [("a", 1), ("b", 2)]
01:40:46 <ski> ok ?
01:40:55 <ski> ok
01:41:02 <xrfang> suppose we do findKey "a" [...]
01:41:03 <ski>   findKey "a" [("a", 1), ("b", 2)]
01:41:26 <ski> now, first we look at the definition of `findKey' above, and use that to rewrite this expression
01:41:31 <ski> into
01:41:43 <younder> looks a lot like the common lisp assoc function
01:41:49 <ski>   foldr (\(k,v) acc -> if "a" == k then Just v else acc) Nothing [("a", 1), ("b", 2)]
01:41:56 <ski> do you agree with that step ?
01:42:12 <pao> dcoutts: it doesn't work... any further suggestion?
01:42:12 <xrfang> sorry I am a bit slow, give me a min.
01:42:27 <xrfang> go on pls
01:42:36 <ski> (i've replaced `findKey "a"' with the body of `findKey key = foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
01:42:39 <ski> arg
01:42:56 <ski> (i've replaced `findKey "a"' with the body of `findKey key', remembering that `key' must be replaced with `"a"')
01:43:10 <xrfang> yes
01:43:15 <dcoutts> pao: if you can get it working using a simple test case and just ghc, then we can do the same via Cabal
01:43:15 <ski> now, the list
01:43:19 <ski>   [("a", 1), ("b", 2)]
01:43:21 <ski> is the same as
01:43:27 <ski>   ("a", 1) : [("b", 2)]
01:43:34 <xrfang> right
01:43:40 <pao> dcoutts: I'll try that... I guess my problem is Mac OSX
01:43:57 <ski> so, now we use the second equation of `foldr' above, replacing our expression with the body of that
01:44:06 <ski> i.e. we want
01:44:10 <ski>   f x (foldr f z xs)
01:44:40 <dcoutts> pao: ohh, I didn't know you could link anything statically on OSX
01:44:48 <ski> but `f' should be `\(k,v) acc -> if "a" == k then Just v else acc', `x' should be `("a", 1)', and `xs' should be `[("b", 2)]'
01:44:51 <ski> so we get
01:45:15 <pao> dcoutts: well, you can... but I've seen people reporting the same problem wrt wx haskell bindings
01:45:21 <ski> (sorry, forgot `z'. it should be `Nothing')
01:45:32 <xrfang> ok, I am thinking pls continue
01:45:40 <pao> dcoutts: I'll try on linux to see if that's a mac os x specific problem
01:45:51 <ski>   (\(k,v) acc -> if "a" == k then Just v else acc) ("a", 1) (foldr (\(k,v) acc -> if "a" == k then Just v else acc) nothing [("b", 2)])
01:46:00 <pao> dcoutts: thanks for the opt-static suggestion
01:46:18 <dcoutts> pao: I know you can't make a fully static prog on OSX, perhaps you can statically link some libs
01:46:37 <xrfang> ski: so in f x (foldr f z xs),
01:46:37 <ski> this may look a bit unweildy, but if you carefully compare that with `f x (foldr f z xs)', remembering what `f',`z',`x' and `xs' should be, you should see that it's a correct rewriting step
01:46:46 <xrfang> the acc is actually (foldr f z xs) right?
01:46:54 <younder> pao: Try the gtk bindings. It is better to interface a C interface anyhow and it can be made to run under Windows and Mac's if you have to
01:47:00 <ski> yes, in the next step, `acc' will become that
01:47:06 <ski> because in
01:47:07 <pao> dcoutts: that's my goal... I would like to bundle libstdc++.a to the haskell package
01:47:10 <ski>   (\(k,v) acc -> if "a" == k then Just v else acc) ("a", 1) (foldr (\(k,v) acc -> if "a" == k then Just v else acc) nothing [("b", 2)])
01:47:44 <ski> we're applying a function `(\(k,v) acc -> ...)' to two arguments `("a", 1)',`(foldr ...)'
01:47:58 <pao> younder: I'm not interested in gui libraries, that was only a project similar to mine as far as dependencies are concerned  :-)
01:48:02 <xrfang> ok
01:48:04 <xrfang> go on
01:48:10 <ski> so `k' should be `"a"', `v' should be `1', and `acc' should be that `(foldr ...)' expression
01:48:20 <ski> so from
01:48:22 <ski>   (\(k,v) acc -> if "a" == k then Just v else acc) ("a", 1) (foldr (\(k,v) acc -> if "a" == k then Just v else acc) nothing [("b", 2)])
01:48:26 <ski> we get
01:48:51 <ski>   if "a" == "a" then Just 1 else foldr (\(k,v) acc -> if "a" == k then Just v else acc) Nothing [("b", 2)])
01:49:02 <ski> ok so far ?
01:49:06 <xrfang> yes
01:49:46 <ski> now the `if' expression wants to know whether the boolean condition is `True' or `False', so it evaluates that first
01:49:50 <ski> to
01:49:54 <ski>   if True then Just 1 else foldr (\(k,v) acc -> if "a" == k then Just v else acc) Nothing [("b", 2)])
01:50:29 <ski> now *if* we had gotten `False' here (e.g. if we searched for `"c"' instead), *then* we would get
01:50:31 <xrfang> so now it seems clear, this is True, then the else part is not needed, that's what you mean?
01:50:35 <ski>   foldr (\(k,v) acc -> if "a" == k then Just v else acc) Nothing [("b", 2)])
01:50:38 <ski> *but*
01:50:54 <ski> we did get `True' and not `False', so what we get from
01:50:56 <ski>   if True then Just 1 else foldr (\(k,v) acc -> if "a" == k then Just v else acc) Nothing [("b", 2)])
01:50:59 <ski> is
01:51:02 <ski>   Just 1
01:51:07 <ski> remember that
01:51:19 <ski>   if True then something else another
01:51:21 <ski> evaluates to
01:51:23 <ski>   something
01:51:24 <ski> and
01:51:29 <ski>   if False then something else another
01:51:32 <ski> evaluates to
01:51:33 <ski>   another
01:51:55 <xrfang> ok, I have a few questions about that...
01:51:55 <ski> xrfang : this last step above is the crucial step
01:52:07 <xrfang> 1)
01:52:21 <xrfang> the foldr should get the RIGHT most item out first, right?
01:52:30 <xrfang> e.g. [(a, 1), (b, 2)]
01:52:36 <xrfang> it will get b in the first step??
01:52:39 <ski> no
01:52:42 <xrfang> but the definition says it is a?
01:52:44 <ski>   [(a, 1), (b, 2)]
01:52:48 <xrfang> @src foldr
01:52:49 <lambdabot> foldr f z []     = z
01:52:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:52:49 <ski> is syntactic sugar for
01:52:56 <ski>   (a, 1) : [(b, 2)]
01:53:07 <ski> and the second equation for `foldr' matches on `x:xs'
01:53:18 <Gracenotes> > foldr f 0 [1..5]
01:53:19 <lambdabot>   Add a type signature
01:53:24 <Gracenotes> > foldr f 0 [1..5] :: Expr
01:53:25 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 0))))
01:53:31 <ski> so `x' is `(a, 1)' while `xs' contain all the rest of the pairs, i.e. `[("b", 2)]'
01:53:49 <Gracenotes> note that "f 5 0" may the first real result if the f requires both arguments
01:53:49 <xrfang> @src fold
01:53:50 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:53:53 <xrfang> @src foldl
01:53:53 <lambdabot> foldl f z []     = z
01:53:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:54:09 <ski> remember that evaluation in haskell generally proceeds "from the outside, inwards"
01:54:12 <Gracenotes> however, if f doesn't require both arguments, you might be able to forget about later parts of the list
01:54:12 <ski> in
01:54:15 <xrfang> I think I messed that up entirely,
01:54:19 <ski>   f (g x) (h x y)
01:54:34 <ski> *`f'* will be called first, *not* `h' or `h'
01:54:47 <ski> (er, *not* `g' or `h')
01:55:24 <xrfang> I need to study foldl foldr :)   btw, is there anything like @src in ghci?
01:55:46 <Gracenotes> oh, another way to think about it is by getting rid of the foldr altogether. We know that z is Nothing and f is (\(k, v) acc -> if k == key then v else acc), and acc is (foldr f z xs). So to translate to plaon old recursion...
01:55:51 <Gracenotes> findKey key [] = Nothing
01:55:53 <Gracenotes> findKey key (x:xs) = func x (findKey key xs) where func (k, v) acc = if k == key then v else acc
01:56:17 <Gracenotes> a simpler way to write the second line: findKey key ((k, v):xs) = if k == key then v else findKey key xs
01:56:52 <Gracenotes> note that the structure of the above function is very similar to foldr. we just know what f and z are in advance
01:57:07 <xrfang> if in f (g x) (h x y)
01:57:13 <xrfang> f is evaluated first
01:57:40 <xrfang> then, we must ensure that after (f (g x)) it is an "application", so that it can further consume (h x y) right?
01:58:12 <ski> well, if `f' is defined like
01:58:21 <ski>   f (...) (...) = ...
01:58:28 <Gracenotes> well, the type-checking is already done by the time the code is compiled. If you can't apply (h x y) to (f (g x)), the code simply won't compile
01:58:37 <ski>   (possibly more than one defining equation)
01:58:58 <ski> then `f' will "eat" both `g x' and `h x y' at the same time (not necessarily evaluating them)
01:59:11 <ski> however, sometimes `f' is defined like
01:59:16 <ski>   f (...) = ...
01:59:30 <ski> (then the right hand side of the `=' is a function)
01:59:32 <ski> so then
01:59:40 <ski>   f (g x) (h x y)
01:59:46 <ski> will be thought of as
01:59:50 <ski>   (f (g x)) (h x y)
01:59:55 <ski> (which it really is)
02:00:02 <ski> and that will be reweitten to
02:00:07 <ski>   (...) (h x y)
02:00:23 <ski> where the `...' comes from the definition of `f'
02:00:37 <ski> and maybe later `h x y' will get "eaten"
02:00:50 <ski> xrfang : does that help any ?
02:01:13 <xrfang> ski: yes, I am doing some exercise, will come back with my function :)
02:01:40 <ski> btw, i said e.g. `g x' is not neccesarily evaluated when `f' is called
02:01:45 <ski> if `f' is defined like
02:01:52 <ski>   f a b = ...
02:01:53 <ski> or
02:01:56 <ski>   f _ b = ...
02:02:12 <ski> where `a' is a *variable*name*
02:02:28 <younder> can someone explain why $! is needed for tail recursion in:
02:02:38 <ski> then `g x' will not be evaluated
02:02:44 <ski> if anytime later, the value of `a' is needed, *then* `g x' will be evaluated
02:02:51 <ski> but if `f' is defined like
02:02:57 <ski>   f 42 b = ...
02:02:58 <ski> or
02:03:01 <xrfang> I tried: findMax = foldr (\x acc -> if Just x > acc then Just x else acc) Nothing
02:03:02 <ski>   f [] b = ...
02:03:07 <ski>   f (c:cs) b = ...
02:03:12 <xrfang> it says "ambiguous type..."
02:03:37 <ski> or any pattern involving an actual data *constructor*, then `g x' will be evaluated directly when `f' is called
02:04:01 <ski> xrfang : that's the "Dreaded Monomorphism Restriction"
02:04:12 <ski> you can avoid it by giving a type signature to `findMax'
02:04:14 <ski> like
02:04:31 <ski>   findMax :: [Integer] -> Maybe Integer
02:04:33 <ski> or
02:04:37 <xrfang> ski: I was told to avoid type signature and let haskell to decide??
02:04:42 <ski>   findMax :: Ord a => [a] -> Maybe a
02:05:07 <xrfang> strangely, I wrote that in a file and :l in ghci, it give me the error
02:05:19 <xrfang> but if I define it in ghci directly use let, seems ok!
02:05:20 <ski> xrfang : yes .. unfortunately, the monomorphism restriction doesn't allow that .. many people think it should be removed
02:05:44 <xrfang> I have not read about monomorphism yet :$
02:06:00 <doserj> you can also define findMax xs = foldr (...) Nothing xs
02:06:11 <doserj> to circumvent the monomorphism restriction
02:06:39 <ski> xrfang : basically, the "monomorphism restriction" was invented because it was thought that in some cases it would make newbies/learners less confused ..
02:07:02 <ski> xrfang : .. unfortunately, as you're experiencing, it can make them more confused, in some cases
02:07:02 <xrfang> seems that I am actually confused :p
02:07:22 <doserj> xrfang: it works in ghci because ghci defaults the type to (), which arguably is confusing...
02:07:29 <ski> (and it is arguable whether the first kind of confusion would be that common or serious)
02:07:42 <xrfang> I did this :
02:07:52 <xrfang> findMax :: (Ord a) => [a] -> a
02:07:54 <xrfang> findMax = foldr (\x acc -> if Just x > acc then Just x else acc) Nothing
02:08:05 <xrfang> oops sorry
02:08:16 <xrfang> should be Maybe a?
02:08:32 <ski> yes
02:08:36 <Botje> > Just 4 > Nothing
02:08:38 <lambdabot>   True
02:08:52 <younder> can someone explain why $! is needed for tail recursion in:
02:08:54 <younder> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2262#a2262
02:10:19 <xrfang> the findMax actually works...
02:10:21 <Peaker> younder: that's not very pretty
02:10:31 <ski> younder : (in absense of magic strictness analyses,) haskell will do
02:10:39 <xrfang> I think it is because in "if Just x > acc..." acc is used, so it cannot break out like the findKey :)
02:10:48 <ski>     myLength ['a','b','c','d']
02:11:05 <ski>   = internalCount ['a','b','c','d'] 0
02:11:11 <Gracenotes> younder: it's tail recursive even without the $!
02:11:21 <Gracenotes> as far as I can tell
02:11:23 <Peaker> younder: the guard for null xs would be nicer expressed as a pattern match..
02:11:33 <ski>   = internalCount ['b','c','d'] (0 + 1)
02:11:39 <ski>   = internalCount ['c','d'] ((0 + 1) + 1)
02:11:48 <ski>   = internalCount ['d'] (((0 + 1) + 1) + 1)
02:11:54 * ManateeLazyCat pasted "WindowsList.hs" at http://paste2.org/get/193601
02:11:55 <ManateeLazyCat> In above file WindowsList.hs, i define a function named "getWindowsList", when i compile it, i got error "No instance for (MonadState WindowsList m), Possible fix: add an instance declaration for (MonadState WindowsList m)", how to write this instance? I try to write it, but failed. Thanks!
02:11:56 <younder> Gracenotes: No, I tried it without with [1..1000000] and it failed
02:11:57 <ski>   = ((0 + 1) + 1) + 1
02:12:00 <ski>   = (1 + 1) + 1
02:12:03 <ski>   = w + 1
02:12:05 <ski> er
02:12:08 <ski>   = 2 + 1
02:12:09 <ski>   = 3
02:12:31 <ski> younder : that is if you used
02:12:35 <doserj> younder: in a lazy language, tail-recursive does not imply constant stack space, as you see here
02:12:36 <ski>   internalCount (_:xs) count = internalCount xs (count + 1)
02:12:38 <ski> instead of
02:12:39 <ski>   internalCount (_:xs) count = internalCount xs $! count + 1
02:13:24 <ski> younder : in this case, haskell thinks that possibly `((0 + 1) + 1) + 1' need not be evaluated at all .. so it puts off evaluating it as long as possible
02:13:27 <younder> doserj: I see it, I just don't understand it, a Lisp thing.. Could you explain?
02:13:37 <doserj> ski just did
02:13:37 <ski> younder : it is possible to be *too* lazy ;)
02:14:37 <younder> doserj: I see the problem. But not the solution
02:14:41 <ski> xrfang : yes, to calculate `Just x > acc' (with most normal types of `x' and `acc' anyway), you need to actually evaluate `acc'
02:14:53 <ski> (xrfang : which was not the case in `findKey', correct :)
02:14:56 <Peaker> well, any thunk buildup that eventually will be executed is probably *too* lazy
02:15:20 <ski> younder : ok, i'll give a trace, *using* the `$!' variant, ok ?
02:15:33 <xrfang> ski: thanks.
02:15:36 <ski>     myLength ['a','b','c','d']
02:15:42 <ski>   = internalCount ['a','b','c','d'] 0
02:15:51 <ski>   = internalCount ['b','c','d'] $! (0 + 1)
02:15:55 <ski>   = internalCount ['b','c','d'] $! 1
02:15:58 <ski>   = internalCount ['b','c','d'] 1
02:16:09 <ski>   = internalCount ['c','d'] $! (1 + 1)
02:16:11 <ski>   = internalCount ['c','d'] $! 2
02:16:14 <ski>   = internalCount ['c','d'] 2
02:16:15 <Peaker> ski: it starts out with (1 + ..) and counts until one prior to the last element :-P
02:16:21 <ski>   = internalCount ['d'] $! (2 + 1)
02:16:25 <ski>   = internalCount ['d'] $! 3
02:16:26 <ski>   = internalCount ['d'] 3
02:16:30 <ski>   = 3
02:16:41 <Peaker> need a @reduce plugin for lambdabot :)
02:17:00 <ski> Peaker : you are correct :), i didn't look at the details too closely
02:17:29 <ski> (but i should have noticed this, since the length of `['a','b','c','d']' shouldn't be `3' ;)
02:17:55 <ski> younder : sorry for that, i was off by one, replace the `0' by `1' above .. so you actually get `4' as final answer
02:18:00 <Peaker> that code is not pretty :)
02:18:08 <younder> I did in my code ;)
02:18:36 <younder> Peaker: what would you consider pretty code?
02:19:03 <younder> I simply filed off the corner cases and otherwise used tail recurion
02:19:03 <ski> (younder : yes .. but i mean if you actually want to check the details of my trace above, instead of just glancing it over a bit, and seeing the general pattern :)
02:19:12 <Peaker> younder: its nicer to have:   myLength [] = 0 ; myLength (_:xs) = 1+myLength xs
02:19:24 <ski> younder : don't use `| null xs' when you can match on the empty list `[]'
02:19:39 <ski>   myLength list = internalCount list 1
02:19:42 <ski>     where
02:19:45 <younder> Peaker: That just seems wrong since it is not tail recursive...
02:19:46 <ski> hm
02:19:48 <ski>   myLength list = internalCount list 0
02:19:49 <ski>     where
02:20:00 <ski>     internalCount [    ] count = count
02:20:20 <ski>     internalCount (_:xs) count = internalCount xs $! count + 1
02:20:31 <Peaker> younder: if strictness/constant space is important, I think this is the canonical way to do it: foldl' (const (1+)) 0
02:21:01 <Peaker> > foldr (const (1+)) [1..10]
02:21:02 <lambdabot>       Overlapping instances for Show ([a] -> [t])
02:21:02 <lambdabot>        arising from a use o...
02:21:08 <Peaker> > foldr (const (1+)) 0 [1..10]
02:21:09 <lambdabot>   10
02:21:15 <Peaker> > foldl' (const (1+)) 0 [1..10]
02:21:15 <younder> But in that point in Real world haskell I was not supposed to have learned that yet
02:21:16 <lambdabot>   11
02:21:21 <ski> younder : remember that "tail-recursiveness" is not always appropriate in haskell where it would be appropriate in strict languages
02:22:04 <younder> ski: You mean dynamic type languages?
02:22:05 <ski> in a strict language, it might be appropriate to write `map' in a tail-recursive fashion. not so in haskell
02:22:25 <ski> younder : no, the "static vs. dynamic typing" distinction is orthogonal to this
02:22:25 <Peaker> > foldl' (const . (+1)) 0 [1..10]
02:22:27 <lambdabot>   10
02:22:37 <ski> i mean the "strict vs. lazy" distinction
02:22:52 <younder> ahh
02:24:21 <younder> I guess I am to 'eager' in my thinking ;)
02:25:28 <younder> funny since I try to put myself in a Scheeme frame of mind where argument order is undefined, but I guess that is not enough..
02:26:53 <Peaker> younder: but if you use the pass-number-in approach, then probably:  len xs = len' xs 0 ; len' [] count = 0 ; len' (x:xs) count = len' xs $! (count+1)
02:26:56 <younder> Since my code suck. Is there a style guide to Haskell?
02:27:07 <younder> sucks
02:27:41 <doserj> Peaker: len' [] count = count, which is essentially what ski did
02:27:51 <Peaker> younder: I think the problem in that code was just the corner-casing instead of trying to unify it over a simple basis.. Writing a separate base case for 0 and 1 is unnecessary
02:28:07 <Peaker> ah oops, I didn't notice ski already wrote the nicer one
02:30:52 <younder> Peaker: could you explain the concept of corner casing?
02:31:39 <xrfang> it is said that foldr can work with infinite list, while foldl can't
02:31:43 <Peaker> younder: well, it seems your code treated 0 as a "corner case" instead of a simple base case.  Corner case is an edge case that deserves special treatment
02:31:44 <xrfang> I don't know why...
02:31:59 <xrfang> apparently I had the wrong impression that foldr "folds from the right"
02:32:00 <Peaker> xrfang: foldl can, foldl' might not be able to
02:32:14 <Peaker> > foldl (const . const $ 1) [1..]
02:32:15 <lambdabot>       Overlapping instances for Show ([b] -> [t])
02:32:16 <lambdabot>        arising from a use o...
02:32:22 <Peaker> > foldl (const . const $ 1) 0 [1..]
02:32:25 <SubStack> @pl (\a b c -> a ++ b ++ c)
02:32:25 <lambdabot> (. (++)) . (.) . (++)
02:32:25 <dolio> foldl always consumes the entire list.
02:32:31 <dolio> Even if it doesn't look at all the elements.
02:32:40 <Berengal> ?src foldl
02:32:47 <lambdabot> foldl f z []     = z
02:32:53 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
02:33:00 <dolio> (Or all the intermediate results.)
02:33:02 <da-x> you crashed lambdabot?
02:33:03 <younder> Peaker: so it causes it to push stuff on the stack? why?
02:33:21 <xrfang> so what does it mean to be able to fold "infinite" list...
02:33:31 <Peaker> @src foldr
02:33:32 <Berengal> xrfang: That's a foldr
02:33:37 <lambdabot> foldr f z []     = z
02:33:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:33:53 <Peaker> foldr is recursively called as an argument of f -- so only if f evaluates it, it recurses
02:34:07 <Peaker> foldl recursively calls itself regardless of how lazy its given functions are
02:34:22 <Peaker> younder: what pushes stuff on the stack?
02:34:43 <xrfang> ok,
02:34:48 <xrfang> tks Peaker
02:34:49 <Peaker> younder: I wasn't talking about the runtime behavior of your code - just the unnecessary extra complexity it introduced by handling multiple base cases and induction, instead of just one base case and induction
02:35:04 <Berengal> Does Haskell even have a stack?
02:35:15 <Berengal> Other than for evaluating thunks, I mean, but that's an implementation detail anyway...
02:35:29 <Peaker> Berengal: when a thunk is forced, and forces another thunk, it keeps the thunks to go back to in a stack, I think
02:35:34 <younder> Peaker so the match is done at RUNTIME! argh!
02:35:45 <Peaker> younder: what match?
02:35:45 <dolio> Does ML have a stack?
02:35:56 <younder> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2262#a2262
02:37:46 <Peaker> younder: reload it to see the nicer version
02:38:02 <younder> Sorry for my dimness, it is just that the efficiency model of Haskell is taking some time to sink in. As well as the estetic's standards.
02:38:05 <Peaker> had a firefox/website bug that it showed me the older version without the nicer one which made me paste it twice.
02:39:05 <dolio> Perhaps Haskell just makes you reevaluate your conception of what stacks are for. :)
02:39:06 <Peaker> younder: myLength computes the length of the list at runtime in either case.. Instead of having myLength do matching against 0-lengthed lists and passing 1-and-above length lists to internalCount which handles a base case of 1 and induction -- myLength can just pass all cases to internalCount which can use a base case of 0 and induction
02:39:14 <younder> Peaker: thanks
02:39:19 <Berengal> myLength = foldl' (const.(+1)) 0
02:39:50 <ski> dolio : e.g. SML/NJ has a "stack" .. only it is allocated on the heap (so `callCC' is cheap, yay !)
02:40:05 <dolio> myLength = length
02:40:08 * dolio wins
02:40:10 <ski> (cf. Stackless Python, iiuc)
02:40:14 <Peaker> younder: I think if you want an iteration on an entire list while keeping strict accumulating state (such as a counter of elements), you want foldl'
02:40:20 <Peaker> @src length
02:40:21 <lambdabot> Source not found. You untyped fool!
02:40:27 <ski> @slap lambdabot
02:40:28 * lambdabot moulds lambdabot into a delicous cookie, and places it in her oven
02:40:48 <younder> lol
02:42:47 <Peaker> ski: cf.=?
02:42:47 <Peaker> normal Python and "Stackless Python" both have Python's stack on the heap, but normal Python also keeps some of the Python stack on the C stack
02:42:52 <Peaker> each python function call induces a call in the C side too in normal Python -- so the stack is as rigid as C's stack. Stackless makes for a flexible stack
02:45:41 <dolio> Anyhow, I've been thinking about this since it's come up lately, and it seems like you could in general say that stacks are used to evaluate sub-expressions, when necessary.
02:47:07 <dolio> In languages like Lisp and so on, you always evaluate sub-expressions at the call site of functions, so the only way you can get expressions that are too deep is with non-tail recursion (or recursion in general if tail-call optimization doesn't happen).
02:47:46 <dolio> But in Haskell, that isn't the case, and you can build up things that will be too deep in other ways.
02:48:43 <dolio> Which is why you need to say "keep this evaluated" with $! and whatnot in some places.
02:51:23 <younder> dolio: THANKS!
02:51:52 <dolio> Good, that made sense. :)
02:52:09 <ski> Peaker : "cf." = "confere"(latin) = "compare (with)"(english)
02:53:52 <ski> Peaker : you are probably right. i'm not very familiar with (e.g. C)Python, so i was extrapolating from hearsay on Stackless Python :)
02:54:23 <younder> dolio: Not exacly ;) but I could infer your intent from the contex..
02:55:35 <ski> (dolio : yes, stacks are for remembering "what to do after the current job" :)
02:55:51 <ErhardtMundt> \o
02:56:43 <Peaker> ski: btw, Guido doesn't like Stackless Python because its a "platform hack" and not usable on the JVM/etc
02:58:07 <sioraiocht> @src cylce
02:58:07 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
02:58:10 <sioraiocht> @src cycle
02:58:10 <lambdabot> cycle [] = undefined
02:58:10 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
03:01:29 <younder> seems inefficent to me
03:01:40 <dolio> Does that matter? If you have a good implementation, why worry about compiling to the JVM?
03:01:50 <xrfang> @src undefined
03:01:50 <lambdabot> undefined =  error "Prelude.undefined"
03:02:13 <dolio> Unless you want to inherit its libraries, but then the code you write using that won't be portable to anything but JVM python.
03:02:19 <Peaker> younder: its efficient in ghc because naming implies sharing, so cycle xs only evaluates the (++) once, and forms a circular list structure in memory, O(N)
03:02:35 <Peaker> dolio: there's Jython, and CPython, etc
03:03:12 <dolio> Maybe I'm confused about what stackless python is. I thought it was an alternate implementation.
03:03:21 <younder> Peaker: ok
03:03:50 <younder> ahh, you are right!
03:04:48 <Peaker> dolio: yeah, and since its not portable to Jython, GvR doesn't want it in the Python language/standard
03:04:55 <younder> This is gonna take some getting used to
03:06:14 <Berengal> "cycle foo" does in fact use less memory than "foo", since foo has to point to nil at the end, but the cycled list can simply point to itself...
03:06:38 <dolio> Heh.
03:06:52 <dolio> All nils are shared, though (in GHC), so that isn't much overhead.
03:07:03 <Berengal> So if all lists in a program are cycled, there's no need for a nil and you save a word (or whatever size nil is)
03:07:05 <sinelaw> Berengal, that's a major advantage!
03:07:06 <Berengal> Right
03:07:32 <sinelaw> especially on my 13-word-memory machine her
03:07:35 <sinelaw> e
03:08:27 <Berengal> sinelaw: Glad I could help optimize :)
03:10:44 <da-x> Peaker: in Data.MList, why 'cons = mlist .MCons' or 'cons x y = mlist . (MCons x y)' don't work, when trying to replace the declaration of 'cons'?
03:11:02 <matthew-_> @tell ivanm I assume someone in the Haskell Gods is going to change things so that you can upload new versions of the graphviz package?
03:11:02 <lambdabot> Consider it noted.
03:11:08 <Peaker> da-x: btw, MList is broken (it compiles and works, but its strict rather than lazy)
03:11:16 <da-x> oh
03:11:48 <da-x> so it was there to replace lazy IO but it's not lazy so it's.. useless?
03:14:00 <ksf> someone write a browser in haskell.
03:14:16 <ksf> firefox keeps crashing on me.
03:14:53 <matthew-_> ksf: use chrome
03:15:10 <ksf> there's a linux version?
03:15:19 <matthew-_> there will be, I know the guys working on it
03:15:33 <Peaker> (I need to fix that)
03:15:33 <Peaker> da-x: lets start with: cons x = mlist . MCons x
03:15:35 <Peaker> dax: that means that:  cons x y = mlist (MCons x y)
03:15:35 <ziman> if you use flash, there's high probability it's flash what's crashing
03:15:41 <Peaker> @pl \cons x y = mlist (MCons x y)
03:15:41 <lambdabot> (line 1, column 11):
03:15:41 <lambdabot> unexpected "="
03:15:41 <lambdabot> expecting pattern or "->"
03:15:57 <matthew-_> ziman: right, and rather terrifying that that can bring down the whole of ff
03:16:03 <ksf> if it's flash that's crashing, then it's firefox 3 that started it.
03:16:07 <ksf> ...worked fine before.
03:16:31 <matthew-_> esp given the current obsession with the browser as the new OS
03:16:47 <younder> Opera works for that at least
03:17:13 <younder> (used to be a developer)
03:18:05 <dolio> Peaker: The thing about MLists is that they're, in my experience, difficult to reason about.
03:18:18 <ziman> this is also why I have turned off flash in Opera as my primary whole-day-running browser and I use firefox just for short unimportant Flash sessions.
03:18:27 <ziman> maybe this is -blah
03:18:48 <Peaker> dolio: I think its better than lazy I/O
03:19:03 <Peaker> @pl \cons x y -> mlist (MCons x y)
03:19:04 <lambdabot> const ((mlist .) . MCons)
03:19:12 <Peaker> @pl \x y -> mlist (MCons x y)
03:19:13 <lambdabot> (mlist .) . MCons
03:19:19 <dolio> Peaker: For instance, if you write a parser with them as your input stream, say, creating an MList m Char or something, where each cons holds the result of a getChar...
03:19:28 <Peaker> da-x: yeah, in its current broken state its useless.. :)
03:19:37 <Peaker> da-x: gonna fix that, though
03:19:40 <Peaker> da-x: when I have time
03:20:05 <dolio> Peaker: Then you have to make sure your parser never backtracks and tries to use the list from an earlier point. Because you won't be getting the same stream of characters.
03:20:12 <Peaker> dolio: if its getChar, you mean MList IO Char, right?
03:20:15 * ksf still doesn't get why we have that buggy flash app, not a simple library and ui wrappers around that written by someone more able to code than adobe-employees.
03:20:26 <dolio> Er, yeah.
03:20:28 <Peaker> dolio: ah -- its not meant for backtracking as in LogicT
03:20:40 <Peaker> dolio: the similarity to LogicT is coincidental
03:20:58 <dolio> Well, the backtracking would be part of the parser.
03:21:11 <Peaker> dolio: its meant to replace lazy I/O. The Monad instance is indeed hard to reason about the correctness of, in context of non-pure monads as parameters
03:21:12 <dolio> MList IO Char would be a replacement for the [Char] input.
03:21:34 <Peaker> dolio: yeah, for lazy I/O like behavior you'd want some caching layer on top of the MList
03:21:54 <dolio> Yeah, exactly.
03:22:05 <ksf> opera: xcb_xlib.c:50: xcb_xlib_unlock: Assertion `c->xlib.lock' failed.
03:22:06 <ksf> ...
03:22:16 <Peaker> dolio: though I'm not sure why I'd want to write backtracking parsers :)
03:22:36 <dolio> Lookahead.
03:22:43 <xrfang> @src Complex
03:22:44 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
03:23:12 <ksf> any parser that can parse more than one document either backtracks or looks ahead.
03:25:44 <Peaker> dolio: why would I want to parse stuff, I mean?
03:25:48 <ski> ksf : see "WWWBrowser" at the bottom of "Fudgets - Demo Form" <http://www.cs.chalmers.se/Cs/Research/Functional/Fudgets/demoform.html>
03:25:59 <younder> ksf: ? it pushes the page onto a stack..
03:26:19 <ski> (istr this was one of the first (if not the first) browser that could load images in parallel .. this was created shortly after Mosaic, iirc)
03:26:47 <younder> All browsers do that now..
03:27:00 <dolio> I don't know. Maybe you're writing a compiler?
03:27:18 <ski> (yes, i know (well, i don't think FairligHTML for the C64 does, but .. :))
03:27:19 <younder> (used to be a Opera developer)
03:27:19 <Peaker> dolio: well, I don't think I'd encode the language I'm compiling in text..
03:27:29 <Peaker> dolio: I'd just write an AST/ASG directly in Haskell and compile that
03:28:03 <ksf> hmmm... I guess I should install the qt-static version.
03:28:38 <ksf> I wouldn't be surprised if the q3-compat libraries that come with q4 aren't actually really compatible.
03:28:39 <Peaker> I think parsing is a niche problem that was blown way beyond proportions of its real importance, because of a historic mistake of encoding various rich data structures as text - where they should have been encoded in whatever way was most convenient, and had frontends to manipulate that are more friendly than a generic text editor
03:29:57 <ksf> well, parsing is a decent, total, subset of turing languages.
03:31:27 <Peaker> ksf: I think parsing is generally considered a good tool to read rich data structures from users -- I think having specialized front-end tools instead of a specialized parser is better, and that until that is made easy, just encoding Haskell data structures is a better approach
03:31:36 <younder> I have ambitios of spesifying my new language Formula-1 in Haskell, but I need to establish the neccesary competence in Haskell first, Mayby next year..
03:32:04 <younder> ambitions
03:32:54 <younder> Basically a mathematically verified functional language.
03:33:36 <younder> I was thinking of writing the spesification in Litterate Haskell (tex version).. doable?
03:36:14 <Peaker> younder: what does "mathematically verified" mean?
03:37:13 <Ferdirand> beware the halting problem :(
03:37:21 <younder> It is based on a automatic proof system called ACL2, but with support for flating point.
03:38:48 <younder> floating
03:39:19 <younder> The haling problem, by it's nature can not be solved
03:39:26 <younder> halting
03:39:51 <cedricshock> Why do neither of these work?:
03:39:56 <cedricshock> main = sequence (map (print) [1..])
03:40:02 <cedricshock> main = do sequence (map (print) [1..])
03:40:05 <Axman6> :t sequence
03:40:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
03:40:13 <Axman6> :t main
03:40:14 <Axman6> ...
03:40:14 <lambdabot> Not in scope: `main'
03:40:23 <vixey> :t sequence (map (print) [1..])
03:40:24 <lambdabot> IO [()]
03:40:25 <Axman6> ok, well anyway, main :: IO ()
03:40:31 <vixey> main :: IO a
03:40:37 <vixey> that does work
03:40:39 <Axman6> really?
03:40:51 <Axman6> hmm, thought it had to be IO ()
03:41:32 <Axman6> :t mapM_ print [1..]
03:41:33 <cedricshock> :t map (print) [1..]
03:41:33 <lambdabot> IO ()
03:41:34 <lambdabot> [IO ()]
03:42:00 <cedricshock> :t sequence (mapM_ (print) [1..])
03:42:02 <lambdabot>     Couldn't match expected type `[b]' against inferred type `IO ()'
03:42:02 <lambdabot>       Expected type: a -> [b]
03:42:02 <lambdabot>       Inferred type: a -> IO ()
03:42:33 <trofi> @src mapM_
03:42:33 <lambdabot> mapM_ f as = sequence_ (map f as)
03:42:44 <younder> Ferdirand: However if each step is proovably reductive it will terminate
03:43:27 <cedricshock> So how can I use sequence to print a list one entry at a time?
03:44:37 <Peaker> cedricshock: that does work
03:44:37 <Peaker> no need for () around print there
03:44:37 <Peaker> cedricshock: and sequence (map f xs) = mapM f xs
03:44:37 <Peaker> @src mapM
03:44:38 <lambdabot> mapM f as = sequence (map f as)
03:44:40 <Axman6> i'd use sequence_
03:46:00 <ski>   main = sequence_ (map print [1..])
03:46:00 <ski> or
03:46:01 <cedricshock> Hmm. This worked, but I had to change the type on main:
03:46:02 <cedricshock> main :: IO [()]
03:46:02 <cedricshock> main = do sequence (map print [1..])
03:46:08 <ski>   main = mapM_ print [1..]
03:46:11 <ski> or
03:46:20 <ski>   main = forM_ [1..] print
03:46:21 <ski> or
03:46:27 <Axman6> cedricshock: you had the type of main as IO () right?
03:46:27 <ski>   main = forM_ [1..] $ \n -> do
03:46:30 <ski>     print n
03:46:32 <cedricshock> yep
03:46:45 <Axman6> well that's why it was wrong, it wasn't the right type
03:47:06 <ski> (the last form resembles a "for loop" with a "body")
03:48:21 <ski> (you don't need the `do' there .. but if you add more command above of below `print n', then you do need `do' there)
03:49:06 <vixey> cedricshock: You could just not write any type annotation
03:49:14 <ski> (s/command/commands/ s/of/or/)
03:49:31 <cedricshock> Thanks for the help.
03:52:19 <beelsebob> main = putStrLn (unlines $ map show [1..])
03:54:52 <ivanm> matthew-_: good question...
03:56:58 <ivanm> who is in charge of hackage?
04:01:30 <ivanm> @users
04:01:30 <lambdabot> Maximum users seen in #haskell: 658, currently: 593 (90.1%), active: 18 (3.0%)
04:04:05 <matthew-_> ivanm: people are in charge?
04:04:18 <ivanm> matthew-_: presumably _someone_ is
04:04:24 <ivanm> though dcoutts claims it isn't him... >_>
04:05:47 <dcoutts> it's probably best if people assume there's nobody in charge ;-)
04:06:05 <ivanm> dcoutts: hhe
04:06:06 <ivanm> *heh
04:06:20 <ivanm> rather than the non-existent Haskell Cabal? ;-)
04:06:28 <trofi> :]
04:06:29 <dcoutts> well, quite
04:06:34 <ivanm> dcoutts: OK, do you know if there's any restrictions on _who_ uploads a package to hackage?
04:06:42 <matthew-_> hmmm, a bit like the kumar rouge then...
04:06:46 <dcoutts> ivanm: there is a restriction yes.
04:07:16 <ivanm> dcoutts: so who has to be told to authorise it that I know maintain graphviz and not matthew-_?
04:07:34 <dcoutts> ivanm: nobody, currently. That's not restricted.
04:07:47 <ivanm> "This server is run by a mysterious group of Haskell hackers who do not wish to be known as a Cabal, ... " <-- community.haskell.org
04:07:53 <ivanm> dcoutts: oh, as long as you have a username?
04:07:57 <dcoutts> ivanm: right
04:08:42 <dcoutts> ivanm: that'll change in the new server, there'll be per-package user groups, but delegating will be easy.
04:14:02 <ivanm> dcoutts: when can we expect this new mysterious hackage server, which is in no way tied to a non-existent shadow organisation commonly referred to as the Haskell Cabal? ;-)
04:14:28 <dcoutts> ivanm: the sooner you get hacking the sooner it'll be released :-)
04:14:33 <ivanm> heh
04:14:37 <ivanm> not my style of hacking ;-)
04:21:14 --- mode: irc.freenode.net set +o ChanServ
04:22:37 <QtPlaty[HireMe]> What is the recomended html parser?
04:22:58 <dcoutts> QtPlaty[HireMe]: a lot of people use tagsoup
04:23:14 <dcoutts> it's not strictly a parser, but it copes with messed up html
04:27:26 <romildo> Is there a shorter expression for the following:
04:27:32 <romildo> do x <- action
04:27:32 <romildo>    when x newAction
04:27:53 <romildo> maybe using some functions from the haskell libraries?
04:28:01 <vixey> when <$> action <$> return newAction I think
04:28:07 <vixey> maybe <*> instead of <$>
04:28:34 <Eridius> in your example, it's when <$> action <*> return newAction
04:29:46 <Eridius> x >>= flip when newAction
04:29:49 <voker57> @djinn a -> IO a
04:29:50 <lambdabot> Error: Undefined type IO
04:31:53 <Peaker> @undo do { x <- action ; when x newAction }
04:31:54 <lambdabot> action >>= \ x -> when x newAction
04:32:07 <Peaker> @pl action >>= \ x -> when x newAction
04:32:08 <lambdabot> flip when newAction =<< action
04:33:03 <Peaker> @. pl undo do { x <- action ; when x newAction }
04:33:03 <lambdabot> flip when newAction =<< action
04:33:26 <Berengal> Given a monad m and a transformer t, what's the easiest way to transform a value of type "t m (m a)" to "t m a" ?
04:33:50 <vixey> :t lift . join
04:33:52 <lambdabot> forall (t :: (* -> *) -> * -> *) (m :: * -> *) a. (Monad m, MonadTrans t) => m (m a) -> t m a
04:34:15 <Berengal> Hmm
04:34:19 <Berengal> @type (>>=lift)
04:34:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad (t m), Monad m, MonadTrans t) => t m (m a) -> t m a
04:34:28 <ski>   action >>= (`when` newAction)
04:34:32 <vixey> damn :p
04:34:47 <Berengal> I knew it was possible...
04:34:49 <Deewiant> ?ty lift <=< join
04:34:50 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad (t m), Monad m, MonadTrans t) => t m (t m (m a)) -> t m a
04:35:11 <ski> @type join . liftM lift
04:35:13 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t, Monad (t m)) => t m (m a) -> t m a
04:36:59 <further> hi, is there any simple function to unique the characters in a string? In another word, clear duplicate Char in [Char].
04:37:08 <Berengal> further: nub
04:37:09 <Deewiant> nub
04:37:13 <Deewiant> > nub "foo"
04:37:14 <lambdabot>   "fo"
04:37:18 <ski> > nub "i'm in my happy place"
04:37:19 <lambdabot>   "i'm nyhaplce"
04:37:31 <further> thx all! I used to use a set to do that..
04:37:39 <Deewiant> A Set might be faster
04:37:42 <Deewiant> nub is O(n^2)
04:37:51 <Deewiant> But if you don't care, just use nub. :-)
04:38:25 <Berengal> > sort $ nub "the quick brown fox jumped over the lazy dog"
04:38:26 <ski> > (map head . group) foo  where foo = sort "i'm in my happy place"  -- can be used instead, if the list is sorted
04:38:26 <lambdabot>   " abcdefghijklmnopqrtuvwxyz"
04:38:27 <lambdabot>   " 'acehilmnpy"
04:38:55 <ski> > (map head . group) foo  where foo = sort "the quick brown fox jumped over the lazy dog"
04:38:56 <lambdabot>   " abcdefghijklmnopqrtuvwxyz"
04:39:11 <Berengal> nub is also stable, unlike sets
04:39:44 <Berengal> where stable = if the first occurence of 'a' comes before the first occurence of 'b', 'a' will come before 'b' in the nubbed list...
04:39:52 <Deewiant> You can use sets to write a stable and faster-than-nub nub
04:40:02 <Berengal> How?
04:40:11 <Deewiant> ?src nub
04:40:11 <lambdabot> nub = nubBy (==)
04:40:14 <Deewiant> Gah
04:40:15 <Deewiant> ?src nubBy
04:40:15 <lambdabot> nubBy eq []             =  []
04:40:15 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:40:36 <Deewiant> Meh, I thought it did it differently so it'd be obvious how to do it with sets. :-P
04:40:49 <Berengal> Using sets is just toList . fromList
04:41:01 <Deewiant> Berengal: Keep a set of what you've seen so far as you loop through the string
04:41:55 <Berengal> O(n log n)?
04:42:47 <Deewiant> Yes.
04:43:19 <Berengal> How does it compare to toList . fromList though?
04:43:54 <Deewiant> It's stable.
04:43:56 <Deewiant> Don't know about speed.
04:44:07 * Berengal tries to whip up a test case
04:44:14 <Deewiant> There was a thread on -cafe or somewhere comparing approaches, some months ago.
04:44:22 <Deewiant> Probably -libraries, actually.
04:47:02 <younder> join #hascell-cafe
04:47:24 <Deewiant> Berengal: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/10165
04:54:29 <Berengal> Wow, some of these timings are abhorring
04:56:10 <dolio> toList . fromList is not lazy.
04:56:20 * neoswish is Now Away ( Reason: Do Not Disturb! ) Loging: On Pager: On  K.I.T.T 2005 
04:57:59 * danderson stabs verbose auto-away
04:58:21 <bremner> @slap neoswish
04:58:21 * lambdabot hits neoswish with an assortment of kitchen utensils
05:06:41 <romildo> Taking into account the naming conventions in Haskell libraries, is whenM a good name for the function below?
05:06:42 <romildo> whenM cond action = do x <- cond
05:06:42 <romildo>                        when x action
05:06:58 <Deewiant> Yep.
05:07:37 <ivanm> romildo: isn't that just liftM when ?
05:08:05 <Deewiant> Not quite.
05:08:08 <Deewiant> ?ty liftM when
05:08:09 <lambdabot> forall (m :: * -> *) (m1 :: * -> *). (Monad m1, Monad m) => m1 Bool -> m1 (m () -> m ())
05:08:30 <ivanm> oh, wait, when is in a monad
05:08:58 <ivanm> @type \ cond action -> cond >>= \ x -> when x action
05:09:00 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
05:09:26 <ziman> @redo cond >>= flip when action
05:09:26 <lambdabot> do { a <- cond; flip when action a}
05:13:09 <Botje> :t \a body -> when <$> a <*> return body
05:13:10 <lambdabot> forall (m :: * -> *) (f :: * -> *). (Monad f, Applicative f, Monad m) => f Bool -> m () -> f (m ())
05:13:26 <Botje> :t \a body -> when <$> a <*> body
05:13:27 <lambdabot> forall (m :: * -> *) (f :: * -> *). (Applicative f, Monad m) => f Bool -> f (m ()) -> f (m ())
05:13:35 <Botje> that's not it :[
05:14:13 <Deewiant> ?ty \a body -> join $ when <$> a <*> return body
05:14:14 <lambdabot> forall (m :: * -> *). (Applicative m, Monad m) => m Bool -> m () -> m ()
05:16:03 <burp_> :t <$>
05:16:04 <lambdabot> parse error on input `<$>'
05:16:11 <burp_> never saw this
05:16:16 <_dls> :t (<$>)
05:16:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:16:24 <Deewiant> It's fmap
05:16:40 <burp_> I see
05:16:49 <burp_> :t (<*>)
05:16:50 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:22:39 <romildo> The use of the return function in the expression
05:22:39 <romildo>    when <$> a <*> return body
05:22:39 <romildo> looks "ugly", so I will not use it as a replacement for the occurrences of
05:22:39 <romildo>    do x <- a; when x body
05:22:39 <romildo> in my program. I did not like it.
05:23:39 <Botje> whenM is probably better ;)
05:40:21 <Raevel> sml at school, solution: code in haskell and convert
05:41:05 <wli> Raevel: How do you deal with it when required to code in the fully functorial style?
05:41:08 <Berengal> Raevel: That's how I got my A
05:41:29 <roadwarrior> can one use guards in case expressions? eg. case test of <19 -> ... ?
05:41:51 <Axman6> yep, i believe so
05:41:51 <da-x> cabal stores arch-specific binaries under ~/.cabal/bin. It's a problem - I cannot work from multiple architectures on the same homedir. Is there a workaround for that?
05:41:54 <doserj> case () of () | test < 19 _>
05:42:34 <Berengal> Haskell could use a cond statement...
05:42:35 <dcoutts> da-x: yes, you can include the $arch in the libsubdir
05:42:44 <dcoutts> da-x: you can set it in the ~/.cabal/config
05:43:01 <da-x> okay, thanks
05:43:07 <Raevel> wli: what is that?
05:43:48 <roadwarrior> hm intriguing :p
05:43:57 <roadwarrior> thanks doserj
05:44:04 <wli> Raevel: They must not be getting very SML-specific.
05:44:15 <Botje> cond x cases = snd . head . filter (($x) . fst) (cases++[(const True, error "cond failed")])
05:44:20 <Botje> no biggy :P
05:44:31 <Raevel> wli: it's not an sml class, so probably not
05:44:53 <zbrown> has anyone read Lambda-Calculus and Combinators: An Introduction by Hindley & Seldin. Is it worth investing in? It seems relatively new and it got a few good reviews from some people at INRIA but I'm looking for more... human-level overviews of it :)?
05:46:15 <dcoutts> da-x: got it working?
05:46:16 <SamB> zbrown: you could check amazon.com ;-P
05:47:18 <younder> zbrown: Not from what I have heard, note that I haven't actually read it. Just read the reviews on Amazon.com
05:47:24 <crem> What is the priority of function application and of dot operator? Why   f . g h . k   is   f . (g h) . k  but not   f . g (h . k)  ?
05:48:13 <bremner> function application is highest
05:48:15 <SamB> application binds tightest
05:48:29 <crem> always? with any operator?
05:48:37 <SamB> yes! tightest!
05:48:39 <crem> thanks
05:49:11 <SamB> I didn't just mean tighter ;-)
05:49:16 <Raevel> my code got so much prettier when i realized that
05:50:10 <zbrown> younder: there's no reviews sadly
05:50:13 <zbrown> SamB: ^^
05:50:44 <da-x> dcoutts: well, I inserted '/$arch' into remote-repo-cache in config but when I did cabal update it created a dir named '$arch' instead of 'x86_64' or whatever..
05:51:18 <zbrown> younder: in that case though, if not that text, do you know of a book (or two) taht covers these topics in a sufficiently introductory level. I'd prefer a book to a website.
05:51:24 <cognominal> how do overcome that problem : "hidden package"?  http://hackage.haskell.org/packages/archive/HaXml/1.19.3/logs/failure/ghc-6.10
05:51:38 <SamB> da-x: aren't those files just sources anyway?
05:52:13 <SamB> cognominal: hackage isn't so good at building stuff
05:52:25 <SamB> the average 5-year-old could probably do better
05:52:38 <SamB> wel, maybe 9-year-old
05:52:47 <SamB> (how old do you usually have to be to read?)
05:52:54 <da-x> SamB,dcoutts: Yes, but for better control, I want to have two independent .cabal hierarchies, i.e. .cabal/i386 and .cabal/x86_64
05:53:00 <Botje> fluid? eightish
05:53:12 <Botje> nine is a nice round number
05:53:26 <SamB> visually or arithmatically ?
05:53:29 <cognominal> well, in respect to haskell, I feel like a 2 years old :)
05:53:48 <younder> me too
05:54:09 <SamB> cognominal: don't sweat it if hackage doesn't build your stuff -- it's probably just hackage being dumb in picking dependencies or something ;-)
05:54:50 <cognominal> Well I am using cabal and get the same result
05:55:05 <SamB> okay, now that's something you can reasonably hope to fix ;-)
05:55:19 <dcoutts> da-x: for what extra control?
05:55:49 <dcoutts> da-x: the package dbs will all be separate. You can also set the binary names or bindir to contain the arch
05:56:20 <cognominal> could thus be that I have polyparse versions later than 1.1?
05:56:26 <cognominal> *this
05:56:39 <SamB> cognominal: it looks like something changed between polyparse 1.1 and 1.3, from that log
05:56:56 <SamB> and the package isn't specific enough about what version it requires
05:57:11 <cognominal> good
05:57:35 <SamB> you should probably email the maintainer
05:58:06 <malcolmw> cognominal: if you alter the HaXml .cabal file to say build-depends: polyparse-1.1 instead of just polyparse, then it should work
05:58:06 <SamB> and possibly also the polyparse maintainer
05:58:09 <cognominal> of polyparse or haxml?
05:58:15 <da-x> dcoutts: alright, I guess that .cabal/packages can be left alone
05:58:23 * malcolmw maintains both HaXml and polyparse
05:58:35 <SamB> malcolmw: oh, right ;-)
05:58:58 <SamB> I hadn't fully realized what package was failing to build here ;-)
05:59:07 <Botje> question that just came up: can you guys devise a use case for an IO transformer?
05:59:21 <SamB> Botje: a WHAT?
05:59:25 <edwardk> Botje: its not a well defined monad transformer
05:59:35 <malcolmw> cognominal: of course, the other possible solution is to install versions polyparse-1.2 and HaXml-1.19.7 instead
05:59:39 <cognominal> woo, that's realtime feedback
05:59:47 <Botje> SamB: we're discussing monad transformers in class
05:59:57 <edwardk> Botje: IOT SomeMonad a fails to be a monad for many many monads
05:59:59 <SamB> Botje: how about confusing the heck out of everyone
06:00:03 <Botje> and the teacher asked me if there would not be a use case for a IO monad transformer
06:00:29 <cognominal> ho, I always forget todo a cabal update
06:00:32 <edwardk> botje: IOT STM a -- for instance kind of defeats the purpose =)
06:00:36 <Botje> don't shoot the messenger! :P
06:00:52 <Botje> edwardk: ah, that makes sense
06:01:07 <Botje> do you know of others or a reference i can follow?
06:01:55 <quicksilver> you might look at Maybe, which is the simplest case
06:02:17 <edwardk> well in general you 'peel off a monad transformer' with some runFoo, the appropriate runIO would have to be some variant of unsafePerformIO
06:02:21 <quicksilver> compare IO (Maybe a) --- a.k.a MaybeT IO a with Maybe (IO a) --- a.k.a IOT Maybe a
06:03:46 <quicksilver> well, is that really true?
06:03:48 <quicksilver> surely
06:03:50 <edwardk> botje: look at any monad that doesn't have a correct transformer variant. ST s, STM, [], -- IOT can't be a monad transformer in general because those don't mesh with it
06:03:55 <quicksilver> runIOT :: IOT m a -> m (IO a)
06:03:56 <pozic> In a module where I use DisambiguateRecordFields, I have f (foo :: MyType), and still it complains that it doesn't know which one I mean. Why is that?
06:04:04 <wli> Botje: Ah there's some code for you...
06:04:24 <Botje> thanks so far, i'll forward your responses :)
06:04:42 <edwardk> quicksilver: sure, you can carry around a monadic IO value in any monad, but you can't interleave the results.
06:05:05 <quicksilver> edwardk: yes, but I question your introduction of unsafePerform ;)
06:05:13 <quicksilver> edwardk: my type signature follows the general pattern.
06:05:15 <edwardk> liftIO :: IO a -> IOT m a -- for that does what?
06:05:29 <edwardk> liftIO = return?
06:05:31 <quicksilver> then to answer the spirit of Botje's question you have to find out why that's not very useful.
06:05:47 <SamB> quicksilver: could you implement Monad for that ?
06:05:57 <edwardk> samb: thats the problem
06:06:04 <quicksilver> SamB: that's the correct question :)
06:06:14 <quicksilver> SamB: I'm trying to pose the right question here, I'm not trying to give the answer.
06:07:00 <edwardk> botje: anyways take quicksilver's IOT, and apply it to [], and then check the associativity of the result
06:07:17 * edwardk gives away the punchline
06:07:23 * edwardk is no fun at cocktail parties, either.
06:08:16 <Botje> edwardk: okay. i'll try to work it out myself first ;)
06:08:24 <wli> Botje: http://wli.pastebin.com/m4f93b1a6 <-- novel use of ReaderT with ContT, with StateT and WriterT in the mix for good measure.
06:09:04 <Botje> loading .. :)
06:09:58 <pozic> wli: I am tempted to press the report abuse button.
06:10:19 <wli> pozic: w0t?
06:11:06 <Botje> wli: i think i'm going to have nightmares about that
06:11:34 <xrfang> hi there...  can haskell (ghc) produce dynamic link libraries either for linux or windows?
06:11:42 <wli> Botje: Why?
06:12:26 <mlesniak> Is there some obvious way (I've overlooked) to show a UTCTime, got by getCurrentTime from Data.Time.Clock?
06:12:39 <doserj> xrfang: http://blog.well-typed.com/2009/04/first-round-of-ihg-development-work/
06:13:15 <therp> shared libraries again...
06:14:05 <quicksilver> mlesniak: yes, use 'show'
06:14:07 <quicksilver> mlesniak: *rimshot*
06:14:13 <quicksilver> mlesniak: (instance in Data.Time.Format)
06:14:42 <mlesniak> quicksilver: UTCTime does not define Show ... ah, in Data.Time.Format :D
06:14:59 <xrfang> doserj: tks... the reason I ask this is that I am thinking of a "plugin" system for a project... I have done a prototype in java, now consider use haskell just for learning haskell.
06:15:01 <mlesniak> quicksilver: I was totally irritated: docs say it defines show, but sources show no sign of it :D
06:15:01 <quicksilver> orphan instances are rather confusing.
06:15:13 <Botje> wli: i'm trying to grasp it :)
06:15:14 <quicksilver> haddock could be a bit cleverer and show you where orphan instances come from
06:15:53 <xrfang> I wonder, doing that in haskell has any real benefit than doing it in java... if I describe that project, can anybody give me some advide on "is there any benefit using haskell instead of java to do it"?
06:16:00 <mlesniak> quicksilver: definitely. Thanks for the hint
06:16:20 * bremner thinks the "why shared libs" explanation misses the concept of smoother distro upgrades.
06:16:27 <fasta> xrfang: your plugins in Haskell will be rather big.
06:16:39 <bremner> xrfang: sure, but you have to factor out our bias against java
06:16:54 <xrfang> well. I will describe the system here. if anybody think it is offtopic, just let me know :)
06:17:07 <wli> Botje: It keeps the exit continuation in the ReaderT env.
06:17:10 <xrfang> the project is a "back-test platform" for stock trading system
06:17:39 <fasta> xrfang: and probably there is more infrastructure to do plugins in Java, whereas in Haskell there is hs-plugins which I think has bitrotted.
06:17:47 <xrfang> it has several models: Market as a collection of Tradables, while Tradables represents stock or product you can trade...
06:18:15 <xrfang> you also have a Portfolio class, which uses a Strategy class to decide to buy or sell some stocks.
06:18:51 <Botje> wli: yeah. i'm trying to figure out where it gets passed to the runReaderT
06:18:54 <xrfang> the Market class is a producer of data and Portfolio is the consumer of data, in a publisher-subscriber pattern
06:18:58 <xrfang> that's all
06:19:25 <Botje> is that what the callCC does?
06:19:29 <xrfang> it is very "time based", like a "state machine" I wonder if doing that in haskell is better or not...
06:19:58 <wli> Botje: Yeah, callCC does it.
06:20:03 <xrfang> the "plugin" I am thinking of is just to put some class file for a particular Strategy, and the program will pick up strategies from a folder and test them...
06:20:10 <xrfang> that's all for the project
06:20:21 * SamB wonders where he can find somebody to proofread his fleshing-out of vm86(2)
06:20:46 <Botje> is the lift . lift . tell needed?
06:21:01 <Botje> shouldn't tell just work? as it's defined on MonadWriter w m a
06:21:13 <wli> Botje: Yeah, tell doesn't typecheck without it.
06:21:19 <Botje> brr :)
06:24:30 * SamB for some reason finds the path sysdeps/unix/sysv/linux/i386/sysdep.h amusing
06:25:20 <bremner> sounds like something from SCO
06:25:52 <wli> Botje: ContT doesn't commute with much of anything, so the two lifts are to hoist it past the two of those. exit only needs to hoist past ReaderT.
06:26:02 * SamB is surprised to read in that file that most unixes use the carry flag to signal errors from system calls -- didn't know they had so much in common with DOS!
06:26:33 <SamB> bremner: I suspect it might just be there because Linux uses the System V ABI
06:26:46 <SamB> -- at least, that's what most userspaces use ;-P
06:26:50 <wli> SamB: Well, some of it.
06:26:54 <Botje> wli: okay, i think get the general gist of it
06:27:08 <Botje> funny how the actual monadic part is only five lines :)
06:27:59 <wli> Botje: That's Haskell for you. ;)
06:28:05 <SamB> wli: well, yeah, it's a big thing
06:28:08 <Botje> heh heh
06:28:13 <SamB> you can hardly expect to use all of the System V ABI
06:28:27 <xrfang> bremner, fasta... any comments about java vs. haskell for my project?
06:28:42 <SamB> but it uses the calling convention, at least (on i386 anyway)
06:28:42 <Botje> xrfang: use whichever you know best
06:28:45 <p_l> SamB: Linux generally follows SystemV these days, and there isn't much that got left out that is still in POSIX
06:28:55 <fasta> xrfang: see Botje
06:29:07 <wli> SamB: I've complained when new violations got institutionalized.
06:29:33 <Botje> if there are no time constraints i'd say implement it in both, compare them, and write a nice blog post :]
06:29:38 <Axman6> ok, replacing drive now. bbiab peeps
06:30:01 <xrfang> Botje : this is not what I expected :) I of course know that answer... my purpose, is to ask what kind of problem haskell is better... I believe haskell is not good at all problems, so is java...
06:30:10 <wli> Botje: Probably the last big observation to make is that the thing infinite loops via rep but backs out with the ContT exit continuation.
06:30:14 <SamB> I'm not familiar with either the System V or Linux ABIs for other architectures, so I didn't want to make any claims about them ;-)
06:30:59 <Botje> xrfang: i find I have to do less work in haskell to keep my code clean and clear
06:31:07 <Botje> wli: that i spotted :)
06:31:27 <Botje> wli: why didn't you do runWriter too?
06:31:34 <xrfang> Botje: I am surprised to hear that in a haskell channel ;)
06:31:58 <Botje> xrfang: if you ask in #java, they'll tell you to use java, probably
06:32:10 <xrfang> haha,
06:32:17 <Botje> if i had any experience witth big java systems i'd tell you about those
06:32:31 <xrfang> I am discussing with my friend what is the real benefit of haskell, or FP in general, hence the question
06:32:33 <wli> Botje: I presumed some callers would want to throw away the execution log (in fact most callers). Some might want the history (I did when debugging) so I gave the option of doing something with it.
06:32:53 <SamB> wli: you wouldn't happen to know offhand which files in glibc I should look at to see how it makes system calls, would you?
06:32:56 <Botje> wli: ah. interesting.
06:33:05 <SamB> on i386
06:33:07 <SamB> I mean
06:33:08 <Botje> i'll keep that in mind next time i stack some monads together :)
06:33:16 <xrfang> Botje: the question could be wider or, polymophic: compare (FP a) => a with (Imperitive b) => b :)
06:33:17 * SamB meant to include that in the question
06:33:41 <kadaver> eevrytime i try to do soemthing in Java i want to blow my head off once i toucht he classpath
06:33:44 <Botje> xrfang: you can't compare them because (==) :: Eq a => a -> a -> Bool :P
06:33:56 <SamB> wli: I'm printing out the file I mentioned above, as well as syscall.S in the same directory
06:34:02 <wli> SamB: There basically aren't any. The useful stuff for that got ripped out of kernel headers and userspace has to cook up everything from scratch.
06:34:16 <Botje> xrfang: if you really want to find out, write both systems and compare the code
06:34:23 <Peaker> (==) doesn't compare apples to oranges :)
06:34:27 <SamB> wli: I said in glibc!
06:34:29 <xrfang> ok, :)
06:34:54 <wli> SamB: In glibc I'm not sure. I only really know the kernel.
06:35:02 <SamB> the info file has this to say:
06:35:28 <SamB> That protocol is not defined by any strong authority, but we won't describe it here either because anyone who is coding `syscall' probably won't accept anything less than kernel and C library source code as a specification of the interface between them anyway.
06:35:36 <xrfang> apples an oranges are both fruit ;)  they cannot be compared on botanic level, but could be compared in a restaurant menu or by a nutritionist ...
06:35:58 <SamB> wli: ah, okay then! just checking.
06:36:23 <Peaker> SamB: if you want to know how syscalls are made, why not just look at the assembly generated?
06:36:27 <Botje> xrfang: write both, compare the code
06:36:38 <Botje> there will be some pieces haskell does really well, and some pieces java does really well
06:36:49 <SamB> Peaker: I figured it would be easier to read the assembly source code, since that has comments ...
06:36:57 <Botje> the language which does the least things very badly is the winner in my book :P
06:37:14 <Peaker> SamB: its easy enough to figure out objdump's output, that's what I did last time I needed to call syscalls from asm
06:37:33 <Peaker> SamB: though I just needed it for a q&d hack at the time
06:38:50 <SamB> Peaker: anyway, I don't want to call them, I'm actually trying to read enough kernel source to document vm86(2)
06:40:33 <SamB> and I'm a bit unsure about some things at the boundary
06:41:07 <wli> Botje: Haskell must be taking major hits on the module system front by that metric.
06:41:30 <SamB> actually, I don't see why I should need to read this stuff ... I may be very confused, on reflection ...
06:41:31 <Berengal> I tried googling a bit but found no references to persisting closures in Haskell. As far as I know this isn't possible.
06:41:34 <Peaker> virtual-8086 mode? ouch
06:41:40 <Berengal> Is this true?
06:41:41 <Botje> wli: and the numeric tower front.
06:42:02 <wli> Botje: No doubt.
06:42:14 <Peaker> Berengal: its possible in theory, but I don't think its possible in ghc
06:42:40 <Botje> and the eastern front
06:42:44 <Botje> waaaiit .. :P
06:42:59 <Berengal> When I asked about this before the only suggestion I got was to use datastructures
06:43:03 <SamB> Peaker: why ouch ?
06:43:24 <Peaker> SamB: Intel architecture is one big ouch. So much complexity for backwards compatibility
06:43:29 <Berengal> What's the prefered way to suggest this to the ghc developers?
06:43:40 <SamB> Peaker: ah, yeah, true
06:43:46 <Peaker> Berengal: I think to support it in ghc would be a lot of effort
06:43:49 <Botje> Berengal: present a proof of concept! :)
06:44:12 <edwardk> @seen pumpkin
06:44:13 <lambdabot> pumpkin is in #haskell-blah, #haskell-in-depth, #ghc and #haskell. I don't know when pumpkin last spoke.
06:44:26 <Peaker> Berengal: and there are issues like how to persist stuff like file descriptors/etc the closure refers to directly or indirectly
06:44:48 <SamB> Peaker: the one thing about virtual-8086 mode I think is truly ouch, though, is that some instructions silently fail instead of generating GPFs
06:45:22 <Berengal> Peaker: Yeah, not everything is persistable, but surely this holds true for other things such as lists as well?
06:47:13 <wli> Peaker: Perhaps ARM netbooks will lead the way.
06:47:13 <Peaker> SamB: why do you need v8086 mode? Why not run an emulator?
06:47:13 <Peaker> SamB: I think new CPUs are so much faster than 8086 was, that they could drop hw support for v8086 mode and just have everyone use emulators
06:47:32 <Berengal> I mean, Haskell is a functional language. Being able to push functions to files or over the network would be really awesome
06:47:49 <quicksilver> Berengal: there have been distributed haskell effors in the past, but they bit rotted.
06:47:57 <edwardk> peaker: yeah
06:48:07 <quicksilver> it's obviously not interesting enough to enough people.
06:48:10 <Berengal> quicksilver: You have some references?
06:48:24 <quicksilver> http://www.macs.hw.ac.uk/~dsg/gdh/
06:48:30 <Peaker> Berengal: well, memory and disk are pretty similar, so asking a platform/runtime to move stored data from memory to disk and back later shouldn't be that difficult.  It would cause a "time gap" that may mean various external resources have gone away (though that can happen during a normal run as well)..
06:48:31 <edwardk> quicksilver: what about the current holumbus stuff?
06:48:32 <SamB> Peaker: well, the emulator in DOSEMU is supposed to implement almost the same interface ... hmm, maybe I should read that ;-)
06:48:44 <SamB> though that's longer than the relevant kernel code
06:49:04 <SamB> Peaker: anyway, it just bothers me how empty the vm86(2) manpage is!
06:49:45 <Peaker> Berengal: moving code between machines may require transparent network references and more complicated mechanisms, though I believe it should be just as possible in theory
06:49:47 <xrfang> > sum [1,2,3]
06:49:48 <lambdabot>   6
06:49:57 <xrfang> > (sum [1,2,3]) / 3
06:49:58 <tromp> perfect!
06:49:58 <lambdabot>   2.0
06:50:03 <quicksilver> Berengal: also this has relevant points : http://www.haskell.org/pipermail/glasgow-haskell-users/2009-April/017120.html
06:50:15 <quicksilver> edwardk: never heard of it.
06:50:16 <xrfang> > (sum [1,2,3]) / (length [1,2,3])
06:50:17 <lambdabot>       No instance for (Fractional Int)
06:50:17 <lambdabot>        arising from a use of `/' at <i...
06:50:37 <opqdonut> xrfang: you need to use fromintegral
06:50:47 <trofi> :t genericLength
06:50:48 <lambdabot> forall b i. (Num i) => [b] -> i
06:50:52 <xrfang> opqdonut: which parameter
06:51:05 <Botje> Peaker: Mozart seems to manage
06:51:16 <Botje> and as far as i can see they're based on graph reduction too
06:51:20 <trofi> :t genericDrop
06:51:21 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
06:51:39 <quicksilver> Botje, Peaker : there are literally hundreds of projects which do it
06:51:46 <quicksilver> no one disputes the possibility :)
06:51:57 <quicksilver> the question is if *haskell* can do it.
06:51:59 <Berengal> Peaker: Once you've got the write to disk part in order, pushing it through a network device shouldn't be harder. It maybe more complicated to do it as easy as simply writing a file, but it can't be more complicated than just sending the file in the first place
06:52:05 <xrfang> > let a = [1,2,3] in (sum a) / fromIntegral(length a)
06:52:06 <lambdabot>   2.0
06:52:20 <quicksilver> Berengal: the network part is much harder.
06:52:29 <quicksilver> Berengal: what if the remote end has different versions of packages?
06:52:32 <trofi> > let a = [1,2,3] in (sum a) / genericLength a
06:52:34 <lambdabot>   2.0
06:52:37 <quicksilver> Berengal: what if it is a different architecture?
06:52:39 <xrfang> opqdonut: why we need fromIntegral?
06:52:40 <bremner> Botje: Mozart uses a virtual machine
06:52:44 <quicksilver> but, these are solvable problems.
06:52:49 <trofi> :t (/)
06:52:50 <lambdabot> forall a. (Fractional a) => a -> a -> a
06:53:01 <Botje> yeah, that's true..
06:53:07 <Botje> haskell works on the bare metal
06:53:08 <quicksilver> xrfang: because length returns an integer but (/) works on Fractionals.
06:53:13 <xrfang> trofi: you are telling me that?
06:53:14 <Botje> would make it a bit harder then >:)
06:53:25 <xrfang> but if I do: (sum [1,2,3]) / 2
06:53:33 <trofi> :t 2
06:53:34 <lambdabot> forall t. (Num t) => t
06:53:35 <Berengal> quicksilver: Yes, that's true, but those problems are there when you write to file as well (although less prevailent)
06:53:36 <bremner> Botje: F# could do it :-)
06:53:37 <xrfang> I don't need: (sum [1,2,3]) / fromIntegral(2)
06:53:42 <xrfang> hehe
06:53:51 <trofi> 2 is polymorphic :]
06:53:52 <xrfang> :t length
06:53:53 <lambdabot> forall a. [a] -> Int
06:54:09 <Berengal> It seems like a universal serialization protocol is in order
06:54:25 <Botje> can we use lambdacats images?
06:54:26 <xrfang> why it cannot "infer" that Int is acceptable while it needs a "Fractional"?
06:54:44 <quicksilver> Berengal: the suggestion that was being made was just dump the in-memory format to a file.
06:54:49 <EvilTerran> xrfang, er, because Int isn't Fractional?
06:55:00 <quicksilver> Berengal: that will work, but relies on the precise versions and memory layouts and architecures of the packages loaded.
06:55:06 <xrfang> :t Fractional
06:55:07 <lambdabot> Not in scope: data constructor `Fractional'
06:55:19 <EvilTerran> Fractional is a typeclass
06:55:23 <quicksilver> xrfang: (/) is for fractional division. Ints can't be fractions.
06:55:26 <Athas> I am having trouble expressing a type:  data ERef m = forall e t. (Event e t) => ERef e.  The intention of this type is to express any e that can be instantiated for the Event class along with some t.  Is that correct?
06:55:30 <tromp> @let sumdiv n = sum [i|i<-[1..n-1], n `mod` i == 0]
06:55:30 <Berengal> quicksilver: Yeah, that's the easy way out. If it works, great, but if it doesn't, which is most of the time, we need something that solves the other problems
06:55:31 <lambdabot>  Defined.
06:55:33 <quicksilver> xrfang: there is `div` for integer division.
06:55:34 <xrfang> well Int is a special type of Fractional if you ask me ..
06:55:39 <tromp> > sumdiv 28
06:55:40 <EvilTerran> xrfang, how?
06:55:40 <lambdabot>   28
06:55:43 <xrfang> quicksilver, I don't want that I want /
06:55:47 <xrfang> sorry brb
06:55:47 <quicksilver> Berengal: Right. I'm not saying these problems are insoluble; they've been solved many times.
06:55:52 <quicksilver> Berengal: in many contexts.
06:56:04 <quicksilver> Berengal: I was just disagreeing with the assertion that network is no ahrder than file :)
06:56:20 <quicksilver> xrfang: then, unfortunately, you are wrong.
06:56:37 <quicksilver> xrfang: Fractional means the type can store fractional quantities. That is precisely what Int cannot do.
06:56:42 <trofi> and what type should be of sum [Int] / Int ?
06:57:32 <Berengal> quicksilver: Well, it seems we had slightly differing assumtions then. I assumed pushing to a file would be hard because of mentioned problems
06:57:49 <quicksilver> Berengal: sure. Somebody else suggested just dumping the in-memory representation to disk.
06:57:55 <quicksilver> Berengal: that can of course work, with a little care.
06:57:56 <Berengal> quicksilver: It would work fine sometimes and more often than over a network, but not all the time
06:58:12 <quicksilver> edwardk: it's not clear to me that Holumbus can serialise lambdas.
06:58:22 <quicksilver> edwardk: looks like it just transmits things which are instances of Binary, or something.
06:58:28 <quicksilver> (which is fair enough, but doesn't solve the problem at hand)
06:59:50 <Peaker> in Python I experimented with serializing the bytecode and sending it over the network, excluding any references to the outside world
07:00:54 <quicksilver> I think it's quite hard to do this correctly in a way which preserves GHC's optimisations.
07:01:21 <quicksilver> It may be you would choose to keep around a slightly more patchable format (like ghci's bytecode) for the purposes of network thunks.
07:01:28 <quicksilver> I'm not sure, though. I haven't thought about it very hard.
07:01:45 <Berengal> Yeah, it seems like it would be easier to serialize bytecode
07:02:14 <Berengal> Currently there's no more "haskell" left in a program after it's compiled. We'd basically be pushing machine code around
07:02:45 <Berengal> I'd be happy with pushing bytecode to be interpreted though
07:03:39 <Berengal> Unfortunately, I'm way too dumb to figure this out myself...
07:03:43 <quicksilver> in principle, machine code has a name.
07:03:48 <quicksilver> you wouldn't push the machine code itself
07:03:54 <quicksilver> but the name of the closure.
07:04:11 <quicksilver> however I'm not sure how easy it is to do that. the names are erased by compilation ;)
07:04:25 <Peaker> re-compile it at the other end
07:04:25 <Peaker> allow for it to be a different architecture
07:04:36 <Berengal> Peaker: Bytecode allows for that
07:04:44 <quicksilver> you don't need to re-compile it if you just send the name
07:04:55 <Berengal> Well, there could be infinitely many closures
07:05:00 <quicksilver> you "know" that the far end has its own compiled copy which alswo contains a closure with that name.
07:05:03 <quicksilver> Berengal: not so.
07:05:06 <Berengal> zipWith ($) (+) [1..] for example...
07:05:08 <quicksilver> Berengal: take a look at the assembly that GHC generates.
07:05:32 <quicksilver> finitely many closure names.
07:05:35 <Berengal> (repeat (+))
07:05:39 <quicksilver> different possible instantiations of the arguments, of course.
07:05:54 <quicksilver> arguments - free variables
07:05:55 <Berengal> Ah, right, like that
07:06:01 <Berengal> Yeah, I can see that
07:06:11 <Berengal> But that means both ends needs the same closures
07:06:15 <quicksilver> definitely.
07:06:26 <quicksilver> they'd have to both be "the same program"
07:06:32 <quicksilver> or at least, have a common subset of modules.
07:06:50 <quicksilver> GHC doesn't generate any code at runtime.
07:06:57 <quicksilver> and a closure is just a pointer into a CODE segment
07:07:04 <quicksilver> so there are finitely many possible closures :)
07:07:12 <Berengal> Yeah, and while useful, you couldn't do funky stuff like send a list and a comparison function to a supercomputer to get a sorted list in return...
07:07:38 <quicksilver> yes, that's a more difficult twist :)
07:07:56 <Berengal> That means sending actual code over the pipe
07:08:01 <quicksilver> distribution where it *isn't* the case that both ends were compiled from the same source.
07:08:22 <Berengal> Hmm...
07:08:50 <quicksilver> then you're back to bytecode.
07:08:58 <quicksilver> but it feels ugly for a GHC-compiled program to include itself "twice"
07:09:00 <Berengal> If we were to go the portable bytecode route, compiled ghc would have to know what it's bytecode looks like
07:09:06 <quicksilver> once in optimised form and once in bytecode
07:09:10 <Berengal> And, yes, that means including itself twice...
07:09:22 <quicksilver> or, just including bytecode, and doing the optimisation / native code JIT.
07:09:31 <quicksilver> which involves bundling a big chunk of the compiler with the code.
07:09:39 <Berengal> Or a separate runtime
07:09:55 <Berengal> Which suddenly becomes a huge project, even for serializable closures
07:10:27 <quicksilver> Yes, I think it's a substantial project :)
07:10:41 <quicksilver> whichever way you play it.
07:10:41 <Peaker> can lambdabot tell the fixity of stuff?
07:10:51 <quicksilver> don't think so.
07:12:12 <Berengal> Closures are problematic...
07:12:34 <Berengal> But sending maps of function names to arguments just isn't going to cut it...
07:13:19 <Berengal> Sometimes I'm really envious of erlang...
07:17:18 <Athas> I believe I am in over my head: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4360#a4360
07:17:58 <Athas> It works if I replace the arbitrary t with a specific type.
07:17:59 <kpreid> Athas: Ref (42 :: Integer)
07:18:30 <byorgey_> Athas: the problem is that '42' could have many different types
07:18:48 <byorgey_> and type classes are open, so GHC can't just assume that since there is only an instance for Integer String, that 42 must be an Integer
07:18:57 <byorgey_> because there could be another instance of MyClass in another module, say
07:19:13 <quicksilver> it's not just because it's a number, either
07:19:19 <xrfang> quicksilver: what I meant is that Num => Fractional => Int
07:19:29 <quicksilver> xrfang: Ints are not Fractional.
07:19:31 <xrfang> i.e. Int is a "subtype" of Fractional
07:19:42 <quicksilver> xrfang: no, it's not.
07:19:46 <xrfang> that's not haskell term, but logically that should be "infered"...?
07:19:47 <Athas> Oh, right.
07:19:57 <quicksilver> xrfang: Ints are not Fractional because Ints cannot contain fractions.
07:20:10 <Berengal> Fractionals can represent fractions of integers. Integers can't do that...
07:20:29 <xrfang> we say Fractional is larger than int
07:20:37 <byorgey_> A is a subtype of B if A can be used anywhere a B is expected.  Ints can't be used anywhere a Fractional is expected, because Fractional requires division to be supported
07:20:38 <xrfang> or , Float is "larger" than int
07:20:39 <quicksilver> you should be very careful.
07:20:49 <quicksilver> Fractional is a class, Int is a type.
07:20:50 <xrfang> just like while there is a need for Num a , I can use Int
07:20:57 <quicksilver> so "Fractional is larger than Int" is a bit confusing.
07:21:03 <doserj> xrfang: look at the class definition of Fractional and think how you would implement the various methods
07:21:05 <xrfang> can't we say while there is a need for "Fractional a" we can use Int
07:21:09 <quicksilver> "Float is larger than Int" makes sense.
07:21:10 <quicksilver> xrfang: No.
07:21:23 <xrfang> :t Fractional
07:21:24 <lambdabot> Not in scope: data constructor `Fractional'
07:21:25 <quicksilver> xrfang: because, when there is a need for Fractional a, that means there is a need for storing fractions.
07:21:28 <doserj> @src Fractional
07:21:29 <lambdabot> class  (Num a) => Fractional a  where
07:21:29 <lambdabot>     (/)             :: a -> a -> a
07:21:29 <lambdabot>     recip           :: a -> a
07:21:29 <lambdabot>     fromRational    :: Rational -> a
07:21:34 <quicksilver> xrfang: Int cannot store Fractions.
07:21:41 <quicksilver> xrfang: so, Int does not satisfy this need.
07:21:51 <byorgey_> xrfang: you are thinking of languages which have autoconversion; in those languages you could use an Int and it would be automatically converted to some fractional type.
07:21:55 <byorgey_> Haskell doesn't do that.
07:22:16 <byorgey_> you must do the conversion explicitly yourself.
07:22:31 <byorgey_> Ints can be *converted to* (i.e. included in) the set of Fractional types, but Ints *are not* Fractional.
07:22:32 <xrfang> byorgey_: but what do you think (Num a) => a is?
07:22:48 <byorgey_> xrfang: it is a value of any type which supports the Num operations.
07:23:19 <quicksilver> xrfang: maybe you are confusing "Int" and "Numeric literal" ?
07:23:20 <xrfang> Franctional is a Num type right?
07:23:23 <quicksilver> > 1 / 42
07:23:24 <lambdabot>   2.3809523809523808e-2
07:23:28 <xrfang> a class type belongs to Num...
07:23:31 <quicksilver> ^^ in that expression, 42 is not an Int.
07:23:39 <quicksilver> in that expression, 42 is a Double, in fact.
07:23:41 <byorgey_> xrfang: not quite.  Any type which is an instance of Fractional must also be an instance of Num.
07:23:43 <Athas> Now I get this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4360#a4362
07:23:49 <xrfang> oh I don't know that!, but that's another story...
07:23:52 <Athas> And I'm beginning to realise that perhaps what I'm doing is ill-defined.
07:24:02 <quicksilver> xrfang: Fractional is a more specific class than Num
07:24:12 <quicksilver> xrfang: Fractionals must indeed be Nums, but they must also be more.
07:24:16 <quicksilver> (they must support fractions)
07:24:24 <quicksilver> Double is a Num which is indeed Fractional.
07:24:30 <quicksilver> Int is a Num which is not.
07:24:30 <xrfang> byorgey_: I can safely say: any value which is a instance of Int is an instance of Fractional?
07:24:35 <quicksilver> no.
07:24:37 <quicksilver> Int is a type.
07:24:40 <quicksilver> it has no instances.
07:24:46 <byorgey_> Athas: ah, since the String is existential, Haskell can't figure that out either.  It's basically the same problem.
07:24:50 <quicksilver> The type Int is *not* an instance of Fractional.
07:24:54 <byorgey_> Athas: one way to solve it is to use a functional dependency.
07:24:55 <xrfang> ok, comparing Int with Fractional is not right
07:25:04 <xrfang> let's compare Int with Double or Float?
07:25:06 <byorgey_> Athas: class MyClass a b | a -> b where ...
07:25:15 <xrfang> @src (/)
07:25:15 <lambdabot> Source not found. There are some things that I just don't know.
07:25:20 <byorgey_> Athas: this means that for each a there is at most one b for which there is an instance of  MyClass a b
07:25:23 <xrfang> :t /
07:25:24 <lambdabot> parse error on input `/'
07:25:28 <Berengal> Fraction is short for "fraction of an integer" which means it must be able to represent parts of ints, not just whole ints. How would you represent "one and a bit" in integers?
07:25:34 <xrfang> :t (/)
07:25:35 <byorgey_> Athas: in this case, once GHC knows that 'a' is Integer, it could figure out the 'String' part
07:25:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
07:25:43 <byorgey_> if you have that functional dependency.
07:25:58 <byorgey_> without it, GHC must assume that b could be anything---again, because type classes are open.
07:26:09 <Athas> byorgey_: Thanks, that fits exactly with my real problem.
07:26:16 <Athas> And I expect it would be ill-defined if it didn't?
07:26:23 <xrfang> Berengal: I am really confused, what I think is: while you want to store a int value, you can store it in a Int container, you can also store it in a Float container...
07:26:38 <quicksilver> xrfang: No.
07:26:40 <Berengal> xrfang: I'm not talking about containers
07:26:42 <byorgey_> Athas: not necessarily, but you'll have a hard time getting your particular code to work =)
07:26:47 <quicksilver> xrfang: technicall, Int values and Float values are completely different.
07:26:54 <byorgey_> I mean, you would without the functional dependency
07:26:56 <Berengal> xrfang: You can store an int in an int, that's easy, but you can't store an int and a bit in an int
07:27:00 <quicksilver> xrfang: however, there is a well-understood way to convert an Int to a Float.
07:27:01 <xrfang> container is my own informal term, let's say, type...
07:27:07 <quicksilver> xrfang: 'fromIntegral'
07:27:24 <xrfang> :t  fromIntegral
07:27:25 <lambdabot> forall a b. (Num b, Integral a) => a -> b
07:27:30 <quicksilver> > let a = 1 :: Int in (a,fromIntegral a) :: (Int,Double)
07:27:31 <lambdabot>   (1,1.0)
07:27:55 <Berengal> > (1,1) :: (Int, Double)
07:27:57 <lambdabot>   (1,1.0)
07:27:57 <xrfang> fromIntegral converts a Integral to Num??
07:28:17 <xrfang> in another word, (/) can accept Num while it cannot accept Int?
07:28:31 <xrfang> i.e., the behavior of Fractional is provided by Num?
07:28:36 <quicksilver> no.
07:28:36 <doserj> no
07:28:42 <quicksilver> (/) cannot accept Num.
07:28:49 <quicksilver> (/) accepts precisely Fractional.
07:28:53 <xrfang> then how do I explain :t fromIntegral
07:28:54 <Athas> Sometimes I feel that I spend
07:28:54 <kpreid> xrfang: fromIntegral converts some Integral to some Num, which might also be Fractional.
07:29:11 <quicksilver> xrfang: fromIntegral is capable of converting from an Integral to any Num.
07:29:18 <Athas> Sometimes I feel that I spend more time trying to seduce the compiler than express my program logic.  But I'm having fun anyway, and that's really what programming is about anyway.
07:29:20 <quicksilver> xrfang: in that example, I used it to convert to double.
07:29:21 <xrfang> then the type signature should be (Fractional b, Integral a) =>...?
07:29:22 <kpreid> e.g. fromIntegral can be Integer -> Double because Integer has Integral and Double has Num
07:29:33 <kpreid> and Double also has Fractional
07:29:36 * Chiamavano is away: Ich bin beschäftigt
07:29:40 <xrfang> quicksilver: ok, I got this point...
07:29:48 <quicksilver> > let a = 1 in (a,fromIntegral a,fromIntegral a,fromIntegral a) :: (Int,Double,Rational,Integer)
07:29:50 <lambdabot>   (1,1.0,1%1,1)
07:29:59 <Berengal> @instances Fractional
07:30:00 <lambdabot> Double, Float
07:30:13 <xrfang> so, there is *no* relationship between Integral and Num?
07:30:17 <byorgey_> Athas: the secret is that seducing the compiler is usually the same thing as debugging your design. =)
07:30:19 <Berengal> > fromIntegral (1 :: Integer) :: Complex Double
07:30:20 <quicksilver> yes, there is.
07:30:21 <lambdabot>   1.0 :+ 0.0
07:30:23 <xrfang> i.e. Integral is not a sub-class of Num?
07:30:23 <quicksilver> All Integral types are Nums.
07:30:27 <quicksilver> yes it is.
07:30:36 <quicksilver> Integral and Fractional are both subclasses of Num
07:30:36 <xrfang> ok, let me think
07:30:38 <quicksilver> they are disjoint.
07:30:48 <quicksilver> Types are either Integral or Fractional but never both.
07:31:04 <quicksilver> You either can store fractions, or you can't :)
07:31:08 <BONUS> @pl (\p x y -> when x y p)
07:31:08 <lambdabot> flip (flip . when)
07:31:10 <byorgey_> (technically, you *could* make a type which is both, but it would be nonsensical =)
07:31:27 <xrfang> then, how type inference works in haskell? can I say that that is not same as type conversion, as 42 is not an Int it is some sort of stuff which can be convereted to Int?
07:31:34 <xrfang> string literal, digits?
07:31:48 <BONUS> @type (\x -> when >>= flip (flip . when))
07:31:49 <lambdabot> forall t (m :: * -> *). (Monad m) => t -> Bool -> ((m () -> m ()) -> ()) -> ()
07:32:03 <BONUS> @type (>>= flip (flip . when))
07:32:05 <lambdabot> forall b. (Bool -> b) -> Bool -> (b -> ()) -> ()
07:32:12 <Berengal> xrfang: Not all numbers can be converted to an int, but every number can be converted _from_ an int
07:32:19 <edwardk> hrmm, integers module a prime?
07:32:20 <BONUS> weird?
07:32:22 <kpreid> xrfang: the thing to remember is that there are NO implicit type CONVERSIONS
07:32:24 <edwardk> checking
07:32:28 <edwardk> er modulo
07:32:41 <kpreid> xrfang: what type inference does is *choose which type shall be used uniformly*
07:32:44 <byorgey> edwardk: well, good point, it might not be nonsensical =)
07:32:53 <xrfang> ok, kpreid, thanks...
07:32:58 <quicksilver> xrfang: numeric literals are magic.
07:33:02 <kpreid> when you write fromInteger and other such conversions you are saying 'the type may differ across this boundary'
07:33:08 <quicksilver> xrfang: they are overloaded things.
07:33:22 <quicksilver> xrfang: "42" on its own, has the most general type (Num a) => a
07:33:32 <quicksilver> xrfang: its precise type is inferred from the context.
07:33:36 <xrfang> ok
07:33:37 <quicksilver> or it may stay polymorphic.
07:33:43 <Berengal> "42" is actually syntactic sugar for "fromIntegral (42 :: Integer)"
07:34:05 <quicksilver> Yes, I use the term magic loosely. It's not really that magical, you can write similar things yourself.
07:34:20 <quicksilver> but the point is that "42" is polymorphic, it doesn't have one particular type.
07:35:28 <Berengal> I wish some other literals were overloaded as well, such as 10^6 (where both values are known at compile time)
07:35:39 <zbrown> Anyone have a good suggestion for a book on lambda calculus and/or combinators, I have looked at Hindley and Seldin's "Introduction to Combinators and lambda-calculus" but haven't found much in the way of reviews as to whether its 50 bucks?
07:35:45 <xrfang> magic...'
07:36:14 <doserj> @type 1E6
07:36:15 <lambdabot> forall t. (Fractional t) => t
07:36:20 <xrfang> :t (+)
07:36:21 <lambdabot> forall a. (Num a) => a -> a -> a
07:36:31 <kpreid> :t (10^6)
07:36:32 <lambdabot> forall t. (Num t) => t
07:36:40 <xrfang> :t 2
07:36:42 <lambdabot> forall t. (Num t) => t
07:36:56 <xrfang> @type length
07:36:57 <lambdabot> forall a. [a] -> Int
07:36:58 <kpreid> Berengal: how is 10^6 not overloaded enough? because you can't change the algorithm?
07:36:59 <quicksilver> Berengal: eh?
07:37:04 <quicksilver> Berengal: 10^6 is overloaded...
07:37:07 <Berengal> Huh
07:37:10 <Berengal> @type (^)
07:37:11 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:37:13 <Axman6> :t (^)
07:37:15 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:37:18 <Berengal> Awesomesauce
07:37:24 <quicksilver> the '6' will get defaulted to Integer
07:37:25 <byorgey> zbrown: what sorts of things do you want to learn, and for what purpose?
07:37:26 <kpreid> :t (10^^6)
07:37:27 <lambdabot> forall t. (Fractional t) => t
07:37:30 <quicksilver> but the '10' is fully polymorphic.
07:37:30 <kpreid> :t (10**6)
07:37:31 <lambdabot> forall t. (Floating t) => t
07:37:58 <Berengal> quicksilver: Yeah, I didn't consider that
07:38:09 <byorgey> > (10^6) / 3.2
07:38:10 <lambdabot>   312500.0
07:38:45 <zbrown> byorgey: primarily the introductory material as I'm interested in learning more about it, not just in a haskell context but rather to undestand how the concepts work and maybe later apply them in designing languages and so on
07:38:48 <xrfang> 10^3, 10^^3, 10**3.... oh my...
07:39:19 <Peaker> > 10^^3
07:39:20 <lambdabot>   1000.0
07:39:24 <Peaker> @type (^^)
07:39:25 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:39:31 <Peaker> @type (^)
07:39:33 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:39:48 <further> hi, how can I generate a such list from two list? [ab] => [01] => [[(a,0),(b,0)],[(a,0),(b,1)],[(a,1),(b,0)],[(a,1),(b,1)]]
07:39:50 <byorgey> zbrown: I might recommend Pierce's "Types and Programming Languages" -- it's a standard introduction to the area and quite well-written.
07:39:57 <zbrown> byorgey: I've seen the Hindley and Seldin texted referenced several times but was just wondering if there's anything else people would suggest.
07:40:12 <byorgey> I'm not familiar with the Hindley and Seldin text myself.
07:40:16 <kpreid> xrfang: the difference is in what kind of result you get: e.g. ^ is non-negative exponents, so the result can be Integer
07:40:24 <Peaker> > liftM2 (,) "ab" [0,1]
07:40:25 <lambdabot>   [('a',0),('a',1),('b',0),('b',1)]
07:40:30 <zbrown> byorgey: ya, Pierce's book is on my list as well
07:40:31 <kpreid> ^^ allows negative and ** allows fractional exponents
07:40:48 <kpreid> and they get you correspondingly messier types
07:41:10 <Peaker> > join sequence $ liftM2 (,) "ab" [0,1]
07:41:11 <lambdabot>       Occurs check: cannot construct the infinite type: m = (->) [m a]
07:41:12 <lambdabot>      P...
07:41:23 <xrfang> ok kpreid: I just am surprised to see so many traps in haskell :)
07:41:38 <Peaker> > join (liftM2 (,)) $ liftM2 (,) "ab" [0,1]
07:41:40 <lambdabot>   [(('a',0),('a',0)),(('a',0),('a',1)),(('a',0),('b',0)),(('a',0),('b',1)),((...
07:41:55 <byorgey> > map (zip "ab") $ replicateM 2 [0,1]
07:41:56 <lambdabot>   [[('a',0),('b',0)],[('a',0),('b',1)],[('a',1),('b',0)],[('a',1),('b',1)]]
07:42:15 <byorgey> further: ^^^
07:42:24 <kpreid> xrfang: the point of having all those versions is so that you can e.g. raise 10 to 6 and get the known-exact answer 1000000, not 1000000.0
07:42:28 <kadaver> anyoen good with linear algebra? is 17*4 matrix rectangular but 4*17 isnt?
07:42:30 <byorgey> there might be a better way though...
07:42:40 <byorgey> kadaver: they are both rectangular.
07:43:12 <quicksilver> xrfang: that's not a trap.
07:43:13 <further> thx all! I used to try foldr and failed~
07:43:23 <quicksilver> xrfang: that's just sensible types.
07:43:30 <quicksilver> xrfang: 10^6 is guaranteed to be an integer.
07:43:39 <quicksilver> xrfang: 10^^(-5) not so much.
07:43:40 <quicksilver> etc.
07:44:01 <xrfang> the good thing in haskell, and also in ruby/python for example is to have very large integer, which is a bit cumbersome in java
07:44:12 <Berengal> quicksilver: Not exactly "guaranteed" what with floats and stuff...
07:44:47 <quicksilver> Berengal: what? 10^6 is guaranteed to be an integer, if 10 and 6 are integers.
07:44:52 <quicksilver> Berengal: that is the only point I was making.
07:44:53 <xrfang> in C, e.g. unless the number is too large, you can always convert a float to int...
07:45:01 <quicksilver> I didn't think it was controversial.
07:45:09 <Berengal> quicksilver: Ah, like that
07:45:19 <quicksilver> xrfang: so you can in haskell - using round, ceil or floor.
07:45:31 <quicksilver> > round 3.56
07:45:32 <lambdabot>   4
07:45:49 <Berengal> There are many ways to make an int out of a float. Haskell just doesn't choose one of them arbitrarily
07:46:06 <xrfang> quicksilver: that's no surprise, and I am happy with that, then I am even more confused by why it need ^ and ^^, how about this: if possible always return integer, otherwise float
07:46:14 <xrfang> or all float. e.g. 10000.0
07:46:16 <cnwdup> How can I test .chs files in ghci?
07:46:24 <quicksilver> xrfang: there is no "if possible"
07:46:24 <xrfang> you can convert to int anyway
07:46:29 <quicksilver> xrfang: expressions have a single type.
07:46:29 <opqdonut> xrfang: testing something like that is hard
07:46:35 <quicksilver> xrfang: that type does not depend on the arguments.
07:46:36 <xrfang> then, float :)
07:46:40 <QtPlaty[HireMe]> xrfang: THere are diffrent efficency tradeoffs.
07:46:46 <quicksilver> xrfang: but sometimes you want integer.
07:46:54 <quicksilver> xrfang: why waste time / accuracy with a float when the answer is integer.
07:46:56 <opqdonut> yes, the exact integer
07:46:56 <quicksilver> > 10 ^ 6
07:46:58 <lambdabot>   1000000
07:47:04 <opqdonut> and not a floating point approximation
07:47:05 <quicksilver> that's an exact integer calculation
07:47:09 <quicksilver> why use floats for that?
07:47:13 <cooldude127> there's definitely a reason for haskell's various exponent operations
07:47:16 <quicksilver> > 10 ^ 999
07:47:18 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
07:47:25 <xrfang> a bit off topic... I am trying to understand this fact: haskell is statically typed,but you need to GUESS what the type is, not like C/Pascal/Java, you know the type by definition
07:47:26 <burp_> > 10 ^^ 6
07:47:28 <lambdabot>   1000000.0
07:47:29 <quicksilver> ^^ that's an exact integer which is too large to fit in Float or Double.
07:47:34 <burp_> thats also exact isn't it?
07:47:39 <quicksilver> xrfang: you have that exactly backwards.
07:47:40 <burp_> exact rational data type
07:47:44 <burp_> :t 10^^6
07:47:44 <opqdonut> xrfang: no guessing involved
07:47:45 <lambdabot> forall t. (Fractional t) => t
07:47:49 <cooldude127> xrfang: who's guessing?
07:47:50 <burp_> ok fractional
07:47:50 <xrfang> backwards?
07:47:56 <quicksilver> xrfang: in haskell the type is known by definition.
07:47:59 <xrfang> the programmer, me, a newbie :p
07:48:10 <quicksilver> xrfang: in C/Pascal/Java you have to guess :P
07:48:12 <QtPlaty[HireMe]> xrfang: There is no guessing, the type is infered.
07:48:18 <cooldude127> xrfang: how do you know the type any less in haskell than in C/Java
07:48:18 <quicksilver> because they have unclear rules for implicit coercions
07:48:25 <quicksilver> which even good programmers don't understand.
07:48:28 <xrfang> while I just learned that infer is NOT conversion...
07:48:49 <xrfang> quicksilver: why I need to guess type in C/Java??
07:48:49 <Berengal> xrfang: Exactly. Since no conversion happens there's no need to guess
07:48:50 <QtPlaty[HireMe]> xrfang: You can if you wish annotate the types for your functions ect.
07:49:40 <kpreid> in my opinion, the great advantage of type inference over Java/C++/... is that you don't have to write down the types of your temporaries
07:49:48 <Berengal> xrfang: What's the type of "a *= 1.5;"?
07:49:57 <kpreid> in fact, Java, C++, etc *DO* type inference; they just only do it in one direction
07:50:08 <xrfang> btw, I see lambdabot is quite handy... but confused about when to use :t and when to use @src...
07:50:09 <QtPlaty[HireMe]> kpreid: I like it for exporitory programing as well.
07:50:13 <quicksilver> xrfang: suppose "void f(float x)" is a funtion taking a float. What happens when you call "f(4)" ? what happens when you call "f(3/4)" ?
07:50:20 <kpreid> e.g. if you write foo(bar()) which foo is invoked depends on the return type of bar
07:50:20 <xrfang> Berengal: that is NOT POSSIBLE in java/c/pascal
07:50:30 <xrfang> you must have something like int a, float a etc.
07:50:34 <cooldude127> xrfang: i'm not sure we understand what you mean by guessing. in haskell, the types are very well-defined.
07:50:37 <Berengal> xrfang: Yes it is, as long as a is defined up above
07:50:38 <xrfang> you cannot use a without define it!
07:50:41 <quicksilver> xrfang: I *was* joking; of course C is also well defined. But the rules for implicit conversions are not widely understood.
07:50:57 <QtPlaty[HireMe]> xrfang: Its possable in C++ and an equiverlent in dynamically typed langs.
07:50:58 <xrfang> that's also the confusion why haskell constructor is like a label
07:51:10 <xrfang> e.g. data Shape = Circle Point Float
07:51:21 <xrfang> while seems like a function header without implementation :S
07:51:22 <QtPlaty[HireMe]> quicksilver: There are big bits of the C standard that are undefined.
07:51:24 <quicksilver> xrfang: ":t" is for finding out the type of a value. "@src" is for giving the source of some of the built-in functions.
07:51:39 <quicksilver> I wish @src did not exist.
07:52:04 <QtPlaty[HireMe]> Because of the spam?
07:52:15 <quicksilver> because of the spam/value ratio ;)
07:52:17 <xrfang> ok, while I try to do something like :t Fractional or @src Fractional, ....I some time get "not known", i.e. I need to know the :t of an expression I am looking up to decide to use :t or @src...
07:52:26 <cooldude127> xrfang: that's like creating a struct in C
07:52:31 <quicksilver> xrfang: "Fractional" is not an expression.
07:52:34 <cooldude127> the data declaration
07:52:35 * QtPlaty[HireMe] wished ghci had a :src
07:52:39 <quicksilver> xrfang: "1+3" is an expression.
07:52:43 <xrfang> cooldude127: yes, I figured out that...
07:52:52 <cooldude127> :k Fractional
07:52:53 <lambdabot> Class `Fractional' used as a type
07:52:55 <quicksilver> xrfang: Fractional is a typeclass.
07:53:03 <xrfang> what is :k?
07:53:10 <Axman6> the kind of the type
07:53:15 <Axman6> :k Either
07:53:16 <lambdabot> * -> * -> *
07:53:17 <xrfang> :t 1+3
07:53:18 <lambdabot> forall t. (Num t) => t
07:53:20 <cooldude127> :k Maybe
07:53:21 <lambdabot> * -> *
07:53:26 <Axman6> :k Int
07:53:28 <lambdabot> *
07:53:31 <Axman6> :k Int#
07:53:32 <lambdabot> Not in scope: type constructor or class `Int#'
07:53:36 <Axman6> bah
07:53:53 <Berengal> Only "types" of kind "*" are concrete types
07:54:01 <Berengal> Anything else is type constructors
07:54:10 <xrfang> :k Just
07:54:11 <lambdabot> Not in scope: type constructor or class `Just'
07:54:16 <xrfang> @src Just
07:54:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
07:54:20 <cooldude127> :t Just
07:54:21 <lambdabot> forall a. a -> Maybe a
07:54:28 <quicksilver> I'm not sure this diversion into kinds is going to reduce xrfang's confusion.
07:54:34 <xrfang> ok, Just is a constructor,
07:54:35 <cooldude127> xrfang: Just is not a type, it's a constructor. Maybe is the type
07:54:49 <xrfang> ok :)
07:55:15 <Axman6> xrfang: Just doesn't have any source. say you had a struct thingo {int x; int y;} asking for the source of y doesn't make much sense, but asking for the source of the struct thingo does
07:55:27 <fasta> cooldude127: actually, Maybe is a type-constructor.
07:55:35 <cooldude127> true
07:55:42 <cooldude127> Maybe Int String is a type
07:55:46 <cooldude127> Maybe Int
07:55:48 <cooldude127> i mean
07:55:50 <Berengal> What's the name we use for the things that have kinds then?
07:55:50 <xrfang> I am also thinking about show
07:56:01 <xrfang> i.e. "deriving show" while define a data type
07:56:02 <Axman6> Show is a class
07:56:05 <Berengal> I mean, there's Types and Type constructors, but they're obivously not the same thing
07:56:26 <cooldude127> kind tells you which it is doesn't it?
07:56:30 <xrfang> how does haskell know how to print out a data only by the "deriving show" while we actually don't tell it how the data is shown?
07:56:37 <cooldude127> * means type, more than that means type constructor
07:56:48 <cooldude127> xrfang: it uses a default representation
07:56:49 <quicksilver> xrfang: deriving show has simple rules which mimic haskell syntax.
07:56:53 <Axman6> xrfang: because it can just use the course code you've written basically
07:57:01 <Axman6> source*
07:57:02 <Berengal> cooldude127: Yes, it does, but it seems like we ought to have a common name for it, like everything that has a type is a value
07:57:02 <kpreid> xrfang: 'deriving' means 'make up a typeclass instance based on some introspection'
07:57:15 <quicksilver> xrfang: e.g. data Shape = Circle, Circle will get shown as the string "Circle"
07:57:18 <Berengal> deriving is compiler magic
07:57:28 <quicksilver> which conveniently is the string of valid haskell code.
07:57:36 <quicksilver> this is really useful because you can copy/paste from ghci sessions into your code
07:57:45 <quicksilver> for test cases, examples, experiments, etc.
07:57:51 <xrfang> e.g data Days = Sunday | Monday |...|Saturday deriving Show
07:57:58 <xrfang> now how is that displayed
07:58:01 <cooldude127> Sunday
07:58:03 <cooldude127> Monday
07:58:08 <cooldude127> etc.
07:58:13 <cooldude127> depending on what the value is
07:58:14 <Axman6> @djinn (b -> c) -> (a -> b) -> (a -> c)
07:58:14 <lambdabot> f a b c = a (b c)
07:58:17 <xrfang> ok, now suppose, I am Chinese, I want the data type to be shown in Chinese.
07:58:25 <xrfang> but the data type constructor is English
07:58:27 <kpreid> xrfang: the compiler generates for you "instance Show Days where show Sunday = "Sunday"; show Monday = "Monday" ...
07:58:36 <cooldude127> xrfang: time to write your own instance
07:58:41 <cooldude127> deriving will not help you
07:58:44 <kpreid> xrfang: you can write your own Show instance just like that but with Chinese words
07:58:46 <xrfang> instance?
07:58:49 <kpreid> deriving is just a shortcut
07:58:56 <cooldude127> instance Show Day where ...
07:59:00 <xrfang> instance is a keyword, right?
07:59:17 <Saizan> Berengal: Maybe is the equivalent at the type level of something like Just, so if Just is a value then Maybe is a type
07:59:24 <cooldude127> xrfang: yes
07:59:24 <quicksilver> xrfang: you don't want the data type to be shown in Chinese.
07:59:29 <quicksilver> xrfang: that is not what Show is for.
07:59:38 <xrfang> why?
07:59:40 <quicksilver> xrfang: Show is the typeclass for representing things as valid haskell code.
07:59:44 <Axman6> @. djinn type on
07:59:45 <lambdabot> f a b c _ = a (b c) (b c)
07:59:53 <Axman6> :t on
07:59:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
08:00:06 <xrfang> I would say main = putStrLn "Today is " ++ show (day)
08:00:07 <Axman6> close enough lambdabot
08:00:10 <cooldude127> quicksilver: but strings aren't shown with double quotes
08:00:11 <Berengal> Saizan: Just IS a value. I can put it in lists just fine
08:00:14 <xrfang> isn't that the way to use show?
08:00:17 <quicksilver> cooldude127: erm?
08:00:20 <quicksilver> > show "hi"
08:00:21 <lambdabot>   "\"hi\""
08:00:25 <cooldude127> or is it
08:00:25 <quicksilver> cooldude127: what do you mean?
08:00:28 <cooldude127> nvm
08:00:30 <quicksilver> ;)
08:00:37 <cooldude127> lol i take it all back :)
08:00:38 <Berengal> Saizan: Does this mean type constructors are types?
08:00:40 <quicksilver> xrfang: well, as I say, that's not what show is for.
08:00:52 <quicksilver> Berengal: loosely speaking type constructors are types, yes.
08:00:57 <cooldude127> xrfang: you can write a different function to show it in chinese
08:01:03 <cooldude127> you don't need show
08:01:08 <quicksilver> Berengal: some people choose to use 'type' to mean 'type of kind *' and some people use it for 'type of any kind'
08:01:15 <quicksilver> Berengal: it's just a matter of taste I think.
08:01:32 <Berengal> quicksilver: Seems like it could cause misunderstandings
08:01:34 <xrfang> ok, the tutorials uses show... to convert number to string... quicksilver, cooldude127.
08:02:01 <cooldude127> xrfang: cuz a number as valid haskell code is a nice string rep
08:02:41 <cooldude127> > show 4.32
08:02:41 <xrfang> ok
08:02:42 <lambdabot>   "4.32"
08:03:17 <xrfang> show is not an IO function I suppose...
08:03:21 <cooldude127> xrfang: Show works in tandem with another typeclass called Read that does the exact opposite
08:03:24 <cooldude127> xrfang: no it's not
08:03:26 <cooldude127> show is pure
08:03:40 <Axman6> > read  (show (1/10 :: Float)) :: Double
08:03:42 <lambdabot>   0.1
08:03:42 <xrfang> so the " will not be printed out while use show with putStrLn or some other IO stuff, right?
08:03:54 <xrfang> it is just a ghci stuff to add " to the result of show?
08:03:55 <Axman6> > read  (show (1/10 :: Double)) :: Float
08:03:56 <lambdabot>   0.1
08:03:58 <Athas> Are there any standard functions for treating lists like association lists/table?
08:04:03 <Axman6> > read  (show (1/3 :: Double)) :: Float
08:04:05 <lambdabot>   0.33333334
08:04:09 <kpreid> xrfang: no, show produces quotes *around strings*
08:04:15 <Athas> I know about lookup, but I also need a function to update the list.
08:04:16 <kpreid> > fix show -- not helpful
08:04:16 <Axman6> Athas: lookup?
08:04:17 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
08:04:19 <xrfang> oh.
08:04:23 <Berengal> xrfang: ghci uses print, which is basically the same as "putStrLn . show"
08:04:27 <Athas> I could define it myself, of course.
08:04:33 <ray> > fix error -- is better
08:04:35 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
08:04:36 <xrfang> ok
08:04:47 <cooldude127> :t fix
08:04:49 <lambdabot> forall a. (a -> a) -> a
08:04:51 <Berengal> xrfang: So ghci adds yet another layer of show on top
08:04:54 <cooldude127> @src fix
08:04:54 <lambdabot> fix f = let x = f x in x
08:05:45 <Axman6> @src error
08:05:45 <lambdabot> error s = throw (ErrorCall s)
08:06:30 <ray> error's type is a lot more helpful than its source
08:06:42 <cooldude127> :t error
08:06:44 <lambdabot> forall a. [Char] -> a
08:07:30 <Axman6> ray: i was curious what the source was though :)
08:07:41 <ray> i hope you were disillusioned
08:10:10 <byorgey> Athas: yeah, I think there aren't actually any standard functions to do update on an association list.
08:10:21 <byorgey> Athas: you'll have to write it yourself, or just use Data.Map
08:10:34 <xrfang> is there a function "average" which does (sum [a]) / fromIntegral (length [a])?
08:10:46 <byorgey> which is probably nicer anyway, unless there's a particularly good reason to use association lists in particular.
08:11:03 <byorgey> xrfang: not in the standard libraries.
08:11:13 * QtPlaty[HireMe] would call it mean.
08:11:15 <xrfang> tks byorgey.
08:11:30 <xrfang> no mean either, it seems :)
08:12:02 <cooldude127> Athas: yeah, i think maps are what to use for that. Map.fromList will take your association list and make it a map
08:12:04 * ray would call it arithMean
08:12:10 <edwardk> xrfang: several, some of which actually don't traverse the list twice. dons blogged one
08:12:14 <xrfang> :t fromJust
08:12:15 <lambdabot> forall a. Maybe a -> a
08:12:20 <edwardk> and there is one in a lib somewhere i saw for statistical accumulators
08:12:30 <Athas> Well, my type isn't an Ord, so I can't use Map.
08:12:41 <xrfang> ok edwardk...
08:12:51 <xrfang> > fromJust Just 3
08:12:52 <lambdabot>   Couldn't match expected type `Maybe a'
08:12:59 <xrfang> > fromJust (Just 3)
08:13:00 <lambdabot>   3
08:13:30 <ray> it's generally better to pattern match on Just x and Nothing than to use fromJust
08:13:34 <xrfang> sorry to be dumb... fromJust Just 3 ... without (),
08:13:39 <xrfang> it does not work, why?
08:13:50 <ray> the precedence
08:13:52 <xrfang> haskell does this I think: (fromJust Just) 3
08:13:57 <paper_cc> yes
08:14:00 <litb> try fromJust $ Just 3  i think
08:14:07 <edwardk> > fromJust (Just 3)
08:14:08 <lambdabot>   3
08:14:10 <cooldude127> > fromJust $ Just 3
08:14:12 <lambdabot>   3
08:14:18 <xrfang> but why? Just is a defined stuff, it should know Just along is not valid, but (Just a) is valid?
08:14:26 <xrfang> sorry
08:14:31 <edwardk> xrfang: foo bar baz = (foo bar) baz
08:14:32 <xrfang> I think I know what's wrong here
08:14:34 <ray> :t Just
08:14:34 <paper_cc> xrfang: Just is perfectly valid alone
08:14:35 <lambdabot> forall a. a -> Maybe a
08:14:36 <seliopou> application is left-associative
08:14:38 <xrfang> Just is a function right?
08:14:40 <cooldude127> xrfang: Just alone is a valid value
08:14:49 <cooldude127> and can be passed around as the function
08:14:51 <ray> yeah, it's a function
08:14:53 <edwardk> xrfang: it acts like one, but any constructor does
08:14:54 <litb> Just is a constructor function
08:14:59 <paper_cc> > fix Just
08:15:00 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
08:15:00 <lambdabot>        Ex...
08:15:01 <xrfang> but it is a strange function without definition :)
08:15:03 <ray> > map Just [1..]
08:15:03 <xrfang> yes
08:15:04 <paper_cc> oh
08:15:05 <lambdabot>   [Just 1,Just 2,Just 3,Just 4,Just 5,Just 6,Just 7,Just 8,Just 9,Just 10,Jus...
08:15:07 <edwardk> @type Just
08:15:09 <lambdabot> forall a. a -> Maybe a
08:15:13 <xrfang> @src Just
08:15:13 <lambdabot> Source not found. That's something I cannot allow to happen.
08:15:21 <paper_cc> @src Either
08:15:22 <lambdabot> Source not found. Just try something else.
08:15:27 <paper_cc> ,src Either
08:15:29 <lunabot>  luna: Not in scope: data constructor `Either'
08:15:34 <edwardk> data Maybe a = Just a | Nothing -- defines Just :: a -> Maybe a -- and Nothing :: Maybe a
08:15:37 <paper_cc> ,src ''Either
08:15:42 <lunabot>  data Either a b = Left a | Right b
08:15:43 <xrfang> > let j = fromJust Just; j 3
08:15:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:15:50 <xrfang> :S
08:16:03 <Axman6> :t Just
08:16:04 <xrfang> fromJust Just, isn't that a "function application"??
08:16:05 <litb> a $ b c = a (b c) i think
08:16:05 <lambdabot> forall a. a -> Maybe a
08:16:07 <Axman6> :t fromJust
08:16:09 <lambdabot> forall a. Maybe a -> a
08:16:12 <ray> xrfang: where you have a ; you meant to say "in"
08:16:14 <paper_cc> xrfang: you probably fromJust . Just -- composition
08:16:22 <paper_cc> *probably want
08:16:22 <ray> and that
08:16:23 <cooldude127> > let j = fromJust . Just; j 3
08:16:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:16:41 <litb> > let j = fromJust . Just in j 3
08:16:41 <paper_cc> > let j = fromJust . Just in j 3
08:16:42 <Axman6> > let j = fromJusr . Just in j 3
08:16:43 <lambdabot>   3
08:16:44 <lambdabot>   Not in scope: `fromJusr'
08:16:44 <lambdabot>   3
08:16:45 <Axman6> ha
08:16:46 <litb> lol
08:16:48 <ray> :(
08:16:52 <paper_cc> =)
08:17:05 <litb> !win
08:17:11 <Axman6> wow, that was nicely symetrical to some degree
08:17:21 <xrfang> > let double = (*); let quad = double double; quad 3
08:17:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:17:32 <litb> @src $
08:17:33 <lambdabot> f $ x = f x
08:17:36 <ray> no semicolons
08:17:36 <litb> oh
08:17:48 <litb> why is it so simple?
08:17:49 <ray> let definition in expr
08:17:59 <litb> doesn't it say that it invokes f with x ?
08:18:07 <Axman6> xrfang: you need to end lets with an 'in' when using it in lambdabot
08:18:10 <cooldude127> litb: it's the precedence that makes $ useful
08:18:18 <xrfang> thanks
08:18:23 <litb> oh $ is left associative?
08:18:29 <Axman6> yes
08:18:29 <xrfang> > let double = (*); quad = double double in quad 3
08:18:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a -> a
08:18:30 <lambdabot>      ...
08:18:32 <litb> i see
08:18:36 <ray> $ is low precedence
08:18:44 <ray> function application is high precedence
08:18:47 <xrfang> so that lambdabot cannot eval multiple expressions at once?
08:18:52 <litb> ah now i get
08:18:53 <ray> it can
08:19:00 <ray> you can have multiple lets
08:19:05 <Axman6> xrfang: it can, what you're trying to write doesn't make any sense
08:19:14 <ray> let ... in let ... in expr
08:19:15 <litb> > let a = 1 in let b = 2 in a + b
08:19:16 <lambdabot>   3
08:19:36 <litb> comma works too i think
08:19:50 <burp_> > let a = 1; b = 2 in a + b
08:19:52 <lambdabot>   3
08:19:58 <litb> oh
08:20:16 <xrfang> > let double = (*) in let quad = double double in quad 3
08:20:17 <lambdabot>       Occurs check: cannot construct the infinite type: a = a -> a -> a
08:20:18 <lambdabot>      ...
08:20:27 <litb> should work with some do-trickery and monads too
08:20:45 <ray> to compose two functions together like that, use .
08:20:55 <cooldude127> > let double = (2*); quad = double . double in quad 3
08:20:56 <lambdabot>   12
08:21:13 <xrfang> hm..
08:21:17 <litb> > do { a <- [1]; b <- [2]; return a + b; }
08:21:18 <lambdabot>       No instance for (Num [t])
08:21:18 <lambdabot>        arising from the literal `2' at <inter...
08:21:19 <burp_> double is not a good name though :>
08:21:29 <litb> hey why won't it give me  [3] :(
08:21:47 <cooldude127> litb: i think you want return $ a + b maybe
08:21:47 <Axman6> > do { a <- [1]; b <- [2]; return (a + b) }
08:21:49 <lambdabot>   [3]
08:21:53 <litb> oh thanks
08:22:44 <burp_> :t do { a <- [1]; b <- [2]; return (a + b) }
08:22:45 <lambdabot> forall t. (Num t) => [t]
08:23:04 <litb> > do { a <- [1, 2]; b <- [2]; return (a + b) }
08:23:06 <lambdabot>   [3,4]
08:23:20 <litb> nice. works like i expect it. didn't do so last year when i tried to mess with it. ahaha
08:24:09 <Axman6> > do { x <- [1..5]; y <- [1..3]; return $ x ^ y}
08:24:11 <lambdabot>   [1,1,1,2,4,8,3,9,27,4,16,64,5,25,125]
08:25:12 <yowgi> why the do notation?
08:25:14 <yowgi> > [x^y | x <- [1..5],  y <- [1..3]]
08:25:16 <lambdabot>   [1,1,1,2,4,8,3,9,27,4,16,64,5,25,125]
08:25:17 <cooldude127> > [x ^ y | x <- [1..5], y <- [1..3]]
08:25:19 <lambdabot>   [1,1,1,2,4,8,3,9,27,4,16,64,5,25,125]
08:25:23 <cooldude127> that's what i wondering
08:25:29 <burp_> same
08:25:41 <byorgey> why not? =)
08:25:42 <burp_> does that use some monadic stuff?
08:25:49 <Axman6> byorgey: beat me to it :)
08:25:50 <cooldude127> apparently list comprehensions are nice syntax for the list monad
08:26:24 <byorgey> cooldude127: actually, list comprehensions used to be called monad comprehensions, and they were nice syntax for any monad =)
08:26:34 <byorgey> but they were taken out in Haskell 1.4 or so
08:26:44 <cooldude127> well how about that :)
08:27:29 <litb> wait. list comprehensions can't work with other monads anymore?
08:27:35 <Axman6> nope
08:27:35 <byorgey> so it's true, in a technically precise sense, that there is a nice correspondence between list comprehensions and do-notation for the list monad
08:27:44 <Axman6> litb: not for a very long time
08:27:52 <litb> oh ok
08:27:56 <Axman6> over 10 years if i'm not mistaken
08:28:24 <litb> byorgey: everything you do with list comprehensions has a direct corresponding do sequence
08:28:34 <byorgey> indeed.
08:28:46 <burp_> interesting
08:28:49 <byorgey> possibly involving 'guard'.
08:29:05 <litb> i believe you can do those "guards" in the list comprehension at the end. you can do that with monads too. it would return the zero element or something along that
08:29:10 <doserj> and fmap
08:29:35 <byorgey> litb: not just at the end, you can have guards anywhere in a list comprehension.
08:29:38 <byorgey> @type guard
08:29:39 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
08:29:48 <da-x> what's type !Int compared to type Int ?
08:29:54 <litb> oh
08:29:59 <byorgey> litb: right, guard only works for MonadPlus types, which have a zero element.
08:29:59 <Zao> da-x: ! is a strictness annotation.
08:30:15 <da-x> I thought it was for expressions only
08:30:17 <litb> i see
08:30:21 <Axman6> are there any rules for Functor, other that it performs a transformation from f a to f b? like must it not change the 'shape' of the f?
08:30:34 <byorgey> Axman6: yes, there are two:
08:30:34 <Axman6> da-x: nope
08:30:37 <byorgey> fmap id = id
08:30:43 <byorgey> and  fmap (g . h) = fmap g . fmap h
08:30:44 <litb> so if the bool is true, it returns something. and if it is false, it returns zero
08:30:47 <Berengal> Axman6: fmap a . fmap b = fmap (a . b)
08:30:57 <Axman6> byorgey: thanks :)
08:31:02 <byorgey> Axman6: together you can definitely see these rules as specifying that it must not change the shape.
08:31:10 <Axman6> indeed
08:32:17 <edwardk> Axman6: the first is the important one, the second one comes for free if you can get it to typecheck
08:32:43 <Berengal> Does this mean fmap has to be strict?
08:32:50 <edwardk> Berengal: no
08:32:50 <Axman6> eh?
08:32:53 <BONUS> nope
08:32:55 <edwardk> berengal: its a free theorem
08:33:08 <Berengal> id is strict
08:33:09 <edwardk> fmap id = id is sufficient to enforce the second condition
08:33:24 <xrfang> > cos -2
08:33:25 <lambdabot>       No instance for (Num (a -> a))
08:33:25 <lambdabot>        arising from the literal `2' at <...
08:33:40 <EvilTerran> > cos (-2)
08:33:42 <lambdabot>   -0.4161468365471424
08:33:44 <burp_> > cos $ -2
08:33:46 <lambdabot>   -0.4161468365471424
08:33:50 <Axman6> ok, sleep time
08:35:14 <edwardk> ah, duh, Foldr is a comonad.
08:35:23 <xrfang> :t -2
08:35:24 <lambdabot> forall a. (Num a) => a
08:35:37 <xrfang> -2 is a function or it is a number? :)
08:35:47 <Axman6> number
08:35:55 <Axman6> one of the few oddities in haskell
08:35:56 <byorgey> edwardk: ah, interesting, I never thought about that.
08:36:09 <Axman6> (+2) is a function, but (-2) is not
08:36:46 <Berengal> Always put parenthesis around negative numbers and never section minus...
08:36:53 <edwardk> byorgey: duplicate (Foldr f z m) = Foldr f'' (Foldr f z m) id where f'' a (Foldr f' c' m') = Foldr f' (f' a c') m' -- or something like that
08:37:11 <xrfang> as it is not a function why I cannot: sin -2?
08:37:24 <xrfang> it should not be seen as (-) sin 2, should it?
08:37:25 <byorgey> edwardk: I meant I never thought about the second fmap rule being a free theorem.  But now that you mention it, I never thought about that other thing either ;)
08:37:32 <Axman6> xrfang: it is
08:37:55 <edwardk> byorgey: heh, i think i may have mentioned it when you asked me over email about the conditions for Pointed
08:38:04 <edwardk> i don't recall, if i didn't, i should have
08:38:19 <byorgey> edwardk: you might have, but if so I didn't remeber it
08:38:33 <byorgey> I didn't remember it, either.
08:39:27 <Peaker> I'm having difficulty understanding the difference between two implementations I have of append between my mlists:
08:39:28 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4363#a4363
08:39:32 <edwardk> that type above is basically the bastard child of a left kan extension and a cofree comonad.
08:39:49 <edwardk> er woops didn't give the type
08:39:50 <edwardk>  data Foldr a b = forall c. (a -> c -> c) c (c -> b)
08:39:53 <byorgey> you need both in general CT, of course, because a functor doesn't have to be polymorphic -- i.e. you could define a functor by cases on the objects in the domain category.
08:40:11 <Peaker> edwardk: forgot the data constructor?
08:40:19 <edwardk> oh yeah that too =)
08:40:23 <byorgey> and I guess you could do something like that in, say, Agda as well
08:41:16 <edwardk> i was just thinking about what i had said to pumpkin the other day about Foldr probably being a category. -- it is, but you have to limit yourself to folding over non-empty containers
08:41:21 <ski> edwardk : hehe :)
08:42:36 <edwardk> in fact if you limit yourself to non-empty containers its an Arrow and can be contorted into an instance of ArrowChoice
08:43:00 <edwardk> but if you use 'Foldr1' with that restriction and with the same general signature, you lose the comonad =(
08:43:01 <Peaker> ok, I understand my problem/difference
08:43:20 <edwardk> otoh, you pick up an instance of Monoid for (Foldr1 a a)
08:43:27 <Cale> Peaker: Is it just a coincidence that the type signature for append1 is followed by a definition for a function called append ?
08:43:59 <Peaker> Cale: ah oops, copy&paste error - both are called append in the source and I renamed to append1 and append2 for the paste/comparison
08:44:03 <Cale> ah
08:44:30 <Peaker> Cale: I'm trying to create a list that is allowed to have side effects in some monad in order to get the next element
08:44:43 <Peaker> Cale: to replace lazy I/O which I find very yucky
08:45:49 <_dls> hey guys, I've tried a couple google searches with no success... is there a way to write some parts of of a haskell program with manual memory management?
08:45:57 <Cale> Peaker: It reminds me of one of the "ListT done right" implementations
08:46:07 <Peaker> Cale: could it do this?
08:46:12 <Cale> _dls: via FFI, sort of.
08:46:14 <ski>   newtype List  link a = MkL {unL :: link (ListCell link a)}
08:46:20 <edwardk> _dls: the short answer is no, the long answer is sure with a complicated enough DSL
08:46:23 <ski>   data ListCell link a = Nil
08:46:25 <ski>                        | Cons a (List link a)
08:46:39 <Peaker> Cale: be used as an alternative to lazy I/O?
08:46:48 <edwardk> _dls: you can malloc, etc. with the FFI stuff, but you still wind up using gc for the heap, etc.
08:46:51 <Cale> _dls: The foreign function interface library has things like malloc
08:46:57 <Cale> yeah
08:47:00 <edwardk> er for the non-manually malloced, stuff
08:47:14 <_dls> Cale: edwardk: thanks, looking into it :)
08:47:17 <ski> it is useful to allow any `link', not just monads
08:47:29 <xrfang> negate abs -2
08:47:32 <xrfang> >negate abs -2
08:47:35 <xrfang> > negate abs -2
08:47:36 <lambdabot>       No instance for (Num (a -> a))
08:47:36 <lambdabot>        arising from a use of `negate' at...
08:47:36 <_dls> edwardk: where might I look for the DSL approach?
08:47:38 <Cale> :t Foreign.malloc
08:47:38 <dschoepe> Can someone help me to speed up this piece of code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4364#a4364 (It is intended to find the highest number below a given limit that has a given prime as its highest prime factor)
08:47:39 <lambdabot> forall a. (Foreign.Storable.Storable a) => IO (GHC.Ptr.Ptr a)
08:47:40 <xrfang> > negate abs (-2)
08:47:41 <lambdabot>       No instance for (Num (a -> a))
08:47:41 <lambdabot>        arising from a use of `negate' at...
08:47:50 * da-x drinks tea while trying to understand the Control.Monad.* implementation
08:47:53 <QtPlaty[HireMe]> > megate . abs $ -2
08:47:54 <lambdabot>   Not in scope: `megate'
08:47:56 <edwardk> _dls: well, by that i was talking about using something like the llvm bindings ;)
08:48:01 <Cale> _dls: So, computations which do their own memory management will have to be in IO
08:48:04 <QtPlaty[HireMe]> > negate . abs $ -2
08:48:06 <lambdabot>   -2
08:48:06 <EvilTerran> xrfang, function application is left-associative.
08:48:18 <EvilTerran> xrfang, ie, "foo bar baz" means "(foo bar) baz"
08:48:24 <edwardk> _dls: for that i'd say lennart augustsson's blog
08:48:27 <xrfang> EvilTerran, that's exactly what I am thinking
08:48:37 <ski> Peaker : what operations on such lists do you want ?
08:48:45 <_dls> Cale: ahh, thanks :)
08:48:53 <xrfang> I try to do an "application" of "negate abs" then apply it to 2
08:48:55 <Cale> _dls: However, if you're really daring and/or careful, you could unsafePerformIO them. This sort of thing is best treated with the same gravity as modifying your compiler.
08:49:05 <cooldude127> xrfang: negate doesn't take a function as input
08:49:07 <EvilTerran> xrfang, you can't negate a function
08:49:14 <_dls> edwardk: lol, fair enough
08:49:26 <EvilTerran> > (negate . abs) (-2) -- xrfang, you could compose "negate" and "abs", though
08:49:28 <lambdabot>   -2
08:49:49 <cooldude127> xrfang: you seem to be using application where you want composition
08:50:04 <QtPlaty[HireMe]> Which is also what I did, but using a $ so I didn't have to add brackets.
08:50:08 <_dls> Cale: yeah, makes sense :-p
08:50:13 <Cale> _dls: It is not entirely impossible to understand how space will be used by pure Haskell code though.
08:50:32 <skorpan> @pl \one rest -> (variableName one):rest
08:50:32 <lambdabot> (:) . variableName
08:51:35 <Cale> _dls: A reasonably good approximation is provided by thinking about the size of expressions as they get evaluated lazily.
08:52:23 <Cale> The evaluation of Haskell expressions as done by GHC still isn't very far off from graph reduction.
08:52:36 <dikini> Cale, edwardk, _dls:  what about monadic regions, don't they cover similar ground?
08:53:02 <Peaker> Cale: I'm trying to transform append1, which is correct, to be expressed in terms of mfoldr
08:53:02 <Peaker> Cale: proving trickier than I thought
08:53:07 <dikini> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/IOR
08:53:09 <Cale> dikini: Somewhat. That, I think, would be considered one of the DSL approaches to it.
08:53:17 <Peaker> ski: basically most of what you'd do on a list, except you get the result in a monad. Also mforM which executes your actions interlaced with the side effects of the list, and such
08:53:22 <Cale> Peaker: I'll have a look :)
08:53:32 <Peaker> Cale: thanks :)
08:54:53 <_dls> Cale: makes sense about the graph reduction, etc. I'm mostly excited to see what it looks like in a purely functional language :p
08:55:01 <_dls> dikini: :D
08:55:57 <ski> append1 :: Monad m => List m a -> List m a -> List m a  -- ?
08:56:03 <skorpan> @where StateT
08:56:03 <lambdabot> I know nothing about statet.
08:56:13 <skorpan> @hoogle StateT
08:56:14 <lambdabot> Control.Monad.State.Lazy newtype StateT s m a
08:56:14 <lambdabot> Control.Monad.State.Lazy StateT :: s -> m (a, s) -> StateT s m a
08:56:14 <lambdabot> Control.Monad.State.Strict newtype StateT s m a
08:56:19 <ski> @index StateT
08:56:19 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
08:56:20 <Cale> Peaker: Oh, you didn't supply an implementation of cons, should I just guess? :)
08:56:27 <Peaker> Cale: oops
08:56:38 <skorpan> thanks ski, i never remember that one
08:57:01 <Peaker> Cale: done
08:57:03 <skorpan> okay, so i have StateT in two packages, monads-fd and mtl, which one should i use?
08:57:10 <dikini> _dls: it just happens that I was looking into that today, but still have to bounce the idea around a few times in my head
08:58:14 <fasta> skorpan: just use mtl until it breaks
08:58:32 <skorpan> heh
08:58:59 <ski> Peaker : if this is available for inspection somewhere, i'd like to take look
08:59:06 <Peaker> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4363#a4365
08:59:09 <ski> Peaker : i'm leaving for now in a few minutes, though
08:59:15 <ski> ty
08:59:15 <Peaker> I've got to go soon too
09:00:01 <kadaver> lol im writing Java and imcopypasting, srssl
09:00:48 <edwardk> hrmm
09:00:58 <xrfang> what is exactly "function application"? negate . abs ? or (max 2)?
09:01:20 <|Jedai|> xrfang: max 2 is the application of max to 2
09:01:39 <xrfang> so negate . abs is called "composition", not "application", right?
09:01:52 <|Jedai|> negate . abs is function composition, it's a function that apply abs then negate to its argument
09:01:59 <Peaker> ski, Cale: I gotta go. I created an mfoldr' which can express append. I am not sure if mfoldr cannot express append, but I think it can't.  Maybe something more general can express both mfoldr and mfoldr' though
09:02:25 <Peaker> ski, Cale: If you have answers, please @message them to me or add them to the paste.. Sorry for having to leave in the middle...
09:02:32 <xrfang> I have an impression that (max 2) is an application (which create another function) while (max 2 3) is not, which create a value (non-function)?
09:03:16 <Jedai> xrfang: max 2 3 is still an application, it's the application of (max 2) to 3
09:03:49 <Jedai> xrfang: The fact that max 2 evaluates to a function while max 2 3 evaluates to an Int is irrelevant
09:04:12 <xrfang> hm... so there word "application" does not refer to "pass one parameter to a function which expect 2, to create a new function" etc.
09:04:17 <voker57_> what are # classes, like Array#? I seem to can not use them in ghci
09:04:19 <Jedai> xrfang: in fact in Haskell composition is still an application by the way
09:04:35 <xrfang> @src (.)
09:04:36 <lambdabot> (f . g) x = f (g x)
09:04:46 <edwardk> data Foldr a b = forall c. Foldr (a -> c -> c) c (c -> b) -- is a left kan extension data Lan g h b = forall c. Lan (g c -> b) (h c) -- along g = Identity, so its the application of the contravariant yoneda lemma to a base functor, i wonder if it could be written more succinctly
09:04:46 <Jedai> xrfang: negate . abs is the application of ((.) negate) to abs
09:04:47 <QtPlaty[HireMe]> xrfang: All functions in Haskell expect one argument.
09:05:00 <xrfang> sorry forgot that :)
09:05:08 <Jedai> xrfang: but most application are not composition
09:05:12 <xrfang> @src ($)
09:05:12 <lambdabot> f $ x = f x
09:05:28 <Jedai> xrfang: composition only happens when you use the composition operator (.)
09:07:39 <xrfang> all function expect one argument... is it valid for a function to expect no argument at all?
09:08:25 <quicksilver> xrfang: sure, although arguably that's not really a function :)
09:08:33 <quicksilver> depends exactly what you understand by 'function'.
09:08:40 <edwardk> oh, duh, its a comealy machine
09:08:49 <quicksilver> a = 1 :: Int -- is this a function which takes no parameters?
09:09:01 <burp_> yes
09:09:03 <quicksilver> that's certainly one sensible way to look at it.
09:09:17 <quicksilver> it's not the standard meaning of 'function' which is 'thing of type a -> b'
09:09:21 <burp_> its the constant function 1
09:09:23 <xrfang> ok
09:09:24 <quicksilver> no it's not.
09:09:30 <edwardk> so this is just the comonad i found back when for that
09:09:31 <quicksilver> f x = 1
09:09:35 <Cale> The constant function would be written f x = 1, yeah
09:09:36 <quicksilver> that's the constant function one, burp_  ;)
09:09:39 <quicksilver> that's different.
09:09:46 <edwardk> expressed in terms of the contravariant yoneda lemma
09:09:56 <quicksilver> but it's not unreasonably to consider constants to be functons of no arguments if you like.
09:09:58 <xrfang> by definition, (f.g) x = f (g x)
09:10:07 <xrfang> while f $ x = f x
09:10:19 <burp_> :t f x = 1
09:10:20 <lambdabot> parse error on input `='
09:10:25 <xrfang> here, what if x is a function? then the 2 definition is quite similar...
09:10:40 <Jedai> xrfang: No, they're not
09:10:46 <c_wraith> Monadic values make a lot more sense if you think of them as 0-argument functions.
09:10:50 <daf> hmm, so toList . viewr == toList . viewl; that's a bit surprising
09:10:53 <burp_> quicksilver, you're right
09:11:00 <Cale> c_wraith: ... not to me :)
09:11:02 <burp_> it's no function
09:11:12 <xrfang> Jedai, I am sorry that I asked the same question again and again... :p
09:11:12 <Jedai> xrfang: I don't really see in which way they would be similar...
09:11:50 <xrfang> > negate . abs 2
09:11:50 <lambdabot>       No instance for (Num (a -> b))
09:11:51 <lambdabot>        arising from the literal `2' at <...
09:12:01 <Cale> Functions *must* have a domain and codomain. The only purpose of a function is to associate each element of the domain with exactly one element of the codomain.
09:12:06 <xrfang> > negate.abs 2
09:12:06 <lambdabot>       No instance for (Num (a -> b))
09:12:07 <lambdabot>        arising from the literal `2' at <...
09:12:21 <burp_> hm, or a=1::Int is the constant function 1 defined at the empty set?
09:12:25 <xrfang> > (negate.abs) 2
09:12:27 <lambdabot>   -2
09:12:32 <burp_> could you say that?
09:12:41 <burp_> no, makes no sense at all
09:12:47 <Cale> burp_: a = 1 :: Int  defines an Int, not a function :)
09:12:54 <burp_> sadly yes
09:12:54 <xrfang> why I still need () around negate.abs ?
09:13:11 <Cale> Functions are the values whose top-level type constructor is (->)
09:13:13 <trofi> :t ($1)
09:13:14 <lambdabot> forall a b. (Num a) => (a -> b) -> b
09:13:22 <burp_> I wanted everything to be a function :|
09:13:30 <Jedai> xrfang: because if you don't put them it's read as "negate . (abs 2)"
09:13:45 <Berengal> So there are functions and there are constants, and their union is the "values"
09:13:57 <xrfang> but I just heard . is left associative?
09:14:00 <Jedai> xrfang: and (abs 2) is an Int, not a function so you can't compose it.
09:14:30 <Berengal> xrfang: function application binds tightest of all, so "negate . abs 2" = "negate . (abs 2)"
09:14:34 <Jedai> xrfang: function application (whitespace) has more precedence than any operators in Haskell
09:14:53 <xrfang> ok, tks
09:15:00 <xrfang> > negate $ abs 2
09:15:02 <lambdabot>   -2
09:16:00 <Jedai> xrfang: On the other hand the operator ($) (which is also function application) has the lowest precedence of all operators
09:16:29 <xrfang> I now see the difference,
09:16:48 <Jedai> xrfang: so you have two way to apply a function, the whitespace or ($), which are at the extreme of the precedence spectra (and that's nice to avoid using a lot of parens)
09:17:21 <yowgi> > sort [3,2,1] ++ [6,5,4]
09:17:23 <lambdabot>   [1,2,3,6,5,4]
09:17:25 <yowgi> > sort $ [3,2,1] ++ [6,5,4]
09:17:26 <trofi> :t ($!)
09:17:27 <lambdabot>   [1,2,3,4,5,6]
09:17:27 <lambdabot> forall a b. (a -> b) -> a -> b
09:17:43 <cognominal> I am still struggling with types. How could I correctly write?    when True fail "Fail"
09:18:10 <trofi> $ fail
09:18:12 <xrfang> while all function takes one argument, we read max 2 3 as (max 2) 3 where (max 2) is a function right
09:18:25 <ray> yes
09:18:32 <trofi> cognominal: when has 2 parameters (not 3)
09:18:35 <xrfang> this seems clear, but why I can say 2 * 3 => (2*) 3 and (*3) 2
09:18:47 <xrfang> i.e. it seems 2* and *2 are same function
09:18:58 <xrfang> it means, we can see 2 as a function?
09:19:09 <cognominal> oops, thx trofi
09:19:16 <da-x> in "class (Monad m) => MonadError e m | m -> e where", how the '| m -> e' fits in there? what does it say?
09:19:23 <ray> sections of operators work because infix operators have 2 arguments by definition, so we can get away with it
09:20:10 <xrfang> i.e. infix operators are exception to the one-argument rule?
09:20:24 <xrfang> and `anyfunc` is also infix function... :)
09:20:43 <ray> not really, just that the infix syntax requires 2 arguments
09:20:45 <trofi> > ((*) 2) 3
09:20:47 <lambdabot>   6
09:21:11 <trofi> > (($ 3) $ 2) (*)
09:21:12 <lambdabot>       No instance for (Num (a -> (a1 -> a1 -> a1) -> a2))
09:21:12 <lambdabot>        arising from...
09:21:30 <Athas> How do I uninstall a package installed via 'cabal install'?
09:21:32 <xrfang> > ((2) * ) 3
09:21:33 <lambdabot>   6
09:21:56 <trofi> @unpl (2*)
09:21:57 <lambdabot> (\ a -> 2 * a)
09:22:24 <burp_> Athas, I think you can't
09:22:46 <Athas> That's odd.
09:22:49 <burp_> it is
09:23:04 <trofi> otherwise other packaes would conmlain you'we broke their world
09:23:23 <Jedai> xrfang: section syntax is just syntax sugar (2 *) is translated to (*) 2 while (* 2) is translated to flip (*) 2
09:23:41 <Jedai> Athas: you can unregister it with ghc-pkg
09:24:16 <Jedai> Athas: and then delete the files
09:24:34 <Athas> Oh nice, thanks.
09:24:44 <Jedai> Athas: Of course if some other package was dependent of this package it is now broken
09:24:50 <cnwdup> Concerning gtk2hs: Which type do I have to pass to a gtk function which expects a GtkWindow? I supposed it was Window, but when compiling gcc complains with: Unacceptable argument type in foreign declaration: Window. Anyone's fit with gtk2hs' internals? (:
09:26:03 <Athas> Jedai: well sure, but it was my own package anyway.
09:31:45 <Cale> cnwdup: hmm... What gtk2hs function are you calling?
09:32:03 <Cale> cnwdup: (I'm not all that knowledgeable about gtk2hs, but I've used it a bit before)
09:33:18 <Cale> cnwdup: er, that's actually really odd
09:33:29 <Cale> cnwdup: Are you having trouble compiling gtk2hs itself?
09:33:41 <cnwdup> Cale, not really a gtk function in particular. I am calling gdk_property_change. http://library.gnome.org/devel/gdk/stable/gdk-Properties-and-Atoms.html#gdk-property-change
09:34:02 <cnwdup> Cale, nope. I am trying to add the functions given on the url above as they seem to be missing from the current gtk2hs.
09:34:15 <cnwdup> And I am trying to compile my own module.
09:35:19 <cnwdup> Cale, http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2265#a2265 that's what I got so far.
09:35:36 * quicksilver would aways say "(*2) is desugared to (\x -> x * 2)"
09:36:49 <DrSyzygyFR> Stupid question. Isn't there an infinite value in, say, Integer or so?
09:37:01 <Cale> DrSyzygyFR: no
09:37:03 <cnwdup> @type Infinity
09:37:05 <lambdabot> Not in scope: data constructor `Infinity'
09:37:05 <DrSyzygyFR> Awwww.
09:37:14 <cnwdup> DrSyzygyFR, there is one in Double or Float or so.
09:37:24 <Cale> DrSyzygyFR: Integer is more or less the same as Z with one extra point (bottom)
09:37:25 <DrSyzygyFR> But I need one! I want an integer that is larger than all other integers!!
09:37:40 <Cale> There's no largest integer ;)
09:37:47 <DrSyzygyFR> Cale: Oh well. I guess I\ll survive without completion. :-P
09:37:51 <quicksilver> data BoundedAbove a = Simply a | MaxBound
09:37:53 <Cale> You can add one
09:38:37 <quicksilver> instance Ord a => BoundedAbove a where MaxBound >= _ = True; Simply x >= Simply y = x >= y
09:38:41 <quicksilver> something like that.
09:39:05 <quicksilver> then BoundedAbove Integer is something like (Z + Inf)
09:39:15 <quicksilver> conal uses types like that all the time.
09:39:21 <quicksilver> although he bounds below as well.
09:39:56 <doserj> quicksilver: deriving(Eq,Ord) should just work
09:40:03 <mightybyte> How would I go about converting the following simple parser to properly account for failure by returning Maybe MyType?
09:40:05 <mightybyte> parse str = MyType (read $ take 2 str) (read $ drop 2 str)
09:40:30 <yowgi> > 1/0
09:40:32 <lambdabot>   Infinity
09:40:36 <quicksilver> doserj: yes, true, I thought it was interesting to stress the implementation.
09:40:42 <quicksilver> mightybyte: use reads not read.
09:40:53 <Saizan_> mightybyte: define readMaybe using reads and then use the
09:40:55 <quicksilver> even better, write maybeRead using reads.
09:40:57 <Saizan_> Maybe nmonad
09:41:19 <quicksilver> maybeRead s = case reads s of [(x,"")] -> Just s ; _ -> Nothing
09:41:38 <quicksilver> then MyType <$> maybeRead (take 2 str) <*> maybeRead (drop 2 str)
09:41:45 <quicksilver> is exactly what you asked for.
09:42:43 <Cale> cnwdup: It seems frustrating to even find the definition of the Window datatype in the Gtk2Hs source code. The person to talk to would be dcoutts, not sure if he's around right now...
09:43:00 <mightybyte> quicksilver: Ok...leveraging the ability of the list monad to represent failure with an empty list.
09:43:19 <quicksilver> no
09:43:19 <Cale> cnwdup: I somehow doubt you'll be able to do this as something separate from Gtk2Hs itself.
09:43:27 <quicksilver> I had an explicit "_" case
09:43:36 <quicksilver> I didn't use any implicit failure reps.
09:44:17 <mightybyte> quicksilver: Right, but that's only possible because reads returns a list.
09:45:00 <quicksilver> yes
09:45:07 <quicksilver> it's not really related to the fact lists are a monad though :)
09:45:11 <quicksilver> only very tangentially.
09:45:12 <Cale> [MyType x y | (x,_) <- reads (take 2 str), (y,_) <- reads (drop 2 str)]
09:45:23 <quicksilver> now that *does* leverage the monad instance.
09:45:25 <cnwdup> Cale, I wouldn't mind adding it to Gtk2Hs. Mh, I think I have to do more research then since I am pretty new to FFI and quite lost looking at the .hsc, chs and .hsc.pp files.
09:45:27 <Cale> If you don't like the use of applicative/monad
09:45:37 <Cale> you can always go with a list comprehension :)
09:46:09 <Cale> cnwdup: yeah, gtk2hs doesn't just use the ffi directly either
09:46:16 <mightybyte> Cale: :)
09:46:54 <mightybyte> quicksilver: Yes.  It's more about lists being something of a superset of Maybe.
09:46:55 <cnwdup> Cale, so hsc and chs files are both source files to produce valid .hs files directly using the ffi?
09:48:05 <Cale> I forget what hsc is, but chs is a file which needs to be processed by c2hs to turn it into Haskell code.
09:48:21 <Cale> I think hsc is closer to C code, iirc.
09:48:38 <Cale> er, no, it doesn't seem so
09:48:54 <glguy> hsc gets converted by hsc2hs and supports a number of preprocessor directives
09:48:55 <DrSyzygyFR> Waiiit!
09:49:00 <DrSyzygyFR> If I derive both Show and Read
09:49:14 <DrSyzygyFR> Shouldn't I be able to read the elements I've shown!?!?
09:49:36 <Cale> DrSyzygyFR: typically, unless there's a custom Show instance involved somewhere
09:50:04 <DrSyzygyFR> >.<
09:50:06 <Cale> (like if it's a parametric type and you applied it to something with a custom show instance
09:50:07 <Cale> )
09:50:09 <DrSyzygyFR> I'm getting failed parses all over.
09:50:12 <dons> ?yow
09:50:12 <lambdabot> Am I elected yet?
09:50:32 <Cale> Am I impeached yet?
09:50:36 <pk> hi
09:50:40 <Cale> hi :)
09:51:26 <DrSyzygyFR> Nope. No custom shows. Everything derives. And the parse fails.
09:51:32 <Cale> huh
09:51:54 <Saizan_> are you reading it back as the same type?
09:52:07 <Cale> Yeah, I suppose that's the next logical thing to check :)
09:52:08 <DrSyzygyFR> Yup.
09:52:23 <DrSyzygyFR> Waaaaiiiiiit
09:52:24 <DrSyzygyFR> No.
09:52:25 <pk> I get a segfault whenever I try to use a stroke font on Opengl/GLUT
09:52:29 <pk> any ideas ?
09:52:32 <DrSyzygyFR> I'm parsing a list of a as an a. DOH!
09:52:45 <DrSyzygyFR> Hah!
09:52:53 <DrSyzygyFR> Using the right type really helped! :-P
09:53:00 <pk> I also have a normal error when I try to use a normal font
09:53:13 <pk> in both case the error is : font not found
09:53:40 <Cale> hmm
09:53:43 <Cale> @paste
09:53:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:54:38 <Cale> I'll try your code if you like... I'm not too familiar with OpenGL/GLUT yet though.
09:55:03 <pk> ok
09:55:44 <burp_> ?src String
09:55:44 <lambdabot> type String = [Char]
09:56:14 <pk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4369
09:56:35 * da-x finally understood that ($ a) means 'a function that when given another function will give 'a' to that function'
09:57:21 <c_wraith> (f $) is a totally awesome operator section. :)
09:58:12 <Berengal> Where would (f $) not be the same as f?
09:58:17 <Cale> pk: It doesn't crash for me...
09:58:20 <haoyu> is there a way to dump ghc parsing tree, with source code line number associated to each node?
09:58:29 <pk> Cale, ok thx
09:58:32 <Cale> pk: But I just get a white window.
09:58:37 <Cale> pk: Is that supposed to be it?
09:58:53 <pk> it is supposed to show some text
09:59:00 <haoyu> I tried ghc -ddump-parsed , but seems it dump out the formatted source code?
09:59:07 <c_wraith> Berengal: it's the same as f.  That's why it's "awesome" :)
09:59:49 <pk> do you have an error on stdout ?
09:59:52 <Berengal> c_wraith: I was just wondering if they could be different in some contexts. After all, '$' == ' ' most of the time, but not always
10:00:14 <Cale> pk: No errors. It just sits there with a perfectly blank white window.
10:00:53 <Saizan_> Berengal: it can make a difference if 'f' is polymorphic enough
10:01:14 <Cale> OpenGL-2.2.1.1  GLUT-2.1.1.2
10:01:39 <Cale> are my package versions. I'm using ghc-6.10.1
10:01:48 <pk> are the fonts in a special freeglut packages ?
10:01:54 <pk> maybe I just don't have them
10:02:09 <Cale> I think the GLUT package expects you to have freeglut installed.
10:02:43 <pk> everything but fonts is working
10:02:53 <Cale> There's also an FTGL package for rendering text using freetype.
10:03:05 <da-x> can someone please explain 'fix f = let x = f x in x' ? the documentation is lacking.
10:03:13 <Berengal> Saizan_: I can't see it. Is it because of MR?
10:03:14 <pk> I'll try that
10:03:16 <pk> thx
10:03:33 <Cale> da-x: It constructs the least-defined fixed point of a function.
10:04:06 <Saizan_> ?type arr
10:04:07 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
10:04:13 <Saizan_> ?type arr id
10:04:14 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b b
10:04:20 <Saizan_> ?type (arr id $)
10:04:22 <lambdabot> forall a. a -> a
10:04:22 <Cale> da-x: If f sends undefined to undefined, then you'll just get an undefined value. However, if f can produce part of its result without examining its argument, you'll get something which is defined.
10:04:35 <Cale> da-x: It's easiest to see what it does through examples, I think...
10:04:38 <Cale> > fix (1:)
10:04:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:05:00 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
10:05:02 <lambdabot>   3628800
10:05:10 <Berengal> > fix (const 5)
10:05:12 <lambdabot>   5
10:05:21 <Saizan_> Berengal: though when used somewhere the context will probably force 'f' to be a function anyway, so it's hard to find a place where this matters
10:05:22 <Cale> Let's examine each of these by using the definition of fix
10:05:34 <Cale> fix (1:) = let x = (1:) x in x
10:05:48 <da-x> okay, I'll dwell on this for a moment. That recursive usage of 'x' in there is a bit confusing.
10:05:56 <Berengal> Saizan_: I think I see it now, though just barely.
10:06:00 <Cale> So, that's obviously going to be the list of all ones.
10:06:08 <Cale> > let xs = 1 : xs in xs
10:06:10 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:06:15 <Cale> yeah?
10:06:53 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10  -- this one is perhaps more complicated looking at first, but if we go carefully, it's not hard to see what happens :)
10:07:03 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
10:07:28 <Cale> -> (let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x) 10
10:07:45 <Cale> -> (let x = (\n -> if n == 0 then 1 else n * x (n-1)) in x) 10
10:08:01 <Cale> -> (let x n = if n == 0 then 1 else n * x (n-1) in x) 10
10:08:04 <edwardk> ah, woot, if you extend the signature of Foldr slightly you can use the density comonad of its underlying functor instead, and duplicate becomes cheaper, but the type gets no bigger
10:08:09 <Cale> -> let x n = if n == 0 then 1 else n * x (n-1) in x 10
10:08:22 <Cale> and so that's exactly like defining the factorial function recursively
10:08:35 <edwardk> data DensityFoldr a b = forall c. DensityFoldr (a -> c -> c) c ((a -> c -> c) -> c -> b)
10:08:49 <edwardk> then duplicate (DensityFoldr f z) = DensityFoldr f z DensityFoldr
10:08:54 <Cale> da-x: was that possible to follow? :)
10:09:03 <edwardk> so you get a cheaper comonad instance
10:10:32 <Cale> da-x: In general,  fix (\f x -> ... f ...) is the same as  let f x = ... f ... in f
10:10:57 <Berengal> Does "least fixed point" mean "least-fixed point" or "least fixed-point"?
10:11:00 <Berengal> The latter makes more sense...
10:11:04 <Cale> The latter.
10:11:25 <Cale> and I find it's usually best to say least-defined fixed-point
10:11:40 <Berengal> Yeah, that's what I thought least meant
10:11:58 <Cale> It does, but that's not always clear if there's another order hanging around :)
10:12:08 <Berengal> True
10:12:18 <Berengal> Also, I assume every function has a least fixed point?
10:12:40 <Berengal> Which would imply every function has a fixed point?
10:12:41 <Cale> Yes, in Haskell's semantics, because every type has _|_ in it
10:13:15 <Cale> Well, that's not directly the reason :)
10:13:19 <tromp> _|_ is not always a fixed point
10:13:29 <Cale> Right, but it tends to be when nothing else is :)
10:13:30 <Berengal> Not every function can return _|_
10:13:31 <tromp> only for strict functions
10:14:26 <Berengal> What I like best about fix is its type
10:14:34 <Berengal> It seems to produce something from nothing
10:14:40 <Cale> If we had types without _|_, there would almost certainly be functions with no fixed point (unless we also restricted the language in other ways)
10:15:54 <Cale> :t fix id
10:15:55 <lambdabot> forall a. a
10:16:14 <Berengal> fix id is the other undefined
10:19:06 <Cale> So if we wanted to remove _|_, we'd also have to remove fix and general recursion.
10:19:45 <roconnor> good ridance
10:20:11 <Berengal> Yeah, the simple fact that turing machines can run forever means any turing-complete language needs to have _|_
10:20:22 <glguy> yeah, we need more jokes about how you *really* can't do anything in a pure language like Haskell
10:20:45 <Gracenotes> Charity doesn't have _|_
10:21:02 <Gracenotes> ..so I've heard
10:21:30 <Cale> Charity can't encode its own interpreter :]
10:22:06 <Cale> ..so I've heard
10:22:14 <Gracenotes> all these dirty rumors!
10:22:19 <NEEDMOAR> Haha
10:22:48 <pk> Cale, did you run it interpreted ?
10:23:00 <Cale> pk: yeah
10:23:25 <Cale> I'll try compiled now
10:23:33 <Cale> Exactly the same
10:23:36 <pk> Cale, this is very strange. I get the same problem on another computer.
10:24:01 <pk> even when it's not my own code ?
10:24:11 <Cale> hm?
10:24:12 <pk> not ?, !
10:24:41 <Cale> The behaviour seems the same, a blank white window, whether interpreted or compiled with or without the threaded runtime.
10:24:48 <pk> ok thx
10:26:01 <Cale> pk: what versions of the OpenGL and GLUT libraries are you using?
10:26:29 <Cale> (and what GHC, perhaps)
10:26:41 <pk> GLUT 2.2.1.2
10:26:47 <pk> ghc 6.10.1
10:27:00 <pk> Opengl 2.2.1.1
10:27:03 <Cale> Oh, interesting, my GLUT is older than that.
10:27:17 <Cale> 2.1.1.2
10:27:32 <pk> I'm on ubuntu
10:27:39 <Cale> me too
10:29:01 <pk> are there some compiled programs for testing out one's freeglut install ?
10:29:21 <kadaver> hmm, haskell is really a great language to get you thinking about good software design and it jsut becomes so obvious when you go from haskell to java.
10:29:41 <copumpkin> kadaver++
10:29:43 <Botje> you don't just "go" from haskell to java
10:29:47 <Botje> you're dragged kicking and screaming.
10:29:51 <litb> ~kadaver++
10:29:53 <kadaver> OO just makes less sense to me very time I use it
10:29:53 <kadaver> @quote OO
10:29:54 <lambdabot> dcoutts says: (:[]) looks like a monster
10:30:01 <litb> oO
10:30:06 <litb> @quote litb
10:30:07 <lambdabot> No quotes match. You type like i drive.
10:30:10 <Botje> evil robot monkey!
10:30:14 <litb> oO
10:30:20 <Cale> @quote java
10:30:20 <lambdabot> shapr says: [on causing trouble in #java] I told a java newbie to use a parser monad...
10:30:23 <Cale> @quote java
10:30:24 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
10:30:24 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
10:30:27 <litb> oh
10:30:43 <Cale> @quote genders
10:30:44 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
10:31:02 <conal> yow
10:31:09 <conal> :)
10:31:20 <Cale> Hi Conal!
10:31:26 <conal> Cale: hi!
10:31:30 <Cale> Did you manage to look at my bug reports?
10:31:46 <conal> yeah
10:31:51 <Berengal> I told a java programmer to use a parser monad today, and he thanked me for it
10:33:23 <Cale> Do you have the same performance issue I do in the one which adds the mouse and keyboard input? It seemed strange to me, because they individually ran so smoothly.
10:33:52 <MyCatVerbs> Berengal: parser monad in Java?
10:33:54 <MyCatVerbs> Heehee.
10:34:11 * MyCatVerbs was just struck by the thought of how hilarious Control.Arrow would look if you wrote it up in Java Generics.
10:34:39 <Berengal> MyCatVerbs: I told him to use Haskell, then showed him a short parser I'd written in parsec
10:35:02 <conal> Cale: i didn't try it out.  could well be an old laziness problem with reactive.
10:35:32 <Cale> conal: Should I try out the darcs versions of things? Is there a repository of compatible development versions?
10:35:58 <conal> Cale: i'm afraid there isn't, right now.  :(
10:36:36 <Gracenotes> woot, Sun sent me a priority code to register for JavaOne! Surely I should take advantage of this offer immediately!
10:36:47 <cooldude127> Gracenotes: lol got that too
10:36:54 <Raevel> what is that
10:37:45 <Gracenotes> uh... apparently I'm a Sun Developer Network member
10:38:15 <Gracenotes> the sent me an email August 2007
10:38:19 <c_wraith> javaone is a spendy java conference of uncertain actual value. :)
10:38:21 <Gracenotes> wtf
10:38:45 <Gracenotes> c_wraith: yeah, non-academic conferences, meh
10:38:46 <Raevel> as long as it has the enterprisey feel i'm going
10:39:04 <p_l> hmmm... any haskell teaching in Edinburgh?
10:39:22 <Berengal> Ugh, enterprise was the main reason I started Haskell...
10:39:23 <Gracenotes> not to say that academic conferences are the bee's knees either
10:39:26 <da-x> Cale: I think I got it, to some degree.
10:39:28 <MyCatVerbs> Gracenotes: perhaps you attempted to download Solaris or something at some vague point in the past?
10:39:45 <Gracenotes> no, not Solaris... hm... it might have been a Java forum
10:40:01 <Gracenotes> an account I never used
10:40:52 <Gracenotes> lol http://www.sun.com/images/l5/l5_java1.09.jpg
10:41:23 <Gracenotes> surely a more appropriate image than http://www.sun.com/images/l5/l5_javame3.0.jpg anyway
10:41:56 <Berengal> Why horses of all things?
10:42:48 <vixey> that guy shouldn't be trusted with lasers
10:45:12 <sbahra>  /j #haskell-blah
10:51:22 <cooldude127> is there a succinct way to apply a list of functions to the same data and get the results as a list
10:51:38 <cooldude127> wait, i might now this already
10:51:46 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
10:51:47 <lambdabot>   [5,7,10,25,32]
10:51:54 <cooldude127> oh awesome
10:51:57 <Cale> > map ($ 5) [id, (+2), (*2), (^2), (2^)]
10:51:59 <lambdabot>   [5,7,10,25,32]
10:52:02 <cooldude127> i was thinking something like the map one
10:52:17 <Cale> sequence makes use of the ((->) e) monad though
10:52:26 <Cale> So you need to import Control.Monad.Instances
10:52:27 <cooldude127> is that important?
10:52:29 <cooldude127> oh ok
10:52:46 <Cale> (ought to be in the Prelude, but it's not)
10:53:29 <cooldude127> got it
10:53:54 * Berengal is very fond of the ((->) e) monad
10:54:04 <copumpkin> me too
10:54:27 <Berengal> And it's applicative
11:00:42 <edwardk> heya pumpkin
11:00:46 <copumpkin> yo yo
11:00:47 <copumpkin> sup?
11:00:54 <edwardk> i have lots of info for you re folds ;)
11:01:13 <copumpkin> oh yummy
11:01:17 <copumpkin> they're not even mine :P
11:01:39 <edwardk> moving to #haskell-in-depth
11:04:21 <Cale> copumpkin is folds?
11:04:38 <Cale> ah, regarding folds :)
11:11:26 * cooldude127 tries to think of a decent name for a function: f = and . sequence
11:11:41 <wjt> @ty and . sequence
11:11:43 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[a]'
11:11:43 <lambdabot>       Expected type: [[a]] -> [Bool]
11:11:43 <lambdabot>       Inferred type: [[a]] -> [[a]]
11:12:00 <haoyu> hmm... any idea about how to use GHC API to parse Haskell source code?
11:12:05 <vixey> error = and . sequence :p
11:12:34 <cooldude127> f x = and . sequence x
11:12:47 <wjt> @ty and . sequence ?x
11:12:49 <lambdabot> forall a. (?x::[a -> Bool]) => a -> Bool
11:13:07 <wjt> allSatisfy ?
11:13:08 <c_wraith> I haven't seen that syntax before...
11:13:21 <cooldude127> wjt: that might be good
11:13:49 <wjt> hmm, that's not really right
11:14:51 <vixey> :t all
11:14:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:15:18 <vixey> :t flip all
11:15:19 <lambdabot> forall a. [a] -> (a -> Bool) -> Bool
11:15:28 <cooldude127> not quite right
11:16:12 <vixey> all :: (a -> Bool) -> [a] -> Bool
11:16:20 <vixey> ___ :: [a -> Bool] -> (a) -> Bool
11:16:44 <cooldude127> yeah what do we call this
11:17:35 <MyCatVerbs> :t \l a -> all ($ a) l
11:17:36 <lambdabot> forall a. [a -> Bool] -> a -> Bool
11:17:38 <vixey> it seems like you can define ___ using all, but not define all using ___
11:18:05 <MyCatVerbs> @let threeUnderScores l a = all ($ a) l
11:18:06 <lambdabot>  Defined.
11:18:39 <vixey> @let ___ l a = all ($ a) l
11:18:40 <lambdabot>  Defined.
11:19:26 <cooldude127> i want a name :)
11:19:33 <Berengal> fred
11:19:38 <cooldude127> is allSatisfy ok?
11:20:21 <Berengal> I'd go for allSatisfied
11:20:33 <vixey> all_
11:20:40 <kadaver> if I have some huge matrices and once I do something to it I want to destroy the old one. how do I solve that? I dont? does ghc figure all sharing out? like if I have a matrix Map (Int,Int) Double or a graph Map a (Set a), and just update one index, do they share sturcture for everything except the updated value then?
11:21:03 <Cale> kadaver: basically, yes
11:21:16 <cooldude127> kadaver: have you looked at hmatrix for doing matrix stuff?
11:21:24 <Cale> kadaver: everything but the path from the root to the vertex you update
11:21:39 <neoswish> was anyone installed gtk2hs on windows with ghc 6.10.2? installer dont registering packages for some reason
11:21:43 <kadaver> but lets say I do something that transforms all elements of the matrix and I dont need the old one anymore and my computer cant hold them both in memory,can I force the old one to be GCed?
11:22:09 <dcoutts> neoswish: oh, did they release a new installer for 6.10.2 already?
11:22:29 <neoswish> no, i tried old
11:22:36 <kadaver> cooldude127: yes but i didnt get it going on windows+mingw. this was a general question anyway.
11:22:46 <Cale> kadaver: It ought to be GCed anyway.
11:22:46 <cooldude127> got it
11:22:58 <kadaver> ok
11:23:00 <Cale> kadaver: GHC is relatively good at collecting short-lived objects.
11:23:24 <Berengal> Augh! I can't remember the nifty powerset function, and it's bugging me alot :/
11:23:30 <neoswish> dcoutts, i cant compile it also on windows =(
11:23:41 <Cale> > filterM (const [True, False]) [1,2,3]
11:23:43 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:23:53 <Berengal> Thank you!
11:24:11 <skorpan> :t lines
11:24:13 <lambdabot> String -> [String]
11:24:14 <Cale> kadaver: But if you determine that you really need mutation, of course you could go with something like STArray.
11:24:29 <dcoutts> neoswish: if you've got the installer built for 6.10.1 and you're using it with 6.10.2 then it'll tell you at startup that your ghc version is not right.
11:24:51 <Cale> kadaver: there's a proper matrix library or two on Hackage which should be reasonably efficient as well, I think.
11:24:54 <kadaver> main = do m <- makeMatrix; s <- svd m;dosomething with s-vals; print s //// but will it there? svd can take a long time so lets say dosomething with s-vals does too, will m be destroyed then since it is used anymore?
11:25:24 <neoswish> dcoutts, are there many differences?)
11:25:48 <dcoutts> neoswish: all ghc builds are binary-incompatible. ghc will refuse to use .hi files from different versions.
11:25:52 <Cale> kadaver: Well, if it's in the IO monad, you could just use an IOArray and mutate...
11:26:23 <MyCatVerbs> @djinn ((a -> Bool) -> Bool) -> (a -> Bool) -> Bool
11:26:23 <lambdabot> f a = a
11:26:43 <Cale> kadaver: So, I'm not sure exactly what you're asking. If there's no code which references something anymore, it typically becomes garbage.
11:26:48 <MyCatVerbs> @djinn a -> ((a -> Bool) -> Bool)
11:26:48 <lambdabot> f a b = b a
11:27:02 <MyCatVerbs> @pl \a b -> b a
11:27:03 <lambdabot> flip id
11:27:15 <Cale> kadaver: Are you having a specific problem with memory usage?
11:27:24 <kadaver> no but i might
11:27:34 <kadaver> get one
11:27:50 <kadaver> trying to do netflix in haskell. i have SVD figured out now and will try to implement it in haskell
11:28:34 <Cale> kadaver: Maybe try hmatrix
11:28:45 <Cale> kadaver: It's a binding to GSL.
11:30:26 <cooldude127> hmatrix is nice
11:31:30 <MyCatVerbs> vixey: you can define all in terms of ___, but I think you need a map.
11:32:32 <MyCatVerbs> :t \f l -> ___ (map (flip id) l) f
11:32:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:32:51 <vixey> oh right very nic
11:32:52 <vixey> oh right very nice
11:33:21 <MyCatVerbs> vixey: not entirely. I should've been able to work that out in thirty seconds flat, but my brain just doesn't want to cooperate today. :)
11:33:53 <vixey> :t \f l -> (\l a -> all ($ a) l) (map (flip id) l) f
11:33:55 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:35:09 <MyCatVerbs> I name this combinator...
11:35:24 <MyCatVerbs> @let ______ f l = ___ (map (flip id) l) f
11:35:25 <lambdabot>  Defined.
11:36:13 <MyCatVerbs> vixey: brain still not cooperating, I can't unravel that. =)
11:36:47 <dschoepe> Is there some way to tell ghc to cache function calls for a specific function or do I have to memoize the function "manually"?
11:37:27 <MyCatVerbs> dschoepe: in simplistic theory, you have to memoize the function "manually".
11:37:43 <cooldude127> is there a way to do that in haskell? write a memoizing function?
11:37:52 <vixey> yes
11:37:57 <MyCatVerbs> dschoepe: in more in-depth theory, it turns out that there are really nifty ways to automatically memoize Haskell functions, which abuse the type system quite handily.
11:39:17 <MyCatVerbs> http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/ <- as with many awesome things, this one is thanks to conal. :)
11:39:46 <MyCatVerbs> dschoepe: and the Hackage package is over here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MemoTrie
11:40:04 <MyCatVerbs> Oh, my bad. Thanks to conal and sjanssen. ^^
11:41:07 <ehird> Do the Data.Map functions non-tail-recurse? I'm getting stack overflows with a gigantic map.
11:41:34 <MyCatVerbs> ehird: I would guess that they're fairly lazy, so you end up with enormous thunks.
11:42:06 <dschoepe> Yes I found that package, but I believe I encountered a bug involving very big Integers: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4370#a4370
11:42:11 <MyCatVerbs> ehird: I ran into the same problem myself building up (crap) tries at one point. Making the *entire* data structure completely strict solved it, albeit at some cost.
11:42:34 <ehird> MyCatVerbs: I can't make a Map strict easily can I?
11:43:05 <MyCatVerbs> No, but it might have an NFData instance, in which case you can hit it with Control.Parallel.Strategy.rnf
11:43:19 <MyCatVerbs> dschoepe: bummer. No clue, sorry.
11:44:10 <dschoepe> MyCatVerbs: Can you suggest another way to memoize such a function? The normal list approach seems unsuitable, since the arguments are larger than Int's maximum value.
11:45:29 <zoheb> Integer
11:45:54 <MyCatVerbs> dschoepe: passing around a Data.Map seems like the obvious option.
11:45:58 <dschoepe> zoheb: I am using Integer, I just don't know how to memoize this function in my paste.
11:46:46 <zoheb> I just logged in -> wheres the paste?
11:47:00 <dschoepe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4370#a4370
11:47:10 <MyCatVerbs> @where hpaste
11:47:10 <lambdabot> http://hpaste.org/
11:47:12 <vixey> hi zoheb
11:47:32 <zoheb> hi vixey
11:47:41 <dschoepe> MyCatVerbs: Ah, right, but there's no way to avoid this additional Map that gets passed around?
11:48:03 <dschoepe> (except unsafePerformIO-ish stuff)
11:48:08 <zoheb> no, thats the magic of purity :)
11:48:35 <MyCatVerbs> dschoepe: no, and I think the trie stuff relies on unsafePerformIO.
11:48:43 <MyCatVerbs> s/I think //, actually.
11:49:06 <zoheb> If this looks like its going to bug you a lot, it is a good time to learn about monads and monad transformers
11:49:13 <MyCatVerbs> It's baaasically legal, but it's one of those places where GHC has more bugs than others.
11:49:32 <zoheb> whats trie?
11:49:53 <dschoepe> MyCatVerbs: It does? I can't find it the memo-trie source.
11:50:38 <dschoepe> MyCatVerbs: Doesn't GHC assume lots of things that unsafePerformIO violates?(Like only one RealWorld#)
11:51:13 <dschoepe> So it would violate purity/ref. transparency and therefore not be legal, or am I missing something?
11:51:48 <Berengal> unsafePerformIO just means it's not guaranteed to be safe, not that it's neccessarily evil
11:52:23 <roconnor> save evil for the MR
11:53:36 <zoheb> what about building an infinite 2 dim array
11:53:41 <MyCatVerbs> dschoepe: at least I presumed it does, since I think it's impossible for it to actually do anything useful without it. Now I'm just reading the MemoTrie sources with a befuddled expression on my face. :)
11:53:54 <zoheb> and have the memo function index into the array?
11:54:10 <Saizan> MyCatVerbs: it just constructs an infinite immutable trie
11:54:17 <zoheb> I guess arrays are fixed bound
11:54:21 <MyCatVerbs> zoheb: 'fraid not, arrays have fixed bounds.
11:54:27 <Saizan> well infinite when needed
11:54:43 <MyCatVerbs> Saizan: oh right of course. Thank you.
11:55:28 <zoheb> or even an extremely large bound might work, I did not follow the infinite when needed idea
11:56:01 <MyCatVerbs> dschoepe: ah, that might be why it doesn't work for Integers. The HasTrie instance doesn't actually handle enormous numbers correctly.
11:56:06 <int-e> dschoepe: the HasTrie instance for Integer is just broken - it converts Integer to Word.
11:56:08 <Berengal> Tries are non-strict, which means they can be infinite
11:56:17 <Berengal> Like lists
11:56:23 <MyCatVerbs> dschoepe: it just uses fromIntegral to convert the Integer to a Word, and then uses the Word instance. So anything outside of Word's range gets clipped.
11:56:32 <dschoepe> Ah, okay.
11:57:14 <MyCatVerbs> I suppose you could rewrite that by making it "chunk" the Integer or something, heh. :)
11:59:25 <int-e> dschoepe: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4370#a4371 is a trie that would work for Integer. (populate corresponds to trie, while lookup corresponds to untrie)
11:59:40 <dschoepe> int-e: Thanks
11:59:47 <int-e> and I'm using 'trie' in a loose sense.
12:01:20 <|2dman|> can someone please tell me why I'm having such difficulty with dates and times in Haskell?
12:01:29 <|2dman|> I just read up on why Data.Time was moved out of GHC
12:01:32 <|2dman|> so then I thought I'd install it
12:01:43 <|2dman|> so apparently it's undocumented how to parse strings into dates / times
12:01:48 <|2dman|> so then I thought maybe DateTime would be cool
12:01:53 <|2dman|> but it depends on QuickCheck
12:01:59 <|2dman|> which doesn't compile (at least with my 6.10.2
12:02:00 <|2dman|> )
12:02:03 <|2dman|> am I insane?
12:02:05 <voker57_> can you partially apply function with not last argument omitted? Like map (zip _ something) somethingelse
12:02:24 <kadaver> is Data.Map slower than a redblacktree? why does people say it i slow? slow for a searchTree or slow compared to a mutable hashtable?
12:02:47 <dschoepe> voker57_: you can use flip
12:03:08 <dschoepe> voker57_: but sometimes this looks ugly
12:03:08 <voker57_> @type flip
12:03:09 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:03:19 <cooldude127> |2dman|: apparently there's a parsedate library on hackage
12:03:19 <voker57_> thanks
12:03:27 <dschoepe> @pl \x -> map (zip x foo) bar
12:03:27 <lambdabot> flip map bar . flip zip foo
12:03:29 <zoheb> @type flip map
12:03:30 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
12:03:31 <MyCatVerbs> voker57_: (map (flip zip something)), or (map (`zip` something))
12:03:49 <|2dman|> cooldude127: I will try that, then.  Am I the only beginner who tries to use dates?
12:03:53 <cooldude127> infix + sections often ends up prettier than flip
12:04:05 <cooldude127> |2dman|: idk, i just did some searching. hasn't come up for me
12:04:17 <dschoepe> MyCatVerbs: then the argument would still be outside the zip
12:05:07 <zoheb> @pl \x y-> map (zip x) y
12:05:07 <lambdabot> map . zip
12:05:32 <zoheb> @pl \x y z -> map (zip z x) y
12:05:32 <lambdabot> flip . (map .) . flip zip
12:05:44 <dschoepe> That's what I meant by ugly :)
12:05:58 <dschoepe> @pl \a b c d e -> e b c a d
12:05:58 <lambdabot> ((flip .) .) . flip (flip . (flip .) . flip . flip id)
12:06:05 <cooldude127> wowwwww
12:06:26 <|2dman|> cooldude127: oh, I see.  This is all based on System.Time, instead of Data.Time.
12:06:41 <cooldude127> hmm i have no idea
12:06:45 <zoheb> has anyone tried using haskeline on windows?
12:07:02 <|2dman|> parsedate adds System.Time.Parse, and produces CalendarDate types
12:07:10 <|2dman|> maybe I'll have better luck with this
12:07:11 <|2dman|> thanks
12:09:37 <cooldude127> |2dman|: actually, apparently new code should not use parsetime
12:09:59 <cooldude127> the time library is what you should use, looks like Data.Time.Format is what does the parsing
12:10:10 <|2dman|> cooldude127: right -- what I found suggests that System.Time is the bad way to do things
12:10:29 <|2dman|> but if I have to install 6 packages to use the "right way", it's close to not being worth it
12:10:51 <quicksilver> time is one package.
12:11:01 <quicksilver> and it comes with every version of GHC ever packages except 6.10.2
12:11:06 <|2dman|> right
12:11:09 <|2dman|> except the one I am using
12:11:27 <|2dman|> so I can install the time package from hackage
12:11:31 <quicksilver> yes.
12:11:34 <|2dman|> but its API is painful to me
12:12:24 <|2dman|> I want to parse a string to a date, and apparently I have to make 4-5 function calls through a couple libraries in the IO monad in order to do that
12:13:14 <|2dman|> and for the time package, when I look through the "use cases" documentation on its homepage, it says, "TODO: Parsing"
12:14:57 <voker57_> @djinn [(a, b)] -> [a]
12:14:57 <lambdabot> Error: Undefined type []
12:15:13 <voker57_> hm
12:15:35 <skorpan> @djinn (List (Pair a b)) -> List a
12:15:35 <lambdabot> Error: Undefined type List
12:17:16 <|2dman|> I guess I'm weighing the effort of understanding the "right" way to do dates in 6.10, writing my own so I can do the blasted date subtraction I need to do, or giving up and writing it in Ruby
12:22:36 <Jedai> |2dman|: parsing is in Data.Time.Format
12:25:28 <Jedai> > readTime defaultTimeLocale "%d/%m/%y" "14/06/85" :: Day
12:25:30 <lambdabot>   Not in scope: `readTime'Not in scope: `defaultTimeLocale'Not in scope: type...
12:26:12 <cooldude127> > import Data.Time
12:26:14 <lambdabot>   <no location info>: parse error on input `import'
12:26:19 <cooldude127> :( lambdabot fail
12:26:20 <Jedai> Time locale comes from System.Locale, readTime from Data.Time.Format
12:26:53 <Jedai> cooldude127: you can't import arbitrary modules in lambdabot (though a lot are already charged) question of security
12:27:03 <cooldude127> yeah figured
12:31:16 <Jedai> |2dman|: The interface of the time format doesn't seems that complex ? What's your problem ? Do you need an "intelligent" library (something that understand "2 days ago") ?
12:33:03 <skorpan> @index io
12:33:03 <lambdabot> bzzt
12:33:08 <skorpan> @hoogle io
12:33:08 <lambdabot> module Data.Array.IO
12:33:08 <lambdabot> module System.IO
12:33:08 <lambdabot> Prelude data IO a
12:33:17 <skorpan> :t io
12:33:18 <lambdabot> Not in scope: `io'
12:33:23 <skorpan> then what the hell is wrong
12:33:27 <skorpan> > let io = liftIO
12:33:28 <lambdabot>   <no location info>: parse error on input `;'
12:33:56 <skorpan> stupid monomorphism restriction
12:33:59 <skorpan> @where monomorphism
12:33:59 <lambdabot> I know nothing about monomorphism.
12:34:03 <skorpan> @where monomorphism restriction
12:34:03 <lambdabot> I know nothing about monomorphism.
12:34:04 <Deewiant> > let io = liftIO in 1
12:34:05 <lambdabot>   Add a type signature
12:34:16 <skorpan> http://haskell.org/haskellwiki/Monomorphism_restriction
12:34:36 <|2dman|> Jedai: no... that's not what I'm looking for
12:34:49 <|2dman|> I want something like:  String -> Date
12:34:56 <|2dman|> where I can give it "2009-01-01"
12:35:05 <Jedai> |2dman|: Well that's readTime
12:35:37 <Jedai> |2dman|: just like my expression :
12:35:40 <Jedai> > readTime defaultTimeLocale "%d/%m/%y" "14/06/85" :: Day
12:35:42 <lambdabot>   Not in scope: `readTime'Not in scope: `defaultTimeLocale'Not in scope: type...
12:36:14 <Jedai> |2dman|: Except your format is "%Y-%m-%d"
12:36:44 <|2dman|> so where the heck is defaultTimeLocale?
12:36:49 <|2dman|> it's not in scope yet...
12:36:54 <Jedai> |2dman|: in System.Locale
12:37:03 <|2dman|> ah
12:37:14 <Jedai> |2dman|: (note that the Haddock doc got links that tell you that directly
12:37:14 <|2dman|> it was the type specifier :: Day that I was missing
12:37:42 <|2dman|> remember (as stated above) I'm a Haskell beginner
12:37:51 <Jedai> |2dman|: readTime works for every type instance of the ParseTime typeclass, which means every date types from the time package
12:37:51 <|2dman|> I could not understand what the ParseTime part was
12:38:49 <|2dman|> since I couldn't get that to work (and didn't know how to understand why it didn't work), I went on the rabbit trail
12:39:11 <Jedai> |2dman|: It's a good bit like the Read typeclass
12:39:25 <Jedai> > read "40000000000" :: Double
12:39:27 <lambdabot>   4.0e10
12:39:33 <Jedai> > read "40000000000" :: Integer
12:39:35 <lambdabot>   40000000000
12:39:37 <Jedai> > read "40000000000" :: Int
12:39:39 <lambdabot>   40000000000
12:39:49 <|2dman|> thanks Jedai
12:39:49 <Jedai> > read "40000000000" :: Word32
12:39:51 <lambdabot>   1345294336
12:40:04 <|2dman|> so it looks like I can do: diffDays d1 d2 and get out a number of days too
12:40:07 <|2dman|> which is exactly what I need to do
12:40:18 <Jedai> |2dman|: You're welcome :) Good luck with your Haskell beginnings
12:45:49 <cedricshock> Is there a more efficient way of keeping bi-directional lists in a pure language than a tuple of the predecessors and successors of the current position (which wastes space on the order of depth into list per pointer).
12:46:42 <mauke> how about a zipper?
12:46:54 <skorpan> i thought that was a zipper
12:46:54 <BONUS> yes, isnt there a wiki article on that
12:47:19 <vixey> that IS a zipper
12:47:21 <mauke> a zipper isn't recursive
12:47:25 <BONUS> http://haskell.org/haskellwiki/Tying_the_Knot
12:48:01 <BONUS> zippers are orthogonal to this imo
13:05:18 <vixey> @farmer
13:05:18 <lambdabot> Nothing is good enough for our customers.
13:05:23 <vixey> @farmer
13:05:23 <lambdabot> My head is closing in on me.
13:05:36 <Deewiant> @ghc
13:05:36 <lambdabot> ghc says: Implicit parameters escape from the monomorphic top-level binding(s)
13:07:51 <cedricshock> I figured it out, you can recursive let the previous part of the list into the next double linker.  This has a really clean example: http://www.comlab.ox.ac.uk/people/duncan.coutts/papers/recursive_data_structures_in_haskell.pdf
13:14:58 <wli> > let a = array (0, 20) ((0, 0) : (1, 1) : [ (i, case i `divMod` 2 of { (q, 0) -> let s = a ! q ; t = a ! (q - 1) in s * (2 * t + s) ; (q, 1) -> let s = a ! q ; t = a ! (q + 1) in s * s + t * t }) | i <- [2..20]]) in a
13:14:59 <lambdabot>   array (0,20) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
13:18:38 <roconnor> QtPlaty[HireMe]: where are you looking to be hired -- I don't have job to offer though.
13:19:22 <yitz> wli: hard to imagine when it would make sense to memoize when using the fast O(log n) fibo algorithm. to make it worthwhile, you would have to be computing far more fibos than you'll ever have room for in memory.
13:19:48 <skorpan> :t foldM
13:19:49 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:20:14 <wli> yitz: Just tying the knot for the purposes of knot-tying examples.
13:20:15 <skorpan> so the first argument is the function, the third is the list of stuff to fold, but what is the second argument?
13:20:23 <yitz> i see.
13:20:54 <yitz> skorpan: initial value, like in any fold
13:22:13 <skorpan> of course... durr
13:23:01 <DrSyzygyFR> If I have more esoteric needs for sorting my thingies than what is easily put in an Ord instance, is there something that'll mimic Data.Map but give me more influence over the comparison it uses?
13:23:51 <yitz> DrSyzygyFR: like what?
13:24:05 <Gabbie> Tuba FTW
13:24:19 <DrSyzygyFR> Something like a MapWith (a -> a -> Ordering) k a
13:24:40 <byorgey> DrSyzygyFR: I don't see how that is possible. if you can provide an  a -> a -> Ordering  function, then can't you provide an Ord instance?
13:24:53 <yitz> DrSyzygyFR: so why can't you make that your Ord instance?
13:24:54 <DrSyzygyFR> byorgey: I'm parametrizing my ordering.
13:25:16 <seliopou> -_-
13:25:17 <seliopou> O_O
13:25:18 <seliopou> what?
13:25:55 <seliopou> Ohhh
13:26:00 <byorgey> ah, well, you can always make a newtype which witnesses the ordering for each particular value of the parameter.
13:26:01 <seliopou> funky
13:26:08 <DrSyzygyFR> I'm implementing gröbner bases. So the same types (the monomials) would be ordered in different ways depending on what you want to do; but it doesn't make sense to proliferate all possible orders...
13:26:14 <byorgey> but it's a bit annoying to have to be dealing with the newtype constructors everywhere.
13:26:22 <seliopou> what byorgey says
13:26:22 <DrSyzygyFR> So instead, I've generated a typeclass for parametrized orderings.
13:26:46 <DrSyzygyFR> Where it provides a compare function dependent on the ordering-type as such.
13:27:29 <yitz> DrSyzygyFR: create a wrapper data type that has an object plus the parameter, then define a single Ord instance for that.
13:28:13 <wli> DrSyzygyFR: I wouldn't use an Ord instance, but rather take comparator functions everywhere.
13:28:15 <amckinley> hey, easy parsec question: im mapping symbol over a list of strings of possible option names. the problem is that symbol will match a string thats only a prefix of a longer option name. what function should i be using instead?
13:28:36 <DrSyzygyFR> wli: You have a version of Data.Map that will let me provide comparators?
13:28:49 <DrSyzygyFR> wli: Which was my original question...
13:29:15 <yitz> DrSyzygyFR: you're right, though, I've always thought that it would sometimes be convenient to have direct order-function versions of some of the collection types that don't require an instance.
13:29:18 <wli> DrSyzygyFR: No, but what I'd do is something like this:
13:29:21 <byorgey> DrSyzygyFR: actually, it shouldn't be too hard to implement your own such version as a thin wrapper around Data.Map
13:29:26 <wli> DrSyzygyFR: http://wli.pastebin.com/m2a36b7e3
13:29:44 <byorgey> that would hide all the newtyping ugliness inside the order-parameterized map module.
13:30:24 <byorgey> of course, it would be annoying to duplicate all the Map functions.
13:30:58 <yitz> wli: where to look in that?
13:31:20 <DrSyzygyFR> wli: That's kinda similar to what I'm doing. :-P
13:31:45 <wli> DrSyzygyFR: That's the idea.
13:32:24 <DrSyzygyFR> wli: Though don't you get annoying performance for your leadTerm implementation?
13:33:02 <DrSyzygyFR> the whole idea (one of) with using Map was to make leading terms very easy to find...
13:33:08 <DrSyzygyFR> And to keep track of pairs of stuff.
13:33:26 <wli> I use Map, but don't rely on the ordering it assumes.
13:34:03 <DrSyzygyFR> wli: My main issue is that regardless of how I do my ordering computations, it will take a LOT of time to compare things.
13:34:32 <DrSyzygyFR> So what I want to do is to somehow cache the things that get generated from my trees in order to compare them, and only go on that...
13:34:47 <DrSyzygyFR> But I can't figure out how to make Map do that.
13:35:22 <byorgey> DrSyzygyFR: so you will actually want to use functions like minView?
13:35:52 <DrSyzygyFR> maxWith actually, but yeah.
13:35:54 <byorgey> i.e. is it important that the ordering used by the map is actually the same as the ordering you care about?
13:35:57 <byorgey> ok
13:36:06 <byorgey> I see.
13:37:30 <mofmog> so... python decorators are basically just combinators
13:37:37 * mofmog is asking about python in a haskell channel
13:38:13 <yitz> mofmog: well, they don't really compose well
13:38:20 <skorpan> yitz++ :)
13:38:32 <mofmog> that is true, so they're dumb combinators
13:38:39 <skorpan> dumbinators?
13:41:14 <yitz> amckinley: you're using "string"?
13:41:44 <amckinley> yeah, since symbol name = lexeme (string name)
13:42:59 <amckinley> yitz: i was thinking about just sorting the list of names by length to hack around it, but that seems less than ideal :)
13:43:21 <yitz> amckinley: so how about string (optname) >> (whatever ends the symbol)?
13:43:42 <DrSyzygyFR> byorgey: For now it runs. But I seem to be looking at weeks or months of computation time for most sensible questions to ask.
13:43:52 <byorgey> yikes.
13:43:53 <DrSyzygyFR> And it would be good to cut things from, say, 4 months to 3.
13:43:57 <byorgey> hehe
13:44:12 <byorgey> DrSyzygyFR: just get yourself one of them newfangled quantum computers.
13:44:21 <DrSyzygyFR> Yeah ... no. Won't help.
13:45:53 <amckinley> yitz: the name is always terminated by whitespace. here's the function im using to make my parsers from my list of strings: make_parser l = (foldl1 (<|>) (map (try . symbol) l))
13:46:30 <amckinley> and changing that to (try  (symbol >> space)) doesnt type check
13:47:22 <yitz> try . (>> space) . symbol
13:47:40 <DrSyzygyFR> What's the best way to uninstall a cabal package?
13:48:03 <dcoutts> DrSyzygyFR: ghc-pkg unregister and if you want to save disk space then rm the files
13:48:12 <DrSyzygyFR> Aight.
13:48:30 <DrSyzygyFR> Thanks!!
13:49:25 <amckinley> yitz: nope: space has the type CharParser st Char and symbol has String -> CharParser () String
13:50:32 <yitz> amckinley: you can use choice instead of foldl (<|>)
13:50:49 <yitz> amckinley: so many1 space then?
13:51:14 <amckinley> yitz: what would the difference be between the fold im using and choice?
13:51:36 <yitz> from the docs: choice ps  = foldl (<|>) pzero ps
13:51:36 <amckinley> (im very new to haskell; im learning it from this project)
13:52:00 <yitz> so it's the same, except it doesn't crash if your list happens to be empty.
13:53:57 <yitz> so how about: make_parser = choice . map (try . (>> many1 space) . symbol
13:54:05 <amckinley> yitz: gotcha. that still doesnt help me with this prefixes problem though, right?
13:54:15 <yitz> oops missing paren, but anyway
13:54:30 <amckinley> whoops, early send
13:54:42 <yitz> amckinley: i think it does - requiring the spaces makes it not match in that case
13:55:35 <yitz> amckinley: but you'll get the spaces as part of your result of course, so you'll have to deal with that
13:56:11 <yitz> skipMany1 spaces
13:56:27 <yitz> so how about: make_parser = choice . map (try . (>> skipMany1 space) . symbol)
13:57:20 <amckinley> yitz: im not sure thats going to work; i need to return the string that symbol parsed
13:57:43 <yitz> amckinley: with or without the trailing spaces?
13:58:30 <amckinley> preferably without, but i guess i can deal with having the trailing spaces. what i want is for the parser to match *only* if the provided string matches *and* its followed immeaditely by whitespace
13:59:33 <amckinley> yitz: i still feel like im going about this the wrong way. all i need is a parser that succeeds if it matches one string from a list of strings (followed by whitespace) and then returns the matched string
13:59:46 <glguy> Where can I read about the differences in Foreign.Concurrent and Foreign.ForeignPtr ?
13:59:49 <amckinley> and when i say "returns" i mean "evaluates to" :P
14:00:25 <yitz> amckinley: I think that's exactly what we're doing
14:00:49 <mauke> choose (map string xs) <* whitespace
14:00:52 <yitz> amckinley: use the one with skipMany1 - it discards the spaces
14:01:10 <amckinley> the skipMany1 doesnt typecheck: Couldn't match expected type `String' against inferred type `()'
14:01:37 <amckinley> mauke: i havent seen the <* operator before; whats it do?
14:01:58 <amckinley> :t (<*)
14:01:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
14:01:59 <mauke> amckinley: p1 <* p2 runs the parser p1 followed by p2, then returns what p1 returned
14:02:27 <yitz> mauke: great!
14:02:30 <amckinley> mauke: wow, that sounds ideal, thanks :)
14:02:47 <mauke> if you want what p2 returned, there's *>
14:02:55 <yitz> i think it's "choice" though
14:03:19 <yitz> mauke: what's the difference between *> and >> ?
14:03:26 <yitz> when you're in a monad
14:03:28 <mauke> none
14:03:43 <edwardk> yitz: one has a star and the other a > =)
14:03:54 <NY01> Hey people
14:04:04 <edwardk> yitz: and the first is only defined if your Monad bothered to define an Applicative instance
14:04:25 <edwardk> @type (*>)
14:04:27 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
14:04:39 <yitz> edwardk: and the second is only defined if your Applicative *has* a Monad instance
14:04:44 <amckinley> where's the import for (<*)?
14:04:49 <edwardk> yitz: very true.
14:05:00 <yitz> @hooge (<*)
14:05:00 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
14:05:01 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
14:05:01 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
14:05:01 <edwardk> oh, and to be pedantic the *> probably does more work
14:05:30 <yitz> hmm, that's actually not so pedantic
14:06:02 <eu-prleu-peupeu> hi
14:06:15 <yitz> hey - I misspelled hoogle and \bot figured it out
14:06:29 <mauke> up to a distance of 2
14:06:29 <yitz> @botsnack
14:06:30 <lambdabot> :)
14:06:30 <lunabot>  :)
14:06:30 <Gracenotes> yeah. liftA2 (const id)
14:06:36 <Gracenotes> @botsnortle
14:06:37 <lambdabot> Unknown command, try @list
14:06:37 <lunabot>  :)
14:06:44 <mauke> @shapr yitz
14:06:44 <lambdabot> I'd rather not; yitz looks rather dangerous.
14:06:45 <edwardk> mainly because *> is just liftA2 id or something, which means that you lift id into the applicative then apply that twice rather than use something directly from the dictionary to glue
14:06:54 <edwardk> yeah liftA2 (const id)
14:07:03 <Gracenotes> edwardk: yeah. which uses both fmap and ap
14:07:15 <yitz> it's very rude of lunabot to eat up lambdabot's snacks
14:07:15 <amckinley> ugh, i think im paren'ing this wrong
14:07:16 <amckinley> make_parser l = choice ((map string) <* space l)
14:07:53 <mauke> choice (map string l) <* space
14:08:21 <edwardk> Alas, Control.Applicative doesn't provide the easy special casing like Monad does.
14:09:05 <mauke> p << q = do x <- p; q; return x  -- easily defined!
14:09:09 <edwardk> pshaw. focusing on being 'correct' and all ;)
14:09:45 <amckinley> hm, not quite:     No instance for (Control.Applicative.Applicative
14:09:45 <amckinley>                        (GenParser Char ()))
14:09:49 <yitz> mauke: are you sure that will work, with one <* space for all the cases? doesn't that have to be inside the choice?
14:10:24 <yitz> what? no Applicative instance for Parsec?
14:10:28 <mauke> amckinley: looks like Parsec doesn't define Applicative instances
14:10:34 <edwardk> amckinley: parsec < 3 ?
14:10:45 <mauke> yitz: I don't see why
14:10:59 <amckinley> edwardk: how can i tell?
14:11:01 <mauke> yitz: (ax|bx) is (a|b)x
14:11:20 <edwardk> amckinley: well, you have to explicitly ask cabal for a version of parsec >= 3 =)
14:11:21 <yitz> mauke: won't it succeed on a prefix case, choose that one, then fail on the trailing spaces?
14:11:25 <edwardk> if you want a recent one =)
14:11:34 <edwardk> cabal install 'parsec >= 3'
14:11:44 <amckinley> im just using whatever came with my haskell install in macports
14:11:45 <mauke> oh, blargh
14:12:01 <edwardk> amckinley: then its the old and crufty parsec that doesn't know about Applicative
14:12:47 <edwardk> instance Applicative (GenParser tok st) where pure = return; (<*>) = ap
14:12:48 <mauke> yitz: my excuse is that I stopped using parsec a long time ago :/
14:12:54 <edwardk> just throw that at the top of the file you're in ;)
14:13:34 <yitz> edwardk: yeah, I see that macports has parsec 2.1.0.1
14:13:41 <Gracenotes> also, you might want to hide certain things in the Applicative import
14:13:47 <edwardk> and try not to think too hard about inconsistent instances
14:13:52 <yitz> amckinley: (you check that with the command ghc-pkg list)
14:14:20 <Gracenotes> or just copy from http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
14:14:36 <Gracenotes> the imports+instances
14:15:04 <edwardk> i still like using view patterns instead of <$> inside the monadic sugar now. i chuckle every time i use it
14:15:22 <badtruffle> edwardk: what happened to comonad.com ?
14:15:26 <badtruffle> (this is pumpkin btw)
14:15:56 <amckinley> whoops; gotta get lunch, back in 20. thanks for your help everyone, ill be right back :)
14:16:01 <BONUS> anyone read this? http://twan.home.fmf.nl/blog/haskell/non-regular1.details am i wrong in thinking that the implementation for <*> could just be defined as a <*> b = extractB a <$> b?
14:16:01 <edwardk> badtruffle: they moved the domain i was CNAMEd off of to a new box and i'm waiting for my DNS to update
14:16:14 <badtruffle> edwardk: so it's some forum now? that's odd
14:16:45 <edwardk> badtruffle: my CNAME pointed at shiftedlands.com so if they updated the DNS for the machine i'd come along for the ride.
14:16:54 <edwardk> badtruffle: then they switched boxes on me ;)
14:16:59 <badtruffle> ah, lol
14:17:08 <badtruffle> I was gonna see if you'd written up your epic blog post
14:17:09 <edwardk> so the new machine doesn't resolve the virtual host and you get the default for the machine
14:17:12 <badtruffle> yeah
14:17:13 <edwardk> nah
14:17:15 <Gracenotes> @where+ applicativeparsec http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ and http://book.realworldhaskell.org/read/using-parsec.html#id652399
14:17:16 <lambdabot> Good to know.
14:17:19 <edwardk> it'll have to wait until i get home
14:17:37 <yitz> does a copumpkin make a bad truffle?
14:17:40 <edwardk> i like to typecheck such things ;)
14:17:43 <badtruffle> so what's shifted lands?
14:17:48 <Gracenotes> unfortunately @where can't handle multiple-word-keys...
14:17:50 <badtruffle> yitz: indeed it does!
14:17:58 <edwardk> a LARP out of michigan that is hosted on the same box as comonad.com
14:25:02 <yitz> BONUS: you mean getB?
14:25:48 <BONUS> yeah, getB
14:25:57 <mdmkolbe> Does TH do (1) type families or (2) GADTs?
14:26:15 <BONUS> it typechecks, im just wondering if it passes the laws
14:30:07 <cytzol> Hi #haskell. Is there a way I can do a select() call on two Handles without dropping down into C? (Or at least, find out if I can read from two Handles some other way?)
14:30:30 <mauke> threads
14:30:55 <cytzol> bah
14:31:26 <mauke> threads are haskell's interface to select(2)
14:32:07 <dolio> f <*> pure b = (\f -> f b) <$> f is a law, but that's not what happens with f <*> pure b = getB f <$> pure b = pure (getB f b).
14:33:09 <dons> cytzol: haskell threads are super light, efficient, and have good support from libraries. e.g. using STM here to select over multiple handles is a perfect interface.
14:33:29 <dons> after all, what you're describing is a concurrency problem. so using concurrency in the language is appropriate.
14:33:29 <BONUS> ah, interesting. damnit
14:33:57 <p_l> a proper AIO system wouldn't be bad, though
14:34:25 <mauke> I've sort of reimplemented select on top of threads, but I'm not sure if I should release it
14:34:32 <cytzol> dons: They may be lightweight but compared to a function call they're more than I was expecting
14:34:56 <mauke> (as an Acme module maybe?)
14:36:18 <dolio> Part 2 has a non-flip version.
14:39:45 <yitz> BONUS: you'd expect that. You're forgetting all the a's in the left argument.
14:39:51 <dons> cytzol: i think you'll find they're very, very cheap.
14:40:01 <dons> since they're actually implemented via 'select'
14:40:31 <DrSyzygyFR> Hmmmm.
14:40:31 <cytzol> I was talking about code, not speed/memory/whatnot
14:40:47 <BONUS> yeah you're right. sometimes just getting the typecheck is not enough i guess
14:40:53 <dons> cheap code wise too. what kind of interface were you thinking of?
14:40:59 <DrSyzygyFR> Sooo ... how would I debug a stack overflow error that only pops up after many hours of execution at -O2 ?
14:40:59 <dons> a Chan that feeds results from multiple handles?
14:41:13 <dons> DrSyzygyFR: profiling. look at what's allocating.
14:41:20 <BONUS> very carefully i guess
14:41:29 <dons> DrSyzygyFR: also, use retainer profiling
14:41:40 <dons> which will generate nice graphs over time of what functions are hanging on to values.
14:41:52 <edwardk> pumpkin: ok, fixed comonad.com
14:42:13 <cytzol> dons: Yes. I'd usually do that by select()ing on all the handles until if any of them have something to read, then read it.
14:42:23 <dons> right.
14:44:13 <DrSyzygyFR> So .... +RTS -xt -hr -hd -hc would get me most of the info I need?
14:44:41 <yitz> DrSyzygyFR: before you do all that, make sure you are not using foldl instead of foldl' somewhere
14:45:41 <dons> cytzol: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4379#a4379
14:45:47 <dons> there's nicer ways still with STM
14:45:50 <dons> using orElse
14:46:26 <edwardk> anyone looked at the uu-parsinglib stuff from about a er.. 1 minute old post on the cafe? =)
14:47:09 <edwardk> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uu-parsinglib-2.0.0
14:47:41 <DrSyzygyFR> yitz: No foldl whatsoevers.
14:47:52 <edwardk> ugh, it defines its own applicative =(
14:48:03 <edwardk> ok, library use fail
14:48:04 <yitz> DrSyzygyFR: ok. profile onward then. :)
14:55:28 <DrSyzygyFR> My average visit per object seems to hover around 3. That seems good, right?
14:55:54 <mdmkolbe> Does Template Haskell support (1) type families or (2) GADTs?
14:55:55 <DrSyzygyFR> (also, this time around it seemed to actually finish ... I upped the corresponding parameters to see it die)
14:55:59 <wli> 3 what?
14:56:16 <edwardk> mdmkolbe: no on the first one, and i dunno on the second
14:56:32 <edwardk> i'd guess not though, since it lags pretty badly
14:58:25 <Gracenotes> hm, looks like unfoldr isn't enough... looks like I'll need... mapAccum :o
14:58:42 <badtruffle> zomg no
15:03:47 <cytzol> dons: Your code works, but there's no way to tell from which Handle the input came from. I'm guessing using Chans is the wrong way to go about this?
15:04:41 <amckinley> hey, im back :)
15:05:05 <amckinley> i think ive got a much easier solution to my "string followed by whitespace" problem, but its not quite right
15:05:58 <amckinley> ive got a function now that looks like this:
15:05:59 <amckinley> op_name :: String -> Parser String
15:05:59 <amckinley> op_name name = do
15:05:59 <amckinley>     try $ string name
15:05:59 <amckinley>     skipMany1 space
15:05:59 <amckinley>     return name
15:06:39 <amckinley> then i produce the parser for my big list by calling "choice (map op_name l)"
15:07:00 <mreh> Any ideas what I could do this summer as a young graduate with an interest in haskell
15:07:14 <Botje> mreh: actual sugar lambdas?
15:07:22 <amckinley> which is *almost* right, except im still having a problem with prefixes
15:07:45 <mreh> Botje: does it pay?
15:07:46 <amckinley> let l = [ "foo", "foo-bar" ]
15:07:53 <amckinley> let p = choice (map zombo l)
15:07:54 <Botje> not really
15:08:16 <adamvo> @hoogle sequenceA
15:08:16 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
15:08:16 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
15:08:35 <amckinley> runLex p "foo-bar "
15:08:35 <amckinley> parse error at (line 1, column 4):
15:08:35 <amckinley> unexpected "-"
15:08:35 <amckinley> expecting space
15:08:48 <mdmkolbe> Anyone know what the "ICFP PC Functional Programming Workshop" is?  What does the "PC" stand for?  It doesn't seem to be associated with the "Programming Contest".
15:09:22 <amckinley> adamvo: is that function for me?
15:09:37 <cytzol> amckinley: does it work if foo-bar comes first in `l'?
15:10:01 <amckinley> cytzol: yes
15:10:37 <adamvo> amckinley: I don't think so
15:10:52 <mreh> i'll have to start a lambdanade stand outside my house :(
15:11:06 <mreh> i'm going to trade mark that name
15:11:16 <amckinley> mreh: nice :)
15:11:17 <cytzol> amckinley: I *think* that you have the `try' in the wrong place. It's `try'ing the "foo", succeeding, and then it stops `try'ing.
15:11:25 <DrSyzygyFR> Hmmm... The shorter things I can execute never break the 6k barrier. In total memory consumption.
15:11:41 <cytzol> Move amckinley: Move the try from op_name and use "choice (map (try . op_name) l)"
15:12:59 <amckinley> cytzol: that did it :) thanks so much
15:16:25 <mreh> lamdanade, casual games in haskell
15:16:57 <mreh> haskell would be perfect for casual gaming, non? fast development time, quick turnover of ideas
15:20:17 <Gracenotes> i has a lambda
15:20:32 <mreh> @faq I can Haskell cheezburger?
15:20:33 <lambdabot> The answer is: Yes! Haskell can do that.
15:20:43 <Gracenotes> λ ← mai kawaii lambda
15:20:52 <DrSyzygyFR> Nawwwwww
15:20:59 <DrSyzygyFR> kawaiiiii!
15:22:18 <ddarius> dcoutts: Have you looked at LADSPA?  That gives you quite a few programs that will use such plugins.  www.ladspa.org
15:23:10 <dcoutts> ddarius: ta, will look
15:31:38 <monadic_kid> omg so funny you guys must read! http://groups.google.nl/group/comp.lang.misc/tree/browse_frm/thread/80e656506595982c/35b980bb75e8e9e7?rnum=1&_done=%2Fgroup%2Fcomp.lang.misc%2Fbrowse_frm%2Fthread%2F80e656506595982c%2F35b980bb75e8e9e7%3F#doc_6ce7486289660d42
15:31:53 <monadic_kid> It's Walter D the guy behind the D programming language
15:33:19 <Gracenotes> "No instance for (Random Int64)" ... :(
15:34:43 <badtruffle> fail
15:34:52 * kadaver_ learned functional programming with clojure but now thinks it is an ugly haskell-wannabe
15:36:37 <Gracenotes> darn, it overflow
15:36:38 <Gracenotes> s
15:36:43 <Gracenotes> with just 32 bits
15:36:58 <monadic_kid> did anyone read Walter D's reply to Jon? that was funny
15:37:15 <Gracenotes> just about 2^32, too
15:37:25 <Gracenotes> ah well. Integer isn't so bad
15:38:44 <blackdog> monadic_kid: where?
15:38:51 <monadic_kid> http://groups.google.nl/group/comp.lang.misc/tree/browse_frm/thread/80e656506595982c/35b980bb75e8e9e7?rnum=1&_done=%2Fgroup%2Fcomp.lang.misc%2Fbrowse_frm%2Fthread%2F80e656506595982c%2F35b980bb75e8e9e7%3F#doc_6ce7486289660d42
15:39:31 <Rocknrolla> who cares about haskell?!I dont even know what it is!
15:39:48 <vixey> yeah screw haskell!!
15:39:58 <mauke> that name looks familiar
15:40:00 * seliopou bites
15:40:06 <seliopou> omg haskell is so awsum u r wrong
15:40:09 <Gracenotes> pssh, come on now. he basically listed all his favorite features in OCaml and just say "many features found in other programming languages"
15:40:12 * myst 
15:40:14 <Gracenotes> siad
15:40:41 <Rocknrolla> yea!
15:40:44 <tomh> any of you guys into F#?
15:40:57 <Rocknrolla> f**ckin?
15:41:00 <Gracenotes> I probably would be if I did .NET.
15:41:04 <Gracenotes> but, not
15:41:07 <Rocknrolla> yea me 2
15:41:19 <tomh> ok
15:41:33 <tomh> just wondering if microsofts 'superior tooling' had any benefit
15:41:39 <monadic_kid> Did you guys not read the funny abit? Walter D's reply! this guy is the guy behind the D programming language
15:41:42 <vixey> F# is stupid just write a haskell->.NET compiler
15:41:54 <vixey> or ocaml->.NET whatever it is
15:42:06 <tomh> \it is based on ocaml
15:42:17 <Rocknrolla> im totally with vixey on this one
15:42:18 * vixey prefers to say 'ripped off'
15:42:22 <vixey> hehe
15:42:26 <mauke> vixey: that wouldn't give you tight integration with the .NET libraries
15:42:30 <dcoutts> vixey: F# :: ocaml -> .NET
15:42:49 <tomh> F# and ocaml are not compatible though
15:42:56 * vixey mumbles something about low hanging fruit
15:43:03 <Rocknrolla> she knows whats  shes talkin bout man!
15:43:21 <dcoutts> right, you could make ocaml for .net but all .net calls would have to go through their FFI
15:43:21 <Cale> Apparently .NET isn't exactly the most hospitable environment for a functional language, so F# is supposed to be a sort of compromise that would fit in.
15:43:23 <mreh_> do yours hang low too vixey?
15:43:55 <Gracenotes> vixey: .NET developers shouldn't rely on GHC developers for fulfillment of their feature needs
15:43:55 <dcoutts> similarly for Haskell for .net or JVM, it'd have to be via the FFI, otherwise you've got to redesign the language
15:44:00 <Rocknrolla> hang low omg
15:44:10 <vixey> doesn't have to be anything to do with GHC though Grace
15:44:18 <tomh> there is a haskell like project for jvm
15:44:30 <tomh> cal or something
15:44:33 <Gracenotes> hrm. Fair enough. It would be pretty modified though
15:44:41 <vixey> I'm just saying: I wish people didn't "design" so many languages which are pretty much carbon copies of a working formula
15:44:53 <tomh> hehe me too
15:45:14 <vixey> can't really get away with it though now that everyone is making their own lisp
15:45:21 <tomh> but on the other hand it is good that ms can find out what kind of tooling would be nice for functional programming languages
15:45:42 <tomh> lisp is like the last language one should base a new lang on
15:46:04 <mreh_> it's a great language
15:46:10 <Toxaris> how is the operation called which takes a type-level representation of foo to a term-level representation of Foo? reify, reflect, ...?
15:46:16 <tomh> but half of it is parenthesses :p
15:46:27 <mreh_> that's why it's so ingenious!
15:46:28 <dons> cytzol, just tag the message with its origin.
15:46:30 <Rocknrolla> u should just focus on other things in life, like real languages, like slovakian..
15:46:39 <tomh> lol
15:46:42 <Rocknrolla> or chilean
15:46:43 <hazridi> Weapons for a more civilized age.
15:46:49 <vixey> Toxaris: I would probably call it reifying that imaginary type level thing into a real value -- not sure it's that common though
15:47:10 <mauke> Rocknrolla: you should stop trolling #haskell
15:47:10 <tomh> hey dons, any news on haskell platform on windows yet? :)
15:47:21 <vixey> Rocknrolla: I wish I have the ability/patience to learn a real language...
15:47:27 <Rocknrolla> whats trollin?
15:47:27 <Cale> Rocknrolla: 私は今回日本語を勉強する
15:47:48 <mreh_> the casual attitude to trolling in #haskell is why i come here
15:47:52 <Rocknrolla> every truth comes through suffering
15:48:00 <Toxaris> vixey: thanks.
15:48:02 <Cale> If you troll enough, we will add you to the bot.
15:48:11 <mreh_> :(
15:48:11 <Cale> @protontorpedo
15:48:12 <lambdabot> is it nicer than APL?
15:48:13 --- mode: ChanServ set +o mauke
15:48:13 <Cale> @protontorpedo
15:48:14 <lambdabot> is there an oo db in haskell?
15:48:17 <Cale> @protontorpedo
15:48:17 <lambdabot> where was haskell during th internet boom?
15:48:22 <kadaver> lisp was probably great 10 years ago, now i dont find it interesting anymore
15:48:32 <kadaver> python is more practical, haskell is more robust
15:48:34 <vixey> that seems harsh mauke he wasn't really doing anything bad
15:48:41 <mauke> YOU'RE NEXT
15:48:51 <vixey> what about my next?
15:48:55 <tomh> kadaver: why do you think python is more practical
15:49:00 <mauke> vixey: its happy
15:49:08 <badtruffle> he didn't even use possessive lol
15:49:19 <vixey> I don't understand delimited continuations at all
15:49:21 <mauke> possessive lol? lo'l?
15:49:22 * badtruffle glares at kadaver
15:49:28 <vixey> (in CBN context)
15:49:32 <kadaver> tomh: there is probably a library for whatever I want to do already
15:49:34 <badtruffle> mauke: there probably should've been a comma before the lol
15:49:36 <mreh_> possessive, what?
15:49:38 <hiredman> talking about "lisp" as a single language is kind of silly these days
15:49:47 <tomh> kadaver: ok so its just a lib problem :)
15:49:49 <mauke> yeah, it's more like a speech impediment
15:49:51 <kadaver> and I think it is mroe readable. it has 80% of the goodies of lisp and the rest i dont really need
15:49:59 <badtruffle> mroe!
15:50:14 --- mode: mauke set -o mauke
15:50:21 * kadaver throws sticky-smelly-types at badtruffle
15:50:25 <badtruffle> :)
15:51:00 <albernaz> Guys, hi im a newbie, and im looking for a little help with this... How can i get a char (that i got as a parameter) and use it as a function (like x^2 and use this char to make a function)? is this possible?
15:51:11 <vixey> E[<F[SV]>]=E[<V(\x.<F[x]>)>]
15:51:19 <mauke> albernaz: huh?
15:51:24 <copumpkin> ord?
15:51:27 <copumpkin> > ord 'b'
15:51:28 <lambdabot>   98
15:51:40 <copumpkin> I dunno, I don't quite understand :P
15:51:40 <mreh_> are you hashing?
15:52:00 <copumpkin> or do you mean parsing a mathematical expression?
15:52:14 <albernaz> like this, (func)x^2, and use this char that i got
15:52:25 <mauke> albernaz: that doesn't make sense
15:52:27 <Cale> albernaz: Which function do you want to make?
15:52:29 <mreh_> what?
15:52:30 <Gracenotes> o.o
15:52:36 <albernaz> like transforming it to something useble
15:52:43 <copumpkin> so you want to parse a string?
15:52:53 <copumpkin> "x^2" ==> f x = x^2 ?
15:52:54 <Gracenotes> characters are pretty usable...
15:52:55 <thoughtpolice> vixey: don syme had a lot of the infrastructure there for a haskell .net compiler. he built F# later on because he wasn't sure how much it would be worth in the end
15:53:02 <mreh_> any haskell related projects for a young graduate credit cruncher?
15:53:04 <albernaz> copumpkin yea
15:53:05 <thoughtpolice> there was someone on infoQ interviewing him about it
15:53:15 <copumpkin> mreh_: have you checked the haskell proposals reddit?
15:53:15 <mreh_> i have been reduced to sandwhich boarding!
15:53:23 <mreh_> no....
15:53:27 <albernaz> copumpkin that simple?
15:53:31 <Gracenotes> mreh_: and I, wrapping seafood :)
15:53:32 <copumpkin> albernaz: no :P
15:53:35 <mreh_> reddit...
15:53:44 <copumpkin> albernaz: but depending on what you want people to be able to write, it can be quite simple
15:53:44 <mreh_> seafood...
15:53:55 <vixey> what is the best emacs mode for haskell?
15:53:56 <copumpkin> mreh_: http://www.reddit.com/r/haskell_proposals
15:53:59 <Gracenotes> taking customer's orders, cooking
15:54:06 <thoughtpolice> vixey: haskell-mode
15:54:42 <thoughtpolice> vixey: get the CVS HEAD though, monnier does ridiculously infrequent releases from haskell mode, and cvs HEAD has a lot of fixes etc. in it
15:55:03 <thoughtpolice> vixey: http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode
15:55:19 <mreh_> "I'm currently researching the possibility of applying for the Google Summer of Code" <- What a promising young man
15:55:49 <Zao> Isn't that quite too late?
15:55:57 <mreh_> Gracenodes: where do you work?
15:56:06 <vixey> thanks
15:56:08 <Gracenotes> midstate New York, near the hudson river
15:56:11 <Gracenotes> poughkeepsie
15:56:11 <vixey> I will try to defeat cvs
15:56:11 <mreh_> yeah, the deadline was ages ago
15:56:15 <mreh_> it's like shitting through the eye of a needle to get into GSoC
15:56:16 <amckinley> does anyone have a good "getting started"-type link for Text.PrettyPrint.HughesPJ?
15:57:05 <Gracenotes> "I'm currently researching the possibility of making inquiries to develop plans to try to apply for GSoC"
15:57:42 <copumpkin> lol
15:57:43 <DarthArachides> Does C++ STL have an equivalent of the zip function? which works at least on a vector?
15:57:44 <mreh_> "I might apply for GSoC"
15:58:12 <mauke> DarthArachides: I don't think there's a function for that
15:58:26 <mauke> wouldn't be too hard to write though
15:59:40 <mreh_> is there like a Haskell stree corner, where I flash my goods, waiting for clients?
15:59:58 <mreh_> will code for monies
16:00:03 <vixey> what fptools is massive
16:00:35 <kadaver> fptools?
16:01:50 <mauke> namespace wtf { template<typename O, typename I, typename J, typename F> void zipWith(F f, I a1, I z1, J a2, J z2, O o) { for (; a1 != z1 && a2 != z2; ++a1, ++a2) { *o++ = f(*a1, *a2); } } }
16:03:06 <monadic_kid> Thats not really STL style
16:03:16 <monadic_kid> DarthArachides: do you know about boost?
16:03:29 <mauke> why not?
16:04:11 <Asztal> looks like something you could find in <algorithm> to me
16:04:15 <monadic_kid> ah sorry I'm just tried, no it's fine
16:04:22 <monadic_kid> *tired
16:04:59 <monadic_kid> there is another method using iterator adaptors, boost has a zip_iterator
16:05:08 <mauke> the output iterator is unnecessary, though
16:05:20 <mauke> and f should probably be a reference
16:05:50 <mreh_> has anyone here use GdH?
16:07:11 <monadic_kid> zip_iterator http://www.boost.org/doc/libs/1_38_0/libs/iterator/doc/zip_iterator.html
16:09:06 <monadic_kid> it's more of a lazy way of doing it
16:10:17 <bos> @src *>
16:10:17 <lambdabot> (*>) = liftA2 (const id)
16:10:24 <bos> @src liftA2
16:10:24 <lambdabot> liftA2 f a b = f <$> a <*> b
16:11:13 <mmorrow> does extra whitespace at the end of lines in code make anyone else crazy, or is it just me
16:11:13 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
16:11:29 <copumpkin> mmorrow: it bothers me a little
16:11:36 <copumpkin> but not enough to go removing it all
16:11:47 <sjanssen> mmorrow: it is rather annoying
16:11:57 <copumpkin> it's more noticeable when darcs highlights it for you
16:12:04 <mmorrow> s/\s+$//
16:12:15 <mreh_> use a regex to get rid of it
16:12:16 <mreh_> oh
16:12:40 <mmorrow> i like to have spaces and tabs visible, maybe that's why it bothers me so much..
16:12:45 <mauke> :%s/\s\+$
16:13:08 <mreh_> why did you escape the plus?
16:13:12 <kadaver> how is no switch/case statements forcing people back to using hashtables? ass opposoed to tress or lsits?
16:13:20 <mauke> because this is vim
16:13:44 <mreh_> how many spaces is a tab?
16:13:54 <mmorrow> , 1/0
16:13:56 <lunabot>  Infinity
16:14:04 <Ralith> NaN
16:14:48 <mmorrow> for haskell code, expand -t8
16:15:29 <mreh_> are spaces more compatible than tabs?
16:15:31 <mmorrow> (or else you'll get errors)
16:15:48 <Ralith> define 'compatible'
16:16:15 <mreh_> can more people read code with spaces than tabs
16:16:22 <BONUS> heh. interesting. the minimal complete definition for Foldable could be just fold if Foldable were a subclass of Functor
16:16:25 <mreh_> the execution is secondary
16:16:28 <Ralith> everyone can read any code they want
16:16:58 <Ralith> if you're asking what you should use, in haskell the standard is spaces.
16:17:00 <mmorrow> the appearance of code with tabs is different depending on your viewer
16:17:02 <Gracenotes> hm. one tends to use unfoldr a bit when translating imperative code...it should seem :o
16:17:04 <Ralith> most elsewhere there isn't a standard.
16:17:53 <mreh_> spaces, because of the offside rule?
16:17:54 <Gracenotes> ooh. unfoldrN is nice.
16:19:18 <NEEDMOAR> :t unfoldrN
16:19:20 <lambdabot> Not in scope: `unfoldrN'
16:19:28 <NEEDMOAR> unfold for naturals?
16:19:56 <Asztal> http://hackage.haskell.org/packages/archive/bytestring/0.9.1.4/doc/html/Data-ByteString.html#v:unfoldrN ?
16:20:06 <Gracenotes> yeah
16:20:24 <Gracenotes> just what I need here, converting an index of a finite alphabet into text
16:20:37 <Gracenotes> of a word in a finite alphabet
16:22:54 <mmorrow> are there any sqlite pros around, because takusen's sqlite driver seems to barf when two threads try to do something to the db at once
16:23:14 <mmorrow> i googled for this at one point and the solution seems to be well known
16:23:25 <mmorrow> (i can't remember what it is though)
16:23:55 <mmorrow> ((this is why hpaste ends up with a "database is locked" error msg every so often)
16:24:02 <Asztal> SQLite locks the entire database, IIRC the "solution" is just to keep retrying for a while
16:24:27 <Gracenotes> mmorrow: transactions?
16:24:39 <mmorrow> Asztal: yeah, iirc you have to test for SQLITE_BUSY (or something), then retry. but takusen doesn't
16:25:08 <Gracenotes> I believe SQLite isn't known for great concurrency prowess
16:25:09 <mmorrow> which results in the database never getting unlocked (or something)
16:25:20 <Asztal> it would be nice if SQLite itself did it, you could just set a timeout per-connection...
16:27:55 <Gracenotes> ugh. It seems unfoldrN isn't what I want .. it writes from the left. I might have to do a reverse, then...
16:28:37 <Gracenotes> meh.
16:29:56 * glguy likes how cabal overrides his cc-option -O3
16:30:10 <mmorrow> glguy: :o
16:30:27 <glguy> you're right, cabal, I didn't know what I wanted
16:30:36 <mmorrow> what does it replace it with?
16:30:45 <mmorrow> (or does it just drop it?)
16:30:53 <blackdog>  glguy: DWI *should* have meant
16:30:56 <glguy> the -O2 I had in my ghc-options
16:31:07 <glguy> seems to add a -optc-O2
16:31:10 <glguy> on the end
16:31:19 * mmorrow always gives -O3 to gcc
16:31:44 <mmorrow> it adds an complete extra optim pass (among other things)
16:31:50 <mmorrow> s/an/a/
16:33:16 <mmorrow> glguy: i had a go at an alternate Chan that doesn't block on isEmptyChan if another thread is already blocked on a readChan: http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/Q.hs
16:34:25 <mmorrow> glguy: i'm 95% sure there are no races in that code, but haven't spent the time to verify 100% yet
16:36:08 <glguy> mmorrow, I can't study it until I get home, but I've bookmarked it
16:36:46 <mmorrow> glguy: cool. lemme know if you find any improvements/bugs
16:37:34 <confused_one> guys, is there a way to transform this "2x" (char) into something like (\x -> 2x) ?
16:37:53 <copumpkin> confused_one: yeah :P
16:38:02 <copumpkin> except you mean 2 * x
16:38:18 <confused_one> copumpkin yes, sorry
16:38:41 <copumpkin> you could write a quick parser for the expression
16:39:22 <confused_one> copumpkin hmm
16:40:43 <StoneToad> confused_one: so you're asking if it's possible to make a simple calculator program?
16:41:01 <confused_one> StoneToad something like that
16:41:04 <StoneToad> (answer is yes btw, very common example program for haskell books)
16:41:11 <StoneToad> and online tutorials
16:41:28 <confused_one> StoneToad oh ok, thx
16:43:20 * Philippa wrote one off the top of her head in front of her girlfriend the other weekend, even
16:43:29 <Philippa> (she's a coder too, I'm not /that/ bad)
16:44:04 <kadaver_> Philippa is lesbian?
16:44:28 <mauke> wait, you just joined
16:44:42 <copumpkin> kadaver_: nice
16:45:03 <duud> Ahm, i would like to be able to run a shell command and process the  output in it. Something like  s <- exec "ls" would be nice... I have searched the libraries but didn not found anything simple
16:45:12 <Nafai> Philippa: How is it having your S.O. as a coder too?  My wife doesn't have the foggiest at what I do and I can't even being to explain it to her :/
16:45:12 <guenni> hi, what was the flag again for building without dos window?
16:46:25 <mreh_> what do you understand this to meanequals xs xs = True
16:46:27 <mreh_> oops
16:46:37 <guenni> mmorrow: ping
16:46:38 <mreh_> equals xs xs = True
16:46:44 <mmorrow> guenni: hi
16:46:46 <mreh_> equals xs (x:xs) = False
16:47:07 <mreh_> That's invalid haskell, but I can't grasp the point of the person who is writing this
16:47:26 <guenni> mmorrow: I'm about to build my app, for windows, do you know the flag to surpress the dos window?
16:47:44 <Toxaris> mreh: (==) `on` length?
16:47:54 <mmorrow> guenni: i don't, i haven't really built any haskell code on windows
16:48:00 <kpreid> mreh_: in some pattern matching systems reusing the variable means that it must be the same thing
16:48:20 <guenni> mmorrow: what?!
16:48:31 <kpreid> i.e. "foo xs xs = ..."  means "foo xs g1 | g1 == xs = ..."
16:48:33 <guenni> mmorrow: shame on you! :)
16:48:42 <mmorrow> guenni: heh, i try to stay away :)
16:49:33 <mmorrow> i'm holding out for the day when windows finally dies :)
16:50:08 <mreh_> > let equals xs xs = True; equals _ _ = false in equals [1..] [1..]
16:50:10 <lambdabot>       Conflicting definitions for `xs'
16:50:10 <lambdabot>      In the definition of `equals'Not ...
16:50:18 <guenni> mmorrow: that'll be the day when you *talk* to your computer
16:50:19 <mreh_> you can't repeat variables
16:50:31 <guenni> mmorrow: which would be some 10 years ago
16:50:54 <guenni> anybody else know the flag, please?
16:50:59 <mmorrow> guenni: i talk to my computer all the time! "you *****, oh *****, noooooooo", etc ;)
16:51:00 <kpreid> mreh_: sure, I'm talking about what some other languages (anything unification-based) will do
16:51:15 <mreh_> oh right
16:51:58 <mreh_> i suppose if you could, the result of a function would depend on your evaluation strategy
16:52:43 <mreh_> > [1..] == [1..]
16:52:59 <lambdabot>   thread killed
16:53:03 <mreh_> oops
16:53:08 <mreh_> they are so the same
16:53:17 <Toxaris> mreh_: proof?
16:53:25 <mreh_> induction
16:53:49 <Gracenotes> truly a shocking proof method!
16:54:00 <mreh_> how about common sense
16:54:15 <mreh_> actually, ive just made my brain hurt
16:54:40 <Toxaris> mreh_: I'm not too sure that can be proved by induction so easily. I'm afraid of infinite stuff.
16:55:02 <Gracenotes> a transformative proof, yielding much energy
16:55:15 <mreh_> cantor equated infinity with the godhead
16:55:30 <mreh_> you should be afraid
16:56:09 <mreh_> mental
16:56:23 <QtPlaty[HireMe]> Could induction be automated?
16:56:56 <Toxaris> QtPlaty[HireMe]: some theorem provers do that to some degree
16:58:06 <Toxaris> QtPlaty[HireMe]: they look at your data types (and maybe the termination proofs of your functions), and generate well-founded relations. then they look at the theorem you want to proof, guess which relation to use for the induction, synthesize the induction hypothesis, apply the induction principle, and try to solve the cases
16:58:16 <roconnor> what is the plural of "formula"
16:58:25 <mreh_> ae
16:58:32 <Toxaris> I think "formulae" or "formulas"
16:58:40 <Gracenotes> hm... unsigned char... how many bytes is that?
16:59:27 <Gracenotes> well, depends on the machine of course
16:59:32 <Gracenotes> most 32-bit, though..
16:59:35 <mreh_> hee hee, German lecturer is now talking about the "Joker" pattern
16:59:52 <mreh_> not quite the same thing
17:00:13 <Gracenotes> oh, it must be a byte
17:00:51 <QtPlaty[HireMe]> Toxaris: Both are acceptable.
17:01:08 <mreh_> in english
17:01:27 <QtPlaty[HireMe]> mreh_: Well we are not talking in latin.
17:02:02 <viraptor> is there any haskell (not a binding) library for encoding jpeg files? google finds decoders only :/
17:02:22 <mreh_> ego in id voco
17:02:43 <Toxaris> > show id
17:02:44 <lambdabot>       Overlapping instances for Show (a -> a)
17:02:44 <lambdabot>        arising from a use of `s...
17:03:05 <QtPlaty[HireMe]> Is there a benchmarking framework for Haskell?
17:03:07 <Toxaris> not the most obvious error message :)
17:03:18 <idnar> "formulas" is pretty awkward, so I'd avoid it
17:03:20 <mreh_> what about Nigerian pigeon english?
17:04:16 <idnar> mreh_: ITYM "pidgin"
17:04:26 <idnar> unless there's something I don't know about birds
17:04:37 <Toxaris> > logBase 8 (fromInteger (toInteger (fromEnum (maxBound :: Char)))) -- how many bytes in a char?
17:04:39 <lambdabot>   6.695820515440522
17:04:54 <c_wraith> 8?
17:04:56 <Toxaris> hmm no that's stupid
17:04:58 <Toxaris> :(
17:05:05 <c_wraith> I think 8 is just the wrong base
17:05:05 <copumpkin> lol
17:05:13 <copumpkin> 256 maybe? :P
17:05:17 <Toxaris> > (logBase 2 (fromInteger (toInteger (fromEnum (maxBound :: Char))))) / 8
17:05:19 <c_wraith> That sounds more reasonable
17:05:19 <lambdabot>   2.5109326932901954
17:05:23 <c_wraith> haha.
17:05:27 <c_wraith> 2.5 bytes!
17:05:28 <copumpkin> 2.5 is about right
17:05:40 <Asztal> > ord maxBound
17:05:43 <lambdabot>   1114111
17:05:53 <c_wraith> Char is unicode codepoints?
17:05:54 <olsner> 20 bits, plus a few hundred values
17:05:59 <Gracenotes> > digitToInt 'f'
17:06:02 <lambdabot>   15
17:06:04 <Gracenotes> :D
17:06:06 <olsner> *few hundred thousand
17:06:10 <mreh_> i've just started playing bass in a band, i must be the most over qualified musician
17:06:26 <c_wraith> One of my co-workers is a drummer in a band.
17:06:31 <olsner> > ord maxBound - 2^20
17:06:33 <lambdabot>   65535
17:06:47 <mreh_> but is he good enough to go pro
17:07:02 <mauke> > 2^21
17:07:04 <lambdabot>   2097152
17:07:14 <c_wraith> Heh.  He's a drummer. :)  He's good, but it's awfully hard to go pro as a drummer.
17:07:46 <mreh_> there's a myth about being a musician, that it's somehow harder than anything else in the world
17:08:06 <c_wraith> Being a musician isn't hard.
17:08:17 <c_wraith> Earning a living from it...  That requires a lot of luck.
17:08:22 <olsner> what a stupid upper bound btw, instead of just going for 2^20 flat, they use 17 64k blocks and leave (iirc) 13 of them reserved for future expansion
17:08:24 <mreh_> incorrect
17:08:34 <copumpkin> olsner: yeah :P
17:08:38 <copumpkin> maybe 15?
17:08:47 <Philippa_> Nafai: it's mostly good. There's the occasional awkward moment, she started coding a lot later than I did and didn't do anything with Haskell beyond UoN's courses which often don't grab students
17:08:56 <mreh_> who do you think plays every wedding in london? one drummer?
17:09:02 <olsner> one is the BMP, I think there are two CJK supplemental planes
17:09:07 <olsner> and one with various symbols
17:09:12 <mreh_> its just like programming, you niche yourself
17:09:30 <mreh_> or become so versatile you can do anything
17:11:08 <MyCatVerbs> @src Integer
17:11:08 <lambdabot> data Integer = S# Int#
17:11:09 <lambdabot>              | J# Int# ByteArray#
17:11:34 <copumpkin> I wonder what the J stands for
17:11:48 <MyCatVerbs> Juggernaut!
17:11:54 <mmorrow> Jello
17:12:19 <mauke> Jones
17:12:28 <mauke> (the S is for Simon)
17:12:37 <mreh_> haha
17:12:45 <copumpkin> lol
17:12:46 <mauke> can you guess what the pipe stands for?
17:12:46 <Gracenotes> :o
17:13:03 <copumpkin> Simon Pipe Jones?
17:13:05 <olsner> copumpkin: apparently, 11 planes are unassigned, with the 16th and 17th plane reserved for private use
17:13:19 <copumpkin> olsner: yeah, we don't really have that many characters :P
17:13:19 <Gracenotes> 11 planes? What is this, string theory?
17:13:24 <Gracenotes> >_>
17:13:33 <copumpkin> olsner: even the CJK extension B only uses a subset of plane 2
17:13:34 <olsner> copumpkin: Peyton is actually an old word for Pipe
17:13:38 <guenni> any windows users present?
17:13:50 <copumpkin> what happened to coolsner btw?
17:14:13 <Gracenotes> ooh, I'd better sign up for this class prompto. (pardon fake spanish)
17:14:21 <copumpkin> prompto :o
17:14:41 <olsner> Gracenotes: heh, we *are* actually talking about the so called "astral" unicode planes
17:14:52 <kadaver> windows here
17:14:53 <Gracenotes> ah, unicode
17:15:22 <dons> http://www.reddit.com/r/programming/comments/8ga9r/ihg_projects_day_1_hello_world_now_only_11k_using/
17:15:26 <dons> woohoo. shared libs. 11k helloworld
17:15:38 <conal> hurray!
17:15:38 <lambdabot> conal: You have 3 new messages. '/msg lambdabot @messages' to read them.
17:16:13 <dons> yay for IHG.
17:16:18 <olsner> copumpkin: I didn't bother to change my network configuration, the nick only lasted as long as that session did
17:16:23 * dons hopes more companies will join, and we'll have a thriving ecosystem
17:16:23 <c_wraith> I like the weather symbols in unicode.. "clear weather", "cloudy weather", "rainy weather", "snowy weather", "comet"...
17:17:03 <SamB> what? no partly cloudy ?
17:17:28 <mmorrow> yay! closer to being free of the the 30MB ghc link tax
17:17:29 <olsner> maybe there's a combinating character you can use to indicate partial weathers
17:17:42 <mmorrow> (14MB after stripping)
17:18:11 <Nafai> Philippa_: I will admit some is rubbing off.  I was watching some presentation online that was talking about functional languages and my wife pipes up, "Haskell is a functional language!"  Now, she didn't know what it meant, but at least she's observed what I'm obsessed with :)
17:18:16 <mauke> ☔̈
17:18:21 <mauke> umbrella umlaut
17:18:25 <mmorrow> heh
17:18:26 <gOcOOl> Prelude> add x y = x + y
17:18:28 <gOcOOl> <interactive>:1:8: parse error on input `='
17:18:32 <gOcOOl> not sure what I'm missing here
17:18:40 <olsner> mauke: umbrella in hail storm?
17:18:48 <c_wraith> gOcOOl: You need a let
17:18:57 <mmorrow> , (text . utf8enc) ((:[]) . chr . (+1) . ord $ '☔̈')
17:18:57 <mauke> gOcOOl: ghci evaluates expressions
17:18:58 <lunabot>  luna: parse error on input `'
17:18:58 <c_wraith> since it's evaluating in the context of the IO monad
17:19:30 <mmorrow> , (text . utf8enc . fmap (chr . (+1) . ord)) "☔̈"
17:19:32 <lunabot>  ☕̉
17:20:08 <gOcOOl> mauke, c_wraith: ah yes, thanks!
17:20:16 <mmorrow> , (text . concat) (iterate (utf8enc . fmap (chr . (+1) . ord)) "☔̈")
17:20:19 <lunabot>  luna: out of memory (requested 1048576 bytes)
17:20:20 <mauke> , text . utf8enc . fmap succ $ "☕̉"
17:20:22 <lunabot>  ☖̊
17:20:28 <mmorrow> heh, succ
17:20:40 <mmorrow> i always forget about that
17:21:04 <mmorrow> , (text . concat . take 10) (iterate (utf8enc . fmap succ) "☔̈")
17:21:06 <lunabot>  ☕̉ãÍÄ¤ÃÃÄÃÄÃ¥ÄÃÄÃÄÃÄÃÄÃÄÃ¦ÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃ§ÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃÄÃ...
17:21:09 <mmorrow> gah
17:21:29 <mmorrow> fail
17:26:12 <sbahra> dons, do you have recommendations on a C gamteb implementation?
17:27:00 <mmorrow> , text . utf8enc . take 8 . concat . (iterate . fmap) succ $ "☔̈"
17:27:01 <lunabot>  ☔̈☕̉☖̊☗̋
17:27:17 <skorpan> dude... no way!!!!!!
17:27:34 <mmorrow> uhh, yes way!!!@
17:27:51 <copumpkin> lol
17:28:01 <skorpan> that guy speaks in pictures... that's so far out!!!
17:29:20 <SamB> mmorrow: dude, half of those are combining ...
17:29:26 <SamB> and most have nothing to do with weather!
17:29:43 <mauke> U+2614 (e2 98 94): UMBRELLA WITH RAIN DROPS [☔]; U+0308 (cc 88): COMBINING DIAERESIS [̈]; U+2615 (e2 98 95): HOT BEVERAGE [☕]; U+0309 (cc 89): COMBINING HOOK ABOVE [̉]; U+2616 (e2 98 96): WHITE SHOGI PIECE [☖]; U+030A (cc 8a): COMBINING RING ABOVE [̊]; U+2617 (e2 98 97): BLACK SHOGI PIECE [☗]; U+030B (cc 8b): COMBINING DOUBLE ACUTE ACCENT [̋]
17:30:09 <mmorrow> ohh, cool. i was wondering where the other 4 chars went
17:30:41 <mmorrow> mauke: your unicode js lookup in handay
17:31:03 <mauke> ☺
17:31:56 * SamB pasted them on the command line to "unicode" ;-P
17:33:10 <mmorrow> , (text . utf8enc) "☺\778"
17:33:11 <lunabot>  ☺̊
17:33:20 <mmorrow> combining chars are so cool
17:33:52 <mauke> especially when combined with compose keys so you can just type them :-)
17:34:04 <mmorrow> heh, i have to work on that
17:35:20 <mauke> compose ⌫ " ==  ̈
17:36:25 <mmorrow> oh nice, combining chars combine with interspersed spaces (at least in my font)
17:36:29 <mmorrow> , (text . utf8enc) "☺\778 \778"
17:36:30 <lunabot>  ☺̊ ̊
17:37:14 <mauke> ω̈
17:37:15 <SamB> maybe they should make a special character to keep combining characters away from characters they could combine with ;-)
17:38:31 <mmorrow> hmm, i forgot that lunabot does `words' on the input, so that might not be what's happenin
17:38:36 <mmorrow> g
17:38:44 <mmorrow> , "o                      m                                  g"
17:38:46 <lunabot>  "o m g"
17:38:53 <mauke> haha, what
17:38:58 <mmorrow> need to fix that...
17:39:16 <mmorrow> words
17:39:23 <skorpan> word up
17:39:39 <luqui> does anybody know of a complete "basis" for stack operations
17:39:57 <mmorrow> push,pop,dup,swap,slide ?
17:40:01 <luqui> i.e. any fixed reordering can be represented as a composition of these basic ops?
17:40:30 <copumpkin> the dynamic linkage stuff is exciting
17:40:53 <luqui> (reordering/duplication/etc.)
17:41:56 <Saizan_> what's the point of shogi pieces in unicode?
17:42:27 <mauke> ☃
17:44:25 <Philippa_> Saizan_: talking about shogi?
17:45:32 <dmehrtash> I am using haskell plugin for emacs, it has a nice feature of showing me the type signature of the function (when i put my mouse on it)  Is there a way to actually jump into the fucntion implementation?
17:48:36 <Saizan_> Philippa_: i guess, but if we go with that we can end up with all the shogi pieces, and mah jong, and all the different decks of cards..
17:48:49 <Philippa_> *shrug*
17:49:20 <Philippa_> we've got one deck of cards already
17:49:44 <Saizan_> dmehrtash: i think you can use hasktags to get that
17:51:59 <luqui> mmorrow, thanks.  didn't see your answer because irc was being stupid...
17:52:24 <mmorrow> luite: :)
17:52:55 <mmorrow> luqui: (do you think that's indeed a minimal basis, i'm not sure. i'd be interested to know what you come up with)
17:53:13 <luqui> mmorrow, i'm not sure either.
17:53:26 <luqui> what is slide, btw?
17:53:27 <dmehrtash> Saizan_:  Hasketag only looks at your souce directories and not the cabal packages, right?
17:54:49 <mmorrow> luqui: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2268#a2268
17:55:13 <centrinia> Isn't slide just repeated pops?
17:55:25 <mmorrow> luqui: might be used in an interp for tailcalls or similar
17:55:25 <Saizan_> dmehrtash: right
17:55:43 <mmorrow> centrinia: it does:
17:56:20 <mmorrow> slide(4,3):   [0,1,2,3,4,5,6,7,8,9] ==> [0,1,2,3,7,8,9]
17:56:43 <luqui> ok
17:58:45 <mmorrow> and also, you may want something like "pushi" (i just made up that name) in a basis too:
17:59:08 <mmorrow> pushi(2):  [0,1,2,3,4,5,..] ==> [2,0,1,2,3,4,5,..]
18:00:26 <mmorrow> luqui: this is an interesting question, since if you had a minimal basis it'd be easy to generate (e.g.) C code for a stack-based interpreter
18:01:01 <mmorrow> (well, easy to generate one that isn't (in some sense) ad-hoc)
18:01:51 <luqui> well it's pretty easy to overdo it...
18:02:02 <mmorrow> yeah totally
18:02:18 <mmorrow> a fine line, etc
18:03:36 <mmorrow> luqui: (ah, also i should explicitly mention that that C code i pasted assumes the stack is growing "downward")
18:17:01 <tsLight> say I have data GTree a = Leaf a |Gnode [GTree a]. How is the empty tree represented? By GNode [] ?
18:19:43 <mmorrow> tsLight: Nothing :: Maybe (GTree a)
18:20:03 <mmorrow> (since that rep has no "empty tree")
18:20:39 <tsLight> I dont get it
18:20:47 <tsLight> I have to change the representation of the type for that?
18:20:55 <mmorrow> well, i guess you could define the empty tree as GNode [], but personally i'm not sure if i'd do that
18:21:03 <mmorrow> tsLight: yes
18:21:09 <tsLight> ah
18:21:27 <mmorrow> data Foo = Nil | Foo ...
18:21:29 <mmorrow> vs.
18:21:35 <mmorrow> data Foo = Foo ...
18:23:53 <tsLight> yeah
18:23:59 <Gracenotes> D:
18:28:48 <Saizan_> i'd avoid introducing two values with the same meaning though
18:29:31 <Saizan_> if you add an explicit Empty constructor then you should use a non-empty list in Gnode
18:30:07 <Saizan_> but i don't see much gain on that over just using empty = Gnode []
18:31:17 <tsLight> how do I define empty = Gnode []?
18:31:23 <tsLight> using type Empty = Gnode[] and thats it?
18:31:27 <tsLight> (synonym)
18:32:04 <Saizan_> no
18:32:24 <Saizan_> empty was at the value level there
18:32:56 <Saizan_> and Gnode is at the value level too, being a data-constructor
18:33:05 <tsLight> but can I define a synonym for a constructor?
18:33:13 <tsLight> so I can do Empty instead of Gnode []
18:33:27 <tsLight> to make the code more understandable
18:33:29 <Saizan_> not in a pattern
18:33:49 <Saizan_> but you can define "empty = Gnode []" and use empty in expressions
18:34:23 <tsLight> ah, but not with capital E because its not a type :P
18:34:37 <Saizan_> and it's not a constructor :)
18:34:47 <tsLight> you are right
18:35:03 <tsLight> its a value of an algebraic type
18:35:04 <tsLight> :P
18:35:13 <Saizan_> right
18:37:48 <Saizan_> uhm, it'd be nice to overload pattern matching
18:40:17 <tsLight> if I want to redefine show function for booleans, how can I do it?
18:40:29 <tsLight> i declare an instance Show Bool where
18:40:32 <tsLight> with my show function
18:40:35 <Saizan_> you can't
18:40:38 <tsLight> but then it overlaps with the default
18:40:46 <tsLight> :O
18:40:46 <roconnor> @wp din
18:40:49 <lambdabot> *** "din" wn "WordNet (r) 2.0"
18:40:49 <lambdabot> din
18:40:49 <lambdabot>      n 1: a loud harsh or strident noise [syn: {blare}, {blaring}, {cacophony},
18:40:49 <lambdabot>            {clamor}]
18:40:49 <lambdabot>      2: the act of making a noisy disturbance [syn: {commotion}, {ruction},
18:40:51 <lambdabot> [6 @more lines]
18:40:58 <zoheb> what if you newtype it?
18:41:23 <Saizan_> you can't declare a new SHow instance for Bool, but you can for a newtype of it, yeah
18:41:27 <tsLight> so I cant override the default show?
18:41:29 <tsLight> ah
18:41:37 <Saizan_> or you can just decide to use another function
18:41:48 <kpreid> tsLight: if Show and instance Show Bool were in separate modules, then you could avoid importing the latter -- but they aren't.
18:41:56 <tsLight> ok
18:46:13 <jatqceer> How do you define a efficient fuction that does [Array Int x] -> Array Int [x] ?
18:46:52 <zoheb> @t  Array
18:46:53 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:46:59 <zoheb> :t  Array
18:47:00 <lambdabot> Not in scope: data constructor `Array'
18:47:06 <zoheb> :t  Data.Array
18:47:08 <lambdabot> Couldn't find qualified module.
18:47:28 <Gracenotes> jatqceer: you can fold
18:47:50 <Gracenotes> it won't be efficient, though, without using an intermediate data representation
18:48:14 <jatqceer> fold?  intermediate array is too inefficient
18:48:25 <Gracenotes> yes, definitely
18:48:32 <Gracenotes> hm...
18:48:37 <Gracenotes> @type (//)
18:48:39 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
18:48:53 <Gracenotes> @type accumArray
18:48:54 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
18:49:01 <Gracenotes> these may be useful for building the new array
18:49:03 <zoheb> what about a list compr
18:49:30 <Gracenotes> particularly the second -- it allows you to take care of duplicate values in the associating list, which you can do by consing
18:49:40 <Gracenotes> *association
18:50:29 <Saizan_> jatqceer: do you know the sizes?
18:50:31 <Gracenotes> so concatMap the original list of arrays into an association list of all of the elements, and then accumArray this large list into the final array. This seems like an okay way to do it, although benchmarking it couldn't hurt
18:51:04 <Gracenotes> not the only solution, I'd bet :)
18:51:08 <jatqceer> how about listArray (a,b) . transpose . elems
18:52:05 <Saizan_> ?type \a b -> listArray (a,b) . transpose . map elems
18:52:06 <lambdabot> forall i i1 e. (Ix i1, Ix i) => i -> i -> [Array i1 e] -> Array i [e]
18:52:30 <jatqceer> Saizan_: using bounds to know the size I guess
18:52:41 <zoheb> :transpose
18:52:46 <zoheb> :t transpose
18:52:47 <lambdabot> forall a. [[a]] -> [[a]]
18:52:49 <Gracenotes> transpose isn't terribly efficient :)
18:53:29 <Saizan_> Gracenotes: do you know the complexity?
18:54:16 <Gracenotes> profiling it with my quantum algorithm simulator has been less-than-reassuring :>
18:54:23 <Gracenotes> I mean, using it as an intermediate function
18:54:31 <jatqceer> probably STArray is more efficient?
18:55:01 <lispy> ?Cale
18:55:01 <lambdabot> Unknown command, try @list
18:55:15 <Gracenotes> it may be in this case. freezing/thawing... see http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#Freezing_and_thawing
18:55:21 <lispy> anyone here have enough permission to ?flush lambdabot?
18:55:28 <Gracenotes> but profile is the only way to be sure :)
18:55:39 <Cale> @flush
18:55:55 <lispy> Cale: thanks, lambdabot has delivered to me the same message 3 times
18:56:02 <Cale> ah
18:56:10 <lispy> maltem asked me where eigenvariable comes from
18:56:17 <lispy> I think I first saw the term used by Oleg
18:56:18 <Adamant> don't fight the types, work with them. be a type whisperer
18:56:27 <Adamant> :P
18:57:00 <lispy> eigenvariable is a fun term, I think we should use it more
18:57:02 <copumpkin> I don't see how thawing can ever be safe
18:57:07 <Adamant> sorry, just getting that from working on something.
18:57:42 <Cale> I don't think I've seen that term before.
18:57:46 <lispy> Cale: question about H-M type inference.  Do you know what book or paper I could read that would talk about it on the theoretical?
18:57:58 <copumpkin> oh I see, freezing and thawing make copies
18:57:59 <Gracenotes> :t \bounds arr -> accumArray (flip (:)) [] bounds $ concatMap assocs arr  -- jatqceer, this is the accumArray thing I was talkin bout.
18:58:00 <lambdabot> forall i e. (Ix i) => (i, i) -> [Array i e] -> Array i [e]
18:58:04 <lispy> Cale: I found typing haskell in haskell, but they assume you know H-M
18:58:24 <Gracenotes> like Saizan_ said you need to know the size, which is easier if all of them are the same size
18:58:38 <jatqceer> thanks, I'm off to do some tests
18:58:40 <Gracenotes> essentially it unwinds the arrays into a list, and accumulates them efficiently
18:58:59 <zoheb> :t accumArray
18:59:00 <Cale> lispy: The fairly standard intro to type theory is Types and Programming Languages by Pierce.
18:59:00 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
18:59:21 <lispy> Cale: hmm..but does he actually cover this? I have a copy, but nothing in the table of contents grabbed me
18:59:29 <lispy> Cale: I can look again of course
18:59:34 <Cale> hmm...
18:59:38 <zbrown> lispy: if you want to go old school, "Principal type-schemes for functional programs" by Damas & Milner is one of the original papers describing the algorithm.
18:59:39 <Saizan_> lispy: there's a chapter on type reconstruction
19:00:01 <zbrown> lispy: if you get Pierce's Advanced Topics TAPL, the last chapter covers ML Type Inferencing as well
19:00:09 <Gracenotes> TAPL... must.. read.. :o
19:00:21 <Gracenotes> stop. putting. off. finishing. it.
19:00:33 <lispy> zbrown: okay
19:00:35 <zbrown> lispy: also, there's "A Theory of Type Polymorphism in Programming"
19:00:36 <lispy> Saizan_: thanks
19:00:45 <zbrown> lispy: I was actually reading htat chapter today though, its quite clear
19:00:47 <zbrown> :)
19:00:54 <lispy> type polymorphism is probably related to parameteric polymorphism though?
19:01:08 <zbrown> lispy: well its a paper by milner and directly related
19:01:15 <Cale> well, wikipedia has a section, but it should be completely unsurprising if you've read TaPL: http://en.wikipedia.org/wiki/Type_inference#Hindley.E2.80.93Milner_type_inference_algorithm
19:01:40 <zbrown> lispy: its in the group of Hindley-Milner papers that laid the foundation for all that
19:01:48 <Gracenotes> lispy: parametric polymorphism is a type of polymorphism. A basic (pre-TAPL, maybe) introduction to type theory is here: http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf
19:02:08 * Gracenotes enjoyed it
19:02:15 <Gracenotes> the introduction explains some informal categories of polymorphism
19:02:26 <lispy> thanks
19:02:33 <Cale> http://groups.csail.mit.edu/pag/6.883/readings/p207-damas.pdf
19:03:24 <zbrown> Cale: yup, thats a good paper too, kind of heavy
19:03:39 <zbrown> I think TAPL + the chapter in Advanced Topics in TAPL are the best places to start
19:03:42 <lispy> I guess I should just sit down and read TaPL
19:03:44 <Jebdm> Is there a function like this?
19:03:44 <Jebdm> applyList fn [a1, a2, a3...] = fn a1 a2 a3...
19:03:47 <Cale> It's the one you initially referenced :)
19:04:02 <Cale> Jebdm: what type would it have?
19:04:06 <zbrown> Cale: indeed
19:04:17 <viraptor> I've lost ability to compile profiled binaries in some way... I get a "Could not find module `Array'" error, when I compile with -prof - how can I fix it? (ghc)
19:04:48 <Jebdm> applyList :: (a -> b) -> [a] -> b
19:04:59 <BMeph> Cale, zbrown: According to oleg,... ;p
19:05:03 <Cale> Jebdm: Your function there takes only one parameter
19:05:22 <Jebdm> Except that it would be something more like (a->b->b->b...)
19:05:28 <Jebdm> Which is my problem ;)
19:05:35 <Cale> a -> a -> ... -> b  ;)
19:05:41 <zbrown> BMeph: eh?
19:05:52 <Jebdm> Oh, yeah, whoops.
19:06:10 <Cale> Jebdm: Normally if you want a function which takes an arbitrary number of parameters of the same type, you just make it take a list in the first place.
19:07:25 <zoheb> http://okmij.org/ftp/Haskell/types.html#polyvar-fn
19:07:26 <BMeph> zbrown: Oh, NM, you were referencing Cale's TaPL reference. :)
19:07:46 <zbrown> BMeph: :)
19:08:04 <viraptor> or... is there any way to enable profiling for my program without profiling included libraries?
19:08:09 <zbrown> Anyone familiar with Scala in here know what type system Scala uses, if not Hindley Milner?
19:08:14 <Cale> There are tricks which can be played with typeclasses to get variadic functions, yeah, but they're typically not worth the hassle.
19:08:21 <BMeph> It should be written somewhere: "An sufficiently advanced computer problem has been hacked by Oleg...in the type system." ;p
19:08:21 <Jebdm> Well, I'm building a VM, and what I'm trying to do is to abstract out the process of pulling a reference R and then X arguments from a list which represents the VM state, pass that to a function, and then put the result in R.
19:08:31 <BMeph> Er, *AnY
19:09:27 <Jebdm> It might be easiest to just define applyList1, applyList2, applyList 3, etc.. because I won't be pulling more than that many arguments.
19:09:43 <Jebdm> But I wanted to generalize it.
19:10:21 <Cale> yeah, that's one option. You could also take the convention that said functions take a list.
19:10:41 <Cale> (though obviously, there's a little less type safety in that)
19:11:01 <Cale> (if they will really only accept a list of a fixed length)
19:11:42 <Cale> You could also build a Template Haskell macro, but that's again something which is probably more trouble than it's worth here :)
19:11:45 <BMeph> Cale: One of the things I noticed about the K (PL/RDBMS, take your pick), is that is "overloads" list/array indexing with function application. Have you considered putting that "hack" into your Caleskell? ;)
19:11:58 <Cale> sorry?
19:12:11 <Jebdm> Well, if I was going to do it that way, it'd probably make more sense to use tuples.
19:12:28 <Cale> BMeph: Oh, I see what you mean.
19:12:53 <Cale> BMeph: But we can't overload function application in Haskell.
19:13:15 <Jebdm> Oh, duh, I can just uncurry the functions.
19:13:15 <BMeph> Jebdm: That sounds like what GHC does with partial application. :)
19:14:06 <Cale> BMeph: What people have been calling "Caleskell" was really just some minor changes to the Prelude :)
19:14:25 * roconnor calls it hascale
19:14:37 <Cale> Though, it might be nice. I don't know what problems it might cause though.
19:14:43 <BMeph> Cale: I.e., tossing two of the three of '!!', '!' and '$', and letting the "last symbol standing" do the work of all three. :)
19:15:09 <Cale> ah, with a typeclass?
19:15:18 <SamB> Cale: well, they are *small* changes
19:15:23 <SamB> but I dunno about minor
19:15:23 <BMeph> roconnor: I thought you called it, "I Can HasCale?" ;p
19:15:34 <roconnor> right
19:15:37 <roconnor> HasCale
19:16:21 * SamB kidnaps Cale so he can say "I HasCale"
19:16:36 * BMeph sez: "MOAR HasCale plz, kthxbai!"
19:19:17 <BMeph> Cale, Jebdm: or cheat, with fmap/liftM! ;)
19:19:44 <Cale> BMeph: hm?
19:20:08 <Jebdm> How would that work?
19:21:36 <BMeph> Put the function in a list, and use 'ap'/'<*>' :)
19:22:46 <BMeph> Of course, you won't know if it's a function or not, unless you know which function it is, and keep track of it somehow.
19:23:19 <Jebdm> Seems a bit.. excessive :)
19:23:45 * BMeph wish someone would just make a "Haskell, but with dependent types" language...well, by "someone" he means "someone else"... ;p
19:24:16 <BMeph> Jebdm: But it works. ;)
19:24:17 * Jebdm doesn't like types.
19:25:09 <Saizan_> BMeph: isn't that Agda2?
19:25:15 <lispy> BMeph: Omega?
19:25:30 <lispy> BMeph: well, Omega isn't fully dependent, but it's close
19:26:33 <BMeph> lispy: Yeah, closer than most. But there's something..."oogey" to me about Omega... ;p
19:27:11 <lispy> BMeph: I'm also not sure how you'd get any real work done in a dependently type language
19:36:59 <mmorrow> , let applyList n = do xs <- replicateM n (newName "x"); f <- newName "f"; lamE [varP f, listP (fmap varP xs)] (foldl appE (varE f) (fmap varE xs)) in ppDoc `fmap` applyList 4
19:37:00 <lunabot>  \f_0 [x_1, x_2, x_3, x_4] -> f_0 x_1 x_2 x_3 x_4
19:37:05 <mmorrow> , let applyList n = do xs <- replicateM n (newName "x"); f <- newName "f"; lamE [varP f, listP (fmap varP xs)] (foldl appE (varE f) (fmap varE xs)) in ppDoc `fmap` applyList 10
19:37:07 <lunabot>  \f_0 [x_1,
19:37:07 <lunabot>        x_2,
19:37:07 <lunabot>        x_3,
19:37:42 <Jebdm> Why doesn't this work?
19:37:42 <Jebdm> applyList fn l = foldl id fn l
19:37:46 <mmorrow> , $(let applyList n = do xs <- replicateM n (newName "x"); f <- newName "f"; lamE [varP f, listP (fmap varP xs)] (foldl appE (varE f) (fmap varE xs)) in applyList 4) (,,,) [0..3]
19:37:48 <lunabot>  (0,1,2,3)
19:38:13 <mmorrow> Jebdm: because haskell's type-system is such that that isn't typeable
19:38:46 <mmorrow> because, what type would it have?
19:39:08 <mmorrow> (you can get something that works using typeclass hackery or with type families though)
19:39:09 <Jebdm> I see that, but why is the type system that way?
19:39:30 <BMeph> You could type it with a T-class, like edwardk's Reducer, that'd work nicely, I bet. :)
19:39:40 <copumpkin> what would applyList do?
19:39:45 <mmorrow> Jebdm: well, it's not like that by design. that that's illegal is just a particular consequence of the type-system
19:39:57 <copumpkin> oh, I see
19:40:45 <mmorrow> Jebdm: if you were to try to give it a type, you'd see that you can't
19:40:59 <Gracenotes> no wai.
19:41:00 <mmorrow> because the type depends on the length of the list
19:41:06 <mmorrow> which isn't statically known
19:41:09 <roconnor> what are the main differences between Haskell and Miranda?
19:41:37 <BMeph> roconnor: Haskell doesn't force you to sign an NDA to use it? ;p
19:41:44 <Jebdm> I see that--I guess I'm just frustrated :)
19:41:49 <roconnor> that's the only one I can think of
19:42:28 <mmorrow> Jebdm: i think you just need to rethink how you go about doing what you want to do
19:42:31 * Jebdm wants a typeless Haskell.
19:42:37 <BMeph> roconnor: But it's a doozy. I figure if someone does the same thing with K, then they'll sink under the waves fast, too. :\
19:42:39 <Jebdm> Yeah, I've worked around it, it's just annoying.
19:42:42 <QtPlaty[HireMe]> Jebdm: How?
19:42:47 <Saizan_> roconnor: product types aren't lifted
19:42:57 <Jebdm> Untyped lambda calculus with all the rest of Haskell's features?
19:43:17 <roconnor> Saizan_: what does that mean?
19:43:26 <QtPlaty[HireMe]> But meany of thouse features depend on the typing system.
19:43:53 <Jebdm> I suppose so, but I feel like most you could get around.
19:44:05 <Saizan_> roconnor: not sure if i got the right term, but basically for types that have only one constructor all the patterns are like haskell's irrefutable ones
19:44:13 <Jebdm> IO isolation would probably be more difficult--that might actually depend on the type system.
19:44:25 <QtPlaty[HireMe]> Jebdm: How would you do pattern matching?
19:44:46 <roconnor> Saizan_: sounds like all data types that could be newtypes are newtypes
19:45:10 <Saizan_> roconnor: well, newtypes can have only one field
19:45:17 <roconnor> oh
19:45:48 <Jebdm> QtPlaty: Use functions which determined the form of their arguments?
19:45:52 <Saizan_> QtPlaty[HireMe]: pattern matching doesn't require types, though the underlying representation might need more sophisticated tags in an untped context
19:46:23 * QtPlaty[HireMe] nods
19:46:47 <SamB> well, it can't just use "0", "1", "2", "3" ...
19:47:45 <QtPlaty[HireMe]> Jebdm: Are you going to tag the types dynamic languge style?  Or be truely untyped with everything being functions (l -> l)
19:48:10 <Saizan_> btw, you can embed the untyped lambda calculus in haskell
19:48:22 <Saizan_> with a recursive type
19:48:37 <Jebdm> You would still leave in type *constructors*, etc., and you would use some basic types (for efficiency reasons) behind the scene... so, practically it would be tagged, but to the programmer it would be fully untyped.
19:49:17 <Saizan_> newtype U = U { apply :: U -> U } -- though you probably want to add some other constructor to get an observable result
19:49:22 <Saizan_> or use Data.Dynamic
19:51:07 <mmorrow> Jebdm: alternatively, you can just compile and run this short prog, which will spit out on stdout the defs for applyList1..N http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2270#a2270
19:51:34 <mmorrow> (change makeItForThese = [1..20] to suit your needs)
19:52:14 <mmorrow> (you'd probably want to put those in their own module too if you chose to go this route ...)
19:52:27 <mmorrow> TH++
19:52:34 <thoughtpolice> Jebdm: the real question I have is - what do you gain by removing the types?
19:52:40 <Jebdm> mmorrow: Thanks!
19:52:44 <mmorrow> Jebdm: np :)
19:53:33 <Jebdm> thoughtpolice: First of all, I just dislike types--typing is a bit of a hack, makes it feel "less pure" to me.
19:53:59 <Jebdm> thoughtpolice: Second of all, it makes things like (applyList fn l = foldl id fn l) work.
19:54:25 <mmorrow> Jebdm: the nice thing about types is it lets you decide 100% that everything is as it should be, then not have to do any runtime checks
19:54:41 <thoughtpolice> re (1), i don't even know what you mean by 'hack', so.. re (2), that is a super-specific case, not worth removing the entire type system for
19:55:06 <SamB> mmorrow: and then get really mad when your program ends up bottoming out anyway ;-P
19:55:11 <thoughtpolice> types *are* in fact the layer that give us purity in haskell. I mean, functions that have side effects have 'IO' in their type
19:55:28 <mmorrow> SamB: that's a logic bug, not a type bug :)
19:55:42 <thoughtpolice> this is the part of the language that enforces you are pure
19:55:51 <SamB> mmorrow: you said EVERYTHING!
19:55:57 <thoughtpolice> this is why unsafePerformIO has type 'IO a -> a'
19:55:59 <Jebdm> Meaning it's something like unit tests and debugger breaks--useful, but not really something that has to be built into the language.
19:56:06 <SamB> even in Coq you generally don't get to prove that ;-P
19:56:07 <mmorrow> SamB: you got me
19:56:41 <thoughtpolice> Jebdm: I'm still not following you at all, I don't really see how haskell would be any more useful without types
19:56:41 <Jebdm> As far as type errors, Haskell is the first language I've found myself making very many in.
19:56:44 <thoughtpolice> okay, so you remove types
19:56:48 <thoughtpolice> you still have laziness and purity
19:57:01 <SamB> Jebdm: they're actually there to help you
19:57:05 <thoughtpolice> wait, you don't have types, so the compiler can't statically enforce and track functions which have side effects
19:57:08 <Jebdm> I don't think typing should go away, but that it should be more like a unit test.
19:57:12 <thoughtpolice> but wait, if the compiler can't distinguish pure things
19:57:15 <thoughtpolice> you can't have laziness
19:57:21 <thoughtpolice> so you've basically botched everything right there
19:57:27 <SamB> knowing I'll get them makes me more confident to make bigish changes ;-)
19:57:42 <mmorrow> Jebdm: for instance, if you use unsafeCoerce and mess up, you'll segfault. because at runtime nothing is checked... so you can apply '4' to '4' if you want and the generated code will attempt to do it (resulting in a crash most likely)
19:58:36 <mmorrow> in a dynamically typed language, the generated code would need to first check that '4' is a function, find out that it isn't, throw an error, then you'd have to deal with it (or crash)
19:58:36 <Jebdm> I think you're right that you can't hide IO's impurity without a type system, but there may of course be some way.
19:58:42 <mmorrow> that's a lot of overhead
19:58:48 <thoughtpolice> Jebdm: the type system by design has to be 'conservative.' this means that it must reject certain programs, some of which certainly seem typeable, but are not
19:58:52 <confuzed> hello all..
19:59:06 <mmorrow> in a typed language you have the guarantee that trying to apply '4' to '4' will *never* happen
19:59:11 <thoughtpolice> Jebdm: but the type system is sufficiently flexible that it allows you to have a high amount of confidence in your code
19:59:14 <copumpkin> the only two laws a functor must obey is fmap id = id and fmap a . fmap b = fmap (a .b), right?
19:59:16 <Jebdm> Which means you would have to build a separate mechanism for IO.
19:59:19 <monochrom> > 4 4
19:59:20 <lambdabot>       No instance for (Num (t -> a))
19:59:20 <lambdabot>        arising from the literal `4' at <...
19:59:22 <thoughtpolice> Jebdm: but no, that doesn't remove unit testing either
19:59:22 <confuzed> any algorithmic wizards around here?
19:59:24 <mmorrow> monochrom: heh
19:59:27 <thoughtpolice> Jebdm: that's why we have quickcheck
19:59:37 <thoughtpolice> Jebdm: because purity is so awesome, the library does all our testing for us
19:59:46 <copumpkin> confuzed: if you want wizards, #sicp is the place to go
19:59:47 <Gracenotes> confuzed: perhaps you are looking for ##sicp :P </joke>
19:59:54 * copumpkin muahahahaas evilly
19:59:54 <Gracenotes> oh, snap
20:00:02 <Gracenotes> I get points for getting the channel name right though
20:00:05 <copumpkin> :(
20:00:08 <thoughtpolice> Jebdm: IO is in fact nothing at all in haskell, it is, truly, just a hack at the type level so the compiler knows how to sequence actions properly
20:00:11 <Gracenotes> <_<
20:00:14 <SamB> copumpkin, Gracenotes I don't get it :-(
20:00:24 <confuzed> haha whats sicp..?
20:00:24 <Jebdm> Yeah, which is why I'm saying that it doesn't really matter.
20:00:29 <copumpkin> the sicp book has a wizard on the cover
20:00:30 <gwern> hm. what's the linux command for a lowlevel trace of systems calls? called lstate or something like that
20:00:31 <thoughtpolice> how does it *not* matter?
20:00:35 <Gracenotes> *huggles copumpkin to assuage his certain anger*
20:00:37 <thoughtpolice> Jebdm: did you read what I said above?
20:00:37 <gwern> confuzed: venerable scheme textbook
20:00:38 <SamB> copumpkin: oh
20:00:40 <copumpkin> gwern: strace
20:00:46 <gwern> ah, thanks
20:00:50 <thoughtpolice> Jebdm: with all that, how can the IO type and more generally, types, not matter?
20:00:53 <Jebdm> Have things which do IO be completely separate, since it's already a hack--have a small imperative part of the language.
20:00:55 <wli> SICP translated into Haskell?
20:00:55 <thoughtpolice> they are an integral part of the language
20:00:58 <SamB> maybe I only looked at it in links or something ;-P
20:01:04 <copumpkin> wli: I'd like that
20:01:10 <mmorrow> Jebdm: "tests can only tell you what didn't/did happen, whereas types tell you what *never*/*always* _will_ happen"
20:01:12 <Gracenotes> confuzed: so what is your query?
20:01:14 <copumpkin> wli: but it'd need more haskell-specific chapters on types and so on
20:01:16 <SamB> it's hard to get the right instance without types ;-P
20:01:20 <gwern> wli: sicp is partially translated into haskell
20:01:36 <Gracenotes> what is your name? what is your quest? what is your favorite color?
20:02:08 <thoughtpolice> Jebdm: but *why*? i'm still not seeing what you're going to get by removing something so engrained in the language and ethos around it
20:02:11 <confuzed> i need a better line following algorithm than the one i have right now
20:02:20 <kadaver_> try clojure for a while then tell me that is better...i think you wont
20:02:31 <Jebdm> I'm not saying it should be removed from Haskell, I would just prefer an untyped language.
20:02:36 <confuzed> my rs232 pins just blew up so i can't debug for trial and error anymore and tomorrows the big day
20:02:49 <confuzed> i.e. i'm shitting myself
20:02:52 <copumpkin> Jebdm: scheme is pretty nice :)
20:03:07 <thoughtpolice> copumpkin: agreed
20:03:12 <thoughtpolice> copumpkin: i like clojure too
20:03:26 <copumpkin> never tried clojure myself, but it has an awesome name
20:03:29 <Jebdm> What do I get?  A language which better separates its concerns--types are basically a kind of test.
20:03:33 <SamB> confuzed: I don't think we can help you there!
20:03:41 <Jebdm> Additionally, a much simpler model.
20:03:51 <gwern> I don't really get 'clojure'
20:03:53 <thoughtpolice> Jebdm: types and tests don't just negate each other
20:03:54 <mmorrow> Jebdm: (types are more than a test, they're a guarantee)
20:03:56 <thoughtpolice> i use both
20:04:04 <thoughtpolice> you seem to think they do
20:04:18 <SamB> Jebdm: how does the system pick the right Monad instance with no types ?
20:04:21 <Jebdm> Scheme isn't untyped, I don't think (I'm not terribly familiar), and it's also not lazy.
20:04:30 <SamB> or Num, or ...
20:04:30 <thoughtpolice> scheme is untyped
20:04:34 <Jebdm> It falls under the same category, is my point.
20:04:35 <thoughtpolice> and no, it is not lazy
20:04:58 <copumpkin> it does have a lazy construct though
20:05:01 <Jebdm> It represents things with type--types are "tagged".
20:05:11 <copumpkin> oh, I thought that's what you said you wanted earlier
20:05:14 <Jebdm> I'm assuming, at least.
20:05:15 <thoughtpolice> laziness is more than just an evaluation strategy
20:05:23 <thoughtpolice> laziness is a part of the language, it's a part of a library
20:05:51 <thoughtpolice> building lazy data structures in a strict world can be dangerous because when you have things forcing evaluation everywhere, you lose benefits that laziness-by-default give you and that's hard to get back
20:05:51 <Jebdm> Nah, it should appear untyped--just tag certain things behind the scenes for efficiency purposes.
20:06:00 <ygui> hi there, a question about redundant calculations :) I'm thinking of the "fib" recursive function definition: fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2). For example, fib 10 = fib 9 + fib 8; fib 9 = fib 7 + fib 8..., if n is large, for example, when n = 40, the running time takes about 20 seconds if compile with no optimization with GHC (optimization level 1 by default).  My question is, is there anyway to avoid the redundant calculations?
20:06:08 <thoughtpolice> also, purity is the *only* logical model for full blown lazy evaluation by default
20:06:20 <copumpkin> ygui: certainly!
20:06:23 <SamB> ygui: there is a technique called memoization
20:06:27 <thoughtpolice> and if you want purity, you need some notion to enforce and check *statically* that pure code doesn't have side effects
20:06:34 <thoughtpolice> because side effects + laziness don't make sense
20:06:48 <copumpkin> > fix ((0:) . scanl (+) 1)
20:06:49 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
20:06:51 <SamB> which is how come we're still pure ;-P
20:06:51 <Jebdm> You don't have to check that things don't have side effects--just don't provide a way to induce them.
20:06:56 <thoughtpolice> and you know what? types give you that
20:06:59 <copumpkin> (/me stole that from mmorrow)
20:07:08 <wli> ygui: let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs !! n
20:07:11 * mmorrow stole that from someone else
20:07:11 <cjs> It's very nice to check statically that code doesn't have side effects, but I don't think it's strictly (ha ha!) necessary.
20:07:24 <blackdog> thoughtpolice: you could argue that unix command line language is lazy and untyped
20:07:27 <Jebdm> Have two notions-- procedures and functions.
20:07:28 <thoughtpolice> blackdog: yes
20:07:33 <thoughtpolice> blackdog: oleg has written on this
20:07:37 <mmorrow> yeah, there's nothing nonsensical about side-effect and laziness
20:07:43 <SamB> Jebdm: like in Pascal ? ;-P
20:07:49 <mmorrow> it's just that it's harder to reason about what happens when
20:07:58 <Jebdm> The majority of code would be in functions, and procedures would basically just be a script on a REPL.
20:08:05 <blackdog> thoughtpolice: every time i read oleg's stuff i come away impressed but no wiser :/
20:08:08 <mmorrow> monads are one of many possibly ways to order evaluation
20:08:10 <Jebdm> Well, it doesn't mean very much in Pascal.
20:08:17 <thoughtpolice> mmorrow: i'm arguing that purity is really the only model for full-blown lazy evaluation
20:08:26 * SamB is teasing, hence the tongue-out smiley
20:08:29 <thoughtpolice> mmorrow: and you probably want some way to track that - the world has enough impure languages already
20:08:34 <thoughtpolice> laziness is the hair shirt you wear
20:08:37 <thoughtpolice> because it keeps you honest
20:08:52 <mmorrow> thoughtpolice: i think purity and laziness are orthogonal
20:08:55 <thoughtpolice> blackdog: i get that feeling a lot
20:08:55 <cjs> I wonder if it's fair to think of monads as giving us even control flow for the order in which things are executed. Or rather, if it's fair to think of even that as control flow.
20:09:16 <copumpkin> the notion of sequencing is just that, isn't it?
20:09:18 <thoughtpolice> blackdog: when i'm reading oleg's stuff at least
20:09:19 <SamB> mmorrow: have you tried the latter without the former much ?
20:09:21 <ygui> thanks! let me think...
20:09:25 <copumpkin> using the data dependency to enforce ordering
20:09:30 <mmorrow> SamB: yes
20:09:37 <cjs> BTW, as far as types go, particularly in regard to ideas like Scheme being "untyped": http://www.pphsg.org/cdsmith/types.html
20:09:44 <mmorrow> SamB: unsafePerformIO!
20:09:45 <SamB> mmorrow: how much hair do you have left on your head?
20:09:54 <Jebdm> I don't disagree, thoughtpolice--I just think that separating purity and side effects via the type system is a (albeit neat) hack, and a lot harder to understand and work with.
20:09:57 <mmorrow> SamB: some around my left ear
20:10:04 <SamB> mmorrow: I rest my case
20:10:19 <cjs> Yes, but it's interesting in that most imperative programmers wouldn't think of, "the second line executes after the first" as needing a control structure.
20:10:19 <thoughtpolice> copumpkin: exactly, this is why i said the IO monad is really 'nothing at all'
20:10:45 <blackdog> Jebdm: i disagree completely. It's just another case of statically enforcing runtime constraints with the type system
20:10:56 <blackdog> just like it stops you from adding characters and integers
20:11:03 <thoughtpolice> blackdog: yes, i said 'hack' earlier but it is really nothing of it
20:11:11 <cjs> Jebdm: I'd disagree that it's a "neat hack"; this is what type systems do!
20:11:13 <thoughtpolice> it's a good solution that fits the abstraction we now love: monads
20:11:48 <SamB> or the one we are now no-longer-thrilled by -- take your pick ;-P
20:11:49 * BMeph thinks Haskell needs to jump on the comonad bandwagon, while the field is still young... ;)
20:12:11 * SamB makes booov booov noises
20:12:46 <mmorrow> Jebdm: it lets you write evalbots that don't have to be in a sandbox
20:12:55 <mmorrow> , readFile "/etc/passwd"
20:12:56 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO GHC.Base.String))
20:13:11 <thoughtpolice> osnap
20:13:17 <thoughtpolice> you mean i can't like
20:13:31 <thoughtpolice> rm -rf ~/ ?
20:13:34 <mmorrow> , appendFile "/etc/passwd" "zomg:asdf:liklol"
20:13:36 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
20:13:49 <thoughtpolice> @bot
20:13:50 <lambdabot> :)
20:13:50 <lunabot>  :)
20:13:51 <cjs> Actually, it's kind of interesting; the two most common control flow structures implemented in monads are one which is implicit in imperative languages (sequential computation), and one which is a real pain in the ass to do (aborting a sequence of computations in an arbitrary place).
20:14:14 <Jebdm> Is it not still a sandbox?
20:14:23 <copumpkin> it's a bag o' sin
20:14:25 <copumpkin> ;)
20:14:46 <ygui> SamB: I'm looking at the doc of memoization, at http://haskell.org/haskellwiki/Memoization, interesting...
20:14:46 <blackdog> Jebdm: i think the implication of sandbox is that you have checked runtime calls
20:15:04 <Jebdm> It seems like the bots just don't have the appropriate functions, which I thought was the obvious way to implement a sandbox.
20:15:36 <Jebdm> Well, in a language that is sufficiently high level.
20:15:41 <mmorrow> Jebdm: a sandbox is an environment in which a program runs where certain calls/actions are intercepted
20:15:51 <mmorrow> Jebdm: here, the readFile *never happens*
20:16:35 <Jebdm> You can have the same effect in, say, Python, just by removing the appropriate functions.
20:16:43 <mmorrow> imagine a C evalbot with fopen/fread/fwrite available
20:16:58 <mmorrow> Jebdm: but we don't need to even bother hiding them!
20:17:17 <mmorrow> all that needs to be hidden is unsafePerformIO
20:17:22 <Jebdm> You don't in Python, either.  Just remove them.
20:17:32 <solrize> dons' galois slides are good, i just started looking.  talks about types
20:17:33 <mmorrow> Jebdm: we don't even need to remove them!
20:17:41 <Jebdm> How so?
20:17:50 <Jebdm> They're defined by default; you have to make them undefined.
20:17:59 <mmorrow> , writeFile "omg.txt" "OH HAI"
20:18:01 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
20:18:04 <mmorrow> , ksjkdjksjfdl
20:18:05 <lunabot>  luna: Not in scope: `ksjkdjksjfdl'
20:18:39 <Gracenotes> ugh... I'm an idiot. I keep generating tables, keep testing them against values that aren't in the keyspace, getting frustrated when they don't work, and deleting the tables
20:18:52 <Gracenotes> *waits 15 minutes to generate next one*
20:19:05 <Saizan_> Jebdm: the whole expression is used as arguemnt to show, so you're just going to display its value
20:20:03 <Jebdm> It's a bit easier in Haskell, because all unsafe action is routed through one thing; if you routed all python IO through a system object or something, you could just remove that object (although I don't think that's actually how they implemented it).
20:20:07 <Saizan_> for IO actions one might decide to show "IO", but lunabot just lacks such a Show instance
20:20:43 <Jebdm> So, you would do
20:20:43 <Jebdm> system.writeFile(someFile, "blahblah")
20:20:52 <Jebdm> And if system wasn't defined, it'd be the same thing.
20:21:02 <Saizan_> yeah, but it's quite different
20:21:19 <Saizan_> here system is still defined :)
20:21:20 <Jebdm> In this case, the mechanism happens to be the type system, but it's not really type-system specific.
20:21:48 <mmorrow> Jebdm: so them you have to comb every single library you make available and remove every single function that anywhere deep down and possibly obscured does something/anything undesireable to something
20:22:07 <Jebdm> No, just delete system.
20:22:21 <blackdog> you could simulate it in python, i guess. I suppose the benefit is that the type system helps you organise your libraries in a consistent way
20:22:27 <mmorrow> what about some library that Gerald wrote that you want to make available through the bot?
20:22:32 <Jebdm> Then, if any library tries to do something undesireable, it throws an exception.
20:22:39 <mmorrow> what if he has a myWriteFile!!!!
20:22:50 <blackdog> so you have to decide what undesirable means
20:23:03 <Jebdm> Right, but you have to do that anyways.
20:23:12 <mmorrow> Jebdm: not in haskell
20:23:16 <blackdog> yep. but types help you keep it consistent.
20:23:31 <mmorrow> undesireable := execute an IO action
20:23:40 <Jebdm> He can't have a myWriteFile, is the point--omit the ability to do bad things from the language.
20:23:40 <blackdog> mmorrow: you do really. it just so happens that we've already got this division of IO and non-IO
20:23:41 <mmorrow> solution, hide unsafePerformIO
20:23:54 <Jebdm> I guess if you're allowing arbitrary linking of binaries, it's an issue
20:24:02 <Jebdm> but if you're doing that, you're screwed already ;)
20:24:29 <Jebdm> By omit, I mean only make it available through one mechanism.
20:24:37 <Jebdm> For instance, a system module
20:24:54 <Saizan_> using the IO monad looks like a very nice solution to encapsulate side-effects, keeping extending the same system object doesn't look as much flexible
20:25:24 <Jebdm> you wouldn't have to extend the system object
20:25:31 <mmorrow> Jebdm: clearly you can do this in any language. the only point i'm trying to make is that it's easier in haskell because the fact that it's doing any IO is reflected in the type, which makes it checkable by the type system and not up to the programmer to enforce
20:25:58 <Jebdm> just have everything you'd want to do (write files, network stuff) in a system object
20:26:18 <Jebdm> you wouldn't have to extend the system object to write a new function, just pass it a message
20:26:24 <Saizan_> Jebdm: yeah, but libraries will want to extend that
20:26:45 <Saizan_> i.e. from FFI or something similar
20:27:19 <Jebdm> I suppose so, but in Haskell wouldn't the relevant functions have to be marked anyways?
20:27:29 <mmorrow> heh, they're marked by their type
20:27:56 <cjs> Seems to be a sensible way to do this might instead be to change the run-time system to essentially run it in its own virtual machine?
20:28:14 <cjs> Then someone writes a file, well, they write a file somewhere, but it's not a f
20:28:16 <Jebdm> Right--but if you don't mark the type when you make it available to Haskell, then Haskell doesn't know it's unsafe.
20:28:31 <Jebdm> Although I'm sure that's the default
20:28:40 <cjs> ...necessarially a file in the underlying OS. It may always be /dev/null, if you want to be simple.
20:28:48 <wli> I'm still trying to figure out how to interpret with a nontrivial module system in tow, where most of the headaches center around the static checking (e.g. type checking/inference, signature checking/inference, etc.)
20:28:55 <kbateman> ygui:  I wrote a basic memoizer a while back, it's at http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2271#a2271 and I put a fibonacci example there too.
20:28:59 <Jebdm> Yeah, that'd be an easy way as well--stub out the dangerous stuff
20:29:04 <Saizan_> Yeah, the point is not knowing, but the best way to communicate the knowledge
20:29:40 <Saizan_> (and encapsulating IO is not useful only for sandboxing purpouses)
20:29:58 <Jebdm> I don't disagree--I think encapsulating IO is a great idea.
20:31:00 <Jebdm> I just would rather not do it through the type system--I like the idea of an untyped pure lazy lambda calculus, with no IO, combined with an imperative driver for that language
20:31:31 <mmorrow> Jebdm: the unfortunate thing there is that you have to constantly be checking "types" at runtime
20:31:35 <kbateman> D has some interesting ideas about isolating effects, and immutability
20:31:38 <mmorrow> killing performance
20:31:46 <Jebdm> Kind of like writing my functions in Haskell, and then running them via C
20:32:05 <Jebdm> Why would you have to check types at runtime?
20:32:21 <mmorrow> Jebdm: you would rather an exception be thrown than a segfault, right?
20:32:35 <Jebdm> Give me an example of what you mean
20:32:41 <Jebdm> I mean, obviously you would have to sometimes
20:32:46 <Jebdm> But not that often.
20:32:51 <copumpkin> ("5262" ++ id) 5
20:33:02 <mmorrow> but you need to check to know if you have to! :)
20:33:12 <kbateman> How do you represent ints in an untyped lazy lambda calculus?
20:33:17 <mmorrow> with static types, that check is done at compile-time
20:33:25 <kbateman> Jebdm:  Maybe you just want to learn lisp. :)
20:34:23 <Jebdm> ("5262" ++ id) 5 should do something.
20:34:36 <Jebdm> In the untyped lambda calculus, all functions return functions, always.
20:34:46 <Jebdm> So it would have to check anyways.
20:34:53 <kerlo> According to delimited continuations, ("5262" ++ id) 5 = "5262":5. According to JavaScript, that's "52625".
20:34:53 <Jebdm> Shit.
20:35:25 <Jebdm> It wouldn't segfault, though
20:35:34 <copumpkin> well, maybe not in those languages
20:35:51 <copumpkin> but even if the concatenation of a string and a function might succeed
20:35:58 <kerlo> Assuming that id = shift id.
20:36:02 <copumpkin> calling the string on a number would be odd
20:36:04 <kerlo> Which would actually be weird.
20:36:14 <Jebdm> Yeah, it'd be weird, but it should work.
20:36:20 <copumpkin> no it shouldn't
20:36:24 <copumpkin> the function call typically involves jumping somewhere
20:36:28 <kerlo> You need a reset too, of course.
20:36:31 <Jebdm> I mean, it shouldn't crash the computer.
20:36:43 <copumpkin> it'll definitely do something unpredictable
20:36:47 <kerlo> reset ("5262" ++ shift id), modulo monadic stuff.
20:36:49 <copumpkin> unless you crafted the string on purpose
20:36:57 <Jebdm> If you've got undefined behavior, you haven't got a ULC
20:37:08 <Jebdm> function
20:37:24 <mmorrow> Jebdm: without dynamic type checking, it'd be pretty easy to execute arbitrary machine code
20:37:35 <copumpkin> I was just giving you an example of why you'd want to check the types at runtime :P
20:37:42 <ygui> kbateman: thanks for the example of memoizer
20:37:54 <Jebdm> You could protect against arbitrary machine code
20:37:55 <Saizan_> i guess you're discussing about different lowlevel representations :)
20:37:56 <copumpkin> also, depending on how the strings are represented, even the append could crash the program
20:38:06 <mmorrow> Jebdm: and how would you do that?
20:38:14 <mmorrow> (==> dynamic runtime type checking)
20:38:20 <Jebdm> Which doesn't mean that you won't have arbitrary "code", but it would all be with the ULC.
20:38:29 <mmorrow> what is a ULC?
20:38:31 <Jebdm> You wouldn't have to do anything, actually.
20:38:37 <Jebdm> Untyped Lambda Calculus
20:38:41 <Jebdm> within*
20:38:43 <Saizan_> if you're just manipulating lambda expressions you won't get segfaults..
20:38:48 <Jebdm> right-o
20:38:52 <kbateman> ygui: no problem
20:39:01 <Saizan_> but that's horribly slow, i'd think
20:39:03 <copumpkin> well yeah, I thought we were talking about a real language though
20:39:11 <mmorrow> Jebdm: ok, now add the ability to do anything useful to this language
20:39:26 <Jebdm> You'd obviously special case the common cases, but you can do that without making it visible.
20:39:44 <copumpkin> how can you special case if you're not checking the types in the first place?
20:39:47 <Jebdm> Don't use Church numerals, but make it look like you do.
20:40:14 <sw17ch> any one else playing with atom?
20:40:37 <Saizan_> so expand machine integers to church numerals if they are applied to something?
20:40:51 <Jebdm> Yeah, basically
20:41:10 <sw17ch> @seen dons
20:41:11 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 24m 47s ago.
20:41:17 <roconnor> how do you know if + is being applied to a church numeral?
20:41:33 <Jebdm> You'd still have to do some type tagging, but it wouldn't be part of the language so much as the implementation
20:41:38 <Gracenotes> wow, typeclasses are awesome. I just ran s/Integer/Word64/g on my 90 lines of code, and it compiled great :D
20:41:54 <Gracenotes> </testimonial>
20:41:57 <roconnor> Gracenotes: type synonym plz
20:41:59 <mmorrow> Jebdm: all type checking in dynamic languages is part of the implementation
20:42:08 <mmorrow> it's hidden from the user
20:42:16 <Gracenotes> roconnor: oh, not a bad idea. type Index = Word64
20:42:17 <Jebdm> I'm assuming this language is compiled.
20:42:28 <Gracenotes> anyway, I'm definitely going to use Word64, but may as well have the code all neat
20:42:40 <mmorrow> Jebdm: the generated machine code would need to include the checks. nothing changes
20:42:42 <Jebdm> You could eliminate a lot of the type checking at compile time
20:42:57 <copumpkin> Jebdm: that's what you were advocating against, wasn't it?
20:43:05 <mmorrow> Jebdm: hehe, static types eliminate **ALL** type checking at compile-time
20:43:06 <copumpkin> that's what haskell does :P
20:43:29 <Jebdm> But it also eliminates a lot of nice things that you can do if you don't have typechecking.
20:43:43 <copumpkin> like what?
20:44:02 <mmorrow> Jebdm: the type system is frustrating at first
20:44:05 <Jebdm> Like simple vararg functions
20:44:19 <copumpkin> you can have vararg functions using typeclass hacks
20:44:26 <copumpkin> as long as the number of args is known at compile time
20:44:41 <Saizan_> yeah, type systems are like that, with the errors you've to take away some of the good programs, thank you Goedel, thank you!
20:45:04 <Jebdm> At compile time is the kicker ;)
20:45:14 <jmzz> ive got a function that takes a list of strings and concatenates them but ive written it which mean si have two parameters, one in which in accumulate the result. is there a way to write this function neatly to avoid having to call the first call with the empty string?
20:45:17 <Gracenotes> okay, here's hoping performance won't go to hell
20:45:22 <copumpkin> Jebdm: why do you not know the number of args at compile time, and if you don't, can't you just use a list or a struct?
20:45:46 <dibblego> jmzz, just use concat or join
20:46:00 <Jebdm> You can obviously work around things with a list or struct, but it's often a pain in the ass
20:46:15 <Jebdm> Take the ridiculousness of zipWith, zipWith2...7
20:46:15 <mib_nbvhyk> #haskell
20:46:46 <kbateman> jmzz:  foldr (++) []
20:46:47 <mib_nbvhyk> does anybody know how do I connect to lambdabot?
20:46:55 <jmzz> dibblego: i want to know if there is a trick. the onyl thing i can thing of is having a new function which calls that function with the first argument filled in
20:46:55 <kbateman> just /msg it
20:46:57 <Jebdm> You can get around it, but it's just not as nice
20:47:05 <wli> zipWith3 .. 7?
20:47:12 <wli> There are varargs
20:47:34 <wli> Text.Printf.printf
20:47:37 <Saizan_> Jebdm: there's also the other solution: use a stronger type systems where zipWithN is typeable
20:48:38 <Saizan_> jmzz: that's what's usually done, yeah
20:49:01 <Jebdm> That'd be fine as well, but a lot more difficlut.
20:49:03 <jmzz> ok, that's a bit ugly
20:49:05 <Jebdm> difficult*
20:49:26 <Saizan_> jmzz: btw if your result is a list you usually don't want to use an accumulating parameter, so that it can be lazy
20:49:46 <jmzz> Saizan_: interesting
20:49:47 <Jebdm> A lot of my aversion to types is subjective--I just like it when everything comes in one variety.
20:50:16 <Saizan_> e.g. map
20:50:17 <copumpkin> what practical language has just one variety?
20:50:18 <Saizan_> ?src map
20:50:19 <lambdabot> map _ []     = []
20:50:19 <lambdabot> map f (x:xs) = f x : map f xs
20:50:22 <Jebdm> assembly
20:50:26 <jmzz> would be nice if it could just be part of the function defn, that if its called with one argument, then do this .. instead of having to write a whole new auxillary function
20:50:28 <Jebdm> everything's a byte
20:50:28 <mmorrow> Jebdm: i think you'd find it interesting to implement your own mini language
20:50:45 <Jebdm> mmorrow: I do find it quite interesting, in fact ;)
20:50:45 <copumpkin> Jebdm: not really
20:51:09 <mmorrow> Jebdm: nice. i look forward to playing with your first release :)
20:51:27 <copumpkin> Jebdm: on most archs, there are types of registers, that you can't directly move things between
20:51:40 <Saizan_> jmzz: we usually write something like foo arg = foo' [] arg where foo' .. = .., so that it's still pretty clean
20:51:44 <Gracenotes> neat, Haskell did a million chains in less than a second :)
20:51:45 <copumpkin> float registers and int registers, int registers of different sizes, single float and double float
20:51:46 * wli has yet to figure out the module system problems.
20:52:02 <Gracenotes> a million chains in a second is great, but unfortunately, I have to write it to the disk at the same time
20:52:10 <copumpkin> chains of what?
20:52:12 <Jebdm> copumpkin: you can usually move things directly
20:52:17 <Gracenotes> rainbow chains, in a rainbow table
20:52:18 <wli> What's a chain in this context?
20:52:31 <copumpkin> Jebdm: not in the assembly languages I know of
20:52:32 <wli> I don't know what a rainbow chain or rainbow table is.
20:52:38 <Gracenotes> applying a hash and reduction function a given number of times (16 in this case), and saving only the start and end points
20:52:45 <Jebdm> copumpkin: a lot of the time it'll be a different instruction, because (for instance) floats are usually on a coprocessor
20:52:53 <copumpkin> yup
20:52:58 <jmzz> Saizan_: understood. im not sure if this language has that feature, but i'll have a look
20:53:02 <copumpkin> Jebdm: that's the point
20:53:06 <copumpkin> Jebdm: the instructions have types
20:53:07 <Gracenotes> it's used for cracking cryptographic hashes, in which set-up time is comparatively speedy and cracking is near-instantaneous
20:53:10 <copumpkin> as do the registers
20:53:19 <Gracenotes> Haskell did well :)
20:53:21 <Jebdm> no, all of the registers are a series of bits.
20:53:27 <copumpkin> Jebdm: same in haskell
20:53:38 <copumpkin> the types are just instructions on how to interpret the series of bits ;)
20:53:40 <kbateman> rainbow chains: http://www.sdclov.org/Rainbow_Chain_Of_Hope_K5CB.html
20:53:53 <Gracenotes> not quite >_>
20:53:55 <Jebdm> exactly-- you have add and floatadd
20:54:06 <Jebdm> but the registers themselves aren't typed
20:54:10 <copumpkin> yeah they are
20:54:13 <mmorrow> (int)42 != (float)42  w.r.t. bits
20:54:44 <copumpkin> Jebdm: you can argue that Int64 and Double are the same thing
20:54:49 <copumpkin> because they're both 64 bits
20:54:50 <Jebdm> they're labeled for use by certain types, but you could in theory move the byte representation of an int to a register meant for a float
20:54:55 <Gracenotes> and the neat part is, the C++ version uses like 600 lines of code, and Haskell uses about 50
20:55:01 <copumpkin> Jebdm: you can do the exact same thing in haskell
20:55:02 <mmorrow> Jebdm: yes, but it won't be the same number then
20:55:05 <Jebdm> it would probably be useless
20:55:18 <Jebdm> sure it would, if you interpreted it as an int
20:55:24 <Gracenotes> granted, the C++ version has some extra functionality like pretty-printing data and parsing charsets, which comes free in Haskell libraries
20:55:26 <mmorrow> but not if interp as a float
20:55:31 * Gracenotes huggles haskell
20:55:32 <Jebdm> of coruse
20:55:39 <Jebdm> which is my point--that it's about the interpretation
20:55:39 <copumpkin> Jebdm: also, negativity will change
20:55:45 <copumpkin> yes, that's what types are about :P
20:55:54 <mmorrow> and no istructions i know of that operate on ints take floating regs
20:56:00 <cjs> Actually, I do exactly that as a hack for storage of IEEE floating-point numbers in logfiles.
20:56:02 <copumpkin> assembly languages typically have a very basic type system too
20:56:12 <copumpkin> if you can even call it a type system
20:56:23 <Gracenotes> you can. I give you permission
20:56:31 <copumpkin> the assembler checks that you used int registers of a given size on an int instruction
20:56:31 <cjs> mmorrow: no, but you can still use the FP regs as fast spillover for int regs; optimizing compilers do this.
20:56:39 <Jebdm> types enforce the abstraction that different things are stored as different actual things
20:57:00 <Jebdm> they attach the meaning to the storage, not how you use it
20:57:09 <copumpkin> o.O
20:57:35 <cjs> Jebdm: actually, they attach meaning to how you use it from time to time. See my int -> FP register spillover example above.
20:57:46 <Gracenotes> hm. is there a sizable Chan?
20:57:51 <Jebdm> you can see this in something like:
20:57:51 <Jebdm> a = 1;
20:57:51 <Jebdm> b = 2.0;
20:57:51 <Jebdm> a + b
20:57:55 <Gracenotes> meaning, a version that has a limit?
20:58:06 <copumpkin> Jebdm: so basic arithmetic as people typically use it is untyped
20:58:15 <cjs> Gracenotes: no, and it would have to be implemented in a completely different way for that to work.
20:58:22 <Jebdm> you have to figure out what + means there, and different systems do it different ways
20:58:22 <copumpkin> Jebdm: you wouldn't be able to use the same + in asm for ints and floats, usually
20:58:26 <Jebdm> right
20:58:36 <cjs> Gracenotes: well, not that I know of, anyway. The current one is implemented as nested MVars.
20:58:43 <Jebdm> that's what i'm saying--that you can put the types in the operations
20:58:47 <Gracenotes> hm. Well, maybe an IOArray could be used
20:58:49 <Jebdm> so get rid of +
20:58:52 <copumpkin> Jebdm: you'd have plusInt :: Int -> Int -> Int and plusFloat :: Float -> Float -> Float, and maybe translateFloat :: Float -> Int
20:58:58 <mmorrow> cjs: sure
20:59:00 <Gracenotes> cjs: like a ring buffer
20:59:02 <copumpkin> Jebdm: the operations have operands, and the types apply to their operands :P
20:59:03 <Jebdm> addIntToFloat a b
20:59:09 <cjs> Gracenotes: but it ought not be to hard to implement yourself. As you just figured out. :-)
20:59:09 <Jebdm> right
20:59:13 <Gracenotes> there might be some blocking, but... I guess that's a price to pay
20:59:14 <copumpkin> Jebdm: so what's your point? :P
20:59:30 <cjs> Gracenotes: not much, actually, if you use something like a work-stealing queue.
20:59:35 <Jebdm> addIntToInt a b should work as well
20:59:38 <Jebdm> and it does, in assembly
20:59:44 <copumpkin> which assembly are you speaking of?
20:59:54 <mmorrow> cjs: (i was just trying to say that a single higher level concept doesn't necessarily always have the same representation (or something like this))
20:59:57 <Jebdm> any assembly--
21:00:00 <copumpkin> Jebdm: um
21:00:03 <Jebdm> with support for floats
21:00:11 <sjanssen> assembly++
21:00:13 <Gracenotes> cjs: ah, yes. *dusts off concurrency algorithms book*
21:00:16 <copumpkin> heh
21:00:25 <copumpkin> Jebdm: have any concrete examples?
21:00:28 <Gracenotes> preflex: karma assembly
21:00:29 <preflex>  assembly has no karma
21:00:32 <copumpkin> I have yet to see one of those
21:00:36 <Jebdm> um, sure
21:01:03 <Jebdm> loadi $t, 5
21:01:11 <cjs> Damn, Wikipedia doesn't have a page on work-stealing queues!
21:01:18 <Jebdm> loadi $t2, 3.0
21:01:29 <Jebdm> add $t3, $t2, $t1
21:01:43 <copumpkin> I don't know that one, but it looks like something the assembler is doing for you?
21:01:49 <cjs> Gracenotes: anyway, if it's not described in our book, there was a paper on the SunOS 2 kernel scheduler that discussed it.
21:01:58 <Jebdm> it should give gobbeldygook, since it's trying to interpret the representation of 3.0 as an int
21:02:07 <copumpkin> what assembly is that?
21:02:25 <Jebdm> abstract assembly from my head, but it think it would work on MIPS
21:02:50 <Gracenotes> all right. thanks :) *tries implementing*
21:02:51 <cjs> Gracenotes: If you implement this, upload it to hackage.
21:03:00 <copumpkin> Jebdm: in mips I believe you have a suffix on the instruciton
21:03:03 <copumpkin> add.s or .d
21:03:09 <Jebdm> because the assembler converts the string "5" to the integer representation
21:03:10 <copumpkin> depending whether you want to use single or double precision floats
21:03:18 <Jebdm> i meant the integer add
21:03:21 <cjs> Gracenotes: Oh, and remember to look at the case for multiple readers, even if you decide not to implement it. That could be interesting.
21:03:27 <Jebdm> which is just add
21:03:48 <Gracenotes> cjs: well. Read and Write locks, maybe.
21:03:52 <copumpkin> Jebdm: heh
21:04:05 <Jebdm> the assembler also converts the string "3.0" to a floating point representation
21:04:13 <Jebdm> say that's gonna be 10010100101010
21:04:18 <Gracenotes> I haven't dealt with concurrent stuff in a year, maybe.
21:04:22 <copumpkin> anyway
21:04:25 <Jebdm> you could read that same thing as an int, and i think it will
21:04:29 <copumpkin> the real assemblies I know of
21:04:32 <Jebdm> but obviously it'll be a different int
21:04:34 <copumpkin> are typed in the sense I gave earlier
21:04:38 <cjs> Gracenotes: No, that you *have* to take care of. But I'm talking what dupChan does: multiple readers each of which gets its own copy of the data stream.
21:04:57 <Gracenotes> when I did, it was with Java, and to be fair java.util.concurrent is a very nice library
21:05:32 <Gracenotes> ..non-STM though it maybe. It does heavily utilize CAS, closely related to STM.
21:05:50 * Gracenotes is familiar with Haskell's stuff, having used it, but not intimately familiar
21:06:09 <Jebdm> to be useful it's going to be "typed" in some way, in that you have to say "i'm going to interpret this bit of memory in a particular way"
21:06:21 <copumpkin> yes, and that's exactly what haskell does :P
21:06:21 <Gracenotes> for Java I read through the sources and fully understood them. Haven't touched Haskell's Control.Concurrency sources too extensively
21:06:28 <copumpkin> and it actively prevents you from mixing interpretations
21:06:34 <copumpkin> without explicit conversions
21:06:53 <Jebdm> but typing where you attach the type to the actual memory is like saying that a chair is *essentially different* from a table
21:07:01 <copumpkin> some exceptions include the fact that many floating point archs allow you to treat single precision as double precision and vice versa
21:07:04 <cjs> The Chan source code is worth reading. And it's quite short.
21:07:04 <copumpkin> because their registers overlap
21:07:11 <Jebdm> but it's not, it's also a collection of atoms/quarks/whatever
21:07:14 <copumpkin> and x86 has overlapping int registers
21:08:09 <copumpkin> Jebdm: you mean keep the types around in memory next to the object?
21:08:14 <Jebdm> Haskell attaches the type to the *value*, not the *function*
21:08:22 <Jebdm> no
21:08:37 <Jebdm> loadi $t1, 5
21:08:42 <Jebdm> loadi $t2, 10
21:08:51 <Jebdm> add $t3, $t1, $t2
21:09:25 <Jebdm> the notion of type isn't attached to the registers
21:09:41 <Jebdm> it exists in the translation from the strings "5" and "10" by the assembler into their int representation
21:09:44 <copumpkin> in this abstract machine you've defined for the sake of argument, sure
21:09:46 <Gracenotes> cjs: sure
21:09:51 <Jebdm> and in that you're using add and not add.f
21:10:31 * copumpkin shrugs
21:10:31 <Jebdm> no, that's the way it actually works
21:10:51 <wli> Jebdm: What arch asm?
21:10:57 <Gracenotes> cjs: I might end up using MVars, though. For locks
21:11:00 <Jebdm> Haskell, when it compiles, switches from attaching the type to the value to the function
21:11:58 <wli> add.f would work on $f0, $f1, etc. no?
21:12:11 <rdeshpande> is real world haskell the defacto haskell book for beginners at the moment?
21:12:30 <copumpkin> rdeshpande: definitely the most popular one right now
21:12:32 <copumpkin> @where lyah
21:12:33 <lambdabot> www.learnyouahaskell.com
21:12:35 <copumpkin> might also help
21:13:33 <Gracenotes> cjs: er... although in this case there is only a consuming thread and a producing thread. So such machinations might be overkill :P
21:13:58 <Gracenotes> who knows, though, I might add more producing threads, I do have *gasp* two CPUs after all
21:14:48 <QtPlaty[HireMe]> Who publishes realworld haskell?
21:14:53 <Gracenotes> o rly
21:14:57 <copumpkin> orly?
21:15:06 <wli> QtPlaty: O'Reilly
21:15:14 <cjs> Gracenotes: Well, my thought on the matter is that it's best to make things safe, even if your particular app doesn't need it....
21:15:56 <Gracenotes> yeah, definitely. I should at least start with a ring buffer with a global lock :)
21:16:01 <scutigera> Last generator in do {...} must be an expression
21:16:12 <scutigera>           data = map splitter datalines
21:16:12 <scutigera>           putStrLn "Done."
21:16:12 <scutigera>  
21:16:50 <scutigera> data =     line is the offender
21:17:19 <scutigera> doh!   let data = map etc...
21:24:20 <wli> > let cantor = let zip' [] yss = yss ; zip' xs@(_:_) [] = map return xs ; zip' (x:xs) (ys:yss) = (x:ys) : zip' xs yss ; f [] = [] ; f ([]:xss) = f xss ; f ((x:xs):xss) = [x] : zip' xs (f xss) in concat . f in Map.filter (not . null . tail) . Map.fromListWith (++) . take 16384 $ cantor [[(i^4+j^4, [(i, j)]) | j <- [i + 1 ..]] | i <- [1 ..]]
21:24:21 <lambdabot>   fromList [(635318657,[(59,158),(133,134)])]
21:32:54 <wli> > let cantor = let zip' [] yss = yss ; zip' xs@(_:_) [] = map return xs ; zip' (x:xs) (ys:yss) = (x:ys) : zip' xs yss ; f [] = [] ; f ([]:xss) = f xss ; f ((x:xs):xss) = [x] : zip' xs (f xss) in concat . f ; nthRoot n x = last $ takeWhile ((<= x) . (^n)) [1 ..] in Map.filter (not . null . tail) . Map.fromListWith (++) . take 1048576 . cantor . cantor $ [[[(i^5 + j^5 + k^5, [(i, j, k)]) | k <- [j .. ]] | j <- [i ..]] | i <- [1..]]
21:33:09 <lambdabot>   thread killed
21:33:32 <wli> Here I get fromList [(1375298099,[(3,54,62),(24,28,67)]),(1419138368,[(13,51,64),(18,44,66)])]
21:37:06 <QtPlaty[HireMe]> wli: What does that do?
21:37:44 <wli> QtPlaty: It searches for numbers representible as a sum of three fifth powers in more than one way.
21:42:27 <kbateman> Project euler problem?
21:43:55 <wli> kbateman: Nope.
21:48:58 <jmzz> wli: that code is close to incomprehensible
21:49:08 <wli> jmzz: Which code?
21:49:21 <jmzz> jml: the one you entered above
21:51:24 <BlackM> jmzz: Don't be a greedy crocodile; eat the hippo one bite at a time. ;)
21:52:02 <jmzz> i bet i could write it in C and be much much clearer :P
21:58:49 <harovali> hi, I'm trying to do a quick test of Parsec, following http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
21:59:13 <harovali> it seems that ghci or hugs here don't find  Parsec when imported
21:59:47 <harovali> I also tryied with import Text.Parsec , but without much luck
22:00:06 <harovali> what can I do ?
22:00:34 <Jebdm> import Text.ParserCombinators.Parsec
22:00:51 <Jebdm> is the default place for GHC
22:01:24 <QtPlaty[HireMe]>    
22:01:26 <QtPlaty[HireMe]> An
22:01:29 <QtPlaty[HireMe]>      p
22:02:01 <harovali> Jebdm: it still doesn't find the package
22:02:02 <QtPlaty[HireMe]> Sory about that
22:02:28 <hydo> stupid osx libjpeg dumbery... I want to play with vacuum-cairo :(
22:02:43 <sjanssen> harovali: you probably need to install parsec
22:03:02 <sjanssen> harovali: apt-get install libghc6-parsec-dev on Debian-likes
22:03:03 <Jebdm> Maybe you installed a version of GHC that didn't come with Parsec?
22:03:09 <sjanssen> @hackage parsec
22:03:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
22:03:24 <sjanssen> ^^^ source package if you don't have a binary package
22:05:21 <harovali> sjanssen: Jebdm: that did it !   thanks.
22:07:41 <Gracenotes> hm. Haskell IO, hella slower than expected :(
22:07:46 <wli> Well, there is > head . filter (not . null . tail . snd) $ filter (not . null . snd) [(n, let f m = takeWhile ((<= m) . (^7)) in do { i <- f n [1 .. n] ; j <- f (n - i^7) [i .. n] ; k <- f (n - i^7 - j^7) [j .. n] ; guard (i^7 + j^7 + k^7 == n) ; return (i, j, k) }) | n <- [1 .. ]]
22:07:53 <sjanssen> Gracenotes: what sort of trouble are you having?
22:07:56 <wli> Gracenotes: Even bytestring-based IO?
22:08:16 <Gracenotes> I'm trying to use Data.Binary to write 100,000 pairs of Word64s at a time
22:09:02 <Gracenotes> at this rate it'll end up taking 4 hours. But the C++ version takes about 15 minutes. using fwrite and stuff.
22:09:14 <sjanssen> Gracenotes: code please
22:09:20 <Gracenotes> it's possible the algorithm itself is taking a long time...
22:09:53 <bos> Data.Binary isn't good at writing out big collections.
22:10:11 <Gracenotes> I've looked at the source, to see how the putword64 item is implemented
22:10:19 <Gracenotes> apparently, using poking and other low-level stuff
22:10:27 <sjanssen> bos: it isn't?
22:10:39 <bos> sjanssen: it traverses a list twice.
22:10:43 <sjanssen> I don't see a problem as long as you're not using lists
22:10:58 <sjanssen> Gracenotes: are you using lists?
22:11:12 <bos> sjanssen: same problem with other collections
22:11:13 <Gracenotes> well, on the intermediate steps
22:11:42 <bos> it should be writing out chunks of 1024 or some other number of elements at a time.
22:11:48 <bos> so it doesn't retain too much data.
22:11:48 <sjanssen> bos: it's been fixed for a few of the collections
22:11:52 <Gracenotes> I'm using the MD5 function from nano-md5, which returns the results as a String... which I am in turn converting to an [Int] with hex-reading :\
22:12:00 <sjanssen> basically all the other supported types are strict, so it doesn't matter
22:12:28 <Gracenotes> however, it seems that generating the values themselves isn't what's taking all the effort.... hm
22:13:01 <bos> sjanssen: but if you have a 10,000 element map, you get to hold onto a 10,000 element list for the duration of the write :-(
22:13:06 <bos> in addition to the map
22:13:09 <jmzz> cant you use mmap?
22:13:32 <Gracenotes> actually, some of my algorithms aren't so speedy. but I computed a million in a few seconds, at least according to rnf
22:13:35 <sjanssen> bos: no, I think that's changed
22:13:38 <bos> Gracenotes: have you profiled this?
22:13:50 <Gracenotes> I'm setting up profiling at the moment.
22:13:53 <bos> sjanssen: not in the code at http://code.haskell.org/binary
22:14:09 <Gracenotes> I'm pretty sure the actual computations are fast, but the IO is what's slowing it. Hence why I considered using more than one core earlier
22:14:11 <jmzz> even 15 minutes is too long.. you should be able to do it in seconds using a decent approach using mmap
22:14:33 <Gracenotes> a problem might be that I'm using the MD5 function to a string
22:14:41 <Gracenotes> not to a byte array
22:14:54 <Gracenotes> and having to parse the hex :\ but that might not be it. lemme profile...
22:15:31 <sjanssen> bos: look again at the Map instance
22:15:52 <bos> sjanssen: ah, yes.
22:16:16 <bos> sjanssen: pardon me while i hide my face in the corner
22:16:54 <sjanssen> bos: you're right that the list instance is bad
22:17:03 <sjanssen> too late to fix it though
22:17:04 <jmzz> Gracenotes: http://code.haskell.org/~dons/code/bytestring-mmap/
22:17:35 <sjanssen> jmzz: IIRC that's for reading only
22:17:39 <Gracenotes> meh. It says I don't have the profiling libraries for the MD5 library
22:17:48 <Gracenotes> @hackage nano-md5
22:17:48 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nano-md5
22:17:59 <jmzz> sjanssen: oh, how useful :/
22:18:08 <Gracenotes> I'm not surprised. Why would a profiling library be made just for that?
22:18:13 <sjanssen> jmzz: ByteString is read-only, so it's no surprise
22:18:24 <bos> Gracenotes: you need to recompile with profiling
22:18:39 <Gracenotes> doable with cabal?
22:18:40 <jmzz> sjanssen: i see. oh well ;)
22:18:41 <bos> Gracenotes: potentially with -prof -auto-all
22:18:43 <sjanssen> Gracenotes: you have to ask Cabal to build a profiling version, Setup configure --enable-library-profiling
22:19:12 <Gracenotes> uuuugggggghhgghahrhrahwwwh.
22:19:12 <bos> --enable-library-profiling isn't enough if the performance problem is in the library
22:19:30 <bos> it only recompiles with -prof, so you get no cost centres in the code.
22:19:51 <Gracenotes> I won't consider that for now
22:20:07 <Gracenotes> it need be I'll write my own C MD5 implementation and link that
22:20:10 <Gracenotes> *if
22:21:32 <jmzz> Gracenotes: is your code available somewhere?
22:21:44 <Gracenotes> ugh. dons' MD5 library actually manually calls showHex
22:22:04 <Gracenotes> somewhat inefficient to reparse it again :)
22:22:36 <Gracenotes> jmzz: just a sec, pasting in its very development-y orm
22:22:37 <Gracenotes> f
22:22:51 <bos> hi gigamonkey
22:22:56 <gigamonkey> yo
22:23:43 <gigamonkey> Whoops. bos, did you just say hi or was that lingering in my emacs buffer from a long time ago?
22:24:22 <copumpkin> you imagined it!
22:24:59 <hydo> gigamonkey: what do you use for irc in emacs?  I've been using rcirc, but I'm wondering if there isn't anything better...
22:25:07 <gigamonkey> ERC
22:25:24 <Gracenotes> jmzz: here http://codepad.org/cwej1o35
22:25:26 <hydo> thanks!  I'll look at it...
22:26:27 <Gracenotes> so two possible inefficiencies in the algorithm: 1. using the MD5 library 2. reversing the bytestring because unfoldrN populates the bytestring from the left
22:26:44 <Nafai> Dude, all of my fravorite programming book authors hang out in #haskell
22:26:47 <Nafai> :)
22:26:51 <Nafai> favorite, even
22:26:59 <Nafai> <- tired
22:27:02 <tsLight> I am having a hard time trying to understand what (flip $ const . (+1)) does. I know the $ is function application so it is (flip(const . (+1))), but I cant understand what const . (+1) does, any help?
22:27:30 <Gracenotes> you're seeing that in a foldl?
22:28:17 <jmzz> Gracenotes: yeah. i'm having trouble reading this though :/ its not you its me, haven't got enough practise reading it
22:28:43 <Gracenotes> yeah, the algorithm is a bit dense
22:29:08 <mmorrow> tsLight: that expression seems odd to me, since
22:29:09 <Gracenotes> check out main at the bottom. the idea is to generate millions of random pairs and put them all in a file
22:29:19 <mmorrow> @type (flip (const . (+1)))
22:29:21 <lambdabot> forall b a. (Num a) => b -> a -> a
22:29:35 <mmorrow> oh, wait
22:29:38 <tsLight> mmorrow, its part of this function that calculates the length of a list: len = foldr (flip $ const . (+1)) 0
22:29:44 <Gracenotes> the pairs come from following a chain of hashes (plaintext -> hash) and reductions (hash -> plaintext)
22:29:50 <Gracenotes> and only recording the start and end values
22:30:04 <Gracenotes> this is what generateRandomPair does
22:30:10 <mmorrow> flip (\x -> const (x+1))
22:30:23 <jmzz> Gracenotes: i'd def try to use mmap for this.. ive worked with large data (10^9) using that approach in common lisp and i can process and write the whole data in seconds
22:30:24 <mmorrow> flip (\x _ -> x + 1)
22:30:30 <mmorrow> (\_ x -> x + 1)
22:30:42 <mmorrow> (\_ x -> x + 1) 200000000000000000000000000  2
22:30:46 <mmorrow> , (\_ x -> x + 1) 200000000000000000000000000  2
22:30:49 <lunabot>  3
22:31:02 <Gracenotes> jmzz: okay. I'll see if cabal can handle it or not
22:31:14 <mmorrow> , foldr (\_ x -> x + 1) 0 [0..9]
22:31:16 <lunabot>  10
22:31:21 <mmorrow> , length [0..9]
22:31:23 <lunabot>  10
22:31:36 <mmorrow> @unpl flip (const . (+1))
22:31:37 <lambdabot> (\ b c -> c + 1)
22:31:38 <Gracenotes> jmzz: so what's the general idea behind mmap-ing?
22:32:37 <jmzz> Gracenotes: pretty simple, you ask the operating system to assign a large file into memory which is exposed to you as an array which you can read/write on, and any modifications you make are persisted in that file
22:33:04 <copumpkin> it's very nice
22:33:15 <copumpkin> but if you're on a 32-bit system, the file can't be too large
22:33:34 <Gracenotes> ah, okay. in this case it only needs to be write only, and although some huge tables may be close to 100 GB, I can do chunks, since only 16 bytes are closely related to each other rally
22:33:34 <mmorrow> Gracenotes: on unix, the rts gets its memory by mmapping /dev/zero
22:33:36 <Gracenotes> *really
22:33:52 <mmorrow> Gracenotes: and the linker mmaps object files
22:34:07 <Gracenotes> so what's the cabal way to compile with profiling support?
22:34:10 <p_l> Gracenotes: Also, mmap gives you more direct interface to memory management, unlike brk/sbrk
22:35:36 <Gracenotes> hehe. love how the only way to use it is with an unsafe function
22:36:11 <Gracenotes> then after I write to the file, I need to sort it, 16-byte chunk by 16-byte chunk
22:36:30 <Gracenotes> maybe some kind of quicksort would work there... I'm going to need some lower-level stuff for you
22:36:38 <Gracenotes> *for sure.
22:36:47 <Gracenotes> what is it with me and typos tonight, huh >_>
22:36:59 <jmzz> Gracenotes: again working with mmap will allow you to do that without creating intermediate objects so you can do it pretty quickly without much gc activity
22:37:58 <Gracenotes> oh, even for sorting?
22:38:03 <jmzz> yeah
22:38:04 <sjanssen> Gracenotes: mmap is probably overkill in your application, look elsewhere for problems first
22:38:21 <quicksilver> win 27
22:38:31 <sjanssen> lose 28
22:39:01 <quicksilver> damn this round to you.
22:39:07 <Gracenotes> sjanssen: well. Speed is the whole point of it -- anything that's a bottleneck must be eliminated so long as it's within the bounds of readable Haskell :)
22:39:14 <cjs> Gracenotes: sounds like you'd be better off using a heapsort, since you can do that in-place.
22:39:30 <quicksilver> I'll get you next time, Miss Pitstop.
22:39:49 <quicksilver> Gracenotes: you are yet to prove that this part *is* the bottleneck :)
22:40:25 <cjs> BTW, note that using mmap instead of brk/sbrk will walk right around your dsize limits, at least in a Linux kernel.
22:40:33 <Gracenotes> okay. just keepin teh perspectives.
22:41:04 <cjs> That was rather annoying with some Ruby programs, where I had to set a vsize limit instead, which got weird when libraries started mmapping large areas of memory that they didn't touch.
22:42:33 <cjs> So I don't necessarily recommend using it for private (unshared) memory backed by swap rather than a file.
22:46:47 <Gracenotes> woot, C library linked successful. *eyes gleam evilly*
22:47:59 <jmzz> anyone interested in Qi?
22:48:52 <sjanssen> Gracenotes: in this code, how much data do you hPut at a time?
22:50:03 <sjanssen> Gracenotes: looks like 16 bytes at a time?  This is bad, you want to write large pieces of data at a time
22:50:20 <Gracenotes> er, only 16 bytes :\ but it should do buffering
22:50:24 <sjanssen> it is also more efficient to encode large pieces with Data.Binary as well
22:50:34 <Gracenotes> or, maybe I should remove buffering entirely and use it like I'd use fwrite
22:50:35 <sjanssen> Data.Binary is probably your bottle neck here
22:50:38 <Gracenotes> ..which may not work
22:51:32 <sjanssen> Gracenotes: an ideal version of this code would be: hPut . runPut $ mapM_ put generateManyWord64s
22:52:19 <Gracenotes> hm. is there a Binary that uses strict bytestrings?
22:52:50 <sjanssen> you don't want strict bytestrings
22:52:58 <Gracenotes> I see.
22:53:57 <sjanssen> Gracenotes: also, generating random numbers is probably pretty slow here too
22:54:25 <Gracenotes> yes. although I have to do it .. five million or so of them
22:54:36 <Gracenotes> the IORef reads/writes must be somewhat slow though
22:54:48 <Gracenotes> of the global generator
22:55:12 <sjanssen> it would be slightly faster to pull one lazy stream of randoms one time, and quite a bit faster to use something other than System.Random
22:55:49 <Gracenotes> hm. Such as... C's rand? >>
22:55:59 <Gracenotes> somewhat flawed though it may be
22:56:14 <quicksilver> don's mersenne random
22:56:20 <quicksilver> is both much faster and more random
22:56:32 <sjanssen> quicksilver: does it support a 'randoms' function?
22:56:57 <quicksilver> I thought it did but I don't know.
22:56:58 <Gracenotes> it seems it does
22:57:10 <Gracenotes> only an IO version, but that's what I need
22:57:59 * quicksilver thinks "hPut . runPut" should be a standard combinator "putPut"
22:58:05 <quicksilver> like an old volkswagen
22:59:06 <sjanssen> so the algorithm becomes: hPut . runPut . mapM_ (put . generateStuffFromRandomNumber) . take N =<< randoms theGenerator
22:59:25 <Gracenotes> @hoogle Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word8 -> Word64
22:59:26 <lambdabot> No results found
22:59:32 <Gracenotes> :P worth a try anyway
23:00:22 <sjanssen> I bet that will be at least twice as fast as what you've got
23:00:38 <Gracenotes> this is for MD5, actually
23:01:26 <sjanssen> Gracenotes: I don't follow
23:01:32 <sjanssen> I mean twice as fast as the Haskell code you pasted
23:02:01 <sjanssen> Gracenotes: other obvious stuff, that foldl should be a foldl'
23:02:04 <jmzz> sjanssen: thats still 8 times slower than his c++
23:02:59 <Gracenotes> well, not my C++, I'm adapting from http://project-rainbowcrack.com/
23:03:22 <Gracenotes> and the paper on rainbow tables that started it
23:03:24 <Gracenotes> with many modifications to the algorithm
23:03:33 <Gracenotes> mostly in the reduction function
23:03:41 <sjanssen> jmzz: there are probably other things to fix as well, I'm just taking the low-hanging fruit
23:03:52 <jmzz> sjanssen: yes understood
23:04:26 <sjanssen> Gracenotes: all of your Arrays should be UArrays
23:04:41 <Gracenotes> sjanssen: as I said, it works :)
23:04:58 <Gracenotes> what I posted is essentially the version right after it started working
23:05:25 <sjanssen> Gracenotes: we don't like to hear the word "slow" around here, so you started it
23:05:30 <Gracenotes> I definitely appreciate all the suggestions though. I just haven't had a chance to consider them myself :)
23:06:26 <sjanssen> Gracenotes: do you actually need Unicode Char, or are you only using bytes?
23:06:40 <sjanssen> replacing them with Word8 wherever possible would certainly help
23:07:28 <sjanssen> and if you can use Word8, use the non-Char8 version of ByteString, which will speed things up a bit
23:07:30 <Gracenotes> Char8 ByteString was largely for convenience debugging, etc. I've eliminated them
23:08:45 <Gracenotes> and also the [Int], will become a Word64, since I only need the first 8 positions
23:08:52 <Gracenotes> doing atm
23:09:22 <sjanssen> assuming you're building with -O2 -funbox-strict-fields, I can make no other suggestions without taking the time to understand the code :)
23:09:58 <Gracenotes> O2? Not extreme enough, man!
23:10:10 * quicksilver turns it up to O11
23:10:14 <sjanssen> -O2 is the highest
23:10:26 <hydo> If I have an array of strings and I want to check if they are keys in a Map and if so get the values, is it bad practice or perhaps faster to just lookup () and test for nothing?  My programmer-sense says do the legwork and check for the keys and then if it exists, get the value.
23:10:37 <sjanssen> -O3 is a red herring
23:10:42 <sjanssen> -O11 is a tired joke :)
23:10:57 * wli hrms.
23:10:59 * quicksilver is a tired hacker, so that's the best sort for him.
23:11:05 <profmakx> and -O42 is the answer!
23:11:17 <quicksilver> hydo: just lookup.
23:11:37 <wli> CPO-STV web app?
23:11:58 <sjanssen> hydo: the beauty of the 'Maybe' return type is that lookup is doing exactly that for you, returning Just thevalue if there and Nothing if not
23:12:02 <hydo> quicksilver: the general populace won't make the wrinkled-nose i-smell-shit face when they see me do this in my code?
23:12:20 <hydo> well... who cares if they do.
23:12:50 <xrfang> memoized_fib :: Int -> Integer
23:12:51 <xrfang> memoized_fib =
23:12:53 <xrfang>    let fib 0 = 0
23:12:54 <xrfang>        fib 1 = 1
23:12:56 <xrfang>        fib n = memoized_fib (n-2) + memoized_fib (n-1)
23:12:57 <xrfang>    in  (map fib [0 ..] !!)
23:12:59 <xrfang> here, how to explain the last expression
23:13:02 <xrfang> especially !!
23:13:27 <sjanssen> that won't necessarily be memoized according to Haskell '98
23:13:35 <sjanssen> xrfang: !! is list index
23:13:47 <sjanssen> > [0, 3, 2] !! 1
23:13:49 <lambdabot>   3
23:14:31 <xrfang> sjanssen: yes I know that
23:14:42 <xrfang> but I don't know what does that mean : map fib [0..] !!
23:14:55 <sjanssen> xrfang: so "map fib [0 ..]" creates the list of all Fibonacci numbers in order
23:15:03 <Zao> @src map
23:15:04 <lambdabot> map _ []     = []
23:15:04 <lambdabot> map f (x:xs) = f x : map f xs
23:15:05 <quicksilver> xrfang: do you know what (2*) means?
23:15:10 <quicksilver> xrfang: it's a section.
23:15:18 <xrfang> I hope (2*) is a function
23:15:20 <sjanssen> and (map fib [0 ..] !!) is the index operator applied to that in a section
23:15:22 <xrfang> which times the parameter by 2
23:15:26 <quicksilver> xrfang: yes.
23:15:31 <xrfang> but !! ...
23:15:34 <quicksilver> (map fib [0..] !!) is a function
23:15:34 <sjanssen> > ([0, 3, 2] !!) 1 -- just a different way of writing this
23:15:36 <lambdabot>   3
23:15:38 <xrfang> say we use [1,2,3] !! 1 = 2
23:15:42 <quicksilver> which indexes the parameter into the list
23:15:45 <quicksilver> (map fib [0..])
23:15:47 <xrfang> but what if the 1 after !! does not exist?
23:15:58 <quicksilver> just like (2*) is  a function
23:16:07 <quicksilver> ([1,2,3]!!) is a function
23:16:09 <quicksilver> same thing.
23:16:10 <Zao> xrfang: When in doubt about a function, look it up on Hoogle.
23:16:18 <Zao> Or ask lambdabot.
23:16:23 <Zao> (she accepts PMs)
23:16:38 <xrfang> in the above example, map f [], while f is fib, []  is [0..]
23:16:52 <wli> This is too painfully slow to live: > let nthRoot n x = let f (a, b) = if a + 1 >= b then (a, b) else let c = (a + b) `div` 2 in case (c^n) `compare` x of { LT -> f (c, b) ; GT -> f (a, c) ; EQ -> (c, c) } in fst $ f (0, x) in head . filter (not . null . tail . snd) $ filter (not . null . snd) [(n, do { i <- [1 .. nthRoot 5 (n `div` 3)] ; j <- [i .. nthRoot 5 ((n - i^5) `div` 2)] ; let k = nthRoot 5 (n - i^5 - j^5) in guard (k >= j) >> guard (i^5 + j^5 + k
23:16:52 <xrfang> this create a list, ok, then the list is appended a !!
23:17:20 <wli> | n <- [1..]] that is
23:17:24 <quicksilver> xrfang: do you follow that, just as (2*) is a functon, ([1,2,3]!!) is a function?
23:17:31 <quicksilver> xrfang: you can section any operator.
23:17:54 <xrfang> quicksilver, yes I understand this
23:18:28 <xrfang> but I don't understand why there is no index number after !!, according to what you said just now, it is sort of partially applied function
23:18:35 <xrfang> i.e. it returns a function?
23:18:37 <xrfang> oh
23:18:39 <xrfang> yes
23:18:47 <xrfang> it should, shouldn't it :p
23:18:52 <quicksilver> yes
23:19:02 <quicksilver> that's why I've been drawing the comparison to (2*) ;)
23:19:06 <dobblego> it's called "partial application" :)
23:19:07 <Zao> @type ([1,2,3]!!)
23:19:09 <lambdabot> forall t. (Num t) => Int -> t
23:19:18 <quicksilver> (2*) is a partially applied function - ([1,2,3]!!) is a partially applied function.
23:19:37 <Zao> @type (!!) [1,2,3]
23:19:39 <lambdabot> forall t. (Num t) => Int -> t
23:19:48 <Zao> Compare to f x   for f :: a -> a -> a
23:20:01 <xrfang> I understand now, just over looked, that the function definition does not contain a "x" in it. so it returns a function not a value
23:20:12 <xrfang> now a further question about why this is "memorized"...
23:20:29 <xrfang> yesterday ski explained what is "thunk" to me, looks like this example
23:20:47 <xrfang> but how about this: fin n = fib (n - 1) + fib (n - 2)?
23:20:57 <xrfang> why in this version the result is not "memorized"?
23:21:29 <Zao> "memoized"
23:21:45 <xrfang> in the memorized version, the use of let, seems to me that it is creating a "local variable" fib... how this *local* variable is used while the function recursively call itself...
23:22:01 <quicksilver> the key part is no the local function fib.
23:22:03 <cjs> Oh, I need to use unsafeInterleaveIO!
23:22:06 <quicksilver> the key part is the list (which has no name)
23:22:14 <xrfang> I think it is a paradigm shift for me... is there a notion of "local" or "global" heap in haskell?
23:22:14 <quicksilver> the list produced by map fib [0..]
23:22:40 <Zao> Haskell has variables? Last I used them they were rather immutable :P
23:22:51 <cjs> But they can still represent different values.
23:23:00 <quicksilver> of course it has variables.
23:23:00 <Zao> xrfang: It's garbage collected, so things are reaped when their time has come.
23:23:05 <quicksilver> (\x -> x*2)
23:23:12 <quicksilver> x is a variable. Its value varies from call to call.
23:23:26 <xrfang> quicksilver, to create this list, the function has to call itself recursively, while it re-enters the function, where does it find out the last time's result
23:23:37 <Zao> I assume xrfang refers to variable in the   { int x = 42; x++; } // C sense
23:23:42 <xrfang> e.g. we are calculating fib 10, it comes back to calc fib 8...
23:23:58 <quicksilver> xrfang: or, if you like, it creates a list which has elements which refer to each other.
23:24:15 <quicksilver> xrfang: so the fourth element of the list is calculated from the third and the second.
23:24:46 <quicksilver> Zao: Both senses are a mathematical "variable". The C one is mutable, the haskell one is not. They're both variables since they both vary.
23:25:00 <wli> > let a = array (0, 20) ((0, 0) : (1, 1) : [ (i, case i `divMod` 2 of { (q, 0) -> let s = a ! q ; t = a ! (q - 1) in s * (2 * t + s) ; (q, 1) -> let s = a ! q ; t = a ! (q + 1) in s * s + t * t }) | i <- [2..20]]) in a
23:25:02 <lambdabot>   array (0,20) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5),(6,8),(7,13),(8,21),(9,34...
23:25:09 <Gracenotes> argh... foiled again by the relative infixities of infix `functions` and + >:[
23:25:21 <xrfang> ok, this is not clear to me, I found some very intersting thing, which even confused me of where haskell store its result
23:25:28 <xrfang> say I do memorized_fib 10000
23:25:34 <Zao> Parens are your friend, Gracenotes?
23:25:40 <Gracenotes> + having 6, mod having 7
23:25:40 <xrfang> it takes about 2 seconds on my T2130 cpu
23:25:42 <xrfang> but
23:25:44 <Gracenotes> Zao: well, they are *now*
23:25:51 <xrfang> if I calculate it the second time, it returns instantly
23:26:03 <Gracenotes> before the left me in the cold... alll by maahseeeeeelfff
23:26:06 <quicksilver> xrfang: I don't think it's a very good example. It's quite subtle why or whether that one gets memoized.
23:26:17 <Gracenotes> y
23:26:26 <wli> I think I got stuck at Warren's method and/or Meek's method the last dozen or so times I tried to get CPO-STV going.
23:26:35 <quicksilver> Gracenotes: you can change the fixities of `functions`
23:26:51 <xrfang> ok, quicksilver, can I say that the "main loop" of that function above is the map operation
23:26:52 <quicksilver> Gracenotes: and the precedences which is probably what you meant :)
23:27:10 <xrfang> while it maps it recursively call itself while everytime it is filling the *same* list
23:27:14 <Gracenotes> yeah, an infixl 7 or something
23:27:21 <xrfang> hence it can lookback to get the previous value?
23:27:30 <quicksilver> xrfang: yes.
23:27:40 <Gracenotes> quicksilver: probably. infixity is left/right usually, but just because I'm too tired to use language correctly doesn't mean I'm too tired to code
23:27:41 <quicksilver> it's not that it "can"
23:27:43 <xrfang> ok, thanks
23:27:48 <quicksilver> it's that, that's what the code says to do :)
23:34:49 <hydo> I haven't seen this anywhere so far so I'm assuming you can't but: Can you give a function defined in a do / where block a type definition?
23:35:36 <mauke> sure
23:35:57 <hydo> hrm... I think I'm going about it wrong.  If the inferred type is off, then it's 99% certain that it's my code at fault.
23:37:51 <Jebdm> ,let x = f where {f a = (a + 4); f:: Int->Int} in (x 5)
23:37:53 <lunabot>  9
23:38:30 <cjs> Hm. I'm trying to write something that works like "tail -f", it it's starting to look to me as if things such as hGetNonBlocking will never return input again once they've hit EOF, even if the file is later extended. Is that the case?
23:38:48 <cjs> (GHC 6.10.2, BTW.)
23:38:51 <mauke> probably
23:39:15 <cjs> Oof. What makes you think that?
23:39:40 <mauke> you
23:39:52 <cjs> Yeah, well, maybe I'm just a bad programmer. :-)
23:40:23 <mauke> why are you trying to reinvent tail -f? :-)
23:40:41 <cjs> Because I need to read a custom format.
23:40:57 <cjs> I suppose I could just say, "you must use tail -f and pass this program the data on stdin," but it seems like a bit of a hack.
23:41:18 <mauke> you could just spawn tail -f and read from it
23:41:20 <cjs> Especially given that I might, say, need to rewind a bit and then read forward again, which would be difficult.
23:41:26 <mauke> http://perldoc.perl.org/perlfaq5.html#How-do-I-do-a-%27tail--f%27-in-perl%3f
23:42:03 <cjs> Ah, so it could be stdio!
23:42:25 <SubStack> perl does magic things to stdin and stdout that let you seek them too
23:42:52 <mauke> SubStack: what?
23:42:53 <cjs> Yeah, but I'm not sure I want that kind of magic when I'm processing multi-gigabyte files. :-)
23:43:17 <cjs> http://markmail.org/message/7pugbbqc6d2ohjm2
23:43:58 <mauke> hrm
23:44:29 <cjs> Not entirely the newest message, however, and also using hGetChar....
23:45:18 <wli> SubStack: Buffering?
23:45:20 <SubStack> mauke: seek STDOUT, 0, 5 works in perl whereas hSeek stdout 0 5 does not
23:45:31 <mauke> SubStack: you are confused
23:45:33 <SubStack> even with $|++
23:45:42 <mauke> also, STOP USING $|++ (grr)
23:46:32 <mauke> seek STDOUT, 0, 5 fails with EINVAL
23:46:40 <SubStack> o_O
23:46:43 <Gracenotes> what the... "(.text+0x3e9e): undefined reference to `bytestringzm0zi9zi0zi1_DataziByteStringziUnsafe_unsafeUseAsCStringLen_closure'"
23:46:52 <Gracenotes> IT MAK NO SAN
23:46:53 <Gracenotes> SE
23:46:56 <mauke> Gracenotes: did you use --make?
23:47:16 <Gracenotes> un momento
23:47:50 <SubStack> mauke: indeed I am confused
23:47:51 <cjs> Well, if anybody wants to play: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4392#a4392
23:47:57 <Gracenotes> not to mention -lssl
23:48:05 <Gracenotes> okay, now it's all happy :D
23:48:13 <Gracenotes> thanks
23:48:30 <Gracenotes> what about --make makes this sort of the stuff illegal?
23:49:47 <Gracenotes> oh, nice, don's mersenne makes Word64 an MTRandom :) no converting back and forth to Integers
23:50:44 <Gracenotes> hm, looks like I'll have to use mod-ing for ranges
23:52:15 <Gracenotes> lol. http://haskell.org/ghc/docs/latest/html/libraries/random/src/System-Random.html#line-299
23:55:02 <xrfang> what does this mean: parse error (possibly incorrect indentation)
23:55:11 <xrfang> I try to: geti = [0..] !!
23:55:20 <xrfang> if I do: geti = ([0..] !!)
23:55:22 <xrfang> then it is ok
23:55:24 <Cale> right
23:55:26 <SubStack> yep
23:55:33 <xrfang> why we need () here
23:55:36 <Cale> Operator sections must be enclosed in parens.
23:55:40 <Cale> It's just part of the syntax.
23:55:52 <Jebdm> you could also do geti = (!!) [0..]
23:56:05 <xrfang> what is called "operator sections"? is it same as "function application"?
23:56:14 <Jebdm> because enclosing an operator in parenthesis makes it a normal function
23:56:24 <Cale> It's syntax sugar for function application or a lambda, depending on which side
23:56:36 <SubStack> or just geti = id for that particular instance
23:56:41 <Cale> (x *) is the same as (*) x
23:56:51 <Cale> (* x) is the same as (\y -> y * x)
23:57:06 <xrfang> ok, Cale, thanks for the explanation
23:57:14 <haskellnoob> What would be a good list of rules for indenting haskell code? Is such a list available somewhere online?
23:57:18 * SubStack wishes there were some examples of Physics.ODE someplace
23:57:45 <SubStack> perhaps I shall write some when I have some time...
23:57:49 <cjs> mauke: The seek doesn't help; even seeking absolute to a point just before where it used to end still only gives me back what used to be there, and nothing after. Setting buffering to NoBuffering didn't help either. This may require some digging into the source code.....
23:58:02 <SubStack> those bindings could use some love too
