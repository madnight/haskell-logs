00:05:10 <ManateeLazyCat> FunctorSalad: Thanks.
00:05:23 <ManateeLazyCat> brb
00:19:21 <Thomas2> ah, seediest idea in the world
00:19:58 <Thomas2> instead of using an unboxed array of bools to do my check
00:20:06 <Thomas2> i can keep it all in a single word
00:20:18 <Cale> Thomas2: hm?
00:20:22 <Thomas2> that way I can effectively convince haskell not to do a conditional check
00:20:43 <Cale> Keep what in a single word?
00:20:45 <Thomas2> it all boils down to me knowing that m ! (x `mod` n) will always be safe in the core of a tight loop
00:21:20 <Cale> Are you still talking about the same program?
00:21:38 <Thomas2> well, most of my checks are mod-m checks where n is less than 32
00:22:10 <Cale> oh, you only need to know if the number is square mod 32?
00:22:17 <Thomas2> no, I need to know if it's a square
00:22:27 <Thomas2> the way to speed it up is to check if it can be a square mod some prime
00:22:32 <Thomas2> that throws out half of them
00:22:45 <Cale> ah, yeah, that seems like a good way to speed it up
00:22:53 <Gracenotes> @hoogle unsafeIndex
00:22:53 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
00:23:38 <Thomas2> ooh aah
00:23:45 <Gracenotes> unsafeAt. Except it's hidden from you :x
00:23:47 <Thomas2> is there an unsafe index for arrays?
00:24:17 <Gracenotes> here we go. http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#v%3AunsafeIndex
00:24:32 <Gracenotes> from the cut-throat depths of GHC's internal libraries
00:24:42 <Gracenotes> oh wait, not quite. :P
00:24:56 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Arr.html#v%3AunsafeAt
00:25:24 <Gracenotes> for the Array type specifically.
00:25:41 <Thomas2> hmm, the boxed one not the unboxed one
00:25:49 <Thomas2> i might go with the specialisation to Word32 anyway
00:25:55 <Thomas2> makes everything less complicated
00:26:36 <Gracenotes> it's pretty nearly unboxed
00:27:12 <Cale> I wonder how effective testing if it's a square modulo a handful of primes is relative to testing just one?
00:28:13 <Cale> Of course, doing so many divisions isn't exactly the cheapest thing either.
00:29:02 <Thomas2> yeah. truth is, I don't really know if the time goes on the divisions or on the indexes
00:29:11 <Thomas2> i suspect the divisions, though.
00:30:00 <Thomas2> erm, braino. i suspect the conditionals in the indexes.
00:31:25 <Gracenotes> hm.. typeclasses might be pretty nice for ray-tracing objects. Being able to detect collisions with any object that implements said function, etc. so long as it's not too slow.
00:31:47 * Gracenotes is trying not to prematurely optimize
00:33:21 <kadaver> how would you do monads n python? class Monad and then subclass that?
00:33:53 <Cale> kadaver: It's hard to do it in a way which is genuinely useful
00:34:13 <Cale> (and yet still convenient)
00:34:43 <Cale> You need bind and return to take the monad class dictionary as a parameter.
00:35:26 <Cale> The funny thing about return in particular is that it's polymorphic in its result type.
00:35:27 <kadaver> yeah i guess it all gets to ugly to be neat
00:35:41 <Cale> :t return 5
00:35:42 <lambdabot> forall t (m :: * -> *). (Monad m, Num t) => m t
00:35:46 <Cale> :t return ()
00:35:47 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
00:35:47 <Gracenotes> Cale: Python does give you >>, right shift :)
00:35:50 <Thomas2> woot, much faster
00:35:56 <Cale> Thomas2: oh?
00:36:04 <kadaver> if someone asks you what a monad is what is the short explanation you give?
00:36:13 <Thomas2> oh, wait, hang on
00:36:33 <Thomas2> no it's not, i'm just testing a smaller sample
00:36:34 <Thomas2> hmm
00:37:31 <Cale> Depends who I'm talking to. If it's a programmer, I would usually say that a monad is a kind of library that supports a particular API which lots of nice polymorphic functions have been written in terms of.
00:37:50 <Berengal> Monads are like cars...
00:38:19 <Cale> (and then after that I would explain how it's a data constructor together with some functions...)
00:39:12 <Cale> The value of recognising that a particular library is a monad is entirely in the ability to use the functions in Control.Monad and other libraries which work for an arbitrary monad though.
00:39:16 <Berengal> Monads are a class of types, all of which has the functions bind and return, which follow certain laws
00:39:30 <Cale> Class of type constructors, really :)
00:39:52 <Berengal> Well, yes...
00:40:28 <Berengal> But the type argument is really irrelevant though
00:40:45 <Berengal> No need to confuse people more than neccessary...
00:41:18 <Cale> I suppose. I think if you really want to understand what the functions bind and return are, you need to know what a type constructor is :)
00:41:50 <Thomas2> hmm, it's the original modulus function on Integers that costs 1/2 to 1/3 of the time used up
00:41:52 <Berengal> I think it would actually be easier to grok functors first
00:42:01 <beelsebob> Berengal: I think there are simpler ways of explaining it even than that
00:42:11 <beelsebob> you don't need to tell them the laws
00:42:13 <beelsebob> as much as the types
00:42:21 <beelsebob> join's type is very easy to understand
00:42:21 <Cale> Thomas2: I only found that it slowed things down a lot.
00:42:33 <Cale> Thomas2: yeah, maybe around 50% slower
00:42:44 <Cale> Berengal: yes
00:42:47 <Berengal> I actually found join harder to understand than bind...
00:42:59 <Cale> It depends which monad you're looking at.
00:43:08 <beelsebob> Berengal: and yes, grocking functors, then applicatives, then monadsis way easier
00:43:16 <beelsebob> I'm certain of that
00:43:17 <Cale> The list monad is a good one to start with.
00:43:18 <Thomas2> humm, a lot of the time is inexplicably going into the toplevel function
00:43:24 <Thomas2> i need to think this through more
00:43:26 <beelsebob> I think it's also massively healthy for the haskell community
00:43:34 <beelsebob> to point out that monad isn't the only abstraction people should be thinking about
00:43:55 <beelsebob> Cale: actually, I found that one one of the harder ones to grock
00:44:05 <kadaver> eh all libs are  monads? that snot what you meant is it
00:44:06 <beelsebob> because there's somehow multiple values apparently flowing down a =<<
00:44:20 <beelsebob> kadaver: all libs?
00:44:21 <Berengal> The list monad is funky with it's nondeterministic semantics...
00:45:08 <Berengal> (>>=) is nice if you think of it as a box with a value applying the value in the box to a function yielding a new box with a new value, then discarding the now-empty old box
00:45:10 <beelsebob> kadaver: 1) not all types are monads – take a look at zip lists for example, 2) just having a monad doesn't automatically make functor/applicative useless
00:45:13 <Berengal> for lists, that becomes... complicated
00:45:21 <Berengal> The function can be applied zero or more times...
00:45:27 <beelsebob> kadaver: parser combinators and errors are massively more useful as applicativs than as monads
00:45:46 <beelsebob> Berengal: yeh
00:45:56 <Cale> beelsebob: Of course, that's one of the reasons that I like it. It's very simple and yet not so simple as to be completely trivial.
00:46:00 <beelsebob> Berengal: I only got the list monad when I "god" join
00:46:02 <beelsebob> got*
00:46:14 <Cale> and it's actually useful on an everyday basis :)
00:46:19 <Berengal> Heh... I actually got the list monad when I learned prolog :)
00:46:24 <beelsebob> hehe
00:46:25 <Thomas2> hmmm, gtg. annoying that this continues to defy me
00:46:41 <Gracenotes> 'join' seems like it would come from the natural name for concatenation. but no, quite category theoretical
00:46:48 <Gracenotes> at least, to someone coming from other pls
00:46:55 <kadaver> beelsebob: why? sho i shouldnt use >> in Parsec but al that funny (***) (&&&) ? what is the difference for me as a user?
00:47:08 <Berengal> kadaver: That's arrows, not applicative
00:47:09 <beelsebob> kadaver: those are from Arrow, which is even more powerful than Monad
00:47:12 <beelsebob> not from Applicative
00:47:31 <beelsebob> kadaver: have a read of this... http://noordering.wordpress.com/2009/03/31/how-you-shouldnt-use-monad/
00:47:59 <Gracenotes> also, here's a nice post about using Parsec in an Applicative style: http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
00:48:06 <Gracenotes> the resulting code is quite readable, and elegant
00:48:14 <Berengal> RWH also has a nice section about applicative parsec...
00:48:55 <Berengal> Anyway, if you really want to understand the CT classes in haskell, typeclassopedia has a nice progression I felt
00:49:49 <kadaver> > fmap (\(a,b) -> (a+1, b+1) ) (1,2)
00:49:50 <lambdabot>       No instance for (Num (t, t1))
00:49:50 <lambdabot>        arising from the literal `2' at <i...
00:49:54 <kadaver> why not?
00:50:01 <kadaver> > fmap (+1) (1,2)
00:50:02 <lambdabot>   (1,3)
00:50:17 <Gracenotes> > ($) (\(a,b) -> (a+1, b+1) ) (1,2)
00:50:19 <lambdabot>   (2,3)
00:50:27 <Gracenotes> @type fmap
00:50:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:50:37 <Gracenotes> @type ($)
00:50:38 <lambdabot> forall a b. (a -> b) -> a -> b
00:50:43 <beelsebob> kadaver: look at the kind of Functor
00:50:53 <beelsebob> or the kind required rather
00:51:57 <kadaver> monads are like associativity and the like? just some operatoras that obey some laws?
00:52:08 <beelsebob> yep
00:52:19 <beelsebob> same for functor and applicative
00:52:27 <beelsebob> I need to follow up that post with exactly what laws are needed for each
00:53:42 <Berengal> The trouble with monads is that "monad" in itself is a pretty useless and empty term.
00:53:51 <Berengal> Their usefulness comes from all the instances
00:54:01 <Berengal> And only then does the class make sense
00:54:21 <Berengal> You can't grok monads without groking several of its instances
00:54:44 <kadaver> but Maybe isnt a Moand until I define it as instance of a monad right? i mean if i declare a data Maybe and a Functor instance of it then I dont have a monad eight?
00:54:52 <Berengal> Each one independent, but each one also similar
00:54:59 <Gracenotes> there is only one monad!
00:55:00 <Berengal> kadaver: Not all functors are monads
00:55:15 <Berengal> All monads are applicatives are pointed are functors...
00:55:21 <kadaver> Monad has several instances?
00:55:37 <Berengal> kadaver: It's a class after all
00:55:45 <Berengal> Classes are useless without instances
00:56:00 <Gracenotes> well, there are things that are applicative, pointed, functors, and not monads
00:56:25 <edwardk> Berengal: in hask anyways ;)
00:56:31 <Gracenotes> but not too common :X
00:56:36 <edwardk> (the monads are applicatives bit)
00:57:31 <Berengal> edwardk: I haven't had the time or energy to read up on CT yet
00:57:33 <kadaver> ok yes it ca be implmented for sveral isntances
00:57:49 <kadaver> but those isntances are unlimited no?
00:58:05 <Berengal> Everything I say is only related to haskell, and usually only true if the truth is stretched a bit ;)
00:59:09 <Berengal> (I have a bad habit of stating things that are just true enough that correcting it seems pendantic)
00:59:29 <pumpkin> zomg it's an edwardk
00:59:49 * pumpkin hides
01:00:32 <Berengal> kadaver: Oh, and yes, there's an unlimited amount of monad instances... probably
01:00:45 <erikc> hmm, drinking tea at midnight might have been a bad idea, i sense a coding frenzy coming on
01:00:48 <Berengal> Or maybe it depends on how many tuple types ghc has defined...
01:00:53 <pumpkin> erikc: oh no!
01:00:56 <pumpkin> or should I say, oh yes!
01:01:00 <erikc> haha
01:01:00 <Gracenotes> not sure how many would be useful
01:01:26 <Berengal> Gracenotes: usefulness is overrated
01:02:08 <Berengal> instance Monad (,,,,,,,,,,,,) a b c d e f g h i j k l where ...
01:02:22 <Gracenotes> hm? Not sure if that'd work without undefined-ness
01:02:37 <Gracenotes> comonad, on the other hand...
01:03:07 <Berengal> Well, if (Monoid [a..l]) =>...
01:03:16 <Gracenotes> well yes.
01:03:48 <Gracenotes> now, interestingly the ((->) r) monad allows monad instances for any other function :) I was quite pickled upon discovering this.
01:04:37 <Berengal> What do you mean? That instance Monad ((->) r) was enough?
01:04:54 <Gracenotes> as far as I can tell
01:05:06 <Berengal> That should be obvious enough...
01:05:22 <Gracenotes> same for.. instance Num b => Num (a -> b)
01:05:57 <Gracenotes> obvious once you discover it, yes. 'twas fun determining the behavior.
01:06:16 <pumpkin> not interesting enough for Berengal
01:06:26 <Gracenotes> alas
01:06:45 <Berengal> :/
01:07:35 <Gracenotes> so, from where else would these instances be retrieved
01:07:38 <pumpkin> does anyone know how to pronounce wouter?
01:07:45 <Berengal> Something set me up the bomb
01:07:55 <Gracenotes> what you say??
01:08:08 <Berengal> I got signal
01:08:25 <Berengal> It crashed irc :(
01:08:37 <pumpkin> onoes, somebody set up you the bomb?
01:08:47 <Berengal> what I said!!
01:08:49 <pumpkin> you should've inverted your "me up"
01:08:57 * edwardk challenges pumpkin to a dual.
01:08:58 <pumpkin> tsk tsk
01:09:03 <pumpkin> oh!
01:09:12 <Gracenotes> "what you say!!" sounds like it should be part of a rap song
01:09:13 <pumpkin> depending on the nature of the dual, would probably lose
01:09:22 <pumpkin> in a few things I may colose
01:09:33 <Hunner> http://xkcd.com/286/ of course
01:09:33 <Berengal> colose = win?
01:09:37 <pumpkin> duh
01:09:59 <Gracenotes> > getDual (Dual "lose" `mappend` Dual "you ")
01:10:01 <lambdabot>   "you lose"
01:10:02 <edwardk> pumpkin is a winner in the Life^op =)
01:10:08 <pumpkin> lol
01:10:14 <pumpkin> why thank you
01:10:49 <Hunner> Too bad it's dual instead of duel
01:11:16 <pumpkin> :)
01:11:32 <pumpkin> is GHC's graph rewriting stuff exported or easily pull-outable somehow?
01:12:38 <edwardk> hrmm anyone know a good way to rebalance ternary search trees?
01:14:04 <edwardk> i can hack it and kind of just adapt the stuff from Data.Set or Data.IntMap but its not exact because adding an entry adds a whole bunch of nodes, and i'd rather rebalance by mass than leaf count.
01:14:44 <edwardk> since that would optimize for search time assuming a random distribution of searches across the words in the trie
01:16:04 <edwardk> Since my trie depth is constant for the usecase I have in mind they are equivalent to me at the moment
01:17:47 <pumpkin> edwardk: you done any work with graphical models? :P
01:18:14 <edwardk> what i have right now is data Tern k v = Tern {-# UNPACK #-} !Int !Int !k !(Maybe v) !(Tern k v) !(Tern k v) !(Tern k v) | Tip; data Trie k v = Maybe v :> !(Tern k v) -- with size (number of leaves), mass (number of nodes) key, value, left, center and right
01:18:25 <pumpkin> ack
01:19:17 <Berengal> @users
01:19:17 <lambdabot> Maximum users seen in #haskell: 658, currently: 579 (88.0%), active: 14 (2.4%)
01:19:32 <edwardk> basically i want to benchmark this version, then unbox it
01:19:40 <edwardk> but i need a good balancing strategy
01:21:26 <edwardk> if i ignore the 'third' leg and optimize the binary trees independently i get something tolerable, if i tried to optimize perfectly for the third leg 'mass' then i can spend all my time in rotations, etc.
01:21:45 <kadaver> couldnt nameclashes be resolved somehow? if the function using sum has a type annotated then it is clear wich one is meant right?
01:22:22 <edwardk> i may cheat and just pretend mass is size and use normal binary tree rotations, and get it to basically do the balanced binary tree stuff with a little bit of bias towards the mass of the third leg.
01:23:01 <pumpkin> kadaver: what context?
01:23:22 <pumpkin> oh, you mean overloading based on your context?
01:25:04 <edwardk> http://portal.acm.org/citation.cfm?id=1167389 seems to describe a nice approach, but its not applicable in a functional setting =(
01:25:36 <edwardk> actually most of their nice approaches have that problem
01:25:42 <SubStack> is there a straightforward way of decomposing a string into its binary bits as a [Bool]?
01:25:54 * SubStack has found plenty of not-so-nice ways to do this
01:26:18 <pumpkin> binary bits in what representation?
01:26:20 <Zao> SubStack: Have a 2^21 lookup table of [Bool]? :)
01:26:44 <SubStack> pumpkin: that part doesn't matter so much
01:31:15 <Gracenotes> > take 8 $ unfoldr (\n -> Just (testBit n 0, n `shiftR` 1)) (ord '?')
01:31:16 <lambdabot>   [True,True,True,True,True,True,False,False]
01:32:13 <Gracenotes> > map (testBit (ord '?')) [0..7]
01:32:14 <lambdabot>   [True,True,True,True,True,True,False,False]
01:32:47 <pumpkin> > unfoldr (\n -> guard (n /= 0) >> Just (testBit n 0, n `shiftR` 1)) (ord '?')
01:32:48 <lambdabot>   [True,True,True,True,True,True]
01:32:52 <pumpkin> lol
01:32:57 <SubStack> and the other way too
01:33:28 <pumpkin> > unfoldr (\n -> guard (n /= 0) >> Just (testBit n 0, n `shiftR` 1)) (ord ' ')
01:33:29 <lambdabot>   [False,False,False,False,False,True]
01:33:39 <Gracenotes> pumpkin: quite. shouldn't be a huge problem for chars, though
01:33:54 <pumpkin> ?
01:34:09 <Gracenotes> not having a termination condition
01:34:21 <pumpkin> it would be if you wanted to concatMap a bunch of them together
01:34:28 <pumpkin> but you'd probably want a fixed number of bits in that case
01:34:31 <Gracenotes> right
01:34:32 <pumpkin> or a coding/delimiter
01:35:18 <Gracenotes> block codes are trivially decodable
01:36:15 <pumpkin> yup :P
01:38:21 <Gracenotes> > chr $ foldr (\x acc -> fromEnum x + acc*2) 0 [True,True,True,True,True,True,False,False]
01:38:23 <lambdabot>   '?'
01:38:29 <SubStack> [Bool] -> String is the harder one
01:38:33 <pumpkin> lol
01:39:49 <Gracenotes> then there are ByteStrings :)
01:40:06 <Berengal> assuming each char is 21 bools: map (chr.gracenoteFunc.take 21) $ iterate (drop 21)
01:40:48 <SubStack> :i gracenoteFunc
01:41:19 <SubStack> @hoogle gracenoteFunc
01:41:19 <lambdabot> No results found
01:41:23 <SubStack> -_-
01:41:24 <Berengal> lol
01:43:38 <pumpkin> holy crap, whoda thunk that factor graphs could be so cool! http://www.robots.ox.ac.uk/~parg/mlrg/papers/factorgraphs.pdf
01:44:17 <Gracenotes> *scrolls down to see pretty graphs*
01:44:26 <Berengal> Wow, they've even got coloured fonts!
01:45:46 <erikc> pretty typesetting is so pretty
01:45:58 <Gracenotes> wow, this guy likes mutability: http://wiioperasdk.com/raytrace/raytrace/sphere.js
01:46:16 <Gracenotes> 6 assignments.. in the condition part of the if statement alone
01:46:47 <SubStack> just be glad they're not reassignments
01:48:30 <erikc> visual studio 2010 with f# cant come soon enough for me
01:48:35 <pumpkin> :o
01:48:41 <pumpkin> you betraying haskell!?!?!!?
01:49:19 <erikc> nah, but im stuck on .net for a while for work
01:49:36 <erikc> f# has made a a lot of ... concessions ... to work with the rest of the .net world
01:49:47 <erikc> things dont quite compose right
01:50:02 <erikc> but its better than the alternatives, and the IDE environment is surprisingly great
01:50:25 <pumpkin> have you seen all the hs-dotnet stuff?
01:50:38 <erikc> was looking at it a bit today
01:50:38 <pumpkin> I don't do windows but it looks pretty extensive
01:51:18 <Gracenotes> I'm certain that's what she said.
01:51:36 <pumpkin> heteronormative :(
01:51:45 <Gracenotes> statistically speaking
01:52:24 <pumpkin> really?
01:52:36 <pumpkin> is this a good sample?
01:53:47 <Gracenotes> anecdotally speaking, with thousands of imagined test subjects
01:54:00 <pumpkin> aha
01:54:45 <Gracenotes> thousands!
01:54:53 <pumpkin> zomg
01:59:17 <Zao> pumpkin: I tried hs-dotnet 0.4 today, still blows up good on SlimDX.
01:59:33 <Zao> I suppose it's a kind of a hell test though, as it's C++/CLI heavy with lots of snazzy techniques.
02:01:54 <hotaru2k3> does hs-dotnet work on mono?
02:02:17 <erikc> i spent last week doing c++/cli stuff, what a crazy language
02:03:16 <pumpkin> http://blog.lab49.com/archives/3011 is a pretty awesome post
02:03:51 <solidsnack> Were I to treat files as functors and define a foldable instance for them, I would definitely want a left fold, right?
02:03:59 <solidsnack> Right fold would be asking for trouble
02:04:01 <solidsnack> ?
02:04:55 <Gracenotes> OpenGL has some freaky behind-the-scenes stuff going on. Not your vanilla FFI interface...
02:08:15 <solidsnack> pumpkin: Man, there are so many ways to approach mutation/statefulness
02:09:07 <Zao> Does there exist any functions to convert from String to UTF-16?
02:09:24 <thoughtpolice> maybe you want the text package?
02:09:26 <Zao> It's fairly straightforward to implement I suppose, but some standard ones would be handy.
02:10:11 <pumpkin> Zao: not built in, but the new Data.Text stuff should have it
02:10:21 <pumpkin> and there are loads of other text encoding offerings on hackage
02:10:24 <pumpkin> well, at least two
02:10:38 <pumpkin> Data.Text uses UTF-16 internally I believe
02:11:03 <erikc> what is Char, UCS-16?
02:11:10 <pumpkin> -32
02:11:11 <Zao> UTF-32
02:11:16 <pumpkin> UCS-4 rather
02:11:27 <pumpkin> or yeah, UTF-32 :)
02:11:40 <pumpkin> erikc: haskell does things right :P
02:11:46 <erikc> hehe
02:11:48 <pumpkin> at least in theory
02:12:43 <erikc> everyone did character representation right for the most part, its just a question of when they did it right :)
02:13:13 <erikc> right kept changing
02:14:02 <pumpkin> lol
02:14:13 <pumpkin> ruby didn't
02:14:18 <erikc> haha
02:14:50 <pumpkin> (I like ruby, but it's ridiculous that a japanese language designer made a language that didn't support non-ascii chars)
02:14:52 <pumpkin> :P
02:15:08 <erikc> yea
02:15:13 <pumpkin> and java's native UTF-16 rep is ugly
02:15:27 <pumpkin> I don't care if unicode didn't have all the extra planes it doesn ow
02:15:38 <pumpkin> I shouldn't have to care :P
02:16:00 <Zao> pumpkin: He's a Shift-JIS fan, I believe.
02:16:28 <pumpkin> Zao: it still makes the assumption of byte=char
02:16:33 <pumpkin> or did until recently
02:20:51 <thoughtpolice> i believe ruby 1.9 fixes it
02:20:54 <thoughtpolice> but don't quote me on that
02:21:32 <pumpkin> yeah, it does
02:21:54 <pumpkin> I was a total rubyhead until a few months ago :P
02:21:58 <pumpkin> guess what happened
02:22:23 <smtms> pumpkin, you switched to Python? :-)
02:22:40 <pumpkin> YES!
02:22:49 <pumpkin> my main purpose in here is as a troll
02:28:43 <ivanm> @slap pumpkin
02:28:43 <lambdabot> Come on, let's all slap pumpkin
02:29:03 <pumpkin> do sum types correspond to haskell types with multiple data constructors? except they're not types and that's why haskell isn't dependently typed?
02:29:07 <pumpkin> or am I misunderstanding
02:30:34 <kadaver> @slappumpkin
02:30:34 <lambdabot> Unknown command, try @list
02:30:34 <kadaver> @slap pumpkin
02:30:35 * lambdabot jabs pumpkin with a C pointer
02:31:19 <Gracenotes> data Sum = Product1 Term1 Term2 | Product2 Term1 Term2, as far as I understand it
02:31:47 <Gracenotes> (Term1 * Term2) + (Term1 * Term2)
02:32:06 <pumpkin> yeah, that's what I got from it
02:32:32 <Gracenotes> could be implemented in C as a tagged union
02:32:47 <Gracenotes> could be implemented in C as a tagged union
02:32:51 <Gracenotes> er, sorry for repeat
02:32:55 <Gracenotes> I mean, struct with a tag and a union
02:33:00 <pumpkin> but the point of the question I guess was to ask if dependent types moved the Sum into the type system too?
02:33:04 <pumpkin> yeah
02:35:44 <Gracenotes> dependent types seem to be on a whole different level. they seem to be a product, with every value the dependent type can have
02:36:16 <pumpkin> well yeah, but it seems like sums already express that
02:36:28 <pumpkin> data Int = 0 | 1 | 2 | 3 | 4 (and negatives)
02:37:08 <pumpkin> if your type system is allowing to check which of your "addends" is being used
02:37:19 <pumpkin> it seems equivalent to talking about what we consider the value of our type
02:37:40 <Gracenotes> so you're saying: Type1 * Int = Type1 * (0 + 1 + 2 + 3 ..) = Type1*0 + Type1*1 + Type1*2 + Type1*3 + ...
02:38:02 <Gracenotes> for a dependent Int.. however notated O_O
02:38:31 <pumpkin> I don't think the dependent bit needs any additional notation does it?
02:38:50 <pumpkin> I dunno, I'm no type theorist :P
02:38:58 <Gracenotes> iirc, I've seen .. (Int a) => Type1 * a
02:39:15 <solidsnack> Dependent types allow conditionals, though.
02:39:28 <pumpkin> how do you mean?
02:39:40 <solidsnack> I mean, the type of numbers less than one.
02:39:48 <solidsnack> The type of even numbers that are primes.
02:39:57 <pumpkin> that's just restricting the sum to subsets of the original domain
02:40:16 <pumpkin> instead of 0 | 1 | 2 | 3 | 4 it could be 2 | 3 | 5 | 7 | 11 ..
02:40:33 <solidsnack> It uses a logical statement.
02:40:37 <pumpkin> thinking of those as "data constructors" of Int
02:41:03 <solidsnack> To express a particular dependent type, how would you do it using that notation?
02:41:08 <pumpkin> well yeah, but that's an implementation detail isn't it?
02:41:19 <pumpkin> I'm just saying that sum types cover all that
02:41:35 <pumpkin> and our main problem is that our type system isn't checking the sum type
02:41:40 <pumpkin> "problem"
02:41:47 <solidsnack> eh
02:43:30 <Gracenotes> :o
02:43:57 <pumpkin> I dunno, I may be misunderstanding completely :P
02:44:21 <solidsnack> I don't see how expressing the constructors of the new type actually expresses the type.
02:44:41 <pumpkin> the constructors are the "sum"
02:44:53 <pumpkin> (I'm talking about that blog post I posted earlier)
02:45:05 <pumpkin> in the sense of sum types and product types
02:45:24 <pumpkin> or I should say, the constructors are the addends
02:46:28 <solidsnack> Okay, so each number is actually its own type?
02:46:51 <solidsnack> Then we sum them to get the numbers greater than four and such?
02:47:17 <pumpkin> well, that's what I'm sort of wondering, the whole sum/product notion seems to fully encode what I understand as dependent types, and the fact that haskell only seems to check products explains (in my mind at least) why haskell isn't dependently typed
02:47:51 <solidsnack> Well, what about the rationals?
02:48:10 <pumpkin> a product of two sum types?
02:48:26 <solidsnack> And a subset of them would be?
02:48:34 <solidsnack> A sum of ... ?
02:49:28 <pumpkin> (1 + 3) * (4 + 3) = (1 * 4) + (1 * 3) + (3 * 4) + (3 * 3)
02:50:40 <solidsnack> Well, what if I don't want (3 * 3) in there?
02:50:56 <solidsnack> I basically have to have a constructor for every rational, every real...
02:51:08 <solidsnack> Somehow I don't think that's the road to dependent types.
02:51:27 <pumpkin> I'm not saying it's how it should be implemented :P
02:52:01 <solidsnack> But if it existed, could it express dependent types?
02:52:20 <pumpkin> I don't see why not
02:52:20 <solidsnack> Well, I guess if a type is a set and we want to know whether elements are in it or not...
02:53:15 <pumpkin> so going back to my original question... :P
02:55:46 <Gracenotes> hm.... 15 minutes of grepping does not yield an example of dependent types
02:55:51 <Gracenotes> sorreh pumpkin
02:55:54 <pumpkin> ?
02:56:03 <Gracenotes> through IRC logs.
02:56:12 <pumpkin> do sum types correspond to haskell types with multiple data constructors? except they're not types and that's why haskell isn't dependently typed?
02:56:16 <pumpkin> was the question
02:56:35 <pumpkin> or more succinctly
02:57:01 <pumpkin> does "type checking" sum types = dependent typing?
02:57:29 <Gracenotes> I'm pretty sure sum types are multiple data constructors
02:57:45 <pumpkin> I am too, now :)
02:59:17 <Gracenotes> this is an epic grep failure
02:59:29 <pumpkin> ?
03:00:08 <solidsnack> I'm going to read this Agda tutorial and see if I can find out. The usual expression of dependent types is "types that depend on values".
03:00:58 <pumpkin> yeah, that's what I've heard so far :)
03:01:06 <pumpkin> but in haskell, so do constructors
03:01:10 <pumpkin> data constructors that is
03:01:30 <pumpkin> you can't tell at compile time whether you'll get the Left or Right of an Either
03:01:35 <Gracenotes> pumpkin: ah, here we are. vector_append :: forall a (m :: Natural) (n :: Natural). Vector a m -> Vector a n -> Vector a (m + n)
03:01:52 <Gracenotes> an example of how such types might look in Haskell
03:01:53 <pumpkin> oh yeah, I've seen lots of stuff like that
03:01:55 <pumpkin> what language is that?
03:01:55 <pumpkin> ah
03:02:03 <pumpkin> the agda one looks quite similar iirc
03:02:07 <pumpkin> just uses single colon
03:02:19 <Gracenotes> not a real language.
03:02:38 <Gracenotes> psuedo-Haskell, if you will?
03:02:54 <pumpkin> so a dependently typed language could reason at compile time about whether you have Left or Right
03:02:54 <thoughtpolice> it's pretty close
03:03:11 <pumpkin> I guess my question is pretty banal :)
03:03:59 <Gracenotes> yes, you should run StrictBanal in the future
03:04:04 <pumpkin> yup
03:04:25 <pumpkin> so I'd guess that implies the answer is "yes"?
03:04:34 <pumpkin> any master type theorists around?
03:05:29 <thoughtpolice> just go use coq :)
03:05:44 <Gracenotes> the power of Coq compels you
03:05:47 <solidsnack> Interactive mode is no longer supported in Agda :(
03:05:51 <pumpkin> I know :(
03:06:01 <pumpkin> but the emacs plugin is supposed to be good
03:06:07 <pumpkin> I've only played with it a little
03:06:10 <Gracenotes> you must be open to Coq
03:06:25 <pumpkin> quit sucking up to coq
03:07:36 <Gracenotes> pumpkin: O_O
03:08:03 <Gracenotes> well, everyone needs time to penetrate the deeper concepts of Coq
03:08:12 <Gracenotes> don't be afraid to experiment.
03:08:56 <pumpkin> :o
03:09:07 <solidsnack> pumpkin: So, your thesis that is that, were Haskell to have true sum types, it could have dependent types?
03:10:03 <pumpkin> well, maybe not "true" sum types, as I think it fits that definition, but if it provided facilities to statically check the elements of a sum type, that would make it dependent
03:10:32 <solidsnack> GADTs are kinda sorta like that.
03:11:00 <solidsnack> Well, hmm, no.
03:11:06 <solidsnack> There's not a direct way to do subsets.
03:11:22 <pumpkin> just something along the lines of
03:11:58 <pumpkin> processRights :: [Either a {Right only kthxbai}] -> a
03:12:23 <pumpkin> or
03:12:40 <thoughtpolice> or you can statically ensure that processRights does not recieve a list of non-Left values
03:12:43 <pumpkin> div :: Int -> Int {no 0 kthx} -> Int
03:13:06 <solidsnack> pumpkin: ?
03:13:08 <thoughtpolice> er, only recieves a list of non-left values
03:13:26 <thoughtpolice> pumpkin: but in general what you're asking for is dependent typing I think, yes.
03:13:51 <solidsnack> {no 0 kthx} is Ints that are not 0, i guess
03:13:57 <pumpkin> yup
03:14:04 <solidsnack> your notation was a little strange at first :)
03:14:07 <pumpkin> at 6 am the lolcat within dominates
03:14:10 <pumpkin> :)
03:14:14 <Gracenotes> not sure if all that can be done in compile-time
03:14:39 <pumpkin> well that's why dependent typechecking isn't guaranteed to terminate, I'd guess
03:14:40 <thoughtpolice> well, you can encode things like that in ATS
03:14:49 <Gracenotes> print . div 10 . read . head =<< getArgs
03:14:53 <pumpkin> really? I thought its dependent types were fake
03:14:57 <thoughtpolice> of course ATS has a different 'approach' to dependent typing from what I can tell
03:15:03 <thoughtpolice> it's mainly based on constraint solving
03:15:03 <Gracenotes> dependent types aren't dynamic-types-with-built-in-checks
03:15:10 <pumpkin> Gracenotes: in that case I think some languages would say "sorry, can't prove it, but if you want I'll compile it anyway"
03:15:24 <Gracenotes> prove it to the language
03:15:27 <Gracenotes> with a crowbar
03:15:34 <pumpkin> pretty much, I think
03:15:35 <solidsnack> or a cast/constructor
03:15:42 <thoughtpolice> and yes, the set of functions int(i) at the type level, which produce types that can only be inhabited by integer 'i'
03:15:47 <thoughtpolice> then again
03:15:59 <thoughtpolice> i don't know what you call 'fake' and 'real' dependent types, so you might have to elaborate a bit on that.
03:16:36 <pumpkin> thoughtpolice: I thought ATS' "dependent typing" was roughly equivalent to our type-level integers, with nicer notation
03:17:13 <dcoutts> igel: ping
03:17:36 <dcoutts> @seen igel
03:17:36 <lambdabot> igel is in #haskell and #gentoo-haskell. I last heard igel speak 8m 2s ago.
03:17:43 <igel> what's up?
03:18:18 <dcoutts> igel: just to let you know, I killed your bash wget loop script on community.haskell.org
03:18:18 <dcoutts> yesterday I mean
03:18:29 <dcoutts> igel: it was making the whole server run really slowly
03:18:43 <pumpkin> :o
03:18:56 <pumpkin> sounds nefarious!
03:19:01 <igel> oops
03:19:02 <igel> sorry
03:19:20 <solidsnack> okay, i am going to have to use this coq thing for awhile, i think
03:19:35 <pumpkin> Gracenotes would be proud
03:19:36 <dcoutts> igel: np, but I'd advise you find a better server next time, the community server is pretty weedy
03:20:02 <igel> ok
03:21:05 <kadaver> im confused. when traversing a binary tree in postorder and preorder, what the hell is that supposed to result in? you cant really get back the xs you put in in fromList xs right?
03:23:46 <thoughtpolice> pumpkin: well what makes ATS dependent types 'fake'? AFAICS, ATS can encode arbitrary properties about program functionality and do proving of it at compile time - that's the point of dependent typing; it's proof-carrying code that's checked. how are ATS dependent types fake? because you have the 'int' sort which you can use to construct singleton types?
03:24:11 <pumpkin> because the values have to be known at compile time
03:24:17 <pumpkin> unless I've misunderstood it
03:24:27 <pumpkin> like "I'm gonna have a vector of 3 elements"
03:24:32 <pumpkin> written in code
03:24:37 <pumpkin> that's good
03:24:52 <pumpkin> and it'll prevent you from adding a vector of 3 to a vector of 4
03:25:37 <mux> "compile time" makes little sense in the context of dependent types though
03:25:45 <solidsnack> pumpkin: That just seems like vanilla/easy stuff. I don't see anything fake there.
03:25:58 <pumpkin> well, just saying that we can do the same in haskell
03:26:01 <mux> the limit between runtime, compile time and type checking is totally blurred with dependent typing
03:26:27 <solidsnack> mux: Really? I thought dependent typing just meant even better static checking.
03:26:42 <pumpkin> what I typically see as dependent typing would be a command prompt that allowed a user to type the size of the vector in
03:26:54 <pumpkin> and would still be able to prove statically that you never try to add vectors of the wrong sizes
03:27:12 <mux> solidsnack: I wish it was that simple
03:28:17 <pumpkin> maybe Philippa__ knows
03:28:51 <solidsnack> I've always understood dependent typing to mean that if your program *could*, *maybe* pass 0 to `div` then it can't be compiled.
03:29:07 <solidsnack> However, I don't really know very much about it, to be honest.
03:29:30 <mux> solidsnack: if that was all there was to it, dependent typing would be no more interesting than total functional programming
03:29:50 <mux> which already prevents using partial functions such as div
03:30:30 <mux> with dependent typing, types can depend on values, so running a program or type checking it is actually the same thing
03:30:36 <thoughtpolice> pumpkin: okay, so you want something like "let x = <1 2 3 4 5> :: Vector[5]"? afaics in ATS you can express something like "fun v_add {a,b:nat | a == b} (x:vec a,y:vec b): vec (a+b) = ..."
03:30:48 <pumpkin> oh, sure
03:30:49 <mux> you cannot type check if you don't have the values assoicated with some type
03:31:00 <pumpkin> but must the a and b be set at compile time?
03:31:24 <pumpkin> if so, we can still do that in haskell :P
03:31:38 <thoughtpolice> no
03:31:47 <pumpkin> really?
03:31:59 <thoughtpolice> but like I said ATS seems to be based on constraint-checking for that type of stuff
03:32:14 <mux> pi n. forall a. Vector a n -> a -> Vector a (n + 1)
03:32:18 <mux> would be a dependent type
03:32:26 <thoughtpolice> so you must still ensure in your code that things are proper, but the constraint checker can verify that (and it will complain if you aren't constraining values)
03:32:43 <pumpkin> thoughtpolice: hmm, I don't understand
03:32:57 <pumpkin> thoughtpolice: if the constraint checker has two unknowns
03:33:15 <thoughtpolice> pumpkin: http://www.ats-lang.org
03:33:16 <pumpkin> what does it do?
03:33:21 <pumpkin> yeah, I've seen it :P
03:33:24 <thoughtpolice> pumpkin: look down to 'factorial 2'
03:33:25 <Axman6> hmm, what are dependent types anyway? (actually looking like something that might be useful to me)
03:33:40 <thoughtpolice> Axman6: < mux> with dependent typing, types can depend on values, so running a program or type checking it is actually the same thing
03:34:03 <Axman6> :o
03:34:24 <mux> Axman6: types in haskell can take other types as parameters (ie with a kind * -> * like for Maybe)
03:34:34 <Axman6> yep
03:34:39 <mux> now imagine that types can also take plain values as parameters
03:34:44 <mux> and you have dependent typing, more or less
03:34:50 <Axman6> that Vector thin above looks funky and cool
03:35:02 <Axman6> thing*
03:35:08 <mux> that's one of the canonical examples of depdendent typing
03:35:24 <Baughn> Well, /types/ can't take other types at parameter
03:35:27 <Baughn> Type constructors can
03:35:47 <Axman6> ffs my ISP is a piece of crap -_-
03:35:47 <pumpkin> thoughtpolice: factorial 2 still seems quite possible in haskell, unless I'm missing something
03:36:12 <Axman6> i really dislike being connected and not being able to load anything due to packet loss
03:36:54 <pumpkin> hmm, maybe no6
03:36:55 <pumpkin> not
03:37:05 <thoughtpolice> pumpkin: yes, but if you remove the call to assert_errmsg, ATS will reject the program
03:37:39 <thoughtpolice> because it determines that the value 'n' can have any value of int, but it has not been constrained to fit what the type wants.
03:38:10 <kynes> I have a Haskell program using a module
03:38:26 <kynes> I want to be able to continue computation when the used module throws a program error
03:38:28 <monadic_kid> One of the guys working ATS was behind Xanadu, shame that project didn't carry on
03:38:31 <kynes> how can I do this?
03:38:49 <Axman6> Control.Exception
03:38:50 <thoughtpolice> monadic_kid: h. xi?
03:38:52 <kynes> I mean I just need to skip that list element throwing the program error
03:38:56 <pumpkin> thoughtpolice: that looks a bit like data Nat = Zero | Succ Nat; along with a pattern match failure
03:39:03 <kynes> Axman6, how, could you explain briefly?
03:39:03 <monadic_kid> yeah
03:39:11 <Axman6> :t catch
03:39:13 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
03:39:13 <thoughtpolice> monadic_kid: he did dependent ML too
03:39:15 <Axman6> :t try
03:39:16 <lambdabot> Not in scope: `try'
03:39:19 <Axman6> bah
03:39:21 <kynes> Axman6, thanks
03:39:29 <Axman6> :t handle
03:39:30 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
03:39:32 <pumpkin> hmm
03:39:34 <pumpkin> ah well
03:39:39 <Axman6> hmm, maybe not'
03:39:43 <Axman6> :t bracket
03:39:44 <lambdabot> Not in scope: `bracket'
03:39:48 <Axman6> lame
03:40:07 <Baughn> Axman6: Yeah, that's the wrong "catch" too
03:40:10 <pumpkin> thoughtpolice: I see though
03:40:14 <Axman6> :\
03:40:16 <Baughn> The prelude /really/ needs some fixing
03:40:16 <pumpkin> anyway, it's too late, I'm going to sleep :P
03:40:30 <pumpkin> submit a ticket!!
03:40:42 <pumpkin> I'll be happy to cc myself to "vote" for it :P
03:40:54 <Baughn> pumpkin: I bet. :P
03:40:59 * Axman6 has noticed quite a few people CC'ing themselves on his 64-bit OS X ticket
03:41:06 <Baughn> pumpkin: I'll wait until they're working on base-5
03:41:15 <monadic_kid> Xandau has huge potential to replace C/C++ meta preprocessor and meta template programming
03:41:25 <pumpkin> Baughn: can't hurt to get people thinking about what's wrong with it
03:41:38 <pumpkin> Axman6: yeah, it was mentioned on a ghc list and then that made it to reddit
03:41:48 <Axman6> ah, i see
03:42:06 <Baughn> pumpkin: I suppose. I don't have much free time for that stuff right now, though; coming up on exam season. *Last* exam season. ^_^
03:42:10 <pumpkin> :)
03:42:35 <kynes> monadic_kid,  what is Xandau?
03:42:56 <Axman6> Baughn: :)
03:42:58 <kynes> monadic_kid, I couldn't find by searching name is gogle
03:43:05 <Axman6> i've got exams next week :(
03:43:18 <Axman6> three, two on the same day. luckily they're only mid-sems
03:43:19 <Baughn> That's early
03:43:23 <Baughn> ..oh
03:43:25 <monadic_kid> kynes: dependently type imperative language, it looks like C with a depedent type system
03:44:02 <kynes> monadic_kid, why the need for "looks like C" and "imperative" ?
03:44:56 <kynes> monadic_kid, I mean instead of "looks like pseudo (close to Python)"  and "functional" ?
03:45:03 <kynes> monadic_kid, or just Haskell
03:45:06 <kynes> :)
03:46:21 <monadic_kid> kynes: because it was  a project to prove a point and to show how you can reap benefits of such a type system in an imperative language
03:46:47 <kynes> monadic_kid, good project
03:47:59 <kynes> monadic_kid, I mean I didn't say the lines above to attack the project idea.. don't get me wrong
03:48:43 <monadic_kid> you think graphics industry would have got to the position it is today by not making high-level shading languages C-like languages?
03:49:05 <Axman6> it's possible
03:49:24 <monadic_kid> i'm not saying it's impossible, i'm saying it wouldn't have been feassible to do
03:49:51 <monadic_kid> you really think that would have gel'ed well in the games industry making it like haskell?
03:50:25 <monadic_kid> shader langauges are really functional languages in disguise anyways
03:50:28 <Axman6> don't see why not, as long as they could connect C/C++ easily enough
03:51:04 <monadic_kid> I don't think so, alot of people would have been pissed off
03:51:11 <monadic_kid> i work in the industry
03:52:05 <monadic_kid> people get pissed off if you use modern C++ techniques let alone something completely different syntatically wise
03:52:22 <Axman6> heh
03:55:53 <monadic_kid> anyways what I would love to see is something like Xandau and SAC, starting from a referentially transparent subset of C99 with a dependent type system and something like uniqueness types, multi-stage programming support and first-class arrays
03:56:49 <Axman6> first class arrays?
03:56:58 <maltem> a referentially transparent subset of C99? like, + - * / ?
03:57:19 <monadic_kid> Axman6: have a look at SAC programming language
03:57:54 <Axman6> ohm single assigment C, i've heard of that (don't know much about it though)
03:58:19 * Axman6 waits for wikipedia page to load. frigging isp
03:58:27 <nikki93> What does '<+>' mean?
03:58:57 <kynes> monadic_kid, I agree you points about people, but there's also another factor..
03:59:02 <maltem> @hoogle <+>
03:59:02 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
03:59:02 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
03:59:02 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
03:59:14 <solidsnack> mux: Sorry, stepped away from the computer.
03:59:33 <monadic_kid> that should cover all the bases where meta preprocessor & meta template programming is typically used but pretty much banned from commerical code or code reused throughout different teams in the company.
03:59:42 <kynes> monadic_kid, you see Erlang, Clojure etc. popped up in the industry as important languages since there's the need for fault tolerance
04:00:02 <kynes> monadic_kid, parallelism is increasing in computational fields
04:00:17 <kynes> monadic_kid, so eventually functional languages will rule :)
04:00:28 <kynes> monadic_kid, (not a big IMHO must be added there)
04:00:28 <chrisdone> how cool are these partial type signatures for ehc?
04:00:34 <solidsnack> If only FP had a good story for distributed computing.
04:00:53 <nikki93> With FP it's harder to handle states, especially in programs such as computer games.
04:01:06 <nikki93> Or maybe I just haven't left the C++ mindset yet. :)
04:01:16 <Baughn> nikki93: It forces you to /think/, sure
04:01:23 <Baughn> It also makes it a lot easier to parallelize the game
04:01:37 <monadic_kid> kynes: those langauges are not appproipate and don't cover what i mentioned and  we are already doing it and doing it for a few years now
04:01:58 <chrisdone> in my experience, the harder it was to do state, the easier the resulting program was to understand
04:02:09 <Axman6> aye
04:02:10 <maltem> solidsnack, at least GHC development is promising enought that there will be a good story
04:02:25 <maltem> solidsnack, ah wait, distributed
04:02:32 <Axman6> having to mentally keep track of what something's set to is usually my biggest problem when debugging imperative languages
04:02:33 <maltem> misread
04:02:37 <kynes> monadic_kid, sure, I didn't give them as examples to what you mentioned.. I just gave those examples to prove that people start to accept an alternative when it's time
04:02:47 <Baughn> Someone could go implement the Sinfonia paper. ;)
04:02:52 <Baughn> Then we'd have a great story
04:02:57 <chrisdone> oh wow, local class instances
04:03:05 <chrisdone> EHC<unicodeheart>
04:03:21 <solidsnack> Baughn: Actually, their story kinda sucks :)
04:03:28 <kynes> Baughn, hey thanks, I didn't hear that one before
04:03:30 <monadic_kid> kynes: i don't think you understand, in the games industry i'm telling you not C++0x is going to be accepted for about 10 years
04:03:43 <Baughn> solidsnack: It beats message-passing
04:03:44 <Axman6> monadic_kid: reckon you could give an example of how arrays are first class citizens in SAC?
04:03:55 <solidsnack> Baughn: Well, sort of.
04:04:02 <solidsnack> You need a few stories, really.
04:04:12 <kynes> monadic_kid, I understand.. you say that the industry people are different..
04:04:17 <monadic_kid> *I''m telling you not even C++0x is going to be accepted easilly for about 10 years after the ISO standard is actually published
04:04:17 <maltem> Axman6, that, and distinguishing between a variable that is set as a part of an algorithm, and a variable that is set as part of the program logic
04:04:18 <Zao> monadic_kid: Acceptance on the console side will be slower than on the PC.
04:04:26 <solidsnack> Sinfonia is single-master system -- it's not a great approach if you care about availability.
04:04:26 <kynes> monadic_kid, they need a tool "right now".. am I correct?
04:04:35 <Axman6> maltem: eh?
04:04:46 <chrisdone> how come the UHC compiler wiki's links to documentation go to ``EHC''?
04:04:51 <Baughn> solidsnack: That could be modified without /too/ much trouble
04:05:00 <solidsnack> Baughn: Well, no. That's all the trouble.
04:05:14 <solidsnack> Multi-master takes frikkin' geniuses.
04:05:22 <maltem> Axman6, I sometimes find it difficult to see where an algorithm is implemented, and where it is merely used
04:05:25 <monadic_kid> isn't anyone actually understanding to what i'm writing, i'm not disputing about referential transparency or a need for tools
04:05:46 <solidsnack> Distributed transaction commit is very hard -- that's why neither Google nor Amazon offer it in their cloud offerings. (They don't have general transactions.)
04:06:03 <solidsnack> monadic_kid: It will be hard for people to adopt new things -- I think we can all agree with that.
04:06:15 <solidsnack> monadic_kid: So that's really a structural/social problem.
04:06:18 <Baughn> solidsnack: Only if you insist on perfection. I seem to recall one algorithm that just had a very low chance of failure..
04:06:42 <solidsnack> Baughn: Eh. Well, that's like saying, only if you don't buy the insurance from me.
04:06:42 <thoughtpolice> chrisdone: wow, that is pretty awesome :)
04:06:47 <maltem> Axman6, that is, algorithmic side-effects vs. "real" effects
04:06:51 <thoughtpolice> chrisdone: UHC has some cool extensions; partial type signatures are neat
04:07:08 <Axman6> maltem: ah, i think i see what you're getting at
04:07:10 <Baughn> solidsnack: If you can make the chance of failure low enough that lightning strikes are more probable, who cares?
04:07:14 <chrisdone> thoughtpolice: yeah!
04:07:24 <solidsnack> Baughn: In that case, great.
04:07:34 <kynes> monadic_kid, I really want to understand.. sorry if I seem to draw wrong conclusions
04:07:46 <solidsnack> That would mean, of course, that failure would not result in common cases -- network partition, node loss, message loss.
04:07:58 <solidsnack> What does that leave? Strikes by lightning.
04:08:09 <thoughtpolice> chrisdone: on the note of n+k patterns, "not available and never will be available"
04:08:38 <chrisdone> thoughtpolice: mhm?
04:08:50 <chrisdone> thoughtpolice: think most people will agree with that?
04:08:53 <Baughn> solidsnack: I'll give you one thing - modifying sinfonia to support multiple masters (even if one's basically a hot spare) wouldn't be /easy/. But I don't think it'd take a genius, either.
04:09:46 <solidsnack> Baughn: One hot spare would be much easier than multiple masters. To solve distributed consensus however -- to really have multiple masters -- is much more difficult.
04:10:07 <solidsnack> Baughn: Here's the deal. You try to figure out how to do it. This time next week, explain it to me :)
04:10:26 <solidsnack> Unless you already know.
04:10:40 <Baughn> solidsnack: I think there are two different problems here. Fault-tolerance - surviving a master crash - is one, but that doesn't require multiple /simultaneous/ masters
04:10:46 <beelsebob> I finally wrote that blog post about bottom not needing to be added to every type :)
04:10:47 <beelsebob> http://noordering.wordpress.com/2009/04/19/bottoms/
04:11:02 <Baughn> solidsnack: And no, I don't, but I'll try to do just that. :P
04:11:15 <thoughtpolice> chrisdone: given the overwhelmingly huge hatred for them, i'd figure anybody even willing to comment on it wouldn't raise a fuss.
04:11:30 <solidsnack> Baughn: Okay. Single master might be suitable for some people's needs but it's basically a hassle.
04:11:43 <solidsnack> Really, administratively that's no advantage over what we have now.
04:12:08 <solidsnack> Baughn: So that's a large part of the appeal of eventual consistency, for example -- it's really hard to lose any data.
04:12:28 <solidsnack> It's also easy to grow the write/read speed by adding more computers.
04:12:48 <Baughn> SUre, sure. It's hard to lose data, if you don't mind readers sometimes getting outdated data
04:13:01 <Baughn> That is usually the case, admittedly
04:13:13 <chrisdone> thoughtpolice: y'know an extension I'd like? patterns that can refer to the same free variable twice
04:13:28 <solidsnack> Right. So enter, multi-master. With distributed transaction commit, we have fresh, redundant data.
04:14:11 <chrisdone> thoughtpolice: I wonder if it would be slower or something. but it's nice to be able to say foo [a,a] ..., rather than foo [a,b] | a == b = ...
04:14:22 <Baughn> When I read the paper, I got the impression sinfonia was for systems where stale data is /useless/ data
04:14:29 <solidsnack> Right.
04:14:33 <kynes> I want to write a safe Haskell function, that takes a function from a module, throwing a program error, and just return a [Char] so that I can return "" in case of error to a [[Char]]
04:14:35 <beelsebob> chrisdone: it requires unification
04:14:37 <kynes> how can I do this?
04:14:43 <chrisdone> beelsebob: yes
04:14:44 <beelsebob> unification is far more complex than pattern matching
04:14:55 <kynes> I mean, when I use catch, it just works for returning IO [Char]
04:14:56 <solidsnack> Baughn: I mean, for filesystems, that's sorta true; and that's what they are doing.
04:14:56 <Baughn> kynes: You can only catch errors in IO
04:14:56 <chrisdone> well, sorry, no
04:14:59 <chrisdone> it doesn't
04:15:05 <chrisdone> beelsebob: what is pattern matching?
04:15:21 <Baughn> kynes: The correct solution is to rewrite the error-throwing function to use ErrorT or explicit return values (Maybe or Either, perhaps)
04:15:30 <beelsebob> chrisdone: the comparisons based on structure that you get to specify on the LHS of a function definition
04:15:35 <kynes> Baughn, but the error-throwing function is not mine :(
04:15:46 <solidsnack> Baughn: However, the reliability problem they introduce is pretty huge.
04:15:53 <Baughn> solidsnack: Distributed filesystems? It might be true for smb, but NFS at least thrives on eventual consistency
04:15:55 <beelsebob> essentially unification, but only in one direction
04:15:58 <chrisdone> beelsebob: what is the difference between unification and pattern matching?
04:16:10 <solidsnack> Baughn: Well, we want metadata to be up to date.
04:16:20 <solidsnack> Also, NFS is kinda single master.
04:16:24 <solidsnack> kinda
04:16:39 <Baughn> Right, so if NFS has problems, how much worse must multi-master systems be? ;)
04:16:39 <beelsebob> chrisdone: pattern matching requires only comparing a small amount of structure and generating bindings
04:16:40 <thoughtpolice> chrisdone: there are view patterns! write views on your data types and use view patterns; you could have 'foo (func -> True) = ...'
04:16:46 <beelsebob> while unification requires constraint solving
04:16:53 <solidsnack> Baughn: Really? Why?
04:16:54 * Baughn knows, actually, since he's writing one. They're horrid.
04:17:00 <solidsnack> Baughn: Really?
04:17:08 <solidsnack> Baughn: So how do you resolve consensus?
04:17:47 <Baughn> solidsnack: I haven't quite figured that out yet
04:17:59 <chrisdone> beelsebob: I don't think having multiple instances of the same free variable would be that more complex. it could be done at compile time and translated to guards
04:18:42 <chrisdone> thoughtpolice: how would you write my list example?
04:18:43 <Baughn> solidsnack: I figure, instead of keeping the system consistent at all times, I should write it to recover from inconsistencies.. um, there was a name for that.. used a lot in long-running transactions...
04:18:47 <beelsebob> chrisdone: except that you gain an Eq constraint then, that you don't clearly see that you need
04:19:00 <solidsnack> Baughn: Hmm.
04:19:20 <chrisdone> beelsebob: why wouldn't you see that checking equality requires Eq?
04:19:23 <solidsnack> Baughn: My thinking on the problem, at present, is to write all transactions into branches and then approve the branches.
04:19:42 <beelsebob> chrisdone: because a pattern match doesn't require equality – wheras that unification does
04:19:47 <solidsnack> Baughn: The name for that is read repair.
04:19:57 <beelsebob> so you would get a situation where *some* pattern matching requires Eq
04:20:03 <solidsnack> Baughn: Does the cluster have fixed membership?
04:20:05 <thoughtpolice> 'foo (func -> True) = ... where func [a,b] = a == b; of course this is a trivial example, normally func would be some general 'view' on your data type you're manipulating
04:20:12 <chrisdone> beelsebob: if the point is to express foo [a,b] | a == b = .. easier, then what is unexpected?
04:20:36 <Baughn> solidsnack: But the basic scheme is, I store metadata alongside the data, accept client transactions once /one/ of the masters for a piece of data has accepted it (that master will also have a write lock on the data), and just deal with the potential inconsistency if it proceeds to crash
04:20:39 <beelsebob> chrisdone: beginners won't see it as making foo [a,b] | a == b = .. easier
04:20:43 <beelsebob> because they won't have had to do that
04:20:59 <chrisdone> beelsebob: so?
04:21:01 <Baughn> solidsnack: Almost-fixed. You can change membership, but it's a slow process of rebalancing.
04:21:22 <beelsebob> chrisdone: so it's not clear why a pattern match foo [a,a] should require an Eq constraint, while a very similar foo [a,b] should not
04:21:37 <solidsnack> Baughn: Is it your goal to offer clients true consistency -- once the server says it's committed, it's committed?
04:21:55 <chrisdone> beelsebob: if you are told that having the same free variable checks them for equality using (==), why isn't that clear?
04:22:10 <kadaver> what is the significance of preorder traversal? it doesnt return the items in inserted order so what do you get really?
04:22:14 <Baughn> solidsnack: Putting it bluntly - no.
04:22:14 <beelsebob> chrisdone: true
04:22:35 <Baughn> solidsnack: My main goals are performance and user-friendliness. That kind of crash would be very rare.
04:22:45 <Zao> Is it possible to get rid of an existing instance?
04:23:33 <Baughn> Zao: Nope. Well, you can not-import the module that defines it, but you can't explicitly hide it.
04:23:37 <Baughn> They're very infectious, too
04:23:49 <solidsnack> Baughn: I'm not sure what user-friendliness means in this context. I don't know much about your system so I can't be sure how performance would be impacted by a consensus algorithm.
04:23:57 <Zao> Baughn: I want to avoid (Binary String)
04:24:09 <Baughn> Zao: The typical solution is to newtype it
04:24:11 <kadaver> the reason we have unsafe head is for convenience? because lists are used for loops it would be annoying if it returned Maybe a ?
04:24:22 <Baughn> Zao: Although, for Binary.. what are you using Binary for?
04:24:32 <solidsnack> Seems like data integrity will be relatively low, though. One node catches on fire and you've lost a bunch of stuff.
04:24:36 <Zao> My current solution is a newtype but that leads to either not being able to use the new type for anything I usually use String for.
04:24:44 <Zao> Baughn: Serialization for network.
04:25:07 <Baughn> solidsnack: All the data is stored on multiple nodes if at all possible. Lose one node, you've lost only transactions that node had accepted but not yet copied to the other nodes storing that data
04:25:42 <Zao> Baughn: I need to mangle my string into word32be-prefixed word16be sequences.
04:25:44 <chrisdone> beelsebob: I like this definition of pattern matching: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_Temp_668 and for unification: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_Temp_675 if we are to take SICP's definition then the difference is pattern matching only has free variables on one side, unification has them on both
04:25:46 <Baughn> Zao: Then you shouldn't use Binary. It's not safe, in that there's no way to detect errors before using the data
04:25:46 <solidsnack> Okay. So this sounds really close to the Dynamo system, an eventually consistent system.
04:25:53 <Baughn> Zao: Look at binary-strict
04:25:58 <Zao> Baughn: Do you have any recommendations for...
04:26:04 <solidsnack> Baughn: If you've not read that paper, you might benefit from it.
04:26:42 <Baughn> solidsnack: Amazon's. I've read it, but it could do with a re-read.
04:27:16 <solidsnack> Baughn: Right, yeah. Is there any kind of conflict resolution in this system?
04:27:41 <solidsnack> I mean, pre-write -- you've got read repair already, it seems.
04:27:59 <Baughn> solidsnack: For data, or metadata?
04:28:04 <chrisdone> thoughtpolice: I'll have to read about that
04:28:14 <solidsnack> Baughn: For either?
04:28:16 <Baughn> solidsnack: And no, I don't. I've got a bunch of ideas, but I haven't really gotten down to writing it yet
04:29:42 <Baughn> solidsnack: There are three consistency models for data. Session semantics and eventual consistency, you probably know already - session semantics deals with multiple writers by basically picking the last to close the file
04:30:00 <solidsnack> Ah. And the third?
04:30:41 <solidsnack> MVCC?
04:30:55 <Baughn> solidsnack: For eventual consistency I haven't quite decided yet. THe third is POSIX; using that, files are locked by the client when it tries writing, and write calls aren't allowed to return before being committed to a master
04:31:21 <Baughn> solidsnack: Or, relaxed slightly, they are but are still locked
04:31:34 <solidsnack> Ah, okay.
04:31:44 <solidsnack> I'm not sure it actually breaks down as simple as that.
04:31:49 <Baughn> Dealing with multiple writers makes no difference to the first case, but in the second case they're forced to trip through the server anyway
04:32:37 <solidsnack> For session consistency, for example, you can have branches -- it doesn't necessarily boil down to last-write-wins.
04:33:03 <Baughn> You *could*, yes
04:33:05 <solidsnack> Also, for first-write-wins, multi-view concurrency control is another option.
04:33:38 <solidsnack> Once you have revision graphs, you just need a way to approve one branch to be the trunk.
04:33:40 <Baughn> Remember, I'm trying to emulate a posix filesystem in all these cases
04:33:46 <Baughn> Last-write-wins is how it's /supposed/ to work
04:34:05 <Baughn> Plus, I don't want users to have to understand any of this
04:34:06 <solidsnack> Well, okay, interesting.
04:34:26 <kadaver> instance Monad Queue where
04:34:26 <kadaver>     return v = Queue v
04:34:31 <solidsnack> What are these users?
04:34:31 <kadaver> Occurs check: cannot construct the infinite type: a = [a]
04:34:36 <kadaver> data Queue a = Queue [a] deriving(Eq,Ord,Show)
04:34:50 <Baughn> solidsnack: People who use the filesystem.. um, joe six-pack basically
04:34:52 <solidsnack> If they understand Subversion, they understand multi-view concurrency control.
04:35:01 <solidsnack> Baughn: Ah, okay.
04:35:09 <solidsnack> So not developers of any stripe.
04:35:37 <solidsnack> These users want to lose all their changes in the event of someone else leaving a file open forever?
04:35:44 <kadaver> @src fmap
04:35:44 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
04:35:48 <kadaver> @srcmap
04:35:49 <lambdabot> Unknown command, try @list
04:35:51 <kadaver> @src map
04:35:51 <lambdabot> map _ []     = []
04:35:51 <lambdabot> map f (x:xs) = f x : map f xs
04:35:52 <beelsebob> kadaver: side note – a list as a queue is not a good plan
04:35:58 <kadaver> @src lambdabot
04:35:58 <lambdabot> Source not found. You type like i drive.
04:36:02 <beelsebob> because either you're gonna have O(n) insertion, or O(n) removal
04:36:10 <kadaver> ?
04:36:14 <kadaver> oh yeah
04:36:20 <kadaver> lol i made a stack
04:36:24 * kadaver is embarrassed
04:36:27 <beelsebob> hehe
04:36:40 <Baughn> solidsnack: It should be possible to throw it on a bunch of computers, have them automatically discover each other (if on a local network) and ask for permission to join up, and automatically handle /everything/ from that up to and including the purchase of storage from amazon, adding redundancy by moving data around, or screaming at them to fix their computer
04:37:03 <Baughn> solidsnack: And that's a peculiarity of session semantics. They probably wouldn't, but then again it defaults to posix. ;)
04:37:10 <solidsnack> Baughn: Well this is one hell of a product.
04:37:26 <Baughn> solidsnack: Heh. "Should" doesn't mean "will", but I can dream
04:37:31 <kadaver> beelsebob: but what si wrong with the monad?
04:37:43 <solidsnack> Baughn: Well, it's not a peculiarity of session semantics. Open your mind. These categories are weird, I don't know where you got them.
04:38:14 <beelsebob> kadaver: return = Queue . pure -- you forgot to put it in a list
04:38:15 <solidsnack> Baughn: It's branching, plain and simple. You don't have to associate branches with a session.
04:38:45 <solidsnack> Baughn: So this sounds pretty hypothetical/exploratory.
04:39:05 <solidsnack> You don't need to multi-master the Twitter database by Friday :)
04:39:22 <beelsebob> kadaver: of note, I'm guessing you want zip-list like behavior for queues, because cross product-like behavior makes little sense – you'd block forever waiting for the second queue to run out of data totally
04:39:28 <beelsebob> in which case, you can't have a monad instance
04:39:35 <beelsebob> you'll need to settle for functor and applicative
04:39:39 <Baughn> solidsnack: I picked them to be understandable without needing to study them very much. They're basically "Acts like a local filesystem", "acts sanely most of the time but is faster", and "may give you old data but is even faster"
04:40:07 <solidsnack> Baughn: Hmmm.
04:40:58 <kadaver> instance Monad Stack where
04:40:58 <kadaver>     return v = Stack [v]
04:40:58 <kadaver>     Stack v >>= f = f v
04:41:02 <kadaver> but >>= doesnt work
04:41:16 <Baughn> solidsnack: I'm also assuming that conflicts will in fact be very rare, so I can use slow methods (eg. serializing them via a single computer) to deal with them
04:41:40 <beelsebob> kadaver: you need to (a) deal with *all* the items in the stack
04:41:41 <solidsnack> I think in a filesystem, conflicts would be very common, though.
04:41:41 <kadaver> what would you use for Queues in Haskell?
04:41:44 <beelsebob> (b) return a stack
04:41:54 <kadaver> so i should mape th elist i tried that too
04:42:24 <beelsebob> (Stack vs) >>= f = Stack $ join (f <*> vs)
04:42:40 <beelsebob> or actually, that's f >>= vs in the list monad anyway
04:42:44 <beelsebob> so just use that :)
04:42:44 <Baughn> solidsnack: Think "homedirs", not "high-performance shared memory for cluster software"
04:43:24 <beelsebob> kadaver: are you sure this is the behavior you want though
04:44:00 <beelsebob> that one stack of height m bound onto a function producing stacks of height n results in a stack of height n*m
04:44:19 <solidsnack> Baughn: Anyways, I won't prod you on this anymore. You've got to keep your secrets :) I have a mailing list where me and a few other people discuss this kind of stuff: http://groups.google.com/group/distribuchat
04:44:35 <Baughn> solidsnack: Version control, branching, etc. would be great. I have no doubt it would improve the filesystem. However, it would also be a distraction, and the targeted user group /wouldn't use it/
04:44:52 <kadaver> a monad stack doesnt make much sense?
04:44:54 <solidsnack> Baughn: It's there to make your life easier, though.
04:45:12 <solidsnack> Baughn: It would also give them a way to recover stuff -- or a way for their admin to do it.
04:45:34 <solidsnack> Baughn: If this is really what it sounds like, then your competitor who does it will eat your lunch.
04:45:47 <Baughn> solidsnack: It's an MSc thesis. :P
04:45:56 <solidsnack> Oh, never mind.
04:45:58 <Baughn> So no competitors, not really
04:46:00 <daf> kadaver: Data.Sequence, perhaps?
04:46:27 <Baughn> solidsnack: I've got to fit this into what i can write in the time allotted, not what I might want. Plus, I'd probably get it wrong anyway.
04:47:02 <solidsnack> Baughn: Yeah, I see that. Maybe this is helpful to you: http://github.com/jsnx/members-only/blob/master/notes/Consistent%20Logging%20Algorithm
04:47:45 <Baughn> solidsnack: Could be. Thanks.
04:47:46 <solidsnack> Needless to say, I've put a lot of thought behind the MVCC approach; though I don't have the membership algorithm worked out.
04:52:36 <solidsnack> Baughn: Ooops, I gave the answer to the thing you were supposed to tell me in a week.
04:52:42 <solidsnack> :)
04:52:54 <Baughn> solidsnack: Whee. Then you already know it's possible. :P
04:52:57 <solidsnack> s/gave/gave you/
04:53:14 <solidsnack> Baughn: There's a lot of approaches out there already, actually. Paxos is a big one.
04:53:37 <solidsnack> I found them all so hard to understand I just made up my own instead.
04:54:11 <Baughn> solidsnack: Ten to one your approach turns out to be isomorphic to one of the existing ones
04:54:59 <solidsnack> Baughn: If you can show me that, I will, uhm...
04:55:13 <solidsnack> I would say buy you coffee but I think you are in Norway or something.
04:55:19 <solidsnack> ?localtime Baughn
04:55:21 <lambdabot> Local time for Baughn is Sun Apr 19 13:55:20 2009
04:55:28 <Baughn> solidsnack: I am. How about you promise to quack like a duck in a public place?
04:55:33 <solidsnack> Yes.
04:55:41 <solidsnack> Agreed.
04:55:49 <solidsnack> You have a lot of reading to do, though.
04:55:56 <Baughn> Mmh
04:58:02 <solidsnack> My presentation is special -- and my paper worth reading -- because it's really straightforward. It doesn't discuss a family of approaches or the properties of a special component -- it describes just one system, with clear timing constraints and failure conditions.
04:58:31 <Baughn> So I'll have to show it to be a special case of one of those families, then. Gotcha.
04:58:43 <solidsnack> Well, I don't know about that :)
04:58:53 <solidsnack> I mean Paxos contains nearly everything under the sun.
04:59:04 * Baughn whistles innocently
04:59:07 <solidsnack> It's so inclusive it really would be hard to say it's not in there somewhere.
04:59:18 <solidsnack> Which is not isometry :)
04:59:34 <solidsnack> Anyways, this is offtopic for the channel, I fear.
05:00:08 <solidsnack> Should you find a way this is just like someone else's system -- or if you find that it actually doesn't work -- please do comment about it.
05:00:38 <Baughn> Sure. I'll take a good long look, anyhow.
05:05:57 <igel> hi
05:06:18 <igel> can somone help me? i tried to declare a functor instance, but i just don't get it working:
05:06:18 <igel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3915#a3915
05:06:45 <igel> i have a Heap type and if it stores (prio, value) tuples, i want to make it a functor
05:07:05 <Baughn> igel: What does the error look like?
05:07:20 <igel> Baughn: i need a type-level (.)
05:07:34 <igel> have a look on hpaste
05:07:54 <igel> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3915#a3915
05:08:01 <Baughn> igel: Just did. Is the error literally "you need a type-level (.) for this"?
05:08:10 <igel> oh sorry
05:08:14 <EvilRanter> igel, you can't partially apply type synonyms
05:08:35 <kadaver> how do I "unfromList"?
05:08:38 <EvilRanter> you'll have to newtype-wrap it or something
05:08:47 <Baughn> kadaver: Sounds rather like toList
05:08:47 <EvilTerran> kadaver, er, toList?
05:09:05 <igel> but then i'd have to re-declare all functions
05:09:49 <kadaver> is Data.Sequence a circularly linkedlist?
05:09:56 <igel> is there no other way to make (Heap Policy (prio, val)) a functor?
05:10:07 <EvilTerran> igel, don't think so, i'm afraid
05:10:19 <Baughn> kadaver: No
05:10:20 <kadaver> Data.Sequence doesnt have toList
05:10:31 <Baughn> kadaver: If you want to know exactly what it is, internally, install vacuum-cairo. ;)
05:10:32 <igel> kadaver: it does, via it's Foldable instance
05:10:36 <EvilTerran> igel, but you could write a "mapHeap" that did what you want without the Functor polymorphism
05:10:56 <igel> yes...
05:11:04 <igel> hmm...
05:11:12 <EvilTerran> kadaver, "The implementation uses 2-3 finger trees annotated with sizes" - from the haddocks
05:11:14 <igel> maybe i'll just make all heaps store (prio, val) assocs
05:11:23 <igel> then i can declare the instance
05:11:28 <monadic_kid> they really need to invent a mouse with those materials that can never be dirty, just always clean
05:11:38 <igel> and for a simple MinHeap a, i use (Heap (a, ())
05:11:52 <EvilTerran> that would work
05:12:56 <igel> what's the reason for not allowing partial application on type synonyms?
05:13:34 <igel> thanks anyway^^
05:13:45 <monadic_kid> you can kind of do that with boost mpl in c++
05:13:59 <EvilTerran> igel, i think it'd make typechecking undecidable
05:14:25 <igel> really? wow!
05:14:36 <monadic_kid> typedef my_type<foo, _1> paritally_applied_type;
05:14:48 <EvilTerran> igel, "type Id a = a; instance Functor Id where fmap = id; ... fmap f (Just x) -- which instance of Functor is this?"
05:14:59 <igel> :D
05:15:15 <igel> ok
05:15:20 <igel> thanks
05:15:21 <igel> bye
05:15:26 <EvilTerran> with that instance, that fmap could be the Id *or* the Maybe functor instance
05:15:43 <EvilTerran> so it's not so much "undecidable" as "incoherent", i guess
05:16:15 <Baughn> kadaver: Oh yes, you probably should read the typeclassopedia. It'll explain the goodies in things such as Foldable, so..
05:17:31 <kadaver> wjere is Functor implemented?
05:17:49 <cnwdup> kadaver, Control.Applicative
05:17:53 <cnwdup> @index Functor
05:17:54 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:18:02 <cnwdup> Oo
05:18:12 <Baughn> kadaver: If you mean the class itself.. the Prelude. Or GHC.Base, depending on your mood.
05:18:33 <cnwdup> Baughn is right. My bad.
05:25:08 <Zao> Heh, I was scratching my head wondering why there wasn't a Put in binary-strict.
05:25:34 <Baughn> There wouldn't really need to be, would there?
05:26:08 <Baughn> Although there /is/ BitPut
05:26:24 <Zao> It'll look weird having Binary instances with just put though.
05:27:04 <Zao> And yet more warnings :(
05:30:19 <kadaver> for soemthing like: pop :: Queue a -> (Maybe a, Queue a), a Monad instance is fit right?
05:31:13 <EvilTerran> kadaver, wouldn't that be pop :: Queue a -> Maybe (a, Queue a) ?
05:31:22 <EvilTerran> in which case you could use the instance of Monad for Maybe
05:32:12 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3916#a3916
05:32:25 <EvilTerran> (do (x, q') <- pop q; ...) -- Nothing if pop returns Nothing, otherwise the value of (...)
05:33:15 <EvilTerran> ?type Set.minView
05:33:16 <lambdabot> Couldn't find qualified module.
05:33:18 <EvilTerran> ?type S.minView
05:33:19 <lambdabot> forall a (m :: * -> *). (Monad m) => S.Set a -> m (a, S.Set a)
05:33:53 <EvilTerran> ^ is the sort of thing i'm thinking of, although there's no good reason for that to be using Monad m => m instead of just Maybe
05:36:57 <kadaver> yeah mayeb thats better
05:37:07 <beelsebob> neat
05:37:27 <beelsebob> ari rahikkala correctly points out that my definition of bottom solves the problem with Monads and fail
05:37:28 <beelsebob> :)
05:37:29 <beelsebob> http://noordering.wordpress.com/2009/04/19/bottoms/
05:39:28 <magthe> I'm confused by the colours in what's generated by `hpc markup`, and I can't seem to find a legend... where can I find one?
05:40:03 <kadaver> where exactly is the typeclassopedia?
05:43:01 <kadaver> im a legend
05:44:10 <magthe> kadaver: thanks for that intentional misunderstanding ;-)
05:44:59 <Athas> Can I have a record field containing values whose only static typing information is that they are instances of some typeclass?
05:45:23 <Athas> For example, a field defined as: field :: forall a. (MyClass a) => [(a, String)]
05:45:23 <EvilTerran> Athas, with an extension, yes
05:45:29 <Athas> Which extension?
05:46:02 <EvilTerran> i think that's ExistentialQuantification
05:46:48 <Athas> Thank you, I will try it.
05:46:49 <EvilTerran> alternatively, with GADTs, that could be "data Foo where Bar { field :: MyClass a => [(a,String)] } :: Foo", iirc
05:46:49 <kadaver> hmm could ther eb soem sort of Wrappable typeclass for deriving functions like toList fromList singlton empty automatically? because soemtimes I find msyelf just doing: singleton v = Queue $ S.singleton v
05:47:35 <maltem> beelsebob, identifying _|_ with (_|_, _|_) and so on *is* a neat idea, I'm curious what the theorists will say about it. I think, though, that the fail fallacy is only tangentially related
05:47:56 <maltem> (“tangentially related”... cool talk that I'm having today :)
05:48:25 <EvilTerran> kadaver, if you make Queue a newtype instead of a data, you could use the GeneralizedNewtypeDeriving extension and derive Foldable, Traversable, etc
05:49:04 <Athas> My problem is that I get an error about an ambiguous type variable whenever I try to access the field.
05:49:38 <Athas> Ambiguous type variable `a' in the constraint: `MyClass a' arising from a use of `field'
05:49:38 <Athas>  
05:49:43 <kadaver> EvilTerran: really?cool
05:50:44 <MyCatVerbs> Athas: typeclass constraints on data types very, very rarely do what you want to.
05:52:05 <kadaver> > hash "hello"
05:52:06 <lambdabot>   Not in scope: `hash'
05:52:08 <Zao> How do people generally convert between lazy and strict ByteString? (B.concat . L.toChunks)? (B.pack . L.unpack)?
05:52:11 <kadaver> > hashString "hello"
05:52:12 <lambdabot>   Not in scope: `hashString'
05:52:28 <Athas> Hrm.  Maybe I need to rethink my entire approach.
05:53:16 <Axman6> @hoogle hash
05:53:17 <lambdabot> package Hashell
05:53:17 <lambdabot> Data.HashTable hashInt :: Int -> Int32
05:53:17 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
05:54:39 <MyCatVerbs> Athas: please hpaste some code?
05:54:46 <b_jonas> that seems to be a FAQ
05:54:51 <MyCatVerbs> Zao: yep.
05:55:01 <Athas> That's not easy, it's a big system.  Maybe I can extract some of it...
05:55:44 <MyCatVerbs> Preferrably the minimal chunk that illustrates the type error. :)
05:58:28 <EvilTerran> kadaver, what do you want hashes for, if i may ask?
05:58:40 <EvilTerran> someone here may be able to suggest something appropriate
05:58:53 <kadaver> EvilTerran: does it happen automatically? do i need to import Data.Foldable etc still?
05:59:21 <EvilTerran> kadaver, well, the classes you're newtype-deriving have to be in scope
05:59:36 <EvilTerran> and you have to add them to the "deriving" clause of the newtype definiton
06:00:22 <EvilTerran> "newtype Queue a = Queue (Seq a) deriving (Eq, Ord, Foldable, Traversable)" would work with GeneralizedNewtypeDeriving
06:01:03 <Athas> MyCatVerbs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3917#a3917
06:02:06 <kadaver> EvilTerran: semantic hashing of images. so the normal hashing is not gonna work.
06:02:06 <kadaver> anyway
06:03:02 * maltem scratches his head about how GeneralizedNewtypeDeriving is terribly useful, but strangely ad-hoc w.r.t. Show (and what other type classes?)
06:03:34 <EvilTerran> kadaver, ah, i see
06:04:03 <EvilTerran> maltem, yeah, even with GeneralizedNewtypeDeriving, the report-style deriving is used for the classes it's defined for
06:04:42 <EvilTerran> it'd be the same for such things as Eq and Ord, but it differs substantially for at least Read and Show
06:05:45 <kadaver> maltem, Evilterran: the newtypederiving worked!
06:05:56 <EvilTerran> hurrah
06:06:18 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3918#a3918
06:06:28 <kadaver> import some more,code a bit less...
06:07:15 <kadaver> hmm but I still need to wrap Queue around froMlist
06:07:22 <kadaver> so actually it didnt helpmuch :P
06:07:56 <Athas> So, is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3917#a3917 based on a fundamental misconception on how to use typeclasses?
06:08:06 <maltem> EvilTerran, ah ok, then Read and Show should be the only two where it matters
06:08:39 <MyCatVerbs> Athas: a problem arises when you try to even construct MyRecords.
06:09:02 <Athas> Indeed.
06:09:07 <jorick> Can anyone help me spot the type error i made in this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3919
06:09:07 <Athas> Only the empty list works.
06:09:26 <MyCatVerbs> Athas: that forall a. is in the wrong place. Where it has been put, it strictly requires that you must have a value there which is of any possible type satisfying (MyClass a).
06:09:42 <jorick> nvmd
06:09:45 <EvilTerran> jorick, "sqrt" only works on Fractionals, and "mod" only works on Integrals
06:10:53 <Athas> MyCatVerbs: So where should I put it instead?
06:11:00 <mux> damn, there is no UA (Ptr a) instance
06:11:19 <jorick> THX
06:11:55 <EvilTerran> Athas, i think before the constructor name might work
06:12:36 <MyCatVerbs> Athas: TBH, I'm not entirely used to waving existentials around myself, either. :)
06:12:41 <Athas> Indeed, it does.  But it gives me another error, 'Cannot use record selector `f_field' as a function due to escaped type variables'.  I have not done pattern-matching on a record before, but I suppose I shall have to read up on it.
06:12:46 * EvilTerran mumbles something about functions being contravariant in their parameter type, so that making the "forall" act like an "exists" or something
06:13:48 <MyCatVerbs> Athas: this one http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3917#a3920 lets you actually construct things, but your main is still problematic.
06:13:52 <EvilTerran> Athas, ah, yeah, i think this kinda thing's incompatible with record syntax
06:14:48 <EvilTerran> the problem being "data Foo = forall a. Bar a => Foo { unFoo :: a }" would give you "unFoo :: Foo -> (exists a. Bar a => a)"
06:15:50 <nathanroys> Come test new IRC bot, MSN freezer, Port Checker, Ping Output, Telnet Output and much much more! Server: host.swiftdesign.org | Port: 3872 | Channel: #coolbot (Ask an admin for user access!)
06:15:55 <defun> :t (>>>)
06:15:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
06:16:07 <defun> :t (>>=)
06:16:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:16:30 <Athas> My main is not important in itself, it's a contrived example due to the complexity of my real program.
06:16:40 <Athas> I shall try to adapt this new knowledge, perhaps I will be back with more problems.
06:21:25 <MyCatVerbs> Athas: agh. Apologies for not being able to help more directly, but I believe that there is a good explanation of just what you can achieve somewhere on the wiki.
06:22:16 <Athas> Well, it's pretty much a cinch that the solution precludes me from using record syntax.  There is too much code that would have to be updated for that to be a reasonable solution, so I will do something else.
06:22:17 <Athas> Thanks anyway.
06:23:25 <vixey> Athas what is it?
06:23:26 <MyCatVerbs> Ah, right. forall a. (MyClass a) => [(a,String)] still requires that there is only one type a involved, so the lists can't be heterogenous.
06:24:21 <Athas> Right.  I'll just pass closures around instead.
06:32:49 <defun> When would one suggest using arrows instead of monads, or vice versa? They seem to me different notations for the same thing...
06:34:45 <EvilTerran> defun, there are things that're Arrows that aren't Monads
06:34:55 <EvilTerran> (eg, comonads)
06:35:35 <defun> I see. I will google comonads in a moment...
06:35:41 <defun> thanks.
06:37:08 <EvilTerran> so code that's generalised over Arrows won't be able to do as much as code that's generalised over Monads, because it doesn't know as much about the structure of what it's dealing with
06:37:29 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3921#a3921 <- so that's some thing that can monadi-simplified right?
06:37:29 <kadaver> untuplifyMess
06:37:29 <kadaver> use StateT or soemthing?
06:43:11 <kadaver> could fmap on a BST change the context? or what does context mean there? just how the elements are connected disregarding "laws" on how they are connected? I eman you can define fmap for a BST and apply a function that makes it an invalid BST. ie fmap (\v -> if v > 10 then v+1000 else v * 100000) some_bst
06:48:29 <deva> hi
06:48:41 <vixey> hi
06:49:01 <deva> ur name
06:49:43 <deva> can i c u r face on cam
06:49:54 <tomh> wtf
06:50:15 <deva> wat
06:50:30 <tomh> i think you mistyped /join #aol as /join #haskell
06:50:35 <tomh> common typo though
06:50:36 <EvilTerran> deva, are you here to talk about Haskell?
06:50:44 <deva> s
06:50:47 <vixey> yeah deva is def. here to talk about haskell
06:51:00 <beelsebob> maltem: cheers – Lennart Augustun replied with something interesting theory wise, though I'm not certain I agree
06:51:15 <EvilTerran> vixey, eh, i'm just going through the motions. opstime?
06:51:31 <vixey> well I'm going to have toast
06:51:31 <beelsebob> I'm deferring judgement for now
06:51:37 <deva> i want c her
06:52:13 * kadaver wonders if deva wants to see a cadaver
06:52:45 <Axman6> @vixen deva is pretty hot, give him some sugar
06:52:46 <lambdabot> you sound like an awesome guy... are you single?
06:53:13 <deva> ss
06:54:21 <Axman6> aww :(
06:57:12 <Athas> Huh, if I do 'type T2 = T1' inside a module, shouldn't I be able to refer to T2 when that module is included?
06:57:25 <Athas> Every top-level declaration in the module is exported.
06:57:29 <EvilTerran> Athas, only if you export T2, i think
06:57:50 <Athas> I just have the normal 'module M where'-stuff, shouldn't that export everything?
06:58:41 <b_jonas> Athas: yes, it exports everything, even those you imported from other modules
06:58:44 <romildo> Hi.
06:59:19 <romildo> I am going to use regular expressions in my program to extract information from some text.
06:59:58 <EvilTerran> "If the export list is omitted, all values, types and classes defined in the module are exported, but not those that are imported."
07:00:02 <romildo> Which regex library are available in GHC and which would be recommended?
07:00:07 <EvilTerran> b_jonas, so, not quite
07:00:26 <b_jonas> EvilTerran: really?
07:00:27 <b_jonas> I see
07:00:43 <EvilTerran> http://haskell.org/onlinereport/modules.html#sect5.2
07:00:55 <b_jonas> EvilTerran: so in ghci it only works because from bytecode modules it imports all the top-level bindings, even the non-exported ones
07:00:58 <b_jonas> or something
07:01:07 <b_jonas> EvilTerran: thanks for clarification
07:01:17 <kadaver> pop :: Queue a -> Maybe (a, Queue a); i want to use this for traversing a BST level-wise. ie breadth first search. should I write a Monad or soemthing to take care of the tuple-mess?
07:01:57 <vixey> kadaver: I don't think that's possible (or at least not without bending over backwards and tying yourself in a knot)
07:02:34 <EvilTerran> kadaver, it'd probably be easiest to have a function that converted a BST into a lazily-generated list of its elements in breadth-first order
07:02:53 <kadaver> well I mean thee queu is jsut one part of thr algorithm
07:03:44 <EvilTerran> kadaver, well, you could use a MonadState to hold the queue
07:04:17 <thoughtpolice> anybody here with OS X and ghc 6.10.2?
07:06:29 <Axman6> yep
07:06:36 <Axman6> pumpkin too i think
07:07:26 <thoughtpolice> Axman6: can you try to 'cabal install GLFW'?
07:07:45 <Axman6> i'll try, net's being very shitty atm
07:08:28 <FunctorSalad> kadaver: there was an announe for a BFS monad recently (I haven't used it)
07:08:33 <sw1sh> Downloading the latest package list from hackage.haskell.org
07:08:33 <sw1sh> cabal: user error (Codec.Compression.Zlib: incorrect header check)
07:08:36 <sw1sh> wtf?
07:09:05 <dcoutts> sw1sh: download failed, try it again
07:09:20 <dcoutts> sw1sh: it'll probably be an empty file or something
07:09:22 <sw1sh> i tried million times
07:09:55 <dcoutts> sw1sh: hmm, see if cabal update -v3 says anything helpful
07:10:21 <Axman6> thoughtpolice: SSE errors o.O
07:10:35 <thoughtpolice> Axman6: yeah :/
07:10:42 <thoughtpolice> and -optc-msse doesn't help
07:10:43 <Axman6> interesting
07:10:46 <FunctorSalad> kadaver: you could also consider iterated depth first search... (but I don't know how well that plays with haskell peformance-wise)
07:10:50 <thoughtpolice> it gets rid of the first error, but the second one persists
07:11:51 <sw1sh> cabal update -v3 , nothing helpful
07:12:33 <kadaver> anyway, what si the significance of traversing a BST preorder?
07:12:55 <kadaver> why woudl you want to do that? it doesnt return the elements in inserted order so exactly what is it you get out?
07:18:37 <Axman6> thoughtpolice: emailed the maintainer?
07:19:25 <thoughtpolice> Axman6: 'bout to.
07:19:30 <thoughtpolice> probably need sleep soon....
07:20:39 <Axman6> @localtime thoughtpolice
07:20:42 <lambdabot> Local time for thoughtpolice is Sun Apr 19 16:20:40 2009
07:28:51 <kadaver> @src pure
07:28:52 <lambdabot> Source not found. stty: unknown mode: doofus
07:29:20 <kadaver> @index pure
07:29:20 <lambdabot> Control.Arrow
07:29:34 <EvilTerran> there's one in Control.Applicative as well
07:30:12 <kadaver> the one in Arrow deosnt exist
07:30:41 <Axman6> @src Arrow
07:30:42 <lambdabot> class Arrow a where
07:30:42 <lambdabot>     arr, pure   :: (b -> c) -> a b c
07:30:42 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
07:30:42 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
07:30:42 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
07:30:44 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
07:30:46 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
07:30:50 <kadaver> *Data.Stack> pure 1 []
07:30:50 <kadaver> 1
07:30:53 <kadaver> why no error?
07:31:10 <Axman6> :o
07:31:30 <b_jonas> what?
07:32:02 <b_jonas> how can they both have the same method? that's strange
07:32:16 * edwardk1 is trying to figure out if he can make a trie into a monad in a nice way.
07:32:27 <mads-> sumList [a | a <- [1..1000], isMultOf 3 a || isMultOf 5 a, a < 1000] - what is the [ a | something something ] called and how does it work? :)
07:33:16 <mads-> Hmm, it must have omitted some of my text - I actually wrote that question to be quite kind, and not at all as ass-hole-ish as it is stated there
07:33:28 <edwardk1> return yielding a trie with the empty key string bound, >>= concatenating the keys seems to work, but the obvious implementation i have i think fails slightly on associativity
07:33:58 <Axman6> mads-: list comprehension
07:34:28 <mads-> thanks Axman6
07:34:43 <Axman6> mads-: [x | x <- xs] is just xs, [x | x <- xs, p x] is filter if p is a predicate a -> Bool
07:35:31 <PeakerWork> [x | x <- xs, p x] == filter p xs
07:36:44 <ddarius> b_jonas: That Arrow class is out dated.
07:36:45 <EvilTerran> b_jonas, i think it was just that the Applicative and Arrow papers both used the name "pure" for different things
07:37:05 <b_jonas> I see
07:43:28 <maltem> class Pointed f where point {- or pure? -} :: a -> f a
07:43:54 <jmcarthur> edwardk: is this trie a set or a map?
07:44:04 <edwardk> jmcarthur: map
07:44:21 <edwardk> jmcarthur: i can derive the set version from it just by wrapping it around () anyways
07:44:29 <jmcarthur> edwardk: have you read conal's type class morphisms paper?
07:44:49 <edwardk> jmcarthur: its not ringing a bell, but i think i've read everything he's written at somepoint
07:45:09 <edwardk> oh yeah
07:45:40 <edwardk> he had some memo trie stuff in there
07:46:16 <jmcarthur> edwardk: i just point it out because it might help you decide what semantic you want for that monad instance (the paper would endorse that it be isomorphic to (->) k's monad instance, if that is your semantic model)
07:46:24 <edwardk> mine is a boring normal trie (technically ternary search tree) that i'm just experimenting to see if i can unbox efficiently
07:46:47 <b_jonas> unbox :-(
07:46:53 <b_jonas> all this crazy unboxing
07:47:20 <edwardk> jmcarthur: unfortunately thats a different monad than the one i'm thinking of i think.
07:47:32 * EvilTerran was gonna suggest "tries are analogous to mappings, so you could pretend Trie = (->)"
07:47:35 <edwardk> jmcarthur: the model i'm looking at can be viewed as seeing it more like a free monad
07:47:38 <cnwdup> shepheb, ping
07:47:49 <edwardk> with the string playing the role of the constructor
07:48:14 <Actium_> um, check out my awesome rot13! http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3922
07:48:16 <edwardk> so concatenating the constructors is analogous to how the free monad builds up trees
07:49:11 <edwardk> so: singleton "Hello" 1 >>= (\n -> singleton " World" (n + 1)) == singleton "Hello World" 2
07:49:45 <jmcarthur> ah
07:50:07 <PeakerWork> maltem: inject maybe?
07:50:13 <edwardk> in which >> has the desired semantics to match the operation of the multiplication of in the Monoid m => [m] seminearring
07:50:22 <edwardk> er of the
07:50:47 <b_jonas> Actium_: it doesn't seem to like punctuation
07:50:59 <ddarius> data TrieSig x = Empty | Fork Char x; type TrieMonad = FreeMonad TrieSig
07:51:15 <Actium_> b_jonas: i have only got around to handling spaces in that respect
07:51:16 <ddarius> Er not quite right
07:51:33 <maltem> PeakerWork, sounds good, but is even longer than pure or point
07:51:56 <edwardk> jmcarthur: i'm still playing with it, but it seems like the right model for it for my purposes in the monoid lib
07:52:05 <PeakerWork> maltem: I don't think that should be a factor
07:52:23 <Actium_> b_jonas: i need an extra test so only alpha chars are changed, and everything else is left alone
07:52:36 <b_jonas> Actium_: yes
07:52:42 <EvilTerran> > let mapping = zip (['a'..'z']++['A'..'Z']) (['n'..'z']++['a'..'m']++['N'..'Z']++['A'..'M']); rot13 c = fromMaybe c $ lookup c mapping in map rot13 "Hello, world!"
07:52:43 <lambdabot>   "Uryyb, jbeyq!"
07:53:08 <b_jonas> EvilTerran: yeah, that's the apl-like solution
07:53:25 <EvilTerran> er, ok...
07:53:29 <Actium_> EvilTerrain: ah, i see
07:53:38 <Axman6> > let mapping = zip (['a'..'z']++['A'..'Z']) (['n'..'z']++['a'..'m']++['N'..'Z']++['A'..'M']); ot13 c = fromMaybe c $ lookup c mapping in map rot13 "Uryyb, jbeyq!"
07:53:40 <lambdabot>   Not in scope: `rot13'
07:53:40 <ddarius> data TrieSig x = Empty | Branch [TrieSig' x]; data TrieSig' x = Limb Char (TrieSig x) -- perhaps
07:53:48 <RayNbow> http://www.reddit.com/r/haskell/comments/8do1l/live_from_hac5_dutch_haskell_user_group_formed/ <-- awesome :)
07:53:50 <Axman6> > let mapping = zip (['a'..'z']++['A'..'Z']) (['n'..'z']++['a'..'m']++['N'..'Z']++['A'..'M']); rot13 c = fromMaybe c $ lookup c mapping in map rot13 "Uryyb, jbeyq!"
07:53:52 <lambdabot>   "Hello, world!"
07:54:01 <kadaver> so Stewie what are you doing today? oh nothing just studying some functors in the category of small categories
07:57:00 <b_jonas> > let { rot13i x | 'a' <= x && x <= 'm' || 'A' <= x && x <= 'M' = 13 | 'n' <= x && x <= 'z' || 'N' <= x && x <= 'Z' = -13 | otherwise = 0; rot13c x = toEnum (fromEnum x + rot13i x) :: Char; rot13 = map rot13c; } in rot13 "Uryyb, jbeyq!"
07:57:01 <lambdabot>   "Hello, world!"
07:57:27 <Actium_> b_jonas: thanks, but i prefer EvilTerran's :)
07:58:59 <tromp> tr "A-Za-z" "N-ZA-Mn-za-m"
07:59:45 <ddarius> @pl rot13 c = fromMaybe c $ lookup c mapping
07:59:45 <lambdabot> rot13 = ap fromMaybe (flip lookup mapping)
08:00:11 <b_jonas> where ap means <*>
08:00:46 <tromp> use maybe id instead
08:00:53 <tromp> :t maybe
08:00:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:01:04 <b_jonas> tromp: what's wrong with fromMaybe?
08:01:22 <skorpan> :t fromMaybe
08:01:23 <lambdabot> forall a. a -> Maybe a -> a
08:01:40 <skorpan> @src fromMaybe
08:01:41 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
08:01:45 <tromp> requires a Just
08:01:50 <mux> fromMaybe = flip maybe id
08:01:56 <mux> :t flip maybe id
08:01:57 <b_jonas> yup
08:01:57 <lambdabot> forall a. a -> Maybe a -> a
08:02:03 <tromp> sorry
08:02:08 <b_jonas> maybe id is useful too
08:02:11 <ddarius> :t flip maybe id
08:02:12 <lambdabot> forall a. a -> Maybe a -> a
08:02:15 <Actium_> @src lookup
08:02:16 <lambdabot> lookup _key []          =  Nothing
08:02:16 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
08:02:16 <lambdabot>                         | otherwise = lookup key xys
08:02:19 <tromp> i tjust think maybe clearer
08:02:33 <skorpan> does prefixing parameters with _ make ghc not warn about unused parameters?
08:02:34 <b_jonas> :-)
08:02:42 <mux> skorpan: yes
08:02:44 <skorpan> i see
08:02:58 <Actium_> so why not just use _ ?
08:03:05 <b_jonas> Actium_: doc
08:03:13 <mux> for when you want to name the parameter but don't want to use it
08:03:22 <tromp> i need coffee
08:03:37 <Actium_> b_jonas: you mean, for clarity?
08:03:44 <b_jonas> Actium_: yes
08:10:26 <_dolio> Anyone installed UHC?
08:10:58 <Berengal> dolio: I was thinking about installing it...
08:11:04 <dolio> Heh.
08:11:12 <dolio> Well, if you do, let me know if it works.
08:11:42 <dolio> I get complaints about it not being able to find the prelude and such, but there's nothing in their instructions about taking steps to install libraries.
08:12:00 <Lemmih> dolio: It works.
08:12:25 <monochrom> "f _ _ _ _ _ [] = 0" is a bit boring. It's more musical to "f _do _do _me _so _so [] = 0"
08:12:28 <Lemmih> dolio: I had to run 'autoreconf && ./configure' to install it.
08:12:51 <dolio> Hmm, okay.
08:12:54 <Lemmih> monochrom: And invalid, too.
08:13:05 <QtPlaty[HireMe]> monochrom: Does prepending the name with _ mean that the value gets thrown away?
08:13:52 <maltem> QtPlaty[HireMe], no, it would have to be f _do _doo _me _mee _so _soo [] = 0
08:13:52 <b_jonas> QtPlaty[HireMe]: sort of, but not as a rule (in haskell). it's like a normal variable, you could use it in the expression, but it usually means it's thrown away.
08:15:07 <QtPlaty[HireMe]> So its just a convention?
08:15:29 <b_jonas> QtPlaty[HireMe]: yes,
08:15:38 <b_jonas> it's used in other languages too
08:15:41 <b_jonas> I think it comes from prolog
08:16:01 <b_jonas> but perl definitely supresses the "used once only" warning too if a package variable starts with an underscore
08:16:52 <ddarius> > let f __ = __ in f 3
08:16:53 <lambdabot>   3
08:16:53 <flux> o'caml too supports that convention
08:16:59 <b_jonas> only in prolog an underscored variable really is distinct from other underscored vars of the same name
08:17:20 <b_jonas> so in prolog (_A, _A) is two different vars, whereas (A, A) is the same var twice
08:17:39 <b_jonas> in haskell only the single underscore is special
08:18:33 <b_jonas> or at least
08:18:53 <b_jonas> that's what the docs say but the prolog interpreter doesn't seem to actually behaive like that
08:19:17 <b_jonas> oh, I see
08:19:27 <b_jonas> in prolog too only the bare underscore is special that way
08:19:42 <vixey> Use _A to ignore singleton warnings
08:19:44 <b_jonas> anything underscored is a normal variable but with the once warning supressed
08:19:47 <b_jonas> yeah
08:19:51 <b_jonas> sorry about the confusion
08:19:57 <nikki93> My xmonad config: http://codepad.org/hgIyfKhj
08:20:00 <nikki93> Just started on it.
08:20:25 <adityam> I am looking for a function (a -> b) -> (b -> Maybe c) -> a -> Maybe c but cannot find it
08:20:43 <ddarius> @hoogle (a -> b) -> (b -> Maybe c) -> a -> Maybe c
08:20:44 <lambdabot> No results found
08:20:53 <ddarius> It's just precomposition.
08:21:12 <Axman6> adityam: that's just (.)
08:21:21 <Axman6> or, flip (.)
08:21:31 <adityam> :) Darn, I was searching too hard
08:21:43 <b_jonas> @djinn (a -> b) -> (b -> Maybe c) -> a -> Maybe c
08:21:43 <lambdabot> f a b c = b (a c)
08:21:44 <Axman6> (>>>) possibly
08:21:55 <b_jonas> @pl f a b c = b (a c)
08:21:55 <lambdabot> f = flip (.)
08:22:03 <Axman6> @hoogle (a -> b) -> (b -> c) -> a -> c
08:22:04 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
08:22:05 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
08:22:05 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> a -> c
08:22:15 <Axman6> :t (>>>)
08:22:17 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
08:22:45 <Axman6> :t (f :: a -> b) >>> (g :: b -> Maybe c)
08:22:47 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
08:22:47 <lambdabot>       from the context ()
08:22:47 <lambdabot>       arising from a use of `f' at <interactive>:1:1
08:23:09 <Axman6> :t (>>>) (f :: a -> b) (g :: b -> Maybe c)
08:23:10 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
08:23:11 <lambdabot>       from the context ()
08:23:11 <lambdabot>       arising from a use of `f' at <interactive>:1:7
08:23:16 <Axman6> :t (>>>) (h :: a -> b) (g :: b -> Maybe c)
08:23:18 <lambdabot>     Could not deduce (SimpleReflect.FromExpr b, Show a)
08:23:18 <lambdabot>       from the context ()
08:23:18 <lambdabot>       arising from a use of `h' at <interactive>:1:7
08:23:20 <Axman6> bah
08:23:31 <b_jonas> try undefined
08:23:48 <b_jonas> :t (undefined :: a -> b) >>> (undefined :: b -> Maybe c)
08:23:49 <lambdabot> forall a c. a -> Maybe c
08:23:54 <dolio> Lemmih: Heh, apparently running autoreconf makes it *not* build successfully here. :)
08:24:36 <adityam> Well, I typed the expression incorrectly.
08:24:38 <Axman6> ah good call
08:25:14 <adityam> I am looking for (b -> [c]) -> (a -> Maybe b) -> a -> [Maybe c]
08:26:04 <skorpan> @djinn (b -> [c]) -> (a -> Maybe b) -> a -> [Maybe c]
08:26:05 <lambdabot> Error: Undefined type []
08:26:09 <skorpan> aw...
08:26:34 <adityam> @hoogle (Monad m, Monad m') => (b -> m c) -> (a -> m' b) -> (a -> m (m' c))
08:26:34 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
08:26:34 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
08:26:34 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
08:26:37 <edwardk> ddarius: just saw your response,. hrmm
08:26:38 <EvilTerran> adityam, surely the [Maybe c] would either be all Justs or all Nothings?
08:26:46 <dolio> @type \f g -> Data.Traversable.traverse f . g
08:26:47 <lambdabot> forall a (f :: * -> *) b (t :: * -> *) a1. (Applicative f, Data.Traversable.Traversable t) => (a -> f b) -> (a1 -> t a) -> a1 -> f (t b)
08:26:48 <adityam> Yes
08:27:10 <dolio> @type (\f g -> Data.Traversable.traverse f . g) :: (b -> [c]) -> (a -> Maybe b) -> a -> [Maybe c]
08:27:10 <bavardage> Philippa__: ping?
08:27:11 <edwardk> data Tern k v = Tern {-# UNPACK #-} !Int !k !(Maybe v) !(Tern k v) !(Tern k v) !(Tern k v) | Tip; data Trie k v = !(Maybe v) :> !(Tern k v) -- my current rep
08:27:11 <lambdabot> forall b c a. (b -> [c]) -> (a -> Maybe b) -> a -> [Maybe c]
08:27:38 <adityam> EvilTerran: I actually want the result to be Just [c] or Nothing.
08:27:58 <edwardk> ddarius: which is for a ternary search tree based trie
08:28:02 <EvilTerran> ah, so ... -> Maybe [c]?
08:28:18 <adityam> I thought I would just add a sequence up front
08:28:48 <adityam> Thanks dolio, I try traverse
08:29:10 <edwardk> when i switch to an unboxed view the Maybe's will fold into constructor cases and only be materialized by viewing
08:29:18 <b_jonas> @index (>=>)
08:29:18 <lambdabot> bzzt
08:29:31 <EvilTerran> ?type (\f g -> fmap f . g) :: (b -> [c]) -> (a -> Maybe b) -> a -> Maybe [c]
08:29:32 <lambdabot> forall b c a. (b -> [c]) -> (a -> Maybe b) -> a -> Maybe [c]
08:29:37 <EvilTerran> adityam, how's that?
08:30:12 <b_jonas> @src (>=>)
08:30:12 <lambdabot> Source not found. Wrong!  You cheating scum!
08:30:14 <adityam> sequence [Maybe c] = Maybe [c]
08:30:28 <skorpan> @src Control.Monad.>=>
08:30:29 <lambdabot> Source not found. Are you on drugs?
08:30:31 <EvilTerran> adityam, er... Maybe is a type, sequence operates on values (being a value)
08:30:49 <EvilTerran> adityam, but, yes, sequence :: [Maybe c] -> Maybe [c]
08:31:06 <adityam> > sequence [Just 1, Nothing]
08:31:07 <lambdabot>   Nothing
08:31:17 <adityam> > sequence [Just 1, Just 2, Just 3]
08:31:18 <lambdabot>   Just [1,2,3]
08:31:37 <EvilTerran> > catMaybes [Just 1, Nothing, Just 3]
08:31:38 <lambdabot>   [1,3]
08:31:50 <adityam> EvilTerran, I see
08:32:48 <EvilTerran> > msum [Nothing, Just 1, Nothing, Just 3]
08:32:49 <lambdabot>   Just 1
08:33:10 <adityam> @info msum
08:33:10 <lambdabot> msum
08:33:17 <adityam> :t msum
08:33:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
08:33:38 <adityam> @src msum
08:33:39 <lambdabot> msum =  foldr mplus mzero
08:34:08 <adityam> >msum [Nothing, Just 1, Just 2, Nothing]
08:34:16 <adityam> > msum [Nothing, Just 1, Just 2, Nothing]
08:34:17 <lambdabot>   Just 1
08:37:06 <Philippa__> bavardage: busy atm, sorry
08:37:15 <bavardage> that's fine
08:37:18 <bavardage> np :D
08:43:54 <skorpan> i don't suppose you can compare functions in haskell, can you?
08:44:16 <skorpan> because basically i'd like to 'trace' which function is passed onto another function of mine
08:44:19 <adityam> @pl f a = catMaybes $ g b `traverse` h b a
08:44:19 <lambdabot> f = catMaybes . (g b `traverse`) . h b
08:44:28 <skorpan> it can be either 'id' or anything else and that's all i'd like to know
08:44:33 <b_jonas> skorpan: you can't normally. you could define an Eq or Ord instance but not a meaningful one.
08:44:49 <adityam> @pl f a = catMaybes $ traverse (g b)  (h b a)
08:44:49 <lambdabot> f = catMaybes . traverse (g b) . h b
08:45:03 <skorpan> b_jonas: would that work for my problem?
08:45:07 <b_jonas> skorpan: no
08:45:11 <skorpan> darn
08:45:27 <skorpan> is there *any* extension which lets me do this?
08:45:28 <b_jonas> skorpan: you could make the function accept a maybe function instead
08:45:28 <ddarius> skorpan: If you are just doing this for testing purposes there are ways to hack something that would probably accomplish what you want.
08:45:42 <pejo> skorpan, could you replace id with Nothing and the other functions with Just func?
08:46:05 <pejo> b_jonas, guess I'm too slow.
08:46:07 <skorpan> b_jonas, pejo: i suppose i could actually...
08:46:44 <ddarius> skorpan: If this is part of how your algorithm is supposed to work, then using some more explicit structure (the Maybe suggestion being a very simple case) is called for.
08:47:16 <skorpan> ddarius: this is solely for testing purposes, because for some reason it seems that the wrong function is passed along
08:49:02 <kadaver> is breadth first search on a BST by traversing the tree and storing each value in a list as (v,level) then filtering the list on levels and concating in that order acceptable?
08:49:07 <ddarius> skorpan: Well, if you control the functions being passed in, you can use unsafePerformIO and a global variable and have the passed in "id" set the variable when used, or if you don't need programmatic access to this knowledge, you can just use the trace function.
08:51:09 <Phyx-> lol @ the hackage theme song, someone should sing it :P
08:51:14 <solidsnack> kadaver: Seems pretty wasteful to me.
08:51:26 <solidsnack> Phyx-: Song?
08:51:27 <skorpan> JOIN US NOW AND SAFE THE SOFTWARE, YOU'LL BE PUUURE
08:51:28 <maltem> kadaver, why not simple traverse breadth-first in the first place?
08:51:36 <Phyx-> solidsnack, http://haskell.org/pipermail/haskell-cafe/2008-September/047406.html
08:52:03 <kadaver> maltem: simple? deoth first is simple
08:52:22 <solidsnack> Phyx-: Hmm. Weird.
08:52:36 <Phyx-> lol
08:52:38 <solidsnack> It needs to be more lulzy.
08:52:47 * wli ponders starting over on Grobner bases.
08:52:54 <kadaver> breadth firs tinvolves a queue i think
08:53:02 <maltem> kadaver, the other meaning of "simply" ;) I don't think you need to label levels explicitly?
08:53:46 <performance> any one use leksah [ or gtk2hs ] on vista?  with ghc6.10.2 ?
08:54:14 <marred> If there is data structure like heap and I would like to make it instance of functor how should fmap work. I could say that it work only for functions that preserves orders and run it over heap structure. Or  I could deconstruct heap to list (or something similar), apply function and reconstruct the heap in such way that that it will preserve functor laws. What I should choose and why?
08:54:16 <maltem> kadaver, rather I'd have lists of nodes of a specific level
08:54:19 <Phyx-> isn't gtk2hs broken on 6.10.2
08:54:29 <Phyx-> a finalizer problem no?
08:54:46 <Phyx-> atleast the installer fails to recognize 6.10.2 as a newer ghc
08:54:59 <dcoutts> Phyx-: right, it's fixed in the dev version and there'll be a new release
08:55:04 <performance> while installing,  it said some thing to the effect of the user being responsible for correct dll paths
08:55:12 <Phyx-> dcoutts, ah, cool
08:55:15 <dcoutts> Phyx-: that's a separate issue, each binary build is specific to one ghc version
08:55:21 <igel> marred: i'm working on precisely that problem for my heap library atm
08:55:22 <performance> dcoutts:  is there a way to get that from within cabal ?
08:55:31 <dcoutts> performance: no, sorry
08:55:36 <kadaver> marred: I had the same dilemma on a BST, I ended up not implementing it.
08:55:41 <kadaver> the fmap that is
08:55:50 <Phyx-> dcoutts, any specific resons for that? i would guess it would be save to build against 6.10.x?
08:55:53 <igel> there are two ways: a set-like unsafeMapMonotonic and a usual functor for (prio, value) heaps
08:56:06 <kadaver> but i guess: fromList $ fmap f $ toList heap; works
08:56:10 <performance> some changes in 10.6.2 broke gtk2hs
08:56:26 <igel> kadaver: not necessarily
08:56:29 <Phyx-> reason*
08:56:42 <igel> you Functor restrict the functions of a functor
08:56:53 <kadaver> igel?
08:56:54 <igel> and the resulting type could not implement Ord
08:57:14 <igel> fmap print heap
08:57:23 <dcoutts> Phyx-: normally that'd be true but for 6.10.2 there was a finaliser change which requires source changes too in gtk2hs, not just a rebuild
08:57:23 <igel> would be (Heap IO ())
08:57:32 <igel> but you need Ord
08:57:38 <performance> Phyx, http://projects.haskell.org/pipermail/leksah/2009-March/000014.html
08:57:40 <skorpan> i just came up with a rather clever solution to my problem that i had earlier...  so basically i wanted to see which function that was passed to a function of mine, it's either id or something else.  i choose a predefined value, pass it to the function and see whether the result is the same as the predefined value.  or have i missed something?
08:58:10 <Phyx-> dcoutts, ah ok. so it was done with that change in mind, makes sense
08:58:35 <kadaver> igel: you are correct it wont compile instance Functor BST where
08:58:40 <EvilTerran> skorpan, what if the function happens to return the same value at the parameter value you check, but acts differently elsewhere?
08:58:55 <Phyx-> performance, i know about that problem. I was asking why gtk2hs was build against specific versions, and not against all minor revisions of a minor version.
08:59:14 <skorpan> EvilTerran: it's actually a function which is never 'id' for any input
08:59:29 <EvilTerran> skorpan, well, if that's the case, it should be fine
08:59:31 <skorpan> EvilTerran: so either 'id' or a 'modifying' function
08:59:32 <skorpan> cool, thanks
08:59:38 <performance> oh ok. actually i myself dont know much of the problem, i was looking for a solution and ran into that thread
08:59:41 <igel> kadaver: Data.Set has the same problem, they have sth. like unsafeMapMonotonic (which is not very beatiful)
08:59:42 <EvilTerran> without that kind of condition, you'd be trying to do something undecidable
09:00:00 <kadaver> but i can implement it is bmap
09:00:03 <skorpan> checkSame f = f 3 == 3
09:00:09 <skorpan> something like that
09:00:11 <igel> or you implement myMap :: (Ord a, Ord b) => (a -> b) -> Heap a -> Heap b as you said
09:00:21 <performance> dcoutts: know when the next release of leksah is going to be?
09:00:24 <nikki93> After a bit more delving, I've come to see the power of haskell at last.
09:00:40 <EvilTerran> skorpan, if you're asserting as a precondition "(forall x. f x == x) || (forall x. f x /= x)", that should work, yeah
09:00:44 <nikki93> You have to treat functions like crap, forget about the C idea that they're 'big things'. They're not.
09:01:01 <Axman6> yep
09:01:22 <skorpan> EvilTerran: isn't that true for any f?
09:01:30 <EvilTerran> no...
09:01:35 <nikki93> Haskell functionisms allow variables to have a kind of 'AI'.
09:01:36 <skorpan> oh, forall
09:01:49 <EvilTerran> (const 0) 0 == 0, (const 0) 1 /= 1
09:02:04 <Saizan> how can InputT have multiple MonadState and MonadReader instances? http://hackage.haskell.org/packages/archive/haskeline/0.6.1.3/doc/html/System-Console-Haskeline.html#t%3AInputT
09:02:37 <dcoutts> performance: no idea, sorry
09:03:05 <marred> igel: Did you decide to implement it?
09:03:21 <b_jonas> Saizan: because it's a * -> * -> * and the instance depends on what first parameter it gets ?
09:03:49 <edwardk> @remember nikki93 After a bit more delving, I've come to see the power of haskell at last. You have to treat functions like crap, forget about the C idea that they're 'big things'. They're not.
09:03:49 <lambdabot> I will never forget.
09:03:56 <igel> marred: i'll definetely provide a functor instance (or similar function) for (prio, value) heaps
09:04:09 <b_jonas> Saizan: actually not
09:04:13 <igel> i'm not yet sure about unsafeMapMonotonic
09:04:22 <b_jonas> Saizan: those are not MonadState instances of InputT
09:04:33 <b_jonas> Saizan: those are MonadState instances of something else called with InputT
09:04:41 <b_jonas> Saizan: the doc just mentions them for completeness
09:05:54 <kadaver> for (k,v) yes it works applying to v but for just k?
09:06:11 <Saizan> b_jonas: what do you mean by "called with InputT"?
09:07:00 <b_jonas> oh wait, no
09:07:04 <b_jonas> I'm confused
09:07:11 <b_jonas> let me look at again
09:08:13 <b_jonas> Saizan: okay, I'm stupid
09:08:17 <b_jonas> that's not the standard MonadState
09:08:18 <performance> dcoutts: how to uninstall with somethign installed with cabal?
09:08:26 <b_jonas> it's a multi-parameter typeclass version of it I think
09:08:47 <b_jonas> hmm wait
09:09:00 <b_jonas> didn't mtl used to not have fundeps?
09:09:07 <dcoutts> performance: you can unregister the packages using ghc-pkg unregister --user pkgname
09:09:22 <b_jonas> I'm confused
09:09:34 <dcoutts> performance: if you also want to delete the files then use rm on the files in ~/.cabal/lib/pkgname
09:09:54 <Saizan> b_jonas: mtl's MonadState is multiparameters and has fundeps
09:12:22 <performance> would that be %HOME%\.cabal on windows?
09:13:24 <performance> there is no such dir
09:13:29 <dcoutts> performance: not with the .
09:13:38 <dcoutts> performance: it's in the application data dir
09:13:40 <dcoutts> per-user
09:13:41 <Saizan> performance: %AppData%/.cabal or without the ., i think
09:15:37 <b_jonas> Saizan: it could be that one of the names are in different packages
09:15:50 <b_jonas> Saizan: the hackage docs don't show the packages so that's sometimes confusing
09:16:10 <cristi_ceata> hi! what does the (1, 5) mean in "array (1,5) [(i,2*i) | i <- [1..5]]" . Does it mean a 1x5 matrix ?
09:16:46 <b_jonas> cristi_ceata: no, it's starting and ending index
09:16:50 <b_jonas> it's numbered from 1 to 5
09:16:55 <b_jonas> the indexes are that is
09:16:58 <cristi_ceata> b_jonas: I see
09:17:32 <cristi_ceata> then how do I declare a 2 x 2 matrix. how do I build or use one?
09:17:37 <maltem> Is there a common name for the zipWith variant where the resulting list is as long as the longer of the input lists (by adding “zero” elements to the shorter list)?
09:18:13 <Saizan> b_jonas: you're right, i initially dismissed that since it doesn't depend on any other monadic lib, but it has a .Monads module that redefines some
09:19:12 <b_jonas> Saizan: and as the one that's not in that package is not even linked, you can't even tell what package it is in
09:20:16 <b_jonas> though you can of course look at the source or ask :info in ghci to tell
09:22:12 <RayNbow> maltem: not that I know of
09:22:46 <RayNbow> but Python has an izip_longest function
09:22:49 <cristi_ceata> ﻿how do I declare a 2 x 2 matrix? how do I build or use one?
09:22:56 <RayNbow> (which is an ugly name imo)
09:24:58 <EvilTerran> cristi_ceata, well, a 2x2 array would be something like "array ((0,0),(1,1)) ..."
09:25:17 <EvilTerran> or array ((1,1),(2,2)), or whatever lower and upper bounds you want
09:25:27 <EvilTerran> > range ((1,1),(2,2))
09:25:28 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
09:25:45 <maltem> RayNbow, yeah it does look ugly
09:25:46 <EvilTerran> cristi_ceata, and then you'd index that array with "yourArray ! (x,y)"
09:26:09 <b_jonas> (unless of course you want a matrix that's fixed 2 x 2 size in compile time by the type system)
09:26:13 <cristi_ceata> thanks. let me see if it works
09:26:32 <EvilTerran> cristi_ceata, if you're going to want to do matrix operations, there's libraries on hackage that do that for you
09:27:15 <b_jonas> yeah, there's a nice wrapper over some of gsl and lapack
09:27:20 <amaron_> anyone worked with takusen and postgres here? I'm having trouble with postgres boolean fields
09:27:25 <b_jonas> but then it can sometimes help for learning to write them by hand
09:28:09 <RayNbow> zipWithZ :: (a -> b) -> a -> b -> [a] -> [b] -> [c] -- maltem, how about this name? (z for zero)
09:28:14 <RayNbow> erm
09:28:22 <RayNbow> (a -> b) should be (a->b->c)
09:29:04 <b_jonas> RayNbow: shouldn't it be "default" or "filler" instead of zero?
09:30:47 <RayNbow> so zipWithD? zipWithF?
09:30:51 <Berengal> If you know which one is the longest: zip a (b ++ repeat zero)
09:31:20 <b_jonas> RayNbow: maybe
09:31:24 <jedai> cristi_ceata: Among other good library you have hmatrix (use Blas and lapack underneath) and a new version that comes with static guarantees on size static-hmatrix
09:31:35 <b_jonas> RayNbow: maybe it should be zipFWith because you cna have a non-With versoin too
09:32:21 * RayNbow nods
09:33:55 <cristi_ceata> what is wrong here? http://moonpatio.net/fastcgi/hpaste.fcgi/view?id=2160#a2160
09:34:55 <maltem> b_jonas, agreed. I'm not sure though if I'm perfectly happy with the F suffix (functor?)
09:35:14 <Berengal> cristi_ceata: (i, j, i+j) needs to be ((i, j), i+j)
09:35:20 <jedai> cristi_ceata: two things, first the range you want is ((1,1),(2,2)) not what you put
09:35:55 <b_jonas> maltem: maybe make it lonhand
09:36:00 <b_jonas> zipFillWith
09:36:04 <b_jonas> or something
09:36:29 <RayNbow> naming functions is hard :p
09:37:11 <Berengal> zipTwoListsMakingTheResultListAsLongAsTheLongestInputListAndPadTheShortestWithZeroElements ?
09:37:38 <maltem> RayNbow, b_jonas, yeah... oh I'm realizing I could also have zipMonoid :: Monoid a => [a] -> [a] -> [a]
09:38:06 <lstor> justDoWhatIWantHere
09:38:22 <RayNbow> maltem: shouldn't you call it mzip?
09:38:31 <RayNbow> like mconcat?
09:38:38 <b_jonas> erm
09:38:40 <maltem> probably
09:38:52 <RayNbow> hmm
09:39:04 <b_jonas> how about zipMaybe if it returns a maybe
09:39:12 <b_jonas> no wait
09:39:15 <b_jonas> that doesn't work
09:41:37 <maltem> mzip looks nice in the definition, mappend x y : mappend xs ys
09:41:40 <maltem> erm
09:41:47 <maltem> mappend x y : mzip xs ys
09:42:05 <b_jonas> but do you only want to use it on monoids?
09:42:23 <vixey> :t zipWith mplus
09:42:24 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> [m a] -> [m a]
09:42:30 <jedai> zipWithPadded ?
09:42:50 <MyCatVerbs> @src mzip
09:42:51 <lambdabot> Source not found. Do you think like you type?
09:43:40 <maltem> b_jonas, in the specific case from which the idea for zipFillWith (or whatever) arised, mzip is sufficient. Not sure if I'd need zipFillWith at all
09:44:01 <mauke> what should I use to solve a system of linear equations?
09:44:16 <jedai> mauke: hmatrix ?
09:44:20 <jmcarthur> :t mzip
09:44:21 <b_jonas> what's the corresponding apl operation called?
09:44:21 <lambdabot> Not in scope: `mzip'
09:44:42 <b_jonas> it's comma with stile or something but what's the name of the operation?
09:46:13 <MyCatVerbs> > let { mzip (a:as) (b:bs) = mappend a b : mzip as bs; mzip as [] = as; mzip [] bs = bs; } in mzip (+) [1,2,3] [4,5] -- zipWith does not like the lists being of different length. Since forall a. a, mappend mzero a = a, and mappend a mzero = a, and we assume that zipWith mappend as (bs ++ repeat mzero) is the behavoir we want, then this works ouy nicely.
09:46:14 <lambdabot>   Couldn't match expected type `[t]'
09:46:24 <MyCatVerbs> Blast ye.
09:46:37 <Berengal> @hoodle id
09:46:37 <lambdabot> Prelude id :: a -> a
09:46:38 <lambdabot> Data.Function id :: a -> a
09:46:38 <lambdabot> Text.Read Ident :: String -> Lexeme
09:46:43 <Berengal> Lambdabot has dwim?
09:46:54 <MyCatVerbs> > let { mzip (a:as) (b:bs) = mappend a b : mzip as bs; mzip as [] = as; mzip [] bs = bs; } in mzip [Sum 1,Sum 2,Sum 3] [Sum 4,Sum 5]
09:46:55 <lambdabot>   [Sum {getSum = 5},Sum {getSum = 7},Sum {getSum = 3}]
09:48:43 <maltem> MyCatVerbs, d'oh, in my definition I forgot what “identity element” means :-
09:48:47 <mauke> jedai: thanks
09:49:48 <b_jonas> Berengal: yes, it has typo correction
09:50:01 <b_jonas> @noodle id
09:50:01 <lambdabot> Maybe you meant: google hoogle
09:50:27 <maltem> Which means that relying on Monoid is a little stupid, because I could simply have zipSomething :: (a -> a -> a) -> [a] -> [a] -> [a]
09:50:59 <Actium_> @h id
09:51:00 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
09:51:10 <maltem> Anyone with a name for this one? :)
09:51:20 <vixey> zipWith
09:51:32 <b_jonas> vixey: that one is already used up
09:51:35 <EvilTerran> zipAllWith
09:51:38 <vixey> hh?
09:51:43 <maltem> vixey, it should act like mzip above
09:51:48 <MyCatVerbs> maltem: well, not really. It's just that the Monoid laws make that optimization of mzip legal. Semantically it's the same either way.
09:51:51 <maltem> only with mappend being a parameter
09:51:53 <vixey> :t zipWith :: (a -> a -> a) -> [a] -> [a] -> [a]
09:51:54 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
09:52:04 <vixey> you want differenc base cases?
09:52:14 <b_jonas> vixey: yes
09:52:18 <vixey> zipWith'
09:52:29 <b_jonas> vixey: not bad
09:52:33 <maltem> vixey, pfff :)
09:52:41 <mauke> zipWiti
09:52:44 <vixey> your just annoyed you didn't think of it :p
09:52:56 <maltem> quite so
09:53:05 <MyCatVerbs> zipMagma
09:53:56 <maltem> MyCatVerbs, yeah I just mean that I wouldn't bother defining mzip now if (zipWith' mappend) means the same
09:54:11 <maltem> however, making sure:
09:54:16 <maltem> @hoogle zipWith'
09:54:16 <lambdabot> No results found
09:54:23 <maltem> looks good
09:54:26 <b_jonas> MyCatVerbs: ah, that's nice
09:54:28 <dolio> That has similar behavior to unionWith for Maps.
09:54:57 <dolio> zipWith corresponding to intersectionWith.
09:55:04 <b_jonas> dolio: ah yeah
09:55:18 <dolio> unionWith probably isn't a good name for the list version, though.
09:56:25 <MyCatVerbs> b_jonas: just went through the list of mathematical structure on Wikipedia and picked off the one with the fewest axioms. :)
09:56:36 <b_jonas> zero
09:56:44 <b_jonas> well, there's also set
09:56:49 <b_jonas> oh well
09:57:46 <kadaver> ziWPith is the coolest function evah!
09:57:47 <maltem> lol, a magma is just an inner binary operator?
09:58:21 <b_jonas> maltem: yes
09:59:30 <MyCatVerbs> maltem: the term "inner" means "closed in this set"?
10:00:22 <b_jonas> I only know what magma is because that's the name of that other free algebra-oriented computer algebra system (the first being gap)
10:00:40 <maltem> MyCatVerbs, ah sorry, I took it for granted that English uses the same word as German. Yes, as in "inner product"
10:00:55 <b_jonas> er
10:01:04 <ddarius> Inner products aren't closed
10:01:04 <b_jonas> inner product is exactly not like that
10:01:14 <maltem> d'oh
10:01:18 <maltem> of course you're right
10:01:19 <MyCatVerbs> maltem: that's less and English<->German query and more of a MyCatVerbs-who-is-thick<->Mathematics.
10:01:34 <maltem> (Why do they call it inner product then?)
10:01:59 <vixey> maltem because it's the inside of the angle
10:03:22 <maltem> vixey, what, and the outer product is called like that because it points away from the plane?
10:03:46 <vixey> actually I call it scalar product and vector product
10:03:55 <maltem> well so do I
10:04:10 <b_jonas> it's inner product because the brakets point outwards like <x|y> whereas in an outer product they point inwards like |x><y|
10:04:12 <maltem> (or dot product / cross product, especially Kreuzprodukt is common)
10:04:40 <b_jonas> also some people make the distinction between scalar product and inner product, one of them having the complex conjugation and the other not
10:04:51 <b_jonas> because actually both of those products make sense in some contexts
10:05:42 <MyCatVerbs> I call it a "dot" product, because of the pretty little circle symbol in the middle.
10:05:49 <MyCatVerbs> Sometimes I draw a flower in instead! ;)
10:05:59 <b_jonas> lol
10:06:19 <ddarius> I don't think there is any real motivation to the use of "inner" in "inner product"
10:07:06 <maltem> MyCatVerbs, I got crazy when I was first exposed to the <x,y> notation. I couldn't see anymore that <ax,y> = a<x,y> and things like that :)
10:07:48 <b_jonas> well that's more or less an axiom: a<x,y>=<ax,y>=<x,conj(a)y>
10:07:53 <cYmen> ddarius: I am making this up but still: the inner product is in the set of vectors while multiplication with a scalar multiplies a vector with something else
10:07:53 <b_jonas> or something like that
10:08:39 <ddarius> cYmen: The result of an inner product is in the field of scalars which is rarely the same as the vector space.
10:09:00 <cYmen> ddarius: but the factors are both vectors, that's what I meant
10:09:15 <ddarius> Both the factors of an outer product are vectors.
10:09:51 <ddarius> "When ... Hermann Guenther Grassman developed the general algebra of hypercomplex numbers, he realized more than one type of multiplication was possible.  To two of the many possible types he gave the names 'inner' and 'outer'.  The names seem to have been chosen because they are antonyms, rather than for any intrinsic meaning."
10:09:54 <maltem> ok, until you bother to read the right side of the type V*V -> K, it looks as if the inner product were closed ^^
10:10:14 <cYmen> fair enough :)
10:10:21 <b_jonas> K as in field, right?
10:10:29 <b_jonas> makes sense
10:10:48 <maltem> duh, K as in Körper, which means F as in field I guess
10:11:04 <ddarius> The above quote was from the book, "The Words of Mathematics" by Steven Schwartzman
10:11:27 <maltem> ddarius, ah thanks for the quote
10:12:05 <bremner> Does it make sense to describe (C++/python/Java) iterators as monads?  Injection is easy, but I'm not sure if there is a general bind operator. Closest seems to be the idiom *dest++=foo
10:13:00 <mauke> aren't iterators lists?
10:13:25 <maltem> bremner, aren't C++ more like abstract pointers? There's no structure as has a Haskell monad
10:13:26 <bremner> mauke: iterators are more like list like interfaces
10:13:32 <maltem> s/C++/C++ iterators/
10:13:41 <mauke> I mean the general shape of the monad instance
10:14:13 <bremner> mauke: you mean the list monad?
10:14:16 <mauke> yeah
10:14:27 <bremner> hmm, good thought. I'll have to ponder.
10:14:46 <mauke> I mean, what else are you going to do with join :: Iterator (Iterator a) -> Iterator a?
10:16:33 <bremner> maltem: I was thinking of the sense in which iterators hide state, and wrap containers
10:16:48 <bremner> maltem: I don't disagree about the abstract pointer view
10:18:37 <glguy> talking about monads in python doesn't get interesting until you start writing functions in python that work in any monad (like mapM, when, join)
10:20:05 <maltem> bremner, you could say that the Haskell implementation of iterators naturally involves a monad
10:20:35 <glguy> well, it involves one if you want to involve one
10:20:41 * bremner is trying to come to terms with the ACMs designation of iterators as a core concept
10:23:07 <maltem> glguy, right
10:23:09 <bremner> but maybe iterators aren't very natural in a functional context
10:23:30 <vixey> iterators is just a silly name for list or stream
10:24:43 <bremner> vixey: except it seems you have more flexibility under the hood
10:25:00 <Philippa__> vixey: it's not in a mutable setting
10:25:18 <pumpkin> couldn't a bidirectional iterator just be a zipper?
10:25:27 <glguy> throw in unsafeInterleaveIO and you have python iterators :)
10:26:23 <bremner> yeah, I think zipper is the word I was missing
10:30:00 <jfredett> ... api bindings can be a pain in the ass... I'm up to 700LOC -- Garr.
10:30:11 <jfredett> and it's only getting bigger.
10:30:25 <pumpkin> anyone know of an interval tree implementation for haskell?
10:32:23 <kadaver> @type const
10:32:24 <lambdabot> forall a b. a -> b -> a
10:32:37 <kadaver> > foldl const 0 [1..10]
10:32:38 <lambdabot>   0
10:32:54 <kadaver> > foldl (const 1) 0 [1..10]
10:32:55 <lambdabot>       No instance for (Num (b -> a))
10:32:56 <lambdabot>        arising from the literal `1' at <...
10:33:05 <kadaver> > foldr (const 1) 0 [1..10]
10:33:07 <lambdabot>       No instance for (Num (b -> b))
10:33:07 <lambdabot>        arising from the literal `1' at <...
10:33:14 <kadaver> how do I do length with foldr+const?
10:33:21 <pumpkin> const . (+1)
10:33:21 <vixey> > foldl (const (const 1)) 0 [1..10]
10:33:23 <lambdabot>   1
10:33:27 <ddarius> jfredett: Write a program to make them for you.
10:33:33 <vixey> > foldl (const (const (length [1..10])) 0 [1..10]
10:33:35 <lambdabot>   <no location info>: parse error on input `;'
10:33:48 <mauke> )
10:33:54 <kadaver> > foldr (const + 1) 0 [1..10]
10:33:55 <lambdabot>       No instance for (Num (a -> a -> a))
10:33:56 <lambdabot>        arising from the literal `1'...
10:34:05 <kadaver> > foldr (const . (+1)) 0 [1..10]
10:34:07 <lambdabot>   2
10:34:10 <jfredett> ddarius: ... hmm
10:34:13 <kadaver> > foldl (const . (+1)) 0 [1..10]
10:34:14 <lambdabot>   10
10:34:25 <trofi> > sum [1..100]
10:34:31 <lambdabot>   5050
10:34:46 <jfredett> i need to learn how to use the preprocessor...
10:35:05 <kadaver> of haskell?
10:35:06 <kadaver> or C?
10:35:07 <trofi> > pred `fmap` "njof!jt!cjhhfs"
10:35:08 <lambdabot>   "mine is bigger"
10:35:13 <kadaver> lol
10:35:15 <jfredett> haskell
10:35:19 <jfredett> it has one, right?
10:35:22 <mauke> jfredett: no
10:35:34 <mads-> Is there a way if I can check whether a certain Integer is in [Integer] ?
10:35:36 <pumpkin> it just ties into the c preprocessor
10:35:42 <trofi> :t elem
10:35:43 <edwardk> jfredett: it can use the c preprocessor
10:35:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
10:35:45 <jfredett> I can hijack the CPP for it, though.
10:35:57 <pumpkin> jfredett: you can also define custom preprocessors, or use TH
10:36:00 <trofi> {-# LANGUAE CPP #-}
10:36:18 <kadaver> `fmap` makes no sense to me why do people wirt elike that?
10:36:20 <jfredett> pumpkin: Template haskell, hmm
10:36:30 <kadaver> makes me think of airthmetic operations
10:36:32 <pumpkin> kadaver: sure it makes sense :P
10:36:37 <kadaver> not a repeated action
10:36:41 <kadaver> on soemthing
10:36:42 <pumpkin> kadaver: but I usually use <$> there
10:36:47 <Actium_> kadaver: FP makes you think of arithmetic?
10:36:57 <pumpkin> kadaver: your notion of infix operators is a little narrow :P
10:36:57 <jfredett> Well, I was trying to do a type-safe binding, but I gave up because it went >1500loc
10:37:00 <kadaver> no `fmap`
10:37:18 <trofi> @hoogle fmap
10:37:19 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
10:37:19 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
10:37:19 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
10:37:23 <pumpkin> jfredett: aren't there tools to do that?
10:37:24 <jfredett> Eg, compile time assurance that the API requests were valid... can TH do associated type stuff?
10:37:25 <trofi> @hoogle (<$>)
10:37:25 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:37:27 <burp_> > fmap pred "p!smz@"
10:37:28 <lambdabot>   "o rly?"
10:37:32 <pumpkin> jfredett: as of HEAD, yeah
10:38:07 <jfredett> pumpkin: I dunno, I pull these things out of my ass... I thought it'd be fun to screw around w/ assoc types in a more meaningful way than in HCard.
10:38:21 <pumpkin> lol
10:38:24 <pumpkin> how are you using them here?
10:39:19 <jfredett>  Well, right now, I have a class for doing the actual mechanics of requesting the thing.
10:39:38 <jfredett> it uses an assoc type to define the return type
10:39:46 <pumpkin> :o
10:40:06 <jfredett> I'm actually doign several bindings
10:40:09 <pumpkin> seems like fundeps could do the same thing more easily
10:40:16 <pumpkin> but it's not like TH supports making those either
10:40:40 <jfredett> each of which may return data in a different format
10:40:48 <jfredett> pumpkin: This is pretty nice, actually
10:40:48 <jfredett> it's just a assoc type synonym
10:40:55 <pumpkin> ah
10:41:13 <jfredett> easy peasy to deal with.
10:46:06 <jfredett> it's really nice, because the whole system boils down to one simple `request` function. the pain is actually creating the type structure for the various API reqs.
10:46:37 <jfredett> the whole reason is because I'm implementing several different related APIs in a fairly generic. :/
10:46:56 <pumpkin> if I wrote data T = T {-# UNPACK #-} !Int {-# UNPACK #-} !Int would :kind T give me ? -> ? -> *
10:47:02 <pumpkin> or still * -> * -> *
10:47:50 <pumpkin> oh wait
10:47:56 <pumpkin> that question makes no sense :)
10:48:02 <pumpkin> nevermind
10:48:19 <pumpkin> and I can't even amend it to make sense given the lack of polymorphic unpackage, so I'll just pretend I never asked it
10:53:23 <b_jonas> EEK
10:53:28 * b_jonas jumps away from the question marks
10:59:34 <performance> any users of the eclipsefp plugin for haskell here?
11:02:10 <vixey> @w80 askance
11:02:13 <lambdabot> *** "askance" wn "WordNet (r) 2.0"
11:02:14 <lambdabot> askance
11:02:14 <lambdabot>      adj : (used especially of glances) directed to one side with or as
11:02:14 <lambdabot>            if with doubt or suspicion or envy; "her eyes with
11:02:14 <lambdabot>            their misted askance look"- Elizabeth Bowen; "sidelong
11:02:15 <lambdabot> [6 @more lines]
11:02:17 <glguy> pumpkin, would your question have worked to ask about: data A a = B {-# UNPACK #-
11:02:25 <glguy> }!a
11:02:35 <pumpkin> really? I thought GHC wouldn't unpack polymorphic ones
11:02:38 <ddarius> It still would have been kind incorrect.
11:02:46 <glguy> I'm not saying it would have worked :)
11:02:51 <pumpkin> ah :)
11:08:11 <Berengal> Haskell makes project euler too easy...
11:08:39 <beelsebob> haha
11:08:43 <vixey> see how muc hyou can do without a programming language
11:09:16 <smtms> machine code is not programming language, but assembler is?
11:09:48 <vixey> smtms you can argue endlessly with people what is a 'programming language' and what isn't
11:09:49 <Gilly> i think vixey means paper/pen
11:10:35 <Baughn> If we had infinitely fast computers, would Bogosort still be a bad algorithm?
11:11:02 <Berengal> Baughn: If we had infinitely fast computers, algorithms would only differ in the result they produced
11:11:14 <smtms> if we had infinitely fast computers we would be simulating the universe
11:11:23 <Baughn> smtms: Nah. Not enough memory.
11:11:34 <Baughn> Berengal: And.. true, I guess, but there's a certain.. lack of elegance
11:11:38 <mads-> I have to find prime factors of a big number - what is the pref. way of doing so?
11:12:00 <Baughn> Then again, in a sense "try all permutations, check for sortedness" is a very elegant algorithm, isn't it?
11:12:13 <Baughn> mads-: How big are we talking about here?
11:12:31 <vixey> Baughn it's a good /specification/
11:12:36 <Berengal> Baughn: In the "describes the problem pretty neatly" it is
11:12:38 <kpreid> mads-: http://en.wikipedia.org/wiki/Integer_factorization#Factoring_algorithms
11:12:49 <mads-> Baughn : 6*10^10
11:12:53 <Berengal> When you've got infinitely fast algorithms, the specification is often enough
11:12:56 <vixey> Baughn, if you can execute specifications in negligible time -- why not?
11:13:01 <Baughn> vixey: Sure, and if you can execute the specification directly..
11:13:10 <Baughn> Mmh
11:13:16 <vixey> this is the aim of prolog
11:13:21 <vixey> or one of ,,
11:13:25 <Baughn> Heck, with that amount of power we could brute-force AI. There's an algorithm that's known to work..
11:13:38 <vixey> Baughn, oo what algorithm?
11:13:48 <jedai> smtms: I guess we would be busy creating new universes (since the only way we could have infinitely fast computer would be if they worked with different law of physics that those in our universe)
11:14:05 <Baughn> vixey: I.. don't quite remember the details, but it basically amounted to trying every permutation
11:14:17 <Baughn> vixey: Still, that wouldn't just be a smart AI, it'd be an /optimally/ smart AI. Scaree.
11:14:35 <Berengal> I think you have to define AI
11:14:51 <vixey> Baughn I bet you could think of much scarier thinsg to do with infinite computing power though :p
11:15:05 <kpreid> Baughn: That's AIXI, right?
11:15:28 <Baughn> kpreid: Ah, right. Thanks
11:15:36 <Berengal> What good is infinite computing power... if all you have is a completely pure language?
11:15:44 <Baughn> vixey: Solomonoff induction
11:16:02 <Baughn> Berengal: Well, it might be possible to take over the universe with it
11:16:09 <kpreid> Berengal: I would argue that said computing power does not exist, in that condition
11:16:13 <Baughn> Berengal: If you simulate your own universe, down to and including the computer
11:16:20 <Berengal> Baughn: How so? There's no IO...
11:16:28 <Baughn> Berengal: Then all of a sudden the chance that you're in a simulated universe becomes 1
11:16:36 <Baughn> Well. ~1
11:16:39 <Berengal> Actually, haskell emulates this pretty well... If there's no IO, nothing's calculated
11:16:52 <p_l> Berengal: There are other ways to have IO in pure functional language than monads etc.
11:17:16 <Berengal> p_l: I didn't say there shouldn't be monads. Monads are pure. The IO monad isn't...
11:17:17 <Baughn> And assuming the recursive calculation would /eventually/ converge, whatever you do to your computer is also done by the people operating the computer on the level above you, thus you control the universe
11:17:24 <vixey> p_l: oh what are they?
11:17:34 <p_l> vixey: you can always try message passing? :)
11:17:35 <Baughn> vixey: Streams
11:17:45 <vixey> message passing in a pure fp ...?
11:17:54 <Baughn> Lazy IO, basically. ;)
11:18:03 <p_l> vixey: Erlang does it this way. Streams are another way
11:18:11 <ddarius> p_l: Erlang is not pure.
11:18:18 <Berengal> Erlang isn't pure. Neither is message passing..
11:18:31 <p_l> Then I'm in error. Still, seemed nice method :)
11:18:41 <Baughn> But let's assume there's no communication whatsoever
11:18:44 <EvilTerran> Baughn, http://qntm.org/?responsibility :)
11:18:55 <Baughn> EvilTerran: Thanks. Yes, that was my inspiration. :)
11:18:58 <Berengal> You could have pure message passing in a monad though... probably...
11:19:01 <Baughn> Berengal: Read that link - you get to do that. :D
11:19:16 <p_l> though I guess if you don't have external world to communicate with, you could get by without IO :P
11:19:31 <Berengal> Baughn: I have. However, with an infinitely fast computer, the simulation would be over the second it started.
11:19:47 <Berengal> Sort of like lazyness...
11:19:49 <Baughn> Berengal: Not if you manipulate the computer so it isn't
11:19:56 <Baughn> You can presumably tell it to wait for input
11:20:09 <Berengal> You can't if there's no IO...
11:20:15 <Baughn> The program does no IO
11:20:20 <Baughn> The OS it's running on sure does. ;)
11:20:24 <pumpkin> is there a pdf-reading lib for haskell?
11:20:30 <Berengal> delayThread is IO...
11:20:34 <Baughn> Berengal: But actually, you don't need to do that
11:20:56 <Berengal> Baughn: Surely any other function would be done calculating the instant it was started...
11:21:15 <p_l> what about infinite loops?
11:21:16 <p_l> ;-)
11:21:21 <Baughn> Berengal: You can simulate a universe almost exactly identical to yours, except that there's a control panel for the universe inside it that pops up the moment after the simulation inside that universe again starts
11:21:26 <cristi_ceata> what does concatMap exactly do?
11:21:35 <Baughn> Berengal: Then, the moment you start the simulation, a control panel will pop into existence behind you.
11:21:35 <pumpkin> concat . map
11:21:35 <EvilTerran> ?src concatMap
11:21:35 <lambdabot> concatMap f = foldr ((++) . f) []
11:21:38 <pumpkin> slightly more efficiently
11:21:50 <vixey> cristi_ceata: concatMap f = concat . map f
11:21:58 <EvilTerran> concatMap f [] = []; concatMap f (x:xs) = f x ++ concatMap f xs -- also equivalent
11:22:03 <Baughn> Berengal: (Of course, it turns out that the universe was in fact /exactly/ identical to yours, but you couldn't know that.. well, okay, you could)
11:22:06 <kpreid> > map (\x -> [x, x + 1]) [1,2,3]
11:22:07 <lambdabot>   [[1,2],[2,3],[3,4]]
11:22:11 <kpreid> > concatMap (\x -> [x, x + 1]) [1,2,3]
11:22:12 <lambdabot>   [1,2,2,3,3,4]
11:22:25 <Baughn> Berengal: There's one person on the very top of the stack who doesn't get a control panel, but he's outnumbered infinity to one
11:22:27 <burp_> lets build an even fast computer
11:22:29 <Berengal> Baughn: Infinite computing power is paradoxical... It makes my brain hurt
11:22:34 <b_jonas> Baughn: do you mean this? http://qntm.org/?responsibility
11:22:39 <burp_> you get the response before you put data into it
11:22:46 <Baughn> b_jonas: Yes, thank you, you're the second one to point it out. :P
11:22:50 <Berengal> Baughn: It would totally suck if it turned out you were that one guy though ;)
11:22:52 <EvilTerran> b_jonas, i linked that a few minutes ago :P
11:22:52 <Baughn> Berengal: And go read it. ;)
11:23:06 <Baughn> Berengal: But you wouldn't be
11:23:20 <Berengal> Baughn: At least one of me would be
11:23:31 <Baughn> Berengal: He doesn't count. He has measure zero.
11:23:41 <Berengal> Baughn: I'm sure I'd disagree :P
11:23:50 <Baughn> Berengal: I'd never know
11:23:55 <Gilly> Baughn: this is a great thought experiment :) you invented it or is there more to it? :P
11:23:57 <b_jonas> oh
11:24:02 <b_jonas> sorry
11:24:02 <Baughn> Gilly: http://qntm.org/?responsibility
11:24:13 <Gilly> thanks
11:24:17 <Baughn> Gilly: Although the internal control panel is my invention
11:24:18 <Berengal> If I turned out to be on top, I'd probably be pissed off enough to shut down the simulation...
11:24:29 <Baughn> Gilly: It solves the issue they discover in the very end. ;)
11:24:30 <Gilly> :D
11:24:45 <Baughn> Berengal: The simulation would already be over, though. Infinite speed, remember?
11:25:03 <Berengal> Baughn: Stop making sense in a paradoxical universe!
11:25:23 <Baughn> Berengal: There aren't even any paradoxes here, though. ::P
11:25:41 * PeakerWork wonders what monads are doing in the C code's shift-rights he's looking at
11:25:42 <burp_> "You knew for a fact: this thing could execute an infinite loop in less than ten seconds."
11:25:43 <burp_> lol
11:26:01 <Berengal> print . last $ iterate simulate newWorld
11:26:02 <burp_> "Brute force primality testing of every single integer in existence? Easy. Pi to the last digit? Piece of cake." :D
11:26:13 <PeakerWork> print . last . iterate simulate $ newWorld
11:26:24 <Baughn> PeakerWork: It'd never finish
11:26:36 <Baughn> PeakerWork: However, after even a single second it'd have run through an infinite number of states
11:26:44 <Baughn> It's just, infinity doesn't /end/
11:26:45 <PeakerWork> Baughn: just nicing up the dot/$ notation of Berengal
11:26:52 <Berengal> print . last . takeWhile (not.heatDeath) . iterate simulate $ newWorld
11:26:56 <skorpan> can lambdabot somehow show me the instance of Foldable for []?
11:27:09 <Baughn> Berengal: Probably wouldn't finish either, what with there being an internal control panel now. :P
11:27:23 <PeakerWork> Berengal: spaces around dots, or they might be confused for module-attributes when you use constructors on the left side
11:27:26 <Baughn> @src Foldable ([])
11:27:26 <lambdabot> Source not found. Where did you learn to type?
11:27:28 <Baughn> @src Foldable []
11:27:28 <lambdabot> Source not found. It can only be attributed to human error.
11:27:31 <Berengal> Baughn: Of course it'd finish. Infinite computing power, remember :)
11:27:34 <Baughn> skorpan: Occasionally. But not this time.
11:27:51 <skorpan> cool
11:28:02 <Baughn> Berengal: Still wouldn't finish. There'd always be more to go, even if it had already done an infinite amount.
11:28:03 <Berengal> skorpan: probably "foldr = Data.List.foldr"
11:28:13 <adityam> @pl fold' f a b = foldr f b a
11:28:13 <lambdabot> fold' = flip . foldr
11:28:16 <Baughn> Berengal: The "infinite loop in less than ten seconds" thing is, what shall we say, "hyperbole".
11:28:32 <burp_> ppl.. talking about infinity is useless :p
11:28:36 <burp_> like this..
11:28:50 <skorpan> Berengal: you're right...
11:28:56 <Berengal> Baughn: The OS probably has a failsafe built in: If a program is running it's in an infinite loop and needs to be killed...
11:28:58 <Baughn> Berengal: However, you could run through an infinite proof in a second and get a correct answer. Yes, the proof wouldn't be done, but.. if it turned out to be false, you'd never know. You'd never get that far.
11:29:12 <Baughn> Berengal: (Which is to say, it'd be a correct proof for anything you could ever try)
11:29:26 <Baughn> ..well, unless you start another infinitely fast machine to countercheck. Now that would be fun.
11:29:37 <Baughn> Berengal: *ROFL*
11:29:54 <Baughn> @quote Berengal [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
11:29:55 <lambdabot> No quotes match. My pet ferret can type better than you!
11:30:00 <Baughn> @remember Berengal [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
11:30:00 <lambdabot> It is forever etched in my memory.
11:30:43 <Baughn> Berengal: Actually, I suspect the answer depends on the exact physics that seem to allow infinite computations
11:30:51 <D_Traka> http://www.myspace.com/tetrapakbeats
11:31:14 <vixey>  -NickServ- D_Traka is not registered.
11:31:25 <vixey> how about making #haskell required registration?
11:31:46 <ddarius> vixey: My nick is not registered.
11:31:51 <mauke> not enough benefits IMHO
11:31:53 <Berengal> Baughn: Apperture science portal gun physics
11:31:53 <Procy0n> mine neither
11:31:57 <sw17ch> vixey, #haskell should have a low amount of effort for entry
11:31:59 <vixey> you should reg ddarius
11:32:01 <sw17ch> it's what hooked me :)
11:32:06 <vixey> someone could steal it
11:32:10 <Baughn> Berengal: Those don't allow infinite speed computations
11:32:19 <Procy0n> vixey: someone already stole it
11:32:30 <Berengal> Baughn: They allow timetravel...
11:32:36 <Procy0n> not feeling like having another nick, though, I've been using this for 9 years, everywhere
11:32:54 <Berengal> Baughn: Or actually, they create a paradox in physics as wel know it. We will never know what they can do
11:33:01 <Berengal> we*
11:33:03 <vixey> what does Procy0
11:33:05 <vixey>  n mean?
11:33:07 <Baughn> Berengal: That's wormholes
11:33:29 <ddarius> @wn procyon
11:33:29 <Baughn> Berengal: And wormholes don't allow infinite-speed computation. THey might allow very high speed, but not infinite; trying would collapse the wormhole
11:33:29 <lambdabot> *** "Procyon" wn "WordNet (r) 2.0"
11:33:29 <lambdabot> Procyon
11:33:29 <lambdabot>      n 1: the brightest star in Canis Minor
11:33:29 <lambdabot>      2: the type genus of the family Procyonidae: raccoons [syn: {genus
11:33:29 <lambdabot>         Procyon}]
11:33:45 <Berengal> Baughn: Portals need to be wormholes...
11:34:01 <Procy0n> :P
11:34:06 <Berengal> Baughn: And infinite computing can be done by sending the computer back in time repeatedly
11:34:32 <Baughn> Berengal: That's just it, you can't do that. Wormholes have a finite throughput depending on the amount of negative mass in them.
11:34:51 <burp_> lol
11:34:56 <Berengal> Baughn: Okay, so portals are wormholes without that restriction...
11:34:57 <burp_> wormhole experts now
11:35:03 <Berengal> It's magic!
11:35:20 <burp_> because human wormhole knowledge is so great
11:35:45 <vixey> are wormholes real?
11:35:53 <skorpan> where can i find out what TH makes out of the following? $(derive makeFoldable ''MyType)
11:35:53 <vixey> I saw them in a lot of sci  fi
11:36:08 <Baughn> vixey: Maybe
11:36:08 <burp_> vixey, nope
11:36:15 <adityam> @pl f a b = g c b a
11:36:15 <lambdabot> f = flip (g c)
11:36:16 <burp_> theoretical
11:36:18 <ddarius> skorpan: Just execute derive makeFoldable ''MyType and see what the output is.
11:36:25 <dolio> How come IntMap doesn't have insertWith'?
11:36:34 <Baughn> vixey: Large wormholes would be too unstable to exist, /unless/ negative matter exists
11:36:37 <skorpan> ddarius: how do i "execute" TH?
11:36:37 <Berengal> burp_: Theoretical doesn't mean not real...
11:36:38 <Baughn> s/matter/mass/
11:36:40 <Baughn> Which it might
11:37:13 <burp_> Berengal, then _everything_! is possible
11:37:17 <ddarius> skorpan: I didn't say execute TH, just execute derive.  It's just a function.
11:37:19 <burp_> you can say maybe to everything then
11:37:23 <skorpan> ddarius: oh!
11:37:31 <Baughn> vixey: Very small ones can get that through the casimir effect; in fact, some physicists suggest that planck-scale spacetime might be a seething mass of wormholes
11:37:37 <skorpan> ddarius: sorry about that, i don't know any TH really
11:37:41 <Baughn> vixey: ..there's no evidence for that yet
11:37:48 <Baughn> (And some against)
11:37:49 <Berengal> burp_: Only to things that can be, but haven't been, disproved
11:37:51 <burp_> just because some equations spit out the possibility for wormholes..
11:38:05 <vixey> seething mass of wormholes -- sounds lovely
11:38:11 <edwardk> dolio: random omission?
11:38:31 <burp_> even maths has basic axioms
11:38:34 <burp_> what if they are wrong?
11:38:39 <dolio> Could be. How are your maps now? Are they competitive with IntMap?
11:38:49 <dolio> And do they have insertWith'? :)
11:38:52 <Berengal> Math axioms can't be wrong. They aren't physical constructs
11:38:53 <Baughn> burp_: Axioms don't have truth value
11:38:55 <edwardk> dolio: not really, IntMap kicks my butt actually =)
11:39:00 <burp_> thats the point!
11:39:02 <Baughn> burp_: They aren't "wrong", or "right" for that matter
11:39:03 <edwardk> I'm faster than Map though generally
11:39:04 <ddarius> Baughn: Sure they do, True.
11:39:08 <Berengal> Physics isn't math though.
11:39:17 <kadaver> im pissed off i never figured out how to play an mp3 in haskell
11:39:22 <Baughn> ddarius: Not last I checked
11:39:26 <burp_> if they are not wrong or right how can the stuff build on them be right or wrong?
11:39:29 <kadaver> i really need to get ubuntu going to get rid of allt his bull
11:39:30 <edwardk> putting together a nice ternary search tree right now, so i can unbox it
11:39:32 <burp_> they can be right or wrong based on the axioms
11:39:34 <dolio> Axioms are true, because they're taken to be so. :)
11:39:34 <Baughn> Some sets of axioms might turn out to be inconsistent, but that's something else again
11:39:37 <Baughn> burp_: It can't
11:39:46 <Berengal> Baughn: math axioms are whatever truth value is convenient for the theorem you're trying to prove
11:39:47 <Baughn> burp_: Math is a huge set of logical necessity built on nothing at all
11:40:02 <Baughn> burp_: To /use/ math, you have to decide which axioms are actually true /in the physical system you're describing/
11:40:10 <burp_> you see
11:40:10 <edwardk> that and because i needed it inside the monoid lib
11:40:22 <Berengal> Baughn: s/physical/logical/
11:40:29 <edwardk> so now i'm somewhat torn since there are a bunch of methods that get better signatures when using a reducer when i'm working wiht a trie
11:40:36 <Baughn> Berengal: I hesitate to call that "using math"
11:40:58 <edwardk> but which wouldn't really fit in the adaptive-containers lib with the uber-generalized signature
11:41:06 <Baughn> Berengal: "Building further on math", maybe, but any purely logical system has by definition no usefulness in real life. Not until you decide it maps well to something real
11:41:19 <Berengal> Baughn: "use" as "physics", sure. Not "use" as in "Computer science" though
11:41:19 <dolio> edwardk: I was going to do a generalized trie type map class to test with jberryman's trie benchmark, but not having insertWith' in IntMap might hurt me, since that will make the structure lazy, which people seem to want to avoid.
11:41:34 <Baughn> Berengal: Then it's not purely logical anymore, now is it? :P
11:41:38 <edwardk> jberryman: has a trie benchmark?
11:41:52 <edwardk> er s/://
11:41:55 <burp_> can you prove the eclid norm equals the real length in our world?
11:41:58 <gwern> @seen nomeata
11:41:59 <lambdabot> I saw nomeata leaving #xmonad, #haskell and #darcs 2m 26d 20h 1m 21s ago, and .
11:42:03 <burp_> is it of use for us then?
11:42:06 <edwardk> burp: i hope not ;)
11:42:22 <Baughn> burp_: You can't prove /anything/ in real life
11:42:29 <gwern> @ask nomeata re darcswatch 'http://darcs.net/ 7342 patches in inventory 1120 tracked 467 applicable 46 obsolete 4 rejected ' <-- there's no way I could possibly go through all of'em, could you mark'em all obsolete?
11:42:29 <burp_> thats what I want to say
11:42:29 <lambdabot> Consider it noted.
11:42:33 <Baughn> burp_: Though I could show that euclidian geometry is a good approximation ;)
11:42:33 <gwern> @flush
11:42:35 <edwardk> burp: the scientific method can never prove anything
11:42:41 <ddarius> People don't match math up to reality, they model reality with mathematical structures.  This does not really require the axioms to be sensible physically (and from all appearances they aren't)
11:42:43 <burp_> Baughn, that for sure
11:42:45 <Berengal> burp_: You can only disprove, which is good enough for me
11:42:46 <dolio> edwardk: I think it's him. He's been fooling with implementing a regular old list trie. But he started using Data.Map for each level, which is probably bad, since I assume he's using it on Strings.
11:42:52 <burp_> same.
11:43:08 <Baughn> Berengal: You can't even do that; the experiment you use to disprove it may be flawed, or you may be
11:43:11 <vixey> edwardk, I'm not sure about that, I mean you are proving things beyond reasonable doubt rather than _proving_mathematically
11:43:13 <edwardk> dolio: yeah, i'm using a ternary search tree, and then plan to add path compression
11:43:23 <Baughn> Berengal: You can disprove it to beyond reasonable doubt, sure. Or prove it, same
11:43:30 <burp_> I think euclid tried to prove it himself.. if I remember correct
11:43:35 * vixey hi fives Baughn :p
11:43:38 <burp_> at least withing some error range
11:43:40 <dolio> And people have proposed alternate stuff, like using unbalanced search trees for the base map, but no one just stuck in Data.IntMap.
11:43:59 <burp_> or wait.. it was the angular sum in a triangle he checked
11:43:59 <edwardk> vixey: you offer support for plausible reasoning, but a single irrefutable counterexample undoes a whole lot of plausibility ;)
11:44:06 <Baughn> Berengal: And this is why I say 0 and 1 aren't really real probabilities. :P
11:44:18 <Berengal> Baughn: Well, granted.... So you can say "this is false if this is true", but not much more than that
11:44:19 <vixey> edwardk: that's life!
11:44:31 <Baughn> Berengal: That's what math is all about
11:44:37 <ddarius> Why should we trust modus ponens?
11:44:39 <Berengal> Baughn: And then you just use what seems the most convenient (for a given value of convenient)
11:44:49 <Baughn> ddarius: ..please, don't start that one
11:44:55 <Baughn> Berengal: Yep
11:44:58 <vixey> ddarius: any finite application of modus ponens is fine :)
11:45:04 <Baughn> vixey: Prove it
11:45:25 <Baughn> vixey: <ddarius> Prove it
11:45:44 <edwardk> dolio: when i get done with the unboxing, the nice thing about the ternary search trie is that i can fold basically of the cases into the constructors and hide them behind views that are still fairly usable
11:46:23 <Baughn> Berengal: Of course, until recently physics had a tendency to outpace math, which confused the issue quite a bit
11:47:06 <Berengal> I could've been a physicist...
11:47:10 <Berengal> Or a mathematician
11:47:12 <Baughn> Berengal: People would think axioms were necessarily true, because they /discovered/ the axioms by looking at nature
11:47:23 <vixey> Berengal: but instead you ?
11:47:30 <Berengal> Computer scientist
11:47:31 <Baughn> Well, he's in #haskell..
11:47:47 <pumpkin> can parsec work with bytestrings easily?
11:47:50 <Gilly> Baughn: A funny thing about that thought experiment arises when you think what happens when you shutdown the simulation. And what if the topmost world restarts it?
11:47:53 <Baughn> pumpkin: Sure
11:47:59 <davidL> how does the speed of an IOUArray Int Word8 compare to ByteString?
11:48:01 <edwardk> pumpkin: i use them with parsec 3 all the time
11:48:07 <kadaver> @slap SPJ
11:48:08 * lambdabot activates her slap-o-matic...
11:48:10 <Baughn> Gilly: Then things get /weird/
11:48:11 <Berengal> CS is the middle ground between physics and math: Not too concerned with reality, yet still has practical consequences
11:48:14 <kadaver> @slap SPJ
11:48:15 <lambdabot> I'd rather not; SPJ looks rather dangerous.
11:48:19 <kadaver> @slap SPJ
11:48:20 <lambdabot> Come on, let's all slap SPJ
11:48:22 <kadaver> @slap SPJ
11:48:22 <Gilly> Baughn: Not so weird, just funny :)
11:48:23 <lambdabot> why on earth would I slap SPJ?
11:48:28 <Cale> Baughn: I still say 0 and 1 are as real as any other probabilities.
11:48:44 <Cale> Baughn: Also note that even if something is probability 0, it can happen.
11:48:48 <Baughn> Cale: The show up a whole lot less frequently
11:48:49 <pumpkin> hmm, it says I already have parsec installed
11:48:50 <Gilly> Baughn: 1) Easy to prove that if you shutdown the simulation you're the topmost node.
11:48:53 <pumpkin> but it's just parsec 2
11:48:55 <kadaver> @slap kadaver
11:48:55 * lambdabot submits kadaver's email address to a dozen spam lists
11:48:58 <Baughn> Cale: And by definition, no it can't. ;)
11:49:04 <Gilly> Baughn: Thus shutting down the simulation will give you the ultimate god-power :)
11:49:05 <vixey> Less frequently than 0.537874 ??
11:49:07 <pumpkin> should I go with that, or force an install of parsec 3?
11:49:20 <Cale> Baughn: No, it can. It just can't happen infinitely many times in infinitely many repeated trials.
11:49:21 <ddarius> Baughn: No, the definition does not say that.
11:49:30 <Cale> Well...
11:49:36 <Baughn> pumpkin: Wait, why are you still on parsec 1.x?
11:49:42 <edwardk> pumpkin install 3, its in the list of things that use an old crufty version by default
11:49:42 <Cale> The probability of that happening would be 0 ;)
11:49:51 <pumpkin> Baughn: I said 2 :o
11:49:58 <Baughn> Cale: You're a.. /frequentist/?
11:50:00 <pumpkin> Baughn: because that's what came with ghc I guess?
11:50:04 * Baughn pokes Cale 
11:50:08 <Cale> Baughn: huh?
11:50:21 <Cale> I'm just going by the usual definition of probability.
11:50:29 <Baughn> There are several. ;)
11:50:42 <Cale> Consider the uniform distribution on [0,1]
11:50:47 <Baughn> pumpkin: What ghc version is this?
11:50:53 <pumpkin> 6.10.2
11:50:54 <Cale> It assigns probability 0 to each individual real number.
11:51:07 <Baughn> pumpkin: That's odd. I've got that, but it came with 6.10.2
11:51:13 <Baughn> pumpkin: Er. 2.1.0.1
11:51:16 <pumpkin> yeah
11:51:19 <Gilly> Baughn: Then, when you restart the simulation, following happens: Simulation proceeds all way to the starting of first simulation and shutting down it. After shutting down it the topmost world and second topmost world are still alive in the second run. Then the simulation proceeds to restarting the simulation and the same recurses to third node and so on.
11:51:20 <pumpkin> that's what I have :P
11:51:26 <Cale> But of course, this doesn't mean that no real number in [0,1] will ever come out of it :P
11:51:48 <Cale> It just means that for any given real number, you can't really expect it to come up.
11:52:06 <cristi_ceata> A question in "Yet another haskell tutorial" sounds like: http://www.moonpatio.net/fastcgi/hpaste.fcgi/view?id=2161#a2161 I can't  see the answer. A little help, please?
11:52:20 <Cale> Baughn: Does that make sense?
11:52:30 <Baughn> Cale: Yes.
11:52:39 <kadaver> haskore doesnt have a mailign lsit or #channel?
11:52:53 <kadaver> do you need any extra lib to actually playt he sound?
11:52:53 <Baughn> Cale: I think the confusion is that I was implicitly thinking of the probability-0 event as being from a /finite/ set of events
11:52:59 <edwardk> kadaver: i doubt it has enough users to justify a channel
11:53:26 <Baughn> pumpkin: Hm. NOw that I look, I can see it doesn't do bytestrings..
11:53:27 <Berengal> cristi_ceata: It uses (==)
11:53:38 <Cale> Baughn: Of course, even when it is a finite set of events, just saying that it's probability 0 shouldn't necessarily mean that it *can't* happen, just that you can't expect it to.
11:53:39 <pumpkin> Baughn: parsec 3 does
11:53:42 <pumpkin> that's why I just installed it :P
11:53:49 <Baughn> pumpkin: Right. Huh, I..
11:53:56 <Baughn> pumpkin: It's from mar 6 /2008/?
11:54:06 <Baughn> ..this is horrible
11:54:08 <pumpkin> yup
11:54:10 <pumpkin> why? what?
11:54:22 <Baughn> Well, why hasn't it been updated? :P
11:54:31 <ddarius> The darcs repo has some changes.
11:54:41 <Baughn> I mean, why doesn't ghc 6.10 use it?
11:55:02 <Cale> cristi_ceata: you're comparing x `mod` 2 with 0, so x `mod` 2 will need to be an instance of Eq, so x will need to be as well
11:55:16 <Baughn> Cale: Well, you'd have an infinite wait before it happens..
11:55:17 <ddarius> Baughn: There are performance regressions.
11:55:27 <Baughn> Hmm
11:55:37 <Cale> cristi_ceata: Also, Ord is a subclass of Eq, so if you want to write an instance of Ord, you'll always need to provide one for Eq too
11:55:39 <opqdonut> Num should contain a zero predicate :P
11:55:44 <Baughn> ddarius: Asymptotic ones?
11:55:52 <Cale> Baughn: Not *necessarily* -- it could happen on the first try.
11:55:57 <cristi_ceata> Berengal: where? on which line?
11:55:59 <Baughn> Cale: But it won't.
11:56:00 <ddarius> Baughn: I doubtit.
11:56:04 <Cale> Baughn: It's just, probability 0 that it will.
11:56:12 <Cale> Baughn: So you wouldn't expect it.
11:56:13 <Baughn> That's what I said
11:56:13 <Berengal> cristi_ceata: Line 7
11:56:34 <Cale> I think it's strange to identify probability 0 with impossible.
11:56:38 <Baughn> Cale: Are you sure the probability shouldn't be called infinitesimal instead of 0?
11:56:55 <Cale> I'm sure. Probabilities are real numbers, so they can't be infinitesimal.
11:57:10 <Baughn> In that case, what's the probability of an impossible event?
11:57:14 <opqdonut> 0
11:57:15 <Cale> Still 0.
11:57:16 <ddarius> 0
11:57:31 <vixey> you could do probability with hyperreals too though?
11:57:36 <Baughn> So you can't distinguish an impossible event from a not-quite-impossible one by looking at their probability?
11:57:37 <Cale> Probability can't distinguish impossible from things which are that unlikely.
11:57:41 <Cale> right
11:57:47 <ddarius> vixey: Presumably some system could be formulated.
11:57:49 <opqdonut> Cale: IIRC one can have random variables \Omega \to hyperreals
11:57:52 <Baughn> That is.. incredibly counterintuitive
11:58:01 <Cale> opqdonut: That would be interesting. :)
11:58:03 <ddarius> Baughn: Why?
11:58:10 <Baughn> And how do you get a prior of 0 anyway?
11:58:16 <opqdonut> as there is a borel-like measure for the hyperreals
11:58:20 <Cale> prior?
11:58:30 <ddarius> Baughn: If I have to wait an infinite amount of time to tell whether something will occur for sure, how can I tell that it isn't just impossible that it will occur.
11:58:51 <Baughn> ddarius: By waitning an infinite amount of time and checking
11:59:06 <cristi_ceata> Cale: but (x `mod` 2) is of type Int. isn't the class Eq already defined for Int ?
11:59:10 <burp_> !addbadword infinity
11:59:20 <Cale> cristi_ceata: Oh, yes it is.
11:59:26 <vixey> who needs infinite amount of time since time is divisible?
11:59:29 <Cale> cristi_ceata: So your problem is the other one I mentioned.
11:59:36 <kadaver> anyone know? can you somehow play a song without haskore-realtime?
11:59:49 <Cale> cristi_ceata: If you want an instance of Ord, you're *forced* to implement Eq by the subclass constraint.
11:59:56 <Baughn> kadaver: Sorry?
12:00:38 <Baughn> kadaver: Well, haskore outputs midi. You could always just.. feed it to another midi player?
12:00:53 <Cale> Baughn: However, there is one way in which you can express which things are truly impossible.
12:01:05 <Cale> Baughn: You can leave the points out of your probability space altogether.
12:02:02 <Cale> Then there's no confusion :)
12:02:02 <Berengal> Cale: Assigning each point a probability of 0 means the space must be continous, no?
12:02:09 <Cale> Well, yes.
12:02:18 <Berengal> So no nice :)
12:02:21 <Berengal> dice*
12:02:23 <opqdonut> Cale: sorry, i was wrong, we can have hyperreal-valued probabilistic variables but the measures (probabilities) are still real-valued
12:02:26 <Cale> Berengal: hm?
12:02:38 <Berengal> Cale: Dice aren't continous
12:02:44 <Cale> Berengal: ah
12:02:44 <opqdonut> Cale: in the usual case, there might be some work on hyperreal-valued measueres...
12:02:46 <Cale> Berengal: hehe
12:02:48 <Baughn> Berengal: You could map a dice to a continuous space just fine
12:02:57 <Baughn> Berengal: And then you could shrink one outcome to a single point
12:03:08 <Baughn> Berengal: And it'd /still/ happen after an infinite amount of time. Or it could, anyhow.
12:03:11 <Baughn> I think I get it now. :P
12:03:24 <Cale> Berengal: 'no dice' is also a common expression, which is why I was confused :)
12:03:41 <Berengal> Cale: I was going for the pun, I must admitt...
12:03:49 <Berengal> Although it didn't really make sense
12:03:57 <dolio> edwardk: Heh, Data.Map with insertWith' actually performs better than Data.IntMap with insertWith. :)
12:04:01 <Baughn> No dice for dice? ;).
12:04:09 <Cale> Berengal: I was unsure. I've been talking to lots of non-native English speakers lately, and funny things like that have been happening. :)
12:04:17 <ddarius> dolio: That doesn't seem surprising.
12:05:48 <Baughn> ddarius: It surprises me. Why doesn't it surprise you?
12:05:57 <jedai> Yeah, every Map alternative should have insertWith' or a way to write it easily, it's way too useful a function
12:06:03 <Berengal> Cale: I like to call it "Internet". It's like english, but without grammar, and with lots more ambiguity
12:06:10 <Cale> Baughn: Of course, if the probability is zero, then the probability of it occurring in infinitely many trials is still 0, you just can never completely rule it out from actually occurring.
12:06:12 <Baughn> I must admit, with type families added I'm half expecting someone to rewrite Map to use IntMap when appropriate
12:06:18 <Cale> Berengal: hehe
12:07:01 <jedai> Baughn: without insertWith', a whole lot of classic use of a Map have to build useless and wasteful thunks :)
12:07:39 <Baughn> jedai: For a truth. There should be a better way to strictify functions than explicitly writing strict versions..
12:08:10 <vixey> Baughn: I was thinking about a strict kind for a bit
12:08:24 <vixey> Baughn: it seemed okayish but I didn't bother to implement it and measure it
12:09:32 <jedai> Baughn: It's not so much the function as the structure we would like to strictify in this case... and there's no easy eficient way to do that (in fact it's worse than for a function)
12:09:43 <dolio> Baughn: In this case, the difference between insertWith and insertWith' is the difference between having a map whose structure is strict, and one whose isn't. And most finite maps seem to be strict in the keys/structure, if not the values.
12:09:58 <vixey> things like Int would have the strict kind insted of *
12:10:00 <dolio> For performance.
12:10:01 <b_jonas> the structure?
12:10:08 <vixey> so that sum :: [a] -> Int would be strict
12:10:39 <b_jonas> if the structure is abstract and all the functions accessing it are strict, then isn't the structure as good as strict?
12:10:39 <dolio> Yes, the tree structure is always fully evaluated, so long as the map is evaluated at all.
12:11:22 <jedai> b_jonas: Yes
12:11:53 <jedai> b_jonas: But in our case, all function to access the structure aren't stricts
12:12:02 <jedai> *strict
12:12:38 <dolio> A list trie looks like 'Map [k] v = Empty | Branch (Maybe v) (Map k (Map [k] v))'...
12:13:00 <dolio> So if Map k is not strict in its stored values (not just the keys), then your overall structure can have thunks in it.
12:13:38 <jedai> b_jonas: The structure is strict in the keys, but not in the values and there are a number of use where you really want to be strict in the value. strict insertion is a good alternative but isn't always available for every version of "Map"
12:14:01 <dolio> Branch whatever { k1 -> thunk, k2 -> thunk, ...} instead of Branch whatever { k1 -> evaluated_map, k2 -> evaluated_map, ... }.
12:14:48 <mads-> I have a function that need a list [1..]. This function returns 0 when it has found the correct number - how do I then stop the [1..] ?
12:15:03 <mauke> mads-: [1..] doesn't move. it cannot be stopped.
12:16:11 <adamvo> > takeWhile (<4) [1..]
12:16:13 <lambdabot>   [1,2,3]
12:16:35 <Berengal> mads-: You just don't bother reading any more numbers from it
12:20:38 <RayNbow> hmm, is # treated as something special in .lhs files?
12:20:52 <mauke> yeah, at least in column 1
12:21:08 <RayNbow> what does it mean?
12:21:15 <mauke> I don't know
12:21:21 <RayNbow> it isn't mentioned in http://www.haskell.org/onlinereport/literate.html
12:22:15 <RayNbow> ah
12:22:16 <stolenKadaver> woot haskore works and I can play the files
12:22:20 <RayNbow> http://hackage.haskell.org/trac/ghc/ticket/733
12:22:54 <stolenKadaver> but isnt there some Parsec-ish interface where you can just delcare the song? ie song = "C" >> "A" >> "C"; ?
12:24:43 <pumpkin> stolenKadaver: all notes have equal duration and strength then? ;)
12:24:53 <pumpkin> and you only get one octave?
12:25:43 <Berengal> stolenKadaver: This sounds like an interesting library... composing music through composing music monads...
12:25:44 <skorpan> what is the flag to pass to GHC if i want to "dump splices" generated by TH?
12:26:12 <Lemmih> skorpan: -ddump-splices?
12:26:50 <skorpan> thanks
12:28:42 <mib_wyxbms> good evening
12:29:33 <pumpkin> hello mr. mib
12:29:37 <pumpkin> or mrs. mib
12:31:28 <stulli> Lemmih: Arent you maintaining the dbus package on hackage?
12:33:16 <Kippetje> I have some problems with the IO monad, first I print "OK" and after that I run an external program from inside haskell, but when I look on the terminal I see first the output of the external program and after that my "OK"
12:33:23 <Kippetje> Is there a way to swap these around?
12:33:58 <Baughn> Kippetje: Try flushing after printing your ok
12:34:03 <skorpan> can lambdabot somehow unflip this?  "flip (foldr (flip (foldr f)))"?
12:34:14 <Baughn> @unpl flip (foldr (flip (foldr f)))
12:34:14 <lambdabot> (\ b c -> foldr (\ e g -> foldr f g e) c b)
12:34:19 <vixey> @@ @pl @unpl flip (foldr (flip (foldr f)))
12:34:20 <lambdabot>  flip (foldr (flip (foldr f)))
12:35:52 <Kippetje> http://pastebin.com/d415b293a
12:35:59 <Kippetje> how do i flush
12:36:49 <mle> see BufferMode in System.IO; if you're line buffered then just printing a newline does so
12:37:01 <Lemmih> stulli: Sure.
12:37:02 <mle> if you're making an ok-prompt, forthstyle then you'll need to flush midline
12:37:09 <mle> see System.IO.hFlush
12:37:43 <Berengal> System.IO.hFlush System.IO.stdout
12:40:17 <stulli> Lemmih: You dont happen to have some sort of tutorial for it? I didnt manage to do something useful with it.
12:41:10 <stulli> I basically tried to rewrite a python script which used dbus bindings in haskell
12:41:30 <brian6> if i'm in ErrorT E IO (), how to catch and translate an exception generated by something like writeFile?  'writeFile fp s `catchError` \_ -> throwError myError'?  not sure about liftIO or in which monad throwError would be happening.
12:41:44 <Lemmih> stulli: I don't think anyone knows how to use DBus.
12:42:43 <stulli> Lemmih: Ok, thanks. At least that means im not retarded :)
12:43:24 <skorpan> testi
12:43:29 <skorpan> god damnit...
12:43:38 <Lemmih> stulli: I asked around when I wrote the binding and was told that no one had a clear idea how the darn thing was intended to be used.
12:45:44 <Lemmih> They told me to look at the Python binding but not to take it too literally since it is completely wrong. /-:
12:46:02 <wli> http://wli.pastebin.com/m22911157 <-- fresh Grobner dirt, albeit still broken
12:46:53 <paolino> :t throwError
12:46:54 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
12:47:41 <Lemmih> Never have I seen such an important piece of software being so horribly broken as DBus.
12:48:11 <stolenKadaver> god it takes time to compile haskore stuff
12:48:34 <stulli> Lemmih: That doest sound very encouraging :(
12:48:37 <paolino> @src ErrorT
12:48:37 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
12:49:03 <stolenKadaver> pumpkin: well each function would thsoe as inputs i guess
12:49:13 <stolenKadaver> Berengal: thats what I thought haskore was
12:49:41 <Berengal> stolenKadaver: I have only a very vague idea of what haskore is...
12:50:17 <Lemmih> stulli: Don't let me get you down. I'm probably just ranting.
12:52:39 <mauke> :t foldr1 (printf "%g + (%s * x)")
12:52:40 <lambdabot> forall a. (PrintfType a, PrintfArg a) => [a] -> a
12:53:27 <Baughn> > foldr1 (printf "%g + (%s * x)") [1,2,3,4]
12:53:28 <lambdabot>   Add a type signature
12:53:32 <Baughn> > foldr1 (printf "%g + (%s * x)") [1,2,3,4] :: String
12:53:33 <lambdabot>       No instance for (Num String)
12:53:33 <lambdabot>        arising from the literal `1' at <in...
12:53:37 <mauke> don't bother, it's wrong
12:53:46 <Baughn> I was pretty sure it would be, but I just had to try
12:53:57 <mauke> > foldr (printf "%g + (%s * x)") "0" [1 .. 4]
12:53:59 <lambdabot>   "* Exception: Printf.printf: bad argument
12:54:12 <stulli> Lemmih: I was thinking about making these bindings myself, but i dont think thats possible with my limited experience in Haskell/FFI/DBus/C...
12:54:24 <Baughn> According to that type the return value has to be the same type as the argument. I suppose.. hmm, I wonder
12:54:27 <kristofer> I just compiled ghci 6.10.2 and I don't have tab completion anymore.. must I do something special to get it back?
12:54:31 <mauke> > foldr (printf "%g + (%s * x)") "0" [1.0 .. 4]
12:54:32 <lambdabot>   "1.0 + (2.0 + (3.0 + (4.0 + (0 * x) * x) * x) * x)"
12:54:42 <Baughn> > foldr1 (printf "%s") ["foo","bar"]
12:54:43 <lambdabot>   "foo* Exception: Printf.printf: formatting string ended prematurely
12:54:50 <Baughn> > foldr1 (printf "%s x %s") ["foo","bar"]
12:54:51 <lambdabot>   "foo x bar"
12:54:55 * Baughn blinks
12:55:17 <chrisdone> :t printf
12:55:18 <lambdabot> forall r. (PrintfType r) => String -> r
12:55:41 <Baughn> chrisdone: It's an Evil Hack of dimensions
12:55:44 <Baughn> Evil dimensions.
12:55:46 <chrisdone> @src foldr1
12:55:46 <lambdabot> foldr1 _ [x]    = x
12:55:46 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
12:55:46 <lambdabot> foldr1 _ []     = undefined
12:56:00 <mauke> now the only problem is that showGFloat is broken
12:56:27 <mauke> fuck
12:56:43 <chrisdone> > (printf "%s x %s" "foo") "bar"
12:56:44 <lambdabot>   Add a type signature
12:56:52 <chrisdone> well, I get it, anyway
12:56:55 <mauke> > ""++ (printf "%s x %s" "foo") "bar"
12:56:56 <lambdabot>   "foo x bar"
12:57:04 <chrisdone> yeh
13:01:04 <stolenKadaver> how do I force a print statement to not be done until some other stuff is done?
13:01:19 <stolenKadaver> runCommand blah; print "done";
13:01:23 <stolenKadaver> prints done first...
13:01:35 <mauke> no, it doesn't
13:01:37 <edwardk1> is the command like an hGetLine or something?
13:02:08 <cYmen> Where can I find docs about the usage of "in"?
13:02:20 <mauke> the haskell report
13:02:21 <kpreid> cYmen: it is part of the syntax of "let"
13:02:31 <cYmen> kpreid: thanks
13:04:54 <ddarius> > 10e-4 * 22000
13:04:55 <lambdabot>   22.0
13:05:11 <ddarius> > 10e-4 * 22000 * 0.8
13:05:12 <lambdabot>   17.6
13:05:24 <ddarius> > 10e-4 * 20500 * 0.8
13:05:25 <stolenKadaver> main = do
13:05:25 <stolenKadaver>   runCommand "ghc --make -O2 -main-is Snippet.main Snippet.hs"
13:05:25 <stolenKadaver>   runCommand "Snippet.exe"
13:05:25 <stolenKadaver>   print "Done."
13:05:25 <lambdabot>   16.400000000000002
13:05:38 <mauke> I wish haskell had multiline string literals
13:05:43 <ddarius> Stupid orders of magnitude.
13:05:46 <stolenKadaver> that tries to run Snippet.exe before it compiels it, or at least it tries to run it before compilation finishes
13:06:02 <ddarius> mauke: Use some quasiquoting TH stuff.  Someone already wrote it somewhere.
13:06:30 <mauke> stolenKadaver: waitForProcess
13:06:38 <gnuvince_> Is there a reason why it's considered "bad style" to define an operator that's just flip (.)?
13:06:45 <mauke> stolenKadaver: or just use system in the first place
13:06:55 <ddarius> gnuvince: It isn't considered bad style.
13:07:02 <mauke> ddarius: too complicated
13:07:07 <ddarius> (>>>) already is flip (.)
13:07:16 <ddarius> (For the (->) of Arrow)
13:07:18 <b_jonas> @type (>>>)
13:07:19 <Berengal> mauke: you can use \<whitespace>\ in string literals to make them span over several lines
13:07:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
13:07:24 <b_jonas> @type flip (.)
13:07:25 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
13:07:30 <mauke> Berengal: yes, and it's extremely ugly
13:07:38 <gnuvince_> ddarius: it isn't?  I seem to recall somebody saying something like that on reddit
13:07:52 <mauke> "foo\n\    \bar" instead of "foo    bar"
13:08:31 <Berengal> mauke: I sort of like it. Makes it possible to line them up without worrying about extra whitespace in the beginning... This is something I wish I had in python for example
13:09:09 <bos> @seen gigamonkey
13:09:09 <lambdabot> I haven't seen gigamonkey.
13:10:45 <stolenKadaver> mauke: how use syetm?
13:12:38 <b_jonas> Berengal: can't you have the equivalent of unlines ["foo", "bar"] in python?
13:13:15 <Berengal> b_jonas: Sure you can, '\n'.join(lines)
13:13:18 <b_jonas> Berengal: or just write it continuously in a multi-line string then strip the indents with a function
13:13:22 <Berengal> I was talking about multiline string literals
13:14:09 <Berengal> b_jonas: What I miss is being able to have indents if I want it, but only when and where I want it
13:14:19 <cYmen> Is there a rule that common words cannot be used as infix operators?
13:14:24 <Berengal> In haskell I can go "foo\n\   \    bar"
13:15:00 <Berengal> cYmen: If you're talking about keywords... you can't redefine keywords
13:15:39 <stolenKadaver> whyd eosnt ghc --make -O2 -main-is Test.main Test.hs produce an exe?
13:16:06 <cYmen> I tried defining (>>) as (foo) and the latter didn't work. That's why I'm asking.
13:17:01 <b_jonas> cYmen: in haskell syntax, punctuation words are always infix operators and alphanumeric words are never
13:17:07 <b_jonas> it's not like standard ml
13:17:14 <Berengal> cYmen: Well, there's operators and there's regular names... Operators are infix by default, but can be made prefix with parenthesis. Names can be made infix with `foo`
13:17:50 <Elly> stolenKadaver: it produces a file called 'Test' which is an executable binary here
13:17:51 <b_jonas> or wait, did you try to define '(>>) = foo' at top-level, which failed because you already had a name (>>) imported from Prelude
13:17:55 <b_jonas> ?
13:18:35 <cYmen> b_jonas: No, I tried to define foo as infix by using (foo) but I should have used `foo`, right?
13:18:45 <Berengal> cYmen: yes
13:19:04 <Berengal> > let a `foo` b = a + b in 5 `foo` 6
13:19:05 <lambdabot>   11
13:19:05 <cYmen> Do I have to use the backticks when I call it?
13:19:19 <b_jonas> cYmen: yes
13:19:19 <Berengal> cYmen: Only if you call it infix
13:19:22 <cYmen> k :)
13:19:31 <Berengal> > let a `foo` b = a + b in 5 `foo` (foo 6 7)
13:19:32 <lambdabot>   18
13:19:32 <b_jonas> cYmen: you can't just make an identifier infix like you can in sml
13:19:42 <cYmen> b_jonas: I don't know sml. What is that?
13:19:50 <b_jonas> cYmen: never mind then
13:20:03 <cYmen> But I want to know now. :)
13:20:07 <Berengal> sml is another functional language, not too different from haskell
13:20:11 <b_jonas> the point is, you can use any name as either infix or normal anywhere,
13:20:21 <cYmen> Oh, ok
13:20:24 <b_jonas> but if you use an alphanumeric as infix, you need backticks,
13:20:34 <b_jonas> and if you use a punctuation as normal, you need parens.
13:20:55 <cYmen> ok
13:21:00 <cYmen> thanks
13:21:10 <b_jonas> you can decide separately every time you use a name (whether in a pattern or an expression or a type) which way you use it
13:21:20 <b_jonas> sml is by the way better known as standard ml
13:21:45 <Berengal> Sml was messing with my mind with it's strict semantics...
13:22:40 <stolenKadaver> how I could ever hold Python over Haskell, that is a real riddle
13:22:58 <stolenKadaver> its this simple
13:23:01 <Athas> Useful for different things.
13:23:11 <stolenKadaver> if the world doesnt start adopting haskell, then i will conquer it
13:23:18 <b_jonas> Berengal: why? the strict semantics are quite simple
13:23:40 <mauke> b_jonas: but hard to think about
13:23:42 <Athas> SML is a great language because it's so simple and predictable.
13:23:56 <b_jonas> mauke: dunno, I worked a lot with strict semantics so I'm used to it
13:24:02 <mauke> b_jonas: you can't just "eta cancel" trailing arguments, for example
13:24:06 <Athas> Not really.  SML is close to being the functional language least fixed point!
13:24:06 <Berengal> b_jonas: Yes, but I had been studying haskell almost continuously for the last two months
13:24:12 <b_jonas> mauke: yes
13:24:25 <mauke> that requires a minor brain rewiring
13:24:32 <b_jonas> Athas: yes, I call it the "flavorless" functional language
13:24:37 <b_jonas> no, it's haskell that requires that
13:24:54 <mauke> no
13:24:56 <b_jonas> just like how scheme is the flavorless dynamically typed functional language
13:25:00 <mauke> in Haskell everything is normal
13:25:03 <Athas> b_jonas: That makes it useful for illustrating fundamental aspects of functional programming, however.
13:25:11 <b_jonas> Athas: exactly
13:25:20 <b_jonas> but not necessarily for writing real programs
13:25:25 <Athas> Right, I agree.
13:25:46 <mauke> I can just pull a subexpression out into a 'let' bound name or function parameter, and the whole thing still works
13:25:51 <mauke> requires no thinking
13:26:19 <Berengal> mauke: You can't do that in sml?
13:26:26 <mauke> no
13:26:34 <Berengal> modulo side-effects, I mean...
13:26:44 <mauke> that's a very big modulo
13:26:48 <b_jonas> yup
13:26:49 <Athas> The only "exotic" feature in SML is the functor concept (which is admittedly cool), while Haskell is nothing but exotic features!
13:26:55 <b_jonas> it's quite common that it's not possible
13:27:16 <b_jonas> exotic is relative
13:27:24 <monadic_kid> you guys are aware of sML? not SML
13:27:38 <Cale> monadic_kid: huh?
13:27:40 <Berengal> b_jonas: I know I'd have a hard time inserting side-effects willy-nilly in a functional language these days...
13:27:40 <b_jonas> by the way, I think haskell has a better syntax than sml
13:27:51 <mauke> OCaml example: 'try foo () with bar' is very different from 'let x = foo () in try x with bar'
13:27:57 <Athas> I care very little for both SML's and Haskell's syntax.
13:27:58 <monadic_kid> yes i'm mean sML not sml/SML
13:27:59 <Elly> b_jonas: welcome to the world's largest club :P
13:28:11 <monadic_kid> successorr-ml
13:28:33 <b_jonas> Berengal: it's not just that, quite often the exception you'd pull out would raise an exception or fall into an infinite loop but only when you wouldn't refer to its value
13:28:39 <vixey> we should spec out successor haskell
13:28:55 <monadic_kid> vixey; wha's hasell' then?
13:29:00 <vixey> don't ask me
13:29:06 <Elly> we can call it (1+) $ Haskell
13:29:07 <mauke> is there a simple text replacement function in the libraries?
13:29:09 <Berengal> b_jonas: Yes, I see now... took a few minutes to switch my brain into strict mode :P
13:29:19 <monadic_kid> i mean haskell'
13:29:43 <b_jonas> Elly: Prelude has succ
13:30:05 <b_jonas> Berengal: of course if you really want, you can always use a function with a dummy unit argument
13:30:06 <Elly> b_jonas: succ $ Haskell, then, to be appropriately haskellish :)
13:30:14 <b_jonas> Elly: why the dollar?
13:30:31 <b_jonas> mauke: someone just asked that
13:30:31 <Elly> $ is one of the things I miss the most when I program in SML
13:30:45 <Berengal> I though Haskell's goal was to avoid success(ors) at all cost?
13:31:04 <Elly> fortunately $ is easily reimplemented
13:31:08 <b_jonas> Elly: what? can't you just define $ in sml?
13:31:12 <monadic_kid> implemntation of sML (not sml/SML) http://www.ps.uni-sb.de/hamlet/
13:31:17 <b_jonas> (with possibly a different name)
13:31:43 <b_jonas> vixey: so couldn't the successor just be ghc?
13:31:45 <jedai> mauke: Not really no :(
13:31:50 <b_jonas> ghc -fglasgow-exts
13:31:58 <vixey> b_jonas mostly focusing on getting things specified formally
13:32:14 <jedai> mauke: though some of the regex library may have a solution
13:32:16 <Elly> b_jonas: you can: fun op $ (a, b) = a b
13:32:26 <mauke> jedai: IIRC the regex libraries are mostly broken
13:32:36 <jedai> mauke: Why ?
13:32:43 <Berengal> Formal specifications are fun to read...
13:32:55 <vixey> Berengal: what do you mean
13:33:04 <mauke> jedai: turning the arguments into C strings
13:33:08 <jedai> mauke: The regex-base with pcre engine works pretty correctly
13:33:15 <Berengal> vixey: Just that. I read formal specifications in the bathroom :)
13:33:17 <mauke> jedai: this has issues for characters >= 256 and '\0'
13:33:28 <vixey> ok not sure why you brought it up
13:33:34 <bavardage> church numerals aren't exactly snappy :P
13:33:37 <jedai> mauke: Ah, maybe
13:33:47 <mreh> to anyone who has watched those videos lectures on LTU, does he ever get past the FP basics and into complex Haskell specific things?
13:33:54 <pumpkin> bavardage: I'm not surprised :P
13:33:56 <b_jonas> vixey: are you thinking of the extensions that are already stable and in general use, like multi-parameter typeclasses, fundeps, pattern guards, higher-rank types, etc?
13:33:59 <mreh> if anyone has seen them..
13:34:07 <vixey> mreh are you talking about SICP?
13:34:27 <mreh> um S-INF.com
13:34:30 <mreh> um S-INF.de
13:34:34 <vixey> b_jonas: also the actual langauge
13:34:36 <b_jonas> mauke: can't you just use utf-8 for that?
13:34:40 <bavardage> pumpkin: adding together a list of 6 fractions takes about 30 seconds :D
13:34:41 <monadic_kid> haskell tutorial videos, the link was on lambda the ultimate ages ago
13:34:44 <mauke> b_jonas: "just"
13:34:53 <pumpkin> bavardage: that sounds a little too slow :P
13:34:55 <bavardage> pumpkin: thought atm I'm not normalising anything
13:35:07 <bavardage> pumpkin: so the integers'll get stupid
13:35:07 <b_jonas> mauke: encode the string and regex to utf-8, do the match, etc
13:35:13 <bavardage> pumpkin: yaeh, yeah it is :D
13:35:21 <mreh> monadic_kid: have you watched them?
13:35:25 <b_jonas> mauke: you may have difficulty getting back the offsets in characters,
13:35:31 <pumpkin> hmm, maybe I'll write a pdf processor lib
13:35:34 <monadic_kid> vixey: http://lambda-the-ultimate.org/node/1303
13:35:35 <pumpkin> since there doesn't seem to be one
13:35:42 <monadic_kid> mreh: nah
13:36:02 <ker2x> hello. i learned Erlang, found it very nice and easy to understand. Now i bought "real world haskell" from o'reilly and find it very hard to "get it". Is there something wrong about this book as a first approach to haskell, or i just "don't get it" ?
13:36:24 <mreh> its great to recap the basics, but i wonder if there are videos on really haskell specific things
13:36:35 <jedai> mauke: regex-pcre at least seems to have support for utf8
13:36:47 <Berengal> ker2x: Haskell is rather different from Erlang, even though they're both functional
13:36:51 <pejo> ker, it takes a while to get used to Haskell.
13:37:04 <stolenKadaver> ker2x: id say haskell is harder to learn
13:37:14 <stolenKadaver> erlang is a very small simple(and good) language
13:37:23 <stolenKadaver> but they share a lot
13:37:23 <Berengal> ker2x: There's much more about haskell to "get". In my experience, there's much more to the language itself than most other languages
13:37:35 <bavardage> jeremiah: just keep at it
13:37:39 <bavardage> jeremiah: srry :P
13:37:43 <bavardage> ker2x: just keep at it
13:37:43 <monadic_kid> ker2x: i think that book is targeted more at people with some experinice, you might wanna get bird's book or school of expression before reading RWH
13:37:44 <b_jonas> ker2x: do you perhaps have some concrete question?
13:37:46 <ker2x> i think it's mostly about the syntax and the book start with type, type, type and type....
13:37:48 <bavardage> ker2x: it'll click eventually
13:38:02 <bavardage> ker2x: they say most people try and fail to learn haskell at least once before they succeed
13:38:15 <ddarius> bavardage: I've never heard that.
13:38:23 <bavardage> pfft
13:38:24 <monadic_kid> bavardage: driving lesson analogy now?
13:38:31 <ker2x> b_jonas: nope, no concrete question yet :)
13:38:32 <bavardage> monadic_kid: you go for it
13:38:37 <malosh> Hi. Does ghc have a ocaml-dynlink like feature to allow dynamic linking of haskell "plugins" ?
13:38:44 <bavardage> since I'm so amazing at driving anyway, I wouldn't know ^^
13:39:04 <monadic_kid> i mean more like the practical driving test
13:39:13 <b_jonas> ker2x: maybe someone here who knows erlang can recommend good resources. I can't because I don't know anything about erlang.
13:39:21 <b_jonas> (also I don't know much about haskell either yet)
13:39:25 <b_jonas> (oh well)
13:39:55 <Berengal> ker2x: Take a look at the wikibooks on haskell. They're not complete, but they give a good intro to the syntax, and should get you started on a few project euler problems...
13:39:58 <ker2x> i'm interested in haskell because : 1) it's functional 2) much more "module" to interact with the outside world (openGL, graph library, etc ...) than erlang
13:40:03 <jedai> malosh: Not really an equivalent but you have things like hs-plugins or others
13:40:07 <chrisdone> UHC, is this awesome(y/n)?
13:40:27 <ker2x> Berengal: that's how i discovered haskell. when trying to solve Euler in Erlang :)
13:41:07 <malosh> jedai : is this hs-plugins really used ? ocaml users seem quite excited about their all-new native dynlink module
13:41:23 <Berengal> ker2x: http://en.wikibooks.org/wiki/Haskell should get you started on the basics. Of course, RWH is a great tool as well, but might progress a little too fast. PE is a great educational tool for learning new languages I've found :)
13:41:26 <monadic_kid> ker2x: you know erlang is not purely functional (referential transparency)
13:41:58 <ker2x> ok i'll read it, thx
13:42:02 <monadic_kid> ker2x: have you seen this link http://learnyouahaskell.com/
13:42:04 <b_jonas> monadic_kid: oh but you can say that to any language basically
13:42:08 <brian6> if i'm in ErrorT E IO (), 'liftIO (readFile fp) `catchError` \_ -> throwError myError', catchError isn't getting to catch the exception thrown by readFile.
13:42:16 <Berengal> Suddenly: Tutorials! Everywhere!
13:42:20 <ker2x> monadic_kid: i'm not and erlang expert yet. it's Erlang was my 1st functional langage
13:42:28 <b_jonas> brian6: yup
13:42:48 <jedai> malosh: Haskell programs can be linked to shared C libraries, but you can't write shared Haskell library, you have to link statically
13:42:50 <bavardage> is there any way to make sure something evaluates?
13:42:53 <ker2x> bookmarked :)
13:42:57 <bavardage> as in say "DON'T BE LAZY"
13:42:58 <b_jonas> brian6: it's not even of type E
13:43:07 <Berengal> bavardage: seq?
13:43:14 <michaelcdever> bavardage: !eval ???
13:43:20 <malosh> jedai : ok, thanks
13:43:26 <bavardage> I just put a !?
13:43:42 <b_jonas> bavardage: print it
13:43:48 <bavardage> b_jonas: that's what I'm doing attm
13:43:53 <brian6> b_jonas: sorry, i'd actually be in ErrorT E IO String for readFile. i'm actually asking how to catch io exceptions and throw a custom error type in ErrorT.
13:43:54 <bavardage> I don't want to have to print it though :(
13:43:59 <michaelcdever> yeah, at your evaluation i.e. return (!f)
13:44:02 <bavardage> since the return value is ugly
13:44:11 <monadic_kid> ker2x: oh yeah we just mentioned this earlier as well http://lambda-the-ultimate.org/node/1303
13:44:22 <monadic_kid> ker2x: video tutorials
13:44:38 <Berengal> bavardage: seq forces it's first argument to whnf before returning the last
13:44:40 <bavardage> michaelcdever: Main.hs:14:15: Not in scope: `!'
13:44:44 <jedai> malosh: You can evaluate code at the runtime though, and use value coming from them and so on, using the ghc api or rather one of the library that provides a sane API to do so (of which hs-plugins is an example)
13:44:52 <bavardage> Berengal: I'll try that
13:44:55 <Berengal> > let a = undefined in const 5 a
13:44:56 <lambdabot>   5
13:44:58 <b_jonas> brian6: well, do you know how to catch them in a plain IO? (with try.) do that, but liftIO it, and then throw it in the ErrorT
13:45:02 <michaelcdever> hmm, it worked for me, ill have a look at the code
13:45:04 <Berengal> > let a = undefined in a `seq` const 5 a
13:45:05 <lambdabot>   * Exception: Prelude.undefined
13:45:25 <bavardage> Berengal: yop that worked
13:45:33 <bavardage> Berengal: ty :D
13:45:47 <Berengal> bavardage: Beware the "to whnf" clause though... it won't evaluate an entire list for example...
13:45:55 <jedai> malosh: It really depends on what you want to do
13:45:57 <Berengal> > let a = [1..] in a `seq` 5
13:45:59 <lambdabot>   5
13:46:08 <bavardage> Berengal: right kk
13:46:19 <bavardage> Berengal: this is for forcing evaluation of lamba calc
13:46:40 <michaelcdever> bavardage: return $!(expression)
13:46:45 <Berengal> bavardage: Right, so functions... those shouldn't pose much problem...
13:46:53 <Berengal> (Unless there's lots of constructors in there...9
13:46:56 <Berengal> )*
13:47:04 <bavardage> Berengal: yeah it seems to be fine
13:47:22 <stolenKadaver> how can ghci derive types that arent in scope
13:47:30 <bavardage> http://paste.pocoo.org/show/113273/ <-- just using it like this
13:47:36 <malosh> jedai : I'm trying to write a plugin system to define dynamically a function to be called often, so I need something efficient. I'm looking at the ghc api, thanks !
13:47:49 <Martijn> stolenKadaver: what do you mean, exactly?
13:47:59 <Martijn> stolenKadaver: perhaps you just need to add the appropriate imports?
13:48:04 <skorpan> could someone help me figure out a Foldable instance for this code?  http://pastebin.com/m558bc00a
13:48:32 <b_jonas> stolenKadaver: asTypeOf
13:48:49 <Berengal> bavardage: Without knowing what type result is... it could be whnf is not the same as regular normal form... As long as you know the difference...
13:48:58 <stolenKadaver> is there some command to do runComman+waitForProcess in one?
13:49:53 <bavardage> oh kk
13:50:03 <monadic_kid> http://fpmatters.blogspot.com/2009/04/haskell-still-very-difficult-to-write.html
13:50:26 <michaelcdever> quick question, when i was writing my file manager my project, i wrote my own functionality, to use unix commands like rm, mv, cp to work with files and directories
13:50:27 <b_jonas> @type System.Process.system {- -> stolenKadaver -}
13:50:28 <lambdabot> Not in scope: `System.Process.system'
13:50:29 <michaelcdever> and files
13:50:41 <b_jonas> @hoogle System.Process.system
13:50:41 <lambdabot> package system-inotify
13:51:12 <michaelcdever> now that im working towards releasing it, i want to use the System.Directory to do the same stuff, keep it all haskelly :D
13:51:26 <michaelcdever> why is there no copyDirectory function in System.Directory??
13:52:06 <wli> I think I've made progress on the Grobner front.
13:52:24 <mauke> michaelcdever: because there is no such system library function
13:53:44 <Martijn> skorpan: see http://pastebin.com/m62624642
13:53:52 <stolenKadaver> In this case we either have to refactor our code to be less monadic, or spend time writing a function that should really be in the library.
13:54:00 <stolenKadaver> bah i never use them monads almost
13:54:05 <michaelcdever> mauke: well i use cp -rf dirname to copy directories...
13:54:15 <Martijn> skorpan: i don't know if I overwrote your original question but at least the answer should be there
13:54:20 <stolenKadaver> write 99% pure code and a dirty main...there you have it
13:54:35 <wli> http://wli.pastebin.com/m11313797 <-- here's hoping that the bloody thing works this time
13:55:08 <skorpan> Martijn: thanks, i'll try that
13:55:09 <stolenKadaver> and the Map lib doesnt suck does it?
13:55:26 <Martijn> skorpan: let me know how it works out
13:56:10 <brian6> b_jonas: are you saying to 'try' and then to either throwError or return?
13:57:36 <mreh> what makes lazy evaluation different from outermost?
13:57:43 <mreh> just stopping when you're done
13:57:48 <mreh> when you have enough
13:58:15 <b_jonas> brian6: yes, basically
13:58:32 <brian6> b_jonas: ok, thanks.
13:58:37 <b_jonas> brian6: but be sure to catch only those exceptions that you want to catch, not all
13:59:01 <brian6> b_jonas: i was worried about that. should i really use tryJust?
13:59:30 <b_jonas> brian6: if try isn't enough to restrict you (that is you don't want to jsut catch all exceptions of one type) then yes
13:59:39 <brian6> b_jonas: or do i do like \(e :: ...) -> ...
13:59:58 <mreh> this guy said, on these e-lectures, ericsson found haskell to write programs 2-10 times shorter, which is bad because they pay by the line at ericsson
14:00:18 <p_l> lol
14:00:18 <mreh> seeings as development is 10-25 times faster, what's the problem?
14:00:36 <trofi> they count comments? :]
14:00:58 <monadic_kid> mreh: the problem was he's gonna loss money ;)
14:00:58 <mreh> comments are overtime
14:01:27 <mreh> if i can write 10 times more code, it doesnt matter that each program is 10 times shorter at most
14:02:06 <b_jonas> brian6: well, you can type constrain it with a :: if yuo want, but if you're transforming the error to a custom error of a different type then you'll likely call specific functions like isDoesNotExistError so in that case you don't even need that
14:02:30 <b_jonas> I think you'll get an error anyway if the compiler can't derive the type of exception you're catching
14:02:50 <jedai> mauke: If you're still searching for a replacement function for unicode text, I may mention that Data.Text has a breakSubstring function that could do what you want quite handily if I understood correctly
14:03:10 <mauke> jedai: I don't even need unicode text
14:03:30 <mauke> I just don't trust an API that obviously hasn't even considered the problem
14:03:38 <mauke> also, text replacement is too hard in haskell
14:03:38 <brian6> b_jonas: if i just use 'try', am i at risk of catching exceptions that don't have anything to do with the IO i was doing?
14:03:56 <mauke> I'll just pipe it through perl -pe 's/\(0\)/0/g' or whatever
14:04:18 <b_jonas> brian6: not if the type you're catching is IOException
14:04:23 <Valodim> some core lib could use a function equal to python's %
14:04:38 <b_jonas> Valodim: do you mean modulo or printf?
14:04:38 <brian6> b_jonas: ah, ok. that helps a lot. thanks.
14:04:44 <Valodim> the printf-y thing
14:04:50 <mauke> Valodim: we have printf
14:04:53 <vixey> (stringStart "a" "b" "c" stringEnd) = "a\nb\nc\n"
14:05:12 <b_jonas> so since when is mtl using fundeps?
14:05:14 <vixey> mauke what do you think
14:05:19 <b_jonas> has it changed while I wasn't looking?
14:05:36 <mauke> vixey: huh?
14:05:43 <vixey> for multiline strings
14:05:53 <b_jonas> vixey: um,
14:06:02 <b_jonas> vixey: wouldn't that need the printf hack?
14:06:19 <mreh> am i in #c?
14:06:22 <mauke> vixey: that's not better than unlines $ "foo" : "bar" : "baz" : []
14:06:26 <trofi> almost
14:06:33 <b_jonas> vixey: is that worth just to be able to omit the commas from unlines [ .. ]
14:06:36 <b_jonas> mreh: no
14:06:44 <mreh> oh thank god for that
14:07:12 <mreh> can we start calling haskell, a highest programming language?
14:07:40 <mreh> highest level programming language
14:08:05 <b_jonas> mreh: no, that would just scare people away I think
14:08:25 <b_jonas> plus I don't thikn it's even true
14:08:37 <jedai> mauke: You have a certain number of regex library that works correctly with Utf8 in Haskell, though I agree that the lack of a good collection of text replacement functions sucks
14:08:47 <mreh> i was objecting to C being called a high level programming language
14:08:58 <Adamant> b_jonas: with stuff like Agda and Epigram out there, it isn't
14:09:27 <Adamant> b_jonas: plus default Haskell doesn't have features other languages have that are fairly powerful
14:09:39 <Adamant> e.g. macros, you need Liskell for that
14:09:55 <b_jonas> Adamant: you mean template haskell?
14:09:56 <jedai> Adamant: Though you have TH
14:10:00 <b_jonas> "liskell" lol
14:10:19 <Adamant> you have TH, but it's not nearly as nice to use as real macros
14:10:27 <Adamant> JMO
14:10:32 <eu-prleu-peupeu> i tried to install a tool by hand, using the runhaskell Setup.lhs configure, but it says some packages are missing, even though i have installed them with cabal
14:10:36 <eu-prleu-peupeu> how do i fix this ?
14:10:43 <b_jonas> I like haskell. we'll see when I have time whether I'll still like it after writing big programs in it.
14:10:55 <b_jonas> and maintain. let me not forget maintain.
14:11:00 <b_jonas> that's what really tests a languages
14:11:01 <monadic_kid> what the hell does powerful really mean anyways, kind of  a stupid word to use
14:11:06 <b_jonas> okay, good night
14:11:12 <Adamant> monadic_kid: it's very, very subjective
14:11:20 <Phyx-> eu-prleu-peupeu, which packages are missing, and check with ghc-pkg list if the correct versions are installed
14:11:27 <eu-prleu-peupeu> monadic_kid: its like an atom bomb, powerfulll
14:11:39 <ddarius> Adamant: The only significant difference between TH and CL, say, style macros is that macro invokation is not implicit in TH and I'm pretty sure this is by design.  Otherwise, it is more or less identical in concept to CL macros.
14:11:48 <mreh> you could measure power objectively
14:11:59 <mreh> languages all translate to machine code
14:12:05 <monadic_kid> you have you define what power is first
14:12:10 <eu-prleu-peupeu> Phyx-: they are listed, but in the cabal dir :/
14:12:26 <mreh> the power is a function of the ration of original coder / machine language
14:12:37 <mreh> s/ration/ratio/
14:12:39 <eu-prleu-peupeu> in this dir: /home/hugo/.ghc/i386-linux-6.10.1/package.conf
14:13:02 <stolenKadaver> http://www.haskell.org/haskellwiki/Top_level_mutable_state <- didnt know that was a problem i use MVar or IORefs without such probs
14:13:08 <Adamant> ddarius: I'm not saying you can't do the same things in TH, it's just more annoying
14:13:14 <Adamant> again, JMO
14:13:16 <Berengal> eu-prleu-peupeu: runhaskell Setup.lhs tries to install it globally, which requires the dependencies to also be installed globally
14:13:30 <ddarius> Adamant: More annoying /= not "real"
14:13:35 <eu-prleu-peupeu> how do i make it install localy ?
14:13:47 <Berengal> eu-prleu-peupeu: --user or something like that... I'm no expert :P
14:13:48 <stolenKadaver> why does Harrop have something against Haskell specifically? he seems to like all other functional languages but really hates haskell.
14:13:53 <eu-prleu-peupeu> thanks
14:14:27 <Adamant> stolenKadaver: I don't think he likes all other functional languages, unless they can make him money, or he thinks they can.
14:15:17 <monadic_kid> stolenKadaver: not really, just ocaml and to less extent f#.
14:15:38 <Adamant> yeah, he has "investment" in those
14:15:40 <vixey> send him an email I doubt #haskell knows what's going on in that guys head
14:16:54 <stolenKadaver> is he even a Dr?
14:17:41 <eu-prleu-peupeu> there are some packages that need quickcheck 1.2, and some that need 2.1, how do i solve this ?
14:18:06 <Phyx-> eu-prleu-peupeu, install both
14:18:25 <eu-prleu-peupeu> Phyx-: how do i do it with cabal ?
14:18:46 <Phyx-> same way you installed the other packages. ghc comes with 1.2
14:18:58 <Phyx-> so you have to download 2.1 from hackage and do a cabal install
14:20:07 <eu-prleu-peupeu> quickcheck 2.1.0.1 doesn't build on ghc 6.10.1
14:20:19 <Phyx-> go into the file that gives the error
14:20:26 <Phyx-> change Control.Exception
14:20:34 <Phyx-> to Control.OldException
14:20:42 <eu-prleu-peupeu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3938#a3938
14:20:49 <arjanb> eu-prleu-peupeu: you need to install extensible-exceptions first
14:20:51 <eu-prleu-peupeu> ah ok
14:21:02 <Phyx-> or
14:21:06 <Phyx-> you can just do what i said
14:21:10 <eu-prleu-peupeu> how do i make cabal to install systemwide ?
14:21:26 <stolenKadaver> can red black trees be faster than tries?
14:21:51 <Phyx-> eu-prleu-peupeu, that's the default afaik
14:22:10 <eu-prleu-peupeu> hmm, whenever i do a cabal install it installs into my home dir
14:22:11 <Berengal> Phyx-: No, cabal installs in the user repo
14:22:43 <arjanb> eu-prleu-peupeu: there's a --global flag
14:23:28 <Phyx-> Berengal, i've never experienced that before, not unless my user repo happens to be in program files
14:24:24 <wli> Okay, I think I'm down to where all I need is to find linear divisors in the field.
14:24:35 <Baughn> eu-prleu-peupeu: You want --global, and root-cmd set in ~/.cabal/config
14:24:37 <Berengal> Phyx-: Windows is different...
14:24:37 <Baughn> Probably to sud
14:24:40 <Baughn> *sudo
14:24:41 <Phyx-> Berengal, the cabal documentation says
14:24:42 <Phyx-> --global
14:24:43 <Phyx-> Register this package in the system-wide database. (This is the default, unless the --user option was supplied to the configure command.)
14:24:58 <Phyx-> So the default is global unless otherwise specified as --user
14:25:04 <Baughn> Phyx-: That's cabal. cabal-install does --user by default.
14:25:07 <Berengal> Phyx-: Not on my machine...
14:25:22 <wli> Given how bad the algorithm for factoring in algebraic number fields looks I should probably try factoring over Q first to cut down the problem size.
14:25:32 <Phyx-> Baughn, i thought we were talking about cabal
14:25:36 <Phyx-> hmm
14:25:46 <Baughn> Phyx-: The cabal /command/, sure. ;)
14:26:10 <jedai> eu-prleu-peupeu: I strongly suggest you install everything locally
14:26:42 <eu-prleu-peupeu> jedai, then how do i install diff versions of quick check ?
14:26:46 <jedai> eu-prleu-peupeu: instead of installing the package you downloaded by hand I suggest you use "cabal configure"
14:26:47 <eu-prleu-peupeu> with cabal :P
14:27:12 <jedai> eu-prleu-peupeu: well you just say to cabal which you want to install
14:27:16 <Phyx-> doesn't "cabal install" already do configure
14:27:32 <ddarius> cabal install does everything
14:27:37 <eu-prleu-peupeu> No packages to be installed. All the requested packages are already installed.
14:27:40 <Phyx-> exactly, so no need
14:27:47 <eu-prleu-peupeu> thats what it says, because i have the 1.2.0.0 installed
14:28:00 <Phyx-> eu-prleu-peupeu, yes, that's why i said download it manually
14:28:17 <Phyx-> 2.1 doesn't seem to be downloadable automatically
14:28:54 <ddarius> You should be able to say cabal install quickcheck-2.1.0.1 or whatever version explicitly.
14:28:54 <eu-prleu-peupeu> strange, because i did a cabal update recently
14:29:22 <Phyx-> ddarius, i tried it once, it told me package not found
14:29:25 <Phyx-> might be me though
14:29:36 <eu-prleu-peupeu> Phyx-: do a cabal update
14:29:48 <jedai> eu-prleu-peupeu: Are you sure you don't have QuickCheck 2.1.0.1 in your user packages ?
14:30:18 <eu-prleu-peupeu> yes
14:30:48 <eu-prleu-peupeu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3939#a3940
14:30:50 <stolenKadaver> fuken ey
14:30:50 <jedai> eu-prleu-peupeu: what does it say if you do "cabal update && cabal install quickcheck-2.1.0.1"
14:30:51 <eu-prleu-peupeu> here is the error
14:31:16 <stolenKadaver>  mokick kadaverd
14:32:10 <eu-prleu-peupeu> when i do a cabal install reactive, it just blows
14:32:37 <eu-prleu-peupeu> i installed ghc 6.10.1 just now, its not filled with packages
14:32:52 <jedai> eu-prleu-peupeu: Ok, the problem is not that it can't install quickcheck-2.1
14:33:23 <eu-prleu-peupeu> eh
14:33:34 <eu-prleu-peupeu> ill switch to windows, it works fine there :/
14:33:36 <jedai> eu-prleu-peupeu: apparently the problem is rather conflicting dependencies in the dependencies of the package you wanted to install in the beginning
14:34:21 <eu-prleu-peupeu> ah
14:34:33 <jedai> eu-prleu-peupeu: What are you trying to install anyway ?
14:34:35 <eu-prleu-peupeu> the package depends on diff versions of the same package
14:34:36 <eu-prleu-peupeu> reactive
14:34:53 <eu-prleu-peupeu> i did a cabal install reactive
14:35:29 <eu-prleu-peupeu> i see
14:35:39 <eu-prleu-peupeu> the stream package got updated and now the others blow
14:35:58 <jedai> eu-prleu-peupeu: I think we may be able to do something like ask him to use an older version of Stream
14:36:00 <ddarius> Use an older version of the stream package then.
14:37:14 <eu-prleu-peupeu> what is the command to delete a package in cabal ? i cant find it on the help
14:37:24 <Berengal> eu-prleu-peupeu: cabal installs are forever
14:37:34 <eu-prleu-peupeu> oh
14:37:38 <jedai> eu-prleu-peupeu: I think adding a simple constraint is enough
14:37:43 <gwern> like diamonds. but not so useless and expensive
14:38:09 <jedai> eu-prleu-peupeu: cabal install reactive --constraint="Stream<=0.3"
14:38:12 <Berengal> Basically... ghc-pkg unregister $foo && rm -rf /path/to/wherever/$foo
14:38:13 <jedai> eu-prleu-peupeu: works
14:38:13 <eu-prleu-peupeu> ahh
14:38:14 <eu-prleu-peupeu> nice
14:38:35 <wli> http://wli.pastebin.com/m2a36b7e3 <-- some slight cleanup for the Grobner code.
14:38:36 <jedai> eu-prleu-peupeu: You can have several versions of the same package, it's not a problem
14:38:49 <eu-prleu-peupeu> perfect :D
14:39:13 <eu-prleu-peupeu> now i can use my code on linux without stress
14:39:15 <eu-prleu-peupeu> yehhh
14:39:22 <eu-prleu-peupeu> thanks :)
14:39:28 <Berengal> Shouldn't cabal be able to figure out these versioning constraints itself?
14:39:30 <wli> I need a better repl for testing crap.
14:39:35 <eu-prleu-peupeu> if i do a ghci
14:39:41 <eu-prleu-peupeu> will it recognize the local packages ?
14:39:49 <Berengal> eu-prleu-peupeu: yes
14:39:52 <eu-prleu-peupeu> fnice
14:40:10 <jedai> Berengal: I think an earlier version could
14:40:28 <Berengal> jedai: Removed or simply bitrotted away?
14:40:38 <jedai> Berengal: but the algorithm sometimes becames horribly slow (so removed)
14:41:20 <jedai> Berengal: The current version very often find a solution but sometimes need a little help with --constraint
14:42:25 <Berengal> jedai: When i tried cabal install reactive, i got an error saying some packages depended on QC >=2.0 and some on QC <2.0
14:42:46 <Berengal> Is there a reason it couldn't just install both versions of QC and install the packages?
14:43:06 <dcoutts> Berengal: it's ok to have both installed at the same time
14:43:21 <stolenKadaver> what language would you use for a life/death application, ie no performance demands but it can never crash
14:43:24 <jedai> Berengal: You can't link to both version at the same time
14:43:28 <dcoutts> Berengal: but each package install plan can only include one version
14:43:33 <jedai> stolenKadaver: coq
14:44:21 <Berengal> Hmmm...
14:44:24 <stolenKadaver> and which lang would you generate?
14:44:38 <jedai> stolenKadaver: Haskell of course !
14:45:27 <beelsebob> Berengal: it can be fixed
14:45:41 <beelsebob> change reactive's cabal file to ask for Stream <= 0.3
14:45:44 <beelsebob> rather than just Stream
14:45:46 <jedai> stolenKadaver: No, to be honest I think I would use Ada with the more formal proof I could manage
14:45:53 <Gracenotes> >_>
14:46:01 <beelsebob> dcoutts: that's the specific thing I was talking to you about
14:46:14 <ivanm> gah! my app ran for about 40 hours and then had a stack space overflow! :@
14:46:20 <Berengal> beelsebob: yes, I know, but I'd hope one would be able to use the latest Stream...
14:46:32 <ivanm> but how? it creates a list but prints each element to file as it finds it...
14:46:41 <jedai> beelsebob: You don't need to modify the cabal file, you can add the constraint on the command line
14:46:51 <beelsebob> Berengal: well, patches are welcome to checkers to make it work with QC 2 – that's the dependancy on 1
14:47:03 <dcoutts> beelsebob: right
14:47:54 <Berengal> beelsebob: I was thinking more in the general case. It shouldn't be impossible to install a package which depends on two different versions of another package...
14:48:17 <Berengal> You might have to statically link one version...
14:48:29 <beelsebob> Berengal: indeed - from what dcoutts said to me, it's an exponential blow up in searching for versions that actually work correctly together
14:48:52 <beelsebob> so it's not as simple as it seems
14:48:58 <beelsebob> I thought exactly what you thought too
14:49:49 <Berengal> beelsebob: I thought the exponential search was to find some combination of versions which didn't have the conflicting dependencies...
14:49:57 <stolenKadaver> ivanm: what kind of app?
14:50:10 <Berengal> If you statically linked all but one of those dependencies, there'd be no conflict
14:50:39 <jedai> beelsebob: No, I think he's actually speaking about linking one binary to two version of a same package
14:50:49 <ivanm> stolenKadaver: one that produces values
14:50:49 <beelsebob> oh
14:50:51 <wli> Oh boy, factoring polynomials is horrendous.
14:50:51 <beelsebob> I see
14:50:51 <dcoutts> beelsebob, Berengal: depending on two versions is possible in principle but cabal does not have enough information to know when it is possible
14:51:15 <stolenKadaver> http://en.wikipedia.org/wiki/File:Simon_Peyton_Jones_01.jpg <- doesnt he look a bit spooky there?
14:51:50 <dcoutts> Berengal: the conflict is in a sense artificial, cabal-install specifically looks for solutions using only one version of a package because those are the only ones that it knows for sure will work
14:52:48 <dcoutts> Berengal: it's always possible to link multiple versions of a package, the problem is type errors
14:52:53 <nA1828KcFz9q> hello, i am having some dependency issues, boiling down to "For the dependency on base ==4.* there are these packages: base-4.0.0.0 and
14:52:53 <nA1828KcFz9q> base-4.1.0.0. However none of them are available.
14:57:45 <pejo> nA1828KcFz9q, do you have ghc 6.10?
14:58:34 --- mode: irc.freenode.net set +o ChanServ
14:58:56 <Gracenotes> okay
14:58:56 <Gracenotes> there we go.
14:58:56 <Phyx-> lol
14:58:56 <Berengal> dcoutts: Not for every case it seems...
14:58:56 <Berengal> But possibly for many
14:58:56 <dcoutts> Berengal: I think it's doable for all
14:59:29 <dcoutts> Berengal: it requires typechecking packages as functors, considering all imports as parameters
14:59:46 <dcoutts> Berengal: then checking what versions are possible requires doing some type checking
15:00:42 <Berengal> dcoutts: I think I see what you mean... It could be possible
15:01:49 <Berengal> The only impossible case is when a module importing two modules which both export different versions of a fourth module and the first module uses that fourth module in incompatible ways
15:01:55 <Berengal> But then the first module wouldn't build anyway
15:02:45 <dcoutts> Berengal: I don't mean all possible combinations are possible but that it's possible to detect which combinations are possible
15:03:18 <dcoutts> Berengal: by seeing what constraints packages impose by unifying the types of two imports
15:05:00 <Berengal> dcoutts: Surely the "impossible" combinations wouldn't build anywhere
15:05:33 <dcoutts> Berengal: but we want to detect that before trying to build them
15:05:48 <dcoutts> Berengal: we want to know that when we're planning what versions to install
15:06:05 <Berengal> dcoutts: Actually, I want the package maintainer to try to build his modules before uploading them :P
15:06:56 <Berengal> Now, if there IS possible combination, then yes, we'd like to find that before we start downloading random packages from hackage
15:07:38 <Berengal> If there isn't... then it shouldn't have been uploaded in the first place
15:13:56 <PeakerWork> does anyone know if Reactive's bugs were fixed as expected by ghc 6.10.2 ?
15:21:21 <nA1828KcFz9q> how long does it usually take to compile ghc 6.10.2 ?
15:21:34 <mauke> a few hours
15:21:41 <nA1828KcFz9q> ic
15:21:49 <Phyx-> a few hours?
15:22:10 <Phyx-> for just 1 platform?
15:22:27 <nA1828KcFz9q> yes
15:23:26 <jedai> That's incorrect
15:23:48 <jedai> On a modern computer ghc doesn't take hours to compile
15:24:03 <jedai> but often more than an half hour though
15:24:09 <nA1828KcFz9q> oh OK
15:24:23 <Phyx-> that includes a rebuild of every package it comes with right? base etc?
15:24:25 <jedai> In other words : use the binary
15:24:29 <Phyx-> or just the core ghc files?
15:24:45 <nA1828KcFz9q> latest binary is not recent enough for some packages
15:24:48 <jedai> Phyx-: Yes, it includes a rebuild of that
15:25:06 <Phyx-> ah ok, then i can see how it'll take long
15:25:18 <mauke> I have a single processor, 2MHz
15:25:24 <Phyx-> lol
15:25:26 <jedai> nA1828KcFz9q: You're confusing package available with the distros and binary available on ghc website
15:25:30 <Phyx-> what os are you running on that
15:25:32 <Phyx-> dos?
15:26:00 <jedai> nA1828KcFz9q: The latest stable ghc is 6.10.2 and a binary is available for every platform on the ghc website
15:28:13 <koeien> can you do 'make -j4' when compiling GHC?
15:28:29 <koeien> or something similar
15:28:47 <pejo> koeien, yes, but it still takes a long time.
15:29:12 <koeien> pejo: should cut off a large chunk :)
15:29:42 <Phyx-> what does -j4 do?
15:30:03 <koeien> Phyx-: spawn <= 4 processes to do the make. useful if you have a machine with more cores or cpu's
15:30:05 <jedai> The fastest compilation of ghc I ever heard of was something like 15m long
15:30:07 <pejo> koeien, maybe I'm just impatient.
15:30:30 <Phyx-> koeien, ah, neat, that's one i gotta remember
15:30:33 <nA1828KcFz9q> jedai
15:30:43 <nA1828KcFz9q> ghc6 latest version for ubuntu is 6.8.2
15:30:58 <Phyx-> that can't be
15:31:04 <koeien> nA1828KcFz9q: in the repositories. on www.haskell.org/ghc there is 6.10.2 for you
15:31:09 <jedai> nA1828KcFz9q: Yes, I know
15:31:25 <Phyx-> i thought i installed 6.10.1 last time
15:31:28 <Phyx-> i need to check my vm
15:31:33 <jedai> nA1828KcFz9q: But the ghc websites has binaries for Linux
15:34:42 <nA1828KcFz9q> oh i see, what will this contain, "ghc-6.10.2-i386-unknown-linux-libedit2.tar.bz2"
15:35:18 <c_wraith> It contains ghc, pre-compiled, linked against libedit 2.
15:35:27 <jedai> nA1828KcFz9q: That's the one you want
15:35:29 <nA1828KcFz9q> oh OK
15:36:17 <jedai> nA1828KcFz9q: you download it and you install it (./configure --prefix=/opt && sudo make install)
15:36:21 <nA1828KcFz9q> yes
15:36:38 <koeien> nA1828KcFz9q: you will need libffi-dev and perhaps some other packages
15:36:46 <koeien> nA1828KcFz9q: i would install it in /usr/local
15:37:07 <koeien> (instead of /opt) Ubuntu's package manager ignores that
15:38:09 <jedai> koeien: Generally you _want_ your package manager to ignore this kind of installation...
15:38:19 <koeien> jedai: yes. that was i was saying :)
15:38:36 <koeien> or at least, meant to say
15:38:46 <koeien> both /usr/local & /opt are ignored
15:39:47 <nA1828KcFz9q> jedai, koeien : OK, did it :-)
15:40:06 <koeien> after installation, you can check whether ghc performs correctly, ghc -e '1+1=2'
15:40:20 <koeien> ghc -e '1+1==2'
15:40:32 <nA1828KcFz9q> yes :)
15:40:40 <koeien> (I had to install libffi-dev to get it to work)
15:40:47 <jedai> koeien: Ok, in this case /usr/local is probably a good choice
15:41:07 <koeien> jedai: not every *nix-like OS ignores /usr/local, but Debian does
15:41:18 <jedai> nA1828KcFz9q: check with "ghc --version" if you're really using the new version
15:41:26 <nA1828KcFz9q> The Glorious Glasgow Haskell Compilation System, version 6.10.2
15:41:33 <koeien> \o/
15:42:23 <jedai> koeien: I tend to avoid /usr/local since I know some distrib use it, I never checked if Ubuntu did, good to know :)
15:44:54 <nA1828KcFz9q> cabal install base-4.0.0.0 --> "config.status: error: cannot find input file: include/HsBaseConfig.h.in"
15:46:02 <mauke> base comes with ghc
15:46:04 <koeien> nA1828KcFz9q: you shouldn't need to install base
15:46:06 <mauke> why do you want to reinstall it?
15:46:12 <koeien> i had this problem as well.
15:46:15 <nA1828KcFz9q> OK, right
15:46:25 <koeien> what does   'ghc-pkg list'  give?
15:46:43 <nA1828KcFz9q> so, im having a problem with "happy"
15:47:57 <eu-prleu-peupeu> has anyone tryed out reactive ?
15:48:08 <nA1828KcFz9q> http://pastebin.com/m62ad3c22
15:48:12 <eu-prleu-peupeu> it doesn't seem so "reactive" in linux :S
15:48:30 <eu-prleu-peupeu> i click the mouse, and it responds only a few seconds later
15:48:50 <koeien> nA1828KcFz9q: this output is normal, you shouldn't need base; it is already installed.
15:49:34 <nA1828KcFz9q> >_< i made a mistake, "happy" went well
15:49:59 <nA1828KcFz9q> just many "Defined but not used:"s, its normal ?
15:50:25 <koeien> nA1828KcFz9q: that are warnings. you can ignore them if it's not your code
15:50:32 <Phyx-> Heh... just finished watching Seven Pounds... i Thought this was supposed to be a happy movie...
15:50:39 <Itkovian> How can I have GHC add profilation point to e.g. Data.List?
15:51:38 <jedai> Itkovian: Normally the library coming with GHC are all compiled in profiling versions too
15:52:36 <gwern> I wonder why sigbjorn is resurrecting greencard?
15:52:38 <eu-prleu-peupeu> why is reactive so slow in linux ?
15:53:01 <nA1828KcFz9q> haskell-src-exts-0.4.8 says 'happy' cannot be found
15:53:30 <gwern> nA1828KcFz9q: either you didn't install happy or it got installed to somewhere off your $PATH
15:54:25 <Itkovian> jedai: Hmm, but the Data.List function I am interested in and not exported.
15:54:56 <Itkovian> -auto only targets those, -auto-all targets top-level functions, but in none of those cases do I see anything from within the libs
15:56:03 <jedai> nA1828KcFz9q: happy was probably installed to ~/.cabal/bin
15:56:41 <jedai> nA1828KcFz9q: You should add this to the path or create a symbolic link in /usr/local/bin
15:56:50 <nA1828KcFz9q> oh, i see
15:57:07 <Berengal> Adding ~/.cabal/bin to the path is probably the best idea
15:57:32 <Berengal> Or you'll end up making symlinks to every haskell binary you install...
15:57:36 <nA1828KcFz9q> what do you mean add "to the path" ?
15:57:38 <lpsmith> I prefer setting symbolic links in my ~/bin/
15:57:54 <lpsmith> You can have cabal add these links automatically
15:58:05 <Berengal> lpsmith: how?
15:58:19 <dcoutts> cabal --help points you to the config file
15:58:22 <Berengal> nA1828KcFz9q: if you try "echo $PATH" in a terminal, it shows your path
15:58:32 <lpsmith> edit your ~/.cabal/config
15:58:46 <lpsmith> set symlink-bindir:  /home/username/bin
15:58:48 <lpsmith> err
15:58:50 <lpsmith> no set
15:58:52 <lpsmith> just
15:58:59 <lpsmith> symlink-bindir: /home/username/bin
15:59:20 <lpsmith> under the subsection "install-dirs user"
15:59:28 <Berengal> Awesome, found it
15:59:29 <Berengal> thanks
16:00:49 <jedai> lpsmith: Oh cool, I didn't know this one :D
16:03:45 <nA1828KcFz9q> oh, i see :)
16:07:08 <PeakerWork> anyone has any idea about the current state of Reactive?
16:11:54 <jedai> lpsmith: symlink-bindir doesn't seem to be recognized, which version of cabal-install has it ?
16:12:38 <dcoutts> jedai: did you uncomment it in the config file?
16:12:56 <dcoutts> jedai: it's certainly supported from 0.6 and later
16:13:26 <jedai> dcoutts: I didn't uncomment it since it wasn't there at all
16:13:54 <jedai> dcoutts: oops, it was but in the main section
16:14:30 <eu-prleu-peupeu> anyone here tryed out reactive in linux ?
16:14:33 <jedai> does that means we can't specify a different version for user or global install ?
16:14:58 <jedai> dcoutts: It seems the kind of option that belongs in those sections
16:15:31 <Itkovian> Steraling the RWH idea, I implemented the L2-norm of a vector as follows: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3942#a3942
16:15:35 <dcoutts> jedai: yeah, you're right. Please file a feature request ticket.
16:16:06 <dcoutts> jedai: http://hackage.haskell.org/trac/hackage/wiki
16:16:11 <Itkovian> Profiling shows this allocating up to 25% of total allocated memory in a larger program. Any hints what I am doing wrong?
16:16:14 <jedai> thanks
16:16:34 <Itkovian> I reused the mean example from the profiling chapter from RWH, and that seems to work just fine.
16:19:18 <eu-prleu-peupeu> strange thing happens
16:19:30 <eu-prleu-peupeu> when i run it in ghci, it responds quite fast
16:19:35 <eu-prleu-peupeu> when i run it compiled
16:19:39 <eu-prleu-peupeu> it responds quite slow
16:19:40 <eu-prleu-peupeu> :S
16:19:52 <c_wraith> eu-prleu-peupeu: what version of ghc are you using?
16:19:59 <eu-prleu-peupeu> 6.10.1
16:20:19 <c_wraith> Well, then, I have no clue.  (I've seen really strange behavior out of 6.10.2 in several cases)
16:20:25 <eu-prleu-peupeu> im going to paste the code
16:21:33 <eu-prleu-peupeu> here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3943#a3943
16:21:34 <eu-prleu-peupeu> :S
16:22:28 <eu-prleu-peupeu> it works like: when you press the mouse inside the window, it should write into the console the time and position that it was pressed
16:22:45 <eu-prleu-peupeu> it runs smoothly inside ghci, but slow as heck if compiled
16:38:45 <eu-prleu-peupeu> ill try freeglut instead of glut
16:38:55 <Berengal> I have a crazy idea...
16:39:26 <Berengal> But it needs an infinite datatype with quick lookup
16:39:41 <eu-prleu-peupeu> bah, it doesnt work :S
16:39:45 <Berengal> Which one would be best?
16:39:49 <Berengal> BST?
16:39:52 <Berengal> Heap?
16:40:05 <eu-prleu-peupeu> IntMap
16:40:38 <Berengal> IntMap is strict, so not infinite
16:40:52 <eu-prleu-peupeu> Array
16:41:05 <mauke> trie
16:42:05 <jedai> Berengal: Trie, look at MemoTrie for instance I think it has what you want (if I understand you correctly)
16:42:29 <Berengal> jedai: It might do what I want...
16:43:02 <Berengal> Basically, I want a map of (Int, Int -> Int) where the values are indexes into the datastructure
16:43:19 <Berengal> Well, indirect indexes...
16:44:04 <Berengal> Or to put it in code: chainList = loeb $ const 0:[(+1).(!!(chain i - 1)) | i <- [2..]]
16:45:54 <Gracenotes> oh, hm, I have a typeclass method called 'getReflective'
16:46:34 <Gracenotes> upon calling it I should transform into a state of deep introspection
16:46:55 <Gracenotes> either that, or return the Double value representing how much light a shape reflects
16:47:29 <ddarius> "Double value"?  You need a BDSF
16:49:58 <Gracenotes> ddarius: hm?
16:52:56 <ddarius> I meant BSDF
16:54:50 <Gracenotes> in my dumbly simple ray tracing world, there are no BSDFs!
16:55:59 <Berengal> BSDF? Big Single Double Float?
16:56:39 <ddarius> Gracenotes: How are you going to simulate velvet textures?
16:56:53 <ddarius> or brushed metal?
16:56:58 <Gracenotes> not at all. yet.
16:57:23 <Gracenotes> an 'ambiguously defined partially reflective surface' will suffice, I think?
16:58:10 <Berengal> Gracenotes: Sounds like a reasonable description of real world materials
16:58:47 <wli> Quad precision (and similar ultiple precision types) would be handy for various things.
17:00:15 <Gracenotes> anyway, I do need to get the point where I've rendered an image
17:01:19 <ddarius> I should add BSDFs to my raytracer.  'a lot easier than adding global illumination.
17:01:44 <Pseudonym> The tricky bit is variance reduction.
17:02:17 <Pseudonym> Actually, have you tried the Metropolis algorithm?
17:02:57 <ddarius> I've read about it.  I haven't bothered trying to implement it, though it's probably what I would try if I ever get that much motivation.
17:03:32 <Gracenotes> I wonder if I can make a ray-tracing EDSL in Haskell
17:04:21 <Pseudonym> Haskell could do with a RenderMan binding.
17:04:22 <Pseudonym> Just saying.
17:07:55 <ddarius> > log (2 - 1.18) / log (2 - 0.52)
17:07:56 <lambdabot>   -0.5061980458516856
17:09:21 <ddarius> > ln 0.52 / ln 1.18
17:09:22 <lambdabot>   Not in scope: `ln'Not in scope: `ln'
17:09:32 <ddarius> > log 0.52 / log 1.18
17:09:34 <lambdabot>   -3.950872645441557
17:09:43 <mauke> > logBase 1.18 0.52
17:09:44 <lambdabot>   -3.950872645441557
17:13:03 <pumpkin> @src logBase
17:13:04 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:13:47 <mauke> :t logBase
17:13:49 <lambdabot> forall a. (Floating a) => a -> a -> a
17:13:50 <mauke> probably a method
17:14:30 <pumpkin> would make sense
17:14:33 <pumpkin> @src Floating
17:14:33 <lambdabot> class  (Fractional a) => Floating a  where
17:14:33 <lambdabot>     pi                                                      :: a
17:14:33 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
17:14:33 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
17:14:33 <lambdabot>     (**), logBase                                           :: a -> a -> a
17:14:44 <pumpkin> @src log
17:14:44 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:14:53 <mle> @pl \b n->(log n) / (log b)
17:14:54 <lambdabot> flip ((/) . log) . log
17:15:10 <Gracenotes> anyway. not expecting too much regarding the performance :\
17:15:28 <pumpkin> that's just (/) `on` log isn't it?
17:15:32 <pumpkin> well, with the params backwards
17:16:44 <mle> :t flip . (/) `on` log
17:16:45 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> c
17:16:45 <lambdabot>     Probable cause: `.' is applied to too few arguments
17:16:45 <lambdabot>     In the first argument of `on', namely `flip . (/)'
17:17:01 <mle> er, wrong thing
17:17:48 <pumpkin> @@ @pl @src on
17:17:49 <lambdabot>  (line 1, column 1):
17:17:49 <lambdabot> unexpected end of input
17:17:49 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:17:56 <pumpkin> @src on
17:17:57 <lambdabot> (*) `on` f = \x y -> f x * f y
17:18:04 <mle> :t flip ((/) `on` log)
17:18:05 <lambdabot> forall a. (Floating a) => a -> a -> a
17:18:06 <pumpkin> @pl (*) `on` f = \x y -> f x * f y
17:18:07 <lambdabot> (line 1, column 12):
17:18:07 <lambdabot> unexpected "="
17:18:07 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
17:18:11 <mauke> where (*) = (/)
17:18:29 <mauke> :t flip (/) `on` log
17:18:30 <lambdabot> forall a. (Floating a) => a -> a -> a
17:19:02 <mle> hm, we need a flip `off` next
17:19:44 <Berengal> @unpl flip `off` next
17:19:44 <lambdabot> (off (\ a b c -> a c b) next)
17:20:14 <Gracenotes> mle: what'd that do?
17:20:58 <Gracenotes> write code with hidden insults? :(
17:21:06 <mauke> @quote you.y
17:21:06 <lambdabot> heatsink says: @pl (\y -> you y off)
17:21:29 <pumpkin> hah
17:22:08 * Gracenotes goes away
17:22:12 <mle> Gracenotes: heh, sorry
17:22:54 <Gracenotes> sort of an analogue of 'off' is liftM2, for functions
17:23:28 <eu-prleu-peupeu> im having problems with reactive when runing compiled code
17:23:49 * PeakerWork hopes Reactive works with 6.10.2
17:23:53 <eu-prleu-peupeu> in ghci it runs fine, but when compiled it is very slow and has huge delays
17:23:59 <Gracenotes> @type liftM2 (.) (flip (.)) (.)
17:24:00 <lambdabot> forall a a1. (a -> a1) -> (a1 -> a) -> a -> a1
17:24:11 <eu-prleu-peupeu> im using 6.10.1
17:24:13 <Gracenotes> @type liftM2 (.) (flip (.)) . (.)
17:24:14 <lambdabot> forall c a b. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:24:20 <Gracenotes> @type on
17:24:20 <uninverted> What does $ do?
17:24:21 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:24:41 <PeakerWork> uninverted: applies a given func with a given arg
17:24:41 <eu-prleu-peupeu> im using reactive-glut
17:24:49 <eu-prleu-peupeu> probably the problem is there
17:24:54 * Gracenotes goes away, really
17:25:03 <PeakerWork> eu-prleu-peupeu: there are bugs in ghc 6.10.1 RTS  that are probably causing your Reactive behavior
17:25:21 <uninverted> PeakerWork: example?
17:25:30 <eu-prleu-peupeu> uninverted: think about it this way: it computes everything to the right, and then it computes everything to the left :P
17:25:50 <PeakerWork> uninverted: print $ "Hello world"      is the same as:     print "Hello world"
17:25:51 * pumpkin doesn't agree with the "and then" bit :)
17:25:59 <eu-prleu-peupeu> :D
17:26:29 <uninverted> So, it's like whitespace? :P
17:26:35 <eu-prleu-peupeu> nahh
17:26:37 <jedai> uninverted: Yes
17:26:45 <PeakerWork> uninverted: its an operator
17:26:48 <jedai> uninverted: But with a very low priority
17:26:49 <pumpkin> the main different being its precedence
17:26:51 <PeakerWork> @src ($)
17:26:51 <lambdabot> f $ x = f x
17:26:53 <mle> a $ b c is like a (b c)
17:27:07 <jedai> uninverted: It's mainly useful to avoid parens
17:27:08 <PeakerWork> uninverted: its used mainly as a syntactic trick to avoid parenthesis
17:27:08 <eu-prleu-peupeu> uninverted: its a replacedment for parenthesis
17:27:54 <jedai> > map (+5) . filter odd . takeWhile (< 10) $ [1..]
17:27:56 <lambdabot>   [6,8,10,12,14]
17:28:11 <uninverted> So, foo $ bar is the same as foo (bar)?
17:28:27 <jedai> uninverted: the same as (foo) (bar)
17:29:04 <uninverted> That makes sense, thanks.
17:29:35 <eu-prleu-peupeu> uninverted: now off to find out what . does
17:30:52 <uninverted> Function composition, right?
17:31:27 <PeakerWork> uninverted: f . g     build a function that applies f to the result of g
17:31:36 <PeakerWork> uninverted: often read as "f after g"
17:31:56 <jedai> PeakerWork: Well it's function composition...
17:32:41 <PeakerWork> Yeah
17:33:14 <eu-prleu-peupeu> now off to find out what <*> does
17:33:19 <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:33:41 <roconnor> @type (<*>)
17:33:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:34:06 <mauke> preflex: remember <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:34:20 * pumpkin hates that processor manuals come in PDFs
17:34:37 <gwern> mauke: <uninverted> ?
17:34:38 <eu-prleu-peupeu> pumpkin: order the pdf :)
17:34:44 <eu-prleu-peupeu> intels are free of charge
17:34:52 <mauke> preflex: quote uninverted
17:34:52 <preflex>  <uninverted> Moving from lisp to haskell with respect to functions is like moving from c to perl with respect to strings.
17:35:08 <pumpkin> eu-prleu-peupeu: that's not the problem, the problem is that the format isn't very machine-readable, yet is clearly generated from a database or some form of data file
17:35:15 <pumpkin> and it isn't intel's that I'm after :)
17:35:18 <eu-prleu-peupeu> ah okey
17:35:21 <pumpkin> I have the pdf of the one I want already
17:35:26 <gwern> @remember uninverted Moving from lisp to haskell with respect to functions is like  moving from c to perl with respect to strings.
17:35:27 <lambdabot> It is stored.
17:35:28 <gwern> @flush
17:35:35 <gwern> @quote perl
17:35:35 <lambdabot> ghc says: GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
17:35:50 <mauke> you can't spell properly without perl!
17:35:52 <gwern> @forget ghc GHCi's bytecode generation machinery can't handle 64-bit code properly yet.
17:35:53 <lambdabot> Done.
17:35:56 <gwern> @quote perl
17:35:56 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
17:35:56 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
17:35:56 <lambdabot> he was one of the pugs de
17:35:57 <ddarius> > log (2 - 1.18)
17:35:58 <lambdabot>   -0.19845093872383818
17:36:00 <eu-prleu-peupeu> i hope ghc 6.10.2 fixes my problem with reactive :/
17:36:05 <ddarius> > log 0.52
17:36:07 <lambdabot>   -0.6539264674066639
17:36:17 <ddarius> > log (2 - 0.52)
17:36:18 <lambdabot>   0.3920420877760237
17:36:23 <ddarius> > log 1.18
17:36:24 <lambdabot>   0.16551443847757333
17:36:25 <pumpkin> ddarius: whatcha calculating?
17:38:29 <Gabbie> Heh I always liked the pugs numbering scheme.
17:39:22 <ddarius> > 20500 * 1e-4
17:39:23 <lambdabot>   2.0500000000000003
17:41:45 <Saizan> gwern: why do you hate ghc?
17:45:20 <eu-prleu-peupeu> bye bye
17:51:47 <ddarius> > (log ((2-0.52) / (2-1.18)), log (1.18/0.52))
17:51:48 <lambdabot>   (0.5904930264998619,0.8194409058842373)
17:57:39 <ddarius> > (log ((2-1.18) / (2-0.52)), log (0.52/1.18))
17:57:41 <lambdabot>   (-0.5904930264998619,-0.8194409058842373)
17:59:00 <ddarius> > (log ((2-0.66) / (2-1.33)), log (1.33/0.66))
17:59:01 <lambdabot>   (0.6931471805599453,0.7006943861953282)
18:11:31 <L11> I am getting non-exhaustive patterns in this code: http://pastebin.com/m15fd141a
18:11:35 <L11> can't seem to figure out why :/
18:11:41 <whoppix> @index dropwhile
18:11:42 <lambdabot> bzzt
18:12:19 <vav> whoppix: Data.List, Prelude -- dropWhile
18:12:29 <whoppix> ah. thanks.
18:13:20 <gwern> Saizan: same reason I hate america; too many hot dogs
18:13:26 <pumpkin> lol
18:13:33 <pumpkin> zomg you hate america!!!
18:13:55 <Saizan> L11: consider the case where one list is empty and the other contains more than one element
18:13:58 <jedai> L11: what happen if you have a list of two elements and an empty list ? This is not covered by your pattern
18:14:54 <jedai> L11: instead of merge [] [] = [] and the next two lines, you can replace by :
18:15:10 <jedai> merge xs [] = xs
18:15:10 <jedai> merge [] ys = ys
18:15:17 <adamvo> even ghc figures one of the patterns out as:  [] (_ : (_ : _))
18:15:26 <adamvo> interestingly
18:17:13 <Saizan> yeah, what's the flag for warning about incomplete patterns?
18:17:31 <mauke> -Wall :-)
18:17:53 <dolio> -fwarn-incomplete-patterns?
18:18:46 <dolio> I don't really understand why that's an -f instead of a -W.
18:19:06 <Berengal> -f = flag
18:19:15 <Saizan> they are all -f, no?
18:19:22 <dolio> -Wall isn't. :)
18:20:02 <Saizan> uhm, yeah, something like -X for warnings makes more sense
18:20:22 <adamvo> nooo, -X is for eXtensions
18:20:24 <Berengal> I thought -X was for language extensions
18:20:43 <dolio> Yeah, but -W could be for warnings.
18:21:04 <Saizan> exactly.
18:21:11 <Berengal> Are we arguing about the logic behind ssentially arbitrary names?
18:21:16 <Berengal> essentially*
18:21:35 <Saizan> we're not arguing
18:21:39 <MyCatVerbs> -W is the THE WHO! THE WHO! THE WHO! You're supposed to chant it while you smash your type system into a million tiny pieces at the end of the stage.
18:21:44 <Berengal> Discussing then...
18:21:45 <Saizan> we're just noting that they could be less arbitrary
18:21:52 <romildo> How do I get a haskell evaluated here in this channel?
18:22:02 <romildo> I mean, a Haskell expression.
18:22:03 <MyCatVerbs> > "Hello, world!"
18:22:04 <lambdabot>   "Hello, world!"
18:22:04 <Berengal> romildo: >
18:22:16 <romildo> > 2+3
18:22:17 <lambdabot>   5
18:22:26 <Saizan> and have explicit "namespaces" instead of ones encoded in names, like the "warn-" prefix
18:23:21 <romildo> > Berengal, and how should a module be imported prior to evaluation of an expression here?
18:23:22 <lambdabot>   <no location info>: parse error on input `,'
18:23:37 <romildo> and how should a module be imported prior to evaluation of an expression here?
18:23:44 <mauke> romildo: no
18:24:15 <romildo> is this actions of this channel described somewhere?
18:24:31 <Berengal> > let f i = if even i then div i 2 else i*3+1 in take 10 $ loeb $const 0:[(+1).(!!f i-1) | i <- [2..]]
18:24:32 <lambdabot>       The operator `!!' [infixl 9] of a section
18:24:32 <lambdabot>          must have lower prec...
18:24:35 <MyCatVerbs> romildo: you can't import modules on the fly in lambdabot. But she has all the most common ones imported by default already.
18:24:37 <dolio> Apparently just -W turns on several -f warnings, but not all of them.
18:24:44 <romildo> > matchRegex (mkRegex "[:alpha:]") "b"
18:24:46 <lambdabot>   Not in scope: `matchRegex'Not in scope: `mkRegex'
18:24:49 <Berengal> > let f i = if even i then div i 2 else i*3+1 in take 10 $ loeb $const 0:[(+1).(!!(f i-1)) | i <- [2..]]
18:24:50 <lambdabot>   [0,1,7,2,5,8,16,3,19,6]
18:25:13 <MyCatVerbs> :t loeb
18:25:14 <lambdabot> forall (f :: * -> *) b. (Functor f) => f (f b -> b) -> f b
18:25:24 <Berengal> @list
18:25:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:25:33 <Berengal> ^^ lambdabot commands
18:25:34 <dolio> -Wall leaves some out, too. And then -Werror turns warnings into errors.
18:26:00 <MyCatVerbs> -Wplease-just-refuse-to-compile-my-code-i-really-mean-it
18:26:02 <romildo> > Text.Regex.matchRegex (Text.Regex.mkRegex "[:alpha:]") "b"
18:26:04 <lambdabot>   /tmp/3719281302371157301:70:32:
18:26:04 <lambdabot>      Not in scope: `Text.Regex.matchRegex'/...
18:26:52 <Berengal> loeb is fun...
18:27:28 <romildo> On my system, after importing Text.Regex in ghci, I get:
18:27:29 <romildo> Prelude Text.Regex> matchRegex (mkRegex "[:alpha:]") "b"
18:27:29 <romildo> Nothing
18:27:58 <romildo> Why does this pattern matching fail?
18:28:37 <mauke> romildo: 'b' is not a member of "ahlp:"
18:28:37 <MyCatVerbs> Looks like Text.Regex doesn't implement the named character classes bit of POSIX regular expressions.
18:29:27 <romildo> mauke, why not? From the wikipedia: [:alpha:] 		[A-Za-z] 	Alphabetic characters
18:29:49 <mauke> I hope that's in the context of character classes
18:29:54 <mauke> otherwise it would be wrong
18:30:27 <romildo> It is under the section: POSIX character classes
18:30:42 <mauke> romildo: "POSIX character classes can only be used within bracket expressions."
18:30:46 <romildo> http://en.wikipedia.org/wiki/Regular_expression#POSIX_character_classes
18:32:54 <romildo> A thought that [:alpha:] was *a character class* it could be used anywhere a character class can be used.
18:33:37 <romildo> But a more complete read of the wikipedia makes it clear.
18:34:19 <wli> I've got some of an algoirithm to break up squarefree polynomials in GF_{p^n}[x] into factors whose irreducible factors are of equal degree, but am missing termination conditions.
18:34:57 <Pseudonym> Obviously the termination conditions are when the factors are irreducible.
18:35:15 <Pseudonym> That was terribly unhelpful, wasn't it.
18:35:22 <wli> Pseudonym: And wrong to boot.
18:35:43 <Pseudonym> Oh, true, because you want equal degrees.
18:36:24 <wli> If the irreducible factors could be directly determined I'd just do that instead of this as a preparation pass for Cantor-Zassenhaus.
18:37:06 <wli> I've got some stuff that is unclear how to prevent from becoming brute force.
18:37:21 <Pseudonym> I wonder if it's unavoidable.
18:37:28 <MyCatVerbs> romildo: matchRegex (mkRegex "[[:alpha:]]") "b" -- does just what you want.
18:37:30 <Pseudonym> In the sense that the problem is NP-something.
18:37:32 <tromp> > product [2,3,5,7,11,13,17]
18:37:33 <lambdabot>   510510
18:37:59 <wli> Basically find an element of order less than that of the whole multiplicative group of GF_{p^n}[x]/(f(x)), say g(x) of order k, then gcd(g(x)^k-1, f(x))
18:38:11 <MyCatVerbs> Pseudonym: "hard".
18:38:29 <wli> Pseudonym: The problem is soluble in some super-fast manner for polynomials over Galois fields, but I just don't know the algorithm.
18:38:38 <Pseudonym> MyCatVerbs: Wasn't sure if it was "hard", "complete", or "co-hard", or whatever.
18:40:23 <c_wraith> wli: I did this in my computer algebra class..  It was a pretty trivial algorithm as I recall.
18:40:42 <wli> c_wraith: yay! pray tell how it's done
18:41:48 <c_wraith> wli: If my memory is anything near correct, it involves the GCD of the derivative of the polynomial and the polynomial itself
18:42:07 <c_wraith> wli: But you have to ensure the polynomial is square-free first
18:42:16 <wli> c_wraith: um, that would be the squarefree factorization, wouldn't it?
18:42:28 <MyCatVerbs> Pseudonym: "NP-hard" is "all problems in NP can be reduced to this one". "NP-complete" is "NP-hard, and also within NP".
18:42:32 <Pseudonym> Yeah, that _is_ how you ensure a polynomial is squarefree.
18:42:33 <wli> c_wraith: if it's squarefree then gcd(f(x),f'(x)) = 1
18:42:37 <Pseudonym> MyCatVerbs: I know what they mean.
18:42:42 <Pseudonym> I didn't know what this problem was.
18:42:49 <MyCatVerbs> Pseudonym: oh, I see, sorry.
18:43:16 <c_wraith> wli: Bah.  Am I remembering the wrong part of it?  But the remainder of the algorithm was trivial, too.
18:43:27 <wli> Well, there's the case where f'(x) = 0 for nonconstant f, but in that case, one just takes the p-th roots of all the coefficients and divides all the powers by p.
18:43:56 <wli> c_wraith: That part is the squarefree factorization done before the part I'm on about (ensuring all irreducible factors are of equal degree).
18:44:34 <c_wraith> Hmm.  I wonder if I still have my notes/books/homework from that class
18:46:55 <pumpkin> maxote: you around?
18:48:54 <c_wraith> hmm.  Can't find my work from that course, and I recall the prof telling me the book wasn't worth keeping, as it was horrible.
18:50:06 <wli> Well, the order of the multiplicative group of GF_{p^n}[x]/(f(x)) is just p^{n(\deg(f)+1}-1, which is not prime, so any element with prime order will do. Find an element of nonzero order. If it's of order q where q is prime then gcd(g(x)^q - 1, f(x)), otherwise if it's of composite order k let q be the smallest prime divisor of k and h(x) = g(x)^(k/q) is the element to consider and do gcd(h(x)^q-1,f(x))
18:50:08 <centrinia__> wli, What is wrong with using Berlekamp's algorithm?
18:50:26 <wli> centrinia: It's reputedly slower.
18:51:25 <wli> (obviously if g(x) turns out to be a zero divisor just gcd with g).
18:52:04 <wli> c_wraith: The trick with this is that I'm not sure how to guarantee forward progress.
18:52:21 <wli> c_wraith: At least not without effectively resorting to brute force for a suitable g(x).
18:52:44 <c_wraith> I think we just used Berlekamp's algorithm.  I recall it was something really simple.
18:53:33 <wli> Berlekamp's algorithm needs solving of homogeneous systems of linear equations, which is not simple.
18:54:01 <centrinia__> Why isn't it simple?
18:54:32 <wli> What I'm trying to figure out is supposed to be really easy once you know how to do it, and then the actual Cantor-Zassenhaus part is supposed to be simpler, too.
18:54:49 <wli> (Not just easy, but very fast.)
18:58:50 <wli> The only "problem" here is lack of documentation. :(
19:04:57 <wli> Hey, at least the Grobner code seems to be working.
19:08:51 <centrinia__> wli, I found an algorithm for performing distinct degree factorization.
19:08:54 <wli> I think you can do a search over all the divisors of p^{n(\deg(f)+1}-1 to see if f(x)/gcd(f(x)^d, (f(x)^d)') is anything interesting.
19:09:08 <wli> centrinia: Yay!
19:10:04 <centrinia__> The product of all irreducible polynomials in F_q[x] of degree d should be X^{q^d}-X
19:10:50 <centrinia__> s/of degree d/of degree up to and including d/
19:11:00 <romildo> Is it possible to abreviate the expression:
19:11:01 <romildo> do x <- action
19:11:01 <romildo>    case x of
19:11:01 <romildo>      pat1 -> expr1
19:11:01 <romildo>      pat2 -> expr2
19:11:16 <romildo> that would ommit the do and would integrate the action into the case expression
19:11:37 <wli> centrinia: I found it.
19:11:39 <sjanssen> romildo: the only other alternative is: action >>= \x -> case x of ...
19:11:45 <romildo> Something like:
19:11:46 <romildo> caseM action of
19:11:46 <romildo>   pat1 -> expr1
19:11:46 <romildo>   pat2 -> expr1
19:11:51 <wli> centrinia: Awesome!
19:11:54 <sjanssen> nope, no such thing
19:11:59 <centrinia__> That should be sufficient. :)
19:12:51 <Gracenotes> romildo: sometimes there is built-in stuff you can do, lifting values into case-functions like maybe or either
19:12:54 <roconnor> > 80/15
19:12:55 <lambdabot>   5.333333333333333
19:13:44 <Gracenotes> or just lifting into case expressions with liftM.. or just what sjanssen said
19:14:39 <wli> centrinia: Yeah, it turned out to be dirt simple as expected. ;)
19:15:05 <centrinia__> It is fast too. ;)
19:15:20 <wli> Next, the rest of Cantor-Zassenhaus, then after that, using Cantor-Zassenhaus on multiple primes (or something) to try to factor in Z[x].
19:16:34 <romildo> See http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2162#a2162
19:16:57 <romildo> That is at the end of a do expression.
19:17:43 <romildo> I have noticed that frequently I have to write a do expression to execute an action, and then examine the its result in a case expression.
19:17:59 <romildo> I thought it could be abbreviated somehow.
19:19:37 <Cale> romildo: well, you can use >>= of course, but that's not a whole lot shorter
19:20:00 <Cale> dialogRun d >>= \resp -> case resp of ...
19:20:12 <wli> centrinia: Now to figure out Cantor-Zassenhaus, then how to apply Cantor-Zassenhaus to factoring in Z[x], then how to apply factoring in Z[x] to factoring in algebraic number fields.
19:20:58 <centrinia__> Finally, figure out how to apply factoring in algebraic number fields to factoring in Z.
19:21:03 <wli> conal: This is a real SOB.
19:21:04 <romildo> Cale, explicitly using the binding operator (>>=) does not make it easier to read, I think. I still preffer the do notation.
19:21:10 <Cale> romildo: Me too.
19:32:50 <PetRat> Anyone here?  (A n y  o n e  h e r e ...) (A     n    y      o    n   e       h       e      r       e  .    .         .                  . )
19:33:19 <pumpkin> um
19:33:42 <PetRat> Question: what package would handle ordered, self-balancing binary trees?
19:34:00 <mauke> Data.Set?
19:34:01 <jmcarthur> PetRat: Data.Set :)
19:35:05 <Question> best nick evar
19:35:34 <PetRat> Interesting. I usually think of "sets" as unordered, but it does look from the API that it does what I want.
19:36:08 <jmcarthur> PetRat: it requires Ord because it is implemented as a binary tree
19:36:32 <jmcarthur> PetRat: so that restriction is really an unfortunate abstraction leak
19:37:27 <PetRat> I  want to scan the members in order, so that helps.
19:37:40 <ddarius> jmcarthur: The Data.Set abstraction doesn't let you inspect the ordering, i.e. you can't get the elements out "in order" (though toList does do that currently, I believe, but that is not guaranteed)
19:37:59 <jmcarthur> PetRat: what ddarius just said seems relevant to you :\
19:38:12 <PetRat> Okay, then I really need an ordered binary tree.
19:38:29 <PetRat> I need to retrieve keys, basically. Keys will be Doubles.
19:38:54 <mauke> keys? do you also have values?
19:38:54 <ddarius> Data.Map has toAscList
19:39:02 <jmcarthur> PetRat: there is an avl tree package i believe
19:39:12 <jmcarthur> PetRat: but yeah, if you are making a map, Data.Map already has that ;)
19:39:25 <ddarius> Apparently, Data.Set does too, so I guess you can use that.
19:39:26 <PetRat> Have values. Basically entires are (Time,Object)
19:39:27 <pumpkin> PetRat: keys of doubles?
19:39:27 <mauke> ddarius: wtf
19:39:35 <pumpkin> PetRat: that might be a little unreliable
19:39:41 <mauke> ddarius: then what's Set.toAscList?
19:39:46 <jmcarthur> PetRat: yeah, you want Data.Map then!
19:40:14 <centrinia__> pumpkin, Doubles have a definite ordering.
19:40:24 <pumpkin> yeah, but depending on whether he's doing arithmetic on them
19:40:30 <pumpkin> he may not be able to find what he put in
19:40:54 <jmcarthur> centrinia__: seems to me that a binary tree storing key/value pairs would allow the same key to point to multiple values
19:41:00 * ddarius is not sure why there's a requirement for a "self-balancing binary tree"
19:41:04 <PetRat> Yes, I want to retrieve the value stored at a particular key.
19:41:25 <PetRat> ddarius: this will be frequently modified and searched during the application.
19:41:51 <jmcarthur> PetRat: you definitely want Data.Map. it's implemented as a red-black tree, if i recall correctly, and already has the key->value mapping implemented for you
19:41:55 <ddarius> PetRat: What is the interface you want (which can include time complexities)?  Who care's how it is implemented.
19:42:06 <Saizan_> PetRat: it's more sensible to ask for a dictionary with O(log n) (or something) insert and lookup
19:42:08 <ddarius> jmcarthur: Data.Map is a size-balanced tree.
19:42:18 <jmcarthur> ddarius: oh, like an AVL tree?
19:42:31 <ddarius> jmcarthur: AVL is height-balanced.
19:42:36 <jedai> jmcarthur: Not exactly
19:42:43 <jmcarthur> oh then i have more balanced tree algorithms to learn
19:42:45 <centrinia__> pumpkin, He could make an Ord instance that represents intervals. If he is careful to not insert overlapping intervals into his Map, then there shouldn't be serious problems even with floating point arithmetic errors.
19:42:59 <PetRat> Operations will include: retrieving all values with keys in  a range...
19:43:08 <PetRat> ...deleting values with keys in a range...
19:43:24 <jmcarthur> what is size balancing? just memoizing the number of elements on each side of a branch?
19:43:32 <PetRat> .. inserting new keys...
19:43:37 <jmcarthur> and using that for rotations, obviously?
19:43:42 <jedai> PetRat: I think Map should be fine for all that
19:43:53 <PetRat> If possible all operations should be no slower than O(log n)
19:43:55 <Saizan_> jmcarthur: something like that
19:44:22 * jmcarthur just checks wikipedia
19:44:26 <jedai> IIRC there is a split operation that separates a Map in keys inferior and keys superior to a given value
19:44:34 <PetRat> Is "self-balancing" the right term or is it "size-balancing"?
19:45:35 <jmcarthur> PetRat: self-balancing doesn't really describe what you want in an interface. you just want some guarantees on time complexity, right?
19:46:00 <Saizan_> size-balancing is a particular technique of self-balancing, however
19:46:11 <PetRat> jmcarthur: that's true
19:46:33 <jedai> @type M.split
19:46:34 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
19:47:08 <centrinia__> How do you join two Maps where one Map's smallest key is larger than the other Map's largest key in O(log (n+m)) time?
19:47:10 <PetRat> To remove values in a range, I wonder if it's faster to make two splits and rejoin, or remove them one-by-one?
19:47:15 <jedai> PetRat: With that it is quite easy to get your "range" operations
19:47:55 <jedai> PetRat: I would say two splits and rejoin
19:48:12 <pumpkin> centrinia__: just saying he should be careful :P
19:49:00 <jmcarthur> hmm... Map may not have an optimized join for that case
19:49:08 <jmcarthur> a fingertree may be more appropriate
19:49:13 <jmcarthur> of some sort
19:49:21 <jmcarthur> or a custom binary tree, at least
19:49:44 <PetRat> Well, it may be premature to talk time.
19:49:59 * jmcarthur looks up Data.Map's documentation for a good join
19:50:02 <PetRat> Who is that said: "Make it work. Make it right. Make it fast."
19:50:45 <jmcarthur> well, i mean the join operation may have a suboptimal algorithmic complexity for that case, where you know the largest key of one map is smaller than the smallest of the other
19:50:53 <centrinia__> jmcarthur, I think that union and repeat inserts can work.
19:51:35 <jmcarthur> well, with a fingertree you can get constant time append
19:52:14 <PetRat> By the way, I know I'm going to sound like I'm brown-nosing, but I recently discovered the Haskell community and I enjoy the knowledge, skill, and style.
19:52:19 <jmcarthur> oh, hmm, yeah i can see union being acceptable, actually
19:52:45 <PetRat> I have no advanced degree in CS and my day job is boring utilitarian programming in Python.
19:53:29 <PetRat> The Python community is okay, but a lot of awkwardly written documentation and it's hard to find books of consistent quality.
19:53:36 <jmcarthur> hey, that's nicer than c at least
19:53:57 <kmeyer> pff
19:54:07 <kmeyer> C you only need one book, K&R2
19:54:54 <PetRat> Someone wrote that Haskell is so pure largely because it hasn't been a success yet, or something to that effect.
19:55:14 <jmcarthur> haskell does benefit from its relative lack of success since it means we can be more mobile
19:55:29 <p_l> It's lazy success ;-)
19:55:30 <jmcarthur> but that is beginning to change now, in my opinion
19:55:35 <PetRat> haskell also seems to attract a consistent mindset of person
19:56:03 <PetRat> I know people at work who would hate haskell... would touch it once and run in the other direction. And other people love it.
19:56:04 <tromp> haskell is deteriorating
19:56:11 <tromp> in terms of avoiding success
19:56:27 <jedai> In the last three years it seems that Haskell has grown much
19:56:37 <PetRat> It's kind of self-selecting in attracting people
19:56:50 <jmcarthur> yeah, there are now enough programs and libraries written in haskell that major language changes would break a lot of work
19:56:55 <PetRat> I can guess that Haskell is growing... I discovered books about it at Borders.
19:57:14 <tromp> wow. was in borders today, forgot to check for it:(
19:57:26 <jmcarthur> PetRat: if you have seen hackage, consider that it didn't even exist a couple years ago!
19:57:26 <jedai> Whether this is a good or a bad thing... It seems to me the community is still pretty nice
19:57:35 <PetRat> Also for the first time a reference to Haskell came up at work, with regard to its benefit for multi-core processors.
19:57:39 <bremner> @slap jedai
19:57:39 <lambdabot> stop telling me what to do
19:57:51 <jedai> bremner: Na ! ^^
19:58:17 <bremner> ok, I'll be nice then
19:58:32 <centrinia__> Hmm, the union function might work in O(log n - log m) time.
19:59:29 <PetRat> Haddock says union is O(n + m)
19:59:40 <jmcarthur> PetRat: that is probably worst case
19:59:53 <centrinia__> That's the worst case time for Maps that might overlap.
20:00:01 <PetRat> oh, I see. The question is for our case for non-overlapping Maps.
20:00:07 <jedai> PetRat: I think centrinia was speaking about your case where Maps don't overlap at all
20:00:50 <centrinia__> Here is a paper about an implementation of a fast concatenation function: http://groups.csail.mit.edu/mac/users/adams/BB/92-10.ps
20:00:58 <PetRat> Now, at work we would resolve this question via empirical testing, which is not very satisfying for a computer scientst (and not reliable)
20:03:51 <PetRat> Does that paper describe the Data.Map implementation?
20:04:30 <centrinia__> Data.Map.union uses the Hedge Union from that paper.
20:06:26 <jmcarthur> i was wrong about fingertree concatenation. it's actually O(log(min(m,n))), not constant time
20:07:01 * centrinia__ gives jmcarthur the finger. :(
20:07:32 <pumpkin> aw
20:08:15 * jmcarthur gives centrinia__ ... a tree?
20:08:30 <centrinia__> Okay, Data.Map.join from ghc-6.10.1 is essentially the same as concat3 in that paper.
20:22:48 <PetRat> I'd also like to do a lazy, in-order traversal of the tree starting at a particular key. I'm not sure Data.Map can do that.
20:23:54 <pumpkin> a zipper could do it
20:25:10 <PetRat> what is a zipper?
20:25:40 <pumpkin> http://haskell.org/haskellwiki/Zipper
20:25:45 <pumpkin> not sure there's one for Data.Map out there
20:26:10 <vixey> PetRat: I suppose that if you have a datastructure then a zipper for that structure is another datastructure which represents a torn open version of the original
20:27:32 <vixey> "    Oleg Kiselyov's zipper-based file server/OS where threading and exceptions are all realized via delimited continuations. " -- Every good idea you have.. someone already thought of it (and better)
20:28:37 <PetRat> If I was going to implement a binary tree myself, it's easy to do an in-order traversal. So the question is: how can I get all the benefits of Data.Map?
20:30:46 <Saizan_> an in-order traversal is going to be O(n) so you could still use split and then toAscList
20:31:08 * mjrosenb feels like making anothe attempt at installing ghc
20:31:10 <PetRat> I should clarify. A lazy in-order traversal beginning with a specific node.
20:31:33 <Saizan_> node? not key?
20:31:59 <PetRat> key. (I'm just thinking of each node as a key-value pair)
20:32:27 <PetRat> After locating the first key, it should proceed in constant time because the number of actual (key,value) I need is approximately constant.
20:32:34 <Saizan_> so, a traversal of all the keys larger than it? with the value?
20:32:42 <PetRat> Saizan: yes
20:33:28 <PetRat> well, I'm not sure if this is what you mean, but what I want is a lazy traversal because I only expect to need approx constant number of (key,value)
20:33:47 <PetRat> but don't know how many ahead of time, and not without processing the (key,value) as I receive them
20:34:20 <Saizan_> > (\(a,b,c) -> M.toAscList c) $ M.split 5 $ M.fromList $ zip [1..10] ['a'..]
20:34:22 <lambdabot>   Couldn't match expected type `(t, t1, M.Map k a)'
20:34:30 <Saizan_> ?type M.split
20:34:32 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (M.Map k a, M.Map k a)
20:34:41 <Saizan_> > (\(a,c) -> M.toAscList c) $ M.split 5 $ M.fromList $ zip [1..10] ['a'..]
20:34:42 <lambdabot>   /tmp/7525878988516166074:70:59: Not in scope: `M.toAscList'/tmp/75258789885...
20:35:07 <Saizan_> something like that.
20:35:15 <PetRat> is toAscList lazy?
20:36:04 <Saizan_> yes
20:36:09 <PetRat> maybe that's a dumb question. Is pretty much any O(N) operation on a Map lazy?
20:36:18 <PetRat> Oh, well that's all I need, then.
20:37:05 <PetRat> Like filter, map,
20:37:28 <mjrosenb> anyone know about ghc, and what i would need to do to get it working?
20:38:15 <Saizan_> operations that change the keys are not that lazy since they can change the shape of the Map
20:38:22 <Saizan_> the others are
20:39:02 <Saizan_> mjrosenb: what problem are you getting?
20:42:53 <mjrosenb> Saizan_: i'm trying to bootstrap ghc
20:43:31 <mjrosenb> and iirc, it's treating some file descriptors as 64 bits
20:43:36 <mjrosenb> when they should be 32 bits
20:44:24 <mjrosenb> ghc-6.8.3: fd:30064771072: lazyRead: invalid argument (Bad file descriptor)
20:44:28 <mjrosenb> ghc-6.8.3: fd:34359738368: lazyRead: invalid argument (Bad file descriptor)
20:45:04 <mjrosenb> which are 0x7 0000 0000 and 0x8 0000 0000
20:45:13 <Saizan_> ah, i can't help on that, maybe ghc-users@ is appropriate
20:45:19 <mjrosenb> kk
20:45:56 <mjrosenb> Saizan_: ghc-users does not seem to exist
20:50:11 <mjrosenb> Saizan_: should i ask in #ghc?
20:50:48 <mauke> he said ghc-users@, indicating a mailing list
20:52:33 <Saizan_> mjrosenb: #ghc is also a valid place, i don't expect much life in it at the moment though
20:54:14 <mjrosenb> mauke: oic....
20:59:13 <vixey> > 4^4
20:59:15 <lambdabot>   256
21:00:12 <centrinia__> > iterate (^4) 1
21:00:13 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:00:22 <vixey> > iterate (^4) 4
21:00:23 <centrinia__> > iterate ((^) 4) 1
21:00:24 <lambdabot>   [4,256,4294967296,340282366920938463463374607431768211456,13407807929942597...
21:00:39 <lambdabot>   thread killed
21:02:46 <harovali1> is thinking about a haskell like unix shell somewhat contradictory with the referentially transparent nature ?
21:03:31 <Cale> harovali1: I don't think so.
21:04:06 <harovali1> Cale: maybe modeling "deleting a file" like a monad or such ?
21:04:26 <Cale> Yeah, or constructing pipelines with various other combinators
21:04:33 <Cale> Have you seen the library HSH?
21:04:38 <harovali1> nope
21:04:52 <Cale> It's not ideal for interactive use
21:05:07 <Cale> But nice for shell-programming type tasks
21:05:14 <Cale> http://hackage.haskell.org/packages/archive/HSH/1.2.6/doc/html/HSH.html
21:05:16 <harovali1> i'm thinking about something interactive too ....
21:05:28 <harovali1> i'll check that
21:06:05 <Cale> It might be good for ideas anyway
21:06:59 <harovali1> thanks Cale
21:07:08 <Cale> No problem
21:57:15 <mmorrow> @yarr
21:57:15 <lambdabot> I want me grog!
21:57:40 <mmorrow> @. vixen yarr
21:57:41 <lambdabot> Beer, it's so much more than just a breakfast drink!
21:58:47 <fynn> hey, I'm thinking of pushing Haskell in our company
21:58:50 <vixey> @yarrrrr
21:58:51 <lambdabot> Unknown command, try @list
21:59:06 <fynn> what's a good "success stories with Haskell in the Real World" link?
21:59:51 <mmorrow> fynn: http://haskell.org/communities/
21:59:57 <fynn> (specifically, I'm thinking of proposing it for some performance-intensive routines, mostly numeric calculations)
22:01:01 <mmorrow> fynn: http://industry.haskell.org/
22:01:03 <mmorrow> fynn: hmm
22:01:13 <mmorrow> fynn: running on what?
22:02:37 <mmorrow> fynn: one nice approach to that is either using haskell to generate performance-critical code, or to use the ffi to be able to control everything in haskell, while at the same time having the individual performance critical bits in C or something
22:03:09 <QtPlaty[HireMe]> The fact that "foo" is equiverlent to 'f':'o':'o':[] is hardcoded into the parser and not something that is easy to modify.
22:03:33 <mmorrow> fynn: an example of the latter approach would be hmatrix
22:03:57 <fynn> mmorrow: running on a bunch of Linux servers.
22:04:41 <fynn> mmorrow: I'm surprised you're recommending that we write some of the code in C :)
22:04:48 <fynn> writing C is what I'm trying to avoid here.
22:05:18 <fynn> (i.e. I'm proposing we go with Haskell in hope I could prevent the default decision of using C/++ for that)
22:05:52 <pumpkin> 'tis mmorrow
22:06:17 <fynn> http://industry.haskell.org/partners says there are 3 partners, but lists only two.
22:06:23 <mmorrow> fynn: but the thing is, you can use haskell's expressiveness to orchestrate huge computations, say, using LAPACK routines for the individual matrix manipulation functions
22:06:55 <mmorrow> fynn: haskell can import a C function with a single line of code
22:08:04 <fynn> mmorrow: hm, good points.
22:14:04 <mmorrow> fynn: this page too might be useful http://haskell.org/haskellwiki/Haskell_in_industry
22:14:26 <fynn> mmorrow: cool, thanks.
22:14:35 <mmorrow> np :)
22:15:57 <ray> that's the wrong way to look at it
22:16:02 <ray> that page should be called industry in haskell
22:29:58 <pumpkin> so, has anyone heard of the sum-product algorithm and/or tried to implement it in haskell?
22:31:27 <binarylegit> what does the algorithm do?
22:31:37 * vixey hadn't heard of it either
22:31:56 <pumpkin> have you heard of belief propagation in graphical models/factor graphs?
22:32:04 <pumpkin> it's a generalization of that
22:32:14 * pumpkin digs up a paper
22:32:20 <binarylegit> heh, no, sounds a bit complex
22:33:01 <pumpkin> http://www.psi.toronto.edu/~frey/papers/fgspa.ps
22:33:20 <pumpkin> this one is a little more tutorial-y: http://www.psi.toronto.edu/pubs/2001/frey2001factor.pdf
22:33:48 <fynn> mmorrow: out of curiosity: there seems to be claim that current GHC is competitive against gcc, performance wise
22:34:17 <fynn> So in what scenario do you envision resorting to FFIing C from GHC as being desirable?
22:34:18 <pumpkin> fynn: usually not exactly, but definitely within 2x, if you put effort into it
22:35:13 <fynn> pumpkin: *nod*, thing is, we're considering writing some new code in either C or Haskell. so we'd rather avoid FFIing if possible.
22:36:07 <erikc> fynn: it will take a fairly high level of ghc expertise to get the tight numerical kernels you could easily express in C
22:36:20 <erikc> fynn: you also cant access SIMD instructions from GHC yet
22:36:23 <binarylegit> sorry, FFI?
22:36:40 <pumpkin> yeah, the SIMD thing is a pain
22:38:03 <dolio> C memcpy tends to be faster than what you can get GHC to generate, too.
22:38:48 <fynn> hm, OK. that unfortunately narrows the advantage of using Haskell a bit...
22:39:11 <fynn> basically, our other option is to write a bunch of C extensions for CPython, which we are already using heavily.
22:40:04 <fynn> I'd have a strong argument if we could avoid C completely with (the much nicer, language-wise) Haskell.
22:40:31 <fynn> but it seems we may need to write some of the tighter operations in C anyway :|
22:40:34 <pumpkin> how important is speed? and what kind of app is it?
22:40:40 <blackh> fynn: What kind of work is the C code doing? I just thought I would see if I can tell you how easy it would be to make that fast in Haskell.
22:41:10 <fynn> pumpkin, blackh: we're doing numeric calculations of very large arrays of numbers.
22:41:21 <pumpkin> hmm, sounds like a job for uvector if you stick with haskell :P
22:41:34 <fynn> currently we're getting away with CPython + numpy since we don't have that much data.
22:41:35 <pumpkin> but it also sounds like a job for SIMD instructions, which you don't get
22:42:14 <pumpkin> but uvector is quite nice
22:42:20 <pumpkin> I've done a lot of number crunching with it
22:42:33 <fynn> tbh (and hopefully that won't come off as inflammatory) we may use Python + C for now, and wait for GHC and the entire Haskell toolchain to mature a bit over the next year or two.
22:42:58 <fynn> I love Haskell, but I heard some horror stories about how difficult the toolchain is atm.
22:42:59 <mmorrow_> dolio: libc memcpy uses prefetching i believe
22:43:01 <pumpkin> not inflammatory, but it's up to you :P
22:43:06 <pumpkin> fynn: the toolchain? :o
22:43:12 <pumpkin> ghc --make? :P
22:43:18 <dolio> mmorrow_: You mean it's not just a for loop?
22:43:22 <mmorrow_> dolio: no
22:43:25 <dolio> :)
22:43:26 <mmorrow_> well, it is
22:43:26 <pumpkin> it's way more complicated than a regular loop
22:43:28 <erikc> you can always replace the Python side with Haskell at a later date
22:43:29 <fynn> pumpkin: things like profilers, debuggers (I'm not even mentioning IDEs ;)
22:43:32 <mmorrow_> but with prefetching
22:43:33 <pumpkin> oh, he was kidding :P
22:43:47 <pumpkin> most standard memcpys are ridiculous
22:43:51 <blackh> fynn: It is possible to get this kind of code about half the speed of C with some effort. If you just bang it out without thinking about speed, it might be 5 to 10 times slower.  The reason for this is to do with avoiding memory allocation.
22:44:08 <blackh> fynn: Essentially, you have to understand what makes GHC allocate memory.
22:44:20 <dolio> Speaking of uvector, dons needs to actually release a 0.2 version some time.
22:44:47 <pumpkin> dolio: I think he's waiting for me to do a couple more things I said I'd do
22:44:49 * mmorrow_ should wrap gcc's __builtin_prefetch and ffi import it
22:44:56 <pumpkin> but I've been too busy to do them >_>
22:44:58 <mmorrow_> then we'll crush!
22:45:03 <dolio> Heh.
22:45:30 <blackh> fynn: GHC has a bit more maturing to do, but I would say that it's pretty good now and I wouldn't hesitate to recommend it for commercial use at this time - except in your case it sounds like performance is just a bit too critical.
22:45:49 <fynn> blackh: right, so it's easier with C, since knowing C means knowing how memory allocation (and all other low-level resource allocation) works.
22:46:49 <dolio> Work is supposed to be happening on code generation, so that may well be significantly better in a year or two.
22:48:31 <blackh> fynn: Quite so - memory allocation in C is direct so you can control performance much easier. GHC optimizes very well, but in some cases it fails to do so and you can spend a lot of time trying to figure it out.  Laziness adds to the complexity of doing this (even though laziness often contributes to making things faster).
22:48:46 <mmorrow_> but the thing is, you can do stuff like
22:48:49 <mmorrow_> .... omgify . trieify . Map.fold (.....) fromList =<< (mapM (getProcId . sendToRemoteServer . foldl' (\m a -> insertWith' c_matmul (fst a) (snd a) m) mempty)) $ mats
22:48:58 <mmorrow_> note the use of the fast C function
22:49:11 <mmorrow_> also note that doing that in C would definitely not be a one-liner
22:49:18 <mmorrow_> c_matmul
22:49:58 <fynn> blackh: *nod*, that's exactly what I heard from people trying to replace C with Haskell, specifically the hardships of performance analysis (towards optimization) due to laziness.
22:50:00 <blackh> fynn: Laziness contributes to optimization by optimizing the memory allocation out of using a lazy list in a "producer/consumer" way. But getting it to actually do this can take some perseverance.
22:50:28 <mmorrow_> (but not to say pure haskell isn't fast of course :)
22:50:36 <fynn> blackh: I imagine those difficulties are mainly about performance instability?
22:51:12 <fynn> i.e. lazy structures unfolding at unexpected-points / common-bottlenecks?
22:52:03 <thoughtpolice> i suppose most people would say it's 'less intuitive' to understand the space-usage characteristics of your code
22:52:49 <thoughtpolice> GHC has good profiling tools though, and at the very least core tells you everything you need to know.
22:53:11 <pumpkin> but debugging it in the common sense of the word is strange
22:53:35 <thoughtpolice> i think overall it pays off in the end because the benefit of a type system combined with purity and such a nice thing as laziness makes it easy to replace parts with faster equivalents
22:53:48 <blackh> That's right - the profiler does work very well, so you have no problem finding where the problem is. The difficulty is in trying to understand what things are optimized well and what things aren't.
22:53:52 <thoughtpolice> and you get more isolated changes
22:54:06 <thoughtpolice> thanks to equational reasoning, you can be confident your code still works.
22:54:10 <mmorrow_> yeah, the type system is the enabling factor in being able to write complex code in a short period of time that works
22:54:26 <fynn> mmorrow_: *nod*, Haskell is an easy sell over C even for people who like it less than me. over Python it's not as easy, though :)
22:54:39 <pumpkin> it's a lot faster than python
22:54:43 <pumpkin> ;)
22:54:57 <thoughtpolice> truly equational reasoning I think is the key
22:55:18 <mmorrow_> fynn: can python use multiple cores?
22:55:19 <thoughtpolice> and purity gives you that, and laziness forces you to keep it.
22:55:21 <blackh> fynn: My experience with Python was that the dynamic typing was unmanageable for a big application.
22:55:24 <fynn> pumpkin: true, but if you're using Python for controller-level code, and C for tight loops, Python isn't affecting performance anyway.
22:55:35 <mmorrow_> (yeah, not to mention it's dynamically typed)
22:55:57 <fynn> mmorrow_: it can if you use multiple processes that communicate :)
22:56:05 <fynn> of course, some problems are awful for that.
22:56:16 <thoughtpolice> isn't there stackless python?
22:56:20 <thoughtpolice> and what about pypy?
22:56:21 <fynn> blackh: we certainly manage that part with a lot of unit-testing.
22:56:24 <mmorrow_> fynn: you can use haskell the same way, but you get in addition to that the type system and compilation to machine code
22:56:28 <thoughtpolice> there were also people working on a branch of CPython
22:56:35 <thoughtpolice> that already has 10% improved performance
22:56:41 <thoughtpolice> and they're hoping to build an llvm backend on it
22:56:48 <fynn> thoughtpolice: stackless is nice, doesn't add that much for performance. PyPy is indeed about 10% faster already.
22:56:54 <mmorrow_> i think the type system is the strongest selling point, personally
22:57:01 <pumpkin> same here :)
22:57:02 <Berengal> You could always use multithreading in the c-code... python doesn't stop you from doing that
22:57:04 <fynn> the last thing you're talking about is the new Google project, Unladen
22:57:09 <thoughtpolice> mmorrow_: types = win!
22:57:09 <pumpkin> especially after trying to do big numerical stuff in matlab ;)
22:57:30 <pumpkin> and running it for half an hour and having it crash because of a silly thing the type system would've caught statically
22:57:36 <fynn> mmorrow_: I sort of agree, with the reservation that I've never used a decent type system for a large system.
22:57:41 <mmorrow> pumpkin: totally
22:57:46 <blackh> fynn: At the beginning my attitude was "We need unit testing anyway, so what does it matter?" but when I wrote a unit test that just constructed an object to check for wrong numbers of arguments in contained objects, I realized that dynamic typing makes a huge amount of unnecessary work for you.
22:58:01 <pumpkin> yeah
22:58:05 <erikc> or you just get a good commercial fortran compiler and throw some openmp pragmas on the matrix code and wipe your hands clean of the matter :)
22:58:09 <mmorrow> fynn: yeah, it's a total pita at first. but once you figure out how to make stuff work, it's priceless.
22:58:15 <pumpkin> and static typing makes things like quickcheck and smallcheck possible
22:58:39 <mmorrow> it also makes things like i-didn't-even-test-this-prog possible ;)
22:58:45 <thoughtpolice> well,
22:58:48 <mmorrow> (not literally, but almost so)
22:59:08 <thoughtpolice> the type system can certainly prevent large classes of errors
22:59:08 <Berengal> Types are invaluable once you're dealing with lists of lists of functions from lists to arrays of functions to maps
22:59:15 <mmorrow> because you only have to test correctness, not bugs
22:59:20 <mmorrow> where  bug := segfault
22:59:21 <fynn> mmorrow: yeah, coming from C++ and Java to Python, I used to think of dynamic typing as pure win. learning about the Haskell type systems, I'm no longer sure :)
22:59:21 <thoughtpolice> and indeed shows your program should not have arbitrary runtime failure due to a type-related issue
22:59:22 <Berengal> Then you need to get a single value out of that...
22:59:49 <thoughtpolice> but the type system doesn't automatically guarantee that well-typed programs don't fail in some way or another at runtime :)
23:00:13 <fynn> i.e. the Haskell type systems looks like something you'd want to use even if you weren't forced to.
23:00:30 <fynn> but anyways, major concern is how few large and complex Haskell systems are out there.
23:00:41 <mmorrow> Berengal: totally. where the type system actually starts to become i-couldn't-do-without-it is once you start manipulating structures that would just be too complicated to even understand without types
23:00:42 <thoughtpolice> lhc's old code base was a perfect example. far too hard to modify, far too hard to extend. it's somewhat "easy" for people to stop taking advantage of the type system at some point or another
23:00:43 <Berengal> I came to Haskell from python, and in I way I found Haskell to be more free of types than python. In haskell you don't need to worry about them at all because the compiler takes care of it for you. In python you need to keep types in your head
23:01:07 <thoughtpolice> fynn: major concern for what?
23:01:20 <Berengal> free from types, would probably make more sense*
23:01:37 <blackh> fynn: I found Haskell's type system is a huge timer saver for a large project (compared with, say, Java), and laziness adds huge power but at a price: There's a fairly big learning curve in how to write your code to handle laziness properly.
23:01:49 <fynn> thoughtpolice: feasibility. we don't want to invest 150 men hours in a Haskell project, only to discover later it was infeasible because of X problem we didn't know about.
23:02:21 <fynn> so a major concern is how little Haskell code there is out there, currently, running in production.
23:02:56 <fynn> afaik, the only Haskell application in common usage is Darcs, and that's not saying much, unfortunately (when even GHC switched to git etc.)
23:03:02 <thoughtpolice> for some reason that sounds like a design issue - "we've come all this way... now what?"
23:03:22 <blackh> fynn: I am writing a huge web application (19,554 lines so far) and Haskell has given me no headaches at all, except for the learning curve.
23:03:34 <blackh> fynn: Now that I am over the learning curve, it's a dream.
23:03:38 <thoughtpolice> i mean, there is the chance you will encounter bugs in GHC
23:03:43 <fynn> blackh: cool. I'd appreciate any links to code online etc.
23:03:51 <thoughtpolice> but that's just part of the game
23:03:56 <blackh> fynn: Unfortunately mine is a commercial secret.
23:03:57 <thoughtpolice> very much a research vehicle, you know.
23:04:22 <fynn> thoughtpolice: agreed, but as a commercial company, that does pose a problem for us :)
23:04:53 <blackh> fynn: It's a very hard question to answer - "When is X ready for prime time?"
23:04:57 <thoughtpolice> fynn: surely, but people out there use it and use it successfully.
23:05:13 <fynn> there's another guy here who's very keen about functional programming, but I suspect we may end up going Erlang, simply because there's so much real world evidence that it works.
23:05:15 <thoughtpolice> i mean, I'm not how sure many conclusive studies there are of the broad usage/installation patterns of haskell code
23:05:17 <blackh> fynn: I think Haskell is pretty much on the cusp.
23:05:17 <pumpkin> blackh: when will you reveal what your huge webapp is?
23:05:22 <thoughtpolice> there are companies out there using it, however
23:05:55 <thoughtpolice> for example, galois does DOD-level research and work (in things like cryptography,) and all their code is written in haskell - even some operating systems
23:06:13 <thoughtpolice> cryptol for example, is used by the NSA and is (according to dons) 70,000 loc
23:06:26 <thoughtpolice> serious business :)
23:06:27 <pumpkin> that's lots of loc for haskell
23:06:31 <fynn> thoughtpolice: yeah, but it's all sort of underground / secret, like blackh's usage. if I want to demonstrate that Python works, I point out some online websites known to be pure Python, and even some applications like Mercurial.
23:06:47 <mmorrow> ghc is 150,000 lines of haskell last i checked
23:06:58 <mmorrow> gcc is over a million (i think)
23:07:00 <blackh> pumpkin: Well, it's pretty much finished except for a long list of bugs.  My partner is handling the marketing, and that could take a few months. It's rather tricky.
23:07:00 <Berengal> ghc is 15 years old...
23:07:03 <fynn> thoughtpolice: with Haskell, I seem to have nothing like that.
23:07:07 <Berengal> That's 10k LOC/year
23:07:21 <pumpkin> blackh: is it something we might end up using?
23:07:49 <pumpkin> is ghc's LOC count considering the literate source files?
23:07:50 <thoughtpolice> fynn: i'm not exactly sure what I can tell you. just that there are people using it and successfully, but there is the chance you could have bugs in GHC or whatnot. but all in all like I said this type of thing needs to be taken into consideration before your 150 man hour investment :)
23:08:02 <mmorrow> pumpkin: yeah
23:08:09 <blackh> fynn: I don't think the fact that Haskell has no major flagship project is due to a lack of capability - it's just that nobody has taken the leap yet.
23:08:11 <fynn> thoughtpolice: yeah, thanks, appreciate the honesty :)
23:08:17 <Berengal> I thought LOC means "lines of code", as in no comments...
23:08:30 <blackh> fynn: Nobody wants to be first - except for me!
23:08:35 <fynn> blackh: I completely agree, but those are the sort of considerations I'll have to face, politically, pushing it here...
23:08:37 <pumpkin> Berengal: most often it's just the output of wc -l on your source dir :P which doesn't do much to cut out comments
23:08:39 <mmorrow> pumpkin: (bear in find i computed this with something like (wc -l "`find . | grep -E "\.l?hs"`") or something
23:08:48 <pumpkin> :P
23:09:05 <fynn> blackh: well, hopefully you make millions and be the Paul Graham-like poster boy of Haskell success ;)
23:09:14 <blackh> pumpkin: It's an application for "general users" - not technical people, if that helps answer your question. :)
23:09:16 <Berengal> pumpkin: You could always remove comments with -E
23:09:51 <Berengal> (Or does that only work for .lhs files?)
23:09:57 <blackh> fynn: That's what I'm hoping - the app has a shiny Haskell logo on it.  I have been sort of promoting Haskell at work myself...
23:10:09 <pumpkin> blackh: I look forward to hearing more when you release it :D
23:10:30 <thoughtpolice> i actually met a haskeller at my uni. recently. a grad student no less.
23:10:34 <fynn> blackh: which web framework (and other major libraries, if it's no secret) are you using, btw?
23:10:38 <blackh> pumpkin: The Haskell community will be the first to know!
23:10:40 <thoughtpolice> i was honestly pretty surprised.
23:10:50 <fynn> thoughtpolice: (sort of reminds me of Python circa 2000...)
23:10:59 <thoughtpolice> hehe
23:11:26 <Berengal> thoughtpolice: There's one at my uni too. He was reqruited by one of my profs to grade one of my papers :P
23:11:36 <Berengal> recruited*
23:11:46 <pumpkin> lol
23:12:07 <pumpkin> we need more haskellers out there
23:12:14 <blackh> fynn: I'm not using a web framework (because I want "total control").  I'm using Berkeley DBXML for the database, hexpat for XML processing, the openid package, and that's pretty much it
23:12:23 <pumpkin> yay, bdb!
23:12:29 * pumpkin is a big fan
23:12:34 <Berengal> first email (from the profs. assistant): "I can't understand your code! I'll have to talk to the prof. about this..."
23:12:34 <pumpkin> bdbxml is pretty cool too
23:12:41 <Berengal> second email (from the haskeller): "Nice monads..."
23:12:46 <pumpkin> lol
23:12:59 <Berengal> (100/100 score)
23:14:09 <blackh> fynn: At work I was asked to do a tricky algorithm, so I said that I could prototype it rapidly in Haskell and translate it to C++. They've been happy about that and Haskell has eliminated all the chores from it.  I am even generating C++ test cases.  It's working really well.  My boss said "I don't want to have to teach the whole team Haskell."
23:15:05 <blackh> pumpkin: I'm definitely a fellow BDB nut.
23:15:31 <blackh> fynn: I did an algorithm for polygon clipping in C++ and Haskell. The Haskell was 10 lines and the C++ was 78. :)
23:15:39 <pumpkin> nice
23:15:45 <Berengal> blackh: At work I was asked to write a database migrator from an old app to the new version. "Four hours in jython" I said. "You code Java good long time!" my boss said :(
23:16:04 <Craig``> hey guys
23:16:10 <opqdonut> bdb rocks :)
23:17:01 <mmorrow> fynn: here's a trivial multithreaded webserver in under 100 lines http://code.haskell.org/~morrow/code/haskell/misc/neutron.hs.html
23:17:18 <fynn> blackh: very cool... :)
23:17:32 <pumpkin> zomg
23:17:33 <pumpkin> import System.IO.Unsafe
23:17:36 <Berengal> mmorrow: top-level go :O
23:17:43 <mmorrow> Berengal: heh
23:17:46 <fynn> btw, does Haskell have a practical job-distribution technique a-la Erlang?
23:17:52 <pumpkin> status = unsafePerformIO (newMVar Starting)
23:17:54 <pumpkin> zomg!
23:17:57 <mmorrow> pumpkin: yeah, that's gone in my current version of that
23:17:57 <pumpkin> global state
23:17:59 <pumpkin> :P
23:18:00 <pumpkin> oh
23:18:15 <opqdonut> fynn: job distribution in which sense? distributed computing?
23:18:19 <mmorrow> (and my current version serves files too ;)
23:18:23 <pumpkin> ooh!
23:18:30 <pumpkin> is it bytestring-based?
23:18:41 <mmorrow> pumpkin: oh yes
23:18:53 <Craig``> I looked at a tut for making a haskell bot last night, it's quite nice, i might attempt to learn haskell again for projects compared to web dev for career study :)
23:18:59 <pumpkin> seems like you could simplify some of that manual spanning and breaking of headers using parsec
23:19:09 <fynn> opqdonut: yeah. let's say I have a calculation that I can parallelize by chunking it to N independent operations. is there a way I can just throw those chunks at any available machine on a network?
23:19:22 <fynn> (which you can do with Erlang)
23:19:24 <mmorrow> pumpkin: oh i already wrote a whole http parser with a modified ReadP that parses right from the Ptr Word
23:19:25 <mmorrow> 8
23:19:30 <blackh> Craig``: We will help you learn Haskell! There will be lots of Great Good going on.
23:19:32 <pumpkin> fynn: well, there is a haskell-erlang library on hackage :P
23:19:35 <mmorrow> and can abort at any time
23:19:49 <pumpkin> fynn: which allows your haskell program to act as an erlang node, but otherwise nope, and I'd love to see someone work on something like that
23:19:58 <pumpkin> mmorrow: wow :o
23:20:03 * Tsion is learning haskell
23:20:09 <Tsion> for Great Good, in fact :)
23:20:18 <pumpkin> everyone is learning haskell!
23:20:19 <lpsmith> tsion:  so what do you think so far?
23:20:20 <Berengal> Who isn't learning Haskell...
23:20:23 <pumpkin> you never know haskell :)
23:20:33 <lpsmith> I'm not learning Haskell at the moment
23:20:37 <mmorrow> pumpkin: i just need to hook it too select/poll or something since i'm using C send/read on raw sockets/fd's
23:20:45 <pumpkin> ack :)
23:20:48 <Craig``> i was wondering, sockets and that, if i can connect to an irc network can i do the same with connecting to msn messenger? or something like that (there's a bot called smarterbot)
23:20:53 <lpsmith> There are still some newer GHC extensions I don't properly appreciate yet :-D
23:21:00 <pumpkin> is there a nice api to select/poll?
23:21:17 <mmorrow> pumpkin: i have a module for Select i adapted from oleg's zfs code
23:21:31 <pumpkin> so the stdlib doesn't have such a facility? :o
23:22:05 <fynn> pumpkin: (you mean, this, right? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/erlang )
23:22:10 <pumpkin> yeah
23:22:16 <pumpkin> but not sure how good it is :)
23:22:17 <mmorrow> pumpkin: i wrote a binding to libev too, actually especially for this webserver, but i never used it for it since i would need to rewrite Network.Socket to actually use it
23:22:25 <mmorrow> :(
23:22:34 <fynn> pumpkin: interesting.
23:22:44 <mmorrow> pumpkin: http://moonpatio.com/repos/hsev/
23:23:03 <pumpkin> cool
23:24:42 <mmorrow> pumpkin: bos and tibbe are working on rewriting ghc's iomanager to use epoll (or whatever's available) iirc
23:24:50 <mmorrow> not sure what the status is on that though
23:24:50 <pumpkin> ooh
23:24:59 <mmorrow> (it currently uses select)
23:25:21 <mmorrow> so is O(1000) for 1000 open Handles
23:25:39 <mmorrow> s/1000/n/
23:25:50 <mmorrow> i think epoll is O(1)
23:27:00 <pumpkin> interesting
23:27:16 <pumpkin> mmorrow: you ever come across sum-product or belief propagation algorithms?
23:27:28 <mmorrow> pumpkin: here's that Select module http://moonpatio.com/repos/c-utils/code/Select.hs
23:27:35 <mmorrow> pumpkin: hmm, no
23:27:47 <mmorrow> pumpkin: i don't even know exactly what those are
23:28:26 <Craig`> reading about haskell most tuts say an advantage of haskell is that if you call a function with the same paremetres everytime then you'll get the same result, aren't most languages like this?
23:28:43 <dolio> No.
23:29:04 <pumpkin> Craig`: int x = 0; int f(int y) { x = x + y; return x; }
23:29:08 <mmorrow> Craig`: int foo(int n){ self_destruct(); return n;}
23:29:43 <Craig`> i see
23:29:45 <fynn> Haskell should come with a dons package, that you just import and dons comes and writes your code for you.
23:29:50 <pumpkin> lol
23:30:52 <mmorrow> there's a "pony" package on hackage
23:30:53 <Craig`> i can prove that "same paremetres" returns the same result is wrong: what if you have a function rand whereas there are 2 parametres: randmin randmax? and it generates a random number lol?
23:31:11 <mmorrow> Craig`: in haskell that would be in IO
23:31:18 <pumpkin> http://en.wikipedia.org/wiki/Belief_propagation
23:31:36 <pumpkin> or it would explicitly take in a seed
23:31:41 <pumpkin> and give you a number and a new seed
23:31:49 <pumpkin> (or do the same thing implicitly wrapped in a monad)
23:31:52 <Berengal> @type random
23:31:54 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
23:32:04 <mmorrow> @type randomIO
23:32:04 <lambdabot> forall a. (Random a) => IO a
23:32:06 <Berengal> @type randomR
23:32:07 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
23:32:14 <vixey> Craig` well you need a random seed
23:32:25 <vixey> Craig`, so it's randoms from the seed 43 are always the same randoms
23:32:30 <Berengal> (seed == RandomGen in haskell)
23:32:35 <vixey> but the seed 46 would be totally different
23:33:18 <mmorrow> , take 10 $ randomRs (0,42::Int) (mkStdGen 9292)
23:33:21 <lunabot>  [27,31,3,20,4,3,0,1,17,14]
23:33:22 <mmorrow> , take 10 $ randomRs (0,42::Int) (mkStdGen 9292)
23:33:24 <lunabot>  [27,31,3,20,4,3,0,1,17,14]
23:33:26 <mmorrow> , take 10 $ randomRs (0,42::Int) (mkStdGen 9293)
23:33:27 <lunabot>  [8,39,19,27,23,22,11,42,19,30]
23:35:56 <pumpkin> is it really true that (IO|ST)Refs can make haskell as good an imperative language as anything else? it seems like it would be like writing a tight inner loop where all your variables are pointers that you need to derefence all the time
23:36:37 <Craig`> gtg
23:37:11 <Berengal> pumpkin: There are other ways of achieving this...
23:37:29 <Berengal> Recursive IO functions for example
23:37:38 <dolio> In what situation are you suing STRefs where you wouldn't be using pointers in C?
23:37:56 <mmorrow> > (\m -> let n = fromIntegral (Map.fold (+) 0 m) in Map.map (\x -> fromIntegral x / n) m) . foldl' (\m a -> Map.insertWith' (+) a 1 m) mempty . take 100000 . randomRs ('a','e') . mkStdGen $ 998277
23:37:58 <lambdabot>   fromList [('a',0.19895),('b',0.19895),('c',0.20184),('d',0.19942),('e',0.20...
23:38:28 <dolio> Using, even.
23:38:41 <pumpkin> oh, I was just wondering about the thing people say about you being able to write imperative algorithms similarly to how you'd do it in c, for example, in haskell... but it seems that since IO or STRefs are boxed, you'd only ever be able to get pointers and would not be able to do tight loops with them
23:39:22 <mmorrow> pumpkin: i'd just use peek/poke with Ptr's personally
23:39:28 <pumpkin> how would recursive IO help over just a regular recursive function?
23:39:39 <pumpkin> mmorrow: but if I wanted a tight "imperative" loop?
23:39:42 <Berengal> pumpkin: I think what most people mean by that is writing code that _looks_ like imperative code.
23:39:48 <pumpkin> without going to memory too often
23:39:58 <Berengal> recursive IO can do IO...
23:39:58 <pumpkin> Berengal: fair enough, I guess :)
23:40:00 <mmorrow> pumpkin: i don't understand
23:41:01 <pumpkin> mmorrow: you want your tight inner loop to be doing lots of stuff on registers and not be sending stuff to and from memory too often... on x86 it's not as big deal but on archs with a decent number of general-purpose regs (or lots of FP regs) it can make a difference
23:41:37 <mmorrow> pumpkin: ah, yeah you'd just have to hope ghc optimizes your code in that case (and you couldn't use mutable vars)
23:42:21 <pumpkin> I was just thinking about cases in which you'd want a super fast version of an "inherently stateful" algorithm, and wanted to stick it in ST
23:42:22 <mmorrow> in ghc-generated asm there aren't any actual asm loops
23:42:31 <pumpkin> hmm?
23:42:36 <pumpkin> oh, oyu mean like rep*?
23:43:55 <mmorrow> like         go: decq %rax; cmpq $10, %rax; jne go
23:44:19 <pumpkin> wait, so what does ghc generate?
23:44:20 <mmorrow> while(x!=10) x--;
23:44:23 <pumpkin> yeah
23:44:41 <mmorrow> it would pass the 'x' via a function param
23:45:06 <pumpkin> ah
23:45:09 <mmorrow> so it'd jmp back there eventually, but only indirectly
23:45:27 <mmorrow> jmp *%rax
23:45:30 <mmorrow> or some such
23:45:47 <pumpkin> mmm a nice predictable jump
23:45:48 <pumpkin> :P
23:45:57 <mmorrow> heh, yeah..
23:50:04 * pumpkin thinks
23:51:04 <pumpkin> I'm just trying to figure out how to do that sum-product thing in haskell without resorting to mutable state
23:52:00 <Berengal> what sum-product thing?
23:52:08 <pumpkin> http://en.wikipedia.org/wiki/Belief_propagation is the closest wikipedia gets
23:52:16 <Berengal> Oh, right...
23:52:23 <pumpkin> :)
23:52:45 <pumpkin> it's basically passing messages along a graph
23:53:05 <pumpkin> updating the values of nodes of the graph, until it stabilizes
23:53:19 <Berengal> I didn't really understand much of that... Then again I haven't slept for 20 hours, so my cognitive functions are probably not fully utilized
23:54:41 <pumpkin> it's like a social gossip network :P two or three people have hard information on a fact so their opinion is set in stone, but they whisper their opinions to their friends, and different people affect the message differently... a week later the network has a general "consensus" after people have received enough messages
23:56:00 <mmorrow> pumpkin: sounds like an implem would be similar to the implem of dataflow analyses in compilers
23:56:03 <pumpkin> but each node's current opinion seems like a stateful thing, unless I want to be passing a modified Data.Map along all the time
23:56:22 <mmorrow> pumpkin: i have some good links, one sec
23:56:29 <pumpkin> ooh thanks :)
23:56:31 * mmorrow tries to remember
23:57:09 <Berengal> Does this message passing happen in ticks?
23:57:13 <pumpkin> yeah
23:57:14 <dolio> I don't really see the issue. If it's a situation like mmorrow's while loop above, then you use tail recursion and an accumulator.
23:57:36 <dolio> If you have mutable structures, you use STRef or something, but you'd have to use pointers in C for that.
23:57:36 <mmorrow> pumpkin: here's one link (have more) http://www.cs.tufts.edu/~nr/pubs/zipcfg-abstract.html
23:57:48 <mmorrow> pumpkin: ghc is moving to using that
23:58:08 <Berengal> I'm guessing the message sent from a node depends on the state it's in?
23:58:12 <pumpkin> dolio: I just wanted to avoid passing around a Data.Map for each iteration of this, as there are lots of iterations and it's adding log(n)
23:58:16 <pumpkin> Berengal: yeah
23:58:21 <pumpkin> mmorrow: thanks
23:58:37 <Berengal> And every node sends a message each tick?
23:58:38 <pumpkin> dolio: but I guess that's a pretty typical cost, and isn't really that bad in the bigger scheme of things
23:58:42 <mmorrow> pumpkin: and this http://portal.acm.org/citation.cfm?id=565816.503298
23:58:46 <dolio> If you want to mutate something and have that mutation show up non-locally, that requires pointers in C, too, just like with an STRef.
23:59:00 <Berengal> I have a weird idea that probably won't work...
23:59:01 <pumpkin> Berengal: nodes only send messages when they obtain new information, so not really
23:59:12 <Berengal> So only when their state changes?
23:59:16 <pumpkin> yeah
23:59:30 <Berengal> Hmmm...
23:59:39 <pumpkin> it's pretty simple for trees, and will converge after you go both ways
23:59:46 <Berengal> It wouldn't be possible to model the state of a node as a function of time would it?
23:59:52 <pumpkin> if you introduce cycles it isn't guaranteed to converge
23:59:56 <pumpkin> but tends to work well
