00:05:15 <wli> Once you've got the basic idea it's easy to be stupid about it, though the optimizations get pretty sophisticated.
00:06:50 <sm> has anyone successfully installed SDL-gfx on mac ? It refuses to see my installed libSDL_gfx during configure
00:07:43 <dmwit> sm: configure --help should have information on how to tell it where libSDL_gfx is.
00:07:46 <dmwit> Something like
00:07:51 <dmwit> --with-sdl=/path/to/libSDL
00:08:28 <sm> actually I'm doing cabal install, and see only generic options
00:08:31 <dmwit> (Though I haven't used SDL-gfx specifically, so forgive me if this advice isn't relevant.)
00:08:44 <sm> I'm specifying --extra-{include,lib}-dirs
00:08:50 <dmwit> Can you cabal-install the dependencies, then do this one by hand?
00:08:57 <dmwit> That would be my recommendation.
00:08:59 <sm> good idea
00:09:04 * sm tries
00:16:41 <sm> in configure, what is test $ac_cv_lib_SDL_gfx_SDL_initFramerate = yes; checking ? that's what's failing
00:25:44 <sm> ok, giving up on sdl for today, glut may work
00:26:48 <johnw> never give up, never surrender!
00:27:06 <sm> johnw!
00:27:32 <sm> I'm toying with the idea of a ludum dare entry
00:27:39 <johnw> ludum dare?
00:27:53 <sm> a 48-hour solo game programming contest
00:28:00 <pumpkin> sounds unfun
00:28:00 <sm> now in progress :)
00:28:13 <sm> not worth chewing up hours on sdl, specially if noone else can install it
00:28:15 <johnw> is the 48 hours the playing part?
00:28:31 <sm> http://www.ludumdare.com/
00:28:54 <wli> I'm fiddling with Grobner crud.
00:29:10 <sm> I should be (a) working (b) darcs sprinting or (c) sleeping but dammit, this looks like fun
00:29:23 <johnw> darcs sprinting?
00:29:53 <sm> the haskell hackathon, including darcs hacking, is also in progress at utrecht
00:31:30 <johnw> i always try to avoid mixing "should" in with fun programming projects :)
00:31:30 <johnw> as in, what I should be doing is usually why I'm not :)
00:32:19 <sm> yes
00:32:40 <sm> so haskell in theory has a great selection of games libs - sdl, hallegro, fungen, opengl/glut.. haskgame! new one
00:36:03 <sm> hmm, all pretty rough
00:51:50 * edwardk waves hello.
00:52:10 <wli> I think it inter-reduces okay now.
00:53:26 <ddarius> edwardk: 'wife sleeping?
00:58:10 <edwardk> ddarius: yeah
01:22:03 <wli> Hmm. interReduce seems dubious.
01:30:19 <GoldyOrNugget> is 'foo bar 1' read as foo(bar(1)) or foo(bar, 1)
01:31:34 <wjt> GoldyOrNugget: foo bar 1 means what you would write in many other languages as foo(bar, 1)
01:32:50 <GoldyOrNugget> can anyone tell me why http://codepad.org/zhrkZbtR fails?
01:34:29 <wks_> actually (((foo) bar) 1) in haskell.
01:37:27 <GoldyOrNugget> can anyone tell me why http://codepad.org/zhrkZbtR fails?
01:37:41 <wjt> takeWhile filter isPrime
01:37:44 <wjt> you don't mean that
01:38:00 <GoldyOrNugget> i dont?
01:38:17 <wjt> well, look at the types. They just don't make sense
01:38:19 <wjt> @type takeWhile
01:38:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:38:22 <wjt> @type filter
01:38:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:38:27 <wjt> @type takeWhile filter
01:38:29 <lambdabot>     Couldn't match expected type `Bool'
01:38:29 <lambdabot>            against inferred type `[a] -> [a]'
01:38:29 <lambdabot>     Probable cause: `filter' is applied to too few arguments
01:38:48 <wjt> you probably mean takeWhile (<= x) (filter isPrime [2..])
01:38:55 <wjt> given that you don't use the argument x at all on the right hand side :)
01:39:04 <GoldyOrNugget> oh wait
01:39:08 <GoldyOrNugget> yes, thats what i mean :P
01:39:21 <GoldyOrNugget> i seem to have forgotten that :/
01:39:24 <GoldyOrNugget> thanks v much
01:40:16 <GoldyOrNugget> so if you want foo bar 1 to be read as foo(bar, 1) instead of foo(bar(1)), how do you separate it?
01:40:26 <johnw> as foo(bar(1))
01:40:34 <johnw> or, foo(bar 1)
01:40:34 <GoldyOrNugget> no, i DONT want that
01:40:45 <GoldyOrNugget> i want foo (bar, 1)
01:40:51 <wjt> foo (bar 1)
01:40:52 <johnw> you mean, passing a tuple?
01:41:00 <wli> Okay, I think I see what I'm doing wrong.
01:41:04 <GoldyOrNugget> no, just passing two args
01:41:09 <wli> (Not that I ever observed a bug.)
01:41:10 <Cale> foo bar 1
01:41:11 <johnw> foo bar 1
01:41:14 <wjt> GoldyOrNugget: if you would write foo(bar(1)) in Python, you want to write foo (bar 1) in Haskell
01:41:24 <GoldyOrNugget> wjt, i want to write foo(bar, 1)
01:41:30 <Cale> foo bar 1  means  (foo bar) 1
01:41:40 <Cale> which is how you pass multiple parameters
01:41:51 <GoldyOrNugget> (foo bar) 1????
01:41:52 <GoldyOrNugget> wtf??
01:42:00 <Cale> functions which appear to take multiple parameters really only take one, and give another function as the result
01:42:10 <GoldyOrNugget> oh lord
01:42:38 <johnw> (foo bar) returns a partially applied function that expects one parameter
01:42:58 <Cale> This is nice because it makes it easy to apply a function to just some parameters and get a function which you use elsewhere
01:43:01 <Cale> For example...
01:43:41 <Cale> > map (map (*2)) [[1,2,3], [4,5]]
01:43:43 <lambdabot>   [[2,4,6],[8,10]]
01:44:18 <johnw> > (+ 1) 2
01:44:20 <lambdabot>   3
01:44:21 <Cale> Here, it's the function  map (*2)  which we apply to each element of the list
01:44:47 <Cale> and that in turn applies (*2) to each element of each of those lists
01:45:35 <johnw> can lambabot report it's current heap usage?
01:45:36 <Cale> that is,  map (map (*2)) [[1,2,3],[4,5]] = [map (*2) [1,2,3], map (*2) [4,5]]
01:45:54 <Cale> = [[1*2,2*2,3*2], [4*2,5*2]]
01:48:44 <wli> Trickier and trickier.
01:48:52 <johnw> wli: what is?
01:49:20 <wli> johnw: Fixing up these algorithms without even seeing bugs in action.
01:49:53 <johnw> seeing bugs in action, makes me think of Starship Troopers
01:53:39 <mmorrow> nice, the IntMap datastructure isn't that hard to implem (especially while looking at the Data.IntMap code)
01:54:18 <mmorrow> i just scrapped my C red-black tree code and have a C version of Data.IntMap working at minimum functionality
01:54:56 <wli> I would probably use hash tries for IntMap equivalents in C.
01:55:04 <mmorrow> you don't even need to do any rebalancing with patricia trees
01:55:20 <mmorrow> and union is way faster than hashtables
01:55:29 <mmorrow> like way way
01:56:08 <mmorrow> wli: http://www.ittc.ku.edu/~andygill/paper.php?label=IntMap98
01:56:28 <mmorrow> wli: oh, hash trIEs?
01:56:33 <mmorrow> hmm
01:56:54 <edwardk> i've been playing with building a nice burst trie implementation actually
01:56:57 <wli> Union isn't terribly swift with hash tries either.
01:57:06 <mmorrow> edwardk: hey there
01:57:15 <mmorrow> what's a burst tree?
01:57:21 <mmorrow> ie
01:57:39 <edwardk> http://portal.acm.org/citation.cfm?id=506312
01:58:05 <edwardk> basically think a tree that you 'pop' into a trie as it fills
01:58:19 <mmorrow> nice, looking at the paper now
01:58:44 <edwardk> i'm using tries in my monoidal regex engine, so i'm looking for efficient options
01:58:49 <wli> edwardk: I do that with hash tries.
01:59:08 <edwardk> its a fairly common trick
01:59:23 <wli> edwardk: Basically once the node size hits the upper limit you know to treat it as a direct-mapped array.
01:59:25 <edwardk> you can view it as a generalization of the common prefix compressed trie stuff
01:59:42 <mmorrow> what about "DAWGS"?
02:00:05 <mmorrow> i was reading a (minimal summary) about them, and didn't see how to build them off the top of my head
02:00:21 <edwardk> well, a DAWG is basically just a hash consed trie in haskell since we don't have mutation anyways
02:04:33 --- mode: irc.freenode.net set +o ChanServ
02:04:54 <edwardk> unfortunately a DAWG is less useful if you use the trie to store information about the keys
02:05:04 <mmorrow> ahh
02:05:33 <edwardk> anyways a dawg is trivial to implement you just need the hash cons structure
02:06:31 <mpeter> are you there, god?? please help me stop masturbating
02:07:23 <magthe> hmm, I've run into the "old exception" vs. "new exception" thingie when trying to bring an older program of mine to build on 6.10... is there a simple explanation together with example of how do deal with it?
02:09:19 <edwardk> replace `catch` \e -> with `catch` \(SomeException e) -> ... or import Control.OldException or link against an old base, iirc
02:10:00 <magthe> edwardk: yes, now I remember... where can I find the possible values for $SomeException?
02:11:13 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
02:14:08 <Cale> actually, iirc, if you do much of anything with the exception, I think you have to give the exception handler an explicit type signature.
02:15:10 <BONUS> also give this a read http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
02:15:29 <BONUS> it tells you how you can use the hierarchic abilities of the new exception library
02:16:05 <cnwdup> Can I catch IO errors (e.g. errors from the underlying monad) in the ErrorT monad?
02:16:09 <BONUS> although i only tend to use I/O exceptions, throwing exceptions from pure code is adding unnecessary I/O to your program
02:16:25 <BONUS> yeah you can have your program be ErrorT IO
02:16:48 <cnwdup> BONUS, how do I catch them then? Neither catch nor catchError seem to have appropiate types.
02:17:27 <BONUS> you can do `catch` (\(e :: SomeException) -> whatever)
02:17:34 <BONUS> for a catchall handler
02:17:47 <BONUS> although you have to turn on some extension for this, i forget which
02:18:06 <BONUS> or do you mean with ErrorT?
02:18:28 <cnwdup> BONUS, but catch expects IO actions. For instance I cannot re-raise an IO-error in ErrorT, right?
02:18:43 <cnwdup> I guess I mean the latter.
02:19:02 <BONUS> well you have catchError
02:19:29 <BONUS> and you can re-raise them from the handler by doing something like return (Left "re-raising this!")
02:19:35 <cnwdup> From the type signature it suggests that it only catches the specific errors for the ErrorT transformer.
02:19:50 <cnwdup> @type catchError
02:19:52 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
02:20:07 <BONUS> say you have this
02:20:26 <BONUS> some_io_action `catchError` (\e -> ...)
02:20:57 <BONUS> and if some_io_action has a type of ErrorT String IO Int
02:20:59 <cnwdup> Ah. I see what you mean now.
02:21:14 <BONUS> it will be either a Left String wrapped in an I/O action
02:21:19 <BONUS> or a Right Int wrapped in an I/O
02:21:31 <BONUS> and if the result of the IO action is a Right Int, the handler gets ignored
02:21:52 <BONUS> if it's, say, Left "something", the "something" will get passed to the handler
02:22:22 <BONUS> which can then return a Right or a Left. if it returns a Left, that's like re-raising your error
02:22:36 <BONUS> of course it has to return a Right or Left in the type of ErrorT e IO a
02:23:09 <cnwdup> But IOErrors are not catched by ErrorT String IO Int, right? This monad implies m -> e, thus its bound to a String which isn't an IOError. Or am I mistaken?
02:23:52 <BONUS> they aren't. if you want to use ErrorT e IO a, you can't use, say getLine
02:24:18 <BONUS> because if you're in ErrorT, your I/O actions have to be of type IO (Either e a)
02:24:40 <cnwdup> That's a pitty. So I cannot for instance handle an socket failing to connect in my custom monad?
02:25:46 <BONUS> hmm i dont know. what if you just used the exceptions from System.IO.Error
02:28:26 <cnwdup> BONUS, I cannot introduce my own error types for them, right? I think I could seperate the code in my custom monad form IO. But that might be very annoying.
02:28:39 <{g}> Hey People! Im not a haskell coder, but I like to talk with coders of all sorts. Do you guys use something like classes?
02:30:04 <BONUS> cnwdup: yeah, you can't. you can extend the new exceptions though, but they're another can of pants. how about if your socket opening functions returns IO (Left "failed") or IO (Right handle)
02:30:40 <BONUS> then you can use it in ErrorT and if you want to use other normal IO actions in ErrorT, just lift them
02:31:05 <cnwdup> But once I have lifted them, I cannot catch the errors any more?
02:31:20 <BONUS> {g}: we use typeclasses. they're sort of like interfaces, only more powerful
02:31:30 <cnwdup> Ah, sorry. Haven't read your answer befor that.
02:31:36 <cnwdup> Yes. That what I apparently have to do. Thank you.
02:31:45 <BONUS> hehe np
02:31:56 <{g}> BONUS: can you give an example?
02:32:04 <BONUS> i prefer my IO actions to have a return type of IO (Either e a)
02:32:46 <BONUS> {g}: well for instance, there's a class called Ord which is for things that can be ordered. it presents the methods (<) and (>). any type can be compared with > and < as long as we make it an instance of Ord
02:33:00 <cnwdup> BONUS, yes. That's a good think. But then again, errors are often in String form and not as concrete data types. Or isn't that true?
02:33:01 <BONUS> that is if we tell the type how to behave with > and <
02:33:21 <cnwdup> BONUS, I find it hard to handle that. It wouldn't feel right to do error handling on string matching basis.
02:33:37 <BONUS> yeah, you can use your own data type for the error part afaik
02:34:21 <cnwdup> BONUS, one should be able to guess from the Monad which errors are possible. You cannot do that with IO, right?
02:34:57 <BONUS> i dont know, i dont think so. you can make your own data type and make it an instance of Error and then use it in the Left parts instead of strings
02:35:37 <{g}> BONUS: because the > and < get overloaded to handle things of type Ord in a special way?
02:35:50 <BONUS> yeah
02:36:23 <BONUS> but there's also typeclasses like Read, which define a function read, which takes a string and return a data type
02:36:48 <BONUS> and then if you make, say, numbers an instance of Read, you can do read "4" and it will return the appropriate type
02:37:06 <BONUS> > read "4" + 3.4
02:37:08 <lambdabot>   7.4
02:37:11 <BONUS> > read "4" + 1
02:37:12 <lambdabot>   5
02:37:25 <BONUS> in once case it u sed floating point numbers, in the other integral numbers
02:37:46 <{g}> BONUS: in php, i would write class Ord { function compare($o1,$o2) {..} }. And then derive ordered stuff from Ord. Then use the compare function to compare objects. How do you write a typeclass in haskell so that the < operator gets overloaded?
02:37:59 <ray> > read "4" :: Double + 1
02:38:00 <lambdabot>       No instance for (Show (+ Double Unit))
02:38:01 <lambdabot>        arising from a use of `sh...
02:38:11 <ray> > (read "4" :: Double) + 1
02:38:12 <lambdabot>   5.0
02:38:35 <BONUS> {g}: class Ord a where (>) :: a -> a -> Bool; (<) :: a -> a -> Bool
02:38:37 <BONUS> for instance
02:39:07 <BONUS> {g}: the thing about typeclasses is that they're open. i can make a typeclass of my own and then connect it with types that already exist
02:39:12 <wli> http://wli.pastebin.com/m43b11017 <-- a few tweaks to the Grobner code
02:39:23 <{g}> BONUS: ok, thanks for the info
02:39:26 <BONUS> in things like Java, you have to choose which classes to inherit from when writing your class
02:39:29 <BONUS> np
02:39:49 <{g}> How do you guys see the future of Haskell? Will it become as popular as PHP is today?
02:40:00 <ray> hopefully not
02:40:22 <Raevel> it's not a popularity contest!
02:40:33 <ray> allegedly, unpopularity helps a language community survive
02:40:53 <BONUS> there's a Haskell saying that goes: avoid success at all costs
02:40:59 <ray> that's good as far as it goes but you don't want to end up like lisp
02:41:06 <ray> happy medium
02:41:08 <monadic_kid> Haskell is clearly popular
02:41:19 <BONUS> yeah, haskell has a nice medium, which i hope we keep
02:41:30 <BONUS> kind of popular but not too popular
02:41:43 <ray> the most popular unpopular language
02:41:58 <{g}> For PHP you can get really good hosting in no time for no money. thats a big benefit i think.
02:42:00 <kadaver> haskellis to good to not become more popular
02:42:05 <monadic_kid> look, how many people in here, compare that to #ocaml or #fsharp
02:42:23 <kadaver> #lisp
02:42:24 <wli> Some theorems to tweak interReduce might help.
02:42:24 <kadaver> #scheme
02:42:30 <monadic_kid> which is a bit unfortunate
02:43:32 <wli> It's irritating that there's no Map which can take a comparator because here the comparators aren't statically determined (well, I don't do anything like that yet, but it's coming up eventually).
02:43:58 <wli> If I had such I could use minView/maxView to great effect.
02:44:35 <monadic_kid> does anyone know of any variants of scheme which is purely functional and has call-by-need semantics?
02:44:59 <magthe> {g}: check out http://langpop.com/ to see just how popular haskell is, in some categories it's already more popular than PHP :)
02:46:06 <{g}> magthe: opportunities for hosting haskell apps are a lot more resrticted then hosting php apps. thats the main backdraw of haskell for me.
02:46:12 <cnwdup> A quick suggestion on how I can reproduce a connection timeout error using connectTo? (:
02:47:56 <kadaver> monadic_kid: call by need =laziness? there is lazy scheme
02:48:03 <BONUS> {g}: most haskell web development libraries are still being worked out and probably not yet ready for production use
02:48:23 <{g}> ok
02:49:04 <monadic_kid> err thats not quite true
02:50:26 <kadaver> what isnt?
02:50:35 <kadaver> about web libs?
02:50:45 <kadaver> happstack seems like it needs some polishing
02:51:06 <monadic_kid> {g}: http://happs.org/
02:52:15 <magthe> {g}: sure, hopefully there will be some forward-looking hosting company that realises that Haskell is a nice niche to be in... another option is to use Amazon's services
02:52:19 <BONUS> it kind of bugs me that you need ghc 6.8.2 for happs
02:52:42 <kadaver> but why do they let people host for free?
02:52:50 <kadaver> how d they earn money then?
02:54:07 <ivanm> BONUS: it won't work with 6.10? how about happstack?
02:54:57 <dqd> Happs is dead, long live happstack.
02:55:21 <lpsmith> BONUS:  bugs you that you need an exact version,  or that you need that new of a version?
02:55:25 <ray> happstack is dead, long live happstacker
02:55:35 <ivanm> ray: :o
02:55:48 <ivanm> x is dead, long live (succ x)!
02:55:49 <ivanm> ;-)
02:55:54 <dqd> Haha.
02:56:03 <lpsmith> I highly recommend upgrading to at least 6.8,  because the compiler has become a *lot* faster these days.
02:56:17 <kadaver> because of the new backend?
02:56:18 <ivanm> (which of course only works for x :: (Ord a) => a :p )
02:56:27 <ivanm> among other things
02:56:29 <kadaver> is it compiling faster or producing faster code or both?
02:56:34 <ivanm> latter mainly
02:56:39 <xenoblitz> Hi people... can someone help me with a little problem here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3892
02:56:50 <kadaver> who wrote the new backend? the godly dons?
02:56:50 <ivanm> which does have a slight effect on the former (due to bootstrapping)
02:56:58 <lpsmith> 6.8.2's version of GHCi has a rather nasty bug with regard to scoping, though.
02:57:18 <ivanm> kadaver: AFAIK, dons writes libraries, nothing to do with ghc itself
02:57:25 <ivanm> that's due to SPJ, simon marlow, etc.
02:57:30 <ivanm> lpsmith: :o
02:57:31 <lpsmith> ivanm:  I haven't noticed the latter so much as the former
02:57:33 <ivanm> I don't recall it...
02:57:39 <BONUS> lpsmith: that it doesn't work with the latest version
02:57:50 <ivanm> lpsmith: you mustn't be writing much performance oriented code then ;-)
02:58:02 <ivanm> BONUS: due to base? does --constraint=base<4 work?
02:58:04 <lpsmith> oh,  that all depends :-D
02:58:09 <BONUS> but otherwise i think happstack is awesome
02:58:20 <BONUS> ivanm: i'll have to try that
02:58:28 <thoughtpolice> well, GHC's optimizations pay off when compiling itself too
02:58:29 <lpsmith> ivanm:  what kind of code have you been writing lately?
02:58:38 <thoughtpolice> the 6.8 release had major speed increases for almost all programs including GHC itself
02:58:39 <ivanm> lpsmith: partial latin square generation
02:58:59 <thoughtpolice> that was quite a difference (pointer tagging made most apps run ~15% faster)
02:59:02 <ivanm> though my current bottleneck is with jyp's hgal library (whether it's due to how I'm using it or the library itself is another story :p )
02:59:28 <wli> I need pretty printing and parsing of multivariate polynomials.
02:59:30 <lpsmith> toughtpolice:  yes,  particularly.   That's much the philosophy behind Chez,  and while the philosophy isn't perfect,   it's very gratifying to the developer
02:59:48 <ivanm> lpsmith: Chez?
03:00:04 <lpsmith> @where chez
03:00:05 <lambdabot> I know nothing about chez.
03:00:15 <lpsmith> ?help where+
03:00:16 <lambdabot> where+ <key> <elem>. Define an association
03:00:19 <monadic_kid> @where monadic_kid
03:00:20 <lambdabot> I know nothing about monadic_kid.
03:00:22 <thoughtpolice> @go chez scheme
03:00:23 <lambdabot> http://www.scheme.com/
03:00:24 <lambdabot> Title: (chez (chez scheme))
03:00:32 <ivanm> ahhh, a scheme variant
03:00:33 <lpsmith> @where+  http://scheme.com/
03:00:34 <lambdabot> Done.
03:00:48 <lpsmith> @where+  chez http://scheme.com/
03:00:48 <lambdabot> Okay.
03:00:59 <lpsmith> oops :-D
03:01:06 <ivanm> @help where-
03:01:07 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:01:10 <ivanm> @help forget
03:01:10 <lambdabot> forget nick quote.  Delete a quote
03:01:19 * thoughtpolice cannot wait until the new backend is in place and bootstrapping works in the HEAD branch again
03:01:22 * ivanm can never remember which command forgets links
03:01:31 <ivanm> thoughtpolice: they're making _another_ new backend?
03:01:45 <thoughtpolice> it's the same one that was scheduled for 6.10
03:01:52 <thoughtpolice> it didn't make the release cut because it wasn't done
03:01:55 <kadaver> pointer tagging?
03:01:57 <ivanm> ahhh
03:02:30 <xenoblitz> anyone here experienced with loop combinators?
03:02:45 <thoughtpolice> you can use the new backend in the HEAD stage1 compiler
03:02:51 <thoughtpolice> it's just not ready for general consumption yet though
03:03:14 <lpsmith> ivanm:  I've come up with a unique,  real-time implementation of queues lately....
03:05:55 <lpsmith> kadaver:   pointer tagging is a very common techinque, at least in the scheme community do to dynamic typing
03:06:34 <kadaver> instance Show NeuralNetwork where
03:06:35 <kadaver>     show (BPN n) = show n
03:06:42 <kadaver> why sint this alllowed?
03:06:51 <lpsmith> In pointer tagging,  some of the  high- or low- order bits are reserved for specifying what kind of data the pointer is referring to
03:06:52 <kadaver> instance Show NeuralNetwork where
03:06:52 <kadaver>     show (_ n) = show n
03:06:52 <kadaver> ?
03:07:04 <kadaver> lpsmith: yes that i know but pointer tagging in haskell?
03:07:08 <lpsmith> instead of tagging the value itself
03:07:14 <c_wraith> hmm.  scanl is really handy.  Why didn't I know about it already?
03:07:22 <lpsmith> GHCi has moved to pointer tagging,  sometimes
03:07:25 <lpsmith> not always
03:08:00 <lpsmith> for example,  pointer tagging Maybe types avoids extra heap allocation
03:08:07 <kadaver> > scanl (+) 0 [0.1,0.4,0.5]
03:08:08 <lambdabot>   [0.0,0.1,0.5,1.0]
03:08:31 <kadaver> > tail $ scanl (+) 0 [0.1,0.4,0.5]
03:08:32 <lambdabot>   [0.1,0.5,1.0]
03:08:48 <c_wraith> > let fibs = 1 : scanl (+) 1 fibs in take 10 fibs
03:08:49 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
03:10:28 <sm> cabal configure's --extra-include-dirs option seems to have no effect
03:12:47 <wli> So there's a prety printer.
03:15:31 <kadaver> data Neuron = Neuron !Inputs !Weights !Threshold
03:15:31 <kadaver>               deriving(Show)
03:15:39 <kadaver> why strictify the args?
03:15:44 <wli> Not quite. I need to switch between + and - vs. just intercalate " + "
03:16:02 <kadaver> to have the lists created on inititation?
03:16:02 <kadaver> not when needed?
03:18:47 <Gaidzis> http://gaidzis.mybrute.com
03:22:28 <Gaidzis> http://gaidzis.mybrute.com
03:24:46 <wli> It's messy but it works.
03:28:44 <_dls> hey guys, this may be a silly question... but is there a way to specify a type that holds a tupple of exactly N length? it seems wrong scattering my code for list length checks and I don't want to hard code it to an n length tupple :-/
03:29:03 <thoughtpolice> well, the 'length' of a tuple is already static
03:29:15 <thoughtpolice> i.e. (Int,Int,String) is a 3-tuple, etc.
03:29:25 <thoughtpolice> but you can encode the length of e.g. a vector in its type
03:29:38 <_dls> yep, is there some way to communicate "a tupple of 5 Ints" or such?
03:30:26 <thoughtpolice> you can project the length of a list into its type using GADTs and type families
03:30:53 <thoughtpolice> well, really you only need GADTs
03:31:03 <thoughtpolice> type families are convenient for doing things like type-level arithmetic, though
03:31:46 <thoughtpolice> _dls: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3895#a3895
03:32:20 <_dls> thoughtpolice: awesome. thanks for the pointers :) ... err references
03:32:52 <thoughtpolice> grr
03:32:56 <thoughtpolice> @seen conal
03:32:57 <lambdabot> I saw conal leaving #haskell and #ghc 2m 25d 5h 19m 10s ago, and .
03:33:14 <thoughtpolice> preflex: seen conal
03:33:15 <preflex>  conal was last seen on #haskell 1 day, 16 hours, 51 minutes and 31 seconds ago, saying: fnod: :)
03:37:19 <wli> It's not actually clear that pretty printing is easier than parsing.
03:39:04 <thoughtpolice> @tell conal I'm getting segfaults with FieldTrip-0.2.2 on Mac OS X and linux, please see - http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3896#a3896
03:39:05 <lambdabot> Consider it noted.
03:42:09 <pk1> is there a way to read what's been accumulated in a writer monad ?
03:42:25 <wli> listen
03:43:16 <pk1> but does this work inside the monad ?
03:43:38 <pk1> like tell "lala" >> listen
03:43:51 <pk1> doesnt' seem to have the good type
03:44:08 <wli> There's also pass.
03:45:19 <ddvlad|> wouldn't get also work? Writer is a MonadState
03:46:30 <wli> @type do { (_, ws) <- listen $ tell [1] ; return ws }
03:46:31 <lambdabot> forall (m :: * -> *) t. (Num t, MonadWriter [t] m) => m [t]
03:46:53 <pk1> yeah, but I can't get what's already been accumulated
03:48:03 <pk1> I'll switch to state
03:49:18 <wli> > runWriterT $ do { tell [2] ; (_, ws) <- listen $ tell [1] ; return ws }
03:49:19 <lambdabot>       No instance for (Show (m ([t], [t])))
03:49:19 <lambdabot>        arising from a use of `sho...
03:49:32 <wli> > runWriter $ do { tell [2] ; (_, ws) <- listen $ tell [1] ; return ws }
03:49:33 <lambdabot>   ([1],[2,1])
03:50:14 <wli> Maybe MonadCont is necesary.
03:52:22 <wli> > runWriter $ do { tell [2] ; mapWriter (\(_,x) -> (x,x)) $ tell [1] }
03:52:23 <lambdabot>   ([1],[2,1])
03:52:38 <pk1> wli, why would you need monadcont ?
03:53:05 <wli> weird control flow
03:53:16 <wli> No idea if it can be pulled off anyway.
03:53:22 <pk1> k
04:53:49 <nothingmuch> any latex hippies around here? trying to use http://conway.rutgers.edu/svn/u/tex/macros/takahashi.sty but i can't seem to get \frame[containsverbatim] to happen
04:54:05 <nothingmuch> latex and especially latex macros are beyond me
04:57:50 <kadaver> http://developeronline.blogspot.com/2009/04/if-philosophers-were-programmers.html
04:58:01 <kadaver> haskell=wittgenstein,hmm
05:06:37 <mstr> http://4.bp.blogspot.com/_PNe-bgIDyRw/SeaORicl3sI/AAAAAAAAARc/uPis6LvwawU/s320/Haskell_Logo.jpg
05:06:43 <mstr> is that really the haskell logo? :D
05:06:58 <tomh> no
05:07:10 <ivanm> mstr: that was the old logo
05:07:14 <ivanm> unfortunately, it's been replaced
05:07:15 <ivanm> :(
05:09:08 <Trowalts> if a function turns a string into an integer by adding up the ascii value of each character in a string, how can I convert that integer back into a string?
05:09:21 <mstr> ivanm: unfortunately? but it's hideous :D
05:09:41 <RayNbow> it should have been replaced with http://haskell.org/sitewiki/images/8/85/NarleyYeeaaahh.jpg
05:10:00 <tomh> absolutely
05:10:03 <mstr> tomh: excellent answer
05:11:00 <pk1> Trowals: you can't
05:11:06 <RayNbow> > sum . map ord $ "  "
05:11:07 <lambdabot>   64
05:11:39 <RayNbow> there are many strings that sum up to 64
05:11:44 <pk1> think of what appens when you inverse 2 characters
05:11:50 <vixey> Trowalts: 1 + 4 = 3 + 2 = 2 + 3 ...
05:11:50 <pk1> the sum won't change
05:13:40 <ivanm> mstr: I like it
05:13:46 <ivanm> then again, I'm mathsy ;-)
05:15:30 <Trowalts> my thought exactly, but its a question given to my by lecturer, and he seems to have a solution to it but wont share until I've done it or gotten 0 for it, I dont want the latter
05:16:12 <vixey> do you have the actual function
05:16:26 <vixey> or is it just this vauge description of it
05:17:08 <Trowalts> this is an example he gave us
05:17:10 <Trowalts> str2num "Hello, world!"  2645608968347327576478451524936
05:17:11 <Trowalts> num2str (str2num "Hello, world!")  "Hello, world!"
05:17:25 <jedai> Trowalts: The function you initially described is clearly a one-way function... So there's several possibilities :
05:17:36 <vixey> Trowalts: th actual function..?
05:17:40 <jedai> it's a trap
05:17:41 <vixey> Trowalts: in haskell code
05:17:50 <Trowalts> no the actual function I have to write
05:17:53 <jedai> the teacher is stupid
05:17:59 <vixey> you don't have str2num?
05:18:11 <Trowalts> I've writen str2num
05:18:12 <jedai> you misunderstood the function str2num (which seems to be the case)
05:18:22 <vixey> Trowalts: ok that's what I was asking!
05:18:22 <vixey> > show . chr =<< "Hello, world!"
05:18:23 <lambdabot>   Couldn't match expected type `Int' against inferred type `Char'
05:18:31 <vixey> > show . ord =<< "Hello, world!"
05:18:32 <lambdabot>   "72101108108111443211911111410810033"
05:18:49 <Trowalts> kk, 2 secs I'll paste the link now
05:18:57 <EvilTerran> Trowalts, you could interpret the string as a base-256 number
05:18:59 <jedai> Trowalts: This str2num in the teacher example is clearly not doing what you said
05:19:49 <jedai> Trowalts: EvilTerran suggestion seems much closer to the mark
05:19:56 <Trowalts> I gave a simple example of my question here
05:20:18 <vixey> Trowalts: why not show the actual haskell code of str2num
05:20:54 <Trowalts> the full function takes each characters ascii value * 256^index, where index is the position of the char in the string, add all of that up and you get the Int I'm tryuing to convert back
05:21:03 <Trowalts> pasting now
05:21:21 <EvilTerran> Trowalts, that's exactly what i had in mind, then
05:21:35 <tomh> mm does the =<< apply each function on every element in the list monad?
05:21:49 <EvilTerran> tomh, it's basically concatMap
05:21:54 <EvilTerran> ?src [] (>>=)
05:21:54 <lambdabot> xs >>= f     = concatMap f xs
05:21:55 <tomh> ok
05:22:06 <tomh> @src concatMap
05:22:07 <lambdabot> concatMap f = foldr ((++) . f) []
05:22:30 <Trowalts> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2151#a2151
05:22:42 <EvilTerran> -- or
05:23:01 <EvilTerran> concatMap f [] = []; concatMap f (x:xs) = f x ++ concatMap f xs
05:26:03 <jedai> let str2num = foldr (\c acc -> acc * 256 + fromIntegral (ord c)) 0
05:27:02 <jedai> Trowalts: This code ^ does the same thing (but is more clear it seems to me)
05:27:26 <Trowalts> thanks jedai, that is indeed clearer
05:27:53 <jedai> Trowalts: And this transformation is indeed reversible
05:28:33 <jedai> Trowalts: you just need to split a number in its representation in base 256 and then use char
05:28:38 <jedai> *chr
05:29:41 <Saizan> i'd normally use foldl', btw (but it depends on endianess)
05:30:16 <Trowalts> I dont know how to split it into its base
05:30:28 <Saizan> however that foldr will stack-overflow on a big list
05:30:42 <jedai> Saizan: I would agree but given the endianess, you would have to reverse the string, I don't think we really need to consider big lists
05:31:46 <jedai> Trowalts: It's just the algorithm you learned in High School (I think)
05:32:31 <jedai> Trowalts: You never did anything like convert decimal representation to binary and the converse ?
05:33:25 <Trowalts> ah, ofcourse
05:41:43 <mmorrow> <wli> It's irritating that there's no Map which can take a comparator because....
05:42:02 <mmorrow> wli: i've been meaning to fork a personal version of Data.Map for a while now
05:42:45 <mmorrow> (IntMap too, but in that case Ord isn't an issue...)
05:44:33 <Saizan> well, you can give it a comparator, using "reflection"
05:44:54 <mmorrow> IntMap is really cool. i've never spent the time to read how it works until a few hours ago
05:45:25 <Saizan> mmorrow: on another note, do you think vacuum could inspect also closures with a functional type?
05:45:54 <mmorrow> it took me < 30 minutes to write structs/etc/helpers/blah/insert/delete in C with the IntMap code open alongside
05:46:08 <mmorrow> Saizan: how do you mean?
05:46:15 <mmorrow> , vacuum id
05:46:21 <lunabot>  [(0,[])]
05:46:39 <mmorrow> (that vacuum is the original original one, but that's the same behavior the current has)
05:46:58 <mmorrow> it's just that the info tables for functions don't have the function/module/package name like constructors do
05:47:10 <Saizan> , vacuum $ let y = replicate 2 'a' in \xs -> xs ++ y
05:47:12 <lunabot>  [(0,[])]
05:47:17 <mmorrow> :o
05:47:22 <mmorrow> err
05:47:35 <Saizan> , vacuum $ let y = replicate 2 'a' in rnf y `seq` \xs -> xs ++ y
05:47:37 <lunabot>  [(0,[])]
05:47:51 <Saizan> i'd like to see the y represented
05:47:57 <mmorrow> , let x = (let y = replicate 2 'a' in \xs -> xs ++ y) in x `seq` closureType x
05:48:00 <lunabot>  PAP
05:48:32 <mmorrow> hmm, i'm not sure you can take apart a PAP at the haskell level with the current ghc interface
05:48:57 <Saizan> it stands for PartialApplication?
05:49:04 <mmorrow> (but i actually just figured out how to get a (a -> Ptr StgClosure) which i can pass to a C function and go nuts!! :)
05:49:17 <mmorrow> (the only thing is that you'd then be racing the next GC)
05:49:22 <mmorrow> Saizan: yes
05:50:43 <mmorrow> Saizan: the only currently provided way to get at (a stripped down basic rep of closures) is to use unpackClosure#, which apparently doesn't give you the pointers in the PAP
05:51:42 <Saizan> i see
05:51:56 <mmorrow> so i think you'd have to write a C function "asdf_t *foo(StgClosure *o)", and then somehow figure out how to weasel an "a" into a (Ptr StgClosure) which you can pass to "foo" via ffi import
05:52:36 <Saizan> and stop the GC?
05:52:41 <mmorrow> (and then if you do that you'd probably want to find a way to pre
05:52:43 <mmorrow> exactly
05:53:20 <mmorrow> or if you're in the non-threaded rts i   guess the foreign call'll block haskell so you'd be ok
05:53:58 <mmorrow> (but ghci is threaded, so i think the only realistic thing to do is find whatever lock you need to grab)
05:55:47 <koeien> do i need to deinstall ghc-6.10.1 before installing 6.10.2 ?
05:56:00 <koeien> if so, how?
05:56:18 <mmorrow> koeien: not if you install to the same PREFIX
05:56:25 <mmorrow> err, imeant --prefix=
05:56:26 <koeien> mmorrow: yes i am. thanks
05:57:17 <mmorrow> koeien: i think if you are then weird things might happen, but maybe not. i've never tried
05:57:23 <pvdbrand> I'm trying to read a binary file as a stream of Word64 values. I'm using a ByteString to read the file, take 8 Word8's at a time and shift and add them into a Word64. However, the shifting and adding seems to be slower than necessary, and the Core shows that the Word8's are still boxed/lazy. How can I unbox them or make them strict, so the shifting and adding is much faster? Or is there a better way to read Word64's?
05:57:41 <mmorrow> pvdbrand: use Data.Binary
05:57:57 <pvdbrand> mmorrow: thanks for the tip, I'll have a look, thanks!
05:58:06 <mmorrow> decode :: Data.ByteString.Lazy -> [Word64]
05:58:13 <mmorrow> @hoogle decode
05:58:13 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
05:58:25 <mmorrow> decode :: (Binary a) => Data.ByteString.Lazy -> a
05:59:23 <mmorrow> koeien: err, i meant to say s/not if you install to the same prefix/not if you DON'T install to the same PREFIX/
06:02:10 <Saizan> i have both installed under /usr/local with no problem
06:02:25 <Saizan> i.e. the default
06:02:31 * ManateeLazyCat pasted "my code" at http://paste2.org/get/186511
06:02:31 <ManateeLazyCat> When a function's type signature is `StateT SomeType`, and this function is not need input argument to pass default. But when i want to add another function argument distinct, how to write type signature? And above is my original function, i need add another function argument with type `WindowDirection`, thanks!
06:03:26 <koeien> Saizan: yes that seems to work. only `ghc' now refers to the new ghc, but ghc-6.10.1 still exists
06:03:36 <Saizan> yup
06:05:38 <Saizan> ManateeLazyCat: WindowDirection -> StateT WindowsList IO Int
06:06:04 <Saizan> ManateeLazyCat: getNewCounter direction = ...
06:07:01 <Saizan> or another function if it was for another
06:07:11 <chrisdone> http://paste.lisp.org/display/78787 -- formlets in javascript =)
06:08:35 <ManateeLazyCat> Saizan: If function mix normal argument and `StateT` argument, just keep `StateT` at end? Haskell care the sequence of different type argument?
06:08:59 <burp_> anyone got ghc working with opensolaris?
06:09:51 <pvdbrand> mmorrow: I just tried Data.Binary. It's very simple use, but unfortunately it needs 4x as much memory as the size of the file I'm trying to read. I don't have enough RAM for the 1 GB file I need to read... is this due to the fact that I'm putting all Word64's in a list?
06:12:42 <Saizan> ManateeLazyCat: the StateT goes at the end yes
06:13:14 <Saizan> ManateeLazyCat: but thinking of it as an argument is a bit misleading
06:13:59 <ManateeLazyCat> Saizan: I see, thanks. Now i rewrite my function.
06:14:03 <TheRealMarko> :)
06:15:51 <Saizan> pvdbrand: a list is not space efficient, unless you manage to never have it all at once in memory
06:17:35 <pvdbrand> Saizan: yes that makes sense. I'm looking into uvector now, thanks for the help
06:22:21 <kadaver> hmm my intuition tells me: dynamic language diggers really underestimate how much of a program types can prove.
06:23:03 <Baughn> Dynamic-typing diggers, really
06:23:21 <Baughn> I kinda wish haskell was more dynamic. It could keep the typing, but I'd like some reflection.
06:23:35 <burp_> I love that haskell is static as it is
06:24:36 <eu-prleu-peupeu> hi
06:24:43 <koeien> hello
06:26:16 <vixey> what is reflection about Baughn?
06:26:17 <jmcarthur> Baughn: what kind of reflection do you mean?
06:26:43 <skorpan> reflection in haskell makes no sense to me.  could someone enlighten me?
06:26:46 <chrisdone> a builtin eval function?
06:26:50 <Baughn> jmcarthur: Lisp-style. Symbol-function, symbol-value, etc... symbol-type too, I suppose
06:27:11 <Baughn> jmcarthur: Being able to construct a serializer at runtime by inspecting a type?
06:27:39 <Baughn> Or, for that matter, being able to write vacuum without horrible GHC-specific hacks
06:28:45 <Saizan> that kind of hurts referential transparency, but we can always blame that on IO i guess
06:28:52 <jmcarthur> http://okmij.org/ftp/Haskell/generics.html#de-serialization
06:29:09 <Saizan> however the haskell language doesn't dictate anything about memory layout etc..
06:29:47 <Baughn> It doesn't need to define how it's implemented, just what the API is like
06:29:52 <Baughn> Of course, it doesn't do that either..
06:31:35 <jmcarthur> what vacuum does has almost nothing to do with haskell and everything to do with ghc, no?
06:31:59 <Baughn> Ah, but it /could/ have something to do with haskell.
06:32:10 <jmcarthur> if haskell had operational semantics you mean
06:32:15 <Baughn> Yes
06:32:22 <Baughn> Actually, not quite
06:32:46 <Baughn> Nobody says the internal data structures have to be the same in every compiler, either, just that they should /exist/
06:32:55 <Baughn> With an interface to read them
06:33:15 <jmcarthur> well, at the least, sharing would have to be a part of the haskell spec
06:33:23 <Baughn> Oh, definitely
06:33:27 <jmcarthur> otherwise, vacuum would be inconsistent
06:33:43 <Baughn> Does it need to be consistent? It's a debugging tool.
06:34:03 <jmcarthur> does it need to be well defined in haskell if it's a debugging tool?
06:34:13 <Saizan> also, the interface to read them must assume something about what they are
06:34:30 <Baughn> jmcarthur: I believe so, yes
06:35:18 <jmcarthur> then it sounds like haskell needs to be inconsistent
06:35:25 <jmcarthur> or at least to allow inconsistency
06:35:48 <Baughn> In the sense that debugging interfaces could produce different results on different compilers, _yes_.
06:36:15 <jmcarthur> and this begins to tread into the debate over what referential transparency is
06:36:32 <jmcarthur> i am on conal's side of that one
06:39:40 <jmcarthur> if this potentially inconsistent debugging interface is in the IO sin bin then i am okay with it returning different results
06:39:59 <jmcarthur> so long as it doesn't somehow modify the behavior of otherwise pure functions
06:40:16 <Saizan> observing sharing should be in IO anyway
06:40:22 <jmcarthur> agreed
06:40:34 <Baughn> I'm fine with it altering pure functions, so long as there's an IO action to do so
06:40:40 <jmcarthur> ew
06:40:46 <Baughn> Otherwise you're prohibiting switching out plugins
06:41:03 <jmcarthur> do { let x = "foo"; alter x "bar"; putStrLn x }
06:41:12 <jmcarthur> yuck yuck yuck
06:41:26 <Baughn> SUre, but..
06:41:33 <jmcarthur> you can switch out plugins without changing pure values
06:41:37 <Baughn> I believe in giving programmers the choice to do yucky things
06:41:53 <Baughn> So, apparently, does the haskell spec. Witness unsafePerformIO .;)
06:42:02 <jmcarthur> do { p <- getNextPlugin; use p; loop } or whatever
06:42:14 <flux> baughn, does the haskell spec have unsafePerformIO?-)
06:42:15 <jmcarthur> unsafePerformIO is not in the spec, is it?
06:42:24 <Baughn> You could, but it's more /convenient/ to allow alteration of global function bindings
06:42:28 <dolio> It's in the FFI spec.
06:42:31 <Baughn> Well, except for the poor compiler writers..
06:42:39 <dolio> Not the main report.
06:42:49 <jmcarthur> convenience is a poor reason to reduce guarantees about your programs
06:42:52 <jmcarthur> in my opinion
06:43:04 <Baughn> jmcarthur: Then don't use it
06:43:53 <astrolabe> Can a user of library find out easily if the library does these yucky things?
06:43:53 <jmcarthur> but i have no idea if library code uses it. it's a side effect that isn't documented by the types, and it's weird enough that i may not be able to reasonably expect it to happen
06:43:54 <ManateeLazyCat> Saizan: Thanks, now my function works nice. :)
06:44:12 <Baughn> jmcarthur: It'd be documented by the IO type
06:44:28 <jmcarthur> Baughn: but it's not documented in the type of the _pure_ function whose meaning it changes
06:44:30 <jedai> Baughn: I don't see very well how this would works with lazyness
06:44:59 <jmcarthur> i can no longer replace a pure expression with its value and expect things to still work
06:45:39 <Baughn> Well. Very well. I don't really need to alter global bindings anyhow. :P
06:45:51 <Baughn> Just read them, look them up, see what bindings exist, etc.
06:46:04 <jedai> Baughn: It would means that when changing plugins, you must be very sure you forced every single thing that used the modified function or you'll get incoherent results or bugs, or it must means that a lot more information must be attached to Haskell expressions (performances...)
06:46:53 <jedai> Baughn: As long as this is done in IO I don't think anyone here has anything against that :)
06:47:14 <jmcarthur> jedai: well, no, i think it would probably be well-defined which ones have been forced and which ones haven't. it would just be horribly hard to control and reason about
06:47:42 <jmcarthur> oh, no, it wouldn't be well defined
06:47:45 <jmcarthur> nevermind
06:47:47 <jedai> jmcarthur: I'm not so sure, remember the evaluation strategy of Haskell isn't well defined
06:48:10 <jmcarthur> jedai: the evaluation strategy is, but sharing or lack thereof is not
06:48:28 <jmcarthur> evaluation *order
06:48:43 <jmcarthur> typing before i think about what i say
06:52:47 <dolio> The evaluation order is not well defined in the report. There are just some bare minimum denotational rules you have to meet.
06:53:22 <dolio> Like, certain functions can be non-strict, where f _|_ /= _|_.
06:54:17 <mmorrow> Saizan: this paste is one method to get an StgClosure* that i've found http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2152, along with explanation and some links to relevant stuff
06:54:54 <dolio> But, there have been evaluation strategies experimented with where when a function is called, the runtime starts evaluating the arguments before calling the function, but if it takes too long, it stops (which is optimistic evaluation).
06:55:11 <jmcarthur> dolio: oh? i didn't know that. so it is incorrect to say that haskell has call-by-name/need semantics?
06:55:37 <dolio> Which avoids making things overly strict, but potentially reduces things in a different order than lazy evaluation.
06:55:38 <jmcarthur> or similar, i mean
06:55:42 <dolio> It has non-strict semantics.
06:55:50 <dolio> But that's a pretty broad category.
06:55:50 <jmcarthur> oh, just non-strict, i see
06:56:08 <pejo> jmcarthur, the idea with optimistic evaluation was that the user wouldn't notice the different evaluation order.
06:56:14 <dolio> You could also fork threads to evaluate the arguments, for instance.
06:56:17 <mmorrow> pvdbrand: unfortunately Data.Binary isn't optimized for space, and the instance of Binary for lists tries to put everything on the stack before returning
06:56:19 <jmcarthur> pejo: yes, that makes sense to me
06:57:34 * ManateeLazyCat pasted "my code" at http://paste2.org/get/186539
06:57:34 <ManateeLazyCat> Saizan: When function mix two arguments, one is normal type argument, another is `StateT` type argument, but just have one argument show in function body, it's misleading. Example the code in above link, Looks function return `StateT WindowsList IO Window` and not accept `StateT WindowsList` as argument, have a way to make those code more clearer? Thanks!
06:58:04 <pvdbrand> mmorrow: I also just noticed that uvector tries to allocate about 4 times the size of the file I'm trying to read and gets an out of memory error immediately... so I went back to my hand-crafted interface around a Data.Bytestring
06:58:51 <dolio> pvdbrand: Were you allocating an array of Word8s?
06:58:52 <ManateeLazyCat> Saizan: Have any syntax sugar can clear function type signature that mix normal argument and `StateT` argument?
06:58:55 <pvdbrand> mmorrow: I'm just being very careful now to never keep a full list in memory
06:59:00 <jmcarthur> pvdbrand: what is it that you're doing with a large file? would it be a good candidate for iteratee, perhaps?
06:59:14 <pvdbrand> dolio: no, I was using a ByteString and trying to convert that to [Word64]
06:59:27 <dolio> Oh.
06:59:28 <jedai> ManateeLazyCat: Not really, but that type doesn't shock me
06:59:46 <pvdbrand> jmcarthur: yes I think so, but I don't know much about iteratees yet, I'll look into it
06:59:50 <mmorrow> pvdbrand: yeah, i do "handcrafted" stuff when i need control over space and/or layout too
07:00:15 <jedai> ManateeLazyCat: It's a function that takes a direction and evaluate to an action in the "StateT WindowList IO" monad, this action returning a Window
07:00:16 <ManateeLazyCat> jedai: Yep, that's not shock me too, but i want my code more clearer for other people that read my code.
07:00:19 <cnwdup> Can I compile ghc successfully on ARM architectures or is there a port for that?
07:00:24 <pvdbrand> just to give some context, I'm trying to win a million bucks in the Netflix Prize ;)
07:00:34 <pvdbrand> but I've got to go now
07:00:37 <pvdbrand> see you!
07:00:56 <jmcarthur> ah, i spent a little time trying the netflix prize as well, but i got bored
07:01:08 <jedai> ManateeLazyCat: I think it's pretty clear as it is. If you're writing for beginners they'll be confused of course but any use of Monad transformers would confuse beginners anyway
07:02:01 <jedai> ManateeLazyCat: If this monad is often used in your program you could make it a new monad though (with newtype deriving), it might be easier to understand
07:02:52 <ManateeLazyCat> jedai: Yep, good idea. newtype is i want. Thanks :)
07:03:35 <jedai> cnwdup: I believe there is work ongoing for a (new) port to ARM, it seems to be pretty advanced now
07:03:40 <ManateeLazyCat> jedai: BTW, that function is evaluate in action `StateT WindowsList` and return `IO Window`. :)
07:04:27 <jedai> ManateeLazyCat: That's a strange (and incorrect) way to see it
07:05:31 * ManateeLazyCat pasted "another function use `StateT WindowsList`" at http://paste2.org/get/186545
07:05:48 <ManateeLazyCat> jedai: My another function that use `StateT WindowsList`
07:09:44 <jedai> cnwdup: Sorry I seem to be mistaken, there was a tentative but it's abandoned for now. It seems hbc works on ARM
07:10:04 <Saizan> doesn't nhc work on ARM too?
07:10:30 <mmorrow> <Baughn> Or, for that matter, being able to write vacuum without horrible GHC-specific hack
07:10:34 <mmorrow> Baughn: i second that
07:11:34 <cnwdup> jedai, is there still any documentation about that?
07:13:04 <jedai> cnwdup: if you mean the port of GHC to ARM there's a page on the developper wiki (it might be interesting to refer to the recent port to SPARC)
07:14:27 <jedai> Saizan: I know that jhc could be used as a cross-platform solution once
07:15:29 <cnwdup> jedai, thanks
07:30:46 <mmorrow> Saizan: oh, i just realized why that pointer is off.. the infoptr in closures is to the start of the code in the infotable, so adjusting by that negative offset (16bytes on x86_64) gets a ptr to the start
07:34:00 <mmorrow> Saizan: oh snap. in RtsApi.h there're (Capability *rts_lock (void);) and (void rts_unlock (Capability *token);)
07:34:54 <Clinteger> hm. I just installed ghc for windows, it doesn't work [perhaps it's a windows 7 thing?]
07:35:14 <tomh> what doesn't work?
07:35:45 <Clinteger> when i run whatever the shortcut is in the programs menu
07:36:12 <tomh> and when you go to your installation directory and try to run ghc.exe?
07:36:15 <tomh> i mean ghci.exe
07:36:48 <Clinteger> ..right :p
07:37:29 <tomh> doesn't work either or what?
07:37:40 <Clinteger> its fine haha
07:37:52 <tomh> ok
07:38:01 <Clinteger> nice that the shortcut doesn't work >_>
07:38:06 <dolio> Hey, UHC has first-class existentials.
07:38:31 <tomh> what are first-class existentials
07:39:27 <dolio> They're existentials that you don't need to introduce a new datatype to use.
07:40:37 <dolio> In GHC you have to write, say, "data Showable = forall a. Show a => S a". Then you can do "foo :: [Showable] ; foo = [S 5, S 'c', S "zap"]".
07:40:50 <sampointon> oh, handy. What kind of syntax does it use for them?
07:41:10 <dolio> In UCH, you could do "foo :: [exists a. Show a => a] ; foo = [5, 'c', "zap"]".
07:41:21 <dolio> Except it says it doesn't work with class contexts.
07:41:37 <tomh> sounds handy
07:42:04 <tomh> why not "foo :: [forall a. Show a => a] ; foo = [5, 'c', "zap"]".
07:42:23 <dolio> Because forall is for universal quantification.
07:42:45 <tomh> yeah..
07:42:59 <dolio> The fact that GHC uses forall is due to some technical argumentation that allows them to not have to add 'exists' as a keyword, more or less. :)
07:43:14 <tomh> ah ok
07:43:40 <tomh> yeah i recall from some lectures that there was some discussion about forall vs exists
07:43:55 <dolio> Specifically, packaging an existential in a type would look like "data Showable = S (exists a. Show a => a)"...
07:43:58 <solidsnack> dolio: So the `exists` doesn't actually work with classes like that?
07:44:46 <dolio> Which would make the constructor have type "S :: (exists a. Show a => a) -> Showable" but that's logically equivalent to "S :: forall a. Show a => a -> Showable"...
07:45:17 <dolio> And then they translate back to the data declaration syntax, putting the quantifier before the constructor name.
07:45:44 <tomh> ok
07:45:45 <dolio> solidsnack: Not yet, at least. But you can still do things like "foo :: exists a. (a, a -> Int)".
07:45:56 <solidsnack> Wow, this compiler has quite a few cool type-level features.
07:46:00 <sampointon> is there any chance of GHC getting first-class existentials like that?
07:46:10 <dolio> So you could roll your own dictionaries "foo :: exists a. (ShowDict a, a)".
07:47:02 <dolio> They thought about it in the past, but apparently it was dubbed to make the type system too complex or something.
07:47:37 <tomh> yeah, don't make it to complex please :)
07:48:04 <dolio> Well, I'm not sure it made use too complex, but maybe implementation.
07:48:41 <tomh> well now they can just grab the source of ehc and put it in ghc :>
07:48:53 <dolio> Heh.
07:49:46 <dolio> UHC has some other cool stuff, too.
07:49:49 <dolio> Local instances.
07:49:59 <solidsnack> yeah, that is cool
07:50:01 <burp_> I prefer zhc
07:51:17 <tomh> i wonder if uhc compiled code is as efficient as ghc compiled code
07:51:19 <solidsnack> This "essential haskell" stuff is interesting.
07:51:47 <dolio> Apparently they have polymorphic kinds, too.
07:53:17 <Trowalts> I messed this bit of code up, not sure how haskell wants it http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2155#a2155
07:54:19 <tomh> Trowalts: what do you want to do with your code
07:54:39 <tomh> it probably gets some error about overlapping pattern matching
07:55:06 <sampointon> duplicate definitions?
07:55:33 <sampointon> findbase is defined twice for every b, n
07:55:40 <Trowalts> I want it to return the biggest multiple of 256 that would divide into another number, b
07:57:28 <Trowalts> eh, b should start off as 1, not sure how I can "declare" b to start off as 1 and then still recursivly multiply it with 256 until its the right size
07:58:07 <skorpan> Trowalts: i think what you want is a helper function
07:58:23 <skorpan> e.g. findBase n = findBase' 1 n
07:58:28 <sampointon> Trowalts: let bs = 1 : map (256 *) bs in head $ dropWhile (x <) bs
07:58:50 <Baughn> Trowalts: "Biggest multiple of 256 that would divide into b" is unbounded, I'm afraid
07:59:04 <Baughn> Trowalts: 256*b would divide into b, of course. So would 256*b*N for all positive integers N
07:59:32 <sampointon> Trowalts: oops, that inequality should be the other way around (I think). But something like that will work
07:59:56 <Baughn> Trowalts: Do you want to change your mind on what you want?
08:00:40 <Trowalts> nope, but thats why I do the n > b check
08:00:44 * ManateeLazyCat pasted "my code" at http://paste2.org/get/186596
08:00:45 <ManateeLazyCat> In above code have many `liftIO`, have a way make those code simpler? Thanks!
08:01:20 <Trowalts> once b is bigger than it, it gives b /256 (go one step back) as the answer
08:01:25 <Baughn> ManateeLazyCat: For one thing, write more functions
08:01:45 <maltem> sampointon, (x `div` 256) * 256 ?
08:01:50 <Baughn> ManateeLazyCat: The three liftIO'd panel commands are the same for every panel, apparently
08:02:03 <burp_> ManateeLazyCat, liftIO $ do .. and then all the stuff
08:02:08 <monochrom> Yeah, if you define "u x = liftIO (updatePositionInto u)", you can save a lot of liftIO's.
08:02:19 <sampointon> maltem: oh yeah. I just realised I completely misread his question
08:02:27 <ManateeLazyCat> burp_: Thanks i try.
08:02:41 <burp_> liftIO $ do \n updatePositionInfo pane1 .. \n onKeyPress etc.
08:03:04 <Baughn> ManateeLazyCat: doStuffWithPane p = liftIO $ do updatePositionInfo p; onKeyPress ...; containerAdd... etc.
08:03:17 <Baughn> ManateeLazyCat: Well, though I guess you have to parametrize that on the window as well. You get the idea.
08:03:26 <maltem> sampointon, I didn't even catch the question though
08:03:35 <Taurus> anyone know java?
08:03:43 <monochrom> No.
08:03:53 <skorpan> does liftIO have any sort of overhead at all in the run-time performance of programs or is that merely for the type checker?
08:03:58 <Baughn> Trowalts: Plenty of people in ##java, I bet
08:04:04 <skorpan> Taurus: yes, and this is certainly the place to ask!
08:04:05 <Baughn> skorpan: Undefined
08:04:21 <ManateeLazyCat> Thanks all, and solution is use `liftIO do ...`. :)
08:04:21 <Baughn> skorpan: It depends on how the particular monad in question implements it
08:04:22 <burp_> skorpan, I'd say merely for the type checker ;)
08:04:27 <Taurus> is that sarcastic skorpan?
08:04:32 <skorpan> Taurus: yes! :)
08:04:34 <monochrom> No.
08:04:45 <skorpan> monochrom: i see what you did there
08:05:12 <Taurus> u never know, might of been a rougue java person in here lol
08:05:24 <Baughn> *twitch*
08:05:28 <skorpan> i'm sure there are plenty of people who know java here, but that's off-topic
08:05:44 <Taurus> just need some help
08:05:45 <Baughn> Unless you're planning to discuss implementing haskell in java or something..
08:05:51 <Taurus> no
08:05:51 <jedai> except maybe to compare with Haskell
08:05:52 <skorpan> Taurus: you should ask in ##java, not here
08:05:52 <bremner> only making fun of Java is permitted here
08:05:54 <Baughn> Trowalts: First step, type "/join #java"
08:05:55 <maltem> Taurus, try #haskell-blah then
08:06:14 <burp_> haskell on jvm
08:06:20 <sampointon> we've got BASIC embedded in Haskell, I guess Java would be possible too
08:06:23 <maltem> Taurus, if you rely on the smartness of the Haskell community :)
08:06:31 <monochrom> You people spoil the proscrastination.
08:06:36 <Taurus> i dont even know wat haskell is?
08:06:40 <jedai> I know #haskell is a nice channel but still... Soon we'll get question on VB here
08:06:47 <ManateeLazyCat> But "liftIO $ do ..." got another problem, if lines mix normal code and `liftIO` code, how to do then?
08:06:48 <maltem> Taurus, oh, then you're wrong here entirely
08:06:49 <skorpan> haskell is a completely different programming language than java, Taurus
08:06:56 <jedai> Taurus: How the hell did you come here then ?
08:06:57 <maltem> Taurus, unless you want to learn it
08:06:58 <vixey> LOL
08:07:04 <vixey> @remember  <Taurus> i dont even know wat haskell is?
08:07:04 <lambdabot> Done.
08:07:08 <ManateeLazyCat> Like above
08:07:09 * ManateeLazyCat pasted "my code" at http://paste2.org/get/186600
08:07:11 <ManateeLazyCat> above
08:07:16 <mauke> @quote Taurus
08:07:16 <lambdabot> No quotes match. Take a stress pill and think things over.
08:07:20 <mauke> vixey: fail
08:07:21 <monochrom> No we won't get questions on VB, jedai. We will just get questions on who knows VB.
08:07:22 * kadaver contemplates drinking acid instead of trying to read more maths
08:07:23 <skorpan> vixey: that's not really funny out of context though
08:07:24 <vixey> mauke: agreed
08:07:28 <bremner> @users
08:07:28 <lambdabot> Maximum users seen in #haskell: 658, currently: 608 (92.4%), active: 19 (3.1%)
08:07:45 <aLegendaryPengui> @quote LegendaryPenguin
08:07:45 <xenoblitz> guys does anyone here have any idea of loop combinators?
08:07:45 <lambdabot> No quotes match. stty: unknown mode: doofus
08:07:46 <Baughn> ManateeLazyCat: You don't need parantheses around the if predicate
08:08:48 <jedai> Trowalts: If you're still trying to put a number in base 256, look at the divMod function, it's really all you need to do it properly and efficiently
08:09:32 <ManateeLazyCat> Baughn: http://paste2.org/get/186600 mix `normal` code and `liftIO` code, have a way to make those code more simper?
08:09:40 <cnwdup> Could I use a ghc arm binary from debian in order to compile ghc form archlinux arm? Or is this not adviced?
08:09:47 <monochrom> Either humans or computer are too lazy to remove < >'s when using @remember.
08:10:04 <ManateeLazyCat> Baughn: It's tired that type too many `liftIO`. :)
08:10:08 <cnwdup> s/form/for/
08:10:20 <xenoblitz> just in case some one knows them under a different name... monads have been used in domain-specific languages to solve the problems related to referential transparency... for objects with loops you need a loop combinator or something which allows you to monadically add a loop... any one know about this or read about monadic Lava EDSL?
08:10:31 <Baughn> ManateeLazyCat: I'm working on it
08:10:33 <jedai> xenoblitz: What do you mean "loop combinators" ? until ? forM_ ?
08:10:39 <Baughn> ManateeLazyCat: There are a /lot/ of transformations to do, so give me a bit.
08:10:49 <ManateeLazyCat> Baughn: Thanks
08:11:04 <jedai> xenoblitz: Do you mean mfix ?
08:11:25 <xenoblitz> jedai: i came across the term in a paper by Claessen... he uses them to create loops in structures representing circuits
08:11:35 <Berengal> xenoblitz: ArrowLoop?
08:12:06 <monochrom> tying the knot
08:12:10 <xenoblitz> Berengal: could be but I never used arrows
08:12:20 <xenoblitz> just a sec let me find you my earlier Hpaste
08:12:24 <jedai> xenoblitz: Yes, you have an extension to GHC with the mdo-notation that add syntax sugar around mfix
08:12:39 <Baughn> ManateeLazyCat: "panedPack1/2" are /really horrible/ function names, by the way
08:13:03 <xenoblitz> jedai: this could explain better what I mean: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3892
08:13:04 <jedai> xenoblitz: The main use as alluded by monochrom is to tie the knot in monadic code
08:13:22 <monochrom> I am an allusion!
08:13:22 <koeien> cool! UHC
08:13:38 <xenoblitz> monochrom: hmmm so it could be I need that then
08:13:55 <ManateeLazyCat> Baughn: You have to talk with Gtk developers. :)
08:13:57 <jedai> xenoblitz: Yes, that's mfix and mdo role
08:14:02 <jedai> @hoogle mfix
08:14:03 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
08:14:15 <monochrom> no news in comp.lang.haskell
08:14:27 <xenoblitz> jedai: never used them... I'll look them up... thank you very much
08:15:02 <ManateeLazyCat> Baughn: Yep, remove parantheses around the if predicate make code more simper, i got another tip, thanks!
08:16:39 <Baughn> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3899#a3899 <-- Something like this?
08:16:49 <Baughn> Well, although I altered the return type a bit
08:17:04 <Baughn> You'll have to fix that, one way or the other
08:17:34 <monochrom> C goes like "if (b) (x=1);" because C does not have "then". Note "if b (x=1);" is ambiguous but "if b then (x=1);" is not.
08:17:42 <Baughn> ManateeLazyCat: Oh, and there seems to be a spurious panedPack1 in there
08:18:27 <Trowalts> thanks jedai
08:19:07 <ManateeLazyCat> monochrom: Thanks, i see.
08:19:36 <xenoblitz> jedai: thanks man ... it compiles and gives me an answer  :) however I am getting a count of 1 instead of 2... but at least its a great step forward
08:20:40 <Baughn> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3899#a3900 <-- Here's an even denser version
08:20:49 <xenoblitz> jedai: ps I am using the code in the hpaste to count the number of gates in a circuit with loops :)
08:20:54 <Baughn> @pl \f b -> f b True True
08:20:54 <lambdabot> flip flip True . flip flip True
08:23:10 <vixey> :t flip flip True . flip flip True
08:23:11 <lambdabot> forall c a. (a -> Bool -> Bool -> c) -> a -> c
08:23:45 <Baughn> :t flip flip
08:23:47 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
08:24:08 <Baughn> ..I'm not sure I /want/ to understand this one
08:24:11 <Baughn> I might be tempted to use it
08:24:58 <dolio> flip swaps the first two arguments of a function. So flip flip gives you flip with the first two arguments swapped.
08:25:15 <Baughn> But.. but flip only takes one argument
08:25:20 <Baughn> :t flip
08:25:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
08:25:25 <Baughn> Well
08:25:28 <Baughn> Um.
08:25:44 <mpeter> uhhh
08:25:52 <vixey> lol
08:25:59 <mpeter> wait
08:26:09 * mpeter walks away
08:26:26 <mauke> flip f x = \y -> f y x
08:27:32 <ManateeLazyCat> :t (!!)
08:27:34 <lambdabot> forall a. [a] -> Int -> a
08:27:38 <LeoD> :t (flip flip) map
08:27:38 <lambdabot> forall a c a1 b. (a -> ((a1 -> b) -> [a1] -> [b]) -> c) -> a -> c
08:27:47 <LeoD> oops
08:29:06 <sampointon> :t map (flip flip)
08:29:07 <lambdabot> forall a b c. [b] -> [(a -> b -> c) -> a -> c]
08:30:57 <jrx> hi everyone, I'd like to speed up my array code in haskell, and I read that I should use unsafeRead/WriteArray, but I cannot find these functions anywhere
08:31:12 <jrx> how to get access to them?
08:31:49 <ManateeLazyCat> :t id
08:31:50 <lambdabot> forall a. a -> a
08:32:39 <c_wraith> @hoogle unsafeReadArray
08:32:39 <lambdabot> No results found
08:32:48 <pejo> @hoogle unsafeRead
08:32:49 <lambdabot> Data.Array.Base unsafeRead :: (MArray a e m, Ix i) => a i e -> Int -> m e
08:32:57 <c_wraith> Ah.
08:33:11 <pejo> jrx, there's a reason it is named "unsafe" though.
08:33:29 <jrx> pejo: ah, thanks ;)
08:34:00 <jrx> pejo: no bounds checking, as I heard but I think I'm pretty safe for that at the moment
08:35:25 <c_wraith> Int as the second arg?
08:35:53 <c_wraith> Hmm.  That totally skips all Ix use, doesn't it?
08:35:58 * c_wraith goes to look it up
08:40:34 <Gracenotes> ..
08:40:39 <Gracenotes> @botsnack
08:40:40 <lambdabot> :)
08:40:40 <lunabot>  :)
08:43:03 <olsner> @pl \(x,y) -> x:y:xs
08:43:04 <lambdabot> uncurry ((. (: xs)) . (:))
08:44:14 <Trowalts> is there a function to convert an Integer into an Int?
08:45:17 <cnwdup> Trowalts, doesn't fromIntegral work?
08:45:21 <jmcarthur> :t fromIntegral
08:45:22 <lambdabot> forall a b. (Num b, Integral a) => a -> b
08:45:28 <cnwdup> > fromIntegral (0::Integer)::Int
08:45:30 <lambdabot>   0
08:45:37 <cnwdup> > fromIntegral (2^32+1::Integer)::Int
08:45:39 <lambdabot>   4294967297
08:45:55 <jmcarthur> :t maxBound :: Int
08:45:56 <lambdabot> Int
08:46:03 <jmcarthur> > maxBound :: Int
08:46:04 <lambdabot>   9223372036854775807
08:46:35 <jmcarthur> > fromIntegral (fromIntegral (maxBound :: Int) + 1 :: Integer) :: Int
08:46:36 <lambdabot>   -9223372036854775808
08:47:08 <Japsu> > log (fromIntegral 9223372036854775807) / log 2
08:47:09 <lambdabot>   63.0
08:47:29 <jmcarthur> :t logBase
08:47:30 <lambdabot> forall a. (Floating a) => a -> a -> a
08:47:38 <Trowalts> yes it does, ty!
08:47:53 <jmcarthur> @src logBase
08:47:53 <lambdabot> Source not found. My mind is going. I can feel it.
09:09:04 <bavardage> with parsec, how do I do something like sepBy2
09:09:12 <bavardage> as in 'two or more' seperated by ...
09:09:31 <skorpan> sepBy2 x = x `andThen` sepBy1 x
09:09:36 <skorpan> (i don't know any parsec at all)
09:10:28 <bavardage> I'll try it :D
09:10:39 <skorpan> andThen is not a function, btw :P
09:10:43 <skorpan> at least not to my knowledge
09:11:07 <skorpan> and i missed the separator and everything.. you get the point
09:11:25 <bavardage> right
09:17:37 <vixey> bavardage: you should write sepByN though
09:26:29 <dons> anyone want a new haskell compiler? http://www.reddit.com/r/programming/comments/8dik8/live_from_hac5_the_utrecht_haskell_compiler/
09:28:11 <bavardage> ANOTHER ONE!!!
09:28:35 <nlogax> gotta catch'em all!
09:28:36 <Berengal> You can never have enough compilers
09:28:54 <bavardage> so what does this do that others don't?
09:28:58 <bavardage> what is its killer feature?
09:29:05 <luqui> hopefully it has a typed low-level form
09:29:06 <Raevel> woah
09:29:09 <flux> jhc sounded interesting, but apparently it hasn't yet lived up to the ideas?
09:29:13 <RayNbow> in the near future, every university city has its own Haskell compiler
09:29:24 <luqui> One Haskell compiler per Monad tutorial!
09:29:26 <mercury^> Compiles via C. :<
09:29:40 <bavardage> glasgow started something
09:29:48 <bavardage> doesn't ghc go via C first too?
09:30:17 <scook0> I think it defaults to -fasm these days
09:30:29 <kadaver> why do they bother?
09:31:09 <kadaver> what are the haskell strongholds? oxford,cambridge,utrecht,...?
09:31:53 <bavardage> glasgow?
09:32:15 <bavardage> perchance
09:32:30 <kadaver> no that is just a scapegoat if Sun tries to kill off all haskellers
09:32:33 <Berengal> The internet?
09:33:12 <RayNbow> it's a shame that while Haskell is being taught in Delft (first year course), there are no advanced FP courses being taught
09:33:54 <luite> RayNbow: you could probably do advanced functional programming at uu and get your credits transferred
09:34:09 <RayNbow> I already have sufficient credits :p
09:34:37 <luite> oh, but I'm sure they will allow you to attend the course if you ask nicely ;)
09:34:38 <RayNbow> and I don't like traveling to Utrecht :p
09:35:03 <RayNbow> Utrecht + public transport = unstable mix :p
09:35:24 <roconnor> but the trains in .nl are so nice
09:35:54 <luite> RayNbow: I don't think it's that bad actually, but the buses are quite busy at times, especially in the morning
09:36:32 <RayNbow> roconnor: but for me Utrecht is terrible... if public transport fails, I'll have a hard time getting home ;)
09:37:26 <luite> RayNbow: probably still better than by car
09:37:43 <roconnor> RayNbow: is that likely?  You could take a taxi in those cases?
09:37:54 <RayNbow> I don't have a car, nor a license, luite :p
09:38:14 <kadaver> is it ugly filling a program with typesynonyms? if a program used a  lot of similar types I just find it much clearer to use them.
09:38:17 <RayNbow> roconnor: students are cheapskates... they don't want to spend money on transportation :p
09:38:45 <roconnor> RayNbow: perhaps you are right
09:38:46 <RayNbow> kadaver: why would type synonyms be ugly?
09:39:09 <luite> RayNbow: but it's very unlikely for the public transport to fail completely, at worst, you could be home an hour late I guess... unless the lectures are so late that you need to get the last train?
09:39:10 <gwern> kadaver: if you're using a lot of synonyms, you may be losing a lot of possible type safety
09:40:02 <RayNbow> luite: did you forget about the meltdown of the trains in Utrecht a few years ago? :p
09:40:24 <luite> RayNbow: I was in it I guess
09:40:57 <luite> not sure if it's the same, but massive delays due to some power failures at several stations
09:41:12 <RayNbow> kadaver: type synonyms serve as documentation
09:41:36 <RayNbow> if you want more type safety, you should use newtypes
09:42:19 <luite> RayNbow: but those situations are quite exceptional, just like the more recent one with a derailed freight train damaging miles of tracks and railroad switches
09:42:25 <RayNbow> luite: I remember that one meltdown occured in a HCC weekend
09:42:35 <RayNbow> (I was lucky to be on my way home early that day :p)
09:42:42 <RayNbow> true :p
09:43:09 <RayNbow> hmm
09:43:23 * RayNbow wonders if in the future, railway software will be written in Haskell :p
09:43:37 <Berengal> Haskell on Rails?
09:43:54 <RayNbow> :p
09:44:19 <smtms> lazy railway software
09:44:42 <paper_cc> smtms: the train doesn't arrive until there's somebody waiting for it
09:45:21 <RayNbow> and the trains would be typesafe
09:45:28 <RayNbow> only accepting PayingCustomers :p
09:46:02 <paper_cc> uuagc-0.9.7 from Hackage doesn't compile for me on AMD64 :(
09:46:04 <Berengal> what if an unpaying customer managed to sneak on board? Would it blow up?
09:46:53 <sampointon> Berengal: there'd be a very unsafe coercion
09:46:56 <paper_cc> It will announce "The impossible just happened"...
09:47:15 <RayNbow> at least we would have to file a bug report, since the typechecker was not doing its job
09:47:20 <RayNbow> (or it was on strike)
09:47:25 <paper_cc> (can anyone help with uuagc?)
09:47:26 <RayNbow> (demanding higher pays)
09:47:58 <Saizan> paper_cc: when compiling or when using it?
09:48:08 <gongat> http://www.ihatemindy.com/index.php?c=viral&m=index&id=60d9623105a2cbd8cecae0f8bdb4dd77
09:48:36 <paper_cc> Saizan: when compiling
09:48:42 * paper_cc makes a paste
09:49:01 --- mode: ChanServ set +o Saizan
09:49:08 --- mode: Saizan set +b *!*=484df868@gateway/web/ajax/mibbit.com/x-4d2439e9099c8d72
09:49:08 --- kick: gongat was kicked by Saizan (Saizan)
09:49:28 --- mode: Saizan set -o Saizan
09:50:20 <Saizan> paper_cc: which version of ghc? it worked for me with 6.10.2, on x86-64
09:50:22 <luite> RayNbow: hm, I don't know anything about their daily operational software, but I do know that haskell was not used for their planning and scheduling systems, even though one of those systems is called dons :p
09:50:29 <paper_cc> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3903#a3903 -- the problem seems quite strange for me
09:50:33 <paper_cc> Saizan: 6.10.1
09:52:19 <Saizan> paper_cc: ah, sorry, i'm testing with uuagc-0.9.10
09:53:22 <paper_cc> aha
09:53:35 * paper_cc tries to understand why cabal-install selected 0.9.7
09:54:26 <Saizan> maybe you need to "cabal update"?
09:54:32 <RayNbow> luite: I only know that ProRail uses VAX hardware
09:54:56 <Saizan> though hackage doesn't report build failures for 0.9.7 either
09:55:02 <paper_cc> Saizan: yes =) 0.9.10 is two days old and compiles fine
09:55:08 <edwardk> sampointon: i suppose it if twas an unsafeCoerce into a PayingCustomer, all would be well
09:55:15 <luite> RayNbow: ah, don't know about that. only know something about the scheduling part, which was done by CWI, using ilog and cplex
09:55:54 <ski> "This directory contains `brisk', the Bristol Haskell System, version 0.0.","Brisk has been tested with ghc, hbc and gofer."
09:56:13 <luite> I'm not sure if there's any open source library that can compete with those expensive proprietary programs for mixed integer programming
09:56:35 <ManateeLazyCat> Baughn: The code of `bodies` is beaut, thanks.
09:59:46 <glguy> What does this mean... "ld warning: atom sorting error for _evpzm0zi0_EVP_EVPzuCIPHERzuCTX_closure_tbl and _evpzm0zi0_EVP_EVPzuCIPHER_closure_tbl in dist/build/EVP.o"?
10:01:02 <zombiekadaver> should I use use data instead?
10:01:40 <pejo> glguy, http://hackage.haskell.org/trac/ghc/ticket/2578
10:01:54 <glguy> pejo, yeah, I just managed to find that...
10:02:14 <ski> zombiekadaver : instead of .. ?
10:03:02 <zombiekadaver> train :: Neuron -> Goal -> Epochs -> LearningRate -> Neuron
10:03:21 <zombiekadaver> instead of train:: Neuron -> Double -> Int -> Double -> Neuron
10:04:17 <ski> you could use type synonyms (or `newtype') as well
10:07:41 <zombiekadaver> id mostly want something like if it is once passed as type X then it cant be passed as a Double evn if it is just a synonym for a Double
10:07:51 <zombiekadaver> the constructor stuff is annoying
10:10:01 <ski> what do you mean by "once passed as type X" ?
10:10:33 <ski> if you do `data' or `newtype', then you can't accidentally confuse `X' and `Double'
10:11:11 <ski> but maybe you also want to be able to use floating-point literals as parameters of type `X' ?
10:11:33 <ski> and maybe you also want to use `(+)',et.c. on values of type `X' ?
10:12:15 <zombiekadaver> i know but id like type to function as newtype without a construcytor
10:12:57 <ski> just for local usage within a module (or even just some of the operations in a module) ?
10:13:15 <zombiekadaver> yes
10:13:40 <ski> then Hugs has a feature like that, under the name `restricted type synonyms'
10:14:02 <ski> unfortunately, i know of no other haskell implementation having something like this
10:14:10 <ski> in Hugs, you can type something like
10:14:19 <ski>   type Stack a = [a]
10:14:29 <ski>     in empty :: Stack a
10:14:39 <ski>        push :: a -> Stack a -> Stack a
10:14:42 <ski>        ...
10:15:21 <ski> then only in the definition of `empty',`push', et.c. is `Stack a' known to be the same as `[a]'
10:15:47 <ski> "outside" of that, it acts like a `data' or `newtype' which is abstractly exported from a module
10:15:49 <cnwdup> Is there more accurate / detailed information about cross-compiling an unregistered GHC besides here: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting ? Even though I use ghc 6.4 the directories seem to be inaccurate.
10:18:48 <cnwdup> Ah, in the manual the paths seem to be correct.
10:20:55 <Gracenotes> @slap Gracenotes_
10:20:55 <lambdabot> I don't perform such side effects on command!
10:21:05 <Gracenotes_> @slap Gracenotes
10:21:06 <lambdabot> I don't perform such side effects on command!
10:21:21 <ski> lambdabot: @slap lunabot
10:21:22 * lambdabot is overcome by a sudden desire to hurt lunabot
10:21:46 <Gracenotes_> > text "IRC no longer br0ken?"
10:21:48 <lambdabot>   IRC no longer br0ken?
10:22:06 <zombiekadaver> ok
10:22:06 <zombiekadaver> god im so frustrated i csant get a simple Neural Network to work because i dont get the formulas
10:50:45 <zombiekadaver> randWeights' :: IO [Double]
10:51:18 <zombiekadaver> randWeights inputs len = take inputs $ repeat $ take len randWeights'
10:51:18 <zombiekadaver> randWeights should gen: IO [[Double]]
10:51:18 <zombiekadaver> but i cant
10:51:40 <pumpkin> omg kadaver isn't just dead, he's undead now!
10:52:41 <sampointon> zombiekadaver: you need an fmap in there somewhere, because randWeights' is IO [Double], but take is Int -> [Double] -> [Double]
10:53:28 <sampointon> zombiekadaver: possibly: randWeights inputs len = fmap (take inputs . repeat . take len) randWeights'
10:53:34 <zombiekadaver> sampointon but how+
10:55:10 <zombiekadaver> ty!
10:56:29 <memento> hi!
10:58:57 <sampointon> has anyone written a conversational chatbot in Haskell?
10:59:02 <memento> i've installed gtk2hs from libghc6-gtk-dev_0.9.13-2ubuntu3_amd64.deb then i'm trying to install grapefruit-ui-gtk but it sais:
10:59:13 <memento> There is no available version of gtk that satisfies >=0.9.13 && <0.11
11:02:06 <gwern> memento: what are your flags?
11:04:07 <memento> gwern: what kind of flags?
11:05:37 <gwern> --user etc
11:07:51 <memento> actually im using the default flags so just cabal install grapefruit-ui-gtk ...
11:09:06 <Saizan_> memento: what does ghc-pkg list gtk says?
11:12:44 <memento> mmm nothing, probably it's because i've installed ghc6.10 from tar and the libghc6-gtk-dev_0.9.13-2ubuntu3_amd64.deb is for 6.8 what's in the repo?!
11:13:20 <memento> is it make sense?
11:14:36 <memento> now im trying gtk2hs 0.10. from tar too
11:15:21 <memento> i made configure && make && make install but ghc-pkg list gtk still empty
11:22:10 <jedai> memento: The first thing to check is what version of ghc you're using exactly "ghc -V" should tell you that
11:22:33 <memento> 6.10.1
11:25:10 <jedai> memento: Ok, now if you had done your ./configure && make && sudo make install correctly you should have installed the library gtk for this ghc (check the version of ghc-pkg too to be sure), so there has been a problem in one of those phase
11:27:45 * ManateeLazyCat pasted "gtk2hs depend packages for Debian (or Ubuntu) system." at http://paste2.org/get/186707
11:27:48 <ManateeLazyCat> memento: See above
11:28:49 <ManateeLazyCat> memento: Now Ubuntu just support ghc 6.8, so after you install ghc 6.10.1, you just need install the packages that i post, then compile gtk2hs with source, and everything is okay.
11:29:05 <memento> ManateeLazyCat: thx, i'm trying
11:29:59 <memento> ManateeLazyCat: ok thx:)
11:31:21 <ManateeLazyCat> memento: I'm use Ubuntu too, and gtk2hs 0.10 works with ghc 6.10.1, i never install package that beginning with `libghc6-*`, because too old in Debian sources, so i found those depend packages with compile information.
11:32:04 * sampointon wishes ghc 6.10 would graduate out of debian sid already
11:32:19 * alexsuraci is trying to wrap his head around compiling his language with LLVM
11:32:24 <skorpan> i never got the deal with debian
11:32:34 <skorpan> what's "good" about it?
11:32:36 <alexsuraci> got print("foo") and dump(50.0) to work, no idea how I
11:32:46 <alexsuraci> ll do different types of functions all from one function
11:32:49 <alexsuraci> stupid enter key.
11:33:20 <bremner> skorpan: err, you want a flamewar, or a serious answer?
11:33:26 <skorpan> bremner: a serious answer
11:33:56 <ManateeLazyCat> memento: When you ./configure gtk2hs 0.10.1, will got "sourceview no", ignore it, either "sourceview yes" or "gtksourceview2 yes" is okay, and "gtksourceview2" is newer one.
11:33:57 <bremner> skorpan: lots of software is packaged, and it all works together reasonably well
11:34:32 * vixey thinks it's weird skorpan is asking about this in #haskell 
11:34:46 <vixey> after telling people java is offtopic..
11:34:50 <bremner> heh
11:35:10 <bremner> at least haskell runs in debian, but not yet in jvm
11:35:22 <ManateeLazyCat> skorpan: Package depend
11:36:03 <skorpan> vixey: right
11:36:05 <ManateeLazyCat> skorpan: aptitude, you have ask this problem in #debian. :)
11:36:21 <skorpan> i just wanted a short serious answer, not a discussion
11:36:44 <monochrom> debian has a good package framework and a good policy on FOSS.
11:37:01 <monochrom> oh, they're also paranoid about stable software. :)
11:37:29 <skorpan> monochrom: (admittedly going off-topic) that's what always annoyed me with debian
11:37:30 <ManateeLazyCat> monochrom: That's why i changed to Ubuntu.
11:37:45 <monochrom> These three combined means paradise for sysadmins. Fewer security and buggy issues, and easier maintenance too.
11:37:47 <bremner> skorpan: well, consider asking in #debian, what is so great about Haskell
11:37:55 <vixey> @dict hypocrit
11:37:55 <lambdabot> Supported dictionary-lookup commands:
11:37:56 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
11:37:56 <lambdabot> Use "dict-help [cmd...]" for more.
11:38:11 <monochrom> Yes, I don't use debian either. I use ubuntu too.
11:38:27 <skorpan> geez, i guess i'll just drop it then
11:38:33 <skorpan> NO TALKING ABOUT DEBIAN HERE!
11:38:43 <vixey> awesome
11:38:51 <monochrom> But I can see a server admin has other priorities. Updating software every other day is not fun.
11:40:34 <monochrom> For security reasons you also want absolute FOSS since proprietory software are empirically proven to be problematic. So for example sysadmins have no beef with GHC. We know it has no back door. :)
11:41:06 <jekor> If I have some fatal error in my FastCGI program, will forkOS protect me more than forkIO? If my program hits an error it can't recover from, will it be contained in the process (forkOS) instead of killing the entire program (forkIO as I understand it)?
11:41:08 <bremner> monochrom: actually, ghc is problematic
11:41:16 <monochrom> haha
11:41:18 <gwern> monochrom: because you can't bootstrap it
11:41:30 <gwern> so you have ritchie's famous evil compiler exploit
11:41:43 <monochrom> True
11:42:05 <gwern> and I wonder how much of ghc has been audited by non-ghc devs...
11:42:14 <gwern> foss doesn't mean much if there are no eyebalsl
11:43:25 <jekor> Hmm...maybe I made an incorrect assumption about what forkOS does.
11:43:50 <memento> ManateeLazyCat: <command line>: unknown package: cairo-0.10.0
11:44:05 <memento> gtk2hs make sais this
11:44:41 <sampointon> gwern: I also wonder how big the pool of potential objective auditors is, because there aren't that many haskell hackers in the first place, let alone non-ghc-involved haskell hackers
11:45:02 <gwern> a subset of a subset of a subset...
11:45:26 <gwern> programmers->fp programmers->haskell programmers->ghc programmers
11:45:28 <sampointon> or we could throw the GHC codebase at a Java programmer and let them figure it out as they go :)
11:45:56 <ManateeLazyCat> memento: Post your output information.
11:46:26 <pejo> sampointon, UHC was discussed earlier, there's also yhc, nhc, and so on. I think it's time that is missing, not skills.
11:46:36 <monochrom> "Learn to become a haskell compiler in 21 days by eating GHC source code raw" :)
11:47:12 <monochrom> . o O ( Why are we obsessed with making fun of java and java programmers? :) )
11:47:27 <gwern> pejo: wasn't ehc the educational one?
11:47:53 <gwern> monochrom: because c and c++ are too easy targets, and no one we care about defends using them in any but very narrow contexts
11:48:02 <memento> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3904#a3904
11:48:32 <pejo> gwern, apparently it grew out of EHC, but I don't know anything about that project.
11:48:52 <malouin> What can I use to get stdout from shell commands (like the perl/sh `ls`) that works with ghc 6.8.2 (ie, debian stable)?
11:48:55 <zombiekadaver> why does some packages jsut fail to install?
11:48:59 <zombiekadaver> daat accessor for example
11:49:04 <gwern> pejo: oh really? hm
11:49:20 <dolio> C and C++ are easy targets, but Java isn't?
11:49:24 <zombiekadaver> isnt there some easy way to just compose midi music in some way i dotn care
11:49:42 <zombiekadaver> C++ ahs its place, java doesnt?
11:49:54 <monochrom> malouin: Some functions in the module System.Process do that. They're quite flexible. This also means they take more parameters.
11:50:44 <ManateeLazyCat> memento: Have you installed package "libcairo2-dev" ?
11:51:21 <malouin> monochrom: ok, I've been messing with System.Process, and it's pretty convenient to just grab stdout on newer versions... haven't dug through the module enough to understand how to do it with the version I have available, but it sounds like I'm on the right track; thanks.
11:51:36 <olsner> is it possible to set a timeout on quickcheck?
11:52:08 <monochrom> Yeah, the newer version is quite an improvement.
11:52:13 <ManateeLazyCat> memento: Best, remove "libghc6-gtk-dev_0.9.13-2ubuntu3_amd64.deb" (or others similar packages) first, then test again.
11:52:56 <memento> ok
11:53:09 <memento> yeah libcairo2-dev installed
11:53:23 <ManateeLazyCat> memento: The packages that for gtk2hs-0.9.13 or ghc-6.8.2 perhaps will make you failed.
11:53:47 <ManateeLazyCat> autoconf && ./configure --enable-docs && make && sudo make install
11:53:57 <w0rth> what's wrong with this: tmeval (TmFix var ty tm) n = Evaluator (\s -> (f, s') where (f, s') = (tmeval tm (extend n var f)) s)
11:54:03 <ManateeLazyCat> memento: Above is my install method for gtk2hs 0.10
11:54:16 <w0rth> gives me a parse error on input `where'
11:54:59 <Saizan_> w0rth: you can't have a where in a lambda expression
11:55:11 <athos> > 1253/2500
11:55:13 <lambdabot>   0.5012
11:55:18 <w0rth> Saizan_: hm okay thanks
11:55:37 <Saizan_> w0rth: you can use let
12:23:55 <olsner> blimey, quickcheck is finding bugs in my code
12:24:41 <pumpkin> amazing innit!
12:24:44 <pumpkin> helped me do that too :D
12:25:34 <sampointon> ascii is very poor at encoding london-ish :(
12:26:03 <sampointon> I was trying to write a reply entirely in slang, but I realised I can only speak it, not write it
12:27:51 <w0rth> lookup looks up a key in an association list; is there a similar function that updates a key in an association list, if the key exists?
12:30:05 <mauke> why not use a Map?
12:30:47 <w0rth> mauke: how would you use map?
12:31:10 <mauke> not map. a Map.
12:32:14 <w0rth> mauke: i see
12:37:11 * da-x understands Just Nothing in haskell.
12:38:06 <ManateeLazyCat> Bye all.
12:39:16 <da-x> What I meant to say is that 'Just Nothing' is a valid haskell expression, and I understand it :)
12:39:48 <alexsuraci> but do you understand Just (Just Nothing)? :o
12:41:10 <da-x> there's a slogan for you: You don't really know haskell until you understand Just Nothing.
12:41:56 <mreh|away> i just banned from
12:42:04 <mreh|away> ##php in five minutes
12:44:27 <vixey> mreh ok
12:47:22 <mreh> hanging around here i thought the atmos in more popular channels might be the same
12:47:43 <mreh> i said php couldn't decide if it was perl or not, and got a ban
12:48:04 <vixey> PHP is for 8 year old girls anyway
12:48:16 <mreh> that's why it has PG rating
12:48:37 <bremner> vixey: some 8 year old girl is going to kick your ass for saying that
12:48:52 <mreh> the admin on the channel
12:49:13 * Saizan_ wish he were an 8 year old girl
12:49:14 <vixey> bremner:  * Topic for ##php is: Stable PHP versions: 5.2.9, 4.4.9 || Testing: 5.3.0RC1 ||  bot is offline - h/w failure || ignorance is no excuse || this is a PG channel - pretend your 8yo niece is here || Submit your code to  http://codepad.org and tell us the issue and the link, Don't flood by pasting in the channel.
12:49:35 <bremner> oh, fair enuff then.
12:53:05 <Apocalisp> @check \x -> not (null x) ==> (head . fmap fst &&& head . fmap snd) x == ((head . fmap fst) &&& (head . fmap snd)) x
12:53:06 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:53:06 <lambdabot>           ...
12:53:49 <Apocalisp> @check \x -> not (null x) ==> (head . map fst &&& head . map snd) x == ((head . map fst) &&& (head . map snd)) x
12:53:50 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
12:53:50 <lambdabot>           ...
12:53:53 <Apocalisp> grr
12:54:27 <Deewiant> @check \x -> null x || (head . map fst &&& head . map snd) x == ((head . map fst) &&& (head . map snd)) x
12:54:28 <lambdabot>   "OK, passed 500 tests."
12:56:42 <therp> vixey: I'd rather say Haskell is for 8 year old girls
12:57:07 <mreh> ban him
12:58:30 <Apocalisp> Thanks Deewiant
13:00:10 <Trowalts> can someone explain this error to me please
13:00:13 <Trowalts> *** Term           : num2str (head xs)
13:00:13 <Trowalts> *** Type           : [Char]
13:00:13 <Trowalts> *** Does not match : Char
13:00:23 <pumpkin> that's HUGS?
13:00:34 <pumpkin> hugs even
13:00:41 <Trowalts> yeah
13:00:48 <pumpkin> either it wants a Char and you gave it a String, or it expects a String and you gave it a Char
13:01:06 <sampointon> wouldn't num2str be Num a => a -> String?
13:01:19 <pumpkin> not sure, never heard of that function
13:01:21 <mauke> num2str returns a string, but the surrounding context wants a char
13:01:23 <pumpkin> but the name might imply it :P
13:01:29 <sampointon> mauke: that was my reading too
13:01:52 <sampointon> either that or the context wants a list of strings
13:01:52 <Trowalts> I'll paste the code now
13:02:38 <Trowalts> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2157#a2157
13:03:22 <mauke> yeah, there's your problem
13:03:38 <sampointon> Trowalts: (:) is a -> [a] -> [a], but you have String as both arguments
13:03:42 <mauke> '| xs /= []' is completely pointless
13:03:59 <mauke> head xs/tail xs better written as pattern matching
13:04:09 <mauke> shouldn't blocks2str return a list of strings?
13:04:22 <Trowalts> no just a string
13:04:29 <Trowalts> here is a bit more info http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2157#a2158
13:05:13 <mauke> num2str returns a string for every number in the input. what do you want to do with all those strings?
13:05:35 <pumpkin> would it be correct to say that there exist two functions with type signature a -> a?
13:05:38 <Trowalts> no it returns one string
13:05:53 <mauke> Trowalts: ... and you call it for each number in the input list
13:05:54 <pumpkin> id and _|_?
13:06:06 <mauke> pumpkin: and const _|_
13:06:06 <dolio> There are 3 in Haskell, technically.
13:06:07 <sampointon> Trowalts: block2str looks like it should be concatMap . map num2str
13:06:27 <pumpkin> aha
13:06:38 <sampointon> Trowalts: you're going over every element of the list and applying num2str to it, which is what map does
13:06:39 <pumpkin> where _|_ is distinguishable from const _|_
13:06:44 <pumpkin> by seq?
13:06:46 <pumpkin> or rather
13:06:47 <pumpkin> by applying it
13:07:10 <Trowalts> I know there are way more elegant ways to do this
13:07:13 <sampointon> Trowalts: and then I'm guessing from the types you want String, not [String], so you need to concat it all together
13:07:34 <mauke> Trowalts: so what do you want to do with the strings?
13:07:35 <dolio> If you get rid of polymorphic seq, there are two.
13:07:36 <Trowalts> thats what I'm trying with num2str (head xs):blocks2str (tail xs)
13:07:41 <pumpkin> ah
13:08:11 <sampointon> Trowalts: if you do num2str (head xs) ++ blocks2str (tail xs), it should work
13:08:30 <zombiekadaver> are neuralnets jsut for binary classification?
13:09:27 <pumpkin> nope
13:09:29 <Trowalts> sampointon: thanks it worked!
13:15:55 * pumpkin needs to get over his fear of fgl
13:16:38 <pumpkin> anyone around who's used it for anything big?
13:17:08 <NEEDMOAR> Are you kidding?
13:17:22 <pumpkin> nope
13:17:28 <NEEDMOAR> Haha!
13:18:06 <pumpkin> ... :P
13:18:08 <zombiekadaver> fgl?
13:18:16 <pumpkin> @hackage fgl
13:18:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
13:18:52 <zombiekadaver> i tried some haskell graph lib, didnt like it :P, wasnt that oen though
13:19:33 <mux> I've used fgl for some project euler exercises, it worked fine, but it wasn't anything big
13:24:09 <jrx_> I've got function which uses temporary array to calculate its results and it gets called lots of times which causes huge number of allocation and in the end my program spends 20% of time in GC. is there any way to optimize it to run in constant space?
13:24:22 <MyCatVerbs> > (1/0,sin (1/0))
13:24:23 <lambdabot>   (Infinity,NaN)
13:24:32 <pumpkin> jrx_: if you're upadting the array that's probably a problem
13:24:40 <pumpkin> unless you're using a DiffArray, and even then that might be a problem
13:24:50 <MyCatVerbs> jrx_: what kind of array? IArray, IOArray?
13:25:31 <MyCatVerbs> For IOArrays, you could write a version which requires that an IOArray be passed into it. Then it's just newIOArray_ ... >>= \array -> yourFunction array
13:25:50 <pumpkin> why the lambda?
13:25:59 <pumpkin> oh, just for illustrative purposes I guess :)
13:26:03 <jrx_> MyCatVerbs: I use the STUarray inside runST
13:26:20 <MyCatVerbs> pumpkin: because I'm too lazy to write do { array <- ... } :)
13:26:39 <pumpkin> but newIOArray_ ... >>= yourFunction  ?
13:26:46 <MyCatVerbs> jrx_: ah! Hrmn.
13:28:06 <_dls> pumpkin: have you looked at writing apache modules? the code is usually much cleaner, and much faster :p
13:28:15 <pumpkin> ??
13:28:17 <MyCatVerbs> jrx_: I believe that the easy and safe way to do this is to use the IOUArrays instead of STUArrays.
13:28:48 <Gracenotes> MyCatVerbs: is there really a difference?
13:28:50 <zombiekadaver> what does theta mean in machine learning?
13:28:57 <jrx_> MyCatVerbs: you mean using some unsafePerformIO?
13:29:02 <Gracenotes> I mean, IO and ST are very alike
13:29:08 <pumpkin> zombiekadaver: often a vector of weights, but that's an awfully vague question :P
13:29:13 <Gracenotes> same State model, different constructor
13:29:15 <MyCatVerbs> jrx_: yeah, provided that would be safe.
13:29:26 <vixey> I think IO and ST are different :(
13:29:37 <pumpkin> only in type, in GHC
13:29:50 <vixey> I know you can implement ST using IO
13:30:04 <jmcarthur> yeah, IORef and STRef are exactly the same thing in implementation. one is a newtype of the other, even
13:30:14 <jmcarthur> err
13:30:17 <jmcarthur> IO and ST, i men
13:30:18 <MyCatVerbs> Like if you can batch up a whole load of that calculation, do 'em all in one big long IO section, then return the result with unsafePerformIO, safely because you should have no outside side effects.
13:30:18 <jmcarthur> *mean
13:30:19 <pumpkin> IO is implemented using ST internally
13:30:25 <jrx_> MyCatVerbs: ok, I'm going to try
13:30:27 <Gracenotes> mainly, IO has extra primitives like Handles and concurrency
13:30:37 <vixey> MyCatVerbs: yes!
13:30:50 <Gracenotes> and teh randoms.
13:30:50 <MyCatVerbs> jrx_: the other, IMO better thing you could do is just make one big long ST action that does *all* of the applications of that function, and explicitly thread your array through it.
13:31:03 <FunctorSalad> and launching processes...
13:31:03 <zombiekadaver> pumpkin: makes sense in the context im am in, thanks.you know machine elarning well?
13:31:10 <lpsmith> pumpkin:  reverse that:   ST is implemented using IO internally
13:31:17 <lpsmith> And unsafePerformIO :-)
13:31:21 <MyCatVerbs> jrx_: the worst (IMO) way to do it is to make one STUArray, and use unsafeCoerce to let you reuse it between ST actions. Really, that would not be a good idea at all. :)
13:31:30 <vixey> @src runST
13:31:30 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
13:31:34 <vixey> @src runSTRep
13:31:34 <lambdabot> runSTRep st_rep = case st_rep realWorld# of (# _, r #) -> r
13:31:36 <pumpkin> lpsmith: I could've sworn that just hte other day I was seeing some IO stuff being implemented with ST, just meaning state thread
13:31:38 <jmcarthur> actually, i think they are just both made with the same use of RealWorld
13:31:39 <vixey> :/
13:31:45 <MyCatVerbs> vixey: ^^
13:31:51 <Gracenotes> @src runSTRepThroat
13:31:52 <MyCatVerbs> jmcarthur: thank you!
13:31:52 <lambdabot> Source not found. You speak an infinite deal of nothing
13:32:01 * MyCatVerbs coughs on Gracenotes.
13:32:08 <Gracenotes> http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Arrays#Freezing_and_thawing
13:32:18 <Gracenotes> see also the section on unsafe freezing and thawing below, if it applies in your case
13:32:30 <lpsmith> Well, if I had to guess,  there might be some things in IO implemented using ST
13:32:37 <Gracenotes> (it's not that unsafe if you promise not to do certain bad things)
13:32:55 <lpsmith> but ultimately STRefs is currently implemented with IORefs and unsafePerformIO
13:33:06 <pumpkin> oh yeah
13:33:42 <Saizan_> ?src IORef
13:33:42 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
13:33:50 * pumpkin yays
13:33:56 <Saizan_> it's the opposite, OMG
13:34:09 <jmcarthur> yeah, my gut reaction about STRef and IORef ended up being the right one, and my correction to IO and ST was incorrect
13:34:12 <lpsmith> hmm
13:34:16 <jrx_> MyCatVerbs: making my whole program run in ST monad is something I'd like to avoid
13:34:49 <jrx_> Gracenotes: I have already tried unsafeThaw and it didn't help even a bit
13:34:55 <MyCatVerbs> jrx_: indeed. Could you run several of these calculations in parallel?
13:35:10 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html
13:35:20 <pumpkin> unsafeSTToIO (ST m) = IO (unsafeCoerce# m) lol
13:35:48 <MyCatVerbs> jrx_: if you're worried about lack of parallelism, well, you could split things up into several large ST actions each with its own intermediate array.
13:36:00 <jmcarthur> actually, i don't see why that function is unsafe
13:36:03 <pumpkin> readIORef  (IORef var) = stToIO (readSTRef var) and so on
13:36:11 <pumpkin> jmcarthur: it isn't
13:36:17 <MyCatVerbs> Whatever you do, though, the only way to avoid re-allocating the array repeatedly is to pass handles to it around somehow.
13:36:50 <pumpkin> jmcarthur: well, it's assuming the compiler representation of m is the same, I guess
13:36:59 <jmcarthur> yeah, but that is implementation detail
13:37:00 <Gracenotes> hm. Well, functional programming languages are sort of inherently much-garbage-collection-done-when-dealing-with-lots-of-data
13:37:06 <jmcarthur> the type makes it seem that it should be safe
13:37:09 <Gracenotes> :\
13:37:11 <pumpkin> jmcarthur: but that's why it's unsafe, I think
13:37:25 <pumpkin> jmcarthur: it wouldn't work if something lower down changed :P or something like that
13:37:27 <Gracenotes> seeing lots of GC in Haskell is different from seeing lots of it in, I dunno, C#.
13:37:34 <jmcarthur> i dunno. it's a GHC library. i think it's safe to rely on GHC implementation
13:37:35 <Gracenotes> afaia at least
13:37:38 <pumpkin> true
13:37:47 <pumpkin> I dunno, can't think of another reason to call it unsafe
13:38:24 <jmcarthur> perhaps you can leak references from otherwise pure code that way?
13:38:41 <pumpkin> I'd think that would be only possible the other way around
13:38:43 <jmcarthur> yes that must be it
13:38:45 <pumpkin> ST to IO seems quite safe?
13:38:56 <b_jonas> jmcarthur: only if the constructor of IORef is exposed
13:39:02 <jmcarthur> hmm
13:39:09 <b_jonas> but I think it's private
13:39:14 <pumpkin> yeah
13:39:21 <pumpkin> mm
13:39:21 <pumpkin> unIO :: IO a -> (State# RealWorld -> (# State# RealWorld, a #))
13:39:21 <pumpkin> unIO (IO a) = a
13:39:23 <pumpkin> :P
13:39:27 <jmcarthur> right, it wouldn't be coercing STRef to IORef or anything
13:39:28 <MyCatVerbs> Gracenotes: seeing 20% of your runtime go to GC is bad no matter what you are writing in.
13:39:53 <alexsuraci> is there a way to search hackage for packages that depend on a certain package?
13:39:57 <MyCatVerbs> Gracenotes: though I've been happy with programs that spent 99.95% of their CPU time in the garbage collector, before. :)
13:39:59 <jmcarthur> yeah, i see no reason for that function to be unsafe
13:40:01 <pumpkin> they also have unsafeIOToST (IO io) = ST $ \ s -> (unsafeCoerce# io) s
13:40:09 <pumpkin> which definitely looks unsafe :)
13:40:10 <jmcarthur> now *that* sounds unsafe
13:40:11 <bavardage> o/
13:40:14 <jrx_> MyCatVerbs: it's rather the problem with refactoring the whole code to run in ST monad, it involves pretty much work
13:40:53 <pumpkin> jmcarthur: the comment for both of those says "This relies on IO and ST having the same representation modulo the constraint on the type of the state"
13:41:21 <jmcarthur> is it a comment or documentation?
13:41:40 <pumpkin> just a comment
13:41:44 <jmcarthur> the former doesn't imply an abstraction leak since it could just be describing the implementation to a GHC programmer
13:41:47 <MyCatVerbs> jrx_: can't help you with that. Just make sure you use version control just in case you decide it isn't worth it.
13:41:47 <michaelcdever> hey all, i've jsust switched to mac, and im trying to load my file manager as per usual
13:41:59 <b_jonas> I think the point is that if you write the whole code to run in one monad, then it's not much work to make it run in two monads under each other
13:42:01 <michaelcdever> but it gives me an error i haven't seen before
13:42:10 <pumpkin> zombiekadaver: not well, but I know a bit :)
13:42:13 <michaelcdever> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3905#a3905
13:42:56 <bavardage> michaelcdever: you the guy making a haskell file manager?
13:43:05 <michaelcdever> that be's me bavardage
13:43:14 <bavardage> of :D
13:43:24 <bavardage> hurry up and release it
13:43:28 <michaelcdever> lol
13:43:37 <michaelcdever> theres a bit more to do
13:43:39 <bavardage> your blog is on my google reader for that purpose :D
13:43:46 <bavardage> michaelcdever: pfft open source - release early release often
13:43:47 <bavardage> :D
13:43:48 <bavardage> DO IT
13:43:49 <bavardage> :P
13:43:50 <michaelcdever> heh seriously?
13:44:11 <bavardage> seriously what?
13:44:13 <michaelcdever> lol, well if I can't figure out this bug, I won't be releasing it :D
13:44:30 <bavardage> who cares about mac though?
13:44:34 <bavardage> it runs on linux, right?
13:44:37 <michaelcdever> i didnt really think anyone was paying attention to my blog
13:45:23 <michaelcdever> yeah it runs on linux, but i haven't used my nix box since i got the mac
13:45:24 <bavardage> dunno, if it can replace thunar then that'd be good
13:45:37 <michaelcdever> heh, its nowhere near as good as thunar
13:45:42 <bavardage> then again, I doubt it has all the nice features yet like automount and stuff
13:45:45 <bavardage> yeah but if you release it
13:45:48 <bavardage> others can work on it too
13:45:59 <bavardage> and I'm sure it could get to a reasonable featureset quite quickly
13:46:07 <bavardage> but w/e :D
13:46:13 <bavardage> I personally hate bothering to release stuff
13:46:19 <b_jonas> bavardage: me too
13:46:29 <bavardage> all the bureacracy
13:46:39 <michaelcdever> nope... i was looking at stuff like that, but it was a college project so i didn't get the time to do it
13:46:42 <bavardage> all the "it doesn't work/compile for meee" crying
13:46:53 <michaelcdever> yeah, i wont be listening to those
13:46:54 <b_jonas> but I released one of my irc bot (and even added a configuration file mechanism so people edit the config file only instead of the source) after people asked me to
13:46:57 <b_jonas> and it turned out to be useful
13:47:03 <bavardage> yeah
13:47:06 <bavardage> that's the big plunge
13:47:07 <b_jonas> because this way someone is running an instance of it all the time
13:47:10 <bavardage> is making a config
13:47:15 <b_jonas> I don't have to host it myself
13:47:19 <bavardage> like I have this tv-app
13:47:26 <bavardage> which tells me programs I may wanna watch on tv
13:47:28 <bavardage> almost finished
13:47:35 <bavardage> but atm the xmltv source is hardcoded
13:47:38 <b_jonas> and when I reinstalled my computer and it stopped working I still had that instance as a backup
13:47:38 <bavardage> in the source
13:47:47 <b_jonas> (it does work again now)
13:47:49 <bavardage> and I really cba to bother making it configurable
13:47:54 <zombiekadaver> http://takinginitiative.wordpress.com/2008/04/03/basic-neural-network-tutorial-theory/  is weight_i*input_i = dotProduct weight_i * input_i ?
13:47:55 <bavardage> yeah
13:48:02 <bavardage> b_jonas: next time try source control maybe :P
13:48:04 <bavardage> github is nice
13:48:25 <pumpkin> yay github
13:48:27 <b_jonas> bavardage: I do have old versions
13:48:39 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1842
13:48:40 <b_jonas> bavardage: but it broke and I didn't change anything
13:48:45 <bavardage> oh strange
13:48:46 <b_jonas> (yeah, you know that)
13:48:55 <b_jonas> I did say I reinstalled the computer
13:48:56 <bavardage> github: bringing centralised version control to git :P
13:49:05 <b_jonas> so I changed something that wouldn't have been in the version control anyway
13:49:08 <sampointon> speaking of configuration: is there a sane way of discovering plugins to load, without having to hardcode the names in the loading code?
13:49:09 <bavardage> before I used version control, I once had a cat break a project
13:49:26 <bavardage> sampointon: what like a python __import__() ?
13:49:28 <pumpkin> mmorrow: looks fancy, what's it do? :P
13:49:29 <bavardage> that would be funky
13:49:55 <sampointon> bavardage: I was thinking more like dependency injection. Besides, hs-plugins works like __import__, ish
13:50:05 <pumpkin> mmorrow: implementing IO using an ST wrapper?
13:50:11 <bavardage> oh right
13:50:17 <pumpkin> would a forkST be possible?
13:50:20 <bavardage> sampointon: I haven't discovered hs-plugins
13:50:24 <mmorrow> pumpkin: there's one there :)
13:50:32 <pumpkin> oh wow
13:50:33 <b_jonas> what?
13:50:34 <pumpkin> cool :)
13:50:45 <pumpkin> lol
13:50:45 <pumpkin> t <- (io . forkIO . oi)
13:50:48 <pumpkin> purty
13:50:49 <sampointon> bavardage: it's what I'm planning to use for the loading part, once I have a good way of discovering -what- to load :)
13:50:50 <mmorrow> leet!
13:50:52 <b_jonas> I thought that's impossible because IO threads depend on pure throwing exceptions
13:51:02 <b_jonas> and you can't catch purely thrown exceptions in ST, can you?
13:51:05 <bavardage> hmm
13:51:17 <mmorrow> sure, if you coerce IO to ST
13:51:22 <mmorrow> then runST
13:51:25 <b_jonas> mmorrow: yeah, but I mean
13:51:27 <b_jonas> is it safe?
13:51:33 <bavardage> sampointon: lame system have a kinda plugin-info.xml file
13:51:34 <pumpkin> always be safe
13:51:35 <mmorrow> safe in what sense of that word?
13:51:38 <michaelcdever> heh lol, it seems like mac just doesn't like Control.Exception
13:51:38 <pumpkin> condoms
13:51:38 <bavardage> with dep info
13:51:39 <michaelcdever> :(
13:51:43 <bavardage> would be horrible probably
13:52:03 <mmorrow> you can dereference pointers in IO
13:52:19 <mmorrow> and that's unchecked, so you can segfault
13:52:59 <pumpkin> segfaults are half the fun
13:53:05 <mmorrow> heh
13:53:06 <sampointon> bavardage: yeah, that's my thought. Either that or some kind of grep/find script seem to be my options
13:53:17 <olsner> debugging segfaults in haskell code sounds like a real pain though
13:53:24 <pumpkin> it is
13:53:24 <bavardage> sampointon: depends what this is for
13:53:25 <mmorrow> heh, totally
13:53:30 * michaelcdever gives up on the mac and goes to install ubuntu on a VM
13:53:33 <bavardage> sampointon: since if there's ever the possibility of windowsing it
13:53:36 <bavardage> sampointon: no grep
13:53:40 <bavardage> sampointon: but screw windows :D
13:54:04 <sampointon> bavardage: they can install cygwin if they're -that- desperate to run my hobby mud :)
13:54:36 <bavardage> hehe
13:54:41 <pumpkin> michaelcdever: hmm, sounds a little heavy-handed :P
13:54:48 <michaelcdever> lol
13:55:30 <michaelcdever> i also just realised i'd have to change a fair bit of it to develop it for the mac... the program opening bit would have to go
13:55:58 <bavardage> why?
13:56:05 <bavardage> and what 'program opening'
13:56:22 <bavardage> michaelcdever: are you using source control?
13:56:27 <michaelcdever> eh, opening say "a.pdf" with the default pdf viewer
13:56:32 <pumpkin> btw, anyone wanting a 64-bit GHC for mac os should add themselves to the CC list for the relevant bug on the ghc trac, so they can see that we want it :P
13:57:28 <michaelcdever> not yet bavardage, i only started using svn myself this week so
13:58:09 <olsner> @src ST
13:58:10 <lambdabot> newtype ST s a = ST (STRep s a)
13:58:13 <olsner> @src STRep
13:58:14 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
13:58:34 <wli> Hmm. There's a bug somewhere in here.
13:58:41 <pumpkin> omg, just like the signature of IO
13:58:45 <pumpkin> :P
13:59:06 <pumpkin> @src IO
13:59:07 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:59:12 <olsner> I don't quite understand the use of unsafeCoerce# in unsafeSTToIO, don't they actually have the same representation?
13:59:19 <pumpkin> so IO = ST RealWorld
13:59:57 <olsner> except you want to keep the 's' in ST s a phantom type, perhaps
13:59:58 <b_jonas> olsner: isn't that the point of unsafeCoerce? if they have different representation, you can't coerce
14:00:38 <olsner> but don't they have the same type?
14:01:04 <Berengal> olsner: No, IO is a newtype
14:01:19 <mmorrow> b_jonas: for the ST/IO case, there isn't actually any real thing behind the type that's being coerced (given ghc's implem)
14:01:30 <mmorrow> it's a phantom type
14:01:46 <olsner> Berengal: yeah, so is ST, but the unsafeCoerce is on the thing inside the newtype
14:01:49 <mmorrow> like (newtype Ptr a = Ptr Addr
14:01:50 <mmorrow> )
14:02:46 <mmorrow> the 's' allows the type-system to know if any effect ever escape
14:02:49 <da-x> what is the earliest version of ghc that has no external haskell dependency? (i.e. depends only on a C compiler).
14:04:16 <Gracenotes> mmorrow: it seems that the type signature of "runST" more contributes to that
14:04:19 <b_jonas> da-x: I think the earliest ones were compiled with another haskell compiler, not a c compiler
14:04:38 * Gracenotes hasn't played around with the internals too much though
14:04:56 <b_jonas> da-x: the c compiler escape was added later to make it easier to bootstrap on a new architecture without a working haskell compiler
14:05:03 <olsner> actually bootstrapping ghc sounds almost impossible
14:05:09 <mmorrow> well, it's a little more than a phantom type
14:05:14 <b_jonas> s/architecture/machine
14:05:33 <mmorrow> Gracenotes: it's the fact that the 's' is universally quantified
14:05:41 <Gracenotes> mm
14:05:42 <mmorrow> and runST disposes of it
14:06:05 <wli> There's an infinite loop foating around here somewhere.
14:08:10 <mmorrow> Gracenotes: i think you would actually go out of your way to put any actual physical rep behind the 's' type param in an implem of ST
14:08:19 <mmorrow> *..actually have to go out of ...
14:09:31 <mmorrow> IO is at an abstract level just an unsafeCoerced ST
14:09:51 <mmorrow> (IO a) might as well be = ST () a
14:10:13 <pumpkin> RealWorld might as well be ()
14:10:17 <pumpkin> :(
14:10:22 <pumpkin> we're meaningless!
14:10:23 <pumpkin> ;)
14:10:39 <MyCatVerbs> > foldr (.) id (repeat ('a':)) $ []
14:10:41 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
14:11:00 <Gracenotes> There is only one RealWorld, Mr. Bond. Or there is undefined. What do you choose...?
14:11:01 <MyCatVerbs> > foldr (flip (.)) id (repeat ('a':)) $ []
14:11:39 <lambdabot>   thread killed
14:11:46 <pumpkin> aw
14:12:06 <kerlo> I haven't yet figured out what ST is.
14:12:36 <pumpkin> state thread!
14:12:52 <kerlo> I haven't yet figured out what state thread is.
14:13:06 <Gracenotes> It's like rain on your wedding day
14:13:12 <Gracenotes> it's a free ride when you've already paid
14:13:22 <Gracenotes> it's good advice that you just didn't take
14:13:30 <Gracenotes> who would've thought!!
14:13:31 <MyCatVerbs> kerlo: same as the IO monad, just without the ability to do anything nondeterministic or which might have external side-effects.
14:13:32 <kerlo> It's like song lyrics.
14:14:02 <kerlo> MyCatVerbs: so it's a monad with no special features at all?
14:14:36 <olsner> why not just have IO be a newtyped ST ()?
14:14:40 <Gracenotes> it's escapable.
14:14:44 <MyCatVerbs> kerlo: quite the opposite! Identity is a monad with no special features at all. ST is a monad which works just like IO, except that you aren't given access to anything that can affect the outside universe.
14:14:46 <gwern> kerlo: no, that'd be the Identity monad :)
14:14:48 <Gracenotes> you can't escape IO! :o
14:14:57 <gwern> @hoogle IO a -> a
14:14:58 <lambdabot> Foreign unsafePerformIO :: IO a -> a
14:14:58 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
14:14:58 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
14:15:06 <gwern> Gracenotes: there's plenty of ways!
14:15:07 <Gracenotes> that's not really escaping. more like a snapshot.
14:15:09 <kerlo> What happens when you escape ST?
14:15:18 <pumpkin> you're pure again
14:15:24 <kerlo> How do you escape ST?
14:15:29 <pumpkin> you can sweep your past sins under the rug
14:15:30 <MyCatVerbs> runST.
14:15:30 <pumpkin> runST
14:15:32 <Gracenotes> runST
14:15:34 <Gracenotes> runST
14:15:37 <pumpkin> lol
14:15:39 <Gracenotes> what do I win????
14:15:39 <povman> runST
14:15:43 <kerlo> @hoogle runST
14:15:44 <lambdabot> Control.Monad.ST runST :: ST s a -> a
14:15:44 <lambdabot> Control.Monad.ST.Lazy runST :: ST s a -> a
14:15:44 <lambdabot> Data.Array.ST runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
14:15:44 <bavardage> how bad really is unsafePerformIO?
14:15:49 <povman> @src runST
14:15:50 <lambdabot> runST st = runSTRep (case st of { ST st_rep -> st_rep })
14:15:57 <vixey> bavardage: the baddest
14:16:03 <bavardage> I'm tempted to use it to quickly bodge in IO to my lamba calc thing
14:16:06 <MyCatVerbs> bavardage: depends. Does it matter when your action runs?
14:16:07 <olsner> bavardage: horse heads in your bed bad
14:16:08 <gwern> bavardage: plenty bad. it totally destroys the type system, it fucks up optimizations, and so on
14:16:13 <vixey> bavardage: why?
14:16:13 <MyCatVerbs> bavardage: ah, that sounds bad.
14:16:17 <kerlo> How do you create an ST, then?
14:16:17 <mreh> ceiling cat is watching you unsafePerformIO
14:16:19 <bavardage> otherwise I'm gonna have to put my whole eval function in the IO monad
14:16:22 <bavardage> :(
14:16:25 <bavardage> maybe I'll have to
14:16:31 <Gracenotes> Lie Bot, what is the baddest function?
14:16:33 <vixey> bavardage: you think just using unsafePerfomIO will work??
14:16:38 <MyCatVerbs> bavardage: yes, that's normal, since you're implementing an impure language.
14:16:40 <bavardage> vixey: I have no idea
14:16:43 <povman> bavardage: Can you get away with Debug.Trace?
14:16:43 <bavardage> but it doesn't seem to ;P
14:16:57 <sampointon> bavardage: yeah, what MyCatVerbs said. Evaluating an impure language is, well, impure
14:16:59 <bavardage> I just want a way for my lamelambacalc to put stuff to the screen
14:17:09 <povman> bavardage: Debug.Trace
14:17:29 <kerlo> @hoogle ST
14:17:30 <lambdabot> module Control.Monad.ST
14:17:31 <lambdabot> module Data.Array.ST
14:17:31 <lambdabot> Control.Monad.ST data ST s a
14:17:39 <vixey> mhm ... data Scheme a = Return a | Bind (b -> Scheme a)| Lam (Scheme -> Scheme Scheme)
14:17:41 <tomh> gonna be great fun with lazy evaluation Debug.Trace ;p
14:17:49 <kerlo> @type Control.Monad.ST.ST
14:17:52 <lambdabot>     Not in scope: data constructor `Control.Monad.ST.ST'
14:17:56 <vixey> that's way wrong :/
14:18:01 <kerlo> @docs Control.Monad.ST
14:18:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html
14:18:11 <MyCatVerbs> bavardage: for screen output, I guess the easiest thing that doesn't put the whole thing into the IO monad is to use the Writer monad, with Data.Seq.
14:18:14 <sampointon> bavardage: some other ideas: use the Writer monad to buffer it
14:18:21 <MyCatVerbs> sampointon: jinx!
14:18:24 <bavardage> I'll try Debug.Trace
14:18:29 <Gracenotes> you may not know it, but your Haskell program may be piped to a missile-launching program, so that when you use Debug.Trace it obliterates half of Europe
14:18:35 <bavardage> maybe at some point I'll convert to writer
14:18:37 <bavardage> haha
14:18:38 <Gracenotes> beware Debug.Trace
14:18:40 <povman> Does ST actually run in a separate thread?
14:18:41 <sampointon> MyCatVerbs: we keep having the same thoughts, it's creepy
14:18:44 <bavardage> as long as it's not MY half
14:18:45 <bavardage> that's fine
14:18:55 <povman> Or am I misinterpreting that word?
14:19:23 <MyCatVerbs> sampointon: well, now I'm thinking about how my mouth hurts because I bit myself. Was that enough to take us out of sync?
14:19:37 <sampointon> MyCatVerbs: plenty, thanks!
14:20:05 <MyCatVerbs> Phew, safe.
14:20:18 <povman> ^ ST = threads?
14:20:38 <bavardage> Debug.Trace woulds fine :D
14:21:33 <Gracenotes> I forget, is there a way to read args in the Prelude?
14:21:58 <pumpkin> threads in the sense of threading state through your program
14:22:05 <pumpkin> not thread in the concurrency sense
14:22:23 <Gracenotes> or iz i forced 2 use System.Environment
14:22:25 <povman> pumpkin: Right.
14:22:42 <kerlo> @hoogle writeSTRef
14:22:43 <lambdabot> Data.STRef writeSTRef :: STRef s a -> a -> ST s ()
14:22:43 <lambdabot> Data.STRef.Lazy writeSTRef :: STRef s a -> a -> ST s ()
14:22:59 <kerlo> @index Data.STRef
14:23:00 <lambdabot> bzzt
14:23:03 <povman> Gracenotes: You mean you don't feel 'forced' to use Prelude?
14:24:00 * donri hugs chrisdone for not being dead <3
14:24:32 * donri slaps chrisdone for making us all worried!
14:24:53 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef)
14:24:54 <lunabot>  luna: Couldn't match expected type `GHC.ST.ST s a'
14:24:58 <mmorrow> , runST (do x <- newSTRef 42; writeSTRef x 99; readSTRef x)
14:24:59 <lunabot>  99
14:25:39 <wli> I wonder how to figure out where I'm looping.
14:26:34 <povman> wli: Debug.Trace
14:27:25 <kerlo> donri: what's this about chrisdone being remarkably alive?
14:28:50 <donri> he has been remarkably not alive in the lojban community for quite a while
14:29:40 * kerlo nods
14:30:08 <gwern> donri: well, at least haskell is usefull...
14:30:13 <donri> :)
14:30:35 <gwern> writing in lojban sounds about as useful as writing in e-prime or esperanto
14:30:51 <gwern> actually, esperanto and e-prime are probably more useful - more speakers
14:30:51 <pumpkin> isn't chrisdone sometimes called kiris?
14:30:54 <pumpkin> or is that someone else?
14:30:56 <b_jonas> so First is a wrapper to make a Maybe work as a monoid like it works as a monadplus
14:30:57 <gwern> @seen kiris
14:30:58 <lambdabot> I saw kiris leaving #haskell 2m 26d 3h 26m 3s ago, and .
14:31:05 <b_jonas> because the monoid instance for Maybe is different otherwise
14:31:06 <donri> kiris is a lojbanification of chris
14:31:11 <pumpkin> ah :)
14:31:19 <thoughtpolice> pumpkin: those numbers on -cafe about OS X performance re. cores looks mighty fine. :)
14:31:31 <chris2> what's 2 in lojban?
14:31:34 <donri> re
14:31:38 <pumpkin> thoughtpolice: yeah, I got excited
14:31:40 <thoughtpolice> pumpkin: once ghc can somewhat bootstrap again, 64-bit on OS X is my top priority
14:31:46 <sampointon> is e-prime even a language in its own right? Every e-prime sentence is also valid english, after all
14:31:47 <pumpkin> thoughtpolice: I do some pretty serious big number crunching in haskell
14:31:59 <b_jonas> sampointon: I think that's a different e-prime
14:32:00 <pumpkin> and being able to use my hefty mac pro would be nice
14:32:02 <thoughtpolice> preflex: seen conal
14:32:03 <preflex>  conal was last seen on #haskell 2 days, 3 hours, 50 minutes and 19 seconds ago, saying: fnod: :)
14:32:14 <thoughtpolice> pumpkin: mmm. :)
14:32:22 <sampointon> b_jonas: there's another one? I thought the only e-prime was english sans the copula
14:32:24 <gwern> sampointon: well, then by definition it has many more speakers than lojban or esperanto :)
14:32:31 <b_jonas> so a Writer (First a) lets me save the first Just value I tell
14:32:33 <bavardage> yay I have IO :P
14:32:55 <gwern> sampointon: well, not just the copula but a number of other words and verbs and tenses which are closely allied
14:33:11 <b_jonas> and I think it's also lazy so if I only execWriter it (not runWriter) then it doesn't have to compute the part of the computation after that first tell, am I right thinking this?
14:33:37 <donri> this is not the place but i shall tell you, to me lojban is mostly a hobby, with the bonus of being brain candy (like haskell!) and great potential for computer fun such as ai
14:33:50 <gwern> donri: what sort of potential?
14:34:03 <donri> but as a language between people? just learn english and spanish and be done with it :P
14:34:38 <donri> gwern, formally parseable and all that
14:34:43 <gwern> no mandarin? you anti-asian bigot!
14:34:43 <bavardage> dammit
14:34:45 <bavardage> HASKELL IS SO LAZY
14:34:51 <bavardage> it ought to actually do some work
14:34:56 <pumpkin> thoughtpolice: we should encourage more people to add themselves to the cc list of that ticket in trac
14:35:12 <donri> i was aiming widest usage
14:36:22 <thoughtpolice> pumpkin: yes
14:36:49 <thoughtpolice> pumpkin: hopefully your  number crunching will get more awesome too - see/mmx stuff is only enabled on 64-bit builds of GHC
14:37:06 <b_jonas> thoughtpolice: why, aren't there -march options?
14:37:14 <b_jonas> for enabling sse on x86
14:37:32 <mmorrow> , let ref=newSTRef;(!)=readSTRef;(.=)=writeSTRef in runST (mdo x <- ref(0); go <- ref(do a <- (x!); when(10000<a)(go.=return a); x.=(a+3); join(go!)); join(go!))
14:37:34 <lunabot>  luna: Couldn't match expected type `t1 -> t'
14:37:37 <mmorrow> aw
14:37:48 <donri> gwern, or if it was the lower case that confused you, ai = AI = artificial intelligence
14:37:48 <pumpkin> there, there
14:37:49 <mmorrow> , let (!) = (+1) in (1!)
14:37:50 <lunabot>  luna: No instance for (GHC.Num.Num (t -> t1))
14:37:57 <thoughtpolice> b_jonas: I couldn't tell you. just that only the x86_64 backend of GHC is configured to take use of sse/mmx registers
14:37:58 <mmorrow> , let (!) = (+1) in (!)1
14:37:59 <lunabot>  2
14:38:13 <thoughtpolice> this is also a ticket in trac (so we can have see/mmx on just x86)
14:38:15 <mmorrow> , let ref=newSTRef;(!)=readSTRef;(.=)=writeSTRef in runST (mdo x <- ref(0); go <- ref(do a <-(!)x; when(10000<a)(go.=return a); x.=(a+3); join((!)go)); join((!)go))
14:38:15 <vixey> donri, even mentioning AI is dangeous around here
14:38:16 <lunabot>  10002
14:38:23 <povman> Roses look red;
14:38:24 <donri> vixey, oh, hows so?
14:38:24 <povman> Violets look blue.
14:38:24 <povman> Honey tastes sweet,
14:38:24 <povman> As sweet as you.
14:38:27 <vixey> donri, ps. I didn't just say that
14:38:33 <donri> haha
14:38:56 * mmorrow loves mdo + STRefs using join(readSTRef ref) to loop
14:38:56 <b_jonas> mmorrow: I'm always confused by this convention from standard ml to mark dereferencing by (!)
14:39:16 <pumpkin> omg
14:39:17 <b_jonas> mmorrow: the forth/scheme convention where ! means writing to a reference makes much more sense to me
14:39:17 <wli> I think it's trouble in multivariate division.
14:39:20 * vixey loves 'boys are back in town' but has no idea what it /means/
14:39:27 <b_jonas> and then @ can be reading from a reference
14:39:29 <mmorrow> b_jonas: heh, i guess it's as in "!zomg"
14:39:51 <mmorrow> b_jonas: but then sml has :=
14:39:57 <mmorrow> which is kinda nice
14:40:15 <MyCatVerbs> vixey: "Salutations, dudes! We have returned! 'Cuz, y'know, the last time we were 'round these parts just rocked, so many awesome memories."
14:40:20 <b_jonas> mmorrow: yes, and I know @ is used for something else (our (++) iirc)
14:40:25 <mmorrow> b_jonas: i like how you can put pretty much anything in a scheme identifier
14:40:32 <MyCatVerbs> vixey: some songs do not, IMO, require much interpretation. :)
14:40:44 <b_jonas> (they need that because their strings are iarrays so string concat has to use a differnent character)
14:41:34 <thoughtpolice> pumpkin: been doing anything fun recently? i've been doing some stuff with HOL light, and playing around with linux on my ps3 :)
14:41:55 <thoughtpolice> pumpkin: (current mission: some type of DSL so writing programs on the PS3 is more palatable)
14:42:01 <pumpkin> thoughtpolice: cramming for a paper deadline until last night :P now I'm relaxing and starting work on a graphical models library
14:42:08 <pumpkin> that sounds cool
14:43:18 <pumpkin> doing factor graphs and belief propagation in haskell could be fun
14:43:20 <pumpkin> I'll find out :P
14:44:01 <thoughtpolice> pumpkin: I was going to try and hook conal's FieldTrip up to elerea (since it
14:44:12 <thoughtpolice> 's really simple and installing reactive with e.g. reactive-fieldtrip is a total pain)
14:44:30 <thoughtpolice> but it turns out FieldTrip is busted - 0.2.2 fails with segfaults on both my OS X and linux boxes :(
14:45:06 <mmorrow> thoughtpolice: maybe your opengl lib is too old or something?
14:45:19 <mmorrow> (that sounds to me like it has to be something like that)
14:45:24 <thoughtpolice> i'm not entirely sure.
14:45:48 <mmorrow> (or too new)
14:46:12 <thoughtpolice> but no, it's just FieldTrip
14:46:18 <thoughtpolice> GLUT based and OpenGL based programs work fine
14:46:20 <mmorrow> hmm
14:46:25 <mmorrow> weird
14:46:49 <mmorrow> thoughtpolice: are you using 6.10.2? maybe some change broke something
14:47:07 <thoughtpolice> that could be it
14:47:26 <thoughtpolice> recently part of the code dealing with the FPU stack and fp-related stuff which was very very broken was fixed
14:47:37 <thoughtpolice> but that should only make things more *stable*, you would hope :)
14:47:40 <thoughtpolice> either way I need to talk to conal
14:47:57 <thoughtpolice> as it stands, installing reactive-fieldtrip is pretty much a PITA
14:48:11 * mmorrow guesses it might have to do with conal's unamb and how ghc deals with blackholes are concurrency or something along those lines
14:48:12 <thoughtpolice> because it all depends on different versions of different libraries like vector-space and checkers
14:48:21 <mmorrow> like ghci behaves way differently
14:48:28 <thoughtpolice> mmorrow: right, but why would *only* FieldTrip fail?
14:48:37 <mmorrow> hmm, good point
14:48:46 <thoughtpolice> I just tried a fieldtrip example: main = render3 $ flatG $ utext "hi"
14:48:54 <thoughtpolice> and I get a segfault in glNormal3f
14:49:09 <thoughtpolice> this kind of makes me want to believe it's a problem with vector-space, but I'm not sure.
14:49:13 <mmorrow> ohh, so it is opengl-related
14:49:15 <wli> I've got the loop narrowed down to somewhere in multivariate division.
14:49:29 <thoughtpolice> either way hopefully conal resumes development of reactive soon
14:49:37 <saml> @info fix
14:49:38 <lambdabot> fix
14:49:39 <thoughtpolice> I think 6.10.2 had the fixes he needed for development to continue
14:49:48 <saml> @hoogle fix
14:49:49 <lambdabot> Data.Function fix :: (a -> a) -> a
14:49:50 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
14:49:50 <lambdabot> module Control.Monad.Fix
14:49:57 <pumpkin> I haven't seen conal around for a while
14:50:02 <thoughtpolice> because it depends on all these versions of libraries that have been upgraded/interfaces changed, but reactive depends on the old version
14:50:51 <thoughtpolice> e.g. reactive uses vector-space, but it requires vector-space-0.5.1 while the latest is 0.5.6, because reactive-0.10.5 believes vector-space exports an 'AVector' type - which it does, in v0.5.1
14:50:52 <donri> vixey, (you're really serious about this aren't you?)
14:51:00 <thoughtpolice> it's really a pain to work with right now
14:51:09 <thoughtpolice> which is why I've decided to just mess with elerea
14:52:12 <thoughtpolice> but first, more HOL light :)
14:52:47 <vixey> what are you doing with HOL light?
14:54:14 <gwern> @type (/=)
14:54:16 <lambdabot> forall a. (Eq a) => a -> a -> Bool
14:55:44 <thoughtpolice> vixey: just playing around and stuff. it's a neat little environment
14:56:32 <vixey> I've tried to read HOL light but I couldn't really take it all in at thaht time
14:56:40 <vixey> I mean the implementation
14:59:52 <pumpkin> I wonder what it would take to have a good "adaptive graph" container like dons' adaptive container work
15:01:07 <ddarius> It would take about the same amount of effort.
15:01:28 <thoughtpolice> vixey: i've been going through the tutorial very slowly, but it's very huge; I like it because it's really lightweight and easy to get (isabelle/hol on the other hand....)
15:03:22 <pumpkin> I wonder if belief propagation would be well suited to an ST-based algorithm
15:03:48 <pumpkin> it sounds rather painful with immutability
15:05:00 <pumpkin> but maybe I just need to think harder
15:06:16 <bavardage> pumpkin: yup that's the solution
15:09:20 <Gracenotes> hm. I remember the whole jQuery-is-like-a-monad thing, but I wonder if a jQuery monad would be possible.. http://stackoverflow.com/questions/764168/jquery-like-selector-in-haskell
15:10:25 <ddarius> The only "jQuery is like a monad" thing that I remember was nonsense.
15:10:54 <Berengal> Monads are like cars
15:11:22 <bavardage> Berengal: complete your car analogy please
15:11:24 <Gracenotes> a tag soup monad? :X
15:11:38 <Gracenotes> runTagSoup
15:11:47 <sampointon> bavardage: they come in lots of different sizes, and they can be unsafe if you take them apart wrongly?
15:12:08 <bavardage> :D
15:12:19 <Baughn> ..here I am, car the size of a planet, and they keep telling me to make monads.
15:12:29 <b_jonas> Baughn: heh
15:12:31 <gwern> car?
15:12:33 <bavardage> and quite a few people can use them, but couldn't make one
15:12:52 <Baughn> gwern: Did you perchance expect a brain?
15:13:04 <gwern> as a matter of fact, I did
15:13:13 <ddarius> No one wants a cdr the size of a planet.
15:13:14 <Baughn> Well, too bad. No brains here.
15:13:23 <Baughn> Yes - it wouldn't fit in the cup holder
15:13:36 <b_jonas> I can make a monad but I can't make a really new monad, only one that I could build from standard and mtl library monads anyway, possibly restricting the interface.
15:13:48 <mreh> what do you write a monad in?
15:13:53 <Gracenotes> for all the talk of car-ing and cdr-ing, there isn't much philosophy about them
15:13:57 <vixey> mreh Haskell
15:13:57 <gwern> mreh: haskell
15:14:02 <mreh> excellent
15:14:03 <Gracenotes> monads, on the other hand..
15:14:14 <Baughn> mreh: C, via the FFI
15:14:18 <Baughn> No, seriously.
15:14:21 <b_jonas> is that like being able to make an Opel or a cross of an Opel and a Wolkswagen, but not being able to make a completely new kind of car which uses much less fuel than anything so far and makes me rich?
15:14:25 <Gracenotes> monadlib
15:14:31 <gwern> Baughn: didn't one guy write a monad library for c?
15:14:40 <Baughn> gwern: I vaguely recall something like that, yes
15:14:41 <mreh> b_jonas, an analogy is supposed to be simple
15:14:53 <Baughn> In my case, I wrote one monad where return was implemented via the FFI
15:14:56 <gwern> @quote analogy
15:14:56 <lambdabot> lilac says: * lilac looks forward to Cale explaining category theory by analogy to Call of Duty
15:14:59 <b_jonas> mreh: how's that quote about analogies?
15:15:02 <gwern> @quote analogy
15:15:03 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
15:15:04 <Zao> Ooh, new version of hs-dotnet. Time to get disappointed all over again.
15:15:08 <Berengal> Making monads is easy. You start with a new datatype, write some functions using it and see which one matches (>>=) and return
15:15:11 <gwern> @quote analogy
15:15:11 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
15:15:40 <b_jonas> lol
15:15:41 <alexbobp> oh sweet, I should write monads-as-unicycle
15:16:05 <beelsebob> unicycles are blatently arrows
15:16:16 <beelsebob> far more control over which direction you go than a bicycle
15:16:19 <beelsebob> (a monad)
15:16:19 <Berengal> Unicycles are like cars
15:16:23 <Gracenotes> who's ready for some <s>funky</s> functor monad-loving??
15:16:31 <alexbobp> beelsebob: haha, I like that one ^^
15:16:34 <MyCatVerbs> Gracenotes: fmap fmap fmap...
15:17:13 <Berengal> Boy do we have geeky humor...
15:17:14 <Gracenotes> MyCatVerbs: don't make me perform StrictAnal
15:17:19 <alexbobp> so funny thing.  I have heard plenty of monad analogy jokes but I don't actually understand monads :(
15:17:26 <b_jonas> by the way, in the Reader monad, can you write join from the Applicative operations?
15:17:40 <Berengal> alexbobp: The analogy jokes aren't helping, I can tell you that
15:18:31 <vixey> alexbobp: watch this
15:18:37 <vixey> > return 3 :: [Integer]
15:18:38 <lambdabot>   [3]
15:18:41 <Berengal> b_jonas: If you can do it for the reader monad, can't you do it for any monad?
15:18:44 <guenni> when I do a "cabal install somepackage" where does cabal put the docs?
15:18:46 <vixey> > [3,4,5] >>= \x -> (x,x)
15:18:47 <lambdabot>   Couldn't match expected type `[b]' against inferred type `(t, t)'
15:18:48 <vixey> oops
15:18:50 <Gracenotes> b_jonas: I think so.
15:18:52 <b_jonas> Berengal: why could you?
15:18:54 <vixey> > [3,4,5] >>= \x -> [(x,x),(x+1,x-1)]
15:18:56 <lambdabot>   [(3,3),(4,2),(4,4),(5,3),(5,5),(6,4)]
15:19:06 <Berengal> b_jonas: Using only the applicative functions, I mean
15:19:19 <vixey> that's [] monad
15:19:29 <b_jonas> @src Identity (>>=)
15:19:29 <lambdabot> m >>= k  = k (runIdentity m)
15:19:33 <Gracenotes> b_jonas: after all, for the ((->) r) monad, "f >>= g" means the same thing as "flip g <*> f"
15:19:37 <bavardage> > [3,4,5] >>= (\x -> [(x,x+1)])
15:19:38 <lambdabot>   [(3,4),(4,5),(5,6)]
15:19:38 <sampointon> alexbobp: I've come to the conclusion the best way to understand Haskell monads is to write a lot of monadic code
15:19:49 <Gracenotes> b_jonas: and Reader is just a wrapper around ((->) r)
15:19:56 <bavardage> Philippa__: ping
15:19:57 <guenni> mmorrow: ping
15:20:00 <b_jonas> Gracenotes: yeah, but maybe that works only if you can actually unwrap it
15:20:09 <Gracenotes> well, you can use runReader
15:20:16 <pumpkin> there needs to be a document (that's up to date) that describes how to use fgl
15:20:20 <b_jonas> Gracenotes: oh yeah, but then you can do anything
15:20:25 <pumpkin> there's a pdf that's several years old on erwig's site
15:20:29 <b_jonas> Gracenotes: even without the applicative
15:20:33 <pumpkin> and otherwise, there's not even a package description on the fgl package
15:20:37 <Gracenotes> *only* runReader and <*> is a good place to start, at least
15:20:38 <alexbobp> vixey: somehow that did not make me understand :P
15:20:40 <b_jonas> so the question is as I can see it whether you can do it wihtout the wrapper and unwrapper
15:20:54 <Philippa__> bavardage: hi
15:20:55 <Berengal> Gracenotes: and fmap
15:21:10 <alexbobp> sampointon: well that sounds like the best way to understand anything!
15:21:17 <Gracenotes> Berengal: wha? You get fmap free from Applicative
15:21:19 <bavardage> Philippa__: what were your plans regarding monads and this lamba calc thing
15:21:29 <alexbobp> sampointon: is monadic code like nomadic code?
15:21:35 <bavardage> Philippa__: I now have a parser and stuff
15:21:36 <Gracenotes> you can write fmap using only <*> and pure
15:21:39 <vixey> > return 3 :: Maybe Integer
15:21:40 <lambdabot>   Just 3
15:21:48 <Berengal> Gracenotes: Yes, I know, but I took you at your word when you said "only"
15:21:49 <vixey> > Just 3 >>= \x -> return (x+1)
15:21:50 <lambdabot>   Just 4
15:21:51 <Philippa__> bavardage: rewrite the evaluator to use the Reader monad to carry the environment
15:21:55 <vixey> > Nothing >>= \x -> return (x+1)
15:21:56 <lambdabot>   Nothing
15:21:59 <vixey> alexbobp how about that
15:22:07 <bavardage> Philippa__: rather than just passing around env?
15:22:07 <sampointon> alexbobp: sometimes when I refactor, it all moves around, though I've never seen my functions herd any steppe animals
15:22:08 <Philippa__> bavardage: after that, use monad transformers to help add new features to the languge
15:22:11 <Gracenotes> Berengal: stfu n00b! :o
15:22:15 <bavardage> Philippa__: should I still use a map though?
15:22:18 <Philippa__> bavardage: right, let the Reader pass it around for you
15:22:20 <Philippa__> a map's fine
15:22:22 <bavardage> yop
15:22:32 <Philippa__> we're not going for the fastest possible evaluator :-)
15:22:35 <bavardage> hahaha
15:22:36 <bavardage> noop
15:22:44 <bavardage> it takes long enough to calc 5 factorial :P
15:22:55 <bavardage> I kinda have an aim (whether I get there who knows)
15:22:56 <Philippa__> heh
15:23:01 <bavardage> that I want to be able to print a mandlebrot set
15:23:02 <Philippa__> yeah, church numerals ain't too fast :-)
15:23:08 <bavardage> yeh
15:23:15 <bavardage> I have implemented basic lists now
15:23:22 <Philippa__> *nod*
15:23:26 <bavardage> http://paste.pocoo.org/show/113132/
15:23:28 <bavardage> comme ca
15:23:28 <Philippa__> also church-encoded?
15:23:40 <bavardage> yop
15:23:40 <b_jonas> binary would be my guess
15:23:44 <b_jonas> church?
15:23:44 <alexbobp> vixey: I don't know what ">>=" does
15:23:48 <bavardage> b_jonas: indeed
15:23:56 <alexbobp> vixey: I think I get the Maybe thing though
15:24:08 <Philippa__> bavardage: nice
15:24:10 <vixey> alexbobp on Maybe that's what >>= does
15:24:14 <bavardage> vixey, b_jonas: http://paste.pocoo.org/show/113138/
15:24:18 <bavardage> this-style-list
15:24:20 <vixey> but for a different monad it does something else
15:24:21 <Cale> alexbobp: It depends on the monad, but generally the idea is that x >>= f is a computation which when run, will run x, and pass its result to f, and run that.
15:24:32 <vixey> bavardage what abotu it ?
15:24:38 <bavardage> vixey: not you
15:24:39 <mreh> do they do free haskell classes yet?
15:24:45 <bavardage> vixey: I fail at highlight
15:24:55 <alexbobp> Cale: so "x >>= f" is different from "f x" how?
15:25:05 <vixey> bavardage is your evaluator lazy
15:25:05 <bavardage>  I meant Philippa__
15:25:05 <vixey> ?
15:25:08 <alexbobp> oh wait, Maybe is a monad?
15:25:15 <bavardage> vixey: no idea
15:25:15 <Cale> alexbobp: f x would be a type error in the same context.
15:25:17 <bavardage> vixey: how do I tell?
15:25:20 <wli> Okay, I see why the multivariate division is broken.
15:25:26 <Cale> alexbobp: For example...
15:25:27 <b_jonas> actually all the example monads in the libraries (core and mtl) are what helped me understand monads (to the extent I understand them now). I think I still don't understand them completely in general, just all those special cases.
15:25:37 <b_jonas> alexbobp: yes, Maybe is a monad
15:25:39 <sampointon> alexbobp: the ideas is, x >>= f lets f get at the value 'inside' the monad. But f x gets the monad, with the value still hidden inside
15:25:40 <Cale> alexbobp: perhaps x :: IO a, and f :: a -> IO b
15:25:51 <bavardage> vixey: I don't think it's very energetic :D
15:25:52 <Cale> alexbobp: or x :: Maybe a and f :: a -> Maybe b
15:25:54 <bavardage> but as for lazy...
15:25:59 <mreh> are these haskell video lectures on LTU any good? before i waste hours
15:26:01 <bavardage> I'll try an infinite loop in an if else statement
15:26:05 <vixey> bavardage: if you don't know that means it's strict
15:26:27 <alexbobp> Cale: ooh
15:26:28 <Cale> alexbobp: So x >>= f provides a way to take the *result* of x and apply f to it.
15:26:28 <vixey> alexbobp yes
15:26:32 <vixey> @instances Monad
15:26:33 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:26:34 <alexbobp> Cale: okay, I need to play around with some code and I'll get this
15:26:37 <vixey> ^^^ here are some monads
15:26:38 <bavardage> I know what lazy is.. but I haven't explicitly made my evaluator so
15:26:50 <vixey> bavardage what have you done?
15:26:54 <bavardage> so it may have ended up as lazy via haskell's lazyness
15:26:55 <b_jonas> where's Identity?
15:27:16 <vixey> not there
15:27:26 <bavardage> vixey: http://paste.pocoo.org/show/113139/
15:27:52 <vixey> oh that looks lazy
15:27:53 <Philippa__> vixey: it's surprisingly easy to write a call-by-name evaluator by accident in haskell
15:28:14 <Philippa__> the 'obvious' eager/strict evaluator isn't
15:28:23 <bavardage> well evidently
15:28:26 <Cale> > let dict = zip [1,2,3] [2,3,4] in lookup 1 dict
15:28:28 <lambdabot>   Just 2
15:28:37 <Cale> > let dict = zip [1,2,3] [2,3,4] in lookup 1 dict >>= \x -> lookup x dict
15:28:39 <lambdabot>   Just 3
15:28:40 <vixey> why did you hard code Cond in?
15:28:41 <bavardage> I didn't put any notions of strict/lazyness into my evaluator
15:28:46 <bavardage> vixey: I dunno
15:28:48 <b_jonas> by the way, which module exports the Monad instance for Either e ?
15:28:49 <Cale> > let dict = zip [1,2,3] [2,3,4] in lookup 1 dict >>= \x -> lookup x dict >>= \y -> lookup y dict
15:28:49 <bavardage> I don't use it anywhere
15:28:51 <lambdabot>   Just 4
15:28:54 <bavardage> vixey: I'll take it out
15:28:56 <wli> I'll get toit once I figure out modules.
15:28:58 <Cale> > let dict = zip [1,2,3] [2,3,4] in lookup 1 dict >>= \x -> lookup x dict >>= \y -> lookup y dict >>= \z -> lookup z dict
15:28:59 <lambdabot>   Nothing
15:29:02 <b_jonas> because I think core doesn't (is that because of fail?)
15:29:16 <vixey> if you make it monadic so it can do IO it will probably go strict
15:29:23 <Philippa__> vixey: in this particular case, the exercise is to learn about monads by building a transformer stack and corresponding evaluator
15:29:25 <b_jonas> > Right 5 >>= (\x -> return (2*x))
15:29:26 <lambdabot>   Add a type signature
15:29:36 <b_jonas> > Right 5 >>= (\x -> return (2*x)) :: Either () Int
15:29:37 <lambdabot>       No instance for (Error ())
15:29:37 <lambdabot>        arising from a use of `return' at <in...
15:29:41 <Philippa__> vixey: only because the IO monad is. Guess how I found out the library State and Reader monads're lazy now?
15:29:50 <b_jonas> oh
15:29:54 <b_jonas> so it's not a general instance
15:29:55 <pumpkin> , Right 5 >>= (\x -> return (2*x)) :: Either () Int
15:29:58 <lunabot>  Right 10
15:30:18 <pumpkin> , fmap (2*) $ Right 5
15:30:19 <lunabot>  Right 10
15:30:20 <mreh> what do you professional haskell types do all day then?
15:30:27 <pumpkin> , fmap (2*) $ Left 5
15:30:28 <lunabot>  Left 5
15:30:30 <b_jonas> couldn't we just make Either a monad with fail = error "fail called for the either monad"
15:30:32 <mreh> if there are any
15:30:33 <b_jonas> ?
15:30:41 <Philippa__> b_jonas: we could, it'd just be stupid
15:30:47 <b_jonas> Philippa__: why?
15:30:55 <wli> It's if the leading term of any polynomial in the basis divides any term of the polynomial to reduce, not just the head term of the polynomial to reduce.
15:30:59 <Philippa__> well, it wouldn't
15:31:08 <Philippa__> and yeah, I know the feeling
15:31:18 <pumpkin> @hackage fgl
15:31:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
15:31:20 <Philippa__> meh, having a bad day. Fail and the resulting Error class suck
15:31:28 <b_jonas> so do you have to define your own Either type to do that?
15:31:36 <b_jonas> I guess you do
15:31:36 <Philippa__> a newtype'll do
15:31:48 <b_jonas> Philippa__: it would but then you have to write double constructors
15:31:59 <b_jonas> Philippa__: reimplementing Either is easier
15:32:07 * vixey thinks we should all respec. haskell
15:32:14 <vixey> redesign the language and libs
15:32:15 <Philippa__> eh, you probably want wrappers around the constructors anyway
15:32:39 <b_jonas> Philippa__: return is there for Right of course,
15:33:08 <Saizan_> it's easier to write a dummy Error instance
15:33:15 <Philippa__> b_jonas: you want elimination forms too. Throw/catch and so forth
15:33:38 <b_jonas> Saizan_: but you can't write a general Error instance because it could interesct with existing ones
15:33:53 <b_jonas> Philippa__: throw is just Left,
15:34:03 <b_jonas> you might not necessarily need catch
15:34:08 <b_jonas> but you may need it
15:34:09 <Philippa__> b_jonas: I know it's just left
15:34:12 <Philippa__> you /want/ catch
15:34:18 <Philippa__> it's not about need
15:34:27 <b_jonas> Philippa__: why, runEither' can catch
15:34:38 <Philippa__> so catch = runEither', you still want it
15:34:57 <pumpkin> seeing things like i2d :: Int -> Double
15:34:57 <pumpkin> i2d = fromInteger . toInteger in fgl make me uneasy
15:35:13 <b_jonas> let's see, to reimplement Either, you need 1. a data, deriving Eq, Ord, Show, Read, 2. an either, 3. instances for Monad, Functor, Applicative. I thikn that's all.
15:35:30 <b_jonas> Philippa__: I think that's try, not catch
15:35:49 <centrinia> :t fromInteger . toInteger
15:35:51 <lambdabot> forall a a1. (Integral a1, Num a) => a1 -> a
15:35:56 <b_jonas> Philippa__: but I'm not sure you need it if you have the constructors exposed, there's no runReader or runList either
15:35:57 <pumpkin> @src fromIntegral
15:35:57 <lambdabot> fromIntegral = fromInteger . toInteger
15:36:07 <Philippa__> there is a runReader
15:36:11 <b_jonas> it's just id
15:36:13 <Philippa__> there's no runList
15:36:17 <b_jonas> Philippa__: for the wrapped Reader, maybe
15:36:19 <Philippa__> but that's an oddity
15:36:24 <b_jonas> but you would use this unwrapped
15:36:43 <b_jonas> anyway, yeah, a catch or something like that could be useful
15:36:48 <b_jonas> or a catchJust or something
15:36:52 <Philippa__> *shrug* - I still prefer to work in high-level terms unless I've got a good reason not to
15:36:58 <Philippa__> and yeah, that includes runReader
15:37:01 <b_jonas> (you'd need names for it)
15:37:12 <b_jonas> Philippa__: oh well
15:37:34 <Philippa__> almost to the point where I'm tempted to define runList = id for the sake of it, because the pattern's so idiomatic
15:37:36 <b_jonas> I guess this is why it's useful that I know how these monads are implemented
15:37:40 <b_jonas> I can write my custom versions
15:37:44 <b_jonas> and you can too
15:37:53 <vixey> but then where do you NOT put runList??
15:37:57 * glguy wonders if Data.ByteString.Internal.createAndTrim would be more efficient if it realloc'd its array, rather than allocating a new array and copying
15:38:43 <Philippa__> vixey: where I'm not using list as an encoding of nondeterministic computation
15:39:23 <Philippa__> to put it another way, runList would mark where I care about getting a list out and where it's reasonable to replace it with another type
15:39:47 <b_jonas> @src transpose
15:39:47 <lambdabot> transpose []             = []
15:39:47 <lambdabot> transpose ([]   : xss)   = transpose xss
15:39:47 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
15:41:23 <Philippa__> vixey: the whole point is that it introduces new information about my intent within the program :-)
15:49:58 <centrinia> What do you call a transform f where f (f (f x))) = f x ?
15:51:05 <Philippa__> idempotent
15:51:07 <vixey> triple idempotent
15:51:22 <vixey> ivolutipotent
15:51:32 <centrinia> Cool,
15:51:45 <smtms>  18
15:51:50 <vixey> centrinia (dont' know any term for that specifically)
15:51:53 <Philippa__> okay, technically I'm assumg f (f x) = f x too. It's not idempotent if not
15:51:55 <smtms> sorry
15:51:59 <vixey> so mushing together words sort of works..
15:52:26 <Philippa__> you might just say that (f x) gives a fixpoint of f . f
15:52:53 <centrinia> Philippa_, I was thinking of something like (transpose . transpose . transpose) x = transpose x ;)
15:52:58 <pumpkin> @pl (\x -> x x) (\x -> x x)
15:53:01 <lambdabot> ap id id (ap id id)
15:53:02 <lambdabot> optimization suspended, use @pl-resume to continue.
15:53:06 <pumpkin> @pl-resume
15:53:06 <Gracenotes> nooooooo
15:53:09 <pumpkin> :P
15:53:13 <lambdabot> ap id id (ap id id)
15:53:13 <lambdabot> optimization suspended, use @pl-resume to continue.
15:53:25 <centrinia> pumpkin, is that the Omega combinator?
15:54:02 <pumpkin> zomega
15:54:07 <Gracenotes> one way to pl that is: join id (join id)
15:54:07 <pumpkin> zomegawd
15:54:34 <Gracenotes> no typechecky, but pl'd 'tis.
15:55:13 <Philippa__> centrinia: do you need specifically that property rather than self-inverse?
15:56:19 * SubStack wonders if there is some way to pattern match without having to care how many arguments a constructor takes
15:56:24 <centrinia> Philippa_, I think that (f . f . f) x = f x is more general than (f . f) x = x; I'm curious as to what that property is called.
15:56:28 <Philippa__> SubStack: yep, record syntax
15:56:42 <SubStack> record syntax in pattern matching?
15:56:43 <Philippa__> Foo{} is "a Foo, don't care about the parms"
15:56:47 <SubStack> :o
15:56:49 <SubStack> Philippa__++
15:56:49 <Philippa__> if you want to name it, foo@Foo{}
15:56:50 <vixey> centrinia: well transpose . transpose = id .. transpose it involutive
15:56:50 <vixey> not sure why you are doing transpose again on both sides
15:57:08 <vixey> instead of (f . f) x = x write f . f = id, it is more beautiful
15:57:10 <SubStack> that is decidedly very nifty
15:57:27 <centrinia> > (\x -> (transpose . transpose) x == x) [[1,2,3],[4,5]]
15:57:38 <lambdabot>   True
15:57:44 <centrinia> > (\x -> (transpose . transpose) x == x) [[1,2],[3,4,5]]
15:57:52 <lambdabot>   False
15:57:56 <centrinia> There.
15:58:05 <centrinia> > (\x -> (transpose . transpose . transpose) x == transpose x) [[1,2],[3,4,5]]
15:58:14 <lambdabot>   True
15:58:22 <wli> Okay, fixed.
15:58:31 <pumpkin> zomg
15:58:36 <pumpkin> TTTranspose
15:58:44 <pumpkin> or fatality or something
15:59:07 <kerlo> centrinia: what do you call the latter property?
15:59:24 <BMeph> Tridempotency? ;)
15:59:37 <centrinia> Also, negation in intuitionistic logic has the same property, but is not a self-inverse.
16:00:11 <wli> Looks much better, and converges, too.
16:00:36 <kerlo> I guess I'd say "self-inverse over its image".
16:01:09 <centrinia> Yeah, that makes more sense.
16:01:57 <c_wraith> I'm playing with project euler a bit.  Many of these problems call for dynamic programming solutions.  Is there a common idiom for dynamic programming in haskell?
16:02:25 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example
16:02:26 <pumpkin> has anyone here tried anything like belief propagation (sum-product) in haskell before?
16:02:37 <luite> c_wraith: you can often generate the table using a lazy, immutable array
16:03:05 <wli> http://wli.pastebin.com/ma0cb49d <-- updated Grobner crud
16:03:07 <centrinia> c_wraith, You can also construct a function.
16:03:09 <bvck> Can someone help translate this into single syllables for me: forall (f1 :: * -> *).
16:03:09 <bvck>                           (Foo f1) =>
16:03:09 <bvck>                           forall (f2 :: * -> *) a1. (Foo f2) => XX f1 (f2 a1) -> f2 a1
16:03:12 <c_wraith> It feels like something that should be trivial, once I wrap my head around it.
16:03:20 <kerlo> > id == id
16:03:21 <lambdabot>       No instance for (Eq (a -> a))
16:03:22 <lambdabot>        arising from a use of `==' at <int...
16:03:27 <kerlo> Aww. :-)
16:05:05 <c_wraith> hmm.  I didn't know about the listArray constructor.  that's handy.
16:10:36 <bavardage> yay I have map working now :D
16:10:45 <bavardage> map using pure lamba calc
16:10:47 <bavardage> :D
16:11:29 <pumpkin> how pure?
16:11:52 <b_jonas> bvck: that looks like higher-order types (aka existentials)
16:12:05 <b_jonas> but maybe it only looks like that
16:12:08 <Saizan_> higher-rank
16:12:11 <adityam> @pl f t = [g t, h t, i t]
16:12:11 <lambdabot> f = liftM2 (:) g (liftM2 (:) h (return . i))
16:12:15 <b_jonas> rank? okay, rank
16:12:49 <b_jonas> this class/rank/order thing is crazy
16:12:56 <bvck> b_jonas, yes it is. I am getting an error in ghci and this is one of the statements so trying to understand it.
16:13:00 <Saizan_> order means something else :)
16:13:33 <b_jonas> is that really a higher-rank type or just written like that/
16:13:40 <bvck> This is the code:
16:13:41 <b_jonas> because both the foralls seem to be at the top level
16:13:43 <bvck> class Foo f where
16:13:43 <bvck>   foo :: f a -> a
16:13:43 <bvck> class Bar b where
16:13:43 <bvck>   bar :: (Foo f) => b (f a) -> f a
16:13:43 <bvck> data (Foo f) => XX f a = X (f a)
16:13:44 <bvck> instance (Foo f) => Bar (XX f) where
16:13:46 <bvck>   bar (X y) = y
16:13:53 <bavardage> pumpkin: pure apart from a let statement
16:13:58 <bavardage> pumpkin: so it's lamba calc with a let
16:14:07 <Saizan_> bvck: use a pastebin
16:14:12 <Saizan_> bvck: and paste the whole error
16:14:15 <b_jonas> @kind forall (f1 :: * -> *). (Foo f1) => forall (f2 :: * -> *) a1. (Foo f2) => XX f1 (f2 a1) -> f2 a1 {- how is that even parenthisized? -}
16:14:17 <lambdabot> parse error on input `forall'
16:14:37 <bavardage> pumpkin: http://paste.pocoo.org/show/113142/ like that
16:15:02 <wli> Not quite fixed. :(
16:16:32 <c_wraith> Hmm.  Is the order of [(i, j) | i <- [1..5], j <- [6..10]] well-defined?
16:17:09 <Saizan_> the order in which the pairs come out?
16:17:18 <c_wraith> Yes.
16:17:26 <Saizan_> yes, it is
16:17:30 <c_wraith> ghc gives me the order I'd expect, but...  I'm not sure I have a reason to expect that.
16:17:45 <Saizan_> ?undo [(i, j) | i <- [1..5], j <- [6..10]]
16:17:46 <lambdabot> concatMap (\ i -> concatMap (\ j -> [(i, j)]) [6 .. 10]) [1 .. 5]
16:17:53 <Saizan_> ?src concatMap
16:17:54 <lambdabot> concatMap f = foldr ((++) . f) []
16:18:12 <c_wraith> Oh.
16:18:16 <Saizan_> you can derive the semantic from that.
16:18:27 <c_wraith> Because of the order of application of >>= if I wrote it in do-notation.
16:18:59 <c_wraith> Well, not the order...  The particular expression each one applies to.
16:19:15 <Saizan_> yeah
16:20:12 <wli> I should get {a^14 - 2066*a^7 + 875009, a^7 - 196*b - 1033} from {b^5-2, a^7 - (35*b^4 + 35*b^3 + 23*b^2 + 21*b + 43)}
16:20:57 <bvck> Saizan_, here it is: http://codepad.org/HkgffvXa
16:21:19 <bvck> (code and error)
16:24:26 <Saizan_> bvck: oh, that's because bar :: (Foo f) => b (f a) -> f a
16:24:35 <Saizan_> bvck: doesn't mean what you think
16:25:11 <bvck> Saizan_, please *explain*....:) I have been banging my head on this.
16:25:25 <Saizan_> bvck: ok
16:25:46 <bavardage> Philippa__: it seems my evaluator is too strict :P
16:25:49 <Saizan_> bvck: do you know kinds?
16:25:54 <wli> woops
16:26:05 <Philippa__> bavardage: how so?
16:26:11 <bvck> Saizan_, kind of...:) I am thinking of them as 'functions' on types.
16:26:27 <bavardage> Philippa__: I can't just wrap things in putNat to get a value
16:26:38 <bavardage> :D
16:26:47 <Saizan_> bvck: kinds are the types of types, type constructors like XX or Maybe are functions on types
16:26:50 <bavardage>   f l. ((isnil l) nil (cons (putNat (head l)) (f (tail l)))) to print a list
16:27:07 <bavardage> but that only outputs if I actually get the value of a certain element
16:27:11 <bavardage> hehe
16:27:21 <wli> Never mind, when I don't typo it in Maple it's some huge nasty expression.
16:27:27 <Philippa__> that's not strict enough, no?
16:27:27 <bavardage> so if I then call (head list) then it gives me the head and outputs the value of the head
16:27:36 <bavardage> gaah I'm silly
16:27:38 <Saizan_> bvck: so Maybe :: * -> * since it takes a parameter, and XX :: (* -> *) -> * -> *, because it takes a parameter that's a function and another one
16:27:40 <bavardage> s/strict/lazy/
16:27:44 <bavardage> "my evaluator is too lazy"
16:27:48 <bavardage> I FAIL at speaking
16:27:58 <Philippa__> if you add IO, you'll get it strictified for you
16:28:02 <Philippa__> don't worry about it for now?
16:28:26 <Saizan_> bvck: in "b (f a)", b :: * -> *, because it takes only a parameter, it doesn't matter that the shape of that parameter is (f a)
16:28:31 <bavardage> Philippa__: I won't
16:28:34 <bavardage> :P
16:28:50 <Philippa__> bavardage: have you had a go at rewriting it using Reader?
16:28:58 <bavardage> not yet
16:29:02 <bavardage> I've been tidying everything up
16:29:07 <bavardage> I may make a start
16:29:07 <Philippa__> you might fight it helps to write it in monadic style using the identity monad first, then factor out the environment
16:29:13 <bavardage> but it's 12:30 and should go sleep
16:29:17 <Philippa__> *nod*
16:29:18 <bavardage> oh kk
16:29:30 <bavardage> so Identity monad is like no monad at all?
16:29:59 <chrisdone> hoi
16:30:15 <BMeph> polloi
16:30:22 <FunctorSalad> @src Identity
16:30:22 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
16:30:39 <chrisdone> will you bmeph friend?
16:30:44 <bvck> Saizan_, following you so far.
16:30:48 <FunctorSalad> (it's a newtype, so you still need to wrap/unwrap)
16:31:11 <Saizan_> bvck: at this point when you write Bar (XX f), b = XX f, and the a of the definition of XX becomes (f1 a) where i use f1 to make it distinct from the other f
16:31:23 <BMeph> ;)p
16:32:06 <Saizan_> bvck: so bar should return this (f1 a), but you try to return what it looks like f (f1 a) to him
16:32:39 <Saizan_> basically i think you should change the type of bar to "(Foo f) => b f a -> f a"
16:32:42 <c_wraith> well, I got the answer wrong, but it sure was fast. :)
16:32:55 <Saizan_> so you can write instance Bar XX where ...
16:33:10 <c_wraith> I just don't know if it's a logic error in my algorithm, or an implementation error, where I wrote the algorithm wrong.
16:33:16 <c_wraith> I'll look at it again after i take a shower.
16:33:44 <c_wraith> oh, crap.  algorithm error!  No need for a later look, yay. >_>
16:35:01 <bvck> Saizan_, let me read your last three sentences a little carefully and ping back. Thanks.
16:36:03 <Saizan_> bvck: maybe i should rewrite that using distinct variables.
16:38:39 <centrinia> Is Identity a functor?
16:39:42 <jedai> centrinia: Every Monad is a Functor
16:40:01 <BMeph> centrinia: ...can you define it in a way that it is *NOT* a functor? ;)
16:40:07 <jedai> centrinia: so Identity is a Functor (though not a very interesting functor)
16:41:05 <wli> So I basically need to fix whatever is wrong with the Grobner code and factor polynomials in Z[x].
16:41:24 <jedai> > fmap (+5) $ Identity 3
16:41:25 <lambdabot>       No instance for (Show (Identity a))
16:41:25 <lambdabot>        arising from a use of `show'...
16:41:41 <jedai> > runIdentity . fmap (+5) $ Identity 3
16:41:42 <lambdabot>   8
16:42:26 <centrinia> Is () a functor?
16:42:43 <jedai> centrinia: No it isn't, it has the wrong kind
16:42:58 <centrinia> Oh, what about newtype Void a = Void ?
16:43:08 <jedai> centrinia: a Functor must have kind * -> *, but () kind is *
16:43:11 <koninkje> yes, trivially
16:43:33 <koninkje> centrinia: the Void :: * -> * version I mean
16:43:51 <Gracenotes> ().. best functor ever. and monad too. applicative, foldable, traversable
16:43:51 <jedai> centrinia: Yes, but even less interesting than Identity, basically fmap for Void is const id
16:43:57 <Philippa__> centrinia: yep. Maps everything to _|_
16:44:13 <Gracenotes> not a comonad though
16:44:30 <Gracenotes> except for monoids
16:44:57 <wli> When the smoke clears I need to factor the divisor(s) of the annihilating polynomials in the field extended.
16:45:54 <orbitz> can anyone think of an example of a monad in another langauge (such as C++, java, Python) that is common (but never called one beacue the authors jut didn't realize)?
16:46:19 <wli> This is rapidly getting beyond my power to program.
16:46:33 <dibblego> orbitz, throws (Java), ; (C++_
16:46:57 <orbitz> dibblego: as in for checked exceptions?
16:47:05 <dibblego> orbitz, yes
16:47:40 <dibblego> orbitz, a method that declared to return T or throw E is really returning Either e t
16:47:43 <orbitz> so is the catch and possible rethrow equivalent to >>=?
16:47:44 <Gracenotes> imperative languages tend have design patterns *because* they don't have abstract stuff like monads. They have to create an enforce the abstraction outside of the language
16:47:47 <dibblego> and (Either e) is the monad
16:47:56 <Gracenotes> *and
16:48:35 <orbitz> dibblego: interesting thanks
16:48:39 <orbitz> any other examples?
16:49:02 <dibblego> orbitz, if(t == null) null else return f(t); // the Maybe monad
16:49:30 <dibblego> return t == null ? null f(t);
16:49:45 <orbitz> ahhh
16:49:49 <crutcher> Gracenotes: it is the position of the Design Pattern community, and Alexander in particular, that design patterns are a feature of any expert knowledge base
16:50:02 <crutcher> though they are not usually called that
16:50:05 <orbitz> so every obejct in Java is basicaly a monad in an abstract sense?
16:50:19 <Gracenotes> crutcher: expert knowledge base?
16:50:36 <dibblego> orbitz, the semi-colon is a monad
16:50:37 <crutcher> anything you can be an expert about
16:50:49 <crutcher> say you know a lot about laying sidewalks
16:50:54 <dibblego> orbitz, that is probably the most pervasive example
16:51:07 <wli> So, basically, my Grobner code is broken even though I understand Grobner, the one (dogslow) method I understand for factoring in Z[x] is too slow for trivial problems and beyond my power to program, and I don't even understand how to factor polynomials over algebraic extensions of Q (or Z) at all.
16:51:13 <orbitz> dibblego: thanks
16:51:18 <Gracenotes> crutcher: yes. In Haskell, we have functors, monads, list combinators, and so on. What sets them apart from, say, Java design patterns is that they're part of the language.
16:51:19 <crutcher> they would say that, squriled away in your head, you have a little language which helps you think about laying sidewalks
16:51:44 <crutcher> that language is your "pattern language", according to this theory
16:51:57 <crutcher> and recurrent solutions generated by that pattern language are the "design patterns"
16:52:07 <Gracenotes> it seems to me that OOP design patterns exist because OOP is more a set of principles than a set of things you can design programs with.
16:52:48 <crutcher> Gracenotes: perhaps, but haskell has its own design patterns; features which are recurrent in many haskell programs
16:52:49 <Berengal> Gracenotes: I'd say monads and such are not part of the language. If they were, they'd have special syntax
16:53:01 <Gracenotes> *cough*do*cough*
16:53:03 <Berengal> Gracenotes: Which, admittedly, monads do, but it's only syntactic sugar
16:53:09 <Gracenotes> :P
16:53:18 <Berengal> throw/catch isn't simply sugar...
16:53:23 <Berengal> (In Java)
16:53:54 <crutcher> Hmm, "only" syntactic sugar? syntactic sugar places a very _strong_ blessing on the pattern that it regularizes
16:54:03 <Gracenotes> crutcher: I agree. They are, basically, abstractions. Which FP is reasonably good at.
16:54:04 <orbitz> i am quite new to all this, but my expereince seems to be is a deisgn pattern in java is something that you implement when you hit a problem and it's not like you are implemetning yoru clas to fit into a design pattern that anyoen can use, unlike say functor which is an interface people program for and then anyone that understand a functor understand your new type
16:54:07 <RayNbow> hmm, curious about the opinions here... http://www.phil.cam.ac.uk/teaching_staff/Smith/LaTeX/resources/buss01.gif versus http://www.mscs.dal.ca/~selinger/fitch/fitch.png , which proof style is considered more readable?
16:54:09 <orbitz> that may not have made much sense...
16:54:26 * RayNbow prefers the Fitch style proofs himself
16:54:27 <centrinia> Java is syntactic sugar for JVM bytecode. :)
16:54:40 <Berengal> crutcher: yes, but you can still do without it. do notation is very similar to stacking ">>= \foo"'s on top of eachother...
16:54:52 * Philippa__ invites anyone who thinks Haskell doesn't have design patterns to consider (FP variants of) the interpreter pattern, shallow encoding, "self-optimising combinators"...
16:55:09 <orbitz> Berengal: isn't try/catch equivalent to impelemtning a generic Either class iN java?
16:55:11 <Philippa__> the last of which has understood patterns for it that aren't "use an arrow like..."
16:55:51 <crutcher> orbitz: if you really care about this, and have a _lot_ of time, you can go read "A Pattern Language". Its about building houses, but its one of the foundational works on pattern languages, and thus, design patterns
16:55:58 <Berengal> orbitz: Exceptions are built into the language. You could probably emulate them to some degree, but I doubt you could emulate them perfectly
16:55:59 <crutcher> the book is huge though
16:56:29 <orbitz> crutcher: ugh i think i might have to stick with your abridged sidewalk version
16:56:41 * koninkje prefers Buss. Though it'd depend on the proof I suppose
16:56:50 <dibblego> orbitz, yes it is like that -- Functional Java does not use exceptions for example
16:57:14 <orbitz> dibblego: it sticks to an Either object?
16:57:42 <dibblego> orbitz, correct -- particularly for its actors implementation
16:57:47 <crutcher> well, the basic idea is that you have a little language in your head for anything that you are an expert at. and if you understand pattern languages, you can take an expert and 'capture' their language, writing down the patterns so others can learn them more easily. design patterns are a degenerate form of that, popularized for OOP.
16:58:12 <crutcher> but the idea of pattern languages, and design patterns, pre-dates and finds motivation outside of oop
16:58:17 <crutcher> that's the sidewalk version.
16:58:18 <orbitz> so a question about usign Either for erro reporting.  It seems like one of the main reasons exceptiosn came into rpactice in imperative langauges is because you can ignore the return value, so you can ignor ean error.
16:58:46 <dibblego> orbitz, that's the value provided to you by the monad
16:58:52 <orbitz> in haskell you have to atleast be aware of you'll get something other htan a Right back, but does that mean you have to have a lot of extra code to propogate erros up teh call stack?
16:59:00 <crutcher> orbitz: are you familiar with setjump/longjump?
16:59:19 <orbitz> crutcher: yes
16:59:26 <tgdavies> it's been said that the design patterns you use in a programming language indicate a lack of expressiveness in that language
16:59:27 <Gracenotes> crutcher: yes, every language has design patterns. Haskell, Java, etc. It just seems to me like class-based design patterns in, say, Java aren't enforced by anyone but the programmer.
17:00:00 <crutcher> lots of the early imperative libs had essentially non-existent error handling, they just died. then some people added the "die, or maybe un-roll the stack" method.
17:00:21 <crutcher> but people wanted more fine-grained control of that, hence exceptions
17:00:41 <c_wraith> anyone who doesn't mind being spoiled for the solution to project euler 15, and is willing to give language advice:  http://pastebin.com/m7d399620   Is there some cleaner way to create r?
17:02:19 * thoughtpolice just found out he can get ACM articles through his university!
17:02:23 <Ansible> Gtk2Hs doesn't seem to be on cabal.  Am I missing something?  just install it manuallY?
17:02:36 <thoughtpolice> Ansible: http://haskell.org/gtk2hs
17:02:42 <thoughtpolice> you have to download and install it with 'make'
17:02:45 <Saizan_> thoughtpolice: yeah, that's an amazing moment :)
17:02:48 <thoughtpolice> cabal can't handle gtk2hs yet
17:02:51 <Gracenotes> there are dependency problems
17:02:57 <Ansible> ah ok...  thx
17:03:15 <koninkje> orbitz: A more faithful functional throw/catch would use a CPS transformed version of Either:
17:03:18 <koninkje> http://code.haskell.org/~wren/wren-extras/dist/doc/html/wren-extras/Control-Monad-MaybeCPS.html
17:03:26 <Berengal> c_wraith: Problem 15, was that the triangle?
17:03:32 <koninkje> ...of course, getting finally blocks to work right is... odd.
17:03:36 <dolio> c_wraith: You could try using a pair as the index instead of nested arrays.
17:03:41 <c_wraith> Berengal: It's the number of paths along the index
17:03:47 <c_wraith> err, along the grid
17:03:47 <Berengal> c_wraith: Oh, right, that one
17:03:54 <Gracenotes> c_wraith: liftM2 f [0..m] [0..n]
17:04:25 <Gracenotes> or actually.. hm, that'd take away the nesting
17:05:01 <Gracenotes> c_wraith: but, ah! Then you can listArray it with ((0, 0), (m, n))
17:05:04 <Berengal> Combinatorial math is really the way to go on that one...
17:05:37 <c_wraith> dolio: Hmm.  Is (Ix a, Ix b) => Ix (a, b) defined?
17:05:38 <Gracenotes> an easy way to make multidimensional arrays in Haskell is to make them with (Int, Int) indices
17:05:45 <dolio> I think so.
17:05:48 <dolio> @instances Ix
17:05:49 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
17:05:55 <Gracenotes> yeah, it's an instance
17:05:57 <dolio> @instances-importing Data.Ix Ix
17:05:58 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
17:06:08 <c_wraith> Ah.
17:06:14 <c_wraith> I didn't realize there was an instance for that.
17:06:17 <c_wraith> It would have been easier
17:06:31 <Gracenotes> so.. listArray ((0, 0), (m, n)) $ liftM2 f [0..m] [0..n]. I think >_>
17:07:16 <Berengal> There is an instance Ix () ?
17:07:32 <c_wraith> Why not?  It's trivial, but...  that means it's easy to write! :)
17:07:39 <Berengal> Hehe
17:07:40 <Gracenotes> > inRange ((), ()) ()
17:07:41 <Berengal> True
17:07:41 <lambdabot>   True
17:07:55 <Gracenotes> wow, Berengal, faster than lambdabot! :D
17:08:25 <JohnMeacham> newtypes in C: http://notanumber.net/archives/33/newtype-in-c-a-touch-of-strong-typing-using-compound-literals
17:08:48 <Berengal> Gracenotes: I incorporate a new optimization technique known as preemptive execution
17:08:54 <Berengal> I execute commands before they're given
17:09:24 <Gracenotes> nice :D try to execute my next one?
17:09:34 <bremner> I christen your new language W
17:09:34 <Berengal> 5
17:09:37 <pejo> Berengal, that explains why I just saw some missiles flying by.
17:09:40 <Gracenotes> > 2 + 3
17:09:41 <lambdabot>   5
17:09:58 <Berengal> See?
17:10:07 <Gracenotes> import Data.Jeopardy
17:10:29 <Berengal> ;)
17:10:52 <JohnMeacham> Berengal: http://www.catb.org/~esr/jargon/html/D/DWIM.html
17:11:24 <boomerangfish> I just came from an open-source conference that had an intro to Haskell ... it looks like interesting programs can be written in Haskell, but what about useful ones?
17:11:41 <Berengal> boomerangfish: They're the same, aren't they?
17:11:46 <crutcher> wow. that's some flame bait
17:12:04 <boomerangfish> sorry if that sounds inflammatory ... I don't mean it that way
17:12:28 <Berengal> boomerangfish: Define useful
17:12:32 <Cale> boomerangfish: Yes, useful programs can indeed be written in Haskell :)
17:12:55 <kc5tja> Useful is so subjective that it has no meaning in this context.
17:13:08 <roconnor> boomerangfish: I find Haskell useful for writing programs to solve particular problems, rather than building systems.  But solving problems tends to be the programs I write / need.
17:13:17 <boomerangfish> I actually learned Miranda in my first year as a computer science undergrad and liked it (it might give you some clue how old I am)
17:13:19 <kc5tja> I'm a rather happy xmonad user, and have been since it first came out.
17:13:29 <romildo> Hi.
17:13:30 <koninkje> boomerangfish: does "useful" include?: operating systems, distributed version control, web applications, window managers,...?
17:13:34 <roconnor> romildo: hi
17:13:51 <kc5tja> I used to use Darcs exclusively, although I switched to Mercurial for purely pragmatic reasons.
17:14:01 <crutcher> boomerangfish: it is the stated goal of Haskell to avoid success at all costs
17:14:02 <boomerangfish> roconnor: point taken ...
17:14:06 <mux> is there a reason for not having an MArray instance for unboxed pairs?
17:14:14 <crutcher> lately, some people are really falling down on that front
17:14:27 <crutcher> looking at you Cale
17:14:33 <Cale> Me?!
17:14:37 <Cale> What have I done?
17:14:55 <crutcher> too much useful stuff?
17:14:56 <Cale> It's all dons' fault, I swear!
17:15:02 <roconnor> boomerangfish: Also, I find writing incorrect programs in Haskell more difficult.  And since it is hard to build large correct systems, perhaps this is why it is hard to write large systems in Haskell.
17:15:09 <kc5tja> I might even be working on a web application written in Haskell (using HApps) in the not too distant future, if the seed funding round goes through.
17:15:18 <roconnor> boomerangfish: ie other languages let you more easily write large broken systems.
17:15:31 <koninkje> mux: unboxed pairs don't exist (at least not in the usual sense)
17:15:43 <Berengal> There is something to be said for large, broken systems though...
17:15:52 <Gracenotes> kc5tja: neat :) although, it is no longer maintained.. a fork, happstack, is (for now, at least)
17:15:53 <luite> boomerangfish: miranda is still being taught at some universities
17:15:55 <pejo> roconnor, people seem to be writing compilers in most fp languages, and that should qualify as a system imho.
17:15:57 <boomerangfish> roconnor: indeed! I write large broken systems on a regular basis (but don't tell my boss that ;)
17:16:02 <roconnor> Berengal: indeed.  Large broken systems are cheap
17:16:09 <c_wraith> Here's an updated version: http://pastebin.com/d301ba474
17:16:16 <kc5tja> Gracenotes: Yes, that's it.  Sorry, that's what I meant.
17:16:23 <Gracenotes> no problem
17:16:29 <mux> koninkje: what are (# #) pairs then?
17:16:30 <c_wraith> liftM2 is a cute replacement for a list comprehension there.  I'll have to remember it when it works.
17:16:32 <Berengal> roconnor: And one of them keeps me employed, both as a clerk and as a software engineer...
17:16:43 <roconnor> Berengal: good thing it is broken then
17:16:49 <koninkje> mux: They are magical and the fields get unboxed into registers
17:17:01 <Cale> I don't think large systems should be any more difficult in Haskell. We just don't have as many large groups of users.
17:17:03 <koninkje> ...that's why they can only be int he return position and not in argument position
17:17:03 <kc5tja> It'll feel good to actually code on a commercial project in Haskell.  Finally, I can get paid to play.
17:17:05 <Berengal> roconnor: It also gives me no small amount of frustration...
17:17:11 <kc5tja> Funding permitting, of course.
17:17:18 <Cale> GHC is pretty large though.
17:17:18 <roconnor> Berengal: if only it were written in Haskell
17:17:19 <mux> koninkje: wow, scary
17:17:25 <Berengal> roconnor: If only...
17:17:30 <dolio> mux: (In GHC) You can't pass unboxed tuples as arguments to functions, for instance. You can only return them from functions.
17:17:36 <Cale> (I suppose it depends somewhat on what you consider to be large)
17:17:37 <Gracenotes> c_wraith: so did it work?
17:17:38 <koninkje> mux: I agree that there should be a way to get the moral equivalent of unboxed MArrays of tuples though
17:18:20 <c_wraith> Yeah, the updated version gives the same answers
17:18:22 <koninkje> er, moral equivalent of MArrays of unboxed tuples
17:18:24 <boomerangfish> OK, how about we cover some problem domains small enough for a single developer to tackle that Haskell excels at?
17:18:30 <Berengal> c_wraith: 40 `choose` 20
17:18:51 <romildo> Is there a function in the std lib that, given a function    firstSuccess :: (a -> Maybe b) -> [a] -> Maybe b   such that    firstSuccess f list     would repeatedly apply f to the list elements until a successfull result is found, returning this result, or Nothing if the end of the list is reached?
17:19:06 <c_wraith> @hoogle choose
17:19:06 <lambdabot> Test.QuickCheck choose :: Random a => (a, a) -> Gen a
17:19:11 <roconnor> IArray UArray a, IArray UArray b=> IArray UArray (#a,b#)  ?
17:19:22 <mux> romildo: that would be listToMaybe . mapMaybe I guess
17:19:26 <Berengal> c_wraith: Wrong choose. I'm thinking about the mathy one
17:19:28 <Gracenotes> c_wraith: also, if you like, sum . map ((r!) . (,) (m-1)) $ [0..n]. I believe. list comprehension might be more readable
17:19:31 <mux> :t listToMaybe . mapMaybe
17:19:31 <Cale> boomerangfish: I've found it's really great for combinatorial search problems.
17:19:32 <lambdabot>     Couldn't match expected type `[a]'
17:19:33 <lambdabot>            against inferred type `[a1] -> [b]'
17:19:33 <lambdabot>     Probable cause: `mapMaybe' is applied to too few arguments
17:19:53 <romildo> :t mapMaybe
17:19:54 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
17:20:00 <c_wraith> Gracenotes: yeah, I'm happy with the list comprehension there.
17:20:00 <Cale> boomerangfish: Anything which involves a parser.
17:20:02 <mux> :t \f xs -> = listToMaybe $ mapMaybe f xs
17:20:03 <lambdabot> parse error on input `='
17:20:08 <mux> :t \f xs -> listToMaybe $ mapMaybe f xs
17:20:09 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> Maybe a
17:20:13 <Cale> boomerangfish: Concurrency and parallelism
17:20:23 <mux> romildo: that should work
17:20:26 <kc5tja> boomerangfish: Well, I had written a R&D version of my CUT unit testing tool in Haskell back in the day.  (It's since been rewritten to Python because everybody b*tched and moaned about it being in a "hippie language".  Funny, I'm still not seeing any patches for it after having rewritten it in Python).
17:20:29 <dolio> mux: uvector has unboxed mutable arrays for pairs, by the way. Although it's the strict pair type (:*:) defined in that library, not the usual (,) kind.
17:20:29 <boomerangfish> cale: how does Haskell compare to Prolog for combinatorial search problems?
17:20:34 <Berengal> > let choose a b = product [(b+1)..a] `div` product [1..(b-a)] in 40 `choose` 20
17:20:34 <adityam> @pl ancestors team idx = ancestoral team [idx]
17:20:34 <lambdabot> ancestors = (. return) . ancestoral
17:20:35 <lambdabot>   335367096786357081410764800000
17:20:43 <c_wraith> Berengal: I know what choose you meant..  I was just hoping someone had implemented it already. :)
17:20:51 <romildo> :t listToMaybe
17:20:52 <lambdabot> forall a. [a] -> Maybe a
17:21:04 <dolio> (Unboxed immutable arrays for pairs, too.)
17:21:09 <mux> dolio: ah yeah, I had seen that
17:21:13 <Berengal> ... that implementation of mine seems off...
17:21:17 <Cale> boomerangfish: Prolog has a bit nicer way of doing unification, but the list monad, or other nondeterminism and logic monads give you most of what you'd need.
17:21:30 <mux> uvector has mutable arrays too? embedded in ST?
17:21:44 <Cale> boomerangfish: I think the expressivity is comparable -- especially when you throw in Haskell's other features relative to Prolog.
17:21:48 <mux> what's the deal with uvector btw, is it the fusion framework that imposes Int indices?
17:21:50 <boomerangfish> Cale: the functional programming presentation also covered Erlang ... sounded like Erlang was more optimized for concurrency than Haskell
17:22:25 <Cale> boomerangfish: Erlang is more famous for concurrency at the moment, and does better at distributed stuff, but I actually think GHC Haskell is doing better at SMP.
17:22:35 <mux> mm, need to try that
17:22:43 <Gracenotes> mux: yeah
17:23:02 <Berengal> boomerangfish: It's actually not hard to emulate erlang style concurrency in haskell. It's not as good at distributed computing though, prefering SMP
17:23:04 <Gracenotes> only allowing certain strict types
17:23:13 <romildo> mux, thanks.
17:23:18 <dolio> mux: Yes, they're usable in ST. And no, I think dons just chose Int for performance. One of the sources of slowness in STUArray is, as I recall, the parameterized indices failing to be fully optimized down.
17:23:22 <mux> romildo: you're welcome
17:23:35 <kc5tja> boomerangfish: Remember that Erlang is a bit of a domain-specific language too -- designed expressly for coding on telephone company switches, distributed computing was a primary concern from day #1.  Haskell is more general purpose.
17:23:42 <mux> dolio: thanks
17:23:48 <boomerangfish> it was kinda funny with 3 different developers from the same company covering 3 different functional languages - Haskell, Erlang, and Clojure - and each of them would make jabs at the other 2 languages
17:23:50 <roconnor> mux: ya, that was a nice solution to romildo's problem.
17:23:56 <Cale> boomerangfish: :)
17:23:58 <roconnor> mux: better than I would have though of at first
17:23:58 <c_wraith> > let choose c n = let fact n' = product [1..n'] in (fact c) `div` ( (fact n) * (fact (c - n)) ) in 40 `choose` 20
17:24:00 <lambdabot>   137846528820
17:24:24 <Cale> boomerangfish: *My* religion is the right one! No, it's *mine*.
17:24:26 * mux blushes
17:24:37 <orbitz> Cale: no it's none of them, it's MIEN!
17:24:50 <c_wraith> Berengal: that gives the same answer, but...  I'm not clear what the justification for that approach is, just yet.
17:24:57 <dolio> mux: Not that you couldn't make it fast, but obviously you can make just-Int fast. :)
17:25:16 <Gracenotes> I'm somewhat surprised the uvector documentation doesn't meantion O(times)
17:25:19 <Gracenotes> -a
17:25:24 <kc5tja> boomerangfish: You mean, the way an Oberon programmer would make jabs at the C language, and a C++ programmer would defend C, but utterly rip Modula-2 a new one, while Ada programmers might defend Modula-2 and slam Oberon for being too simple?  Turf wars aren't unique to functional languages.
17:25:25 <c_wraith> Berengal: I guess you can think of it as...  all the distinct orders for 20 lefts and 20 downs?
17:25:28 <Berengal> c_wraith: Heh, neither am I currently. I used to be, but it's been five years since I covered combinatorics...
17:25:43 <boomerangfish> cale: it was more along the lines of "see how much more elegantly this problem is handled in language X compared to language Y"
17:25:53 <mux> dolio: this library looks very yummy, the associated types makes it look shiny new too ;-)
17:26:10 <dolio> :)
17:26:10 <Cale> boomerangfish: Ah, that's the more civilised version :)
17:26:21 <Gracenotes> don't get carried away now, mux >_<
17:26:27 <Berengal> c_wraith: Yeah, there's twenty different "go straight ahead, or turn left" and twenty different "go straight ahead, or turn right" choices
17:27:11 <jzmer> just read something about haskell, could anyone tell me if haskell is something like ocaml that would have a virtual machine running bytecodes, or more like c?
17:27:25 <kc5tja> jzmer: Both.
17:27:35 <c_wraith> Berengal: I'd think of it as "You have to go left 20 times, you have to go down 20 times.  That's 40 moves.  How many ways can you put the 20 lefts into the 40 slots?"
17:27:38 <zakwilson> jzmer: there are several implementations of Haskell.
17:27:39 <roconnor> jzmer: depends on how you implement Haskell
17:27:42 <Cale> jzmer: Uh, there are many implementations of Haskell which are rather different in terms of mechanics of that sort.
17:27:43 <kc5tja> jzmer: Use ghci to run in a VM-like environment, and use ghc to compile to native code.
17:27:45 <Berengal> c_wraith: That works too
17:28:03 <Berengal> Does ghci compile to bytecode?
17:28:08 <Cale> and yeah, the most popular implementation, GHC, has an interpreter and a compiler in one :)
17:28:14 <jzmer> oh, thats amazing, u could even write an operating system with haskell then
17:28:25 <boomerangfish> So many programmers still think there is a real distinction between language interpreters and language compilers
17:28:28 <Cale> jzmer: It's been done. :)
17:28:58 <Berengal> boomerangfish: There is a distinction, but it shouldn't be
17:28:58 <Cale> boomerangfish: Well, the bigger mistake is thinking that a language is compiled or interpreted :)
17:28:59 <idnar> jzmer: you could also write an operating system with ocaml, python, or java; there's no particular reason your OS can't run on a VM
17:29:00 <zakwilson> jzmer: you can, and people have: http://www.ninj4.net/kinetic/
17:29:15 <kc5tja> boomerangfish: Well, the choice of implementation technique influences the capabilities of the language and the performance you get from it.
17:29:22 <jzmer> idnar: well javaos failed miserably
17:29:30 <glguy> > let euler15 x y = iterate (scanl1 (+)) (repeat 1) !! x !! y in euler15 20 20
17:29:31 <lambdabot>   137846528820
17:29:43 <jzmer> something that would have to rely on a vm is cumbersome
17:29:44 <idnar> jzmer: well, it's not like there are any Haskell OSs installed on a million desktops either
17:30:00 <inimino> boomerangfish: there's a pretty big difference in practice for typical uses
17:30:07 <glguy> idnar, there are Haskell programs running on Xen, however :)
17:30:09 <jzmer> but an obvious exception is ocaml
17:30:09 <kc5tja> jzmer: not necessarily.  Perl and Python are hardly what I'd call "cumbersome."
17:30:18 <ddarius> Creating a new remotely successful desktop OS is effectively impossible.
17:30:29 <jzmer> well ocaml runs better than both of them
17:30:34 <zakwilson> jzmer: define failed. Most operating systems aren't intended to become popular desktop systems.
17:30:52 <kc5tja> jzmer: But Perl and Python are far more prevalent than OCaml.
17:31:08 <roconnor> I wonder if OS/2 is running on a million desktops
17:31:20 <jzmer> i know, but now i got an idea of writing an os with haskell in the core and map traditional c/c++ calls into ocaml
17:31:22 <boomerangfish> cale: that's what I mean ... they're just different forms of translation ... there is no such thing as "purely compiled" because the object output is always data to be processed by some other program (even machine language is data processed by a microprogram)
17:31:24 <jzmer> and ocaml into haskell
17:31:38 <roconnor> jzmer: have you looked at house?
17:31:40 <roconnor> @where house
17:31:41 <lambdabot> http://programatica.cs.pdx.edu/House/
17:31:51 <jzmer> roconnor: thx i will take a look at that
17:31:58 <ddarius> boomerangfish: What about VHDL?
17:32:01 <Cale> jzmer: There's also a project to write an L4 kernel in Haskell.
17:32:16 <roconnor> Cale: L4?
17:32:20 <roconnor> like in orbit?
17:32:28 <inimino> heh
17:32:28 <kc5tja> boomerangfish: Microprograms are quite rare now-a-days.  Most CPUs use dedicated hardwired logic for performance, replacing the microcode with a pipeline.  But, yeah, your point is taken.
17:32:50 <idnar> glguy: Xen isn't runninng on a million desktops either :P
17:32:55 <jzmer> Cale: u mean l4 microkernel?
17:33:09 <boomerangfish> kc5tja: sorry, I guess my computer architecture knowledge is a bit rusty
17:33:14 <ddarius> kc5tja: When you have transistors to burn, you might as well.
17:33:30 <idnar> kc5tja: uhm, it depends on what level you're looking at, surely?
17:33:32 <Berengal> kc5tja: You could argue that the only "real" programs are physical entities...
17:33:32 <boomerangfish> (I'm showing my age again)
17:33:32 <Cale> jzmer: Yeah, that is, it's written to meet that spec.
17:33:37 <kc5tja> idnar: Nope.
17:33:42 <idnar> kc5tja: most CISC chips these days look like a RISC chip + instruction decoder
17:33:58 <idnar> well, x86/amd64 does anyway
17:34:00 * roconnor programs with raindrops on the sidewalk
17:34:19 <kc5tja> idnar: True, but x86 CPUs cover only 5% of all microprocessor deployments (thank god!).
17:34:36 <Gracenotes> I tried to run ghci on OpenVZ. When I tried to do anything it crashed, though. apparently more memory than my VPS would give me.
17:34:38 <idnar> kc5tja: they probably cover 90% of software development, though...
17:34:44 <Cale> Right, I remember that Rebekah Leslie had something to do with it.
17:34:47 <Berengal> x86 is still the most "important" to us computer people though...
17:34:47 <Gracenotes> can't do much with 64 MB of memory >_>
17:35:01 <Cale> http://web.cecs.pdx.edu/~apt/icfp05.pdf is a related paper
17:35:03 <boomerangfish> the physical universe is a more powerful computer than any microprocessor ... it can project the motion of heavenly bodies instantaneously
17:35:05 <roconnor> <_<
17:35:13 <ddarius> Berengal: For -desktop- computer people perhaps.
17:35:17 <idnar> boomerangfish: that's because it's hardwired :P
17:35:23 <kc5tja> Irrelevant, I think.  And besides, the instruction decoder is still just a pipe stage unto itself -- it's a translation mapping (a giant ROM if you will, with opcode for input, and RISC-ops as output).  That's a purely combinatorial circuit.
17:35:24 <jzmer> Cale: wikipedia says the name is osker
17:35:34 * roconnor uses the entire solar system to run a simulation of the entire solar system.
17:35:34 <Cale> Yeah, seems to be
17:35:47 <ddarius> roconnor: In real time !
17:35:49 <Berengal> ddarius: Sure, there are other computer people, but they aren't me :P
17:35:51 <boomerangfish> idnar: God cheated by hardcoding the gravitational constant!!!!
17:35:55 <roconnor> ddarius: ya!
17:36:06 <idnar> boomerangfish: heh, I thought they decided that wasn't so constant after all :P
17:36:16 <boomerangfish> idnar: really?
17:36:37 <nanothief> Is there a name for types that have no type variables in them? Eg comparing Eq a => a -> a -> Bool vs Int -> Int -> Bool
17:36:38 <gwern> '                                        We design an algo-
17:36:39 <gwern> rithm based on two principles and evaluate the compatibility
17:36:39 <gwern> of our algorithm on over a billion HTTP responses.
17:36:49 <gwern> having access to google's db lets you do some pretty cool things
17:36:56 <gwern> nanothief: monomorphic? concrete?
17:37:05 <Cale> nanothief: Monomorphic types?
17:37:12 <idnar> boomerangfish: well, not that it varies, but just that it's determined by a combination of other things
17:37:21 <gwern> if a -> a -> Bool is polymorphic, then it stands to reason int -> int -> bool would be monomorphic :)
17:37:22 <nanothief> gwern,Cale, monomorphic was the work I was looking for, thanks
17:37:53 <Berengal> What does monomorphic even mean? why not nonmorphic?
17:38:04 <Berengal> It's not like it morphs when it only has one shape...
17:38:13 <boomerangfish> idnar: well it makes sense to me that every physical constant is really the result of a function with default values for all the dependent variables
17:38:14 <Cale> mono means one
17:38:18 <Cale> poly means many
17:38:24 <c_wraith> well..  directly translated, monomorphic would mean "one form"
17:38:25 <BMeph> Berengal: 'nonmorphic' would mean that it had no form. ;)
17:38:31 <idnar> boomerangfish: I guess I just mean that it's not a "primitive"
17:38:32 <Berengal> Ah
17:38:35 <boomerangfish> idnar: we usually just don't know what those dependent variables are
17:38:38 <Gracenotes> amorphic?
17:38:48 <Berengal> I thought morphic meant it changed form
17:38:53 <idnar> boomerangfish: in the same sense that pi + i is a "constant", but not a "primitive" constant, since its value is determined by the values of pi and i
17:38:55 <boomerangfish> sorry I meant independent variables .... my functional programming is also a bit rusty
17:38:57 <wli> Hmm. I guess I could try to factor the polynomial over the algebraic number field to begin with.
17:39:04 <BMeph> Berengal: Or nine forms, if you want to get "Old School" with the Greek. :)
17:39:33 <ddarius> Berengal: Anthropomorphic doesn't mean changing into a humanoid form.
17:39:51 <Berengal> BMeph: I'm going to start calling my functions pentamorphic or whatever, depending on how many different instanciations they can have
17:40:05 <boomerangfish> idnar: is it possible to prove that any constant is "primitive"?
17:40:31 <c_wraith> technically, it's "metamorphic" that means "changing form"
17:40:55 <kc5tja> I would have thought "transmorphic" instead.
17:41:01 <BMeph> Berengal: Well, since Haskell's classes are Open, you never "really" know how many instances they have... ;p
17:41:08 <kc5tja> "metamorphic" would, to me, imply a form of a form.
17:41:15 <idnar> boomerangfish: "prove" is a bit of a funny word
17:41:26 <idnar> boomerangfish: 42 is a primitive constant, 40 + 2 is not :P
17:41:37 <Berengal> BMeph: That just means I'll have to hook my documentation generator into the compiler somehow :P
17:41:42 <BMeph> kc5tja: "Trans" is Latin. The Greek equivalent of which, is "meta". ;)
17:42:16 <wli> Not sure what to do, apart from debugging the Grobner code.
17:42:17 <kc5tja> Oh, gotcha.
17:42:45 <Cale> boomerangfish: I'm of the view that the values of fundamental constants involved in a model of the universe, if any, are consequences of that particular way of modelling the universe.
17:42:47 <boomerangfish> indar: but they express the same value!!  I thought functional programming believed in the equivalency of values!
17:42:57 <kc5tja> Well, time to bow out.  Hacking on a solar oven, and need to pull laundry and hang it up to dry.
17:43:02 <boomerangfish> I'm sure there is a fancier term for it
17:43:25 <roconnor> kc5tja: put your laundry in the solar oven
17:43:28 <Berengal> @type 40 + 2
17:43:28 <gwern> kc5tja: maybe self-modifying code would be metamorphic
17:43:29 <lambdabot> forall t. (Num t) => t
17:43:31 <Cale> (and not necessarily anything more fundamental than that)
17:43:34 <BMeph> boomerangfish: That would be "referential transparency". It's not a particular FP trait, though.
17:43:35 <Berengal> @type 42
17:43:36 <lambdabot> forall t. (Num t) => t
17:43:37 <boomerangfish> f(40 + 2) == f(42) regardless of the definition of f, right?
17:43:44 <Cale> Similarly for every aspect of the model itself.
17:44:03 <kc5tja> roconnor: It's not that big.  However, I've already thought of something big enough for that purpose.  However, a $20 line of rope, pulleys, and clips is a lot cheaper.  :)
17:44:05 <Berengal> boomerangfish: Depends on which instance of Num f takes, and how + is defined
17:44:14 <boomerangfish> (apologies for not using proper Haskell syntax (since I don't know Haskell yet))
17:44:31 <gwern> Berengal: such as the boundedness of Int?
17:44:55 <boomerangfish> Berengal: OK, you got me!  I'm assuming the standard definition of "+" for integers
17:44:58 <koninkje> boomerangfish: Only when f is referentially transparent , and when the Num instance is also referentially transparent
17:45:03 <kerlo> boomerangfish: if 40 + 2 is equivalent to 42, then f(40 + 2) is equivalent to f(42).
17:45:07 <roconnor> kc5tja: what part of the world do you live in?
17:45:24 <kc5tja> roconnor: Bay Area, California.
17:45:40 <kerlo> Whether they're == is another question; sometimes, the result of f is not of a comparable type, and sometimes the guy who defined == over that type is a jerk and decided to make it return False even though they're the same.
17:46:11 <roconnor> kc5tja: sunny
17:46:15 <koninkje> boomerangfish: frex, there's a project for doing GP-GPU coding in haskell, and their Num instance actually builds an AST  so 40+2 /= 42
17:46:21 <BMeph> kerlo: Modulo your definition of "same", nathc. ;p
17:46:33 <BMeph> Er, *natch
17:46:40 <NEEDMOAR> Defaulting isn't a bit against transparency?
17:46:46 <kc5tja> roconnor: You don't need a hot clime to use these ovens in though.  People use solar ovens in mid-winter Ontario too.  All you need is a sunny day.
17:46:50 <boomerangfish> Haskell for GPGPU?  Does it support CUDA?
17:46:58 <koninkje> indeed.
17:47:13 <koninkje> DSEL for embedding cuda into haskell
17:47:18 * koninkje looks for the paper
17:47:26 <kc5tja> But, since I *do* have a hot clime, the last thing I want to do is waste coal/gas/electricity (which has the nasty side effect of making my apartment hotter!) cooking food when I have a plentiful supply of heat already bearing down on me.
17:48:30 <BMeph> kc5tja: Excuse me, but I thought you said you were in the Bay Area? What hot clime is that? ;p
17:48:47 <ddarius> The sample programs here are... impressive... http://en.wikipedia.org/wiki/MUMPS
17:49:11 <kc5tja> BMeph: I'm sorry?
17:49:12 <orbitz> is Either the preferred error system in Haskell?  what about differentiating various error types and even an error type heirarchy?
17:49:36 <koninkje> boomerangfish: http://www.cse.unsw.edu.au/~chak/papers/gpugen.pdf It's still a work in progress, alas.
17:49:51 <Cale> boomerangfish: In Haskell, if functions f and g always give the same result value for any particular argument x, then it's valid to replace any occurrence of f with g and vice versa.
17:50:02 <Cale> boomerangfish: (without changing the meaning of the program)
17:50:08 <Berengal> ddarius: I think scary is the word you're looking for
17:50:32 <boomerangfish> Haskell for CUDA sounds cool!   I'm a GPUGRID.net participant but I am about to disable GPUGRID on my BOINC client because it generates too much heat on my GPU over the summer months
17:50:49 <Cale> boomerangfish: another nice consequence of this is that if your function gives a correct result for a certain parameter once, you can be sure that it will always give that same correct result
17:51:03 <boomerangfish> Haskell for CUDA would give my GPU something to do (since I rarely play games with it these days)
17:51:39 <Berengal> boomerangfish: I actually use my computer as a space heater...
17:51:43 <BMeph> ddarius: "(Word about) MUMPS spread mostly through the medical community,..." Heh-heh. ;)
17:51:48 <mholub_> Does anyone know some url, where I can get highlighted haskell code in html ready for use in my blog?
17:52:06 <Cale> (that is, it's not going to magically do something different from what it did when you tested it as you go to call it in the middle of your real program)
17:52:08 <boomerangfish> Berengal: so do I,but I don't need a space heater in south-eastern US during the summer
17:52:09 <koninkje> cabal install hscolour ?
17:53:04 <mholub_> koninkje: web service will be more convenient I think
17:53:18 <boomerangfish> we got some stuff written in M (MUMPS) at my work ... hardly anyone knows how to code in it though
17:53:39 <mholub_> koninkje: sorry.. read about hscolour at hackage
17:53:44 <koninkje> mholub_: You can always grep through the output of hpaste or similar srvices
17:53:53 <orbitz> mholub_: check out the highlight program, it handles like everything
17:54:07 <BMeph> kc5tja: Just poking fun at your "homeland", heh-heh. :)
17:57:28 <kc5tja> BMeph: Well, it's hot enough to matter.  My thermometer is telling me it's close to 80 degrees here, and that's just plain too hot to spend even 15 minutes standing near a stove.
17:57:56 <kc5tja> Anyway...
17:58:17 <jmcarthur> boomerangfish: where in the southeastern us are you?
17:58:35 <jmcarthur> i'm in huntsville, al
17:58:48 <boomerangfish> charlotte, nc
17:58:59 <BMeph> jmcarthur: Ah, Rocketville, USA. :)
17:59:08 <jmcarthur> BMeph: yup
17:59:56 <jmcarthur> boomerangfish: cool, i was just checking. i still know of no other haskellers in my area
18:00:28 <boomerangfish> they had a open-source conference in columbia, sc today ... that's the one that had the session on functional languages
18:00:29 <jmcarthur> although both copies of rwh have been sold at a local barnes and noble
18:00:35 <ddarius> Admittedly out of context (though it's possible context wouldn't change much), but this figure seems to suggest the slower your language is the "higher level" it is. http://home.pacbell.net/ouster/scripting.anc.gif
18:01:41 <boomerangfish> ddarius: errr, depends on which you consider to be the dependent variable and which the independent variable
18:01:47 <jmcarthur> but ghc-haskell does let you get surprisingly close to the metal, yet i would still consider haskell to be very high level
18:02:04 <jmcarthur> higher level than the scripting languages on that graph, even
18:02:18 <boomerangfish> ie. "HL languages are slow" is different from "slow languages are HL"
18:03:29 <jmcarthur> i think the distinction between high level and low level is a bit blurry nowadays anyway
18:03:45 <Berengal> Being high on the "instructions per statement" scale doesn't neccessarily mean slow. It can also mean low LOCC.
18:04:30 <Berengal> (Also, calling C strongly typed is simply wrong)
18:04:32 <ddarius> Yes, but if I compiled Visual Basic say, it would require less instructions per statement and thus, by that graph, be "lower level" than it was at least.
18:04:32 <benmachine> hi, if I have a type signature that's pretty long, and an equally long list of functions to which it applies, how do I split it over several lines?
18:04:55 <ddarius> "Strong" means "static" in this context, I'm pretty sure.  C is definitely statically typed.
18:04:59 <Berengal> benmachine: Use a type synonym?
18:05:15 <benmachine> Berengal: that's a pretty good idea I guess
18:05:22 <boomerangfish> jmcarthur: "instructions per statement" definition as a measure of HL seems unambiguous to me
18:05:35 <benmachine> but if I'm doing foo, bar, baz, quux :: blah, can I split foo bar and baz over more than one line
18:05:36 <Berengal> ddarius: I see your point, but I could argue about that as well. C doesn't have types...
18:05:46 <Berengal> it just pretends it does
18:06:02 <benmachine> Berengal: well, a C type will determine the number of bytes allocated for it
18:06:38 <Berengal> benmachine: Yes, but not much more. You could also simply use a byte array...
18:06:46 <boomerangfish> I think of C as having static but loose typing ... that's why it relies so much on typecasting
18:06:48 <ddarius> If I have a language that has a lot of proof terms so that I can statically ensure various properties, but these terms don't lead to any executable code, will such a language potentially be even "lower level" than assembly?
18:06:58 <roconnor> int[]
18:07:00 <ddarius> Or a language like Virgil which optimizes for a very small footprint.
18:07:30 <benmachine> a language with less than one instruction per statement?
18:07:37 <ddarius> benmachine: Sure.
18:08:16 <Berengal> It doesn't take any instructions to allocate variables on the stack...
18:08:44 <boomerangfish> ddarius: so you're saying HL is fuzzy because some instructions are executed in the translation phase vs. the execution phase?
18:09:51 <ddarius> boomerangfish: No, I'm saying this definition of "high level" is silly.  I could, for example, make an arbitrarily "high" level language.
18:10:57 <boomerangfish> ddarius: true ... HL is a measure, and like any measure it can be intentionally subverted and abused
18:11:41 <ddarius> boomerangfish: It's not a matter of "subversion", it's a matter that this measure only tenuously correlates to the intuitive notion of "high level"
18:12:01 <benmachine> maybe high-level-ness is just about how much of your job is done by the compiler :P
18:12:08 <kerlo> Low-level languages expose all the quirks of whatever architecture you're writing for, and make the programmer figure out how to make it fast. High-level languages expose as few quirks of the architecture as possible, and have the compiler figure out how to make it fast.
18:12:08 <benmachine> (or the interpreter, or whatever)
18:12:17 <boomerangfish> I mean "High-Level" is only meant as a way to compare other more interesting properties like performance ... "high-level" shouldn't be automatically assumed as "better"
18:12:32 <kerlo> Also, the more features are arbitrarily left out, the more low-level it is.
18:13:01 <benmachine> kerlo: the more features that are arbitrarily introduced...?
18:13:52 <benmachine> ho hum.
18:14:13 <boomerangfish> the presentation I saw today had a slide that discusses "incidental complexity" vs "essential complexity" ... the presenter suggests that functional languages are better at eliminating incidental complexity
18:14:13 <benmachine> referential transparency and the en passant rule do not mix >_>
18:14:19 <Gracenotes> a difference between 'high-level' and 'low-level mess', maybe
18:15:02 <kerlo> Sure, introduce arbitrary features; just don't make people pay the consequences.
18:15:11 <kerlo> (What's the en passant rule?)
18:15:28 <boomerangfish> en passant?  you mean in chess?
18:15:45 <Gracenotes> it's not so much a rule as an.. optional optimization?
18:15:58 <kerlo> "Hey, it looks like we can implement Scheme-style callCC in Haskell, but if we include it in GHC, everyone's programs will run 10 times slower. I guess that's the price we have to pay."
18:16:00 <benmachine> boomerangfish: yeah, that one
18:16:46 <boomerangfish> talk about mixed metaphors
18:17:00 <benmachine> it's not a metaphor, it's just mildly non-sequitur
18:17:08 <ddarius> Scheme-style callCC will never be added to Haskell.
18:17:10 <benmachine> I'm coding a chess program and it's annoying me
18:17:32 <adityam> does anyone know how to install haxr?
18:17:34 <boomerangfish> benmachine: ahh OK
18:17:39 <benmachine> :P
18:17:49 <ddarius> cabal install haxr ?
18:18:00 <adityam> It lists dataenc=0.11 as a dependecy but arch linux gives me dataenc=0.12
18:18:02 <koninkje> anyone have a rundown of how Scheme-style callCC differs from Haskell's version?
18:18:52 <boomerangfish> benmachine: I suppose your point is that en passant is one of the few moves whose legality depends on knowing what the previous move was?
18:19:15 <benmachine> boomerangfish: yeah, and where which piece is captured depends on what is doing the capturing
18:19:31 <benmachine> well, where the piece to be captured is, rather
18:19:37 <adityam> cabal install haxr gives build errors
18:20:04 <boomerangfish> benmachine: it's the only move that captures a piece without occupying it's space, right?
18:20:09 <benmachine> yeah
18:20:43 <benmachine> it's just that my move function used to be a one-liner
18:20:45 <benmachine> and now I have
18:20:50 <benmachine> move b p q | enPassantHackIsNecessary b p q = enPassantHackMove b p q | otherwise = setSq (setSq b q $ getSq b p) p Empty
18:20:55 <benmachine> um, with newlines
18:21:16 <ddarius> koninkje: It doesn't.  The Cont monad just explicitly implements (part of) the semantics of Scheme.  I.e. Scheme has an implicit continuation monad everywhere.
18:21:37 <koninkje> ddarius: ew.
18:21:52 <koninkje> thx
18:22:04 <Berengal> Continuations are funky...
18:22:14 <koninkje> continuations rock
18:22:30 <Berengal> Continuations jazz?
18:22:58 * koninkje needs to download some of that
18:23:19 <boomerangfish> OK
18:23:22 <NEEDMOAR> Berengal: punk, for sure.
18:23:39 <Berengal> baroque punk-jazz, more like
18:23:47 <boomerangfish> Where can I find "The complete idiot's guide to monads"?
18:23:59 <ddarius> @google the complete idiot's guide to monads
18:23:59 <lambdabot> No Result Found.
18:24:06 <Berengal> Monads are like cars
18:24:14 <NEEDMOAR> Haha
18:24:19 * BMeph is hungry for a sandwich...
18:24:25 <Berengal> They have four wheels, an engine, exhause, run on fuel...
18:24:28 <ddarius> lambdabot's @google needs to be fixed.
18:24:31 <Berengal> exhaust*
18:24:47 <Gracenotes> it does I'm Feeling Luck at the moment, I'm guessing?
18:24:49 <Gracenotes> +y
18:25:00 <centrinia> Some cars have a wheel count that is not exactly four.
18:25:16 <jedai> @google haskell
18:25:17 <lambdabot> http://haskell.org/
18:25:18 <lambdabot> Title: Haskell - HaskellWiki
18:25:34 <Gracenotes> hmm... a bit of an unfortunate title for the Main Page? >_>
18:25:39 <BMeph> @google hoogle
18:25:41 <lambdabot> http://haskell.org/hoogle/
18:25:41 <lambdabot> Title: Hoogle
18:25:47 <NEEDMOAR> centrinia: some monads neither
18:25:48 <centrinia> @hoogle google
18:25:49 <lambdabot> Google rocks!
18:25:49 <lambdabot> package GoogleChart
18:25:54 <Gracenotes> @google hayoo
18:25:55 <lambdabot> No Result Found.
18:25:57 <Gracenotes> :[
18:26:02 <Gracenotes> Terrible! Google ranking.
18:26:06 <Berengal> Googlingg the complete idiot's guide to monads gave me: The Complete Idiot's Guide to the Gnostic Gospels
18:26:12 <centrinia> @hayoo hoogle
18:26:12 <lambdabot> Unknown command, try @list
18:26:28 <centrinia> Why isn't there an @hayoo command?
18:26:39 <ddarius> centrinia: Because you haven't implemented it yet.
18:26:40 <adamvo> @google hoogle
18:26:41 <lambdabot> http://haskell.org/hoogle/
18:26:41 <lambdabot> Title: Hoogle
18:26:54 <BMeph> @hoogle something
18:26:55 <lambdabot> Data.Generics.Schemes something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
18:27:14 <Gracenotes> There is not a @hayoo command because GHC.Any has not implemented it yet
18:29:45 <adamvo> Gracenotes: what's GHC.Any for?
18:31:04 <Gracenotes> when GHC can't use polymorphism, it seems
18:31:25 <Gracenotes> an easy way to get one: a <- return undefined
18:32:20 <adamvo> Gracenotes: so that a is monomorphic, right?
18:32:48 <Gracenotes> mm, forcing it
18:34:11 <Gracenotes> it is a constructor-less type, data Any a
18:34:32 <dolio> Any is a safe thing to unsafe coerce to, as I recall.
18:34:45 <dolio> With respect to garbage collection or something.
18:34:47 <jfredett> I wish there was a kind-level enum mechanism... So instead of doing data Foo; instance Show Foo where show _ = "Foo"; data Bar; etc, I could just to enum Foo | Bar | ... and do some kind of pattern matching on the types for a higher-level instancing of classes.
18:35:07 <jfredett> would make type-level programming a bit nicer, methinks.
18:36:14 <adityam> @pl f a b = (h a b) `func` (g a b)
18:36:14 <lambdabot> f = ap (ap . (func .) . h) g
18:37:32 <Gracenotes> adityam: liftM2.liftM2
18:37:48 <Gracenotes> with the ((->) r) instance
18:38:34 <adityam> Thanks Gracenotes
18:38:36 <Gracenotes> assuming by func you meant f
18:38:51 <adityam> No, func is a different function
18:39:13 <adityam> I do not have a recursive definition
18:39:16 <Gracenotes> oh, never mind, it's the name, not the argument.
18:40:15 <Gracenotes> so, yeah. Just pass func as the first argument
18:41:02 <Gracenotes> liftM2.liftM2 is like.. \f g h a b -> f (g a b) (h a b)
18:41:09 <Berengal> What's the best way to do GUI code in haskell these days?
18:41:32 <Berengal> gtk2hs seems decent, but not really better than any other language's guis...
18:42:29 <Gracenotes> in the same way that liftM2 is like \f g h a -> f (g a) (h a). for functions
18:43:00 <ddarius> @. djinn type liftM2 . liftM2
18:43:01 <lambdabot> Cannot parse command
18:43:21 <adityam> Gracenotes: just using liftM2 . liftM2 $ func g h gives a type error
18:43:31 <ddarius> :t liftM2 . liftM2
18:43:32 <lambdabot> forall (m :: * -> *) a1 a2 r (m1 :: * -> *). (Monad m1, Monad m) => (a1 -> a2 -> r) -> m (m1 a1) -> m (m1 a2) -> m (m1 r)
18:43:39 <Gracenotes> mm, $ isn't meant for multiarg functions
18:43:54 <Berengal> a $ b c means a (b c)
18:43:54 <Gracenotes> (liftM2 . liftM2) func g h.. works
18:44:03 <koninkje> Gracenotes: sure it is, you just need to use it for each argument
18:44:30 <ddarius> koninkje: That still wouldn't do the right thing.
18:44:42 <adityam> Thanks
18:45:05 <Berengal> koninkje: $ is right-associative. a $ b $ c = a $ (b $ c) = a (b c)
18:45:10 <Gracenotes> @djinn (a1 -> a2 -> r) -> (m -> m1 -> a1) -> (m -> m1 -> a2) -> (m -> m1 -> r)
18:45:11 <lambdabot> f a b c d e = a (b d e) (c d e)
18:46:12 <adamvo> Gracenotes, dolio: thanks for explaining Any
18:47:08 <Gracenotes> well. Can't say I know much about it, but I do know that if you encounter it, something is likely being done wrong
18:47:40 <adamvo> yeah, that part of it :)
18:51:36 <adityam> Is foldr1 union . map f == nub . concatMap f, and if so, which is more efficient?
18:52:09 <centrinia> :t union
18:52:10 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
18:53:13 <ddarius> > union [2] [2]
18:53:14 <lambdabot>   [2]
18:53:24 <ddarius> > union [1,2] [2,1]
18:53:26 <lambdabot>   [1,2]
18:53:41 <centrinia> > nub ([1,2] ++ [2,1])
18:53:43 <lambdabot>   [1,2]
18:53:46 <ddarius> > union [1,2] [2,1,2]
18:53:47 <lambdabot>   [1,2]
18:53:54 <centrinia> > nub ([1,2] ++ [2,1,2])
18:53:56 <lambdabot>   [1,2]
18:54:00 <dolio> > union [1,1] [1,1]
18:54:01 <lambdabot>   [1,1]
18:54:04 <Berengal> @check \l -> foldr1 union $ map (+5) l == nub . concatMap (+5) $ l
18:54:05 <lambdabot>   Couldn't match expected type `[a]'
18:54:51 <BMeph> Berengal: No need; check dolio's last. :)
18:55:05 <Gracenotes> @free union
18:55:06 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Eq a) => [a] -> [a] -> [a]\n"
18:55:51 <centrinia> > (\f x -> (foldr1 union . map f $ x,nub . concatMap f $ x)) (id,[])
18:55:53 <lambdabot>   Couldn't match expected type `a1 -> [a]'
18:56:11 <centrinia> > (\f x -> (foldr1 union . map f $ x,nub . concatMap f $ x)) id []
18:56:13 <lambdabot>   (* Exception: Prelude.foldr1: empty list
18:56:23 <centrinia> > (\f x -> ({- foldr1 union . map f $ x, -} nub . concatMap f $ x)) id []
18:56:25 <lambdabot>   []
18:56:34 <centrinia> Okay, they are different.
18:57:11 <adityam> Thanks centrina... so they behave differently on empty lists
18:57:29 <centrinia> > (\f x -> (foldr union [] . map f $ x, nub . concatMap f $ x)) id []
18:57:31 <lambdabot>   ([],[])
18:58:18 <adityam> So they don't :)
18:58:27 <BMeph> Does it irk anyone else here, that you can't specify the length of a list at creation, or *not* specify the length of an array?
18:58:46 <pshc> Where are your dependent types now?!
18:58:47 <adamvo> > cycle []
18:58:49 <lambdabot>   * Exception: Prelude.cycle: empty list
18:59:22 <Berengal> BMeph: No, it doesn't. To do so doesn't really make much sense to me...
18:59:23 <jmcarthur> BMeph: that seems to be against the purposes of both, no?
18:59:47 <jmcarthur> :t replicate -- regardless...
18:59:49 <lambdabot> forall a. Int -> a -> [a]
19:00:22 <Berengal> Although in prolog I've used length(10, List) to create a list of a given length...
19:01:39 <Berengal> Array lengths, however, never change, so they have to be specified before they're created. There's no way around that
19:01:44 <Gracenotes> that is unnatural! :o
19:02:17 <Berengal> Gracenotes: What is?
19:02:23 <Gracenotes> prolog >_>
19:02:56 <Berengal> prolog allows you to write O(2^n) algorithms in O(log n) lines
19:03:23 <Berengal> (for some rather subjective and stretched definition of O)
19:03:54 <BMeph> Berengal: What do you mean, "array lengths never change"? That seems to imply that list lengths do, which, "obviously", they don't. :)
19:05:55 <Berengal> BMeph: unsafeCons???
19:08:33 <BMeph> Berengal: What is that, Agda? ;)
19:21:50 <jeffwheeler> > "foo foo foo" =~ "foo" :: [String]
19:21:52 <lambdabot>   ["foo","foo","foo"]
19:22:11 <jeffwheeler> I can't get that locally; I always get a no instance defined; String works, but [String] doesn't for me.
19:22:44 <Tsion> :src (=~)
19:23:00 <jeffwheeler> @src (=~)
19:23:01 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:24:05 <jeffwheeler> Is there a clever way to do replacing?
19:25:23 <Gracenotes> splitting/intercalating?
19:25:31 <jeffwheeler> Hmm . . . :-/
19:27:34 <jeffwheeler> > subRegex "foo" "foo foo foo" "a+\1+b"
19:27:36 <lambdabot>   Not in scope: `subRegex'
19:28:00 <jeffwheeler> @hoogle subRegex
19:28:01 <lambdabot> No results found
19:28:15 <jeffwheeler> It seems to be in regex-compat, though.
19:32:38 <wli> Hm. How the heck is this doing it wrong.
19:32:59 <wli> The bug has to be somewhere in reduceStep.
19:33:52 <maurer> I'm having a hard time getting escaping right in string literals in haskell. I want a string literal that is "\d" (an actual backslash followed by a d), but "\d" gives a lexical error, and "\\d" gives two slashes.
19:34:15 <Cale> > length "\\d"
19:34:17 <lambdabot>   2
19:34:24 <Cale> It's not two slashes.
19:34:31 <maurer> Prelude> print "\\d"
19:34:31 <maurer> "\\d"
19:34:54 <idnar> I think you want putStrLn
19:35:12 <Cale> It just quotes the string when you apply show to it (or when it prints it), so it has to quote that backslash.
19:35:20 <mholub_> is function application in haskell left-associative? foldr step id xs z == ((((foldr step) id) xs) z) == (foldr step id xs) z?
19:35:36 <Cale> putStrLn indeed will print the string directly, unquoted.
19:35:38 <maurer> Cale: Oh, thanks, sorry for being so dense.
19:35:49 <Cale> mholub_: yes
19:36:21 <Cale> mholub_: But for some reason ($) is not, though I'd argue it should be
19:37:08 <mholub_> Cale, thanks, I know about low priority of $
19:37:27 <Cale> yeah, that's the important thing about $
19:37:59 <Cale> It'd be nice if it was left associative, because as it is, you can usually replace most of the ($)'s with (.)'s (all but the last)
19:38:17 <Cale> But if it was left associative, you could remove parens from more types of expressions.
19:40:41 <mholub_> I was confused by currying in haskell..  I try to understand foldl in terms of foldr now from RWH.. But now I understand
19:41:11 <roconnor> @src foldl
19:41:12 <lambdabot> foldl f z []     = z
19:41:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:45:54 <Gracenotes> mholub_: currying effectively means that (a b) c is the same as a b c, and x -> (y -> z) is the same as x -> y -> z
19:46:16 <roconnor> Gracenotes: um...
19:46:20 <roconnor> not really
19:46:38 <Gracenotes> :o wat did I slip upopn
19:46:46 <roconnor> @type curry
19:46:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
19:47:16 <Gracenotes> hm? I mean in the partial application sense
19:47:26 <mholub_> I saw a function of three arguments and forgot that in haskell all functions are really functions of one argument... so function of three arguments is the function of two arguments that returns one argument-function
19:47:28 <roconnor> currying is about changing functions that take a pair (or more) of arguments into functions (of one argument) that return functions
19:47:38 <Gracenotes> roconnor: in a mathematical sense, yes
19:48:39 <Gracenotes> I thought it was also used to refer to partial application. But, partial application it what I meant.
19:49:35 <Gracenotes> the trick with the foldl-in-terms-of-foldr is that, whereas the accumulator in a fold is often something simple like an integer, it's a function in this case
19:49:37 <mholub_> I thought that partial application and currying are the same things
19:50:52 <jeffwheeler> @src (=~) [String]
19:50:53 <lambdabot> Source not found. You speak an infinite deal of nothing
19:51:00 <mholub_> ah... I see... roconnor meaned curry function
19:51:11 <Berengal> In a sense they are the same... you can't partially apply arguments when all functions only take one
19:51:14 <idnar> currying is a way of implementing partial application
19:51:40 <jeffwheeler> @src (=~) (RegexContext Text.Regex.TDFA.Regex [Char] [String]
19:51:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:51:53 <jeffwheeler> @src (=~) (RegexContext Text.Regex.TDFA.Regex [Char] [String])
19:51:54 <lambdabot> Source not found. Just try something else.
19:52:02 <jeffwheeler> Hmm. It obviously exists . . .
19:52:03 <Gracenotes> jeffwheeler: probably not in the source library
19:52:16 <idnar> jeffwheeler: @src just looks stuff up in a text file
19:52:21 <Gracenotes> that lambdabot uses. It's a hand-written file for all the source declarations
19:52:22 <idnar> (basically)
19:52:25 <jeffwheeler> Ah, I see.
19:52:38 <jeffwheeler> Hmm; well, I can't seem to find where it's defined, anyways.
19:52:50 <jeffwheeler> Somehow lambdabot has the definition, as do most tutorials, but I don't.
19:53:12 <Tsion> @hoogle (=~)
19:53:13 <lambdabot> No results found
19:54:10 <Gracenotes> jeffwheeler: if you have it in ghci, try doing :i Regex
19:54:26 <Gracenotes> it mentions in which modules the instances are defined
19:54:44 <Gracenotes> and then look at the source code, available from hackage
19:55:03 <ddarius> http://lambda-the-ultimate.org/node/2266#comment-33620 (partial application v. currying)
19:55:04 <Gracenotes> or in GHC if builtin
19:55:19 <Berengal> http://hackage.haskell.org/packages/archive/regex-posix/0.94.1/doc/html/src/Text-Regex-Posix-Wrap.html#%3D~
19:55:58 <jeffwheeler> As I said earlier, it's only certain instances that are missing for me. String and Bool work fine.
19:56:30 <Gracenotes> oh! Yeah.
19:57:30 <Gracenotes> it's mentioned in the comments here.. http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html#id617251
19:57:57 <Gracenotes> if I think it's the same problem you're thinking of
19:58:04 <jeffwheeler> And the code seems to spit out the exact same error I'm having.
19:58:25 <jeffwheeler> Under this paragraph: "Another valid type of result is 	[String], which returns a list of 	all matching strings."
20:01:50 <jeffwheeler> I suppose RWH automatically compiles all the src code, which is why the error is included in the text?
20:02:16 <jeffwheeler> The text seems to say it's fine, and then the example right below it has a big error.
20:02:41 <Berengal> jeffwheeler: I've seen that several places in RWH
20:02:43 <Gracenotes> I suppose it's a .lhs file. Dunno though.
20:04:51 <Gracenotes> hm... is the engineering library closed or not...
20:05:19 <cYmen> I have a question about http://www.haskell.org/tutorial/arrays.html. I tried to remove the bnds parameter and use maxmimum and minimum instead but then I get a stack overflow sooner. Why is that?
20:05:21 <Gracenotes> .. closed at 6. ;_;
20:05:41 <cYmen> Oh, damn. I am talking about the hist function explaining accumulative arrays.
20:08:55 <Gracenotes> cYmen: you mean, you used (minimum, maximum) in its place?
20:11:14 <cYmen> Gracenotes: (minimum is, maximum is) instead of bnds in the accumArray call and removed the parameter yes.
20:13:46 <Gracenotes> mm. Have you checked the type of the new function?
20:14:19 <Gracenotes> it is meaningful for an array to have bounds like ((0, 0), (10, 10))
20:14:33 <Gracenotes> that creates an 11-by-11 (121 element total) array with multidimensional-like-indexing
20:16:21 <Gracenotes> oh, hm, actually it won't make a difference, will it. :(
20:16:43 <Berengal> Gracenotes: no, it won't.
20:16:52 <cYmen> I don't know I'm new to haskell. :)
20:16:57 <Berengal> cYmen: Can you give an example of it failing?
20:17:15 <Berengal> @paste
20:17:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:17:21 <Gracenotes> not sure about the overflow though. adieu.
20:17:51 <Gracenotes> >_<
20:18:02 <cYmen> Berengal: I used the rollNDice function from the tutorial on monads. I'll paste.
20:18:24 <Berengal> Oh dear...
20:18:31 <cYmen> ? :)
20:18:53 <Berengal> That could return widely spaced apart minimum and maximum bounds
20:19:14 <Berengal> > (minBound, maxBound) :: (Int, Int)
20:19:15 <lambdabot>   (-9223372036854775808,9223372036854775807)
20:19:36 <Gracenotes> , (minBound, maxBound) :: (Int, Int)
20:19:37 <lunabot>  (-2147483648,2147483647)
20:20:13 <cYmen> But I the array contains only values 1-6 :)
20:20:13 <roconnor> > minBound + maxBound
20:20:15 <lambdabot>   Add a type signature
20:21:14 <Berengal> Oh, right... roll dice
20:21:18 <Berengal> how long is it?
20:21:41 <Berengal> It could be building up a huge thunk...
20:22:27 * Apocalisp is building up a huge thunk as well. Going to be an interesting morning after me tea.
20:22:48 <roconnor> Apocalisp: huh?
20:23:26 <Apocalisp> You know, one of those that goes "thunk!" as it goes. I tell you, when that one gets into the channel, it will be a danger to shipping.
20:23:35 <cYmen> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3906#a3906
20:23:54 <cYmen> So that's what happens. :)
20:24:13 <gwern> Apocalisp: oh, I thought you were makign a bladder joke
20:24:33 * gwern builds up a thunk drinking tea at the computer, if yaknowhatimean
20:24:37 <Apocalisp> sorry, slaphappy
20:25:17 <Berengal> have you tried "minimum (rollNDice 1000000 (mkStdGen 23425))" ?
20:25:37 <cYmen> No...
20:25:52 <Berengal> In ghci I mean
20:25:54 <Berengal> Directly
20:26:01 <cYmen> stack overflow
20:26:06 <Berengal> Right
20:26:34 <cYmen> How does that happen?
20:27:48 <wli> Somehow the syzygy polynomials are coming out wrong.
20:29:24 <Berengal> cYmen: What if you let minimum xs = foldl' min maxBound xs?
20:30:13 <Berengal> (You might have to import Data.List for foldl', I forget...)
20:30:42 <cYmen> Berengal: hm...I'll try
20:30:47 <gwern> @hoogle fold'
20:30:47 <lambdabot> No results found
20:30:53 <gwern> @hoogle foldl'
20:30:54 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
20:30:54 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
20:30:54 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
20:31:17 <c_wraith> For that particular case, I'd use foldl1'
20:31:33 <Berengal> c_wraith: Doesn't work for empty lists...
20:31:49 <c_wraith> Oh, that's true.
20:32:04 <Berengal> c_wraith: On the other hand, my definition doesn't work for unbounded types...
20:32:32 <cYmen> I don't think I know enough haskell to make that work. :)
20:33:03 <Berengal> cYmen: Just create a new function "myMinimum" and use that instead of minimum
20:33:19 <wli> Ah, it's the code to divide monomials in the syzygy and reduction code.
20:34:13 <Berengal> cYmen: First just see if that works for the simple "minimum (rollNDice ..." in ghci
20:34:26 <Berengal> If it does we'll have to implement maximum as well :)
20:35:18 <wli> Maybe not.
20:35:49 <cYmen> It does.
20:36:08 <cYmen> I'll have to read the definition of foldl. :)
20:36:11 <Berengal> cYmen: Cool, now try to implement myMaximum as well.
20:36:20 <Berengal> foldl is lazy. foldl' is strict
20:36:49 <Berengal> What this means is that foldl builds up lots of recursive calls, and when you try to evaluate them they overflow the stack
20:37:10 <Axman6> :t scanr
20:37:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
20:37:24 <Berengal> foldl' on the other hand evaluates the calls as is goes, and is in essence a simple loop
20:38:05 <wli> There are a couple of different problems, one of which can only come from spol; it looks like somehow something that should always come out as an integer is not, and the spol is coming out wrong in other cases, too.
20:38:23 <cYmen> Berengal: I thought lazy means that it's not evaluated unless necessary?
20:39:07 <Berengal> cYmen: Yes, which in the case of foldl means it'll have a large bunch of unevaluated calls that blow up the stack when they're finally needed
20:40:25 <Berengal> ?src foldl
20:40:25 <lambdabot> foldl f z []     = z
20:40:25 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:41:38 <cYmen> ?src foldl'
20:41:38 <lambdabot> foldl' f a []     = a
20:41:38 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:41:45 <Berengal> cYmen: The "(f z x)" part of the function isn't evaluated, which means it'll build up to "f(f(f(f(f(f(f(f(..."
20:42:08 <Berengal> cYmen: That list of calls isn't tail-recursive, and is what blows up the stack
20:42:26 <Cale> foldl itself is tail recursive
20:42:36 <cYmen> Wow. ok...
20:42:40 <Cale> So that expression is built up using a nice tight loop
20:42:55 <Cale> But the expression ends up being huge by the end, and that's what kills the stack
20:43:14 <Berengal> Indeed
20:43:37 <Cale> (searching through that expression for a reducible subexpression)
20:43:40 <Berengal> foldl' solves that problem by forcing "f z x" in each loop though
20:43:49 <cYmen> I thought tail recursion is optimized so it will exactly not do that?
20:44:06 <cYmen> Nevermind I don't know enough to actually discuss this ;)
20:44:08 <Cale> I think it helps to see exactly what the steps are
20:44:16 <Cale> Lazy evaluation is outermost first
20:44:19 <Cale> So:
20:44:24 <Cale> foldl (+) 0 [1,2,3]
20:44:33 <Cale> -> foldl (+) (0 + 1) [2,3]
20:44:38 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
20:44:44 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
20:44:52 <Cale> -> ((0 + 1) + 2) + 3
20:45:04 <cYmen> ok
20:45:27 <Berengal> At that point foldl is done, but it still has to reduce the result
20:45:35 <Cale> So it builds up an expression. Now, the outermost reducible subexpression of that is the 0 + 1
20:45:37 <Berengal> And that expression is not tail-recursive...
20:45:57 <Cale> I don't think it makes sense to say if the expression is tail recursive or not.
20:46:07 <Cale> It's... just an expression.
20:46:14 <Berengal> Cale: You're right... at this point it doesn't really
20:46:56 <Cale> So at this point, in order to search through that expression and find the (0 + 1), it has to push some things on the stack
20:47:01 <Cale> (...) + 3
20:47:05 <Cale> (...) + 2
20:47:38 <Cale> and then it gets to the (0 + 1) which it can properly evaluate
20:47:53 <Cale> But if the expression was very large, we'd run out of stack before finding it.
20:48:06 <cYmen> Ok, that makes sense.
20:48:29 <Berengal> ?src minimum
20:48:29 <lambdabot> minimum [] = undefined
20:48:29 <lambdabot> minimum xs = foldl1 min xs
20:48:34 <cYmen> Thanks for explanation.
20:48:39 <cYmen> *the
20:48:52 <Berengal> minimum uses the lazy foldl
20:49:20 <Cale> Of course, that doesn't always happen. If, for some strange reason (+) was defined differently, and (...) + 3 could be evaluated without needing to know what the (...) was, then it wouldn't need the stack.
20:49:32 <Cale> This happens with reverse.
20:50:08 <wli> all short circuits
20:50:39 <Cale> reverse = foldl (flip (:)) []
20:50:42 <wli> any, too
20:50:46 <Cale> yeah
20:50:50 <Berengal> Anywayl, most of the time you want either foldl' or foldr
20:50:55 <Cale> right.
20:50:56 <Berengal> Anyway*
20:51:01 <Berengal> ?src any
20:51:01 <lambdabot> any p =  or . map p
20:51:06 <Cale> ?src or
20:51:07 <lambdabot> or    =  foldr (||) False
20:51:14 <Cale> foldr is actually more appropriate there
20:51:25 <Berengal> Most short circuiting folds are foldrs
20:51:54 <adamvo> Berengal: which are foldls?
20:52:07 <Berengal> ?src reverse
20:52:07 <lambdabot> reverse = foldl (flip (:)) []
20:52:15 <Berengal> No wait..
20:52:18 <Berengal> :/
20:52:29 * Berengal needs more coffee, obviously
20:52:38 <Thomas2> well, this is interesting
20:52:58 <Thomas2> running my code in ghc rather than ghci saved a *lot* of time
20:53:14 <Thomas2> and then switching on -O made it a *lot* slower again
20:53:28 <Axman6> sounds normal to me
20:54:21 <Berengal> cYmen: Anyway, did you manage to write the myMaximum function as well?
20:54:23 <Thomas2> as in 10 times slows
20:54:33 <Thomas2> guh, slower
20:55:09 <cYmen> Berengal: myMaximum xs = foldl' max minBound xs
20:55:34 <Berengal> cYmen: Right, so just use those instead of minimum and maximum in your hist2 function, and it should work now
20:55:35 <cYmen> text substitution :)
20:56:07 <cYmen> Berengal: Could you give me an example how I would do it with let?
20:56:12 <Thomas2> maybe it optimised out my function f :: () -> a which i used to stop it memoising
20:58:18 <wli> http://wli.pastebin.com/m54263c27 <-- still debugging :(
20:59:10 <Berengal> cYmen: If you only want them defined in the function itself, I'd use a where...
20:59:29 <Berengal> cYmen: Or it's simply "let <functions> in <expression>"
21:00:07 <cYmen> Ah, ok.
21:00:10 <cYmen> Thanks again!
21:00:14 <Berengal> :)
21:00:54 <malouin> If I can't figure out how to match a ReaderT Foo IO against IO string, where do I go for enlightenment?
21:01:24 <wli> runReaderT
21:02:43 <Axman6> Thomas2: to stop it memoising? o.O
21:02:52 <cYmen> Berengal: Another one: How do I redefine the a in hist2 :: (Ix a... so it will be "bounded"? Because I am using max-/minBound on it in myMin/-Max
21:03:33 <Berengal> (Ix a, Bounded a, Integral b) => ...
21:03:51 <Berengal> Or just delete the type signature and ask ghci :)
21:05:08 <Berengal> cYmen: Alternatively you could use different definitions of minimum and maximum that don't rely on {min,max}Bound
21:05:26 <cYmen> Ok, let me try...
21:05:58 <cYmen> myMinimum xs = (x:xs) foldl' min x xs?
21:06:06 <cYmen> bla
21:06:12 <Berengal> Err... no
21:06:15 <Berengal> ?src minimum
21:06:16 <lambdabot> minimum [] = undefined
21:06:16 <lambdabot> minimum xs = foldl1 min xs
21:06:22 <cYmen> myMinimum (x:xs) = foldl' min x xs?
21:06:25 <cYmen> that's what I meant
21:06:29 <Berengal> hint: the strict version of foldl1 is called foldl1'
21:06:38 <Berengal> Or that one :)
21:06:50 <cYmen> What did you mean?
21:07:07 <Berengal> The one you supplied works fine
21:07:09 <kerlo> How is "memoizing" pronounced?
21:07:22 <Berengal> kerlo: like memorizing without the r
21:07:35 <malouin> wli: great, thanks.
21:07:45 <cYmen> Probably like memoirs...frenchish ;)
21:08:32 <kerlo> cYmen: I'm going to assume that Berengal's right, since you said "probably" and e didn't.
21:09:01 <kerlo> Sounds like an Elmer Fudd version of "memorizing", or "memowizing".
21:09:22 <cYmen> I'm going to go back trying to figure out what monads are. :)
21:09:32 <kerlo> Using fancy diacritics, "mmzng".
21:10:52 <dolio> Using fancy diacritics, you can turn all the vowels into spaces.
21:11:46 <Berengal> Monads are like cars...
21:11:58 <ray> monads are like diacritics
21:12:12 <Berengal> diacritics are like analogies
21:12:38 <cYmen> You guys are like mad.
21:13:05 <kerlo> Monads are like cars, so I herd you like them, so I put one in one so... eh.
21:13:18 <Berengal> kerlo: instance Monad Monad?
21:13:48 <Gracenotes> what's with all the analogy talk lately!!
21:13:55 <roconnor> Yo dawg, I heard you like Monads, so I put a Monad in your Monad so that you can Monad while you ... hey why is there still only one?
21:14:34 <kerlo> (>>>==) :: (Monad n, Monad m) => n (m a) -> (a -> n (m b)) -> n (m b)
21:15:06 <Berengal> > let recurse = "recurse while you " ++ recurse in "Yo dawg, I herd you like recursion so I put a recursion in your recursion so you can " ++ recurse
21:15:07 <lambdabot>   "Yo dawg, I herd you like recursion so I put a recursion in your recursion ...
21:15:12 <kerlo> Hey, it might even exist. But it probably doesn't.
21:16:05 <kerlo> "Yo dawg, I herd you like this joke, so I put this joke in this joke while you can recurse while you recurse."
21:17:39 <Berengal> monads are like yo dawg
21:22:28 <Gracenotes> kerlo: I think you'd need some way to go n (m a) -> n a
21:23:50 <tehcheat4> hey
21:24:26 <roconnor> hey
21:24:43 <tehcheat4> I was wondering if I could get some help with a problem
21:24:54 <roconnor> homework?
21:24:58 <tehcheat4> yeah
21:25:08 <tehcheat4> just can't understand this error
21:25:15 <roconnor> :)
21:25:17 <roconnor>  a common problem
21:25:24 <roconnor> @paste
21:25:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:25:56 <tehcheat4> how does that work exactly?
21:26:13 <roconnor> you click there and paste your text
21:26:27 <roconnor> then sumbit and paste the link here
21:26:32 <tehcheat4> ah
21:26:34 <roconnor> In this case paste your code and error
21:26:34 <tehcheat4> I see
21:31:48 <tehcheat4> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3909#a3909
21:31:52 <tehcheat4> there is my problem
21:33:53 <Berengal> tehcheat4: Try adding a type signature to your function
21:37:35 <tehcheat4> yep, that fixed it, thanks!
21:40:28 <Gracenotes> :o
21:41:06 <Berengal> Gracenotes: what?
21:43:09 <ManateeLazyCat> When i compile my program, i got error "Module imports form a cycle for modules:", looks i have two module `import` each other, how to fix this problem? Thanks!
21:43:18 <pumpkin> .hs-boot
21:43:33 <ddarius> They do Haskell at the University of Texas?
21:43:40 <tehcheat4> yeah
21:43:46 <pumpkin> nice
21:43:51 <NEEDMOAR> Well done!
21:44:05 <ray> it's all haskell all the time at the university of ray's apartment
21:44:11 <tehcheat4> haha
21:44:29 <Berengal> ray: I know what that's like
21:44:38 <pumpkin> I'd like that
21:45:03 <thoughtpolice> yay
21:45:06 <ray> it's not all that great since cup ramen is an unimaginable luxury for me
21:45:33 <Berengal> sadly, my real university is all like "java java java java java java java java PROLOG PROLOG java java java java java java java java PROLOG PROLOG... SML!"
21:45:34 <pumpkin> thoughtpolice: no developments in my 6.6 64-bit stuff, been cramming a paper up until yesterday :)
21:45:41 <Berengal> (sung to the badgers song)
21:45:43 <pumpkin> Berengal: lol
21:45:46 <tehcheat4> they do a lot of java here
21:46:00 <thoughtpolice> pumpkin: I just got a copy of 6.6.1 working on os x intel
21:46:10 <pumpkin> thoughtpolice: ooh nice!
21:46:12 <pumpkin> 64-bit then?
21:46:13 <tehcheat4> haskell is probably only half of this course, the rest is done in java
21:46:23 <ray> ah
21:46:25 <ray> bait and switch
21:46:26 <thoughtpolice> pumpkin: no, but i might be able to hack it into 64-bit state
21:46:28 <Berengal> Java is painful...
21:46:34 <pumpkin> thoughtpolice: oh :(
21:46:38 <ddarius> They should switch to C#
21:47:16 <Berengal> I learned all there was to java in two weeks...
21:47:22 <tehcheat4> the head of the department is teaching the basic logic class with LISP
21:47:22 <Berengal> (The language, not the programming that is)
21:47:31 <Berengal> Haskell... I still don't know everything about
21:47:34 <tehcheat4> well, ACL2
21:47:44 <Berengal> Mostly because of the extensions
21:47:49 <Thomas2> is there anything like a hashtable for haskell?
21:47:52 <thoughtpolice> pumpkin: I may be able to work something out with the HEAD branch
21:47:59 <Berengal> tehcheat4: lisp is decent
21:48:02 <pumpkin> thoughtpolice: it'd be nice if that git mirror on github were possible to compile, so we could work on our changes to it through there
21:48:02 <thoughtpolice> pumpkin: the new build system should be coming in shortly, which might help
21:48:09 <thoughtpolice> pumpkin: yes :)
21:48:09 <pumpkin> thoughtpolice: yeah, I was going to wait
21:48:20 <wahjava> Thomas2: No Hashtable AFAIK, use Data.Map
21:48:26 <ddarius> @hoogle HashTable
21:48:26 <lambdabot> module Data.HashTable
21:48:27 <lambdabot> Data.HashTable data HashTable key val
21:48:36 <tehcheat4> Berengal: I like that I don't get lost in parenthesis in Haskell
21:48:42 <pumpkin> there is a hashtable, use Data.Map anyway
21:48:46 <Berengal> tehcheat4: learn emacs :)
21:48:53 <wahjava> oops, sorry Thomas2 I didn't know of that
21:49:08 <p_l> tehcheat4: what parentheses? Where? I don't see any ;-)
21:49:29 <thoughtpolice> pumpkin: anyway, the deal with the current HEAD is that you can configure it to build x86_64-apple-darwin, but the runtime it seems isn't compiled as 64-bit by gcc
21:49:35 <Thomas2> why would you use data.map anyway?
21:49:46 <pumpkin> thoughtpolice: yeah, I originally started working on HEAD
21:49:47 <Berengal> "You see only a heap of parenthesises... me? I see conses, nils..."
21:49:59 <thoughtpolice> pumpkin: it fails on Adjustor.c because the runtime needs to be split up to support 64-bit and OS X, but there's a flag so you can just use libffi for adjustors, which I did
21:49:59 <pumpkin> thoughtpolice: I made some changes and got somewhere, but can't remember where
21:50:04 <tehcheat4> haha
21:50:06 <ddarius> Berengal: A heap of conses is hardly better.
21:50:10 <thoughtpolice> then it turned out there is code in the RTS that references registers directly
21:50:22 <Berengal> ddarius: They are if they're represented by whitespace...
21:50:31 <pumpkin> thoughtpolice: oh yeah, I remember messing with that
21:50:49 <thoughtpolice> i.e. in the case of x86_64 it will use r8..rn and rbx etc.
21:50:54 <ddarius> Berengal: I want to see trees, lists, pairs, records, not just a pile of conses.
21:51:03 <thoughtpolice> so with using libffi for adjustors you can get pretty far on a stage1
21:51:09 <pumpkin> cool
21:51:14 <tehcheat4> another professor tried to push lisp on students by giving them the option of lisp or a horrible java lisp
21:51:22 <pumpkin> clojure?
21:51:30 <pumpkin> ;)
21:51:36 <Berengal> ddarius: The visual translators are working for the machines anyway
21:52:03 <thoughtpolice> pumpkin: there may just be some config somewhere in the build system blocking the compiler flag to go with a 64-bit build
21:52:18 <thoughtpolice> pumpkin: i'll try again and with the new build system and see if I can get anything working
21:52:30 <pumpkin> where does the new system live right now?
21:53:17 <Berengal> Whitespaces are the most important characters in a language. In haskell, space represents function application. In lisp, cons...
21:53:40 <Berengal> In java... nothing, basically...
21:53:47 <pumpkin> let = 5
21:53:48 <thoughtpolice> pumpkin: can't remember; look it up on g-h-u
21:54:01 <pumpkin> that's applying the let function to the = function and 5
21:54:02 <pumpkin> !!!!
21:54:38 <ray> > let let = 5 in let
21:54:40 <lambdabot>   <no location info>: parse error on input `='
21:54:52 <pumpkin> > let in text "hullo"
21:54:53 <lambdabot>   hullo
21:55:06 <Berengal> :t text
21:55:08 <lambdabot> String -> Doc
21:55:15 <Berengal> ?index text
21:55:15 <lambdabot> Graphics.HGL.Draw.Text, Graphics.HGL.Draw, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.Html, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
21:55:16 <idnar> > let in 5
21:55:18 <lambdabot>   5
21:55:21 <ray> > let me out of here
21:55:22 <lambdabot>   <no location info>: parse error on input `of'
21:55:52 <pumpkin> anyone here worked on graphical models in haskell?
21:56:47 <Berengal> > let away = 5; go = (+5) in case () of emergency -> go away
21:56:48 <lambdabot>   10
22:00:16 <pumpkin> thoughtpolice: oh yeah, more people CCing themselves on the bug
22:00:22 <pumpkin> *ticket
22:00:23 <pumpkin> :P
22:04:46 <roconnor> graphical models?
22:05:25 <pumpkin> http://en.wikipedia.org/wiki/Graphical_model
22:06:33 <ray> good god, did haskell.org just change its logo to be some kind of unholy combination of >>= and lambda?
22:06:43 <ray> or did i end up on the wrong wiki again
22:07:01 <pumpkin> it did
22:07:07 <Berengal> Awesome, the new logo is in place
22:07:12 <Zao> ray: They had some ninja competition.
22:07:26 <Zao> It was over before I got around voting :P
22:08:14 <inimino> it took months
22:09:14 <roconnor> pumpkin: that is totally not what I was thinking.
22:09:18 <pumpkin> :)
22:09:36 <pumpkin> conditional random fields and the like
22:11:24 <pumpkin> trying to figure out if there's a nice way to represent belief propagation functionally
22:11:33 <pumpkin> since it seems quite stateful at first glance
22:12:23 <enolan> http://gist.github.com/97930 Is there some simple way to auto-generate those get* functions?
22:14:50 <Gracenotes> enolan: there is.. but it fails via exception if the constructor is not matched, instead of doing a Maybe thing.
22:15:07 <Gracenotes> record syntax.
22:15:47 <Gracenotes> enolan: usually constructor-matching is just embedded in code, afaik
22:16:08 <Gracenotes> since, even in this case, you still have to deal with both cases of Maybe
22:16:39 <pumpkin> you could move the things that deal with particular instances of that constructor to a typeclass and split those constructors up into types, making them instances of the typeclass
22:16:49 <pumpkin> but that may not be possible in your case
22:17:19 <pumpkin> then you could have some sort of existential wrapper if you needed to pass them around without knowing which was which
22:17:53 <Gracenotes> o_o
22:18:47 <pumpkin> lol
22:22:06 <Thomas2> ugh, this is odd
22:22:26 <Thomas2> import Data.Map and get undefined references e.g. to containerszm0zi2zi0zi0_DataziMap_lookup_closure
22:22:50 <pumpkin> --make
22:22:56 <pumpkin> pass that to ghc when building
22:23:09 <pumpkin> that really needs to be a default :P
22:23:14 <Thomas2> ok, but ... why?
22:24:00 <Thomas2> and yeah, that seems to have fixed it
22:25:12 <Gracenotes> argh. How hard is it to make a functional window in OpenGL?
22:25:19 <Gracenotes> functional in the sense of functioning!!
22:27:04 <Thomas2> hmm, Data.Map is too slow as well
22:27:54 <pumpkin> what are your keys?
22:28:06 <pumpkin> Data.IntMap tends to be faster
22:28:06 <Gracenotes> on the counter
22:29:10 <pumpkin> Thomas2: you compiling with -O2?
22:30:33 <Zao> Gracenotes: Not that horribly hard with GLFW or GLUT.
22:31:13 <Gracenotes> Zao: there is no titlebar, and apparently no way to get one.
22:31:44 <Zao> Gracenotes: Which platform are you on, and can you paste your code
22:32:12 <Gracenotes> I'm trying to adapt code from here: http://www.haskell.org/haskellwiki/OpenGLTutorial1#Using_the_drawing_canvas
22:32:50 <Cale> Thomas2: In general, I've found Data.Map to have very practical performance. What sort of thing are you using it for?
22:33:22 <Gracenotes> it would be nice to have a titlebar so I don't have to kill ghci to kill the window.
22:33:35 <Zao> Gracenotes: Which platform are you on?
22:33:49 <Gracenotes> Ubuntu 8.04.
22:34:02 <Zao> Using some silly WM?
22:34:03 <Gracenotes> ..if that's enough info for the platform
22:34:11 <Thomas2> yeah, this is a bit of a special case
22:34:43 <Thomas2> i'm solving project euler problems
22:34:50 <Thomas2> i need to test whether an integer is a square
22:34:55 <Gracenotes> Zao: using the default
22:34:58 <Thomas2> it's (just) bigger than int32 range
22:35:02 <Zao> So Gnome then?
22:35:02 <Cale> Thomas2: Okay. There are decent ways of doing that.
22:35:05 <Gracenotes> yeah
22:35:12 * Zao restarts to try.
22:35:14 <Thomas2> but that's only about 150000 squares, so i thought i'd try just checking membership
22:35:25 <Cale> Thomas2: Use binary partitioning.
22:35:45 <Cale> Thomas2: That way you do O(log n) rather than O(sqrt n) tests :)
22:36:07 <Gracenotes> maybe I should use SDL
22:36:13 <Thomas2> Cale: just checking membership in a Data.Map is O(log (sqrt n))
22:36:22 <Cale> Thomas2: Well, okay.
22:36:38 <Cale> Thomas2: If you can afford to build the map :)
22:36:44 <Thomas2> that's not too bad
22:36:54 <Gracenotes> not sure if it'd be any better. I previously used gtk2hs
22:37:03 <Thomas2> I think, I haven't really checked
22:37:18 <Thomas2> anyway I need to throw 200,000,000 elements at it, so it should amortize pretty well
22:37:20 <Gracenotes> which is nice, but afaia doesn't have much pixel-drawing support beyond Cairo.
22:38:11 <pumpkin> 200 million elements into a Data.Map?
22:38:12 <Cale> Thomas2: okay :)
22:38:16 <pumpkin> that sounds like it'll be heavy :)
22:38:25 <Cale> pumpkin: 200 million lookups
22:38:27 <pumpkin> oh
22:38:29 <Thomas2> no, I need to test 200,000,000 elements for membership
22:38:33 <pumpkin> I saw at as in :P
22:38:34 <pumpkin> whoops :)
22:38:42 <Thomas2> which will take ~10 minutes
22:38:44 <Cale> Thomas2: Are you compiling with -O2 ?
22:38:50 <Cale> (Just a silly question :)
22:38:58 <pumpkin> you're probably doing the euler problem wrong if you're doing 200 million tests :P
22:38:59 <Thomas2> that saved me 3 secs off 45 :-)
22:39:16 <Cale> What is the problem?
22:39:20 <Thomas2> #143
22:39:36 <Thomas2> it stumped a friend of mine so I thought I'd give it a go
22:39:41 * Cale 
22:39:53 <pumpkin> :o
22:39:56 <Thomas2> http://projecteuler.net/index.php?section=problems&id=143
22:40:15 <pumpkin> 
22:40:17 <Thomas2> wait, what? wrong number
22:41:08 <Thomas2> erm, no, that's the right one.
22:41:21 <Zao> Torricelli triangles?
22:41:28 <Thomas2> sorry. it turns out, of course, that the geometric problem reduces to a diophantine equation if you use the cosine rule
22:41:31 <pumpkin> 
22:41:38 <Thomas2> b^2 = p^2 + q^2 + pq
22:41:47 <Zao> pumpkin: You seem to be emitting moonspeak.
22:41:53 <Thomas2> which you have to solve for integers < 110000
22:41:53 <pumpkin> I am :)
22:42:43 <Thomas2> ok, next way out there option is learning to use unboxed boolean arrays
22:43:00 <Cale> Zao: It's just random nonsense hiragana :) (the outdated ones interspersed with small versions of the vowels)
22:43:07 <pumpkin> yup :)
22:43:20 <Gracenotes> argh!! maybe I can use GDK..
22:43:36 <pumpkin> Cale: you forgot the random nonsense katakana too
22:43:41 <Cale> oh, yes
22:44:30 <Cale> Thomas2: hmm. I suppose that would likely be even faster.
22:44:59 <Thomas2> Cale: well, much too big for Int32-ish range, but I have another idea
22:45:15 <sw1sh> what tilda is for: i.e. mapPair ~(f,g) ~(x,y) = (f x, g y) ?
22:45:15 <Thomas2> actually, wait, if I used gigs of memory I might cover it all
22:45:18 <Cale> Thomas2: what?
22:45:31 <Gracenotes> why do you need to have all the data in memory at the same time?
22:45:37 <dolio> > let f ~(x,y) = 5 in f undefined
22:45:38 <lambdabot>   5
22:45:41 <Cale> sw1sh: It means that the parameter isn't evaluated unless one of the variables is actually used.
22:46:12 <sw1sh> thanks
22:46:41 <Thomas2> p^2 + q^2 + pq a square where p, q < 110000. the total can get to just over 2 ^ 32
22:47:06 <Cale> sw1sh: Normally when a function pattern matches against a constructor, the parameter actually gets evaluated to determine if the pattern matches or not -- in the case of pairs, you know that it'll match if it turns out to be anything at all, so it's safe to defer that evaluation with ~
22:47:34 <Cale> Thomas2: But the table of squares?
22:47:51 <Cale> Thomas2: or is this something else?
22:47:59 <Gracenotes> Thomas2: well, if it's an integer total the Integer type can handle that.. you can just strictly fold on the sum.
22:49:15 <Cale> Thomas2: iirc, Integer is an instance of Ix
22:49:28 <Cale> Or is it not?
22:49:33 <Thomas2> yeah, it should be
22:49:54 <Cale> So you can make a UArray Bool as large as you wany
22:49:55 <dolio> > 3*110000^2 :: Word32
22:49:56 <Cale> want*
22:49:56 <lambdabot>   1940261632
22:50:06 <Gracenotes> it is, but.. why do you need to keep all that stuff in memory? -.-
22:50:07 <dolio> > 3*110000^2 :: Int32
22:50:08 <lambdabot>   1940261632
22:50:11 <Cale> Note that the Bool values will be packed in bitwise.
22:50:20 <Thomas2> yeah, but that's still a huge amount of memory
22:50:26 <Thomas2> let me try this other idea first
22:51:01 <dolio> > 3*110000^2 :: Int64
22:51:03 <lambdabot>   36300000000
22:51:55 <Cale> I'm not certain why it's that much memory, but maybe I misunderstand what it is that you're caching.
22:52:44 <Cale> Oh, all the squares up to 110000^2 ?
22:52:47 <Thomas2> well yeah
22:52:52 <Thomas2> you want to test for membership
22:52:58 <Thomas2> point is, this isn't the smart way to do it
22:53:16 <Cale> That'd be very sparse, and about 1.5 GB.
22:53:37 <Cale> But yeah
22:53:39 <Thomas2> yup, and initialising 1.5GB will take a while, i think
22:54:05 <dolio> > length . takeWhile (< 3 * 110000^2) . map (^2) $ [1..]
22:54:07 <lambdabot>   190525
22:54:55 <Zao> Gracenotes: Gnome gives the GLUT window a titlebar just fine here on FC10.
22:55:09 <Zao> And I can't remember having any issues on any Ubuntu boxen either.
22:55:11 <Gracenotes> Zao: hrm. Which example did you run?
22:55:12 <dolio> > S.size . S.fromList . takeWhile (< 3 * 110000^2) . map (^2) $ [1..]
22:55:14 <lambdabot>   /tmp/9166580623440427824:70:72: Not in scope: `S.size'/tmp/9166580623440427...
22:55:18 <Zao> Are you running Compiz?
22:55:29 <Zao> Gracenotes: 2.
22:55:37 <Gracenotes> .. oh right.. I remember having issues with OpenGL and that in the past
22:55:40 <Gracenotes> *headdesk*
22:55:55 <dolio> > Set.size . Set.fromList . takeWhile (< 3 * 110000^2) . map (^2) $ [1..]
22:55:56 <Gracenotes> lots of flickering, missing titlebars, etc.
22:55:58 <lambdabot>   190525
22:56:34 <Gracenotes> that might be it
22:56:38 <Zao> Gracenotes: It's even more fun on ATI cards.
22:57:01 <Gracenotes> you don't say. :3
22:58:19 <Cale> Thomas2: On my machine, I can do 20 million lookups in the appropriate Data.Set of squares in about 17 seconds.
22:58:30 <Cale> Thomas2: and that's not even compiled
22:58:48 <Cale> (and it scales linearly)
22:59:22 <Cale> 175 seconds isn't that bad for 200 million lookups is it?
22:59:40 <Cale> At least, it's not an impractical time to wait.
23:00:54 <dolio> If only we had good hash tables.
23:01:00 <Berengal> Gah!
23:01:08 <Cale> hm?
23:01:18 <Berengal> I was squashing a bug, got frustrated, and typed "fix error" in ghci...
23:01:23 <PetRat> test
23:01:31 <Cale> Berengal: ahaha
23:01:35 <idnar> Berengal: hahaha
23:01:48 <idnar> @remember Berengal I was squashing a bug, got frustrated, and typed "fix error" in ghci...
23:01:48 <lambdabot> Done.
23:05:09 * Cale compiles with -O2 and tries 200 million tests.
23:05:29 <Cale> Should only take 3 minutes
23:05:45 <Thomas2> guideline is solutions should run in a minute :-)
23:05:46 <Cale> (unless it's faster :)
23:06:11 <Thomas2> ok, interesting. in the meanwhile, my clever idea seems to have fallen flat on its face
23:06:14 <dolio> Is there also a guideline that you shouldn't be brute forcing solutions by problem 143?
23:06:14 <Cale> Thomas2: Well, that's only a factor of 3
23:06:35 <Thomas2> well, it's a guideline in general that things should run in a minute
23:06:39 <idnar> brute forcing is so tempting, though :P
23:06:42 <Cale> And I have an old machine. If my machine was newer :)
23:06:44 <idnar> especially when you suck at math
23:06:56 <Thomas2> a lot of the example solutions are in tuned C though, so what is possible in a minute varies heavily
23:07:05 <Berengal> Thomas2: Unofficial guidelines is it should finish in a sigarette, then you check the forums.
23:07:07 <Cale> real	2m6.720s
23:07:13 <Cale> user	1m29.906s
23:07:13 <idnar> I always get the suspicion that a decent mathematician could reduce almost all of those problems to something you can do in your head
23:07:38 <Thomas2> hmm, i claim to be a somewhat decent mathematician, and for most of them I really can't
23:07:47 <Thomas2> some of the earliest ones I could solve on paper
23:08:15 <Berengal> idnar: Well, first of all, most mathematicians I know can't divide 49 by 7...
23:08:21 <Cale> I don't understand why anyone would care what the sum of all distinct values of p + q + r <= 110000 for Torcelli triangles is.
23:08:34 <Thomas2> argh, I'm an idiot
23:08:40 <Cale> It's a number :)
23:08:47 <idnar> Cale: I was in a meeting the other day, and I totally needed to know that *hide*\
23:09:01 <Thomas2> write isASolution2, isASolution3 but the test i'm timing is still using 2
23:09:26 <idnar> Thomas2: write a new one, programmerIsAnIdiot
23:09:48 <idnar> Thomas2: then send me the implementation, I need it too :P
23:10:07 <Thomas2> idnar: programmerIsAnIdiot :: IO ()
23:10:14 <dolio> Numbers are easy to type into a text field, and automatically verify.
23:10:20 <Thomas2> idnar: programmerIsAnIdiot :: coffee >>= drink
23:10:25 <Cale> Berengal: With *paper* though, you can expect quite a bit :)
23:10:49 <Thomas2> maybe that should be makeCoffee?
23:10:59 <Cale> Berengal: I've gotten through quite a few exams that supposedly demanded a calculator without one :)
23:10:59 <Berengal> Cale: True, but when the terms are finally reduced to 49 / 7...
23:11:00 <idnar> I found some of my code the other day that calculated something for every element in a set of N elements... and then for some reason called that function in a loop over the set again
23:11:02 <Thomas2> hmm, so that did halve the time
23:11:05 <Berengal> Who remembers long division anyway?
23:11:20 <Thomas2> 49 is not especially long
23:11:21 <QtPlaty[HireMe]> Berengal: I do, I use it often enought.
23:11:25 <Berengal> (Actually, I'm quite decent without a calculator...)
23:11:27 <Cale> Even to the point of calculating logarithms and square roots by hand.
23:11:45 <Thomas2> now that's obsessive
23:11:51 <idnar> short division, hee hee
23:11:59 <QtPlaty[HireMe]> It was the first intresting algrithum I learned.
23:12:01 <Cale> Well, I don't own a pocket calculator.
23:12:15 <idnar> all of my maths teachers were highly amused that I still used crutches when I did arithmetic by hand (which I did a lot)
23:12:20 <idnar> s/all of/some of/
23:12:21 <Cale> and I never remember to bring one
23:12:23 <Berengal> Cale: I can't do that, but I am very good at keeping state in my mind. Most problems I've encountered in an educational setting I didn't even need paper for
23:12:33 <pumpkin> anyone know much about graph layout?
23:12:59 <idnar> I also got strange looks when I turned up to exams without a calculator, because I couldn't be bothered to carry one around
23:13:01 <Cale> pumpkin: Anyone in the wider sense of the term? :)
23:13:05 <pumpkin> lol
23:13:13 <pumpkin> anyone present know much about graph layout?
23:13:30 <Thomas2> yeah, most of the tools you can get are terrible
23:13:35 <ManateeLazyCat> pumpkin: Graph layout?
23:13:36 <Thomas2> that's my $0.02
23:13:54 <pumpkin> ManateeLazyCat: embedding a graph into 2d space
23:13:56 <Berengal> Most pocket calculators can't even do more than 8 digits... I can usualy do that in my head
23:14:01 <pumpkin> well, 2d is the one I'm interested in
23:14:17 <Cale> pumpkin: I'd really like a graph layout algorithm which made use of the symmetry group of the graph, along with appropriate additional data (perhaps selected factors of that group) to draw a pretty picture which helped exhibit that symmetry.
23:14:17 <pumpkin> ManateeLazyCat: with some notion of "goodness" of the embedding
23:14:25 <idnar> most of the time there wasn't any requirement to even work things out, "x = log(5 / 2**i)" or whatever the heck would be a perfectly acceptable final answer
23:14:46 <ManateeLazyCat> pumpkin: Now, i'm develop gtk2hs program, i think gtk libraries can do that.
23:14:53 <pumpkin> ManateeLazyCat: I doubt it :)
23:15:07 <pumpkin> Cale: that would be nice
23:15:28 <pumpkin> Cale: sounds like the world needs a haskell graph layout library ;) nudge nudge wink
23:15:39 <Cale> pumpkin: Most of the algorithms I know of are just things like turn all the edges into springs and treat the vertices as charged particles.
23:16:04 <pumpkin> I'm looking for something even simpler actually
23:16:05 <pumpkin> http://www.hex-rays.com/idapro/5preview/index.htm
23:16:09 <Cale> You end up with something, but it's usually not so pretty.
23:16:26 <pumpkin> basic blocks precede and follow one another and give you a partial order
23:16:29 <Cale> (Not ideal for symmetric graphs, anyway)
23:16:42 <pumpkin> you want it to go down, but there can be cycles
23:16:46 <orbitz> how many scene points do i get for each person i turn onto haskell?
23:17:10 <Cale> pumpkin: Ooh, that's cute.
23:17:30 <pumpkin> yeah, just trying to figure out a good way to make a graph like that, really
23:17:43 <pumpkin> it's a handy representation that's helped me many times :P
23:17:47 <ManateeLazyCat> pumpkin: That's not hard to implement.
23:18:11 <pumpkin> ManateeLazyCat: I just want to know the basic idea... a topological sort could give me the y order if there were no cycles
23:18:15 <pumpkin> but most interesting programs have cycles :P
23:18:30 <Cale> pumpkin: I wonder if it's possible to ask dot to do something like that.
23:18:40 <pumpkin> I could detect cycles, merge them into single nodes, and lay them out independently
23:18:45 <pumpkin> but was wondering if there was something nicer
23:18:48 <Thomas2> convert a link to a back link inthe manner that gives you most distinct y ordering?
23:19:15 <pumpkin> yeah, and you want to minimize edge crossings as usual (or zero them if it happens to be planar)
23:19:55 <ManateeLazyCat> pumpkin: Ok, my question, how to use hs-boot fix `recursive import` problem?
23:21:41 <ManateeLazyCat> pumpkin: Have a *light* way that make ghc support `recursive import` without hs-boot file?
23:22:26 <Zao> Yay. 0.3 and 0.3.1 of the Stream library depends on a completely different major version of QuickCheck.
23:25:43 <FunctorSalad> pumpkin: Cale: I think dot already does this actually
23:25:56 <FunctorSalad> (it orders stuff into ranks)
23:26:04 <thoughtpolice> Zao: yes, that tends to mess things up :)
23:26:05 <Cale> FunctorSalad: with the rectilinear lines and all?
23:26:25 <FunctorSalad> you can explicitly tell it which edges to ignore for the rank ordering with the "constraint=false" property
23:26:35 <FunctorSalad> Cale: hmm don't know about these
23:27:59 <FunctorSalad> record nodes with named "ports" are possible too
23:28:15 <FunctorSalad> (then you can start or end an edge at nodename:portname)
23:29:22 <Zao> Building reactive-fieldtrip looks like it'll be a fun adventure.
23:33:42 <Thomas2> why do some functions not get profiler nodes even with -auto-all?
23:33:48 <Thomas2> is it because no ticks landed in them?
23:34:09 <Gracenotes> aaaah! Haskell just dumped me :(
23:34:25 <Thomas2> erm, my bad
23:34:37 <Thomas2> i had a brain stupid again :-(
23:34:43 <Gracenotes> I shall never code another IO action again!!
23:35:37 <Cale> Gracenotes: huh?
23:36:16 <Gracenotes> I just got a core dump/backtrace
23:36:33 <Gracenotes> well, using the OpenGL interface
23:39:19 <thoughtpolice> Zao: I actually just built it yesterday actually
23:39:45 <thoughtpolice> Zao: before anything you'll need to do 'cabal install Stream-0.3 checkers-0.1.2 vector-space-0.5.1'
23:40:00 <thoughtpolice> Zao: that should fix up most of the ridiculous mismatch issues there are now for versioning constraints in the reactive packages
23:44:11 <ManateeLazyCat> Have a simple way to handle `mutually recursive modules` ?
23:45:22 <FunctorSalad> hs-boot isn't that bad... you just have to include the decls that are actually used by the other module
23:46:04 <FunctorSalad> (@ManateeLazyCat)
23:46:58 <ManateeLazyCat> FunctorSalad: But it's troublesome, i need modified hs-boot file when i changed .hs file.
23:47:39 <ManateeLazyCat> FunctorSalad: Why not ghc do those troublesome thing self?
23:48:29 <FunctorSalad> I don't know the details of how viable that would be
23:48:30 <Zao> thoughtpolice: How I wish that cabal had a purge command.
23:49:37 <ManateeLazyCat> FunctorSalad: If just two files, that okay. But if i have too many files, and those files import each others, and hs-boot file is too complex and unflexible.
23:50:19 <FunctorSalad> hmm
23:51:01 <ManateeLazyCat> FunctorSalad: Have other tools can do those work automatically? Cabal can help me do those work?
23:52:18 <FunctorSalad> I don't think cabal does  anything like that
23:54:27 <ManateeLazyCat> FunctorSalad: So only have *one* way (hs-boot) can fix this problem? GHC will fix this problem in the feature version?
23:56:26 <FunctorSalad> you'd have to ask the ghc developers for that :)
23:57:23 <ManateeLazyCat> FunctorSalad: Okay, so i have two files named "Window.hs" and "WindowsList.hs", and them import each other, how to write .hs-boot file? Just need write either one?
23:58:25 <ManateeLazyCat> FunctorSalad: You know the mailing-list of ghc? Or IRC channel?
23:59:00 <FunctorSalad> ManateeLazyCat: http://www.haskell.org/mailman/listinfo/glasgow-haskell-users
23:59:38 <Berengal> Woah...
23:59:43 <Berengal> I know loeb
