00:00:11 <mmorrow> type Graph = IntMap Node; data Node = Node { ...., succs :: [Int], state :: Something, ....}
00:00:15 <pumpkin> Berengal: maybe, but it seems pretty complex as it can depend on all the other nodes
00:00:26 <mmorrow> is how i'd try it first
00:00:32 <mmorrow> IntMaps are pretty speedy
00:00:36 <pumpkin> yeah, I've started along those lines
00:00:42 <pumpkin> I'll keep going and stop prematurely optimizing :)
00:00:50 <mmorrow> heh
00:01:20 <pumpkin> was going to use fgl but what I need is simple enough for me to implement myself, and I don't really like fgl's api much :/
00:02:45 <Gilly> fgl is good because it has implemented heaps that are needed in dijkstra :P i found it a pain to implement that in haskell
00:03:32 <pumpkin> hmm, don't think I'll need dijkstra for this at least
00:04:55 <pumpkin> anyway, it should be relatively simple to do without thinking too hard about performance, and then maybe I'll try to speed it up once I have it working :)
00:05:37 <pumpkin> but I'll read that paper too
00:07:17 <Berengal> Finding a good algorithm isn't premature optimizing, and doesn't neccessarily benefit from an already implemented solution...
00:07:52 <pumpkin> true, but given that it's a pretty simple algorithm and it won't cost me much to try it, doing so will give me a better idea of the problems involved, I guess :)
00:08:04 <pumpkin> if I'm thinking of ST up front, I'm probably doing it wrong, but maybe not
00:08:20 <Berengal> Well, yes... spending time on finding a better algorithm is a waste of time if you don't need one...
00:08:36 <pumpkin> oh, I definitely want speed here eventually :P
00:08:46 <pumpkin> I'm going to be handing it big graphs
00:08:52 <Berengal> What are you using it for?
00:09:07 <pumpkin> machine learning
00:09:14 <pumpkin> getting tired of the shitty matlab and c stuff
00:09:14 <Berengal> Ah
00:09:37 <ray> are you still doing that evangelism thing?
00:09:45 <pumpkin> ?
00:09:54 <ray> "belief propagation"
00:09:58 <pumpkin> lol
00:10:04 <Berengal> hehe
00:10:08 <pumpkin> I was actually
00:10:17 <pumpkin> I've left RWH in a strategic location in my department
00:10:18 <pumpkin> next to food
00:10:25 <pumpkin> with a comfy couch next to that
00:10:31 <ray> on top of food
00:10:37 <pumpkin> hoping people will sit down on a break and pick up a "random book"
00:10:39 <Berengal> inside food...
00:11:20 <ray> surrounding food
00:11:30 <Berengal> Simply EVERYWHERE
00:11:41 <Berengal> A house built of RWH
00:11:59 <Berengal> Perhaps I should go to sleep...
00:12:01 <Axman6> @quote primes
00:12:02 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
00:12:04 <Axman6> @quote primes
00:12:04 <lambdabot> sigfpe says: It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
00:12:05 <Axman6> @quote primes
00:12:06 <lambdabot> quicksilver says: <cads> three new mersenne primes in the past couple of months <quicksilver> I blame the financial crisis [...] out of work bankers have nothing better to do that calculate primes.
00:12:10 <Axman6> bah
00:12:17 <Axman6> @quote Data.Number
00:12:17 <lambdabot> No quotes match. My pet ferret can type better than you!
00:12:22 <Axman6> :(
00:19:55 <pumpkin> @quote pumpkin
00:19:55 <lambdabot> pumpkin says: OMG I <3 RECORD SYNTAX
00:20:44 <mmorrow> pumpkin: nice, i'm wrong about the no asm loops thing http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2164#a2164
00:21:00 <pumpkin> ah cool :)
00:21:10 <mmorrow> (either this is a trivial case because it's not allocating, or wherever i read that was wrong, or this is a new change)
00:21:13 <pumpkin> pity I can't get that on my platfom :(
00:21:17 <mmorrow> :(
00:22:01 <mmorrow> pumpkin: how do you mean?
00:22:10 <pumpkin> no x86_64 on mac os :(
00:22:15 <mmorrow> ahh (
00:22:17 <mmorrow> :(
00:23:04 <mmorrow> yeah x86 sucks for registers
00:23:24 <mmorrow> from what i understand ghc just passes *everything* on the stack on x86
00:23:30 <pumpkin> :(
00:24:49 <mmorrow> (and to add salt to the wound, ghc doesn't use sse regs/instrs for x86 fp code)
00:24:59 <mmorrow> (but it does on x86_64)
00:25:47 <pumpkin> it burns
00:25:56 <mmorrow> not sure if that really has any performance impact though, since i don't think it's using the sse in a vectorized way (or whatever)
00:25:58 <pumpkin> I do most of my development on mac os
00:25:59 <mmorrow> pumpkin: heh
00:26:03 <pumpkin> and I have a monster mac pro
00:26:20 <pumpkin> even just being able to use more RAM would be nice
00:26:29 <mmorrow> yeah
00:28:00 <mmorrow> x86_64 is so nice, the ccall convention has the first 6 args in registers
00:28:07 * mmorrow has been reading up on it recently
00:28:36 <pumpkin> first 6!
00:28:38 <mmorrow> and there are *two* return regs (although i'm not sure if C will use more than one)
00:28:40 <pumpkin> wow
00:28:49 <pumpkin> what will two return regs give you?
00:28:56 <pumpkin> can GHC return unboxed pairs? :P
00:29:06 <mmorrow> yeah, and that's not counting the 8 fp arg regs
00:29:34 <mmorrow> pumpkin: yeah something like that (also, this is for the C calling conv)
00:29:41 <pumpkin> yeah
00:29:42 <mmorrow> ghc uses its own callconv
00:29:54 <mmorrow> specialized by graph coloring
00:29:56 <pumpkin> I just remember reading that it was impossible to return (# , #) from a function
00:30:25 <mmorrow> hmm, in bytecode you can't, but you can in compiled code
00:30:30 <pumpkin> oh
00:31:06 <mmorrow> (but on x86 both'll be on teh stack :(
00:31:16 <pumpkin> yeah, that makes sense
00:58:03 <Gracenotes> scene: a 10-minute debugging period, in which Gracenotes learns the detriment of failing to normalizing vectors
00:58:12 <Gracenotes> *booing from the audience :(*
01:09:26 <ray> scene: a small university classroom. HASKELL CON '45 is scrawled on a futuristic cyber-blackboard. a carefree drunkard looking to be in his early 20s lounges near the center of the room, sipping from a flask occasionally.
01:11:01 <PetRat> scene: some in the Pacific timezone is up way past his bedtime
01:11:09 <PetRat> ^^ someone
01:16:21 <Ralith> DRUNKARD yawns/
01:16:21 <Ralith> .
01:21:28 <quicksilver> mmorrow: by the way, I did hack together a simple force-based 3D graph layout thing, as challenged by peter V
01:21:55 <chromakode> Monad noob question: I'm trying to use System.Timeout to run a pure function. The timeout function expects something in IO. How do I wrap my pure function in IO to get it to run properly for timeout?
01:22:37 <Ralith> @hoogle timeout
01:22:38 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
01:22:38 <lambdabot> module System.Timeout
01:22:38 <lambdabot> package control-timeout
01:22:55 <chromakode> the Int is in microseconds
01:22:55 <quicksilver> chromakode: just put 'return' in front of it, is the simple answer.
01:23:01 <quicksilver> however, it may well not work.
01:23:07 <chromakode> quicksilver: it doesn't.. that makes it lazy
01:23:19 <quicksilver> no it odesn't.
01:23:23 <quicksilver> it doesn't 'make' anything lazy.
01:23:32 <quicksilver> it just doesn't stop somethign being lazy, which alwready was.
01:23:40 <chromakode> aha, I see.
01:23:52 <chromakode> how would I force evaluation?
01:23:59 <quicksilver> you could try "return $! thing"
01:24:11 <quicksilver> if the thing is just a simple value such that one seq is enough to force it.
01:24:17 <opqdonut> why do you want to force evaluation?
01:24:22 <opqdonut> for some side-effects?
01:24:26 <quicksilver> because he wants to impose a timeout on it.
01:24:27 <chromakode> opqdonut: it's a long-running function
01:24:46 <Gracenotes> IO is a force-evaluation-y monad by default
01:24:48 <chromakode> quicksilver: BAM! the $! did the trick
01:25:03 <quicksilver> Gracenotes: I'm not sure what you said makes any sense.
01:25:08 <Gracenotes> unless you use methods which call unsafeInterleaveIO, etc.
01:25:15 <chromakode> thanks very much quicksilver
01:25:21 <quicksilver> np
01:25:31 <Gracenotes> quicksilver: strict, you might say?
01:25:59 <quicksilver> I certainly wouldn't, no.
01:26:05 <quicksilver> there's nothing strict about IO.
01:26:24 <blackh> The evaluation of IO actions is strict - that's why return $! thing works
01:26:26 <quicksilver> all it does, it force as much data as it needs to, to do its work.
01:26:33 <quicksilver> blackh: no.
01:26:40 <Gracenotes> well, 'strict monad' used loosely, in the sense that it won't cause the State monad to crash
01:26:45 <quicksilver> that's true of haskell in general
01:26:59 <quicksilver> haskell is demand driven - everything forces enough to do its work.
01:27:09 <quicksilver> IO has no particularly special case here.
01:27:18 <quicksilver> of course putChar (for example) forces its argument.
01:27:43 <Workybob> (but the call to putChar itself may not be forced)
01:27:46 <quicksilver> > (Just 4 >> (return $! undefined) >> Just 5)
01:27:47 <lambdabot>   * Exception: Prelude.undefined
01:27:54 <quicksilver> ^^ would you then call Maybe a 'strict monad' ?
01:27:56 <quicksilver> I wouldn't.
01:28:24 <quicksilver> it's just that for >> and >>= to do their work, they have to inspect the action at least superficially.
01:28:28 <quicksilver> so return
01:28:30 <quicksilver> sorry
01:28:39 <quicksilver> (return $! foo) === (foo `seq` return foo)
01:28:54 <quicksilver> does indeed force foo (to WHNF) if you force the >> or >>=
01:29:08 <Gracenotes> I would icall it a 'strict monad' n the sense that the ordering of >>= is important
01:29:25 <quicksilver> > ((+4) >> (return $! undefined) >> (*5)) $ 9
01:29:27 <lambdabot>   45
01:29:46 <Workybob> Gracenotes: but the ordering of (.) in a lot of places is important too
01:29:46 <Gracenotes> in terms of what's evaluated when
01:29:48 <quicksilver> well, I find that a strange justification.
01:29:55 <quicksilver> what does "strict" have to do with "ordering" ?
01:30:15 <quicksilver> the ordering of >>= is important in all monads in general
01:30:15 <Workybob> Gracenotes: I would call it a side-effecting, or impure monad for that reason
01:30:23 <Gracenotes> again, the effect on what evaluations are forced when.
01:31:06 <mmorrow> quicksilver: ooooh, sweet!
01:31:08 <quicksilver> I would encourage you to try to formulate a statement which is true of IO but not true of lazy state.
01:31:17 <quicksilver> to make precise what you mean here by 'strict monad'.
01:31:24 <mmorrow> quicksilver: how does it look?
01:31:50 <quicksilver> (incidentally, and I don't wish to go on a tangent, but the 'strict state' monad is not so-called because it is a strict monad, but because it generates functions which are strict in the state component)
01:32:00 <quicksilver> mmorrow: screenshot coming up :P
01:32:08 <mmorrow> weeee
01:32:33 <quicksilver> mmorrow: http://roobarb.jellybean.co.uk/~jules/Picture%2011.png
01:32:35 <Gracenotes> well, I am going by how I have interpreted strictness to be explained before, which makes sense to me.
01:32:47 <quicksilver> mmorrow: that's a dodecahedron which has not quite reached steady state yet
01:32:50 <Gracenotes> perhaps someone needs to write something on it in terms of monads
01:32:52 <mmorrow> quicksilver: hell yesh!
01:33:03 <mmorrow> quicksilver: what are your plans for it?
01:33:16 <quicksilver> mmorrow: to give the code to other people and let them make it into something nice.
01:33:26 <quicksilver> mmorrow: I can't integrate it with vacuum since I don't have 6.10.
01:33:37 <mmorrow> quicksilver: cool. are you going to hackage it?
01:33:44 <mmorrow> quicksilver: aww. why no 6.10?
01:33:54 <Workybob> Gracenotes: strictness doesn't actually have anything to do with evaluation order at all
01:34:21 <Workybob> a function is strict in its argument if the argument must be in WHNF to carry out a reduction
01:34:29 <Workybob> or all reduction rather
01:34:35 <Workybob> no small steps here
01:34:42 <quicksilver> mmorrow: it is missing a lot of stuff - it doesn't try to detect steady state, it doesn't label the points because opengl's built in text stuff is useless.
01:34:54 <quicksilver> mmorrow: it's just a proof on concept.
01:35:07 <quicksilver> mmorrow: it's quite cute the way all the platonic solids automatically lay themselves out, though.
01:35:44 <quicksilver> mmorrow: (no 6.10 - there were issues with 6.10.1 I didn't feel like fighting, I didn't want ot lose opengl, etc. I'll probably upgrade soon)
01:35:44 <mmorrow> quicksilver: (i've been off-and-on working on a (minimal) binding to graphviz's C code to gen png's in the same address space, and then an opengl image viewer to display them. i've got the graphviz part done and am currently trying to figure out the deal with textures to i can use that do display the image)
01:36:09 <mmorrow> quicksilver: i've got opengl up and running with 6.10.1
01:36:19 <Gracenotes> Workybob: right, I don't fundamentally associate it with evaluation order... the order of >>= changes what must be in WHNF when, although that's a poor way of explaining it :)
01:36:38 <Workybob> Gracenotes: yes, but the order of >>= also changes much more important things
01:36:41 <Workybob> like the meaning of the program
01:36:44 <Gracenotes> yeah.
01:37:00 <quicksilver> Gracenotes: certainly one possible definition of 'strict monad' is '(>>) is strict in both arguments'
01:37:10 <mmorrow> quicksilver: yeah, 3D force-directed graphs are extremely amusing to watch
01:37:14 <quicksilver> Gracenotes: however, I'm not sure that's a useful concept - Maybe is a strict monad by that concept.
01:37:41 <mmorrow> quicksilver: i'm not sure if i had to do anything to get opengl to build though
01:37:43 <Gracenotes> the function parameter is strict..?
01:37:43 * mmorrow checks
01:38:34 <Workybob> quicksilver: I don't think maybe is strict by that deff
01:38:34 <mmorrow> quicksilver: no, looks like it built oob
01:38:42 <mmorrow> (i darcs got from http://darcs.haskell.org/libraries/OpenGL)
01:39:14 <mmorrow> quicksilver: an from http://darcs.haskell.org/libraries/GLUT
01:39:44 <Workybob> (Just 5) >> f can be reduced to f 5
01:39:50 <Workybob> without evaluating f at all
01:40:01 <opqdonut> err, >> ?
01:40:06 <opqdonut> don't you mean >>=
01:40:06 <Workybob> oh, woops
01:40:07 <Workybob> >.<
01:40:10 <mmorrow> quicksilver: yeah, opengl's text stuff is super useless (and excruciatingly slow)
01:40:15 <Workybob> brain fail
01:40:33 <quicksilver> Workybob: I just demonstrated it :)
01:40:41 <quicksilver> > (Just 4 >> (return $! undefined) >> Just 5)
01:40:43 <lambdabot>   * Exception: Prelude.undefined
01:40:49 <Workybob> hmm, wow
01:40:56 <Workybob> why on earth is it defined like that
01:41:04 <Workybob> does it break monad laws if you make it lazy?
01:41:04 <quicksilver> >> has to case to check for Nothing
01:41:06 <quicksilver> doesn't it?
01:41:10 <Workybob> oh, duh
01:41:11 <Workybob> yes
01:41:23 <Workybob> sorry, being a noob
01:41:39 <Workybob> but wait...
01:41:42 <quicksilver> with >>= it's a bit hard to define what you mean by right-strictness
01:41:47 <quicksilver> (left-strictness is obvious)
01:41:54 <Workybob> (Just 4 >> Something complex) can be reduced to something complex
01:41:55 <quicksilver> since the RHS of >>= is under a lambda anyway.
01:42:06 <Workybob> without looking at the rh argument
01:42:12 <Workybob> you only need look at the left hand one
01:42:14 <mmorrow> > (\x -> case x of Nothing -> Nothing; Just _ -> x) (return $! undefined)
01:42:15 <lambdabot>   * Exception: Prelude.undefined
01:42:19 <mmorrow> > (\x -> case x of Nothing -> Nothing; Just _ -> x) (return undefined)
01:42:20 <lambdabot>   Just * Exception: Prelude.undefined
01:42:23 <quicksilver> Workybob: yes, but then you return the right argument :P
01:42:26 <Gracenotes> .... wha
01:42:33 <quicksilver> Workybob: so if the right argument is _|_ you get _|_
01:42:37 <quicksilver> Workybob: which is the defn. of strict.
01:42:45 <quicksilver> > (Nothing >> return $! undefined)
01:42:47 <lambdabot>   Couldn't match expected type `a -> a1'
01:42:53 <quicksilver> > (Nothing >> (return $! undefined))
01:42:55 <lambdabot>   Nothing
01:42:55 <Workybob> *thinks*
01:42:56 <Workybob> yeh
01:42:58 <Workybob> that's... wierd
01:43:01 <quicksilver> ^^ that's the eample you want
01:43:03 <quicksilver> I think.
01:43:13 <Workybob> yeh
01:43:15 <mmorrow> > (Nothing >> undefined)
01:43:16 <lambdabot>   Nothing
01:43:16 <Workybob> indeed it is
01:44:30 <mmorrow> quicksilver: did you reference that paper on ubigraph's website at all?
01:44:39 <mmorrow> (i haven't read it, just briefly skimmed)
01:45:35 <quicksilver> mmorrow: I will not pollute my mind with the ramblings of evil closed-source software authors. It is like unto acid sprayed into my eyes.
01:45:41 <quicksilver> :P
01:45:43 <mmorrow> hehe
01:46:14 <mmorrow> how are you computing the force vector at each node? it seems like it's essentially a convolution
01:46:27 <quicksilver> I just used a bit of high school physics - linear spring forces, 1/r2 repulsion, and a v-proportional damping
01:46:49 <mmorrow> ahhh, cool. i see, so it's the edge that's doing it
01:46:50 <quicksilver> no attempt to make it clever or fast. I wasn't targetting large graphs after all.
01:47:09 <quicksilver> I'm sure it's a good target for dph + uvector + a  good SSE backend
01:47:20 <quicksilver> but I just did it naively.
01:47:26 <mmorrow> quicksilver: ah yeah, that reminds me about ghc and sse stuff
01:47:35 <quicksilver> the hardest part was picking initial positions
01:47:51 <quicksilver> no two points co-incident, and preferably most of them not coplanar
01:47:57 <mmorrow> quicksilver: i'm sure it could be made speedy without too much pain, now that it exists
01:48:14 <mmorrow> quicksilver: hmm, interesting
01:48:20 <mmorrow> is it "online"?
01:48:37 <mmorrow> in the sense that you can add/delete nodes at any point?
01:48:47 <quicksilver> an early version had a bug which made all the points coplanar. It was quite pretty to watch - it found the 2D solution first and then as floating point rounding errors accumulated to force them slightly out of the plane it 'popped' open
01:48:56 <mmorrow> heh
01:49:19 <quicksilver> there is no user interface for adding/deleting points. There is no reason you couldn't, though.
01:49:24 <quicksilver> it's stateless
01:49:24 <mmorrow> nice
01:49:33 <quicksilver> in the sense that the evoluation depends only on the current state and nothing else
01:49:44 <mmorrow> sweet, yeah that's perfect
01:50:33 <mmorrow> quicksilver: another cool thing is that you could compute a 2D solution, then generate an image or something a la graphviz
01:51:27 <quicksilver> I wonder if you get better solutions by solving in 2D, or by solving in 3D and then choosing a 'good' projection.
01:52:15 <mmorrow> hmm, i'm not sure. it seems like letting it "evolve" itself in 3D would be equivalent to choosing a 'good' projection, and much simpler too
01:52:38 <mmorrow> (but i'm not sure all the "moving parts" ;)
01:52:57 <Gracenotes> @index rnf
01:52:57 <lambdabot> Control.Parallel.Strategies
01:53:21 <mmorrow> quicksilver: oh wait, i misread what you said
01:53:29 <mmorrow> quicksilver: that's a good question
01:53:50 <mmorrow> quicksilver: i think it might be cooler to solve in 3D and project
01:54:47 <quicksilver> mmorrow: choosing a good projection should be a simple search over the surface of the unit sphere
01:54:51 <mmorrow> quicksilver: err, but at the same time choosing a good projection seems very subjective
01:54:59 <mmorrow> quicksilver: hmm
01:55:11 <quicksilver> well you can maximise the sum of root mean square point distance
01:55:13 <quicksilver> or something
01:55:22 <quicksilver> root mean square distance to nearest point.
01:55:31 <quicksilver> I'm sure there are some simple measures :)
01:55:42 <mmorrow> hmm, yeah i think so too
01:56:00 <quicksilver> alternatively you could *then* run the 2D version of the algorithm
01:56:08 <quicksilver> having used the 3D to pick a good global conformation
01:56:12 * quicksilver doesn't know.
01:56:16 <quicksilver> experimentation needed.
01:56:19 <mmorrow> totally
01:56:38 <quicksilver> you can trivially add different "bond lengths"
01:56:48 <quicksilver> but I didn't.
01:57:07 <quicksilver> also I wonder what you need to do to make H2O lay out correctly (some of my examples were chemical)
01:57:21 <quicksilver> I guess you need to treat the spare electron pairs on the O atom as hidden nodes.
01:57:34 <mmorrow> yeah, molecules would be interesting
01:57:41 <quicksilver> c2h6 looks nices.
01:57:53 <quicksilver> the two ends are rotated relative to each other.
01:58:09 <quicksilver> screenshot doesn't do it justice, you have to rotate it interactively to do it justice.
01:58:12 <mmorrow> first H2O, then protein folding!
01:58:16 <quicksilver> ;)
01:58:20 <mmorrow> heh
01:59:55 <cgizmo> hello everyone
02:00:13 <cgizmo> i have a question about monads to ask you guys
02:00:25 <quicksilver> good morning. Monad questions are my favourite.
02:00:36 <cgizmo> every tutorial i saw on the internet explains what monads ARE
02:00:58 <cgizmo> but i didn't get what monads were FOR, and what exactly do they represent
02:01:29 <cgizmo> i got the part about monads being able to chain actions together
02:02:08 <quicksilver> they're an abstraction.
02:02:17 <quicksilver> they're FOR hiding certain boring details.
02:02:37 <quicksilver> like if you have a bunch of code which produces answers and also messes with an auxiliary variable:
02:02:58 * Zao fondly recommends threading accumulators manually through functions.
02:03:05 <quicksilver> let (x1,a) = fun1 x0; let (x2,b) = fun2 x1; let (x3,c) = fun3 x2;
02:03:12 <vixey> cgizmo: IO monad is for input output effects, list monad is for nondetermistic search, Either monad is for exceptions (non local control effect again), State monad is for a mutable variable (mutation effect)
02:03:17 <quicksilver> the 'xn' variable are just passing through.
02:03:31 <quicksilver> with the right monad, you can rewrite that as :
02:03:39 <quicksilver> a <- fun1; b <- fun2; c <- fun3;
02:03:45 <quicksilver> the xs become totally implicit.
02:05:58 <quicksilver> mmorrow: as for the SSE stuff, yeah, I was away for a week and then I got distracted with some other projects.
02:06:12 <quicksilver> mmorrow: getting into ghc's backend has something of an activation energy hurdle.
02:09:03 <mmorrow> quicksilver: yeah, it does totally
02:11:01 <cgizmo> sorry, my internet connection died
02:11:11 <cgizmo> i'll check the logs to see what you told me
02:13:37 <cgizmo> quicksilver: thank you for the explaination
02:14:22 <cgizmo> so what was the point in have monads operate in a separate environment (such as with the do notation, special function return types) ?
02:14:32 <cgizmo> or am i totally mistaken again ?
02:14:42 * JaffaCake returns after 2 weeks on holiday
02:17:55 <int-e> @undo do x <- foo; bar x y; return (x,x)
02:17:55 <lambdabot> foo >>= \ x -> bar x y >> return (x, x)
02:18:38 <quicksilver> JaffaCake: welcome back :) hope you had a good time.
02:18:50 <quicksilver> cgizmo: to do notation is just a convenient shorthand.
02:19:12 <int-e> cgizmo: The do notation is just syntactic sugar. It's the types and basic operations (>>= and return) that are the point. And then each monad comes with its own set of primitives to actually be useful.
02:19:24 <quicksilver> cgizmo: my previous example a <- fun1; b <- fun2; c <- fun3; could be written "fun1 >>= \a -> fun2 >>= \b -> fun3 >>= \c -> ...."
02:19:31 <JaffaCake> quicksilver: yes thanks :)
02:19:37 <quicksilver> cgizmo: and, actually, in ML that style is programming is relatively common.
02:19:58 <quicksilver> cgizmo: (not necessarily with the symbol '>>=', but chaining combinators with trailing lambdas)
02:20:08 <cgizmo> ok, thank you
02:20:25 <cgizmo> so manads do NOT operate in a totally separate env
02:20:33 <int-e> right.
02:20:37 <cgizmo> ther are just a way to make things shorter and more readable ?
02:20:52 <vixey> don't know what env is
02:21:03 <cgizmo> with additionnal functions i'm guessing
02:21:20 <vixey> do vs >>= is about readability
02:21:23 <int-e> It's just IO that does, in a way: The RTS gets an IO action (main :: IO ()) and 'magically' executes the stuff in that action, something that you can not do in plain Haskell (ignoring unsafePerformIO)
02:21:24 <vixey> monads are not about readability
02:21:53 <vixey> int-e that hardly makes sense
02:22:35 <PetRat> Related to monads, I want to use Qt eventually for gui stuff, but I'm wondering if I should learn GTK first because it is documented in good books like Real World Haskell and The School of Expression.
02:22:48 <int-e> Sorry. I guess "operate" has two possible contexts in that case.
02:23:19 <fasta> PetRat: SOE does not do anything with GTK, AFAIK
02:23:23 <kadaver> PetRat: dont know about Qt but Gtk is easy to use at least.
02:24:22 <int-e> Let's just say that IO is special in various ways, and not a typical example of a monad.
02:24:26 <fasta> The idea of the SOE library, AFAIK,  was that it you didn't have to learn about "complex" libraries like GTK/QT/Win32/...
02:24:52 <cgizmo> int-e: is the IO monad the only one that performs side-effects ?
02:25:16 <PetRat> fasta: you are right about SOE. I misremembered what was in the book.
02:25:27 <EvilTerran> cgizmo, depends on how you define "side-effect", really
02:25:52 <int-e> cgizmo: IO, ST and STM come to mind. All three have special support in the run time system.
02:25:57 <EvilTerran> ST uses mutable data structures under the hood, but they're all constrained to a region of the code with some clever type hackery
02:26:23 <vixey> and State
02:26:43 <EvilTerran> but you could reason about the behaviour of, say, Maybe or State as being "side-effects"
02:26:51 <EvilTerran> even though they're implemented purely
02:26:51 <PetRat> I need qt's powerful canvas.. don't know another GUI that has something like that.
02:27:02 <quicksilver> PetRat: "powerful" in what way?
02:27:03 <int-e> Right. But State is pure Haskell - it represents a function under the hood.
02:27:05 <int-e> @type State
02:27:06 <lambdabot> forall s a. (s -> (a, s)) -> State s a
02:27:10 <quicksilver> PetRat: gtk has cairo canvases but I don't know anything about qt.
02:27:12 <vixey> so does ST
02:27:26 <int-e> vixey: I prefer to ignore that point as an implementation detail.
02:27:31 <int-e> So no, it doesn't ;-)
02:27:46 <vixey> what point?
02:27:53 <EvilTerran> surely the mutability aspect is the implementation detail wrt ST
02:28:02 <EvilTerran> seeing as, semantically, it's pure
02:28:14 <fasta> Can the debugger turn a function Int -> Bool into some source code corresponding to that function? Probably not, but this kind of opaqueness is not really helpful.
02:28:23 <PetRat> quicksilver: well, in my Python prototype I was able to implement a screen with thousands of objects, but they could all be primitive canvas items because of the huge variety qt offers (including spline fitted curves)...
02:28:28 <int-e> vixey: I just prefer to treat ST as opaque is all.
02:28:42 * EvilTerran has considered trying to write a pure version of ST with a bit of HList-esque hackery
02:28:51 <EvilTerran> because the possibility of STT amused me
02:28:51 <PetRat> ...so the refresh was very fast. I didn't need to care about how refreshes or changes were done.
02:28:59 <EvilTerran> and indeed TST :P
02:29:11 <EvilTerran> (think EtatsT)
02:29:13 <fasta> EvilTerran: with the same complexity bounds?
02:29:24 <EvilTerran> fasta, i think that'd be impossible
02:29:24 <vixey> fasta lol
02:29:36 <fasta> EvilTerran: I know how I can write one with amortized the same complexity bounds.
02:30:03 <fasta> EvilTerran: yes, that's why I asked.
02:30:22 <quicksilver> EvilTerran: I think you need typeable.
02:30:33 <EvilTerran> quicksilver, that'd probably work, yeah
02:30:54 <quicksilver> and I think you'll have problems with polymorphic references.
02:31:01 <quicksilver> not that people use them often in practice
02:31:04 <quicksilver> btu as a point of principle ;)
02:31:46 <quicksilver> PetRat: cairo canvas certainly offers some neat components but possible not spline fitted curves :)
02:31:49 <cgizmo> well, thank you for your answers
02:31:50 <EvilTerran> i was thinking there might be something clever i could do, although it might involve restricted monads, involving building up an HList with a cell for each reference type used in each monadic action
02:32:20 <cgizmo> so, good day to you
02:32:25 <EvilTerran> although you could probably foil that sort of idea with the right (or wrong) polymorphic recursion
02:32:27 <cgizmo> bye, and thanks
02:32:35 <PetRat> quicksilver: Google isn't giving me much help in locating Cairo canvas documentation. Any idea?
02:33:18 <PetRat> never mind... just found the gtk reference manual.
02:33:23 <PetRat> I just had to omit the word Cairo
02:33:30 <EvilTerran> quicksilver, actually, you could probably pull it off without Typeable with unsafeCoerce :P
02:34:07 <vixey> can you do it without typeable or unsafeCoerce?
02:34:28 <EvilTerran> possibly; that's what my rambling about HList is in aid of
02:34:30 <dons> this ability to run happstack out of fastcgi is nice, http://www.reddit.com/r/programming/comments/8du8j/the_happstack_web_framework_for_haskell_running/
02:34:48 <quicksilver> PetRat: http://cairographics.org/documentation/
02:36:29 <fasta> When using the debugger I get: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3977#a3977 When I do the same in a new ghci session, this never happens. Is this a known problem?
02:37:41 <PetRat> quicksilver: it's not clear from those docs whether Cairo or GTK provides a canvas in the same sense as Qt. In Qt, a canvas is a collection of graphical items at different places. The canvas handles efficient changes and updates, drawing or redrawing only those items which intersect the affected area.
02:38:45 <PetRat> Also, if you are scripting in an interpreted language, and you can delegate all actual drawing to canvas primitives, then updates and changes never trigger your own code.
02:39:02 <quicksilver> PetRat: I think it doesn't.
02:39:12 <quicksilver> I think it's more of a one-off render to a pixels thing.
02:39:23 <quicksilver> if you want to maintain a 2D scene graph that's down to your end.
02:40:22 <PetRat> Well, it seems that GTK-Haskell is well documented, so I'll test the waters with that, then take a look at Qt-haskell.
02:45:02 <fasta> Is there some logic to what variables are in scope? I have basically this: z f = do a <- foo; b <- bar; foo (\a -> let k = 1 in f a) and I have a break point on the same line as where f gets called. It want to be able to see the value of a and b too, but when I do :back, I get back to far, so, how can I control it?
02:45:14 <fasta> (I am talking about the debugger)
02:45:51 <quicksilver> fasta: I'm not ignoring you, per se, but I've never used the debugger I'm afraid.
02:54:28 <kadaver> man haskore is pretty complex
02:54:36 <fasta> I wonder whether the number of users of the debugger is greater than 1. It certainly still doesn't work properly if I encounter a bug in it within 5 minutes of use.  It also appears that one cannot see the bindings of monadic variables. So, I guess I will try the debugger again with the next release (when there is actually a change in the release notes)...
02:54:38 <kadaver> isnt theresome easy way to jsut string a bunch of noes together?
02:54:59 <kadaver> i have managed to create a 1-note sogn and generate a midi but thats about it
02:55:43 <fasta> kadaver: (+:+) means serial composition of musical objects.
02:56:02 <fasta> kadaver: I don't use Haskore myself, but I can imagine that should work.
02:56:36 <quicksilver> fasta: I imagine it would be helpful if you would report at least one or two of the issues you have faced.
02:56:59 <fasta> quicksilver: I doubt it, since most bugs I report are moved to the next release.
02:57:01 <quicksilver> fasta: the trac serves not only as a repository of known bugs but also a quasi-voting system to alert the GHC people to what people would like to work better.
02:57:16 <quicksilver> nonetheless, they are more likely to get fixed if you report them than if you don't.
02:57:21 <quicksilver> It is, of course, your decision.
02:59:42 <fasta> quicksilver: I think someone, apparently, needs to do another Phd on debuggers to make it work, since there are not that many people in getting it to work, because they don't use it and it probably takes some time to learn how exactly the current implementation works. And even then it might not be Phd material, since it is basically fixing up some broken implementation, which rarely counts as "research".  Conclusion, it will probably not get fixed in the next f
02:59:42 <fasta> ew years.
03:01:10 * quicksilver shrugs.
03:01:25 <quicksilver> Whoever spend a long time implementing that debugger did so in the hope that it would be useful.
03:01:33 <quicksilver> I imagine they are interested in fixing problems in it.
03:01:44 <fasta> quicksilver: I very much doubt that.
03:01:56 <quicksilver> well then, you keep that attitude.
03:02:14 <quicksilver> be negative, refuse to report bugs, refuse to engage in the community, and watch your bugs not get fixed.
03:02:17 <daf> not filing a bug seems quite defeatist
03:02:17 <quicksilver> it's all the same to me.
03:02:21 <fasta> quicksilver: it's just an attitude consistent with my observations.
03:02:32 <fasta> Why would I report another bug, before all the others are fixed?
03:04:29 <quicksilver> because reporting a bug helps the people who work on GHC know what is broken, and what people want fixing.
03:04:30 <fasta> And again, I reported more bugs than the average member of the "community", so this description is a bit harsh.
03:06:22 <dibblego> orbitz, that's the value provided to you by the monad
03:06:26 <dibblego> oops sorry
03:07:47 <nihongo> doesn't haskell limit what you can do because it's functional?
03:07:57 <nihongo> s/functional/purely functional
03:08:15 <nihongo> everything has to follow a recurrence rule?
03:08:26 <nihongo> What about non-math programs?
03:08:33 <fasta> nihongo: see IO/ST monad, so no.
03:09:00 <fasta> nihongo: there is possibly a limitation for real-time programs, though.
03:09:03 <MyCatVerbs> nihongo: in some contexts, yes. There are various useful limitations as to what you can do in pure code, for example.
03:09:41 <MyCatVerbs> nihongo: in others, no. In the IO monad, absolutely anything goes. Missiles may be launched, questionable thread safety, access to raw pointers, you name it.
03:10:11 <nihongo> how do I get a random number in haskell?
03:10:22 <MyCatVerbs> There's a module called System.Random.
03:11:32 <cjs> So 'instance Foo a => Foo [a] where...' is a reasonable way of defining a generic instance for lists of things that are instances of Foo?
03:11:39 <MyCatVerbs> cjs: yes.
03:12:00 <cjs> Hm. So reasoning about this stuff works. :-)
03:12:09 <MyCatVerbs> cjs: mostly. :)
03:12:22 <cjs> (I'm still somewhat awed and frightened by GHC's type system.)
03:13:21 <MyCatVerbs> nihongo: Most uses look like, do { gen <- getStdGen; let (number,newgen) = randomR (0,128) gen; putStrLn ("We have " ++ show number ++ " bananas in our ears."); }
03:13:33 <PetRat> cjs: noobie question: did you mean Foo a => [a] or is there something I don't get?
03:13:41 <nihongo> What is haskell mostly used for?
03:13:52 <MyCatVerbs> Programming.
03:13:57 <nihongo> As compared to imperative langs?
03:14:04 <quicksilver> better programming.
03:14:12 <Zao> As you can write imperative code in Haskell, anything that's not kernels.
03:14:22 <dibblego> haskell is more practical than imperative languages for general purpose programming
03:14:26 <quicksilver> cjs: be aware that not only is it a generic instance, it's the only instance.
03:14:36 <quicksilver> cjs: (the only instance for things of the form [a] I mean)
03:14:46 <cjs> PetRat: Basically, if I have an 'instance Foo A where...' and 'instance Foo B where...', I want to use that one declaration instead of 'instance Foo [A] where...' and 'instance Foo[B] where...'.
03:14:46 <quicksilver> cjs: that's good though. Parametricity is our friend.
03:14:48 <kadaver> why cant ghci import a file int eh same dir?
03:14:55 <quicksilver> kadaver: it can.
03:15:04 <cjs> quicksilver: Right. I reckoned that might be the case. In fact, I think I've run into it before.
03:15:14 <quicksilver> make sure the working directory of GHCi is the right place so it can find the files.
03:15:33 <kadaver> Zao: you mean you catn write OSkernels like House for example?
03:16:01 <quicksilver> communicating with hardware is generally a hard-real-time problem, so it's quite difficult to get it right in the presence of GC.
03:16:06 <nihongo> So if you want to do non math programming, it's GG
03:16:18 <PetRat> cjs: if A and B are instances of class AB, then wouldn't the declaration be : AB a => Foo [a] ? or maybe I don't get something
03:16:26 <nihongo> if it doesn't follow some recurrence rule
03:16:28 <quicksilver> it's possible that a few fairly lightweight language extensions could solve this in principle although I don't know the form.
03:16:36 <dibblego> nihongo, no, Haskell is for general purpose programming, not math programming
03:16:52 <dibblego> nihongo, has someone told these ideas to you?
03:16:56 <nihongo> yes
03:17:08 <dibblego> nihongo, it was inaccurate
03:17:11 <nihongo> ok
03:17:19 <cjs> Hm. But now I have a problem. 'class Foo a where fooName :: a -> String'. Normally, I can give fooName an undefined value of the type, and it works just fine, since it's never dereferenced, it's just used to select which fooName definition to call. But how do I define fooName for [a]?
03:17:36 <nihongo> I'll read lyahfgg
03:17:36 <cjs> In a generic way, I mean? I can't take the head of the list, because the list might be empty.
03:18:41 <blackh> cjs: You can use an explicit type signature in your code that references fooName
03:18:43 <MyCatVerbs> cjs: instance (Foo a) => Foo [a] where fooName _ = "List of " ++ fooName (undefined :: a)
03:18:50 <quicksilver> cjs: you can, actually.
03:18:57 <quicksilver> cjs: fooName (head xs) is fine.
03:19:04 <cjs> quicksilver: Really?
03:19:07 <quicksilver> cjs: lazy evaluation - the head never gets evaluated
03:19:11 <quicksilver> it doesn't matter that it might crash.
03:19:12 <cjs> Oh, of course, because it's never evaluated!
03:19:32 <quicksilver> you could argue it's ugly, and MyCatVerbs solution is more attractive.
03:19:40 <quicksilver> but MyCatVerbs's solution isn't haskell
03:19:46 <quicksilver> you pays your money you makes your choice
03:19:49 <quicksilver> -XScopedTypeVariables
03:20:04 <MyCatVerbs> I prefer quicksilver's.
03:20:17 * blackh did not understand the question. :)
03:20:19 <Athas> Can I alias a data constructor somehow?  I have a constructor T1, but I would also like the user to be able to refer to it with T2.
03:20:33 <MyCatVerbs> Just because the fact that (head xs) never gets evaluated and hence won't crash, even though it looks like it ought to, strikes me as a pretty neat prank.
03:20:54 <cjs> quicksilver: Yes, I was trying MyCatVerbs' solution, and encountering difficulties. :-)
03:21:03 <MyCatVerbs> Athas: nope. Closest you can come would probably be view patterns.
03:21:23 <MyCatVerbs> By abusing view patterns, I mean.
03:21:50 <Athas> Damn, guess I'll just write a function.
03:31:14 <fasta> No wonder TH is not popular: Exotic pattern not (yet) handled by Template Haskell !var, just about every simple thing I want to do with TH is not possible.
03:32:55 <kadaver> what module is T.T?
03:46:33 <lepassive> is there a shoutcast server written in Haskell ?
03:48:36 <beelsebob> given that shoutcast is one specific server for streaming media... no
03:49:59 <Philonous> Is there an efficient way to display per-pixel colour data in gtk2hs? I.e. I have an image as a matrix of colours and want to draw it to the screen. Painting every pixel seems to be horribly inefficient.
03:50:42 <lepassive> beelsebob, okay thanks
03:50:45 <beelsebob> Philonous: most likely, there's an image structure somewhere you can pack data into, but I can't be sure
03:50:55 <beelsebob> you could always create an OpenGL context
03:50:59 <beelsebob> and paint a texture
03:51:46 <Philonous> Ah well, that seems like overkill, but thanks
03:52:04 <Philonous> I was looking for this image structure but didn't find anything useful.
03:52:15 <beelsebob> tbh, OpenGL wouldn't be overkill
03:52:33 <beelsebob> often people don't remember that OpenGL is Open Graphics Library â€“ not Open 3D Graphics Library
03:52:41 <beelsebob> it's just an efficient way of drawing stuff
03:52:50 <beelsebob> sometimes 3D stuff
03:53:06 <MarcWeber> nominolo: Are you working on the scion vim frontend now?
03:54:05 <Philonous> beelsebob: I see. Somehow I would have tendet to use SDL instead of OpenGL
03:55:54 <quicksilver> Philonous: yes, there is.
03:56:02 <quicksilver> Philonous: gtk pixmap or gdk pixmap or some such thing.
03:56:42 <Gracenotes> argh. pattern-matching on 0 for a Double, bad idea. Doing so when I'm supposed to check <= 0, not just 0.. even worse idea.
03:58:57 <Zao> Guards are nice.
03:59:13 <quicksilver> just remember 'Croesus'
03:59:37 <Gracenotes> Zao: yes. otherwise... >_>
03:59:48 <fasta> Guards are not nice, since you cannot just move them around, like if then else, although I admit that it looks nicer.
04:00:24 * EvilTerran wishes for "case | ..." notation
04:00:37 <EvilTerran> ... or would "if | ..." make more sense?
04:01:34 <Gracenotes> I wouldn't mind a bool/if function, although it would certainly lead to denser code..
04:01:47 <int-e> I think case makes more sense - it'd be a shortcut for  case () of _ |
04:01:54 <Gracenotes> guards are fine for me
04:02:18 <EvilTerran> "case of" = "\x -> case x of" would also be nice
04:02:32 <Gracenotes> yeah
04:02:43 * EvilTerran ponders trying his hand at some compiler hacking
04:02:59 <EvilTerran> i imagine either would be *relatively* straightforward modifications, seeing as they're both just de-sugarings
04:03:32 <Gracenotes> mm. as long as you don't have to touch the lexer O_O
04:03:34 <quicksilver> there is always vixey's cond
04:03:52 <quicksilver> cond [ foo ---> 1 , bar ---> 2 , baz ---> 3]
04:04:02 <quicksilver> that just uses ---> as a synonym for (,)
04:04:07 <int-e> > let x | odd 1 = 1 | otherwise = 0 in x == case () of _ | odd 1 -> 1 | otherwise -> 0
04:04:09 <lambdabot>   True
04:04:16 <quicksilver> cond :: [(Bool,a)] -> a
04:04:59 <int-e> @type snd . head . filter fst
04:05:00 <lambdabot> forall b. [(Bool, b)] -> b
04:05:34 <quicksilver> yes, that one.
04:05:35 <kadaver> does ghc for windows work for all windows versions, Vista/XP?
04:05:42 <kadaver> at leats the newest ones
04:05:58 <EvilTerran> @type fromJust . lookup id
04:05:59 <lambdabot> forall a b. (Eq (a -> a)) => [(a -> a, b)] -> b
04:06:05 <EvilTerran> uh
04:06:14 <EvilTerran> @type fromJust . lookup True
04:06:15 <lambdabot> forall b. [(Bool, b)] -> b
04:06:37 <int-e> yeah, that's simpler.
04:06:57 <EvilTerran> you have to import fromJust, though
04:07:24 <int-e> @type (listToMaybe .) . filter . (==)
04:07:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe a
04:09:07 <Gracenotes> EvilTerran: plus the shame we all feel when we have to type the name of the unclean function "fromJust"
04:09:39 <Gracenotes> (though in this case an unmatched guard would also be an error :)
04:12:17 <EvilTerran> head's just as bad, too
04:13:19 <quicksilver> it's no worse than an unmatched guard
04:13:32 <ivanm> Gracenotes: fromJust can be useful... e.g. poor man's concatMaybes: map fromJust . filter isJust
04:13:33 <quicksilver> you can always end with , otherwise --> "happy fish"]
04:14:55 <quicksilver> and head can be useful, as in map head . group
04:15:07 <quicksilver> partial functions can be safe.
04:15:24 <quicksilver> large programs tend to contain at least some safe uses of partial functions, in my experience.
04:15:25 <Gracenotes> true
04:17:15 <Gracenotes> ivanm: right, I was considering doing something like that, having to write a function [(Just a, b)] ->[(a, b)]
04:17:34 <Gracenotes> I used mapMaybes, though
04:17:45 <Gracenotes> if you had to you could probably prove to the compiler that you're using it correctly.. and to yourself
04:20:46 <dibblego> is (flip (->) r) a Comonad?
04:21:12 <EvilTerran> i think not
04:21:25 <EvilTerran> Comonads have to still be Functors, don't they?
04:21:31 <dibblego> same, but it's a Cofunctor, since I ..
04:21:34 <dibblego> of course, silly me
04:22:12 <EvilTerran> or is it Comonad ==> Cofunctor? i'm really not sure
04:22:19 <dibblego> no other way
04:22:25 <Gracenotes> Functor, I think?
04:22:46 <dibblego> er yeah, (Functor a) => Comonad a
04:27:53 <quicksilver> Gracenotes: have you seen ndm's program "catch"
04:28:02 <quicksilver> Gracenotes: that is all about proving you're using partial functions correctly
04:28:04 <quicksilver> it's rather nice.
04:30:54 <Gracenotes> *browses program*
04:31:28 <Gracenotes> ooh.
04:31:50 <Gracenotes> codifies constraints, I see
04:51:55 <DanielC> Hi. Is there a "standard" way to make web applications with Haskell? I notice that the "Haskell Server Pages" project appears to be abandoned.
04:51:55 <lambdabot> DanielC: You have 1 new message. '/msg lambdabot @messages' to read it.
04:52:17 <quicksilver> no, there isn't a standard way
04:52:20 <DanielC> Is there anything that is mature and actively maintained?
04:52:29 <quicksilver> happstack appears to be gaining popularity
04:52:46 <quicksilver> I'm not sure any of the frameworks quite qualifies as mature.
04:53:05 <opqdonut> DanielC: have a look at http://hackage.haskell.org/packages/archive/pkg-list.html#cat:web
04:53:07 * DanielC googles for happstack
04:53:55 <DanielC> opqdonut: Yeah, but how do I know which of those are a one-man project from 3 years ago and which ones are active and mature?
04:54:19 <quicksilver> check for mailing list activity, search for blog posts, discussions
04:54:21 * DanielC is looking at the happstack home page
04:55:10 <burp_> happstack is active
04:59:51 <DanielC> Damn it, my IRC connection keeps dying.
05:00:02 <DanielC> I never know for sure if I'm still at the server.
05:00:09 <DanielC> s/still connected/
05:00:38 <nominolo> MarcWeber: well, I put it higher up on my TODO list
05:00:47 <nominolo> I first have to install Vim
05:02:33 <ivanm> anyone know of a math-oriented paper about church numerals, etc. (recent is better)?
05:02:50 <ivanm> I put myself down to do a talk at the math phd journal club in a few weeks, and figured that might be an interesting topic
05:02:57 <MarcWeber> nominolo Ok. It's still on my todo list. There are more important things for me at the moment. Do you remember my branch?
05:03:31 <nominolo> yes, things have changed quite a bit, though.  I'll try to incorporate as much as possible, of course
05:04:06 <MarcWeber> nominolo: Don't hesitate to task if there is any question, please! I'll try to support you as good as I can.
05:04:41 <MarcWeber> nominolo: By the way which things have changed? Have you comitted many changes?
05:05:44 <nominolo> MarcWeber: yes
05:06:05 <nominolo> MarcWeber: and you created some extra directories and things like that
05:07:10 <paul424> I work on windows. What is the best IDE I could get ? I think about Xemacs, but the home page says it rather will report errors
05:07:43 <quicksilver> emacs (not xemacs) is a good coding editor.
05:07:53 <quicksilver> I wouldn't describe it as an IDE, but I find it good for my haskell needs.
05:08:15 <MarcWeber> nominolo The point is: It's more important to me writing a tool automatically generating nix expressions from hackage data.. I haven't had any time left to work on scion :-( Don't think this will change this week.
05:09:11 <nominolo> MarcWeber: there were more people interested in getting scion to work with Vim.  I want to integrate your changes now, so maybe someone can continue from there
05:09:12 <kadaver> god i miss so many haskell idioms in other languages
05:09:38 <kadaver> Maybe is really such a simple ingenious construct
05:09:59 <quicksilver> yeah, Maybe's great.
05:11:38 <paul424> the home page of haskell's xemacs mode says : This release should work on any recent version of Emacs. If it doesn't: complain. If it works on XEmacs, consider yourself lucky." What should  I think ?
05:11:54 <mstr> paul424: get gnu emacs
05:12:03 <ivanm> paul424: does it work?
05:12:17 <insane> quit
05:14:18 <Gracenotes> ugh.. I don't get why I'm specifying colors that get drawn as black :(
05:15:40 <Zao> Gracenotes: Lighting enabled but no lights?
05:16:01 <Gracenotes> :D yay, a primitive surface emerged
05:16:17 <Gilly> speaking of editors - is yi going forwards?
05:16:23 <Gracenotes> the problem was the ordering of filling rectangles with Cairo
05:16:28 <quicksilver> Gilly: I believe so.
05:16:37 <Gracenotes> you have to align the layers just so...
05:17:23 <nominolo> quicksilver: IO (Maybe a) is not great ;)
05:19:54 * Gracenotes always forgets about saving/restoring..
05:19:54 <Gilly> Having a haskell scriptable editor could be nifty :) (Currently I'm mostly a vim user, sometimes I go with emacs, though.)
05:24:49 <luite> Gilly: does that work for you? I always find vim commands in my files i edit in emacs, or switch vim to modes I never even knew existed by typing in emacs commands, unless I stick to a single editor :)
05:25:05 <quicksilver> nominolo: runMaybeT ftw.
05:29:22 <codebliss> What is the point of http://en.wikipedia.org/wiki/Fixed_point_combinator in haskell?  I don't see what it has done to the fact example..
05:30:07 <opqdonut> it has eliminated explicit recursion
05:30:13 <opqdonut> the definition of fact doesn't need to use fact
05:30:54 <codebliss> Oh.  I didn't notice that.  Alright.
05:31:27 <codebliss> So does this eliminate needing to use an accumulator for faster tail-callable functions?
05:31:39 <opqdonut> no
05:31:46 <codebliss> Dang XD
05:32:47 <quicksilver> codebliss: it has no point at all in haskell.
05:32:52 <dons> ?src fix
05:32:53 <lambdabot> fix f = let x = f x in x
05:32:54 <quicksilver> codebliss: because haskell already has recursion.
05:33:06 <dons> it's cute but rarely used
05:33:11 <dons> because it is trivial
05:33:19 <quicksilver> it is an interesting mathematical observation that you can use a fixed point combinator to implement recursion (if you don't have recursion)
05:33:28 <quicksilver> and you can use recrusion to imnplement a fixed point combinator
05:33:33 <Gilly> luite: yea it does :) at one point i liked to edit my latex documents in emacs, do scripts/small coding in vim and manage my C project in emacs again :P
05:33:34 <quicksilver> so they are, in some sense, equivalent.
05:33:48 <quicksilver> fix is only used explicitly to give a "cute" syntax for anonymous recursion.
05:36:48 <lilac> @quote fix
05:36:48 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
05:36:48 <lambdabot> is not fixed.
05:36:50 <lilac> @quote fix
05:36:51 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
05:36:53 <lilac> :(
05:36:57 <lilac> @quote fix
05:36:57 <lambdabot> monochrom says: Monad is about postmodernism. There are laws but no one owns them. You can interpret them any way you want. You can write about your own understanding and the meaning of your writing
05:36:58 <lambdabot> is not fixed.
05:37:12 <lilac> @quote lilac fix
05:37:12 <lambdabot> lilac says: fix f = fix where fix = f fix
05:37:18 <EvilTerran> ?type fmap fix return
05:37:19 <lambdabot> forall a. a -> a
05:37:21 <kadaver> @quote SPJ fix
05:37:21 <lambdabot> No quotes match. Do you think like you type?
05:39:02 <Gracenotes> hurrah, I have rendered an image
05:39:12 <Gracenotes> with my horrible primitive raytracer :o
05:39:20 <codebliss> quicksilver: Thanks, makes perfect sense =P
05:39:54 <idnar> > fmap fix return 20
05:39:56 <lambdabot>   20
05:39:57 <Gabbie> Gracenotes, primitive? It's someone with a felt tip isn't it.
05:40:41 <codebliss> idnar: What is the monad for return 20?
05:40:47 <Gracenotes> :(
05:40:54 <codebliss> idnar: return :: (Monad m) => a -> m a
05:40:55 <Gracenotes> hey, they used a fine tip
05:41:20 <idnar> @type fmap fix
05:41:22 <lambdabot> forall a (f :: * -> *). (Functor f) => f (a -> a) -> f a
05:41:24 <Gabbie> Hehe
05:41:35 <codebliss> idnar: I don't get that example =X
05:41:49 <lilac> codebliss: it's the (->) r monad
05:41:57 <idnar> @type let ?x = return in fmap fix ?x
05:41:59 <lambdabot> forall a. a -> a
05:42:13 <idnar> @type let ?x = return; blah = fmap fix ?x in ?x
05:42:14 <lambdabot> parse error on input `blah'
05:42:16 <codebliss> lilac: I guess the only monads I know of are IO, Maybe, and List XD
05:42:16 <lilac> @type return :: (a -> (a -> a)) -> (a -> a)
05:42:17 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a -> a
05:42:24 <idnar> man, what
05:42:29 <lilac> @type return :: (a -> (a -> a))
05:42:30 <Gracenotes> ;x;x
05:42:30 <lambdabot> forall a. a -> a -> a
05:42:37 <lilac> @type fmap fix :: (a -> (a -> a)) -> (a -> a)
05:42:38 <lambdabot> forall a. (a -> a -> a) -> a -> a
05:42:46 <idnar> @type let ?x = return in let blah = fmap fix ?x in ?x
05:42:48 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
05:43:01 <idnar> hmm, no, that doesn't help
05:43:01 <codebliss> ?x hm?
05:43:01 <lambdabot> Maybe you meant: . ? @ v
05:43:11 <codebliss> You're just stream rolling through my brain XD
05:43:16 <EvilTerran> codebliss, it's the "linear implicit parameters" extension
05:43:17 <Gracenotes> @@
05:43:21 <EvilTerran> ?type ?x + 1
05:43:22 <lambdabot> forall a. (Num a, ?x::a) => a
05:43:30 <lilac> @type fmap fix ?return :: a -> a
05:43:31 <lambdabot>     Could not deduce (?return::a -> a -> a) from the context ()
05:43:31 <lambdabot>       arising from a use of implicit parameter `?return'
05:43:31 <lambdabot>                    at <interactive>:1:9-15
05:43:34 <idnar> @type let blah = fmap fix (return `astypeof` ?x) in ?x
05:43:36 <lambdabot> Not in scope: `astypeof'
05:43:43 <idnar> @type let blah = fmap fix (return `asTypeOf` ?x) in ?x
05:43:44 <lambdabot> forall t. (?x::t) => t
05:43:54 <lilac> @type let return = return in fmap fix ?return :: a -> a
05:43:56 <lambdabot>     Could not deduce (?return::a -> a -> a) from the context ()
05:43:56 <lambdabot>       arising from a use of implicit parameter `?return'
05:43:56 <lambdabot>                    at <interactive>:1:32-38
05:44:01 <lilac> aww
05:44:07 <idnar> @type let blah = fmap fix (?x `asTypeOf` return) in ?x
05:44:08 <lambdabot> forall t. (?x::t) => t
05:44:13 <idnar> grr
05:44:22 <EvilTerran> codebliss, it basically allows you to have these things that let you pass values around more implicitly, by encoding their presence in the type
05:44:23 <Axman6> :t fmap fix return
05:44:24 <lambdabot> forall a. a -> a
05:44:32 <Axman6> > fmap fix return 1
05:44:33 <lambdabot>   1
05:44:36 <idnar> okay, I give up
05:44:42 <EvilTerran> codebliss, but it's generally considered bad style to actually use it for anything serious
05:44:42 <lilac> @type fmap fix ?return
05:44:43 <lambdabot> forall a (f :: * -> *). (Functor f, ?return::f (a -> a)) => f a
05:45:07 <codebliss> EvilTerran: Thanks.  GHCI is blowing up when I try to use it anyway, meh
05:45:19 <lilac> EvilTerran: semantically it's almost the same as a typeclass instance AFAICS...
05:45:23 <ski> @type fmap fix ?return `asTypeOf` fmap fix return
05:45:25 <lambdabot> forall a. (?return::a -> a -> a) => a -> a
05:45:27 <Gracenotes> okay 250000 pixels takes 2 minutes, 20 seconds
05:45:28 <lilac> (only more flexible)
05:45:30 <codebliss> EvilTerran: I haven't really understood anything since it was said how fix is redundant in haskell
05:45:54 <Gracenotes> > show (250000 / 140) ++ " pixels per second"
05:45:55 <lambdabot>   "1785.7142857142858 pixels per second"
05:46:03 <Axman6> :o
05:46:09 <Gracenotes> oh, hrm. :x
05:46:11 <Axman6> Gracenotes: to do what?
05:46:18 <Gracenotes> ray trace
05:46:27 <Axman6> ah, ok.
05:46:36 <Axman6> that's not particularly fast is it?
05:46:52 <EvilTerran> codebliss, :set -XImplicitParams
05:46:53 <lilac> > show (140 * 10^6 / 250000) ++ " microseconds per pixel)
05:46:54 <lambdabot>   <no location info>:
05:46:54 <lambdabot>      lexical error in string/character literal at chara...
05:46:59 <Gracenotes> not too fast, I don't think. This is quite not-optimized, and it's written in Haskell..
05:47:08 <lilac> > show (140 * 10^6 / 250000) ++ " microseconds per pixel"
05:47:09 <lambdabot>   "560.0 microseconds per pixel"
05:48:01 <Gracenotes> one way to make it faster is to accumulate across an array, rather than fold a list to find the minimum
05:48:41 <lilac> Gracenotes: you're not using a BSP / octree / something?
05:49:09 <EvilTerran> wouldn't that be more for polygon-based rendering than raytracing?
05:49:28 <Gracenotes> graphics people. acronyms. aaaarrrrrggggghhhhhhhhhhh.
05:49:35 <Gracenotes> [Â¬Âº-Â°]Â¬
05:49:39 <Philippa__> nope, spatial partitioning makes plenty good sense for raytracing
05:50:04 <lilac> EvilTerran: a lot of time in raytracing goes in, well, tracing rays. space partitioning is good for speeding that up.
05:50:20 <EvilTerran> true
05:50:32 <Gracenotes> hopefully there are some shared calculations I can do to speed it up
05:50:53 <Gracenotes> haven't touched antialiasing yet. In fact, this is for the most part a port of this JavaScript one: http://wiioperasdk.com/raytrace/raytrace.html
05:51:15 <Gracenotes> in terms of the model used, at least.
05:51:25 * Gracenotes plans on reading the book he took out from the library...
05:51:57 <Philippa__> Gracenotes: Binary Space Partitioning, if that helps any. Think binary tree with planes being used to supply the splitting/ordering
05:52:29 <quicksilver> Interestingly UHC claims to implement local instances
05:52:32 <Gracenotes> you mean, divide and conquer, essentially
05:52:36 <quicksilver> I guess UHC stands for 'Unsound Haskell Compiler'
05:52:39 <ivanm> quicksilver: which means?
05:52:50 <Zao> A wild guess would be "Utrecht".
05:52:54 <ivanm> quicksilver: sure it's not "unrobust"? :p
05:52:59 <quicksilver> Zao: I was joking.
05:53:04 <Gracenotes> Philippa__: is there anything special about BSP?
05:53:04 <quicksilver> however, local instances are unsound.
05:53:09 <ivanm> Zao: sshh!!! sense wasn't invited into this conversation...
05:53:09 <Philippa__> Gracenotes: it's a specific form of it
05:53:11 <Zao> Local instances sounds awesome.
05:53:18 <ivanm> quicksilver: what _are_ local instances?
05:53:18 <Zao> I could have used some of those recently.
05:53:22 <Philippa__> and it's well-studieid
05:53:52 <Gracenotes> oh. I did see a chapter on kd-trees in the book.
05:53:56 <Philippa__> quadtrees are more useful if you're modelling 'terrain', which is normally a deformed plane
05:54:12 <Philippa__> k-d trees are a particular form of BSD where the planes are axis aligned :-)
05:54:16 <quicksilver> ivanm: an instance of a typeclass which is local rather than global?
05:54:26 <Gracenotes> that would be true here.
05:54:26 <ivanm> quicksilver: well, yes, but local to what?
05:54:30 <ivanm> as in it's not exported?
05:54:32 * quicksilver struggles to re-order the words in a different way to trigger lightbulb in ivanm's mind.
05:54:32 * ski idly wonders if there's a later version of the bristol haskell system
05:54:35 <ivanm> or an instance inside a function definition?
05:54:39 <quicksilver> a particul scope, I assume.
05:54:44 <Philippa__> makes it cheaper to do the "which side am I on?" test
05:54:51 <ivanm> how "particular" is the scope though?
05:55:03 <ivanm> an instance within a module _might_ make sense
05:55:04 <quicksilver> I assume any old scope of your choice
05:55:05 <Gracenotes> anyway, a few hours spent debugging that... eerghk.
05:55:09 <ivanm> an instance within a function doesn't
05:55:21 <Philippa__> yeah, and there're numerics issues with them
05:57:24 <quicksilver> ivanm: GHC already supports module-local instances, which is a known and reported bug.
05:58:00 <ivanm> oh? as in it's not meant to? or it actually has an extension to do so?
05:58:24 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/2356
05:58:27 <quicksilver> it's a bug.
05:58:32 <quicksilver> it's a clear violation of the haskell spec
05:58:38 <quicksilver> and, unsound, as I have been saying :)
05:59:54 <ivanm> "Currently this is by design." <-- oh?!?!?! :s
06:01:16 <quicksilver> they mean, it's hard to fix and they don't want to
06:01:26 <quicksilver> it is however, unsound, wrong, immoral, and reprehensible
06:01:33 <quicksilver> it may even be an example of turpitude.
06:02:24 <quicksilver> I think the set example (pasted although not devised by Igloo) makes the point clearly enough.
06:03:15 <ivanm> quicksilver: "immoral" might be going a _bit_ far
06:03:53 <mmorrow> heh
06:04:37 <jelly12gen> hi is there a way to execute two functions in one guard statement ?
06:04:58 <Gracenotes> &&?
06:05:35 <jelly12gen> Gracenotes: that makes a bool of the return value
06:05:37 <Axman6> jelly12gen: like what?
06:05:57 <mmorrow> quicksilver: your graph viewer just motivated me to hack on my graphviz-interface->opengl-image viewer for the past hour or two :)
06:06:01 <Axman6> f x | p x = g (h x) ?
06:06:19 <mmorrow> now, un-sidetracking...where was i.. ;)
06:06:26 <jelly12gen> Axman6: i have an recursive function  , wich needs too do two calls for a function in one card statement
06:06:26 <Gracenotes> jelly12gen: well, if you want to check two things in the guard, it's the way to go. I don't quite get what you mean,.
06:06:52 <jelly12gen> Gracenotes: is there an allways function in guard that always does some action ..?
06:07:14 <Gracenotes> | otherwise = ... always do this ...
06:07:21 <Gracenotes> > otherwise
06:07:23 <lambdabot>   True
06:07:25 <osfameron> why not just do the action before the guard if you always want to do it?
06:07:45 <Gracenotes> the first part of a guard is just a boolean value
06:08:02 <Gracenotes> however, that's more of a fall-back case.
06:08:13 <jelly12gen> Gracenotes i need it to run always
06:08:18 <Gracenotes> if no other case succeeds.
06:08:26 <Gracenotes> jelly12gen: perhaps you want a 'where'?
06:08:37 <Gracenotes> running it outside of the guard, as osfameron said
06:08:38 <kadaver> are the haskell OSes better than the Java OSes?
06:09:13 <Axman6> they're totz better
06:09:18 <jelly12gen> Gracenotes: well i am doing a binary true
06:09:24 <jelly12gen> *tree
06:09:26 <kadaver> totz?
06:09:27 <Axman6> heh
06:09:43 <kadaver> forver
06:09:46 <kadaver> @type forever
06:09:47 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
06:10:16 <Gracenotes> jelly12gen: well, you can make more than one recursive call in an expression
06:10:24 <p_l> kadaver: The only one I really read on wasn't that much different, they simply used Haskell to make it easier to determine state of the system....
06:10:31 <jelly12gen> Gracenotes: like if then else
06:10:35 <jelly12gen> Gracenotes: thanks
06:10:37 <Gracenotes> wha
06:10:47 <jelly12gen> i got an idea :)
06:10:52 <Gracenotes> > if 3 > 4 then "yes" else "no"
06:10:54 <lambdabot>   "no"
06:11:05 <jelly12gen> Gracenotes: i get itt
06:11:33 <kadaver> p_l: different than what? the JAVA approach or the standard (linux approach)?
06:12:07 <Gracenotes> jelly12gen: okay. chances are there's some syntax or function that allows you to do what you want -- otherwise there's are more Haskell-y way to do it :)
06:12:07 <p_l> kadaver: No, they wouldn't really work as Java. It's too heavyweight of language :D
06:12:18 <Gracenotes> s/are/a/
06:12:30 <Stinger> does haskell have a usb lib?
06:13:00 <p_l> kadaver: The one I know used haskell mainly in order to do formal proofing of security
06:14:35 <p_l> kadaver: A security-oriented variant of L4 nanokernel
06:15:34 <EvilTerran> Stinger, i don't think so, although it shouldn't be too hard to rig in a C one
06:20:40 <kadaver> ok
06:26:40 <cjs> p_l: not that I know of, but it would be pretty easy to do an FFI interface into libusb.
06:27:09 <p_l> cjs: that was Stinger :D
06:27:23 <cjs> Oops. Names are too similar. :-)
06:27:31 <p_l> ... lol?
06:27:48 <Stinger> ok then
06:28:26 <cjs> Stinger: I've done FFI stuff before, and it's dead easy. You won't need to write a line of C.
06:28:56 <Stinger> heh the Haskell part would probably be the problem if I were to try
06:29:37 <cjs> Honestly, I doubt it. If you know C already, writing FFI Haskell is like writing C, except with a much, much better type-checker.
06:30:05 <osfameron> dammit, Gatwick is so near London but so far after a day's work... (I think I'll miss dons's talk tonight :-(
06:30:27 <Stinger> you underestimate my Haskell noobness, I'd probably have to learn bytestrings first
06:30:39 <jmcarthur> yeah, Haskell's FFI to C is surprisingly easier than many imperative languages' FFIs
06:31:16 <jmcarthur> i did FFI as a noob without any major hitches
06:31:25 <sgcummin> as did I
06:31:29 <p_l> I dunno if there's Swing binding for Haskell...
06:31:29 <kadaver> yes the FFI is excellent
06:31:42 <kadaver> Swing is pure Java right?
06:31:56 <p_l> *Swig
06:32:01 <kadaver> ah
06:32:04 <bpalmer> part of it is built on the AWT, which uses native bindings.
06:32:20 <kadaver> I still can't figure out how to play mp3s via haskell which is a shame
06:32:23 <p_l> Java GUIs are awful. They do not work under XMOnad :/
06:32:24 <bpalmer> (Swing, that is)
06:32:26 <Stinger> heh well I'm not so solid on the usb part as it is, so I'd be adding points of failure to something thats already going to take some debugging
06:32:41 <Stinger> mebbe after I get it working in C
06:32:44 <kadaver> i find swing to be very neat. look good without doing anything special and easy toprogram
06:33:10 <p_l> now if it only worked...
06:33:19 <bpalmer> I like Swing (or did, back when I was doing java); best toolkit I've worked with.
06:33:52 <p_l> I don't have anything against Swing's API (it could be worse), but the implementation... maaaan
06:34:11 <kadaver> the gtk bindings for haskell are also great though, jsut gtk looks uglier than swing by default
06:34:26 <kadaver> p_l: what about the implementation?
06:35:02 <p_l> kadaver: It fails under non-reparenting wms, especially tiling ones. I can understand OpenGenera failing, but Swing?
06:35:08 <malosh> Hi. How do I iterate a (a->IO ()) function on arrays like I would do with mapM on lists ?
06:35:21 <amaron_>  kadaver: gtk themes may make it beautiful
06:36:29 <blackh> malosh: mapM action (toList a)
06:36:52 <EvilTerran> malosh, Arrays are Traversable
06:37:06 <EvilTerran> ?type Data.Traversable.mapM
06:37:07 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Traversable.Traversable t) => (a -> m b) -> t a -> m (t b)
06:38:08 <blackh> EvilTerran: I like that answer!
06:38:22 <malosh> blackh : I want something efficient
06:38:28 <malosh> EvilTerran : thanks !
06:38:46 <blackh> malosh: Don't assume mapM x (toList a) is inefficient!
06:38:54 <EvilTerran> ?type Data.Traversable.mapM :: (a -> IO ()) -> Array i a -> IO (Array i ())
06:38:55 <lambdabot>     Could not deduce (Ix i) from the context ()
06:38:55 <lambdabot>       arising from a use of `Data.Traversable.mapM'
06:38:55 <lambdabot>                    at <interactive>:1:0-20
06:39:01 <EvilTerran> ?type Data.Traversable.mapM :: Ix i => (a -> IO ()) -> Array i a -> IO (Array i ())
06:39:02 <lambdabot> forall a i. (Ix i) => (a -> IO ()) -> Array i a -> IO (Array i ())
06:39:05 <malosh> doesn't it convert my array to a list ?
06:39:15 <blackh> malosh: (Though EvilTerran's answer is better than mine.)
06:39:17 <malosh> (i mean with a toList)
06:39:28 <EvilTerran> the problem with the Traversable version is you do get a gratuitous Array i () being built up
06:40:21 <EvilTerran> ?type Data.Foldable.mapM_ :: Ix i => (a -> IO b) -> Array i a -> IO ()
06:40:22 <lambdabot> forall a b i. (Ix i) => (a -> IO b) -> Array i a -> IO ()
06:40:26 <ddarius> EvilTerran: With an adaptive array type, making a (strict) array of () could be -very- cheap.
06:40:29 <EvilTerran> malosh, there's the function to use
06:40:50 <malosh> ok thanks !
06:41:33 <EvilTerran> malosh, note there's a "mapM_" in the Prelude, so you'll need to "import qualified Data.Foldable as F" or something
06:41:44 <malosh> yes of course
06:46:27 <petermarks> Is HList something that could be used in a real-world project or is it crazy "look at the hoops GHC can jump through" stuff?
06:48:20 <Axman6> mor elike look at the hoops Oleg can jump through
06:49:20 <petermarks> Axman6: so it is way off the crazy scale then?
06:49:32 <Axman6> as far as i know, yes
06:49:53 <fasta> petermarks: I can imagine it is going to be slow for large projects and you need to get it to compile first, which was not possible 5 months ago.
06:50:16 <petermarks> so what is the sane route for extensible records then?
06:50:49 <Axman6> Strings
06:50:50 <Axman6> >_>
06:52:12 <petermarks> Axman6: hmm, I think Dynamics would be a step up from that
06:52:36 <Axman6> probably. it's not something i've ever looked into really
06:55:00 <Axman6> so, apparently Oracle are getting lots of errors connecting to the DB for their website since this sun news has come about... which is awesome for a database company
06:56:31 <kadaver> anyone know of a song which can be played with "pure" chords? liek twinkle little star maybe. just a fe ones. can you anme them eve n :P
06:56:57 <kadaver> how do you get real 8-bit sounds? I want to do old school computer game music in haskore
06:58:21 <blackh> Axman6: Oracle bought Sun That's nuts. I was more upset when they bought SleepyCat.
06:58:38 <Axman6> i'm pretty upset too :(
06:59:46 <blackh> Headline should read: Memory manufacturer shares soar as industry bloats out
07:00:41 <gnuvince> It makes sens though, doesn't it?  Oracle needs big iron to run (Solaris) and is a heavy user of Java.  Plus, they can kill an open source competitor :)
07:01:23 <kadaver> is Oracle objectively better than POSTGRESQL?
07:01:35 <kadaver> i mean there must be a reason people pay for it...?
07:01:55 <gnuvince> kadaver: I don't know about better, but I imagine managers *think* it's better.
07:01:57 <Axman6> they also own MySQL
07:02:06 <quicksilver> petermarks: I think HList is more a proof of concept - here are some things you can make the type system do.
07:02:17 <quicksilver> petermarks: if you find interesting techniques there, you can implement them
07:02:18 <blackh> kadaver: Oracle is junk
07:02:24 <gnuvince> "If they charge $20,000, it *must* be good!"
07:02:37 <quicksilver> I would personally steer clear of anything which requires Overlapping or Incoherent instances though.
07:02:46 <kadaver> if someone pays 20K$ it must be decent...
07:03:37 <quicksilver> there are some objective reasons that oracle is better. They are not relevant to most people. They are tremendously important to a small number.
07:04:28 <Gracenotes> client support goes a long way
07:04:42 <petermarks> quicksilver: thanks. why should overlapping or incoherent instances be avoided?
07:05:30 <quicksilver> petermarks: because they are, to a greater or lesser extent, unsound.
07:05:39 <quicksilver> they mean adding new code can change existing code in a surprising way
07:05:42 <quicksilver> that's never nice.
07:07:03 <petermarks> quicksilver: ok, thanks, I understand that. I am kind of used to that from the OO world though.
07:08:35 <quicksilver> sure, people who escape from restrictive regimes are often used to being hungry and scared; however it doesn't mean they need to keep on feeling that way in their new life ;)
07:09:06 <Gracenotes> it is somewhat common in Java. If (blah is instanceof Foo) { ... } else { ... }
07:09:40 <Gracenotes> one example of overlapping instances. if Foo is a subtype of Bar. maybe.
07:09:49 <blackh> quicksilver, petermarks: I remember when I was learning Haskell by doing a big project in it, I wrote brilliant code. The only trouble was, my standards got higher and I had to re-write most of it.
07:10:07 <EvilTerran> indeed, java-style method overloading is very similar in some respects to overlapping instances
07:10:10 <Gracenotes> such code depends on downwards casting and other stuff that breaks the OOP pattern
07:10:24 <petermarks> quicksilver: fair point, just lots to unlearn
07:10:54 <cjs> petermarks: You'll find quite a few things you do in the OO world disappear, and you do miss them at first. The feeling goes away; the restrictions have their good reasons.
07:10:57 <Gracenotes> EvilTerran: oh, that too
07:11:25 <Gracenotes> although in a different sense, if typeclasses are taken to be analogues of interfaces, I guess
07:11:48 <cjs> If you did the structured-to-OO transition, expect the OO-to-Haskell transition to be about three times as hard.
07:12:21 <Gracenotes> hmm.
07:12:25 <quicksilver> EvilTerran: that broke the java 1.0 to 1.1 upgrade
07:12:38 <petermarks> Gracenotes: there are much more elegant example of this sort of behaviour in OO. What I mean is even "good" OO design can lead to unexpected side effects when extending.
07:12:45 <quicksilver> EvilTerran: the compiler noticed at compiler time that some virtual methods were not overridden in fact, so it generated direct jumps.
07:13:03 <quicksilver> EvilTerran: then, when I upgraded to 1.1 - without recompiling my entire file - I had broken behaviour
07:13:24 <quicksilver> EvilTerran: because some standard library method, previously not overriden, was in 1.1
07:13:39 <Gracenotes> mm. binary compatibility between releases of anything is sorta suspect..
07:13:46 <quicksilver> EvilTerran: of course, upgrading a whole library version without a recompile was a lot to ask for, but ittook me a while to track that down :)
07:13:59 <quicksilver> Gracenotes: not really, linux shared libraries manage it all the time.
07:14:40 <Gracenotes> ah. perhaps I've been bit by needing to recompile more than a few times, then :\
07:15:52 <quicksilver> cjs: I didn't find it so, but then I was much younger when I did the structured-to-OO transition
07:16:46 <cjs> Really? And you were up on all the libraries, uses of Functors, Applicative, Monoids, Monads, all that stuff, in about the same amount of time?
07:17:28 <quicksilver> well the structred-to-OO transition took me years :)
07:18:04 <cjs> It's not that, after a year of almost-full-time, I'm uncomfortable in Haskell, but there's so much clever stuff still waiting for me to learn it....
07:18:31 <cjs> Ah, well, it took me about two years, but then again, I wasn't programming a huge amount at that time.
07:18:39 <quicksilver> but isn't that true of any system?
07:18:45 <cjs> Maybe I'm just much older but still dumb. :-)
07:19:01 <quicksilver> I mean you could be using .NET (*cough*) and still there is more clever stuff waiting to learn.
07:19:11 <petermarks> Gracenotes: my brain does see ï»¿typeclasses as analogues of interfaces. Having said that I've grokked multi-parameter typeclasses ok.
07:19:22 <codebliss> I don't get the error on this func.  It says zipWith has too few arguments.  compareResults = foldl (&&) True . zipWith (==)
07:19:23 <cjs> quicksilver: No, I wouldn't say that there's a huge learning space left for me in OO at this point. Sure, lots of tricks, but in terms of fundemental new techniques?
07:19:30 * quicksilver nods
07:19:43 <vixey> codebliss shouldn't write foldl (&&) True
07:19:44 <quicksilver> maybe the new haskell isn't isn't as fundamental as you imagine, either :)
07:19:54 <KickTheKadaver> im making deadly cool ninja-music with haskore
07:19:56 <Gracenotes> petermarks: yeah... multiple dispatch isn't a very OOP thing, though :P
07:20:00 <cjs> Oh, I look at things like Applicative, and I can see that it is.
07:20:03 <quicksilver> codebliss: zipWith(==) is a binary function
07:20:06 <Gracenotes> although CLOS people might disagree
07:20:10 <quicksilver> codebliss: . composes unary functions
07:20:19 <Axman6> codebliss: yeah, that's one of those things many people run into. just nme the params and you'll have better results...
07:20:28 <lilac> vixey: yeah, 'foldr' or 'and' would be much better
07:20:29 <codebliss> I want to test for identical outputs, like so.  compareResults (foo x) (foo' x)
07:20:31 <Philippa__> KickTheKadaver: cool
07:20:38 <codebliss> Axman6: Okay, thanks
07:20:38 <Gracenotes> o nos :x
07:20:42 <quicksilver> codebliss: yes, I can see what your'e trying to do.
07:20:45 <quicksilver> just explaining why.
07:20:53 <codebliss> quicksilver: So don't go points-free?
07:21:00 <skorpan> in the old-locale package, i find 'rfc822DateFormat = "%a, %_d %b %Y %H:%M:%S %Z"'... surely "%_d" is supposed to be "%d", no?
07:21:31 <quicksilver> @pl \x y -> foldl (&&) True (zipWith (==) x y)
07:21:32 <lambdabot> (foldl (&&) True .) . zipWith (==)
07:21:41 <quicksilver> codebliss: you can do, but it looks funny
07:21:49 <quicksilver> unless you're used to how it looks :)
07:22:57 <Gracenotes> @type let (a .^ b) c d = a (b c d) in foldl (&&) True .^ zipWith (==)
07:22:59 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
07:23:38 <Gracenotes> heh. well, it type-checks. at least.
07:24:07 * vixey hits Gracenotes with a bamboo stick
07:24:44 <Gracenotes> with my ingenious new combinator I shall make millions!
07:25:29 * quicksilver ponders selling combinators as iPhone apps on the iTunes store.
07:25:36 --- mode: irc.freenode.net set +o ChanServ
07:26:07 <quicksilver> welcome back ChanServ
07:26:29 <osfameron> Gracenotes: there's combinators in them thar hills!
07:27:48 <codebliss> quicksilver: compareResults f g xs = foldl (&&) True $ zipWith (==) (map f xs) (map g xs)
07:28:03 * KickTheKadaver ponders selling haskore ninja songs as iphone apps
07:28:21 * KickTheKadaver ponders if KickTheKadaver is a cool name for a band
07:28:49 <centrinia__> Haskore?
07:28:56 <KickTheKadaver> haskellmusicliv
07:29:04 <KickTheKadaver> haskell music lib
07:29:15 <KickTheKadaver> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskore
07:29:15 <codebliss> HML is a cool acronym XD
07:29:31 <codebliss> Ah, cool.  LOL HASKORE, awesome
07:32:08 <BONUS> also foldl (&&) True = and
07:32:09 <BONUS> afaik
07:32:10 <BONUS> @src and
07:32:11 <lambdabot> and   =  foldr (&&) True
07:32:27 <Gracenotes> foldr chosen for its terminating powers
07:33:12 * Axman6 wants to @remember Gracenotes foldr chosen for its magical evil terminating powers
07:34:24 <Gracenotes> M-m-m-m-m-make it so. Make it so. Make it so.
07:34:30 <Gracenotes> ... m-m-m-m-m-make it so. Make it so. Make it so.
07:34:34 <Gracenotes> /picard
07:34:43 <Gracenotes> okay, foldr isn't that evil :(
07:35:00 <blackh> foldr is glorious!
07:35:07 <Axman6> indeed
07:38:02 <doserj> compareResults f g = all (liftM2 (==) f g)
07:41:12 <BONUS> umm
07:41:20 <blackh> compareResults f g = all `dot2` liftM (==) where dot2 = (.).(.)    <-- I think
07:41:22 <BONUS> > liftM2 (==) [1,2,3] [2,3,4]
07:41:23 <lambdabot>   [False,False,False,True,False,False,False,True,False]
07:41:31 <KickTheKadaver> example of when foldr terminates and foldl doesnt? foldl isnt lazy?
07:41:45 <KickTheKadaver> liftM (==1) [1,2,3]
07:41:47 <Gracenotes> more zipping, less cartesian-ing
07:41:48 <KickTheKadaver> > liftM (==1) [1,2,3]
07:41:49 <lambdabot>   [True,False,False]
07:42:03 <blackh> I mean compareResults = all `dot2` liftM2 (==) where dot2 = (.).(.)
07:42:07 <KickTheKadaver> > map (==1) [1,2,3]
07:42:08 <BONUS> > foldl (&&) [False..]
07:42:08 <lambdabot>   [True,False,False]
07:42:09 <lambdabot>   <no location info>: parse error on input `]'
07:42:16 <Axman6> > foldl (||) $ [True] ++ repeat False
07:42:17 <lambdabot>   Couldn't match expected type `Bool' against inferred type `[Bool]'
07:42:29 <BONUS> foldl won't terminate on infinite lists
07:42:32 <Axman6> > foldl (||) True $ repeat False
07:42:35 <BONUS> foldr will
07:42:39 <Axman6> > foldr (||) True $ repeat False
07:42:52 <Axman6> you fail lambdabot
07:43:22 <Gracenotes> it'll stop if there's something to stop on
07:43:24 <vixey> @src and
07:43:26 <vixey> @src or
07:43:27 <dax> (.).(.) looks dirty.
07:43:47 <vixey> dax I don't even wanna /guess/ what species you are
07:43:48 <Gracenotes> ... or if it's working at all
07:43:49 <Axman6> Haskell: making boobs useful once again!
07:43:54 <Gracenotes> , (foldr (&&) True (False:repeat True), foldr (||) False (True:repeat False))
07:43:57 <lunabot>  (False,True)
07:44:18 <Axman6> oh fine then
07:44:24 <Axman6> whatever, i don't even like you lambdabot
07:44:33 <Axman6> oh, that was lunabot
07:44:36 <Gracenotes> <it... hears... you...>
07:44:42 <endojelly> is there no string split function?
07:44:50 <Axman6> , foldl (||) True $ repeat False
07:44:52 <vixey> endojelly dunno split could mean a multitude of things
07:44:53 <lunabot>  luna: out of memory (requested 1048576 bytes)
07:44:55 <dax> i like  lift ((*)(*))  even more
07:44:59 <Axman6> , foldr (||) True $ repeat False
07:45:05 <lunabot>  Killed.
07:45:10 <Axman6> :\
07:45:15 <endojelly> vixey, [a] -> a -> [[a]]
07:45:19 <vixey> dax can't see that being anything but a type error
07:45:24 <quicksilver> Axman6: "once again" ?
07:45:40 <vixey> endojelly, no but you can use unfoldr to define it
07:45:40 <quicksilver> Axman6: 10 million breastfeeding babies attest to them being pretty useful even without haskell's help :P
07:45:41 <Axman6> :)
07:45:41 <endojelly> vixey, or [a] -> [a] -> [[a]], i don't care
07:45:51 <dax> but its my own type error :/
07:46:00 <endojelly> then I'll do that
07:46:00 <Axman6> quicksilver: there in lies the joke :P
07:46:09 <lambdabot>   thread killed
07:46:09 <lambdabot> and   =  foldr (&&) True
07:46:09 <lambdabot> or    =  foldr (||) False
07:46:38 <dax> liftM2 ((*)(*))
07:46:42 <dax> that works.
07:46:50 <vixey> :t liftM2 ((*)(*))
07:46:53 <lambdabot> forall a (m :: * -> *). (Monad m, Num (a -> a -> a), Num a) => m (a -> a -> a) -> m a -> m (a -> a)
07:46:57 <Axman6> :t liftM2 ((*)(*))
07:46:58 <lambdabot> forall a (m :: * -> *). (Monad m, Num (a -> a -> a), Num a) => m (a -> a -> a) -> m a -> m (a -> a)
07:46:59 <Axman6> bah
07:47:19 <dax> and it's looks even better >.<
07:47:34 <Axman6> what the crap is that even useful for?
07:47:44 <skorpan> how come i can do "type TT = something; instance (MyDataType TT) where" but not "type TT = something; instance TT where" using flexible instances?
07:47:47 <vixey> it's a type error..
07:48:16 <vixey> skorpan did you mean instance (MyDataType TT) where ?
07:48:23 <skorpan> vixey: yes
07:48:50 <Gracenotes> @type ((*)*(*))
07:48:52 <lambdabot> forall a. (Num (a -> a -> a), Num a) => a -> a -> a
07:49:07 <Axman6> > ((*)*(*)) 3 5
07:49:09 <lambdabot>       No instance for (Num (a -> a -> a))
07:49:09 <lambdabot>        arising from a use of `*' at...
07:49:27 <Axman6> oh right
07:49:49 <Gracenotes> yeah, we have no Num c => (a -> b -> c) instance. which comes from Num b => (a -> b) instance...
07:49:58 <Gracenotes> potentially
07:50:22 <dax> lets write one.
07:50:54 <Gracenotes> you can. Although don't include it by default...
07:51:28 <Gracenotes> weird error messages mostly :P
07:51:32 <quicksilver> skorpan: it overlaps/conflicts with another instances, perhap.
07:52:19 <skorpan> i just realized i had a mistake in my question
07:53:16 <skorpan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3981#a3981
07:53:56 <quicksilver> would you like to tell us what the error is?
07:54:04 <quicksilver> or is that a secret, designed to make it harder to help you? :P
07:54:29 <skorpan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3981#a3982 <- the error
07:55:05 <skorpan> okay, so that's no type error.. but yeah.
07:55:14 <dolio> That error tells you what the problem is.
07:55:18 <dolio> You need a language extension.
07:55:23 <skorpan> yes, but why?
07:55:39 <quicksilver> because haskell 98 says you can't do that.
07:55:41 <skorpan> well, yeah
07:55:46 <skorpan> i just realized that was a silly questoin
07:55:47 <skorpan> thanks
07:56:40 <quicksilver> I think it might have been disallowed becayse allowing instances for type synonyms rather implies you can have different instances for different synonyms of the same type
07:56:44 <quicksilver> which you can't
07:56:46 <quicksilver> but that's only a guess.
07:56:56 <skorpan> makes sense
07:56:56 <quicksilver> the restrictions on instance for in h98 were pretty sever.
07:58:32 <doserj> with type synonyms it is also not so obvious (to the user) whether the instace has the form T a b ..., which is another problem that skorpan will have :)
07:58:37 <petermarks> Anyone here going to Don's talk tonight at London HUG?
07:59:37 <bwr> i would if i was in london
07:59:50 <Axman6> i would if i were on earth
08:00:04 <p_l> Axman6: orbital assignment? or outer space? :D
08:00:21 <Axman6> depends on whether i need supplies
08:00:45 <p_l> Axman6: I'd say it depends how far you're willing to go :)
08:00:56 <mornfall> Hi, anyone knows something about gitit? I am getting HTTP request failed with: Unsupported socket ... it seems to be somewhere in HTTP library when trying to figure the peer address.
08:03:57 <mornfall> Ah, hm, happstack problem.
08:04:08 <malosh> Is it possible to foldr a function on DiffArrays ?
08:04:59 <dolio> @instances-importing Data.Foldable Data.Array.Diff Foldable
08:05:01 <lambdabot> Array i, Maybe, []
08:05:26 <malosh> ok
08:05:26 <quicksilver> malosh: as an aside, DiffArrays are a cool idea but don't work very well in prctice.
08:05:51 <dolio> Apparently the answer is "no".
08:05:51 <malosh> yes, but I need the go-back feature
08:06:09 <malosh> dolio : guessed it ;-)
08:06:24 <quicksilver> malosh: just store save old versons of the data in the obvious way.
08:06:27 <dolio> There's no reason in principle why you couldn't do it, but there's no Foldable instance for it.
08:06:32 <quicksilver> or use a Map instead of an array
08:06:45 <quicksilver> which has the go-back feature atuomatically
08:06:49 <quicksilver> and can be partial sharing etc.
08:06:50 <malosh> quicksilver : why do you say they don't work well ?
08:07:05 <dolio> They aren't as fast as advertised.
08:07:18 <quicksilver> malosh: they turn out not to have the speed advantage you'd hope
08:07:25 <malosh> ok
08:07:31 <quicksilver> it turns out to be fast to use Data.Map, or just normal Arrays and makes lots of copies.
08:07:43 <quicksilver> Data.Map is a whole lot more pleasant to program with to
08:07:49 <quicksilver> unless your arrays have 100s of millions of elements.
08:08:02 <malosh> i'll check
08:11:20 <jmcarthur> what exactly is the speed penalty that DiffArrays have the make them so useless? is it just a bad constant factor?
08:11:49 <KickTheKadaver> man i wish i had at least half a music ear
08:12:31 <quicksilver> jmcarthur: I don't know, I'm just repeating hearsay.
08:12:56 <jmcarthur> yeah, i've repeated the same hearsay too
08:13:26 <quicksilver> cargo-culting advice++
08:13:39 <dolio> Every write involves managing some list of changes in case you need to revert to an old array. So that's a constant factor at least, I imagine.
08:14:03 <dolio> As well as every read and write checking if you're using the latest version, and if you're not, making a copy.
08:14:41 <jmcarthur> dolio, that's all i can think of too. and yet it doesn't seem like it should be _that_ much overhead
08:14:43 <dolio> Well, perhaps not a copy for the read.
08:15:16 <jmcarthur> then again, maybe the speed penalty that people speak of is actually the cost of getting one of the older versions
08:15:26 <jmcarthur> if it is many generations back, that could be bad
08:15:43 <dolio> Yeah, if you fail to use it in a single-threaded manner, you'd doing copying *and* managing the change list.
08:23:26 <Axman6> @quote InvaderJ
08:23:26 <lambdabot> InvaderJ says: one wormhole near his boy parts, other wormhole near his lady's girl parts. blam, kids. (RE: Steven Hawking having three kids)
08:24:26 <kadaver> Stephwn Hawking is in bad health in hospital in Cambridge right now
08:24:59 <Axman6> yeah,t aht's why he came up
08:25:48 <vixey> #haskell-blah
08:28:38 <dolio> So, I just did some benchmarking...
08:29:05 <dolio> DiffArray is significantly faster than Array, provided you actually use it single-threaded.
08:29:07 <dolio> As expected.
08:29:14 * QtPlaty[HireMe] has been reading through the GHC source and the libaries (esp prelude and its dependancies) "What does it mean when a constructor name ends with a '#'? 
08:29:18 <dolio> But it isn't faster than IntMap. :)
08:30:07 <kadaver> is intmap just a c-array?
08:30:13 <quicksilver> no.
08:30:19 <quicksilver> it's a patricia tree
08:30:19 <dolio> IntMap is a trie.
08:30:25 <quicksilver> (as it says in its docs, IIRC)
08:30:28 <Axman6> @src IntMap
08:30:29 <lambdabot> Source not found. Where did you learn to type?
08:30:31 <Axman6> :(
08:30:45 <kadaver> @src Map
08:30:45 <lambdabot> Source not found. My mind is going. I can feel it.
08:30:49 <Axman6> what's a patricia tree?
08:31:00 <sgcummin> it's a compressed Trie
08:31:06 <dolio> Even DiffUArray doesn't seem to be faster than IntMap.
08:31:08 <kadaver> radix tree
08:31:17 <QtPlaty[HireMe]> Axman6: Its used in routing.
08:31:18 <kadaver> http://en.wikipedia.org/wiki/Patricia_tree
08:31:38 <dolio> Large DiffArrays appear to suffer fromthe same GC stuff as Data.HashTable.
08:31:42 <dolio> Unsurprisingly.
08:33:21 <Axman6> > 26^26
08:33:23 <lambdabot>   6156119580207157310796674288400203776
08:33:38 <vixey> > 27^27
08:33:40 <lambdabot>   443426488243037769948249630619149892803
08:35:59 <jedai> QtPlaty[HireMe]: Generally it means you're speaking about unboxed versions
08:36:51 <jedai> QtPlaty[HireMe]: I# take an Int# (in other word a machine int)
08:38:18 <jedai> QtPlaty[HireMe]: As far as I know it's just a convention, and only used internally, ideally you should never see it outside GHC source
08:38:27 * QtPlaty[HireMe] nods.
08:38:48 <kadaver> the cost of a hashing functions is ignoreable?
08:39:23 <wli> kadaver: It depends.
08:39:42 <wli> kadaver: If you're doing MD5 sums on huge strings they're not.
08:41:01 <QtPlaty[HireMe]> kadaver: What is your indended use?
08:49:54 <dolio> Wow, 'let x = 42 in x == 42 == True' is supposed to parse as '(let x = 42 in x == 42) == True'.
08:50:35 <kadaver> well at least: (-1) == 1 doesn't return True
08:50:42 <seliopou> dolio: lisp/scheme ftw! :D
08:50:49 <kadaver> > let x = (-1) in x == 1
08:50:50 <lambdabot>   False
08:50:50 <vixey> > let x = True in x == True == x
08:50:51 <lambdabot>       precedence parsing error
08:50:52 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
08:50:56 <vixey> > let x = True in x == True == True
08:50:57 <lambdabot>       precedence parsing error
08:50:57 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
08:51:14 <kadaver> can you import in lambabot?
08:51:21 <quicksilver> no
08:51:21 <kadaver> what modules does she have loaded?
08:51:24 <quicksilver> lots.
08:51:36 <quicksilver> but you can only find out which by asking the maintainer
08:51:37 <kadaver> > insert 10 empty
08:51:38 <lambdabot>       Ambiguous occurrence `empty'
08:51:38 <lambdabot>      It could refer to either `Text.Pretty...
08:51:47 <kadaver> > Map.insert 10 Map.empty
08:51:47 <quicksilver> although you can find out what the default is by looking at the source
08:51:48 <lambdabot>       Overlapping instances for Show
08:51:48 <lambdabot>                                  (M.Map ...
08:51:52 <seliopou> I was unaware lambdabot had been sexed
08:52:12 <kadaver> > Map.delete 10 $ Map.insert 10 30 Map.empty
08:52:13 <lambdabot>   fromList []
08:52:19 <kadaver> > Map.insert 10 30 Map.empty
08:52:20 <lambdabot>   fromList [(10,30)]
08:52:35 <kadaver> > Map.adjust 10 (+1) $ Map.insert 10 30 Map.empty
08:52:36 <lambdabot>       No instance for (Ord (a1 -> a1))
08:52:36 <lambdabot>        arising from a use of `M.adjust...
08:52:45 <kadaver> > Map.adjust (+1) 10 $ Map.insert 10 30 Map.empty
08:52:46 <lambdabot>   fromList [(10,31)]
08:52:50 <kadaver> > Map.adjust (+1) 101 $ Map.insert 10 30 Map.empty
08:52:51 <lambdabot>   fromList [(10,30)]
08:53:40 <kadaver> so what if you want t construct varying-level Markov-Map of a text. so each value could be a new Map. that isn't possible right?
08:53:51 <kadaver> @sex lambdabot
08:53:51 <lambdabot> Maybe you meant: let seen src thx
08:54:00 <kadaver> @type lmbdabot
08:54:01 <lambdabot> Not in scope: `lmbdabot'
08:54:03 <kadaver> @type lambdabot
08:54:04 <lambdabot> Not in scope: `lambdabot'
08:54:10 <kadaver> @faq lambdabot
08:54:10 <lambdabot> The answer is: Yes! Haskell can do that.
08:54:40 <quicksilver> kadaver: sure
08:55:02 <quicksilver> kadaver: data Markov = Markov (Map String (Either String Markov))
08:55:08 <quicksilver> kadaver: recursive data types are made for this.
08:55:24 <edwardk> @seen cpoucet
08:55:24 <lambdabot> I haven't seen cpoucet.
08:55:26 <quicksilver> you may chose to name things and move the recursion around.
08:55:44 <quicksilver> data Markov = Atom String | SubMarkov (Map String Markov)
08:56:03 <edwardk> I totally need to post up my trie code, every time I see 'Map String' I cry ;)
08:56:24 <quicksilver> edwardk: it only matters if it matters.
08:56:34 <quicksilver> edwardk: Map String is perfectly fine for many casual uses.
08:56:38 <edwardk> quicksilver: how zen
08:56:49 <quicksilver> I trie.
08:56:54 <kadaver> hmm cant haskore play music really fast+
08:56:57 <QtPlaty[HireMe]> edwardk: Why do you cry?
08:57:09 <edwardk> QtPlaty[HireMe]: the inefficiency =)
08:57:24 <kadaver> ah ofc
08:57:24 <quicksilver> Also a fondness for parametric polymorphism means I can't honestly endorse a Map which auto-specialises to a trie
08:57:28 <quicksilver> although it's a cute idea.
08:57:33 <sheyll> hi, is there a way to catch expections thrown with error?
08:57:38 <quicksilver> cuteness is not always parametric.
08:57:43 <quicksilver> sheyll: (a) no, don't try to do that
08:57:52 <quicksilver> (b) actually there is, if you really want to. But it's normally a mistake.
08:57:59 <quicksilver> I can't remember the exact syntax.
08:58:07 <quicksilver> (depends which version of the exceptions library you have)
08:58:12 <QtPlaty[HireMe]> edwardk: Is it that inefficient?  And I'm one of thouse people with the view that as long as its fast enought you shouldn't worry about inefficency.
08:58:47 <bavardage> QtPlaty[HireMe]: ++
08:58:49 <sheyll> I am trying to use hs-plugins, eval
08:58:50 <bavardage> who cares about inefficiency :D
08:58:50 <edwardk> QtPlaty[HireMe]: actually my problem is that very thing, i had something that wasn't fast enough with map [a] -- so i had to put together a trie lib to change my asymptotics
08:58:58 <quicksilver> Well, a trie has bettering asymptotics for various cases.
08:59:06 <bavardage> I mean, if everyone thought like that, who would program in python
08:59:10 <quicksilver> it also has a better practical behaviour for nearby keys
08:59:12 <bavardage> it may not be blazing fast, be it's usually fast enough
08:59:16 <edwardk> QtPlaty[HireMe]: i don't care about constant factors. i just care about the asymptote involved
08:59:29 <quicksilver> inserting keys into a Map [a] which have a large common prefix is pathological
08:59:36 <quicksilver> you keep recomparing the same items
08:59:44 <quicksilver> that's precisely what a trie solves
09:00:24 <edwardk> quicksilver: w.r.t. autospecialization, since i'm working on unboxing and all sorts of non-parametric optimizations anyways, automatically specializing the [a] case to a trie isn't so bad
09:00:31 <sheyll> does anyone know how to prevent a haskell program from exiting in case a script evaled with System.Eval.Haskell.eval causes an error?
09:00:35 <edwardk> quicksilver: in context
09:01:32 <quicksilver> edwardk: oh what a hostile landscape you inhabit, with the precious oxygen of parametricity so cruely denied.
09:01:33 <sheyll> I am suspecting that error will be called in a pure function, how do I catch that?
09:01:39 <pumpkin> seems like the current use of associated types for specialized unboxed containers should be something we could get GHC to automate for us?
09:01:40 <edwardk> quicksilver: hah
09:01:47 <vixey> preflex: seen jkff
09:01:47 <preflex>  jkff was last seen on #haskell 31 days, 1 hour, 30 minutes and 30 seconds ago, saying: Not all of them. There was a thread in haskell-cafe that provided counterexamples: iirc, they were about Either
09:01:53 <quicksilver> sheyll: well the problem is that eval is just hadning you back a thunk
09:01:59 <quicksilver> the 'error' is hidden deep inside.
09:02:07 <edwardk> quicksilver: yeah but in this 'vacuum', vacuum gives me pretty diagrams
09:02:34 <sheyll> quicksilver: so there is no diffrence to a i.e. a pattern mismatch in any other pure function?
09:02:42 <quicksilver> right
09:02:51 <quicksilver> the eval from hs-plugins doesn't separate the layers in anyway
09:02:51 <edwardk> quicksilver: and you can reclaim parametricity in this framework you just need to explicitly throw a few 'Box' newtypes in
09:02:56 <sheyll> quicksilver: and there is no way to catch that?
09:03:00 <quicksilver> there is.
09:03:08 <quicksilver> but you need to force everything to push the error out.
09:03:24 <edwardk> quicksilver: sounds .. uncomfortable
09:03:52 <quicksilver> edwardk: yes, I think you appreciate the spirit of my comments. Do you plan a blog post or mailing list post to discuss any of your recent work? Some of it is quite exciting.
09:04:17 <pumpkin> hs-plugins? the thing BSP was working on?
09:04:37 <pumpkin> oh, no
09:04:44 <pumpkin> I'm thinking of ghc plugins or something :P
09:04:53 <sheyll> quicksilver: you mean Control.Parallel.Strategies.force?
09:05:32 <edwardk> quicksilver: well, the trie stuff i'm doing i'll probably just include in the adaptive-containers library or something, once i can show a performance win
09:05:45 <edwardk> quicksilver: the packing stuff i have yet to make work efficiently
09:05:50 * quicksilver nods
09:06:19 <wli> centrinia: The annihilating polynomials over Q are useless. If I can factor in number fields I can just factor x^n-c in K[x].
09:06:21 <edwardk> quicksilver: if i can get generic enough packing to work, that will wind up as a blog post in a heartbeat ;)
09:07:13 <edwardk> quicksilver: the right-kan extension monad stuff i was going to try to see if i could put something together with mmorrow in time for the haskell symposium
09:08:18 <edwardk> quicksilver: and the monoid lib, as soon as i have an efficient enough trie and work out the regex engine and dyck chunking engine, i figure i can pull a paper or two out of that
09:09:01 <edwardk> so hopefully all of my nice little metacircular performance obsessions will come together soon ;)
09:09:19 <pumpkin> haskell symposium???
09:10:06 <edwardk> pumpkin: http://haskell.org/haskell-symposium/2009/
09:10:35 <pumpkin> aha
09:11:14 <quicksilver> edwardk: well, make sure you get some of it actualy done and dusted and released, don't juggle too many projects and finish none :)
09:11:19 <quicksilver> edwardk: I speak from bitter experience :)
09:11:42 <edwardk> quicksilver: well, its an exercise in yak shaving at this point ;)
09:12:00 <edwardk> As soon as I finish my parallel yak shaver, I'll be in business
09:13:58 <quicksilver> the nature of yak shaving is it can't be paralellised
09:13:58 <pumpkin> lol
09:14:16 <quicksilver> you don't realised you have to shave the next yak until a particular point in shaving the last.
09:14:22 <edwardk> Amdahl's Yak
09:14:42 <pumpkin> your paper for the symposium could be on a new technique for parallelizing that which was thought to be unparallelizable
09:14:59 <Zao> I would use some kind of yak futures.
09:15:11 <Zao> Along with some speculative shaving.
09:15:21 <edwardk> well, right now its just about using a crap ton of different right kan extensions, which are unfortunately very very painful to write, so i haven't done very many of them yet
09:15:39 <quicksilver> Zao: the trouble is when the yaks start climbing trees
09:15:41 <edwardk> the nice thing is they seem to kick butt in the performance department though, and to cover all of the cases in the MTL.
09:15:45 <quicksilver> Zao: the branch prediction is almost impossible.
09:16:08 <edwardk> quicksilver: no worries. Yaks are heavy. Few branches can support them.
09:16:09 <quicksilver> edwardk: and of course, by the time you have finished, you have solved everything.
09:16:20 <quicksilver> edwardk: because "Everything is a Kan extension"
09:16:25 <quicksilver> I'm reliably informed.
09:16:30 <edwardk> quicksilver: stick close to the core of the tree and you'll find all but the youngest of Yaks.
09:16:36 <Zao> There ought to be some common fur patches that can be shaven regardless of the branch taken.
09:16:38 <JustinJoseph> Challenge Me - http://justinjg.mybrute.com :p
09:16:50 --- mode: ChanServ set +o quicksilver
09:16:54 --- mode: quicksilver set +b *!*=midnight@*.pitbpa.fios.verizon.net
09:16:54 --- kick: JustinJoseph was kicked by quicksilver (or you could fuck off)
09:17:13 <quicksilver> with apologies for the language.
09:17:16 --- mode: quicksilver set -o quicksilver
09:17:36 <edwardk> Zao: i figure if you just automate the process of randomly swinging an electric razor around and put enough agents on the task you might be able to statistically shave yaks in parallel.
09:19:05 <edwardk> quicksilver: but i'll admit i have been spending a lot of time yak shaving. this whole thing started as a side project in parallelizing my kata parser. ;)
09:19:11 <quicksilver> haha.
09:19:34 <edwardk> quicksilver: the unboxed stuff started because i wanted unboxed monoidal reductions
09:19:39 <quicksilver> kata in the martial arts sense?
09:20:13 <edwardk> nah, kata as in my language sense. or as in programming kata, practice, clean, impractical in a fight ;)
09:21:33 <quicksilver> oh, right.
09:21:40 <quicksilver> was your parser slow enough to care?
09:21:47 <edwardk> untyped haskell with eiffel style multiple inheritance for ml-like modules replacing type classes
09:21:47 <Roshan> Hi, I have a question about Cabal on Windows Vista. I tried installing a package at cabal fails complaining about not being able to create "C:\Program Files\Haskell". Indeed that is not where ghc is installed on my system. However despite adding the modified path in cabal's "config" file or specifying the --prefix option, it still complains about exactly the same folder. Is there a known fix?
09:21:51 <quicksilver> or was this just a particularly hairy yak and you couldn't resist?
09:21:55 <edwardk> erm, probably not ;)
09:22:18 <edwardk> mostly i just got annoyed at parsec and hate happy and wanted a third way to proceed ;)
09:23:05 <vixey> what is the third way
09:23:06 <vixey> ?
09:23:21 <edwardk> vixey: i've been working on monoidal parsing basically
09:23:22 <quicksilver> edwardk: polyparse!
09:23:34 <edwardk> a whole bunch of monoids that each individually handle some part of the parsing process
09:23:37 <vixey> I wonder what is monoidal parsing
09:23:42 <quicksilver> edwardk: but your monoid parsing sounds great, so I'm gld you decided to make your own way.
09:24:17 <vixey> edwardk is there some code?
09:25:01 <edwardk> vixey: what i have is this. i have a whole bunch of monoids that know how to inject values from another type. For instance if you have a monoid that can inject Chars I call that a Char `Reducer`.
09:25:19 <wli> aha, Cantor-Zassenhaus is just raising a polynomial to a huge power and doing gcd's.
09:25:29 <edwardk> then i might have a Word8 `Reducer` for UTF8 recognition that feeds the fully parsed chars to any Char `Reducer` you have lying around.
09:25:34 <edwardk> vixey: sure
09:25:49 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/
09:26:20 <edwardk> vixey: one such char based reducer can calculate out source positions for token annotation by accumulating column and line information locally
09:26:40 <edwardk> so that if you applied it inside of a fingertree it can rebuild itself in logarithmic time after source file mutation
09:26:51 <edwardk> but also, since these are monoids, i can chunk and run them in paralel
09:27:06 <edwardk> so i can parse in parallel, and then incrementally update things live
09:27:16 <vixey> this is definitely wizardry
09:27:41 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Reducer.html is the idea of a Reducer. nothing magic there
09:27:44 <kadaver> it is possible have drums+piano+xylophone for example in one song in haskore right?
09:28:08 <lament> no, you'll get a style mismatch error
09:28:17 <edwardk> then I define generators which know how to make efficient use out of reducers: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Generator.html
09:28:39 <edwardk> for specific data types. they work like specialized instances of Foldable.
09:28:48 <edwardk> and provide a large suite of combinators: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Generator-Combinators.html
09:29:24 <edwardk> but note the combinators are all really just 'extract from some monoid that we mapReduced values into'
09:30:01 <vixey> but that last one is monads not monoids
09:30:08 <vixey> so how do you go from monoid to monad?
09:30:12 <vixey> (do you ?)
09:30:23 <edwardk> i have several monoids for monads
09:30:30 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Monad.html
09:31:20 <edwardk> Action -- derives mapM_, MonadSum is a monadplus->monoid transformer that uses just the MonadPlus instance as a monoid
09:31:46 <Eleanore> Höns!
09:32:06 <kadaver> kycklingar!
09:32:14 <pumpkin> will haskell' improve sharing in the built-in typeclasses? both alternative and monadplus could be monoids directly
09:32:16 <edwardk> and Mon is used to any lift module over a ringoid by wrapping a monad around it.
09:32:22 <Eleanore> Tuppar!
09:32:32 <kadaver> Muppar!
09:32:42 <Eleanore> Sorry, wrote in the wrong chan. :-)
09:33:23 <edwardk> If n is a Monoid and m is a Monad than m `Mon` n is a Monoid, basically it lifts the monoid into the monad. I have a similar one for Applicatives
09:33:42 <edwardk> hiding over in http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Applicative.html
09:33:59 <wli> pumpkin: I think Haskell' is only really about getting some sort of documentation/standardization for near-universal extensions going.
09:34:15 <pumpkin> boo :(
09:34:39 <quicksilver> pumpkin: almost certainly not.
09:34:41 <edwardk> vixey: but the terseness of the definitions in http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Generator-Combinators.html should speak to the efficacy of expression in the framework
09:34:44 <wli> pumpkin: Nah, it's a good thing. That sort of stuff might be good for Haskell II though.
09:35:05 <quicksilver> pumpkin: however, the way to get such an improvement in Haskell' or Haskell'' is to design the solution and garner community support for it.
09:35:05 <pumpkin> it seems so silly to have list be an instance of Monoid, Alternative, and MonadPlus
09:35:30 <edwardk> pumpkin: monoid vs. monadplus serve different purposes
09:35:36 <quicksilver> the job of standardisation efforts is to standardise working, tested, behaviour
09:35:45 <edwardk> i do think Alternative and MonadPlus should just be ripped out into FunctorPlus or something
09:35:45 <vixey> edwardk: do you have any (smaller) examples of using it to parse something?
09:35:46 <quicksilver> not to standardise something new and untesteds
09:35:54 <quicksilver> if you see what I mean. clumsy wording.
09:36:04 <wli> Well, for Haskell II, one might as well nuke the H98 Prelude braindamage.
09:36:07 <pumpkin> hmm
09:36:09 <wli> From orbit, even.
09:36:12 <edwardk> vixey: not yet. the regex monoid isn't in the library yet.
09:37:12 <quicksilver> wli: that would need to come with syntax to invoke the new prelude, assuming we didn't want to break backward compatibility.
09:37:14 <edwardk> vixey: what i do is i use my reflection library to reify a DFA into a type level brand so you can have a monoid of state transitions in the regex, which you can concatenate in parallel, etc. and then check to see if the regex matches
09:37:29 <quicksilver> that sounds like a sensible idea anyhow
09:37:47 <edwardk> and more interestingly it can accumulate monoidal values on edges, so the whole thing can feed other monoids
09:38:08 <wli> quicksilver: The presumption was that Haskell II wouldn't be bound by the chains of backward compatibility.
09:38:15 <pumpkin> yay
09:39:12 <wli> quicksilver: It may not be what whoever is working on Haskell II is up to, though I'm not entirely sure there's anything happening on the Haskell II front (and probably won't be until Haskell' is done).
09:39:17 <edwardk> vixey: i can't eliminate all context sensitivity, so there is some 'left-to-right' bias, but i can minimize it. i can recognize utf-8 using the utf-8 monoid, feeding a char monoid that can do lexing using the regex monoid to chunk things into tokens. i can then take the token stream and feed that
09:40:20 <wli> I did see _somewhere_ though that the name for the forward-looking revision was supposed to be Haskell II (or 2?).
09:40:22 <edwardk> to a balanced parenthesis/haskell layout/dyck language monoid which minimizes the size of your context sensitive chunks, and then feed the chunks individually to parsec-as-a-monoid
09:40:34 <vixey> that's really interesting edwardk
09:40:45 <vixey> I definitely don't totally see how it works yeta
09:40:58 <bavardage> how do I parrallelise monad code?
09:41:01 <edwardk> so basically think of it as taking the low level of parsing away, and the high level of parsing away, and leaving only the middle level of dealing with context-sensitivity as left-to-right
09:41:03 <bavardage> (just using par and seq)
09:41:07 <quicksilver> wli: I think there have been mutterings but nothing "official"
09:41:30 <bavardage> http://paste.pocoo.org/show/113377/ so convert this to use par and seq
09:41:37 <quicksilver> wli: there was a recent-ish announcmenet to try to streamline haskell' into a rolling standardisation process instead of a big all at once thing
09:41:46 <edwardk> vixey: well, lets rewind, which part trips you up?
09:41:57 <wli> quicksilver: Yeah, I don't think things have even gotten far enough to decide on the concept of Haskell II.
09:42:44 <edwardk> vixey: lets take a look at a nice simple monoid i use, like the source position monoid. it represents a run of consecutive characters and their contribution to the knowledge of your current line # and column #.
09:43:11 <edwardk> vixey: after all one of the big pieces of value a parser has is that it can tell you where the error occurs
09:44:57 <edwardk> if you just have part of a file you can only know some of the information about where you are. if you have seen an 'x' with no context. you know that you have a delta of one column, but not which line you are on.
09:45:27 <edwardk> if you have seen a bunch of characters followed by a carriage return you know that you are on the 1st column of a line, and that you have a delta of one line.
09:45:52 <vixey> ohyeah
09:45:54 <edwardk> if you see a tab, things get trickier, because you can't fully parse a tab until you know your absolute column #
09:45:56 <vixey> I'm looking at the impl. of it too
09:46:00 <wli> Anyway, now that I understand Cantor-Zassenhaus, I have to figure out how factoring over GF_{p^n}[x] is supposed to help factor in Z[x].
09:46:24 <edwardk> and you can track tabs with just partial information about how many characters came before and after your logical tab.
09:46:59 <edwardk> and if you encounter a #line directive you should just set yourself to an absolute file name/line/column
09:47:14 <edwardk> so between those you have a nice simple monoid of file position information that can 'reduce' chars
09:47:32 <edwardk> its compositional and can be factored out from the rest of your concerns.
09:48:01 <edwardk> OTOH, if you want to recognize UTF8 things are a little trickier.
09:48:26 <edwardk> UTF8 marks the first byte in each character with information about the length of the token, but never takes more than 4 bytes to encode a char
09:48:50 <edwardk> so given 7 bytes, you have to have at least one fully parsable char or an invalid encoding
09:49:12 <pumpkin> does UTF-8 on 4 bytes actually give exactly 21 bits?
09:49:14 <edwardk> so have the utf-8 monoid feed the chars it recognizes up stream to another reducer
09:49:52 <QtPlaty[HireMe]> pumpkin: No its a verabable lenght encoding IIRC.
09:49:53 <edwardk> pumpkin: yes
09:49:59 <edwardk> 3 + 6 + 6 + 6
09:50:05 <pumpkin> makes sense
09:50:13 <pumpkin> I remember them allowing more than 4 bytes at some point
09:50:14 <edwardk> pumpkin: i presume you mean on a 4 byte encoded char
09:50:21 <edwardk> pumpkin: they cut that
09:50:22 <pumpkin> did that get cut down to match unicode?
09:50:23 <pumpkin> ah
09:50:41 <edwardk> RFC3629
09:50:54 <edwardk> yeah
09:50:55 <MyCatVerbs> > log (fromIntegral ((fst . head . readHex "10FFFF") + 1)) / log 2
09:50:56 <lambdabot>   Couldn't match expected type `a -> [a1]'
09:51:05 <koala_man> it's defined up to 6 bytes
09:51:49 <koala_man> but unicode v4 doesn't specify more than 21 bits
09:51:49 <edwardk> so basically all the utf8 monoid does it track the result of having fed its fully recognized chars into some other char monoid, and the 'fiddly bits' on either side for the up to 3 bytes unrecognized in either direction
09:52:02 <edwardk> its a little messier than that in my hack
09:52:14 <MyCatVerbs> > log (fromIntegral ((fst . head . readHex $ "10FFFF") + 1)) / log 2
09:52:15 <lambdabot>   20.087462841250343
09:52:17 <pumpkin> koala_man: that's what I remember, but that RFC cuts it down
09:52:25 <koala_man> ah
09:52:55 * pumpkin designs a language with a distinct character for every imaginable thought
09:52:59 <edwardk> koala_man: the original ISO 10646 encoding was, but UTF-8 was restricted to a subset of the original encoding by RFC3629.
09:53:13 <yitz> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3983#a3983
09:53:18 <centrinia__> > length "10FFFF" * 4
09:53:18 <pumpkin> and forces unicode use the 16 higher planes just for his special language
09:53:19 <lambdabot>   24
09:53:35 <pumpkin> yitz: yeah :P but apparently that's been reduced now
09:53:42 <MyCatVerbs> pumpkin: welcome to Hangul.
09:53:43 <pumpkin> in the RFC edwardk linked to
09:53:53 <pumpkin> MyCatVerbs: the fully expanded hangul is only around 11k codepoints iirc
09:54:01 <edwardk> further more non-canonical encodings are also invalid under a strict interpretation of utf8, but aren't addressed in the original, iirc.
09:54:15 * edwardk is a bit of a standards junkie ;)
09:54:15 <MyCatVerbs> pumpkin: pretty nifty that they manage to pack so much into just 11k codepoints, no? :)
09:54:20 <pumpkin> lol
09:54:25 <yitz> pumpkin: oh yeah? to how many bytes? and when? (what I pasted is from w3c)
09:54:39 <yitz> uh, no, unicode consort.
09:54:46 <pumpkin> MyCatVerbs: well, they also packed it into under 100 combining characters :P
09:54:55 * centrinia__ designs a character code that can encode every non-negative integer in a character.
09:55:01 <pumpkin> yitz: 4 bytes, RFC3629
09:55:40 <edwardk> so the only trickiness in my utf8 monoid is making sure that when i parse invalid bytes that i remain a monoid and that the result of having parsed forward or backward or having jammed together 2 partially parsed fragments together is the same regardless
09:55:43 <yitz> pumpkin: but what I pasted only encodes 4 bytes
09:55:56 <pumpkin> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3983#a3983 ?
09:56:01 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Monoid-Lexical-UTF8-Decoder.html is the hideousness that my first stab at that resulted in.
09:56:04 <pumpkin> looks like it goes up to the original 6 there
09:56:10 <edwardk> i'm sure that could be rewritten into something a bit more elegant
09:56:34 <centrinia__> 6 planes is less than an unlimited amount of planes.
09:56:39 <pumpkin> lol
09:56:45 <edwardk> pumpkin: the last 2 are explicitly marked invalid
09:56:45 <pumpkin> unicode has 17 planes!
09:57:09 <centrinia__> Infinicode has omega planes!
09:57:13 <pumpkin> lol
09:57:30 <pumpkin> @quote centrinia Infinicode has omega planes!
09:57:31 <lambdabot> No quotes match. Maybe you made a typo?
09:57:35 <edwardk> 11111xxx is illegal in utf-8
09:57:36 <pumpkin> @remember centrinia Infinicode has omega planes!
09:57:37 <lambdabot> I will remember.
09:58:04 * centrinia__ wishes that he can make a code that can represent any set with a character. :)
09:58:23 <edwardk> now a lot of simplistic utf-8 parsers will let it through, but they'll also let non-canonical code point representations through as well.
09:58:35 <edwardk> http://prowebdevelopmentblog.com/content/big-overhaul-java-utf-8-charset
09:59:04 <edwardk> which violates http://www.unicode.org/versions/corrigendum1.html
09:59:07 <yitz> pumpkin: oh, I see, the utf8 itself is now only up to 4 bytes, encoding only 2.5 bytes of unicode.
09:59:10 <janiss> Hi I am new on haskell and trying to merge two streams which are pairs of integers but I couldnt do it.  I did it in scheme before but in haskell i cant find where i am mistaken. usingh ghci with ghc6. Can someone suggest a debuggin tool for haskell or just chek my little code?
09:59:24 <pumpkin> yitz: oh yeah, well unicode code points are only defined up to 21 bits
09:59:56 <pumpkin> beyond 21 bits, unicode is "of age" and doesn't need UTF8 anymore, I guess
10:00:02 <centrinia__> 2^21-1 < infinity
10:00:04 <mauke> @where paste
10:00:04 <lambdabot> http://hpaste.org/new
10:00:04 <edwardk> in fact i think my utf-8 monoid is the only haskell utf-8 parser that actually enforces strictly that all values are legal utf-8
10:00:18 <pumpkin> zomg
10:00:27 <MyCatVerbs> > let { bits 1 = 7; bits n = 5*n + 1; } in map bits [1..6]
10:00:29 <lambdabot>   [7,11,16,21,26,31]
10:00:34 <edwardk> i don't think anyone else is that pedantic ;)
10:00:42 <pumpkin> they should be, it can be dangerous!
10:00:53 <mauke> insufficient paranoia
10:01:08 <MyCatVerbs> edwardk: I have a vague feeling that Tom Harper's might?
10:01:10 <edwardk> well, it just means that you can have strings compare as equal that fail to parse as equal after decoding
10:01:18 <edwardk> mycatverbs: which one?
10:01:33 <MyCatVerbs> edwardk: Data.Text. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text on Hackage.
10:01:52 <mauke> janiss: where is your code?
10:01:58 <pumpkin> I thought bos did a lot of the work on that, why isn't he listed as an author? :o
10:02:12 <centrinia__> Should I use the Elias code to represent non-negative integers with characters?
10:02:28 <MyCatVerbs> pumpkin: he is. Brian O'Sullivan, Tom Harper and Duncan Coutts.
10:02:30 <bos> hmm?
10:02:31 <yitz> janiss: this channel is a very good debugger. paste it on hpaste or your favorite paste board and let's have a look.
10:02:39 <pumpkin> MyCatVerbs: they're listed as maintainers :P
10:02:46 <MyCatVerbs> Oh, my bad.
10:02:57 <MyCatVerbs> pumpkin: I just mentioned Tom because he's the one I saw give a presentation on it. :)
10:03:00 <pumpkin> ah :)
10:03:18 <edwardk> mycatverbs: checking http://hackage.haskell.org/packages/archive/text/0.1/doc/html/src/Data-Text-Encoding-Utf8.html
10:03:39 <yitz> @hpaste
10:03:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:03:45 <yitz> janiss: ^
10:04:25 <edwardk> mycatverbs: holy crap he gets it right =)
10:04:56 <MyCatVerbs> edwardk: ^_^
10:05:08 <MyCatVerbs> Honestly it looked like a spec dump to me.
10:05:27 <MyCatVerbs> Like somebody had read the RFC and encoded it into Haskell.
10:05:30 <edwardk> well, usually folks just do the mask and multiply
10:05:45 <edwardk> i skimmed through like 5 different haskell implementations
10:05:49 <MyCatVerbs> *shakes fist* Those fools!
10:06:01 <edwardk> meh, works well, and is faster ;)
10:06:17 <edwardk> but permits non-canonical inputs
10:06:18 <pumpkin> lol
10:07:21 <edwardk> afk a bit
10:07:27 <Roshan> Does anyone have experience installing hackageDB packages on Vista? I have been trying to install a package using cabl and using runhaskell. They both fail due to access denied errors.
10:07:41 <Roshan> I am running as admin in both cases.
10:07:59 <yitz> edwardk: lenient on input, strict on output
10:08:00 <janiss> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3984 I am trying to merge lists but only second list is returning where am i mistaken?
10:09:57 <mauke> oh god, (head (tail (head y)))
10:10:10 <mauke> the scheme has corrupted your brain
10:10:20 <centrinia__> :t head . tail . head
10:10:21 <lambdabot> forall a. [[a]] -> a
10:10:27 <janiss> I've tryied to (y:ys) it but it raised an error
10:10:34 <jeffersonheard> oh good.  I thought I'd joined #scheme for a sec
10:10:50 <yitz> janiss: your smap is called zipWith in haskell
10:10:53 <jeffersonheard> can someone remind me how to derive a regularly derivable type on a single line inGHC?
10:10:55 <mauke> janiss: wait, didn't you mention pairs?
10:10:56 <gnuvince> @seen dons
10:10:57 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 4h 37m 46s ago.
10:11:00 <jeffersonheard> as in, not at the type decl
10:11:02 <yitz> @type zipWith
10:11:02 <mauke> janiss: why are you using a list of lists?
10:11:03 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
10:11:29 <rfh> may i ask for help: http://pastebin.com/m7ba227c5   how can i extract the root of n without getting a type error ?
10:11:52 <mauke> rfh: floor (sqrt (fromIntegral n))
10:11:56 <janiss> mauke I dont know diffrence between pairs and list of lists in haskell
10:12:13 <Saizan_> Roshan: are you using Cabal-1.6.0.2?
10:12:19 <mauke> janiss: a pair is exactly two values of possibly different types. a list is 0 or more values of the same type
10:12:42 <yitz> @type sqrt -- rfh
10:12:43 <lambdabot> forall a. (Floating a) => a -> a
10:12:44 <janiss> mauke : how can I sue pairs in haskell?
10:12:48 <paper_cc> janiss: pair is MxM on sets, list is M*
10:12:50 <mauke> janiss: (x, y)
10:12:57 <jeffersonheard> with a lawyer presumably :P
10:13:06 <mauke> a language lawyer!
10:13:13 <jeffersonheard> *ducks*
10:13:21 <mauke> no quack!
10:13:31 <c_wraith> I thought haskell didn't have duck typing
10:13:33 <yitz> rfh: sqrt only works when both the input and output are floats. do you want to convert?
10:13:38 <janiss> how can i get elements of pairs?
10:13:44 <rfh> mauke: works nice, thanks
10:13:44 <janiss> same as head and tail?
10:13:47 <kiris> fst, snd
10:13:50 <mauke> janiss: pattern matching, preferably
10:13:51 <kiris> > fst (1,2)
10:13:51 <jeffersonheard> derive Eq or Show or Ord from outside the module that a datatype was declared in?  can anyone remember?
10:13:52 <lambdabot>   1
10:13:53 <kiris> :t snd
10:13:54 <lambdabot> forall a b. (a, b) -> b
10:14:04 <jeffersonheard> I know I've done it before
10:14:16 <mauke> merge f ((x1, x2) : xs) ((y1, y2) : ys)
10:14:26 <kiris> :t merge
10:14:26 <rfh> yitz: nevermind, it works well with fromIntegral
10:14:27 <lambdabot> Not in scope: `merge'
10:14:28 <sinelaw> PeakerWork, ?
10:14:29 <paper_cc> jeffersonheard: http://haskell.org/haskellwiki/GHC/StandAloneDeriving
10:14:33 <janiss> ok makue I will try this way
10:14:35 <yitz> rfh: yep
10:14:39 <cooldude127> anyone else using lhs2TeX notice that it struggles with alignment with the poly style and do-notation?
10:14:55 <gwern> c_wraith: well, aren't typeclasses or existential kind of like ducktyping?
10:15:02 <paper_cc> jeffersonheard: deriving Eq for FooType
10:15:17 <c_wraith> gwern: Kind of, but the main point of duck typing is that it's ad-hoc...  Type classes aren't exactly ad-hoc.
10:15:25 <yitz> rfh: though I find that often it's a good idea to avoid floating point stuff where possible.
10:15:26 <jeffersonheard> thank you
10:15:31 <Craig`> can i get haskell apps embedded on websites? like java
10:15:46 <mauke> janiss: shouldn't merge f [] ys = ys?
10:15:54 <gwern> c_wraith: we have ad-hoc stuff! like ad hoc polymorphism
10:15:57 <mauke> (and merge f xs [] = xs)
10:16:19 <centrinia__> Shouldn't distance x y = sqrt ((x*x)+(y+y)) ?
10:16:26 <kiris> .. = []?
10:16:35 <c_wraith> Craig`: There is no haskell embedded app plugin for browsers that I'm aware of.
10:16:35 <rfh> yitz: if there is a more efficient,elegant version which i can understand, i m amenable to negotiation:-)
10:16:39 <gwern> Craig`: haskell applets? not really. there's an interesting project which translates yhc core output into javascript, but that's definitely researchy
10:16:51 <Craig`> haha okay :)
10:16:56 <vixey> haskell applets you could do
10:16:59 <yitz> rfh well it depends what you're trying to do of course :)
10:17:00 <Saizan_> gwern: not as ad-hoc as duck-typing goes, we'd need some kind of structural subtyping for typeclasses, rather than only named subtyping
10:17:02 <mauke> centrinia__: doesn't matter if you only compare with other distances
10:17:17 <rfh> yitz: i am doing problem 12 on projecteuler.net
10:17:21 <Craig`> just i want to learn haskell and im training to be a web dev, i want haskell for projects for fun but like it wont be any help for web dev :/
10:17:29 <mauke> @check \x y -> (sqrt x <= sqrt y) == (x <= y)
10:17:30 <lambdabot>   "Falsifiable, after 0 tests:\n-0.5\n1.3333333333333335\n"
10:17:36 <gwern> Craig`: applets /= web dev
10:17:40 <PeakerWork> sinelaw: hey
10:17:42 <vixey> what does it take to train to be a web dev
10:17:48 <Saizan_> Craig`: you can use haskell on the server side
10:17:50 <mauke> @check \x y -> x < 0 || y < 0 || (sqrt x <= sqrt y) == (x <= y)
10:17:51 <lambdabot>   "OK, passed 500 tests."
10:17:59 <c_wraith> Craig`: I'm writing web app code in Haskell.  It's just not applets.  It's the server.
10:18:08 <Craig`> kk
10:18:27 <Craig`> just ill be learning: html, css, javascript, php and java/haskell
10:18:30 <sw1sh> Maybe HAppS?
10:18:32 <PeakerWork> @check x >= 0 && y >= 0 ==> (sqrt x <= sqrt y) == (x <= y)
10:18:33 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:18:34 <lambdabot>           ...
10:18:38 <vixey> java/haskell??
10:18:40 <PeakerWork> @check (x >= 0 && y >= 0) ==> (sqrt x <= sqrt y) == (x <= y)
10:18:41 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:18:41 <lambdabot>           ...
10:18:42 * centrinia__ recalls some kind of a client-side functional programming language.
10:18:49 <Saizan_> vixey: the new C/C++
10:18:50 <yitz> rfh: not sure why you need a sqrt for that, but anyway, here's one:
10:19:05 <lilac> duck-typing is structural typing for dynamic languages. haskell supports structural typing via Oleg's HList
10:19:21 <mauke> O(leg)
10:19:26 <rfh> yitz: well, i needed a efficient version for finding divisors
10:19:53 <Craig`> how would i do a function that checked if a string contained a "~" ?
10:19:55 <lilac> mauke: is that the time complexity for solving an arbitrary problem in the typesystem?
10:20:07 <centrinia__> rfh, Compute the prime factorization first.
10:20:09 <lilac> Craig`: elem
10:20:17 <mauke> :t elem '~'
10:20:17 <lambdabot> [Char] -> Bool
10:20:18 <yitz> > let stable (x:x':xs) | x==x' = x | otherwise = stable (x':xs); isqrt x = stable . iterate (\y -> (y*y+y+x) `div` (y+y)) $ x in isqrt 12345 -- rfh
10:20:18 <vixey> that's not structural typing!!
10:20:19 <lambdabot>   111
10:20:19 <lilac> @type elem :: Char -> String -> Bool
10:20:20 <lambdabot> Char -> String -> Bool
10:20:21 <vixey> is it?
10:20:29 <gwern> @quote javascript
10:20:30 <lambdabot> No quotes match. You speak an infinite deal of nothing
10:20:35 <gwern> @quote script
10:20:36 <lambdabot> TuringTest says: They got it work in Haskell without understanding Haskell.  It is quite an achievement, of some description.
10:20:46 <gwern> yes
10:20:47 <gwern> ack
10:20:50 <edwardk> yitz: in general i agree, however, you can wind up with security concerns that otherwise wouldn't be faced by embracing that policy blindly
10:21:07 <gwern> but didn't lb have a quote about javascript? something about inside javascript is a small scheme trying to get out?
10:21:21 <yitz> edwardk: yes I can see that could be a concern
10:21:28 <rfh> yitz: hmm, i will look over it, and try to understand =)
10:21:31 <edwardk> gwern: heh, i learned continuation passing style in javascript ;)
10:21:49 <rfh> centrinia__: and then combinate the prime factors?
10:21:53 <edwardk> at least that was when it finally clicked for me
10:21:56 <lilac> @quote half-assed
10:21:56 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
10:21:57 <cypher-> edwardk: oh, maybe you could help me with CPS ;-)
10:22:03 <lilac> @quote half-assed
10:22:03 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
10:22:05 <lilac> @quote half-assed
10:22:05 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
10:22:07 <lilac> grr
10:22:17 <gwern> @quote insanity.*different
10:22:18 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
10:22:20 <cypher-> I'm struggling with a question on how to do exception handling with CPS in lambda calculus
10:22:38 <vixey> cypher-: exception handling *with* CPS Â¿
10:22:45 <yitz> mauke: is that the NOleg = NOleg-Complete problem?
10:22:49 * gwern 's witty invocation of 'insanity is doing the same thing over and over and expecting different results' falls flat on its face
10:22:51 <vixey> what not do exception handling /then/ CPS it
10:22:51 <vixey> ?
10:22:53 <edwardk> cypher: functon foo(x) { ...; return x * 2; } => function foo(x, return_) { ...; return_(x * 2); }
10:22:55 <centrinia__> Does O(-1) make sense?
10:23:05 <rfh> yitz: thank you anyway
10:23:10 <PeakerWork> cypher-: encode the Maybe data-type in LC with its catamorphism - and then implement the bind, return and Nothing functions
10:23:51 <gwern> centrinia__: sure. with time travel. the procedure returns a value a constant time before invocation
10:24:03 <lilac> cypher-: perhaps if you shared the question we could all struggle with the same question rather than with our own guesses as to what the question might be ;-)
10:24:04 <yitz> rfh: (it's a streamlined newton's method implementation)
10:24:06 <edwardk> cypher: well, i just cps transformed the Error monad as part of my little 'finding the right kan extension' exercise.
10:24:10 <cypher-> edwardk: I've got the following reductions: try raise catch M -> M, raise M -> raise, try \x.M catch M' -> \x.M' and need to show how to translate it into pure lambda caluculus using continuations
10:24:38 <cypher-> lilac: see above ^
10:25:09 <vixey> cypher-: oh cool
10:25:11 <yitz> gwern I guess that means that multi-threading is insane. I tend to agree.
10:25:22 <vixey> cypher-: you already did the lambda calculus fragent?
10:25:47 <gwern> @quote insane
10:25:48 <lambdabot> monochrom says: Power doesn't corrupt you. No no no. Power makes you INSANE! Absolute power makes you absolutely insane! BWAHAHAHAHAHA...
10:25:55 <gwern> @quote insane
10:25:56 <lambdabot> dylan says: I avoid buzz-buzz whenever possible. I prefer math-based or completely insane terminology
10:26:10 <gwern> @quote multi.*insane
10:26:10 <lambdabot> No quotes match. Take a stress pill and think things over.
10:26:27 <gwern> bleh. either my memory or lambdabot's memory are going
10:26:27 <yitz> @quote over
10:26:28 <lambdabot> Masklinn says: stability is overrated
10:26:37 <yitz> @quote over
10:26:37 <lambdabot> JonHarrop says: We invested a lot of time and money diversifying into Haskell before I discovered that their industrial success stories were largely faked.
10:26:39 <cypher-> vixey: I haven't done anything with it yet, I'm not sure how to approach it
10:26:46 <edwardk> cypher: consider the error monad for a second. Either e b, then CPS transforming that you get forall o. (a -> o) -> (e -> o) -> o. -- you have two continuations, a success and a failure continuation.
10:26:47 <vixey> do pure lambda calculus first
10:26:53 <rfh> yitz : have to look into a math book for that
10:27:04 <edwardk> er Either e a
10:27:39 <cypher-> vixey: so you recommend first encoding it into pure lambda calculus and then converting into CPS?
10:28:01 <vixey> no
10:28:19 <jeffersonheard> the standalone deriving thing isn't working
10:28:33 <jeffersonheard> even after putting it in a language pragma at the top of the module
10:28:48 <yitz> rfh: heh ok. the basic idea is you find a zero by starting with a point on the x axis, go up to the curve, draw a tangent line, see where it hits the x-axis, repeat.
10:28:48 <jeffersonheard> {-# LANGUAGE BangPatterns, FlexibleContexts, UndecidableInstances, StandaloneDeriving #-} still yields a parse error after 'deriving'
10:29:06 <lilac> jeffersonheard: what does your 'deriving' line look like?
10:29:21 <jeffersonheard> deriving Eq for LayoutWrapMode
10:29:39 <yitz> rfh: here we are finding a zero of y = x^2 - n to find sqrt n.
10:29:42 <rfh> yitz: i know newton iteration
10:29:49 <jeffersonheard> parse error on input `Eq'
10:29:49 <yitz> oh ok
10:30:04 <cypher-> vixey: then what should I do?
10:30:09 <edwardk> yitz: Either e a ~ forall o. (a -> o) -> (e -> o) -> o -- (the funny order on the result is because I choose to represent it in the form suitable for expression as a right kan extension)
10:30:16 <rfh> yitz:in differential calculus
10:30:16 <edwardk> er not yitz, cypher-
10:30:29 <jeffersonheard> I thouhgt maybe i had some other error earlier that was causing it to hork, but I moved the deriving lines to just after my imports
10:30:31 <centrinia__> > iterate (\x -> x - (x^2 - 2.0) / (2*x)) 2.0
10:30:31 <lilac> jeffersonheard: that's not right. i think it's 'deriving Eq LayoutWrapMode' but they might be the other way around and might have parens
10:30:32 <lambdabot>   [2.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.4142135...
10:30:53 <yitz> rfh: that's exactly what I did. except with integers, you get an exact answer quickly.
10:31:00 <conal> jeffersonheard: i think the word "instance" is in there.  perhaps "deriving instance Eq LayoutWrapMode"
10:31:04 <yitz> rfh (if you set it up carefully)
10:31:28 <jeffersonheard> oy.  I see three different syntaxes depending on whether I'm looking at the wiki or the GHC manual...
10:31:45 <lilac> jeffersonheard: yeah, conal's right.
10:31:47 <vixey> cypher-: the rules for the pure lambda calculus first, then think about the exceptions
10:32:04 <jeffersonheard> yeah, that worked
10:32:05 <lilac> jeffersonheard: it's the same as a normal 'instance' but you add 'deriving' to tell the compiler to fill it in for you
10:32:09 <jeffersonheard> that's not what it says in the GHC manual, though
10:32:18 <rfh> yitz: right
10:32:23 <jeffersonheard> argle.  okay.  thanks, folks.  meeting time now
10:33:07 <rfh> yitz: never thought this could find application in finding divisors
10:33:07 <edwardk> cypher-: basically just start with a lambda calculus, transform everything into the Either e monad, then, transform the Either e monad into cps style using that translation i gave, and translate it the rest of the way back down to the lambda calculus
10:33:25 <cypher-> edwardk: sounds fun, I'll try
10:34:32 <yitz> rfh: heh. well you can use it here, but you can also find divisors without using a sqrt function at all, just a matter of style. this early in PE you don't need a huge amount of speed either.
10:35:16 <ski> (`PE' being `Partial Evaluation' ?)
10:35:52 <DanielC> Help. What am I doing wrong? Ghci complains when I do this:   foldr (+) [1,2,3,4]
10:36:10 <ski> DanielC : you're missing the "base case" argument to `foldr'
10:36:18 <ski> > foldr (+) 100 [1,2,3,4]
10:36:18 <rfh> yitz: efficiency,style,elegance are things which are always good
10:36:20 <lambdabot>   110
10:36:28 <DanielC> ah
10:36:39 <DanielC> foldr (+) 0 [1,2,3,4]
10:36:41 <DanielC> :-D
10:36:42 <DanielC> thanks
10:36:49 <lilac> DanielC: foldr (+) 0 == sum
10:36:56 <ski> also, if you know the list will always be non-empty, you can use `foldr1'
10:37:03 <ski> > foldr1 (+) [1,2,3,4]
10:37:05 <lambdabot>   10
10:37:06 <lilac> actually, sum might be foldl, but never mind...
10:37:14 <ski> @src sum
10:37:14 <lambdabot> sum = foldl (+) 0
10:37:26 <DanielC> Interesting.
10:37:32 <burp_> @src foldl
10:37:33 <lambdabot> foldl f z []     = z
10:37:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:37:38 <yitz> rfh: last two yes. first only when needed if it costs the other two - that would be "premature optimization", a cardinal sin.
10:37:39 <burp_> @src foldr
10:37:40 <lambdabot> foldr f z []     = z
10:37:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:37:44 <lilac> for almost all Num instances, foldl (+) 0 == foldr (+) 0
10:37:47 <conal> lilac: depends what you mean by "be"
10:38:00 <lilac> conal: depends what /you/ mean by "mean"
10:38:10 <conal> :)
10:38:33 <edwardk> cypher: its not so terrible, just think of it as encoding each value as a function that accepts a success continuation and a failure continuation and calls the success continuation with its value.
10:39:01 <lilac> conal: i think it depends more on what i mean by 'might' ;-)
10:39:05 <edwardk> cypher-: an exception is just an extension of the idea of a value to one that instead calls the failure continuatin with some representation of an exception
10:39:23 <edwardk> @type either
10:39:23 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:40:26 <edwardk> cypher: it may be easier to grok if you do a straightforward cps transformation first, without the failure continuation.
10:40:37 <edwardk> and then think of how you'd thread the extra continuation through
10:41:21 * ski thinks the "staged" CPS transformation is easier to understand the results of
10:41:36 <rfh> yitz: yes, as hardy always said, there is no place for ugly mathematics or in this case code
10:41:44 <edwardk> skI: yeah
10:41:50 <cypher-> edwardk: thanks for suggestions, I'll try to do that
10:42:16 <ski> (.. and not that much more difficult to understand/code itself)
10:43:44 <solidsnack> Are there any proposals for a split up Foldable?
10:43:53 <edwardk> solidsnack: how?
10:44:08 <edwardk> solidsnack: I have Generator which is basically a monomorphic Foldable
10:44:10 <solidsnack> Well, maybe only foldl or only map, &c.
10:44:36 <edwardk> solidsnack: well, all you need to implement Foldable is foldr or foldMap
10:44:36 <edwardk> everything else is derived from those
10:44:40 <ski> ("only map" is `Functor', no ?)
10:44:43 <snoobino> why isn't the rule : fmap id = id enough for functors ?
10:44:47 <edwardk> you get default definitions for the rest
10:45:56 <pk1> (sry got disconected)
10:46:06 <ski> s/snoobino/pk1/ : <category theory>because categories have both identity and composition as structure ?</category theory>
10:46:17 <pk1> (I'm snoobino)
10:46:42 <pk1> I meant, this law is enough to say fmap won"t change the structure
10:47:04 <kadaver> > foldr1 0 [1..10]
10:47:05 <lambdabot>       No instance for (Num (a -> a -> a))
10:47:05 <lambdabot>        arising from the literal `0'...
10:47:06 <pk1> what is the other law giving ?
10:47:09 <edwardk> well, fmap f . fmap g = fmap (f . g) comes from the free theorem, fmap id = id is the only technical requirement
10:47:12 <kadaver> > foldl1 0 [1..10]
10:47:13 <lambdabot>       No instance for (Num (a -> a -> a))
10:47:13 <lambdabot>        arising from the literal `0'...
10:47:16 <kadaver> > foldl1 (+) [1..10]
10:47:18 <lambdabot>   55
10:47:19 <kadaver> > foldr1 (+) [1..10]
10:47:20 <pk1> k
10:47:21 <lambdabot>   55
10:47:46 <quicksilver> but free theorems are a property of haskell's parametric polymorphism.
10:47:57 <PeakerWork> quicksilver: what do you mean?
10:48:00 <quicksilver> if you ignore that detail, fmap f . fmap g = fmap (f.g) is an important thing
10:48:05 <edwardk> quicksilver: sure
10:48:14 <quicksilver> it's certainly a key part of the categorical definition of functor.
10:48:18 <edwardk> quicksilver: my only point was that fmap id = id is the only law you have to prove
10:48:25 * quicksilver nods
10:48:28 <edwardk> so in that he is correct
10:48:29 <kadaver> > let toPerlHacker a = a ++ " loves perl" in fmap toPerlHacker ["edwardk","dons"]
10:48:30 <lambdabot>   ["edwardk loves perl","dons loves perl"]
10:48:39 <edwardk> thank you.
10:48:39 <pcc1> is there a haskell data structure that is like a map but stores multiple keys for each value (sort of the opposite of a multimap)
10:48:46 <quicksilver> but he's not correct that we could "reduce" functor as a class by removing it
10:48:50 <solidsnack> edwardk: So actually, I don't want a foldr.
10:48:56 <solidsnack> I just want a foldl.
10:48:59 <edwardk> pcc1: store references?
10:49:07 <lilac> pcc1: that sounds like a map to me
10:49:16 <edwardk> solidsnack: ah
10:49:20 <solidsnack> So that's why I'm curious about split up variants.
10:49:23 <edwardk> solidsnack: what structure?
10:49:26 * Axman6 agrees with lilac 
10:49:29 <solidsnack> File handle.
10:49:33 <janiss> mauke and others thanx a lot i fixed my problem
10:49:36 <pcc1> what's a store reference?
10:49:40 <quicksilver> pcc1: two maps, one each way?
10:49:55 <quicksilver> map from keys to values and then a map from values to [all its keys]
10:49:56 <cooldude127> pccl: can't you just store the same value in multiple keys?
10:49:59 <lilac> pcc1: do you want to be able to find the set of 'keys' for each 'value'?
10:50:02 <quicksilver> (Map k v, Map v [k])
10:50:07 <edwardk> solidsnack: well, i have a Generator, which offers just monoidal folds, and which you can implement left to right or right to left depending on what makes sense for the container
10:50:11 <edwardk> or in your case for fild handles
10:50:35 <edwardk> solidsnack: i.e. for bytestrings i use foldl' internally, etc.
10:50:57 <edwardk> and for lazy bytestrings i parmap over each chunk a foldl'
10:50:59 <solidsnack> Oh, interesting. Yeah, it's probably just as well to stick with associative.
10:51:14 <solidsnack> edwardk: Where is a link?
10:51:22 <dolio> Folding over file handles sounds like the alternative-to-lazy-IO libraries floating around.
10:51:38 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Generator.html
10:51:45 <dolio> Unless we're unsafePerformIOing.
10:51:51 <edwardk> solidsnack: 'cabal install monoids'
10:52:04 <solidsnack> edwardk: thank you
10:54:22 <mib_0jbn6gdc> can I ask a very newbie question here...
10:54:35 <QtPlaty[HireMe]> mib_0jbn6gdc: Just ask your question.
10:55:02 <mib_0jbn6gdc> how do I define a new type that can take only values -180 to +180
10:55:13 <Philonous> you can't
10:55:18 <mofmog> so why doesnt ghc just install cabal
10:55:19 <mofmog> -_-
10:55:31 <pcc1> quicksilver: yes, that could work. guess I'll have to write my own management routines, oh well
10:55:36 <cooldude127> my ghc has cabal, but not cabal-install
10:55:43 <cooldude127> which has the cabal program
10:55:44 <mauke> data T = X_180 | X_179 | X_178 | ... | X178 | X179 | X180
10:56:04 <trofi> pretty straightforward
10:56:10 <mofmog> at least installing ghc is less painful than installing clojure
10:56:11 <mib_0jbn6gdc> yes, is that all
10:56:12 <trofi> and some arith ops :]
10:56:29 <kadaver> Im a monoid and im allright, i work all dya and i sleep all night
10:56:50 <arjanb> mofmog: http://haskell.org/haskellwiki/Haskell_Platform
10:56:56 <mofmog> do you ever feel mempty on the inside?
10:56:59 <Philonous> mib_0jbn6gdc: You can, however, just use some other type with more numbers and after each operation check if the value is still in bounds
10:57:08 <mib_0jbn6gdc> how?
10:57:10 <cnwdup> mib_0jbn6gdc, you could define newtype YourType = X Int and not export the data constructor and provide one that checks for the range.
10:58:20 <Philonous> mib_0jbn6gdc: just like cnwdup said. Then you redefine Num and add the checks to the operations
10:59:18 <quicksilver> mofmog: often, on bad days. But on good days I feel pure on the inside.
10:59:19 <mib_0jbn6gdc> Philonous, then after I define that, can I have a compound type as in degrees:minutes:seconds ?
11:00:24 <Philonous> You mean a tuple of those? Sure.
11:00:45 <mmorrow_> grrrrrrrrrh, opengl + ffi + -threaded == HELL
11:01:18 <mib_0jbn6gdc> in which I want to provide some math operations for calculating degrees and radians
11:01:40 <Berengal> It isn't programming if it doesn't make you want to choke a kitten every once in a while...
11:01:47 * mmorrow_ is tempted to use C opengl
11:01:56 * mmorrow_ looks for the kittay
11:02:25 <Philonous> mib_0jbn6gdc: I'm not quite sure what you exactly want to do, but it doesn't sound problematic to me
11:02:44 <solidsnack> edwardk: So this API is basically map and map-reduce?
11:03:43 <mib_0jbn6gdc> Philonous: one custom type for float values for degrees and another for display purposes for degrees, minutes, seconds and both can be used for plus, minus operations
11:04:14 <edwardk> solidsnack: the one for generators, yeah
11:04:47 <edwardk> solidsnack: the rest of it is a lot of extensions to the concept to handle,say, seminearring based map/reduce for containers and data types with more structure.
11:05:10 <solidsnack> seminearring?
11:05:38 <Philonous> mib_0jbn6gdc: You can do that. You could also just write a function that pretty prints your float to degrees, minutes, seconds
11:05:41 <solidsnack> Well, I can look that up.
11:06:53 <edwardk> solidsnack: a seminearring is a pair of monoids, lets call them (0,+) and (1,*), with an absorbing 0 (0 * x = 0 = x * 0) and only one of the distributive laws. usually for my purposes right, (a + b) * c = a * c + b * c
11:07:29 <QtPlaty[HireMe]> I wounder if it would be resonable to create the angle datatype as an instance of Num and define the approprate numrical operations on it.
11:07:33 <edwardk> solidsnack: there are lots of seminearrings, regexes, tries, lists of monoids, any applicative functor wrapped around a monoid...
11:07:39 <mib_0jbn6gdc> Philonous: want to go beyond pretty print, i.e., take values as both floats and as deg:min:sec and still be able to manipulate them. That is two custom types interacting in simple math operations.
11:08:27 <edwardk> solidsnack: so i've been investigating how to abuse 'seminearring homomorphisms' to abuse structural redundancy in data when reducing it
11:08:36 <solidsnack> edwardk: Interesting.
11:08:40 <QtPlaty[HireMe]> mib_0jbn6gdc: Why?
11:09:22 <eu-prleu-peupeu> hello
11:09:26 <edwardk> solidsnack: an example of how to abuse structural redundancy, that doesn't even need the seminearring stuff is i can compress a data set using the algorithm for LZ78 and decompress it _in_ the monoidal reduction. the dictionaries never need to contain the strings
11:09:27 <MyCatVerbs> solidsnack: your nick is making me hungry.
11:09:31 <solidsnack> edwardk: Are most of the classes in this system monomorphic, like generator?
11:09:34 <QtPlaty[HireMe]> mib_0jbn6gdc: The normal pratice is to store your data as an inturnal format that makes sence, and only worry about what you see when you present it.
11:09:51 <Baughn> @remember <edwardk> [Massively impressive yet unreadable demonstration that, yes, you should be an expert in math to use Haskell]
11:09:51 <mib_0jbn6gdc> QtPlaty[HireMe]: because data sources have the values in both formats and the interactive version may also need both formats
11:09:51 <lambdabot> It is stored.
11:09:56 <edwardk> solidsnack: some, the generator stuff is specific so i can optimize for monomorphic containers, like bytestrings
11:10:09 <Gracenotes> MyCatVerbs: meh. I tend to associate solid either with mathematics or.. a certainly bodily process. See what does for your appetite. >_>
11:10:18 <solidsnack> edwardk: Interesting about the compression stuff. I will take a good hard look at this, thank you.
11:10:18 <Gracenotes> +that
11:10:47 <solidsnack> edwardk: I must step out. Cheers.
11:10:47 <QtPlaty[HireMe]> mib_0jbn6gdc: convert the data sources into your internal representaion, and then display them in whatever is approprate.
11:10:56 <MyCatVerbs> Gracenotes: I associate it with Playstation games featuring giant robots and special forces units composed entirely of the weirdest freaks in or out of the universe.
11:10:56 <pcc1> after considering the issue more I decided what I really want is something aking to a database table with fields (k1, k2, v) such that by supplying a value for a particular key (either k1 or k2) you get a list of all (k1, k2, v) in the datastructure.  does anything like this exist or will I need to implement it myself?
11:11:16 <Philonous> mib_0jbn6gdc: You could read in your deg:min:sec format to float, do some number crunching and spit it back out as deg:min:dec. If you still want to keep both datatypes you can of course. You would just have to maintain double the amount of code and besides that it would possibly be more tedious to work with three values.
11:11:34 <Baughn> pcc1: If you're thinking in terms of databases, perhaps what you want is an actual database. Sqlite?
11:11:52 <QtPlaty[HireMe]> As well as trippleing the chance of writing a bug.
11:12:28 <mib_0jbn6gdc> Philonous: I see the error of my ways....let me try the first: convert as necessary. THX.
11:12:46 <pcc1> unfortunately an actual database won't work for my application. there will be hundreds of these data structures being passed throughout the program
11:12:55 <Gracenotes> omnomnomnomnom
11:15:07 <edwardk> Baughn: am i really that bad? er wait, nevermind, don't answer that ;)
11:15:14 <voker57> how can i write if statement without else?
11:15:39 <Baughn> voker57: Doesn't really make sense. What's the value of the expression if the test fails?
11:15:43 <edwardk> baughn: as for the LZ78 stuff its really quite simple the compressor/decompressor fits in like 5 lines
11:15:49 <Baughn> voker57: In a monadic context, you can use COntrol.Monad.when/unless
11:16:02 <Baughn> pcc1: Then.. it'd be surprising if no-one has written such a package, but I'm not aware of one
11:16:05 <kadaver> does Trees use more or less or the same memory as hashtables?
11:16:19 <Baughn> kadaver: Yes
11:16:39 <voker57> Baughn: yep, i'm in monadic context... need to fail on certain condition.
11:16:44 <Baughn> kadaver: It really depends on the hash-table. And the tree.
11:17:07 <Baughn> kadaver: Some trees are /really/ dense; you can implement a heap as a flat array of values, with the nodes being implicit in their position
11:17:32 <Baughn> kadaver: But some hash-tables do similar tricks, so..
11:17:41 <Baughn> voker57: You're looking for guard, then
11:17:52 <edwardk> Baughn: http://comonad.com/haskell/monoids/dist/doc/html/monoids/src/Data-Generator-Compressive-LZ78.html mapTo' does all the work of decompressing inside of a monoid
11:18:00 <ski> edwardk : what does "monomorphic container" mean ?
11:18:03 <kiris> voker57: let if' x a = if x then a else error "OMMMVV"
11:18:28 <Baughn> voker57: guard (x == 2)
11:18:41 <edwardk> ski: just a container that can only hold one type of element. i.e. a Bytestring has bytes as elements, while a list can hold anything.
11:18:48 <Baughn> @type guard
11:18:49 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:18:52 <yakov> could anybody give me a hint if Implementation of Non-Strict Functional Programming Languages by Kenneth Traub is a good book on Haskell implementation in particular?
11:19:16 <pcc1> Baughn: thanks anyway
11:19:18 <edwardk> ski: a Generator isn't required to be polymorphic in the type of values it can contain
11:19:20 <ski> edwardk : .. oh .. i was thinking it had got to do with monomorphisms somehow
11:19:50 <edwardk> ski: nah, just lets me specialize the heck out of things
11:19:57 <ski> *nod*
11:20:11 <pk1> Is there an "easy" explanations of the maths behind the free theorems ? I don't get the paper
11:20:26 <pk1> I mean, I don't understand the paper
11:20:28 <Baughn> pcc1: I can think of one way to implement it easily, but it's.. kinda ugly
11:20:36 <edwardk> pk1: basically once you have a forall quantifying over a value, there isn't much you can do with it
11:20:43 <Baughn> pcc1: Make that /really/ ugly. Never mind.
11:21:05 <pk1> edwark, yeah, that's clear
11:21:24 <pk1> but I don't understand how it is proven
11:21:28 <edwardk> pk1: think about (forall a. a -> a), what can inhabit that type? basically the identity function and a function that bottoms out.
11:21:37 <pk1> agreedd
11:21:57 <pk1> how would you prove it though ?
11:22:11 <vixey> pk1: there is not an easy explanation
11:22:19 <pk1> at least another
11:22:38 <ski> @djinn (forall a. Either (f a) (g a)) -> Either (forall a. f a) (forall a. g a)
11:22:38 <lambdabot> Error: kind error: (KVar 3,KVar 7)
11:22:41 <edwardk> well, you bake in the definition of parametricity into your semantics in a way that you can reason about it
11:22:42 <vixey> pk1: it's not a straight forward theorem, it's a fantastically clever and devious construction
11:22:58 <edwardk> in a lot of languages you dont have parametricity, so you don't have any useful free theorems
11:23:15 <edwardk> i.e. usually languages with a strong reflection mechanism piss all over parametricity
11:23:21 <pk1> vixey, I agree. I didn't mean a different way to prove it but a different explanations
11:23:23 <vixey> pk1: the actual theorem which all free theorems come from is,  assume t : T then t<T>t (t is related to itsself by the relation <T> induced from T)
11:23:37 <vixey> pk1: and you can unfold <T> to get all the equations about the terms
11:23:58 <pk1> ho
11:24:00 <vixey> simple example is, we have  id :: forall a. a -> a
11:24:07 <Baughn> vixey: Can you restate that sentence, assuming I don't know the syntax?
11:24:21 * Baughn waits for the example
11:24:22 <vixey> that means we have:  id < forall a. a -> a > id
11:24:45 <pk1> wait
11:25:12 <Baughn> vixey: Okay. What does that mean?
11:25:16 <pk1> when you say t <T>
11:25:17 <pk1> t
11:25:24 <pk1> sry, t <T> t
11:25:34 <pk1> what does it mean ?
11:27:02 <ski> `T' is a type, `<T>' is a binary relation between elements of that type, `t <T> t' is the proposition that `t' stands in the `<T>' relation to itself
11:27:04 <pk1> argh
11:27:27 <mofmog> so if you cabal install something, where does it go
11:27:35 <Baughn> mofmog: ~/.cabal, usually
11:27:40 <pk1> so <T> it a relation from a type to the same type ?
11:27:48 <Baughn> mofmog: Unless you use --global
11:27:54 <Baughn> Or --prefix
11:28:09 <kadaver> > reverse "cigol nonsentical "
11:28:10 <lambdabot>   " lacitnesnon logic"
11:28:18 <mofmog> hrm, im trying to install hsc3
11:28:20 <vixey> so we have
11:28:21 <vixey> id < forall a. a -> a > id
11:28:22 <mofmog> and get it to work with emacs
11:28:32 <mofmog> all i see is the tar file lying about inside .cabal
11:28:32 <vixey> and the _definition_ of a forall relation in this case, would unfold to:
11:28:36 <vixey> forall X Y (f : X -> Y), id_X < #0 -> #0 > id_Y
11:28:46 <vixey> X and Y are any types, f is any function from X to Y
11:28:54 <vixey> now the def of --> relation is:
11:28:54 <vixey> forall X Y (f : X -> Y), x < #0 > y ==> id_X x < #0 > id_Y y
11:28:56 <kadaver> > reverse "lacitnesnon logic"
11:28:57 <lambdabot>   "cigol nonsentical"
11:29:11 <vixey> and for variable relations we get:  forall X Y (f : X -> Y), f x = y ==> f (id_X x) = id_Y y
11:29:19 <vixey> if you rewrite the equation you get: forall X Y (f : X -> Y), f (id_X x) = id_Y (f x)
11:29:20 <Baughn> > iterate reverse "lacitnesnon logic"
11:29:21 <vixey> @free id
11:29:22 <lambdabot>   ["lacitnesnon logic","cigol nonsentical","lacitnesnon logic","cigol nonsent...
11:29:22 <lambdabot> f . id = id . f
11:29:32 <ski> (how is the `#0' there related to `f' ?)
11:29:34 <vixey> hich is what @free gives too, but it put it through @pl as well
11:29:43 <Baughn> @free head
11:29:44 <lambdabot> f . head = head . $map f
11:29:47 <vixey> ski, I guess I am using de bruijn indices here
11:29:50 <trofi> @free beer
11:29:52 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `beer'\n\n"
11:29:59 <ski> ok
11:30:08 <Baughn> @let beer = \chug -> fix chug
11:30:10 <lambdabot>  Defined.
11:30:26 <vixey> pk1: that is how to compute free theorems -- but the question remains: why is this true/valid
11:30:27 <vixey> I gues
11:30:35 <vixey> but I wonder if what I said so far is making some senes?
11:30:53 <Baughn> ..I need a much longer explanation, preferably with pretty pictures
11:30:56 <vixey> free theorems (very carefully) defines this relation so it works out
11:30:59 <Baughn> And explosions
11:31:16 <Baughn> @free beer
11:31:17 <lambdabot> f . g = h . f => f (beer g) = beer h
11:31:23 <vixey> :t beer
11:31:24 <lambdabot> forall a. (a -> a) -> a
11:32:51 <Baughn> @free mplus
11:32:52 <lambdabot> Expected variable or '.'
11:32:58 <pk1> vixey, what does t<T>t mean ?
11:33:25 <dolio> xRy means x is related to y by the relation R.
11:33:36 <ski> @free f :: (forall a. a -> a) -> (forall a. a -> a)
11:33:37 <lambdabot> (forall g. g . x = y . g) => h . f x = f y . h
11:33:37 <pk1> so it meas
11:33:47 <ski> @free runST :: forall a. (forall s. ST s a) -> a
11:33:48 <lambdabot> Plugin `free' failed with: /tmp/ghc25834_0/ghc25834_59.hspp:(202,0)-(291,23): Non-exhaustive patterns in function freeTheorem'
11:33:52 <ski> bah
11:34:00 <dolio> (x, y) \in R
11:34:03 <pk1> <T> is a relation from T to T
11:34:11 <pk1> because t belongs to T
11:34:13 <vixey> pk1: it depends entirely what t and <T> are but for example we could have:   3 = 3,   f =/ f    f x = x,  instead of being simply (=) or (=/) it's a complicated relation built up based on the structure of the type T
11:34:23 <vixey> <T> : TxT -> []
11:34:32 <vixey> <T> : TxT -> o
11:34:36 <vixey> maybe that is more usual not sure
11:34:58 <pk1> not [TxT] ?
11:35:08 <dolio> Are we using lambda prolog?
11:35:17 <vixey> dolio yes!
11:37:45 <jeffersonheard> argh.  what would the >>= operator for Set look like if I declared Set to be an instance of Monad...
11:37:55 <jeffersonheard> Data.Set.Set, that is
11:37:58 <Baughn> jeffersonheard: That's the wrong way around
11:38:09 <Baughn> jeffersonheard: First, you define some useful combinators/functions
11:38:17 <Baughn> jeffersonheard: Then you notice that their types match the monad types
11:38:26 <Baughn> Or not
11:38:38 <jeffersonheard> ...   Why would you think I hadn't done that?
11:38:54 <Baughn> ..if you had, you wouldn't be asking. You'd already have the function
11:39:04 <seliopou> zing of the day!
11:39:05 <vixey> jeffersonheard: I'm not sure why Set is any different than []
11:39:11 <jeffersonheard> vixey, it's not
11:39:16 <Baughn> If you're having trouble defining >>=, maybe you're looking at an Applicative, not a monad
11:39:21 <dolio> It would look like 'fold (union . f) empty', but the constraints prevent a Monad instance.
11:39:22 <vixey> so why not use [] only
11:40:24 <vixey> pk1 did that make sense about <T>?
11:40:35 <EvilTerran> er, Set can't be a Monad
11:40:40 <EvilTerran> because of the Ord constraints
11:40:46 <jeffersonheard> Ah.
11:41:04 <jeffersonheard> that's more or less where I was tripping up
11:41:07 <jeffersonheard> APplicative it is...
11:41:16 <Baughn> You could define a Set wrapper that errors out if given a non-Ord, but that's.. not nice
11:41:27 <jeffersonheard> ANd pointless
11:41:27 <seliopou> I don't think it's applicative either
11:41:44 <dolio> Applicative is even worse, because you can't store functions in a set.
11:42:01 <Baughn> So, just Functor then. :P
11:42:15 <dolio> No, it's not a Functor, either.
11:42:16 <QtPlaty[HireMe]> dolio: Why can't you?
11:42:19 <jeffersonheard> oy
11:42:20 <Baughn> Ord again?
11:42:29 <dolio> QtPlaty[HireMe]: Because Set requires its element type to be in Ord.
11:42:35 <EvilTerran> ?type (\m f -> S.fold (S.union . f) S.empty m) :: (Ord a, Ord b) => S.Set a -> (a -> S.Set b) -> S.Set b
11:42:36 <lambdabot> forall a b. (Ord b, Ord a) => S.Set a -> (a -> S.Set b) -> S.Set b
11:42:47 <seliopou> dolio, not entirely true
11:42:48 <seliopou> empty
11:42:50 <EvilTerran> is what >>= would look like if you *could* define it
11:42:51 <seliopou> 8)
11:43:09 <dolio> empty doesn't have any functions in it.
11:43:29 <pcc1> is there an archive of old hpastes?  those of the form hpaste.org/DIGITS sem to has disappeared
11:43:35 <jeffersonheard> Ahh, but could I rather define Monad or Applicative over a specialization of Set, say, type BaseVisual = Set Primitive, where Primitive is definitely an Ord instance
11:43:36 <pcc1> *have
11:43:42 <Baughn> You could define an Ord instance for functions, though. Theoretically.
11:43:45 <sjanssen> pcc1: I don't think so
11:43:55 <Baughn> It would depend on having Ord instances for already-cached partial applications
11:44:13 <jeffersonheard> Baughn, this reminds me of someone discussing that Scheme can compare functions with eq?, while Haskell cannot
11:44:14 <bavardage> how do I get HXT to completely ignore doctype
11:44:29 <bavardage> since it keeps dying with "fatal error: unsupported protocol in URI "xmltv.dtd""
11:44:36 <bavardage> even though I don't care about the doctype
11:44:42 <dolio> Haskell can compre functions with reallyUnsafePtrEquality#. :)
11:44:56 <jeffersonheard> dolio, that is a painful statement.
11:45:07 <dolio> Actually, Haskell can't, but GHC can.
11:46:07 <Baughn> dolio: Those are unstable, though
11:46:14 <dancor> is there a cool way to go from Maybe to Bool
11:46:19 <dancor> like fromMonad
11:46:23 <EvilTerran> ?type isJust
11:46:24 <lambdabot> forall a. Maybe a -> Bool
11:46:29 <pcc1> in that case, I will reask the question :) what is wrong with this code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3986
11:46:31 <EvilTerran> ?src isJust
11:46:31 <lambdabot> isJust Nothing = False
11:46:32 <lambdabot> isJust _       = True
11:46:39 <dolio> Baughn: It's not an ordering, either.
11:46:42 <Baughn> dolio: What we want is for something like "(+1) < (+2)" to return true by first comparing the function pointers (and finding equality), and then using the ord instances on the one argument they already have
11:46:44 <dancor> i guess in general you can't preserve info between arbitrary monads
11:47:07 <dancor> like True -> Just defaultValue requires a default
11:47:16 <dancor> maybe like _|_
11:47:46 <dolio> Baughn: That's not going to work for functions with different implementations that nevertheless compute the same function.
11:48:43 <kadaver> we should jsut create bindings to google sparse hash?
11:48:59 <kadaver> to shut Jon Hardonk up
11:49:04 <Baughn> dolio: So it's not perfect. So sue me.
11:49:10 <kadaver> (or not wast time on him at all)
11:49:23 <dolio> The papers are in the mail.
11:50:33 <ksf> lazy graph construction, anyone? I kept staring at fgl, but providing node ids is kinda impossible if you don't know in which order the graph is constructed.
11:50:49 <Saizan_> pcc1: that you want "indices :: x -> [exists i . Ord i => x -> i]"
11:51:01 <vixey> I guess I lost pk1
11:51:01 <kosmikus> cooldude127: (lhs2TeX) no, I've never noticed problems with do notation
11:52:04 <ksf> ...the mean thing is that i really, really, don't care about the ids, just about the labels.
11:52:15 <Saizan_> pcc1: i.e. data AnyOrd = forall a. AnyOrd a, "indices :: x -> [x -> AnyOrd]"
11:53:18 <pcc1> Saizan_: thanks will try that
11:53:44 <ski>   data AnyOrd = forall a. Ord a => AnyOrd a
11:53:57 <Saizan_> yeah, right
11:54:20 <Saizan_> but that existential looks pretty useless.. in retrospect
11:54:27 <Saizan_> ?src Ord
11:54:28 <lambdabot> class  (Eq a) => Ord a  where
11:54:28 <lambdabot>     compare      :: a -> a -> Ordering
11:54:28 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
11:54:28 <lambdabot>     max, min         :: a -> a -> a
11:55:10 <Saizan_> you'd just be able to compare an element to itself
11:55:33 <ski> > nan `compare` nan where nan = 0 / 0
11:55:35 <lambdabot>   GT
11:56:52 <QtPlaty[HireMe]> Saizan_: The other one is comparing two floats
11:56:55 <Gracenotes> wha
11:58:08 <Saizan_> QtPlaty[HireMe]: uh?
11:58:22 <Gracenotes> > map (flip join (0/0)) [(<), (==), (>), (>=), (<=)]
11:58:24 <lambdabot>   [False,False,False,False,False]
11:58:55 <pumpkin> lol
11:58:55 <Gracenotes> hum. I guess it has to give an answer that's an Ordering
11:59:02 <QtPlaty[HireMe]> Saizan_: Because Real numbers can't be computered, the floating point approximentations can be diffrent even though they should be equil.
11:59:12 <pumpkin> > join compare (0/0)
11:59:15 <lambdabot>   GT
11:59:18 <pumpkin> ORLY
11:59:23 <Saizan_> QtPlaty[HireMe]: i don't understand why you're saying that to me
11:59:41 <Gracenotes> > sort [0/0, 2, 6, 0/0, 2, 1/0, -1/0]
11:59:43 <lambdabot>   [-Infinity,2.0,Infinity,NaN,2.0,6.0,NaN]
11:59:45 <Saizan_> ?src compare
11:59:45 <lambdabot> compare x y | x == y    = EQ
11:59:45 <lambdabot>             | x <= y    = LT
11:59:45 <lambdabot>             | otherwise = GT
11:59:59 <ski> hehe
12:00:00 <pumpkin> fail
12:00:00 <Gracenotes> uh. At least the regular numbers are sorted.
12:00:27 <QtPlaty[HireMe]> I mave have missunderstood the meaning of 'you'd just be able to compare an element to itself"
12:01:01 <Saizan_> QtPlaty[HireMe]: i was talking about AnyOrd
12:01:19 <QtPlaty[HireMe]> Oh
12:01:45 <rabideejit> Do any other programming languages use the stg machine?
12:02:04 <QtPlaty[HireMe]> stg?
12:02:13 <rabideejit> spineless tagless and g
12:02:22 <pumpkin> about this stg thing, is the progress: haskell -> core -> STG -> cmm ?
12:02:26 <pumpkin> -> native
12:03:09 <rabideejit> I'm not a GHC developer but I think it says on the trac that yes that is the case, except on some platforms it goes cmm -> c -> native
12:03:31 <pumpkin> ah yeah
12:03:32 <jeffersonheard> So, okay...  the one thing I don't understand is earlier we said that Set couldn't be a monad because of the Ord constraints, but how is that any different from the declared Monoid instance?
12:03:59 <ski> which instance ?
12:04:04 <Gracenotes> so, for double equality, translateOp FloatEqOp     = Just (MO_Eq F32)
12:04:06 <ski> the one for `Writer w' ?
12:04:19 <Gracenotes> er, translateOp DoubleEqOp     = Just (MO_Eq F64). the other one is float.
12:04:32 <pumpkin> jeffersonheard: not sure if this is relevant to your question, but there's an rmonad
12:04:48 <Saizan_> jeffersonheard: since Monoid is for types of kind *, you can add the Ord a => constraint in the instance head
12:05:13 <ski>   instance Monoid w => Monad (Writer w)
12:05:27 <Saizan_> instance Ord a => Monoid (Set a) where .. instance Ord a => Monad Set -- ops no 'a' here
12:05:27 <ski> is ok, since we're not constraining the monadic result parameter, here
12:06:28 <Gracenotes> condFltReg cond x y = do { CondCode _ cond cond_code <- condFltCode cond x y; tmp <- getNewRegNat I8; let { code dst = cond_code `appOL` toOL [ SETCC cond (OpReg tmp), MOVZxL I8 (OpReg tmp) (OpReg dst) ] }; return (Any I32 code) }
12:06:41 <Gracenotes> so the NaN equality thing is rather hard-coded
12:06:42 <pumpkin> lol, wonderful
12:07:09 <jeffersonheard> Saizan_, I thought Monad was also for types of kind *...  or is it * -> * ...
12:07:17 <ski> the latter
12:07:28 <ski> @kind Maybe
12:07:29 <jeffersonheard> oh, wait.  I see why
12:07:30 <lambdabot> * -> *
12:07:31 <ski> @kind IO
12:07:32 <lambdabot> * -> *
12:07:32 <jeffersonheard> got it
12:07:36 <Gracenotes> this is yielded by the getRegister function. Oh, GHC.. I shall conquer you one day
12:07:41 <Gracenotes> well not really
12:08:08 <jeffersonheard> @kind: Set
12:08:09 <lambdabot> Not in scope: type constructor or class `Set'
12:08:13 <jeffersonheard> @kind: Data.Set.Set
12:08:14 <lambdabot> * -> *
12:08:29 <vixey> haskell is so complex the type system has a type system
12:08:43 <MyCatVerbs> vixey: ah, but the type system's type system is untyped.
12:09:02 <MyCatVerbs> vixey: and the type system's type system doesn't enforce anything other than correct numbers of arguments. :)
12:09:13 * ski wonders when the first use for a type system for the kinds will turn up
12:09:15 <vixey> every syntactically valid term is valid I think that is a type system
12:09:42 <jeffersonheard> I'm beginning to hear Goedel laughing at us for things like that, ski
12:09:42 <vixey> <K> ::= * | <K> -> <K>
12:09:59 <edwardk> ski: i have a ton of uses for kind polymorphism
12:10:15 <ski> edwardk : yes .. but kind parameters ?
12:10:18 <rabideejit> edwardk: Hello again
12:10:37 <edwardk> ski: in fact, most of them are for rabideejit here ;)
12:10:37 * vixey couldn't think of a single example of kind polymorhpism
12:10:48 <ski> (kind polymorphism i already know of use cases for)
12:10:55 <roconnor> MyCatVerbs, that's not true.  Compare (* -> *) -> * with * -> *
12:11:09 <rabideejit> the lack of kind polymorhpism makes doing Lots of things in the type system very difficult.
12:11:12 <vixey> what are some examples?
12:11:19 <roconnor> MyCatVerbs: well, maybe what you said is true with a liberal enough interpretation
12:11:26 <dolio> UHC has kind polymorphism, apparently.
12:11:35 <rabideejit> dolio: oooh
12:11:40 <ski>   Compose :: forall_kind k0 k1 k2. (k0 -> k1) -> (k1 -> k2) -> (k0 -> k2)
12:12:16 <dolio> I still need to figure out how to get it to install with libraries.
12:12:36 <MyCatVerbs> roconnor: AIUI, it enforces that you can't give too many arguments to any type constructor, and that you can't have values with any kind other than *?
12:12:59 <pumpkin> rabideejit: what kinds of things can you not do without kind polymorphism? I assume you don't mean taking advantage of ? and ??
12:13:00 <MyCatVerbs> @pl (\f -> fileLines f >>= putStrLn)
12:13:00 <lambdabot> (putStrLn =<<) . fileLines
12:13:53 <ski> (using `?',`??' would not strictly be kind-polymorphism)
12:14:16 <pumpkin> ah, so I'm just confused, I thought there were only 3 or 4 distinct kinds
12:14:24 <pumpkin> but I guess you could substitute * for (* -> *) ?
12:14:25 <rabideejit> pumpkin: wait a second, I kinda wanna prepare an example properly so I'm not talking crap. :)
12:14:29 <pumpkin> oh ok
12:14:30 <edwardk> vixey: type level combinators. think about 'curry' and 'uncurry', you can make data families for them, but in general you have to specialize them to the particular kinds, so they are a lot less useful than their polymorphic term level counterparts
12:15:00 <vixey> you can't define type level combinators though because we don't have functions at type level
12:15:16 <pumpkin> are there any plans for introducing them?
12:16:03 <ski> (there can still be "trivial" type level combinators, in the sense of `newtype', et.c.)
12:16:32 <ski> pumpkin : well, it'd be nice to guarrantee type-checking terminating
12:16:35 <rabideejit> I ran into some probablems trying to create the state monad in the type system.
12:16:55 <ski> (rabideejit : like lack of proper product kinds ?)
12:17:17 <vixey> state monad in the type system what ??
12:18:03 <rabideejit> See this is where a good example would be excellent, so I have to go finish typing it out.
12:18:17 <edwardk> vixey: yes, we do have them. we have type families
12:18:20 * ski recalls his type-CPS
12:18:30 <edwardk> vixey: type and data families let you define all sorts of type-foo
12:18:44 <edwardk> vixey: you just can't do unbounded recursion
12:18:57 <Berengal> Types are hard. Let's go shopping!
12:19:15 * pumpkin goes shopping
12:19:57 <Berengal> Since when did types stop being simple value annotations?
12:20:05 <Berengal> I'm asking this sincerely
12:20:15 <Berengal> I want to know what type-level programming can give me
12:20:23 * SubStack hindley-milner-infers Berengal 
12:20:48 <jeffersonheard> Okay, now I actually think I get the kind system...
12:20:59 <dolio> type family Arity (t :: k) :: * ; type instance Arity Int = Z ; type instance Arity Maybe = S Z ; ... :)
12:21:54 <Philippa__> Berengal: it can give you never trying to access an array out of bounds, for example
12:22:00 <dolio> Arity :: Forall k. k -> *
12:22:28 <Philippa__> it can give you keeping track of all kinds of properties - ones that need a little computation to follow, if that makes sense
12:22:51 <Berengal> Philippa__: In a way...
12:23:01 <Berengal> It also sort of reminds me of lisp macros... running code at compile time
12:23:12 <kadaver> http://en.wikibooks.org/wiki/Data_Structures/Min_and_Max_Heaps <- regarding heaps. just append the element to the arrray, i assume they mean to the end of it?
12:23:22 <kadaver> so I have to dynamically malloc in C?
12:23:35 <Philippa__> Berengal: yeah, they're very different in practice though
12:23:56 <Philippa__> (though it is true that you can use type classes to do type-based code generation for you)
12:24:20 <Berengal> Philippa__: I'm sure I could define some create-array and dereferece-array macro in lisp that checked arrays at compile-time...
12:24:48 <Berengal> Well, a sometimes-working, ugly hack macro that is.
12:25:11 <Philippa__> Berengal: not really, not the same way. Haskell can buy you an index type that /has/ to be in range, wherever the hell it came from
12:25:38 <Philippa__> lisp can't unless you superimpose a type system on it
12:26:01 <edwardk> bah type systems are overrated ;)
12:26:03 <Berengal> Philippa__: Or you rewrite the entire language to use macros...
12:26:19 <Philippa__> Berengal: no. What's stopping another macro from slipping bullshit under the radar?
12:26:25 <edwardk> Berengal: that would be a form of two level compilation... or type system if you prefer ;)
12:27:01 <Philippa__> edwardk: or embedding a typechecked language in lisp :-)
12:27:23 <Berengal> Philippa__: If you only expose the fundamental macros to the programmer, that's not a problem...
12:27:28 <Berengal> And yes, I see how this converges
12:27:34 <Philippa__> Berengal: then you're not writing lisp any more :-)
12:28:36 <eu-prleu-peupeu> hi
12:28:36 <Berengal> Philippa__: Well, defining lisp is hard... "It has parenthesis, like, and they're, like, trees... dude."
12:28:42 <eu-prleu-peupeu> has anyone managed to build sdl in windows ?
12:28:47 <eu-prleu-peupeu> i could have a hand :/
12:28:52 <mmorrow> you can do repeated concats/whatever with type families
12:29:01 <mmorrow> , nesty $(nat 4) (:[]) 42
12:29:03 <lunabot>  [[[[[42]]]]]
12:29:10 <Philippa__> Berengal: well, you might be embedding a different lisp in the one you started with, but still
12:29:11 <mmorrow> , [$ty| nesty $(nat 4) (:[]) 42 |]
12:29:13 <lunabot>  forall a . Num a => Nest (N (N (N (N ())))) [] a
12:29:20 <Philippa__> hell, in a pinch you can embed /the same one/
12:29:20 <kadaver> eu-prleu-peupeu: yes i have with mingw!
12:29:20 <mmorrow> , $(nat 4)
12:29:22 <dolio> "I can graft an ad hoc, informally-specified, bug-ridden type system on top of lisp using macros."
12:29:23 <lunabot>  S (S (S (S Z)))
12:29:25 <dolio> That sounds familiar.
12:29:40 <rabideejit> Berengal: To be fair, the only tools I've seen which use type programming extensively are libraries which interact with Things outside haskell.  The bindings for LLVM use functional dependencies for type programming, you can see a use for it in the core/codegen module ( which is hidden )
12:29:43 <Berengal> Philippa__: Would turn into haskell with parenthesises... Yeah, I get it
12:29:57 <pumpkin> , [$ty| nasty |]
12:29:57 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166#a2166
12:29:58 <MyCatVerbs> Berengal: no dice, we already have Liskell. :)
12:29:59 <pumpkin> , [$ty| nesty |]
12:30:00 <lunabot>  luna: Exception when trying to run compile-time code:
12:30:02 <lunabot>  forall a b c . N c -> (forall d . d -> b d) -> a -> Nest c b a
12:30:09 * SubStack </3 parens
12:30:09 <mmorrow> pumpkin: heh, i had to add a 'y' since
12:30:11 <mmorrow> , 'nest
12:30:12 <lunabot>  Text.PrettyPrint.HughesPJ.nest
12:30:21 <pumpkin> ack, epic lag
12:30:26 <dolio> , [$ty| either Right Left |]
12:30:29 <lunabot>  forall a a . Either a a -> Either a a
12:30:29 <mmorrow> heh
12:30:30 <Berengal> MyCatVerbs: Liskell is funky...
12:30:54 <mmorrow> dolio: i've done nothing
12:30:58 <dolio> :)
12:31:04 <mmorrow> :)
12:31:19 <SubStack> :]
12:31:22 <pumpkin> :( lagggg
12:31:30 <mmorrow> , nesty $(nat 18) (:[]) 42
12:31:32 <lunabot>  [[[[[[[[[[[[[[[[[[[42]]]]]]]]]]]]]]]]]]]
12:31:40 <mmorrow> , nesty $(nat 400) (:[]) 42
12:31:43 <lunabot>  luna: Context reduction stack overflow; size = 20
12:31:45 <SubStack> O_O
12:32:01 <mmorrow> stack overflows it teh type system!
12:32:09 * SubStack approves
12:33:16 <edwardk> the reason i wrote a bunch of code for type level hexadecimal 2s complement integers was i was overflowing the context stack with binary far too early =)
12:33:41 <Berengal> Needs more stack
12:33:49 <Berengal> You can never have enough stack
12:33:53 <edwardk> 2^(18*4) is a lot bigger number than 2^18 and a lot more useful as an upper bound
12:34:01 <dolio> Perhaps Conor will save us all with his non-sucking type-level numerics.
12:34:06 <edwardk> when you are trying to say how big arrays can be
12:34:13 <edwardk> could be nice
12:34:25 <Berengal> > 2^(18*4)
12:34:26 <lambdabot>   4722366482869645213696
12:34:29 <rabideejit> dolio: link?
12:34:50 <edwardk> dolio: he advertised for a ph.d student position to work on said feature
12:34:59 <edwardk> er rabideejit
12:35:12 <rabideejit> Ahh I see
12:35:15 <rabideejit> It would be good!
12:35:26 <pumpkin> yeah, I wonder if anyone applied
12:35:39 <pumpkin> it sure would be nice
12:35:49 <dolio> You can look for it around March 14th on haskell-cafe.
12:35:54 <rabideejit> Cheers
12:37:08 <edwardk> i'd love to do add a ph.d to the wall, but can't really justify committing financial suicide
12:42:43 * edwardk hears a pin drop.
12:43:45 <wchogg> Heh, I don't know if I'd call it financial suicide.  A vow of poverty, perhaps.
12:44:01 <edwardk> wchogg: =)
12:44:27 <wchogg> edwardk : of course I have to rationalize my decision to go back & start my phd this year :p
12:45:22 <gwern> edwardk: financial suicide? and what else are you going to do with a detailed knowledge of type-level programming & category theory? :)
12:45:30 <edwardk> wchogg: hah. sok, i have to rationalize my decision to leave academia and earn a paycheck. ;)
12:45:52 <mofmog> i have hsc3 running and installed
12:46:03 <mofmog> however, starting it up seems wonky
12:46:53 <edwardk> gwern: i picked what little of each that I know, while looking for better tools for dealing with parallelism. Ultimately, I like to pretend that I'm secretly a pragmatist ;)
12:47:07 <mofmog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3991#a3991
12:48:06 <gwern> type-level parallelism using morphisms for ultra-fast reddit browsing?
12:48:08 <gwern> mind-blowing
12:48:55 <mofmog> meh i spent so long getting hsc3 installed and it wont even load right -_-
12:50:19 <rabideejit> mofmog: supercollider is awesome, lemme 'av a look mate
12:50:47 <mofmog> ok
12:50:51 <mofmog> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3991#a3991
12:50:54 <mofmog> that's basicallyt hte error
12:50:58 <mofmog> the server starts
12:51:02 <mofmog> jackd works
12:51:08 <mofmog> and im using it via emacs
12:51:24 <mofmog> (the error occurs after C-c C-s)
12:52:11 <mmorrow> , $(tupE (fmap nat [1..100]))
12:52:13 <lunabot>  luna: A 100-tuple is too large for GHC
12:52:20 <rabideejit> well, I've not seen the tutorial source, but it is trying to load "Sound.SC3.UGen.Unsafe" which is not an exposed module on hsc3 here http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc3
12:52:21 <mmorrow> , $(tupE (fmap nat [1..62]))
12:52:25 <lunabot>  luna: No instance for (GHC.Show.Show
12:52:29 <mmorrow> , $(tupE (fmap nat [1..10]))
12:52:32 <lunabot>  (S Z,S (S Z),S (S (S Z)),S (S (S (S Z))),S (S (S (S (S Z)))),S (S (S (S (...
12:52:46 <rabideejit> maybe the tutorial was written for an earlier version
12:53:08 <vixey> omg
12:53:15 <vixey> , [$ty|nat|]
12:53:17 <lunabot>  Int -> ExpQ
12:53:25 <mmorrow> , $(tupE (fmap (\n -> [|(toInt $(nat n), $(nat n))|] [1..10]))
12:53:26 <lunabot>  luna: parse error (possibly incorrect indentation)
12:53:27 <mmorrow> , $(tupE (fmap (\n -> [|(toInt $(nat n), $(nat n))|] [1..10])))
12:53:28 <mofmog> hrm
12:53:28 <lunabot>  luna: Couldn't match expected type `t -> b'
12:53:32 <mofmog> the tutorial came with the package
12:53:36 <vixey> oh it's type level nat
12:53:38 <mofmog> i cabal installed it
12:53:40 <mmorrow> , $(tupE (fmap (\n -> [|(toInt $(nat n), $(nat n))|]) [1..10])))
12:53:41 <lunabot>  luna: parse error on input `)'
12:53:42 <mmorrow> , $(tupE (fmap (\n -> [|(toInt $(nat n), $(nat n))|]) [1..10]))
12:53:45 <lunabot>  ((1,S Z),(2,S (S Z)),(3,S (S (S Z))),(4,S (S (S (S Z)))),(5,S (S (S (S (S...
12:53:54 <mofmog> how do you have it set up? or do you use supercollider's own lang?
12:54:05 <mmorrow> , $(nat 10)
12:54:07 <lunabot>  S (S (S (S (S (S (S (S (S (S Z)))))))))
12:54:14 <vixey> , $(nat infinity)
12:54:16 <lunabot>  luna: Not in scope: `infinity'
12:54:23 <mmorrow> vixey: it's just for convenience so you don't have to actually type it out
12:54:26 <vixey> oh it's Int
12:54:30 <vixey> , $(nat 445245)
12:54:32 <mmorrow> , toInt $(nat 10)
12:54:35 <lunabot>  10
12:54:36 <lunabot>  Killed.
12:54:40 <rabideejit> mofmog: yeah, hsc3-0.4 has Sound.SC3.UGen.Unsafe.  Maybe you could try with that version, but if I were you, I'd send an email to the maintainer reporting the buggy tutorial ( or bugtraq, or whatever if it has it ).  Perhaps edit the tutorial to remove references to this "unsafe" module.
12:54:49 <mmorrow> , nesty $(nat 10) (:[]) 42
12:54:51 <lunabot>  [[[[[[[[[[[42]]]]]]]]]]]
12:55:11 <mofmog> meh, i might as well just learn supercollider
12:55:49 <rabideejit> it's pretty cool anyway.  I kinda wanted to use the haskell bindings, 'cus I thought writing  GUI for supercollider would be cool.
12:56:04 <mmorrow> vixey: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2166#a2166
12:56:05 <kiris> bitches don't know bout my supercollider
12:56:31 <mofmog> ugh, now .lhs are associated with hsc3
12:57:01 <rabideejit> kiris: you found a boson in yo livin room?
12:59:07 <mofmog> why the hell is the first for supercollider on google an outdated 2001 lookingish website
12:59:17 <rabideejit> or was that rude and you wrote the package ( sorry )?
12:59:27 <Berengal> @google supercollider
12:59:28 <lambdabot> http://www.audiosynth.com/
12:59:28 <lambdabot> Title: The SuperCollider Home Page
12:59:43 <mofmog> there's a link right there to the modern homepage
13:00:05 <mmorrow> , $(fmaps 10) (*2) (nesty $(nat 9) Just 42)
13:00:07 <lunabot>  Just (Just (Just (Just (Just (Just (Just (Just (Just (Just 84)))))))))
13:00:08 <rabideejit> supercollider is cool for sin oscillators.  I wonder if it has any realtime use in anything other than audio.
13:02:05 <pcc1> is it not possible to use functional dependencies in data declarations to avoid unnecessary type parameters  (e.g. "class Foo a b | a -> b"..."data Foo a b => Bar a")
13:02:16 <rabideejit> kiris: You have me intrigued to an extraordinary degree. ( Thought I don't mean to worry you )  What do you mean?  Do you have another supercollider package?
13:03:45 <boegel> @tell MyCatVerbs you poked me some time ago?
13:03:46 <lambdabot> Consider it noted.
13:10:14 <Berengal> Where is the functor instance for ((->) r) defined?
13:10:44 <mauke> probably in Control.Monad.Instances
13:10:55 <kadaver> http://en.wikibooks.org/wiki/Data_Structures/Min_and_Max_Heaps <- can someone explain to me why they refer to [1] as min in one place and [0] in another?
13:11:01 <ski> `Control.Monad.Reader', too iirc
13:11:15 <RayNbow> also in Control.Arrow
13:11:40 <Berengal> Huh, Control.Monad.Instances only contains that functor instance and the monad class?
13:12:19 <marcot> Hello, why the Traversable class requires the type to be Functor and Foldable?
13:14:20 <marcot> IOList a => IORef [a] is possible to write a mapM for it, but not a fmap.
13:15:11 <Berengal> ?src sequence
13:15:12 <lambdabot> sequence []     = return []
13:15:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:15:12 <lambdabot> --OR
13:15:12 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:16:21 <cooldude127> kadaver: sometimes the size of the heap is kept in the 0 place, sometimes not
13:17:36 <marcot> It seems to me that my problem is that I'd like to write mapM for a data type, and I thought I could use Traversable for this.
13:17:45 <marcot> But this doesn't seem to hold.
13:17:53 <Berengal> marcot: How would you write mapM for IORef?
13:23:40 <ker2x_> Friendly Greetings \o/
13:23:50 <vixey> hi
13:24:27 <Berengal> I'm trying to figure out if I can make some nice operators for folds...
13:24:39 <ker2x_> i'm reading learnyouhaskell, very good tutorial. much more easier than "real world haskell" :)
13:24:43 <marcot> Berengal: I had in my gtk2hs ListStore.
13:24:46 <pumpkin> operators for folds?
13:24:56 <Berengal> What I have now:
13:25:07 <edwardk> Berengal: as in like horrible infix things?
13:25:08 <Berengal> (\:) xs f d = foldr f d xs
13:25:20 <pumpkin> ah
13:26:08 <Berengal> I was very happy with my (.) = fmap definition, so I figured it should be possible for other functions as well...
13:26:10 <vixey> Berengal that is not nice
13:26:31 <Berengal> vixey: The (.) or the folds?
13:26:35 <vixey> \:
13:26:40 <Berengal> Yeah, I know...
13:27:06 <vixey> Berengal, actually did you get the idea from APL ? or J ?
13:27:08 <edwardk> (.) = fmap has been floating around for a while
13:27:09 <Berengal> I need a way to express "crush" in a few punctuations...
13:27:13 <jeffersonheard> @instances Graphics.Rendering.OpenGL.GL.Types.GLuint
13:27:13 <lambdabot> Couldn't find class `Graphics.Rendering.OpenGL.GL.Types.GLuint'. Try @instances-importing
13:27:19 <Berengal> vixey: scala, actually...
13:27:25 <jeffersonheard> @instances-importing Graphics.Rendering.OpenGL.GL.Types GLuint
13:27:25 <lambdabot> Couldn't find class `GLuint'. Try @instances-importing
13:27:27 <vixey> oh weird
13:27:45 <Berengal> edwardk: Yeah, I know I'm not the first one
13:28:13 <Berengal> vixey: In scala you can do stuff like Range(1,10,1)./:(1) (_*_)
13:28:23 <ker2x_> what's fmap ? :)
13:28:29 <pumpkin> functor map!
13:28:33 <Berengal> @type fmap
13:28:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:28:39 <mauke> ker2x_: generalized map; works on any container
13:28:43 <pumpkin> it map a function over mappable things :P
13:28:58 <pumpkin> not just a container
13:29:09 <pumpkin> well, I guess it depends what you mean by a container :)
13:29:26 <Berengal> > let (.) = fmap in ((*2).(+5)) . [1..10]
13:29:27 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
13:29:29 <marcot> Berengal: What I want is mapArray.  Thanks.
13:29:31 <Berengal> :/
13:29:36 <segher> a container is something you can fmap in, heh
13:29:42 * ker2x_ try ton understand the fmap definition... mmm... i think i need to read 1 or 2 more of learnyouhaskell page :)
13:29:45 <Berengal> fmap fmap fmap...
13:30:21 <kadaver> how can you pass --extra-include-dirs to cabal?
13:30:23 <jeffersonheard> well, I'm not going to whine about it, but :  (fromIntegral (-20)) :: Data.Word.Word32 -> 4294967276
13:30:40 <jeffersonheard> sensible, if semantically meaningless
13:37:24 <pumpkin> kadaver: by putting that on the end of your command line :P
13:43:24 <pumpkin> jeffersonheard: yeah :/
13:43:24 <edwardk> berengal: cale and i figured it out some time around http://comonad.com/reader/2006/generalizing-dot/ (he posted it to the cafe, and i wrote that article after we had a discussion over on ##logic of all places) there are a few other non obvious extensions for (.) that conflict with the fmap version though
13:43:24 <pumpkin> there's a wiki page on caleskell
13:43:24 <Berengal> Hmmm
13:43:24 <edwardk> not least is the one in Control.Category
13:43:24 <ker2x_> i have the feeling that haskell can be easily obfuscated... am i right ?
13:43:24 <pumpkin> yup, just make all your names be sequences of question marks
13:43:24 <mofmog> christ, why doesn't gtk2hs work either >_<
13:43:24 <edwardk> ker2x_: so can most any interesting language =)
13:43:24 <pumpkin> and/or use @pl where it doesn't belong
13:43:24 <Berengal> edwardk: So you can't have the cat (.) at the same time as functor (.)?
13:43:24 <mofmog> i installed it from the debian repos but Graphics.UI.Gtk doesnt import
13:43:24 <Berengal> It still seems like fmap should have its own operator...
13:43:24 <edwardk> berengal: the generalizations fail. its been a while since i showed the conflict, but basically they only collapse if you have the hom of the category and the exponential of the category as the same type. iirc
13:43:24 <edwardk> @type (<$>)
13:43:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
13:43:24 <Saizan> mofmog: ghc-pkg list gtk?
13:43:24 <Berengal> <$> is too hard to write if I need it lots...
13:43:24 <mofmog> /usr/local/lib/ghc-6.10.2/./package.conf:
13:43:24 <mofmog> /home/andrew/.ghc/i386-linux-6.10.2/package.conf:
13:43:24 <Berengal> Although I guess it will do for anything outside my scratchpad.hs
13:43:24 <Saizan> mofmog: ok, so it's probably installed for a different compiler.
13:43:24 <edwardk> Berengal: i kind of like the <> proposal somebody made
13:43:24 <mofmog> >_<
13:43:24 <Saizan> mofmog: like an older version of ghc on your machine
13:43:24 <mofmog> i only have 6.10.2 insstalled as far as i can tell
13:43:24 <mofmog> hrm
13:43:24 <mofmog> i installed it from the tar, never installed from repos
13:43:24 <mofmog> i assumed it would overwrite older versions
13:43:24 <Berengal> There should be more non-alphanumeric characters present on a keyboard...
13:43:24 <mofmog> i guess the solution is to install from source??
13:43:24 <pumpkin> Berengal: we were just talking about that this minute in #haskell-in-depth :P
13:43:24 <Berengal> mofmog: I'm on ubuntu. I have to install from source...
13:43:24 <mofmog> yeah
13:43:24 <mofmog> im doing it right now
13:43:24 <mofmog> the repo version is borked for us
13:43:47 <eu-prleu-peupeu> im trying to build the sdl binding in windows, and it complaints about having multiple main definitions, here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3992#a3992   can anyone solve this kind of problem ?
13:46:00 <eu-prleu-peupeu> :/
13:46:55 <eu-prleu-peupeu> help please
13:47:11 <ker2x_> i wish i could :)
13:48:03 <mofmog> installing haskell libraries should be 100% less painful
13:48:11 <mofmog> and by that i mean they should all be cabalized
13:48:17 <mofmog> also cabal should come with ghc
13:48:27 <mofmog> cabal install i mean
13:48:39 <eu-prleu-peupeu> cabal blows because it doesn't find the sdl include :/
13:49:29 <eu-prleu-peupeu> ehhh :(
13:49:31 <mofmog> oh christ, gtk2hs takes forever to build
13:50:09 <Berengal> mofmog: It takes a while, but not too long... Then again, I build ghc I half an hour...
13:50:27 <Berengal> in*
13:50:36 <eu-prleu-peupeu> what about sdl in windows ? :P
13:51:23 <Berengal> eu-prleu-peupeu: The only things I've got installed in windows are left 4 dead and emipre: total war, I'm afraid...
13:51:47 <eu-prleu-peupeu> :)
13:52:35 <ker2x_> how "fast" is haskell ? can i expect some good performance, for exemple, if i build web server in haskell ? is there something i should know about haskell performance ?
13:52:50 <skorpan> it's only as fast as you make it
13:53:09 <Berengal> ker2x_: http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all&box=1
13:53:11 <mofmog> haskell is quite slow
13:53:14 <mofmog> it's interpreted
13:53:17 <mofmog> and fully functional
13:53:24 <mofmog> it has to go through a lambda-interpreter first
13:53:28 <mauke> mofmog: excuse me wtf r u doin
13:53:43 <ker2x_> sure, butr some langage are very bad in some topic. eg : parsing GByte of text
13:54:04 <skorpan> mofmog: are you trolling?
13:54:10 <mofmog> obviously
13:54:11 <mofmog> sorry
13:54:20 <ker2x_> interpreted ? huh ? :)
13:54:28 <Berengal> Haskell can have very variable performance... If you're not careful and unlucky it can be slower than python...
13:54:51 <mofmog> it's actually quite fast
13:55:29 <Saizan> ker2x_: ghc compiles to machine code
13:55:48 <ker2x_> well, so, there is no known huge bottleneck ?
13:55:50 <sebaseba> @faq Can Haskell run lightning-fast?
13:55:50 <lambdabot> The answer is: Yes! Haskell can do that.
13:56:41 <mofmog> well
13:56:46 <mofmog> the array libraries are kinda
13:56:47 <mofmog> heh
13:56:54 <Saizan> ker2x_: there are some things to be aware of, like adding strictness annotations were appropriate, especially for primitive types
13:57:23 <mofmog> stuff like why foldl, foldr, foldl', and foldr' result in vastly different running times
13:57:41 <Saizan> foldr' having almost no sense
13:57:41 <ker2x_> k :)
13:58:09 <Berengal> It's nothing to worry about at first though...
13:58:13 <mofmog> saizan: this is the 1980s and i use foldr' as a hack to make the timing of my game right
13:58:38 <Saizan> with stack oveflows?
13:58:46 <kadaver> what do you do for error-codes in C? isnt using 0 for failure really bad since 0 could ver well be valid for a lot of fucntions to return?
13:59:16 <Berengal> kadaver: You could always set a global error-variable
13:59:21 <kadaver> struct maybe  :P
13:59:35 <kadaver> Berengal: thats what i do but msot peoples ay they use enums
13:59:59 <Berengal> kadaver: You still need to return that enum somehow
14:01:00 <monadic_kid> someone say oragami programming?
14:01:11 <Berengal> Having a dedicated box called "here be errors only. No values allowed" is needed to tell the difference between values and errors when all you've got is numbers...
14:02:48 <kadaver> hence FAILURE=0 is terrible...
14:02:50 <ibid> kadaver: returning zero is ok only if it is not a valid return value; other techniques include a pointer argument for either the result or the error value (see strtol) and global error variables (see errno)
14:03:55 <monadic_kid> boost::optional, wants to be a maybe
14:04:22 <monadic_kid> but i'm guessing this is something for haskell FFI so forgot that
14:05:12 <monadic_kid> ker2x_: http://www.cs.nott.ac.uk/~gmh/fold.pdf
14:05:30 <ker2x_> reading, thx
14:06:46 <monadic_kid> A tutorial on the universality and expressiveness of fold
14:06:46 <Berengal> Returning an error even when it's not a valid return value can be bad as well. It could hide a bug in the implementation...
14:06:46 <monadic_kid> I think the book "The fun of programming" had a chapter on oragami programming
14:07:22 <Berengal> ... is it possible to make a turing complete language with only lists, numbers and foldr?
14:07:31 <monadic_kid> Berengal: yeah thats why directx sdk has debuging tools which inject code in debug builds so code that doesn't bother checking you can do things like break on folds
14:07:50 <monadic_kid> errr i mean break on error codes
14:07:59 <bremner> Berengal: if everything terminates, how can it be turing complete?
14:08:12 <Berengal> ... replicate as well?
14:08:16 <edwardk> what i've been trying to do is figure out how much of the time you really need all the different folds and when you could just get by with a monoidal fold
14:08:17 <Berengal> or repeat...
14:08:22 <Berengal> (or cycle)
14:08:30 <Berengal> I dunno...
14:08:34 <edwardk> then its not foldl, foldr, or whatever its just fold
14:09:12 <edwardk> and the container can do whatever is efficient for the container
14:09:31 <edwardk> though, that said i want a nice efficient way for the container and the reduction to cooperate the figure out the best direction
14:10:18 <dolio> Yeah, what is efficient is not dependent solely on the container.
14:10:22 <edwardk> and i haven't come up with a nice way to do that. i've been leaning towards a system of type family based c++ style 'iterator traits' that each can expose that i can use to build a nice canonical set of combinators, but its ugly
14:11:13 <mofmog> sucess, gtk2hs works
14:11:30 <monadic_kid> what was that paper called again on catamorphisms, Hylomorphism, Anamorphism, etc, etc?
14:11:33 <equaeghe> I've encountered a problem cabal install'ing a package (hmatrix) and need guidance on resolving it (new to IRC BTW)
14:11:45 <edwardk> i.e. it'd be able to say that you're reducing with something that has an absorbing zero, so you can short circuit it, or that the container supports random access, or that the operation takes a long time so you should run a lot of stuff in parallel
14:11:54 <vixey> bananna outerspace lenses
14:12:04 <monadic_kid> bug eyd lenses
14:12:24 <edwardk> or that the reducer works better left to right and can support an efficient monadic folding operation
14:12:40 <monadic_kid> which reminds nice blog on that http://ulissesaraujo.wordpress.com/2009/04/09/hylomorphisms-in-haskell/
14:13:28 <monadic_kid> http://ulissesaraujo.wordpress.com/2009/04/09/more-hylomorphisms-in-haskell/
14:14:12 <edwardk> monadic_kid: that reminds me i never did blog the nice commutative diagram for a generalized hylomorphism
14:14:33 * Berengal now has over 40 open tabs in firefox he needs to read through...
14:14:33 <edwardk> in fact i worked them all out for all of the different foomorphisms
14:17:40 <monadic_kid> can never have enough lambdacats! http://arcanux.org/lambdacats.html
14:18:04 <monadic_kid> When Guinea pigs test is awesome
14:18:26 <monadic_kid> "O Hai! I maded U a test case            but I eated it."
14:18:34 <monadic_kid> :P
14:19:38 <monadic_kid> "Mummy!!! iz there really undecidable" - Type system under may bed?!
14:20:37 <ker2x_> scarry :)
14:21:10 <monadic_kid> Polymorphic cat, haz class!
14:27:02 <ker2x_> i just understood foldr reading lambdacats :)
14:27:18 <BONUS> @seen dons
14:27:18 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 8h 54m 7s ago.
14:28:33 <skorpan> i have a function "toStrokes :: (lol -> lol) -> [lol] -> Endo [Stroke]"...  so basically i want to apply the function "f :: lol -> lol" to each element in "[lol]" and return an "Endo [Stroke]".  any ideas for me?
14:29:03 <skorpan> uhm, that makes no sense i realize now.
14:29:24 <skorpan> so make the function f :: lol -> Stroke
14:29:26 <skorpan> now, what? :)
14:32:16 <jmcarthur> so you essentially want (lol -> Stroke) -> [lol] -> [Stroke] -> [Stroke]?
14:32:35 <legaulois_> hi
14:32:49 <jmcarthur> hi
14:33:27 <legaulois_> i cannot find an answer to a question and dunno how to get it with google because of special chars...
14:33:45 <legaulois_> what's the difference between => and -> in Type signature ?
14:33:45 <legaulois_> myF :: (a -> b -> c) -> [a] -> [b] -> [c]
14:33:45 <legaulois_> myF :: (a -> b -> c) => [a] -> [b] -> [c]
14:34:08 <jmcarthur> => means that the things on the left are type class constraints on something that's on the right
14:34:22 <jmcarthur> a -> b is a function that takes an a and returns a b
14:34:29 <jmcarthur> :t show
14:34:29 <legaulois_> ok!
14:34:30 <lambdabot> forall a. (Show a) => a -> String
14:34:44 <jmcarthur> constrains a to things which have an instance for Show
14:35:08 <jmcarthur> and the function itself takes an a and returns a String
14:35:10 <monadic_kid> jmcarthur: :t show was like you saying "Here is one i made earlier!"
14:35:20 <jmcarthur> heh
14:36:48 <legaulois_> thank you very much jmcarthur!
14:36:49 <ker2x_> and return a b ? :)
14:36:59 <monadic_kid> legaulois_: you're familiar with generic constraints? cause it's quite similar to that, they logically serve the same purpose
14:37:41 <legaulois_> no i am not really familiar with it, but anyway now I can read about the subject in google
14:37:54 <monadic_kid> C++0x Concept also will
14:37:58 <jmcarthur> yeah, "type classes" is what you want
14:37:59 <monadic_kid> *Concepts
14:38:00 <legaulois_> but google for "=>" ... you can forget about it...
14:38:10 <ker2x_> explained in learnyouhaskell.com (i'm currently reading it)
14:38:15 <legaulois_> ah
14:38:24 <jmcarthur> @where lyah
14:38:24 <lambdabot> www.learnyouahaskell.com
14:38:26 <jmcarthur> @where rwh
14:38:26 <lambdabot> is http://www.realworldhaskell.org/blog/
14:38:29 <legaulois_> I was reading real world haskell and went on it
14:38:38 <jmcarthur> ^^ seem to be the most commonly referenced tutorials right now
14:38:40 <legaulois_> in :t examples
14:38:53 <ker2x_> lyah is much more easier to understand :)
14:38:59 <monadic_kid> those are bad-ass resources
14:39:04 <legaulois_> and it wa snot introduced at this stage of my reading
14:39:49 <legaulois_> monadic_kid - why ?
14:39:55 <jmcarthur> legaulois_, yeah, there have been some reports of RWH being a little out of order. i believe they are fixing these issues for the second edition
14:40:04 <ker2x_> rwh start with a huge chapter about type and you don't even know why and make the learning curve harder than on lyah
14:40:16 <monadic_kid> legaulois_: meaning good/positive
14:40:25 <legaulois_> ah okie
14:40:57 <legaulois_> jmcarthur - often switching from the book to the commenting system answers your question
14:41:01 <legaulois_> really helpful
14:42:14 <ker2x_> programming Erlang is much more easier to read. i knew nothing about functionnal programming before, and found it very intuitive. In fact, i find it much easier than imperative langage.
14:43:35 <legaulois_> I attended Joe's presentation at Qcon London this year
14:43:41 <legaulois_> was really nice
14:43:59 <legaulois_> but some other friend advised me haskell
14:45:58 <defu1> why is this invalid in GHC? shift (x:xs) = (xs:x)
14:46:11 <vixey> deful: type error
14:46:24 <defu1> ?
14:46:39 <defu1> How so?
14:46:52 <ker2x_> the head can't be a list
14:46:57 <vixey> > 'a':"bc"
14:46:58 <lambdabot>   "abc"
14:46:58 <ker2x_> that's it ?
14:47:01 <vixey> > "bc":'a'
14:47:02 <lambdabot>   Couldn't match expected type `[[Char]]'
14:47:08 <vixey> > "bc"++['a']
14:47:09 <lambdabot>   "bca"
14:47:16 <defu1> ah.
14:47:17 <vixey> > ['a']++"bc"
14:47:18 <lambdabot>   "abc"
14:47:45 <ker2x_> heh, i was right \o/
14:47:46 <Stinger> @ty (:)
14:47:47 <lambdabot> forall a. a -> [a] -> [a]
14:49:07 <mholub> What is the default pretty printer module for haskell? http://haskell.org/ghc/docs/latest/html/libraries/base/Text-PrettyPrint-HughesPJ.html is not working.. so I suppose it was deleted from ghc?
14:49:35 <monadic_kid> @feed
14:49:36 <lambdabot> Maybe you meant: free read seen
14:49:56 <monadic_kid> how do feed it rewards?
14:50:13 <Stinger> @botsnack
14:50:14 <lambdabot> :)
14:50:14 <lunabot>  :)
14:50:21 <monadic_kid> yeah * 10
14:50:39 <Stinger> I remember the most useless crap
14:51:26 <defu1> :t (:)
14:51:28 <lambdabot> forall a. a -> [a] -> [a]
14:51:31 <defu1> :t (++)
14:51:32 <lambdabot> forall a. [a] -> [a] -> [a]
14:52:34 <mholub> Sorry.. google gave me wrong link. The right one is http://haskell.org/ghc/docs/latest/html/libraries/pretty/src/Text-PrettyPrint-HughesPJ.html
14:52:44 <ker2x_> @cookie
14:52:45 <lambdabot> Unknown command, try @list
14:52:47 <ker2x_> :(
14:53:30 <monadic_kid> @botsnack
14:53:30 <lambdabot> :)
14:53:30 <lunabot>  :)
14:53:32 <monadic_kid> @botsnack
14:53:32 <lambdabot> :)
14:53:32 <lunabot>  :)
14:54:14 <segher> stop it, we don't want fat spoiled bots
14:54:58 <ker2x_> Congratulation ! You're a whale ! (from lyah)
14:56:45 <Cale> hehe, where does it say that?
14:57:40 <ker2x_> when you learn how to write functions using | and where
14:58:26 <ker2x_> Chapter 4
14:58:36 <kniu> GAH
14:58:53 <Cale> ah, hehe :)
14:59:15 <ker2x_> oh, and it's "You're a whale, congratulations!", my bad.
14:59:20 <PetRat> what is GAH?
14:59:50 <monadic_kid> i'm trying to get where clauses in F# :P
15:00:23 <Philippa__> PetRat: like gah, only shouted
15:00:38 <PetRat> On mibbit, any reference to (:) is displayed as a smiley
15:01:06 <PetRat> g.. a.. haskell?
15:02:48 <ker2x_> Curried function is confusing
15:03:27 <orbitz> ker2x_: how so?
15:03:44 <Berengal> ker2x_: Curried functions are USEFUL! (yes, with the big letters and exclamation mark)
15:04:13 <monadic_kid> ker2x: all you need to remember is all functions really just take one argument, look at a type signature like this 'a -'a - 'a, the -> assoicates to the right so actually it's 'a -> ('a -> 'a)
15:04:27 <ker2x_> foo a b c is similar to (foo a) (foo b) (foo c) ?
15:04:46 <Berengal> ker2x_: No, foo a b c = ((foo a) b) c
15:05:30 <monadic_kid> :t curry
15:05:31 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:05:34 <Berengal> Or if you're defining foo: foo a b c = ... <=> foo = \a -> \b -> \c -> ...
15:05:35 <monadic_kid> :t uncurry
15:05:36 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:05:40 <eu-prleu-peupeu> is it possible to use haskell packages in python ?
15:08:40 <ker2x_> oooh. So every function return a function
15:09:08 <segher> everything is a function
15:09:19 <Berengal> What about functions without arguments?
15:09:28 <Berengal> I wouldn't call those functions...
15:09:42 <ker2x_> why not ?
15:09:51 <Berengal> Functions take an argument
15:10:08 <segher> that's just terminology
15:10:11 <monadic_kid> ker2x: every function takes just one argument, when you right a function with more than one argument it's really syntatic sugar for for a function with one argument return a functoin
15:10:16 <segher> call it an expression, instead
15:10:21 <Berengal> segher: Oh yes, but important terminology
15:10:25 <segher> sure
15:10:31 <monadic_kid> ker2x: and aplied for you
15:10:36 <Stinger> thats what you call a paradoxical definition
15:10:44 <Stinger> functions that aren't functions
15:10:49 <Cale> I agree. If all values are considered functions, then why even bother with the distinction. To me, a function is a value whose topmost type constructor is (->)
15:11:16 <Berengal> Cale: Indeed, just as a list is a value constructed by (:)
15:11:32 <Cale> Well, its topmost type constructor is []
15:11:33 <ker2x_> well, in C, void foo(void) take no arguments, and it's still a function
15:11:42 <Cale> :t [1,2,3] :: [] Integer
15:11:54 <Berengal> Cale: Excuse my imprecice terminology. Yes
15:12:30 <Berengal> ker2x_: In haskell there's no need for functions with no arguments because all functions return the same value for the same arguments
15:12:36 <Ferdirand> ker2x_: but haskell disallows side effects, so a function without arguments ends up being a constant
15:13:15 <monadic_kid> ker2x:you can interpret void arguments to be the unit type which is a singleton type of one value ()
15:13:20 <monadic_kid> ...
15:13:25 * ker2x_ grins
15:13:25 <Berengal> @type const 5
15:13:44 <monadic_kid> ker2x:you can interpret void arguments to be the unit type which is a singleton type of one value ()
15:14:19 <Stinger> C is impure, so it's really foo(world) :P
15:14:36 <Cale> There is actually one particular reason you might want to take a constant and turn it into a function of ()
15:14:52 <Berengal> lambdabot died?
15:14:53 <monadic_kid> lazy values
15:14:57 <Cale> It's that the results of functions are not kept.
15:15:19 <Cale> So if you want the constant to be garbage collected after it's used, turning it into the result of a function is a good way to do that.
15:15:32 <Ferdirand> interesting
15:15:35 <lambdabot> [Integer]
15:15:37 <lambdabot> forall t b. (Num t) => b -> t
15:15:42 <Berengal> wow...
15:16:00 <Stinger> that sure is some lag
15:17:30 <ker2x_> i don't understand what lambdabot said.
15:17:31 <monadic_kid> you know in the boost phoenix library where functional objects support currying, a phoneiix function of no arguments and no return is lazy value if i remember correctly
15:18:57 <monadic_kid> ker2x: don't worry it has become a live
15:19:13 <kadaver> is space and memory leaks in haskell a problem?
15:19:29 <kadaver> ie does applications crash because of bugs in ghc/RTS?
15:20:06 <ker2x_> \o/
15:20:41 <monadic_kid> whats going on with the reactive library at the moment? is complete yet? conal said around summer time
15:23:18 <defu1> > rotatel n (x:xs) = rotatel (n-1) (xs:[x])
15:23:20 <lambdabot>   <no location info>: parse error on input `='
15:23:44 <wli> rotatel n (x:xs) = rotatel (n-1) (xs ++ [x])
15:24:54 <ker2x_> trying to implement a round robin ? :)
15:25:58 <Stinger> defu1, you still can't have a list on the left side of :
15:26:40 <ker2x_> oops, nope... but, hey. it's probably really easy to implement something like rrd in haskell, isn't it ?
15:27:49 <monadic_kid> maybe you shoudl head and rest termonolgy instead
15:28:09 <monadic_kid> *maybe you should use head and rest
15:29:49 <amckinley> hey, can someone answer a n00b parsec question?
15:30:06 <dibblego> amckinley, ask to ask and all that
15:31:22 <amckinley> im parsing dhcpd config files, which look like this: http://pastebin.com/m56dd6cb0
15:32:02 <amckinley> my parser works for the case when all the option declarations precede the host declarations, but im not sure how to rewrite it so i could interleave them freely
15:38:01 <ker2x_> @type map
15:38:03 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:39:15 <amckinley> anyone? i feel like this should be really straightforward
15:42:30 <ker2x_> when i read the definition of map, can i say that : map take a function a(b) as first args, and [a] as snd arg, and return [b] ?
15:42:59 <ker2x_> (maybe it's not the right terminology, but ... ?)
15:43:41 <amckinley> maybe an easier question, does anyone have good links/papers on getting started with parsec? ive read the chapter in rwh, and daan leijen's paper
15:43:48 <mauke> "function a(b)" doesn't make sense to me
15:44:51 <ker2x_> why ?
15:45:10 <kadaver> ker2x: it is correct
15:45:15 <kadaver> @type map
15:45:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:45:18 <mauke> because it doesn't make sense
15:45:20 <monadic_kid> map takes a function from a to b, a list of a and returns a list of b, -> is a mapping from a domain of set A to the range of A
15:45:23 <ker2x_> ah, you're trolling, ok :)
15:45:23 <ker2x_> kadaver: thx :)
15:45:26 <kadaver> he means
15:45:34 <monadic_kid> *range of set B
15:45:41 <kadaver> int plus1(int a)
15:45:59 <mauke> even if you were talking about C-style syntax, it would be b(a)
15:46:04 <vav> hmm, a(b) looks like a :: b -> ? so is confusing
15:46:29 <kadaver> yeah it wasnt correct ig uess :P but i got what he meant
15:47:16 * ker2x_ scratch is head
15:47:24 <monadic_kid> if you want to worded forn of -> then you call it from something *To* something, it's a mapping, a special relation from one set to another set
15:47:43 <monadic_kid> *if you want a worded form of
15:47:54 <centrinia__> Datatypes are not sets.
15:48:12 <vav> > map (+1.0) [2..6]
15:48:14 <lambdabot>   [3.0,4.0,5.0,6.0,7.0]
15:48:16 <monadic_kid> centrinia_: you can view them as sets
15:48:28 <ker2x_> well ok ok.i was wrong, but i got the picture. thx :)
15:48:33 <vav> (+1.0) is the (a->b)
15:48:38 <centrinia__> monadic_kid, That would be too limiting.
15:49:15 <centrinia__> Also, datatypes do not have an inherent equality relation.
15:49:42 <monadic_kid> centrinia_: not at all, that is what the Curry–Howard isomorphism is about
15:49:46 <mauke> :t (==) `on` typeOf
15:49:47 <lambdabot> forall a. (Typeable a) => a -> a -> Bool
15:49:56 <mauke> hah
15:50:25 <Cale> Well, it's nicer to think of them as topological spaces or DCPO's.
15:50:37 <Cale> But both of those are just types of sets.
15:51:13 <mauke> wait, types are sets (for some types of sets)?
15:51:47 <centrinia__> Can a type correspond to a proper class?
15:52:11 <Cale> centrinia__: Usually the cardinality doesn't even go above countable.
15:52:26 <ker2x_> map :: (a -> b) -> [a] -> [b] mean, using my words : the first args is a function that take a and return b, the 2nd arg is a list [a]. and map return a list [b]
15:52:31 <ker2x_> better ?
15:52:44 <Cale> centrinia__: But if you want to generalise type theory that way, it's probably possible
15:52:56 <wli> I don't think it's even possible for anything on a computer to go beyond countable.
15:53:15 <oms_> is there any way to define a type that has undefined contents but a certain size for Storable?
15:53:21 <mauke> ker2x_: yes!
15:53:24 <Cale> In some sense it's possible, depending on how you think about it.
15:53:26 <ker2x_>  \o/
15:53:26 <wli> They're all modest sets, computable sets, et al.
15:53:51 <sjanssen> oms_: you want to only define sizeOf, but not peek and poke?
15:53:55 <Cale> Input streams needn't be computable though.
15:54:07 <monadic_kid> when I say sets, i do not necessarily mean that I am talking strictly in the domain of set-theory, there are other theories that subsume the concept of sets. A function is always special form of a relation and a relation is always aa special form of a set
15:54:19 <wli> I just don't know on that front.
15:54:34 <Cale> (but it's probably reasonable just to assume that they are, since you'll only ever be seeing a finite portion of them anyway)
15:54:34 <oms_> sjanssen: if i made a type that's just a synonym for (), but sizeOf = 64, say
15:54:35 <oms_> and peek and poke just make ()'s
15:54:50 <oms_> will alloca et al. reserve 64 bytes?
15:54:56 <sjanssen> oms_: yes
15:55:03 <sjanssen> alloca only looks at sizeOf
15:55:32 <centrinia__> So I'm not going to be able to work with every value in a proper conglomerate on my computer?
15:55:40 <oms_> sjanssen: another question that probably digs more specifically at ghc internals:
15:56:10 <oms_> is there a way to have alloca, but of type Storable a => (Ptr a -> b) -> b
15:56:24 <oms_> so that whether it actually runs is immaterial
15:56:41 <sjanssen> oms_: you could use unsafePerformIO
15:56:47 <oms_> it seems like when something is wrapped up in alloca there's no reason for it to be strict
15:56:58 <oms_> i see
15:57:11 <oms_> i considered that, but it seems tasteless
15:57:19 <oms_> but i could go down that road
15:57:20 <sjanssen> oms_: well, the inner function ought to be in IO, since ordering matters when actually using the Ptr
15:57:43 <Cale> oms_: How do you plan to write a useful function of type (Ptr a -> b) when all the primitives for working with Ptrs are in IO?
15:58:15 * monadic_kid looks at the ceiling cats
15:58:19 <oms_> actually i think what i'm looking for is something that's a Ptr to some opaque C object, the memory of which can be allocated lazily
15:58:33 <ker2x_> mauke: i should check the Erlang equivalent more often : map(Fun,List1) -> List2  :)
15:58:43 <centrinia__> Why don't we need anything larger than a conglomerate?
15:58:47 <ker2x_> it's the same thing ^^
15:59:06 <Cale> centrinia__: conglomerate?
15:59:10 <Ralith> ker2x_: not exactly.
15:59:17 <ker2x_> nope ?
15:59:17 <Cale> centrinia__: Is that a technical term?
15:59:17 <sjanssen> oms_: I think unsafeInterleaveIO should be safe here
15:59:19 <Ralith> ker2x_: strictly, haskell functions only take one argument.
15:59:21 <Ralith> ever.
15:59:42 <centrinia__> A conglomerate of all categories for example. The term was mentioned in Abstract and Concrete Categories.
15:59:43 <monadic_kid> how many times have i said that today? :P
15:59:44 <oms_> like say i have some (!!!) imported from C, with type P -> P -> P, where P is a mystery to haskell, but a pointer to something (!!!) knows what to do with
15:59:51 <Ralith> for f :: a -> b -> c, you've actually got a function which takes 'a' and returns 'b -> c', which then takes 'b' and returns 'c'
15:59:55 <mauke> map :: (a -> b) -> ([a] -> [b])
15:59:59 <oms_> sjanssen: i'll brush up on unsafety, i've never used it
16:00:09 <mauke> map takes a function from a to b and returns an upgraded function from [a] to [b]
16:00:29 <kadaver> is pointer arithmetic faster or just more idiomatic?
16:00:30 <mauke> it has now the superpower to work on entire lists at once
16:00:41 <Cale> kadaver: Than what?
16:00:42 <Ralith> ker2x_: this is why currying is natural in haskell
16:00:44 <monadic_kid> Does erlang have curried functions?
16:00:51 <ker2x_> headache++
16:00:58 <ker2x_> i'll get it... tomorrow :)
16:01:09 <mauke> beware the flip id, my son
16:01:12 <kadaver> Cale: indexing?
16:01:21 <Cale> kadaver: In C?
16:01:22 <centrinia__> :t flip id
16:01:23 <lambdabot> forall b c. b -> (b -> c) -> c
16:01:38 <Cale> kadaver: It's idiomatic in C.
16:02:03 <Cale> kadaver: Which makes it necessary/desirable at times when doing FFI.
16:02:14 <centrinia__> :t flip ($)
16:02:16 <lambdabot> forall a b. a -> (a -> b) -> b
16:02:30 <centrinia__> Wait, flip id looks a lot like flip ($)
16:02:34 <mauke> in C, indexing is pointer arithmetic
16:02:39 <mauke> centrinia__: ($) is id
16:02:58 <Cale> centrinia__: Oh, okay, it's not a widespread term. There are various formalisms which extend the notion of sets to capture certain things which can't actually be sets because there are too many of them.
16:02:58 <kadaver> sure
16:03:00 <mauke> centrinia__: ($) :: (a -> b) -> (a -> b)
16:03:07 <kadaver> but not many people are aware of that
16:03:28 <centrinia__> > tail `id` [1,2,3]
16:03:30 <lambdabot>   [2,3]
16:03:54 * centrinia__ will use `id` instead of $ from now on. :)
16:03:59 <Cale> centrinia__: Usually proper classes help -- there's a proper class of all small categories, but if you want *all* categories, things get more tricky.
16:04:13 <Ralith> mauke: ooooooh, neat!
16:04:19 <centrinia__> Cale, I think that's why they came up with conglomerates.
16:04:37 <Cale> centrinia__: Right, that would likely be the book's formalism for that.
16:04:44 <ker2x_> from lyah exemple : # ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
16:04:47 <ker2x_> # "GAYBALLS"
16:04:49 <ker2x_> ^^
16:04:53 <oms_> hahaha
16:05:09 <skorpan> ker2x_: heh, never noticed that
16:05:22 <ker2x_> it's full of stuff like that ... :)
16:05:59 <skorpan> BONUS: did you make them up yourself?
16:06:02 <mauke> ah, the fabled "YHBT Haskell Beginner's Tutorial"
16:06:21 <monadic_kid> oh yeah i forgot to link this earlier on
16:06:23 <monadic_kid> http://www.cs.nott.ac.uk/~nas/bctcs09slides.pdf
16:08:16 <Cale> centrinia__: I think the point is that in computing we're mostly only concerned with computable things, and there are only ever countably many of those (because you can index the lambda terms/Turing machines/what-have-you that construct them)
16:08:43 <Cale> centrinia__: Of course, sometimes it helps to introduce larger collections to simplify our reasoning.
16:09:16 <enolan> @users
16:09:16 <lambdabot> Maximum users seen in #haskell: 658, currently: 591 (89.8%), active: 16 (2.7%)
16:09:17 <Cale> But it's uncommon to directly have need of such large collections when modelling a computational situation.
16:13:59 <oms_>  ah ha, anyone know how to make a type with a certain size so that when an instance is simply instantiated, that much memory is allocated
16:14:25 <oms_> and once instantiated as such, how to get a reference to it to pass as a Ptr to C?
16:14:56 <mauke> that's not how it works
16:15:09 <MyCatVerbs> oms_: you really, really do not want to do that, at all. :)
16:15:10 <lambdabot> MyCatVerbs: You have 1 new message. '/msg lambdabot @messages' to read it.
16:15:25 <MyCatVerbs> oms_: instead, use Foreign.C.mallocBytes.
16:15:40 <oms_> i'd ideally make the whole affair lazy
16:16:14 <MyCatVerbs> You want a lazy thing to pass to a C function?
16:16:27 <oms_> yes
16:16:29 <oms_> undoable?
16:16:37 <MyCatVerbs> I s'pose you could unsafePerformIO (mallocBytes...)
16:17:04 <oms_> hm, but my dream is to have haskell do the allocation
16:17:09 <MyCatVerbs> But that's not really the spiffiest idea in the world, because you need to free anything that you've allocated with malloc.
16:19:04 <blackh> oms_: You should be able to do it easily with a combination of unsafeInterleaveIO and ForeignPtr.
16:19:54 <monadic_kid> centrina_: http://www.chinalex.org/~gaboardi/lavori/ML_types.pdf
16:20:19 <MyCatVerbs> Ah yes. mallocForeignPtr.            much memory is allocated
16:20:32 <MyCatVerbs> Whoops, meant to paste this URL: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-ForeignPtr.html#v%3AmallocForeignPtr
16:21:19 <oms_> ah-ha
16:21:29 <oms_> mallocForeignPtr is almost exactly what i want
16:21:31 <oms_> thanks
16:23:00 <oms_> would it be in any way safe to unsafePerformIO mallocForeignPtr?
16:23:04 <blackh> oms_: unsafeInterleaveIO with a 'data'  wrapper could be used to make it do the allocation only when your data structure is evaluated.
16:23:27 <blackh> oms_: unsafePerformIO mallocForeignPtr would be OK.
16:23:33 <oms_> yesssssssss
16:23:34 <Cale> http://imgur.com/CQoF.png -- ahaha
16:24:17 <Berengal> Cale: lol
16:25:25 <oms_> what is wrong with both people
16:25:45 <mauke> also, s/science/scientist/
16:25:46 <MyCatVerbs> Cale: victory is most delightful to observe when it is achieved with extreme economy of effort.
16:33:25 <Stinger> there was a similar one recently, EE question, where they had to work out the voltage at a point
16:33:28 <gwern> MyCatVerbs: victory is most delightful when you can sup from the skulls of your enemies
16:33:38 <gwern> that, or see their women driven lamenting before you.
16:33:59 <Stinger> but the question didn't give the reference 0V point (assuming 0V at infinity)
16:34:24 <Stinger> so the student just set the reference 0V at the point and gave that as the answer
16:34:30 <Stinger> marked right
16:35:22 <gwern> Cale: so what is the right answer? I'm guessing appealing to the proof of lower-bounds on comparison sorts is wrong?
16:35:27 <blackh> I had to write a program to calculate the day of the week in 8086 assembly language, so I called a BIOS routine to do it and I got full marks. I was astonished! This is going back a bit, obviously. :)
16:35:59 <ddarius> You don't write 8086 assembly daily?
16:36:04 <Stinger> lol actually I remember back in cs1 (java bleah)
16:36:12 <Stinger> we had to decode an int into binary
16:36:34 <Stinger> I just found a lib function, and the guy marking it just went hmmm, I spose
16:36:39 <gwern> blackh: well, any routine you write is going to be wrong at some point in history because of the countless changes of calendars; so your solution has the virtue of being good engineering by exemplifying code reuse
16:36:43 <Berengal> Decoding ints to binary makes little sense... they're already binary...
16:36:54 <Stinger> you know what I mean
16:37:03 <Berengal> boolean[] or something, right?
16:37:50 <Stinger> just printing the binary representation of an int
16:38:11 <skorpan> data Bit = One | Zero
16:38:46 <ddarius> Hmm, I wonder...
16:39:11 <ddarius> @index UArray
16:39:11 <lambdabot> Data.Array.Unboxed
16:39:14 <Cale> gwern: I'm fairly sure that for any e > 0, it's impossible to determine the median correctly in O(n^(1-e)) time, because you're not even able to examine all the elements. So by altering the elements which you didn't get to examine, the median could be changed, and thus you can't be certain you have the correct one.
16:39:14 <Berengal> take 32 . unfoldr (\a -> Just (a .&. 1, shiftR 1 a))
16:39:35 <ddarius> @hoogle [a] -> UArray a
16:39:35 <lambdabot> Did you mean: [a] -> UArray a a /count=20
16:39:36 <lambdabot> Prelude head :: [a] -> a
16:39:36 <lambdabot> Prelude last :: [a] -> a
16:39:43 <ddarius> @hoogle [a] -> UArray INt a
16:39:43 <lambdabot> Did you mean: [a] -> UArray Int a /count=20
16:39:43 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:39:43 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
16:40:39 <ddarius> @index unsafeCoerce
16:40:39 <lambdabot> bzzt
16:40:42 <gwern> Cale: but was that the answer he was looking for?
16:40:44 <ddarius> @hoogle unsafeCoerce
16:40:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:40:57 <Cale> gwern: I think so.
16:41:10 <Cale> gwern: Note that he's only talking about the partitioning step.
16:42:16 <Cale> Oh, not to mention that you can't even iterate over the entire list in O(n^(0.75)) time to separate the elements into the two bins.
16:42:36 <gwern> that would've been my answer
16:42:50 <gwern> 'sublinear is impossible as you can't order without looking at all n elements'
16:42:54 <Cale> But before you can even get that far, you can't calculate the median correctly.
16:43:04 <ddarius> Excellent.  unsafeCoerce (listArray (0,32) [3] :: UArray Int Int) :: UArray Int Bool
16:43:06 <Berengal> Besides, it should obviously be O(n^(3/4)). Decimals have no place in math.
16:43:35 <Cale> I think it should be "Let 0 < e < 1..." and "O(n^(1-e))"
16:43:42 <Berengal> ddarius: Wow. I've only done that in C...
16:44:00 <ddarius> Berengal: The most direct translation of that wouldn't work.
16:44:50 <Cale> gwern: Note that the algorithm isn't required to actually *order* the elements though.
16:45:03 <Cale> gwern: It just has to split them up.
16:45:07 <ker2x_> 'night
16:45:27 <ddarius> Stinger: There you go.
16:47:17 <jmelesky> the rest of the story, fwiw: http://imgur.com/CSqh.png
16:47:45 <centrinia__> Cale, is it possible to do the partitioning in O(n^(1-e)) time, 0 < e < 1, with multiple processing units?
16:49:11 <MyCatVerbs> Good question.
16:49:23 <Cale> centrinia__: mm... with a number of processing units proportional to the input size?
16:49:25 <ddarius> centrinia__: Prove or refute it.
16:49:30 <oms_> i'd say if you have n^1/4 processors
16:49:37 <oms_> you can do a n^3/4 sort maybe
16:49:50 <centrinia__> Cale, yes.
16:50:02 <centrinia__> Actually, you can have any number of processing units. :)
16:50:16 <MyCatVerbs> centrinia__: was going to say, you don't need to limit the number of processing units.
16:50:52 <oms_> i'd say you can do it in log n time
16:50:55 <centrinia__> Wait a minute... you can sort in O(log^2 n) time.
16:50:57 <oms_> with infinite processors
16:51:00 <oms_> beat you
16:51:07 <MyCatVerbs> The number of processing units is naturally constrained by the total latency through the system that you allow, since it takes time for all the messages to filter down to the final output component.
16:51:24 <centrinia__> MyCatVerbs, the communications latency is zero. :)
16:52:12 <MyCatVerbs> centrinia__: no, the communications latency is bounded by some constant. Your processing units still have to take time to read their inputs and write their outputs.
16:52:14 <centrinia__> Clique network with zero latency. :)
16:52:28 <centrinia__> That some constant is zero. :)
16:52:37 <wli> centrinia: Any ideas on how to reconstruct factorizations in Z[x] from factorizations in (Z/pZ)[x]?
16:53:17 <MyCatVerbs> centrinia__: what you're after here is the depth complexity of a circuit family for finding medians, no? And then the size complexity of that circuit family is bounded by 2^depth.
16:53:54 <centrinia__> MyCatVerbs, in this case, yes.
16:54:18 <centrinia__> wli, I recall reading some papers that mentioned that a while ago.
16:54:29 * wli suddenly understands how to solve systems of algebraic equations by constructing eigensystems.
16:54:48 <MyCatVerbs> centrinia__: hence your gates have propogation delay, otherwise you'd be perfectly happy just using a completely linear circuit with O(dear) depth.
16:58:32 <BMeph> wli: Wow, that's like, what - Chinese Remainder Theorem, turned inside-out! =8*o
17:02:29 <centrinia__> wli, You can do it in O(n^12 + n^9(log |f|)) :p
17:04:13 <kadaver> > (4*8)^2
17:04:14 <lambdabot>   1024
17:05:02 <kadaver> 4bytes=32bits->1024 what? combos
17:09:03 <kadaver> > 32^2
17:09:04 <lambdabot>   1024
17:09:08 <kadaver> > 2^32
17:09:10 <lambdabot>   4294967296
17:09:23 <skorpan> > 32^32
17:09:24 <lambdabot>   1461501637330902918203684832716283019655932542976
17:09:27 <skorpan> > 32^128
17:09:28 <lambdabot>   456244061762219521864117160570029132489322850724855993057919251789927516720...
17:09:43 <centrinia__> > iterate (2^) 2
17:09:45 <lambdabot>   [2,4,16,65536,2003529930406846464979072351560255750447825475569751419265016...
17:10:02 <centrinia__> > map (`mod` 100 ) `id` iterate (2^) 2
17:10:18 <lambdabot>   thread killed
17:10:53 <centrinia__> Note to self: exponentiate in Z_m and not in Z and then modulo by m. ;)
17:11:24 <skorpan> :t map (`mod` 100)
17:11:26 <lambdabot> forall a. (Integral a) => [a] -> [a]
17:11:33 <skorpan> :t map (`mod` 100) `id`
17:11:34 <lambdabot> parse error (possibly incorrect indentation)
17:11:49 <skorpan> centrinia__: was that just you replacing $ with `id`?
17:11:58 <centrinia__> skorpan, Yes. :)
17:11:59 <skorpan> because otherwise, my brain just exploded
17:12:01 <wli> cewntrinia: I can do what in O(n^12+n^9(log|f|))?
17:13:13 <SubStack> skorpan: consider an investment in hull plating
17:13:13 <centrinia__> wli, You can factor polynomials over the integers in that time.
17:13:23 <SubStack> to contain the brain explosions
17:13:34 <skorpan> SubStack: i'm not into sci-fi
17:13:41 <centrinia__> wli: http://www.math.ru.nl/~bosma/onderwijs/voorjaar07/LLL.pdf
17:13:45 <wli> centrinia: That sounds kind of slow...
17:13:51 <centrinia__> It is. :(
17:14:01 <codebliss> I'm trying to make a function to do a simplified regex-esque splitting of a list.  Ex) "This is a test." => ["This","is","a","test."].  But for lawlz, I want to do it only using simple function composition =).  I have an idea with takeWhile (/=' '), but I need to keep repeating that and put them in a new list...hm
17:14:41 <SubStack> words
17:14:43 <codebliss> Somehow I want a takewhile and then (:).
17:14:50 <codebliss> I know, I'm doing this as a challange =P
17:15:32 <SubStack> point-free style is nifty
17:15:56 <codebliss> Yeppers.  Been messing with it lately as I'm not even a couple months into function programming.  It's awesome.
17:16:02 <wli> centrinia: Looks hairy/ugly; I'd have thought there were easier methods.
17:16:15 <MyCatVerbs> codebliss: you need to do both takeWhile and dropWhile.
17:16:23 <centrinia__> wli, There should be.
17:16:33 <codebliss> Done some like.. ext = reverse . takeWhile(/='.') . reverse
17:16:49 <codebliss> MyCatVerbs: Mkay.  Nest them in each other?
17:17:03 <centrinia__> > reverse (repeat ())
17:17:12 <ddarius> :t span
17:17:15 <lambdabot>   mueval: Prelude.read: no parse
17:17:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:17:26 <MyCatVerbs> codebliss: Prelude.span breaks a list into two parts, and is what you want.
17:17:33 <ddarius> :t break
17:17:34 <wli> centrinia: Going p-adic from Berlekamp (or Cantor-Zassenhaus) is hurting me.
17:17:34 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:17:42 <MyCatVerbs> codebliss: from there, it's just a case or recursing on the didn't-satisfy list.
17:17:58 <codebliss> Thank you, I've been looking at this for a while =)
17:18:00 <centrinia__> Oh yeah, I forgot about Hensel lifting.
17:18:35 <wli> I don't see why you'd need much else if you can go p-adic.
17:20:24 <centrinia__> What can you do with p-adic numbers?
17:21:04 <wli> You can pretty much analytically estimate coefficients from there.
17:21:34 <centrinia__> Estimate?
17:23:37 <wli> You can find them by basically using the least residue mod p^n, verifying that the coefficients of the product come out right, and if they don't, move to mod p^{n+1}
17:24:13 <centrinia__> Oh.
17:24:56 <wli> Some tweaks may be needed to account for positive and negative signs.
17:25:06 <kadaver> is space and memory leaks in haskell a problem?
17:25:29 <kadaver> ie does applications crash because of bugs in ghc/RTS?
17:25:40 <wli> Maybe the least residue in absolute value.
17:25:57 <codebliss> > tail [1..]
17:25:59 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:26:03 <codebliss> That's awesome
17:26:35 <Hunner> > tail [0,-1..]
17:26:36 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-21...
17:26:43 <mmorrow> kadaver: lunabot has been running for a month
17:26:56 <codebliss> Are last and init slower than head/tail?
17:27:04 <mmorrow> if forkIO's an rts thread for every single input irc message :)
17:27:07 <codebliss> What's the speed on them?  I never knew init and last existed
17:27:08 <mmorrow> "just cuz"
17:27:21 <mmorrow> s/if/it/
17:27:27 <mmorrow> , [0..]
17:27:30 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
17:27:57 <mmorrow> it has over 60 processor hours last i checked (yesterday or so)
17:29:43 <wli> centrinia: I expected something to do with the Chinese remainder theorem.
17:30:15 <Axman6> codebliss: certinly sot slower than tail
17:30:18 <Axman6> not*
17:30:23 <mmorrow> mmorrow  11442  0.1  0.1 229488 10924 pts/2    Sl+  Mar17  72:06 ./bot +RTS -N8 -RTS
17:30:46 <ezyang> Hello all
17:30:53 <wli> e.g. maybe there's some bound on the coefficients of the factors, then when things factor use the CRT to narrow down the coefficients to within a range containing only a single residue for each coef.
17:32:20 <wli> I guess you can do that for distinct primes and guess (least residue in absolute value mod the product) and check until either some prime sees it come out irreducible or a factor shakes out.
17:33:24 <lunabot>  Killed.
17:33:34 <mmorrow> heh, a straggler
17:34:06 <kadaver> http://code.google.com/p/clojure-contrib/wiki/DatalogOverview <- pretty cool, anything like it been done in haskell?
17:34:39 <wli> I have no idea when that should terminate on irreducibles, though.
17:35:32 <wli> Or, rather, how long to keep going when guess and check keeps failing but you never see a prime for which it's irreducible.
17:36:53 <centrinia__> If a polynomial f in Z[x] factors to f=p*q, then should it factor to f=p*q in F_q[x] for any q=p^n?
17:37:08 <centrinia__> Uh, there might be some problems with my variable choice.
17:38:08 <wli> centrinia: But it's not F_{p^n} but rather Z/p^nZ for p-adic affairs.
17:39:23 <centrinia__> wli, What happens if you map from F_{p^n}  to Z/pZ and then lift to Z/p^nZ?
17:40:41 <wli> centrinia: If I could lift to Z/p^nZ I wouldn't bother with F_{p^n} in the first place.
17:41:19 <centrinia__> You can Hensel-lift from Z/pZ to Z/p^nZ
17:41:51 <wli> I have no idea how to Hensel lift factorizations in Z/pZ to factorizations in Z/p^nZ
17:44:31 <dolio> @seen dons
17:44:31 <lambdabot> dons is in #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 12h 11m 20s ago.
17:46:42 <kadaver> what would I need to control a little radiosteerable car via my computer?i would like to build an autonomous coffee-fetching robot
17:47:35 <Berengal> kadaver: Lego?
17:48:29 <kerlo> kadaver: find a cheap programmable microcontroller thing.
17:49:17 <kerlo> Yeah, a microcontroller.
17:49:56 <Axman6> get one of the propeller ones! they've got 8 cores :)
17:52:25 <kerlo> Those are kind of expensive, I imagine. :-)
17:53:03 <ezyang> I've heard good things about the Arduino boards.
17:53:30 <Axman6> yeh, me too
17:56:20 <kadaver> what doea a microcontroller cost?
17:57:28 <kerlo> Can't be too much. Likely not much than a few bucks.
17:58:52 <kerlo> "Cost has plummeted over time, with the cheapest microcontrollers being available for well under $0.25 in 2009 , and 32 bit microcontrollers under $5." http://en.wikipedia.org/wiki/Microcontroller#History
17:58:57 <kadaver> i found one for 100$
17:59:05 <kadaver> wow
17:59:07 <Axman6> ...
17:59:19 <Axman6> microcontrollers should not cost $100
17:59:48 <kerlo> Keep looking.
18:01:35 <wli> centrinia: Maybe one could factor f(x) in Z[x] by choosing a polynomial g(x) in Z[x]/(f(x)) and representing the action of multiplying by g(x) in Z[x]/(f(x)) by a linear transformation, and then hunt for the nullspace...
18:04:04 <kerlo> See if you can buy 400 microcontrollers for that prices.
18:04:07 <wli> centrinia: Or otherwise since it reduces to a direct sum, maybe some matrix decomposition finds the factors.
18:04:07 <kerlo> s/s//
18:09:04 <wli> centrinia: Frobenius normal form at least avoids extending the field.
18:09:21 <wli> centrinia: And it does decompose direct sums.
18:09:38 <gwern> huh. why did google short us 2 SoCs this year?
18:09:57 <gwern> we had 7 last year but I only see 5 on http://socghop.appspot.com/org/home/google/gsoc2009/haskell
18:15:28 <bremner> those are the two they gave to git
18:15:37 <blackh> kadaver: You could buy something like this: http://www.gumstix.com/, install Debian arm on it, then use qemu to run GHC, then copy the binaries over to it.  It'll cost ya a bit more money than the microcontroller, but you'll be able to program your robot in Haskell.
18:18:40 <wli> centrinia: I think there's an easy way to find a matrix whose characteristic equation is f(x) in Z[x] and then Frobenius normal form smokes out divisors.
18:28:25 <kadaver> so sinc e there is no #basic and all other channels no nothing(C,asm) i fall back to haskell
18:28:32 <pumpkin> lol
18:28:37 <pumpkin> you're looking for basic help? :o
18:28:47 <kadaver> does Basic have pointers?
18:28:47 <pumpkin> why would you move to basic after trying haskell???
18:28:53 <kadaver> if not then what does it have?
18:29:17 <kadaver> i cant program a microcontroller in haskell
18:29:36 <kpreid> kadaver: "basic" is a language of many variants, you can't generalize over them at all
18:29:40 <BMeph> kadaver: Give it a month, tops. The you will. ;)
18:29:49 <BMeph> *Then
18:29:50 <pumpkin> microH
18:30:35 <kadaver> BMeph: because i will write a dsl to gen basic code?
18:30:38 <SubStack> kadaver: yes you can
18:30:44 <kadaver> or someone else is doing soem project?
18:30:58 <pumpkin> kadaver: you can write BASIC in augustss' dsl
18:31:00 <pumpkin> ;)
18:31:05 <blackh> kadaver: You can program a microcontroller in Haskell. It just has to be ARM based and have enough memory to run Linux.
18:31:10 <pumpkin> lol
18:31:26 <pumpkin> we almost have the iphone running linux
18:31:46 <Axman6> blackh: heh
18:31:52 <Axman6> bah
18:31:54 <SubStack> see flask (http://www.eecs.harvard.edu/~mainland/flask/)
18:31:57 <Axman6> what va terrible idea pumpkin
18:32:18 <Berengal> I wonder if the day comes when my shoes have 8GB memory @ 4 GHz...
18:32:40 <blackh> Axman6: Bare minimum would be 64MB of RAM and maybe 256MB flash.
18:32:57 <pumpkin> the iphone has that and more :D
18:33:11 <Axman6> yeah... haskell's not relly suited to embedded stuff. at least not ghc haskell
18:33:11 <Berengal> What about some older linux?
18:33:22 <Berengal> The first linux version was written for the 386 after all...
18:33:58 <Berengal> Seems like it should be possible to push the requirements far below 64MB
18:34:31 <blackh> Berengal: Yes, you could do it with 32MB. The thing you have to remember is that there is no swap, so ... you run out of memory ... you die.
18:34:55 <mofmog> is it just me or did haskell-mode break after i installed the latest ghc
18:35:05 <wli> ugh, it doesn't work (or at least the implication is not there)
18:35:20 <mofmog> i can load stuff into ghci from terminal, but if i open an the interpreter in emacs it cries
18:36:06 <blackh> Axman6: There is no reason why you can't use GHC for an embedded system in the way I described.
18:37:12 <Berengal> mofmog: It worked just fine for me
18:37:37 <mofmog> hrm hrm, time to redo haskell-mode
18:37:59 <mofmog> for some reason ^J keeps appearing i the buffer
18:38:08 <mofmog> and other what i guess are erroneous escapes
18:38:40 <Berengal> mofmog: there's a fix for that
18:38:59 <bremner> ask lambdabot about emacs^J
18:39:11 <Berengal> echo "cat | ghci" >ghci-no-tty
18:39:21 <Berengal> chmod +x ghci-no-tty
18:39:31 <mofmog> ah, so it's a known problem
18:39:33 <Berengal> Actually, mv ghci-no-tty ghci-no-tty.sh
18:40:01 <mofmog> actually, for some reason if i have a file that calls a user defined module it ghci in emacs likes to pretend it doesnt exist
18:40:05 <Berengal> then in ~/.emacs: (setq haskell-program-name "~/ghci-no-tty.sh")
18:41:23 <mofmog> where do i put the elisp
18:41:27 <mofmog> after the hooks?
18:41:50 <bremner> @fact emacs^J
18:42:16 <lambdabot> I know nothing about emacs^j
18:42:56 <bremner> @fact emacs
18:42:56 <lambdabot> I know nothing about emacs
18:43:16 <Berengal> mofmog: Actually, mine looks like (custom-set-variables '(haksell-program-name "...")...)
18:43:40 <mofmog> the problem looks fixed regardless
18:44:00 <mofmog> except for the "refuses to load user imported modules that are user defined" thing
18:44:17 <Berengal> How exactly does it fail?
18:44:21 <bremner> this works for me (add-hook 'haskell-mode-hook '(lambda () (setq process-connection-type nil)))
18:44:29 <bremner> ^mofog
18:44:37 <bremner> ^mofmog
18:44:51 <mofmog> i have two files, InstructionSet.hs and Core.hs
18:44:58 <mofmog> Core.hs imports InstructionSet
18:45:06 <mofmog> if i load Core in ghci from terminal it loads fine
18:45:12 <kadaver> Damn Small Linux
18:45:23 <mofmog> if i C-c C-l it into ghci in emacs, it can't find the module
18:45:50 <kadaver> isnt ghc soemthing like 400MB?
18:45:53 <Berengal> mofmog: Check your inferior haskell: does it say something like ":cd ~/.cabal"?
18:46:02 <mofmog> yes
18:46:03 <mofmog> it does
18:46:11 <mofmog> oh god, cabal broke haskell-mode?
18:46:15 <kadaver> or i should make a water robot :P
18:46:16 <Berengal> There's a fix for that. Unfortunately, I haven't had use for it...
18:46:28 <Berengal> It's supposedly fixed in the last haskell-mode
18:46:34 <mofmog> yeah, ill dl it then
18:46:43 <Berengal> Or HEAD, or whatever...
18:46:58 <Berengal> (I think it was a simple .emacs addition as well...)
18:47:10 <mofmog> wait, but haskell mode hasnt been updated in forever
18:47:23 <Berengal> mofmog: That's just what someone said the other day
18:48:21 <blackh> kadaver: I'm saying you run ghc on qemu on your PC.
18:48:29 <mofmog> hm, i have 2.4 installed that's funny
18:48:59 <blackh> kadaver: Then you copy the binaries over - it'd be libc and a few others. Call your program '/sbin/init' and Linux will run it.
18:49:16 <blackh> kadaver: I mean Linux as in "the Linux kernel"
18:49:21 <Berengal> mofmog: Could be "it WILL be fixed"...
18:49:51 <mofmog> ugh
18:50:06 <mofmog> they just gotta save the current directory, look at the cabal directory, then move back
18:50:15 <mofmog> too bad im too terrible at elisp to fix it
18:50:19 <mofmog> perhaps i should switch to yi
18:50:40 <mofmog> elisp was a terribly thought out language.
18:50:47 <ddarius> elisp was thought out?
18:50:58 <Berengal> elisp grew up among wild wolves...
18:51:12 <Berengal> For several years it lived like one of them
18:51:19 <Berengal> Until one day an old man found it
18:51:23 <mofmog> dynamic scoping
18:51:31 <mofmog> so that you get headaches while having a headache
18:51:38 <Berengal> He brought it home, nursed it, and taught it emacs
18:51:47 <Berengal> Unfortunately, it's wildness couldn't be fully contained
18:52:15 <mofmog> richard stallman would be the last person who should nurse anything
18:52:20 * mofmog said it
18:52:31 <Berengal> That fact didn't do much to help elisp...
18:54:26 <Berengal> mofmog: A quick fix it to "touch .cabal" in the root directory of your project
18:54:44 <Berengal> or something like that...
18:55:17 <mofmog> im going to try out yi, how complete is it?
18:57:49 <blackh> mofmog: It works. I like Leksah a lot better, though.
18:59:30 <mofmog> what's your opinion of emacs?
19:00:30 * Cale uses vim
19:00:37 <Cale> But emacs can be nice too
19:00:53 <blackh> mofmog: I am an emacs avoider and liker of GUIs, so I don't know whether I like emacs.
19:01:10 <Cale> Emacs has a sort of GUI mode.
19:01:59 <blackh> My philosophy is this: Some software wants to help you get the job done, and some software wants to start a relationship. I only like the first kind.
19:02:20 <Cale> Like how?
19:03:18 <blackh> Correct me if I'm wrong, but emacs is the sort of software that exists so people can tinker.  Not my kind of software.
19:03:43 <Berengal> I've found emacs to be one of the better editors out there
19:03:57 <Berengal> I used to use kate... It was decent enough, but not very well suited to haskell
19:04:07 <mofmog> emacs is just... more powerful
19:04:09 <Berengal> Yi... I've found to lack documentation
19:04:16 <mofmog> well Yi is new
19:04:32 <blackh> I haven't found my perfect editor for Haskell yet - Leksah is very close, though.
19:04:40 <Berengal> When I first installed emacs out of curiosity I ran through the tutorial once and found I could use it just fine afterwards
19:05:22 <blackh> Leksah has ** source candy ** Oooooh!
19:05:47 <Berengal> Leksah is nice, but it's more of an IDE than an editor... emacs blurrs that line pretty well, but if you want it'll step out of the way and just let you put characters in a file for you
19:06:23 <Berengal> Leksah's source candy is actually one of the most alluring things about it in my opinion...
19:06:30 <Berengal> I'm a sucker for bling...
19:06:45 <blackh> The thing I like about Leksah is that if you've already got a .cabal file, then.. there's your project. It'll be better when all the bugs are out, but quite useable.  And it lets you jump straight to lines with errors on - that's the killer feature for me.
19:07:06 <Berengal> (Of course, emacs has candy too, but at the moment all I get is boxes)
19:08:02 <Berengal> ls
19:08:05 <Berengal> oops
19:09:38 <bremner> . .. README
19:12:56 <Berengal> cat README
19:13:17 <SubStack> happy purring cats
19:15:19 <Axman6> THERE CATS COME WITH NO WARRANTY, IMPLIED OR OTHERWISE, TO THE FULL EXTENT ALLOWED BY ALL APPLICABLE LAWS
19:15:26 <Axman6> THESE*
19:15:40 <Axman6> never seen a readme with a type correction like that
19:18:09 <SubStack> hepcats!
19:18:16 * SubStack named a haskell project that
19:19:08 <chromakode> hey all, what do you use for good line editing for terminal input? would you recommend System.Console.Readline?
19:19:53 * SubStack recommends against whatever ghci uses
19:19:55 <SubStack> pesky thing
19:20:06 <chromakode> what does ghci use?
19:20:54 <SubStack> in 6.10 it changed to be not readline I think
19:21:19 <SubStack> editline is the new thing
19:22:02 <SubStack> there seems to be some sort of haskelline project, I'd check that out at least
19:22:15 <chromakode> thanks :)
19:23:10 <dolio> editline has some issues.
19:23:15 <jedai> haskeline is a "pure Haskell" solution, it's what I would try first
19:23:18 <dolio> Unicode being one, I think.
19:23:34 <dolio> Same with haskelline, I thought.
19:24:07 <kerlo> I wonder what the most amazing 80-character Haskell program is.
19:24:15 <dolio> The only thing that was really wrong with readline was licensing issues, I think.
19:24:39 <chromakode> dolio: readline has licensing issues?
19:24:44 * SubStack is still blown away by the foldM that does the powerset, despite knowing sort of how it works
19:24:49 <dolio> It's GPL.
19:24:54 <SubStack> er, filterM
19:24:57 <chromakode> that's what I thought
19:25:39 <SubStack> > filterM (const [True,False]) "abc"
19:25:40 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
19:25:58 <chromakode> whoa.
19:26:20 <Cale> hmm, it would be nice to have a readlinish library which managed an IRC-like display, with the edit line always at the bottom, and asynchronously displayed messages scrolling above it.
19:26:36 <chromakode> Cale: agreed! you could make something like that with hsCurses
19:26:39 <Cale> yeah
19:26:50 <SubStack> nifty idea
19:27:09 * SubStack also wants vi mode
19:27:35 <SubStack> those shortcuts are addictive
19:49:24 <mmorrow> dolio: so instead of using the money they must be making on their closed-source apps to hire someone for a few hours to make a custom editline version of ghci, they impose editline on us all :)
19:49:33 * mmorrow is bitter about editline..
19:49:56 <dolio> Huh?
19:49:57 <pumpkin> who?
19:50:06 <mmorrow> <dolio> The only thing that was really wrong with readline was licensing issues, I think.
19:50:08 <mmorrow> :)
19:50:20 <mmorrow> i'm just trying to sneak a shot in where i can ;)
19:50:30 <pumpkin> who's the they in that though
19:50:31 <dolio> Yeah, GHC is BSD/MIT-ish.
19:50:31 <pumpkin> ?
19:50:42 <mmorrow> pumpkin: "\"they\""
19:51:06 <dolio> Hey, either of you still use 6.8?
19:51:13 <dolio> And know some ghc-core?
19:51:14 <pumpkin> not me
19:51:20 <Zao> Yes, no.
19:51:22 <pumpkin> I have a machine with 6.8 on it though
19:51:29 <mmorrow> dolio: i'm fairly sure that the only reason editline was swapped in was because certain (i don't know who) people wanted to use ghci verbatim in their closed apps
19:52:15 <mmorrow> iirc they're considering re-adding in a compile-option for readline i think
19:52:25 <dolio> pumpkin: Can you take a look at this: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=3996
19:52:48 <dolio> I don't remember it being an issue in 6.8, so it might be a regression.
19:52:51 <pumpkin> any particular compile flags?
19:53:04 <Berengal> Aren't readline and editline binary compatible?
19:53:12 <dolio> -O2. Whatever ghc-core uses.
19:53:15 <Berengal> Or was that some lie told to me by a stranger...
19:53:46 <dolio> Seems unlikely.
19:53:51 <c_wraith> I wish editline supported a lot more of readline's functionality.  Crazy things like the delete button.  Or ctrl-R
19:54:11 <pumpkin> hmm, ghc-core won't install on that machine, says "    Module `System.Process' does not export `readProcess'"
19:54:12 <Zao> Delete? Are you crazy.
19:54:15 <pumpkin> is that a simple fix?
19:54:55 <dolio> Try an older version, maybe?
19:55:20 <pumpkin> ok :)
19:55:50 <mmorrow> dolio: maybe banging  child2 = child1 + , child3 = child1 + 2 in the where might do something (?)
19:55:57 <GoldyOrNugget> how can i make an integer a string and back again?
19:56:13 <thoughtpolice> wee!
19:56:16 <Axman6> read and show
19:56:22 <thoughtpolice> isabelle2009 has a native mac os x installer
19:56:26 <Axman6> > read . show $ 1
19:56:27 <lambdabot>   * Exception: Prelude.read: no parse
19:56:33 <Axman6> > read . show $ 1 :: Integer
19:56:34 <lambdabot>   1
19:56:42 <pumpkin> hmm, I have core
19:56:49 <dolio> mmorrow: I'll try it, but there are already bangs on the fields in the pair.
19:57:28 <mmorrow> dolio: that's the only thing i can figure, since i think the (+) is the only _non_strict thing in there.
19:57:32 <pumpkin> dolio: looks like they both unbox :o
19:57:40 <pumpkin> dolio: unless I'm looking at the wrong spot
19:57:49 <GoldyOrNugget> > take 3 (show 12345678)
19:57:51 <lambdabot>   "123"
19:57:54 <GoldyOrNugget> ah cool
19:57:56 <GoldyOrNugget> thanks
19:58:54 <dolio> pumpkin: The way I usually find it is look for the code that does "root * 3 + 1", follow that to the code for maximumChild, look for the (child1 + 1) code, and find the part that returns/calls-the-continuation for that.
19:58:57 <pumpkin> dolio: the chunk: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4002#a4002
19:59:28 <pumpkin> I'll look
19:59:46 <pumpkin> but that looks awfully like your piece of code
19:59:57 <pumpkin> plus an extra unboxed Int
20:00:03 <dolio> Yeah, that looks promising. Although the arguments appear to be in the opposite order.
20:00:32 <cooldude127> hey guys i just installed the binary of ghc 6.10 on ubuntu, and i'm trying to cabal install hmatrix, which fails being unable to find the GSL library, even tho it's installed and worked with 6.8 installed via apt-get
20:00:56 <cooldude127> i tried putting /usr/include and /usr/lib in the appropriate --with-extra-* options
20:01:25 <cooldude127> or that is --extra-include-dirs and --extra-lib-dirs
20:03:06 <pumpkin> dolio: more of it at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4002#a4003
20:03:56 <dolio> Hmm... It's writing to an index +40?
20:04:07 <pumpkin> maybe I'm looking in the wrong place :P
20:05:26 <dolio> Oh, yes, that's right, apparently.
20:05:51 <Cale> cooldude127: hmm... I'll give it a shot
20:06:15 <cooldude127> Cale: you're using the binary or source? as long as it's not the one from apt-get
20:06:27 <pumpkin> dolio: here's the whole thing, if it helps http://pumpkinpat.ch/moo.html
20:06:38 <dolio> pumpkin: 6.8 is doing a better job optimizing the comparison with case, as well.
20:06:43 <Cale> I'm using the binary ghc, but 6.10.1 still
20:07:02 <Cale> I actually already have hmatrix installed.
20:07:02 <cooldude127> Cale: i doubt that will make a difference
20:07:04 <cooldude127> lol
20:07:06 <pumpkin> doesn't GHC's testsuite test unboxing?
20:07:14 <Cale> But maybe it's a problem with the newer version.
20:07:28 <dolio> pumpkin: In 6.10.2, the False branch of that code has a redundant test for equality, with the same code in both branches.
20:07:46 <dolio> But I'm pretty sure I already saw a bug for that.
20:08:56 <cooldude127> Cale: you think i should just uninstall and do 6.10.1 instead?
20:09:05 <pumpkin> how'd you notice this? wanted to make sure your uvector code was as tight as possible and just saw an unnecessary boxing, or was there a noticeable performance problem?
20:09:34 <Cale> cooldude127: Well, if it succeeds, I'll upgrade to 6.10.2 (I've been meaning to, have it downloaded here), and see if I can get the problem to happen.
20:09:35 <dolio> pumpkin: Yes, I look at the generated core for my sorts and look for boxes.
20:09:55 <cooldude127> Cale: i'll give it a shot. i just installed it, not attached
20:09:57 <dolio> pumpkin: Also, I noticed that my heapsort was doing much more allocation than I remembered it doing.
20:10:10 <pumpkin> that sucks, I wonder what changed
20:10:11 <Cale> okay, hmatrix-0.5.1.1 installed okay for me
20:10:42 <dolio> In my benchmark, 6.10.2 does 14 gigabytes of allocation. If I use a special type to get that thing unboxed, it drops to 3 gigabytes.
20:11:21 <dolio> Which is good for maybe 25% on random arrays.
20:11:25 <Cale> cooldude127: what is the error message that you're getting?
20:11:29 <dolio> 25% time, that is.
20:12:06 <pumpkin> wow
20:12:52 <cooldude127> Cale: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2168#a2168
20:13:16 <cooldude127> Cale: after install ghc6.10.2?
20:13:27 <Cale> No, still haven't done that yet
20:13:29 <dolio> pumpkin: That loop happens a lot during heapsort. :)
20:13:30 <cooldude127> k
20:14:11 <pumpkin> dolio: what part of GHC deals with that? is it the *drumroll* StrictAnal one?
20:14:26 <dolio> I don't really know.
20:14:36 <dolio> That seems likely.
20:14:47 <Cale> cooldude127: Okay, and you have libgsl0-dev ?
20:15:02 <cooldude127> correct, i have it from when i installed hmatrix for 6.8
20:15:06 <Cale> okay
20:15:14 <cooldude127> which works perfectly
20:15:21 <cooldude127> but i want to do some stuff using ghc6.10
20:15:24 <pumpkin> how does one ask darcs for the difference between two major releases in a single file?
20:15:30 * Cale unpacks 6.10.2
20:15:31 <pumpkin> I have a checked-out copy of GHC head
20:15:40 <amckinley> hey, easy parsec question: i have this code as part of a parser im writing for dhcpd config files: http://pastebin.com/m48c5ea1c
20:16:15 <dolio> I assume the reason it isn't unboxing is because it's only used in one branch, which could possibly mean that it wouldn't be evaluated in that branch, except that the data type that the original code has strictness annotations.
20:16:33 <amckinley> how do i add something that occurs after the appropriate parser's been chosen? in this case, a semi-colon appears after each parameter
20:17:01 <dolio> Another possibility is that it eliminates the pair before doing strictness analysis, and then doesn't retain the fact that it's supposed to be strict.
20:17:18 <cooldude127> Cale: yeah ghc 6.10.1 fails too, maybe i need to reinstall cabal-install?
20:17:31 <Cale> cooldude127: Might be an idea :)
20:17:38 <cooldude127> god dangit
20:17:51 <Cale> cooldude127: It's easy to do if you already have cabal-install
20:17:57 <Cale> (or should be)
20:18:00 <cooldude127> we'll see
20:19:22 <cooldude127> nope, it installed itself, but hmatrix install still fails
20:19:42 * BMeph wonders if "Andrew Lincoln" tells the first-initial-last-name IT guys that his first name is "really" Drew...
20:20:10 <Cale> amckinley: I'll take a look... my connection's being really slow due to my router being unhappy about my torrent though :)
20:20:16 <mmorrow> dolio: i can't figure it out
20:20:39 <dolio> Figure what out?
20:20:43 <amckinley> Cale: thanks a bunch; this should be really simple. im new enough to haskell that im pretty sure im just messing up the syntax :)
20:20:44 <Cale> amckinley: Should just involve putting a semicolon parser after it in the do-block, I would think :)
20:20:48 <pumpkin> the StrictAnal isn't strict enough
20:20:49 <mmorrow> dolio: why it's not unboxing
20:20:59 <mmorrow> pumpkin: clearly not
20:21:08 <dolio> A bug, I imagine.
20:21:15 <mmorrow> dolio: maybe it has something to do with how many times it
20:21:16 <cooldude127> Cale: i have progress. i linked ~/bin/cabal to the newly installed ~/.cabal/bin/cabal, and now i get a different error
20:21:22 <mmorrow> 's used?
20:21:31 <Cale> cooldude127: okay...
20:21:38 <mmorrow> iirc, there's something with inlining and being used once
20:21:40 <amckinley> Cale: the obvious thing (just changed the paste to show it) doesnt work
20:21:48 <mmorrow> (although that probably has no relevance here..)
20:21:49 <dolio> Actually, no strictness annotation I tried worked on it.
20:21:56 <cooldude127> Cale: it can't find lapack, but i think that package might have gotten messed with in an upgrade, let me make sure
20:21:59 <mmorrow> me neither
20:22:19 <pumpkin> how about head?
20:22:49 <dolio> I even tried putting "child' `seq` cmp val ac" in the case statement, and that didn't clue it in.
20:22:58 <cooldude127> installing lapack-dev
20:23:02 <mmorrow> heh, i started doing that stuff too..
20:23:47 <cooldude127> Cale: it's building now
20:23:59 <Cale> amckinley: yeah, that won't work, because it's not inside any do-block
20:24:59 <amckinley> Cale: yup. whats the thing to do, nest all my do blocks inside a bigger, outer do-block? write a helper function? just put the "semi" line after each choice in the existing set of do-blocks?
20:25:27 <dolio> I'll write up a bug report some time soon, I guess.
20:25:33 <Cale> amckinley: I'm just pasting something now. I turned your parameter into parameter' and wrote  parameter = do p <- parameter'; semi; return p
20:25:45 <Cale> http://pastebin.com/m5888e978
20:26:29 <mmorrow> dolio: heh
20:26:46 <dolio> I'm not going to compile head to test this.
20:26:48 <Cale> Seriously? ghci 6.10.2 segfaults when I hit Ctrl-C to quit
20:27:53 <amckinley> Cale: that works for me, as long as thats more-or-less canonical. thanks for your help :)
20:28:05 <Cale> amckinley: no problem :)
20:28:50 <cooldude127> so if i want gtk2hs i need to install it from source? it's not on hackage?
20:29:29 <Cale> cooldude127: Yeah. To be fair, it's been around a good deal longer than hackage and already had quite a complex custom build system.
20:29:40 <cooldude127> makes sense
20:32:26 <orbitz> too many package managers otu there!
20:33:30 <Cale> okay, hmatrix installs fine for me
20:33:54 <Cale> I'm not sure which system packages it requires though...
20:36:12 <cooldude127> Cale: it's gsl and lapack
20:36:14 <Cale> (On a fresh 6.10.2 with a fresh cabal-install this is now)
20:36:21 <Cale> Did it work out for you?
20:36:32 <Cale> oh, right, you did say that :)
20:36:35 <cooldude127> lol
20:36:53 * cooldude127 builds gtk2hs
20:40:50 <Berengal> Hmm... If I have several threads communicating through TChans, would it be possible to capture that in a monad?
20:41:48 <Berengal> Or maybe State would be good enough...
20:42:34 <Cale> Berengal: You must use the STM monad, and IO.
20:42:56 <Cale> Berengal: Or monads constructed from those.
20:43:12 <Cale> Or do you just want to simulate that?
20:43:39 <Berengal> No, I was being somewhat unclear. It would have to exist on top of those.
20:43:43 <pumpkin> does the STM stuff have any special support (or tie-ins) with GHC?
20:43:54 <Cale> pumpkin: ?
20:44:00 <Cale> pumpkin: It's only supported by GHC.
20:44:25 <pumpkin> but does GHC have special support for STM, or is it just that GHC exposed more primitives that made STM possible?
20:44:41 <Cale> It has special support in the RTS.
20:44:48 <pumpkin> ah
20:46:04 <Cale> Though it would be interesting to see STM implemented at a high level in terms of MVars, etc. It probably would have even worse performance :)
20:52:35 <pumpkin> Cale: omg STM is slow? neva!
20:55:58 <Cale> pumpkin: Well... it's acceptably fast, but not as fast as the simpler mechanisms which provide fewer guarantees and composability.
20:56:16 <Cale> and less composability*
20:56:42 <Cale> In the case that you actually need transactions, it's probably quite acceptable :)
20:57:00 <pumpkin> I really like the idea, but haven't had a need for it yet
20:57:19 <Berengal> You know, I was wondering about the speed of STMs...
20:57:36 <Berengal> Some weeks ago I wrote some pretty basic program just to check out concerrency...
20:57:37 <Berengal> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4005#a4005
20:57:52 <pumpkin> whoa, look at that unicode
20:57:55 <Berengal> It turned out the speed of the program increased linearly with the number of cores applied
20:58:02 <pumpkin> ghc accepts the arrows?
20:58:26 <Berengal> pumpkin: I just copy-pasted that from leksah. It translates it back to regular text
20:58:31 <pumpkin> ah
20:58:37 <pumpkin> cause I've heard GHC will accept the lambdas
20:58:38 <Berengal> (I remembered this when I just fired up leksah again)
20:58:40 <pumpkin> but not sure what else
20:58:55 * sjanssen would hate that feature
20:59:01 <pumpkin> isn't doTimes just replicateM?
20:59:09 <Berengal> Probably
20:59:18 <sjanssen> replicateM_
20:59:21 <Berengal> I was just goofing around in a tired and non-thinking state
20:59:27 <pumpkin> or rather replicateM_
20:59:31 <pumpkin> :)
20:59:39 <pumpkin> oh look, sjanssen beat me to it :(
20:59:55 <Berengal> I was too dazzled by the unicode :P
20:59:58 <hotaru2k3> that one "->" in there looks strange to me
21:00:06 <pumpkin> yeah
21:00:29 <Berengal> Indeed... but anyway, any reason this should slow down linearly with the number of cores applied?
21:00:55 <Berengal> -N1 ~ 15 sec, -N2 ~ 30 sec, -N4 ~ 55 sec...
21:01:05 <QtPlaty[HireMe]> Berengal: Overhead?
21:01:13 <SubStack> > (Î» x â†’ 2 * x + 1) 4
21:01:14 <Gracenotes> :(~
21:01:14 <lambdabot>   <no location info>: parse error on input `â†’'
21:01:26 <Berengal> QtPlaty[HireMe]: Obviously, but why that much?
21:02:37 <pumpkin> , (Î» x â†’ 2 * x + 1) 4
21:02:38 <lunabot>  luna: Pattern syntax in expression context: Û x -> 2 * x + 1
21:03:03 <Berengal> Luna seems to accept ->...
21:03:12 <pumpkin> , (Î» x -> 2 * x + 1) 4
21:03:13 <lunabot>  luna: Pattern syntax in expression context: Û x -> 2 * x + 1
21:03:19 <Berengal> > (Î» x -> 2 * x + 1) 4
21:03:20 <lambdabot>   <no location info>: parse error on input `->'
21:03:30 <sjanssen> Berengal: as far as I can tell, your program should only ever use two cores
21:03:40 <Berengal> , (\ x â†’ 2 * x + 1) 4
21:03:41 <lunabot>  9
21:04:10 <Berengal> sjanssen: Well, yes, but even just using two cores spent twice the time using one core did
21:04:14 <sjanssen> Berengal: and the garbage collector is probably behind the slowdown
21:04:56 <Berengal> sjanssen: Yes, it was spending quite alot of time in GC...
21:05:07 <Berengal> But that was true of using a single core as well
21:05:24 <Berengal> Is the syncronization when using several cores that bad?
21:05:54 <sjanssen> generally not, if they're not communicating
21:06:04 <sjanssen> Berengal: I'm rather skeptical of your results
21:07:11 <Berengal> I'll see if I can replicate them...
21:07:13 <sjanssen> that there is any difference between N2 and N3 is especially odd
21:08:19 <sjanssen> Berengal: you're on a dual core box, right?
21:08:32 <Berengal> sjanssen: quad
21:08:39 <jedai> Berengal: You compiled with -threaded ?
21:08:54 <Berengal> jedai: Yes. Without it there was no difference
21:09:59 <Berengal> Pooey... Not enough memory to calculate the big numbers I used before. I need to kill something
21:10:28 <sjanssen> ooh, running out of memory, eh?
21:10:43 <sjanssen> Berengal: is it possible you were hitting swap before?
21:10:45 <dolio> pumpkin: What version of 6.8 were you using? .3?
21:10:58 <pumpkin> .2
21:11:02 <pumpkin> the one ubuntu gave me
21:11:02 <dolio> Okay.
21:11:23 <Berengal> sjanssen: No. I was getting close, but not hitting it.
21:11:53 <Berengal> The program used about 3GB of memory... then I had just restarted, but this time I was already using about 2/4
21:13:02 <Berengal> Hah, running it now pushed most of the used memory into swap...
21:13:27 <bryan1> How can I convert an Int -> ByteString.
21:14:08 <pumpkin> what kind of conversion?
21:14:35 <ezyang> Question: what are the benefits of having hpc mark "otherwise" guards as "always true"?
21:14:37 <pumpkin> you want the 2's complement binary representation of the Int?
21:14:51 <pumpkin> @src otherwise
21:14:52 <lambdabot> otherwise = True
21:14:56 <bryan1> pumpkin: yes
21:15:04 <pumpkin> bryan1: look at Data.Binary.Put
21:15:13 <bryan1> pumpkin: thanks.
21:15:22 <pumpkin> or just Data.Binary :)
21:15:44 <sjanssen> bryan1: Data.Binary will be a bit expensive if you're only converting one Int at a time
21:15:50 <ezyang> pumpkin: Right. It seems to me, then, that if I'm looking for guards where I should be testing both the true and false condition, having otherwise thrown in there could result in false positives.
21:16:15 <roconnor> (1295+1973)/2
21:16:19 <roconnor> > (1295+1973)/2
21:16:20 <lambdabot>   1634.0
21:16:59 <ezyang> Is this just not a good way of using hpc's output?
21:18:03 <bryan1> sjanssen: what do u suggest I use if I'm only encoding one Int at a time.
21:18:58 <Berengal> I'm unable to replicate the issue I had before... using two cores is actually almost twice as fast...
21:19:09 <sjanssen> bryan1: there isn't really anything else convenient
21:19:19 <Berengal> I was pushing for more fibs the last time though, which required me to increase the stack space...
21:20:11 <mle> anyone around from the icfp2009 contest group?  As discussed on the 2008 list... dns is still screwed up
21:24:25 <Nafai> The new Hack library looks interesting
21:24:28 <Nafai> Wish there were docs
21:25:28 <Cale> ezyang: Well, 'otherwise' isn't actually built-in syntax. It's just a value defined to be True
21:25:57 <Cale> ezyang: I would suspect you always want the last guard in a collection to be always true.
21:26:13 <ezyang> Cale: Not necessarily, esp. if I have more patterns afterwards.
21:26:24 <Cale> ezyang: That's why I said the last one.
21:26:29 <Cale> oh
21:26:33 <Cale> I see what you mean.
21:27:00 <ezyang> But I can understand hpc not wanting to gunk up their code with a special case :-/
21:27:08 <Cale> Well, any guard whose failure would necessarily mean the failure of the function then :)
21:27:43 <Cale> I would see it as simply being accurate. It really did succeed every time, and that's what you wanted.
21:29:13 <Cale> But it would be cool if it could separate the cases where it's really impossible for the guard to fail.
21:29:28 <ezyang> Agreed.
21:30:44 <Cale> I suppose if they bother you, you could also adopt a funny style of just replacing a final otherwise case with another pattern match.
21:31:00 <ezyang> Yeah. That kind of defeats the purpose of otherwise though :-)
21:31:04 <Cale> yeah :)
21:35:09 <pumpkin> thoughtpolice: nice post :P
21:35:22 <pumpkin> I wonder how many of my followers actually care
21:37:45 <thoughtpolice> pumpkin: ty :)
21:37:50 <thoughtpolice> pumpkin: really neato little tool
21:37:57 <pumpkin> yeah, it looked cool
21:37:58 <thoughtpolice> also Isabelle2009 actually works on mac os x now
21:38:02 <pumpkin> oh, nice
21:38:12 <thoughtpolice> and it installs as a .dmg with AquaEmacs+ProofGeneral included
21:38:33 <pumpkin> AquaEmacs ftl :P
21:38:34 <thoughtpolice> pumpkin: I thought the SML translation bit was a tad awesome :)
21:38:59 <andresj> @src enumFromTo
21:38:59 <lambdabot> Source not found. My pet ferret can type better than you!
21:42:10 <cooldude127> i'm trying to use cabal for my haskell project. i have hmatrix installed in my home directory, and i added hmatrix to build-depends in my .cabal file, but runhaskell Setup.lhs configure fails saying it can't find hmatrix
21:42:40 <sjanssen> cooldude127: you need to configure with --user
21:42:46 <cooldude127> oh ok
21:42:51 * quicksil1er mutters about the fact he can't be bothered arguing with deluded misinformed people on haskell-cafe.
21:43:01 <quicksil1er> what a completely absurd email.
21:43:01 <cooldude127> yup that works
21:43:11 <sjanssen> quicksil1er: oh?
21:43:12 <dolio> Which one?
21:43:14 <blackh> quicksil1er: Past the link for us
21:43:27 * sjanssen has fallen behind on Haskell lists lately
21:43:30 <dolio> Is this in the UHC thread?
21:43:39 <dolio> That seems like a likely source of nuttery.
21:43:43 <pumpkin> it is
21:44:00 <thoughtpolice> pumpkin: also in my workings to install linux-2.6.30 on my ps3 (it's now officially my main dev box.) i was looking at stuff like valgrind, and jesus it seems like an awesome tool
21:44:08 <thoughtpolice> er, well, dev box for linux
21:44:11 <pumpkin> wow, ps3 as main dev box
21:44:13 <ddarius> sjanssen: I've pretty much stopped reading them.  4548 unread emails.
21:44:19 <thoughtpolice> luckily apt has huge repos, with lots of ppc stuff
21:44:31 <pumpkin> I guess my tv would make a good monitor
21:44:33 <pumpkin> for development
21:44:37 <thoughtpolice> pumpkin: no, it's fairly slow, but i'm going to use it to write cell code and random tomfoolery like that
21:44:41 <pumpkin> ah
21:45:16 <thoughtpolice> also i needed to update my kernel and bootloader anyway because kboot is out of date and 2.6.29 had some fixes for the ps3 merged in that make shutdowns clean, etc.
21:45:42 <thoughtpolice> so i decided to just get a copy of the ps3-linux git head, which features wifi/bluetooth drivers etc.
21:45:47 <quicksil1er> http://www.haskell.org/pipermail/haskell-cafe/2009-April/060182.html
21:46:10 <pumpkin> internet mailing lists are weird places :P
21:46:20 <quicksil1er> "these days it's chock full of stuff
21:46:22 <quicksil1er> which is hardly less critical for system operation"
21:46:24 <sjanssen> ddarius: 4643, I win!
21:46:50 * quicksil1er has 15237 unread in -cafe ;)
21:47:19 <pumpkin> wow
21:48:05 <ddarius> sjanssen: Sounds like we stopped at about the same time.
21:48:37 <Gracenotes> 3100. But from other mailing lists too.
21:49:08 <pumpkin> my e-penis is so much shorter than y'all's
21:49:51 <Zao> I'm down to 7000 unread now after a morning of ^R
21:52:44 <sjanssen> quicksil1er: I thought you said you can't be bothered? :)
21:54:45 <pumpkin> :o
21:55:03 <pumpkin> quicksilver to the rescue
21:56:14 <pumpkin> has godwin ever applied to any -cafe discussions?
21:56:52 <ddarius> Perhaps, pumpkin, you can be the first.
21:57:31 * mmorrow hates user installs
21:58:12 * pumpkin approves of the user default
21:58:51 <mmorrow> so we can all be convenienced when we're installing on some random shell account?
21:59:04 <sjanssen> mmorrow: it's nice for other reasons
21:59:22 <sjanssen> eg. I can nuke my user package DB and now that all system-level packages still work
21:59:25 <pumpkin> say I want to install pr0n-0.0.0 from hackage, and I don't want other users to see it
21:59:31 <wli> I usually call accounts by the kernel name.
21:59:51 <sjanssen> mmorrow: and I can barely see how the availability of user installs hurts anyone
21:59:59 <pumpkin> wli: nice
22:00:02 <mmorrow> sjanssen: we should start putting /boot in ~/.boot so we can nuke it too
22:00:12 <sjanssen> just drop a couple lines in your cabal-install config
22:00:14 <mmorrow> sjanssen: i don't think it hurts anyone
22:00:28 <mmorrow> i just think it shouldn't be the default
22:00:35 <sjanssen> ah
22:01:14 <mmorrow> i think having things install stuff in my home directory triggers a neurosis or something
22:01:32 <wli> I've taken a break from not understanding module systems and gone to totally misunderstanding algebraic geometry and how to factor polynomials.
22:01:46 <mmorrow> wli: heh
22:02:17 <ray> stuff that wants to install outside my home directory drives me crazy, because then it's lost in the jungle of the UNIAX filesystem layout
22:02:20 <ray> possibly forever
22:02:23 <pumpkin> yeah
22:02:40 <mmorrow> mkdir /usr/local/ghc
22:02:48 <mmorrow> mkdir ~/pr0n
22:02:52 <pumpkin> mmm
22:03:53 <mmorrow> ray: do you install everything in your home dir?
22:04:10 <wli> I'm still completely lost as to how Hensel lifting is applicable lifting factorizations in Z/p^nZ to Z/p^{n+1}Z.
22:04:13 <ray> anything that's not package managed by the package manager
22:04:16 <raxas> ray: never heard about locate?
22:04:21 * mmorrow stops ranting
22:04:48 * pumpkin uses mdfind
22:05:01 <ray> none of those programs can collect your uniax garbage
22:05:15 * mmorrow screams /usr/local to the abyss
22:05:16 <mmorrow> :)
22:05:26 <inimino> it really is pretty simple
22:05:32 <blackh> wli: Well don't look at me!
22:05:33 <inimino> use /usr/local
22:06:04 <inimino> problem solved
22:13:08 <quicksil1er> sjanssen: well, I read it a third time and I thought I had a short, simple and not too emotional response :)
22:13:32 <quicksil1er> sjanssen: my first or second cancelled emails were not appropriate for -cafe :P
22:13:37 <pumpkin> quicksil1er: "Hitler. Nuff said"
22:13:42 <pumpkin> :P
22:14:28 <pumpkin> quicksil1er: oh no, he replied :o
22:14:34 <quicksil1er> sjanssen: just to be clear, I'm not opposed to user installs.
22:14:42 <Gracenotes> :o
22:14:53 <quicksil1er> sjanssen: I was just making the point that, since everything else defaults to /usr/local installs, there is an argument for cabal to do so as well.
22:15:31 <quicksil1er> in fact originally it wasn't even my intention to back that argument all that strongly, merely to explain it more clearly since I thought the point someone before me (Achim?) had been trying to make had not been picked up.
22:15:35 * quicksil1er shrugs.
22:15:52 <pumpkin> we need a wiki page mapping real names to nicks and back
22:15:54 <quicksil1er> it's about sensible defaults not removing functionlity.
22:15:58 <pumpkin> for -cafe reference
22:16:07 <quicksil1er> my real name is a closely guarded secret.
22:16:14 <pumpkin> I can tell :P
22:16:25 <quicksil1er> only those who have mastered the arcane art of the /whois command can possibly work it out.
22:16:43 <pumpkin> will you teach me, o master?
22:16:55 <dolio> How can a default to global installs prevent you from doing local installs?
22:22:08 <Reiver> Whoa. That's... not a small channel.
22:22:16 <Zao> Reiver: A keen observation.
22:22:41 <Gracenotes> (ï½€ï½¥Ï‰ï½¥Â´)ã‚ ï¼œ Welcome to ï¼ƒhaskell
22:22:57 <Reiver> So, er. I'm just learning Haskell, and having fun with Really Stupid Errors and the like. Is this the right place to accost folks for advice, or should I be looking elsewhere?
22:23:15 <pumpkin> definitely the right place :)
22:23:18 <pumpkin> we love helping people here
22:23:30 <pumpkin> it goes against our goal to avoid success at all costs, but we do it anyway
22:23:41 * Reiver snickers.
22:23:59 <Reiver> Okay, let me throw this little code fragment up on a pastie so people can see what I'm throwing at the wall.
22:24:11 <pumpkin> I guess failing to avoid success is equivalent to avoiding success at avoiding success
22:24:38 <pumpkin> @paste
22:24:38 <blackh> Reiver: Watch out - you might get 8 answers the same.
22:24:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:26:01 <Reiver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4007#a4007
22:26:25 <pumpkin> ok
22:26:30 <Reiver> I'm getting thrown errors that, as far as I can tell, are complaining that I can't divide an integer by two in case I get a fraction (which is reasonable enough).
22:26:33 <Gracenotes> pumpkin: either that, or avoiding success implies that you're avoiding success at avoiding success, meaning that avoiding success may be a comonad
22:26:40 <pumpkin> lol
22:26:41 <blackh> Reiver: Hmm.. length x2 `div` 2
22:27:26 <Reiver> I was kinda hoping for integer division, but dunno how to tell Haskell To Divide And Drop The Remainder, Please(tm).
22:27:32 <Reiver> blackh: ... I am a little puzzled as to what that would, uh, do.
22:27:49 <quicksil1er> Reiver: div is integer division
22:27:54 <Gracenotes> the Num classes.. and their many functions
22:27:58 <pumpkin> :t div
22:27:59 <lambdabot> forall a. (Integral a) => a -> a -> a
22:28:00 <pumpkin> :t (/)
22:28:02 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:28:02 <quicksil1er> backquotes make a normal function (div) into a an infix one
22:28:03 <blackh> Reiver: ` ` makes it infix
22:28:08 <quicksil1er> > div 5 2
22:28:09 <Reiver> Ah! Okay. Danke kindly. :)
22:28:10 <lambdabot>   2
22:28:13 <quicksil1er> > 5 `div` 2
22:28:14 <lambdabot>   2
22:28:40 <pumpkin> > 5 `divMod` 2
22:28:42 <lambdabot>   (2,1)
22:29:06 <Gracenotes> :O
22:29:19 <quicksil1er> and now, he's suggesting that installers shouuld be interactive and ask me questions?
22:29:20 <Reiver> Handy!
22:29:23 <quicksil1er> heaven save us.
22:29:30 <Gracenotes> divMod is more of a convenience function... neither result uses the other
22:29:32 <quicksil1er> I will do what I should have done last time, and ignore the thread.
22:29:55 <Jedi_Stannis> general question: when writing code, and you notice some repeated code that should be factored out, but you don't have a good name for it - its just some repeated logic - how do you come up with a good name for it?
22:29:56 <Gracenotes> at least for Ints, Integers, etc.
22:30:05 <quicksil1er> Gracenotes: on a good day, with a following wind, the right optimisation flags, etc, quotRem might compile down to a single machine opcode.
22:30:24 <pumpkin> Jedi_Stannis: I call it x12524
22:30:30 <ddarius> quicksil1er: A prudent course of action.
22:30:34 <blackh> quicksil1er: He is a New Zealander. We are almost child-like in our naivete
22:30:40 <Gracenotes> quicksil1er: hum. That's more C--'s perogative, I think.
22:30:50 <pumpkin> ahem
22:30:53 <Gracenotes> +r
22:30:57 <pumpkin> :)
22:31:13 <Gracenotes> +fu :(
22:31:27 <Gracenotes> +srynvm
22:31:31 <Reiver> Hum. So then. I've got 'take' to get the first half of the list... I should either get a function that actually splits off that part of the list. I think I'll handwrite it for the heck of it...
22:31:56 <mmorrow> @src (^)
22:31:56 <lambdabot> x ^ 0            =  1
22:31:56 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
22:31:56 <lambdabot>   where f _ 0 y = y
22:31:56 <lambdabot>         f x n y = g x n
22:31:56 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
22:31:58 <lambdabot>                       | otherwise = f x (n-1) (x*y)
22:32:00 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
22:32:58 <arabidopsis> hi! Any Archlinux users around here?
22:33:09 <arabidopsis> I cannot find haskell-cabal AUR anymore?
22:33:34 <arabidopsis> and it requires ghc 6.10.1 , but Arch has 6.10.2 ghc
22:35:47 <HeavensRevenge> hello arabidopsis
22:36:01 <HeavensRevenge> so u need need aur to play nice?
22:36:34 <arabidopsis> HeavensRevenge: my problem is I cannot find haskell-cabal AUR anymore? is it orphaned or something?
22:36:55 <HeavensRevenge> have you tried yaourt?? might help with a dependency, otherwise youll need to alter the PKGBUILD file
22:37:19 <HeavensRevenge> hmm yea get yaourt in there, make yaourt query the aur
22:37:36 <arabidopsis> yaourt doesn't show haskell-cabal anymore, it I have the PKGBUILD, I won't be asking this question.
22:37:37 <HeavensRevenge> and then see if you can get it that way 1st, before going manual
22:38:02 <arabidopsis> even you go to aur.archlinux.org you cannot find haskell-cabal anymore
22:38:25 <HeavensRevenge> im on my way :P
22:38:35 <HeavensRevenge> havent visited my luvly aur for a while
22:40:00 <glguy> did it move into community?
22:40:10 <HeavensRevenge> yea something like this was happeneing when i was playin with this a while back
22:40:29 <HeavensRevenge> i think they transitioned to cabal-install instead
22:41:09 <HeavensRevenge> i had this problem settin up arch again from a debian perspetcive
22:42:19 <arabidopsis> then, what should I do? uninstall haskell-cable and install cabal-install
22:42:21 <HeavensRevenge> they had that haskell-cabal, and im used to getting direct from hackage, so this cabal-install is the proper aur'd cabal
22:43:08 <HeavensRevenge> yea, that was they initial one:P BUT you do have the old haskell packjage right??
22:43:29 <arabidopsis> but many AUR packages depends on haskell-cabal. Do I have to rebuild all those packages?
22:44:49 <arabidopsis> HeavensRevenge: I still have the haskell-cabal installed, but it prevents the upgrade to 6.10.2
22:45:16 <HeavensRevenge> just keep a copy of the hackell-cabal .pkg.tar.gz package for manual reinstallation
22:45:29 <HeavensRevenge> but yea... replace
22:45:52 <Saizan_> arabidopsis: when you upgrade ghc you've to rebuild the libs anyway
22:45:53 <HeavensRevenge> and yup lol you probably will have to rebuild them
22:46:23 <HeavensRevenge> yea but hes in a "distro haskell world" not the real world, just his distros percieved one
22:46:55 <HeavensRevenge> even tho its an awesome perspective ;) their packages which are double rev dependencies and double dependencies
22:47:12 <arabidopsis> well, I have no knowledge of haskell. I may just keep my ghc as is for now. The only reason I have haskell stuff is for xmonad and pandoc only.
22:47:17 <HeavensRevenge> since the packaging systems in combo and conflict are pacman and cabal
22:48:44 <Reiver> ...Ooh, I wonder if I can do it that way.
22:48:53 <HeavensRevenge> hopefully youll get sucked into our awesome way of live if you like xmonad arabidopsis :)
22:54:50 <Reiver> hrm. So, to split a list in half, so [1,2,3,4,5] => ([1,2],[3,4,5]) I'm pondering if you can't just rig a recursion to stop if length firstList >= endList ?
22:55:05 <Gracenotes> so, I was in the shower the other day and I got why the monomorphism restriction can be inefficient
22:55:08 <chromakode> yourang?
22:55:22 <Gracenotes> rather, not having the restriction
22:56:46 <Gracenotes> I know, cool story
22:57:08 <dolio> Because computing something N times is often slower than computing it once?
22:58:25 <Gracenotes> why the restriction makes lazily caching certain computations difficult
22:58:38 <Axman6> Reiver: i'd just find the length once then split at length xs `div` 2
22:58:44 <Gracenotes> 'cache' not the most descriptive word, but, you know.
22:59:14 <Axman6> which is O(n), ot O(n^2) or whatever that would be
23:01:18 <Gracenotes> I wonder how efficient it would be to have one accumulator skip one node at a time and another accumulator skip two nodes at a time
23:01:21 <Reiver> Axman: Yeah, this turned out to be much easier.
23:01:33 <Reiver> It was a Clever Idea that turned out rather too complicated to actually implement~
23:01:42 <Gracenotes> and then, when the second reaches the end, use the results
23:01:54 <Axman6> @pl splitIn2 xs = splitAt (length xs `div` 2) xs
23:01:54 <lambdabot> splitIn2 = splitAt =<< (`div` 2) . length
23:01:58 <Axman6> heh
23:02:18 <Reiver> Axman: I'm doing this stuff to get the hang of the language, though.
23:02:34 <dolio> > let halve xs = go xs xs where go (x:xs) (_:_:zs) = first (x:) (go xs zs) ; go xs _ = ([], xs) in halve [1..20]
23:02:36 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
23:02:37 <Gracenotes> it might be difficult not having the first part reversed... without a sort of difference list like reverse uses
23:02:38 <Reiver> Start with simple things that have been done before (because really, the simple stuff inevitably has), work my way up from there.
23:03:00 <Gracenotes> oh. :o very nice
23:03:07 <Reiver> ... that wins.
23:03:11 <Axman6> dolio: heh, i'm impesssed i understand that :)
23:03:14 * Reiver eyes his code. Yeah, that wins~
23:03:41 <Axman6> dolio: hmm, how lazy would that be?
23:04:00 <dolio> > let halve xs = go xs xs where go (x:xs) (_:_:zs) = first (x:) (go xs zs) ; go xs _ = ([], xs) in halve [1..]
23:04:02 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
23:04:18 <dolio> Not lazy for the second part, I thnk.
23:04:19 <Axman6> very nice
23:04:22 <Axman6> yeh
23:04:24 <dolio> > let halve xs = go xs xs where go (x:xs) (_:_:zs) = first (x:) (go xs zs) ; go xs _ = ([], xs) in snd $ halve [1..]
23:04:48 <lambdabot>   mueval: Prelude.read: no parse
23:05:43 <Gracenotes> a similar technique can check if there are repeats in a list, except in Haskell there is just value comparison, so not much use here
23:06:00 <Gracenotes> i.e. if the whole list repeats. cycles
23:08:09 <dolio> If you don't care about splitting at the middle and just want two (almost) equally sized lists, you can be lazy in both, of course.
23:09:04 <Reiver> hmm. I'm happy with what I ended up with.
23:09:35 <dolio> > let demux [] = ([],[]) ; demux (x:xs) = first (x:) $ demux' xs ; demux' [] = ([],[]) ; demux' (x:xs) = second (x:) $ demux xs in take 10 *** take 10 $ demux [1..]
23:09:39 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19],[2,4,6,8,10,12,14,16,18,20])
23:10:03 <Reiver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4007#a4008
23:10:55 <Gracenotes> > partitionEithers (cycle [Left, Right] <*> [1..20])
23:10:56 <lambdabot>   Not in scope: `partitionEithers'
23:11:00 <Gracenotes> :[ aww
23:11:24 <dolio> @type lefts
23:11:25 <lambdabot> Not in scope: `lefts'
23:11:32 <dolio> @type Data.Either.lefts
23:11:33 <lambdabot> Not in scope: `Data.Either.lefts'
23:12:15 <andresj> :t Data.Either.Left
23:12:17 <lambdabot> forall a b. a -> Either a b
23:12:25 <andresj> the closest there as far as i can see :P
23:12:25 <dolio> That would be ([1..20], [1..20]) anyhow.
23:12:35 <Gracenotes> actually, yeah, I'm thinking of ZipLists
23:12:45 <dolio> You could `zip`.
23:12:54 <dolio> Wait, no.
23:12:58 <Gracenotes> zipWith ($), yes
23:13:01 <dolio> Yeah.
23:13:17 <dolio> But that doesn't infix nicely.
23:13:19 <Gracenotes> ZipLists are neat
23:15:19 <dolio> That halve might leak space.
23:15:24 <Reiver> One should use guards in favor of if-then-else, correct?
23:15:36 <Axman6> depends on the situation
23:15:44 <Axman6> and it's really up to you
23:15:54 <Reiver> Hm. Let's pretend I want to, then.
23:16:01 <dolio> For every element you force in the first list, two elements are forced.
23:16:30 * Reiver goes hunting for documentation on how to do 'em.
23:17:12 <Axman6> Reiver: well, do you have an example of some code you'd like to convert to using guards?
23:17:31 <dolio> Or, I should say, if you consume the entire first list, then the second list's spine will be fully evaluated, as long as you keep it in scope.
23:19:49 <Reiver> Well, not really. I'd like to create a function that merges two sorted lists, so [1,3,5] [2,6,8] => [1,2,3,5,6,8]. I figure recursion that takes the heads of the two lists, compares them, merges the smallest onto a third list and continues is the best way to go.
23:20:17 <Axman6> so merge sort's merge function?
23:20:25 <Reiver> Pretty much, yes.
23:20:33 <Axman6> that's a very nice example for usign guards actually
23:20:34 <Gracenotes> Reiver: Haskell's guards can handle that nicely
23:20:48 <Reiver> I thought they could - I sorta made the example up to use them ;)
23:20:49 <Axman6> Reiver: would you like me to show you how to do it, then explain it?
23:20:53 <Gracenotes> (one could also use a case statement with the 'compare' function)
23:21:01 <Gracenotes> @src compare
23:21:01 <lambdabot> compare x y | x == y    = EQ
23:21:01 <lambdabot>             | x <= y    = LT
23:21:01 <lambdabot>             | otherwise = GT
23:21:10 <Axman6> zomg guards!
23:21:15 <Reiver> Aha!
23:21:18 <Gracenotes> well... that's the default
23:21:29 <Gracenotes> Ints/Integers have a somewhat more sophisticated one I believe
23:21:33 * Reiver is rather terrible at searching this haskell documentation yet, so...
23:21:35 <Axman6> :t compare
23:21:36 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
23:21:41 <Axman6> @src Ord
23:21:41 <lambdabot> class  (Eq a) => Ord a  where
23:21:41 <lambdabot>     compare      :: a -> a -> Ordering
23:21:41 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
23:21:41 <lambdabot>     max, min         :: a -> a -> a
23:21:56 <Axman6> @src (<=)
23:21:57 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
23:22:02 <ddarius> @src Int compare
23:22:02 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:22:41 <Gracenotes> > case compare 4 5 of { LT -> "less than!"; EQ -> "2 equal 4 u"; GT -> "GREATER THAN" }
23:22:43 <lambdabot>   "less than!"
23:26:13 <Axman6> Gracenotes: yu don't have a link to the definitions of compare for Int do you?
23:26:29 <Axman6> you*
23:26:47 <dolio> It uses <#, ==# and >#.
23:26:52 <Gracenotes> it seems it's a wrapper for primitives
23:27:08 <Gracenotes> yeah, what dolio said :X
23:28:16 <jinjing> @bot
23:28:16 <lambdabot> :)
23:28:17 <lunabot>  :)
23:28:27 <Gracenotes> cmpInteger# for Integers, which returns negative Int# if LT, positive if GT, otherwise use EQ
23:28:31 <dolio> Actually, maybe not >#, since the first two are sufficient to find an answer.
23:30:32 <Gracenotes> compareInt# x# y#
23:30:32 <Gracenotes>     | x# <#  y# = LT
23:30:32 <Gracenotes>     | x# ==# y# = EQ
23:30:32 <Gracenotes>     | otherwise = GT
23:31:19 <Gracenotes> it doesn't seem the order of checking is terribly consistent among the basic numeric types
23:31:47 <Axman6> hmm, why not have x# <# y# then x# ># y# then the otherwise? (is there a >#?)
23:31:59 <Gracenotes> well, Integer, mainly
23:32:42 <Gracenotes> Axman6: axiom of trichotomy?
23:32:59 <Gracenotes> ># exists
23:33:00 <Axman6> eh?
23:33:25 <Gracenotes> either x < y, x = y, or x > y
23:33:35 <Axman6> well yeah
23:33:41 <Gracenotes> better stated in terms of order theory. but yeah.
23:33:45 * Reiver ponders, stabs hugs.
23:33:48 <bryan1> How can I get the name of a data constructor at runtime?
23:34:07 <glguy> bryan1, ideally, you don't
23:34:07 * Reiver should really go look up the documentation for that later. Stupid default settings.
23:34:17 <Axman6> i was just thinking that x == y can only be for equal pairs, which are probably far less likelt than than x > y or x < y
23:34:41 <glguy> bryan1, otherwise, you can make a function constructor :: YourType -> String
23:34:56 <blackh> bryan1: Types don't exist at runtime unless you use Data.Typeable... there's a GHC extension that can make things typeable for you automatically.
23:35:08 <Gracenotes> who knows, though. Most of the time you'd use >=, <, etc. not compare, directly
23:35:17 <Axman6> yeah
23:35:37 <bryan1> blackh: I am trying that now, but am having a few issues... :|
23:35:49 <Axman6> just thinking it'd be more efficient to check for the > and < cases first, then if it's anything else, it must be equal
23:35:49 <Gracenotes> for sorting... I suppose it helps with mostly-sorted data :)
23:36:00 <Axman6> hmm, i guess
23:36:16 <blackh> bryan1: Well, typeable can allow you to display the type of a value at runtime
23:36:25 <blackh> bryan1: What are you trying to achieve/
23:36:33 <Gracenotes> anyway, they are straight-to-machine-code-rather-optimized
23:36:38 <glguy> blackh, check out toConstr in Data.Data
23:36:44 <glguy> Data.Typeable is for types
23:36:44 <Axman6> yeah
23:36:47 <glguy> constructors aren't types
23:37:23 <glguy> > toConstr (Just 10)
23:37:35 <bryan1> I am writing a binary file w/standardized set of key values.  When I write a value I want to maintain the data type so that when I read it back in I can construct the same types as I used to write with.
23:37:36 <glguy> Prelude Data.Data> toConstr (Just 10)
23:37:36 <glguy> Just
23:37:54 <blackh> glguy: That's nuts!
23:37:57 <glguy> bryan1, you would more likely want to write Binary instances
23:38:05 <glguy> and use the binary package for this
23:38:34 <Axman6> bryan1: yeah check out Data.Binary, it's a really nice interface
23:38:55 <bryan1> glguy: I'm not looking to serialize all types tho.  It's more of a log file that I can run queries against.
23:39:25 <glguy> bryan1, right, so write Binary instances for the types you do want to serialize
23:39:46 <Axman6> i'm cut that the source links don't work on http://haskell.org/ghc/docs/latest/html/libraries/ghc-prim/GHC-Prim.html#8 :(
23:39:51 <glguy> typically when you start using Typeable and Data you are doing it wrong
23:40:06 <bryan1> glguy: thanks.
23:40:12 <lambdabot>   /tmp/4987869176094509516:70:40: Not in scope: `toConstr'
23:40:47 <Gracenotes> Axman6: the source is: let x = x in x
23:40:48 <Gracenotes> for all of 'em
23:41:05 <Axman6> heh
23:41:09 <Axman6> awesome
23:41:19 <cads> hey, if I've got a theorem from a math book, what do I need to do to turn it into a useful function in a haskell?
23:41:25 <cads> :)
23:41:46 <Gracenotes> then code generation kicks in at ghc/compiler/
23:41:52 <Axman6> that's cooler than when i found out that RealWorld's definition was data RealWorld (and then found out that was just shorthand :( )
23:43:01 <Gracenotes> reallyUnsafePtrEquality# = let x = x in x
23:43:34 <Gracenotes> but, in ghc/compiler/codeGen/CgPrimOp.hs, emitPrimOp [res] ReallyUnsafePtrEqualityOp [arg1,arg2] live = stmtC (CmmAssign (CmmLocal res) (CmmMachOp mo_wordEq [arg1,arg2]))
23:44:25 <Gracenotes> I have no idea how it gets capitalized along the way, but.. it just does
23:45:24 <Gracenotes> oh, wait. primop  ReallyUnsafePtrEqualityOp "reallyUnsafePtrEquality#" GenPrimOp, from compiler/prelude/primops.txt.pp
23:45:44 <Gracenotes> niiice.
23:46:23 <Gracenotes> GHC people know what they're doing :o
23:46:57 <Axman6> >_<
23:51:00 <omg911> !latest
23:52:01 <Axman6> o.O
23:52:32 <Gracenotes> ï¼ˆã€€Â´_ã‚`ï¼‰
23:52:40 <olsner> hehe, I wonder how C would look if every unsafe operation had an unsafe or reallyUnsafe prefix
23:53:01 <Reiver> curious. This is doubtless a Silly Error, but: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4009#a4009 is throwing a type error.
23:53:42 <Axman6> z unsafe= x unsafe+ y
23:54:16 <Reiver> What've I missed?
23:54:16 <sjanssen> Reiver: you need parens around (x:y:xs)
23:54:26 <Reiver> ...oh. Duh.
23:54:37 <ezyang> Those damn operator precedence
23:54:51 * Reiver laughs. Figured it was something Really Obvious, but he's still too new to spot such things.
23:55:00 <Reiver> Please forgive the newbie questions :)
23:55:28 <Axman6> Reiver: that's what we're here for ;)
23:55:29 <sjanssen> no problem, it's what #haskell is for
23:55:36 <Axman6> whoops, need to go@
