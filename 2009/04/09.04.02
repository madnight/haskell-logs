00:02:16 <neoswish> @type inRange
00:02:17 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
00:02:48 <neoswish> why its (Ix a), not (Ord a), its stupid)
00:03:21 <wli> neoswish: The comparison is not done via the Ord instance.
00:03:55 <jmcarthur> @src inRange
00:03:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:03:58 <jmcarthur> meh
00:04:03 <neoswish> but it could, why i must instead write my own inRange)
00:05:00 <wli> neoswish: It's not.
00:05:06 <wli> (1, 3) < (2, 2)
00:05:20 <wli> > (1, 3) < (2, 2)
00:05:21 <lambdabot>   True
00:05:51 <wli> > inRange ((1,1),(2,2)) (1,3)
00:05:53 <lambdabot>   False
00:05:56 <jmcarthur> what i want to know is why IOMode is an instance of Ix...
00:06:01 <jmcarthur> @instances Ix
00:06:02 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
00:06:12 <jmcarthur> @instances Data.Ix.Ix
00:06:13 <lambdabot> Couldn't find class `Data.Ix.Ix'. Try @instances-importing
00:06:26 <jmcarthur> grr
00:06:40 <wli> > let { lo = (1,1) ; hi = (2,2) ; x = (1,3) } in (lo <= x && x <= hi, inRange (lo, hi) x)
00:06:41 <lambdabot>   (True,False)
00:06:54 <wli> neoswish: Believe me now?
00:07:24 <neoswish> ok, its just will be nice to have inRange for Doubles for example
00:08:06 <jmcarthur> "The Ix class is used to map a contiguous subrange of values in a type onto integers. It is used primarily for array indexing (see the array package)."
00:08:17 <wli> neoswish: I don't believe implementing an Ix instance for Double makes sense.
00:08:17 <jmcarthur> that's why Double isn't an instance of Ix
00:09:06 <neoswish> i dont want an instance for Ix, just inRange for Doubles in Prelude )
00:10:53 <jmcarthur> @pl \(mn,mx) x -> mn <= x && mx >= x
00:10:53 <lambdabot> uncurry ((. (>=)) . ap . ((&&) .) . (<=))
00:11:02 <jmcarthur> @pl \x -> mn <= x && mx >= x
00:11:02 <lambdabot> liftM2 (&&) (mn <=) (mx >=)
00:11:09 <wli> class Boxy t where { inBox :: (t, t) -> t -> Bool } ; instance Ix t => Boxy t where { inBox = inRange } ; instance Boxy Double where { ... }
00:11:23 <jmcarthur> :t \(mn,mx) -> liftM2 (&&) (mn <=) (mx >=)
00:11:24 <lambdabot> forall t. (Ord t) => (t, t) -> t -> Bool
00:12:13 <jmcarthur> no need for a new type class. Ord should be fine for that definition, afaik
00:12:41 <jmcarthur> oh, you are doing the Ix instance, n/m
00:12:41 <wli> You can't do instance Ord t => Boxy t because the Boxy instance on (t, t) clashes with the Ord (t, t) => Boxy (t, t) instance.
00:13:36 <jmcarthur> i just meant you can get the function without the type class, but it would not work over things that are instances of Ix but not Ord
00:14:08 <jmcarthur> oh wait
00:14:14 <jmcarthur> all Ix are instances of Ord
00:14:58 <wli> There may be some trouble then. Boxy will have to not use those kinds of instances.
00:16:04 <wli> It can only use direct instance (Boxy t1, Boxy t2) => Boxy (t1, t2) where { ... } ; instance (Boxy t1, Boxy t2, Boxy t3) => Boxy (t1, t2, t3) where { ... } etc.
00:17:46 <wli> It's really more of a type constructor affair.
00:21:38 <wli> It's essentially whether bounding boxes are expressible.
00:21:55 <neoswish> is there way to overload functions?
00:22:46 <wli> Hmm. Generativity doesn't sound like something I like.
00:22:55 <wli> I'd much rather have referential transparency.
00:23:28 <neoswish> what is this?
00:24:22 <wli> neoswish: Module system issues.
00:27:26 <wli> Generativity is basically C++ template bloat before they figured out .linkonce sections or whatever.
00:31:46 <pumpkin> :t liftIO
00:31:47 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
00:32:21 <adamvo> neoswish: you mean more than the 'overloading' that happens due to typeclasses?
00:32:25 <adamvo> :t (+)
00:32:26 <lambdabot> forall a. (Num a) => a -> a -> a
00:32:51 <markw2> Is it possible in c2hs to address in #set a union that is part of a struct ?
00:34:07 <neoswish> adamvo, yes more, i.e. if i want (+) :: a -> a -> b, what i can do?
00:34:28 <pumpkin> newsham: functional dependencies might help, but in general types like that are inconvenient
00:34:45 <pumpkin> markw2: I don't think it can do that easily
00:35:05 <markw2> No it seems like it as I am having problems :)
00:36:39 <jedai> neoswish: You can create typeclass with more than one parameter
00:39:38 <wli> http://www.cs.cmu.edu/~rwh/papers/thoms/tr2.pdf <-- this seems to be useful
00:46:53 <wli> http://www.cs.cmu.edu/~rwh/papers/thoms/tr2.pdf <-- rocking my world wrt. explaining wtf. is going on wrt. module systems
00:47:25 <wli> edwardk: Harper's page seems to be the mother lode of module systems
00:51:03 * sm bookmarks
00:52:23 <sm> incidentally, would it be safe to assume that cabal install builds with -O2 ?
00:58:15 <wli> sm: Bookmarking Harper's page?
00:58:21 <sm> yup
00:58:32 <sm> I like pages that explain wtf is going on
00:58:52 <wli> sm: bookmark http://www.cs.cmu.edu/~rwh/papers.htm not the URL of that particular PDF
00:59:30 <sm> thanks
00:59:50 <wli> He's got a whole raft of good papers.
01:00:09 <osfameron> is a raft really a good place to keep papers?  won't they get wet?
01:05:58 <mjk> how to haskell display chinese string?
01:06:17 <pumpkin> mjk: in the encoding you ask it to
01:06:28 <pumpkin> utf8 is probably the most widely supported one
01:06:53 <mjk> can you give me a example? thanks
01:16:30 <adamvo> @where utf8-string
01:16:30 <lambdabot> I know nothing about utf8-string.
01:16:37 <adamvo> @hackage utf8-string
01:16:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
01:19:05 <adamvo> mjk: the functions in that library can do the encoding and decoding transparently (just use it like the normal IO stuff)
01:19:45 <mjk> thanks
01:23:10 <wli> Okay, the way people describe the way I think higher-order modules should be is "applicative functors" vs. the C++ template -like bloat of "generative functors."
01:23:22 <wli> s/generative functors/generativity/
01:23:36 <wli> ocaml uses applicative functors.
01:28:47 <wli> I'm completely lost as to what the problem is with recursive modules even after Harper's recursive module paper.
01:30:18 <adamvo> wli: then just pretend that there aren't any problems for now =)
01:30:57 <wli> What kind of sense is that supposed to make?
01:33:35 <quicksilver> wli: the problems with recursive modules are (AFAIK) about dependencies and separate compilation.
01:33:52 <quicksilver> wli: it should be fine to have mutual recursion where each module only depends on the other's *signature*
01:34:12 <quicksilver> and it should also be fine if you don't care about separate compilation.
01:34:13 <quicksilver> right?
01:35:28 <wli> I'm interpreting anyway, but as I see it all I need to do is dump whatever I've been able to infer thus far from that particular module into bytecode or whatever and slurp it back up upon resumption if I care to cache separate module processing.
01:35:43 <wli> I'd just use Data.Binary on some internal interpreter state.
01:36:07 <quicksilver> well that forces you to have a representation for 'partially-type-checked'
01:36:21 <quicksilver> and potentially go backwards and forward a number of times before you reach the fixed point.
01:36:58 <wli> quicksilver: Partial type checking, partial name resolution, etc. don't seem problematic at all to me.
01:37:01 <quicksilver> AFAIk it's not a fundamentally different problem from mutually recursive functions + types.
01:39:38 <wli> Generate constraints, reduce them as much as you can, spew them out.
01:40:30 <wli> Or, rather, spew out what's left.
01:41:05 <wli> You only care if they're fully solved at the end.
01:46:42 <wli> I guess my solution to "separate compilation" is basically to dump intermediate states and representations for processing a module in the absence of other information and arranging various of the algorithms to allow some computational progress to be made without reference to other modules.
01:48:32 <wli> This has something of a disadvantage in that it essentially precludes flagging errors on account of inter-module errors except on an opportunistic basis.
01:49:20 <wli> Or defers such until (much) later.
01:50:32 <wli> You could do something resembling incremental linking on such IR dumps.
01:53:36 <wli> I actually think the softness wrt. errors so long as there's internal consistency may be a good thing to do; things that crop up as type errors in one module may actually be because another did the wrong thing.
01:54:48 <enkrav> hello, I have a function f::Char->Bool, f c = (c>='a') && (c<='f'). I looked at the ghc-core of the function to see the strictness I see Str: DmdType U(L). Why? I would just expect an S or an U
01:55:02 <enkrav> since the function is clearly strict
01:57:57 <quicksilver> to know it's strict you need to know that >= is strict, and that && is left-strict.
01:58:06 <quicksilver> maybe ghc fails to know one of those things?
01:58:18 <quicksilver> still I think it's a question for #ghc channel.
02:00:41 <jacobian> when mixing do and lets do people usually just use a do, and use return ?
02:00:49 <jacobian> Otherwise I tend to drift to the right...
02:03:23 <jacobian> It's just a style question really
02:03:31 <quicksilver> you don't need to drfift to the right
02:03:37 <quicksilver> there is a special form of let, to use in do blocks
02:03:41 <quicksilver> which doesn't drift
02:03:54 <quicksilver> do { foo; let a = bar; baz; }
02:05:33 <jacobian> Awesome, thanks
02:08:18 <wli> quicksilver: I so wish there were a case to use in do blocks that didn't drift.
02:10:26 <quicksilver> you mean case on a single alternative, i.e. an unwrap?
02:11:46 <wli> Well, it's more that you have to introduce a fresh do block for each alternative, so you actually get hit two indentation levels.
02:12:31 <quicksilver> true.
02:12:43 <quicksilver> can be worth defining the whatever-o-morphism
02:12:47 <quicksilver> like 'maybe'
02:14:24 <wli> My quasi-workaround is to try to define the alternatives in a let block before the case function.
02:14:54 <wli> Or, if they don't depend on anything in the do block, floating them even further outward.
02:15:57 <wli> C_k x_1 ... x_n_k
02:16:43 <wli> C_k x_1 ... x_n_k -> f_k x_1 ... x_n_k
02:17:56 <wli> define f_k in a let above the case
02:20:29 <wli> A lot of times it'll be crud like case ( ... , ... ) of { (Just x, Just y) -> ... ; (Nothing, Just y) -> ... ; ... }
02:22:18 <quicksilver> wli: you can sometimes refactor those in terms of the Monad, Monoid, or MonadPlus instances of Maybe
02:22:24 <quicksilver> wli: but generically I udnerstand your point
02:22:31 <quicksilver> it doesn't bite me very often.
02:23:59 <ivanm> with the april fool's joke, why did SPJ choose a koala?
02:24:04 <ivanm> did dons put him up to it?
02:24:21 <doserj> SPJ didn't
02:24:39 <ivanm> oh? who was it then?
02:24:51 <doserj> Ketil Malde
02:25:10 <ivanm> ahhhh
02:25:16 <ivanm> is he an aussie?
02:25:47 <quicksilver> he's norwegian I think
02:30:28 <ivanm> so why did he choose a koala?  I don't see the connection... :s
02:30:33 <wli> case ... `compare` ... of { EQ -> ... ; LT -> ... ; GT -> ... } is really easy to float up to preceding lets.
02:31:51 <mmorrow> wli: i'm not sure if you're seen these, but they're excellent:
02:31:58 * mmorrow actually finds the links now..
02:32:25 <mmorrow> (and very directly applicable/no-nonsense)
02:33:02 <wli> cool
02:33:03 <mmorrow> there ones section in here that briefly glosses over linking http://ncstrl.cs.princeton.edu/expand.php?id=TR-220-89
02:33:06 <mmorrow> oops
02:33:17 <mmorrow> http://www.cs.princeton.edu/research/techreps/TR-220-89
02:33:32 <mmorrow> and this is way interesting:
02:33:44 <mmorrow> http://www.cs.princeton.edu/~appel/papers/hotslide.ps
02:34:30 <mmorrow> (there looks like there's more relevant stuff here, but i've only read those two of the ones that relate to linking http://www.cs.princeton.edu/~appel/papers/)
02:35:52 <wli> mmorrow: Well, my thoughts mostly centered around punting things impeding separate compilation to linking phases.
02:36:27 <mmorrow> hmm. what would be one such thing?
02:37:25 <wli> mmorrow: Anything relying on dependencies being preprocessed vs. mutually recursive modules.
02:37:41 <mmorrow> (i guess those links are more at the level of how to physically accomplish inter-module linkage, moreso than how to logically structure such a system, but i think these are more related than not)
02:38:36 <mmorrow> wli: it seems to me that mutually rec modules could be processed in an identical way to letrecs
02:39:32 <mmorrow> just pull out all the freevars in each binding, and add those to the args
02:39:32 <wli> Well, letrecs don't span files esp. files you're not processing at the time of invocation.
02:39:50 <mmorrow> but then how would you even know they're mutually recursive then?
02:39:57 <mmorrow> (or care?)
02:40:22 <wli> The idea was to do that so you don't care anymore.
02:41:08 <mmorrow> interesting. i think i've just not worked through any of the issues myself, so i don't have the little gotchas close in mind
02:42:36 <wli> Type errors involving usage of imported constructs' types and even scope ambiguity/absence issues can't be flagged until the module's lower shadow in the dependency graph is closed off in an incremental link or some such.
02:42:59 <wli> So there's a very clear loss of error reporting functionality.
02:44:38 <pozic> Is there a generalization of filter like fmap is for map in a library already?
02:44:53 <mmorrow> wli: i think it just has to be accepted that certain things aren't possible anymore when moving to entirely new systems/methods of doing things
02:45:00 <wli> OTOH it somewhat symmetrizes errors; e.g. if one module references something imported from another at the wrong type, you basically flag both modules as wrong.
02:45:45 <mmorrow> wli: nice. "symmetry" i've noticed is lacking from a lot of the "type checking" that various compilers/languages/whatever do
02:45:55 <Workybob> pozic: filterM, which should really be filterA
02:46:01 <Workybob> possibly filterF
02:46:21 <wli> mmorrow: Well, all I really do is generate a buttload of constraints from the module being processed, propagate whatever I can with the information in the module being processed, and save the work.
02:46:50 <pozic> Workybob: for a Data.Sequence I don't think these instances are there, are they?
02:47:04 <quicksilver> Workybob: that isn't the direction pozic is trying to generalise in, I don't think
02:47:10 <quicksilver> he wants to replace the list with a generic container
02:47:10 <wli> mmorrow: In fact, very stupidly, as a literal state dump.
02:47:14 <quicksilver> that's actually quite hard to do.
02:47:33 <quicksilver> none of our classes is really quite right
02:47:33 <pozic> quicksilver: yes, that's what I want to do.
02:47:41 <quicksilver> although you can right something using Monoid
02:47:46 <quicksilver> s/right/write/
02:47:52 <mmorrow> wli: if it works it works :)
02:48:28 <quicksilver> pozic: http://www.haskell.org/haskellwiki/Foldable_and_Traversable
02:48:32 <quicksilver> pozic: section 2
02:48:42 <quicksilver> pozic: I wrote a version of filter which requires Applicative, Foldable and Monoid
02:48:42 <ivanm> anyone know which versions of xulrunner gtk2hs supports?
02:48:47 <quicksilver> I'm not sure if you can do better than that.
02:49:06 <wli> mmorrow: It's the entire lower shadow of open imports because nameclashes could arise if any identifiers could still be introduced to the top-level scope of the module being processed.
02:50:50 <mmorrow> wli: ah yeah, that's true. but couldn't you just parameterize a module by everything free inside of it? then it's not literal splicing of stuff into it, but analogous to applications of a lambda
02:52:14 <mmorrow> (\fmap (Maybe@{Just,Nothing}) -> module Foo where .... fmap .... Just ....) someCommonName (Perchance@{Indeed,Bzzzt})
02:52:18 <mmorrow> or whatever
02:52:28 <wli> You have to carry out a resolution pass where (internally) all those freevars get fully qualified.
02:53:04 <mmorrow> what level are you doing this at? the source-level, or the level of object-code linkage?
02:53:49 <mmorrow> wli: yeah, for sure you'd have to figure out what the freevars in a module are..
02:54:02 <wli> Source level. You can't even finish typechecking until the type of the imported fully-qualified identifier is acquired from somewhere.
02:54:26 <wli> Nor can you even fully qualify it.
02:55:04 <mmorrow> couldn't you either 1) infer the type, or 2) require a signature of a bundle of stuff the module's parameterized by?
02:55:15 <mmorrow> (2 being the reasonable one)
02:55:46 <mmorrow> so such signatures would be directly analogous to annotating the param vars in a lambda with their type
02:56:24 <mmorrow> :t (\(x::{module{fmap::a->Int,....}) -> module ... fmap ...)
02:56:25 <lambdabot> parse error on input `{'
02:56:29 <wli> I don't really need to. I just save the constraint set as it stands from processing the module in isolation and do more when more information is made available.
02:56:48 <mmorrow> module{fmap::a->Int} -> module{......}
02:57:25 <mmorrow> wli: ah, that sounds reasonable.
02:57:47 <wli> There's a source-level difference between a functor and a structure I wouldn't want to disturb, and am not sure it'd help all that much.
02:59:12 <wli> mmorrow: One could also envision this as first stage processing on a per-file basis, and second-stage processing could be done with all that first stage information around (like .hi-boot getting auto-generated, only lots more dirt than those have).
02:59:30 <quicksilver> Workybob: does Peter V. IRC?
03:00:51 <wli> mmorrow: However, I foresee some pain with imported fixity decls.
03:01:08 <mmorrow> wli: heh
03:01:28 <quicksilver> yes, that sounds insane
03:01:36 <quicksilver> having another module influence your types is one thing
03:01:45 <quicksilver> having it influence your parsing is horrific.
03:01:58 <wli> That's already the case in Haskell.
03:02:01 <quicksilver> I know.
03:02:07 <mmorrow> wli: it seems like if you define and use some "core" rep rather than the actual source rep, things would be much easier (while still being equiv)
03:02:15 <quicksilver> the horror regularly assaults me.
03:02:22 <mmorrow> hehe
03:02:32 <quicksilver> at the very least, you could force fixities into the signature
03:02:44 <quicksilver> so they're visible at an "early stage"
03:03:02 <wli> The thing that's insane about it is suspending judgment on everything that could possibly be imported from another module etc. so you are trying to save all this stuff without even a complete parse.
03:03:54 <wli> mmorrow: That's what I've been trying to say I intended to do all along -- in fact, literally writeFile whatever $ show dumpOfIR
03:03:56 <mmorrow> wli: yeah, i think certain things about haskell would need to be changed to do this
03:04:15 <wli> mmorrow: Who's dealing with Haskell? This is my mini-interpreter.
03:04:26 <mmorrow> ahhhhh.
03:06:14 <mmorrow> wli: ok, s/haskell/any lang that has such a module system/ i think couldn't have external fixity decls/any such thing that would/could change how you even parse it
03:06:43 <wli> I don't believe that's true.
03:07:39 <mmorrow> hmm, so your strategy is to delay processing until that info becomes available?
03:08:13 <quicksilver> I would personally choose to make anything which affects parsing guaranteed avialbel at an early stage
03:08:17 <mmorrow> on second thought, that seems like it could work
03:08:20 <quicksilver> e.g. fixitiy decls in the module signature.
03:08:26 <quicksilver> it's your call, though, it's your langauge :P
03:09:00 <mmorrow> yeah, it seems like it'd be wayyyy for sanity-preserving to be able to at least parse a module fully/correctly in isolation
03:14:56 <mmorrow> wli: i just realized that thinking of compiling and linking as two conceptually different stages is just an arbitrary way of thinking about it that only seems natural because that's how it's been viewed
03:16:37 <quicksilver> mmorrow: Yes. To fix some of C++'s worst problems would require link-time code generation, really.
03:17:15 <quicksilver> mmorrow: to get a good compromise between modularity (possibility to compile libraries) and optimisation of a very high level language, you want to be able to do some code-gen/optimisation at link time.
03:17:19 <quicksilver> or JIT.
03:18:49 <mmorrow> totally. even more possibilities open up if the compiler and linker are the same program performing two tasks which intersect to some given extent
03:19:40 <quicksilver> I just noticed I used modularity in roughly the sense you used it yesterday, which I criticised as a poor usage.
03:19:44 <quicksilver> Ah well.
03:20:07 <mmorrow> (i used it?)
03:20:39 <snoobino> suppose I have a module A. Is it possible to say export everything from A + some of the prelude (for instance)
03:21:20 <mmorrow> module A (module A, map, id, Maybe(Just)) where ...
03:22:04 <mmorrow> (but you probably wouldn't want to export Prelude stuff unless the importer of that module is going to hide the prelude
03:22:06 <mmorrow> )
03:22:46 <quicksilver> exporting other people's modules is poor style.
03:23:08 <snoobino> its for a very special use
03:23:10 <quicksilver> exporting [stuff from] other modules is only sensible when they are your own, internal, modules which there is no other way to get stuff from.
03:23:18 <quicksilver> then, yes, you can.
03:23:23 <snoobino> I said prelude for an example
03:23:29 <quicksilver> You can export any symbol wherever you got it form.
03:23:30 <quicksilver> from.
03:23:45 <snoobino> thx
03:25:12 <lilac> quicksilver: the c++ module proposal seems to fix most of the compilation time issues without link-time codegen.
03:25:24 <lilac> quicksilver: (well, when combined with a template repository at least)
03:25:43 <wli> Yeah, the whole thing I'm doing is basically to punt almost everything to link-time.
03:26:06 <quicksilver> lilac: does it solve the problem that you need the entire implementation of the template library available at compile time?
03:26:10 <lilac> the trouble with requiring link-time codegen is you often then find you need dynamic-link-time codegen
03:26:24 <lilac> quicksilver: link-time codegen doesn't solve that.
03:26:28 <quicksilver> yes it does.
03:26:35 <quicksilver> that's precisely what it solves.
03:26:39 <lilac> compile time expands to include link time
03:26:52 <quicksilver> and dynamic-link-time is what I meant, yes.
03:26:58 <quicksilver> in practice, anyway.
03:27:16 <lilac> it solves the templates-instantiated-multiple-times issue
03:27:20 <quicksilver> it's not an easy solution, but it's the "right" solution.
03:27:35 <quicksilver> otherwise a template library isn't a library, in the normal sense.
03:28:03 <quicksilver> it's a set of textual expansion macros dressed up in an ill-fitting pantomime library costume.
03:28:14 <lilac> dynamic-link-time codegen is not, and cannot, be the right solution for commercial apps (well, depending on what you mean --i have no objection to link-time jit, llvm-style)
03:28:33 <lilac> or rather, link-time compilation
03:28:58 <lilac> and i mean closed-source rather than commercial, too, i guess
03:29:10 <lilac> man, real-time conversations are hard :-)
03:29:34 <quicksilver> I'm not sure I follow the closed-source inference.
03:29:48 <lilac> well, dynamic-link-time compilation plus closed source creates problems
03:29:54 <quicksilver> it means your library comes bundled with some intermediate representation which can be further optimised / compiled
03:30:09 <quicksilver> that's not particularly different from java code being distributed as bytecode
03:30:16 <quicksilver> and that doesn't seem to stop closed-source java.
03:30:19 <lilac> as i said, link-time jit is fine
03:30:21 <wli> Applicative higher-order functors have C++ template instantiation -like problems.
03:30:38 <lilac> however, link-time template instatiation is not fine
03:30:42 <quicksilver> why not?
03:31:16 <lilac> because it requires closed source, dynamic-linked apps to ship with essentially the source code for their templates
03:31:36 <quicksilver> it requires them to ship with some kind of intermediate rep which contains enough information for the instantiator, yes.
03:31:49 <quicksilver> something like a parametric representation which can be specialised + optimised.
03:32:08 <quicksilver> as I say I don't think that's qualitatively different from java bytecode - java bytecode is really quite close to a source format.
03:32:42 <ManateeLazyCat> Hi, all. I wrote `case' sentence, "case condition of", and `condition' have four possible value, `A' `B' `C' `D', and i want make `A' with `B' as a group, `C' with `D' as a group, how to write `condition'? Thanks!
03:32:43 <lilac> c++' templates are such that anything which is dependent on a templated type or value can't be represented much different from a parse tree
03:32:52 <quicksilver> If they really cared, closed-source apps could statically link.
03:32:57 <quicksilver> that might make sense for them anyway.
03:33:12 <lilac> ManateeLazyCat: case condition of A -> ab; B -> ab; C -> cd; D -> cd where ab = ...; cd = ...
03:33:13 <quicksilver> or maybe we jsut conclude closed-source apps should not be written in C++.
03:33:14 * quicksilver shrugs
03:33:50 <lilac> quicksilver: well, on linux, statically linking is pretty much the only option unless you want to distribute twenty different binaries
03:34:02 <quicksilver> the current status quo is that closed source libraries have to supply full source to the templatey parts anyway
03:34:08 <quicksilver> so I don't really think my proposal makes things worse.
03:34:13 <ManateeLazyCat> lilac: I want to write like "case condition of A, B -> ab; C, D -> cd".
03:34:23 <quicksilver> it just ships the source to the end user and not only the licensed developer
03:34:24 <quicksilver> who cares?
03:34:35 <wli> FP term lang affairs can mostly box and tag, but functors (analogues of functions for higher-order modules) may be difficult to import from closed source anything.
03:34:37 <ManateeLazyCat> lilac: I want to know correct syntax
03:34:48 <quicksilver> ManateeLazyCat: he gave you the correct syntax.
03:34:50 <wjt> ManateeLazyCat: you can't
03:34:58 <wjt> ManateeLazyCat: you can write what lilac said
03:34:58 <lilac> quicksilver: what about closed source apps which ship as some dynamic libs plus an app?
03:35:00 <quicksilver> ManateeLazyCat: there is no way to combine case conditions, lilac showed you what do to.
03:35:19 <quicksilver> lilac: if they are there own libs, they can link them in statically.
03:35:23 <quicksilver> lilac: *shrug*
03:35:32 <wli> Actually, let's boil it down to ML functors vs. closed source shared libraries.
03:35:46 <mmorrow> the fact that dynamic libs happen to support a closed source business model is coincidence in my pov. and i don't see that as any reason to artificially impede progress
03:35:50 <quicksilver> lilac: I'm not interested in continuing this part of the conversation. I'm very interested in compilation techniques, and utterly uninterested in the problems of closed source busines models.
03:35:59 <quicksilver> they can go cry a river.
03:35:59 <ManateeLazyCat> quicksilver: So if condition `A' and `B' will get same result, i need write those conditions twice, and can't combine those conditions?
03:36:04 <mmorrow> seconded.
03:36:33 <wli> ML functors vs. dynamic linking, then.
03:36:36 <quicksilver> ManateeLazyCat: lilac showed you the best you can do. You can name the expressiosn and put them in a where clause.
03:36:58 <wli> (I don't care much about closed source either.)
03:37:05 <wjt> ManateeLazyCat: or you could write isAB :: YourType -> Bool; isAB A = True; isAB B = True; isAB _ = False
03:37:06 <ManateeLazyCat> Thanks all.
03:37:14 <quicksilver> frankly piracy is absolutely rife anyway, and I seriously doubt this would make things any worse. People who really want to use the source illegally surely can.
03:37:23 <wjt> ManateeLazyCat: case () of () | isAB cond -> foo | otherwise -> bar
03:37:54 <lilac> quicksilver: it depends on your industry. in any case, fixing c++ is somewhat off-topic for here... :)
03:37:58 <wli> quicksilver: Frankly, I suspect with sufficiently arcane build constraints the source might be harder for people to pirate than binaries.
03:38:05 <quicksilver> wli: ;)
03:38:22 <quicksilver> lilac: sure, but module systems and separate compilation and polymorphism aren't, I don't think.
03:38:31 <ManateeLazyCat> wjt: Yep, but i need write another function to support it, i think it's better if Haskell `case' sentence can support condition combine .
03:38:45 <wli> quicksilver: ML functors vs. dynamic linking
03:38:58 <lilac> quicksilver: true :) what we can learn is that c++-style polymorphism-via-code-generation has /issues/ :)
03:39:23 <wjt> ManateeLazyCat: i'm sure the GHC maintainers look forward to your extension and its implementation :)
03:39:39 <wli> lilac: Unboxed-only parametric polymorphism.
03:39:48 <quicksilver> ManateeLazyCat: I made the proposal to SPJ once.
03:39:55 <lilac> ManateeLazyCat: imagine if it could, and your constructors took arguments. what would happen?
03:39:58 <quicksilver> ManateeLazyCat: he couldn't see why not but it doesn't seem to come up very often.
03:40:20 <quicksilver> lilac: you'd only be allowed to do it if you used the same names in each combined alt and they took the same types.
03:40:40 <quicksilver> my proposed syntax was
03:40:49 <quicksilver> case foo of A | B -> bar ; C | D -> baz;
03:40:58 <quicksilver> but it clashed with guards :)
03:41:05 <wjt> quicksilver: ; maybe?
03:41:12 <quicksilver> yeah, that's probably better
03:41:16 <quicksilver> or -> ;
03:41:28 <quicksilver> case foo of A -> ; B -> bar; C ->; D -> baz;
03:41:30 <ManateeLazyCat> quicksilver: I write A | B for test, but failed.
03:41:37 <lilac> case foo of Leaf x, Branch _ x _ -> x
03:42:17 <lilac> top-level comma seems unambiguous
03:42:28 <ManateeLazyCat> quicksilver: What is SPJ?
03:42:34 <lilac> ManateeLazyCat: Simon Peyton-JOnes
03:42:36 <wjt> ManateeLazyCat: a lean, mean, compiling machine
03:42:39 <wli> You can split up modules into static (code) vs. dynamic (updateable preinitialized heap) components, use boxing for any types depending on functors' parameters, and everything else I can't think of.
03:42:57 <wjt> ManateeLazyCat: originally invented at the University of Glasgow
03:43:07 <quicksilver> ManateeLazyCat: SPJ is the primary author of GHC.
03:43:19 <ManateeLazyCat> I see.
03:43:26 <wjt> ManateeLazyCat: but he was too smart and escaped, and now lives in a secret moon base
03:44:11 <lilac> wjt: if only this had come up yesterday
03:44:24 <wjt> lilac: you were on the moon yesterday, and could have hung out?
03:44:59 <wli> I don't believe there's anything really impeding ML functors vs. dynamic linking.
03:45:31 <mmorrow> wli: me neither
03:46:03 <wli> I think you could get in trouble trying to mutually recurse modules across dynamic linking boundaries.
03:46:34 <mmorrow> i don't think it'd necessarily be problematic
03:46:54 <wli> I was about to say, "Except I can't actually come up with what the problem would be."
03:47:06 <mmorrow> heh
03:47:32 <ManateeLazyCat> Thanks all for describe. :) brb
03:49:44 <wli> Now I just have no idea how module system typing rules need to be extended for (mutually) recursive modules.
03:50:08 <mmorrow> wli: ahh, i don't know how i forgot about this one: http://ttic.uchicago.edu/~blume/papers/cm-TOPLAS.pdf
03:53:00 <wli> I think the "process as much as possible in isolation" phase gets a lot of mileage.
03:55:50 <ketil> 2tell
03:55:51 <wli> For instance, even without a full parse, you can pluck out which identifiers need to be uniquely resolved from imports, propagate constraints between fully-parsed subexpressions' types, etc.
03:55:51 <lambdabot> ketil: You have 3 new messages. '/msg lambdabot @messages' to read them.
03:55:54 <ketil> @tell
03:55:55 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
03:56:13 <ketil> @tell lambdabot What was that I read on the mailing list about partial functions?
03:56:15 <lambdabot> Nice try ;)
03:56:15 <bremner> haha
03:56:51 <ketil> And I've read those messages repeatedly over the past few months.  Sigh.
03:56:55 <bremner> empty list=the SIGSEGV of FP
03:56:59 <ketil> Heh.
03:57:49 <ketil> @tell bos Is there an easy way to count the 1-bits in a Bloom filter?  I want to calculate the a posteriori (or rather: post construction) false positive probability.
03:57:50 <lambdabot> Consider it noted.
03:57:59 <ketil> Consider it considered.
03:58:20 <ivanm> ketil: are you the one that did the koala-SPJ april fools joke?
03:58:32 <ketil> ivanm, ah, er, who wants to know?
03:58:42 <ketil> i.e. - yes.
03:58:48 <ivanm> just wondering why you chose a koala, that's all
03:59:11 * ivanm /= SPJ, if that's what you're worried about
03:59:13 <ketil> No particular reason, except SPJs face fit rather well, and it was at hand.
03:59:43 <ketil> hehe.
03:59:57 <ivanm> heh
04:00:11 <ketil> You know, I installed GHC 6.10.2, and suddenly none of my code compiles!  Coincidence?  I think not.
04:00:25 <ivanm> ketil: heh
04:00:48 * bremner commences the kvetching about debian unstable not upgrading yet after almost 24H :-)
04:01:30 <Hunner> that is why I went with arch
04:01:37 <Hunner> updated updates
04:02:04 <ivanm> eh, gentoo has an ebuild, I'm just waiting for kolmodin to apply the libedit patches so I can bootstrap and create an x86 binary
04:03:01 * bremner thinks that wli's experience is enough to put anyone off gentoo :-)
04:03:18 <bremner> anyway, I left FreeBSD because I was bored of compiling things
04:03:46 * ivanm hasn't had any problems with gentoo that weren't his own fault
04:03:50 <bremner> anyway, peace love and harmony, to each their own tradeoff
04:03:58 <wli> I'm waiting for specific confirmation that the gentoo ebuild's ghci repl has readline support before getting anywhere near 6.10.2
04:04:31 <bremner> wli: did you ever try rlwrapper?
04:05:23 <wli> eix rlwrapper turns up nothing.
04:05:23 <ivanm> wli: 6.10.1 does AFAIK...
04:05:34 <ivanm> but kolmodin hasn't applied the patches to .2 yet
04:06:04 <wli> ivanm: When I installed 6.10.1 ghci did not have it and I had to downgrade back to 6.8.3 in a panic.
04:06:07 <bremner> err sorry, is called "rlwrap"
04:06:12 <ivanm> wli: it does now
04:06:22 <ivanm> it uses readline
04:06:54 <wli> I'll check.
04:07:51 <bremner> wli: upstream is http://utopia.knoware.nl/~hlub/uck/rlwrap/, although it sounds no longer relevant
04:11:22 <raxas_> wli: eix rlwrap -> app-misc/rlwrap Available versions:  (~)0.21 0.24 (~)0.30
04:13:17 <ivanm> raxas_: I don't think it's used anywhere for haskell packages...
04:13:49 <bremner> ivanm: rlwrap -a ghci
04:14:03 <ivanm> for libedit stuff?
04:14:09 <ivanm> we don't use libedit anymore anyway
04:14:22 <ivanm> we haz leet patches!
04:14:23 <ivanm> ;-)
04:14:31 <bremner> we = ?
04:14:41 <ivanm> gentoo-haskell
04:15:02 <bremner> yah see, sometimes there are solutions to problems that don't involve recompiling ghc :-)
04:15:19 <bremner> even on gentoo... :-)
04:15:27 <ivanm> bremner: well, the reason we have the patches is because libedit isn't stable
04:15:39 <ivanm> so for distribution purposes, we don't want to use it
04:15:53 <Jeil> hi everybody
04:15:58 <bremner> ivanm: ah so.
04:16:30 <blackh> Jeil: Hello!
04:16:50 <Jeil> can anybody lend me a hand with an issue related to handle binary files in C?
04:17:28 <wli> ivanm: in mainline gentoo or the Haskell overlay?
04:17:32 <ivanm> wli: overlay
04:17:38 <ivanm> 6.10 isn't in the tree yet
04:17:46 <ivanm> Jeil: ummm.... this isn't ##C ...
04:17:49 <wli> okay good I've got the overlay stuff
04:18:27 <Jeil> sorry im looking for a proper chat channel and I thought this was a proper one
04:18:35 <ivanm> not for C it isn't
04:18:54 <Jeil> sorry
04:19:17 <quicksilver> :( we're not "proper"
04:19:32 <ivanm> \o/
04:19:34 <ivanm> ;-)
04:19:51 * ivanm guesses English isn't Jeil's native tongue
04:20:13 <blackh> My guess is Jeil was a mythical creature that lives under a bridge.
04:20:53 <quicksilver> nah, he was a very non-mythical creature who wanted someone else to do his class assignment for him.
04:21:14 <ivanm> quicksilver: heh
04:21:21 <quicksilver> that's what "IRC" means to the youth of today - other people who will do my work for me.
04:21:26 <quicksilver> ;)
04:21:28 <ivanm> blackh: what, and I was the biggest billy goat? :s
04:21:40 <ivanm> quicksilver: oh, I thought that was what "forums" were for...
04:21:47 <blackh> ivanm: You had Jeil flying for miles.
04:22:07 * ivanm slaps his forehead, after considering all the time he's wasted trying to get people on forums to do his assignment for him
04:22:20 <blackh> My favourite word is "research" (meaning "looking it up on Wikipedia")
04:23:19 <wli> The 6.10.1 ebuild has no mention of readline.
04:24:04 <wli> All I see is libedit there.
04:25:40 <wli> Okay, scratch that.
04:25:43 <ivanm> wli: doesn't here...
04:25:44 <ivanm> heh
04:25:44 <wli>                 # Here we disable using readline in ghci, for two reasons:
04:25:49 <ivanm> :o
04:25:52 <ivanm> this is the overlay? :o
04:25:57 <wli> yeah
04:26:41 <ivanm> wli: line 174 for me has "# use sys-libs/readline instead of dev-libs/editline"
04:28:09 <ivanm> wli: that's the only mention of editline here...
04:29:38 <wli> Trying to install it...
04:32:05 <wli> Weird, it's doing some weird junk downloading a binary-only thing for ebuild digest
04:32:19 <ivanm> wli: why are you digesting? :s
04:32:43 <wli> To undo some editing I did to the ebuild file.
04:33:42 <ivanm> wli: you shouldn't be editing anything in the actual haskell overlay; you should make your own!
04:34:38 <wli> When I figure out how to do it right I will.
04:34:58 <ivanm> wli: try "darcs whatsnew" in the overlay... you shouldn't have anything...
04:38:26 <sheyll> Hi, just a quick question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3208#a3208
04:38:37 <sheyll> how do I specify an Arrow instance?
04:38:46 <sheyll> what am I missing here>
04:38:53 <quicksilver> sheyll: arrow has two parameters
04:39:22 <sheyll> so how would the instance df. look like?
04:39:35 <quicksilver> instance Arrow foo bar where ...
04:39:47 <EvilTerran> instances of Component have kind *; instances of Arrow have kind * -> * -> *, so they're not compatible
04:40:00 <quicksilver> that's what "arrow has two parameters" is supposed to mean, yes :)
04:40:25 <EvilTerran> quicksilver, wouldn't that be "arrows have two parameters"?
04:40:44 <sheyll> EvilTerran: so I want that Component has an input and an output type where would I put these in the class def. ?
04:40:49 <wli> Hmm. Something has broken. The layman sync's are going to /usr/local/portage/layman/ or some such and emerge is reading from /home/portage/
04:40:53 <ivanm> EvilTerran: there is only one Arrow class... >_>
04:40:56 <wli> (the latter is correct)
04:41:03 <doserj> quicksilver: instance Arrow foo bar is wrong. Arrow is a single-parameter type class
04:41:06 <ivanm> wli: layman always syncs there AFAIK
04:41:11 <ivanm> check the layman settings in make.conf
04:41:26 <quicksilver> doserj: oh gosh, you're right.
04:41:28 <quicksilver> what a fool I am.
04:41:38 <quicksilver> got my parameters all at the wrong levels.
04:41:44 <raxas_> wli: http://www.gentoo.org/proj/en/overlays/userguide.xml
04:41:48 <EvilTerran> ?src Arrow
04:41:49 <lambdabot> class Arrow a where
04:41:49 <lambdabot>     arr, pure   :: (b -> c) -> a b c
04:41:49 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
04:41:49 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
04:41:49 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
04:41:51 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
04:41:53 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
04:42:06 <quicksilver> sheyll: your 'Component' appears to be a type class over concrete types. "state" is expected to be an actual type.
04:42:13 <raxas_> wli: join the #gentoo-haskell, we tell you :)
04:42:21 <quicksilver> sheyll: 'Arrow' however, is a type class over binary type constructors.
04:42:32 <quicksilver> that is, things like "Either".
04:42:49 <sheyll> quicksilver: yes, state is supposed to be backed by 'data'
04:43:04 <quicksilver> that can't be an instance of Arrow then.
04:43:12 <quicksilver> things which are instances of arrow are binary type constructors.
04:43:13 <quicksilver> like
04:43:18 <EvilTerran> (->)
04:43:20 <wli> raxas: emerge may well be confused about far more than where layman's affairs belong
04:43:20 <quicksilver> data F a b = ......
04:43:25 <quicksilver> instance Arrow F where ....
04:43:47 <sheyll> hmmm
04:43:59 <blackh> That reminds me - I can't get my head around types like ((->) a).   What would be an example of a value of this type?
04:44:04 <sheyll> I see
04:44:15 <EvilTerran> blackh, that's not a type proper
04:44:22 * beelsebob wonders why arrow has so much in it
04:44:33 <beelsebob> theres things in there that can be built from other things
04:44:40 <sheyll> well thanks alot quicksilver and EvilTerran tou helped me. I know now how to get waht I want :)
04:44:46 <EvilTerran> blackh, its kind is * -> *, and only type expressions of kind * are actual types (ie can be the type of an expression)
04:44:50 <blackh> EvilTerran: Is Functor defined for ((->) a) or did I remember that wrong?
04:45:02 <wli> raxas: Something clobbered my make.conf's portage dirs (at least) without my noticing.
04:45:05 <quicksilver> blackh: sure. Functor is defined for Maybe as well.
04:45:11 <EvilTerran> ?type fmap
04:45:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:45:15 <quicksilver> blackh: you can't have a value of tpe Maybe, either.
04:45:23 <EvilTerran> "f" in that type isn't a type, it's a type constructor
04:45:34 <quicksilver> blackh: all the things Functor is defined for are type constructors wiating for one more parameter.
04:45:46 <EvilTerran> if f = ((->) e), you get "fmap :: (a -> b) -> ((->) e) a -> ((->) e) b"
04:45:47 <quicksilver> e.g. Maybe, ((->)a), [], and so on.
04:46:01 <EvilTerran> ie "fmap :: (a -> b) -> (e -> a) -> (e -> b)"
04:46:16 <blackh> EvilTerran, quicksilver: Thanks - That did the trick - I understand now!
04:47:01 <EvilTerran> :)
04:55:19 <rajazz> malcolmw: hi!
04:55:37 <ivanm> wli: any luck?
04:56:27 <malcolmw> rajazz: hello
04:57:12 <rajazz> nice morning today in Argentina... perfect temperature
04:57:59 <vixey> Severely resource-constrained devices present a confounding challenge to the functional programmer: we are used to having powerful abstraction facilities at our fingertips, but how can we make use of these tools on a device with an 8- or 16-bit CPU and at most tens of kilobytes of RAM? Motivated by this challenge, we have developed Flask, a domain specific language embedded in Haskell that brings the power of functional programming to sensor networks, coll
04:57:59 <vixey> ections of highly resource-constrained devices
04:59:45 <Raevel> Pretty much every function in my program takes a parameter of the same type, I'm thinking I should use a state monad... ?:-)
04:59:54 <wli> ivanm: My portage dirs are really screwed up; something clobbered my configs.
05:00:14 <ivanm> it's times like these you wished you bothered to make backups...
05:00:15 <quicksilver> Raevel: or just the reader monad. In general do they return modified versions of that parameter?
05:00:24 <wli> ivanm: I think I'm just now getting started.
05:00:25 <Raevel> quicksilver: they modify it, yes
05:00:36 * quicksilver nods
05:00:40 <quicksilver> then yes, that's what the state monad is for.
05:00:49 <Raevel> awesome
05:00:53 <quicksilver> it helps you thread the modified versions back in
05:01:03 <quicksilver> and not accidentally confuse new_s and old_s and use the wrong version
05:02:44 <rajazz> funny
05:03:22 <wli> ebuild manifest checking vs. darcs backups
05:05:32 <wli> It seems to be compiling.
05:07:30 <mmorrow> heh, the libffi pkg on hackage is neat. here's getting syscall via dlsym, then using that to call execve and replace ghci with /bin/sh: http://moonpatio.com/fastcgi/hpaste.fcgi/save
05:07:36 <mmorrow> oops
05:07:41 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2029#a2029
05:08:06 <mmorrow> (all in ghci too)
05:09:06 <mmorrow> ghci is teh best C repl yet!
05:09:25 <ivanm> heh
05:10:36 <wli> I didn't know you could do <- at the repl
05:11:09 <bremner> wli: isn't that the same reason you need let?
05:11:25 <mmorrow> wli: :o
05:11:27 <wli> sure
05:11:44 <raxas> mmorrow: nice one. worth archiving :)
05:11:55 <mmorrow> raxas: :)
05:12:45 <ttmrichter> Am I permitted to express some suspicion at the timing of GHC 6.10.2's release?  ;)
05:13:04 <wli> Now we just need data, type, newtype, class, and instance decls at the repl. ;)
05:13:37 <bremner> ttmrichter: you sound like you think there is some sort of evil cabal controlling haskell...
05:14:15 <rajazz> yes, it's a daemon
05:15:35 <vixey> {x=4} x := x + 1 {x=5}
05:15:55 <dcoutts> no no, there is no Haskell Cabal
05:16:05 <ivanm> dcoutts: :o
05:16:12 <dcoutts> that's the first rule! everyone knows that
05:16:18 <ivanm> so what's that think you apparently keep hacking on then?
05:16:36 <ivanm> also, what's the second rule then?
05:16:56 <dcoutts> ivanm: if you payed attention to the first rule you would not ask that question
05:16:59 <quicksilver> hacking? dcoutts can't even type, let alone produce a shadowy piece of software with non-specified political aims.
05:17:07 <ivanm> quicksilver: heh
05:17:12 * dcoutts grins
05:17:19 <ttmrichter> Not Haskell.  Just GHC....
05:17:22 <ivanm> quicksilver: so that explains why he hasn't finished his thesis yet?
05:17:28 <ttmrichter> Hmmm...  This looks legit.  Nice!
05:17:36 <ivanm> ttmrichter: you do know the meaning of "Cabal", don't you?
05:18:16 <dcoutts> ttmrichter: it's fun to announce real things on April 1st :-)
05:18:20 <jacobian> Is there a way to get a type synonym that is rigid in the sense that the typing of a term ascribed with this type is checked nominally?
05:18:30 <jacobian> i.e. You have a term t::Foo and t'::Bar   where Foo = String and Bar = String, but f :: Foo -> Bar  will not take arguments in the reverse order.
05:18:35 <vixey> why is this called Java monad:  T A = (S -> (A * S + E * S + 1))  ?
05:18:54 <ttmrichter> "Yes, ivanm, I know what Cabal is.
05:19:07 <ivanm> dcoutts: like gmail? ;-)
05:19:10 <quicksilver> jacobian: yes, newtype.
05:19:18 <quicksilver> jacobian: (or alternatively, "no").
05:19:25 <quicksilver> jacobian: it's a question of perspective.
05:19:38 <ivanm> quicksilver: well, no-one can say you haven't covered all the options!
05:19:38 <vixey> I get it
05:19:49 <ivanm> vixey: I don't
05:20:18 <ttmrichter> dcoutts: Yes, it is fun to announce real things on April 1st.  Because of suspicious people like me.  :D
05:20:39 <dcoutts> ivanm: looks line an answer and new state, or an exception and new state, not sure what the +1 is
05:21:12 <ivanm> but why "Java"?
05:21:28 <dcoutts> ivanm: because it models the semantics of evaluating Java
05:21:43 <quicksilver> the 1 might be non-termination
05:22:04 <dcoutts> quicksilver: aye
05:22:37 <ivanm> dcoutts: ahhh
05:22:42 <vixey> what's a CPO-monad
05:22:43 <vixey> ?
05:22:54 <ivanm> dcoutts: so since you're actually here, does this mean your thesis is finished? ;-)
05:23:21 <dcoutts> ivanm: I'm not here
05:23:42 <ivanm> ahhh
05:24:42 <rajazz>  what's CPO-monad??
05:24:57 <vixey> rajazz: I agree
05:25:27 <luqui> vixey, good question!
05:25:43 <ivanm> vixey: is that monad name missing a 3? :p
05:25:49 <ivanm> @wn CPO
05:25:53 <lambdabot> No match for "CPO".
05:26:03 <luqui> * complete pointed ordering
05:26:07 <luqui> i assume
05:26:17 <dcoutts> complete partial order
05:26:28 <vixey> is that teh same as a partial order with all lubs and glbs?
05:26:34 <luqui> i know pointed comes up in one of those acronyms...
05:26:34 <dcoutts> it's the domain theory stuff
05:27:01 <dcoutts> http://en.wikipedia.org/wiki/Complete_partial_order
05:27:50 <dcoutts> it's a good semantic basis to explain non-strictness
05:27:53 <luqui> is it the _|_-lifting monad?
05:28:14 <luqui> i know what a cpo is... where's the monad?
05:28:40 * mmorrow likes to pretend it's "Canaries, Pancakes, and Orangutangs"
05:28:45 <ivanm> luqui: in hiding?
05:30:11 <quicksilver> luqui: the partiality monad perhaps?
05:30:30 <luqui> quicksilver, yeah, that's my guess, but that only adds one _|_
05:30:36 <wli> How do I unbind an identifier in the ghci repl?
05:31:00 <luqui> so calling it a cpo is overadvertizing a little...
05:31:38 <luqui> but i don't know the context.  vixey said "cpo monad" and my interest was piqued
05:32:00 <mmorrow> wli: you can't, but you can rebind..
05:32:04 <vixey> =Examples: State and recursion TX = (S × X)S ⊥ (where S = ωL discrete cpo of states)
05:32:24 <vixey> that should be
05:32:30 <vixey> TX = (S × X)^S_⊥
05:32:41 <quicksilver> yes
05:32:43 <vixey> S = ω^L
05:32:58 <quicksilver> s->(x,s)
05:33:04 <quicksilver> in our notation.
05:33:14 <wli> mmorrow: It throws warnings whenever shadowed, and s hence quite aggravating.
05:33:38 <wli> It's why I never use bindings at the prompt.
05:33:54 <luqui> vixey, where's that _|_?  subscript of S, or subscript of the whole thing?
05:34:09 <vixey> subscript of the whole thing
05:34:30 <luqui> hmm... that's strict recursion only i think
05:35:00 <luqui> oh nvm
05:35:10 <mmorrow> wli: it should only complain if you have two ident syms in two different loaded modules
05:35:12 <luqui> that monad isn't encoding fixpoints, just allowing them
05:35:17 <mmorrow> ident(ical)
05:36:05 <mmorrow> wli: i can't wait until someone gets fed up and adds the ability to import/load stuff qualified/hiding/as etc
05:36:10 <wli> mmorrow: let foo s = ... gets shadowed by the s <- getArgs
05:36:28 <mmorrow> it shouldn't
05:36:31 <wli> or vice-versa
05:36:39 <agruman> is there any map function that can be applied to monadic functions? i have "f :: a -> m b" and want apply this to [a] and then get [b] instead of [m b] .. which would then need a concat to become "b" in the end, is this doable?
05:36:48 <mmorrow> wli: wait, what are you saying?
05:36:51 <wli> s <- getArgs has its s shadowed by the s in the arg of let foo s = ...
05:37:09 <mmorrow> where is "s <- getArgs" ?
05:37:13 <wli> Then because I always run with -Wall set I get pages of warnings.
05:37:20 <wli> mmorrow: top-level at the ghci prompt
05:37:21 <vixey> agruman: [m b] -> m [b]
05:37:40 <Raevel> @src evalState
05:37:41 <lambdabot> Source not found. There are some things that I just don't know.
05:37:49 <quicksilver> agruman: mapM
05:37:54 <mmorrow> wli: ohhhh, i see what you're saying. yeah, i guess that's no diff than if you were coding it..
05:38:05 <quicksilver> I don't find -Wall useful.
05:38:07 <agruman> vixey thanks!
05:38:13 <wli> I can't unbind the s <- getArgs
05:38:20 <quicksilver> I would find it doubleplusunuseful in ghci
05:38:32 <wli> So top-level bindings at the ghci prompt are doorstops.
05:38:33 <mmorrow> wli: i love how you can do "open MyStructure" in the middle of a "let" in SML
05:38:50 <wli> mmorrow: Yeah, I miss that, too.
05:38:51 <agruman> quicksilver thanks alot
05:39:04 <quicksilver> agruman: it's not entirely what you asked for
05:39:08 <quicksilver> you'll get m [b]
05:39:12 <quicksilver> but that is actually what you want :)
05:39:18 <quicksilver> just not what you thought you wanted.
05:40:06 <agruman> quicksilver, k
05:40:44 <wli> I use -Wall -Werror when compiling with ghc, so I test exprs for warnings in ghci before putting them in a file.
05:40:55 <agruman> quicksilver, well since its still in the monad i see the need for m [b] :)
05:40:59 <quicksilver> ;)
05:44:05 <wli> mmorrow: There's no reason not to allow localized module futzing (e.g. define modules local to some scope, then pass them to a functor you import, etc.) at all. It's just stupidity not to.
05:45:37 <quicksilver> wli: although there's also no point in doing so until there are useful things you can do with them.
05:45:44 <mmorrow> wli: i agree
05:45:46 <quicksilver> I occasionally wish haskell had local data types though.
05:45:59 <wli> mmorrow: The only nasty is when passing term arguments to functors.
05:46:10 <wli> quicksilver: Yeah, that too.
05:46:54 <mmorrow> quicksilver: (let open Foreign(Storable(peek)); f x = .. peek .. in \y -> ... f)
05:47:18 <luqui> the distinction between the top level and let/where clauses is one that i don't think belongs
05:47:23 <lilac> wli: how's your module system going?
05:47:23 <quicksilver> mmorrow: yes, definitely, I was talking about actual module definition.
05:47:31 <mmorrow> quicksilver: i wish for local datatypes *every day*
05:47:33 <Philonous> Is it advisable to use my own data types even when the standard types would do? Or doesn't it matter?
05:47:35 <quicksilver> mmorrow: local namespace futzing would indeed be useful.
05:47:45 <quicksilver> Philonous: it's often advisable to use the standard ones
05:47:46 <luqui> sigma types!
05:47:52 <mmorrow> quicksilver: ohh. hmm, i've never though about local module defs.
05:47:56 <quicksilver> Philonous: so you can take advantage of library functons and class instances.
05:48:27 <mmorrow> it wouild be extremely interesting if modules were first class
05:48:36 <wli> No, not first class.
05:48:42 <mmorrow> why not?
05:49:15 <wli> It's a different notion from local module defs within terms.
05:49:36 <mmorrow> sure
05:50:00 <mmorrow> luqui: sigma types fail at mutual recursion though (?)
05:50:02 <quicksilver> I wonder what exactly mmorrow means by first-class though.
05:50:03 <wli> Maybe you want it, maybe you don't, but it's a different issue.
05:50:17 <quicksilver> presumably not the ability to pass a module to a function?
05:50:17 <luqui> mmorrow, so does ghc ;-)
05:50:18 <Philonous> quicksilver: I see. Custom data types would add to readability, though
05:50:25 <quicksilver> Philonous: you can use type synonyms for that.
05:50:34 <wli> quicksilver: That's first class modules AIUI.
05:50:59 <quicksilver> I suppose it is a natural step after local modules in terms
05:51:08 <quicksilver> if you can have local modules in terms, why not pass them from term to term :P
05:51:11 <quicksilver> but is it useful?
05:51:14 <mmorrow> quicksilver: yeah. so i'm thinking of     data Foo a = Foo {type Asdf b = Either a b; x :: Int = 42; f = (id :: (a,b) -> (a,b))}
05:51:29 <luqui> quicksilver, yes!
05:51:49 <mmorrow> luqui: hehe, yes that's true
05:51:55 <luqui> it's just damn close to dependent types, so your proof machinery needs to step it up a notch to be supported
05:52:25 <vixey> what does  sigma types fail at mutual recursion though  mean?
05:52:40 <wli> There's already a lot of machinery to add just for local modules to be able to capture local term variables.
05:52:41 <mmorrow> quicksilver: (that "yeah" wasn't in response to "but is it useful", but i think that yes it'd be)
05:53:21 <wli> How do sigma types fail at mutual recursion?
05:53:40 <vixey> I think "local datatypes" is a red herring -- what you really would use is modules
05:53:51 <mmorrow> vixey:  imagine a n-sigma type like {a,b,c,d,e,f}. (e.g.) b can't depend on f
05:54:15 <vixey> I don't know what that is
05:54:18 <vixey> is that a type?
05:54:19 <wli> mmorrow: I don't see why that's the case.
05:54:20 <mmorrow> so it's a sequence of "let"s, rather that a letrec
05:54:36 <luqui> mmorrow, though i think that is pretty easy to get around.  the hard one is that b's *type* can't depend on f... but... who cares?
05:54:41 <luqui> who cares in Haskell, i mean.
05:54:46 <vixey> well that's easy to fix!
05:55:04 <luqui> vixey, no pun intended?  ;-)
05:55:21 <mmorrow> wli: i thought that that's the case by definition
05:55:22 <vixey> I only said that /because/ of the pun
05:55:26 <wli> vixey: It's only doing whatever you can do inside a scope inside scopes within term expressions.
05:55:42 <quicksilver> vixey: why do you think local datatypes is a red herring? I've often wants an "enum-style" ADT just locally to one function.
05:55:59 <luqui> i think nonlocal anything is a red herring
05:56:11 <vixey> quicksilver: I think you can have local everything by proper module setup
05:56:18 <luqui> but i think i might know what vixey is saying
05:56:43 <luqui> with proper existential types, you can capture a whole bunch of good stuff
05:56:50 <mmorrow> vixey: but following that line of reasoning, there's no reason to allow local functions
05:57:03 <luqui> including newtypes
05:57:12 <vixey> yeah it would be nice if let and where were subsumed by it too
05:57:15 <luqui> (which makes me exicted, because i always thought they were kind of kludgey)
05:58:00 <luqui> although you still need some mechanism for iso-recursion, i guess
05:58:09 * mmorrow wants iso-recursion
05:58:18 <vixey> oh multiple newtypes would just be separate instantiations of a module that holds a datatype then?
05:58:28 <luqui> well the typical existential type encoding of newtypes would give you equi-recursion, which is a bitch for compilers.
05:58:41 <mmorrow> err, i meant equi-recursion
05:58:49 * mmorrow want equi-recursion
05:58:58 <luqui> yeah that'd be nice
05:59:03 <luqui> stupid theorists, ruining our fun!
05:59:13 <wli> I've seen this stuff mentioned but not understood it.
05:59:20 <mmorrow> i think they're just using the wrong theory ;)
05:59:44 <quicksilver> stupid funsters, ruining our theory!
05:59:54 <luqui> wli, iso-recursion is like a recursive type in a newtype: wrapped in constructors.  equi-recursion has no constructors, like  type Foo = Int -> Foo
06:00:22 <vixey> what's so bad about constructors?
06:00:39 <wli> I know what equi vs. iso recursion is, just not how it's pertinent to modules.
06:00:42 <luqui> they're just not very pretty.
06:00:53 <luqui> very important reason, I know
06:01:12 <luqui> wli, you can use an existential type to simulate "newtype" style hiding
06:01:53 <vixey> this is so smooth math.andrej.com/data/est.pdf
06:02:03 <luqui> but the recursion wouldn't be hidden...
06:02:44 <luqui> if you know what i mean
06:02:58 <wli> This does not sound pertinent to the module system -related discussion of iso- vs. equi- recursion.
06:03:00 <mmorrow> vixey: interesting link
06:03:14 <vixey> hey luqui, how is your lang/os/whatever that is .. going?: )
06:03:31 <vixey> are you adding extistential types to it :p
06:03:43 <luqui> vixey, not adding so much as proving that they're already  there...
06:03:59 <luqui> vixey, i'm narrowed in on a nice core logic
06:04:08 <vixey> do you have your core theory written down in one place? (not source code)
06:04:40 <luqui> It's mostly IXi from the illative combinatory logic paper
06:04:51 <luqui> rather, between IXi and I0
06:05:05 <luqui> and i'm doing constructions in it right now, to see how i'm going to encode things
06:06:01 <luqui> it's *really* hard not to become a logic researcher
06:06:06 <luqui> what a deep and complex field...
06:06:09 <vixey> luqui, does it have eta conversion?
06:06:12 <luqui> yeah
06:06:17 <vixey> yikes
06:06:23 <luqui> it doesn't have to
06:06:40 <luqui> but, it's not designed to be inferrable or anything
06:06:42 <vixey> I saw a combinatory version of MLTT and the conversion was weaker than the lambda-calculus presentation
06:06:54 <vixey> kinda guessed that was a theme about combinatory versions but maybe not
06:07:14 <luqui> well it's not really combinatory
06:07:23 <luqui> the logic is combinatory
06:07:31 <luqui> but the lambda calculus is just lambda calculus
06:07:32 <luqui> untyped
06:07:55 <luqui> that was the appeal of IXi to me... all functions are untyped by nature
06:08:01 <vixey> huh??
06:08:02 <luqui> and you prove that they have certain types externally
06:08:14 <vixey> weird...
06:08:37 <luqui> yeah it's different from what we're used to in the Martin Lof world
06:09:08 <luqui> but you can prove correctness of type erasure
06:09:09 <vixey> so I guess you can take as axiom   Y combinator has type (a -> a) -> a   and things like this?
06:09:11 <luqui> which is a big deal
06:09:28 <luqui> vixey, not quite sure what i'm going to do about partiality yet
06:09:40 <vixey> well I didn't mean about partiality actually
06:10:09 <vixey> just being able to take a lambda term and pretend it has a type (a valid type for it, just one you couldn't prove)
06:10:12 <luqui> oh.  the logic is consistent, so you're not going to get a Y combinator
06:11:06 <luqui> you better be able to prove it
06:11:13 <vixey> luqui: actually I'm wondering how you'd get pattern matching into the languag
06:11:17 <luqui> the ones you can't prove are in the land of whatever i do with partiality
06:11:24 <kohwj> umm.... how does one do rounding of to n decimal places? is there a function (round :: Double -> Integer -> [Char]) that does it?
06:11:28 <wli> I'm still kind of stumped about what (mutual) recursion in modules needs from the module type system.
06:11:34 <luqui> via church encoding?
06:11:42 <kohwj> or (round :: Double -> Integer -> Double)
06:11:49 <wli> kohwj: Numeric.showFFloat, Numeric.showGFloat, etc.
06:12:00 <vixey> luqui: like system F?
06:12:06 <quicksilver> kohwj: wli's answer if you want to go to string.
06:12:19 <luqui> vixey, ... probably.  i don't really know much about system F
06:12:28 <luqui> though I probably do, indirectly :-)
06:12:31 <quicksilver> kohwj: if you don't, then (/10^n).fromIntegral.round.(*10^n)
06:12:34 <luqui> just never studied it explicitly
06:12:39 <vixey> luqui: I was just thinking if you could add in computational axioms then you could get K or UIP or JMeq easily
06:12:48 <kohwj> quicksilver: wli: thanks :) this wasn't a very google-able question...
06:12:55 <vixey> luqui: which is why I asked about Y, but Y being partial totally derailed the trail
06:12:56 <luqui> vixey, _now_ I don't know what you are talking about
06:13:36 <quicksilver> hmm
06:13:38 <luqui> vixey, because of logical issues, i've got to have some sort of way of adding "axioms"
06:13:38 <quicksilver> :t showFFloat
06:13:40 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:13:58 <luqui> vixey, eg. i want to be able to embed it in a typesafe way in a UI, for example, but no consistent logic can embed itself
06:14:04 <quicksilver> no, it's not.
06:14:11 <luqui> vixey, so you have to add an axiom to do it...
06:14:22 <luqui> not sure how i'm going to do that yet.  more of a policy issue than a mathematical one.
06:14:29 <vixey> luqui: if you add axioms in Coq or agda they cannot compute -- that's good because lots of them would royally screw things up if they did. but some axioms you actually do want to compute
06:14:40 <Raevel> now i managed to get confused again :-), how do i write this w/o do notation? atFinalState' ds = do g <- get; return ((currentState g) `elem` (finalStates g))
06:14:52 <luqui> vixey, hmmm
06:15:02 <vixey> luqui: (specifically axiom K (or any of the others I mentioned) which lets you compiled away dependent pattern matching)
06:15:22 <luqui> vixey, cool!  i'll have to find out more about that
06:16:08 <lilac> @undo do g <- get; return ((currentState g) `elem` (finalStates g))
06:16:09 <lambdabot> get >>= \ g -> return ((currentState g) `elem` (finalStates g))
06:16:23 <Raevel> :-)
06:16:38 <Raevel> what happened to ds?
06:16:41 <lilac> @pl \g -> return ((currentState g) `elem` (finalStates g))
06:16:42 <lambdabot> return . liftM2 elem currentState finalStates
06:16:44 <vixey> luqui: I'm guessing you would program in some kind og higher level language like haskell/agda type thing and it would be compiled (and type checked and so on) into this core ..
06:16:48 <luqui> @. pl undo  do g <- get; return ((currentState g) `elem` (finalStates g))
06:16:49 <lambdabot> liftM2 elem currentState finalStates `fmap` get
06:16:50 <kohwj> quicksilver: read (Numeric.showFFloat (Just 2) 2.33423 "") :: Double          an alternative
06:16:51 <vixey> so that true ?
06:17:14 <luqui> vixey, yeah that's the plan
06:17:47 <lilac> @type (elem <$> ?currentState <*> ?finalStates) <$> get
06:17:48 <lambdabot> forall a a1 (f :: * -> *). (Functor f, MonadState a1 f, ?finalStates::a1 -> [a], ?currentState::a1 -> a, Eq a) => f Bool
06:17:54 <quicksilver> kohwj: sure, but about 8 million times slower.
06:18:18 <kohwj> quicksilver: yep
06:18:24 <lilac> @type elem <$> ?currentState <*> ?finalStates <$> get
06:18:25 <lambdabot> forall a a1 (f :: * -> *). (Functor f, MonadState a1 f, ?finalStates::a1 -> [a], ?currentState::a1 -> a, Eq a) => f Bool
06:18:29 <lilac> yay
06:18:52 <Raevel> :-o
06:19:04 <wli> @type flip (Numeric.showFFloat $ Just 2) ""
06:19:06 <lambdabot> forall a. (RealFloat a) => a -> String
06:20:26 <luqui> vixey, hmmm idea:  no axioms, just (possibly computational) assumptions.  then to run some code, you give it axioms.
06:20:47 <luqui> vixey, so the assumptions bubble up to the top
06:20:49 <lilac> Raevel: you didn't use ds, is what happened to it :) did you mean 'g'?
06:21:17 <vixey> luqui: do they just sort of float on the surface like scum ? :p
06:21:25 <luqui> lol
06:21:26 <Raevel> true! but i still wonder why i didn't use it
06:21:36 <luqui> in that you want as little of them there as possible, yes :-)
06:21:43 <vixey> luqui: if bad assumptions reduce you lose termination.. if good assumptions don't reduce lots of things don't typecheck.. it's really tricky
06:22:11 <luqui> vixey, you mean termination of typechecking?
06:23:01 <vixey> luqui: yes
06:23:02 <luqui> vixey, well, the core logic doesn't care; there's no decision procedure for typechecking at that level.  but surely that duality will pop up at higher levels.
06:23:26 <vixey> no decision procedure for *typechecking*?
06:23:34 <vixey> so what do you do with the core?
06:23:37 <luqui> it's just a sequent calculus.
06:23:42 <luqui> got to construct proof trees.
06:24:01 <luqui> the clients each do that in their own way
06:24:05 <vixey> but once you have a proof tree you have no idea if it's been put together properly?
06:24:15 <vixey> or you assume every proof tree is wel/ formed?
06:24:16 <luqui> vixey, oh you do
06:24:30 <mmorrow> vixey: check it!
06:24:34 <luqui> but... the usual terms-are-proofs thing doesn't hold
06:24:35 <ledzipelin> hello ^_^
06:25:00 <vixey> :S so how do you do reflection?
06:25:12 <luqui> but you manually fold and unfold assumptions
06:25:26 <luqui> vixey, you mean logical reflection / self-embedding?
06:25:51 <luqui> (where "you" is "a higher level compiler")
06:27:41 <ledzipelin> I'd like to build a list of every possible combination of say Bool of length n. My problem, I don't really see an "elegant" solution for that (i.e. bruteforce & verifying). Do you have any hints?
06:27:55 <ledzipelin> i.e. a list of lists
06:28:11 <luqui> > sequence (replicate 4 [True,False])
06:28:12 <lambdabot>   [[True,True,True,True],[True,True,True,False],[True,True,False,True],[True,...
06:28:17 <luqui> ;-)
06:28:30 <ledzipelin> this is unbelievable ^^
06:28:44 <ledzipelin> is it in prelude?
06:28:52 <luqui> yeah all that's in the prelude
06:28:56 <luqui> it's using the list monad
06:29:30 <luqui> list monad is perfect for encoding combinatorical problems, which this is
06:30:30 <luqui> ledzipelin, oh, btw, if you're generating very big lists of these, and you don't care about order, there is a way that has much better memory performance
06:32:34 <QtPlaty[HireMe]> :src sequence
06:32:39 <ledzipelin> luqui: blist 0 = [[]], blist n = map (\x -> True:x) (blist (n-1)) ++ map (\x -> False:x) (blist (n-1))
06:32:52 <ledzipelin> luqui: this  one should work too, but I don't see the logic behind it.
06:32:58 <QtPlaty[HireMe]> @src sequence
06:32:59 <lambdabot> sequence []     = return []
06:32:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:32:59 <lambdabot> --OR
06:32:59 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
06:33:10 <Gracenotes> GOODBYE WORLD
06:34:15 <luqui> ledzipelin, no?  generate blist (n-1), then stick True on the front of every element
06:34:17 <luqui> do the same for False
06:35:03 <luqui> (if you say let rest = blist (n-1) = ...  instead of repeating blist (n-1), you get aforementioned improved memory performance)
06:35:31 <ledzipelin> luqui, you mean like building a tree and then for every turn-to-left stick a True and for every turn-to-right stick a False and doing that for every way from the top to the bottom?
06:36:07 <luqui> ledzipelin, uhhhh... maybe.  that's not how i think of it.
06:36:41 <luqui> it's just inductive reasoning.  given that you have all the binary sequences of length n, how do you generate all the binary sequences of length n+1?
06:36:53 <luqui> just add True to the beginning of all of them, and add False to the beginning of all of them
06:38:08 <luqui> [0,0], [1,0], [0,1], [1,1]  -->  (adding 1) [1,0,0], [1,1,0], [1,0,1], [1,1,1]  (adding 0)  [0,0,0], [0,1,0], [0,0,1], [0,1,1]
06:43:17 <vixey> > let one = [0,1] in  [one,one,one]
06:43:17 <vixey> > let one = [0,1] in sequence [one,one,one]
06:43:17 <lambdabot>   [[0,1],[0,1],[0,1]]
06:43:17 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
06:43:17 <vixey> > let one = [Nothing,Just 1] in sequence [one,one,one]
06:43:17 <lambdabot>   [[Nothing,Nothing,Nothing],[Nothing,Nothing,Just 1],[Nothing,Just 1,Nothing...
06:43:17 <vixey> that wasn't what I wanted..
06:43:17 * quicksilver congratulates himself for reading an email about category theory in french.
06:43:17 <luqui> lol
06:47:26 <bremner> cue quote about "mathematicians are like Frenchmen..."
06:48:34 <ledzipelin> quicksilver: tres bien!
06:48:42 <quicksilver> merci mon ami.
06:50:32 <ledzipelin> luqui: hm ok
06:52:49 <mgee> hi
06:53:16 <mgee> is in all cases: head x = take 1 x ?
06:53:19 <bremner> Goethe: Mathematicians are [like] a sort of Frenchmen; if you talk to them, they translate it into their own language, and then it is immediately something quite different.
06:53:38 <ledzipelin> luqui: oh ok, so you did the same with sequence (replicate n [True,False]) basically?
06:54:15 <luqui> ledzipelin, oh.. um.  that is what it boils down to, but why is a bit abstract
06:54:42 <Saizan> > take 1 [] -- mgee
06:54:44 <lambdabot>   []
06:55:05 <bremner> @quote Goethe Mathematicians are [like] a sort of Frenchmen; if you talk to them, they translate it into their own language, and then it is immediately something quite different.
06:55:06 <lambdabot> No quotes for this person. My mind is going. I can feel it.
06:55:10 <ledzipelin> luqui, ah ok, so what would be the most intuitive way to solve it in haskell? with map?
06:55:16 <Saizan> mgee: the two expressions have different types, btw
06:55:18 <mgee> Saizan: ah ok, for head [] is would throw an error, i guess
06:55:27 <bremner> @remember Goethe Mathematicians are [like] a sort of Frenchmen; if you talk to them, they translate it into their own language, and then it is immediately something quite different.
06:55:27 <Saizan> > head []
06:55:28 <lambdabot> It is stored.
06:55:28 <luqui> well, exactly like that if your readers are familiar with the list monad
06:55:29 <lambdabot>   * Exception: Prelude.head: empty list
06:55:36 <mgee> Saizan: thanks
06:55:49 <luqui> ledzipelin, but, whichever way you understand it best, i guess :-)
06:56:07 <wli> YES!! I've got 6.10.1 with readline-enabled ghci
06:56:18 <EvilTerran> > head [] -- mgee
06:56:20 <lambdabot>   * Exception: Prelude.head: empty list
06:56:55 <mgee> and if i am sure that the list is not empty? then take 1 und head would be the same?
06:56:56 <vixey> obviousl [] should be banished from haskell
06:57:08 <doserj> mgee: they don't even have the same type
06:57:40 <luqui> > take 1 [1,2,3]
06:57:42 <bremner> vixey: no, but head should
06:57:42 <doserj> @type take 1
06:57:42 <lambdabot>   [1]
06:57:43 <luqui> > head [1,2,3]
06:57:43 <lambdabot> forall a. [a] -> [a]
06:57:44 <lambdabot>   1
06:57:57 <luqui> mind the brackets
06:57:58 <EvilTerran> ?? head :: (?type head); take 1 :: (?type take 1)
06:58:00 <lambdabot>  head :: forall a. [a] -> a; take 1 :: forall a. [a] -> [a]
06:58:17 <luqui> EvilTerran, what is this black magic!?
06:58:46 <mgee> mhh seems to be the same according to EvilTerran's code...
06:59:00 <mgee> ah no
06:59:01 <NameAlreadyInUse> who is "[QUOTE=Razalgrim;1000952]Yes, I do believe in God, and by no means are my two beliefs contradictory.[/QUOTE]
06:59:01 <NameAlreadyInUse> Theism has never been incompatible with science or evolution. It is the religious dogma that often accompanies it that is incompatible.
06:59:01 <NameAlreadyInUse> [QUOTE=Razalgrim;1000952]There are hundreds of races in this earth today, but the Bible says it all began with two people. How did that happen?[/QUOTE]
06:59:01 <NameAlreadyInUse> It didn't.
06:59:02 <mgee> right
06:59:02 <NameAlreadyInUse> Genetic analysis has ruled out the possibility of such a small population bottleneck in human history. Even if this wasn't the case, such a small population would rapidly succumb to the negative effects of prolonged inbreeding.
06:59:05 <NameAlreadyInUse> [QUOTE=Razalgrim;1000952]Evolution. Though it is still a theory[/QUOTE]
06:59:07 <NameAlreadyInUse> Evolution is almost universally accepted among biologists and within the scientific community in general. It is strongly supported by the evidence, and evolutionary principles continue to be validated by new discoveries. Evolution is a cohesive model for explaining some part of the natural world, and that is basically what a scientific theory is. It isn't some sort of transitional stage between hypothesis and fact.
06:59:12 <NameAlreadyInUse> You might as well say that the theory of relativity is "just a theory" or that the germ theory is "just a theory."
06:59:15 <NameAlreadyInUse> [QUOTE=Razalgrim;1000952]... science [I]has[/I] been disproved hundreds of times in the past.[/QUOTE]
06:59:17 <NameAlreadyInUse> bah
06:59:21 <NameAlreadyInUse> copy buffer strikes again
06:59:21 <mgee> list to list and list to element. ok
06:59:23 <quicksilver> yowch.
06:59:26 <NameAlreadyInUse> who was "Kleisli"?
06:59:36 <luqui> lol
06:59:52 <Deewiant> I always first paste to the server window because I know that I'll mess it up 50% of the time otherwise
06:59:53 <vixey> @fo Kleisli
06:59:53 <lambdabot> Maybe you meant: foldoc forget fortune ft
07:00:04 <quicksilver> NameAlreadyInUse: http://en.wikipedia.org/wiki/Heinrich_Kleisli
07:00:27 <NameAlreadyInUse> thanks quicksilver, that's what i was looking for
07:01:31 <luqui> pasting is for losers.  i type everything by hand.  encourages abstraction =P
07:02:04 <Hunner> copying is one of the few things that really requires a mouse
07:03:07 <quicksilver> lies!
07:03:18 * quicksilver copys and pastes all day, mostly mouseless.
07:03:28 <quicksilver> it just requires an efficient set of keyboard movement commands.
07:03:43 <Hunner> If it's in vim or screen, sure, but how about between firefox and xterm?
07:03:54 <NameAlreadyInUse> quicksilver: what sort of keyboard commands?
07:04:25 <doserj> Hunner: Shift-Insert pastes in an xterm
07:04:57 <quicksilver> NameAlreadyInUse: forward-backward {word,line,paragraph,function} etc.
07:05:03 <Hunner> yeah, but notice that I didn't say "Pasting requires the mouse" ;)
07:05:21 <lilac> NameAlreadyInUse: irssi to the rescue? "are you sure you want to paste 15 lines?"
07:05:40 <quicksilver> Hunner: don't use firefox? use conkeror! http://conkeror.org/
07:06:20 <Hunner> oh, speaking of which, copying links from irssi to firefox. X doesn't read screen's buffer
07:06:38 <doserj> Hunner: hitting F7 turns on caret browsing in firefox
07:06:44 <Hunner> Looks cool. I've been using vimperator
07:06:49 <NameAlreadyInUse> lilac: sounds good to me. i don't understand why IRC clients paste to chat
07:06:52 <quicksilver> similar idea AFAIR.
07:06:55 <NameAlreadyInUse> lilac: or my IRC client, at least
07:07:19 <quicksilver> Hunner: it would be nice if screen integrated with a wider ecosystem, yes.
07:07:35 <quicksilver> Hunner: like a terminal program which presented screen windows (running through ssh, of course) as tabs
07:07:45 <quicksilver> Hunner: and integrated the clipboard with the window system clipboard.
07:08:35 <Raevel> how is mapState implemented?
07:09:10 <quicksilver> @hoogle mapState
07:09:11 <opqdonut> ?src mapState
07:09:12 <lambdabot> Control.Monad.State.Lazy mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
07:09:12 <lambdabot> Control.Monad.State.Strict mapState :: ((a, s) -> (b, s)) -> State s a -> State s b
07:09:12 <lambdabot> Control.Monad.State.Lazy mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
07:09:12 <lambdabot> Source not found. Are you on drugs?
07:09:16 <opqdonut> hrmm
07:09:34 <Raevel> tried that. :-)
07:09:44 <quicksilver> Raevel: get result, get state, push through function, put state, return
07:10:10 <quicksilver> mapState f act = a <- act; s <- get; let (b,s') = f (a,s); put s'; return b;
07:10:49 <luqui> f=a{<ESC>$a}<ESC>
07:11:08 <doserj> mapState f m = State $ f . runState m
07:11:11 * quicksilver ponders the implications of the different "m" and "n" in mapStateT.
07:11:27 <quicksilver> doserj: modulo some currying, I think ?
07:11:53 <Raevel> okay, thanks!
07:12:19 <luqui> :t State $ ?f . runState ?m
07:12:20 <lambdabot> forall s a a1. (?m::State s a1, ?f::(a1, s) -> (a, s)) => State s a
07:12:23 <EvilTerran> ?type mapStateT
07:12:25 <lambdabot> forall (m :: * -> *) a s (n :: * -> *) b. (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
07:12:40 <NameAlreadyInUse> was there a haskell.org april fools joke?
07:12:46 <doserj> quicksilver: that's the definition on http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/src/Control-Monad-State-Strict.html#mapState
07:12:47 * quicksilver apologises for doubting doserj.
07:12:54 <Hunner> 6.10.2?
07:12:54 <EvilTerran> quicksilver, huh... that does have some interesting possibilities
07:12:58 <quicksilver> never again will I make that error.
07:13:14 <luqui> doserj, now's your chance!
07:13:19 <EvilTerran> ,src 'mapStateT
07:13:21 <lunabot>  luna: Not in scope: `mapStateT'
07:13:22 <doserj> quicksilver: It's often not an error :(
07:13:25 <luqui> doserj, tell him that haskell is worse than C
07:14:02 <NameAlreadyInUse> Hunner: really?
07:14:38 <Hunner> NameAlreadyInUse: no, not really, but there was things like "I installed 6.10.2 and all of a sudden my code doesn't compile" earlier :)
07:15:15 <quicksilver> NameAlreadyInUse: yes, on the mailing list : [Haskell] Marketing Haskell
07:15:17 <ledzipelin> http://en.wikipedia.org/wiki/Fold_(higher-order_function)#List_folds_as_structural_transformations <-- what happens if it isn't just (:)? and instead ((:) . f) ? what's the ordering of the ops?
07:15:33 <kohwj> quicksilver: hey i'm really impressed by how you devised that function so quickly
07:15:50 <Itkovian> what function to use to emulate tr -s " " ?
07:16:13 <kohwj> quicksilver: does it come with practice in haskell?
07:16:16 * EvilTerran suspects quicksilver was running something akin to the djinn algorithm in his head
07:16:17 <quicksilver> kohwj: which function?
07:16:29 <kohwj> quicksilver: the rounding function
07:16:40 <quicksilver> hmm. Well, I'd done it before.
07:16:54 <quicksilver> but it's a fairly natural way to (ab)use "round"
07:16:55 <vixey> ledzipelin: no ordering
07:17:00 <quicksilver> which is the only thing we have built in.
07:17:02 <luqui> Itkovian, unwords . words
07:17:26 <Itkovian> luthx.
07:17:27 <kohwj> quicksilver: thanks for sharing, fromIntegral . round was quite eye-opening- gotta read up on the Integral and Num types
07:17:31 <Itkovian> luqui: thx that was
07:17:33 <EvilTerran> ah, the rounding one, not the mapState
07:17:34 <luqui> :-)
07:18:03 <EvilTerran> ?help ?
07:18:04 <lambdabot> ? [args].
07:18:04 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
07:18:04 <lambdabot>  The commands are right associative.
07:18:04 <lambdabot>  For example:    ? ?pl ?undo code
07:18:04 <lambdabot>  is the same as: ? (?pl (?undo code))
07:18:07 <ledzipelin> vixey: for foldr:  is it, (f 1) : (f 2) : (f 3) ...
07:18:11 <EvilTerran> luqui, there's your black magic
07:18:31 <ledzipelin> ?
07:19:07 <luqui> :t foldr ((:) . ?f)
07:19:08 <lambdabot> forall b a. (?f::a -> b) => [b] -> [a] -> [b]
07:19:44 <ledzipelin> luqui: and how does it work for foldl?
07:19:54 <ledzipelin> i don't like foldl :)
07:20:02 <quicksilver> nobody likes foldl.
07:20:04 <luqui> you will fit in nicely here
07:20:08 <quicksilver> it is known as the combinator with no friends.
07:20:13 <ledzipelin> heh
07:20:23 <ledzipelin> friends := profs, phd assistans, stuff
07:20:42 <ledzipelin> they write the f.... exams and put so many strange questions in it
07:20:44 <luqui> but it does have a cool big brother, foldl'
07:20:45 <Raevel> @hoogle (s -> b) -> State s a -> State s b
07:20:46 <lambdabot> Control.Monad.State.Lazy withState :: (s -> s) -> State s a -> State s a
07:20:46 <lambdabot> Control.Monad.State.Strict withState :: (s -> s) -> State s a -> State s a
07:20:46 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
07:20:48 <doserj> > foldl f z [a,b,c]
07:20:49 <lambdabot>   f (f (f z a) b) c
07:21:07 * araujo notices some dons's reddit posts about himerge
07:21:29 <ledzipelin> doserj: how about implementing map with foldl?
07:21:32 <luqui> > foldr ((:) . f) [a,b,c] []
07:21:34 <lambdabot>   [a,b,c]
07:21:39 <luqui> > foldr ((:) . f) [a,b,c] [d,e,f]
07:21:42 <lambdabot>   [f d,f e,f f,a,b,c]
07:21:50 <luqui> right, duh
07:22:16 <luqui> so foldr ((:) . f) [] = map f
07:22:26 <EvilTerran> now prove it equationally! :P
07:22:41 <luqui> ?src map
07:22:42 <lambdabot> map _ []     = []
07:22:42 <lambdabot> map f (x:xs) = f x : map f xs
07:22:49 <luqui> oh damn, i was hoping that was the definition
07:23:01 <lilac> @src foldr
07:23:01 <lambdabot> foldr f z []     = z
07:23:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
07:23:03 <ledzipelin> luqui, how about the foldl map?
07:23:07 <lilac> done.
07:23:17 <luqui> ledzipelin, i'm not going to give you the answer...
07:23:35 <ledzipelin> luqui: already solved it. then forgot it.
07:23:44 <ledzipelin> i keep forgetting foldl things.
07:23:46 <ledzipelin> i hate that.
07:23:56 <luqui> it's okay, they never come up in practice ;-)
07:24:10 <edwardk> foldl?
07:24:18 <ledzipelin> luqui, foldl -> exam, for sure!
07:24:19 <ledzipelin> :D
07:24:33 * edwardk uses foldl whenever he forgets to be lazy
07:24:37 <ledzipelin> heh
07:24:45 <luqui> edwardk, do you come from lisp/scheme?
07:25:08 <luqui>  /any other functional language?  ;-)
07:25:18 <lilac> map _ [] = foldr ((:) . f) [] [] = []; map f (x:xs) = foldr ((:) . f) [] (x:xs) = ((:) . f) x (foldr ((:) . f) [] xs) = f x : map f xs
07:25:28 <edwardk> luqui: nah, i come from a very imperative background ;)
07:25:56 <luqui> haskell was my first functional language.  as a consequence, foldl basically doesn't exist...
07:25:57 <edwardk> my addiction to category theory and abstraction is mostly a reaction to my mis-spent youth.
07:26:08 <luqui> heh
07:26:37 <FunctorSalad> how do you mean that?
07:26:55 <EvilTerran> base case: map f [] ={defn of map} [] ={defn of foldr} foldr ((:).f) e [] -- nice and easy
07:27:11 <vixey> I'm watching catsters videos.. trying to absorb some category theory
07:27:15 <vixey> it's not working -_-
07:27:16 <edwardk> i'm bringing myself to use foldl' for the first time in my current effort actually, since it can be pretty efficient over bytestrings, etc.
07:27:33 <EvilTerran> inductive case: map f (x:xs) ={defn of map} f x : map f xs ={inductive hypothesis} f x : foldr ((:).f) e xs
07:27:39 <edwardk> handy videos but eugenia cheng needs to stop and breathe every once in a while ;)
07:27:44 <EvilTerran> ... ={defn of (.)} ((:).f) x (foldr ((:).f) e xs) ={defn of foldr} foldr ((:).f) e (x:xs) -- and we're done! :)
07:27:56 <luqui> EvilTerran, but you used induction
07:27:56 <lilac> EvilTerran: mine was less typing ;-)
07:28:06 <luqui> EvilTerran, and that identity holds for infinite lists too
07:28:34 <luqui> lilac's is shorter *and* more general :-)
07:28:44 <vixey> eugenia cheng is so cool!
07:28:48 <edwardk> vixey: and they are some times hard to follow, because she forgets that the camera can;t crane its neck to look over her shoulder
07:29:29 <vixey> I don't have much trouble following but I only watched basic ones about pullbacks and stuff
07:29:41 <NameAlreadyInUse> i tried to understand category theory once, without much success
07:29:43 <edwardk> funny thing is the set of those that actually first made something new click for me was the series on string diagrams. i finally 'got' adjunctions from that
07:30:00 <FunctorSalad> I'm curious, what are you saying is the causal relationship between misspent youth and ct/abstraction?
07:30:03 <edwardk> and those were by the other guy
07:30:05 <Raevel> should i write my functions as MyState a -> b -> MyState c or b -> MyState a -> MyState c ? I can't decide.
07:30:12 <EvilTerran> luqui, well, i could've looked at the "map f _|_ = foldr ((:).f) [] _|_" case as well to prove it rigorously for the infinite list case too, but i couldn't be bothered :P
07:30:27 <lilac> Raevel: which way are you likely to want to partially apply the function?
07:30:43 <luqui> EvilTerran, really?... does that work?
07:30:48 <Raevel> lilac: not sure
07:31:12 <luqui> i can't see it immediately
07:31:18 <edwardk> FunctorSalad: oh sorry. um, well i spent most of my time growing up obsessed with algorithms and data structures in a very imperative setting. i learned differential equations and linear algebra on my own just to do 3d graphics and really abused the pieces i knew
07:31:22 <Raevel> should i vary the order between functions to make pa easier, or should i pick one order and stick with it?
07:31:24 <lilac> Raevel: intuitively, i'd go for the latter; a function of type 'MyState a -> MyState c' seems nicer to me than one of type 'b -> MyState c'
07:31:33 <beelsebob> > (\f -> foldr ((:) . f) []) (+1) undefined
07:31:34 <lambdabot>   * Exception: Prelude.undefined
07:31:44 <EvilTerran> luqui, IIRC, Richard Bird told me that works; i'm taking him (and my (dubious) memory) at his word for it
07:32:00 <luqui> EvilTerran, okay.  i'll have to think about that.
07:32:02 <doserj> b
07:32:05 <EvilTerran> (i say "told me", i mean "told the lecture theatre full of students")
07:32:12 <edwardk> functorsalad: i was obsessed with writing provably correct code in a a hoare logic kind of setting, had a whole toy compiler for it, etc. very imperative stuff, then i found haskell.
07:32:26 <FunctorSalad> :)
07:32:48 <edwardk> and the curry howard isomorphism and pure type systems, and substructural logic, and the calculus of constructions, and category theory...
07:32:55 <lilac> luqui: i think the _|_ case allows you to apply well-ordered induction
07:33:02 <kohwj> would you recommend using haskell as a starting point for higher math, including cat. theory?
07:33:07 <edwardk> and all of a sudden i had a MUCH better framework to think in than the one I'd been using all along
07:33:14 <vixey> kohwj, no :p
07:33:25 <kohwj> heh
07:33:39 <kohwj> why?
07:33:45 <EvilTerran> luqui, i guess proving the _|_ case is sufficient for showing it works in infinite cases because you can model an infinite list as the limit of its initis
07:33:47 <lilac> kohwj: it can be useful, but some haskell concepts don't quite map onto the CT ones
07:33:50 <edwardk> kohwj: maybe not as the sole mechanism for learning them, but i think it serves as a great proving ground to show that you understand the ideas as you learn them though
07:33:50 <EvilTerran> *its inits
07:33:54 <FunctorSalad> edwardk: so "misspent" was only referring to the kind of mathematics your were using before? ;)
07:34:01 <ledzipelin> map f = foldl (\x y -> x ++ [f y]) [] ?
07:34:05 <lilac> kohwj: for instance, haskell's Functor is categorically only covariant endofunctors on Hask
07:34:20 <EvilTerran> luqui, or rather, say, [1..], is the limit of _|_, 1:_|_, 1:2:_|_, 1:2:3:_|_, ...
07:34:24 <NameAlreadyInUse> ledzipelin: does that work on infinite lists?
07:34:27 <kohwj> lilac: i'll take your word for it :)
07:34:38 <luqui> EvilTerran, right, that makes sense, i think
07:34:54 <edwardk> FunctorSalad: well, it took me a long time to become an academic. i was mostly concerned with bit twiddling, embedded systems, and 'software engineering' , etc. at various points before hand
07:35:07 <lilac> kohwj: haskell can be a great way for building intuition on category theoretical concepts
07:35:24 <luqui> lilac, maybe a good way...
07:35:28 <lilac> kohwj: but that intuition is not sufficiently general to teach category theory
07:35:50 <edwardk> kohwj: i like haskell as a lens to focus on category theory because the category of types is a pretty rich category, and so you can say a lot about it
07:36:15 <FunctorSalad> edwardk: btw, do you have a haskell parser/interpreter for kata?
07:36:21 <edwardk> but its easy to get fooled by glib haskell typeclass definitions and think you understand a category theoretic concept in general solely because you understand how Functors work in Hask.
07:36:28 <EvilTerran> lilac, it looks like your shorter version proves "map f (x:xs) = f x : map f xs" assuming "map f = foldr ((:) . f) []", not the other way round...
07:36:38 <EvilTerran> (to me, anyway; i may not be following your reasoning right)
07:36:52 <edwardk> FunctorSalad: i have several for several iterations of the language. ;) the current version is in flux because i want to use my monoid lib to replace most of its guts
07:37:08 <ledzipelin> NameAlreadyInUse, why shouldn't it :) it also solves the halting problem :P
07:37:16 <lilac> EvilTerran: what my version says is, "if you define map as foldr ((:) . f) [], then it has the properties required"
07:37:16 <FunctorSalad> I see
07:37:42 <EvilTerran> lilac, ah, i see; different kind of proof
07:38:02 <BMeph> NameAlreadyInUse: foldl doesn't work on infinite lists, so no.
07:38:04 <edwardk> FunctorSalad: my kata interpreter started as one for nuel way back when, which was my attempt to go down the substructural route before i just accepted the fact that mere mortals were not intended to program that way
07:38:07 <kohwj> i must say that programming has piqued my interest in discrete math
07:38:27 <vixey> what's discrete math
07:38:38 <unixty> hi
07:38:47 <edwardk> vixey: i'd tell you, but i'm er.. trying to be discrete
07:38:52 <unixty> what's the bootstrat flag for?
07:38:54 <EvilTerran> abstract algrabra, CT, domain theory, etcetc
07:38:55 <FunctorSalad> edwardk: ah... can't comment on that since I don't know anything about substructural logic
07:39:14 <EvilTerran> as compared to continuous math, being calculus, linear algebra, analysis...
07:39:18 <EvilTerran> *shudder*
07:39:34 <NameAlreadyInUse> BMeph: that's what i mean, the foldl definition of map isn't valid because it doesn't work on infinite lists
07:39:36 <edwardk> linear algebra can be discrete too ;)
07:40:33 <edwardk> FunctorSalad: i put down my current parser for kata because it was a hideous parsec beast, so i'm trying to see if i can make a more elegant one using the monoid combinators i've been writing
07:40:58 <edwardk> FunctorSalad: and the datalog engine i was mentioning on here for a while was being used in the guts of the type checker
07:41:01 <unixty> what about my question?
07:41:22 <edwardk> question?
07:41:39 <edwardk> bootstrap flag?
07:41:47 <vixey> edwardk: I want to see this new parser if it works out
07:41:49 <unixty> yes, in ghc
07:41:50 <edwardk> i think folks needed more context
07:42:01 <FunctorSalad> edwardk: I see... I was curious about using the adjective-based system as a framework for formal (semiformal?) math too
07:42:05 <edwardk> vixey: parts of it are working already
07:42:10 <FunctorSalad> (it seems quite natural)
07:42:23 <vixey> adjective ??
07:42:36 <edwardk> FunctorSalad: i was really happy when it cleaned up so much of my libraries
07:42:53 <edwardk> vixey: kata's 'traits' which are like context-sensitive mixin classes
07:43:41 <edwardk> http://comonad.com/kata/Category.k 'product' in 'product category' 'cartesian' and 'closed' in 'cartesian closed category'
07:43:51 <Saizan> unixty: what do you mean by bootstrap flag?
07:43:52 <unixty> what's the substructure logic?
07:44:25 <FunctorSalad> edwardk: I imagine it would be neat for a more-semantical mathematics wiki
07:44:30 <edwardk> so you can say foo = new adjective adjective adjective noun with ... -- and the adjectives add some definitions to the resulting class, and their meaning may depend on the other adjectives
07:44:34 <quicksilver> edwardk: have you written a blog post, or mailing list writeup, for your monoid parsers yet?
07:44:43 <quicksilver> edwardk: I'd love to see a worked example or similar
07:44:45 <edwardk> FunctorSalad: i keep trying to come up with a way to support 'cotraits'
07:44:55 <FunctorSalad> cotraits? :)
07:45:08 <edwardk> quicksilver: i'm still working on that part. i want some benchmarks and i need a better notion of a stratified generator to get decent results
07:45:40 <edwardk> FunctorSalad: a "semi ring" which removes some properties/laws, etc.
07:45:58 <edwardk> FunctorSalad: right now all traits are refinements
07:45:59 <unixty> Saizan: oh never mind, in gentoo haskell package has a boostrap USE flag. this is the description --> [-    ] bootstrap - !!internal use only!! DO NOT SET THIS FLAG YOURSELF!, used during original system bootstrapping [make stage2]
07:45:59 <vixey> unixty: you know the rules like   \a -> (a,a)  and  \(a,a) -> a
07:46:31 <quicksilver> edwardk: I'm more interested in programattical elegance than speed personally :)
07:46:32 <unixty> that's logic notation?
07:46:34 <edwardk> FunctorSalad: i can get by by making semi-ring into a class, and making ring subclass it, but i need to know superclasses a-priori or give up on code reuse
07:46:59 <edwardk> quicksilver: hah fair enough. well, the examples work pretty easily
07:47:06 <vixey> unixty: hasklel
07:47:26 <edwardk> unixty: substructural logic is where you remove some of the rules of logic and see whats left over. then maybe you permit them again in some limited contexts.
07:47:47 <unixty> ah
07:48:04 <edwardk> unixty: in general it takes the form of control over 'contraction' and 'weakening' in logic. contraction is the ability to use a variable more than once, weakening is the ability touse it not at all.
07:48:47 * ski whispers "exchange"
07:48:58 <FunctorSalad> edwardk: defining "semi-ring" from "ring" sounds kind of impossible if you regard the concept of ring as a collection of things that are rings, rather than a list of ring axioms
07:49:09 <edwardk> ski: hence why i said in general. you can go down to ordered as well ;)
07:49:22 <FunctorSalad> (not sure how to express this better)
07:49:42 * ski would like to see a braided substructural system
07:49:47 <edwardk> FunctorSalad: the idea of the concept of cotraits is that they define implicitly a superclass of an existing class by removing some subset of the traits or laws implied by the definition
07:50:39 <edwardk> so for instance remove some member, and remove all definitions that depended on that member
07:51:34 <ski> (FunctorSalad : yes, the weakening would be wrt a particular presentation of the concept)
07:51:40 <edwardk> i explicitly am not implementing them at this point, but i acknowledge that things like 'non-associative rings' and 'non-commutative fields' exist ;)
07:52:07 <FunctorSalad> how about "every (+),(0),(*) structure that becomes a ring if you adjoin additive inverses"?
07:52:57 <unixty> from the wiki 'Bastiaan Heeren, Daan Leijen, and Arjan van IJzendoorn in 2003 also observed some stumbling blocks for Haskell learners, "The subtle syntax  and sophisticated type system of Haskell are a double edged sword — highly appreciated by experienced programmers but also a source of frustration among beginners, since the generality of Haskell often leads to cryptic error messages."
07:53:06 <unixty> anybody find this criticism stupidL
07:53:08 <ski> (edwardk : like quasigroup / loop, yes ?)
07:53:20 <unixty> ?
07:53:31 <Twey> unixty: Not entirely
07:53:43 <unixty> I mean, why not make a language for experienced programmers?
07:53:50 <Twey> Heck, I've been using Haskell for quite a while, and sometimes the type errors still don't make sense to me
07:53:57 <Twey> I mostly look at the line number :)
07:54:47 <NameAlreadyInUse> i still find ghc's error messages to be pretty clear compared to what you get from implementations for other languages
07:54:59 <Twey> You have to have a perfect grokking of what's going on to understand them, and presumably in that case you wouldn't have made the error in the first place
07:55:02 <Twey> Oh, heck, yes
07:55:08 <Twey> They beat C++'s errors by miles
07:55:08 <jmcarthur> i agree with you unixty. i think it's frustrating that so many languages are completely crippled to cater to beginners
07:55:19 * vixey can't think of any..
07:55:31 <Twey> Yes, 'it would be confusing to beginners' is never a reason to leave things out
07:55:37 <Twey> *cough*monad comprehensions*cough*
07:55:38 <unixty> I don't find it a valid criticism that is not n00b-proof the syntax of an advanced language if that's the advantage and would take an experience programmer to understand
07:56:01 <NameAlreadyInUse> Twey: yes, i have sometimes been left stunned by complex C++ template errors
07:56:15 <jmcarthur> this is one of the reasons for the motto "Avoid success at all costs."
07:56:23 <Twey> NameAlreadyInUse: Or, even better, 'Segmentation fault' :)
07:56:43 <FunctorSalad> the "parse error" could be more informative too ;)
07:56:50 <Raevel> to me it seems fairly obvious that a steeper learning curve can allow you to make the language more useful
07:56:51 <Twey> I'm OK with the parse errors
07:57:10 <Twey> Parse errors are pretty much definitively shallow
07:57:12 <Twey> Typos and the like
07:57:14 <unixty> someone then should change that paragraph on the wiki, either that or make criticism of the criticism
07:57:16 <Raevel> same goes for frameworks/libraries/applications
07:57:37 <NameAlreadyInUse> unixty: i think that is what they are saying, not that haskell sucks because of the confusing error messages, but that the error messages are one of the disadvantages
07:57:44 <Twey> There are a few subtle ones introduced by layout and peculiar editor settings, but...
07:57:44 <FunctorSalad> Twey: some layout-related ones can take me a long time to spot
07:58:08 <FunctorSalad> (but admittedly I never read the formal layout rules, maybe I should)
07:58:13 <bastl> hi guys.
07:58:25 <FunctorSalad> still not sure when you are allowed to un-indent without exitting a scope in the process
07:58:38 <Raevel> i don't see why it's "criticism" at all, it's an observation, whether correct or not (if that makes sense)
07:59:08 <Twey> FunctorSalad: I think basically you shouldn't
07:59:29 <Twey> Even when you're allowed to, one column = one scope is nice and easy to understand
07:59:58 <NameAlreadyInUse> unixty: and if that's the only criticism that is listed then i think haskell is doing pretty well for itself
08:00:00 <jmcarthur> i don't know off the top of my head of any cases where you don't leave scope when unindenting...
08:00:05 <FunctorSalad> Twey: but it's annoying to waste half a screen for preliminaries and have the interesting code line-wrapped
08:00:20 <Raevel> @hoogle State s a -> a
08:00:21 <lambdabot> Text.Parsec.Prim stateUser :: State s u -> u
08:00:21 <lambdabot> Text.ParserCombinators.Parsec.Prim stateUser :: State s u -> u
08:00:21 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
08:00:46 <Raevel> why does evalState have a second parameter?
08:00:57 <Twey> FunctorSalad: Rethink your structure
08:01:16 <Twey> Splitting off into additional functions or something even more complex like a monad might be useful
08:01:19 <FunctorSalad> (say, "preservingMatrix $ do ..." - id like to unindent the "...")
08:01:29 <jmcarthur> you can do that
08:01:41 <RayNbow> @djinn-add class Functor f where fmap :: (b -> c) -> f b -> f c
08:01:41 <ski> Raevel : the initial state
08:01:41 <FunctorSalad> sometimes I can ;)
08:01:44 <jmcarthur> indent slightly underneath that line
08:01:52 <RayNbow> @djinn a (a x -> x) -> a x
08:01:53 <lambdabot> -- f cannot be realized.
08:01:55 <Twey> Yeah
08:01:59 <Twey> It's not really unindenting
08:02:01 <jmcarthur> be somewhere to the right of the p of preservingMatrix
08:02:06 <Twey> But it's only slight indenting
08:02:19 <vixey> a (a x -> x) -> a x  that's an interesting type
08:02:21 <ski> @djinn Functor f => f (f a -> a) -> f a
08:02:21 <lambdabot> -- f cannot be realized.
08:02:22 <Raevel> ski: but, i have a new state, why do i need to care about the initial one?
08:02:22 <jmcarthur> you have to line break after the do though
08:02:27 <ski> (no recursion)
08:02:33 <FunctorSalad> it's unindenting compared to continuing to the right of the d of the do
08:02:34 <jmcarthur> otherwise you're breaking the do after that first line
08:02:44 <jmcarthur> yes
08:02:48 <NameAlreadyInUse> @src scanl
08:02:49 <lambdabot> scanl f q ls = q : case ls of
08:02:49 <lambdabot>     []   -> []
08:02:49 <lambdabot>     x:xs -> scanl f (f q x) xs
08:02:53 <EvilTerran> vixey, is that yoneda?
08:02:57 <jmcarthur> but... it's really not
08:03:04 <ski> Raevel : an action in a state monad may read the state before updating the state, hence you need an initial one
08:03:13 <jmcarthur> i don't consider it unindenting unless you are starting to the left of the previous line
08:03:14 <ski> EvilTerran : it is `loeb'
08:03:22 <RayNbow> http://blog.sigfpe.com/2006/12/tying-knots-generically.html
08:03:27 <RayNbow> ^ I was reading this page :p
08:03:44 <jmcarthur> well, unless you were to put stuff after the do on the same line
08:03:53 <jmcarthur> but then you are obviously visually breaking the block
08:04:01 <Botje> undefined is my favorite initial state
08:04:04 <EvilTerran> ski, ah, yes, loeb. i'm getting my eponyms mixed up.
08:04:20 <ski> (or at least, it has the same type as `loeb' .. i'm not sure if it "is" `loeb' (in whatever sense))
08:05:30 <ski> Raevel : if you only produce output (wild guess), you might possibly use `Writer' instead of `State'
08:06:11 <ledzipelin> when I have to prove some Tree-funcion equalities, do I always have to prove the two base cases, LLeaf and LNode something LLeaf LLeaf ?
08:06:14 <NameAlreadyInUse> what does "loeb" even stand for?
08:06:29 <eu-prleu-peupeu> hi
08:06:30 <Botje> concentrated evil in pre-knot-tied form
08:06:32 <Raevel> ski: ah, now it makes sense :-) thanks
08:06:44 <ski> NameAlreadyInUse : <http://en.wikipedia.org/wiki/Martin_L%C3%B6b>
08:06:46 <vixey> ledzipelin: it depends entirely on the programs
08:06:48 <Raevel> i do need state though
08:06:56 <EvilTerran> NameAlreadyInUse, http://en.wikipedia.org/wiki/L%C3%B6b%27s_theorem
08:07:27 <Twey> ski: Your funny link format confuses my browser
08:07:32 <Twey> Er, terminal
08:07:58 <ski> (Twey : it's the recommended way to include a link in text, according to some RFC)
08:08:20 <Twey> It's silly — > is a valid character in URLs, I believe
08:08:36 <ledzipelin> vixey, hm ok, so that's" "not always" :D
08:08:52 <EvilTerran> IIRC, the RFC said to write <URL:http://...>, but that's from when people might not've recognised a URL unless it was labelled as such
08:09:10 <NameAlreadyInUse> ski: my IRC client considers the > to be part of the url
08:10:02 <ski> Botje : the actual `loeb' (i.e. the meta-theorem about a logic, or theorem in provability logic) is not cyclic in the way that `Functor'-generic version is
08:10:28 <Twey> Ah, no
08:10:30 <ski> (but it's "almost" cyclic :)
08:10:36 <Twey> Our applications are wrong
08:11:07 <Twey> RFC1738 specifically says: "The characters "<" and ">" are unsafe because they are used as the delimiters around URLs in free text"
08:11:09 <Botje> oh :)
08:11:19 <Botje> i've only seen sigfpe use it to write that spreadsheet thing
08:11:50 <quicksilver> news at 11: IRC client author doesn't read RFCs :P
08:12:01 <Twey> Hahaha
08:12:36 <quicksilver> next up : bicyclist is under delusion that there is a special exception to traffic rules just for him.
08:13:22 * Twey grins.
08:13:37 * Twey almost got run over by a bicyclist yesterday
08:16:04 <Twey> @let ⊕ = mappend
08:16:05 <lambdabot>   Parse error
08:16:08 <Twey> :<
08:16:18 <Twey> Oh
08:16:21 <Twey> @let (⊕) = mappend
08:16:22 <lambdabot>  Defined.
08:16:37 <vixey> hey
08:16:41 <Twey> > [1, 2] ⊕ [3, 4]
08:16:42 <lambdabot>   [1,2,3,4]
08:16:50 <vixey> I was using ⊕ as mplus
08:16:54 * Twey adds a compose entry for ⊕
08:17:02 <vixey> > let (⊕) = mplus in   [1,2] ⊕ [3,4]
08:17:03 <Twey> According to this article, it's the proper symbol for mappend
08:17:04 <lambdabot>   [1,2,3,4]
08:17:08 * vixey boo
08:17:10 <vixey> what article?
08:17:13 <Twey> http://gregorycollins.net/posts/2009/03/30/building-a-website-part-2
08:17:41 <vixey> nah
08:18:07 <tomh> hey dolio, you knew yesterday the rules for super and inst by guessing right?
08:18:16 * vixey reads "It holds the contents of my delicious feed (which we’ll discuss later),.." wonders, is the author a chicken?
08:18:25 * Twey laughs.
08:18:28 <Twey> I thought much the same
08:18:45 <vixey> now  that is what a chicken would write on it's blog
08:18:49 <quicksilver> Twey: I like +> for mappend.
08:19:04 <quicksilver> Twey: (I'm not unicode capable, what was your symbol?)
08:19:04 <Twey> quicksilver: ASCII is so last decade
08:19:11 <vixey> (+)
08:19:24 <Twey> quicksilver: U+2295 CIRCLED PLUS
08:21:26 <EvilTerran> ah, pluscle!
08:21:37 <Twey> Hahaha
08:21:45 <vixey> ++ for mappend is better
08:21:45 <beelsebob> haha
08:21:46 <Twey> To rhyme with 'muscle'?
08:21:50 <beelsebob> that's what I'll name it forever more
08:22:05 <Twey> :-D
08:22:08 <vixey> > (("foo"++) ⊕ ("bar"++)) []
08:22:09 <lambdabot>   "foobar"
08:22:19 <vixey> :t mappend
08:22:20 <vixey> :t mplus
08:22:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
08:22:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
08:22:24 <EvilTerran> at least one of my lecturers calls (+) "pluscle", (x) "crosscle", etcetc
08:23:04 <EvilTerran> rhyming with "muscle", yeah
08:23:36 <vixey> what do they use them for?
08:23:54 <quicksilver> Twey, vixey : Yes; we always used (+) in lecture. However, I prefer +>
08:23:55 <vixey> I think ⊕ is direct sum
08:24:04 <quicksilver> because +> has an asymmetric feel to it.
08:24:08 * ski . o O ( linear logic )
08:24:10 <quicksilver> and in general, Monoids are not commutative.
08:24:15 <Hunner> I think it's more a combination of plus and circle, not muscle
08:24:17 <quicksilver> that's why I prefer +> to ++ and (+)
08:24:42 <jmcarthur> that actually convinced me. i preferred (++) until now
08:24:44 <EvilTerran> vixey, er, mostly arbirary infix operators, that kinda thing
08:24:48 <quicksilver> it allows us to intuitively define (<+) = flip (+>) for the times you want to compose the other way.
08:25:02 <ski> (however, if you flip the operation in a monoid, you get a monoid. so it's symmetric in that sense)
08:25:08 <quicksilver> ski: yes.
08:25:09 <jmcarthur> although i'm not sure i like the > in it since it make it look like it's pointing
08:25:13 <EvilTerran> foldr (⊕) e (x:xs) = x ⊕ foldr f e xs
08:25:18 <quicksilver> ski: I don't think that contradicts my argument though :)
08:25:37 <quicksilver> jmcarthur: perhaps you'd like to argue for +| ?
08:25:42 <quicksilver> that's not pointing at no one.
08:25:47 <jmcarthur> i was thinking exactly that
08:25:52 <BMeph> jmcarthur: It /is/ pointing, that's the appeal of it. :)
08:26:18 <jmcarthur> BMeph, i like that it's asymmetric, not that it looks like an arrow
08:26:44 <Twey> It doesn't really look like an arrow
08:26:53 <Twey> Strangest darned arrow I've ever seen, anyway
08:27:01 <EvilTerran> -|->
08:27:06 <jmcarthur> >s make things look like funky arrows to me
08:27:10 <EvilTerran> is reminisecent of it
08:27:19 <BMeph> jmcarthur: Why do you hate the arrow so? Did a Native American beat you up as a child? ;)
08:27:24 <jmcarthur> it's okay for things like bind
08:27:29 * Twey laughs.
08:27:43 <jmcarthur> although... i wish bind didn't look like an arrow :)
08:27:43 <Twey> jmcarthur: Why?
08:27:49 <Twey> But it makes sense
08:27:55 <jmcarthur> i'm just used to it looking like an arrow
08:27:59 <Twey> You're indicating the direction the input goes
08:28:12 <quicksilver> Twey: it looks like a necktie :)
08:28:14 <jmcarthur> Twey, why doesn't <*> look like an arrow then? it makes no less sense than for bind to me
08:28:24 <Twey> >>= *peers*
08:28:24 <jmcarthur> or <$>
08:28:32 <idnar> jmcarthur: <*> isn't directional ;P
08:28:32 <quicksilver> jmcarthur: <*> being symmetric was also a mistake, IMO.
08:28:39 <quicksilver> idnar: it is very direction.
08:28:46 <Twey> jmcarthur: Why would <*> look like an arrow?  x.x
08:28:54 <idnar> uhm, what I meant was, <*>'s "shape" is broken
08:28:55 <quicksilver> you don't apply arguments to functions, you apply functions to arguments.
08:28:59 <Twey> Just because something points, doesn't make it an arrow
08:28:59 <jmcarthur> it is just as directional as bind is
08:29:00 <idnar> it should be directional
08:29:02 <Deewiant> ?ty (<*>)
08:29:02 <Twey> An arrow needs a shaft
08:29:03 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:29:05 <ski> `<*>' is more about order than direction
08:29:07 <Twey> Like -> or ~>
08:29:09 <idnar> which makes *> even more confusing
08:29:09 <jmcarthur> bind happens to be backwards though
08:29:10 <quicksilver> idnar: right. Agreed.
08:29:12 <Twey> Or ~~~~>
08:29:19 * EvilTerran likes bind being =<< because that makes "do ...; x <- f =<< m" look like an arrow labelled with "f"
08:29:20 <jmcarthur> ski, yes!
08:29:27 <jmcarthur> i think bind is more about order than direction too
08:29:41 <quicksilver> it's the direction the result flows
08:29:42 <jmcarthur> =<< more than >>= i think
08:29:45 <quicksilver> it's a dataflow arrow, isn't it?
08:30:09 <ski> jmcarthur : less so, i'd say, because of the `a' flowing from the left to the right argument
08:30:21 <jmcarthur> (<*>) :: m (a -> b) -> (m a -> m b); (=<<) :: (a -> m b) -> (m a -> m b)
08:30:24 <jmcarthur> ^^ they are very similar
08:30:30 <beelsebob> ski: I'd say bind should be the other way round too though
08:30:35 <EvilTerran> =<< is more reminiscent of function application
08:30:36 <beelsebob> i.e. data flowing from right to left
08:30:43 <beelsebob> or function transformation too
08:30:54 <EvilTerran> >>= makes more sense in its own right, but then, so would writing (x f) instead of (f x)
08:31:12 <quicksilver> true.
08:31:25 <quicksilver> we're not very consistent about whether data flows left to right or right to left
08:31:26 <ski>   (<,,>) :: i a -> i b -> i (a,b)  -- only order, no data-direction
08:31:27 * BMeph heard Isaac Hayes music in his head, when he read Twey's remark about "shaft"
08:31:31 <quicksilver> but with >>+ the arrow shows you.
08:31:34 * Twey laughs.
08:31:56 <quicksilver> ski: agreed. that would be fine, if legal.
08:32:18 <quicksilver> on the other hand, <* and *> make a different, good, use of the directions
08:32:32 <ski> using `(<,,>)' you can define both `<*>' and its "converse"
08:32:40 * quicksilver ndos
08:32:44 <quicksilver> <**>
08:32:54 <ski> (an even worse name)
08:33:00 <quicksilver> oh, that's the converse in a different axis :)
08:33:13 <quicksilver> <*>, flip <*>, <**> and flip <**>
08:34:11 <ghcai> M.insertWith (:) "hello" "que" $ M.fromList [("hello", ["no"])]
08:34:15 <ghcai> M.insertWith (++) "hello" "que" $ M.fromList [("hello", ["no"])]
08:34:16 <ghcai> ?
08:34:42 <ghcai> ah
08:34:52 <ski> @src <**>
08:34:52 <ghcai> M.insertWith (++) "hello" ["que"] $ M.fromList [("hello", ["no"])]
08:34:52 <lambdabot> (<**>) = liftA2 (flip ($))
08:35:23 <ski> (yes, that's the one i was thinking of)
08:36:57 <ski> (beelsebob : did you meant `(=<<)' instead of `(>>=)' in `Monad' ?)
08:37:36 <beelsebob> ski: indeed
08:38:00 <ski> you could have both, i suppose
08:39:56 <beelsebob> you could
08:40:04 <beelsebob> (>>=) shouldn't even be in the Monad class anyway
08:40:13 <beelsebob> just join
08:40:31 <ski> then you need the `Functor m' constraint
08:40:55 <beelsebob> no, the Pointed m constraint
08:41:25 <beelsebob> oh, no, you need functor
08:41:28 <beelsebob> hmm
08:41:30 <ski>   ma >>= amb = join (fmap amb ma)  -- you weren't thinking of this ?
08:41:31 <lilac> beelsebob: arguably (>>=) should be in Monad but defaulted, like (>>), for efficiency reasons
08:41:32 <ski> ok
08:41:45 <beelsebob> lilac: true I guess, yeh
08:41:46 <opqdonut> i'm with lilac
08:41:58 <opqdonut> or rather, join and >>= should both be defaulted
08:41:59 <ski> (sometimes it feels more natural defining the `(>>=)'/`(=<<)' .. also, efficiency as lilac said)
08:42:02 <opqdonut> like == and /= are
08:42:15 <lilac> opqdonut: that's even better, and also kinda backwards compatible
08:42:28 <opqdonut> indeed
08:42:43 <lilac> backwards compatible with all code which didn't forget to give a Functor instance :)
08:42:49 <doserj> and >> shouldn't be in Monad.
08:43:36 <Duqicnk> @type amb
08:43:37 <lambdabot> Not in scope: `amb'
08:43:57 <ski>   amb :: a -> m b  -- there above
08:44:14 <ski> @type (>>=)
08:44:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:44:44 <lilac> doserj: you want that in Applicative? (a >> b = flip const <$> a <*> b)
08:45:03 <jeltsch> lilac: Ah, that‘s interesting!
08:45:05 <doserj> lilac: yes. ==> do-notation for Applicative!
08:45:16 <jeltsch> doserj: Cool! :-)
08:46:43 <jeltsch> On the other hand, is it really useful to just chain effectful computations with do notation without having any data dependencies.
08:47:48 <beelsebob> oh god
08:47:52 <beelsebob> I would slap anyone that does that
08:47:56 <beelsebob> with an enormous trout
08:48:11 <beelsebob> why do people think that writing a chunk of imperative code is a good thing
08:48:20 <Duqicnk> are there any good text-templating engines for Haskell?
08:48:23 <vixey> why do people have such a bad reaction to imperative code ?
08:48:54 <beelsebob> vixey: because it has horrible horrible properties – not least of which is that I don't want to describe how to get a value, I want to describe the value
08:49:05 * EvilTerran has previously noted that, with -XNoImplicitPrelude and (>>) = (*>), "do x; y" works out correctly with an Applicative constraint
08:49:19 <EvilTerran> (in 6.10.1, anyway)
08:49:20 <vixey> what horrible horrible properties ?
08:49:37 <Philippa_> beelsebob: amongst other things, it's often the closest way I can express chunks of some highly declarative paradigms
08:49:39 <ski> maybe define "imperative code" ?
08:49:43 <Duqicnk> beelsebob: you are describing the value.  it's description is 'the result of doing foo'
08:49:51 <Duqicnk> sometimes you can do no better
08:49:56 <beelsebob> Duqicnk: which is a horrible backwards way of describing the value
08:50:07 <Duqicnk> how do you describe the value 'the current time' better than 'the result of asking the OS for the current time'?
08:50:07 <beelsebob> and I don't believe that sometimes you can do no better
08:50:17 <beelsebob> Duqicnk: take a look at Reactive
08:50:23 <beelsebob> ;)
08:50:38 <Philippa_> = "the result of being constantly fed the current time"
08:50:43 <Philippa_> that's not much better
08:50:48 <beelsebob> no, no it doesn't
08:50:52 <Philippa_> in fact, it just ducks the question
08:50:55 <beelsebob> it's a value which is time varying
08:50:59 <beelsebob> it's not a result of anything
08:51:01 <beelsebob> it's a value
08:51:05 <vixey> What are the horrible properties of imperative code?
08:51:15 <beelsebob> vixey: we're discussing one at the moment
08:51:25 <beelsebob> the backwards nature of describing how to get a value, rather than just the value
08:51:29 <Philippa_> beelsebob: that only works if you completely don't care how this 'time' relates to anything physical
08:51:39 <Philippa_> otherwise, somewhere down the line you've got to connect the two
08:51:48 <vixey> actually declarative programming is backwards, but nothing is bad about backwards
08:51:49 <beelsebob> Philippa_: only if your OS isn't functional :)
08:52:00 <Philippa_> beelsebob: only if your Theory of Everything isn't
08:52:15 <beelsebob> Philippa_: yep
08:52:16 <vixey> we intuitively deal with "open that box and bring it over here" not "bring the open version of that box here"
08:52:29 <beelsebob> but we don't know what the theory of everything looks like yet
08:52:41 <Philippa_> but right now, our CPUs sure as hell aren't and some of us have better things to do than wait for a functional OS
08:52:42 <vixey> next? :p
08:52:43 <beelsebob> I'm still prepared to bet that it looks very functional though
08:53:19 <beelsebob> Philippa_: the reason I'm using Haskell is that I like abstracting things away from the details of the CPU I'm running on
08:53:30 <beelsebob> the CPU I'm running on doesn't have a concept of function application either
08:53:32 <beelsebob> doesn't mean I don't use it
08:53:38 <Philippa_> as do I. I like having a choice as to how far I do it though
08:53:47 <beelsebob> yep, so do I
08:53:52 <vixey> Actually something I would like to know is: say that you write some algorithms using Applicative (or something else declarative) rather than Monad is it easier to formall prove it correct?
08:53:55 <Philippa_> to put it another way, I appreciate the existance of Harpy
08:53:58 <jeffersonheard> jules, are you on here?
08:53:59 <beelsebob> doesn't mean I want to do it early when I don't have to
08:54:02 <quicksilver> jeffersonheard: yes.
08:54:12 * beelsebob runs off to watch a film
08:54:17 <Philippa_> fine. That's not the argument you were making earlier, however
08:54:50 <vixey> formally
08:54:59 <jeffersonheard> ah yay.  rather than deluge the mailing list with too much more about it, I thought I'd pop on here and see if I could clear things up about the EData type
08:55:32 <Philippa_> vixey: using an Applicative rather than a Monad doesn't magically make you more declarative
08:55:46 <quicksilver> jeffersonheard: I think I understnad why you'r doing it, now.
08:55:53 <quicksilver> jeffersonheard: I don't know if I agree, though :)
08:56:06 <quicksilver> I think I'd rather have a composable approach
08:56:15 <Philippa_> OTOH, it can be easier for approximately the reason that proving things about first-order languages can be easier
08:56:28 <quicksilver> I could start with an bus of type Event Key and a bus of type Event MouseMoved
08:56:31 <jeffersonheard> Well, I can certainly see a decent argument for declaring the type separately and simply using it a bunch
08:56:38 <quicksilver> and combine them to a bus of type Event (Either Key MouseMoved)
08:56:51 <quicksilver> I'd rather have a Widget Key (if it really only cares about keys)
08:56:52 <vixey> Philippa_: I was kinda aiming at beelsebob because he blogged about why you should use applicative instead of monad, but beyond that I really do not know the answer to my question
08:57:01 <quicksilver> and a way to upgrade that to a Widget SomethingMoreComplex
08:57:11 <quicksilver> if I have a combined behaviour which needs more complex busses
08:57:12 <quicksilver> etc.
08:57:25 <vixey> Philippa_: it's kind of bizarre, so difficult to find formal proofs about even simple functions..
08:58:05 <jeffersonheard> quicksilver: but then you end up pushing the problem down to behaviours, I would think.
08:58:26 <stonedz_> hello everybody, I've some troubles installing the unix package with cabal-install, since it's my first attempt with cabal-install I don't know if I'm doing something wrong: cabal-install terminates with "Module `GHC.Conc' does not export `Signal'". What should I do?
08:58:28 <jeffersonheard> I can see a composable bus, but it seems to make behaviours less so.
08:59:00 <quicksilver> jeffersonheard: hmm. I haven't grokked your behaviours. I should try the code, I guess.
08:59:10 * ski wonders how to make defaulting sane for a "triangle" of default definitions ..
08:59:14 <quicksilver> jeffersonheard: my gut doesn't like special cases like that.
08:59:49 <Twey> ski: You can have them depend on each other, can't you?
08:59:54 <jeffersonheard> not so much a special case as I was thinking of the basic unit of composition being the behaviour, not the bus
08:59:56 <Twey> Like (==) and (/=)
09:00:14 <jeffersonheard> and declaring EData as a separate type makes it less a special case than it is now
09:00:23 * Twey thinks we need a formal way to specify minimum complete definitions in code
09:00:37 <quicksilver> jeffersonheard: that's certainly true.
09:00:38 <jeffersonheard> Twey: I like that idea
09:00:39 <ski> each one of `f',`g',`h' has a default definition in terms of each of the others .. six default definitions in all
09:01:13 <jeffersonheard> quicksilver: I think I'll do that...  it certainly seems more aesthetic to do so
09:01:26 <vixey> Twey: formal in what sense(s)?
09:01:41 <Twey> vixey: Not comments.
09:01:52 <vixey> Twey: oh like some kind of DAG and it says:  You should fill in the definition of (>>=)  as an error message
09:01:57 <ski> (or maybe a slightly saner case would be `f' having one definition in terms of `g', and one in terms of `h', and then `g',`h' only has definitions in terms of each other (not in terms of `f'))
09:02:11 <Twey> ski: So ‘f’ can be defined in terms of either ‘g’ or ‘h’ depending on which exists?
09:02:19 <vixey> Twey: seems a bit tricky to automate, mutual recursion throws a spanner in the works
09:02:28 <ski> Twey : right
09:02:42 <Twey> vixey: From code, but not if specifying
09:03:03 <ski> Twey : there's potentially some problem if the user decides to provide both of `g' and `h', though .. which default definition of `f' to use
09:03:18 <Twey> You just have to be able to say “‘f’ OR ‘g’”
09:03:26 <ski> Twey : but at least in the cases where there's exactly one definition to use, in each case
09:03:29 <EvilTerran> (f `unamb` g)?
09:03:39 <Twey> ski: Aye, but you can just pick one, right?
09:03:57 <ski> Twey : no, i might want to use one in one instance, and another in another instance
09:04:18 <Twey> Hmn
09:04:29 <ski> (Twey : not "OR" .. more like "AND", but like the additive conjunction in linear logic, not the multiplicative one)
09:04:50 * BMeph has an immediate reaction of annoyance whenever he hears C programmers talk about how programming languages should deal with "stack frames".
09:05:35 <QtPlaty[HireMe]> BMeph: Why?
09:05:43 <mmorrow> BMeph: tell them smlnj has a nice method
09:06:11 <mmorrow> (namely, it doesn't)
09:06:15 <vixey> BMeph: what's the annoyance?
09:06:34 <ski> (mmorrow : Chicken is also interesting)
09:07:06 <mmorrow> maybe assuming that the definition of "language" includes a C-callstack like evaluation model
09:07:12 <mmorrow> (@vixey)
09:07:18 <mmorrow> ski: yeah, that is pretty cool
09:07:45 <ski> (Twey : sorry, i wasn't meaning to drag linear logic into this (yet), i just had to respond to your "OR")
09:08:55 <Duqicnk> ski: CPS transform and keep track of application on the stack?
09:08:59 <Duqicnk> or was it a different trick
09:09:22 <ski> CPS transform and GC when stack full
09:09:44 <mmorrow> but cool in the make-the-best-of-the-horrible-situation-you're-in
09:09:47 <mmorrow> :)
09:11:37 <mmorrow> it's heap lives on the C stack, and when it runs out of room, it longjumps back to the start
09:12:00 <mmorrow> (i don't recall where it copies the still-live part of the heap to..)
09:12:10 <quicksilver> I wish GHC dealt better with deep stacks.
09:12:13 <mmorrow> (or even if it's a copying gc (i think it'd have to be))
09:12:24 <quicksilver> it shouldn't be somethign I have to worry about.
09:16:45 <BMeph> vixey: Yeah, what mmorrow said.
09:17:54 <BMeph> vixey: BTW, I'm sorry that I keep getting dragged off and responding to your messages hours after you ask. :)
09:18:22 <quicksilver> that's ok, IRC is an unreliable, asyncrhonous, message-passing system.
09:18:24 <quicksilver> like erlang.
09:18:25 * quicksilver ducks
09:18:41 * jmcarthur doesn't see any reason to duck for that
09:20:03 <ghcai> @slap quicksilver
09:20:04 * lambdabot loves quicksilver, so no slapping
09:20:10 <ghcai> lol
09:20:12 <jmcarthur> haha
09:20:21 <bigsyke> lol
09:21:11 <quicksilver> haha.
09:23:34 <RayNbow> @slap RayNbow
09:23:34 * lambdabot pulls RayNbow through the Evil Mangler
09:23:42 <RayNbow> @thanks
09:23:43 <lambdabot> you are welcome
09:24:14 <pumpkin> mmorrow: did you sign up for twitter? cause if not, someone snapped up your username in the past few days :P
09:25:22 <mmorrow> pumpkin: those bastards!
09:25:34 <pumpkin> http://twitter.com/mmorrow
09:25:39 <mmorrow> (i actually use "morrow", but that's usually always taken :(
09:25:41 <pumpkin> oh
09:27:29 <bigsyke> anyone know any good tutorial on monads?
09:27:39 <pumpkin> bigsyke: nope
09:27:44 <bigsyke> i'm a haskell freshman
09:27:50 <cnwdup> bigsyke, Real World Haskell's chapter on monads helped me a lot.
09:27:53 <cnwdup> *chapters
09:28:12 <RayNbow> bigsyke, are you familiar with the other type classes in Haskell?
09:28:14 <pumpkin> bigsyke: although there are thousands written out there :P what helps people understand monads seems to vary based on the reader rather than the writer
09:28:25 <steveklabnik> bigsyke: it also depends, you're talking about from the beginning?
09:28:25 <abuiles> Hi, does someone knows where can I find the definition for  "data (->) a b        -- Defined in GHC.Prim " It says GHC.Prim , but is not there... thanks!
09:29:14 <ski> (pumpkin : would that suggest "The Monad Reader" to be appropriate ? :)
09:29:25 <bigsyke> @cnwdup yep,I'm confident with the other type classes
09:29:26 <lambdabot> Unknown command, try @list
09:29:29 <bastl> can i make this code shorter ? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3220#a3220 it looks as if ...
09:29:31 <mmorrow> pumpkin: did you see this mmorrow fellow's first tweet?
09:29:43 <bigsyke> cnwdup yep,I'm confident with the other type classes
09:29:52 <cnwdup> bigsyke, that was RayNbow. ^^
09:29:58 <RayNbow> :p
09:30:02 <RayNbow> bigsyke: have you read byorgey's Typeclassopedia?
09:30:03 <vixey> bastl: you could just retutrn (i+1) rather than i' <- get
09:30:23 <vixey>   i' <- get ; return i'   could be shortened to   get
09:30:26 <bastl> vixey: the mapM in the middle manipulates the state
09:30:34 <vixey> oh right of course
09:30:41 <vixey> modify (+1)
09:30:46 <bigsyke> rayNbow:nope
09:30:56 <vixey> modify (+1) >> mapM ... >> get
09:30:57 <pumpkin> mmorrow: yeah, I was afraid to ask about it :P
09:31:00 <RayNbow> bigsyke, http://www.haskell.org/haskellwiki/The_Monad_Reader
09:31:01 <vixey> or something like that
09:31:30 <mmorrow> pumpkin: heh
09:31:38 <quicksilver> I think to get up to date and hip, someone shuold do a twitter monad tutorial
09:31:45 <quicksilver> preferably just a single tweet.
09:32:07 <bastl> vixeey: ok, thanks.
09:32:08 <mmorrow> +10 style points if it's in rhyming LOLCODE
09:32:24 <bigsyke> thanx everyone,i'll check out all the tutorial links
09:32:25 <pumpkin> Monad = (fmap, return, join)
09:32:26 <pumpkin> there you go
09:32:45 <quicksilver> I'm not sure that quite qualifies as 'tutorial'
09:33:02 <pumpkin> Monad = (fmap, return, join) and is just like a burrito
09:33:04 <pumpkin> how's that?
09:33:25 * Philippa_ wonders if you can do a meaningful one explaining how bind relates to (MLish) let
09:33:32 <ski> monads are monoids over the endofunctor category (with composition and identity as monoidal structure) of any category. fin.
09:33:59 <snoobino> I'm fighting the worst bug ever
09:34:05 <abuiles> Guys, Does someone knows where can I find the definition for  "data (->) a b       " It says GHC.Prim , but is not there.,thanks!
09:34:10 <snoobino> only appearing 1 time out of 10
09:34:16 <snoobino> you mayu
09:34:22 <snoobino> you may think its better
09:34:37 <snoobino> but it makes debugging so hard
09:34:39 <quicksilver> abuiles: it's built in.
09:34:51 <quicksilver> abuiles: there's no way to define it.
09:35:19 <snoobino> I need compassion
09:35:39 <quicksilver> @faq Can haskell show pity on snoobino
09:35:40 <lambdabot> The answer is: Yes! Haskell can do that.
09:36:03 <abuiles> quicksilver: thanks
09:36:16 <snoobino> thx you lambda buddies
09:39:00 <pumpkin> bbl
09:39:21 <mae_work> dcoutts: what is the reasonable / portable way to get standard mingw include paths when trying to build a cabal for windows? i don't want to hardcode them to c:\ghc\ghc-6.10.1\include\mingw etc...
09:39:51 <mae_work> i can use cpphs or gcc -E (comes with std ghc distribution) .. but the include paths aren't automagical
09:39:51 <alexeevg> hello. Anyone knows why I'm getting linking errors from ghci session when trying to use my cabal-install'ed package, though the very same package works fine when the main module is loaded via :l command?
09:40:15 <dcoutts> mae_work: does ghc not put that include dir on the search path?
09:40:17 <jmcarthur> Monad tutorial: (<$>) :: (a -> b) -> (m a -> m b); (=<<) :: (a -> m b) -> (m a -> m b); -- you can enter but you can't leave, mwahaha!
09:40:34 <jeffersonheard> quicksilver: There updated and on hackage.  That wasn't a hard change
09:40:52 <idnar> Hotel Monadia
09:40:56 <jmcarthur> guess it needs pure or return
09:40:59 <jeffersonheard> jmcarthur:  Thinks for the non mathies we should rename monad HotelCalifornia
09:41:13 <jeffersonheard> There would have been an april fools joke
09:41:16 <jeffersonheard> too bad I'm too late
09:41:36 <mae_work> dcoutts: ghc does, but i am using c2hs : \
09:41:42 <mae_work> c2hs is not automagical like ghc
09:41:45 <dcoutts> mae_work: sounds to me like it should just work. If that dir is listed in the rts or base package then Cabal will use it by default.
09:41:58 <dcoutts> mae_work: ah, does Cabal not pass those dirs to c2hs, hmm.
09:42:05 <mae_work> nope
09:42:08 <mae_work> c2hs needs include paths
09:42:10 <dcoutts> mae_work: that'd be another ticket to file.
09:42:14 <mae_work> well actually it needs cpp and include paths
09:42:19 <alexeevg> the misterious error looks like this: Loading package vacuum-ubigraph-0.1.0.2 ... linking ... <interactive>: ... unknown symbol `vacuumzmubigraphzm0zi1zi0zi2_GraphicsziUbigraph_lvl_closure'
09:42:22 <dcoutts> it passes some -I dirs to c2hs
09:42:23 <mae_work> because cpp doesn't existin the default distribution
09:42:29 <Philippa_> simplelet x = v in y == (\x.y) v. monadlet x = v in y == (\x.y) <<= v
09:42:50 <mae_work> dcoutts: oh?
09:42:57 <mae_work> dcoutts: i get "can't find windows.h" etc..
09:43:02 <Philippa_> and something similar about where monadic 'values' come from (*cough*return*cough*)
09:43:19 <mae_work> when i do -dtrace on c2hs
09:43:21 <Philippa_> (which might fit in the remaining 70 chars?)
09:43:57 <dcoutts> mae_work: ah it only uses the include dirs of the current package not of dependent packages. Please file a ticket for that.
09:44:01 <mae_work> i guess the real problem is that cpp is not in the default distro
09:44:16 <dcoutts> mae_work: for hsc2hs it gets the include dirs of dependent packages too
09:44:38 <dcoutts> mae_work: I don't think that's the real problem
09:51:55 <mib_88bs5p4t> who can tell me why Haskell not to support random access to a list ,I think that does not  violate the concept of pure function
09:53:25 <mib_88bs5p4t> this absence  makes it too low effective
09:53:37 <ziman> haskell lists are standard singly linked lists, which do not support O(1) access to an arbitrary element (however, there's O(n) (!!) for lists)
09:53:40 <dmwit> Haskell supports random access to a list in O(n) time; it also supports random access to an array in O(1) time.
09:53:42 <lilac> Monad laws explained / greater-equals-greater and / return form monoid
09:56:01 <Baughn> mib_88bs5p4t: Lists are lists. If you want something not-list, use a not-list - Data.Sequence, for example.
09:56:48 <mmorrow> can anyone think of a decent abbreviation for "employee"
09:56:50 <mmorrow> ?
09:56:55 <Baughn> "serf"
09:56:58 <mmorrow> heh
09:57:06 * mmorrow is tempted to go with "serf"
09:57:11 <Baughn> "empy"
09:57:16 <mmorrow> hmm
09:57:19 <wli> "peon" and "slave" also work.
09:57:30 <mmorrow> Baughn: yeah, i think that's the best it'll get
09:57:30 <Baughn> "robot" works
09:57:48 <Baughn> "Robot" has the advantage of just meaning "worker", without any negative connotations
09:58:00 <mmorrow> "robopeon" could be nice
09:58:13 <edwardk> Data.Sequence is all sorts of awesome
09:58:23 <Baughn> > (length "employee", length "robopeon")
09:58:24 <lambdabot>   (8,8)
09:58:27 <mmorrow> edwardk: yeah, fingertrees are way cool
09:58:37 <jmcarthur> <3 fingertrees
09:58:38 <Baughn> Well, that ain't an abbreviation no more, now is it?
09:58:48 <mmorrow> maybe just "robop"
09:59:04 * mmorrow goes with empy
09:59:14 <edwardk> i just wish 'Measured' didn't have a fundep
09:59:53 <abuiles> mmorrow :ftmn (footman)
10:00:12 <Baughn> Finger-trees are all sorts of awesome, at least theoretically. :P
10:00:32 <Baughn> But I'd hesitate to use them for my buffering, if I wasn't in fact streaming text at 200 B/s
10:01:24 <edwardk> Baughn: don't fingertree the chars, fingertree bytestrings or something chunkier
10:01:38 <Baughn> edwardk: Right. I'm fingertreeing lines, actually
10:01:53 <edwardk> what monoid are you using?
10:02:22 <Baughn> ..don't think I'm using any monoid operations
10:02:33 <edwardk> so just Data.Sequence?
10:02:36 <Baughn> Yep
10:02:37 <jmcarthur> Baughn, are you using Data.Sequence of Data.Fingertree?
10:02:41 <jmcarthur> ah
10:02:45 <jmcarthur> *or
10:03:13 <Baughn> Hum. Data.Fingertree looks rather useful..
10:03:19 <jmcarthur> quite!
10:03:35 <Baughn> I think hackage needs a wiki
10:03:44 <jmcarthur> that would be awesome
10:03:57 * edwardk added a monoid instance for FingerTrees themselves which seemed somewhat metacircular but came in really handy
10:04:07 <Baughn> haskell-wiki would do, if it were possible to register on it..
10:04:11 <jmcarthur> haskell.org kind of suffices at the moment, but it would be nice to have some pages just for covering libraries in hackage
10:04:22 <Baughn> Right, that was the idea
10:04:38 <Baughn> And.. actually, the main hackage interface could be integrated with a wiki - would be even better
10:04:46 <Baughn> Add comments to individual package pages, etc.
10:04:55 <edwardk> right now i tend to just use FingerTree m (c `WithReducer` m) to work around the fact that FingerTree's Measured has that silly fundep
10:06:58 <lilac> @src Measured
10:06:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:07:32 <Baughn> Would anyone be especially peeved if I implemented a wiki entirely in javascript?
10:07:37 <edwardk> lilac: class Measured v a | a -> v where measure :: a -> v
10:07:37 <Baughn> It's just a wild idea, but.. :P
10:07:56 <edwardk> Baughn: tiddlywiki?
10:08:10 <Baughn> edwardk: Something more custom-tailored for hackage
10:08:29 <Baughn> Well, I suppose the obvious and reasonable way would be to hack hackage
10:08:36 <edwardk> i was just referring to the 'javascript only' wiki idea
10:08:59 <jakeluck> what's a better way to apply f to element 4,23,44 of list within a list?
10:09:00 <Saizan> Baughn: the new hackage-server is quite more hackable
10:09:02 <lilac> edwardk: sounds like the standard haskell typeclass problem of one instance per type
10:09:16 <Baughn> Saizan: Sounds good
10:09:18 <lilac> edwardk: removing the fundep probably makes things abiguous
10:09:52 <edwardk> lilac: not for any of the cases i care about ;)
10:10:24 <edwardk> lilac: you have to wind up putting a type annotation on it anyways for almost any practical use to begin with
10:11:32 <kadaver> invertMap :: (Ord k) => M.Map a k -> M.Map k a
10:11:32 <kadaver> invertMap d = M.fromList $ map (\(a,b) -> (b,a)) $ M.toList d
10:11:38 <kadaver> but i have a harder problem
10:12:01 <lilac> me too. mine is "write a C++ compiler". what's yours? :)
10:12:14 <edwardk> @type uncurry (flip id)
10:12:16 <lambdabot> forall a c. (a, a -> c) -> c
10:12:21 <kadaver> invertMap :: (Ord k) => M.Map String [String] -> M.Map String [String]
10:12:24 <ski> jakeluck : if you really must use lists, define `(!!<-) :: Integral n => [a] -> n -> (a -> a) -> [a]'
10:12:28 <lilac> @pl \(a,b) -> (b,a)
10:12:28 <lambdabot> uncurry (flip (,))
10:12:38 <mae_work> dcoutts: no cpp: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3221#a3221
10:12:55 <kadaver> so I want for each "hello", ["blah", "flah"] -> "blah,["hello"] ; "flah",["hello"]
10:13:01 <kadaver> i can do that with a monad
10:13:05 <kadaver> ie state
10:13:19 <kadaver> but I want a better pure version
10:14:28 <jakeluck> ski, isn't that implemented somewhere ?
10:14:35 <ski> not that i know
10:14:39 <mae_work> dcoutts: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3221#a3222
10:14:40 <dcoutts> mae_work: oh, hmm. Perhaps Cabal needs to tell c2hs to use gcc -E and where to find gcc.
10:14:40 <jeffersonheard> question...  are the various flavors of bytestring all using the same ByteString type?   as in...  if I declare in my type signature that I have a bytestring, does it matter if it's a lazy char8 bytestring or a simple word bytestring?
10:15:08 <mae_work> dcoutts: yeah... and also, even when i do gcc -E the include paths aren't passed (although i guess this would happen by default if i use no opts i guess right?)
10:15:10 <lilac> @type (>>= uncurry (map . (,)))
10:15:11 <lambdabot> forall a a1. [(a1, [a])] -> [(a1, a)]
10:15:23 <BMeph> kadaver: Does it have to be State, or are you just throwing random names out now? :)
10:15:32 <jakeluck> i had switcded to intmap, there is overhead in conversion hence looking for something more elegant
10:15:55 <lilac> @type group . sort . (>>= uncurry (map . flip (,)))
10:15:56 <lambdabot> forall a a1. (Ord a1, Ord a) => [(a1, [a])] -> [[(a, a1)]]
10:16:02 <dcoutts> mae_work: that's because gcc -E doesn't have any extra include paths. ghc -E looks them up in the ghc-pkg db. That's what Cabal does too for hsc2hs, but not yet for c2hs.
10:16:15 <dcoutts> mae_work: a ticket will stop me forgetting about this :-)
10:16:41 <lilac> @type map (fst . head &&& map tail) . group . sort . (>>= uncurry (map . flip (,)))
10:16:42 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
10:16:42 <lambdabot>       Expected type: (a, b) -> b1
10:16:42 <lambdabot>       Inferred type: [a1] -> [a1]
10:16:45 <dcoutts> mae_work: I was not aware of the issue on Windows. That's probably a separate ticket.
10:17:45 <mae_work> dcoutts: http://hackage.haskell.org/trac/c2hs/ticket/18#comment:1
10:18:00 <lilac> @type M.fromList . map ((fst . head) &&& map snd) . group . sort . (>>= uncurry (map . flip (,))) . M.toList -- kadaver
10:18:01 <lambdabot> forall a k. (Ord k, Ord a) => M.Map k [a] -> M.Map a [k]
10:18:06 <lilac> kadaver: now solve my problem :)
10:18:16 <mae_work> dcoutts: not sure of what windows ticket you are referring too :\
10:18:53 <dcoutts> mae_work: the fact that c2sh doesn't know where to find gcc when we're on Windows, it's not on the $PATH. But Cabal knows where ghc's copy of gcc lives.
10:21:32 <mae_work> dcoutts: oh i wouldn't knwo about that issue, the first thing i do is to setup PATH
10:21:44 <mae_work> the gcc method you talk about is the method i used to make it work
10:21:48 <mae_work> but the include paths aren't automatic
10:22:35 <edwardk> jeffersonheard: there are two bytestring 'types' the one used in Data.ByteString and the one in Data.ByteString.Lazy
10:22:39 <BMeph> Are any leksah devs on?
10:23:01 <jeffersonheard> that's what I thought...
10:23:04 <edwardk> the Char8 versions just use the same bytestring for their underlying type and provide char oriented methods. the data type doesn't change there
10:23:16 <jeffersonheard> k
10:23:47 <jeffersonheard> wasn't sure if they used the same Data.ByteString.internal.ByteString or not
10:24:00 <BMeph> dcoutts: Rather, GHC knows where GHC's copy of gcc is. It does bug me sometimes that I have gcc already installed, but GHC (and cabal) don't use it.
10:24:12 <edwardk> jeffersonheard: lazy bytestrings are basically [Strict.Bytestring]
10:24:43 <dcoutts> BMeph: but what if there's some incompatibility between the two? By default we should use the same one. You can always set --with-gcc=whatever
10:24:46 <jeffersonheard> makes sense
10:26:46 <dcoutts> mae_work: http://hackage.haskell.org/trac/hackage/ticket/536 and http://hackage.haskell.org/trac/hackage/ticket/537
10:28:31 <MiniCow> Probably a simple question. Is there a shorthand for writing "(Floating a, Floating b) =>" in type declarations? Something like "(Floating a,b) =>"
10:29:06 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3223#a3223 <- how do I make the last one work?
10:29:06 <vixey> no
10:29:15 <ghcai> parsec problem ^^
10:29:28 <Deewiant> MiniCow: 'Fraid not
10:29:40 <MiniCow> Ok, worth a try
10:30:03 <MiniCow> Some of my definitions are getting a bit verbose
10:35:57 <travisbrady> ghcai: eol maybe, i haven't played with parsec in a year though
10:36:20 <insane_> is there a real world haskell pdf version freely available online?
10:36:42 <travisbrady> oh oops, no such thing
10:38:33 <jmcarthur> insane_, would be nice, but i don't think so
10:38:41 <jmcarthur> just html
10:41:22 <ghcai> what is the name of the datastructure thta is a Map but cna ahve several equal keys?
10:41:54 <Duqicnk> Map k (Set v) ?
10:42:26 <jmcarthur> or Map k [v] if v isn't an instance of Ord
10:42:34 <jmcarthur> woah somebody is having problems
10:46:30 <ghcai> Esperanto> parseLine spanish "we	nosotros"
10:46:30 <ghcai> <interactive>:1:21:
10:46:30 <ghcai>     lexical error in string/character literal at character '\t'
10:46:31 <MiniCow> What is GHC trying to tell me with "Inferred type is less polymorphic than expected"?
10:46:34 <huh-what> hmm
10:47:22 <ghcai> \t what is that?
10:47:37 <huh-what> a tab
10:48:11 <mattam> MiniCow: :) Put a type annotation that explicitly states what is polymorphic and you'll probably get where it isn't.
10:49:34 <MiniCow> mattam: Yes, I noticed if I put a type declaration in it seemed to silence it, but I was doping to get away without.
10:49:53 <huh-what> man, I need some project to work on
10:50:07 <huh-what> but it seems like most projects are too advanced for me
10:50:43 <huh-what> (especially the haskell ones)
10:50:58 <MiniCow> huh-what: That's the way it works. You learn as you do them
10:51:01 <travisbrady> ghcai: i annotated your paste, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3223#a3224 wrapping that last line in an optional seems to do the trick
10:51:35 <FunctorSalad> MiniCow: some type system extensions make annotations required...
10:51:40 <BMeph> huh-what: Obviously, your project should be to advance your haskell knowledgge! ;)
10:51:49 <BMeph> s/gg/g/
10:51:50 <FunctorSalad> (not sure off-hand which ones exactly)
10:51:58 <FunctorSalad> rank-n-types I think
10:52:10 <huh-what> well, actually I'm not looking for a haskell project in particular, any language is fine
10:52:22 <huh-what> is there some nice website that perhaps collects such ideas?
10:52:23 <BMeph> huh-what: Blasphemer!
10:52:37 <BMeph> ;)
10:53:00 <huh-what> heh :)
10:53:08 <mattam> MiniCow: maybe the monomorphism restriction is biting you.
10:53:11 <c_wraith> huh-what: You could play with http://projecteuler.net/
10:53:26 <lilac> MiniCow: can you hpaste your code and the error?
10:53:27 <c_wraith> None of those are real programming projects, but they're still kind of fun.
10:53:42 <huh-what> c_wraith: that is a good site, but I've completed around 30 problems or so, and now it feels like they require so much math knowledge
10:53:46 <MiniCow> I'll do a snippet, back in a bit.
10:53:48 <huh-what> that I don't really have
10:54:00 <lilac> MiniCow: do you get a "rigid type variable" error?
10:54:16 <MiniCow> lilac: nope, not seen that one.
10:55:38 <FunctorSalad> rigid monomorphic type variables escapes...
10:56:19 <FunctorSalad> (that was not supposed to make sense)
10:58:43 <MiniCow> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3225
11:00:23 <kniu> @fp (\ req str -> select str commands (Request site GET [] ""))
11:00:24 <lambdabot> (\ req str -> select str commands (Request site GET [] "")) not available
11:00:52 <kniu> what's that command that turns expressions into point-free form?
11:00:58 <c_wraith> it's @pl
11:01:07 <kniu> @pl (\ req str -> select str commands (Request site GET [] ""))
11:01:08 <lambdabot> const (flip (flip select commands) (Request site GET [] []))
11:01:14 <kniu> thanks.
11:01:21 <FunctorSalad> MiniCow: :type tableA_3m ?
11:01:28 <c_wraith> I don't think the point-free version is better in that case. :)
11:01:31 <kniu> :t const
11:01:32 <lambdabot> forall a b. a -> b -> a
11:01:36 <ziman> if I say (xs `par` ys `pseq` foo xs ys) will only the first cons cells be evaluated in parallel?
11:02:10 <MiniCow> FunctorSalad: That's what I'm having to add, and I'm defining it as "(Real a) => [Time a]"
11:02:12 <kniu> @pl (\ req str -> select str commands req)
11:02:12 <lambdabot> flip (flip select commands)
11:02:59 <FunctorSalad> MiniCow: what does ghci claim is the type if you don't annotate (and comment out lookupTable so it loads)?
11:03:23 <FunctorSalad> (seems like it's the monomorphism restriction as mattam said)
11:03:48 <ghcai> cant ghci handle tabs?
11:03:49 <ghcai>    lexical error in string/character literal at character '\t'
11:04:29 <MiniCow> FunctorSalad: [Time Integer]
11:05:01 <ziman> I have a 57M list of values which are completely independent of each other and therefore should parallelize well; however, (parMap rnf) eats all available memory while map runs nicely in O(1)
11:05:06 <FunctorSalad> MiniCow: right, that's the DMR... try adding {-# OPTIONS -XNoMonomorphismRestriction #-} as the first line
11:06:06 <MiniCow> So it's locking the inferred type down to integer, and then can't make it as general as the type declaraction for the function that uses it. Right?
11:06:17 <FunctorSalad> yes
11:06:22 <Baughn> ziman: It'll try do map all of them at once. How /long/ is the list?
11:06:44 <ziman> Baughn, 57M elements
11:06:58 <Baughn> ziman: Quite. Threads are cheap, but 57 million threads is a bit much.
11:07:04 <beelsebob> FunctorSalad: surely {-# LANGUAGE NoMonomorphismRestriction #-}
11:07:06 <Baughn> ziman: You may want to try parListChunk instead
11:07:27 <MiniCow> FunctorSalad: Yup, That option does the trick
11:07:39 <FunctorSalad> beelsebob: never got that. with OPTIONS you can also add -f or -d stuff when necessary ;)
11:07:40 <Baughn> ziman: Or parBuffer with parListChunk, for lazy evaluation
11:08:10 <MiniCow> beelsebob: both work ;-)
11:08:25 <beelsebob> FunctorSalad: I guess I just find it somewhat more descriptive of what it's doing
11:08:37 <ziman> Baughn, i see, thank you
11:08:42 <MiniCow> FunctorSalad: Any downside to hitting that switch?
11:09:40 <ghcai> so ghc cant handle tabs?
11:09:43 <ghcai> ghci
11:10:12 <ziman> ghcai, you can use \t instead of the literate tab character
11:10:20 <ziman> *literal (?)
11:12:08 <FunctorSalad> MiniCow: I don't really know the details, you can look here http://www.haskell.org/haskellwiki/Monomorphism_restriction
11:12:25 <FunctorSalad> "without the restriction, there would be some repeated evaluation where a programmer might expect the evaluation to be shared"
11:12:31 <ghcai> ziman: i did
11:12:35 <MiniCow> Already reading it. It's long and involved though
11:12:37 <FunctorSalad> is this resolved by GHCs automatic SPEC?
11:12:47 <ghcai> but when imparsing "nanana    ahaajaj" it fails with lexicla error
11:13:46 <ziman> ghcai, what do you use for parsing?
11:15:19 <ghcai> parsec
11:16:37 <ziman> and do you read that string from a file?
11:16:58 <JavaKamel99> Fuck England!
11:16:58 <ziman> I still suspect you're feeding ghci with raw tab characters, which ghci does not like
11:17:03 <MiniCow> Anyway, thanks people. At least I understand the issue now, and know how to get around it.
11:17:19 <beelsebob> that's nice JavaKamel99, you got anything productive to say?
11:17:21 <FunctorSalad> (I mean, if the reference to the polymorphic value is replaced by a specialised one by ghc, then sharing will be alright, no?)
11:17:38 <JavaKamel99> FUCK ENGLAND
11:17:39 <pumpkin-> JavaKamel99: that might be difficult...
11:17:40 <JavaKamel99> FUCK ENGLAND
11:17:43 <JavaKamel99> FUCK ENGLAND
11:17:45 <JavaKamel99> FUCK ENGLAND
11:17:48 <JavaKamel99> FUCK ENGLAND
11:17:51 <beelsebob> yeh, I mean... where do you put it?
11:17:51 <JavaKamel99> FUCK ENGLAND
11:17:53 <vixey> you guys: it might be best to just ignore the guy?
11:17:59 <pumpkin-> @where ops
11:17:59 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
11:18:00 <Zao> vixey: What guy? :)
11:18:09 --- mode: ChanServ set +o glguy
11:18:11 --- mode: glguy set +b *!*@91.135.163.63
11:18:21 --- mode: ChanServ set +o dcoutts
11:18:32 --- mode: ChanServ set -o dcoutts
11:19:21 --- mode: glguy set -o glguy
11:24:40 <ghcai> ziman: yes I read it from a file
11:26:52 <travisbrady> ghcai: can you paste your source and the error to hpaste?
11:29:04 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3226#a3226
11:30:29 <ziman> ghcai, you're entering a raw tab char into ghci; the error comes from ghci, not from parsec. Use "wasps\tavispas" instead.
11:30:54 <ziman> and what do you read from file, btw?
11:32:35 <kniu> Is there an alternative to the lookup function which uses a user-supplied comparison function :: a -> b -> Bool to retrieve values from an associative list in the standard Prelude?
11:33:06 <lilac> kniu: you could use find
11:33:16 <lilac> @type find
11:33:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
11:33:19 <pumpkin-> kniu: a -> a ?
11:33:39 <kniu> more like
11:33:49 <dolio> @type find . (. fst)
11:33:51 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe (a, b)
11:34:07 <kniu> lookupWith :: (a -> b -> Bool) -> [(b, c)] -> c
11:34:09 <lilac> @type fmap snd . find . (.fst)
11:34:09 <lambdabot>     Couldn't match expected type `(a, b)'
11:34:10 <lambdabot>            against inferred type `Maybe (a1, b1)'
11:34:10 <lambdabot>       Expected type: (a1 -> Bool) -> [(a1, b1)] -> (a, b)
11:34:19 <mauke> kniu: that type doesn't make sense
11:34:21 <dolio> @type (snd .) . find . (. fst)
11:34:22 <kniu> oh wait
11:34:23 <lambdabot>     Couldn't match expected type `(a, b)'
11:34:23 <lambdabot>            against inferred type `Maybe (a1, b1)'
11:34:23 <lambdabot>     In the second argument of `(.)', namely `find . (. fst)'
11:34:27 <kniu> lookupWith :: (a -> b -> Bool) -> [(b, c)] -> a -> c
11:34:29 <kniu> yeah.
11:34:30 <pumpkin-> :o
11:34:40 <dolio> @type (fmap snd .) . find . (. fst)
11:34:40 <mauke> kniu: still not very good
11:34:41 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe b
11:34:44 <dolio> There we go.
11:34:46 <pumpkin-> what does that extra a buy you?
11:34:55 <kniu> okay.
11:34:56 <lilac> kniu: just partially apply your function. (b -> Bool) -> [(b, c)] -> c
11:35:08 <kniu> That makes more sense.
11:35:21 <lilac> kniu: but what should happen if it's not found?
11:36:03 <kniu> Then let me rephrase:
11:36:06 <pumpkin-> that's why dolio's is good
11:36:15 <aleator> Hi, What is the status of gpugen and/or obsidian and where can I find out more?
11:36:26 <kniu> is there already a function :: (a -> Bool) -> [(a, b)] -> Maybe b in the standard Prelude?
11:36:33 <dolio> Yes, I am great, aren't I?
11:36:41 <mauke> @hoogle (a -> Bool) -> [(a, b)] -> Maybe b
11:36:41 <lambdabot> No results found
11:36:43 <pumpkin-> aleator: the former is aiming to get an alpha out in may, ChilliX told me last night
11:36:54 <pcc1> I need to import identical operators from two separate modules and use them together in the same source file (the operator is (!) from Prelude and Data.Map). how can I do this?
11:36:55 <pumpkin-> aleator: don't know anything about osbidian
11:37:04 <kniu> I really would never have thought of writing "(fmap snd .) . find . (. fst)"
11:37:05 <mauke> pcc1: qualified imports
11:37:14 <aleator> pumpkin-: Cool! I just found out that I'm a cuda programmer for the rest of the year.
11:37:25 <lilac> @unpl (fmal snd .) . find . (. fst)
11:37:25 <pumpkin-> :)
11:37:25 <lambdabot> (\ e k -> fmal snd (find (\ n -> e (fst n)) k))
11:37:30 <pcc1> mauke: I know about qualified imports but how does it work with operators?
11:37:33 <pumpkin-> aleator: I think conal is working on something like that too
11:37:42 <mauke> pcc1: same way it works without operators
11:37:52 <FunctorSalad> pcc1: ModuleAlias.!
11:37:53 <byorgey> @type \p -> listToMaybe . filter (p . fst)
11:37:54 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe (a, b)
11:37:57 <byorgey> how about that?
11:38:02 <ghcai> ziman: what I read? a .txt file a dictionary, eng-spanish
11:38:15 <kniu> :t listToMaybe
11:38:16 <lambdabot> forall a. [a] -> Maybe a
11:38:21 <pumpkin-> @type \p -> fmap snd . listToMaybe . filter (p . fst)
11:38:22 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe b
11:38:27 <byorgey> err, I guess that's not quite the same thing
11:38:28 <lilac> @type \p -> snd <$> find (\x -> p (fst x))
11:38:29 <aleator> pumpkin-: Hmm. I'll have to ask him as well then. BTW. I made some slight progress on the optimization package interface.
11:38:29 <lambdabot>     Couldn't match expected type `(a, b)'
11:38:30 <lambdabot>            against inferred type `Maybe (a1, b1)'
11:38:30 <lambdabot>       Expected type: [(a1, b1)] -> (a, b)
11:38:30 <byorgey> yeah, there you go
11:38:33 <pcc1> ok. "import qualified Prelude as P" --> Not in scope: `P.!'
11:38:39 <pumpkin-> aleator: yay!
11:38:42 <lilac> @type \p xs -> snd <$> find (\x -> p (fst x)) xs
11:38:43 <lambdabot> forall a b. (a -> Bool) -> [(a, b)] -> Maybe b
11:38:46 <ziman> ghcai, but there's no I/O in the snippet you posted
11:39:04 <mauke> pcc1: yeah, that's because there is no ! in the Prelude
11:39:09 <byorgey> kniu: anyway, there isn't already such a function, but there is 'lookup' if the predicate is equality
11:39:12 <byorgey> @type lookup
11:39:13 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
11:39:16 <edwardk> pcc1: LANGUAGE NoImplicitPrelude
11:39:28 <mauke> edwardk: :-|
11:39:30 <edwardk> or did i get what you wanted wrong?
11:39:30 <aleator> pumpkin-: Still takes a while. Currently I've got a simple "vector" typeclass so people can use what they want and optimizers modelled as stream of steps. Still need to port the old stuff to use this.
11:39:36 <ghcai> P.GenParser Char st (String, String)
11:39:42 <ghcai> and
11:39:42 <ghcai> P.GenParser Char () (String, String)
11:39:46 <kniu> I've been using that, but it's limited for what I'm doing.
11:39:46 <pumpkin-> aleator: great!
11:39:51 <edwardk> oh you _wanted_ ! ;)
11:39:54 <ghcai> what is the significance of st and () there?
11:40:01 <edwardk> @type (!)
11:40:03 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
11:40:19 <lilac> ghcai: that's the parser state.
11:40:20 <pcc1> silly me it was !! not !
11:40:36 <edwardk> > array (1,4) [1..4] Data.Array.! 3
11:40:37 <lambdabot>       No instance for (Enum (t, e))
11:40:38 <lambdabot>        arising from the arithmetic sequen...
11:40:40 <byorgey> kniu: sure.  well, just define your own lookupP and then use that, and you can forget how it is implemented =)
11:41:05 <kniu> Already done so, kind of,
11:41:07 <FunctorSalad> @t array
11:41:07 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:41:07 <lilac> lookupWith surely?
11:41:11 <FunctorSalad> @typ array
11:41:12 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
11:41:14 <edwardk> the qualified infix operator syntax makes me vaguely ill
11:41:23 <byorgey> lilac: whatever ;)
11:41:26 <edwardk> a woops
11:41:27 <kniu> but just wondering whether I'm overlapping an existing library function.
11:41:43 <FunctorSalad> edwardk: x `Data.Monoid.mappend` y? ;o
11:41:46 <lilac> edwardk: they're fixing it in haskell' iirc
11:41:54 <vixey> are there any DWIM programming languages
11:42:03 <edwardk> FunctorSalad: x Prelude.+ y ;)
11:42:09 <byorgey> kniu: right. not that I know of.
11:42:10 <vixey> why is ISWIM called ISWIM
11:42:13 <edwardk> liliac: whats the new convention?
11:42:25 <FunctorSalad> I just tried to take it further...
11:42:35 <lilac> edwardk: where fixing means 'x `(Prelude.+)` y'
11:42:46 <FunctorSalad> haha
11:42:53 <pumpkin-> thoughtpolice: yay
11:42:58 <lilac> edwardk: or possibly `Prelude.(+)`
11:43:02 * edwardk no longer feels just 'vaguely' ill about that ;)
11:43:34 <lilac> edwardk: yeah, i think it's the latter. you reference it as Module.(op) and can put it in backticks if you want
11:43:40 <pumpkin-> does anyone know of any good haskell t-shirts or merchandise? I'm trying to convert more people in my department
11:43:45 <lilac> edwardk: it's much better for Prelude..
11:43:58 <FunctorSalad> you could just make a convenience typeclass joining both meanings
11:44:01 <ziman> ghcai, GenParser does not do any file I/O at all
11:44:08 <lament> pumpkin-: you can go door-to-door handing out copies of RWH...
11:44:13 <vixey> > "A" Prelude.++ "A"
11:44:15 <lambdabot>   "AA"
11:44:33 <edwardk> lilac: yeah I can't say the kata syntax of ._Prelude is all that much better but at least it formats nicely ;)
11:44:36 <pumpkin-> lament: my current strategy was to buy a crapload of food and soda for my lab and I left a copy of RWH on the comfy couches next to the food :P
11:44:54 <thoughtpolice> pumpkin-: yeah it kinda does stuff now
11:44:56 <ziman> > ((+1) Prelude.. (*4)) 42
11:44:57 <thoughtpolice> i need to do some more
11:44:58 <lambdabot>   169
11:45:01 <thoughtpolice> then i am going to kick it out the door
11:45:03 <edwardk> a +_int b
11:45:04 <pumpkin-> cool :)
11:45:06 <thoughtpolice> in hopes someone would like to help :)
11:45:43 <FunctorSalad> pumpkin-: that sounds pretty sophisticated actually
11:46:24 <FunctorSalad> (trying to bundle haskell with positive reinforcers?)
11:46:25 <ghcai> P.spaces P.<|> P.char '\t'
11:46:30 <ghcai> Couldn't match expected type `()' against inferred type `Char'
11:46:39 <ghcai> ok i cant OR spaces and char?
11:46:52 <FunctorSalad> we could also have haskell-flavoured crack.
11:46:59 <edwardk> ghcai: you have to bind the char to return () to swallow its return type
11:47:05 <pumpkin-> FunctorSalad: well, obnoxious language evangelists are annoying (I've met a few) so I'm trying to be more subtle
11:47:08 <edwardk> <|> is kind of annoying like that
11:47:34 <FunctorSalad> pumpkin-: *nod*
11:47:36 <edwardk> P.spaces P.<|> (P.char "\t" >> return ())
11:47:45 <edwardk> er single quotes
11:48:58 <edwardk> ghcai: in general you want to return something from each production, so the return types have to match
11:54:32 <kadaver> so what should the return type be?
11:54:33 <huh-what> hmm
11:55:05 <pumpkin-> kadaver: ?
11:55:08 <huh-what> I can't seem to download anything from sourceforge. Anyone else has similar problems? (The project that I'm trying to download is: http://glfw.sourceforge.net/)
11:55:29 <pumpkin-> I hate how shitty sourceforge has become in the past few years
11:55:32 <kadaver> cant I or Parsec.spaces and Parsec.char '\t'?
11:55:34 <kadaver> or = <|>
11:55:53 <mauke> not directly
11:56:49 <edwardk> kadaver: spaces should consume \t anyways ;)
11:56:55 <edwardk> iirc it parses anything that isSpace
11:57:12 <edwardk> er that isSpace returns true for
11:57:23 <malibuu> www.nationtv.org   somali federal Government - they need your help tell all over the world
11:57:31 <kadaver> so how do I solve that?
11:57:46 --- mode: ChanServ set +o mauke
11:58:26 <vixey> :t \ m f inp -> concatMap (uncurry f) (m inp)
11:58:28 <lambdabot> forall t a b b1. (t -> [(a, b)]) -> (a -> b -> [b1]) -> t -> [b1]
11:58:40 <vixey> @pl \ m f inp -> concatMap (uncurry f) (m inp)
11:58:41 <lambdabot> flip ((.) . (=<<) . uncurry)
11:59:15 <ledzipelin> how can I compare if a letter in a string is equal to a character?
11:59:31 <mauke> a == b
11:59:39 <vixey> is there a different name for mplus?
11:59:43 <vixey> like a real name..?
11:59:47 --- mode: mauke set -o mauke
12:00:07 <lilac> ledzipelin: do you want to know if a string contains a certain character?
12:00:48 <ledzipelin> actually the whole thing should split a word at the location, where that 'char' occurs
12:00:48 <lilac> if so, since String is a synonym for [Char], you can use `elem`
12:01:19 <lilac> > break (==' ') "Hello world"
12:01:20 <lambdabot>   ("Hello"," world")
12:01:25 <lilac> like that?
12:01:27 <ledzipelin> yes
12:01:29 <ledzipelin> :)
12:01:37 <lilac> no, that's not possible in haskell, sorry
12:02:03 <LeoD> haha
12:02:11 <ledzipelin> heheheh
12:03:26 <edwardk> @faq
12:03:27 <lambdabot> The answer is: Yes! Haskell can do that.
12:08:11 <travisbrady> ledzipelin: also might be worth looking at data.list.split and bytestring.split http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Char8.html#v%3Asplit
12:08:29 <ledzipelin> thanks
12:08:34 <vixey> ><
12:09:01 <edwardk> vixey: nah thats usually used for join ;)
12:09:08 <edwardk> @type (><)
12:09:10 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
12:09:25 <edwardk> @type (Data.Sequence.><)
12:09:27 <lambdabot> forall a. Data.Sequence.Seq a -> Data.Sequence.Seq a -> Data.Sequence.Seq a
12:09:58 <vixey> edwardk: I got to put termination criteria into the type of my monads
12:10:05 * edwardk realizes that his deliberate misparse probably wasn't as obvious as he thought
12:10:07 <vixey> I think ..
12:10:14 <edwardk> hrmm
12:14:45 <vixey> edwardk: pretty straight forward, it's just lots of typing
12:18:25 <edwardk> vixey: and there lies the rub ;)
12:21:33 <FunctorSalad> edwardk: does one have stuff like "class trait1 trait2 trait3 = traitA traitB" in a trait-based system if two accumulations of traits happen to lead to the same concept?
12:22:17 <edwardk> functorsalad i currently allow aliases, though right now, traits have to be applied to something, even if its just object to make sense.
12:22:40 <edwardk> so, class trait1 trait2 trait3 object = traitA traitB object  is fine and equivalent semantically
12:22:53 <ledzipelin> hm I don't see the reason for the structure of the otherwise case: http://rafb.net/p/DQw43f57.html
12:22:54 <FunctorSalad> edwardk: ah, I wasn't sure there's a distinction between traits and objects
12:23:00 <edwardk> class epimorphism = epic morphism
12:23:35 <ledzipelin> why is it not just:   otherwise = x : rest ?
12:23:45 <edwardk> the noun on the end is a class the others are slightly different since they take context only from the existence of the class on the end, its slightly inhomogeneous but distinguishes nouns from adjectives
12:24:28 <edwardk> it means that a 'product category' is different than a 'category product'
12:24:38 <edwardk> you can subclass multiple classes however
12:24:43 <FunctorSalad> hmm ok, you can't instantiate an adjective by itself
12:24:48 <edwardk> class foo : bar : baz
12:25:38 <edwardk> and there are some modifiers that will make sense only in the context of a single class import, like renaming, hiding, etc.
12:25:48 <FunctorSalad> btw what's the difference between 'ensures' and 'unifies'?
12:26:00 <edwardk> ensures ~ RULES pragmas
12:26:29 <edwardk> unifies basically says that these slots in the object are actually the same entry so defining any one of them defines all of them
12:27:07 <FunctorSalad> hmm, ok
12:27:40 <edwardk> so class optimized endofunctor : optimized functor public carrier unifies carrier = domain = codomain -- means that any attempt to define domain or codomain or carrier will define them all.
12:28:08 <edwardk> its useful because if a bunch of unifies clauses overlap all it does is increase the size of the disjoint set
12:28:47 <ledzipelin> anyone?
12:30:40 <jvoorhis> does anyone here know of any libraries or systems for performing discrete-time frp?
12:31:20 <edwardk> jvoorhis: discrete time as in just events no continuous behaviors?
12:31:27 <Actium> i want to integrate haskell interpretation into an application. what's the best way of doing that?
12:31:40 <edwardk> mueval?
12:31:48 <jvoorhis> edwardk: exactly, just events
12:31:51 * edwardk doesn't know the framework just that such exists
12:32:06 <vixey> I wish I knew what FRP is
12:32:15 <edwardk> jvoorhis: i have a partial model for it, but i haven't got anything that is coherent in aggregate
12:32:34 <jvoorhis> edwardk: what does the model provide?
12:32:46 <edwardk> vixey: functional reactive programming. modeling reactions to events and time continuous behaviors as functions not monads with state
12:33:42 <jvoorhis> from hackage: "[Mueval] is, in short, intended to be a standalone version of Lambdabot's famous evaluation functionality"
12:33:52 <edwardk> jvoorhis: i've been calling it functional reactive relativity. i want a lorentzian causal domains for each agent, i.e. process that can communicate with causality tied to message round trips, so you can know what messages can be known
12:34:03 <edwardk> er s/domains/domain/
12:34:41 <edwardk> jvoorhis: the issue i've been trying to tackle with it is the issue of local clock drift, etc.
12:35:02 <edwardk> i can't ensure FRP's global clock in a distributed environment
12:36:24 <vixey> edwardk: I have some combinators:
12:36:33 <ghcai> P.char '[' P.<|> P.char '/' P.<|> P.char '(' P.<|> P.char '.' P.<|> P.newline
12:36:57 <vixey> epoch = join (,) ; relative = fst ; absolute = snd ; start = liftA2 (-) absolute relative
12:37:09 <vixey> &
12:37:10 <vixey> delay delta f g (rel,abs)
12:37:10 <vixey>  | rel < delta = f (rel,abs)
12:37:10 <vixey>  | otherwise = g (rel-delta,abs)
12:37:32 <ghcai> why doesnt the newline work there?
12:38:35 <vixey> I don't know if this is FRP
12:38:50 <vixey> but it makes sense to put together local and global events in a timeframe
12:39:20 <vixey> oh /distributed/
12:41:07 <travisbrady> ghcai: how is it not working?  error message?
12:41:16 <Actium> is there any library written in C for haskell interpretation?
12:41:25 <pumpkin-> Actium: hugs?
12:41:41 <vixey> Actium: you can call mueval by popen or whatever
12:42:02 <Actium> vixey: mueval looks like it was written in haskell
12:42:08 <vixey> yeah it is....
12:42:15 <Actium> okay i'll look up popen
12:42:21 <Actium> is hugs linkable?
12:42:26 <vixey> you're trying to program C and you don't know popen?
12:42:34 <vixey> sorry, ignore that
12:43:06 <Actium> i don't want to use piping sorry
12:43:45 <Actium> it needs to be linked into the binary (and i am on windows platform)
12:44:40 <ghcai> why doesnt Parsec react on \n?
12:45:06 <pumpkin-> react?
12:45:18 <mauke> ghcai: ask answerable questions, please
12:45:33 <ghcai> yeah parse i correctly
12:45:34 <Actium> pumpkin-: ah. hugs is available in lib form. thanks!
12:45:34 <pumpkin-> there's nothing special about \n, the language you're parsing may or may not care about it
12:45:50 <pumpkin-> Actium: ah, I don't know if it is available as a library
12:46:16 <Actium> http://www.haskell.org/haskellwiki/Implementations: "It has many libraries including Win32 libraries, a foreign interface mechanism to facilitate interoperability with C"
12:46:35 <pumpkin-> ok :)
12:46:43 <pumpkin-> not sure that means hugs itself is a library
12:46:56 <pumpkin-> but I guess we'll see soon enough
12:47:08 <sjanssen> Actium: I don't think that means what you think it does
12:47:13 <bittin-> https://wiki.ubuntu.com/MobileTeam/Meeting/2009/20090402  if somone cares
12:47:19 <ErhardtMundt> hello
12:47:25 <sjanssen> Actium: the FFI is mostly used for Haskell calling C, though the other way is also supported
12:47:32 <ghcai> ah
12:47:32 <ghcai> is \n included in letter?
12:47:32 <ghcai> how do I say only 'abc..z'?
12:47:34 <pumpkin-> oh wow, God is following me on twitter( http://twitter.com/almightygod)
12:47:35 <sjanssen> that also isn't really the same as interpreting Haskell
12:48:53 <Actium> sjanssen: okay. for context, this is to provide fast user-entered expression evaluation with 'cool' features.
12:49:46 <sjanssen> Actium: why not write the whole thing in Haskell?
12:49:58 <vixey> ↓↑mutual lexicographic structural recursion
12:50:25 <BMeph> ghcai: No, and ['a'..'z'], respectively. :)
12:50:52 <pumpkin-> moo
12:50:58 <ulfdoz> hm, hab hier gerade von vor rund einem Jahr mein Ticket rausgekramt. 136er Messung bei 100 auerort, also 32 zu schnell, 75EUR, 1 Punkt und die blichen Verwaltungsgebhren.
12:51:04 <pumpkin-> o.O
12:51:05 <ulfdoz> ewin
12:51:05 <Actium> sjanssen: that would be great, but i'm still learning the language and i have experience with the chosen language of c++
12:51:24 <pumpkin-> Actium: learning to walk on crutches will teach you to walk funny ;)
12:51:38 * pumpkin- pushes Actium in the deep end
12:51:42 <Actium> lol a reaction i was expecting!
12:51:46 <pumpkin-> :)
12:53:00 <Actium> it is still very much at the design stage. the application is a voxel-based modelling package. it is very... volumetric. i would make a formidable first project in haskell
12:53:23 <pumpkin-> oh my, voxels
12:53:48 <ledzipelin> any ideas about: http://rafb.net/p/DQw43f57.html ?
12:54:52 <pumpkin-> why Char -> String -> [String] and not a -> [a] -> [[a]] ?
12:54:52 <edwardk> Actium: ? i used to do a lot of work with volumetric rendering
12:55:04 <Actium> edwardk: what stopped you?
12:55:15 <edwardk> Actium: moved on to greener pastures
12:55:33 <pumpkin-> ledzipelin: also, pattern matching (instead of the guard on ==) will save you from getting an Eq constraint
12:55:36 <edwardk> licensed technology to 3d game companies for volumetric actors back in the day
12:55:43 <pumpkin-> vactors?
12:56:01 <Actium> edwardk: it seems to be making a comeback, especially with the recent surge in raytracing research
12:56:24 <pumpkin-> I like the idea, but cubic complexity is scary :P
12:56:33 <edwardk> yeah. i did a quick test of parallax occlusion map coated voxels and it was nice
12:56:54 <Actium> i skipped past the hybrid methods
12:57:30 <kerlo> ledzipelin: replace "rest xs" with "rest" in both cases.
12:57:32 <ledzipelin> pumpkin: i was told to write that function using that signature. how do I use the guards correctly?
12:57:43 <ledzipelin> kerlo, oh yes, typo
12:57:52 <edwardk> well, my models were rigid models with elastic patches around joints that compiled down from octree renders into a form that you could quickly render into a zbuffer.
12:58:37 <kerlo> ledzipelin: and contrary to pumpkin-'s advice, the guards are necessary; you can't pattern match it.
12:58:39 <Actium> i wrote a regular-grid-of-octrees raycaster on cuda.
12:58:47 <edwardk> i've also done some work in modeling voxel scenes using what i guess in todays buzzword bingo conscious world would be called 'sparse voxel octrees', octrees with quickly stridable arrays at leaves
12:58:54 * mmorrow wonders if he just heard edwardk volunteer to write an ubigraph in haskell
12:58:59 <edwardk> er rather not just at leaves but at any fixed resolution
12:58:59 <mmorrow> :)
12:59:21 <edwardk> mmorrow: hah well, i volunteered to mentor for the lambdacube project that is in the gsoc proposal list ;)
12:59:46 <mmorrow> edwardk: this demo is sooo neat: http://ubietylab.net/ubigraph/content/Demos/random_binary_tree.html
13:00:08 <edwardk> the ubigraph demos are sexy
13:00:15 <mmorrow> edwardk: lambdacube? i'll have to check it out
13:00:18 <mmorrow> edwardk: yesh
13:00:21 <edwardk> i loved the vacuum ubigraph demo
13:00:30 <edwardk> oh btw- awesome work there
13:00:35 <edwardk> on the whole vacuum thing
13:00:36 <mmorrow> thx :)
13:01:10 <edwardk> i've actually made it so every object in kata can currently render itself to a dot file as a result ;)
13:01:15 <mmorrow> i remember when i saw the first graphviz rendered graph (was of an IntMap [Char]) and my mouth hit the floor
13:01:24 <edwardk> hah
13:01:46 <mmorrow> edwardk: ooh, awesome! if you have any cool images i'd love to put them in the gallery section
13:01:49 <edwardk> i've been using it to try to get a feel for how sharing is working or breaking when i run things through my LZ78 data structure, etc.
13:02:39 <edwardk> mmorrow: i'll blog up the LZ78 ones when i get around to making a post on what i'll probably call 'compressive parsing' or something like that
13:02:56 <mmorrow> yeah, it's great for seeing sharing
13:03:05 <Baughn> Now, if only it worked with 6.11
13:03:06 <vixey> can you get sued for implementing LZ78?
13:03:08 <edwardk> right now i'm trying to use the tool to see if i can get LZAP or LZW to be a bigger win
13:03:14 <edwardk> vixey: not any more
13:03:16 <mmorrow> edwardk: heh, nice name
13:03:48 <edwardk> mmorrow: what i'm trying to do now is get it to gobble up long enough strings to be useful
13:04:07 <mmorrow> hmm
13:04:14 <edwardk> but i haven't gotten my bentley mcilroy data structure fully implemented, ive been too distracted by other parts of the library
13:04:26 <mmorrow> heh
13:04:44 <edwardk> that will guarantee that runs of identical structure larger than a certain size will ALL get shared, which should be a huge win
13:05:23 <edwardk> the LZ78 is nice because it can decompress values that have already been mapped, the decompressor never compares values, only looks up indexes in a dictionary
13:05:25 <mmorrow> edwardk: were you around when DAWGs came up yesterday?
13:05:35 <wli> Is edwardk /msg'ing you?
13:05:39 <edwardk> mmorrow: yeah, i'm putting in tries directly
13:05:53 <edwardk> am i?
13:05:53 <mmorrow> i've been thinking about them (just saw the def), and i'm stumped on how to construct one (remotely efficiently)
13:06:17 <kerlo> I feel like implementing LZW with arithmetic coding.
13:06:30 * wli is unconvinced that DAWG's are the way to go for anagrams.
13:06:33 <vixey> kerlo that even makes sense ?
13:06:43 <kerlo> Of course it makes sense.
13:06:48 <edwardk> kerlo: LZSS with arithmetic encoding is nice because the break even gets cheaper
13:07:08 <edwardk> vixey: you compress the dictionary keys you send back and forth, you can use an arithmetic compressor in lieu of a huffman compressor for those
13:07:24 <edwardk> since i'm just using it to get monoid sharing i don't actually compress my dictionaries
13:07:35 <edwardk> er my dictionary keys
13:07:41 <Actium> i could write my application if i made a binding to my renderer lib...
13:07:46 <Actium> ^in haskell.
13:08:00 * wli thinks the way to go for anagrams is multisets of chars.
13:08:50 <sjanssen> Actium: calling C from Haskell is usally easier than calling Haskell from C
13:09:15 <kerlo> Actually, maybe I could just come up with a better compression algorithm myself. I'm sure it couldn't be difficult.
13:09:18 <edwardk> the funny thing is in the interest of maximal sharing i found that it would be nice to be able to look up a value in a Map and get not only the value but the key in some cases, but thats not included in the Map api
13:10:23 <edwardk> kerlo: i did some cheesy 1-bit ADPCM stuff back in the 90s using an arithmetic compressor for game audio in a format that could be decompressed part way and xored together to mix audio streams server side for chatty environments
13:10:27 <kerlo> Assume the text is generated by a Markov process. The only question is what the "prior" Markov process space should be.
13:10:52 <augustss> edwardk: you can always pair up the key with the data and use that as data
13:11:04 <edwardk> augustss: thats what i'm doing now
13:12:06 <Actium> sjanssen: i see. then it now looks like a very attractive option. gtk was planned for gui, which has haskell bindings. everything else still fits. high performance code can stay in c and cuda.
13:12:11 <edwardk> actually one of the reasons why i'm thinking about LZW is the dictionary contains all the tokens a priori so i can do the mapping from values into the monoid in one prepass and then just mash monoids together
13:13:05 <kerlo> > map ord [' '..'~']
13:13:07 <lambdabot>   [32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56...
13:13:25 <kerlo> I wonder what I hoped to accomplish by doing that.
13:13:29 <Botje> "mash monoids together" sounds like a really cool german metal band
13:13:45 <edwardk> so basically just inject everything over an enumFromTo kinda thing and then start working, as it stands i still have to inject the values multiple times
13:14:23 <Gracenotes> Botje: Mashing Mönöids
13:14:31 <Botje> :)
13:14:42 <edwardk> wööt röck döts
13:14:49 <Gracenotes> yes, two umlauts... I went there
13:16:00 * edwardk realized today that I could make a Reducer that used the same trick I used in that incremental fold post
13:16:11 <wchogg> Gracenotes : but it's only acceptable if your provide a .wav of you pronouncing it that way
13:16:16 <edwardk> in fact i can make a monoid that way, a ring, etc.
13:16:22 <edwardk> any dictionary really
13:16:25 <kerlo> Ūse măcrŏns ănd brēves.
13:16:28 <augustss> ååååååå
13:16:35 <edwardk> i understood that intellectually before but hadn't internalized it
13:16:45 <Gracenotes> kerlo: YOUR DIACRITICS FAIL
13:16:50 <Gracenotes> THERE ARE NOT EXTREME ENOUGH
13:16:56 <mauke> üm̈l̈äüẗs̈
13:17:26 <edwardk> heading out
13:17:28 <augustss> that's just too müch
13:17:31 <kerlo> I guess that would be either "Măshĭng Mōnoids" or "Măshĭng Mŏnoids".
13:17:34 <p_l> ノット ディス シttウ アガイン
13:17:36 <Badger> o_O
13:18:02 <p_l> ;-)
13:18:09 <Badger> how do you say m̈ and ẗ and s̈ :P
13:18:19 <kerlo> Anyway, one trit is about 1.5849625 bits.
13:19:03 <kerlo> Therefore, if you want to represent a series of trits in binary, the best way is clearly to simply spread each trit over that many bits.
13:19:04 <wchogg> Badger : last person to try and pronounce an umlaut over a t broke his jaw & is permanently sterile.
13:19:24 <kerlo> Actually, Italians do that on a regular basis.
13:19:50 <kerlo> Viẗoria is a common Italian name.
13:19:58 <kerlo> It's also one that doesn't show up well even on my client.
13:21:22 <vixey> these letters are so happy ッ シ
13:22:20 <mauke> ツ
13:22:21 <bavardage> hehe
13:22:23 <bavardage> nice
13:23:20 <bavardage> some reason my dead umlaut works on ḧ <-- h too
13:24:42 <mauke> (｡◕‿‿◕｡)
13:25:14 <Raevel> dude
13:25:32 <Botje> mauke wins the "most outrageous use of unicode" award
13:25:46 <mauke> ¡ʎɐʎ
13:25:58 <bavardage> I can't see w/e mauke did
13:26:07 <bavardage> well, I see the yay
13:26:10 <Baughn> I see a bunch of skyscrapers
13:26:12 <bavardage> failfont evidently
13:26:15 <olsner> I see what mauke did
13:26:24 <bavardage> what did he doo?!
13:26:26 <Gracenotes> （　≖‿≖）
13:26:28 <Gracenotes> （≖‿≖　）
13:26:30 <bavardage> someone give me a full description
13:26:37 <mauke> U+0028 (28): LEFT PARENTHESIS [(]; U+FF61 (ef bd a1): HALFWIDTH IDEOGRAPHIC FULL STOP [｡]; U+25D5 (e2 97 95): CIRCLE WITH ALL BUT UPPER LEFT QUADRANT BLACK [◕]; U+203F (e2 80 bf): UNDERTIE [‿]; U+203F (e2 80 bf): UNDERTIE [‿]; U+25D5 (e2 97 95): CIRCLE WITH ALL BUT UPPER LEFT QUADRANT BLACK [◕]; U+FF61 (ef bd a1): HALFWIDTH IDEOGRAPHIC FULL STOP [｡]; U+0029 (29): RIGHT PARENTHESIS [)]
13:26:41 <Gracenotes> not as outrageous, but still very ^.^
13:27:20 <tibbe_> remember that the deadline for Google Summer of Code is tomorrow. Hurry and apply! :)
13:27:35 <Twey> bavardage: It's a character
13:27:38 <kerlo> Ĕh. Ī thĭnk ĭt's ŏutrāgeəs ēnəgh tō ūse măcrŏns ănd brēves.
13:27:49 <Baughn> ಠ_ಠ
13:27:54 <augustss> mmmm, macaronis
13:27:57 <kerlo> Ănd schwas.
13:28:06 <Twey> U+1E27 LATIN SMALL LETTER H WITH DIAERESIS
13:28:15 <mauke> argh, no kannada in my font
13:28:23 <augustss> > 1E27
13:28:24 <lambdabot>   1.0e27
13:28:25 <kerlo> Măcərōnē.
13:28:38 <Baughn> (ﾟ⊿ﾟ)?
13:28:40 <Twey> > readHex "1E27"
13:28:41 <lambdabot>   [(7719,"")]
13:28:49 <mauke> ＥＸＴＲＡ ＬＡＲＧＥ
13:29:03 <jmcarthur> let (｡◕‿‿◕｡) = (+) in 4 ｡◕‿‿◕｡ 5
13:29:08 <bavardage> WOO
13:29:09 <jmcarthur> > let (｡◕‿‿◕｡) = (+) in 4 ｡◕‿‿◕｡ 5
13:29:09 * monochrom is listening to: E Moggie «Lambda Calculus for All Computations» 4:25 5.6MB
13:29:09 <Baughn> mauke: (╬ ಠ益ಠ)
13:29:10 <lambdabot>   <no location info>: lexical error at character '\65377'
13:29:12 <jmcarthur> :(
13:29:17 <jmcarthur> "letters"
13:29:46 <Twey> I see none
13:31:15 <kerlo> > "\&"
13:31:17 <lambdabot>   ""
13:31:21 <kerlo> Cool.
13:31:25 <p_l> Baughn: what is that character in the middle?
13:31:45 <Baughn> p_l: I have no freakin' idea
13:31:46 <vixey> lool Baughn
13:31:53 <Baughn> p_l: Actually, I can't even see it
13:31:57 <p_l> ...
13:32:03 <Deewiant> 益?
13:32:06 <p_l> Baughn: get a better font
13:32:16 <Baughn> p_l: But then rxvt would run slower
13:32:58 * mmorrow only has the char '5', 'w', and '+' enabled in his xterm. pure speed baby!!
13:33:31 <p_l> Baughn: 【えき(P); やく; よう】 (n) (1) benefit; use; good; advantage; gain; (2) profit; gains;
13:33:47 <kerlo> @hoogle utf8
13:33:49 <lambdabot> package utf8-light
13:33:49 <lambdabot> package utf8-string
13:33:49 <lambdabot> Distribution.Simple.Utils fromUTF8 :: String -> String
13:34:15 <kerlo> What if I want to convert a String into a UTF-8 [Int] or something?
13:34:33 <mmorrow> , utf8enc "╬ ಠ益ಠ"
13:34:36 <lunabot>  "\226\149\172 \224\178\160\231\155\138\224\178\160"
13:34:55 <augustss> > "\&\&\&\&\&"
13:34:57 <lambdabot>   ""
13:35:02 <mmorrow> magic!!
13:35:16 <mmorrow> what are those for again?
13:35:28 <kerlo> > "\1984\&42"
13:35:30 <lambdabot>   "\1984\&42"
13:35:34 <Deewiant> mmorrow: \1\&2
13:35:44 <mmorrow> ahhhh
13:35:45 <kerlo> > "\198442"
13:35:47 <lambdabot>   "\198442"
13:35:57 <mmorrow> um, i still don't get it
13:36:06 <olsner> Deewiant: was that supposed to be an explanation? :P
13:36:11 <kerlo> @read "\1984\&42 \198442"
13:36:12 <lambdabot>  42 *
13:36:20 <Deewiant> olsner: Yes :-P
13:36:31 <augustss> Very good explanation too
13:36:33 <mmorrow> , ord '\&'
13:36:33 <kerlo> mmorrow: it terminates a numeric escape such as \1984.
13:36:34 <lunabot>  luna: lexical error in string/character literal at character '\''
13:36:50 <olsner> ahaa, now I get it
13:36:54 <mmorrow> ahh, me too
13:36:55 <kerlo> , ord '\&\&\&\&\&7\&\&\&'
13:36:56 <Deewiant> > "\61\62"
13:36:56 <lunabot>  luna: lexical error in string/character literal at character '\\'
13:36:58 <lambdabot>   "=>"
13:37:36 <Deewiant> > ("\61\62", "\6162", "\61\&62")
13:37:38 <lambdabot>   ("=>","\6162","=62")
13:38:12 <augustss> kerlo: \& is not allowed in Char literals
13:45:51 <dolio> > ['\SO','H']
13:45:52 <lambdabot>   "\SO\&H"
13:46:05 <Deewiant> > ord '\SO'
13:46:07 <lambdabot>   14
13:46:33 <dolio> > ord '\SOH'
13:46:34 <lambdabot>   1
13:46:36 <Deewiant> Hmm, sounds like something that is never used anywhere
13:46:57 <bavardage> is there a way of 'just outputting a character'
13:46:57 <Deewiant> Although I guess SOH isn't, either. :-P
13:47:05 <bavardage> without rewriting my code to do monadic things
13:47:07 <Deewiant> ?ty putChar
13:47:07 <lambdabot> Char -> IO ()
13:47:35 <Deewiant> ?hoogle trace
13:47:35 <lambdabot> Debug.Trace trace :: String -> a -> a
13:47:36 <lambdabot> module Debug.Trace
13:47:36 <lambdabot> package traced
13:47:41 <bavardage> can I discard the return value etc
13:47:58 <bavardage> like I want a function that outputs the top of a list and returns the list...
13:48:23 <Baughn> bavardage: Probably, you don't, but if you really want to that's easy enough to write
13:48:32 * ghcai wonders why Parsec treats \n as a letter
13:48:32 <Deewiant> If you want the function to have output as part of its semantics (i.e. you're not just debugging), you need to be in the IO monad.
13:48:52 <bavardage> I'm writing a brainfuck implementation
13:49:06 <bavardage> so I just want to output the value of the current position on the tape
13:49:10 <Baughn> Mm. IO done outside the IO monad /will/ run multiple times, out of order, or frequently not at all
13:49:16 <Baughn> Just write proper monadic code, would you?
13:49:32 * ghcai packs the shotgun and heads towards his ISP
13:49:37 <bavardage> BUT I DON'T KNOW HOW :(
13:49:39 <bavardage> bleh
13:49:48 <Baughn> Then this is a good time to learn. :P
13:49:55 <bavardage> yeah I have read a few things
13:50:07 <bavardage> when something's inside the IO monad
13:50:20 <bavardage> does *everything* called have to be in the io monad
13:50:31 <vixey> bavardage: no
13:50:41 <Baughn> bavardage: Of course not. Then you could never get out of it.
13:50:46 <cads> I miss type classes in lisp!!
13:50:56 <vixey> cads: use CLOS
13:50:58 <Deewiant> Baughn: Well, in a sense you can't. :-P
13:50:59 <Baughn> bavardage: It's the other way around; any function that's in the IO monad can only be called by other functions in the IO monad
13:51:16 <andun> bavardage: the IO inside article on the haskell wiki is fantastic. i highly recommend it :-) http://haskell.org/haskellwiki/IO_inside
13:51:21 <bavardage> yeah, I heard that you can't get out of it :D
13:51:23 <bavardage> uhm kk
13:51:25 <augustss> cads: in Lisp you can do anything!  (At least that's what they keep telling me.)
13:51:26 <Baughn> Deewiant: Eh. Well, /technically/ I suppose the pure functions are computed /inside/ the monad, not the other way around..
13:51:33 <Baughn> Deewiant: But who cares.
13:51:34 <ghcai> how does Parsec treat escpare characters?
13:51:41 <Deewiant> Baughn: Well, it depends on which way your head wraps around it.
13:52:06 <Baughn> bavardage: Right. The inside/outsideness is disputed. But the semantics aren't: IO can call IO, IO can call pure, pure can't call IO.
13:52:20 <kyagrd> ghcai: what do you mean by escape chars?
13:52:23 <p_l> augustss: you can. Doesn't mean it will be easy without laying some groundwork
13:52:27 <bavardage> right
13:52:49 <kyagrd> ghcai: you can parse any charecter using the parser char
13:52:49 <augustss> p_l: I know you can.  Just a few macros later...
13:53:14 <cads> vixey, I'm in clojure, thinking about how I'll implement generic linear spaces. We've got multimethods and macros, but I sure wish I could do it the haskell way
13:53:22 <vixey> guy
13:53:25 <vixey> guh*
13:53:29 <vixey> don't use clojure
13:53:31 <ghcai> kyagrd: \n \r etc
13:53:57 <kyagrd> you can do   char '\n'          char '\r'
13:54:17 <kyagrd> ghcai: There's nothing special about escape chars
13:54:20 <ghcai> yes but they seem to be ignored
13:54:25 <ghcai> P.char '[' P.<|> P.char '/' P.<|> P.char '(' P.<|> P.char '.' P.<|> P.newline P.<|> P.char '\r'
13:55:21 <kyagrd> They are not ignored unless you skip it manually using Parsec.spaces or something
13:55:31 <ghcai> It works wihth / [ etc but not with \n
13:55:31 <ghcai> is \n also a letter?
13:55:38 <kyagrd> '\n
13:55:46 <kyagrd> oops '\n' is just a char
13:56:06 <kyagrd> just like 'a' or 'b' is a Char
13:57:21 <kyagrd> instead of  P.char '[' P.<|> P.char '/' P.<|> P.char '(' P.<|> P.char '.' P.<|> P.newline P.<|> P.char '\r'  you can just say   oneOf "[/(.\n\r"   assuming that P.newline is same as P.char '\n'
13:57:39 <cads> vixey, clojure's appeals to me for a few reasons, and I'd like to make it a replacement for the kind of stuff I use ruby for now. I'd like to hear your criticisms of it though, got any complaints/gossip that's really juicy? :)
13:58:01 <cads> s/that's/that're
13:58:22 <ghcai> cads: clojure helped me on the way to haskell, since it is not forced to eb pure
13:58:38 <ghcai> but  haskell keeped sucking me back and i really appreicate the typesystem
13:59:19 <zakwilson> I like both Clojure and Haskell. They seem to be optimal for different sorts of programs.
13:59:41 <zakwilson> Haskell seems to be better when your problem is fairly well-defined and really needs to be *right*.
13:59:43 <ghcai> but still it doesnt work
13:59:48 <ghcai> Parsers> parseLine spanish "abacterial\tabacteriano, sin bacterias\n"
13:59:48 <ghcai> ("","")
13:59:48 <ghcai> *
13:59:52 <ghcai> Parsers> parseLine spanish "abacterial\tabacteriano, sin bacterias/"
13:59:52 <ghcai> ("abacterial","abacteriano, sin bacterias")
13:59:52 <ghcai> *
14:00:17 <ghcai> zakwilson: give an example of when clojure is better
14:00:46 <zakwilson> Clojure is better when the problem isn't as well-defined. It's better for exploratory programming.
14:01:01 <glguy> ha
14:01:03 <kyagrd> ghcai: You definition of spanish might be not what you intend
14:01:21 <kyagrd> it doesn't parse \t and it would be because you defiend it that way
14:01:49 <zakwilson> The JVM also has certain deployment advantages, especially if you're doing something cross-platform.
14:01:58 <glguy> Is there something like this laying around in a fairly standard place? newtype X a = X (X a -> a)
14:01:59 <ghcai> zakwilson: thats true
14:02:41 <glguy> Haskell is good for when you are going to be making a lot of changes to your progrma, and you want the type system to catch your mistakes along the way
14:03:01 <glguy> you know, exploratory programming
14:03:03 <zakwilson> I don't see Clojure as a good replacement for the sort of thing I would use Ruby for though - the startup time is long, and I use Ruby for short scripts that I want to run fast.
14:03:06 <kyagrd> Haskell is extremely good for writing parsers Parsec rocks!
14:03:31 <zakwilson> Parsec is pretty cool. I just wrote a log file parser with it.
14:03:34 <cads> glguy: describe what you'd like your type to be... but usually you'd say something like   data Tree a = Leaf a | Branch [Tree]
14:03:40 <ghcai> kyard: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=3228#a3228
14:04:03 <glguy> cads, I want exactly the type I specified (modulo the name) :)
14:04:13 <dolio> glguy is obviously writing a type to facilitate writing fixed point combinators. :)
14:04:14 <glguy> and I don't want to keep redefining it everywhere
14:04:25 <zakwilson> I may need to get more used to Haskell's type system to help with exploratory programming.
14:04:29 <cads> dolio: that's what I was wondering too :)
14:04:46 <glguy> otherwise I'm going to have to add it, and reload my ghci session
14:06:31 <ghcai> im gonna kill my isp. seriously
14:06:40 <cads> glguy, say it in english, like  "the type tree x which for any type x, either consists of a leaf of type x, or a branching that contains a list of trees of type x"
14:06:57 <glguy> heh
14:07:08 <glguy> cads, I appreciate your intent, but that really was what I wanted
14:07:16 <glguy> I didn't know if it was laying around in category-extras or something
14:08:23 <dolio> I'd wager it isn't.
14:08:34 <kyagrd> ghcai: I think I see the problem
14:09:00 <cads> glguy:  I'm just curious about what your type wants to do, because I can't wrap my head around it :)
14:09:15 <kyagrd> You are using P.sapce when you parse in spa <- ....
14:09:20 <mmorrow> instance Monad X where return a = X (const a); x@(X f) >>= k = k (f x)
14:09:38 <dolio> It is sort of the standard type for demonstrating why you can't include negative types in a total type theory.
14:09:50 <kyagrd> Note, P.space = oneOf " \t\n\r\t" somethin like this
14:10:19 <glguy> cads, in my case it is for continuations that return continuations
14:10:22 <glguy> that return continuations
14:10:26 <glguy> ... and so on
14:10:44 <dolio> Doesn't monadLib have a Label type or something for that?
14:10:56 <kyagrd> So, if you put the \n at the end of your string spa will try to parse to the end since parsers try to do longest match
14:11:06 <glguy> dolio, if I wanted to do this the easy way, I'd be done already ;)
14:11:26 <kyagrd> the problem is the next line (line #20) will not succeed since you have no input left
14:13:54 <kyagrd> ghcai: I think you may want to define the syntax that you want to parse more clearly
14:14:17 <kniu> @pl (\r -> mapM_ . privmsg r)
14:14:18 <lambdabot> (mapM_ .) . privmsg
14:16:46 <kniu> Sometimes, it's really hard to understand WHY those two expressions are equivalent.
14:17:21 <kadaver> eh i missed if someone posted soemthing to me
14:17:42 <vixey> kniu: eta expand and simplify
14:17:53 <kniu> what's eta expand?
14:18:02 <conal> kniu: you can write (result.result) mapM_ privmsg, saying that you're applying mapM_ to the result of th eresult of privmsg.
14:18:12 <conal> kniu: where result = (.) = fmap
14:18:33 * kadaver plants a napalm-bomb at the ISP owners car and murders all his children
14:18:36 <vixey> I find that argument/result stuff completely confusing
14:18:58 <conal> vixey: if you play with first & second, you'll find it's the same game.
14:19:07 <vixey> :t first
14:19:09 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
14:19:14 <vixey> I don't use these either :/
14:19:16 <conal> the important thing is to think of result ((.)) as *unary*
14:19:33 <kadaver> kyagrd: why does it consume the whole line?
14:19:33 <kadaver> why does itthen work for . and / but not \n ?
14:19:47 <travisbrady> what do we call this "(,)" function?  and is there non-symbolic version?
14:20:01 <vixey> @let pair = (,)
14:20:02 <lambdabot>  Defined.
14:20:20 <kyagrd> kadaver - which program r u talking about? (are you the same persion as ghcai?)
14:20:35 <travisbrady> > pair 5 6
14:20:36 <lambdabot>   (5,6)
14:23:01 <kyagrd> I'm leaving now but to repeat what I said to ghcai, P.space in line#19 eats up the last \n if it can parse and don't leave any for line#20 in the spanish parser
14:24:11 <cads> have you guys read about pluggable type systems?
14:24:15 <conal> vixey: this type might help: result :: (b -> b') -> ((a -> b) -> (a -> b')) .  so 'result f' lifts f to work on results.
14:24:32 <vixey> conal it looks like compose backwards
14:25:11 <conal> vixey: result = (.)
14:25:20 <conal> vixey: but written to emphasize a *unary* perspective
14:25:35 <conal> vixey: for composability.
14:26:00 <conal> composable compose
14:26:25 <conal> and it generalizes nicely, to "deep arrows"
14:27:13 <bvck> Me again. More of a category theory question than Haskell, but since folks had been kind enough in the past...Can a morphism have multiple domain and/or co-domains?
14:27:37 <neoswish> hey guys, what the complexity of (!!) for haskell lists, O(1) or O(n)?
14:27:49 <glguy> bvck, I think that since the sum of two domains is a new domain, that you probably can't
14:27:58 <conal> neoswish: O(n)
14:28:08 <cads> neoswish: think about that for a sex
14:28:12 <BMeph> nwoswish: O(x), where 'x' is the argument . :)
14:28:20 <cads> sec!
14:28:20 <conal> neoswish: there are also balanced tree types.  and arrays.
14:28:38 <neoswish> yeh, i better then use arrays for my problem)
14:28:39 <BMeph> Er, *neoswish, I meant.
14:29:07 <glguy> bvck, someone just told me that "multi-categories" can have that property, but that he'd never really seen such things used
14:30:02 <wli> Allegories and relators or something?
14:30:11 <bvck> glguy, thanks. I will look up multi-categories now...:)
14:31:56 <vixey> I think Allegories still have one dom and cod
14:32:14 <vixey> just that they also have got lubs and stuff, iirc
14:32:23 <BMeph> conal: I wonder, why you chose "Sequence" (or should that be 'sequence') as your example for finite/discrete things, when Arrays ("arrays"? :) ) have the syntax of specifying the bounds, as do your seqments. :)
14:34:45 <conal> BMeph: i guess i was going for semantics, rather than syntax.  and i mean sequence inclusively of lists, finger trees, arrays, etc.
14:36:13 <bavardage> how can I convert an int to a character?
14:36:21 <dolio> Heh "an associativity condition (involving a further level of composition) that takes a long time to write down."
14:36:22 <bavardage> as in ascii int...
14:36:22 <matthew-_> any gtk2hs gurus around?
14:36:23 <conal> toEnum
14:36:25 <matthew-_> I have scrolling issues
14:36:27 <bavardage> ty
14:36:28 <conal> @type toEnum
14:36:29 <lambdabot> forall a. (Enum a) => Int -> a
14:36:54 <dcoutts> matthew-_: if you don't find anyone, ask on the mailing list. I'm afraid I don't have time now.
14:37:25 <conal> bavardage: there's also Data.chr
14:38:21 <bavardage> conal: what are the advantages of this?
14:38:30 <conal> bavardage: i don't know
14:38:39 <bavardage> hmm
14:38:44 <bavardage> toEnum works fine atm
14:38:57 <vininim> mmmm maybe we need an emacs interface to evince
14:38:58 <BMeph> conal: I figured as such (thus all of the parenthetized items). :)
14:39:03 <matthew-_> dcoutts: ok, thanks. It's quite quick though. I have a scrolled window, a viewport in that, and a drawingarea in that. And I'm trying to programmatically change the scroll value. Whenever I change it (either through a new adjustment or using adjustmentSetValue), the process locks up with 100% CPU and never responds again
14:39:11 <vininim> err wrong channel, as usual
14:39:33 <Axman6> bavardage: though Data.Char.chr is designed specifically for that purpose
14:39:49 <Philippa_> bvck: if you want multiple domains and codomains, what you have isn't a morphism - it's some kind of collection of morphisms
14:39:51 <Philippa_> but that's okay
14:39:56 <dcoutts> matthew-_: event loop?
14:40:19 <dolio> Well, multicategories do have morphisms with multiple domains.
14:40:23 <dolio> Not codomains, though.
14:40:38 <Gracenotes> o:
14:40:40 <dolio> So far as I can tell.
14:41:52 <matthew-_> dcoutts: I don't see how it can be
14:42:18 <dolio> I'm not sure how that's different than looking at morphisms from products, though.
14:42:31 <dolio> Maybe it applies even when you can't form products?
14:42:32 <dcoutts> matthew-_: the other issue with drawing area inside a viewport is you need to set the size of the drawing area, otherwise it always just sizes to the viewport
14:42:42 <matthew-_> yeah, done that
14:42:47 <latitude> @type foldr
14:42:47 <dcoutts> matthew-_: and check the settings of the adjustment are sensible
14:42:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:42:58 <latitude> why is there b?
14:43:01 <matthew-_> dcoutts: actually, when they're insane, it doesn't lock
14:43:07 <matthew-_> (like negative values)
14:43:08 <latitude> why not just all as
14:43:11 <matthew-_> when they're sane, then it locs
14:43:14 <dcoutts> matthew-_: I can forward a test prog for drawing area if it helps at all
14:43:34 <dcoutts> matthew-_: I mean scrolling a drawing area inside a viewport/scrolled window
14:43:58 <matthew-_> dcoutts: that'd be great, thanks. I'm sure I'm just doing something dumb somewhere
14:44:40 <Axman6> latitude: all a's would be a lot less useful
14:44:58 <bvck> Philippa, the reason for the question is I am playing with a haskell implementation of a category and that has defined an 'initial object' as one object and only one morphism.
14:45:33 <latitude> ooh, i got it
14:45:39 <latitude> b can also be a
14:45:42 <bvck> Since there are multiple objects in the category, my thinking is that morphism has multiple-codomains and hence the question.
14:45:51 <Axman6> > foldl (\c n -> n*10 + ord c - orc '0') "" "12345"
14:45:52 <lambdabot>   Not in scope: `orc'
14:45:56 <Axman6> > foldl (\c n -> n*10 + ord c - ord '0') "" "12345"
14:45:57 <latitude> they *may* be different, but they *should not* right?
14:45:58 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
14:46:01 <Axman6> bah
14:46:17 <dolio> bvck: There's a unique morphism for every target object.
14:46:19 <Axman6> > foldl (\c n -> n*10 + (ord c - ord '0')) "" "12345"
14:46:20 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
14:46:21 <latitude> i mean a and b types
14:46:28 <Axman6> :t (\c n -> n*10 + (ord c - ord '0'))
14:46:29 <lambdabot> Char -> Int -> Int
14:46:44 <Axman6> > foldl (\c n -> n*10 + (ord c - ord '0')) 0 "12345"
14:46:45 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
14:46:48 <Axman6> >_<
14:46:52 <bvck> dolio, that was my understanding too, but this implementation threw me off so wanted to confirm.
14:46:53 <Axman6> too early in the morning
14:47:21 <dolio> Although you could totally specify all those by giving the uniqe morphism to the product of every object.
14:47:28 <dolio> Assuming products exist.
14:48:16 <Axman6> :t foldl
14:48:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:48:28 <dcoutts> matthew-_: sent
14:48:53 <Axman6> rawr,whatever, i do't even care -_-
14:48:58 <Axman6> stupid foldl
14:49:05 <filip_s> hello, has anyone tried to get the BerkeleyDB bindings for Haskell to work?
14:49:27 <matthew-_> dcoutts: gah, I've just figured it. I'm using an MVar to hold state. The MVar is taken when I make the adjustment, but it's immediately calling the expose event which sits waiting for the state MVar
14:49:32 <matthew-_> it's a fricking deadlock
14:49:39 <matthew-_> why is gtk using so many threads?!
14:49:50 <kadaver> why is the Linux kernelgrowing so fast? what are the new stuff? new drivers?
14:50:05 <Zao> They're rewriting it all in Haskell.
14:50:22 <Axman6> with perl for the low level stuff
14:50:25 <dcoutts> matthew-_: ahh. Gtk itself doesn't use any threads.
14:50:43 <dcoutts> well, one I guess :-)
14:50:56 <matthew-_> dcoutts: well I'm just a bit surprised - the SWT model is that there's _one_ thread that comes from the GUI and you do all your GUI work in that and only that
14:51:01 <matthew-_> here there seems to be > 1 GUI threads
14:51:05 <matthew-_> which surprises me
14:51:32 <matthew-_> or rather, adjusting the scroll value is synchronous
14:52:00 <dcoutts> matthew-_: really? I thought the SWT model used a GUI thread and then you could do anything else from any other thread. Gtk+ uses a single thread, the same one as the rest of your program. It can be used with only a single thread in the entire process.
14:52:40 <dcoutts> matthew-_: actually that was AWT, I don't know about SWT. ATW/Swing forks a dedicated thread to run the GUI
14:52:41 <BMeph> > foldl (\n c -> n*10 + (ord c - ord '0')) 0 "12345"
14:52:42 <lambdabot>   12345
14:52:53 <BMeph> Axman6: Nice foldl! ;)
14:53:03 <BMeph> > foldl' (\n c -> n*10 + (ord c - ord '0')) 0 "12345"
14:53:04 <lambdabot>   12345
14:53:12 <Axman6> whut?
14:53:14 <Axman6> >_<
14:53:21 <Axman6> why's it work for you?
14:53:42 <Herculezz> anyone in here know VB?
14:53:42 <matthew-_> yes, AWT does one thread, but then wraps everything else up and does all the switching itself under the bonnet. this is why it tends to be slowish
14:53:44 <BMeph> Axman6: Order of arguments, m'man. ;)
14:53:58 <Axman6> rawr!
14:54:01 <matthew-_> dcoutts: effectively what I end up doing is something like newMVar () >>= \mv -> modifyMVar_ mv (\_ -> print "a" >> takeMVar mv >> print "b")
14:54:36 <matthew-_> dcoutts: which in java works as locks are reentrant. I guess the moral here is not to use MVars as reentrant locks
14:55:58 <dcoutts> matthew-_: ah yes
14:59:10 * RayNbow is starting to understand loeb :: Functor a => a (a x -> x) -> a x...
14:59:32 <RayNbow> (although I don't like sigfpe's choice of type variables here :p)
15:00:47 <Arnar> hi all..
15:01:03 <Arnar> so, haskell question of the day: how do I get bibtex to recognize that SPJ has two last names?
15:01:09 <BMeph> RayNbow: What's wrong with f and b? :)
15:01:16 <pejo> Arnar, {Peyton Jones}
15:01:27 <Arnar> pejo: ah, excellent.. thanks :)
15:01:33 <jmcarthur> Arnar, Peyton-Jones doesn't work?
15:01:55 <Arnar> jmcarthur: won't that print a hyphen? (maybe that's how it's supposed to be..)
15:02:05 <jmcarthur> Arnar, yeah, the hyphen is part of his name
15:02:15 <conal> jmcarthur: i don't think so
15:02:21 <jmcarthur> conal, really? i thought it was
15:02:36 <Arnar> hmm
15:02:41 <Arnar> wikipedia says no hyphen..
15:02:45 <Arnar> MSR webpage has hyphen
15:02:50 <conal> i use the braces trick in bibtex
15:02:51 <jmcarthur> ugh, slow internet prevents me from checking
15:03:07 <pejo> Arnar, but his snailmail is without hyphen.
15:03:21 <RayNbow> BMeph: don't ask me, ask sigfpe :p
15:03:39 <Zao> cvs-ghc has S P-J.
15:03:42 <Arnar> pejo: yeah, pages that presumably are written by him don't have hyphen: http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
15:03:55 <jmcarthur> i'm 90% sure the hyphen is part of his name...
15:04:04 <chessguy> the name on SPJ's email address has a hyphen
15:04:23 <jmcarthur> http://www.haskell.org/pipermail/haskell-cafe/2008-December/052589.html
15:04:36 <jmcarthur> his name next to his email is hyphenated
15:05:05 <conal> i've known simon a long time.  if there's a hyphen, it's recent.
15:05:07 <chessguy> jmcarthur:  that's what i just said...
15:05:12 <bavardage> how can I do anything with getchar?
15:05:17 <bavardage> how can I get the char out of the IO?
15:05:25 <Arnar> looks like I opened a huge can of worms ...
15:05:25 <conal> maybe he got tired of showing up under "Jones" in bibliographies
15:05:56 <pejo> Or it's a limitation of some of the systems at Microsoft..
15:06:20 <Saizan> bavardage: do c <- getChar; <use with (c :: Char) here <
15:06:27 <bavardage> oh kk
15:06:30 <bavardage> :D
15:06:50 <Arnar> *digs up a paper by spj*
15:07:15 <Arnar> no hyphen on his papers.. so I'll go with that :)
15:11:55 <kadaver> anyone here good with machine translation? i ahve now a working dictionary and the translation is a bit meh obv since it jsut does direct translation and no grammars
15:12:10 <kadaver> Just adding the use of ngrams from a huge corpus does a big difference right?
15:12:25 <mmorrow> bavardage:
15:12:28 <mmorrow> @type let runIt program = do input <- getLine; return (program input) in runInt
15:12:29 <lambdabot> Not in scope: `runInt'
15:12:32 <mmorrow> @type let runIt program = do input <- getLine; return (program input) in runIt
15:12:34 <lambdabot> forall t. (String -> t) -> IO t
15:12:47 <bavardage> thanks..
15:12:53 <bavardage> I got it working with Saizan's prompt
15:13:34 <dmwit> The sneaky thing about IO is that you never get out of it.
15:13:40 <dmwit> You drag everything else *into* it, instead.
15:13:51 <jmcarthur> it's a trap!
15:14:14 <wjt> So. I want to hook up my test suite to `cabal test`. The best way I can see to do it currently is make the test hook run `runhaskell path/to/tests.hs`. Is it possible to have the test executable compiled alongside, but not installed by cabal install, only used by cabal test?
15:14:40 <pumpkin-> onoes
15:14:50 <dcoutts> wjt: not easily yet.
15:14:53 <edwardk> preflex: seen beelsebob
15:14:54 <preflex>  beelsebob was last seen on #haskell 3 hours, 57 minutes and 3 seconds ago, saying: yeh, I mean... where do you put it?
15:14:55 <ackbar> it's a trap!
15:14:56 <ackbar> there
15:15:06 <dcoutts> wjt: it's a major wishlist item
15:15:13 <bavardage> what's the best way to do paren matching?
15:15:16 <wjt> dcoutts: yeah, i found the wishlist bug. hoped it had been secretly fixed :(
15:15:36 <dcoutts> wjt: heh, sorry, we keep it depressingly up to date
15:15:36 <wjt> dcoutts: so just spawning runhaskel test-suite.hs is the best option atm?
15:15:37 <bavardage> atm I'm just doing ugly walk back/forward with 'levels'
15:15:38 <dmwit> bavardage: One second, I have a post on haskell.reddit about it.
15:15:43 <bavardage> oh nice
15:15:53 <dcoutts> wjt: if it works it's reasonable for now.
15:16:02 <wjt> dcoutts: okay, thanks :)
15:16:17 <dcoutts> wjt: and add yourself to the cc list on that ticket
15:17:18 <dmwit> http://www.reddit.com/r/haskell/comments/7v47r/matching_brackets_in_haskell_passing_curiosity/c07howj
15:17:20 <dmwit> bavardage: ^^
15:17:29 <bavardage> ty :D
15:17:50 <wjt> dcoutts: oh hmm, the ticket i fonud is on the ghc trac not the cabal one
15:19:51 <wjt> oh trac. make it more obvious how to CC myself
15:20:25 <skorpan> trac is horrible at times
15:20:30 <skorpan> but much better than other crap out there
15:21:46 <marcot> http://hackage.haskell.org/trac/summer-of-code/ticket/1575
15:21:50 <marcot> Is this serious?
15:22:11 <pumpkin> lol
15:22:29 <pumpkin> check out the attachment
15:22:34 <pumpkin> I sort of doubt it ;)
15:22:41 <marcot> I just saw it.
15:22:41 <marcot> =)
15:23:38 <monochrom> By the time of "xfactoryfactory" all seriousness has disappeared, in all seriousness.
15:24:22 <jmcarthur> anybody manage to get ubigraph on arch linux to play with vacuum-ubigraph?
15:25:18 <dcoutts> wjt: ah, you found the ticket in the cabal trac I see
15:26:24 <wjt> :)
15:27:45 <Nafai> marcot: Sadly, the joke at the end about xfactoryfactory...I've seen Java classes named FooFactoryFactory before (obviously not Foo, but...)
15:28:18 <marcot> Nafai: I don't know so much about Java to got this one.
15:28:31 <edwardk> factory factories exist, this fact has pained me since i first saw one
15:28:40 <glguy> marcot, search for the factory design pattern
15:29:09 * p_l considers appearance of a design pattern an anti-pattern
15:30:31 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3233#a3233 <- why does invertMap' return a fucntion?
15:30:46 <lament> in haskell every single three argument function is a factory factory
15:30:53 <kadaver> as opposed to a [(String, String)]
15:30:55 <lament> wouldn't you say that's pretty bad!
15:32:04 <pumpkin> kadaver: because you haven't evaluated it all the way?
15:32:18 * shapr boings quietly
15:32:47 <pumpkin> be proud of thine boings!
15:33:04 <edwardk> lament: yeah but we typically get constructor dependency injection more or less for free, so its all a wash ;)
15:33:47 <Nafai> shapr!
15:33:52 <kadaver> wow that google ticket is awesome.
15:34:47 <pastah> i need to do argument parsing for a program
15:34:53 <pastah> parsec seems a bit overkill
15:34:58 <mmorrow> jmcarthur: what problems are you having?
15:35:04 <mmorrow> (i have it working on fedora)
15:35:09 <ddarius> pastah: Use hsgetopt (or whetever it's called)
15:36:28 <RayNbow> > take 10 $ loeb $ const 0 : const 1 : [liftA2 (+) (!!n) (!!pred n) | n <- [1..]]  -- extremely inefficient way of computing the first 10 Fibonacci numbers :p
15:36:30 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
15:37:18 <pastah> ddarius: parseargs?
15:37:19 <mmorrow> jmcarthur: (i assume you've started the (closed src, distributed-as-a-binary) ubigraph server and are looking at the black empty window)
15:37:20 <edwardk> haskell, turning paradoxes into convenience functions since 1990.
15:37:25 <pastah> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parseargs
15:37:41 <jmcarthur> mmorrow, i simply can't find ubigraph in aur and don't know how to install the deb/rpm. nothing wrong with vacuum or anything per se
15:38:05 <edwardk> jmcarthur: vacuum can be installed without anything
15:38:12 <jmcarthur> mmorrow, i will take some time later maybe and make a proper pacman package for ubigraph
15:38:17 <jmcarthur> edwardk, ubigraph, not vacuum
15:38:17 <edwardk> jmcarthur the other stuff just makes it more useful ;)
15:38:21 <edwardk> ah
15:38:21 <jmcarthur> right
15:38:29 <harovali1> what do I have to import in ghci to get ord function in scope?
15:38:37 <jmcarthur> i've been playing with vacuum-cairo a lot
15:38:39 <mmorrow> jmcarthur: i just got the tarball, unpacked it in a dir, cd'ed and ./bin/ubigraph_server &
15:38:47 <edwardk> harovali1: Data.Char
15:38:49 <mmorrow> jmcarthur: cool :)
15:38:56 <jmcarthur> oh, i didn't realize there was a tarball
15:38:58 * jmcarthur looks again
15:39:42 <jmcarthur> oh, are the downloads all tarballs? i assumed they would be debs and rpms
15:39:53 <harovali1> edwardk: thanks
15:40:31 <mmorrow> jmcarthur: i just looked, i think so
15:40:43 <augustss> harovali1: you don't need ord, there's fromEnum
15:41:36 <harovali1> augustss: in order to get the ascii number of a character?
15:41:47 <jmcarthur> mmorrow, oh nice. well, nevermind then! :)
15:41:55 <mmorrow> jmcarthur: :)
15:43:47 <mmorrow> jmcarthur: one tip i've noticed is that you'll want to toggle labels to off *before* you draw any large graphs
15:44:25 <mmorrow> labels seems to slow it to a slow-motion crawl
15:44:29 <mmorrow> *seem
15:45:02 <augustss> harovali1: yes
15:45:17 <augustss> harovali1: It works on any Enum type
15:45:23 <augustss> > fromEnum 'a'
15:45:25 <lambdabot>   97
15:45:44 <augustss> > toEnum 98 :: Char
15:45:46 <lambdabot>   'b'
15:45:59 <augustss> > fromEnum True
15:46:01 <lambdabot>   1
15:46:34 <wjt> rrrgh. cabal-install depends on parsec 2 but only parsec 3 is in Debian :'(
15:48:40 <jmcarthur> mmorrow, ah yeah, that seems a good idea
15:51:46 <ddarius> pastah: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
15:55:54 <harovali1> augustss thanks
15:56:01 <guenni> does "wrt" mean "with respect to" ?
15:56:19 <harovali1> guenni: yes sort of, with regards to
15:56:41 <guenni> harovali1: thx
16:00:57 <mmorrow> jmcarthur: heh, i forgot to mention the complete-lockup-if-labels-are-on part...
16:02:04 <mmorrow> guenni: i read "wrt" as "with respect to" myself
16:02:15 <mmorrow> guenni: i read "wrt" as "with respect to", myself
16:03:24 <Gracenotes> have fun campaigning
16:03:26 <Gracenotes> or however you spell it
16:03:28 <Gracenotes> lol
16:03:46 <pumpkin> university of illinois urbana campaign?
16:04:35 <pumpkin> :P
16:04:52 <guenni> mmorrow: hi!
16:04:55 <Gracenotes> pumpkin: Mark Foley's private chats that were published and from which he was convicted.
16:05:18 <guenni> Gracenotes: whom?
16:05:36 <pumpkin> ?
16:06:09 <Gracenotes> >_> these are historical documents here, people!
16:06:39 <pumpkin> I don't get how that fits in with campaigning or me writing stupid misspellings of university names
16:08:50 <kniu> @pl (\p -> (: filter (\q -> fst p /= fst q)) l)
16:08:51 <lambdabot> (l :) . filter . (. fst) . (/=) . fst
16:08:54 <kniu> oh lord.
16:09:31 <pumpkin> that's an odd way for you to write the original one too
16:09:56 <kniu> Wait...
16:10:08 <kniu> @pl (\p -> (: filter (\q -> fst p /= fst q) l))
16:10:09 <lambdabot> flip (:) . flip filter l . (. fst) . (/=) . fst
16:10:15 <kniu> There, that makes more sense.
16:11:17 <kniu> The pointful form is actually shorter and more readable.
16:11:41 <augustss__> that happens a lot
16:11:52 <Gracenotes> uh, \p v -> v : filter (\q -> fst p /= fst q) l?
16:13:04 <ghcai> > (map . map) concat [[[1],[2]]]
16:13:05 <lambdabot>       No instance for (Num [a])
16:13:06 <lambdabot>        arising from the literal `1' at <inter...
16:13:13 <kniu> Gracenotes, ain't that the same thing?
16:13:18 <ghcai> > (map . map) concat [[[[1]],[[2]]]]
16:13:20 <lambdabot>   [[[1],[2]]]
16:13:24 <Gracenotes> just making sure.
16:13:29 <ghcai> > map concat [[[[1]],[[2]]]]
16:13:31 <lambdabot>   [[[1],[2]]]
16:13:41 <Gracenotes> kniu: sometimes pl isn't always smart enough to come up with function combinators, thouh
16:13:42 <Gracenotes> *though
16:13:47 <kniu> huh.
16:13:52 <Gracenotes> @pl \p v -> v : filter (((/=) `on` fst) p) l
16:13:52 <lambdabot> flip (:) . flip filter l . ((/=) `on` fst)
16:14:02 <Gracenotes> ^ somewhat more readable, I think
16:14:10 <kniu> what's `on`?
16:14:12 <kniu> :t on
16:14:13 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:14:18 <Gracenotes> it's in Data.Function
16:14:51 <kniu> Ah, I see what it does now.
16:15:15 <poucet> Is there any reason why vacuum requires EXACTLY 6.10.1
16:15:21 <poucet> And not, for instance, 6.10.2?
16:15:49 <skorpan> what was that website called where people ask tech questions and people answer and get points?
16:15:59 <skorpan> something like "syntax overflow" ...?
16:16:10 <tessier_> stackoverflow
16:16:13 <skorpan> thanks
16:22:42 <alexbobp> I seem to be able to write "(\x -> x)::(Int -> Int)", but is there a way to only specify the type of the parameter?  I was hoping for (\x::Int -> x) to do what I wanted, but alas, it's a syntax error.
16:24:34 <pumpkin> alexbobp: there's an extension that allows that iirc
16:24:40 <pumpkin> doesn't the syntax error suggest something to you?
16:24:46 <ddarius> With a GHC extension you can write \(x :: Int) -> x
16:24:46 <mauke> (\x -> x :: Int)
16:25:19 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#pattern-type-sigs
16:26:00 <alexbobp> okay, thanks
16:32:58 <ghcai> isnt parsec Left supposed to catch all errors?
16:33:02 <ghcai> ("abdomen","*** Exception: Prelude.head: empty list
16:33:02 <ghcai> *
16:33:30 <mauke> no, only parse failures
16:36:08 <kerlo> > \x :: Int -> x
16:36:09 <lambdabot>       Overlapping instances for Show (t -> t)
16:36:10 <lambdabot>        arising from a use of `s...
16:36:20 <kerlo> > (\x :: Int -> x) 45
16:36:22 <lambdabot>   Ignoring (deprecated) result type signature Int
16:36:43 <ghcai> how did I specify end of parse again?
16:36:48 <ghcai> P.eof?
16:36:53 <kerlo> > ((\x :: Int) -> x) 45
16:36:55 <lambdabot>   <no location info>: parse error on input `)'
16:37:04 <kerlo> > (\(x :: Int) -> x) 45
16:37:06 <lambdabot>   45
16:37:13 <kerlo> Huh.
16:38:38 <TSC> ghcai: Yeah, eof matched end-of-input
16:38:43 <TSC> matches, that is
16:39:28 <Gracenotes> :O
16:39:30 <Gracenotes> O:
16:45:02 <kadaver> i want to say match "all this stuff" but not more.
16:45:26 <kadaver> so i want to match at least that and then cut it. but if there is mroe and it doesnt match then sreturn the match
16:45:28 <kadaver> ie
16:45:50 <kadaver> many char >> space >> many char
16:45:53 <kadaver> matches
16:45:57 <kadaver> hello there
16:46:02 <kadaver> hello there.
16:46:10 <kadaver> but not: hello .
16:47:39 <Gracenotes> 'many char' isn't exactly legal?
16:47:55 <Gracenotes> char is a function
16:48:12 <Gracenotes> anyway, it is greedy by default, so try noneOf " " or something like.
16:52:15 <kadaver> so can I say
16:52:32 <alexbobp> How do I define a function in ghci or hugs?  They both give an error if I type something like "x=1"
16:52:56 <kadaver> many (letter && noneOf 'xyz') ?
16:53:43 <gnuvince_> alexbobp: let x = 1
16:54:31 <alexbobp> gnuvince_: okay, thanks
16:59:06 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3234#a3234 <- how can I simplify that? I guess I dont know all the "builtin" functions well enough to write shorter code sometimes
17:02:18 <pumpkin> ghcai: it's kind of sad that the only way I have to identify you is by the code and questions you ask (verifying it by your hostname)
17:02:23 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3234#a3235
17:02:34 <pumpkin> :P
17:02:44 <ghcai> well i try to change to kadaver
17:02:51 <ghcai> but then  my ufcking isp fucks off
17:02:53 <glguy> ghcaifoldWithKey (\k xs m -> foldl (\ m x -> insertWith (++) x [k] m) m xs)
17:03:01 <glguy> something like that ought to work
17:03:12 * glguy sets off to test
17:03:23 <pumpkin> ghcai: what about the original code I gave you yesterday?
17:03:34 <pumpkin> ghcai: that was pretty suucinct
17:03:46 <dolio> @type M.fromListWith (++) . ((\(k,l) -> map (flip (,) [k]) l) <=< M.toList)
17:03:48 <lambdabot> forall a k. (Ord a) => M.Map k [a] -> M.Map a [k]
17:05:05 <ghcai> pumpkin: lol my conncection smust have kicked me irhgt then
17:05:15 <pumpkin> ghcai: you commented on it :P
17:06:48 <pumpkin> Map.fromListWith Map.union . concatMap (\(x, y) -> [(a, Map.singleton x b) | (a, b) <- Map.toList y]) . Map.toList
17:07:16 <pumpkin> @type Map.fromListWith Map.union . concatMap (\(x, y) -> [(a, Map.singleton x b) | (a, b) <- Map.toList y]) . Map.toList
17:07:17 <lambdabot> Couldn't find qualified module.
17:07:23 <pumpkin> lol
17:08:02 <pumpkin> @type Data.Map.fromListWith Map.union . concatMap (\(x, y) -> [(a, Data.Map.singleton x b) | (a, b) <- Data.Map.toList y]) . Data.Map.toList
17:08:04 <lambdabot> Couldn't find qualified module.
17:08:07 <pumpkin> :(
17:08:17 <pumpkin> @type Data.Map.fromListWith Data.Map.union . concatMap (\(x, y) -> [(a, Data.Map.singleton x b) | (a, b) <- Data.Map.toList y]) . Data.Map.toList
17:08:19 <lambdabot> forall k a k1. (Ord k, Ord k1) => M.Map k1 (M.Map k a) -> M.Map k (M.Map k1 a)
17:08:41 <glguy> foldWithKey (\k xs m -> foldr (\ x -> insertWith (++) x [k]) m xs) empty m
17:08:45 <glguy> I'd forgotten the "empty"
17:09:24 <pumpkin> ghcai
17:12:45 <pumpkin> guess he disappeared again
17:17:29 <alexbobp> Turns out you can write very unreadable haskell code: prettify (x:xs)=foldl (\x -> (++) ((++) x ", ")) x xs
17:18:07 <sm> I'm trying to figure out some cabal deployment issues
17:18:26 <ghcai> hmm list comrepehnsions are really neat to use instead of explicit recursion
17:18:33 <sm> I want installation to just work, and installation docs to be simple
17:18:43 <Saizan> > foldl1 (\x -> (++) ((++) x ", ")) ["a"."b","c","d"]
17:18:45 <lambdabot>   Couldn't match expected type `b -> c'
17:18:47 <sm> my package depends on vty which is not available on windows. What happens if someone does cabal install vty on windows anyway ?
17:19:05 <sm> it downloads and fails to build ?
17:19:08 <Saizan> > foldl (\x -> (++) ((++) x ", ")) "0" ["a"."b","c","d"]
17:19:10 <lambdabot>   Couldn't match expected type `b -> c'
17:19:49 <Saizan> sm: yes
17:19:57 <Saizan> ?hackage vty
17:19:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty
17:20:34 <Saizan> sm: well, no, sorry, cabal will complain about a missing "unix" package
17:20:37 <dolio> > foldl ((++) . (++ ", ")) "0" ["a","b","c","d"]
17:20:39 <lambdabot>   "0, a, b, c, d"
17:20:59 <sm> ok, so my package can't depend on vty by default, or it would be uninstallable on windows
17:21:28 <sm> currently it builds a cut-down non-vty version by default, and to get the full deal on unix you install -f vty
17:21:42 <sm> but that's a pain and hard to document, I'm looking for a simpler way
17:22:06 <Saizan> ah, if you use a flag and let use-vty be default cabal will pick the other value for the flag when it sees that the default is not installable
17:22:17 <sm> really!
17:22:57 <Saizan> yeah, that's a fundamental feature
17:23:20 <sm> I see.. it doesn't download and fail to build on windows, it just sees the dependencies are unsatisfiable
17:23:40 <Saizan> the "if" statement in .cabal files is bidirectional, if choosing the default branch fails it'd try with the other changing the value of the flag
17:23:44 <sm> so then it starts flipping flags until it can satisfy ? even if there's a bunch of them ?
17:23:51 <Saizan> yes.
17:24:05 <dcoutts> it's really a prolog program
17:24:25 <sm> well that's very cool and should help a lot, thanks for explaining that
17:24:46 <sm> I'll be testing it soon
17:27:23 * sm doesn't think autoconf knows that trick
17:28:00 <kniu> :t forkIO
17:28:01 <lambdabot> Not in scope: `forkIO'
17:28:15 <pumpkin> @hoogle forkIO
17:28:16 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
17:29:04 <lpjhjdh> So I'm trying to "cabal install directory" and I'm getting "it is a member of package base, which is hidden"
17:30:01 <Saizan> lpjhjdh: you should get something more before that, listing a module name
17:30:12 <lpjhjdh> Control.Exception.Base
17:32:11 <Saizan> lpjhjdh: mmh, maybe there's a bug in the package then
17:33:52 <lpjhjdh> trying to update because when I use directory I get "HSdirectory-1.0.0.2.o: unknown symbol unixzm2zi3zi1zi0_SystemziPosixziDirectory_a12_info"
17:34:28 <lpjhjdh> and I tried to build unix but I'm getting: Module `GHC.Conc' does not export `Signal'
17:34:54 <harovali1> what is Helium?
17:36:04 <Saizan> lpjhjdh: for directory it works if you use cabal install directory --constraint="base >= 4"
17:36:33 <sm> my app can also build with or without happstack. With, you get a mildly cool web interface. Is the additional time/hassle required to download and build happstack and deps going to annoy folks ?
17:36:51 <lpjhjdh> hmm, my stuff must be screwed up
17:37:15 <lpjhjdh> I'm on arch and have had a lot of trouble using some haskell-whatever native packages
17:37:27 <lpjhjdh> thanks
17:39:37 <Saizan> lpjhjdh: actually, i had to edit directory.cabal adding base == 4.* in build-depend
17:40:37 <QtPlaty[HireMe]> How do the labels get picked for the types from inferences?
17:41:13 <ivanm> QtPlaty[HireMe]: I take it you want work? ;-)
17:41:25 <QtPlaty[HireMe]> ivanm: I do
17:41:45 * ivanm wonders how he managed to work that out... :p
17:42:25 <lpjhjdh> thanks Saizan, it seems the current broken unix+directory stuff is getting in the way
17:44:49 <latitude> hmm, if i'd like to have function that returns random value, that requires to run an action?
17:45:25 <pumpkin> a computer can't make a "random" value
17:45:37 <centrinia> pumpkin, Sure it can.
17:45:37 <latitude> so like in math, there cannot be diferent values for the same argument
17:45:41 <pumpkin> you can use the IO monad to save the PRNG state somewhere
17:45:48 <pumpkin> or you can just pass it around in a typical State monad sense
17:45:52 <centrinia> You just need a computer that has an uncountable number of possible states.
17:45:56 <ddarius> pumpkin: Sure it can.  You are confusing a computer with a mathematical/logical abstraction of a computer.
17:46:02 <pumpkin> fair enough :)
17:46:13 <latitude> no i mean just the basic notion of function
17:46:36 <centrinia> latitude, (const 9) is a function that returns a random value.
17:46:38 <latitude> let leave pure randoms to randomness
17:47:06 <lpjhjdh> Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin
17:47:47 <centrinia> Here: http://clipmarks.com/clipmark/4905F106-063A-401C-8631-392E2E49652A/
17:48:45 <kerlo> latitude: yeah, you need to run an action. The value of a Haskell expression is not random.
17:49:18 <Saizan> lpjhjdh: for unix, it appears you need to install unix-2.3.1.0 , the new version is probably for ghc-6.10.2
17:49:33 <ddarius> "Further details of the construction can be found in [suppressed]."
17:49:44 <shapr> ??
17:52:58 <lpjhjdh> Saizan: thanks
17:54:25 <latitude> are there loops in haskell?
17:54:37 <latitude> i understand why there is no for loops
17:54:41 <ivanm> latitude: not explicit ones
17:54:42 <latitude> but what about while
17:54:50 <SnailRacer> until
17:54:52 <ivanm> you generally use a fold or something
17:54:52 <ghcai> what does <=< do?
17:55:00 <ivanm> @hoogle (<=<)
17:55:01 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c
17:55:05 <ghcai> and does anyone else haskell has to much weird syntax?
17:55:20 <ivanm> ghcai: it appears to chain together monadic functions
17:55:27 <ivanm> (i.e. monadic equivalent of (.))
17:55:34 <ivanm> and no, it doesn't have enough weird syntax! ;-)
17:56:09 <pumpkin> ghcai: haskell has pretty simple syntax
17:56:16 <pumpkin> the only weird thing I'd like to get rid of is if
17:56:23 <lpjhjdh> hmm, after installing unix-2.3.1.0 now I get HSdirectory-1.0.0.2.o: unknown symbol `unixzm2zi3zi1zi0_SystemziPosixziDirectory_a12_info'
17:56:25 <ivanm> pumpkin: replace it with if' ?
17:56:29 <pumpkin> yeah, and maybe bool
17:56:32 <pumpkin> depending on your style
17:56:49 <travisbrady> pumpkin: couldn't agree more
17:56:50 <pumpkin> lpjhjdh: did you use --make?
17:57:03 <travisbrady> if doesn't seem to fit and i always forget the layout rules for it
17:57:21 <ivanm> pumpkin: "bool"?
17:57:30 <pumpkin> in the style of maybe, either
17:57:33 <edwardk> if has grown on me mainly because i find the alternative if (foo quux) (bar baz) (flurfl blarg) to have way too many parens
17:57:44 <ivanm> @src if'
17:57:44 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:57:56 <ivanm> IIRC, if' p t e = if p then t else e
17:58:07 <pumpkin> ivanm: bool would simply be if' with the arguments in a different order, to match typical either/maybe
17:58:22 <edwardk> pumpkin: that i've written a couple of times ;)
17:58:24 <pumpkin> I'd be fine with keeping both if' and bool
17:58:30 <lpjhjdh> cabal install *
17:58:32 <ivanm> pumpkin: I don't think bool is a good name for it, tbh
17:58:32 <pumpkin> yeah, I think it's quite common
17:58:37 <pumpkin> ivanm: why not?
17:58:41 <lpjhjdh> seems to produce a bunch of linker errors
17:58:48 <edwardk> ivanm: it doesn match the convention adopted by maybe and either
17:58:49 <ivanm> if is a more intuitive name, matching our experience in the world, etc.
17:58:50 <edwardk> er does
17:58:59 <travisbrady> ivanm: that is cleaner by a lot
17:59:04 <ivanm> edwardk: yes, but that's based upon extracting a value out of the constructor
17:59:08 <pumpkin> lpjhjdh: you tried to install everything on cabal?
17:59:12 <ivanm> travisbrady: what is?
17:59:16 <edwardk> ivanm: this is also ;)
17:59:30 <ivanm> edwardk: Bool doesn't contain a value (i.e. it isn't a Functor or anything)
17:59:33 <pumpkin> ivanm: the first argument of maybe isn't "extracting" anything
17:59:39 <ivanm> pumpkin: it's a default value
17:59:42 <ivanm> @src maybe
17:59:43 <lambdabot> maybe n _ Nothing  = n
17:59:43 <lambdabot> maybe _ f (Just x) = f x
17:59:45 <lpjhjdh> yeah, I always get problems with arch native packages
17:59:51 <ivanm> @src either
17:59:52 <lambdabot> either f _ (Left x)     =  f x
17:59:52 <lambdabot> either _ g (Right y)    =  g y
17:59:53 <edwardk> ivanm: bool is a maybe with two different 'defaults' ;)
18:00:08 <ivanm> edwardk: not really...
18:00:15 <pumpkin> aren't those things called catamorphisms or something?
18:00:22 <pumpkin> provide something to do for each constructor?
18:00:35 <pumpkin> data Bool = False | True
18:01:01 <travisbrady> ivanm: if'
18:01:02 <pumpkin> cataBool :: a -> a -> Bool -> a
18:01:11 <edwardk> they are f-algebras for Maybe and Either respectively
18:01:27 <edwardk> and boolAlgebra is even worse than bool ;)
18:01:40 <monochrom> boo algebah
18:02:14 <edwardk> 'thenelse' ? =)
18:02:15 <pumpkin> I'm sure I've seen people call them catamorphisms
18:02:27 <pumpkin> but you know best :P
18:03:02 <pumpkin> either way, bool looks just like either and maybe to me :P
18:03:31 <edwardk> pumpkin: a catamorphism takes what to do with the underlying functor at each step, but here the underlying functor doesn't recuse, a catamorphism _takes_ an f-algebra and gives you something that tears down that functor folded in on itself.
18:04:18 <centrinia> When someone mentions catamorphisms, think of catastrophies.
18:04:38 <centrinia> When someone mentions anamorphisms, think of anabolic steroids. ;)
18:04:45 <edwardk> the equivalent catamorphic 'maybe' would take the same f-algebra and apply it recursively to some data type of the form Maybe (Maybe (Maybe ...) -- that should look familiar, thats data Nat = Succ Nat | Zero
18:04:52 <monochrom> cathermorphine
18:04:57 <pumpkin> ah
18:05:12 <monochrom> is a nice addictive girl
18:05:18 <pumpkin> edwardk: isn't it closer to the type-level naturals?
18:05:26 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3236#a3236 <- can you codegolf that into a 1liner?
18:05:31 <ivanm> monochrom: heh
18:05:32 <edwardk> pumpkin: those are term level nats, note the recursive ADT
18:06:00 <pumpkin> edwardk: yeah, but you can't define an arbitrarily recursing Maybe can you?
18:06:17 <pumpkin> it seems more similar to data Zero; data Succ a;
18:06:26 <edwardk> pumpkin: newtype Mu f = In (f (Mu f)) -- then tear down Mu Maybe
18:06:58 <edwardk> Mu Maybe is isomorphic to that data Nat = Succ Nat | Zero i mentioned
18:07:12 <pumpkin> oh I see
18:08:00 <edwardk> you can make Nat in that sort of explicit fold style by defining data NatF a = Succ a | Zero -- which should look familiar ;)
18:08:37 <ddarius> edwardk: Non-recursive types are just fixed points of constant functors.
18:08:52 <QtPlaty[HireMe]> Is it possable to do something like a lisp syle cond?
18:08:59 <edwardk> ddarius: sure
18:09:14 <sjanssen> QtPlaty[HireMe]: use guards?
18:09:18 <bremner> QtPlaty[HireMe]: case looks pretty similar
18:09:24 <ddarius> centrinia: catamorphism - downward change, catastrophe - downward step
18:09:28 <bremner> err, yeah, sorry guards
18:09:30 <edwardk> ddarius: steal my punchline why don't ya? =)
18:10:50 <edwardk> pumpkin: so using that explicit style you could make a data MaybeF a r = Just a | Nothing -- which ignores its r parameter
18:10:53 <bremner> is  'foo l | length l < 3 = False'  efficient, or is there insufficient magic to avoid evaluating length
18:11:09 <edwardk> and then Mu (MaybeF a) -- would be just like Maybe a
18:11:09 <sjanssen> bremner: there is no magic
18:11:13 <pumpkin> yup :)
18:11:16 <ivanm> bremner: there's a better way:
18:11:52 <chessguy> large (x:y:z:rest) = True; large _ = False
18:11:57 <ivanm> > let single [_] = True, single _ = False, isLength n = single . drop (n-1) in isLength 3 [1..10]
18:11:58 <lambdabot>   <no location info>: parse error on input `,'
18:12:08 <ivanm> > let single [_] = True; single _ = False; isLength n = single . drop (n-1) in isLength 3 [1..10]
18:12:09 <lambdabot>   False
18:12:11 <chessguy> foo l | large l = False
18:12:18 <ivanm> bremner: ^^ works for infinite lists as well
18:12:31 <ivanm> oh, you want at least...
18:12:38 <bremner> ah, right, doing my patterns in the wrong order.  Thanks
18:12:47 <ivanm> *shrug* replace single with (non . null)
18:13:00 <edwardk> > (null . drop 3) <$> [[1,2],[1,2,3],[1,2,3,4]]
18:13:01 <lambdabot>   [True,True,False]
18:13:04 <edwardk> there ya go
18:13:16 <chessguy> ooooh, aren't you clever
18:13:18 <chessguy> :)
18:13:35 <pumpkin> you and your fancy applicative magick
18:13:37 <edwardk> oh wait, < 3
18:13:47 <ddarius> pumpkin: It's just map.
18:13:48 <pumpkin> map would've been just as short :P
18:13:50 <pumpkin> I know
18:13:57 <edwardk> foo l | null (drop 2) = ...
18:14:10 <edwardk> er null (drop 2 l)
18:14:23 <bremner> err, yeah
18:14:27 <ddarius> foo = not . null . drop 2
18:14:33 <ivanm> edwardk: yeah, that through me at first
18:14:43 <ivanm> I already said to use not . null drop 2 !
18:14:49 <chessguy> > drop 2 []
18:14:51 <lambdabot>   []
18:14:59 <kerlo> @hoogle Just a -> Bool
18:15:00 <lambdabot> Did you mean: Maybe a -> Bool /count=20
18:15:00 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
18:15:00 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:15:03 <edwardk> ivanm: i failed to parse your statement ;)
18:15:09 <bremner> but the first solution is fine, because I need to do the pattern matching anyway
18:15:10 <ivanm> edwardk: heh
18:15:12 <kerlo> @hoogle isJust
18:15:13 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
18:15:28 <ivanm> edwardk: I meant to say "yeah, that threw me at first"
18:15:31 <ivanm> wrong damn threw :@
18:15:32 <pumpkin> lol @ isBottom :: a -> Bool
18:15:40 <ddarius> pumpkin: A useful function.
18:15:42 <ivanm> > isBottom undefined
18:15:44 <lambdabot>   Not in scope: `isBottom'
18:15:48 <ivanm> :(
18:15:50 <pumpkin> aw
18:15:51 <ivanm> @hoogle isBottom
18:15:52 <kerlo> > let maybeTail (Just (x:xs)) = Just xs; maybeTail _ = Nothing; compareLength' 0 = const Nothing; compareLength' n = compareLength' (n-1) . maybeTail; compareLength n = isJust . compareLength' n in map (flip compareLength) [0..10] "hello"
18:15:52 <lambdabot> Test.QuickCheck.Batch isBottom :: a -> Bool
18:15:54 <lambdabot>   Couldn't match expected type `[Char] -> t'
18:15:55 <ivanm> ahhh
18:16:10 <chessguy> > Test.QuickCheck.Batch.isBottom 3
18:16:11 <lambdabot>       Failed to load interface for `Test.QuickCheck.Batch':
18:16:11 <lambdabot>        it is a me...
18:16:15 <kerlo> > let maybeTail (Just (x:xs)) = Just xs; maybeTail _ = Nothing; compareLength' 0 = const Nothing; compareLength' n = compareLength' (n-1) . maybeTail; compareLength n = isJust . compareLength' n in map (flip compareLength "hello") [0..10]
18:16:17 <lambdabot>   Couldn't match expected type `Maybe [t]'
18:16:21 <ivanm> "it is a me" ? :o
18:16:24 <chessguy> "it is a me..."?
18:16:25 <chessguy> lol
18:16:29 <kerlo> > let maybeTail (Just (x:xs)) = Just xs; maybeTail _ = Nothing; compareLength' 0 = const Nothing; compareLength' n = compareLength' (n-1) . maybeTail; compareLength n = isJust . compareLength' n . Just in map (flip compareLength "hello") [0..10]
18:16:31 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False]
18:16:33 * ivanm wonders if kerlo is channeling wli...
18:16:34 <pumpkin> that is awesome
18:16:36 <alexbobp> does lambdabot remember functions?
18:16:38 <kerlo> Useful.
18:16:40 <chessguy> @kerlo me
18:16:41 <lambdabot> i use an 8088
18:16:41 <pumpkin> > Test.QuickCheck.Batch.isBottom 3
18:16:42 <lambdabot>       Failed to load interface for `Test.QuickCheck.Batch':
18:16:42 <lambdabot>        it is a me...
18:16:44 <pumpkin> wow
18:16:51 <alexbobp> > let s x y z=(x z)(y z)
18:16:52 <lambdabot>   <no location info>: parse error on input `;'
18:16:52 <ivanm> alexbobp: you can, but you shouldn't go and tell it to remember functions just for the sake of it
18:16:53 <monochrom> @help kerlo
18:16:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:16:54 <pumpkin> who's @msg ing?
18:17:05 <alexbobp> ivanm: aww, okay
18:17:08 <kerlo> Why are people treating my name as a lambdabot command?
18:17:10 <chessguy> @keal
18:17:10 <wli> Is my code that bad?
18:17:10 <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
18:17:11 <pumpkin> > Test.QuickCheck.Batch.isBottom 3
18:17:12 <lambdabot>       Failed to load interface for `Test.QuickCheck.Batch':
18:17:12 <ivanm> pumpkin: messaging who?
18:17:12 <lambdabot>        it is a me...
18:17:16 <ivanm> wli: it can get that way ;-)
18:17:17 <alexbobp> > kerlo
18:17:19 <lambdabot>   Not in scope: `kerlo'
18:17:26 <pumpkin> ivanm: lambdabot is saying stuff :o
18:17:36 <chessguy> it's getting really confusing in here...
18:17:40 <ivanm> heh
18:17:40 <pumpkin> <lambdabot> love a black and white lower 128 from 32 up of ascii glyphs?
18:17:42 <pumpkin> ???
18:17:44 <kerlo> And who's this wli guy I'm channeling?
18:17:47 <alexbobp> > let s x y z=(x z)(y z); s (++) reverse "kerlo"
18:17:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:17:50 <chessguy> and it all started with LB saying "it is a me..."
18:17:51 <ivanm> pumpkin: chessguy said "@keal"
18:17:54 <lpjhjdh> hm, so if I have unix-2.3.1.0 installed and registered (via cabal) I get "HSdirectory-1.0.0.2.o: unknown symbol `unixzm2zi3zi1zi0_SystemziPosixziDirectory_a12_info'" but without it I get System.Posix.Directory unexposed because unix-2.3.1.0 is hidden
18:17:57 <alexbobp> well I don't know why that didn't work :(
18:18:08 <ivanm> chessguy: let's see how many simultaneous conversations we can get going in the one channel! ;-)
18:18:10 <pumpkin> ivanm: it happened several times before he @kealed
18:18:10 <ghcai> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3236#a3236 <- a 1liner for that ?n any codegolfers out there?
18:18:18 <monochrom> Because the syntax is "let ... in ..."
18:18:22 <chessguy> ivanm:  particularly when they're all randomly nonsensical
18:18:32 <kerlo> > let maybeTail (Just (x:xs)) = Just xs; maybeTail _ = Nothing; compareLength' 0 = id; compareLength' n = compareLength' (n-1) . maybeTail; compareLength n = isJust . compareLength' n . Just in map (flip compareLength "hello") [0..10]
18:18:34 <lambdabot>   [True,True,True,True,True,True,False,False,False,False,False]
18:18:35 <ivanm> pumpkin: there was a @kerlo, which lambdabot fixed to @keal presumably
18:18:36 <kerlo> Whew.
18:18:38 <pumpkin> lol
18:18:42 <pumpkin> I see
18:18:48 <ivanm> ghcai: why do you want it code golfed?
18:18:58 <ivanm> and there's always @pl to code golf for you...
18:19:13 <pumpkin> ivanm: wait, it happened one time before that too :o
18:19:13 <monochrom>  @pl doesn't have ai yet.
18:19:18 <kerlo> Now, don't tell me there's a better way of doing what I'm trying to do. :-P
18:19:21 <pumpkin> ghcai: using last isn't good
18:19:36 <chessguy> @type takeWhile (== ' ') . takeWhile (/= ' ')
18:19:37 <lambdabot> [Char] -> [Char]
18:19:47 <pumpkin> chessguy: that isn't quite strip though
18:19:49 <Saizan> lpjhjdh: you need to rebuild the directory package against the new unix
18:19:59 <pumpkin> > takeWhile (== ' ') . takeWhile (/= ' ') $ "    hello world     "
18:20:01 <lambdabot>   ""
18:20:07 <chessguy> ghcai: is  something like that what you want??
18:20:07 <pumpkin> actually :P
18:20:09 <ivanm> pumpkin: I find either @ or > prefixed messages for each time lambdabot talked...
18:20:10 <ddarius> data Array a = Scalarize a | AddDimension Int (Array a) -- ~ type Array a = ([Int], a)
18:20:13 <chessguy> pumpkin:  i know
18:20:20 <chessguy> oh wait
18:20:20 <pumpkin> > takeWhile (/= ' ') . dropWhile (== ' ') $ "    hello world     "
18:20:22 <lambdabot>   "hello"
18:20:24 <pumpkin> even then
18:20:25 <lpjhjdh> runhaskell Setup configure --user gives linkger errors :(
18:20:34 <chessguy> yeah, i reversed them
18:20:36 <lpjhjdh> Saizan: for directory-1.0.0.3
18:20:44 <pumpkin> chessguy: it'll still stop after the first space
18:20:54 <chessguy> pumpkin:  yes, as i said, i know
18:21:19 <pumpkin> I figured you meant you knew about the ""
18:21:26 <Saizan> lpjhjdh: heh, because the Cabal libraries uses directory too
18:21:26 <pumpkin> not about the stop after first space :)
18:21:26 <monochrom> > takeWhile (/= ' ') "hey      you!"
18:21:28 <lambdabot>   "hey"
18:21:38 <Saizan> lpjhjdh: do you have cabal-install installed perhaps?
18:21:49 <monochrom> stripping things from the end is not easy.
18:21:50 <lpjhjdh> Saizan: I do
18:21:55 <chessguy> pumpkin:  it's not clear what kind of input ghcai  has in mind
18:22:03 <Saizan> lpjhjdh: use cabal configure --user then
18:22:04 <loop> monochrom: just reverse
18:22:09 <ghcai> last isnt so bad it only traverses once anyway right?
18:22:10 <monochrom> reverse twice.
18:22:11 <pumpkin> @type loop
18:22:12 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
18:22:18 <Saizan> lpjhjdh: or just cabal install --user
18:22:19 <ghcai> but yeah the takewhile dropwhile is neat
18:22:42 <Saizan> lpjhjdh: since it does the configure/build steps for you
18:22:47 <chessguy> ghcai:  do you anticipate having spaces in the middle of the string?
18:23:03 <lpjhjdh> Saizan: thanks :D
18:23:13 <chessguy> > flip it
18:23:15 <lambdabot>   Not in scope: `it'
18:23:34 <pumpkin> > let in the dog please
18:23:36 <lambdabot>   Not in scope: `the'Not in scope: `dog'Not in scope: `please'
18:23:39 <pumpkin> :(
18:23:47 <pumpkin> someone cleared my let
18:23:54 <ghcai> wait t doesnt work
18:23:58 <ghcai> hello world fails
18:24:07 <ghcai> i just want to trim the edges
18:24:11 <chessguy> ghcai:  that's why we asked you repeatedly what exactly you were looking for
18:24:17 <ghcai> :)
18:24:33 <chessguy> > words " hello world "
18:24:35 <lambdabot>   ["hello","world"]
18:24:38 <ghcai> well i posed the function
18:24:54 <chessguy> unwords . words?
18:25:10 <pumpkin> then you lose "    hello    world   "
18:25:14 <chessguy> > words "  hello   world!!  "
18:25:15 <lambdabot>   ["hello","world!!"]
18:25:32 <chessguy> > unwords . words $ "  hello  world!"
18:25:34 <lambdabot>   "hello world!"
18:25:54 <ghcai> ywah
18:25:59 <chessguy> > unwords . words $ "   hello          ,,    world"
18:26:01 <omnihil> > reverse . dropWhile (== ' ') . reverse . dropWhile (== ' ') $ "   hello   world   "
18:26:01 <lambdabot>   "hello ,, world"
18:26:02 <lambdabot>   "hello   world"
18:26:03 <ghcai> stewie says yay!
18:28:02 <Saizan> > join (.) (reverse . dropWile isSpace) $ "   foo   bar   "
18:28:03 <lambdabot>   Not in scope: `dropWile'
18:28:11 <chessguy> @let strip s | head s == ' ' = strip (tail s) | last s == ' ' = strip (init s) | True = s
18:28:12 <Saizan> > join (.) (reverse . dropWhile isSpace) $ "   foo   bar   "
18:28:13 <lambdabot>  Defined.
18:28:14 <lambdabot>   "foo   bar"
18:28:43 <chessguy> @check \s -> L.strip s == (unwords . words) s
18:28:45 <lambdabot>       Failed to load interface for `L':
18:28:45 <lambdabot>        Use -v to see a list of the fi...
18:28:52 <chessguy> ?
18:29:11 <chessguy> @check \s -> strip s == (unwords . words) s
18:29:13 <lambdabot>   Not in scope: `strip'
18:29:18 * chessguy mutters
18:29:45 <chessguy> @type L.strip
18:29:46 <lambdabot> [Char] -> [Char]
18:30:06 <chessguy> you can't use @check on things that have beel letted?
18:30:52 <pumpkin> > concat . init . tail . group . (" " ++).(++ " ") $ "    hello   world     "
18:30:53 <lambdabot>   "hello   world"
18:30:58 <pumpkin> :P
18:31:16 <pumpkin> lamest way ever
18:31:18 <chessguy> @check \s -> let strip s | head s == ' ' = strip (tail s) | last s == ' ' = strip (init s) | True = s in strip s == (unwords . words) s
18:31:20 <lambdabot>   "* Exception: Prelude.head: empty list
18:31:41 <pumpkin> Saizan's is prettier
18:31:45 <pumpkin> although I'm scared of reverse
18:32:13 <chessguy> @check \s -> let strip s | null s = "" | head s == ' ' = strip (tail s) | last s == ' ' = strip (init s) | True = s in strip s == (unwords . words) s
18:32:15 <lambdabot>   "OK, passed 500 tests."
18:32:19 <monochrom> reversing twice is unsatisfactory.
18:32:19 <chessguy> w00t
18:32:30 <pumpkin> so my way wins!
18:32:39 <pumpkin> :D
18:32:42 <pumpkin> :P
18:32:44 <chessguy> pumpkin:  uh, i think unwords . words wins
18:32:52 <pumpkin> chessguy: I've already pointed out what's worng with that
18:32:58 <chessguy> i missed it
18:33:10 <chessguy> it apparently does what his function does
18:33:25 <pumpkin> > (unwords . words) s $ "    hello      world    "
18:33:26 <lambdabot>   Couldn't match expected type `a -> b'
18:33:32 <pumpkin> > (unwords . words) $ "    hello      world    "
18:33:34 <lambdabot>   "hello world"
18:33:58 <pumpkin> > join . init . tail . group . (" " ++).(++ " ") $ "    hello   world     "
18:34:00 <lambdabot>   "hello   world"
18:34:32 <chessguy> > let strip s | null s = "" | head s == ' ' = strip (tail s) | last s == ' ' = strip (init s) | True = s in strip "  hello    world   "
18:34:34 <lambdabot>   "hello    world"
18:34:41 <chessguy> bah
18:34:50 <omnihil> @hoogle join
18:34:50 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
18:34:50 <lambdabot> System.FilePath.Posix joinDrive :: FilePath -> FilePath -> FilePath
18:34:50 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
18:34:57 <chessguy> i guess QC just doesn't find it?
18:35:01 <chessguy> that sucks
18:35:06 <pumpkin> not sure why it didn't pick it up actually
18:35:16 <chessguy> not enough tests probably
18:35:22 <pumpkin> I guess the Arbitrary Char doesn't generate spaces very often
18:35:27 <pumpkin> maybe, yeah
18:35:49 <chessguy> could be trying a lot of empty strings too
18:36:01 <pumpkin> I think it avoids checking the same value twice, but I'm not sure
18:38:39 <matthewp> bos: are you around?
18:38:44 <ddarius> > let f spaces (c:cs) | c == ' ' = f (c:spaces) cs | otherwise = spaces ++ c:f cs; f _ [] = [] in f "" "   hello   world   "
18:38:44 <pumpkin> ghcai: enough golfage for you?
18:38:45 <lambdabot>   Couldn't match expected type `[Char]'
18:38:51 <matthewp> @seen bos
18:38:52 <lambdabot> bos is in #haskell and #ghc. I don't know when bos last spoke.
18:39:28 <ddarius> > let f spaces (c:cs) | c == ' ' = f (c:spaces) cs | otherwise = spaces ++ c:f "" cs; f _ [] = [] in f "" "   hello   world   "
18:39:29 <lambdabot>   "   hello   world"
18:40:12 <ddarius> > let f spaces (c:cs) | c == ' ' = f (c:spaces) cs | otherwise = spaces ++ c:f "" cs; f _ [] = [] in f "" $ dropWhile (' '==) "   hello   world   "
18:40:13 <lambdabot>   "hello   world"
18:40:21 <chessguy> hey matthewp was attendance any better tonight?
18:40:55 <matthewp> chessguy: had to bail because I couldn't get the spot tonight.  * sigh * things just keep adding up
18:40:55 <centrinia> > reverse . dropWhile (==' ') . reverse . dropWhile (== ' ') $ "     hello  world   "
18:40:57 <lambdabot>   "hello  world"
18:41:31 <ddarius> > let f spaces (c:cs) | c == ' ' = f (c:spaces) cs | otherwise = spaces ++ c:f "" cs; f _ [] = [] in f "" $ dropWhile (' '==) $ "   hello   world   " ++ repeat 'x'
18:41:32 <lambdabot>   "hello   world   xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
18:42:08 <chessguy> matthewp:  more time to watch SICP!
18:43:20 <ivanm> chessguy: are you afraid someone is going to steal it, that you continuously watch your copy of SICP?
18:43:23 <ivanm> :o
18:43:50 <monochrom> I continuously watch my LCD monitor. I am afraid someone will steal it.
18:43:57 <ivanm> heh
18:44:27 <monochrom> But I don't watch my loudspeakers. I just listen to them.
18:44:30 * ddarius steals monochrom's monitor.
18:44:31 <ivanm> or do you think that by just looking at the book you can absorb its contents?
18:44:48 * ddarius recommends eating the book.
18:44:50 <monochrom> That's observationally what happens, doesn't it?
18:44:52 * ivanm steals monochrom's loudspeakers whilst he's trying to work out what happened to his monitor
18:45:00 <matthewp> chessguy: was looking for bos because of the SlopeOne implementation. Had a few questions about it
18:45:07 <chessguy> SlopeOne?
18:45:22 <monochrom> You observe that someone is just looking at the book. Then later you query him and find that he possesses the knowledge.
18:45:36 <monochrom> He's observationally equivalent to OCR.
18:45:58 * centrinia puts a cardboard box replica of a monitor and speakers in place of where monochrom's monitor and speakers were.
18:46:23 <ddarius> centrinia: Just like the real thing, only more informative.
18:46:34 <monochrom> And observationally equivalent too.
18:46:36 <ivanm> centrinia: think he'll notice?
18:46:43 <monochrom> No, I won't.
18:46:43 <centrinia> I doubt it. ;)
18:46:49 <centrinia> See. ;)
18:47:01 <monochrom> Only observational equivalence matters.
18:47:31 <matthewp> chessguy: SlopeOne http://www.serpentine.com/blog/2007/08/27/weighted-slope-one-in-haskell-collaborative-filtering-in-29-lines-of-code/
18:50:23 <chessguy> matthewp:  you want to use this in PCI?
18:50:46 <ghcai> why doesnt the program return to the prompt after finishing hwen using System:process.runCommand?
18:51:25 <monochrom> perhaps it doesn't finish.
18:51:50 <matthewp> chessguy: PCI?
18:51:59 <matthewp> oh, yes
18:52:02 <matthewp> sorry
18:52:03 <chessguy> haha
18:52:18 <matthewp> well, in compliment to
18:55:03 <gnuvince_> @hoogle Char -> String -> [String]
18:55:04 <lambdabot> Distribution.Simple.PreProcess.Unlit plain :: String -> String -> String
18:55:04 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
18:55:04 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
18:59:11 <ghcai> can you push towars hackage with darcs or cabal?
18:59:25 <ghcai> monochrom: it does
18:59:45 * shapr boings
19:00:03 * alexsuraci wishes there wasn't a package called "alex"
19:00:06 <ivanm> shapr: are you on a trampoline or something?
19:00:08 <ivanm> alexsuraci: heh
19:00:27 <alexsuraci> need to figure out how to get irssi to ignore this channel for that hilight, haha
19:01:10 <monochrom> Your nick is not alex. Why would any software highlight not-your-nick unless you set it to?
19:01:13 <shapr> ivanm: roller coaster actually.
19:01:28 <shapr> Perhaps it's his username?
19:01:34 <alexsuraci> monochrom: I set it to, for other channels, since I'm usually/always the "Alex" they refer to
19:01:44 <omnihil> @hoogle alex
19:01:44 <lambdabot> package alex
19:01:44 <lambdabot> Distribution.Simple.Program alexProgram :: Program
19:01:44 <lambdabot> package HaLeX
19:01:58 <ivanm> shapr: why is a rollercoaster making you bounce? isn't that bad? :s
19:02:08 <shapr> ivanm: No, it's a positive development.
19:03:21 <monochrom> Recently some people tend to go out of their way to enter my nick manually and they entered "monochrome".
19:03:50 <bremner> B&W: huh, people are strange
19:04:33 <ivanm> monochrom: well, I find nick-completion rather helpful ;-)
19:04:47 <monochrom> Me too. I don't understand why people don't use it.
19:05:11 <ivanm> monochrom: don't know about it?
19:05:27 <monochrom> It is like they're making a strong assertion "humans are more reliable than computers" which is clearly superstition
19:05:31 * ivanm keeps trying to tab-complete any long word he wants to use in IRC :s
19:05:31 <edwardk> monochrome: who does that? =)
19:05:39 <ivanm> monochrom: heh
19:06:13 <monochrom> Anyway, bremner wins. People are strange.
19:06:28 <ddarius> al<TAB> = aleator
19:06:51 <edwardk> monochrom: meh, i just go out of my way to type things out when i want to say something if only because i work with too many folks who live in the world of intellisense who can't type to save their life
19:06:52 <ivanm> al<TAB><TAB><TAB> = aleator
19:07:21 <edwardk> and i can type a nick in a context insensitive manner, while there is a modality to tab completion that requires thought
19:07:51 <ddarius> edwardk: You should put "can't type to save their life" to the test.
19:08:23 <ivanm> "type out this 3 page document or die! mwahahahahahaha!!!"
19:08:25 <edwardk> ddarius: wooo sounds interesting. mavis beacon^H^H^H^H^H^H^H^H^H^H^H^Hsaw teaches typing
19:09:40 <monochrom> I have a better idea. "type out this wikipedia page or die!"
19:10:19 <ivanm> monochrom: now that's not fair...
19:10:24 <ivanm> they're _never_ right!
19:10:33 <ivanm> besides, what happens if the page changes mid-way through?
19:10:55 <monochrom> use STM to handle change.
19:11:41 <ddarius> shoot head >> retry
19:13:22 <dancor> forever (shoot head)
19:14:56 <monochrom> There was a Star Trek TNG episode of roll-back I really like.
19:15:35 <monochrom> They actually went through 4 retries before they could get out. :)
19:16:06 <ivanm> monochrom: heh
19:16:17 <ivanm> roll-back == "ground-hog day"-style situation?
19:16:57 <pumpkin> :o
19:17:29 <monochrom> I am not sure what that means. Probably not.
19:17:38 <mdmkolbe> Does anyone know what the status of the C-- work in GHC is?
19:17:48 * mdmkolbe worked on C-- in GHC two summers ago
19:18:02 <pumpkin> #ghc might know more
19:18:46 <thoughtpolice> hi pumpkin
19:18:51 <pumpkin> omg
19:18:53 <pumpkin> a thoughtpolice
19:18:58 * pumpkin hides
19:19:31 <Axman6> heh, now i know where your nick comes from thoughtpolice
19:19:38 * Axman6 is reading 1984 atm
19:19:41 <pumpkin> :)
19:19:49 <Adamant> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=scala&box=1
19:19:58 <Adamant> for all the RoR's jumping ship to Scala
19:20:06 <pumpkin> RoR?
19:20:14 <Adamant> Ruby On Rails
19:20:27 <ivanm> Axman6: /me prefers brave new world
19:20:35 <ivanm> Adamant: so it's now RoR^HS ?
19:20:45 <Adamant> ivanm: ?
19:20:49 <Axman6> eh?
19:20:58 <ivanm> Adamant: do you mean RoR is moving to Scala?
19:21:04 <Adamant> ivanm: yes
19:21:04 <pumpkin> SoR
19:21:07 <Axman6> you mean Adamant?
19:21:09 <Adamant> github and Twitter did
19:21:19 <ivanm> pumpkin: yeah, that's what I meant
19:21:21 <pumpkin> Adamant: really?? :o
19:21:23 <ivanm> R^HSoR
19:21:31 <ivanm> Axman6: no, you ;-)
19:21:39 <monochrom> label L0: Enterprise is travelling happily in space as usual. It comes near to a space-time distortion --- a hole --- and another ship from the past emerges from it. The two ships are about to collide. Enterprise uses tractor beam to try to push and avoid collision. They still scratch each other obliquely. Engines get unstable and explode. The explosion near the space-time distortion leads to (so the fictional theory goes): g
19:21:39 <monochrom> oto L0.
19:21:41 <Adamant> pumpkin: why do you think you haven't seen the Failwhale so often :P
19:21:41 <ivanm> IMHO, Brave New World > 1984
19:21:52 <pumpkin> Adamant: I saw it just earlier today
19:22:20 <ivanm> Adamant: so why are they switching to Scala?
19:22:34 <Adamant> ivanm: Ruby isn't getting faster enough fast enough
19:22:50 <ivanm> Adamant: oh? I thought 1.9 was meant to be much faster :s
19:22:58 <Adamant> ivanm: it is faster
19:22:59 <ivanm> then again, isn't Scala running on the JVM? :s
19:23:07 <Adamant> both Python and Ruby are getting fastr
19:23:10 <pumpkin> Adamant: where does it say people are moving to scala?
19:23:12 <Adamant> but, they're still slow
19:23:21 <ivanm> ahhh
19:23:32 <Adamant> pumpkin: it's in the media for both Twitter and github
19:23:40 <thoughtpolice> maybe OT but i thought this was awesome: http://blog.headius.com/2009/03/bitescript-001-ruby-dsl-for-jvm.html
19:23:41 <ivanm> "Scala is a pure object-oriented language in the sense that every value is an object. " <-- obviously a different meaning of the word "pure" than we use :s
19:23:47 <Adamant> all the Web 2.0 types are now enchanted
19:23:56 <Axman6> Adamant: well, making ruby faster is like making poo look more attractive
19:24:03 <pumpkin> wow
19:24:09 <Adamant> Axman6: I like Ruby and Haskell better than Scala
19:24:16 <pumpkin> same here
19:24:22 <Axman6> i dislike ruby
19:24:24 <pumpkin> ruby isn't poo
19:24:26 <Adamant> I don't see the point of Scala
19:24:30 <pumpkin> I like it a lot, but the interpreter sucks
19:24:34 <Adamant> besides Java interop
19:24:36 <Adamant> that's about it
19:24:40 * ivanm has never used ruby, but isn't that big a fan of Python :s
19:24:44 <monochrom> The Dark Side is pure, too.
19:24:46 <Adamant> everything it does it done better by OCaml or Haskell
19:24:50 <Adamant> or SML
19:24:53 <ivanm> Adamant: I think that's the whole point
19:25:00 <monochrom> Or rather, the Dark Side has a Pure Dark Side, too.
19:25:02 <dolio> Adamant: It's better than Java.
19:25:07 <ivanm> "we've got heaps of JVM libraries, available, but the language sucks... so let's create a new one!"
19:25:24 <ivanm> monochrom: where they _never_ do anything remotely considered as good for anyone?
19:25:25 <Adamant> dolio: Clojure is nicer than Scala IMO
19:25:26 <Axman6> i think python will become much more important if this LLVM thing google's working on for it takes off
19:25:36 <dolio> I haven't really looked at either.
19:25:48 <monochrom> Pure is always good. It ticks off common people. It avoids success.
19:25:55 <Adamant> Axman6: they're just recapitulating all the work that was done on the Lisps and Smalltalks
19:26:03 <Adamant> to make them reasonably fast
19:26:12 <pumpkin> yeah, I like a language that has principles, like haskell
19:26:12 <thoughtpolice> Adamant: I like clojure a lot
19:26:15 <dolio> Technically I have no experiential basis for claiming Scala is better than Java, but I think it's a safe bet.
19:26:31 <ivanm> monochrom: oh, so it's not that the researchers wanted to keep their toy to themselves that the unofficial motto is "avoid success at all cost"... it's because Haskell is _pure_! :o
19:26:31 <Adamant> dolio: your bet is safe, it's not as bad
19:26:34 * ivanm is englightened
19:27:00 <ghcai> can you push towards hackage with darcs or cabal?
19:27:00 <Adamant> I am only a dabbler with Clojure and Scala so take my options with a major grain of salt
19:27:01 <pumpkin> so how do scala and clojure differ? I confuse them both as "oh, the functional language on jvm"
19:27:08 <ivanm> ghcai: cabal-install can
19:27:12 <pumpkin> ghcai: did you like my strip?
19:27:24 <dolio> Clojure is lisp, isn't it?
19:27:25 <Adamant> pumpkin: Clojure is functional Lisp, Scala is functional OCaml-alike
19:27:29 <pumpkin> ah
19:27:32 <ivanm> pumpkin: Scala is haskell-like, Clojure is apparently a lisp
19:27:40 <Adamant> I wouldn't call it Haskell like
19:27:40 <ivanm> IIRC
19:27:44 <monochrom> You will be enlightened on the second order if you know to ask "but why did they make it pure".
19:27:47 <ghcai> pumpkin: clojure is much more functional, more so than scheme i think since datastructures work like in haskell
19:27:49 <ivanm> Adamant: well, more haskellian than clojure is...
19:27:49 <Adamant> that's an insult to Haskell
19:28:08 <pumpkin> ah
19:28:08 <Adamant> it's really an insult to OCaml to compare it to that either
19:28:09 <ivanm> monochrom: just so it would have no success so they could keep their toy to themselves?
19:28:14 <monochrom> Yeah!
19:28:16 <ghcai> scala felt heavy like C++ when i tried it. looked good on paper but i didnt dig it to much
19:28:24 <monochrom> Haskell is invented not discovered to be pure.
19:28:30 <pumpkin> ghcai: did you decide on which golfed strip to use? :P
19:28:30 <ivanm> monochrom: so how I do reach the third stage of enlightenment?
19:28:40 <pumpkin> (mine please!)
19:28:53 <ghcai> pumpkin: yes i always liek your stuff :P. i chose strip = unwords . words; in the end
19:29:01 <pumpkin> ghcai: but that's wrong!
19:29:05 <pumpkin> :(
19:29:06 <monochrom> When you design your own language and you know why you design it your way.
19:29:17 <ghcai> why?
19:29:47 <pumpkin> > (unwords . words $ "     hello     world     ") == "hello     world"
19:29:49 <lambdabot>   False
19:29:50 <ghcai> monochrom: you mean haskell isn't truth?
19:29:56 <ghcai> heresy heresy!
19:30:00 <ghcai> @slap monochrom
19:30:01 <pumpkin> ghcai: that's why
19:30:01 * lambdabot karate-chops monochrom into two equally sized halves
19:30:05 <ivanm> monochrom: oh, so if I'm happy and satisfied with haskell I'll never reach the third stage of enlightenment? :(
19:30:08 <monochrom> Or, when you find out that your PhD supervisor knows nothing either. That's when you can get a PhD.
19:30:16 <ivanm> monochrom: heh
19:30:24 <Axman6> > unwords . words $ "     hello     world     "
19:30:25 <lambdabot>   "hello world"
19:30:28 * ivanm is still waiting on funding decisions regarding PhD
19:30:42 <ghcai> pumpkin: yeha i see, that isnt really a problem though
19:30:51 <pumpkin> ghcai: my version doesn't suffer from that :(
19:31:00 <ghcai> so which one was that?
19:31:08 <ghcai> takewhile dropwhile?
19:31:15 <pumpkin> > join . init . tail . group . (" " ++).(++ " ") $ "    hello   world     "
19:31:17 <lambdabot>   "hello   world"
19:31:18 <ivanm> pumpkin: what did you do? reverse . takeWhile isSpace . reverse . takeWhile isSpace ?
19:31:29 <ivanm> s/takeWhile/dropWhile/;
19:31:39 <kerlo> There are stages of enlightenment?
19:31:51 <ivanm> kerlo: so zen master monochrom says...
19:31:59 <pumpkin> ivanm: nope, that was saizan's one (expressed more succinctly with a join)
19:32:11 <ivanm> *nod*
19:32:22 <gwern> @quote zen
19:32:23 <lambdabot> Wild_Cat says: [on #python] (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
19:32:33 <ivanm> heh
19:32:50 <kerlo> I have the Wikipedia article "Zen" open right now.
19:32:55 <ivanm> that's not true... more than half the financial world had problems with the financial crisis!
19:33:05 <ivanm> what is the sound of one hand clapping?
19:33:10 <ivanm> does a dog have the buddha nature?
19:33:11 <ivanm> ;-)
19:33:14 <kerlo> @slap ivanm
19:33:15 * lambdabot karate-chops ivanm into two equally sized halves
19:33:23 <kerlo> Also, mu.
19:33:26 <kerlo> ...I think.
19:33:28 <ivanm> do my two pieces each have the buddha nature? :p
19:33:33 <gwern> ivanm: 3 pounds of flax
19:33:39 <kerlo> Ooh, that's a koan I'm not familiar with.
19:33:51 <ivanm> gwern: oh?
19:34:05 <kerlo> Oh, apparently a dog does have the Buddha-nature.
19:34:09 * ivanm -> lunch
19:34:20 <ghcai> i dont quite get yours pumpkin
19:34:26 <bitrot> does a A novice asked the master: "Whenever I program on a new system I must learn a new language.  Why are there no standards?"
19:34:30 <ivanm> kerlo: IIRC, the argument goes that everything has the buddha nature, but the answer to that koan is "no" :s
19:34:50 <bitrot> The master turned away. "The only true standard is Death", he said
19:35:13 <bitrot> s/does a//
19:35:27 <kerlo> I see.
19:35:42 <gwern> as wumen writes, if you affirm the buddha-nature, you lose your own
19:35:50 * kerlo nods
19:36:06 <kerlo> Hmm, here's that koan, straight from Wikipedia: "Two hands clap and there is a sound; what is the sound of one hand?"
19:36:37 <kerlo> The thing is, if you try to clap with one hand, your hand will never hit anything, so it will continue moving forever.
19:36:57 <kerlo> So the sound of one hand clapping is the limit as time approaches infinity of an ever-changing system.
19:37:05 <ghcai> is Haskell Zen?
19:37:07 <kerlo> Periodic, even.
19:37:14 <bitrot> ghcai: no.
19:37:30 <ghcai> is Zen Haskell?
19:37:35 <kerlo> Haskell would be Zen if recursion were banned and the only type were forall a. a.
19:37:52 <ghcai> and use Hugs instead of ghc?
19:38:03 <kerlo> You have to continue programming forever, but once you finish, you will have the answer to everything.
19:38:08 <pumpkin> ghcai: what about it?
19:38:21 <ghcai> Hugs as in hugs
19:38:26 <ghcai> as in flowerpower
19:38:28 <pumpkin> I mean
19:38:31 <pumpkin> my strip
19:38:32 <ghcai> as in pseudo-zen
19:38:35 <pumpkin> you said you didn't get it
19:38:53 <bitrot> Programs are but dreams
19:38:55 <pumpkin> > group . (" " ++).(++ " ") $ "    hello   world     "
19:38:57 <lambdabot>   ["     ","h","e","ll","o","   ","w","o","r","l","d","      "]
19:38:58 <bitrot> Born in formless shapless Zen
19:39:02 <bitrot> We are but dreamers
19:39:07 <Gracenotes> baah
19:39:14 <pumpkin> > init . tail . group . (" " ++).(++ " ") $ "    hello   world     "
19:39:16 <lambdabot>   ["h","e","ll","o","   ","w","o","r","l","d"]
19:39:28 <pumpkin> > join . init . tail . group . (" " ++).(++ " ") $ "    hello   world     "
19:39:30 <lambdabot>   "hello   world"
19:39:39 <Gracenotes> or no you didnt
19:39:41 <ghcai> i do now
19:40:16 <pumpkin> :)
19:40:46 <monochrom> Shapeless Typeless Zen machine
19:42:37 <ghcai> Deterministic?
19:46:46 <gwern> ghcai: 'the enlightened man is one with causality'
19:47:00 <gwern> for this, the master was turned into a fox for 700 years
19:47:21 <gwern> 'the enlightened man is not at one with causality', for this he was reborn
19:48:58 <gwern> hyakujo's fox is one of the most difficult koans I've encountered; one of the longest as well
19:49:03 <kerlo> I thought it was 500 rebirths.
19:49:20 <kerlo> And a certain Causality Principle.
19:49:45 <gwern> well, you could consult your friendly neighborhood gateless gate and find out for sure
19:50:07 <kerlo> Anyway, I've figured out the answer to the one-hand-clapping koan.
19:53:48 <kerlo> It is evident that you have as well.
19:55:25 <ledzippelin> good morning :)
19:57:30 <ghcai> what is the Parsec symbol for AND? Ie opposite of <|> ?
19:58:14 <Gracenotes> intersection is parsers is not 'natural'
19:58:17 <Gracenotes> *in
19:58:35 <Gracenotes> context-free languages are closed under union, but not intersection
19:59:11 <Gracenotes> although.. parsec might support it. it's not bound by any rules after all.
20:00:03 <Gracenotes> of course using monadic effects you can implement intersection in your own way :X depends.
20:00:46 <dolio> I can't think of how you'd do it without getting and setting the stream state, if that's even allowed anymore.
20:10:23 <kerlo> It's pretty convenient that Parsec isn't bound by any rules. I use it in my gas tank; it works pretty well.
20:10:43 <edwardk> can someone cabal update and cabal install monoids to make sure i didn't screw up a file inclusion or two like usual?
20:11:24 <ivanm> kerlo: :o
20:11:35 <pumpkin> > join . init . tail . groupBy ((&&) `on` isSpace) . (" " ++).(++ " ") $ "  \t  hello   world   \t  "
20:11:37 <lambdabot>   "hello   world"
20:11:55 <ivanm> pumpkin: have you caught wli's disease as well? :o
20:12:11 <pumpkin> ivanm: don't think so :) was just making split better
20:12:25 <pumpkin> I mean
20:12:26 <pumpkin> strip
20:12:26 <ivanm> heh
20:12:40 <dolio> Hah, monoids depends on category-extras?
20:12:51 <ivanm> strip, split, there's only one letter and a permutation difference ;-)
20:12:51 <edwardk> yeah i use Pointed and Copointed
20:13:04 <dolio> 2 out of 99 modules. :)
20:13:05 <edwardk> and there is a monoid category and some things
20:13:08 <edwardk> hah
20:13:13 <edwardk> yeah i need to make the dependencies into flags
20:13:46 <edwardk> dolio: yeah i need to make the dependencies here into flags because a lot of these dependencies are so i can add functionality to other modules
20:14:13 <pumpkin> edwardk: I think you should make a mathematically sound branch of GHC rather than just individual modules for it :P
20:14:29 <edwardk> pumpkin: a lot of it just can't be typed in haskell
20:14:39 <Cale> edwardk: Seems to install okay :)
20:14:42 <pumpkin> :(
20:14:44 <ivanm> edwardk: what do you type it into then?
20:14:45 <edwardk> cale: woot
20:15:00 <dolio> Wow, monoids has 44 modules of its own.
20:15:11 <edwardk> dolio: its a growing boy
20:15:22 <edwardk> dolio: my ocd occasionally has its uses ;)
20:15:39 <edwardk> considering i started it a week ago
20:15:57 <dolio> Works here.
20:16:02 <edwardk> some of those modules are pretty tiny though
20:16:08 <edwardk> otoh, some are a few hundred lines
20:16:11 <dolio> Yes, they build pretty fast.
20:16:29 <monochrom> @remember kerlo It's pretty convenient that Parsec isn't bound by any rules. I use it in my gas tank; it works pretty well.
20:16:30 <lambdabot> Okay.
20:17:05 <pumpkin> lol
20:17:20 <kerlo> Is lambdabot's quote database available in any public place?
20:17:51 <ivanm> kerlo: I don't know about the latest version, but you can get the one in darcs...
20:17:53 <dolio> This 6.10.2 release will be handy. All my reinstalled libraries will pick up the --enable-library-profiling, so I won't have to manually rebuild packages that I'd previously forgot about.
20:17:59 <edwardk> mostly what i did this last build was move Data.Generator out from Data.Monoid.Generator, so it wouldn't be confused with the  'generator of a monoid' and refactored a bunch of stuff to support fields.
20:18:08 <ivanm> dolio: oh? what does it do?
20:18:35 <edwardk> oh and added a Data.Reflection based Reducer that can let you just supply a reduction function so you don't have to use the Self monoid transformer
20:18:47 <dolio> It builds profiling libraries automatically with cabal-install. When I started with 6.10 I didn't have it enabled in the configuration.
20:18:55 <edwardk> it let me get myself out of some corners i had painted myself into
20:19:15 <dolio> So I build a bunch of libraries without profiling binaries, and had to go back later when I tried using them.
20:19:30 <edwardk> ah
20:19:52 <ivanm> dolio: is it a ghc or a cabal-install option?
20:20:13 <dolio> ~/.cabal/config
20:20:22 <dolio> library-profiling: True
20:20:26 <edwardk> nice
20:20:50 <andddd> hi
20:20:53 * QtPlaty[HireMe] wonders why mappend isn't spelt ++
20:21:14 <edwardk> QtPlaty[HireMe]: back in Haskell 98 they made a lot of the library less polymorphic
20:21:15 <ivanm> QtPlaty[HireMe]: the report
20:21:24 <edwardk> QtPlaty[HireMe]: that was one of the casualties
20:21:26 <ivanm> edwardk: because they didn't think about it? or to simplify it?
20:21:36 <edwardk> ivanm: to avoid terrifying newbies with error messages
20:21:38 <andddd> a
20:21:46 <dolio> (++) used to be mplus, though, technically speaking.
20:21:47 <QtPlaty[HireMe]> Ah
20:21:47 <edwardk> ivanm: we've been feeling the pain ever since
20:21:56 <edwardk> dolio: true
20:22:07 <edwardk> yeah mappend should be (+) =)
20:22:08 <ghcai> what does ; do in Parsec?
20:22:10 <dolio> That's still better than just list appending. :)
20:22:13 <edwardk> see Data.Monoid.Additive.Sugar ;)
20:23:44 <edwardk> i at allow plus and zero as aliases for mappend and mempty throughout the monoid lib, and i let you throw caution to the wind with the .Sugar modules which ignore the existence of the prelude
20:24:13 <ivanm> edwardk: you mean there is no Prelude?
20:24:19 <ivanm> just like there's no cake? :o
20:24:33 <edwardk> ivanm: the .Sugar modules conflict with the prelude and mention in their docs what you should hide from the prelude if you import them
20:24:40 <QtPlaty[HireMe]> edwardk: I wouldn't because I expect that.  a + b == b + a
20:25:10 <edwardk> ivanm: my convention is that Foo.Combinators should be qualified as Foo and Foo.Sugar should be imported driectly with the prelude equiv hdiden
20:25:49 <edwardk> QtPlaty[HireMe]: unfortunately when you want to build up from monoid you want to add a multiplicative layer on top, for rings, semirings and near-semirings. you don't have commutativity in all of those scenarios
20:26:00 * pumpkin hires QtPlaty[HireMe]
20:26:10 <edwardk> QtPlaty[HireMe]: the a + b = b + a is a good convention for fields, but it breaks down in weaker structures
20:26:16 <ivanm> pumpkin: how much you paying him?
20:26:32 <pumpkin> ivanm: I can afford about a dollar a month
20:26:59 <ivanm> QtPlaty[HireMe]: is that enough for you?
20:27:26 <QtPlaty[HireMe]> ivanm: I'll get back to you  :D
20:27:43 <edwardk> QtPlaty[HireMe]: since most computer science structures aren't commutative rings, and there is no other operator to suggest itself to take that slot, i take the liberty that you cannot assume that plus is commutative unless you inherit from a class that says yours is ;)
20:28:30 <QtPlaty[HireMe]> edwardk: That sort of makes sence.
20:29:07 <edwardk> QtPlaty[HireMe]: its also necessary to view it as addition when you go to view monads and applicatives wrapped around monoids as nearsemirings, because in that case the nearsemiring's addition is the monadplus and the multiplication is the addition of the monoid.
20:30:06 <edwardk> when you go further from there and allow algebras over (near) (semi)  rings you need to have a later on top of that addition, which is the multiplication operation again
20:30:11 <edwardk> er layer
20:30:58 <edwardk> afk for a bit
20:31:17 <QtPlaty[HireMe]> edwardk: Digests that while edwardk is afk
20:34:10 <gwern> 'T is for true, which does very little.
20:34:11 <gwern> U is for uniq, which is used after sort, and
20:34:11 <gwern> V is for vi, which is hard to abort.
20:34:58 <edwardk> QtPlaty[HireMe]: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Ring-Semi-Near.html
20:35:13 <ivanm> gwern: wtf?
20:35:42 <gwern> ivanm: don't you know your ABCs?
20:35:55 <ivanm> not in a unix context I don't...
20:36:44 <gwern> it's very easy
20:36:47 <gwern> 'A is for awk, which runs like a snail, and
20:36:48 <gwern> B is for biff, which reads all your mail.
20:36:48 <gwern> C is for cc, as hackers recall, while
20:36:48 <gwern> D is for dd, the command that does all.
20:36:59 <ivanm> dd does everything? :o
20:37:12 <ghcai> is haskell truth?
20:37:17 <SnailRacer> C is for C and that's just wrong
20:37:29 <gwern> @faq Is haskell for truth?
20:37:30 <lambdabot> The answer is: Yes! Haskell can do that.
20:39:56 <Hunner> actually, with sort -u you don't need uniq
20:41:38 <jmcarthur> weird. i tweak the haxr .cabal to use HTTP < 4000, install it, then try to install vacuum-ubigraph, which tries to reinstall haxr for now apparent reason
20:41:42 <ivanm> alias uniq="sort -u"
20:41:43 <jmcarthur> ghc-pkg lists it and everything
20:41:56 <jmcarthur> (this is with cabal-install)
20:42:01 <ivanm> jmcarthur: did you use any build flags?
20:42:04 <gwern> Hunner: you sound like a useless use of cat person...
20:42:06 <jmcarthur> OH
20:42:14 <jmcarthur> probably profiling or something
20:43:21 <jmcarthur> hmm, no...
20:44:05 <gwern> maybe it was trying to link vacuum against a haxr linked against http4k
20:45:01 <jmcarthur> haxr links against http4k?
20:45:01 <ivanm> jmcarthur: it also is probably getting the hackage version...
20:45:38 <jmcarthur> so if i tweak a package, cabal will still try to replace it with the hackage version?
20:46:07 <jmcarthur> well, cabal-install i mean
20:47:16 <ivanm> yeah, I think so
20:47:19 <ivanm> @seen dcoutts
20:47:20 <lambdabot> dcoutts is in #happs, #gentoo-haskell, #haskell, #ghc, #haskell-overflow, #haskell-soc and #darcs. I last heard dcoutts speak 3h 23m 13s ago.
20:47:29 <ivanm> hmmm.... the expert is hiding again...
20:48:17 <jmcarthur> it's okay for now. i'll just do it manually
20:48:28 <jmcarthur> would be nice to work out a solution of some sort though
20:49:08 <SnailRacer> >(map fst).(filter (\(a,b)->(a/=b)||(not(isSpace a))))$(\m -> zip m ((tail m)++[head m])) "Hello   world."
20:49:31 <Tsion> Hi, I'm new to Haskell. How can Haskell differentiate between "" and []? They are both just empty lists, right?
20:50:28 <TSC> :t ""
20:50:29 <lambdabot> [Char]
20:50:43 <TSC> They are both empty lists indeed, but "" has type [Char]
20:51:06 <sm> how do I disable an on-by-default cabal flag at the commandline ?
20:51:59 <Tsion> TSC: So it's possible to have say, an empty list of type Num?
20:52:07 <ivanm> Tsion: no
20:52:20 <ivanm> you can have an infinite list of type "(Num a) => a" though
20:52:26 <ivanm> note that Num is a typeclass, not a type
20:52:27 <TSC> Num isn't a type, but you could have an empty list of Ints
20:52:35 <Tsion> oh
20:52:50 <TSC> :t ([] :: [Int])
20:52:51 <lambdabot> [Int]
20:53:16 <ivanm> :t ([] :: (Num a) => a)
20:53:18 <lambdabot>     Couldn't match expected type `a1' against inferred type `[a]'
20:53:18 <lambdabot>       `a1' is a rigid type variable bound by
20:53:18 <lambdabot>            the polymorphic type `forall a1. (Num a1) => a1'
20:53:24 <ivanm> :t ([] :: (Num a) => [a])
20:53:25 <lambdabot> forall a. (Num a) => [a]
20:55:17 <kerlo> For any type a in Num, you can have an empty list of type [a].
20:55:37 <sclv> Numeric.FAD++
20:56:06 <sclv> I'm going to drop that newton function right into an existing codebase tomorrow. yay.
20:59:03 <NameAlreadyInUse> what is a "monomorphic" type?
20:59:36 <kerlo> One that doesn't have any subtypes, I guess?
20:59:49 <sclv> a monomorphic type is a normal type.
20:59:55 <sclv> i.e. Int, String, etc.
21:00:14 <sclv> as distinct from a polymorphic type, which is free but constrained potentially by typeclasses.
21:00:19 <sclv> i.e. Show a => a
21:00:31 <meanburrito920_> how would i declare a type for a tuple of ints with length 3?
21:00:45 <ivanm> meanburrito920_: (Int, Int, Int)
21:00:59 <meanburrito920_> ivanm: ah duh. thanks
21:01:09 <ivanm> no worries
21:01:27 <NameAlreadyInUse> sclv: so a in  "a -> a" isn't monomorphic?
21:02:03 <sclv> the function "id" is polymorphic over all a.
21:03:40 <sclv> but id "foo" is monomorphic, because once you pass a string to it, that fixes the result.
21:04:12 <ivanm> :t id id
21:04:14 <lambdabot> forall a. a -> a
21:04:16 <ivanm> ;-)
21:04:27 <Jarie> my professor has recommended that we use OCaml for a new project instead of Haskell, because Haskell doesn't have the capability of having data members that are non-global
21:04:42 <Jarie> any thoughts on this matter?
21:05:02 <SubStack> why would you want to have global anything?
21:05:06 <ivanm> Jarie: ummm.... Haskell doesn't have global variables...
21:05:10 <Jarie> Non-global
21:05:11 <arjanb> non-global in what sense?
21:05:20 <ivanm> what do you mean by "non-members"?
21:05:22 <meanburrito920_> can anyone explain to me why the following code errors? i know it is probably something simple: (code and error pastebin
21:05:26 <meanburrito920_> http://pastebin.com/m4d7b575c
21:05:29 <ivanm> * "data members"
21:05:36 <blackh> Jarie is talking about field names
21:05:37 <SubStack> umm... what
21:05:41 <NameAlreadyInUse> i was under the impression that Data declarations could be completely encapsulated in modules
21:05:58 <SubStack> import qualified?
21:06:12 <ivanm> meanburrito920_: looks like you're trying to use tuples as lists
21:06:16 <Jarie> Yes field names
21:06:18 <ivanm> python might support that; haskell doesn't
21:06:26 <ivanm> Jarie: why do you want an inline data structure?
21:06:31 <Jarie> I was taught that haskell has severe problems and isnt ready for use because of the Field names problem
21:06:41 <meanburrito920_> ivanm: not exactly, i just want to unpack the members of the tuple to use them in the list comprehension
21:06:58 <SubStack> Jarie: that's quaint
21:07:04 <meanburrito920_> ivanm: ah. i think i see the error
21:07:07 <sclv> that's absurd.
21:07:09 <NameAlreadyInUse> sclv: is "id :: String -> String" monomorphic?
21:07:18 <ivanm> Jarie: what problem?
21:07:24 <sclv> NameAlreadyInUse: yep
21:07:26 <Jarie> as far as I understand it, haskell cannot have two different datatypes with the same field name
21:07:32 <Jarie> which sounds totally unusable
21:07:45 <sclv> Jarie: it can't if they're in the same module and you only use the record syntax.
21:07:50 <blackh> Jarie: This is what I think on the subject: The "field names problem" is slightly annoying if you are not used to it, and I've come to realize that the annoyance is so slight that nobody has bothered fixing it.
21:07:54 <Jarie> what if you are putting a bunch of types in a module
21:08:02 <Jarie> then you have to create 500 files every little module you ever use?
21:08:14 <SubStack> then don't do that
21:08:16 <sclv> or just use different names.
21:08:19 <blackh> Jarie: Once you're used to it, it isn't a problem. A namespace is a namespace. Java uses 'class' as its namespace, Haskell uses 'module'
21:08:21 <Jarie> <sclv> or just use different names.
21:08:22 <NameAlreadyInUse> i am yet to use record syntax, is it really a big deal?
21:08:23 <Jarie> ahahahah
21:08:26 <Jarie> are you kidding
21:08:44 <Jarie> Thats like saying. Damn. My car only has three weels.   "Or just don't drive fast."
21:08:50 <Jarie> that's no solution
21:08:53 <blackh> NameAlreadyInUse: It's pretty easy to use and useful.
21:09:14 <sclv> Jarie: lots of people write lots of complex production code despite Haskell's dead-simple record system.
21:09:16 <dolio> Haskell data types don't really have named fields. Thus, there is no problem. :)
21:09:27 <blackh> Jarie: People often overlook the advantage in the way Haskell does it:
21:09:30 <sclv> And with a little work, there are bunches of template-haskell based solutions.
21:09:35 <Jarie> it's a problem when you have foo _ _ _ x _ _ _ _
21:09:39 <sclv> (i've written two or three myself)
21:09:39 <Jarie> and you cant remember what is what
21:09:55 <blackh> Jarie: A field name has the useful property of implying a type.
21:10:16 <Jarie> idunno this whole thing seems ass backward like we're stuck back in the 60's or something
21:10:18 <sclv> Jarie: seriously. lots of modules aren't a problem, and otherwise, you can always prefix each selector with some indication of what it refers to.
21:10:33 <Jarie> i mean the "ability to have types with field names" thing was solved what, before I was even alive
21:10:38 <Jarie> and yet Haskell is still broken
21:10:40 <Jarie> that doesnt make sense
21:10:42 <sclv> "solved"
21:11:09 <sclv> record selectors in haskell are functions with monomorphic types. records are *nothing* like objects in other, broken languages
21:11:09 <Philippa_> Jarie: it wasn't solved in the context of a lang like Haskell until the mid-90s
21:11:10 <blackh> Jarie: You can't have two fields with the same name in a Java class or C struct, right?
21:11:23 <Jarie> Philippa, which lang like Haskell solved it?
21:11:30 <Philippa_> and that solution overlaps with other Haskell features
21:11:31 <arjanb> if the fields thing is the problem you're probably trying to hard to force OO style coding into Haskell
21:11:33 <Philippa_> Jarie: ocaml
21:11:35 <Jarie> well my Prof recommended OCaml cause it doesnt have this problem
21:11:48 <blackh> Jarie: Why would you want two fields with the same name in a Haskell module? - the reasoning is the same.
21:11:58 <Jarie> blackh: no thats insane
21:12:01 <Jarie> your mind is warped
21:12:08 <dolio> No, your mind is warped.
21:12:10 <blackh> Jarie: Just because you can put lots of Java classes in one file doesn't make it a good idea.
21:12:10 <Jarie> any normal person would want that
21:12:15 <dolio> You're trying to write Java programs in Haskell.
21:12:18 <sclv> ocaml doesn't have first class selectors.
21:12:23 * Philippa_ finds she wants extensible variants more often than extensible records, but she's working with compilers
21:12:26 <sclv> that's broken too, depending on your outlook.
21:12:42 <Philippa_> sclv: though not by much because they're easy to create
21:12:52 <kerlo> @remember everyone No, your mind is warped.
21:12:53 <sclv> yeah, i'm just feeding the troll.
21:12:53 <lambdabot> Good to know.
21:12:56 <blackh> Jarie: You should have one Java class per file, and one Haskell data structure per file.
21:13:10 <sclv> kerlo: plz don't crap up bot
21:13:14 <Gracenotes> I'm just feeding my kitty
21:13:19 <Jarie> blackh: i dont agree on that, sometimes I want little types that are relevant to this file to be in the file
21:13:20 <sclv> erm, \bot's quote db that is.
21:13:28 <kerlo> Mmkay.
21:13:33 <sclv> @forget everyone No, your mind is warped.
21:13:33 <lambdabot> Done.
21:13:43 <Gracenotes> @quote everyone
21:13:43 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:13:49 <Jarie> I dont see any kind of sound logical reasoning behind " you should have one file per class " besides syntactical problems
21:13:50 <Philippa_> blackh: you have a problem when the one data structure doesn't correspond to a single haskell datatype
21:13:50 <Gracenotes> ahahahahahahahaha okay
21:14:01 <Gracenotes> @quote transformer
21:14:01 <lambdabot> monochrom says: krad!  I'm reading Bird's haskell book now.  It has fusion, parser monad, and monad transformers!  If I read this book instead of Paulson's ML book ten years ago, the history of the
21:14:01 <kerlo> Oh, that's a nice command.
21:14:01 <lambdabot> entire human race would have to be rewritten!
21:14:04 <Jarie> I mean where's the real solid argument for that
21:14:22 <Gracenotes> @. vixen quote
21:14:23 <lambdabot> what's a program?
21:14:41 <Philippa_> though to be fair, if it really is one big datatype you can declare a typeclass to handle the record stuff - you just can't use record syntax with it
21:14:47 <blackh> Jarie: If "one Java class per file" is in dispute, then I can't argue with you.
21:14:51 <sclv> Jarie: there are lots of tradeoffs in selectors, and there are good and bad things about haskell's approach. this is far from unusable however.
21:16:05 <sclv> here's one way to do extensible records in haskell that i cooked up a while ago (there are better ones too, mind you): http://fmapfixreturn.wordpress.com/2008/05/03/simple-extensible-records-now-quick-generic-tricks-pt-1/
21:16:09 <Nafai> Jarie: For example, I find it completely unreasonale that Java doesn't allow me to have first clsas functions
21:16:42 <Jarie> but why assume Java is any kind of benchmark
21:17:02 <blackh> Jarie: Is the way Java handles field names acceptable?
21:17:22 <Jarie> Maybe, but I am just thinking in terms of haskell
21:17:23 <Philippa_> Jarie: ocaml doesn't have typeclasses. Eventually that will drive you nuts too
21:17:40 <sclv> in any case haskell's record syntax is at worst a minor annoyance, is the point.
21:17:58 <Philippa_> welcome to the state of programming languages in 2009: there's a definite niche for a new language to combine the best of haskell and the ML world
21:18:07 <Jarie> we tried to find a GHC extension that would solve this
21:18:08 <blackh> Jarie: If the Java compiler allows only one public class per file (which it does), and that's acceptable, then why is it not acceptable for Haskell to work the same way?
21:18:13 <Jarie> and were surprised to find it doesnt exist
21:18:16 <Jarie> any idea why
21:18:17 <Jarie> ?
21:18:29 <Philippa_> because nobody can pick a definite 'right answer'
21:18:32 <blackh> Jarie: I know why...
21:18:41 <Philippa_> and GHC HQ are extremely loathe to just pick /an/ answer
21:19:01 <sclv> ... and it isn't a big deal, in the meantime.
21:19:08 <blackh> Jarie: It's because it has never been enough of a problem for anyone to have the motivation to fix it.  Once you gain a bit of experience in Haskell, it ceases to be a problem.
21:19:41 <sclv> the "right answer" isn't just about sharing names in fields, but about generic lightweight extensible records that preserve type-safety, and that's a much bigger concern.
21:20:19 <Philippa_> one that's likely to get broken by any quick fix in the meantime
21:20:27 <blackh> Jarie: In my opinion, it isn't perfect, but I don't find it to be a problem in practice.
21:20:29 <sclv> and you can do something like those too already, but it involves HLists :-(
21:20:40 <sclv> which are tricky if you don't know what you're doing.
21:21:46 <sclv> and if you're just hacking around and want to throw type-safety to the wind (please don't!) you can just use a map of dynamics.
21:24:27 <Jarie> thanks for help guys, the records thing is really scary...
21:28:11 <NameAlreadyInUse> if OCaml doesn't have type classes or something similar, what do they use instead?
21:28:43 <scook0> their module system, iirc
21:28:53 <blackh> NameAlreadyInUse: I can only give second hand info: The article "Caml trading" complained that OCaml doesn't have the equivalent of Haskell's "show"
21:29:15 <shepheb> anyone with war stories about building turbinado recently?
21:29:16 <blackh> NameAlreadyInUse: ...assuming I understood it correctly
21:30:20 <dolio> They also use, for instance +. for floating point addition (and so on), by default at least.
21:30:39 <dolio> There might be a way to have more generic operators using modules. I'm not sure.
21:31:02 <scook0> and where have things like Data.Map with Ord constraints all over the place
21:31:30 <meanburrito920_> does anyone know how haskell implements infinite lists. i know its lazy, but lets say i have [1,2..] and i want to grab the first 65 elements. great. now i want to grab the first 1000 elements. will it use the already generate 65 elements as part of the process? or will it regenerate? because it has to generate the last element first due to its linked list implementation, so it seems as though there would be issue wit
21:31:30 <meanburrito920_> h that.
21:31:32 <scook0> they would use a parameterized module, that must be instantiated with a particular element type and functions that define an ordering for that type
21:31:42 <Gracenotes> hm. it would be interesting to make a Num instance for []
21:32:01 <scook0> meanburrito920_: it sort of depentds on exactly what you do
21:32:05 <Gracenotes> then you can have "hello" + "world". To the embarrassment of all sane people
21:32:12 <scook0> Gracenotes: pretty sure people have done that sort of thing
21:32:18 <meanburrito920_> scook0: in what sense?
21:32:27 <Gracenotes> scook0: indeed
21:33:34 <dolio> What's 'abs "hello"'?
21:33:38 <scook0> meanburrito920_: well, if you have take 65 [1,2..] and later take 1000 [1,2..], the elements will be generated twice
21:33:52 <Gracenotes> dolio: id, I suppose
21:34:05 <scook0> dolio: well, nobody said it was a particularly sane instance
21:34:10 <Gracenotes> you probably couldn't make an abs for something like a matrix, even
21:34:27 <ivanm> Gracenotes: if by "abs" you mean determinant, then prob not
21:34:32 <Gracenotes> except maybe an abs of all the elements, assuming there was a Num constraint
21:34:35 <scook0> meanburrito920_: but if you do let xs = [1,2..] in (take 65 xs, take 1000 xs), they will be shared
21:34:36 <ivanm> IIRC, determinant is only defined for square matrices
21:34:42 <ivanm> and the type would be wrong, anyway
21:34:44 <NameAlreadyInUse> scook0: are you sure? i thought they would be memoized?
21:34:49 <Gracenotes> ivanm: yeah
21:35:02 <blackh> That's what I thought too.
21:35:04 <ivanm> NameAlreadyInUse: there is no inbuilt memoization in Haskell...
21:35:16 <scook0> the compiler tends not to do arbitrary common-subexpression-elimination
21:35:19 <ivanm> you can simulate it by having a Map over all possible values, but that's about it AFAIK
21:35:22 <Gracenotes> NameAlreadyInUse: taking make the spine of the list
21:35:29 <blackh> ivanm: That's not true - I know that constant values are memoized. It would be easy enough to try...
21:35:34 <scook0> because it can drastically change the time/space behaviour of your code in unexpected ways
21:35:35 <Gracenotes> however, for a simple sequence like [1,2..], that's not too helpful
21:35:42 <ivanm> blackh: that's not memoization AFAIK...
21:35:43 <Gracenotes> *makes
21:36:00 <scook0> individual thunks are updated with their eventual values
21:36:01 <ivanm> memoization means memorizing the outputs of a function for inputs if they've already been calculated
21:36:08 <meanburrito920_> scook0: thanks. it makes sense now that i think about it
21:36:18 <scook0> but if you create multiple thunks representing the same computation, they'll usually proceed independently
21:36:29 <NameAlreadyInUse> i am going to try to test this
21:36:35 <Gracenotes> if there's a particularly hard point in getting the next element of the list (say) 50 elements in, then the next time you go past that point it won't take so long
21:36:50 <Gracenotes> (just using the spine)
21:37:07 <blackh> I just tried, and the answer is that if you do 'take 5 a' then 'take 10 a' it only calculates the second half
21:37:42 <scook0> blackh: yes, that is the expected behaviour
21:37:58 <Gracenotes> all is going to plan!
21:38:01 <Gracenotes> @vixen mwahahahahaha
21:38:02 <lambdabot> are you being sincere?
21:38:06 <ddarius> The canonical example is the following two definitions of powerset: powersetA [] = [[]]; powersetA (x:xs) = xss ++ map (x:) xss where xss = powersetA xs  v.  powersetB [] = [[]]; powersetB (x:xs) = powersetB xs ++ map (x:) (powerset xs)
21:38:07 <Gracenotes> .. maybe.
21:38:32 <blackh> @let banana = map (\x -> unsafePerformIO $ putStr ("<"++show x++">") >> return x) [1..10]
21:38:33 <lambdabot>  <local>:9:20: Not in scope: `unsafePerformIO'
21:38:37 <blackh> Smeg
21:38:50 <ivanm> ddarius: but that's not memoization, is it...
21:38:53 <blackh> Prelude System.IO.Unsafe> let banana = map (\x -> unsafePerformIO $ putStr ("<"++show x++">") >> return x) [1..10]
21:38:53 <blackh> Prelude System.IO.Unsafe> take 5 banana
21:38:53 <blackh> [<1>1,<2>2,<3>3,<4>4,<5>5]
21:38:53 <blackh> Prelude System.IO.Unsafe> take 10 banana
21:38:53 <blackh> [1,2,3,4,5,<6>6,<7>7,<8>8,<9>9,<10>10]
21:39:07 <ivanm> that's just being more clever with your function definition
21:39:08 <Gracenotes> crafty, sir
21:39:10 <ddarius> ivanm: It's not an example of memoization.  It's an example of why you wouldn't want CSE.
21:39:20 <ivanm> *nod*
21:39:33 <ivanm> ddarius: why is it an example of why you wouldn't want CSE?
21:39:37 <Gracenotes> blackh: see also Debug.Trace :X
21:39:40 <ddarius> ivanm: Try each.
21:39:41 * ivanm is only half-following this thread...
21:39:51 <ivanm> ddarius: infinite list problems?
21:39:59 <ivanm> that's the only thing I can think of...
21:40:01 <ddarius> ivanm: They're semantically the same.
21:40:24 <ivanm> CSE == "hey, these look the same so might as well make them the same" ?
21:40:48 <Gracenotes> what type of semantics deals with evaluation order and the like?
21:40:53 <scook0> do { forM_ [1..veryLargeNumber] print ; forM_ [1..veryLargeNumber] print }
21:41:09 <ivanm> scook0: yeah, that's what I was thinking
21:41:14 <scook0> without CSE, this will consume a small amount of memory
21:41:20 <ivanm> very large/infinite lists will consume a lot of memory for cases like that
21:41:22 <scook0> with CSE, it will consume a very large amount of memory
21:41:27 * ivanm has experienced that problem before
21:41:46 <ivanm> I was just checking that CSE was what I thought it was
21:42:11 <ddarius> CSE = common subexpression elimination which means naming a subexpressing and sharing its value
21:42:17 <scook0> that's CSE in the context of haskell, at any rate
21:42:43 <ddarius> CSE is a compilation term, not a language term.
21:43:15 <ivanm> *nod* what I thought
21:43:24 <scook0> perhaps I should have said "in the context of GHC-haskell as we currently understand it"
21:43:55 <alpha-beta> hi
21:44:14 <blackh> alpha-beta: HI!
21:44:18 <scook0> after all, there's no guarantee that "Haskell" is actually lazy
21:44:35 <scook0> and even GHC isn't lazy 100% of the time
21:44:46 <pumpkin> :o
21:44:55 <pumpkin> it's not lazy when you ask it not to be
21:45:04 <ivanm> scook0: just non-strict?
21:45:04 <pumpkin> or use types that can't be lazy
21:45:13 <ivanm> pumpkin: you mean unboxed types?
21:45:18 <pumpkin> yup
21:47:19 <scook0> ivanm: aye
21:47:56 <scook0> iirc there's a race condition that exists in certain types of multithreaded code
21:48:12 <scook0> that makes it possible for two threads to execute the same thunk for a brief time
21:48:36 <scook0> which doesn't actually matter if your pure code really is pure
21:49:37 <blackh> scook0: I know from experience that for extreme performance, it's usually better to ensure your code is pure and tolerate race conditions of this type than prevent them.
22:15:02 <travisbrady> i'm writing a function that runs readInt twice and therefore can encounter Maybe twice, is there a nice way to return Nothing if either of them is Nothing without having to match on both of them separately?
22:15:56 <ddarius> liftM2 combine readInt readInt
22:17:03 <travisbrady> @hoogle combine
22:17:04 <lambdabot> System.FilePath.Posix combine :: FilePath -> FilePath -> FilePath
22:17:04 <lambdabot> System.FilePath.Windows combine :: FilePath -> FilePath -> FilePath
22:17:04 <lambdabot> Language.Haskell.TH.Lib combine :: [([(Name, Name)], Pat)] -> ([(Name, Name)], [Pat])
22:17:29 <ddarius> combine was generic
22:18:04 <ivanm> travisbrady: what should it do if they're both Just ?
22:18:05 <travisbrady> how do you mean?
22:18:09 <ivanm> you could possibly use a monad...
22:18:21 <ivanm> travisbrady: ddarius meant write a combine function that assumes they're both Just
22:18:22 <ddarius> travisbrady: It was a stand-in, i.e. if you want to add them combine = (+{
22:18:24 <travisbrady> ivanm: if they're both just I want -> Just (a, b)
22:18:29 <ivanm> oh...
22:18:34 <ddarius> Then combine = (,)
22:18:39 <ivanm> > liftM2 (,) (Just 2) (Just 3)
22:18:41 <lambdabot>   Just (2,3)
22:18:43 <travisbrady> oh i see
22:18:44 <ivanm> > liftM2 (,) (Just 2) Nothing
22:18:46 <lambdabot>   Nothing
22:20:47 <Nafai> Where's liftM2?
22:20:53 <NameAlreadyInUse> Control.Monad
22:21:21 <ddarius> @hoogle liftM2
22:21:22 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:21:30 <travisbrady> ddarius, ivanm: thank you
22:27:27 * pumpkin resolves to use Applicative more
22:29:27 * edwardk resolves to use infix `fmap` more just to taunt pumpkin ;)
22:29:48 <pumpkin> lol, I don't care :P
22:30:15 <edwardk> @type fmap `fmap` fmap
22:30:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:30:20 <edwardk> hrmm, that sounds dirty
22:30:46 <edwardk> @type fmap `fmap` fmap `fmap` fmap
22:30:48 <Heffalump> neat, functor composition
22:30:49 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
22:30:55 <pumpkin> :0
22:31:39 * edwardk keeps fmapping like this and i'm going to need a cigarette
22:32:18 <pumpkin> Heffalump: do you have an RApplicative and an RTraversable yet? :P maybe the module should just be called restricted!
22:32:19 <pumpkin> :P
22:32:23 <pumpkin> lol
22:33:16 <wli> RArrow?
22:33:21 <pumpkin> I want it
22:33:41 <pumpkin> I even proposed it on the haskell proposals subreddit, but people didn't seem too enthusiastic
22:34:34 <edwardk> pumpkin: well, a large part of that is that you have to have functions in your applicative's source category, so that rules out most of the interesting monads anyways
22:34:47 <Heffalump> pumpkin: I started writing RApplicative but it's tricky - didn't I mail the rmonad list about it?
22:34:49 <travisbrady> ddarius: how am i able to unpack (s, l) here?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3240#a3240 that should be a maybe right?  i also don't understand how the final return type is a Maybe, since 'v' just a ByteString
22:34:49 <edwardk> pumpkin: er exponentials in the source
22:34:59 <Heffalump> or rather the types aren't necessarily that helpful
22:35:18 <pumpkin> Heffalump: oh, maybe, I have a filter putting mailing lists into their own label and haven't checked it
22:35:27 <pumpkin> I'll look now
22:35:50 <edwardk> Heffalump: yeah kinda expected. the very thing that makes Applicative a valid superclass of Monad in Haskell kinda keeps you from having many useful classes of values that you can include in the applicative that doesn't cover everything
22:36:07 <Heffalump> I think EDSLs might provide an example
22:36:10 <Heffalump> but I'm not sure
22:36:13 <Heffalump> anyway, I have to go to work now
22:36:37 <edwardk> i suppose if it just had restrictions on the source and destinations of each function type you can lift into it
22:37:00 <pumpkin> :)
22:37:05 <Heffalump> yeah, as long as its closed over the -> it'd work
22:37:07 <edwardk> (Appropriate f a, Appropriate f b) => f (a -> b) -> f a -> f b
22:37:12 <edwardk> or whatever you called it
22:37:14 <pumpkin> Suitable
22:37:28 <Heffalump> really got to go
22:37:32 <pumpkin> ciao :)
22:37:32 <edwardk> ok, go =)
22:37:51 * edwardk continues talking about the topic to taunt Heffalump as he heads for the door
22:39:06 <pumpkin> how about RTraversable :) just need to stick Rs on the various bits
22:39:49 <edwardk> pumpkin: i have almost an RTraversable inside of the generator framework in monoids
22:39:54 <edwardk> its basically an RFoldable
22:40:21 <pumpkin> hmm
22:40:34 <wli> RGeneric?
22:40:53 <pumpkin> you and heffalump should agree on your Suitables so you can use each other's stuff
22:41:50 <edwardk> well, the generator stuff has a slightly different api and focus, so it doesn't fit the suitable class right now, since it uses a type family that indicates content type. so maybe its not a full rfoldable
22:41:59 <pumpkin> ah
22:42:21 <edwardk> pumpkin: http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Generator-Combinators.html has a lot of Foldable-like functions though
22:43:14 <edwardk> RFoldable/RTraversable are actually not a bad idea
22:44:09 * edwardk is trie'ing to figure out how to implement (\\) for tries that accumulate a monoid up the tree, whenever that monoid is actually a group
22:44:17 <pumpkin> it seems like if it's possible to make all those "lift any type into me" classes into restrictable ones, we might as well
22:44:26 <pumpkin> who knows what someone might do with it
22:45:20 <edwardk> pumpkin my first stab at that generator api used something like that but i found i had to fix one thing or the other, the generator had to have a fixed content type or the monoids could only reduce one kind of value
22:45:31 <edwardk> or i ran into ambiguous type signatures
22:45:42 <pumpkin> could functional dependencies help there?
22:45:54 <edwardk> the type family plays the role of a fundep
22:46:12 <pumpkin> ah yeah
22:46:13 <edwardk> adding a fundep causes me to fix one thing or the other ;)
22:47:07 <edwardk> i found it more useful to leave the reducers unconstrained because then you can do things like let the MaxPriority monoid consume either a's or Maybe a's as you see fit
22:47:47 <travisbrady> how is it that the return type of the parseRleString function here is Maybe (ByteString, Int, Int)?  i would think (s, l) would be inside a maybe, but somehow v, which is just a bytestring when packed up in a tuple with s and l gets wrapped in a maybe
22:47:51 <travisbrady> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3240#a3240
22:48:00 <edwardk> or you can let the Traversal monoid consume any Applicative f => f a even though it ignores the a, yielding a natural encoding of traverse_
22:48:18 <edwardk> traverse_ = getTraversal . reduce
22:48:52 <edwardk> er traverse_ f = getTraversal . mapReduce f
22:48:57 <edwardk> forgot there was a function involved ;)
22:49:44 <edwardk> parseRleString?
22:49:59 <edwardk> oh, didn't see paste
22:50:47 <travisbrady> somehow the compiler is inferring from my use of liftM (i think) that it needs to package up whatever I return inside a Maybe...or so i'm guessing
22:50:50 <edwardk> travisBrady : erm, when you return you wrap things in Just
22:51:03 <edwardk> return doesn't mean what it does in imperative languages
22:51:18 <travisbrady> could i also use pure in this case?
22:51:19 <edwardk> in the Maybe monad "return = Just"
22:51:29 <edwardk> in the Maybe applicative "pure = Just" as well ;)
22:52:10 <travisbrady> so is the result of the liftM2 not also inside a maybe?
22:52:22 <Gracenotes> yes, for the maybe mona
22:52:23 <travisbrady> looking at it i would guess so, since readInt returns a maybe
22:52:24 <Gracenotes> d
22:52:48 <edwardk> travisbrady: yes it is, but the <- does 'magic' which i'll explain in a sec ;)
22:53:16 <edwardk> travisbrady: do x <- y; z -- gets translated into y >>= \x -> z
22:53:24 <edwardk> @type (>>=)
22:53:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:53:36 <travisbrady> oh and I can use liftA2 instead of liftM2
22:53:46 <edwardk> you can but it doesn't change anything
22:53:54 <Gracenotes> I don't believe there's a variant like (a -> b -> ... -> j -> m z) -> m a -> m b -> ... -> m j -> m z, is there?
22:54:23 <Gracenotes> differing from liftMX in that the first argument's function returns an m z instead of a z
22:54:25 <edwardk> join $ liftMn foo a b c d e f
22:54:51 <Gracenotes> yes, there's that, but I'm not entirely convinced join would do the right thing in all cases
22:55:00 <pumpkin> how does sequence . repeat differ from forever?
22:55:02 <edwardk> erm it better thats a law =)
22:55:45 <Gracenotes> hrm. just seems odd from a programming perspective to add a monad layer and then remove it
22:55:51 <Gracenotes> although that's a natural operation in the CT sense
22:56:13 <pumpkin> very natural
22:56:17 <pumpkin> so natural, it's naked
22:56:22 <travisbrady> edwardk: so does my "(s, l) <- ..." extract the pair out of the Maybe?
22:56:25 <Philippa_> Gracenotes: "build it, run it"
22:56:31 <edwardk> gracenotes: mathematicians define monads using the fmap, join and return. what you have there is a final fmap, and a join pending.
22:56:46 <Gracenotes> yes, me knows :x
22:57:05 <Gracenotes> hm. liftMx is a sort of extended fmap.
22:57:24 <Gracenotes> well, x = 1 => fmap
22:57:28 <edwardk> travisbrady: kind of what happens is your '(s,l) <- ...; something' actually makes up a function '\(s,l) -> something' behind your back and then passes it into the bind operation of the monad
22:57:42 <edwardk> gracenotes: yes, but every liftMn ends in an liftM
22:58:20 <travisbrady> edwardk: ohhhhh, that's kind of non-explicit in a way that is both cool but also makes me want to know exactly what's being done
22:58:21 <edwardk> the last operation is ultimately do ...; z <- z'; return (f x y z) -- which is liftM (f x y)
22:58:54 <Gracenotes> it's liftMs all the way down!
22:59:11 <edwardk> so the law that defines how join and bind are related says that what i said about just joining the output of liftMn is always safe in a valid monad
22:59:15 <sOpen> is there a way to define multiple function patterns for a lambda? or a way to define these in the repl?
22:59:19 <edwardk> Gracenotes: actually its not ;)
22:59:19 <Gracenotes> but, join in a 'programming' sense is not so intuitive as to why it's necessary. in a CT sense, join and fmap are all you have
22:59:32 <edwardk> gracenotes: only the last one is a liftM, the others need to use bind or ap
23:00:29 <edwardk> travisbrady the maybe monad's definition of >>= may choose to use your function or not. for instance
23:00:34 <edwardk> Nothing >>= _ = Nothing
23:00:35 <edwardk> but
23:00:40 <edwardk> Just x >>= k = k x
23:00:46 <Gracenotes> edwardk: what distinguishes the last one? that there's no ap after it?
23:01:28 <edwardk> so if your liftM2 returns Nothing, then when that gets desugared, you don't have a value of type a to feed to your function of type (a -> m b) -- so the only thing it cna do is give you back a Nothing
23:01:34 <edwardk> gracenotes: the shape.
23:01:38 <edwardk> @src liftM
23:01:38 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
23:02:40 <edwardk> the others can't use the same 'turn it into a call to liftM trick'
23:02:47 <edwardk> @src liftM2
23:02:47 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:02:49 <pumpkin> @@ @undo @src liftM
23:02:50 <lambdabot>  ()
23:02:53 <pumpkin> o.O
23:03:19 <edwardk> i can rewrite the second in the form: liftM2 f m1 m2 = do { x1 <- m1; liftM (f m1) m2 }
23:03:20 <travisbrady> pumpkin: whoa, what the?
23:03:33 <edwardk> but i can't get rid of that <- m1 the same way because the seocnd thing i do isn't return
23:04:04 <edwardk> so the law that says (>>= return . f) = fmap f doesn't apply
23:04:38 <Gracenotes> sOpen: in one line: let blah 0 = foo; blah n = baz
23:04:38 <Gracenotes> if not on the same line, it's redefined
23:04:38 <Gracenotes> you can also specify type in a let statement
23:05:00 <sOpen> Gracenotes, at the end with :: Type?
23:05:11 <edwardk> @undo \f m1 = do { x1 <- m1; return (f x1) }
23:05:11 <lambdabot>  Parse error at "=" (column 7)
23:05:12 <travisbrady> edwardk: in your rewritten form of liftM2 is the x1 bit necessary since it doesn't get used?
23:05:25 <edwardk> @undo  \f m1 -> do { x1 <- m1; return (f x1) }
23:05:25 <lambdabot> \ f m1 -> m1 >>= \ x1 -> return (f x1)
23:05:34 <edwardk> @pl \ f m1 -> m1 >>= \ x1 -> return (f x1)
23:05:34 <lambdabot> fmap
23:06:13 <edwardk> @. pl . undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:06:13 <lambdabot> Plugin `compose' failed with: Unknown command: "\\f"
23:06:30 <edwardk> @. pl undo \f m1 m2 -> do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:06:30 <lambdabot> liftM2
23:06:33 <edwardk> hah
23:06:33 <Gracenotes> sOpen: yeah. Like: let n :: Int -> Int; n x = x+1
23:07:10 <edwardk> oh woops travis i typod
23:07:21 <edwardk> liftM2 f m1 m2 = do { x1 <- m1; liftM (f x1) m2 }
23:07:23 <edwardk> there ;)
23:07:28 <Gracenotes> OHNOS
23:07:30 <sOpen> Gracenotes, ohh... I was using let x = 0 :: Int and getting confused :-) thanks
23:08:06 <Gracenotes> sOpen: hm? that should work
23:08:18 <sOpen> Gracenotes, yes... but not with multiple clauses ;-)
23:08:19 <edwardk> @pl  \f m1 m2 -> do { x1 <- m1; liftM (f x1) m2 }
23:08:19 <lambdabot> (line 1, column 16):
23:08:20 <lambdabot> unexpected "{"
23:08:20 <lambdabot> expecting variable, "(", operator or end of input
23:08:20 <Gracenotes> if it's just that on the line. your case might be more complicated.
23:08:34 <Gracenotes> sOpen: ah. in that case some parens would take care of it
23:08:42 <Gracenotes> but the let blah :: foo is convenient too
23:08:44 <edwardk> @undo  \f m1 m2 -> do { x1 <- m1; liftM (f x1) m2 }
23:08:44 <lambdabot> \ f m1 m2 -> m1 >>= \ x1 -> liftM (f x1) m2
23:08:45 <Gracenotes> sometimes
23:08:52 <edwardk> @pl \ f m1 m2 -> m1 >>= \ x1 -> liftM (f x1) m2
23:08:53 <lambdabot> liftM2
23:08:56 <edwardk> hah
23:09:06 <Gracenotes> wild applause for edw
23:09:10 <Gracenotes> ardk
23:09:22 <edwardk> meh, back to tries and groups and rings
23:16:27 <pumpkin> thoughtpolice: you around?
23:19:54 <pumpkin> ah well, bedtime
23:25:13 <jakeluck> how does one autowrap the strings with "" when outputting to a csv via putStr?
23:25:35 <ivanm> > show "hi!"
23:25:37 <lambdabot>   "\"hi!\""
23:25:54 <ivanm> note that when you putStr it, it will just be "hi!"
23:26:54 <jakeluck> i wish there is something that let's one remember the parsec tree and reverse the process
23:27:30 <ramesh> i have a question on the zip function.
23:27:46 <ramesh> we have multiple zip functions zip3 , zip4 etc
23:28:17 <ramesh> instead can we not have a single zip function which takes a list of lists and performs the zip or zipWith function on that
23:28:29 <ramesh> I am a newbie. pardon me if my question is dumb
23:28:36 <pumpkin> you could use a fold over zippers
23:28:42 <pumpkin> using applicative
23:28:47 <pumpkin> but then you don't get tuples
23:29:09 <pumpkin> I meant ziplists
23:29:14 <jakeluck> you can simulate that with pattern matching
23:29:20 <ramesh> ok the challenge is to get the tuples. if i am ok for the result to be a list also then i can do the same
23:29:28 <ramesh> using fold
23:29:32 <ramesh> thanks
23:29:45 <pumpkin> ramesh: it's more than a challenge ;)
23:29:50 <pumpkin> it's impossible in haskell
23:29:54 <glguy> ramesh, transpose is half of what you are describing
23:30:07 <edwardk> @src transpose
23:30:07 <lambdabot> transpose []             = []
23:30:07 <lambdabot> transpose ([]   : xss)   = transpose xss
23:30:07 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
23:30:07 <glguy> but then your function would have to take all of its arguments of the same type
23:30:21 <ramesh> oh ok i see
23:30:25 <edwardk> > transpose [[1,2],[4,5]]
23:30:27 <lambdabot>   [[1,4],[2,5]]
23:30:29 <ramesh> i was infact trying to write my own transpose
23:30:35 <ramesh> for a set of strings
23:30:44 <ramesh> and then got this question
23:30:45 <edwardk> > transpose ["hello","world"]
23:30:47 <lambdabot>   ["hw","eo","lr","ll","od"]
23:37:56 <jakeluck> going from ["hello","make","curry"](data) to  "hello","make","curry"\n(output)
23:38:18 * jakeluck trys to find a neat oneliner
23:42:48 <ivanm> jakeluck: putStrLn . unwords . map show
23:43:03 <ivanm> > unwords $ map show ["hello", "make", "curry"]
23:43:05 <lambdabot>   "\"hello\" \"make\" \"curry\""
23:43:29 <jakeluck> i guess i can then use missingh's replace " " ","
23:43:52 <ramesh> >mapM putStr ["hello","make","carry"]
23:44:09 <ivanm> ramesh: that won't make them space separated
23:44:09 <ramesh> > mapM putStr ["hello","make","carry"]
23:44:11 <lambdabot>   * Exception: "<IO [()]>"
23:44:26 <ivanm> ramesh: and it won't print the quotes
23:44:47 <ivanm> jakeluck: putStrLn . intersperse "," . map show
23:44:50 <ivanm> ^^ that should do it
23:45:04 * ivanm didn't see the quotes
23:45:08 <ivanm> s/quotes/commas/
23:45:34 <ivanm> jakeluck: note that if you're printing to file, replace putStrLn with the appropriate function
23:45:46 <ivanm> hPutStrLn, IIRC
23:45:51 <ivanm> @hoogle FilePath -> String -> IO ()
23:45:52 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
23:45:53 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
23:45:53 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
23:45:56 <jakeluck> yup, thank you, life is good
23:46:10 <ivanm> OK, appendFile is probably what you want
23:46:21 <jakeluck> *nod*
23:46:31 <ivanm> well, you might need to do writeFile foo "" first to create the file
23:47:40 <jakeluck> maybe death by mosquito bytes, working on a 80MB txt
23:48:33 <ivanm> jakeluck: if you're doing it one line at a time, you should be fine
23:48:37 <ivanm> laziness++ ftw! ;-)
23:48:40 <ivanm> @karma laziness
23:48:41 <lambdabot> laziness has a karma of 4
23:48:47 <jakeluck> heh
23:49:28 <ivanm> is that all?!?!? :o
23:49:53 <jakeluck> what is 1,2 and 3 then?
23:50:03 <glguy> probably due to all of the people lamenting space-leaks
23:50:17 <jakeluck> @karma leak
23:50:18 <lambdabot> leak has a karma of 0
23:50:35 <jakeluck> @karma space-time-leak
23:50:36 <lambdabot> space-time-leak has a karma of 0
23:51:09 <ivanm> jakeluck: ummm... that means someone did laziness++ four times
23:51:12 <ivanm> well, five now ;-)
23:51:16 <ivanm> @karma laziness
23:51:17 <lambdabot> laziness has a karma of 5
23:51:20 <ivanm> space-leaks--
23:51:53 <jakeluck> aha
23:52:06 <_zenon_> Hi there
23:52:17 <_zenon_> Loong time no see, I'm swamped with school and all
23:52:48 <jakeluck> zeno, what's keeping your busy?
23:54:52 <_zenon_> jakeluck, It's the master's thesis and a course at the side of it.
23:55:17 <_zenon_> jakeluck, I'll hopefully be an engineer when I grow up :)
23:55:51 <jakeluck> that's reverse application :) people nowadays grow by engineering
23:56:15 <jakeluck> what's your thesis topic?
23:56:26 <_zenon_> Identifying User Based on Input Devices
23:56:30 <_zenon_> it's machine learning and AI
23:57:05 <jakeluck> and you are using haskell for the implementation?
23:59:04 <_zenon_> Nah, we wanted to keep to the functional arena, but got thrown to Ruby. The company used a hackup of Python, Lisp, C and whatnot, now they are focusing things to Ruby.
23:59:51 <jakeluck> it is amazing how ruby for such a loyal following for the past 3 yearts
