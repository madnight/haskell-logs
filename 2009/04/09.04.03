00:00:02 <jakeluck> s/got/for
00:00:45 <_zenon_> jakeluck, yeah. But I must say it's quite smooth to work with.
00:01:38 <edwardk> hrmm. never had darcs pull this before. darcs failed:  Error applying hunk to file ./Data/Monoid/Combinators.hs
00:02:17 <ivanm> :o
00:02:22 <ivanm> edwardk: someone sent a dodgy patch?
00:02:37 <edwardk> ivanm: single repository, no third party patchers
00:02:47 <edwardk> ivanm: i work locally and push up to another server thats it
00:03:10 <ivanm> hmmm...
00:04:17 * edwardk joined #darcs to see if i can get a fix there
00:07:00 <wli> Rumor has it xen is using ocaml.
00:10:05 <ivanm> wli: :o
00:10:11 <ivanm> xen as in the virtualisation stuff? :o
00:10:35 <ivanm> I know that the fastest fourier transform in the west uses ocaml...
00:11:07 <sclv> wli: they gave a talk on it at cufp last year.
00:11:20 <edwardk> wli: its not much of a rumor, its pretty well known
00:19:06 <wli> It's the first I've heard of it.
00:19:36 <ivanm> sclv: what do they use ocaml for?
00:20:40 <wli> Probably userspace stuff.
00:20:44 <sclv> lots of things, as i recall. don't remember the details offhand.
00:22:29 <sclv> http://cufp.galois.com/2008/slides/MadhavapeddyAnil.pdf
00:24:28 <sclv> also: http://groups.google.com/group/ocaml-developer/browse_thread/thread/8d32548e11238778/c03e1627cc04d6a7
00:25:41 <vixey> anyone has a parametrised nondet state monad?
00:27:03 <sclv> vixey: what exactly do you mean?
00:27:28 <sclv> nondet over state, state over nondet, paramaterised by what?
00:27:53 <vixey> I thikn I got to go back to the drawing board
00:31:58 <wli> hmm
00:35:49 <wli> vixey: Look for Tomita parsers?
01:21:39 <vixey> where could I find some simple examples of monadic programs?
01:21:56 <vixey> some kinds of short functions which exemplify each basic monad
01:25:56 <_boegel_> hiya all
01:26:21 <_boegel_> what's the easiest way to get GHC working on a system on which I have no root access, and where no older GHC is available yet
01:27:01 <_boegel_> I'm not afraid to build GHC from source, but I'm guessting I need GHC to build GHC? or is it able to bootstrap itself?
01:27:38 <vixey> I thought that /was/ bootstrapping
01:28:59 <ivanm> _boegel_: you need ghc to build ghc
01:29:03 <ivanm> which OS are you using?
01:29:13 <_boegel_> ivanm: Scientific Linux
01:29:17 <ivanm> you can install a binary ghc in your user directory (I've done that before)...
01:29:20 <ivanm> s/user/home/
01:29:27 <_boegel_> ivanm: I'm trying to get GHC working on our new supercomputer...
01:29:43 <ivanm> what architecture does it use?
01:29:46 <_boegel_> ivanm: I could ask the admins, but I'd rather figure it out myself ;-)
01:29:54 <_boegel_> ivanm: Intel Xeon, so x86_64
01:30:16 <_boegel_> ivanm: but that requires libedit, right? afaik, it's not on there (yet)
01:30:17 <vixey> why you would run haskell on a super computer :?
01:30:22 <ivanm> _boegel_: OK, get the generic linux x86_64 binary from haskell.org/ghc and unpack it into your home directory
01:30:30 <ivanm> _boegel_: hmmm... good point
01:30:33 <_boegel_> vixey: to use my nifty tools on it
01:30:37 <ivanm> get one of the 6.8 ones then?
01:30:39 <vixey> ok
01:30:48 <_boegel_> ivanm: those don't require 6.8?
01:30:50 <vixey> seems weird to me
01:31:00 <_boegel_> ivanm: err, don't require libedit?
01:31:02 <vixey> I have a sci-fi image of what super computers are though
01:31:04 <ivanm> nope, readline
01:31:14 <_boegel_> vixey: I just like using Haskell to create small tools that chew on a lot of data
01:31:27 <ivanm> _boegel_: or you can try getting the gentoo binary 6.10.1 package we've made, which uses kolmodin's patches to use readline instead of libedit
01:31:29 <_boegel_> vixey: supercomputers are just a bunch of computers linked together
01:31:41 <ivanm> _boegel_: no they're not (necessarily)
01:31:41 <_boegel_> vixey: but you can use each node seperately, like I'm doing
01:31:46 <ivanm> e.g. Crays
01:31:49 <vixey> so basically it's just a powermac :p
01:32:02 <ivanm> _boegel_: if you use the gentoo binary though, you own't have ghci
01:32:09 <ivanm> vixey: heh
01:32:18 <_boegel_> ivanm: I don't need ghci, just GHC
01:32:51 <_boegel_> vixey: the main difference is that huge jobs, using 128+ cores, can be run without fiddling too much with communication between nodes
01:33:11 <_boegel_> vixey: one can just use MPI, and rely on the system software to make everything work and scale well
01:33:13 <ivanm> _boegel_: OK,  http://haskell.org/~kolmodin/ghc-bin-6.10.1-r2-amd64.tbz2 might work for you
01:33:30 <ivanm> just unpack it to your home directory, and add ~/usr/bin to your PATH
01:34:03 <ivanm> see, if we had erlang-style concurrency then haskell would be really cool to use on one of those cluster-style supercomputers...
01:34:19 <ivanm> s/concurrency/parallelism.
01:34:25 <ivanm> s/.////
01:34:34 <ivanm> gah, whatever the syntax is
01:34:54 <_boegel_> ivanm: how good is GHC at producing threaded code that would use 8 cores well? (given you have parallellizable work to do?
01:35:13 <_boegel_> ivanm: I'll give that a try
01:35:31 <ivanm> _boegel_: pretty good from what I've heard (I've never done any parallel stuff in haskell), but it's closer to an OpenMP style of parallelism than MPI
01:36:03 <ivanm> not in terms of memory sharing/passing
01:36:09 <ivanm> (this is AFAIK, anyway)
01:36:27 <ivanm> just in that you have the one instance of the program that uses multiple CPUs/cores/etc.
01:41:21 <boegel> vixey: one instance that uses multiple cores on one machine is all I need
01:41:43 <boegel> vixey: I suppose just compiling with -threaded would do the trick, for the most part?
01:42:03 <boegel> vixey: basically, everything using map should be easily parallellizable
01:42:03 <vixey> I don't really know.. my tries with -threaded jsut make the program slower..
01:42:25 <quicksilver> well yes, -threaded has overheads
01:42:34 <quicksilver> it will only speed things up if you actually use the other cores enough.
01:43:46 <ivanm> dons did a blog post on that for something once...
01:44:09 <ivanm> fibonacci, IIRC
01:44:14 <ivanm> @go dons fibonacci parallel
01:44:15 <lambdabot> No Result Found.
01:44:20 <ivanm> @go haskell fibonacci parallel
01:44:23 <lambdabot> http://www.haskell.org/haskellwiki/Fibonacci_primes_in_parallel
01:44:23 <lambdabot> Title: Fibonacci primes in parallel - HaskellWiki
01:44:29 <ivanm> gah
01:44:43 <vixey> @go Fibonacci primes in parallel
01:44:44 <lambdabot> http://www.haskell.org/haskellwiki/Fibonacci_primes_in_parallel
01:44:45 <lambdabot> Title: Fibonacci primes in parallel - HaskellWiki
01:45:38 <ivanm> http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/26#no-headaches
01:45:41 <ivanm> boegel: ^^
01:46:13 <ivanm> oh, that's not it :s
01:47:52 <ivanm> http://donsbot.wordpress.com/2007/11/29/use-those-extra-cores-and-beat-c-today-parallel-haskell-redux/
01:48:03 <ivanm> ^^ has a cutoff in their code which determines whether to use parallel or not
01:56:27 <_boegel_> vixey: is it possible that kolmodin's tarball is meant to be extracted as root, i.e. in /usr/bin and /usr/lib64?
01:56:41 <_boegel_> vixey: I'm seeing stuff like "usr/bin/ghc: line 3: /usr/lib64/ghc-6.10.1/ghc: No such file or directory"
01:56:49 <_boegel_> vixey: unless I missed something obvious
01:56:56 <ivanm> _boegel_: oh.... maybe it is :s
01:57:08 <_boegel_> vixey: I added ~/usr/bin to PATH and ~/usr/lib to LD_LIBRARY_PATH, but no aval
01:57:11 <_boegel_> ivanm: oh well :)
01:57:12 <ivanm> I didn't know we had anything specific like that...
01:57:37 <ivanm> _boegel_: did you add ~/usr/lib64 to LD_LIBRARY_PATH? :s
01:57:43 <vixey> probably some esoteric tar option
01:57:50 <_boegel_> ivanm: yeah, lib64 is what I meant
01:58:06 <luap> is there an alternative for faster list concatination? I have a statement:  (a ++ b), and the size of a grows (to like 50.000), and b is always small (like 10)
01:58:06 <ivanm> _boegel_: maybe just LDPATH ?
01:58:35 <ivanm> luap: no
01:58:41 <ivanm> well, you can use dlists...
01:58:58 <quicksilver> it's probably compiled with hard coded paths
01:59:11 <_boegel_> quicksilver: yeah, I think so too
01:59:28 <_boegel_> ah well, then I'll have to rely on a 6.8 version of GHC to compile my own
01:59:37 <luap> but it slows my code down like crazy :(
01:59:42 <_boegel_> alhtough that'll require libedit too, right?
02:00:05 <ivanm> _boegel_: you can try manually applying kolmodin's patches if you then boostrap from 6.8.3 to 6.10.1 ...
02:00:15 <ivanm> _boegel_: 6.8 uses readline
02:00:28 <_boegel_> luap: maybe think about the order of the (++) arguments, that might make a lot of difference
02:00:32 <_boegel_> @src (++)
02:00:33 <lambdabot> []     ++ ys = ys
02:00:33 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
02:00:33 <lambdabot> -- OR
02:00:33 <lambdabot> xs ++ ys = foldr (:) ys xs
02:00:58 <_boegel_> luap: try using the smallest list as the first argument, that might make a huge difference
02:01:21 <ivanm> luap: DLists have O(1) for the equivalent of (++) ...  but converting to normal lists is then O(n) because it does all the actual (++) of the underlying lists
02:01:30 <_boegel_> ivanm: but I really want the latest and greatest GHC, especially because I want to use the parallel runtime :)
02:02:36 <luap> ok, but i have to think of my code will still work, using (b++a) , but ill look to dlists also, tnx :)
02:02:51 <ivanm> _boegel_: 1) download the official 6.8.3 binary for 64bit; 2) download the 6.10.2 source; 3) apply kolmodin's listed here: http://code.haskell.org/gentoo/gentoo-haskell/dev-lang/ghc/ghc-6.10.2.ebuild
02:02:55 <ivanm> 4) build the patched ghc
02:03:17 <quicksilver> ivanm: although really it's only O(number of elements you access)
02:03:24 <quicksilver> ivanm: ...if you start from the head, I mean
02:03:30 <ivanm> quicksilver: something like that, yeah
02:03:33 <quicksilver> ivanm: which is no "worse" than accessing that list anyway.
02:03:38 <_boegel_> ivanm: how about installing libedit in ~/lib, and make GHC use that? :)
02:03:46 <quicksilver> well, worst case O(number of concatenations + number of elements)
02:03:55 <ivanm> quicksilver: yeah...
02:04:02 <jacobian> I find that when I port code form SML I tend to end up with haskell code with infinite loops due to the way that lets work differently in the two
02:04:03 <jedai> luap: Generally (++) isn't that slow
02:04:06 <ivanm> it's just explicit rather than implicit laziness
02:04:10 <ivanm> _boegel_: that'll probably work
02:04:12 <jacobian> Does anyone have suggestions on tracking down infinite cycles?
02:04:18 <vixey> oh I hate that with the lets
02:04:21 <ivanm> it's just bad for system packaging because libedit isn't stable :s
02:04:39 <vixey> jacobian: is it inside do blocks?
02:04:40 <jedai> luap: what's slow is when you use it several time in a way that makes it O(n²) instead of O(n)
02:04:42 <_boegel_> jedai: unless you're using a huge list as wrong argument, then it needs to run over like 95% of the concatenated list :)
02:05:34 <jedai> _boegel_: Even then the cost isn't stupendous (it's still only O(n))
02:05:40 <ivanm> jedai: using that superscript 2 character is cheating! ;-)
02:06:06 <jedai> _boegel_: Sure if you can avoid it or put the argument the other way 'round, it's better
02:06:06 <ivanm> luap: what jedai is saying is that (a ++ b) ++ c is bad; a ++ (b ++ c) is OK
02:06:07 <bavardage> ²³²³²³²²²³²³²³²
02:06:20 <luap> ok, basically im doing a BFS, holding a list of results, and appending the new states. but the list grows very large and i concat the new states to it which are only 10 new states
02:06:25 <ivanm> one advantage of DLists is that they'll always (I think) do the eventual concatenations efficiently
02:06:25 <jedai> ivanm: Why ? ²_³
02:06:51 <ivanm> jedai: for those of us that can't be bothered working out how to do them ;-)
02:07:59 <jacobian> vixey: Mostly
02:08:33 <vixey> jacobian: in do blocks I use  a <- return $ f a  rather than  let a = f a  to solve it
02:08:34 <ivanm> jacobian: well, if it runs in infinite time then it's an infinite loop...
02:08:43 <ivanm> which AFAIK is the only sure way to tell...
02:08:44 <ivanm> ;-)
02:09:03 <ivanm> oh, is that what you're talking about...
02:09:13 * ivanm has experienced that mucking around in ghci
02:09:19 <luap> but i need the first elements of the list every itteration, so im wondering if dlists will speed it up.
02:09:24 <ivanm> I agree, that's a PITA
02:09:35 <jacobian> It's not the only sure way to tell surely
02:09:44 <jacobian> f = f  is provably non-terminating
02:09:53 <ivanm> luap: well, if you're doing a ++ (b ++ c), then you don't have to worry about DLists
02:09:55 <jacobian> I was just wondering if there were some sort of tools for finding cycles
02:10:15 <ivanm> i.e. doing the eventual concatenations before concatenating this list on the front
02:10:39 <ivanm> jacobian: I doubt there'd be a generic way of finding all such cycles
02:11:37 <jedai> ivanm: GHC detect a certain number of them
02:11:43 <vixey> you could probably put something sick together using TH
02:12:01 <ivanm> jedai: yes, but _all_?
02:12:17 <ivanm> wouldn't that be the halting problem?
02:12:23 <ivanm> or something like it
02:12:30 <quicksilver> no.
02:12:39 <quicksilver> languages without letrec can throw errors
02:12:50 <quicksilver> check for cyclic dependencies is easy enough.
02:12:55 <luap> but head on DList is still very slow?
02:13:04 <quicksilver> luap: no, it's not.
02:13:17 <jedai> Well of course it's impossible : Haskell is turing complete
02:13:22 <quicksilver> it's worst case O(number of concatenations)
02:13:32 <quicksilver> jedai: we're only talking about spotting cyclic data dependencies.
02:13:36 <quicksilver> not the halting problem.
02:13:51 <vixey> quicksilver: yeah but it's #haskell :p
02:14:02 <vixey> you got to mention the halting problem every so often
02:14:40 <jedai> quicksilver: Cyclic data dependencies aren't always so bad, it depends on if they're coinductives or not
02:15:18 * quicksilver screams.
02:15:22 <quicksilver> I know.
02:15:23 <vixey> lol
02:15:27 <quicksilver> I"m not an idiot.
02:15:35 <quicksilver> I know what the halting problem is, and I know that recursion is useful.
02:15:50 <ivanm> quicksilver: are we?
02:15:52 <quicksilver> it just happens we were discussing the topic of how you debug the infinite loop arising from 'accidental' recursion.
02:15:59 <ivanm> I thought we were talking about finding all infinite cycles...
02:16:09 <Alpounet> Me too.
02:16:15 <jedai> quicksilver: I know that you know but it bears repeating :)
02:16:32 * vixey waits for someone to mentions Godels incompleteness theorem
02:16:44 <vixey> oops
02:17:01 <lament> but what about godel's incompleteness theorem?
02:17:50 <ivanm> vixey: let's just see when we can invoke the all mighty powers of Godwin's Law...
02:19:50 <bavardage> ivanm: you are a nazi?
02:20:20 * bavardage is off to do a stats exam paper
02:20:21 <bavardage> :(
02:21:12 <lament> The Final Solution To The Halting Problem
02:21:17 <vixey> lol
02:21:30 <quicksilver> I prefer just to call it the Halting Solution.
02:24:08 <vixey> any good books on language design?
02:24:09 <jacobian> if people saw my question they'd no that it has nothing to do with corecursion :)
02:24:10 <ivanm> heh
02:24:37 <vixey> esp. would be cool reading about actual languages design process
02:27:15 <ivanm> vixey: the one you're going to write in the future? ;-)
02:27:33 <vixey> no
02:28:11 <lament> i think the actual process involves wild partying, hard drugs, hookers, and the kind of decision you regret in the morning, but by then it's too late to change the spec
02:28:40 <ivanm> vixey: :(
02:40:40 <wli> Pick up the sequent calculus.
02:41:17 <wli> I liked John C. Mitchell's "Foundations for Programming Languages."
02:47:40 <pozic> How can I build and install all the dependencies of a package, but not the package itself?
02:49:32 <doserj> pozic: Ctrl-C in the right moment :)
02:49:52 <JuanDaugherty> why would you want to do that?
02:50:45 <JuanDaugherty> (though saving the pre-build targets and copying them over the build result would do it)
02:51:00 <JuanDaugherty> *target
02:51:46 <JuanDaugherty> s/them/it/
02:52:38 <ivanm> JuanDaugherty: if you want to hack on that package?
02:53:20 <JuanDaugherty> prolly easier to just have multiple configurations
02:53:21 <jedai> ivanm: seems more logic to just build the package then
02:54:05 <jedai> ivanm: that should install whatever dependencies and let the package uninstalled but check that the base is fine
02:54:14 <ivanm> jedai: *shrug* just providing a possible reason
02:54:30 <ivanm> and if using cabal-install, it's a bit of a PITA IMHO to uninstall stuff
02:57:09 <jedai> ivanm: I'm not sure what you're speaking about ? There's nothing to uninstall in the solution I propose ? Except if you want to uninstall the dependencies afterward, in this case the easiest is to use another configuration file and installation directory like JuanDaugherty proposed
02:57:49 <ivanm> jedai: if you use cabal-install to install something from hackage, how do you uninstall?
02:58:07 <quicksilver> you don't.
02:58:12 <ivanm> quicksilver: heh
02:58:13 <quicksilver> packages are for life, not just for christmas.
02:58:39 <ivanm> @remember quicksilver [about uninstalling packages installed with cabal-install] packages are for life, not just for christmas.
02:58:40 <lambdabot> Okay.
02:59:07 <jedai> ivanm: Basically if you wish to uninstall them later, you install them as user, it makes it easier to uninstall them later
02:59:26 <ivanm> jedai: yes
02:59:31 <ivanm> but still, how do you uninstall?
02:59:35 <jedai> ivanm: You can also isolate them from your normal user-packages by changing the conf file
02:59:39 <ivanm> only way I've found is to unregister, then manually delete
02:59:46 <jedai> ivanm: right
03:00:05 <ivanm> whic is a PITA
03:00:05 <jedai> ivanm: and it's not that hard if you know where you installed your stuff
03:00:51 <pao> if you want to divorce from packages there is pkenv http://www.nabble.com/pkgenv---disposable,-isolated-pkg-environments-td22146204.html :-)
03:01:20 <pao> ivanm: just to collect some info for my personal poll
03:01:31 <pao> ivanm: do you use windows or unix?
03:01:35 <ivanm> neither
03:01:42 <pao> ivanm: what then?
03:01:55 <ivanm> I use a GNU/Linux distribution
03:02:07 <pao> ivanm: I classify that under unix :-)
03:02:15 <ivanm> well it isn't, it's a Unix clone
03:02:20 <ivanm> (or should that be UNIX?)
03:02:30 <ivanm> and GNU's Not Unix :p
03:02:32 <wli> Solaris?
03:02:32 <pao> ivanm: what is unix then? :-)
03:03:12 <ivanm> wli: that's a Unix
03:03:13 <bremner> not GNU, obviously
03:03:15 <McManiaC> focusFollowsMouse  :: !Bool <-- whats the ! ?
03:03:19 <ivanm> as it's derived from the original code
03:03:26 <ivanm> McManiaC: makes the !Bool strict
03:03:30 <ivanm> requires an extension IIRC
03:03:32 <pao> my very personal definition for unix is a OS that provides as a primary system interface a posix api
03:04:01 <McManiaC> ah okay
03:04:02 <bremner> pao: SCO's lawyers gave people good reason to dislike that definition
03:04:24 * quicksilver notes in passing that SCO bankrupted itself with ill-judged lawsuits :P
03:04:45 <quicksilver> ivanm: don't think so. strictness annotations are haskell98.
03:04:54 <ivanm> quicksilver: in a function definition?
03:05:04 * bremner notes he is not endorsing SCO's apparent position of owning posix
03:05:08 <pao> ivanm: give pkgenv a try (shameless commercial plug)
03:05:10 <ivanm> or am I thinking of "foo !a = ... " requiring an extension?
03:05:15 <ivanm> pao: what is it?
03:05:25 <ivanm> bremner: I don't recall them saying anything about posix...
03:05:27 <ivanm> just Unix
03:05:32 <quicksilver> ivanm: yes, BangPatterns is an extension.
03:05:34 <pao> @google pkgenv
03:05:35 <lambdabot> No Result Found.
03:05:37 <ivanm> and even so, I don't see the point if it occurred when HP owned Unix
03:05:43 <ivanm> quicksilver: *nod*
03:05:47 <quicksilver> ivanm: but stricness in data structures isn't.
03:05:49 <ivanm> OK, so bangs in type sigs are OK
03:05:55 <pao> ivanm: http://www.nabble.com/pkgenv---disposable,-isolated-pkg-environments-td22146204.html
03:06:23 <quicksilver> I don't think so, no.
03:06:33 <quicksilver> what McManiaC posted was, I assumed a field name from a record type
03:06:41 <ivanm> quicksilver: well, you just said they don't need an extension :s
03:06:44 <ivanm> quicksilver: ahhh
03:06:53 <ivanm> I thought it was from a function :s
03:07:17 <ivanm> pao: eh, if I need a new package installed I just create an ebuild
03:07:45 <pao> ivanm: gentoo?
03:08:38 <ivanm> yes
03:09:45 <pao> ivanm: I guess I don't understand what you mean by "I just create an ebuild"
03:10:07 <ivanm> I create an ebuild that installs that haskell package, and install it
03:10:13 <ivanm> then if I don't want it anymore, I uninstall it
03:10:34 <ivanm> typically, the only time I install anything locally is if I'm testing a package I'm writing
03:11:20 <pao> ivanm: clear
03:12:12 <tomh> with cabal is there something where you can say build-depends: time || old-time (ghc 6.10.2 renamed packages)
03:13:07 <tomh> oh i can probably use this: impl(ghc >= 6.6.1)
03:13:19 <quicksilver> ghc 6.10.2 did not rename time or old-time.
03:13:31 <ivanm> it just didn't ship with it
03:13:59 <quicksilver> the time/old-time split was back in 6.6, I think
03:14:00 <quicksilver> or 6.4
03:14:09 <quicksilver> old-time contains System.Time, which is deprecated
03:14:18 <quicksilver> time contains Data.Time.*
03:15:15 <tomh> mm
03:15:29 <ivanm> in which case, wouldn't that be split-base?
03:15:44 <tomh> so if i use any time stuff what should i put in cabal?
03:15:58 <tomh> just time and have users get it manually from hackage or?
03:16:19 <jedai> tomh: if you use Data.Time then time, if you use the old System.Time API then old-time
03:16:56 <ivanm> though have that probably for split-base, and just use time if split-base is false?
03:18:28 <quicksilver> I don't *think* time split out in the base split
03:18:33 <quicksilver> I think time was split out long agao
03:18:38 <ivanm> quicksilver: oh...
03:18:44 <quicksilver> so 'time' is always the correct dependency (for Data.Time)
03:18:47 <ivanm> wasn't 6.6 the base split?
03:18:58 <quicksilver> it just means, your 6.10 users will need to get a time package from somewhere.
03:19:02 <quicksilver> ivanm: I'm not sure; ICBW>
03:19:21 <ivanm> :o
03:19:24 <ivanm> you? wrong?
03:19:36 * ivanm looks out of the window for levitating equine
03:19:48 <jedai> quicksilver: but isn't time with the extra-libraries, no ?
03:19:54 <quicksilver> jedai: not in 6.10, no.
03:19:58 <quicksilver> erm, 6.10.2
03:20:14 <quicksilver> it was removed from the extralibs bundle on the author's request.
03:20:36 <jedai> Ok... Why ? Licensing problem ?
03:23:09 <ivanm> jedai: updating IIRC
03:23:24 <ivanm> he was updating it more often than extralibs were...
03:23:31 <ivanm> (or was it the other way round? :s )
03:23:49 <tomh> great, the time lib doesn't compile on windows :/
03:24:37 <jedai> I don't really see the problem ? cabal-install should be able to upgrade it as any other library, and time was a quite basic necessity
03:25:22 <ivanm> @go haskell time extralibs 6.10.2
03:25:24 <lambdabot> No Result Found.
03:25:28 <ivanm> @go time extralibs 6.10.2
03:25:29 <lambdabot> No Result Found.
03:25:32 <ivanm> grrr....
03:25:47 <jedai> @go time
03:25:49 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
03:25:54 <ivanm> jedai: there's sometimes issues with upgrading bundled libs
03:26:07 <ivanm> hmmm.... is the Haskell Platform going to replace extralibs?
03:26:14 <quicksilver> ivanm: yes.
03:26:21 <jedai> ivanm: We hope so :-)
03:27:05 <ivanm> so when dons and dcoutts get it done, the question will be moot
03:27:16 <ivanm> AFAICT, in terms of distro packaging extralibs is a PITA
03:28:23 <quicksilver> dons and dcoutts need help getting it done, though.
03:29:22 <ivanm> well, those of us on #gentoo-haskell will be doing gentoo packaging...
03:29:29 <ivanm> which caters that part of what their email asked for
03:50:49 <tomh> mm what command should i use in cabal to move resource files to the output dir of the exacs?
03:50:52 <tomh> *execs
03:57:55 <ivanm> tomh: sounds like you need a custom build script, rather than using Distribution.Simple
03:58:04 <ivanm> @seen dons
03:58:05 <lambdabot> dons is in #happs, #haskell-soc, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 13h 18m 47s ago.
04:02:51 <jedai> tomh: You know how to use the Paths_* facility offered by Cabal ?
04:10:31 <RayNbow> @where tying the knot
04:10:32 <lambdabot> I know nothing about tying.
04:10:57 <jedai> tomh: http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html in case you don't
04:11:18 <wli> RayNbow: ah, use an array whose elements are defined in terms of each other, e.g. ...
04:12:45 <RayNbow> wli: I was looking for a specific example I came across a while ago
04:12:50 <RayNbow> but I found it :)
04:12:51 <RayNbow> http://obfuscatedcode.wordpress.com/2008/02/16/functional-pearl-trees/
04:13:15 <RayNbow> setting the minimum value of the tree at the leaves in a single pass :)
04:16:51 <wli> > let a :: Array Int Integer = array (0, 100) $ (0, 0) : (1, 1) : [(n, let (q, r) = n `divMod` 2 in case r of { 0 -> (a ! q) * ((a ! q) + 2 * (a ! (q - 1))) ; 1 -> (a ! q) * (a ! q) + (a ! (q + 1)) * (a ! (q + 1)) }) | n <- [2 .. 100]] in elems a
04:16:52 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:20:09 <RayNbow> wli: that seems faster than what I tried yesterday :p
04:20:26 <RayNbow> > take 10 $ loeb $ const 0 : const 1 : [liftA2 (+) (!!n) (!!pred n) | n <- [1..]]  -- extremely inefficient way of computing the first 10 Fibonacci numbers :p
04:20:27 <lambdabot>   Not in scope: `loeb'
04:20:35 <wli> > let a :: Array Int Integer = array (0, 100) $ (0, 0) : (1, 1) : [(n, let (q, r) = n `divMod` 2 ; s = a ! q in case r of { 0 -> s * (s + 2 * (a ! (q - 1))) ; 1 -> let t = a ! (q + 1) in s * s + t * t ; _ -> error "impossible" }) | n <- [2 .. 100]] in elems a
04:20:37 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:20:40 <RayNbow> @let loeb x = fmap (\a -> a (loeb x)) x
04:20:41 <lambdabot>  Defined.
04:20:43 <RayNbow> > take 10 $ loeb $ const 0 : const 1 : [liftA2 (+) (!!n) (!!pred n) | n <- [1..]]  -- extremely inefficient way of computing the first 10 Fibonacci numbers :p
04:20:45 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
04:20:57 <RayNbow> (O(n) access is killing it)
04:22:03 <tomh> jedai: thanks
04:23:16 <wli> I was just using any old recurrence as an excuse to tie the knot.
04:23:38 <ivanm> is there a nice/easy way of having dual safe "Maybe a" / unsafe "a" functions?
04:23:54 <Twey> RayNbow: That's amazing
04:24:04 <ivanm> i.e. would something like this work: maybe (error "invalid") fromJust
04:24:19 <wli> > let a :: Array Int Integer = array (0, 100) $ (0, 0) : (1, 1) : [(n, a ! (n - 1) + a ! (n - 2)) | n <- [2 .. 100]] in elems a
04:24:21 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
04:24:32 <RayNbow> Twey: what is? :)
04:24:42 <wli> ivanm: Monad m and let default fail s = error s take over.
04:24:43 <Twey> RayNbow: The one-pass tree-minimum algorithm
04:24:47 <RayNbow> ah
04:24:59 <ivanm> wli: nah, I want two functions
04:25:00 * Twey is impressed and astonished
04:25:08 * Twey heaps love onto Haskell
04:25:11 * RayNbow was puzzled when he encountered it for the first time :p
04:25:26 * _boegel_ doesn't feel like figuring out how it works
04:25:38 <Twey> _boegel_: You should
04:25:41 <Twey> It's beautiful
04:25:45 <jedai> ivanm: Then you just write the Monad m function and export two function that specialize it in Maybe and Identity monad
04:26:11 <ivanm> jedai: hmmm...
04:26:12 <jedai> ivanm: Or you write the safe function
04:26:34 <RayNbow> the strangest thing is... I was puzzled, even though not long before I did something similar in a Java for a lab course :p
04:26:35 <jedai> ivanm: and the unsafe is fromMaybe (error "blabla") . safe
04:26:50 <ivanm> jedai: I did ask if that worked ;-)
04:26:58 <ivanm> <ivanm> i.e. would something like this work: maybe (error "invalid") fromJust
04:27:00 <jedai> ivanm: Yep, it works
04:27:05 <_boegel_> Twey: meh :)
04:27:10 <ivanm> OK, I wasn't sure about error's laziness, that's all
04:27:36 <jedai> ivanm: I use it often (except I use fromMaybe, maybe would need an useless id here)
04:28:06 <_boegel_> does the binary package of GHC rely on libedit.so.0 to be located in /usr/lib ? or can it be located somewhere else too?
04:28:06 <ivanm> @type fromMaybe
04:28:06 <jedai> ivanm: error isn't lazy but maybe/fromMaybe is
04:28:07 <lambdabot> forall a. a -> Maybe a -> a
04:28:26 <ivanm> jedai: *nod* as in it doesn't create/throw the error?
04:28:29 <ivanm> @src fromMaybe
04:28:30 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
04:28:37 <ivanm> @index fromMaybe
04:28:37 <lambdabot> Data.Maybe
04:28:45 <ivanm> OK, looks like I need another import...
04:29:09 <jedai> ivanm: as in the first argument of fromMaybe isn't reduced if the second one isn't Nothing
04:29:38 <ivanm> jedai: *nod*
04:30:04 * _boegel_ runs make install to see if GHC will actually work
04:36:23 <ivanm> How do most people here create .cabal files? by hand (copy/pasting from other projects)?
04:37:17 <blackh> Yes
04:38:47 <alx`> Hi guys ! I have a problem with an array list. I do an unsafeThaw of a Array Int [Int], and I cast it with :: ST s (STUArray s Int [Int]). It worked with simpler arrays (Array Int Int), but with Array Int [Int] GHC complains...could you help me ?
04:39:27 <Saizan_> you can't have an STUArray of [Int], only a STArray
04:39:42 <alpha-beta> I have never done programming before and also most no nothing about any programming is there good tutorial
04:39:54 <alpha-beta> maybe video
04:40:17 <alx`> Saizan_ : thanks ! problem solved :-)
04:40:21 <ivanm> alpha-beta: for haskell?
04:40:23 <ivanm> @where RWH
04:40:23 <lambdabot> is http://www.realworldhaskell.org/blog/
04:40:25 <ivanm> @where LYAH
04:40:26 <lambdabot> www.learnyouahaskell.com
04:40:27 <ivanm> @where YAHT
04:40:28 <Twey> alpha-beta: There's a free book: http://book.realworldhaskell.org/read/
04:40:28 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
04:40:31 <ivanm> @where wikibook
04:40:32 <lambdabot> http://en.wikibooks.org/wiki/Haskell
04:40:38 <ivanm> ^^ there's four
04:40:40 <ivanm> @where tutorial
04:40:41 <lambdabot> http://www.haskell.org/tutorial/
04:40:44 <Saizan_> RWH is not really intended for beginners
04:40:44 <Twey> Videos, videos...
04:40:46 <ivanm> ^^ make that five ;-)
04:40:50 <ivanm> Saizan_: hmmm.... true :s
04:40:53 <Twey> SPJ did a nice intro, I recall
04:40:57 <ivanm> more for beginning haskellers :s
04:41:06 <Twey> True
04:41:07 <samshel> hi, i am having some unexpected heap behaviour with lazy bytestring and hashing :-/
04:41:09 <ivanm> IIRC, byorgey_'s xmonad based one isn't bad...
04:41:12 <Twey> LYAH is definitely for beginners
04:41:36 <b_jonas> hi
04:41:55 * Twey waves.
04:41:57 <ivanm> Twey: well, it scared me when I first saw it...
04:42:01 <ivanm> :s
04:42:07 <samshel> can someone help me find out why this code load all the file in moemry even if i am using lazy bytestrings?? http://pastebin.com/m633d0852
04:43:51 <quicksilver> samshel: because it processes the entire file with integerDigest, and then passed 'm' to a recursive call of signWithKey
04:44:08 <Twey> samshel: Because you use it all
04:44:08 <alx`> Saizan_ : I would like to confirm that I understood my STUArray error. The STUArray prevents the use of boxing, and an [Int] is by definition boxed, so the two don't match ?
04:44:10 <quicksilver> samshel: so you're holding onto the head of the lazy bytestring = all the bytestring.
04:44:17 <quicksilver> so nothing can be gc'ed.
04:44:24 <quicksilver> alx`: Yes.
04:44:28 <Twey> ivanm: What, LYAH?
04:44:33 <Twey> The one with the elephants?
04:44:34 <quicksilver> alx`: STUArry just supports a fixed, small, list of types which can be unboxed.
04:44:39 <ivanm> Twey: yeah
04:44:40 <quicksilver> alx`: most types cannot be nboxed.
04:44:49 <Twey> Why did it scare you?
04:44:53 <Twey> Elephant-phobia?  :-P
04:45:10 <alx`> quicksilver : OK. Thank you for the answer !
04:45:33 <ivanm> Twey: I don't like weirdo tutorials like that
04:45:40 <ivanm> besides, the title doesn't make sense :s
04:45:54 <Twey> ivanm: I don't like it either, but it is informative for newbies I guess :)
04:46:10 <ivanm> ... maybe ...
04:46:13 * quicksilver thinks LYAH is made of awesome and win.
04:46:20 <nlogax> why do you hate animals?
04:46:22 <RowanD> LYAH isn't exactly for someone who knows nothing about programming.  But, it's close.
04:46:24 <nlogax> :(
04:46:34 <ivanm> I suppose BONUS wrote it to counteract the poignant guide to ruby, or whatever it's called?
04:46:43 <ivanm> nlogax: who?
04:46:47 <ivanm> me?
04:47:01 <alx`> About LYAH, as a newcomer to Haskell I really think it is a very good tutorial, it gave me the first bases in a fun way.
04:47:02 <Twey> ivanm: I think so, yes
04:47:19 <ivanm> "fun" way? *shudder*
04:47:33 <RowanD> You got to first base?
04:47:43 <ivanm> AFAICT, all introductory programming tutorials/texts come in three "flavours": maths-based, text-based and wtf-based
04:47:43 <alx`> RowanD : lol ;-)
04:47:43 <ivanm> ;-)
04:47:50 <Twey> RowanD: Well, from the description, I understood that alpha-beta doesn't exactly know nothing about programming... but it's close :)
04:47:55 <nlogax> ivanm: anyone who feels called out! :P
04:48:03 <Twey> So they should be a good fit.
04:48:13 <ivanm> most Haskell tutorials are maths-based, LYAH is the notable exception as it is in the last category
04:48:23 <nlogax> yes, LYAH reminded me of that ruby guide, but with less wtf
04:48:32 <b_jonas> which ruby guide?
04:48:42 <nlogax> b_jonas: http://poignantguide.net/ruby/
04:48:47 <Twey> b_jonas: Why's Poignant Guide to Ruby
04:48:56 <b_jonas> ivanm: category, lol
04:49:03 <Twey> Heh
04:49:30 <osfameron> is LYAH downloadable?
04:49:37 <ivanm> not AFAIK
04:49:40 <osfameron> LYAH is entirely unlike Poignant
04:49:44 <osfameron> it actually has some Haskell in it
04:49:46 <ivanm> but I only went to the site when it was first announced
04:49:48 <ivanm> osfameron: heh
04:49:56 <ivanm> osfameron: what, doesn't Poignant have any ruby in it? :s
04:50:00 <osfameron> it may do
04:50:06 <nlogax> but no haskell
04:50:07 <samshel> quicksilver: i can't understand the point.why should the message 'm' be processed all in memory? i thought that my calls in the check were tail calls
04:50:08 <nlogax> ;)
04:50:08 <osfameron> after 20 or so pages of self-indulgent wank about foxes
04:50:15 <wjt> CHUNKY BACON
04:50:15 <osfameron> I gave up after 10 pages
04:50:16 <ivanm> osfameron: heh
04:50:20 <osfameron> I tried. I really tried.
04:50:36 <wjt> osfameron: oh, i don't know. the first chapter contained *some* ruby. then there were about a hundred pages of crap about walking through castles
04:50:47 <wjt> that is to say: it got wores
04:50:51 <osfameron> ah
04:51:20 <samshel> quicksilver: ok, i got it
04:52:16 <quicksilver> samshel: lazy bytestrings are like lists - hold onto the head and you're holding onto everything.
04:52:33 <quicksilver> samshel: if you want to process a file multiple times, as a strem, then pass the file name (or handle) and re-read it each time.
04:54:23 <zachk> is there a null output IO () action to force computation but not to print anything?
04:55:01 <samshel> quicksilver: ok, thx for help
04:55:43 <quicksilver> zachk: force computation of what?
04:55:46 <bremner> zachk: return ()  ?
04:57:28 <Twey> Put seq everywhere!!!1
04:57:38 <blackh> zachk: return () is your all-purpose trusty "do nothing" action in a monad
04:57:42 <blackdog_> zachk: Control.Exception.evaluate
04:59:17 <zachk> so return(f a) will force evaluation of f on a? and then i can just drop it with >>?\
04:59:55 <blackdog_> zachk: no, it won't.
05:00:06 <daf> return is defined in terms of the monad you're using
05:00:11 <daf> there's no guarantee that it's strict
05:01:29 <quicksilver> nobody should ever use evaluate
05:01:40 <RowanD> Computation of things will be forced when they are needed.  For IO, the things that build up the sequence of effects are requested in order. But, what's returned are still only requested when something needs them.
05:01:46 <quicksilver> [*] unless you can give a detailed explanation of why. So I might just permit JaffaCake to use it.
05:01:53 <quicksilver> zachk: you force evaluation with seq
05:01:59 <quicksilver> that is no different inside or outside of any monad.
05:02:13 <quicksilver> let y = f a in y `seq` return y
05:02:21 <blackdog> quicksilver: what's wrong with evaluate?
05:02:26 <quicksilver> or "return $! f a" for short.
05:02:32 <quicksilver> blackdog: it has almost no purpose.
05:02:40 <quicksilver> instead of one primitive in the language which can easily be explained (seq)
05:02:52 <quicksilver> we have another one, which is not definable in terms of seq, and hard to explain.
05:03:08 <quicksilver> I would rather people just learn how to use seq
05:03:16 <_boegel_> wow, I'm still using GHC 6.4 on my main system
05:03:17 <_boegel_> scary
05:03:18 <quicksilver> which is equally applicable in all situations, not just IO.
05:03:52 <blackdog> quicksilver: ok. so it's inelegant, rather than actually broken
05:03:58 <RowanD> Yeah, seq is the right thing.
05:04:31 <quicksilver> blackdog: it's pointless.
05:04:41 <quicksilver> [*] in 99% of cases.
05:04:54 <quicksilver> If you're smart enough to understand what that 1% is and know when to use evaluate, then be my guest.
05:05:04 <quicksilver> I'd be even more grateful if you'd teach me how to recognise that 1% ;)
05:05:11 <RowanD> Although I prefer to have lazy vs non-lazy exposed in the types.  Unlikely to happen in Haskell though.
05:06:22 <blackdog> quicksilver: (trying not to make the obvious pl joke) yeah, fair enough. and if you want more abstract control of evaluation there's a strategies library, right?
05:06:25 <blackdog> still haven't got the hang of rnf
05:07:18 <latitude> hi
05:07:20 <quicksilver> right.
05:07:25 <latitude> pairFst Pair a b = a
05:07:27 <quicksilver> strategies is all 'seq-style'
05:07:46 <quicksilver> it's all built in seq, as pure composabl stuff.
05:07:46 <latitude> doesn't it enought? why to involve braces?
05:08:00 <quicksilver> latitude: that defines a function with 3 parameters
05:08:07 <quicksilver> latitude: the first is 'Pair' the second is 'a' the third is 'b'
05:08:08 <latitude> but Pair is type
05:08:23 <latitude> that is said it is capitalized
05:08:30 <latitude> thus it's a Type
05:08:35 <EvilRanter> or a constructor
05:08:37 <quicksilver> actually it's a Constructor
05:08:38 <quicksilver> not a Type.
05:08:39 <EvilRanter> > True
05:08:41 <lambdabot>   True
05:08:42 <blackh> latitude: pairFst (Pair a b) = a
05:08:47 <EvilRanter> ^ there's another constructor
05:08:50 <EvilRanter> ?src Bool
05:08:51 <lambdabot> data Bool = False | True deriving (Eq, Ord)
05:08:57 <quicksilver> blackh: he knows that, he was asking why.
05:09:19 <quicksilver> latitude: because we don't want the parser to be sensitive to whether something is a constructor or another kind of function.
05:09:19 <latitude> blackh: yep that's what i meen
05:09:27 <quicksilver> latitude: and you can partially apply constructors as well.
05:09:47 <insane> what do you think what would be the best way to communicate with haskell society during my google summer of code?
05:09:55 * blackh says 'doh'
05:09:59 <insane> what is the best way to achieve this?
05:10:44 <insane> i mean both presenting my results and search for feedback?
05:10:45 <blackdog> insane: here? haskell-cafe?
05:10:46 <insane> a blog maybe?
05:11:04 <insane> yeah but it should be available every time
05:11:11 <blackdog> i mean, you could join the cabal, but you have to kill a man first
05:11:14 <Saizan_> insane: a weekly updated blog has been a popular choice
05:11:26 <latitude> oh indeed
05:11:39 <latitude> Pair may be function and maybe a type
05:11:58 <RowanD> Yeah, I agree.  What's the project, insane?
05:12:07 <insane> cabal dependency resolver
05:12:17 <RowanD> Yeah, cool.
05:12:21 <insane> and yours?
05:12:29 <insane> or you're not participating?
05:12:38 <RowanD> Me?  No, I'm too old for that.
05:12:40 <samshel> quicksilver: mm it's not only that (regarding the heap mess). i have moved the hashing in another action which does the call to the function passing only the hash in numeric form, but nothing, memory still full
05:12:42 <insane> ;] i see
05:12:52 <RowanD> I did three summers back in the mid-90s.  :)
05:13:00 <insane> ;]
05:13:15 <RowanD> INRIA, AARHUS, DEC/SRC.
05:13:28 <latitude> i can think about it like it *is* unambigous but haskell just requires to be more expressive, right?
05:13:35 <RowanD> That kinda dates me.
05:13:40 <latitude> can i?
05:14:28 <EvilRanter> latitude, in an expression, "foo Bar baz" would mean "(foo Bar) baz". in the interests of consistency, it also always means that in patterns
05:14:59 <TThijs> hai could someone help me. I want to split a string when "/n" is in te string, how do i do this?
05:15:19 <ejt> TThijs: lines
05:15:36 <EvilRanter> > lines "\nfoo\nbar\n\nbaz\n"
05:15:37 <TThijs> lines?
05:15:38 <lambdabot>   ["","foo","bar","","baz"]
05:16:13 <TThijs> Thank you very much :D
05:20:08 <_boegel_> TThijs: you might want to look into hoogle
05:20:14 <_boegel_> @hoogle String -> [String]
05:20:15 <lambdabot> Prelude lines :: String -> [String]
05:20:15 <lambdabot> Prelude words :: String -> [String]
05:20:15 <lambdabot> Data.List lines :: String -> [String]
05:20:44 <_boegel_> TThijs: if you can imagine the type of the function you need, it helps _a lot_
05:21:04 <TThijs> yeah i noticed but I didn't saw the "string at newline characters"
05:21:59 <RowanD> Knowing the types, you can usually write about half the code without thinking too much.
05:22:21 <latitude> i seem to have trouble with ex. 4.5 in yaht
05:23:05 <_boegel_> TThijs: well, you did realize the type of the function needed to be something like "String -> [String]" right?
05:23:25 <_boegel_> TThijs: that would have given you a pointer to the 'lines' function, which pretty much says what it does ;-)
05:23:52 <blackh> latitude: Quadruple? What's the trouble?
05:25:04 <latitude> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2030#a2030
05:25:07 <latitude> here is
05:25:11 <b_jonas> _boegel_: he might have searched a generalized split function in which case he woulnd't have found lines by hoogle
05:25:27 <blackh> latitude: You need some ( )'s
05:25:28 <latitude> what is unclear is that it is said that a and b a type parameters
05:25:48 <latitude> yeah i know
05:26:16 <latitude> added
05:26:18 <blackh> latitude: The left-hand side of the 'data' declaration has the list of types you are using, and you only need two types there
05:26:46 <blackh> latitude: The right-hand side says what fields the data type contains, and you need four of those
05:26:53 <latitude> so that is not a signature like list of members, just a list of types used?
05:27:29 <doserj> I guess, for the proper Quadruple, he needs 4 parameters both on the left and the right
05:27:35 <blackh> latitude: Yes - since you're only using two different data types, the type (on the left) has to have two arguments.
05:27:45 <blackh> doserj: The exercise asks for two types
05:28:09 <MiniCow> So, Quad a b = Quad a a b b, Right? (I'm still learning too)
05:28:23 <blackh> MiniCow: Right
05:28:25 <latitude> updated the paste
05:28:39 <latitude> then we come to functions
05:28:39 <doserj> oh
05:29:24 <blackh> latitude: Looks good
05:29:26 <latitude> those a b c d are not types now, right, they are some values?
05:29:43 <blackh> latitude: That's right
05:30:34 <RowanD> You can tell by the context whether there should be a type there or an expression.
05:31:38 <MiniCow> latitude: Type Declarations and Function declarations are separate things. They have to agree, but they're distinct.
05:32:06 <latitude> that's what i'm thinking
05:32:10 <MiniCow> Hence they have separate name spaces
05:32:15 <RowanD> Well - types come first.  Then the function declarations have to agree.
05:32:18 <latitude> so when we declare data, nothing happens
05:32:20 <blackh> latitude, MiniCow: Here's another example ...  data ListWithLength a = ListWithLength Int a
05:32:34 <latitude> the type borns only when we define how to work with it ?
05:32:47 <blackh> This is how you might represent a list where the length is kept so you can evaluate it quickly (I have done this before)
05:33:02 <latitude> is born
05:33:04 <blackh> 'Int' isn't needed on the left hand side because it's not a type variable.
05:33:40 <latitude> when i say data Quadruple a a b b = Quadruple a b, i just declare that there are two types and four members
05:34:01 <blackh> latitude: Other way around, but otherwise, yes
05:34:04 <MiniCow> You've got it reversed again
05:34:39 <RowanD> When you declare data types, nothing observable happens, but you've changed the world to allow more functions to be defined.
05:34:51 <bremner> latitude: feel free to use different names for the Type constructor and the Value constructor if it helps. RWH ch. 3 is quite clear on this
05:34:54 <bavardage> "Change the world. Learn haskell"
05:35:08 <bavardage> *"Change the world. Code Haskell"
05:35:20 <latitude> what's rwh?
05:35:21 <bavardage> could be an ad campaign tbh
05:35:27 <blackh> bavardage: Make a modified copy of the world. Learn Haskell.
05:35:28 <EvilRanter> ?where rwh
05:35:29 <lambdabot> is http://www.realworldhaskell.org/blog/
05:35:36 <Twey> main = putStrLn "World successfully changed."
05:35:37 <MiniCow> Another way would be "data Quad a b = QuadConstructor a a b b"
05:35:38 <RowanD> I tried to change the world, but I could get my head around the IO monad, so all my programs were pure.
05:35:39 <latitude> shiny
05:35:39 <bavardage> blackh: doesn't have the same ring to it though...
05:35:42 <bavardage> haha
05:35:55 <bavardage> you can't chance the world whilst staying pure
05:36:02 <RowanD> Haha.
05:36:08 <RowanD> I'm teaching F# currently.
05:36:21 <RowanD> It has monads - in a way.
05:36:31 <Twey> RowanD: In a way?
05:36:36 <bavardage> teaching?
05:36:36 <Twey> I'm learning C# currently.
05:36:42 <bavardage> this at school or uni level?
05:36:43 <Twey> It has monads — in a way.
05:37:11 * bavardage doesn't get any programming offered at school :(
05:37:18 <Twey> bavardage: None at all?
05:37:22 <lilac> I'm learning the piano currently.
05:37:23 <Twey> You don't even have a CS class?
05:37:26 <bavardage> noop
05:37:26 <lilac> It has monads - in a way
05:37:28 <Twey> lilac: Does it have monads?
05:37:30 <Twey> Hahahaha
05:37:39 <bavardage> Twey: there is 'IT' but that's just learning to use ms office
05:37:46 <jedai> Twey: But you see F# has monad in a way that is way more than the way C# has monads
05:37:46 <RowanD> It has monads, for sure.
05:37:50 <bavardage> CS isn't very common over here pre-unversity
05:37:55 <RowanD> I'm teaching at a university.
05:37:56 <bavardage> *university
05:38:03 <Twey> jedai: How does it have monads, then?
05:38:09 <bremner> RowanD: programming languages?
05:38:10 <RowanD> F# has monads.
05:38:16 <RowanD> Haha.
05:38:19 <blackh> Teach us F#!
05:38:22 <bavardage> yeah!
05:38:24 <bavardage> actually no
05:38:25 <Twey> C# has LINQ, which I'm told is basically language support for monads.
05:38:26 <bavardage> I'll pass
05:38:33 <bavardage> (don't think i can run F# here)
05:38:37 <RowanD> This is not the place for teaching F#
05:38:38 <bavardage> isn't it a microsoft thingy?
05:38:43 <Twey> bavardage: It compiles with Mono
05:38:44 <jedai> Twey: F# really has monads, I assume you were speaking about Linq when you spoke about monads in C#
05:38:44 <bavardage> hence won't have linux support
05:38:46 <bavardage> oh hmm
05:39:01 <b_jonas> Mono… id?
05:39:02 <Twey> (it takes some fiddling, but you can do it)
05:39:05 <jedai> Twey: It has some special sugar for monads
05:39:07 <RowanD> It has good support outside MS.
05:39:14 <Twey> jedai: But so does C# :-P
05:39:20 <RowanD> True.
05:39:23 <RowanD> LINQ.
05:39:31 <RowanD> So does VB and Haskell.
05:39:41 <RowanD> Haskell had it first though.
05:39:49 <b_jonas> VB?
05:39:53 <Twey> Ayup
05:39:57 <RowanD> Visual Basic.
05:40:00 <Twey> VB doesn't, I think
05:40:03 <RowanD> Haha.
05:40:03 <Twey> Maybe VB.NET
05:40:06 <RowanD> It does now.
05:40:10 <jedai> Twey: Except that LINQ really isn't honest about what it is a sugar for, F# sugar is much cleaner
05:40:15 <Twey> Separate languages
05:40:18 <RowanD> Okay. VB.NET.
05:40:19 <Twey> jedai: True
05:40:20 <jedai> Twey: Whatever !! ^^
05:40:38 <RowanD> Right, in F# is is clearly a monad.
05:40:40 <jedai> Anyway there are monads everywhere nowadays :)
05:40:55 <RowanD> Just that it doesn't isolate side effects.
05:41:02 <ivanm> :o I got an "the 'impossible' happened" bug! :o
05:41:09 <RowanD> Just like Haskell doesn't isolate the non-termination side-effect.
05:41:09 <bremner> RowanD: in what course are you teaching F#?
05:41:15 <b_jonas> jedai: sure, as long as the language has first-class functions, someone will build a library for them
05:41:23 <RowanD> Oh - "Programming Paradigms".
05:41:28 <Twey> RowanD: I'm sure it will, when we can figure it out :-P
05:41:41 * Twey ponders.
05:41:49 <RowanD> Isolate non-termination?
05:41:49 <bremner> RowanD: what do you use as a textbook, if any?
05:41:51 <Twey> Wait a minute — can that even be considered a side-effect?
05:42:00 <RowanD> That was the original form Moggi put monads in.
05:42:08 <RowanD> Haskell made it non-pure.  :)
05:42:11 <Twey> It's still pure.  Computation time isn't considered a side effect.
05:42:21 <RowanD> Even when infinite?
05:42:30 <Twey> Of course — why would that make a difference?
05:42:54 <RowanD> You must have a convenient amount of time to wait for things then, cause that would have an effect on me.
05:43:10 * Twey rolls his eyes and shakes his head.
05:43:52 <Twey> BRB, need toast.
05:44:01 <quicksilver> Twey: partiality is sometimes considered an effect.
05:44:09 <RowanD> Sometimes?
05:44:13 <RowanD> It is an effect.
05:44:46 <quicksilver> RowanD: I mean "when one discusses effects in the sense of Moggi, partiality is one of the effects one sometimes s
05:44:47 <RowanD> The definition of an effect is anything that affects the external view of a program.
05:44:53 <quicksilver> discusses".
05:45:09 <RowanD> Partiality was the the first effect to be captured with a monad.
05:45:47 <RowanD> In domain theory.
05:46:11 <RowanD> Then, Moggi generalized this to all effects.
05:46:23 <RowanD> Then Haskell removed partiality.
05:46:46 <RowanD> Which is not necessarily bad.
05:46:51 <quicksilver> it didn't "remove" it.
05:46:58 <quicksilver> Maybe is the partiality monad.
05:46:59 <RowanD> It hid it.
05:47:12 <quicksilver> it's jsut that haskell also has an implicit partiality which can't be observed directly
05:47:15 <quicksilver> halting problem etc.
05:47:18 <RowanD> In the same way ML hides all effects.
05:47:22 <RowanD> Not in the type system.
05:47:39 <quicksilver> as I say, Maybe is the partiality monad.
05:47:42 <quicksilver> and it is in the type system.
05:47:51 <RowanD> Maybe?
05:47:54 <quicksilver> yes, Maybe.
05:47:56 <RowanD> Not in Haskell.
05:48:00 <quicksilver> yes, in Haskell.
05:48:18 <quicksilver> Maybe is an implemenation of a partial functions, as a Monad, in Haskell.
05:48:19 <RowanD> So, I can't write a non-terminating function without a Maybe type?
05:48:26 <RowanD> Nono.
05:48:34 <RowanD> I mean non-terminating.
05:48:43 <quicksilver> ok, but that's not what you said.
05:48:45 <RowanD> Not terminating and returning nothing.
05:48:49 <RowanD> Haha.
05:48:50 <RowanD> Fine.
05:48:50 <quicksilver> yes, I know.
05:49:00 <quicksilver> There is a totally explicit partiality monad in haskell - Maybe.
05:49:06 <RowanD> Ok, I mean the effect of non-termination.
05:49:17 <RowanD> Right, you are correct.
05:49:25 <RowanD> In the Haskell context, that is right.
05:49:28 <quicksilver> There is also the implicit one caused by non-termination, which is inevitable if you are not prepared to restrict your langauge to total programming.
05:49:40 <RowanD> But, non-termination is another effect.
05:49:40 <quicksilver> and that's not visible in the type system although you could of course argue it's always there.
05:49:56 <RowanD> Exceptions are another.
05:50:27 <RowanD> Unmatched pattern exceptions are also not captured by the types.
05:50:27 <quicksilver> there is a conservative approximation to the non-termination monad visible in GHC's (internal) type system.
05:50:42 <quicksilver> unboxed types cannot fail to terminate.
05:50:49 <RowanD> That's not the same as type.
05:50:59 <quicksilver> it is a type system.
05:51:01 <RowanD> Cause, types are things programmers can use.
05:51:03 <int-e> quicksilver: but they can.
05:51:08 <quicksilver> int-e: can they?
05:51:19 <vixey> RowanD: exceptions being an effect is interesting wrt. Haskell
05:51:31 <RowanD> Yeah?
05:51:37 <vixey> RowanD: because throwing (error) is pure.. but catching is manifest as an IO effectt
05:52:09 <Twey> 13:45:30 < RowanD> The definition of an effect is anything  that affects the external view of a program.
05:52:13 <int-e> quicksilver: define  f :: Int# -> Int#; f _ = f 0#. then f 0# :: Int# is an unboxed value.
05:52:15 <RowanD> Well, to me throwing is not pure.  But, can understand how it works out.
05:52:17 <Twey> RowanD: Then every function is impure
05:52:29 <Twey> Because they all have different termination times
05:52:49 <Twey> (and that's not necessarily referentially transparent, either)
05:53:03 <RowanD> Right.  Depends on your point of view.
05:53:12 <Twey> They also have other side effects, like using variable amounts of memory, heating up the processor, &c.
05:53:29 <RowanD> I guess I believe we need hierchachies of monads to reflect that.
05:53:42 <quicksilver> int-e: interesting. So unboxed types force eager evaluation but not termination?
05:53:42 <Twey> I believe we shouldn't even try to reflect it
05:53:52 <RowanD> Without being too heavyweight and in the way.  I don't know how to do that.
05:53:57 <int-e> quicksilver: yes.
05:54:00 <Twey> The code itself is pure.  These 'side effects' are evaluation details.
05:54:15 <int-e> quicksilver: iow, nontermination is the only kind of bottom that is left.
05:54:24 <vixey> RowanD: what monad heierarchy/
05:54:25 <vixey> ?
05:54:32 <RowanD> Twey: Indeed - and many people will tell you the same about ML code.
05:54:32 <Twey> That is, they belong to the equipment used to evaluate the code, not to the code itself.
05:54:44 <int-e> quicksilver: which isn't surprising, because that's the only one that doesn't have to be represented as a value. (I subsume exceptions under the notion for simplicity)
05:54:51 <quicksilver> int-e: *nod*
05:55:46 <jeltsch> Hi, does anyone know what happend to the community server? It seems not very responsive at the moment. :-(
05:55:47 <lilac> the semantics of Maybe aren't the semantics of a partiality monad, since you can pattern-match on Nothing...
05:57:58 <quicksilver> lilac: being able to pattern match on Nothing isn't part of the semantics of Maybe.
05:57:59 <lilac> the more i think about it, the more i think that haskell strips away 'implicit' monads to exactly the right level
05:58:10 <quicksilver> lilac: that's cheating - accessing the implemntation.
05:58:21 <RowanD> Haskell makes non-termination a subtle issue.  Laziness and pattern matching don't work well together.
05:58:22 <quicksilver> lilac: if you just use the methods from Monad (and MonadPlus, if you like) you're fine.
05:58:35 <lilac> quicksilver: if you just use the methods from Monad, then you can't distinguish monads
05:58:48 <ErhardtMundt> hello
05:58:50 <quicksilver> I didn't say that very well, did I ?
05:58:54 * quicksilver tries to reformulate.
05:59:06 <RowanD> I don't understand why non-termination is allowed as an effect when others aren't except via the IO monad.
05:59:26 <RowanD> I'd like there to be a monad that included non-termination.
05:59:28 <lilac> quicksilver: i consider something like the 'maybe' function as an important part of the semantic model of Maybe
05:59:29 <quicksilver> RowanD: because the only way to prevent that is to go to a provably total language.
05:59:36 <vixey> RowanD: because it would be so horribly awkward nobody would use it
05:59:45 <int-e> RowanD: and you lose Turing completeness on the way
05:59:45 <quicksilver> RowanD: which is an interesting path (q.v. epigram, agda)
05:59:52 <quicksilver> RowanD: but difficult.
05:59:57 <vixey> turing completeness was never really a good thing
05:59:58 <lilac> RowanD: non-termination as a monad requires proofs in your program.
06:00:17 <vixey> proofs ?
06:00:18 <lilac> int-e: no, if you have partiality as a monad and your top-level is allowed to be partial you can keep turing-completeness
06:00:18 <RowanD> Yeah - but the semantics of Haskell is really awkward to define for things like pattern matching.
06:00:23 <quicksilver> lilac: I'll restate myself. There is nothing wrong with being able to observe partiality.
06:00:29 <vixey> you can just program with folds and unfolds, everything terminates
06:00:42 <blackh> ErhardtMundt: Greetings!
06:00:45 <quicksilver> lilac: you are confusing non-termination - which is not observable in practice - with partiality - which is a useful mathematicl concept.
06:00:54 <ErhardtMundt> blackh: :)
06:00:56 <RowanD> Why is partiality different to printing to the screen?
06:01:00 <quicksilver> lilac: Maybe works perfectly as a monad for the notion of working with partial functions.
06:01:08 <vixey> RowanD: I already told you ....
06:01:29 <lilac> quicksilver: what you're saying is that mathematically / semantically they are the same, but operationally they can't be?
06:01:32 <b_jonas> is it awkward because then in practical programs you'd need to add arbitary limits to loops so instead of a program that can loop if the a loop is infinite long you have one that exits after 2**64 iterations but claims that it's terminating?
06:01:37 <RowanD> Because printing to the screen is dangerous, and non-termination isn't?
06:01:47 <lilac> quicksilver: presumably because if we use Maybe to model non-termination then we can't compute the result of the 'maybe' function
06:01:49 <vixey> RowanD: that's not what I said
06:01:55 <lilac> quicksilver: and indeed it's not even well-defined
06:01:57 <RowanD> I know.
06:02:01 <quicksilver> lilac: I'm saying, I'm not talking about non-termination.
06:02:16 <b_jonas> dangerous as in it can damage hardware?
06:02:22 <quicksilver> lilac: I'm talking, pure and simple, about partiality, as in "f :: a -> b may not be defined on every element of a"
06:02:34 <RowanD> At a mathematical level, they are the same kind of thing.
06:02:36 <lilac> quicksilver: right, sorry, i was seeing one word and imagining another :)
06:02:43 <quicksilver> lilac: that is what a partial function is; it can be modelled as a monad and that's exactly what maybe is ;)
06:02:44 <int-e> RowanD: forbidding non-termination isn't going to help you much - for practical considerations, a function that terminates in 1000 years isn't really better than one that doesn't terminate at all.
06:02:56 <quicksilver> lilac: it is *also* true that non-termination is a kind of partiality ...
06:03:07 <quicksilver> lilac: but as you correctly point out, it's not observablein general.
06:03:09 <lilac> quicksilver: right, but it's a specific kind :)
06:03:30 <lilac> quicksilver: at this point i understand what you mean and i think we're just agreeing :)
06:03:53 <RowanD> vixey: okay - what exactly did you say?
06:04:08 <vixey> RowanD: because it would be so horribly awkward nobody would use it
06:04:09 <lilac> quicksilver: and my initial statement was wrong; i meant 'non-termination' where i said 'partiality'
06:04:41 <b_jonas> ah, it turns out that function I was searching does exist, only not in the package I was looking in:
06:05:09 <b_jonas> Control.Concurrent.threadWaitRead and Control.Concurrent.threadWaitWrite resp
06:05:21 <b_jonas> block until a file descriptor becomes readable or writeable resp
06:05:27 <lilac> RowanD: IO as a monad isn't about 'danger', it's about being able to reason about your program
06:05:33 <b_jonas> so that's why these aren't in System.Posix
06:05:48 <b_jonas> great
06:06:14 <RowanD> Vixey: a lot of people of the same trouble with large Haskell programs when they need to introduce effects in a certain place they hadn't previously inticipated.  It's the same kind of problem.
06:06:30 <RowanD> ("have" missing there)
06:06:35 <vixey> don't know what you mean really
06:06:41 <RowanD> No?
06:06:48 <lilac> RowanD: termination is a global property, lack of side-effects is a local one
06:06:51 <vixey> like you hacked out this huge program and realize you need a gensym counter half way through?
06:07:04 <RowanD> Okay, many of my students have that problem when they try to right large programs in Haskell.
06:07:05 <vixey> would probably put that down to bad (or lack of..) design
06:07:18 <RowanD> (um, write)
06:08:04 <RowanD> vixey: that is totally naive - to think that every component of a large system can be designed once, and never have the designe changed.
06:08:17 <vixey> I agree that's naive :p
06:08:22 <vixey> that's not even close to what I said though
06:08:48 <RowanD> It's awkward to deal with those issues in Haskell - will you agree with that?
06:08:57 <vixey> never been a problem for me actually
06:09:09 <blackdog> hey, what's the consensus on John Harrop? am wondering whether it's worth debunking his latest attack on haskell... (for the curious, he's benchmarking the ocaml hashtable against the haskell one, which is about as close to deprecated as you can get...)
06:09:09 <int-e> so you add the gensym counter where you need it and then follow the type checker.
06:09:11 <vixey> I don't write programs bigger than a couple thousand lines in Haskell though
06:09:28 <int-e> and when you're done with that, you have some assurance that you actually changes all places that mattered.
06:09:37 <int-e> *changed
06:09:40 <lilac> RowanD: my (limited) experience is that, if you have a monad threaded through your program already, it's usually pretty easy to add some more stuff to that monad.
06:09:44 <blackh> I have not encountered a problem like that... I generally just add what I want, then pass it aaaaall the way down, then aaaall the way back up again, then re-factor.
06:09:48 <b_jonas> vixey: could it be because you're writing programs from the bottom up like smalltalk/forth programmers, not from the top down?
06:10:04 <jedai> blackdog: As long as one person comments on that it's enough, getting dragged into a debate with him is not worth it
06:10:07 <vixey> b_jonas: honestly I have no idea which way up -is-
06:10:24 <lilac> RowanD: and threading a monad through existing pure code is usually fairly straightforward.
06:10:49 <blackh> blackdog: OMG I wrote a hash table in Haskell!
06:10:56 <blackdog> blackh: yeah?
06:11:03 <b_jonas> vixey: well, by bottom up I mean you write functions that call only functions you've already written before; by top down I mean write functions that mostly call functions you haven't yet written
06:11:14 * vixey gets this horrible idea of a type error directed refactor..er .. :/
06:11:14 <blackdog> i wrapped CMPH, which is pretty damn fast, but it's sorta cheating - you can't add new elements :)
06:11:17 <blackh> blackdog: For the programming language shootout (k-nucleotide).  It's ugly!
06:11:52 <chessguy_work> > let g 0 = 0; g n = n - (g (g (n-1))) in map g [1..]
06:12:02 <quicksilver> b_jonas: out of interest why do you need threadWaitRead rather that just using an input command (like hGet) which waits implicitly?
06:12:06 <melisa> hi all
06:12:07 <chessguy_work> @bot
06:12:08 <lunabot>  :)
06:12:08 <lambdabot>   thread killed
06:12:09 <lambdabot> :)
06:12:14 <vixey> hi melisa
06:12:16 <blackh> blackdog: Unfortunately it isn't as fast as the O'Caml entry
06:12:22 <chessguy_work> > let g 0 = 0; g n = n - (g (g (n-1))) in map g [1..5]
06:12:25 <lambdabot>   [1,1,2,3,3]
06:12:32 <jedai> hello
06:12:39 <melisa> hi
06:12:51 <b_jonas> quicksilver: weren't you here last time when I asked about this? I would like to wrap the C library libcurl, which downloads stuff,
06:12:58 <melisa> how are u
06:13:26 <b_jonas> and it has a callback interface where when it wants to block it tells me what filehandles and time to select on, and then your c program can do other things meanwhile, or block on that and other stuff if it has nothing to do.
06:13:44 <b_jonas> so I'd need a thread-aware select function in haskell
06:13:47 <quicksilver> b_jonas: possibly, yes; I'm quite senile and don't tend to remember what happened this morning let alone last week.
06:14:07 <mmorrow> b_jonas: just ffi-import select
06:14:09 <quicksilver> b_jonas: yes, that rings a bell :)
06:14:09 <b_jonas> someone suggested that I can use -threaded ghc and call select in a native thread
06:14:23 <Saizan_> b_jonas: did you look at the curl bindings on hackage? (just wondering if they tackled the same problem)
06:14:36 <mmorrow> b_jonas: (you would need to use Fd's in that case)
06:14:44 <b_jonas> Saizan_: there is one, and I might use it, but it doesn't support this background interface, only the blocking one it seems
06:15:26 <b_jonas> why I kept searching is that as ghc concurrency implements blocking read even without native threads,
06:15:45 <quicksilver> it uses select  internally on posix.
06:15:47 <mmorrow> @hoogle hGetBufNonblocking
06:15:48 <lambdabot> System.IO hGetBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
06:15:49 <b_jonas> why I kept searching is that as ghc concurrency implements blocking read even without native threads,
06:15:59 <quicksilver> and some godawful api on win32.
06:16:06 <b_jonas> it surely has to support these operations, and so it's likely that they're exporting it as well.
06:16:13 <mmorrow> hGet_Nonblocking
06:16:30 <mmorrow> where _ is ByteString/String/Buf
06:16:34 <b_jonas> mmorrow: look,
06:16:43 <b_jonas> I don't want a non-blocking read, I want quite the opposite
06:16:47 <mmorrow> ah
06:17:03 <b_jonas> I want to block a thread until a filedes becomes readable, and then resume without reading from it
06:17:15 <mmorrow> @hoogle threadWaitRead
06:17:16 <lambdabot> Control.Concurrent threadWaitRead :: Fd -> IO ()
06:17:16 <b_jonas> because the function I'll then call from the curl library will do the reading or writing
06:17:18 <mmorrow> @hoogle threadWaitWrite
06:17:19 <lambdabot> Control.Concurrent threadWaitWrite :: Fd -> IO ()
06:17:31 <b_jonas> mmorrow: exactly, that's what I just said I found
06:17:36 <RowanD> lilac: ML programs always have a monad implicitly threaded through them.  So do Haskell programs - even pure ones.
06:17:38 <blackh> b_jonas: HsOpenSSL does this
06:17:38 <mmorrow> oh :)
06:17:49 <b_jonas> but thanks anyway
06:18:16 <mmorrow> b_jonas: wait, i'm confused. so is that what you need or not?
06:18:22 <Saizan_> RowanD: there are total languages how there, mostly dependently typed, but they are not "pratical" yet
06:18:24 <mmorrow> if not, just ffi-import select
06:18:24 <lilac> RowanD: sure. almost all languages do that. i'm talking about an explicit monad
06:18:27 <b_jonas> mmorrow: yes, that's what I need
06:18:32 <mmorrow> ah, cool
06:18:35 <vixey> RowanD: "ML programs always have a monad implicitly threaded through them" -- is just /one/ way to view it
06:18:42 <b_jonas> mmorrow: only I was searching for it in System.Posix last time and couldn't find it
06:18:48 <blackh> b_jonas: In fact, now that you mention it, I think HsOpenSSL would be worth looking at because it is quite similar to what you describe.
06:18:49 <mmorrow> ah
06:18:54 <RowanD> lilac: I'm talking about languages where you can move between these views.
06:19:08 <lilac> RowanD: in any case, one wants to minimize the semantics of said monad to enable easier reasoning
06:19:11 <b_jonas> and asked the irc channel but must have explained my problem wrong because no-one pointed me to these functions.
06:19:19 <b_jonas> blackh: I might be looking at it
06:19:21 <lilac> RowanD: views of what?
06:19:24 <mmorrow> b_jonas: (threadWait* are hooked to ghc's iomanager, which itself uses select)
06:19:33 <int-e> > let g g 0 = 0; g g n = n - (g (g (n-1))); memo f = fix (\f' -> (map (f f') [0..] !!)) in map (memo g) [0..]
06:19:36 <lambdabot>   [0,1,1,2,3,3,4,4,5,6,6,7,8,8,9,9,10,11,11,12,12,13,14,14,15,16,16,17,17,18,...
06:19:40 <RowanD> Why choose just one monad to be implicit like Haskell does?
06:19:50 <RowanD> Why not have it be programmer defined?
06:20:04 <quicksilver> b_jonas: I didn't know about them until just now :)
06:20:04 <RowanD> And different for different parts of their code?
06:20:05 <lilac> haskell chooses the minimum set of implicit monads which do not require the user to give proofs
06:20:06 <vixey> RowanD: Already explained that 2 times...
06:20:10 <quicksilver> b_jonas: so that's why I didn't point them to you.
06:20:16 <lilac> RowanD: and it /is/ programmer defined
06:20:22 <quicksilver> b_jonas: I'll try to remember for next time :)
06:20:23 <lilac> RowanD: i can say 'this function is in that mond'
06:20:24 <lilac> *monad
06:20:26 <mmorrow> > return 42 :: [Int]
06:20:28 <RowanD> Lilac: proofs of what?  Termination?
06:20:29 <lambdabot>   [42]
06:20:31 <mmorrow> > return 42 :: MAybe Double
06:20:32 <lilac> RowanD: right.
06:20:33 <lambdabot>   Not in scope: type constructor or class `MAybe'
06:20:34 <mmorrow> > return 42 :: Maybe Double
06:20:37 <lambdabot>   Just 42.0
06:20:39 <mmorrow> > return 42 :: IO Integer
06:20:42 <lambdabot>   * Exception: "<IO Integer>"
06:21:06 <RowanD> lilac: changing the monad is a very powerful technique.  Why not use it?
06:21:07 <Saizan_> i guess RowanD is talking about which "implicit monad" you get from direct style
06:21:09 <lilac> RowanD: proofs of termination are enough to enable proofs of anything else via curry-howard, AIUI
06:21:21 <lilac> RowanD: because haskell's default monad allows for referential transparency
06:21:22 <vixey> lilac: huh ?
06:21:55 <lilac> RowanD: in particular, there's no particular sequencing imposed by 'f x = g x + h x'
06:22:03 <b_jonas> HSOpenSSL-0.6 – found it, thanks. I will look at that
06:22:18 <lilac> RowanD: in order to implicitly thread a monad through that, we'd need to specify the /order/ in which g, h and (+) happened
06:22:21 <RowanD> lilac: I don't consider it transparent when one program terminates with an answer and another doesn't.
06:22:24 <vixey> lilac: I guess you mean like:   if <property> then () else diverge  ?
06:22:35 <lilac> vixey: the curry-howard thing?
06:22:53 <vixey> just curious what you mean by "proofs of termination are enough to enable proofs of anything else"
06:23:25 <int-e> @src assert
06:23:25 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
06:23:26 <vixey> it's saying that, every program at all can be coded as a termination argument
06:23:27 <lilac> vixey: yeah, if <property> then () else diverge is a nice way of doing it :)
06:23:34 <vixey> sorry
06:23:37 <vixey> every problem at all
06:23:50 <lilac> vixey: proving termination is proving your argument is well-founded
06:23:51 <mmorrow> vixey: i it that he means that termination implies you can use it as a "proof" checker
06:23:57 <mmorrow> *i take it..
06:24:25 <vixey> ok:  if you have a strongly normalizing proof (program) then that proof has a sound logical reading
06:24:45 <RowanD> The way pattern matching works in Haskell is inconsistent enough with the call-by-name view via curry-howard to make any such attempt very difficult.
06:25:06 <vixey> (maybe I need to tack on to the end  (assuming all the helper functions/lemmas it uses))
06:25:34 <lilac> RowanD: call-by-name is irrelevant in a total language. in a total language, lazy and strict evaluation have the same result.
06:26:01 <RowanD> If haskell pattern matching was lazy, maybe I would think lazy semantics was simple.
06:26:11 <RowanD> But, instead Haskell is a weird hybrid.
06:26:12 <jeffersonheard> peter, the latest version of FTGL on hackage fixes the CStringLen problem...  version 1.2
06:26:19 <jeffersonheard> and I'll look at the unsafePerformIO stuff
06:26:33 <lilac> RowanD: pattern matching has optional laziness.
06:26:39 <quicksilver> I don't think there is anything very complex about haskell's semantics.
06:26:45 <quicksilver> it's lazy in let, strict in case.
06:26:52 <quicksilver> it's not very hard to formalise that if you cared to do so.
06:26:55 <RowanD> Okay - true.  But, by default it is weird.
06:27:06 <tomh> if i got a computation with a value i require in a liftIO, can i get that value outside the liftIO to use in my monadtransformer?
06:27:08 <int-e> > let ~(x@23) = 42 in x
06:27:10 <lambdabot>   * Exception: /tmp/4208658166663480196:71:52-63: Irrefutable pattern failed ...
06:27:13 <lilac> RowanD: basically, pattern matching is strict by default /only/ in cases where you might need to choose which path to execute based on the pattern matched
06:27:15 <RowanD> Haskell has lazy expressions and strict patterns.
06:27:18 <RowanD> That is weird.
06:27:25 <int-e> not at all
06:27:30 <Saizan_> in general patterns can't be lazy by definition
06:27:31 <int-e> lazy patterns aren't very useful
06:27:39 <int-e> (as a default)
06:27:56 <tomh> :t liftIO
06:27:56 <RowanD> Non-strict patterns have a much more natural semantics.
06:27:58 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:28:01 <lilac> RowanD: f [] = [1,2]; f (x:xs) = x:f xs. how would you decide which branch to execute if the pattern matching were lazy?
06:28:03 <Saizan_> case x of 0 -> a; (n+1) -> b, how do you decide between a and b if without forcing x?
06:28:14 <RowanD> Haskells combination can only be defined operationally.
06:28:16 <Saizan_> s/if//
06:28:20 <int-e> Saizan_: exactly
06:28:34 <vixey> RowanD: is that bad?
06:28:42 <RowanD> Yes.
06:28:42 <ivanm> how does one enable profiling when running an app? ./foo +RTS -p ?
06:28:43 <lilac> RowanD: semantically they can be defined in terms of how they act on _|_
06:28:47 <vixey> why?
06:29:01 <RowanD> I'm a logician as well as a PL researcher.
06:29:06 <lilac> RowanD: in my example above, it says 'f _|_ = _|_; f [] = [1,2]; f (x:xs) = x:f xs'
06:29:14 <Saizan_> actually, you can desugar pattern matching to the untyped lambda calculus
06:29:31 <b_jonas> "haddock: internal Haddock or GHC error: Maybe.fromJust: Nothing"
06:29:48 <b_jonas> the encoding module still has an unbulidable docs :-(
06:29:53 <mmorrow> b_jonas: love that error
06:29:53 <ivanm> b_jonas: yeah, it's a bug
06:29:56 <ivanm> don't build docs for it
06:30:06 <Saizan_> b_jonas: even with the new haddock/ghc?
06:30:12 <ivanm> mmorrow: the haddock devs obviously never tried building it with -Wall...
06:30:17 <b_jonas> isn't there a way to download targzipped html docs?
06:30:24 <b_jonas> Saizan_: new ghc, but not new haddock
06:30:35 <b_jonas> ghc-6.10.1 that is
06:30:35 <ghcai> is it possible to make (') an operator?
06:30:42 <wli> I can't imagine the untyped lambdacalc as a computationally useful desugaring.
06:30:55 <lilac> RowanD: whereas if i wrote "f' xs = a:b:cs where (a,b,cs) = case xs of [] -> (1,2,[]); (x:xs) -> (x,head (f xs),tail (f xs))" it would say "f _|_ = _|_:_|_:_|_; f [] = [1,2]; f (x:xs) = x:f xs"
06:31:02 <mmorrow> > isSymbol '\''
06:31:06 <lambdabot>   False
06:31:06 <Saizan_> b_jonas: 6.10.2 is out :)
06:31:13 <b_jonas> Saizan_: it is? when?
06:31:20 <Deewiant> Two days ago
06:31:25 <b_jonas> oh, great
06:31:30 <daf> ghcai: it's used for character constant syntax :/
06:31:35 <b_jonas> let me check why freshmeat didn't notify me
06:31:42 <b_jonas> thanks for the info
06:31:57 <b_jonas> why's it not in the topic then?
06:33:23 <b_jonas> http://freshmeat.net/projects/ghc says the latest releases are 6.8.3 and 6.8.2 before that
06:33:41 <lilac> if one uses -XOverloadedStringLiterals, can one make `""` an operator?
06:33:50 <chessguy_work> what's freshmeat, some sort of open-source announcement feed aggregator?
06:34:05 <b_jonas> chessguy_work: something like that, yes
06:34:14 <b_jonas> I'm not really sure either, I only just started using it
06:34:17 <jeffersonheard> chessguy_work: for package releases.  Generally scrapes from sourceforge, but you can announce yourself as well
06:34:18 <ivanm> gah! the choke point of my app is a function from someone else's library! :s
06:34:20 <b_jonas> because I keep missing these release announcements
06:34:26 <quicksilver> lilac: I think not, because that's a lexer thing
06:34:29 <quicksilver> lilac: I could be wrong though.
06:34:39 <b_jonas> like bash 4.0 came out recently, etc
06:34:48 <lilac> quicksilver: ghci agrees with you
06:34:52 <quicksilver> lilac: I think `` is part of the lexical syntax not the expression syntax.
06:35:10 <b_jonas> it's tiring to check the homepage of all software package by hand whose updates I'm interested in
06:35:30 <wli> overloaded string literals are about bytestring string literals no?
06:35:31 * lilac forgot he had access to a box with ghci
06:35:37 <b_jonas> anyway, in this case I'm going to download 6.10.2 and buil dit
06:35:38 <ivanm> lilac: heh
06:35:43 <mmorrow> b_jonas: i think there's a "darcswatch" or something like that on hackage
06:36:01 <lilac> @src IsString
06:36:01 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
06:36:08 <ivanm> @src isString
06:36:09 <lambdabot> Source not found. I am sorry.
06:36:17 <RowanD> Look - I like Haskell - but I think it encourages non-strictness, but then doesn't do it in the natural way.  I think some of the Haskell designers themselves acknowledge this.  Haskell with strictness annotations everywhere is pretty cool - except you get sick of putting them there.
06:36:22 <ivanm> lilac: what type would isString have?
06:36:28 * vixey is trying to simplify a 70 line >>=
06:36:35 <lilac> ivanm: IsString is a typeclass
06:36:37 <ivanm> vixey: heh
06:36:39 <ivanm> lilac: oh...
06:36:44 <b_jonas> also ruby 1.9 came out
06:36:54 <ivanm> with a pretty obvious implementation using type-class extensions?
06:37:02 <ivanm> @hoogle IsString
06:37:03 <lambdabot> Data.String class IsString a
06:37:13 <b_jonas> it has a completely changed threads implementation (though I'm not sure why) and strings that know what encoding they are in and some other stuff
06:37:16 <lilac> ivanm: with -XOverloadedStrings, "foo" gets translated to something like fromString ('f':'o':'o':[])
06:37:29 <lilac> ivanm: where fromString :: IsString s => String -> s
06:37:36 <ivanm> lilac: "fromString"?
06:37:42 <lilac> not sure if that's the name
06:37:51 <lilac> @hoogle IsString s => String -> s
06:37:52 <lambdabot> Data.String fromString :: IsString a => String -> a
06:37:52 <lambdabot> Prelude error :: String -> a
06:37:52 <lambdabot> Debug.Trace trace :: String -> a -> a
06:38:04 <ivanm> lilac: ahh, is this the magic used for errors, etc.?
06:38:04 <kadaver> I want a shorter name for transpose
06:38:12 <quicksilver> lilac: I'm not sure that's the right way to have done it.
06:38:12 <kadaver> do I have to write a arser then?
06:38:19 <kadaver> arser->parser
06:38:30 <ivanm> lilac: I thought it was a class that determined if the given value was a String :s
06:38:31 <lilac> quicksilver: *shrug* at least it's consistent with Num
06:38:36 <ivanm> (which seemed pretty pointless...)
06:38:39 <quicksilver> lilac: I think it should have been "class IsString s where cons :: c -> s -> s; empty :: s"
06:38:47 <ivanm> kadaver: trans = transpose
06:38:49 <ivanm> ^^ like that?
06:38:50 <mmorrow> kadaver: let xpose = transpose
06:39:04 <quicksilver> lilac: to remove the overhead of constructing a list you don't need.
06:39:16 <quicksilver> lilac: sorry, cons :: Char -> s -> s
06:39:22 <quicksilver> and they're not serious name suggestions.
06:39:33 <lilac> quicksilver: at the expense of constructing O(n) intermediary ByteStrings ?
06:40:15 <b_jonas> quicksilver: why? plain String is a list so that's basically isomorphic, right?
06:40:26 <lilac> class IsString s where type X :: *; cons :: Char -> X -> X; empty :: X; make :: X -> s ?
06:40:27 <b_jonas> oh, you mean parametrized on s?
06:40:39 <lilac> +correct syntax
06:41:06 <kadaver> yes but like ion octave
06:41:11 <kadaver> M'
06:41:16 <kadaver> or 'M
06:41:27 <b_jonas> lilac: is that like type families?
06:42:33 <quicksilver> b_jonas: to avoid the list construction which possibly couldn't be optimised away.
06:42:35 <RowanD> lilac: one last word: F# equally emphasizes strict and non-strict lists.  It works pretty well.
06:42:38 <quicksilver> lilac: interesting point.
06:42:51 <quicksilver> RowanD: however haskell works better.
06:43:06 <quicksilver> @faq can haskell do everything F# can do, only better?
06:43:08 <lambdabot> The answer is: Yes! Haskell can do that.
06:43:22 <RowanD> Unless you want to change something from non-IO to IO.
06:43:29 <RowanD> In a large system.
06:43:32 <jedai> RowanD: In other words you want a strict language ? With optional lazyness ?
06:43:43 <quicksilver> lilac: my idea is that the intermediate bytestrings would be statically visible
06:43:49 <quicksilver> lilac: so the RULES would optimised them out.
06:43:55 <quicksilver> lilac: I'm not sure if this works, but I think it might.
06:44:03 <jeffersonheard> as I recall, SimonPJ has written a paper about the troubles of having a default-lazy language.
06:44:13 <jedai> RowanD: And with implicit IO ? Are you sure you're on the right channel ?
06:44:16 <quicksilver> lilac: and I don't think it would for the fromString version.
06:44:21 <jeffersonheard> however, I have to say that's the reason I started using Haskell, and one of the reasons I keep using it
06:44:33 <quicksilver> RowanD: I appreciate that's a problem in principle; I've never found it a problem in practice.
06:44:42 <quicksilver> you don't change a large subsystem from non-IO to IO
06:44:45 <quicksilver> you change one small thing
06:44:59 <quicksilver> and the ripple effect is manageable and caught by the compiler.
06:45:02 <RowanD> I want a language that has refinement types that make pure functions a subtype of maybe-non-terminating functions and those a subtype of IO type functions.  And maybe some things inbetween.
06:45:05 <quicksilver> is my (personal, anecdotal) experience.
06:45:06 <VibeFm> join pls #vibefm
06:45:32 * Twey wonders what ‘pls #vibefm’ is
06:45:50 <quicksilver> RowanD: certainly an interesting idea.
06:46:07 <Twey> I think the biggest issue is that functions in a default-strict language probably won't be written with laziness in mind
06:46:11 <RowanD> In fact, it's on my list to build such a thing for ML - something that distinguishes the pure functions from the others.
06:46:22 <RowanD> Has been on my list maybe for 10 years.  :)
06:46:23 <Twey> It becomes a bit of a gamble as to what's strict and what isn't
06:46:46 <vixey> RowanD: that sounds interesting btw
06:46:49 <wli> RowanD: Purity analysis helps gcc, too.
06:47:07 <RowanD> Yeah - I think it needs to be done.
06:47:30 <RowanD> My PhD was on refinement types, so it doesn't seem so far.
06:47:44 <RowanD> I consider it recovering a pure function space in ML.
06:48:38 <RowanD> I already have have a full implementation for SML.  But, I guess SML isn't used as much these days.  :)
06:49:27 * mmorrow loves smlnj
06:49:28 <wli> RowanD: Lots of us want SML's module system (or more).
06:49:53 <vixey> RowanD: you wrote anything about it? or just implented
06:50:06 <RowanD> You've seen the proposal that combines the two well?
06:50:17 <RowanD> Vixey: no.
06:50:28 <mmorrow> RowanD: which proposal?
06:50:45 <RowanD> Vixey: sorry - it's not at that stage.  I tend to go slow.
06:50:54 <wli> I remember the ML2000 proposal from various people.
06:51:05 <RowanD> mmorrow - I'll get the URL.
06:52:08 <RowanD> http://www.google.com.au/url?sa=t&source=web&ct=res&cd=4&url=http%3A%2F%2Fwww.cse.unsw.edu.au%2F~chak%2Fpapers%2Fmtc-tr-long.pdf&ei=XRTWSfu6ApKUkAWv4onCBA&usg=AFQjCNErCBWeirlYrfFXidtMOrE5FkmEFA&sig2=DstRlcieUT1XFXtZkMtgEQ
06:52:15 <RowanD> Oh. that was long.
06:52:29 <mmorrow> RowanD: thx :)
06:53:21 <RowanD> It's the Dreyer, Harper and Chakravarty paper.
06:53:39 <b_jonas> quicksilver: I see
06:54:04 <mmorrow> hmm, personally i think typeclasses are a poor substitute for a nice module system (but of course what i have in mind would need a modified haskell language definition)
06:54:13 <b_jonas> quicksilver: but doesn't it usually happen once in the program only because it's only called for literals?
06:54:17 <RowanD> (I have a bias here, I did my PhD at CMU.  Bob and Derek are friends.)
06:55:16 <RowanD> mmorrow: typeclasses are really great in the "small to middle" kinda programming.
06:55:52 <RowanD> morrow: modules are great for the "in the large" to set things up for the small to middle kind.
06:56:15 <RowanD> I really miss Haskell type classes in other languages.
06:56:26 <RowanD> But, there's a wall you hit with them.
06:56:37 <RowanD> When you need something more.
06:56:43 <Twey> I have to say, I prefer ad-hoc polymorphism in some cases
06:57:04 <Twey> Overloading can be handy
06:57:13 <RowanD> I prefer it in small programs.  For me that's most of the time.
06:58:18 <RowanD> But, when sometimes you want this equality, sometimes that...
06:58:21 <osfameron> are type classes and modules the same kind of thing?
06:58:29 <osfameron> I thought they were, what's the word?  orthogonal?
06:58:35 <RowanD> No, not really.
06:58:42 <b_jonas> neither I think
06:58:49 <b_jonas> neither orthogonal nor the same
06:58:56 <RowanD> I'd agree.
06:58:59 <mmorrow> RowanD: yeah, i agree. they're very very convenient when there's only one instance of a class for any given type that "makes sense", but when that's not the case they're a total pain
06:59:19 <Twey> RowanD: Well, I think Eq is meant to be for 'ultimate equality'
06:59:22 <Twey> As strict as it gets
06:59:47 <Twey> Probably if you want something else you should make another typeclass
07:00:06 <yaxu> orthogonal++ # one of the few useful words I know as a programmer that my english grad partner didn't
07:00:14 <RowanD> Okay, equality is a bad example them.  Less than is a better one.
07:00:33 <b_jonas> have you looked at the c++1x draft yet? it has something like typeclasses, except more dynamic of course
07:00:41 <b_jonas> it's called "concept"s
07:00:52 <RowanD> You can't just make another type class if you're using some elses code.
07:01:29 <mattam> Named Type Classes...
07:01:55 <Saizan_> Named instances you mean?
07:02:00 <mattam> Yes.
07:02:05 <Twey> RowanD: I think that the same applies
07:02:20 <Twey> Ord should be sort of global
07:02:38 <Twey> If you need something more specific you should make a different typeclass
07:02:47 <jedai> Twey: That's more open to discussion, there's often several order that make sense
07:02:54 <Twey> The real issue is that you can't then make (>) and so on work with that typeclass
07:03:05 <Twey> Which is what I miss from ad-hoc
07:03:07 <Saizan_> Twey: still if i define a LiberalOrd, i can only make an instance for that class
07:03:14 <jedai> Twey: the normal solution is to use newtype but that's not always very elegant
07:03:15 <Saizan_> Twey: so the main problem remains
07:03:26 <Saizan_> Twey: that's the reason we have sortBy etc..
07:03:31 <Twey> Yeah
07:03:39 <Twey> Which strikes me as something of a hack
07:03:56 <RowanD> You can have named subclasses that use different operations than the main class?  Is that reliable?
07:05:07 <jedai> class alias would help a bit to get a more compartimented type class space while still having the convenience and backward compatibility of the current sheme
07:05:25 <mattam> IMO a record system and sugar for treating them as typeclasses or modules would be best. But modules have complicated features like sealing and generativity.
07:05:47 <jedai> But I guess a better module system or maybe a localized instance definition or something like that would be nice
07:05:50 <yaxu> I want to do a psychological test, where I balance pairs of stimuli between test subjects...  anyone know of a haskell package that might help me?
07:06:10 <b_jonas> mattam: complicated features… that has never stopped ghc extensions
07:06:14 <RowanD> Seriously - the paper by Dreyer, Harper and Chakravarty talks about all this, and it convinced me.  Having both type classes and modules with a good interface between the two is the best thing.  It even solves some issues on both sides.
07:06:31 <mattam> RowanD: I really meant named instances: the ability to disambiguate an overloaded call by giving an instance explicitely.
07:06:52 <mattam> RowanD: the Modular Type Classes one?
07:07:14 <quicksilver> it doesn't work.
07:07:21 <RowanD> mattam: Oh!  Sure that's fine until you need the functions from the other kind of instance.  What do you do then?
07:07:24 <quicksilver> adding named instances to haskell (naively) breaks soundness.
07:07:34 <jeffersonheard> you know what i think would make leksah awesome...  if it took literate haskell source and highlighted the literate portions as either LaTeX or HTML and the code portions the same way it does Haskell now
07:07:42 <jeffersonheard> for that matter, Yi, too
07:07:42 <RowanD> Mattam: Yeah, that one.
07:07:45 <quicksilver> there is a whole lot about the type class system which *depends* on uniqueness of instances.
07:07:55 <quicksilver> if you want to generalise, you've got some reworking to do.
07:08:02 <wli> There's a paper about how to get decent module systems to work with typeclasses?
07:08:08 <mattam> quicksilver: due to scoping issues you mean?
07:08:10 <RowanD> Mattam: it's pretty nice - the best of both worlds.
07:08:18 <quicksilver> mattam: due to the use of type classes for invariants.
07:08:28 <quicksilver> mattam: consider a Data.Map built up with on Ord instance in scope.
07:08:30 <b_jonas> quicksilver: is that like the ugliness you get with ?variables ?
07:08:37 <quicksilver> mattam: if you somehow access it when another Ord instance is in scope
07:08:40 <quicksilver> it's totally broken.
07:08:53 <quicksilver> the globalness of Ord instances is assumed by Data.Map's invariants.
07:08:59 <quicksilver> similarly Data.Binary's class.
07:09:02 <mattam> Yes, but that's just because Map should have the Ord instance as a parameter :)
07:09:10 <RowanD> Yep.
07:09:10 <quicksilver> then it's not a type class any more.
07:09:17 <quicksilver> then it's just plain passing a comparison funciton
07:09:22 <quicksilver> (which is fine - nothing wrong with that)
07:09:28 <b_jonas> in the constructor?
07:09:36 <b_jonas> makes sense
07:09:42 <quicksilver> mattam: but then how do you 'Union' two different maps?
07:09:51 <quicksilver> comparison functions can't be checked for equality.
07:10:08 <Saizan_> you need to put the name of the instance in the Map type, at that point
07:10:12 <mattam> Well, not in Haskell indeed. But you can make such a type Map taking the Ord implementation as a parameter in a dep. typed language.
07:10:16 <yaxu> in particular I want to do balanced incomplete block design: http://en.wikipedia.org/wiki/Block_design
07:10:27 <quicksilver> you can yes
07:10:32 <RowanD> Guys- read the paper - it basically turns type classes into modules which are then just type theory so well understood.
07:10:38 <quicksilver> but then you have something really substantially different from type classes.
07:10:48 <quicksilver> which is just what i'm trying to say
07:10:53 <mattam> I agree.
07:10:55 <yaxu> there are enough keywords like 'set' and 'combination' and 'algebra' to indicate to me that haskell would be good at this kind of stuff
07:10:56 <quicksilver> removing the uniqueness restriction is a big change.
07:11:24 <yaxu> there's even a lambda there
07:11:24 <quicksilver> I personally feel haskell type classes should not be viewed as an 'abstraction' mechanism of any kind.
07:11:34 <quicksilver> They're just an overloading mechanism.
07:11:38 <mattam> It's a convenience.
07:11:40 <RowanD> No, because type classes can be compiled into a language without them.  This does it in a really natural way.
07:11:44 <quicksilver> If you only use them when overloading is what you want, that's fine.
07:11:58 <quicksilver> RowanD: sure, but that language is unsound.
07:12:23 <quicksilver> RowanD: the dictionary passing translation of type classes (to take one example) admits the possibility of 'breaking' a Data.Map by passing the 'wrong' ord instance.
07:12:39 <Saizan_> but isn't overloading an abstraction mechanism? i.e. like mapM abstracts over the monad
07:12:40 <b_jonas> quicksilver: um, you could say it's just overloading only if all the instances could be flattened in compile time like with c++ templates, but they can't
07:13:11 <quicksilver> b_jonas: I disagree. Nothing about overloading in my mind requires resolution at compile time.
07:13:19 <quicksilver> b_jonas: the Num class is used to overload (+)
07:13:26 <RowanD> Quicksilver: give me an example?
07:13:32 <quicksilver> b_jonas: so we can use the symbol (+) to stand for different functions in different types.
07:13:45 <quicksilver> b_jonas: we can do that even when the type isn't clear at compile time
07:13:50 * whpearson decides to write an anime smiley haskell package using ^.^ and ^-^/ and -.-
07:13:52 <quicksilver> b_jonas: (by dictionary passing, or by some other implementation method)
07:13:56 <quicksilver> b_jonas: it's still a form of overloading.
07:14:02 <b_jonas> hmm, that's true
07:14:21 <quicksilver> RowanD: if you insert into a Data.Map with one Ord instance, and 'lookup' with a different Ord instance, you may not find the item
07:14:26 <quicksilver> RowanD: that's "broken" Data.Map
07:14:29 <RowanD> Unless your modules are first class.
07:14:30 <wli> I completely fail to get what quicksilver is on about.
07:14:50 <quicksilver> RowanD: you can't do that directly in haskell, but if you do the dictionary-passing transform, then in your *destination* language, you can break Map.
07:14:51 <jeffersonheard> whpearson, what would the `o_O` operator do?
07:15:02 <quicksilver> RowanD: so, that translation moves you to a language which can express unsound things.
07:15:10 <quicksilver> that's not particularly surprising. I'm not saying it is.
07:15:19 <whpearson> Jeffersonheard: Unfortunately it is illegal.
07:15:19 <mattam> You can break the typeclass abstraction because it relies on an "invisible" (type wise) invariant: instances are unique.
07:15:26 <jeffersonheard> whpearson, no it's not
07:15:34 <jeffersonheard> it just has to be infixed using backticks
07:15:46 <jeffersonheard> o_O is a perfectly valid identifier...
07:15:46 <quicksilver> let o_O a b = a + b in 3 `o_O` 4
07:15:51 <RowanD> quicksilver: is what Haskell type classes do any better?
07:15:52 <quicksilver> > let o_O a b = a + b in 3 `o_O` 4
07:15:54 <lambdabot>   7
07:16:05 <quicksilver> RowanD: well, it at least lets you have a sound Data.Map?
07:16:11 <wli> quicksilver: You can break things that way now by passing things across module boundaries.
07:16:28 <quicksilver> wli: only by using orphan instances
07:16:29 <mattam> quicksilver: well it's unsound w.r.t. to the semantics you gave to the source language, it's just "larger".
07:16:30 <RowanD> I think it is still not going to work.
07:16:30 <osfameron> o_O = ironicFoldl, O_o = ironicFoldr ?
07:16:37 <quicksilver> wli: which is why orphan instances should be illegal.
07:16:39 <whpearson> Ahh, but still not what I was going for unless the backticks add to the smiley in some fashion
07:16:44 <jeffersonheard> quicksilver, properly, I think o_O should hide unsafeInterleaveIOs on either side, to always generate a surprising result
07:16:59 <Saizan_> with orphan instances you should still get an error, i think?
07:17:00 <jeffersonheard> whpearson ,they're sweat
07:17:03 <quicksilver> wli: (or to be more precise, GHC is a non-compliant haskell compiler because it doesn't complain if you compile a program with two different orphan instances)
07:17:12 <quicksilver> Saizan_: I think you don't, and that's reported as a GHC bug.
07:17:15 <quicksilver> I could be wrong.
07:17:35 <RowanD> Basically for everything you care about, that paper gives you something sweet.
07:17:45 <quicksilver> RowanD: I don't disagree with you.
07:17:57 <quicksilver> My only argument is that changing typeclasses to fix this is a substantial change.
07:18:09 <quicksilver> and you can make a case for what you have after that change not really being typeclasses any more.
07:18:19 <quicksilver> in the sense that they're different and perhaps shouldn't have the same name.
07:18:29 <Saizan_> quicksilver: i can't conjure an example where the two instances won't be in scope at some point, but i'm not thinking that hard
07:18:30 <quicksilver> I'm not saying it can't be fixed, or you can't get a useful language by fixing it.
07:18:33 <RowanD> Ha.  In Functional languages, everything changes over time.
07:18:52 <quicksilver> well the clue is in the name. Type "class".
07:18:56 <mattam> Maybe classes would suffice, but that's already overloaded :)
07:18:58 <quicksilver> you are either a memebr of a class, or you're not.
07:18:59 <RowanD> Functional languages are the testing grounds for more mainstream languages.
07:19:04 <quicksilver> you can't be a member of the same class twice.
07:19:13 <quicksilver> your generalisation would be properly called 'typemulticlasses' P
07:19:17 <_boegel_> has anyone ever run into something like this while doing a Cabal install of a package: Setup.hs: failed to create OS thread: Cannot allocate memory
07:19:18 <_boegel_> :-/
07:19:28 <RowanD> Well, I can when I'm drunk.. :)
07:19:55 <whpearson> Can I get a link to the paper?
07:20:18 <RowanD> Yeah, yeah.  One sec.
07:20:19 <Saizan_> _boegel_: tried compiling it?
07:20:42 <_boegel_> Saizan_: this is during configure
07:20:52 <RowanD> http://www.google.com.au/url?sa=t&source=web&ct=res&cd=4&url=http%3A%2F%2Fwww.cse.unsw.edu.au%2F~chak%2Fpapers%2Fmtc-tr-long.pdf&ei=XRTWSfu6ApKUkAWv4onCBA&usg=AFQjCNErCBWeirlYrfFXidtMOrE5FkmEFA&sig2=DstRlcieUT1XFXtZkMtgEQ
07:20:58 <RowanD> Sorry, kinda a long link.
07:21:00 <quicksilver> whpearson: http://scholar.google.com/scholar?hl=en&lr=&client=firefox-a&cluster=3828178155619767776
07:21:00 <Saizan_> _boegel_: compiling the Setup.hs script, i mean
07:21:03 <quicksilver> ;)
07:21:12 <RowanD> That is a better link.
07:21:19 <_boegel_> Saizan_: how would that help?
07:21:40 <_boegel_> Saizan_: hmm
07:21:43 <_boegel_> Saizan_: ghc Setup.hs -o setup_csv
07:21:43 <_boegel_> Setup.o:(.text+0x46): undefined reference to `Cabalzm1zi6zi0zi3_DistributionziSimple_defaultMainWithHooks_closure'
07:21:43 <_boegel_> Setup.o:(.text+0x4d): undefined reference to `Cabalzm1zi6zi0zi3_DistributionziSimple_defaultUserHooks_closure'
07:21:50 <Saizan_> _boegel_: use --make
07:21:59 <whpearson> quicksilver, RowanD: Thanks
07:22:11 <_boegel_> Saizan_: yeah, figured that when I pressed <enter> :)
07:22:39 <Saizan_> _boegel_: it's a shot in the dark, anyway, but sometimes effective
07:23:09 <_boegel_> Saizan_: it works
07:23:15 <_boegel_> Saizan_: any idea why it works? :)
07:23:42 <_boegel_> Saizan_: does this mean runhaskell on that system is fubar?
07:23:47 <Saizan_> _boegel_: no, never seen that error before :)
07:24:09 <_boegel_> Saizan_: hmmk
07:24:14 <_boegel_> Saizan_: thanks anyway ;-)
07:24:24 <Saizan_> _boegel_: it looks like that, try with other scripts too, it could be a proper bug
07:26:20 <_boegel_> Saizan_: hmm
07:26:35 <_boegel_> Saizan_: it might be caused because I didn't install GHC 'properly' though
07:26:52 <_boegel_> Saizan_: this is on Gentoo, and emerge is telling me it only has GHC 6.8
07:27:11 <_boegel_> Saizan_: so I installed libedit (using emerge), and unpacked a binary GHC 6.10.2 version
07:27:34 <_boegel_> Saizan_: without removing the 6.8 one installed by Gentoo, which might be the cause of the issues I'm seeing
07:27:43 <_boegel_> ah well, who uses runhaskell anyway :P
07:28:14 <Saizan_> multiple versions of ghc installed are usually fine
07:29:31 <_boegel_> hmmk
07:29:37 <michaelcdever> does anyone know if there were any major changes to ghc or gtk2hs in the last week?
07:29:46 <RowanD> boegel: I use runhaskell when I want to see an old, dead, but excellent, logician run around.
07:30:00 <michaelcdever> sorry, the ubuntu .deb file installable using apt
07:30:16 <michaelcdever> and the gtk2hs source
07:30:21 <mmorrow> _boegel_: iirc runhaskell uses the bytecode interpreter, so that may be why runhaskell Setup.lhs fails and ghc --make Setup.lhs && ./Setup succeeds
07:30:42 <mmorrow> (assuming here that Setup.lhs has nontrivial code in it)
07:31:11 <mmorrow> (and that the programmer is relying on the strictness analyzer to make that code work)
07:32:39 <_boegel_> mmorrow: Setup.hs is fairly trivial
07:32:40 <mmorrow> but in that case i'd expect a stack overflow... i've never seen the "cannot allocate memory" error
07:32:50 <mmorrow> yeah, something must be borked
07:33:51 <RowanD> It's an effect.  :)
07:34:23 <wli> I'm having real trouble seeing the problem quicksilver is on about. It seems like something you shouldn't do inadvertently, but not really a necessary guarantee.
07:34:55 <RowanD> Say again what problem that is?
07:35:20 <_boegel_> RowanD: Setup.hs: failed to create OS thread: Cannot allocate memory (during Cabal configure)
07:35:38 <tibbe> last day for applying for haskell.org SoC projects is today
07:35:44 <Saizan_> that e.g. Data.Map relies on uniqueness of instances for correctness
07:35:51 <Saizan_> Storable too
07:35:53 <wli> RowanD: Conflicting instance usage being enabled by module scope control for instances.
07:36:02 <michaelcdever> how do i get project space on haskell.org? i.e. along the lines of haskell.org/hide
07:36:21 <Saizan_> michaelcdever: community.haskell.org
07:36:37 <michaelcdever> Saizan: cheers
07:37:07 <RowanD> wli: Yeah, seems unlikely to me too.
07:37:24 <Saizan_> what's unlikely?
07:37:32 <RowanD> wli: But yeah, it can happen.
07:37:34 <michaelcdever> hmmm thats not loading up
07:37:40 <Saizan_> i think for modules that corresponds to traslucent functors?
07:37:52 <wli> RowanD: But it can happen as things now stand anyway.
07:37:56 <Saizan_> (only that instances are not types here)
07:38:03 <Saizan_> wli: can you give me an example?
07:38:17 <RowanD> wli: But, yeah, first class modules of those kind will fix that.
07:39:03 <jeffersonheard> what's the general way to catch a failure that normally isn't caught?  like read-ing something that doesn't parse?  Usually, I just get a bork: Prelude.read no parse
07:39:10 <RowanD> wli: they will fix many things.  Maybe even not first class, but at least economy class modules.
07:39:48 <wli> Saizan: I remember hearing about this and getting shown an example but not what the example was.
07:40:03 <Saizan_> wli: did it use OverlappingInstances ?
07:40:27 <wli> Saizan: quicksilver actually knows the details.
07:41:53 <Saizan_> jeffersonheard: use readMaybe (or similar) from the safe package, or write one yourself using reads
07:42:05 <malcolmw> jeffersonheard: I think the answer is to use a real parser, but for now you might just want to catch the exception (Control.Exception)
07:43:23 <jeffersonheard> malcomw: I wasn't sure it threw an exception, thanks. Saizan_ the reason I asked for "general" is that I'd like the same thing for an invalid Binary file or other kind of failures where GHC runtime normally just borks out with an unhelpful message
07:43:59 <Saizan_> i dislike Binary for that too
07:44:19 <Saizan_> i tend to use a real parser over bytestrings, in fact
07:44:28 <jacobian> Is there a 'replace' function in Prelude with a -> [a] -> [a]
07:44:34 <jacobian> er sorry
07:44:39 <jacobian> Eq a => a -> [a] -> [a]
07:45:07 <Saizan_> no
07:45:12 <mmorrow> bytestringreadp++ (on hackage)
07:50:48 <_boegel_> @hoogle a -> [a] -> [a]
07:50:48 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:50:48 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
07:50:48 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
07:51:01 <_boegel_> @hoogle (Eq a) => a -> [a] -> [a]
07:51:01 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
07:51:02 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:51:02 <lambdabot> Data.List (\\) :: Eq a => [a] -> [a] -> [a]
07:51:19 <_boegel_> jacobian: seems like no
07:51:32 <_boegel_> jacobian: I wrote my own, it's really easy :)
07:51:40 <jacobian> yes
07:51:51 <jacobian> Just better to use the built in if it exists
07:52:16 <lilac> jacobian: what would it do?
07:52:32 <lilac> replace x xs  = ?
07:53:13 <lilac> did you mean replace ::  Eq a => a -> a -> [a] -> [a]?
07:53:23 <kadaver> why is this not legal in Parsec:
07:53:23 <jacobian> yes
07:53:23 <kadaver> P.eof P.<|> (P.char '/' P.<|> P.char '(' P.<|> P.char '.' P.<|> P.char '[')
07:53:30 <jacobian> I'm just an idiot
07:53:40 <jacobian> at least currently
07:53:46 <lilac> @hoogle Eq a => a -> a -> [a] -> [a]
07:53:46 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
07:53:46 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
07:53:46 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
07:53:50 <jacobian> I'm going to go eat, and see if my brain starts working better
07:54:04 <RowanD> @hoogle List a -> ()
07:54:04 <lambdabot> Warning: Unknown type List
07:54:05 <lambdabot> Control.Parallel.Strategies r0 :: Strategy a
07:54:05 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
07:54:06 <mmorrow> kadaver: you probably need to use `try', parsec does depth-first search
07:54:14 <RowanD> Oh, oh.
07:54:38 <RowanD> @hoogle [a[ -> ()
07:54:38 <lambdabot> Parse error:
07:54:38 <lambdabot>   --count=20 "[a[ -> ()"
07:54:38 <lambdabot>                  ^
07:54:42 <Twey> kadaver: Excess of P.s
07:54:49 <wli> RowanD: These LL parser combinators are terrifying.
07:55:05 <RowanD> LL parsers?  Not really.
07:55:18 <Twey> kadaver: Try P.eof P.<|> P.oneOf "/(.["
07:55:25 <lilac> @@ @pl @djinn Maybe a -> ()
07:55:25 <lambdabot>  f = const ()
07:55:32 <wli> RowanD: I'm going to have to check out X-SAIGA for something that handles a less crippled class of grammars.
07:55:51 <RowanD> @hoogle [a] -> ()
07:55:52 <lambdabot> Prelude head :: [a] -> a
07:55:53 <lambdabot> Prelude last :: [a] -> a
07:55:53 <lambdabot> Data.List head :: [a] -> a
07:56:09 <edwardk> wli is a grammar snob ;)
07:56:09 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:56:22 <RowanD> Wait - no - I didn't ask for those.
07:56:29 <RowanD> I wanted unit!
07:56:33 <lilac> RowanD: those are the closest matches
07:56:33 <Twey> RowanD: Works for a = () :-P
07:56:41 <RowanD> Haha.
07:56:46 <lilac> (by some definition of 'closest')
07:57:04 <Saizan> sort of btw, any nice way to get informative parse errors out of a DCG?
07:57:07 <lilac> RowanD: what's wrong with my @djinn? :)
07:57:17 <kadaver> seriously this drives me nuts that i cant define the grammer in parsec for soemthing so simple
07:57:23 <lilac> (ok, i used maybe not list because djinn doesn't do lists, but...)
07:57:31 <RowanD> Haskell function with return type () has no purpose really other than to slow things down.
07:57:33 <wli> Saizan: I mostly hand-code error rules in DCG's.
07:58:05 <orbitz> kadaver: what are you definingag grammar for?
07:58:15 <lilac> RowanD: you can use unit types for checking proofs at runtime
07:59:52 <wli> orbitz: He's probably irritated by the operational aspects of parsing clobbering the direct specifications of grammars.
08:00:09 <quicksilver> RowanD: it may have a strictness effect.
08:00:30 <quicksilver> RowanD: that's why Control.Parallel.Strategies defines 'Done' as '()'
08:01:10 <orbitz> wli: i suspect his complaint is less nuansced :)
08:06:33 <lilac> RowanD: pragmatically, the function 'assert_not_null [] = error "unexpected null list"; assert_not_null _ = ()' might be useful in contexts such as 'joinWith f xs = assert_not_null xs `seq` foldr1 f xs'
08:08:41 <quicksilver> lilac: although I'm not sure that's better than joinWith f [] = error "unexpected null list"; joinWith f xs = ...
08:08:52 <quicksilver> indeed, I'm sure it's not better :)
08:10:05 <kadaver> how can Map.size be O(1)?
08:10:08 <Saizan> error "Foo.joinWith" please
08:10:09 <_boegel_> can someone give me a quick pointer to some manual/tutorial on vectorization of Haskell code using GHC?
08:10:20 <kadaver> is Map a record?
08:10:22 <_boegel_> I need some food-for-thought for my 45m train ride back home :)
08:10:22 <Saizan> ..and the rest of the message
08:10:42 <Saizan> kadaver: the size is cached in the contructor, it's used for balancing purpouses
08:11:17 <Saizan> _boegel_: look for DPH, Data Parallel Haskell
08:11:42 <_boegel_> Saizan: hmmk, thanks
08:11:57 <wli> kadaver: Each node in the tree stores the size of the tree rooted at the node in the node itself.
08:12:30 <_boegel_> Saizan: I'm not sure that's entirely what I'm looking for, but I'll skim through it anyway
08:12:51 <wli> AVL is HB[1] i.e. height-balanced to within a difference of 1.
08:13:12 <_boegel_> Saizan: the main thing I was looking for is a way to tell GHC to make sure to use SSE2 or so instructions for a simple but heavily used function in my code, i.e. one which computes the Euclidean distance between two points
08:13:20 <wli> Data.Map's tree doesn't have a name I'm aware of but balances on tree size vs. height.
08:13:46 <_boegel_> i.e. dist p1 p2 = sqrt . sum $ zipWith (\x y -> (x-y)^2) p1 p2, with p1 and p2 [Double], and thus a result of type Double
08:14:44 * BMeph imagines Data.Map with a sticker "Now Fortified with balancing porpoises!"
08:14:50 <_boegel_> now, this function is being executed 75% of the time, according to a profiling run, and it'll only get worse when changing the parameters, so I need a way to speed up this function significantly :)
08:15:52 <wli> _boegel_: Or constructible numbers (i.e. the closure of the rationals under real quadratic extensions)
08:19:26 <_boegel_> wli: eh?
08:19:31 <_boegel_> wli: nvm, gotta run
08:19:35 <_boegel_> ttyl!
08:22:10 <xkb> hi
08:22:16 <wli> There are actually roots of unity whose real and imaginary parts lie within such fields, i.e. p-th roots of unity where p is a Fermat prime.
08:22:20 <RowanD> @run boegel
08:22:21 <lambdabot>   Not in scope: `boegel'
08:22:27 <xkb> How can I set an unix env var in haskell?
08:23:31 <wli> Hence Gauss' construction of a 17-sided regular polygon with straightedge and compass. ;)
08:24:13 * edwardk always thought someone should have introduced the idea of marking a ruler to the greeks ;)
08:24:36 <edwardk> trisecting an angle? no problem ;)
08:24:46 <RowanD> Indeed. I have to say: why?  Has anyone used that construction since?
08:25:15 <edwardk> RowanD: it was a classic open greek open at the time
08:25:26 <RowanD> Yeah.
08:25:37 <RowanD> I'm classically trained.
08:25:44 <quicksilver> xkb: System.Environment
08:25:48 <RowanD> Has anyone used it?
08:26:06 <abbe> quicksilver, I don't there is any setEnv, putEnv function there.
08:26:17 <abbe> s/t the/t think the/
08:26:35 <jeffersonheard> xkb: look in System.Environment
08:27:20 <jeffersonheard> xkb: heh...  you're right
08:27:57 <quicksilver> ah, true.
08:28:07 <quicksilver> you can set a fresh environment for subprocesses when you create them though
08:28:09 <quicksilver> (System.Process)
08:28:46 <xkb> jeffersonheard: yeah there's only getEnv
08:28:52 <xkb> quicksilver: ah ill look there
08:28:57 <jeffersonheard> hrm... checkpoint your program at this point, then fork a new subshell, set the environment variable, and restart your program with the checkpoint file!!!
08:29:04 <xkb> I'm trying to build a greylister for qmail with haskell
08:29:12 * jeffersonheard is beginning to think he should go back to Tcl...
08:29:21 <abbe> xkb, System.Posix.Env
08:29:42 <jeffersonheard> abbe:  or that... ^_^
08:29:54 <xkb> abbe: nice :)
08:30:05 <abbe> :-)
08:32:35 <Saizan> is there a way to extend a simple backtracking+mutable variables unification algorithm to cope with reducible terms like the application of a type function?
08:33:23 <RowanD> Yes, I think with a complicated monad.
08:33:37 <wli> Saizan: Beta normalize everything?
08:34:18 <RowanD> Oh - I hope not higher-order unification.  No function variables, right?
08:34:59 <wli> RowanD: Is it doable if all functions are some sort of constant?
08:35:18 <Saizan> wli: the problem is when the argument is still uninstantiated
08:35:36 <RowanD> Normal unification is just function names and constants all applied to each other.
08:35:50 <Saizan> no, no function variables
08:36:12 <RowanD> Wli - yeah, if constants, fine.
08:36:32 <RowanD> If you can determine equality between them, well enough.
08:38:32 <Saizan> it looks like i need a way to defer unification, i.e. i can't resolve "Foo a `unify` X" while 'a' is still a variable
08:38:45 <Saizan> and Foo is a function
08:39:10 <Saizan> as opposed to a type-constructor
08:40:08 <RowanD> Yeah, you are in the domain of higher-order unification.  Frank Pfenning is the expert on that.  (My Phd supervisor.  I guess I could try to help.)
08:41:22 <RowanD>  As you said - you have to defer some.
08:41:34 <Saizan> mmh, i'm a bit confused on what qualifies as higher order unification and what doesn't
08:41:37 <RowanD> Basically do a best effort.
08:41:37 <mattam> Saizan: welcome to undecidability :)
08:42:13 <RowanD> Right, you can't just keep going cause then sometimes you won't finish.
08:42:40 <RowanD> Although- there are many practical algorithms that sometimes don't terminate.
08:42:50 <Saizan> i see
08:43:37 <RowanD> Including a nice variant of polymorphic type inference.
08:44:10 <RowanD> Yeah, but basically, check some papers on higher-order unification.
08:44:46 <mattam> Huet's is nice.
08:44:47 <RowanD> It becomes ad-hoc for obvious reaons.
08:44:55 <RowanD> Yep.
08:44:58 <RowanD> Agreed.
08:45:22 <kadaver> so what symbols are available to use as functions?
08:45:27 <Saizan> i have a very limited special case, actually
08:45:34 <mattam> (he was my supervisor's supervisor, small world).
08:45:35 <RowanD> Although, that is still decidable - I think?
08:45:46 <mattam> Maybe so.
08:45:56 <offender> would someone of you like to be my urinating friend?
08:45:59 <mattam> It's a semidecision algorithm.
08:46:21 <RowanD> I'd love a urinating friend!
08:46:46 <offender> can someone help me to lick urine
08:46:53 --- mode: ChanServ set +o Saizan
08:46:59 --- mode: Saizan set +b *!*i=saippua@*.kpylaajakaista.net
08:46:59 --- kick: offender was kicked by Saizan (Saizan)
08:47:03 --- mode: Saizan set -o Saizan
08:47:04 <RowanD> Right, most higher-order unification is semi-decidable,
08:47:38 * osfameron reads that as "higher order urination"...
08:47:41 <RowanD> Yeah, no, Huets is semi-decidable too.
08:48:49 <Saizan> to a [] = []; to a (l:t|r) = l: t -> a | to a r -- i only need to deal with this function, where the second argument is a row type
08:48:55 <mattam> And if you throw in some subtyping it's even funier :)
08:49:22 <Saizan> so i'm really asking for trouble?:)
08:50:12 <Saizan> (row types being a form of subtyping)
08:50:23 <mattam> Oh yeah you are. But I guess that means your system's interesting.
08:54:21 <pumpkin> thoughtpolice: yo
08:55:13 <Saizan> well i'm trying to implement section 6.1 of http://web.cecs.pdx.edu/~mpj/pubs/polyrec.html , they refer to it as "straightforward"
08:55:27 <edwardk> heya mattam, back in the states?
08:56:22 <edwardk> saizan: row types are nice. did you see MLPolyR?
08:57:47 <Saizan> edwardk: i did, very nice, but i'm trying to implement the record/variant duality without an ad-hoc case construct
08:58:01 <Saizan> and equi-recursive types are scary :)
08:58:09 <mattam> edwardk: yep.
09:03:19 <zcvvc> (beginner) question: typing just "return" at GHCi triggers ambiguous type variable error so the compiler refuses to guess. But when I type "return 3" it shows the number 3 and doesn't care that I didn't say explictly which monad I'm going to use. Why?
09:04:23 <zcvvc> *explictly state which
09:04:24 <Saizan> the ghci prompt is almost like a do-block in the IO monad
09:04:49 <Saizan> so return 3 is types as IO Integer
09:04:53 <Saizan> *typed
09:05:25 <zcvvc> why return isn't typed as IO a -> a, then?
09:05:52 <Saizan> a -> IO a you mean?
09:05:56 <zcvvc> yes, sorry
09:06:05 <Saizan> because a -> IO a doesn't match IO b
09:07:52 <glguy> if you just type "return" then you have a function rather than a single value
09:08:03 <glguy> since that value can't be bound into the main block
09:08:11 <glguy> it can't infer that it should have used IO
09:08:46 <glguy> since that function can't*
09:09:14 <jeffersonheard> sighting of Haskell code in a graphic on our Open Source License page:  http://www.renci.org/resources/open-source-software-license
09:09:33 <zcvvc> thanks, I'm starting to understand it
09:09:34 <quicksilver> ghci tries to unify with (IO a) and (Show a => a)
09:09:44 <quicksilver> I'm not sure if there is something else it tries.
09:10:25 <Saizan> if expr is your expression, you can imagine that it first tries to execute "expr >>= print", then "expr >> return () :: IO ()", and then "print expr"
09:10:35 <Saizan> and some other special case wrt ()
09:11:05 <zcvvc> thanks. I got it now
09:22:02 <BMeph> So, where's the project to write the JVM in Haskell hosted? ;)
09:23:11 <Twey> What would we want that for?  :-P
09:23:17 <Twey> When's the GHC Parrot target coming?
09:29:27 <mib_70zvkhw6> Did anybody checked out the Jon Harrop's new benchmark?
09:30:12 <quicksilver> well, Data.Hashtable is basically broken and deprecated.
09:30:17 <quicksilver> beyond that, what is there to add?
09:30:45 <quicksilver> (not broken as in correctness, just in terms of performance)
09:30:52 <mib_70zvkhw6> Is just i'm not a haskell expert but i hate Jon's attitude
09:31:28 <kadaver> mib_70zvkhw6: he's a known troll,noone really takes him seriously
09:32:34 <jmcarthur_work> _new_ benchmarks? where?
09:32:41 * jeffersonheard thinks it's sad when someone who's otherwise done good work decides to turn troll...
09:32:42 <dons> mib_70zvkhw6: seriously. not worth the effort.
09:32:47 <jmcarthur_work> i remember the ray tracer benchmarks
09:33:21 <jeffersonheard> mib_70zvkhw6: he's basically an ML zealot.  Anything that is not ML is trolled.
09:33:39 * jmcarthur_work has been thinking about making a ray tracer
09:33:56 <dons> jeffersonheard: not so much ML, really
09:34:04 <dons> what ever product he is selling, which is more F# now.
09:34:18 <dons> and by selling we mean pay-per-read blog posts
09:34:18 <jeffersonheard> dons: F#'s sorta based on ML, though
09:34:24 <jeffersonheard> it's ML-like, anyway
09:34:31 <jeffersonheard> didn't know he was into that now, though.
09:34:33 <dons> yup. but I wouldn't say he's an ML person. he's very particular
09:34:47 <kadaver> isnt haskell ML based? at least syntactically it is very similar
09:35:06 <jeffersonheard> just remember the first release of Hieroglyph he wrote me to say how superior his vis package was
09:35:36 <jeffersonheard> I'm like, "Yeah, well, Processing's superior in functionality and performance right now, too, but that doesn't mean this *can't* be, just means it's an initial release"
09:35:50 <jeffersonheard> and left it at that
09:36:05 <dons> jeffersonheard: he sees you as a competitor
09:36:17 <dons> since he's trying to sell some visualisation libs for F# and ocaml c
09:36:25 <jeffersonheard> ah well, fine.  I see him as a line on my banlist
09:36:38 <dons> so when someone does something in haskell, and puts it on hackage, that cuts his market pretty significantly
09:36:50 <dons> he doesn't have the mindshare anyway
09:37:46 <dons> jeffersonheard: yeah, seriously, he's either trying to demotivate you, or have you switch and buy his stuff. that kind of behaviour sucks
09:38:11 <jeffersonheard> does F# have the same ugly global-runtime-lock as OCaml?  I just remember giving up on ocaml when I realized I had to fork processes and migrate threads manually to get the same behaviour as Haskell, C, or Java
09:38:34 <dons> F# uses a different runtime, the .NET one
09:38:55 <dons> only has higher level similarities to ocaml (and haskell)
09:38:59 <p_l> and it doesn't have any of those giant locks
09:39:00 <jeffersonheard> ah yay. well, so probably less broken with regards to parallelism than ocaml
09:39:15 <dons> yep
09:39:30 <p_l> jeffersonheard: it's well connected to MS' new parallel-oriented SDKs
09:39:38 <jeffersonheard> might check it out sometime.  what I really want is a pure-functional language that compiles to ActionScript/Flash
09:39:42 <mib_70zvkhw6> jeffersonheard: you can use .net thread pool instead of forking your own processes.
09:39:45 <jeffersonheard> at the moment
09:40:00 <jeffersonheard> mib:  oooh, that is nice, actually.  convenient
09:42:05 <quicksilver> kadaver: "based on", no. But the designers of haskell were definitely influences by the syntax of ML.
09:42:15 <zachk> i am in minor dependency hell getting cabal-install to work. i got zlib installed the C and the haskell parts of it. but HTTP is whining for parsec and things. should i just manually fufill its requests or is there a simpler way
09:43:10 <forneus> \o/
09:44:05 <Saizan> zachk: what are you running and what's the error?
09:48:00 <kadaver> where doyou normally comment haskell code? in the .hs file?
09:48:10 <kadaver> or you generate haddocks and add commetns?
09:50:02 <dons> in the .hs file
09:50:11 <dons> which is where haddock stuff is extracted from
09:50:39 <kadaver> and haddock comes with ghc?
09:50:59 <nlogax> RWH just showed me why the type signatures look like they do, first mention of partial function application, and it blew my mind a little.. (supernoob here). is my interpretation correct that for example the value of the expression "map toUpper" is a function that takes a list of chars and produces another one?
09:51:18 <michaelcdever> wow ghc takes a long time to build
09:51:23 <zachk> nlogax yes
09:51:32 <nlogax> (or something close to that.. maybe the full explanation comes later)
09:51:35 <nlogax> oh, great :)
09:52:25 <zachk> > sum $ map (\x->x*x) $ [1..10]
09:52:26 <lambdabot>   385
09:52:47 <zachk> > sum.map (^2) $ [1..10]
09:52:49 <lambdabot>   385
09:53:00 <nlogax> takes a while to digest these things, being a lowly web dev spending most of the time doing js
09:53:51 <zachk> see the first one? that was with a lambda, an anonymous function. the second one i just left out the first argument n^2 and made it ^2 and that is a partial function that takes one argument
09:54:11 <chessguy_work> @type let foobar = do { a <- [1,2,3]; b <- [4,5,6]; liftIO $ putStrLn $ show a; return (a+b); } in foobar
09:54:13 <lambdabot>     No instance for (MonadIO [])
09:54:13 <lambdabot>       arising from a use of `liftIO' at <interactive>:1:46-51
09:54:13 <lambdabot>     Possible fix: add an instance declaration for (MonadIO [])
09:54:33 <kadaver> so I think i have a fold ++ problem
09:54:44 <kadaver> > foldr (++) "" ["hello","there"]
09:54:45 <lambdabot>   "hellothere"
09:54:48 <mauke> function map(f) { return function(xs) { var ys = []; for (var i = 0; i < xs.length; ++i) { ys.push(f(xs[i])); } return ys } }
09:54:49 <kadaver> hmm
09:54:54 <mauke> teehee
09:54:55 <kadaver> that is O(n) ?
09:54:58 <chessguy_work> @type let foobar = do { a <- lift [1,2,3]; b <- lift [4,5,6]; putStrLn $ show a; return (a+b); } in foobar
09:54:59 <lambdabot>     Couldn't match expected type `t []' against inferred type `IO'
09:55:00 <lambdabot>       Expected type: t [] t1
09:55:00 <lambdabot>       Inferred type: IO ()
09:56:47 <nlogax> zachk: yes.. i had seen things like that before, but didn't understand the implication :)
09:56:49 <chessguy_work> @hoogle ListT
09:56:50 <lambdabot> Control.Monad.List newtype ListT m a
09:56:50 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT m a
09:56:50 <lambdabot> Language.Haskell.TH ListT :: Type
10:02:50 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3253#a3253 <- how can that be bettered? i do the (++) on very big stuff, not good.
10:03:17 <c_wraith> kadaver: why do you think ++ is inefficient in haskell?
10:03:27 <gwern> c_wraith: because it is
10:03:31 <c_wraith> Have you actually measured it?
10:03:34 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3254 I convert numbers like 256 into '256th'; is there any base lib for this or shorter way of writing it?
10:03:42 <gwern> c_wraith: if ++ wasn't slow we wouldn't have dlists...
10:03:45 <Cale> xs ++ ys  necessarily takes O(length xs) time.
10:04:07 <Cale> There's no way to make it any faster on lists, but other representations support faster concatenation.
10:04:17 <Cale> I kind of think the DList library is silly :)
10:04:20 <kadaver> foldr (++) is better than foldl (++)
10:04:40 <mauke> kadaver: I'd map over the words, then intercalate
10:04:42 <kadaver> so cons and reverse instead?
10:05:04 <c_wraith> I really am baffled how ++ can be worse than O(1) in a lazy language.
10:05:16 <Cale> c_wraith: Hm?
10:05:25 <Cale> c_wraith: Well, it has to make a new list.
10:05:33 <mauke> c_wraith: we're including the time to look at the results
10:05:36 <Igloo> c_wraith: Well, all functions are O(1) is you don't demand the result
10:05:42 <Igloo> but that's not very useful
10:05:47 <c_wraith> But looking at the result is necessarily O(n) anyway
10:06:14 <mauke> yes. we're trying to avoid O(n^2)
10:06:20 <Cale> Well, okay, xs ++ ys is O(min(length xs, k)) where k is the number of elements of the resulting list that you demand.
10:06:27 <MiniCow> I'm looking for a function "[a] -> [b] -> [(a,b)]", but doesn't zip, rather it produces every possible combination from [a] and [b]. Any ideas? (Hoogle failed for me)
10:06:29 <kadaver> @type intercalate
10:06:31 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:06:37 <mauke> MiniCow: liftM2 (,)
10:06:38 <vixey> MiniCow: liftA2 (,)
10:06:54 <MiniCow> Ta
10:07:00 <mauke> kadaver: or even intersperse
10:07:18 <Cale> So if you only want to reduce xs ++ ys to WHNF, that's constant time.
10:08:10 <Cale> (It takes only one reduction step in any case)
10:08:20 <kadaver> thanks!
10:08:33 <kadaver> made hgue difference,program terminated immediately vs seemingly running forever
10:08:42 <kadaver> translating an 80kb file
10:11:34 <kadaver> WHNF=?
10:11:53 <diegoeche> kadaver: weak head normal form
10:12:01 <bavardage> what are the conventions for naming haskell source files
10:12:08 <bavardage> should they start with capitals?
10:12:12 <bavardage> are there any conventions!?
10:12:34 <kadaver> what does lift do really?
10:12:50 <c_wraith> kadaver: there are several different functions with lift in the name.  Some do very different things from others.
10:12:55 <jmcarthur_work> :t lift
10:12:56 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:12:57 <jmcarthur_work> :t liftA
10:12:58 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
10:13:02 <c_wraith> Are you asking about liftM in particular?
10:13:12 <jmcarthur_work> liftA and liftM are the same as fmap
10:13:44 <jmcarthur_work> lift transforms a monadic expression to a higher level in a monad transformer stack
10:14:26 <zachk> here is a little secret: get the latest release of ghc to make installing cabal-install alot easier
10:14:29 <jmcarthur_work> liftA2, liftA3, liftM2, liftM3, etc. are generalizations of fmap for functions of more than one argument
10:14:51 <zachk> does the f in fmap stand for fun? cause i find it fun to use :-/
10:14:57 <jmcarthur_work> functor, i think
10:16:20 <BMeph> gwern: Is there some reason why you don't just use a `case (mod n 10) of 1 -> ...; 2 ->` instead of that c function? :)
10:18:28 <gwern> BMeph: hm. I'm not sure
10:18:32 <gwern> > mod 55 10
10:18:34 <lambdabot>   5
10:21:07 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3214#a3256 <-- I'm a little confused by 'clozeify' - I don't follow why it returns a list of functions, and not a list of Strings
10:22:01 <gwern> I mean, the input is there in the typesig - I have some [Maybe String], I run this big complicated lambda over them, and I should get back a [String]
10:22:36 <bavardage> can I specify a set-size list?
10:22:43 <bavardage> so something that I can treat as a list
10:22:49 <bavardage> but has only 7 elements
10:22:54 <gwern> a tuple
10:22:54 <bavardage> or should I just enforce this in my code
10:23:01 <bavardage> can I treat tuples like lists?
10:23:05 <bavardage> with pattern matching and such
10:23:09 <gwern> yeah
10:23:10 <vixey> bavardage: sort of
10:23:22 <bavardage> so I can do (x:xs) kinda stuff?
10:23:25 <bavardage> and elem
10:23:25 <mauke> gwern: map (\a -> (\b c d e ...)) xs
10:23:31 <vixey> bavardage: no
10:23:34 <bavardage> hmm
10:23:59 <bavardage> I'll just enforce it in code then..
10:24:00 <bavardage> ty
10:24:14 <gwern> mauke: hm. interesting
10:24:28 <gwern> bavardage: might also want to look into data.sequence if you're dealing with strict/finite lists
10:24:35 <bavardage> oh kk
10:26:22 <gwern> mauke: you meant 'foo xs = map (\a -> (\b c d e...) a) xs' :) you dropped the 'a'
10:26:51 <mauke> no, I didn't
10:27:15 <lilac> bavardage: you can pattern match on tuples, but you must pattern match on the /whole/ tuple, not just the start
10:27:16 <gwern> wait, evne that type sig is still wrong
10:27:22 <bavardage> k
10:27:24 <Saizan_> the 'a' is already in scope in the body of the inner lambda
10:27:35 <noteventime> hullo
10:27:58 <mauke> gwern: you know I just rewrote your code to make the type signature more obvious, right?
10:28:15 <mauke> I'm not telling you to use this instead
10:28:41 <gwern> -_- no I didn't realize that
10:28:59 <mauke> (\x y -> B) is the same as (\x -> \y -> B)
10:29:20 <mauke> you gave map a function of four arguments
10:29:26 <mauke> map only calls it with one
10:29:39 <mauke> er, five
10:30:24 <mauke> so the result is a list of functions of four arguments (b, c, d, e); 'a' is bound to each element of the input list in turn
10:30:41 <lilac> "What came after Jefferson?\tFranklin"
10:31:10 <gwern> oh, I see, it should be '(\(a, b, c, d, e) ->'
10:31:13 <lilac> doesn't look like correct output
10:31:25 <gwern> since pair is '(Maybe String, Maybe String, Maybe String, Maybe Int)';
10:31:33 <gwern> it's a list of 5-tuples
10:31:46 <gwern> lilac: what's wrong with it?
10:32:20 <lilac> isn't it supposed to say "What came after Jefferson?\tAdams"?
10:32:21 <gwern> lilac: the output there was just part of the design process; I haven't actually run anything yet
10:32:38 <gwern> probably
10:32:39 <lilac> ah ok then :)
10:32:58 <bavardage> can you make typeclasses inherit from show too?
10:33:23 <gwern> you could probably put a constraint on it, and default to show instances?
10:33:37 <noteventime> Is it always possible to define a type class over a higher order type as a typeclass over two types with a functional dependency (at least if you enable flexible instances). Sorry if I'm using the terminology wrongly, still somewhat new to this...
10:34:00 <bavardage> gwern: but I can't define a show function for them?
10:36:05 <gwern> dunno
10:38:21 <Saizan_> bavardage: you can have Show be a superclass of your typeclass
10:38:33 <bavardage> Saizan_: that sounds like what I want
10:38:36 <Saizan_> bavardage: like class Show a => Foo a where ..
10:38:40 <bavardage> and I can then define a default show method too?
10:38:45 <Saizan_> no.
10:38:51 <bavardage> hmm
10:39:03 <bavardage> I'll make it a superclass though
10:39:30 <Saizan_> you can't define defaults for superclasses in subclasses currently, that's a often wanted feature though
10:39:56 <BMeph> gwern: Also, as another quibble, mzero is "" in List. return () would just be [()]. :)
10:39:59 <slava> did anyone see harrop's benchmark?
10:40:36 <noteventime> For example, any reason why "class Monad m" (m :: * -> *) couldn't be class "class Monad m a | m -> a"
10:40:40 <gwern> BMeph: bah humbug
10:40:55 <Saizan_> noteventime: with m :: *  in the latter?
10:41:18 <gwern> slava: the one he was asking whether there was any haskell version?
10:41:23 <BMeph> slava: jdh has a benchmark? Is it sponsored by Trolltech, perhaps? ;)
10:41:39 <slava> http://flyingfrogblog.blogspot.com/2009/04/f-vs-ocaml-vs-haskell-hash-table.html
10:41:42 <noteventime> Saizan_: Not necesserilly
10:41:50 <vixey> oh hi slava
10:41:53 <noteventime> Saizan_: instance Monad [a] a where ...
10:41:57 <noteventime> e.t.c.
10:41:59 <vixey> your talk about factor was pretty cool
10:41:59 <noteventime> err
10:42:04 <noteventime> Saizan_: so yes *
10:42:06 <Saizan_> noteventime: m :: * there
10:42:08 <Saizan_> ok
10:42:20 <noteventime> Saizan_: A little mind slip :) sorry
10:42:36 <Saizan_> noteventime: well, for the Monad class you actually need two argument types for (>>=)
10:43:27 <noteventime> Saizan_: Ahh, right
10:43:52 <noteventime> Thanks :)
10:44:57 <noteventime> Saizan_: But for something like a vector space class it would make sense, wouldn't it?
10:47:28 <boegel> when compiling using -fvia-C, is running into a Segmentation fault common?
10:47:41 <Baughn> No.
10:48:30 <boegel> Baughn: hmmk... is there anything I can do to figure out what might be going wrong? I'm pushing the binary through gdb as we speak, but I suspect that won't tell me much
10:48:42 <boegel> Baughn: would GHC be to blame for something like this, or rather GCC?
10:48:52 <Baughn> boegel: What gcc version are you using?
10:49:04 <boegel> ok, some more details: Program received signal EXC_BAD_ACCESS, Could not access memory.
10:49:06 <Baughn> boegel: gcc does have a lot of history of compilation errors, so..
10:49:18 <boegel> Baughn: gcc version 4.0.1 (Apple Inc. build 5490)
10:49:34 <Baughn> boegel: I would suggest upgrading to 4.2. If it still happens,it's probably gcc.
10:49:39 <Baughn> boegel: Er. Probably ghc.
10:49:44 <bavardage> how would I make a loop data structure?
10:49:49 <boegel> I have a gcc-4.2 too though, but I'm unsure how to tell GHC to use it?
10:49:53 <pumpkin> > repeat 5
10:49:54 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
10:49:55 <bavardage> is this possible even...
10:49:58 <pumpkin> bavardage: that's one
10:50:06 <bavardage> pumpkin: noop, like a linked list
10:50:09 <bavardage> so I have 10 items
10:50:11 <jmcarthur_work> that is a linked list
10:50:13 <Baughn> boegel: Put it in the PATH?
10:50:13 <boegel> pumpkin: that's not a data structure?
10:50:14 <pumpkin> > cycle [1..10]
10:50:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6...
10:50:20 <pumpkin> boegel: looks like one to me
10:50:22 <bavardage> each of which has a next
10:50:27 <boegel> Baughn: how can I tell which GCC GHC is using?
10:50:32 <BCoppens> boegel: in what universe aren't lists data structures
10:50:34 <pumpkin> bavardage: that's what I gave you
10:50:49 <Baughn> boegel: Run ghc with -v
10:50:52 <bavardage> hmm
10:50:54 <boegel> BCoppens: you could argue it's a function application given you an infinite list :)
10:50:57 <bavardage> maybe I'm still thinking imperative
10:51:03 <jmcarthur_work> you are :)
10:51:05 <bavardage> I want to make a game board
10:51:17 <bavardage> so it has 14 spaces
10:51:18 <boegel> bavardage: you don't need loops in haskell, only recursion (I think)
10:51:26 <bavardage> but you go around the board in a loop
10:51:26 <Baughn> bavardage: Define "loop", please
10:51:32 <Cale> bavardage: However, cyclic data structures look identical to infinite data structures, so if you want to manipulate them a lot, you should really represent the graph arcs explicitly
10:51:33 <pumpkin> :t loop
10:51:34 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
10:51:37 <bavardage> http://en.wikipedia.org/wiki/Mancala <-- attempting to make this
10:51:38 <Baughn> boegel: He /probably/ means tying the knot
10:51:38 <jmcarthur_work> boegel, you don't need recursion in haskell, only combinators ;)
10:51:55 <Cale> bavardage: I would recommend  Map Vertex (Set Vertex)  (or some minor variation on that) as a graph data structure
10:51:56 <bavardage> it's a sowing game
10:51:57 <jmcarthur_work> (of course, you have to make combinators sometimes)
10:52:08 <bavardage> so you pick up a handful of counters and plonk them around the board
10:52:09 <boegel> jmcarthur_work: ok... I still consider myself a newbie with Haskell, so I can't really argue with you on this ;-)
10:52:18 <pumpkin> only argue wit hme :P
10:52:21 <bavardage> so each slot has a logical 'next' slot
10:52:28 <pumpkin> bavardage: that's what I gave you :P
10:52:35 <jmcarthur_work> boegel, it's mostly stylistic, but my personal preference is to avoid explicit recursion
10:52:39 <bavardage> pumpkin: no, I don't think so
10:52:53 <pumpkin> @src []
10:52:54 <lambdabot> data [] a = [] | a : [a]
10:52:59 <boegel> Baughn: running ghc with -v doesn't show me anything about which gcc it's using, at least not at first sight
10:53:05 <pumpkin> bavardage: looks like a linked list to me
10:53:05 <Cale> bavardage: In the case of mancala, unless you want to play on many different variations of the board, you're probably better off just using a finite list or array.
10:53:17 <bavardage> Cale: yeah I was trying to make it general
10:53:19 <Baughn> boegel: Assuming you use -fvia-c, of course
10:53:29 <bavardage> but yeah, a finite list is probably better...
10:53:36 <lament> if you're trying to make it general, don't forget there're 4-row mancala games!
10:53:39 <bavardage> so the board is just of type [Int]?
10:53:53 <bavardage> lament: and you don't just progress around the board in a certain order?!
10:53:54 <bavardage> dammit :P
10:54:23 <bavardage> bleh food
10:54:27 <seliopou> wait a second... Haskell... mancala
10:54:28 <pumpkin> bavardage: wait!
10:54:28 <bavardage> I'll pester ye later
10:54:42 <michaelcdever> does anyone else have problems building gtk2hs against ghc 6.10
10:54:50 <pumpkin> http://www.youtube.com/watch?v=X4-212uMgy8 and associated videos will show you why what I gave you is an actual loopy linked list :)
10:55:18 <seliopou> bavardage, did you take cs173?
10:55:26 <boegel> Baughn: of course, silly me :) thanks
10:55:52 <boegel> seliopou: homework? :)
10:56:43 <seliopou> implementing AB pruning for mancala in Haskell was a homework assignment for cs173, a course I TA'd
10:57:24 <boegel> hmm, gcc-4.2 is a binary, and is in my path (it's in /usr/bin), so simply adding it to my PATH won't make ghc use it...
10:57:24 <seliopou> thing is, it's a fall course, which makes this even more confusing
10:57:43 <boegel> seliopou: I see
10:58:26 <michaelcdever> how do i figure out the path to my ghc install? i built it from source
10:58:54 <Baughn> michaelcdever: It'll be /usr/local, if you don't set it explicitly
10:59:00 <jeffersonheard> michaelcdever: are you using 0.10.x?
10:59:15 <michaelcdever> jeffersonheard: yeah i am
10:59:20 <boegel> michaelcdever: where ghc
10:59:24 <seliopou> michaelcdever, vim `which ghc`
10:59:28 <jeffersonheard> hrm...  no, not except on MacOS X
10:59:34 <michaelcdever> it wont build the gtk module
10:59:43 <michaelcdever> and it doesnt present any errors
10:59:49 <jeffersonheard> that's odd
10:59:54 <jeffersonheard> haven't seen that particular failure mode
11:00:02 <jeffersonheard> what platform are you building on?
11:00:03 <boegel> does anyone know of a way of explicitely specifying which GCC binary GHC should use?
11:00:31 <Igloo> -pgmc
11:01:50 <michaelcdever> jeffersonheard: ubuntu 8.04
11:02:20 <boegel> Igloo: thanks
11:02:33 <michaelcdever> i built it exactly the same as i have done before earlier... that didnt work (with ghc6.8) so i build 6.10 and tried building gtk2hs againt that
11:02:44 <michaelcdever> now it doesnt give any sort of an error
11:02:52 <boegel> Igloo: but I figured that changing the symlink /usr/bin/gcc to /usr/bin/gcc-4.2 instead of /usr/bin/gcc-4.0 would be better in the end...
11:02:56 <michaelcdever> but wont build the gtk module
11:04:39 <michaelcdever> i just tried explicitly pointing it at the 6.10 install... that doesnt solve anything
11:04:42 <michaelcdever> grrrrr
11:04:48 <jeffersonheard> and you have libgtk2.0-dev and libglib1.2-dev installed...
11:04:59 <michaelcdever> libglib2.0
11:05:21 <Baughn> boegel: Not really. You're on OS X; all sorts of things break if you alter anything in /usr.
11:05:26 <boegel> hmm, simply changing the symlink doesn't seem the right way to go...
11:05:34 <jeffersonheard> ya, sorry
11:05:35 <boegel> Baughn: yeah, I noticed that
11:05:47 <boegel> Prologue junk?: 	.globl ___stginit_Data_p
11:05:47 <boegel> ___stginit_Data_p:
11:05:47 <boegel> 	mflr r3
11:05:48 <Baughn> boegel: It's better to install a new gcc in /opt, or.. ghc uses whatever gcc it compiled against, and then it /does/ use the path.
11:05:49 <boegel> :-/
11:05:55 <michaelcdever> yeah i do
11:06:07 <boegel> Baughn: I see
11:06:08 <Baughn> boegel: What ghc version are you on, anyway?
11:06:11 <michaelcdever> hmmmm
11:06:13 <jeffersonheard> blown away the directory, re-untarred it, and re ./configured it, and everything?
11:06:15 <boegel> Baughn: 6.10.1
11:06:47 <jeffersonheard> I've got a configured gtk2hs build made up already on my machine.  i fyou're running 64-bit ubuntu, it ought to work
11:06:56 <jeffersonheard> I could just make it available to you for download
11:07:00 <Baughn> boegel: Hmm. I have no idea whether it'll help, but there are some (unrelated, those I know of) bugs in 10.1 that have since been fixed. I'm sort of standardizing on 6.11 until 6.10.2 is out. ^^;
11:07:04 <jeffersonheard> you'll have to do a make install still
11:07:05 <michaelcdever> lol silly me.... i didnt actually have libgtk2.0 installed... hmmm
11:07:06 * Baughn goes poof
11:07:14 <jeffersonheard> -dev
11:07:23 <boegel> Baughn: hmmk, thanks for the info
11:07:23 <michaelcdever> yeah -dev
11:07:25 <yrlnry> I learned a while back that Curry-Howard does not apply to Haskell so, for example, one can define a function of type (a -> a) -> a.  Is there some analogous theorem that correctly says what Haskell types are inhabited by non-bottom values?
11:07:55 <vininim> I still wonder if 6.10.2 is real or not, because it could be a meta self-referential april's fools.
11:07:59 <michaelcdever> i could have sworn i installed it, gtkhs used to complain if you didnt have a gtk lib installed
11:08:23 <michaelcdever> thanks anyway jefferson, hope this fixes it
11:08:39 <bos> @seen augustss
11:08:40 <lambdabot> I saw augustss leaving #haskell 10h 52m 34s ago, and .
11:10:18 <boegel> vininim: which is kind of a lame april fools...
11:10:33 <michaelcdever> nope, now im getting this: unknown package: cairo-0.10.0
11:10:38 <michaelcdever> anyone have any ideas?
11:14:03 <michaelcdever> and i have libcairo2-dev installed
11:14:04 <Nafai> How do I do multi-line strings in my source?
11:16:53 <Cale> Nafai: I usually use a list with unlines, but there are string gaps as well. Any whitespace occurring between two backslashes is ignored, and so you can break a long string across multiple lines.
11:17:16 <Cale> (but of course, the newlines are ignored, so you'd have to include the \n characters yourself.)
11:18:26 <Nafai> Thanks
11:20:57 <boegel> @paste
11:20:58 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:21:39 <b_jonas> and, as I've learnt, "\@" is the empty string
11:21:51 <b_jonas> > "a\@b"
11:21:52 <lambdabot>   <no location info>:
11:21:52 <lambdabot>      lexical error in string/character literal at chara...
11:22:01 <b_jonas> maybe it was "\&" ?
11:22:04 <b_jonas> > "a\&b"
11:22:04 <lambdabot>   "ab"
11:22:07 <b_jonas> yeah, it was
11:22:08 <b_jonas> sorry
11:22:16 <boegel> Igloo: neither changing the symlink nor using -pgmc works, I'm running into something like http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3259#a3260
11:23:36 <boegel> Igloo: should I also specify additional libraries that changed or something?
11:24:15 <Igloo> boegel: Does it work without "-optc-fast -optc-mcpu=7450"?
11:24:55 <Igloo> boegel: Oh, and you might need -pgma. You can add -v to see what's actually being run
11:27:01 <boegel> Igloo: k, thx
11:27:14 <Eduard_Munteanu> Hi. I want to write a script in Haskell and run it directly. I've seen this working with Hugs, how can I do it with GHC?
11:27:15 <pumpkin> yay harrop trolling again :) http://www.reddit.com/r/programming/comments/89poq/f_vs_ocaml_vs_haskell_hash_table_performance/
11:27:31 <Eduard_Munteanu> I just don't want object files and all that lying around in the current directory.
11:27:35 <mauke> Eduard_Munteanu: runghc
11:27:46 <Eduard_Munteanu> mauke, thanks.
11:29:14 <nomeata> Hi. Is Colin Paul Adams here?
11:29:52 <nomeata> Or does he hang around here sometimes?
11:30:28 <nomeata> Or does someone else know the game-tree package?
11:31:10 <gwern> Eduard_Munteanu: technically, 'runhaskell' should work whether you have hugs or ghc
11:33:04 <Baughn> Eduard_Munteanu: #!/usr/bin/env runhaskell
11:33:22 <Baughn> Unless it's ghc-specific, in which case you might want to avoid the annoyance
11:33:45 <Baughn> Eduard_Munteanu: And you should almost always use #!/usr/bin/env for portable scripts
11:34:15 <Eduard_Munteanu> gwern, Baughn, thanks.
11:36:11 * FunctorSalad is confused by parsec's decision of who the culprit is with regards to which '<?>' to display :(
11:36:21 <FunctorSalad> (which <?> message, that is)
11:36:23 <mmorrow> Baughn: better do #!/usr/bin/env env  to be double portable
11:36:44 <Deewiant> #!fix env
11:36:44 <FunctorSalad> (I think I did cover everything with try)
11:36:58 <Baughn> mmorrow: Quite. /usr/bin/env should work on every platform ghc actually runs on, at least.
11:37:03 <Baughn> I don't think we care about the rest.
11:37:11 <mmorrow> not i :)
11:37:23 <wli> I just spray try everywhere.
11:38:02 <Baughn> But I've seen so annoyingly many scripts that assume /usr/local/bin/perl or whatever..
11:38:17 <b_jonas> Baughn: actually no
11:38:18 <FunctorSalad> so did I, but it still seems to commit to one particular branch, at least judging from the <?> message displayed
11:38:31 <b_jonas> I've seen machines where /usr/bin/env doesn't exist, only /bin/env does, and also the converse
11:38:45 <b_jonas> so the simple solution /usr/bin/env does not always work
11:38:48 <Baughn> b_jonas: That run ghc?
11:39:06 <b_jonas> Baughn: linux machines, so I assume you can install ghc on them
11:39:07 <Baughn> I suppose the alternative is to bootstrap from /bin/sh. Do not want.
11:39:33 <b_jonas> Baughn: well, there are more portable magical headers devised for perl and ruby scripts, and they're at least four lines long
11:39:44 <b_jonas> and yes, they use /bin/sh
11:39:55 <b_jonas> but there too you have to be quite careful
11:40:05 <mmorrow> !#/bin/sh -c `which env`
11:40:27 <b_jonas> mmorrow: no way, #! accepts only a single argument after the exe name
11:40:32 <mmorrow> awwww
11:40:44 <Baughn> mmorrow: Also, backquotes are a bash extension
11:40:48 <b_jonas> oh wait, maybe that's no problem
11:40:54 <b_jonas> Baughn: are they? I don't think so
11:41:02 <Baughn> b_jonas: Well, bash isn't the only thing to do them
11:41:06 <Baughn> But the original sh...
11:41:12 <ziman> $(...) is the equivalent bash extension
11:41:20 <Baughn> Much nicer. :P
11:41:26 <ziman> korn shell used `...`, iirc
11:41:32 <mmorrow> hmm, `` works in my /bin/sh
11:41:44 <b_jonas> mmorrow: which sh is that?
11:41:44 <Baughn> As in mine. But wait, that's bash.
11:41:46 <mmorrow> oh n/m
11:41:48 <mmorrow> yeah
11:41:53 <mmorrow> it's bash ..
11:42:05 <Baughn> It works a lot of places, but /not/ all of them
11:42:14 * Baughn compiles csh to check
11:42:19 <mmorrow> [m@monire ~]$ ls -l `which sh`
11:42:19 <mmorrow> lrwxrwxrwx 1 root root 4 2009-03-27 09:19 /bin/sh -> bash
11:42:21 <b_jonas> still even wihtout that I don't think '#!/bin/sh -c`which env`' makes much sense
11:42:21 <mauke> csh is not a sh
11:42:28 <b_jonas> if you run the shell anyway, why would you need env?
11:42:29 * Baughn does it anyway
11:42:33 <pumpkin> it works in csh
11:42:34 <b_jonas> oh, compilation done
11:42:34 <pumpkin> just tried it
11:42:46 <Baughn> b_jonas: Eh, it's to replace env
11:42:55 <b_jonas> Baughn: but this would just run env without arguments
11:42:56 <Baughn> And csh isn't in portage, I guess. Never mind.
11:43:03 <b_jonas> and if you wanted that you could jsut say #!/bin/sh -c env
11:43:13 <mmorrow> b_jonas: yeah, you'd also need to add an arg for env
11:43:24 <Baughn> b_jonas: Perhaps #!/bin/sh -c`which env`ghc
11:43:29 <mmorrow> !#/bin/sh -c eval "`which env` perl"
11:43:35 <Baughn> ..no, that wouldn't work either
11:43:46 <b_jonas> Baughn: I just checked, you can't put the command in the same arg as -c so no, that doesn't work either
11:43:57 <b_jonas> Baughn: bash does not accept the command that way
11:43:58 <b_jonas> so no
11:44:14 <Baughn> Whoever made up #! has my eternal hatred and anguish. ;_;
11:44:30 <b_jonas> but that wouldn't work either anyway, because then ghc would die at the #! syntax because that's not valid haskell
11:44:34 * Baughn builds ghc 6.10.2 instead of csh. Much nicer.
11:44:44 <b_jonas> so no, there _is_ a reason why those magical headers are long
11:44:48 <b_jonas> really
11:44:57 <Baughn> #! /is/ valid haskell. Sort of.
11:45:03 <Baughn> At least as far as ghc and hugs are concerned
11:45:10 <b_jonas> Baughn: oh, is it?
11:45:17 <Baughn> b_jonas: Special-cased
11:45:22 <b_jonas> I see
11:45:29 <Saizan_> don't you need .lhs for that?
11:45:35 <b_jonas> still this won't work because of the -c thing
11:45:35 <Baughn> Point is, you can stick #!/usr/bin/env runhaskell at the start of a script
11:45:42 <Baughn> Hmm
11:45:45 <Baughn> Saizan_: Oh, maybe you're right
11:45:49 <mmorrow> gah, i can't believe !# only accepts one arg
11:45:54 <Baughn> I suppose that's why Setup.lhs tends to be .lhs
11:45:57 <b_jonas> mmorrow: it really does
11:45:59 * Baughn was wondering
11:46:05 <b_jonas> mmorrow: would you want it to even parse double quotes and stuff?
11:46:11 <mmorrow> b_jonas: oh no, i believe you. i just can't believe it.
11:46:33 <mmorrow> b_jonas: it'd be nice abuse-enabling :)
11:46:52 <paggas> hi, is there an equivalent to make's -j for ghc --make? or, if it's done automatically, can i change the number of concurrent jobs?
11:46:59 <orbitz> Baughn: not wandering?
11:47:01 <mmorrow> paggas: unfortunately no
11:47:11 <Baughn> orbitz: Not this time of year, unfortunately
11:47:16 <vixey> :(( I can't make this work
11:47:16 <pumpkin> everyone wants it
11:47:18 <Baughn> Too much ice. And snow. With ice mixed in.
11:47:19 <mmorrow> paggas: ghc --make doesn't know how to build in par :(
11:47:19 <pumpkin> I'm looking forward to it
11:47:29 <pumpkin> I haz many cores
11:47:41 <paggas> pity... :)
11:48:18 <Baughn> mmorrow: Odd, really. If it's well written (generates dependency graph, /then/ executes it) that should be a fairly small amount of work..
11:48:28 <orbitz> split your project up into more subprojects!
11:48:40 <pumpkin> I think I heard dcoutts saying it was mostly ready for it
11:48:45 <Baughn> orbitz: But running multiple compiles at once tends to mess up cabal..
11:48:51 * BMeph imagines Haskell' using first-class thunks as a distributed processing mechanism...
11:48:56 <b_jonas> in which directory should I decompress the ghc testsuite?
11:49:05 <pumpkin> BMeph: GHC 7! :D
11:49:15 <Baughn> b_jonas: tar tjf testsuite.tar.bz2
11:49:26 <b_jonas> Baughn: but in which directory?
11:49:28 <paggas> given that haskell is so good for parallelism :D :D
11:49:32 <b_jonas> shouldn't it be under the ghc build dir?
11:49:37 <b_jonas> or a subdir of that?
11:49:52 <Saizan_> code.haskell.org/hbuild builds in parallel, but doesn't accept .cabal files yet, if someone feels like helping me to hack on it :)
11:49:53 <pumpkin> didn't the testsuite come with the source distro? it did for me
11:49:59 <Baughn> b_jonas: That's what running that command is for.
11:50:20 <Baughn> b_jonas: It'll print the directory structure in the tarball, which chances are will start with "ghc-6.10.2/" or some such. Then you know.
11:50:31 <Saizan_> the main problem is that ghc has an huge startup overhead though
11:50:52 <b_jonas> Baughn: in ghc-6.10.1 it did that, but the ghc-6.10.2 testsuite is not in it
11:50:56 <b_jonas> Baughn: really
11:50:57 <mmorrow> Baughn: yeah, i think it wouldn't be that hard to fix --make (fix := build in par ;). the only potentially painful part i think would be to figure out where in ghc to get all the info you need.
11:51:35 <b_jonas> Baughn: it's in a directory testsuite-6.10.2 instead of ghc-6.10.2/testsuite
11:51:52 <mmorrow> Saizan_: i've got your repo, and have been meaning to hack around with it :)
11:52:24 <Baughn> b_jonas: Umh. I'm not sure what to do with that, then.
11:52:40 <b_jonas> :-(
11:52:40 <Baughn> b_jonas: Perhaps it's supposed to be started separately, after the install..
11:52:49 <Baughn> Unpack it, check for a readme?
11:52:54 <b_jonas> I did
11:52:57 <michaelcdever> anyone know how to solve this error with gtk2hs? unknown package: cairo-0.10.0
11:53:00 <b_jonas> the readme points to http://hackage.haskell.org/trac/ghc/wiki/Building/RunningTests
11:53:03 <Baughn> michaelcdever: Install gtk2hs
11:53:09 <Baughn> michaelcdever: Oh. Er..
11:53:19 <Baughn> michaelcdever: Are you, currently, trying to build gtk2hs?
11:53:33 <michaelcdever> yeah building it
11:53:33 <michaelcdever> 1
11:54:37 <boegel> Igloo: any idea what the cause might be for these messages during linking: Undefined symbols:  "___DISCARD__", referenced from: <long list like "___stginit_KMeans in KMeans.o">
11:55:00 <Baughn> michaelcdever: Do you have the C cairo development package installed?
11:55:03 <Saizan_> mmorrow: let me know how that goes if you start :)
11:55:13 <mmorrow> Saizan_: for sure.
11:55:24 <michaelcdever> i dunno, i have libcario installed
11:55:31 <Baughn> But not the -dev package?
11:55:32 <b_jonas> I've moved the testsuite-6.10.2 dir under ghc-6.10.2 and I think it works that way
11:55:33 <Igloo> boegel: Are you still passing extra -optc flags?
11:55:34 <Baughn> That'd be it, then
11:55:35 <michaelcdever> *libcairo2-dev
11:55:36 <b_jonas> still, this is strange
11:55:38 <michaelcdever> aswell
11:56:52 <michaelcdever> yeah libcairo2-dev is installed :\
11:57:11 <boegel> Igloo: no
11:57:22 <boegel> Igloo: only --make -O3 -fvia-C
11:57:34 <Igloo> boegel: Sounds like a bug then
11:57:40 <boegel> Igloo: oh joy
11:59:06 <michaelcdever> and if you do --disable-cairo, it fails again, because it can't find cairo
11:59:15 <michaelcdever> theres no easy way of doing anything is there?
11:59:19 <michaelcdever> lol
12:00:21 <boegel> Igloo: how should I proceed?
12:00:30 <boegel> Igloo: where can I submit a bug?
12:01:10 <Igloo> boegel: http://hackage.haskell.org/trac/ghc/wiki/ReportABug
12:06:33 <boegel> Igloo: ok, thanks
12:06:55 <michaelcdever> right well, im guessing i wont be able to get this to install
12:07:00 <michaelcdever> 2 hours wasted
12:07:26 <Nafai> Is there a function to convert a string "01011001" to a binary number?
12:07:31 <bavardage> o/
12:07:33 <Nafai> (well, an int)
12:07:38 <Nafai> Int
12:07:42 <Baughn> @type parseInt
12:07:43 <lambdabot> Not in scope: `parseInt'
12:07:50 <Actium> my friend thinks the strictness and low-levelness of ISO C90 makes him cool =(
12:08:16 <boegel> Actium: kick him in the nuts
12:08:20 <Baughn> @hoogle readint
12:08:20 <lambdabot> Numeric readInt :: Num a => a -> Char -> Bool -> Char -> Int -> ReadS a
12:08:20 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:08:21 <lambdabot> Data.ByteString.Lazy.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
12:08:29 <Baughn> Nafai: Ah. There we go.. I'm pretty sure.
12:08:31 <Nafai> There's readDec and readHex, but not readBin
12:08:42 <Nafai> Yeah, I'm trying to write my own using readInt :)
12:08:57 <Nafai> It's getting ugly
12:09:45 <Nafai> http://gist.github.com/89906
12:09:55 <mauke> :t readInt 2 (`elem` "01") digitToInt
12:09:56 <lambdabot> forall t. (Num t) => String -> [(t, String)]
12:09:57 <Nafai> There it get the individual numbers, but them as a full byte :)
12:11:01 <mauke> > readInt 2 (`elem` "01") digitToInt "0101" :: [(Int,String)]
12:11:02 <lambdabot>   [(5,"")]
12:11:29 <boegel> Igloo: googling tells me this issue also occured when people started to switch from gcc-3.3 to gcc-4.0 on OS X
12:11:36 <Baughn> > readInt 2 (const True) digitToInt "0101" :: [(Int,String)]
12:11:36 * Nafai tries
12:11:37 <lambdabot>   [(5,"")]
12:11:41 <Baughn> > readInt 2 (const True) digitToInt "0121" :: [(Int,String)]
12:11:43 <lambdabot>   [(9,"")]
12:11:47 * Baughn blinks
12:12:13 <Baughn> ..I see what I did there.
12:12:32 <Nafai> YOu guys make it look too easy :)
12:12:37 * Baughn wonders if mixed-base representation is useful
12:15:22 <Nafai> @hoogle digitToInt
12:15:23 <lambdabot> Data.Char digitToInt :: Char -> Int
12:15:32 <Baughn> > digitToInt 'f'
12:15:34 <lambdabot>   15
12:15:37 <Baughn> > digitToInt 'z'
12:15:37 <lambdabot>   * Exception: Char.digitToInt: not a digit 'z'
12:15:52 <Baughn> > digitToInt 'g' -- Come, now
12:15:53 <lambdabot>   * Exception: Char.digitToInt: not a digit 'g'
12:16:50 <mauke> preflex: calc 36'zig.zag
12:16:50 <preflex>  46024.98028120714
12:17:05 <b_jonas> Baughn: no, but you have to work with it because it would be hard to convince people not to use years and months and weeks and days and hours and minutes
12:17:24 <Baughn> b_jonas: Ah. Well. Yes.
12:17:52 <b_jonas> also feet and inches and stuff
12:18:05 <bavardage> how would I apply a function to a specific element in a list
12:18:08 <bavardage> and ONLY that element
12:18:20 <mauke> fetch it with !!
12:18:32 <Actium> :t !!
12:18:33 <bavardage> (but return the whole list)
12:18:33 <lambdabot> parse error on input `!!'
12:18:38 <bavardage> :t (!!)
12:18:40 <lambdabot> forall a. [a] -> Int -> a
12:18:43 <Actium> ah. L)
12:18:58 <bavardage> see I want something like [a] -> Int -> (a->a) -> [a]
12:19:10 <bavardage> bleh roll my own
12:19:21 <Baughn> bavardage: That would require copying half the list, on average. Are you /sure/ you want that?
12:19:41 <bavardage> Baughn: the list is only 14 elements long
12:19:45 <Baughn> bavardage: Data.Sequence, Data.Map, etc. have update functions. List doesn't, since you normally don't want it.
12:19:50 <bavardage> right
12:19:54 <bavardage> I'll look at those
12:19:57 <bavardage> they complicated :P?
12:20:05 <Baughn> Data.Sequence is the most obvious replacement, here
12:20:05 <Baughn> And no
12:20:28 <Baughn> bavardage: Ah, but you do need to know about Foldable and such. Read the typeclassopedia? ;)
12:20:57 <Baughn> bavardage: (Or just read the Foldable documentation. You can use the functions without understanding them. Traversable is something else again, if handier..)
12:21:04 <bavardage> right...
12:21:18 <bavardage> so Data.Sequence and foldable?
12:21:36 <Baughn> Data.Sequence, Foldable and Traversable
12:21:45 <b_jonas> don't you want to use just an IOArray?
12:22:20 <Baughn> b_jonas: It's also a functor, a monad, a monadplus, typeable, monoid... eh, just read the instance list. :P
12:22:25 <Baughn> *bavardage
12:24:22 <Baughn> bavardage: The point is, Data.Sequence appears to be missing a lots of functions, that are actually provided via those instances.
12:24:45 <bavardage> Baughn: right.. where do I find documentation on this?
12:24:51 <bavardage> as in I have http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html#v%3Aadjust this
12:25:00 <mauke> btw, for a list I'd use splitAt
12:25:44 <gwern> 'The language looks like Japanese emoticons run amuck. If and when I reach the \(^.^)/ operator I'm calling it a day.'
12:25:44 <Baughn> bavardage: http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Sequence.html#t%3ASeq
12:25:50 <Baughn> bavardage: Just.. click on the instance names.
12:25:55 <bavardage> oh ty
12:26:14 <Baughn> @let a ^_^ b = a ^ b + b ^ a
12:26:15 <lambdabot>   Parse error in pattern:
12:26:18 <Baughn> ..drat
12:26:39 <Baughn> @rember gwern 'The language looks like Japanese emoticons run amuck. If and when I reach the \(^.^)/ operator, I'm calling it a day.
12:26:39 <lambdabot> Okay.
12:26:59 <Baughn> @let a ^.^ b = a ^ b + b ^ a
12:27:01 <lambdabot>  Defined.
12:27:49 <b_jonas> so the *.* dos glob is an emoticon as well?
12:28:14 <Baughn> Yes
12:28:21 <Baughn> Star-struck
12:30:45 <lilac> > let a \\ f = f a a; a // b = floor (fromIntegral a / fromIntegral b)  in 1 \\(^.^)// 2 :: Int
12:30:47 <lambdabot>   1
12:31:58 <lilac> > let a \\ f = f a a; a // b = floor (fromIntegral a / fromIntegral b)  in 10 \\(^.^)// 10 :: Int
12:31:59 <lambdabot>   2000000000
12:32:09 * BMeph wonders why it's called `sequence`, when it (theorectically) "runs" in parallel...
12:32:24 <gwern> Baughn: that's not actually me
12:32:28 <gwern> that was a quote
12:32:32 <gwern> hence, the quotemarks
12:34:29 <lilac> seq a b = unsafePerformIO $ do v <- newEmptyMVar; forkIO (evaluate a >> putMVar v ()); r <- evaluate b; takeMVar v; return r
12:34:29 <Baughn> gwern: Well, I got one quote into the quote at least
12:34:49 <gwern> -_-
12:34:54 <gwern> maybe you should just remove it
12:34:56 <vixey> hehe
12:35:09 <Baughn> lilac: I may be forced to spit you and grill you over an open fire. -_-
12:35:16 <Baughn> gwern: Nah
12:35:31 <kadaver> can you fold with a 3rd param that is updatable?
12:35:38 <kadaver> or i have to write tht fucntion myself?
12:35:42 <Baughn> gwern: It's entirely too good to be removed over something silly such as being a misquote
12:35:44 <lilac> Baughn: how do you know for sure that's /not/ the implementation GHC uses? ;-)
12:35:57 <lilac> (ok, silly question)
12:36:09 <Baughn> lilac: I'd notice the multithreading, for one
12:36:14 <Baughn> lilac: For another, I've read the code. :P
12:36:28 <Baughn> And while I didn't understand a lot, I think I'd notice something like that
12:36:39 <Baughn> (For a third, parallel is an add-on library)
12:36:40 <lilac> :-D
12:37:13 <Baughn> But maybe it's implemented by forking into an alternate universe, like Higurashi?
12:37:38 <lilac> it's implemented with unsafeCollapseWaveFunction
12:38:00 <lilac> the forking isn't the hard part :)
12:38:05 <Baughn> Which is itself implemented by unsafeDecohereAndFoolPhysicists
12:38:16 <gwern> Baughn: why not just google it and attribute the real author?
12:38:22 <lilac> unsafeActAsAParticleWhenThey'reNotLooking
12:38:32 <Baughn> gwern: I can't handle the truth.
12:38:50 <gwern> so I guess you don't want the truth
12:38:59 <Baughn> I CAN'T HANDLE THE TRUTH
12:39:02 <b_jonas> lol
12:39:08 <vixey> bind has the wrong type
12:39:45 <b_jonas> or worse, it could be implemented with forkUniverse and unsafeDestroyUniverse where you have to make sure not to call the latter in all universes forked
12:40:05 <Baughn> b_jonas: Mangled worlds quantum mechanics? ;_;
12:40:15 <Baughn> That's.. the most disturbing explanation I've read yet, actually
12:40:18 <Baughn> And the most complete
12:40:26 * gwern is mildly surprised Baughn has heard of mangled worlds
12:40:54 <Baughn> gwern: It got quite a bit of coverage on OB
12:40:59 <vixey> what's OB?
12:41:03 <BMeph> vixey: The wrong type for what? :)
12:41:07 <gwern> ah
12:41:28 <lilac> b_jonas: i have an efficient implementation of an RSA cracker for that system. but please don't give it a prime...
12:41:31 <vixey> BMeph: in  m >>= f  I'm trying to say that f is getting input smaller than m
12:41:46 <vixey> it's just not fitting together yet though
12:42:08 <Baughn> vixey: overcomingbias.com
12:42:34 <vixey> oh h I have come across that a couple times
12:42:43 <Baughn> gwern: Mangled worlds is still mostly hand-waving, but at least it's got the hand-waving. I've yet to see any other theory even /try/ to explain the born rule.
12:43:10 <gwern> Baughn: it's a profound truth!
12:43:18 <gwern> and if we find the opposite, that's just another profound truth
12:43:19 <lilac> Baughn: born rule?
12:43:21 <Baughn> gwern: It's a pity it had to do it by saying "Oh, the universe is more likely than not to fall apart a second from now"
12:43:48 <Baughn> lilac: Born probability rule of quantum mechanics: That the probability of witnessing an event is proportional to the square of its wavefunction's amplitude
12:43:52 <gwern> Baughn: a lot of good theories have to do that. pace most thermodynamic explanations of the arrow of time
12:44:52 <Baughn> gwern: You read that recent post about thermodynamics not having explainative power backwards in time?
12:45:00 <Baughn> Though I think that was on lesswrong.com
12:45:02 <gwern> Baughn: my personal theory is that the correct interpretation of the born rule will be thermodynamic
12:45:28 <Baughn> gwern: Promoting a statistical rule to.. hmm, I guess the born rule is /also/ statistical. Okay, that might work.
12:45:30 <gwern> we'll find that nothing has a greater or less probability, it's just that large clusters 'look' the same
12:45:43 <sioraiocht> if a functor has a left adjoint, is it always the right adjoint of that functor?
12:45:44 <slava> has anyone figured out why harrops hashtable benchmark runs so slow?
12:46:06 <gwern> (obviously then the ones with 'lesser' probability appear lesser because they simply look different from each other)
12:46:41 <gwern> Baughn: yes, I think I did. not the first time I've read up on thermodynamics, but I need to go read mangled worlds again; might be relevant to my thinking on quantum suicides
12:46:43 <dolio> Is it using Data.Hashtable?
12:46:57 <slava> dolio: yes
12:47:02 <sm> yikes, how do I define a Read instance for a type just so that read "str1" gives Constructor1 ?
12:47:04 <slava> and its an order of magnitude slower than, eg, python
12:47:16 <slava> nobody has offered an explanation, except to use IntMap which was also slower
12:47:22 <Baughn> gwern: If mangled worlds is true, then quantum suicide had /better/ work - the universe would be running the experiment a couple trillion times a second.
12:47:25 <vixey> instance Read Thing where read "str1" = Constructor1
12:47:29 <dolio> slava: Data.Hashtable is well known to be poorly optimized.
12:47:35 <slava> dolio: http://www.reddit.com/r/programming/comments/89poq/f_vs_ocaml_vs_haskell_hash_table_performance/
12:47:37 <dolio> And nobody's worked on it for years, to my knowledge.
12:47:38 <gwern> Baughn: :) yes, you see the relevance
12:47:47 <Baughn> gwern: I'm not convinced it would be possible to tell the difference, though
12:47:48 <slava> dolio: sounds like hashtables should be one of the first things to optimize
12:47:48 <sm> vixey: pretty sure I just tried that and read is not an method of Read
12:48:10 <Baughn> gwern: I mean, personal continuity is basically epiphenomenal
12:48:25 <FunctorSalad> sioraiocht: if F -| U and F -| U2, then Hom(A, U B) ~ Hom(F A, B) ~ Hom (A, U2 B)
12:48:43 <vixey> @src Read
12:48:43 <sm> read' is not a (visible) method of class `Read'. I assume I'm using Read from prelude
12:48:44 <lambdabot> class Read a where
12:48:44 <lambdabot>   readsPrec    :: Int -> ReadS a
12:48:44 <lambdabot>   readList     :: ReadS [a]
12:48:44 <lambdabot>   readPrec     :: ReadPrec a
12:48:44 <lambdabot>   readListPrec :: ReadPrec [a]
12:49:00 <vixey> probably readPrec then
12:49:33 <Baughn> We could use a proper library of imperative data structures. Is there anything like that on hackage now?
12:49:35 <sm> haddock suggests readsPrec, but I don't understand it.. oh well
12:49:56 <sioraiocht> FunctorSalad: thanks
12:49:57 <gwern> Baughn: that's one of the better objections to quantum suicide, that personal identity never hinges on a particular quantum event, thus it's possible that in all univererses 'you' reach a point where all collapses/forks lead to a dead 'you'
12:50:01 <dolio> slava: Has anyone tried with Data.Map? That's the one people actually use.
12:50:15 <FunctorSalad> in particular for A=U2 B you get Hom (U2 B, U B) ~ Hom (U2 B, U2 B); transporting the identities from the left to the right gives you a natural iso from U2 to U
12:50:26 <FunctorSalad> (unless I'm missing something)
12:50:29 <FunctorSalad> @ sioraiocht
12:50:33 <slava> dolio: I don't know, but it looks like the shootout benchmarks which use hashtables roll their own using unsafe*, malloc and so on
12:50:36 <dolio> Since it's a purely functional data structure, instead of consigning your algorithm to running in the IO monad.
12:50:57 <Baughn> gwern: Indeed. Certainly, there's no obvious reason why you couldn't just become a vegetable.
12:51:05 * sioraiocht can't wait until he can stop thinking about category-theoretic notions of programming for a whole week
12:51:16 <FunctorSalad> sioraiocht: sorry I mean form the right to the left ;)
12:52:22 <Baughn> gwern: Having the entire universe overwritten by a stray wave-function fluctuation is something else again..
12:53:33 <FunctorSalad> Baughn: "mangled worlds" (perl)? ;)
12:53:35 <dons> slava: we rarely use (mutable) hash tables. far, far more common and trees (avl, size-balanced) and tries
12:53:50 <slava> but search trees are much slower, dons
12:54:04 <Baughn> FunctorSalad: http://hanson.gmu.edu/mangledworlds.html <-- This. Be prepared for nightmares if you take it at all seriously.
12:54:21 <Baughn> FunctorSalad: (Which you should. There's no obvious reason it can't be correct.)
12:54:40 <gwern> except maybe parsimony
12:54:41 <dons> depends on the situation. i'd be surprised if the patricia trie implemention was slower than a hash function
12:54:52 * sm finds an example
12:54:57 <FunctorSalad> Baughn: hmm I can guess... many-world + unpleasant coincidences?
12:54:58 <dons> but no one's written a fast hashtable
12:55:12 <dons> while they have written fast tries and trees
12:55:13 <Baughn> FunctorSalad: No. Think more.. lovecraftian.
12:55:25 <Baughn> FunctorSalad: Or just read it. It's pretty short.
12:55:29 <b_jonas> I don't care about actual speed, only theoretic one
12:55:45 <Baughn> ..since when does anyone prefer /theoretical/ speed to actual?
12:55:45 <gwern> dons: there's no fast hashtable in edison?
12:55:54 <b_jonas> so I use trees even if they're slow and using just a list would be much faster because in most cases I only have few data
12:55:58 <b_jonas> Baughn: I do
12:55:59 <gwern> or do we want non-functional hashtables?
12:56:01 <b_jonas> I'm a mathematician
12:56:05 <Baughn> gwern: The latter
12:56:17 <Baughn> gwern: Anyway, I have no idea whatsoever how to build a functional one
12:56:27 <gwern> I'm sure okasaki does :)
12:56:28 <Baughn> ..not a /fast/ functional one
12:56:34 <Baughn> Heh. He would. :P
12:56:53 <slava> no such thing as a fast functional map, hashtables are really hard tobeat
12:56:54 <dolio> I don't think his book has hash tables.
12:57:01 <FunctorSalad> Baughn: I'm scared, should I really click it? :o
12:57:05 <Baughn> FunctorSalad: Yes.
12:57:07 <bavardage> PES
12:57:09 <bavardage> *YES
12:57:10 <bavardage> w/e it is
12:57:12 <bavardage> just do it
12:57:18 <dons> gwern: no, edison is a library of purely functional structures
12:57:19 <Baughn> b_jonas: I use a tree even when they're slow, if I won't notice the slowness. Just to get better scaling.
12:57:26 <Baughn> If I would notice it, that's something else again
12:57:41 <dons> slava: right. a good ST-based implementation of hashtables would be useful for some situations
12:57:52 <gwern> dons: yes, hence my followup question as to whether we were really after a non-functional one
12:58:00 <b_jonas> yes, that's what I'm saying
12:58:02 <dons> committing to destructive updates is sometimes ok. making it threadsafe in turn would be an issue though
12:58:07 <Baughn> An ST-based hashtable wouldn't be functional, would it?
12:58:21 <Baughn> Though having a read-mostly functional variant could be useful
12:58:22 <dons> it'd be using memory effects
12:58:45 <vixey> could it have a pure interface?
12:58:59 <vixey> even thought it used ST internally... I don't think so
12:59:11 <dolio> No.
12:59:12 <b_jonas> actually there's also a middle-way: you can make a data structure that doesn't use destructive updates but it still fast only if you don't use it persistently
12:59:13 <Baughn> vixey: A functional interface would imply persistence
12:59:23 <Baughn> Though you might do something like diffarray.. assuming that can be done efficiently at all
12:59:23 <vixey> yeah
12:59:34 <Baughn> More likely, something like uarray
12:59:36 <b_jonas> Baughn: heh
12:59:36 <dolio> You could do something like DiffArray, but those don't seem to be all they're cracked up to be.
12:59:40 <jmcarthur_work> what about DiffArray
12:59:45 <jmcarthur_work> oh, i'm too late
13:00:05 <jmcarthur_work> i have never benchmarked DiffArray
13:00:06 <Baughn> jmcarthur_work: What about it? The point of using a hash-table at all would be speed, so..
13:00:19 <Baughn> It's slow. Beyond slow. Slow as all hell.
13:00:57 <jmcarthur_work> oh... i thought the whole point was to have the speed of mutation but some of the other advantages of a purely functional structure
13:01:10 <Baughn> Yes. Well. :P
13:01:16 <slava> I just don't understand why people make the claim that Haskell is fast. The only benchamrks I've seen either use malloc and unsafe features, or run slowly, or both
13:01:34 <jmcarthur_work> i've never been disappointed with haskell speed
13:01:42 <jmcarthur_work> benchmarks are bull crap
13:01:53 <slava> except when ghc wins, right
13:01:58 <slava> then its worth spamming all over proggit
13:01:59 <jmcarthur_work> no, they are all crap
13:02:06 <b_jonas> I never care about benchmarks others make
13:02:07 <jmcarthur_work> dude calm down
13:02:13 <b_jonas> and I don't write speed-critical programs
13:02:32 <Baughn> slava: It's fast when you end up with an O(n) algorithm instead of an O(n^2) one because writing it is easier
13:03:06 <Baughn> But seriously, speed is not the primary reason to use haskell. Or C, for that matter. Not on modern systems.
13:03:08 <jmcarthur_work> i've done data processing programs in haskell that rival C performance with less work than the C version, but that was just once or twice, so what do i know?
13:03:26 <jmcarthur_work> and yes, it was due to the algorithm
13:03:33 <jmcarthur_work> not to ghc optimizatiosn
13:03:34 <vixey> slava: why do you think haskell is so popular :p
13:03:39 <slava> Baughn: that's the ruby excuse. you can do better
13:03:52 <klirrikassan> is House a serious OS? or is it to slow?
13:03:55 <Baughn> slava: How about "it's easier to parallelize"?
13:03:58 <vixey> House is a toy OS
13:04:40 <Duqicnk> i don't think it does enough things to be slow
13:05:11 <klirrikassan> a toy OS as in a to OS or to OS as in proof of concept?
13:05:18 <vixey> proof of concept
13:05:33 <Baughn> klirrikassan: Both, but primarily concept
13:05:34 <paggas> how can i have two modules in one source file with ghc?
13:05:42 <Baughn> paggas: Use two source files
13:05:42 <gwern> can't really
13:05:54 <jmcarthur_work> paggas, unfortunately you can't
13:06:06 <paggas> mmm
13:06:13 <b_jonas> you can't even if you're not using --make ?
13:06:20 <Baughn> paggas: You could always define your functions in one file, then re-export them in two other, otherwise empty ones
13:06:43 <Baughn> b_jonas: Deliberately writing non-cabalizable code would be mean even if you could
13:06:48 <paggas> thanks for the info, you people really are quick at answering :)
13:07:08 <b_jonas> I just don't like this restriction
13:07:23 <gwern> like other languages don't do it?
13:07:26 <b_jonas> I know it follows mostly from haskell's not too good module systems
13:07:29 <klirrikassan> Baughn: is it researchers just toying around or is it a sponsored project? whats he point? to have verifiable OSes ?
13:07:30 <b_jonas> gwern: java does
13:07:36 <b_jonas> gwern: and I don't like it there either
13:07:49 <b_jonas> gwern: and in C you don't notice because it doesn't have namespaces, only compilation units
13:07:51 <jmcarthur_work> i don't think the fact that java does it justifies it.
13:07:58 <b_jonas> but in general I think the two should be different
13:08:10 <b_jonas> jmcarthur_work: that's what I'm saying, it shouldn't be done that way
13:08:43 <jmcarthur_work> meh, the module system is a common complaint about haskell
13:08:52 <gwern> klirrikassan: look into l4
13:09:17 <b_jonas> jmcarthur_work: actually while I'd like better modules, I can't really imagine how the perfect module system would work
13:09:41 <jmcarthur_work> nor i, but there are things i would change
13:11:38 <slava> remember when you guys announced 'full unicode support' but it was just a string datatype taht could hold non-ascii characters, plus an incomplete ICU binding?
13:11:47 <slava> that's the sort of intellectual dishonesty that's getting pretty old
13:12:05 <slava> and all this perforamnce stuff too
13:12:06 <jmcarthur_work> i don't know what you're talking about
13:12:54 <jmcarthur_work> are you slava pestov?
13:13:06 <slava> yes, and I'm getting pissed off at haskell shills
13:13:06 <dolio> Believe it or not, not everyone here spends their time hyping haskell on reddit.
13:13:25 <vixey> only about half :pp
13:14:34 <Ingo__> Is it possible to install wxhaskell on windows, because no matter what I try, I always fail
13:15:04 <swiert> I managed to speed up the hashtable benchmark by about a factor 2 on my machine, in case anyone cares:
13:15:05 <swiert> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3263
13:15:19 <jmcarthur_work> slava, that hash table benchmark you linked here was written by a known troll. i don't think fighting our trolls with your own is intellectually honest either
13:15:32 <slava> it doesn't matter who wrote it
13:15:34 <jmcarthur_work> but you may not have been aware of that
13:15:42 <slava> just because harrop is an idiot doesn't invalidate his colcusions
13:15:59 <jmcarthur_work> well, anybody who does a second of research can find that we don't endorse out hash tables
13:16:11 <jmcarthur_work> *our
13:17:43 <mauke> > ｘ ＋ ｙ
13:17:44 <lambdabot>   x + y
13:18:03 <vixey> > ｘ + ｙ
13:18:04 <lambdabot>   x + y
13:18:32 <wli> Pretty much all the mutable array API's require MPTC; I'm not sure how "nonstandard extensions" fit into the picture.
13:18:49 <Baughn> MPTC?
13:18:57 <gwern> multiparameter type classes
13:20:46 <wli> There really needs to be a Haskell' so extensions almost everyone takes for granted are "offically standardized."
13:20:58 <gwern> there is
13:21:03 <gwern> just not officialized yet
13:21:25 <Duqicnk> will the Prelude be redesigned to take advantage of MPTC in Haskell' ?
13:21:44 <mauke> unlikely, I think
13:21:49 <wli> That would not be the response if I had been clear enough to be understood.
13:21:50 <Deewiant> Haskell' doesn't look like it's going to change anything
13:22:12 <Deewiant> It'll just move some extensions away from 'extension' status
13:22:33 <Duqicnk> sure, but this is a plausible extension someone might write between now and then
13:22:35 <Deewiant> And clarify a few weirdnesses in the Report, I guess (indentation)
13:23:11 <wli> Haskell' is largely about taking extensions every implementation already agrees upon and most/all programmers take for granted and merging them into the standard.
13:23:47 <FunctorSalad> Baughn: great picture of the configuration space in the ppt presentation linked there, eh? ;)
13:24:11 <Baughn> FunctorSalad: Perhaps. I don't have anything that can read ppt installed, so..
13:24:49 <FunctorSalad> Baughn: openoffice can
13:25:02 <wli> The whole thing I was on about was that there really does need to be something that conservative.
13:25:13 <Baughn> FunctorSalad: I'm on gentoo. Installing OOo takes.. I haven't bothered spending the day yet.
13:25:40 <FunctorSalad> Baughn: IANAP, but I'm confused about this talk of "splitting" and particular "worlds".... I thought this whole business was continuous
13:25:58 <mauke> emerge openoffice-bin
13:26:03 <Baughn> FunctorSalad: It is; the splitting is basically an emergent effect
13:26:07 <Baughn> mauke: Not on amd64
13:26:12 <mauke> ヾ
13:26:17 <SubStack> gentoo... bad memories there
13:26:25 <SubStack> with my 233 MHz pentium
13:27:01 <Baughn> FunctorSalad: Avalanche effect, really. One particle splits into two orthogonal wave-functions; as it interacts with others, it splits those as well, and so on.
13:27:25 <Baughn> FunctorSalad: Though it gets rather interesting once you involve entanglement - but still distinctly local, to my great reliefe.
13:27:35 <FunctorSalad> almost orthogonal I suppose
13:27:52 <Baughn> Well, yes. There's nothing /forcing/ that to happen, it's just the most likely outcome
13:27:55 <Baughn> But it won't be exact
13:28:51 <Baughn> Which is what mangled worlds relies on; slight fluctuations in high-amplitude worlds that are one possible due to that inexactness, might be enough to entirely kill off the low-amplitude ones
13:29:02 <Baughn> (I don't think anyone's done the math on that yet)
13:32:01 <SnailRacer> Did someone drop Gmane from the mailing list? It hasn't updated since the 1st.
13:32:25 * FunctorSalad is thinking positively. There's some probabiliy that the mangling will bring heaven... in fact, I think I should make waiting for that my new life plan
13:32:35 <FunctorSalad> ;)
13:33:55 <gwern> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3214#a3264 <-- ok, I've finished it. any comments on style or useful library functions that could shorten it?
13:34:31 <gwern> (it is about 30 lines, but half of that is due to formatting etc.)
13:34:35 <Actium> why do i detect feminism in haskell literature?
13:34:55 <gwern> Actium: no idea. not many female haskell writers...
13:35:16 <Duqicnk> you don't have to be female to be a feminist
13:35:19 <skorpan> i know (of) at least three here at chalmers
13:35:22 <Actium> exactly
13:35:27 <FunctorSalad> Actium: never noticed it
13:35:28 <paggas> wondering if i can replace mapM_ with list comprehensions, like i can for map (map x y becomes [x i | i <- y]) :D
13:35:28 <skorpan> females that is, not necessarily feminists
13:35:37 <gwern> skorpan: well, chalmers is riddled with haskellers
13:35:48 <skorpan> gwern: that's true
13:35:53 <mauke> @src mapM_
13:35:54 <lambdabot> mapM_ f as = sequence_ (map f as)
13:35:59 <wli> paggas: sequence_
13:35:59 * jmcarthur_work has never detected feminism in haskell papers
13:36:10 <klirrikassan> Actium: vixey is omnipresent
13:36:18 <skorpan> paggas: that is, sequence_ [ ...list comp... ]
13:36:25 <skorpan> @src mapM_
13:36:26 <lambdabot> mapM_ f as = sequence_ (map f as)
13:36:28 <gwern> @vixen is vixey really omnipresent?
13:36:29 <lambdabot> really!
13:36:36 <gwern> ok then
13:36:42 * Actium shrugs
13:36:45 <b_jonas> gwern++
13:36:49 <skorpan> @karma gwern
13:36:50 <lambdabot> gwern has a karma of 2
13:36:54 <paggas> of course :O
13:36:55 <FunctorSalad> Actium: do you just mean pronouns or more severe stuff?
13:36:57 <mauke> preflex: karma gwern
13:36:57 <preflex>  gwern: 1
13:37:21 <Actium> FunctorSalad: pronouns, not direct references
13:37:49 <mauke> preflex: 8ball should I get another spoon?
13:37:49 <preflex>  yes - definitely
13:38:15 <Actium> preflex: 8ball is it all in my head?
13:38:15 <preflex>  very doubtful
13:40:16 <FunctorSalad> you accidentally the whole 8ball...?
13:40:49 <Cale> I ACCIDENTALLY THE WHOLE ACCIDENT!!
13:41:07 <Actium> you accidentally what? ;)
13:41:12 <b_jonas> let's extend the type system to handel grammatical gender
13:41:12 <FunctorSalad> hey Cale
13:41:15 <Cale> Hey
13:41:28 <Baughn> Cale: I accidentally the silly meme.
13:41:33 <FunctorSalad> long time since I last saw you here :)
13:41:39 <Cale> I've been here.
13:41:48 <Cale> But not talking so much in the past little while.
13:42:05 <mauke> let's extend the type system to george frideric handel
13:42:34 <wli> Could we take a break from the type system long enough to get a module system?
13:42:35 <Cale> 日本語を勉強したんだ。
13:42:48 <skorpan> with the postfix notation extension, will i be able to say e.g. "x `withCurlies`" where withCurlies is a function with arity 1?
13:43:04 <mauke> needs more parens
13:43:25 <skorpan> x (`withCurlies`)?
13:43:34 <Cale> (x `withCurlies`)
13:43:34 <b_jonas> no, (x `withCurlies`)
13:43:41 <skorpan> i see
13:43:47 <FunctorSalad> even with the postfix ext?
13:43:52 <b_jonas> yes
13:43:52 <ziman> > let (!) n = product [1..n] in (6!)
13:43:55 <lambdabot>   720
13:44:03 <bavardage> how do I get a random element from a list?
13:44:08 <skorpan> btw, do the following expressions have different precedence?  x `hello` y vs. hello x y?
13:44:28 <mauke> skorpan: yes
13:44:29 <Cale> bavardage: You generate a random number from 0 up to length xs - 1, and then use !!
13:44:32 <skorpan> ziman: but i'm talking about some postfix notation extension that i read about in the ghc docs
13:44:38 <bavardage> Cale: heh kk :P
13:44:41 <FunctorSalad> bavardage: do { x <- randomRIO (0,length lst -1); return (lst !! x) }
13:44:48 <Cale> bavardage: The issue of generating random numbers is a bit subtle in Haskell.
13:44:50 <skorpan> mauke: which has lower precedence and why?  (or where can i read about this?)
13:44:51 <FunctorSalad> bavardage: but that's O(n)
13:45:00 <Cale> bavardage: There are a number of approaches you could take
13:45:08 <bavardage> FunctorSalad: I really couldn't care less about O(ness) :P
13:45:16 <bavardage> I only grasp the basics of big-O notation
13:45:21 <bavardage> Cale: right...
13:45:22 <mauke> skorpan: the haskell report (and function application binds tighter than infix operators)
13:45:39 <skorpan> mauke: but i thought that the `infix` notation was just syntactic sugar
13:45:45 <skorpan> apparently not?
13:45:53 <mauke> huh?
13:45:57 <mauke> why not?
13:46:01 <b_jonas> skorpan: it is just syntactic sugar
13:46:04 <skorpan> because the semantics change
13:46:09 <mauke> no, they don't
13:46:30 <FunctorSalad> it is distinguished in the template haskell AST
13:46:39 <Actium> what's the ghci command for showing the implementation (source code) of a function?
13:46:42 <FunctorSalad> but I guess that's so you can output it like it came in
13:46:45 <mauke> Actium: no
13:46:52 <Actium> :(
13:47:03 <skorpan> okay... i thought syntactic sugar was basically just rewriting something into something else which is *then* put into the AST.
13:47:14 <b_jonas> skorpan: how does semantic change?
13:47:31 <skorpan> b_jonas: because the normal notation takes precedence over the one with syntactic sugar
13:48:01 <b_jonas> huh? you're not talking about template haskell, are you?
13:48:05 <FunctorSalad> Actium: emacs? M-x inferior-haskell-find-definition , but  it only works for loaded files, not imported modules
13:48:15 <skorpan> b_jonas: no, i don't know TH at all
13:48:28 <mauke> both (+) x y and x + y compile to Apply (Apply (Sym "+") (Sym "x")) (Sym "y")
13:48:35 <b_jonas> so what's this takes precedence thing?
13:48:50 <skorpan> b_jonas: but if "hello x y" binds tighter than "x `hello` y", i don't quite see the latter as *only* syntactic sugar
13:49:04 <Actium> FunctorSalad: thanks for the elaboration
13:49:05 <skorpan> i'm not arguing btw, i'm trying to understand this
13:49:25 <mauke> you seem to be using a weird definition of syntactic sugar
13:49:44 <skorpan> maybe i am..
13:50:11 <skorpan> because i see syntactic sugar as something like: eval (SyntacticSugar x) = eval (NonSyntacticSugar x)
13:50:21 <skorpan> if that makes sense to anyone
13:51:19 <skorpan> so in this case it would be something like: eval (x `fun` y) = eval (fun x y)
13:51:20 <FunctorSalad> that should be necessary but not sufficient for syntactic sugar status...
13:51:26 <vixey> \o/
13:51:34 <wli> Syntactic sugar are syntactic constructs defined by their (mostly blind) translations into versions of the language without the construct.
13:51:40 <FunctorSalad> (deep theorems can have that form too)
13:51:54 <wli> e.g. x `op` y ---> op x y
13:51:55 <vixey> skorpan: I would understand   eval = eval' . desugar
13:52:21 <skorpan> wli: exactly, that's what i would think
13:52:31 <wli> (*5) ---> \x -> x * 5
13:52:48 <mauke> my understanding of syntactic sugar is based on intuition and writing a lambda calculus interpreter :-)
13:53:03 <skorpan> oh well, i guess i'll just swallow this defeat for now... but i'll be back!
13:53:45 <skorpan> > let x {} y = x + y in 5 {} 4
13:53:47 <lambdabot>   <no location info>: Empty record update
13:54:03 <skorpan> man, why are all the *good* operators disallowed...
13:54:11 <mauke> ? is a good operator :-)
13:54:25 <b_jonas> mauke: does writing a lambda calculus interpreter help? because I wrote a scheme-like interpreter that has no syntactic sugar, not even let or quote
13:54:31 <vixey> skorpan utterly ridiculous: I can't call a variable 'type' in Haskell
13:54:33 <skorpan> i'm trying to make an operator which expresses "parse x with curly brackets around it"
13:54:36 <FunctorSalad> skorpan: most unicode is legal :)
13:55:05 <mauke> > let x ｛｝ y = x + y in 5 ｛｝ 4
13:55:05 <FunctorSalad> > let (∏) = prod in ∏ [1..3]
13:55:05 <skorpan> maybe i should start looking for unicode non-ascii curlies
13:55:07 <lambdabot>   <no location info>: lexical error at character '\65371'
13:55:07 <lambdabot>   <no location info>: parse error on input `∏'
13:55:09 <Deewiant> vixey: But you can call a variable 'typex', and yet not an operator '{}+'.
13:55:10 <FunctorSalad> meh.
13:55:17 <FunctorSalad> > let (∏) = prod in (∏) [1..3]
13:55:19 <lambdabot>   Not in scope: `prod'
13:55:22 <FunctorSalad> > let (∏) = product in (∏) [1..3]
13:55:24 <lambdabot>   6
13:55:26 <FunctorSalad> :D
13:55:38 <vixey> > let (∏) = product in (∏ [1..3])
13:55:39 <lambdabot>       Overlapping instances for Show ([[t] -> t1] -> t1)
13:55:40 <lambdabot>        arising from ...
13:55:41 <b_jonas> `curly`
13:55:43 <skorpan> that was the only beauty i personally could find in agda btw
13:55:46 <vixey> > let (∏) = product in ([1..3] ∏)
13:55:48 <lambdabot>   6
13:55:53 <wli> You want PL/I? if if = then then else else?
13:56:09 <vixey> wli no :S
13:56:13 <b_jonas> wli: isn't that fortran?
13:56:18 <vixey> wli, I just don't names already hogged
13:56:19 <FunctorSalad> . o O { overload nbsp }
13:56:34 <b_jonas> except I think in fortran it works without the spaces
13:56:55 <skorpan> curlies x = plzSpc '{' <*> x <*> plzSpc '}'
13:56:56 <mauke> b_jonas: it's nice to see how far you can go with a language based on data Expr = Var String | Abs String Expr | App Expr Expr
13:57:08 <skorpan> that one gives me a type-error.  i'm not using the function anywhere yet, still won't compile.
13:57:11 <FunctorSalad> let (
13:57:11 <FunctorSalad> ) = 1 in (
13:57:11 <FunctorSalad> )
13:57:11 <skorpan> makes *no* sense to me.
13:57:24 <FunctorSalad> oh dear
13:57:26 <b_jonas> mauke: well, mine had set! and numbers so I could cheat
13:57:32 <mauke> b_jonas: you just have to extend the parser to support multi-arg functions, sections, let, recursive definitions, etc
13:57:45 <b_jonas> mauke: I just used set! for recursion instead of a real y combinator stuff
13:57:47 <mauke> the core can stay the same
13:58:04 <mauke> (also, infix operators)
13:58:06 <b_jonas> but in theory it could interpret the y combinator version as well
13:58:16 <b_jonas> but yes, I agree in general
13:58:29 <bavardage> can one do an if-style statement inside a do block?
13:58:42 <mauke> bavardage: yes
13:58:45 <FunctorSalad> bavardage: yes, but you must indent the then and else
13:58:52 <bavardage> kk :D
13:58:53 <mauke> (if you have no "else" part, use "when" instead)
13:58:58 <b_jonas> mauke: the most complicated code I wrote for it was (((lambda (fact) (set! fact
13:59:01 <b_jonas> (lambda (n) (if (< n 1) 1 (* n (fact (- n 1)))))) fact) 0) 5)
13:59:09 <b_jonas> I think that's also valid scheme
13:59:39 <b_jonas> that was after I wrote some simple things in wikiplia I think
13:59:49 <b_jonas> that language is funny
13:59:52 <mauke> from my prelude: "let show n = uncurry (\\d m -> (m + '0') : if is-zero d then nil else show d) (div n 10) in reverse . show"
14:00:05 <b_jonas> it has a small core too which is sort of like lambda calculus but not exactly
14:00:27 <b_jonas> the library emulates lambda calculus though
14:01:25 <mauke> longest definition: "let cmp lt eq gt a b = let cmp' = cmp lt eq gt in if is-zero a then if is-zero b then eq else lt else if is-zero b then gt else cmp' (pred a) (pred b) in cmp"
14:01:55 <b_jonas> ah
14:02:09 <Baughn> @pretty let cmp lt eq gt a b = let cmp' = cmp lt eq gt in if is-zero a then if is-zero b then eq else lt else if is-zero b then gt else cmp' (pred a) (pred b) in cmp
14:02:09 <lambdabot>  let cmp lt eq gt a b
14:02:09 <lambdabot>      = let cmp' = cmp lt eq gt in
14:02:09 <lambdabot>        if is - zero a then if is - zero b then eq else lt else
14:02:09 <lambdabot>        if is - zero b then gt else cmp' (pred a) (pred b)
14:02:09 <lambdabot>  in cmp
14:02:09 <b_jonas> so you use peano integers, not built-in or binary
14:02:21 <mauke> no builtins
14:02:32 <b_jonas> my interpreter has built-in numbers
14:02:56 <b_jonas> wikiplia also has built-in lists
14:03:06 <b_jonas> (where by lists I mean just cons cells and null)
14:03:25 <b_jonas> because that's what it uses for passing vararguments
14:03:48 <b_jonas> the builtin lambda only works with vararg, so in most cases you have to pattern-match elements of that list
14:04:04 <b_jonas> which is why it's almost impossible to program it directly without the desugarring compiler
14:04:34 <qba> hi, I've just started learning Haskell using http://learnyouahaskell.com as a tutorial, could you give me some sites with exercises for beginners, please
14:04:47 <mauke> .extend( ":"       , "\\x y f -> f x y" )   .extend( "nil"     , "const true" )
14:04:48 <mauke> wheee
14:05:48 <b_jonas> mayke: you also need deconstructing
14:06:09 <zou`> is there a haskell lib for reading jar/zip files?
14:06:18 <b_jonas> and isn't ((:) = \\x y f g -> f x y) instead?
14:06:45 <b_jonas> wait, const true? what's true?
14:06:47 <mauke> .extend( "uncons"  , "\\c n x -> if null x then n else x c" )
14:06:56 <mauke> true = const
14:07:09 <Baughn> zou`: zip-archive. Search hackage.
14:07:26 <mauke> false = flip const
14:07:27 <wli> mauke: data Expr label con var =  Var var |  Lam var Expr |  App Expr Expr |  Let (Map var Expr) Expr |  Con con (Map label Expr) |  Case Expr (Map con (Map var label, Expr)) ?
14:07:40 <mauke> wli: eww, too complicated
14:07:41 <Duqicnk> is this a kids book or what
14:08:13 <mauke> wli: also, I have no types so I don't need Con/Case, and Let is redundant if you have Lam
14:08:23 <wli> mauke: | LitInt Integer | LitChar Char | LitFlo Double
14:09:08 <zou`> Baughn: tried zip-archive, it had trouble reading jar files
14:09:52 <zbrown> Is there a preferred way to install GHC in Haskell? I've installed the standalone installer already and am looking at installing Cabal + friends however I also noticed that I can do all this through MacPorts as well. Anyone have thoughts on which is the best route?
14:10:01 <zbrown> errr to install GHC in Mac OS X**
14:11:06 <sm> is it possible to have cabal install a symlink to, or copy of, an executable, with a different name ? or would I have to build a second executable, duplicating all the config ?
14:11:07 <Baughn> zbrown: FWIW, I prefer the extra control of installing it manually. You never know when you'll want to try 6.11 for testing or something.
14:11:28 <Baughn> sm: There's the symlink-bindir option
14:11:33 <Baughn> In .cabal/config
14:11:42 <zbrown> Baughn: manually being via the standalone installer?
14:11:45 <Baughn> Oh, but different name? Not so much.
14:11:54 <Baughn> zbrown: Being from source, on os x. :P
14:12:10 <sm> hmm, thanks but I mean to configure this for one package, so it will work for all users
14:12:24 <sm> when they install
14:12:29 <zbrown> Baughn: oh I see
14:14:25 <Baughn> sm: One workaround would be to install a stub executable that just exec's the original
14:14:42 <sm> good idea
14:14:46 <Baughn> sm: The installation bindir is part of the Paths_foo stuff cabal can write
14:14:48 <b_jonas> mauke: okay, good night now
14:14:50 <kerlo> @hoogle find
14:14:52 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
14:14:52 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:14:52 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:15:33 <Baughn> sm: That said, I'm sure you can write a custom setup for cabal that creates an actual symlink. It'd just take a bit mor ework.
14:16:05 <sm> agreed, maybe time to get into custom Setup.hs
14:16:08 <sm> thanks
14:16:46 <wli> mauke: recursion sans letrec requires type errors
14:17:00 <mauke> huh?
14:17:12 * kerlo frowns at a 50-line JavaScript function to turn stuff like "<one two />" into stuff like "<one two></one>"
14:17:20 <wli> mauke: e.g. The untypeable Y combinator.
14:17:22 <mauke> fix = (\rec -> rec (\y f -> f (rec y f))) (\f -> f f)
14:17:29 <bavardage> how can I stop getChar returning a newline?
14:17:37 <mauke> bavardage: what?
14:17:37 <bavardage> as in, I call getChar
14:17:45 <Baughn> bavardage: Check for newline. Call again if you see one.
14:17:51 <bavardage> enter 3, press ENTER to ok the value..
14:17:57 <bavardage> Baughn: bleh kk
14:17:58 <mauke> bavardage: use getLine instead
14:18:02 <Baughn> Or that
14:18:08 <bavardage> and then just take the head I guess
14:18:10 <Baughn> Or readLine
14:18:10 <smarmy> not exactly a haskell question, but why is the set of all functions from Nat to Bool not countable?
14:18:18 <mauke> Baughn: readLn :-)
14:18:36 <wli> There's also no way to ever produce a result of observable type.
14:18:38 <kerlo> Can you set the buffering on stdin so that you don't have to press enter?
14:19:03 <Baughn> kerlo: Yes, with hSetBuffering
14:19:10 <kerlo> smarmy: there are relatively simple injections between (Nat -> Bool) and the reals.
14:19:18 <mauke> kerlo: I don't know how System.IO works internally, but in general it's not a buffering issue; you have to set some terminal attributes
14:19:37 <kerlo> Cantor's diagonal argument is a pretty simple proof that Nat -> Bool is uncountable, I guess.
14:19:49 <Baughn> ISTR hSetBuffering on stdin actually does set those terminal attributes
14:20:28 <kerlo> @type (!!)
14:20:30 <lambdabot> forall a. [a] -> Int -> a
14:20:44 <Baughn> @type generic!!
14:20:45 <lambdabot> parse error (possibly incorrect indentation)
14:21:04 <mauke> @type genericIndex
14:21:06 <lambdabot> forall b a. (Integral a) => [b] -> a -> b
14:21:31 * Baughn actually managed to run into the limitations of !! recently
14:21:41 <kerlo> > let excluded l = [not (l!!n!!n) | n <- [0..]] in excluded ([repeat True, repeat False, cycle [True, False]] ++ repeat (repeat True))
14:21:43 <lambdabot>   [False,True,False,False,False,False,False,False,False,False,False,False,Fal...
14:22:05 <kerlo> smarmy: excluded, given a list of lists of Bools, gives a list of Bools that is not in the list.
14:26:09 <smarmy> kerlo: i understood diagonalization, but i wasn't thinking correctly about the set.  that makes the connection clear
14:26:43 <poucet> How would I make a change to an existing hackage package?
14:26:55 <Baughn> poucet: Locally?
14:26:58 <smarmy> kerlo: so i can create a new function that for each n in N, produces a different Bool along the diagonal than each already counted function
14:26:59 <poucet> Baughn: No, on hackage
14:27:04 <Baughn> poucet: Upload a new version
14:27:05 <poucet> Baughn: vacuum is too strict
14:27:13 <poucet> Baughn: Right, but how you do you upload?
14:27:28 <Baughn> poucet: ..are you the author of vacuum?
14:28:02 <kerlo> smarmy: yeah.
14:28:09 <poucet> Baughn: No, I am not.
14:28:28 <Baughn> poucet: Then you should not be randomly uploading new versions of it. Fork if you must, but try talking to the author first.
14:28:30 <jmcarthur_work> Baughn, that would be mmorrow
14:28:35 <poucet> Baughn: The issue is that it requires ghc == (6.10.1) instead of something like ghc >= 6.10.2
14:28:38 <poucet> Baughn: I can't fork
14:28:38 <Baughn> jmcarthur_work: ..I know.
14:28:56 <jmcarthur_work> Baughn, ah, i thought it was a legitimate question
14:28:58 <mauke> poucet: sounds reasonable if it relies on compiler internals
14:28:58 <poucet> Baughn: When I cabal install vacuum-ubigraph, evne though I installed the package locally after modification, it still complains about the version, cause I think it tries to get it again from hackage
14:29:15 <Baughn> jmcarthur_work: Must you put it that way? ;_;
14:29:31 <jmcarthur_work> Baughn, sorry ;)
14:29:43 <Baughn> poucet: Worked for me. Are you sure that isn't just vacuum-ubigraph having yet another restriction?
14:29:58 <poucet> Baughn: You have 6.10.2?
14:30:12 <Baughn> poucet: Yes
14:30:23 <jmcarthur_work> poucet, i ended up having to install vacuum-ubigraph manually instead of using cabal-install
14:30:28 <Baughn> Although, I'm still compiling gtk2hs
14:30:34 <poucet> jmcarthur_work: I might have to do that
14:30:37 <jmcarthur_work> it kept complaining about haxr even though i had already installed it
14:31:55 <cognominal>  [ 1, 2 ] ++ [ 1 ]  -- I want the same but with  1 in place of [ 1 ]
14:32:07 <mauke> lol wut
14:32:26 <mauke> > (\x -> [1, 2] ++ [x]) 1
14:32:28 <lambdabot>   [1,2,1]
14:32:29 <jmcarthur_work> > reverse $ 1 : reverse [1,2] -- ?
14:32:30 <slava> he wants to add an element to a list
14:32:31 <lambdabot>   [1,2,1]
14:32:49 <cognominal> mauke, this is what I want to avoid :)
14:32:52 <lilac> cognominal: you want an append :: [a] -> a -> [a]
14:32:54 <lilac> ?
14:33:07 <jmcarthur_work> @hoogle [a] -> a -> [a]
14:33:08 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:33:08 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:33:08 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:33:11 <vixey> @let xs +++ x = x ++ [x]
14:33:12 <lambdabot>  <local>:15:17:
14:33:12 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
14:33:22 <vixey> > let xs +++ x = x ++ [x] in  [1,2] +++ 1
14:33:23 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
14:33:23 <lambdabot>        Expect...
14:33:31 <vixey> > let xs +++ x = xs ++ [x] in  [1,2] +++ 1
14:33:33 <lambdabot>   [1,2,1]
14:33:36 <mauke> cognominal: why?
14:33:56 <lilac> cognominal: if you're doing that a lot, you probably don't want to uise []
14:34:08 <cognominal> I thought the construction of an intermediate array was an uneeded extra-step
14:34:13 <cognominal> I am probably too fussy
14:34:29 <mauke> s/array/list/ :-)
14:34:35 <jmcarthur_work> if you are doing it a lot, you should either just use (:) and then reverse the whole thing at the end or use something like Data.Sequence
14:34:35 <mauke> and it's not intermediate
14:34:48 <mauke> the [1,2] part is intermediate, though
14:35:10 <jmcarthur_work> cognominal, what is the use case?
14:35:36 <cognominal> I want to write a burryBuffer for yi
14:35:36 <zou`> so using zip-archive from haskage, always getting this error "Did not find end of central directory signature"
14:35:36 <zou`>  
14:35:43 <zou`> for reading jar/tar files
14:36:00 <jmcarthur_work> i'm sorry... a burryBuffer?
14:36:07 <cognominal> that means moving a bufferref to the end of a list.
14:36:22 <zou`> the zip.hs seems to be looking for this signature   --> unless (endSig == 0x06054b50)
14:38:01 <zou`> is that not the right signature to check for jar/tar files?
14:38:04 <jmcarthur_work> cognominal, well, i'm not familiar with what you are doing this for, but if you let me know how you intend to use this list i can help you choose the right structure and functions for it
14:39:12 <jmcarthur_work> the function are ask for is O(n) insertion
14:39:37 <jmcarthur_work> s/are/you/
14:41:43 <sioraiocht> in Set, how does [->Y] map an object X to [X->Y]?
14:41:59 <cognominal> jmcarthur,  I think that buryBuffer would be a switchToBufferE  with a minor modification. See yi/Yi/Editor.hs :394
14:42:12 <sioraiocht> (assuming [->Y] is a functor, that is)
14:42:30 <sioraiocht> and [X->Y] is the set of all functions from X->Y
14:42:37 <wli> Just use Data.Sequence
14:42:44 <cognominal> that moving a buffer to the end of a list, instead to moving it to the beginning
14:43:26 <sioraiocht> @src Functor (->)
14:43:26 <lambdabot> Source not found. Do you think like you type?
14:43:42 <sioraiocht> @src Functor []
14:43:42 <lambdabot> Source not found. Just try something else.
14:43:57 <mauke> @src (->) fmap
14:43:57 <lambdabot> fmap = (.)
14:43:58 <cognominal> anyway, I think I can do it by myself now
14:44:13 <jmcarthur_work> cognominal, ah, so this isn't going to be heavily used?
14:44:20 <jmcarthur_work> O(n) is probably fine then
14:44:30 <jmcarthur_work> i thought it was more of a data processing type thing
14:44:41 <sioraiocht> :t (.)
14:44:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:45:16 <cognominal> ho, I missed the thread about O(n). Yes, my worry was stylistic only
14:45:29 <cognominal> one does not moves buffers around much
14:45:37 <jmcarthur_work> i think the [1,2] ++ [3] version is fine
14:45:47 <mauke> rotate [] = []; rotate (x : xs) = xs ++ [x]
14:45:52 <jmcarthur_work> i don't know what you mean about moving buffers around too much. there are no side effects in that code
14:46:05 <mauke> jmcarthur_work: yi is a text editor
14:46:13 <jmcarthur_work> mauke, yes?
14:46:20 <cognominal> and yes, I always says array when I think list. I come from the Perl world
14:46:33 <jmcarthur_work> oh i misread you
14:47:07 <jmcarthur_work> "one [that] does not moves buffers around much" <-- mental insertion. i thought "that" represented the expression in question
14:47:17 <mauke> oh, heh
14:47:48 <wli> > let rotate [] = [] ; rotate [x] = [x] ; rotate (x:x':xs) = x' : rotate (x:xs) in rotate [1..10] :: [Int]
14:47:49 <lambdabot>   [2,3,4,5,6,7,8,9,10,1]
14:49:31 <jmcarthur_work> @pl xs x -> xs ++ [x]
14:49:31 <lambdabot> (line 1, column 6):
14:49:31 <lambdabot> unexpected ">" or "-"
14:49:31 <lambdabot> expecting variable, "(", operator or end of input
14:49:34 <zou`> and zip -T test.jar returns ok
14:49:39 <jmcarthur_work> @pl \xs x -> xs ++ [x]
14:49:39 <lambdabot> (. return) . (++)
14:49:59 <jmcarthur_work> @pl \x -> xs ++ [x]
14:49:59 <lambdabot> (xs ++) . return
14:50:03 <jmcarthur_work> that one is okay
14:50:29 <zou`> but 'toArchive `liftM` String.readFile test.jar' complained about not finding the end of central dir signature
14:50:35 <zou`> any ideas?
14:52:23 <cognominal> :)
15:03:37 <mmorrow> poucet: if you don't force stuff, you just end up segfaulting :)
15:03:56 <poucet> mmorrow: ah, interesting :)
15:04:13 <poucet> mmorrow: So it doesn't suppot 6.10.2?
15:04:21 <mmorrow> and it'd probably work with 6.10.2, but i have to make sure ClosureTypes is synced with ClosureTypes.h
15:04:39 * poucet nods
15:05:24 <mmorrow> poucet: i'm going to try to update it (if needed) for 6.10.2 today
15:05:30 <poucet> mmorrow: Great, thanks.
15:05:54 <mmorrow> poucet: (i'm not quite sure why exactly it segfaults, but there may be some way around it)
15:06:33 <jmcarthur_work> mmorrow, hey, is there any work being done on the ability to show thunks rather than forcing?
15:06:57 <mmorrow> jmcarthur_work: if you don't force stuff, it just mysteriously segfaults
15:07:37 <jmcarthur_work> aw :( that sounds weird
15:07:42 <mmorrow> but if we figure out why that is, there may be a way to get around that
15:07:55 <mmorrow> jmcarthur_work: yeah, weird for sure
15:13:55 <klirrikassan> let cpp = "lol" in concat [cpp,cpp,cpp,cpp]
15:13:57 <klirrikassan> > let cpp = "lol" in concat [cpp,cpp,cpp,cpp]
15:13:59 <lambdabot>   "lollollollol"
15:14:06 * mmorrow builds 6.10.2
15:14:13 * poucet cheers for mraddatz 
15:14:22 <poucet> mmorrow even
15:14:25 <mmorrow> heh
15:15:04 <RayNbow> finally... with the help of some IRC friends... I managed to install Linux for the first time... :p
15:15:37 * RayNbow should soon pacman -S ghc... :)
15:16:10 <mmorrow> RayNbow: nice
15:16:10 <luite> I juist built 6.10.2, I love the smell of a new compiler :p
15:16:34 <mmorrow> does it smell like napalm in the morning?
15:16:49 <mmorrow> (victory)
15:17:11 <RayNbow> mmorrow: it's a hell to get it working though... especially if you're trying to install it on an exotic piece of hardware :p
15:17:33 <mmorrow> eeh, on what?
15:17:54 <RayNbow> oh, the hardware support is getting better now... I installed Arch on an Acer Aspire One (150)
15:18:09 <mmorrow> cool
15:18:13 <RayNbow> but it sucks if you don't have wlan and you need to fetch packages from the web :p
15:18:23 <mmorrow> yeah, total pita
15:18:45 * RayNbow managed to get Linpus (the default OS) on an USB memory stick after several tries
15:19:02 <mmorrow> it's funny how having to plug in for internet with a laptop at this point feels like total torture :)
15:19:31 <luite> RayNbow: yeah you could have done it in less tries if you didn't forget to preserve the file permissions and ownerships the first time ;)
15:20:03 <RayNbow> luite: actually, for Linpus on USB, I followed blackhawk's guide
15:20:43 <RayNbow> (first attempt failed, so I tried something else... but the second time I tried to follow the guide it worked)
15:20:57 <RayNbow> mmorrow: I didn't use eth0 though :)
15:21:09 <mmorrow> oh snap
15:21:33 <RayNbow> I don't have cat5 cables that are long enough
15:21:44 <RayNbow> and I don't feel like sitting near the router :p
15:21:55 <luite> yeah plugging in ethernet would be like admitting defeat
15:22:00 <RayNbow> that too :p
15:22:11 <sioraiocht> :t [] 4
15:22:13 <lambdabot>     Couldn't match expected type `t1 -> t' against inferred type `[a]'
15:22:27 <mmorrow> oh cool, i just googled what an Acer Aspire One is
15:22:34 <RayNbow> sioraiocht: what are you trying to do?
15:22:44 <sioraiocht> was trying to treat [] as a constructor
15:22:45 <luite> it's a thing that probably takes days to build ghc ;)
15:23:01 <sioraiocht> i know [4] works =[
15:23:02 <mauke> sioraiocht: it is a constructor, but it takes no arguments
15:23:02 <sioraiocht> =p
15:23:08 <RayNbow> :t []
15:23:08 <mauke> @src []
15:23:09 <lambdabot> data [] a = [] | a : [a]
15:23:09 <lambdabot> forall a. [a]
15:23:10 <sioraiocht> mauke: yeah i realise =
15:23:13 <RayNbow> :t (:)
15:23:15 <lambdabot> forall a. a -> [a] -> [a]
15:23:51 <RayNbow> mmorrow: Aspire One 150 is already aging... recently Samsung announced a netbook with a battery life of 10 hours or something like that
15:23:56 <luite> RayNbow: do you have one with hdd or ssd?
15:24:06 <RayNbow> 150 is the hard disk version
15:24:09 <RayNbow> 110 is SSD
15:24:12 <luite> ah
15:24:23 <RayNbow> the SSD in the 110 is said to be slow
15:24:38 <mmorrow> RayNbow: oh? as in you can buy it?
15:24:54 * mmorrow was just thinking he wanted one of those Aspire Ones
15:25:51 <RayNbow> mmorrow, http://www.engadget.com/2009/04/02/samsungs-2-1-channel-rocking-n120-netbook-now-available-for-pre
15:26:15 <RayNbow> but the newer netbooks tend to grow in size
15:26:23 <luite> isn't that samsung more expensive than the acer?
15:26:28 <RayNbow> that too
15:26:52 <RayNbow> but the battery life on my Acer is like 2:00h to 2:30h
15:27:03 <RayNbow> but then again, it's only a 3 cells battery
15:27:38 <mmorrow> RayNbow: ooh, looks nice
15:28:25 <mmorrow> i just got a thinkpad x301 with the solid-state drive, and reading from disk is soooo fast
15:28:32 <RayNbow> mmorrow: the body of that Samsung is 12.1" though
15:28:55 <cads> mmorrow thats enviable
15:29:03 <mmorrow> cads: :)
15:29:14 <cads> what's the $/Gb on those things these days/
15:29:23 * RayNbow wants a laptop with 24x SSDs! :p (sweet dreams :p)
15:29:40 <harovali1> what is in GHCi the contrary of import?
15:29:50 <RayNbow> :m -Module ?
15:29:55 <mmorrow> cads: i'm not sure, but mine's 128GB
15:30:11 <harovali1> RayNbow: thanks
15:30:36 <RayNbow> mmorrow, http://www.scientia.demon.nl/AspireOne/ <-- size comparison of 8.9" Aspire One vs 15" Tecra S3 (warning: pics were taken with a crappy phone :p)
15:30:48 <cads> mmorrow: more than adequate for most work... I ought to see if I can find one that'll fit my ol' lappytop
15:31:10 <cads> hey mmorrow, hows your interpreter project going/
15:31:23 <luite> RayNbow: I still think you should have bought that thinkpad instead of the tecra ;)
15:31:39 <RayNbow> luite: that Tecra is my old Tecra ;)
15:31:45 <luite> oh, nm then :p
15:32:08 <RayNbow> Tecra S10 (which is being repaired) is 15.4" widescreen
15:32:12 <mmorrow> cads: it's going well. i sidetracked slightly lately with vacuum, but i've picked it up again and think i could realistically have something releasable in a week.
15:32:59 <mightybyte> How do you fix the cabal error "Could not find module ABC: it is a member of package xyz, which is hidden"?
15:33:19 <mmorrow> cads: yeah, the speedup with the SSD is super noticeable
15:33:43 <mauke> mightybyte: list the package in the .cabal file
15:34:15 <mightybyte> mauke: I did, but I still get the error.
15:34:56 <cads> mmorrow: i'll look forward to checking it out
15:35:17 <mightybyte> mauke: I presume it goes in the Build-Depends line.
15:35:25 <mauke> yes
15:39:34 <mightybyte> mauke: Yeah, that still doesn't fix it.
15:40:02 <cads> Have you guys read Gilad Bracha's schpiel about pluggable type systems for programming languages?
15:40:56 <cads> He's got some interesting things to say, and even to my uneducated perspective, the idea of choosing type systems seems pretty cool
15:41:11 <kadaver> i ran into it once
15:41:12 <kadaver> seemed interesting
15:41:12 <kadaver> he has his own language right?
15:41:21 <cads> let me look up the name
15:41:27 <kadaver> but he is fairly OO i think
15:43:17 <sm> http://newspeaklanguage.org , good stuff
15:43:20 <cads> I think an OO type system can be seen as a specialization of a really expressive algebraic type system
15:44:04 <cads> it's the idea of specialized types systems that really seems exciting to me
15:45:17 <lowmagnet> if i have a function that returns IO Double
15:45:28 <lowmagnet> and i have a function in do notation that tries to use the result like so:
15:45:37 <lowmagnet> do r <- func
15:45:51 <lowmagnet> why am i getting an error about inferred type of 'IO b' when i use it?
15:46:29 <mauke> real error message plz
15:46:37 <lowmagnet> Couldn't match expected type `Double' against inferred type `IO b'
15:46:53 <mauke> hmm, need more context
15:47:00 <wchogg> are you sure func returns an IO Double and not just Double?
15:47:05 <mauke> did you forget a function argument?
15:47:14 <lowmagnet> zero function arguments
15:47:29 <lowmagnet> momento, i'll pasteboard it
15:47:33 <wchogg> cool
15:48:49 <lowmagnet> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2032
15:49:17 <lowmagnet> (yes, i'm aware i can set the ranges directly in the randomR)
15:49:44 <lowmagnet> this is among my first attempts to use IO
15:50:03 <wchogg> why isn't rangedRandom have type IO Double?
15:50:06 <vixey> > 48*atan(1/38)+80*atan(1/57)+28*atan(1/239)+96*atan(1/268)
15:50:08 <lambdabot>   3.141592653589793
15:50:30 <mauke> lowmagnet: the type signature of rangedRandom is wrong
15:50:35 <kadaver> BIOS is the layer between hardware and software right? is it hard to write one? that layer is a big like magic tome.
15:50:52 <Baughn> lambdabot: You need to fix the type declaration of rangedRandom. Also, function application binds tighter than any infix function, so your return lines are wrong.
15:50:57 <Baughn> Er, lowmagnet
15:51:08 <Baughn> lowmagnet: Either add parantheses, or use $
15:51:18 <TomMD> kadaver: Wrong channel.
15:51:21 <lowmagnet> ah
15:51:33 <lowmagnet> so i'm forever doomed to use IO up to main because i use random?
15:51:54 <Baughn> No
15:52:10 <Baughn> lowmagnet: getStdRandom is in IO, but once you have the generator you can pass it around and split it as needed
15:52:12 <mauke> lowmagnet: yes
15:52:23 <wchogg> lowmagnet : Well, IO is contaminating.  You can't escape back out of it.
15:52:34 <Baughn> lowmagnet: But you don't need IO just to get randomness
15:52:35 <cads> sm, wonder if newspeak will be popular... I think small-talk like languages deserve some popularity, as well as the lisps and functional languages
15:53:50 <vixey> can you automatically turn any parser grammar into a non left recursive one?
15:53:56 <vixey> and is it wise to do this?
15:54:02 <sm> I think it will be big, but they lost funding so things have slowed way down
15:54:40 <cads> > 16 * atan(1/5) - 4*atan(1/239)
15:54:41 <sm> I'm definitely interested in it, even as a haskeller
15:54:41 <Baughn> lowmagnet: Or you could just grab an infinite list of random numbers, for that matter
15:54:42 <lambdabot>   3.1415926535897936
15:54:49 <lowmagnet> oh i see now
15:54:55 <mauke> > 355/113
15:54:57 <lambdabot>   3.1415929203539825
15:55:14 <Lemmih> @seen insane
15:55:14 <lambdabot> I saw insane leaving #haskell 4h 40m 41s ago, and .
15:55:20 <lowmagnet> randInDecimalRange is returning a generator and unboxing just gets one of the values
15:55:32 <cads> > 16 * atan(1/5) - 4*atan(1/239) - pi
15:55:33 <lambdabot>   4.440892098500626e-16
15:55:54 <Baughn> lowmagnet: Not so much "returning" as "is", since it takes no parameters
15:56:10 <lowmagnet> Baughn: yeah, imperative habits die hard
15:56:24 <cads> > [355/113 - pi, 48*atan(1/38)+80*atan(1/57)+28*atan(1/239)+96*atan(1/268) - pi]
15:56:25 <lambdabot>   [2.667641894049666e-7,0.0]
15:56:34 <Baughn> lowmagnet: And yes, "unboxing" in the IO monad actually executes the action and gives you the result
15:56:35 <lowmagnet> Baughn: i use functional terms at work and confuse the oo people too
15:57:04 <Baughn> lowmagnet: Other monads treat the unboxing left-arrow differently. The only one I'd really call "unboxing", in fact, is the Maybe monad.. and maybe the Either one
15:57:24 <mauke> Identity :-)
15:58:23 <lowmagnet> well now that i understand i'm using a generator, it makes much more sense
15:59:05 <b\6> not getting what 'ambiguous type variable' is about. i'm doing something like 'un :: forall a . X a => a' and then using an X function on the result.
15:59:06 <Eduard_Munteanu> :t pi
15:59:08 <lambdabot> forall a. (Floating a) => a
15:59:15 <Baughn> lowmagnet: You can also get hold of the random-generator explicitly, pass it around as any other pure value and use it as you like
15:59:48 <Baughn> lowmagnet: That loses you the guarantee that any given state will only be used once, of course; you'll have to keep track of that yourself, but there's a function that lets you split one generator into two you'll find useful.
16:00:00 <Baughn> lowmagnet: (Eg. that's what getStdRandom on its own does)
16:00:03 <mauke> :t show . read
16:00:04 <lambdabot> String -> String
16:00:22 <mauke> oh, you
16:00:28 <Baughn> lowmagnet: Er. getStdGen, of course.
16:01:19 <cads> vixey, your formula wins :)
16:01:24 <Baughn> PRNGs may be sinful, but they sure are handy in pure languages. ;)
16:01:49 <luite> sinful?
16:01:57 <luite> for cryptographic purposes maybe
16:02:22 <Baughn> Cryptographic PRNGs exist, and are in common use for exactly that purpose.
16:02:28 <Baughn> No, I was referring to the famous quote.
16:02:31 <cads> Baughn: entropy is 'spensive though
16:02:34 <glguy> when I need access to real randoms in a pure computation I return a continuation so that the outer loop can get me some randoms and resume :)
16:02:52 <lowmagnet> PRNGs are often necessary in our shop
16:03:09 <mauke> PRNG = Porn Generator
16:03:18 <lowmagnet> mauke: given enough time
16:03:19 <kerlo> > map isAlpha "∩(　´Α｀)"
16:03:22 <lambdabot>   [False,False,False,False,True,False,False]
16:03:34 <glguy> get a Via processor, they generate entropy fask
16:03:35 <glguy> fast
16:03:37 <Baughn> > randoms (mkStdGen 42)
16:03:39 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
16:03:51 <TomMD> glguy: Yeah, the nop does tend to corrupt memory
16:04:10 <luite> Baughn: what quote?
16:04:22 <glguy> TomMD, I don't know about that specifically, but the padlock stuff has hardware rng :)
16:04:37 * cads furtively opens his coat, revealing the grubby inner lining, with rows and rows of dirty paper bags labeled "true random numbers"
16:04:47 <kadaver> anyone have a link on how to bootstrap ghc to a new OS?
16:04:55 <TomMD> glguy: You've used that a bit?  Do you have a rate?
16:04:58 <cads> *pssst* anyone need some _stuff_?
16:05:14 <kerlo> > let x ∩ y = x ++ y; x 　´ y = y ++ x; x ｀ y = head x : tail y in "foo" ∩ ("bar" 　´ "Α" ｀ "baz")
16:05:16 <lambdabot>   "foo\913az"
16:05:19 <Baughn> luite: "Anyone who considers arithmetical methods of producing random digits is, of course, in a state of sin." <-- von Neumann.
16:05:35 <Baughn> luite: It was a joke, mind you.
16:05:50 <cads> Baughn: I kind of agree
16:05:56 <luite> Baughn: ah, couldn't find it with 'sinful', thanks
16:06:31 <glguy> TomMD, I don't have numbers, but I can generate some if you know a good command :)
16:07:33 <lilac> random numbers you say?
16:07:36 <lilac> > randoms
16:07:37 <lambdabot>       Ambiguous occurrence `randoms'
16:07:37 <lambdabot>      It could refer to either `L.randoms...
16:07:37 <glguy> I use rngd to feed my kernel entropy with my /dev/hwrandom
16:07:56 <lilac> > L.randoms
16:07:57 <lambdabot>   [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...
16:08:07 <Baughn> glguy: How odd. You'd think it could do that on its own.
16:08:11 <vixey> lol
16:08:21 <kerlo> > L.randoms :: String
16:08:23 <lambdabot>       No instance for (Num Char)
16:08:23 <lambdabot>        arising from a use of `L.randoms' at ...
16:08:27 <kerlo> Oh.
16:08:28 <vixey> @remember <lilac> > L.randoms <lambdabot>   [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...]
16:08:28 <lambdabot> I will never forget.
16:08:29 <Baughn> lilac: Looks perfectly random to me
16:08:32 <cads> lilac: Yes sir, produced by the finest of atmospheric disturbances
16:08:47 <kerlo> What is L here?
16:08:52 <Baughn> The probability of that sequence is no greater than that of any other!
16:08:52 <cads> highest quality random numbers there are
16:08:53 <lowmagnet> that would fail an autocorrelation test ;)
16:09:05 <glguy> Baughn, you'd think :)
16:09:09 <kerlo> > L.randoms
16:09:09 <b\6> i extract a value via pattern matching like 'f (X x) = ...'. x is constrained to be an instance of Y. when i try to use a Y function on x, i get 'ambiguous type variable'. i don't understand where to add a type signature.
16:09:11 <lambdabot>   [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...
16:09:21 <kerlo> Baughn: I don't know, it's looking higher all the time.
16:09:23 <Baughn> lowmagnet: Yes, well, there's always a chance of a false positive on those
16:09:39 <lowmagnet> > L.randoms :: Double
16:09:41 <lambdabot>   Couldn't match expected type `Double' against inferred type `[t]'
16:09:48 <Baughn> kerlo: Nope. Same probability as any other result.
16:09:48 <lilac> > L.randoms :: [Double]
16:09:50 <lambdabot>   [9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9....
16:09:55 <lowmagnet> lol
16:09:59 <Baughn> @type L.randoms
16:10:01 <lambdabot> forall t. (Num t) => [t]
16:10:02 <lilac> > L.randoms :: [CReal]
16:10:03 <lambdabot>   [9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9.0,9....
16:10:14 <lowmagnet> it likes 9, leave it alone
16:10:14 <lilac> could well be random though
16:10:28 <Baughn> You can't prove it isn't!
16:10:35 <lowmagnet> Baughn: if you plot it an eyeball it, it's not so bad
16:10:47 <lilac> Baughn: well, *I* can, but you can't ;-)
16:10:49 * kerlo goes into arrogant genius mode.
16:10:50 <lowmagnet> R's acp works alright
16:10:51 <glguy> TomMD, /dev/random is the one that block on insufficient entropy, right?
16:11:08 <TomMD> glguy: Yep
16:11:09 <kerlo> Baughn: on the contrary, the proof that it isn't random is trivial.
16:11:09 <lilac> Baughn: but only because I know what I @let
16:11:16 <TomMD> glguy: And /dev/urandom is a sha mixer.
16:11:23 <glguy> rngtest: input channel speed: (min=18.837; avg=721.489; max=1262.116)Kibits/s
16:11:23 <glguy> rngtest: FIPS tests speed: (min=4.022; avg=24.148; max=25.031)Mibits/s
16:11:38 <Baughn> lilac: That recollection may be due to random errors in your brain, though
16:11:41 <glguy> when doing: rngtest < /dev/random
16:11:52 <lilac> oh. hmm. yeah, right you are. it must be random after all :-)
16:12:54 <TomMD> glguy: Is this your computer that is a Via C3 or something else like an embedded system?  I'm always interested in full computing systems that are non-x86 (ex: pandora).
16:13:25 <glguy> TomMD, its a picoitx c3 or c7 system (x86)
16:13:39 <glguy> its a normal computer running Fedora
16:13:45 <glguy> just fairly small
16:13:54 <glguy> does the hw rng and aes and sha accel
16:14:00 <TomMD> nice
16:20:51 <lowmagnet> messing around with fst and snd on the RandomGen types. nifgy
16:20:55 <lowmagnet> nifty, too
16:21:18 <Baughn> lowmagnet: Might find Arrow useful, too
16:21:56 <klirrikassan> im writing a function genSuccessorMap :: String -> Map String (Map String Int); it takes a string and counts how many times different words appears after it. this easily done with state. but purely? a foldl doesnt work here since I need to eb able to move forward or backwards.
16:24:55 <lowmagnet> :w
16:25:08 <lowmagnet> grr i really don't like the cmd-~ order in terminal.app
16:25:10 <klirrikassan> :lowmagnet
16:25:29 <klirrikassan> @src simonPeytonJones
16:25:29 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
16:25:43 <mmorrow> omg yesh! non-allocating infinite loops don't lock-up-and-make-you-have-to-kill-9 ghci in 6.10.2!
16:26:15 <skorpan> no way!
16:27:00 <mmorrow> way!
16:27:16 <mmorrow> it even handles
16:27:19 <mmorrow> let x = x in x
16:27:32 <skorpan> no way!
16:27:39 <mmorrow> yes way!
16:27:48 <skorpan> i thought .2 was only a bugfix release
16:28:30 * mmorrow keeps forkIO'ing threads that run "let x = x in x" in ghci and killThreading them because he can't believe it's true
16:28:48 <skorpan> heh
16:29:03 <harovali1> what is an IO-script ?
16:30:45 <klirrikassan> @type skorpan
16:30:46 <lambdabot> Not in scope: `skorpan'
16:31:09 <klirrikassan> skorpan :: Goeteborgare
16:31:12 <skorpan> jajemen
16:31:24 <skorpan> hur visste du?
16:32:31 <klirrikassan> @type klirrikassan
16:32:32 <lambdabot> Not in scope: `klirrikassan'
16:32:43 <klirrikassan> klirrikassan :: GenieInABottle
16:33:04 <lowmagnet> skorpan: maybe it was a bug that was making them unkillable?
16:37:50 <klirrikassan> skorpan hows your masters going?
16:37:59 <kadaver> a
16:38:00 <skorpan> kadaver: who are you? :P
16:38:08 <kadaver> you're mentor
16:38:14 <kadaver> your
16:38:28 <skorpan> really?
16:38:49 <skorpan> anyways, my thesis is coming along just fine
16:38:52 <b\6> newtype X = forall a . (Y a) => X a, 'newtype constructor cannot have an existential context'. some way to evade?
16:38:53 <edwardk1> mmorrow: nice
16:39:10 <edwardk1> b\6: yeah, use data ;)
16:39:12 <Zao> Those dastardly thesis advisors, stalking you everywhere :)
16:39:40 <edwardk1> b\6 the other alternative is if you are only using them as arguments to some other method change the signature of that method to take a rank-2 universal type
16:40:14 <b\6> edwardk1: thanks, trying.
16:43:53 <kadaver> skorpan: whats the thesis about again?
16:44:20 <kadaver> Yi and javascript verification?
16:44:25 <sioraiocht> @src uncurry
16:44:25 <lambdabot> uncurry f p = f (fst p) (snd p)
16:44:47 <skorpan> kadaver: yes, something like that
16:45:11 <kadaver> @src unchili
16:45:11 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:45:12 <kadaver> tihi
16:45:25 <tomh> @src flip
16:45:25 <lambdabot> flip f x y = f y x
16:45:41 <kadaver> hmm should 600kB file be that hard to
16:45:46 <kadaver> oh wait !! is O(n)
16:46:00 <tomh> @src !!
16:46:00 <lambdabot> xs     !! n | n < 0 = undefined
16:46:00 <lambdabot> []     !! _         = undefined
16:46:00 <lambdabot> (x:_)  !! 0         = x
16:46:00 <lambdabot> (_:xs) !! n         = xs !! (n-1)
16:46:19 <lowmagnet> IO Random is really helping me understand monads
16:46:21 <tomh> lol undefined
16:46:26 <Badger> > undefined
16:46:27 <lambdabot>   * Exception: Prelude.undefined
16:46:28 <kadaver> are arrays O(1) lookup or O(1)? i mean they are not C arrays are they?
16:46:45 <tomh> atleast show a message or something..
16:46:47 <dolio> The first O(1).
16:46:49 <dolio> Not the second.
16:47:09 <sioraiocht> @src curry
16:47:09 <lambdabot> curry f x y = f (x, y)
16:47:36 <kadaver> O(log N) vs O(1)
16:47:50 <dolio> Immutable arrays are O(1) lookup.
16:47:56 <dolio> O(n) mutation.
16:47:59 <kadaver> ok
16:48:21 <tomh> anyone here coding haskell professionally?
16:48:30 <dolio> Mutable arrays in ST or IO are O(1) lookup and mutation.
16:51:37 <kadaver> is threre a function: map toLower ?
16:51:49 <dolio> You just wrote it.
16:51:59 <vixey> @let lowercase = map toLower
16:52:00 <lambdabot>  Defined.
16:52:19 <dolio> Unless you're asking for some fancy unicode aware function, in which case the answer is "no."
16:52:37 <edwardk1> dolio: actually there is via text-icu
16:52:52 <dolio> Is there now?
16:52:53 <skorpan> kadaver: so you're my mentor? what's your name?
16:53:49 <edwardk> dolio: it has a module for leting you access icu transforms, one will do case conversion
16:56:58 <tomh> :t lowercase
16:57:00 <lambdabot> [Char] -> [Char]
16:57:56 <kadaver> strip :: Char -> String -> String
16:57:56 <kadaver> strip c = join . init . tail . group . ([c] ++).(++ [c])
16:58:17 <Zao> > lowercase "Λ" == "λ"
16:58:20 <lambdabot>   True
16:58:21 <kadaver> wait
17:05:14 <dancor> how does lowercase interact with locale?
17:05:27 <mauke> not at all, I hope
17:06:25 <dancor> oh unicode casing is locate-independent?
17:06:34 <dancor> s/ate/ale
17:07:01 <dancor> looks that way
17:09:58 <sjanssen> dancor: the lowercase function doesn't depend on locale, but I think proper Unicode casing might
17:10:31 <tomh> @src toLower
17:10:31 <lambdabot> Source not found. My brain just exploded
17:10:36 <dons> anyone want to file a ticket to improve the performance of Data.HashTable (it hopelessly fails to inline, and has never been performance-tested afaik)
17:11:12 <tomh> :t toLower
17:11:13 <lambdabot> Char -> Char
17:11:29 <dolio> Someone on the reddit story said there's a fundamental flaw in GHC's garbage collector that prevents it from being fast.
17:12:24 <bremner> dolio: what to the hold up as a fast GC?
17:12:48 <dolio> What?
17:13:07 <bremner> what _do_ they hold up
17:13:09 <bremner> sorry
17:13:40 <dolio> Oh, they didn't. They were just explaining that the particular implementation gave GHC problems.
17:13:53 <dolio> Apparently it's internally an IOArray Int [(k,v)] or something.
17:14:03 <bremner> I see
17:14:05 <dolio> And mutable arrays pointing elsewhere in the heap is bad or something.
17:14:36 <bremner> I never used another system with good garbage collection stats, so I don't know what to expect.
17:15:21 <kadaver> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3272#a3272
17:15:41 <kadaver> so what is best, stick the chars ina s et and trim each end unitl no more chars?
17:15:57 <dolio> And people aren't working on making that fast, they're working on unboxed arrays and such.
17:16:08 <dolio> Which isn't necessarily a bad thing.
17:17:16 <kadaver> is HashTable implemented in haskll or C?
17:17:16 <kadaver> i just did one in C
17:17:25 <dolio> Haskell.
17:21:13 <sjanssen> dolio: IIRC IOArrays were fixed in a recent version of GHC
17:21:56 <Saizan_> sjanssen: "fixed"?
17:23:01 <sioraiocht> is there a way to define pure for (->a)
17:23:02 <sioraiocht> ?
17:23:10 <sioraiocht> or sorry, (a ->)
17:23:19 <dolio> pure = const
17:23:25 <sjanssen> Saizan_: the performance problems with IOArray that hurt HashTable.  This is only a vague memory
17:24:16 <dons> it's a beginner exercise to write a hashtable faster than Data.HashTable :)
17:24:27 <dons> dolio: citation needed :)
17:24:44 <sioraiocht> dolio: that function would exist in the category of sets and functions, wouldn't it?
17:24:50 <dolio> You want a pointer to the guy who said it, or actual evidence of the problem? :)
17:24:53 <Bella> http://smekaren.mybrute.com
17:24:53 <mauke> @src (->) return
17:24:53 <lambdabot> return = const
17:25:04 <dolio> I don't have the latter. :)
17:25:08 <dons> dolio: pointer is ok.
17:25:21 <dons> i think it's a bogus confusion about mutable/immutable write barriers (as the fast hashtable on the shootout shows)
17:25:30 <dolio> It's a comment by guapoo in the reddit comments.
17:26:37 <sjanssen> dons, dolio: I definitely remember there was a fundamental problem with IOArray
17:26:52 <sjanssen> "was" being the key word
17:27:30 <dons> oh, arrays of pointers
17:27:41 * Saizan_ forces dons to use an hashtable until he realeases a fast one
17:28:30 <dons> well, now harrop blogged about it I probably have to to shut him up
17:28:38 <dons> or he'll cite it for the next 3 years
17:28:46 <dons> stupid internet
17:29:02 <dolio> It's imperative we have a fast hashtable implementation for people to not use.
17:29:05 <dons> :)
17:29:06 <dons> yes.
17:29:07 <dolio> Rather than a slow one.
17:29:10 <dons> just to demonstrate it.
17:29:20 <dons> ok .home time
17:30:06 <lpjhjdh> so I'm trying to play with happstack and I keep getting System.Posix.Directory because unix-2.3.2.0 is hidden.
17:30:20 <lpjhjdh> I try to cabal install unix to get a local user copy but then I get linker errors
17:31:15 <TomMD> What is it trying to link with that gets the error?
17:31:28 <lpjhjdh> tried ghc 6.10.2 and 6.10.1, also several copies of unix and directory
17:31:56 <TomMD> I had linker errors with a couple packages before and it would usually say something like HSHaskellTemplate-X.Y.a  - so I just unregistered and reinstalled template haskell.
17:32:17 <lpjhjdh> it was from HSDirectory-1.0.0.2/3
17:32:23 <lpjhjdh> lemme see
17:32:30 <TomMD> So try unregistering and reinstalling.
17:32:31 <lpjhjdh> HSdirectory-1.0.0.3.o: unknown symbol `unixzm2zi3zi2zi0_SystemziPosixziDirectory_a11_info'
17:32:55 <Saizan_> you need to install the packages in dependecy order
17:33:15 <Saizan_> since there each library doesn't provide a fixed ABI
17:34:04 <Saizan_> i.e. if you rebuild unix you need to rebuild the packages that depend on that version of unix
17:34:10 <lpjhjdh> ah, thanks
17:35:58 <Saizan_> it can be annoying.. but until we switch to a persisent storage of packages, there's little we can do
17:38:10 <Saizan_> on the other hand, i don't think there's a strong reason to upgrade core packages like unix or directory (and with 6.10.2 they should be at the latest version)
17:38:57 <lpjhjdh> with 6.10.2 it is the latest version, but it was telling me unix was hidden
17:39:04 <lpjhjdh> which ghc-pkg list didn't show
17:39:37 <Saizan_> ghc-pkg list unix didn't show it?
17:39:46 <lpjhjdh> didn't show it as hidden
17:40:00 <Saizan_> ah
17:40:15 <Saizan_> maybe some package weren't listing it in build-depends
17:40:36 <Saizan_> Cabal hides all packages except those listed in build-depends by default
17:40:53 <klirrikassan> lolcatify "Im in Jon Harrop's pants, ripping him a new one"
17:40:53 <klirrikassan> "Im iN jOn haRrOp'z pANTS, rIpPIng HIM A New onE"
17:40:56 <Saizan_> that doesn't mean that the package is not properly installed
17:41:04 <lpjhjdh> oh, thanks, I haven't really taken the time to learn about cabal so I'm sure I'm doing something stupid
17:41:35 <sm> it's not stupid, it bites everyone learning to use cabal
17:42:29 * Saizan_ can't find the Cabal faqs
17:43:01 <sm> I had good luck with a fresh ghc 6.10.2 and just cabal install happstack recently, but that doesn't help you
17:43:33 <Saizan_> lpjhjdh: do you remember which package gave you that error, btw?
17:43:37 <sm> now and then I have to cabal install somelib --reinstall
17:43:53 <lpjhjdh> Saizan: looks like rebuilding some stuff and adding unix to build-depends did the trick :)
17:43:55 <lpjhjdh> thanks
17:44:14 <sm> cool, you should probably report that on #happs
17:45:04 <Saizan_> yeah, if it's an happstack-* package
17:45:45 <lpjhjdh> just the guestbook demo
17:45:59 <lpjhjdh> from "happstack new <dir>"
17:47:54 * Saizan_ tries it 
17:49:20 <kniu> In a monad, using do notation,
17:50:20 <Botje> haskellers do it with monads
17:50:27 <kniu> Nevermind.
17:52:14 <thoughtpolice> pumpkin_: http://github.com/thoughtpolice/generate-c/blob/7efeb9900e53ccc66649cff244bebb4ddc47132a/ex1.hs
17:52:29 <thoughtpolice> pumpkin_: it's kinda actually almost useful :)
17:52:38 <Saizan_> lpjhjdh: uhm, i don't get that problems from running "cabal install" in the directory created by happstack new project dir
17:52:58 <lpjhjdh> hmm
17:53:15 <BMeph> Has anyone heard of any kind of project trying to use other VMs/comp. models to compile/run Haskell programs, besides MS's [C/D]LR and the JVM?
17:53:16 <Saizan_> lpjhjdh: but if you can give more details or reproduce the problem someway please let us know
17:53:26 <lpjhjdh> Saizan_: will do, thanks for the help again
17:53:32 <shepheb> thoughtpolice: oooh
17:54:36 <sjanssen> @quote intel.to.optimize.their
17:54:36 <lambdabot> No quotes match. Where did you learn to type?
17:55:09 <sjanssen> @remember simonmar Wondering how popular Haskell needs to become for intel to optimize their processors for my runtime, rather than the other way around
17:55:09 <lambdabot> Done.
17:56:04 <Saizan_> auhauhhuauahua
17:56:50 <Saizan_> this connects to the quote about C being too slow since you've to embed it through 7-levels of monad transfromers
17:57:47 <zou`> is zip-archive the only lib for reading jar/tar files?
17:58:12 <thoughtpolice> shepheb: :)
17:58:17 <Saizan_> zou`: there's also tar and zlib
17:58:24 <mmorrow> poucet: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vacuum-0.0.7
17:59:24 <thoughtpolice> shepheb: I've been thinking of using it to generate SPU code on my sp3 :) it would be a neat experiment
17:59:31 <poucet> mmorrow: cheers!
17:59:35 <mmorrow> :)
17:59:39 <thoughtpolice> or perhaps generate C code, then load it back through a .so or something
18:01:24 <Saizan_> sp3?
18:01:55 <thoughtpolice> *ps3
18:03:11 <zou`> Saizan_: which is the recommended one?
18:03:35 <mmorrow> thoughtpolice: have you played with the libffi wrapper on hackage?
18:03:38 <mmorrow> it's fun
18:03:53 <mmorrow> thoughtpolice: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2029
18:04:29 <kadaver> onIOComplete: failed to grab table semaphore, dropping request 0xd; que?
18:05:12 <Saizan_> zou`: zlib is just a binding to the C lib, and tar should be of good quality, i've never used zip-archive, so i can't comment on that
18:05:33 <thoughtpolice> mmorrow: awesome :)
18:05:46 <kadaver> do people like happstack?
18:06:27 <cognominal> what is the difference between a pointed listed and a zipper?
18:06:47 <Saizan_> define pointed list..
18:07:55 <sioraiocht>  (- x Y) is a functor: Set -> Set, could it also be an arrow or no?
18:08:03 <sioraiocht> @join #math
18:08:04 <lambdabot> Not enough privileges
18:08:06 <sioraiocht> oops
18:08:07 <sioraiocht> =p
18:08:26 <zou`> Saizan_, thanks I'll give tar a try
18:09:50 <dolio> What is the proposed arrow? Arrows have two parameters.
18:10:26 <sioraiocht> dolio: X -> X x Y
18:11:07 <thoughtpolice> mmorrow: that might neat like I said to specialize some code, generate C, then load and call it. :)
18:11:09 <dolio> A -> B x Y is the Kleisli arrow for the reader monad.
18:11:23 <dolio> For monoids Y.
18:11:35 <Saizan_> reader monad?
18:11:42 <dolio> Sorry, writer monad.
18:11:53 * sioraiocht is trying to create a natural transformation eta such that eta_x: X -> [Y -> X x Y]
18:12:42 <Saizan_> that's return for the State Y monad
18:13:08 <sioraiocht> hrm
18:13:57 <Saizan_> (which is built out of Yx- and Y -> -, which are adjunctions, but i don't know what i'm saying here)
18:14:26 <sioraiocht> Saizan_: indeed they are, that's what i'm trying prove...I'm trying to define the unit and counit forumlas
18:15:24 <sioraiocht> huh, wait
18:15:26 <sioraiocht> i have it backwards
18:15:36 <klirrikassan> onIOComplete: failed to grab table semaphore, dropping request 0xd; que? what is the problem exactly?
18:15:39 <sioraiocht> X x - is an arrow, isn't it?
18:17:09 <Saizan_> it's a functor, but not an arrow, in CT arrows chage only when you change category
18:17:18 <sioraiocht> eah, that's what i was afraid of
18:18:07 <BMeph> Wouldn't X -> [Y -> X x Y] be more like return for StateT Y [], or are those brackets not what that means?
18:18:15 <dolio> What do you mean by arrows? Arrow the type class?
18:18:23 <sioraiocht> dolio: I mean as in CT =p
18:18:28 <Saizan_> and an instance of Arrow in haskell defines a subcategory of Hask where the objects are still types and the arrows are different
18:18:35 <dolio> X x - is an arrow in the category of categories, because any functor is.
18:18:43 <sioraiocht> dolio: but not in the category of sets
18:19:22 <dolio> The category of sets has functions as arrows.
18:19:31 <sioraiocht> indeed
18:19:47 <mmorrow> thoughtpolice: yeah that would totally.
18:19:53 <sioraiocht> so how do you define construction of products using functions?
18:19:58 <kadaver> insertWith (if not in map then 1 else get+1)
18:20:08 <sioraiocht> usually either <f,g> or (f x g) notation
18:20:18 <dolio> a |-> (x, a) is an arrow from A -> X x A.
18:20:19 <lpjhjdh> dolio: simple question but I'd thought there was no category of all categories.
18:20:25 <mmorrow> thoughtpolice: now that i'm on x86_64, i miss harpy
18:20:39 <sioraiocht> lpjhjdh: CAT is, i thought
18:20:53 <sioraiocht> and Cat is the category of small categories
18:20:58 <dolio> lpjhjdh: Yeah, well, you can't take it literally, because if you do you run into paradoxes like in naive set theory.
18:21:42 <dolio> At least, I imagine you do.
18:21:46 <mmorrow> there's a category of categories
18:21:57 <mmorrow> you're always working in "some universe"
18:22:46 <cognominal> saizen, the diff between a zipper and Data.List.PointedList?
18:22:52 <mmorrow> http://en.wikipedia.org/wiki/Grothendieck_universe
18:23:20 <dolio> Lawvere developed a theory of the category of categories for directly axiomatizing category theory.
18:23:45 <dolio> But I don't think you say, like, that the category of categories is an object within itself.
18:24:03 <dolio> Instead you say that it has objects with similar structure to the whole thing, or something like that.
18:24:03 <Saizan_> sioraiocht: with this diagram, i think: http://en.wikipedia.org/wiki/Categorical_product#Definition
18:24:06 <mmorrow> dolio: yeah, i'm not sure how exactly that's dealt with
18:24:14 <sioraiocht> Saizan_: indeed, i'm there =)
18:24:26 <dolio> So the category of small categories is in there, and so on.
18:24:51 <mmorrow> dolio: oh, wait. yeah so the category of (small) cateogies isn't small
18:25:02 <sioraiocht> mmorrow: nope
18:26:09 <mmorrow> so when you say "category of categories", the "within some universe" is implicit
18:26:21 <Saizan_> cognominal: ah, that PintedList is a list zipper
18:26:53 <cognominal> ok, that's a particular kind of zipper...?
18:27:33 <Saizan_> well, from each polynomial ADT you can generate its zipper
18:27:33 <sioraiocht> hrm
18:27:45 <Saizan_> i.e. the zipper for a binary tree will be different
18:28:04 <cognominal> by nature a zipper is a structure with only one iterator?
18:28:50 <Saizan_> a zipper of X is the structure which identifies a single element inside X
18:29:16 <cognominal> so, a rhertorical question for now, what if I want to navigate astructure iwth many iterators?
18:29:19 <Saizan_> and it's in geneneral formulated so that access and modification to that element is O(1)
18:29:31 <sioraiocht> well hrm
18:29:53 <dolio> mmorrow: I think the important part in Lawvere's theory was that the "category of categories" he's directly axiomatizing doesn't contain itself as an object. Rather it has objects that also follow the same axioms as the ones he's using to directly define category theory.
18:29:58 <cognominal> Saizan_, nice point indeed
18:30:06 <sioraiocht> is is possible to have some object X, and then a functor (-)^A, and X^A is then an arrow?
18:30:15 <dolio> And those objects are like representations of the category of categories of a certain cardinality.
18:30:48 <dolio> Which is maybe similar to how you can have objects in ZF that are models of ZF itself, I don't know.
18:31:38 <Saizan_> cognominal: if you want multiple points of interest you may look at higher order zippers, but i didn't find much on the subject
18:32:16 <cognominal> trees are being branched list, I could say that zipper are to navigate and manipulate them with O(1) because at one point in time I work locally on the said branched list?
18:32:35 <Saizan_> cognominal: oleg's site has some interesting code on the subject based on delimited continuations, iirc
18:32:56 <cognominal> url?
18:33:15 <kerlo> Did someone say "higher-order zippers"?
18:33:16 <Saizan_> ?google oleg delimited continuation
18:33:17 <lambdabot> http://okmij.org/ftp/Computation/Continuations.html
18:33:17 <lambdabot> Title: Continuations and delimited control
18:33:18 * kerlo plots.
18:33:25 <lpjhjdh> So is oleg putting out some of those papers in his spare time?  He works with some oceanography group correct?
18:33:50 <kerlo> Nah, zippers don't generally give you access to the top.
18:34:29 <cognominal> I am overwhelmed by the number of abstraction in haskell and haskell libraries. But I know that eventually mastering good abstractions pay a lot. One does not reinvent badly existing wheels
18:34:32 <kerlo> So has Oleg figured out how to create traversable graphs with arbitrarily many foci, mutable at any one?
18:35:04 <Saizan_> kerlo: that's what i'm wondering myself
18:35:21 <kerlo> Actually, I think the "arbitrarily many foci" requirement can be removed without loss of... something isomorphic to generality.
18:35:47 * Saizan_ uses fgl for now
18:36:03 <cognominal> "Generic Zipper and its applications" seems promising
18:36:27 <kerlo> Indeed.
18:36:59 <cognominal> bed time
18:39:24 <Saizan_> dolio: did you use CC-delcont, btw?
18:39:30 * BMeph wonders if oleg deliberately chooses topics that either 1) can be implemented in both Scheme and Haskell; 2) Are already built into either Scheme or Haskell, but aren't in the other.
18:40:23 <dolio> Use it? I packaged it.
18:40:49 <Saizan_> yeah, i was wondering if you used it in some application/library
18:41:01 <dolio> Not that I recall. I just thought it was cool.
18:41:51 <Saizan_> me too, but an example user is even cooler :)
18:42:53 <dolio> I mean, I translated Oleg's incremental parser from OCaml to Haskell with it a while back.
18:43:05 <dolio> But that's not a very serious program.
18:48:39 <ddarius> BMeph: What topic wouldn't be implementable in both Scheme and Haskell?
18:49:14 <BMeph> ddarius: "Only the Oleg Knows..." ;)
18:50:49 <BMeph> ddarius: I've noticed, though, that oleg tends to write only haskell98, if it's at all possible, although if it were possible but oleg couldn't figure it out, would we ever know?
18:51:02 <cognominal> dolio, there is a relationship with your incremental parsser and the one in yi?
18:51:17 <dolio> Doubtful.
18:51:43 * kerlo chokes down http://okmij.org/ftp/Haskell/Zipper1.lhs
18:52:05 <dolio> It's a proof of concept for how you can take any (appropriate) parser and turn it into an incremental parser with delimited continuations.
18:52:12 * cognominal should go to sleep instead to try to figure out the relaionship between continuations and prompts
18:53:07 <dolio> Where appropriate is something like parameterized by an arbitrary monad, so you can slip the continuation monad in there.
18:53:31 <dolio> The OCaml version doesn't require that, of course, because the continuations are native.
18:54:22 <kniu> Does return terminate a function?
18:54:31 <kerlo> kniu: no.
18:54:37 <kniu> kthnx
18:55:51 <jeffwheeler> gwern: In your haskell-cafe post, would 'not' do something like "numbers _not_ in the series of 1, 4, 7, . . ."
18:55:56 * kerlo pretends to ponder whether delimited continuations could be used to make a really sweet parser.
18:56:24 <gwern> jeffwheeler: my abortive idea was to also have a 'map' primitive
18:56:43 <jeffwheeler> Hmm?
18:57:00 <gwern> so the user could do something likie 'Map (Not (Equal 5))' to say the rule is 'all numbers are no equal to 5'
18:57:15 <jeffwheeler> ah
18:57:19 * jeffwheeler goes back to playing
18:58:22 * gwern wonders what with
18:58:44 <jeffwheeler> That, of course! I don't know anything about GADTs or complicated stuff, but it looks neat anyways.
18:58:48 <neoswish> hi, somebody have this problem with ghci, when it often replacing first letter of command by 'g' ?
18:59:07 <neoswish> its very annoying
18:59:17 <gwern> jeffwheeler: but I didn't provide any working source
18:59:37 <jeffwheeler> gwern: indeed; I started a scratch file just to see where playing took me
18:59:59 <gwern> oh. well if you get anywhere I'd like to know
19:00:03 <Igloo> gwern: I think good AI for Zendo would be very hard. The game is interesting when you step out of the possibilities that have been previously considered
19:00:24 <gwern> Igloo: yes, I have saved a thesis on an AI for a very similar problem
19:00:57 <gwern> part of the problem, I've been convinced, is that your selection of primitives and data can make the problem trivial, and it's easy to accidentally do so
19:01:22 <kerlo> neoswish: well, that's weird.
19:01:46 <kerlo> Can you give an example?
19:01:49 <dons> hmm. don't our fast bloom filters have a fair bit of a hashtable in them?
19:02:03 <gwern> (for example, if you take a bongard problem and encode it logically, you can write a very good 'AI' in what is probably a few lines, because you've encoded the answer, basically, as part of the logical formula)
19:02:11 <kerlo> Don't all Bloom filters use hash tables?
19:02:44 <Igloo> gwern: Well, if you have a fixed vocabulary then I don't think the game is interesting
19:02:53 <dons> http://hackage.haskell.org/packages/archive/bloomfilter/1.2.6/doc/html/Data-BloomFilter-Hash.html
19:03:02 <dolio> Bloom filters are a hash of bools, though, right?
19:03:07 <Igloo> gwern: It's like Mao, or "1000 blank cards", in that respect
19:03:17 <dolio> And they don't need to store elements for actual retrieval.
19:03:23 <dons> bit hashes
19:03:31 <gwern> Igloo: zendo players don't seem to find it uninteresting, and I haven't seen any example rules that couldn't be encoded with a basic haskell expression
19:03:35 <dons> good source of hash functions, by the looks
19:03:56 <Igloo> gwern: Players don't have a fixed vocabulary
19:04:11 <gwern> the rule is what matters
19:04:37 <gwern> what good is a large vocabulary if used only to match a rule expressed with a simpler vocabulary?
19:06:13 <Igloo> gwern: For example, in the original game, you could play several games just looking at the numbers of pieces of each colour. Then one day someone makes a rule "at least 2 pieces touch".
19:06:37 <Igloo> A week later, someone makes a rule "at least one piece points at another piece"
19:07:08 <Igloo> If you didn't put "Points at" and "Touches" in the vocabulary then you wouldn't be able to do that
19:07:28 <gwern> a more complex domain needs more primitives; one reason my interest is in numerical sequences
19:07:50 <gwern> much easier to characterize integers
19:07:55 <dons> ?bug
19:07:56 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
19:08:09 <Igloo> But the same will be true whatever you do. If you only provide "Even" and "Odd" then a rule can't involve "Prime"
19:08:33 <Igloo> And there is no challenge in discovering a rule involves "Prime" if you know that that is in the vocabulary
19:08:49 <gwern> how so?
19:09:01 <Igloo> how so what?
19:09:16 <gwern> I offered an example in the email of [2, 4, 6]; this satisfies quite a few rules expressible with the primitives I was aiming at
19:09:23 <gwern> is it any less interesting for it?
19:09:27 <Igloo> If you know the vocab then you're basically just brute forcing it
19:09:40 <gwern> most games can be seen as just brute forcing it...
19:09:44 <gwern> clue, for example
19:09:45 <Igloo> You aren't needing to be inventive, or even to think
19:09:52 <Igloo> But not Zendo!
19:10:29 <necroforest> Are there any projects that use Haskell for numerical computing/signal processing/similar things?
19:11:00 <gwern> unless zendo players are seriously using rules like 'all sequences built using a left hand have the buddha nature, and ones built with a right don't', I'm not concerned
19:12:09 <Igloo> gwern: Have you played it, OOI?
19:12:17 <gwern> no
19:12:30 <gwern> I've played mao, though
19:12:36 <dons> http://hackage.haskell.org/trac/ghc/ticket/3149
19:12:38 <dons> fix hashtable ticket
19:13:27 <dons> porting the standard ocaml hashtable prob. good enough
19:15:58 <blackdog> dons: do you want the interface to be the same? was thinking maybe a libjudy wrapper would make sense, if outside libraries are allowed
19:16:24 <dons> "allowed"?
19:16:28 <dons> there's already a libjudy wrapper
19:16:41 <dons> but we should just have a fast, haskell-only hashtable for the kiddies and trolls
19:16:43 <blackdog> ah. so what's the problem, then?
19:16:44 <blackdog> ok.
19:16:56 <gwern> ('lolol haskell cant even do a hashmap but has to use c stuff')
19:16:56 <dons> either don't have one in base, or have a decent one
19:17:02 <dons> gwern: zactly
19:17:24 <blackdog> libjudy is a massive amount of work. anyone who gets sniffy about not reimplementing that is an idiot.
19:17:29 <dons> gee, we have a kickarse bloomfilter and trie suite, but no hashtable
19:17:42 <ddarius> Moral of the story, hash tables are overrated.
19:18:04 <dons> yeah, for some reason it never popped up on anyone's "i need this" queue
19:18:25 <blackdog> that's not quite true. i desperately needed compact hash tables so i wrapped CMPH
19:18:33 <dons> mm
19:18:42 <blackdog> Tries are nice and fast (and mad props to wren for that), but they use a heap of space
19:18:52 <ddarius> blackdog: Would a generic hash table have worked for you?
19:18:52 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/PerfectHash ?
19:18:59 <blackdog> dons: yeah, that's the one
19:19:19 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bytestring-trie needs to be benchmarked
19:19:33 <blackdog> ddarius: it would have been ok, but i was able to rig it so i could get the whole set of strings to be hashed
19:19:39 <blackdog> so working out a perfect hash was faster
19:19:46 <dons> cool
19:20:07 <blackdog> dons: shit yes. I've been thinking about that: do we have a standard benchmarking suite? i remember nofib, but not sure if it's still active
19:20:32 <dons> nobench kinda is.
19:20:38 <dons> but its a bit pre-cabal old school
19:22:14 <dons> http://twitter.com/mattpodwysocki/status/1449186316
19:22:20 <dons> just so people feel better :)
19:23:08 <jeffwheeler> I think Cabal has done so much to clean up the Haskell libraries and community.
19:23:13 <jeffwheeler> It really was perfect for Haskell.
19:23:17 <sm> +1!
19:23:35 <dons> yeah, game changer.
19:23:39 <dons> should have done it 10 years ago :)
19:23:47 <gwern> yeah. I really feel vindicated for having put so much effort in cabalizing things
19:23:52 <dons> gwern: totally
19:23:57 <gwern> if it had plopped, I would have felt like such an ass
19:23:58 <blackdog> yeah. i think it's easy to underestimate how much effort it takes to get something installed
19:24:01 <dons> and there's no cabal for F#, OCaml, ...
19:24:04 <blackdog> especially if you're hacking something every day
19:24:12 <dons> so long term efficiency gain
19:24:21 <blackdog> still, CPAN has been around for donkey's years
19:24:22 <dons> a haskell package for every child
19:24:31 <dons> blackdog: not so much the auto-install aspect though
19:24:45 <gwern> ('So you spent your hacking time for ~a year doing what again?' 'Packaging software in a now-dead and useless format, which no one used even when I was packaging' 'You're an idiot')
19:24:51 <jeffwheeler> I just think back to use setup.py and similar for Python projects . . . it's hideous.
19:25:05 <dons> you're really expected   to reuse and publish work now
19:25:12 <dons> it's not ok to duplicate modules in a project
19:25:23 <dons> that's a cultural change that's really important
19:25:28 <jeffwheeler> exactly
19:25:41 <dsturnbull> except when the debian weenies get all pedantic about your internal packaging manager ala ruby gems
19:26:00 * jeffwheeler is surprised a arch-like system hasn't happened for Debian/Ubuntu yet
19:26:02 <dons> yay for debian-cabal
19:26:05 <gwern> well we learned from them
19:26:10 <blackdog> dons: what do you mean? CPAN does that...
19:26:12 <jeffwheeler> err, a popular one, I guess
19:26:12 <gwern> gems' missteps, I mean
19:26:15 <dons> haskell/debian is taking off
19:26:24 <b\6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=3275  do i need a data wrapper or something?
19:26:26 <dons> blackdog: what's the cpan equiv. of cabal-install?
19:26:31 <dons> i've never seen it in use.
19:26:36 <blackdog> cpan Acme::Foo
19:26:36 <jeffwheeler> Is it? I'd like to see something like ppa for Haskell; I'll have to look at what their solution is.
19:26:41 <dons> http://urchin.earth.li/pipermail/debian-haskell/
19:27:03 <dons> http://lists.debian.org/debian-haskell/
19:27:03 <blackdog> CPAN is glorious, it's the one thing that made hacking perl at optus bearable
19:27:07 <dons> mmm
19:27:17 <blackdog> but hackage and cabal-install are improving so fast
19:27:20 <dons> http://lists.debian.org/debian-haskell/2009/04/msg00000.html
19:27:21 <dons> woo
19:27:28 <dons> cabal-debian
19:27:29 <dons> Automatically generate a debian directory from a .cabal package. To
19:27:29 <dons> use, cd in the root directory of the .cabal project and run:
19:27:29 <dons> cabal-debian --debianize
19:27:36 <blackdog> you know you've got a good system when your first impulse is to check for libs for you do _anything_
19:27:45 <dsturnbull> oh that's cool
19:27:55 <dsturnbull> still probably suffers from how slow debian is though
19:27:59 <jeffwheeler> Cabal-debian looks like it should be used more, then. :)
19:28:04 <gwern> hm. cabal-debian is not on hackage?
19:28:12 * gwern is confuzzled. then what *is* it?
19:28:47 <dons> dsturnbull: yeah, hopefully it automates most of the grunt work
19:28:49 <gwern> maybe it's called 'debian'...
19:28:50 <jeffwheeler> I think it should be used with something like PPA which makes a repository for the latest builds automatically.
19:28:54 <dons> if you can pass 'lintian' then you're on your way
19:29:29 <Nafai> jeffwheeler: I'd love that
19:29:29 <dsturnbull> i personally use debian/ubuntu everywhere (looking at arch though..) and i would still use cabal directly
19:30:03 <blackdog> dsturnbull: true for development. often for deployment, there's an edict to use native packages.
19:30:17 <dsturnbull> i always fight the sysadms and get my way anyway :)
19:30:45 <Zao> Is there any builtin zipWithWith :: [(a -> b -> c)] -> [a] -> [b] -> [c]?
19:30:49 <Nafai> As a sys admin, I prefer to use native packages
19:31:01 <dsturnbull> in a sense, there's no difference from a bundled package in your app than if you wrote some code and deployed with in your app
19:31:24 <blackdog> dsturnbull: there is if they have to do extra work
19:31:46 <blackdog> and you don't want to bundle it yourself because you'll have to rebuild when the underlying package gets bugfixes and upgrades
19:32:20 * blackdog is still scarred by the attempt to get a perl binary from this millennium installed at optus
19:32:28 <dsturnbull> well, my reactions were formed when working with pretty poor quality system administrators
19:32:52 <dolio> @type \fs as bs cs -> getZipList $ ZipList fs <*> ZipList as <*> ZipList bs <*> ZipList cs
19:32:54 <lambdabot> forall a a1 a2 a3. [a1 -> a2 -> a3 -> a] -> [a1] -> [a2] -> [a3] -> [a]
19:32:55 <ddarius> :t zipWith3
19:32:56 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
19:33:38 <ddarius> :t zipWith3 ($)
19:33:40 <lambdabot> forall a c d. [a -> c -> d] -> [a] -> [c] -> [d]
19:34:03 <gwern> hm. debian fails to compile with a type error
19:34:51 <Cale> debian?
19:34:58 <gwern> yes
19:35:22 <Cale> ah, it's a Cabal package?
19:35:41 <gwern> yes
19:35:58 <Zao> ddarius: Ooh, sneaky.
19:36:04 <dons> gwern: cabal update?
19:36:08 <dons> wfm.
19:36:18 <Zao> Is there a similiar construct for folding?
19:36:25 <gwern> dons: yes
19:38:45 <gwern> srcinst is also broken - looks like either the module name 'Dpkg' changed or it didn't declare a dep
19:55:56 <cocon> Is there a better way to say "f >>= \x -> g >> return x"? Maybe using arrows?
19:56:39 <cocon> ("compute x, but do g before returning it")
19:57:04 <Philippa_> one of the applicative combinators ought to do the trick
19:57:12 <Philippa_> <* or *>
19:57:41 <ddarius> Yes, it's f <* g
19:58:17 <ddarius> This is, incidentally, liftA2 const f g
19:58:22 <cocon> oh cool, thanks
19:59:11 <Zao> import qualified Applicative as Magic
20:00:13 <cocon> oh
20:00:32 <cocon> actually I meant "f >>= \x -> g x >> return x"
20:00:46 <cocon> so g takes x
20:01:01 <EvilTerran> that's harder
20:01:11 <EvilTerran> the first would be Control.Applicative.<*
20:02:22 <ddarius> @hoogle (a -> m b) -> m a
20:02:23 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
20:02:23 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
20:02:23 <lambdabot> Control.Monad.Cont runContT :: ContT r m a -> (a -> m r) -> m r
20:03:20 <ddarius> @pl f >>= \x -> g x >> return x
20:03:20 <lambdabot> liftM2 (>>) g return =<< f
20:04:19 <cocon> lifting ">>"? :)
20:04:37 <cocon> > liftM2 (>>)
20:04:38 <lambdabot>       Overlapping instances for Show (m1 (m a) -> m1 (m b) -> m1 (m b))
20:04:39 <lambdabot>      ...
20:05:08 <cocon> @ liftM2 (>>)
20:05:44 <cocon> @type liftM2 (>>)
20:05:46 <lambdabot> forall (m :: * -> *) a b (m1 :: * -> *). (Monad m1, Monad m) => m1 (m a) -> m1 (m b) -> m1 (m b)
20:06:23 <ddarius> cocon: The way you originally had it is probably the clearest way.
20:06:42 <BMeph> cocon: I like to think of liftM2 as a functional converse of 'on'. :)
20:06:57 <cocon> 'on' ?
20:07:03 <BMeph> @src on
20:07:04 <lambdabot> (*) `on` f = \x y -> f x * f y
20:08:31 <cocon> @pl  \x y -> f x * f y
20:08:31 <lambdabot> (. f) . (*) . f
20:08:39 <BMeph> cocon: liftM2 (on Reader/ ((->) a)) takes the binary function and applies it to the result of two functions on one argument. Whoo, that's kind of confusing. :\
20:09:26 <BMeph> (*) `liftM2` f g = \x -> f x * g x -- like that. :)
20:09:40 <b\6> i made a type that represents any instance of C, but when i try to get the x out of 'AnyC x', i guess it's not a concrete type. the whole point was for me to be able to do C functions on whatever it is without caring about its type, but i can't even extract it.
20:09:43 <pumpkin> it's somewhat similar to on
20:09:49 <pumpkin> except it does it with one argument instead of two
20:09:55 <ddarius> liftM2 is a fork of monads (not to be confused with Haskell monads), on is a capped fork of a dyad.
20:10:11 <ddarius> http://www.jsoftware.com/help/dictionary/dictf.htm
20:10:25 <BMeph> pumpkin: ...and with two auxiliary functions, instead of one. :)
20:10:26 <ddarius> (Probably no one knows what I'm talking about.)
20:10:43 <pumpkin> yeah
20:10:46 * BMeph understands.
20:11:04 <pumpkin> choo choo
20:11:31 * BMeph thinks his new not-quite-swear phrase will be "monad-forker!"
20:12:16 <dons> anyone interested in improving Data.HashTable, add names/details to the ticket http://hackage.haskell.org/trac/ghc/ticket/3149
20:12:35 <dons> i think we can do something api-equiv, but hella faster, with not too much thinking
20:13:05 <pumpkin> maybe we could move it to ST?
20:13:08 <pumpkin> instead of IO
20:13:11 <pumpkin> that seems more friendly, too
20:13:22 <ddarius> Actually my description of on is off.
20:14:11 <EvilTerran> b\6, i think you may need a type sig with an explicit forall somewhere or something
20:14:14 <BMeph> Sweet!
20:14:17 <cocon> BMeph: looks like 'liftM2' does what 'on' does on the type level
20:14:25 <BMeph> @type on (?x) . flip id
20:14:27 <lambdabot> forall c a c1. (?x::c1 -> c1 -> c) => a -> (a -> c1) -> (a -> c1) -> c
20:14:39 <BMeph> cocon: ^^ liftM2-a-like. :)
20:15:16 <BMeph> cocon: There, 'x' is your stand-in for (*) - or (>>), in your case. :)
20:15:45 <cocon> interesting
20:15:56 <ddarius> :t (?*)
20:15:57 <lambdabot> Not in scope: `?*'
20:16:21 <BMeph> ddarius: Thus, the use of 'x'. :\
20:16:37 <ddarius> No implicit operators for you.
20:16:40 <BMeph> @unpl on (?x) . flip id
20:16:41 <lambdabot> (\ h -> on (\ a -> a ? x) (\ d -> d h))
20:16:57 <ddarius> Hah
20:17:09 <BMeph> Boo, Bad \-bot. :\
20:17:41 * BMeph tries :set -XImplicitOperatorParams...
20:18:56 <BMeph> @unpl on
20:18:57 <lambdabot> on
20:18:58 <EvilTerran> i don't think @pl knows implicit parameter syntax
20:19:43 <BMeph> @unpl on (*) . flip id
20:19:45 <lambdabot> (\ g -> on (*) (\ c -> c g))
20:20:23 <BMeph> EvilTerran: Worse, I don't think u@unpl knows 'on'. :\
20:20:35 <BMeph> s/u@/@/
20:20:44 <djsiegel> Hey, how do I write a binary literal? I write a hex literal as 0x0F, for example.
20:21:20 <BMeph> djsiegel: 0b, maybe? ;)
20:22:01 <BMeph> ...maybe not. :(
20:22:48 <djsiegel> Hehe, not :)
20:23:52 <necroforest> djsiegel, convert it to hex and leave a comment ;)
20:25:52 <jmillikin> Does anybody here know of a library for parsing bytestrings in IEEE-754 format into a Float or Double?
20:31:30 <Berengal1> Hi people, I've got a question...
20:32:45 <Berengal1> I've got an array which I'll do lots of single updates on. What's the best way to do this?
20:33:31 <Berengal1> I'll need to keep the first version, but no intermediate versions
20:41:52 <sm> so, I made a module called IO and tried import IO in ghci, but I think it's pulled in a different one. What's the smartest thing to do next ?
20:42:16 <dons> found in Data.Hashtable:
20:42:20 <dons> -- STRICT version of modifyIORef!
20:42:21 <dons> modifyIORef :: IORef a -> (a -> a) -> IO ()
20:42:21 <dons> modifyIORef r f = do v <- readIORef r let z = f v in z `seq` writeIORef r z
20:42:25 <dons> that's criminal
20:42:31 <pumpkin> hah
20:42:51 <dons>   %GC time      98.9%  (99.0% elapsed)
20:42:55 <Cale> Using Data.Hashtable in the first place is criminal.
20:42:59 <dons> that's why the benchmark is slow...
20:43:00 <pumpkin> dons: how hard would it be to put Hashtable into ST (or provide an ST interface to it?)
20:43:11 <pumpkin> Cale: we can give harrop less ammo if we fix it :P
20:43:17 <dolio> Cale: Didn't you get the message? F# is 60 times better than Haskell because of hash tables.
20:43:29 <dons> this really does do 99% GC...
20:43:30 <dons> freaky
20:43:40 <Cale> Hashtables are severely overrated.
20:43:53 <pumpkin> Cale: yeah, but it's the first thing someone from other languages will reach for
20:43:53 <dons> oh, you're shitting me. -H1G 0.7s, no -H 50s.
20:44:02 <dolio> Even slava came here to bitch about our hashtable performance.
20:44:02 <Cale> sm: Probably best to rename your module. It conflicts with the name of a module in the Haskell 98 standard. Otherwise, just make sure that the haskell98 package isn't being used.
20:44:42 <sm> thanks Cale.. trying to go slow and learn what I can from these quirks. That's helpful
20:44:51 <dons> simple profiling error on harrop's part
20:45:01 <dons> didn't check how much GC was happening
20:45:21 <dolio> I doubt he cares about the reasons.
20:45:25 <dons> indeed
20:45:28 <Nafai> dons: What does -H do?
20:45:57 <dons> initial heap hint.
20:46:05 <dons> just reducing the GC amount by a few percent is a giant speedup
20:46:15 * Nafai nods
20:47:10 <dolio> So that's nearly 2 orders of magnitude?
20:47:25 <dolio> That's more than the alleged F#/Haskell difference.
20:47:28 <dons> 50s to 6s
20:47:39 <dons> well, it's still kinda busted (89% GC time)
20:47:46 <dons> the GC has to traverse the boxed array, iirc
20:47:56 <dons> should be a way to turn that off
20:49:45 <Cale> Did he compare with Data.Map?
20:49:51 <pumpkin> of course not :P
20:50:00 <Cale> What does it look like if you compare with Data.Map?
20:50:14 <pumpkin> just as good as their hashtables, someone in the comments did it
20:50:25 <dons> IntMap would be more appropriate
20:50:30 <dons> let's see.
20:50:45 <pumpkin> he cited a cafe post about IntMap as his inspiration, that had a minor mention of hashtable, and obviously picked the hashtable
20:50:55 <dolio> Someone compared it with IntMap, and he claimed it wasn't a valid comparison, because IntMap takes asymptotically more time to look up keys.
20:50:55 <gcollins> dons: I didn't do anything special and got <1s for that hashtable benchmark
20:51:05 <Cale> Then what is the purpose of optimising Data.Hashtable? It should just be deleted.
20:51:16 <Cale> Or made to use Data.Map
20:51:30 <dons> gcollins: where's the code?
20:51:39 <dons> dolio: heh
20:51:39 <gcollins> i posted it in a comment to his website
20:52:02 <dolio> Which would probably be a questionable argument even if it were relevant.
20:52:13 <gcollins> dons: i'm "how.gauche" there
20:53:07 <pumpkin> how does hashtable work on any value?
20:53:32 <gcollins> oh never mind: i left off a zero
20:53:36 <pumpkin> oh I see
20:53:41 <pumpkin> it has a hash function you provide
20:53:42 <dons> $ time ./A  +RTS -H1G
20:53:42 <dons> Just 100
20:53:42 <dons> ./A +RTS -H1G  9.83s user 0.87s system 96% cpu 11.036 total
20:53:47 * sm thinks watch out with the defensive posts, we are sounding rather shrill
20:53:49 <dons> yeah, so hashtable with enough heap beats IntMap
20:54:05 <dons> sm, very important yes. be self deprecating, and constructively fix thiings
20:54:21 <dons> it's important to shrug off stuff, fix it, and move on.
20:54:31 <dons> since this guy's trying to poke the anthill
20:54:55 <gcollins> I wouldn't be surprised if he left off the -O2
20:55:20 <dons> well, sure. he's not really benchmarking. and he's only doing it to poke fun and win hits. but still, should fix it.
20:55:26 <sm> it's good to have someone poking critically at performance, even if he's usually wrong (I don't know if he is)
20:55:55 <dons> well, he's nuts, but doing it publically is a good motivator
20:56:11 <RowanD> gcollins (or anyone): can you post the link again?  I must have joined too late.
20:56:38 <gcollins> ~/tmp/h $ time ./Foo
20:56:38 <gcollins> 100
20:56:39 <gcollins> 18.568 secs
20:56:48 <gcollins> (with n=10000000)
20:56:55 <gcollins> http://flyingfrogblog.blogspot.com/2009/04/f-vs-ocaml-vs-haskell-hash-table.html
20:57:04 <kadaver> why are hashtables overrated? i think they are awesome...
20:57:05 <dolio> Is that IntMap with 1G heap, too?
20:57:07 <dons> so i'm getting 7s with a decent heap.
20:57:08 <gcollins> so it's 20x slower than with n=1000000
20:57:14 <kadaver> Data.Map is good enough though
20:57:30 <pumpkin> kadaver: because the O(1) typically cited is misleading
20:57:33 <gcollins> no the 19s score I just posted is default settings
20:57:34 <dons> kadaver: they're impure, fragile, non-threadsafe things
20:57:52 <dons> i'm not really happy with the current containers situation
20:58:36 <blackdog> dons: where do you lose thread safety?
20:58:43 <dolio> kadaver: Nobody's saying that maps are overrated. Just that hashtables are as an implementation.
20:58:49 <dons> hey, i wonder if having 2 cores for GC helps here.
20:58:55 <dons> since the GC is pointlessly traversing things
20:59:34 <dons> hehe. at least the GC runs in parallel
21:00:20 <gcollins> dons: -H1G made it worse for me
21:00:20 <dons>   Parallel GC work balance: 1.89 (309610432 / 164021678, ideal 2)
21:00:20 <blackdog> i probably say this too much, but for symbol table lookups and similary applications, hash tables are awesome, and quite usable in a pure way
21:00:20 <dons> best GC score I've ever seen.
21:00:20 <gcollins> ~/tmp/h $ time ./Foo +RTS -H1G
21:00:20 <gcollins> 100
21:00:20 <gcollins> 27.630 secs
21:00:20 <dons> blackdog: how do you use them purely?
21:00:20 <dolio> Hashtables certainly don't fit well in Haskell, regardless of how good the implementation is, since they as far as I can tell, would have to be in a monad.
21:00:20 <blackdog> dons: just use fromList and lookup
21:00:20 <dons> ah
21:00:25 <dons> yes, that's fine. and we should support really good versions of that
21:00:33 <dons> fill an unboxed array with a perfect hash function
21:00:33 <blackdog> so one-shot setup. it's a much narrower thing.
21:00:45 <blackdog> *small voice* PerfectHash?
21:01:08 <edwardk> i should actually gut my stm hash table implementation and turn it into a simple sorted linear hash table to see if it can out perform Data.HashTable
21:01:31 <blackdog> although i don't think i'm using unboxed arrays, come to think of it
21:02:01 <edwardk> an SLHT should have the right asymptotics without as many terrible re-alloc issues
21:02:59 <dolio> I don't think the GC time comes from reallocating the array, if that's what you mean.
21:03:18 <edwardk> dolio: it'll still suck for gc ;)
21:03:21 <dons> it comes from traversing the boxed array at the top looking for nodes to deallocate, no?
21:03:25 <jmillikin> > pl (\k -> ceiling (4 * (logBase 2 k)) - 13)
21:03:26 <lambdabot>   Not in scope: `pl'
21:03:32 <dons> so we should use a ForeignPtr-managed array
21:03:38 <dons> and deallocate the whole thing at the end
21:03:52 <edwardk> good point
21:03:56 <jmillikin> Aww, does the lambda bot not do point-free stuff anymore? I'm reading about it on the wiki, but the package is broken.
21:04:15 <edwardk> @pl \k -> ceiling (4 * (logBase 2 k)) - 13
21:04:15 <lambdabot> subtract 13 . ceiling . (4 *) . logBase 2
21:04:17 <gwern> @pl foo x y = x y
21:04:18 <lambdabot> foo = id
21:04:25 <jmillikin> Well shoot, thanks
21:04:29 <jmillikin> @pl (\k -> ceiling (4 * (logBase 2 k)) - 13)
21:04:30 <lambdabot> subtract 13 . ceiling . (4 *) . logBase 2
21:04:34 <dolio> Could you have the same interface with a ForeignPtr based implementation?
21:05:01 <dons> i think so
21:05:31 <edwardk> .me gives up trying to get vacuum-ubigraph installed. haxr/unix/a whole bunch of other stuff just seems to want different conflicting versions and the obvious patches don't work.
21:05:34 <dons> i don't feel comfortable having no decent hashtable. we're being a little too hippy-trippy not having something very fast in this space. and IntMap is still slower, and shouldn't be.
21:06:04 <mdmkolbe> @hoogle String -> [Word8]
21:06:04 <lambdabot> Prelude fail :: Monad m => String -> m a
21:06:05 <lambdabot> Control.Monad fail :: Monad m => String -> m a
21:06:05 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
21:06:27 <dons> yeah, our clever GC appears to be traversing the array completely
21:06:36 <dons> which isn't so clever for a strict, impure data structure
21:06:45 <dons> sigh
21:07:13 <dons> so we'd see another order of magnitude speedup if it didn't traverse the array
21:07:15 <edwardk> dons: alas if you ever let a reference to the hash table be transitively closed over by the hash table it'd leak like a sieve if you move to the foreign pointer version.
21:07:16 <dons> 0.6s or so
21:07:32 <dons> edwardk: yup :/
21:07:36 <dons> so what is ocaml doing?
21:08:00 <dons> since the GC alone accounts for the entire difference in performance
21:08:15 <edwardk> hrmm, if you only store unboxable things it can never close over an environment that includes the hash table itself though ;)
21:08:43 <blackdog> dons: on the unboxed array thing - how would you do that in a generic way? ATM, I have "Array Word32 a" - would i have to specialise it for various types of a?
21:08:51 <dons> http://hackage.haskell.org/trac/ghc/ticket/3149#comment:1
21:09:07 <dons> edwardk: right. so restricting to copied atomic types
21:09:20 <dons> blackdog: UA a => UVector a
21:09:22 <dons> i imagine
21:09:26 <dons> would be a good structure
21:09:36 <pumpkin> UVector?
21:09:59 <dons> whatever it is called :)
21:10:08 <edwardk> UArray or whatnot
21:10:16 <pumpkin> UArr!
21:10:36 <dolio> dons has transcended beyond the need to know the names of types in his own libraries. :)
21:10:39 * edwardk feels like he is twelve. No Uarr! =P
21:10:54 <pumpkin> yeah, it's a sign of dons having done too much haskell work
21:10:58 <blackdog> ooh, that's shiny. i reckon i can speed up my lexicon even more with that.
21:10:59 <pumpkin> when he starts forgetting his own stuff :P
21:10:59 <edwardk> hah
21:11:14 <dons> ghc is telling me that productivity in this benchmark is 1.1%
21:11:27 <sm> that's why he makes those big diagrams y'know
21:11:27 <pumpkin> so we can be 100 times faster! which takes us above ocaml :P
21:11:27 <dons> so for a 51s program, that's 0.5s if we turn off the freaking gc. and we win.
21:11:40 <dons> pumpkin: yes.
21:11:56 <dons> i'd like simon mar to fix this :)
21:12:08 <dolio> Do you have significantly more than 1.7 gigs of memory? You could try that. :)
21:12:17 <pumpkin> I wonder how I'd feel if harrop had chosen to be an asshole troll in favor of haskell against ocaml/F# instead of vice versa
21:12:33 <gwern> pumpkin: I hope we'd be quietly ashamed of him
21:12:34 <blackdog> pumpkin: conflicted? :)
21:13:05 <gwern> (somewhat like I feel about dons' more trivial haskell proggit posts)
21:13:48 <blackdog> hey, if it weren't for don's trivial haskell proggit posts, i'd never have been reddited at all :)
21:15:10 <dons> gwern: that's weird.
21:15:19 <pumpkin> gwern: dons doesn't exactly go picking well acknowledged shortcomings in F# and portray it as an objective benchmark of the languages :P
21:15:25 <performance> geographically where is the highest density of Haskell Jobs?
21:15:30 <dons> portland, oregon
21:15:34 <edwardk> i always figured it was just don'sbot doing the posting so dons wouldn't have to ;)
21:15:45 <pumpkin> lol
21:16:02 <dons> gwern: what's of concern?
21:16:06 <performance> dons, is there any more info on that?
21:16:12 <edwardk> preflex: seen lispy
21:16:12 <preflex>  lispy was last seen on #haskell 8 days, 23 hours, 6 minutes and 58 seconds ago, saying: good luck
21:16:19 <pumpkin> http://www.galois.com/
21:16:34 <dons> performance: oh, galois is here, as is psu, so there's like 50 employed haskell programmers within 5 blocks of each other.
21:16:38 <gwern> pumpkin: I didn't say the analogy was perfect in all respects; but my point is that dons's reddit postings are not an unalloyed good for haskell, and neither in harrop's trolling for ocaml/f# unalloyed goods for those languages
21:16:55 <sm> wow.. that's a haskell hub
21:16:59 * pumpkin shrugs
21:17:03 <gwern> with all these, we should hope for the moral fiber to condemn what is bad and praise what is good
21:17:07 <dons> gwern: do you have a specific example? i can always go have a beer instead of clicking 'submit' if i knew which ones suck
21:17:24 <gwern> dons: what, right now?
21:17:27 <Adamant> dons: how many Haskell programmers in NYC and London?
21:17:28 <performance> may be there are more underground haskellers in newyork/connecticut
21:17:47 <newsham> how many haskell programmers in hawaii?
21:17:49 <dons> gwern: well, i'm wondering if you had any recent examples (feel free to peruse my reddit history)
21:17:54 <pumpkin> performance: I'm in NH
21:17:58 <dons> Adamant: not sure.
21:17:58 <edwardk> we're starting to collect quite a few of them over here in boston
21:18:38 <Adamant> newsham: there's you, and maybe some students at UH, and ???
21:18:40 <performance> well if there is an easy public map that we could pin these things on, we'd get a good density map :D
21:18:45 <gwern> dons: well, ok, how about http://physics-dph.blogspot.com/2009/04/hpysics-grapefruit-and-hackathon.html
21:18:58 <necroforest> dons, you're at psu?
21:18:59 <newsham> do you know of students at UH using haskell?
21:19:00 <gwern> 'Tonight we held an IRC meeting where this and other goals of Grapefruit were discussed.'
21:19:04 <pumpkin> yeah, a haskeller map would be neat
21:19:05 <gwern> oy
21:19:19 <Adamant> newsham: no, just figured if there's a CS program there are some
21:19:25 <gwern> I've seen in ur base reddit comments longer and more interesting than that entire blog post
21:19:26 <dons> gwern: you're ashamed of that, quietly, appearing in the haskell reddit?
21:19:46 <newsham> there are several schools here with CS programs.  i dont know too much about them.
21:20:10 <performance> well the reason i ask is.. my company announced about 25% layoffs..  so there is a non zero chance of that affecting me too
21:20:11 <gwern> or 'FMCAD and AFM Submissions Open: get you some formal methods [haskell] (galois.com)'; what interest could this of your average redditer? do we really often have papers lying around we could submit to random conferences?
21:20:26 <pumpkin> newsham: are you from hawaii or did you move there at some point?
21:20:29 <gwern> if it were a post to papers *from* FMCAD whatever it is, then that'd be different
21:20:33 <newsham> I grew up here.
21:20:44 <gwern> or how about 'The Yi Blog: Haddock is back [haskell] (yi-editor.blogspot.com)'
21:20:54 <gwern> christ, that's barely of interest to yi developers!
21:21:02 <gwern> much less your usual haskeller
21:21:03 <performance> if i could find a job where they would pay beginners to Haskell, but otherwise experienced engineers, i might want to apply there
21:21:21 <pumpkin> this is awkward
21:21:24 <edwardk> gwern: the idea that grapefruit has goals is disturbing on so many levels. i try not to think about what my breakfast foods are thinking.
21:21:56 <pumpkin> I love my grapefruit juice
21:22:02 <Adamant> edwardk: it's got a lovely little thing goin' on with lemon and lime, and it can just go on forever as long as it's concerned
21:22:25 <pumpkin> I'm a big fan of most citrus
21:22:37 <Adamant> yeah, scurvy sucks
21:22:39 <pumpkin> even this one: http://en.wikipedia.org/wiki/Chinotto
21:22:41 <Adamant> arrrrr
21:22:54 <dons> gwern: its the haskell reddit. feel free to vote down conference CFPs, but I think they're a good part of the haskell culture
21:23:25 <sm> +1.. voting should work this out
21:23:41 <gwern> I'd criticize this twitter since I've no idea what it means, but it seems to've gotten a fair number of upvotes
21:23:44 <gwern> 'Haskell's purity reminds me of lemon juice: you need to add lots of water, sugar and ice to make refreshing lemonade.'
21:23:57 <dons> because it is the author of python saying that.
21:24:02 <pumpkin> criticize twitter?
21:24:11 <edwardk> it sounds like he's 'soured' on the whole experience ;)
21:24:16 <gwern> pumpkin: well, what's the noun form of stuff on twitter?
21:24:22 <pumpkin> tweet :)
21:24:26 <pumpkin> or twat
21:24:28 <pumpkin> ;)
21:24:31 <gwern> *criticize this tweet
21:24:34 <sm> my beef is I can't get haskell linked anywhere sensible in the reddit ui
21:24:47 <pumpkin> rare beef?
21:24:51 <mdmkolbe> Is there a conventional name for the [Word8] type, like String is to [Char]?  (I can define my own, but I prefer to meet convention if there is any.)
21:24:59 <newsham> mmm lemon juice
21:25:05 <performance> did any one try to port reddit to haskell?
21:25:13 <edwardk> pumpkin: yes, but wouldn't the person who tweets be a twitter? so if you want to attack guido and not the message then gwern would be grammatically correct ;)
21:25:22 <gwern> performance: if by port, you mean rewrite, then no
21:25:33 <pumpkin> oh I was just wondering which tweet gwern was criticizing :)
21:25:42 <performance> yeah rewrite, why not?
21:25:58 <pumpkin> lots of work, not much gain
21:26:01 <solidsnack> edwardk: It stands to reason that those who tweet are tweeters.
21:26:05 <pumpkin> no one interested in it I guess :)
21:26:08 <pumpkin> that person could be you
21:26:18 <solidsnack> Those who twit are twitters :)
21:26:43 <pumpkin> or twats
21:26:56 <performance> yeah , if i end up being laid off, i want to find a job where i can use and learn Haskell, so i might try something like that to get noticed :d
21:27:25 <performance> [ and learn too  before facing an interview, its always good to have failed miserably at something and recovered atleast once ]
21:27:35 <solidsnack> performance: You should write a monad tutorial or a record system proposal.
21:28:08 <performance> if only i had a dime for every other monad tutorial already out there..
21:28:50 <glguy> You could pay someone to haul off the reddit clones?
21:29:18 <Berengal1> Hi people, I have a question...
21:29:25 <pumpkin> we may have answers!
21:29:36 <Berengal1> I'm doing lots of single updates on an array. What's the best way to do this?
21:29:50 <pumpkin> there's a diffarray, but I've heard it's slower than it should be
21:29:57 <EvilTerran> 1) rethink your algorithm so you don't; or (2) STArray
21:29:58 <dons> use an IntMap ?
21:30:10 <Berengal1> I also need to save the original array...
21:30:24 <EvilTerran> Map or IntMap would make sense, then
21:30:27 <pumpkin> Berengal1: is it sparse?
21:31:00 <Berengal1> Basically what I'm doing is something like 'until done update initialArray'
21:31:05 <Berengal1> No, it's not sparse
21:31:18 <pumpkin> you could try out Diff(U)Array then
21:31:19 <pumpkin> if it
21:31:26 <pumpkin> turns out to be slow, try something else
21:31:40 <pumpkin> in theory it should be what you want
21:31:57 <EvilTerran> i thought DiffArray always turns out to be slow
21:32:01 <zou`> Data.ByteString.Lazy.readfile test.jar complained that openBinaryFile does not exists
21:32:21 <zou`> isn't openBinaryFile part of GHC by default?
21:32:23 <pumpkin> EvilTerran: is that an inherent limitation of it, or just a bad implementation?
21:33:03 <Berengal1> Also, I need to feed the algorithm random numbers.
21:33:52 <Berengal1> How do I make sure I don't reuse the old ones? getStdGen seems to always return the same generator...
21:34:11 <dons> use an infite stream of randoms?
21:34:19 <dons> zou`: hmm. it certainly is.
21:34:20 <zou`> reading a text file with the above seems to be ok
21:34:27 <glguy> don't use getStdGen
21:34:34 <glguy> if anything, use newStdGen
21:34:49 <dons> i believe this hash benchmark holds the current record for pathological GC use
21:35:04 <dons> if anyone has a program that is < 1% productive, i'd like to see it :)
21:35:10 <dons> then we can throw it at jaffacake
21:35:28 <Berengal1> Ah, would newStdGen work fine in multiple threads?
21:35:48 <dons> you'll need to use split to share a different stream amongst threads
21:35:56 <zou`> so i'm certainly confused -- it sure hope that haskell act like python re: library
21:36:07 <dons> zou`: how is the error occuring?
21:36:14 <dons> System.IO.openBinaryFile ?
21:36:25 <Berengal1> dons: Couldn't I use newStdGen in the threads themselves?
21:36:31 <Berengal1> Seems less complicated that way...
21:36:43 <dons> well, no.
21:36:47 <glguy> Berengal1, newStdGen uses an atomic operation to modify the global generator
21:36:49 <dons> you can't. since there's only 1 stdgen
21:36:55 <dons> so you have to split it
21:37:00 <glguy> newStdGen does the splitting
21:37:12 <dons> ah
21:37:15 <glguy> newStdGen = atomicModifyIORef theStdGen split
21:37:27 <dons> oh, and we get two new gens out the back?
21:37:51 <dons> still, a better model would be a single gen in main, split, then seed threads with their own infinite list
21:37:55 <zou`> dons: if the file is a text file, the read works, but if it's a binary file, then i got the error
21:37:57 <EvilTerran> pumpkin, well, it's kinda hard to say where one ends and the other begins for DiffArray
21:38:14 <dons> zou`: on what system, with which ghc?
21:38:16 <EvilTerran> pumpkin, seeing as the complexity of everything is heavily tied to the order of evaluation
21:38:26 <zou`> ubuntu, ght6.8.2
21:39:11 <dons> hmm
21:39:17 <dons> so Prelude System.IO> openBinaryFile "/tmp/f" ReadMode
21:39:18 <dons> fails?
21:39:21 <dons> in ghci?
21:39:56 <zou`> dons: so I did: Data.ByteString.Lazy.readFile foo
21:40:18 <zou`> dons: if foo is a text file, it works, but if it's a binary file, then it barfs
21:40:26 <dons> hmm
21:40:32 <dons> in ghci?
21:40:36 <zou`> yep
21:40:59 <dons> works for me with ghc 6.10.1
21:41:30 <dons> Prelude> s <- Data.ByteString.Lazy.readFile "/usr/bin/ghc"
21:41:30 <dons> Prelude> print (Data.ByteString.Lazy.head s)
21:41:30 <dons> 35
21:41:34 <pumpkin> zou`: barfs how?
21:42:18 <jeffersonheard> I'm beginning to wonder if I ever sleep...
21:42:35 <sm> ha jeffersonheard .. sleepless week ?
21:43:11 <jeffersonheard> yeah, kind of.  lot of work, not a lot of time.
21:43:14 <dons> hmm. we should have a 'containers challenge' to implement a program to hold a dictionary of 1M int-indexed strings, and process them in some way, to identify the current best space/time libs for these container indexing problems
21:43:24 <jeffersonheard> you guys see the tip of the iceberg when I make three releases in one week
21:43:31 <zou`> hmm, exit out of ghci in emacs, then redo it seems to have fixed the issue
21:43:43 <pumpkin> zou`: you mean it crashed??
21:44:14 <zou`> no, it complained that it can't find openBinaryFile,
21:44:19 <sm> ouch.. know what you mean
21:44:37 <pumpkin> zou`: could you actually paste the error?
21:44:43 <jeffersonheard> zou' I've seen that before, too
21:45:00 <dons> jeffersonheard: :D
21:45:15 <zou`> i don't have the session anymore, i don't know if this has anything to do with i was running the ghci inside emacs
21:45:18 <dons> "can't find" implies missing modules, no?
21:45:28 <dons> like System.IO isn't in scope
21:45:32 <dons> or base?
21:45:57 <zou`> i thought by default these get loaded
21:46:58 <dons> could you try a standalone ghci session please?
21:47:03 <dons> and paste the error into a paste bin
21:47:04 <dons> ?paste
21:47:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:48:31 <dons> the bloomfilter library is a thing of beauty
21:48:38 <zou`> hmm, this doesn't happen anymore
21:48:57 <jeffersonheard> dons: I kind of wonder if you ever sleep too, sometimes.
21:49:00 <dons> why can't we have a hashtable like this.
21:49:04 <dons>     , bitArrayB :: {-# UNPACK #-} !(UArray Int Hash)
21:49:13 <Zao> "bloom filter" heads down the graphics postprocessing path of my brain.
21:49:47 * dons votes bos to spit out a fast hashtable
21:50:03 <pumpkin> :o
21:50:20 * glguy suspects dons sense of democracy is confused ;)
21:50:27 <pumpkin> lol
21:50:35 <dons> isn't this how things work?
21:50:58 <dons> it's like being voted off the island
21:51:07 <dons> you're voted onto low level mutable array hacking
21:52:49 <dons> should i compare haskell's bloomfilter library against non-existant ones in F#?
21:52:57 * dons laughs quitely
21:53:59 <pumpkin> how do the newfangled built-in unit primitives in F# compare to the haskell module?
21:54:26 <jeffersonheard> @seen jonharrop
21:54:27 <lambdabot> I haven't seen jonharrop.
21:54:47 <pumpkin> @seen jdh30
21:54:48 <lambdabot> I haven't seen jdh30.
21:54:55 <dons> bloomfillters get to use UArray, hashtable gets to use IOArray
21:55:15 <dons> i wonder how much we could get if we could avoid the need to use a boxed mutable array
21:55:25 <dons> so no         buckets :: !(HTArray [(key,val)])
21:55:48 * edwardk wishes the bloomfilter lib carried a phantom type parameter indicating the size of the bloom so you could do fast unions and intersections on them. (and make a monoid instance)
21:56:05 <dons> edwardk is obsessed with monoid instances in spring
21:56:28 <edwardk> unfortunately its a big breaking api change
21:56:38 <edwardk> dons: yes, i'm also obsessed with bloom filters =)
21:57:06 <pumpkin> bloomonoid
21:57:35 <edwardk> most of the interesting bloom filter ops require agreement in bucket count, hash count and hash algorithm. which dovetails with the reflection stuff i've been doing lately
21:57:53 <edwardk> maybe i should just do a tiny reflected-bloom lib or something
21:58:36 <dons> so not using chaining, but via open addressing
21:58:43 <dons> and we can then use unboxed (resizable) arrays
22:00:35 <wli> dons: What kind of keys is it supposed to support?
22:00:45 <pumpkin> any key you can provide a hash function for?
22:00:46 <dolio> Why use reflect? They already store that stuff, don't they?
22:00:47 <dons> yes, that's the drawback.
22:01:10 <dons> so we'd be hasing UA values only.
22:01:32 <dons> and using no boxed structures in the implementation (so GC free, fast, same as in an imperative language)
22:01:42 <dons> downside is that's it is even more useless
22:01:43 <edwardk> how safe is it to kill support for 6.8 these days?
22:02:10 <edwardk> dolio: they do, but the monoid only works if they agree
22:02:23 <edwardk> dolio: the reflection is a way to force term agreement at the type level
22:02:29 <dolio> Yeah. But you don't need to use reflect to add a region parameter. You just add one.
22:02:57 <wli> I don't see why it couldn't be polymorphc over an MArray-constrained array constructor.
22:03:31 <edwardk> dolio: the reflect instance on the tag makes it so you don't store them in every instance of the bloom.
22:03:36 <wli> I guess it might be less efficient.
22:04:36 <edwardk> dolio: i prefer types that can't have bad inhabitants. doing both branding and carrying is the worst of both worlds in some sense because now you have the overhead of carrying, and the risk of accidentally not respecting the brand
22:06:27 <wli> The hashtable doesn't look so bad offhand.
22:08:09 <dons> bah, i try to use 1M ints as keys to 1M values in a uvector, and of course index (enumFromTo ) fuses away entirely
22:08:56 <performance> has any one faced problems with cabal install on vista? probably due to spaces in paths like Program Files . ?
22:09:33 <dolio> What's the benchmark by the way? Store (i,i) for all i from 1 to a million in a hashtable or something like that?
22:09:41 <dolio> I should probably actually look at it. :)
22:09:48 <dons> right, so if it is perfect hashing, and we use uvectors, it takes 0.132s to allocate and index
22:09:58 <dons> so uvectors would be a suitable backend for a perfect hash here.
22:10:20 <dons> so the question is could you do something moderately efficient, avoiding the boxed array GC blackhole
22:10:21 <edwardk> dons is obsessed with hashtables in spring ;)
22:10:29 <dons> and still keep fairly general key/element types
22:10:39 <pumpkin> so using MUArr you mean?
22:10:40 <dolio> It's not totally his fault. :)
22:11:15 <dolio> Oh, 10 million.
22:13:15 <solidsnack> Can any one recommend a paper that highlights the difficulty with type inference in the present of sub-typing?
22:13:26 <wli> What's the boxed array GC blackhole?
22:13:51 * edwardk notices newtype instances in a data family for the first time and is blown away.
22:14:18 <edwardk> solidsnack: did you read tapl?
22:14:27 <solidsnack> edwardk: No.
22:14:35 <solidsnack> Do I have to read the whole thing?
22:14:43 <dons> dolio: any thoughts on a UA a => based hashtable ? how'd we do that?
22:14:44 <solidsnack> I will if I have to :)
22:14:46 <edwardk> solidsnack: pierce being the guy who discovered most of the problems with it gives a nice writeup in there
22:15:00 <solidsnack> edwardk: Interesting, thanks.
22:15:01 <dons> we'd need open addressing, wouldn't we, no chaining on collisions
22:15:14 <edwardk> solidsnack: no, you can skip to the punchline more or less, but there is a nice encoding of a turing machine as a subtyping problem near the end
22:15:15 <dolio> dons: I don't see how you'd do it except for both UA key and UA value.
22:15:23 <dons> yes, that's fine.
22:15:26 <dons> UA key is always the case
22:15:40 <dons> and UA value might be enough for a lot of string-based counting problems
22:15:47 <dons> i.e. stupid benchmarks :)
22:15:51 <edwardk> hah
22:15:54 <dolio> And, yeah, you'd need to do the version of hash table I actually learned in college, instead of the linked list bucket version everyone seems to use.
22:16:11 <dons> it's a bit weird we don't use an IntMap instead of a [(Int,a)]
22:16:24 <wli> Open addressing vs. separate chaining.
22:16:38 <wli> dons: That's called tree hashing, and it's good.
22:16:41 <dons> yep
22:16:51 <dons> well, using a patricia trie :)
22:17:21 <dons> but anyway, collisions aren't the problem. it is the GC not liking boxed, mutable arrays
22:17:38 <Berengal1> The strange thing about Haskell is that once you've implemented the data structures and the algorithm you find that you are done. In Java, that's just when the fun begins...
22:17:39 <dons> while unboxed mutables ones are ok. so our constraint is to use only MUArr/UArr
22:17:42 <wli> What is the GC problem with boxed mutable arrays?
22:17:46 <dolio> It's been so long since I took the class the covered hash tables.
22:17:59 <dons> write barrier super duper expensive? need to find where this is written up
22:18:01 <dolio> You need to think about load factors and stuff.
22:18:03 <edwardk> wli: er 'that you have to' =)
22:18:13 <dolio> And when to reallocate your array and stuff.
22:18:18 <edwardk> wli: the whole array gets traversed
22:18:25 <dons> http://hackage.haskell.org/trac/ghc/ticket/650
22:18:27 <dolio> So much work.
22:21:11 <wli> Okay, so it's the indirection requiring the GC to go around futzing with every entry in the array.
22:21:16 <dons> data Hashtable = Hashtable {
22:21:16 <dons>         keySize   :: {-# UNPACK #-}!Int,
22:21:16 <dons>         noOfSlots :: {-# UNPACK #-}!Int,
22:21:16 <dons>         spine     :: {-# UNPACK #-}!(Ptr Word8)
22:21:16 <dons>     }
22:21:21 <dons> is what we use on the shootout :)
22:21:56 <wli> Like my B+ tree example in my anti-refcounting rants.
22:22:33 <wli> spine?
22:23:31 <dolio> Are strict bytestrings UA-able?
22:23:37 <edwardk> wli: yeah its one of those scenarios where a region based collection would be handy, make hashtables contents reside in a region that can't contain references back out to the region that contains the hash table itself et voila, you can stop tracing as the table.
22:23:52 <dolio> BSArr = IntArr * IntArr * PtrArr or something?
22:23:54 <pumpkin> dolio: sounds painful
22:23:57 <dons> dolio: hmm.
22:24:26 <wli> edwardk: I didn't know regions could do that.
22:24:38 <pumpkin> the possibility of the ForeignPtr being anywhere might make that hard?
22:24:51 <dons> i'm inclined to submit a patch against Data.HashTable citing this bug
22:24:57 <edwardk> wli: well, it'll leak memory like a sieve while you have the hash table around ;)
22:25:06 <dons> just explaining why you should really not consider using Data.HashTable for anything serious
22:25:09 <dons> mark it deprecated...
22:25:38 <dons> and use open addressing unboxed for a replacement for people who really want a hash
22:25:51 <dons> (prob. faster than Data.IntMap, if HashTable is with sufficient heap)
22:26:08 <dons> anyone have other thoughts?
22:26:13 <wli> Hash tries
22:26:31 <dons> actually just use a generalized trie?
22:26:51 <dolio> I guess I don't actually know how to store a Ptr in an array...
22:26:53 <wli> Kind of like tree hashing, except with another open-addressed hash table in the collision chain.
22:27:03 <dons> dolio: Ptr a is a valid unboxed type
22:27:34 <wli> dons: It's a trie with a huge branching factor that keeps its node sizes down via hashing by open addressing.
22:28:07 <dons> but i don't    think that avoids the need for a boxed array, does it?
22:28:08 <performance> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2036#a2036
22:28:19 <dolio> Yikes, ForeignPtr is more complicated than I thought.
22:28:24 <dons> so, the broader question then is which haskell container is best for which circumstance
22:28:26 <performance> need help with installing time
22:28:28 <dons> dolio: :)0
22:28:40 <dons> a survey paper for the HW? :)
22:29:03 <dolio> I guess the odds of storing that in an unboxed array are pretty low.
22:29:45 <dons> i suppose we could go via Storable
22:29:49 <dons> and sidestep the GC entirely
22:30:07 <wli> dons: The internal nodes' indices are just Int or some such, and the entries are not too exciting.
22:30:08 <dons> do our own memory management under the hood
22:31:36 <sm> performance: http://www.nabble.com/1,000-packages,-so-let's-build-a-few!-td21767890.html talks about this, perhaps you need MSYS
22:32:40 * edwardk never thought he'd say that he wished he'd spent more time studying differential geometry, but here I am.
22:33:22 <wli> Grassman stuff?
22:34:30 <edwardk> wli: nah there i'm pretty comfortable, used it for stabbing line problems, in this case a lot of pushforward differential geometry stuff i'm trying to see how to make sense of in these minimalist seminearrings i've been playing with
22:34:50 <edwardk> wli: trying to see how reverse mode AD would work in this setting basically
22:36:11 <dons> hmm. so could we do a hashtable that was an UArr of Ptr a ?
22:36:51 <edwardk> if you're going all the way to a Ptr a what keeps you from doing separate chaining in the Ptr's?
22:37:13 <dons> yeah, may as well.
22:37:29 <dons> unboxed array of Ptr (IntMap) ...
22:38:13 <dons> ?hoogle a -> Ptr a
22:38:14 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
22:38:14 <lambdabot> Prelude id :: a -> a
22:38:14 <lambdabot> Data.Function id :: a -> a
22:38:23 <dolio> Can you make a Ptr to an IntMap?
22:38:25 <dons> a -> Ptr a is that a thing?
22:38:32 <edwardk> i wonder if there is some kind of brand/tag/quantification trick that could make it hard to type a hash table that contained a reference to itself precluding the sort of uncollectable cycle that would make that leak
22:38:33 <dons> i can't do that, can I.
22:38:51 <dolio> I thought you could only malloc space for storable stuff.
22:39:07 <dons> i want to use haskell structures for elems, but i don't want the GC traversing the top level.
22:39:12 <dons> and i want to use IntMap for chaining
22:39:47 <dons> "Dropped milestone. Some of this work has been done in 6.6 already: mutable arrays are only traversed during GC if they were modified since the last GC (although they remain on the mutable list), and IORefs are only placed on the mutable list when they are modified. Threads are also marked as clean/dirty to avoid traversing a thread's stack if it hasn't run since the last GC. "
22:40:24 <dons> so if you froze a hashtable once it was full, we'd be ok too, i think.
22:40:30 <dolio> It talks about only marking 4/8k chunks. But that still seems like a lot.
22:41:05 <dolio> > 4 * 1024 / 8
22:41:07 <lambdabot>   512.0
22:41:26 <wli> ... at most
22:41:40 <Eridius> dolio: did you really need to ask lambdabot to tell you what 1024/2 was?
22:41:43 <wli> There's usually a fair amount of fluff surrounding pointers.
22:41:44 <dons> hehe
22:41:48 <edwardk> so they basically use a card marking scheme for array update flagging?
22:41:52 <dolio> Eridius: Yes.
22:41:57 * Eridius chuckles
22:41:59 <wli> edwardk: not yet
22:42:13 <dolio> Eridius: At least I didn't do 8 * 1024 / 8.
22:42:16 <Eridius> hah
22:42:27 <wli> edwardk: They just write down whether mutable arrays were modified or not.
22:42:38 <edwardk> ah
22:42:55 <dolio> They talk about card marking, but haven't done it.
22:42:57 <jeffwheeler> > 2 / 2
22:42:59 <lambdabot>   1.0
22:43:04 <jeffwheeler> @type (/)
22:43:06 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:43:36 <jeffwheeler> @src Fractional
22:43:36 <dons> card marking isn't done.
22:43:37 <lambdabot> class  (Num a) => Fractional a  where
22:43:37 <lambdabot>     (/)             :: a -> a -> a
22:43:37 <lambdabot>     recip           :: a -> a
22:43:37 <lambdabot>     fromRational    :: Rational -> a
22:43:39 <dons> so at the point, it'd be solved
22:43:40 <edwardk> anyone here familiar with reverse mode automatic differentiation?
22:43:46 <dons> but we might be able to fix hashtable before then
22:43:57 <dons> so is this why bulat complains about mutable arrays?
22:44:19 <edwardk> dons: but since they do array marking, could you fake card marking by just dealing with an array of arrays at the grain size you'd want the cards to be marked at?
22:44:32 <wli> edwardk: I'm lost as to what you mean by it.
22:44:42 <dons> mmm
22:44:48 <dons> edwardk: clever :)
22:44:57 <edwardk> i.e. just chunk your hash table into 8k chunks
22:45:21 <dons> yep
22:45:37 <dons> that might be the easiest modication
22:45:46 <edwardk> i was using a bilevel scheme for my SLHT and never had any GC issues, that may be why
22:45:47 <dons> so then we'd want to avoid linear search i guess
22:46:10 <wli> dons: You don't need to keep a whole 8K chunk; structuring as a hash trie lets less populated chunks eat less space.
22:46:15 <edwardk> otoh, i wasn't particularly watching for them
22:47:11 <dons> wli: what's the top level type?
22:48:16 <dons> sometimes it would be fun to compile with -fno-use-gc
22:49:10 <wli> dons: STUArray s Int (STUArray s Int t) if a fixed-level scheme / fixed-width key is used (as per flexible arrays).
22:50:19 <wli> I've not tried to be unboxed etc. before.
22:53:00 <dons> oh, maybe the top level could be STUArray Int (Ptr Int)
22:53:10 <wli> I guess it goes: hash trie with Int key --> flexible array --> hash table with small enough chunks not to kill the GC
22:53:11 <dons> then the second thing is actually a Ptr t
22:53:26 <dons> oh , i see.
22:53:35 <dons> yes. small enough at the top level GC traversal won't hurt
22:53:43 <dons> but faster than just using a single trie
22:54:09 <dons> interesting.
22:54:25 <wli> dons: Assuming it's sparsely populated enough there are no pieces that get too big.
22:55:25 <BMeph> wli: Did you answer my question earlier? (Just got home from work a half-hour ago.)
22:55:44 <wli> BMeph: I doubt it. I never remember seeing a question from you.
22:57:08 <wli> dons: Like I said earlier, huge branching factors can be gotten away with because hashing by open addressing keeps the arrays in the nodes only as big as needed.
22:58:40 <BMeph> wli: Okay. I asked if you had a certain scheme for the data types for futzing around with the SQUFOF stuff. I'm sure it's not a big ticket project, it was just idle curiousity.
22:59:31 <wli> BMeph: If you can figure out SQUFOF from the lousy docs congratulations to you.
23:00:15 * BMeph chuckles at wli's keen insight.
23:00:36 <BMeph> wli: I was just planning on riding on your coattails. ;)
23:03:40 <sm> what's a good way to convert between n-tuples and n-argument functions ?
23:03:53 <sm> sorry I can't phrase that better
23:03:58 <wli> dons: The idea being that you can have a max node size of e.g. 8K but only pay for as much as the node is populated wrt. GC pain.
23:04:04 <sm> like uncurry, but more of them
23:04:08 <glguy> sm, pattern matching
23:04:13 <sm> aha
23:04:29 <wli> sm: uncurry3, uncurry4, et al got dumped at some point.
23:04:54 <sm> I've got 6. :) It's not very nice
23:05:12 <wli> :t let uncurry3 f (x, y, z) = f x y z in uncurry3
23:05:13 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
23:05:37 <wli> sm: I usually start nesting tuples before then.
23:05:46 <sm> nesting tuples, hmm
23:05:57 <glguy> I usually define a new data type before then
23:06:45 <sm> this all came about because I'm trying to move some code which knows about my app's options, down to the library, which doesn't
23:06:51 <wli> glguy: Occasionally there isn't an obvious type to use.
23:07:57 <wli> e.g. 3 triples of Double
23:08:10 <sm> some of the optional behaviour is useful in the library, but I don't think I can define some options there and some in the app. So, passing them in as more generic values
23:10:07 <sm> it doesn't feel very elegant. But things will improve later I expect
23:11:15 * edwardk sits around playing on the mathematics genealogy site and realizes he can trace back from his advisor to klein if he chases a trail long enough.
23:11:29 <Berengal1> How do I make a muteable array out of an immutable one without getting my face full of type errors?
23:11:49 <sm> I can't say enough about how what a godsend sp --no-exts --no-default-map -o prog ghc --make prog.hs --run  is!
23:12:04 <BMeph> Berengal1: search for "thawArray". :)
23:12:29 <Berengal1> BMeph: I've found 'thaw'...
23:13:00 <BMeph> Berengal1: Read on, MacDuff... :)
23:13:19 <Berengal1> BMeph: but it makes my screen full of type errors
23:13:29 <Berengal1> No instance for (MArray Array Visited IO)
23:17:59 <wli> Try MArray IOArray Visited IO
23:19:01 <Berengal1> MArray is a class
23:19:31 <Berengal1> I'm guessing I'm putting the signature in wrong...
23:19:35 <wli> Yes, instantiate it to IOArray instead of Array.
23:28:40 <sm> yes, new data type, much better
23:30:29 * BMeph puts his "UR DOIN IT RONG!" sign back on top of the monitor.
23:30:48 <ivanm> BMeph: since you don't have to remind yourself anymore?
23:32:17 <loupgaroublond> is there a way to get an automatic count of how many packages there are in hackage?
23:33:07 <ivanm> loupgaroublond: unique packages, or number of package versions?
23:33:29 * ivanm presumes there's a way of doing the former, since there's been enough visualisations, etc. that do stuff with hackage
23:33:54 <wli> I still can't get vacuum installed.
23:33:55 <loupgaroublond> ivanm, unique packages, i want to put a count of say: 15 out of $NUM packages from hackage done, for fedora haskell
23:34:10 <loupgaroublond> so we can set a goal of having 100% of hackage in fedora
23:34:23 <ivanm> at the very least "liftM length getListOfPackages" or something
23:34:32 <ivanm> loupgaroublond: I doubt you'd have that
23:34:36 <wli> cabal: dependencies conflict: ghc-6.10.1 requires process ==1.0.1.1 however
23:34:36 <wli> process-1.0.1.1 was excluded because ghc-6.10.1 requires process ==1.0.1.0
23:34:39 <ivanm> aren't some of them Mac OSX packages?
23:34:53 <ivanm> wli: what wants 1.0.1.1 ?
23:34:59 <ivanm> do you have both installed?
23:35:10 <ivanm> note that this is one reason why the latest cabal-install doesn't do upgrades anymore
23:35:28 <loupgaroublond> ivanm, why?
23:35:33 <loupgaroublond> ah
23:35:36 <ivanm> ;-)
23:35:43 <ivanm> or debian packages, arch packages, etc.
23:35:44 <wli> ivanm: I have no idea what's going on with it.
23:35:45 <loupgaroublond> well, i'm assuming some won't compile for xyz reasons
23:35:50 <loupgaroublond> well, you know what i mean
23:35:52 <ivanm> wli: what did you do to get that?
23:35:58 <loupgaroublond> i've at least gotta set a goal
23:35:59 <ivanm> loupgaroublond: *nod*
23:36:05 <ivanm> oh, a _goal_
23:36:10 <ivanm> those are useful things to ignore ;-)
23:36:36 <ivanm> loupgaroublond: though I suppose I must thank you, since it seems that when the maths sysadmin at uni upgrades the linux boxes I'll be able to use ghc thanks to you...
23:36:37 <wli> ivanm: su -c "cabal install --global vacuum"
23:36:41 <jakeluck> how does one do partial appliation on the second parameter but leaving the first parameter for the next application?
23:37:00 <jakeluck> e.g. map (elem _ [3,5]) [1..10]
23:37:06 <wli> jakeluck: flip f x
23:37:12 <ivanm> wli: what does "ghc-pkg list process" give you?
23:37:12 <jakeluck> aha!
23:37:16 <loupgaroublond> ivanm, thank juhp and bos, they do the actual GHC package
23:37:24 <ivanm> wli: if you want an ebuild for vacuum, just ask on #gentoo-haskell...
23:37:24 <wli> jakeluck: map (`elem` [3,5]) [1..10]
23:37:40 <jakeluck> what if it is a 3 arg thingie
23:37:41 <loupgaroublond> ivanm, i just prodded them into making packaging guidelines so i could make haskell packages
23:37:47 <ivanm> loupgaroublond: well, who's responsible for getting it into the default list of packages?
23:38:29 <Gracenotes> @pl \x -> f x y z
23:38:29 <lambdabot> flip (flip f y) z
23:38:46 <jakeluck> that could get hairy
23:39:32 <loupgaroublond> ivanm, you mean the default installation of fedora? it isn't afaik
23:39:44 <ivanm> loupgaroublond: oh? I'm pretty sure he said it was...
23:39:55 <ivanm> or it was in one of the default package lists... maybe due to xmonad?
23:40:14 <loupgaroublond> doubt it, that's not a default package by any stretch of the imagination
23:40:25 <loupgaroublond> but it's possible your sysadmin is installing it anyways
23:40:54 <Gracenotes> jakeluck: yeah. Varying the first parameter in a three-arg function isn't so common though. Generally the arguments are ordered from least likely to change to mostly likely to change
23:41:17 <jakeluck> ahhhh, so it is an api design decision, interesting
23:42:17 <jakeluck> it may actually be kind of nice to have some !! like-way to partial apply
23:43:42 <BMeph> jakeluck: If it's nice enough to you, you'll be motivated enough to write it yourself. ;)
23:44:27 <jakeluck> all in good time, i am starting to collect things that aren't written as i code more
23:45:08 <jakeluck> it is a good idea to find out what is out there already, nonetheless
23:45:52 <loupgaroublond> what's the most efficient way to do character substitutions without using full blown regular expressions?
23:46:14 <jakeluck> change the character set
23:46:41 <loupgaroublond> no no, i mean replacing @FOO@ with something else
23:47:22 <jakeluck> ahhh, string sub
23:47:44 <loupgaroublond> ah
23:48:08 <loupgaroublond> that's it?
23:48:10 <loupgaroublond> hehe
23:48:48 <loupgaroublond> i'm used to other languages then, where the most efficient way is to use some obscure mutable string library designed for high speed operations at the expense of your sanity
23:48:55 <jakeluck> i know a few ways, though you are asking for the _most efficient_
23:49:22 <Gracenotes> [Char]s aren
23:49:25 <Gracenotes> er
23:49:29 <Gracenotes> aren't terribly efficient
23:49:39 <loupgaroublond> well, loading a file, changing some strings, and then saving it again
23:50:07 <Gracenotes> ByteStrings are a bit faster for handling I/O streams, or many other things really
23:50:17 <loupgaroublond> ah
23:50:17 <Cale> loupgaroublond: I would probably use ByteString parsec.
23:50:39 <Cale> But, using a full-blown parser library for that is admittedly a bit overkill.
23:50:54 <loupgaroublond> exactly...
23:52:19 <wli> X-SAIGA has some interesting tidbits about specifying grammars for parsers.
23:52:25 <Gracenotes> loupgaroublond: are you trying to replace one character with another, or a string with another string..?
23:52:33 <loupgaroublond> Gracenotes, a string with another string
23:52:53 <loupgaroublond> chances are, string sub will be fine, i'm replacing a few lines of sed
23:53:15 <jakeluck> *cough* if you are simply reading, sub and writing, why not stick with sed?
23:54:02 <Gracenotes> hm. Well, tails might help. not sure how efficient it would be though
23:54:52 <loupgaroublond> jakeluck, because it's the tool that generates spec files from cabal files, which was rewritten from some shell scripts that grep the cabal file to something that uses Distribution to parse it
23:54:58 <Gracenotes> and so would Sonic and Knuckles, probably >_>
23:55:25 * jakeluck often advocate using the easiest tools for the job
23:55:26 <jakeluck> ahhhh
