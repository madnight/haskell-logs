01:01:08 <mreh> @go yi
01:01:10 <lambdabot> http://en.wikipedia.org/wiki/Yi
01:01:10 <lambdabot> Title: Yi - Wikipedia, the free encyclopedia
01:01:24 <mreh> @go site:haskell.org yi
01:01:26 <lambdabot> http://www.haskell.org/haskellwiki/Yi
01:01:26 <lambdabot> Title: Yi - HaskellWiki
01:41:47 <dibblego> @type \x f -> case x of [] -> []; (h:t) -> f h : t -- is there a combinator for this in the standard library?
01:41:49 <lambdabot> forall a. [a] -> (a -> a) -> [a]
01:44:31 <Gracenotes> not that I know of...
01:50:02 <ski> @let list :: as -> (a -> as -> as) -> ([a] -> as); list nil cons [] = nil; list nil cons (a:as) = cons a as
01:50:03 <lambdabot>  Couldn't match expected type `as' against inferred type `[a]'
01:50:17 <ski> @let list :: as -> (a -> [a] -> as) -> ([a] -> as); list nil cons [] = nil; list nil cons (a:as) = cons a as
01:50:18 <lambdabot>  Defined.
01:50:35 <ski> @type flip $ \f -> list [] ((:) . f)
01:50:37 <lambdabot> forall b. [b] -> (b -> b) -> [b]
02:06:12 <dibblego> @type \f x -> ((++) . (f <$>)) `uncurry` (splitAt 1 x)
02:06:13 <lambdabot> forall a. (a -> a) -> [a] -> [a]
02:06:29 <dibblego> >let k = \f x -> ((++) . (f <$>)) `uncurry` (splitAt 1 x) in k "abc"
02:06:33 <dibblego> > let k = \f x -> ((++) . (f <$>)) `uncurry` (splitAt 1 x) in k "abc"
02:06:34 <lambdabot>   Couldn't match expected type `a -> a'
02:06:41 <dibblego> > let k = \f x -> ((++) . (f <$>)) `uncurry` (splitAt 1 x) in k toUpper "abc"
02:06:42 <lambdabot>   "Abc"
02:06:47 <voker57__> how to modify one field in 'data' type?
02:07:04 <ski> > (\f -> list [] ((:) . f)) toUpper "abc"
02:07:06 <lambdabot>   "Abc"
02:07:33 <lars9> hi, who knows how to uninstall all packages installed by cabal-install?
02:07:41 <voker57__> like ???? $ Wtf {a = 2, b =3} =  Wtf {a=2, b=4}
02:08:00 <eivuokko> lars9, Assuming ghc, use ghc-pkg unregister to remove them from package database and remove the files by hand.
02:08:31 <ski> let wtf = Wtf {a = 2, b = 3} in wtf {b = 4}  -- voker57__ ?
02:10:50 <ski> > let wtf = Node {rootLabel = 2,subForest = []} in wtf {subForest = [Node {rootLabel = 3,subForest = []}]}
02:10:52 <lambdabot>   Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []}]}
02:11:50 <cayennext> I am trying to implement IO using dialogs and I have some problems with it. Process is a function that takes a request and returns response and program is a function that returns list of requests and have responses passed as argument. Please look at those 13 lines of code: http://pastebin.com/m2f1e06d0. It works well if both functions are pure ((1) in code). But when I added IO to process ((2) in code), it doesn't work. Can someon
02:11:50 <cayennext> e help me with this?
02:11:52 <ski> let ftw wtf = wtf {subForest = [Node {rootLabel = 3,subForest = []}]} in ftw $ Node {rootLabel = 2,subForest = []}
02:11:55 <ski> > let ftw wtf = wtf {subForest = [Node {rootLabel = 3,subForest = []}]} in ftw $ Node {rootLabel = 2,subForest = []}
02:11:57 <lambdabot>   Node {rootLabel = 2, subForest = [Node {rootLabel = 3, subForest = []}]}
02:16:01 <ski>   {-# LANGUAGE RecursiveDo #-}
02:16:04 <ski>   run :: IO (List Request, List Response)
02:16:12 <ski>   run = mdo responses <- process requests
02:16:23 <ski>             let requests = program responses
02:16:32 <ski>             return (requests, responses)
02:16:44 <ski> cayennext : tried something like that ?
02:16:58 <cayennext> I didn't know about this lang extension
02:17:12 <cayennext> thank you
02:17:37 <ski> Chapter 7. GHC Language Features 7.3. Syntactic extensions 7.3.6. The recursive do-notation <http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#mdo-notation>
02:18:31 <voker57__> ski: thanks
02:19:53 <ski> The Hugs 98 User's Guide - Chapter 6. Language extensions supported by Hugs and GHC - 6.1. Syntactic extensions - 6.1.1. Recursive do-notation - <http://cvs.haskell.org/Hugs/pages/users_guide/hugs-ghc.html#RECURSIVE-DO>
02:20:43 <cayennext> there's a problem: <<exception: loop>>
02:22:11 <cayennext> my code heavily relies on laziness, can it work with unfinished data?
02:23:05 <ski> possibly you need to use `~' (more ?) ?
02:23:11 <cayennext> from documentation: "The do-notation of Haskell does not allow recursive bindings". That's what I am trying to do in this code.
02:23:25 <cayennext> sorrry
02:23:34 <cayennext> thought it's about mdo
02:23:54 <voker57__> wtf {a=3} works ok, but can i use it as curried function? Like for map
02:24:20 <ski>   map (\wtf -> wtf {a = 3})
02:24:57 <voker57__> ah, lambdas
02:25:54 <Beelsebob> voker57__: usually the first thing I do when I define a record is write a bunch of boilerplate definitions:
02:26:14 <Beelsebob> setA w na = w{a=na}
02:26:16 <Beelsebob> etc
02:26:37 <voker57__> not nice at all...
02:26:48 <Beelsebob> no, record syntax in haskell fails
02:27:34 <ski> @type let foo Node {rootLabel = r,subForest = f} = (r,f) in foo
02:27:36 <lambdabot> forall t. Tree t -> (t, Forest t)
02:27:44 <ski> @type let foo t {rootLabel = r,subForest = f} = (t,r,f) in foo
02:27:46 <lambdabot> Parse error in pattern
02:28:02 <ski> @type let foo (t {rootLabel = r,subForest = f}) = (t,r,f) in foo
02:28:03 <lambdabot> Parse error in pattern
02:28:06 <ski> mhm
02:28:11 <mux> Data.Accessor helps with that
02:48:44 <cayennext> fun = do { x <- g; return 1:x }. If g = _|_, can I get head of f where f <- fun?
02:49:58 <Twey> cayennext: Yes
02:50:09 <cayennext> What extension shoul I use?
02:50:15 <Twey> No extension required
02:50:23 <Twey> Oh!
02:50:30 <Twey> Depends on the monad, though
02:50:35 <cayennext> IO
02:50:42 <Twey> Yeah, IO is strict, so that won't work
02:50:55 <Twey> x can be _|_, but g cannot
02:50:56 <cayennext> any extension magic to fix this?
02:51:10 <Twey> No â€” it doesn't make sense to â€˜fixâ€™ it
02:51:26 <Twey> Imagine if your IO actions weren't performed in the order you told them to be :-P
02:51:35 <cayennext> :)
02:53:34 <Cale> cayennext: Basically, if you have something like  do x <- undefined; return (1:x)  it has to evaluate the 'undefined' in order to tell that it isn't supposed to go and print something to screen there.
02:54:47 <cayennext> Yes, now I see what I was trying to do, I should try another way.
02:55:48 <Cale> You could use unsafeInterleaveIO to cheat though.
02:56:09 <Cale> Prelude System.IO.Unsafe> do (y:ys) <- do { x <- unsafeInterleaveIO undefined; return (1:x) }; print y
02:56:09 <Cale> 1
02:56:18 <mreh> I'm running the configure script in the ghc 6.10 binary, and I get this
02:56:19 <mreh> configure: error: cannot determine current directory
02:56:31 <Cale> mreh: What platform?
02:56:32 <cayennext> I cannot. Professor said: no unsafe.
02:56:38 <mreh> Cale: debian
02:56:47 <Twey> Good professor
02:56:49 <Cale> x86 or x86_64 ?
02:57:01 <mreh> Cale: x86
02:57:29 <mreh> it's GHC6.1.3
02:57:32 <mreh> it's GHC6.10.3
02:58:00 <Cale> mreh: Hmm, I recall getting that error when I accidentally tried to install the x86 package on a 64bit machine.
02:58:21 <mreh> Cale: I'm definately not 64bit!
02:58:27 <mreh> definitely*
02:58:39 <Cale> okay :)
02:58:59 <mreh> i've got one machine that has taken 3 hours to install cabal, and one that thinks it's 64 bit!!!
02:59:27 <dcoutts> mreh: if it's been stuck for 3 hours then something is very wrong
02:59:34 <mreh> dcoutts: its IO bound
02:59:50 <dcoutts> linking programs takes at most 30 seconds over slow NFS
03:00:07 <Cale> Maybe it's just caused by a similar problem. ISTR the GHC binary package coming with a funky version of pwd which is usually the first thing to fail if there's an incompatibility.
03:01:08 <mreh> dcoutts: I have no memory to speak of
03:01:33 <mreh> I figured it was writing and reading virtual memory the whole time
03:01:56 <mreh> stupid laptop
03:02:10 <Cale> mreh: try running   ./utils/pwd/pwd forwardslash   from the root of the package directory
03:02:16 <Cale> mreh: does it work?
03:02:59 <mreh> what does that do?
03:03:14 <Cale> It should just print the current directory you're in
03:03:18 <mreh> it reminds me of people telling you to press ALT-F4
03:03:27 <Cale> (using forwardslashes)
03:03:45 <Cale> pwd is a standard unix command, but for whatever reason, the ghc installer includes its own
03:04:15 <Cale> and usually if there's a dependency problem, it's the first place in the install to fail
03:04:17 <mreh> ./utils/pwd/pwd: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory
03:04:20 <Cale> aha
03:04:23 <Cale> So you have no libgmp
03:04:43 <mreh> what on earth is that?
03:04:55 <ski> (cayennext : it's arguable whether `unsafeInterleaveIO' actually is "unsafe", though ..)
03:04:55 <Cale> It's the C library used to implement the Integer type in Haskell.
03:05:20 <mreh> it's completely missing from my installation of GHC?!
03:05:21 <Cale> apt-get install libgmp3c2
03:05:48 <Twey> It should be a dependency...
03:05:53 <Twey> Oh, wait, you're compiling from source?
03:06:03 <Cale> He's installing the generic binary
03:06:20 <Cale> It probably should try to discover when that library is missing.
03:06:33 <Twey> Yeah
03:06:41 <Twey> I thought there were plans for an installer.
03:07:26 <Cale> It's probably that someone overlooked that ./utils/pwd/pwd is written in Haskell and linked against libgmp and so if you run it before the test for libgmp the installer will fail without telling the user anything sensible.
03:07:40 <mreh> configure: error: C compiler cannot create executables
03:07:48 <Cale> Oh, nice.
03:07:55 <Twey> >.<
03:08:28 <mreh> I think I might try and upgrade my distribution
03:09:08 <mreh> What does that even mean?!
03:09:48 <Cale> I'm a bit surprised that the C compiler needs to be able to create executables to install the binary ghc...
03:10:00 <Cale> It means that your install of GCC is broken though.
03:10:29 <Cale> (or that autoconf's script thinks it is, anyway)
03:10:35 <p_l> Cale: or that your options cause it to fail - had this with misplaced -mach
03:12:10 <kynes> hi, I'm currently using catch from Control.Exception to run functions safely in my application
03:12:21 <kynes> is there a way to specify a time limit on a function run / expression ?
03:12:35 <Cale> kynes: System.Timeout
03:12:42 <kynes> Cale, how can I use that?
03:12:49 <Cale> timeout :: Int -> IO a -> IO (Maybe a)
03:12:59 <Cale> I believe the parameter is in microseconds
03:13:01 <mreh> my ghc wont install :''''(
03:13:09 <kynes> Cale, okay thanks
03:13:18 <Heffalump> does that work with let loop () = loop () in loop () ?
03:13:22 <mreh> Cale: should I tinked with the configure script?
03:13:26 <mreh> tinker*
03:13:33 <kynes> Cale, if expression times out, what does it give as return value ?
03:13:34 <Cale> Heffalump: probably if you apply evaluate to it first
03:13:41 <Cale> kynes: Nothing
03:13:52 <Cale> kynes: and if not, it gives  Just x
03:13:56 <Heffalump> most things only interrupt when an allocation happens, and that never allocates and never blackholes
03:14:01 <Heffalump> or at least didn't the last time I checked
03:15:00 <Cale> Prelude System.Timeout Control.Exception> timeout 1000000 (evaluate (let loop () = loop () in loop ()))
03:15:01 <Cale> Nothing
03:15:28 <Berengal> Prelude System.Timeout> timeout 10000 (return (loop ()))
03:15:28 <Berengal> Just ^CInterrupted.
03:15:47 <Cale> Of course, since return is not strict.
03:16:09 <Berengal> Indeed, 's what I thought
03:17:37 <Berengal> Prelude System.Timeout> timeout 10000 (loop () `seq` return ())
03:17:37 <Berengal> Nothing
03:19:26 <mreh> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2530#a2530 <--- This is the config.log
03:19:51 <kynes> Cale, Berengal, thank you both
03:20:06 <mreh> look at the failed program
03:21:48 <Athas> How can I do unsigned arithmetic in Haskell?  Or just shift Int32's without sign extension?
03:21:56 <Bacta> @faggot Can haskell..
03:21:56 <lambdabot> Unknown command, try @list
03:22:36 <olsner> Athas: you have Word and Word32 etc that correspond to the Int types but are unsigned
03:22:44 <Berengal> > 256 :: Word8
03:22:45 <lambdabot>   0
03:22:56 <olsner> > 255 :: Int8
03:22:58 <lambdabot>   -1
03:23:23 <Athas> olsner: nifty, thanks.
03:26:09 <voker57__> @hoogle (a -> a -> a) -> (a -> a)
03:26:10 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
03:26:10 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
03:26:10 <lambdabot> Data.List foldl1 :: (a -> a -> a) -> [a] -> a
03:26:48 <kynes> I run on hugs and it says: Can't find imported module "System.Timeout"
03:27:02 <kynes> I'm on Ubuntu, is the default hugs package "minimal" ?
03:27:13 <kynes> I can import System.Environment
03:28:05 <kynes> is this an extra haskell package ?
03:28:11 <kynes> I mean Timeout
03:28:49 <Cale> kynes: Oh, it's something that comes with GHC
03:29:24 <kynes> Cale, :( I was currently using runhugs
03:30:39 <Cale> kynes: One moment while I get you a snippet of code to do a similar thing...
03:30:52 <Cale> oh, heh, we can just steal the code probably
03:31:11 <kynes> Cale, :) thanks man
03:31:15 <mreh> editline-0.2.1.0 is missing from GHC6.10.3
03:31:16 <Cale> er... hmm
03:31:45 <Cale> mreh: right, it's gotten rid of the use of editline. I think the package can be obtained from hackage still if you really need it(?)
03:32:17 <mreh> Cale: i'm installing the haskell platform with 6.10.3
03:32:28 <mreh> i think it was distributed with .2
03:33:06 <mreh> I only wanted to install the platform to get cabal, but i need cabal to install editline
03:33:10 <mreh> :D
03:33:21 * mreh sighs
03:34:07 <dcoutts> mreh: use the configure option to allow building with an unsuported ghc version
03:35:45 <mreh> dcoutts: it appears to be undocumented, short of looking in the script, is there something you would guess at?
03:36:30 <Berengal> Isn't cabal included in the ghc install?
03:36:36 <mreh> no
03:36:41 <mreh> the haskell platform
03:37:44 <dcoutts> mreh: ./configure --help
03:38:18 <Cale> kynes: ah, okay, in Hugs it can't work the same way as it does in GHC, since in GHC, what it does is to start a thread which throws an exception back to the original thread when the timeout is up, and Hugs doesn't support throwTo
03:38:20 <mreh> yeah, thanks
03:38:43 <kynes> Cale, oh
03:38:52 <Cale> kynes: So, I can just get you some code which I wrote a long time ago. The difference is that it doesn't run the timed-out computation in the original thread.
03:39:09 <Cale> http://www.haskell.org/haskellwiki/Timing_out_computations
03:39:25 <Cale> The first two snippets on that page ought to work, I think...
03:40:00 <kynes> Cale, okay I'm taking a look
03:40:46 <Cale> Oh, d'oh, hugs has no killThread either.
03:40:53 <Cale> Why are you using hugs anyway?
03:42:58 <kynes> Undefined variable "threadDelay" for 1st snippet
03:43:01 <Cale> Heh, apparently in Hugs, the ThreadId type is a synonym for ()
03:43:16 <Cale> kynes: I didn't get that... did you remember to import Control.Concurrent?
03:43:39 <Cale> But still, the killThread that it absolutely requires isn't there.
03:44:22 <kynes> Cale, yes I imported that, just as in the snippet
03:44:32 <stroan> "T a -> (a -> T a) -> a" I'm trying to make a monad, where bind ignores any operations after a certain situation holds true, simply passing on the previous state. But obviously, that does not match the requirement for bind in a monad. Is there any way to do this without making each function deal with that functionallity and making bind trivial
03:44:51 <Cale> kynes: hugs is a somewhat impoverished environment for writing actual applications.
03:45:01 <Peaker> Cale: that code is very similar to unamb's race - except it doesn't handle exceptions/etc
03:45:12 <Twey> Hugs is for learning, Yhc is for playing, GHC is for working :-P
03:45:15 <Peaker> (compete, that is)
03:45:49 <Cale> Peaker: yeah
03:45:54 <Peaker> one shouldn't write   do { resourceAllocation ; ... ; resourceFreeing }  in code -- should always use bracket, or a withResource thing
03:46:24 <Cale> Peaker: hm?
03:46:42 <Peaker> Cale: resourceFreeing should always be made to happen, even if the code in between throws or such
03:46:57 <Cale> Peaker: yyyes... I don't see what you're referring to.
03:47:00 <kynes> Cale, I was using hugs to evaluate simple Haskell codes without throwing every code piece to GHC and use the output
03:47:10 <kynes> Cale, it was a quick solution together with Python
03:47:11 <Cale> kynes: ghci?
03:47:14 <Peaker> http://www.haskell.org/haskellwiki/Timing_out_computations -- compete has forkIO's and then killThreads
03:47:20 <kynes> Cale, oh sorry, yes :)
03:47:32 <Saizan_> stroan: your monad sounds like MaybeT (State s)
03:47:40 <Peaker> and timeoutIterate has too
03:47:50 <Cale> Peaker: Well, it more or less is the abstraction wrapper.
03:48:10 <Cale> Peaker: You have to write the bracket-like-thingy somewhere :)
03:48:34 <kynes> Cale, can I use ghci just as I use runhugs ?
03:48:39 <Peaker> Cale: it could use a lower-level abstraction wrapper in it -- something like:  withThread  that scopes the operations afterwards and guarantees the thread is killed
03:48:48 <Cale> kynes: There's runghc
03:48:58 <Cale> kynes: Which works in more or less the same way :)
03:49:36 <Cale> Peaker: I'm not sure it would make it any clearer, but you can try. :)
03:50:28 <ski> stroan : define your own combinator which does what you want ?
03:50:37 <kynes> Cale, ghci throws more parse errors than hugs.. :/
03:50:53 <Cale> kynes: Can you paste the code on hpaste or something?
03:52:19 <stroan> ski: Aye. That's what I have, I'm just trying to wrap it all up into a monad at the moment.
03:52:25 <Cale> stroan: Could what you're describing be more or less similar to using a continuation?
03:53:11 <Cale> stroan: That is, you wrap the whole thing in a callCC and when you reach the condition you mentioned, you call the continuation that's been passed in?
03:53:38 <ski> stroan : maybe you could use an exception or continuation monad to abort the monadic computation when the "certain situation holds true", cutting off the rest of the bind operations ?
03:54:32 <kynes> Cale, http://pastebin.com/d39d5e2f6
03:54:51 <stroan> I'll look into these. I'm extremely new to all this. Writting this application to get my head around monads really.
03:54:53 <kynes>  parse error on input `;'  for line 9
03:55:13 <Cale> Yeah, you have a spurious ; at the end of the line there
03:55:15 <kynes> which runs fine in Hugs
03:55:15 <Cale> delete it
03:55:39 <Cale> It shouldn't.
03:55:49 <Saizan_> stroan: maybe you can paste your type and your combinator, and we can take a look
03:55:49 <ski> stroan : you might try pasting your code (and/or explaining more what you're about)
03:55:52 <kynes> Cale, I cannot delete it because it's student code :) they have built their homework around Hugs
03:56:19 <kynes> Cale, is there a way to make GHCi more flexible like Hugs ?
03:56:36 <Cale> That ; isn't correct Haskell syntax and I have no idea why hugs would accept it
03:56:55 <stroan> will do now
03:57:57 <Cale> ; is a separator, not a terminator, and is only allowed inside of blocks, which occur in the 'let' portion of a let/in (but not the in), after 'where', 'do' and 'of' for a case
03:58:29 <kynes> Cale, you're definitely right
03:58:30 <ski> (kynes : btw "Unknown post id, it may have expired or been deleted")
03:58:49 <kynes> ski, oh I'll repost
03:58:52 <kynes> ski, sorry
03:59:18 <stroan> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2531 I'm trying to write a parser.
03:59:24 <kynes> ski, http://pastebin.com/d67416773
03:59:42 <Cale> stroan: btw, you're indenting if/then/else unconventionally
03:59:59 <Cale> stroan: the normal Haskell way is to always line up the 'then' with the 'else'
04:00:00 <stroan> what would be standard?
04:00:04 <Cale> So it goes
04:00:07 <Cale> if foo
04:00:09 <Cale>    then bar
04:00:12 <Cale>    else quux
04:00:26 <Cale> Or something like
04:00:26 <stroan> ah, my every other language ever days coming back to haunt me ;)
04:00:32 <Cale> if foo then bar
04:00:37 <Cale>        else quux
04:00:44 <stroan> will change that now
04:01:01 <Cale> It makes sense if you think about it :)
04:01:25 <stroan> it does yeah
04:01:29 <stroan> just habbits
04:01:30 <Cale> The 'then' and 'else' are part of the 'if', so should be indented more than it, and are siblings, so should be indented the same.
04:01:56 <Cale> I find it works really nicely in bash scripts too :)
04:02:12 <Cale> (you can avoid semicolons :)
04:02:37 <kynes> ski, have you taken a look ?
04:02:43 <kynes> ski, I'll erase it after some time
04:03:45 <ski> > let ; in ()
04:03:46 <lambdabot>   ()
04:03:51 <ski> > let () = () ; in ()
04:03:52 <lambdabot>   ()
04:03:58 <ski> > let ; () = () in ()
04:04:00 <lambdabot>   ()
04:04:15 * ski raises eyebrow
04:04:19 <Beelsebob> > let ; a = 5 in a
04:04:21 <lambdabot>   5
04:05:09 <Cale> > (let a = 5 in a;)
04:05:11 <lambdabot>   <no location info>: parse error on input `;'
04:05:47 <Cale> You can have empty declarations in a let, but the semicolon is totally out of place in an 'in'
04:05:50 <Baughn> > let ; ; ; a = 5 in a
04:05:51 <lambdabot>   5
04:06:04 <Baughn> > let;a=5 in a
04:06:06 <lambdabot>   5
04:06:17 <Baughn> > let;a=5in a
04:06:18 <lambdabot>   5
04:06:20 <Beelsebob> looks like a good new way of obfuscating haskell
04:06:23 <ski> kynes : i think the `;' in the paste there is ok, as long as you have some declaration/signature/definition after the one defining `executeCommands'
04:06:42 <kynes> ski, yes there is
04:06:49 <kynes> ski, so indeed the code is okay ?
04:07:05 <kynes> I mean, is GHCi at fault ?
04:07:12 <Cale> ski: I don't think so...
04:07:13 <ski> kynes : not in isolation, but as a fragment followed by more top-level items
04:07:30 <kynes> ski, yes, it's used like that in the code indeed
04:07:39 <Cale> Note on line 8 the semicolon inside the 'in' which is followed by the 'else'
04:07:44 <Cale> That is not valid.
04:07:52 <Baughn> > let;a=5in;a
04:07:54 <lambdabot>   <no location info>: parse error on input `;'
04:07:55 <ski> oh .. i missed that one
04:08:10 <kynes> ski, http://pastebin.com/d2943c94f updated
04:08:47 <kynes> Cale, so there is a bug at Hugs ?
04:09:21 <kynes> I noticed that GHCi is also stricter about indentation
04:09:22 <ski> (that `in' was indented too much, so i was thinking it was another equation inside that `let' ..)
04:09:22 <dibblego> @type \f -> zipWith ($) (f : repeat id)
04:09:24 <lambdabot> forall b. (b -> b) -> [b] -> [b]
04:09:33 <dibblego> > let k = \f -> zipWith ($) (f : repeat id) in k toUpper "abc"
04:09:34 <lambdabot>   "Abc"
04:09:38 <dibblego> zing!
04:09:49 <ski> kynes : generally, one does not indent like
04:09:53 <ski>   let foo = ...
04:09:58 <ski>       bar x = ...
04:10:04 <ski>       in ..foo..bar..
04:10:14 <kynes> ski, I didn't mean the indentation is correct in the pasted code
04:10:21 <kynes> ski, I meant another code
04:10:33 <kynes> ski, but I fixed that one so cannot paste.. hmm
04:10:40 <Serica>  i wonder why whatever i specify in --host= when building ghc it always defaults to i386-unknown-linux ?
04:10:51 <Cale> kynes: Yes, it is a bug for hugs to accept that
04:11:01 <ski> (stroan : btw, s/(elem s list)/elem s list/)
04:11:43 <stroan> changed. Any idea how to make the monad do what combine does?
04:11:49 <kynes> do I have a Timeout solution I can use in Hugs ?
04:12:05 <kynes> ski, Cale, Baughn I'm erasing the post
04:12:09 <kynes> is it okay ?
04:12:29 <ski> (kynes : i already have it in browser, so sure :)
04:12:35 <Cale> sure
04:12:35 <Serica> umm i decided to ask in #ghc and close the question here
04:12:36 <kynes> ski, :) okay
04:13:15 <kynes> thank you very much for your help
04:13:42 <ski> stroan : it appears like `extract' tries to separate a longest prefix of characters all occuring in a given list
04:14:39 <ski> stroan : could you explain more what you're trying to do ?
04:14:59 <ski> how and why are you going to use `extract' and `combine' ?
04:15:46 <stroan> aye. there is also an extractWhile function that extracts till a non match. So say I want to extract an identifier which matches the pattern of a123df. The first leter must be a member of ['a'..'z'] and the rest of the letters must be of (['a'..'z'] ++ ['0'..'9'])
04:16:45 <stroan> so I call extract with the first pattern. then I call extractwhile with the second pattern. but I want such combinations to terminate when the larger pattern can no longer be matched against
04:18:18 <kynes> Cale, http://markmail.org/message/earajbrh2muzppn2#query:haskell%20base%20timeout+page:1+mid:mgpwb2rnxgzjuago+state:results
04:18:21 <ski> so `Done' means something like "cannot parse further" while `Cont' means something like "partial parse succeeded, can parse further" ?
04:18:51 <stroan> yup
04:18:59 <Cale> kynes: yes, this is the code which uses throwTo
04:19:06 <Cale> kynes: Which I was trying earlier.
04:19:26 <Cale> mm... more or less, anyway
04:19:44 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-Timeout.html#timeout
04:19:47 <ski> (stroan : so why is `Done' not called something like `NoParse' or `ParseError' or `Bad', then ?)
04:20:00 <stroan> because it's not nesecarilly a bad thing
04:20:55 <stroan> like when matching an arbitrarilly large thing. I just want to match till the pattern fails. so if I have "a+b" it will match the a, and give me a done
04:20:59 <ski> if i pass the string "1abc45" for parsing with your identifier parser, wouldn't that return a `Done' result ?
04:21:22 <kynes> Cale, ERROR "test.hs" - Unknown entity "throwDynTo" imported from module "Control.Exception"
04:21:29 <kynes> Cale, as you said
04:21:36 <stroan> it would pass a done, after having extracted nothing
04:21:46 <Cale> Right, and that's throwTo in the current library, but neither exists in hugs
04:22:03 <Cale> kynes: Hugs doesn't even have a concept of a ThreadId, so it's impossible.
04:22:14 <ski> stroan : right .. how is that not a parse error (wrt your identifier parser) ?
04:22:43 <Cale> (you can start threads, but there are no operations on them -- you can only use MVars to communicate with them, and they are responsible for stopping themselves)
04:22:57 <ski> stroan : e.g. do you expect to be able to extract some partial information for a parse, even if not the whole parse succeeded ?
04:23:49 <stroan> Because I'm building this of an LL(1) grammar, so I was going to ask it to check several possible patterns at once and only one of them may match, and return a result and whichever one does is the correct one.
04:24:11 <stroan> if multiple patterns match then it's also an error
04:24:23 <stroan> but that was going to be checked with other logic
04:25:20 <ski> mhm
04:26:10 <ski> i'm not convinced your `ParserData' is defined correctly
04:26:32 <stroan> It's probably not :/ Though this is as close to working as I've gotten the program in a few days :P
04:27:07 <stroan> A third, error, state might be required
04:27:27 <ski> btw, you're aware there are already parsing combinator libraries which you might use or at least be inspired by ?
04:27:53 <stroan> Aye. This is mostly a get to know haskell / get my head around monads project
04:27:58 <ski> i'm not sure why the type signature of `extract' should mention all those `[Char]'
04:29:12 <ski> it seems some occurances of `[Char]' there stands for the underlying list of tokens to be parsed, while other occurances of it stands for an identifier being currently implemented as a list of characters
04:29:32 <ski> what if you had an abstract type of identifiers, `Ident'
04:29:55 <ski> hm
04:30:42 <stroan> My current plan is just to tokenise / parse in one step.
04:30:51 <jkramer> Hello
04:31:15 <ski> (i realize i misread before, `extract' only does one step of identifier parsing)
04:31:26 <stroan> aye.
04:31:48 <stroan> I also have extractWhile, that extracts until done.
04:31:59 <ski> so, what would the type be of an operation for parsing a whole identifier, in your parsing combinator framework ?
04:32:15 <ski> (i'm just asking for a type signature, not an implementation)
04:32:16 <jkramer> I'm trying to install encoding with cabal, but it seems to hang at 43/47 (Data.Encoding.JISX0208). Does anyone know that problem?
04:32:33 <jkramer> ghc eats 99% of CPU
04:32:52 <jkramer> Or is that module just very hard to compile?
04:33:54 <stroan> extractIdentifier :: String -> ParserData
04:34:01 <stroan> and that raises some issues :P
04:34:04 <Saizan_> jkramer: the latter
04:34:10 <ski> `ParserData' requires a type argument
04:34:22 <stroan> ParserData (String,String)
04:34:50 <jkramer> Saizan_: But +10 minutes eating ~100% CPU on 2x2Ghz?
04:34:51 <ski> and what if an identifier had type `Ident' instead of `String' ?
04:35:15 <ski> (you may assume `data Ident = MkI String' if that makes you feel better)
04:35:46 <jkramer> The other encodings compiled in < 1s
04:36:08 <maltem> jkramer, I tried and I'm seeing the same thing. Let's see how long it takes here :)
04:36:09 <stroan> so the signature would be String -> ParserData(Ident, String)?
04:36:37 <ski> ok
04:37:07 <jkramer> maltem: May the faster machine finish first :)
04:37:26 <Saizan_> jkramer: well, two processors don't count when you're using only one :)
04:37:32 <ski> so the first occurance of `String' is the input from the point to parse an identifier, and the second occurance of `String' is the input from the point after the identifier being parsed, yes ?
04:37:33 <jkramer> That's true
04:37:41 <stroan> yes
04:37:51 <jkramer> It's not even two processors but just two cores :(
04:38:22 <jkramer> Has anyone tried turbinator yet?
04:38:23 <ski> your `ParserData m' is basically the same as `Either m m' (just other names for the two constructors)
04:38:36 <ski> so that makes your type being roughly
04:38:46 <ski>   String -> Either (Ident, String) (Ident, String)
04:39:49 <ski> iiuc, the first case (the `Cont' case) corresponds to an identifier having been parsed, and also there's some part left of the input string to parse on from
04:39:58 <jkramer> He, it just finished :)
04:40:17 <jkramer> http://en.wikipedia.org/wiki/JIS_X_0208 - sounds like a lot of characters
04:40:18 <PeakerWork> Nicer to have (Bool, Ident, String) ?
04:40:27 <stroan> Cont if the last parse was successful. Done if the last match failed
04:40:46 <ski> what is the "last parse/match" ?
04:40:52 <ski> say the input string is
04:41:04 <ski>   "a123df+1"
04:41:30 <ski> say we want to parse an identifier, and then maybe continue parsing some else with the rest of the input
04:42:14 <stroan> the last match it would perform inside the identifier parsing section would be the "+", which it would leave in place and return done
04:42:39 <stroan> so Done ("a123df","+1")
04:42:56 <ski> so is the first string there a valid identifier ?
04:43:03 <stroan> yes
04:43:12 <ski> what if the string was
04:43:20 <ski>   "(1+2)"
04:43:30 <stroan> Done ("", "(1+2)")
04:43:31 <ski> what should the identifier parser return ?
04:43:42 <ski> is the empty string a valid identifier ?
04:43:53 <stroan> Nope
04:44:06 <ski> then the types doesn't match
04:44:14 <stroan> You're right
04:44:22 <stroan> I need an error type
04:44:39 <ski> or at least a "NoParse" alternative
04:44:49 <ski> (maybe that amounts to the same thing :)
04:44:56 <stroan> :)
04:45:16 <ski> maybe it would be easier to think here of a parser of boolean values
04:45:27 <ski> the parser would parse strings as
04:45:30 <ski>   "True"
04:45:32 <ski> as well as
04:45:34 <ski>   "False"
04:45:53 <ski> also allowing there to be any amount of extra tokens/characters after those characters
04:45:59 <ski> so
04:46:17 <ski>   parseBoolean :: String -> ParserData (Bool,String)
04:46:19 <ski> maybe ?
04:47:00 <stroan> I already have a Token datatype, which I was planning on using a step later. But it's pretty clear you're completely right :)
04:47:00 <ski> (the point being that the type `Bool' doesn't contain any such dummy values as the empty string above, so one can't make a mistake in that way at least)
04:47:53 <ski> also, i'll give a suggestion, which i'm not completely sure if it applies with the kind of parsing you want to do, but anyway
04:48:24 <ski> if you feel you're having this `String -> ParserData (Foo,String)' pattern over and over, consider defining
04:48:36 <maltem> jkramer, true, that's a really tough package to compile :o (now at 45/47)
04:48:48 <ski>   newtype Parser a = MkP (String -> ParserData (a,String))  -- or something similar
04:48:52 <ski> so that you can then have
04:49:01 <ski>   parseBoolean :: Parser Bool
04:49:09 <ski>   parseIdentifier :: Parser Ident
04:49:58 <ski> (also, it might be that even though `ParserData' maybe can't be made into a monad, mayhaps `Parser' can be)
04:50:46 <stroan> hmmm, thanks for all this. It is seriously a huge help.
04:51:10 <stroan> Haskell really makes it very hard to be unclear in your thinking.
04:51:38 <ski> anyway, good luck
04:51:42 <stroan> thanks :)
04:51:42 * ski needs to leave
04:58:34 <Absolute0> Is it possible to make Map.lookup x map into a higher order function where x is the only argument, without making a helper function with reversed arguments? (let helper x = Map.lookup x setup) ?
04:59:09 <Cale> flip
04:59:12 <Cale> :t flip
04:59:13 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:59:26 <EvilTerran> (`Map.lookup` map)
04:59:28 <Cale> Or just use a lambda :)
04:59:48 <Absolute0> Cale: yeah i was using a lambda but it was to long for my example
04:59:48 <EvilTerran> or (flip Map.lookup map), or (\x -> Map.lookup x map)...
05:00:48 <Absolute0> does flip have to take 3 parameters?
05:01:02 <Absolute0> @let foo x y = x
05:01:04 <lambdabot>  Defined.
05:01:10 <Absolute0> > flip foo
05:01:11 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> a -> a)
05:01:11 <lambdabot>    arising from a use...
05:01:17 <Absolute0> :(
05:01:39 <Jedai> Absolute0: What do you mean ? flip like all functions in Haskell only takes one parameter
05:01:45 <maltem> Absolute0, that as because functions cannot be printed
05:01:49 <maltem> *was
05:03:10 <Absolute0> :t flip foo
05:03:11 <lambdabot> forall a b. b -> a -> a
05:03:32 <Absolute0> what is forall?
05:03:35 <Absolute0> :t forall
05:03:37 <lambdabot> Not in scope: `forall'
05:03:43 <Absolute0> not a function..
05:03:58 <Absolute0> oh its polymorphic?
05:04:03 <Jedai> Absolute0: forall is for all, it just means that a and b are type variables
05:04:10 <Absolute0> gotcha
05:04:16 <Jedai> Absolute0: like in mathematics
05:04:35 <Absolute0> haskell has got to be the closest language to mathematics :)
05:04:55 <Jedai> Absolute0: actually you can write forall yourself in your type annotation if you enable some extensions
05:05:25 <Cale> (It's because those extensions are enabled that the bot prints it)
05:05:34 <Absolute0> I was thinking, why can't you achieve what monads achieve by simply writing a bunch of where declarations?
05:05:38 <Cale> Specifically, RankNTypes
05:05:38 <Jedai> Absolute0: it's usually implicit, but for some advanced type manipulation, making forall explicit is necessary
05:06:04 <Absolute0> each new declaration caliing a previous one
05:06:06 <Cale> Absolute0: The point of monads is to have general operations which work across a wide class of libraries that have been recognised.
05:06:09 <Absolute0> hence having states
05:06:25 <Cale> Monads in general have essentially nothing to do with state.
05:06:29 <Jedai> Absolute0: I'm not sure where you're coming from ? Monads are nothing magic, they're just an useful abstraction
05:06:57 <Twey> Absolute0: The answer is â€˜you canâ€™
05:06:58 <Absolute0> according to most tutorials they seem to simplify state manipulation
05:07:02 <Jedai> Absolute0: If you're speaking about the State monad, you sure can do it by hand
05:07:03 <Twey> Monads don't do anything magic
05:07:06 <Cale> (To think that they do is confusing the abstraction with the application :)
05:07:07 <Twey> They just make it prettier
05:07:27 <Absolute0> Is there any nice simple to read monad tutorial out there?
05:07:29 <Cale> Absolute0: Beware, there are many poor monad tutorials.
05:07:40 <Absolute0> the majority of them seem to get too academic
05:07:53 <Absolute0> or poor as Cale said :)
05:08:03 <Jedai> Absolute0: but if you try to do it on a big example you'll soon understand why we use monads
05:08:05 <Twey> And therefore I recommend Cale's excellent Monads as Computation: http://haskell.org/haskellwiki/Monads_as_computation
05:08:28 <Cale> Yeah, actually in that one I try to explain what the point is of talking about monads at all.
05:08:44 <Jedai> Absolute0: and as other said, State monads are only a small part of what you can do with monads
05:09:11 <Cale> If all you want is any one monad, there's no point in talking about monads. For example, if all you want is IO, there's no need to recognise that it's a monad.
05:09:27 <foo-nix> twanvl, ping.
05:10:08 <Cale> It's only when you get reuse out of the general polymorphic operations in Control.Monad and elsewhere that the fact that anything is a monad becomes useful knowledge.
05:10:17 <Cale> Like, for example...
05:10:19 <Cale> :t mapM
05:10:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:10:24 <Cale> :t sequence
05:10:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:10:29 <Cale> :t foldM
05:10:31 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
05:10:36 <Cale> etc, etc.
05:11:19 <Absolute0> isn't forall superflous in the above lines?
05:11:21 <Cale> Otherwise, you're just talking about specific combinator libraries, and while even that is new for most people, it's not what monads are about.
05:11:26 <Absolute0> no type means all types...
05:11:27 <Jedai> Absolute0: it is
05:11:29 <Cale> yes
05:11:30 <Absolute0> ehh
05:11:35 <Cale> It's just being very explicit.
05:11:43 <Jedai> Absolute0: but it doesn't hurt anything
05:11:47 <PeakerWork> didn't know about foldM
05:11:54 <Absolute0> Jedai: might confuse some...
05:11:55 <Absolute0> :)
05:11:58 <Absolute0> like i was
05:12:11 <Cale> In Haskell, if you leave type variables unquantified, they're automatically forall'd at the beginning of the type signature
05:12:22 <Cale> But if you place the foralls elsewhere, the meaning changes.
05:12:38 <Jedai> Absolute0: Actually the explicit notation is rather clearer in my eyes
05:13:00 <Cale> For example,  foo :: (forall a. a -> a) -> ...  means that foo takes a function *required to be polymorphic* as a parameter
05:13:07 <Absolute0> superflous is superflous making it unecessary
05:13:11 <Jedai> Absolute0: what might be confusing is the coexistence of an implicit and an explicit notation
05:13:42 <PeakerWork> Absolute0: Monads abstract computations that can be sequenced to use previous results.  They can be used to abstract state, continuations, exceptions, side effects, and many other interesting things
05:14:00 <Jedai> Absolute0: it's not like it will tire the bot...
05:14:01 <Cale> Absolute0: But yeah, if you like, you can ignore all that part up to the '.'
05:14:26 <Cale> It's just making explicit that m is a type constructor and that a, b are types
05:14:34 <Cale> (any types, not particular ones)
05:14:40 <Absolute0> PeakerWork: regarding the "sequenced" part i mentioned that simple where clauses could do the job.
05:14:41 <Jedai> Absolute0: and being consistent (putting forall everywhere rather than only when it needs to be explicit) is not bad either
05:15:04 <PeakerWork> Absolute0: what do you mean?
05:15:20 <Absolute0> ie: where x = 5 y = x + 2 z = y + 3
05:15:42 <PeakerWork> Absolute0: That's not "sequencing computations" -- that's just creating a graph for evaluation
05:15:54 <Jedai> Absolute0: there is no sequencing in your example
05:16:12 <Cale> That is more or less the identity monad without recognising that it's the identity monad.
05:16:14 <PeakerWork> Absolute0: "sequencing computation" means "apply whatever sequencing operation the specific Monad implements" in order get exceptions, continuations, failure handling, state, etc
05:16:42 <Absolute0> i need to do some RTFM'ing
05:16:59 <Jedai> Absolute0: Don't listen to Peaker though, "explicit sequencing" is only one aspect of the capacity of monads
05:16:59 <PeakerWork> Absolute0: For example, an "exception monad" might implement the sequencing operation to ignore any computation its requested to sequence, if the previous computation has resulted in error
05:17:13 <Cale> Though, of course, let is a bit different in its typing rules than do-notation (which translates in terms of lambdas) would be.
05:17:33 <Cale> But that's not a big difference.
05:17:49 <PeakerWork> Jedai: What other aspects do you have in mind?
05:17:58 <Jedai> PeakerWork: I don't much like "the sequencing operation" to design bind (>>=), it's not the only thing that it can do
05:18:35 <PeakerWork> Jedai: I think its a legitimate POV on monads, as the "sequencing order" is always allowed to have semantic significance
05:18:40 <Jedai> PeakerWork: I don't see how the list monad enter your description exactly, for me it's not a matter of sequencing
05:18:56 <Jedai> PeakerWork: and the monads that can commute ?
05:19:01 <PeakerWork> Jedai: even the list monad sequences
05:19:07 <Jedai> PeakerWork: No
05:19:14 <Cale> Jedai: It's a certain kind of sequencing. The order in which selections are made.
05:19:19 <PeakerWork> > liftM2 (,) [1,2] [3,4] /= liftM2 (,) [3,4] [1,2]
05:19:20 <lambdabot>   True
05:19:22 <EvilTerran> Jedai, considering it to be the backtracking computation monad, >>= starts to look like sequencing
05:19:29 <Cale> It just happens to have nothing to do with the evaluation order.
05:19:38 <Cale> (well, essentially nothing)
05:19:41 <Jedai> PeakerWork: the list "sequence" in your example, not the monad
05:19:56 <PeakerWork> Jedai: some monads don't sequence, but since monads in general are allowed to sequence -- its hard not to see the sequencing as part of the abstraction of monads
05:20:01 <Cale> > do x <- [1..3]; y <- [1..x]; return (x,y)
05:20:03 <lambdabot>   [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3)]
05:20:38 <Cale> Pick a number x from 1 up to 3, then pick a number y from 1 up to x, and return the pair (x,y)
05:20:59 <Jedai> PeakerWork: That's part of the capacity of monads, I agree, I just don't think it's a very good idea to use "sequence" and "sequencing operation" as a basic vocabulary to describe monads in general
05:21:00 <Cale> So it's a kind of sequence of operations, though the evaluation order is drastically different.
05:21:18 <Absolute0> Is it common to have type signatures in where clauses?
05:21:28 <ivanm> not really
05:21:35 <Cale> I think sequencing is to some extent at the heart of what monads abstract over, but you have to be cautious that you really know what is meant by it.
05:21:56 <Absolute0> silly monads
05:22:01 <Jedai> Absolute0: it is sometimes necessary, especially if the monomorphism restriction is activated, but it's relatively uncommon
05:22:02 <Absolute0> confusing everyone
05:22:10 <Cale> Using the term around those who are uninitiated is perhaps dangerous. :)
05:22:14 <EvilTerran> Cale, as in, sequencing the flow of information, not the evaluation order
05:22:15 <EvilTerran> ?
05:22:23 <Gracenotes> Absolute0: in some cases you might even need scoped type variables >_>
05:22:27 <Cale> EvilTerran: something like that, I suppose.
05:22:30 <PeakerWork> Jedai: Monads do   Functor(fmapping) + Applicative(sequencing + value combining) + Monad(can use results of previous sequence to choose how to continue sequencing)
05:22:30 <sohum> this is very offtopic, but where would I go to ask a CS question?
05:22:42 <Absolute0> the author of the haskell book at yale says that monads should've been called "warm and fuzzy things
05:22:46 <Cale> EvilTerran: Sequencing in terms of what <=< does
05:22:54 <EvilTerran> although the Etats monad has information flowing in both directions <.< >.>
05:23:02 <Jedai> Cale: That's what I was saying, not that "sequencing" has nothing to do with monads, just that a little caution around the term when teaching a beginner may be good
05:23:17 <Gracenotes> sohum: can't do much if we don't know what the question is...
05:23:18 <Cale> That is, a monad has about as much to do with sequencing as the composition of any category does.
05:23:43 <Cale> But associativity is the heart of what we expect from sequences
05:23:59 <Cale> and composition in categories is associative
05:24:01 <sohum> Gracenotes: well, I don't want to ask #haskell, I just wondered if yall knew somewhere where a CS question would be ontopic
05:24:03 <Jedai> sohum: you can try here, eventually go to haskell-in-depth
05:24:15 <Gracenotes> sohum: CS is extremely general. what.
05:24:22 <PeakerWork> Jedai: I think a beginner should learn Functor, then Applicative, then Monad -- and Applicative should already introduce sequencing
05:24:22 <sohum> fair enough.
05:24:32 <Gracenotes> unfortunately there's not a CS channel on freenode. at least not a busy one.
05:24:45 <Cale> Applicative doesn't really have sequencing in the sense that Monad does.
05:25:01 <Gracenotes> :/ but... for jeeve's sake, what's the question?
05:25:11 <sohum> if there's a graph with exactly 2x nodes, and each node is connected to exactly x other nodes, does there have to exist a clique of size x?
05:25:22 <Absolute0> Applicative?
05:25:36 <Jedai> Absolute0: another typeclass
05:25:42 <Absolute0> does lambdabot provide links?
05:25:43 <Cale> Absolute0: Applicative is another abstraction similar to Monad, but weaker in its operations and more general.
05:25:44 <EvilTerran> sohum, you could also try #math for a problem like that
05:25:52 <sohum> EvilTerran: I could, thankee.
05:25:53 <Jedai> Absolute0: yes, I think
05:25:58 <Absolute0> whats the syntax?
05:26:01 <Cale> (Every monad is an applicative functor, but not every applicative functor is a monad)
05:26:07 <Cale> See Control.Applicative
05:26:10 <Jedai> > (+3) <$> [1..5]
05:26:10 <Gracenotes> sohum: math is a good channel :) sorry for snarky
05:26:11 <lambdabot>   [4,5,6,7,8]
05:26:23 <Cale> that's just fmap...
05:26:42 <Cale> > [id, (+2), (*2), (^2), (2^)] <*> [5,6,7]
05:26:43 <lambdabot>   [5,6,7,7,8,9,10,12,14,25,36,49,32,64,128]
05:26:51 <Gracenotes> better to ask than to ask to ask, they say
05:26:53 <Absolute0> :t <+>
05:26:54 <lambdabot> parse error on input `<+>'
05:27:01 <Absolute0> :t (<+>)
05:27:02 <lambdabot>     Ambiguous occurrence `<+>'
05:27:02 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at /home/cale/.lambdabot/State/L.hs:4:0-19
05:27:02 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at /home/cale/.lambdabot/State/L.hs:54:0-46
05:27:03 <Cale> :t pure
05:27:05 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
05:27:08 <EvilTerran> > [f,g,h] <*> [x,y,z] :: [Expr]
05:27:09 <Jedai> Absolute0: "f <$> x <*> y" is a simple example, you can have more sophisticated ones
05:27:09 <Cale> :t (<*>)
05:27:09 <lambdabot>   Ambiguous occurrence `x'
05:27:09 <lambdabot>  It could refer to either `L.x', defined at <local...
05:27:10 <sohum> Gracenotes: np ;}
05:27:11 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:27:23 <Cale> Absolute0: pure and <*> are the basic functions for Applicative
05:27:38 <Absolute0> :t Control.Arrow.<+>
05:27:39 <lambdabot> parse error on input `Control.Arrow.<+>'
05:27:44 <Absolute0> :t Control.Arrow.(<+>)
05:27:45 <lambdabot> Couldn't find qualified module.
05:27:48 <Absolute0> beh
05:27:55 <Cale> Absolute0: everything else is built from those two
05:27:55 <Gracenotes> sohum: you're sure it's not P? :P
05:28:05 <Cale> <+> is unrelated
05:28:13 <Jedai> Absolute0: <+> isn't an operator of Applicative
05:28:16 <NEEDMOAR> sohum: btw, an "square" (four points joint by four lines in the standard way) wouldn't be a counterexample?
05:28:16 <Absolute0> xmonad uses <+> in the config
05:28:22 <Absolute0> i am trying to figure out what it does
05:28:37 <Jedai> Absolute0: search in the xmonad doc (look in the index)
05:28:39 <ivanm> Absolute0: it's an xmonad operator
05:28:40 <sohum> Gracenotes: :P
05:28:41 <Cale> I think you'd have to look in the xmonad code for that.
05:28:46 <ivanm> it joins together two hooks, IIRC
05:29:12 <sohum> NEEDMOAR: no, because the "square" has four cliques of size 2
05:29:30 <NEEDMOAR> sohum: nevermind, stupid me.
05:29:31 <Absolute0> it looks funky, very intriguing :)
05:29:33 <Cale> http://hackage.haskell.org/packages/archive/xmonad/0.8.1/doc/html/XMonad-ManageHook.html#v%3A<%2B>
05:29:36 <Cale> Absolute0: ^^
05:30:11 <Cale> Heh, apparently its implementation is mappend :P
05:30:31 <Absolute0> xmonad rocks by the way
05:30:38 <Cale> aha, type ManageHook = Query (Endo WindowSet)
05:30:40 <Absolute0> hands down the best WM
05:30:48 <walter_> >pates
05:30:51 <walter_> >paste
05:30:52 <sohum> (incidentally, the reason my mind is currently blown is because I read through the Monad chapters in RWH ;})
05:30:52 <Cale> and Query derives its Monoid instance
05:31:03 <Cale> So it just composes functions on WindowSets
05:31:19 <Cale> er, oops
05:31:24 <Cale> newtype Query a = Query (ReaderT Window X a)
05:31:27 <Cale> instance Monoid a => Monoid (Query a) where
05:31:28 <Cale>     mempty  = return mempty
05:31:28 <Cale>     mappend = liftM2 mappend
05:31:37 <Cale> so, more or less :)
05:32:30 <Jedai> Absolute0: So <+> is related to Monoid, though only the Hook monoid
05:32:31 <Cale> So what it does when you <+> two ManageHooks together is it constructs the Query computation which when run will run each, and then compose their results
05:32:49 <Cale> (which are required to be WindowSet -> WindowSet functions
05:32:50 <Cale> )
05:32:57 <Absolute0> thanks :)
05:32:57 <Cale> (wrapped in Endo)
05:33:04 <Jedai> Absolute0: I suppose you already know the Monoid typeclass ? If not it's well worth knowing despite its apparent simplicity
05:33:15 <Absolute0> I'll pretend to. :)
05:33:26 <Absolute0> for the time being.
05:33:29 <Cale> Absolute0: It's rather simple to explain...
05:33:55 <Absolute0> monoid related to monad?
05:34:10 <Cale> distantly
05:34:14 <Berengal> @quote endofunctors
05:34:15 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
05:34:18 <Jedai> Absolute0: monoid are just set with a binary operation that is associative and has a neutral element
05:34:39 <Absolute0> monoid monad functor, haskell sounds like some sort of new funky religion :)
05:34:48 <Jedai> Absolute0: for instance (Integer, (+), 0) is a monoid
05:34:49 <Cale> If you have a type, and a special operation, say (*) you'd like to identify on that type, which happens to be associative, that is x * (y * z) = (x * y) * z for all x,y,z, and has an identity, say 1 such that 1 * x = x * 1 = x, for all x, then you can make it an instance of the Monoid class
05:34:56 <Cale> With mappend = (*) and mempty = 1
05:34:59 <Absolute0> Jedai: a field...
05:35:04 <Jedai> Absolute0: monoid are really basics in maths
05:35:08 <Absolute0> in mathematical terms
05:35:16 <Jedai> Absolute0: a field is much more complicated,
05:35:56 <Absolute0> are there isomorphisms in haskell? :-D
05:35:59 <Cale> A field is a group under addition, and a monoid under multiplication satisfying a distributive law, and having inverses for nonzero elements under multiplication
05:36:03 <Absolute0> or ways to verify isomorphism?
05:36:09 <Absolute0> i guess using map function..
05:36:11 <Cale> A group is a monoid with inverses for all elements.
05:36:25 <Cale> (Monoid is a mathematical term)
05:36:41 <Absolute0> where can a monoid be useful?
05:36:41 <walter_> I got a  "parse error" , but dont know why, thanks in advance.   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5443#a5443
05:36:58 <Cale> Absolute0: Monoids are almost everywhere.
05:37:03 <Absolute0> ah :)
05:37:12 <Jedai> Absolute0: http://blog.sigfpe.com/2009/01/haskell-monoids-and-their-uses.html
05:37:50 <Berengal> > sortBy (comparing length `mappend` compare) (words "asd fdsasdf fdsaf fds fdssdf fds")
05:37:51 <lambdabot>   ["asd","fds","fds","fdsaf","fdssdf","fdsasdf"]
05:38:10 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
05:38:14 <Cale> Absolute0: ^^
05:38:29 <hackagebot> bindings-sqlite3 0.0.2
05:38:33 <Cale> there's a post I wrote about one example of what recognising that monoids are everywhere gets you :)
05:38:55 <Cale> and, it explains what Berengal just showed
05:39:02 <olsner> cgibbard = Cale?
05:39:06 <Cale> yes
05:39:06 <Jedai> walter_: I think the error may well be in the code before the line 28...
05:39:22 <Absolute0> I am writing a simple chess game, don't seem to require any of this fancy stuff to get by...
05:39:26 <Jedai> walter_: maybe a ")" or a "]" is lacking
05:39:27 <Absolute0> not sure why
05:39:45 <Absolute0> http://github.com/ramin32/chessengine/tree/master
05:39:55 <apfelmus> Absolute0: Ah, but the stuff is not fancy at all.
05:40:15 <Absolute0> simple data definitions and functions do everything :)
05:40:15 <Cale> There are a lot of monoids associated with chess.
05:40:25 <apfelmus> Rather, in its simplicity lies its power.
05:40:39 <walter_> Jedai,  dont understand where to add ] more  in makeNewsPair :: [Tag] -> [(String, String)]
05:40:56 <Jedai> Absolute0: as apfelmus says, this stuff is not "fancy", in fact it's rather recognizing simple structure gives you more leverage to manipulate them
05:41:30 <Absolute0> monads are not that simple..
05:41:37 <Absolute0> other things could be
05:41:45 <Jedai> Absolute0: and I'm sure you don't _need_ them to do pretty impressive things in Haskell, but when you do know them you'll get more elegant, flexible, shorter... code
05:41:48 <Absolute0> ehh i am just ill informed
05:41:53 <Cale> The basic part of what a monad is, is actually extremely simple.
05:42:06 <Jedai> walter_: I said before this line
05:42:28 <Cale> The laws might seem confusing, but there is actually a way to present them which makes them seem really simple indeed.
05:42:47 <Absolute0> Maybe in my second week of haskell coding i'll get it. :-P
05:43:00 <Cale> It's possible to define a monad as a type constructor M with an operation:
05:43:20 <Cale> (<=<) :: (b -> M c) -> (a -> M b) -> (a -> M c)
05:43:23 <Cale> and
05:43:24 <Jedai> walter_: this line appears perfectly correct, but the parser says there is an indentation error, it's probably because the code that precede this line is incorrectly indented or lacks a closing character
05:43:27 <Cale> return :: a -> M a
05:43:51 <Absolute0> (x) is a functor, right?
05:43:53 <Cale> Before I go on, take a moment to compare those types with
05:44:00 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
05:44:03 <Cale> and
05:44:07 <Cale> id :: a -> a
05:44:17 <Jedai> Absolute0: what's (x) ? do you means [] ?
05:44:22 <Cale> So we've basically just stuck some M's in :)
05:44:22 <Absolute0> return is just taking a simple value and makes it into a Maybe
05:44:27 <Cale> yeah
05:44:37 <Absolute0> Jedai: (x -> y ->z) -> some fancy crap
05:44:58 <Cale> Now the laws are really easy to state in this form:
05:45:00 <EvilTerran> Cale, can you define >>= in terms of >=> and return? do you need join too?
05:45:09 <Cale> EvilTerran: yes you can
05:45:15 <Cale> return <=< f = f
05:45:20 <Cale> f <=< return = f
05:45:33 <Cale> (f <=< g) <=< h = f <=< (g <=< h)
05:45:42 <Cale> those are the three monad laws
05:46:02 <Jedai> Cale: like the composition with return =~= id :)
05:46:04 <Absolute0> Cale: so <=< is just some transitive sort of function mapping then
05:46:31 <Cale> Absolute0: 'transitive', I'm not sure is the word
05:46:36 <Cale> But associative
05:46:42 <Cale> and having identity return
05:46:51 <Cale> Note that
05:46:55 <Cale> id . f = f
05:46:58 <Cale> f . id = f
05:47:00 <Cale> and that
05:47:02 <Absolute0> Cale: can you give an example of  <=< in use?
05:47:06 <Jedai> Absolute0: (<=<) is an operator that "compose" functions of the form (a -> M b)
05:47:06 <Cale> (f . g) . h = f . (g . h)
05:47:47 <Cale> and so (.) and id define what's called the identity monad, though we can't make that directly an instance of Monad in Haskell, since we need a type constructor
05:48:02 <Cale> (so you have to do some extra wrapping then)
05:48:06 <walter_> Jedai, excellent, you are right! thank you
05:48:09 <EvilTerran> ?type \f m -> (f <=< const m) () -- Cale, would this be =<< ?
05:48:10 <lambdabot> forall b (m :: * -> *) c. (Monad m) => (b -> m c) -> m b -> m c
05:48:10 <ivanm> well, the new darcs wiki doesn't seem to like searching... >_>
05:48:16 <Cale> EvilTerran: yeah
05:48:36 <Absolute0> Cale: let me just read your article
05:48:40 <Absolute0> thanks anyways
05:48:57 * EvilTerran feels uncomfortable about the extraneous () in that, but ok...
05:48:58 <Cale> Absolute0: My article gives a more down-to-earth look at the monad laws
05:49:13 <Cale> Absolute0: Which deals with how they might be desirable in actual programming.
05:49:39 <Absolute0> there's some paper i recently read
05:49:43 <Absolute0> by some walders guy?
05:49:47 <Absolute0> not bad..
05:49:47 <Cale> Wadler
05:49:51 <Absolute0> yeah that guy
05:50:02 <Heffalump> Cale: btw, I found some situations where blanket use of . . . $ instead of $ $ $ $ is unnatural: if you're doing the same/similar operation on a bunch of things, some of which are simple values and some of which are applications themselves, it feels quite weird for the $ to keep moving around.
05:50:13 <Absolute0> I am thinking of doing my phd in functional programming.
05:50:17 <Absolute0> i hope i get it in time..
05:50:20 <Absolute0> :)
05:50:38 <Absolute0> are there any undone research that can be done?
05:50:40 <Cale> Heffalump: hm?
05:50:48 <Cale> Absolute0: I'm sure there is.
05:50:49 <Beelsebob> Absolute0: there's *many* bits of FP research to do
05:51:01 <EvilTerran> Absolute0, it's a huge field, there's lots of unexplored edges
05:51:06 <Absolute0> i like programming languages in general
05:51:12 <Absolute0> but haskell is just cool
05:51:16 <Cale> Heffalump: I'm not sure I understand what you mean there...
05:52:02 <Absolute0> scala and python hype about having functional functions, but haskell had it from the start..
05:52:06 <Absolute0> :)
05:52:54 <Twey> â€˜Functional functionsâ€™?
05:53:01 <Absolute0> map,
05:53:08 <Absolute0> all any..
05:53:11 <Twey> If you mean first-class functions, they've been around since Lisp
05:53:13 <ivanm> higher-order functions?
05:53:16 <Heffalump> Cale: I can't find my example now
05:53:25 <Twey> Which has been around since the '50s
05:53:26 <ivanm> Twey: doesn't "first-class" mean you can pass functions around?
05:53:32 <Twey> ivanm: Yes
05:54:00 <ivanm> whereas Absolute0 seems to be referring to higher-order functions, which IIRC means you have functions that use functions
05:54:01 <Absolute0> Twey: in those languages these functions are second-class
05:54:10 <ivanm> (which kinda relies on first-class functions...)
05:54:22 <Twey> ivanm: It's the same abstraction
05:54:24 <Absolute0> unlike haskell/lisp
05:54:26 <Cale> Heffalump: I'll tell you one exception I usually make is that I won't split up the parameters to a zip or zipWith
05:54:32 <Cale> Heffalump: well... usually
05:54:43 <Twey> First-class functions begets higher-order functions; higher-order functions require first-class functions
05:54:54 <Twey> Absolute0: In what languages?  Lisps?
05:54:57 <ivanm> yes, but they're still different ;-)
05:55:05 <Heffalump> that's the thing though, if there are cases where you do want $ $, then you can't make it left associative
05:55:14 <Absolute0> Twey: scroll up
05:55:17 <ivanm> Twey: I think Absolute0 means scala, python, etc.
05:55:17 <Cale> Heffalump: Oh, I still don't do that
05:55:21 <Twey> Oh, right
05:55:24 <Cale> Heffalump: I just use natural application
05:55:28 <Twey> Absolute0: Python functions are first-class, at least
05:55:33 <hackagebot> uu-parsinglib 2.0.1
05:55:33 <Twey> I don't know about Scala
05:55:47 <Heffalump> that involves too many () for me :-)
05:55:49 <Cale> Heffalump: This is specifically in the case that it's last in the chain
05:55:49 <EvilTerran> Heffalump / Cale: it'd be nice if you could write "zipWith (...) $ some list expression $ some other list expression", eh =/
05:56:00 <Cale> Right.
05:56:15 <Cale> That's actually a case where I'd love left associative $
05:57:08 <Cale> But I just meant that if I have something like, oh,  foo . bar $ zip x y, I usually won't push it as far as  foo . bar . zip x $ y
05:57:18 <Twey> ivanm: Absolute0 simply said â€˜mapâ€™
05:57:29 <Twey> That could have been referring to the arguments it takes *shrugs*
05:57:35 <ivanm> Twey: the message before
05:57:36 <Cale> But usually I try to maximise my use of composition to the exclusion of application.
05:57:47 <ivanm> <Absolute0> scala and python hype about having functional functions, but haskell had it from the start..
05:57:55 <ivanm> Twey: though hey also mentioned all and any
05:58:15 <Twey> Absolute0: You got higher-order functions and not first-class functions from â€˜functional functionsâ€™?  :-P
05:58:58 <Twey> Cale: In fact I go the other way
05:59:05 <Absolute0> Twey: details....
05:59:07 <Twey> Because it saves a character or two :-P
05:59:13 <Twey> Er, ivanm** sorry
05:59:39 <ivanm> Twey: I got it from map, all, any ;-)
06:00:59 * sohum stabs this question
06:01:36 <sohum> are there any good resources on clique membership problems, as opposed to clique existence problems?
06:01:38 <walter_> how express empty tuple?  []?
06:01:55 <Cale> walter_: [] is the empty list, () is the empty tuple
06:01:59 <sohum> walter_: empty tuple? ()
06:02:07 <walter_> got, thank you!
06:02:08 <EvilTerran> walter_, [] is empty list. () is empty tuple.
06:02:08 <EvilTerran> ?type []
06:02:08 <EvilTerran> ?type ()
06:02:09 <lambdabot> forall a. [a]
06:02:10 <lambdabot> ()
06:02:24 <esap> is there a standard way to compare functors for equality based on their structure?
06:02:32 <Cale> sohum: Clique membership?
06:03:10 <sohum> Cale: as in, given a graph G, a node N in G, and k, is N a member of a clique of size k or greater
06:03:33 <Cale> esap: hmm, find a pair of natural transformations and prove they compose to the identity in either direction?
06:03:45 <ivanm> sohum: you want to find cliques in a graph?
06:03:57 <sohum> ivanm: no, I know that's NP-complete
06:04:03 <Cale> sohum: Oh, okay, so you're looking for an algorithm.
06:04:06 <ivanm> so what are you actually wanting?
06:04:16 * ivanm has clique-finding code for FGL graphs, if you want
06:04:23 <sohum> ivanm: I want to find if a given node is a member of a clique (of size >= k)
06:04:37 <sohum> Cale: yep
06:04:50 <ivanm> sohum: as in in Haskell, or an algorithm to do so?
06:05:14 <sohum> ivanm: an algorithm will do, this is really a CS question.
06:05:25 <ivanm> ahhhh
06:05:37 <esap> cale: that's up-to-iso. Well ok, maybe that's what I need to do. I'm just wondering if that's sufficient for declaring two natural transformations to be composable (that the functors in middle are isomorphic?)
06:05:45 <ivanm> sohum: I would just try and build a clique with that node; once you've found k nodes in that clique, stop
06:06:38 <Cale> esap: Well, otherwise, equality is, well, they're directly the same functor. I suppose we take it for granted in mathematics that you can decide that.
06:07:07 <Cale> esap: I suppose if they're only isomorphic, you need a specified isomorphism.
06:07:48 <Cale> esap: In implementing a programming language, I suppose I would just check that the types are equal.
06:08:06 <sohum> ivanm: hmmmmm. am I right in thinking that that's O(k^2) for the case where you're checking if it's a member of a clique of size k?
06:08:43 <ivanm> sohum: sounds like it off the top of my head
06:08:51 <esap> cale: Well the thing is, I tried to represent functors as a simple "map of objects" and "map of arrows", but that representation doesn't allow the equality comparison...
06:09:18 <Cale> esap: Well, they're equal if those maps are equal...
06:09:33 <esap> cale: Well I don't have equality comparison for the maps :-)
06:09:36 <uzytkownik> What is standard indentation of do?
06:09:44 <Cale> uzytkownik: something like:
06:09:47 <Cale> do foo
06:09:49 <Cale>    bar
06:09:51 <Cale>    baz
06:10:23 <uzytkownik> Cale: Ok. I was not sure if it was do\n  foo or do foo. Thanks
06:10:27 <Cale> That is, subsequent lines line up with the first non-whitespace character after the 'do'
06:10:36 <ivanm> sohum: then again, the way I've found cliques is to take a node n, find it's neighbours, then recursively try adding a neighbour to the current clique and finding the intersection of its neighbours with the neighbours-so-far
06:10:50 <ivanm> uzytkownik: you can do that as well
06:10:53 <ivanm> some people do:
06:10:56 <ivanm> main = do
06:10:57 <ivanm>   foo
06:10:58 <ivanm>   bar
06:11:00 <ivanm>   baz
06:11:00 <esap> Cale: http://www.kotiposti.net/epulkkin/Category.txt
06:12:59 <Cale> esap: This sort of thing is kind of tricky, because as you go up, you need more and more ability to test equality. I suppose that if you don't mind the finiteness it imposes on things, you can turn more things into concrete values.
06:13:11 <uzytkownik> Should I use IO (Maybe a) or use fail?
06:13:22 <Cale> uzytkownik: The first, I think.
06:13:37 <Cale> uzytkownik: You should never use fail, but there are ways to throw IO exceptions.
06:13:48 <esap> cale: yea, I suppose I must rely on finiteness here
06:14:11 <Cale> Use Data.Map instead of functions or something
06:14:21 <uzytkownik> Cale: Thanks
06:15:42 <Cale> uzytkownik: It's generally more convenient to use Maybe when you have any sort of 'lookup' type of operation, because pattern matching is nice and easy. Catching exceptions is not hard, but it's not quite as pretty.
06:15:44 <esap> cale: yea, that will work [it'll not be fast, but works]
06:16:33 <sohum> ivanm: gaah, brain. could you rephrase that so I can figure out why it's either a heuristic or exponential time?
06:16:49 <ivanm> it's not a heuristic
06:16:55 <ivanm> but the way my code found cliques was:
06:17:03 <CSWookie_> Blah.  I feel dumb, but I can't seem to find the syntax for how to define a funtion in the book I'm reading.
06:17:10 <ivanm> take a node n; find it's neighbours ns
06:17:56 <ivanm> then recursively, take the first elem of ns, and find the intersection of its neighbours and ns
06:18:14 <ivanm> (actually, I did this on tails of n's neighbours, IIRC)
06:18:31 <ivanm> sohum: I have code online if that would help you...
06:19:28 <CSWookie_> Ah, wait, I think I found it.
06:20:24 <sohum> ivanm: aha. so in the worst case scenario that is factorial time
06:20:43 <ivanm> something like that, yes
06:20:56 <sohum> ok, brain better
06:20:59 <sohum> thankee
06:21:02 <ivanm> you can always simplify it (?) by finding how many you have so far as possibles, as well
06:26:08 <sohum> ahaha
06:26:09 <sohum> I have it
06:26:31 <sohum> checking whether a node of order n is a member of a clique of size n is just O(n^2)
06:26:49 <sohum> if the order > n then it becomes exponential
06:41:43 <hackagebot> gtk2hs-cast-glib 0.10.1.1
06:51:56 * EvilTerran notes that you don't seem to be able to nest QuasiQuoters
06:52:05 <EvilTerran> , [$ty| [$ty| () |] |]
06:52:06 <lunabot>  luna: parse error on input `|]'
06:53:12 * EvilTerran also notes that surely (ty [|...|]) would make more sense than [$ty| ... |], seeing as the body is meant to be a haskell expression
06:54:08 <dcoutts> EvilTerran: you can effectively nest them, but not lexically
06:54:44 <dcoutts> and similarly for splicing
06:54:46 <hackagebot> bindings-common 0.1.1
06:55:59 <EvilTerran> dcoutts, "effectively nest"?
06:56:11 <dcoutts> EvilTerran: using let
06:56:44 <dcoutts> EvilTerran: actually, I should admit I've only done it for splicing, not quoting
06:56:59 <dcoutts> it'd need reify I think
06:58:24 * Whoof pokes Phyx with a large stick.
06:59:15 * Phyx- uses Arrows on Whoof
06:59:46 <EvilTerran> , let theType = [$ty| () |] in [$ty| theType |]
06:59:48 <lunabot>  luna: Exception when trying to run compile-time code:
07:04:24 <koeien> @where showHex
07:04:24 <lambdabot> I know nothing about showhex.
07:04:34 <koeien> ?index showHex
07:04:35 <lambdabot> Numeric
07:09:26 <CSWookie_> Is there nice way to say 'multiples of 3' in haskell?
07:09:55 <CSWookie_> I'm used to python, and I'm trying to understand the haskell idioms.
07:10:16 <EvilTerran> > [0, 3 ..]
07:10:17 <kpreid> > [0,3..]
07:10:21 <lambdabot>   mueval-core: Prelude.read: no parse
07:10:21 <lambdabot>  mueval: ExitFailure 1
07:10:21 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
07:10:31 <kpreid> whoops
07:11:29 <kpreid> hm, is that lb's parser's bug? I would think that 3 isn't a module name
07:12:33 <Phyx-> lol
07:12:38 <Phyx-> which of those failed?
07:12:44 <kpreid> mine, I expect
07:12:49 <kpreid> > [0, 3 ..]
07:12:50 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
07:12:51 <kpreid> yes
07:12:53 <Phyx-> ah
07:13:14 <olsner> @faq can template haskell iterate all identifiers in a module?
07:13:15 <lambdabot> The answer is: Yes! Haskell can do that.
07:13:30 <olsner> now, for the how :)
07:13:36 <Phyx-> @faq can haskell save the world?
07:13:36 <Twey> No no
07:13:36 <lambdabot> The answer is: Yes! Haskell can do that.
07:13:40 <Phyx-> rofl
07:13:41 <Twey> You don't even need TH
07:13:47 <Twey> Look, it says *Haskell* can do it
07:14:12 <Twey> That obviously means '98 :-P
07:14:19 <Phyx-> you could use SYB and haskell-src-ext? :P
07:14:19 <olsner> hmm, well of course *Haskell* can do it, question is can *I* :)
07:14:29 <trofi> @hoogle :: Integer -> [a] -> a
07:14:30 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
07:14:30 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
07:14:30 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
07:14:50 <Twey> olsner: *grin*
07:14:58 <kpreid> trofi: genericIndex is the general (!!) equivalent
07:15:22 <CSWookie_> Can I say multiples of 3 or 5 in a similar way?
07:15:28 <CSWookie_> I'm doing projecteuler.
07:15:55 <hackagebot> gtk2hs-cast-glade 0.10.1.1
07:15:56 <kpreid> No...
07:15:58 <kpreid> hm
07:16:02 <kpreid> @hoogle merge
07:16:02 <lambdabot> Distribution.Simple.PackageIndex merge :: Package pkg => PackageIndex pkg -> PackageIndex pkg -> PackageIndex pkg
07:16:02 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
07:16:02 <lambdabot> Text.ParserCombinators.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
07:16:03 <Jedai> CSWookie_: You could just merge the multiples of 3 and the multiples of 5
07:16:19 <Jedai> CSWookie_: write the appropriate merge and it's a snap
07:16:26 <CSWookie_> Jedai: That sounds like what I want.
07:16:28 <byorgey> or you could just use a list comprehension.
07:16:37 <kpreid> yeah.
07:16:41 <Phyx-> yeah, and restrict the values to a multiple of 3 and 5
07:16:51 <trofi> kpreid: yeah, i searched exactly that function
07:16:54 <kpreid> > [x | x <- [0..], x `mod` 3 == 0, x `mod` 5 == 0]
07:16:55 <lambdabot>   [0,15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,30...
07:17:02 <kpreid> er
07:17:06 <kpreid> > [x | x <- [0..], x `mod` 3 == 0 || x `mod` 5 == 0]
07:17:07 <lambdabot>   [0,3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,5...
07:17:40 <Jedai> kpreid: That works if you're in a hurry but it examines much more numbers
07:18:29 <Jedai> (ok, in the case of 3 and 5 not that much more, but imagine you want multiples of much bigger numbers... ^^ )
07:18:57 <hackagebot> gtk2hs-cast-th 0.10.1.0
07:19:02 <kpreid> > let merge xs@(x:xs') ys@(y:ys') | x < y = x : merge xs' ys; | otherwise = y : merge xs ys' in merge [0, 3 ..] [0, 5 ..]
07:19:03 <lambdabot>   <no location info>: parse error on input `|'
07:19:09 <kpreid> > let merge xs@(x:xs') ys@(y:ys') | x < y = x : merge xs' ys | otherwise = y : merge xs ys' in merge [0, 3 ..] [0, 5 ..]
07:19:11 <lambdabot>   [0,0,3,5,6,9,10,12,15,15,18,20,21,24,25,27,30,30,33,35,36,39,40,42,45,45,48...
07:19:27 <kpreid> > let merge xs@(x:xs') ys@(y:ys') | x == y = x : merge xs' ys' | x < y = x : merge xs' ys | otherwise = y : merge xs ys' in merge [0, 3 ..] [0, 5 ..]
07:19:28 <lambdabot>   [0,3,5,6,9,10,12,15,18,20,21,24,25,27,30,33,35,36,39,40,42,45,48,50,51,54,5...
07:19:31 <kpreid> there you go
07:19:42 <CSWookie_> Jedai: kpreid: the LC up there will go through all numbers, and return those that are multiples of 3 or 5, yes?
07:19:55 <Jedai> CSWookie_: Yes
07:19:57 <hackagebot> gtk2hs-cast-gnomevfs 0.10.1.2
07:19:57 <hackagebot> gtk2hs-cast-gtk 0.10.1.2
07:19:58 <kpreid> CSWookie_: all nonnegative integers, yes
07:20:33 <CSWookie_> Haskell is hard for me to read.
07:20:52 <kpreid> practice
07:20:54 * CSWookie_ looks up merge in his book.
07:20:57 <hackagebot> gtk2hs-cast-gtkglext 0.10.1.2
07:21:08 <Jedai> CSWookie_: merge is not a standard function
07:21:11 <Phyx-> if the numbers are in sequence anyway, wehy not just generate them based on x*3 and 5*x
07:21:14 <EvilTerran> CSWookie_, it can take a bit of getting used to
07:21:38 <CSWookie_> Oh.
07:21:43 <Jedai> CSWookie_: it usually design a function that takes two sorted list and merge them into a sorted list, the detail may vary
07:21:57 <kpreid> my eval above gives a definition of merge
07:21:57 <hackagebot> gtk2hs-cast-gtksourceview2 0.10.1.2
07:22:02 <Jedai> CSWookie_: kpreid gave a version appropriate to our use above
07:22:06 <kpreid> in particular, one which combines equal items rather than repeating them
07:22:18 <Jedai> kpreid: and works on infinte streams
07:22:50 <kpreid> Jedai: I would expect any merge function on Haskell lists to work on infinite streams.
07:23:01 <kpreid> Now, mine fails on *finite* lists, but that's just for brevity.
07:23:08 <Jedai> kpreid: I meant and only works on infinite streams
07:23:24 <CSWookie_> I'm used to much longer variable names.
07:23:49 <uzytkownik> I have a parametrized function - by parametr k. In a where close I need to cast on this type (compiler have no way to determin - but that's a different story). Is it possible to indicate that a in where statement is the same a as in function declaration or I have to use less direct method (I know how but it requires 'empty' statement such as head (y:(snd z)) to indicate type of z).
07:23:50 <Jedai> CSWookie_: well in our case there is not much point to them
07:24:27 <CSWookie_> Jedai: Why?
07:24:52 <kpreid> CSWookie_: One can construct a general principle: variable names' length is proportional to the nearness of their uses
07:24:59 <Jedai> CSWookie_: merge is the traditional merge, a more precise name is hard to give, and the (x:xs) (y:ys) are traditional for general lists
07:25:18 <kpreid> Since Haskell code is so short otherwise, we use short names...
07:25:24 <CSWookie_> What?
07:25:35 <CSWookie_> Your general principle doesn't make sense to me.
07:25:52 <CSWookie_> Jedai: What does the @ mean?
07:25:54 <kpreid> Like in C, you almost always use 'i' for a simple array index.
07:25:56 <kpreid> Because it's part of the loop and nothing larger.
07:26:04 <Jedai> CSWookie_: you could write (head:tail) but it wouldn't give more detail
07:26:29 <Jedai> CSWookie_: the @ is a "as-pattern"
07:26:52 <Axman6> i prefer x:xs to had:tail because there's a visual que that x is smaller than xs (which is most cases it will be)
07:27:03 <Axman6> head*
07:27:21 <Axman6> head:tail seems to imply to me that they are equal lengths
07:27:23 <Jedai> CSWookie_: xs'@(x:xs) match xs' with the whole list, x with the head of the list and xs with the tail
07:27:30 <Axman6> i'm probably alone here though...
07:28:04 <Axman6> CSWookie_: xss@(x:xs) defines xss to be the whole list, x to be the head of the list, and xs to be the tail
07:28:15 <Jedai> CSWookie_: in general, it allows you to keep a name for the whole parameter while breaking it into finer parts at the same time
07:28:31 <olsner> turns out, reify barfs with a compile error when given a nonexistant identifier (rather than indicating whether or not it was defined)
07:28:40 <CSWookie_> I'm sorry if I'm thick about things.  I've got to go to church, now.  I'll be back later, maybe in quiter.
07:29:15 <Jedai> CSWookie_: You're not thick, Haskell isn't a particularly easy language to learn
07:29:30 <Jedai> CSWookie_: especially if it's your first functional language
07:29:37 <Axman6> it's handy for a lot of other things, like data Vec = V Double Double Double; f :: Vec -> Double; f v@(V x y z) = x + 2y* mag v
07:29:44 <Twey> Oh, CSWookie_, hello
07:29:56 <nA1828KcFz9q> type theory resources?
07:30:07 <paolino> hi, anyone can explain the different behaviors here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5444#a5444 , please?
07:32:36 <kpreid> paolino: in the second one, your ErrorT adds an independent error mechanism which has no relation to the one in IO. And your catchError applies to that one rather than IO.
07:32:40 <EvilTerran> ?hoogle catchError
07:32:40 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
07:32:45 <Axman6> nA1828KcFz9q: i don't think those words form a question
07:33:18 <kpreid> paolino: you'll have to "lift" the catchError into IO to make it do the same as the first (but note that it's a 2-arg function so you can't just apply lift)
07:33:19 <EvilTerran> ?instances-importing Control.Monad.Error MonadError
07:33:21 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
07:34:21 * EvilTerran concurs with kpreid - that'll be the instance MonadError IOError IO, and the instance MonadError e (ErrorT e m)
07:34:46 <kpreid> (where e = String and m = IO)
07:34:57 <paolino> it makes sense
07:35:48 <nA1828KcFz9q> Axman6: Which papers or pages are the standard resources referred to when one is beginning to study algebraic type theory?
07:36:03 <EvilTerran> unfortunately, there's an ambiguty in chosing an instance for MonadError for (ErrorT e m) where m is already a MonadError instance
07:36:22 <Axman6> that is a certainly a questions. i wish i could help you now :)
07:36:28 <paolino> is lifting catchError the way to go from the IOException to a common layer with logic errors ?
07:36:32 * Axman6 doesn't know anything (formally) about type theory
07:36:33 <EvilTerran> and, while it does make more sense to go for the instance based around the ErrorT, it does result in this kinda behaviour
07:37:54 <paolino> if I'm able to lift it, in the end
07:38:27 <EvilTerran> nA1828KcFz9q, Ben Pierce's Types and Programming Languages is an excellent introductory text
07:38:36 <EvilTerran> ?go TaPL pierce
07:38:38 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
07:38:38 <lambdabot> Title: Types and Programming Languages
07:39:19 <EvilTerran> i don't recall how much detail it goes into wrt algebraic types, but it covers basic type theory nicely
07:40:28 <uzytkownik> ?hoogle listToMaybe
07:40:29 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
07:40:37 <voker57__> can i make a list which has different types, but all of one typeclass?
07:40:55 <voker57__> like type Objects = (Object a) => [a]
07:41:23 <EvilTerran> voker57__, not in haskell98; there's usually other ways of achieving the same thing, though
07:41:47 <Axman6> hmm, i can see it being possible using partially applied functions... maybe
07:41:49 <voker57__> EvilTerran: like?
07:42:33 <EvilTerran> voker57__, well, it depends on what you want to do with the list
07:42:54 <paolino> kpreid: I don't know how to lift catchError :-/
07:43:04 <EvilTerran> for instance, rather than having a [forall a. Show a => a], you could achieve pretty much the same result with just a [String]
07:44:42 <kpreid> voker57__: you can get the effect using an existential-type wrapper (which is not h98 as EvilTerran said) -- but yes, you should first consider whether there's a better way to do it
07:48:10 <jbjohns> hi all.  How does the dynamic linking work in Haskell?  I want to create a Haskell CMS and I want users to be able to add modules to the running system like one can with e.g. Joomla! .
07:51:26 <harlekin> jbjohns, check out http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins.
07:52:05 <Jedai> jbjohns: look at happstack too, it may be a good basis
07:53:30 <paolino> kpreid: to move errors between layers I have to tag results from IO and case-match them in the ErrorT layer ?
07:53:50 <alexsuraci> Is there a way to dump the raw data of a string? e.g. raw "ABC" => "\x41\x42\x43" (or something more natural)
07:54:03 <alexsuraci> "raw data" may be the wrong term
07:54:11 <kpreid> paolino: it's up to you how you translate the errors
07:54:23 <kpreid> > map fromEnum "ABC"
07:54:23 <harlekin> @ty ord
07:54:25 <lambdabot>   [65,66,67]
07:54:25 <lambdabot> Char -> Int
07:54:35 <harlekin> alexsuraci, map ord "ABC"
07:54:46 <alexsuraci> harlekin: thanks, that seems like it'd do it
07:55:00 <harlekin> alexsuraci, kpreid's suggestion is more general, though. I'd prefer that.
07:55:10 <Axman6> > ord maxBound
07:55:12 <lambdabot>   1114111
07:55:49 <Axman6> > foldl' (\x n -> n * 1114111 + x) "ABC"
07:55:50 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:55:50 <lambdabot>    arising from the literal ...
07:55:59 <Axman6> > foldl' (\x n -> x * 1114111 + n) "ABC"
07:56:00 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
07:56:00 <lambdabot>    arising from the literal ...
07:56:11 <Axman6> > foldl' (\x n -> x * 1114111 + n) 0 "ABC"
07:56:13 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
07:56:13 <lambdabot>    arising from the literal `1...
07:56:32 <Axman6> > foldl' (\x n -> n * 1114111 + ord x) 0 "ABC"
07:56:33 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:56:48 <Axman6> :t foldl' (\x n -> n * 1114111 + ord x) 0
07:56:48 <Jedai> > foldl' (\x n -> x * 1114111 + ord n) 0 "ABC"
07:56:50 <lambdabot>   80680889352258
07:56:50 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
07:56:50 <lambdabot>     In the expression: n * 1114111 + ord x
07:56:50 <lambdabot>     In the first argument of `foldl'', namely
07:57:00 <Axman6> thaks Jedai
07:57:12 <Axman6> i never can remember how to use folds
07:57:25 <paolino> kpreid: I want to write a function IO a -> ErrorT String IO a, where the possible IOExceptions are found in Lefts values , I suppose
07:57:27 <Jedai> Axman6: you're welcome... so base 1114111 ?
07:57:37 <Axman6> yup
07:57:51 <Axman6> or, base Haskell Char
07:59:08 <paolino> :i ErrorT
07:59:16 <paolino> @src ErrorT
07:59:16 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
07:59:51 <marcot> Is there a getDirectoryContentsRecursive function somewhere?
07:59:52 <marcot> Like unix find.
07:59:52 <lambdabot> marcot: You have 1 new message. '/msg lambdabot @messages' to read it.
08:00:32 <EvilTerran> marcot, there may be something on hackage
08:00:42 <jbjohns> harlekin: thanks
08:00:48 <jbjohns> l
08:03:44 <Phyx-> @info ->
08:03:45 <lambdabot>  Parse error at "->" (column 1)
08:03:48 <paolino> ï»¿:t \f -> ErrorT ((Right <$> f) `catch` (return . Left . show))
08:03:53 <Phyx-> @info ~>
08:03:54 <lambdabot> (~>)
08:04:01 <Phyx-> helpful
08:04:09 <harlekin> :D
08:04:42 <Phyx-> @info (~>)
08:04:42 <lambdabot> (~>)
08:04:59 <Phyx-> @type (~>)
08:05:00 <lambdabot> Not in scope: `~>'
08:05:02 <paolino> info is not offensive at least :|
08:05:17 <Phyx-> lol
08:05:20 <EvilTerran> Phyx-, there's no @info command, it's typo-corrected to @undo
08:05:20 <EvilTerran> @info do x <- 1; return (x,x)
08:05:20 <lambdabot> 1 >>= \ x -> return (x, x)
08:05:36 <Phyx-> EvilTerran: which explains alot
08:05:37 <Phyx-> lol
08:05:50 <EvilTerran> ^ see, @undo :)
08:06:52 <Phyx-> > folder (+) 0 []
08:06:52 <lambdabot>   Not in scope: `folder'
08:06:52 <Phyx-> oops, right, only commands are typo corrected
08:08:59 <Phyx-> @king StateT
08:08:59 <lambdabot> Maybe you meant: kind ping
08:09:08 <Phyx-> @king\d StateT
08:09:10 <lambdabot> * -> (* -> *) -> * -> *
08:09:20 <Phyx-> lol
08:09:41 <Phyx-> that was actually unintentional
08:09:44 <jbjohns> @src (>>>)
08:09:44 <lambdabot> Source not found. Where did you learn to type?
08:09:51 <Phyx-> hahaha
08:10:06 <Phyx-> @index (>>>)
08:10:07 <lambdabot> Control.Arrow
08:10:17 <Phyx-> @src Control.Arrow
08:10:17 <lambdabot> Source not found. Where did you learn to type?
08:10:23 <paolino> src is offensive
08:10:28 <Jedai> @source Control.Arrow
08:10:29 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
08:10:39 <Jedai> @source Control.Arrows
08:10:39 <lambdabot> Control.Arrows not available
08:10:49 <Jedai> @source isn't though :)
08:10:49 <lambdabot> isn't though :) not available
08:10:51 <Phyx-> why both src and source?
08:11:08 <Jedai> Phyx-: they don't do the same thing
08:11:17 <Phyx-> is src for it's local definitions?
08:11:34 <EvilTerran>  @src prints source code to the channel; @source provides a link to the source file
08:11:49 <EvilTerran> @src foldr
08:11:49 <lambdabot> foldr f z []     = z
08:11:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:11:50 <Jedai> Phyx-: @src gives the source code for a function (when it knows it, so never... ;) and @source gives a link to the source file of a module
08:12:01 <Phyx-> @src (+)
08:12:02 <lambdabot> Source not found. I am sorry.
08:12:05 <jbjohns> I think it's actually in Category
08:12:11 <EvilTerran> @source Prelude
08:12:11 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
08:12:11 <Phyx-> Jedai: so... @src is useless?
08:12:14 <Jedai> @src Int (+)
08:12:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
08:13:05 <Jedai> Phyx-: no, as EvilTerran has shown, @src works for Prelude functions and some others, but it won't work very often otherwise
08:13:16 <Jedai> @src Maybe fmap
08:13:16 <lambdabot> fmap _ Nothing       = Nothing
08:13:16 <lambdabot> fmap f (Just a)      = Just (f a)
08:13:21 <Phyx-> @hoogle (>>>) --info
08:13:21 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
08:13:21 <lambdabot>  
08:13:21 <lambdabot> From package base, version 3.0.1.0
08:13:58 <Phyx-> Jedai: ok, then not useless, just not so useful :)
08:14:11 <Jedai> Phyx-: nice to show a basic function to a beginner
08:14:53 <Phyx-> :)
08:15:10 <Jedai> Phyx-: by the way, @src (+) don't work because (+) is a class method, @src Int (+) should work but I'm guessing it don't because it's defined somewhere in the entrail of GHC
08:15:27 <Jedai> @src  Complex (+)
08:15:27 <lambdabot> Source not found. Are you on drugs?
08:15:32 <Phyx-> hahahah
08:15:41 <Phyx-> rofl
08:15:59 <Jedai> @src  (++)
08:15:59 <lambdabot> []     ++ ys = ys
08:15:59 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:15:59 <lambdabot> -- OR
08:15:59 <lambdabot> xs ++ ys = foldr (:) ys xs
08:16:22 <Phyx-> @src return
08:16:22 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:16:34 <Jedai> @src Maybe return
08:16:34 <lambdabot> return              = Just
08:16:39 <Phyx-> ah
08:16:40 <Phyx-> right
08:17:27 <Phyx-> i was actually expecting it to print out the definition in the class, on the first one
08:17:35 <EvilTerran> marcot, would http://hackage.haskell.org/cgi-bin/hackage-scripts/package/directory-tree suit your purposes?
08:17:44 <Taejo> which Regex library is the fastest? (my regexes are large but fairly simple)
08:17:52 <Berengal> @src Monad
08:17:52 <lambdabot> class  Monad m  where
08:17:53 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
08:17:53 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
08:17:54 <lambdabot>     return      :: a -> m a
08:17:56 <lambdabot>     fail        :: String -> m a
08:17:57 <marcot> EvilTerran: I was looking at Unixutils, let me see this option.
08:18:03 <Jedai> Phyx-: Nope, @src is pretty stupid... and offensive !
08:18:22 <Phyx-> hehehe
08:18:33 * kpreid also wishes @src wouldn't print insults
08:18:43 <jbjohns> I was just trying to figure out an example from Niel Bartlett's blog
08:18:56 <Jedai> Taejo: regex-pcre is pretty fast from what I know, if you ever write a benchmark don't forget to post the results !
08:19:10 <jbjohns> > test1 a = a * a
08:19:11 <lambdabot>   <no location info>: parse error on input `='
08:19:20 <jbjohns> > let test1 a = a * a
08:19:21 <lambdabot>   not an expression: `let test1 a = a * a'
08:19:31 <marcot> EvilTerran: Unixutils seems to be simpler.
08:19:44 <jbjohns> no way to define functions with lambda bot then?
08:19:49 <Phyx-> @let test1 a = a * a
08:19:50 <lambdabot>  Defined.
08:19:53 <jbjohns> ah
08:19:57 <Phyx-> > test1 6
08:19:59 <lambdabot>   36
08:20:04 <Taejo> Jedai: I was just thinking, if all else fails, I'll just use something that isn't PCRE. I prefer high-factor linear time to heavily optimized exponential
08:20:17 <Jedai> jbjohns: but usually we use "> let ... in ..."
08:20:28 <EvilTerran> but note all the @let definitions disappear if anyone does an @undef
08:20:45 <jbjohns> He gave the example:  summaries = deep (hasName "cd") >>> (getAttrValue "artist") &&& (getAttrValue "title") >>> (arr . uncurry) itemSummary
08:20:50 <Jedai> @undef
08:20:55 <Phyx-> @undef test1
08:21:06 <Phyx-> odd
08:21:12 <Phyx-> > test1 7
08:21:13 <lambdabot>   Not in scope: `test1'
08:21:15 <Phyx-> ah
08:21:37 <Phyx-> > join (+) 6
08:21:38 <lambdabot>   12
08:22:51 <Jedai> Taejo: you still have posix, IIRC they're linear time, no ?
08:22:54 <jbjohns> As I read that, deep must be returning a list of xml nodes, but the rest of it seems to work with only one element
08:23:06 <mxc> regarding atomicModifyIORef, the docs say that it is unsafe for multiple IORefs, does that mean that if you are trying to modify multiple IORefs in a single call its unsafe or if you have multiple IORefs in distinct parts of the code, anywhere, its unsafe?
08:23:16 <EvilTerran> Phyx-, as i said, @undef doesn't take a parameter, it undefines everything
08:23:26 <Taejo> Jedai: well, posix, tdfa and dfa seem to be the options
08:23:40 <Phyx-> EvilTerran: that needs some updating
08:23:59 <jbjohns> @let itemSummary a t = t ++ " performed by " ++ a
08:24:01 <lambdabot>  Defined.
08:24:11 <Jedai> jbjohns: what's the definition of deep
08:24:21 <jbjohns> deep scan of an XML tree
08:24:30 <eivuokko> mxc, it means it's not possible to have atomic guarantee when trying to change multipe iorefs from one location, in presence of other threads/finalisers.
08:24:35 <Jedai> jbjohns: right but what's its type
08:25:04 <mxc> eivuokko : thanks.  thats what I thought, but just wanted to double check
08:25:09 <jbjohns> @let getAttrValue k ((k',v):'t) = if k == k' then v else getAttrValue k 't
08:25:09 <lambdabot>   Parse error in pattern: HsVarQuote (UnQual (HsIdent "t"))
08:25:22 <jbjohns> @let getAttrValue k ((k',v):t') = if k == k' then v else getAttrValue k t'
08:25:23 <lambdabot>  Defined.
08:25:40 <jbjohns> getAttrValue "artist" [("artist", "me")]
08:25:45 <jbjohns> > getAttrValue "artist" [("artist", "me")]
08:25:47 <lambdabot>   "me"
08:26:00 <Berengal> > curry id 5 6
08:26:02 <lambdabot>   (5,6)
08:26:04 <Jedai> @type lookup
08:26:05 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:26:19 <EvilTerran> @src lookup
08:26:19 <lambdabot> lookup _key []          =  Nothing
08:26:19 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
08:26:19 <lambdabot>                         | otherwise = lookup key xys
08:26:59 <jbjohns> > (getAttrValue "artist") &&& (getAttrValue "title") >>> (arr . uncurry) itemSummary $ [("artist", "Puddle of mud"), ("title", "She hates me")]
08:27:00 <lambdabot>   "She hates me performed by Puddle of mud"
08:27:32 <jbjohns> so I was trying to figure out how deep is able to get this part to iterate over all the nodes.  It seems to operator only on a single entry
08:27:47 <jbjohns> > :t (getAttrValue "artist") &&& (getAttrValue "title") >>> (arr . uncurry) itemSummary
08:27:48 <lambdabot>   <no location info>: parse error on input `:'
08:27:59 <jbjohns> @type (getAttrValue "artist") &&& (getAttrValue "title") >>> (arr . uncurry) itemSummary
08:28:00 <lambdabot> [([Char], [Char])] -> [Char]
08:28:01 <Jedai> @type (>>>)
08:28:02 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
08:28:47 <jbjohns> @type deep
08:28:48 <lambdabot> Not in scope: `deep'
08:29:14 <Jedai> jbjohns: Your inquiry is pointless without the type of deep, the arrow in which we're operating or a link to the article/paper
08:29:54 <jbjohns> it's from HXL
08:30:05 <jbjohns> HXT even
08:30:24 <jbjohns> the XML library that uses arrows
08:30:53 <jbjohns> deep	:: XmlFilter -> XmlFilter
08:31:17 <jbjohns> type XmlFilter = XmlTree -> [XmlTree]
08:35:34 <lars9> hey, i've learning haskell, i have a problem to solve but dunno how to design the code, may i get some help here?
08:35:52 <Zao> Quite possibly.
08:35:54 <eivuokko> Very likely.
08:36:25 <burp> ?faq can haskell solve the problem?
08:36:25 <lambdabot> The answer is: Yes! Haskell can do that.
08:36:31 <lars9> the problem is: given a list l, print out all sublist of length n, and the number of their appearence
08:39:18 <Phyx-> > quickCheck \x->x==x
08:39:20 <lambdabot>   <no location info>: parse error on input `\'
08:39:34 <Phyx-> > quickCheck (\x->id x = x)
08:39:35 <lambdabot>   <no location info>: parse error on input `='
08:39:41 <Phyx-> > quickCheck (\x->id x == x)
08:39:42 <lambdabot>   Not in scope: `quickCheck'
08:40:02 <Jedai> jbjohns: From what I see, deep is an operation from the class ArrowTree
08:40:29 <EvilTerran> @check \x -> id x == x
08:40:30 <lambdabot>   "OK, passed 500 tests."
08:40:41 <Phyx-> ah
08:40:45 <EvilTerran> @check \x y -> x == y -- but beware of defaulting
08:40:46 <lambdabot>   "OK, passed 500 tests."
08:40:47 <jbjohns> ah, yep, I see it
08:41:04 <Phyx-> @check \x join pure x == x
08:41:04 <lambdabot>   Parse error at "==" (column 16)
08:41:13 <Phyx-> @check \x-> join pure x == x
08:41:14 <lambdabot>   "OK, passed 500 tests."
08:41:29 <Jedai> jbjohns: anyway, arrows are a very powerful abstraction, (>>>) on this case isn't working on simple functions, trying to approximate it with composition won't work
08:41:34 <Phyx-> how does that work anyway, i don't see how join pure becomes the identity
08:41:35 <lars9> for example, give 1231234, all sublists of length 3 are: 123, 231, 312, 234, which appears 2, 1, 1, 1 times, respectively
08:41:55 <voker57__> lars9: something like  [inits ts | ts <- tails xs]
08:42:04 <voker57__> where xs is the list
08:42:43 <Phyx-> @type join pure
08:42:44 <lambdabot> forall a. a -> a
08:42:47 <Phyx-> @type join
08:42:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:42:58 <voker57__> > let xs = [1..10]
08:42:59 <lambdabot>   not an expression: `let xs = [1..10]'
08:43:06 <EvilTerran> ?type join pure
08:43:07 <lambdabot> forall a. a -> a
08:43:15 <voker57__> > let xs = [1..10] in [inits ts | ts <- tails xs]
08:43:17 <lambdabot>   [[[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],...
08:43:28 <jbjohns> Jedai:  I agree, but the thing I did above was using the same operators.  I tried passing a list of those nodes but I didn't see how to make it traverse.  (>>>) also doesn't seem to be a type class method so I didn't see how it's overloaded unless (.) itself is overloaded
08:43:40 <Taejo> > break (== 2) [2, 2, 3, 4]
08:43:41 <lambdabot>   ([],[2,2,3,4])
08:43:48 <Phyx-> EvilTerran: I thought the result of join was always a monad
08:43:50 <Taejo> > break (=/ 2) [2, 2, 3, 4]
08:43:51 <lambdabot>   Not in scope: `=/'
08:43:59 <Taejo> > span (== 2) [2, 2, 3, 4]
08:44:01 <lambdabot>   ([2,2],[3,4])
08:44:01 <byorgey> Phyx-: that's using the ((->) a) monad
08:44:16 <Taejo> anyone have a good mnemonic for which is which of break and span?
08:44:21 <Jedai> > M.fromList (take 3 . tails $ [1, 2, 3, 1, 2, 3, 4])
08:44:22 <lambdabot>   Couldn't match expected type `(k, a)' against inferred type `[a1]'
08:44:32 <voker57__> > let xs = [1..5] in  [filter (/= []) (inits ts) | ts <- tails xs]
08:44:32 <byorgey> pure :: a -> m a, so unifying that with  m (m a)  means  m = (a ->)
08:44:33 <lambdabot>   [[[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]],[[2],[2,3],[2,3,4],[2,3,4,5]],[[...
08:44:33 <Jedai> > S.fromList (take 3 . tails $ [1, 2, 3, 1, 2, 3, 4])
08:44:35 <lambdabot>   fromList [[1,2,3,1,2,3,4],[2,3,1,2,3,4],[3,1,2,3,4]]
08:45:02 <voker57__> > let xs = [1..3] in  [filter (/= []) (inits ts) | ts <- tails xs]
08:45:04 <lambdabot>   [[[1],[1,2],[1,2,3]],[[2],[2,3]],[[3]],[]]
08:45:06 <EvilTerran> Phyx-, both the join and the pure are in the (e->) monad
08:45:13 <Jedai> > M.fromList (map take 3 . tails $ [1, 2, 3, 1, 2, 3, 4])
08:45:14 <lambdabot>   Couldn't match expected type `b -> c'
08:45:20 <voker57__> > let xs = [1..3] in filter (/=[]) [filter (/= []) (inits ts) | ts <- tails xs]
08:45:21 <Jedai> > M.fromList (map (take 3) . tails $ [1, 2, 3, 1, 2, 3, 4])
08:45:22 <lambdabot>   [[[1],[1,2],[1,2,3]],[[2],[2,3]],[[3]]]
08:45:22 <lambdabot>   Couldn't match expected type `(k, a)' against inferred type `[a1]'
08:45:29 <EvilTerran> Phyx-, in which join f x = f x x, and pure = const
08:45:30 <Jedai> > S.fromList (map (take 3) . tails $ [1, 2, 3, 1, 2, 3, 4])
08:45:31 <lambdabot>   fromList [[],[1,2,3],[2,3,1],[2,3,4],[3,1,2],[3,4],[4]]
08:45:35 <voker57__> that's it, i guess
08:45:35 <lars9> in other languages, that problem requires a 'map', but how to do in haskell
08:45:40 <Phyx-> EvilTerran, byorgey hm, ok, guess i'll go take a look at that monad
08:45:47 <Jedai> lars9: with a MAp
08:46:15 <voker57__> with map, you map!
08:46:24 <Jedai> > M.fromListWith (+) . map (flip (,) 1) . map (take 3) . tails $ [1, 2, 3, 1, 2, 3, 4]
08:46:26 <lambdabot>   fromList [([],1),([1,2,3],2),([2,3,1],1),([2,3,4],1),([3,1,2],1),([3,4],1),...
08:46:56 <Jedai> lars9: there, it's almost good, you just have to delete those pesky too small sublists
08:47:09 <EvilTerran> Phyx-, Reader is just (->) with a newtype wrapper
08:47:23 <voker57__> i solved this already
08:47:58 <voker57__> why IntMap?
08:48:12 <Jedai> voker57__: I didn't see it ?
08:48:24 <Phyx-> EvilTerran: ah ok, cool
08:48:39 <voker57__> Jedai:  let xs = [1..3] in filter (/=[]) [filter (/= []) (inits ts) | ts <- tails xs]
08:48:46 <Jedai> voker57__: I don't think you're resolving the problem lars9 asked
08:49:02 <skorpan> would it be appropriate to call something with the type "s -> Bool" a predicate?
08:49:05 <EvilTerran> voker57__, it'd be better to write (not.null) rather than (/= [])
08:49:06 <Jedai> voker57__: he wanted all sublists of length n (3 in his example)
08:49:12 <voker57__> ah, length n
08:49:19 <EvilTerran> ?type not.null
08:49:19 <EvilTerran> ?type (/= [])
08:49:20 <lambdabot> forall a. [a] -> Bool
08:49:21 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:49:27 <voker57__> well another filter :)
08:49:31 <EvilTerran> skorpan, entirely appropriate, imo
08:49:32 <Jedai> @src (>>>)
08:49:32 <lambdabot> Source not found. My brain just exploded
08:49:34 <Phyx-> ahhh ok
08:49:36 <skorpan> EvilTerran: okay, thanks
08:49:40 <Phyx-> makes sense now
08:49:44 <Jedai> @source Control.Arrow
08:49:44 <lambdabot> http://darcs.haskell.org/packages/base/Control/Arrow.hs
08:50:08 <voker57__> Jedai:  let xs = [1..3] in filter (((==) 3) . length) [filter (not.null) (inits ts) | ts <- tails xs]
08:50:16 <voker57__> >  let xs = [1..3] in filter (((==) 3) . length) [filter (not.null) (inits ts) | ts <- tails xs]
08:50:17 <lambdabot>   [[[1],[1,2],[1,2,3]]]
08:51:05 <Jedai> @source Control.Category
08:51:06 <lambdabot> Control.Category not available
08:52:18 <Jedai> jbjohns: but (.) is overloaded (in Control.Category, where (>>>) is defined)
08:52:37 <voker57__> >  let xs = [1..5]; n=3 in filter (not.null) [filter (((==) 3) . length) (inits ts) | ts <- tails xs]
08:52:39 <lambdabot>   [[[1,2,3]],[[2,3,4]],[[3,4,5]]]
08:53:08 <Jedai> voker57__: not elegant (and you have too much [])
08:53:25 <voker57__> >  let xs = [1..5]; n=3 in foldl (++) [] $ filter (not.null) [filter (((==) 3) . length) (inits ts) | ts <- tails xs]
08:53:27 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
08:54:03 <voker57__> yep... the requirement on length allows to make it easier
08:54:04 <Jedai> > M.fromListWith (+) . map (flip (,) 1) . foldr (.) id (replicate 2 inits) . map (take 3) . tails $ [1, 2, 3, 1, 2, 3, 4]
08:54:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
08:54:26 <Jedai> > M.fromListWith (+) . map (flip (,) 1) . foldr (.) id (replicate 2 init) . map (take 3) . tails $ [1, 2, 3, 1, 2, 3, 4]
08:54:27 <lambdabot>   fromList [([1,2,3],2),([2,3,1],1),([2,3,4],1),([3,1,2],1),([3,4],1)]
08:54:36 <Jedai> ok, so :
08:54:41 <Taejo> what is the language pragma for no monorphism restriction?
08:54:52 <jbjohns> jedai:  yea, I was looking to see if that was overriden to do some iteration anywhere, but the definition for deep you found doesn't seem to iterate.  Definition:                deep f = f `orElse` (getChildren >>> deep f)
08:55:02 <wli> {-# LANGUAGE NoMonomorphismRestriction #-}
08:55:40 <Jedai> let countSub n = M.fromListWith (+) . map (flip (,) 1) . foldr (.) id (replicate (n-1) init) . map (take n) . tails in countSub 3 [1, 2, 3, 1, 2, 3, 4]
08:55:46 <Jedai> > let countSub n = M.fromListWith (+) . map (flip (,) 1) . foldr (.) id (replicate (n-1) init) . map (take n) . tails in countSub 3 [1, 2, 3, 1, 2, 3, 4]
08:55:47 <lambdabot>   fromList [([1,2,3],2),([2,3,1],1),([2,3,4],1),([3,1,2],1),([3,4],1)]
08:56:14 <Jedai> > let countSub n = M.fromListWith (+) . map (flip (,) 1) . foldr (.) id (replicate n init) . map (take n) . tails in countSub 3 [1, 2, 3, 1, 2, 3, 4]
08:56:15 <lambdabot>   fromList [([1,2,3],2),([2,3,1],1),([2,3,4],1),([3,1,2],1)]
08:56:49 <Jedai> lars9: There, you have it, works perfectly and not too inneficient
08:57:07 <voker57__> > let n = 3; xs = [1..5] in filter (((==) n) . length) $ map (take n) (tails xs)
08:57:09 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
08:57:10 <lars9> Jedai: thanks, let me learn it
08:57:15 <Taejo> wli: thanks, must have been misspelling it
08:57:15 <voker57__> another one :)
08:57:15 <lars9> Jedai: first
08:57:27 <lars9> voker57__: great, thanks too
08:58:06 <voker57__> Jedai: so why do use Map?
08:58:23 <Jedai> voker57__: ((==) n) can be written (n ==), it's a little bit better IMHO
08:58:56 <Jedai> voker57__: to count the number of occurence of each sublist, it was my understanding that this was what was asked
08:59:08 <voker57__> oh.
08:59:20 <lars9> Jedai: yeah, count the number of occurence
08:59:24 * voker57__ needs to learn to read
08:59:45 <Jedai> <lars9> the problem is: given a list l, print out all sublist of length n, and the number of their appearence
09:00:01 <voker57__> i though it was about a total number of sublists
09:00:21 <lars9> that would be length - n + 1, :D
09:01:02 <Jedai> voker57__: also your proposition is less efficient than my own, probably two times slower
09:02:07 <lars9> Jedai: is there staright forward way to do the count thing? like count the number of each char in a string
09:02:50 <Jedai> lars9: the idiom is "M.fromListWith (+) . map (flip (,) 1)"
09:03:03 <EvilTerran> lars9, length . filter (==c) would be the usual method
09:03:14 <EvilTerran> (for each char)
09:03:32 <EvilTerran> or map (head &&& length) . group . sort
09:03:42 <EvilTerran> to get a [(Char,Int)] with a list of counts
09:03:43 <lars9> EvilTerran: then we need to 'unique' the string first?
09:03:57 <Phyx-> nub
09:04:00 <EvilTerran> > map (head &&& length) . group . sort $ "abracadabra"
09:04:02 <lambdabot>   [('a',5),('b',2),('c',1),('d',1),('r',2)]
09:04:25 <Jedai> Phyx-: Please don't say nub to the beginner, it's too damn slow !
09:04:36 <Phyx-> rofl
09:04:53 <Phyx-> it's because he is a beginner i said it
09:04:56 <lars9> EvilTerran: abracadabra is common in textbook, did you just think it out? :D
09:05:05 <EvilTerran> nub is O(n^2); map head . sort is O(n*log n)
09:05:05 <Phyx-> @type group
09:05:07 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
09:05:10 <Jedai> EvilTerran: What do you think is faster ? The Map trick or this one (theoretically it has the same complexity)
09:05:31 <Heffalump> hi augustss
09:05:55 <augustss> hi
09:05:57 <Phyx-> @index group
09:05:57 <lambdabot> Data.List
09:06:05 <EvilTerran> lars9, i just use it as a placeholder for demo'ing various string manipulations
09:06:13 <EvilTerran> lars9, it has various useful properties for that sort of thing
09:06:17 <Phyx-> hmm interestig function
09:06:22 <EvilTerran> (like five 'a's)
09:08:12 <lars9> what about the usual way of implementing key-value data structure in haskell?
09:08:26 <EvilTerran> Jedai, no idea; i figure they're probably close enough that you should use whichever you find clearest
09:08:29 <EvilTerran> lars9, that'd be Data.Map
09:09:12 <lars9> EvilTerran: let me check Data.Map, maybe it's better in doing the counting job
09:09:27 <lars9> EvilTerran: more straight forward i mean
09:09:28 <Jedai> lars9: That's what I used in my method
09:09:56 <lars9> Jedai: the 'M' is Data.Map?
09:10:04 <Jedai> @type M.fromListWith
09:10:05 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
09:10:11 <lars9> Jedai: sorry i didnt figure it out
09:10:42 <Jedai> lars9: it's a shortcut in lambdabot (Data.Map is imported qualified as M)
09:11:09 <EvilTerran> lars9, lambdabot basically has "import qualified Data.Map as M"
09:11:09 <lars9> Jedai: i see, smart bot
09:13:04 <stepnem> and what is the comma in (flip (,) 1)?
09:13:26 <Jedai> stepnem: I could rewrite that as (\x -> (x,1))
09:13:40 <stepnem> ah, I see, :)
09:13:49 <Jedai> stepnem: It could be clearer (depending on your addictiong to pointfree style)
09:14:10 <byorgey> @type (,)
09:14:11 <lambdabot> forall a b. a -> b -> (a, b)
09:14:15 <byorgey> > (,) 2 3
09:14:17 <lambdabot>   (2,3)
09:14:22 <stepnem> heh
09:14:42 <lars9> i know the Map thing now. How to do this counting job onlinely?: read symbols from a list one by one, and print the number of occurence of the read symbol.
09:15:31 <Jedai> lars9: I'm not sure what you mean, you want to print the number of occurence "until now" ?
09:15:33 <byorgey> you can do that with a Map too.  just keep a Map around and update it each time you read a symbol
09:16:02 <lars9> read 'a', print 1, read 'b', print 1, read 'a', print 2, read 'c', print 1
09:16:23 <lars9> read '\n', exit
09:17:48 <kpreid> lars9: if you like functionalness, start with 'main = interact yourFunc' where yourFunc :: String -> String
09:18:18 <Jedai> lars9: Yep, do that with a Map, you can even be pretty efficient by using an insertLookupWithKey (in order to read and modify the value simultaneously)
09:18:51 <lars9> Jedai: but how to loop in main?
09:19:20 <Jedai> lars9: Try using kpreid method (interact)
09:20:00 <lars9> Jedai: kpreid : thanks, let me check 'interact' first
09:20:15 <Jedai> lars9: it's pretty easy to loop anyway, you can just call main in main (or do the same with another function if you want a smaller loop)
09:21:14 <lars9> i see, recursion for loop
09:21:53 <lars9> got to go now, thanks guys, bye:)
09:22:03 <Jedai> lars9: You can also write your own loops
09:28:01 <RayNbow> ah, apfelmus has a nice quit msg :)
09:34:02 <Taejo> how do I run an external process in Haskell?
09:36:40 <int-e> something in the process library should do the trick. http://hackage.haskell.org/cgi-bin/hackage-scripts/package/process -- System.Cmd is a simple interface that simply runs commands while System.Process is more complicated but allows you to capture stdin, stdout and stderr as well.
09:44:18 <burp> argl, I hate "where" indention
09:46:39 <Cale> burp: what about it?
09:46:53 <Cale> burp: You have roughly two options
09:46:57 <Cale> foo = bar
09:47:05 <Cale>   where bar = quux
09:47:11 <Cale> foo = bar
09:47:13 <Cale>   where
09:47:16 <Cale>     bar = quux
09:48:08 <dolio> No, no. In that second one, you should line bar up with where. :)
09:48:18 <Cale> In either case, the subsequent lines should align to the column containing the first non-whitespace character after the 'where'
09:48:20 <burp> really?
09:48:27 <Cale> I wouldn't.
09:49:21 <Cale> (but obviously the rule is a little more general than this)
09:49:55 <Cale> The important thing is that the contents of the 'where' is indented more than the function/value definition itself.
09:51:15 <burp> ok
09:51:27 <kpreid> there's also foo = bar where
09:51:27 <kpreid>                ...
09:51:42 <Cale> I find that a bit annoying, myself :)
09:51:55 <burp> @pretty looooooooooong t = A*cos(omega*t) + B*sin(omega*t) + h where { A = 4.8-5*h; B = 1/2; h = 12.8/14; omega = 2*pi/12 }
09:51:56 <lambdabot>  looooooooooong t = A * cos (omega * t) + B * sin (omega * t) + h
09:51:56 <lambdabot>    where A = 4.8 - 5 * h
09:51:56 <lambdabot>          B = 1 / 2
09:51:56 <lambdabot>          h = 12.8 / 14
09:51:56 <lambdabot>          omega = 2 * pi / 12
09:51:57 <Cale> Unless the contents of the where will all fit onto that one line
09:52:34 <Cale> burp: Note that the 'where' is part of the function definition itself, and *not* the expression on the right hand side of the =
09:53:03 <Cale> This actually matters conceptually, as 'where' will scope over multiple guards.
09:53:19 <Cale> foo x | y < 0 = ...
09:53:24 <Cale>       | y == 0 = ...
09:53:28 <Cale>       | y > 0 = ...
09:53:33 <Cale>   where y = x^2 + x + 1
09:54:56 <burp> http://paste.railsbox.eu/show/1IOFKrp52ZBMHgMHhPyr/ <- why is this indention wrong then?
09:55:23 <burp> oh.. capitals
09:55:33 <Cale> (heh, of course, thinking would reveal there that only one of my guards will ever succeed :)
09:55:49 <Cale> oh, yes
09:55:59 <Cale> A and B look like data constructors
09:56:02 <burp> with correcty syntax highlighting the problem is directly visible :>
09:56:10 <Cale> indeed :)
10:00:43 <int-e> Calling a local binding in a function 'h' 'h' may lead to confusion.
10:01:55 <burp> uh, thats true
10:05:33 <Taejo> what is the Bool argument to executeFile?
10:06:48 <Taejo> ah, never mind, looks like I should be using System.Process
10:06:59 <alexsuraci> woo, just implemented python's struct.unpack in haskell
10:07:16 <int-e> Taejo: yes you should. but it tells executeFile whether to search the PATH or not.
10:07:31 <Taejo> int-e: thanks
10:09:29 <stepnem> are there some more accessible resources on arrows (>>>,&&& etc.)?
10:10:27 <stepnem> I see there's plenty of stuff on monads, on haskell.org, but what about arrows (other than the paper(s))...?
10:11:03 <Taejo> stepnem: the distinction between "papers" and "not papers" is artificial :)
10:11:22 <Taejo> but I agree that the arrows paper is not a great tutorial
10:11:43 <stepnem> Taejo: well, whatever, *accessible* is my point here, :)
10:12:02 <Saizan> the papers are quite accessible
10:12:08 <stepnem> and more tutorial-like, yeah
10:12:45 <stepnem> hm... maybe I should try the papers then -- honestly, I haven't so far, heh
10:13:03 <PeakerWork> stepnem: I think you should start with Category, its much simpler
10:13:30 <Saizan> arrows are not so widely used, so you don't have many compelling examples to work with
10:13:34 <PeakerWork> stepnem: Arrows are not a very interesting class, due to a design mistake in there..
10:14:40 <arjanb> what design mistake?
10:14:45 <Taejo> Saizan: I don't use arrows much, but I use the arrow combinators a fair bit with plain old (->) arrows
10:14:59 <Taejo> first, second, (&&&), (***) are all pretty handy
10:15:09 <stepnem> hm, I have to say that 'map (head &&& length) . group . sort $ "abracadabra"' *is* quite interesting and compelling for me, :)
10:15:36 <Saizan> Taejo: yeah, but that's more like having Data.Tuple than anything else
10:16:01 <Taejo> Saizan: yes, indeed. but it seems that's what stepnem is interested in
10:16:19 <Saizan> i mean, if you're only using one instance ever you don't even need to learn about the abstraction
10:16:25 <Taejo> indeed
10:16:27 <Saizan> just learn about what each combinator does
10:16:39 <Taejo> so, stepnem, don't bother learning the abstraction right now
10:17:42 <Taejo> stepnem: the (&&&) combinator has type (a -> b) -> (a -> c) -> (a -> (b, c)) (restricting to the ordinary -> arrow)
10:17:48 <stepnem> Taejo: but what should I look at then? only from the source it isn't very ovious to me what's going on there
10:17:55 <stepnem> obvious*
10:18:09 <Taejo> yes, because of the unneeded abstraction
10:18:47 <Taejo> without the abstraction, (&&&) f g x = (f x, g x)
10:19:02 <Taejo> and (***) f g (x, y) = (f x, g y)
10:19:07 <Saizan> the instance for (->) should have that definition, or similar
10:19:14 <stepnem> ah... right, :)
10:19:15 <Taejo> true
10:19:25 <Taejo> @src (&&&) (->)
10:19:26 <lambdabot> Source not found. That's something I cannot allow to happen.
10:19:32 <Taejo> @src &&& ->
10:19:33 <lambdabot> Source not found. My pet ferret can type better than you!
10:19:43 <Taejo> @src (->) (&&&)
10:19:43 <lambdabot> Source not found. My mind is going. I can feel it.
10:19:49 <Taejo> never mind, then
10:22:53 <PeakerWork> how can Ocaml beat Haskell's conciseness in: http://gmarceau.qc.ca/blog/2009/05/speed-size-and-dependability-of.html ?
10:23:40 <Taejo> @where (</>)
10:23:40 <lambdabot> I know nothing about (</>).
10:26:10 <Taejo> is it impossible to use readFile and appendFile on the same file in a program, even if I know that the one finishes before the other starts?
10:29:19 <Athas> I just had my first real use of the Maybe monad in code.
10:29:22 <Athas> Man, that is really handy.
10:29:44 <Athas> I have a definition that now looks like: s' = s { finger = finger s >>= return . (+1) }
10:29:55 <Athas> That would have been much more ugly if written explicitly.  Thank you, Data.Maybe!
10:30:12 * CSWookie_ goes back to look at that merge thing again.
10:33:37 <Jedai> Taejo: No, it's not impossible at all
10:34:01 <int-e> Taejo: It's not impossible, but the only way to close the file reliably after readFile is to consume all data that readFile returned.  consume :: String -> IO (); consume = foldr (const id) (return ()), say.
10:34:41 <Jedai> Athas:  s' = s { finger = fmap (+1) (finger s) }
10:35:08 <Jedai> Athas: Maybe is an instance of Functor too, and in your case that's all you need
10:35:16 <Athas> Oh yes, that is better.  Thank you.
10:37:40 <PhDP> Somebody know what Don is using in this vidÃ©o; http://www.youtube.com/watch?v=2Lqzygxvus0... emacs ? Vim ? (I really don't know much about this kind of thing, but it seems powerful)
10:38:16 <Samy> Probably vim.
10:38:26 * Samy didn't look at the video
10:38:54 <profmakx> its vim
10:38:59 <profmakx> as you can see in the top bar
10:39:01 <Jedai> PhDP: I couldn't say, the url is malformed for me
10:39:40 <profmakx> some day i will try stuff out for my phd in haskell...
10:39:50 <PhDP> http://archhaskell.wordpress.com/2009/03/24/chart-a-library-for-generating-2d-charts-and-plots/
10:39:53 <Taejo> int-e: my seq was in the wrong place. thanks for the help
10:41:55 <jbjohns> do haskell structures have any kind of syntax like Erlang does?
10:42:15 <skorpan> what do you mean?
10:42:28 <jbjohns> like for example, the UTCTime structure has a field for every element of time, day, month, etc.
10:42:49 <jbjohns> in erlang you could take one of those and do like:           UTCTime#variable{hour = 2}
10:42:57 <jbjohns> and get a copy of the variable but with the time set to 2
10:43:02 <jbjohns> er, with the hour set to 2
10:43:36 <Jedai> PhDP: Yeah, it vim but he doesn't do anything impressive with it (by emacs or vim standard anyway), the demo is nice thanks to the library, ghci and xmonad
10:43:51 <jbjohns> it's nice when you just want to change a part of the "structure" but not all of it
10:44:17 <Jedai> jbjohns: In haskell they're called records
10:44:21 <PhDP> Well then I'm just easily impressed, for now I'm writting my code with basic text editor.
10:44:39 <jbjohns> Erlang as well.  I just knew they were made with the data keyword so I didn't know what Haskell called them
10:44:45 <Jedai> jbjohns: and you have this kind of syntax too
10:44:51 <jbjohns> wonderful
10:45:16 <Jedai> data Stuff = { foo :: Int, bar :: Maybe Bool }
10:45:36 <Jedai> test = { foo = 5, bar = Nothing }
10:45:53 <Jedai> test2 = test { bar = Just True }
10:46:07 <Jedai> data Stuff = Stuff { foo :: Int, bar :: Maybe Bool }
10:46:20 <jbjohns> ah, that works?  I didn't even know what try
10:46:24 <Jedai> test = Stuff 5 Nothing
10:46:42 <jbjohns> I read through Real World Haskell in the records part but I didn't see it
10:46:43 <Jedai> jbjohns: sorry, my first version lacked the constructor
10:47:23 <Jedai> test = Stuff {foo = 5, bar = Nothing}
10:47:41 <Jedai> jbjohns: so test2 is test with bar modified
10:48:03 <Jedai> jbjohns: "foo test" gets the value in the foo field
10:48:53 <Jedai> jbjohns: This isn't perfect though, especially when you want to modify a value deep inside a record in a record in a record
10:49:58 <Jedai> jbjohns: if you find yourself doing things like that look up the data-accessor package, it's pretty nice
10:50:52 <Jedai> jbjohns: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor
10:51:06 <fracture> (got booted; so missed if anyone answered that)
10:51:58 <jbjohns> thanks, I just tried it out on my stuff, looks good
10:52:14 <jbjohns> now I can go change a bunch of my code from when I didn't know you could do this
10:52:33 <Jedai> jbjohns: How did you do it before ?
10:53:00 <jbjohns> I have a function like:            withDays f dt = UTCTime { day = f dt.day, month = dt.month, year = ....
10:53:45 <Jedai> jbjohns: dt.month is written month dt in Haskell though
10:53:52 <fracture> so in case that didn't go through:  is there a way to make user defined data constructors that take a variable number of arguments (like [] does)?
10:53:54 <jbjohns> I used Haskell before Erlang so it never occurred to me to even look for something like this
10:54:03 <fracture> (or maybe [] doesn't...)
10:54:05 <jbjohns> Jedai: Yea, must be that then
10:54:45 <fracture> actually (after playing around), I guess I don't understand what the tutorials mean when they say [] is like a data constructor
10:54:45 <Jedai> fracture: [1,2,3] is special syntax, it's syntax sugar for 1:2:3:[]
10:55:04 <fracture> ohh now I get it... [] is a type constructor
10:55:05 <Jedai> fracture: [] is not a data constructor, (:) is
10:55:09 <fracture> got it
10:55:11 <fracture> thanks
10:55:15 <Jedai> fracture: right, [] is a type constructor
10:55:17 <idnar> Jedai: [] is the data constructor for the empty list
10:55:39 <Jedai> idnar: True, but it hasn't any arguments in this case
10:55:45 <idnar> yeah
10:55:47 <idnar> @src []
10:55:48 <lambdabot> data [] a = [] | a : [a]
10:56:05 <idnar> (that's not a "real" definition, but if there were one, that would be it)
10:56:14 <fracture> ah
10:56:56 <Jedai> fracture: Note that you can use operator as data constructor for your datatypes, as long as they start by :
10:57:08 <fracture> ah
10:57:37 <Jedai> @src Complex
10:57:37 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
11:00:34 <Jedai> jbjohns: with data-accessor, you can rewrite that "day ^: f $ dt"
11:01:09 <jbjohns> ah, that's some kind of composition?
11:01:39 <PeakerWork> Jedai: [] is both a type-constructor and a data-constructor (as evident in its appearing on the LHS and RHS of that data declaration)
11:02:14 <Jedai> PeakerWork: Yep, I forgot the empty list at first
11:02:15 <PeakerWork> oh, didn't read the whole thing, you acknowledged that
11:02:19 <PeakerWork> sorry
11:02:38 <AllNight^> how can I get ghc to show me what the current directory is? I know I can change it with :cd
11:03:00 * AllNight^ just got haskell-mode working :D
11:03:22 <Jedai> jbjohns: Yes, in this case it's not particularly interesting, but with longer field name and especially with nested records it makes all the difference in the world
11:03:50 <jbjohns> it looks neat with this as well
11:04:03 <Jedai> jbjohns: "state ^: date ^: day ^: (+1) $ gameState"
11:04:15 <jbjohns> but yea, I can imagine that really helping a lot for nested structures
11:04:30 <PeakerWork> Jedai: probably nicer to use a composed accessor, in the same sense a (.) chain is nicer than ($)
11:05:15 <PeakerWork> and accessor composition could be done with (Control.Category..) (You might need to declare your own instance) so you could have:  (state . date . day) ^: (+1) $ gameState
11:05:33 <Jedai> PeakerWork: True, something like "state <: date <: day ^: (+1) $ gameState"
11:05:52 <PeakerWork> except <: is silly because accessors should be Control.Category.Category :)
11:06:02 <PeakerWork> and one can use (.) or (<<<)
11:06:21 <PeakerWork> (much less operator names to remember!)
11:06:22 <Jedai> PeakerWork: I guess so, but I don't think the instance is defined by default
11:08:27 <Taejo> I'm trying to open an external editor from Haskell -- 'runProcess "vim" [fn] Nothing Nothing Nothing Nothing Nothing' seems to me to be the right thing, but vim complains "Vim: Error reading input, exiting..."
11:08:51 <EvilTerran> Taejo, you may need to provide a handle for it to read as stdin
11:09:11 <Taejo> EvilTerran: "Handle to use for stdin (Nothing => use existing stdin)"
11:09:36 <EvilTerran> oh right, i was thinking Nothing meant that stdin would start closed.
11:10:53 <PeakerWork> @hoogle runProcess
11:10:53 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
11:11:01 <EvilTerran> AllNight^, :!pwd, perhaps?
11:11:26 <AllNight^> yes that does it - thanks EvilTerran :)
11:11:37 <PeakerWork> Maybe [Handle] would probably be nicer (stdin,stdout,stderr are just a convention, you may have more)
11:12:34 <PeakerWork> @hoogle runProcess --info
11:12:34 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
11:12:34 <lambdabot>  
11:12:34 <lambdabot> Runs a raw command, optionally specifying Handles from which to take the stdin, stdout and stderr channels for the new process (otherwise these handles are inherited from the current process).
11:12:53 <PeakerWork> Taejo: is your "existing stdin" ok?
11:13:09 <PeakerWork> what's the 2nd FilePath?
11:13:23 * EvilTerran didn't know @hoogle could do that! :o
11:13:28 <Taejo> PeakerWork: I'm running the program from a terminal; the 2nd FilePath is the cwd
11:13:44 <EvilTerran> PeakerWork, i think it's the name of the process image as it sees it itself
11:13:53 <EvilTerran> ... or that.
11:14:08 <PeakerWork> I guess that would be the 2nd arg's (!!0)
11:18:37 <frwmanners> join haskell-in-depth
11:18:38 <lambdabot> frwmanners: You have 1 new message. '/msg lambdabot @messages' to read it.
11:21:00 <frwmanners> Baughn: I seem to have got your message 7 days late
11:21:03 <Athas> What's the easiest way to read a file as a list of Word32's?
11:21:46 <PeakerWork> @hoogle FileHandle -> ByteString
11:21:46 <lambdabot> Did you mean: Handle -> ByteString /count=20
11:21:46 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:21:46 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:21:56 <PeakerWork> @hoogle FileHandle -> IO ByteString
11:21:56 <lambdabot> Did you mean: Handle -> IO ByteString /count=20
11:21:56 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:21:56 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
11:22:22 <frwmanners> Baughn: re filterE
11:23:04 <alexsuraci> I'm getting this error when trying to build haskelldb-hsql: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5449#a5449
11:23:12 <alexsuraci> related: http://hackage.haskell.org/packages/archive/haskelldb-hsql/0.10/logs/failure/ghc-6.10
11:23:38 <alexsuraci> Is there any known fix for that?
11:23:42 <PeakerWork> hoogle/hayoo really kind of suck on this search
11:23:44 <Jedai> @hoogle Handle -> IO ByteString
11:23:44 <lambdabot> Data.ByteString hGetContents :: Handle -> IO ByteString
11:23:44 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
11:23:44 <lambdabot> Data.ByteString.Char8 hGetContents :: Handle -> IO ByteString
11:24:10 <Jedai> PeakerWork: as suggested, Handle instead of FileHandle works better
11:24:14 <PeakerWork> oh
11:24:18 <PeakerWork> whoops
11:24:32 <Jedai> Athas: using binary is probably the easiest way
11:24:33 <PeakerWork> Athas: you can combine this with Data.Binary.Get
11:25:10 <Athas> Yes, I tried using Data.Binary myself, but I think my attempt just consed up a huge list, without ever passing beyond the first four bytes in the file.
11:25:28 <PeakerWork> Athas: How did you use it?
11:25:33 <Athas> Additionally, Data.Binary seems hardcoded to use lazy bytestrings.
11:26:12 <gwern> Athas: indeed
11:26:15 <Athas> I can't remember.  A recursive parser using getWord32be.
11:26:18 <gwern> and binary-strict is a hack
11:26:33 <PeakerWork> hmm.. ByteString should have been a class? :P
11:26:45 <Athas> Is there a clean way to force the evaluation of the parser before my file handle is closed, in that case?
11:27:04 <gwern> 'Performance This was the real unknown. Performance on the prototype looked
11:27:05 <gwern> good, but we did not know how it would scale. Other systems implemented in
11:27:05 <gwern> Haskell, like Darcs (Roundy, 2005), have shown that performance can be an issue
11:27:05 <gwern> in real-world workloads.
11:27:08 <Athas> Perhaps I should just use Data.Binary.decodeFile?
11:27:18 <gwern> auugh. I knew darcs would become a cited example of bad haskell performance -_-
11:27:24 <PeakerWork> Athas: the doc says it just uses ByteString's readFile?
11:27:52 <PeakerWork> gwern: is that a horrible thing?
11:28:05 <gwern> PeakerWork: yes, it prevents people from swallowing our koolaid
11:28:23 <PeakerWork> I don't know how much of darcs' bad performance was attributed to Haskell and how much to the logic, though
11:28:36 <frwmanners> Baughn: looking at the new code, it's redundant
11:29:07 <Baughn> frwmanners: How's that?
11:29:47 <frwmanners> Baughn: So, the problem was Max (AddBounds t) as time in FutureG
11:30:02 <Baughn> frwmanners: Er. Hang on, what?
11:30:04 <Baughn> What new code?
11:30:04 <gwern> '                                       A surprising weakness was executable size,
11:30:07 <gwern> with our executables coming in at 5 megabytes each. With several executables per
11:30:10 <gwern> release, and several prototype releases running simultaneously, fpf turned out to
11:30:13 <gwern> be unexpectedly disk hungry.
11:30:33 <frwmanners> Baughn: reactive-0.11
11:30:37 <gwern> '  A combination of make (Feldman, 1979) and Perl (Wall & Schwartz, 1990) scripts
11:30:40 <gwern> complete the build system infrastructure, including a program-level regression test
11:30:41 <frwmanners> I think (???)
11:30:43 <gwern> suite. Relatively mainstream tools were selected here to simplify maintenance.
11:30:43 <Baughn> frwmanners: So that should be the unamb code..
11:30:45 <gwern> -_-
11:30:54 <Baughn> frwmanners: Um, I don't think I've got any code in reactive-0.11..
11:31:14 <frwmanners> frwmanners: Sorry, you asked me to elaborate on something I said a week ago
11:31:20 <Baughn> frwmanners: What I've been working on is unamb and TVal.hs. The latter is part of reactive, granted, but it isn't done yet..
11:31:21 <frwmanners> ^^^ Baughn
11:31:23 <Baughn> Oh
11:31:31 <Baughn> I'd completely forgotten about that
11:31:49 <frwmanners> Baughn: I only remembered because the lambdabot just told me
11:32:01 <frwmanners> Baughn: sorry for time / confusion
11:33:02 <gwern> '                                                      The points-free approach, while
11:33:04 <Baughn> It rolled out of my log, unfortunately. :/
11:33:06 <gwern> elegant, can make code unreadable, especially if it is written by quantitative analysts
11:33:09 <gwern> moonlighting as functional programmers.
11:33:26 <Tsion> Hello, could someone with admin on lambdabot make it join #botters please?
11:33:32 <gwern> @remember SimonFrankau The points-free approach, while elegant, can make code unreadable, especially if it is written by quantitative analysts moonlighting as functional programmers.
11:33:32 <lambdabot> It is forever etched in my memory.
11:33:43 <Athas> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5450#a5450 <- Why doesn't that work?
11:33:59 <Athas> It just conses infinitely.
11:34:33 <Baughn> frwmanners: But am I mistaken to think that implementing reactive for io-driven events will require the use of unsafePerformIO to grab the current time for the Ord instance of Improving?
11:35:02 <PeakerWork> does Lazy Bytestring's file functions do unsafeInterleaveIO?
11:35:03 <Baughn> frwmanners: Eg. when merging two Events
11:35:47 <Taejo> @pl (\x -> not $ (x `inDB` db) || ("#" isPrefixOf x))
11:35:48 <lambdabot> not . liftM2 (||) (`inDB` db) isPrefixOf
11:36:09 <Baughn> frwmanners: "Event a's first occurence is at 1.5 seconds. Event b's first occurence is unknown, but will get timestamped when it happens. We can wait until either (a) it happens, or (b) its clock says 1.5 seconds too, in which case a is first
11:36:37 <Baughn> ...oh god, the horror
11:36:48 <frwmanners> Baughn: I'd agree with that, but I'm now confused
11:36:55 <Taejo> hang on, that's not right
11:36:57 <int-e> Athas: what are you expecting it to do? and what are you reading?
11:37:02 <Taejo> @pl (\x -> not $ (x `inDB` db) || (['#'] isPrefixOf x))
11:37:03 <lambdabot> not . liftM2 (||) (`inDB` db) isPrefixOf
11:37:06 <Taejo> ack
11:37:14 <Taejo> @pl (\x -> not $ (x `inDB` db) || ("#" `isPrefixOf` x))
11:37:14 <lambdabot> not . liftM2 (||) (`inDB` db) ("#" `isPrefixOf`)
11:37:33 <gwern> '                             The preferred solution would be developers more ex-
11:37:37 <gwern> perienced in Haskell, but the combined Haskell and financial knowledge is rather
11:37:40 <gwern> rare, and it seems that even a relatively inexperienced Haskell programmer can be
11:37:43 <PeakerWork> Athas: do you want lazy I/O? Do you mind if the entire file is read immediately?
11:37:43 <gwern> more productive than an experienced C++ programmer in domains such as ours.
11:37:59 <gwern> '                                    Should in-process operation be required in the
11:38:02 <gwern> future, a com interface can be integrated (Finne et al., 1999).
11:38:04 <gwern> the fools! the poor fools!
11:38:10 <duaneb> goddamn
11:38:12 <duaneb> I hate parsing
11:38:15 <Athas> int-e: I would expect it to read a list of Word32s from a file (sequentially, I suppose).  And no, I have no strictness requirements.
11:38:32 <PeakerWork> duaneb: why not use a Haskell DSL then?
11:38:32 <duaneb> Only networking and database theory is a more evil field of computer science
11:38:42 <duaneb> PeakerWork: because I need to parse :P
11:38:49 <PeakerWork> duaneb: what needs parsing? :(
11:38:50 <Wraithan> Ok, I am writing a client for todoist, their API returns JSON objects and I can get the JSON object into a object I could potentially use but I have no clue a to how I would get the data I need from it: http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2532
11:39:03 <duaneb> PeakerWork: s expressions
11:39:06 <Baughn> frwmanners: You're not the only one. I'll need to break referential transparency to implement this.
11:39:06 <duaneb> homework :/
11:39:31 <Taejo> what characters do I need to escape to make a string into a regex that matches itself?
11:39:32 <Wraithan> I would like to grab the api_token value (along with others) but it seems like a rather complicated object to reach in and just grab that data
11:39:42 <Baughn> frwmanners: Hopefully in a safe manner, exporting a referentially transparent /interface/, but.. oh my, I see why reactive has provoked RTS bugs
11:40:01 <frwmanners> Baughn: I'm happy to think of the eventual goal (futures) as a fairly reasonable extension of the language's semantics
11:40:15 <int-e> Athas: well, the list instance reads a word from the file, treats it as the length of the returned list, and then reads that many words. and decodeFile is strict so it won't return any data before the whole list is read.
11:40:25 <gwern> Wraithan: wouldn't it be something like 'api_token $ r'?
11:40:32 <frwmanners> Baughn: but I agree, that makes implementing it using current methods sort of unpleasant
11:40:44 <gwern> Wraithan: since each field of a record has a getter function defined of the smae name
11:41:21 <Wraithan> gwern: ok, so how would I access those getter fuctions?
11:42:25 <gwern> Wraithan: or, looking at http://hackage.haskell.org/packages/archive/json/0.4.3/doc/html/Text-JSON-Types.html#v%3AfromJSObject
11:42:31 <gwern> why not use get_field ?
11:43:00 <gwern> offhand, it looks like 'get_field r "api_token"' might work?
11:43:03 <frwmanners> Baughn: fyi, my original concern was that AddBounds (Improving t) hides all information when we don't know whether the occurrence is finite or not
11:43:31 <frwmanners> Baughn: Improving (AddBounds t) is better; but as I say, this has already been done
11:44:58 <Taejo> how do I delete a file from a Haskell program?
11:45:07 <mauke> @hoogle removeFile
11:45:07 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
11:45:15 <gwern> Taejo: too vague; say more
11:45:15 <Taejo> thanks, mauke
11:46:01 <Taejo> the web version of hoogle finds no results for removeFile (I already guessed that name)
11:47:19 <int-e> Athas: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5450#a5452 may work better for you
11:47:44 <int-e> Athas: where 'all' should be 'allWords'
11:48:08 <Athas> int-e: thanks, I will try it out.
11:48:26 <int-e> Athas: and 't' too. (darn. I should test the code after renaming an identifier twice)
11:50:12 <cads_> the set C of infinite sequences of binary digits is searcheable. That means that in finite time, we can either return an element of it that satisfies a certain predicate, or say that the element does not exist in C.
11:50:24 <cads_> this is a pretty shocking statement to me
11:50:30 <Wraithan> Is there any way to strip that left and right crap off so I don't have to worry about both sides of the case returning the same value? just want to simplify things so I can get to actually trying to figure out how to do this, rather than running into typing issues because one side of a case returns something different (when I am just using it to strip left/right)
11:50:32 <cads_> are you guys familiar with this result?
11:51:05 <int-e> cads_: the point is that the predicate must be computable.
11:51:14 <cads_> Exhaustible Sets in Higher-Type Computation: http://arxiv.org/abs/0808.0441
11:51:31 <Twey> cads_: Of course it's true
11:51:49 <int-e> http://www.cs.bham.ac.uk/~mhe/papers/seemingly-impossible.html
11:52:14 <Twey> Up to any given element, the set is finite
11:52:40 <PeakerWork> cads_: you're searching a finite element of it -- if you sort the infinite sequences by length, its enough to get to a higher-lengthed one than the one you search?
11:52:51 <cads_> int-e: I was wondering how a function of infinite rank could be used as our predicate and still preserve searcheability
11:53:06 <hackagebot> MonadCatchIO-mtl 0.2.0.0
11:54:00 <yitz> hackagebot?
11:54:18 <yitz> that's nice.
11:54:27 <mauke> not nice enough
11:54:36 <yitz> mauke?
11:54:39 <mauke> it should use CTCP ACTIONs to announce stuff
11:54:47 <cads_> so, Twey, I can't use this to create a representation of the binary number equal to the square root of two, for example?
11:55:31 <Twey> Of course â€” that's irrational and is itself infinite
11:55:56 <cads_> but it's a computable real
11:56:21 <cads_> that is, there are reals that can't even be defined by a finite computational rule
11:57:17 <Wraithan> @hoogle JSValue -> JSObject
11:57:17 <lambdabot> Warning: Unknown type JSValue
11:57:17 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:57:17 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:58:06 <Wraithan> @hoogle Text.JSON.JSValue -> Text.JSON.JSObject
11:58:06 <lambdabot> Parse error:
11:58:07 <lambdabot>   --count=20 "Text.JSON.JSValue -> Text.JSON.JSObject"
11:58:07 <lambdabot>                  ^
11:58:12 <Wraithan> bleh
11:58:22 <crem> listAvg x = ( fromIntegral $ sum x ) / ( fromIntegral $ length x )   -- why do I need the second pair of parentheses?
11:58:27 <cads_> hmm, I think I'll implement the algorithm in the paper and see what it gives me to play with
11:58:48 <Jedai> @hoogle JSValue -> JSObject +json
11:58:48 <lambdabot> Could not find file:
11:58:48 <lambdabot>     json
11:58:48 <lambdabot> Searched:
11:58:55 <int-e> Wraithan: pattern match on the JSObject constructor?
11:59:05 <EvilTerran> crem, because / is tighter binding than $
11:59:09 <Wraithan> int-e: huh?
11:59:15 <crem> EvilTerran, thanks.
11:59:34 <Wraithan> @hoogle String -> JSObject
11:59:35 <lambdabot> Warning: Unknown type JSObject
11:59:35 <lambdabot> Prelude error :: String -> a
11:59:35 <lambdabot> Debug.Trace trace :: String -> a -> a
11:59:35 <Jedai> Wraithan: http://www.haskell.org/hoogle/?hoogle=JSValue+-%3E+JSObject+%2Bjson
11:59:36 <yitz> @info (/)
11:59:36 <lambdabot> (/)
11:59:57 <int-e> Wraithan: case jsvalue of JSObject jsobject -> jsobject; _ -> error "not an object"
11:59:57 <yitz> urgh, no fixity info.
12:00:20 <EvilTerran> @recall @info
12:00:20 <lambdabot> Unknown command, try @list
12:00:21 <cads_> aaack
12:00:26 <EvilTerran> @quote @info
12:00:26 <lambdabot>  @info says: typo-corrects to @undo. it isn't a real command.
12:00:33 <cads_> the predicate must be total
12:01:14 * cads_ had really wanted to believe the stronger version he'd imagined
12:02:08 <Jedai> cads_: Well if it takes infinite time to return, it sure won't find the searched element in finite time...
12:02:48 <Baughn> cads_: Well, I dare say an incomputable predicate won't be very useful on a computer..
12:03:00 <Baughn> Or anywhere in this universe, really
12:03:05 <Heffalump> oh, hi kowey
12:03:10 <Heffalump> I was just trying to email you, one-handed
12:03:23 <Heffalump> The Darcs wiki used to have links like
12:03:23 <Heffalump> http://wiki.darcs.net/index.html/Foo
12:03:23 <Heffalump> and
12:03:23 <Heffalump> http://wiki.darcs.net/DarcsWiki/Foo
12:03:24 <Heffalump> (a) the front page of http://darcs.net points to these old URLs
12:03:26 <cads_> Baughn: hyper-turings? :D
12:03:28 * Baughn wonders why join isn't part of the Monad class
12:03:35 <Jedai> cads_: What was your stronger version like ? I can't really imagine
12:03:42 <Baughn> cads_: Aren't incomputables beyond even them
12:03:42 <Heffalump> (b) we should probably use Apache redirect rules to deal with other links we don't know about
12:03:45 <gwern> @src join
12:03:45 <lambdabot> join x =  x >>= id
12:04:01 <Baughn> cads_: No matter. Current physical law says the universe is turing-computable.
12:04:03 <gwern> Baughn: if it can be defined using just the existing monadic typeclass, why add it?
12:04:08 <cads_> :)
12:04:12 <kowey> Heffalump: oh, yes
12:04:13 <EvilTerran> Baughn, for the same reason Functor isn't a superclass of Monad?
12:04:19 <Heffalump> sorry, wrong channel!
12:04:21 * Heffalump --> #darcs
12:04:30 <Baughn> gwern: Because you can also define >>= in terms of join and fmap, and it's often easier to do it that way around
12:04:36 <EvilTerran> gwern, but in some circumstances, it'd be nice to be able to define a monad in terms of fmap/join/return instead of >>=/return
12:04:38 <cads_> I think the point of hyper-turings is to compute with complete real numbers or higher cardinalities
12:04:52 <Jedai> gwern: to have specialized version (and we could have default definition for >>= in function of join and vice-versa
12:05:07 <Baughn> gwern: Plenty of libraries first define join, then go on to implement >>= in terms of join, then have of course join in terms of >>=...
12:05:19 <Baughn> That's not including reactive, which has >>= in terms of join and join in terms of >>=
12:05:42 <Baughn> In that case it's the /same/ join. Knot-tying for the win? ^^;
12:05:53 <EvilTerran> O.o
12:06:04 <ray> join join fmap fmap fmap fmap join
12:06:21 <EvilTerran> ?type join join fmap fmap fmap fmap join
12:06:22 <lambdabot>     Occurs check: cannot construct the infinite type:
12:06:22 <lambdabot>       t = t -> t -> t1 -> t2 -> t3 -> t4 -> t5
12:06:22 <lambdabot>     Probable cause: `join' is applied to too few arguments
12:06:32 <Baughn> Anyway, statements like " e >>= f  = joinE (fmap f e)" are very common in monad instances..
12:06:33 <EvilTerran> ... actually, i think it's applied to too many. :P
12:06:36 <cads_> Jedai: I thought we were somehow able to quantify over the binary numbers that have computable expressions in terms of partial fractions or something like that
12:06:48 <ray> yeah, i'm just beatboxing
12:07:07 <ray> :k Join
12:07:08 <lambdabot> Not in scope: type constructor or class `Join'
12:08:27 <cads_> that set would be compact in C
12:09:06 <duaneb> could someone help me with my s-expr parser?
12:09:06 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5453#a5453
12:09:08 <cads_> or {0, 1}^|N|
12:09:11 <duaneb> specifically parseCons
12:09:16 <duaneb> There are two type errors
12:09:17 <opqdonut> cads_: which set?
12:09:26 <duaneb> at lines 42 and 47
12:09:32 <duaneb> and I can't figure it out :/
12:09:44 <cads_> the set of binary numbers generated by algorithms of finite length
12:09:52 <opqdonut> ah
12:10:30 <opqdonut> how would it be compact in {0,1}^N
12:10:49 <duaneb> well
12:10:54 <duaneb> I've figured out the problem
12:10:58 <duaneb> I just don't know why it exists
12:12:08 <Baughn> conal: I think I've figured out how to fix makeEvent. You had, of course, covered it in the paper, but you know about information which man was not meant to know? This is some of it.
12:12:13 * Baughn quietly goes insane
12:12:19 <duaneb> anyone? :|
12:12:20 <cads_> opqdonut: I think you could write a sequence of generated numbers approaching any incomputable number, as their generator algorithms tended towards infinite length
12:12:41 <EvilTerran> duaneb, i think, around line 42, you need "case endMaybe of Just _ -> return Null; Nothing -> parseLispType ..."
12:12:46 <Baughn> duaneb: Ah, add the type errors as a revision please
12:12:52 <cads_> but that actually seems like it could be disastrously bad intuition on by part :)
12:12:53 <Jedai> duaneb: are you aware that they're a tutorial that show you step by step how to write a parser (with Parsec) and interpreter for Lisp in Haskell ?
12:13:03 <Jedai> *there is
12:13:04 <duaneb> Jedai: yea, I don't like their parsing :P
12:13:06 <EvilTerran> duaneb, and similarly around 47, i suspect
12:13:17 <Jedai> duaneb: Oh, ok... :D
12:13:21 <opqdonut> cads_: hmm, what was the criterion for sequentially compact <=> compact
12:13:27 <opqdonut> cads_: was it hausdorff or T3?
12:13:37 <duaneb> EvilTerran: isn't that what I wrotE?
12:13:39 <duaneb> wrote*
12:14:11 <EvilTerran> duaneb, i mean, the second branch is already a monadic action, so shouldn't be wrapped in a "return"
12:14:17 <cads_> opqdonut: well for example the rational numbers are compact in the reals, even though they're countable. This is because between any two reals there's still a rational
12:14:27 <EvilTerran> duaneb, so you should float the "return" wrapping the case to inside it
12:14:46 <duaneb> EvilTerran: ok, but why?
12:14:51 <EvilTerran> (and only to the Just/Null branch)
12:15:05 <EvilTerran> duaneb, the type of >>=
12:15:07 <EvilTerran> ?type (>>=)
12:15:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:15:20 <EvilTerran> the RHS has to result in a monadic value
12:15:25 <opqdonut> cads_: my point was, there are sequentially compact (=> each sequence has a limit) spaces that are not compact (=> each open cover has a finite subcover)
12:15:48 <EvilTerran> duaneb, in parseLispType >>= (\t -> Cons t parseCons'), you're not doing that
12:16:46 <EvilTerran> duaneb, and, re-writing that to, say "liftM (`Cons` parseCons) parseLispType", that's also a monadic action
12:16:47 <duaneb> ah, nm
12:16:48 <duaneb> figured out
12:16:51 <EvilTerran> duaneb, so you don't need to wrap it in return
12:17:05 <duaneb> EvilTerran: no, the problem was I was passing Cons a monad
12:17:11 <duaneb> instead of what was in the monad
12:17:21 <duaneb> (parseCons' instead of what was in parseCons')
12:17:39 <EvilTerran> uh
12:17:41 <Jedai> duaneb: The objective of return is to lift an ordinary value into the monad, here the second branch of the case isn't an ordinary value but monadic (it's also different from the type of the first branch of the case which is an obvious error)
12:17:45 <cads_> opqdonut: hmm, sec while I open my analysis book :)
12:17:50 <EvilTerran> duaneb, parseLispType >>= (\t -> Cons t parseCons') still isn't going to work
12:17:57 <EvilTerran> even if you deal with parseCons'
12:18:19 <opqdonut> cads_: in metric spaces sequential compactness is the same as compactness, but not generally in topological spaces
12:18:30 <opqdonut> cads_: however, there was a simple criterion for when they are the same
12:18:52 <EvilTerran> because (>>=) :: Parser a -> (a -> Parser b) -> Parser b, and (Cons ...) does not fit "Parser b"
12:19:05 <duaneb> ah.
12:19:20 <EvilTerran> ?type liftM
12:19:21 <duaneb> I still don't get why putting the return inside each of the cases would help....
12:19:21 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
12:19:37 <duaneb> the `case` type SHOULD be LispType
12:19:53 <Jedai> duaneb: it won't be sufficient, but at least both branch of the case will have the same type
12:19:55 <EvilTerran> duaneb, you're doing monadic stuff in one branch of the case
12:20:10 <EvilTerran> duaneb, and "return (...)" has no monadic side-effects
12:20:22 <duaneb> ahh, never mind
12:20:26 <duaneb> I figured it out
12:21:00 <Jedai> duaneb: the second branch should be something like do { lt <- parseLispType; c' <- parseCons'; return (Cons lt c') }
12:21:22 <cads_> opqdonut: bleh, I can't make {0,1}^|N| into a metric space
12:22:10 <cads_> wait yes i can
12:25:19 <cads_> p(a, b) = sum (a_k + b_k)/2^k.  a, b in {0,1}^|N|
12:26:01 <conal> Baughn: glad to hear you're making progress.  there's a lot packed into that paper.  easy to miss things.
12:26:11 <_JFT_> Is there some prescribed way to mix State and ST monads? Or is that a general don't? I have a specific application where I need to hold a few tables of "record" which are actually references. There are cyclical references.
12:26:46 <_JFT_> So I was thinking of using an State monad for the topology containing the various tables and entry points
12:27:04 <_JFT_> in these tables are record containing STRef
12:28:19 <Baughn> conal: This time I'm carefully writing tests as I find problems, and coupling them to cabal test. I estimate the probability of this breaking in a future GHC update at 80-something percent.
12:28:36 <int-e> _JFT_: StateT state (ST s) should work fine as a monad. Or you could store the state in an STRef.
12:29:19 <_JFT_> int-e: I wanted to avoid stocking that state in an STRef since I want need to stack many maniupulation and wanted to avoid manually threading that state
12:29:48 <Jedai> _JFT_: Then StateT state (ST s) should be perfect, no ?
12:30:05 <int-e> _JFT_: or, meet in the middle, ReaderT (STRef s state) (ST s)
12:30:14 <_JFT_> int-e: interesting...
12:30:33 <duaneb> ok
12:30:38 <duaneb> I got my sexpr working
12:30:38 <duaneb> but
12:30:40 <_JFT_> int-e: thanks for the ReaderT (STRef s state) (ST s) very clever!
12:30:47 <_JFT_> int-e: I am going to try that route :)
12:30:54 <duaneb> if there's trailing text, my parser ignores it
12:31:06 <conal> Baughn: thanks a bunch for the tests!  please include them in your next darcs patch.  when unamb gets solid and efficient, i predict people will come up with lots of cool uses.
12:31:15 <mauke> <* eof
12:31:20 <Jedai> duaneb: put eof at the end of your parser
12:33:11 <duaneb> Jedai: yea, just figured that out :P
12:33:19 <_JFT_> int-e: the part that was bugging me is how do I eval a combination of State and ST if 2 or more field of my state are ST s...
12:33:43 <_JFT_> int-e: using the ReaderT approach i.e. should bypass that issue
12:34:17 <hackagebot> uu-parsinglib 2.1.0
12:37:18 <int-e> hackagebot should sat 'new package:' or something like that in addition to the package name.
12:38:09 <mauke> hackagebot should /nick hackage and announce things in the format /me upload: uu-parsinglib 2.1.0
12:47:26 <bakesz> hi guys!is there some way to look into a function,which is made by another function?(sorry for my english).thanks for help
12:48:07 <Twey> Template Haskell says yes.
12:48:33 <ray> templatehaskellsayswhat?
12:49:01 <IRZ> hi
12:49:05 <IRZ> can u have two foreign keys for one table (each with multiple columns) pointing to the same table.
12:49:45 <Heffalump> IRZ: Haskell isn't a database
12:50:17 <Botje> bakesz: "look into a function" ?
12:50:57 <IRZ> i cant find an answer to my question, so i thought i would ask here
12:51:02 <IRZ> wha tis haskel exactly ?
12:51:08 <IRZ> alot of people in thsi room
12:51:10 <Heffalump> it's a programming language
12:51:16 <IRZ> i guessed that
12:51:25 <IRZ> but umm whats it predominantly used for
12:51:32 <Heffalump> there's URLs in the topic you can use to find out about it
12:51:49 <tux_rocker> http://en.wikipedia.org/wiki/Haskell ?
12:51:57 <IRZ> was looking for a  one sentece answer
12:51:59 <IRZ> i dotn really care
12:52:07 <IRZ> thx tho
12:52:34 <tux_rocker> does anyone know a way to serialize a System.Random.StdGen?
12:52:42 <kynes> hi, I have a question about Test.QuickCheck
12:52:49 <tux_rocker> there's Read and Show instances but they're asymmetric
12:52:49 <Heffalump> tux_rocker: it's just a pair of Integers, isn't it?
12:52:55 <Heffalump> that sucks
12:53:11 <tux_rocker> Heffalump: it is, but you can't build a StdGen straight from the pair of integers
12:53:30 <tux_rocker> kynes: alright, go ahead
12:53:30 <Heffalump> I think asymmetric Read/Show is a bug.
12:53:46 <kynes> it generates objects having random values to check a property, the question is, can I get these temporary objects ? I mean I want to report them
12:54:12 <tux_rocker> kynes: you could use Debug.Trace in the code of your tests
12:54:13 <kynes> tux_rocker, is there a way to see the object during the check ?
12:54:24 <kynes> tux_rocker, can you give an example usage ?
12:54:37 <kynes> tux_rocker, thank you btw
12:54:42 <Heffalump> I think QuickCheck 2 might have hooks to help with this
12:55:51 <bakesz> Botje: i mean like this: let sum_nums w=if w==0 then 0 else (\f x -> (f (x-1)) +x ) sum_nums w
12:55:52 <tux_rocker> Heffalump: I see no hooks on a quic first glance
12:56:15 <Heffalump> fair enough
12:56:18 <bakesz> it generates function to every input argument,and i would like to see it
12:56:44 <Botje> you can't print functions
12:57:24 <bakesz> that's sad.
12:57:28 <Botje> bakesz: you could put a trace inside that anonymous lambda, though
12:57:47 <Botje> import Debug.Trace
12:57:48 <tux_rocker> kynes: import Debug.Trace\nprop x y = trace ("x = " ++ show x ++ ", y = " ++ show y) $ x == y || x /= y\nmain = quickCheck prop
12:57:59 <tux_rocker> kynes: replace \n by newline
12:58:24 <Botje> let sum_nums w = if w == 0 then 0 else (\f x -> trace (show x) $ f (x-1) + x) sum_nums w
12:58:34 <kynes> tux_rocker, thanks!
12:58:37 <Botje> of course that fragment is pretty contrived
12:58:58 <Botje> why bother with the lambda if you're going to apply it sitrectly after ...
12:59:15 <Botje> let sum_nums w = if w == 0 then 0 else sum_nums (x-1) + x
12:59:23 <Botje> err
12:59:28 <Botje> let sum_nums w = if w == 0 then 0 else sum_nums (w-1) + w
12:59:52 <Botje> and then you might use pattern matching
13:00:39 <Twey> let sum_nums 0 = 0; sum_nums w = sum_nums (w - 1) + w
13:01:35 <bakesz> sorry,what does "contrived" mean,because my dictionary doesn't find it
13:01:47 <Botje> really really awkward and un-haskelly
13:01:58 <Botje> not code any sensible person would write
13:02:42 <bakesz> thank you
13:02:46 <Wraithan> @type Text.JSON.decode
13:02:47 <Tsion> arg
13:02:48 <lambdabot> Couldn't find qualified module.
13:02:56 <dolio> In general it means made-up and unrealistic.
13:03:01 <Tsion> 14:02:29 <@Tsion> @run 1 + 1
13:03:01 <Tsion> 14:02:31 <lambdabot`>   L.hs:3:29: Module `Control.Arrow' does not export `pure'L.hs:3:29: Module `...
13:03:07 <Tsion> my lambdabot won't work :/
13:03:10 <tux_rocker> correction of myself: read/show for StdGen are not asymmetric
13:03:19 <Wraithan> Bleh, anyway, it returns a Result a, how I do I get the value from the result/
13:03:22 <tux_rocker> my program needed a type signature somewhere to work correctly
13:03:49 <luqui> i'd like some help on the design of a library
13:04:24 <luqui> i'm writing a proof tactics library, where a tactic takes a theorem and attempts to find a proof
13:04:27 <trofi> Tsion: try remove hiding (pure) from L.hs
13:04:33 <Tsion> trofi: It's not there
13:04:37 <luqui> er, takes a statement and ...
13:04:44 <trofi> Tsion: ~/.lambdabot/L.hs
13:05:05 <luqui> but i would like the code that decides how to find the proof to be overloaded in some respect
13:05:07 <Tsion> trofi: Whoa, thanks
13:05:20 <Tsion> I was changing it in the source and recompiling
13:05:21 <luqui> i.e. allowed to do I/O, or talk to an external context, etc.   (not committing to any particular one)
13:05:44 <luqui> but i don't want it to be able to return an invalid proof, so the "primitive constructors" are restricted
13:05:45 <luqui> any ideas?
13:05:50 <luqui> does that make sense?
13:06:01 <_JFT_> int-e: can I bug you for one more question? I am trying to eval my ReaderT ST monad stack...
13:06:07 <Wraithan> decode :: JSON a => String -> Result a -- How do I get the value of a? I am doing really bad at this haskell stuff so far lol
13:06:20 <PeakerWork> luqui: hey.. Is this for an interactive theorem prover?
13:06:33 <PeakerWork> luqui: or do you want to let your language's programs partially prove stuff?
13:06:41 <PeakerWork> luqui: (and allow automated proof for the rest)
13:06:46 <int-e> _JFT_: yes
13:06:46 <maltem> findProof :: (Monad m) => Tactic m a -> m (Proof a) -- ?
13:06:47 <luqui> PeakerWork, possibly-interactive.  i.e. interactivity is one of the ways to instantiate it
13:07:09 <PeakerWork> I don't think findProof can/should be in a polymorphic monad
13:07:32 <_JFT_> int-e: thanks I could paste the code if you can get a look at it please
13:07:33 <maltem> Fair enough
13:07:57 <luqui> PeakerWork, well I'd like some way to communicate the proof context to the user from within the library
13:08:05 <luqui> yeah, partiality is acceptable
13:08:17 <PeakerWork> luqui: proof :: Theorem -> ErrorT ProofFailure IO Proof  -- where Proof is represented in a form that is always valid?
13:08:26 <luqui> I don't want IO in the type
13:08:29 <PeakerWork> luqui: I guess it might be proving some *other* theorem, heh
13:08:36 <luqui> right, that too
13:08:46 <_JFT_> int-e: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2533#a2533
13:08:53 <PeakerWork> luqui: so you do want the Monad to be polymorphic, as per maltem's suggestion?
13:08:56 <luqui> so the primitive combinators only allow proofs of what you're actually trying to prove
13:09:24 <luqui> PeakerWork, I think so...
13:09:27 <PeakerWork> luqui: Sounds impossible in Haskell (that the type will guarantee that the result proof is of that theorem), but maybe I'm wrong
13:09:30 <luqui> maltem, what is this a?
13:09:41 <luqui> PeakerWork, should be possible using some variant of certificate
13:09:46 <luqui> i just can't figure out that variant
13:09:50 <PeakerWork> luqui: what's that?
13:09:51 <_JFT_> int-e: I understand the problem is with my "s" state thread variable
13:10:04 <luqui> restricting the constructors you expose only to allow valid proofs
13:10:19 <_JFT_> int-e: but I have no idea how to fix it ( I guess I have to quantify it? forall s. etc?)
13:10:20 <maltem> luqui, no idea, I thought you may want to put something resultish in there
13:10:27 <PeakerWork> luqui: but they don't only have to be valid proofs, they also have to be proofs of some other argument
13:10:33 <luqui> like, modusPonens :: Proof -> Proof -> Maybe Proof
13:10:55 <PeakerWork> luqui: (of some theorem
13:11:24 <_JFT_> int-e: I added missing part at the top http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2533#a2534
13:11:33 <luqui> PeakerWork, well, yeah, that's the challenge.  Thus exposing the type as a plain function isn't an option
13:11:49 <luqui> i.e. Term -> Proof is no good, because that's allowed to return proofs that are not proofs of that term
13:11:57 <luqui> so instead it's got to be an abstract type Tactic
13:12:04 <luqui> whose structure I cannot figure out...
13:12:58 <luqui> like, basic tactic combinators are easy.  the problem is shoving that monad/whatever in there
13:13:06 <PeakerWork> luqui: the caller can always validate the proof :-)
13:13:10 <luqui> so that it can make decisions based on the context
13:13:19 <luqui> PeakerWork, don't want them to have too
13:13:21 <luqui> *to
13:14:06 <luqui> i have a hunch that if it's guaranteed *locally* correct, then it will be easy to verify
13:14:07 <int-e> _JFT_: give a type signature: evalTopology :: (forall s . Topology s v f a) -> a
13:14:08 <luqui> formally
13:14:47 <_JFT_> int-e: thank you VERY much :) I haven't played much with ST and constantly get into problem with the "s" :(
13:15:30 <int-e> _JFT_: (requires Rank2Types or RankNTypes) The error message basically means that 'runST' wants to fix the type of 's' itself, but can't, because it's already fixed by the (inferred) type signature of evalTopology.
13:16:35 <PeakerWork> luqui: can you show for example, some basic tactic combinators?
13:16:56 <_JFT_> int-e: I read your explanation "loud and clear" but the original message wasn't as clear ;) I'll read it back with you interpretation! Thanks again!
13:18:25 <luqui> PeakerWork, intro (\h -> assumption h)     -- proves eg. A -> A
13:18:51 <luqui> but i'd like to be able to:  intro (\h -> interactive)
13:19:16 <luqui> er, mentioning h in interactive so that it can add it to the context
13:20:31 <_lilian_> ouvindo ( Francesco Napoli - Balla Balla.mp3 ) .: kikøscript :. http://kikoscript.blogspot.com
13:20:50 <luqui> my intended usage may be flawed, too...
13:21:27 --- mode: ChanServ set +o mauke
13:21:45 --- mode: mauke set -o mauke
13:35:37 <bnijk> http://shootout.alioth.debian.org/u32q/benchmark.php?test=all&lang=ghc&lang2=gnat&box=1 <-- ????
13:35:46 <bnijk> what's with the memory use
13:48:38 <mux> rah
13:48:39 <mux> atsui!
13:49:09 <Twey> Atsusugi :(
13:49:54 <shapr> AKIRA!
13:50:03 <mxc> nihon kara dete!
13:50:15 <mxc> nihon no natsu ga taihen dane!
13:50:30 <Jedai> bnijk: ? What's the problem ? Except the Mandelbrot bench, the factor compared to ADA are quite normal and even for the mandelbrot, the memory usage isn't that far fetched
13:50:40 <shapr> Jag har ingen aning vad du sÃ¤ger!
13:51:01 <xian> shapr: I have no idea what you say?
13:51:02 <shapr> MinÃ¤ haluan hampurilainen!
13:51:23 <shapr> xian: Yup, you got the Swedish correct, now can you translate the Finnish?
13:52:19 <Chile`> is there a common method of doing substring replaces in haskell? there doesn't seem to be a standard one, unless I'm just missing it in the docs
13:52:21 <xian> shapr: Wow, Swedish is really similar to German :)   As to the Finnish, I happen to know that minÃ¤ means ``I'', so I guess it's also something along "I have no idea"
13:52:53 <RayNbow> mxc: why use romaji? :p
13:52:58 <shapr> xian: Actually I said "I want a hamburger."
13:53:12 <shapr> xian: joda, svensk Ã¤r mycket lika som tysk.
13:53:31 <shapr> xian: Talar du tysk?
13:53:36 <RayNbow> @users
13:53:36 <lambdabot> Maximum users seen in #haskell: 658, currently: 601 (91.3%), active: 19 (3.2%)
13:54:01 <xian> shapr: Yeah, that's my native language.
13:54:26 <shapr> kul :-)
13:54:42 <shapr> My native language is Southern. I'm from Alabama.
13:54:58 <mxc> raynbow - does IRC support unicode?
13:55:07 <mxc> ãƒ†ã‚¹ãƒˆ
13:55:17 <mxc> è©¦é¨“
13:55:24 <mxc> well, i see that, not sure if anyone else does
13:55:30 <shapr> I see it.
13:55:58 <xian> shapr: Ah, I see. It's interesting to know that there are Swedish speakers in AL.
13:56:05 <Jedai> Chile`: not really
13:56:10 <shapr> xian: I learned Swedish at the same time my German/French fiancee was learning it, she learned Swedish very quickly.
13:56:28 <shapr> xian: Well, I'm in Boston these days, but I'm sure there must be at least one or two Swedish speakers in AL.
13:56:43 <shapr> xian: Are you in Boston? Want to hang out?
13:56:53 <Jedai> Chile`: it's not too hard to cook one for your specific need most of the time though
13:57:08 <RayNbow> mxc: as long as two persons use the same appropiate encoding, they can use unicode over IRC
13:57:25 <shapr> Sadly, IRC dÃ¶s not specify an encoding.
13:57:33 <shapr> So most channels choose one.
13:57:36 <Chile`> Jedai: no, it's not difficult at all, but every time I rewrite something that fundamental i cringe a little bit :)
13:57:40 <Jedai> mxc: I see it (assuming you see the same as me)
13:57:45 <shapr> Er, most channels that aren't ASCII.
13:57:53 <mxc> for some reason, i imagined that the irc servers would mangle it
13:58:06 <xian> shapr: I'd love to, but for now it seems as if I'm stuck in Germany.
13:58:13 <shapr> Well, you should come visit!
13:58:13 <mxc> although, i guess if its UTF-8, there aren't any \0's in leading bytes
13:58:34 <Jedai> Chile`: I agree that it's annoying, maybe someone should just put a module with some traditional variants on hackage
13:58:57 <shapr> Jedai: Good idea! Go for it!
13:59:11 <Jedai> shapr: I just may :)
13:59:12 * wli would love to be stuck in Germany
13:59:36 * RayNbow wouldn't :p
14:00:17 <RayNbow> (but that's because I haven't practiced German in a long while)
14:02:24 <monochrom> IRC is neutral to "does it support unicode or not". Two humans conversing with each other decide what the bytes mean.
14:03:33 <monochrom> My stand is I insist on UTF-8 and you can bite me.
14:06:09 * RayNbow recently had a small UTF8 problem :p
14:08:40 <RayNbow> (when I replaced xmonad with xmonad-darcs... xmobar was no longer displaying text correctly... replacing System.IO.UTF8.hPutStrLn with hPutStrLn in my config fixed it :p)
14:23:42 <Chile`> kind of a best practices question.. is monadic parsing actually used in practice, or would basically everyone use Happy or such?
14:23:58 <augustss> I wouldn't
14:24:04 <augustss> use happy
14:24:05 <Heffalump> I think most people use parser combinators
14:27:07 <mmorrow> Chile`: mostly happy's used for language parsers and parser combinators for smaller stuff
14:27:08 <luqui> though people seem to be moving toward applicative style
14:27:23 <skorpan> is it okay to call constructors functions if the context makes it clear that they are indeed constructors?
14:27:57 <luqui> skorpan, do you mean "is it okay to call functions constructors if ..." ?
14:28:09 <skorpan> no, i meant what i said :)
14:28:13 <luqui> constructors *are* functions
14:28:15 <PeakerWork> luqui: can an Applicative parser be optimized in ways that a monadic parser can't?
14:28:23 <luqui> PeakerWork, yeah
14:28:24 <skorpan> yes, i know
14:28:34 <skorpan> i'm just not sure whether it's a generally accepted fact
14:28:42 <PeakerWork> luqui: I thought the fact applicatives were parameterized over functions destroyed that
14:29:26 <Chile`> mmorrow: makes sense, I'll stick to that
14:29:43 <luqui> PeakerWork, i'm no expert, but I think there are some optimizations possible
14:29:48 <luqui> not *all* the context-free ones, though
14:31:03 <mmorrow> Chile`: (and you usually use a monad along with happy, although you don't necessarily have to)
14:31:07 <peanuts> i have a beginner question about my implementation of quicksort for list of lists, maybe someone could give me a pointer
14:31:21 <peanuts> i'm getting a non-exhaustive pattern error
14:31:28 <luqui> peanuts, paste
14:31:34 <luqui> if you please
14:31:54 <Chile`> mmorrow: alright. I haven't looked at happy at all past knowing of it's existence.
14:31:54 <peanuts>  sortLists :: Ord a => [[a]] -> [[a]]
14:31:54 <peanuts>   8 sortLists [[]] = [[]] -- pattern matching instead of "null"
14:31:54 <peanuts>   9 sortLists (x:xs) = sortLists shorterOnes ++(x:sortLists longerOnes)
14:31:54 <peanuts>  10    where
14:31:54 <peanuts>  11      shorterOnes = [y | y <- xs, length y < length x ]
14:31:54 <peanuts>  12      longerOnes  = [y | y <- xs, length y >= length x]
14:32:07 <BONUS> [[]] is not an empty list :)
14:32:24 <BONUS> it's a lsit that has one element (an empty list)
14:32:25 <duaneb> ok
14:32:30 <duaneb> how can I compare functions?
14:32:34 <Twey> duaneb: You can't
14:32:36 <duaneb> e.g. (not == not)
14:32:38 <duaneb> :(
14:32:39 <Twey> It doesn't make sense
14:32:43 <PeakerWork> peanuts: why is a sort of lists different from a sort of values?
14:32:44 <duaneb> yes it does
14:32:50 <duaneb> you can compare variables
14:32:51 <luqui> duaneb, (not in general.  there are classes of function types that you can compare)
14:32:56 <duaneb> "variables"
14:32:59 <PeakerWork> Maybe if functions were total, you could compare them?
14:33:02 <duaneb> and functions can be data
14:33:20 <Twey> duaneb: If you have two functions that do the same thing in different ways, are they equal?
14:33:25 <peanuts> oh I didn't realize that I could drop the inner empty list
14:33:29 <BONUS> > sortBy (compare `on` length) [[1,2,3],[1],[1,2,3,4,5]]
14:33:30 <PeakerWork> duaneb: but should (1+) == (+1) return True or False?
14:33:31 <lambdabot>   [[1],[1,2,3],[1,2,3,4,5]]
14:33:33 <peanuts> I thought it would be a type error
14:33:36 <luqui> PeakerWork, not always.  you can compare functions with compact, overt domain
14:33:38 <Twey> They may have different complexities
14:33:49 <Chile`> luqui: applicative parsing referring to http://book.realworldhaskell.org/read/using-parsec.html#id652517  this sort of thing?
14:33:49 <duaneb> peaker: well, are they the same function?
14:33:51 <duaneb> probably not.
14:34:03 <duaneb> it depends on how ghc compiles them
14:34:04 <PeakerWork> duaneb: they have the same domain, range, and mapping between them
14:34:05 <luqui> duaneb, we say two functions are the same if they do the same thing to every argument
14:34:11 <PeakerWork> duaneb: but they might have different operational semantics
14:34:14 <duaneb> well, yea
14:34:20 <duaneb> just compare the pointers!
14:34:25 <PeakerWork> duaneb: should (==) between functions compare just denotational semantics or also operational semantics?
14:34:30 <luqui> duaneb, that violates a fundamental premise of haskell
14:34:38 <duaneb> no, it really doesn't.
14:34:39 <peanuts> thanks for the help!
14:34:43 <Chile`> peanuts: what part of OR?
14:34:54 <luqui> duaneb, maybe you should come back after you have researched a little
14:35:02 <PeakerWork> duaneb: what's the point of comparing functions by pointer to the implementation?
14:35:03 <duaneb> luqui: maybe you could help
14:35:08 <duaneb> I need to compare two functions
14:35:10 <peanuts> Corvallis
14:35:12 <PeakerWork> duaneb: what for?
14:35:17 <Chile`> peanuts: what part of Corvallis? :)
14:35:18 <duaneb> I have a lambda data type
14:35:22 <duaneb> for an interpreted language
14:35:26 <luqui> duaneb, sure, but don't reply with "no it really doesn't" without knowing what you're saying
14:35:26 <duaneb> that has a function in haskell
14:35:28 <copumpkin> duaneb: if the input is enumerable and the output has equality, then you can ;)
14:35:33 <copumpkin> enumerable in the non
14:35:35 <BONUS> also is (head == foldr const undefined)
14:35:36 <copumpkin> -Enum sense
14:35:50 <duaneb> luqui: I understand what you're saying
14:35:55 <mmorrow> , id .==. id
14:35:56 <peanuts> Chile
14:35:57 <lunabot>  True
14:35:58 <Twey> Under purity laws, optimisation means that the same name may not refer to the same function
14:35:59 * mmorrow ducks
14:36:04 <PeakerWork> duaneb: (+1) and (1+) do the exact same thing to every input, but they might have different "function pointers", should they not compare equal?  Note that the result of (4+4) and 8 may be different "pointers" in the implementation but (==) will still return True
14:36:12 <copumpkin> mmorrow: lol, what is that comparing? stablenames?
14:36:15 <duaneb> but at the same time, there's nothing stopping haskell from testing for equality between two arbitrary functions
14:36:19 <Twey> And two entirely different names may refer to the same function
14:36:23 <Twey> You never know
14:36:29 <peanuts> Chile`: north west, 10 min from OSU ;)
14:36:31 <duaneb> PeakerWork: yes, they should not be the same function!
14:36:33 <luqui> duaneb, well, if you're okay with the comparison returning inside IO
14:36:45 <luqui> there is a comparison a -> a -> IO Bool, but it is not to be trusted
14:36:49 <mmorrow> copumpkin: a .==. b == a `seq` b `seq` I# (reallyUnsafePtrEquality# a b)
14:36:49 <PeakerWork> duaneb: under same logic, 4 + 4 /= 8
14:36:53 <copumpkin> lol
14:36:54 <mmorrow> copumpkin: ;)
14:37:00 <duaneb> also, let f = 5; g = 5; f `funccomp` g should equal False
14:37:03 <luqui> depending on details of the garbage collector, concurrency, etc., it might give different answers for the same arguments
14:37:03 <Twey> Haskell does not do identity checking â€” purity means that everything must be checked by value only
14:37:11 <duaneb> PeakerWork: No, you're not reading what I'm saying
14:37:16 <duaneb> I don't care what the functions do
14:37:21 <duaneb> I'm trying to test identit
14:37:22 <duaneb> y
14:37:26 <mmorrow> copumpkin: err, maybe this one doesn't have the `seq`s, i can't remember
14:37:28 <PeakerWork> duaneb: Haskell has no notion of "identity", really
14:37:33 <duaneb> well
14:37:37 <Twey> duaneb: If you want identity, make your own
14:37:37 <duaneb> that's very inconvenient.
14:37:39 <mmorrow> , id [] .==. []
14:37:41 <lunabot>  False
14:37:42 <luqui> duaneb, how about this.  haskell doesn't like identity.  what are you trying to do, in the larger scheme of things?
14:37:45 <mmorrow> no seqs
14:37:55 <duaneb> compare two functions
14:37:58 <Twey> For example a Data.Unique ID attached to your language object
14:37:59 <luqui> duaneb, why?
14:38:01 <duaneb> that are stored in a datatype
14:38:09 <duaneb> luqui: let's say I'm building a tree
14:38:17 <duaneb> a sorted tree
14:38:34 <duaneb> of functions
14:38:45 <duaneb> how can I sort it if I can't test for equality at the very least?
14:38:49 <luqui> duaneb, but you don't care what the sort is, just sorted at all?
14:39:09 <duaneb> luqui: look, do you understand what I'm saying?
14:39:25 <luqui> duaneb, kind of, but I'm questioning your motivations for putting functions in a sorted tree
14:39:31 <luqui> when it's unclear when one function should be less than another...
14:39:33 <luqui> what does that mean?
14:39:33 <duaneb> luqui: I'm not actually
14:39:44 <mmorrow> duaneb: even with ptr equality, you don't get an Ord on functions.. since haskell is garbage collected
14:39:50 <hatds> sorted containers are useful because it speeds up lookup.  What you want to achieve can be done by insert (Int, func) pairs instead of just functions into your tree
14:40:01 <mmorrow> (the Ord would change every GC)
14:40:31 <luqui> duaneb, it's hard for newcomers, but haskell actually prevents you, by design, from doing certain things.  most languages don't.  you buy some nice properties this way, but it does cause you to rethink how you might approach some problems...
14:40:40 <duaneb> luqui: well, just compare pointers
14:40:41 <duaneb> so
14:40:41 <luqui> chances are, if you want to compare functions, you are not doing it "the haskell way"
14:40:44 <duaneb> I just can't do this?
14:40:44 <duaneb> Ok
14:40:48 <duaneb> this is what I'm doing
14:41:32 <duaneb> I have a lisp
14:41:35 <duaneb> I have two lambdas
14:41:38 <duaneb> built-in
14:41:47 <duaneb> defined internally as haskell functions
14:41:56 <luqui> you're writing a lisp interpreter?
14:42:00 <duaneb> I need to implement the scheme function "equal?"
14:42:18 <duaneb> part of that entails testing built-in functions for equality
14:42:20 <PeakerWork> Does Scheme have eq? and equal?
14:42:23 <duaneb> there is NO WAY to do this with haskell?
14:42:26 <duaneb> PeakerWork: yes
14:42:37 <PeakerWork> duaneb: the "built-in" functions are actually free to be *any type you choose*
14:42:38 <luqui> duaneb, there is a way, but scheme is less pure than haskell
14:42:39 <kpreid> duaneb: you have to *give* an identity to the builtin functions
14:42:48 <luqui> so you'll have to simulate the impurities manually
14:42:51 <Twey> duaneb: Like I said: data SchemeType a = SchemeType Id a
14:42:51 <PeakerWork> duaneb: they don't have to be Haskell functions
14:42:53 <luqui> as kpreid says
14:42:55 <duaneb> I am not happy.
14:43:08 <kpreid> duaneb: in your table of builtins attach unique ids along with the haskell functions
14:43:18 <duaneb> I suppose....
14:43:24 <PeakerWork> duaneb: You're trying to map Scheme functions directly to Haskell functions, despite the semantics of them being very dissimilar
14:43:35 <gwern> duaneb: if you're stuck, iirc, there's a Scheme in 21 days or something you could crib from
14:43:37 <Twey> Haskell functions are pure.  Scheme functions are not.
14:43:39 <copumpkin> duaneb: as I said, you can do it if your input is enumerable and the output is an instance of Eq
14:43:53 <luqui> copumpkin, that is completely irrelevant to his problem :-)
14:44:07 * copumpkin puts his tail between his legs and runs away
14:44:11 <copumpkin> *stem
14:44:11 <Twey> Yeah, that's not nearly the answer in this case.
14:44:16 <Twey> Hehehe
14:44:20 <copumpkin> I haven't really followed context :P
14:44:22 <Twey> Copumpkins have legs?
14:44:26 <copumpkin> just keep hearing "OMG function equality"
14:44:27 <Twey> They really are different
14:44:44 <Phyx-> hmmm http://www.cafepress.com/doitmonad.7154442
14:44:49 <mmorrow> duaneb: imagine if someone implemented vmware in the game of life, ptr equality there would still be ptr equality, but not equality on the ptrs use to implement the life which implements vmware which implements hardware which provides the memory cells which programs running on the hosted os see as ptrs
14:45:12 <Phyx-> i wonder how many people would get that if i walk through an airport with it on
14:45:14 <luqui> Phyx-, :-)
14:45:28 * Twey laughs.
14:45:32 <Twey> Nice T-shirt, Phyx-
14:45:48 <duaneb> mmorrow: well, I understand the problem
14:45:54 <duaneb> I just don't understand why that's necessary
14:45:58 <gwern> Phyx-: they wouldn't have time to read it
14:46:08 <Phyx-> lol, i'm thinking of getting it
14:46:14 <Phyx-> or http://www.cafepress.com/classyhaskell.7154232
14:46:21 <luqui> duaneb, when you see f :: Int -> Int in haskell, you already know certain things about f
14:46:28 <mmorrow> duaneb: why what's necessary? (no comparison of the ptrs to haskell objects? (because of the gc))
14:46:36 <Phyx-> gwern: well, some are going to be in a 10hour flight with me :)
14:46:38 <luqui> for example, it will not do any IO, and if you call it twice with the same argument you'll get the same result.
14:46:46 <mmorrow> duaneb: you can use StableName though
14:46:48 <gwern> luqui: yeah. like, it could be bottom, it could be using unsafePerformIO, it could...
14:46:51 <luqui> if you could willy-nilly compare objects, then it might violate the latter constraint
14:46:58 <copumpkin> duaneb: can't you just use a wrapper type for your functions you want to expose in your lisp? data LispFunction = LispFunction String (LispType -> LispType) or something
14:47:02 <gwern> actually, we don't get a whole lot of guarantees in real haskell do we -_-
14:47:08 <luqui> gwern, I reject your unsafePerformIO and substitute my own
14:47:24 * gwern sees luqui and raises with an unsafeCoerce#
14:47:26 <hatds> lol
14:47:35 <duaneb> copumpkin: I have that
14:47:36 * copumpkin applies StrictAnal
14:47:38 <copumpkin> ah
14:47:39 <Twey> duaneb: Because what you're saying doesn't make sense in a pure language
14:47:49 <Twey> A function is a mapping from one set of values to another
14:47:53 <duaneb> data LispType = Lambda (LispType -> LispType)
14:47:58 * gwern invokes the function 'lub' on copumpkin's StrictAnal
14:48:03 <copumpkin> lol
14:48:05 <PeakerWork> gwern: if its using unsafePerformIO to break referential transparency, then its buggy -- it cannot under any circumstance do it behind a legitimate interface
14:48:13 * hatds looks at code using pointer equality.  Goes "well there's your problem".
14:48:19 <duaneb> Twey: well, it may not make sense, but it's also not prohibited by a pure language
14:48:21 * Phyx- voilates gwern referential transparency
14:48:23 <Twey> In mathematics, it would make sense to say that any functions that could provably yield the same results for all inputs are equal
14:48:34 * gwern is now impure! damn you Phyx- 
14:48:52 <Twey> In Haskell, though, that's not necessarily true, since we're running on real hardware and that means that there's computational complexity to consider
14:48:53 <copumpkin> we could get a referential transparency violation chain going in here
14:49:00 <luqui> Twey, (even unprovably, but that gets yucky)
14:49:03 <Phyx-> hahah
14:49:04 <Twey> Additionally, that can't be proven anyway
14:49:10 <Twey> (by a machine)
14:49:14 <mreh> Loading package unix-2.3.2.0 ... <command line>: can't load .so/.DLL for: rt (/usr/lib/librt.so: symbol __librt_multiple_threads, version GLIBC_PRIVATE not defined in file libc.so.6 with link time reference)
14:49:15 * Phyx- goes to bash.org
14:49:20 <kpreid> duaneb: yes it is prohibited. trying to define function identity gives you all sorts of interesting problems with preserving referential transparency, particularly because functions can close over values
14:49:21 <mreh> that's exciting
14:49:23 <hatds> yea, operational equality and denotational equality would both be somewhat functions to have... if only they weren't so hard to compute!
14:49:32 <hatds> *somewhat nice functions
14:49:33 <mmorrow> usually in math a function if a function by definition, a priori
14:49:39 <PeakerWork> duaneb: That LispType seems kind of useless
14:49:42 <mmorrow> because you said it's a function
14:49:43 <mreh> i've had so many errors trying to cabal install yi
14:49:43 <kpreid> duaneb: it might be possible to define "good enough equality" but it wouldn't be predictable over multiple compiles due to optimization
14:50:00 <PeakerWork> duaneb: how do you form an arg for the input of LispType?
14:50:26 <kpreid> I assume that was just an example of one of the constructors
14:50:58 <luqui> duaneb, anyway, probably looks like this:  data LispType = Lambda Unique (LispType -> LispMonad LispType)
14:51:11 <duaneb> PeakerWork: well, it's not the only constructor :P
14:51:26 <luqui> (LispMonad because lisp functions have more side-effects than just comparing for equality, and you need to get your uniques from somewhere)
14:51:59 <mmorrow> i think we're talking about two different things here... so ignoring referential transparency, purity, and letting "anything go", you still can't get Ord on the ptrs to haskell values (you can get Eq though) because of the GC
14:52:13 <luqui> PeakerWork, of course, newtype L = L (L -> L) is the scott domain.  hard to *do* anything with it :-)
14:52:23 <luqui> but it is the foundation of our entire language
14:53:12 <PeakerWork> duaneb: I think if you want mutations on values, you can't just attach an Id tag to values and copy the pair around.  You have to have some global   Map Id LispType
14:53:18 <hatds> mmorrow: wait, what?  wouldn't GC mess up Eq and Ord equally?
14:53:21 <PeakerWork> duaneb: Then you can place all the lisp values in there
14:53:45 <mmorrow> hatds: yeah, it destroys any chance for Ord, but you can haz Eq
14:53:47 <luqui> PeakerWork, and do manual GC (!)
14:53:50 <hackagebot> uuid 1.0.2
14:53:54 <luqui> PeakerWork, probably better to use STRefs
14:53:59 <hatds> mmorrow: Eq how?
14:54:05 <PeakerWork> luqui: can an STRef be compared for identity?
14:54:11 <luqui> PeakerWork, yep
14:54:13 <mmorrow> hatds: reallyUnsafePtrEquality#
14:54:17 <PeakerWork> luqui: how?
14:54:19 <hatds> mmorrow: oh
14:54:22 <luqui> @info STRef
14:54:23 <lambdabot> STRef
14:54:27 <luqui> thanks, lambdabot
14:54:31 <PeakerWork> STRef's have an Eq instance?
14:54:42 <mmorrow> hatds: which is dependent on what state of evaluation a value happens to be in..
14:54:57 <PeakerWork> oh cool
14:55:07 <mmorrow> hatds: (which is why the "unsafe", because it's not referentially transparent)
14:55:45 <luqui> duaneb, okay, so using STRef (or IORef if ST scared you) seems like a good bet?
14:56:15 <mmorrow> (and the "really" because you have to "really" figure out what's going on to be almost sure it's working like you want it to)
14:57:05 <PeakerWork> duaneb: You can have:  data LispType = LispValue (IORef Lisp)  ; data Lisp = BuiltinFunction (LispType -> LispType) | Atom String | List [LispType]
14:57:55 <luqui> PeakerWork, BuiltinFunction (LispType -> IO LispType)  ?
14:58:24 <dmwit> No, let all the built-in functions be pure! ;-)
14:58:30 <dmwit> ?instances-importing Data.STRef Eq
14:58:31 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, STRef s a, Sum a, [a]
14:58:40 <dmwit> luqui: There you go.
14:58:48 <dmwit> luqui: Also, for your future information:
14:58:49 <PeakerWork> equal compares identity or eq?
14:58:56 <PeakerWork> luqui: Yeah
14:58:58 <dmwit> ?info do { x <- foo; return (bar y) }
14:58:58 <lambdabot> foo >>= \ x -> return (bar y)
14:59:14 <luqui> info = undo?
14:59:23 * dmwit nods
14:59:26 <luqui> how... strange
14:59:32 <PeakerWork> I think its accidental
14:59:40 <copumpkin> the edit distance is short?
14:59:43 <dmwit> right
14:59:47 <dmwit> ?botsmuck
14:59:47 <lambdabot> :)
14:59:59 <luqui> oh lame
15:00:06 <copumpkin> ?batstack
15:00:06 <lambdabot> :)
15:00:10 <luqui> lol
15:00:14 <PeakerWork> which of eq/equal are equality and which are identity?
15:00:16 <PeakerWork> (in Scheme)
15:00:17 <PeakerWork> heh
15:00:22 * dmwit censors himself
15:00:41 <sjanssen> been such a long time since I've used Scheme
15:00:46 <sjanssen> I think eq is identity
15:01:16 <luqui> there are so many different kinds of equality.  *hugs haskell for clearing up the situation*
15:01:32 <augustss> equal is equality
15:01:44 <augustss> in scheme
15:02:02 <augustss> eq is identity, eqv is in between
15:02:08 <dmwit> Do any Haskell implementations use unsafe pointer equality as a fast-path for Eq instances?
15:02:19 <Phyx-> i tried F# last week... i couldn't make head or tails of it... I was trying to figure out how to make a function signature.. epic fail...
15:02:21 <augustss> dmwit: not that I know
15:02:32 <augustss> dmwit: it's tricky
15:02:35 <Trollinator> what is the $ operator for? after all, f $ x is the same as f `id` x
15:02:59 <dmwit> augustss: What, really?
15:03:35 <Chile`> Trollinator: just convenient syntax to avoid lots of nested parens
15:03:43 <luqui> Trollinator, um... i dunno, readability?
15:03:53 <dmwit> augustss: What if we restrict it to derived instances, where we know pointer equality will never steer us wrong?
15:04:31 <dmwit> Trollinator: ($) has lower precedence than `id`.
15:04:33 <Trollinator> right! i hear $ screaming "I'm the function application operator!"
15:04:42 <mreh> I've got a dependancy issue while installing yi, for a package that isn't listed on the hackage dependancy list
15:04:49 <luqui> infixr 0 `id`
15:04:52 <mreh> unix-2.3.2.0
15:05:13 <mreh> I can't work out which version yi needs, there's some kind of bug in the one I haver
15:05:15 <mreh> have*
15:10:16 <PeakerWork> luqui: hmm.. trying this approach to Lisp, but how can you create global IORefs for true/false without unsafePerformIO on a newIORef?  I guess the entire Lisp thing can be in a ReaderT of an environment with all the necessary builtins, but its not nice
15:11:05 <PeakerWork> luqui: (have to return Lisp's true/false inside functions like equal, but they are also inside IORefs. Maybe immutable stuff should have Ids and mutable stuff should be in IORefs
15:11:30 <luqui> PeakerWork, yeah i think so
15:11:40 <luqui> true/false aren't mutable so they shouldn't be in IORefs
15:11:49 <copumpkin> :o
15:11:56 <luqui> true := 42
15:12:13 <luqui> > let 1 = 2 in 2+2
15:12:15 <lambdabot>   4
15:14:17 <copumpkin> > let !1 = 2 in 2 + 2
15:14:18 <lambdabot>   * Exception: <interactive>:1:153-158: Non-exhaustive patterns in pattern bi...
15:14:25 <copumpkin> zomg what will I do
15:20:25 <telemachus> do I need to load a special library to have access to ord and chr?
15:20:43 <sjanssen> telemachus: import Data.Char
15:20:52 <telemachus> that would be it
15:20:53 <telemachus> sighs
15:20:56 <telemachus> thanks, sjanssen
15:21:23 <telemachus> the book I'm using neglected to mention that
15:21:46 <telemachus> (and most searches on Google for ord gave tons of hits for Ord)
15:22:32 <aavogt> @hoogle chr -- likely better than google for functions
15:22:32 <lambdabot> Parse error:
15:22:32 <lambdabot>   --count=20 "chr -- likely better than google for functions"
15:22:32 <lambdabot>                  ^
15:22:37 <aavogt> @hoogle chr
15:22:38 <lambdabot> Data.Char chr :: Int -> Char
15:22:38 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
15:22:38 <lambdabot> System.Posix.Internals c_s_ischr :: CMode -> CInt
15:23:47 <telemachus> hoogle bookmarked, thanks aavogt
15:24:18 <sjanssen> oh jeez, don't tell me we have a shell injection vulneratiblity here
15:24:36 <sjanssen> @hoogle chr" ; echo busted
15:24:37 <lambdabot> Parse error:
15:24:37 <lambdabot>   --count=20 "chr" ; echo busted"
15:24:37 <lambdabot>                 ^
15:25:20 <centrinia> @hoogle chr\" ; echo busted
15:25:21 <lambdabot> Parse error:
15:25:21 <lambdabot>   --count=20 "chr\" ; echo busted"
15:25:21 <lambdabot>                  ^
15:26:06 <sjanssen> nope, safe
15:26:09 <centrinia> @hoogle ; ls -l
15:26:10 <lambdabot> Parse error:
15:26:10 <lambdabot>   --count=20 "; ls -l"
15:26:10 <lambdabot>              ^
15:26:17 <sjanssen> the parse error comes from the Hoogle program
15:26:49 <sjanssen> we don't go via sh when calling hoogle
15:29:02 <Phyx-> @url hoogle
15:29:02 <lambdabot> http://haskell.org/hoogle
15:43:07 <aavogt> <ghc> My brain just exploded. I can't handle pattern bindings for existential or GADT data constructors. Instead, use a case-expression, or do-notation, to unpack the constructor.
15:54:02 <PeakerWork> Why does ghc need to preface that message with "My brain just exploded."? :P
15:54:10 <PeakerWork> its funny the first time, but then its annoying for the rest
15:54:48 <monochrom> It has a second purpose in addition to being funny.
15:54:49 <Phyx-> @src :P
15:54:50 <lambdabot> Source not found. Just try something else.
15:54:53 <Phyx-> @src (+)
15:54:54 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:55:06 <Phyx-> PeakerWork: why does @src try to be funny
15:55:20 <PeakerWork> @src is lambdabot, and the above is a ghc error
15:55:20 <lambdabot> Source not found. That's something I cannot allow to happen.
15:55:30 <monochrom> Let's say you're writing your program but you haven't implemented some planned feature yet, but you leave stub in your code for it. What do you write in the stub?
15:55:44 <centrinia> @src -- Please insult me gently with a chainsaw.
15:55:45 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
15:55:51 <aavogt> it is a trivial change to make my code comply with this arbitrary restriction
15:56:01 <monochrom> You probably write like f x = error "I haven't implemented f yet".
15:56:20 <Phyx-> PeakerWork: well, i appreciate ghc's attempt at humor though :)
15:56:35 <monochrom> So they write "My brain has exploded". It means something is not implemented yet.
15:57:11 <centrinia> @let f x = error "I haven't implemented f yet"
15:57:12 <lambdabot>  Defined.
15:57:15 <centrinia> @src f
15:57:16 <lambdabot> Source not found. Just try something else.
15:57:24 <centrinia> @src L.f
15:57:25 <lambdabot> Source not found. Take a stress pill and think things over.
15:57:35 <centrinia> That doesn't make sense.
15:57:40 <monochrom> src is a static database, and very incomplete.
15:57:52 <aavogt> @src src
15:57:52 <lambdabot> Source not found.
15:58:06 <monochrom> Let's just say what src knows is pretty much hardcoded.
15:58:39 <monochrom> It's also somewhat out of touch with reality, too.
15:58:45 <centrinia> How do we make the @src database dynamic?
15:58:51 <wpearson> @src reality
15:58:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:59:04 <centrinia> @src clue
15:59:05 <lambdabot> Source not found.
15:59:06 <monochrom> @src length
15:59:07 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
15:59:17 <monochrom> @src foldl
15:59:18 <lambdabot> foldl f z []     = z
15:59:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:59:22 <aavogt> @src lambdabot
15:59:22 <lambdabot> Source not found. The more you drive -- the dumber you get.
15:59:23 <centrinia> @src (>>=)
15:59:24 <lambdabot> Source not found. Where did you learn to type?
15:59:32 <centrinia> @src sqrt
15:59:33 <lambdabot> Source not found. :(
15:59:40 <monochrom> For example foldl. It is not what GHC uses.
15:59:56 <centrinia> At least @src should have the entire Prelude. :(
16:00:18 <monochrom> Did you know that "sqrt" and ">>=" are typeclass methods?
16:00:30 <centrinia> Oh.
16:00:39 <centrinia> @src sqrt :: Double -> Double
16:00:40 <lambdabot> Source not found. Sorry.
16:00:45 <monochrom> Did you know that therefore asking for the source code of "sqrt" is ambiguous? Like which instance would you really want?
16:00:46 <dmwit> ?src Double sqrt
16:00:47 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:00:51 <dmwit> ?src [] (>>=)
16:00:52 <lambdabot> xs >>= f     = concatMap f xs
16:00:58 <centrinia> Ah.
16:01:13 <centrinia> ?src IO (>>=)
16:01:14 <lambdabot> m >>= k     = bindIO m k
16:01:20 <dmwit> sqrt = sqrtDouble# ;-)
16:01:20 <centrinia> ?src bindIO
16:01:21 <lambdabot> bindIO (IO m) k = IO ( \ s ->
16:01:21 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
16:01:36 <centrinia> ?src unIO
16:01:36 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:01:53 <aavogt> @quote not funny
16:01:53 <lambdabot> No quotes for this person. Sorry.
16:02:05 <aavogt> @quote exploded
16:02:05 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
16:02:23 <monochrom> unIO is the inverse of IO. By IO I mean the data constructor you just saw in "bindIO (IO m) k".
16:03:00 <monochrom> The source code probably had "data IO a = IO { unIO :: ... }". And of course src would not know that one.
16:03:22 <mauke> @src IO
16:03:22 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:03:35 <monochrom> Yeah I mean newtype. :)
16:04:24 <monochrom> You are better off finding GHC library source code elsewhere than asking src. It knows nothing.
16:09:01 <Botje> it's from barcelona!
16:09:26 <dmwit> oh no!
16:26:34 <frogman> Is there a way to test the type of something within a function--like if a function has a return type of either, can I see if the output of another function on the input is one type or another?
16:27:00 <mauke> what
16:27:04 <mauke> 'either' is not a type
16:27:13 <frogman> Either Int String
16:27:26 <mauke> case x of Left i -> ...; Right s -> ...
16:27:41 <frogman> ok thanks!
16:28:34 <kpreid> frogman: those are not different types, they're different values (constructors, you could say)
16:32:53 <christastrophe> good evening everyone
16:33:38 <christastrophe> i'm having some confusion with a little code snippet
16:34:11 <christastrophe> this seems to cause an overflow: foldl' (\(l,s) v -> (l+1,s+v) (0,0) [1..1000000]
16:34:29 <christastrophe> but computing each of the sub parts works just fine
16:34:51 <mauke> makes sense
16:34:59 <christastrophe> what could cause the overflow in the combined version?
16:35:08 <mauke> the usual laziness
16:35:08 <Botje> christastrophe: foldl' only forces the outer constructor
16:35:14 <mauke> forcing a pair doesn't force its contents
16:35:14 <Botje> which is (,)
16:35:48 <christastrophe> ah I see, so I'm still building up a chain of thunks here
16:35:49 <Botje> either use a strict pair or call seq yourself
16:36:00 <mauke> (,) $! l+1 $! s+v
16:36:38 <christastrophe> ok let me give that a try...
16:40:20 <christastrophe> ha. that did work. seems I am not yet 'evaluating' haskell properly in my head
16:54:20 <hatds> lazy pairs of numeric types always messed with my head :)
16:55:47 <christastrophe> I was reading foldl simmilar to SmallTalks inject, but forgetting the laziness of Haskell
17:18:01 <Peaker> maybe foldl' could use rnf?
17:20:21 <christastrophe> Peaker: what does 'rnf' mean in this context?
17:20:38 <coscrotum> Reduced Normal Form?
17:21:09 <Peaker> I like to see it as "deep forcing" (but I may be misunderstanding)
17:21:31 <byorgey> yes, reduced normal form.  'rnf' is for fully evaluating things.
17:21:44 <byorgey> I think 'deep forcing' is the right intuition.
17:22:03 <ik> hot.
17:22:49 <christastrophe> basically meaning that the function argument to foldl' would require its arguments be evaluated eagerly?
17:23:37 <byorgey> right.  foldl' is already "strict"---but in fact that means its arguments are evaluated eagerly with 'seq', which only reduces things to weak head normal form.
17:23:57 <byorgey> for things like Int (say), weak head normal form is the same as reduced normal form.
17:24:06 <byorgey> but for other things (like lists) they are very different.
17:24:32 <christastrophe> is that something that can currently be expressed in the Haskell type system?
17:24:36 <byorgey> weak head normal form for a list means it is only evaluated far enough to tell whether it is empty, or a cons.
17:24:47 <byorgey> christastrophe: no
17:24:58 <byorgey> there's nothing in the type system that can express strictness properties.
17:25:06 <byorgey> which is too bad.
17:25:46 <byorgey> not that I really know what would be involved in a type system that *could* express strictness properties.  but it sounds neat.
17:26:45 <christastrophe> yeah that is still above my paygrade too .. but it seems that since you can define a functions arguments to be strictly evaluated, it would be possible to define a functions type in a simmilar manner ...
17:28:53 <uzytkownik> Are Char always 4-byte or is is implementation-dependent? If always is the encoding UTF32 or something else?
17:29:04 <byorgey> not really.  Haskell-the-language is actually pretty agnostic about operational issues such as strictness.
17:29:12 <byorgey> er, that was to christastrophe
17:29:18 <Zao> uzytkownik: It's large enough to represent all unicode codepoints, I believe.
17:29:46 <Peaker> if whnf was called flat forcing, and rnf was called deep forcing, wouldn't it be nicer?
17:30:09 <Zao> uzytkownik: http://www.haskell.org/onlinereport/basic.html
17:30:20 <Zao> uzytkownik: The report doesn't seem to say much about sizes, as it's rather irrelevant.
17:30:25 <byorgey> Peaker: those are good terms to start using as synonyms.
17:30:26 <Zao> It's at least 21 bits.
17:30:33 <christastrophe> byorgey: oh sure. but if I can say foo = \!x -> ..., why not say foo :: !Int -> ...?
17:30:55 <byorgey> Peaker: but I don't see the wisdom in abandoning accepted terminology that's used in lots of related research.
17:31:01 <Zao> There may be a relation to the size of Int, as it mentions toEnum/fromEnum.
17:31:05 <Peaker> byorgey: backwards compatibility :(
17:31:23 <christastrophe> but I digress since my understanding here is quite shallow
17:31:28 <byorgey> Peaker: well, I see your point.
17:32:05 <byorgey> christastrophe: oh, I see, actually, you can indeed do that
17:32:27 <byorgey> christastrophe: but it doesn't give you a whole lot of control.
17:32:41 <byorgey> christastrophe: and I'm not sure whether it's anything more than a recommendation to the compiler
17:33:07 <christastrophe> byorgey: I imagine this is a very GHC specific feature too
17:33:16 <byorgey> yeah, probably.
17:33:38 <uzytkownik> Zao: Unless someone tries to find out a way of CString UTF8 -> Haskell String. I can have it converted to UTF16 or UTF32. But CWString is not suitable as it is implementation-dependent so I don't know if it is UCS2 (UTF16?) or UTF32.
17:35:10 <Zao> uzytkownik: What are you trying to do? If you're just trying to convert UTF-8 to String, you can just use the utf8-string package or the Data.Text module.
17:38:53 <uzytkownik> Zao: OK. Thanks (BTW. I don't have Data.Text module in ghc 6.10.1)
17:42:18 <Zao> uzytkownik: Yeah, it's third party one. You can find it on Hackage.
17:42:21 <byorgey> uzytkownik: Data.Text is from the 'text' package available on Hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/text
17:42:21 <Zao> It's nice though.
17:44:37 <mmorrow> > rnf
17:44:38 <lambdabot>   Overlapping instances for GHC.Show.Show
17:44:38 <lambdabot>                              (a -> ...
17:45:23 <mmorrow> @let foldl'' _ z [] = z; foldl'' f z (x:xs) = let a = f z x in a `rnf` foldl'' f a xs
17:45:25 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Done'
17:45:50 <mmorrow> @let foldl'' _ z [] = z; foldl'' f z (x:xs) = let a = f z x in rnf a `seq` foldl'' f a xs
17:45:51 <lambdabot>  Defined.
17:46:10 <mmorrow> (probably a loss?)
17:48:42 <mmorrow> > foldl'' M.union mempty (fmap (\(m,n) -> M.fromList (zip [m..n] [0..])) (take 20 $ fmap (\x -> (x,x+100)) [0,101..]))
17:48:43 <lambdabot>   fromList [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,1...
17:48:53 <mmorrow> > foldl'' M.union mempty (fmap (\(m,n) -> M.fromList (zip [m..n] [0..])) (take 1000 $ fmap (\x -> (x,x+100)) [0,101..]))
17:48:58 <lambdabot>   mueval-core: Prelude.read: no parse
17:48:58 <lambdabot>  mueval: ExitFailure 1
17:49:06 <mmorrow> > foldl'' M.union mempty (fmap (\(m,n) -> M.fromList (zip [m..n] [0..])) (take 200 $ fmap (\x -> (x,x+100)) [0,101..]))
17:49:07 <lambdabot>   fromList [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,1...
17:49:12 <mmorrow> > foldl'' M.union mempty (fmap (\(m,n) -> M.fromList (zip [m..n] [0..])) (take 500 $ fmap (\x -> (x,x+100)) [0,101..]))
17:49:17 <lambdabot>   fromList [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,1...
17:49:20 <mmorrow> > foldl' M.union mempty (fmap (\(m,n) -> M.fromList (zip [m..n] [0..])) (take 500 $ fmap (\x -> (x,x+100)) [0,101..]))
17:49:21 <lambdabot>   fromList [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,1...
17:49:33 <mmorrow> hmm, worth benchmarking maybe
17:49:39 <dmwit> Maps are pretty strict already.
17:49:45 <mmorrow> hmm, true
17:50:32 <mmorrow> can you think of any structure/type where foldl' and foldl'' would be noticeably different?
17:51:06 <mmorrow> nothing's coming to mind
17:52:04 <dmwit> How about constructing a list where the elements are deeper and deeper thunks of compositions of (+1) or something?
17:52:12 <dmwit> Not sure how to be precise about what I mean...
17:52:38 <mmorrow> but would you use foldl' for that in the first place?
17:53:42 <mmorrow> but yeah i see what you're going for
17:53:53 <dmwit> Yeah, I don't know.
17:53:56 <dmwit> dunno dunno
17:54:23 <mmorrow> @pl \dunno -> dunno dunno
17:54:24 <lambdabot> join id
17:54:33 <dmwit> I guess it can't be deeply nested thunks at a function type.
17:54:38 <dmwit> As you say, it has to be a structure.
17:54:41 <skorpan> what the hell
17:55:47 <mmorrow> yeah, it'd have to be some structure where the recursive part is more than one-level deep, and isn't strict (in that going to whnf doesn't force the recursive part(s) to whnf)
17:56:20 <mmorrow> data Foo = Foo ... (Blah ... Foo ..)..
17:56:27 <mmorrow> unionFoo
17:57:17 <mmorrow> data Foo = Foo ... !(Blah ... !Foo ..)..  -- would make rnf (wrt Foo) == whnf
17:57:19 <mmorrow> (i think)
17:57:39 <mmorrow> err, that should be
17:57:46 <mmorrow> data Blah = Blah ... !Foo ...
17:57:58 <mmorrow> data Foo = Foo ... !Blah
17:58:30 <mmorrow> which i can't even begin to think of an example of
17:59:45 <mmorrow> ooh, a simple case would be with nested tuples, where you'd have to manually bang them in foldl'
18:00:14 <mmorrow> > foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..10000000]
18:00:24 <lambdabot>   mueval-core: Prelude.read: no parse
18:00:24 <lambdabot>  mueval: ExitFailure 1
18:00:28 <mmorrow> > foldl'' (\(a,b) c -> (a+c,b+c)) (0,0) [0..10000000]
18:00:33 <lambdabot>   mueval-core: Prelude.read: no parse
18:00:33 <lambdabot>  mueval: ExitFailure 1
18:01:21 <mmorrow> > foldl' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:01:24 <lambdabot>   (* Exception: stack overflow
18:01:25 <mmorrow> > foldl'' (\(a,b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:01:29 <lambdabot>   (500000500000,500000500000)
18:01:31 <mmorrow> > foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:01:33 <lambdabot>   <no location info>: Illegal bang-pattern (use -XBangPatterns)
18:01:35 <mmorrow> , foldl' (\(!a,!b) c -> (a+c,b+c)) (0,0) [0..1000000]
18:01:38 <lunabot>  (500000500000,500000500000)
18:02:06 <mmorrow> (but you can always just bang the tuples and avoid the annoying NFData constraint)
18:03:40 <mmorrow> , foldl' (\(!a,((!b,!c),!d)) e -> (a+e,((b+e,c+e),d+e))) (0,((0,0),0)) [0..1000000]
18:03:44 <lunabot>  (500000500000,((500000500000,500000500000),500000500000))
18:04:17 * mmorrow thinks the moral is that bang patterns r00l
18:04:39 <augustss> when you want strictness
18:04:45 <mmorrow> yes
18:06:10 <mmorrow> , foldr (\x !xs -> x : xs) [] [0..]
18:06:12 <lunabot>  Stack space overflow: current size 8388608 bytes.
18:06:12 <lunabot>  Use `+RTS -Ksize' to increase it.
18:09:02 <gwern> well, I'll be. conal has a beard
18:09:07 <ExamTommorowHELP> hiya
18:09:12 <gwern> somehow my mental image of him was much like SPJ
18:09:36 <gwern> except with more steel-rimmed glasses
18:09:39 <ExamTommorowHELP> Im in need of some programming help, could anyone offer me a hand?
18:10:08 <gwern> ExamTommorowHELP: well, your nick doesn't inspire much empathy y'know
18:10:22 <ExamTommorowHELP> : (
18:10:23 <gwern> ExamTommorowHELP: but you might as well spit out your questions & see what happens
18:10:35 <ExamTommorowHELP> well I need to write an ask method in Java 5
18:10:45 <ExamTommorowHELP> like with the buffered stream reader in stuff
18:10:49 <inimino> somehow I was expecting Java questions
18:10:50 <ExamTommorowHELP> I forgot how to do it
18:10:53 <gwern> java.
18:11:00 <inimino> why don't you try the channel devoted to that language
18:11:02 <mauke> how is that a Haskell question?
18:11:03 <inimino> just a thought...
18:11:07 <inimino> #java
18:11:07 <ExamTommorowHELP> oops..
18:11:08 <gwern> ExamTommorowHELP: you're in the wrong place..
18:11:12 <ExamTommorowHELP> ok thanks
18:11:15 <ExamTommorowHELP> sorry about that
18:11:22 * gwern knows how to do that, but refuses on principle to help
18:14:08 <xian> I'm not sure, but somehow it occurs to me that ExamTommorowHELP might not have been entirely serious.
18:14:23 <ExamTommorowHELP> yeah I was
18:14:36 <ExamTommorowHELP> I cant find a #java room
18:14:42 <ExamTommorowHELP> do you know where one is
18:14:56 <gwern> there is no #java or ##java?
18:14:56 <xian> It's ##java on this network.
18:14:57 <Zao> Consult your course literature?
18:15:07 <ExamTommorowHELP> I have no course literature Zao
18:15:08 <gwern> Zao: that'd be too hard!
18:15:11 <ExamTommorowHELP> just a computer
18:15:16 <ExamTommorowHELP> thats it
18:15:19 <mauke> #java redirects to ##java
18:15:20 <ExamTommorowHELP> my teacher sucks
18:15:24 <mauke> in summary, you fail
18:15:41 <Zao> A bad craftsman blames his tools.
18:15:42 <ExamTommorowHELP> how do I fail he never gave out books
18:15:46 <gwern> mauke: ah, so it does
18:15:52 <ExamTommorowHELP> All I have is my memory
18:15:57 <Zao> Doesn't one usually purchase books?
18:15:59 <luqui> wow, don't be nice or anything
18:15:59 <Zao> Or take notes?
18:16:04 <mauke> ExamTommorowHELP: you're asking in #haskell. and you can't find #java when you're pointed at it.
18:16:12 <gwern> ExamTommorowHELP: you know, there are dozens of great java textbooks online
18:16:16 <ExamTommorowHELP> Not when im in High School
18:16:35 <gwern> I liked thinking in java, personally
18:16:39 <ExamTommorowHELP> I dont know where to look
18:17:05 <luqui> the great Google is your friend
18:17:08 <Zao> I should probably not say anything, I'm stuck in procrastination aftermath myself.
18:17:10 <Gracenotes> gwern: definitely. The Java design decisions might be somewhat arbitrary, but they are a fun labrynth to navigate
18:17:12 <ExamTommorowHELP> I tried nothing came up
18:17:24 <luqui> what did you search for?
18:17:30 <ExamTommorowHELP> java5 ask method
18:17:34 <Gracenotes> *eek, labyrinth
18:17:45 <xian> ExamTommorowHELP: How did you manage to end up here?
18:17:56 <ExamTommorowHELP> I typed in programming chat
18:17:59 <luqui> or better yet... why don't you go to #java and ask for help?
18:18:01 <duaneb> @src ($)
18:18:01 <lambdabot> f $ x = f x
18:18:04 <ExamTommorowHELP> this came up like #1
18:18:10 <ExamTommorowHELP> I cant find #java
18:18:10 <luqui> ExamTommorowHELP, just type "/join #java"
18:18:10 <Zao> ExamTommorowHELP: "make a ask method" isn't really understandable either.
18:18:16 <luqui> without the quotes
18:18:19 <ExamTommorowHELP> oh ok
18:18:22 <duaneb> @src (.)
18:18:22 <lambdabot> (f . g) x = f (g x)
18:18:26 <Zao> @type interact
18:18:26 <ExamTommorowHELP> sorry Ive never used irc before thanks
18:18:29 <lambdabot> (String -> String) -> IO ()
18:18:35 <luqui> ExamTommorowHELP, yes it's a bit daunting
18:18:41 <Gracenotes> the issue is that you need to register before joining ##java
18:18:46 <luqui> ohhh
18:18:48 <Gracenotes> it's a +r channel
18:18:53 <Zao> Competence filter, in other words.
18:18:55 <Gracenotes> /msg nickserv register password email
18:18:58 <ExamTommorowHELP> yeah I typed it in nothing happened
18:18:59 <ik> still trying to figure out how he joined #haskell
18:19:03 <troutwine> Silly question: How do I escape a double quote in a string literal when using parsec? "[Event \"?\"]" includes the '\' character.
18:19:05 <Gracenotes> ..yeah
18:19:12 <ExamTommorowHELP> @ik it just popped up on google
18:19:12 <lambdabot>  it just popped up on google
18:19:16 <mauke> troutwine: no, it doesn't
18:19:18 <ik> ExamTommorowHELP: haha what
18:19:27 <Gracenotes> @help ik
18:19:27 <ik> ExamTommorowHELP: what on earth did you search for?
18:19:27 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:19:31 <ExamTommorowHELP> programming chat
18:19:35 <ik> -_-
18:19:41 <ik> Ok- be more specific in the future
18:19:44 <Gracenotes> :)
18:19:49 <xian> He's right. Just search for "Programming Chat" on google and the first result is a link to a browser client directing you here.
18:19:53 <Gracenotes> /msg nickserv help register
18:19:58 <ik> xian: oh, brilliant
18:20:04 <ExamTommorowHELP> I was in a programming chatroom for java but no one would help : (
18:20:16 <luqui> yeah those guys are jerks.   (j/k)
18:20:35 <Gracenotes> IRC channels don't necessarily take kindly to people wanting others to do their homework or cramming for exams
18:20:36 <ExamTommorowHELP> I tried that /msg nickserv but it said insufficent parameters
18:20:41 <Zao> Heh, the "expert mode" requires mirc :)
18:20:54 <ExamTommorowHELP> I know, but all I need is one lousy method
18:21:03 <Gracenotes> ExamTommorowHELP: ugh. what is it >:]
18:21:04 <mauke> congratulations on misspelling "tomorrow"
18:21:09 <Gracenotes> did I mention that I mean >:[
18:21:30 <luqui> ExamTommorowHELP, oh, one method on one class?  which class?
18:21:31 <Zao> Gracenotes: Interpreting earlier text, asking the user something and reading the response.
18:21:34 <ExamTommorowHELP> I need to ask the user a question
18:21:42 <ExamTommorowHELP> like what is your name
18:21:53 <ExamTommorowHELP> just need to know the buffered stream reader part
18:21:53 <Zao> So you need to find out how to print something to the console and how to read something from the console.
18:22:00 <Gracenotes> java.util.Scanner. google it.
18:22:05 <Peaker> Gracenotes: what's interesting about "navigating Java's design choices"?
18:22:14 <Peaker> Gracenotes: Java seems to be all about mediocrity/boredom...
18:22:28 <Zao> Peaker: Guess what language I currently have to code in? :)
18:22:30 <troutwine> mauke: http://pastebin.com/m62d6ac67
18:22:44 <Peaker> Zao: Boredom extreme
18:22:44 <Gracenotes> Peaker: but suppose you're not a mediocre programmer. It at least is interesting.
18:23:01 <ExamTommorowHELP> @ zao I ask the user to input their name then be able to bring it out later
18:23:10 <Zao> Haskell has damaged my ability to code in more verbose languages.
18:23:18 <Zao> I keep trying to generalize and write elegant code.
18:23:24 <dibblego> Zao, you might try http://functionaljava.org/
18:23:26 <mauke> troutwine: what
18:23:27 <Peaker> Gracenotes: I don't know, having known C++, Java seemed to be C++ without templates, and with GC/refs instead of manual/pointers
18:23:29 <Zao> While in Java you're supposed to be horribly verbose and spammy.
18:23:30 <Gracenotes> dibblego: nooo
18:23:45 <Gracenotes> ExamTommorowHELP: google "java.util.scanner". Oh god what a troll
18:23:45 <dibblego> Gracenotes, better than Java without it at least
18:23:57 <ExamTommorowHELP> im not a troll I dont want to be in here lol
18:24:09 <ExamTommorowHELP> I would be playing UT3 right now if I could
18:24:19 <Peaker> Zao: I work with Python/C at work.  C is supposed to suck, but Python I find myself thinking "This whole thing would be a simple liftA2 ..." and stuff :)
18:24:22 <Gracenotes> okay, sorry then. But the class should be all you need. If you can't get much from the documentation, then you might have more serious troubles
18:24:22 <Zao> dibblego: I'd say that my cow-orkers would disagree with me about using that :)
18:24:37 <dibblego> Zao, tell them to harden the fuck up
18:24:39 <Gracenotes> here's a link, even: http://java.sun.com/j2se/1.5.0/docs/api/java/util/Scanner.html
18:25:25 <xian> ExamTommorowHELP: Check out: http://academic2.strose.edu/math_and_science/goldschd/spring2007-java-week01-ex.html
18:25:34 <dmwit> Isn't there a ##java?
18:25:40 <Zao> private void rethrow(Throwable throwable) throws Throwable { throw throwable; }
18:25:42 <Gracenotes> many people have been in your shoes before, myself included. don't underestimate googling... or taking notes? :
18:25:50 <dmwit> Yes, there is.
18:25:56 <ik> dmwit: yes, but it is +r and (apparently) registration is difficult for this one
18:25:58 <Gracenotes> dmwit: requires registration.
18:26:01 <xian> dmwit: There is, but he can't join, because he's not identified.
18:26:01 <troutwine> mauke: Unless I'm mistaken, parsec is barfing on the escaped double quote.
18:26:08 <troutwine> mauke: Better paste here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5458#a5458
18:26:16 <dmwit> ik, Gracenotes, xian: Tough.
18:26:27 <Gracenotes> okay, I'm going to watch TV now. adieu
18:26:30 <ik> dmwit: oi, don't blame me
18:26:45 <ik> dmwit: just summing up the last few for ya.
18:26:49 <Zao> Had this been ##C, he'd been banned within three lines.
18:26:49 <mauke> troutwine: it's barfing on the quote because " is not a letter
18:26:54 <mauke> troutwine: as far as I can tell
18:26:54 <Zao> Thankfully this isn't C.
18:27:18 <troutwine> mauke: Oh, damnit. Thanks.
18:27:32 <xian> Zao: The friendliness of the Haskell community is remarkable.
18:27:43 * dmwit feels grumpy, not friendly
18:27:53 <ExamTommorowHELP> hey xian thanks so much that link was great! found just what I needed
18:28:13 <dmwit> I must be getting old. =/
18:28:20 <ExamTommorowHELP> you guys have been a great help better than the ppl in the java room lol
18:28:25 * Zao hands dmwit a lambda-shaped cane.
18:28:31 <Gracenotes> ExamTommorowHELP: next time don't cram
18:28:56 <Gracenotes> again look into java.util.Scanner; some courses prefer that approach to the one xian linked. Just saying.
18:29:10 <ExamTommorowHELP> no Gracenotes its not that
18:29:18 <ExamTommorowHELP> Ive used the one xian sent me
18:29:22 <dmwit> My band teacher used to have a sign on his door that said, "Poor planning on your part does not constitute an emergency on my part."
18:29:55 <ExamTommorowHELP> what the hell is a haskell anyway?
18:30:00 <ExamTommorowHELP> jk lol
18:30:16 <mauke> a dog
18:30:18 <Gracenotes> ExamTommorowHELP: hm... perhaps you should learn yourself one.
18:30:25 <Gracenotes> @where lyah
18:30:25 <lambdabot> www.learnyouahaskell.com
18:30:26 <roconnor> @where lyah
18:30:27 <lambdabot> www.learnyouahaskell.com
18:30:29 <Gracenotes> lol
18:30:36 <MyCatVerbs> dmwit: your *band* teacher? Now I hear that a lot from sysadmins and tech support personell, but what does it have to do with music?
18:30:57 <Gracenotes> ExamTommorowHELP: okay then. mystery solved. You do know of a search engine called Google though, right?
18:30:58 <MyCatVerbs> Great minds think alike! That doesn't explain you two, though. ;)
18:31:02 <dmwit> You'd be surprised how many opportunities he found to point at it and stare at you disapprovingly.
18:31:24 <ExamTommorowHELP> yeah it didnt work though
18:31:33 <MyCatVerbs> dmwit: I am surprised, indeed. Would you care to elaborate, perhaps with an example? ^_^
18:31:34 <dmwit> Google... didn't work.
18:31:39 <ExamTommorowHELP> nope
18:31:49 <ExamTommorowHELP> type in java 5 ask method nothing comes up
18:31:56 <ExamTommorowHELP> nothing useful atleast
18:32:15 <mauke> why would I type that in?
18:32:29 <dmwit> MyCatVerbs: hum; can't find the hat for the uniform and the bus is leaving; can't find the music and the all-state competition is tomorrow; didn't practice for the lesson this week and so can't play the assigned piece; etc.
18:32:30 <mauke> how about "free java book"?
18:33:13 <ExamTommorowHELP> I wasnt looking for a free java book
18:33:26 <ExamTommorowHELP> just 2 lines of code
18:33:37 <MyCatVerbs> dmwit: I see! Yes, those would seem to constitute emergencies on the parts of the victims.
18:33:39 <mauke> insert appropriate yoda quote here
18:33:54 <MyCatVerbs> ExamTommorowHELP: what in the blazes is an "ask method", please?
18:33:57 <dmwit> ExamTommorowHELP: If what you tried didn't work, perhaps you should graciously accept the advice of the people here.
18:34:06 <Zao> MyCatVerbs: s/ask/interact/
18:34:10 <ExamTommorowHELP> I did they zao helped alot
18:34:35 <MyCatVerbs> Zao: ?
18:34:43 <ExamTommorowHELP> mycatverbs an ask method is this   InputStreamReader isr = new InputStreamReader(System.in);
18:35:50 <inimino> we're calling those whats now?
18:36:22 <hatds> what's a good symbol to use for xor?
18:36:26 <hatds> or symbols
18:36:37 <dmwit>  /=
18:36:41 <mauke> xor
18:36:44 <dmwit> > True /= False
18:36:45 <lambdabot>   True
18:36:46 <MyCatVerbs> hatds: Data.Bits just uses xor.
18:36:59 <mauke> (Data.Bits should have used .^.)
18:37:08 <harlekin> âŠ•
18:37:40 <MyCatVerbs> harlekin: I'll go for that when I get a keyboard that has a key for it. ;P
18:37:48 <hatds> hmm I kinda like ^ (or variations thereof)
18:38:09 <Twey> mauke: It looks too phallic
18:38:09 <MyCatVerbs> (Or, more to the point, when I get around to adding a lot of extra compose key sequences to my machine's config.)
18:38:12 <mmorrow> mauke: .>>. and .<<. too
18:38:32 <mauke> Twey: but .|. is obviously fine, amirite
18:38:34 <mmorrow> Twey: what about
18:38:36 <mmorrow> yeah
18:38:39 <Twey> Haha, touchÃ©
18:41:56 <Twey> > foldl (,) [1..5]
18:41:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = (a, b)
18:42:10 <Twey> Those infinite type errors always catch me out
18:42:47 <aavogt> > (,,,,,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10 11 12 13
18:42:48 <lambdabot>   Overlapping instances for GHC.Show.Show
18:42:49 <lambdabot>                              (n -> ...
18:43:28 <aavogt> > (,,,) 1 2 3 4
18:43:29 <lambdabot>   (1,2,3,4)
18:43:33 <mauke> preflex: calc ++++++++++++ 1 2 3 4 5 6 7 8 9 10 11 12 13
18:43:33 <preflex>  91
18:43:56 <Twey> A prefix calculator?  But why?
18:44:00 <Twey> Postfix is the natural order.
18:44:10 <mauke> preflex: calc 1 2 3 4 5 6 7 8 9 10 11 12 13 ++++++++++++
18:44:10 <preflex>  91
18:44:15 <Twey> \o/
18:44:27 <Twey> preflex: calc + 1 2 3 +
18:44:27 <preflex>  6
18:44:31 <Twey> preflex: calc - 1 2 3 -
18:44:32 <preflex>  -4
18:44:42 <idnar> Twey: pah, "natural"
18:44:50 <aavogt> preflex: + 1 2 3 + 4 5 +
18:45:04 <Twey> idnar: It is!
18:45:17 <Twey> It annoys me when I have to use infix notation in maths, now.
18:45:19 <mmorrow> preflex: zenc (,,,,,,,,,,,,,)
18:45:19 <preflex>  ZLz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUz2cUZR
18:45:22 <MyCatVerbs> What the HELL fixity does preflex use? oO
18:45:35 <Twey> MyCatVerbs: It's OMNIFIX
18:45:37 <mauke> MyCatVerbs: AWESOME
18:45:45 <Gracenotes> YOU'RE SERIOUS??1!?!?
18:46:00 <mmorrow> infixAWESOME + 11 -- ?
18:46:14 <Gracenotes> really though, wtf
18:46:15 <Twey> Hahahaha
18:46:23 <dmwit> MyCatVerbs: I think it maybe uses separate number and operator stacks.
18:46:25 <mauke> preflex: calc (+ 1 2) * (6 3 -)
18:46:26 <preflex>  9
18:46:32 <Gracenotes> the plus at the beginning
18:46:33 <Twey> aavogt: You missed the â€˜calcâ€™ keyword.
18:46:47 <Gracenotes> is that mixing prefix and postfix? .. and infix? .... oooohh.
18:46:50 <Twey> preflex: calc + 1 2 3 + 4 5 +
18:46:50 <preflex>  Too many operands
18:46:56 <Twey> Hoo.
18:46:59 <Twey> preflex: calc + 1 2 3 + 4 5 6 +
18:46:59 <preflex>  Too many operands
18:47:13 <Twey> Oh, operands.  Duh.
18:47:14 <MyCatVerbs> preflex: calc + 1 2 3 -
18:47:14 <preflex>  0
18:47:14 <Twey> preflex: calc + 1 2 + 4 5 +
18:47:15 <preflex>  12
18:47:22 <Twey> preflex: calc - 1 2 - 4 5 -
18:47:23 <preflex>  -10
18:47:28 <MyCatVerbs> preflex: calc + 1 2 - 3
18:47:28 <preflex>  0
18:47:32 <mauke> best parsing algorithm ever.
18:47:35 <Gracenotes> preflex: calc 1 + 2 + 3 + 4 + 5
18:47:36 <MyCatVerbs> preflex: calc + - 1 2 3
18:47:36 <preflex>  15
18:47:36 <preflex>  0
18:47:37 <Twey> I'm having some trouble figuring out the order of operations there.
18:47:54 <dmwit> Twey: 1 - 2 - 4 - 5
18:47:56 <dmwit> = -10
18:48:06 <Twey> Yeah
18:48:06 <sohum> preflex: - 3 + 1 2
18:48:09 <Twey> I guess
18:48:12 <mauke> preflex: calc +) 1 2 * 6 3 ((-
18:48:12 <preflex>  9
18:48:21 <dmwit> gah
18:48:22 <Twey> Hm... so basically on reading an operator...
18:48:22 <Gracenotes> but but... mommy... ;_;
18:48:29 <sohum> that's ... off
18:48:30 <Twey> If it has enough operands on the stack, it performs it
18:48:43 <Gracenotes> well. is it context-free?
18:48:45 <Twey> Otherwise, it reads more operands until it has enough
18:48:56 <Gracenotes> if it uses two stacks, I'm guessing no
18:49:02 <dmwit> Twey: I still think it's simpler to think of it as two separate stacks.
18:49:05 <sohum> preflex: 3 1 2 + -
18:49:17 <dmwit> sohum: needs moar calc
18:49:22 <Twey> dmwit: I don't think so
18:49:22 <dmwit> preflex: calc 3 1 2 + -
18:49:22 <preflex>  2
18:49:27 <sohum> ah, right
18:49:30 <sohum> thankee
18:49:32 <Gracenotes> so if it has a plus, it waits for two numbers. if it has two numbers, it waits for an operator
18:49:37 <Twey> preflex: calc + 1 2 3 + 4 5 +
18:49:38 <preflex>  Too many operands
18:49:41 <Twey> See?
18:49:56 <sohum> yea, you should be able to simplify the code with just one stack
18:50:14 <sohum> (wait, is this meant to be prefix or postfix?)
18:50:20 <mmorrow> , readP_to_S (sepBy1 (choice [munch isDigit, string "+", string "-", string "*"]) skipSpaces) "+ 1 2 * 3 -"
18:50:22 <lunabot>  [([""],"+ 1 2 * 3 -"),(["",""],"+ 1 2 * 3 -"),(["","",""],"+ 1 2 * 3 -"),...
18:50:52 <mmorrow> goo
18:50:56 <Gracenotes> oog
18:50:56 <mauke> preflex: calc + + 1 2 3 4 *
18:50:56 <preflex>  15
18:51:16 <Gracenotes> two stacks is pretty Turing-machine-ish, though
18:51:40 <aavogt> @type munch
18:51:41 <lambdabot> Not in scope: `munch'
18:51:44 <mmorrow> , let lexemeP p = do a <- p; skipSpaces; return a in readP_to_S (many1 (lexemeP . choice $ [munch isDigit, string "+", string "-", string "*"])) "+ 1 2 * 3 -"
18:51:45 <sohum> a turing machine can be simulated with a two stack PDA
18:51:45 <lunabot>  [([""],"+ 1 2 * 3 -"),(["",""],"+ 1 2 * 3 -"),(["","",""],"+ 1 2 * 3 -"),...
18:51:49 <mmorrow> gah
18:51:52 <Gracenotes> , [$ty | munch |]
18:51:54 <lunabot>  luna: parse error on input `|]'
18:52:02 <mmorrow> , 'munch
18:52:03 <lunabot>  Text.ParserCombinators.ReadP.munch
18:52:05 <Gracenotes> sohum: my point quite
18:52:07 <mmorrow> , [$ty| munch|]
18:52:10 <lunabot>  (Char -> Bool) -> ReadP String
18:52:15 <Gracenotes> eek
18:52:19 <mmorrow> wteef
18:52:21 * sohum blinks
18:52:25 <sohum> the 'syntax?
18:52:40 <sohum> , 'show
18:52:41 <lunabot>  GHC.Show.show
18:52:42 <mmorrow> template-haskell
18:52:45 <sohum> shiny
18:52:49 <Gracenotes> I'm more surprised about the $ty parsing thing
18:52:51 <mmorrow> , [$ty| 'ty |]
18:52:52 <mauke> IIRC calc uses no stacks
18:52:54 <lunabot>  Name
18:53:00 <mmorrow> , src ''Name
18:53:02 <lunabot>  data Name = Name OccName NameFlavour
18:53:05 <mmorrow> , 'Name
18:53:06 <lunabot>  Language.Haskell.TH.Syntax.Name
18:53:10 <Gracenotes> mauke: well. you know how it is with recursion... :?
18:53:22 <Gracenotes> hrm.
18:53:28 <mmorrow> , let lexemeP p = do a <- p; skipSpaces; return a in last $ readP_to_S (many1 (lexemeP . choice $ [munch isDigit, string "+", string "-", string "*"])) "+ 1 2 * 3 -"
18:53:29 <Gracenotes> would love to check it out
18:53:30 <mauke> Gracenotes: it's not recursive
18:53:34 <lunabot>  Killed.
18:55:01 <mauke> hmm, I should make a pure haskell version of it some day
18:55:45 <mmorrow> what the frig is happening?!
18:55:53 <mmorrow> , let lexemeP p = do a <- p; skipSpaces; return a in readP_to_S (many1 (lexemeP . choice $ [munch isDigit, string "+", string "-", string "*"])) "+ 1 2 * 3 -"
18:55:55 <lunabot>  [([""],"+ 1 2 * 3 -"),(["",""],"+ 1 2 * 3 -"),(["","",""],"+ 1 2 * 3 -"),...
18:55:56 <Twey> Terror and chaos
18:56:06 <mmorrow> how is it accepting empty strings?
18:56:15 <mmorrow> oh
18:56:18 <mmorrow> , let lexemeP p = do a <- p; skipSpaces; return a in readP_to_S (many1 (lexemeP . choice $ [munch1 isDigit, string "+", string "-", string "*"])) "+ 1 2 * 3 -"
18:56:19 <lunabot>  [(["+"],"1 2 * 3 -"),(["+","1"],"2 * 3 -"),(["+","1","2"],"* 3 -"),(["+",...
18:56:38 <mmorrow> , let lexemeP p = do a <- p; skipSpaces; return a in fst . last $ readP_to_S (many1 (lexemeP . choice $ [munch1 isDigit, string "+", string "-", string "*"])) "+ 1 2 * 3 -"
18:56:39 <lunabot>  ["+","1","2","*","3","-"]
18:56:58 <mmorrow> guess munch,choice,many* don't play well
18:57:02 <dmwit> and the first shall be last
18:57:25 <mauke> "+ 1 2 * 3 -"? that's not even valid
18:58:25 <mauke> preflex: calc + 1 2 * 3 -
18:58:25 <preflex>  Not enough mana
18:58:27 <gwern> mauke: it's just a partially applied function :)
18:59:03 <mauke> preflex: calc + 1 2 * 3 - 5
18:59:03 <preflex>  2
19:00:55 <Qriva> How hard would it be to make a symbolic calculator that does some basic stuff?  like diff. of two squares?
19:01:05 <dmwit> > x^2 - y^2
19:01:07 <lambdabot>   x * x - y * y
19:01:17 <dmwit> ?where twanvl
19:01:17 <lambdabot> I know nothing about twanvl.
19:01:25 <dmwit> ?where simplexpr
19:01:25 <lambdabot> I know nothing about simplexpr.
19:01:29 <dmwit> hmph
19:02:39 <dmwit> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
19:02:46 <Gracenotes> @hackage simple-reflect
19:02:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/simple-reflect
19:10:52 <hackagebot> txt-sushi 0.3.0
19:16:39 <Qriva> Gracenotes: dmwit thanks
19:18:02 <Qriva> I'd like to build something to rotate 3d objects around an axis and calculate the volume or surface area
19:18:07 <Qriva> is that really hard for a newbie?
19:19:29 <Gracenotes> 2D and 3D plotting tends to not vary too much from language to language.
19:19:46 <Qriva> yeah, so far from the HSoE things look fairly straightforward
19:20:11 <Qriva> Haskell makes doing plain math pretty easy, it's the symbolic stuff that looks difficult
19:20:30 <Gracenotes> definitely up Haskell's alley -- especially with ADTs and the like... depends on the algorithm
19:20:50 <roconnor> > deriv (sin . cos) x
19:20:52 <lambdabot>   1 * negate (sin x) * cos (cos x)
19:21:03 <Qriva> deriv x^3
19:21:09 <Qriva> > deriv x^3
19:21:10 <lambdabot>   Couldn't match expected type `Data.Number.Dif.Dif a
19:21:12 <roconnor> > deriv (^3) x
19:21:14 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
19:21:16 <Qriva> ahhhh
19:21:24 <roconnor> > deriv (\x -> x^3) x
19:21:25 <lambdabot>   (1 * x + x * 1) * x + x * x * 1
19:21:30 <Qriva> what is \x?
19:21:44 <roconnor> \param is how we write anonymous function
19:21:47 <wli> Now you just need to find an integral basis ...
19:21:53 <Qriva> also, what is v', where v is any binding
19:22:00 <Zao> @type \x y -> x + y
19:22:02 <lambdabot> forall a. (Num a) => a -> a -> a
19:22:14 <Qriva> Zao: is that a monad?
19:22:22 <Zao> ' is a valid glyph in names.
19:22:24 <Qriva> it's not, nevermind
19:22:29 <Gracenotes> @type deriv
19:22:29 <Zao> x, x' and x'' are independent names.
19:22:30 <lambdabot> forall a b. (Num a, Num b) => (Dif a -> Dif b) -> a -> b
19:22:38 <roconnor> \ is lambda x y are Zao's parameters -> separates parameters from the body, x + y is the body.
19:22:44 <Qriva> Zao: awesome, thank you
19:22:59 <Qriva> so i know this is almost cliche in here, but i have to ask:
19:23:03 <Qriva> got a good monad tutorial?
19:23:07 <Zao> A named function like mine would be   f x y = x + y
19:23:11 <gwern> @quote monad.*tutorial
19:23:11 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
19:23:17 <gwern> @quote monad.*tutorial
19:23:17 <lambdabot> <BMeph> says: psygnisfive: In #haskell, you can't hardly be taken seriously w/o writing a monad tutorial...
19:23:21 <Qriva> haha
19:23:22 <gwern> @quote monad.*tutorial
19:23:22 <lambdabot> Pseudonym says: A "newbie", in Haskell, is someone who hasn't yet implemented a compiler. They've only written a monad tutorial.
19:23:22 <InabaAtsuyoshi> lol
19:23:27 <gwern> @quote Wadler
19:23:27 <lambdabot> lambdabot says: I know nothing about wadler.
19:23:30 <psygnisfive> O_O
19:23:32 <Gracenotes> sure you don't
19:23:35 <psygnisfive> damnit lambdabot >|
19:23:36 <idnar> bwahaha
19:23:40 <gwern> @quote endofunctor
19:23:41 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
19:23:42 <InabaAtsuyoshi> @quote curry
19:23:42 <lambdabot> VirginiaCurry says: "You know, Haskell actually never liked the name Haskell." -- Virgina Curry (Haskell B. Curry's widow)
19:23:48 <Qriva> >>=
19:23:52 <Gracenotes> =<<
19:23:58 <idnar> >=>
19:24:02 <Gracenotes> <=<
19:24:02 <Qriva> lol
19:24:04 <Qriva> well played
19:24:05 <gwern> <->
19:24:07 <Qriva> :=:
19:24:11 <Gracenotes> >-<
19:24:12 <idnar> >=< -- oh noes!
19:24:15 <Gracenotes> <=>
19:24:17 <gwern> :-;
19:24:21 <Gracenotes> -:-
19:24:26 <InabaAtsuyoshi> ^-^
19:24:31 <Gracenotes> ï¼ˆã€€â‰–â€¿â‰–ï¼‰
19:24:33 <Qriva> ((_)=======D
19:24:33 <roconnor> ^-v
19:24:38 <Gracenotes> okay okay
19:24:43 <InabaAtsuyoshi> rofl
19:24:47 <gwern> Qriva: actually, that's not valid because of the parentheses
19:24:48 <idnar> (:[])
19:24:57 <gwern> @quote monkey
19:24:57 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
19:24:58 <roconnor> > (:[]) 5
19:24:59 <lambdabot>   [5]
19:25:04 <Absolute0> Is there something like a functor but returns the inner object after applying fmap? ie fmap (+1) (Just 10) -> 11
19:25:08 <Qriva> (_)==D
19:25:10 <Qriva> -> True?
19:25:14 <gwern> @quote monkey
19:25:15 <lambdabot> DanPascu says: For God's sake, have mercy on us. I'm no mathematician, yet I find 'patch commutation' to sound reliable and trustworthy. 'Patch Flipping' sounds like a drunken monkey doing rollovers
19:25:17 <dmwit> Absolute0: comonad
19:25:22 <gwern> dang it, the monkey quote is gone
19:25:25 <Qriva> > (_) == D
19:25:27 <lambdabot>   Pattern syntax in expression context: _Not in scope: data constructor `D'
19:25:35 <Qriva> > (_) == o
19:25:36 <lambdabot>   Pattern syntax in expression context: _
19:25:42 <Qriva> i give up
19:25:51 <Gracenotes> _ is used with pattern matching
19:25:57 <Qriva> > _ == _
19:25:58 <lambdabot>   Pattern syntax in expression context: _Pattern syntax in expression context...
19:26:07 <Apocalisp> Maybe is not a comonad is it?
19:26:34 <hatds> no, what would coreturn be?
19:26:42 <Absolute0> Maybe is a functor
19:26:48 <Gracenotes> pattern matching is a kind of declarative programming
19:26:48 <Absolute0> iirc
19:26:53 <idnar> extend :: Comonad w => w a -> (w a -> b) -> w b
19:27:20 <Apocalisp> yea, coreturn would be undefined for the Nothing case
19:27:22 <idnar> wait, no, I guess you want extract :: Comonad w => w a -> a
19:27:24 <Gracenotes> not really found in other languages...
19:28:09 <bremner> Gracenotes: err, pattern matching is found in many languages
19:28:10 <idnar> Gracenotes: hmm, there are limited forms of pattern matching in quite a few languages
19:28:18 <Gracenotes> I mean, declarative programming isn't
19:28:29 <Gracenotes> oops. and I mean, not found in many other languages.
19:28:35 <Apocalisp> Absolute0: In general, you don't want to get things "out" of monads. You want to put computations in.
19:28:48 <bremner> Gracenotes: if by other languages you mean Java.
19:29:07 <Absolute0> Apocalisp: I know, it's just a convenience to extract as well...
19:29:18 <Absolute0> like ad hoc computation and print
19:29:32 <Gracenotes> declaring classes? Yeah, not sure data structures count...
19:30:01 <Gracenotes> anyway. silly point.
19:30:01 <Absolute0> Is it right to view type classes as interfaces and instances as implementations?
19:30:11 <Gracenotes> sorry
19:31:07 <dmwit> Absolute0: That's about right, yeah.
19:31:16 <Absolute0> :)
19:31:26 <dmwit> Absolute0: The main difference is that you can mix several interfaces (which Java definitely does Not Allow).
19:31:30 <bremner> Gracenotes: I guess it would be fair to say few "mainstream" languages support declarative programming
19:31:43 <dmwit> i.e. (Ord a, NFData a) => a -> a -> a -- or whatever
19:31:43 <Qriva> How does one do random numbers in haskell?
19:31:53 <bremner> Gracenotes: that is all I meant with the java reference
19:31:55 <Gracenotes> bremner: that sounds like much less of a careless phrasing :)
19:31:55 <Peaker> Absolute0: There's little point in having an fmapAndExtract. You could just have  class Extractable f where extract :: f a -> a   -- but Maybe could not be an instance -- how could you implement extract in the case of Nothing?
19:31:57 <Absolute0> dmwit: you can mix interfaces, you can't subclass many classes...
19:32:15 <Absolute0> dmwit: in Java that is.
19:32:20 <idnar> Absolute0: you can't apply multiple interface constraints to a variable, though
19:32:24 <dmwit> Absolute0: A type can implement many interfaces, but a function can't ask for a value that is an instance of several interfaces.
19:32:35 <dmwit> Qriva: System.Random?
19:32:38 <Gracenotes> "not really found in other languages" -- you can only make "really" mean so much...
19:32:39 <idnar> you could create a new interface that inherits from both, but that has to be explicit then
19:32:56 <idnar> anyway, the main difference is universal vs. existential quantification
19:32:59 <dmwit> Qriva: Once you've grokked the State monad, MonadRandom is a nice layer over System.Random.
19:33:23 <Peaker> dmwit: is there a transformer?
19:33:29 <Peaker> @hoogle RandomT
19:33:29 <lambdabot> No results found
19:33:31 <idnar> in Haskell, you typically have forall a. (SomeClass c) => c a
19:33:38 <dmwit> Peaker: You bet there is!
19:33:42 <dmwit> ?hackage MonadRandom
19:33:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadRandom
19:33:50 <idnar> er
19:33:57 <Gracenotes> interfaces also have this whole inheritance thing...
19:33:59 <idnar> forall a. (SomeClass a) => a I mean
19:34:11 <Peaker> cool
19:34:17 <idnar> in java, you effectively have exists a. (SomeClass a) => a
19:34:19 <Peaker> Baughn: you there?
19:34:44 <Gracenotes> idnar: ...interesting.. how so?
19:35:05 <Gracenotes> is this because of some kink in the type system?
19:35:09 <Peaker> idnar: in C++ too, yeah, and this has often overlooked efficiency problems too - as well as dividing the language into the generics world, and subclassing world, where each thing can be implemented in either way
19:35:15 <idnar> Gracenotes: I wouldn't really say it's a "kink"
19:35:27 <Gracenotes> instanceof-ing? Because inheritance implementation is open-ended polymorphism, just like typeclasses
19:35:37 <Peaker> Gracenotes: when in C++ or Java you say that you take a variable of type  Blah, then actually you're saying that the variable is *any subclass* of Blah, and not necessarily a Blah
19:35:41 <Gracenotes> interface implementation rather
19:36:16 <idnar> Gracenotes: interface inheritance is pretty similar to subclassing in haskell, though
19:36:18 <Peaker> Gracenotes: In Haskell, Eq a => a -> a -> Bool -- sure "a" is *any instance* of Eq, like any subclass, *but* the two a's are the same
19:36:22 <Gracenotes> mm. and for SomeClass a => a, a is any instance of SomeClass.
19:36:49 <Peaker> Gracenotes: in Java/C++ you can't express that at all -- and each of  Eq -> Eq -> Bool is carrying its own vtable which makes it a serious problem choosing which to use
19:37:13 <idnar> yeah, if you have "bool somefunc(Comparable x, Comparable y)", x and y can be of different types
19:37:18 <dmwit> Gracenotes: Right, the difference is in who gets to decide what 'a' is: the caller or the callee.
19:37:19 <Peaker> Gracenotes: not to mention having an array of many objects always has each one carrying a vtable ptr, rather than just having the vtable ptr outside (e.g as an arg), when the type is universally quantified
19:37:37 <Gracenotes> hm. I see. But you can discern more about a type in Java/C++ than you could in a simple exists (Blah a) => a system
19:37:42 <idnar> it's more like (Eq a, Eq b) => a -> b -> Bool
19:37:53 <Gracenotes> due to casting and whatnot
19:37:53 * dmwit never thought of it this way; it's very instructive
19:37:55 <dmwit> idnar++
19:38:22 <Peaker> idnar: Well, since you can't really use "a" and "b" anywhere else, I'd say its less like that
19:39:02 <idnar> ((Eq a) => a) -> ((Eq a) => a) -> Bool, then?
19:39:19 <Peaker> compare :: (exists a. Eq a => a) -> (exists a. Eq a => a) -> Bool
19:39:23 <Peaker> I think
19:39:28 <idnar> oh, well, yeah
19:39:36 <idnar> we're comparing apples with particle accelerators, let's not pick too many nits ;)
19:39:40 <Gracenotes> I think this is simplifying their type system just a bit. But, anyway >_>
19:39:45 <idnar> Gracenotes: well, Haskell has unsafeCoerce and so on
19:40:02 <Gracenotes> in language disputes, unsafe* is off-limits :P
19:40:04 <idnar> "casting" is actually a whole bunch of separate things
19:40:12 <gwern> no, you said their names!
19:40:24 <idnar> jumping over to C++ for a moment; you have static_cast<> which is more like fromIntegral and friends
19:40:31 <idnar> you have reinterpret_cast<> which is like unsafeCoerce
19:40:35 <Gracenotes> idnar: but it really does make a different, casting and whatnot
19:40:39 <Gracenotes> difference
19:40:41 <gwern> ia! ia! p'fthagan unsafeCoerce# shubboth!
19:41:00 <idnar> you have const_cast<> which is a mild form of unsafeCoerce
19:41:12 <idnar> and you have dynamic_cast<> which is somewhat magic
19:42:32 <Peaker> @hoogle cast
19:42:32 <lambdabot> Data.Typeable cast :: (Typeable a, Typeable b) => a -> Maybe b
19:42:32 <lambdabot> Foreign.C.String castCCharToChar :: CChar -> Char
19:42:32 <lambdabot> Foreign.C.String castCharToCChar :: Char -> CChar
19:42:42 <idnar> dynamic_cast does runtime introspection to check whether the value you have is actually the subclass you want to cast it to, and bails out if it's not
19:42:48 <Peaker> dynamic_cast is like  Data.Typeable cast
19:42:57 <idnar> yeah
19:43:07 <Peaker> > cast 5 :: Double
19:43:08 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
19:43:15 <dmwit> > cast 5 :: Maybe Double
19:43:17 <lambdabot>   Nothing
19:43:23 <dmwit> > cast 5 :: Maybe Integer
19:43:24 <lambdabot>   Just 5
19:43:42 <Peaker> idnar: except Typeable cast has a nicer mechanism than exceptions :)
19:44:43 <idnar> @type let f = (\x -> x) :: (Num a) => a -> (forall b. (Num b) => b) in f 5
19:44:45 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
19:44:45 <lambdabot>       `b' is a rigid type variable bound by
19:44:45 <lambdabot>           the polymorphic type `forall b. (Num b) => b' at <interactive>:1:9
19:44:46 <Peaker> const_cast is like id in Haskell :)
19:45:00 <idnar> hrm, nevermind
19:45:17 <idnar> Peaker: eh, it's more like unsafePerformIO than id :P
19:45:38 <Peaker> idnar: everything is const and remains const in Haskell, so its id :)
19:46:11 <Peaker> Perhaps you could say its a readIORef -- if you start with a mutable IORef
19:46:20 <idnar> unsafePerformIO . readIORef
19:46:44 <Peaker> I wouldn't say anything in C++'s const_cast means its Haskell "equivalent" shouldn't be in IO
19:46:47 <idnar> except it's inside-out
19:47:09 <idnar> Peaker: it falsifies the type of a value in a way that doesn't cause corruption
19:47:38 <idnar> as opposed to reinterpret_cast<> which can produce undefined behaviour
19:47:58 <Gracenotes> hm. Isn't this article a bit odd? http://en.wikipedia.org/wiki/Composite_data_type
19:48:11 <idnar> I'm struggling to find a Haskell analogue of that
19:48:15 <Gracenotes> describes a record. or an ADT
19:48:21 <Gracenotes> but it's only about C++
19:48:32 <Gracenotes> methinks it doesn't really exist >_>
19:49:43 <idnar> it's kinda like using unsafeCoerce to unwrap a newtype whose constructor isn't exported
19:50:03 <Peaker> Gracenotes: it sounds like a named type product
19:50:09 <idnar> you're not going to get garbage out, but you're being naughty, and you're still open to "semantic" breakage
19:50:19 <Gracenotes> Peaker: quite
19:50:22 <Peaker> idnar: a const_cast is just a readIORef -- not sure why you think it has not to be in IO
19:50:26 <Gracenotes> so many other names
19:50:36 <Gracenotes> the article doesn't really have sources >_>
19:51:15 <idnar> Peaker: a const_cast doesn't "do" anything, though
19:51:35 <idnar> Peaker: in the sense that the compiler doesn't emit any code for it
19:51:52 <Peaker> idnar: yeah, its the other way around, and you can't make an immutable mutable, so it just doesn't exist
19:52:23 <idnar> Peaker: the trick is that const doesn't actually mean immutable
19:52:30 <idnar> the real meaning of const is pretty much up to the programmer
19:52:50 <Peaker> idnar: C++ adds "immutablity" on top of mutability, and Haskell does the other way around, so in C++ dropping a compile-time qualifier is possible while converting a value whose semantics are truly as simple as that of immutability into a mutable value is just not possible
19:53:06 <Peaker> idnar: its supposed to mean immutable at some level
19:53:07 <idnar> because you can declare members as "mutable"
19:53:41 <Peaker> yeah, and they're supposed to be "caches" and such
19:54:35 <idnar> anyhow, I have to be up in 2 hours, so I bid you all adieu
20:01:32 <Gracenotes> hmmmmmmm. In both Haskell and C-style languages. there is a unit type, but only in one of those does it have a value :)
20:02:23 <Gracenotes> not like the value is that too useful
20:03:07 <Peaker> What's the unit type in c?
20:03:19 <Peaker> doesn't it have to have a value if its a unit-type?
20:03:21 <dmwit> void
20:03:30 <dmwit> it has value "return"
20:03:42 <Peaker> that's not a value :-P
20:03:45 <Zao> An uncompletable incomplete type.
20:04:06 <dmwit> Peaker: It's just an implicit, unboxed unit.
20:04:19 <dmwit> You can't store it in a variable because that would be stupid.
20:04:30 <kpreid> I wish sizeof(void) == 0
20:04:48 <mauke> void v = (void)1;
20:05:20 <kpreid> Oh, now I remember. The way in which void is Definitely Not An Ordinary Type: you can't write void foo() { return bar(); } where bar's return type is void.
20:05:23 <kpreid> This annoys me.
20:05:31 <kpreid> But in Haskell, () is a value!
20:05:58 <Peaker> well, the only utility that particular example would have is avoiding code change to propagate new return values, but you'd still have to change that void there. However, if it was a typedef...
20:06:19 <kpreid> or a macro.
20:06:29 <mauke> template<typename T> T foo() { return bar<T>(); }
20:06:52 <kpreid> that's not C :)
20:07:01 <Gracenotes> although, there is http://java.sun.com/javase/6/docs/api/java/lang/Void.html :)
20:07:09 <mauke> well, then you should have written void foo(void) {!
20:07:13 <Gracenotes> but still uninstantiable
20:07:58 <Peaker> foo :: () -> t ; foo () = bar ()
20:08:34 <sdf> Hello. I'm a newbie who's just begun the wormhole that is Haskell's type system. I understand what data is, and I understand how and why to do a type synonym, but I don't understand how a newtype declaration is useful to a beginner. I've read http://www.haskell.org/haskellwiki/Newtype , but I don't see any immediate reason why I should drop what I'm doing to
20:08:37 <sdf> learn based on that.
20:08:39 <mauke> foo :: () -> t; foo () = foo (bar ())
20:08:58 <mauke> sdf: newtype isn't useful to a beginner
20:09:10 <kpreid> sdf: the *use* of newtype is to distinguish things that are represented the same
20:09:19 <kpreid> sdf: without any inefficiency as a result
20:09:23 <aavogt> @type (==) `on` round
20:09:24 <lambdabot> forall a. (RealFrac a) => a -> a -> Bool
20:09:27 <aavogt> @type (==) `on` round 5.5
20:09:29 <lambdabot> forall b a. (Eq b, Integral (a -> b)) => a -> a -> Bool
20:09:35 <kpreid> e.g. newtype HTML = HTML String --
20:09:46 <aavogt> @type (==) `on` round $ 5.5
20:09:47 <lambdabot>     Precedence parsing error
20:09:47 <lambdabot>         cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
20:10:01 <kpreid> or newtype Length = Inches Double
20:10:23 <dmwit> > ((==) `on` round) 5.5 6.5
20:10:25 <lambdabot>   True
20:10:34 <hatds> there is one place where newtype is useful beside efficiency: newtype deriving
20:11:24 <aavogt> dmwit: infix functions with 4 arguments can be awkward sometimes
20:11:52 <dmwit> > let (~=) = (==) `on` round in 5.5 ~= 6.5
20:11:54 <lambdabot>   True
20:12:04 <idnar> kpreid: you can have an expression of type void in C, you just can't store it or use it ;)
20:12:15 <mauke> preflex: calc (1 2 + 3 4) --
20:12:15 <kpreid> I didn't say you couldn't!
20:12:15 <preflex>  -4
20:12:22 <sdf> I'm still having trouble conceptualizing the importance. Are you saying I should just basically not worry about it until I need to worry about performance issues? I read the examples given my kpreid, but they seem to be things that could be accomplished in other ways. Am I correct?
20:12:42 <idnar> kpreid: void foo() { return bar(); } does compile, btw
20:12:43 <mauke> everything can be done in some other way
20:13:02 <kpreid> idnar: hum...
20:13:05 <mmorrow> sdf: 'newtype' only exists at the source-code level, it's gone at runtime. whereas 'data' puts its content(s) into a box that has ptrs to them
20:13:05 <Peaker> idnar: that surprises me, no warnings with -Wall?
20:13:14 <idnar> Peaker: no warnings
20:13:17 <kpreid> idnar: is that with -std=c99 or -std=c89?
20:13:29 <idnar> kpreid: both work fine
20:13:37 <mmorrow> sdf: so newtype is "free" and data isn't
20:13:41 <idnar> I'm slightly surprised that it works, but only slightly
20:13:44 <kpreid> hold on, did you declare bar returning void?
20:13:45 <mauke> try.c:7: warning: ISO C forbids â€˜returnâ€™ with expression, in function returning void
20:13:58 <sdf> mmorrow: okay. that helps.
20:14:01 <idnar> kpreid: yes, void bar() {}
20:14:01 <kpreid> mauke: that's what I expected to see.
20:14:21 <hatds> I like how C warnings are "ISO C says you shouldn't do this dangerous thing
20:14:30 <idnar> mauke: how did you get that?
20:14:37 <idnar> ah, -pedantic
20:14:44 <mauke> with my default c flags
20:14:45 <hatds> and not like "type rejected: returning Int where expecting void"
20:14:47 <mauke> preflex: ? cflags
20:14:48 <preflex>  gcc -std=c89 -pedantic -Wall -W -Wno-missing-field-initializers -Wundef -Wendif-labels -Wshadow -Wpointer-arith -Wbad-function-cast -Wcast-align -Wwrite-strings -Wstrict-prototypes -Wmissing-prototypes -Wnested-externs -O2
20:15:17 <idnar> g++ -pedantic is fine with it, though
20:15:54 <idnar> hmm, what is sizeof(void)?
20:15:56 <mauke> (note: gcc doesn't even claim to be a C compiler without -std=c89 -pedantic)
20:16:14 <mmorrow> mauke: c89??
20:16:18 <mauke> yes
20:16:26 <mauke> it definitely doesn't conform to c99
20:16:32 <idnar> oh, 1 (and a warning)
20:17:03 <idnar> not that it matters
20:17:27 <idnar> does a value of type () consume memory in GHC?
20:17:55 <hatds> typeclasses and alternatives (sum types) provide similiar but distinct roles -- is there an analogue for product types?
20:18:20 <mauke> hatds: sounds like a record system!
20:18:30 <allbery_b> idnar: it does, because it could be _|_
20:18:41 <hatds> mauke: it doesn't to me
20:19:13 <hatds> or is it extensible records?
20:24:09 <hackagebot> hsSqlite3 0.0.6
20:24:20 <gwern> hatds: I'm guessing a sum type is data Foo = Bar | Quux, but what's a product type?
20:24:36 <mauke> data Foo = Foo Bar Baz
20:24:38 <hatds> gwern: tuples or data types with one constructor
20:25:12 <gwern> hum
20:25:13 <mauke> and you can build everything from (), Either, (,) and recursion
20:32:14 <dmwit> ...and ->
20:39:10 <idnar> mauke: man, that would be painful :P
20:43:56 <dmwit> idnar: Go to bed!
20:59:04 <roconnor> mauke: I don't think that is true
20:59:44 <roconnor> mauke: you need type-level combinators: SK or BCKW or some such thing.
21:00:29 <gio123> is here any english speaker?
21:00:38 <MyCatVerbs> No, we all speak Haskell.
21:01:07 <MyCatVerbs> I mean, yes. Everybody here speaks English. What can I do for you?
21:01:09 <gio123> ok
21:01:24 <gio123> nothing
21:01:28 <gio123> just wanted to know
21:02:17 <Twey> .oi mi pi-so'u-roi vi tavla fo la .lojban.
21:02:31 <osfameron> tu croix?
21:03:05 <MyCatVerbs> Well okay, Twey and osfameron can only be communicated to through obscenely complicated strings of typeclass declarations.
21:03:09 <MyCatVerbs> But pretty much everyone else is alright.
21:04:18 <roconnor> gio123: there are a few non-english Haskell channels.
21:04:36 <roconnor> #haskell.es for example
21:05:13 <roconnor> El Lenguaje de ProgramaciÃ³n Puramente Funcional Haskell
21:05:33 <osfameron> and -it
21:05:48 <osfameron> consistency ftw
21:06:25 <roconnor> god damn inconsistency
21:06:25 <MyCatVerbs> I don't think there's a #haskell.ge yet, though.
21:06:33 <roconnor> @where lambdabot
21:06:33 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
21:06:34 <osfameron> ge?
21:06:38 <roconnor> @seen lambdabot
21:06:39 <lambdabot> Yes, I'm here. I'm in ##english, #haskell-hacphi, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #
21:06:39 <lambdabot> haskell.jp, #haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-in-depth, #haskell-freebsd,
21:06:39 <lambdabot> #macosx, ##freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow
21:06:39 <lambdabot> and #haskell
21:07:03 <mmorrow> void **fix(void*(*f)(void**)) {return f(malloc(sizeof(void*)));}
21:07:06 <mmorrow> /kinda
21:07:09 <osfameron> ah! it /is/ .it, my mistake
21:07:31 <MyCatVerbs> osfameron: Georgia. I got curious and poked a geoip service.
21:07:38 <osfameron> aha
21:07:46 <Twey> mmorrow: !!!
21:08:05 <monochrom> That is evil.
21:08:24 <osfameron> wossit do?
21:08:26 <MyCatVerbs> What, GeoIP is evil?
21:08:37 <monochrom> The C code of mmorrow is evil.
21:09:17 <MyCatVerbs> Oh! Yes.
21:09:23 <MyCatVerbs> Evil indeed.
21:09:48 <monochrom> I think it works for suitably defined f.
21:11:38 <monochrom> No, it doesn't recurse f. I don't know its purpose now.
21:12:09 <monochrom> And his computer has just crashed because he is testing his code. :)
21:12:26 <Twey> Forgot to free.
21:12:26 <osfameron> unless malloc happens to return fix?
21:12:46 <osfameron> meh, do not understand C
21:13:29 <monochrom> malloc is not supposed to happen to return fix. It is not like we're running it in DOS.
21:13:29 * alvarezp is away: 
21:13:41 <mmorrow> laptop dies
21:13:52 * osfameron crashes (due to lack of sleep, as well as evil c)
21:14:04 <monochrom> You spewed evil C code and your laptop dies in punishment.
21:21:01 <mmorrow> monochrom: haha
21:21:05 <mmorrow> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2535#a2535
21:21:14 <mmorrow> , fix (42:)
21:21:16 <lunabot>  [42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,...
21:21:54 <mmorrow> malloc just for the indirection ptr
21:22:17 <mmorrow> gah, my session fontsize is borked.. re-logging in
21:25:45 <mmorrow> that abstract out into its own function pretty poorly
21:25:49 <mmorrow> *abstracts
21:26:09 <mmorrow> forces you to have **'s all over
21:26:52 <mmorrow> , levels (fix (\x -> Node () [x,x]))
21:26:54 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
21:27:29 <osfameron> :t levels
21:27:31 <lambdabot> forall a. Tree a -> [[a]]
21:27:55 <osfameron> ah
21:28:07 <mmorrow> perfect infinite binary tree :)
21:28:41 <mmorrow> , vacuum (fix (\x -> Node () [x,x]))
21:28:43 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
21:29:06 <mmorrow> , vacuum (fix (\x -> () : x))
21:29:09 <lunabot>  [(0,[1,0]),(1,[])]
21:32:26 <Gracenotes> mmorrow: how do you know about which number is which node..? no way to tell? >_>
21:32:50 <mmorrow>   (nodeid,[ptrs])
21:33:31 <mmorrow> and if (nodeif,[]) ==> it's a literal (Int#,Double#,(possibly many of them))
21:33:38 <mmorrow> (nodeif,[])
21:33:39 <mmorrow> gah
21:33:41 <mmorrow> (nodeid,[])
21:34:03 <mmorrow> , vacuum [0..100]
21:34:05 <lunabot>  [(0,[1,2]),(1,[]),(2,[3,4]),(3,[]),(4,[5,6]),(5,[]),(6,[7,8]),(7,[]),(8,[...
21:34:57 <mmorrow> Gracenotes: but yeah, you have to guess which pair corresponds to which node ;)
21:35:25 <Gracenotes> mmorrow: well, the diagrams have it
21:35:26 <mmorrow> it walks it (for the most part) breadth-first though
21:35:30 <mmorrow> yeah
21:35:42 <Gracenotes> might mighty useful... quizas
21:35:44 <mmorrow> this just ditches all info other than the graph structure
21:36:13 <Gracenotes> aw.
21:36:23 <mmorrow> (it actually use essentially the same algo that a cheney copying gc uses)
21:36:59 <mmorrow> except the "tospace" is the (IntMap HNode) in the state monad's state rather than a chunk of memory
21:43:00 <mmorrow> love million line csv files
21:44:35 <mmorrow> oops, that should be:
21:44:44 <mmorrow> void **fix(void**(*f)(void**))
21:44:47 <mmorrow> not
21:44:50 <mmorrow> void **fix(void*(*f)(void**))
21:45:01 <mmorrow> (not that it really matters in C)
21:45:37 <luqui> why void**?
21:46:45 <mmorrow> that fix is basically just abstracting out allocating the idirection ptr that `f' 'll use to set it's result to and to embed within itself
21:46:55 <Pseudonym> template<type T> T fix(std::unary_function<T,T>);
21:47:21 <mmorrow> so it's actually pretty worthless as a C function since it forces you to have another level of indirection
21:47:37 <mmorrow> for not really any gain (woo, not have to call malloc once yourself :)
21:48:10 <luqui> Pseudonym, of course, that's no good because C++ is strict
21:48:16 <luqui> Pseudonym, need to eta expand
21:48:33 <mmorrow> Cons *xs; xs = malloc(sizeof(Cons)); xs->head = 42; xs->tail = xs; return xs; //without the need for **'s
21:48:35 <Pseudonym> Of course, none of this is any good because not all types in C or C++ have a least fixed point.
21:49:35 <luqui> template<class T. class U> std::unary_function<T,U> fix(std::unary_function<std::unary_function<T,U>, std::unary_function<T,U> >)  // ugh
21:49:50 <luqui> all function types do
21:49:55 <mmorrow> the single-fix is more about self-reference than recursion though
21:50:01 <mmorrow> *single-arg fix
21:50:03 <luqui> ah
21:50:31 <mmorrow> it hands you the result of what you'll eventually do with the result
21:50:53 <mmorrow> which is just an uninitialized chunk of memory
21:51:08 <luqui> that sentence made me think of fixed points of continuations...
21:51:20 <luqui> which is probably unremarkable, but i can't grok it at
21:51:21 <luqui> atm
21:51:59 <mmorrow> how do you mean?
21:53:00 <mmorrow> @type \f a -> fix (\k -> f a k)
21:53:01 <lambdabot> forall t a. (t -> a -> a) -> t -> a
21:53:11 <mmorrow> hmm
21:53:20 <mmorrow> @type \f -> fix (\k -> f k)
21:53:21 <lambdabot> forall a. (a -> a) -> a
21:53:27 <mmorrow> heh,
21:53:32 <mmorrow> oh
21:54:40 <mmorrow> hard without newtypes to get infinite types
21:55:18 <mmorrow> (hard [to mess with fix+continuations] without newtypes [as a way to get] infinite types)
21:56:04 <mmorrow> luqui: the monadLib `Label' datatype is really neat
21:56:26 <mmorrow> it lets you grab the cont from callCC and stick it places
21:57:42 <mmorrow> , runCont (do (a,here) <- label 0; when (a < 100) (jump here (a+3)); return a)
21:57:43 <lunabot>  luna: Not in scope: `label'
21:58:15 <luqui> oh, first-class goto
21:58:23 <mmorrow> , runCont (do (a,here) <- labelCC 0; when (a < 100) (jump here (a+3)); return a)
21:58:25 <lunabot>  luna: Occurs check: cannot construct the infinite type:
21:58:29 <mmorrow> , runCont id (do (a,here) <- labelCC 0; when (a < 100) (jump here (a+3)); return a)
21:58:31 <lunabot>  luna: Occurs check: cannot construct the infinite type:
21:58:45 <mmorrow> , [$ty| jump |]
21:58:48 <lunabot>  forall a b c . ContM b => c -> Label b c -> b a
21:58:50 <luqui> I like monadlib
21:58:55 <mmorrow> , runCont id (do (a,here) <- labelCC 0; when (a < 100) (jump (a+3) here); return a)
21:58:56 <lunabot>  102
21:59:09 <mmorrow> luqui: yeah, it's nice
21:59:39 <roconnor> newtype Label m a    = Lab ((a, Label m a) -> m ())
21:59:49 * roconnor mind boggles
22:00:00 <roconnor> that does seem strictly positive to me.
22:00:11 <roconnor> that doesn't
22:00:14 <mmorrow> you need to define jump as
22:00:54 <mmorrow> jump a l@(Lbl k) = k (a,l) >> undefined
22:01:04 <mmorrow> or something like that
22:01:20 <mmorrow> (or at least how i defined it i did)
22:01:49 <luqui> roconnor, does it need to be?
22:02:26 <mmorrow> jump :: a -> Label m a -> Cont o a
22:02:30 <mmorrow> jump a l@(Lbl k) = k (a,l) >> undefined
22:03:04 <mmorrow> label a = callCC (\k -> return (a, Lbl k))
22:10:00 <roconnor> It's nice that Haskell's char was able to change from 8 bit to 16 bit to 24 bit without trouble.
22:10:06 <Gracenotes> @djinn (t -> t -> a) -> t -> a
22:10:07 <lambdabot> f a b = a b b
22:18:34 <Athas> What's the proper way to compile a Haskell program using Data.Binary and Data.Bytestring.Lazy with GHC from the command-line?  I get linker errors about undefined symbols with plain ghc Main.hs.
22:18:43 <Athas> I can load the program just fine in ghci, though.
22:19:51 <QtPlaty[HireMe]> ghc --build Main.hs
22:19:55 <mmorrow> @pl \a b c -> a b c
22:19:56 <lambdabot> id
22:20:43 <Athas> ghc: unrecognised flags: --build
22:21:06 <hotaru2k3> isn't it "--make"?
22:21:27 <Athas> --make indeed works, thanks!
22:21:53 * roconnor doesn't know how to use ghc without --make
22:22:56 <mmorrow> @pl \f -> \a b c -> a (f b) c
22:22:57 <lambdabot> flip (.)
22:23:08 * Twey chuckles.
22:23:11 <mmorrow> @pl \f -> \a b c -> g a (f b) c
22:23:12 <lambdabot> flip ((.) . g)
22:23:12 <Twey> That showed you!
22:23:17 <mmorrow> heh
22:54:43 <hydo> Ugh... gotta put haskell on pause to clean up perl code so I can put it up on github and (hopefully) get a damn job.  *sniff*
22:56:04 <Twey> By â€˜clean upâ€™ you of course mean â€˜convert to Haskellâ€™ :-P
23:13:52 <hackagebot> hack-frontend-happstack 2009.6.1
23:50:21 <copumpkin> epic bindings in hackage
