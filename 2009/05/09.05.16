00:00:03 <Jedai> Oh well...  it was a complicated question to do it right anyway... We don't have a latex generating package, do we ?
00:01:31 <sjanssen> Jedai: pandoc might actually have something
00:02:00 <sjanssen> but we can still do better than this sample without even involving proper LaTeX generation
00:02:29 <Jedai> Right
00:03:40 <Apocalisp> http://www.wolframalpha.com/input/?i=((a+and+b)+implies+c)+implies+a+implies+b+implies+c
00:04:03 <Apocalisp> This thing is neat.
00:04:32 <Apocalisp> can't wait for "Wolfram Lambda"
00:06:26 <Gracenotes> curry!
00:06:43 <Axman6> yum
00:06:45 <Gracenotes> Apocalisp: exactly what I was thinking
00:06:51 <Gracenotes> tried (\x . x) y earlier
00:06:55 <Gracenotes> naught
00:07:00 <Axman6> oh wow, wolfram alpha's open now. wasn't yesterday
00:07:44 <Apocalisp> Even better: ((a and b) implies c) vs (a implies b implies c)
00:08:21 <Gracenotes> only false if a and b are true and c is false
00:08:39 <Gracenotes> hm
00:10:36 <Apocalisp> it means that the function can be realised for all a and b.
00:10:56 <Axman6> http://www.wolframalpha.com/input/?i=weather+in+canberra+on+November+5th+1989 awesome
00:12:42 <Apocalisp> weather in bingen am rhein on easter sunday
00:13:25 <Twey> Wolfram|Alpha has temporarily exceeded its current maximum test load.
00:13:44 <Twey> i.e. one of the guys sitting there typing away furiously on his keyboard went off for a toilet break
00:13:58 <sjanssen> huh, they even have weather from the day and location I was born
00:14:24 <sjanssen> Lincoln, NE which is no major city
00:16:42 <copumpkin> :o
00:17:16 <copumpkin> I was born on a rainy day
00:17:20 <copumpkin> unsurprisingly
00:17:52 <copumpkin> it doesn't know the average volume of the human penis though
00:17:53 <Gracenotes> I was born a very hot day
00:18:05 <Gracenotes> ~100 degrees
00:18:14 <copumpkin> was water boiling? ;)
00:18:16 <Gracenotes> at least where I was born
00:18:29 <sjanssen> copumpkin: the historical graph shows the average skyrocketing the day I was born :)
00:18:32 <sjanssen> hur hur hur
00:18:35 <Gracenotes> silly human, Fahrenheit is the natural scale!
00:18:39 <copumpkin> lol
00:18:40 <Apocalisp> I was born on a snowy day, apparently.
00:18:44 <Apocalisp> in may
00:18:59 <copumpkin> I bet wolfram alpha relies on types a lot
00:19:03 <copumpkin> :P
00:19:14 <Apocalisp> quite
00:19:24 <Apocalisp> try "2 girls 1 cup"
00:19:35 <copumpkin> lol
00:19:47 <sjanssen> 2 cup girls -- nice!
00:19:48 <Apocalisp> answer: 2 girls * 1 cup = 2 cup girls
00:20:13 <Apocalisp> whee
00:21:02 <copumpkin> I wonder if alpha hooks into freebase
00:21:36 <Twey> Hahaha
00:22:22 <sclv> yipe. a giant rule system hooked on freebase. sounds like a recipe for disaster.
00:24:57 <copumpkin> alpha is cool enough for sjanssen to tweet about!
00:24:58 <ray> wolfram alpha can't tell me how to tie a windsor knot, fail
00:25:15 <copumpkin> a tweet from sjanssen is worth a lot more than one of mine is, because he tweets so rarely!
00:25:16 <Axman6> "Assuming "wolfram alpha" is a historical event | Use as an internet domain instead" ha
00:25:22 <wli> I'd have asked it how to tie a cravat.
00:26:20 <sjanssen> copumpkin: I considered posting 2 cup girls, but didn't want to without proper attribution
00:26:37 <ray> it can't prove P != NP either
00:26:50 <Apocalisp> well what's the point then
00:27:19 <Gracenotes> I think it would be very weird of P = NP
00:27:43 <Gracenotes> if there is an algorithm to solve every NP problem in polynomial time, why hasn't it been discovered yet?
00:27:48 <Gracenotes> for any of them? >_>
00:27:59 <sjanssen> it can't tell me which Superman and the Flash are faster :(
00:28:32 <ray> yeah people generally go with the assumption that P != NP
00:28:35 <copumpkin> Gracenotes: proof by "surely someone would've proved this by now if it were true"
00:28:40 <bpalmer> neither can DC comics.
00:28:51 <copumpkin> *disproof, I guess
00:28:55 <Gracenotes> copumpkin: it is suspicious though
00:28:59 <sjanssen> bpalmer: not with any consistency, no
00:29:13 <ray> well, it depends on whether the writers are benevolent or not
00:29:28 <ray> if they are, the flash is faster because otherwise he'd be upstaged by superman at the one thing he does
00:29:29 <bpalmer> every time I've seen them propose the question, they make sure to include some excuse.
00:29:32 <Gracenotes> if, as far as you know, something can't be done, it is perhaps best to assume that it simply can't be done when you need to apply it
00:29:44 <copumpkin> Gracenotes: what if the very question of P =? NP is itself undecidable??
00:29:49 <bpalmer> propose to answer the question, rather, they make sure to include an excuse for why it's not a definitive answer.
00:29:51 <Gracenotes> copumpkin: I've considered that
00:30:02 <ray> lots of people go with that assumption too
00:30:06 <Gracenotes> or perhaps you mean unprovable? >_>
00:30:27 <Gracenotes> do you mean decidable in the TM sense?
00:30:29 <copumpkin> if you phrase it as a decision problem, I don't see why I can't say it my way?
00:30:36 <Gracenotes> ah, okay.
00:31:00 <sjanssen> it does know the cheesy answer to life, the universe, and everything
00:31:20 <bpalmer> brie?
00:31:53 <Gracenotes> well, surely it's recognizable. Just try every possible program, simulating one step for one program, then two steps for two programs, then three steps for three programs, etc.
00:32:12 <Gracenotes> eventually you will reach any arbitrary step for any arbitrary program
00:32:31 <ray> now give them all numbers
00:32:32 <Gracenotes> although... how to determine the algorithm's time from just running it?
00:32:44 <bpalmer> Gracenotes: you're starting down Goedel's path.
00:33:14 <Gracenotes> come to think of it, is there an algorithmic way to determine some bounds on running time?
00:33:31 <bpalmer> Gracenotes: running time is usually considered as a function based on the size of input
00:33:39 <Axman6> functional programming, mathematica style: http://www.wolframalpha.com/input/?i=sin+%2F%40+%7Bpi%2F6%2C+pi%2F5%2C+pi%2F4%2C+pi%2F3%2C+pi%2F2%2C+pi%7D
00:34:37 <Gracenotes> bpalmer: a decidable computable one?
00:34:46 <Gracenotes> at least for bounds
00:35:17 <davidL> is something like foo defined somewhere? foo True c = Just c; foo False _ = Nothing
00:35:25 <Gracenotes> hm. I feel I'm venturing into rather murky waters
00:35:53 <bpalmer> I can describe a procedure whose running time is not decidable.
00:36:10 <ray> @hoogle Bool -> a -> Maybe a
00:36:11 <lambdabot> Control.Exception assert :: Bool -> a -> a
00:36:11 <lambdabot> Prelude asTypeOf :: a -> a -> a
00:36:11 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
00:36:12 <Berengal> davidL: Don't think so. How about just if True then Just x else Nothing
00:36:29 <copumpkin> davidL: if you had the bool function, you could do bool Just (const Nothing)
00:36:31 <Gracenotes> bpalmer: first even number not the sum of two primes, say? :)
00:37:00 <sjanssen> which #haskeller did I just pick up on twitter?
00:37:14 <Berengal> Gracenotes: 2?
00:37:16 <Gracenotes> hmm. Well we don't know if that's decidable. could be. might not be. aaarrghh it's late.
00:37:16 <wli> Me?
00:37:32 <Gracenotes> Berengal: the problem is formulated such that 2 is excluded
00:37:35 <davidL> thanks Berengal/copumpkin
00:37:52 <bpalmer> 2 is the sum of 1 and 1
00:37:55 <copumpkin> sjanssen: what handle?
00:37:59 <sjanssen> runarorama
00:38:01 <bpalmer> er, sorry, that was stupid on my part
00:38:01 <Berengal> bpalmer: 1 isn't a prime
00:38:05 <augustss> Wolfram Alpha is useless.
00:38:13 <bpalmer> right, a sign I'm out of here. :)
00:38:43 <ray> yeah, it can't even tell me anything about stephen wolfram except that he's not dead
00:38:43 <Berengal> http://www.wolframalpha.com/input/?i=e^(pi*i)
00:39:06 <Gracenotes> augustss: well. It does have some nice subroutines
00:39:41 <Gracenotes> as a general research tool it's a bit underdeveloped at the moment
00:39:50 <augustss> Gracenotes: I'm sure it can answer maths questions, but hardly anything else I've tried.  And it's natural language engine sucks.
00:40:12 <Gracenotes> this is basically its feature list: http://www.wolframalpha.com/examples/
00:40:43 <Berengal> I believe it'll be awesome when it matures a bit
00:40:49 <ray> of course it has cellular automata
00:41:02 <augustss> my latest failure is 'graph gbp/sek' which it understands, but doesn't do.
00:41:04 <Gracenotes> heh. yeah
00:41:29 <Berengal> When I searched for 'monad' it gave me a genome...
00:41:31 <Lemmih> augustss: Divide by zero?
00:41:37 <augustss> lol
00:42:28 <Berengal> Cripes! It knows about my home town, a place far out in deliverance country in norway :/
00:42:29 <cjs> Can anybody here give me an explanation of the hash table implementation given in Bagwell's VList paper (http://lampwww.epfl.ch/papers/techlists.pdf)? I can't seem to get it, perhaps because there's no example. In the off-topic channel is ok, if someone reminds me what that is.
00:42:32 <ray> i think you're confusing it with isk
00:43:01 <augustss> Doesn't know about my home town in Sweden.
00:43:11 <augustss> 'when is earth close to mars?'  not a clue
00:43:28 <Berengal> distance earth vs mars?
00:43:45 <Gracenotes> when are the planets physically closest, I suppose
00:44:06 <Gracenotes> things astrologists concern themselves about, too :P
00:44:34 <ray> also people lobbing rockets at mars
00:44:38 <augustss> As I said, it's natural language engine sucks
00:45:04 <Berengal> Aww... http://www.wolframalpha.com/input/?i=graph+distance+earth+vs+mars
00:45:36 <Berengal> Earth | current distance from Earth | (data not available)
00:45:37 <Gracenotes> it seems to be more of a find-the-subroutine thing. hopefully will get better with more input, if it doesn't wither up... which would be unfortunate
00:45:44 <ray> if i say "distance from earth" it locates my isp's nearest thingy and tells me how far it is from some point off the ivory coast
00:46:34 <Berengal> ray: I got "distance | from  Bergen, Hordaland, Norway to world" as my interpretation
00:46:43 <ray> presumably that point is 0 lat 0 long
00:47:19 <Gracenotes> distance to center of earth -> Assuming Center (Texas, USA). heh
00:47:33 <Gracenotes> "radius of earth" works
00:47:44 <Berengal> Eh, apparently the "world" is somewhere off the west coast of africa
00:48:05 <augustss> makes perfect sense.  To Steve Wolfram
00:48:41 <ray> well, it makes sense to me, it's just probably not the best interpretation
00:48:50 <augustss> 'how much can an unladen swallow carry?'
00:48:57 <ray> a cellular automata probably told him to do it
00:49:01 <ray> automaton
00:49:12 <Gracenotes> at least he has some cute queries that always work
00:49:19 <Gracenotes> like 42, woodchuck, etc.
00:49:31 <Gracenotes> that we'll possibly all be sick of in a week or so >_>
00:49:53 <Berengal> One can never be sick of such things
00:50:26 <Apocalisp> http://www.wolframalpha.com/input/?i=mercury+|+venus+|earth+|mars|+jupiter|+saturn+|uranus+|neptune+|pluto
00:50:36 <Apocalisp> neato
00:50:52 <augustss> http://www.wolframalpha.com/input/?i=third+futamura+projection
00:50:58 <augustss> clueless as usual
00:51:12 <Gracenotes> heh. it knows what it is told to know
00:51:27 <Berengal> I keep misreading futamura as futurama...
00:51:37 <Axman6> dwarf planet :(
00:52:45 <augustss> Of course it knows what it's been told.  But if you try to sell something as a knowledge engine you expect some basic knowledge. :)
00:52:52 <wli> Brown dwarves are reputedly interesting.
00:53:15 <dan> Anyone here an emacs wiz? Trying to make ghci autocomplete work in inferior haskell
00:53:26 <wli> They're reputedly like Jupiter, only much larger.
00:54:00 <Apocalisp> Brown dwarves seem to rather put the standard theory of stellar evolution in shome hot water.
00:55:31 <wli> They're interesting in their own right even apart from that.
01:02:07 <Apocalisp> I like this one here.
01:05:43 <Apocalisp> http://www.wolframalpha.com/input/?i=a+glass+of+milk+and+a+pop+tart
01:06:40 <Apocalisp> http://www.wolframalpha.com/input/?i=peanut+butter+and+jelly+sandwich+with+coke
01:07:12 <Apocalisp> It adds eggs and cheese to my pb&j :)
01:08:00 <Axman6> ha
01:08:19 <Axman6> http://www.google.com/search?&q=399999999999999+-+399999999999998 fail
01:08:42 <Apocalisp> does it work with rational numbers?
01:08:56 <Apocalisp> oh, those are integers
01:09:33 <Apocalisp> floating-point for the lose
01:09:34 * Axman6 adds .1 and .5 and still gets fail
01:12:36 <Apocalisp> http://www.wolframalpha.com/input/?i=five+tons+of+flax+seed
01:14:12 <Axman6> serving size 5 metric tons, ha
01:15:02 <Berengal> Mmm, five tons of flax...
01:15:28 <hydo> http://www.wolframalpha.com/input/?i=what+is+the+air-speed+velocity+of+an+unladen+swallow%3F
01:15:34 <hydo> wolframalpha++
01:16:03 <Berengal> http://www.wolframalpha.com/input/?i=what+is+the+air-speed+velocity+of+an+unladen+swallow%3F&a=*DPClash.MiscellaneousE.what+is+the+air!-speed+velocity+of+an+unladen+swallow-_*AirSpeedVelocityOfAnUnladenEuropeanSwallow-
01:19:27 <Berengal> I need to figure out which combinators WA has...
01:19:44 <Berengal> It's having some trouble finding the time from England to Africa using the airspeed of an unladen European swallow
01:26:32 <copumpkin> sjanssen: that same twitter user is following me now :o
01:26:54 <copumpkin> maybe he just found us on the haskellwiki twitter page?
01:27:22 <Axman6> which user?
01:27:39 <copumpkin> http://twitter.com/runarorama
01:28:11 <Axman6> rightio
01:29:02 <Apocalisp> Yea, I know that guy ;)
01:30:24 <copumpkin> :o
01:31:12 <copumpkin> oh, it's you :P
01:31:13 <ivanm> isn't twitter short for "I'm too lazy to blog properly", where blog was short for "I'm too lazy to write proper articles"?
01:31:29 <copumpkin> "A republic's constitution is its legislative typechecker. These presidential candidates do not compile!"
01:31:43 <copumpkin> ivanm: that's one way of looking at it (that I don't really agree with)
01:31:56 <ivanm> which part? ;-)
01:32:44 <copumpkin> well, I guess I only disagree with the connotations of the language you used :P
01:33:13 <ivanm> that twitter is useless?
01:33:24 <ivanm> good, because that's the connotation I was wanting to come across! :p
01:34:05 <copumpkin> :)
01:34:40 <ivanm> methinks something is wrong with reddit: it's saying that dons posted articles only 6 hours ago that I saw more like 20 hours ago... >_>
01:37:19 <Apocalisp> Twitter is for peripheral thoughts that you would share with your office mate if you had one.
01:37:37 <ivanm> Apocalisp: then why not actually say it to them?
01:37:46 <ivanm> oh, "if you had one"... missed that bit
01:37:50 <Apocalisp> Blogging is a substitute for ranting over a beer with a mate, if you had one.
01:38:42 <copumpkin> see, I'm too lazy to even argue about the worth of twitter anymore
01:39:11 <copumpkin> there are always people who will see anything as a fad that the sheep are following for the sake of following :)
01:40:29 * ivanm also refuses to use facebook, etc.
01:40:34 <copumpkin> exactly :)
01:40:39 <copumpkin> many people also refuse to use haskell
01:40:51 <ivanm> see, at least for facebook I have privacy reasons which are valid
01:41:03 <ivanm> whereas Haskell increases your security :p
01:41:09 <copumpkin> that's true :) although you can create an account with no information in it
01:41:17 <copumpkin> and just stalk people
01:41:19 <copumpkin> ;)
01:43:21 <copumpkin> anyway, bedtime for me :) ciao!
01:43:31 <mm_freak_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4924
01:43:48 <mm_freak_> this parser works only for FullUser, the other two parsers are tried, but they always fail
01:43:51 <mm_freak_> why?
01:44:13 <Berengal> mm_freak_: You need to try
01:44:25 <Berengal> as map try
01:44:33 <mm_freak_> oh, ok
01:44:36 <mm_freak_> thanks
01:44:39 <Berengal> Parsec doesn't backtrack unless you tell it to
01:44:49 <mm_freak_> yeah, i figured
01:46:51 <mm_freak_> works now, thanks
01:47:07 <Berengal> :)
01:52:44 <mm_freak_> is there some general way to express a natural transformation in haskell?  i often have the following pattern in my code:
01:52:51 <mm_freak_>   = case parse parser "" str of
01:52:51 <mm_freak_>       Left _       -> Nothing
01:52:51 <mm_freak_>       Right result -> Just result
01:53:20 <ivanm> mm_freak_: you mean Either -> Maybe?
01:53:32 <mm_freak_> Either left -> Maybe
01:54:57 <Twey> :t fromEither
01:54:58 <lambdabot> Not in scope: `fromEither'
01:55:59 <Twey> > either (const Nothing) Just (Right "foo")
01:56:00 <lambdabot>   Just "foo"
01:56:05 <Twey> > either (const Nothing) Just (Left "foo")
01:56:07 <lambdabot>   Nothing
01:56:24 <mm_freak_> i rather thought about a generalization of this
01:56:26 <Twey> Also:
01:56:27 <monadic_kid> when some says "natural transformation" i'm thinking catamorphisms
01:56:34 <monadic_kid> *when someone says
01:56:52 <mm_freak_> trans :: (Functor f, Functor g) => f a -> g a
01:56:53 <Twey> > listToMaybe . rights $ Left "foo"
01:56:54 <lambdabot>   Not in scope: `rights'
01:57:06 <Twey> Why isn't that in scope?
01:57:36 <dibblego> @type Data.Traversable.sequence -- mm_freak_
01:57:38 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
01:58:44 <mm_freak_> dibblego: how is that useful for my purpose?
01:59:09 <dibblego> mm_freak_, I'm just guessing -- (Functor f, Functor g) => f a -> g a is certainly useful
01:59:16 <dibblego> *not useful
01:59:22 <mm_freak_> why not?
01:59:35 <ivanm> @hoogle Either a b -> Maybe b
01:59:36 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
01:59:36 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
01:59:36 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
01:59:38 <dibblego> because it can't exist
01:59:54 <mm_freak_> class HasTransform f g where trans :: f a -> f b
01:59:58 <ivanm> oh, you found that already
02:00:28 <mm_freak_> uhm
02:00:31 <mm_freak_> silly me
02:00:34 <mm_freak_> class HasTransform f g where trans :: f a -> g a
02:01:11 <mm_freak_> instance HasTransform (Either l) Maybe where trans (Left _) = Nothing; trans (Right x) = Just x
02:01:23 <mm_freak_> i think that would be useful
02:04:05 <mm_freak_> even more general:  instance MonadPlus m => HasTransform (Either l) m where trans (Left _) = mzero; trans (Right x) = return x
02:07:57 <Saizan> it might be nice, though i'm not sure that it's always easy to find a canonical instance for every (f,g) pair
02:08:39 <mm_freak_> right
02:09:36 <mm_freak_> but i think that any comonad will make an 'f' and any MonadPlus will make a 'g'
02:12:20 <markb> how do i use lambdabot to convert a function to point free style?
02:12:47 <Saizan> @pl \f g x -> f x (g x)
02:12:47 <lambdabot> ap
02:12:56 <markb> cheers
02:13:13 <integral> @pl \a b -> compare (snd a) (snd b)
02:13:14 <markb> @pl \x -> ((x .&. 4) `shiftR` 2) `xor` 1
02:13:14 <lambdabot> (`xor` 1) . (`shiftR` 2) . (.&. 4)
02:13:14 <lambdabot> (. snd) . compare . snd
02:13:31 <Saizan> integral: compare `on` snd
02:13:35 <Saizan> or comparing snd
02:13:46 <integral> where's 'on' and 'comparing' from?
02:13:52 <mmorrow> @unpl (. snd) . compare . snd
02:13:53 <lambdabot> (\ d j -> compare (snd d) (snd j))
02:13:55 <Saizan> Data.Function and Data.Ord
02:14:02 <mmorrow> @unpl (`xor` 1) . (`shiftR` 2) . (.&. 4)
02:14:03 <lambdabot> (\ f -> xor (shiftR (f .&. 4) 2) 1)
02:14:36 <integral> cool, were those new in something like 6.4?
02:14:46 * integral has been away from following GHC's new versions for a while
02:15:13 <Saizan> on is from 6.6.1 i think, comparing i don't know
02:15:17 <integral> @src on
02:15:18 <lambdabot> (*) `on` f = \x y -> f x * f y
02:15:48 * integral didn't know you could use sections in patterns either 8-) neat
02:15:49 <mmorrow> @type on
02:15:51 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:15:55 <mmorrow> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
02:15:56 <lambdabot> f a b c _ = a (b c) (b c)
02:16:16 <mmorrow> heh, bzzzt
02:16:53 <mmorrow> @djinn (a -> a -> c) -> (b -> a) -> b -> b -> c
02:16:53 <lambdabot> f a b c _ = a (b c) (b c)
02:17:13 <mmorrow> @djinn (a -> a -> b) -> (c -> a) -> c -> c -> b
02:17:14 <lambdabot> f a b c _ = a (b c) (b c)
02:17:20 <ivanm> mmorrow: are you bored or something?
02:18:10 <mmorrow> ivanm: i'm trying to see if it's just a fluke or not that djinn chose that possibility
02:18:17 <ivanm> ahhh
02:18:27 <mmorrow> (ruled out that djinn cares about names of tyvars)
02:18:51 <mmorrow> ohh
02:19:06 <mmorrow> err
02:19:45 <mmorrow> @djinn (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d
02:19:46 <lambdabot> f a b c d = a (b d) (c d)
02:20:25 * mmorrow gets the djinn code
02:22:23 <mmorrow> @pl \a b c d -> a (b d) (c d)
02:22:24 <lambdabot> liftM2
02:23:09 <mmorrow> @djinn (s -> s -> c) -> (a -> s) -> (b -> s) -> a -> b -> c
02:23:10 <lambdabot> f a b c d e = a (b d) (c e)
02:24:11 <mmorrow> @pl \a b c d e -> a (b d) (c e)
02:24:11 <lambdabot> ((flip . ((.) .)) .) . (.)
02:24:21 <Axman6> obviously
02:24:24 <mmorrow> heh
02:24:32 <Axman6> :P
02:24:42 <mmorrow> @djinn (s -> s -> c) -> (a -> s) -> (b -> s) -> (a,b) -> c
02:24:43 <lambdabot> f a b c (d, e) = a (b d) (c e)
02:24:51 <mmorrow> @pl \a b c (d, e) -> a (b d) (c e)
02:24:52 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .) . flip . ((.) .)) .) . (.)
02:24:55 <mmorrow> arghh
02:25:26 <Axman6> as von neumann said: "Premature pointfree optimisation is the root of all evil"
02:25:46 <solrize> flip flip ... ?
02:25:51 <trofi> :]
02:25:54 <trofi> :t flip
02:25:55 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:26:02 <Saizan> ?type flip flip
02:26:03 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
02:26:04 * Axman6 doesn't care if that's a bastardised, misattributted quote
02:26:13 <Saizan> ?type flip flip flip
02:26:14 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
02:26:21 <Axman6> > flip flip flip flip
02:26:22 <lambdabot>       Overlapping instances for Show
02:26:22 <lambdabot>                                  ((a -> ...
02:26:29 <Axman6> :t flip flip flip flip
02:26:30 <lambdabot> forall a b c a1 c1. (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
02:26:42 <Axman6> @djinn (a1 -> ((a -> b -> c) -> b -> a -> c) -> c1) -> a1 -> c1
02:26:42 <lambdabot> f a b = a b (\ c d e -> c e d)
02:26:58 <Saizan> @pl f a b = a b (\ c d e -> c e d)
02:26:59 <lambdabot> f = flip flip flip
02:27:41 <Axman6> hmm, docs.python.org down for anyone else?
02:27:55 <nlogax> works here
02:28:06 <Axman6> hmmm
02:28:25 <nlogax> but http://downforeveryoneorjustme.com/docs.python.com says it's not just you :o
02:28:48 * Axman6 can never remember the name of that site
02:28:57 <trofi> you are not alone :]
02:29:04 <mmorrow> flip . (flip .) is actually really handy
02:29:12 <mmorrow> @let flop = flip . (flip .)
02:29:14 <lambdabot>  Defined.
02:29:25 <Axman6> :t flop
02:29:26 <lambdabot> forall a1 a b c. (a1 -> a -> b -> c) -> b -> a1 -> a -> c
02:29:40 <mmorrow> , foldl 0 [0..9] (\x y -> x+y)
02:29:41 <lunabot>  luna: The lambda expression `\ x y -> x GHC.Num.+ y' has two arguments,
02:29:43 <mmorrow> , flop foldl 0 [0..9] (\x y -> x+y)
02:29:45 <lunabot>  luna: Not in scope: `flop'
02:29:48 <mmorrow> > flop foldl 0 [0..9] (\x y -> x+y)
02:29:49 <lambdabot>   Couldn't match expected type `a -> b -> a'
02:29:53 <mmorrow> so used to hitting ,
02:29:59 <mmorrow> > (flop foldl) 0 [0..9] (\x y -> x+y)
02:30:01 <lambdabot>   Couldn't match expected type `a -> b -> a'
02:30:03 <mmorrow> grr
02:30:16 <mmorrow> > (flop foldl) [0..9] 0 (\x y -> x+y)
02:30:16 <Saizan> the list goes first
02:30:17 <lambdabot>       Overlapping instances for Show (a -> a -> a)
02:30:17 <lambdabot>        arising from a use ...
02:30:22 <mmorrow> > flop foldl [0..9] 0 (\x y -> x+y)
02:30:23 <lambdabot>       Overlapping instances for Show (a -> a -> a)
02:30:23 <lambdabot>        arising from a use ...
02:30:26 <mmorrow> wut
02:30:34 <trofi> [:
02:30:38 <Saizan> > flop foldl [0..9] (\x y -> x+y) 0
02:30:40 <lambdabot>   45
02:30:40 * mmorrow cries
02:30:49 <trofi> :t (flop.flop)
02:30:51 <mmorrow> oh snap, i messed up flop
02:30:51 <lambdabot> forall a1 a b c. (a1 -> a -> b -> c) -> a -> b -> a1 -> c
02:31:00 <Saizan> "is actually really handy" :)
02:31:11 <mmorrow> my memory fails me
02:31:51 <mmorrow> @pl \f a b c -> flip (flip f a) b c
02:31:52 <lambdabot> (flip .) . flip
02:32:08 <mmorrow> let flop = flip . (flip .)   {- doh -}
02:32:37 <mmorrow> @let flap = (flip .) . flip
02:32:39 <lambdabot>  Defined.
02:33:00 <mmorrow> > flap foldl 0 [0..9] (\x y -> x+y)
02:33:01 <lambdabot>   45
02:33:11 <mmorrow> for when you have long lambdas
02:33:34 <ivanm> mmorrow: who's going around stretching lambdas horizontally?
02:33:43 <mmorrow> i do:
02:33:57 <mmorrow> flap foldl z xs (\x y ->
02:34:00 <mmorrow>   ............
02:34:23 <mmorrow> GOTO LINE+1
02:34:46 * Axman6 waits for velociraptors to attack mmorrow 
02:34:51 <mmorrow> or starting the lamdaba on the next line
02:36:48 <trofi> $ would destroy trailing bracket
02:38:25 <mmorrow> i like the parens for lambda-guts-retension, personally
02:38:36 <mmorrow> i used to like it the opposite way though..
02:44:25 <dan> I'm getting an internal error in ghci-6.10.3 when using the array package :(
02:44:37 <dan> 6.10.2 works fine...
02:44:54 <mmorrow> what's the msg?
02:44:56 <ivanm> what kind of error?
02:45:10 <ivanm> AFAIK, 6.10.3 was just a bugfix
02:45:21 <ivanm> though they didn't fix the ghc-pkg bug :@
02:45:21 <dan> *Test Data.Array> a
02:45:21 <dan> Loading package syb ... linking ... done.
02:45:21 <dan> Loading package array-0.2.0.0 ... <interactive>: internal error: loadObj: error whilst reading `C:\ghc\GHC-61~1.3\array-0.2.0.0\HSarray-0.2.0.0.o'
02:45:21 <dan>     (GHC version 6.10.3 for i386_unknown_mingw32)
02:45:22 <dan>     Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
02:45:53 <dan> and the code is just
02:45:54 <ivanm> :o
02:45:59 <dan> module Test where
02:45:59 <dan> import Data.Array
02:45:59 <dan> a="foobar"
02:45:59 <dan>    
02:46:00 <dan>   
02:46:20 <trofi> HSarray looks broken
02:46:53 <ivanm> dan: ummm.... so a is a String?
02:47:02 <dan> yup
02:47:05 * ivanm fails to see why array is complaining...
02:47:12 <ivanm> maybe a dodgy windows build?
02:47:18 <dan> it can also be a numbee whatever
02:47:35 <dan> i just can't do the import from a ghc file (works fine from an interactive shell)
02:47:50 <Axman6> cabal install --reinstall hsarray?
02:47:59 <dan> ill try that
02:48:18 <ivanm> Axman6: isn't it just array? not hsarray?
02:48:26 <Axman6> no idea
02:50:04 <mmorrow> @let assocl (a,(b,c)) = ((a,b),c)
02:50:05 <lambdabot>  Defined.
02:50:13 <mmorrow> @let assocr ((a,b),c) = (a,(b,c))
02:50:14 <lambdabot>  Defined.
02:50:22 <mmorrow> @let swap = uncurry (flip (,))
02:50:23 <lambdabot>  <local>:9:0:
02:50:23 <lambdabot>      Multiple declarations of `L.swap'
02:50:23 <lambdabot>      Declared at: <local...
02:50:41 <mmorrow> @let swop = uncurry (flip (,))
02:50:42 <lambdabot>  Defined.
02:50:59 <mmorrow> @type assocl . swap . assocr
02:51:01 <lambdabot> forall t1 t2 t11 t21. (((t1, t2), t11), t21) -> (((t11, t21), t1), t2)
02:51:10 <mmorrow> @type assocl . swop . assocr
02:51:11 <lambdabot> forall t1 t2 t11 t21. (((t1, t2), t11), t21) -> (((t11, t21), t1), t2)
02:51:34 <mmorrow> oh
02:52:00 <mmorrow> @type assocr . first swop . assocl
02:52:01 <lambdabot> forall t t1 t2. (t, (t1, t2)) -> (t1, (t, t2))
02:52:13 <mmorrow> @type assocl . second swop . assocr
02:52:15 <lambdabot> forall t t1 t2. ((t, t1), t2) -> ((t, t2), t1)
02:54:16 * mmorrow is writing all the helpers that he duplicates over and over again down in a single module for good
02:54:24 <trofi> :]
02:54:40 <trofi> arg-permutator
02:55:07 <mmorrow> handay for => Map a (Map b c) -> Map b (Map a c)
02:55:57 <mmorrow> well, Map a (Map b (Set c)) -> Map b (Map a (Set c))
02:56:12 <mmorrow> in general so you don't lose any
02:57:16 <dan> well, seems the problem is with my HD
02:57:27 <dan> getting a device IO error when trying to read the array package
02:57:30 <dan> :/
02:57:53 <dan> so haskell is not broken but computers are
02:57:57 <trofi> екн ысфтвшыл ше
02:58:04 <trofi> try scandis drive
02:58:23 <mmorrow> @let gather (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty
02:58:24 <lambdabot>  Defined.
02:58:46 <trofi> it might be not a hardware problem, but improperly shutdown system
02:59:21 <dan> if i reboot and still can't access the file, it means it's a hardware problem - right?
02:59:34 <dan> after the usual scandisk
03:00:25 <trofi> can't access means you can't copy it or get garbage when copy it?
03:00:32 <dan> can't copy it
03:00:59 <trofi> yes, it may be HW problem
03:01:02 <dan> trofi: you mean chkdsk, right?
03:01:41 <mm_freak_> say i'm storing a lot of ByteStrings, if they are in NF, does it matter whether my ByteStrings are lazy?
03:01:48 <trofi> scandisk. you can chose scan your disk after reboot
03:02:05 <mm_freak_> i recall that lazy ByteStrings are just a list of fixed-size strict ByteStrings
03:03:31 * RayNbow is completely baffled why he cannot visit http://research.microsoft.com/en-us/people/simonpj/ at home in certain circumstances...
03:03:49 <Twey> RayNbow: What happens?
03:03:55 <RayNbow> timeouts
03:04:03 <RayNbow> but here's the most puzzling aspect
03:04:06 <RayNbow> not working: XP/IE7, XP/FF3, ArchLinux/FF3
03:04:13 <Twey> Hmn
03:04:31 <RayNbow> working: XP/FF3+university proxy, XP/Opera, XP/Lynx, XP/wget, ArchLinux/Lynx, ArchLinux/wget
03:04:41 <Taejo> RayNbow: I seem to be having trouble on Ubuntu/FF3
03:04:42 <RayNbow> ^ this is what I just don't seem to get
03:05:01 <bremner> RayNbow: I think it is a network issue from what I remember...
03:05:32 <RayNbow> bremner: but how could it be a network issue if it works in a different browser?
03:06:36 <bremner> umm. good point. OK, well, I have had intermittent trouble with that site, not sure about browsers, I mostly use konqueror
03:06:54 <RayNbow> on the other hand, you could be right though
03:07:08 <RayNbow> last evening I spied on my network traffic using Wireshark
03:07:25 <RayNbow> I did notice a lot of TCP retransmissions when I tried to access MSResearch
03:34:21 <mux> @seen dons
03:34:21 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 21m 34s ago.
03:36:58 <eu-prleu-peupeu> something to think about: http://en.wikipedia.org/wiki/C%2B%2B0x#Type_inference
03:54:47 <mmorrow> @pl \g f k -> k (g . f)
03:54:47 <lambdabot> (flip id .) . (.)
04:01:09 <wraithan> Sup, I am back
04:03:03 <u_quark> what is the best way to make an Array an instance of Arbitrary in QuickCheck ?
04:03:46 <Botje> cheat off the List instance?
04:06:35 <mm_freak_> haskell.org has had far too many downtimes recently
04:06:57 <mm_freak_> ok, it's not down, but it takes it forever to respond
04:07:23 <Axman6> u_quark: elements?
04:07:56 <u_quark> so there is no good way to do this using only the API of QuickCheck ?
04:08:48 <u_quark> Axman6: elements ?? how ?
04:08:49 <Botje> didn't i just tell you how you could do it ?
04:08:59 <Botje> take the List instance and modify it a bit
04:09:13 <Axman6> yeah, use elements to just use the list instance
04:09:16 <Botje> it already has support for random lengths
04:09:21 <u_quark> yes :) just asking ...
04:09:47 <Botje> if you're really lazy you can just do arbitrary = fromList `fmap` arbitrary
04:09:52 <Axman6> hmm, think i may have mis understood the question
04:09:59 <Botje> where fromList :: [a] -> Array i a
04:10:10 <Saizan> i don't see the problem with that approach :)
04:10:27 <Saizan> you're going to build the array with listArray or similar anyhow
04:12:56 <u_quark> ok tnx all
04:27:00 <Pellwurst> is there an easy way to get the current time/date (formatted)?
04:27:36 <Wraithan> :i Data.Info
04:27:38 <ivanm> there is, but it will be formatted according to the American system IIRC
04:27:39 <Wraithan> :i Data.Time
04:27:52 <ivanm> Wraithan: I don't think lambdabot recognises :i
04:27:58 <Wraithan> Ah
04:28:07 <ivanm> Pellwurst: either in Data.Time or System.Time, something like that
04:28:16 <Pellwurst> k, thx
04:28:30 <Wraithan> System.Time is deprecated or that is what I read when I was looking for time stuff, Data.Time is what you want
04:28:45 <Wraithan> And you can choose how to format it using Data.Time.Format
04:29:25 <ivanm> Pellwurst: have a look at the "today" function here: http://code.haskell.org/Graphalyze/Data/Graph/Analysis/Reporting.hs
04:30:28 <ivanm> Wraithan: or else System.Locale's stuff for formatting
04:42:01 * mux does some more cleanup to System.BSD.Sysctl before uploading it to hackage
04:42:34 <xian> Sorry for this newbie'ish question, but what's Haskell's equivalent of Lisp's remove-duplicates? (A quick Google search didn't turn up anything useful)
04:42:45 <mauke> sounds like nub
04:42:52 <byorgey> > nub [1,2,3,2,4,4,1,2]
04:42:54 <lambdabot>   [1,2,3,4]
04:43:01 <Pellwurst> ivanm: how can i install the Data.Time package? i cant import it.
04:43:07 <xian> Great, thanks.
04:43:31 <ivanm> Pellwurst: I think it's the time package on hackage
04:43:40 <ivanm> System.Time is old-time, right?
04:43:57 <Baughn_> xian: Note that nub is kind of slow (it has to be) on large lists. Set.toList . Set.fromList is faster. For large lists.
04:44:28 <Baughn_> xian: (However, nub maintains order; Set sorts them)
04:45:01 <mauke> :t mapAccumL
04:45:02 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:46:39 <Saizan_> nub is lazier
04:48:37 <mauke> > snd . foldl (\z@(s, xs) x -> if x `S.member` s then z else (S.insert x s, x : xs)) (S.empty, []) $ "foo bar baz"
04:48:38 <lambdabot>   /tmp/8484947192528556890:70:66: Not in scope: `S.member'/tmp/84849471925285...
04:48:49 <mauke> :t S.member
04:48:50 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
04:48:51 <mauke> what
04:49:17 <Botje> > S.member
04:49:18 <lambdabot>       Overlapping instances for Show (a -> S.Set a -> Bool)
04:49:18 <lambdabot>        arising fr...
04:49:26 <Botje> it does know it
04:49:52 <Botje> > S.member undefined S.empty
04:49:52 <mauke> > S.empty
04:49:54 <lambdabot>   /tmp/2755912368993524889:70:32: Not in scope: `S.member'/tmp/27559123689935...
04:49:54 <lambdabot>   /tmp/984034499413416886:70:32: Not in scope: `S.empty'
04:50:04 <Botje> weeiiiird
04:50:05 <mux> mmmm, adding a directory to Data-Dir in a cabal file doesn't seem to be enough to have cabal sdist put this directory in the tarball
04:55:17 <mux> alright, Data-Files is enough
05:09:26 <dcoutts> mux: data-dir is to say where data files are looked for, so that it's not just relative to $top
05:09:59 <dcoutts> eg so you can organise your build tree like $top/src/ and $top/data/
05:13:23 <mux> dcoutts: ah, okay, thanks
05:13:38 * mux just uploaded bsd-sysctl-1.0.0 on hackage
05:18:01 <jaj> mux: hey cool!
05:18:54 <jaj> this can be used to get battery information in xmobar for example
05:19:16 * mux nods
05:19:22 <mux> jaj: are you running OpenBSD?
05:19:25 <jaj> mux: yeah
05:19:47 <mux> jaj: I think the package wouldn't build there, because OpenBSD seems to lack both sysctlbyname() and sysctlnametomib()
05:20:05 <jaj> true
05:20:09 <mux> I'll probably have to #ifdef some code so that it still builds without name lookup
05:20:18 <mux> (should be pretty easy)
05:20:44 <mux> if you check out the demo program included in the example, you'll see how easy and cool it is to get the list of process from a sysctl ;-)
05:20:52 <mux> s/example/tarball/
05:21:20 <jaj> by the way I just finished a ghc-6.10.3 port for openbsd: http://www.hcl-club.lu/~jaj/ports/tgz/
05:21:24 <jaj> I'm currently testing it
05:21:51 <mux> the FreeBSD haskell ports are in a sorry state unfortunately
05:22:04 <jaj> mux: on openbsd it's worse ;)
05:22:19 <mux> heh, but we are real men anyways, we build via source :-P
05:23:00 <jaj> mux: my P4 does not agree
05:23:06 <NEEDMOAR> Haha.
05:23:17 <mux> I recently switched from an ooold athlon box to a core i7 one :-)
05:23:24 <NEEDMOAR> I'm tired of broken ports :-(
05:23:27 <mux> needless to say, it builds faster than hell
05:25:02 <mux> anyone running NetBSD? this package _should_ build fine there
05:25:04 <jaj> I'll have to dig into sysctl(8) under openbsd to see how it does lookups
05:25:20 <mux> jaj: via the "old" way only, an array of integers
05:25:31 <mux> I just have to disable some part of my code for the module to build on OpenBSD
05:25:32 <burp_> jaj, awesome, but just x86, right?
05:25:49 <mux> if you want to do it and send me a patch that'd be nice :-)
05:25:53 <jaj> burp_: currently building on amd64
05:25:59 <burp_> ok, I got openbsd on macppc
05:26:37 * mux wonders if he'll be able to have dons rewrite cpuperf using this module
05:26:40 <jaj> burp_: hmm that won't work :)
05:26:45 <burp_> yup :(
05:27:37 <jaj> burp_: it uses ghc-6.6.1 to bootstrap 6.10.3 and I don't know whether 6.6.1 in ports will build on macppc. I don't have a macppc machine myself
05:28:10 * mux patiently waits for the haddock documentation to get generated
05:28:11 <jaj> burp_: you could give it a try
05:29:01 <jaj> burp_: comment out ONLY_FOR_ARCHS and see how far you can get
05:29:16 <burp_> guess not far ;)
05:29:57 <jaj> is macppc officially supported by ghc?
05:30:49 <burp_> ghc works with os x macppc
05:31:50 <jaj> you'd probably have to generate .hc files for ghc-6.6
05:32:48 * koeien has written an MD6 implementation, wee
05:33:08 <mux> koeien: did you use Cryptol? :)
05:33:17 <koeien> mux: no
05:36:26 <koeien> it's not particularly efficient btw
05:39:09 <dibblego> is join . repeat in the standard libraries?
05:39:32 <Baughn_> @type join . repeat
05:39:33 <lambdabot> forall a. [a] -> [a]
05:39:34 <mauke> :t cycle
05:39:35 <lambdabot> forall a. [a] -> [a]
05:39:35 <koeien> cycle
05:39:42 <dibblego> ah yeah ta
05:47:38 <Botje> what does join . repeat do ?
05:47:43 <Berengal> Botje: cycle
05:47:53 <Botje> obviously :P
05:48:08 <Botje> oh, repeat [a] generates [[a]]
05:48:13 <Botje> and join is concat
05:48:16 <Botje> i get it :)
05:48:17 <Botje> carry on!
05:48:28 * Berengal carries on
05:48:46 <Botje> whee, overflow ;)
05:49:40 <stroan> You when create an array from a list. Is the whole list evaluated then and there?
05:50:04 <stroan> Just trying to figure out how arrays get O(1) access time
05:50:09 <Berengal> stroan: Only the spine and the indexes
05:50:54 <stroan> ok, makes sense.
05:57:11 <Angel> What would you recommend for a basic Haskell editor/IDE? I've seen EclipseFP and leskah so far but they're a bit overkill for my needs (syntax highlighting, quick access to the interpreter and such) Thanks :)
05:57:20 <ivanm> emacs
05:57:28 <ivanm> or vim, if you swing that way
05:58:15 <Philippa> Angel: anything with highlighting and a console tab
05:58:26 <Philippa> what platform're you on?
05:59:06 <Angel> I'd heard of Emacs but it sounded on the heavy side... let me have a look then. I'm on Linux by the way
05:59:19 <jaj> haddock: out of memory (requested 1048576 bytes)
05:59:27 <jaj> there goes the amd64 build :(
05:59:30 <p_l> Emacs is not heavy nowadays. Especially if you're comparing with Eclipse :D
05:59:45 <david_> hmm, is there built in reg exp in haskell?
06:00:01 <Philippa> Angel: gedit, jedit, kate...
06:00:54 <david_> and with built-in I mean bundled with ghc
06:01:20 <Philippa> Text.Regex.* or similar?
06:01:25 <pejo> "Eight Megs And Constantly Swapping"
06:01:29 <mux> david_: yes, you have Text.Regex.* in the regex-* packages that are builtin GHC
06:02:01 <Philippa> pejo: yeah, well. I expect any good-for-modern-machines environment to do that
06:02:02 <ivanm> pejo: yes, but most computers have much more than 8 MB of RAM available nowadays...
06:02:53 <david_> thanks
06:15:46 <mwoehrle> /?
06:16:06 <mauke> ¿\
06:17:07 <Eelis> heh, i see utf8-string is unlikely to be in the platform. so much for "batteries included"
06:19:21 <mhaggag> Hello, I'm a haskell newbie going through "Real World Haskell". I'm at Chapter 4, where I implement a function asInt_either which converts a string to an integer or produces an error string (using Either String Int).
06:19:35 <mhaggag> I have an implementation here: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2436#a2436
06:19:51 <mhaggag> I was wondering if there was a better way to "format" the error message? A la printf.
06:19:58 <mhaggag> (Line 12 in the above paste)
06:20:12 <mauke> well, you could use printf
06:20:18 <Botje> as a matter of fact, there _is_ a Text.Printf
06:20:19 <mhaggag> :D
06:20:24 <Botje> but it's a bit weird to use, so be warned ;)
06:20:33 <Saizan_> Eelis: you can propose it for the next version :)
06:20:34 <mux> and can fail at runtime
06:20:35 <mhaggag> Cool, didn't know that. Can you give me a quick example?
06:20:52 <mauke> Left (printf "non-digit encountered '%c'" x)
06:20:55 <Eelis> Saizan_: it was, and the proposal is getting negative comments
06:20:56 <mux> > printf "%.*s" 3 "foobar"
06:20:57 <lambdabot>   Add a type signature
06:21:02 <mux> > printf "%.*s" 3 "foobar" :: String
06:21:03 <lambdabot>   "* Exception: Printf.printf: bad formatting char *
06:21:11 <mux> pft :)
06:21:19 <mauke> mux: get printf-mauke instead
06:21:23 <mauke> it's fixed there
06:21:27 <mux> I've _used_ this in the past
06:21:38 <mux> that was for a %.*f though
06:21:57 <mhaggag> Interesting. On a sidenote, RWH mentions early on that Haskell's type system makes it difficult to write variadic functions. Isn't printf such a function?
06:21:59 <mux> mauke: why isn't your fix merged to Text.Printf ?
06:22:14 <mauke> mux: ask the maintainer
06:22:19 <mux> mhaggag: yes, it uses advanced type-class hackery to make this work
06:22:23 <mux> mauke: I see :-)
06:22:53 <mauke> I found and fixed a few bugs in printf, then wrote a bug report
06:23:11 <mhaggag> mux, oh I see. So it's not impossible, but difficult. Does it involve half-assed hacks a la C++ pseudo-variadic templates? (i.e. essentially writing the template for N possible parameters)
06:23:14 <mauke> after a few months of inactivity I released my own printf
06:23:30 <mux> mhaggag: no, it involves making function types instances of the class
06:23:52 <mwoehrle> hey everyvody! anybody knows how to do a "pause for x milliseconds"-step in an io-do-sequence?
06:24:05 <mauke> :t threadDelay
06:24:06 <lambdabot> Not in scope: `threadDelay'
06:24:14 <mhaggag> mux: that went right over my head :D I guess I'll get to it when I get to it, but I'm relieved to know that it's not a hack. The type system is growing on me, so I was kinda weary when I hit that warning in RWH
06:24:14 <mux> mauke: I read a paper about a new printf implementation using ATs
06:24:29 <trofi> hoogle delay
06:24:40 <mux> mhaggag: the type system always has a few tricks up its sleeves :)
06:24:50 <mauke> mhaggag: http://okmij.org/ftp/Haskell/types.html#polyvar-fn (teehee)
06:25:06 <mux> *beware* of okmij.org links
06:25:15 <mux> it makes haskell beginners' brains melt
06:25:29 <Botje> s/beginners'//
06:25:32 <mmorrow> preflex: seen rwbarton
06:25:32 <preflex>  Sorry, I haven't seen rwbarton
06:25:40 <mmorrow> @seen rwbarton
06:25:41 <lambdabot> Last time I saw rwbarton was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #
06:25:41 <lambdabot> haskell, #haskell-blah, #haskell-books, #haskell-freebsd, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #
06:25:41 <lambdabot> haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 3m 25d 7h 54m 47s ago,
06:25:41 <lambdabot> and .
06:25:42 <mwoehrle> thanks, mauke, that looks good!
06:27:06 <mhaggag> mauke: Oy! Didn't know Oleg did  haskell. I've visited that page tons of times, but never noticed :O
06:27:25 <mauke> haha
06:28:01 <mauke> where do you know him from?
06:28:22 <mhaggag> reddit.com/r/programming. People link to him often.
06:28:42 <mux> heh, no wonder
06:29:03 <povman> Am I an inherently bad person if I start my program with {-# LANGUAGE ExistentialQuantification #-} ?
06:29:09 <povman> I feel like I'm breaking the rules.
06:29:47 <mux> well, look at the number of LANGUAGE directives in Oleg sources :-)
06:30:00 <mmorrow> mauke: if you ever get the desire for a TH printf , here's (a minimal/compact/copy-pasteable) one that i've been meaning to add formats to for a while (see `parse') http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=1929#a1930
06:30:27 <povman> I guess the real question is: will existential quantification be on by default in the next revision of Haskell?
06:30:56 <mmorrow> , $(printf "%s %d %d") "omg" 42
06:31:00 <lunabot>  luna: No instance for (GHC.Show.Show (a[a78e] -> GHC.Base.String))
06:31:02 <mux> povman: this is very likely
06:31:34 <mux> but I thought one only needed Rank2Types
06:31:59 <mmorrow> > printf "%s %d %d" "omg" 42 :: String
06:32:01 <lambdabot>   "omg 42 * Exception: Printf.printf: argument list ended prematurely
06:37:42 <naxa> hi folks! Can someone help me, what's wrong with "take (2^400) [n | n <- [1..], n `mod`7==0 ]" ?
06:37:59 <mauke> 2^400 doesn't fit in an Int
06:38:12 <mmorrow> , 2^400
06:38:12 <mux> try genericTake
06:38:14 <lunabot>  2582249878086908589655919172003011874329705792829223512830659356540647622...
06:38:17 <mmorrow> lol
06:38:22 <naxa> thanks :)
06:38:25 <mux> or maybe take less things :p
06:38:38 <mmorrow> or just take infinitely many
06:38:39 <voker57_> yeah, don't be greedy
06:39:06 <mauke> [ n * 7 | n <- [1 .. 2^400] ]
06:39:19 <naxa> actually I just wanted to have a nice day watching how Haskell does all the previously impossible work
06:39:31 <mmorrow> > (2^400) `div` (fromIntegral (maxBound::Int))
06:39:33 <lambdabot>   279968092772225526350034486512082551501613288563091086863452994768954854897...
06:39:45 <mauke> > [7, 14 .. 7 * 2^400]
06:39:46 <lambdabot>   [7,14,21,28,35,42,49,56,63,70,77,84,91,98,105,112,119,126,133,140,147,154,1...
06:40:15 <naxa> hey guys thanks! :)
06:47:41 <mhaggag> Can you guys help me understand ghc's following error better: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2437#a2437
06:48:01 <mhaggag> It took me a while to figure out the problem, but I'm trying to understand why ghc reports the error that way
06:48:54 <mhaggag> Why is it "constructing an infinite type a = [a]" when I pass in an element instead of a list to ++?
06:49:15 <skorpan> :t (++)
06:49:18 <lambdabot> forall a. [a] -> [a] -> [a]
06:49:25 <skorpan> hm...
06:49:44 <mauke> the arguments of ++ have the same type, therefore typeof(acc) == typeof(x)
06:50:10 <mhaggag> skorpan: A bit of context: I'm a newbie going through real-world haskell, so the :type information just printed doesn't make any sense to me :O
06:50:18 <mauke> takeWhile returns the result of helper, which is acc. therefore typeof(acc) == [a]
06:50:33 <skorpan> mhaggag: the type information *should* make sense to you... [a] is a list of any type a
06:50:34 <Saizan_> and only [[[..]]] ad infinitum will satisfy a = [a]
06:50:59 <mauke> you're calling pred x and pred takes 'a', so typeof(x) == a
06:51:02 <mhaggag> skorpan: I get that part. I'm not sure what the "forall a." part is.
06:51:09 <mauke> together this means that [a] == a
06:51:42 <kpreid> mhaggag: don't worry about that part yet
06:51:51 <mhaggag> mauke: Ah, so during type unification it tries to construct a type that satisfies [a] == a which is impossible?
06:52:00 <mauke> yes
06:52:44 <mauke> the occurs check disallows unifying a variable x with another type containing x
06:52:52 <skorpan> mhaggag: for the time being just know that "forall a." is implied when you write "[a] -> [a] -> [a]" or anything with an "a" in it.  there are exceptions, but meh...
06:53:33 <mhaggag> mauke: That makes it much clearer, thanks. I was somewhat confused by the 'constructing a type' part of the error, but now I see where it's coming from.
06:54:26 <mhaggag> skorpan: I see.
06:54:34 <tetha> skorpan: are there types with exists a.? (I'm just comparing this to quantifiers I know)
06:55:01 <skorpan> tetha: not in the same way, afaik
06:55:15 <skorpan> (i'm no expert!)
06:57:48 <mhaggag> So, in the error message, why doesn't the compiler point out the offending expression explicitly? It seems to do this often to me, and I find it very helpful. (I realize this is a bit of a compiler/implementation detail)
06:57:54 <vixey> exists doesn't exist
06:58:07 <vixey> well EHC has it
06:58:29 <skorpan> if i have "data A = A Int | B String", would you refer to "A Int" as a constructor or just "A"?
06:58:39 <mauke> mhaggag: there is no single offending expression
06:58:48 <mauke> skorpan: just A
07:00:06 <mhaggag> mauke: Hmm...isn't the infinite type construction attempt occur during inferring the expression (acc ++ x)?
07:00:17 <mhaggag> occurring*
07:00:35 <mauke> no, that just makes typeof(acc) == typeof(x)
07:00:41 <mhaggag> Oh, right
07:00:57 <mhaggag> The typeof(acc) is inferred from takeWhile itself
07:01:16 <mhaggag> which is why the whole thing is flagged, because the problem could be on either side: acc or x
07:12:02 <stroan> hmm, when the docs told me to go make a cup of tea while wxHaskell builds, they were giving sound advice :P
07:13:13 <mauke> mhaggag: so I looked at your function again with my brain enabled ... why are you using a helper function/accumulator?
07:13:55 <mauke> takeWhile pred (x : xs) | pred x = x : takeWhile pred xs; takeWhile _ _ = []
07:13:56 <mhaggag> mauke: Let me take a look at it again. I have this habit of defaulting to an accumulator from when I started learning functional programming in scheme.
07:14:20 <mauke> accumulators are a bad idea because they lead to tail recursion :-)
07:14:41 <mhaggag> ..is that a bad thing?
07:14:48 <mauke> in this case, yes
07:15:11 <mauke> > takeWhile (\_ -> True) [1 ..]
07:15:12 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:15:21 <mauke> consider infinite lists
07:19:02 * mhaggag smacks forehead
07:19:12 <mhaggag> Man, I guess laziness still hasn't sunk in
07:19:52 <mhaggag> But if I write my functions in a non-tail-recursive way, is the compiler still able to transform them automatically into loops?
07:19:58 <mauke> > foldr (\x _ -> x) (error "head: empty list") [1,2,3]
07:20:00 <lambdabot>   1
07:20:03 <mauke> > foldr (\x _ -> x) (error "head: empty list") []
07:20:04 <lambdabot>   * Exception: head: empty list
07:20:49 <mauke> I don't think it has to
07:21:13 <mauke> laziness transposes control flow
07:22:10 <mhaggag> Well, I guess it's a case of me carrying assumptions over from other languages over to haskell when I still haven't grokked it yet. In strict languages tail-recursion was essential to produce tight code that wouldn't stack overflow. I guess that doesn't readily apply in haskell? (at least not directly)
07:23:07 <mhaggag> So when would I write a tail-recursive implementation in haskell? (I realize that's rather vague..but I'm certain I've seen a couple of tail-recursive implementations so far in RWH)
07:23:37 <mauke> when it makes sense :-)
07:23:47 <mauke> @src foldl
07:23:47 <lambdabot> foldl f z []     = z
07:23:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:23:59 <mauke> this foldl can actually cause stack overflows
07:24:24 <mhaggag> Oh, this is the Prelude one right? The one that can overflow the thunk evaluation/storage/execution stack? (Still vague on the whole notion of thunks..)
07:24:27 <EvilTerran> > foldl (+) 0 [1..10^9]
07:24:58 <Astro> @hoogle ByteString -> [Word64]
07:25:08 <Astro> !hoogle ByteString -> [Word64]
07:25:10 <lambdabot>   mueval: Prelude.read: no parse
07:25:10 <lambdabot> Data.ByteString zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
07:25:10 <lambdabot> Data.ByteString.Lazy zipWith :: (Word8 -> Word8 -> a) -> ByteString -> ByteString -> [a]
07:25:10 <lambdabot> Data.ByteString.Char8 zipWith :: (Char -> Char -> a) -> ByteString -> ByteString -> [a]
07:27:36 <mhaggag> So, to conclude: In Haskell, one doesn't write tail-recursive code unless the problem itself translates well into tail-recursive code? As in, don't use tail-recursion as a looping construct (a la Scheme)
07:28:25 <mauke> I think so
07:28:28 <vixey> mhaggag: if you want to write scheme style tail recursive code you can do that (just insert ! everywhere), It's not a usual approach to programming in Haskell though
07:28:34 <mauke> our loops are lists, not tail recursion
07:28:35 <Berengal> mhaggag: Sure, you can use tail recursion, but it's more important to beware of how much recursion has to be done to create a constructor
07:29:09 <Berengal> foldl needs to recurse through the entire list. map only needs to recurse once
07:30:04 <Berengal> We do like lists though...
07:30:11 <mhaggag> Berengal: could you elaborate on the "...recursion to be done to create a constructor"?
07:30:25 <mauke> map f (x : xs) = f x : map f xs
07:30:33 <mauke> (:) is a constructor
07:31:05 <mhaggag> Oh, the list constructor. Was berengal referring to that specifically, or any type constructor in general?
07:31:10 <Berengal> Right, so reducing map f (x : xs) yields a constructor right away
07:31:13 <mauke> any data constructor
07:31:15 <Berengal> mhaggag: Any type of constructor
07:32:01 <mauke> when you force/evaluate a lazy value, it runs until it hits a constructor
07:32:23 <mauke> (that constructor can contain more lazy values but that doesn't matter)
07:32:25 <mhaggag> I'm trying to wrap my head around the notion of creating a constructor. I think I'm getting confused. We use constructors to create values. So what you mean by "creating a constructor" is..?
07:32:58 <Berengal> mhaggag: In this context we're talking about thunks producing values
07:33:00 <mauke> "create a constructed value" or something like that
07:33:10 <mauke> a fully applied constructor
07:33:53 <Berengal> Think of the graph reduction done by the runtime. Once it starts reducing a graph it does so until the top element is a constructor
07:34:12 <mauke> but I don't think in graphs!
07:34:31 <Berengal> mauke: Then get your own visualisation :P
07:34:39 <vixey> graph reduction 4 ever
07:34:40 <mhaggag> Well, I don't even know how graph reduction is done by the compiler yet so I'm not worried about that yet :)
07:35:01 <mhaggag> I think I'm starting to understand, though. So in the case of foldl vs map
07:35:19 <Berengal> mhaggag: Graph reduction is simply evaluating the AST
07:35:32 <vixey> mhaggag: instead of evaluating everything before applying (like eval/apply in scheme), we just keep trying to take this object into Weak Head Normal Form
07:36:06 <mhaggag> foldl has to go through the whole list before producing a constructor, whereas map can produce one item/constructor at a time? (the second part of my sentence sounds awful..)
07:36:14 <mauke> yes
07:36:40 <mhaggag> And this comes from the fact that foldl is tail-recursive, presumably?
07:36:43 <mauke> the outermost call in the definition of foldl is to foldl itself, so it won't stop until it hits the end
07:36:55 <vixey> to take  head (map (+1) [0..]) it WHNF, you take the 'map ...' bit to WHNF, which gives 1 : map (+1) [0..] then you take the head of that giving 1
07:36:55 <Berengal> It's not foldl's fault it causes stack overflows, it's the accumulator function's fault
07:36:56 <mauke> (outermost stuff is evaluated first)
07:37:11 <ski> `foldl' is a bulk operation, while `map' is incremental
07:37:12 <vixey> mhaggag: is that makeing sense so far ?
07:37:19 <mauke> the outermost call in map is to (:), which doesn't cause any further evaluation (on its own)
07:37:39 <mhaggag> vixey: Stay with me, I'm trying to grok what you're saying..one minute
07:38:15 <vixey> the reasons it's 'graph' reduction is because we can throw in things like  let x = 1 + 1 in x + x  it'll only have to take x to WHNF once
07:38:20 <Berengal> foldl (flip (:)) [] doesn't cause stack overflows
07:38:32 <vixey> > foldl (flip (:)) [] [1..]
07:38:43 <lambdabot>   mueval: Prelude.read: no parse
07:38:54 <opqdonut> Berengal: don't you mean foldr (:)...
07:39:11 <mauke> opqdonut: that doesn't reverse anything
07:39:20 <opqdonut> ah, you wanted to reverse the list
07:39:24 <Berengal> vixey: The foldl is done in constant space (TCO), reducing the accumulator is a lazy operation in this case
07:39:43 <mhaggag> vixey: I'm not sure I follow what you mean by WHNF. Can we backtrack to head (map (+1) [0 ..])?
07:39:55 <mhaggag> vixey: What does it mean to take the map bit to WHNF?
07:40:01 <Berengal> however, since the list is infinite it never gets to the reduction phase, so foldl is stuck in an infinite loop (in constant space)
07:40:55 <Berengal> mhaggag: map (+1) [0..] = (:) (0 + 1) (map (+1) [2..])
07:41:08 <Berengal> The evaluator sees the (:) comes first, and then stops
07:41:22 <Berengal> Because (:) is a constructor, and it's at the head
07:41:48 <Berengal> Any expression that starts with a constructor is in WHNF
07:41:53 <mhaggag> Oh, I see. The problem with the foldl was that we kept hitting the recursive foldl call before hitting a constructor, so it drilled down to the end.
07:42:08 <mhaggag> Whereas with a map we hit the : constructor right away, so we stop?
07:42:14 <ski> yes
07:42:59 <Berengal> mhaggag: Well, the foldl actaully runs in constant space (neverminding the accumulator thunk). It's when it comes to reducing the accumulator to WHNF we hit the stack limit
07:43:07 <Berengal> Because the accumulator isn't tail-recursive
07:43:41 <Berengal> I could say foldl runs in constant stack space since the thunk is on the heap... that would make it more correct...
07:44:36 <Berengal> Anyway, foldl (+) 0 [1,2,3,4,5] reduces to (1+(2+(3+(4+(5+0)))))
07:44:53 <mauke> > foldl (+) 0 [1,2,3,4,5] :: Expr
07:44:59 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
07:45:06 <mauke> REFUTED
07:45:12 <Berengal> There's still no constructor, and that last expression isn't tail-recursive
07:45:13 <opqdonut> :D
07:45:14 <mhaggag> Shouldn't that be: (((((0 + 1) + 2) + 3) + 4) + 5)
07:45:20 <mhaggag> ?
07:45:22 <mauke> yes
07:45:23 <Berengal> Pft, whatever :P
07:45:25 <ski> > foldr (+) 0 [1,2,3,4,5] :: Expr
07:45:27 <lambdabot>   1 + (2 + (3 + (4 + (5 + 0))))
07:45:37 * Berengal is too used to thinking in terms of foldr
07:45:56 <Berengal> Anyway, makes no difference. None of those expressions are tail-recursive
07:46:15 <ski> i'm not sure it make sense to ask whether they are tail-recursive or not
07:47:00 <Berengal> ski: Well, they aren't. foldl is, and it runs in constant stack space. It's the non-tail-recursiveness of the accumulators that make strict accumulators fail
07:47:12 <mhaggag> I'm somewhat struggling with the notion of the expressions being tail-recursive or not. It's just not clear in my head how the thunks are stored or evaluated.
07:47:14 <Berengal> > foldl (+) 0 [1..1000000]
07:47:17 <lambdabot>   * Exception: stack overflow
07:47:18 <mauke> I'd like to see a tail recursive thunk
07:47:31 <Berengal> > foldl (flip (:)) [] [1..1000000]
07:47:32 <skorpan> > sort [1..1000000
07:47:34 <skorpan> > sort [1..1000000]
07:47:34 <lambdabot>   <no location info>: parse error on input `;'
07:47:34 <lambdabot>   [1000000,999999,999998,999997,999996,999995,999994,999993,999992,999991,999...
07:47:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:47:38 <skorpan> > sort [1..10000000]
07:47:38 <ski> Berengal : i see no recursion in that expression, so how can it be tail-recursive, or for that matter, fail to be tail-recursive ? :)
07:47:58 <skorpan> how would you sort 10 million integers in haskell?
07:48:13 <mauke> with sort
07:48:28 <skorpan> i think i tried it and it jammed my RAM
07:48:41 <Berengal> ski: The accumulator doesn't recurse by itself, but one of its arguments is determined in terms of itself, which is close enough form e
07:49:27 <ski> i think you're still talking about what `foldl' does
07:49:47 <Berengal> ski: Yes, I am
07:50:36 <Berengal> Did we change topic?
07:50:39 <ski> so how can that be relevant to whether the expression that `foldl' produces can meaningfully be said to be tail-recursive or not
07:50:42 <ski> ?
07:50:56 <ski> i could enter that expression on my own, without calling `foldl'
07:51:10 <lambdabot>   thread killed
07:51:28 <ski> i'm just not seeing what you mean by "the accumulator isn't tail-recursive"
07:51:42 <mauke> skorpan: ./a.out  41.10s user 1.14s system 93% cpu 45.048 total
07:51:55 <Berengal> ski: What I mean by that is that reducing the accumulator to WHNF cannot be done in constant space
07:51:57 <Berengal> Assuming the accumulator isn't lazy
07:52:47 <Berengal> By accumulator I mean accumulator function
07:52:47 <ski> to me, "tail-recursiveness" is a property of a recursion
07:52:52 <skorpan> mauke: i'm sure it terminates at some point but the computer becomes completely unusable during the process due to the intense memory usage
07:52:59 <ski> i don't see what recursion you are talking about
07:53:09 <skorpan> so maybe i should rephrase my questoin.. how do you memory-efficiently sort 10 million integers in haskell?
07:53:23 <mauke> shell out to sort(1)
07:53:25 <ski> (since we've already established that the recursion in `foldl' itself is of the tail-recursive variety)
07:53:37 <skorpan> mauke: you know what i mean
07:53:44 <mauke> skorpan: what?
07:53:54 <skorpan> mauke: okay, imagine we don't have a shell
07:54:00 <Berengal> ski: I'm talking about repeatedly calling the accumulator function
07:54:14 <mauke> ok, maybe "shell out" wasn't the right words
07:54:24 <skorpan> imagine we don't have sort(1)
07:54:27 <ski> which is what `foldl' does
07:54:34 <skorpan> imagine we can't call an external program to do it
07:54:36 <mauke> skorpan: reimplement it
07:54:44 <ski> surely that must be a property of how `foldl' is defined, then ?
07:54:50 <skorpan> mauke: how would i reimplement sort(1) in haskell?  (geez!)
07:54:56 <ski> (as opposed to the accumulator function)
07:55:06 <Berengal> ski: Oh, are we talking about whose fault it is now?
07:55:13 <mauke> skorpan: I'm not sure how to answer that
07:55:19 <mauke> by writing code?
07:55:27 <Berengal> foldl or the accumulator function?
07:55:50 <skorpan> are you avoiding the question at hand or am i being that unclear mauke?
07:55:58 <ski> (Berengal : obviously i see what you are referring to when you say "the accumulator isn't tail-recursive" .. i just don't know how those words relate to what you intend)
07:56:24 <opqdonut> skorpan: "interact (unlines . sort. lines)" ?
07:56:43 <opqdonut> ah, you were interested in effectiveness
07:56:59 <skorpan> yes, memory effectiveness specifically
07:57:04 <opqdonut> mhmm
07:57:05 <Axman6> > length "agpheG1hbjZibG9ncg4LEghCbG9nUG9zdBgdDA"
07:57:09 <lambdabot>   38
07:57:14 <Berengal> ski: I've sort of lost track of which point I'm trying to make now.... At one point it was that while foldl is tail-recursive and runs in constant stack space, it's result cannot be reduced in constant stack unless it's lazy
07:57:15 <opqdonut> some sequence type that supports efficient splicing
07:57:19 <opqdonut> would probebly be the solution
07:57:25 <opqdonut> does Data.Sequence?
07:57:43 <ski> Berengal : in `foldl (+) 0 [1,2,3,4,5]', `(+)' is the accumulator function, i can use this function in other circumstances .. to me it would seem reasonable that if `(+)' (the accumulator, here) isn't tail-recursive, then that's a property that is independent on where `(+)' is used
07:57:53 <mauke> skorpan: what data structure do you use to store the integers?
07:58:02 <opqdonut> or of course, some STArray/IOArray solution might work
07:58:10 <opqdonut> mauke: that's the main variable here
07:58:11 <opqdonut> AIUI
07:58:32 <skorpan> mauke: any
07:58:46 <mauke> ok, use a mutable array and sort in-place
07:58:53 <skorpan> this isn't a specific problem i'm having, i'm just interested in understanding how it could be done
07:58:55 <ski> Berengal : sorry, i'm losing sight of the point as well. maybe suffice it to say that i thought your way of expression vague. ok ?
07:59:51 <Berengal> ski: Fair enough. How about "the result graph can/cannot be reduced in constant stack"?
08:00:01 <ski> sure
08:00:04 <Berengal> result graph of foldl in this case
08:00:20 <mhaggag> Is it possible to inspect the source of a function from ghci? (Similar to the @src you're doing on captain lambdabot here)
08:00:37 <mauke> mhaggag: no
08:00:50 <Berengal> mhaggag: No, but there's always :info which gives where it's defined
08:01:31 <mhaggag> :info is cool, I use it often. But @src is very nifty, especially at this stage where I'm reinveting lots of wheels to learn. Sometimes I end up with square ones, and I like to see how the round ones look like :)
08:02:06 <Berengal> mhaggag: Heh, all of us here have probably reinvented at least half the Prelude at some point
08:02:09 <vininim> hoogle
08:02:43 <mhaggag> vininim: Hot damn that is awesome! Thanks :)
08:03:19 <mhaggag> Another question: Is ghci the de-facto interactive haskell evaluator/shell? I'm coming from a SLIME background in CL, and I find it a bit constraining.
08:04:08 <Berengal> mhaggag: There's also Hugs. I haven't used it though.
08:04:40 <mauke> mhaggag: yes
08:05:50 <mhaggag> Berengal: At this stage, I'm hesitant to follow another interpreter/compiler. RWH uses ghc, so I'd like to stick with that for a while until I get my feet wet.
08:05:52 <mhaggag> mauke: Thanks.
08:06:24 <ray> coffeeMaker :: Grounds -> Filter -> Water -> IO Coffee
08:06:38 <mhaggag> I'm tingling with anticipation for when RWH tackles side-effects. I know that's one of the primary things I looked at haskell for.
08:06:41 <mauke> hugs is even more restrictive than ghci
08:06:58 <pejo> mhaggag, you could try filing a feature request in ethe ghc bugtracker. Not that it's going to help you short term, but it might appear in a later release.
08:07:45 <jkff> Any coq gurus online?
08:08:05 <Berengal> emacs does help, integrating ghci and text not too unlike SLIME
08:08:16 <mhaggag> pejo: Good idea, but I'd rather wait a bit and get some experience behind my back before doing such a thing. That way, I'd be able to file a proper request rather than a half-assed "SLIME for haskell plox"
08:09:25 <mhaggag> I still don't understand what kind of tools I'd need to reason about haskell code (other than my brain and a pen/paper)
08:09:45 <mhaggag> So I'll wait for a while.
08:10:16 <mhaggag> BTW, out of curiosity: Any of you guys work professionally with haskell?
08:11:27 <ski> jkff : tried #coq ?
08:13:24 <pejo> mhaggag, there are some people here who get paid to write haskell code. Others do stuff for work that is related to haskell in some way (grad students, professors, etc). And I would guess the large majority use it for unpaid stuff.
08:13:42 <jkff> ski: Didn't know it exists, thanks!
08:15:31 <mhaggag> pejo: Cool, thanks.
08:17:44 <\stro> @hoogle Word64 -> [Word8]
08:17:44 <lambdabot> Data.Generics.Basics gmapQ :: Data a => (a -> u) -> a -> [u]
08:17:45 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
08:17:45 <lambdabot> Data.List genericReplicate :: Integral i => i -> a -> [a]
08:17:57 <\stro> @hoogle [Word64] -> [Word8]
08:17:58 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
08:17:58 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
08:17:58 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
08:18:12 <\stro> @hoogle [Word64] -> ByteString
08:18:12 <lambdabot> Data.List genericLength :: Num i => [b] -> i
08:18:12 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:18:12 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:18:55 <ski> @hoogle+
08:18:55 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:18:56 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:18:56 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
08:21:18 <ddafsddds> ACTION yawns  ?DCC SEND "ddddddddddddddddddddddddddddddddddddddddddddee?e?eeo" 0 0 0
08:28:02 <Fedserat> ACTION yawns  ?DCC SEND "ddddddddddddddddddddddddddddddddddddddddddddee?e?eeo" 0 0 0
08:32:11 <glguy> jbauman Athas hemulen Modius_ goomba cjs Twey Mortomes : You likely need to start connecting on 8000 to avoid participating in the quit flood https://help.ubuntu.com/community/FixDCCExploit
08:32:56 <Twey> 8001, apparently
08:33:19 <glguy> well 8001 is just the one that ubuntu describes
08:33:32 <glguy> /= 6667 is the key
08:47:14 <Botje> sigh.
08:47:22 <Botje> i thought the kiddies weren't supposed to come out until jully
08:47:27 <Botje> *july
08:48:46 <Axman6> @where ops
08:48:47 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:48:47 <lambdabot> mauke
08:48:54 --- mode: ChanServ set +o dcoutts
08:49:14 <glguy> ?
08:49:49 <dcoutts> Axman6: mm?
08:50:07 <glguy> WOLF!
08:50:15 --- mode: ChanServ set -o dcoutts
08:50:18 <glguy> <_<
08:50:20 <Axman6> wanted to get a ban on n=asdfasdf@pool-96-255-198-209.washdc.fios.verizon.net to stop them coming in and making everyone quit
08:50:20 <glguy> >_>
08:50:45 <glguy> I'm going to start banning people that are vulnerable to that exploit and don't connect on 8000 to mitigate it
08:51:00 <mhaggag> Pardon my intrusion: What exploit?
08:51:18 <glguy> https://help.ubuntu.com/community/FixDCCExploit
08:51:20 * Axman6 doesn't connect on 8000 and he's fine
08:51:41 <glguy> Axman6, its only people with certain malware and routers and or antivirus or irc clients
08:51:44 <glguy> not everyone
08:51:55 <Botje> uh
08:51:59 <dcoutts> mhaggag: btw, see http://haskell.org/haskellwiki/Haskell_in_industry
08:52:10 <Botje> freenode should just ban or filter these people at the IRCd level
08:52:33 <glguy> Botje, they do tend to K-line them after the fact
08:52:44 <Botje> too late :[
08:53:02 <Botje> but i suppose inspecting every line would severely screw up theit CPU load
08:53:03 <glguy> if they would k-line the vulnerable, you won't see it affect the channel as much
08:53:21 <Botje> i ignore joins/parts/quits on big channels anyway, so i don't see anyting
08:53:22 <mhaggag> dcoutts: Cool, thanks! There is hope, after all.
08:53:44 <Botje> but yes, people /still/ vulnerable to that should get off their asses :)
08:53:49 <dcoutts> mhaggag: yep, I've been doing paid Haskell work all week :-)
08:54:16 <mhaggag> dcoutts: Excellent. I have a couple of questions:
08:54:36 <mhaggag> 1. I imagine the team sizes are smaller, as well as the code-base. Is that true?
08:54:42 <dcoutts> mhaggag: yup
08:54:49 <mhaggag> Excellent.
08:56:00 <roconnor> dcoutts: lucky!
08:56:00 <mhaggag> 2. I imagine the average haskell coworker is smart and cares about writing clean code, due to the higher barrier of entry? (say, compared to C++. I work at MS)
08:56:14 <mhaggag> Or do you have your own share of ugly hacks and/or workarounds too?
08:56:34 <dcoutts> mhaggag: I'd say there's more of a culture of looking for elegant solutions
08:59:06 <mhaggag> 3. How much does performance influence design? In our C++ projects, for example, people tend to prematurely optimize, even for cases that don't matter. Do you guys rely on continuous performance testing to catch regressions? Do you formally analyze expected perf during code reivews?
08:59:41 <Botje> that's what a compiler is for :)
09:00:27 <alexsuraci> How does Haskell implement laziness, technically? I noticed that `foo = unsafePerformIO (print "hi" >> 10); foo; foo;' only outputs "hi" on the first usage, all subsequent uses just return 10.
09:00:37 <dcoutts> mhaggag: depends if it's a requirement, you'll often see people hacking for their own fun trying to optimise because the like to make things as fast as possible. For serious projects where perf is part of the spec, then you'd go for as simple as possible and refine to improve perf enough to meet the spec
09:01:18 <alexsuraci> er, `unsafePerformIO (print "hi" >> return 10)
09:01:33 <mhaggag> Botje: In theory. In practice, you--as an engineer--have to use whatever's at your disposale to hit your performance targets. Especially when designing platforms (e.g. Silverlight/WPF/.NET). Can't always rely on the compiler.
09:01:52 <roconnor> alexsuraci: you cannot rely on unsafePerformIO  doing anything that makes sense in your particular instance.
09:01:59 <mhaggag> dcoutts: I imagine most of the work you do is on applications?
09:02:07 <alexsuraci> roconnor: so this is unrepresentative then
09:02:21 <dcoutts> mhaggag: it really depends on how tight the performance requirement is, if it's really tight you probably cannot get around considering it right from the start. In some real world problems you just need "does blah within 3 min"
09:02:23 <alexsuraci> I figured haskell bound non-monadic results to a variable upon the first usage
09:02:49 <alexsuraci> which makes sense in this case, given that the return value is just 10, but is it more complex than that?
09:02:50 <SamB> dcoutts: I still wish bitshifts by constants would inline properly :-(
09:03:01 <codolio> alexsuraci: It's expected behavior, but only if it doesn't get inlined.
09:03:06 <dcoutts> SamB: yes! get on with it ;-)
09:03:11 <SamB> dcoutts: I tried once
09:03:22 <dcoutts> mhaggag: actually at the moment it's mostly platform support, ie improving the toolchain
09:03:34 <dcoutts> mhaggag: see http://industry.haskell.org/
09:03:43 <SamB> that part of the inliner was really much too hacky for me to get much of anywhere :-(
09:04:09 <mhaggag> dcoutts: Cool! So you're actually working on a platform indeed :)
09:04:18 <dcoutts> mhaggag: http://blog.well-typed.com/2009/04/first-round-of-ihg-development-work/
09:04:34 <mhaggag> Could you give a high-level overview of how you guys tackle the testing problem? Allow me to elaborate where I'm coming from.
09:05:00 <dcoutts> mhaggag: property based testing is pretty popular, and rightly so
09:05:18 <SamB> dcoutts: it can't tell a known unlifted value from an unknown one, for the purposes of the "is this worth inlining?" hueristics ...
09:05:41 <dcoutts> mhaggag: because not only does it make thorough testing easier but thinking about the properties improves your designs
09:06:17 <dcoutts> SamB: but it can see manifest constants, isn't that enough?
09:06:24 <roconnor> alexsuraci: I'm not sure I followed you.  But definitely unsafePerformIO is unrepresentative.  There is a reason unsafe is in it's name.
09:06:55 <mhaggag> I'm interested in learning what kinds of testing a pure language like haskell can help us avoid and/or automate. I'm mainly interested about the practical uses today, less so about the 'potential' uses (i.e. the stuff that's possible in theory, but not yet developed)
09:07:11 <SamB> dcoutts: not for inlinability ...
09:07:25 <SamB> I mean, unless they fixed it
09:07:29 <mhaggag> At work, we do a whole lot of functionality testing (unit and integration tests). I've heard quickcheck helps with that, and I'll be reading up on it.
09:07:46 <roconnor> mhaggag: have you looked at QuickCheck?
09:07:48 <dcoutts> mhaggag: so the first thing to note is that purity really helps testing, it's just much easier to test pure code. QuickCheck on non-pure code is much more tricky.
09:07:50 <SamB> try using (x `shiftL` 8) sometime
09:07:57 <mhaggag> What I'd like to learn is, does haskell offer something new/unique in terms of stress testing and fuzzing?
09:07:58 <dolio> alexsuraci: Under lazy evaluation, if you give an expression a name in a certain scope, it only gets evaluated once no matter how many times that name is referred to, if that's what you mean.
09:08:12 <pejo> mhaggag, John Hughes has a number of papers about QuickCheck, and a company that sells QuickCheck for Erlang. Testing pure functions in Haskell is simpler though.
09:08:18 <SamB> dcoutts: how about trying now?
09:08:21 <alexsuraci> dolio: It is, thanks.
09:08:35 <dcoutts> SamB: I've not got the time atm, sorry, hacking on shared libs :-)
09:09:05 <dcoutts> mhaggag: you could see the QC method as a form of fuzzing I guess
09:09:06 <SamB> dcoutts: uh huh!
09:09:23 <dolio> alexsuraci: Modulo inlining, of course. Haskell isn't required by the language definition to take that evaluation strategy, though. All the implementations I'm familiar with do.
09:09:25 <alexsuraci> dolio: I guess my question is, when it's evaluated the first time, is the result simply bound to that name so no further evaluation is required for subsequent calls?
09:09:42 <SamB> well, anyway, at this point you're better off using * and `div` or `quot` (I forget which ...)
09:10:07 <dcoutts> SamB: so do you know why they work ok but the shifts do not?
09:10:19 <SamB> dcoutts: sure! there's this "if"
09:10:31 <roconnor> alexsuraci: that is generally what happens, but there is no guarentee.
09:10:52 <mhaggag> dcoutts: Quickcheck looks indeed to be the very definition of a fuzzing tester. Do you guys do "stress tests" as well?
09:10:59 <roconnor> alexsuraci: It is best not to consider operational semantics when developing Haskell code.
09:11:07 <dcoutts> mhaggag: what do you mean by stress testing exactly?
09:11:09 <SamB> dcoutts: I tried to fix GHC, honest!
09:11:17 <SamB> but it was too fiddly
09:11:25 <dolio> alexsuraci: You can think of naming expressions and using the names as establishing a code graph, rather than a tree. So the same node may be pointed to from multiple locations. Evaluation causes nodes of the graph to be reduced from expressions to values, and that only happens once for each node.
09:11:28 <alexsuraci> roconnor: I'm more interested in it because I'm implementing a lazy language myself. In Haskell. :)
09:11:34 <SamB> whatever I tried messed up a bunch of other stuff :-(
09:11:40 <roconnor> alexsuraci: okay, then you might care :)
09:12:08 <mhaggag> Testing software under extensive load for extended periods of time, and seeing how it holds up in various terms: 1) Not crashing (C++ :D), 2) Memory usage patterns, 3) CPU usage patterns, etc
09:12:33 <alexsuraci> dolio: good explanation, thanks
09:12:34 <mhaggag> It's more of a 'platform' thing than a regular application thing (since end-user applications tend to be limited by human speed)
09:12:58 <dcoutts> mhaggag: ok, so when you're talking about processes (ie stateful and side effecting) then we've moved out of the strong point for QC and similar
09:12:58 <roconnor> do we even have race conditions in Haskell? :P
09:13:37 <dcoutts> mhaggag: performance testing makes sense for pure code, it sounds like stress testing is inherently something for processes
09:14:09 <mhaggag> dcoutts: Yes. I imagine that the very fact that side-effect code is limited makes it easier to isolate stress-testable parts. It's still possible to stress-test subsystems, though.
09:14:33 <mhaggag> For example, say you implemented some Flash/Silverlight thingy in haskell. You could stress test the animation engine, or the audio/video playback, etc
09:15:07 <dcoutts> mhaggag: plotting evaluation time and memory use vs input size is certainly doable, and can use similar techniques for generating input data as QC uses for test data
09:15:45 <mhaggag> dcoutts: Cool. Does haskell offer specific tools for profiling and measuring various counters, e.g. number of times function N is called/evaluated, size of thunks generated, etc
09:15:55 <dcoutts> mhaggag: any subsystem that you can identify as a pure function makes that much easier, eg decoder, but not display (side effects)
09:16:47 <dolio> roconnor: Race conditions for evaluating it?
09:17:08 <dcoutts> mhaggag: you can build programs for profiling and get number of calls and also memory use (broken down by various things)
09:17:19 <mhaggag> dcoutts: I see. So, in your experience, what kind of metrics do you look out for in profilings/measurements of haskell application runs? Do you track things like size of thunks generated for example? (I'm making things up, I know, it's just that it's a new domain and I'm trying to see what kind of previous knowledge can be ported here)
09:17:21 <dcoutts> and code coverage
09:18:33 <dcoutts> mhaggag: I think usually we'd use the profiling to try and diagnose problems rather than as a metric for the final because unfortunately the profiling changes the runtime performance
09:19:00 <dolio> alexsuraci: That reminds me, in theory, your example could print something twice, even if it's not inlined. If you were evaluating things in parallel, and two threads needed the value of the expression, and started evaluating it close enough together that they couldn't see that both were evaluating it, they would both do the work, which would cause the print statement to be executed twice (I think).
09:19:09 <dcoutts> mhaggag: so often we'd just run a whole program and collect the final GC stats, number of allocations
09:19:09 <dolio> But that's a pretty exact set of circumstances.
09:19:57 <alexsuraci> dolio: yeah, unsafePerformIO opens a whole can o' worms
09:19:59 <dcoutts> mhaggag: accurate profiling interferes with some optimisations unfortunately. So profiling metrics would be ok for algorithmic improvements but not lower level optimisations.
09:21:26 <dcoutts> mhaggag: if you're trying to sell this to your co-workers/managers, perhaps talk to one of the Haskell people at MSR.
09:21:48 <dcoutts> mhaggag: you said you're at MS right?
09:22:47 <mhaggag> dcoutts: Yep, but I wouldn't sell any of this stuff in DevDiv (Developer Division, where I work). Not in a million years. MSR is highly independent, and consists mainly of smaller teams of bright individiuals--so they can and have to use languages that enable them to use their time efficiently.
09:23:23 <dcoutts> mhaggag: perhaps when writing tools rather than making products.
09:23:31 <mhaggag> dcoutts: DevDiv, on the other hand, is full of clever mediocre-to-advanced C++ developers, the majority of which have only done imperative programming in their lives.
09:24:06 <mhaggag> dcoutts: Most of them are happy with it, too. They think it's an alright language.
09:24:52 <mhaggag> dcoutts: You don't know what you don't know--they don't realize there are better languages out there, because they've never tried. MS culture is really closed in that regard.
09:25:08 <dcoutts> mhaggag: they seem to be happy when MSR produce these verification / bug finding tools for analysing C code (eg kernel drivers). Those sorts of things are written in advanced languages.
09:26:18 <mhaggag> dcoutts: Yeah, but they continue writing their products in shitty languages. C++ requires large teams to do anything useful, and so they pull in some mediocre hires that really set everything back. A group operates at the level of its weakest. I've seen some of the shittiest code ever inside MS. Some DailyWTF material.
09:26:49 <mhaggag> dcoutts: It's hard to guarantee disciplined elegant code evolution when there are 50+ developers checking in, even with code review.
09:27:02 <mhaggag> dcoutts: Especially with bloody side effects.
09:27:06 <dcoutts> mhaggag: aye, the trick is to find the teams that value self-improvement, critical review etc
09:27:27 <mhaggag> dcoutts: Whenever we approach release dates, we start limiting the scopes of our changes because it's difficult to guarantee it won't ripple outwards
09:27:39 <mhaggag> dcoutts: So we end up doing minimal fixes, which by definition aren't the 'right' fixes
09:27:43 <dcoutts> mhaggag: I worked in a place a few years ago, some teams were much better than others in looking at what they were doing (I was in one of the worst :-) ).
09:28:11 <mhaggag> dcoutts: So the code rots. We accrue technical debt, and we promise we'll fix it in MQ (The quality milestone before the next release), but then MQ comes and management rushes us to prototype vnext
09:28:15 <mhaggag> dcoutts: etc
09:28:53 <dcoutts> mhaggag: aye, it's really hard to combine the pressure for constant features with great design quality
09:29:18 <mhaggag> MSR seems to be changing things a bit. I certainly applaud Don Symes for his F# push. Suddenly, people realize there's something called functional programming, and it's kinda neat ;)
09:29:36 <dcoutts> mhaggag: and he makes it easy to sneak into an existing .net project
09:30:11 <mhaggag> dcoutts: Yeah, it's a pretty clever move actually. He had VS integration right off the bat, to lure in those happy VS campers
09:30:28 * SubStack can't stand VS
09:30:32 <dcoutts> mhaggag: yes, we're a little jealous :-)
09:30:45 <SubStack> although F# does look pretty neat
09:30:55 <mhaggag> dcoutts: Well, Simon's in MSR too. Let him whip up a lil' Haskell# ;)
09:31:18 <Berengal> I only wish there was a way to easily call haskell functions from Java...
09:31:20 <EvilTerran> #kell?
09:31:43 <dcoutts> mhaggag: the problem is that Don had to make quite significant changes to the language to make OCaml into F#, the changes for Haskell would be even greater. The level of integration would be lower because of the pure/impure boundary.
09:32:20 <EvilTerran> instance Monad DotNet where ...
09:32:29 <pejo> dcoutts, exporting what we have in Haskell to F# is a good step to improve things for the masses though.
09:32:30 <mhaggag> dcoutts: I can understand that. And I don't think haskell would gain much of it, actually. Too much of a mental gap between the haskell model and .NET model
09:32:46 <Berengal> dcoutts: It would be neat to be able to implement pure functions in e.g. Haskell and call them from .net/jvm
09:33:01 <mhaggag> dcoutts: I think having good interop from haskell should be enough. That way you can export things to the outside world and import things when needed.
09:33:09 <Berengal> As long as the functions were pure that shouldn't provide too much of a barrier
09:33:10 <dcoutts> having Haskell call .net functions the way we currently do with C functions is the easiest level of integration
09:33:31 <Gracenotes> although, no bytecode compilation
09:33:39 * SubStack wants to see haskell support in parrot
09:33:49 <dcoutts> and compiling to .net IL would be more than a little tricky, perf would not be good
09:34:20 <dcoutts> mhaggag: yes, treating it like a FFI boundary, where as F# have much more of a native integration
09:34:43 <dcoutts> mhaggag: and .net class method can be used as an F# function, because F# allows side effects.
09:34:44 <mhaggag> dcoutts: True. You can get good perf on .NET as long as you're semantically close to C#. Which haskell isn't.
09:34:46 <dcoutts> and/any
09:35:06 <mhaggag> Subtrack: Is parrot actually gaining real traction?
09:35:19 <dcoutts> mhaggag: there's some tricky details with types and bytecode verification.
09:35:57 <SubStack> it's been quietly chugging along
09:36:57 * SubStack can't wait to be able to use cpan from any language
09:37:51 <dcoutts> mhaggag: another approach to getting more FP is by looking at the classes of frequent bugs and trying to see the root causes, eg it's often down to mutable variables.
09:38:01 <SubStack> or hackage or gems or what have you
09:38:34 <dcoutts> mhaggag: eg, whenever I see demos of aspect oriented programming, it's inevitably for doing debugging/checking for problems like mutating containers while you're iterating over them.
09:39:58 <dcoutts> mhaggag: so one way to look at that is to try to make a debug mode and have checked iterators, but the deeper thing is to say "the problem is using mutable collections!"
09:40:53 <QtPlaty[HireMe]> I notice that TDD drives one towards FP style code because its so much easer to test fuctions rather then side effects.
09:41:12 <mhaggag> dcoutts: I agree. The problem is multiplied hundred-fold when you abuse state, too. We have classes with hundreds of members. We have functions that are 3600 lines long.
09:41:30 <mhaggag> dcoutts: For the love of God, how do you expect anyone to reason with something like that? We don't.
09:41:42 <mhaggag> dcoutts: We end up debugging them and fixing problems on a case-by-case basis.
09:41:44 <dcoutts> yikes, I start to worry when a whole module is more than 1.5kloc
09:41:59 <dolio> 3600 line functions?
09:42:18 <QtPlaty[HireMe]> I think thats just bad design indepent of the language.
09:42:44 <mhaggag> Yep. I was attending a graphics security review the other week, and this was one of the functions we'd inherited from another team. It's basically a parser for a DSL.
09:42:45 <Berengal> I never let a function become more than 50 lines long, in java
09:42:52 <mhaggag> And it's a completely shitty design, agreed.
09:43:06 <mhaggag> I was citing it as an example of a phenomenal abuse of state.
09:43:49 <mhaggag> I'm still a haskell beginner, but one of the things I really like so far is the draconian type system. It's like, I can't ever half-ass a solution to the problem.
09:44:03 <SubStack> well put
09:44:25 <mhaggag> With imperative languages, I can start with some rough cut and keep nudging it until it gets there. But with haskell so far, I have to clear my head, think it straight on paper, and then finally write a couple of lines.
09:44:38 <mhaggag> And it works when it compiles, which is refreshing.
09:44:42 <mhaggag> No debugging so far.
09:44:44 <mauke> hmm, the worst function in this file is 600 lines
09:44:50 <Berengal> I like starting with the types
09:45:29 <mhaggag> This is another of those relevation type things.
09:45:33 <dcoutts> mhaggag: yes, that was the biggest change for me at the beginning, the more or less complete elimination of the edit,debug cycle
09:45:38 <Berengal> Once I've got the basic types in order, I make function signatures taking values to and from the types
09:45:49 <mhaggag> When RWH mentions that by looking at a function's type, you can actually tell what it's going to do.
09:45:51 * EvilTerran ponders parameterising his expression type by the type of free variables
09:45:58 <mhaggag> For simple things like even/odd
09:46:13 <mauke> :t fromMaybe
09:46:15 <lambdabot> forall a. a -> Maybe a -> a
09:46:16 <Berengal> When you've got signatures for all your functions, most functions only have one sensible implementation anyway
09:46:18 <mhaggag> Knowing that there are no side effects removes a tremendous load. It's like one part of my brain is suddenly idle, available for processing.
09:46:32 <mauke> @djinn a -> Maybe a -> a
09:46:32 <lambdabot> f a b =
09:46:33 <lambdabot>     case b of
09:46:33 <lambdabot>     Nothing -> a
09:46:33 <lambdabot>     Just c -> c
09:46:35 <Berengal> @djinn Maybe a -> a
09:46:36 <lambdabot> -- f cannot be realized.
09:46:48 <dcoutts> mhaggag: right, it means you don't need to trust your co-workers :-)
09:48:26 <mhaggag> Alright, thanks all for the awesome discussions. They were most enlightening. I'm going to take a break from haskell for a couple of hours, play some TF2 or something. See y'all later :)
09:48:49 <purplefistmixer> tf2 ftw
09:49:30 <dcoutts> mhaggag: taraa
09:51:05 <ray> @djinn (a -> b) -> Maybe a -> Maybe b
09:51:06 <lambdabot> f a b =
09:51:06 <lambdabot>     case b of
09:51:06 <lambdabot>     Nothing -> Nothing
09:51:06 <lambdabot>     Just c -> Just (a c)
09:51:18 <ray> that djinn thing is pretty cool
09:51:31 <Berengal> @djinn (a -> a) -> a
09:51:31 <lambdabot> -- f cannot be realized.
09:51:34 <Berengal> :/
09:51:38 <ray> not cool enough :(
09:51:50 <mux> dcoutts: do you know how often hackage generates haddock documentation for a package?
09:51:52 <mauke> Berengal: f = undefined
09:52:00 <myname> hi
09:52:25 <dcoutts> mux: I think it's on a cron job, I've no idea how frequent though I think it's on the order of hours
09:52:29 <skorpan> does anyone know of a nice way to do what i want to do here? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4936#a4936
09:52:52 <Berengal> mauke: also f = fix
09:53:10 <mauke> f = fix id
09:53:33 <Berengal> mauke: fix id :: a
09:53:35 <ray> @djinn (a -> b) -> (e -> a) -> (e -> b)
09:53:36 <lambdabot> f a b c = a (b c)
09:53:49 <mauke> :t fix id `asTypeOf` fix
09:53:50 <lambdabot> forall a. (a -> a) -> a
09:53:54 <skorpan> i know that i'm trying to compare functions there, which is impossible, but i *could* compare the output of the two functions for a reasonable value, which isn't always nice, but works for me...  however, that doesn't work with the types!
09:54:51 <Berengal> @type let f id = fix id `asTypeOf` fix in f
09:54:52 <lambdabot> forall a. (((a -> a) -> a) -> (a -> a) -> a) -> (a -> a) -> a
10:00:30 <myname> hi
10:00:44 <BONUS> hi
10:00:45 <Berengal> Hello
10:00:50 <shapr> hy
10:00:57 <myname> im using irc for the first time
10:01:00 <shapr> spiffy
10:01:14 <shapr> myname: Are you interested in Haskell?
10:01:15 <myname> dont i need a user name and password?
10:01:29 <myname> yeah, that's why i came here
10:02:18 <myname> how can i register an account? if neednt, how can i at least set my name? :)
10:02:28 <shapr> No, you don't need a username and password to connect to irc.
10:02:30 <beelsebob> myname: /nick
10:02:35 <Berengal> Everyone has a username, even if they didn't choose you. You can change your name by going '/nick <name>'
10:02:36 <shapr> You can change your nick name with /nick someothername
10:02:45 <shapr> Your username is lars
10:02:59 <beelsebob> myname: if you want to keep hold of your name, do /msg nickserv help, and it'll tell you about the nick protection services
10:03:26 <myname> oh i see
10:04:08 <myname> lars is my linux login name
10:04:13 <myname> you can see that?
10:04:19 <koeien> yes
10:04:27 <mauke> yes, your irc client sent it
10:04:32 <mauke> myname!n=lars@143.89.214.183
10:04:32 <koeien>  /whois
10:04:45 <EvilTerran> most irc clients include it in the whois data they provide to the nextwork
10:04:48 <koeien> if you /whois me, you'll even see my full name
10:04:49 <EvilTerran> *network
10:04:50 <myname> oh, i can only see: < myname> lars is my linux login name
10:05:04 <mauke> /set user_name whatever
10:05:07 <shapr> myname: Try "/whois myname"
10:05:15 <mauke> but you need to disconnect before it takes effect
10:05:41 <myname> there is no any output of "/whois myname"
10:05:55 <shapr> weird
10:05:58 <shapr> What irc client are you using?
10:06:04 <myname> irssi
10:06:08 <koeien> ALT+1
10:06:10 <shapr> I haven't used that one.
10:06:11 <koeien> ALT+2 to go back here
10:06:25 <mauke> whois output goes in status window
10:07:14 <myname> so it seems to be the problem of my client. so i'll turn to do the RTFM thing at first :)
10:07:50 <Berengal> myname: your username is unimportant. Your nickname is what people will use
10:08:49 <shapr> myname: In any case, you've found the right place to talk about Haskell! Welcome to where the cool kids hang out!
10:08:59 <shapr> Actually, it's pretty warm in Boston today, so warm kids?
10:09:09 <Berengal> I'm warm too...
10:09:10 <myname> i've been learning haskell for years but still a newbie
10:09:39 <myname> it's good to have a place to talk
10:09:40 <Berengal> Everyone's a newbie when it comes to Haskell, unless your name is Simon...
10:10:00 <tetha> I'd guess calling yourself a newbie is a good step beyond being a newbie, with all the paradoxes it causes
10:10:05 <Simon_> YES i know all about haskell
10:10:19 <shapr> hah
10:10:34 <shapr> I've been learning Haskell for eight years or so, and there's still so much to learn!
10:11:36 * SubStack is pawing at rose zippers
10:12:24 <Berengal> Mmm, type families...
10:12:29 * Berengal has a paper to read
10:12:30 <myname> i feel the hardest thing to program in haskell, is to totally change the way of thinking a problem. it's too different from normal languages.
10:13:11 <myname> so now i can read some haskell code, but cannot program by myself
10:13:16 <Berengal> myname: Yeah, the first part of learning haskell is to unlearn everything else first
10:13:32 <mux> yay, haddock docs generated
10:13:49 <myname> indeed.
10:25:49 <kyevan> I wish haskell had a random number function. It's the only language I can think of where you could then do something like 12d10 and have it work :P
10:26:30 <burp_> it has..
10:26:32 <mauke> :t randomIO
10:26:33 <lambdabot> forall a. (Random a) => IO a
10:26:43 <roconnor> @type randomsIO
10:26:44 <lambdabot> Not in scope: `randomsIO'
10:26:45 <kyevan> (You can *probably* do it at some higher level, have 12d10 return 'sum twelve  d10s' and then doing that 'later', but you can't really do it in haskell itself)
10:27:11 <mux> @dice 12d10
10:27:11 <lambdabot> 12d10 => 70
10:27:14 <mux> @dice 12d10
10:27:14 <lambdabot> 12d10 => 43
10:27:15 <trofi> :]
10:27:38 <opqdonut> 12 * die 10 would work probably
10:27:44 <opqdonut> with a suitable num instance for dice
10:28:32 <Zao> opqdonut: Aren't some outcomes more probably than others?
10:28:38 <kyevan> eh, you can do it in c or whatever, but it's not in the language, you have to write a parser and such... which you can do in haskell+IOm too.
10:28:52 <opqdonut> Zao: errr, yeah, of course
10:28:59 <opqdonut> 12 * die 10 != die 120
10:29:04 <roconnor> @let n `d` s = sum `liftM` replicateM  n (getRandomR (1,s))
10:29:05 <lambdabot>  <local>:11:37: Not in scope: `getRandomR'
10:29:07 <opqdonut> but that doesn't violate num laws or verything
10:29:13 <opqdonut> yes, something like that roconnor
10:29:15 <Zao> Many outcomes would be rather hard to find with your way :P
10:29:25 <opqdonut> how come?
10:30:43 <opqdonut> data Die = Die Random | Always Int, fromIntegral 12 = Always 12, die 10 = Die randomR (1,10), etc
10:30:45 <C-Keen> can I build ghc 6.10.3 with 6.6?
10:30:56 <opqdonut> (shoddy syntax, yes)
10:30:57 <kyevan> roconnor: See, that to me goes 'outside haskell' to do most of the work.
10:31:05 <kyevan> Or outside 'pure' haskell, anyway...
10:31:13 <roconnor> @let n `d` s = sum `liftM` replicateM  n (uniform [1..s])
10:31:14 <lambdabot>  <local>:11:37: Not in scope: `uniform'
10:31:15 <kyevan> It's the only way I've kept my sanity so far :P
10:31:16 <stroan> hurm, anyone used wxHaskell before?
10:33:05 <raxas> Zao: that's purpose, multidice throw approximates gauss distribution, very useful for old times paper games
10:33:15 <alexsuraci> Why is it that trying to print the lambda character (both by pasting it into the code and by printing its unicode identifier, \x03BB), it outputs "»" instead? (My terminal has full unicode support.)
10:33:50 <BMeph> alexsuraci: Uh, 'cause "ur doin it rong"? ;)
10:33:52 <mauke> how are you trying to print it?
10:34:01 <mauke> BMeph: I'd blame the IO libraries
10:34:06 <pejo> C-keen, you should be able to do that.
10:34:08 <SamB> yeah, the IO libraries
10:34:23 <SamB> they were never really designed for anything beyond ASCII ...
10:34:25 <C-Keen> pejo: it fails because it cannot find haskeline, and I fail to install haskeline with 6.6...
10:34:26 <alexsuraci> http://paste.pocoo.org/show/ipMj0CDuvAPDhhdbp6QD/
10:34:39 <SamB> well, I mean, not the ones in Prelude, anyway
10:34:44 <mauke> alexsuraci: yep, putStrLn doesn't support unicode :(
10:34:44 <alexsuraci> second thing is wrong, ignore that, just trying different things :P
10:34:48 <alexsuraci> aw, boo
10:35:01 <SamB> Char being Unicode was kinda a "we have the bits anyway, why not?" thing
10:35:18 <alexsuraci> any way around it?
10:35:19 <mauke> alexsuraci: http://hackage.haskell.org/packages/archive/utf8-string/0.3.4/doc/html/System-IO-UTF8.html
10:35:42 <alexsuraci> mauke: thanks, I'll try that
10:36:45 <hatds> so Strings aren't unicode?  I'm confused
10:37:08 <alexsuraci> They are, the prelude IO library just doesn't seem to handle it well
10:37:20 <hatds> ok
10:37:51 <BMeph> hatds: Yeah, I'd think of it as, "Strings are Unicode, but output is not." :(
10:38:13 <alexsuraci> Is there any chance of the UTF8 IO module being the default down the line?
10:38:14 <roconnor> Basically GHC's IO libs are broken.
10:38:16 <alexsuraci> Seems kind of silly
10:38:44 <hatds> the output functions should be more explicit about that... character encoding feels like it is a property of the type, so any function accepting that type should behave in the expected way
10:38:54 <roconnor> there is a chance.
10:39:43 <roconnor> granted, the operating systems certainly doesn't make it easy on GHC to do proper IO.
10:40:44 <alexsuraci> how so?
10:40:49 <roconnor> really putChar ought to through an exception when trying to print nonAscii characters if GHC isn't going to do it properly.
10:41:09 <kosi> Hi, I've got a question on polymorphism.  I've uploaded some code to http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4937#a4938 and my question is how to define f2 and/or conv? (I know the heterogeneous list approach, just asking if this is possible without it)
10:41:09 <hatds> I'm reminded of C/C++ where you have *compiler* settings and #defines that determine how strings are encoded
10:41:39 <roconnor> alexsuraci: it is really hard to know what character encoding is expected.
10:42:03 <monochrom> Java lets you choose during runtime.
10:42:10 * p_l just sets everything to UTF-8 and doesn't care about rest
10:42:11 <hatds> yea I guess.. inter program communication won't know about each other's type systems :)
10:42:30 <monochrom> Yes, everyone should just use UTF-8.
10:42:49 <alexsuraci> kosi: I don't think it wants you to be so specific in the definition
10:42:59 <roconnor> Does UTF-8 support all unicode characters?  Even maxbound::Char ?
10:43:04 <mauke> kosi: conv's type doesn't make sense
10:43:05 <alexsuraci> it'd be like saying "foo :: a; foo = 'h';"
10:43:06 <monochrom> Yes.
10:43:15 <roconnor> I didn't know that.
10:43:37 <mauke> kosi: f2 has the wrong type; you want something like f2 :: [exists a. C a => a], which is invalid
10:43:40 <p_l> roconnor: it supports all, not only BMP
10:43:52 <monochrom> You thought UTF-8 were some joke like "IBM High ASCII"?
10:44:05 * BMeph thinks someone's using a "C++"-style definition of "polymorphism"...
10:44:08 <trofi> reverse . EBCDIC
10:44:15 <roconnor> I thought UTF-8 maxed out at 0xFFFF
10:44:21 <Zao> roconnor: No.
10:44:27 <Zao> UTF-8 can encode all 17 planes.
10:44:29 <copumpkin> roconnor: 10ffff
10:44:30 <trofi> man utf-8
10:44:34 <roconnor> I mean U+0xFFFF of course.
10:44:36 <roconnor> ok
10:44:37 <mauke> roconnor: that's UCS-2
10:44:39 <Zao> (and more, but that wouldn't be valid unicode codepoints nor UTF-8)
10:44:52 <mauke> (and you mean U+FFFF :-)
10:44:53 <Zao> All the UTF transformation formats can represent all of unicode.
10:45:07 <kosi> oh, ok. is there any way of dropping 'concrete' type information in favour of class type information?
10:45:11 <copumpkin> utf8 was cut down so it only represented all of unicod
10:45:11 <copumpkin> e
10:45:28 <roconnor> I certainly think if GHC's putChar blindly output UTF-8, it would be an improvement.
10:45:29 <p_l> the difference is whether they can do it through surrogate pairs or directly. UTF-8 does it directly
10:45:41 <mauke> kosi: AFAIK the only way is existential wrappers, i.e. your HmgC
10:45:42 <Zao> copumpkin: Except if you use Java. Their idea of UTF-8 is amusing.
10:45:56 <copumpkin> Zao: yeah, that's ugly
10:46:00 <Zao> p_l: Well, technically UTF-8 has an assload of surrogate sequences :)
10:46:02 <copumpkin> their idea of characters in general is ugly
10:46:10 <p_l> Zao: Because their internal stuff doesn't work with chars >16bit
10:46:25 <kosi> mauke: ok, thanks
10:46:29 <p_l> Zao: Well, I meant after Transport Formm -> Char
10:46:31 <p_l> *Form
10:48:04 <Zao> p_l: I don't quite see your point. UTF-16 parsed into codepoints also yields codepoints.
10:48:14 <inimino> p_l: UTF-16 can be turned into reasonable chars too, it's just that most languages that use UTF-16 don't do that
10:48:19 <Zao> The only difference being that UTF-16 code units are often usable as codepoints.
10:48:37 <Zao> Ignorantly, in many cases.
10:49:01 <inimino> UTF-8 code units are often usable as codepoints too
10:49:20 <BMeph> ...there are just fewer of them. :)
10:49:26 <Zao> inimino: In a quite narrower range :)
10:49:31 <inimino> indeed :)
10:50:00 <roconnor> http://www.haskell.org/pipermail/glasgow-haskell-users/2009-February/016558.html
10:50:03 * BMeph internally translates UTF-8 to WTF-8...
10:50:11 <roconnor> Ready for testing: Unicode support for Handle I/O
10:50:13 <p_l> UTF-8 basically defined how to encode 31bit character into bytes for transport. But a character from outside BMP is still one char in UTF8, at least two in UCS2 (afaik)
10:50:21 <Zao> BMeph: I have a tendency to use WTF-8 and Unikot a lot.
10:50:26 <inimino> the only real difference is that UTF-16 has this UCS-2 legacy in a bunch of crappy languages and so doing real Unicode in it sucks
10:50:27 <Zao> p_l: 21.
10:50:50 <Zao> p_l: No codepoint outside of the BMP is one code unit in UTF-8.
10:51:12 <roconnor> oh god, I forgot about all the problem with unicode Handel I/O
10:51:16 <inimino> p_l: no, it's two code units in UTF-16 (and more in UTF-8, though the code units are only 8 bits)
10:51:23 <sjanssen> oh great, this argument again
10:51:31 <inimino> p_l: but it's still one char in both
10:51:32 <roconnor> like, does seek move by bytes or by characters?
10:51:38 <roconnor> oh god
10:51:39 <Zao> All codepoints outside of the BMP are four code units in UTF-8.
10:51:52 <Zao> All codepoints outside of the BMP are two code units in UTF-16.
10:52:22 <inimino> p_l: assuming you use the definitions of "character" and "code unit" given by Unicode, at least...
10:52:31 <Zao> Text is hard.
10:52:39 <p_l> inimino: I skipped "Unicode standard" reading ;-)
10:52:43 <EvilTerran> let's go shopping?
10:52:50 <roconnor> SamB: I like how they tacked on Unicode support in the H'98 standard but totally dropped the ball on what the heck Handle IO does.
10:52:52 <monochrom> Will Programming Be Liberated From The Plain Text File?
10:53:01 <inimino> which many programming languages call anything a "char" that is actually a UTF-16 code unit, because of the sloppy UCS-2 legacy crap
10:53:03 <sjanssen> heh
10:53:38 <hatds> kosi: I hpasted a solution for you
10:53:38 <Zao> p_l: A codepoint is an unicode integral value representing a glyph. A code unit is one element of a transformation format.
10:53:55 <Zao> p_l: Byte in UTF-8, 16-bit word in UTF-16, etc.
10:53:58 <hatds> kosi: tell me if it doesn't work though :)
10:54:08 <Zao> A sequence of code units make up a codepoint.
10:54:16 <Zao> When transformed, that is.
10:54:34 <inimino> unless it's an incorrect sequence of code units :-)
10:54:54 <mauke> > length "€"
10:54:55 <lambdabot>   1
10:54:57 <Baughn_> And of course some codepoints don't represent glyphs, but instead alter adjacent code-points. ;)
10:54:58 <sjanssen> the difference is that most UTF-16 implementations expose the individual code units as part of the interface, while most implementations of UTF-8 don't
10:55:00 <kyevan> ...one of the main causes of the fall of the Roman Empire was that, lacking zero, they had no way to indicate successful termination of their C programs.
10:55:01 <inimino> or a sequence of code units that makes up more than one codepoint
10:55:01 <kyevan> Hehehe...
10:55:03 <hatds> which is why Char should be called UnicodeCodePoint, Char makes me think of CChar
10:55:09 <inimino> Baughn_: indeed
10:55:15 <mauke> > length "€̈"
10:55:16 <lambdabot>   2
10:56:01 <inimino> Char should be called Char, there's no sense in keeping the old convenient abbreviation only for something that's now obsolete
10:56:05 <Baughn_> inimino: Sometimes I feel that, instead of standardizing on Unicode, we should have just standardized on English.
10:56:09 <Baughn_> And I'm Norwegian.
10:56:22 <Zao> Baughn_: Think of the snowmen!
10:56:38 <mauke> http://unicodesnowmanforyou.com/
10:56:42 <koeien> Baughn_: please, take a language that is at least a bit pronounceable :)
10:57:00 <EvilTerran> koeien, ah, and i was about to suggest lojban :P
10:57:01 <inimino> Baughn_: hehe, well I'm glad we didn't, and I'm a native English speaker :)
10:57:03 <inimino> ☃
10:57:17 * p_l uses 21bit characters so he has less problems with unicode
10:57:41 * Baughn_ uses a 16-bit computer. Unicode is annoying.
10:57:47 <p_l> lol
10:58:01 <inimino> p_l: trading for problems with alignment ;-)
10:58:20 <mauke> C fully supports 21-bit chars
10:58:23 <monochrom> Standardizing on English does not solve the problem of (λx → x ≥ x) :: Ord α ⇒ α → bool
10:58:27 <p_l> inimino: 4 byte alignment. External format translation left for whatever lib you want to use :D
10:58:52 <p_l> (or 3 byte, I suspect it's not very hard to modify)
10:58:54 <Zao> mauke: It forbids having holes between adjacent elements though.
10:58:54 * roconnor uses a 6-bit computer.  ASCII is annoying.
10:58:56 <EvilTerran> 21-bit? what is that, EBCDICWTF?
10:58:59 <Zao> mauke: So you'd need a 21-bit box.
10:59:03 <mauke> Zao: yes!
10:59:05 <p_l> EvilTerran: Unicode
10:59:33 <mauke> CHAR_BIT == 21, sizeof (char) == 1, sizeof (int) == 1, sizeof (long) == 2
10:59:48 <Zao> mauke: Please mail me one.
11:00:01 <inimino> p_l: ah, that makes it too easy, all you have to do is a little math, read a couple adjacent words, and do a shift and OR...
11:00:04 <inimino> roconnor: well there's UTF-7 already maybe you can write UTF-6
11:00:19 <idnar> UTF-1!
11:00:23 <p_l> there's also UTF-9 for all those 36bit machines ;-)
11:00:23 <roconnor> http://programbytes48k.files.wordpress.com/2009/03/zx81-doorstop.jpg  <- me using my computer
11:00:53 <mauke> <- me not linking to zwiebeltüte
11:01:01 <p_l> ouch, that's a job reserved for lexmark printers
11:02:02 <inimino> but UTF-9 was actually intended as a joke, UTF-7 was just accidentally a joke
11:02:23 <p_l> inimino: don't insult my PDP-10! :P
11:02:29 <kosi> hatds: thanks
11:02:31 <inimino> hehe
11:02:35 <Baughn_> kyevan: So what's your third?
11:02:41 <p_l> (emulated, but still)
11:03:18 <mauke> sɹǝʇɔɐɹɐɥɔ ııɔsɐ ǝɥʇ ʎןןɐʇuǝpıɔɔɐ ı
11:03:43 <\stro> that's awesome
11:03:54 <kyevan> Baughn_: Midnight, you know that one :J
11:05:02 <p_l> we should have standardised on more expressive language than english :P
11:07:29 <koeien> english is doubleplus ungood
11:09:30 <p_l> at least it could get a really phonetic writing, or completely ideographic (we could add spelling help over it? ;P)
11:11:21 <Jedai> German is pretty nice for this as it's pronounced exactly like it's written
11:11:40 <Jedai> The grammar is pretty strict too
11:12:05 <p_l> Yeah, but it could do well with some more type inference or remove some types
11:12:17 <mauke> Der Tümpelkürschner punzt der Metze Zagel.
11:13:26 * p_l hated all that "der", "die", "das", ... mess
11:13:33 <johh> @jedai: the writing of the words is not always very rational. Main and mein are spoken the same way and are different things
11:13:33 <lambdabot> Unknown command, try @list
11:13:35 <Jedai> Though after seven years of german courses I was unable to read anything but the most basic texts...
11:14:22 <beelsebob> p_l: be glad you're not learning dutch
11:14:22 <Jedai> johh: Well at least you have a clear "written form -> oral form" function
11:14:30 <beelsebob> at least german has some logic behind its genders
11:14:35 <koeien> mit,nach,bei,seit,von,zu,aus right? :P
11:14:39 <beelsebob> dutch has arbitrarily chosen het/de
11:14:46 <p_l> after 3 years of learning german I'm thinking of removing "basic german" from CV
11:14:47 <koeien> beelsebob: it's not arbitrary! :P
11:14:57 <koeien> i never do it wrong
11:15:10 <beelsebob> koeien: o.O if you can provide a logic behind it I'll come give you a blowjob!
11:15:13 <roconnor> beelsebob: I thought there was a map from german genders to dutch genders.
11:15:16 <Jedai> p_l: I can understand that... ^^
11:15:28 <beelsebob> roconnor: not that I know of
11:15:35 <koeien> beelsebob: there is a mapping from words to {M,F,N}
11:15:36 <p_l> I understood more of japanese after 2 years of not very diligent studying
11:15:50 <beelsebob> koeien: no there's not
11:15:51 <beelsebob> :P
11:15:55 <koeien> almost ;)
11:15:58 <johh> jedai: no, think of gläschen
11:16:07 <beelsebob> dutch has gendered/non-gendered, not masculin/feminine/neuter
11:16:15 <koeien> beelsebob: that is not true
11:16:22 <beelsebob> o.O
11:16:27 <Jedai> johh: What's the problem with it ?
11:16:36 <hatds> o.O
11:16:38 <beelsebob> plenty of dutch/belgian people have told me this... now I'm *really* confused
11:16:51 <koeien> beelsebob: yes. the articles are for M and F are the same
11:17:12 * beelsebob ponders if those statements are equivalent
11:17:15 <johh> its a little glass but spoken gläs-chen not glä-schen
11:17:20 <koeien> but, if you want to refer to a word, you will need hij/zij/het ('he'/'she'/'it')
11:17:22 <beelsebob> no... not quite
11:17:39 <mauke> das Naschen / das Näschen
11:17:43 <beelsebob> koeien: can you give an example where you'd use that?
11:17:47 <koeien> or, zijn/haar ('his'/'her')
11:17:58 <roconnor> koeien: I though the Dutch had given up on using zij for objects.
11:18:12 <pejo> johh, what is the middle character there?
11:18:14 <roconnor> at least that's how I remember being taught Dutch.
11:18:24 <koeien> beelsebob: 'De regering kwam bijeen. Zij besloot...'
11:18:34 <mauke> pejo: &auml;
11:18:38 <johh> pejo: ä?
11:18:45 <beelsebob> oh, I'd been told to use het in that situation koeien
11:18:52 <beelsebob> difference with flemmish?
11:18:58 <koeien> roconnor: 'Het'? That's really strange
11:18:59 <pejo> johh, yeah.
11:19:10 <roconnor> koeien: How old are you? :P
11:19:13 <koeien> roconnor: 22 :P
11:19:22 <roconnor> well, there goes that theory
11:19:22 <johh> its between a and e like in hair
11:19:36 <beelsebob> roconnor: what I've been taught and what you've been taught seem to agree though
11:19:47 <beelsebob> who taught you, a dutch man, or a belgian?
11:19:57 <pejo> johh, well, mauke answered my question. :-)
11:20:19 <roconnor> beelsebob: I was taught Dutch 4 years ago in the netherlands.
11:20:26 <beelsebob> hmm
11:20:29 <roconnor> not that I learned it very well.
11:20:29 <beelsebob> :/
11:20:33 <beelsebob> well ditto
11:20:38 <beelsebob> maybe we've both been given the simple version?
11:20:51 <koeien> i confess that most people might do the above example wrong
11:20:52 * beelsebob tends to trust the dutch speaker telling us how it is
11:21:08 <roconnor> beelsebob: I don't think so
11:21:14 <beelsebob> koeien: so is it true then that the gendering is roughly equivalent to german?
11:21:23 * beelsebob tries to think of an example where they don't match up
11:21:33 <roconnor> beelsebob: when I accidentally used "haar", my teacher would say that is correct, but the old way of speaking.
11:21:47 <beelsebob> oh, interesting
11:21:48 <koeien> roconnor: maybe i'm old-fashioned :)
11:22:29 <koeien> beelsebob: roughly
11:22:42 <beelsebob> neat
11:22:48 <beelsebob> that makes life much easier for me then
11:22:53 <koeien> beelsebob: less inflection
11:23:01 <beelsebob> I know a decent number of german genders
11:23:06 <koeien> no 'cases' (except in some old expressions)
11:23:13 <mauke> I only know three
11:23:48 <koeien> but i'm not sure how well the genders translate between dutch and german
11:23:56 <roconnor> koeien: I find it hard to believe you are old-fashioned at the age of 22.
11:24:06 <JoshTriplett> @pl \(x,y) -> (y,x)
11:24:06 <roconnor> I wonder if it is a loction thing.
11:24:06 <lambdabot> uncurry (flip (,))
11:24:07 <p_l> roconnor: quite possible
11:24:24 <p_l> roconnor: depends on what you read/watch etc :)
11:24:26 <roconnor> koeien: but it is true that I was taught Dutch much more recently than you.
11:24:31 * beelsebob speaks old fassioned english at 26
11:24:47 <beelsebob> I've not met anyone else who actually manages to get who/whom and less/fewer right
11:24:58 <roconnor> I'm pretty good at who/whom
11:25:00 <mauke> hah. trivial, my dear watson
11:25:06 <koeien> beelsebob: less/fewer is confusing for me as well, they are the same in dutch
11:25:14 <beelsebob> koeien: yeh, I can get it for dutch people
11:25:19 <mauke> you use "who" for "wer" and "whom" for "wen" and "wem"
11:25:29 <beelsebob> what I can't understand is that british people can't get it when they *can* get more/many
11:25:38 <beelsebob> much/many even
11:25:41 <monochrom> gender, singular/plural, countable/uncountable, prepositions are all language scams.
11:25:42 <hatds> people say 'whom' is on its way out
11:25:56 <roconnor> hatds: that could be true.
11:26:14 <beelsebob> monochrom: I'm unconvinced by the singular/plural one, but I'm not sure I can give you an ambiguous example
11:26:27 <beelsebob> perhaps the sheep/sheep thing proves I can't
11:26:31 <mmorrow_> in 99% of speaking situations i wouldn't use whom, even if i know it to be "correct"
11:26:38 <koeien> roconnor: but of most words i don't even know the gender. only whether it's masculine or feminine
11:26:47 <koeien> roconnor: ehm, either M/F or N
11:26:59 <monochrom> We Chinese do find without singular/plural.
11:27:04 <koeien> yes, i heard that
11:27:04 <monochrom> s/find/fine/
11:27:04 <roconnor> koeien: that's good.
11:27:12 <koeien> monochrom: also, without articles
11:27:14 <koeien> right?
11:27:18 <monochrom> Yes.
11:27:43 <monochrom> First-order logic also do fine without language scams.
11:28:00 <koeien> but, how would you describe first-order logic without natural language?
11:28:12 <monochrom> use Chinese. :)
11:28:22 <beelsebob> koeien: isn't the question "how would you define it without natural language with plurals"
11:28:25 <mauke> ☯
11:29:09 <monochrom> The first-order logic example is to dispell the myth "without singular/plural you get ambiguity". It doesn't say you should teach first-order logic to new born babies.
11:29:33 <beelsebob> (you should though)
11:29:35 <beelsebob> :P
11:29:42 * dsouza now using unifont :-)
11:29:47 <koeien> ok
11:29:59 <mauke> ｅｘｃｅｌｌｅｎｔ
11:30:11 * beelsebob taps fingers together
11:40:00 <mmorrow_> , let (yin,yang) = fix (\x -> (Node()[snd x],Node()[fst x])) in vacuum yin == vacuum yang
11:40:02 <lunabot>  True
11:41:05 <mauke> :t Node
11:41:06 <lambdabot> forall a. a -> Forest a -> Tree a
11:41:18 <opqdonut> Node?
11:41:21 <opqdonut> :t Node
11:41:22 <lambdabot> forall a. a -> Forest a -> Tree a
11:41:25 <mauke> ...
11:41:35 <opqdonut> heh
11:42:10 <mmorrow_> , levels (fix (\x -> Node () [x,x]))
11:42:12 <lunabot>  [[()],[(),()],[(),(),(),()],[(),(),(),(),(),(),(),()],[(),(),(),(),(),(),...
11:42:37 <mmorrow_> , fmap length (levels (fix (\x -> Node () [x,x])))
11:42:40 <lunabot>  luna: out of memory (requested 1048576 bytes)
11:42:43 <mmorrow_> , take 10 $ fmap length (levels (fix (\x -> Node () [x,x])))
11:42:45 <lunabot>  [1,2,4,8,16,32,64,128,256,512]
11:43:10 <mmorrow_> , vacuum (fix (\x -> Node () [x,x]))
11:43:12 <lunabot>  [(0,[1,2]),(1,[]),(2,[0,3]),(3,[0,4]),(4,[])]
11:44:36 <mmorrow_> Tree is the only thing in the stdlibs that's recursive with more than one way to go (that i can think of)
11:48:05 <adam123> is this a (noteworthy) bug? -> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2438#a2438
11:48:16 <adam123> (GHC bug?)
11:48:35 <mmorrow> heh
11:48:41 <mauke> not a bug, I'd say
11:48:42 <roconnor> I don't think so myself
11:48:56 <bombshelter13_> Can anyone recommend me a good introduction to category theory, maybe a book that starts at a fairly introductory level? It seems kind of important to full understanding of haskell, so i'd like to learn more about it...
11:49:25 <roconnor> it's not really important to understand haskell.
11:49:33 <duaneb> hi people
11:49:42 <duaneb> cabal is ignoring my .cabal/config, I think
11:50:00 <duaneb> I have it marked to look in /opt/local/include for headers, but it still can't find gmp.h
11:50:07 <duaneb> and yes, gmp.h DOES exists there
11:50:30 <mmorrow> it's probably looking in $HOME/Pictures or something for it :/
11:50:35 * mmorrow ducks
11:50:38 <roconnor> bombshelter13_: but Category Theory does have a lot of good ideas in it, that are applicable to Haskell.
11:50:57 <bombshelter13_> roconnor: yeah, it seems to have inspired a lot of the design decisions
11:51:26 <mauke> export CPATH=/opt/local/include
11:51:28 <roconnor> Sadly I've never found a good introduction to Category Theory
11:51:29 <stroan> bombshelter13_: Basic Category Theory for Computer Scientists
11:52:21 <duaneb> mauke: yea, but why does the .cabal/config file not work?
11:52:36 <mauke> no idea
11:53:08 <bombshelter13_> Hmm, I  saw that one, yeah... looked pricey for a smallish book, so I didn't wanna get it without at least a recommendation that it was actually decent
11:53:11 <dons> bombshelter13_: its not important to understand haskell, any more than it is important for say, erlang. certainly it won't hurt you.
11:53:15 * cypher- is looking forward to the next year's course at his uni: CT for CS and Adv CT for CS :D
11:53:19 <duaneb> mauke: thanks, though
11:53:30 <duaneb> Also, completely random: is there a pocket reference to haskell?
11:53:48 <cypher-> bombshelter13_: you can find quite a few lecture notes online
11:54:13 <cypher-> bombshelter13_: some of them very comprehensive, could make a book easily, except that they are free
11:54:14 <dons> duaneb: yeah, the haskell 'cheatsheet' on hackage.
11:54:29 <dons> duaneb: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CheatSheet
11:54:35 <duaneb> I mean, I have the Zvon things
11:54:37 <bombshelter13_> duaneb: cypher-: yeah, it just seems tricky to sort out the ones that are appropriate for beginners
11:54:37 <duaneb> thing*
11:54:38 <mauke> http://hackage.haskell.org/trac/ghc/ticket/3121 - related?
11:55:03 <monochrom> If you want category theory, the short book "basic category theory for computer scientists" is good.
11:55:12 <duaneb> mauke: what's the CPATH for libraries?
11:55:15 <duaneb> Same issue for linking
11:55:16 <cypher-> bombshelter13_: http://www.cl.cam.ac.uk/~gw104/catnotes.ps
11:55:23 <cypher-> bombshelter13_: here's an example ^
11:55:31 <bombshelter13_> cool, I'll give that a read :)
11:55:40 <bombshelter13_> monochrom: yeah, with two recommendations so far I think i'll pick it up :)
11:56:57 <mauke> LD_LIBRARY_PATH maybe?
11:57:32 <pejo> duaneb, LDFLAGS might be what you're looking for.
11:57:32 <dons> have people read and commented on SPJs + Oleg + CCShan's new paper? http://www.reddit.com/r/programming/comments/8kygl/fun_with_type_functions_oleg_kiselyov_ken_shan/
11:57:34 <cypher-> can someone recommend very short (but good) introduction to modal logic?
11:58:55 <duaneb> pejo: thanks, that appears to work
11:59:31 <mux> dons: hiya there! I did read it and found it very nice
11:59:34 <duaneb> anyone here work on LHC?
11:59:42 <dons> Lemmih does.
11:59:47 <dons> he's the L in LHC
11:59:50 <duaneb> of the haskell variety, not higgs boson
12:00:05 <monochrom> "God's haskell compiler"? :)
12:00:11 <duaneb> Lemmih: you guys interested in a new backend?
12:00:29 <mauke> Lemmih Hadron Collider
12:00:41 <mux> dons: I really like their typed printf implementation
12:00:46 <dons> whole program compilers are somewhat like 'colliders'
12:00:56 <dons> anything we can rip out and put on hackage?
12:01:07 * dons hates to see type correct code in papers, but not on hackage
12:02:22 <mux> dons: have you seen the bsd-sysctl package I uploaded today? you could use it in cpuperf to get the sysctl at the library level :)
12:05:07 <duaneb> anyone else really hate darcs?
12:05:08 * duaneb ducks
12:05:14 <duaneb> just kidding
12:05:24 <duaneb> but seriously, is there an Hg community here?
12:05:28 <duaneb> or at least git? :/
12:05:32 * cypher- likes perforce, but it's quite exensive
12:05:36 <cypher-> *expensive
12:05:40 <duaneb> cypher-: yea
12:05:44 <duaneb> nice build system, though :P
12:05:47 * duaneb hearts perforce jam
12:06:05 <cypher-> the only thing I hate is CVS + whole software layer on top of it that one of my former employers used
12:06:10 <TomMD> duaneb: One of the best known Haskellers is a centrail mercurial dev, so you don't get kicked for voicing a different opinion.
12:06:15 <cypher-> I still have nightmares
12:06:24 <TomMD> s/sentrail/central
12:06:29 <TomMD> err, yeah
12:07:03 <saleop> Hey guys. Is there a way to set up ghci to start up with whatever prompt you want it to have?
12:07:08 <duaneb> Yea, I really don't mind USING darcs, I just couldn't fit my workflow into it
12:07:14 <duaneb> the lack of branching is... unfortunate
12:07:26 <duaneb> true branching, anyway
12:07:28 <TomMD> saleop: You can add commands to the .ghci file, which is loaded at startup.
12:07:32 * koeien likes hg a bit more than darcs, but hates git
12:07:35 * trofi always complains on darcs' speed
12:07:47 <Cale> saleop: By that do you just mean the prompt, or do you mean loading modules? Both are possible.
12:07:58 <dons> mux: yeah, possible.
12:08:11 <dons> yes, we have both core darcs and core hg devs
12:08:13 <TomMD> @users
12:08:14 <lambdabot> Maximum users seen in #haskell: 658, currently: 606 (92.1%), active: 23 (3.8%)
12:08:15 <saleop> Cale: just the prompt..
12:08:36 <cypher-> oh, something that I relly need: what is the best unification algorithm that one can execute by hand?
12:08:54 <Cale> saleop: You can just add an appropriate :set prompt line to your .ghci
12:08:58 <mauke> echo ':set prompt "C:\>"' >> ~/.ghci
12:09:11 <mmorrow> hah
12:09:16 <mmorrow> DIR
12:09:17 <saleop> ooh
12:09:40 * mmorrow is tempted by that
12:09:48 <saleop> this is really dumb, but i don't know where my .ghci is :x
12:09:56 <mauke> in ~
12:10:03 * duaneb wishes you could have things like (*) :: (Num a) => String => a -> String
12:10:04 <Cale> saleop: It might not exist yet.
12:10:04 <TomMD> saleop: Are you on windows?
12:10:05 <mmorrow> it doesn't exist unless you've made it
12:10:09 <saleop> TomMD: os x
12:10:15 <saleop> it's in ~? ok..
12:10:15 <duaneb> and vice versa, of course
12:10:31 <bombshelter13_> that is why he said ~/.ghci, yeah...
12:10:40 <mauke> duaneb: and what is "foo" * 0.5?
12:11:04 <mmorrow> > fix error
12:11:06 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
12:11:35 <duaneb> mauke: ok, (Integral a) => String -> a -> String
12:11:38 <adamvo> > replicate 0.5 "foo"
12:11:39 <lambdabot>       No instance for (Fractional Int)
12:11:39 <lambdabot>        arising from the literal `0.5' ...
12:11:50 <adamvo> > replicate 6 "foo"
12:11:51 <mmorrow> @type
12:11:52 <lambdabot>   ["foo","foo","foo","foo","foo","foo"]
12:11:52 <lambdabot> <no location info>: not an expression: `'
12:11:55 <mauke> duaneb: "foo" * (-2)
12:11:56 <TomMD> > let s = "foo" in take (fromIntegral $ fromIntegral (length foo) * 0.5) foo
12:11:58 <lambdabot>   Not in scope: `foo'Not in scope: `foo'
12:11:58 <vixey> "fooooooooooooooooooooooooooooo"
12:11:59 <duaneb> but "foo" * 5 would be replicate 5 "foo"
12:12:00 <mmorrow> @type \x -> (++ show x)
12:12:01 <lambdabot> forall a. (Show a) => a -> [Char] -> [Char]
12:12:08 <TomMD> > let s = "foo" in take (fromIntegral $ fromIntegral (length s) * 0.5) s
12:12:08 <kyevan> Hmm... is there a "replicate indefinately"?
12:12:09 <lambdabot>   Add a type signature
12:12:11 <mmorrow> @type \x -> (show x ++)
12:12:13 <lambdabot> forall a. (Show a) => a -> [Char] -> [Char]
12:12:13 <koeien> kyevan: repeat
12:12:14 <vixey> > cycle "foo"
12:12:15 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
12:12:21 <Cale> > repeat "foo"
12:12:22 <adamvo> > repeat "pew"
12:12:22 <lambdabot>   ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","f...
12:12:23 <duaneb> > replicate -2 "foo"
12:12:23 <lambdabot>   ["pew","pew","pew","pew","pew","pew","pew","pew","pew","pew","pew","pew","p...
12:12:24 <lambdabot>       No instance for (Num (Int -> a -> [a]))
12:12:24 <lambdabot>        arising from a use of `-...
12:12:26 <mmorrow> @type \x -> flip (++ show x)
12:12:28 <lambdabot>     Couldn't match expected type `b -> c'
12:12:28 <lambdabot>            against inferred type `[Char]'
12:12:28 <lambdabot>     In the first argument of `flip', namely `(++ show x)'
12:12:35 <Cale> > replicate (-2) "foo"
12:12:37 <lambdabot>   []
12:12:45 <Jedai> mauke: mauke: Perl would tell you that "foo" * 0.5 is ""
12:12:47 <duaneb> there ye go :P
12:12:47 <kyevan> > cycle [1, 2, 3]
12:12:49 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
12:13:04 <mauke> Jedai: I don't think so
12:13:06 <kyevan> There you go. That's how you count 3/4 time. IS THAT SO HARD? :P
12:13:12 <mauke> Jedai: it's 0
12:13:16 <kyevan> > repeat [1,2,3]
12:13:17 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1...
12:13:19 <TomMD> @check \x -> cycle (x ++ " ") == unwords (repeat x)
12:13:23 <kyevan> If you prefer to see measures :J
12:13:26 <lambdabot>   mueval: Time limit exceeded
12:13:39 <kyevan> Also... how does Lambdabot handle infinite lists?
12:13:39 <Jedai> mauke: Well "foo" x 0.5
12:13:47 <trofi> kyevan: lazily
12:13:56 <koeien> kyevan: just as all haskell programs do
12:13:57 <TomMD> kyevan: Just see my previous test
12:14:04 <Jedai> mauke: Since it's obviously what duaneb wanted to do
12:14:11 <kyevan> No, I mean, how does she handle *displaying* them.
12:14:13 <kyevan> :P
12:14:22 <roconnor> > [1..
12:14:23 <lambdabot>   <no location info>: parse error on input `;'
12:14:24 <roconnor> > [1..]
12:14:26 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
12:14:28 <koeien> > replicate 10000000 1
12:14:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
12:14:31 <kyevan> Does she do her own display of them, 'giving up' at a certain point?
12:14:37 <koeien> there is a max output size i guess
12:14:39 <Jedai> mauke: Of course * is a numeric operator so force a numeric context on its arguments
12:14:40 <mauke> take 100 . show
12:14:47 <trofi> > take 100 $ show [1..]
12:14:48 <lambdabot>   "[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
12:14:53 <trofi> nothing special
12:14:54 <kyevan> Oh, that'd work :J
12:15:13 <mauke> > let x = flip replicate in "foo" `x` 3
12:15:14 <lambdabot>   ["foo","foo","foo"]
12:15:17 <Cale> > length "[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,"
12:15:18 <lambdabot>   75
12:15:29 <koeien> > let fact n = product [1..n] in fact 1000000
12:15:31 <lambdabot>   * Exception: stack overflow
12:15:38 <koeien> doh
12:16:02 <Cale> > let fact n = foldl' (*) 1 [1..n] in fact 1000000
12:16:05 <mmorrow> , let mutual f g a = f a (\b -> g b (\a -> mutual f g a)) in mutual (\x k -> x ++ k " HAI") (\x k -> x ++ k " OH") "OH"
12:16:07 <lunabot>  "OH HAI OH HAI OH HAI OH HAI OH HAI OH HAI OH HAI OH HAI OH HAI OH HAI OH...
12:16:17 <lambdabot>   thread killed
12:16:18 <koeien> > 10^75 :: Integer
12:16:20 <lambdabot>   1000000000000000000000000000000000000000000000000000000000000000000000000000
12:16:24 <koeien> > 10^80 :: Integer
12:16:27 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
12:16:31 <mmorrow> > 10 ^ 400
12:16:32 <koeien> lists are not special
12:16:34 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
12:16:39 <bombshelter13_> kyevan: maybe she takes x items from the list, strings it, and takes 2x characters from it, where 2x is her maximum display length in characters, such that even if each item in the list is 1 char long she still gets enough to fill her output size
12:17:04 <kyevan> Yeah. I just wasn't thinking of take :J
12:17:04 <Cale> No, it's just taking a certain amount of the show of the list.
12:17:26 <adamvo> > fix show
12:17:29 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
12:17:39 <mmorrow> cat /dev/uranom | od | head -40
12:17:54 <beelsebob> @src product
12:17:54 <lambdabot> product = foldl (*) 1
12:18:02 <beelsebob> hmm... isn't that the worst of both worlds
12:18:03 <trofi> @dst /dev/null
12:18:03 <lambdabot> Maybe you meant: ask dict ft let list msg
12:18:17 <kyevan> Hmm...
12:18:22 <beelsebob> we still get stack overflows, and we can't lazily check if lazy numbers are greater than a certain amount
12:18:29 <beelsebob> i.e. shouldn't it be a foldr if we want to be lazy
12:18:31 <halberd> does anybody know of any work on the modification of a proof for a statement S, to prove instead a slightly different statement S'?
12:18:41 <halberd> modification by a computer
12:19:03 <kyevan> map (\x -> \y -> y + x) [1..]
12:19:20 <halberd> i.e. computer program gets as input S and a proof for S, and the statement S' which is similar to S, and the desired output is a proof for S'
12:19:29 <kyevan> That would give you an infinite list of 'add_n_'s, right?
12:19:43 <adamvo> ?type map (+) [1..]
12:19:46 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
12:19:48 <vixey> halberd that sounds like hard work
12:19:52 <koeien> kyevan: let's look at the types.
12:19:58 <vixey> halberd is a proof of   even 2  similar to a proof of  even 3 ?
12:20:05 <koeien> adamvo: almost, it's map (flip (+)) [1..]
12:20:13 <halberd> vixey you are using some unicode symbol I can't see
12:20:18 <vixey> no I'm not
12:20:25 <halberd> [15:19:50]  <vixey> halberd is a proof of   even 2  similar to a proof of  even 3 ?
12:20:31 <vixey> that's what I wrote
12:20:34 <koeien> i don't see anything strange there ?
12:20:38 <halberd> oh
12:20:46 <halberd> well I'm assuming S and S' are both true
12:21:10 <halberd> and that they are similar in a way that changing the structure of the proof for S slightly will prove S'
12:21:14 <vixey> if they are both true who cares
12:21:19 <vixey> proofs are not needed
12:21:22 <koeien> vixey: ?
12:21:28 <koeien> what a strange statement
12:21:32 <adamvo> you and your floating-point-non-commutative number non-algebras
12:21:33 <vixey> If something is true you don't have to prove it
12:21:40 <halberd> maybe you aren't sure it's true
12:21:47 <vixey> but you said you are sure
12:21:52 <mauke> vixey: of course you do
12:21:54 <halberd> maybe the program is allowed to fail if it can't find a way to modify the proof for S to get a proof for S'
12:22:16 <halberd> the reason for failure might be, S' is true but dissimilar to S, or S' is false (or S' is just unprovable)
12:22:40 <davidmccabe> What is the distinction if any between String and [Char]?
12:22:45 <koeien> davidmccabe: none.
12:22:46 <byorgey> davidmccabe: none.
12:22:46 <mmorrow> none
12:22:57 <halberd> habit
12:23:00 <beelsebob> the letters used when you type it
12:23:01 <byorgey> String is a synonym for [Char], as if it had been declared  type String = [Char]
12:23:04 <koeien> type String = [Char]
12:23:08 <adamvo> @check (\x y -> x+y == (y+x::Double))
12:23:09 <halberd> nun nun nun habit
12:23:11 <lambdabot>   "OK, passed 500 tests."
12:23:14 <davidmccabe> Then why do I get, Couldn't match expected type `String' against inferred type `[a] -> [Char]' In the first argument of `putStrLn', namely ... ?
12:23:19 <mmorrow> @check
12:23:21 <lambdabot>   <no location info>: parse error on input `;'
12:23:27 <mauke> davidmccabe: because String is [Char], not [a] -> [Char]
12:23:28 <vixey> um.. because of the  [a] ->   bit?
12:23:29 <beelsebob> davidmccabe: because while String and [Char] are the same...
12:23:34 <koeien> davidmccabe: because String is different from [a] -> String
12:23:35 <beelsebob> [a] -> [Char] is not [Char]
12:23:37 <mmorrow> @check \x y z -> (x+y)+z == x+(y+z::Double)
12:23:39 <lambdabot>   "Falsifiable, after 17 tests:\n1.2\n2.6666666666666665\n3.2\n"
12:23:45 <halberd> also vixey there are many cases where there are statements you are pretty sure are true, but are nonetheless very interested in a proof of
12:23:52 <davidmccabe> Wow, you make a chorus. :)
12:24:03 <koeien> mmorrow: not being associative is even worse than noncommutativity :(
12:24:05 <byorgey> davidmccabe: it looks like you are trying to pass a function to putStrLn.  maybe you forgot an argument?  or maybe you need parentheses
12:24:06 <duaneb> how can I allow the bang strictness-modifier?
12:24:10 <davidmccabe> Oh, it's an operator precedence problem.
12:24:12 <mmorrow> @check \x -> x == (x+pi::Double)-pi
12:24:13 <halberd> for example, in the construction of programs from formal specifications
12:24:14 <davidmccabe> I needed to add a $.
12:24:15 <lambdabot>   "Falsifiable, after 6 tests:\n2.3333333333333335\n"
12:24:24 <koeien> duaneb: {-# LANGUAGE BangPatterns #-}
12:24:36 <byorgey> davidmccabe: yup, that ought to do it.  otherwise  'putStrLn foo x' is parsed as '(putStrLn foo) x'
12:24:44 <halberd> the formal specification is most likely a true statement (i.e. there is a program which satisies it) but you are still very interested in the program that satisfies it
12:24:47 <mmorrow> koeien: heh
12:24:53 <duaneb> koeien: thanks
12:24:58 <davidmccabe> thanks byorgey, mauke, beelsebob, koeien.
12:25:00 <halberd> that program being a proof of the specification
12:25:13 <monochrom> That is only one way to write a formal specification.
12:25:15 <kyevan> data MyString = SN Char MyString | EndString
12:25:31 <kyevan> Look, I defined a string that's not [Char]! It's just structurally identical :J
12:25:51 <halberd> monochrom: tell me another way
12:26:07 <byorgey> kyevan: that is a string but not a String =)
12:26:32 <mauke> Fix (Either () `O` (,) Char)
12:26:44 <trofi> @instanceOf String
12:26:46 <lambdabot> Couldn't find class `String'. Try @instances-importing
12:26:48 <kyevan> Oh that reminds me...
12:27:07 <kyevan> Is there a way to do a constructor that can take a subset of integers?
12:27:16 <kyevan> Like... only 1-20, or something?
12:27:32 <kyevan> Or only whole numbers. Or, yeah :J
12:27:40 <koeien> whole numbers already exists
12:27:51 <koeien> that's called Integer :)
12:27:51 <monochrom> Another way is to let free variables stand for inputs and outputs. Implementation is implied-by. For example "the output should be bigger than the input": x'>x.  If I implement it by increasing by 1, I have to prove the implication: x'<x implied-by x'=x+1
12:28:08 <koeien> kyevan: but in general in believe that the answer is no
12:28:10 <monochrom> See also http://www.cs.toronto.edu/~hehner/aPToP/
12:28:41 <kyevan> Integer is NOT whole numbers, koeien...
12:28:44 <koeien> kyevan: you can do 'smart constructors', e.g.  newtype RestrictedInt = RI Int  ; makeRI :: Int -> Maybe RestrictedInt
12:28:46 <bombshelter13_> i thought it was generally defined what whole numbers could not be negative?
12:28:50 <kyevan> > -1 :: Integer
12:28:53 <lambdabot>   -1
12:29:03 <kyevan> > 0 :: Integer
12:29:06 <halberd> okay monochrom, but isn't that the same thing with just different notation? you're still specifying a type for the program
12:29:06 <lambdabot>   0
12:29:10 <koeien> kyevan: in that case i am curious. what is your definition of 'whole number' ?
12:29:16 <kyevan> If Integer was whole numbers, those would be invalid.
12:29:25 <kyevan> Whole numbers are integers greater than zero.
12:29:28 <mauke> you're all insane
12:29:32 <halberd> i.e. you're implicitly saying that the program has the type of functions that return values greater than their inputs
12:29:35 <kyevan> [1..] in haskell.
12:29:46 <mauke> kyevan: your definitions are wrong
12:29:47 <bombshelter13_> hmm, I've always heard [0..] for whole
12:30:07 <kyevan> Oh, yeah, greater than or equal to.
12:30:11 <bombshelter13_> but known that it's ambiguous
12:30:12 <koeien> kyevan: ok, i see the whole numbers as the set Z = {...,-2,-1,0,1,2,...}
12:30:14 <kyevan> I mixed up whole and natural.
12:30:22 <kyevan> koeien: That's integers.
12:30:22 <vixey> 'whole numbers' is vauge
12:30:32 <koeien> kyevan: yes. integers = whole numbers.
12:30:35 <vixey> even 'natural numbers' is vauge
12:30:39 <koeien> i would regard 0 as natural, but some authors do not do that
12:30:40 <monochrom> "<halberd> the formal specification is most likely a true statement" does not apply to x'>x
12:30:55 <vixey> 0 being 'natural' means you're a computerologist
12:30:59 <koeien> anyway, there is no such thing without doing smart constructors or using dependent types.
12:31:09 <halberd> the statement made by that formal specification is,  "there exists a function P where P(x) > x"
12:31:10 <kyevan> :/
12:31:15 <monochrom> And in this method we are not interested in "∃x'. x'>x" either.
12:31:24 <koeien> kyevan: i would find it useful to have such a thing sometimes.
12:31:26 <monochrom> No.
12:31:32 <koeien> the problem is that functions like - become partial
12:31:36 <monochrom> x' is a free variable. there is not "there exists".
12:31:46 <davidmccabe> Is there a function that acts like id for strings and show for other types?
12:31:50 <bombshelter13_> Or, for 1..20, you could take the lame rout and do 'data smallInts = SI 1 | SI 2 | SI 3 | SI 4 | SI 5 ...'
12:31:55 <kyevan> Howso, Koeien?
12:31:56 <bombshelter13_> but this gets unwieldly for large ranges
12:32:00 <halberd> okay but if you were to write the same constraint as a type, isn't that the statement you would get?
12:32:01 <koeien> kyevan: what is 2-3 ?
12:32:07 <kyevan> -1.
12:32:10 <kyevan> But...
12:32:13 <koeien> but that is not a natural number
12:32:16 <mauke> davidmccabe: impossible, unless you define separate instances for every other type
12:32:22 <kyevan> > type (-)
12:32:24 <lambdabot>   <no location info>: parse error on input `type'
12:32:27 <kyevan> er...
12:32:29 <monochrom> If I write a type, I still do not get a quantifier.
12:32:35 <kyevan> :type (-)
12:32:48 <hatds> >:t (-)
12:32:49 <bombshelter13_> > :t (-)
12:32:50 <kyevan> ... Gah, I forget how to get types out of lambdabot :P
12:32:51 <lambdabot>   <no location info>: parse error on input `:'
12:33:03 <koeien> :type subtract
12:33:10 <duaneb> could someone explain `error` to me?
12:33:20 <halberd> types can have quantifiers
12:33:21 <hatds> ?type (-)
12:33:24 <lambdabot> forall a. (Num a) => a -> a -> a
12:33:25 <koeien> duaneb: yes. error is just a fancy way to do encode "bottom"
12:33:27 <kyevan> Anyway, - doesn't take arbetrary types that have a number in them
12:33:28 <mauke> duaneb: it's like abort() in C, except with an error message
12:33:35 <halberd> well
12:33:39 <duaneb> mauke: I understand that
12:33:41 <duaneb> I mean "how"
12:33:48 <mauke> @src error
12:33:49 <lambdabot> error s = throw (ErrorCall s)
12:33:57 <halberd> the type in that case would represent the set of programs whose output is greater than their input
12:34:00 <duaneb> but doesn't that have side effects?
12:34:10 <duaneb> shouldn't it be wrapped in  a monad or something?
12:34:13 <halberd> and constructing a program with that type, proves that the set is nonempty
12:34:25 <mauke> duaneb: in some sense yes, but Haskell isn't total anyway
12:34:28 <koeien> duaneb: does   f = f   have side effects?
12:34:29 <monochrom> Here is x'>x translated to type in PVS notation.  (x:int) -> {x':int | x'>x}.  There is no "there exists".
12:34:33 <duaneb> koeien: no
12:34:42 <duaneb> wait
12:34:44 <kyevan> basically... I'm looking for a shortcut for data Foo = F1 | F2 | F3 | F4 | F5 | F6 | F7...
12:34:48 <duaneb> no
12:34:51 <duaneb> wait
12:34:52 <duaneb> shit
12:34:53 <koeien> duaneb: except that your computer gets hotter ;)
12:34:59 <duaneb> yes, it has a stack overflow!
12:35:00 <halberd> there's an implicit forall... it's forall x
12:35:05 <kyevan> duaneb: error basically means "OH SHIT BREAK THE SYSTEM"
12:35:17 <grahamhutton> dunaeb: nontermination (i.e. partiality) is an effect...
12:35:21 <duaneb> oh, so at that point, purity is fucked anyway? :P
12:35:31 <duaneb> what's the "nice" way to throw an error?
12:35:32 <koeien> duaneb: exceptions are caught in the IO monad
12:35:32 <duaneb> Maybe?
12:35:39 <mauke> duaneb: throwIO
12:35:40 <kyevan> WEll
12:35:45 <kyevan> More "Your program is fucked"
12:35:48 <koeien> duaneb: so there is not really a problem
12:35:56 <grahamhutton> http://cs.ioc.ee/~tarmo/tday-veskisilla/uustalu-slides.pdf
12:35:58 <kyevan> Error is basically intentional crashing :J
12:36:03 <halberd> the way I learned type theory, a type is considered the same as the set of programs which are proofs for that type
12:36:17 <duaneb> Oh, I see, so if you're willing to recognize the error, you also need to accept the impurity of the actions
12:36:31 <halberd> and constructing a program with that type, shows that the set is nonempty
12:36:31 <koeien> if you want to catch it, you are in the IO monad, yes
12:36:46 <mauke> I think catching error is a bad idea
12:37:02 <koeien> mauke: agreed. except perhaps on a very highlevel, where you can restart the program
12:37:16 <halberd> well
12:37:19 <kyevan> Well...
12:37:27 <kyevan> Error has no more a side effect than eol
12:37:28 <koeien> but it explains the point of it having 'side effects'
12:37:39 <kyevan> Except that it doesn't 'keep going'
12:38:01 <halberd> I concede that there is more than one way to express a formal specification
12:38:53 <kyevan> (So I guess it's more like EOF)
12:38:56 <halberd> but a specification in one notation, can be translated into another... so they are all equivalent
12:39:55 <kyevan> That reminds me. Couldn't a language be pure even with reassignable variables, as long as those couldn't escape up or down?
12:40:17 <trofi> > let a = 1 in let a = 2 in a
12:40:19 <lambdabot>   2
12:40:38 <koeien> kyevan: you mean "hiding" ?
12:40:43 <kyevan> Yeah. Basically that without lets all over :J
12:40:49 <mauke> kyevan: you mean like ST?
12:40:51 <koeien> there is one difference though
12:40:57 <trofi> or State
12:40:58 <halberd> or with imperative loops
12:40:59 <koeien> > let a = 1 in let a = a + 1 in a -- diverges
12:41:12 <Cale> Hiding old definitions is just confusing though.
12:41:14 <lambdabot>   thread killed
12:41:18 <Cale> Use a different variable name.
12:41:59 <kyevan> I'm just thinking, several of Haskell's "weirdnesses" aren't /actually/ necessary for pure functional with no side effects.
12:42:12 <grahamhutton> kyevan: Haskell has precisely this kind of encapsulated state: http://research.microsoft.com/en-us/um/people/simonpj/papers/state-lasc.ps.gz
12:43:18 <kyevan> Yeah, but my point was more that you could do a 'traditional' syntax with the same semantics :J
12:43:24 <dons> kyevan: yes, see the ST monad.
12:43:34 <dons> syntax is an entirely separate issue.
12:43:56 <Cale> In fact, allowing shadowing at all is perhaps a little questionable, but is sort of necessary to allow for new definitions in modules that you import, or new definitions in the same module not to create errors.
12:44:14 <Cale> But I would try to avoid it normally.
12:44:18 <dons> the amazing thing about ST is that it is just a library :) we didn't have to modify the language to support it. just the type system had to be rich enough to track the property
12:44:21 <kyevan> *nods* But I've seen people state that the syntax is necessary, which it isn't.
12:44:23 <Cale> Er...
12:44:24 <koeien> GHC complains loudly with -Wall
12:44:31 <Cale> ST isn't *just* a library
12:44:49 <koeien> creation of new variables is magical, isn't it?
12:44:51 <dons> well, the key type properties are in userland.
12:45:03 <Cale> Well, yes :0
12:45:05 <Cale> er, :)
12:45:37 <Cale> STRefs are hard to construct without some low-level stuff going in though.
12:45:51 <Cale> (because they can have any type)
12:45:58 <dons> kyevan: i'd be surprised if anyone conflates the syntax and semantics , btw. since that's just wrong.
12:48:24 <njbartlett> Trying to build Leksah on Mac OS... where can I get gtksourceview2?
12:48:56 <dons> hmm. part of gtk
12:49:25 <njbartlett> dons: I've installed gtk2hs (built from source, the macports version didn't work)
12:50:31 <duaneb> so, ah
12:50:39 <duaneb> could someone explain '<-' to me?
12:50:41 <ehird> has wolfram alpha been rewritten in haskell yet?
12:50:42 <duaneb> in a do context?
12:50:48 <koeien> duaneb: do you know what (>>=) is ?
12:50:52 <mauke> duaneb: it's syntactic sugar for >>= \
12:50:52 <dcoutts> njbartlett: the ./configure will tell you if it found the right stuff to be able to build the gtksourceview2 component
12:51:02 <duaneb> hrm :/
12:51:05 <dcoutts> njbartlett: the gtk2hs ./configure I mean
12:51:16 <kyevan> ehird: Eh, why?
12:51:31 <kyevan> Also, ehird: SINE MISSES YOU
12:51:34 <ehird> kyevan: Well, t'was done when Arc came out. I am become Haskell, destroyer of egos.
12:51:40 <ehird> Also, aagh!
12:51:45 <njbartlett> dcoutts: Aha, thanks... it says no
12:52:09 <njbartlett> dcoutts: do I just need to --enable-gtksourceview2?
12:52:36 <dcoutts> njbartlett: yes, do that and it'll tell you what it's missing
12:52:59 <njbartlett> dcoutts: "GtkSourceView-2.0 requirement not met. Perhaps you need to install gtksourceview-2.0 or gtksourceview-devel-2.0"
12:53:54 <dcoutts> njbartlett: right
12:54:17 <dcoutts> it means the C libs
12:54:32 <njbartlett> dcoutts: Yup thanks. Just looking for those now.
12:55:19 <dcoutts> njbartlett: in particular, it's asking the pkg-config program. See pkg-config--list-all. You'll have installed the gtk+-2.0 C libs but not the sourceview ones
12:56:13 <njbartlett> dcoutts:  I don't recall installing gtk+-2.0 :-)
12:56:19 <duaneb> ok, I installed Data.ByteString by cabal
12:56:29 <duaneb> how can I use ghc so that --package points at it?
12:56:45 <koeien> duaneb: -package bytestring. i normally use --make, so that GHC chases dependencies for me
12:57:18 <duaneb> koeien: is it just the lowercase form, or do packages usually have different names?
12:57:39 <koeien> duaneb: it differs. `ghc-pkg list` gives you the answer
12:57:53 <koeien> sometimes it's the same, sometimes different
12:58:00 <koeien> e.g. Cabal is with capital C
12:58:46 <duaneb> koeien: good tip
12:58:48 <koeien> there is no requirement for package X to export a module with X in it
12:58:51 <duaneb> thanks! :)
12:59:14 <koeien> you can use ghc-pkg to hide and unregister packages as well
12:59:19 <adamvo> @hoogle IORef
12:59:20 <lambdabot> module Data.IORef
12:59:20 <lambdabot> Data.IORef data IORef a
12:59:20 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
13:01:51 <duaneb> is this stupid?
13:02:12 <duaneb> (in a do statement: x <- liftM (readInt . (!!0)) getArgs
13:02:28 <koeien> (!!0) = head
13:02:29 <EvilTerran> duaneb, well, (!!0) = head
13:03:10 <EvilTerran> and you'll get an error if someone provides no args, or the first isn't a valid int
13:03:11 <koeien> your program crashes if the result of getArgs is the empty list
13:03:14 <njbartlett> dcoutts: Found, built and installed gtksourceview-2.0, gtk2hs still says it can't be found :-(
13:03:38 <Berengal> njbartlett: You need the developer version
13:03:49 <Berengal> Not just the binaries
13:03:59 <dcoutts> njbartlett: ask pkg-config, that's the definitive thing
13:04:33 <njbartlett> Berengal: I see, thanks. Will try to find that!
13:04:44 <Cale> duaneb: readInt normally has many other parameters doesn't it?
13:05:17 <Cale> duaneb: x will still need to be applied to a few other things
13:05:38 <Cale> :t readInt
13:05:39 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
13:06:11 <myname> exit
13:06:13 <Cale> But I suppose if your intention is to get the base from the commandline args, it's not so bad.
13:06:58 <njbartlett> Berengal: You don't know where I can find that? Google doesn't have a clue
13:07:48 <Berengal> njbartlett: I just use whatever's in the distro repos. Don't know how macports work...
13:08:05 <njbartlett> Berengal: Well, macports never works.
13:10:00 <pejo> (Macports works really well for me, including Haskell stuff).
13:10:19 <duaneb> Cale: I wasn't aware that readInt actually existed
13:10:39 <duaneb> I have readInt defined as readInt = (read :: String -> Int)
13:10:51 <njbartlett> pejo: Yeah I heard stories of macports working, seen no direct evidence of it myself :-)
13:11:22 <kyevan> Macports works, but installing ghc was /slow/
13:11:27 <kyevan> As in, twelve hours >_>
13:11:28 <Cale> duaneb: I suppose it's possible to need to do that, but you normally shouldn't.
13:11:41 <Cale> duaneb: Just using read should work okay normally
13:11:57 <njbartlett> Macports doesnt even seem to have gtksourceview-devel
13:12:14 <duaneb> Cale: yea, but in my example it would be hard to infer the type
13:12:26 <njbartlett> Has anybody managed to get Leksah working on the Mac??
13:16:16 <duaneb> is (++) constant?
13:16:28 <koeien> duaneb: what do you mean?
13:16:35 <duaneb> time-wise
13:16:43 <duaneb> I'm trying to create a tail-call'd function
13:16:53 <koeien> oh. no.
13:16:57 <EvilTerran> duaneb, why?
13:17:00 <Berengal> n ++ m is O(n)
13:17:04 <koeien> lineartime
13:17:07 <vixey> O(length(m))
13:17:13 <duaneb> and (:)?
13:17:16 <vixey> wait I am wrong
13:17:18 <koeien> that's constant
13:17:21 <vixey> you get it first time
13:17:46 <duaneb> wait, so appending is linear, but prepending is constant?
13:17:48 <duaneb> dammit.
13:17:53 <koeien> duaneb: yep.
13:17:53 <Berengal> vixey: Let's compromise and say O(length(n)) ;)
13:18:04 <bremner> duaneb: one reverse at the end is free
13:18:18 <monochrom> O(sqrt(n*m)) is the true compromise. Geometric mean.
13:18:20 <koeien> duaneb: reverse (... reverse ... ), is O(n)
13:18:28 <malouin> Do people use cabal to manage haskell packages system-wide, eg in /usr/local?
13:18:30 <byorgey_> duaneb: if you want fast prepends and appends, you need a different data structure.
13:18:37 <byorgey_> Data.Sequence being one candidate.
13:18:43 <SamB> malouin: sometimes
13:19:08 <dcoutts> malouin: I think most people use it for per-user installs.
13:19:10 <SamB> (possibly even in /usr, where it oughtn't put them ...)
13:19:20 <koeien> malouin: ghc-pkg list  gives some packages installed system-wide. i use it the most for installs in $HOME though
13:19:53 <Berengal> duaneb: (:) and ++ do the same thing. ++ just loops over a list and does (:) to each of the elements
13:20:01 <EvilTerran> duaneb, (:) is prepending a single element, so is O(1); (xs ++ ys) involves (length xs) uses of (:)
13:20:02 <malouin> ok.
13:20:12 <Berengal> I'm not making much sense today...
13:20:21 * SamB got tired of sudoing, and running out of space in /usr, so also set his to default to per-user installs)
13:20:34 <monochrom> "prepend is O(1), append is O(n)" is a counterintuitive way to look at it, and therefore it looks counterintuitive. The intuitive way to look is "x:y" is one prepend and O(1), "xs++y" is n prepends and n*O(1)=O(n).
13:20:39 * SamB realizes he couldn't have put a paren before the EMOTE command ...
13:21:00 * EvilTerran (sometimes approximates it like this)
13:21:31 <mauke> the word "EMOTE" is now banned
13:22:01 <ehird> duaneb: but
13:22:06 <ehird> if you do multiple ++s
13:22:12 <ehird> they'll cascade properly
13:22:17 <ehird> in a recursion
13:22:40 <Berengal> ehird: That depends.
13:22:43 <ehird> well, yes
13:22:46 <ehird> but most of the time
13:22:59 <Berengal> foldl (++) [] is O(n^2) but foldr (++) [] is O(n)
13:23:21 <duaneb> ok
13:23:24 <duaneb> consider this
13:23:33 <duaneb> (wait, maybe I should use foldl....)
13:23:34 <duaneb> anyway
13:23:48 <duaneb> > let rgbbgr arr = rgbbgr' [] arr; rgbbgr' hd [] = hd; rgbbgr' hd (r:g:b:tl) = rgbbgr' (hd ++ (b:g:[r])) tl in rgbbgr [1,2,3,4,5,6]
13:23:49 <lambdabot>   [3,2,1,6,5,4]
13:24:12 <duaneb> I think that should work in O(n^2/3)
13:24:24 <duaneb> O((n^2)/3)
13:24:42 <Berengal> That's O(n^2)
13:24:49 <duaneb> Berengal: yes
13:24:52 <duaneb> that's what I said
13:25:00 <ehird> 21:24 duaneb: O((n^2)/3)
13:25:01 <ehird> no it's not
13:25:10 <duaneb> well, it IS
13:25:16 <ehird> ...?
13:25:25 <duaneb> (n^2)/3
13:25:33 * ehird scratches head
13:25:41 <duaneb> err
13:25:48 <duaneb> yes
13:25:50 <byorgey_> O(n^2 / 3) = O(n^2).
13:26:00 <ehird> hmm
13:26:02 <ehird> well, right
13:26:03 <duaneb> well, whatever
13:26:06 <Berengal> (n^2)/3 /= n^2, but O((n^2)/3) ≃ O(n^2)
13:26:15 <byorgey_> so, from a semantic point of view, that IS what duaneb said.  but not from a syntactic point of view. =)
13:26:24 <duaneb> it's /3 because it only calls (++) once every three entries
13:26:31 <duaneb> and all other operations are constant
13:26:38 <duaneb> (recursive call is, of course, linear)
13:27:00 <duaneb> so n * (n/3) == (n*n)/3 = (n^2)/3
13:27:12 <duaneb> anyway
13:27:16 <duaneb> how can I make it linear?
13:27:22 <duaneb> It's definitely a linear problem
13:28:25 <Berengal> concat . map reverse . takeWhile (not null) . map (take 3) . iterate (drop 3)
13:28:34 * duaneb wimpers
13:28:36 <duaneb> whimpers*
13:28:49 <Berengal> > concat . map reverse . takeWhile (not null) . map (take 3) . iterate (drop 3) $ [1,2,3,4,5,6,7,8,9,10]
13:28:51 <lambdabot>   Couldn't match expected type `Bool'
13:28:54 <Berengal> :/
13:29:01 <vixey> :t concat . map reverse . takeWhile (not null) . map (take 3) . iterate (drop 3)
13:29:02 <lambdabot>     Couldn't match expected type `Bool'
13:29:02 <lambdabot>            against inferred type `[a] -> Bool'
13:29:02 <lambdabot>     In the first argument of `not', namely `null'
13:29:08 <vixey> :t concat . map reverse . takeWhile (not null)
13:29:09 <lambdabot>     Couldn't match expected type `Bool'
13:29:09 <lambdabot>            against inferred type `[a] -> Bool'
13:29:09 <lambdabot>     In the first argument of `not', namely `null'
13:29:10 <Berengal> > concat . map reverse . takeWhile (not.null) . map (take 3) . iterate (drop 3) $ [1,2,3,4,5,6,7,8,9,10]
13:29:12 <lambdabot>   [3,2,1,6,5,4,9,8,7,10]
13:29:17 <EvilTerran> vixey, er, not.null?
13:29:27 <vixey> ?
13:29:37 <Berengal> vixey: (not null) vs (not.null)
13:29:53 <duaneb> anyway
13:30:49 <byorgey_> ah, right
13:31:05 <duaneb> here's my code right now:
13:31:09 <duaneb> (don't wince, please)
13:31:10 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4940#a4940
13:31:12 <Berengal> '\n -> map (take n) . iterate (drop n)' should be a standard function...
13:31:25 <duaneb> How can I make that work?
13:32:29 <koeien> duaneb: error "..." ++ (show x)    is different from   error ("..." ++ (show x))
13:32:36 <koeien> remember that function application binds really strongly in Haskell
13:32:38 <duaneb> koeien: oh, right
13:33:34 <Berengal> duaneb: First of all, guards look different
13:33:40 <duaneb> but still, how about the guards?
13:33:44 <koeien> yes.
13:33:47 <koeien> otherwise
13:33:52 <Berengal> foo a b c | p a = b c
13:33:59 <koeien> after a | a Boolean predicate must occur
13:34:04 <Berengal> not 'foo a b c = | p a -> b c'
13:34:05 <koeien> _ is not a boolean value
13:34:22 <koeien> also, no = after the first line. and you need = instead of ->
13:36:13 <mmorrow> @let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs
13:36:15 <lambdabot>  Defined.
13:36:56 <mmorrow> > (\n -> concatMap reverse . chunk n) 3 [0..]
13:36:57 <lambdabot>   [2,1,0,5,4,3,8,7,6,11,10,9,14,13,12,17,16,15,20,19,18,23,22,21,26,25,24,29,...
13:38:50 <mmorrow> , fmap take 6 $ (\n -> tranpose . chunk n) 3 (cycle "bgr")
13:38:51 <lunabot>  luna: Not in scope: `tranpose'
13:38:59 <mmorrow> > fmap take 6 $ (\n -> transpose . chunk n) 3 (cycle "bgr")
13:39:01 <lambdabot>       Overlapping instances for Show ([a] -> [a])
13:39:01 <lambdabot>        arising from a use o...
13:39:12 <mmorrow> > fmap (take 6) $ (\n -> transpose . chunk n) 3 (cycle "bgr")
13:39:27 <lambdabot>   thread killed
13:42:10 <mmorrow> > fmap (take 6) $ (\n -> transpose . chunk n) 3 (take 1000000 $ cycle "bgr")
13:42:13 <lambdabot>   ["bbbbbb","gggggg","rrrrrr"]
13:43:18 <Berengal> > let chunk n = unfoldr (\l -> if null l then Nothing else Just (splitAt n l)) in chunk 3 [1..10]
13:43:20 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
13:45:37 <malouin> ah, cabal --global install!
13:46:00 <malouin> that is what I was looking for.
13:46:04 <duaneb> > let flatten = foldl (++) [[1,2],[3,4],[5,6],[7,8]]
13:46:06 <lambdabot>   <no location info>: parse error on input `;'
13:46:16 <duaneb> err
13:46:26 <duaneb> whoops
13:46:39 <Cale> foldr would be better, and you forgot the base case :)
13:46:46 <duaneb> > let flatten = foldl (++) [] in flatten [[1,2],[3,4],[5,6],[7,8]]
13:46:49 <lambdabot>   [1,2,3,4,5,6,7,8]
13:46:59 <duaneb> why would foldr be better?
13:47:00 <pk> join #porno
13:47:12 <Cale> > let flatten = foldl (++) [] in flatten (repeat [1,2])
13:47:27 <koeien> duaneb: foldr works on infinite lists
13:47:28 <lambdabot>   mueval: Prelude.read: no parse
13:47:29 <Cale> ... wait for that to time out...
13:47:34 <Cale> > let flatten = foldr (++) [] in flatten (repeat [1,2])
13:47:42 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
13:47:48 <Cale> but that works :)
13:47:51 <duaneb> ahh
13:47:58 <duaneb> but doesn't foldr fold from the right?
13:48:06 <duaneb> so how CAN it work on infinite lists?
13:48:08 <Cale> Yes, that's why.
13:48:15 <Cale> It starts at the beginning of the list.
13:48:22 <koeien> foldr gives a + (b + (c + ... )))
13:48:22 <Berengal> (++) copies the entire left argument. In foldl each element is on the left side of the resulting "expression" as many times as there are elements to the right of it, but in foldr it only appears to the left once
13:48:23 <Cale> [1,2] ++ (...)
13:48:24 <duaneb> but the right-most value isn't known
13:48:24 <duaneb> OH
13:48:38 <duaneb> I thought that 1 in [1,2,3,4] was the left most value
13:48:43 <Cale> It is.
13:48:45 <roconnor> > [1,2] ++ undefined
13:48:47 <lambdabot>   [1,2* Exception: Prelude.undefined
13:48:57 <roconnor> > take 2 $ [1,2] ++ undefined
13:48:59 <lambdabot>   [1,2]
13:49:06 <Cale> [1,2,3,4] = 1 : (2 : (3 : (4 : [])))
13:49:20 <duaneb> so if foldl folds from the left, would it not start with 1
13:49:31 <duaneb> ...or does it fold GOING left?
13:49:33 <Cale> foldl f z [1,2,3,4]
13:49:34 <duaneb> ahah
13:49:34 <koeien> no.
13:49:35 <Cale> > foldl f z [1,2,3,4]
13:49:37 <lambdabot>   f (f (f (f z 1) 2) 3) 4
13:49:42 <Cale> > foldr f z [1,2,3,4]
13:49:43 <lambdabot>   f 1 (f 2 (f 3 (f 4 z)))
13:50:06 <Cale> But to really see the problem, I think it's best to look at the code
13:50:11 <Cale> @src foldl
13:50:11 <lambdabot> foldl f z []     = z
13:50:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:50:14 <Berengal> foldr is like looping backwards, possibly ignoring previous iterations of the loop
13:50:16 <koeien> see also foldr.com and foldl.com
13:50:27 <Cale> foldl does nothing but to call itself over and over until it reaches the end of the list
13:50:47 <Cale> The first thing that happens when (x:xs) is matched is another foldl gets evaluated
13:50:53 <Cale> @src foldr
13:50:53 <lambdabot> foldr f z []     = z
13:50:53 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:50:57 <duaneb> ahh
13:50:59 <duaneb> interesting
13:51:00 <Cale> But foldr calls f instead
13:51:23 <Cale> So if f doesn't end up using its second parameter, then foldr stops.
13:52:02 <koeien> > foldl (\_ _ -> 1) 0 [1..]
13:52:12 <koeien> > foldr (\_ _ -> 1) 0 [1..]
13:52:20 <lambdabot>   mueval: Prelude.read: no parse
13:52:25 <lambdabot>   1
13:52:33 <koeien> foldr is a better choice if your "folding" function is not always strict in both arguments
13:52:39 <koeien> (and you want to terminate earlier)
13:52:54 <koeien> otherwise, you want foldl' most of the time
13:53:23 <koeien> (but this is not true in all cases. a reasonable approximation though imo)
13:54:37 <Berengal> If the accumulator function in a foldl is lazy, do you want foldl instead of foldl'?
13:54:47 <Berengal> I'm thinking spesifically about foldl (flip (:)) []
13:54:53 <Absolute0> Is there a more elegant solution to:
13:54:53 <Absolute0> merge [] x = x
13:54:53 <Absolute0> merge x [] = x
13:54:53 <Absolute0> ?
13:54:54 <duaneb> gah, making haskell fast makes my head hurt >.<
13:55:43 <koeien> Absolute0: it is partial. you'd need to add more clauses to make it total.
13:55:57 <duaneb> ok, also, is doing this stupid?
13:55:58 <duaneb> height' = (fromIntegral::Integral a => a -> Word16) height
13:56:14 <mauke> yes
13:56:18 <koeien> duaneb: just do     (fromIntegral height)
13:56:24 <Berengal> Absolute0: In my opinion you should give one of the xes another name. Probably not the answer you're looking for :P
13:56:27 <koeien> if that is not enough,  (fromIntegral height :: Word16)
13:56:29 <mauke> height' = fromIntegral height :: Word16
13:57:04 <dsouza> Cale: why foldr stops if `f' does not use the snd parameter? can't see this from the function definition ...
13:57:07 <koeien> Absolute0: yes. i'd do   merge [] ys = ys; merge xs [] = xs
13:57:08 <duaneb> yea, but the inferred type in this case is (fromIntegral :: (Integral a, Word a1) => a -> a1)
13:57:16 <duaneb> mauke: that works too
13:57:29 <koeien> dsouza: consider
13:57:32 <Absolute0> koeien: :)
13:57:32 <koeien> @src foldr
13:57:33 <lambdabot> foldr f z []     = z
13:57:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:57:48 <Berengal> > foldr const 0 [1..]
13:57:49 <lambdabot>   1
13:57:58 <koeien> dsouza: in the second clause, if f doesn't use its second argument, the rest, (foldr f z xs) will not be evaluated because of lazy evaluation.
13:58:51 <dsouza> oh ok. i see now: f 1 (f 2 (f 3 (f 4 z)))
13:58:58 <Gracenotes> yep
13:59:02 <dsouza> thx
13:59:19 <Gracenotes> if f needs both arguments, then the first thing to be fully evaluated will be the inner part, f 4 z
13:59:32 <Gracenotes> (in the case the whole thing needs to be fully evaluated, anyway)
13:59:50 <Gracenotes> so in a sense it does fold from the right.
14:00:05 <idnar> > foldr (\x y -> if x < 10 then x + y else x) 0 [1..]
14:00:06 <lambdabot>   55
14:00:27 <njbartlett> dcoutts: Hey I got Leksah working on Mac OS!
14:00:28 <koeien> i always remember it like this,  in foldr (\x y -> ...)   the 'y' (on the 'right') refers to what already has been computed, and the 'x' to the current item
14:02:05 <dsouza> right. it makes sense now. thx :-)
14:09:23 <mmorrow> foldl hands it's function the accum value and the next val and expects an updated accum val
14:09:26 <mmorrow> *its
14:09:44 <ehird> I always consider folds as time travel.
14:09:53 <ehird> "y" isn't what's already been computed - it's what's GOING to be computed
14:10:03 <mmorrow> and foldr hands its function the next val and a thunk that contains the rest of the lists
14:10:05 <ehird> This helps me think about it more functionally instead of imperatively.
14:10:15 <ehird> I suppose that only applies to foldr, but meh.
14:12:22 <mmorrow> @let foldc f z [] = z; foldc f z (x:xs) = f z x (\z -> foldc f z xs)
14:12:25 <lambdabot>  Defined.
14:13:13 <mmorrow> > foldc (\_ x k -> x : k ()) () [0..]
14:13:15 <lambdabot>   Couldn't match expected type `[t]' against inferred type `()'
14:13:20 <mmorrow> arg
14:13:49 <Cale> dsouza: It's important to remember that lazy evaluation is *outermost first*
14:13:54 <mmorrow> @let foldC f g z [] = g z; foldC f z (x:xs) = f z x (\z -> foldC f g z xs)
14:13:55 <lambdabot>   arity mismatch for 'foldC'
14:14:02 <mmorrow> @let foldC f g z [] = g z; foldC f g z (x:xs) = f z x (\z -> foldC f g z xs)
14:14:04 <lambdabot>  Defined.
14:14:24 <mmorrow> > foldC (\_ x k -> x : k ()) (const []) () [0..]
14:14:26 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:14:44 <Cale> dsouza: So the right hand side of that equation for foldr means that f will be evaluated first, and the parameters x and (foldr f z xs) will be substituted into its body.
14:15:10 <Cale> dsouza: Does that help?
14:15:13 <mmorrow> > foldC (\acc x k -> let acc' = acc + x in acc' `seq` k acc') id 0 [0..1000000]
14:15:16 <lambdabot>   500000500000
14:15:19 <mmorrow> > foldC (\acc x k -> let acc' = acc + x in acc' `seq` k acc') id 0 [0..10000000]
14:15:30 <lambdabot>   50000005000000
14:15:41 <mmorrow> > foldr (+) 0 [0..10000000]
14:15:44 <lambdabot>   * Exception: stack overflow
14:16:23 <mmorrow> > foldC (\acc x k -> if x==0 then 0 else let acc' = acc * x in acc' `seq` k acc') id 1 ([1..10]++[0]++[1..1000000])
14:16:25 <lambdabot>   0
14:16:29 <dsouza> Cale: yes it does. When I saw someone writting this `foldr const 0 [1..]' I undestood what you guys were saying
14:16:45 <mmorrow> > foldc (\acc x k -> if x==0 then 0 else let acc' = acc * x in acc' `seq` k acc') 1 ([1..10]++[0]++[1..1000000])
14:16:46 <lambdabot>   0
14:16:49 <Berengal> :)
14:16:50 <dsouza> I knew foldr was lazy and could work with infinite structures,
14:17:15 <Berengal> ehird: foldr as time-travel works nicely
14:17:19 <dsouza> but I didn't realized that if f didn't evaluate the snd parameter it would stop! nice thing to learn ...
14:17:45 <mmorrow> dsouza: but also it's not just that "foldr is lazy and foldl isn't", but that they do two fundamentally different things
14:17:46 <ehird> dsouza: my time travel metaphor covers this
14:17:56 <ehird> it took infinite time to compute, and then traveled back in time with the value
14:18:13 <ehird> the fact that you then branch off a world where you didn't compute it merely implies odd physics ;-)
14:19:14 <dsouza> monochrom: could ellaborate a little bit on this?
14:19:18 <Berengal> The nice thing about mathematics is that it doesn't have to relate to the read world, and as long as we can describe it in binary we've got a real world computer that can evaluate it
14:19:27 <Berengal> This explains why time-travel is possible :P
14:19:41 <dsouza> ops
14:19:50 <dsouza> s/monochrom/mmorrow/
14:20:23 <mmorrow> dsouza: foldr take the first elem of the list, then builds a thunk containing itself recursing on the rest of the list, then it hands this pair to the function
14:21:30 <mmorrow> foldl on the other hand takes and accumulated value, and the next item of the list, then hands this pair of items to the function and waits for the updated accumulated value, then repeats
14:21:38 <mmorrow> *...take an ....
14:22:22 <copumpkin> allo
14:22:32 <copumpkin> bah, how do I ask mibbit to stop doing that
14:26:15 <dsouza> mmorrow: absolutely, thx. it makes even more sense when reading the definition of both functions :-)
14:26:43 <roconnor> Berengal: I wrote an article on time-travel in haskell.
14:26:57 <monochrom> foldr (&&) False xs -> False && foldr (&&) xs -> done
14:27:00 <Berengal> roconnor: link?
14:27:10 <roconnor> @go time-travel haskell
14:27:12 <lambdabot> http://changelog.complete.org/archives/585-haskell-time-travel
14:27:12 <lambdabot> Title: Haskell Time Travel | The Changelog
14:27:24 <roconnor> bah
14:28:06 <roconnor> Berengal: http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf
14:28:34 <Berengal> Nice
14:28:38 <dsouza> this if first time i join the channel, i'm really impressed about these bots. i know i should probably be googling for it, but anyway: where I can find the source code of these bots?
14:28:59 <Berengal> dsouza: lambdabot is on hackage
14:29:07 <duaneb> ok
14:29:09 <duaneb> I have this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4941
14:29:23 <duaneb> that produces the prof here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4942
14:29:26 <roconnor> @where lambdabot
14:29:26 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
14:29:33 <duaneb> why is `test` taking so much time?
14:29:35 <dsouza> ha!
14:29:46 <duaneb> it should find `row` and duplicate it 500 times
14:29:52 <dsouza> thx
14:29:53 <duaneb> this doesn't warrant the runtime that it has...
14:30:47 <roconnor> @bf [...>..<]
14:30:47 <lambdabot>   fd:7: hClose: resource vanished (Broken pipe)
14:30:53 <Berengal> duaneb: try changing flatten to foldr (++) [], or simply use concat...
14:31:27 <duaneb> ok
14:32:09 <duaneb> oh, hey, that's nifty
14:33:31 <Berengal> duaneb: Did that work out?
14:35:19 <duaneb> Yes
14:35:22 <duaneb> now... why?
14:35:37 <duaneb> because concat is literally foldr (++) []
14:36:01 <Berengal> foldl (++) [] is O(n^2) but foldr (++) [] is O(n)
14:36:32 <Gracenotes> > take 10 $ foldl (++) [] (repeat "hello")
14:36:41 <lambdabot>   mueval: Prelude.read: no parse
14:36:43 <Gracenotes> > take 10 $ foldr (++) [] (repeat "hello")
14:36:47 <lambdabot>   "hellohello"
14:37:11 <skorpan> Berengal: how is foldl (++) [] O(n^2)?  i mean i see the difference between foldl and foldr, but i don't see how the asymptotic time complexity could change
14:37:41 <duaneb> skorpan: for each iteration, it must go to the end of the list
14:37:44 <duaneb> thus, N^2
14:37:48 <Asztal> you're building up the big list on the left, and adding to the right
14:37:54 <duaneb> really (n^2)/2
14:37:57 <duaneb> (I think)
14:38:09 <Berengal> skorpan: (++) duplicates its left argument, foldl (++) [] [a,b,c,d,e] looks like ((([] ++ a) ++ b) ++ c) ++ d
14:38:41 <Berengal> As you can see, a appears to the left of three (++)
14:39:05 <skorpan> and foldr makes it [] ++ (a ++ (b ++ (c ++ d)))... hm...
14:39:08 <Berengal> Okay, four, if I hadn't forgotten about the e
14:39:17 <Gracenotes> and if the list of things to concat are infinite, it will never reach the leftmost point
14:39:31 <Berengal> skorpan: right, except the [] is in the wrong spot
14:39:37 <skorpan> oh, sorry, yes
14:39:40 <skorpan> a ++ (b ++ ...
14:39:45 <Gracenotes> *is
14:39:47 <Berengal> Anyway, in the foldr case, a is only to the left of one (++)
14:39:53 <Gracenotes> @src foldl
14:39:53 <lambdabot> foldl f z []     = z
14:39:54 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:40:03 <Berengal> all the other (++) to the right are inside other expressions
14:40:36 <Elly> does anyone use ghc on dragonfly BSD?
14:40:53 <skorpan> foldr (++) [] [[1, 2], [3, 4], [5, 6]]...  [1, 2] ++ ([3, 4] ++ ([5, 6] ++ []))...
14:40:59 <cognominal>  filter ( λb →  b ^. identA  ≠  Left "Buffer List") bs     -- now want to filter out everything that is Left _
14:41:12 <cognominal> what is the more concise way.
14:41:15 <Gracenotes> @hoogle lefts
14:41:16 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
14:41:16 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
14:41:20 <Gracenotes> >:|
14:41:35 <Gracenotes> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html#v%3Alefts
14:41:51 <skorpan> i guess i can understand O(n) and O(n^2) then... although to me it wasn't entirely obvious :)
14:41:55 <duaneb> so, ah, apparently `concat . map reverse . takeWhile (not.null) . map (take 3) . iterate (drop 3)` is pretty slow
14:42:00 <Berengal> @djinn Either a b -> Bool
14:42:01 <lambdabot> f a =
14:42:01 <lambdabot>     case a of
14:42:01 <lambdabot>     Left _ -> False
14:42:01 <lambdabot>     Right _ -> True
14:42:32 <Berengal> duaneb: Yeah, that one could've been done better
14:42:34 <cognominal> lefts x = [a | Left a <- x]
14:42:37 <vixey> @djinn (a,b) -> Bool -> Either a b
14:42:37 <lambdabot> f (a, b) c =
14:42:37 <lambdabot>     case c of
14:42:37 <lambdabot>     False -> Left a
14:42:37 <lambdabot>     True -> Right b
14:42:45 <Gracenotes> heh
14:42:51 <cads> hey, I've got a function called grav that calculates the force of gravitational attraction between two massive bodies. grav a b = grav b a . I also have a function where the order _does_ matter, which calculates the resulting acceleration vectors:  GravAcc a b = [scalar_product (gforce/a_mass) direction, scalar_product (gforce/b_mass) direction] where direction = normalize (b_pos - a_pos), gforce = grav a b.     I'd like to apply this fun
14:42:51 <cads> ction between all pairs of particles in a list of particles, but after that, sums have to be collected particle wise to figure out the final acceleration.
14:43:07 <duaneb> still faster than the whole rgbbgr' hd (r:g:b:tl) = rgbbgr (hd ++ [b,g,r]) tl, but....
14:43:09 <cognominal> I wanted a generic way to filter with a pattern matching
14:43:44 <cognominal> what is the name of  this construction?  [a | Left a <- x]
14:43:53 <cognominal> same as in math, but I gorgot the name
14:44:10 <BONUS> list comprehension?
14:44:22 <Berengal> duaneb: let chunk n = unfoldr (\l -> if null l then Nothing else Just $ splitAt n l); rgbbgr = chunk 3?
14:45:56 <eu-prleu-peupeu> haskell is awesome
14:46:34 <duaneb> unfoldr?
14:47:03 <Berengal> @type unfoldr
14:47:06 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:47:13 <Berengal> It's the opposite of a fold
14:48:26 <duaneb> Berengal: isn't that [a]->[[a]]?
14:49:04 <Berengal> @type foldr
14:49:06 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:49:26 <jnj> I have some experience with SML and thus functional programming. Can you guys recommend any Haskell books for me?
14:49:56 <Berengal> Or if we switch around the types a little: foldr :: ((a, b) -> b) -> b -> [a] -> b. unfoldr :: (b -> (a, b)) -> b -> [a]
14:49:57 <duaneb> @type (unfoldr (\l -> if null l then Nothing else Just $ splitAt n l))
14:49:59 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
14:49:59 <lambdabot>     In the first argument of `splitAt', namely `n'
14:49:59 <lambdabot>     In the second argument of `($)', namely `splitAt n l'
14:50:00 <ehird> jnj: Real World Haskell & Yet Another Haskell Tutorial
14:50:04 <duaneb> goddammit
14:50:11 <duaneb> @type (\n -> (unfoldr (\l -> if null l then Nothing else Just $ splitAt n l)))
14:50:12 <lambdabot> forall a. Int -> [a] -> [[a]]
14:50:16 <ehird> jnj: YAHT will make good sense to you being an FPer, RWH will show the Haskell way of practical things
14:50:25 <duaneb> ja
14:51:03 <duaneb> oh, I see what you're doing
14:51:12 <cognominal> YAHT?
14:51:20 <jnj> ehird: Thanks, I'll try YAHT, since it's apparently free ;)
14:51:44 <ehird> jnj: So's real world haskell!
14:51:47 <ehird> You can read it online.
14:51:57 <jnj> ehird: Oh, that I didn't know
14:52:05 <ehird> jnj: But I'd go for YAHT first for the theoretical stuff.
14:52:08 <ehird> cognominal: Yet Another Haskell Tutorial.
14:53:10 <adamvo> @go yaht
14:53:12 <lambdabot> http://en.wikibooks.org/wiki/Haskell/YAHT
14:53:12 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
14:54:41 <cypher-> jnj: I always recommend Richard Bird's book
14:55:19 <cypher-> Introduction to FP using Haskell, but if you're good at SML then you might find it rather borring since it introduces the concept of FP as much as features of the language
14:56:42 <snoobino> why can't I write : instance (Functor f) => Functor (forall a. (SomeFunctor (f a))) where ..
14:56:45 <jnj> well, it's been a while since I did SML, but I think I'll be able to cope with books without an in-depth FP introduction
14:56:50 <jnj> I'll look it up though, thanks
14:57:07 <Gracenotes> snoobino: SomeFunctor...?
14:57:28 <snoobino> Gracenotes: it's some functor
14:58:12 <Gracenotes> like, for instance, Maybe
14:58:27 <snoobino> yeah, why not
14:58:59 <mux> snoobino: what are you actually trying to express?
14:59:12 <snoobino> composition of functor
14:59:23 <snoobino> I'm tired to write fmap . fmap
14:59:55 <Gracenotes> eh. with the type system, you'd need a newtype for composition, which might be inconvenient
14:59:59 <mauke> http://okmij.org/ftp/Haskell/typecast.html#deepest-functor
15:00:03 <hatds> you can probably do it if you turn on all of the extensions
15:00:08 <Gracenotes> newtype Comp f g a = Comp (f (g a))
15:00:11 <hatds> flexible instances, undecidable, etc
15:00:20 <mux> you'd need polymorphic components, I thinnk
15:00:21 <cypher-> jnj: once you're throug h some intro book, check "the fun of programming"
15:00:22 <Gracenotes> either that or some crazy undecidable instance thing
15:00:36 <hatds> I'd go with the newtype
15:00:50 <mux> snoobino: but I'm not quite sure why you want to bring a value type 'a' into scope
15:00:53 <Gracenotes> maybe you should define a function, fmap2 = fmap . fmap
15:01:10 <Gracenotes> or fmapNest?
15:01:28 <snoobino> mux: so I can define a composition
15:01:29 <beelsebob> fmap2 = fmap fmap fmap
15:01:31 <beelsebob> or is that fmap3?
15:01:32 <beelsebob> :P
15:01:50 <snoobino> I thought the forall was acting like a type function
15:01:56 <hatds> every time I've thought I wanted some sort of "deep" operation I'm glad I changed my mind
15:02:05 <snoobino> I meant, like the lambda for normal functions
15:02:07 <mux> instance (Functor f, Functor g) => Functor (f :*: g) where -- something like this?
15:02:13 <mux> for some definition of x*x
15:02:16 <mux> err, :*:
15:02:25 <Gracenotes> (:*:) being isomorphic to Comp
15:02:56 <mux> forall is not about type functions
15:02:57 <Gracenotes> foralls are generally used for existential quantification in the language... lots of messy type stuff
15:03:06 <mux> type functions is what you get via associated types
15:03:08 <snoobino> ok
15:03:35 <mux> foralls are used for many things unfortunately
15:04:18 <BONUS> would you need dependent types so that soething like fmapN n = foldr (.) id (replicate n fmap) would typecheck
15:04:24 <BONUS> without constructing an infinite type
15:04:28 <mux> with scoped type variables, they bring the type parameter into scope for later reuse in type annotations, they are also used to model existential quantification, and to permit polymorphic components in data types
15:04:47 <snoobino> BONUS: how would that work ?
15:04:56 <BONUS> honestly i dont know
15:05:13 <duaneb> how can I return nothing?
15:05:13 <BONUS> basically fmapN 2 would be fmap . fmap
15:05:14 <snoobino> because all the fmaps aren't all the same
15:05:19 <duaneb> in an IO () expression
15:05:22 <BONUS> fmapN3 would be fmap . fmap . fmap
15:05:23 <BONUS> ah
15:05:24 <BONUS> yeah
15:05:39 <Gracenotes> duaneb: make it explicit .. use a Maybe wrapper
15:05:39 <Berengal> duaneb: an IO () doesn't return anything as it is...
15:05:49 <snoobino> you can't replicate it
15:05:53 <Gracenotes> ah, for IO ()
15:06:05 <Gracenotes> "return x" is an IO action that does nothing
15:06:11 <BONUS> i dont know about dependent types really, i was just wondering if they would allow for a function that fmaps over n nested functors
15:06:11 <snoobino> there is always template haskell
15:06:13 <Gracenotes> just brings a value in the IO monad
15:06:18 <BONUS> @type replicate 10 fmap
15:06:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => [(a -> b) -> f a -> f b]
15:06:20 <duaneb> ok, I guess:
15:06:50 <duaneb> I have a function let f :: Int -> IO (); f  0 = return...
15:06:53 <duaneb> but what I do I return?
15:06:59 <duaneb> that's what I'm trying to figure out
15:07:06 <BONUS> return ()
15:07:08 <BONUS> because it's IO ()
15:07:11 <snoobino> the problem is : the type of the fmapN depends on its argument
15:07:16 <BONUS> yeah
15:07:32 <snoobino> + we don't have polymorphism
15:07:38 <snoobino> I meant
15:07:43 <snoobino> methods stuff
15:07:47 <mux> you can get some limited dependent typing features by playing with associated types and type classes, etc
15:07:48 <duaneb> oh, ok
15:07:49 <duaneb> thanks
15:08:06 <gnuvince_> BONUS: I was wondering if you had any more chapters for Learn You A Haskell in the pipeline?
15:08:40 <BONUS> yes, monoids and foldable coming soon, and then i'll finish monads, transformers and zippers over the summer
15:08:51 <TomMD> BONUS was planning on making one for every package on Hackage... right?
15:08:58 <cognominal>  map ( \x -> Left x ) ( \x-> [a | Left a <- x] ) [ Left 1, Right 2 ]
15:08:59 <BONUS> haha
15:08:59 <Gracenotes> you don't finish monads... monads finish you
15:09:10 <cognominal> first it does not compile
15:09:13 <BONUS> and then we have to check it for errors and stupidities before it goes into print
15:09:18 <Gracenotes> cognominal: it's because x is not a list
15:09:24 <Gracenotes> so you can't do Left a <- x
15:09:24 <cognominal> second I guess there is simpler
15:09:38 <SubStack> BONUS++
15:09:42 <BONUS> :]
15:10:09 <Gracenotes> cognominal: define isLeft (Left _) = True, isLeft _ = False. then it's as simple as filter isLeft
15:10:38 <cognominal> indeed
15:10:56 * SubStack thinks there should be more illustrated technical guides
15:11:23 <mux> Gracenotes: you can do even simpler by using the property of the fail method in the list monad :-)
15:11:25 <BONUS> thinking of maybe if the book comes with a haskell poster
15:11:26 * SubStack should be getting his wacom bamboo in the mail soon, too
15:11:28 <Gracenotes> or, if you like list comprehensions, [ Left x | Left x <- xs ] is that approach, but isLeft isn't so bad. simplest tends to be better... there may be a better way than this, depending on your problem
15:11:41 <BONUS> like there's a pretty picture in the middle and then around it it's like a cheat sheet of some haskell functions and stuff
15:11:43 <cognominal> I wanted to do pattern matching in a filter but either it is not possible or (more probably) I don't know how to do it... or it is meaningless
15:11:57 <SubStack> sounds pretty groovy
15:12:21 <Gracenotes> cognominal: well, what do you want to do with the list of Eithers?
15:13:03 <mux> Gracenotes: foo eithers = [ x  | Left x <- eithers ]
15:13:37 <cognominal> Gracenotes, I will do as you said. But my more general question is still open :)
15:13:46 <Gracenotes> mux: that's the lefts function. if you want (Either a b -> Either a b) instead, taking out the Rights, then filtering is probably better
15:13:57 <Gracenotes> it seems that's what cognominal had above
15:14:34 <Gracenotes> but... rarely would you want to rewrap it. So there may be a better way in your case that's not complicated as ___.
15:14:40 <mux> well it sounds odd to need that but that would be map Left . lefts
15:14:56 <mux> at least I'd prefer writing it this way
15:15:37 <cognominal> mux++
15:16:35 <Gracenotes> implicit is better than explicit :P
15:16:40 <Gracenotes> /joke
15:17:05 <cognominal> the joke must be implicit because  I don't get it
15:17:45 <Gracenotes> import this
15:17:55 <mux> @karma
15:17:55 <lambdabot> You have a karma of 1
15:18:00 <duaneb> @karma
15:18:01 <lambdabot> You have a karma of 0
15:18:04 <duaneb> dammit.
15:18:11 <duaneb> Can I help someone?
15:18:11 <mux> when did the karma db got reseted? :-/
15:18:17 <duaneb> Please take a number and stand in line.
15:18:24 <duaneb> mux++
15:18:28 <mauke> preflex: karma mux
15:18:28 <preflex>  mux: 2
15:18:28 <duaneb> @karma mux
15:18:29 <lambdabot> mux has a karma of 2
15:18:33 <mux> woot!
15:18:39 <duaneb> karma mux
15:18:41 <duaneb> @karma mux
15:18:42 <lambdabot> mux has a karma of 2
15:18:46 <duaneb> :/
15:18:53 <mux> @karma ghc
15:18:53 <lambdabot> ghc has a karma of -2
15:18:54 <duaneb> how can I give karma?
15:18:57 <mux> how come.
15:19:00 <mux> ghc++
15:19:03 <duaneb> ghc++
15:19:05 <mauke> preflex: karma ghc
15:19:05 <preflex>  ghc: 3
15:19:10 <duaneb> :P
15:19:14 <roconnor> mux: cause ghc sucks
15:19:26 <snoobino> > cycle "snoobino++\n"
15:19:28 <lambdabot>   "snoobino++\nsnoobino++\nsnoobino++\nsnoobino++\nsnoobino++\nsnoobino++\nsn...
15:19:31 <mauke> preflex: karma C
15:19:31 <preflex>  C: 13421
15:19:37 <roconnor> :)
15:19:39 <mux> I suppose you have a valid reason to say that that is beyond me :)
15:19:45 <snoobino> @karma snoobino
15:19:45 <lambdabot> You have a karma of 0
15:20:01 <snoobino> snoobino--
15:20:02 <bremner> @karma karma karma chameleon
15:20:02 <lambdabot> karma has a karma of 1
15:20:03 <roconnor> mux: http://hackage.haskell.org/trac/ghc/ticket/3234
15:20:07 <roconnor> :P
15:20:07 <duaneb> @karma lambdabot
15:20:08 <lambdabot> lambdabot has a karma of -2
15:20:11 <snoobino> @karma snoobino
15:20:11 <lambdabot> You have a karma of 0
15:20:12 <duaneb> lambdabot++
15:20:15 <duaneb> @karma lambdabot
15:20:16 <lambdabot> lambdabot has a karma of -1
15:20:18 <MyCatVerbs> , cycle "lambdabot++ "
15:20:26 <lunabot>  "lambdabot++ lambdabot++ lambdabot++ lambdabot++ lambdabot++ lambdabot++ ...
15:20:29 <duaneb> > cycle "lambdabot++\n"
15:20:31 <mux> roconnor: ouch.
15:20:31 <lambdabot>   "lambdabot++\nlambdabot++\nlambdabot++\nlambdabot++\nlambdabot++\nlambdabot...
15:20:39 <Gracenotes> I think it would only count a line once
15:20:47 <MyCatVerbs> @karma lambdabot
15:20:47 <lambdabot> lambdabot has a karma of 4
15:20:49 <mux> roconnor: it breaks deforestation in your module?
15:20:51 <Gracenotes> enough bot abuse! >_>
15:20:51 <duaneb> heh
15:20:52 <roconnor> mux: well, I'm really exagerating when I say GHC sucks.
15:20:58 <snoobino> > snoobino++
15:20:59 <lambdabot>   <no location info>: parse error on input `;'
15:21:02 <roconnor> mux: I just mean it is imperfect. :P
15:21:03 <MyCatVerbs> And it ignores its own output. Nope, it does count lines however many times you like.
15:21:08 <snoobino> > "snoobino++"
15:21:10 <lambdabot>   "snoobino++"
15:21:16 <snoobino> @karma snoobino
15:21:16 <lambdabot> You have a karma of 0
15:21:23 <snoobino> come on
15:21:36 <MyCatVerbs> snoobino: lambdabot ignores her own output, silly.
15:21:38 <duaneb> so um
15:21:56 <duaneb> ghc++
15:21:57 <duaneb> ghc++
15:22:00 <duaneb> @karma ghc
15:22:00 <lambdabot> ghc has a karma of 2
15:22:04 <duaneb> heh
15:22:04 <snoobino> MyCatVerbs: does she now about lunabot ?
15:22:13 <duaneb> so how can I use Data.Binary?
15:22:23 <roconnor> preflex: @karma lambdabot
15:22:23 <preflex>  lambdabot: 8
15:22:29 <mux> @where binary
15:22:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/binary.html
15:22:42 <MyCatVerbs> snoobino: no, she doesn't. Hence.
15:22:44 <duaneb> I mean, is there an example?
15:22:44 <mux> it's available on hackage acually
15:22:47 <mux> better take it ehre
15:23:09 <mux> duaneb: it's quite straightforward to use
15:23:14 <roconnor> mux: I'm still using GHC 6.8.2, so this bug doesn't bother me yet.
15:23:50 <duaneb> mux: I just don't know where to start :P
15:24:02 <duaneb> do I have to create an instance of Binary to use it?
15:24:05 <RayNbow> http://www.wolframalpha.com/input/?i=prove+%28a+-%3E+%28b+-%3E+c%29%29+-%3E+%28b+-%3E+%28a+-%3E+c%29%29 <-- Djinn vs Wolfram Alpha... 1-0 :p
15:24:07 <bwr> what is the best way to represent a 2d map in haskell... like a game board
15:24:12 <mauke> duaneb: what are you trying to do?
15:24:18 <mux> duaneb: what do you want to serialize ? there are instances for most basic types
15:24:19 <stroan> someone was saying in here that lists are preferable to tail recursion to implement iteration?
15:24:29 <roconnor> bwr: an array
15:24:34 <Berengal> stroan: Yes
15:24:38 <duaneb> I'm trying to write to a format
15:24:48 <sjanssen> bwr: is it sparse or dense?  Are the dimensions static?  Will you be updating it frequently?
15:24:49 <snoobino> > "> "lal" "
15:24:50 <lambdabot>   Not in scope: `lal'
15:24:51 <stroan> so, I'm writing a simple loop, to see if a value escapes after a few hundred iterations
15:24:53 <duaneb> that is already defined
15:24:55 <stroan> I use a list?
15:25:00 <snoobino> > "> \"lal\" "
15:25:02 <lambdabot>   "> \"lal\" "
15:25:02 <duaneb> so, I need to output the values in a certain time
15:25:09 <duaneb> in a certain order*
15:25:10 <snoobino> > ", \"lal\" "
15:25:10 <bwr> dimensions are static
15:25:11 <lambdabot>   ", \"lal\" "
15:25:13 <bwr> and it is dense
15:25:32 <bwr> 8x8
15:25:34 <snoobino> , "lal"
15:25:35 <lunabot>  "lal"
15:25:43 <roconnor> bwr: updating frequently?
15:25:47 <bwr> yes
15:25:48 <Berengal> stroan: What do you mean by "to see if a value escapes"?
15:25:52 <snoobino> , "> lal"
15:25:53 <lunabot>  "> lal"
15:25:54 <MyCatVerbs> stroan: you can do it however you like. Personally I'd write it tail-recursively, but a lot of people feel that writing it as a foldr on a list is clearer.
15:25:56 <roconnor> bwr: diffArray
15:26:11 <bwr> ok i will take a look at that, thanks!
15:26:13 <MyCatVerbs> s/a lot/some/, because I don't know how many people are in each group.
15:26:21 <sjanssen> bwr: I would recommend a Map, actually
15:26:28 <stroan> Berengal: xn+1 = f(xn). and see if any xn is greater than a certain value
15:26:35 <bwr> ok i will try both
15:26:55 <bwr> Map with keys of (x,y) ?
15:27:02 <Gracenotes> @elite , (*2) <$> [1, 2, 3]
15:27:03 <lambdabot> , (*2) <$> [1, 2, 3]
15:27:04 <lunabot>  [2,4,6]
15:27:25 <snoobino> Gracenotes, gg
15:27:25 <sjanssen> bwr: yeah
15:27:37 <snoobino> what does elite do ?
15:27:57 <Gracenotes> @elite copies a string, turning alphabet characters into leet
15:27:58 <lambdabot> (oPI35 a S+riNg, +uRnInG aLfAb37 ChaRa(T3rz INt0 |3et
15:28:22 <Berengal> stroan: Not quite sure I get what you're trying to do still, but it looks like iterate and take/takeWhile might be of use
15:28:22 <snoobino> cool
15:28:26 <roconnor> sjanssen: map?
15:28:29 <p_l> and quite hard version of leet
15:28:43 <roconnor> sjanssen: for a dense array?
15:29:04 <sjanssen> roconnor: updates suck with arrays, even with DiffArray
15:29:07 <Gracenotes> snoobino: there may be other bot loops, but none infinite
15:29:09 <stroan> Berengal: similar to the Newton-Raphson method
15:29:11 <Gracenotes> I don't think >_>
15:29:14 <Berengal> , text "> 2 + 2"
15:29:15 <lunabot>  > 2 + 2
15:29:23 <stroan> but to check if any of the value exceed a certain value
15:29:54 <snoobino> Gracenotes: I see you studied the question
15:29:54 <Berengal> > iterate (+1) 0
15:29:56 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:29:59 <MyCatVerbs> sjanssen: *especially* with DiffArray. The asymptotics sound great but the constants are AFAIK way worse than Map.
15:30:07 <Berengal> > head . dropWhile (<10) . iterate (+1) 0
15:30:09 <lambdabot>   Couldn't match expected type `a -> [a1]'
15:30:20 <Berengal> > head . dropWhile (<10) . iterate (+1) $ 0
15:30:22 <lambdabot>   10
15:30:23 <roconnor> I though diffArray's were as fast as MArrays.
15:30:28 <MyCatVerbs> sjanssen: immutable array updates are fine if you replace the whole array in one go every time though, no?
15:30:30 <stroan> Berengal: many thanks :)
15:30:32 <Gracenotes> diff arrays are pretty slow, afaik
15:30:43 <snoobino> , :t text
15:30:45 <lunabot>  luna: Couldn't match expected type `(GHC.Base.String
15:30:47 <roconnor> poor diffArrays
15:30:50 <MyCatVerbs> Less (update), more (map).
15:31:02 <snoobino> , :t text 3
15:31:03 <lunabot>  luna: Couldn't match expected type `(GHC.Base.String
15:33:07 <Saizan> snoobino: without the ,
15:33:16 <Gracenotes> > text . intercalate "\n" . replicate 3 $ "lunabot++"
15:33:17 <lambdabot>   lunabot++
15:33:18 <lambdabot>  lunabot++
15:33:18 <lambdabot>  lunabot++
15:33:18 <Saizan> or
15:33:25 <Gracenotes> *facepalms*
15:33:38 <burp_> lol
15:34:06 <duaneb> @karma lunabot
15:34:06 <lambdabot> lunabot has a karma of 0
15:34:09 <snoobino> :t text
15:34:09 <duaneb> heh
15:34:11 <lambdabot> String -> Doc
15:34:21 <duaneb> lambdabot++
15:34:23 <Gracenotes> preflex: karma lunabot
15:34:23 <snoobino> :info Doc
15:34:23 <preflex>  lunabot: 3
15:34:29 <duaneb> lunabot: who are you?
15:36:30 <bakesz> hi guys!could you help me what does this error message mean:"Ambiguous type variable `a' in these top-level constraints:"?
15:36:41 <bakesz>   `Integral a'
15:36:41 <bakesz>     arising from use of `felso_hatizsak'' at <interactive>:1
15:36:41 <bakesz>   `RealFrac a'
15:36:41 <bakesz>     arising from use of `felso_hatizsak'' at <interactive>:1
15:37:18 <vixey> bakesz: you should call it felsoHatizsak
15:37:21 <mauke> your function doesn't make sense
15:37:25 <mux> bakesz: it means some value in your expression would need to be both Integral and RealFrac
15:37:41 <mux> show us the code
15:38:26 <roconnor> doesn't it mean that a type annotation is needed to resolve a type variable that cannot be inferred?
15:39:01 <sjanssen> roconnor: good luck instantiating the variable with those constraints
15:39:29 <bakesz> im very new in haskell,so sorry for the ugly code
15:39:39 <bakesz> and the bad practise
15:39:47 <bakesz> felso_hatizsak(weight,capacity,profit)=felso_hatizsak'(weight,capacity,profit,[[0],[]],ures_nested_list(length weight),0)
15:39:48 <bakesz> felso_hatizsak'(weight,capacity,profit,out,cond,max)=if ( ((length (biggest_ok(cond,capacity,weight)))==0) || (dot_product( (biggest_ok(cond,capacity,weight)),profit)<(head(head out)) ) ) then out
15:39:48 <bakesz> 	else elso_elem_max(felso_hatizsak'(weight,capacity,profit,[[dot_product_trunc(biggest_ok(cond,capacity,weight),profit)],(biggest_ok(cond,capacity,weight)) ],le_condition(cond,biggest_ok(cond,capacity,weight) ) ,max),felso_hatizsak'(weight,capacity,profit,[[dot_product_trunc((biggest_ok(cond,capacity,weight)),profit)],biggest_ok(cond,capacity,weight) ],fel_condition(cond,biggest_ok(cond,capacity,weight)),max) )
15:39:49 <bakesz> elso_elem_max (a,b)=if (head (head a) )>(head (head b) ) then a else b	
15:39:55 <Berengal> @paste
15:39:56 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:40:15 <mauke> I barf'd
15:40:15 <roconnor> data Foo = Foo deriving (Integral, RealFrac)
15:40:18 <roconnor> done
15:40:38 <sjanssen> roconnor: that isn't valid Haskell
15:40:49 <snoobino> @remember truc : @truc
15:40:49 <lambdabot> Done.
15:40:54 <snoobino> @quote truc
15:40:54 <lambdabot> truc says: : @truc
15:40:59 <snoobino> dammit
15:41:00 <roconnor> :(
15:41:09 <sjanssen> bakesz: please don't paste so much code in the channel, use a pastebin site
15:41:18 <roconnor> @forget truc : @truc
15:41:19 <lambdabot> Done.
15:41:33 <sjanssen> eg. http://hpaste.org
15:41:37 <vixey> bakesz: You made the suggestion I gave you yet?
15:41:58 <bakesz> sorry,here is the link:http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4944#a4944
15:42:03 <bakesz> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4944#a4944
15:42:17 <snoobino> @remember , :  text "@,"
15:42:17 <lambdabot> It is forever etched in my memory.
15:42:28 <snoobino> @,
15:42:29 <lambdabot> Maybe you meant: . ? @ v
15:42:47 <roconnor> @quote ,
15:42:47 <snoobino> @quote ,
15:42:47 <lambdabot> , says: :  text "@,"
15:42:47 <lambdabot> , says: :  text "@,"
15:42:48 <lunabot>  luna: parse error on input `:'
15:42:48 <lunabot>  luna: parse error on input `:'
15:43:15 <sjanssen> whoa
15:43:17 <roconnor> @forget , :  text "@,"
15:43:18 <lambdabot> Done.
15:43:35 <vixey> @let snonk = flip const
15:43:36 <lambdabot>  Defined.
15:43:40 <burp_> how can I create a matrix with numeric prelude?
15:43:47 <vixey> @remember ," " `snonk` text "bloo"
15:43:47 <lambdabot> I will never forget.
15:43:49 <roconnor> @remember , stupidbotsaysparseerroroninput
15:43:49 <lambdabot> Okay.
15:43:50 <vixey> @quote ,"
15:43:51 <lambdabot> ," says: " `snonk` text "bloo"
15:43:52 <lunabot>  luna: Not in scope: `snonk'
15:43:55 <vixey> aww
15:44:03 <vixey> @forget ," " `snonk` text "bloo"
15:44:03 <lambdabot> Done.
15:44:03 <MyCatVerbs> vixey: I'm mystified by that function name. Why snonk?
15:44:06 <roconnor> @quote ,
15:44:06 <lambdabot> , says: stupidbotsaysparseerroroninput
15:44:07 <lunabot>  luna: Not in scope: `says'
15:44:13 <roconnor> damn
15:44:15 <roconnor> outwitted
15:44:21 <Jedai> bakesz: Sorry to say that but that's the ugliest code I've yet to see in Haskell...
15:44:24 <roconnor> @forget , stupidbotsaysparseerroroninput
15:44:24 <lambdabot> Done.
15:44:39 <burp_> :t Cons
15:44:40 <lambdabot> Keyword
15:44:51 <jaj> @quote ,
15:44:51 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
15:44:52 <burp_> :t MathObj.Matrix.Cons
15:44:52 <sjanssen> bakesz: could you make an effort to clean the code up a bit?  It's hard to figure out what's going on
15:44:53 <lambdabot> Couldn't find qualified module.
15:45:00 <adamvo> > let f a b = b + a in f 5 4 -- bakesz, its better to write functions curried, it makes partial application cleaner
15:45:02 <lambdabot>   9
15:45:03 <MyCatVerbs> bakesz: did nobody ever teach you indentation? Packing all your code into one dense block like this makes it much harder for anybody to understand it - you included.
15:45:12 <Jedai> bakesz: And some other languages too (maybe one of the ugliest of all code I've ever seen)
15:45:18 <snoobino> @remember , :  text "@quote ,"
15:45:19 <lambdabot> It is forever etched in my memory.
15:45:20 <sjanssen> bakesz: breaking that second line into several lines would really help
15:45:24 <snoobino> @quote ,
15:45:25 <lambdabot> , says: :  text "@quote ,"
15:45:26 <lunabot>  luna: parse error on input `:'
15:45:26 <bakesz> sorry
15:45:33 <mauke> now would be a good time to stop playing around with the bots
15:45:46 <Jedai> bakesz: Also in Haskell you don't pass arguments like that
15:46:04 <snoobino> mauke--
15:46:11 <snoobino> haha
15:46:18 <Jedai> bakesz: when you have a function with several arguments you curry it, that is you write this :
15:46:21 <MyCatVerbs> bakesz: also, there are *loads* of identifiers in there that need to be defined somewhere, but haven't. For example, what on Earth is biggest_ok?
15:46:43 <Jedai> add3 x y z = x + y + z, not add3 (x,y,z) = x+y+z
15:47:05 <vixey> @forget , :  text "@quote ,"
15:47:05 <lambdabot> Done.
15:48:48 <bakesz> MyCatVerbs:i tried out all the functions i use in it,and they works,so i thought they are not needed
15:49:22 <bakesz> could you show me a simple code which makes this error message,too?
15:49:52 <mauke> > \x -> x / 3 `mod` 2
15:49:53 <lambdabot>       Overlapping instances for Show (a -> a)
15:49:53 <lambdabot>        arising from a use of `s...
15:49:55 <adamvo> > sqrt $ length $ replicate 5 ()
15:49:56 <lambdabot>       No instance for (Floating Int)
15:49:56 <lambdabot>        arising from a use of `sqrt' at <...
15:50:08 <adamvo> > (/3) $ length $ replicate 5 ()
15:50:10 <lambdabot>       No instance for (Fractional Int)
15:50:10 <lambdabot>        arising from a use of `/' at <i...
15:50:12 <mauke> > (\x -> x / 3 `mod` 2) 42
15:50:14 <lambdabot>   Add a type signature
15:50:17 <mauke> :-(
15:50:29 <MyCatVerbs> bakesz: in order to find the cause of type error, we need to know all of the other type signatures, at the very least.
15:51:10 <MyCatVerbs> bakesz: there is not enough information in the definition of that function on its own to be able to work out what is going on. We don't even know what it is *for*.
15:51:43 <adamvo> > round $ length $ replicate 5 ()
15:51:44 <lambdabot>       No instance for (RealFrac Int)
15:51:44 <lambdabot>        arising from a use of `round' at ...
15:51:55 <duaneb> huh
15:51:56 <duaneb> Perhaps you haven't installed the profiling libraries for package binary
15:52:09 <adamvo> > fix round
15:52:09 <duaneb> does the package binary have profiling in it?
15:52:10 <lambdabot>   Add a type signature
15:52:25 <adamvo> > round $ round 5
15:52:27 <lambdabot>   Add a type signature
15:52:29 <TomMD> duaneb: Any package can be profiled, it just must be compiled with the right flag.
15:52:36 <duaneb> hmm
15:52:42 <duaneb> I compiled Data.Binary with Cabal
15:52:48 <duaneb> how can I enable profiling?
15:52:55 <TomMD> See the help
15:53:10 <mauke> library-profiling: True
15:53:14 <mauke> in your config
15:53:22 <TomMD>  -p --enable-library-profiling     Enable Library profiling
15:53:30 <TomMD> On the command line, the above is recommended
15:53:38 <duaneb> my config doesn't work.
15:53:39 <TomMD> 'cabal install -p binary'
15:53:59 <bakesz> maybe this helps: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4945#a4945
15:54:02 <duaneb> there ye go :)
15:54:08 <Jedai> MyCatVerbs: The main problem being that the function is horribly obfuscated by the horrid formating and the unidiomatic uncurried functions (not to mention lack of anything like local variables)
15:55:49 <Jedai> bakesz: le_condition and fel_condition may be the source of your problem... But I strongly suggest you rewrite your whole program anyway, maybe after relearning Haskell and studying some real code ! ^^
15:56:54 <snoobino> what would that do ? => @let truc = text ", text \"> truc\""
15:58:12 <bakesz> Jedai:why is it bad?
15:58:42 <TomMD> snoobino: Please don't work to make the bots loop - its happened before on accident and isn't very fun.
15:58:49 <Jedai> bakesz: You ever read real Haskell code ?
15:58:53 <TomMD> Go ahead and evaluate pi if you are bored.
15:59:11 <snoobino> notice I didn't typed it
15:59:21 <TomMD> Yes, and I'm thankful for that.
15:59:49 <TomMD> But to answer your question, if you were actually asking, yes loops are possible.  Someone might have worked to address that, but I don't know for sure.
15:59:56 <bakesz> Jedai:i like to find the solutions on my own :)so please tell me what is the problem
16:00:15 <snoobino> there is only one way to find out
16:00:16 <Jedai> bakesz: I enumerated some of the problems already, but seriously don't you want to kill yourself when you try to touch the else clause in your "felso_hatizsak'" ? If you even manage to find it in the first place
16:00:35 <Asztal> bakesz: how does this look? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4944#a4946
16:00:43 <snoobino> ask on the wiki, of course
16:00:43 <TomMD> snoobino: I'll pretend you're talking about cabal-install'ing the bots and running them on your own system.
16:00:50 <TomMD> ah, or that
16:00:53 <Asztal> (I'm not entirely sure it's the same, but it's easier to read at least)
16:01:07 <Axman6> felso_hatizsak' :: forall b t. (RealFrac b, Integral b) => ([b], b, [b], [[b]], [[b]], t) -> [[b]] ... o.O
16:01:31 <Jedai> bakesz: Your code is unreadable, there's not an ounce of indentation, you repeat the same code a lot of time where you should be using local variables,....
16:01:49 <Axman6> bakesz: yeah, you're quite new to haskell aren't you
16:02:53 * Axman6 would strongly suggest not using massive tuples
16:03:20 * MyCatVerbs would strongly suggest reading LYAH or YAHT or something, too.
16:03:20 <Axman6> bakesz: i'm banning you from using tuples for one day! now, go forth and fix that code!
16:03:41 <Jedai> Axman6: I don't think "new to Haskell" is the only problem here...
16:03:45 <MyCatVerbs> At the very least, LYAH or YAHT would instill a vague notion of good Haskell style, just from seeing their examples.
16:03:45 <Hunner> > sum [2^^x|x<-[971..1023]] + (sum [sum [2^^x|x<-[1..y]]|y<-[916..968]])
16:03:48 <lambdabot>   1.7976931348623157e308
16:04:05 <Axman6> Jedai: well, i've only seen the type signatures, so i wouldn;t know :)
16:04:25 <Axman6> > exp 1
16:04:26 <lambdabot>   2.718281828459045
16:04:48 <Jedai> Asztal: Impressive (of course it help if you understand the language, what is it anyway ?), still perfectible
16:05:21 <Jedai> Axman6: Look at the first version in Asztal link
16:05:28 <Axman6> i am
16:05:34 <Asztal> Jedai: it's Hungarian
16:05:38 <Axman6> oh, heh, there's stuff above it...
16:05:45 <Jedai> Asztal: Thanks
16:06:13 <Axman6> wow...i've never seen haskell written like that
16:06:24 <Axman6> jesus :O
16:06:28 <bakesz> Asztal:would you like to help me (maybe in hungarian)?
16:06:39 <Axman6> it breaks hpaste's layout :o
16:06:45 <Asztal> bakesz: I don't speak Hungarian so well
16:07:29 <Axman6> bakesz: how well do you speak english? well enough to read a haskell tutorial (ans ask questions here)?
16:07:37 <duaneb> ok, I need to speed this up:
16:07:38 <duaneb>  putData ((r,g,b):dat') = {-# SCC "putData" #-} putWord8 b >> putWord8 g >> putWord8 r >> putData dat'
16:07:45 <duaneb> (ignore the SCC bit)
16:07:59 <Axman6> if so, you should check out LYAH:
16:08:02 <Axman6> @where lyah
16:08:02 <lambdabot> www.learnyouahaskell.com
16:08:08 <Jedai> Asztal: Of course, in your version it become clear that the algorithm is completely cracked... for example max is never used, biggestOk yadayada is repeated a hundred time, knapsack' should be a local function and so on
16:08:11 <Axman6> bakesz: ^^^^
16:08:17 <bakesz> Asztal:i had problems with the fel_condition and le_condition,and its hard to explain for me in english
16:08:57 <Asztal> say it in Hungarian if you like, but I might not understand
16:09:18 <drunkenmonkey> use you Hungarian phrase book
16:09:43 <Asztal> bakesz: http://www.webforditas.hu/index.php is quite a good translator, if you need one
16:11:57 <Axman6> duaneb: you could get sneaky and put the three word8's into a single word32: putWord32 (r*2^16 + g*2^8 + + b) >> putData dat
16:12:28 <opqdonut> why not 4?
16:12:46 <opqdonut> ah, nvm, read the backlog
16:12:57 <Axman6> > 2^16
16:12:59 <lambdabot>   65536
16:13:31 <Axman6> putWord32 (r*65536 + g*256 + b) >> putData dat
16:13:47 <mmorrow> @tell dsouza the lunabot (the bare infrastructure, just rewritten, no docs yet) source code is at http://moonpatio.com/repos/lunabot/
16:13:47 <lambdabot> Consider it noted.
16:13:57 <opqdonut> Axman6: why not use the Bits instance?
16:14:11 <Axman6> how?
16:14:21 <Axman6> bit shifting?
16:14:36 <opqdonut> yes
16:14:54 <Axman6> i think it'd end up longer, and possibly slower
16:14:58 <opqdonut> shiftL 100 8  + shiftL 99 8
16:15:03 <opqdonut> > shiftL 100 8  + shiftL 99 8
16:15:04 <lambdabot>   Add a type signature
16:15:11 <opqdonut> gah
16:15:27 <opqdonut> Axman6: i'd hope it'd translate into more efficient machine code
16:15:37 <duaneb> > shiftl (100::Word32) 8
16:15:38 <Axman6> i'm not sure it does
16:15:39 <lambdabot>   Not in scope: `shiftl'
16:15:44 <duaneb> > shiftL (100::Word32) 8
16:15:47 <lambdabot>   25600
16:15:59 <duaneb> > shiftL (100::Word32) 8 + shiftL (99::Word32) 8
16:16:01 <lambdabot>   50944
16:16:21 <opqdonut> yeah, and they should've been 16 and 8
16:16:24 <Axman6> you'd want one shiftl x 16 there...
16:16:25 <opqdonut> or something
16:17:22 <duaneb> could someone look at this?
16:17:23 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4948#a4948
16:17:29 <duaneb> slap me for doing the stupid things?
16:18:01 <duaneb> oh, and how can I do tail-call recursion with monads?
16:18:06 * BMeph takes a gander...and slaps duaneb a couple of times
16:18:13 <duaneb> :P
16:18:40 <vixey> btw
16:18:41 <vixey>                                 putWord8 0
16:18:41 <vixey>                                 putWord8 0
16:18:41 <vixey>                                 putWord8 0
16:18:41 <vixey>                                 putWord8 0
16:18:50 <vixey> isn't exactly what I would call good style
16:19:03 <duaneb> well, I wasn't sure how else to output those :P
16:19:06 <Axman6> uh yeah...
16:19:39 <duaneb> but aside from that?
16:19:50 <mmorrow> duaneb: replicateM, replicateM_, mapM, mapM_, forM, forM_, sequence, sequence_
16:20:28 <mmorrow> when you don't care about the result (or it's ()), use an underscore one, since then you don't hang onto the result unnecessarily
16:20:43 <Asztal> :t (toInteger, fromInteger, truncate)
16:20:45 <lambdabot> forall a a1 a2 b. (Integral b, RealFrac a2, Num a1, Integral a) => (a -> Integer, Integer -> a1, a2 -> b)
16:20:47 <mmorrow> replicateM_ 4 (putWord8 0)
16:20:51 <duaneb> mapM putWord8 [0,0,2,0,0,0,0,0]
16:20:52 <duaneb> ok
16:20:53 <duaneb> that's good
16:21:00 <mmorrow> mapM_ putWord8 (replicate 4 0)
16:21:01 <opqdonut> mapM_
16:21:05 <opqdonut> yeh
16:21:38 <duaneb> and aside from that?
16:22:00 <Axman6> what are the putWord16le 0 -- x coord bits doing?
16:22:43 <duaneb> uhh, that's just a required part of the header
16:22:50 <Axman6> rightio
16:23:04 <Jedai> bakesz: Another version, I didn't try to translate http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4944#a4950
16:23:06 <vixey> mapM putWord8 [0,0,2,0,0,0,0,0]
16:23:09 <vixey> isn't really an improvement
16:23:11 <duaneb> yea, I can add that to the end
16:23:16 <duaneb> vixey: ok, why not? :P
16:23:24 <duaneb> it's header garbage
16:23:27 <marcusb> hi, why is Data.HashTable related to IO Monades?  Is this the one I'd use to store a symbol name->value table?
16:23:33 <vixey> I was suggesting more like giving a declarative spec of the file
16:23:41 <vixey> not giving an imperative program that prints bits of it out
16:23:43 <duaneb> o.O
16:23:45 <Axman6> marcusb: you'd usually use Data.Map
16:23:51 <duaneb> whatever for?
16:23:52 <marcusb> ah 'kay
16:23:56 <vixey> if you're just a beginner don't worry about it
16:24:16 <duaneb> vixey: no, I'm honestly interested
16:24:24 <duaneb> how is a declarative format better?
16:24:43 <duaneb> the Targa is meant to write nothing but RGB files; I have no reason for color maps, black and white, or run length encoding
16:24:44 <duaneb> (yet)
16:24:53 <vixey> there's lots of reasons think about why fp is better than procedural in general
16:24:58 <MyCatVerbs> vixey: how is mapM putWord8 [0,0,2,0,0,0,0,0] in the Put monad *not* declarative?
16:25:17 <vixey> MyCatVerbs: it's the same as   putWord8 0 ; putWord8 0 ; ....
16:25:27 <duaneb> vixey: no, it's 8 times better
16:25:33 <Axman6> heh
16:25:35 <vixey> lol
16:25:38 <mle> heh
16:25:42 <duaneb> anyway
16:25:49 <MyCatVerbs> vixey: yes. putWord8 0; putWord8 0;... specifies that the next eight bytes should have the values 0,0,2,...
16:25:55 <duaneb> what would be a functional way of doing it? :P
16:26:27 <duaneb> I don't think the problem here is procedural/imperative vs functional, it's why-are-you-using-magic-numbers :P
16:26:32 <MyCatVerbs> vixey: it has an imperative reading too, sure, but that's kind of the whole point of do notation for monads.
16:27:01 <Axman6> duaneb: i might split the validation out into another function checkTarga, just to reduce clutter
16:27:04 <MyCatVerbs> duaneb: there is that, I guess. :|
16:27:12 <bakesz> Jedai:thanks,but...dont you have it with the old function names to try it out?
16:27:21 <duaneb> Axman6: yea, I was just about to do that
16:27:55 <Axman6> bakesz: did you take a look at LYAH?
16:28:24 <Jedai> bakesz: It's not an attempt to corrige your type errors, anyway I think they're in leCondition and felCondition (which you didn't give) so...
16:28:29 <PetRat> http://www.mibbit.com/pb/5lsECG Cofused about some stuff in chap 15, RWH. He is demonstrating a use of the State monad. Where I get lost is the instance declaration for 'Supply'. The first line is instance Monad (Supply s) where...  is that 's' the same as the 's' in the definitions?
16:29:11 <Jedai> bakesz: This code is exactly equivalent to what you gave us, but with better indentation, local variables and functions and respecting the standard Haskell style
16:29:11 <PetRat> What is the term for Supply.. a type that is parameterized by two additional types?
16:30:10 <Jedai> bakesz: Which means the function name like that (though that's not the important part and not absolute) but more importantly, functions taking their arguments properly, not all in one tuple
16:30:37 <bakesz> Jedai:I mean the old,bad function names(dot_product and so on).it would be easier to try out
16:31:10 <Jedai> bakesz:  Even if the name was the same you would still have to rewrite them to use a proper calling convention
16:31:36 <Saizan_> PetRat: we call parametrized types "type constructors" in general
16:32:03 <Saizan_> to specify how many and which paramenters we use kinds
16:32:07 <Saizan_> :kind Maybe
16:32:12 <Saizan_> @kind Maybe
16:32:13 <lambdabot> * -> *
16:32:17 <Jedai> bakesz: And I'm serious, your functions shouldn't take all their arguments in one tuple, it's not the Haskell way, it's innefficient, ugly and restrict their utility
16:32:19 <Saizan_> @kind Either
16:32:20 <lambdabot> * -> * -> *
16:33:26 <Jedai> bakesz: If you really prefer the old names, just do a search and replace, there is only 5 function names or so, it's not much of an effort !
16:33:34 <PetRat> Where I'm getting confused is I think the idea of declaring a type constructor to be an instance of another type constructor. Let's see, "Supply s" is itself a type constructor because Supply requires two types, does it not?
16:33:59 <MyCatVerbs> PetRat: yes. You can curry type constructors! ^_^
16:34:39 <Jedai> PetRat: It's like function, map is a function but map (+2) is also a function
16:34:47 <Axman6> @kind (+)
16:34:49 <lambdabot> Not in scope: type variable `+'
16:34:59 <Axman6> @kind (->)
16:35:01 <lambdabot> ?? -> ? -> *
16:35:20 <PetRat> Oh, I just thought of something. There is an easy confusion between constructors that are parameterized by types and parameterized by values.. because of haskell's type inference. In other words, if I write "Supply <v1> <v2>" I have BOTH declared a new type and created data.
16:35:29 <MyCatVerbs> Axman6: I can't help reading that as "WHAT!? onto WAT? onto WHATEVER!"
16:35:39 <vixey> PetRat: I don't unerstand
16:36:19 <Saizan_> PetRat: in your pasted code Supply is only a type
16:36:21 <Axman6> PetRat: you mean between type constructors and data constructors?
16:36:26 <Saizan_> PetRat: its constructor is "S"
16:36:28 <MyCatVerbs> PetRat: yyyes, but they're still completely distinct. It's just that it's possible to come up with fitting types from values, and to make up fitting values given the types.
16:36:33 <PetRat> In C++ templates, let's say you have a template RefCntPtr. Then you can make a type such as RefCntPtr<Int>. Then you can make data.
16:36:59 <PetRat> In Haskell you just type "RefCntPtr i" where i is inferred to be an Int and you've done both things at once.
16:37:07 <duaneb> wait, does "Maybe" fail with Nothing?
16:37:14 <Axman6> yes
16:37:15 <MyCatVerbs> duaneb: yes.
16:37:17 <MyCatVerbs> PetRat: yes.
16:37:22 <Axman6> yes!
16:37:25 <hellige> anyone here used reactive?
16:37:29 <roconnor> > fail "" :: Maybe ()
16:37:31 <lambdabot>   Nothing
16:37:45 <Saizan_> ah, yeah, you don't need to pass Int as a parameter explicitly
16:38:16 <Saizan_> you actually can't
16:38:28 <MyCatVerbs> PetRat: pretty much. The types and the values are still completely distinct concepts, but the compiler can indeed often work out the types from just the values.
16:38:52 <Saizan_> (which is sometimes annoying when you have fancier types)
16:38:53 <MyCatVerbs> Which is just a convenience, but a really really useful one.
16:39:09 <PetRat> Getting back to my pasted code.  the lower case-s in the instance... line must be a type variable correct?
16:39:21 <Saizan_> yes
16:39:32 <PetRat> However, in the next two lines, there is a lower-case s, which is... data?
16:39:55 <Saizan_> yeah, they are on distinct namespaces
16:40:10 <Saizan_> (and the type variable is not really in scope there, either)
16:40:24 <PetRat> Are they trying to confuse me or is there some good reason for doing that?
16:41:07 <Saizan_> not a really good reason
16:41:14 <Saizan_> i'd have written m >>= f = ..
16:42:22 <PetRat> Saizan_ where your lower-case m stands in for the monad, correct? and f  has the type (a -> (Supply s) b)
16:42:32 <Saizan_> right
16:42:57 <Saizan_> which is the same as (a -> Supply s b)
16:43:04 <vixey> what's Supply? not a comonad?
16:43:38 <Saizan_> we've the monad here
16:43:51 <Saizan_> http://www.mibbit.com/pb/5lsECG
16:44:55 <PetRat> What's interesting to me is the way a monad is similar to a class in Python which can store variables of different types, but we must not forget it's a type constructor.. To say more...
16:45:36 <Saizan_> store in which sense?
16:45:50 <sbahra> Warning: ghc-6.10.1:RtClosureInspect: could not find link destinations for:
16:45:50 <sbahra>     RtClosureInspect.RttiType RtClosureInspect.GhciType RtClosureInspect.TermProcessor RtClosureInspect.TermPrinter RtClosureInspect.TermPrinterM RtClosureInspect.Precedence
16:45:50 <sbahra> Warning: ghc-6.10.1:TcBinds: could not find link destinations for:
16:45:50 <sbahra>     TcBinds.MonoBindInfo
16:45:54 <sbahra> etc..., is this a problem?
16:46:42 <PetRat> We speak of "wrapping things in the monad" or we say that the code in a do-block all "executes in the monad" (or something similar). It's like a monad is a named type in a scripting language that just stores a value of any type (because it's a dynamically typed language, let's say)
16:47:17 <Cale> I *really* hate the term "wrapping things in a monad"
16:47:24 <PetRat> The "thing" wrapped in the monad can change from line to line in a do-block
16:47:26 * vixey wraps Cale in a monad
16:47:39 <Cale> Unless those things are themselves *types* and not values
16:48:39 <MyCatVerbs> vixey: I'm pretty certain Cale is already in IO. :3
16:48:41 <Cale> Integer, I suppose, is something you could wrap in a monad. (which would just mean applying the monad to it), but 5 is not.
16:49:11 <PetRat> Cale: you are speaking to my point, actually. As a beginner, I feel like some books are telling me to think of monads as wrappers for data, and some are telling me to think of them a type constructors. Because Haskell has type inference, there is a similarity.
16:49:36 <Cale> The latter sort of book is better :)
16:50:05 <MyCatVerbs> The latter sort of book is precisely correct, which is the best kind of correct.
16:50:06 <Cale> Though monads can be thought of as *kinds* of containers.
16:50:26 <PetRat> How about this phrase: "Nothing can escape from a monad".
16:50:27 <Cale> A list, like [1,2,3], is not a monad
16:50:46 <Cale> PetRat: That's also a flawed sort of thing to say
16:50:52 <PetRat> How about this phrase: "Nothing can escape from a variable of monadic type."
16:51:05 <vixey> that's a bad phrase
16:51:08 <Cale> I don't even understand what that one means
16:51:22 <mmorrow> , maybe 0 id (Just 42)
16:51:24 <lunabot>  42
16:51:33 <mmorrow> , maybe 0 id (return 42)
16:51:34 <lunabot>  42
16:51:42 <Cale> There are a lot of really bad monad tutorials
16:51:47 <PetRat> I am probably misremembering it, but some author used it. Maybe it was only in reference to the IO monad.
16:51:55 <mmorrow> , unsafePerformIO (return 42)
16:51:57 <lunabot>  luna: Not in scope: `unsafePerformIO'
16:52:10 <Cale> escape is just a bad word to use
16:52:15 <PetRat> Is it possible to pattern-match to IO?
16:52:17 <Saizan_> see? you can't.
16:52:22 <mmorrow> the constructor is hidden
16:52:35 <mmorrow> (since that is equivalent to unsafePerformIO)
16:52:44 <Cale> It needn't be
16:52:45 <Saizan_> IO is defined as an abstract type by the language
16:52:54 <mmorrow> but you can get it if you import a GHC module
16:52:56 <Cale> You could have an IO type which would be safe to pattern match against
16:53:32 <mmorrow> Cale: that'd be interesting
16:53:34 <Cale> But in existing implementations, values of type IO t are opaque programs which if run will produce a value of type t each time.
16:54:21 <Cale> That is, you shouldn't think of there being a value of type t hiding inside there.
16:54:39 <Cale> It's something which the thing will make for you at the time you run it.
16:54:49 <hatds> the escaping thing could be simply said as "the monad typeclass doesn't provide a function m a -> a, nor is a general one derivable from >>=, return"
16:55:06 <Cale> hatds: Right, that's better.
16:55:12 <mmorrow> although the same could be said for Functor
16:55:13 <PetRat> hatds: that makes more sense, thanks.
16:55:21 <Cale> There's no polymorphic function of type (Monad m) => m a -> a
16:55:47 <Cale> But for specific monads M, there might be plenty of functions M a -> a
16:56:00 <Cale> (or there might be none, as is the case with IO)
16:56:24 * roconnor can only think of the writer monad
16:56:34 <Cale> How about any state monad?
16:56:43 <roconnor> Cale: requires an s parameter
16:56:43 <hatds> head, fromJust (if you allow non totality)
16:56:56 <MyCatVerbs> Cale: I'd say that the case with IO, and indeed most things in Haskell that you can do impure things, is that there is one but for the purposes of politeness we refrain from mentioning it in refined company.
16:56:58 <Cale> (Each initial value gives you a different function of the appropriate type.)
16:57:04 <mokus> roconnor: or a fixpoint combinator
16:57:11 <roconnor> hatds: might as well allow const undefined while we are at it. :)
16:57:39 <ehird> "I suspect you would be hard-pressed to find a langauge that isn't imperative." —reddit
16:57:41 <ehird> Sorry, folk; we don't exist.
16:57:42 <hatds> roconnor: partial and undefined are different
16:57:42 <Cale> MyCatVerbs: Hm?
16:57:44 <hatds> :)
16:57:53 <roconnor> hatds: exactly
16:57:57 <roconnor> wait
16:57:57 <MyCatVerbs> Cale: I mean, the existence of (undefined :: a) breaks every constructive proof in the type system, because you can instantiate anything.
16:57:57 <Cale> MyCatVerbs: unsafePerformIO isn't really a function, it just pretends to be one.
16:58:03 <roconnor> I mean no they are not different
16:58:06 <hatds> ha, tricked you
16:58:07 <MyCatVerbs> Cale: and unsafePerformIO breaks all notions of purity.
16:58:18 <Cale> MyCatVerbs: Oh, of course I'm talking about defined things.
16:58:23 <ehird> unsafePerformIO doesn't exist in Haskell98.
16:58:30 <ehird> Just because some implementations expose it...
16:58:35 <Cale> Or at least, not-totally-undefined things.
16:58:46 <MyCatVerbs> Cale: and our types don't say anything about totality of functions, and so on and so forth.
16:58:51 <Cale> ehird: It is in the FFI extension to H98 though.
16:58:52 <shachaf> Since PostfixOperators was added in GHC 6.10, and was implicit in 6.8, is there a way to get a .hs file that works with both?
16:58:56 <TomMD> unsafePerformIO has probably caused more debates than any other glasgow 'extension' out there.
16:58:57 <ehird> Cale: Well, true.
16:59:01 <Cale> ehird: (which is standardised)
16:59:12 <ehird> Cale: Definition of GoodHaskell: "Haskell, but without unsafePerformIO."
16:59:14 <MyCatVerbs> There's no particular reason in practice to believe that any particular @djinn output should work, just because functions aren't necessarily total.
16:59:15 <ehird> There we go.
16:59:29 <ehird> hey guys
16:59:29 <ehird> http://www.reddit.com/r/programming/comments/8krbo/erlang_is_not_functional_response_to_scala_is_not/c09md6l
16:59:30 <shachaf> (Without using something like -fglasgow-exts? It complains if it comes across a LANGUAGE pragma it doesn't recognize.)
16:59:33 <ehird> wanna try educating him?
16:59:35 <mmorrow> every single ByteString you use, you're making a call to unsafePerformIO
16:59:37 <ehird> or do you think hopeless case
16:59:37 <MyCatVerbs> But in practice, things are good enough that we gloss over all of these holes.
16:59:58 <MyCatVerbs> ehird: it's tempting to write "Haskell is not a functional language" just for the sake of trolling dons. :D
17:00:00 <Saizan_> uh? @djinn lives in a total world, afaik
17:00:02 <ehird> from another comment: "Do you seriously want me to believe that the order in which the statement are executed is non-deterministic? That they will effectively be executed in a random order?"
17:00:06 <MyCatVerbs> Poor dons.
17:00:10 <TomMD> MyCatVerbs: Exactly - if you removed every package with an unsafePerformIO then probably 80% of hackage would be gone.
17:00:12 <ehird> MyCatVerbs: heck, I'm raging!
17:00:18 <ehird> TomMD: 80%? no, that's excessive
17:00:24 <ehird> i'd say like 10%
17:00:48 <TomMD> ehird: Well, I'd include anything that depends on a package with unsafePerformIO - so anything with bytestring for example.
17:00:56 <mmorrow> well, they'd all be broken due to their deps being gone :)
17:01:02 <ehird> TomMD: bytestring does not HAVE to use unsafePerformIO
17:01:03 <TomMD> ehird: So yes, 80% is probably high, but still it would be significant.
17:01:07 <ehird> It is merely an implementation detail, I would say
17:01:09 <TomMD> ehird: But it does.
17:01:14 <mmorrow> ehird: every ByteString would be in IO then
17:01:18 <ehird> TomMD: yes, but it is NOT part of the package's interface
17:01:24 <ehird> therefore it doesn't infect dependencies
17:01:28 <TomMD> ehird: A detail that gives it the performance it has, which is the reason the package is used.
17:01:31 <ehird> mmorrow: no— an implementation could provide the infrastructure for it
17:01:35 <ehird> without requiring unsafeness
17:01:35 <mmorrow> newtype ByteString = ByteString [Word8]
17:01:43 <mmorrow> there's nothing unsafe about it though
17:01:47 * Cale replied.
17:01:48 <MyCatVerbs> Saizan_: yes. djinn lives in a total world, but the real world is not total. You cannot necessarily assume that djinn's (total-function world) output will work in the real (partial-functions everywhere) world.
17:01:54 <ehird> I'm just saying
17:02:00 <ehird> bytestring does not have to use IO internally
17:02:04 <ehird> and unsafePerformIO
17:02:06 <ehird> to give its benefits
17:02:11 <ehird> it's just that way in current implementations
17:02:25 <Lemmih> TomMD: The 'base' package uses unsafePerformIO. So I guess 100% would have to be removed.
17:02:32 <hatds> can you make a fast bytestring without unsafePerformIO that lives in the IO monad?
17:02:35 * roconnor wants the partial function monad.
17:02:36 <ehird> Lemmih: does it have to?
17:02:38 <MyCatVerbs> Cale: good reply.
17:02:43 <vixey> roconnor: I have one
17:02:46 <TomMD> Lemmih: Where?  I'm not overly surprised, but was unaware.
17:02:51 <vixey> on moonpaste
17:02:51 <ehird> Cale: ah, uh, don't bother... grauenwolf is just a troll
17:02:54 <roconnor> vixey has one
17:03:30 <obk> I am trying to configure a package to compile under both 6.8 and 6.10. In 6.10, it requires PostfixOperators. If I put this in the Cabal file, even if protected by impl(ghc >= 6.10.0), I get an error when configuring the package. Is there a workaround?
17:03:47 <Cale> ehird: I'm aware, but I don't mind replying to trolls if they try to misinform people.
17:03:50 <vixey> I can't find it :/
17:04:03 <Lemmih> ehird: It uses unsafePerformIO to create global buffers for the various handles.
17:04:05 <vixey> http://www.unsafecoerce.com/fastcgi/hpaste.fcgi/view?id=562
17:04:10 <Saizan> obk: you need a later version of Cabal i think
17:04:16 <vixey> roconnor it's mostly ripped out of some slides I found
17:04:27 <ehird> Lemmih: Implementation detail, not part of interface.
17:04:45 <Lemmih> ehird: Same with bytestrings, no?
17:04:55 <ehird> exactly
17:05:09 <ehird> If the implementation provided infrastructure to do things like that safely, we would not need unsafePerformIO
17:05:20 <ehird> and since this unsafeness is not exposed via the interface, it does not infect across dependency barriers
17:05:38 <TomMD> ehird: Certainly, but unsafePerformIO is so general it would be hard to find a good set of safe constructs to replace it (in my opinion)
17:05:46 <obk> Saizan: Thanks, will try
17:05:51 <ehird> TomMD: Yep— I'm being totally theoretical here.
17:06:02 <ehird> I'm just arguing against "Everything is innately tied to unsafePerformIO, woe!"
17:06:59 <hatds> how would a compiler implement a safe version of unsafePerformIO?
17:07:09 <vixey> hatds there's no such thinga
17:07:48 <hatds> or rather, safe infrastructure to do things we want that we currently use unsafePerformIO
17:07:58 <hatds> (ehird's comment)
17:08:04 <roconnor> hatds: dependent types!
17:08:10 <ehird> hatds: by providing the stuff used primitively, pretty much
17:08:17 <ehird> as in, a primitive version of bytestrings' operations is the most trivail way
17:08:24 <sshc> wow.  learnyouahaskell.com's a great site
17:08:24 * roconnor proposes that dependent types solve all problems.
17:08:26 <Saizan> hatds: something like the ST monad for example
17:08:28 <ehird> more work could be done into general ways of doing things that seem unsafe
17:08:29 <ehird> roconnor++
17:08:31 <roconnor> ... except for stack overflows
17:08:32 <ehird> Saizan: that too
17:08:34 <vixey> roconnor didn't actually want a partiality monad..
17:08:58 <ehird> vixey: why not?
17:09:01 <ehird> partiality monads would rock
17:09:16 <roconnor> vixey: I want one, but I already knew how to make one.
17:11:48 <hatds> now I'm curious... would we think calling into C via IO to be "safe"?  I mean, it's C!
17:12:23 <hatds> *think of
17:12:43 <roconnor> calling into C is not safe in general
17:13:24 <MyCatVerbs> hatds: nothing in IO is guaranteed to be safe anyway. You have multithreading and Foreign.Storable, for starters.
17:13:47 <roconnor> what's unsafe about multithreading?
17:14:32 <vixey> roconnor: partiality monad is good for theory but in practice isn't it horribly inefficient (making these huge chains of data)?
17:14:44 <vixey> (you can't erase them and retain the computational meaning)
17:15:12 <vixey> runComputation (Now x) = x ; runComputation (Later c) = runComputation c -- works, but you can only do that at the end
17:15:13 <hatds> vixey: can you give an example?
17:15:26 <roconnor> vixey: presumably all you need is lazy evaluation.
17:15:29 <vixey> hatds: my paste shows an example of a program that is more lazy than it would be if you wrote it in direct haskell
17:15:48 <vixey> roconnor, I seem to write 'lazier than lazy' code using lfp of computation
17:15:56 <roconnor> lfp?
17:16:05 <vixey> least fixed point (by omega race)
17:16:43 <MyCatVerbs> roconnor: the ordering of operations isn't well defined unless you use a correct locking scheme, and you get no automatic proof as to whether or not your locking scheme *is* correct.
17:18:09 <SamB> MyCatVerbs: I think the linux kernel actually offers that ...
17:18:23 <SamB> there's a Kconfig option for it, I think
17:18:40 <MyCatVerbs> SamB: what? Deadlock resolution?
17:18:50 <SamB> (obviously only helps if it's the Linux kernel you want to prove the locking scheme of correct ...)
17:18:53 <roconnor> MyCatVerbs: so we are considering race conditions to be unsafe?
17:19:00 <SamB> MyCatVerbs: proving your locking scheme correct!
17:19:24 <SamB> where you == kernel hacker
17:19:31 <roconnor> vixey: I don't get your lazier than lazy comment.
17:19:34 <MyCatVerbs> SamB: huh? You can't prove arbitrary programs' locking schemes correct without solving the Halting Problem first?
17:19:50 <SamB> MyCatVerbs: well, I expect it only works sometimes!
17:19:54 <vixey> roconnor, I'm referring to the program in my paste
17:19:57 <MyCatVerbs> roconnor: sure, and there are other even less safe things. For example, non-atomic reads and writes.
17:20:03 <roconnor> vixey: I'm looking at it now.
17:20:07 <vixey> if you write that not in the computation monad it will not be as lazy
17:20:11 <vixey> you get _|_ more often
17:20:27 <vixey> so to make Computation monad useful in practice.. I don't know what you do
17:20:36 <SamB> but if it fails to prove your code correct, or fails to terminate in attemting to do so ... well, your code is probably too tricky to be allowed in the kernel, right?
17:20:43 <vixey> currently it doesn't seem good enough
17:20:51 <SamB> haven't tried that feature myself, though
17:21:07 <roconnor> MyCatVerbs: can you use race conditions to read and write a complex data structure and totally screw it up by getting an impossible value?
17:21:11 <marcusb> where can I find more info on the   { foo :: TypeFoo, bar :: TypeBar } ... { foo = somefoo, bar = somebar }  notation?  I don't even know how it is called.  I want to find out how I can write a modify function for a state monad with such a type
17:21:15 <SamB> I only changed two lines, one of which was a comment ;-)
17:21:27 <SamB> and the other one, I just replaced one way of writing "0" with another
17:21:36 <MyCatVerbs> roconnor: yes, if you don't have atomic reads and writes on that data structure.
17:21:58 <hatds> marcus: record notation
17:22:15 <roconnor> MyCatVerbs: hmm, but isn't updating a simple pointer update, which usually is attomic?
17:22:16 <marcusb> thanks
17:22:41 <MyCatVerbs> roconnor: not on all architectures. On x86, yes, but x86 is weird in this respect.
17:23:14 <roconnor> vixey: which function are you talking about?
17:23:20 <MyCatVerbs> roconnor: plus you might concievably get inconsistent views. Imagine some data structure with multiple pointers in it, where it's significant whether two different pointers inside it alias the same location or not.
17:23:30 <vixey> isAscending
17:23:40 <stroan> Finally finished mandelbrot. That took more learning than in any other language I've ever started with.
17:24:27 <roconnor> MyCatVerbs: what you ask me to imagine doesn't sound like haskell.
17:25:13 <mae_> hFlush: resource vanished (Broken pipe), what the heck does this mean!
17:25:26 <MyCatVerbs> roconnor: fine. data Foo = Foo { first :: (IORef Int), second :: (IORef Int) }.
17:25:35 <TomMD> mae_: Your handle is probably closed, so flushing isn't possible.
17:25:44 <roconnor> vixey: I see what you mean.
17:25:53 <MyCatVerbs> roconnor: pretend there's some significance as to whether (first foo) and (second foo) have identical values or not.
17:26:00 <PetRat> http://www.mibbit.com/pb/7Xd03D Looking at my example again, in the line marked (*), where does the definition of the "return" on the right come from?
17:26:32 <MyCatVerbs> roconnor: it's a million miles away from idiomatic, but you can make more complicated examples that are perhaps less obviously broken.
17:27:01 <roconnor> MyCatVerbs: I'm looking for an example where type soundness is broken, not data structure invarients.
17:27:10 <PetRat> stroan: pardon my ignorance---what are you referring to? a book?
17:27:32 <MyCatVerbs> roconnor: oh, right. Nah, you only break type soundness with non-atomic reads and writes.
17:27:56 <stroan> PetRat: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2439 Implementing mandlebrot is one of the first programs I write in any language
17:28:22 <mae_> stroan: rock on.
17:28:51 <roconnor> MyCatVerbs: and on x86, thunk updates are always atomic? ... What about on whatever motorola chip that Macs use, or are they all x86 now?
17:29:00 <MyCatVerbs> roconnor: if one thread is writing while another is reading on an arch where pointer reads and writes aren't always atomic, you can end up with the reader taking, say, the low bits of IORef's pointer's old value and the high bits of the new value.
17:29:04 <stroan> mae_: :)
17:29:04 <PetRat> stroan: I started learning Haskell a short time ago, and it is so different from any previous language I've learned. Feel like I was learning basic things for the first time.
17:29:25 <MyCatVerbs> roconnor: PowerPC. Macs are all x86 now. I'm not sure, it varies from architecture to architecture.
17:29:42 <stroan> PetRat: yeah. I know. Also used to there being the usual slew of C libraries available through trivial interfaces
17:29:54 <PetRat> bump -- simple question here -- http://www.mibbit.com/pb/7Xd03D Looking at my example again, in the line marked (*), where does the definition of the "return" on the right come from?
17:30:11 <MyCatVerbs> roconnor: the only two I know offhand are Alpha, where just about everything is non-atomic unless you put explicit barriers in, and x86, where just about everything is atomic provided it's no longer than the size of a general-purpose arithmetic register.
17:30:36 <opqdonut> PetRat: the return of the list monad
17:30:47 <opqdonut> :t return 1 :: [Integer]
17:30:48 <lambdabot> [Integer]
17:30:53 <opqdonut> > return 1 :: [Integer]
17:30:54 <lambdabot>   [1]
17:31:40 <opqdonut> er, no
17:31:44 <Asztal> kind of looks like it should be the State monad return
17:31:47 <opqdonut> the return of the state monad actuallhy
17:31:49 <opqdonut> -h
17:32:06 <PetRat> opqdonut: yeah that make smore sense.
17:32:42 <PetRat> PetRat's test
17:35:02 <PetRat> Can someone tell me what the definition of the State monad's return is?
17:35:18 <MyCatVerbs> @src State
17:35:19 <lambdabot> Source not found. I feel much better now.
17:35:42 <MyCatVerbs> PetRat: http://www.haskell.org/all_about_monads/html/statemonad.html
17:35:58 <hatds> what's the simplest way to write f :: BinTree Int -> BinTree Int which changes each node to the sum of all its descendants, but where f is not recursive?
17:36:12 <hatds> (BinaryTree)
17:36:14 <MyCatVerbs> hatds: what's BinTree look like?
17:36:20 <PetRat> Thanks.
17:36:31 <adu> hi
17:36:35 <adu> how do I "fixWith"?
17:36:44 <augustss> hatds: Do you have a fold function for BinTree?
17:36:52 <hatds> say Tree a = Node a | Branch a (Tree a) (Tree a)
17:37:11 <hatds> yea, folds, traverse, etc.
17:37:15 <adu> like a function like :: (a -> a) -> a -> a
17:37:20 <adu> but like fix
17:38:49 <augustss> hatds: well, then you should be able to do it :)
17:38:53 <bwr> for some reason i thought you could derive Random when defining a datatype. is this not correct?
17:39:12 <hatds> augustss: I'm not seeing it :(
17:39:41 <augustss> bwr: it's not
17:40:12 <bwr> i'm doing something like data Color = Red | Blue ...
17:40:13 <augustss> hatds: one pass with a fold to add up all the numbers, one pass with a map to replace
17:40:19 <MyCatVerbs> > let { fixWith f v = let x = f v in fixWith f x } in fixWith (\l -> head l : l) "a"
17:40:29 <lambdabot>   mueval: Prelude.read: no parse
17:40:30 <bwr> is there someway i can generate a random value of type COlor
17:40:32 <bwr> Color
17:40:33 <MyCatVerbs> Blast.
17:41:01 <augustss> bwr: use toEnum on an appropriate Int
17:41:10 <adu> MyCatVerbs: thanks :)
17:41:19 <MyCatVerbs> bwr: derive Enum and Bounded for Color. Generate Ints between (fromEnum minBound) and (fromEnum maxBound).
17:41:30 <MyCatVerbs> adu: I'm not sure whether it's correct or not! x_x
17:41:52 <MyCatVerbs> adu: no, it isn't. Hrmn.
17:41:54 <augustss> QuickCheck has a number of utilities to generate random values.
17:42:00 <bwr> thanks
17:42:01 <adu> oh :(
17:42:07 <opqdonut> :t foldr (.) id . repeat
17:42:10 <lambdabot> forall a. (a -> a) -> a -> a
17:42:18 <opqdonut> that should be correct
17:43:14 <adu> opqdonut: no thats infinite
17:43:36 <opqdonut> well stuff with fix tends to be
17:43:46 <adu> I want something that keeps going only while the output reaches a fixedpoint
17:43:46 <hatds> augustss: in the first pass though at each node you fold over all the descendents
17:44:03 <adu> s/while/until/
17:44:03 <hatds> augustss: right?  I want to get away with just adding the two immediate children together
17:44:27 <augustss> hatds: that's what fold will help you do
17:44:54 <codolio> :t foldr ($) id . repeat
17:44:55 <lambdabot> forall a. ((a -> a) -> a -> a) -> a -> a
17:45:20 * Saizan doesn't see how to divide this in two passes
17:45:38 <adu> so if iterate f xs = [5, 7, 4, 8, 6, 2, 3, 1, 1, 1, 1, ...] then fixWith f xs = 1
17:45:41 <dolio> :t foldr ($) undefined . repeat
17:45:42 <lambdabot> forall b. (b -> b) -> b
17:46:06 <PetRat> http://www.mibbit.com/pb/WxgZBa  I have another question. I don't even know how to ask it. I'm stuck in trying to understand this example because I see [s] in one place and s in another and I don't know how to bring these together.
17:47:08 <adu> PetRat: well, you can either remove some brackets of insert some brackets :P
17:47:41 <Saizan> PetRat: those two 's' are not the same one
17:48:11 <MyCatVerbs> adu: in order to keep going until you reach a fixpoint, you need more an (Eq a) constraint.
17:48:17 <PetRat> Can you show me how to rewrite it to make it clearer?
17:48:33 <Saizan> PetRat: instance Monad (State s) where .. <- here 's' is a variable so you can instantiate to any type you want
17:48:35 <MyCatVerbs> adu: so that you'll be able to tell when you've hit the fixed point.
17:48:37 <marcusb> this may be over my head, but anyway: I want to implement a very simple virtual machine, and have a state monad for the machine state, and an array of opcodes, the result of execution of the opcodes is a list of strings.  I want to pattern match on one or more instructions (thus I don't want to use a fold or something similar simple). Would it be sensible to do
17:48:37 <marcusb> execute :: [Opcode] -> State Machine ([String]) instr1:instr2:rest = do { do_instr1; do_instr2; strtail <- execute rest ; return "something":strtail }
17:48:37 <marcusb> I think I am asking if this is or can be made tail-recursive(?).
17:48:48 <adu> yes, I should have been clear :: Eq a => (a -> a) -> a -> a
17:49:05 <EvilTerran> MyCatVerbs, what would be insufficient about Eq?
17:49:09 <MyCatVerbs> adu: fixWith f v = let v' = f v in if (v == v') then v else fixWith v' -- easy peasy.
17:49:19 <adu> oh ok
17:49:38 <MyCatVerbs> EvilTerran: nothing. The word "more" shouldn't have been in that sentence, it was a typo. Brain-o. Whatever.
17:49:45 <EvilTerran> ah
17:49:46 <Saizan> PetRat: it's like when you define a function foo x = ..., when i call it with an argument say foo [x] it doesn't matter that 'x' was also the name of the formal parameter
17:50:03 <PetRat> Okay let me fiddle a bit..
17:50:04 <adu> MyCatVerbs: you forgot an 'f'
17:50:15 <MyCatVerbs> adu: yes, yes I did.
17:50:21 <MyCatVerbs> You didn't, though. :3
17:51:04 <marcusb> maybe I should store the strings inside the state and only dump them at the end
17:51:18 <mmorrow> @type \f -> fix (\k -> either k id . f)
17:51:20 <lambdabot> forall b a. (a -> Either a b) -> a -> b
17:51:38 <augustss> marcusb: yes, probably
17:52:02 <mmorrow> > (\f -> fix (\k -> either k id . f)) (\a -> if 10 < a then Right a else Left (a+1)) 0
17:52:04 <lambdabot>   11
17:52:44 <Saizan> marcusb: why be tail recursive when you can be lazy? i'd use the WriterT monad transformer
17:53:13 <marcusb> Saizan: basically everything I do in haskell can be explained by ignorance :)
17:53:28 <adu> MyCatVerbs: it works!! thanks
17:53:54 <MyCatVerbs> adu: No problem. Have fun. Don't use it irresponsibly. ;)
17:54:06 <adu> lol
17:54:07 <marcusb> Saizan: so the idea is to wrap the machine state in another monad that stores the output strings and write to that?
17:54:50 <marcusb> I guess that's similar to storing the strings myself, except I don't need to implement it myself if I can understand monad transformations
17:55:09 <Saizan> marcusb: Writer gives you a kind of logging facility, so you can e.g. tell ["something"] and it'll get appendend to what you tell'ed before
17:55:32 <marcusb> yeah, I'm roughly aware of it.  I guess I need to read section III in All About Monads
17:55:34 <Saizan> the log can be any Monoid, but it's common to use a list
17:55:46 <mmorrow> marcusb: i like the idea of this "Status" datatype in http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=772
17:56:42 <vixey> mmorrow: looks a lot like the ordinal data type
17:57:12 <Saizan> marcusb: if you just store the strings in the state you'd be less lazy, in that you can't look at the first strings before evaluating the last "put" in the computation
17:57:25 <mmorrow> vixey: i'm not sure what that is, but it's similar to MonadPrompt (although i've never used that, but from what i understand that's the basic idea)
17:57:41 <marcusb> Saizan: ah
17:57:42 <mmorrow> , [$bf|.+[.+]|]
17:57:44 <lunabot>  luna: No instance for (GHC.Show.Show
17:57:46 <mmorrow> , [$bf|.+[.+]|] ""
17:57:48 <lunabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK...
17:57:54 <mmorrow> output
17:59:44 <mmorrow> so the idea of `Status' is that you just write a function :: Status -> o, then you can mutual with the eval function of type :: [Code] -> Status
18:00:23 <sauf_> hi all, how can I write a polymorphic version of iterate
18:00:41 <mmorrow> and if you want to output,   eval (Out msg : rest) = W "something" (eval rest)
18:00:42 <sauf_> which would work with powerSet :: [a] -> [[a]]
18:00:43 <sauf_> and for which "take 2 $ polyIterate powerSet [1]" would give me
18:01:11 <sauf_> [ [[],[1]],  [ [], [[1]], [[]], [[],[1]] ] ]
18:01:11 <sauf_> ?
18:01:13 <mmorrow> interp withStat code = withStat (eval code)
18:01:36 <Saizan> sauf_: can you imagine a type for polyIterate?
18:01:45 <mmorrow> eval (ReadChar : rest) = R (\c -> .. do something with c ... eval rest)
18:01:52 <sauf_> no
18:02:26 <sauf_> :(
18:03:15 <Saizan> you can make a type for arbitrarily nested lists though
18:03:36 <mmorrow> @type Node
18:03:38 <lambdabot> forall a. a -> Forest a -> Tree a
18:04:15 <Saizan> Node is not quite what we want here
18:04:22 <sauf_> Saizan: yes but would it be executable ?
18:04:26 <Saizan> the elements should be all at the "leafs"
18:04:28 <mmorrow> but since we can't define datas in the interp..
18:05:03 <Saizan> sauf_: yes, but you'd have to deal with its constructors
18:05:04 <mmorrow> arg, it's painful with Tree
18:05:21 <mmorrow> data T a = Tip [a] | T [T a]
18:05:55 <sauf_> mmorrow: is it for me ?
18:06:42 <Saizan> data T a = Nest (T [a]) | Tip a
18:06:48 <mmorrow> ghci> [T[Tip[],Tip[1]],T[Tip[],T[Tip[1]],T[Tip[]],T[Tip[],Tip[1]]]]
18:06:48 <mmorrow> [T [Tip [],Tip [1]],T [Tip [],T [Tip [1]],T [Tip []],T [Tip [],Tip [1]]]]
18:07:02 <sauf_> mmorrow: Saizan thanks !
18:07:03 <Saizan> so you enforce that you've the same level of nesting everywhere, i think
18:07:37 <mmorrow> ghci> flat (T[T[Tip[],Tip[1]],T[Tip[],T[Tip[1]],T[Tip[]],T[Tip[],Tip[1]]]])
18:07:37 <mmorrow> [1,1,1]
18:07:51 <mmorrow> let flat (Tip xs) = xs; flat (T ts) = concatMap flat ts
18:15:19 <mmorrow> flat (Tip a) = [a]; flat (Nest t) = (concat . flat . flat) t {- for Saizan's polymorphic recursive T -}
18:23:20 <davidmccabe> This seems like sort of a hack; anyone have a better implementation handy?
18:23:21 <davidmccabe> uniqueSorted l = Set.toAscList $ Set.fromList l
18:23:46 <MyCatVerbs> davidmccabe: nah, that's a perfectly cromulent way of expressing it.
18:23:57 <PetRat> @ runstate
18:24:03 <PetRat> @runstate
18:24:04 <lambdabot> Unknown command, try @list
18:24:27 <MyCatVerbs> davidmccabe: the only other efficient thing you could do would be to use Data.List.sort and then scan the list dropping identical items.
18:24:35 <PetRat> How do you ask lambdabot for a definition of runState?
18:25:39 <MyCatVerbs> > let { identical (a:b:cs) = if a == b then identical (b:cs) else a : identical (b:cs); identical a = a; } in identical . sort $ [1,4,3,2,4,3,5,8,1,7]
18:25:40 <lambdabot>   [1,2,3,4,5,7,8]
18:26:38 <Saizan> PetRat: there's @src in general, but runState is actually just a field accessor
18:27:06 <PetRat> Oh, I see it now. A field accessor of State.
18:27:13 <Saizan> yup
18:27:21 <Saizan> it just unwraps the State constructor
18:27:44 <Saizan> "data-constructor"
18:28:26 <PetRat> Saizan: regarding this example, I'm trying to "play compiler" and work it through with concretes. Funny, because in RWH the example that makes all the types concrete doesn't come until the end of the chapter. So I'm working backwards from that, hoping to figure out how the compiler uses these type constructors.
18:28:50 <PetRat> I have to go to dinner now, but should have a handle on this by later tonight.
18:29:52 <mmorrow> struct con {int tag; char payload[];};
18:30:44 <PetRat> For some reason I'm obsessed about getting through chapter 18 (Monad transformers) a.s.a.p., as though I were cramming for an exam. (I'm not in school---I'm a professional programmer but don't need Haskell for my work. It is for home projects.)
18:31:05 <PetRat> I need to relax and do something non-Haskell for a while.
18:31:11 <mmorrow> (oh, i think i misunderstood what you're after with that struct)
18:31:31 * roconnor needs to relax and write some Haskell for a while.
18:31:50 * Saizan needs to relax and get some sleep for a while
18:33:07 <PetRat> What's the syntax for writing about yourself in the third person? Sorry about my newness to IRC
18:33:14 <alexsuraci>  /me
18:33:28 * PetRat is talking in the third person.
18:37:54 <NickMib> SUCK IT FUCKERS
18:38:30 <Hunner> > [floor(x/2) | x <- [0 .. maxBound]]
18:38:31 <lambdabot>   Add a type signature
18:39:02 <Hunner> Where does it need a type signature for that?
18:39:20 <roconnor> what is the type of x?
18:39:37 <Hunner> > [floor(x/2) | x <- [0 .. maxBound::Int]]
18:39:38 <lambdabot>       No instance for (RealFrac Int)
18:39:38 <lambdabot>        arising from a use of `floor' at ...
18:40:01 <roconnor> you cannot divide with Ints
18:40:05 <roconnor> you can `div` though.
18:47:37 <Axman6> ok, so. does R^2 have more numbers in it than R^1?
18:48:25 <dolio> R is the reals?
18:48:32 <Axman6> yeah
18:48:40 <dolio> They have the same number of elements.
18:49:10 * Axman6 does not like this
18:49:20 <josephholsten> diagonalization proof, seems to imply otherwise
18:50:36 <Axman6> so 2D space has as many elements as 1D (just making sure the question's clear)
18:51:03 <dolio> Yes. As does any finite dimensional space.
18:51:11 <wli> |R^k|=k|R|=|R| when k is finite.
18:51:45 * Axman6 still does not like this
18:51:52 <dolio> Maybe a countably infinite dimensional space, too. I'm not sure about that one.
18:53:11 <dolio> I'm not sure what mapping from R^2 to R you use to demonstrate it, though.
18:54:07 <josephholsten> countable infinite is aleph-0
18:54:45 <dolio> Maybe interleaving the digits in some representation would do?
18:55:05 <josephholsten> reals are cardinality aleph-1
18:55:06 <Asztal> it would
18:56:15 <josephholsten> oops, cardinality of continuum = 2^aleph-0
18:56:17 <dolio> That's probably most convincing, too, if you take [0,1)^2, and show that it has the same cardinality as [0,1).
18:56:44 <dolio> Then you show that R^2 has the same cardinality as [0,1)^2.
18:57:30 <marcusb> Saizan: hey, WriterT [String] State Machine () works now, amazingly enough.  Took me awhile to get lifting right and figure out how to run it, the best example was in Real World Haskell.
18:57:34 <marcusb> thanks a lot
18:59:26 <camio> Does anyone have a general idea for how often the google summer of code projects complete their objectives?
19:02:01 <kyevan> Is it possible to construct an infinite list where the value of each entry relies on the previous one/few?
19:02:19 <davidmccabe> First Haskell program, almost. Any comments or suggestions? http://dmccabe.org/tmp/quotient_rings.hs
19:02:49 <SubStack> camio: #gsoc
19:02:56 * roconnor tries to construct a continous injection from R^2 to R
19:03:07 <SubStack> I'm sure they'd know better than haskell folks
19:03:20 <stroan> kyevan: f a b c = a+b+c : f b c (c+2) ?
19:03:26 <camio> SubStack: thanks
19:03:37 <stroan> that kind of thing?
19:04:04 <kyevan> Oh. Right, recursive calls!
19:04:07 <kyevan> Yeah :P
19:04:30 <SubStack> davidmccabe: pretty ambitious for a first program
19:05:06 <roconnor> davidmccabe: I don't see anything particularly wrong by glancing at the code.
19:05:15 <SubStack> although it's not terribly clear what's going on, some sort of latex thing it seems
19:05:39 <SubStack> more comments is a good suggestion
19:06:00 <camio> davidmccabe: I would probably make another function for latexEnclose :: String -> String -> String, that handles the begin and end stuff.
19:07:01 <mae_> what is the best way to handle a ctrl-c across windows and nix (sigterm)
19:07:05 * SubStack is playing with zippers and rose trees
19:07:11 <roconnor> davidmccabe: I wouldn't indent your where section so much.
19:07:29 <camio> davidmccabe: That would be bringing the latex part closer to a DSL (domain specific language). It makes code like this very readable.
19:08:05 <alexsuraci> is there any sort of package for sending packets to/from a persistently connected client and server? (for example, implementing a mmorpg server)
19:08:21 <camio> davidmccabe: Like roconner said. I usually indent 2 spaces myself.
19:08:39 <SubStack> alexsuraci: Network is nice
19:08:42 <roconnor> alexsuraci: I remember reading a blog post about a protocol library.
19:09:02 <SubStack> Network.Socket not so much
19:09:07 <alexsuraci> SubStack: Looking at it, but it looks like it's built for sending/receiving strings mostly
19:09:09 <roconnor> or was it a Monad.Reader article?
19:09:15 <camio> davidmccabe: By the way, thanks for sharing your code with us!
19:09:27 <SubStack> raw packets?
19:09:39 <alexsuraci> SubStack: yeah, as in hex data and such
19:10:12 <camio> davidmccabe: Also, depending on how comfortable you are with higher level functions, uniqueSorted = Set.toAscList . Set.fromList.
19:10:13 <SubStack> there's a Raw thing in Network.Socket
19:10:13 <davidmccabe> You're welcome, camio. Thanks everybody for the comments.
19:10:19 <SubStack> so however you'd do that in C I guess
19:10:32 <davidmccabe> camio: I did that, but I had to add a type declaration and overall it was less clear because of the extra clutter introduced by it.
19:10:51 <davidmccabe> :: (Eq a) => [a] -> [a] I think.
19:10:52 <SubStack> type declarations are good
19:11:01 <davidmccabe> Actually it had to be Ord.
19:12:04 <camio> davidmccabe: keep up the work. There is sooo much to learn to improve ones coding in haskell if my experience is any indicator.
19:12:33 <davidmccabe> camio: This is pretty much a direct translation from some Python I wrote the other day.
19:13:03 <davidmccabe> I'm also trying to figure out exactly the right place to go from sets to lists, to get rid of the uniqueSorted everywhere.
19:13:19 <camio> davidmccabe: How do you like programming in haskell in comparison so far?
19:25:22 * wli usually just deals with Set almost everywhere when uniqueness is a constraint.
19:25:39 <davidmccabe> camio: It's a pain in the ass.
19:25:46 <davidmccabe> :)
19:26:38 <duaneb> so
19:26:41 <duaneb> I have this function
19:26:43 <camio> :) I feel you, bro. Get's better.
19:26:44 <SubStack> once you pick up the idioms it gets better
19:26:50 <duaneb> wait a minut
19:26:52 <duaneb> minute*
19:27:23 <duaneb> > let foo :: (Monad m) => Int -> m; foo 5 = return ()
19:27:25 <lambdabot>   <no location info>: parse error on input `;'
19:27:30 <duaneb> what's up with that?
19:27:38 <duaneb> not lambdabot's error
19:27:40 <dibblego> m is a type constructor :: * -> *
19:27:50 <duaneb> what does that mean?
19:27:58 <dibblego> it means it takes another type variable
19:28:04 <duaneb> dammit
19:28:18 <dibblego> > let foo :: (Monad m) => Int -> m (); foo 5 = return () in 7
19:28:20 <lambdabot>   7
19:28:50 <roconnor> @kind Maybe
19:28:50 <duaneb> yea, I just figured that out :P
19:28:51 <lambdabot> * -> *
19:29:02 <roconnor> @kind Maybe Int
19:29:03 <lambdabot> *
19:29:15 <roconnor> @type Just 7
19:29:16 <lambdabot> forall t. (Num t) => Maybe t
19:29:24 <roconnor> ah, close enough
19:29:40 <roconnor> @type Just (fix bitsize)
19:29:41 <lambdabot> Not in scope: `bitsize'
19:29:44 <roconnor> @type Just (fix bitSize)
19:29:45 <lambdabot> Maybe Int
19:37:10 <duaneb> so, I have a function here
19:37:10 <duaneb> putData ((r,g,b):dat') = putWord8 b >> putWord8 g >> putWord8 r >> putData dat'
19:37:14 <duaneb> Is that tail recursive?
19:37:37 <idnar> does it matter?
19:37:41 <duaneb> idnar: yes
19:37:48 <Berengal> It's not even a function
19:37:54 <duaneb> Not in this case, especially, but I want to understand the language
19:37:57 <duaneb> Berengal: ?
19:38:25 <Berengal> Well, it is, but it produces an action
19:38:39 <duaneb> that's true
19:38:46 <duaneb> but is the call to putData a tail call?
19:38:48 <Berengal> I like to think of such functions as actions with parameters...
19:39:02 <duaneb> I mean, that's what I want to know
19:39:37 <Berengal> No, the last call is to (>>)
19:39:37 * ski . o O ( forM_ )
19:39:53 <duaneb> Berengal: dammit
19:39:56 <Berengal> But I'm being pendantic
19:40:03 <duaneb> any way to MAKE it a tail call?
19:40:04 <Berengal> It'll run in constant stack though
19:40:09 <duaneb> ok
19:40:10 <duaneb> why is that?
19:40:14 <duaneb> special case for monads?
19:40:17 <Berengal> It's being lazy about it
19:40:24 <duaneb> or is the compiler just smart in the order it applies the functions?
19:40:41 <Berengal> Not as much smart as lazy
19:40:48 <idnar> duaneb: lazy evaluation means things aren't evaluated until they're needed
19:41:05 <duaneb> Is there a paper on this somewhere?
19:41:10 <Berengal> duaneb: You need to stop thinking in terms of tail calls :P
19:41:17 <duaneb> I understand lazy evaluation fine, just not in this case....
19:41:23 <Cale> What that really means, for the most part is that functions are applied outermost first.
19:41:35 <duaneb> I don't know what 'outermost' means
19:41:40 <duaneb> right or left most? ::P
19:41:45 <Cale> Think of expressions as trees
19:41:54 <Berengal> duaneb: leftmost, assuming operators are written prefix
19:41:55 <Cale> Start nearest the top of the tree.
19:42:04 <Berengal> A function is evaluated before its arguments
19:42:09 <Cale> right
19:42:16 <duaneb> ok, that makes sense
19:42:18 <Cale> I'll do my standard example.
19:42:22 <duaneb> the laziness doesn't, though
19:42:23 <Cale> Suppose we have double x = x + x
19:42:37 <Cale> and we want to evaluate double (double 5)
19:42:45 <duaneb> though, the function does absolutely nothing BUT return if putData returns
19:42:52 <roconnor> The whole notion of tail-call makes no sense for haskell because "entering a function" does not push anything onto a stack.
19:43:10 * duaneb needs to learn the haskell internals
19:43:14 <duaneb> is there a paper on THAT?
19:43:21 <jmcarthur> duaneb: STG machine
19:44:04 <stroan> roconnor: thanks for that. That's acutally cleared a lot up in my head
19:44:11 <Cale> duaneb: It's not necessary to really understand the GHC implementation to have a good sense of things like performance though, in most cases.
19:44:13 <duaneb> roconnor: how does it pass information, then?
19:44:17 <duaneb> through registers and the heap?
19:44:28 <roconnor> duaneb: I usually imagine it doing graph reduction
19:44:28 <duaneb> Cale: It will help me figure out the best way to write, though
19:44:29 <Cale> duaneb: There is a much higher-level approximation you can use.
19:44:35 <roconnor> even though that isn't quite how GHC works.
19:44:40 <duaneb> Clearly thinking of tail-calls doesn't help
19:44:57 <duaneb> hmm
19:44:58 <duaneb> ok
19:45:03 <duaneb> I'll start digging through ghc
19:45:04 <Berengal> Imagine evaluating the AST directly
19:45:07 <Cale> Wait wait
19:45:16 <Berengal> From the top
19:45:21 <duaneb> I'm still reading :P
19:45:36 <Cale> Come to haskell-overflow, and I'll go over some evaluation with you and it should start becoming more obvious how things work :)
19:53:09 <alexsuraci> it occurs to me that I keep changing my language and it's getting closer and closer to haskell
19:53:19 <alexsuraci> i predict that the final product will end up being haskell implemented in itself
19:55:32 <halberd> if I'm looking for a minimalistic dependently typed language, should I look no further than LF (Logical Framework)?
19:56:42 <dolio> Using what, twelf?
19:57:03 <halberd> well I want to write my own
19:57:13 <dolio> Oh, okay.
19:57:28 <halberd> but based on some simple formalism
19:57:43 <dolio> Well, calculus of constructions is pretty easy to implement.
19:57:54 <dolio> I'm not very familiar with LF, but I doubt it's any easier.
19:58:12 <dolio> If easiness is what you're going for.
19:58:20 <halberd> it is
20:06:21 <halberd> and CoC is as powerful as LF?
20:07:07 <halberd> I mean, can every theorem that can be proved in LF also be proved in CoC?
20:09:53 <dolio> Well, wikipedia doesn't give a whole lot of information on LF, but they sound pretty similar.
20:12:02 <dolio> I guess, strictly speaking, I've implemented LF before, as well.
20:17:25 <halberd> if you've implemented CoC, could I have a look at your source code?
20:17:29 <mmorrow> roconnor: but evalutation pushes things on the stack
20:17:39 <dolio> Anyhow, in the calculus of constructions, you have effectively a kind level, and then a single type above the kind level, and the hierarchy stops there.
20:17:47 <roconnor> in GHC case analysis pushes things onto a stack.
20:18:01 <roconnor> > fix tail
20:18:02 <mmorrow> roconnor: case is the only thing that causes evaluation
20:18:02 <lambdabot>   * Exception: stack overflow
20:18:14 <dolio> The wikipedia describes LF as "predicative" which might mean you have an infinite number of levels, but I'm not sure.
20:18:43 <dolio> If that's not what they mean by that, then I don't know what the difference between CoC and LF would be, exactly.
20:18:52 <mmorrow> roconnor: so if your entire result depends on more than just the next "tick", you're essentially in the same situation as you'd be in a strict language
20:19:01 <mmorrow> e.g. sum
20:19:25 <roconnor> mmorrow: entering a function is totally distinct from case analysis.
20:20:22 <roconnor> mmorrow: I'm not really understanding what point you are trying to make.
20:20:31 <mmorrow> roconnor: you need a result. so you evaluate, which entail jumping to functions, which begin executing their code, which may need to case on things, and jump to other functions, build closures, etc
20:20:49 <duaneb> Cale: sorry, mibbit died
20:20:55 <duaneb> and then I joined the wrong channel
20:20:56 <dolio> And I would show you my code, but I messed it all up fooling around with unification stuff, so it doesn't work very well anymore.
20:21:03 <mmorrow> the point i'm trying to make is that things need to be evaluated at some point
20:21:06 <Cale> duaneb: ah, it's #haskell-overflow
20:21:13 <halberd> ok
20:21:23 <halberd> well in general how did you approach it then?
20:21:33 <dolio> I can point you at an augustss blog post that shows how to do it, though.
20:21:43 <dolio> I went a little beyond and made it into a pure type system.
20:22:08 <roconnor> mmorrow: you don't jump to functions, you jump to thunks.
20:22:16 <halberd> ok
20:22:28 <roconnor> mmorrow: these thunks might be in the middle of a function body, and often are
20:22:32 <mmorrow> so my point is that the part of the heap that you *are* going to evaluate, because you need it, you do so strictly
20:22:42 <halberd> Cayenne a language with dependent types?
20:22:47 <roconnor> mmorrow: and the body is only executed upto revealing the next constructor before execution is suspended.
20:23:01 <mmorrow> but you need *all of it*
20:23:19 <mmorrow> say i do "foldr (+) 0 [0..100000000000] == 4"
20:23:22 <roconnor> mmorrow: what does any of what you are saying have to do with tail calls?
20:23:25 <dolio> http://augustss.blogspot.com/2007/10/simpler-easier-in-recent-paper-simply.html there we go.
20:24:11 <cads> hey I want to infer haskell types from clojure code, can I do this for limited but useful cases?
20:25:27 <halberd> thanks dolio
20:25:47 <mmorrow> int sum(int x, int *xs, int i, int n){ if(i < n){return xs[i] + sum(x,xs,i+1,n);} return x;}
20:25:58 <mmorrow> imagine running that in C
20:26:23 <mmorrow> that's exactly what you're doing when you do "foldr (+) 0 [...]" in haskell"
20:27:10 <mmorrow> because the single Int result isn't complete until you hit the end of the list, /then return back through all the stack frames you've pushed onto the stack/
20:27:45 <mmorrow> (so i'm just talking about when the entire result depends on traversing the entire structure here)
20:28:12 <roconnor> In C, calling sum pushes a stack frame
20:28:22 <roconnor> in Haskell calling (+) pushes the stack frame.
20:28:40 <mmorrow> so does haskell when it comes time to actually evaluate "foldr (+) 0 [..]"
20:28:50 <mmorrow> but you need the result of (+)
20:28:55 <mmorrow> not just the thunk
20:29:12 <mmorrow> so you need to evaluate (+) and both operands
20:29:17 <roconnor> (+) is a effectively doing case analysis, even though it is a prim op
20:29:32 <roconnor> and case analysis pushes stack frames in GHC
20:29:36 <roconnor> not function calls.
20:29:50 <mmorrow> 1 + (2 + (3 + (4 + ( ............... (10000000000000 + 0
20:30:05 <mmorrow> evaluate "1"...done
20:30:11 <mmorrow> evalutate the rhs
20:30:22 <mmorrow> goto => evaluate 2...done
20:30:28 <mmorrow> evaluate the rhs
20:30:30 <mmorrow> ....
20:30:40 <roconnor> mmorrow: I still don't get what you are disagreeing about.
20:31:12 <mmorrow> i'm saying that you can use either the heap or the stack in haskell just like you can in strict langs
20:31:40 <roconnor> no you don't
20:31:44 <roconnor> In C, calling sum pushes a stack frame
20:31:53 <roconnor> in Haskell calling (+) pushes the stack frame.
20:32:56 <mmorrow> i don't see your point
20:33:16 <mmorrow> :)
20:33:38 <roconnor> [23:26] <mmorrow> that's exactly what you're doing when you do "foldr (+) 0 [...]" in haskell"
20:33:44 <roconnor> I'm saying they are not exactly the same
20:33:59 <mmorrow> you're pushing 100000000 stack frames to eval the Int!
20:34:17 <mmorrow> just like you're pushing 100000000 stack frames to eval sum to completion
20:34:49 <mmorrow> (for that particular `sum')
20:34:56 <roconnor> mmorrow: firstly I don't think the number of stack frames is the same.  I think they will probably differ by one.  Secondly, even if the number of stack frames is the same, it is entirely coincidental.
20:35:14 <mmorrow> heh
20:35:19 <roconnor> I stand by my claim that the notion of tail-call make no sense in haskell.
20:35:45 <Baughn> Makes perfect sense for strict evaluation, doesn't it?
20:35:54 <Baughn> It's just a bit rare to run into that
20:36:56 <roconnor> the purpose of tail-call optimization is to clear the stack before exiting a function at a tail call.
20:37:23 <roconnor> but since entering a function in haskell doesn't allocate stack space, the whole idea of clearing it before a tail call makes no sense.
20:37:43 <Baughn> Evaluating a thunk does allocate stack space, though
20:37:51 <roconnor> yes
20:38:10 <Baughn> And when you have to evaluate multiple thunks at once, you can do tail-call optimization
20:38:23 <mmorrow> my claim is that the considerations change, but laziness doesn't save you from blowing your stack in the situation where you go to evaluate some massive thunk you've built, because if you need to eval /all/ of that thing to get any result at all, it's very similar to strict eval
20:38:40 <dolio> Stack space is needed to evaluate subexpressions. Tail-call optimization is the realization that in "return g(...)", g(...) is not a subexpression of anything. :)
20:38:47 <roconnor> mmorrow: I don't contest that.
20:38:54 <mmorrow> that's all i'm saying :)
20:39:07 <roconnor> I never said you couldn't blow a stack.
20:39:36 <dolio> But in haskell, function application doesn't correspond to evaluating subexpressions anyway. :)
20:40:15 <roconnor> Baughn: plz explain your multiple thunk thing
20:40:32 <roconnor> Baughn: cause it makes no sense to me.
20:41:17 <Baughn> roconnor: Um. Say, 1+(2+3), where the runtime doesn't hit any constructors while evaluating the first + before evaluating both parameters
20:41:25 <mmorrow> dolio: yeah, it's like inverted strict evaluation (or something) ((haz now, pay later (if you actually try to)))
20:42:27 <roconnor> Baughn: okay, where does the tail call come in?
20:43:06 <Baughn> roconnor: In realizing that, to sum a large chain of numbers, you can live with constant stack space
20:45:27 <roconnor> How do you realize that?
20:51:34 <Lemmih> Draconx|Laptop: Please return to MC3018.
20:53:18 <mmorrow> ok, so i think i've figure out how to say what i'm thinking.. i think saying that "tailcalls don't make sense in haskell" is misleading, because it implies that the eval model is such that it's even be a consideration (i.e. every function returns to caller, must optimize away tailcalls), *but* the bad results you can get if you try to do something in a non-tailcall-optimized language with recursion are still possible in haskell, under ce
20:53:18 <mmorrow> rtain conditions (which are avoidable)
20:56:03 <roconnor> I claim these bad results are only superficially similar, and in fact the cause behinds these similar bad results are totally different.
20:56:35 <mmorrow> but they're just the other side of the same coin
20:56:47 <dolio> Yes, but the way you avoid them isn't solely by using tail calls, it's by forcing things earlier than absolutely necessary.
20:57:18 <roconnor> I think they are totally different coins
20:57:31 <mmorrow> dolio: exactly, or by turning your recursion inside-out
20:58:01 <dolio> Of course, sometimes you need to rewrite things to be more tail callish. But that's not sufficient.
20:59:04 <mmorrow> > let foo x [] = x; foo x (y:xs) = let !z = foo x xs in y + z in foo 0 [0..1000000000] {- bad -}
20:59:06 <lambdabot>   * Exception: stack overflow
20:59:41 <mmorrow> > let foo x [] = x; foo x (y:xs) = let !z = x + y in foo z xs in foo 0 [0..1000000000]
20:59:56 <lambdabot>   thread killed
21:00:34 <mmorrow> dolio: yessss, that's really exactly what i'm trying to say
21:01:05 <mmorrow> i just don't know how exactly to phrase my thoughts, because they're not really precise
21:02:04 <vixey> mmorrow interpretive dance
21:02:35 <Elly> an interpretive dance in six lambdas
21:04:36 <vixey> mmorrow have you read my blog posts about TCO in haskell :D
21:04:46 <vixey> they're controversal according to 'reddit'
21:04:48 <mmorrow> no, link?
21:04:50 <mmorrow> heh
21:05:21 <Elly> vixey: you're just a controversial person
21:05:31 <dolio> Well, if it's on reddit it must be true.
21:06:18 <mmorrow> i thought that was the internet
21:07:32 <jekor> Hey guys. How would I go about applying a function to arguments contained in a list? I presume that I need to use Template Haskell, but I'm not sure how. I'd like to be able to say "alright, apply this function to this list of arguments, but if the number of arguments don't match the size of the list, return Nothing".
21:08:22 <jmcarthur> jekor: so you are wanting the first element to be the first argument, the second element to be the second argument, etc.?
21:08:30 <vixey> jekor which function?
21:08:37 <jekor> jmcarthur: Yes.
21:08:55 <jekor> vixey: Depends. Usually data constructors.
21:09:05 <jekor> It's to try and cut down on some boilerplate for working with SQL.
21:09:06 <vixey> jekor so a whole bunch of different functions, with different types
21:09:08 <vixey> ?
21:09:32 <jekor> vixey: I was thinking along the lines of: fromValues someFunc 5 someList
21:09:41 <vixey> ?
21:09:51 <mmorrow> vixey: i can't find it, is your code blog the right place to look?
21:10:06 <vixey> mmorrow: I just realized my post is irrelevant nonsense :/
21:10:12 <vixey> probably best to avoid it
21:10:12 <mmorrow> :(
21:10:17 <Baughn> > foldr ($) (printf "%d %d") [1,2] :: String
21:10:18 <lambdabot>       No instance for (Num (String -> String))
21:10:18 <lambdabot>        arising from the litera...
21:10:35 <Baughn> ah.. no, not quite right. How was it...
21:10:46 <jekor> Baughn: I knew I should have looked at the example for printf more closely...
21:11:08 * vixey says to jekor: Are you talking about a bunch of different functions with _different types_ or just one type?
21:11:10 <Baughn> jekor: Just so you know, this is something you almost never actually want.
21:11:48 <Baughn> jekor: The printf hack is so it can use a format string; in general it's better to use combinators
21:11:54 <jekor> Hmm...
21:12:03 <jekor> Any pointers on how to go about doing that?
21:12:13 * vixey says to jekor: ok suit yourself
21:12:18 <jekor> vixey: :P
21:12:23 <Baughn> jekor: Start by looking at how parsec works, I guess. That's nice and practical. :)
21:12:26 <vixey> I'm just not gonna let it bother me
21:12:50 <vixey> you'd probably not understand what I said if I did answer your q anyway
21:13:09 <jekor> vixey: I'm confused by what you're asking.
21:13:11 <vixey> increasingly seems to happen where I tell someone something and they just go "what"
21:13:23 <vixey> ooh I wonder if telling me that instead of ignoring me would have been quicker progres
21:13:31 <jekor> vixey: The idea was to generate a bunch of functions with different types at compile time, yes.
21:13:43 <vixey> sounds bad but I'm not gonna stop you
21:13:43 <jekor> vixey: Not if I wanted to get information from Baughn first.
21:15:23 <Baughn> jekor: Anyway, what you're asking is a staple of dynamic languages, which haskell is not
21:16:03 <Baughn> jekor: There are no doubt other ways to do what you'd be using it /for/, but it's hard to suggest at this level. You're saying "how do I drive across the atlantic", when you should just be asking "how do I get to europe in the fastest way"
21:16:17 <jekor> Baughn: Aye. Ideally I'd be able to use something like MetaHDBC, but it doesn't seem to compile with the latest HDBC.
21:16:59 <Baughn> jekor: Oh, HDBC? Yeah, queries are kind of akin to printf format strings..
21:17:14 <Baughn> jekor: You /could/ do the same trick with those, but it'd probably be better to invent a combinator language instead
21:18:14 <jekor> Wouldn't I have just reimplemented HaskellDB by that point? What am I missing here?
21:19:24 <roconnor> mmorrow: the fact that your good version of foo works has nothing to do with foo being in a tail call position.
21:19:31 <Baughn> jekor: Nothiing much. Yes, that's exactly what you'd be doing. :P
21:19:34 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..10000000]
21:19:43 <jekor> Baughn: OK. Just checking. Thanks for the tips ;)
21:19:48 <roconnor> observe, no tail call, yet no stack overflow
21:19:50 <lambdabot>   thread killed
21:19:55 <Baughn> jekor: I'm telling you how it /should/ work. Nobody says the system is perfect. :/
21:20:17 <Baughn> jekor: As it is, well, you'll kind of have to learn to love toSql
21:20:19 <jekor> Gotcha. I'd love to get there at some point.
21:20:32 <mmorrow> roconnor: the reason that the bad one doesn't is because it's not
21:20:32 <roconnor> I did @let swap x = let (a,b) = x in (b,a) in a pm with lambdabot
21:20:55 <roconnor> mmorrow: but my codes doesn't have foo in the tail position either.
21:21:15 <vixey> mmorrow: my point was TCO doesn't exist in Haskell btw
21:21:24 <dolio> @type swap
21:21:44 <roconnor>  swap x = let (a,b) = x in (b,a)
21:21:52 <mmorrow> wut, ok we're not even talking about the same thing when we say "tail recursion"
21:22:00 <lambdabot> thread killed
21:22:12 <roconnor> mmorrow: was that directed at me?
21:22:15 <mmorrow> yes
21:22:45 <roconnor> what the heck are do you think tail call means?
21:22:50 <roconnor> s/are//
21:23:12 * vixey says TCO and means http://schemers.org/Documents/Standards/R5RS/HTML/r5rs-Z-H-6.html#%_idx_80
21:23:14 <vixey> not that anyone ased me
21:23:19 <mmorrow> in `bad', the ! makes it so that eval will have to return to that point, then proceed to contruct the resulting closure of which the `z' in !z will be a part
21:23:26 <vixey> but yeah -- there's a formal def, it's completely syntactic
21:23:32 <jekor> One difference I see with printf is that it generates a function that accepts n arguments. But I was hoping to accept a function that accepts n arguments and then apply it to a list. The list extraction seems to be the key. And I won't have the list until runtime.
21:23:41 <mmorrow> in your and my `good', it doesn't
21:23:52 <jekor> Nevermind, I think I know how I can do it.
21:23:58 <Baughn> @type printf
21:24:01 <Baughn> @type foldr
21:24:01 <lambdabot> forall r. (PrintfType r) => String -> r
21:24:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:24:09 <mmorrow> once you construct the result closure, you never have to return to that function again
21:24:11 <roconnor> > let foo x [] = x; foo x (y:xs) = let !z = x + y in 2*(foo z xs) in foo 0 [0..10000000]
21:24:16 <lambdabot>   * Exception: stack overflow
21:24:19 <jekor> Baughn: Ah...the foldr. Thank you.
21:24:20 <roconnor> that stack overflows
21:24:23 <roconnor> and it has a !z
21:24:53 <Baughn> > (foldr ($) (printf "%d %d %s") [1,2]) "foo" :: String
21:24:55 <lambdabot>       No instance for (Num (([Char] -> String) -> [Char] -> String))
21:24:55 <lambdabot>        a...
21:25:00 * Baughn sighs
21:25:30 <vixey> mmorrow: what is it exactly you're figuring out
21:25:34 <vixey> or discussing or whatever
21:25:40 <vixey> something to do with 'TCO' but what?
21:25:46 <vixey> or maybe it's to do with stack overflows.. ?
21:26:02 <roconnor> mmorrow: I agree you need the !z for efficency; however the !z has nothing to do with a tail call
21:26:10 <mmorrow> roconnor: that's no different in essence than 'bad'
21:26:19 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..10000000]
21:26:25 <roconnor> no tail call, yet it is good.
21:26:35 <lambdabot>   thread killed
21:26:36 <mmorrow> roconnor: i'm was only using the !z there to order evaluation
21:26:56 <roconnor> why are you describing your "good" foo as having a tail call
21:27:01 <mmorrow> a closure is built for this ===> "swap (foo z xs)"
21:27:35 <mmorrow> ok ok, i have to take a break
21:27:40 <roconnor> @undefine
21:27:41 <vixey> :(
21:27:53 <roconnor> @let swap (a,b) = (b,a)
21:27:55 <mmorrow> vixey: i'm not even certain anymore
21:27:57 <lambdabot>  Defined.
21:28:00 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap (foo z xs) in foo 0 [0..10000000]
21:28:06 <vixey> ok
21:28:06 <lambdabot>   * Exception: stack overflow
21:28:12 <roconnor> now it does overflow!
21:28:43 <roconnor> bah!
21:28:46 * roconnor gives up
21:28:50 <mmorrow> @let swap' ~(a,b) = (b,a)
21:28:52 <lambdabot>  Defined.
21:28:59 <mmorrow> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..10000000]
21:29:15 <lambdabot>   thread killed
21:29:31 <roconnor> see, it has everything to do with where case analysis are, and nothing to do with whether foo is making a tail call.
21:30:08 <dolio> It has to do with tail calls involving strict functions.
21:30:21 <mmorrow> i think we need to stop calling it "tailcall" because i'm not even talking about that really
21:30:45 <roconnor> mmorrow: Well that's pretty much what I said at the beginning.
21:30:46 <jmcarthur> @quote endofunctor
21:30:53 <mmorrow> i'm talking about exactly what you just said.... it has to do with the path of execution during evaluation of the graph of thunks you've created
21:31:00 <jmcarthur> uh...
21:31:00 <roconnor> the notion of "tail-call" isn't applicable to haskell.
21:31:07 <vixey> roconnor I agree!
21:31:14 <jmcarthur> @quote monads
21:31:19 <mmorrow> and the position of things determines that path
21:31:23 <mmorrow> (obviously)
21:31:24 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
21:31:24 <lambdabot> samc says: monads are hard. let's go shopping!
21:31:26 <vixey> I'm so happy now there's 2 people in the world that think that :p
21:31:32 <jmcarthur> finally...
21:33:06 <roconnor> so instead of telling people, oh to sum lists you should use strictness and a tail call, we instead should be saying, you need to use strictness and arrange things in the right order.
21:33:40 <roconnor> because, as you can see from the swap' example, it foo doesn't even have to be put into tail-call position to fix the stack-overflow.
21:33:41 <dolio> A tail call is the right order.
21:34:00 <mmorrow> which i think is the flip side of the coin of what you consider when writing strict code that uses tail calls
21:34:19 <mmorrow> yes
21:34:32 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..10000000]
21:34:48 <lambdabot>   thread killed
21:34:48 <roconnor> dolio: the above doesn't have a tail call, and there is no stack problem.
21:35:08 <roconnor> dolio: so you are wrong when you say that tail call is the right order.
21:35:17 <mmorrow> tail calls are applicable, but in a reverse, inverted, backwards, and opposite in time, space, and direction!
21:35:28 <roconnor> ugh!
21:35:34 <dolio> No, it is the right order. Just not the only right order. :)
21:37:18 <dolio> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000000]
21:37:27 <lambdabot>   (0,500000500000)
21:40:01 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in swap' (foo z xs) in foo 0 [0..1000001]
21:40:30 <lambdabot>   thread killed
21:40:55 <roconnor> ;(
21:40:59 <dolio> I think we might be destroying the machine lambdabot's on.
21:41:28 <mmorrow> @pl (\x -> x x) (\x -> x x)
21:41:31 <lambdabot> ap id id (ap id id)
21:41:32 <lambdabot> optimization suspended, use @pl-resume to continue.
21:41:39 <mmorrow> fingers slipped
21:42:17 <roconnor> <dolio> No, it is the right order. Just not the only right order. :)
21:42:31 <roconnor> Do you seriously think that is a defense of using the term tail call?
21:42:35 <roconnor> or are you just joking?
21:43:27 <mmorrow> @bot
21:43:27 <lunabot>  :)
21:45:14 <dolio> If you're telling a newbie how to write 'sum', telling them to use a tail call and strictness on an accumulator tells them the correct way to implement it.
21:46:06 <Baughn> > foldl (printf "%d %d") [] [1,2] :: String
21:46:17 <lambdabot>   "* Exception: Printf.printf: bad argument
21:46:22 <dolio> In general, the rule is (approximately) tail calls possibly guarded with non-strict functions.
21:46:53 <dolio> If you're inclined to think in terms of tail and non-tail calls.
21:46:55 <Baughn> > foldl1 (printf "%d %d") [1,2] :: String
21:46:56 <lambdabot>       No instance for (Num String)
21:46:56 <lambdabot>        arising from the literal `1' at <in...
21:47:00 <copumpkin> moo
21:47:15 <copumpkin> I got a legit copy of the ARMv7 documents!
21:47:19 <Baughn> > foldl1 (printf "%s %s") ["1","2"] :: String
21:47:20 <lambdabot>   "1 2"
21:47:37 <Baughn> ..oh, that's just great
21:49:15 <david_> Hm. I'm a bit lost here. I've done a small (hello world-style) web app with fastcgi and everything works fine there. However, how can I access things such as GET and POST variables?
21:49:21 <dolio> Well, I see that ghci-haskelline didn't improve my ^C handling any.
21:52:44 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in id (foo z xs) in foo 0 [0..1000001]
21:52:46 <lambdabot>   (500001500001,0)
21:53:00 <copumpkin> it's kind of awkward when someone says "especially for a woman" on -cafe
21:53:01 <roconnor> dolio: id is a strict function, and it works fine in place of swap'
21:53:10 <roconnor> > let foo x [] = (x,0); foo x (y:xs) = let !z = x + y in id (foo z xs) in foo 0 [0..100000000]
21:53:25 <lambdabot>   thread killed
21:53:35 <dolio> Yes, but id is one of a few special cases.
21:53:36 <copumpkin> > fst (5, id 6)
21:53:38 <lambdabot>   5
21:53:41 <copumpkin> > fst (5, id undefined)
21:53:43 <lambdabot>   5
21:53:52 <MyCatVerbs> copumpkin: who what where? Drama?
21:54:19 <roconnor> dolio: I think your rule is pretty misleading.
21:54:24 <jdrake> Is anyone aware of this 'haskell to objective c binding'  ( http://code.google.com/p/hoc/ )
21:55:11 <copumpkin> jdrake: I think it's a little bitrotted
21:55:34 <dolio> I don't think it's necessarily a good way to teach neophytes, but if someone's coming from scheme or something, it explains the differences.
21:55:35 <jdrake> A lot of stuff seems to have been done
21:56:05 <jdrake> I am doing commercial development with cocoa and noticing certain things would lend themselves to haskell :p
21:56:33 <roconnor> dolio: here's how you explain it to people coming from scheme:
21:56:52 <roconnor> The whole notion of tail-call makes no sense for haskell because "entering a function" does not push anything onto a stack.
21:57:08 <copumpkin> isn't it just pushing the notion to thunk evaluation instead of function call though?
21:57:10 <roconnor> well, something like that.
21:57:23 <dolio> Yes, and I already wrote out an explanation like that earlier.
21:57:35 <copumpkin> ah
21:58:16 <roconnor> copumpkin: I haven't really understood what a tail-call for thunk evaluation would be, but I think that is what mmorrow was trying to get at.
21:58:18 <vixey> I don't think it's schemers getting confused though :)
21:58:32 <dolio> OCamlers, then.
21:58:56 <roconnor> copumpkin: but the point is that the form of a recursive function has little to do with it's stack properties.
21:59:15 <roconnor> it is all about how the case analysis statements are arranged.
21:59:29 <BMeph> copumpkin: If the original topic concerns peeing with no hands, I guess that could apply. ;p
21:59:41 <roconnor> which is why, id wasn't a problem in my code.  Because id does no case analysis.
22:01:47 <dolio> Yes, but it's only one of two (I believe) strict functions that don't.
22:01:55 <dolio> Technically 3 in Haskell.
22:02:23 <copumpkin> how is id strict?
22:02:31 <dolio> id _|_ = _|_
22:03:56 <dolio> Although I suppose it's hard to imagine it being a problem anyway.
22:04:35 <dolio> Does doing something like (define foo () (id (foo))) blow the stack in scheme?
22:05:11 <roconnor> (define foo () (id (foo ()))) ?
22:05:14 <dolio> I suppose you'd have to ensure that it doesn't just eliminate id.
22:05:17 <copumpkin> oh, is that how strict is defined?
22:05:28 <copumpkin> I guess that makes sense
22:05:52 <dolio> (foo) is how you call a function of no arguments in scheme, isn't it?
22:05:56 <vixey> dolio it crashes sisc
22:05:57 <dolio> It's been a while.
22:06:14 <vixey> which is fine, I expect that (id (foo)) to explode
22:07:50 <dolio> Technically seq doesn't do case analysis, either, it does magic. :)
22:08:45 <roconnor> I consider seq case analysis since I don't ever recall applying it to functions.
22:08:58 <roconnor> If we had our Seq class, it would actually be case analysis I think.
22:09:47 <dolio> I'm not sure if I have or not. I wonder if one can construct a stack overflow on a function...
22:10:31 <dolio> Aside from, like, 'let y f = f (y f) in y id :: a -> a'.
22:10:41 <dolio> Which is clearly cheating.
22:10:42 <MyCatVerbs> dolio: (foo) is indeed how you call a zero-arity function in Scheme.
22:11:14 <copumpkin> MyCatVerbs: I meant Bulat's response to Belka
22:11:57 <dolio> Interestingly enough, I went back and read some of the old reports with the Seq class, and despite it being in a class, it still worked on functions, and was magic.
22:12:04 <dolio> You weren't allowed to define instances yourself.
22:12:23 <MyCatVerbs> copumpkin: thanks. I haven't been up to date on -cafe for several months now. >>
22:12:52 <MyCatVerbs> To the tune of... four thousand unread posts? By Thor's left nut, that is a lot of email. x_x
22:13:21 <roconnor> dolio: oh?
22:13:22 <copumpkin> :P
22:13:36 <roconnor> dolio: interesting
22:13:44 <roconnor> and hard to believe.
22:14:09 <roconnor> I thought the whole complaint about removing the Seq class was about that seq would apply to functions.
22:14:34 <dolio> Maybe that's why polymorphic seq got the pass, since it wasn't adding new eta-breaking to the language, just moving the eta-breaking out of a class. :)
22:16:35 <david_> hmm.. Isn't there a built in function for splitting strings with given delimiter?
22:16:57 <vixey> I don't think so
22:17:31 <dibblego> Data.List.Split
22:18:06 <dolio> From the 1.4 report: "Class Eval is a special class for which no instances may be explicitly defined. An Eval instance is implicitly derived for every datatype. Functions as well as all other built-in types are in Eval. (As a consequence, _|_ is not the same as \x -> _|_ since seq can be used to distinguish them.)
22:18:29 <dolio> I didn't go all the way back to 1.0, though, so maybe there was a time when it wasn't that way.
22:18:45 <vixey> it's stupid making it a class if it's defined for everything
22:19:12 <dolio> Well, Typeable is, in principle, defined for everything.
22:19:26 <dolio> Everything monomorphic, at least.
22:19:30 <david_> hmm.. Isn't there a built in function for splitting strings with given delimiter?
22:19:34 <david_> oops
22:20:08 <david_> it complains on "Couldn't fine module Data.List.Split".. :(
22:20:11 <jmcarthur> @src words
22:20:11 <lambdabot> words s = case dropWhile isSpace s of
22:20:11 <lambdabot>     "" -> []
22:20:11 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
22:20:25 <jmcarthur> david_: it's a package on hackage
22:20:32 <david_> ah okay
22:21:08 <roconnor> dolio: wow
22:22:02 <dolio> Yeah, I was surprised, too.
22:22:41 <roconnor> interseting
22:22:53 <roconnor> > let foo x [] = fix (In . ((,)())); foo x (y:xs) = let !z = x + y in (\x -> let  In (_,y) = x in y) (foo z xs) in fst . out $ foo 0 [0..1000000]
22:22:55 <lambdabot>   * Exception: stack overflow
22:23:09 <dolio> Evidently 1.4 was not perfect. :)
22:23:09 <roconnor> I wanted to show this as an example of a non-id strict function that doesn't overflow
22:23:15 <roconnor> but it does overflow
22:23:35 <roconnor> > let foo x [] = fix (In . ((,)())); foo x (y:xs) = let !z = x + y in (\x -> let  In ~(_,y) = x in y) (foo z xs) in fst . out $ foo 0 [0..1000000]
22:23:37 <lambdabot>   * Exception: stack overflow
22:30:46 <roconnor> I guess my let expression doesn't delay case analysis long enough.
22:35:36 <Gracenotes> let in :(
22:35:53 <bombshelter13_> Can a value ever be extracted and coerced into a value of it's original type after being put into a type like 'data F = forall a. Show a => F a'?
22:36:15 <bombshelter13_> or can I only extract it and retype it as another type with identical constraints?
22:37:02 <roconnor> bombshelter13_: I *think* if you know the original type you can safely unsafeCoerce it back.
22:37:07 <Gracenotes> ouch
22:37:58 <bombshelter13_> hm... *looks up unsafe coerce*
22:38:07 <Gracenotes> bombshelter13_: probably not a good idea, though.
22:38:18 <roconnor> bombshelter13_: you have to be sure to drop the constructor containing it.
22:38:27 <Gracenotes> are you trying to have a heterogeneous list?
22:38:39 <roconnor> of course
22:38:54 <bombshelter13_> Yeah, pretty much.
22:39:23 <roconnor> > let foo x [] = repeat 0; foo x (y:xs) = let !z = x + y in 1 : drop 1 (foo z xs) in foo 0 [0..100000000] -- does not stack overflow
22:39:38 <lambdabot>   thread killed
22:39:45 <roconnor> > let foo x [] = repeat 0; foo x (y:xs) = let !z = x + y in 1 : drop 2 (foo z xs) in foo 0 [0..100000000] -- does stack overflow
22:39:49 <lambdabot>   [1* Exception: stack overflow
22:40:02 <BMeph> roconnor: Liar. ;)
22:40:12 <roconnor> BMeph: how so?
22:40:32 <copumpkin> a smaller value might actually not get killed in the first case
22:40:54 <roconnor> copumpkin:smaller value?
22:41:13 <copumpkin> > let foo x [] = repeat 0; foo x (y:xs) = let !z = x + y in 1 : drop 1 (foo z xs) in foo 0 [0..1000000] -- does not stack overflow
22:41:22 <lambdabot>   [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:41:29 <copumpkin> > let foo x [] = repeat 0; foo x (y:xs) = let !z = x + y in 1 : drop 2 (foo z xs) in foo 0 [0..1000000] -- does stack overflow
22:41:35 <lambdabot>   [1* Exception: stack overflow
22:41:43 <roconnor> when something does or does not stack overflow is unrelated to the tail call position.
22:41:44 <copumpkin> just that :)
22:41:59 <roconnor> copumpkin: um, where is my lie?
22:42:05 <copumpkin> I never said you lied
22:42:15 <roconnor> oh oops
22:42:29 <copumpkin> I just said that in your first case, it got killed, so it wasn't very clear that it wasn't stack overflowing (with a different error)
22:42:33 <copumpkin> *meant :)
22:42:37 <Gracenotes> > error "stack overflow"
22:42:38 <roconnor> good
22:42:39 <lambdabot>   * Exception: stack overflow
22:42:43 <copumpkin> zomg
22:42:45 <roconnor> :D
22:42:47 <BMeph> I said he lied., though. :)
22:42:50 <copumpkin> mmorrow: had a good one though
22:43:12 <copumpkin> > error "stack overflsegmentation fault"
22:43:14 <lambdabot>   * Exception: stack overflsegmentation fault
22:43:21 <Gracenotes> overflegmentation
22:43:22 <copumpkin> something like that :P
22:43:27 <roconnor> talking about tail calls is such a bad way of understanding stack overflows.
22:44:22 <roconnor> and how to fix them
22:44:28 <Gracenotes> in a lazy language, it's to do more with how man levels of thunk-i-ness there are
22:44:33 <Gracenotes> as far as I understand
22:44:37 <Gracenotes> y
22:44:51 <roconnor> ya, talking about thunks is a fairly good way.
22:45:18 <povman> Hi all.
22:45:25 <roconnor> I didn't even know what caused stack allocations in GHC until a few weeks ago.
22:45:30 <roconnor> I thought it was just prim ops
22:47:08 <bombshelter13_> copumpkin: that's an awesome error, how'd you cause it?
22:47:21 <copumpkin> bombshelter13_: I didn't :P it was just humor on mmorrow's part :)
22:48:23 <bombshelter13_> damn, i'd have enjoyed seeing code that could cause that.
22:48:35 <roconnor> error ("stack overfl"++unsafeCoerce 7)
22:48:47 <roconnor> hmm
22:48:51 <roconnor> error ("stack overfl"++unsafeCoerce id)
22:48:54 <bombshelter13_> heh, without faking part of the string
22:48:55 <roconnor> better
22:49:08 <copumpkin> I don't think that would crash would it?
22:49:37 <copumpkin> error (unsafeCoerce 5 "stack overfl") maybe?
22:50:10 <Gracenotes> if you have a Num (a -> b) instance, not so bad :)
22:50:28 <copumpkin> why not?
22:50:42 <Gracenotes> but, actually, roconnor's code just causes unsafeCoerce id to be ""
22:50:45 <Gracenotes> it seems
22:50:45 <mmorrow> > help
22:50:50 <lambdabot>   <<loop>***Excep
22:50:51 <lambdabot>  Segmentaion fault
22:50:55 <copumpkin> :P
22:50:57 <Gracenotes> maybe it's converted it to the nullary constructor []?
22:51:01 <mmorrow> heh
22:51:16 <Gracenotes> mmorrow: I know text when I see it!
22:51:21 <Gracenotes> o_O
22:59:36 <povman> How likely are we to use template haskell when we discover something that (gasp) haskell can't do
22:59:37 <povman> ?
22:59:53 <roconnor> povman: 30% chance
23:00:44 <MyCatVerbs> povman: pretty likely. If you watch Haskell-cafe, you see places where people have used TH to fake optimisations in order to benchmark potential gains.
23:01:29 <MyCatVerbs> povman: e.g. dons hacking together a loop unroller in TH in order to estimate how profitable it might be to add loop unrolling to GHC.
23:01:40 <povman> hey cool
23:02:02 <povman> Hm. Could you replace GHC with a template haskell expander?
23:02:35 <MyCatVerbs> Probably, in as much as TH is Turing-complete after all.
23:02:58 <povman> I am obviously procrastinating.
23:03:01 <MyCatVerbs> You'd just need to tack on a phase at the end that ran the output through Hugs or something in order to dump the output binary.
23:03:37 <MyCatVerbs> That'd be more "write a Haskell compiler in Template Haskell" than anything sensible though.
23:19:26 <MyCatVerbs> Coinductive functions are just those that tail call on data constructors, right?
23:26:32 <psygnisfive> http://news.ycombinator.com/item?id=612999
23:26:40 <psygnisfive> guys should totally read the series e.e
23:30:03 <centrinia> Is it possible to have a chain of metaprograms that has no minimum length?
23:30:43 <povman> centrinia: what's a 'chain of metaprograms'?
23:31:37 <centrinia> You start with some program, and a subsequent metaprogram outputs the previous program's source code.
23:32:26 <copumpkin> in scripting languages, the trivial one should work
23:32:39 <Nafai> Something like a higher-order quine?
23:32:41 <copumpkin> or how do you mean?
23:32:54 <copumpkin> I remember seeing a circular quine once, with 4 steps I think
23:33:07 <copumpkin> maybe in an IOCCC submission
23:33:10 <centrinia> Wait, will all chains contain a quine?
23:34:01 <povman> centrinia: That sounds false.
23:34:23 <p_l> copumpkin: the one with 4 ASCII arts?
23:34:32 <copumpkin> that sounds right
23:34:38 <copumpkin> I think they were manga style or something?
23:34:43 <p_l> Saito -> Aku -> Soku -> Zan -> Saito
23:34:56 <copumpkin> what's that from?
23:35:01 <copumpkin> it was a cool entry, I thought :P
23:35:21 <p_l> the first image was from a manga (but the character was based on real guy), the other three were the motto of his unit during Meiji Revolution
23:35:28 <copumpkin> ah
23:35:59 <p_l> "Aku Soku Zan" roughly translates as "Kill evil swiftly"
23:37:26 <centrinia> Why isn't it possible for a chain of metaprograms to not contain a cycle?
23:37:51 <povman> centrinia: Why do they have to contain a cycle?
23:37:53 <p_l> copumpkin: the guy was "Saitō Hajime"
23:38:04 <centrinia> povman, I don't know.
23:38:16 <povman> centrinia: I could spend my whole life writing programs that printed the previous program and never have a loop
23:38:34 <centrinia> Do they always contain a cycle?
23:38:38 <povman> They'd keep getting bigger though.
23:38:49 <povman> centrinia: Is this a homework question?
23:39:01 <centrinia> I don't have homework.
23:39:20 <copumpkin> o.O
23:39:36 <centrinia> I only have workwork. ;)
23:39:50 <povman> centrinia: Why don't you write a program, then write another that prints it, and so on
23:39:52 <MyCatVerbs> It *is* possible for a chain of metaprograms to not contain a cycle. povman gave a fairly easy way to construct one: a modified quine that makes itself a little longer on each iteration.
23:40:27 <centrinia> povman, I guess I was too drunk to have thought about that. :p
23:40:30 <MyCatVerbs> No program in that chain will ever be identical to any other program in that chain.
23:41:09 <povman> centrinia: Do you believe in Ballmer's peak?
23:41:11 <p_l> copumpkin: funny, wikipedia claims the motto was fictional, while from some other sources I recall it being "unofficial motto" of the whole Shinsengumi. No time to chase the tails :D
23:41:18 <copumpkin> :P
23:41:27 <copumpkin> it was rather unfamiliar japanese, so I looked it up
23:41:44 <centrinia> povman, No.
23:42:45 <povman> This website says I have (1) message. I wonder who it's from?
23:42:54 <MyCatVerbs> povman: it's my mum.
23:43:00 <MyCatVerbs> She emails everybody.
23:43:03 <copumpkin> :o
23:43:09 <MyCatVerbs> Mostly about nitrogen generators.
23:43:37 <MyCatVerbs> She's had it up to here with buying dozens of bottles of ammonia.
23:44:05 <povman> I actually have a spare one if she needs it. Is she trying to kill some fish?
23:44:37 <MyCatVerbs> No, harden titanium.
23:44:44 <MyCatVerbs> Just the outside.
23:47:37 <centrinia> Is liquid nitrogen soluble in liquid oxygen?
23:47:52 <lw0x15> lol
23:48:00 <bombshelter13_> if I had a function, mapfilter, where 'mapfilter f g l' returns an identical value to 'map f $ filter g l', but only iterates over the list once, instead of iterating over it once to filter and once to map the way 'map f $ filter g l' would, would it be any quicker, or is the difference optomized away? (assuming ghc)
23:48:51 <Lemmih> bombshelter13_: The difference is optimized away.
23:49:10 <bombshelter13_> handy to know
23:49:11 <Gracenotes> laziness takes care of that for you
23:49:21 <Gracenotes> laziness is responsible for lots of performance gains
23:49:32 <MyCatVerbs> Gracenotes: (!)
23:49:39 <Gracenotes> (?)
23:49:47 <bombshelter13_> ahh, i see how that would help now that you point it out :0
23:50:05 <MyCatVerbs> Gracenotes: laziness doesn't mean that the optimisation must happen, rather pure semantics mean that it's possible.
23:50:40 <Gracenotes> yes. but most of the time it's best to think about code as though laziness is predictable -- because most of the time it is :) in common use
23:50:47 <bombshelter13_> MyCatVerbs: er, while that might be true for certain particular optimizations it doesn't make gracenotes statement untrue
23:50:53 <Gracenotes> it can be subtle though... eh.
23:50:56 <sjanssen> MyCatVerbs: lazy evaluation actually does guarantee that
23:51:12 <sjanssen> MyCatVerbs: I think you mean "non-strict"
23:51:47 <Gracenotes> bombshelter13_: so even though the calculation is in memory, nothing happens (in theory) until the first element of the list is retrieved
23:52:10 <Gracenotes> it finds the first value for which the filter condition is true, and then maps it, and gives you that
23:52:15 <MyCatVerbs> sjanssen: what? Lazy evaluation does *not* guarantee that (map f . filter g) are merged into one pass!
23:52:18 <Gracenotes> and the same for the next element, and so on, until you reach the end of the list
23:52:26 <Gracenotes> again, in theory.
23:52:29 <Gracenotes> :)
23:52:44 <sjanssen> MyCatVerbs: it does
23:52:46 <povman> I have a feeling there's a GHC rewrite rule which handles that
23:52:55 <Twey> Yep
23:52:56 <Gracenotes> the entire list may be deforested away, after all, and yes, rewrite rules
23:52:57 <sjanssen> there is, but that's even more specific than one pass
23:53:10 <MyCatVerbs> sjanssen: no it doesn't. You get no guarantee whatsoever that you don't get an intermediate list consed up in between the filter and map.
23:53:31 <Cale> MyCatVerbs: But you do get a guarantee that the elements of that list are immediate garbage.
23:53:36 <bombshelter13_> yeah, I'm aware that that's the general behaviour I just for some reason figured that, once the value of the filter call was needed by map, the entire filter would be evaluated. but that doesn't make sense now that i think about it... after all, to map f on to the first element of the result of filtering l by g, you only really need to filter enough of l to get one element :)
23:54:01 <sjanssen> MyCatVerbs: there will be an intermediate cons cell between the map and filter, but only one will ever be in memory at a time
23:54:06 <Cale> MyCatVerbs: That is, at no point in time will any more than one element of that list be held.
23:54:20 <MyCatVerbs> Cale: yes. Hence the deforestation is possible. Not by any stretch of the imagination required, though.
23:54:40 <Cale> MyCatVerbs: But that's already much better than strict evaluation!
23:55:06 <MyCatVerbs> Cale: only asymptotically. ;)
23:55:07 <sjanssen> MyCatVerbs: deforestation is a step beyond achieving this in a single pass
23:55:20 <Cale> Sure, you can go that extra step and remove even the one cons cell.
23:57:16 <MyCatVerbs> sjanssen: right, yes. Serves me right for thinking like it was ML.
23:57:53 <jekor> Is there a way to force import of a function from a module when the function is not exported by the module?
23:58:00 <MyCatVerbs> No.
23:58:34 <jekor> *sigh* Another library to modify...
