00:00:10 <hatds> generalizing lists?
00:00:22 <adu> yes
00:00:36 <adu> that always seemed very odd to me
00:01:34 <adu> that arrays were used to rarely and has a short operator (!), and lists were used frequently, and have a long operator (!!)
00:01:45 <copumpki> I agree
00:01:51 <hatds> you use ! more with arrays
00:01:53 <copumpki> the name is odd though
00:02:05 <copumpki> (Int)Map could be an instance too, I guess
00:02:12 <adu> i don't mind the name so much as its length
00:02:30 <copumpki> IntMap might be more difficult
00:02:35 <copumpki> adu: I mean, Gettable
00:02:42 <adu> copumpki: :)
00:03:27 <ray> ix is the oddest typeclass name ever
00:03:36 <hatds> yea
00:03:46 <adu> ray: thats my favorite class!
00:05:09 <adu> why didn't they name it Index?
00:05:26 <Cale> It's been largely forgotten that it was only named after the number of its definition in an ancient numbering system.
00:05:50 <copumpki> seems like it could be a class with an associated type
00:05:51 <Cale> ;)
00:05:51 <ray> yeah, i always think of dune
00:05:54 <copumpki> for Key
00:06:05 <copumpki> in the case of lists, you'd have Nat
00:06:15 <copumpki> for arrays, you'd have a bunch of different Ixes
00:06:21 <copumpki> and for Map you could have the map key
00:06:47 <copumpki> a but like GMap I guess
00:07:13 <adu> what was another big Prelude issue... Set!
00:07:23 <hatds> ?
00:07:27 <copumpki> set! always bothered me in scheme
00:07:34 <Lemonator> this pretty-printing business is harder than I thought.
00:07:38 <adu> there was a big fiasco about the Set class
00:07:42 <adu> or type
00:07:44 <Lemonator> what's it going to take to have
00:07:47 <copumpki> I want RMonad as the default Monad type :P
00:07:52 <Lemonator> makePretty :: String -> String
00:07:53 <Lemonator> ?
00:08:05 <copumpki> Lemonator: what are you pretty printing?
00:08:09 <Lemonator> my own code.
00:08:13 <copumpki> haskell?
00:08:17 <Lemonator> yeah
00:08:22 <copumpki> parse it with haskell-src-exts, pretty print it using that?
00:08:29 <copumpki> not sure how good its pretty printer is though
00:08:40 <hatds> RMonad?
00:08:44 <hatds> reader?
00:08:46 <ray> i just want the default monad to be definable using join
00:08:48 <adu> or was it (Monad Set) that was impossible...
00:08:50 <ray> restricted monad
00:09:01 <Lemonator> It looks ugly to me, and I don't know how to manually give it good-looking indenting.
00:09:10 <hatds> what are useful restricted monad instances?
00:09:17 <copumpki> Set, for example
00:09:20 <ray> RMonad Set, i guess
00:09:49 <copumpki> it also comes with restricted functors
00:09:56 <ray> fancy
00:10:07 <copumpki> it would also allow us to make things like uvector into a (restricted) functor
00:10:15 <adu> (Monad Set) i think was blocked by a lack of (Ord a =>) in front of Monad?
00:10:26 <ray> i see it doesn't come with join as a method, though
00:10:28 <copumpki> adu: yup, RMonad compensates for that
00:10:32 <adu> oh ok
00:10:52 <copumpki> ray: the regular Monad doesn't either does it?
00:10:53 <copumpki> @src Monad
00:10:53 <lambdabot> class  Monad m  where
00:10:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:10:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:10:54 <lambdabot>     return      :: a -> m a
00:10:54 <lambdabot>     fail        :: String -> m a
00:11:00 <ray> nope
00:11:26 <ray> i wan tit
00:11:31 <ray> i want it
00:11:32 <hatds> it doesn't seem like the two classes can be unified though
00:11:34 <ray> no typos
00:11:36 <hatds> RMonad and Monad
00:11:55 <copumpki> hatds: no, but I don't see why you couldn't just remove Monad altogether?
00:12:02 <copumpki> and replace it with RMonad
00:12:17 <copumpki> same with Array, I guess
00:12:22 <hatds> but then you don't have polymorphic bind/return
00:12:25 <hatds> ?
00:12:45 <ski> @where RMonad
00:12:46 <lambdabot> I know nothing about rmonad.
00:12:52 <copumpki> http://hackage.haskell.org/packages/archive/rmonad/0.4.1/doc/html/Control-RMonad.html
00:13:05 <jn> can anyone explain to me why i seem unable to catch async exceptions?
00:13:31 <copumpki> jn: what would you do if you caught an "out of stack" exception?
00:13:39 <adu> ray: another reason I want HList-like abilities builtin is that if heterogeneous lists were also linked, then you could implement zipWith# with fst, and snd
00:13:49 <PetRat> I'm working through Typeclassopedia. Is this a proper implementation of Applicative for Maybe? http://www.mibbit.com/pb/pEDXaH
00:13:51 <Saizan> jn: are you using Control.Exception.catch?
00:14:16 <jn> Saizan: yes.. well, Control.Exception.try
00:14:24 <copumpki> hatds: I think you do with FlexibleInstances
00:14:30 <copumpki> unless I've misunderstood what you meant
00:14:45 <Beelsebob1> copumpki: perhaps go "oh, shit, I'd better free up some resources, then display a dialog to the user, because I'm writing a GUI app, not a CLI app"
00:14:49 <hatds> looks right to me, PetRat
00:15:01 <PetRat> It obeys the one applicative law he mentions.. since that law involves pure, by necessity things are constructed with Maybe.
00:15:06 <Saizan> jn: then the exception must be raised otuside of its scope
00:15:17 <copumpki> Beelsebob1: but in many instances you don't have enough control to free up some resources do you?
00:15:32 <ray> petrat: yeah, ((->) e) is the hard one
00:15:35 <Beelsebob1> copumpki: why not?
00:16:03 <Beelsebob1> copumpki: I would imagine 99% of stack overflows are caused by 1 enormous computation that couldn't quite fit... you let that stack unravel and catch it at the bottom
00:16:34 <ski> PetRat : i think so
00:16:40 <PetRat> Actually I screwed that up.. I was trying to say that in working on the applicative law, only the main case of <*> is exercised (the one in which both arguments are Just _)
00:16:50 <copumpki> yeah, but how does that happen? say I stack overflow from evaluating foldl1 (+) [1..1000000000] and catch the exception... what do I do to recover?
00:17:25 <ski>   pure f <*> ia = fmap f ia
00:17:46 <jn> Saizan: i'm likely doing something stupid. can you take a look? http://paste.lisp.org/display/80482
00:17:47 <ski>   if <*> pure a =  fmap ($ a) if
00:18:06 <ski> (well, renaming `if' to a non-keyword identifier, i suppose)
00:18:45 <hatds> in C you would (supposedly, I've never done it) have saved memory before hand to execute your functions to recover from a stack overflow
00:18:47 <Saizan> jn: (f 5) gets evaluated only after try returns, because of laziness
00:18:49 <hatds> not sure how that works
00:19:03 <Beelsebob1> copumpki: not much, except the knowledge that it happened
00:19:05 <Saizan> jn: you've to use seq or $! to force evaluation
00:19:08 <Beelsebob1> ... now you can display a dialog
00:19:09 <hatds> I guess you can reserve some emergency stack space in C?
00:19:11 <Beelsebob1> rather than just crashing
00:19:13 <Saizan> jn: or use evaluate instead of return
00:19:18 <copumpki> Beelsebob1: wouldn't displaying a dialog require more stack space?
00:19:31 <jn> Saizan: ah obviously.. thanks. been in ocaml land too long.
00:19:34 <Beelsebob1> copumpki: stack space freed up by the fact that we're no longer computing 1000000000000 additions
00:19:51 <Saizan> the exception surely frees that stack, yeah
00:19:51 <ski>   (if <*> ia) <*> ib = (fmap uncurry if) <*> (pure (,) <*> ia <*> ib)
00:19:56 <copumpki> oh, so dumping it all
00:19:59 <copumpki> fair enough
00:20:14 <Beelsebob1> copumpki: it's normal to unwind the stack as exceptions are propogated down it, no?
00:20:24 <Beelsebob1> just don't stick the catch in (+)
00:21:23 <Cale> But what result do you return? The program can't continue, can it?
00:21:28 <Beelsebob1> no
00:21:45 <Beelsebob1> so you return the IO action that displays a dialog box on the screen saying "oh fuck"
00:21:52 <Beelsebob1> and possibly an explanation that the operation the user was doing failed
00:21:57 <Cale> Oh, you can do that currently.
00:21:58 <Beelsebob1> rather than just bombing out
00:22:33 <Beelsebob1> ah, woot, so maybe that answers the original question
00:22:40 * Beelsebob1 goes looking for who asked about it
00:22:59 <Beelsebob1> jn aparently
00:23:04 <hatds> indeed
00:23:06 <PetRat> ski: are these other laws of applicative.. fundamental, or derivable from pure g <*> x = fmap g x
00:23:11 <PetRat> ?
00:24:53 <Cale> Prelude Control.Exception> Control.Exception.catch (do x <- evaluate (sum [1..1000000]); print x) (\(SomeException e) -> print "Oops!")
00:24:53 <Cale> "Oops!"
00:25:41 <Cale> But you have to know which computation is going to stack overflow ahead of time.
00:25:51 <Cale> So that you know to force its evaluation.
00:26:16 <hatds> doesn't sound that bad of a restriction
00:26:58 <hatds> couldn't you just catch it really far down?
00:27:11 <Cale> Well, you have to catch it from IO
00:27:34 <ski> PetRat : iirc, those three i mentioned above is the applicative functor laws
00:28:14 <ski> (you can replace `pure (,) <*> ia' with `fmap (,) ia')
00:28:59 <EnglishGent> hello all :)
00:29:02 <Cale> hello
00:29:10 <EnglishGent> hi Cale :)
00:29:51 <EnglishGent> can someone help me? I'm trying to follow a Haskell tutorial - but it tells me to use the line "import Text.Regex"
00:30:09 <Cale> and you don't have the regex package installed?
00:30:10 <EnglishGent> and that gives me the error "Failed to load interface for `Text.Regex'"
00:30:14 <Cale> mhm
00:30:25 <EnglishGent> I'm using ghc on Debian
00:30:32 <EnglishGent> I just apt-getted it
00:30:43 <Zao> There's a whole slew of packages in Debian.
00:30:45 <Cale> Yeah, Debian's packages are really minimalist and split into a million pieces
00:30:50 <EnglishGent> if it's not a standard library, the tutorial doesnt say how to get it
00:30:52 <Zao> You most probably need one of the bazillion "optional" ones.
00:31:09 <ray> a haskell-platform metapackage would be cool
00:31:15 <Saizan> libghc6-regex-dev or something
00:31:40 <Cale> libghc6-regex-base-dev, libghc6-regex-compat-dev, libghc6-regex-posix-dev
00:31:47 <ray> i'm all for that package minimalism as long as they include nice metapackages
00:31:48 <Zao> ray: Baby steps with a proper GHC package would be good first though.
00:32:04 <EnglishGent> it's kinda confusing having a tutorial that fails on line 2
00:32:04 <Cale> Debian is still shipping 6.8.2
00:32:12 <Cale> (as is Ubuntu)
00:32:12 <EnglishGent> but I'll try apt-getting all that stuff
00:32:17 <EnglishGent> thanks all :)
00:32:36 <Cale> EnglishGent: That stuff normally comes with ghc
00:32:39 <ray> i've resigned myself to being stuck with the previous ghc
00:32:46 <Zao> EnglishGent: Or you could always just install a nice binary GHC from the site.
00:32:52 <Cale> EnglishGent: The Debian guys decided to split it all up into separate packages.
00:33:05 <Zao> What could a major version and several minor versions ever add :)
00:34:02 <EnglishGent> indeed Zao! :)
00:34:19 * Cale guesses that the people maintaining the Haskell-related packages in Debian and Ubuntu are not Haskell users.
00:34:43 <copumpki> :o
00:35:46 <ray> maybe i should do it, but i'm not nearly qualified
00:36:13 <Zao> When you look into the Apt, the Apt looks back at you.
00:36:13 <Cale> Well, maybe they are, but I'd sort of expect to see them around here at least occasionally...
00:36:37 * EnglishGent waits for extra packages to finish installing.... :)
00:36:57 <ray> maintaining freebsd ports is super easy and i still managed to fail at that
00:37:15 <Zao> ray: Well, you have to maintain boot files for that, won't you?
00:37:32 <Zao> Last I checked, GHC only installs on i386 and amd64 :(
00:37:41 <ray> boot files?
00:38:06 <Zao> As far as I understand it, the ports port for GHC on FreeBSD downloads a mini-binary GHC that it uses to build the real deal.
00:38:24 <ray> yeah, i don't know anything about that, i only maintained simple stuff
00:38:50 * boegel feels like his spamming haskell-cafe by replying to don and claus' responses
00:39:00 <EnglishGent> ah... that changes my error message to the (more confusing) "tutorial.o: In function `s1j9_info':
00:39:00 <EnglishGent> (.text+0x2711): undefined reference to `__stginit_regexzmcompatzm0zi92_TextziRegex_'
00:39:00 <EnglishGent> collect2: ld returned 1 exit status
00:39:03 <EnglishGent> "
00:39:05 * ski seems to recall twb maintained some haskell package in debian ..
00:39:11 <EnglishGent> :/
00:39:30 <Cale> EnglishGent: compile with --make
00:39:40 <ray> i lost the domain i was using for email at the time, and never bothered to update it with the freebsd people
00:39:48 <Cale> EnglishGent: (this is generally a good policy regardless :)
00:39:49 <Zao> ray: Which disappointed me a lot on my fine sparc64 FreeBSD :(
00:40:46 <EnglishGent> ah that works!
00:40:49 <EnglishGent> ty! :D
00:41:13 <EnglishGent> (what difference does --make make? I'm kinda new to Haskell...)
00:41:40 <ray> basically, it links stuff
00:41:50 <koeien> EnglishGent: finds -packages that are necessary automagically
00:42:02 <koeien> in this case, something like regex
00:42:18 <EnglishGent> ah - but surprised that isnt the default then...
00:42:45 <koeien> if automated programs compile stuff, you don't want to do it with --make
00:43:06 <koeien> because you may want to know precisely what the dependencies are
00:43:07 <ray> make itself will replace --make in that case
00:43:20 <EnglishGent> I'm trying to go through the tutorial at: http://www.lisperati.com/haskell/
00:43:27 <koeien> i don't know why it isn't the defualt. it's a pretty frequently AQ
00:43:36 <EnglishGent> it would be nice if it mentioned all this! :)
00:44:06 <koeien> yes
00:45:15 * EnglishGent is fairly comfortable with Lisp & ML -- but had the advantage that the enviroments for them was already set up
00:45:16 <EnglishGent> :)
00:45:42 <koeien> aptitude install ghc6 on my machine :)
00:46:41 <ray> i like those illustrations though
00:46:47 <ray> lyah has some competition
00:47:41 <EnglishGent> lyah?
00:47:49 <koeien> learn you a haskell
00:47:53 <koeien> @where learn you a haskell
00:47:53 <lambdabot> I know nothing about learn.
00:47:59 <koeien> @go learn you a haskell
00:48:00 <lambdabot> http://learnyouahaskell.com/
00:48:00 <lambdabot> Title: Learn You a Haskell for Great Good!
00:48:01 <Saizan> @where LYAH
00:48:01 <lambdabot> www.learnyouahaskell.com
00:48:04 <EnglishGent> oh - if anyone knows any other good tutorials I'd love to hear :)
00:49:01 <EnglishGent> this one looked good becuase it dealt with I/O right from the word go - and I'd like to be able to use Haskell for real world stuff - not just comp-sci lab illustrations
00:49:02 <ski> @where YAHT
00:49:02 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
00:49:09 <ski> @where RWH
00:49:10 <lambdabot> is http://www.realworldhaskell.org/blog/
00:49:17 <mux> http://twitter.com/gvanrossum/status/1838308947
00:49:20 * mux nearly died laughing
00:49:29 <koeien> i must say i dislike the final example of the lisperati tutorial
00:50:04 <copumpki> :)
00:50:09 <ski> (: mux
00:50:23 <copumpki> anyone in here on twitter and not on the haskellwiki twitter page?
00:50:25 <EnglishGent> why koeien?
00:50:38 <copumpki> van rossum doesn't have that many followers on twitter, really
00:51:09 <koeien> EnglishGent: lots of i/o :)
00:51:31 <koeien> EnglishGent: i like more, smaller pure functions
00:52:00 <boegel> mux: what's SICP?
00:52:06 <copumpki> structure and interpretation of computer programs
00:52:09 <mux> structure and interpretation of computer programs
00:52:11 <mux> an MIT tetxbook
00:52:16 <Gilly> i guess this: http://en.wikipedia.org/wiki/Structure_and_Interpretation_of_Computer_Programs
00:52:17 <koeien> for example, the writePoint functions should be defined outside
00:52:26 <copumpki> boegel: isn't there some sort of duff's device that we can write in haskell, for streams?
00:52:30 <EnglishGent> koeien - from a mathematical pov so do I .. but as a programmer - I'm of the opinion that if I cant write pacman in a language it's not a real-world tool :)
00:52:30 <koeien> yes, i guess the reason for it was that MIT switched to python for that course
00:52:34 <copumpki> boegel: about your email on -cafe
00:53:12 <koeien> EnglishGent: yes, i am not questioning the example per se
00:53:14 <boegel> copumpki: I don't know what a duff's device is... I'm guessing you're not talking about the beer brand in the Simpsons :)
00:53:36 <koeien> this code makes it hard to debug & test from the GHCi command prompt
00:53:36 <copumpki> boegel: something like http://en.wikipedia.org/wiki/Duff's_device for manually unrolling loops
00:53:56 <copumpki> it could be done with a big tower of case statements in haskell
00:54:07 <ray> it's a terrible yet compelling c idiom
00:54:25 <ray> you manually partially unroll your loop
00:54:26 <Saizan> EnglishGent: the point is on style and organization of code, haskell let's you document the use of side-effects in the type, but you cram everything in a big IO function you lose some of the advantages
00:54:42 <Saizan> s/let's/let/
00:55:09 <Saizan> "if you cram"
00:55:17 * Saizan needs more tea
00:55:18 <boegel> ray: if it results in better performance, then I'm ok with it, I guess
00:55:30 <boegel> ray: although I'd prefer getting good performance with 'clean' code
00:55:32 <ray> i don't care about performance
00:55:38 <ray> but i like duff's device
00:55:48 <ray> it's very clever
00:56:20 <copumpki> boegel: it might be possible to express such a thing as a stream function, so that front-end programs on uvector use it transparently
00:56:26 <copumpki> boegel: needs more thought though :)
01:00:44 <EnglishGent> ok I see that point Saizan - I'm only just learning how to I/O in Haskell _at all_ though :)
01:00:56 <boegel> ray: it is kind of cool
01:01:09 <koeien> EnglishGent: sure :) but this large example is perhaps not the best
01:02:21 <ttwwii> Hello :D How to prove the equation: "map (f . g) = map f . map g" for infinite lists?
01:02:46 <koeien> ttwwii: prove it for [], (x:xs) and, (x:_|_)   iirc (not 100% sure)
01:03:15 <ttwwii> ok thx :)
01:03:43 <Saizan> ttwwii: have you read the "theorems for free" paper?
01:03:46 * ski would assume something with bi-simulation
01:04:22 <ski> (forall n. take n as0 = take n as1) => as0 = as1
01:04:46 <Saizan> at the end it has a simple criteria for telling when it's safe to extend it to corecursive values, iirc
01:10:40 <zoran119> hey, i'm looking through xmonad config file which is written i haskell and i'm trying to understand it. there is a line that says ppTitle = \ _ -> ""
01:10:50 <zoran119> now i think that it sets ppTitle to ""
01:10:56 <koeien> zoran119: almost
01:11:02 <zoran119> but can someone explaing the syntax
01:11:20 <koeien> it is a function that, for every argument you give it, it returns "" (the empty string)
01:12:25 <zoran119> _ matches every parameter, right?
01:12:29 <koeien> yes
01:12:41 <zoran119> what's \
01:12:43 <ski> > let ppTitle = \_ -> ""  in (ppTitle False,ppTitle 42,ppTitle "foo")
01:12:45 <lambdabot>   ("","","")
01:12:48 <koeien> makes anonymous function
01:12:49 <ski> > let ppTitle _ = ""  in (ppTitle False,ppTitle 42,ppTitle "foo")
01:12:50 <lambdabot>   ("","","")
01:12:58 <ski> > let ppTitle x = ""  in (ppTitle False,ppTitle 42,ppTitle "foo")
01:12:59 <lambdabot>   ("","","")
01:13:07 <ray> const "" would be prettier
01:13:13 <koeien> ray: yes
01:13:41 <ski> `\x -> ..x..' is the function that when given an argument, call it `x', returns the value of `..x..'
01:13:55 <ski> > let f = \x -> x*x + 1  in  f 10
01:13:57 <lambdabot>   101
01:14:03 <ski> > (\x -> x*x + 1) 10
01:14:05 <lambdabot>   101
01:14:17 <ski> > map (\x -> x*x + 1) [0..10]
01:14:19 <lambdabot>   [1,2,5,10,17,26,37,50,65,82,101]
01:15:22 <ski> zoran119 : the `\' is the syntax that starts a function value (aka "anonymous function") .. it is supposed to be an ascii version of minuscle greek letter lambda
01:15:23 <zoran119> i'm so lost, i don't even know if u are talking to me
01:15:31 <koeien> :)
01:15:47 <koeien> zoran119: there is an #xmonad channel afaik
01:15:58 <koeien> zoran119: they might be able to answer how to change this setting
01:16:07 <koeien> we would need some more context
01:16:37 <ski> zoran119 : those lambdabot examples just above were meant to show a few different, but equivalent, ways of defining `ppTitle'
01:16:39 <zoran119> koeien: i know... they helped me with the config by saying type this and type that
01:16:56 <zoran119> i want to know the haskell part of it
01:17:01 <koeien> oh
01:17:37 <koeien> ppTitle = \_ -> ""      means that the function for every argument (e.g., a window) gives ""
01:17:54 <ski> zoran119 : generally, `foo = ..' names the (value of the) expression `..' with the name `foo'
01:18:23 <ski> in this case, `ppTitle' is a name given to the (anonymous) function `\_ -> ""'
01:19:32 <zoran119> ski: ah, i get it
01:19:48 <EnglishGent> ok - gotta go irl... thanks for the help all - see everyone later :)
01:19:51 <ski> instead of defining
01:19:53 <ski>   ppTitle = \_ -> ""
01:19:56 <ski> you could do
01:20:01 <ski>   ppTitle _ = ""
01:20:03 <copumpki> polyparse looks nice
01:20:12 <ski> to define the same `ppTitle' with equivalent definition
01:20:16 <zoran119> so by using \ you are omitting the name of the function, but still assigning its return value to ppTitle
01:20:26 <ski> no
01:20:37 <ski> the function itself is "assigned" to `ppTitle'
01:20:49 <zoran119> ok ok
01:20:55 <koeien> zoran119: sorta. not completely.  the anonymous function gets then the name `ppTitle'
01:21:00 <ski> iow `ppTitle' is the name that is here given to the (nameless) function `\_ -> ""'
01:21:35 <ski> zoran119 : by using `\' we *can* omit naming the function, yes
01:21:36 <ski> e.g.
01:21:47 <ski> > map (\_ -> "") [1,2,3]
01:21:49 <lambdabot>   ["","",""]
01:21:57 <joeally> i am trying to  make a function that takes the mean from a list of numbers this is what i came up with" average (x:xs) = div x length (x:xs) + average xs"
01:22:18 <ski> but in this case, the writer of the code directly gave the name `ppTitle' to the function *value* `\_ -> ""'
01:22:20 <koeien> joeally: that is not correct
01:22:24 <dcoutts> @seen aavogt
01:22:24 <lambdabot> aavogt is in #arch-haskell, #haskell and #xmonad. I last heard aavogt speak 2h 33m 48s ago.
01:22:26 <joeally> yes
01:22:33 <joeally>  i get a type error
01:22:42 <koeien> joeally: even if you fix the types it's not the mean :)
01:22:43 <copumpki> joeally: even apart from that
01:22:58 <koeien> joeally: how do you define the mean normally?
01:23:01 <ski> joeally : first, you must use more brackets
01:23:05 <joeally> yes
01:23:20 <joeally>  i know what mean is
01:23:28 <ski> `div x length (x:xs)' is parsed as `((div x) length) (x:xs)'
01:23:41 <koeien> joeally: how did you define it ?  sum of the values divided by the number of values ?
01:23:42 <joeally> oh okay
01:23:45 <joeally> yes
01:23:51 <ski> whereas you (presumably) meant `div x (length (x:xs))'
01:23:57 <joeally> yes ski thankyou
01:24:03 <copumpki> it still isnt correct though
01:24:05 <ski> that can also be written as
01:24:10 <koeien> that doesn't mean that it's correct
01:24:12 <ski>   x `div` length (x:xs)
01:24:23 <joeally> okay thanks ski
01:24:48 <koeien> 1. there is no base case. 2. the definition does not correspond to the mathematical definition of mean.
01:24:51 <ski> > average []  where  average (x:xs) = x `div` length (x:xs) + average xs
01:24:53 <lambdabot>   * Exception: /tmp/1880350984201788398:71:51-101: Non-exhaustive patterns in...
01:25:03 <joeally> (x1 + x2 +x3)/3 is mean right
01:25:06 <ski> > average [42]  where  average (x:xs) = x `div` length (x:xs) + average xs
01:25:07 <koeien> joeally: yes. correct
01:25:08 <lambdabot>   * Exception: /tmp/6901507667190146830:71:61-111: Non-exhaustive patterns in...
01:25:18 <joeally> that means x1/3 + x2/3 + x4/3
01:25:22 <koeien> joeally: yep.
01:25:28 <copumpki> > average [1, 2, 3] here  average (x:xs) = x `div` length (x:xs) + average xs
01:25:29 <lambdabot>   <no location info>: parse error on input `='
01:25:31 <copumpki> > average [1, 2, 3] where  average (x:xs) = x `div` length (x:xs) + average xs
01:25:32 <lambdabot>   * Exception: /tmp/4174601387898950114:71:69-119: Non-exhaustive patterns in...
01:25:34 <joeally> isnt that what i'm doin
01:25:45 <koeien> joeally: no. the value of "length (x:xs)" changes while recursing.
01:25:58 <joeally> oh
01:26:05 <joeally> thanks compumpki
01:26:06 <koeien> joeally: so when you go to the end of the list "length (x:xs)" becomes smaller
01:26:11 <joeally> yes i know
01:26:15 <copumpki> mostly koeien :) I just failed a couple of times
01:26:18 <joeally> the whole function is this
01:26:25 <joeally> average [] = 0
01:26:25 <joeally> average [x] = x
01:26:25 <joeally> average (x:xs) = div x (length (x:xs)) + average xs
01:26:36 <copumpki> I'd hesitate to do [] = 0
01:26:42 <koeien> average [] = 0 doesn't make sense
01:26:46 <joeally> oh
01:26:47 <koeien> you cannot divide by zero
01:26:51 <ski> > average [1,2,3]  where  average [] = 0; average [x] = x; average (x:xs) = x `div` length (x:xs) + average xs
01:26:53 <lambdabot>   4
01:26:56 <copumpki> but you can leave [x] as a base case
01:27:00 <joeally> yes but i have to put something
01:27:01 <koeien> yes, in fact you should
01:27:18 <koeien> joeally: no you don't ;) otherwise i would say    error "the average of the empty list is undefined"
01:27:23 <copumpki> joeally: one option is to make average return Maybe a (for Fractional a)
01:27:28 <joeally> okay
01:27:41 <copumpki> that's only if you're obsessed with having total functions though
01:27:55 <ski> > average [1,2,3] :: Expr  where  average [] = 0; average [x] = x; average (x:xs) = x `div` fromIntegral (length (x:xs)) + average xs
01:27:56 <lambdabot>   1 `div` 3 + (2 `div` 2 + 3)
01:28:03 <ski> > average [1,4,2,8,4,7] :: Expr  where  average [] = 0; average [x] = x; average (x:xs) = x `div` fromIntegral (length (x:xs)) + average xs
01:28:05 <lambdabot>   1 `div` 6 + (4 `div` 5 + (2 `div` 4 + (8 `div` 3 + (4 `div` 2 + 7))))
01:28:11 <koeien> yes, you see the problem here.
01:28:30 <joeally> yes
01:28:41 <koeien> you can do this with some trickery. it helps if you have some scratch paper
01:28:51 <joeally> okay
01:28:53 <joeally> thankyou
01:28:59 <ski> joeally : one solution is to make a local function that does the recursion, and compute the length once, for the "top" input list
01:29:02 <joeally> i'll try the from intergral fucntion
01:29:13 <copumpki> ski: that can cause space leaks though
01:29:23 <ski> joeally : i just used `fromIntegral' there to appease `Expr' .. you need not pay that any heed
01:29:30 <koeien> @let avg2 [x] = x; avg2 (x:xs) = x `div` (fromIntegral (length (x:xs)) + (length xs / length (x:xs)) * average xs   -- something like this
01:29:30 <lambdabot>   Parse error
01:29:38 <koeien> but this is needlessly complex :)
01:29:45 <joeally> okay
01:29:53 <koeien> the best way is to define two functions. one for the sum. one for the length. then say    average xs = sum xs / length xs
01:29:55 <dqd> > let avg x = fromIntegral (sum x) / fromIntegral (length x) in avg [1,2,3]
01:29:56 <lambdabot>   2.0
01:30:01 <ski> copumpkin : for otherwise incremental lists, sure
01:30:03 <joeally> I'm new to haskell and just getting used to reocorrursion
01:30:06 <pumpkin> koeien: I'm not sure I'd call that the best way :P
01:30:09 <joeally> okay thats a good way koein
01:30:13 <koeien> [you will have some space leak -- but for a beginner it's the best]
01:30:19 <koeien> pumpkin: sure
01:30:20 <pumpkin> unless you have the magic fold combinators!!
01:30:21 <pumpkin> :P
01:30:21 <koeien> ;)
01:30:37 <dobblego> @type uncurry div . (length &&& sum)
01:30:38 <lambdabot> [Int] -> Int
01:30:38 <ski> (joeally : hehe .. is "reocorrursion" supposed to be a mixture of "recursion" and "corecursion" ?)
01:30:46 <pumpkin> then you can write sumF <^(/)^> lengthF
01:30:52 <koeien> i had this in my introductory haskell class by the way, using tupling
01:31:03 <pumpkin> koeien: you teach?
01:31:09 <koeien> no, i am teached :)
01:31:12 <pumpkin> oh :)
01:31:24 <koeien> and i preach :)
01:31:45 <pumpkin> :)
01:32:01 <ski> (koeien : you could use `genericLength' as well, instead of `fromIntegral' .. except that meant i got the lengths in `Expr' too :)
01:32:32 <joeally> is this a good function for sum :
01:32:34 <joeally> sum (x:xs) = x + sum xs
01:32:47 <ski> joeally : you're missing a base case there, as well
01:32:47 <koeien> ski: yes. but i was suggesting defining your own 'sum' and 'length' as an exercise.
01:32:51 <joeally> obviously with sum[x] = x
01:32:51 <koeien> joeally: what is sum [] ?
01:32:51 <ski> > average [1,2,4,9,6] :: Expr  where  average [] = 0; average [x] = x; average (x:xs) = x `div` genericLength (x:xs) + average xs
01:32:53 <lambdabot>   1 `div` (1 + (1 + (1 + (1 + (1 + 0))))) + (2 `div` (1 + (1 + (1 + (1 + 0)))...
01:33:04 <koeien> joeally: ok! fine.
01:33:15 <koeien> joeally: you could make sum [] = 0 because the sum of zero elements is zero
01:33:27 <joeally> i suppose
01:33:35 <pumpkin> joeally: not sure how far along you are, but there are some nice higher order functions that allow you to avoid recursing manually
01:33:50 <joeally> yeah but i'm learning
01:33:53 <pumpkin> okay :)
01:33:55 <koeien> (for averages, it is ok; but if you want to use this function elsewhere, it's nice to make it total :)
01:33:57 <joeally> so i want to be able to implement them
01:34:11 <ttwwii> I have a problem with prove for infiniti list for example map f (xs + ys) = map f xs + map f ys. +                +
01:34:18 <joeally> okay koeien
01:34:32 <pumpkin> ttwwii: you mean ++ ?
01:34:36 <ttwwii> yes :P
01:34:53 <ski> @let avg2 [x] = x; avg2 (x:xs) = x `div` fromIntegral (length (x:xs)) + (length xs / length (x:xs)) * average xs   -- something like this
01:34:54 <lambdabot>  <local>:1:97: Not in scope: `average'
01:34:54 <ttwwii> have do it for (x:_|_ ++ ys)?
01:35:07 <koeien> joeally: if you have this in a file, you might want to add the line     import Prelude hiding (length, sum)
01:35:39 <joeally> yeah i changed it to sum
01:35:42 <joeally> sum1*
01:35:44 <koeien> ok
01:35:57 <joeally> because it seemed to clash wit some inbuilt fucntion
01:36:03 <koeien> yep :)
01:36:32 <koeien> so, you have sum1. and now length1 :)
01:36:43 <ski> ttwwii : have you tried my suggestion ?
01:36:55 <joeally> i'm just about to write lenght1
01:37:03 <joeally> length1*
01:37:16 <ski> my_length
01:37:28 <ttwwii> ski: yes but i dont know excatly how to do it if i have (xs++ys)
01:38:06 <mreh> is cabal very similar to apt-get on debian flavour *nix?
01:38:22 <mreh> does pattern matching on the name i supply
01:38:41 <ski> ttwwii : me neither .. but i'd try showing all approximations of the output lists are equal assuming all approximations of the input lists are equal
01:38:43 <dcoutts> mreh: it's not nearly as mature, and it's source based.
01:38:43 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
01:38:58 <joeally> koeien this is my length function
01:38:59 <joeally> length1 [] = 0
01:38:59 <joeally> length1 [x] = 1
01:38:59 <joeally> length1 (x:xs) = 1 + length1 xs
01:39:10 <koeien> joeally: correct. you don't need the second case though
01:39:16 <joeally> okay
01:39:20 <joeally> thanks :)
01:39:24 <koeien> since it's covered by the last one :) do you see why?
01:39:27 <mreh> dcoutts: the documentation is little thin, i'll try fully qualified package names
01:39:30 <joeally> yes
01:39:33 <joeally> i do now
01:39:43 <mreh> dcoutts: it uses hackage as the package server does it not?
01:39:51 <dcoutts> mreh: "fully qualified" ?
01:39:55 <ski> (ttwwii : or maybe divide into cases : (a) infinite lists (`(forall n. as0 !! n = as1 !! n) => as0 = as1') ; (b) et.c. (partial, finite) .. but i'd prefer not to have to do this)
01:40:04 <koeien> joeally: if you're starting out, it helps to give an explicit type signature for your functions
01:40:11 <dcoutts> mreh: yes, that's the default sever set in the ~/.cabal/config file
01:40:21 <mreh> superpackage.parentpackage.packagename
01:40:25 <joeally> yeah i looked at that but it balffled me somewwat
01:40:28 <mreh> that sort of thing
01:40:31 <ttwwii> ski: ok thanks :P
01:40:32 <joeally> somewhat*
01:40:47 <koeien> joeally: you can ask ghci (or hugs, if that's what you're using) for the type sig of your functions.
01:40:54 <joeally> okay
01:41:01 <joeally> thankyou
01:41:15 <koeien> i can understand that, because in this case you might get pretty strange type signatures (using (Num a) => ) and so on
01:41:20 <ski> (ttwwii : the reason for not liking the latter approach being that i'm not really convinced every list is infinite or not)
01:41:20 <magical_1ony> :t funcName
01:41:21 <lambdabot> Not in scope: `funcName'
01:41:43 <magical_1ony> :t length
01:41:44 <koeien> ski: is 1:_|_ infinite?
01:41:44 <lambdabot> forall a. [a] -> Int
01:41:46 <joeally> thanks magical
01:41:56 <dcoutts> mreh: the package namespace is flat, there is no super package or parent package
01:41:59 <ski> koeien : that would be a partial list, in this terminology
01:42:01 <joeally> :)
01:42:11 <magical_1ony> no problem
01:42:25 <joeally> so i would just put "average :: (Fractional t) => [t] -> t"
01:42:30 <joeally>  before average
01:42:35 <ski> yes
01:42:38 <koeien> joeally: yes.
01:42:45 <ski> you may drop the brackets, if you wish
01:42:53 <joeally> thankyou ski koeien
01:42:54 <koeien> ski: that's style :) i like 'em
01:43:01 <ski>   average :: Fractional t => [t] -> t
01:43:18 <joeally> thank you people
01:43:19 <ski> koeien : sorry ?
01:43:36 <koeien> ski: i like the parentheses there, in type sigs
01:43:48 <joeally> ghci gives it with brackets
01:43:49 <koeien> but it's a style thing. don't know what the consensus is
01:43:52 <ski> you mean in constraints ?
01:43:55 <koeien> ski: yes
01:44:21 * ski usually prefers the bare minimum that the syntax allows
01:45:07 <mreh> Graphics/HGL/Key.hs:57:7:
01:45:07 <mreh>     Could not find module `Graphics.Win32':
01:45:07 <mreh>       it is a member of package Win32-2.1.1.1, which is hidden
01:45:07 <mreh> cabal: Error: some packages failed to install:
01:45:07 <mreh> HGL-3.2.0.0 failed during the building phase. The exception was:
01:45:07 <mreh> exit: ExitFailure 1
01:45:28 <mreh> hidden?!
01:45:33 <joeally> get linux bro
01:45:33 <dcoutts> that's borked
01:45:48 <ivanm> what's borked?
01:45:54 <magical_pony> bork bork bork
01:45:54 <dcoutts> mreh: http://haskell.org/cabal/FAQ.html#hidden-packages-a
01:45:57 <koeien> the cabal file :)
01:46:12 <koeien> some build-depends missing probably
01:46:13 <mreh> define: borked
01:46:24 <koeien> (for your platform)
01:46:47 <dcoutts> mreh: the package couldn;t possibly have been tested, it's missing important information in the .cabal file, the dependency on the Win32 package
01:47:05 <mreh> thanks, dcoutts
01:47:34 <dcoutts> mreh: HGL has no maintainer anymore afaik, I'd use a different graphics lib
01:47:43 <mreh> which one?
01:47:56 <mreh> dcoutts: which one?
01:48:10 <dcoutts> depends what you're trying to do, if you wanted HGL for the SOE stuff then there are two other SOE implementations
01:49:06 <mreh> dcoutts: i'm easy
01:49:24 <mreh> SOE is so paltry though
01:49:45 <mreh> i thought HGL was necessary for things like user input
01:49:49 <dcoutts> mreh: I mean are you trying to draw simple 2d graphics, 3d, or GUI's with windows, buttons, menues etc
01:49:58 <mreh> yes
01:50:12 <ivanm> heh
01:50:14 <koeien> :(
01:51:02 <dcoutts> mreh: then you need a serious gui lib like gtk2hs or wxhaskell
01:51:34 <dcoutts> gtk2hs does gui stuff and has a powerful 2d vector graphics api (cairo) and allows embedding 3d OpenGL drawing areas
01:52:11 <trez> is there any easy way to know which array caused index out of range exception or do I need to catch this exception?
01:53:35 <ivanm> trez: you're better of either not using !, or ensuring that you don't go out of range
01:53:43 <mreh> dcoutts: I'll stick to HGL for my asteroids game for now, but thanks for the tips
01:54:06 <mreh> hey, it's raining! yey!
01:54:08 <ivanm> @hoogle Ix i => i -> Array i e -> e
01:54:08 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
01:54:08 <lambdabot> Data.Array.IArray (!) :: (IArray a e, Ix i) => a i e -> i -> e
01:54:08 <lambdabot> Data.Array.Base unsafeAt :: (IArray a e, Ix i) => a i e -> Int -> e
01:54:14 <dcoutts> mreh: ok, but I wouldn't recommend HGL on windows, I don't think it works (even when it compiles)
01:54:27 <ivanm> trez: hmmm... there's a lookup or something function in Data.Array.IArray IIRC
01:54:34 <mreh> dcoutts: i'll test it
01:54:37 <trez> ivanm: yea but to find the bug I need to know in what array it goes out of bounds
01:54:37 <dcoutts> mreh: I think you may be letting yourself in for a lot of frustration, trying to use HGL
01:54:50 <magical_pony> get a linuxes. make a small partition with ubuntu and go nuts.
01:55:12 <mreh> sounds like a good idea, i have yet to do so on my laptop
01:55:27 <trez> 'run: Error in array index'
01:55:28 <mreh> i prefer debian
01:55:41 <trez> that does not say a lot..
01:55:42 <ski> (mreh : raining lambdas ?)
01:55:49 <dcoutts> mreh: http://hackage.haskell.org/trac/ghc/ticket/742
01:56:03 <magical_pony> i'm running arch, it's an interesting distro
01:57:29 <mreh> can anyone think how it might be possible to develop as3 games in haskell
01:58:56 <zoran119> nope, .xinitrc doesn't work
01:59:08 <zoran119> sorry, wrong forum
02:02:01 <boegel> zoran119: you do realize you'll have to write 1,000 of lines of C now to make up for that?
02:03:46 <zoran119> boegel: 46 lines to go!
02:06:08 <Hunner> `````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````
02:06:14 <Hunner> cat
02:06:23 <Hunner> ugh, she's all wet too
02:07:28 <Lemmih> ?where ops
02:07:28 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
02:07:28 <lambdabot> mauke
02:07:35 --- mode: ChanServ set +o dcoutts
02:07:38 --- kick: Hunner was kicked by dcoutts (dcoutts)
02:08:28 <Saizan> Lemmih: you are an op too, btw
02:08:30 <dcoutts> Hunner: or was I too quick? did you really mean your cat walked over your keyboard? :-)
02:08:37 <pumpkin> I thought he meant that the cat walked on it :P
02:08:50 <Hunner> uh, yeah, my cat walked on my keyboard
02:08:52 <dcoutts> Hunner: apologies
02:09:17 --- mode: ChanServ set -o dcoutts
02:09:27 <Peaker> Who's D.A turner? Is he in #haskell?
02:09:59 <mreh> Hunner: raining in London
02:10:14 <Peaker> I'm reading the "Total Functional Programming" paper, and it seems very nice so far (written by him) :)
02:10:24 --- mode: ChanServ set +o Lemmih
02:10:33 <Lemmih> Oh my.
02:10:45 --- mode: ChanServ set -o Lemmih
02:10:54 <pumpkin> feel the power!
02:12:59 <pejo> Peaker, "David Turner", the Miranda guy?
02:13:02 <ski> Peaker : isn't Turner the one who invented Miranda ?
02:13:08 <Baughn> @index unamb
02:13:09 <lambdabot> bzzt
02:13:28 <Peaker> pejo, ski: Possibly, I have no idea
02:13:55 <dolio> Yes, that's him.
02:14:22 <mreh> :t return
02:14:23 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:14:32 <mreh> :t return ()
02:14:33 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
02:15:12 <quicksilver> Peaker: yes, that is David Turner who wrote Miranda. He doesn't IRC, as far as I know (I'd be surprised)
02:15:47 <mreh> he wanted to keep all the lambdas to himself
02:16:09 * osfameron chants "Who ate all the lambdas?"
02:18:41 <mreh> is "do" like a series of nested ">>"s but with a return () at the end?
02:19:04 <mreh> IO, IO, It's off to work we go
02:19:42 <mreh> >putChar '!'
02:19:44 <Baughn> mreh: It's a series of nested >>=s, rather
02:19:52 <Zao> do { a <- x; b x; c x } desugars to a >>= \x -> b x >>= c x
02:19:53 <Zao> Or so.
02:19:54 <Baughn> mreh: return would only be there if you put it there
02:19:54 <mreh> > putChar '!'
02:19:56 <lambdabot>   <IO ()>
02:20:13 <doserj> @undo do a; b; c
02:20:13 <lambdabot> a >> b >> c
02:20:15 <Zao> Err, x <- a
02:20:20 <doserj> @undo do  x <- a; y <- b; f x y
02:20:21 <lambdabot> a >>= \ x -> b >>= \ y -> f x y
02:20:22 <mreh> > putChar 'h' >> putChar 'e' >> return ()
02:20:24 <Peaker> mreh: "do" doesn't add "return" anywhere.  "do" puts >> and >>= and calls to "fail" when you use simple statements, name bindings for effect results, and pattern matches, respecitively
02:20:24 <lambdabot>   <IO ()>
02:20:54 * mreh brane asplode
02:21:04 <mreh> didnt understand most of that
02:21:12 <mreh> i'll come back when i've finished this lecture
02:21:31 <Botje> long time no brane asplosions here
02:21:32 <Botje> yay!
02:21:53 <mreh> hurray!
02:25:04 <Baughn> Botje: No, mine exploded yesterday, learning reactive
02:25:27 <Peaker> Baughn: its surprisingly simple, IMO :)
02:25:41 <Baughn> Peaker: Yes, well, I had to deal with bugs in reactive at the same time
02:25:49 <Baughn> Peaker: ..wound up giving up. How does anyone /use/ that?
02:25:56 <Peaker> Baughn: does it still have bugs in ghc>=6.10.2 ?
02:26:02 <Baughn> Peaker: Yes
02:26:14 <Peaker> Baughn: I don't think Reactive is in real use yet.. what bugs did you find in ghc>=6.10.2?
02:26:19 <Peaker> (Reactive with that ghc, that is)
02:26:35 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5018#a5018 <-- This just crashes
02:26:50 <Baughn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5020 <-- This.. stutters
02:28:05 <Baughn> Peaker: I tried to learn FRP by using it. That was apparently my mistake. :/
02:29:34 <HugoDaniel> hello
02:29:52 <Peaker> Baughn: Interesting to debug it then
02:30:11 <Baughn> Peaker: No, just impossible, but you're welcome.
02:31:12 <alinp> hi
02:31:17 <alinp> I'm missing something in haskell
02:31:23 <alinp> I have a Main module
02:31:28 <alinp> and ofc, a main function
02:31:36 <Baughn> alinp: You're allowed to write longer lines
02:31:49 <alinp> ok Baughn :)
02:32:05 <alinp> and I want to call just a function, but without display something
02:32:09 <Zao> Baughn: I feel limited by the 512 byte message size.
02:32:28 <Baughn> Zao: So do I, especially as irssi doesn't split lines automatically - it just truncates
02:32:44 <alinp> for instance, I don't want to print fib 35
02:32:51 <alinp> I just want to call fib 35
02:32:54 <Zao> let f35 = fib 35
02:33:05 <Baughn> alinp: *Why* do you want to do that?
02:33:11 <ray> but if you call it and don't do anything with the result, you might as well not call it
02:33:12 <benign_failure> Hi. Visual Haskell, does it work with VS2008 (http://www.haskell.org/visualhaskell/ says "need VS2003 or VS2005") and is it a good ide for haskell on win32?
02:33:13 <Zao> It'll probably not be evaluated unless the result is needed though.
02:33:16 <alinp> testing purpose
02:33:37 <ray> if you're testing it, you want to see the result, right?
02:33:44 <Zao> > let x = undefined + 3 in 5
02:33:45 <lambdabot>   5
02:33:46 <ray> you probably want to load it in ghci and play with the function there
02:33:46 <Baughn> alinp: Look in Control.Exception/Control.Parallel.Strategies
02:33:57 <Baughn> alinp: evaluate . rnf to force evaluation at a specific poin
02:33:58 <Baughn> t
02:34:00 <alinp> no, I want to see how much is taking a function to run
02:34:08 <ray> ah, profiling
02:34:08 <Zao> alinp: The point is, it will not need to run.
02:34:11 <Zao> As the result is not needed.
02:34:16 <ray> you can profile it
02:34:41 <HugoDaniel> benign_failure: i would try eclise haskell plugin instead
02:34:49 <ray> i can't really tell you *how*, because i've never done it
02:34:55 <HugoDaniel> s/eclise/eclipse
02:35:06 <ray> are you using ghc?
02:35:19 <benign_failure> <- not an eclipse fan. But I will just try both ;)
02:36:14 <HugoDaniel> benign_failure: personally i use vim (even on windows), and make sure eclipse or vs allow you to replace tabs by 4 space characters, it helps out in indentation
02:36:36 <alinp> Zao: I want to run the function in a binary file
02:36:48 <alinp> for instance, I want to compile the file and after that, to execute it
02:36:52 <mreh> :t (>>)
02:36:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
02:37:01 <ray> benign_failure: since that website doesn't seem to have any recent updates, i expect visual studio 2008 wasn't out yet when they wrote that
02:37:07 <alinp> and afaik this can be done when using main function
02:37:12 <ray> yes
02:38:31 <benign_failure> ray: aye, and I just found http://stackoverflow.com/questions/395828/visual-haskell-2008    doesn't seem to work with vs2008 :( okok, eclipse it is then
02:40:54 <ray> alinp: you want to find out how long a function takes to run?
02:41:12 <alinp> yes, but having a binary for it
02:41:25 <ray> if you're using ghc, see http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
02:41:27 <alinp> without using internal haskell libraries
02:41:36 <Zao> benign_failure: EclipseFP works decently.
02:41:43 <Zao> benign_failure: I prefer just using vim though.
02:41:50 <alinp> I don't want to display anything
02:41:56 <alinp> I just want to call a function :)
02:42:13 <ray> if you call it and then don't do anything with the value, though, the compiler will optimize it out of existence
02:42:16 <alinp> can't this be done in haskell ? I mean, I'm sure it can be done, but I don't know how
02:42:37 <Baughn> alinp: I told you already. evaluate . rnf
02:42:49 <ray> yes, that will work
02:42:55 <ray> but printing it is probably a lot simpler
02:42:55 <alinp> oh, sorry, didn't saw that
02:43:00 <alinp> thanks guys
02:43:04 <Baughn> Yes, but printing also affects the runtime
02:43:07 <Baughn> Sometimes a lot
02:43:17 <benign_failure> Zao: maybe vim is worth a look, too. Every 10 years I _could_ give it a shot :)
02:43:35 <Baughn> Anyway, evaluate introduces an artificial external dependency, namely on the outermost constructor of what you pass to it
02:43:41 <ray> last time i gave vim a shot, i installed nvi
02:43:47 <Baughn> rnf collapses whatever value you pass to /that/ to a single ()
02:43:55 <Baughn> So a combination will fully evaluate whatever
02:44:45 <ray> i'll have to remember that one if i ever profile something
02:45:01 <ray> or really, just remember those modules in general
02:45:26 <Baughn> Control.Parallel.Strategies is absolutely crucial.. in general, really
02:45:29 <Zao> benign_failure: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
02:45:49 <Zao> > let a = [0..] in Control.Parallel.Strategies.rnf a
02:46:02 * Zao rolls thumbs
02:46:05 <lambdabot>   thread killed
02:46:05 <Baughn> Zao: ..yes, okay, that won't work
02:46:48 <ray> makes sense
02:47:12 <benign_failure> Zao: ty, I'll try it
02:47:18 <Baughn> There are strategies meant to work on infinite lists. That isn't one of them. :P
02:51:50 <Peaker> Cool, the "Total Functional Programming" paper just gave me an example of when Turing Completeness is a must for real-world programs:  When writing an interpreter for your total language (You can write it in another total language, but at the end of the interpreters' tower, there's going to have to be a Turing Complete interpreter)
02:53:22 <randomity> Peaker: yeah, that's also the easiest way to prove a language is turing-complete (write an interpreter for some trivial but known-to-be-complete language such as Unlambda or Brainfuck)
02:54:18 <Peaker> randomity: Yeah, but you could say that's not a "real-world-interesting program" if you're assuming that turing-completeness is not necessary for interesting things
02:54:48 <Peaker> randomity: but even an interpreter for a total (non-turing-complete) language requires turing completeness (or defers that requirement to the next interpreter)
02:55:16 <Peaker> though I like the idea of putting turing completeness in a monad, like side-effects
02:55:56 <quicksilver> Peaker: consider the language "Hello", in which programs are always precisely one instruction.
02:56:03 <quicksilver> Peaker: that instruction is "World".
02:56:22 <quicksilver> (the effect of executing 'World' is to print the text "Hello World")
02:56:36 * Reiv pokes his nose in inquisitively
02:56:41 <quicksilver> the program "World" - which, in fact, is the only valid program - is also a perfect interpreter.
02:56:44 * Badger follows suit.
02:56:54 <quicksilver> it interprets the only possible program, correctly.
02:57:05 <Reiv> Any fans of parsers here? I have some Very Noobish Questions, as I'm having some trouble getting my head around the starting stages.
02:57:06 <quicksilver> Obviously, Hello is a total programming language.
02:57:21 <quicksilver> and yet, it contains its own interpreter.
02:58:03 <Peaker> quicksilver: I'm sure you can add some prerequisites to what interpretation must be able to do to avoid the uninteresting trivial interpreters
02:58:11 <ray> reiv: the only noobish thing is asking to ask :)
02:58:21 <Peaker> Baughn: your Reactive program WorksForMe(TM)
02:58:32 <quicksilver> Peaker: which prerequisites, though? :)
02:58:47 <Baughn> Peaker: What ghc version?
02:59:09 <Peaker> Baughn: 6.10.3
02:59:33 <Peaker> Baughn: the latter program does have weird behavior :)
02:59:44 <Peaker> Baughn: the former seems to function as you'd expect (the "fails" part)
03:00:30 <Baughn> Peaker: Ah. Yes, 10.3 fixed that one, apparently
03:00:34 <Baughn> It fails in 10.2 at least
03:00:57 <Baughn> Peaker: Oh, but if you compile with -threaded, it fails
03:01:28 <Peaker> Baughn: put {-# OPTIONS -O2 -Wall -threaded #-} at the top?
03:01:31 <Baughn> Peaker: Unless you run it with +RTS -I0, in which case it doesn't
03:01:56 * Baughn shrugs. 'twas a throwaway test
03:02:57 <Peaker> Baughn: I see, the former crashes with "thread blocked indefinitely", the latter "mostly works" but sometimes accumulates
03:03:52 <Peaker> Baughn: something seems to be indeed buggy, not necessarily Reactive itself (as the ghc 6.10.1 bug has shown)
03:04:03 <Peaker> Haskell needs better debugging tools, IMO
03:04:35 <Baughn> Peaker: Conal believes it's reactive.. I think
03:05:08 <Peaker> Baughn: I guess adding prints everywhere could help ;)
03:08:18 <Baughn> Peaker: Or, rather, it's reactive /and/ GHC
03:08:44 <Baughn> Peaker: There are still subtle bugs in the implementation of unamb (as you see with the spurious thread-lock thing), but mainly they're in reactive
03:08:48 <Baughn> Hm..
03:09:11 * quicksilver notes that Reactive is an unusual case, insofar as it creates a need for debugging tools by going *beyond* haskell.
03:09:21 <quicksilver> Reactive is partly code, partly compiler extension.
03:09:36 <quicksilver> still, that doesn't mean the tools wouldn't be nice to have.
03:10:10 <Peaker> why is it a "compiler extension"?
03:10:22 <quicksilver> because it uses unsafePerformIO
03:10:28 <quicksilver> that's a tool to extend the language/compiler/runtime.
03:11:04 <Peaker> you can write a debugger that handles that
03:11:15 <Peaker> at least for the "safe perform IO" case :-)
03:11:37 <quicksilver> I didn't say, or suggest you couldn't.
03:11:53 <quicksilver> I was just pointing out that reactive stresses things more than a pure haskell app.
03:11:57 <quicksilver> because it's trying to hook into the RTS.
03:13:00 <pozic> Is replicateM lazy for some monads?
03:13:17 <Peaker> @src replicateM
03:13:17 <lambdabot> replicateM n x = sequence (replicate n x)
03:13:29 <Peaker> pozic: sequence is lazy for some monads, so yeah
03:13:35 <tetha> heh, that program is efficient enough to break the exercise. "plot the runtimes for more threads and examine the speedup". The problem's: I cannot cram more input into the memory, and the runtime is still below any easy measurement
03:13:46 <Peaker> > replicateM 99999999 [1]
03:13:48 <Baughn> > take 1 $ replicateM 999999999999999999 [1]
03:13:48 <lambdabot>   * Exception: stack overflow
03:13:50 <lambdabot>   * Exception: stack overflow
03:14:04 <Peaker> > replicateM 99999999 []
03:14:04 <quicksilver> pozic: replicateM behaves like lots of >>s
03:14:05 <lambdabot>   []
03:14:23 <pozic>  fmap head $ replicateM 999999999 (Just 1) gives me a stack overflow
03:15:05 <Berengal> > fmap head $ replicateM 100 (Just 1)
03:15:07 <lambdabot>   Just 1
03:15:33 <Peaker> > replicate 9999999999 (Just 1)
03:15:34 <Berengal> @src sequence
03:15:34 <lambdabot> sequence []     = return []
03:15:34 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
03:15:34 <lambdabot> --OR
03:15:34 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
03:15:35 <lambdabot>   [Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just...
03:16:07 <Peaker> > Identity 1
03:16:08 <lambdabot>       No instance for (Show (Identity t))
03:16:08 <lambdabot>        arising from a use of `show'...
03:16:17 <Peaker> > getIdentity . Identity $ 1
03:16:18 <lambdabot>   Not in scope: `getIdentity'
03:16:21 <Peaker> > unIdentity . Identity $ 1
03:16:22 <lambdabot>   Not in scope: `unIdentity'
03:16:32 <Peaker> @hoogle Identity a -> a
03:16:33 <lambdabot> Control.Monad.Identity runIdentity :: Identity a -> a
03:16:33 <lambdabot> Prelude id :: a -> a
03:16:33 <lambdabot> Data.Function id :: a -> a
03:16:45 <pozic> That is not lazy enough for my needs.
03:16:52 <Peaker> > runIdentity (replicateM 999999999999 (Identity 1))
03:16:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:17:11 <Peaker> pozic: replicateM is lazy, Maybe and []'s monad instance seems to be the problem here
03:17:25 <quicksilver> it's not a laziness issue.
03:17:28 <quicksilver> it's semantics.
03:17:40 <quicksilver> it has to get to the end of the list to check there isn't a Nothing.
03:17:55 <quicksilver> > sequence [Just 1, Just 1, Just 1, Just 1, Just 1, Nothing]
03:17:57 <lambdabot>   Nothing
03:17:58 <Berengal> > runIdentity $ fmap head $ replicateM 999999999999999 (Identity 1)
03:17:59 <lambdabot>   1
03:18:22 <quicksilver> sequence can't possibly return the 'Just' constructor until it's got to the end of the list?
03:19:18 <Peaker> > sequence [[1],[1],[1],[1],[]]
03:19:19 <lambdabot>   []
03:19:25 <Peaker> (ditto for lists)
03:19:47 <Berengal> replicateM for Maybe is useless anyway
03:20:00 <pozic> quicksilver: Ok
03:21:02 <quicksilver> Berengal: sure, but the issue is the same for [] where it's not useless ;)
03:21:29 <quicksilver> > sequence [[1],[1],[1],[1],[2]]
03:21:30 <lambdabot>   [[1,1,1,1,2]]
03:22:01 <Berengal> quicksilver: Well, yes, but if you should happen to find yourself in the Maybe monad and need to replicateM, (fmap.).replicate will work just the same
03:22:14 <Berengal> Except it won't die on you
03:23:07 <quicksilver> > sequence [[1],[1],[1,1],[1],[2]]
03:23:08 <lambdabot>   [[1,1,1,1,2],[1,1,1,1,2]]
03:28:09 <Peaker> Can a rewrite rule convert replicateM to (fmap.).replicate for Maybe's?
03:29:22 <quicksilver> yes.
03:29:26 <quicksilver> sounds like a stupid thing to do though :)
03:30:11 <Peaker> quicksilver: why?
03:30:25 <quicksilver> because replicateM isn't useful, in Maybe
03:30:34 <Peaker> yeah, but maybe somebody's using it in polymorphic code
03:30:45 <quicksilver> then a rewrite rule won't spot it.
03:30:47 <quicksilver> ;)
03:31:17 <Peaker> quicksilver: not even when it could statically?
03:31:34 <Berengal> Peaker: Separate compilation
03:31:34 <quicksilver> only if the polymorphic code gets inlined and hence specialised.
03:37:32 <lilac> i'm slightly surprised that GHC isn't smart enough to notice that forcing replicateM n (Just x) will always terminate, and with a Just constructor
03:39:51 <quicksilver> lilac: are you also suprised it doesn't know sum [0,0...] is 0 ?
03:40:43 <lilac> quicksilver: that's an excellent point, thanks ;-)
03:41:11 * lilac is grateful for being struck with a padded cluebat
03:41:55 <doserj> sum [0,0...] = undefined is fine, but it could handle  sum (replicate 1000000 0) better
03:42:05 <tetha> who knows what kind of type hackery we are going to see.. so maybe somewhen such things as sum [0,0...] might be seen :)
03:42:37 <tetha> er, there's a =0 missing
03:42:56 <lilac> doserj: i think this all reduces to: GHC could optimize better if it could prove totality
03:43:41 <lilac> that said, in cases such as replicateM n (Just x) and sum (replicate 1000000 0), proving totality seems pretty easy
03:44:19 <tetha> you also need that 0 is a neutral element for the addition
03:44:45 <lilac> tetha: specifically for +#
03:51:47 <lilac> i've looked through the core; it's not fusing the sequence and the replicate together. optimizing further looks pretty hard.
03:58:25 <pejo> lilac, I don't think you need totality for some of the stuff you want. I'm guessing Supero would do some of the things you want, and that even works without types.
03:59:00 <quicksilver> static optimisations which reduce complexity classes are a two-edged sword.
03:59:22 <quicksilver> static optimisations are by nature fragile, and it's annoying when your code suddenly jumps up a complexity class.
03:59:54 <Peaker> quicksilver: could be nice to have a "suggestion" or so: "Can possibly reduce complexity/optimize blah blah"
04:00:15 <Peaker> quicksilver: if these optimizations were explicit and not implicit (say, integrated in the editor, offering to optimize explicitly in the code), it'd be nicer still
04:00:38 <quicksilver> But they apply to transformed code, not source code.
04:00:45 <quicksilver> during the transformation, code gets duplicated and mvoed around.
04:00:56 <quicksilver> there may not be  sensible place in the source code to make the offer :)
04:01:08 <pejo> Peaker, that's a whole lot of worrying about operational behaviour that is hard to predict.
04:01:18 * quicksilver likes to worry.
04:01:32 <pejo> I prefer to worry when there's a reason.
04:02:28 <pejo> I still can't tell what the result of fusing/specializing more than 2 or 3 functions will be, and that is far less than most pipelines people write in this channel.
04:06:24 <ray> pipelines.. maybe flip (.) should be called (|)
04:06:29 <ray> it's probably taken though
04:06:53 <EvilTerran> | is reserved syntax for guards
04:06:54 <Peaker> ray: (>>>)
04:07:14 <Peaker> > ((+1) >>> (*2)) 5
04:07:15 <lambdabot>   12
04:07:17 <ray> i know, i'm thinking unix pipes
04:07:19 <idnar> flip (.) should be (..), right? (except that's also reserved)
04:07:34 <EvilTerran> unix (|) strikes me as more like flip ($) than flip (.)
04:08:05 <Peaker> Maybe operator names should only be palindromes if they are cummutative
04:08:17 <augustss_> yes!
04:08:18 <lambdabot> augustss_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:08:18 <idnar> EvilTerran: depends on whether the first command needs input on stdin or not :P
04:08:23 <Peaker> (.) is a palindrome so should be reserved for a cumutative function
04:08:31 <idnar> *commutative
04:08:32 <ray> yeah, except commutative
04:08:57 <Peaker> (.) can be reserved for module attributes
04:09:31 <ray> <<< works and is asymmetrical, plus more general
04:09:36 <idnar> <<< is pretty unwieldy for function composition
04:09:44 <ray> `fmap`
04:10:03 <Peaker> maybe if all the arrow stuff was 2 instead of 3 (though && and || and ** are taken)
04:10:06 <ray> personally, i like composition as dot, but there's good arguments for the other side
04:10:22 <augustss_> I would exclude single character operators from the commutativity thing
04:10:22 <idnar> presumably << and >> are also taken?
04:10:35 <ray> augustss_: same
04:10:40 <boegel> idnar: yeah
04:10:44 <boegel> @type (<<)
04:10:45 <lambdabot> Not in scope: `<<'
04:10:45 <ray> consider (-) and (/) too
04:10:47 <EvilTerran> >> is, by Monad; oddly, i don't think << is
04:10:52 <EvilTerran> ?hoogle (<<)
04:10:52 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
04:10:53 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => Html -> b -> a -> b
04:10:53 <lambdabot> Text.XHtml.Transitional (<<) :: HTML a => Html -> b -> a -> b
04:10:56 <idnar> even (+) and (-) aren't necessarily commutative
04:11:03 <Peaker> idnar: (+) better be
04:11:09 <augustss_> Especially not -
04:11:17 <idnar> er, heh
04:11:19 <boegel> > (+) 1 2
04:11:20 <lambdabot>   3
04:11:22 <boegel> > (+) 2 1
04:11:23 <lambdabot>   3
04:11:30 <idnar> I meant (+) and (*), but I can't think of an example for (+)
04:11:36 <augustss_> + on Nat isn't commutative
04:11:37 <ray> (+) is either required to be commutative or should be
04:11:44 <Peaker> augustss_: why?
04:11:49 <boegel> augustss_: ?
04:11:51 <augustss_> _|_
04:11:56 <idnar> ray: why?
04:11:57 <Peaker> augustss_: in a total language :)
04:12:05 <ray> hrm, _|_
04:12:09 <augustss_> Ah, in the dream world. :)
04:12:11 <boegel> ray: ass! :)
04:12:20 <ray> the polite term is bottom
04:12:21 <idnar> Peaker: this isn't #peakerlang :P
04:12:26 <boegel> ray: same thing
04:12:33 <Peaker> augustss_: you don't believe total languages will succeed as much as Haskell has already, in the next 15 years?
04:12:40 <boegel> is it called bottom because it looks like an ass?
04:12:50 <ray> that's just a happy coincidence
04:13:01 <augustss_> Peaker: I think they might, because Haskell isn't really much of a success. :)
04:13:08 <tetha> I think the proper term would be 'divergent computation', but thats unwieldy
04:13:19 <Peaker> augustss_: successful enough to get real world work done with it :)
04:13:23 <idnar> Peaker: if after 15 years they can't even match Haskell's success, they might as well give up
04:13:47 <augustss_> Peaker: absolutely.  There are already total languages used in the real world.
04:14:00 <augustss_> Like SQL
04:14:36 <idnar> SQL is total?
04:14:54 <augustss_> idnar: yes, unless you have some weird extensions
04:14:57 <blackh> It's total garbage. Does that count?
04:15:00 <quicksilver> except for the most recent standard with the weird recurrence stuff.
04:15:13 <idnar> blackh: hahaha
04:15:22 <augustss_> blackh: In an argument to our advantage even garbage can be used.
04:15:22 <quicksilver> xpath is probably total, isn't it? on a similar vein
04:15:29 <idnar> maybe I don't understand what that means, then
04:15:34 <quicksilver> it's quite a desirable property for a query language.
04:18:31 <tetha> hm, unless the queried structure is mean and total queries cannot reach everything, I think
04:19:07 <pozic> SQL as used in the real world is not total, some standard is, though.
04:19:44 * quicksilver thinks the vast majority of SQL uses in the real world are in the total subset.
04:19:48 <Peaker> @hoogle catches
04:19:48 <lambdabot> No results found
04:20:28 <quicksilver> tetha: things like transitive closure are not generally expressible in total languages.
04:25:21 <Peaker> is it safe to try to kill dead threads? Do thread IDs get reused?
04:25:44 <roderyk> In my cabal file, I have under the executable " ghc-options:       -threaded"; is there anything else I need to do? my executable is being run with a single thread (if I ghc --make -threaded .. ; myself, everything works fine)
04:26:31 <Peaker> in umamb's source:  (myThreadId >>= killThread) >> unblock (race a b)  -- doesn't unblock (race a b) die immediately because of the killThread?
04:27:37 <roderyk> oops, nevermind. I needed to clean dist/
04:29:18 <Peaker> myThreadId >>= killThread will only continue execution until unblock, no?
04:31:30 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5031#a5031
04:31:37 <Peaker> doesn't killThread send an async exception?
04:33:26 <tetha> ah, beautiful, my copy of "To mock a mockingbird" arrived
04:36:44 <Peaker> weird! Control.Exception.block does not seem successful at blocking ThreadTermination
04:37:33 <Peaker> or at least, when that termination is self-served
04:38:08 <Peaker> ok, it does block thread terminations from other threads, but not from own thread...?
04:39:48 <Peaker> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5032#a5032  -- prints haha1 only
04:40:02 <Peaker> it should also print "haha".  Is ghc's thread system very buggy? :(
04:41:06 <blackh> Peaker: Threads aren't buggy but it doesn't seem to tolerate several threads writing to the console at the same time.  It'll work if you put locks around the print's.
04:41:29 <Peaker> blackh: same behavior if there's just one thread printing
04:41:45 <blackh> Peaker: Actually the main thread is probably exiting too soon. Put a delay in the main thread.
04:42:38 <Peaker> blackh: same
04:43:10 <Zao> Or use mvars or suchlike to wait for worker threads to be done with work.
04:43:28 <Peaker> blackh: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5033#a5033 -- no haha printed
04:44:59 <blackh> Peaker: I have never looked at what 'block' does
04:45:41 <blackh> But judging by the documentation, it looks like it doesn't block thread death. You might have to read the code.
04:45:55 <blackh> Well, judging by your code and the documentation.
04:46:23 <quicksilver> Peaker: maybe killThread blocks in that case?
04:46:58 <quicksilver> Peaker: I.e. how do you know that that thread dies, rather than is just never reaching print "haha" ?
04:47:20 <dibblego> do other Arrow instances often arise besides (->) and Kleisli m ?
04:48:15 <Peaker> quicksilver: interesting proposition :)
04:48:40 <quicksilver> dibblego: the only interesting arrow instances which are not kleisli arrows I'm aware of are the S-D parsers
04:48:56 <Peaker> quicksilver: how can I know whether a thread is alive?
04:49:28 <Peaker> Why are Kleisli arrows interesting and normal functions aren't?
04:49:29 <quicksilver> I don't know.
04:49:42 <quicksilver> Peaker: normal functions are kleisli arrows too.
04:49:48 <Peaker> quicksilver: okay, so its probably a bug to  (myThreadId >>= killThread) anyway, which conal uses in unamb
04:50:01 <Peaker> quicksilver: of the identity monad?
04:50:07 <quicksilver> right.
04:51:53 <Peaker> @tell conal "myThreadId >>= killThread" appears in Unamb.hs and is probably a bug, because even when blocked, it probably blocks forever to deliver the exception
04:51:53 <lambdabot> Consider it noted.
04:53:33 <Peaker> I wonder why Unamb re-races stuff if it gets a thread termination
04:53:48 <Peaker> Can anyone look at Unamb.hs:97?
04:54:02 <Peaker> (unamb package: src/Data/unamb.hs)
04:54:37 <Peaker> http://hackage.haskell.org/packages/archive/unamb/latest/doc/html/src/Data-Unamb.html
04:54:41 <dibblego> what is S-D parser?
04:55:00 <Peaker> I don't understand why the "Just ThreadKilled" handling makes any sense
05:02:27 <quicksilver> dibblego: swierstra duponcheel
05:03:21 <dibblego> is there a data structure declaration for such a parser?
05:03:25 <Peaker> can evaluation cause execution of a killed thread to continue?
05:04:45 <Xen0x> swierstra duponcheel?
05:04:56 <Xen0x> never mind :)
05:05:00 <Peaker> what happens to exceptions inside forkIO'd threads?
05:05:05 <Peaker> the threads simply die?
05:05:07 <Xen0x> it's Doaitses parsers I suppose
05:05:11 <Peaker> (pure exceptions)
05:08:53 <Peaker> a thread dying on an exception generates a message to stderr but otherwise execution continues?
05:09:33 <Saizan> execution of other threads continue, yes
05:11:00 <Peaker> how do you catch a pure exception in IO?
05:11:02 <Peaker> @hoogle catch
05:11:02 <lambdabot> package catch
05:11:02 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
05:11:02 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
05:11:22 <Peaker> Prelude.catch does not seem to do it. Control.Exception.catch does?
05:11:29 <Saizan> yes
05:12:12 <Peaker> thanks
05:13:06 <quicksilver> different versions of C.E.catch depending on your base version.
05:13:13 <quicksilver> and Im' not sure what you mean by 'pure exception'
05:13:14 <quicksilver> but, yes :)
05:13:45 <Peaker> how do I use C.E.catch to catch all exceptions?
05:13:48 <Peaker> base >=4
05:14:08 <Peaker> const handlers leave ambiguous exception type variables
05:14:55 <Peaker> ah, can catch (SomeException _)
05:15:48 <Peaker> does catching SomeException catch all exceptions?
05:15:53 <Saizan> yes
05:17:06 <Peaker> weird way to handle exceptions right there :)
05:19:30 <Saizan> it's like on java, so i guess it is :)
05:27:51 <ivanm> is there a non-negative integer type?
05:28:08 <koeien> no.
05:28:14 <koeien> (not unbounded, anyway)
05:29:01 <koeien> if you want the same size as "Int", use "Word" instead
05:29:27 <ivanm> that's all I care about
05:29:32 <ivanm> not having negatives
05:29:44 <koeien> > 2^64 :: Word
05:29:46 <lambdabot>   0
05:29:54 <ivanm> how about one that only has positive integers? ;-)
05:30:12 <ivanm> > fromInteger (-1) :: Word
05:30:13 <lambdabot>   18446744073709551615
05:30:18 <ivanm> :o
05:30:25 <koeien> all arithmetic is mod 2^n
05:30:37 <koeien> for some n, machine-dependent in the case of Word
05:31:06 <ivanm> true
05:31:12 <ivanm> > fromInteger (-2) :: Word
05:31:13 <lambdabot>   18446744073709551614
05:32:30 <Peaker> > -1 :: Word
05:32:31 <lambdabot>   18446744073709551615
05:32:42 <Peaker> ivanm: literals are already fromInteger'd
05:32:55 <ivanm> oh, yeah... duh :s
05:34:22 <quicksilver> koeien: Integer isn't mod 2^n
05:34:30 <koeien> quicksilver: no. I was referring to Word
05:34:32 <quicksilver> koeien: it just blows up your computer if you exceed the implicit bound.
05:34:47 <koeien> i should have made this more explicit
05:34:51 <quicksilver> *nod* ah, you said "all" :)
05:35:01 <Peaker> stay away from the computer when it blows up
05:35:11 <frwmanners> anyone know if there's a state of the art on automatic stack space analysis?
05:36:01 <ivanm> @index Word
05:36:02 <lambdabot> Data.Word, Foreign, GHC.Exts
05:49:25 <xenoblitz> Hi people, I am sort of experimenting with GADTs
05:49:33 <xenoblitz> I wrote this simple implementation here: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5034
05:49:44 <xenoblitz> but I have some problems... any input is greatly appreciated
05:50:13 <koeien> xenoblitz: you need 'Wire Bool -> Wire Bool -> Wire Bool' for the And constructor
05:50:17 <koeien> i guess
05:50:26 <koeien> instead of Wire a -> Wire a -> Wire a
05:51:26 <xenoblitz> koeien: I would actually like to interpret And for both types differently if possible... sort of overloading it for integers ( = max function) and booleans ( = conjunction function)
05:51:41 <koeien> that is fine. but in that case you cannot use &&
05:51:55 <koeien> :t (&&)
05:51:56 <lambdabot> Bool -> Bool -> Bool
05:51:58 <xenoblitz> koeien: ouch you are right
05:52:16 <koeien> so i suggest to use a typeclass for this
05:52:39 <xenoblitz> koeien: is there no other way that introducing a typeclass?
05:52:41 <koeien> or use Ord
05:53:06 <koeien> the only functions of type a -> a are id and _|_ :)
05:53:18 <mmorrow> xenoblitz: : http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5035
05:53:33 <koeien> so if you want to apply some "combinator" function, you will need a typeclass or a specific type
05:54:09 <koeien> :t max
05:54:10 <lambdabot> forall a. (Ord a) => a -> a -> a
05:54:15 <koeien> > True `max` False
05:54:16 <lambdabot>   True
05:54:20 <mmorrow> or you can use another GADT
05:54:42 <xenoblitz> mmorrow, koeien: thanks for your input
05:57:09 <xenoblitz> mmorrow, koeien: introducing the Ord a => to the and case and using the max function, and Eq to the equality case works like a charm :)
05:57:18 <joeally> how do you pick the pivot in quicksort i forgot
05:57:57 <joeally> do you just pick the term that is in the middle of the list?
05:58:05 <koeien> xenoblitz: yep, but note that max for Bool is not (&&)
05:58:09 <koeien> which is a bit painful
05:58:15 <p_l> joeally: arbitrarily? There are different strategies, which, depending on the data, give different performance...
05:58:21 <koeien> joeally: in quicksort, any pivot is good enough normally.
05:58:23 <xenoblitz> koeien: yeah i just checked... its actually min :)
05:58:27 <joeally> fair enough
05:58:33 <joeally> thanks guys
05:58:44 <joeally> i'm goin for the middle term in the list
05:58:44 <koeien> in the canonical quicksort implementation in Haskell for lists, we pick the first element
05:58:52 <joeally> oh
05:58:56 <koeien> but you could equally well choose the last
05:59:01 <joeally> really
05:59:05 <ivanm> what's the minimum implementation of Show and Read? show and readsPrec respectively?
05:59:06 <koeien> performance suffers a bit
05:59:11 <joeally> i thought you chose one in the middle
05:59:32 <koeien> joeally: Haskell's focus on lists makes the first element more convenient.
05:59:33 <ivanm> joeally: it's arbitrary
05:59:39 <koeien> joeally: but you can pick any
05:59:41 <joeally> okay
05:59:49 <p_l> joeally: the optimal selection depends on data distribution...
05:59:54 <ivanm> then again, it isn't real quicksort, since it's meant to be in-place... >_>
05:59:59 <joeally> yeah i suppose
06:00:08 <ivanm> p_l: yeah, you use the middle one if it's already sorted :p
06:00:11 <koeien> p_l: yes. to avoid ddos, sometimes a random pivot is chosen :P
06:00:27 <koeien> DoS*
06:00:28 <pozic> Does Foo{..}{a = b} work in record construction?
06:00:38 <joeally> no i mean elemnt 4 if there is 8 in the list
06:00:40 <ivanm> pozic: I think it would...
06:00:47 <koeien> perhaps with additional parentheses
06:00:58 <joeally> but first seems easier
06:01:03 <joeally> so i'll go with that
06:01:41 <koeien> pozic: yes it works
06:02:22 <joeally> actually would using the mean as pivot be faster (in most cases) in quicksort
06:03:06 <p_l> joeally: it would be, but you need to know the mean
06:03:15 <koeien> joeally: how do you find the mean? you'll need O(n)
06:03:20 <joeally> yeah i written a function for that eralier
06:03:28 <joeally> earlier
06:03:41 <p_l> joeally: it all breaks down to what is more efficient for the type of data you have to sort
06:03:46 <pozic> koeien: there is no problem is using O(n)
06:04:00 <pozic> koeien: in using O(n), is there?
06:04:06 <koeien> hmm
06:04:06 <mmorrow> xenoblitz: you can do stuff like this too http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5036
06:04:21 <joeally> i am just doing a general one... i'm just writing it for learning
06:04:35 <frwmanners> if you use first then [1..n] becomes O(n^2) no?
06:05:02 <koeien> frwmanners: yes
06:05:16 <pozic> frwmanners: if you use any fixed index, yes.
06:05:18 <koeien> pozic: you would always get a O(n log n) algo that way, or am i wrong here?
06:05:36 <koeien> although with a perhaps horrible constant, since finding the median is a bit tricky
06:05:51 <pozic> koeien: ? median != mean
06:06:39 <koeien> i am confused, how can you ever use the mean as pivot? or did you mean the "middle element" ?
06:06:51 <mmorrow> xenoblitz: heh, i just realized that with that `Func', you have:
06:06:53 <mmorrow> apply :: Wire (Wire a -> b) -> Wire a -> b
06:06:54 <mmorrow> apply = simulate
06:06:56 <joeally> no i meant find the mean of the whole list
06:07:01 <mmorrow> xenoblitz: which seems interesting somehow
06:07:10 <koeien> joeally: yes, but the mean of say [1,2,3,4] is not in the list
06:07:14 <pozic> koeien: I thought the interesting piece of this discussion was the use of the mean. The behaviour of the median is well-known for quicksort.
06:07:16 <joeally> so
06:07:20 <joeally> it doesnt need to be
06:07:36 <koeien> depends on the distribution of the numbers
06:07:41 <ivanm> should Show and Read be prettified-output and parsing of same?  or just using the constructors (i.e. deriving) ?
06:07:54 <koeien> ivanm: you may choose.
06:08:06 <frwmanners> qsort [2^(2^n) | n <- [1..10000]]
06:08:09 <pozic> koeien: but there are probably inputs for which it doesn't work with the mean.
06:08:14 <EvilTerran> pivoting is splitting into (<p), (==p), and (>p) - any one of those three lists can be empty
06:08:27 <ivanm> "It contains only the constructor names defined in the data type, parentheses, and spaces."
06:08:29 <joeally> pozic how
06:08:32 <ivanm> ^^ documentation from show
06:08:38 <joeally> how can there be inputs for which it wont work
06:08:46 <frwmanners> joeally: the one I just gave
06:08:47 <pozic> joeally: by does not work, I mean O(n^2)
06:08:52 <xenoblitz> mmorrow: hehe you fully blew the language up xD
06:09:01 <joeally> oh
06:09:13 <joeally> fair enough
06:09:32 <joeally> it would be slower for large lists aswell
06:09:59 <mmorrow> xenoblitz: :)
06:10:40 <EvilTerran> using the mean should always terminate, seeing as forall xs. all (==mean) xs || (any (<mean) xs && any (>mean) xs)
06:11:14 <koeien> in an ordered field
06:12:07 <pozic> Emacs should insert a do when one uses <- in the code, when it is not there. I always forget those. I am probably not the only one who does that.
06:12:16 <EvilTerran> well, yes. the statement's undefined unless mean and < have meanings.
06:12:18 <koeien> it's in a certain sense ugly, because you need + and /, behaving nicely wrt <, while this is not necessary.
06:12:33 <ivanm> pozic: ummm.... you can use <- in non-monadic code
06:12:45 <EvilTerran> ivanm, you can?
06:12:48 <pozic> ivanm: list comprehensions, what else?
06:12:53 <pozic> ivanm: view patterns?
06:12:59 <pozic> ivanm: I don't use view patterns
06:12:59 <EvilTerran> pattern guards
06:13:06 <EvilTerran> view patterns use ->
06:13:10 <koeien> pozic: view patterns are -> aren't they?
06:13:26 <ivanm> pozic: I meant list comprehensions
06:13:28 <pozic> koeien: I don't use them. Obviously, I don't know.
06:13:41 <pozic> ivanm: it is easy to see the difference between the two uses.
06:14:00 <ivanm> pozic: if it is so "easy", then submit a patch to haskell-mode
06:14:06 <pozic> ivanm: I was not outlining a complete and correct algorithm.
06:14:40 * ivanm hates it when people trivialise something as being "easy" to do, and complain that no-one has done so since it's so "easy"
06:14:56 <ivanm> *despite it being so "easy"
06:15:04 <pozic> ivanm: by easy, I mean that writing down a correct algorithm is not difficult. It might be that Emacs intricacies make things difficult.
06:15:20 <ivanm> pozic: yes, I was hinting at things like that
06:15:30 <pozic> Of course, it still remains a hack, like the rest of Emacs.
06:15:42 <ivanm> even still, I'd be wary of something that inserted code it's "obvious" I want
06:15:50 <ivanm> pozic: how is emacs a hack?
06:15:58 <ivanm> elisp and how it's used might be a hack
06:16:03 <ivanm> but I wouldn't say emacs itself is a hack
06:16:13 <pozic> ivanm: I was mostly referring to all the modes.
06:16:35 <ivanm> how they're implemented? or the fact that it uses modes?
06:16:42 <Badger>  * Endless formatting fixes
06:16:42 <pozic> ivanm: how they are implemented
06:16:51 <ivanm> class Mode m where... ;-)
06:16:55 <Badger> ...
06:16:58 <pozic> ivanm: the fact that it uses modes is brilliant.
06:17:00 <ivanm> pozic: yeah, so elisp is a hack ;-)
06:17:07 <Badger> how did that happen.
06:17:09 <EvilTerran> Badger, mispaste?
06:17:22 <Badger> apparently I pressed up. :)
06:17:29 <Badger> lots
06:17:32 <Badger> oh well.
06:17:57 <ivanm> so is there an "official" verdict on whether Show/Read should use pretty output/input as opposed to dedicated functions for printing/parsing?
06:20:00 * bremner wonders what pretty input is
06:20:18 <ivanm> bremner: s/pretty/human readable/
06:21:14 <ivanm> seems the wiki asks the same question ;-) http://haskell.org/haskellwiki/Show_and_Read_instance
06:22:05 <pozic> ivanm: if you distribute your code, it might be nice to have (show .read) x == x
06:22:24 <ivanm> pozic: well, yes, that's a given
06:22:31 <doserj> *cough* the other way round *cough*
06:22:39 <pozic> doserj: right
06:23:13 <ivanm> but should I also have say write and parse that have (write . parse) x == x , and leave show and read for deriving whilst write and parse deal with more human-readable stuff?
06:23:41 <Saizan> i'd say so
06:23:47 <Twey> I'd do that, aye
06:24:01 <ivanm> *nod*
06:24:02 <Saizan> Show/Read should have valid haskell code as format
06:24:17 <Twey> Well, parse is really only necessary if the format it uses is externally useful
06:24:29 <bremner> ivanm: there is the general principle of be generous in what you accept and careful what you emit.
06:24:47 <ivanm> bremner: hmmmm....
06:24:48 <kpreid> Saizan: so the instance for Data.Set is wrong?
06:25:07 <Saizan> bremner: that gets us the mess with HTML and browsers!
06:25:22 <Saizan> kpreid: should it use Data.Set.fromList ?
06:25:23 <joeally> I've written a quicksort function (kind of) but i'm not sure if this covers all bases :
06:25:25 <joeally> qsort [] = []
06:25:25 <joeally> qsort [x] = [x]
06:25:25 <joeally> qsort (x:xs) = ((lthan x xs)++[x])++(gthan x xs)
06:25:25 <joeally> quicksort x = iterate qsort x !! 2
06:26:03 * Twey tilts his head.
06:26:07 <kpreid> iterate?!
06:26:09 <ivanm> kpreid: I think the issue there is not to show internal details
06:26:09 <Twey> Weird code
06:26:15 <kpreid> I'm pretty sure that's not the right answer
06:26:16 <Twey> Yeah, iterate on qsort?  O.O
06:26:24 <ivanm> but to still let people use Show and Read
06:26:31 <bremner> Saizan: not at all, it just means web page "designers" are not following the principle
06:26:32 <kpreid> Have you tried it on lists larger than 7?
06:26:36 <joeally> as far as I can tell it should work on every thing
06:26:38 <joeally> yes
06:26:40 <koeien> joeally: how did you define lthan ?
06:26:45 <joeally> wieght no i havent
06:26:48 <joeally> yup
06:26:58 <joeally> lthan n [] = []
06:26:58 <joeally> lthan n [x] = if x<=n then [x] else []
06:26:58 <joeally> lthan n (x:xs)
06:26:58 <joeally> 	| x<=n = x:lthan n xs
06:26:58 <joeally> 	| otherwise = lthan n xs
06:27:04 <koeien> if it's just a filter, then it's not ok (use kpreid's suggestion) :)
06:27:13 <Twey> joeally: The traditional Haskell qsort is qsort [] = []; qsort (x:xs) = filter (< x) xs ++ [x] ++ filter (>= x) xs
06:27:26 <kpreid> Twey: ...it is?
06:27:28 <joeally> yes it doesnt work kpreid
06:27:29 <Saizan> bremner: my point is that if consumers don't enforce correctness then producers won't follow it
06:27:34 <koeien> Twey: do not forget to call qsort on the left and right parts
06:27:38 <joeally> twey : oh
06:27:39 <Twey> Did I?
06:27:39 <Twey> Oops
06:27:41 <Twey> Yah
06:27:43 <kpreid> joeally: you need to sort your left and right sublists
06:27:43 <Twey> Yeah**
06:27:52 <kpreid> rather than repeating the whole algorithm
06:28:00 <Twey> qsort [] = []; qsort (x:xs) = qsort (filter (< x) xs) ++ [x] ++ qsort (filter (>= x) xs)
06:28:02 <joeally> okay thanks no
06:28:11 <joeally> no more clues
06:28:17 <joeally> i wanna figure this out
06:28:27 <Twey> joeally: Well, that's evidently not what you're doing.  There are other ways.
06:28:37 <joeally> i no
06:28:45 <joeally> back to square one
06:28:47 * Twey winces.
06:30:52 <joeally> got it
06:30:53 <joeally> qsort [] = []
06:30:53 <joeally> qsort [x] = [x]
06:30:53 <joeally> qsort (x:xs) = qsort(((lthan x xs)++[x])) ++ qsort((gthan x xs))
06:31:05 <joeally> is that right
06:31:23 <Twey> Why did you put extra brackets around everything?
06:31:38 <Twey> I think that's non-terminating
06:31:48 <joeally> i come from python java etc
06:31:51 <joeally> yes it is tweu
06:31:55 <joeally> twey
06:32:01 <joeally> i'll be back
06:32:07 <Twey> You don't want to include x in the stuff that's getting sorted again
06:32:24 <Twey> joeally: Ah, in Python you write ((func(arg, arg)))?  :-P
06:32:31 <joeally> yeah
06:32:42 <Twey> That's not standard practice :)  Stop it :-P
06:32:57 <joeally> no muahah
06:33:01 <stroan> also joeally no need to make the distinction between [x] amd x:xs cases
06:33:07 <Twey> The Python folks will laugh at you too :-P
06:33:16 <endojelly> so, how would I go about specifying different warning flags for ghc for one particular source file? when using --make? separately compiling the files doesn't work either, because they depend on other files which I would like to compile with the normal warning settings
06:33:25 <joeally> okay stroan thanks
06:33:25 <Twey> Yeah — you never use xs, so it's perfectly all right if xs is []
06:33:41 <endojelly> alternative would be to not let ghc care about depending sources and let make do that job
06:33:45 <endojelly> but I somehow like ghc --make
06:33:47 <Twey> It'll just get caught by the empty case on the next recursion
06:33:49 <endojelly> it makes Makefiles cleaner
06:34:31 <endojelly> joeally, don't use func(...), that's rather confusing
06:34:39 <endojelly> joeally, use (func ...) if you must
06:34:41 <joeally> okat
06:34:44 <joeally> okay
06:34:46 <joeally> sorry
06:34:50 <Twey> Especially when you get to multiple arguments
06:34:58 <endojelly> joeally, heh, no problem, I don't really care, but it may save you a lot of trouble %)
06:35:02 <Saizan> endojelly: you can put the flags in a {-# OPTIONS_GHC  .. #-} pragma on the top of the file
06:35:07 <Twey> func(foo bar baz) does not mean func foo bar baz
06:35:39 * juhp tries HipmunkPlayground
06:35:43 <juhp> pretty cool!
06:35:47 <joeally> yes i know tweu
06:35:53 <joeally> twey
06:36:04 <joeally> the brackets are evaluated first
06:36:19 <endojelly> Saizan, ah, nice idea. now, the problem is: the files which should have different warning flags are generated by alex and happy. so unless I find a way to make it stick pragmas at the beginning (which may very well exist), I have to include the normal flags on *every* non-generated source file
06:36:22 <Twey> jeu
06:36:28 <deech> Hi all,I am trying to do 'Maybe' operations in the IO Monad, something like this: {do x <- something; y <- somethingThatReturnsMaybe; liftIO print y}
06:36:36 <Twey> joeally**: Errr, that's a very confusing statement in Haskell
06:36:37 <deech> I think this needs the MaybeT monad transformer but I am not sure how to use it.
06:36:38 <endojelly> Saizan, but of course, if I can make alex and happy generate sources with those pragmas, this will work... thanks...
06:36:41 <Peaker> Saizan: OPTIONS_GHC=OPTIONS?  both fail to accept -threaded
06:36:51 <Twey> They're not evaluated first, but they are evaluated separately
06:37:03 <Twey> i.e. it will attempt to apply the function foo to bar and baz
06:37:19 <Peaker> deech: something that returns maybe, you mean: IO (Maybe ...) ?
06:37:20 <joeally> this workds
06:37:21 <Twey> When foo, being an argument, might not even be a function
06:37:26 <joeally> this works yay
06:37:29 <joeally> qsort [] = []
06:37:29 <joeally> qsort [x] = [x]
06:37:29 <joeally> qsort (x:xs) = qsort ((lthan x xs)++[x]) ++ qsort (gthan
06:37:33 <Peaker> deech: you'll need to transform IO (Maybe a) to MaybeT IO a
06:37:36 <joeally> )
06:37:41 <Peaker> @hoogle maybeT
06:37:41 <lambdabot> package MaybeT
06:37:41 <Twey> joeally: Good; now clean up the mess
06:37:41 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
06:37:48 <joeally> qsort [] = []
06:37:49 <joeally> qsort [x] = [x]
06:37:49 <joeally> qsort (x:xs) = qsort ((lthan x xs)++[x]) ++ qsort (gthan x xs)
06:38:20 <Twey> As mentioned, the [x] case is unnecessary; additionally, you don't need brackets around any of that except the lthan/gthan expressions (++ is associative)
06:38:22 <joeally> yeah
06:38:30 <joeally> it is
06:38:37 <Peaker> deech: MaybeT is pretty trivial, you don't "need" it except for convenience -- if your thing is that simple, you can handle the maybe cases explicitly
06:38:52 <joeally> i do need qsort [x] = [x]
06:38:55 <Saizan> Peaker: that's because -threaded is a link time option, it doesn't really make sense for a single module
06:38:59 <joeally> other wise i get stack overflow
06:39:10 <Peaker> Saizan: oh
06:39:12 <deech> Peaker: Do you mean that my somethingThatReturnsMaybe should be a somethingThatReturnsAMaybeT?
06:39:17 <Berengal> joeally: That's because your inductive case is wrong
06:39:18 <Twey> joeally: Only because you forgot to handle the case where x == head xs
06:39:24 <endojelly> joeally, this might be even easier to read: qsort (x:xs) = qsort ((x `lthan` xs) ++ [x]) ++ qsort (x `gthan` xs)
06:39:27 <deech> Peaker: I'm trying to learn to use monad transformers
06:39:28 <Saizan> Peaker: except for Main, maybe
06:39:30 <Twey> lthan x xs = filter (< x) xs, and gthan x xs = filter (> x) xs
06:39:37 <joeally> yeah i supose
06:39:42 <Peaker> deech: if you want to use MaybeT, yeah. Or you can just convert an IO (Maybe a) to MaybeT IO a with the MaybeT data constructor
06:39:45 <Twey> But it should be either <= or >=
06:39:54 <joeally> na my lthan is rather more convoluted
06:39:55 <Twey> You need to include the elements that are equal to x somewhere
06:39:59 <Saizan> endojelly: i think if you put them in the .x and .y files they might get copied into the final .hs
06:40:07 <joeally> lthan n [] = []
06:40:07 <joeally> lthan n [x] = if x<=n then [x] else []
06:40:07 <joeally> lthan n (x:xs)
06:40:07 <joeally> 	| x<=n = x:lthan n xs
06:40:07 <joeally> 	| otherwise = lthan n xs
06:40:07 <Peaker> deech: MaybeT :: Monad m => m (Maybe a) -> MaybeT m a
06:40:11 <Twey> joeally: For no good reason
06:40:17 <Twey> You've just reimplemented filter
06:40:18 <joeally> yes
06:40:22 <Twey> Square
06:40:25 <joeally> or list comprehension
06:40:30 <xenoblitz> koeien, mmorrow: do you think its possible to create the same effect using phantom types rather than GADTs? I am finding problems with defining simulate
06:40:40 <joeally> i forgot about those though
06:40:48 <Peaker> joeally: why do you handle the [x] case specially?
06:41:07 <endojelly> Saizan, there's ways to include arbitrary stuff, I just have too hope that the pragmas don't come too late (e.g. language pragmas need to come *before* the module declaration), but yeah, I think it'll work
06:41:11 <endojelly> I'll try right now
06:41:12 <joeally> i thought it wouldnt work otherwise
06:41:14 <deech> Peaker: Can I use lifting to convert a function that returns to one that returns MaybeT?
06:41:22 <Peaker> joeally: think about what happens if you remove it
06:41:34 <joeally> in lthan or qsort
06:41:40 <Peaker> deech: lift would convert an IO a to a (MaybeT IO a)
06:41:42 <deech> Peaker: rephrase, Can I use lifting to convert a function that returns Maybe to one that returns MaybeT?
06:41:42 <stroan> either
06:41:52 <stroan> think what would happen if xs was []
06:42:09 <joeally> oh yeah
06:42:18 <Peaker> deech: I *think* that lift is just (fmap return) in many monad transformers, but I'm not sure. Its the case in MaybeT, at least
06:42:34 <joeally> i get stack overflow in qsort though
06:42:39 <mmorrow> xenoblitz: you can kinda get the same effect with phantom types, but you lose the ability to just not handle cases which the GADT's types don't allow, whereas with phantom types it's possible to build those cases if you have the constructors available
06:42:44 <Peaker> deech: By "returns..", do you mean "evaluates to a value of type.."?
06:42:55 <Peaker> deech: or "evaluates to a value of type (Monad m => m ...)" ?
06:43:09 <stroan> joeally: you don't want n to be included in the output of lthan
06:43:15 <mmorrow> castPtr :: Ptr a -> Ptr b; castPtr (Ptr addr#) = Ptr addr#
06:43:25 <stroan> because you have lthan ++ x ++ gthan
06:43:30 <mmorrow> (data Ptr a = Ptr Addr)
06:43:38 <mmorrow> err
06:43:40 <mmorrow> (data Ptr a = Ptr Addr#)
06:43:57 <xenoblitz> mmorrow: I don't understand what you mean unfortunately... let me show you my implementation so far
06:44:25 <deech> Peaker: the former, I already have a somethingThatReturnsAMaybe function and I'd like to reuse it in my example.
06:44:38 <endojelly> Saizan, hmm. the options in that pragma are actually *pre*pended
06:44:58 <xenoblitz> mmorrow: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5038
06:45:06 <Peaker> deech: lift is a bit like return -- it puts a value in a monadic shell that has no effect -- thereby "lifting it" from some internal monadic value to a bigger/outer monadic value
06:45:16 <xenoblitz> mmorrow: i am getting an error with the second casen ow
06:45:18 <xenoblitz> *now
06:45:39 <mmorrow> xenoblitz: so for instance, i can do:
06:45:52 <mmorrow> W (ConstI 42) :: W Bool
06:46:09 <Peaker> deech: your function that returns IO (Maybe a) -- if it returns Nothing -- does it indicate a failure/exception that should stop further execution unless caught?
06:46:18 <endojelly> Saizan, well, okay, disabling all warnings (-w) works... guess that's okay right now
06:46:20 <mmorrow> xenoblitz: so you lose the guarantee that if you get passed a (W Bool), it really is what it claims to be
06:46:35 <mmorrow> xenoblitz: but you can guard against that by not exporting the constructors
06:47:00 <mmorrow> (whereas in the GADT case, (W (ConstI 42) :: W Bool) wouldn't typecheck
06:47:01 <xenoblitz> I was going to export just the functions shown in the above hpaste
06:47:05 <endojelly> make 2>&1|wc -l
06:47:05 <endojelly> 506
06:47:05 <endojelly> make 2>&1  7,02s user 0,66s system 94% cpu 8,078 total
06:47:07 <xenoblitz> I understand
06:47:08 <endojelly> I have a lot to do :/
06:47:09 <xenoblitz> that's good to know
06:47:38 <deech> Peaker: Hmmm, I'll have to think about it a little more .... thanks for your help.
06:47:56 <deech> Peaker: yea
06:48:02 <deech> Peaker: yes
06:48:25 <Peaker> deech: then it should probably use MaybeT IO a instead of IO (Maybe a)
06:48:55 <Peaker> deech: MaybeT IO a is basically the same as IO (Maybe a) that stops binding new IO actions if actions so far evaluated to Nothing
06:49:06 <lilac> @wiki New monads/MaybeT
06:49:06 <lambdabot> http://www.haskell.org/haskellwiki/New_monads/MaybeT
06:49:20 <lilac> ^^ MaybeT
06:49:28 <xenoblitz> mmorrow: do you think that I can still write the simulate function using phantom types though or it is not possible?
06:53:05 <Peaker> when is     lift /= wrap . fmap return ?
06:53:23 <Peaker> I don't know ContT very well, sounds like the craziest monad - is it not true there?
06:53:26 <ivanm> @hoogle wrap
06:53:26 <lambdabot> Control.Applicative WrapArrow :: a b c -> WrappedArrow a b c
06:53:26 <lambdabot> Distribution.Simple.Utils wrapLine :: Int -> [String] -> [[String]]
06:53:26 <lambdabot> Control.Applicative WrapMonad :: m a -> WrappedMonad m a
06:53:32 <ivanm> what's wrap?
06:53:35 <ivanm> @hoogle lift
06:53:36 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
06:53:36 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
06:53:36 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
06:53:48 <Peaker> ivanm: wrap is the monad transformer's constructor
06:53:56 <Peaker> @src ContT
06:53:57 <lambdabot> newtype ContT r m a = ContT { runContT :: (a -> m r) -> m r }
06:54:16 <Peaker> @src ContT lift
06:54:16 <lambdabot> Source not found. There are some things that I just don't know.
06:54:24 <Peaker> @src ContT return
06:54:24 <lambdabot> return a = ContT ($ a)
06:54:33 <ivanm> Peaker: so should it be Wrap? or is it a function that applies the constructor?
06:54:45 <Peaker> ivanm: its just the constructor itself, but there's no way to generalize it
06:54:52 <Peaker> for example, MaybeT's lift is: MaybeT . fmap return
06:54:57 <ivanm> so shouldn't it be Wrap?
06:55:03 <Peaker> what's Wrap?
06:55:06 <Peaker> oh
06:55:09 <ivanm> oh, you're using it as a generic constructor?
06:55:12 <Peaker> yeah
06:55:28 <Peaker> I am thinking maybe one could even generalize all monad transformers?
06:55:30 <Peaker> but probably not
06:57:14 <ivanm> @seen byorgey
06:57:14 <lambdabot> byorgey is in #haskell, #xmonad, #haskell-blah, #haskell-overflow and #haskell-in-depth. I last heard byorgey speak 19h 11m 33s ago.
06:57:34 <ivanm> @ask byorgey OK, was that "strange dream" blog post of yours meant to make sense? :s
06:57:35 <lambdabot> Consider it noted.
06:57:52 <Peaker> you could maybe generalize a bunch of them:  data MonadT t m a = MonadT { runMonadT :: m (t a) }  instance MonadTrans MonadT where lift = MonadT . fmap return   instance (Monad m, Monad t) => Monad (MonadT t m a) where return = MonadT . return . return ; x >>= f = ??
06:58:39 <Peaker> Might need a sub-class of Monad restriction on the "t" that can do only the bind for us (we can do everything else)
06:58:45 <xenoblitz> Can someone help me with this error? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5039
06:59:06 <Peaker> so defining a monad transformer would only require defining the transformer's bind. The lift and return would be the same as the monad's normal ones
06:59:53 <lilac> ivanm: i assumed it was his subconscious mind reeling at the notion of a fixed-but-unspecified-precision Int ;-)
07:01:05 <Peaker> xenoblitz: can you remove all irrelevant code that is not necessary to reproduce your problem?
07:01:26 <xenoblitz> Peaker: yes sorry I shall
07:02:06 <xenoblitz> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5040
07:02:40 <lilac> xenoblitz: your function 'simulate' is not of type 'W a -> a'
07:03:16 <lilac> xenoblitz: since it's not of type 'W String -> String', for instance.
07:03:35 <Peaker> simulate (W (ConstB True) :: W Int) -- boom
07:04:02 <lilac> xenoblitz: you need W Int to have different constructors from W Bool if you want that sort of thing to work
07:04:11 <xenoblitz> Peaker: yeah I am starting to understand better what mmorrow meant sorry... some things are still a bit hazy about phantom type
07:04:14 * lilac suggests using a GADT
07:04:24 * Peaker has never needed a GADT yet
07:04:32 <xenoblitz> lilac: if you see before that there is a GADT implementation
07:04:46 <xenoblitz> Peaker: see the hpaste on the same page
07:05:08 <xenoblitz> I am just wondering if it is possible to achieve the simulate function using phantom types but my guess is that its not possible at all?
07:06:05 <lilac> xenoblitz: well, you could say 'data W a = Const a | Not (W a) | ...'
07:06:10 <xenoblitz> Peaker, lilac: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5035 ... I am trying to see if it is possible to achieve the same effect using phantom types
07:06:22 <lilac> but that'd not be a phantom type any more
07:06:35 <Peaker> xenoblitz: I think maybe you want an open type sum here rather than a closed-one?
07:06:53 <Peaker> xenoblitz: I think Phantom types typically go hand-in-hand with GADT's?
07:07:31 <xenoblitz> Peaker: if you refering the Sum, that was added by mmorrow :P I don't know what he had in mind
07:07:42 <xenoblitz> Peaker: I am told that they are orthogonal
07:07:52 <lilac> xenoblitz: the trouble with not using a GADT is that non-generalized ADTs are ambivalent of the contained type in some sense
07:08:14 <lilac> so if W Bool has a ConstB Bool constructor then either W Int has a ConstB Int constructor or a ConstB Bool constructor
07:08:20 <lilac> and you don't want either of those possibilities
07:08:42 <Peaker> xenoblitz: no, I'm referring to your use of an ADT -- when you might be better off using a type-class/function-record and an open type world
07:08:55 <lilac> xenoblitz: it's possible you can do this with a type class constraint
07:09:05 <Peaker> I think OO sometimes wrongfully encourages open type sums, and that ADT's sometimes wrongfully encourage closed-type-sums
07:09:21 <xenoblitz> Peaker, lilac: yeah that I know... I'm experimenting with phantom types for my work
07:09:44 <joeally> okay guys this is my final quicksort
07:09:46 <joeally> qsort [] = []
07:09:46 <joeally> qsort [x] = [x]
07:09:46 <joeally> qsort (x:xs) = qsort ([z |z<-xs ,z<=x]++[x]) ++ qsort [z |z<-xs ,z>x]
07:09:50 <joeally> hows that
07:09:56 <lilac> xenoblitz: for what it's worth, in keeping with your design metaphor here, i'd rename Ifte to Mux and Equ to XNor...
07:10:21 <lilac> joeally: do you need to include [x] in the first qsort?
07:10:34 <joeally> i tried taking it out
07:10:39 <joeally> but i got stack overflow
07:10:47 <zachk> check it out http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5041#a5041 debrujin cycles . now is there a way to do them in like 2 lines of haskell using lambdabot? :-D
07:10:53 <lilac> joeally: i mean in the third line
07:11:02 <Peaker> xenoblitz: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5034#a5042
07:11:10 <joeally> oh
07:11:14 <xenoblitz> Peaker, lilac: so the bottom line is that given phantom types its not really possible to obtain the function I need like I did when implementing the same function using GADTs?
07:11:20 <xenoblitz> Peaker: let me see
07:11:20 <joeally> then the pivot would be excluded
07:11:26 <lilac> joeally: you know that x is between the first partition and the second, so you could rewrite as ... = qsort (...) ++ [x] ++ qsort (...)
07:11:39 <joeally> oh yeah
07:11:39 <xenoblitz> joeally: its "sorted" so you don't need to resort it
07:11:50 <Peaker> xenoblitz: I think you need to prove to the compiler the relationship between the data constructor (ConstB vs ConstI) and the phantom type (Bool vs Int)
07:11:54 <joeally> chears lilac
07:11:55 <lilac> xenoblitz: if it's possible, i think you'd need some type class hackery and it wouldn't be pretty
07:12:01 <zachk> whats a phantom type?
07:12:18 <lilac> zachk: a type that doesn't appear on the RHS of the type definition
07:12:37 <lilac> zachk: type ST s a = (... something not involving s ...)
07:12:58 <xenoblitz> Peaker: yeah that's essentially part of the definition I used earlier using GADTs
07:13:08 <xenoblitz> Peaker, lilac: thanks for your help guys
07:13:22 <Peaker> xenoblitz: why do you prefer the non-GADT?
07:13:36 <xenoblitz> Peaker: its not a matter of prefer... I'm comparing and constrasting :)
07:13:54 <xenoblitz> Peaker: I think the GADT is really elegant as things go
07:14:11 <xenoblitz> Peaker: was just wondering: can I do it with phantom types?
07:14:14 <lilac> joeally: with that change made, your second line is redundant, since the third line on a one element list reduces to "qsort (x:[]) = qsort [] ++ [x] ++ qsort []"
07:14:36 <joeally> oh right
07:14:40 <joeally> i'll try it
07:14:45 <joeally> thanks lilac
07:14:45 <Peaker> xenoblitz: the GADT is not a phantom type?
07:14:53 <Peaker> xenoblitz: (the type variable of the GADT, that is)
07:15:10 <lilac> joeally: one other thing you might want to consider is using 'partition' instead of a list comprehension, so you only walk the list once instead of twice
07:15:15 <joeally> yup
07:15:24 <xenoblitz> Peaker: well yes I guess it is
07:15:25 <lilac> but you've already arrived at the "canonical" "quicksort" implementation in haskell
07:15:32 <joeally> i have learned about partition yet
07:15:43 <joeally> yeah i just read it now
07:15:56 <joeally> it uses filter instead of a list comprehension
07:16:09 <joeally> it is probably a bit easier to read
07:16:37 <lilac> technically it's not a quicksort implementation because the quicksort algorithm is an in-place sorting algorithm on arrays and that is not, but...
07:16:57 <joeally> oh
07:17:01 <Berengal> > let qsort [] = []; qsort (x:xs) = let (l,g) = partition (<=x) xs in qsort l ++ [x] ++ qsort g in qsort [1,5,4,6,8,5,5,4,3,4,5,6,8,5,34,5,6,8]
07:17:03 <lambdabot>   [1,3,4,4,4,5,5,5,5,5,5,6,6,6,8,8,8,34]
07:17:19 <lilac> nonetheless, lots of people call that algorithm quicksort, so you're in good company ;-)
07:17:48 <xenoblitz> Peaker: I guess what Cheney and Hinze say in First-Class Phantom Types as the disadvantage of common phantom types to GADTs is this very case... but I am not sure I am making false connections: "while such encodings (phantom types) guarantee that only well-formed data can be constructed, they do not permit type-safe deconstruction without additional tagging and run-time checks
07:18:15 <xenoblitz> if anyone can clarify it would be awesome :)
07:20:30 <lilac> xenoblitz: sounds about right. i think they're saying, via encapsulation you can enforce (by construction) that W Int does not use W Bool, but the type system can't know that, so when you pattern match, it won't tell you that the ConstB constructor implies the type is W Bool
07:20:53 <lilac> actually, the type system could know that in some cases, but it in practice does not ;-)
07:22:15 <xenoblitz> so very very basically, common Phantom Types allow safe construction and guided deconstruction and GADTs allow safe construction and deconstruction
07:22:46 <lukeo05> So, totally got my end of first year functional programming exam in an hour. What 1 thing do you think I should know?!
07:22:54 <p_l> ...
07:23:25 <lilac> lukeo05: whichever one thing comes up most :)
07:23:57 <lilac> (sadly computing that will take too long)
07:24:11 <bremner> lukeo05: tail recursion, if using a strict language
07:25:13 <lukeo05> awesome. all set now! :)
07:26:56 <Berengal> I'd say lists, but that might just be me...
07:28:12 <bremner> tail recursion on lists!
07:28:29 <pozic> fib!
07:28:33 <Botje> the monomorphism restriction!
07:30:09 <bremner> strictness!
07:30:36 <Botje> tying the knot!
07:31:09 <pozic> Why functional programming is superior to everything else!
07:31:20 <tetha> catamosphisms, clearly
07:31:29 <pozic> That last one is totally a real academic question.
07:31:32 <lukeo05> Right... better go. Hopefully I get modules next year with haskell so I can come back here. I'd of failed without this place!
07:34:20 <tetha> why do you need courses to keep learning haskell?
07:35:36 <demolithion> yeah you should skip courses to learn haskell :>
07:35:49 <tetha> heh
07:35:58 <tetha> depending on the course, you might learn more by learning haskell
07:36:02 <tetha> :>
07:36:11 <demolithion> i agree :)
07:36:59 <fasta> My stack traces show that certain functions call each other, except in the source code they don't. I just parse in a value at some location. This location is the only place in the code which constructs the value. Then this value gets processed using a slightly complicated recursive function, but it is not mutually recursive in the multi-level way as the stack trace shows it. Moreover, I expect the function to terminate after one go, but in fact it goes into an
07:36:59 <fasta> infinite loop (which is consistent with the stack trace).  The function in question does go to the "end" (it's a monadic function), when I put in error "All ok", it does reach it and it does work before it.
07:37:12 <fasta> So, in short, the impossible seems to be happening.
07:37:16 <pejo> Is anyone else having problems pulling from code.haskell.org?
07:37:35 <quicksilver> fasta: "stack" trace?
07:37:39 <quicksilver> fasta: this is haskell, after all :)
07:37:41 <fasta> quicksilver: the xc output
07:38:22 <quicksilver> does it show where things are forced rather than where they are lexically evaluated?
07:38:30 * quicksilver has never tried it
07:38:35 <quicksilver> so I may not be much heklp/
07:39:46 <fasta> quicksilver: In all the examples until now it's the latter.
07:42:07 <Axman6_> anyone have any recommendations for a text editor for windows that works well with haskell, and isn't hard to use? (i'm suggesting notepad++, but i don't know of anything else)
07:42:28 <Jedai> Axman6_: emacs !
07:42:35 <tetha> I'd argue that learning vim or emacs is one of the better decisions you can make in your programming career
07:42:36 <Jedai> Axman6_: kidding...
07:42:40 <tetha> even if it takes some time
07:42:42 <Axman6_> i was going to say...
07:42:58 <Axman6_> tetha: considering she doesn't want to be a programmer...
07:43:15 <Jedai> Well really Emacs would be my choice but I understand those that don't want to bother
07:43:31 <tetha> Axman6: doesnt editing haskell code make you a programmer?
07:43:40 <Axman6> basically, anything with haskell syntax highlighting would be good
07:43:59 <Axman6> tetha: not when it's only a requirement for a degree
07:44:28 <Jedai> Notepad++ should be perfect then, it's really nice, easy to use from the beginning and not too lame for serious programming
07:44:44 <blackh> Axman6: jEdit does do Haskell syntax highlighting but not indenting and it's really easy to use
07:45:09 <Axman6> ok, i'll recommend that too, thanks blackh :)
07:45:09 <Jedai> Axman6: What kind of degree require you to know Haskell but isn't a CS degree ?*
07:45:18 <Axman6> a science one
07:45:25 <Axman6> actually, and engineering one
07:45:49 <mreh> :t (>>=)
07:45:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:45:53 <DarthArachides> Jedai: I studied haskell in my math degree
07:46:27 <Jedai> DarthArachides: Yeah but was it a required unit ?
07:46:37 <DarthArachides> Jedai: yes
07:46:54 <DarthArachides> Jedai: but to be fair, our course was a bit *interesting*
07:46:58 <Jedai> DarthArachides: Wow, what was your school ?
07:46:59 <alexsuraci> would Template Haskell be the best route to writing a compilier from a language to Haskell?
07:47:46 <mreh> can someone give me an example of a function (a -> IO b)?
07:48:05 <bremner> mreh: print
07:48:07 <Jedai> mreh: putStr :: String -> IO ()
07:48:13 <bremner> b=()
07:48:26 <fasta> mreh: undefined
07:48:35 <Jedai> fasta: ...
07:48:48 <bremner> :t error
07:48:49 <lambdabot> forall a. [Char] -> a
07:49:10 <fasta> Jedai: ...
07:49:43 <DarthArachides> Jedai: I studied in India, unlikely that you have heard of the place.
07:49:57 <quicksilver> DarthArachides: I have heard of India :P
07:50:00 <mreh> they have computers in India?
07:50:10 <bremner> mreh: readFile is more interesting example.
07:50:14 <bremner> :t readFile
07:50:15 <lambdabot> FilePath -> IO String
07:50:22 <mreh> thanks all
07:51:08 <mreh> so (>>=) can only combine actions of the same monad type?
07:51:16 <mreh> :t (>>=)
07:51:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:51:18 <Jedai> mreh: Right
07:51:34 <mreh> uhuh
07:52:01 <Jedai> mreh: it combine an action from a monad m and a fonction that results in an action in m and returns a combined action in m
07:52:08 <Peaker> @hoogle Bool -> IO () -> IO ()
07:52:37 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
07:52:37 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
07:52:37 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
07:52:40 <mreh> @src (>>=)
07:52:40 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:53:35 <mreh> when = "if ..."
07:53:39 <mreh> and unless is the oposite
07:53:39 <Peaker> mreh: Monads and Applicatives support "Sequencing" of computations.  Monad sequencing does 2 things -- it allows the latter function to use the result[s] of the previous function (combines values), and it sequences together the effects, left-to-right (combines the actions)
07:53:58 <DarthArachides> mreh: yes! and amazingly, the also have internet these days.
07:54:15 <Peaker> mreh: Applicative Sequencing is pretty much the same, except the latter action does not get to see the previous action result, only to feed its result function a result argument
07:54:20 <mreh> I remember all those third world jokes
07:54:26 <pejo> Igloo/dcoutts, do you have the power to kick the webserver  for code.haskell.org?
07:54:38 <mreh> @quote monads
07:54:39 <lambdabot> lispy says: "monads are like condoms, without them, it's unsafePerformSex"
07:54:44 <mreh> @quote monad
07:54:45 <lambdabot> Dzlk says: you can make the Id monad somewhat better behaved by wrapping it in SuperegoT.
07:54:47 <quicksilver> fasta: after doing some research and having a chat with some smart people, it's probably a bug destroying or moving annotations around.
07:54:59 <quicksilver> fasta: you coudl submit a bug if oyu like.
07:55:13 <fasta> quicksilver: thanks a lot for saying so!
07:55:17 <Jedai> mreh: Note that (>>=) is different for each monad
07:55:40 <fasta> quicksilver: at the same time: "I am sure my boss would like to hear exactly that."
07:56:03 <quicksilver> fasta: the xc code relies on the cost centres being correct, a bug in the way the optimiser tries to preserve the cost centres can lead to odd looking traces.
07:56:38 <fasta> quicksilver: oh, so, only the stack traces are odd. The code executes correctly, still?
07:56:56 <pejo> quicksilver, are the cost centres guaranteed to stay in place if optimization is turned on?
07:57:04 <quicksilver> pejo: you mean, turned off?
07:57:06 <fasta> quicksilver: which still means there is another problem in my code. I still have some ideas where the issue might be lurking.
07:57:19 <quicksilver> fasta: I think so, yes.
07:57:28 <mreh> so all this "monads are like..." is all nonsense
07:57:35 <pejo> quicksilver, if you turn the optimizer off it's not going to move them around, I hope.
07:57:43 <quicksilver> pejo: right.
07:57:52 <quicksilver> the optimizer can duplicate code and eliminate code.
07:58:03 <quicksilver> in that case, obviously care has to be taken to keep the cost centres sane.
07:58:09 <pejo> quicksilver, yeah, that was kind of my idea. case-of-case transformation for example.
07:58:15 <quicksilver> see, for example, http://hackage.haskell.org/trac/ghc/ticket/948
07:59:41 <Jedai> mreh: The explanations of monads by comparison are most of the time correct but partial, they only works for certains monads
08:00:00 <mreh> @quote Gahhh
08:00:00 <lambdabot> Gahhh says: monads are usually a personal experience.
08:00:18 <mreh> I believe in a personal moand
08:01:15 <tetha> I figured grasping monads is like learning to throw bo-shuriken. you try to and fail everyday for a year, and then eventually it will just click and seem so damn obvious you don't know how it was unclear somewhen
08:01:16 <Jedai> mreh: Generally you have two different visions of the monads, as containers or as computations, they can help understand some monads but won't give you a definitive understanding of what a monad really is
08:02:02 <stroan> Jedai: do you know of any particularly good description? irregardless of accessibility
08:02:02 <mreh> haha, the more you explain it, the more is sounds like Nirvana
08:02:12 <mreh> or Tao
08:02:33 <tetha> if you want more confusion, my bachelor thesis mentor said: monads just allow you to override function composition and do crazy things in there
08:02:59 <Berengal> Monads are like cars
08:03:03 <mreh> hahaha
08:03:08 <mreh> here we go again
08:03:10 <C-Keen> monads are like buritos
08:03:22 <tetha> very nice, car analogies :)
08:03:29 <mreh> i am from England
08:03:32 <tetha> so I just have to restart my monad to debug it
08:03:39 <mreh> the Burito is alien to me
08:04:44 <mreh> so in (a -> IO b), b is the type of the container
08:05:01 <mreh> but not the result of the evaluation
08:05:15 <Jedai> stroan: Generally I don't believe any description is better than the dry mathematic description with the triplet of (monadtype, return, bind) and monad rules
08:05:29 <quicksilver> mreh: if you want the container analogy, IO is the container.
08:05:33 <quicksilver> mreh: b is the contents.
08:05:51 <stroan> Jedai: Yeah, but any particularly good description of that and its uses
08:06:12 <Jedai> stroan: It don't give you any appreciation for what it's useful for though, so I supplement that with "All about monads" which is nothing but a catalog of the classic monads (and a bit about monad transformers)
08:07:11 <Jedai> stroan: There is nothing fancy in the mathematic description (which is why I called it dry)
08:07:26 <Peaker> Looking at Reactive's implementation, I wonder why conal put a serializer with a clock
08:07:58 <Jedai> stroan: A monad is just a triplet of a type and two functions traditionally called return and bind, which follows three rules
08:08:46 <mreh> is do a function or syntax?
08:08:54 <gnuvince> syntax
08:09:01 <tetha> even though the name 'return' tends to confuse imperative programmers
08:09:17 <SamB_XP_> @undo do y <- f x; print y
08:09:17 <lambdabot> f x >>= \ y -> print y
08:09:47 <mreh> a >> b = a >>= \_ -> b
08:09:48 * dcoutts_ notes that Prof Knuth is currently in the office opposite
08:09:50 <dcoutts_> why don't people tell me these things in advance?
08:09:51 <Jedai> 1. (return x) >>= f == f x
08:09:51 <Jedai>    2. m >>= return == m
08:09:51 <Jedai>    3. (m >>= f) >>= g == m >>= (\x -> f x >>= g)
08:09:59 <gnuvince> tetha: I'm not sure why "return" was selected when it has such a strong meaning in most other languages.
08:10:20 <Berengal> @. pl undo do y <- f x; print y
08:10:21 <lambdabot> print =<< f x
08:10:22 <gnuvince> I think RWH suggests that "inject" would've been a better choice.
08:10:22 * bremner finds the Real World Haskell chapter on monads to be ok for an intro
08:10:41 <mreh> that book is so large
08:11:25 <athos> bremner: well, IIRC it heavily depends on previous chapters
08:11:25 <Jedai> stroan: Once you know that, you know everything that makes a given triplet a monad, it just remains to learn about the classic monads, try to use them and learn (experience seems to be the only way) to recognize monads in your code
08:11:26 <mreh> too large in proportion to content
08:11:32 <bremner> mreh: yeah, but you don't need most of the intervening chapters to read the Monad one. Just typeclasses IIRC
08:12:19 <athos> bremner: IMHO it's best to read the previous parser chapters to be enlightened by the monad chapter
08:12:23 <bremner> athos: I made lecture notes for 6 hours of lectures, starting with types and syntax and ending with the monad chapter
08:13:00 <Berengal> Writing a parser is a great way to understand monads
08:13:07 <athos> yup
08:13:08 <bremner> yeah, maybe
08:13:15 <stroan> Jedai: thanks. I guess it's just going to be a case of writing application and try to figure out how to do these things
08:13:21 <stroan> applications*
08:13:26 <Berengal> Doesn't have to be complicated, just something simple like String -> (a, String)
08:14:34 <stroan> Berengal: I was thinking that actually. I'm trying to find a minimal language to implement.
08:14:50 <Berengal> stroan: A minimal lisp is fine
08:15:45 <stroan> A very good idea. I took a course on compiler design last year, so the parsing and interpretting won't be the stumbling block, just haskell ;)
08:16:01 <Berengal> stroan: Or a very simple functional-ish language: expr = letExpr | var | val | addOp | mulOp
08:16:27 <Berengal> letExpr = "let" var "=" expr "in" expr
08:17:02 <Peaker> I don't like monadic parsers
08:17:17 <Peaker> I don't like parsers in general, though :-0
08:17:39 * SamB_XP_ mumbles something about how cute pitbulls are
08:17:41 <Peaker> niche problem that became so important because of a failure to create code editors :)
08:17:42 <Berengal> Peaker: I used to not like parsers in general until I learned of monadic parsing...
08:18:05 <Peaker> Berengal: I think parsing should be relegated back into the niche-problem territory where it belongs :)
08:18:28 <stroan> Berengal: was thinking Godel System T
08:18:30 <Berengal> Peaker: Well, they're not particularly _interesting_, I'll give you that
08:18:35 <Botje> parsec makes parsing FUN(ctional) again
08:18:46 <SamB_XP_> Botje: eh ...
08:18:51 <SamB_XP_> it's kinda lousy!
08:18:59 <Peaker> Hmm... type b :--> a = (Sink b, a)      And Sink b = b -> IO ()     -- that's a weird type
08:19:19 <SamB_XP_> you have to jump through hoops to keep it from going down the wrong alternative!
08:19:20 <Peaker> the doc says: -- | An @a@ that's fed by a @b@ -- but it seems the a is not "fed" by anything
08:20:14 <Botje> SamB_XP_: didn't notice much of it :)
08:20:33 <Baughn> reactive? b would be an aaction to add an event occurence at the current time; a's the event.. yes?
08:21:05 <SamB_XP_> ewww IO
08:21:21 * Badger inputs SamB_XP 
08:21:23 <Baughn> SamB_XP: It's LegacyAdapters. The module is specifically to interact with IO. ;)
08:21:31 * Badger outputs spaghetti
08:21:33 <Baughn> *exists specifically to
08:21:40 <SamB_XP> Baughn: oh
08:22:00 <Baughn> I can't make it work, though
08:22:06 <SamB_XP> sounds like it needs better docs
08:22:16 <Baughn> First it needs to /work/
08:22:21 <fasta> In foo = do undefined; let !a = trace "hi" ();undefined, why is "hi" being printed?
08:22:40 <Baughn> There are ghc bugs (possibly), and reactor bugs (probably) preventing me from using this, and conal is a poor starving ex-student
08:22:47 <Baughn> Someone should hire him to work on FRP
08:32:28 <Jedai> fasta: That depends on the monad (on (>>=) strictness more precisely)
08:32:43 <Peaker> Baughn: ex-MS-research guy, too
08:32:56 <Peaker> Baughn: I'm reading Reactive's code to see what breaks your example
08:33:19 <Peaker> Baughn: its built very elegantly in a layered manner, but that has the disadvantage that you actually have to understand many layers to understand just the part you want..
08:34:27 <Baughn> Peaker: I noticed. :/
08:34:31 <Baughn> Peaker: Currently doing the same thing
08:35:33 <Baughn> Peaker: And, of course, chances are very good it's a ghc issue - given how it behaves differently under -threaded
08:35:45 <Baughn> Peaker: I tried running it under GHC head, though. No difference.
08:36:00 <Peaker> Baughn: btw, do you understand the code of race?
08:36:12 <Baughn> Peaker: Oh, sure. Clever, but it's the simplest part.
08:36:29 <Peaker> I don't understand the part that supposedly does this: "Importantly, it also sets itself up to be retried if the unamb value is accessed again after its computation is aborted."
08:36:44 <Peaker> Baughn: I don't see how "myThreadId >>= killThread" could do anything desirable
08:36:59 <Baughn> Peaker: myThreadId >>= killThread kills the current thread, obviously
08:37:11 <Peaker> Baughn: look at the code in Unamb.hs/race
08:37:17 <Baughn> I have
08:37:21 <Baughn> Peaker: But it's an async. exception, so the kill doesn't go through until unblock is called
08:37:22 <Peaker> Baughn: After that, it does: unblock (race a b)
08:37:51 <Peaker> Baughn: I tested  myThreadId >>= killThread    and it seems it just hangs
08:37:56 <Peaker> Baughn: (when you're blocked)
08:38:02 <kyevan> Mmm.
08:38:08 <Baughn> Peaker: You need to actually unblock it
08:38:09 <Peaker> Baughn: OR it does kill the thread, which I guess that denotationally is equivalent
08:38:24 <kyevan> One thing to be said for haskell, I think "map (\x -> chr ((ord x) `xor` 0xFF))" is the shorted mangle/demangle I've ever written :J
08:38:35 <Peaker> Baughn: only a thread can unblock itself -- so  block $  myThreadId >>= killThread      -- is a deadlock because killThread waits
08:39:06 <Peaker> @pl (\x -> chr ((ord x) `xor` 0xFF))
08:39:06 <lambdabot> chr . (`xor` 255) . ord
08:39:20 <Baughn> Peaker: Oh, right you are..
08:39:23 <Peaker> chr . xor 255 . org    will also work (xor is commutative)
08:39:27 <Baughn> That's funny
08:39:52 <Peaker> Baughn: so that puzzled me for a while -- but also, even if it did send an async exception - it would die immediately afterwards in the unblock, wouldn't it?
08:40:09 <Peaker> kyevan: map (chr . xor whatever . ord)
08:40:25 <Baughn> Peaker: Hang on, I need to do a few tests
08:40:51 <Peaker> Baughn: Also, how would it accomplish:L "Importantly, it also sets itself up to be retried if the unamb value is accessed again after its computation is aborted."
08:41:15 <kyevan> Hehe, I wrote this while being bounced around on a highway, give me some slack :P
08:41:28 <Peaker> does takeMVar have an implicit unblock in it?
08:42:36 <Baughn> Peaker: You really should ask conal about this. You're right that it's odd, but I'm just as befuddled as you
08:42:53 <Baughn> Peaker: And I hadn't quite figured out the definition of unamb either. ;)
08:44:10 <Peaker> Baughn: Assuming race works - I understand unamb
08:44:47 <Peaker> Baughn: amb and unamb are equivalent, except unamb can unsafePerformIO on amb because its guaranteed that the actions have denotationally equivalent results
08:45:02 <Baughn> Peaker: Mind you, a quick print shows that neither unamb nor (obviously) race are actually used in my troublemaker
08:46:11 <Peaker> Baughn: yep, I think they're only used when multiplexing events
08:46:32 <Peaker> ghc needs a proper debugger!
08:47:09 <Baughn> Peaker: But.. okay. When race kills itself (never mind that that /fails/, deadlocking instead), it sets up a new invocation of race to be executed after the thread dies
08:47:36 <Peaker> Baughn: I don't get that -- even if it didn't deadlock, it'd die in the unblock before it had a chance to do anything
08:47:43 <Baughn> Peaker: When using unsafePerformIO to execute an action, killing one thread that's executing it does not necessarily mean the action's execution will never continue
08:50:41 <Peaker> Baughn: it seems like takeMVar does an implicit unblock
08:50:46 <Peaker> Baughn: that usleep, for example, doesn't
08:51:03 <Peaker> oh wait, maybe usleep and the likes are not allowed in forkIO?
08:52:22 <Baughn> They should be
08:52:46 <Baughn> Mind you, using usleep instead of threadDelay is a bad idea, but.. still.
08:52:49 <Peaker> hmm.. it appears that all "blocking" operations unblock?
08:52:58 <TomMD> FWIW, my tests on takeMVar make me think its unblocking as well.
08:52:59 <Peaker> blocking as in waiting, unblock as in Control.Exception.unblock
08:53:16 <Peaker> threadDelay too seems like it unblocks
08:53:34 <Peaker> I guess the idea is to force block sections to be atomic and avoid deadlocks
08:53:47 <Peaker> but I don't think I saw this in the documentation
08:54:06 <Peaker> Baughn: anyway, since its not in your thingie, I'll try to sprinkle prints over reactive instead
08:54:25 <Baughn> Peaker: You do that. I'll.. do that too.
08:54:51 <fasta> For a language designed for concurrency, having to guess the semantics of MVars is not a good thing.
08:55:03 <Peaker> can darcs tell me if I have local unpushed changes easily?
08:55:08 <Baughn> darcs whatsnew
08:55:14 <Baughn> Or.. no
08:55:27 <Baughn> Well, darcs send/push will prompt you
08:55:32 <Peaker> fasta: I think its the semantics of block/unblock in general.. Everything that blocks execution unblocks exceptions, iiuc
08:56:01 <Baughn> fasta: You're not really supposed to use block/unblock in application-level code, either
08:56:41 <fasta> Baughn: I was referring to the exported public MVars API.
08:56:47 <Peaker> Baughn: if you use forkIO in your application code, you're likely to need block/unblock too
08:57:05 <fasta> Baughn: at least over a year ago it was impossible to figure out what it does, unless you experiment with it.
08:57:24 <Baughn> Peaker: I've never had to, but I don't throw exceptions willy-nilly either
08:57:26 <Peaker> fasta: at least experimenting is easy :)
08:57:36 <Peaker> even killThread throws though
08:57:54 <Baughn> Right, but then that's what finally/onError/bracket are for
08:59:31 <quicksilver> I think the mvar semantics is pretty clear, excluding asynchronous exceptions.
08:59:42 <quicksilver> I don't really use asynch exceptions so they don't really bother me often.
08:59:51 <quicksilver> but definitely, they make everything gnarly.
09:00:20 <fasta> Can any tool show why a certain function gets called more than once?
09:01:20 <quicksilver> fasta: the profile will show you where it's called from most often
09:02:38 <Peaker> Baughn: runE is not even calling runR
09:03:24 <Baughn> Peaker: Yep. Do you happen to know where the Functor instance for Event is?
09:04:00 <Peaker> Baughn: PrimReactive.hs:187
09:05:38 <fasta> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/visual-graphrewrite looks interesting, and it even compiles, but how should one use it?
09:08:06 <doserj> fasta: doesn't look finished: http://github.com/zsol/visual-graphrewrite/blob/c2047c227b6ccee1bf05b2a66c007e21c1bf3fd5/README
09:10:21 <teolicy> Hi. What's the difference between an Array and a List?
09:10:41 <kpreid> lots
09:10:47 <kpreid> why do you ask?
09:11:04 <kpreid> if you give some context I can perhaps tell you the relevant difference
09:11:16 <kpreid> (assuming by List you mean [])
09:11:37 <Peaker> Baughn: the thread block is in the forcing of the bt argument in runE, brb
09:12:45 <fasta> quicksilver: I don't get a profile, because the program does not terminate and I do C-c C-c
09:13:52 <frwmanners> fasta: ghci breakpoints help?
09:13:57 <Peaker> fasta: windows?
09:14:12 <fasta> Peaker: no, Linux.
09:14:31 <fasta> frwmanners: usually the debugger does not help
09:14:47 <frwmanners> true
09:14:55 <Peaker> Baughn: oh, you're using the joinE
09:14:57 <fasta> The debugger extensions written by Peter <???> seem quite nice, though.
09:16:15 <Peaker> Baughn: If you avoid using the Monad instance of event then that resolves one problem
09:16:22 <quicksilver> fasta: ah, and you dont' know how to make the program terminate because you don't know where it is getting stuck?
09:16:22 <Peaker> Baughn: I think the Monad instance of events is knowingly broken
09:16:32 <fasta> quicksilver: right
09:16:58 <fasta> quicksilver: well, I can make it terminate after a gazillion iterations with unsafeperformio
09:17:09 <quicksilver> fasta: it's a dirty hack, but how about running your program in a separate thread
09:17:25 <quicksilver> and have the main thread just exit cleanly after a fixed time
09:17:30 <quicksilver> that should get you a profile I believe.
09:17:35 <Baughn> Peaker: I did get that feeling. Meanwhile, my other (more problematic) testcase does use race, so let me see..
09:17:48 <fasta> quicksilver: I will try tomorrow. Thanks
09:18:31 <Peaker> Baughn: well, your (>>=return) thing proves that event's monad instance is broken -- but that's ok, because it's not that useful
09:19:40 <Baughn> Peaker: More, it proves that joinE is broken
09:21:17 <frwmanners> Baughn: if you're playing with reactive, what structure of Time are you using?
09:22:13 <quicksilver> Baughn: "broken" in what case?
09:22:31 <quicksilver> Baughn: anything worse than non-determinism for simultaneous events?
09:22:45 <quicksilver> because I don't care what order simultaneous events arrive in, mostly.
09:22:50 <quicksilver> but anything worse than that, would be bad.
09:23:28 <Baughn> frwmanners: TimeT
09:23:51 <Baughn> quicksilver: It causes GHC to detect nonexistent deadlocks under the threaded runtime
09:24:03 <Baughn> quicksilver: Or, in 6.10.2, just all the time
09:24:10 <Baughn> quicksilver: Using +RTS -I0 "cures" it.
09:24:15 <Baughn> I'd say it's bad.
09:24:28 <Baughn> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5018 <-- Oh, and testcase
09:25:04 <quicksilver> surely that's got to be a compiler/RTS bug
09:25:07 <quicksilver> not a joinE bug
09:25:26 <Baughn> quicksilver: It's hard to tell, considering how reactive is implemented
09:25:39 <Baughn> quicksilver: I don't believe unsafePerformIO has semantics that can be considered buggy
09:25:55 <Twey> U.
09:25:55 <leimy> I'm a little confused by how a pure function like (unlines . lines) can force I/O to be sequenced linewise with interact.
09:26:16 <leimy> I thought the only way to really sequence I/O was via the imperative "bindy" stuff inside the I/O monad.
09:26:17 <Twey> leimy: Because it's lazy
09:26:49 <Twey> It's not sequenced for sure, but every time you read an item from the list, you have to have read a corresponding line of input
09:27:08 <leimy> hmmm
09:27:10 <Twey> In current implementations, that means that it reads a line at a time
09:27:26 <leimy> meaning I should not rely on the fact that that reads a line, and then joins that line back in with other lines...
09:27:39 <Trowalts> I have a function that works but is teribly ineficient, I know what should be done to simplify it, but have no idea how to write it in haskell
09:28:15 <Twey> leimy: Input doesn't really work like that, though it may seem to in a shell
09:28:22 <Twey> Input and output are separate streams
09:28:38 <leimy> well "interact" ties them to input and output streams
09:28:39 <leimy> so
09:28:55 <Trowalts> the function is, hasFactor p = take 1 [z | z <- [2..p-1], p `mod` z == 0] but it doesent have to go all the way to [2..p-1], it only needs to go until [2.. while z^2 < p]
09:28:57 <leimy> interact (unlines . lines) -- basically an echo command
09:29:19 <inimino> ...both of which may be buffered
09:29:45 <leimy> Well I guess it's that way with line buffering.
09:29:49 <Peaker> leimy: lazy I/O indeed makes evaluation invisibly sequence IO actions -- but its considered "bending" rather than breaking the rules, because you're not supposed to be able to tell the difference between hGetContents getting the entire file now and it doing the getting line-by-line per evaluation
09:29:53 <Trowalts> well thats how I'm trying to express what I need..
09:29:54 <inimino> @type interact
09:29:56 <lambdabot> (String -> String) -> IO ()
09:30:26 <leimy> @src interact
09:30:27 <lambdabot> interact f = do s <- getContents; putStr (f s)
09:31:18 <leimy> So I guess my concern is, can I do things with interact that seem to force linewise input and expect it to work "portably" or reliably in future GHC releases? :-)
09:31:21 <leimy> it sounds like "probably not"
09:31:22 <Peaker> @. pl undo do s <- getContents; putStr (f s)
09:31:22 <lambdabot> putStr . f =<< getContents
09:32:05 <Trowalts> ie, I need to put a condition onto the range of [2..] so the list comprehension will brake, anyway this can be done
09:33:08 <joeally> what does this mean
09:33:09 <joeally> Couldn't match expected type `[a]'
09:33:09 <joeally>            against inferred type `[a1] -> [a1]'
09:34:01 <leimy> it means that you're providing a function where it's expecting a list
09:34:26 <MyCatVerbs> Trowalts: what condition? hpaste your code please?
09:34:31 <Trowalts> kk
09:34:35 <MyCatVerbs> @where hpaste
09:34:35 <lambdabot> http://hpaste.org/
09:37:25 <Trowalts> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5043#a5043
09:38:00 <Trowalts> with ranfe-> range and why -> way, sorry about that
09:40:56 <Trowalts> basicly I dont need to do the check for factors of p ( p `mod` z ) if z^2 is greater than p (cos then its imposible to find a factor in anycase)
09:41:03 <doserj> z <- [2..isqrt p], where isqrt computes the integer square root, or z <- takeWhile (\n->n^2<p) [2..p].
09:41:16 <Jedai> Trowalts: [ f | f <- takeWhile (\f -> f^2 < n) [2..], n `mod` f == 0 ]
09:41:23 <joeally> cheers leimy
09:42:01 <Jedai> Trowalts: besides I suggest to remove the take 1 from your function
09:42:30 <lilac> Trowalts: i'd use '2:takeWhile (\n -> n^2 <= p) [3,5..]'
09:43:04 <lilac> doserj's and Jedai's formulations will both say that the square of a prime is prime ;-)
09:43:28 <Jedai> Trowalts: lazyness will ensure that no more than one factor will ever be calculated if you just test if the result is empty
09:43:34 <Jedai> lilac: Ooops
09:43:37 <lilac> :-D
09:44:19 <doserj> lilac: the isqrt one will work, though
09:44:21 <Trowalts> Jedai, lilac: alrighty then, thanks
09:44:23 <lilac> or even 'takeWhile (\n -> n^2 <= p) (2:[3,4..])'
09:44:39 <lilac> doserj: fair point ;-)
09:46:25 <Jedai> > let hasFactor :: Int -> Bool; hasFactor n = not . null $ [ f | f <- takeWhile ((<= n) . (^2)) (2:[3,5..]), n `mod` f == 0] in hasFactor 11
09:46:26 <lambdabot>   False
09:49:13 <Twey> > let hasFactor n = not . null . filter ((== 0) . (n `mod`)) . takeWhile ((<= n) . (^2)) $ 2 : [3, 5..] in hasFactor 11
09:49:14 <lambdabot>   False
09:51:16 <Jedai> @hoogle (a -> Bool) -> [a] -> Bool
09:51:16 <Jedai> > let hasFactor n = any ((== 0) . (n `mod`)) . takeWhile ((<= n) . (^2)) $ 2 : [3, 5..] in hasFactor 11
09:51:17 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
09:51:17 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
09:51:17 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
09:51:18 <lambdabot>   False
09:51:35 <Jedai> > let hasFactor n = any ((== 0) . (n `mod`)) . takeWhile ((<= n) . (^2)) $ 2 : [3, 5..] in hasFactor 25
09:51:37 <lambdabot>   True
09:52:59 * SamB wonders what the heck "the git potty" is
09:55:48 <mreh> Graphics/HGL/Key.hs:57:7:
09:55:48 <mreh>     Could not find module `Graphics.Win32':
09:55:48 <mreh>       it is a member of package Win32-2.1.1.1, which is hidden
09:55:48 <mreh> cabal: Error: some packages failed to install:
09:55:48 <mreh> HGL-3.2.0.0 failed during the building phase. The exception was:
09:55:49 <mreh> exit: ExitFailure 1
09:56:10 <dcoutts_> mreh: you asked that Q already :-)
09:56:20 <mreh> yeah, i forgot the answer
09:56:32 <mreh> add Graphics.Win32 to the dependancy list?
09:56:38 <dcoutts_> the answer was: don't use HGL, use something that works and is maintained
09:57:02 <mreh> unacceptable answer
09:57:09 <FunctorSalad> how about adding "If you got this error message while trying to compile a cabal package, you might have to add the package to the build-depends field"?
09:57:19 <FunctorSalad> adding it to the error message
09:57:32 <dcoutts_> mreh: if you were crazy enough to want to try and fix HGL then you'd start by editing the .cabal file to list Win32 as a build dependency
09:58:04 <mreh> thanks
09:58:13 <dcoutts_> however the problems will quickly become harder, threading nightmares etc
09:58:23 <FunctorSalad> :o
09:59:02 <mreh> I'm making a game of asteroids
09:59:13 <mreh> i dont see that really occuring
09:59:54 <dcoutts_> mreh: I don't mean in the code you write, but in the guts of HGL. Some clever people have looked at it to try and fix it, and not been able to.
10:00:03 <mreh> your advice is noted, you can say "I tol dyou so later"
10:00:39 <dcoutts_> I don't want to gloat :-) I'd prefer to save your frustration by giving you good advice
10:01:17 <mreh> getting more errors now
10:01:32 <mreh> Graphics/HGL/Key.hs:57:7:
10:01:32 <mreh>     Could not find module `Graphics.Win32':
10:01:32 <mreh>       it is a member of package Win32-2.1.1.1, which is hidden
10:01:32 <mreh> cabal: Error: some packages failed to install:
10:01:32 <mreh> HGL-3.2.0.0 failed during the building phase. The exception was:
10:01:33 <mreh> exit: ExitFailure 1
10:01:33 <mux> so far, everything seems to happen as dcoutts_ predicted then :-P
10:01:36 <mreh> wrong
10:01:38 <mreh> hang on
10:02:18 * mux should upload the newest version of his System.BSD.Sysctl module that can handle sysctl "procedures" to hackage
10:02:35 <mreh> Graphics/HGL/Internals/Types.hs:25:0:
10:02:35 <mreh>     Bad interface file: C:/ghc/ghc-6.8.3/lib\base-3.0.2.0/Data/Ix.hi
10:02:35 <mreh>         magic number mismatch: old/corrupt interface file?
10:02:38 <lpjhjdh> for parsing is happy de facto?  I wrote something quick with readp but adding error tracking is annoying.
10:02:59 <mreh> Haskell interfaces?
10:03:01 <mux> lpjhjdh: many of us use parser combinators libraries such as parsec or polyparse
10:03:09 <mux> mreh: the .hi files
10:03:35 <mreh> is that like a C header file?
10:03:46 <lpjhjdh> hmm, haven't tried polyparse, parsec always seemed overarchitected compared to readp to me
10:04:03 <dcoutts_> mux: for reference: http://hackage.haskell.org/trac/ghc/ticket/742
10:04:05 <lpjhjdh> of course now I'm complaining about adding error tracking with readp :p
10:04:24 <mreh> hehe, stop it dcoutts_!
10:04:25 <mux> dcoutts_: I think you meant to send that to mreh
10:04:26 <dcoutts_> lpjhjdh: right, readp has 0 in the way of parser error handling, you just get [] :-)
10:04:40 <mreh> mux: he's advising you stay out of it
10:04:55 <mux> I _am_ going to stay out of it for sure :-)
10:04:55 <Saizan> uu-parsinglib is nice too, aside from the fact they define their own Applicative
10:05:03 <dcoutts_> mux: I don't think mreh wants to hear the bad news :-)
10:05:09 <mux> heh.
10:05:29 <mux> dcoutts_: are you running OpenBSD?
10:05:38 <dcoutts_> mux: gentoo
10:05:44 <mux> damn.
10:06:03 <dcoutts_> though I recently got kvm working, so should be able to run any of the BSDs easily
10:06:09 <lpjhjdh> hmm, what would you all suggest then for a simple parser with error handling?
10:06:25 <mux> both NetBSD and OpenBSD (latest versions) fail to run with qemu 0.10.4 (latest version)
10:06:35 <mux> and this happens _just_ when I need to test stuff on those OSes
10:06:45 <dcoutts_> mux: gah
10:06:47 <dcoutts_> lpjhjdh: parsec or polyparse
10:07:12 <lpjhjdh> dcoutts_: thanks
10:08:17 <dcoutts_> mux: we need a haskell.org build farm with half a dozen different OSs
10:08:38 <mux> dcoutts_: that would be great, though in my case I'd need to do some runtime tests as well
10:08:51 <dcoutts_> mux: eg, upload to a test-only hackage and have bots test on different platforms
10:09:11 <mux> if the bots can run the test suite then I guess it'd be fine
10:09:14 <dcoutts_> mux: yes, we also need to upgrade cabal test
10:09:26 <mux> although I would have to write different tests suites for some OSes
10:11:23 <mux> dcoutts_: btw, the latest versions of cabal-install are truly great
10:11:28 <mux> can't live without it!
10:11:32 <dcoutts_> :-)
10:11:39 * dcoutts_ wishes he had more time to hack on it
10:11:52 <mux> if only to be able to type "cabal {configure|build|install}"
10:12:03 <mux> but of course installing packages from hackage is cool too
10:12:17 <dcoutts_> mux: do you use the bash command completion btw?
10:12:23 <lpjhjdh> dcoutts_: so with polyparse will I need to write basic stuff to track position?
10:12:26 <mux> dcoutts_: nope, I use zsh
10:12:49 <dcoutts_> mux: oh, someone should port it, should be trivial since most of it is done by the cabal program itself
10:12:58 <mux> dcoutts_: yup
10:13:07 <dcoutts_> lpjhjdh: I'm not sure actually, check the docs
10:13:24 <mux> I've had problems with PP exporting much less stuff than it should
10:13:35 <mux> I found tons of useful unexported functions in the sources
10:13:50 <mux> err, wait
10:14:00 <mux> sorry I was thinking of HaXml actually
10:14:05 <marcot> http://www.cs.york.ac.uk/fp/darcs/hscolour/hscolour.cabal
10:14:13 <marcot> Should this .cabal file have a Library field?
10:14:27 <mux> that and HaXml redefines maybe primitive parses already provided by PP
10:14:32 <mux> s/maybe/many/
10:14:43 <dcoutts_> marcot: it's an old style .cabal file, pre-Cabal-1.2, it still works
10:15:14 <marcot> dcoutts_: Ok, thanks.  It's not working with the Debian infra-structure.  I'll check why latter.
10:16:37 <mux> this is a bit surprising since both PP and HaXml are maintained by the same guy
10:17:09 <mux> I guess since PP was extracted from HaXml, he didn't have time to clean it up
10:19:40 <amgarching> hi, is there a primitive to split a list in two by a binary property?
10:20:24 <mux> amgarching: span
10:20:29 <skorpan> @src partition
10:20:30 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
10:20:30 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
10:20:30 <lambdabot>                               | otherwise = (ts, x:fs)
10:20:33 <skorpan> :t partition
10:20:34 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:20:47 <mux> oh, I may have understood what you want the wrong way
10:20:58 <mux> partition is the way to go in that case
10:21:12 <skorpan> could be either one really
10:21:58 <amgarching> skorpan: where is it? <interactive>:1:0: Not in scope: `partition'
10:22:04 <skorpan> amgarching: Data.List
10:22:07 <mux> @index partition
10:22:07 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
10:22:31 <skorpan> amgarching: hoogle is great for these kinds of questions
10:22:45 <skorpan> @hoogle (a -> Bool) -> [a] -> ([a], [a])
10:22:45 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
10:22:46 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
10:22:46 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
10:23:57 <joeally> how do i get this function to return a floating point number
10:23:59 <joeally> variance x =  div (sum (map (^2) x)) (length x)
10:24:08 <joeally> its an incomplete variance function
10:25:02 <mux> you want a floating point in the end even though you use integer division in your function?
10:25:22 <mux> by the way, div is best used infix imho
10:25:28 <joeally> okay#
10:25:40 <joeally> but it gives an error if i use the infix one
10:25:49 <mux> show us how you lrite it
10:25:59 <joeally> okay
10:26:39 <joeally> i get this when i use infix  No instance for (Fractional Int)
10:26:39 <joeally>       arising from a use of `/' at funcs.hs:25:14-44
10:26:39 <joeally>     Possible fix: add an instance declaration for (Fractional Int)
10:26:39 <joeally>     In the expression: (sum (map ((^ 2)) x)) / (length x)
10:26:39 <joeally>     In the definition of `variance':
10:26:39 <joeally>         variance x = (sum (map ((^ 2)) x)) / (length x)
10:26:52 <mux> is not the infix version of div
10:26:55 <mux> err
10:27:00 <mux>  / is not the infix version of div
10:27:03 <joeally> okay you mean x 'div' y
10:27:06 <mux> `div` is
10:27:18 <mux> div is integer division, (/) is FP division
10:27:43 <mux> which one do you actually want? :-)
10:27:56 <Zao> Not to forget quot :)
10:28:01 <mux> heh.
10:28:11 <joeally> i want one that will give me a a float
10:28:24 <joeally> for example in the mean of [1,2,3] is 2
10:28:24 <mux> then you want (/), but for that you need to supply it the correct types
10:28:29 <mux> :t (/)
10:28:30 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:28:34 <joeally> and the mean of [1,2] is 1.5
10:28:41 <mux> this means both numbers have to be in the Fractional class
10:28:53 <joeally> oh right
10:29:11 <mux> so you really want fromIntegral (sum (map (^2) x)) / (fromIntegral (length x))
10:29:12 <joeally> I'm reallly new to haskell
10:29:17 <joeally> okay
10:29:21 <joeally> thanks
10:29:23 <mux> yeah, don't worry, we've all been through that
10:29:40 <mux> next you'll discover haskell also has 3 different exponentiation operators :-)
10:29:57 <joeally> i'm looking forward to tha
10:29:59 <joeally> why
10:30:07 <joeally> ^ has worked fine for me
10:30:11 <mux> :t (^)
10:30:12 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
10:30:15 <mux> :t (**)
10:30:16 <lambdabot> forall a. (Floating a) => a -> a -> a
10:30:20 <mux> :t (^^)
10:30:20 <joeally> okay
10:30:21 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
10:30:23 <joeally> thanks lamdabot
10:30:26 <mux> see? :-)
10:31:11 <joeally> yes i do
10:31:18 <joeally> one is for floating point
10:31:26 <joeally> one is for intergers
10:31:34 <mux> > 4 ** -1
10:31:35 <lambdabot>       precedence parsing error
10:31:35 <lambdabot>          cannot mix `(**)' [infixr 8] and pref...
10:31:36 <joeally> its because it is statically typed
10:31:41 <mux> > 4 ** (-1)
10:31:42 <lambdabot>   0.25
10:31:47 <mux> > 4 ** (-1.5)
10:31:48 <lambdabot>   0.125
10:32:10 <mux> joeally: this is because these functions have a different behaviour
10:32:23 <joeally> oh
10:32:32 <mux> static typing doesn't prevent any kind of polymorphism
10:32:44 <mux> if there was really no use in providing 3 functions, haskell would only provide one
10:36:13 <lilac> has anyone written a numeric prelude which provides the same style of interface as dynamic languages tend to?
10:36:55 <lilac> (something like 'class Div a b where (/) :: a -> b -> Double' with instances for various pairs of numeric types)
10:37:18 <lilac> maybe 'class Div a b c | a b -> c where ...' would be closer to what you get in, say, python
10:37:28 <joeally> whats that for
10:40:34 * mux cabal sdist :-)
10:45:28 * mux wonders what would happen if he uploaded a package on hackage with a weird category... such as html code :-P
10:45:57 <joeally> go on mux
10:45:59 <joeally> do it
10:46:41 <mux> no, I already uploaded my package and even though I'm curious about it I don't want to do any harm on the site :-)
10:46:51 <joeally> oh
10:47:19 <lilac> can someone with an account cabal upload something for me?
10:47:37 <mux> though <span style="color: red; font-weight: bold">SomeCategory</span> would be funny.
10:47:40 <dcoutts_> lilac: you mean hackage? you can ask for an account
10:47:40 <joeally> mux how would I use a list comprehension to multiply to elements from 2 coresponding lists
10:47:51 <joeally> ooh mux inline csss
10:47:54 <joeally> css*
10:47:59 <joeally> thats is not good
10:47:59 * lilac asks for an account :)
10:48:15 <joeally> sorry lilac
10:48:17 * mux waves and leaves
10:48:23 <joeally> bye
10:48:37 <dcoutts_> mux: I expect that since it's using the html lib, that all strings are escaped
10:49:24 <lilac> does ross@soi.city.ac.uk IRC?
10:50:53 <lilac> what safeguards does hackage have to prevent some unscrupulous user from uploading a malicious version of a package?
10:51:13 <Elly> I would guess "none"
10:51:52 <SamB> lilac: well, you need to go through a human to get an account these days, don't you?
10:52:02 <joeally> is there anyway to form a new list by multiplying corresponding elements of two lists using map or a list comprehension
10:52:15 <SamB> so ... the threat of account suspension and shunnage ...
10:52:39 <otto_s_> > zipWith (*) [1,2..] [10,20,30]
10:52:41 <lambdabot>   [10,40,90]
10:52:59 <joeally> cheers otto
10:53:18 <lilac> SamB: sure, but at the cost of account suspension etc., one could probably quite easily own a lot of machines by uploading an evil version of some library
10:53:30 <lilac> i suspect this could only happen the once, but still, it concerns me
10:53:30 <Berengal> joeally: There's also a parallell list-comprehension expension
10:53:39 <joeally> oh
10:53:43 <joeally> how do i do that
10:53:46 <Elly> if you DNS poisoned you could get people to download arbitrary code too, since cabal doesn't check
10:53:55 <Berengal> > [a*b | a <- [1..10] | b <- [1..10]]
10:53:56 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:54:04 <joeally> thanks
10:54:07 <Berengal> You need to enable the expension though
10:54:13 <SamB> Elly: you think the hackage server should have a GPG key ?
10:54:18 <Berengal> Bleh, extension
10:54:27 <joeally> i think zipWith is a bit more elegant thougt
10:54:31 <joeally> but thanks
10:54:34 <SamB> or HTTPS or ... ?
10:54:53 <Berengal> joeally: Yeah, zipWith would be my choice as well. I'm just saying it's there :)
10:54:55 <lilac> SamB: it's not the hackage server that's the problem, it's trusting the content on the server
10:55:12 <lilac> a faked server with trusted content would arguably be fine to isntall from :)
10:55:13 <Berengal> > [(a,b,c) | a <- [1,2], b <- [3,4] | c <- [5,6]]
10:55:14 <lambdabot>   [(1,3,5),(1,4,6)]
10:55:15 <jbjohns> I read on an internet site about command line parameters, defaults and so on just being monoids.  Any implementations of this I could look at?  I'm having a hard time visualizing exactly how this would work
10:55:21 <joeally> yeah thanks thats the way i would have originally doen it had someone not told me of zipwith
10:55:57 <SamB> lilac: I meant to prevent the DNS poisoning stuff
10:55:59 <Berengal> joeally: Oh, and there's also ZipLists
10:56:03 <dcoutts_> SamB, Elly, lilac: I'd advocate a lightweight system where users can only upload specific packages (to stop subverting well-known names) and the packages should be checked against a hackage key so you know they've not been modified since they were uploaded.
10:56:18 <lilac> SamB: my point was, DNS poisoning is irrelevant if you trust the content, and you're hosed anyway if not
10:56:24 <joeally> oh
10:56:26 <joeally> okay
10:56:34 <Berengal> > getZipList $ (*) <$> ZipList [1..10] <*> ZipList [1..10]
10:56:36 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
10:56:37 <dcoutts_> but not a system where each author has to sign packages and all clients check, that's too much to manage
10:56:41 <SamB> lilac: and the GPG thing I was thinking of wouldn't prevent illegitimate servers serving the legitimate content
10:56:52 <dcoutts_> SamB: which isn't a problem
10:57:03 <SamB> dcoutts: I know!
10:57:15 <SamB> who cares if the server was a fake if it gave you the right data, eh?
10:57:22 <dcoutts_> SamB: well, except that it lets illegitimate serve old versions which may have known exploits
10:57:29 <SamB> dcoutts: well, okay ...
10:57:45 <jbjohns> dcoutts:  Actually, was it you that said that about command line args = monoids?
10:57:48 <SamB> but that's a heck of a lot better than a trojan, no?
10:57:51 <dcoutts_> SamB: that's more of a problem for distros with lots of network facing packages
10:58:03 <dcoutts_> jbjohns: yes
10:58:51 <SamB> anyway ... I was thinking that the hackage client would have grabbed the GPG key upon being configured to access the server ...
10:59:03 <dcoutts_> jbjohns: http://www.haskell.org/pipermail/cabal-devel/2007-December/001509.html and it's now implemented in Cabal
10:59:10 <jbjohns> dcoutts: cool, any examples you could point me too?  It seems to me the cleanest way to implement the defaulting+overriding behavior would be to use a Dictionary
10:59:10 <lilac> jbjohns: if you think of such things as a mapping of keys to values, those form a monoid where the empty mapping is zero and map union (preferring the RHS if the same key is in both maps) is plus
10:59:11 <SamB> and would check each package for a signature, and ensure that it was signed by that key
10:59:28 <lilac> jbjohns: if you think about it, that's how command-line arguments work too
10:59:31 <jbjohns> thanks guys
10:59:49 <SamB> or possibly a designated successor key
11:00:02 <SamB> (duly signed by the original, of course)
11:00:07 <dcoutts_> SamB: checking the package index is sufficient if the index contains hashes of the package tar.gz files
11:01:29 <skorpan> could someone remind me about the haskell definition of `split', i.e. 'split " " "hello there" = ["hello", "there"]'?
11:01:41 <skorpan> hm, actually words will do
11:01:52 <Berengal> @src words
11:01:52 <lambdabot> words s = case dropWhile isSpace s of
11:01:52 <lambdabot>     "" -> []
11:01:52 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
11:02:07 <skorpan> yep, so i could easily generalise that
11:02:26 <Berengal> If you wanted
11:02:43 <Berengal> Hmm, is there such a thing as groupBy?
11:02:47 <Cale> But, there's a nice library of string splitting functions on Hackage
11:02:48 <skorpan> yes
11:02:53 <skorpan> @src groupBy
11:02:53 <lambdabot> groupBy _  []       =  []
11:02:54 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:02:54 <lambdabot>     where (ys,zs) = span (eq x) xs
11:02:56 <Berengal> > groupBy (==' ') "hello there person"
11:02:56 <amgarching> i am very occasional haskeller, any comments on the code "sanity" here? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2448 In particular "simplify" looks ugly to me.
11:02:57 <lambdabot>   Couldn't match expected type `Char -> Bool'
11:03:05 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
11:04:04 <joeally> [a*b|a<-[1,2,3]|b<-[1,2,3]]
11:04:14 <joeally> >[a*b|a<-[1,2,3]|b<-[1,2,3]]
11:04:26 <Cale> amgarching: Well... there's a standard complex number library you could use for one.
11:04:54 <Cale> > [a*b|a<-[1,2,3]|b<-[1,2,3]]
11:04:55 <lambdabot>   [1,4,9]
11:04:58 <joeally> @[a*b|a<-[1,2,3]|b<-[1,2,3]]
11:04:58 <lambdabot> Unknown command, try @list
11:05:09 <Cale> The space after > is not optional
11:05:13 <Berengal> joeally: Needs a space after >
11:05:14 <joeally> okay
11:05:15 <Berengal> right
11:05:18 <joeally> sorry
11:05:34 <Cale> quite all right
11:05:37 <joeally> it doesnt work when i use variables
11:05:44 <jbjohns> @src foldMapDefault
11:05:44 <lambdabot> Source not found. Do you think like you type?
11:05:46 <joeally> i get this     Illegal parallel list comprehension: use -XParallelListComp
11:06:01 <Cale> joeally: Yeah, it's an extension which you have to turn on
11:06:05 <joeally> ooh
11:06:11 <joeally> how do i do that
11:06:25 <Cale> joeally: If you add {-# LANGUAGE ParallelListComp #-} to the top of your file it will work
11:06:31 <Berengal> joeally: Yeah, you need to enable them. Either run ghc/ghci with -XParallelListComp, as the suggestion says, or put {-# LANGUAGE ParallellListComp #-} at the very top of your file
11:06:32 <joeally> okay thanks
11:06:40 <Cale> Or just pass -XParallelListComp on the commandline to ghc
11:06:51 <cnwdup> Should libffi.so be provided by ghc?
11:06:53 <jbjohns> @src fmapDefault
11:06:53 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:07:01 <joeally> thanks
11:07:06 <Cale> Also, if you're inside ghci, you can :set -XParallelListComp
11:07:07 <jbjohns> > import Data.Traversable
11:07:08 <lambdabot>   <no location info>: parse error on input `import'
11:07:41 <Cale> jbjohns: The @src and > are not tied to each other anyhow.
11:07:43 <amgarching> Cale:  this doenst seem to work for complex numbers: (1 % 2) :+ 3
11:07:51 <jbjohns> aha
11:08:33 <jbjohns> I guess it wouldn't make sense for them to be really
11:08:37 <Cale> amgarching: hmm, oh, right.
11:09:06 <Cale> amgarching: That's another Haskell 98 stupidity. There's a pointless class restriction on the Complex datatype.
11:09:20 <Cale> I suppose it can't be helped.
11:10:55 <Cale> Ah, I see why too. It's because Num has too many stupid extra methods. Implementing abs and signum for Complex numbers requires a sqrt.
11:10:58 <schoenfinkel> @src Data.Traversable.fmapDefault
11:10:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:11:29 <Cale> I'm pretty sure there's no source in the @src database for that. You can get the source from the haddock documentation
11:12:06 <Cale> -- | This function may be used as a value for `fmap` in a `Functor` instance.
11:12:07 <Cale> fmapDefault :: Traversable t => (a -> b) -> t a -> t b
11:12:07 <Cale> fmapDefault f = getId . traverse (Id . f)
11:12:26 <Cale> newtype Id a = Id { getId :: a }
11:12:53 <Cale> (and it has trivial Functor and Applicative instances)
11:14:55 <joeally> I have this function fro Sxy
11:14:55 <joeally> > sxy x y = fromIntegral([a*b|b<-y|a<-x]) - fromIntegral((sum x)*(sum y))/fromIntegral(length x)
11:14:56 <lambdabot>   <no location info>: parse error on input `='
11:15:33 <joeally> only it gives this error
11:15:34 <joeally> No instance for (Integral [t])
11:15:34 <joeally>       arising from a use of `sxy' at <interactive>:1:0-10
11:15:34 <joeally>     Possible fix: add an instance declaration for (Integral [t])
11:15:49 <joeally> sxy x y = fromIntegral([a*b|b<-y|a<-x]) - fromIntegral((sum x)*(sum y))/fromIntegral(length x)
11:15:57 <skorpan> fromIntegral doesn't take a list
11:16:19 <skorpan> [a*b|b<-y|a<-x] is a list
11:16:40 <joeally> oh yeah
11:16:42 <joeally> thanks
11:16:46 <skorpan> make that [ a * b | b<-y, a<-x ] btw
11:16:50 <joeally> i for got to do the some of it
11:17:04 <skorpan> or [ a * b | b <- y, a <- x ], much more readable
11:17:14 <joeally> okay
11:17:15 <joeally> noted
11:17:35 <joeally> sxy x y = fromIntegral(sum [ a*b | b<-y | a<-x ]) - fromIntegral((sum x)*(sum y))/fromIntegral(length x)
11:17:44 <joeally> there we go
11:18:13 <Cale> amgarching: So this simplify is more or less collecting the like terms of the sum?
11:18:50 <amgarching> how would you factorize \sqrt(int) into int * \sqrt(int) ?
11:19:41 <amgarching> Cale: right, there appear several cancelling terms like (x*y) with opposit coeefs in expansion
11:20:57 <skorpan> :t foldr'
11:20:58 <lambdabot> Not in scope: `foldr''
11:21:02 <skorpan> :t Data.Foldable.foldr'
11:21:03 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
11:23:25 <skorpan> :t foldr1
11:23:26 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:25:09 <Cale> amgarching: I have something perhaps simpler if you don't mind reordering the monomials.
11:26:48 <Cale> > map (fst . head &&& sum . map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst) $ [("a",4),("a",3),("b",7),("a",-12)]
11:26:49 <lambdabot>   [("a",-5),("b",7)]
11:27:24 <Cale> > map (fst . head &&& sum . map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst) $ [("a",4),("a",3),("b",7),("a",-12),("b",-7)]
11:27:26 <lambdabot>   [("a",-5),("b",0)]
11:27:40 <Cale> > filter ((/= 0) . snd) . map (fst . head &&& sum . map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst) $ [("a",4),("a",3),("b",7),("a",-12),("b",-7)]
11:27:42 <lambdabot>   [("a",-5)]
11:29:25 <lilac> @seen roconnor
11:29:25 <lambdabot> roconnor is in #haskell-in-depth, #haskell-blah and #haskell. I last heard roconnor speak 1h 8m 28s ago.
11:30:04 <Cale> simplify = filter ((/= (0,0)) . snd)
11:30:04 <Cale>            . map (fst . head &&& csum . map snd)
11:30:04 <Cale>            . groupBy ((==) `on` fst)
11:30:04 <Cale>            . sortBy (comparing fst)
11:30:10 <lilac> @tell roconnor I've uploaded a version of the numbers package with Enum for Natural fixed.
11:30:10 <lambdabot> Consider it noted.
11:30:46 <lilac> Cale: s/csum/sum/?
11:30:55 <Cale> lilac: csum is something from his code
11:31:19 <Cale> He ended up having to reimplement complex numbers because Data.Complex has a stupid class dependency.
11:31:30 <lilac> fair enough
11:31:32 <Cale> (and won't admit complex rationals0
11:32:44 <lilac> something like (+) *** (+)  (for a (***) that works on 2-arg functions) then?
11:33:14 <lilac> @hoogle (a -> b, c -> d) -> (a, c) -> (b, d)
11:33:15 <lambdabot> No results found
11:33:40 <amgarching> Cale: does it really work?! I'll need some googling to understand that. I saved your snipplets, thanks for your thoughts. I need to run.
11:34:02 <arjanb> @type on
11:34:03 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:34:08 <Cale> amgarching: However, I wonder if it wouldn't save some trouble to make use of a more general library regarding these polynomials... I have a nice library for multivariate polynomials (and other monoid rings) which I still haven't put on hackage.
11:34:45 <EvilTerran> ?type uncurry (&&&)
11:34:46 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => (a b c, a b c') -> a b (c, c')
11:34:56 <EvilTerran> ?type uncurry (***) -- even
11:34:56 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
11:34:59 <Cale> amgarching: Note that comparing is from Data.Ord, `on` is from Data.Function, and (&&&) is from Control.Arrow
11:35:04 <wli> Cale: Any of the algorithms for translating systems of polynomial equations into eigensystems?
11:35:26 <Cale> wli: No, nothing of that sort. Just basic arithmetic on monoid rings.
11:35:35 <joeally> is there any way you can have executed writing in your code like # or /**/ in other languages
11:35:43 <amgarching> Cale: I just wanted to compare two expressions for spherical harmonics expansion for equivalence
11:36:19 <joeally> unexecuted*
11:36:36 <joeally> commets
11:36:40 <Cale> joeally: {- ... -} and -- ...
11:36:43 <joeally> okay
11:36:50 <joeally> thank you
11:36:59 <Cale> joeally: Moreover, it's okay to nest the bracketed comments.
11:37:07 <Cale> (unlike in C)
11:37:20 <joeally> thanks
11:37:37 <Hunner> How would I pattern match for (Either a b)? Am I thinking about Either wrong?
11:37:44 <Cale> case foo of
11:37:47 <Cale>   Left x -> ...
11:37:51 <Cale>   Right y -> ...
11:37:58 <Hunner> ah, I think I saw that somewhere. Thanks Cale
11:38:15 <Cale> Hunner: Or of course, use multiple equations, like you see in various functions.
11:38:16 * Hunner didn't recognize it though
11:48:21 <jbjohns> Ok, I'm looking through the cabal-install code at the flag -> monoid code.  Can anyone tell me the advantage of this over using a Dictionary and overwriting the values?  Like in Java you would just make a Properties object and load the config files in reverse order of preference.
11:48:48 <Cale> jbjohns: That's exactly what it is.
11:48:50 <jbjohns> I mean, I believe you that they are there, I'm just trying to break out of my OO thinking
11:49:15 <mauke> dictionaries form a monoid
11:49:25 <jbjohns> ok, I think I get that
11:49:29 <Cale> jbjohns: The monoid in question has the empty dictionary as a unit, and preferential combining as multiplication.
11:49:35 <Cale> (mappend)
11:50:53 <gwern> jbjohns: so therefore the advantage is reusing existing code and directly naming the abstract math object you are using
11:50:58 <Cale> jbjohns: When you have a bunch of things which have a unit and an associative combining operation, it's usually good to recognise them as a monoid, because then various libraries which know how to work generically with various monoids can make use of that, and it helps to document the properties of the code.
11:51:23 <Cale> Also, you get a bunch of related monoids for free, which is sometimes helpful.
11:51:44 <Cale> For example, we automatically get an mempty and mappend for functions which produce these dictionaries.
11:52:02 <jbjohns> ok, so one obvious advantage is the type system helps out to make sure you aren't mixing e.g. Boolean flags with value flags or list flags, right?
11:52:19 <Cale> Yes, but it would do that anyway.
11:52:50 <jbjohns> well, like in Java with the Properties object approach; it's all just strings.
11:52:52 <gwern> yeah; the sig would be Monoid Option vs Monoid Bool; this clashes just as would Option vs Bool
11:53:30 <Cale> Where is the code in question btw?
11:53:46 <jbjohns> from me?  Which code?
11:53:55 <Cale> The code that you're currently looking at.
11:54:20 <jbjohns> I just recently went through some property loading stuff with Java at around the same time I saw the entry from dcoutts so I wondered what it would look like in Haskell
11:54:23 <Cale> This is sort of a standard approach, so I have a rough idea of what it looks like, but I haven't seen the cabal version of it :)
11:54:40 <jbjohns> Ah, the cabal code I just did a google for "cable source"
11:54:54 <jbjohns> and now I'm looking through the darcs repo
11:55:12 <jbjohns> http://darcs.haskell.org/cabal/Distribution/Simple/
11:55:15 <jbjohns> that's part of it
11:55:22 <jbjohns> Setup.hs
11:56:12 <dcoutts_> jbjohns: right, we don't want a standard collection type like a dictionary or map because that the command line parameters are all different types but a collection would force them to be all the same type
11:56:14 <jbjohns> I've typically been a dynamically typed programmer, but all this C#/Java they've had me doing at work has started to grow my interest in Haskell lately for some reason
11:57:11 <dcoutts_> jbjohns: probably because Haskell has a proper static type system :-)
11:57:12 <persica> "some reason" -> "good reason" (fixed that for you)
11:57:12 <jbjohns> dcoutts: good point
11:57:51 <jbjohns> well, not "for some reason", because I do see advantages even those crappy type systems have so I've been interested in what a state-of-the-art one can do for me
11:58:26 <gwern> dcoutts_: that wouldn't be too bad; we could just define a sum type for the dictionary though
11:58:43 <olsner> I just made a bug... in the type system!
11:58:50 <jbjohns> actually I guess it was Sigfpe's monoid thing he did.  That really sparked my interest
11:58:59 <dcoutts_> gwern: bleugh, I want to know I'm getting the right type for each command line arg
11:59:08 <gwern> heh
11:59:14 <Cale> It does look like it might be nice to have some Data.Generics-based combinators to make those monoid instances though.
11:59:21 <dcoutts_> Cale: yes
11:59:25 <gwern> my point being that if java had sum types it wouldn't be so bad to not have monoids
11:59:30 <gwern> (did java ever get'em?)
11:59:32 <Cale> With 20 or 30 fields the code gets really repetitive :)
11:59:44 <jbjohns> where he just changed the type signature of some function to have Dual to make the tracing run in reverse
11:59:52 <dcoutts_> Cale: aye, sadly I'm restricted to H98 for Cabal
12:00:37 <Cale> jbjohns: Yeah, monoids are absolutely everywhere in computer programming (and computer science) and they're really useful to identify
12:01:10 <jbjohns> I've been reading the tour entry in the latest Monad.Reader
12:01:18 <jbjohns> the applicative stuff is really cool
12:01:30 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx -- here's an oldish response I gave to someone who was interested in knowing why monoids are useful.
12:02:17 <jbjohns> yea, seen that one.  The sorting stuff is quite neat
12:02:29 <olsner> if typing makes haskell programs free of run-time defects, is unit-testing required for testing the typing rules you've built to enforce the correctness of the rest of the program?
12:03:12 <Cale> olsner: Well, typing doesn't automatically make sure the program is entirely correct, but it goes some distance toward it.
12:03:38 <Cale> olsner: You might, if your types are sufficiently complicated, want to do a bunch of testing.
12:03:44 <Cale> (at the type level)
12:04:23 <Cale> But normally, types are much less complicated than the code and are easy enough to check by visual inspection.
12:04:35 <persica> Typing supplements testing more than replaces it.  It sort of seems like a general sanity check, but it doesn't prevent you from leaving out a step or the like.
12:04:48 <Cale> Well, sometimes it does ;)
12:05:07 <olsner> yeah, this is easily the most complex type program I've made thus far
12:05:20 <Cale> :t let myMap :: (a -> b) -> [a] -> [b]; myMap f [] = []; myMap f (x:xs) = x : myMap xs in myMap
12:05:21 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
12:05:22 <lambdabot>     In the first argument of `myMap', namely `xs'
12:05:22 <lambdabot>     In the second argument of `(:)', namely `myMap xs'
12:05:30 <Cale> :t let myMap :: (a -> b) -> [a] -> [b]; myMap f [] = []; myMap f (x:xs) = x : myMap f xs in myMap
12:05:31 <lambdabot>     Couldn't match expected type `b' against inferred type `a'
12:05:31 <lambdabot>       `b' is a rigid type variable bound by
12:05:31 <lambdabot>           the type signature for `myMap' at <interactive>:1:19
12:05:32 <persica> The way I see it, the type system makes sure the system is doing what you are telling it to.  But we sometimes tell it the wrong thing.
12:05:46 <Cale> There we go, that's the error I wanted ;)
12:05:47 <persica> And we tell it what the type system is... so...
12:06:13 <Cale> Yeah, it doesn't completely ensure that the program you've written is the program you wanted to write.
12:06:29 <Cale> Just makes it hard to to structurally unsound things.
12:06:44 <Cale> I've likened it to the nubs on lego blocks in the past.
12:07:00 <EvilTerran> particularly in languages with restricted side-effects, strict typing dramatically limits the domain of situations over which you need to test
12:07:22 <jbjohns> do you find that in Haskell it's easier (as in; less work) to do unit testing?
12:07:23 <Cale> to do*
12:07:35 <Cale> jbjohns: Absolutely, yes.
12:07:45 <Cale> jbjohns: Purity is an enormously helpful thing.
12:07:49 <EvilTerran> Cale, and unsafeCoerce is a craft knife and a bottle of glue?
12:07:55 <Cale> EvilTerran: hehehe
12:08:02 <EvilTerran> :P
12:08:13 <Cale> EvilTerran: Watch out! You'll cut your finger!
12:08:33 <olsner> unsafeCoerce duplo :: Lego
12:08:38 <jbjohns> yea, looking at the QuickCheck stuff looks awesome.  I was just wondering how often in practice the tests are mostly just constraints that generate tests
12:09:02 <EvilTerran> Cale, and then glue it to the table?
12:09:18 <EvilTerran> ah, the hazards of semantic-breaking functions...
12:09:44 <EvilTerran> unsafeGlueMissileToFinger
12:09:44 <Cale> jbjohns: I find it's a very useful way of testing my code, or testing that a change I'm about to make in the way I've implemented something preserves the meaning...
12:10:15 <Cale> jbjohns: Some people try to discover enough general properties of their code that the quickcheck tests get full code coverage.
12:10:53 <Cale> jbjohns: That's usually a fairly tricky thing to do, but if you can do it, it gives at least a little confidence that your tests actually characterise what it is that you're doing.
12:10:55 <olsner> quickcheck properties seem like they translate very well into general pieces of wisdom about what it is you're trying to do, really
12:11:14 <Cale> Yes, they make great documentation.
12:11:18 <jbjohns> nice.  The problem I have with TDD in dynamic languages and even C#/Java is that you're basically just writing code.  This code could also have bugs.  Describing constraints and then verifying them sounds much better. :)
12:11:26 <olsner> "operation A should lead to property Bar and should never ever break Foo"
12:11:59 <olsner> and writing an Arbitrary instance shows you why you want to encode as many properties as possible in the actual data types you're working with
12:11:59 <Cale> jbjohns: It also means that you're testing the interrelationships between various bits of your code, and not just in isolation.
12:12:06 <skorpan> jbjohns: there are tools for verifying java code as well
12:12:36 <Cale> Yeah, the need to write instances of Arbitrary is a good way to ensure that you're making sufficient use of the type system ;)
12:12:55 <olsner> (although you can always add quickcheck properties for your arbitrary instance)
12:13:10 <Cale> (in particular, it gets you to use newtype instead of just type)
12:13:59 <Cale> Though, I sort of wish that quickcheck came with a bunch of identity newtypes which twisted the arbitrary instances in various ways.
12:14:18 <Cale> I wonder how doable that is :)
12:14:39 <olsner> quickcheck2 does iirc
12:15:22 <pumpkin> twisty newtypes!
12:15:25 <olsner> Cale: you have e.g. OrderedList, NonZero etc from here: http://hackage.haskell.org/packages/archive/QuickCheck/2.1.0.1/doc/html/Test-QuickCheck-Arbitrary.html
12:15:42 <Cale> Aha! Very nice :)
12:16:18 <jbjohns> skorpan: I know, but not being pure, the utility is lessened, no?
12:16:44 <jbjohns> cale: what do you mean "newtype instead of just type"?  You mean giving existing types an alias as well as naming others or?
12:16:44 <Cale> jbjohns: I imagine so.
12:17:20 <Cale> jbjohns: Well, if you use type to define the types your program is using, you get fewer guarantees about correctness.
12:17:59 <Cale> jbjohns: (in exchange for a little bit of quick convenience, because all the functions which operated on the original type still works on the one you defined with type)
12:18:02 <jbjohns> hrm, I don't understand.  But I'm reading through "Real world Haskell", maybe that will clue me in
12:18:25 <jbjohns> ah, type!  Not data.  What does type do, just an alias?
12:18:32 <Cale> With newtype, you get a genuinely different type as far as the type system is concerned, but it just happens to be exactly the same as an existing type as runtime.
12:18:37 <Cale> yeah
12:18:58 <Cale> type just makes an alias which desugars away before the type checker even runs.
12:19:05 <jbjohns> ah
12:21:22 <Cale> newtype by contrast is like data, except that you're only allowed one case and one field, and the semantics for pattern matching are very subtly different, so that the compiler can represent values of the newtype as values of the original type that it wraps
12:21:46 <Cale> and the type checker gets to actually check things properly then
12:21:59 <Cale> For instance, you might have:
12:22:07 <Cale> newtype Dollars = D Integer
12:22:34 <pumpkin> mmm, enjoying the new hackage twitter account
12:22:37 <Cale> which would be like an Integer at runtime, but with no chance of confusing it with other Integers which happen to be in the program
12:22:42 <mm_freak> unfortunately for your own account, you'll likely never exceed the size of an Int =/
12:22:49 <Cale> hehe :)
12:22:50 <olsner> newtype is perfect for "tagging" values
12:22:59 <Cale> yeah
12:23:09 <Berengal> type is nice as a documentation tool
12:23:20 <Cale> If you need to write a new instance of a typeclass when one already exists, newtyping it is a good trick.
12:23:21 <Berengal> Like String for [Char] or FilePath for String
12:23:33 <Cale> You can then use the data constructor for the newtype to select which instance you want.
12:23:55 <mm_freak> Berengal: i use 'type' to save some typing…  like "'type' for me" =)
12:24:18 <mm_freak> i often use things like this:  type AppIO = StateT AppState (ReaderT AppConfig IO)
12:24:23 <Cale> Berengal: Though, it's a bit of a shame that we don't have nicely structured cross-platform file paths by default. :)
12:24:34 <mm_freak> (a few days earlier, i just used StateT or RWS, though)
12:24:48 <olsner> and you can also hide newtypes in modules to get a cheap way to make sure that only valid values generated by your module get passed around
12:24:52 <mm_freak> ((RWST))
12:24:56 <Berengal> Cale: Yeah, it sort of is... Still, file paths are strings...
12:25:19 <Cale> Berengal: Actually, the fact that file paths are Strings might be a bit of a shame in itself...
12:25:34 <jbjohns> that's cool stuff.  The other day I was looking at the monoid stuff with Sum and Product but when I tried to make my own with newType ghc wouldn't let me make Monoid instances of both
12:25:36 <Cale> Peaker has some interesting ideas about this.
12:25:53 <Berengal> Cale: Well, it makes them easy to work with. I wouldn't cry if FilePath turned newtype on me though
12:26:02 <jbjohns> Berengal:  I would disagree actually.  File paths have more than that, they have seperators that can be / or \ and other things
12:26:21 <skorpan> if i'm in a monad HelloM and i want to execWriter, how would i do that?
12:26:30 <jbjohns> that is, they are a string but there are certain assumptions about them
12:26:33 <virus_> I'm having a lookt at "3.15 Datatypes with Field Labels" in the Haskell 98 Report, but I don't seam to get it. Is there anywhere a nice example of these?
12:26:52 <Cale> skorpan: Well, the execWriter can't have anything to do with your monad, so stick it in a let?
12:26:53 <olsner> data FilePath = FilePath (Maybe Root) [String]
12:27:16 <skorpan> Cale: but then how would i extract what the writer resulted in?
12:27:37 <Cale> skorpan: let log = execWriter (some Writer computation)
12:27:38 <FunctorSal> you're learning haskell basics from the report? that's badass ;)
12:27:49 <mm_freak> olsner: the first argument is going to be Nothing in most cases
12:27:53 <skorpan> Cale: i see... :|
12:28:03 <olsner> mm_freak: maybe
12:28:05 <Cale> skorpan: Does that make sense?
12:28:09 <Berengal> virus_: data Person = Person {firstName :: String, lastName :: String, age :: Int}
12:28:43 <olsner> some platforms do have esoteric notions of sets of roots though
12:28:50 <Berengal> Then you can do 'setAge person newAge = person{age = newAge}'
12:28:53 <mm_freak> i'd rather prefer something like:  newtype FilePath = FilePath ByteString
12:29:20 <Berengal> I'd prefer an abstract FilePath myself...
12:29:21 <mm_freak> because all platforms have some string representation of roots, so i'd just add some functions for root handling
12:29:22 <EvilTerran> virus_, Berengal's example creates a constructor, Person :: String -> String -> Int -> Person; and accessors firstName, lastName :: Person -> String; age :: Person -> Int
12:29:22 <skorpan> Cale: it does actually, i never thought about the fact that execWriter returns w and not e.g. "m w"
12:29:31 <Cale> skorpan: Okay :)
12:29:45 <virus_> ah, cool. now that makes a lot more sense
12:29:51 <mm_freak> Berengal: that would result in 'show' or some 'pathToString' being abused most of the time
12:30:17 <Cale> mm_freak: Well, I think it would still make manipulation easier.
12:30:17 <FunctorSal> another cute use of named fields is record puns: cycleName Person{firstName} = cycle firstName
12:30:22 <EvilTerran> mm_freak, and "stringToPath"
12:30:37 <Berengal> mm_freak: Can't be worse than simply extracting the bytestring...
12:30:45 <FunctorSal> or setName p firstName = p{firstName}
12:30:47 <EvilTerran> FunctorSal, is that an extension thar?
12:30:57 <cnwdup> data Plugin = P { runPlugin :: IO Plugin }, myPlugin = P (do { putStrLn "Hello."; return myPlugin } }, evalPlugin plugin = runPlugin plugin >>= evalPlugin -- how expensive would that be if I want to have a non-terminating plugin loop and state emulated due to returning the plugin-structure?
12:31:00 <FunctorSal> EvilTerran: yeah, NamedFieldPuns
12:31:16 <EvilTerran> nice
12:31:20 <FunctorSal> even more concise are record wildcards
12:31:29 <Cale> What would possibly be really cool is if permissions to act on files was obtained from the filesystem in a way which didn't necessarily involve these strings at all.
12:31:30 <FunctorSal> cycleName Person{..} = cycle firstName
12:31:30 <EvilTerran> looks a bit non-scalable, but nice for a lot of circumstances
12:31:37 <EvilTerran> perlers would love it :P
12:31:57 <skorpan> hm, why isn't there anything such as evalWriter?
12:32:02 <FunctorSal> EvilTerran: actually it's more forwards-compatible than positional components
12:32:13 <Cale> skorpan: I don't know. It's stupid.
12:32:25 <FunctorSal> granted, that is, if you don't change the names
12:32:34 <skorpan> Cale: is evalWriter stupid or is it stupid that it doesn't exist?
12:32:36 <Cale> skorpan: Maybe they figured that you wouldn't have bothered to write it as a Writer computation in the first place if you didn't care about the log.
12:32:42 <EvilTerran> FunctorSal, i mean, it wouldn't work as a syntax on its own if you needed to dismantle two records of the same type in the same scope, say
12:32:44 <Cale> It's stupid that it doesn't exist.
12:32:49 <mm_freak> Berengal: and not better, i guess…  abstractions are fine, but too much abstraction can get annoying
12:32:53 <FunctorSal> EvilTerran: ah, right
12:32:57 <Cale> In fact, I'm a little fed up with the whole mtl.
12:33:13 <skorpan> there's been some discussion about mtl on the ML, no?
12:33:23 <skorpan> on haskell-cafe, that is
12:33:36 <Berengal> mm_freak: Yeah. I'm fine with type FilePath = String too :P
12:33:52 <Berengal> But if we're going to abstract, might as well make it an abstract type :)
12:34:03 <EvilTerran> FunctorSal, ie, it fills the same sort of niche served by perl's mighty "it" variable ($_). it works in lots of small cases, but stops being useful once you start needing the name for more than one thing
12:34:08 <FunctorSal> Berengal: wouldn't newtype with OverloadedStrings be better?
12:34:23 <mm_freak> Berengal: for whatever reason =)
12:34:27 <FunctorSal> and deriving Monoid
12:34:40 <mm_freak> abstraction doesn't have to mean hiding things
12:35:00 <mm_freak> it can also just mean:  type-safe convenience =)
12:35:20 <Cale> mtl really isn't that good a monad library. There are nicer ones like monadLib.
12:35:28 <Cale> Oh! I just had a lovely idea...
12:35:56 <Berengal> mm_freak: No, it doesn't, but if you think about what a file path really is, would you say it's a string, or it's location on disk?
12:36:20 <FunctorSal> generally type classes with generalizedNewtypeDeriving seems like a good way to have your type-safe cake and eat it without too much wrapping
12:36:26 <Cale> I should ask Edward Kmett about seeing if his category-extras tricks could possibly work to improve performance of MonadPrompt...
12:36:34 <virus_> Berengal, EvilTerran: So how would I access the data fields? like filtering all persons from a list with their first name being "Anna": filterAnna l = filter(\p -> p{firstName} == "Anna", l)
12:36:54 <Saizan> MonadPrompt is already CPS'ed iirc
12:37:05 <Cale> hmm, come to think of it :)
12:37:07 <EvilTerran> virus_, filter ((=="Anna") . firstName) would work
12:37:13 <FunctorSal> virus_: that would be filter (\p -> firstName p == "Anna")
12:37:20 <mm_freak> Berengal: that's a good point
12:37:26 <FunctorSal> the {} is for pattern matching
12:37:36 <mm_freak> Berengal: however, i don't know any OS where it's not a string =)
12:37:42 <Cale> Actually, I should look into what the performance of MonadPrompt is actually like.
12:38:00 <Cale> Having a MonadPrompt-based monad library would be really neat.
12:38:20 <EvilTerran> virus_, or filterAnnas l = [p | p@Person{firstName = "Anna"} <- l] would work, too, i believe
12:38:25 <Berengal> mm_freak: Of course, working at the lower level doesn't hurt us too much in this case. There might not be a good reason to abstract, but if we're already at the point of discussing how to abstract we might as well do it properly. Abstracting a string to a string makes no sense :)
12:38:31 <mm_freak> Berengal: generally real numbers are limits of cauchy series, but if you viewed it that way, the Prelude would get extremely inconvenient =)
12:38:52 <virus_> ah. so every fields creates an accessor
12:39:16 <Cale> (though, even as it is, how MonadPrompt actually functions is a little bit tricky for me to understand)
12:39:20 <EvilTerran> virus_, that using the record syntax in a pattern (Person{firstName = "Anna"}), as well as at-patterns (the pattern x@(...) acts like (...), but also binding the value matched by that pattern to x)
12:39:29 <skorpan> "warn" is to "warning" as X is to "error"...  what is X?
12:39:34 <skorpan> "err"?
12:39:39 * wli is at something of a loss to describe how to represent real numbers with arbitrary/infinite precision.
12:39:59 <Twey> Yes, ‘to err’
12:40:05 <Twey> It's a verb
12:40:06 <skorpan> thank
12:40:07 <skorpan> s
12:40:13 <Twey> err/erring/erred/erred
12:40:16 <EvilTerran> virus_, indeed; those accessors are normal functions, just generated automatically for your convenience :)
12:40:23 <EvilTerran> wli, CReal not suitable?
12:40:37 <Saizan> Cale: though you've to interpret a Prompt action into something, and often it's nice to have a monad as that something
12:40:47 <wli> It may well be. I'm merely at a loss to explain how it works.
12:40:51 <Twey> skorpan: I wouldn't say they were really comparable in computing terms, though
12:41:07 <EvilTerran> wli, ah. i have no idea how it works, so i'm afraid i can't help you there. :P
12:41:30 <Twey> To warn is to offer information about something, but to err is to actually commit the error
12:41:36 <Saizan> well, i'm not that sure about often :)
12:41:47 <EvilTerran> > exp (sqrt (-1) * pi) :: Complex CReal -- however, i do love that this actually works
12:41:48 <lambdabot>   (-1.0) :+ 0.0
12:41:49 <Cale> Saizan: That's part of what makes it nice, you get things like liftP :: Prompt p r -> PromptT p m r
12:42:24 <wli> What is this MonadPrompt thing?
12:42:33 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MonadPrompt
12:42:42 <Cale> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/src/Control-Monad-Prompt.html#MonadPrompt
12:43:33 <Cale> wli: Basically, it's an extremely general monad parametrised over an arbitrary datatype of effect descriptions. When you run it, you supply implementations of those effects.
12:43:51 <Saizan> it's also nice that you could combine monad by using (p :+: q) as the prompt type
12:43:59 <Cale> Yes :)
12:45:28 <skorpan> is there any simple showList definition which is equivalent to "lines"?
12:46:34 <Cale> I feel that perhaps there ought to be something like...  data Evaluator p r b = Evaluator { ret :: r -> b ; prm :: forall a. p a -> (a -> b) -> b }, and then an algebra of operations on those.
12:47:18 <skorpan> @instance Show Char
12:47:19 <lambdabot> Maybe you meant: instances instances-importing
12:47:39 <FunctorSal> skorpan: lines . fmap show?
12:47:49 <FunctorSal> if I understand you correctly
12:48:49 <skorpan> what i mean is that i simply want [A 2, A 9] to be serialized to (show (A 2) ++ "\n" ++ show (A 9) ++ "\n")
12:49:05 <skorpan> using showList in instance Show A where
12:49:12 <skorpan> data A = A Int
12:49:17 <FunctorSal> that's unlines . fmap show
12:49:23 <skorpan> no, i got a type error
12:49:29 <FunctorSal> yeah it is unlines
12:49:40 <FunctorSal> > unlines . fmap show $ [1,2,3]
12:49:40 <skorpan> oh, right
12:49:41 <lambdabot>   "1\n2\n3\n"
12:49:46 <skorpan> thanks :)
12:49:49 <FunctorSal> np
12:49:50 <Cale> skorpan: It's not usually considered a great idea to make show instances that don't produce valid Haskell code...
12:50:04 <Cale> But you can of course do it
12:50:10 <skorpan> Cale: i know, but in this case it's only for ease of debugging
12:50:17 <FunctorSal> theres always Text.PrettyPrint.ANSI.Leijen.Pretty :)
12:50:18 <Cale> ah, okay :)
12:50:45 <Cale> Wow, someone went nuts with the module path there ;)
12:50:51 <FunctorSal> indeed
12:51:09 <FunctorSal> it's particularly evil that the parts aren't hierarchical, so any permutation would make sense
12:51:17 <FunctorSal> ;)
12:51:21 <skorpan> FunctorSal: actually, that seems to be returning "" for me for some reason...  when i don't define showList, i get the right output
12:51:36 <skorpan> uh, wait, no, my bad :|
12:51:47 <skorpan> i had showList xs = ..
12:51:53 <skorpan> uh, what :|
12:51:55 <skorpan> i'm confused!
12:52:27 <skorpan> FunctorSal: ah, yes, i see... showList is [a] -> ShowS
12:52:34 <skorpan> type ShowS = String -> String
12:52:41 <skorpan> that was the reason that i asked in the first place :)
12:53:31 <SamB> FunctorSal: almost makes you want to have [facet :: tag] specifications in imports ...
12:53:43 <Saizan> you're supposed to prepend your output to the given list
12:53:47 <FunctorSal> SamB: I thought that too...
12:54:17 <SamB> but then you'd need a way to retroactively add those facet :: tag pairs to modules from existing packages
12:54:21 <SamB> and specify defaults
12:54:25 <SamB> or something ...
12:56:52 <roconnor> Cale: have you installed the new numbers package into lambdabot?
12:56:52 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
12:57:10 <Cale> roconnor: hmm
12:57:31 <roconnor> Cale: lilac installed proper Enum methods for Natural.
12:57:40 <Cale> roconnor: I haven't updated things on the machine lambdabot is running on in quite some time.
12:58:17 <Cale> /home/cale/.ghc/x86_64-linux-6.8.3/package.conf:
12:58:17 <Cale>     numbers-2008.4.20, numbers-2008.4.20.1
12:58:24 <virus_> for a testcase I want to define a list of objects. Now I've written myList = [ (Foo "a"), (Foo "b"), (Foo "c") ], but with newlines and it doesn't recognize it anymore. It tells me about a parse error with incorrect indentation. I tried adding a \ at the end of the lines with no success.
12:58:37 <roconnor> Cale: lilac uploaded it a few hours ago.
12:58:49 <EvilTerran> virus_, \ at the end of lines doesn't mean anything in haskell, except in stringd
12:58:54 <Cale> updated.
12:59:28 <virus_> So is there a way of splitting a list into multiple lines in the sources?
12:59:29 <EvilTerran> virus_, the general rule is, if you're continuing an expression on the next line, be sure to indent the continuations more than the first line
12:59:43 <EvilTerran> virus_, and don't use tabs
13:00:15 <EvilTerran> because the layout engine's interpretation of them may be different to your editor's interpretation
13:00:18 <virus_> ok. no tabs used so far. I got expandtab enabled as I'm writing a lot of python code :)
13:02:52 <roconnor> > [1..infinity]
13:02:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:03:04 <mauke> :t infinity
13:03:06 <lambdabot> Natural
13:03:54 <trofi> > infinity
13:03:56 <lambdabot>   * Exception: stack overflow
13:03:58 <trofi> > infinity + 1
13:04:01 <lambdabot>   * Exception: stack overflow
13:04:37 <trofi> > infinity `div` 2
13:04:42 <lambdabot>   * Exception: stack overflow
13:04:55 <trofi> > infinity == infinity
13:05:10 <lambdabot>   thread killed
13:05:19 <roconnor> @tell lilac Your new Naturals appear to be installed in lambdabot now.
13:05:19 <lambdabot> Consider it noted.
13:05:31 <roconnor> @tell lilac thanks to Cale.
13:05:31 <lambdabot> Consider it noted.
13:05:45 <virus_> EvilTerran: so there is no possibility to split the declaration of a static list into multiple lines?
13:05:47 <roconnor> > min 5 infinity
13:05:49 <lambdabot>   5
13:05:53 <roconnor> > min infinity 5
13:05:55 <lambdabot>   5
13:06:03 <mauke> virus_: of course there is
13:06:06 <mauke> I do it all the time
13:06:33 <roconnor> [1,2,3]++\n[4,5,6]
13:06:39 <Jedai> virus_: You can split such a declaration anywhere you want
13:06:53 <roconnor> [1,2,3,\n4,5,6]
13:06:59 <trofi> > min 5 (-infinity)
13:07:01 <lambdabot>   * Exception: Natural: (-)
13:07:11 <trofi> > max 5 (-infinity)
13:07:13 <lambdabot>   * Exception: Natural: (-)
13:07:15 <trofi> :p
13:07:23 <roconnor> -infinity isn't a Natural number
13:07:27 <roconnor> neither is -1
13:07:32 <Jedai> trofi: Naturals are naturals... there is no negative numbers
13:07:35 <Philonous> infinity isn't a natural number either
13:07:36 <roconnor> > -1 :: Natural
13:07:38 <lambdabot>   * Exception: Natural: (-)
13:07:43 <roconnor> Philonous: :D
13:08:03 <roconnor> Philonous: infinity isn't a natural number, but it is a Natural number.
13:08:05 <trofi> > (-1)/0
13:08:06 <lambdabot>   -Infinity
13:08:18 <roconnor> trofi: different type
13:08:24 <roconnor> that's a Double.
13:08:29 <trofi> yes, i understand
13:08:31 <Jedai> trofi: That's Float (or Double), nothing to do with *Natural
13:08:34 <virus_> http://codepad.org/VDj7XBgA
13:09:07 <Jedai> virus_: The "]" is incorrectly placed
13:09:30 <deech> Hi all, is there a Distance class that determines the distance between two Enumerable things? So for instance if it were specializing on the alphabet, the distance between B and D would be 3.
13:09:40 <virus_> When moving it at the end of the last entry it works fine - how is that so?
13:09:51 <trofi> :t fromEnum
13:09:56 <lambdabot> forall a. (Enum a) => a -> Int
13:09:59 <Jedai> virus_: As it is in the first column it should be the start of a new top-level definition
13:10:04 <EvilTerran> deech, you can do that with just Enum
13:10:30 <skorpan> could someone help me figure this pretty easy SYB problem out?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5052#a5052
13:11:00 <Jedai> virus_: You could also indent it a little and it would work too
13:11:11 <EvilTerran> > (subtract `on` fromEnum) 'A' 'N' -- 13!
13:11:12 <lambdabot>   13
13:12:08 <EvilTerran> > let enumDistance from to = fromEnum to - fromEnum from in enumDistance 'a' 'n' -- deech: this is probably clearer
13:12:09 <lambdabot>   13
13:12:14 <Jedai> skorpan: I probably wouldn't use Syb there...
13:12:32 <Jedai> skorpan: But I guess it's an exercise ?
13:12:45 <skorpan> no, i've just forgotten all i ever knew about SYB :)
13:12:52 <skorpan> i actually need this now
13:12:55 <EvilTerran> virus_, the general rule is, if you're spreading an expression across several lines, to make sure the second to last lines are *all* indented more than the first
13:13:22 <skorpan> i'm writing a light-weight javascript verifier, which will make sure that there are no multiple function declarations in each block of the code
13:13:34 <EvilTerran> virus_, although all lines but the first are usually at the same indentation level as each other
13:13:35 <virus_> EvilTerran: ok. including the "]". I thought it'd work like python in this case - ignoring the indent until the ].
13:13:38 <deech> EvilTerran: Thanks. I have used this, but it seems like such common operation that there would be a class for it.
13:14:23 <EvilTerran> deech, well, as you see, you don't really need a separate class for it. it might make sense for it to be in Data.Enum, though
13:14:59 <EvilTerran> deech, now i think about it, there's similar functionality in Data.Index, though
13:15:01 <EvilTerran> ?src Ix
13:15:01 <lambdabot> class (Ord a) => Ix a where
13:15:01 <lambdabot>     range           :: (a,a) -> [a]
13:15:01 <lambdabot>     index           :: (a,a) -> a -> Int
13:15:01 <lambdabot>     inRange         :: (a,a) -> a -> Bool
13:15:01 <lambdabot>     rangeSize       :: (a,a) -> Int
13:15:03 <deech> EvilTerran: Yes that is what I meant. Thought, words, disconnect. Why I laugh?
13:15:36 <EvilTerran> > rangeSize ('a','n')
13:15:37 <deech> EvilTerran: Cool, never looked at Ix.
13:15:38 <lambdabot>   14
13:15:58 <EvilTerran> > rangeSize ('a','a') -- this is off-by-one from the enumDistance though, in the Char case
13:16:00 <lambdabot>   1
13:16:12 <Cale> skorpan: Must it use Data.Generics?
13:16:19 <Cale> skorpan: A simple list comprehension would be simpler.
13:16:37 <skorpan> Cale: i suppose
13:16:39 <Cale> [Bike b | Bike b <- xs]
13:17:08 <Jedai> [ b | b@(Bike _) <- xs ]
13:17:21 <EvilTerran> deech, Ix is usually used for things like array indices, so it acts differently in some ways to Enum
13:17:57 <deech> EvilTerran : Will have to take a closer look at Ix. Thanks!
13:18:29 <EvilTerran> > range ((0,0) , (1,1)) -- range :: Enum a => (a,a) -> [a]; all the indices that would be in an array starting at (0,0) and finishing at (1,1), ie, a 2-dimensional array
13:18:30 <lambdabot>   [(0,0),(0,1),(1,0),(1,1)]
13:18:36 <Jedai> EvilTerran: I'm not sure if that's the case on the classic Enum types (though of course Ord and Ix don't always accord on "inRange")
13:19:18 <EvilTerran> Jedai, well, each is defined for some types the other isn't defined for, iirc
13:19:43 <Jedai> EvilTerran: Right :) (though Ix could be defined for every Enum type)
13:19:50 <EvilTerran> Enum doesn't do tuples, and Ix doesn't do Float/Double (although arguably Enum shouldn't either)
13:19:59 <skorpan> i just realized why i want generics in this case...  i'm using BList, a zipperish data structure.  so, back to my question, how would i do it? :)
13:20:48 <Jedai> EvilTerran: Enum really shouldn't do Float/Double
13:20:54 <Jedai> :(
13:21:59 <EvilTerran> it does seem at odds with the semantics for other Enum instances
13:23:06 <EvilTerran> > [0 :: Data.Fixed.Fixed E6 ..]
13:23:07 <lambdabot>   [0.000000,0.000001,0.000002,0.000003,0.000004,0.000005,0.000006,0.000007,0....
13:23:40 <Cale> maybe something like:  concat $ gmapQ (mkQ [] (\v -> case v of b@(Bike {}) -> [b]; _ -> [])) myStruct
13:23:46 <EvilTerran> > [0 :: Float ..] -- yeah, these two make sense when compared
13:23:47 <lambdabot>   [0.0,1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0...
13:23:52 <Cale> I don't really know Data.Generics all that well
13:25:07 <Cale> skorpan: Where is BList defined?
13:25:30 <skorpan> Cale: it's a Yi thing
13:25:40 <skorpan> Yi.Syntax.BList
13:25:44 <skorpan> data BList a = One [a] | Two ([a] -> [a]) [a]
13:25:54 <skorpan> i'm currently writing a bListToList function...
13:26:18 <Cale> Interesting.
13:26:19 <amgarchIn9> "Conflicting definitions for `q' in case alternative": How can I match duplicates in a list: q:q:qs ???
13:26:43 <Zao> a:a':as | a == a' = ...
13:26:47 <EvilTerran> amgarchIn9, give them different names, and use a guard on the pattern
13:26:47 <Cale> p:q:qs | p == q -> ...
13:28:46 <EvilTerran> "Welcome to #haskell, where your questions are answered in contrapuntal fugue."
13:29:37 <Cale> skorpan: Isn't that as simple as  toList (One r) = r; toList (Two l r) = reverse (l []) ++ r
13:29:38 <Cale> ?
13:29:46 * Cale doesn't see why it needs generics...
13:30:20 <Cale> Oh, it's already a Foldable even...
13:30:40 <Cale> :t Data.Foldable.toList
13:30:41 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
13:32:14 <hydo> "Cannot find module X.X it was found in multiple packages"  ugh
13:33:15 <gwern> I'm having a brainfart. BSD license requires attribution?
13:33:39 <mauke> depends on which BSD license you mean
13:34:06 <c_wraith> that's the main (only?) difference between the two main variants.
13:34:54 <gwern> thought bsd3 removed the advertising clause, but one still had to attirubte in the metadata
13:35:14 <mauke> oh, hm
13:35:27 <amgarchIn9> is hpaste dead for you?
13:36:09 <mauke> no
13:36:31 <skorpan> Cale: thanks for reminding me of Data.Foldable.toList :)
13:39:31 <amgarchIn9> how would you pull out a full square out of sqrt(Integer)? Any simpler way than this? -> http://haskell.pastebin.com/mf4fb0f1
13:40:40 <roconnor> heh, the famous prime / isPrime circle.
13:40:51 <SubStack> amgarchIn9: do you really need primes to do that?
13:42:33 <roconnor> amgarchIn9: I suspect there is a better way, but I don't know of one.
13:55:02 <hydo> Clean install of 6.10.3 and cabal-install... first package I tried to install is HStringTemplate and I'm getting http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2450#a2450 I'm assuming this is one of those "oh, yea, you need to X"
13:57:07 <hydo> ah, ha!  -fsyb-with-class
14:00:33 <mightybyte> Anyone know why I'm getting an error in this code?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5056
14:00:49 <hydo> Ok, does anyone know what I'm doing wrong?  Compiling HStringTemplate, cabal configure -fsyb-with-class (since it won't build for me without it) , cabal build then cabal install rebuilds the library, of course without -fsyb-with-class.  So I can build it, but I can't install it?  Any of you know what I'm doing wrong?
14:01:05 <byorgey> @seen ivanm
14:01:06 <lambdabot> I saw ivanm leaving #gentoo-haskell, #xmonad and #haskell 6h 23m 19s ago, and .
14:01:30 <Saizan_> hydo: cabal install --only
14:02:16 <hatds> mightbyte: you have to call the function at (Foo ns) and (Bar ss)
14:02:31 <hydo> Saizan_: is that a hidden option?  I don't see any reference to it in 'cabal help install'?
14:02:40 <hydo> s/?$//
14:03:06 <Saizan_> hydo: yes it is
14:03:17 <amgarchIn9> roconnor: one better way here: http://haskell.pastebin.com/m4a1b56b3 , I see some timing difference for sqrt23 $ factorial 100
14:03:27 <Saizan_> hydo: you can also pass flags like -fsyb-with-class to install directly
14:03:39 <Saizan_> hydo: instead of configuring separately
14:03:54 <hydo> Saizan_:  okie dokie.  I'll remember that then.  It's the magic make-it-work bit.
14:04:00 <mightybyte> hatds: Why?  What I want is gen :: Show a => ([a] -> String) -> MyData -> String
14:04:11 <hydo> Saizan_: I tried that and it didn't work... still got the 'found in multiple packages' error.
14:04:55 <hydo> Saizan_: doesn't matter actually... on to the next issue... :O
14:05:01 <hydo> err.. :P rather
14:05:06 <Saizan_> hydo: the problem is that HStringTemplate doesn't depend on base >= 4
14:05:34 <hatds> mightybyte: ah I misread
14:06:35 <yaxu> should the haskell platform work with ghc 6.10.3?  I'm getting "configure: error: The core package editline-0.2.1.0 is missing. It should have been distributed with 6.10.2"
14:07:13 <mightybyte> hatds: I've tried it with and without that type signature.  Both fail, but they give slightly different errors.
14:09:33 <hatds> mightybyte:  gen :: (forall a. [a] -> String) -> MyData -> String      you need to enable though RankNTypes
14:09:58 <hatds> you can put {-# LANGUAGE RankNTypes #-} on the top of your file
14:10:27 <hatds> I think you'll have trouble constructing such a function though :)
14:11:01 <mightybyte> hatds: Ahh, that works.
14:11:17 <mightybyte> hatds: Oh, I have an application for that pattern.
14:13:46 <hatds> mightybyte: I think what you are trying to accomplish can only be done by making your own show class or using the existing one, you can say you want a function that will work for any "Show-like" class
14:13:55 <hatds> *can't say
14:14:59 <mightybyte> hatds: And make MyData an instance of that class?
14:15:13 <hatds> mightybyte: yea
14:16:08 <hatds> either that or settle for the type signature    gen ::  (MyData -> String) -> MyData -> String
14:16:33 <mightybyte> hatds: I don't want to use that type signature because gen is complex and I'm trying to reuse it.
14:17:15 <hatds> for other types besides MyData or for other show-like functions?
14:17:16 <mightybyte> hatds: ...allowing different behaviors by letting the caller pass in their choice of listFunc.
14:17:22 <mightybyte> Both
14:17:53 <leimy> anyone here a fan of Timber?
14:18:13 <skorpan> i know pejo is
14:18:27 <mightybyte> A more complex data type instead of MyData and Text.XHtml.Strict.HTML instead of Show.
14:18:45 <leimy> @users
14:18:46 <lambdabot> Maximum users seen in #haskell: 658, currently: 614 (93.3%), active: 14 (2.3%)
14:19:04 <pejo> leimy, ohoy!
14:19:09 <hatds> mightybyte: gen itself will have to be overloaded if you want to generalize for other types besides MyData:   as it stands gen contains patterns like "Foo ns", which forces the second argument to be "MyData"
14:19:11 <mightybyte> Does forall allow you to include type class restrictions?
14:19:24 <hatds> yes
14:19:30 <leimy> pejo: Just looking at timber :-)
14:19:39 <leimy> looks intriguing
14:19:48 <mightybyte> hatds: Oh, not for multiple types.  Just for one, more complex, MyData.
14:20:12 <pejo> leimy, great! Let me know what you find out!
14:22:38 <monochrom> f :: (forall a. Ord a => a -> a > Bool) -> Int -> Bool   is an example of using forall and typeclass restriction.
14:22:45 <leimy> pejo: I'm wondering when the latest Timber compiler might show up on hackage :-)
14:23:10 <mightybyte> hatds: Excellent.  gen :: (forall a. Show a => [a] -> String) -> MyData -> String solved my problem
14:23:22 <mightybyte> monochrom: Thanks
14:24:09 <mightybyte> hatds: That works perfectly.  Thank you.
14:24:09 <pejo> leimy, hackage doesn't allow me to upload, it just hangs. There's a tar.gz on the homepage though, which is the same file as the one that should be on hackage.
14:24:32 <leimy> pejo: I see.  I've never been sure how things get updated there.
14:24:57 <leimy> pejo: do timber programs have an extension that's used often?
14:25:02 <monochrom> It downloads from the future. :)
14:25:04 <leimy> like ".timber"?
14:25:06 <pejo> leimy, if you download that file and unpack it and cd into the directory you can run "cabal install" from there and it will act almost as if you had cabal install'd directly from hackage.
14:25:20 <leimy> pejo: that's ok, I just installed the older one :-)
14:26:21 <pejo> leimy, the file extension used so far is .t. If you bump into problems with 1.0.2: try to update to 1.0.3, it has an awful lot of small bugfixes all over the place.
14:26:29 <leimy> ok
14:26:32 <leimy> fair enough :-)
14:27:32 <pejo> dcoutts, any idea why hackage just hangs for me? :-)
14:28:03 <dcoutts> pejo: nope, does it look like it's up?
14:28:08 <augustss_> yo!
14:28:49 <dcoutts> hia augustss_
14:29:06 <leimy> Weird.. I did "cabal install timberc" and it got stuck on happy
14:29:12 <leimy> but then I manually said "cabal install happy"
14:29:17 <leimy> and then "cabal install timberc"
14:29:19 <leimy> and it was good
14:29:27 <dcoutts> leimy: it doesn't yet track deps on tools, only on libs
14:29:30 <leimy> isn't cabal install supposed to do all the dependencies for me?
14:29:36 <leimy> ok that explains it.
14:29:43 <pejo> dcoutts, just because I asked it worked now. Sorry.
14:29:52 <dcoutts> pejo: :-)
14:29:54 <monochrom> Proof by transitivity is hard. :)
14:31:55 <pejo> leimy, ok, it's on hackage now.
14:32:24 <leimy> pejo: awesome!
14:33:49 <leimy> pejo: how portable is the C that is generated by timberc?
14:34:01 <leimy> meaning, do I need to port a bunch of runtime to make stuff run elsewhere?
14:35:58 <pejo> leimy, it's not 64-bit clean at the moment I think. A 32-bit posix-like platform should be ok though.
14:36:12 <leimy> but just libTimber.a ?
14:41:20 <pejo> leimy, if you run "timberc -v --make File" you will see what flags it is passing to gcc, and what files it is including. I apparently broke my local verison.
14:41:31 <leimy> ah ok :-)
14:44:29 <pejo> leimy, (libTimber.a is the standard library (Prelude) and some parts of the RTS though).
14:46:20 <mreh> does lambda calculus relate in any way to the calculus of infintessimals
14:46:24 <mreh> aka calculus
14:52:18 <DrSyzygy> > sum . (1.0/) $ [51..100]
14:52:19 <lambdabot>       No instance for (Fractional [a])
14:52:19 <lambdabot>        arising from the literal `1.0' ...
14:52:44 <DrSyzygy> > sum . ((1::Float(/) $ [51..100]
14:52:44 <lambdabot>   <no location info>: parse error on input `..'
14:52:53 <Jedai> > sum . map (1.0/) $ [51..100]
14:52:53 <DrSyzygy> > sum . ((1::Float)/) $ [51..100]
14:52:55 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Float'
14:52:55 <lambdabot>   0.6881721793101949
14:53:04 <DrSyzygy> Jedai: Thanks. I seem to be stupid tonight.
14:53:23 <Jedai> DrSyzygy: We all have this kind of moment.. ^^
14:53:26 <centrinia> What is calculus anyway?
14:53:30 * yaxu finds installing haskell a bit frustrating
14:53:38 <DrSyzygy> centrinia: I'll show you in a sec.
14:53:41 <Jedai> yaxu: On what OS ?
14:53:51 <DrSyzygy> Actually ..... http://michiexile.livejournal.com/193692.html
14:53:51 <yaxu> ubuntu
14:53:58 <DrSyzygy> Check it out before I update it to get the puzzle.
14:54:09 <yaxu> the haskell wiki points me at the ubuntu packages, which are out of date
14:54:20 <yaxu> so I download the latest binary and that's incompatible with the haskell platform
14:54:25 <DrSyzygy> Yo yaxu!
14:54:30 <yaxu> hey DrSyzygy
14:54:38 <yaxu> congratulations on your Dr :)
14:54:41 <Jedai> yaxu: What's incompatible ?
14:54:44 <DrSyzygy> Thanks! :-)
14:54:57 <yaxu> from earlier: should the haskell platform work with ghc 6.10.3?  I'm getting "configure: error: The core package editline-0.2.1.0 is missing. It should have been distributed with 6.10.2"
14:55:38 * yaxu tries installing that from hackage
14:56:05 <Jedai> yaxu: Arf... just edit a little bit the .cabal, editline isn't with 6.10.3 (it use haskeline instead and good riddance)
14:56:23 <yaxu> Jedai: ah ok, thanks!
14:57:16 <Jedai> yaxu: Don't try to install editline, it was a substitute for readline (chosen for license reason) but it's not very good, instead 6.10.3 use haskeline for ghci, which is a pure haskell library
14:58:48 <monochrom> mreh: No, lambda calculus and Newton/Leibniz's calculus are unrelated. The common word "calculus" means very broadly "a method of calculation", which doesn't say anything.
14:59:20 <centrinia> Oh.
14:59:40 <monadic_kid> nor is predicate calculus
14:59:43 <yaxu> Jedai: ok I deleted it from the cabal file, looks happier now
14:59:45 <monochrom> lambda calculus is "a method of calculation" because it comes with rules like beta reduction for you to simplify expressions.
15:00:29 <centrinia> I thought calculi all involved transformations of sequences of symbols.
15:00:42 <monochrom> Newton/Leibniz's calculus is "a method of calculation" because it comes with rules like the product rule and integration by parts to simplify derivatives and integrals.
15:01:05 <centrinia> Analytic Calculus. ;)
15:01:09 <monochrom> Yes, calculation means playing with symbols.
15:01:54 <monochrom> Note how the rules of integration are playing symbols instead of thinking "how to do this with Riemann sums".
15:01:54 <centrinia> Is there a predicate algebra and a lambda algebra?
15:02:14 <gwern> I sometimes wonder why we can't do total FP in haskell; surely someone has written a compiler or dsl or something? but I don't see anything on hackage
15:02:34 <Twey> ‘Total FP’?
15:02:49 * centrinia has read about some variants of Haskell that have no partial functions.
15:02:57 <monadic_kid> Twey: living without general recursion
15:03:00 <Cale> Twey: functional programming with no _|_
15:03:06 <Twey> Oh right
15:03:08 <Twey> O.O
15:03:13 <Twey> Is that Turing-complete?
15:03:17 <gwern> Twey: nope
15:03:19 <monadic_kid> Twey: nope
15:03:19 <Cale> Necessarily not.
15:03:20 <Twey> Aha
15:03:23 <Twey> I thought as much.
15:03:24 <centrinia> Bottomless functional programming. :)
15:03:29 <Twey> Heh
15:03:34 <Cale> But it's surprising how much it's possible to express.
15:04:05 <gwern> and while it isn't too bad in some ways, some parts of it scare me. like some of his comments
15:04:08 <gwern> '                                                  This is sometimes quite hard
15:04:10 <monochrom> Yes, from any calculus you can get an algebra. A calculus has rules that say "if you see X, reduce it to Y and hopefully it helps". To get an algebra, just assert the corresponding axiom X=Y and don't bias towards either direction.
15:04:11 <gwern> - for example rewriting the well known sieve of Eratosthenes program in this
15:04:14 <gwern> discipline involves coding in some bound on the distance from one prime to the
15:04:17 <gwern> next.
15:05:03 <Base> Hey
15:05:06 <monadic_kid> strict dependant types require total functions i think i read somewhere before
15:05:15 <Base> Can someone help me out with something
15:05:21 <Cale> gwern: Of course. If you think about it, where is the knowledge encoded in the sieve program that there will indeed be another prime? If there were only finitely many primes, it would just run forever, which total functional programs are not allowed to do.
15:05:32 <centrinia> Wait, reductions in calculi are invertible?
15:05:45 <byorgey> Base: don't ask to ask, just ask =)
15:05:45 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
15:05:49 <gwern> Cale: why does it need to know that? of course there will be another prime
15:06:01 <Base> oh okay byorgey :)
15:06:02 <Base> Define a function partition that takes an integer k and a list and returns the list
15:06:02 <Base> partitioned into sublists of length k (the last sublist could be of length less than k), e.g.,
15:06:02 <Base> partition 3 [1,2,3,4,5,6,7,8] ->[[1,2,3],[4,5,6],[7,8]].
15:06:13 <monochrom> That's not what I said.
15:06:17 <Cale> "Calculus" isn't a well-defined term. It just means "Means of calculation", which is sufficiently abstract to refer to a lot of things. Trying to pin it down more than that is folly.
15:06:23 <byorgey> Base: is this a homework question?
15:06:35 <Base> Part of a huge one
15:06:36 <Twey> Cale: Seems a bit poorly-considered to me
15:06:45 <Base> I'm stuck at this and one other
15:06:47 <Cale> Base: you know about take and drop right?
15:06:54 <byorgey> Base: well, what have you tried so far?  we are happy to help but we won't do your homework for you.
15:06:55 <Twey> An algorithm can be O(1) with an infinite constant, on a really poorly-designed system.
15:07:02 <Twey> Termination is an implementation detail.
15:07:06 <monochrom> I said from a calculus to an algebra you use =. I did not say you do that to the calculus.
15:07:11 <Base> Yeah I don't want you to do my homework for me
15:07:13 <Botje> Twey: every algorithm is O(1), just set n = 1 :o)
15:07:17 <centrinia> > let takeEvery n [] = []; takeEvery n (x:xs) = x:takeEvery (drop (n-1) xs) in takeEvery 2 [0..]
15:07:18 <lambdabot>   Couldn't match expected type `[t]' against inferred type `Int'
15:07:25 <Twey> Botje: *laughs*
15:07:27 <centrinia> > let takeEvery n [] = []; takeEvery n (x:xs) = x:takeEvery n (drop (n-1) xs) in takeEvery 2 [0..]
15:07:28 <Cale> Base: The way I would do it involves the following functions: take, drop, iterate, map, takeWhile
15:07:28 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
15:07:34 <byorgey> Base: you can paste what you have so far at hpaste.org
15:07:42 <Twey> I mean it can not recurse :-P
15:07:45 <DrSyzygy> :t iterate
15:07:46 <lambdabot> forall a. (a -> a) -> a -> [a]
15:07:48 <gwern> @hoogle splitAt
15:07:49 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
15:07:49 <lambdabot> Data.ByteString splitAt :: Int -> ByteString -> (ByteString, ByteString)
15:07:49 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
15:08:09 <monadic_kid> Twey: you can have structural recursion in total program, just not general
15:08:09 <Cale> Base: oh, and not, null
15:08:17 <monochrom> Axioms in an algebra are intended to be invertible. Rules in a calculus come with directions because usually only one direction gets you closer to the answer.
15:08:30 <Base> Cale I see
15:08:43 <Base> I'm more object oriented than function oriented
15:08:53 <Base> I tried to take length of string
15:08:57 <Base> and work on that
15:08:57 <gwern> > let part n as = let s = splitAt n as in (fst s) : part (snd s) in part 3 [1..10]
15:08:58 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Int'
15:09:00 <Base> using splitat
15:09:04 <centrinia> monochrom, the calculi are more general than the algebras?
15:09:07 <Base> but it was too messy :\
15:09:08 <gwern> > let part n as = let s = splitAt n as in (fst s) : part n (snd s) in part 3 [1..10]
15:09:09 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
15:09:19 <gwern> hm, that's not quite right :)
15:09:26 <byorgey> that's a good start though =)
15:09:28 <Cale> Base: It's also possible to write something recursive with splitAt, but it should not be necessary to use length
15:09:33 <Twey> monadic_kid: But you don't need any recursion at all for a program to fail to terminate.
15:09:40 <gwern> byorgey: kind of hard to write pattern-matching in lb!
15:09:43 <centrinia> > let part n as = map (take n) (iterate (drop n) as) in part 3 [1..]
15:09:44 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
15:09:49 <centrinia> > let part n as = map (take n) (iterate (drop n) as) in part 3 [1..10]
15:09:50 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
15:09:53 <DrSyzygy> > let part n as = let s = splitAt n as in (fst s) : part n (snd s) in takeWhile (not . null) 3 [1..10]
15:09:54 <lambdabot>   Couldn't match expected type `[t1] -> t'
15:10:01 <DrSyzygy> Pbtbtbtbt
15:10:03 <DrSyzygy> :t takeWhile
15:10:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:10:10 <DrSyzygy> :t not . null
15:10:11 <lambdabot> forall a. [a] -> Bool
15:10:12 <gwern> personally, I like the concreteness of using 'splitAt', although the tuple parsing is too bad
15:10:17 <centrinia> > let part n as = takeWhile (not . null) $ map (take n) (iterate (drop n) as) in part 3 [1..10]
15:10:19 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
15:10:24 <gwern> @hoogle Int -> [a] -> [[a]]
15:10:25 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
15:10:25 <lambdabot> Prelude drop :: Int -> [a] -> [a]
15:10:25 <lambdabot> Prelude take :: Int -> [a] -> [a]
15:10:37 <Cale> Well, since centrinia has already given it away...
15:10:41 <monochrom> I feel that I am trolled. I am asked questions that are already answered. I say "P is true" and I am asked "so P is false?"
15:10:45 <centrinia> Oops. :(
15:10:50 <gwern> (hm. I wonder how one could do it with replicateM?)
15:10:57 <Cale> part n = map (take n) . takeWhile (not . null) . iterate (drop n)
15:11:29 <blackh> Base: Yes we do do your homework for you.  I hope functional programming gets you interested.  I have been doing OO programming for years and I would never go back to it by choice after learning FP.
15:11:39 <gwern> @quote homework
15:11:39 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
15:11:57 <gwern> Welcome to #haskell, where your homework questions are answered in majestic stereo!
15:11:58 <Base> blackh are you serious?
15:12:02 <_JFT_> blackh: 100% with you on this one
15:12:04 <DrSyzygy> *snerk*
15:12:13 <blackh> Base: Yes, very serious.
15:12:20 <Cale> Me too.
15:12:33 <DrSyzygy> The "We won't do your homework" attitude gets kinda undermined by the tendency for people to start games of code golf in here. :-P
15:12:55 * DrSyzygy is sad that the original majestic stereo quote got removed from the lambdabot...
15:13:06 <gwern> @quote stereo
15:13:06 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
15:13:09 <Cale> Basically, the policy should be "you should be careful not to ask your homework questions because we will do them for you and you will fail the exam"
15:13:11 <gwern> heh
15:13:14 <gwern> @quote stereo
15:13:14 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
15:13:16 <DrSyzygy> @quote majestic
15:13:17 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
15:13:36 <blackh> Base: When I was a student years ago FP wasn't very advanced. A FP book sat on my shelf for 20 years and collected dust. My life would have been greatly improved if I had taken an interest in it earlier!
15:13:37 <gwern> remember Cale Welcome to #haskell, where your questions are answered in majestic stereo!
15:13:44 <gwern> er.
15:13:48 <gwern> @remember Cale Welcome to #haskell, where your questions are answered in majestic stereo!
15:13:49 <lambdabot> Okay.
15:13:57 <Cale> I believe I deleted that one on purpose.
15:14:01 <DrSyzygy> Woot!
15:14:04 <DrSyzygy> Awwwwww.
15:14:10 <gwern> Cale: it was too good to leave dead
15:14:14 <gwern> like sherlock holmes
15:14:29 <centrinia> Cale, why did you delete it?
15:14:42 <Cale> centrinia: Because it highlights me whenever someone uses it.
15:14:58 <gwern> welcome to #haskell, where your crimes are deduced by glorious zombies!
15:14:59 <Base> blackh I think ummm web applications are more into oo
15:15:10 <DrSyzygy> Cale: Would having the quote without attribution make you happier?
15:15:13 <Cale> yes :)
15:15:22 <gwern> @forget Cale Welcome to #haskell, where your questions are answered in majestic stereo!
15:15:22 <lambdabot> Done.
15:15:38 <DrSyzygy> Hey - we could attribtue to Ca1e
15:15:38 <gwern> @remember Anonycale Welcome to #haskell, where your questions are answered in majestic stereo!
15:15:39 <lambdabot> I will remember.
15:15:39 <blackh> Base: I've written 20,000 lines of web app in Haskell. It is far better than any of the dozens on web apps I've written in OO languages.
15:15:44 <DrSyzygy> Or that works.
15:15:52 <DrSyzygy> Does it?
15:15:52 <Cale> @quote stereo
15:15:52 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
15:15:56 <Cale> @quote majestic
15:15:56 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
15:16:00 <Cale> yeah, that's okay
15:16:04 <gwern> what, what?
15:16:07 <copumpkin> lol
15:16:11 <gwern> which was it, glorious or majestic?
15:16:11 <DrSyzygy> Hehehe
15:16:17 <Cale> majestic
15:16:28 <leimy> @quote stereo
15:16:29 <lambdabot> greeting says: Welcome to #haskell where your questions are answered in glorious stereo!
15:16:39 <leimy> @quote homework
15:16:40 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
15:16:40 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
15:16:42 <Cale> @forget greeting Welcome to #haskell where your questions are answered in glorious stereo!
15:16:42 <lambdabot> Done.
15:16:43 <gwern> Cale: then away it goes
15:16:47 <Cale> @flush
15:16:59 <Base> blackh can you show me some web apps developed in haskell
15:17:04 <gwern> Cale: incidentally, you push any state/ updates to darcs lb lately?
15:17:13 <gwern> Base: well, gitit is a nice haskell webapp
15:17:18 <gwern> (I like it alot)
15:17:20 <Apocalisp> Haskell Web Toolkit looks promising.
15:17:27 <Cale> gwern: I haven't. I've basically let lambdabot run itself for the last several months.
15:17:40 <gwern> Cale: ah. well at some point you should
15:17:45 <blackh> Base: Haskell is not as well supported with libraries as something like Python or PHP, but the web app support is pretty good. The huge advantage is the language itself.
15:17:50 <Cale> It's somewhat surprising that it's still running :)
15:17:52 <gwern> maybe schedule it for once a month; I noticed we've been losing HWN quotes
15:18:10 <Elly> HWN?
15:18:18 <centrinia> @google HWN
15:18:19 <lambdabot> http://www.hwn.org/
15:18:19 <lambdabot> Title: The Hurricane Watch Net
15:18:30 <DrSyzygy> Haskell Weekly News
15:18:31 <blackh> Base: I can't show you any web apps because mine is commercial and I haven't used the popular Haskell frameworks, but take the suggestions of others.
15:18:37 <Elly> oh, that :)
15:18:39 <aavogt> @go hwn
15:18:39 <gwern> @where HWN
15:18:39 <lambdabot> http://sequence.complete.org/
15:18:40 <lambdabot> http://www.hwn.org/
15:18:40 <lambdabot> Title: The Hurricane Watch Net
15:18:51 <gwern> aavogt: go is short for google
15:18:55 <Cale> There are a bunch of interesting web libraries for Haskell, but web programming is something that only interests me abstractly.
15:18:57 <aavogt> sure it is
15:19:14 <aavogt> sounds reasonable, now that I think of it
15:19:30 <gwern> google is closest in lb's edit distance setup
15:19:40 <blackh> Base: Amazing things are possible with web applications in Haskell.  Some of the widget libraries are truly ingenious in the way they abstract things, in ways that aren't possible in OO languages.
15:20:11 <Base> blackh you really got me intrested o.O
15:20:17 <blackh> Base: I'll give you a concrete example of something I did...
15:20:27 <Base> I mean i did my intern in a software company
15:20:30 <Base> purely OO
15:20:30 <Cale> For example formlets :)
15:20:42 <blackh> Base: Formlets - that's the word I was looking for.
15:20:49 <Base> and they're implimenting umm share point atm i thinl, they were talking about it before
15:21:00 <Base> blackh imma check that
15:21:05 <hydo> I hope web programming in haskell gets more popular (ie. I could get a job doing it) because it sure is a lot of fun.
15:21:22 <blackh> Base: Here's something I did just to illustrate the power of the language: I have a function called // which I use to output HTML, e.g.
15:21:35 <zachk> do most of you guys use happs? or just handroll
15:21:51 <hydo> I'm using Hack + happstack
15:21:55 <Cale> I don't actually write web apps. ;)
15:22:02 <blackh> Base: Really simple stuff, such as "<tr><td colspan=\"5\" style=\"width:" // text (show maxPhotoWidth) //
15:22:02 <blackh>                                "px;padding-bottom:5px\">" // inMarkup "</td></tr>\n" (
15:22:02 <blackh>                         photoTexts !! 0) //
15:22:07 <gwern> zachk: gitit is based on happstack yeah
15:22:07 <iago> uhm, someone argues that in haskell you can implement web apps easier than in tapestry for example?
15:22:18 <hydo> usually happstack by itself, but I've been playing with Hack for the past couple of days.
15:22:24 <amgarchIn9>     polynom' = filter (\(m, c) -> c /= 0) $ map re' polynom
15:22:25 <amgarchIn9>     re' (m, (r,_)) = (m, r)
15:22:34 <_JFT_> @go gitit
15:22:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/gitit
15:22:35 <lambdabot> Title: HackageDB: gitit-0.5.3
15:22:43 <amgarchIn9> how would you map+filter in one shot^^^
15:22:48 <hydo> iago: I would agree with that... mainly because I don't know java (tapestry is a java fw right?)
15:23:01 <Cale> amgarchIn9: I suppose a comprehension is possible
15:23:08 <blackh> Base: The ingenious bit is that // can store state and do other clever things.  One thing I use this for is I store footnotes as I go along, and collect them up at the bottom of the page.
15:23:20 <gwern> amgarchIn9: that doesn't really make sense; a filter is over a list, but a map deals with each item individually
15:23:46 <Cale> polynom' = [(m,r) | (m,(r,_)) <- polynom, r /= 0]
15:23:48 <gwern> amgarchIn9: you could have re' do something like return Nothing if c == 0, or something, but you would then still need to filter out the nothings
15:23:50 <blackh> Base: There's even one bit where I collect footnotes from earlier in the page.  I can do this because I evaluate it twice - once to store the footnotes, and one final time to generate the output.
15:24:05 <_JFT_> amgarchIn9: might try to use concatMap
15:24:16 <Base> blackh o.O
15:24:17 <c_wraith> amgarchIn9: catMaybes is probably the closest thing to what you want to do
15:24:19 <Base> that's sweet!
15:24:22 <Cale> List comprehensions do have a purpose, you know :)
15:24:34 <amgarchIn9> Cale: great!
15:24:43 <gwern> Cale: yes, to make other languages envious
15:25:46 <_JFT_> cale: silly of me but as much as I liked list comprehension when I started Haskell it is the one feature I rarely used and tend to forget about :P
15:25:46 <blackh> Base: This is all done in a general way. Another thing I use it for is where I do some processing that requires a certain CGI field to be kept in all links, I just say .. // preserve "some_id" // .. and all forms/links on the page pick it up.
15:26:23 <blackh> Base: The key concept is "composability".
15:26:47 <blackh> Base: Composability is where Haskell really excels. It turns programming into lego in a way that OO only attempts to do.
15:27:07 <blackh> Base: This is true of all FP languages, though, not just Haskell.
15:27:14 <lament> that's why Haskell is such a tremendous success, and OO is failing so badly.
15:27:21 <Cale> _JFT_: I've gone through the same thing. It's easy to forget they're there. Usually the urge to use concatMap makes me consider them now.
15:27:32 <iago> hydo, yep, tapestry is java, but it's hard to do easier write a web app
15:27:49 <gwern> blackh: composability benefits from purity & laziness, though
15:27:51 <_JFT_> cale: Thank you for the tip! I never thought of their likelyness
15:28:06 <Axman6> iago: ever tried google app engline?
15:28:10 <Axman6> enging*
15:28:17 <blackh> lament: If that's sarcasm I detect there, I just want to add that I have been at the coal face and OO has failed in many instances.
15:28:22 <hydo> Axman6: engine? :)
15:28:22 <mux> anyone using GHCi 6.10.3 here who could try a simple :run command ? it seems it always fail for me
15:28:24 <Axman6> bah
15:28:27 <Axman6> yes
15:28:30 <hydo> hehe
15:28:37 <Axman6> i just woke up
15:28:43 <Axman6> well, i'm still waking up
15:28:46 <Base[away]> blackh I should look more into it
15:28:56 <_JFT_> mux: which command?
15:29:00 <Axman6> and typing while eating breakfast
15:29:23 <hydo> blackh: do you use happstack?
15:29:26 <iago> Axman6, no
15:29:29 <mux> _JFT_: :run
15:29:45 <_JFT_> mux: with which arguments^
15:29:46 <_JFT_> ?
15:29:56 <mux> whatever, on any program
15:30:07 <blackh> hydo: No .. I've rolled my own. Partly because I don't like SQL and partly because the app is so big that I get the longer term benefit from the total control this approach gives me.
15:30:12 <mux> if you experience the same bug it won't matter
15:30:33 <mux> it just fails with: Couldn't find command in ""
15:30:33 <Axman6> iago: well,m i managed to get a pretty decent blog up and running with it, in about three hours, without knowing anything about python or much about google app engine (only found out about it by going to a google tech talk)
15:30:35 <_JFT_> mux: never used it give me one sec to see what I'm supposed to feed it :P
15:30:40 <hydo> blackh: It wouldn't happen to be publicly viewable, would it? :)
15:30:55 * mux found the code source and starts looking for the bug
15:30:55 <TomMD> mux: It works for me (GHC 6.10.3, x86_64, Linux)
15:31:05 <blackh> hydo: Unfortunately no, but I'd be happy to talk to you about it and show you bits of it.
15:31:56 <_JFT_> mux: it is working for me
15:31:59 <blackh> hydo: I've thought about taking some of the good stuff I've developed and putting it out there. My forms/html generation have worked out brilliantly, but so as HappStack. Maybe I can contribute something, though.
15:32:00 <iago> Axman6, well, if you do a blog in three hours I could expect something very specialized
15:32:11 <mux> TomMD, _JFT_: ok, thanks
15:32:11 <Axman6> eh?
15:32:22 <_JFT_> mux: GHC 6.10.3, OS X 10.5
15:33:01 <iago> perhaps I don't understand you well, I dunno
15:34:07 <mux> now that's really weird
15:34:35 <Axman6> iago: seriously, if you want to write highly scalable app, that use the same data store infrastructure google do, google app engine is well worth checking out
15:35:09 <blackh> Axman6: Does your app require Google's say-so to run?
15:35:17 <Axman6> nope
15:35:24 <Axman6> just upload it and go
15:35:57 <Axman6> you can even use google accounts for authentication (which is the default way of doing things)
15:36:03 <blackh> Axman6: What I mean is, let's say Google got taken over by evil aliens, and they decided to shut down all Google app engine apps, would the owners of the apps be able to move them to their own servers?
15:36:41 <Axman6> well, you do all the development on you local system, so sure
15:36:55 <Boney> blackh: I agree with you, while this cloud stuff seems wonderful, and companies like google might make a 99.9% promise.  I still don't have control.
15:37:08 <Boney> if they break something and cause some regression, I can't patch their code.
15:37:19 <Axman6> the data in the data store may be harder to get out, but i think it'd still be trivial
15:37:25 <blackh> Axman6, Boney: That's good, then.  I'm extremely wary of vendor lock-in.  I don't mean to imply that all aliens are evil, by the way.
15:37:47 <Boney> of course.
15:38:07 * Boney is one of those people that still runs his own mailserver.
15:38:11 <Axman6> google have very strong feelings about API's so people can have control
15:38:56 <Boney> Axman6: I havn't looked into it so I'm not authorative.  I'll have to do some reading sometime.
15:40:01 <Boney> Essentially my wife uses hotmail.com for her e-mail and complains when they change something (she often sees UI changes as regressions)>  I use mutt and don't have this problem.  This is my level of experience with "the cloud".
15:40:12 <Boney> heh, I nearly typed "clod"
15:40:28 <Twey> Haha
15:40:30 <Twey> Clod computing
15:40:42 <DrSyzygy> Boney: Not only running my own - but also providing my own and my wife's family with sensible mail services. :-P
15:40:43 <Boney> "put it in the clod"
15:40:47 <inimino> amateur postmasters unite!
15:40:59 <Twey> It's the next wave of eco-friendly computer systems
15:41:00 <Axman6> it's a really nice system though. you don't have to worry about setting up databased or anything, you just make a python class that has some 'properties' that the data store knows how to handle, and you just create not objects and run obj.put() and it's there
15:41:05 <Boney> DrSyzygy: that's my intention, if Liz actually wanted to try it.
15:41:15 <Axman6> you've also got access to their memcache stuff, which makes stuff about 10 times faster
15:41:23 <Boney> maybe I"ll put some webmail thing on it so she feels comfortable :-)
15:41:40 <DrSyzygy> Boney: Squirrelmail is surprisingly nice.
15:42:13 * Axman6 got his Arduino board yesterday :D
15:42:14 <Boney> Yep, I think I've used it once for something.
15:42:19 <inimino> I really hate Squirrelmail actually
15:42:23 <_JFT_> Dumb question but is there a hidden way to enter binary literals?
15:42:29 <Boney> Axman6: sounds nice.
15:42:44 <SamB> _JFT_: nope -- just use hex
15:43:03 <DrSyzygy> inimino: I'm sure you have better tools though, don't you? You gotta think like, say, my mom. :-P
15:43:08 <_JFT_> SamB: Thanks, that's what I've been doing
15:43:21 <SamB> this isn't scheme, you know!
15:43:33 <_JFT_> SamB: was hoping for some hidden way :P
15:43:34 <SamB> that's like the one thing they even HAVE syntax for
15:43:52 <inimino> DrSyzygy: I think Squirrelmail is not good for your Mom either, it's archaic and unfriendly
15:43:58 <SamB> _JFT_: well, you *could* cheat and use Template Haskelll
15:44:01 <SamB> er. Haskell
15:44:14 <DrSyzygy> inimino: Any recommendations on better webmail packages?
15:44:30 <_JFT_> SamB: Now that's an idea, I've never played with TH that should be quite simple for such a little task...
15:44:38 <inimino> DrSyzygy: but then, Gmail isn't very Mom-friendly either, but not for the same reasons
15:45:20 <inimino> DrSyzygy: unfortunately, no, unless you want to take a couple months and help me write one ;-)
15:45:34 <DrSyzygy> inimino: WAY too many paper deadlines the next few months.
15:45:42 <inimino> DrSyzygy: I think the state of FOSS webmail clients has been abysmal for a long time
15:45:50 <zachk> foss?
15:45:53 <inimino> DrSyzygy: yeah, I don't really have any time to do anything about it either
15:46:36 * cads misses you haskell guys in the clojure community
15:46:51 <inimino> zachk: free/open-source software
15:47:14 <lament> is there really no power function with non-integral exponents?
15:47:28 <cads> lament, I think there's an exp function somewhere
15:47:29 <DrSyzygy> lament: sqrt?
15:47:32 <DrSyzygy> :-P
15:47:42 <DrSyzygy> ?ho exp
15:47:42 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
15:47:48 <DrSyzygy> ?hoogle exp
15:47:48 <lambdabot> Prelude exp :: Floating a => a -> a
15:47:48 <lambdabot> Language.Haskell.TH data Exp
15:47:48 <lambdabot> Language.Haskell.TH.Syntax data Exp
15:47:49 <lament> oh, there is
15:47:52 <lament> it's called **
15:48:00 <DrSyzygy> :t (**)
15:48:01 <lambdabot> forall a. (Floating a) => a -> a -> a
15:48:10 <DrSyzygy> > 3.5 ** 1.5
15:48:11 <lambdabot>   6.547900426854397
15:48:19 <cads> > (PI^PI)
15:48:20 <lambdabot>   Not in scope: data constructor `PI'Not in scope: data constructor `PI'
15:48:40 <cads> oops
15:48:48 <roconnor> > 3.5 ** 1.5 :: CReal
15:48:49 <lambdabot>   6.547900426854397424771560281553961278073
15:49:18 <cads> damn those creals are just uber
15:51:02 <Axman6> > pi / (pi+1) :: CReal
15:51:04 <lambdabot>   0.7585469929947761453444306890448928641384
15:51:10 <Axman6> > pi / (pi-1) :: CReal
15:51:12 <lambdabot>   1.4669422069242598599833948132336675731433
15:51:16 <Axman6> > pi / (pi-3) :: CReal
15:51:18 <lambdabot>   22.1875399177931373093790154577116741282029
15:51:56 <_JFT_> CReal?
15:52:09 <TomMD> Part of the FFI
15:52:14 <TomMD> @hoogle CReal
15:52:15 <lambdabot> No results found
15:52:16 <copumpkin> CReal is part of numbers
15:52:17 <Axman6> uh no
15:52:18 <TomMD> damn you hoogle
15:52:21 <copumpkin> you're thinking of CDouble
15:52:22 <TomMD> oh, ok
15:52:26 <TomMD> Right, right
15:52:35 <_JFT_> @hoogle CDouble
15:52:35 <lambdabot> Foreign.C.Types data CDouble
15:52:38 <Axman6> they're arbitrary precision real numbers
15:52:48 <Axman6> > showCReal 40 pi
15:52:50 <lambdabot>   "3.1415926535897932384626433832795028841972"
15:52:52 <_JFT_> Axman6: which package provide CReal?
15:52:53 <Axman6> > showCReal 60 pi
15:52:55 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974945"
15:53:02 <copumpkin> numbers
15:53:04 <Axman6> Data.Numbers i think
15:53:05 <copumpkin> @hackage numbers
15:53:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
15:53:07 <Axman6> yeah
15:53:18 <_JFT_> Axman6, copumpkin : Thank you!
15:53:22 <copumpkin> :)
15:53:25 <Axman6> they're very cool
15:53:58 <roconnor> > deriv (\x -> cos x *exp x) x
15:54:00 <lambdabot>   1 * negate (sin x) * exp x + cos x * (1 * exp x)
15:54:09 <_JFT_> I love cabal-install!
15:54:22 <Axman6> roconnor: what package is that from?
15:54:27 <copumpkin> > deriv (\x -> cos (sin (exp x))) x
15:54:28 <lambdabot>   1 * exp x * cos (exp x) * negate (sin (sin (exp x)))
15:54:33 <roconnor> @hackage numbers
15:54:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
15:54:41 <roconnor> and simple reflect
15:54:48 * Axman6 is happy that his TI calculator can do the same thing, and pretty print it
15:54:49 <Axman6> ah ok, awesome
15:54:51 <roconnor> but numbers has it's own reflect package that does the same.
15:54:58 <roconnor> well, sameish
15:55:31 <roconnor> the reflect in numbers is probably better than the reflect that lambdabot is using.
15:56:05 <Axman6> ha, just replied to someone on twitter who wasn't following me, and now they are
15:57:21 <roconnor> Axman6: the neat thing is that the deriv function and the simple reflection of expressions are developed totally independently!
15:57:34 <Axman6> :t deriv (\x -> cos (sin (exp x))) ?x
15:57:35 <lambdabot> forall a. (?x::a, Floating a) => a
15:57:58 <Axman6> roconnor: shame i can't get it working in ghci :9
15:58:00 <Axman6> :(*
15:58:20 <roconnor> get what working?
15:59:34 <Axman6> i've got Data.Number.Dif :m +'d, but it's whinging about x not being being in scope. guess i need to load something else, or make a new variable?
15:59:53 <roconnor> you need to load the reflection module
15:59:58 <copumpkin> that's simple-reflect
16:00:13 <Axman6> ah, ok
16:00:26 <roconnor> load up Data.Numbers.Symbolic
16:00:34 <roconnor> let x = var "x"
16:00:34 <Axman6> hmm, i have that too
16:00:36 <Axman6> ah ok
16:00:52 <Axman6> hooray :)
16:01:02 <roconnor> the simple reflect package that lambdabot uses is different and already has a bunch of one letter variables defined.
16:01:11 <Axman6> yeah
16:01:18 <hydo> ack!  Saizan: what was that magic make-it-work bit again?  That conversation has scrolled out of the buffer.
16:01:24 <roconnor> but you will find Data.Numbers.Symbolic makes nicer output
16:01:33 <hydo> I thought it was -fonly but that's not working.
16:01:35 <c_wraith> hydo: I think it was --only
16:01:37 <Axman6> but, i can see it'd be a pain if x was defined whenever you loaded op simple reflect
16:01:49 <roconnor> @src x
16:01:49 <lambdabot> Source not found. Maybe you made a typo?
16:01:49 <Axman6> ok, shower time
16:02:54 <hydo> c_wraith: yep, that was it.  Thanks!
16:11:28 <roconnor> @free length
16:11:29 <lambdabot> length = length . $map f
16:11:52 <amckinley> easy question: is there a way to partially apply the arguments to a value constructor defined with record syntax?
16:12:30 <kpreid> amckinley: yes, a value constructor can be used as a normal function
16:12:41 <kpreid> you can't partially apply AND use names though
16:12:55 <amckinley> kpreid: argh! thanks :)
16:18:34 <amckinley> kpreid: so theres no way i could pass a half-initialized ADT between functions and set different pieces of the ADT using record syntax?
16:20:21 <hatds> don't try to abuse record syntax :)
16:21:33 <amckinley> hatds: :) any better ideas? im populating a kind-of complicated structure with the results of parsing a big ugly text file
16:22:45 <roconnor> break your record into different pieces?
16:24:36 <amckinley> roconnor: ive already broken it up a lot; i guess i could keep going :P
16:24:57 <roconnor> amckinley: also see data.accessor, which is totally awesome.
16:27:06 <amckinley> roconnor: oooh, thanks for that
16:27:35 <roconnor> I'm told it really improved the nested records in the Chart's library.
16:32:07 <kpreid> amckinley: you COULD pass a half-initialized ADT and use record update syntax later, that works fine
16:32:20 <kpreid> you just have to avoid using any of the uninitialized fields since they are _|_
16:32:56 <Philonous> @hoogle wait
16:32:56 <lambdabot> System.Process waitForProcess :: ProcessHandle -> IO ExitCode
16:32:56 <lambdabot> Control.Concurrent.QSem waitQSem :: QSem -> IO ()
16:32:56 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
16:33:12 <roconnor> @hoogle delay
16:33:12 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
16:33:33 <Philonous> Thanks
16:37:06 <amckinley> hmmm... could i use fold to apply a bunch of args in a list to a half-initialized ADT?
16:37:55 <roconnor> amckinley: you can sequence a list of data.accessor.sets .
16:39:15 <roconnor> amckinley: http://hackage.haskell.org/packages/archive/data-accessor/0.2.0.2/doc/html/Data-Accessor-Basic.html#v%3Acompose
16:39:27 <roconnor> ``This is a general function, but it is especially useful for setting many values of different type at once.
16:39:38 <amckinley> i guess i couldnt use fold, since the type of the half-initialized adt would change after every application
16:39:55 <amckinley> roconnor: thanks again
16:40:04 <roconnor> oh, if the types are changing after every update, then you are in trouble.
16:40:38 <amckinley> well, its a partially applied function that id be using as the accumulator
16:40:50 <amckinley> as in
16:40:59 <amckinley> let s = BigAdt firstArg
16:41:22 <amckinley> foldl (\t x -> t x) s [ arg2, arg3, etc]
16:44:30 <roconnor> what's wrong with writing s arg2 arg3 ... ?
16:45:02 <amckinley> because its more like 10 args
16:45:08 <copumpkin> oh no, OccurAnal
16:45:11 <amckinley> so i want to say something like
16:45:15 <amckinley> nums    <- many1 $ lexeme $ many1 digit
16:45:35 <amckinley> and then peel off one element of nums at a time and apply it
16:46:41 <roconnor> amckinley: that doesn't sound type safe as you describe it.
16:47:23 <amckinley> roconnor: you're right
16:48:33 <amckinley>         explode s (x:xs) = s x . explode s xs
16:48:33 <amckinley>         explode s _ = s
16:48:41 <amckinley> gives an infinite type error
16:48:46 <roconnor> yes
16:48:54 <roconnor> because it isn't type safe
16:49:19 <roconnor> how do you know the list contains the correct number of arguments?
16:49:51 <amckinley> i thought it wasnt type safe because the type of s will change after every application
16:50:34 <roconnor> amckinley: well if it was type safe, it would require an infinite type.
16:50:38 <amckinley> but i guess its also not type safe because you have no idea how many applications will actually happen :P
16:50:56 <amckinley> roconnor: ok, i give up :) switching to data.accessor
16:51:07 <roconnor> data.accessor is awesome
16:54:15 <Nehal> import List; numerator (4 % 6)         this reduces the ratio first and then returns 2, how do i get the numerator before it is reduced?
16:54:44 <Nehal> uh, that should be import Ratio
16:55:50 <Jedai> Nehal: You can't
16:55:52 <roconnor> you cannot.  The % function reduces the ratio.
16:55:59 <Nehal> i see
16:56:39 <Jedai> Nehal: There are good reasons to do this, it is better to normalize the representation as soon as possible, it avoids many problems and innefficiencies afterward
16:56:39 <aavogt> :t Ratio
16:56:40 <lambdabot> Not in scope: data constructor `Ratio'
16:57:22 <Jedai> Nehal: if you want couple, just use couples
16:57:41 <glguy> > fst (4,6)
16:57:43 <lambdabot>   4
16:57:56 <Nehal> ok
16:58:46 <Jedai> Nehal: On the other hand, if you explain why you would like to do that, we may have smarter suggestions
16:59:50 <Nehal> Jedai: it's for an assignment, i have to produce an infinite list of rational numbers between 0 and 1, no duplicates allowed... i somehow have to detect duplicates
17:00:43 <Jedai> Nehal: ... it seems to me that to detect duplicates it is far better to use a canonical form
17:00:59 <aavogt> > (4%6) == (2%3)
17:01:00 <lambdabot>   True
17:01:12 <Jedai> Nehal: In other words the behaviour of Ratio seems much better for this assignment than the one you asked for
17:01:34 <Nehal> yes i think i know what you are saying
17:02:38 <Jedai> I'm not sure to understand the assignment, isn't it really easy ?
17:03:18 <Nehal> Jedai: this is a basic haskell course and this is the first assignment.... i wouldn't be surprised if it seems very easy for you :)
17:04:25 <Base> umm how can i do [1..5] -> [1,[2,[3,[4,[5]]]]]
17:04:49 <Ralith> \(x:xs) -> x:[xs]
17:05:16 <Jedai> Nehal: If I understood the assignment correctly I would suggest that you forget this idea of "detecting duplicates", it is far easier to produce this infinite list directly
17:05:21 <Cale> It seems easier to generate the list in such a way that there are no duplicates from the outset than to remove them after the fact.
17:05:42 <Jedai> Base: You can't
17:05:43 <Nehal> Jedai: yeah, i was thinking about it the wrong way
17:05:51 <Cale> Base: That list, what type does it have?
17:06:06 <Base> Int
17:06:19 <Cale> Base: Int is not a list type
17:06:34 <Base> ummm can i do it (1,(2,(3 ... ?
17:06:40 <Jedai> Base: the basic list type in Haskell is homogenous, that is every element of it has the type, that is not the case of [1,[2,[3,[4,[5]]]]]
17:07:03 <Jedai> Base: That you can
17:07:07 <Cale> Do you perhaps mean 1 : (2 : (3 : (4 : (5 : [])))) ?
17:07:16 <Cale> Because [1..5] is already equal to that.
17:07:20 <Jedai> Base: But I don't see why that would interest you ?
17:07:38 <Base> It's part of a huge set of questions
17:07:51 <Base> nothing specific
17:08:08 <Cale> > (1, (2, (3, (4, (5, ())))))
17:08:09 <lambdabot>   (1,(2,(3,(4,(5,())))))
17:08:16 <Cale> :t (1, (2, (3, (4, (5, ())))))
17:08:16 <Jedai> Base: if they're course question, I'm pretty sure you don't need (1,(2,(3,4)))
17:08:17 <lambdabot> forall t t1 t2 t3 t4. (Num t4, Num t3, Num t2, Num t1, Num t) => (t, (t1, (t2, (t3, (t4, ())))))
17:08:48 <Cale> ^^ this is a type which you're very unlikely to actually want, basically
17:09:07 <Jedai> Base: I would suggest that trying to use this type is an error itself, you're unlikely to need or want it
17:10:13 <cads> hey, what's a representation of a module that I can use to understand what is meant when people say ML has a first class module system?
17:12:10 <cads> I was thinking of a lambda function that takes a few parameters representing the functional parameters that a module is dependent on,  and returns an associative map of name/function pairs, where the functions are derived in part from the parameters given
17:13:25 <Cale> cads: Well, suppose that we treated the export lists of modules more like the types of values. A module could express that it was parametrised over any module which had a given signature.
17:14:14 <cads> ah, I see
17:15:03 <Cale> cads: A good example of this might be something like all the various libraries for working with HTML, and the various different String and ByteString libraries. An XML/HTML parsing library could say "you can apply me to the string library you'd like to use, and I will parse strings of that type"
17:15:52 <Cale> So the effect is not unlike that of typeclasses, but the way in which things are expressed is somewhat different.
17:16:43 <cads> if we neglect to express it in an algebraic type symbolism, can we realize the above with my module-lambda idea when our module-lambda can receive as a parameter another module lambda, or the associative map produced by instantiating one?
17:17:23 <Cale> I think your idea basically sounds like it.
17:18:00 <aavogt> it there a fundamental reason that ghc needs hs-boot files to compile mutually recursive modules?
17:18:15 <Cale> aavogt: Not a particularly fundamental one.
17:18:49 <Cale> aavogt: But the annoyance of it is enough that I usually try to avoid cyclic module dependencies altogether.
17:19:10 <Cale> aavogt: Usually it's sufficient to move datatypes into a separate module.
17:19:56 <centrinia> Consolidation also helps.
17:20:27 <aavogt> Cale: true. So it hasn't been solved because it isn't annoying enough, not because it is that difficult
17:21:11 <Cale> aavogt: Well, I think it's been designed with a focus on separate compilation. It doesn't really (as far as I know) have a facility for compiling a bunch of modules together as one.
17:22:01 <Cale> It would need to do that, on strongly connected components of the module dependency graph, if it was going to resolve the cyclic dependencies on its own.
17:22:02 <aavogt> I see
17:23:39 <Cale> and yeah, while sometimes it can be annoying, it's usually not *too* hard to jostle things around a bit to remove cyclic dependencies.
17:27:02 <QtPlaty[HireMe]> Has anyone else had problems hitting research.microsoft.com ?
17:27:29 <dolio> It's pretty flakey.
17:50:13 * Baughn uses fmap.fmap.fmap in anger for the first time
17:52:09 <Smorg> Aww, length [0..] doesn't say infinity, it just maxes the cpu. Lame.
17:52:48 <Smorg> and only one core! I demand multi-threaded counting to infinity.
17:52:52 <dolio> > (5 :: Natural) < genericLength [0..]
17:52:53 <lambdabot>   True
17:53:32 <Smorg> hm interesting.
17:53:34 <centrinia> Weird.
17:54:01 <centrinia> > (5 :: Natural) - (6 :: Natural)
17:54:02 <lambdabot>   * Exception: Natural: (-)
17:54:20 <Jedai> > (5 :: Natural) - 3
17:54:22 <lambdabot>   2
17:54:26 <zbanks> With ghc (at least), is it possible to cross compile an executable wo/ having ghc ported to the platform?
17:54:49 <aavogt> > (5 :: Natural) > (iterate succ undefined !! 6)
17:54:51 <lambdabot>   * Exception: Prelude.undefined
17:55:24 <zbanks> For example, could I compile a program for ARM just using the arm toolchain and not porting ghc?
17:56:02 <aavogt> > succ undefined :: Natural
17:56:04 <lambdabot>   * Exception: Prelude.undefined
17:56:33 <aavogt> > (5 :: Natural) > (iterate (1+)  undefined !! 6)
17:56:34 <lambdabot>   False
17:56:46 <Cale> I think that subtraction on naturals should be extended with 0 in the case that the second is larger than the first.
17:56:57 <aavogt> why is Enum for naturals so strict?
17:57:18 <dolio> Probably goes through Int.
17:57:21 <Cale> (because that's how lists behave)
17:57:40 <aavogt> @src Enum Natural
17:57:41 <lambdabot> Source not found. Do you think like you type?
17:57:53 <Cale> Natural is from the numbers package on hackage.
17:58:09 <dolio> > maxBound :: Int
17:58:11 <lambdabot>   9223372036854775807
17:58:26 <dolio> > succ (9223372036854775807 :: Natural)
17:58:29 <lambdabot>   * Exception: stack overflow
17:58:36 <dolio> Heh.
17:59:35 <aavogt> Cale: hmm, in that package: succ = (+1)
18:00:06 <dolio> Oh, that's bad.
18:00:14 <dolio> Should be (1+).
18:00:15 <roconnor> aavogt who says Enum for the Naturals is strict?
18:00:41 <Cale> Uh, that library doesn't define succ at all.
18:00:56 <roconnor> > [0..] :: [Natural]
18:00:56 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
18:00:57 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
18:01:02 <aavogt> http://hackage.haskell.org/packages/archive/numbers/2009.5.18.1/doc/html/src/Data-Number-Natural.html#Natural
18:01:31 <Cale> ah, yes
18:01:52 <aavogt> > 1 > succ (succ undefined) -- roconnor, says this!
18:01:54 <lambdabot>   * Exception: Prelude.undefined
18:02:11 <roconnor> dah
18:02:13 <Cale> Ah, it's (+1) and not (1+)
18:02:17 <aavogt> > 1 > 2+undefined -- should be like this
18:02:18 <lambdabot>   * Exception: Prelude.undefined
18:02:22 <Cale> That's foolish :)
18:02:45 <roconnor> @tell lilac you screwed up your Enum Natural instance.  succ needs to be (1+) not (+1).
18:02:45 <lambdabot> Consider it noted.
18:02:56 <aavogt> > 1 > 1+(1+undefined)
18:02:58 <lambdabot>   * Exception: Prelude.undefined
18:03:17 <dolio> I thought augustss did numbers.
18:03:21 <aavogt> > (1:Natural) > succ (succ undefined) -- roconnor, says this!
18:03:21 <roconnor> > 1 < 1+(1+undefined)
18:03:22 <lambdabot>   Not in scope: data constructor `Natural'
18:03:23 <lambdabot>   * Exception: Prelude.undefined
18:03:29 <Cale> sigh...
18:03:29 <aavogt> > (1::Natural) > succ (succ undefined) -- roconnor, says this!
18:03:31 <lambdabot>   * Exception: Prelude.undefined
18:03:43 <roconnor> > 1 > 1+(1+(undefined::Natural))
18:03:45 <lambdabot>   False
18:03:45 <aavogt> > (1::Natural) > (2+ undefined)
18:03:46 <lambdabot>   False
18:03:48 <Base> okay I'm out
18:03:54 <Cale> There's an excellent natural number library which is smarter about representation anyway... http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nat
18:03:59 <Base> lambdabot thanks a lot for the help
18:04:14 <roconnor> dolio: augustss is the package author, but #haskell upgrades it.
18:04:39 <roconnor> Cale: yes, but lambdabot doesn't come with nat.
18:04:50 <Cale> I could add it...
18:04:52 <dolio> Oh.
18:05:26 <roconnor> Cale: nat's Enum instance is also 60% borked.
18:05:31 <Cale> hmm
18:05:47 <aavogt> Cale: how about StrictCheck in lambdabot too?
18:05:53 <roconnor> Enum Nat really needs a proper full implementation to work properly.
18:07:04 <Cale> aavogt: That seems like more work :)
18:08:00 <Cale> @undefine
18:08:21 <Cale> > (3 :: Nat) + 1
18:08:22 <lambdabot>   /tmp/1017640965175325836:70:46:
18:08:22 <lambdabot>      Not in scope: type constructor or clas...
18:08:25 <Cale> hmm
18:11:58 <copumpkin> :k Nat
18:11:59 <lambdabot> *
18:12:06 <copumpkin> > 3 :: Nat
18:12:07 <lambdabot>   /tmp/1691783180983557560:70:41:
18:12:07 <lambdabot>      Not in scope: type constructor or clas...
18:12:13 <copumpkin> that's odd
18:12:37 <ray> different lambdabot pieces know about it i guess
18:12:57 <copumpkin> yeah, but I remember someone using it earlier
18:14:00 <Smorg> > [0..] == [1..]
18:14:01 <lambdabot>   False
18:14:09 <Smorg> [0..] == [0..]
18:14:13 <Smorg> > [0..] == [0..]
18:14:29 <lambdabot>   thread killed
18:17:39 <EvilTerran> > 0 : undefined == 1 : undefined
18:17:41 <lambdabot>   False
18:18:31 <aavogt> > let let = let in undefined
18:18:33 <lambdabot>   <no location info>: parse error on input `='
18:26:33 <mmorrow> > "[0..]" == "[0..]"
18:26:33 <lambdabot>  Terminated
18:26:39 <mmorrow> hah
18:26:45 <EvilTerran> O.o
18:26:48 <mmorrow> > "[0..]" == "[0..]"
18:26:49 <lambdabot>  Terminated
18:26:57 <Cale> mueval is not installed atm
18:27:01 <EvilTerran> , "[0..]" == "[0..]"
18:27:04 <lunabot>  True
18:27:35 <Cale> hmm
18:28:03 <mmorrow> Cale: a "Segnentaion fault" would be amusing
18:28:04 <Cale> @flush
18:28:17 <mmorrow> *..message would be ...
18:28:36 <Cale> aha, finally
18:28:48 <Cale> I don't think I had enough memory to do the linking for it :)
18:28:54 <mmorrow> heh
18:29:04 <mmorrow> , eval "[0..]"
18:29:09 <lunabot>  <<[Integer]>>
18:29:24 <mmorrow> , fromDynamic (eval "[0..]") :: Maybe [Integer]
18:29:27 <lunabot>  Just [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
18:29:56 <mmorrow> , eval "fromDynamic (eval \"[0..]\") :: Maybe [Integer]"
18:29:59 <lunabot>  <<Maybe [Integer]>>
18:30:28 <Cale> damn seen state...
18:30:55 <Cale> there we go...
18:31:01 <xoclipse> i just wrote a very basic AIM client in haskell, anyone want to check it out? (its just console but does login and some other cool stuff)
18:31:04 <Cale> Now, does it work?
18:31:09 <Cale> > (2 :: Nat) + 1
18:31:17 <Cale> ...
18:31:18 <lambdabot>   3
18:31:20 <copumpkin> woo!
18:31:29 <Cale> Oh, right, it's joining channels, so it's slow :)
18:31:38 <copumpkin> what does Nat buy us?
18:31:52 <Cale> I'm not sure, but it ought to be more efficient than Natural
18:32:01 <copumpkin> > (genericLength [1..]) > 3
18:32:10 <lambdabot>   * Exception: stack overflow
18:32:18 <Cale> > (genericLength [1..] :: Nat) > 3
18:32:24 <lambdabot>   * Exception: stack overflow
18:32:30 <copumpkin> whoops, that's what I meant :)
18:32:33 <Cale> hmm
18:33:06 <mmorrow> does genericLength do that?
18:33:13 <Cale> I wonder...
18:33:30 <copumpkin> is that Nat lazy?
18:33:41 <mmorrow> oh, n/m i didn't see the 'Nat'
18:33:42 <Cale> > Data.Number.Nat.length [1..] > 3
18:33:42 <copumpkin> I thought genericLength was just a fold of const . (+1)
18:33:44 <lambdabot>   * Exception: stack overflow
18:33:48 <Cale> pff
18:33:56 <Cale> > length [1,2,3]
18:33:57 <lambdabot>       Ambiguous occurrence `length'
18:33:57 <lambdabot>      It could refer to either `Data.List....
18:33:59 <Cale> blah
18:34:04 <Cale> I'll have to import it qualified
18:34:07 <aavogt> > (genericLength [1..] :: Nat) < 4
18:34:09 <lambdabot>   * Exception: stack overflow
18:34:40 <Cale> @undefine
18:34:44 <Cale> > length [1,2,3]
18:34:45 <lambdabot>       Ambiguous occurrence `length'
18:34:45 <lambdabot>      It could refer to either `Data.List....
18:34:50 <Cale> wait, what?
18:35:01 <mmorrow> i think it doesn't matter though that it's lazy, since you demand the result that can only be obtained by reaching the end of the list, so it goes..
18:35:02 <Cale> @undef
18:35:15 <Cale> > length [1,2,3]
18:35:16 <lambdabot>       Ambiguous occurrence `length'
18:35:17 <lambdabot>      It could refer to either `Data.List....
18:35:19 <Cale> huh...
18:35:28 <mmorrow> @type length
18:35:29 <lambdabot> forall a. [a] -> Int
18:35:35 <mmorrow> , length ?f
18:35:37 <lunabot>  luna: Unbound implicit parameter (?f::[a])
18:35:39 <mmorrow> > length ?f
18:35:40 <lambdabot>       Ambiguous occurrence `length'
18:35:40 <lambdabot>      It could refer to either `Data.List....
18:35:46 <Cale> oh, stupid
18:35:52 <Cale> I have to change it in mueval too.
18:36:54 <Cale> > length [1,2,3]
18:36:57 <lambdabot>   3
18:37:02 <Cale> > Nat.length [1,2,3]
18:37:03 <lambdabot>   3
18:37:49 <Cale> > compare (Nat.length [1..]) 3
18:37:51 <lambdabot>   * Exception: stack overflow
18:37:54 <Cale> odd
18:37:54 <mmorrow> @type Nat
18:37:55 <lambdabot> Not in scope: data constructor `Nat'
18:38:00 <mmorrow> @type Nat.length
18:38:01 <lambdabot> Couldn't find qualified module.
18:38:08 <mmorrow> > Nat.length
18:38:09 <lambdabot>       Overlapping instances for Show ([a] -> Nat)
18:38:09 <lambdabot>        arising from a use o...
18:38:12 <Cale> oh, yes, one more place I have to change things
18:38:34 <mmorrow> , 1 :: Nat
18:38:34 <lunabot>  luna: Not in scope: type constructor or class `Nat'
18:38:37 <mmorrow> > 1 :: Nat
18:38:38 <lambdabot>   /tmp/4402716139142980055:71:41:
18:38:38 <lambdabot>      Not in scope: type constructor or clas...
18:38:55 <Cale> It really annoys me that just as I finally had all the imports in one place, someone changed things :)
18:38:58 <mmorrow> i wonder why the stack overflow
18:39:24 <mmorrow> oh, that was on an infinite list
18:39:50 <coCoconut> Cale: Just when you get all the answers, they go and change all the questions? ;)
18:40:34 <Cale> @undef
18:40:41 <Cale> :t Nat.length
18:40:42 <lambdabot> forall a. [a] -> Nat
18:40:48 * copumpkin watches StrictAnal and OccurAnal scroll by his screen
18:41:22 <Cale> mmorrow: It still ought to work.
18:42:07 <Cale> > (473893072198403712980473289140 :: Nat) * 43728914073289107498214
18:42:08 <lambdabot>   /tmp/4023223342573982941:71:279:
18:42:08 <lambdabot>      Not in scope: type constructor or cla...
18:42:15 <Cale> > (473893072198403712980473289140 :: Nat.Nat) * 43728914073289107498214
18:42:16 <lambdabot>   1259947102118438840
18:42:23 <Cale> errrrr
18:42:35 <Cale> heh
18:43:11 <mmorrow> weee
18:44:03 <Cale> whaaaaaaaat
18:44:11 <copumpkin> :o
18:44:47 <Cale> @undefine
18:44:50 <Cale> > (473893072198403712980473289140 :: Nat.Nat) * 43728914073289107498214
18:44:51 <lambdabot>   1259947102118438840
18:44:53 <Cale> > (473893072198403712980473289140 :: Nat) * 43728914073289107498214
18:44:54 <lambdabot>   /tmp/2670833402401945774:71:279:
18:44:54 <lambdabot>      Not in scope: type constructor or cla...
18:45:10 <Cale> Okay, I'm also confused about the required qualification thing.
18:45:24 <Cale> Oh, right, it's semi-ignoring the imports in L.hs
18:45:31 <Cale> hmm
18:46:14 <Cale> well, whatever, it looks really broken anyway
19:03:25 <m3ga> @PosixTime
19:03:25 <lambdabot> Unknown command, try @list
19:06:17 <m3ga> @list
19:06:17 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
19:06:41 * Elly attempts to ram monads through her head
19:08:03 <copumpkin> Elly: instead of explicitly trying to learn them, I'd recommend just playing with existing ones and getting a "sense" of them
19:08:20 <Elly> I'm reading http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html, which is making sense so far
19:15:02 <mkaemmer> a question about monad transformers:
19:15:34 <mkaemmer> I have a state transformer: StateT (State StdGen Int) IO()
19:15:48 <mkaemmer> and would like to print the random int...
19:16:20 <mkaemmer> I don't think I'm going about this correctly.
19:17:20 <mkaemmer> does anyone who understands what I'm trying to do have any suggestions?
19:17:46 <kpreid> you have a state monad stuffed in the state of a StateT? I somehow doubt that's what you want
19:17:47 <Lemmih> mkaemmer: StateT StdGen IO a?
19:18:39 <mkaemmer> kpreid: you're probably right
19:19:58 <mkaemmer> the question is... how can I keep track of two states (the int and the seed) and perform IO operations
19:20:23 <saml> > (maxBound :: Int32) - (minBound :: Int32)
19:20:25 <lambdabot>   -1
19:20:48 <saml> > (maxBound :: Int32)  - (minBound :: Int32) :: Int
19:20:49 <lambdabot>   Couldn't match expected type `Int' against inferred type `Int32'
19:20:59 <Elly> hm... I am stuck on the "prove that lift f * lift g = lift (f . g)" part of http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html :(
19:21:59 <kpreid> Elly: I would try substituting in the definition of lift on both sides, to start
19:22:02 <saml> @pl \a b -> f a `g` f b
19:22:02 <lambdabot> (. f) . g . f
19:22:31 <PetRat> I'm reading Typeclassopedia. He suggests that implementing the ((->) e) monad is a good exercise for the reader. I am stumped. I read a bit about the State monad so I'm guessing there will be some kind of definition like newtype Reader e a = {runRead :: e->a}. Can someone confirm if this much is right?
19:22:32 <Gracenotes> g `on` f
19:22:35 <Gracenotes> @src on
19:22:35 <lambdabot> (*) `on` f = \x y -> f x * f y
19:22:37 <Lemmih> mkaemmer: StateT (StdGen,Int) IO a
19:22:50 <saml> can I abstract it?
19:22:51 <saml> oh
19:22:56 <Cale> PetRat: You *could*, but I think the exercise is to define instance Monad ((->) e) where
19:22:57 <saml> @hoogle on
19:22:58 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
19:22:58 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
19:22:58 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
19:23:15 <Cale> PetRat: that is, without a newtype
19:23:26 <PetRat> Cale: then I need a clue.
19:23:40 <Cale> PetRat: Okay, so one clue is that (->) e a = (e -> a)
19:24:08 <Cale> and that in our type signatures the monad m is going to be replaced by (->) e
19:24:28 <mkaemmer> Lemmih: that will probably work. Thanks :)
19:24:36 <Cale> So if m is our monad we have, return :: a -> m a
19:24:40 <PetRat> Hum, let me start with return.
19:24:51 <Cale> So what will it become when we substitute for m?
19:24:55 <Elly> kpreid: that step works, but then I have \x -> (f x, "") * \x -> (g x, "") = \x -> ((f . g) x, "")
19:25:06 <PetRat> return x = \_ -> x ?
19:25:12 <PetRat> or id?
19:25:14 * Elly tries expanding further
19:25:18 <Cale> PetRat: well, yes, but what's the type?
19:25:37 <PetRat> oh, a -> (e->a)
19:25:40 <Cale> right
19:25:48 <kpreid> Elly: Yes, that * would be the problem, I would guess.
19:25:55 <Cale> Now, let's look at (>>=) :: m a -> (a -> m b) -> m b
19:25:57 <kpreid> Elly: And at some point you can throw out the (, "")
19:26:00 <Cale> what does its type become?
19:26:01 <kpreid> (on both sides)
19:26:08 <Elly> kpreid: I'm trying to get it to that point
19:26:27 <PetRat> Okay, so >>= :: (m a) -> (a-> m b) -> m b.  (e->a) -> (a->(e->b)) ->(e->b)
19:26:32 <Cale> yep
19:26:39 <Cale> So...
19:26:47 <Cale> (x >>= f) e = ...
19:27:08 <PetRat> oh it takes e as an argument?
19:27:18 <Cale> well, it has 3 args, yeah?
19:27:25 <Gracenotes> you could say x >>= f = \e -> ...
19:27:29 <Cale> (before producing a value of type b)
19:27:33 <PetRat> oh, also because the result is a function of e
19:27:38 <Cale> right
19:27:52 <Cale> So might as well have all the args on the left of the =
19:28:09 <Gracenotes> combining a monad (function, in this case) with a function to the monad yields another monad (itself a function, in this case)
19:28:17 <Cale> Gracenotes: eek!
19:28:26 <Cale> Do not abuse the word monad!
19:28:31 <Cale> hehe
19:28:45 <Cale> There is only one monad here and it is ((->) e)
19:28:54 <PetRat> does it make sense to drop the inner parenthesis and write (e->a) -> a -> (e->b) -> (e->b). Is that what you mean by three arguments?
19:28:58 <Gracenotes> it is a polymorphic word >_>
19:29:06 <Cale> PetRat: wrong parens
19:29:17 <Cale> (e -> a) -> (a -> e -> b) -> e -> b
19:29:29 <Gracenotes> (e->a) -> (a -> (e->b)) -> (e->b)
19:29:31 <Gracenotes> also
19:29:36 <Gracenotes> as you had above
19:30:11 <Cale> (well, there is one monad for each e)
19:30:30 <Cale> But the important thing is that a monad is something at the type level.
19:30:49 <Gracenotes> yet, a monad instance is itself a type
19:30:59 <Gracenotes> so how to refer to a value whose type is a monad instance? :)
19:31:13 <Cale> A monadic value, computation or action
19:31:20 <Elly> woohoo, I proved lift f * lift g = lift (f . g)
19:31:30 <MyCatVerbs> "Action" is my favourite term for them.
19:31:48 <MyCatVerbs> Monadic value is accurate but too wordy. :)
19:32:09 <MyCatVerbs> "Computation" does not seem specific enough, IMO.
19:33:23 <Cale> PetRat: Does that make sense, anyway?
19:33:32 <Cale> PetRat: -> associates to the right
19:34:07 <Cale> So (e -> a) -> ((a -> (e -> b)) -> (e -> b))  is the same as  (e -> a) -> (a -> e -> b) -> e -> b
19:34:51 <Cale> PetRat: Can you implement a function of that type?
19:34:54 <PetRat> Yes. how about (winces) x >>= f = \e -> f (x e) e
19:35:03 <Cale> right
19:35:22 <Cale> So, there's basically only one way to do it, and that happens to give you a lovely monad.
19:35:46 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
19:35:48 <lambdabot>   ("hello","olleh","HELLO")
19:36:06 <Cale> > join (*) 5
19:36:07 <lambdabot>   25
19:36:26 <Cale> > sequence [id,(+2),(*2),(^2),(2^)] 5
19:36:27 <PetRat> okay that wasn't too hard after I got unconfused. I wasn't sure what to do with 'e'. Note that in the line "instance Monad ((->) e)" e is a type variable, but I also used e as a value.
19:36:27 <lambdabot>   [5,7,10,25,32]
19:36:38 <Cale> PetRat: oh, yes
19:36:40 <Cale> e :: e
19:36:43 <Cale> ;)
19:36:53 <PetRat> Cale: are these demonstrations of the reader monad?
19:37:02 <Cale> effectively
19:37:12 <Cale> Though usually I just call this the function monad
19:37:20 <Cale> and the wrapped up one Reader
19:37:25 <kpreid> > (sequence $ map (\n -> iterate n drop) [0..5]) "hello"
19:37:26 <lambdabot>   Couldn't match expected type `(->) t' against inferred type `[]'
19:37:49 <kpreid> > (sequence $ map drop [0..5]) "hello"
19:37:50 <lambdabot>   ["hello","ello","llo","lo","o",""]
19:37:52 <PetRat> Oh I see. in the ("hello", ...) example each line is a function.
19:37:56 <BMeph> kpreid: replicate, vice iterate, maybe? :)
19:38:00 <PetRat> what is join?
19:38:02 <Cale> PetRat: right
19:38:18 <kpreid> BMeph: eh?
19:38:21 <Cale> join x = do y <- x; v <- y; return v
19:38:36 <Cale> join :: (Monad m) => m (m a) -> m a
19:38:52 <aavogt> > mapM drop [0..5] "hello"
19:38:53 <lambdabot>   ["hello","ello","llo","lo","o",""]
19:39:05 <Cale> Alternately,  join x = x >>= id
19:39:07 <kpreid> aavogt: ooh
19:39:17 <BMeph> kpreid: Trying to figure out what "\n -> iterate n drop" was supposed to do. :)
19:39:27 <kpreid> I was overdoing it
19:39:35 <kpreid> "iterate n tail"
19:39:37 <PetRat> Is there an intuitive description of join?
19:40:00 <copumpkin> flattening a nested monad!
19:40:00 <Cale> PetRat: Basically, if you have an action which produces another action as its result
19:40:01 <copumpkin> ;)
19:40:07 <aavogt> > tails "hello"
19:40:09 <lambdabot>   ["hello","ello","llo","lo","o",""]
19:40:17 <copumpkin> aavogt: it's like being in a cave!
19:40:21 <Cale> PetRat: Then you can construct an action which when run, runs this action, and then runs its result
19:40:52 <kpreid> PetRat: For imperative-ish monads, it's "Figure out what to do, then do it"
19:41:14 <PetRat> I see. (*) is a function of two arguments or in a curried sense a function of one argument which gives a function of one argument.
19:41:20 <kpreid> join (return x) = x
19:41:21 <Cale> PetRat: right :)
19:41:48 <Cale> For containerish monads, it's often something like concatenation
19:41:56 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
19:41:58 <lambdabot>   [1,2,3,4,5,6,7,8]
19:42:24 <Cale> Thinking of the list monad in terms of making selections, it first picks a list, then picks an element from it, in all possible ways
19:42:34 <Cale> and that gives the concatenation of the lists :)
19:43:02 <PetRat> Yes I've worked with the list monad a bit, from RWH, although I think moving over to Typeclassopedia is giving a better background for it.
19:43:40 <Cale> > [y | x <- [[1,2,3],[4,5],[6,7,8]], y <- x]
19:43:42 <lambdabot>   [1,2,3,4,5,6,7,8]
19:43:53 <PetRat> For all of RWH's 700 pages, when they get to monads and monad transformers it sure feels like they are racing through the material.
19:43:54 <Cale> > do x <- [[1,2,3],[4,5],[6,7,8]]; y <- x; return y
19:43:56 <lambdabot>   [1,2,3,4,5,6,7,8]
19:44:11 <Cale> Or even:
19:44:15 <Cale> > do x <- [[1,2,3],[4,5],[6,7,8]]; x
19:44:16 <lambdabot>   [1,2,3,4,5,6,7,8]
19:44:40 <ray> i think it's more that monads and monad transformers need a slower pace
19:45:15 <PetRat> ray: that's what I was trying to say actually---that there's so much to learn about Haskell.
19:45:21 <Cale> Monad transformers are a strange topic to approach. They're a library design technique more than they are an application programming technique.
19:45:26 <fynn> Slightly offtopic, but what's a good resource (book, URL, whatever) for algorithms & data structures problems, preferably with solutions?
19:45:43 <ray> monad transformers are weird
19:45:43 <fynn> Ideally, something that would take a good solver 10-60 minutes to solve.
19:46:08 <ray> sicp exercises? i dunno
19:46:33 <fynn> I'm interviewing a guy for a job, and looking for some question ideas.
19:46:59 <fynn> We're looking to use Haskell soon, so it's slightly on topic :>
19:47:13 <copumpkin> purely functional data structures?
19:47:15 <lament> ooooh hire me hire me
19:47:37 <fynn> lament: your username suggests I shouldn't :/
19:47:37 <roconnor> no no hire me!
19:47:47 <roconnor> lament couldn't program his way out of a paper bag
19:47:52 <fynn> heh, PM me your resumes.
19:47:53 * copumpkin laments lament's lack of a job
19:48:11 <lament> fynn: we can negotiate a username change if necessary ;)
19:48:13 <roconnor> fynn: where is the job?
19:48:14 <copumpkin> no no hire me! roconnor couldn't program his way out of a paper bag
19:48:21 <fynn> roconnor: Bay area.
19:48:29 <roconnor> ack!
19:48:34 <copumpkin> besides, I have the coolest nick ev4r
19:48:43 <copumpkin> and 1 wr1t3 1n l33t
19:48:52 <roconnor> might as well hire copumpkin then.
19:48:53 * copumpkin b34mz
19:48:55 <fynn> ooh, such class.
19:48:59 <ray> monads would be so much easier to understand if the prelude let you define them with join
19:49:08 <fynn> anyways, I'm still looking for good interview problems :|
19:49:11 * copumpkin b0wz
19:49:16 <roconnor> fynn: I did the whole Berkeley grad school thing.
19:49:22 <copumpkin> fynn: will they be programming problems or just conceptual?
19:49:23 <roconnor> already
19:49:33 <fynn> copumpkin: programming problems for sure.
19:49:48 <fynn> the guys is pretty good, I need to know he can actually solve programming probelms.
19:50:06 <lament> roconnor: damn
19:50:08 * lament folds
19:50:11 <fynn> that said, they should also contain some theoretical challenge
19:50:16 <Cale> This job demands fluent 13375p34k, and it is expected that applicants will file their resumes in it.
19:50:21 <copumpkin> lol
19:50:47 <roconnor> lament: if it helps, I dropped out of my PhD program at Berkeley.
19:50:55 <copumpkin> roconnor: why?
19:50:55 <ray> and people complain about resumes that have to be in word
19:51:09 <lament> roconnor: to get a masters?
19:51:13 <roconnor> copumpkin: they have no intrest in dependent type theory there.
19:51:15 <copumpkin> yeah, resumes must be .nfo files with l33tspeak and ascii art
19:51:20 <lament> roconnor: isn't that the usual swindle anyhow?
19:51:30 <copumpkin> roconnor: there seems to be less interesting PL in the US in general, I've found
19:51:34 <roconnor> ... interdisciplinary logic program my ass
19:51:51 <ray> resumes must be in the form of a bittorrent ratio, references from at least 2 private torrent trackers required
19:51:56 <fynn> you guys are so not helpful :>
19:52:01 <copumpkin> fynn: aw, sorry
19:52:09 <copumpkin> fynn: try purely functional datastructures though
19:52:09 <fynn> hehe, it's OK, I have more than enough questions.
19:52:17 <fynn> just wondering if you have any good suggestions.
19:52:22 <roconnor> fynn: ask him to write a memoized list of prime numbers generator.
19:52:26 <roconnor> in haskell
19:52:35 <fynn> roconnor: I actually thought about that particular problem.
19:52:49 <ray> ask him to write a haskell numeric prelude
19:52:54 <copumpkin> fynn: are you just trying to find out if they know what they're talking about when it comes to haskell?
19:52:55 <fynn> the candidate is very good at math, so I don't want to play to his strengths.
19:52:58 <copumpkin> or a deep thinking problem?
19:53:13 <roconnor> fynn: I think that primes problem separates the haskell n00bs from the slightly less newbies.
19:53:20 <fynn> copumpkin: the latter. we plan to integrate Haskell, but knowing Haskell now is not a requirement.
19:53:25 <copumpkin> I see
19:53:54 <lament> fynn: mad props for using haskell!
19:54:18 <fynn> the guy has a PhD from a math related field, so I'm mainly going to see how he handles CS theory, and ultimately also solving a hard problem with actual code.
19:54:43 <roconnor> fynn: is his name Josh?
19:54:48 <fynn> he's placed well in math competitions etc, I'm not concerned that he is dumb, but I am concerned he may be too detached.
19:55:05 <fynn> i.e. unable to solve practical problems and actually code.
19:55:26 <fynn> lament: thanks. we were using Python, and looking for something stateless and fun, so Haskell seemed a good choice :)
19:55:51 <roconnor> heh, inability to solve practical problems could be a general problem with Haskell programmers :P
19:56:07 <ray> no way, there's language communities that are a lot worse
19:56:23 <fynn> roconnor: well, it wouldn't fly here, that's for sure =)
19:56:39 <lament> fynn: then don't ask algorithms questions, ask practical questions
19:56:40 <roconnor> fynn: how long is the interview?
19:56:49 <fynn> roconnor: 60-90 minutes.
19:56:51 * BMeph coughs: *Smalltalk!* Man, these spring colds are the worst! ;p
19:56:53 <roconnor> hmm
19:57:13 <ray> my cough sounds like "common lisp" for some reason
19:57:20 <lament> fynn: memoized primes are hardly a practical problem
19:57:55 <ray> memoizing in general
19:58:15 <fynn> lament: my current plan is: first 30 minutes - rapid fire knowledge questions about practical topics (operating systems, concurrency, concrete programming language aspects, how data structure are implemented in practice), and rapid fire "code a solution to a fairly trivial problem"
19:58:25 <roconnor> fynn: I'm pondering some if the ICFP contest puzzle problems from 2006, but they might be too hard.
19:58:47 <fynn> rest 60 minutes: 1-3 truly complex questions, and he has to code a solution.
19:59:08 * copumpkin screams at libffi
19:59:10 <roconnor> code a solution in what language?
19:59:15 <fynn> roconnor: definitely; a question may not take more than 60 minutes total, and I want to see semi-working code on the board.
19:59:19 <fynn> whatever language he likes.
20:00:10 <roconnor> how hard was that plinko problem?  ... but it was kinda math related.
20:00:12 <roconnor> oh
20:00:19 <roconnor> how about those google treasure hunt problems
20:00:29 <fynn> never heard for that, I'll look at it.
20:00:31 <roconnor> they were ridicuously easy.
20:00:39 <roconnor> at least I found
20:00:48 <roconnor> ... some of the solutions reddit came up with
20:00:52 * roconnor shakes his head
20:01:07 <fynn> heh. candidates in the past complained our questions were too easy :)
20:01:20 <fynn> at least one good guy we hired thought they were.
20:01:21 <copumpkin> fynn: are you allowed to tell us what company that is?
20:01:33 <fynn> copumpkin: not really, and we're a startup :)
20:02:32 <copumpkin> ah :)
20:03:05 <roconnor> you could ask him to implement a bag data type, and then implement a set data type reusing the bag code.
20:03:19 <roconnor> and sees if he screws it up.
20:03:41 <fynn> even in this area (MTV / Palo Alto and the neighborhood) I don't know of companies using Haskell
20:03:42 * roconnor remembers reading Oleg's essay on that last week.
20:03:55 <fynn> I heard of one other startup that does, but don't know too much about them.
20:05:35 <roconnor> http://okmij.org/ftp/Computation/Subtyping/
20:05:47 <fynn> in any case, thanks for your input. I'm sure you were mostly joking; doubt anyone here has a serious problem getting a job ;)
20:06:06 <roconnor> hopefully I will get my fellowship
20:06:10 <roconnor> then i won't need a job
20:06:34 <lament> fynn: getting a job is one thing
20:06:41 <m3ga> i'm coding on Linux and using Hoogle, but find that Hoogle is missing a bunch of stuff. ie System.Time. Is there an alternative to Hoogle that covers Linux/Posix stuff better?
20:06:45 <lament> getting a haskell job is quite another :)
20:07:02 <roconnor> lament: good point
20:07:13 <roconnor> @hoogle Time
20:07:13 <lambdabot> module Data.Time
20:07:14 <lambdabot> package time
20:07:14 <lambdabot> Data.Time.LocalTime data TimeOfDay
20:07:21 <roconnor> @hoogle+
20:07:21 <lambdabot> Data.Time.LocalTime TimeOfDay :: Int -> Int -> Pico -> TimeOfDay
20:07:21 <lambdabot> Data.Time.LocalTime timeOfDayToDayFraction :: TimeOfDay -> Rational
20:07:21 <lambdabot> Data.Time.LocalTime timeOfDayToTime :: TimeOfDay -> DiffTime
20:07:25 <roconnor> hmm
20:07:29 <roconnor> @hoogle posix
20:07:29 <lambdabot> module Data.Time.Clock.POSIX
20:07:29 <lambdabot> module System.FilePath.Posix
20:07:29 <lambdabot> package posix-realtime
20:07:32 <fynn> lament: true, hopefully the selection would increase as time goes by.
20:07:43 <lament> m3ga: try hayoo
20:07:44 <m3ga> @hoogle System.Time
20:07:44 <lambdabot> package time
20:07:44 <lambdabot> module System.Timeout
20:07:44 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
20:07:55 <lament> m3ga: http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:08:06 <roconnor> I wonder if it is that System.Time is depricated?
20:08:14 <fynn> there's certainly more awareness now, especially with more tools maturing, e.g. the Haskell Platform.
20:08:24 <fynn> (and Hackage, Cabal, etc.)
20:08:40 <fynn> more *practical
20:09:05 <m3ga> lament: thanks, interface not quiet as nice but it works
20:09:23 <roconnor> fynn: if I don't get my fellowship, you should move your start-up to Waterloo Ontario.
20:09:27 <roconnor> :P
20:09:43 <m3ga> roconnor: i think the problem os that hoogle run on windows and hence can't query packages that only run on Posix
20:10:04 <roconnor> m3ga: I don't think that is the case, but I'm not sure.
20:10:11 <fynn> roconnor: you can easily work remotely from there for some American companies :)
20:10:29 <roconnor> http://www.haskell.org/hoogle/?hoogle=posix
20:10:46 <roconnor> perhaps.
20:11:14 <fynn> btw, how can one "not get a fellowship"?
20:11:38 <roconnor> fynn: there are only a certain number of fellowships available.
20:12:21 <fynn> roconnor: can't you just go on a PhD program anyway?
20:12:43 <roconnor> this is a post-doctoral fellowship
20:12:48 <roconnor> oh
20:12:58 <roconnor> right, after dropping out at Berkeley I went to the Netherlands
20:13:07 <roconnor> where they actually do research into type theory
20:13:16 <fynn> ah, I thought you didn't finish your PhD
20:13:29 <gwern> @quote PhD
20:13:30 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
20:13:38 <roconnor> fynn: ya, sorry for misleading you.
20:13:41 <gwern> @quote PhD
20:13:41 <lambdabot> dons says: so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
20:13:50 <gwern> hm.
20:13:52 <gwern> @quote PhD
20:13:52 <lambdabot> dons says: so, anyone else plan on getting a phd in haskell studies, so they can get a job at a big investment bank? :)
20:13:52 <roconnor> that was my plan
20:13:56 <roconnor> untill last year.
20:13:59 <roconnor> :)
20:14:03 <gwern> heh
20:14:08 <gwern> jane street' still around
20:14:13 <roconnor> yep
20:14:16 <fynn> heh, what happened last year?
20:14:22 <gwern> I'm sure ocaml wouldn't be *too* painful...
20:14:30 <roconnor> every big investment bank went under.
20:14:36 <m3ga> jane street say they quite like the current market
20:14:38 <gwern> fynn: the tide went out, per buffett
20:14:54 <gwern> m3ga: I guess, if they had enough cash to spare to fund haskell projects
20:15:08 <roconnor> jane street isn't a big investment bank. :)
20:15:17 <fynn> gwern: mhm, yeah, I can understand what you mean
20:15:21 <fynn> but what roconnor just said
20:15:35 <fynn> though it certainly didn't help the entire market.
20:16:02 <fynn> but sure, lots of laid off financial programmers now seeking employment in different areas.
20:16:12 <lament> and not just financial
20:16:25 <lament> microsoft laid off thousands of people
20:16:31 <gwern> (a good fund should be able to profit off the volatility and general chaos, but who knows how many of those there are)
20:16:33 <roconnor> heh, especially since the disaster was "all their fault"
20:16:47 <gwern> lament: which was a little odd, since MS has tons of money and just raised billions more
20:16:55 <fynn> lament: only few of them actual programmers, no?
20:17:01 <roconnor> MS raises money?
20:17:17 <lament> dunno the numbers
20:17:28 <gwern> roconnor: oh sure. a few days ago they finished up a multi-billion $ bond offer
20:17:33 <fynn> rumor is, lots of places that are firing, including MS, are just using the events as execuses to get rid of dead wood.
20:17:52 <gwern> made headlines because this apparently is the first time MS has ever sought outside capital like that
20:18:14 <gwern> people're interested because it looks like a move most useful if they're going after yahoo again
20:18:42 <lament> yahoo should get a restraining order against them
20:18:54 <fynn> they probably will. I doubt they'll stop until they acquire one giant web hub.
20:19:02 <fynn> and not too many of those around.
20:19:16 <lament> at least google isn't in any danger at the moment
20:19:26 <lament> and yahoo, who really cares :)
20:19:35 <fynn> there's absolutely no reason why they would be prevented from buying yahoo. it's a quirk they weren't able to in the first place.
20:19:37 <gwern> heh. no, eric schmidt sounded quite upbeat this weekend
20:19:39 <ttmrichter> Is there anybody connected who knows anything about porting GHC to a currently unsupported platform?  The docs available are out of date and specifically say they don't apply to any version past 6.4.
20:19:47 <gwern> (he was speaking at the CMU commencement)
20:20:08 <dmwit> ttmrichter: You might want to hang around in #ghc.
20:20:09 <sclv> what platform?
20:20:31 <ttmrichter> dmwit: Ah!  Didn't know it existed.  sclv: OpenSolaris.
20:20:39 <gwern> ttmrichter: might try the ghc channel. my understanding is that the procedure is to take one of the old bootstrapping ghcs, and then compile ghcs until you've gotten up to something new
20:20:54 <copumpkin> ttmrichter: it's mostly supported now in 6.11 again
20:20:55 <gwern> ttmrichter: also, solaris? there's a blog about getting ghc running on sparc
20:21:01 <sclv> there's been lots of solaris work done lately, as i recall.
20:21:07 <ttmrichter> gwern: OpenSolaris x86, not Sparc.
20:21:40 <ttmrichter> But if GHC is being moved to Solaris already, perhaps waiting is better than driving myself insane with the bootstrapping.  :D
20:22:02 <sclv> i'd search the -cafe archives? i seem to recall donn cave did some work a few mos back?
20:22:33 <sclv> if the archives confirm my recollections you could try contacting him directly and see what he has working at the moment too.
20:23:26 <roconnor> gwern: ah, bonds.  That makes sense.
20:23:52 <gwern> well sure. how else would they raise money?
20:24:59 <roconnor> gwern: um .. venture capital?
20:25:02 <roconnor> :P
20:25:22 <roconnor> gwern: more seriously, issuing new stock
20:25:33 <gwern> ? and who precisely would be giving the VC stock? why would existing shareholders authorize dilution?
20:25:35 <roconnor> but both those seem completely implausible.
20:25:43 <roconnor> hence my question.
20:41:31 <amckinley> hey, parsec question: im parsing bind config files, which have the incredibly annoying property that if you omit the hostname for a record, the record assumes the hostname of the previous record. i have no idea how to modify my more-or-less line oriented parser to handle that case
20:42:19 <dmwit> Use Parsec's state.
20:42:35 <dmwit> It's got "get" and "set" functions.
20:44:28 <amckinley> dmwit: can you give me a little more guidance? im still new to haskell
20:45:38 <dmwit> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#getState
20:45:51 <dmwit> When you read a hostname, set the state using setState.
20:46:06 <dmwit> If you read a record with no hostname, set it to the current state by calling getState.
20:46:51 <dmwit> You could also just read the records in, record which ones didn't have a hostname, and fill them in after the entire parsing stage was done.
20:47:16 <dmwit> (Which wouldn't require the getState/setState functions at all.)
20:48:44 <amckinley> dmwit: i was under the impression that parsec's state was for deep internal parsec magic. are you saying you can put arbitrary state in it?
20:48:57 <dmwit> There's parsec state and user state.
20:49:04 <dmwit> getState/setState/updateState modify the user state
20:49:14 <amckinley> ahhhhh, gotcha
20:50:32 <amckinley> thanks a bunch
20:54:46 <roconnor> @hoogle ReaderT r m a -> StateT r m a
20:54:47 <lambdabot> No results found
20:54:49 <roconnor> :(
20:57:07 <grncdr> what is the deal with Int vs. Integer?
20:57:19 <grncdr> <- total haskell noob
20:57:31 <roconnor> > maxBound :: Int
20:57:33 <lambdabot>   9223372036854775807
20:57:35 <roconnor> > maxBound :: Intenger
20:57:36 <lambdabot>       Not in scope: type constructor or class `Intenger'
20:57:42 <roconnor> > maxBound :: Integer
20:57:43 <lambdabot>       No instance for (Bounded Integer)
20:57:43 <lambdabot>        arising from a use of `maxBoun...
20:57:51 <roconnor> , maxBound :: Int
20:57:52 <lunabot>  2147483647
20:58:00 <roconnor> > 2^100 :: Int
20:58:01 <grncdr> ah I see
20:58:01 <lambdabot>   0
20:58:04 <roconnor> > 2^100 :: Integer
20:58:05 <lambdabot>   1267650600228229401496703205376
21:16:51 <jbhatta> i'm trying to use getopts.  the examples i've found suggest that the best way to take care of options with arguments is to wrap them in a type that encapsulates the argument
21:17:35 <jbhatta> and then make a type that can hold any one of the types i just made so i can have a list of 'em
21:18:13 <jbhatta> but now i've got a list of these things, and i don't really know how to deal with them functionally.  i need to do different things with different options, but sometimes multiple options interact, etc
21:18:42 <jbhatta> is there some kind of trick that i should be aware of, or do i need to write a bunch of exhaustive function definitions matching each possible pattern combination or something awful like that?
21:20:04 <jbhatta> i'm sure i don't have to do something that awful, because i doubt that this community would endorse a getopts implementation that forced them to do something that ugly
21:20:23 <jbhatta> but i'm new to haskell, so the best solution is far from obvious to me
21:21:01 <bos> jbhatta: i think there's an example in RWH
21:21:21 <MyCatVerbs> Usually you want something like, data Flag = ConfigFile FilePath | DebugMode Bool...
21:22:06 <pumpkin> thoughtpolice: *poke*
21:22:09 <jbhatta> MyCatVerbs: i've done that, but now i've got a list of flags from getopts and i'm not sure how to process them
21:22:41 <jbhatta> MyCatVerbs: for example, i have one switch that takes no arguments that will call a different function to do the main work
21:22:53 <jbhatta> and one required option with an argument pointing to a config file
21:23:29 <jbhatta> i always want to read that required option, but once i do, i want to use its argument when i call the function picked by specifying the other option (the "switch" i mentioned)
21:24:44 <MyCatVerbs> jbhatta: hol' up. You *are* using System.Console.GetOpt, rather than raw GetArgs?
21:25:06 <jbhatta> MyCatVerbs: yeah, i am
21:25:20 <MyCatVerbs> Right. So that handles required or non-required arguments for you.
21:25:37 <jbhatta> i think my problem is so basic that it's difficult to describe
21:25:49 <jbhatta> i'm going to get a list from getopts of flags
21:25:55 <MyCatVerbs> The list it hands back to you is just what you'd get it you repeatedly called getopt(3) in C.
21:26:15 <MyCatVerbs> (Well, in spirit anyway).
21:27:19 <MyCatVerbs> You can do things like scan the list for all of the instances of a particular option, remove those and set flags of some description...
21:29:03 <jbhatta> hmmm, i didn't think to actively scan the list looking for options
21:29:04 <MyCatVerbs> e.g. (options,nonoptions,errors) <- getOpt Permute optionspec args
21:29:32 <MyCatVerbs> let debugMode = elem (DebugMode True) options
21:30:14 <jbhatta> ah, ok
21:30:19 <MyCatVerbs> let filesToFoo = [ file | (Foo file) <- options ]
21:30:35 <MyCatVerbs> mapM foo filesToFoo -- :)
21:31:21 <MyCatVerbs> (That list comprehension is just a map and filter together. Extracts all the Foo elements from options.)
21:31:59 <jbhatta> ah, ai see what u did thar
21:32:02 <jbhatta> what's mapM?
21:32:19 <MyCatVerbs> Er, should usually be mapM_. mapM = sequence . map
21:32:37 <MyCatVerbs> sequence takes a list of actions, and runs them one after another.
21:32:58 <jbhatta> is it kinda like fold?
21:33:03 <jbhatta> what type do "actions" have?
21:33:11 <jbhatta> functions returning monadic types or something?
21:33:20 <MyCatVerbs> When I say "actions" I'm talking about monadic values.
21:33:31 <jbhatta> ah, ok, spiffy
21:33:44 <MyCatVerbs> sequence :: (Monad m) => [m a] -> m [a]
21:34:20 <jbhatta> whoa, ok
21:34:26 <MyCatVerbs> e.g. mapM putStrLn ["foo","bar","baz"] -- prints "foo\nbar\nbaz\n" to stdout, and returns [(),(),()] because putStrLn's result is always ().
21:34:58 <jbhatta> MyCatVerbs: gotcha.  cool, ok, so i'm learning a lot today
21:34:58 <jbhatta> hehe
21:35:20 <MyCatVerbs> mapM_ putStrLn ["foo","bar","baz"] -- is another IO action that does the same thing, but returns just (), which isn't much less useful than [(),(),()]. :)
21:35:52 <jbhatta> does it return the last thing it evaluates or something?
21:35:57 <MyCatVerbs> mapM_ is useful when you don't care about the return values, because mapM_ never needs to hold on to them, so the garbage collector can just throw the return values away right away.
21:36:03 <jbhatta> ah, ok
21:36:13 <jbhatta> so it just ALWAYS returns ()
21:36:16 <MyCatVerbs> Ah, no. I should've explained that. It throws *all* the results away.
21:36:23 <MyCatVerbs> @type mapM_
21:36:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
21:36:49 <jbhatta> ok
21:37:21 <MyCatVerbs> It takes actions of all types, runs them, then sends the results away to die lonely and unloved in the middle of the Australian Great Bugger All.
21:37:36 <jbhatta> hehehe
21:37:46 <MyCatVerbs> Er, any, not all. You won't usually get too far with a mixed list. >>
21:40:13 <MyCatVerbs> jbhatta: mapM_ foo filesToFoo is just a convenient way to write: let { fooAllFiles (file:files) = foo file >> fooAllFiles; fooAllFiles [] = return (); } in fooAllFiles filesToFoo
21:40:39 <MyCatVerbs> jbhatta: I hope you'll agree that it's a lot more convenient to use the short combinators for the simple cases.
21:41:02 <jbhatta> oh yes, absolutely
21:41:17 <jbhatta> i'm just a n00b, so i end up looking stuff up pretty frequently
21:41:31 <MyCatVerbs> @where hoogle
21:41:31 <lambdabot> http://haskell.org/hoogle
21:41:43 <jbhatta> ah yes.  i have learned of the magic of hoogle
21:42:28 <MyCatVerbs> jbhatta: I still rarely do anything much without the haddock docs at hand. ^^
21:43:11 <jbhatta> yeah, it's tricky.  luckily haskell is weirdly natural to document
21:43:12 <jbhatta> hehe
21:43:25 <jbhatta> so i've seen thus far, anyway
21:43:48 <jbhatta> i'm using xmonad, and the xmonad libraries are freaking HUGE
21:43:57 <jbhatta> but it's still pretty easy to look things up and figure them out
21:44:06 <jbhatta> thankfully!
21:44:14 <dmwit> Yay!
21:44:21 <jbhatta> :-D
21:44:23 <dmwit> This is AWEsome praise!
21:44:52 <jbhatta> dmwit: do you maintain or just advocate the xmonad docs?  ;)
21:45:21 <dmwit> Well, there's been a lot of talk recently about improving the docs for Haskell libraries.
21:45:28 <dmwit> So if somebody finds some of them good... =)
21:46:30 <jbhatta> hehehe.  i like their consistent format, and haskell's type declarations are just so good you can usually just read the types and the name of the function and it's nice.  but then there's a description at the end of the doc just in case!
21:46:34 <jbhatta> i think it's pretty nice
21:48:37 <hatds> agreed
21:49:15 <jbhatta> and it's also nice that you guys seem friendlier than some of the lisp guys i got used to dealing with ;)
21:49:23 <hatds> and random unfamiliar source in the libraries is often easy to read too
21:49:45 <hatds> :)
21:51:35 <roconnor> in #haskell we don't pretend to even know how to program properly yet. :)
21:51:59 <p_l> jbhatta: we no longer bite, believe me (well, I'd recommend staying away from c.l.l, no matter your level, aptitude etc.)
21:52:20 <pumpkin> ChilliX: I think I have a ghc x86_64 for mac os almost working!
21:52:29 <MyCatVerbs> p_l: "no longer"? I didn't think we ever bit much at any point? :/
21:52:48 <p_l> MyCatVerbs: I spoke as #lisp denizen ;P
21:53:17 <MyCatVerbs> p_l: oh, phew.
21:53:26 <jbhatta> p_l: ah, well that's good to hear!
21:53:32 <jbhatta> i admit i was kinda scared off
21:53:34 <jbhatta> hehe
21:54:22 <roconnor> p_l: I find it hard to believe #lisp is that bad, yet I hear so many stories.
21:54:26 * p_l also heard tales of how #lisp was a scary place... but it's no longer (unless you troll). comp.lang.lisp is a loss of time, IMHO
21:55:19 <rickasauruss> I hoogle all my searches
21:55:26 <p_l> and well, stupid questions are not welcome, and sometimes you can make them even by mistake :)
21:56:14 <jbhatta> p_l: yeah, i'm known to do that pretty often.  that was probably my downfall in #lisp
21:58:08 <lament> is rahul in #lisp?
22:01:08 <p_l> lament: I don't recognize that nick
22:03:30 <lament> amazing
22:03:37 <Adamant> #lisp is fine, it was never particularly bad. c.l.l is a cesspit.
22:04:16 <Adamant> and #haskell is very nice and welcoming of newcomers.
22:05:06 <mintsoup> are haskell guards dijkstra guards?  like, if more than one is true is one branch chosen nondeterministically?
22:05:06 <MyCatVerbs> Slightly more so than it was a couple months back, even.
22:05:18 <dmwit> mintsoup: no
22:05:20 <MyCatVerbs> mintsoup: no. They're more like Prolog pattern matches.
22:05:24 <Saizan> mintsoup: the first one is chosen
22:05:31 <MyCatVerbs> mintsoup: they're tried in order from top to bottom, and the first matching one is used.
22:05:33 <dmwit> mintsoup: The first matching guard is chosen, with "first" being defined syntactically.
22:06:00 <mintsoup> thanks
22:15:28 <jbhatta> gawd, curried functions are definitely the best thing ever
22:16:25 <jbhatta> so FREAKING handy
22:16:45 <jbhatta> yaaay for this language
22:17:34 <araujo> @yarr!
22:17:35 <lambdabot> Arrr!
22:30:36 <mushtar> Can we extract the contents of a monad by using a function, contents m = (m >>= id) ?
22:30:49 <pumpkin> :t (>>=)
22:30:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:31:17 <pumpkin> :t \m -> m >>= id
22:31:18 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
22:31:21 <pumpkin> :)
22:31:23 <sjanssen> @type join
22:31:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:31:33 <mushtar> hm
22:31:37 <mushtar> and how do you write join?
22:31:42 <pumpkin> exactly as you did
22:32:01 <shachaf> mushtar: A monad doesn't have "contents".
22:32:04 <pumpkin> > let contents m = (m >>= id) in contents [[1,2,3], [4,5,6]]
22:32:05 <lambdabot>   [1,2,3,4,5,6]
22:32:07 <pumpkin> !
22:32:08 <pumpkin> :)
22:32:09 <shachaf> > fromJust Nothing
22:32:10 <lambdabot>   * Exception: Maybe.fromJust: Nothing
22:32:15 <mushtar> shachaf: Why does a monad not have "contents"?
22:32:24 <shachaf> Because you're confusing types and values, for one.
22:32:31 <shachaf> Just x is not a monad; Maybe is.
22:32:31 <pumpkin> mushtar: what would contents of [1,2,3] be?
22:33:05 <mushtar> Hm I see
22:33:33 <pumpkin> certain monads might have functions for pulling a value "out of them"
22:33:37 <pumpkin> but in general it isn't possible
22:33:46 <pumpkin> because for many monads it doesn't make sense
22:33:56 <mushtar> so in general you can't run a monad, but if you have a monad inside a monad, you can extract that inner monad?
22:34:07 <mushtar> even without having a function that pulls the value out?
22:34:13 <shachaf> Not "out of the monad", but "out of values whose type is the monad"
22:34:20 <shachaf> (Or at least that's closer.)
22:34:28 <mushtar> yes
22:34:42 <shachaf> mushtar: You can't extract anything from a monad.
22:34:48 <shachaf> > join (Just Nothing)
22:34:49 <lambdabot>   Nothing
22:34:56 <Cale> If you want, the contents of a monad are all the types which belong to it.
22:34:59 <mushtar> so join has type m (m a) -> m a. but it does this without ever running the monad?
22:34:59 <shachaf> > join (Nothing :: Maybe (Maybe Int))
22:35:00 <lambdabot>   Nothing
22:35:15 * pumpkin pokes thoughtpolice
22:35:15 <shachaf> mushtar: "running"?
22:35:20 <Cale> But I don't think that's what people are talking about here :)
22:35:34 <mushtar> shachaf: yes, running the monad?
22:35:40 <shachaf> What does that mean?
22:35:45 <mushtar> shachaf: monads are computations right?
22:35:47 <Cale> (That is, the contents of the IO monad are all the types IO t for each t :)
22:35:53 <pumpkin> mushtar: they can be thought of them
22:35:56 <pumpkin> *as
22:36:36 <Cale> monads are type constructors which construct types whose values can often be thought of as computations
22:36:40 * pumpkin is trying to get people excited about his breakthrough with ghc, but no one who cares is around :(
22:36:41 <mushtar>  > join (Nothing)
22:36:52 <Cale> pumpkin: breakthrough?
22:37:02 <pumpkin> I got ghc working on x86_64 on mac os :)
22:37:03 <mushtar> > join (Nothing)
22:37:04 <lambdabot>   Nothing
22:37:10 <mushtar> so why does that work?
22:37:22 <Cale> mushtar: Because Nothing :: Maybe (Maybe t)
22:37:30 <dibblego> > Nothing :: Maybe (Maybe Int)
22:37:31 <lambdabot>   Nothing
22:37:41 <mushtar> oh.. interesting
22:37:57 <pumpkin> just like [] could be an empty list of Ints, Bools, or anything else
22:38:49 <mushtar> so can you extract the value out of a monad, in general?
22:38:55 <pumpkin> no
22:39:02 <pumpkin> only in certain particular cases
22:39:07 <shachaf> mushtar: Monads don't have values.
22:39:17 <mushtar> shachaf: according to Cale they do
22:39:31 <mushtar> <Cale> monads are type constructors which construct types whose values can
22:39:31 <mushtar>        often be thought of as computations
22:39:37 <shachaf> Yes.
22:39:47 <mushtar> So why don't Monads have values?
22:39:52 <pumpkin> they may have many of them
22:39:54 <shachaf> A value :: (Monad m) => m a can't be turned into a value :: a.
22:40:07 <pumpkin> mushtar: or none of them
22:40:12 <shachaf> Because, for instance, there may be no value :: a.
22:40:16 <shachaf> (As in Nothing and [].)
22:40:31 <mushtar> But a value :: (Monad (Monad m)) => m (m a) can be turned into a value :: m a?
22:40:31 <shachaf> Or it may take extra arguments to produce it, as in Reader and State.
22:40:39 <pumpkin> mushtar: yup :)
22:40:44 <shachaf> Not (Monad (Monad m)).
22:40:48 <shachaf> @ty join
22:40:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:40:55 <mushtar> Oh yes
22:41:02 <shachaf> And yes, it can.
22:41:13 <pumpkin> that's one of the defining characteristics of a monad
22:41:13 <Apocalisp> (Comonad m) => m a -> a
22:41:31 <mushtar> pumpkin: why is that?
22:41:46 <pumpkin> mushtar: think of a list, for example
22:41:52 <shachaf> Apocalisp: I don't think that would be very helpful at this point. :-)
22:41:55 <Apocalisp> heh
22:42:00 <pumpkin> you can flatten nested lists down to a single list, but you can't flatten it past that
22:42:12 <mushtar> so it's turtles all the way down?
22:42:18 <shachaf> mushtar: I think the join/fmap/return definition of a monad is nicer than >>=/return.
22:42:39 <mushtar> shachaf: why is that?
22:42:41 <Apocalisp> shachaf: Easier to understand.
22:42:43 <pumpkin> mushtar: asking for a function Monad m => m a -> a would be like asking for a meaningful function [a] -> a
22:42:45 <Cale> pumpkin: what?
22:42:52 <pumpkin> lol
22:43:03 <shachaf> How about:
22:43:04 * pumpkin shuts up
22:43:14 <Cale> pumpkin: I suppose a monad could have no elements, but the list monad always has lots.
22:43:15 <mushtar> ok this makes sense
22:43:21 <jbhatta> (pumpkin: do you mean a NATURAL function [a]->a ?)
22:43:25 <Cale> For every type t, [t] is inhabited
22:43:32 <shachaf> data Null a = Null; instance Monad Null where return _ = Null; Null >>= _ = Null
22:43:35 <Cale> So, that's not an empty monad by any measure
22:43:43 <shachaf> That's a valid monad where a is *never* used.
22:43:49 <pumpkin> I'm just trying to give the intuition of why it doesn't make sense to ask for m a -> a
22:43:50 <shachaf> It doesn't even exist.
22:44:06 <Cale> Actually, that's a lie, there's no empty monad
22:44:17 <pumpkin> me?
22:44:30 <pumpkin> oh
22:44:31 <Apocalisp> mushtar: You already know what a higher-order function is, right?
22:44:35 <Cale> Because whenever x :: t, we have return x has to be an element of m t
22:44:36 <mushtar> Apocalisp: yes
22:44:50 <shachaf> Cale: Sure, but a value of type t never exists.
22:44:51 <Apocalisp> mushtar: And you know what a functor is, yes? (fmap, map)
22:44:56 <shachaf> Just :: m t.
22:44:58 <mushtar> Apocalisp: no
22:45:18 <Cale> shachaf: I mean, you can pick any type you want which has values, and it shows that the monad has members
22:45:19 <shachaf> mushtar: A functor is something that has an equivalent of map. :-)
22:45:21 <shachaf> @ty fmap
22:45:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:45:31 <Apocalisp> mushtar: OK. A functor is any type t for which there exists a function (a -> b) -> t a -> t b.
22:45:38 <Cale> shachaf: Just :: t -> m t
22:45:50 <Apocalisp> @type map
22:45:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:46:01 <mushtar> okay i see
22:46:01 <Apocalisp> see, List is a functor
22:46:35 <Cale> The smallest monad you can have is  data Trivial a = T
22:46:36 <Apocalisp> A functor also has to satisfy some obvious laws, but we'll let that sit.
22:46:54 <Apocalisp> mushtar: A monad is just a functor with an additional method: join.
22:46:56 <Apocalisp> @type join
22:46:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
22:47:00 <Cale> With return x = T, and T >>= f = T
22:47:05 <Saizan> Apocalisp: and return
22:47:13 <Cale> But it is inhabited.
22:47:13 <Apocalisp> oh snap, and return
22:47:18 <Apocalisp> @type return
22:47:19 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:47:22 <mushtar> Should it be trivial to see that the two definitions of monads are equivalent?
22:47:28 <mushtar> Because I don't see it.
22:47:37 <Cale> mushtar: It's not hard, but not trivial either
22:47:43 <shachaf> Apocalisp: You need return too.
22:47:52 <Apocalisp> yep, got it
22:47:52 <shachaf> Er, sorry.
22:47:56 <Apocalisp> :)
22:48:13 <Cale> mushtar: If you have >>= you can get join by using  join x = x >>= id
22:48:16 * shachaf learns not to switch away from the IRC window for too long without reading back...
22:48:32 <mushtar> i see
22:48:47 <Cale> and if you have join, you can get >>= by using x >>= f = join (fmap f x)
22:49:37 <Cale> Now, monads are required to satisfy a few simple laws in addition, and the laws can be stated in terms of fmap/return/join or in terms of return/>>=
22:50:17 <Apocalisp> > tails [1,2,3]
22:50:18 <lambdabot>   [[1,2,3],[2,3],[3],[]]
22:50:24 <Apocalisp> > join (tails [1,2,3])
22:50:25 <lambdabot>   [1,2,3,2,3,3]
22:51:04 <Cale> If you're interested, I can go over what they are.
22:51:14 * jbhatta is interested, so please do it anyway
22:51:18 <mushtar> Cale: i've read about them, stuff like associativity, etc?
22:51:24 <Cale> yeah
22:51:42 <Cale> Actually, my favourite way to write the laws uses neither of these presentations
22:51:58 <Cale> The laws are much prettier when written in terms of return and <=<
22:52:05 <Cale> :t (<=<)
22:52:06 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
22:52:15 <pumpkin> ooh
22:52:19 <Cale> It's defined by:
22:52:24 <mushtar> that's a handful
22:52:26 <Apocalisp> kleisli composition?
22:52:34 <dmwit> mushtar: Compare the type of (.):
22:52:36 <dmwit> :t (.)
22:52:37 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:52:55 <Cale> Yeah, it's like composition, but instead of functions (a -> b), you have (a -> m b)
22:53:23 <Cale> (g <=< f) x = do v <- f x; g v
22:53:33 <Cale> or:
22:53:43 <Cale> (g <=< f) x = f x >>= \v -> g v
22:53:47 <Cale> which is
22:53:52 <Cale> (g <=< f) x = f x >>= g
22:54:17 <Cale> So that's how it goes in terms fo >>=
22:54:18 <Cale> of*
22:54:30 <Cale> Let me state the laws using it
22:54:35 <cnwdup> > "hello" :: ByteString
22:54:36 <lambdabot>       Not in scope: type constructor or class `ByteString'
22:54:40 <Cale> 1) return <=< f = f
22:54:40 <cnwdup> > "hello" :: B.ByteString
22:54:41 <lambdabot>       Failed to load interface for `B':
22:54:41 <lambdabot>        Use -v to see a list of the fi...
22:54:50 <Cale> 2) f <=< return = f
22:54:59 <cnwdup> However, is this possible with XOverloadedStrings?
22:55:05 <Cale> 3) (f <=< g) <=< h = f <=< (g <=< h)
22:55:07 <dmwit> cnwdup: It should be, yes.
22:55:21 <Cale> So they say that return is an identity for <=<
22:55:25 <Cale> and that <=< is associative
22:55:33 <jbhatta> cale: that composition rule certainly makes the identities prettier
22:55:55 <dmwit> cnwdup: I'm not sure where to find the appropriate instances, though.
22:55:56 <mushtar> that's nicer than the way i learned it
22:56:20 <jbhatta> Cale: can you show that it's equivalent to the usual identities using >>= et al?
22:56:29 <jbhatta> is it a simple matter of expanding <=<?
22:56:31 <Cale> Yes, by expanding out the definition of <=<
22:56:39 <jbhatta> okay
22:56:40 <Cale> and applying it to an argument
22:56:46 <shachaf> dmwit: Data.ByteString.Lazy.Char8 has one, at least.
22:57:33 <Cale> But this form of the laws is a little bit far away perhaps from the way that we usually program.
22:57:40 <Cale> Maybe...
22:58:12 <Saizan> unless you program in pointsfree style :)
22:58:22 <dmwit> It's not *so* far.
22:58:35 <dmwit> I use (>=>) fairly often.
22:58:38 <Cale> In the computational viewpoint, it should still be clear that the first two laws essentially say that return x gives a computation which has no effect but produces x as its result
22:59:12 <Cale> (What do we mean by no effect? Well, the laws make it formal.)
22:59:36 <Cale> The third law is extremely important for composability of programs.
23:00:11 <Cale> It essentially is what lets us take a chunk out of the middle of a do-block, decide that it's useful and make it into a new definition, and then call it, without changing the meaning of the program.
23:00:36 <Cale> (or, inline a definition into the middle of a do-block)
23:02:01 <Cale> It's partly because we can move the brackets around that do-blocks make any sense in the first place -- things are combined in a long sequence, but the order in which the subsequences are paired up to make it doesn't matter.
23:03:50 <Cale> So, the third laws in essence just formalises our expectation that it doesn't matter if you:
23:03:53 <Cale> put on your socks then (put on your shoes then tie the laces)
23:03:54 <Cale> or
23:04:00 <Cale> (put on your socks then put on your shoes) then tie the laces
23:04:09 <Cale> law*
23:04:37 <Cale> Is that cool?
23:05:42 <mushtar> yes it makes sense
23:05:51 <pumpkin> oh, is that what makes it a monoid in the category of endofunctors? I've heard that mentioned before, but didn't make the connection
23:06:16 <Cale> Well... actually, the return/join version is closer to that
23:06:25 <Cale> This is what makes the Kleisli category a category.
23:06:46 <Cale> (of course, they're all closely related)
23:07:08 <pumpkin> ah, cool
23:07:15 <dibblego> I'm going to give a talk to a bunch of Java guys -- I don't want it o be boring (i.e. this is the syntax for list) and I don't want to lose the audience, so I figure monadic parsers (without saying the m word) -- comments?
23:07:41 <Cale> For the monoid object in the category of endofunctors bit, you need to know that the sense of the word 'monoid' has been generalised quite a bit.
23:07:57 <Ycros> dibblego: yeah, that would be pretty cool
23:08:55 <pumpkin> Cale: oh, I just saw what you said earlier as making >=> an associative operator, with return as the identity element
23:09:03 <Cale> pumpkin: yeah
23:09:35 <Cale> pumpkin: but the type of >=> isn't quite right for it to make a monoid... however, it makes the next closest thing
23:09:41 <Cale> A category
23:10:39 <pumpkin> what is missing about >=>'s type to make it a regular monoid? I can see how it would be a category though
23:10:51 <Cale> Well, you can't compose any two arrows.
23:11:01 <pumpkin> oh
23:11:03 <Cale> So it's not a set sort of monoid
23:11:06 <pumpkin> I see
23:11:21 <pumpkin> so it's a "monoid with incompatible elements"
23:11:22 <pumpkin> :P
23:11:30 <Cale> yeah, which we also call a category :)
23:11:34 <pumpkin> yeah :) I see now
23:11:38 <pumpkin> cool
23:11:51 <Apocalisp> The existence of mzero and mplus make monads moinoidal objects, right?
23:12:05 * pumpkin eats some gummy bears to celebrate
23:12:08 <Cale> Apocalisp: hmm...
23:12:45 <Cale> Apocalisp: Maybe in some particular sense, but not in any of the senses we've yet discussed
23:13:15 <Cale> In order to understand the concept of a monoid object, first you need to know what a monoidal category is (it's the sort of category in which we can define monoid objects)
23:13:19 <Apocalisp> i.e. for all monads m and all a, (m a) is a monoid
23:13:35 <pumpkin> well, MonadPlus?
23:13:50 <Cale> For all monadpluses ;)
23:14:01 <Apocalisp> heh
23:14:18 <Cale> It's true, but I'm not sure if I see how that makes m into a monoid object in any category...
23:14:30 <Apocalisp> What's a familiar monad that doesn't satisfy MonadPlus?
23:14:39 <Cale> State s
23:14:47 <Apocalisp> ah, ok
23:14:52 <Cale> Or for that matter (->) e
23:15:08 <Cale> Let me explain the way that m is a monoid object in the category of endofunctors
23:15:09 <Apocalisp> -> e does only if e is a monoid
23:15:15 <pumpkin> yay
23:15:24 <pumpkin> Apocalisp: yeah, but we can't write -> e can we?
23:15:25 <Cale> Apocalisp: other way around ;)
23:15:37 <Apocalisp> forgot parens
23:16:01 <pumpkin> I thought it was true only if you left out parens
23:16:05 <pumpkin> but you can't write it without parens
23:16:10 <pumpkin> :P
23:16:14 <Cale> A monoidal category is a category C which has a bifunctor that I'll call * : C x C -> C
23:16:15 <Apocalisp> (e ->) then
23:16:34 <Cale> That means, it's a functor in each parameter.
23:16:50 <Cale> and an object I of C
23:17:18 <Cale> Together with some natural isomorphisms  (A * B) * C ~= A * (B * C)
23:17:28 <Cale> and I * A ~= A and A * I ~= A
23:17:39 <Cale> The most familiar example is (,)
23:17:42 <Cale> and ()
23:17:48 <Cale> (ignoring strictness for now)
23:18:11 <Cale> Because (a,(b,c)) ~= ((a,b),c)
23:18:12 <pumpkin> (,) being the bifunctor?
23:18:23 <Cale> and ((),a) ~= a ~= (a,())
23:18:25 <Cale> yeah
23:18:59 <Cale> But the category of endofunctors with natural maps between them is a monoidal category in a different way
23:19:18 <pumpkin> what do you mean by ~= ?
23:19:22 <Cale> isomorphic to
23:19:26 <pumpkin> oh ok :)
23:19:36 <Cale> (naturally isomorphic to, if you want to be more technical)
23:19:56 <pumpkin> not sure what the naturally qualification adds to it :) I haven't read that far in awodey yet
23:20:13 <pumpkin> but the plain ol' isomoprhic makes sense
23:20:22 <Cale> It basically just means that the isomorphism is supposed to "do the same thing" regardless of what A,B,C are
23:20:38 <Cale> In Haskell, we'd expect it to be realised as a polymorphic function
23:20:47 <Cale> But actually polymorphism is a little stronger
23:20:52 <pumpkin> ok
23:21:08 <Cale> In the category [C,C] of endofunctors on C, we take the * to be composition of functors(!) and the I to be the identity functor.
23:21:39 <pumpkin> what's the [C,C] notation?
23:21:48 <Cale> Functors from one category to another
23:21:52 <pumpkin> oh ok :)
23:21:58 <Cale> C^C would work too :)
23:22:00 <Cale> Or C -> C
23:22:05 <pumpkin> cool
23:22:10 <Cale> (though that's more haskelly)
23:22:15 <Cale> Since composition is associative, we get that A . (B . C) is isomorphic to (A . B) . C
23:22:37 <Cale> (more than that, they're equal)
23:22:46 <Cale> and since the identity functor is an identity, A . id = A = id . A
23:23:31 <Cale> Oh, actually there are some annoyingly technical conditions which the isomorphisms are supposed to satisfy... I'm not going to bother with that
23:23:52 <Cale> anyway!
23:23:56 <pumpkin> :)
23:24:42 <Cale> If we have a monoidal category, a monoid object in it is an object M together with two arrows:  mu: M * M -> M
23:24:48 <Cale> and eta: I -> M
23:25:01 <Cale> and they have to satisfy a few laws
23:26:30 <Cale> But you can already start to see how in the category of endofunctors, this is starting to look like a monad
23:27:07 <Cale> In Haskell, we might realise mu as a function of type M (M a) -> M a
23:27:09 <pumpkin> that's an eye -> M
23:27:12 <pumpkin> not ell, right?
23:27:15 <Cale> yeah
23:27:19 <pumpkin> yeah :)
23:27:25 <Cale> and eta as a -> M a
23:27:26 <pumpkin> and eta is return
23:27:45 <pumpkin> that's neat
23:28:10 <Cale> The laws they have to satisfy are analogous to the laws for a monoid in Set
23:28:55 <Cale> If we start from M * M * M
23:29:29 <Cale> We can either look at that as M * (M * M) and apply mu on the right to get to M * M and then apply mu again to get to M
23:30:14 <Cale> Or, by the required isomorphism, we can look at it as (M * M) * M and apply mu on the left (since * is a bifunctor), and get to M * M, and then apply mu again to get to M
23:30:35 <Cale> and the associativity law says these compositions have to be equal
23:31:20 <Cale> That is, in Haskelly notation, join . fmap join = join . join
23:32:22 <Cale> Follow that much?
23:32:40 <Cale> It may help to draw a diagram or look at the one on http://en.wikipedia.org/wiki/Monoid_object
23:33:40 <Cale> One of the unit laws is that if we start from I * M and apply eta on the I to get to M * M and then mu to get to M, the result is the same as the isomorphism I * M -> M gives us
23:34:07 <Cale> Of course, the isomorphism is actually an equality in the endofunctor case
23:35:01 <Cale> and so this says  join . return = id
23:35:43 <Cale> Or, starting from  M * I, we can apply eta on the I to get to M * M and then mu to get to M, and that should be the same as the isomorphism M * I -> M gives us
23:36:14 <pumpkin> yup :)
23:36:15 <Cale> and translated into the endofunctor case and then to Haskell, that gives us that join . fmap return = id
23:36:37 <pumpkin> I think I actually followed all of that
23:36:43 <Cale> Great!
23:38:10 <Cale> To get the normal notion of monoids, you take the category of sets, and * becomes Cartesian product, and I becomes any one-element set.
23:38:28 <Cale> mu: M x M -> M
23:38:35 <Cale> is the multiplication in the monoid (mappend)
23:38:53 <Cale> and eta: 1 -> M is a function which picks out the identity element (const mempty)
23:40:01 <Cale> Which goes to show that if you abstract any two concepts far enough, they will eventually look the same ;)
23:40:09 <pumpkin> hah
23:43:18 <Cale> Hmm...
23:43:42 <pumpkin> ?
23:43:56 <Cale> Just wondering now how to go most efficiently from the endofunctor presentation to the Kleisli composition presentation
23:43:56 <cnwdup> How can I catch signals like ^C (SIGTERM?) in Haskell?
23:44:10 <pumpkin> isn't that SIGINT?
23:44:16 <cnwdup> Probably. (:
23:44:33 <dmwit> Have you checked in the System hierarchy?
23:44:46 <Cale> There's a posix library which has stuff related to signals as I recall...
23:44:58 <dmwit> http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html
23:44:58 <cnwdup> Cale, dmwit, thanks. Will see if I can find it.
23:45:36 <Cale> installHandler :: Signal -> Handler -> Maybe SignalSet -> IO Handler
23:45:54 <Cale> data Handler
23:45:55 <Cale>   = Default
23:45:55 <Cale>   | Ignore
23:45:55 <Cale>   | Catch (IO ())
23:45:55 <Cale>   | CatchOnce (IO ())
23:47:55 <Cale> so... installHandler keyboardSignal (Catch handleCtrlC) Nothing
23:48:26 <cnwdup> Cale, thanks
23:49:02 <Cale> It probably isn't the least bit windows compatible
23:49:23 <cnwdup> That's okay for me.
23:49:54 <dmwit> Windows is POSIX-compliant, I thought.
23:50:13 <Cale> "The package is not supported under Windows (except under Cygwin)."
23:50:25 <p_l> dmwit: it is, but you need to install additional package (SUA)
23:51:17 <p_l> and GHC probably doesn't use that :)
23:51:52 <dmwit> aha
23:52:07 <magical_pony> are there any major differences between ghc(i) and hugs?
23:52:15 <magical_pony> why would one use hugs over ghc?
23:52:20 <pumpkin> you wouldn't
23:52:22 <Cale> ghc is a compiler
23:52:32 <Cale> and ghci a bytecode interpreter
23:52:40 <Cale> hugs is an interpreter
23:52:40 <magical_pony> yes... then why does hugs exist?
23:52:43 <magical_pony> ooooh
23:53:08 <Cale> Because people were working on it since the very earliest days of Haskell.
23:53:24 <Lemmih> It's also more portable, I think.
23:53:30 <magical_pony> understood. is there a standard implementation of the haskell language?
23:53:40 <magical_pony> i suppose i can consult haskell.org
23:53:43 <Cale> magical_pony: I would normally just recommend GHC
23:53:49 <dmwit> GHC is the most widely-used implementation.
23:54:09 <dmwit> If you have problems with other implementations, people will likely say, "use GHC" rather than support the other implementation. ;-)
23:54:21 <magical_pony> alright, thanks.
23:54:33 <Cale> Hugs is the only other maintained implementation which isn't in a somewhat experimental state right now, I think.
23:54:51 <Cale> And GHC produces much faster code and has more cool features.
23:55:01 <magical_pony> so there are differences!
23:55:06 <Cale> (like a profiler, code coverage tools, and so on)
23:55:14 <Cale> and language extensions, yes
23:55:14 <magical_pony> oh, development tools, i see.
23:55:24 <pumpkin> onoes, xzibit got into the GHC GMP build -D__GMP_WITHIN_GMP
23:55:33 <Cale> ahahhaa
23:55:50 <magical_pony> sure is b in here
23:56:31 <p_l> <insert mandatory "yo, dawg" joke here>
23:58:26 <pumpkin> :)
