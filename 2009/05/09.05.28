00:22:07 <hackagebot> linear-maps 0.6
00:34:47 * osfameron was thinking about lenses last night.  it seems like there are plenty of very sensible transformations which can't be expressed as a lens
00:35:04 <aconbere> hey, so I'm struggling with Random and using that within the context of HOpenGL
00:35:17 <aconbere> basically one of the state variables I want to be randomly generated
00:35:27 <aconbere> intially you create a newIORef
00:35:41 <aconbere> and this works fine coming from the IO wrapped random data
00:35:49 <aconbere> but when I try to mutate it
00:35:58 <aconbere> myVar $= randomVar
00:36:07 <aconbere> it yells at me about the type
00:36:14 * aconbere shrugs!
00:36:30 <Zao> writeIORef?
00:36:38 <Zao> I thought $= was just for opengl state?
00:37:06 <aconbere> right, this is an openGL state var
00:37:44 <Zao> So readIORef and throw the result at myVar $=?
00:39:33 <Zao> aconbere: ($=) :: s a -> a -> IO ()
00:40:50 <Zao> aconbere: Take shadeModel for example.
00:41:11 <Zao> You have  shadeModel :: StateVar ShadingModel
00:42:01 * aconbere tries to find this in the api docs
00:42:05 <Zao> (shadeModel $=) would have the type  ShadingModel -> IO (), which is an function taking a ShadingModel returning an IO action.
00:42:15 <Zao> http://hackage.haskell.org/packages/archive/OpenGL/2.2.3.0/doc/html/Graphics-Rendering-OpenGL-GL-StateVar.html#v%3A%24%3D
00:43:19 <Zao> Where your expression has the type  StateVar ShadingModel -> (IORef ShadingModel) -> IO ()
00:43:31 <Zao> Which doesn't match the signature for ($=)
00:44:19 <aconbere> so a lot of what you're saying is over my head still
00:44:39 <aconbere> but I think the gist of my problem comes down to how you manipulate random data from tools like MonadRandom
00:44:44 <aconbere> once I get that IO data type
00:44:52 <aconbere> I feel like I can't do anything with it
00:45:15 <Zao> @type readIORef
00:45:17 <lambdabot> Not in scope: `readIORef'
00:45:25 <aconbere> so I tried
00:45:33 <Zao> @type Data.IORef.readIORef
00:45:35 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
00:45:40 <aconbere> myVar $= readIORef myRandomVar
00:45:52 <aconbere> but got a type error that readIORef expects and IORef
00:45:55 <aconbere> not IO
00:46:03 <Zao> What type is myRandomVar?
00:46:07 <aconbere> IO
00:46:13 <aconbere> since that's what random returns
00:46:32 <Zao> Not the whole truth.
00:47:01 <Zao> IO what? One usually doesn't refer to the monad with just the name.
00:47:47 <Zao> Could you hpaste relevant bits of your code?
00:48:54 <Zao> Long story short, if you want to get the contents of an IORef t, you use   x <- readIORef r
00:49:16 <Zao> If you want to use randomIO to get a random value from the global pool, you use   x <- randomIO
00:49:30 <aconbere> yeah I'm working on it, slightly weird dev environment here
00:50:45 <Zao> You can't use something with type (IO a) anywhere that expects an a.
00:51:10 <Zao> You need to sequence it and get hold of the contents using <- or >>= or suchlike.
00:51:49 <aconbere> right, so I've been kind of shooting in the dark with this stuff I can't ever really quite figure out how that stuff works
00:51:53 <aconbere> but it's okay I'm learning :)
00:51:54 <Zao> A value of type (IO t) represents a function in the IO monad, that when actually run yields the value inside.
00:51:56 <aconbere> http://paste.pocoo.org/show/119531/
00:52:26 <aconbere> so that's the bit that makes the random data structure
00:53:18 <aconbere> http://paste.pocoo.org/show/119532/
00:53:28 <aconbere> that's where it's instantiated in the openGL main loop
00:55:15 <Zao> So what's the type of the expression newIORef $ randomFood?
00:55:34 <aconbere> http://paste.pocoo.org/show/119534/
00:56:02 <aconbere> one sec let me look at newIORef again :)
00:56:33 <aconbere> I'd expect it to be something crazy like
00:56:45 <aconbere> IO (IORef (IO a))
00:57:25 <Zao> So in the end, food has what type?
00:59:30 <Zao> In do notation, <- binds the name to the left to the result of the (m a) expression to the right.
01:00:03 <aconbere> I'm not sure I understand ($=) :: s a -> a -> IO ()
01:00:13 <aconbere> but the type that food ends up as is bound up in that
01:00:47 <aconbere> as far as <- goes I get taht it's binding a variable from (m a)
01:01:00 <aconbere> I just don't find that it quite works the way I expect in practice
01:01:01 <Zao> ($=) is a function in the IO monad, taking something matching (s a), a value of type a, returning unit.
01:01:16 <Zao> $= only works on OpenGL state variables.
01:01:33 <Zao> (and other things conformant to the HasSetter class)
01:02:06 <Zao> food has type :: IORef (IO f)
01:02:32 <Zao> That is, an IORef pointing at a IO function to give you a new random food.
01:02:49 <Zao> Is that the intended result?
01:03:17 <aconbere> the problem with "intended" in this regard is that I have not internalized haskell completely
01:03:26 <aconbere> so often times "intended" just isn't how to do it :)
01:03:28 <aconbere> for instance
01:03:43 <aconbere> my intention is to simply create a new random food evertime it gets eaten
01:04:07 <aconbere> the problem is in my approach :)
01:04:24 <te> I'm so excited for my haskell book to get here tomorrow
01:04:30 <Zao> I assume the intended functionality would be analogous to the following C++:  *currentFood = randomFood(); ?
01:04:42 <Zao> Or more explicitly,  Food f = randomFood(); *currentFood = f;
01:05:14 <Zao> As I assume that the food IORef in main is supposed to contain a piece of food, not a function to generate more.
01:06:29 <Zao> Ignore what I said above about ($=) not being usable on IORefs. Apparently there's an instance around for that.
01:08:51 <aconbere> Zao: that's pretty much right
01:09:02 <aconbere> or in most dynamic languages it would be analagous to
01:09:10 <aconbere> food = RandomFood()
01:09:26 <aconbere> which is kind of how I've been envisioning this whole $= bit
01:09:31 <aconbere> since that seems to be mostly how it works
01:09:40 <aconbere> but Random has been givine me a headache :)
01:10:25 <Zao> Let's address the issue in main first.
01:10:46 <Zao> You're initializing the food IORef with an IO function, while you just want an initial value.
01:10:46 <aconbere> roger!
01:10:53 <aconbere> totally
01:11:08 <Baughn> @index fix
01:11:09 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
01:11:10 <aconbere> so should I have first binding that value to a variable?
01:11:22 <aconbere> wow
01:11:24 <Zao> That's one way.
01:11:24 <aconbere> that's barely english
01:11:52 <Baughn> @instances-importing Control.Monad.Fix MonadFix
01:11:53 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
01:12:46 <Zao> do { initialFood <- randomFood; food <- newIORef initialFood }
01:12:50 <Zao> That's the more explicit variant.
01:13:31 <aconbere> totally
01:13:35 <aconbere> okay I'll start there
01:13:39 * aconbere pokes around
01:14:32 <Zao> @type >>=
01:14:34 <lambdabot> parse error on input `>>='
01:14:37 <Zao> @type (>>=)
01:14:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
01:15:12 <Zao> For future reference,    food <- randomFood >>= newIORef    would do too.
01:15:20 <Zao> But that relies on understanding >>=
01:15:26 <aconbere> yeah
01:15:28 <Zao> Anyway, I'm late for work already. Have fun.
01:15:31 <aconbere> let's not go there quite yet :)
01:15:36 <aconbere> thanks!
01:16:15 <Zao> Duct taping actions together like that tends to cut down on the avalanche of temporary variables.
01:17:02 <Zao> When control flows through an IO function, there needs to be a single clear order (sequence) of IO actions to perform.
01:17:17 <Zao> >>= allows you to compose larger actions from smaller ones.
01:17:37 <Zao> `do' blocks actually desugars to >>, >>= and a whole pile of lambdas.
01:18:59 <Zao> It tends to take a good while before things start to click :)
01:19:46 <Lemmih> @seen augustss
01:19:46 <lambdabot> augustss is in #haskell-in-depth, #ghc and #haskell. I don't know when augustss last spoke.
01:49:35 <Baughn> @type msum
01:49:37 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
01:50:10 <mib_83y9w7go> hey guys
01:50:21 <mib_83y9w7go> could anyone tell me whats wrong with this
01:50:23 <mib_83y9w7go> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5334#a5334
01:51:04 <mebbel> exactly what it says
01:51:22 <mebbel> you're calling fanCount films
01:51:36 <mebbel> fanCount takes a Film; films is a list of Films
01:51:50 <mib_83y9w7go> ahh
01:52:43 <T-Cell> HELP PLEASE: Expected kind `?', but `Request' has kind `* -> *' ...I need to support '*' uri in OPTIONS request. How is this done? (relevant source: http://hackage.haskell.org/packages/archive/HTTP/3001.1.5/doc/html/src/Network-HTTP.html#RequestMethod )
01:54:09 <Lemmih> T-Cell: More information required.
01:54:12 <mebbel> Request has kind * -> *? not according to the url you pasted
01:57:17 <T-Cell> specifically, in data Request, rqURI  has :: URI and I need this to support '*' see the link above
01:57:37 <mebbel> ok?
01:57:54 <T-Cell> I'm not sure how this is done
01:58:00 <Lemmih> T-Cell: You haven't really asked anything.
01:58:14 <mebbel> and how is this related to the kind error?
02:00:08 <T-Cell> How can I support '*' in uri OPTIONS request? OPTIONS is defined in rqMethodMap which is in the link above.
02:00:13 <quicksilver> I have no idea what the kind error is about, but the comments in that source suggest that you can't.
02:00:19 <quicksilver> -- ^ might need changing in future
02:00:25 <quicksilver> --  1) to support '*' uri in OPTIONS request
02:00:30 <T-Cell> yes
02:00:45 <mebbel> so you can do it by patching Network.HTTP
02:01:15 * Lemmih has a nagging feeling that T-Cell is asking us to do his work for him.
02:03:36 <T-Cell> no, I just don't know a lot about Network.HTTP. I really just need a function to work which unfortunately depends on this.
02:04:23 <T-Cell> it's ok. I appreciate the help though.
02:10:15 <mib_83y9w7go> any idea how to fix this? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5334#a5334
02:10:25 <mib_83y9w7go> im lost
02:10:46 <quicksilver> as you were told 20 minutes ago
02:10:48 <mib_83y9w7go> trying to sort list by amount of fans
02:10:58 <quicksilver> fanCount takes a single film
02:11:06 <quicksilver> and you're giving it 'films' which is a list.
02:11:25 <quicksilver> I think you misunderstand sortBy, too :)
02:11:29 <quicksilver> :t sortBy
02:11:31 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
02:11:56 <mib_83y9w7go> seems i have a lot of work
02:12:00 <mib_83y9w7go> :S
02:12:03 <quicksilver> what you want is sortBy (comparing fanCount) films
02:12:15 <quicksilver> it would probably be good if you tried to work out why, though.
02:12:22 <quicksilver> :t comparing
02:12:23 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
02:12:24 <Zao> Almost sounds like english, this fancy language of yours :)
02:12:53 <mib_83y9w7go> lol
02:13:08 <Cale> Zao: That was the point when I first defined comparing :)
02:19:41 <McManiaC> @src getLine
02:19:41 <lambdabot> getLine = hGetLine stdin
02:33:50 <mib_83y9w7go> hey is there a generic function to flip a list?
02:34:00 <Cale> reverse?
02:34:03 <Cale> > reverse [1,2,3]
02:34:05 <lambdabot>   [3,2,1]
02:34:09 <mib_83y9w7go> cool
02:37:19 <cads> hey, what's the cleverest O(1) algorithm known to man?
02:37:44 <cads> makes a better candidate for a joke than a question
02:39:09 <dmwit> There's not really a lot of choices.
02:39:12 <dmwit> Array indexing, maybe.
02:39:25 <quicksilver> reading a haiku
02:39:28 <cads> i guess any algorithm that does a fixed number of things with at most a fixed number of elements of the input would qualify
02:39:55 <dmwit> Radix sort on lists of length at most 10^30. ;-)
02:40:22 <cads> well technically that O(1), no?
02:40:57 <cads> hehe, not locally
02:41:18 <dmwit> cads: Yes, it's O(1), exactly. =)
02:41:41 <WorkyBob> cads: no, I don't think so – to be O(1) its time complexity must be constant varying *with the size of its input*
02:41:57 <WorkyBob> you can't just say "yes, but its input is this size" and declare it constant time
02:42:09 <dmwit> Sure you can.
02:42:16 <cads> but bob, if the first part of the algorithm just truncates the input if too large, the rest of it will run in constant time
02:42:37 <WorkyBob> cads: ah, now that's a different matter - that does sound like a constant time algorithm
02:42:41 <WorkyBob> not a very interesting one though
02:42:58 <WorkyBob> well, I guess head does that and is fairly interesting
02:43:12 <dmwit> This is one of the pitfalls of O-notation: people mostly don't understand it as well as they think they do.
02:43:16 <cads> getting head )is( interesting
02:43:22 <WorkyBob> heh
02:44:16 <opqdonut> dmwit: most people who get all smart-ass about O(1) don't remember that the problem/algorithm needs to be extended to inputs of arbitary length
02:44:18 <WorkyBob> dmwit: is this function: f 6 = 3 constant?
02:44:42 <hackagebot> delimited-text 0.1.1
02:45:07 <Zao> @type const 3
02:45:09 <lambdabot> forall t b. (Num t) => b -> t
02:45:13 <opqdonut> cads: but as for real O(1) algorithms, there are local graph algorithms (i.e. collect data from only a constant radius) that attain good approximations of classic problems
02:45:17 <ivanm> opqdonut: I just came in to this conversation and so I don't know what you're talking about, but isn't array access O(1) no matter what size the array (well, maybe not after you've updated your immutable array a few times...)
02:45:19 <ivanm> ?
02:45:20 <opqdonut> cads: let me throw you a link
02:45:33 <cads> dmwit: yeah, plateuing any function's runtime after a certain size input makes it O(1) but render the O notation useless for thinking about the function... or rather, we;d want to think about the part of the function that grows like a different O, which will be hard in general
02:45:34 <opqdonut> ivanm: yeah, array access is really (ideally) O(1)
02:45:39 <WorkyBob> ivanm: indeed
02:46:02 <Saizan> well, with unbounded memory it isn't
02:46:09 <ivanm> though immutable arrays make that kind of argument tricky ;-)
02:46:12 <ivanm> Saizan: *nod*
02:46:21 <dmwit> WorkyBob: ...yes?
02:46:22 <WorkyBob> Saizan: with an unbounded integer unit it is again though :D
02:46:22 <Saizan> but it all depends on what operations you're counting
02:46:23 <opqdonut> cads: the link: http://arxiv.org/pdf/0810.2175
02:46:34 <dmwit> cads: Right, I understand that.
02:46:35 <WorkyBob> dmwit: so how come I get different results for f 5 and f 6?
02:46:46 <cads> in clojure we get a vector where subvectors and reversal are O(1)
02:46:51 <dmwit> WorkyBob: I thought you were talking about constant-time.
02:46:57 <dmwit> i.e. O(1)
02:47:04 <dmwit> Naturally it's not the constant function.
02:47:21 <opqdonut> cads: the haskell Data.Sequence type is quite efficient for splicing, indexing and catenating
02:47:23 <WorkyBob> dmwit: I am - but my point is that you saying "if you restrict it to only inputs of a set length it's constant time" is equivalent to saying that f 6 = 3 is a constant function
02:47:39 <WorkyBob> ... if it's input is of length  6, it'll always take 3 seconds
02:47:51 <Saizan> more interestingly, how to prove that the fold for Data.Tree.Tree runs in linear time if the folded function runs in constant time?
02:47:53 <cads> oo, consing is O(1)
02:48:07 <dmwit> Ah, yes, I understand what you're saying.  I was slightly imprecise in my statement.
02:49:08 <cads> yeah, we're not fixing the input
02:51:49 <cads> lets see, "f ~ O g" means that a function g is bound from above by some scalar factor of some function, right?
02:52:03 <cads> O(g) *
02:52:15 <cads> ah crud
02:52:27 <cads> bound above by a scalar factor of g*
02:52:46 <cads> shit I really need to just go to bed
02:53:18 <dmwit> It means f is bound above by a scalar factor of g, yes.
02:53:49 <cads> it's actually a useful notion places other than algorithms
02:53:51 <Saizan> after some point
02:53:57 <mapreduce> cads: Consing is O(1)?  So if you cons n items it happens in constant time?
02:54:05 <WorkyBob> mapreduce: absolutely
02:54:06 <dmwit> For sufficiently large inputs. =)
02:54:07 <opqdonut> cads: yeah, stuff like O(1/n)
02:54:19 <WorkyBob> (1:long list) does not traverse the whole long list
02:54:27 <mapreduce> WorkyBob: That's not what I said.
02:54:33 <WorkyBob> oh, neither it is
02:54:35 <Saizan> if you cons n items you pay O(n)
02:54:37 <dmwit> mapreduce: If you cons n items, it happens in O(n) time. =)
02:54:38 <WorkyBob> but he said consing is constant time
02:54:45 <WorkyBob> not multiple conses are constant time
02:55:01 <WorkyBob> if you do n O(1) operations, you get an O(n) algorithm, big surprise
02:55:02 <mapreduce> Ok.
02:55:53 <cads> mapreduce: consing an item onto a list of n items will take O(1) time
02:56:30 <cads> wait, you guys covered that
02:57:07 <cads> I'm going to slep
02:57:10 <cads> night all
02:57:33 <cads> I think tail wins as most interesting O(1) algorith, yaaaaay!
02:58:04 <Berengal> tail is barely an algorithm at all...
02:58:05 <cads> though the fixed radius subgraph was neat if true
02:58:59 <cads> man, tail can take an infinite number of elements, serve you up with another infinite elements, all in one operation? shoooot
02:59:16 <yowgi> are walking and taking the bus both O(n)? ;)
03:00:16 * cads would settle for O(log(log(x))) transportation
03:02:18 <yowgi> although one could say that travelling at c is both O(n) and O(1). or even O(0)?
03:03:27 <Berengal> Well, it's not O(0) since getting from one place to another still takes time, whatever that may be at that speed
03:04:07 <doserj> it doesn't in your frame of reference
03:04:40 <lilac> big-O notation only makes sense if you have a pre-agreed objective definition of what it is you're bounding
03:04:59 <lilac> "time, as measured by, well, someone (we don't know who)" doesn't count ;-)
03:05:57 <Berengal> What's the time complexity for counting the number of list elements in a tree of lists?
03:06:30 <quicksilver> O(elements) I believe.
03:06:53 <quicksilver> traversing a tree should be O(nodes)
03:07:30 <Berengal> Yeah, that's what I thought as well. O((elements/nodes)nodes) = O(elements)
03:08:04 <Berengal> Could you also say it's O(elements + nodes)?
03:08:49 <quicksilver> but nodes itself is O(elements)
03:08:54 <quicksilver> so there is no point saying that.
03:09:06 <quicksilver> unless some of your lists are empty!
03:09:13 <quicksilver> in which case, yes, O(nodes + elements) is better :)
03:09:38 <Berengal> O(nodes + elements) take care of both the (combined) size of the lists and the size of the tree
03:10:02 <Berengal> O(elements) assumes a tree of a given size
03:10:21 <quicksilver> well I was just assuming the lists are non empty
03:10:40 <quicksilver> at which point nodes is certainly O(elements)
03:10:47 <quicksilver> and you can coalesce
03:11:34 <Berengal> Tree traversal doesn't depend on the contents of the tree
03:12:06 <Berengal> It's O(nodes) anyway
03:12:44 <Berengal> The length of a list is O(elements)
03:13:31 <Berengal> I should be heading off to work instead of doing this :/
03:13:42 <ivanm> work? what's that?
03:13:42 <ivanm> :p
03:14:07 <Berengal> Well, it's my last day tomorrow
03:14:09 <Berengal> ish
03:14:17 <Berengal> Moving to a new department
03:14:24 <ivanm> ahhh
03:14:29 <ivanm> promotion? or transfer?
03:14:35 <Berengal> Transfer
03:14:35 <Alpounet> yay
03:14:56 <Berengal> But promotion from intern in the department I'm transfering to
03:15:05 <ivanm> heh
03:15:16 <ivanm> so I'd say that's in a sense a promotion ;-)
03:15:41 <Berengal> Yes. Also, change in title. I'll now be a "programmer" instead of a "junior consultant"
03:15:52 <ivanm> they call interns "junior consultants"?
03:15:59 <ivanm> that sounds better than "programmer"...
03:16:15 <Berengal> No, they call interns interns. Junior consultants are just regular clerks
03:16:25 <ivanm> ahhh
03:16:46 <Berengal> And also, small raise :)
03:16:51 <ivanm> \o/
03:17:01 <ivanm> but only a _small_ one? from intern -> programmer?
03:17:18 <Berengal> I worked as an intern for free
03:17:35 <Berengal> But I also had a regular job at the same company
03:17:39 <ivanm> ahhhhh
03:18:30 <Berengal> Anyway, more hours + more pay = good
03:18:40 <ivanm> no, less hours + more pay = good
03:18:41 <ivanm> ;-)
03:19:08 <Berengal> To be honest, 30% of full time isn't enough :/
03:19:33 <Berengal> Now I've got 10 weeks of 100%
03:19:42 <ivanm> if they pay you for full time but you only work 30%, that leaves you with 70% for other things!
03:19:47 <ivanm> Berengal: only a short term contract?
03:20:09 <Berengal> Yeah, I've been on a short-term contract since last summer...
03:20:22 <Berengal> Though as a student that fits me okay
03:20:43 <ivanm> well, you better get going to work so that they'll renew your contract again when this one is up!
03:20:43 <ivanm> ;-)
03:20:55 <Berengal> Yeah, indeed
03:20:57 <Berengal> I'm off
03:21:26 <ivanm> then maybe you should be kept in the fridge rather than left outside? :p
03:34:12 <Baughn> @tell conal I did eventually get makeEvent working, though getting finalizers to work right is crazily hard. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5335 has the code for that; you'll want to consider changing types such as :--> and :+->, though. (Right now I'm just not using them)
03:34:13 <lambdabot> Consider it noted.
03:36:01 <WorkyBob> Baughn: ohh, does that mean that reactive actually makes progress correctly now, or is this a different bug?
03:40:10 <Baughn> WorkyBob: I'm working on it
03:40:42 <WorkyBob> sweet :D
03:40:47 <Baughn> WorkyBob: The bug I'm /currently/ working on is to have a makeEvent-created event /end/ when the sink gets GC'd
03:40:55 <Baughn> WorkyBob: ..and the other way around
03:41:01 <WorkyBob> ah, yeh
03:41:16 <WorkyBob> that makes sense, so it actually gets the infinite future added?
03:41:16 <Baughn> WorkyBob: QUite a lot of stuff started working when I fixed unamb a while back, but that code hasn't been released yet
03:41:19 <Baughn> Yes
03:41:32 <WorkyBob> is that possible with Haskell finalizers?
03:41:37 <WorkyBob> I thought they weren't guarenteed to run
03:41:38 <Baughn> Yes
03:41:41 <WorkyBob> only C ones
03:41:42 <Baughn> Oh, they aren't
03:41:50 <Baughn> In practice they get run, though.
03:41:53 <WorkyBob> ah, k
03:42:09 <Baughn> In particular, they get run before the GC decides a thread is deadlocked.
03:42:38 <quicksilver> Baughn: it would be nice to hear a bit about what you're doing/fixing on the reactive list
03:42:39 <WorkyBob> hmm, doesn't sound overly reliable to me
03:42:58 <Baughn> So that means you might end up blocking on reading the event for a while (=until the next major gc, possibly), but you won't actually get a deadlock exception
03:43:07 <WorkyBob> yeh, I'd love to hear what progress you're making in more detail – some of the bugs in reactive really enlightened me about how the whole thing works
03:43:22 <WorkyBob> ahhh, okay
03:43:28 <Baughn> WorkyBob: I'm also adding a call that'll let you cap the Event manually, which is safer. The finalizer's just to ensure it never goes /too/ wrong.
03:43:55 <Baughn> ..if I can figure out why my code isn't working now
03:44:05 <WorkyBob> ah, ok
03:44:11 <Baughn> quicksilver: I'm not even subscribed. :/
03:45:11 <WorkyBob> what I'm slightly confused by is that a while ago I fixed recursive integrals
03:45:17 <WorkyBob> and I'm sure it went into the darcs copy
03:45:23 <quicksilver> Baughn: well my suggestion is it would be nice if you were :)
03:45:27 <WorkyBob> but the most recent one doesn't seem to do it right
03:45:43 <quicksilver> Baughn: for a while, the list was quite lively but then people got blocked on some bugs, and busy.
03:45:47 <Baughn> WorkyBob: A lot of things fail to work due to a malfunctioning Unamb. Hang on..
03:45:53 <quicksilver> Baughn: they don't even even know you're fixing them :)
03:45:58 <WorkyBob> isn't unamb fixed now though?
03:46:09 <WorkyBob> I thought that was due to it not restarting the computation if it was demanded again
03:46:11 <Baughn> Yes, but the code hasn't been released
03:46:15 <Baughn> WorkyBob: Oh, it was
03:46:20 <Baughn> WorkyBob: The fix for that didn't work.
03:46:23 <WorkyBob> oh, okay
03:46:28 <Baughn> ..testing's nice.
03:46:34 <Baughn> WorkyBob: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5337#a5337 <-- This one does.
03:46:56 <hackagebot> Chart 0.11
03:47:39 <quicksilver> Baughn: so your fix is for the same thing? it's just a fix which works?
03:47:56 <Baughn> quicksilver: Yes
03:47:58 <WorkyBob> Baughn: ohhh, that's a neat one
03:48:13 <WorkyBob> it's a shame unamb is such a hard bugger to implement right
03:48:22 <WorkyBob> it's got some really nasty gotchas
03:48:57 <WorkyBob> oh, also, neat - that one produces a "fast" bottom, doesn't it
03:49:04 <Baughn> It does, if it works. :)
03:49:06 <WorkyBob> i.e. if both are bottom, it terminates as bottom
03:49:11 <WorkyBob> rather than non-terminating
03:49:23 * quicksilver should carve out some time to poke at his implementation again.
03:49:25 <Baughn> Oh. Yes, but so did the last one.
03:49:31 <WorkyBob> hmm?
03:49:44 <WorkyBob> in the last one, if a thread threw an exception, the mvars never got written
03:49:46 <WorkyBob> and it just got blocked
03:49:50 <Baughn> Hm
03:50:12 <Baughn> I didn't realize. Seemed like the obvious thing to do..
03:50:30 <Baughn> WorkyBob: It also has an optimization-in-potentia in isEvaluated, I just don't quite dare to turn it on yet
03:50:37 <WorkyBob> hehe
03:50:39 <WorkyBob> yes
03:50:47 <WorkyBob> when did isEvaluated get added btw?
03:50:51 <Baughn> Yesterday
03:50:54 <WorkyBob> in amongst all the Vaccum fun?
03:51:21 <Baughn> I originally wrote it independently of vacuum, but using vacuum lets me get away with /not/ including all of GHC in the executable. :3
03:51:31 <WorkyBob> nice :)
03:52:55 <Baughn> ..oh, this is insane
03:53:18 <Baughn> I've got a thread blocked on writeChan /at the same time/ as another thread is blocked on readChan
03:53:21 <Baughn> For the same Chan
03:53:26 <WorkyBob> o.O
03:53:47 <Baughn> GHC just doesn't want to let me make makeEvent work. >_<
04:01:43 <Baughn> @tell conal ..also, it doesn't work. I appear to have two threads deadlocked on the same chan, reading and writing it respectively. No, no idea how. *groan*
04:01:44 <lambdabot> Consider it noted.
04:04:19 <mib_13lje4t4> hey guys im using get line to get a year value
04:04:47 <mib_13lje4t4> but it comes up as the return value for getLine is [char]
04:05:09 <mib_13lje4t4> and i need an Int
04:05:13 <mib_13lje4t4> any ideas?
04:05:19 <ivanm> mib_13lje4t4: read it
04:05:20 <Axman6> you want readLn
04:05:23 <ivanm> > read "1234"
04:05:25 <lambdabot>   * Exception: Prelude.read: no parse
04:05:31 <ivanm> @type readLn
04:05:32 <lambdabot> forall a. (Read a) => IO a
04:05:40 <ivanm> hmmmm, didn't know about readLn
04:05:42 <Axman6> @src readLn
04:05:43 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
04:05:55 <Gracenotes> @type readIO
04:05:56 <lambdabot> forall a. (Read a) => String -> IO a
04:06:07 <Axman6> @src readIO
04:06:07 <lambdabot> Source not found. Just try something else.
04:06:18 <ivanm> why is it IO?
04:06:22 <ivanm> @src readIO
04:06:23 <lambdabot> Source not found. It can only be attributed to human error.
04:06:25 <Axman6> no idea
04:06:26 <Gracenotes> r <- readIO l; return r? A bit redundant? :P
04:06:44 <ivanm> Gracenotes: yeah
04:07:05 <WorkyBob> o.O
04:07:20 <ivanm> but AFAICT, readIO = liftM read
04:07:21 <ivanm> :s
04:07:29 <ivanm> take it back, it isn't
04:07:37 <ivanm> readIO str = return (read str)
04:07:46 <doserj> readIO throws an IOException  instead of error
04:08:04 <ivanm> doserj: if read fails? that makes sense then
04:08:06 <Gracenotes> oh, I see.
04:08:22 <doserj> ivanm: yes
04:08:48 <Gracenotes> here
04:08:50 <Gracenotes> readIO s =  case (do { (x,t) <- reads s; ("","") <- lex t; return x }) of { [x]    -> return x; [] -> ioError (userError "Prelude.readIO: no parse");  _ -> ioError (userError "Prelude.readIO: ambiguous parse") }
04:08:51 <ivanm> since it's easier to catch IOException rather than an error?
04:09:08 <Gracenotes> from System.IO
04:09:14 <ivanm> hmmm....
04:09:16 <ivanm> @type lex
04:09:17 <lambdabot> String -> [(String, String)]
04:09:17 <ivanm> @src lex
04:09:18 <lambdabot> Source not found. I feel much better now.
04:09:39 <ivanm> what's lex?
04:09:45 <ivanm> > lex "1234"
04:09:46 <doserj> ivanm: yes. you can't catch error in Haskell98
04:09:47 <lambdabot>   [("1234","")]
04:09:50 <Gracenotes> ivanm: catching of native errors always occurs in the IO monad. So may as well throw in the IO monad
04:09:56 <Gracenotes> me guesses
04:09:58 <ivanm> > lex "Maybe 1234"
04:10:00 <lambdabot>   [("Maybe"," 1234")]
04:10:06 <ivanm> >_>
04:10:12 <Gracenotes> ooooh... that's an interesting function
04:10:21 <Gracenotes> > lex "Maybe!"
04:10:22 <lambdabot>   [("Maybe","!")]
04:10:32 <Gracenotes> so that's how reading occurs like that
04:10:38 <ivanm> but what does it actually _do_?
04:11:14 <ivanm> since it isn't class based, how does it know which constructor to read?
04:11:25 <ivanm> or does it split symbols from letters?
04:11:34 <ivanm> > lex "1234Maybe"
04:11:35 <lambdabot>   [("1234","Maybe")]
04:11:44 <ivanm> @index lex
04:11:45 <lambdabot> Text.Read, Prelude, Text.Read.Lex
04:12:21 <doserj> ivanm: it splits the input text into tokens, approximating Haskell syntax rules
04:12:24 <Baughn> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5338#a5338 <-- While you're around, any idea how this code can (when running the finalizer for chan1w) get to state "croak", while the reader is at "wannaread", and the program then /deadlocks and exits/?
04:12:35 <Gracenotes> ivanm: let is defined precisely in the prelude
04:12:37 <Gracenotes> http://www.haskell.org/onlinereport/standard-prelude.html#sect8.2
04:12:39 <ivanm> doserj: *nod*
04:12:43 <ivanm> Gracenotes: you mean lex?
04:12:44 <Gracenotes> it's Haskell 98. that's how srs it is
04:12:52 <Baughn> quicksilver: I mean, I've then got one thread doing a write to the Chan while another is reading, and somehow it deadlocks.
04:12:53 <ivanm> "srs"?
04:12:59 <Gracenotes> lex, right. Check out the link for the exact algorithm
04:13:02 <Gracenotes> serious
04:13:10 <quicksilver> Baughn: threaded or non-threaded rts?
04:13:33 <Baughn> quicksilver: Both
04:14:39 <nopsled_X> Newbie question: how would i use the function >> bind f' (gx,gs) = let (fx,fs) = f' gx in (fx,gs++fs) << ?
04:15:11 <nopsled_X> exploring monads ..
04:15:22 <ivanm> @hoogle bind
04:15:23 <lambdabot> Distribution.Simple.InstallDirs bindir :: InstallDirs dir -> dir
04:15:23 <lambdabot> Distribution.Simple.InstallDirs BindirVar :: PathTemplateVariable
04:15:23 <lambdabot> Language.Haskell.TH.Syntax bindQ :: Q a -> (a -> Q b) -> Q b
04:15:23 <Gracenotes> looks like bind for the Writer monad .. for lists
04:16:01 <nopsled_X> Its from the article "you-could-have-invented-monads-and.html"
04:16:34 <Gracenotes> to get the most out of the Writer monad, you need the "tell" function
04:16:50 <Gracenotes> ..hm
04:17:09 <nopsled_X> idea was from let (y,s) = g' x
04:17:10 <nopsled_X> (z,t) = f' y in (z,s++t)
04:17:17 <nopsled_X> define bind..
04:17:32 <quicksilver> Baughn: are you sure the main thread isn't just running out? what is keeping the main thread alive? just tryning to eliminate possibilities here
04:18:24 <Baughn> quicksilver: I suppose.. here's the code for the main thread, so as you can see I'm pretty sure. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5338#a5339
04:18:47 <Gracenotes> nopsled_X: the Writer monad lets you do normal operations with "gx" and "fx"
04:19:16 <nopsled_X> Gracenotes: ok
04:19:22 <Baughn> quicksilver: And just to make extra sure, I just switched it for print $ eFutures ev. That ought to finish by printing a ], not "test: thread blocked indefinitely".
04:19:26 <Gracenotes> however, it has an extra parameter for a monoid
04:19:28 <Gracenotes> in your case, a list
04:19:41 <quicksilver> Baughn: I don't think addFinaliser works the way you think it does.
04:19:48 <Baughn> quicksilver: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5338#a5340 <-- Here's the actual output
04:19:50 <Gracenotes> so it's like you're working on two values at the same time: a normal value, and something else that accumulates
04:20:23 <Baughn> quicksilver: I know it doesn't necessarily get called immediately, but as the output shows it /does/ get called. The finalizer is working, it's the finally code that isn't.
04:20:26 <nopsled_X> haskells notion of state.. ?
04:20:38 <quicksilver> Baughn: the finaliser is being called too early.
04:20:44 <quicksilver> Baughn: which is always a risk with addFinaliser.
04:20:52 <quicksilver> Baughn: that kills the thread.
04:21:00 <Gracenotes> nopsled_X: sort of. The Writer monad is meant to extend the state -- aka write-only -- not necessarily read it
04:21:02 <quicksilver> is my guess.
04:21:20 <Gracenotes> or to modify it. (although these operations are supported, they're not commonly used)
04:21:29 <Gracenotes> there is an actual State monad that is intended for this
04:21:38 <Baughn> quicksilver: The finalizer is being called at exactly the right time, once the sink-calling thread exits
04:21:57 <Baughn> quicksilver: Also, if it did get called too early the effect of the would be occurences going missing, not a deadlock
04:22:00 <EvilTerran> nopsled_X, Writer is for things such as producing a log alongside the evaluation
04:22:19 <Gracenotes> nopsled_X: I think http://book.realworldhaskell.org/read/monads.html#id640791 explains the Writer monad better
04:22:33 <Gracenotes> It's actually a specific version of Writer -- for lists
04:22:37 <Gracenotes> like you have there
04:23:32 <Gracenotes> er. actually it's introduced in http://book.realworldhaskell.org/read/monads.html#monads.logger , but the implementation is in the first link
04:23:43 <Baughn> quicksilver: Still. You can probably see what I'm trying to do here; if you have any better suggestions, I'm all ears. I've gone through about six revisions that all either called the finalizers too early or not at all. This one calls them correctly, but they then fail to work. :
04:23:48 <Baughn> :/
04:24:00 <quicksilver> Baughn: My theory was, a finaliser being called too early would kill a blocked thread which then causes deadlock as there is nothing left to break it
04:24:22 <nopsled_X> Gracenotes: thanks :-)
04:24:37 <Baughn> quicksilver: The Chan programmers were smarter than that. It uses withMVar, etc. - things that carefully unlock the Chan if it gets aborted.
04:25:07 <quicksilver> Baughn: yes, but that's not the point.
04:25:09 <Baughn> quicksilver: Wait.. you may have something there
04:25:12 <quicksilver> Baughn: if I kill the last possible reader
04:25:18 <quicksilver> than any remaining writer is in deadlock
04:25:21 <quicksilver> or vice-versa
04:25:29 <Baughn> Oh, sure. The reader isn't killed
04:25:48 <Gracenotes> nopsled_X: no problem. There are lots of resources out there :) If you need to look at the implementations for some common monads see Part II here http://www.haskell.org/all_about_monads/html/index.html
04:26:13 <osfameron> don't most censorship regimes burn books rather than killing readers?
04:26:22 <nopsled_X> Gracenotes: thanks :-)
04:26:47 <whoppix> osfameron, yes, killing all the readers is somewhat impractical
04:26:51 <quicksilver> Baughn: well in this specific case, a finaliser running early kills the last remaning writer to chan2
04:26:59 <QtPlaty[HireMe]>  s
04:27:11 <quicksilver> Baughn: which means the reads on chan2 are deadlock (i.e. the next time you look for an event occurence)
04:27:32 <Baughn> quicksilver: Yes, that's what the finally clause is for
04:27:47 <Baughn> quicksilver: The writer is supposed to put Nothing in the chan, which will make the reader bail out and stop reading
04:28:42 <quicksilver> Baughn: I think you should put a print in the other finaliser too.
04:30:04 <quicksilver> maybe the thread is getting killed twice
04:30:12 <quicksilver> second kill arriving in the finally
04:30:39 <Baughn> quicksilver: Exceptions are blocked in exception handlers. But if the reader gets killed..
04:31:04 <quicksilver> Baughn: not if the handler contains an unblock they aren't.
04:31:10 <quicksilver> Baughn: and chan2w contains an unblock.
04:31:16 <Baughn> ..the write
04:33:40 <Baughn> quicksilver: You're right, the chan2r finalizer does get run. But why, when readOccurences is in the middle of calling it?
04:34:06 <quicksilver> because addFinaliser doesn't mean what you think it means.
04:34:28 <quicksilver> it adds a finaliser to what, for lack of a better word, I'll call a "box"
04:34:46 <quicksilver> but you have no guarantee that all uses of chan2r actually use the "chan2r box" that the finaliser is attached to.
04:34:59 <quicksilver> other uses of chan2r may happily have inlined some or all of that box.
04:35:10 <Baughn> That is, admittedly, true
04:35:22 <Baughn> But I don't see how I'm going to pull this off without finalizers
04:35:23 <quicksilver> I'm pretty sure in your example all uses of chan2r will definitely be inlined
04:35:33 <quicksilver> so I'd expect that finaliser to be eligible for running immediately
04:35:34 <Baughn> Um.. let me explain in #ghc
04:35:38 <quicksilver> (and, in practice, get run at the next GC)
04:46:43 <mib_13lje4t4> hey what does this error mean "Instance of Num [Char] required for definition of mainMenu"?
04:47:05 <Zao> mib_13lje4t4: Depends on what mainMenu is and how you were using it.
04:47:15 <mib_13lje4t4> ok
04:47:18 <mib_13lje4t4> ill hpaste
04:48:24 <Gracenotes> mib_13lje4t4: it probably means that a [Char] was expected, but that a Num was inferred
04:48:35 <Gracenotes> (Num being a typeclass makes the error a bit more cryptic)
04:49:09 <Gracenotes> or it could mean the other way around, wrt expected/inferred...
04:49:15 <mib_13lje4t4> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5341#a5341
04:49:54 <Gracenotes> x is a string, and you're comparing it to 1
04:49:56 <EvilTerran> mib_13lje4t4, that error tends to mean that you're trying to use a number as a string, or vice-versa
04:49:59 <mib_13lje4t4> ERROR file:.\FilmV3.hs:128 - Instance of Num [Char] required for definition of mainMenu
04:50:08 <Gracenotes> that's a no-no >_>
04:50:32 <EvilTerran> mib_13lje4t4, "Instance of Num [Char] required" means "I need [Char] to be a numeric type, but it isn't!"
04:50:39 <EvilTerran> and [Char] = String
04:50:46 <Gracenotes> actually, this was brought up earlier :) try readLn
04:50:49 <mib_13lje4t4> ah ok
04:50:49 <Zao> Isn't the else too far outdented?
04:50:50 <Gracenotes> @type readLn
04:50:52 <lambdabot> forall a. (Read a) => IO a
04:51:03 <mib_13lje4t4> easier if i just call them A B C ....
04:51:07 <Gracenotes> x <- readLn
04:51:15 <Gracenotes> although you might need to specify the type of x
04:51:53 <mib_13lje4t4> readLn sorted it
04:51:56 <mib_13lje4t4> :)
04:55:41 <Baughn> @type (>=>)
04:55:42 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:56:29 <Baughn> @index (>=>)
04:56:30 <lambdabot> bzzt
04:56:40 <Baughn> @hoogle (>=>)
04:56:40 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
05:02:58 <EvilTerran> mib_13lje4t4, the other possibility would be continuing to use getLine, and replacing the x == 1 with x == "1"
05:07:14 <ski> > read " 1" :: Int
05:07:16 <lambdabot>   1
05:10:38 <Baughn> ..now it's just taunting me.
05:14:52 <dancor_> what would you do if you sent takusen a question and later answered it with a patch and neither maintainer ever responded
05:15:05 <dancor_> forkusen?
05:15:53 <pejo> Pingusen?
05:16:18 <dancor_> mm
05:16:41 <povman> Good Morning Everyone!
05:17:49 <lilac> good early afternoon, povman
05:17:51 <dancor_> gm
05:18:09 <ivanm> povman: g'evening
05:19:16 <povman> If I compile a program with GHC, can i call its 'main' from a c program without the FFI?
05:19:18 <quicksilver> dancor_: haskel-cafusen
05:19:31 <dancor_> what is the scope of haskell-cafe
05:19:42 <quicksilver> stuff about haskell.
05:19:47 * EvilTerran is confusen
05:19:49 <dancor_> is it a forum for revenge on maintainers
05:19:55 <quicksilver> sure, among other things.
05:20:07 <quicksilver> there are was of saying things, though.
05:20:28 <ivanm> dancor_: maintainers of what?
05:20:29 <quicksilver> You can say something like "here is a patch I find useful with takusen, here is a place you can download it from, does anybody have any comments" ?
05:21:44 <mib_13lje4t4> hey is there a function that outputs a list rather than a string?
05:22:23 <povman> mib_13lje4t4: That is a very vague question, but here's one:  f = []
05:22:24 <EvilTerran> mib_13lje4t4, er, a string is a list
05:22:30 <EvilTerran> ?src String
05:22:31 <lambdabot> type String = [Char]
05:23:01 <b_jonas> > ['s','t','r','i','n','g']
05:23:02 <lambdabot>   "string"
05:23:19 <mib_13lje4t4> im trying to out put a list of tuples though
05:23:22 <b_jonas> (unlike in standard ml where a string is an iarray of chars)
05:23:29 <EvilTerran> > map toUpper "abracadabra"
05:23:30 <lambdabot>   "ABRACADABRA"
05:24:05 <ivanm> b_jonas: after all, if C does it then it _must_ be a good idea! :p
05:24:50 <quicksilver> mib_13lje4t4: you can "show" most combinations of built in types.
05:25:02 <quicksilver> > show [(1,3),(3,4)]
05:25:04 <lambdabot>   "[(1,3),(3,4)]"
05:25:13 <EvilTerran> ?type print
05:25:15 <quicksilver> mib_13lje4t4: so you can show it and then putStrLn it
05:25:15 <lambdabot> forall a. (Show a) => a -> IO ()
05:25:21 <EvilTerran> ?src print
05:25:22 <lambdabot> print x = putStrLn (show x)
05:25:58 <povman> If I compile a program with GHC, can i call its 'main' from a c program without the FFI?
05:26:32 <EvilTerran> fork() and exec()?
05:26:52 <povman> I mean a direct function call
05:27:06 <quicksilver> no.
05:27:28 <quicksilver> You'll need to set up the haskell RTS and stuff.
05:27:30 <mib_13lje4t4> quicksilver would deriving (Show) be put in the function that is returning the list?
05:27:36 <quicksilver> mib_13lje4t4: no.
05:27:54 <quicksilver> mib_13lje4t4: most built in types and combinations of them are already instances of Show, in fact.
05:28:02 <b_jonas> povman: do you mean http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html ?
05:28:12 <povman> If i have main(){hs_init(...); CALL_HS_MAIN(); hs_exit(); return 0;}
05:28:38 <mib_13lje4t4> sooo... putStrLn show [a]?
05:28:42 <povman> b_jonas: I want a C program that runs a haskell program without the haskell author needing to know
05:29:05 <b_jonas> povman: I think you need to export functions with ffi
05:29:29 <povman> There isn't a consistent symbol for main?
05:29:37 <Cale> povman: Wrap hs_init and hs_exit in something and tell the person writing the C program to call that :)
05:30:24 <povman> Cale: I'm writing the C program, I want it to call hs main as a function, without hs main being ffi exported
05:31:01 <Cale> povman: Oh, I see what you mean.
05:31:10 <b_jonas> povman: what if you write a haskell function in another module that just calls main, and export that?
05:31:12 <povman> I was hoping there'd be a single entry point which i could point at
05:31:42 <povman> b_jonas: That requires the 'other module' to know what the main module is :(
05:31:55 <povman> i'm so bad at linker
05:34:18 <lilac> povman: you could possibly dlopen the haskell binary and use dlsym to find the GHC RTS entry point
05:35:01 <povman> lilac: Curious..
05:36:03 <lilac> why can't you just fork and exec?
05:38:15 <povman> lilac: I fear that might not work. I'm fixing the SDL binding
05:41:09 <codebliss> Hello.  I'm working on a ripoff of the Maybe monad for practice.  Here's my code, I have an error.  More information in the pastebin =D    http://pastebin.com/m5a48adf1
05:41:27 <codebliss> I'm still trying to get used to this type mania
05:41:49 <povman> Your names are totally rad, dude
05:42:16 <codebliss> hahahaha XD
05:42:25 <mux> codebliss: you need a "| otherwise = ..." in the second case
05:42:30 <mux> since you're using pattern guards
05:42:31 <codebliss> Okay
05:42:42 <codebliss> >liftM2 (+) (Totally 5) (Totally 29)
05:42:44 <codebliss> Totally 34
05:42:48 <codebliss> hahaha XD
05:42:53 <ski>   Totally x >>= f = f x
05:42:54 <povman> I'm being completely weirded out by the (//)   - why parentheses?
05:42:59 <ski>   a // b | b == 0            = Null
05:43:04 <codebliss> Oh ya, you don't need it there
05:43:11 <ski>   Totally a // Totally b = Totally (a / b)
05:43:11 <codebliss> *facepalm*
05:43:16 <mux> povman: those seem weird indeed, parenthesis are used around operators to use them in prefix form
05:43:29 <codebliss> Understood, I have no idea why I did that
05:43:33 <lilac> codebliss: the | b == 0 is wrong too
05:43:41 <povman> Yes, i read that as (//) a pattern argument of (Totally a)
05:43:47 <lilac> codebliss: since b is a Possibly t for some t
05:44:00 <mux> right
05:44:04 <lilac> (and not a Num instance)
05:44:11 <lilac> (and not an Eq instance either)
05:44:19 <mux> missed that one; should be a // (Totally b) | b == 0 = ...
05:44:21 <codebliss> _ // (Totally b) | b == 0            = Null
05:44:26 <codebliss> Got it
05:44:32 <codebliss> Understood thank you =D
05:44:45 <ski> no brackets needed around `Totally b'
05:44:45 <doserj> you can just write _ // (Totally 0) = Null
05:44:53 <lilac> codebliss: you'll also need a // Null case
05:45:09 <codebliss> Roger, thank you very much all of you
05:45:19 <codebliss> That...is a very good idea
05:45:30 <lilac> codebliss: you might want to consider adding Eq to your deriving clause
05:45:37 <byorgey> codebliss: what type do you want // to have?  I would have thought something like  Double -> Double -> Possibly Double
05:45:39 <lilac> then you can say 'a // b | b = Totally 0 = Null'
05:45:53 <byorgey> but looks like you have  Possibly Double -> Possibly Double -> Possibly Double
05:46:05 <lilac> s/b =/b ==/
05:46:06 <codebliss> OH
05:46:08 <codebliss> I gotcha
05:46:12 <codebliss> byorgey: Thanks
05:46:31 <codebliss> I just wanted Num a => a -> a -> Possibly a
05:46:36 <byorgey> right
05:46:58 <byorgey> well, Num won't work, but Fractional will
05:47:00 <codebliss> I need to wake up, lol.  Thanks again all
05:47:06 <codebliss> *refacepalm*
05:47:17 <byorgey> hehe
05:49:05 <lilac> you could also make a Num a => Num (Possibly a) instance...
05:49:11 <codebliss> *Main> 5 // 0
05:49:11 <codebliss> Null
05:49:11 <codebliss> *Main> 5 // 3
05:49:11 <codebliss> Totally 1.6666666666666667
05:49:12 <codebliss> Thank you
05:49:22 <lilac> depending on whether you want to work in the monadic style or the numeric style
05:49:33 <povman> I think in this case, facepalming is good for you
05:49:48 <codebliss> Facepalming helps the blood in my brain =P
05:49:59 <lilac> don't worry if your head hurts, it's just your brain getting bigger
05:50:09 <lilac> ;-D
05:50:13 <codebliss> =D.  Damn haskell making me think, it's addicting!
05:50:34 <codebliss> I still laugh at (,) being a function.  That's just too awesome
05:51:25 <codebliss> Okay not literally, but I love pure fprogramming
05:52:13 <povman> Ok, i've got my wrapper down to a single foreign export ccall "hs_main" main :: IO ()
05:53:25 <quicksilver> it's sometimes bad for your keyboard.
05:57:01 <McManiaC> what do i need to use "foreign import ..." ? i always get "parse error on import"
05:57:38 <EvilTerran> {-# LANGUAGE ForeignFunctionInterface #-}
05:57:40 <EvilTerran> iirc
05:57:54 <povman> that is correct
05:58:40 <McManiaC> ok thx!
06:08:25 <povman> YESSSSS!!!!! VICTOLY!  I feel so dirty, yet so clean.
06:09:05 <povman> It should now be possible for haskell people to write cross platform SDL programs without all this C nonsense
06:09:06 <Saizan> ?
06:09:13 * byorgey high-fives povman 
06:09:22 <povman> it's disgusting
06:09:33 <povman> I'd better make sure it's portable
06:09:41 <byorgey> povman: how did you get around the external-main thing?
06:09:47 <liyang> povman: BIKUTORI, shurely.
06:10:34 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2514#a2514
06:12:02 <Baughn> povman: It would be easier if SDL didn't do so many disgusting hacks
06:12:12 <povman> Baughn: so true.
06:12:26 <povman> They want their C interface to be the same everywhere though, which is reasonable
06:12:47 <Baughn> povman: They could do it some other way
06:13:34 <povman> well. Maybe. The #sdl people didn't much like my suggestion to delete the #define main SDL_main
06:14:46 <povman> this is making me wet
06:15:59 <povman> I think i'm going to cry of happiness
06:22:18 <cnwdup> @seen dons
06:22:18 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 12h 34m 49s ago.
06:24:59 <povman> @seen Lemmih
06:25:00 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 4h 23m 44s ago.
06:33:42 <fasta> Is there some file API which replaces ~ by the home dir? Preferably something which also works on $PLATFORM.
06:34:47 <quicksilver> I doubt it.
06:35:39 <earthy> not that I know of
06:35:43 <Absolute0> Do I need to use monads to change a state of some object?
06:36:28 <Absolute0> Say I have a map and I want to change the key of that map
06:36:37 <Absolute0> doing that in function results in nothing
06:36:45 <kpreid> Absolute0: It depends on what you mean by change, really :-)
06:36:49 <Absolute0> *key of an item in the map
06:36:50 <doserj> there are no objects in haskell, and you don't change state in haskell :)
06:36:55 <fasta> Absolute0: you cannot actually change anything, but you can use monads to achieve something similar.
06:37:01 <kpreid> Absolute0: You have two options ...
06:37:17 <Saizan> Absolute0: you usually just return a updated map and use that from then on
06:37:17 <Absolute0> in ghci you just call the functions and it does the job
06:37:19 <kpreid> You can write a routine to take a value and return a modified value
06:37:21 <earthy> fasta: however, there is System.Directory.getHomeDirectory
06:37:38 <kpreid> Or you can use some monad with references such as ST, STM or, if you must, IO
06:37:41 <earthy> and System.Directory.getUserDocumentsDirectory
06:37:47 <fasta> earthy: yes, I already wrote my own version based on that.
06:37:58 <Absolute0> let me play with it some more
06:38:02 <kpreid> It is generally better to use the 'return modified' approach as it is more flexible
06:38:16 <Absolute0> is there a concept of pass by value/reference in haskell?
06:38:26 <earthy> yes.
06:38:31 <kpreid> No. You always pass values by reference...
06:38:32 <earthy> everything is passed by valuw
06:38:36 <earthy> value
06:38:42 <Axman6> heh
06:38:51 <fasta> Absolute0: everything is pass by value, ST/IO can be used for references.
06:38:52 <earthy> even references are passed by value. :)
06:39:01 <kpreid> Er, right, I got that backwards
06:39:11 <b_jonas> fasta: try http://erxz.com/pb/17862
06:39:13 <kpreid> If you have one thing which a complex program wants to modify repeatedly, consider using the State monad (which is just a decorative wrapper around passing the value)
06:39:17 <quicksilver> well, at the level of implementation, everything is indeed passed by reference.
06:39:17 <Absolute0> and things are accessed by pointers like in java?
06:39:23 <Absolute0> ie references
06:39:26 <quicksilver> (so you can assuming that no copying takes place - passing is fast)
06:39:31 <opqdonut> value and reference are really the same in a referentially transparent language :)
06:39:32 <Absolute0> right
06:39:33 <kpreid> Absolute0: That distinction doesn't make sense in Haskell.
06:39:37 <opqdonut> indeed
06:39:40 <quicksilver> however at the level of semantics everything is passed by value
06:39:40 * earthy nods
06:39:50 <quicksilver> if you can't modify a reference, it doesn't matter :)
06:39:51 <fasta> b_jonas: I wrote something similar, but based on getHomeDirectory. I will just keep it that way.
06:39:55 <kpreid> Absolute0: Since there is no mutation (outside of the reified stuff in IO/ST/...) there is no difference between pass-by-*
06:39:59 <Absolute0> quicksilver: copying large objects is slow..
06:40:01 <lilac> fasta: there's something in libtcl which does ~-expansion, and libtcl is probably available on $PLATFORM...
06:40:06 <kpreid> Absolute0: so you don't copy
06:40:06 <quicksilver> Absolute0: indeed. and they are not copied.
06:40:13 <lilac> fasta: admittedly that's probably not a very helpful answer, but...
06:40:17 <quicksilver> Absolute0: since everything is immutable there is no need to copy.
06:40:20 <WorkyBob> Absolute0: clever implementations don't copy things ;)
06:40:26 <earthy> unless you generate a new value out of the old value...
06:40:29 <earthy> reusing parts of it
06:40:38 <kpreid> > let x = [1,2,3] in (0:tail x) -- I did not copy x, but I produced a modified version of it
06:40:40 <earthy> then those parts *may* get copied...
06:40:42 <lambdabot>   [0,2,3]
06:40:42 <fasta> WorkyBob: too bad there are no smart implementations :)
06:40:58 <earthy> ofcourse, there's also the copying garbage collector which copies things regularly anyway
06:41:06 <earthy> but that's another matter entirely ;)
06:41:16 <Absolute0> let me just see what Data.Map.insert returns :) that will solve all my problems
06:41:23 <lilac> b_jonas: that doesn't work for ~foo/... :-/
06:41:25 <kpreid> :t Data.Map.insert
06:41:28 <lambdabot> forall k a. (Ord k) => k -> a -> M.Map k a -> M.Map k a
06:41:46 <Absolute0> it returns the modified map..
06:41:47 <Absolute0> ok
06:41:53 <fasta> lilac: it should not work for that input.
06:41:58 <kpreid> > M.insert "a" "b" (M.empty)
06:41:59 <lambdabot>   fromList [("a","b")]
06:42:03 <b_jonas> lilac: yup
06:42:10 <lilac> fasta: ~foo/ should mean foo's home dir
06:42:12 <b_jonas> lilac: also not for ~+ and ~- and ~1 and stuff
06:42:23 <lilac> b_jonas: what do those do? :)
06:42:48 <fasta> lilac: oh, I didn't know that.
06:42:57 <fasta> lilac: what's the point of doing that?
06:43:07 <quicksilver> historically, ~-expansion is a feature of the shell not, for example, the filesystem or the c library
06:43:07 <b_jonas> lilac: ~+ is bashism for the current directory, ~- is the OLDPWD env-var which cd sets to the old directory when you change, ~1 and ~2 and ~+1 etc are the directory stack (dirs, pushd, popd) thing
06:43:08 <lilac> fasta: it's mandated by POSIX iirc
06:43:10 <Absolute0> also what is the best way for parsing/tokenizing strings in haskell?
06:43:12 <quicksilver> thus is varies from shell to shell
06:43:13 <b_jonas> they're useful in the shell line often
06:43:29 <WorkyBob> Absolute0: depends on how complex the parsing you want to do is
06:43:51 <WorkyBob> one of happy/parsec/manually writing a parser usually though
06:44:10 <Absolute0> I have a string "(a,1) -> (b,2)" and i need to convert them to the tuples: ('a', 1) and ('b',2)
06:44:19 <WorkyBob> oh, manually then
06:44:30 <yowgi> i find that with happy there can be a lot of repetitions between types and the grammar
06:44:41 <WorkyBob> read . takeWhile (/= ' ') -- first tuple
06:44:48 <Absolute0> happy is a library?
06:44:58 <earthy> happy is a parser generator
06:44:59 <thoughtpolice> Absolute0: happy is a parser generator, like gnu bison
06:45:02 <WorkyBob> read . dropWhile (/='(') . tail -- second tuple
06:45:07 <earthy> (or antlr)
06:45:19 <earthy> parsec in applicative style is quite nice though as well
06:46:06 <Absolute0> WorkyBob: the tuple should be (Char, Int) not just another string.
06:46:11 <Absolute0> ok i can play with it..
06:46:16 <WorkyBob> Absolute0: that's what read does
06:46:19 <WorkyBob> @type read
06:46:21 <lambdabot> forall a. (Read a) => String -> a
06:46:21 <Absolute0> ah
06:46:27 <Absolute0> cool
06:46:28 <Absolute0> :)
06:46:31 <WorkyBob> > read "(5, \"jam\")"
06:46:33 <lambdabot>   * Exception: Prelude.read: no parse
06:46:42 <WorkyBob> > read "(5, \"jam\")" :: (Int, String)
06:46:43 <lambdabot>   (5,"jam")
06:46:58 <earthy> does require quotes though
06:47:08 <earthy> > read "(5, a)" :: (Int,Char)
06:47:09 <lambdabot>   * Exception: Prelude.read: no parse
06:47:35 <WorkyBob> oh okay then, you want a little custom character reading function then
06:47:45 <kpreid> > read "(5, a)" :: (Int,Expr) -- probably not what you want
06:47:46 <lambdabot>   No instance for (GHC.Read.Read SimpleReflect.Expr)
06:47:46 <lambdabot>    arising from a use of...
06:47:50 <kpreid> (even if it worked)
06:48:10 <Absolute0>  read "('a',5)"::(Char, Int)
06:48:10 <Absolute0> ('a',5)
06:48:12 <Absolute0> :)
06:48:15 <WorkyBob> > read "(5, 'a')" :: (Int, Char)
06:48:16 <lambdabot>   (5,'a')
06:48:16 <Absolute0> works just fine
06:48:26 <WorkyBob> Absolute0: sure, but not if you don't include the quotes
06:48:27 <earthy> as I said, requires quotes :)
06:49:16 <Absolute0> oh sorry I missed the quotes in my question.
06:49:23 <Absolute0> I can make the user enter them in. :-P
06:49:27 <WorkyBob> :)
06:49:32 <Absolute0> I'll probably be the only user anyways
06:49:36 <Absolute0> i can take it
06:50:05 <WorkyBob> if you want to do something more permissive that lets you include spaces in the tuple etc, you'll need a little bit more preprocessing than I did, but *shrug*
06:50:12 <lilac> b_jonas: interesting. so "cd -" is really just shorthand for "cd ~-" then? :)
06:50:21 <WorkyBob> takeWhile (/=')') and append the close paren might work nicely
06:50:28 <b_jonas> lilac: yes, they're the same
06:50:37 <b_jonas> mostly
06:51:43 <hackagebot> linear-maps 0.6.1
06:52:55 <Absolute0> doesn't Data.Map.delete violate the haskell philosophy?
06:53:00 <Absolute0> or insert
06:53:02 <WorkyBob> nope
06:53:06 <WorkyBob> you get a new map back
06:53:08 <Absolute0> the result is different each time
06:53:09 <WorkyBob> with the value deleted
06:53:15 <WorkyBob> hmm? show me an input
06:53:21 <WorkyBob> for which I can call it multiple times
06:53:24 <WorkyBob> and get different results
06:53:24 <Zao> Absolute0: Given a certain input, it gives the same output.
06:53:25 <EvilTerran> the old map stays the same
06:53:30 <Absolute0> oh :)
06:53:31 <Absolute0> ok
06:53:39 <opqdonut> of course those operations are implemented efficiently so the input and the output share as much as possible
06:53:41 <Absolute0> still getting used to it..
06:53:53 <fasta> Absolute0: also, it is not a Haskell philosophy. All this stuff comes from the 70's and was in fact more advanced back then.
06:54:14 <fasta> Absolute0: this just had a different name for these kind of structures.
06:54:20 <WorkyBob> fasta: sure it is
06:54:28 <opqdonut> yeah, persistent data structures
06:54:29 <WorkyBob> just like "give the user access to the machine" is the C philosophy
06:54:33 <fasta> opqdonut: right
06:54:42 <opqdonut> some really good papers back there
06:54:45 <WorkyBob> it having been done before doesn't make it any less the haskell philosophy
06:55:11 <opqdonut> the haskell philosophy is "support abstraction with types", not "purity" :)
06:55:12 <opqdonut> imo
06:55:21 <WorkyBob> depends who you ask
06:55:22 <Absolute0> It's cool how the Data.Map doc's print the actuall order complexity.
06:55:27 <WorkyBob> perhaps that's the great thing about Haskell
06:55:33 <WorkyBob> different people can get totally different things from it
06:55:34 <Absolute0> haskell duded care about effeciency.
06:55:40 <Absolute0> dudes
06:55:51 <b_jonas> well, the Data.Map is written in pure haskell with no unsafe functions or anything like that, so its functions must be safe
06:56:32 <lilac> where "safe" == referentially transparent
06:56:40 <fasta> Absolute0: some do, but not all.
06:56:53 <WorkyBob> most care about complexity
06:57:03 <WorkyBob> few care about number-of-machine-operations type efficiency
06:57:10 * Axman6 cares
06:57:15 <mercury^> Unfortunately. :(
06:57:39 <lilac> most care about complexity, but not always computational complexity. sometimes code complexity is more important ;-)
06:57:46 <WorkyBob> indeed
06:58:16 <lilac> fwiw, i sometimes care about number-of-machine-operations type efficiency, and number-of-bytes-of-memory efficiency...
06:58:27 <opqdonut> type-efficiency ;)
06:58:37 <lilac> heh
06:58:58 <opqdonut> "this code type-checks in under 30 unifications!"
06:58:59 <WorkyBob> I care that my entire program is efficient... meaning that GHC's already run it in the type system when I compile it
06:59:00 <WorkyBob> >.<
06:59:24 <lilac> WorkyBob: doesn't that make your development process less efficient? :)
06:59:28 <WorkyBob> hehe
06:59:44 <fasta> The whole of CS is about number-of-machine operations in some way. If it isn't, then CS has no right to exist anymore.
07:00:01 <opqdonut> CS is about computability
07:00:42 <opqdonut> efficiency of computation is just a subfield
07:00:46 <fasta> opqdonut: ok, maybe I meant the algorithmic part of CS>
07:01:43 <fasta> And, the next interesting thing someone might say about computability will have to be someone with a degree in physics.
07:02:38 <opqdonut> are you referring to quantum computers? their theoretical properties are pretty well known
07:02:41 <opqdonut> BQP and all
07:02:49 <fasta> opqdonut: no, I was not referring to quantum computers.
07:02:56 <opqdonut> ok
07:03:10 <fasta> opqdonut: I was referring to something which might invalidate the Church-Turing thesis.
07:03:25 <opqdonut> that'd be cool
07:03:44 <fasta> opqdonut: there is a guy who wrote about using quantum computers to do so.
07:03:54 <opqdonut> somehow cs is just a very convoluted branch of constructive mathematics ;)
07:04:03 <opqdonut> fasta: do you have a link?
07:04:26 <fasta> opqdonut: http://adsabs.harvard.edu/abs/2006cs.......10114T
07:04:41 <opqdonut> nice periods
07:05:41 <fasta> opqdonut: unfortunately, I was not able to follow it in detail, but that the Church-Turing thesis might not be true, is something which would not surprise me a lot.
07:06:25 <Axman6> hmm, CS needs laws
07:06:45 <Axman6> all good sciences have laws, and they make things easier
07:07:00 <lilac> fasta: how do you mean, might not be true?
07:07:05 <Axman6> V = IR etc
07:07:13 <lilac> it doesn't apply in general, only to a certain number of proven cases, right?
07:07:20 <fasta> Axman6: V=IR is a great simplification.
07:07:39 <lilac> fasta: isn't it the definition of resistance?
07:08:42 <fasta> lilac: yes, I was thinking of something else.
07:09:21 <fasta> lilac: I mean that you can in fact compute incomputable objects.
07:10:03 <lilac> fasta: you're right though; V=IR is a great simplification if you assume that R is constant
07:10:43 <mercury^> What is V=IR?
07:10:43 <lilac> in reality it's a function of temperature and a bunch of other effects, some of which will indirectly depend on V...
07:10:52 <lilac> mercury^: Ohm's law
07:11:38 <fasta> lilac: and of course temperature is also a model
07:11:55 <purplefistmixer> perhaps the laws of thermodynamics would be a better one to take
07:12:31 <fasta> "Laws" also stiffle innovation, in case they are wrong.
07:13:01 <lilac> fasta: absolutely. how many physicists have you heard discount theories because they would allow information to travel faster than the speed of light?
07:13:32 <fasta> lilac: a few, but I am not a physicist.
07:14:08 <jmcarthur_work> laws in science are different from laws in mathematics
07:14:11 <ksf> what's Mondad (->a)? eval/apply?
07:14:27 <Absolute0> I have 2 modules that each require the other to function, how can I prevent cycle imports?
07:14:31 <lilac> ksf: you mean Monad (->) a?
07:14:34 <jmcarthur_work> mathematical laws are only ever really accepted if they are proven, something which you con't even begin to do in science
07:14:37 <ksf> lilac, yes.
07:14:48 <lilac> ksf: that's the Reader monad with no clothes on
07:14:53 <quicksilver> jmcarthur_work: well you can prove scientific laws, based on other assumptions.
07:15:04 <quicksilver> jmcarthur_work: that's not all that different from mathematical laws
07:15:06 <ksf> There's no laws, unless you choose to invent them.
07:15:08 <quicksilver> but this is pretty off-topic :)
07:15:12 <jmcarthur_work> quicksilver, sure, but then it's only sensible to include those assumptions with the law
07:15:27 <jmcarthur_work> which is often left out of the law as it is usually cited
07:15:29 <fasta> jmcarthur_work: and what constitutes a proof?
07:15:49 <hackagebot> terrahs 0.6
07:15:52 <EvilTerran> Absolute0, the ghc manual has a bit on dealing with circular imports
07:15:57 <ksf> There can be no proof, only applicability of a model in a certain domain.
07:16:16 <ksf> look at, e.g., newtonian mechanics.
07:16:23 <fasta> jmcarthur_work: there is no ultimate truth. Everything is relative to something else and bottoms out at turtles.
07:16:27 <Absolute0> EvilTerran: i moved the dependent part into the other modules :)
07:16:35 <Absolute0> fixed.
07:16:37 <ksf> to say that the next big theory is more true is merely being blindly arrogant.
07:16:41 <jmcarthur_work> my point is that mathematical laws are generally given with their assumptions and can be verified based on those assumptions. scientific laws, not so much
07:16:47 <jmcarthur_work> i'm not claiming absolute truth
07:16:48 <lilac> ksf: couldn't you equally say, there are no proofs in mathematics, only applicability of a certain line of reasoning in a given model of logic with a certain set of axioms?
07:17:00 <jmcarthur_work> math is not reality anyway
07:17:03 <Absolute0> math/physics who cares go get a girlfriend :)
07:17:05 <ksf> lilac, I could'nt have said it better.
07:17:23 <jmcarthur_work> i think we are in agreement, just with different words
07:17:39 <lilac> ksf: of course, that leads to the question of, how do you know your line of reasoning is valid? we only think that first-order logic is valid because we've not found it to be inconsistent
07:17:57 <lilac> and that's really the same as the argument for quantum mechanics
07:18:01 <jeff_s_> Completeness Theorem
07:18:15 <ksf> it's valid if you get something useful done.
07:18:15 <jeff_s_> first order logic is stronger than you're saying
07:18:40 <lilac> jeff_s_: all that proves is that it's at least as consistent as some other system in which you're showing it to be consistent
07:19:00 <jmcarthur_work> that's all that math is
07:19:00 <ksf> consistency is nice, but not a total requirement... you can use a program for ages and make millions before it segfaults for the first time.
07:19:17 <Saizan> nah, physical laws have only passed enough iterations of QuickCheck, while mathematical "laws" (do we mean theorems?) have a proof
07:19:38 <jeff_s_> ksf - do you know about the Completeness Theorem?
07:19:43 <Saizan> the proof is only as good as the reviewers, though :)
07:19:43 <lilac> Saizan: the logic on which mathematical laws are based have only passed enough iterations of QuickCheck.
07:20:12 <ksf> jeff_s_, yes, though I don't claim to have any more than an intuitive understanding of the proof.
07:20:15 <jmcarthur_work> lilac, i don't understand that. logic is an invention, not a natural phenomenon
07:20:40 <Saizan> lilac: even if the logic is inconsistent the theorem is still valid
07:20:54 <lilac> jmcarthur_work: my point is this: we want our logic to be consistent. we can't prove it is, because that would require the pre-existence of a known consistent logic.
07:20:54 <jeff_s_> then you might want to read about it more before trying to convince people that first order logic is so weak
07:21:08 <jmcarthur_work> lilac, that's true, but i don't think it's useful
07:21:29 <yottis> my firends the philosophers seem to think that one can reach certainty, but i think they trust themselves a bit too much, or as usual, have redefined terms such as "reality" to better suit their needs
07:21:43 <jmcarthur_work> logic, at least in the way i think you are using the word, is the *definition* of consistency
07:21:48 <ksf> I'm not trying to tell people anything about fo logic...
07:22:10 <jeff_s_> sorry I meant to talk to lilac ><
07:22:33 <lilac> jeff_s_: when did i say first order logic was weak?
07:22:45 <ksf> psychologically speaking, there's a wide gap between certainty and truth.
07:22:52 <lilac> jeff_s_: i said we've not found it to be inconsistent.
07:23:17 <quicksilver> jeff_s_: don't be patronising.
07:23:25 <lilac> that's as strong a statement as you can make for any logic without assuming any other logic is consistent
07:23:25 <jeff_s_> I missed the beginning of this conversation but... "we only think that first-order logic is valid because we've not found it to be inconsistent"
07:23:40 <Absolute0> Can instances be overridden?
07:23:41 <quicksilver> jeff_s_: the "proof" of the consistency of first order logic is itself written in some logic.
07:23:54 <quicksilver> jeff_s_: that logic may not be consistent, so the proof may be invalid.
07:23:59 <lilac> jeff_s_: the contrapositive being, if we found first-order logic to be inconsistent, we would think it was invalid. what's wrong with that?
07:24:12 <jmcarthur_work> the proof is valid in that particular logic though. and that is all that matters
07:24:28 <jmcarthur_work> it seems that the conversation is steering toward some concept of "absolute validity"
07:24:42 <ksf> there's no truth. everything is permissible.
07:24:42 <jmcarthur_work> different logics will have different results
07:24:44 <lilac> jmcarthur_work: why is that all that matters? we're talking about the foundation here, not about those things built atop it.
07:25:00 <EvilTerran> ksf, all things are true?
07:25:07 <Absolute0> instance Show (Map.Map Position ChessPiece) where <-- Position and ChessPiece are both data definitions
07:25:11 <jmcarthur_work> lilac, there is no foundation. if you reject the logics we use commonly then just use your own
07:25:14 <EvilTerran> even false things?
07:25:21 <jmcarthur_work> in math you can make things up
07:25:26 <jmcarthur_work> that's just how it is
07:25:28 <quicksilver> Absolute0: in normal haskell, no.
07:25:38 <Absolute0> Illegal instance declaration for `Show (Map.Map Position ChessPiece)'
07:25:42 <quicksilver> Absolute0: if there is a polymorphic show instance for Map (and there is), then you cannot supply a more specific one.
07:25:58 <Absolute0> quicksilver: what would be the syntax?
07:26:05 <Absolute0> I tried different combinations..
07:26:07 <quicksilver> Absolute0: actually there are some other problems with that to do with the precise forms instances are allowed to take
07:26:08 <ksf> EvilTerran, not while I'm eating, no.
07:26:14 <EvilTerran> Absolute0, if you don't want the behaviour that Show provides, then you probably don't actually want a Show instance
07:26:18 <quicksilver> Absolute0: there is nothing really wrong with that syntax.
07:26:27 <jmcarthur_work> #haskell has to be the most philosophical programming channel i've ever been in
07:26:31 <quicksilver> Absolute0: but there are two things wrong with what you're tryign to do.
07:26:38 <EvilTerran> Absolute0, seeing as Show instances tend to follow some fairly specific semantics
07:26:52 <Peaker> Absolute0, you can have a newtype/data around a Map Position ChessPiece that has its own Show instance
07:27:04 <Absolute0> oh let me try that
07:27:07 <lilac> jmcarthur_work: i disagree. there is a common foundation (alhtough we can't prove we all use the same one), and it's important to recognise that it's empirical, rather than absolute
07:27:08 <quicksilver> Absolute0: (1) in strict haskell98, you can't give instance declarations for types constructed out of type constructors.
07:27:31 <quicksilver> Absolute0: (2) once you fixed that with -XFlexibleInstances, you still can't do what you want, because tehre is already a Show instance for Map
07:27:37 <quicksilver> Absolute0: (3) you REALLY DONT WANT TO DO THIS anyway.
07:27:39 <quicksilver> ;)
07:27:40 <lilac> jmcarthur_work: if tomorrow we found that first-order logic proves false, then we'd need to reject it and all logics which prove it consistent.
07:27:48 <jmcarthur_work> lilac, i don't think we disagree that it shouldn't be considered absolute
07:27:57 <jmcarthur_work> lilac, proves false *in some other logic* you mean
07:28:02 <Absolute0> Qualified name in binding position: Map.Map
07:28:05 <jmcarthur_work> which, again, suffers from the same problem
07:28:06 <lilac> jmcarthur_work: no, in itself.
07:28:13 <quicksilver> Show is for machine-readable, haskell syntax
07:28:13 <Absolute0> newtype GameSetup = Map.Map Position ChessPiece
07:28:15 <jeff_s_> lilac - why are you insisting on considering that 1st order logic could be found to be wrong somehow when it's impossible?
07:28:25 <Absolute0> quicksilver: alright i'll just implement a myShow function :)
07:28:25 <jmcarthur_work> you can't prove a logic "false" anyway
07:28:26 <quicksilver> never use it for pretty printing or 'smoethign which looks nicer'
07:28:27 <Absolute0> point taken.
07:28:47 <quicksilver> Absolute0: the newtype syntax is newtype GameSetup = GameSetup (Map.Map Position ChessPiece)
07:28:50 <quicksilver> you need a constructor.
07:28:54 <Peaker> jmcarthur_work, you can prove it inconsistent, though?
07:28:55 <Absolute0> oh
07:29:10 <fasta> Peaker: yes
07:29:12 <Absolute0> So show should never be overridden?
07:29:21 <quicksilver> you can write show for your own types
07:29:22 <Absolute0> since Read cannot process it.
07:29:32 <quicksilver> but you should always write something which Read can process
07:29:33 <EvilTerran> jmcarthur_work, jeff_s_: i think lilac is thinking of the problem that, due to incompleteness, we can't actually disprove "forall a. a" in FOL
07:29:37 <Absolute0> right.
07:29:39 <quicksilver> so you might as well use 'deriving' really
07:29:47 <lilac> jeff_s_: i think you misunderstand the Completeness Theorem. if logic A proves logic B consistent, then either B is consistent or A is not. there's no absolute notion of 'impossible' here
07:29:57 <jeff_s_> er, "forall" isn't a concept in 1st order logic
07:30:09 <jeff_s_> completeness doesn't hold for 2nd order logic
07:30:28 <jeff_s_> completeness DOES hold for 1st order logic
07:30:51 <jmcarthur_work> a logic will always be "wrong" if it is either inconsistent or incomplete? that doesn't sound useful to me either
07:31:06 <EvilTerran> um
07:31:21 <ksf> OMG WE NEED A HASKELL BROWSER
07:31:30 <EvilTerran> "FOL is a system of deduction that extends propositional logic by allowing quantification over individuals of a given domain of discourse."
07:32:00 <quicksilver> EvilTerran: however, "forall a . a" isn't FOL, since that's not quantifying over an individual, but over a proposition.
07:32:08 <EvilTerran> ah, i see
07:32:13 <quicksilver> still I think we should maybe take this to -overflow or -blah
07:32:25 <EvilTerran> i meant we can't prove FOL consistent, though
07:32:51 <lilac> -overflow seems more appropriate
07:33:34 <seliopou> sorry to jump in here... but I believe that first-order logic is both sound and complete
07:33:54 <quicksilver> seliopou: if you wish to jump in, please jump into #haskell-overflow :P
07:34:15 <jeff_s_> never mind, I was mistaken. forall is in first order logic, but it's still complete
07:34:50 <jeff_s_> oh and quicksilver is right too though - ok i'm done then :P
07:35:50 <rfmge> > let f n = (\a b c -> [a,b,c]) <$> [1..n] <*> [1..n] <*> [1..n] in f 2
07:35:51 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
07:36:02 <rfmge> is there a way to make that work for any number of lists instead of just 3?
07:36:54 <quicksilver> > replicateM 3 [1..2]
07:36:56 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
07:37:01 <quicksilver> > replicateM 4 [1..2]
07:37:03 <lambdabot>   [[1,1,1,1],[1,1,1,2],[1,1,2,1],[1,1,2,2],[1,2,1,1],[1,2,1,2],[1,2,2,1],[1,2...
07:37:17 <rfmge> awesome, thanks
07:42:25 <EvilTerran> rfmge, but do you see how it works?
07:43:46 <rfmge> i think so
07:44:38 <rfmge> the list monad is concatMap, so it's building a list of [[1][1][1][1]],[[1][1][1][2]]...
07:44:58 <dev31212> > print Nothing
07:45:00 <lambdabot>   <IO ()>
07:45:13 <dev31212> Hi folks...question about show
07:45:21 <dev31212> IN GHCi, "print Nothing" works fine.
07:45:41 <dev31212> but in my simple test program, main = print Nothing, I get the following  error:
07:46:02 <dev31212>  Ambiguous type variable `a' in the constraint:
07:46:02 <dev31212>       `Show a' arising from a use of `print' at functor.hs:50:1-5
07:46:02 <dev31212>     Probable fix: add a type signature that fixes these type variable(s)
07:46:17 <dev31212> Am I not importing something?
07:46:25 <Zao> As Nothing is of type Maybe a, it doesn't know what a is.
07:46:35 <nibro> ghci does some clever defaulting to pick an a for you
07:46:44 <Zao> What about if you do   print (Nothing :: Maybe ()) ?
07:47:01 <dev31212> ahh let me try
07:47:17 <ksf> sometimes, I have the impression that okular is the only kde program that was written by half-way capable people.
07:47:22 <nibro> I have a question for the ssh gurus out there
07:47:33 <ksf> as in "at least, it never crashed on me"
07:47:52 <dev31212> ok, indeed that works Zao
07:47:53 <dev31212> thanks
07:47:58 <dev31212> Why does GHCi allow it?
07:48:07 <nibro> I'm trying to set myself up on my new machine, and I want to ssh to code.haskell.org without typing my password all the time (which I've even forgotten)
07:48:23 <Zao> dev31212: Friendliness?
07:48:30 <nibro> I thought it would be enough to copy my .ssh from my old machine to my new one, but it doesn't seem to work
07:48:31 <Zao> It does a lot of defaulting.
07:48:33 <ksf> dev31212, ghc can't infer what type your Justs are, because you never use them.
07:48:37 <Zao> nibro: Permissions right?
07:48:50 <Zao> nibro: Throw more -vvv at ssh to see if you get more info.
07:49:19 <ksf> dev31212, -XNoMonomorphismRestriction should "fix" things, but adding a signature is better style.
07:49:26 <dev31212> ok gotcha
07:49:29 <dev31212> Thanks folks
07:49:36 <dev31212> so I guess as you said, "friendliness"
07:49:39 <lilac> ksf: will that help?
07:49:42 <dev31212> Well that friendlieness can be confusing for new jacks
07:49:52 <nibro> dev31212: ghci always tries () first, if it doesn't know what the type is
07:49:56 <ksf> lilac, nope.
07:50:16 <ksf> ... the Maybe type doesn't escape to the top-level binding.
07:52:08 <dev31212> ok
07:52:25 <nibro> I checked the permissions, they were probably wrong, but I've fixed them to the same as my other machine has and it still won't work
07:52:37 <nibro> ssh -v doesn't seem to mention anything about looking at the .ssh
07:53:52 <nibro> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5343#a5343
07:57:26 <dev31212> Anybody care to give a guy some inspiration?
07:57:35 <dev31212> Whats the Haskell job market like?
07:58:02 <skorpan> which haskell job market?
07:58:08 <skorpan> or rather "what"
07:58:26 <dev31212> Um, I dunno...general haskell programming?
07:58:34 <nibro> "emerging"
07:58:40 <dev31212> Entry level Haskell jobs?  I am looking to transition out of Java/PHP at one point
07:58:43 <Beelsebob> there are people with haskell jobs
07:58:44 <C-Keen> heh
07:58:48 <Beelsebob> they're not easy to get though
07:58:54 <dev31212> Beelsebob, that doesnt souind encouraging
07:59:02 <dev31212> ok
07:59:06 <jmcarthur_work> dev31212, Beelsebob just wants the haskell jobs to himself
07:59:08 <osfameron> "entry level haskell jobs" would be nice...
07:59:16 <Beelsebob> jmcarthur: I already *have* a haskell job
07:59:30 <osfameron> I think the best way to get a haskell job right now is to startup your own company developing haskell
07:59:31 <jmcarthur_work> Beelsebob, do you have any extras to pass around?
07:59:36 <jmcarthur_work> ;)
07:59:50 <dev31212> Well I realize it will probably be up to a year before I could consider myself competent enough for a haskell job anyway...and I am mainly doing this for my own personal projects
07:59:55 <osfameron> or to get a job doing nothaskell, and persuade your boss that your next project should be in haskell
07:59:59 <dev31212> but it wouyld be nice to be in a market with such little supply
08:00:12 <dev31212> PHP programmers are a dime a dozen..so I want to enhance my resume
08:00:30 <dev31212> osfameron, hmmm...not a bad idea.
08:01:09 <myname> hi, i need help: how to list files in a folder in haskell?
08:01:27 <quicksilver> lars9: look at the functions in System.Directory
08:01:44 <lars9> thanks, i'll check that.
08:02:11 <dev31212> Beelsebob, let me ask you, rudely, a question
08:02:26 * quicksilver recommends you ask it, politely.
08:02:29 <quicksilver> ;P
08:02:30 <dev31212> would you say you make more than the average person, with your years of experience, doing say, Java, or .net, php, etc?
08:02:36 <mux> lars9: the function is getDirectoryContents
08:02:41 <dev31212> A rude question asked politley :)
08:02:43 <lars9> quicksilver, are you replying me? i'm new to irc...
08:02:53 <jmcarthur_work> sounds like a /msg question ;)
08:02:58 <quicksilver> lars9: I was, yes, the first time.
08:02:59 <dev31212> ok, my bad
08:03:09 <quicksilver> lars9: when I said "look at the functions in System.Directory
08:03:47 <jmcarthur_work> but i am curious if the average haskell developer makes more than the average <insert X language> developer (i find it very likely)
08:03:58 <lars9> thanks, then i use that to count number of new mails in my maildir, for a plugin of xmobar...
08:04:02 <dev31212> Thats what I am thinking...
08:04:14 <dev31212> given the short supply of competent Haskell programmers..and functional programmers, in general
08:04:30 <jmcarthur_work> well, also pretty small demand, yet
08:04:37 <dev31212> yeah, good point.
08:05:01 <dev31212> I was told some Swiss Bank uses Haskell for all their systems...
08:05:10 <dev31212> And Twitter is written in Scala...
08:05:28 <lars9> swiss bank uses haskell? cool...
08:05:42 <dev31212> Yeah, I think centrenia told me that...
08:05:49 <nibro> a lot of banks use haskell these days
08:05:53 <dev31212> ahh nice
08:05:56 <nibro> well, several anyway...
08:06:02 <mux> facebook's chat is written in erlang
08:06:11 <nibro> they use it for financial system modelling
08:06:11 <jeff_s_> awesom
08:06:13 <dev31212> nice
08:06:28 <lars9> awesome +1
08:07:05 * QtPlaty[HireMe] can't recall which bank uses Ocamel "But if you do any search for functional langs you often get there adds"
08:07:16 <dev31212> I saw some blog article advocating using haskell to write Military munitions code
08:07:22 <dev31212> because of less chance of screwups :)
08:07:35 <nibro> see here: http://www.haskell.org/haskellwiki/Haskell_in_industry
08:07:36 <dev31212> I guess that;'s why bannks like it...less chanbce of dumb dubgs
08:07:36 <fasta> QtPlaty[HireMe]: Jane Street
08:07:49 <dev31212> bugs*
08:09:24 <SamB> QtPlaty[HireMe]: you also can't remember how to spell?
08:09:26 <nibro> Zao: turns out it was a permission thing after all, thanks for the tip :)
08:14:02 <dev31212> hi centrinia
08:14:04 <bos> nifty, my rewrite of pidgits gets Haskell to first place on that list again: http://shootout.alioth.debian.org/u64q/benchmark.php?test=pidigits&lang=all&box=1
08:14:14 <centrinia> Hi dev31212.
08:14:16 <wli> w00t
08:14:20 <nibro> way to go bos! :)
08:14:56 <bos> and it's the shortest of all the submissions by a fair margin, too. nice!
08:16:22 <JaffaCake> bos: very nice, but you're allowed to use whitespace in the shootout, right?
08:17:17 <ksf> bos, multi-threading?
08:17:37 <ksf> that is, seperate calculation from printing?
08:18:17 <bos> JaffaCake: i guess.
08:18:22 <bos> :-)
08:18:35 <bos> ksf: haven't had time to try it. i'd be somewhat astonished if it helped.
08:19:06 <jeff_s_> bos, what is the "j#s" and "j&(n,a,d) syntax in your pidgits function?
08:19:15 <fasta> jeff_s_: it's not syntax
08:19:19 <bos> jeff_s_: they're just functions.
08:19:26 <bos> # is one function, and & is another.
08:19:48 <JaffaCake> are they still using gzip as a way to measure code length?
08:19:58 <jeff_s_> hm, ok
08:20:02 <bos> JaffaCake: yep
08:20:11 <JaffaCake> this code looks like it's already been gzipped :)
08:20:50 <bos> JaffaCake: it was a lot more readable before i golfed the living bejaysus out of it :-)
08:21:04 <jeff_s_> huh, so in haskell you don't have to put ain infix operator in parens and use it prefix when defining it?
08:21:08 <bos> i could have tightened it up more, but that felt silly.
08:21:14 <bos> jeff_s_: right
08:21:18 <jeff_s_> neat
08:21:22 <JaffaCake> :) np, as long as we win
08:23:14 <bos> i could actually understand the code when i first wrote it. now, er, not so much.
08:23:20 <fasta> y=(j*2+1)
08:23:27 <fasta> Two parens?
08:23:41 <nibro> cpu usage 100% 0% 0% 0%?
08:23:51 <fasta> Or is that more efficient for gzip ;)
08:23:51 <nibro> no gains to be made at all from parallelizing?
08:24:08 <nibro> (disclaimer: I have no idea what the problem is even :))
08:24:12 <bos> fasta: an artifact of refactoring in a rush
08:24:24 <bos> nibro: almost certainly no gain from parallel evaluation
08:24:38 <fasta> It depends on how many cores you have.
08:24:48 <ksf> the pi generation isn't parallisable as i see it, but you could factor out printing.
08:25:05 <fasta> If you have a gazillion cores, you can probably do things which are completely insane to do right now.
08:25:24 <jmcarthur_work> fasta, well, also dependent on the bandwidth you have to those cores
08:25:28 <bos> fasta: not if every digit depends on the computation of the prior digit.
08:25:32 <jeff_s_> is anyone here subscribed to the libraries@haskell.org maillist? http://www.haskell.org/ghc/dist/current/docs/libraries/old-time/System-Time.html has a broken link
08:25:46 <fasta> bos: but that's not the case for pi
08:26:06 <ksf> fasta, the algorithm is given.
08:26:10 <jmcarthur_work> fasta, the benchmark stipulates a particular algorithm, which i'm not sure is parallelisable
08:26:38 <fasta> So, if you have to use a particular algorithm, how can you use more than one cpu?
08:26:42 <fasta> That would change the algorithm.
08:27:06 <bos> sometimes the algorithm can be parallelised.
08:27:12 <jeff_s_> if Haskell has a pmap you could probably sneak it in :)
08:28:34 <McManiaC> @src error
08:28:34 <lambdabot> error s = throw (ErrorCall s)
08:31:16 <jmcarthur_work> :t parMap
08:31:17 <lambdabot> forall b a. Strategy b -> (a -> b) -> [a] -> [b]
08:31:26 <jmcarthur_work> :t par
08:31:27 <lambdabot> forall a b. a -> b -> b
08:32:32 <lilac> bos: looks like the algorithm boils down to a long product of 2x2 matrices? that sounds embarassingly parallelizable
08:32:49 <lilac> unless you're required to multiply in a certain order?
08:32:50 <ksf> bos, http://hackage.haskell.org/packages/archive/strict-concurrency/0.2.1/doc/html/Control-Concurrent-Chan-Strict.html
08:33:00 <ksf> I'd do it, but I have a single core.
08:33:47 <bos> lilac: i don't believe so
08:34:07 <lilac> which part?
08:36:19 <ksf> what about the library rule? would using something out of the platform be allowed?
08:37:30 <Berengal> If we're going to have multiple error-reporting modes in ghc, I want to suggest "foo :: Int -> Bool \n bar :: Double \n foo bar :: WTF o_O?
08:37:48 <Berengal> <location>"
08:37:56 <nominolo> Hm, I have a suspicion that Parsec 3's Stream interface is not as useful as it could be :/
08:38:13 <ksf> nominolo, huh?
08:38:31 <ksf> it's basically another interface to matching on : and []]
08:39:29 <nominolo> ksf: well, I'm trying to build a stream out of bytes I read from a socket or stdin and I get weird parse errors which shouldn't happen
08:40:00 <nominolo> the thing is that we have no guarantee that the returned state is used linearly
08:49:29 <lars9> hi, i need help one a small piece of code, who can help me?
08:49:56 <ksf> nominolo, well, parsec isn't designed to work on monadic streams... it sounds to me that you want to use something in the direction of iteratees.
08:50:17 <nominolo> ksf: right, but I want to also parse things
08:50:34 <nominolo> and I'd like to avoid rolling (yet again) my own parser
08:50:56 <lars9> i have the function countFiles to count the number of files in a directory. and the function has type of "String -> IO String"
08:51:40 <lars9> how to write "countFiles d = do ..."? using functions "getDirectoryContents" and "length"
08:52:00 <Lemmih> lars9: Why does it return a String?
08:52:49 <ksf> :t fmap length getDirectoryContents
08:52:50 <lambdabot> Not in scope: `getDirectoryContents'
08:53:08 <lars9> import System.Directory
08:53:16 <ksf> :t fmap length System.Directory.getDirectoryContents
08:53:17 <lambdabot>     Couldn't match expected type `[a]'
08:53:17 <lambdabot>            against inferred type `IO [FilePath]'
08:53:17 <lambdabot>       Expected type: FilePath -> [a]
08:53:31 <doserj> countFiles d = length <$> getDirectoryContents d
08:54:15 <ksf> :t \x -> fmap length System.Directory.getDirectoryContents x
08:54:16 <lambdabot>     Couldn't match expected type `[a]'
08:54:17 <lambdabot>            against inferred type `IO [FilePath]'
08:54:17 <lambdabot>       Expected type: FilePath -> [a]
08:54:27 <ksf> :t \x -> fmap length (System.Directory.getDirectoryContents x)
08:54:29 <lambdabot> FilePath -> IO Int
08:54:43 <ksf> now that's an utterly cryptic error message, there.
08:55:08 <dancor_> it's better when it gives you the part with the mismatch
08:55:14 <dancor_> it's cut-off here
08:55:40 <doserj> ksf: why? fmap length reguires a list as argument, getDirectoryContents isn't a list
08:55:43 <ksf> otoh, it's the same, old, pontless fail.
08:55:53 <Lemmih> lars9: Use two functions: one for counting the files and one for displaying the output.
08:56:23 <ksf> :t (fmap length .) System.Directory.getDirectoryContents
08:56:25 <lambdabot> FilePath -> IO Int
08:56:43 <dancor_> :t length <$> System.Directory.getDirectoryContents
08:56:44 <lambdabot>     Couldn't match expected type `[a]'
08:56:44 <lambdabot>            against inferred type `IO [FilePath]'
08:56:44 <lambdabot>       Expected type: FilePath -> [a]
08:56:50 <lars9> why mine does not work? countFiles d = do ; l <- getDirectoryContents; n <- length l; return $ show n;
08:57:00 <Lemmih> lars9: Do you want to include the files in subdirectories?
08:57:10 <doserj> let n = length l instead of n <- length l
08:57:13 <ksf> lars9, length isn't monadic, so don't use <-
08:57:40 <lars9> oh, what does let means?
08:58:04 <ksf> it introduces a binding.
08:58:09 <doserj> a local binding
08:58:14 <ksf> you can also say return $ show $ length n
08:58:16 <lars9> it works after using "let" instead of "<-"
08:58:53 <ksf> ...which is more important to understand.
08:59:05 <doserj> But really, I would also expect a function named countFiles to return IO Int
08:59:12 <b_jonas> ksf: where by n you mean l ?
08:59:23 <ksf> b_jonas, yes.
08:59:56 <ksf> I've got a compiler and an irc channel to detect such bugs for me.
09:00:07 <b_jonas> :-)
09:00:17 <lars9> is ( return . show . length ) converting list to Monad String?
09:00:37 <ksf> :t return . show . length
09:00:37 <Berengal> lars9: Think of <- as extracting a value from a monad. All monads constist of two things: a box and a value inside it. getDirectoryContents, with type IO [String], has an IO box and a value of type [String]. length l is simply Int, which doesn't have a box, so there's nothing to extract from
09:00:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m String
09:00:48 <ksf> short answer: yes.
09:01:02 <ksf> :t return
09:01:04 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:01:14 <hackagebot> complexity 0.1.3
09:02:09 <lilac> lars9: you also want l <- getDirectoryContents d, not l <- getDirectoryContents.
09:03:32 <lars9> it works now.. great, thanks. now i can use it to display number of new mails in xmobar
09:03:58 <lars9> countFiles "/home/lars/.mail/inbox/new"
09:04:15 <hackagebot> explicit-sharing 0.3.1.3
09:05:18 <ksf> ls ~/.mail/inbox/new | wc -l
09:05:41 <doserj> lars9: you might want to subtract 2 from the result, though
09:06:56 <Berengal> Since when did we get hackagebot, and who set it up?
09:08:30 <QtPlaty[HireMe]> SamB: http://quollified.com/~platypus/Spelling.html
09:18:41 <aleator> Stupid non-related question: What use are minimum spanning trees? (#haskell people usually know such things.)
09:20:46 <Berengal> aleator: Find the cheapest way to connect all the nodes in a graph
09:21:34 <aleator> Berengal: Thanks, sure but I need a motivation to give for about 1st year student on why to learn such
09:21:51 <joga> aleator, maybe this helps http://lmgtfy.com/?q=minimum+spanning+tree ;)
09:22:40 <aleator> har-har..
09:23:02 <joga> you might for example have a problem where you need to visit certain places and consume as little gas as possible
09:23:04 <Berengal> aleator: http://www.facebook.com/careers/puzzles.php?puzzle_id=1
09:23:33 <Berengal> joga: That'd be travelling salesman
09:23:43 <joga> well, yeah
09:24:01 <joga> my mistake
09:24:19 <Berengal> Unless you travelled in an infinitely large group of people who could split up at junctions
09:24:28 <joga> the cable tv company example in the wikipedia article is better
09:25:00 <aleator> Berengal: Hey, thats actually excellent. I can rephrase it into making chemicals so that idiot lecturers can lecture for 6h a day. :)
09:27:43 <gigi> ciao
09:27:46 <TomMD> ?quote fusion
09:27:46 <lambdabot> ksf says: Confusion is the first step to enlightenment
09:27:51 <gigi> !list
09:27:56 <TomMD> ?quote fusion
09:27:57 <lambdabot> ksf says: Confusion is the first step to enlightenment
09:28:03 <TomMD> damn, no more
09:28:21 <ray> @quote haskell
09:28:21 <lambdabot> roconnor says: I can't wait for the Density Comonad chapter of "learn you a haskell"
09:28:34 <Berengal> @quote fusion
09:28:35 <lambdabot> Ralith says: I'm sure we'll have fusion within 40 years.
09:28:51 <ray> thanks irc lag and silly irc client for making the quote appear before my @quote
09:34:44 <ksf> lambdabot's random gen seems to be utterly biased.
09:34:52 <ksf> ...at least wrt. quotes.
09:35:24 <Berengal> ksf: It also decides to fetch quotes from empty lists from time to time
09:37:41 <lilac> @quote fix
09:37:41 <lambdabot> mauke says: a hint to beginners: typing 'fix error' in ghci does not have the intended  effect
09:37:52 <lilac> > fix fail
09:37:53 <lambdabot>   ""
09:38:07 <skorpan> > fix undefined
09:38:16 <lambdabot>   * Exception: Prelude.undefined
09:38:29 <skorpan> > [undefined, undefined..undefined]
09:38:31 <lambdabot>   * Exception: Prelude.undefined
09:38:36 <skorpan> > [1..undefined]
09:38:37 <lambdabot>   * Exception: Prelude.undefined
09:38:43 <skorpan> > take 3 [1..undefined]
09:38:45 <lambdabot>   * Exception: Prelude.undefined
09:38:48 <lilac> > [1,2..undefined]
09:38:49 <lambdabot>   * Exception: Prelude.undefined
09:39:02 <Berengal> @src emumFromTo
09:39:02 <lambdabot> Source not found. Where did you learn to type?
09:39:11 <skorpan> @src enumFromTo
09:39:11 <Berengal> @src enumFromTo
09:39:11 <lambdabot> Source not found. My mind is going. I can feel it.
09:39:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:39:44 <mxc> oh the joys of laziness..  with full logging, everything works, with partial logging, nothing..
09:39:51 * Berengal guesses something with "foo <= maxLimit"
09:40:07 <lilac> > [1,2..-7]
09:40:08 <lambdabot>   Not in scope: `..-'
09:40:11 <lilac> > [1,2.. -7]
09:40:12 <lambdabot>   []
09:40:15 <lilac> > [1,2.. 7]
09:40:16 <lambdabot>   [1,2,3,4,5,6,7]
09:40:16 <Gracenotes> > head [1,2..undefined]
09:40:18 <lambdabot>   * Exception: Prelude.undefined
09:40:23 <lilac> first ctor could be either [] or (:)
09:40:26 <Gracenotes> hm. So it's not so lazy..?
09:40:37 <lilac> Gracenotes: if undefined < 1, then the list is empty
09:40:38 <Gracenotes> It guess it has to check if 1 <= undefined
09:40:43 <Berengal> Gracenotes: How would you implement it?
09:40:49 <Gracenotes> indeedy so, lilac
09:41:03 <doserj> > [1..infinity]
09:41:07 <cfrssv> hi
09:41:08 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:41:27 <burp> > [1..]
09:41:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:41:30 <Gracenotes> doserj: that's so un-Natural!
09:41:38 <NEEDMOAR> @src infinity
09:41:38 <lambdabot> Source not found. Take a stress pill and think things over.
09:41:45 <lilac> > [infinity, infinity-1 .. 0]
09:41:47 <lambdabot>   []
09:41:58 <lilac> huh?
09:42:01 <centrinia> :t infinity
09:42:02 <lambdabot> Natural
09:42:15 <lilac> > [3,2..0] :: [Natural]
09:42:16 <lambdabot>   []
09:42:19 <lilac> bums
09:42:21 <centrinia> > infinity < infinity+1
09:42:27 <lambdabot>   mueval-core: Prelude.read: no parse
09:42:27 <lambdabot>  mueval: ExitFailure 1
09:42:28 <lilac> > [3,2..0]
09:42:30 <lambdabot>   [3,2,1,0]
09:43:14 <centrinia> > infinity < succ infinity
09:43:20 <lambdabot>   mueval-core: Prelude.read: no parse
09:43:20 <lambdabot>  mueval: ExitFailure 1
09:43:22 <cfrssv> please, help! i'm linking with self-made opencv ffi (-L./out/ -lcvffi), but, on runtime, program tryes to load it from /usr/lib. Can I use other path?
09:44:03 <yowgi> cfrssv, LD_LIBRARY_PATH=./out/  ./program
09:44:04 <thoughtpolice> cfrssv: put the .so for your self-made version in the same directory?
09:44:33 <burp> <centrinia> > infinity < infinity+1 <- haha nice idea
09:44:34 <cfrssv> thoughtpolice, wont work :(
09:44:57 <cfrssv> works only with lib in /usr/lib
09:45:30 <cfrssv> yowgi, thanx!
09:49:55 <McManiaC> http://sprunge.us/NdRZ?hs <- any idea why this isnt working as intended? i still get:
09:49:58 <McManiaC>   Parallel GC work balance: nan (0 / 0, ideal 2)
09:51:30 <McManiaC> what else do i have to do to use multithreading? i already set +RTS -N2
09:56:11 <ksf> centrinia, infinity = succ infinity , so you're going for a _|_.
09:56:38 <ksf> ...algebraic smartness is absent, as always.
09:58:29 <ksf> zsh: segmentation fault  ./TestEmbedMoz
09:58:35 <ksf> grargh
10:02:16 <SamB> QtPlaty[HireMe]: you know, I think emacs has word completion
10:02:29 <SamB> though I guess you have to know what you're going to misspell to use that
10:02:44 <conal> i'm moving the checkers package from quickcheck 1 to quickcheck 2.  does anyone know why the 'rand' generator disappeared?
10:02:44 <lambdabot> conal: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:02:53 <conal> is there a recommended replacement?
10:03:06 <SamB> QtPlaty[HireMe]: I mean, with ispell
10:03:26 <SamB> I wish Python had use strict ;-P
10:07:01 <Botje> @quote bondage
10:07:01 <lambdabot> No quotes match. Maybe you made a typo?
10:08:39 <McManiaC> is there *no* way to do "pure exception handling"?
10:09:17 <McManiaC> try / tryJust / catch etc always returns IO monad =(
10:09:31 <McManiaC> from Control.Exception
10:09:46 <Lemmih> McManiaC: There is no way.
10:10:01 <Lemmih> McManiaC: You can always use data types, though.
10:10:37 <McManiaC> :S
10:12:24 <doserj> pure exception handling is called the Either Monad
10:14:51 <McManiaC> i wish every function would return maybe/either ;)
10:16:14 <pumpkin_>  bos31337: congratulations on first place!
10:18:08 <zsol> can someone explain me what's this \mu notation here: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentation_of_Fixed_Point
10:19:07 <zsol> I'm tempted to read it as a lambda expression but something tells me it's not accidentally a mu instead of a lambda
10:20:24 <Baughn> (Emacs users:) What fontset/font settings are you using to show symbols in haskell-mode (assuming you've got those on)?
10:20:39 <zsol> I'm using terminus
10:21:35 <Baughn> zsol: And that's got the <- and . glyphs?
10:22:33 <zsol> yeah it displays neatly
10:23:01 <zsol> it's also got lambda, ->, and a few others
10:25:04 <Baughn> zsol: I've got that installed, but it seems not to be an option. How do you set it?
10:25:54 <zsol> I've just set the default font face to terminus
10:26:44 <Baughn> M-x set-default-font terminus.. gives "Font 'terminus' is not defined"
10:26:48 <Baughn> Ah, I'll ask #emacs
10:29:47 <conal> yow!  i get an error when building QuickCheck 2 from hackage: Class `Exception' used as a type.  works fine via 'cabal install', but not with explicit Setup.lhs from source.
10:30:34 <dcoutts> conal: cabal install is picking base 3 because it's pessimistic.
10:30:36 <conal> Baughn: i use 12x24 from the Misc menu (shift-left).
10:30:55 <Baughn> conal: Yow. Way too big, but maybe one of the others..
10:30:57 <dcoutts> conal: where as runghc Setup uses the simple stupid algorithm of picking the latest version of everything
10:31:13 <conal> Baughn: yeah.  pretty fat.  please let me know what you end up liking.
10:31:39 <dcoutts> conal: so it sounds like that package needs base < 4
10:31:51 <dcoutts> but did not declare it
10:32:09 <conal> dcoutts: maybe so.  thanks.  hm.  will there be trouble if other packages need base 4?
10:32:30 <BONUS> when it complains that Exception is used as type it's usually cause of the new style exceptions yeah?
10:32:46 <dcoutts> conal: no problem, different packages in a single stack can use base 3 or 4
10:32:51 <Baughn> Yep. It was a type in base-3, but it's a class now
10:33:19 <Baughn> conal: I'm still hammering on makeEvent, by the way. I see what you mean about the finalizers. ^^;
10:33:22 <dcoutts> conal: so cabal is papering over compatibility issue, if we hadn't done this then nearly every package on hackage would have broken when ghc-6.10 came out
10:33:35 <conal> i see in QuickCheck.cabal there's a splitBase flag: http://hackage.haskell.org/packages/archive/QuickCheck/2.1/QuickCheck.cabal  relevant?
10:33:57 <dcoutts> conal: no, that's about base 2 vs 3. This is about 3 vs 4.
10:34:18 <dcoutts> conal: packages should specify an upper bound on base, but not many do yet.
10:34:36 <conal> dcoutts: thanks.  "base == 3" sound right?
10:34:40 <hackagebot> numbers 2009.5.28.1
10:34:52 <dcoutts> conal: that's too strict, that would not work with 3.0.3.0 for example
10:35:06 <conal> dcoutts: base >= 3 && base < 4 ?
10:35:15 <dcoutts> conal: yep
10:35:18 <conal> thx!
10:35:36 <Baughn> conal: My favorite font is actulaly the default one; it's easy to read. It just lacks some glyphs.
10:35:36 <dcoutts> conal: actually it's "build-depends: base >= 3 && < 4"
10:35:50 <Baughn> conal: Now to find out which that is..
10:35:53 <dcoutts> conal: no repetition of the package name is needed
10:36:04 <TomMD> dcoutts: I thought you could say something lik "base == 4.*"
10:36:07 <conal> dcoutts: worked much better!  :)
10:36:14 <dcoutts> TomMD: yes, you can
10:36:18 <TomMD> great!
10:36:37 <dcoutts> TomMD: if you're prepared to require cabal-version: >= 1.6
10:36:55 <TomMD> Sure, I don't mind forcing people to be up to date
10:37:12 <conal> hm!  now i get an error on a haddock comment: parse error on input `-- * \"Magic\" functions'
10:38:43 <conal> never mind.  seems to be fixed in the very latest QC
10:39:40 <conal> well.  phew!  checkers now builds with QC2.  all but a bit i commented out.
10:42:03 * jmcarthur_work uses inconsolata in emacs, at the moment. not sure how it does with special symbols and stuff, but it _should_ be okay
10:48:01 <conal> i just wrote to koen to tell him about the QC2 compilation problem with base 4
10:48:17 <conal> Baughn: oh -- just noticed your finalizers comment.  yeah.  tricky stuff!
10:49:01 <conal> Baughn: i've seen misc hints about ghc libraries having awkward interface tweaks to work around finalization.
10:49:59 <conal> Baughn: which tell me that weak refs & finalizers don't form a robust abstraction.
10:51:58 <ksf> I was quite surprised as I read that finalizers aren't guaranteed to run.
10:52:54 <TomMD> ksf: I thought that was fixed with the 6.10 branch - where did you read this?
10:53:00 <lilac> ksf: presumably that's to do with cycles which are kept alive by the thunks for the finalizers themselves?
10:53:05 <ksf> somewhere in the docs, some time ago.
10:53:24 <lilac> if a's finalizer references b and b's finalizer references a, then you're hosed
10:53:26 <ksf> we have a refcounting gc?
10:54:03 <lilac> whichever finalizer runs second is going to see an already-finalized object
10:54:37 <lilac> either that or at least one of them does not run
10:54:46 <ksf> hmm
10:54:51 <conal> ksf: yeah.  finalizers (and gc in general) are terribly important but not dependable.
10:55:20 <conal> fortunately, now *C*-based finalizers are run promptly.
10:55:38 <conal> we pushed on that change at anygma last summer, in order to to do robust graphics programming.
10:57:33 <conal> i don't know how to do robust & modular programming without GC, but not GC is reliably only on system RAM, and not on other memory and other resources.
11:05:30 <burp> > [0.5,1.0,..5]
11:05:31 <Taejo> if I wanted to use GMP functions that aren't currently exposed to Haskell by GHC, would I have to mess about with the runtime? Or could I just do an ordinary FFI?
11:05:31 <lambdabot>   <no location info>: parse error on input `..'
11:05:37 <burp> > [0.5,1.0..5]
11:05:39 <lambdabot>   [0.5,1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]
11:06:09 <Zao> Taejo: You'd probably have some trouble getting an Integer or suchlike to a format usable by GMP FFI.
11:06:40 <Zao> There were some documentation recently on implementing additional primops, but it might be out of scope.
11:07:54 * ksf_ switches to links until he wrote his own browser
11:07:59 <mm_freak> is there a variant of Chan with a message limit, such that when that limit is exceeded, further writers have to wait?
11:08:05 <lilac> how does GHC react if an object's finalizer holds a reference to that object?
11:08:16 <jzhou> is setting path var enough for a self-compiled ghc installation? do i need to set ld_library_path as well?
11:08:24 <lilac> (and further, what happens if that finalizer extends the lifetime of the object?)
11:11:37 <conal> lilac: there's a paper "stretching the storage manager" http://citeseer.ist.psu.edu/peytonjones99stretching.html
11:12:27 <conal> lilac: historical trivia: the impetus (at the time) to add these gc features to ghc was data-driven frp.
11:13:01 <zsol> anyone willing to help me derive this type: data Tree a = Node a [Tree a]
11:13:11 <SamB> lilac: isn't there something to prevent that from happening ?
11:14:01 <ksf_> #error "GCC no longer implements <varargs.h>."
11:14:04 <ksf_> bastards!
11:14:40 <lilac> conal: excellent, thanks!
11:14:45 <SamB> ksf: it is marked as legacy
11:14:53 <SamB> http://opengroup.org/onlinepubs/007908799/xsh/varargs.h.html
11:14:55 <conal> :)
11:15:09 <lilac> SamB: it looks like the formulation of weak references is designed to sidestep it
11:15:24 <mux> ksf_: you're supposed to use stdarg.h since looooong
11:15:24 <SamB> lilac: yeah
11:15:40 <SamB> yeah, since at least 12 years ago
11:15:42 <jzhou> SamB: is there any replacement of that?
11:16:14 <SamB> jzhou: it says right there to use stdarg.h instead
11:17:22 <jzhou> SamB: oh, thanks a lot, i used varargs.h a lot in my old cs homeworks
11:17:46 <mux> were you also using malloc.h? ;-)
11:17:50 <zsol> not really sure if this functor is what I'm looking for: TreeF_A X = A * (List X) = A * (Mu ListF_X)
11:18:56 <mauke> SamB: hah, it's more than 20 years old
11:19:15 <sbahra> hah
11:19:17 <sbahra> hah hah hah
11:19:39 <jzhou> mux: lol, according to http://www.opengroup.org/onlinepubs/9699919799/functions/free.html ,     There is now no requirement for the implementation to support the inclusion of <malloc.h>.
11:19:49 <mux> hopefully!
11:20:08 <sbahra> Did you sort out your sysctl issues mux?
11:20:42 <mux> sbahra: the issue with doc generation? dcoutts helped me write a specific hook to work my way around the problem, only, it doesn't work on hackage :-P
11:20:57 <mux> so the generated documentation of my package on hackage is still incomplete and I don't know why
11:20:59 <sbahra> No, testing on OpenBSD.
11:21:11 <mux> couldn't do this either, but it should work
11:21:16 <mux> could you give it a try ?
11:21:47 <sbahra> mux, I'm on FreeBSD.
11:21:56 <sbahra> mux, but I could ask a friend once he's around.
11:22:46 <mux> tbh, I'm more interested in knowing whether it works fine on NetBSD & Mac OS X
11:23:15 * sbahra wonders what the status is for Mac OS X/PPC
11:23:19 <sbahra> I could test there.
11:23:44 <mux> would be great
11:24:14 <sbahra> mux, you know what would be great?
11:24:22 <sbahra> mux, in fact, I think it would be fantastic.
11:24:41 <mux> what would?
11:24:54 <ksf_> mux, I was trying to compile fudgets...
11:25:12 <sbahra> mux, if you took lead of the FreeBSD Haskell project until I am able to work on it again.
11:25:34 <sbahra> Your girlfriend will love you more for it, I'm telling you.
11:25:41 <Twey> Haha
11:25:42 <ksf_> It's not widely known, but there's a web browser implemented in haskell, but it needs fudgets.
11:25:43 <wahjava> yeah :)
11:25:49 <mux> ksf_: I don't know what that is but this is too bad; if you can do C however, it should be easy to fix
11:26:03 <mux> sbahra: no way, sorry
11:26:17 <mux> I would have to get my commit bit back etc etc, I don't even want to think about going down that road for now
11:26:22 <sbahra> No, you wouldn't.
11:26:26 <sbahra> It is a separate project, mux.
11:26:33 <sbahra> We have our own hardware resources.
11:26:37 <ksf_> well, I don't want to spend my time fixing software that, while really cool, is obsolete.
11:26:40 <sbahra> Some committers work with us, and they will deal with the dirty work.
11:26:40 <mux> alright, let me find some other reason why I should not then.
11:26:51 <sbahra> mux, ok, let me know about them.
11:26:59 <mux> time? :-)
11:27:17 <sbahra> mux, that is a problem. But any time is better than no time.
11:29:05 <sbahra> mux, it isn't much work...in all honesty. If you wish, you could just pick up a small project from it.
11:29:44 <sbahra> The GHC port is trivial, I just haven't had time to properly audit it. Several Haskell ports are out of date (also easy to update a lot of them).
11:29:58 <mux> seriously, I would if I had more time
11:30:33 <sbahra> Ok.
11:30:46 <mux> did you guys write a bsd.cabal.mk thingie to automate at least part of the port's writing?
11:31:02 <TomMD> Did I hear talk of a bare metal ARM port?
11:31:14 <sbahra> mux, I am only working on GHC, my ports and server ...wahjava and jacula were working on that.
11:31:36 <sbahra> mux, a cabal2port is very feasible (and it doesn't need a bsd.cabal.mk, but that would be nice for hand-writing).
11:31:46 <wahjava> mux, there is a bsd.haskell.mk available
11:31:46 <sbahra> wahjava, is there anything in that area?
11:31:49 <mux> yes, that too.
11:32:06 <wahjava> no nothing in that area, atm.
11:32:10 <mux> I'd still make cabal2port use a bsd.cabal.mk framework
11:32:26 <sbahra> wahjava, jacula is busy with school, you too. dezzy?
11:32:34 <sbahra> mux, sure, but it isn't necessary.
11:33:03 <sbahra> mux, for example, bsd.haskell.mk would require more bureaucracy, so efforts can easily be over-lapped.
11:33:12 * mux tempted to answer the exact same last sentence :-)
11:47:38 <gigi_> ciao
11:48:09 <sayyestolife> I'd like to "pimp" my laptop a bit. Anyone knows if there is some nice haskell stickers (or similar) for sale anywhere?
11:48:31 <TomMD> @tell dcoutts Diving into finals week here (so I don't have time to do any hacking now) but I did just send you some old patches.  Feel free to let me know if they need fixing and perhaps I'll get to that on break.
11:48:32 <lambdabot> Consider it noted.
11:49:25 <Lemmih> sayyestolife: The closest thing I have is a Tupil sticker.
11:49:54 <TomMD> Thats your business card?
11:50:31 <lilac> @tell Cale Another week, another fix to the numbers package for lambdabot...
11:50:31 <lambdabot> Consider it noted.
11:50:32 <Lemmih> TomMD: Not mine, I'm afraid.
11:50:53 <Cale> okay :)
11:50:54 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:51:20 <dcoutts> TomMD: ok, ta
11:51:20 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
11:51:21 <lilac> thankyou, lambdabot :)
11:53:06 <ksf_> how come a package installs fine when installed directly, but not if it's installed as a dependency?
11:53:17 <ksf_> ...and why does cabal want to reinstall it, even though it's installed?
11:53:42 <dcoutts> ksf_: using cabal-install-0.6.2  or 0.6.0?
11:53:46 <ksf_> checkers-0.1.4 and reactive-0.10.7
11:54:00 <ksf_> 0.6.0
11:54:06 <Baughn> @pl \val -> readIORef sinkV >>= \c -> c val
11:54:06 <lambdabot> (readIORef sinkV >>=) . flip id
11:54:25 <dcoutts> ksf_: ok, upgrade and try again, I made an improvement in that area between 0.6.0 and 0.6.2
11:54:41 <dcoutts> ksf_: there are still circumstances where it must reinstall
11:55:21 <ksf_> hmmm. emerge is way slower computing dependencies than cabal.
11:55:33 <dcoutts> ksf_: heh, that's python for you
11:55:41 <dcoutts> ksf_: just cabal install cabal-install
11:56:18 <ksf_> nah, it's one of the haskell packages I install system-wide, so I don't feel pain nuking my .cabal and .ghc
11:59:35 <ksf_> dcoutts, still doesn't work
12:00:38 <ksf_> ...somehow, I doubt that quickcheck should be in the dependency list, anyway.
12:01:18 <ksf_> or I could just begin to shout at conal.
12:01:19 * Baughn cries for joy
12:02:35 <ksf_> :t filp id
12:02:37 <lambdabot> Not in scope: `filp'
12:02:39 <ksf_> :t flip id
12:02:41 <lambdabot> forall b c. b -> (b -> c) -> c
12:02:51 <Baughn> @tell conal http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5355#a5355 <-- I've got it working. Perfectly. And simpler than ever.
12:02:52 <lambdabot> Consider it noted.
12:02:57 <dcoutts> ksf_: ok, then it's because it cannot use the installed one because it's deps would conflict
12:03:13 <dcoutts> ksf_: if you do --dry-run with -v it'll say a bit more about why it's picking versions
12:03:20 <lament> what should i use to catch exceptions from Prelude.read?
12:03:26 * Baughn found a use for "modifyMVar_ foo return"
12:03:38 <dcoutts> lament: you'd use reads instead
12:04:11 <inimino> filp (a, b, c, d) = (a, c, b, d)
12:04:13 <p_l> Baughn: Did you catch my message about Tor wrt middleware?
12:04:24 <Baughn> p_l: Yes
12:04:25 <dcoutts> lament: reads :: Read a => String -> [(a,String)]
12:04:45 <lament> thanks
12:04:54 <lament> and Prelude.(!!) ?
12:05:13 <p_l> Baughn: I guess Tor addressing scheme would work nicely for skynet
12:05:34 <ksf_> well, the problem is that cabal wants to upgrade checkers from quickcheck 1 to 2, which fails.
12:06:09 <dcoutts> ksf_: so checkers mis-specifies the version of QC it needs and presumably because something else needs QC 2
12:06:30 <Baughn> p_l: I wasn't planning to go that far, but it's possible
12:06:47 <ksf_> ...checkers 0.1.4, in contrast to 0.1.3, doesn't specify a range for quickcheck, anymore, but uses QuickCheck.Utils...
12:06:53 <p_l> Baughn: Mix in direct connections and you have your NAT traversingsocket layer
12:06:54 <ksf_> COOOOONAAAAALLLLLL!
12:07:22 <dcoutts> ksf_: you could do worse than sending a patch :-)
12:07:44 <olsner> all monads should be monad transformers! if need be, they can add some convenience functions for FooT Identity (e.g. runFoo = runIdentity . runFooT), and for your generic functions, use type Foo a = (forall m . Monad m => FooT m a)
12:07:57 <dcoutts> lament: you can use drop and then check if the result is empty or not
12:08:02 <aavogt> IOT
12:08:30 <olsner> (just an rfc, do let me know if I'm wrong)
12:09:03 <dcoutts> olsner: sometimes performance dictates not using transformers
12:09:32 <olsner> shouldn't the newtypes always go away for the Identity case?
12:10:25 <olsner> but yeah, transformers probably do give the optimizer more work that it might not always be able to do
12:11:34 <centrinia> What is an IOT?
12:11:54 <Baughn> The IO Transformer
12:12:05 <Baughn> It's rumored to live in the dark jungles of System.IO.Unsafe
12:12:53 <jmcarthur_work> IO transformer?!
12:13:09 <jmcarthur_work> supremely evil
12:13:56 <mux> dcoutts: do you think it would be a bad idea to upload a package to hackage with more debug output just to understand what's going on?
12:14:07 <Botje> me shoots olsner in the FooT
12:14:10 <dcoutts> mux: yes, that's cheating ;-)
12:14:17 <mux> heh
12:14:30 <Baughn> mux: Better would be a version with optional debugging, via a .cabal flag
12:15:03 <olsner> Botje: :D
12:15:16 <dcoutts> mux: I'd rather just put it off 'til we get the code from Ross
12:15:37 <dcoutts> mux: if it's that vital, just upload your own docs somewhere and link to them.
12:15:49 <mux> it ain't vital
12:16:06 <olsner> Botje: ShooT (FooT IO) ()
12:16:17 <deech_> Hi all, really simple question, is there a function that removes whitespace around a string?
12:16:22 <ksf_> checkers uses generate and configSize out of QC1, what are their QC2 equivalents?
12:16:29 <jmcarthur_work> Botje, i can't find this evil IOT in System.IO.Unsafe
12:16:36 <mux> dcoutts: I'll wait then, but I guess prodding will be in order in the next few days :)
12:16:37 <Botje> jmcarthur_work: don't look at me :)
12:16:47 <olsner> jmcarthur: it is only rumored :)
12:16:56 <Botje> olsner: heh heh
12:17:11 <ksf_> ...in general, all that Util stuff is missing, which is a pita.
12:17:17 <olsner> @quote shoot
12:17:18 <lambdabot> foot says: You shoot yourself in the foot very elegantly, and wonder why the whole world isn't shooting itself this way.
12:17:37 <jmcarthur_work> FooT says it!
12:17:40 <mux> dcoutts: the only explanation I can think of right would be that his scripts are using "cabal haddock" instead of "runhaskell Setup.hs haddock" for generating the docs but that sounds highly unlikely
12:18:39 <dcoutts> mux: I very much doubt it, it's pre-cabal
12:18:46 <dcoutts> pre cabal-install I mean
12:19:06 * ksf_ thinks test suites shouldn't be built by default
12:20:17 <seliopou> > let strip = (takeWhile (not . isSpace)) . (dropWhile isSpace) in strip "   something    "
12:20:19 <lambdabot>   "something"
12:21:08 <aavogt> > isSpace '\n'
12:21:10 <lambdabot>   True
12:22:13 <nibro> dcoutts: a question for you
12:22:38 <nibro> I'm sure you're aware of my haskell-src-exts gsoc project
12:22:44 <dcoutts> nibro: yep
12:23:01 <nibro> one of the first things to do in there is to parametrize parsing on what extensions are expected in the code
12:23:09 <dcoutts> right
12:23:28 <nibro> so I'd want a list of extensions - incidentally the same list that appears in cabal's Language.Haskell.Extension
12:24:05 <nibro> ... which one might think would actually do better to live somewhere like haskell-src-exts in the first place
12:24:07 <dmwit> > let strip = (takeWhile (not . isSpace)) . dropWhile isSpace in strip "  something else   " -- seliopou =/
12:24:08 <lambdabot>   "something"
12:24:31 <dcoutts> nibro: hmm, though it has to be accurate with what features compilers actually ship
12:24:32 <seliopou> heh, right
12:24:51 <nibro> so I'm wondering if we want *one* such module somewhere, or if each tool should keep its own list
12:24:55 <dcoutts> nibro: I agree that the current Cabal lib seems a little heavyweight to be an appropriate home
12:25:09 <dmwit> > let strip = join (.) (reverse . dropWhile isSpace) in strip "  something else  "
12:25:10 <lambdabot>   "something else"
12:25:16 <dmwit> seliopou: How about that? =)
12:25:33 <nibro> when you say accurate, you mean it needs to contain *at least* what compilers need, right?
12:25:35 <dcoutts> nibro: my plan on that front is to separate the declarative bit of Cabal from the implementation of the build system. Then people should have fewer qualms about depending on the declarative bit.
12:26:13 <dcoutts> nibro: the reason it should be shipped with the compilers is so that when a compiler adds an extension, then people can start using it immediately.
12:26:15 <aavogt> > let strip = join fmap $ reverse . dropWhile isSpace in strip "  this works too?  "
12:26:15 <SamB> dcoutts: that's a good idea
12:26:16 <lambdabot>   "this works too?"
12:26:34 <SamB> dcoutts: will it be possible to implement support for a particular compiler seperately, somehow ?
12:26:36 <nibro> dcoutts: is GHC using cabal's module for this?
12:26:43 <SamB> probably not at first ...
12:26:47 <dcoutts> nibro: yes
12:26:50 <dmwit> aavogt: Sure, fmap = (.)
12:26:58 <dcoutts> SamB: that's not high on the todo list
12:27:18 <nibro> dcoutts: interesting, then it certainly needs to be kept in a more "central" location
12:27:45 <nibro> since other tools (*cough*) might not want to depend on cabal
12:27:50 <dcoutts> nibro: the Cabal lib is fairly central, it's a core lib shipped by every compiler (except jhc). There's no particular problem with depending on it.
12:28:34 <nibro> dcoutts: then there is of course also the issue that haskell-src-exts currently supports some non-standard extensions
12:28:57 <nibro> or I shouldn't say currently really, it does support them and will continue to do so
12:29:03 <dcoutts> nibro: all extensions should be registered. They do not have to be implemented in ghc to be listed in Language.Haskell.Extensions.
12:29:28 <nibro> so what would be the procedure to register an extension?
12:29:37 <dcoutts> nibro: send a patch with documentation.
12:29:50 <nibro> I'll be right on it :)
12:30:11 <Heffalump> does jhc actively refuse to integrate with cabal/hackage then?
12:30:36 <dcoutts> nibro: it's a central registry of extensions, so that when two compilers implement the same thing they can call it the same thing, or when the want to use the same name for different things then we can decide who got there first!
12:31:05 <nibro> what I will want to register is XMLExpressions and RegularPatterns
12:31:07 <dcoutts> nibro: so there needs to be enough documentation for another implementer to see if it's the same thing
12:31:11 <nibro> any objection to those names?
12:31:40 <SamB> XmlExpressions might be better
12:31:41 <dcoutts> nibro: not from me, send the patch to the cabal devel list and perhaps cc the ghc and/or libraries list
12:31:55 <dcoutts> Heffalump: pretty much
12:32:23 <Heffalump> oh well, it's not like it's much use either :-)
12:32:23 <dcoutts> Heffalump: I think for jhc it's supposed to be really minimal and people can install Cabal if they feel like it
12:32:40 <Heffalump> does it have a package system etc?
12:32:45 <dcoutts> sort-of
12:33:00 <dcoutts> there's code in Cabal for JHC, has been for ages, but it's a bit hard to test
12:33:12 <dcoutts> jhc cannot compile Cabal for example, or most of the packages that Cabal depends on
12:33:50 <dmwit> > let strip = stripNoSpace . dropWhile isSpace; stripNoSpace xs = let (b, e) = break isSpace xs in b ++ stripSpace [] e; stripSpace xs [] = []; stripSpace xs (y:ys) | isSpace y = stripSpace (y:xs) ys | otherwise = reverse xs ++ y : stripNoSpace ys in strip "   something else   "
12:33:51 <lambdabot>   "something else"
12:33:59 <dcoutts> John has the idea that Cabal should be able to just read a file that says "this compiler can be used like ghc, ie call it in batch mode with -c -o"
12:34:00 <skorpan> dmwit++
12:34:09 <dmwit> > let strip = stripNoSpace . dropWhile isSpace; stripNoSpace xs = let (b, e) = break isSpace xs in b ++ stripSpace [] e; stripSpace xs [] = []; stripSpace xs (y:ys) | isSpace y = stripSpace (y:xs) ys | otherwise = reverse xs ++ y : stripNoSpace ys in strip ("   something else   " ++ undefined)
12:34:10 <lambdabot>   "something else* Exception: Prelude.undefined
12:34:17 <dmwit> better for laziness =)
12:34:37 <skorpan> was that piece of code your first try or did you test it externally first?
12:34:41 <dcoutts> Heffalump: which is pretty ambitious, in practice at the moment one needs quite a bit of code to say how to find, configure and call the compiler and to establish the path conventions etc
12:34:45 <dmwit> skorpan: first try =)
12:34:48 <skorpan> cool :)
12:35:06 <dmwit> I've done it before, though, so I knew which bugs to watch for. =)
12:35:27 <olsner> how can it be the first try if you've done it before? :D
12:35:35 <dmwit> Okay, not first try. heh
12:35:41 <skorpan> still worth the ++
12:39:05 <nibro> dcoutts: I assume it's the head branch of cabal I want to send a patch to?
12:39:21 <hackagebot> buster 2.21
12:39:23 <dcoutts> nibro: yep
12:40:05 <dcoutts> nibro: ideal would be haddock docs that give a brief description plus a link to papers / websites for details.
12:40:44 <dcoutts> nibro: do not be discouraged by the fact that many existing extensions do not give this level of detail! It's my new hardline policy. :-)
12:41:31 <nibro> dcoutts: thanks a lot for deciding to implement it today and not tomorrow... :-)
12:41:58 <Cale> http://www.youtube.com/watch?v=X9dpXHnJXaE -- this is amusing
12:42:32 <dcoutts> nibro: ask Ian, he was the first to be hit with the new policy before they released 6.10 :-)
12:45:44 <nibro> dcoutts: so just to get this right, you want me to attach a haddock comment to the constructor that I propose be added, right?
12:46:51 <dcoutts> nibro: yes, like the example for PackageImports
12:47:12 <nibro> right, I see it now, thanks
12:47:21 <dcoutts> nibro: and since you've published things on each of these extensions (right?) you can link to those. (haddock uses <> for hrefs iirc)
12:48:26 <nibro> yep, I have a paper each on them
12:48:48 <nibro> they've evolved a bit since though, I probably should write that up on the wiki some time...
12:50:07 <olsner> Cale: cool!
12:50:35 <olsner> I'm amazed it actually works to connect that thing to a modern modem
12:51:04 <kpreid> olsner: as long as the protocol is the same...!
12:59:09 <nibro> dcoutts: what's the purpose of the knownExtensions list?
12:59:33 <dcoutts> nibro: so that we can enumerate the buggers
12:59:40 <nibro> (or maybe I should ask, what's the difference between that list and an enum instance?)
12:59:52 <nibro> oh, nvm, I should think for myself
12:59:53 <dcoutts> nibro:   | UnknownExtension String
12:59:58 <nibro> yeah, indeed
13:00:42 <dcoutts> and it's handy to have for quicker parsing
13:01:10 <Cale> olsner: and after 45 years, it's still functioning!
13:01:54 <byorgey> dcoutts: what's the syntax is for the 'tested-width:' field in .cabal files?
13:02:04 <byorgey> I couldn't find it in the documentation
13:02:12 <byorgey> er, tested-with
13:02:19 <dcoutts> byorgey: compiler flavour and a constraint, eg GHC == 6.8.3
13:02:32 <byorgey> ah, ok, thanks
13:02:35 <byorgey> I was only slightly off =)
13:03:31 <byorgey> dcoutts: is there a repo for the documentation somewhere?  I could submit a patch
13:03:46 <dcoutts> byorgey: yep, same repo, docs/Cabal.xml
13:03:53 <byorgey> ah, cool
13:07:04 <paper_cc> what can I do to debug a segfault in a Haskell program, provided that GHCi can't load it because it uses the BerkeleyDB binding? I've tracked the segfault down to a single takeMVar, but I can't reproduce it in a small program :(
13:10:10 <paper_cc> it still segfaults if I put a readMVar here, but it doesn't do so if I use putMVar, isEmptyMVar, tryTakeMVar, or if I fill the MVar before trying to read it - that is, it fails when it tries to wait.
13:10:29 <paper_cc> it also fails the same way if I use TMVars instead.
13:15:03 <Cale> paper_cc: That is really interesting and strange.
13:15:50 <Cale> paper_cc: Maybe some strange interaction between the details of that C library and GHC's concurrency?
13:16:02 <nimred> where can i get types.h breaking my xmobar build --> http://pastebin.ca/1438277 ?
13:16:15 * paper_cc comments out foreign calls
13:16:17 <Cale> paper_cc: But why can't ghci load it?
13:16:40 <paper_cc> Cale: BerkeleyDB binding is written in C++
13:17:31 <Feuerbach> nimred: haven't we inferred that you're not on linux and thus cannot have linux/types.h?
13:17:54 <Cale> paper_cc: huh? You mean the original BerkeleyDB library is in C++. The binding itself has got to be in Haskell :)
13:19:25 <paper_cc> Cale: that is, the binding has a helper C++ file which has to be linked with C++ runtime libraries
13:19:33 <olsner> if you have a reliable compiled test-case, you could try to gdb or strace it
13:21:00 <nimred> Feuerbach ignoring hinotihy or inotify didn't work neither so that i prefer asking here from the begining of my problem
13:21:34 <paper_cc> olsner: well, gdb shows no useful stack trace
13:22:33 <paper_cc> Cale: interesting, it also segfaults when I deadlock the whole thing manually
13:23:00 <Cale> Which binding are you using? There seem to be a number of them
13:23:37 <paper_cc> Cale: the capitalized one =) BerkeleyDB-0.6
13:24:36 <paper_cc> aha
13:24:54 <byorgey> anyone know what it means if I use 'cabal upload' and get an error '400 Error in upload'?
13:24:55 * paper_cc caught the point where GHC stopped producing deadlocking messages
13:25:12 <Feuerbach> nimred: making people to guess from the beginning that you're not on linux is not fair -- it's just wasting their time. Isn't it obvious that you are not supposed to have linux/types.h?
13:25:13 <dcoutts> byorgey: it means your proxy hates you
13:25:23 <skorpan> byorgey: well, that means "bad request", which iirc means that it expected e.g. GET, but you made POST, etc.
13:25:36 <byorgey> hrm
13:26:05 <byorgey> so if I try uploading from a different network it might work?
13:26:49 <nimred> Feuerbach you look like feeling so good to solve my problem --> do it
13:26:51 <dcoutts> byorgey: maybe. Out of interest, what version of cabal-install and what version of HTTP do you think it was built with?
13:27:25 <byorgey> it's cabal-install 0.6.2, pretty sure it was built with HTTP-4000.0.6
13:28:28 <byorgey> I guess I can just upload manually via the hackage website.
13:29:39 <Cale> nimred: I suppose the conclusion is that it requires linux, so if you're not running linux...
13:30:42 <Feuerbach> Cale: it's an optional dependency and he cannot figure out how to disable it
13:30:52 <byorgey> hmm, that didn't work either, but I got a different error message...
13:30:52 <Cale> Oh, is it optional?
13:30:56 * byorgey investigates further
13:31:35 <dmwit> inotify is only required for the Mail plugin in xmobar, IIRC
13:31:53 <dmwit> Isn't there a flag in the cabal file or something to disable it?
13:32:43 <byorgey> dcoutts: ah, this is bad
13:33:02 <byorgey> dcoutts: when I try to upload manually via the hackage web page I get this:
13:33:24 <byorgey> '400 Error in upload.  Unfortunately the language extensions 'PatternSignatures' break the parser in earlier Cabal versions... blah blah'
13:33:31 <byorgey> but 'cabal check' didn't give me any warnings.
13:33:54 <byorgey> and when I do 'cabal upload' it just says '400 Error in upload' without telling me the rest of the error.
13:34:24 <byorgey> dcoutts: how hard do you think this is to fix?  I might have a bit of time to send a patch if it isn't too bad
13:34:42 <Cale> try:  cabal install --flags="-with_inotify" xmobar
13:34:56 <Cale> nimred: ^^ see if that helps
13:35:30 <nimred> Cale it is ok :)
13:36:14 <nimred> Cale : just one warning :
13:36:21 <nimred> ": warning: warning: reference to compatibility setlocale(); include <locale.h> for correct reference"
13:36:41 <Cale> Okay, I have no idea what that means
13:37:07 <Cale> (I'm not xmobar's developer, I just looked in the .cabal file for what flags were there)
13:37:39 <hackagebot> RepLib 0.2.1
13:44:13 <mib_mf0uz8d4> hi
13:54:47 <byorgey> hi mib_mf0uz8d4
14:02:37 <nibro> dcoutts: so what would be the expected turnaround time for getting the patch applied, a version including the patch released, and a version including the patch included in the HP?
14:02:51 <nibro> (I sent a patch now btw)
14:03:54 <tibbe> anyone know what the actual cost of a "safe" FFI call is?
14:04:02 <inetic> hi guys, please, what is the (>>) function called again?
14:04:24 <Botje> "and then" :)
14:04:32 <Apocalisp> @type (>>)
14:04:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:04:51 <Apocalisp> I've heard it called "sequence".
14:05:02 <Apocalisp> But there's sequence
14:05:06 <Apocalisp> @type sequence
14:05:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:05:34 <inimino> "bind, but don't"?
14:05:42 <inetic> :-)
14:05:59 <inetic> I thought it has a precise one, but thanks
14:08:45 <paper_cc> Cale: I've caught the error to some extent
14:08:45 <paper_cc> Cale: actually, the program deadlocks, but something prevents GHC from printing out the message
14:12:47 <inetic> I have made some pictures (as part of my learning) and I think they might fit nicely in this wiki page: http://en.wikibooks.org/wiki/Haskell/Understanding_monads , would you guys care to review them?
14:14:21 <codemac> Is there a good example of getting a binary file into a B.ByteString?
14:17:38 <paper_cc> codemac: \filename -> withFile filename ReadMode $ B.hGetContents
14:17:54 <glguy> Data.ByteString.Lazy.readFile
14:18:46 <glguy> if you want to use withFile, you'll need withBinaryFile
14:21:45 <dcoutts> nibro: certainly in time for ghc 6.12.
14:23:11 * paper_cc wants a good libdb binding ... or will he write one?
14:29:37 <jeffwheeler> Is it acceptable to run darcsweb on community.haskell.org? I think it may require using a special port, and running its own server?
14:30:04 <jeffwheeler> Alternatively, is there some place that can mirror a repo, and provide RSS feeds for updates?
14:36:38 <Absolute0> Instead of composing the same function twice (func . func) is there a shorter way to compose the same function n amount of times?
14:37:20 <hatds> :t iterate
14:37:22 <lambdabot> forall a. (a -> a) -> a -> [a]
14:37:28 <mightybyte> What's the most common way to organize HUnit test cases?  Separate test case tree, separate files in the same tree, or included with the actual code?
14:37:30 <tromp> :t replicate
14:37:32 <lambdabot> forall a. Int -> a -> [a]
14:37:42 <dolio> @type \n -> foldr (.) id . replicate n
14:37:43 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:37:49 <hatds> @src iterate
14:37:50 <lambdabot> iterate f x =  x : iterate f (f x)
14:38:05 <hatds> Absolute0:   (iterate func) !! n
14:38:25 <Absolute0> I guess replicate would work too :)
14:39:23 <hatds> iterate was written for this though :)
14:40:04 <Absolute0> let x = (iterate $ takeWhile (/= '-')) !! 2 <--fails
14:40:07 <Absolute0> let me play with this
14:40:26 <dolio> iterate needs an initial argument.
14:41:10 <Absolute0> oh iterate f x..
14:41:17 <Absolute0> >log 5
14:41:20 <Absolute0> > log 5
14:41:21 <lambdabot>   1.6094379124341003
14:41:25 <Absolute0> sweet :)
14:41:34 <hatds> > :t (iterate Just) !! 5
14:41:36 <lambdabot>   <no location info>: parse error on input `:'
14:41:37 <Absolute0> is lambdabot written in haskell? :-P
14:41:44 <opqdonut> Absolute0: yeah
14:41:51 <hatds> :t (iterate Just) !! 5
14:41:52 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe a
14:41:52 <lambdabot>       Expected type: a
14:41:52 <lambdabot>       Inferred type: Maybe a
14:42:29 <Absolute0> opqdonut: I assume the creator likes southpark : http://www.haskell.org/haskellwiki/Lambdabot
14:42:59 <hatds> > ((iterate (*2)) !! 16) 2
14:43:01 <lambdabot>   Couldn't match expected type `[a]'
14:43:22 <glguy> newtype F a = F (a (F a))
14:43:24 <glguy> iterate (F . Just) :: F Maybe -> [F Maybe]
14:44:07 <hatds> > (\x -> (iterate (*2) x) !! 16) 2
14:44:09 <lambdabot>   131072
14:44:29 <Absolute0> composing the function twice looks much cleaner :(
14:44:33 <Absolute0> and more readable
14:44:46 <hatds> yea, you'll want a cleaner solution
14:45:33 <Absolute0> > 2 ^ 16
14:45:34 <lambdabot>   65536
14:45:40 <Absolute0> hmm
14:46:21 <nibro> you started with 2, and did *2 16 times
14:46:22 <Absolute0> hatds: what is your lambda supposed to do?
14:46:28 <nibro> that's 2 ^ 17 :)
14:46:37 <Absolute0> > 2 ^ 17
14:46:38 <lambdabot>   131072
14:46:42 <Absolute0> zere we go
14:47:39 <Absolute0> oooh MIT student :)
14:48:56 <ksf_> @seen conal
14:48:56 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 3h 24m 41s ago, and .
14:49:26 <ksf_> :q
14:49:32 <ksf_> uhhhh...
14:53:39 <gwern> 'Lloyd estimates the rate of Moore's Law as 108 factor of improvement in areal bit density over the past 50 years. Assuming that both storage density and computational speed will improve by a factor of 108 per 50 years, the limit will be reached in about 125 years for storage and about 250 years for operations per second. One imagines the final 125 years being spent frantically developing better compression algorithms - or advanced ...
14:53:42 <dcoutts> jeffwheeler: generally community.haskell.org isn't powerful enough to run anything extra :-) it suffers enough with what we've got
14:53:46 <gwern> ... theoretical physics research. '
14:53:47 <gwern> http://lwn.net/Articles/285790/ heh heh.
14:54:02 <gwern> dcoutts: oh darn, I was going to set up some gitit instances on it too!
14:54:05 <jeffwheeler> dcoutts: alright, that's why I asked :)
14:54:29 <dcoutts> we might switch to a more powerful server, eg the sparc server
14:54:48 <TomMD> Or make hackage-server a distributed system?
14:55:01 <gwern> dcoutts: I'd, uh, really appreciate c.h.o remaining x86
14:55:05 <dcoutts> TomMD: I don't think that's necessary yet
14:55:10 <dcoutts> gwern: you may not have that choice
14:55:35 <dcoutts> gwern: but we can probably promise that it remains debian linux
14:55:51 <dcoutts> gwern: what difference would it make?
14:56:06 <gwern> well, it means I couldn't copy over any of my binaries
14:56:17 <dcoutts> but you could compile them locally
14:56:18 <gwern> can't copy over and test out darcs darcs, etc
14:56:28 <dcoutts> but you can build darcs locally :-)
14:56:40 <dcoutts> the server has masses of cpu power
14:56:43 <gwern> after setting up an entire sparc toolchain?
14:56:51 <dcoutts> one will be provided
14:57:14 <TomMD> c.h.o should move to ARM... then a distributed system would be needed.
14:57:34 <jeffwheeler> @help quote
14:57:35 <lambdabot> quote <nick>
14:57:35 <lambdabot> remember <nick> <quote>
14:57:35 <lambdabot> Quote somebody, a random person, or save a memorable quote
14:57:44 <jeffwheeler> @remember TomMD c.h.o should move to ARM... then a distributed system would be needed.
14:57:44 <lambdabot> Nice!
14:57:56 <gwern> @quote distributed
14:57:56 <lambdabot> TomMD says: c.h.o should move to ARM... then a distributed system would be needed.
14:58:11 <TomMD> :-)
14:58:16 <gwern> @flush
14:58:24 <jeffwheeler> ?
14:58:38 <dcoutts> gwern: so nothing apart from concerns about building software easily?
14:58:41 <TomMD> Save quote db to disk.
14:58:59 <TomMD> jeffwheeler: that is what flush does, saves db to disk, if you were asking.
14:59:09 <jeffwheeler> TomMD: yep, thanks
14:59:11 <gwern> dcoutts: well, I am concerned that sparc seems to basically untested with the haskell ecosytem
14:59:33 <dcoutts> gwern: ghc passes the testsuite and has a native code gen
14:59:45 <dcoutts> that's what the project was for
14:59:50 <gwern> (which is worth about as far as you can punt the testsuite)
14:59:51 <dcoutts> well, and smp etc
15:00:43 <dcoutts> well, fortunately it's not as if it can regress from the current c.h.o :-)
15:00:50 <dcoutts> you can't run anything there atm
15:01:28 <TomMD> But the current c.h.o builds my xen bindings properly - its nice when the c library is already installed by pure coincidence.
15:02:02 <gwern> I ran gitit on c.h.o a few times
15:04:17 <TomMD> Its too bad gitit hasn't made the switch to happstack.
15:04:37 <gwern> ?
15:04:49 <TomMD> gwern: It still uses Happs.
15:05:01 <gwern> not really
15:06:11 <TomMD> Humm... it does for me.  I notice an OR there - what flag is it?  I'd think anyone with small base set would get the updated (happstack) version.
15:06:36 <gwern> I only use HEAD; in there I only see a plugins flag
15:06:55 <TomMD> Well when I cabal install it wants to use HaPPs.
15:07:19 <gwern> it's been a while since a release
15:07:34 <gwern> john got pretty busy because of the academic year; I think he's traveling right now or soemthing
15:12:16 <dcoutts> gwern: ah, so we should blame you when c.h.o goes insane? :-)
15:12:29 <gwern> dcoutts: sure, why not?
15:12:38 * dcoutts hopes gitit doesn't take much memory
15:12:53 * gwern reflects that as a pseudonym, vengeance cannot be visited upon my physical head
15:13:05 <dcoutts> heh
15:13:23 <gwern> gitit can take a lot of memory, but that's GHC's fault
15:13:26 <dcoutts> the server seems to go awol when we go over half memory use, probably because it's not backed by that much physical ram on the real host
15:13:55 <dcoutts> gwern: probably best to avoid it on c.h.o then
15:14:06 <gwern> at least for large repos
15:14:11 <RyanT5000> what's the cleanest way to install GHC 6.10.3 on Ubuntu? 6.8.2 is the latest available in the official repos
15:14:34 <gwern> for small repos, it's fine. my local wiki with ~700 patches peaks at 1.2% of my 3.6 gigs of ram
15:14:39 <gwern> (seems reasonable to me)
15:14:41 <dcoutts> gwern: using anything over 50M would be a bad thing for the server as a whole
15:15:37 <SamB> > 0.012 * 3.6*1024
15:15:39 <lambdabot>   44.2368
15:16:11 <dcoutts> on the new sparc you could use 4 gigs and nobody would notice
15:16:23 <byorgey> Hac phi registration is now open: http://haskell.org/haskellwiki/Hac_%CF%86
15:16:32 <SamB> whose new sparc?
15:16:43 <dcoutts> SamB: the one that belongs to haskell.org
15:16:48 <dcoutts> to the community
15:16:55 <SamB> accessible how?
15:17:05 <SamB> /when ?
15:17:22 <dcoutts> we'll be giving out accounts when ben is done with his project, which should be fairly soon now
15:17:41 <dcoutts> and we need to set up linux on it yet
15:17:44 <gwern> the sparc project has taken longer than I expected, actually
15:17:49 <gwern> didn't it start like last summer?
15:18:00 <dcoutts> gwern: no, January, he's not been doing it full time
15:18:13 <gwern> (oh. maybe last summer was when it was announced)
15:18:21 <dcoutts> gwern: yes and we got the server last autumn
15:19:56 <jeffwheeler> Where is the server, physically?
15:20:01 <dcoutts> Chalmers
15:20:06 <Jedai> RyanT5000: use the binary release from GHC homepage
15:20:29 <Tobsan> oh, which server are we talking about?
15:20:40 <jeffwheeler> The amount of Haskell work there is surprising and impressive . . .
15:20:44 <Jedai> RyanT5000: install it in /usr/local and install cabal-install, with that you'll have a nice setup
15:20:45 <gwern> our ultra-expensive multi-processor ultra sparc thingy
15:20:51 <Tobsan> gwern: ah I see
15:20:56 <gwern> jeffwheeler: such as?
15:21:01 <Tobsan> I have never got to see it physically :(
15:21:08 <jeffwheeler> gwern: just, a lot of people working on Haskell seem to be there
15:21:20 <TomMD> Wired... lava... various verification projects
15:21:23 <jeffwheeler> gwern: can't think of anybody specifically, just see a lot of @chalmers stuff :P
15:21:35 <gwern> TomMD: so nothing very useful to the community then
15:21:54 <TomMD> gwern: now now, the community can benefit from the most unexpected of things.
15:21:55 <dcoutts> Tobsan: http://blog.well-typed.com/2008/09/the-new-haskellorg-community-sparc-server-is-online/
15:21:55 <Tobsan> QuickCheck?
15:22:14 <gwern> Tobsan: I don't think benefitting from quickcheck was very unexpected...
15:22:14 <Tobsan> dcoutts: Ah, I remember reading about this
15:22:53 <TomMD> And thinking "damn, why didn't I apply" ??
15:23:05 <gwern> although I do wish quickcheck hadn't been cloned so widely... it would've been nice if we could've kept it for ourselves
15:23:41 <mapreduce> Yeah, but it's only actually generally usable in Haskell, from what I've seen.
15:23:56 <Tobsan> mapreduce: what about the erlang edition?
15:24:19 <mapreduce> I haven't seen it.  I'd guess the lack of typesystem makes QuickCheck more verbose there.
15:24:37 <Tobsan> neither have I
15:24:53 <dcoutts> mapreduce: apparently the lack of a type system makes it more useful since it also catches type errors :-)
15:25:08 <TomMD> dcoutts: What do you think about a bundling package names with hashes in the index-00.tar.gz for client side verification?
15:25:37 <mapreduce> I like Erlang's "types".  Tuples where the first element is a symbol.  Much more honest than most languages.
15:25:45 --- mode: ChanServ set +o bos
15:25:50 --- mode: ChanServ set -o bos
15:26:09 <dcoutts> TomMD: I think that's a good idea. The index should contain a signed list of tarball hashes.
15:26:28 <TomMD> You want it signed?  I figured it would remain cheaper than real crypto, but either way.
15:27:51 <TomMD> So the full idea is signing index-00.tar.gz, which contains hashes of the files.  This as opposed to signing each package separately, allowing verification even without updated index.
15:27:53 <nibro> actually, John Hughes likes to speak of how much *less* verbose quickcheck is in erlang since the types don't get in the way
15:28:12 <gwern> those goshdarn types
15:28:18 <nibro> and he once claimed that he considered quickcheck a reasonable replacement to a type system...
15:28:30 <dolio> Hah.
15:29:01 <nibro> John is tricky, you never really know if he means it or not :)
15:29:26 <mapreduce> Why prove your code correct when you can write n^n tests for it? ;)
15:29:29 <dcoutts> TomMD: I'm not sure what you mean about an updated index, but yes, it tells you a package has not been modified since it was uploaded to hackage
15:29:47 <dcoutts> TomMD: of course whether you trust the package is your own business
15:30:32 <dcoutts> TomMD: so it's a much simpler system than signing each package and trying to track that back to devs, but correspondingly you get less of a guarantee
15:31:37 <dcoutts> TomMD: and yes, I think there's little point unless the index is signed. Otherwise it's just a last-hop integrity test which we can do as well using the http md5 header
15:32:25 <TomMD> Someone should build an ECC Haskell library.
15:33:55 <duaneb> could someone help me with some parsec stuff?
15:34:16 <duaneb> identifier = (initial >> many subsequent) <|> peculiarIdentifier
15:34:29 <duaneb> problem with this is, 'initial' is lost
15:34:34 <duaneb> how can I make it not lost? :P
15:34:53 <dcoutts> TomMD: if you're hacking on the hackage-server though I think there are more pressing issues, like doc uploads/downloads
15:35:03 <Cale> liftM2 (:) initial (many subsequent)
15:35:28 <TomMD> Yep, building haddock docs is perhaps the big issue followed by pretty pages and account management (creation).
15:35:30 <dcoutts> TomMD: I started implementing a component for serving the contents of tarballs in a memory-efficient way
15:35:43 <TomMD> Great!
15:35:54 <duaneb> Cale: that doesn't make sense
15:36:00 <nibro> anyone know for sure if ICFP papers can be freely distributed on your own webpage?
15:36:16 <dcoutts> TomMD: ie maintaining a file index in memory, mapping file names to (offset,length) in the uncompressed tarball, so that serving the content would be quick.
15:36:28 <duaneb> oh wait
15:36:29 <duaneb> that does
15:36:35 <dcoutts> nibro: unless they've changed the rules, yes you can.
15:36:53 <dcoutts> TomMD: but I don't have the time to work on it in the next few months :-(
15:37:27 <nibro> dcoutts: thanks - I'm already doing it, but if I was to put the paper in a more stable location then I really needed to know for sure ;)
15:38:10 <dcoutts> nibro: we certainly did for our icfp paper, on the understanding we could do so.
15:42:07 <nibro> http://www.sherpa.ac.uk/romeo.php
15:42:14 <nibro> good site that
15:42:20 <nibro> the answer is a definite yes
15:44:19 <genericBrandRame> has anyone here installed the reactive-fieldtrip package? I'm having trouble with some of its dependencies
15:46:17 <ksf_> genericBrandRame, I'm attempting to install reactive, myself.
15:46:41 <ksf_> ...and run into issues regarding quickcheck 1 vs. quickcheck 2
15:46:50 <genericBrandRame> yep, same here
15:47:29 <genericBrandRame>     Could not find module `Test.QuickCheck.Utils':
15:47:29 <genericBrandRame>       it is a member of package QuickCheck-1.2.0.0, which is hidden
15:48:07 <ksf_> conal knows about it, I just send him an email asking for some help how to best remove both checker and quickcheck dependencies from reactive... I didn't plan on running the tests, anyway.
15:49:19 <RyanT5000> i'm having the same issue
15:59:27 <Baughn> @type id
15:59:29 <lambdabot> forall a. a -> a
15:59:30 <Baughn> @type flip id
15:59:31 <lambdabot> forall b c. b -> (b -> c) -> c
15:59:33 <Baughn> @type flip
15:59:35 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
16:02:46 <duaneb> cycle "OM N"
16:02:52 <duaneb> > cycle "OM N"
16:02:53 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
16:03:46 <ksf_> > cycle [1..]
16:03:47 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
16:03:51 <Japsu> > fix ("OM N":)
16:03:52 <lambdabot>   ["OM N","OM N","OM N","OM N","OM N","OM N","OM N","OM N","OM N","OM N","OM ...
16:03:58 <Japsu> :(
16:04:14 <ksf_> > fix ("OM N" ++)
16:04:15 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
16:04:23 <ksf_> @src cycle
16:04:24 <lambdabot> cycle [] = undefined
16:04:24 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
16:04:42 <duaneb> cycle 1
16:04:47 <duaneb> >cycle 1
16:04:51 <duaneb> > cycle 1
16:04:52 <lambdabot>   No instance for (GHC.Num.Num [a])
16:04:52 <lambdabot>    arising from the literal `1' at <inter...
16:04:53 <ksf_> > fix (""++)
16:04:56 <Japsu> > fix ('O':'M':' ':'N':)
16:04:57 <lambdabot>   The operator `:' [infixr 5] of a section
16:04:57 <lambdabot>      must have lower precedence th...
16:04:58 <lambdabot>   mueval-core: Prelude.read: no parse
16:04:58 <lambdabot>  mueval: ExitFailure 1
16:04:58 <duaneb> > cycle "1"
16:05:00 <lambdabot>   "11111111111111111111111111111111111111111111111111111111111111111111111111...
16:05:13 <ksf_> > fix (""++)
16:05:18 <duaneb> > cycle [1,1]
16:05:19 <lambdabot>   mueval-core: Prelude.read: no parse
16:05:19 <lambdabot>  mueval: ExitFailure 1
16:05:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:05:59 <gwern> (ah, good ol mueval. one of the few haskell things I can be proud of)
16:06:33 <ksf_> well, you could make her report "hey, don't give me headaches"
16:07:06 <gwern> that is too silly & irreverent
16:07:12 <gwern> mueval is more dignified than lambdabot
16:07:13 <iop> is there a function: splitOn :: (a -> Bool) -> [a] -> [[a]] ; ?
16:07:35 <gwern> iop: see the split package in hackage
16:07:36 <iop> @hoogle (a -> Bool) -> [a] -> [[a]]
16:07:37 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
16:07:37 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
16:07:37 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
16:08:08 <gwern> yeah, you shouldn't use that Distribution one :)
16:09:14 <aconbere_> anyone here know much about optimizing hopengl performance?
16:09:27 <aconbere_> I'm new to both opengl and hopengl and haskell! so this is fun :)
16:09:50 <ksf_> ...well, if it's slower than opengl/c, report a bug.
16:09:56 <TomMD> aconbere_: The first step is in knowing what (if anything) is performing poorly.
16:09:56 <aconbere_> that's fair
16:10:00 <aconbere_> yeah
16:10:03 <aconbere_> so I've run the profiler
16:10:04 <TomMD> aconbere_: So start profiling!
16:10:08 <TomMD> good
16:10:21 <aconbere_> and I guess I'm just suprised by the cose of rendering some of the basic primitives I'm using
16:10:24 <aconbere_> (squares)
16:10:26 <aconbere_> cost
16:10:39 <ksf_> aconbere_, you could be stressing the command pipeline.
16:11:09 <ksf_> (or be running software gl...)
16:11:28 * aconbere_ nods
16:12:07 <aconbere_> this is the profile output form the function that renders the squares
16:12:11 <aconbere_> renderQuad        Shape                                                587     1676579  14.4   44.7     0.0    0.0
16:12:22 <aconbere_> maybe a key would help as well :)
16:12:37 <aconbere_> COST CENTRE              MODULE                                               no.    entries  %time %alloc   %time %alloc
16:13:20 <ksf_> uhhh... If I'm not really mistaken, you shouldn't be able to derive much meaning out of the profile, as you're basically talking over a socket.
16:13:24 <aconbere_> so basically rendering probably... 200 2D squares is taking up most of the time
16:13:31 <aconbere_> hmmm
16:13:35 <aconbere_> that's fair
16:13:40 <TomMD> So you are running it 16M times - is that more than you'd expect?  Sometimes I find that I can drastically reduce the number of calls because some calls are unneeded (or a I can use a smarter alg).
16:13:56 <ksf_> or display lists.
16:14:15 <aconbere_> display lists?
16:14:15 <ksf_> if you're sending unchanging geometry to the renderer on every frame, you're doing it wrong.
16:14:41 <ksf_> they safe gl commands to be executed later, and multiple times.
16:14:48 <aconbere_> ah yes
16:14:56 <aconbere_> well maybe the answer is to actually read the red book
16:14:58 <ksf_> ...and the renderer can pre-compile them and do other smart stuff
16:15:09 <ksf_> that's an excellent idea.
16:15:28 <aconbere_> I'm definitely sending non-changing pieces to the render, but basically as a side effect of how I've created my map / finding intersections etc.
16:15:46 <aconbere_> I could probably isolate a number of the non-change pieces though
16:15:56 <aconbere_> which definitely make up a bulk of those calls
16:16:03 * aconbere_ goes off to poke around
16:18:26 <aconbere_> thanks :)
16:20:01 <skorpan> hi, i have a problem which i kind of understand, but i'm not sure how to get around it...
16:20:02 <skorpan> lol = Hello <$> sym "hello" <|> World <$> sym 2
16:20:02 <skorpan> sym x = symbol (== x)
16:20:25 <skorpan> by 'sym "hello"' it infers that the function works with Strings, but the function itself is polymorphic
16:20:41 <skorpan> how do i get around this problem?
16:21:26 <Botje> explicit type annotation
16:21:35 <ksf_> you can't have a function that's polymorphic between "hello" and 2, they share no usable common class.
16:21:48 <Botje> Eq?
16:21:57 <ksf_> oh. yeah.
16:22:18 <iop> how can I regex in haskell?
16:22:28 <skorpan> Botje: you mean i should give "sym" an explicit type?
16:22:33 <Botje> yes
16:22:39 <skorpan> okay, makes sense.
16:22:44 <ksf_> there's multiple regex libraries, take your pick, or use a proper parser library like parsec/polyparse
16:23:11 <ksf_> I'd recommend a parser library, they tend to be less messy.
16:28:03 <whoppix> http://www.getacoder.com/projects/detect_loop_106243.html < someone feels like solving the halting problem today? :)
16:29:45 <aconbere_> is there a way to create portable executables via ghc / hugs?
16:29:49 <ksf_> "suspectible" is nice. you can just collect fixpoints and print them.
16:31:07 <ksf_> ghci is a bytecode interpreter, so I guess it wouldn't be too much work to hack something up.
16:31:11 <int-e> or modify a compiler to inject infinite loops
16:31:19 <sjanssen> aconbere_: how portable?
16:31:43 <sjanssen> GHC executables are portable to like architectures and operating systems
16:32:04 <mmorrow> and if you -static, you just need the same libc
16:33:12 <aconbere_> sjanssen: yeah I guess I'm just wondering if I need to pass some options to GHC to staticlly link libraries, etc.
16:33:29 <aconbere_> I haven't /tried/ running any of my executables on other machines
16:33:36 <aconbere_> which really I suppose would answer my question
16:33:42 <mmorrow> you need to pass the necessary opts to the linker
16:33:57 <mmorrow> -optl-static -optl-lgmp -optl-l...
16:34:21 <ksf_> you should be automagically fine on linux/osx/windoze, except if you use low-level stuff like posix sockets or something.
16:34:37 <sjanssen> aconbere_: GHC doesn't have many dynamic links by default
16:34:54 <sjanssen> aconbere_: GMP is the only one AFAIK
16:34:56 <mmorrow> yeah, sometimes -optl-static Just Works, and sometimes you have to mess with optl-.. options
16:36:11 <iop> is there a function f = drop 1 ?
16:36:36 <ksf_> > let f = drop 1
16:36:38 <lambdabot>   not an expression: `let f = drop 1'
16:36:49 <ksf_> > let f = drop 1 in f "foo"
16:36:50 <lambdabot>   "oo"
16:37:02 <ksf_> I think it's called "tail".
16:37:51 <aconbere_> haha
16:38:29 <dibblego> > dropWhile (== '0') &&& length $ "00123" -- what operation do I want for ("123", 3) ?
16:38:31 <lambdabot>   ("123",5)
16:39:55 <mmorrow> > (id &&& length) . dropWhile (== '0') $ "00123"
16:39:56 <lambdabot>   ("123",3)
16:40:16 <dibblego> hmm thanks
16:40:30 <gwern> @src tail
16:40:31 <lambdabot> tail (_:xs) = xs
16:40:31 <lambdabot> tail []     = undefined
16:40:33 <iop> duht tail yes
16:40:48 <gwern> tail isn't the same as drop 1, as you can see. they deal with empty lists differently
16:40:51 <dibblego> tail /= drop 1
16:41:01 <gwern> @check \x -> tail x == drop 1 x
16:41:02 <lambdabot>   "* Exception: Prelude.tail: empty list
16:41:06 <idnar> > drap 1 []
16:41:07 <lambdabot>   Not in scope: `drap'
16:41:10 <idnar> > drop 1 []
16:41:12 <lambdabot>   []
16:41:23 <mmorrow> > take 100000000000000000 []
16:41:24 <lambdabot>   []
16:41:36 <gwern> @src take
16:41:36 <lambdabot> take n _      | n <= 0 =  []
16:41:37 <lambdabot> take _ []              =  []
16:41:37 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
16:42:42 <gwern> hm. how is take evaluated for 'take 100 []'? does it pattern match on [] first and fall through to [], or does it do positive-number test first and then return []?
16:43:12 <mmorrow> i'd think the posnum test first, then matches []
16:43:38 <idnar> > take 100 [1,2]
16:43:38 <mmorrow> , take (negate 10000000000000) [0..]
16:43:39 <lambdabot>   [1,2]
16:43:40 <lunabot>  []
16:43:53 <gwern> mmorrow: that seems inefficient, then
16:43:54 <mmorrow> , take (negate 10000000000000) undefined
16:43:55 <lunabot>  []
16:44:31 <idnar> > take (negate 100) undefined
16:44:32 <mmorrow> gwern: true, i'd hope in the real implem they don't test for negative every loop
16:44:32 <lambdabot>   []
16:44:49 <gwern> mmorrow: I suppose we could check the core...
16:45:04 <mmorrow> (or GHC.List (or whatever))
16:46:06 <dolio> It has to test for 0 every iteration anyway.
16:46:12 <mmorrow> take n _ | n <= 0 = []; take n xs = let go _ [] = []; go 0 _ = []; go n (x:xs) = x : go (n-1) xs in go n xs
16:46:21 <mmorrow> actually, you have to test for 0 anyways..
16:46:24 <mmorrow> yeah
16:46:39 <gwern> why do you have to test for zero?
16:46:54 <mmorrow> because how else would you know when to stop?
16:47:00 <gwern> if the second arg is [], then you can instantly stop there and return []
16:47:11 <mmorrow> , take 10 [0..]
16:47:12 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
16:47:30 <mmorrow> without the 0 test, that never would finish
16:48:22 <dolio> The only question is whether "n <= 0" turns into two operations or one.
16:48:32 <mmorrow> yeah, true
16:48:45 <dolio> It's probably 2.
16:48:47 * mmorrow looks at the asm
16:49:15 <dolio> Unless it does some fancy stuff for 0 comparisons.
16:49:49 <dolio> Or, I suppose you could always turn it into one operation, but whatever.
16:50:35 * ksf_ bets you're going to find a jle
16:50:37 <dolio> I know that compare on Ints isn't terribly optimal.
16:51:02 <mmorrow> what's "jb" again?
16:51:16 <ksf_> below.
16:51:20 <ksf_> that's the inverse of le
16:51:37 <ksf_> wait, no, taht'll be ja
16:51:54 <mmorrow> JB Jump if Below
16:52:11 <ksf_> wtf does ghc do there?
16:52:21 <idnar> jb == jl right?
16:52:36 <ksf_> modulo signedness, yes.
16:53:04 <idnar> oh right, signedness
16:53:10 <ksf_> there's also other equivalences due to bit reprentation, I constantly forget them.
16:53:36 <ksf_> if you don't see another je or jne, it's one operation.
16:53:36 <mmorrow> hmm, it's hard to tell since i don't see any tests against an immediate $0 or $1
16:55:20 <dolio> There's actually a <=# primop.
16:55:21 <dolio> How nice.
16:55:41 <TomMD> @seen shapr
16:55:42 <lambdabot> shapr is in #haskell-blah and #haskell. I last heard shapr speak 14m 14s ago.
16:55:56 <mmorrow> oh yeah, i forgot what we're looking for
16:56:03 <mmorrow> yeah, it looks like it's one op
16:56:18 <iop> is there something about \n00 that makes zeros be regarded as terminating or newline chars?
16:56:24 <iop> as opposed to just \n
16:56:48 <ksf_> there's CString
16:57:03 <idnar> ksf_: '0' is not a NUL
16:57:35 <mmorrow> here's the asm + hs if anyone want to look http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2515#a2515
16:57:38 <mmorrow> (x86_64)
16:57:56 <sjanssen> iop: that string is just a newline followed by two '0' characters
16:57:59 <ksf_> well, if it's that, then the answer is map (\x -> if x == '0' then '\n' else x)
16:58:34 <mmorrow> ooh wait, it might be two tests
16:59:14 <shapr> TomMD: You called?
16:59:19 <mmorrow> preflex: zdec ghczmprim_GHCziTypes_ZMZN_closure
16:59:19 <preflex>  ghc-prim_GHC.Types_[]_closure
16:59:36 <ksf_> wow
16:59:50 <TomMD> shapr: I just wanted you to know that every time I google for anything new on h@lvm your IRC statement always comes up first.
17:00:06 * mmorrow gives up trying to figure out the flow from the asm
17:00:10 <TomMD> I guess that tells me there isn't any other solid info on the web when IRC logs dominate the first page.
17:00:12 <mmorrow> too many indirect jumps
17:01:10 <shapr> TomMD: Can't argue with that.
17:03:01 <dibblego> @type [minBound..maxBound] -- is this in the standard library?
17:03:03 <lambdabot> forall a. (Bounded a, Enum a) => [a]
17:03:07 <dibblego> @hoogle (Bounded a, Enum a) => [a]
17:03:08 <lambdabot> Prelude enumFrom :: Enum a => a -> [a]
17:03:08 <lambdabot> Prelude maxBound :: Bounded a => a
17:03:08 <lambdabot> Prelude minBound :: Bounded a => a
17:04:15 <mmorrow> oh, maybe that "took" isn't getting stuff unboxed since it's just that single function in its own module, so nothing can be specialized
17:04:47 <dolio> Yeah.
17:04:47 <mmorrow> preflex: zdec ghczmprim_GHCziTypes_ZC_con_info
17:04:47 <preflex>  ghc-prim_GHC.Types_:_con_info
17:07:56 <iop> ah i see
17:08:18 <iop> read 00229 ::Int obv drops the zeros
17:09:01 <iop> is there a function: f :: String -> [Char] ?
17:09:16 <TomMD> iop: id
17:09:24 <TomMD> :-)
17:09:39 <ksf_> String _is_ [Char]]
17:09:51 <TomMD> hence 'id' will work fine.
17:15:55 <iop> i have a String and want to turn each char to an int
17:16:02 <iop> String -> [Int]
17:16:06 <iop> how?
17:16:16 <iop> > map (\x -> read x :: Int) "123"
17:16:18 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:16:31 <ziman> > map digitToInt "123"
17:16:33 <lambdabot>   [1,2,3]
17:16:34 <skorpan> @hoogle Integer -> Char
17:16:35 <lambdabot> Prelude fromInteger :: Num a => Integer -> a
17:16:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:16:35 <lambdabot> Prelude show :: Show a => a -> String
17:16:49 <skorpan> @hoogle Char -> Integer
17:16:50 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
17:16:50 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
17:16:50 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
17:16:58 <skorpan> ah, unsafeCoerce, there we have it
17:17:00 <ziman> > map ord "123"
17:17:02 <lambdabot>   [49,50,51]
17:17:10 <ksf_> showDecimal n = showIntAtBase 10 intToDigit n ""
17:17:15 <ziman> > unsafeCoerce 0 :: String
17:17:17 <lambdabot>   Not in scope: `unsafeCoerce'
17:17:25 <centrinia> > map (chr. ord) "Hello World!"
17:17:27 <lambdabot>   "Hello World!"
17:17:29 <ksf_> ah, we alrealy have a string
17:17:45 <skorpan> > map ((-(ord '0')) . ord) "123"
17:17:47 <lambdabot>   Couldn't match expected type `b -> c'
17:17:49 <skorpan> bah
17:19:14 <iop_> > map digitToInt "123"
17:19:16 <lambdabot>   [1,2,3]
17:19:28 <iop_> @index digitToInt
17:19:29 <lambdabot> Data.Char
17:20:04 <iop_> @src digitToInt
17:20:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:20:26 <ksf_> :t (-(1))
17:20:27 <lambdabot> forall a. (Num a) => a
17:20:42 <ksf_> hmmm... shouldn't that be a (-) section?
17:21:24 <amz> > map (-(1)) [1..5]
17:21:25 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
17:21:25 <lambdabot>    arising from a use of syntactic n...
17:21:59 <amz> guess that it's simply interpreting it as -1
17:22:15 <amz> > map ((-)1) [1..5]
17:22:17 <lambdabot>   [0,-1,-2,-3,-4]
17:22:28 <amz> meh
17:22:33 <twanvl> > map (subtract 1) [1..5]
17:22:34 <lambdabot>   [0,1,2,3,4]
17:25:44 <jimmyjazz14> map (+) 7) [1..10]
17:25:58 <jimmyjazz14> map ((+) 7) [1..10]
17:26:24 <jimmyjazz14> lambdabot: :t map
17:26:34 <jimmyjazz14> lambdabot: help
17:26:43 <shapr> @help
17:26:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:26:52 <shapr> > map (+ 7) [1..10]
17:26:53 <lambdabot>   [8,9,10,11,12,13,14,15,16,17]
17:27:39 <jimmyjazz14> > map ((+) 4) [1..20]
17:27:41 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24]
17:27:42 <shapr> jimmyjazz14: Do you have ghci installed? Many things that work in ghci will work if you put them after > here on #haskell
17:27:51 <jimmyjazz14> heh cool
17:27:53 <shapr> :t (+ 4)
17:27:54 <lambdabot> forall a. (Num a) => a -> a
17:28:14 <jimmyjazz14> :t map
17:28:15 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:29:20 <shapr> :t \a b -> b a
17:29:21 <lambdabot> forall t t1. t -> (t -> t1) -> t1
17:29:29 <jimmyjazz14> I've been trying to get lambdabot to run on Arch
17:29:39 <jimmyjazz14> anyone got that going?
17:29:41 <shapr> Not working?
17:29:47 <shapr> I haven't tried to build lambdabot recently.
17:29:56 <sjanssen> jimmyjazz14: getting lambdabot to build is always a bit of a chore
17:30:55 <jimmyjazz14> I was trying to do it with AUR
17:31:13 <jimmyjazz14> I get dependency problems with haskell-brainfuck
17:31:28 <shapr> I use debian, I assume AUR is the package management system for Arch?
17:31:49 <jimmyjazz14> yeah
17:31:55 <skorpan> shapr: the user repo stuff
17:32:05 <jimmyjazz14> kinda
17:32:05 <shapr> oh
17:32:29 <skorpan> jimmyjazz14: i think you're just better off cabal installing everything haskellish
17:32:43 <skorpan> the AUR has bitten me so many times and cabal mostly works better
17:32:43 <jimmyjazz14> yeah I'll probably just do that
17:32:53 <skorpan> i never use the AUR for haskell packages anymore
17:33:12 <jimmyjazz14> yeah its been a bit of a pain for me
17:34:04 <iop_> how do I convert from Int to Double? apparently fromIntegral fosnt do that
17:35:38 <sjanssen> iop_: fromIntegral does do that
17:35:45 <sjanssen> > fromIntegral (1 :: Int) :: Double
17:35:46 <amz> > (fromInteger 5) :: Double
17:35:47 <lambdabot>   1.0
17:35:48 <lambdabot>   5.0
17:37:18 <skorpan> :t fromIntegral
17:37:20 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:37:36 <skorpan> :t fromInteger
17:37:37 <lambdabot> forall a. (Num a) => Integer -> a
17:37:51 <skorpan> so, basically there is no point in using fromInteger as opposed to fromIntegral?
17:38:42 <jbauman> > (fromIntegral 1) :: Double
17:38:43 <lambdabot>   1.0
17:38:57 <skorpan> ...is there?
17:39:37 <Cale> skorpan: It's important when defining Num instances, and that's about it.
17:39:46 <skorpan> how so?
17:39:50 <mmorrow> in ghc fromIntegral is implemented with {-# RULES ... #-} for all the types, so it's guaranteed to be the most efficient possible way
17:40:25 <Cale> Because fromInteger is a method of the Num class which is responsible for the interpretation of integer literals.
17:40:46 <Cale> But other than that, fromIntegral is usually more convenient.
17:41:36 <mmorrow> skorpan: yeah, fromInteger is what implicitly happens with all integer literals
17:41:55 <mmorrow> 1 :: Tree (Maybe (Either (Map () ()) Int))
17:42:00 <mmorrow> ==> fromInteger 1
17:42:06 <Cale> When you write 5435789341075439, the compiler desugars that to fromInteger (5435789341075439 :: Integer)
17:42:32 <skorpan> Cale: why is ":: Integer" necessary?
17:42:49 <dolio> It isn't.
17:42:53 <mmorrow> i think he was just to being explicit
17:42:58 <skorpan> oh
17:43:07 <Cale> I was just being explicit that it's *actually* an integer there
17:43:30 <skorpan> okay, so it does fromInteger...  but what is the result type?
17:43:32 <skorpan> Num a?
17:43:32 <Cale> (and not another polymorphic integer literal, because that would be silly)
17:43:37 <Cale> yeah
17:43:47 <Cale> :t 5
17:43:49 <lambdabot> forall t. (Num t) => t
17:43:58 <skorpan> i see
17:44:00 <mmorrow> > 1 :: Tree (Maybe (Either (Either () ()) Int))
17:44:01 <lambdabot>   No instance for (GHC.Num.Num
17:44:01 <lambdabot>                     (Data.Tree.Tree
17:44:01 <lambdabot>           ...
17:44:06 <skorpan> :t fromInteger (2434 :: Integer)
17:44:07 <lambdabot> forall a. (Num a) => a
17:44:30 <skorpan> :t Tree
17:44:32 <lambdabot> Not in scope: data constructor `Tree'
17:44:52 <skorpan> does lambdabot have any "builtin" natural number type?
17:45:12 <skorpan> as in something like data Nat = Succ Nat | Zero
17:45:27 <mmorrow> data E = Lit Integer | E :+ E | E :* E deriving(Eq,Ord,Read,Show); instance Num E where fromInteger = Lit; (+) = (:+); (*) = (:*); signum = undefined; abs = undefined
17:45:44 <mmorrow> , src ''Tree
17:45:47 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
17:46:04 <shepheb> having a parsec issue. I've got a parser for variable declarations, and another for statements. the parser for a procedure expects variable declarations followed by statements, but it fails in the vardecls one, on the first statement. it's like it doesn't backtrack far enough.
17:46:52 <mmorrow> shepheb: are you using 'try' enough? parsec does depth-first search, so once it commits to a subtree without try, it never looks back
17:47:05 <shepheb> possibly not.
17:47:06 <mauke> o/` if at first you don't succeed ... o/`
17:47:19 <skorpan> the lesson is "never try"
17:47:22 <Botje> .. get a bigger gun?
17:47:33 <mmorrow> .. cheat?
17:47:53 <Botje> .oO(aimbots written in haskell)
17:48:08 * Twey laughs.
17:48:35 <skorpan> :t Nat
17:48:37 <lambdabot> Not in scope: data constructor `Nat'
17:48:49 <skorpan> so lambdabot does *not* have any builtin natural number type?
17:49:54 <roconnor> > 1 : Natural
17:49:55 <lambdabot>   Not in scope: data constructor `Natural'
17:50:08 <roconnor> > 1 :: Natural
17:50:09 <lambdabot>   1
17:50:23 <skorpan> @src Natural
17:50:23 <lambdabot> Source not found. My mind is going. I can feel it.
17:50:27 <skorpan> hm...
17:50:37 <roconnor> > infinity :: Natural
17:50:39 <lambdabot>   * Exception: stack overflow
17:50:44 <skorpan> > (1 :: Natural) - (2 :: Natural)
17:50:46 <lambdabot>   * Exception: Natural: (-)
17:50:53 <skorpan> > (1 :: Natural) - (1 :: Natural)
17:50:54 <lambdabot>   0
17:51:10 <skorpan> > fromIntegral (1 :: Natural) :: Integer
17:51:12 <lambdabot>   1
17:51:18 <skorpan> > fromIntegral (1 :: Natural)
17:51:20 <lambdabot>   1
17:51:24 <skorpan> > :t fromIntegral (1 :: Natural)
17:51:26 <lambdabot>   <no location info>: parse error on input `:'
17:51:30 <skorpan> :t fromIntegral (1 :: Natural)
17:51:31 <lambdabot> forall b. (Num b) => b
17:52:40 <skorpan> > (1383148184848 :: Natural) - (1 :: Natural)
17:52:43 <lambdabot>   * Exception: stack overflow
17:52:48 <skorpan> > (1383148184 :: Natural) - (1 :: Natural)
17:52:51 <lambdabot>   * Exception: stack overflow
17:52:53 <skorpan> > (1383148 :: Natural) - (1 :: Natural)
17:52:56 <lambdabot>   * Exception: stack overflow
17:52:58 <skorpan> > (1383 :: Natural) - (1 :: Natural)
17:53:00 <lambdabot>   1382
17:53:05 <skorpan> there we are
17:53:44 <skorpan> > (1383 :: Natural) - (1 :: Integer)
17:53:45 <lambdabot>   Couldn't match expected type `Data.Number.Natural.Natural'
17:53:58 <skorpan> :t (-)
17:53:59 <lambdabot> forall a. (Num a) => a -> a -> a
17:54:06 <skorpan> ah
17:54:52 <BMeph> Hello, everyone. (Back from my stay-cation.)
18:05:00 <chessguy> so i've been thinking a lot lately about building a chess strategy DSL
18:05:37 <chessguy> my thinking is that i can define very simple engines
18:05:57 <chessguy> and then combinators which take 2 (or maybe even more) engines, and create another engine
18:06:04 <mightybyte> How will you compose those engines?
18:06:12 <chessguy> oh pipe down, you :)
18:06:35 <chessguy> haha, i was boring mightybyte  with these ideas all day
18:07:16 <skorpan> chessguy: you're being pretty abstract right now :P
18:07:56 <mightybyte> The worst thing is not the boringness...it's that he's not using haskell.
18:08:28 <iop> m = toMatrix "C:/users/saftarn/desktop/sudoku.txt" >>= \r -> return $ fromList $ head r ?
18:08:38 <chessguy> i've been re-thinking that, mightybyte
18:08:48 <mightybyte> Oh, excellent.
18:08:55 <skorpan> :t toMatrix
18:08:57 <lambdabot> Not in scope: `toMatrix'
18:09:01 <skorpan> oh, uhm... never mind.
18:09:09 <chessguy> skorpan:  my idea is to sort of have a parsec-like API
18:09:19 <skorpan> iop: ... >>= return . fromList . head
18:10:11 <skorpan> or maybe ... >>= fromList <$> head, but i'm not sure
18:10:22 <skorpan> :t liftM
18:10:23 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:10:28 <sjanssen> no, fmap (fromList . head) ...
18:10:31 <skorpan> no, that doesn't work
18:10:38 <sjanssen> or fromList . head <$> ...
18:10:55 <skorpan> oh, right
18:12:54 <skorpan> :t fmap
18:12:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:13:06 <skorpan> so fmap is just a slightly more general version of liftM, right?
18:13:47 <chessguy> mightybyte:  i'm back to thinking each engine should just be a function from (Position,LegalMoves) -> Maybe Move
18:13:48 <skorpan> hm, no...
18:13:54 <sjanssen> liftM is an artifact of some brokenness in the Prelude
18:14:09 <aavogt> @hoogle liftM
18:14:09 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
18:14:10 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:14:10 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
18:14:14 <skorpan> sjanssen: but what i said isn't true though, is it?  because i thought Monad somehow required Functor
18:14:19 <sjanssen> skorpan: all monads are functors, but the Prelude classes don't enforce that
18:14:31 <aavogt> and its not even in the prelude
18:14:32 <skorpan> well, then we sorted that out
18:14:48 <skorpan> but how can all monads be functors?
18:15:01 <sjanssen> if you've got bind and return:
18:15:03 <ddarius> Anyone interested in a decent chunk of a (raw) binding to libusb-1.0 and/or (Haskell) code that talks to Owon oscilloscopes over USB?
18:15:04 <sjanssen> @src liftM
18:15:04 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
18:15:58 <skorpan> oh...  so basically this could hold for any monad: fmap = liftM?
18:16:09 <roconnor> yes
18:16:11 <sjanssen> yes, that should be true
18:16:32 <skorpan> will this prelude brokenness be handled in haskell prime?
18:16:47 <sjanssen> probably not
18:16:57 <sjanssen> Haskell' isn't very ambitious in that way
18:17:36 <aavogt> when did Haskell' start? 1999?
18:17:42 <dibblego> it's not? then why bother with Haskell' at all?
18:17:56 <chessguy> aavogt:  err, try in the 80's sometime, i believe
18:18:03 <ddarius> dibblego: Because 1998 was over ten years ago.
18:18:11 <sjanssen> aavogt: Haskell' started more recently, 2007 maybe?
18:18:12 <chessguy> aavogt:  there's a great history of haskell paper out there
18:18:32 <chessguy> oh! i mis-read, sorry. missed the "'"
18:18:51 <skorpan> heh
18:19:12 <sjanssen> dibblego: Haskell' is supposedly an iterative process, with out much backwards incompatible changes
18:19:43 <sjanssen> dibblego: but it also hasn't seen too much progress, so who knows what will really come of it
18:19:54 <kniu> What's the difference between Text.ParserCombinators.Parsec
18:19:57 <ddarius> Well, if anyone is interested in the USB bindings, email me, because I'm not interested in finishing them or maintaining them.
18:19:59 <kniu> and Text.Parsec?
18:20:05 <chessguy> byorgey:  we need some lambdabot love in #haskell-hackphi!
18:20:13 <ddarius> Text.Parsec is parsec3 Text.ParserCombinators.Parsec is parsec2
18:20:18 <sjanssen> lambdabot: @join #haskell-hackphi
18:20:32 <chessguy> sjanssen:  no k in hacphi, sorry
18:20:36 <sjanssen> chessguy: you'll need to talk to Cale if you want to make it permanent
18:20:42 <sjanssen> lambdabot: @part #haskell-hackphi
18:20:49 <sjanssen> lambdabot: @join #haskell-hacphi
18:20:50 <chessguy> i ken seplll reel gut
18:20:52 <kniu> why have parsec2 installed if you already have parsec3?
18:21:07 <aavogt> hmm, there's some mentions of haskell two somewheres, any leads? my searches turn up nothings
18:21:12 <ddarius> parsec2 is faster and what most libraries expect.
18:21:23 <kniu> huh
18:24:03 <aavogt> sjanssen: the mailing list archives for H' go back to 2006
18:29:56 <Tsion> data Integral a => Ratio a = !a :% !a deriving (Eq)
18:30:08 <Tsion> What do the !s mean?
18:30:38 <jaredj> strictness
18:31:12 <Tsion> So it will evaluate them right away?
18:31:33 <jaredj> yes, rather than store them as thunks and evaluate them when they're needed.
18:31:47 <Tsion> Okay, thanks jaredj
18:34:38 <Cale> Tsion: More precisely, anything which evaluates a Ratio value will cause both the fields to be evaluated at that point
18:36:41 <Cale> (The report defines it in a slightly different way actually, but I'm fairly sure the difference only matters if you're mixing strict and non-strict fields)
18:38:26 <sm> Cale: good evening, fyi I haven't been able to see a speedup with your fast tree builder. I wonder if I lost the benefit by converting it. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5360#a5360
18:39:48 <Cale> hmm
18:40:28 <Cale> Well, I used it at the time to construct some very large trees rather quickly...
18:40:34 <mmorrow> ddarius lives
18:41:17 <Cale> sm: it looks like you're doing lots of (xs ++ [a]) ?
18:42:06 <sm> I guess.. I wanted the full path in each node, not just the node name
18:42:13 <Cale> sm: Note that (xs ++ [a]) eventually costs O(length xs) time to evaluate
18:42:26 <Cale> and so if you keep doing it, it'll be quadratic time
18:42:29 <sm> aha
18:42:34 <mmorrow> oh, ddarius has quit
18:42:57 <sm> gosh I really need to learn these costs
18:43:50 <sm> still, the max length of xs there is the depth of the tree
18:44:13 <sm> about 8
18:44:49 <sm> I wish, I wish, for a more readable/friendly profiler
18:45:01 <Cale> What does the profiling output say?
18:45:31 <fracture> is there a prefered way to put named constants into haskell code?
18:45:37 <jaredj> In python, by convention, methods starting with _ are more or less for internal use only. Is there a convention about identifiers starting with _ in Haskell?
18:45:43 <fracture> just foo = value maybe?
18:45:48 <Cale> fracture: yeah
18:45:56 <Cale> fracture: Everything is a named constant anyway ;)
18:45:58 <fracture> any naming conventions?
18:46:02 <fracture> ah good point
18:46:08 <fracture> nm then
18:46:26 <Cale> jaredj: Usually that's a hint that the parameter is unused.
18:46:39 <Cale> (If it's part of a pattern match)
18:46:48 <jaredj> uhh. right, but that's if _ is the whole thing
18:46:53 <jaredj> what about _x
18:47:01 <Cale> Well, if _ is the whole thing then it *really* is unused
18:47:04 <jaredj> sure
18:47:12 <chessguy> i've never seen _x as an identifier
18:47:13 <sm> Cale: before http://joyful.com/repos/hledger/profs/200905250945.prof , after http://joyful.com/repos/hledger/profs/200905250949.prof
18:47:24 <jaredj> wait this whole thing is dumb
18:47:28 <Cale> But I've seen the convention where something like _x was used to give a parameter a name even though it goes unused.
18:47:41 <mmorrow> sm: ooh, are you making a hierarchical Trie of account (which may have subaccounts which may have..) and then attaching values to the leaves? (i did something very similar at one point)
18:47:47 <chessguy> Cale:  that's....weird
18:47:51 <jaredj> if i have a little convenience function needed by two functions i expect others to use, i just don't export it from the module. right?
18:47:52 <chessguy> why not just leave it at _ then?
18:48:07 <Berengal> chessguy: Documentation
18:48:09 <sm> mmorrow: just a tree, I do not speak trie yet
18:48:26 <Cale> jaredj: right
18:48:52 <jaredj> ok. thx
18:49:00 <Cale> My Tree is effectively a Trie with a large alphabet :)
18:49:28 <jaredj> has anyone made a trae yet?
18:49:33 <mmorrow> sm: hmm, so are you grouping subaccounts of account underneath their parent account, and so on recursively?
18:49:34 * sm 's head spins.. steady..
18:50:02 <sm> mmorrow: yes indeed.. I make a tree of account names (the chart of accounts) to start
18:50:09 <gwern> jaredj: as a child, I frequently ate off traes
18:50:15 <sm> then I transform that into a richer data structure
18:50:28 <mmorrow> cool
18:50:36 <Cale> sm: hmm... This is the profiling output from the optimised version, yeah?
18:50:40 <jaredj> haha
18:51:02 <sm> the "after" link is, I'm 98% sure
18:51:06 <Cale> The profiling output is harder to read even though it's more accurate when you turn optimisations on.
18:51:08 <dibblego> @hoogle Seq a -> [a]
18:51:09 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
18:51:09 <lambdabot> Prelude repeat :: a -> [a]
18:51:09 <lambdabot> Data.List repeat :: a -> [a]
18:51:23 <Cale> I'm seeing all these ==_a6iI etc, which are strange.
18:51:34 <sm> hmm. I think this profile is unoptimised
18:51:39 <gwern> I was very disapointed to find that the Show instance for Seq was 'fromList [...]'
18:51:50 <Cale> I'm guessing they're specialisations of equality tests...
18:53:13 <Cale> anyway, it looks like in either case, the major time centre is ledgerAccount, and the major allocation centre is isAccountNamePrefixOf
18:53:31 <Cale> The latter seems suspicious.
18:53:40 <Cale> What does that function look like?
18:53:54 <Cale> gwern: What's wrong with that?
18:54:29 <gwern> Cale: well, it's inefficient. here we have a strict, finite list, and we're re-using the machinery of regular lists?
18:54:54 <Cale> gwern: But it gives you valid Haskell code for reconstructing the list, which is all that it's meant for.
18:55:30 <gwern> I know, but we shouldn't need to switch to data.binary every time we need even a tiny bit of performance; the defaults should be reasonably performant
18:55:39 <Cale> Huh?
18:55:52 <Cale> Lists perform very well for the kind of access which show does.
18:56:31 <Cale> In fact, by comparison, Data.Seq would be slower.
18:56:44 <gwern> when I was dealing with large Seqs, I noticed data.binary was faster than read/show for seq
18:56:56 <Cale> Well, of course.
18:56:58 <sm> Cale: it's about a third of the way down http://joyful.com/repos/hledger/Ledger/AccountName.hs
18:58:46 <dibblego> is there any way to use two equally named functions from different modules in the same source file without using import qualified?
18:59:11 <Cale> sm: Even though it might destroy correctness, will you try something for a moment? Remove that ++ [acctsepchar]
18:59:20 <sm> sure thing
19:00:14 <Cale> The only way I imagine that function is doing allocation is when it creates that new list.
19:00:50 <Cale> Though, I wouldn't expect it to change the time-performance much
19:01:56 <mauke> dibblego: yes, just qualify them
19:02:46 <sm> Cale: a second slower, but 600M less allocation - http://joyful.com/repos/hledger/profs/200905281900.prof
19:02:58 <cads> bleh, currying a variadic function is so ugly
19:03:14 <Cale> sm: That's interesting that it would be slower
19:03:54 <cads> have to say something like ((curry * 3) 2 4 2 1 :end) => 48
19:03:59 <Cale> sm: anyway, the main cost in time is ledgerAccount, but looking at the code for that, it's probably not ledgerAccount's fault.
19:04:03 <hatds> dibblego: no, but if they are highly related functions there might be a way around it
19:04:22 <Cale> It's the fact that you're calling it 821149 times...
19:04:24 <sm> it's funny I don't see anything under the ledgerAccount 40% line
19:04:26 <sm> oh!
19:04:27 <sm> that
19:04:34 <sm> right you are
19:04:44 <Cale> (plus a few)
19:05:02 <Cale> and it's all from ledgerAccountTree
19:05:14 <sm> isSubAccountNameOf 2 million times
19:06:35 <Cale> But apparently that's much cheaper :)
19:06:37 <sshc> how do I operator overload in Haskell?
19:07:01 <Cale> sshc: Typeclasses
19:07:04 <sshc> is it possible to define two functions with the same names but take completely different types of arguments?
19:07:29 <dibblego> sshc, yes, using type-classes
19:07:35 <Cale> sshc: Yes. You define a typeclass for the set of operations which you want to make general, and then instances for each of the types you want to implement them at
19:07:50 <Cale> sm: Where is treemap defined?
19:08:22 <fracture> I have a long computation where I want to see what's happening; seems like printf-style debugging is basically impossible in haskell
19:08:29 <fracture> is there a way to trace through stuff in ghci?
19:08:35 <sm> Cale: http://joyful.com/repos/hledger/Ledger/Utils.hs
19:08:37 <hatds> you should also consider whether (say) your 2 functions f1: a1 -> b and f2: a2 -> b are actually representing one function f : a -> b where a is a bigger type
19:08:42 <aavogt> @hoogle trace
19:08:42 <lambdabot> Debug.Trace trace :: String -> a -> a
19:08:42 <lambdabot> module Debug.Trace
19:08:42 <lambdabot> package traced
19:08:55 <Cale> fracture: Yes, there's a debugger and Debug.Trace.trace
19:09:14 <fracture> cool I'll look into that
19:09:15 <fracture> thanks
19:09:21 <Cale> fracture: But you might find that things happen in a very different order than you expected, if you're not so familiar with lazy evaluation
19:09:32 <hatds> fracture: you might find the ghci evaluation stepper more useful than the trace for just understanding how the execution goes
19:09:57 <dblazakis> wasn't there a monad reader article on using the ghci debugger?
19:10:02 <sm> really.. I found the ghci debugger much more confusing than trace
19:10:25 <hatds> sm: meaning, the :step debugging?
19:11:42 <fracture> ah yes... the :step output is weird
19:11:46 <fracture> I think I need to read the manual for this :)
19:12:50 <hatds> Yea, I've never used :step to debug a full fledged program, but I've found it invaluable for learning the finer points about Haskell semantics
19:13:28 <fracture> seems like it could be more useful with integration into an editor
19:13:34 <fracture> it's cumbersome to type :list every time
19:13:52 <fracture> I'll try trace (in other languages I'd most likely printf debug this situation too)
19:14:28 <hatds> there's a command to make it :list after every step
19:14:33 <fracture> ah
19:14:40 <hatds> the ghc user manual has a small tutorial
19:14:50 <fracture> :set stop :list
19:14:56 <fracture> yay
19:15:01 <fracture> ;)
19:15:02 <sm> hatds: yeah.. worth learning, but tricksy! It may be a bit better now
19:15:35 <sm> it was semi-useful when I tried
19:15:52 <sm> peter hercek has been doing cool enhancements
19:17:26 <kniu> @src foldl
19:17:27 <lambdabot> foldl f z []     = z
19:17:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:17:41 <fracture> wow this is really neat (seeing how the laziness works)
19:17:57 <sm> oh man it's good to be back on the big monitor..
19:18:54 <kniu> @src foldr
19:18:55 <lambdabot> foldr f z []     = z
19:18:55 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:27:56 <iop> is bitC an ongoing project?
19:28:35 <sm> there's something I don't understand in this profile excerpt: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5361#a5361
19:29:17 <sm> is it telling me ledgerAccountTree, called 2457 times, called all of treeprune, ledgerAccount and treemap 800k times ?
19:30:01 <sm> and how can that be since it is just: ledgerAccountTree depth l = treemap (ledgerAccount l) $ treeprune depth $ accountnametree l
19:30:35 <sm> oh I see.. treemap/treeprune recurse
19:32:12 <Cale> There must be a lot of nodes in that tree.
19:32:30 <sm> I think I see..
19:33:15 <sm> there are 600 nodes
19:33:38 <fracture> hmm
19:33:40 <sm> max depth is about 10
19:33:46 <fracture> trying to run the profiler on a program that doesn't terminate
19:33:58 <fracture> and the prof file doesn't get anything when I sigint it
19:34:07 <fracture> is there any way to do that?
19:34:15 <sm> fracture: someone posted recently on-list about a real-time profiler thing
19:34:45 <fracture> maybe I can limit my thing to a maximum depth somehow and have it terminate there
19:34:55 <Cale> sm: Is it a different tree each time?
19:34:56 <fracture> pass an n to my expression and when n > 10000 do an error or something
19:35:01 <Cale> sm: Or are you repeating work?
19:35:38 <sm> Cale: there's only one tree for the duration of the program.. I guess I must be repeating work somehow
19:35:41 <gwern> well, if you're interested in memory, I believe the PS heap profilign output is continuous
19:35:49 <fracture> more interested in time
19:36:04 <fracture> memory usage seems constant for the program (I think it is GCing everything after it uses it as I proc stuff)
19:36:05 <Cale> sm: Perhaps you could compute that treemap higher up and pass the result in?
19:37:11 <sm> I don't quite see it
19:37:24 <sm> what you mean
19:39:42 <Cale> sm: I suppose it's impossible, because it's dependent on l...
19:39:50 <Cale> (looking at the code)
19:39:55 <sm> I'm not sure why I'm getting this big multiplier effect.. according to me, it does things in stages: first builds the 600-node account name tree; then prunes it; then maps ledgerAccount l to each node
19:40:13 <Cale> actually, no, that's not at all what it does
19:41:00 <Cale> The first thing to happen is that treemap is applied to (ledgerAccount l), and then that does a pattern match on the tree, which causes treeprune to be evaluated...
19:42:17 <Cale> and treeprune also ends up wanting to see the root of the tree, and so accountnametree l is evaluated just enough to construct the root, at which point treeprune matches against it, and then treemap applies the function ledgerAccount l to the root and returns a Branch node.
19:42:31 <sm> woah.. rewiring my mental map
19:42:46 <Cale> and the treemap and treeprune continue when the subtrees get pattern matched
19:44:24 <sm> laziness takes a long time to understand :)
19:45:05 <sm> that explanation is a very helpful reminder
19:46:31 <sm> then my haskell-sense tells me that I could make something strict here, and it would behave better
19:46:35 <Cale> Is there a particular reason you didn't like my way of organising the account names in the tree?
19:46:53 <sm> you mean just having the node name at each node ?
19:47:10 <Cale> Yeah, and having a Map at each level
19:47:12 <MyCatVerbs> sm: meh, laziness. I'll get around to understanding it later, since it's not strictly necessary right away. ;D
19:47:37 <Cale> Well, in fact...
19:47:40 <sm> Cale: just that it requires rethinking the rest of the app
19:48:03 <sm> if I absolutely have to change the whole app to make this perform, I guess I will
19:48:16 <hackagebot> HSFFIG 1.1
19:48:49 <Cale> Well, I'm still not certain enough about what this is doing in order to say whether it's necessary/recommendable :)
19:48:58 <sm> I mean, it probably won't mean a lot of changes, but a fair bit of thought
19:49:04 <Cale> What is it that is being computed here?
19:49:18 <Cale> I noticed 'isInteresting'
19:49:55 <sm> well, what I've been trying to optimise is just this:
19:49:57 <sm> -- | Convert a list of account names to a tree.
19:49:57 <sm> accountNameTreeFrom ∷ [AccountName] → Tree AccountName
19:51:06 <mmorrow> sm: is an AccountName something like AccountName = (SubAccountName, AccountName)  ?
19:51:29 <sm> and now I have shifted to understanding why there's such a high multiplier effect
19:51:34 <Cale> type AccountName = String
19:51:52 <mmorrow> (which could manifest itself it different ways i guess, e.g. "Foo.Bar.Baz.Sales")
19:51:54 <Berengal> Sounds like the perfect job for a trie...
19:52:41 <mmorrow> exactly, then once you've built the trie, you can turn it into a Tree fairly easily
19:52:48 * sm is converting ["assets", "assets:bank", "assets:bank:checking", "expenses:food"] to a tree 
19:52:56 <mmorrow> perfect
19:52:59 <sm> and it had been O(n^2)
19:53:20 <mmorrow> bb in a minute
19:54:09 <sm> and Cale gave me a non-n^2 tree builder which worked for him.. but doesn't have much effect in my app yet
19:55:37 <sm> I'm also trying to learn how to efficiently profile and tune haskell. Part of my brain is saying "you wouldn't be spending this time if it was python"
19:56:51 <MyCatVerbs> sm: you also wouldn't get anywhere near the same ceiling if it was Python, so meh.
19:57:13 <MyCatVerbs> sm: anyways, I trust you are using ghc-core for the awkward tuning bits?
19:57:26 <Cale> MyCatVerbs: Nothing at that level
19:58:02 <Cale> ghc-core is useful when you're worried about how things are optimised... this is an asymptotic problem, most likely
19:58:19 <MyCatVerbs> Oh? Oh, aye. Excuse my thinking in constant factors. ^^
19:58:43 <Cale> sm: Is that darcs repo current?
19:59:18 <sm> no it isn't.. I'll make it so
20:01:16 * thoughtpolice hopes he can make it to hac phi...
20:01:24 <thoughtpolice> thank goodness it's in july; I won't have class :)
20:02:07 <sm> Cale: pushed the latest
20:02:55 <sm> if you are profiling, I should make you a data file like the one I have here
20:03:24 <mgsloan> has anyone thought about writing a tool to analyze large volumes of haskell code (spider for code on the internet), and generate a list of functions which abstract the most frequent replications?
20:05:51 <dmwit> mgsloan: I know of at least one person who has thought about it.
20:06:16 <mgsloan> and that's me!  just kidding.  it would be very interesting.
20:06:25 <dmwit> Yeah, it would be!
20:06:29 <dmwit> You should definitely do it.
20:07:35 <mgsloan> Maybe this summer I'll give it a go :)  interning at adobe might be enough coding for the summer though, hrmm
20:08:29 <myname> any body uses xmobar's Mail plugin?
20:08:49 <dmwit> myname: Ask on #xmonad, there's more likely to be people using xmobar there.
20:09:00 <idnar> sm: if you think profiling and tuning python is easy, I'd love to know what your secret weapon is :P
20:09:01 <myname> thanks
20:09:07 <mgsloan> You would probably need some sort of canonical form, which minimizes the difference between re-expression of a similar concepts
20:09:48 <idnar> sm: I actually think GHC's tools are a lot better in several areas
20:11:15 <dmwit> > groupBy (/=) [1,2,3,2,1,2,3]
20:11:17 <lambdabot>   [[1,2,3,2],[1,2,3]]
20:11:24 <dmwit> Oh, that is just too slick.
20:11:31 <dmwit> I'm going to hate myself tomorrow for writing the code this way.
20:11:58 <idnar> how the heck does that work?
20:12:14 <idnar> @src groupBy
20:12:14 <lambdabot> groupBy _  []       =  []
20:12:15 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:12:15 <lambdabot>     where (ys,zs) = span (eq x) xs
20:12:21 <Gracenotes> groups by the first element of the list
20:12:34 <Gracenotes> into blocks beginning with that element
20:12:52 <idnar> oh, groupBy isn't what I thought
20:13:06 <Cale> sm: I have something for you to test. Not sure if it will improve performance, but it's something to try.
20:13:10 <dmwit> > groupBy (/=) []
20:13:11 <lambdabot>   []
20:13:17 <dmwit> ah, rats
20:13:27 <dmwit> Oh well, I can just declare that nobody pass me [].
20:13:49 <sm> Cale: great
20:13:57 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5362#a5362
20:15:05 <sm> idnar: you may be right. That part of my brain is just saying that mutability would - in practice, for me writing this app - avoid all this in the first place. Bringing other costs with it down the road of course.
20:15:32 <idnar> sm: I think it's all about trade-offs
20:15:54 <sm> indeed. I'd like to understand those well
20:15:57 <idnar> sm: not only trade-offs in the language itself, but also in what you're familiar with, and the "community knowledge" that exists
20:16:10 <sm> agreed
20:18:23 <idnar> I'm kinda optimisation-weary right now; I've spent the last week and a half optimising Python code :)
20:18:34 <sm> Cale:         total time  =        4.98 secs   (249 ticks @ 20 ms)
20:18:34 <sm>         total alloc = 1,803,104,924 bytes  (excludes profiling overheads)
20:18:43 <idnar> fortunately I've been targetting CPU time, not memory usage
20:19:00 <Cale> Better?
20:19:10 <sm> yes it seems a couple of secs faster
20:19:40 <Cale> It's a lot of allocation, but it should all be immediate garbage.
20:20:37 <sm> just for reference, the Competition (c++ ledger) does this in .4s
20:21:21 <sm> I was using this quite happily, then some boor pointed this out on the list..
20:21:52 <idnar> heh
20:22:08 <Cale> Well, you are using a lot of Strings...
20:22:28 <p_l> sm: which c++ ledger?
20:22:30 <Cale> It's also probably possible to do this tree construction more directly
20:22:57 <sm> p_l: http://wiki.github.com/jwiegley/ledger
20:23:15 <Cale> Seems a bit of a shame to switch back and forth between a Trie of the components and a Data.Tree...
20:23:37 <p_l> sm: wasn't it obsoleted by the author? :)
20:23:57 <sm> not at all.. 3.0 will be out when he gets back to it
20:24:09 <sm> meanwhile I have been hacking on our righteous http://hledger.org
20:24:09 <p_l> sm: Right, seems like the C++ version still gets some work
20:25:32 <sm> Cale: maybe time I read up on trie and used it throughout then. I still wonder if any of this "advanced" optimisation is required.. if I would just not call these things 800k or 2 million times
20:25:37 <mmorrow> sm: here's some Trie code that i use a bunch and a speed test (builds a Tree of 1000 random [String]'s by way of an intermediate Trie) that's pretty speedy http://moonpatio.com/repos/trie-test/
20:25:52 <Cale> sm: Right, that's sort of what I was asking about before.
20:25:56 <dibblego> is there a safe (!!)? (to return Maybe)?
20:26:42 <Cale> sm: Actually it would be interesting to see the new profile
20:26:44 <mmorrow> (i used this trie-code when i was doing that account grouping thing too, and it worked out well (thousands of hierarchical accounts from a db and treeify -> webpage (w/ sparklines!))
20:27:28 <Cale> It's not exactly a conventional Trie which I was using either, but one where the account name path components are the alphabet :)
20:27:49 <mmorrow> exactly
20:28:10 <mmorrow> (which is a Trie in my book)
20:28:12 <Cale> Which I think models the directory tree structure that it's going for best anyway
20:28:14 <sm> brb
20:28:31 <Cale> So it might be worthwhile to make other code in the program use that type.
20:28:48 <mmorrow> my trie type is:
20:28:54 <mmorrow> newtype Trie m k a = Trie (Maybe a, m (SubKey k) (Trie m k a))
20:28:59 <Cale> newtype Tree' a = T (Map a (Tree' a))
20:29:00 <mmorrow> type family SubKey k
20:29:00 <mmorrow> type instance SubKey [k] =
20:29:04 <mmorrow> k
20:29:19 <mmorrow> (and i'm using Data.Map for the m)
20:29:34 <Cale> cool
20:29:58 <mmorrow> i used okasaki's trie chapter from purely funcitonal datastructures
20:29:59 <mmorrow> http://moonpatio.com/repos/trie-test/Trie.hs
20:30:29 <mmorrow> (i had to use a function on haskell records of functions to model his sml functor though)
20:30:42 <mmorrow> trie :: M m k (Trie m [k] a) -> M (Trie m) [k] a
20:31:05 <mmorrow> (is the "sml functor")
20:32:01 <sm> Cale: latest profile with your change: http://joyful.com/repos/hledger/profs/200905282017.prof
20:32:24 <Cale> Oh, interesting.
20:32:35 <Cale> So now it's *really* ledgerAccount which we need to attack
20:33:01 <Cale> Well, or the need to call that in the first place
20:33:56 <mmorrow> what does ledgerAccount do?
20:34:05 <Cale> It's just a map lookup, I think.
20:34:17 <Cale> The real problem is that it's being called 800,000 times
20:34:34 <Cale> (when the map is nowhere near that large, even)
20:35:12 <mmorrow> what's the Map of?
20:35:13 <Cale> hmmm
20:35:40 <mmorrow> (and what's the Map's key type?)
20:35:41 <Cale> Damnit I hate firefox's copy/paste shenanigans
20:35:53 <Cale> > 821161 / 2457
20:35:54 <lambdabot>   334.2128612128612
20:35:56 <Cale> hmm
20:36:47 <Cale> mmorrow: String
20:37:01 <Cale> ledgerAccount :: Ledger -> AccountName -> Account
20:37:01 <Cale> ledgerAccount l a = (accountmap l) ! a
20:37:23 <mmorrow> ooh, String will kill
20:37:48 <Cale> Yeah, but I somehow don't think that's the main problem.
20:37:55 <mmorrow> personally i'd map strings to Ints somehow, and use IntMap
20:38:20 <Cale> I don't care for IntMap very much somehow. It's always seemed like an ugly hack to me.
20:38:31 <mmorrow> i dunno, Int compare is like a single machine instr, whereas String compare is ..
20:38:40 <Cale> (but I'm morally opposed to Int in the first place ;)
20:38:50 <mmorrow> Cale: i never cared for it either, until i saw how cool of a structure it is
20:38:59 <mmorrow> for instance, it never needs rebalancing
20:39:06 <mmorrow> and union is best-case O(1)
20:39:18 <Cale> String comparisons are lexicographical though, so, most of the time you don't compare the whole thing
20:40:07 <Cale> sm: Is the average number of accounts per ledger around 300?
20:40:13 <Cale> That seems high...
20:40:17 <mmorrow> (and IntMap nodes have the Int key unboxed into them, whereas Map nodes have a ptr to the key)
20:41:12 <Cale> mmorrow: Yeah, but this is all stuff which should be hidden behind the Data.Map library. I shouldn't have to import a separate module and use a different datatype.
20:41:40 <Cale> Maps which happen to have Int keys should just be fast :)
20:41:53 <mmorrow> IntMap could just as well be IntegerMap, the only thing it needs is the ability to do bitwise ops on the key type
20:42:02 <mmorrow> (it's a BitTrie..)
20:42:24 <sm> Cale: I think it would lower for most..
20:42:25 <mmorrow> Map and IntMap are totally diff structures
20:42:43 <Cale> mmorrow: Right, getting the polymorphic stuff to work is hard.
20:43:12 <Cale> sm:
20:43:12 <mmorrow> yeah, and patricia trees don't even work if you can't do bitwise stuff on the key
20:43:15 <Cale> > 821161 / 2457
20:43:17 <lambdabot>   334.2128612128612
20:44:12 <fracture> anyone know if there's a way to :step in ghci that doesn't doesn't step into stuff it needs to compute to get the current expression?
20:44:23 <fracture> or like a step out
20:44:26 <fracture> couldn't find it in the manual
20:44:43 <Cale> I think the stepping commands are somewhat limited...
20:44:50 <Cale> fracture: what are you trying to analyse?
20:45:12 <fracture> well, I have this search thing that I've figured out is going into an infinite loop
20:45:21 <fracture> and I'm trying to understand the conditions that cause it to do so
20:45:36 <fracture> (at least I think it's going infinite)
20:45:49 <Cale> Maybe start by plonking a Debug.Trace.trace into it which prints the parameters that it's called with each time.
20:46:10 <Cale> that way you can figure out how it's being called at least
20:46:26 <fracture> the data structure is somewhat large... it'd be nicer to be able to inspect it in the debugger
20:46:50 <Cale> Do you know which function it is?
20:46:52 <fracture> how do you put a trace in, by the way?  const function?
20:46:54 <fracture> yeah
20:47:22 <Cale> What's it's type?
20:47:28 <fracture> like .. const foo (trace "asd") ?
20:47:36 <fracture> solve :: Board -> Int -> Maybe Board
20:47:47 <fracture> board is data Board = Board (Array (Int,Int) Int) deriving Show
20:47:52 <Cale> okay
20:47:57 <Cale> add a case:
20:48:38 <Cale> solve b i | trace (concat ["solve: ", show b, " ", show i]) False = undefined
20:48:43 <Cale> at the top
20:49:00 <fracture> ok
20:49:02 <Cale> The guard will always fail, but its evaluation will print that message
20:49:20 <fracture> ah nice
20:49:38 <Cale> Then you can comment out that line to stop tracing.
20:51:12 <mmorrow> ooh, handay
20:51:38 <fracture> cool; this should work to debug this (thanks)
20:51:40 <Cale> In general,  trace str x   is a value which is the same as x, but when x gets pattern matched against, the string str is printed on stderr
20:51:42 <bos> is anyone planning on going to hac φ?
20:51:55 <fracture> got ya
20:51:55 <mmorrow> bos: i'd like to
20:52:01 * bos is thinking about it
20:52:18 <mmorrow> nice
20:52:37 <mauke> oleg++
20:53:16 <mauke> hmm, this may have the unintended side effect of strictifying solve
20:53:23 <mauke> deep strict
20:53:25 <Cale> Yes, it will.
20:53:34 <Cale> I've had that be a problem before too ;)
20:53:39 <fracture> hmm... now I'm not so sure it's in an infinite loop :)
20:53:43 <fracture> guess I gotta think about this more
20:53:47 <ivanm> mauke: what has oleg done this time?
20:54:28 <mauke> AFAIK he invented the | ... False = undefined trick; at least that's where I learned about it
20:54:42 <Cale> I stole it from the original definition of undefined
20:54:50 <Cale> Which was
20:54:52 <mmorrow> mauke: i heard that if you say oleg's name 3 times into a mirror in the darc he'll appear out of nowhere and delimit your continuation
20:54:57 <Cale> undefined | False = undefined
20:55:20 <mauke> redundant
20:55:34 <Cale> It's undefined, but not an infinite loop.
20:55:38 <mmorrow> i thought undefined was
20:55:42 <mmorrow> undefined = undefined
20:55:55 <mauke> http://okmij.org/ftp/Haskell/#making-function-strict
20:55:57 <Cale> This way you get a pattern match failure.
20:56:18 <Cale> Yeah, it's good for that sort of thing too.
20:56:31 <mmorrow> i've heard people say they like the "undefined = undefined" way more because it was more "instructive" :)
20:56:38 <Cale> Though not usually necessary now that we have bang patterns.
20:56:54 <mauke> __ = __  -- to quote oleg again
20:57:12 <mmorrow> um
20:57:12 <ivanm> mmorrow: though doesn't ghc define it as an error?
20:57:18 <mmorrow> ivanm: yes
20:57:36 <Berengal> @src undefined
20:57:37 <lambdabot> undefined =  error "Prelude.undefined"
20:57:37 <mmorrow> oh, no
20:57:40 <mmorrow> err,m yeah
20:57:48 <mmorrow> which itself is UserError or something
20:57:51 <hatds> which is, of course, more useful :)
20:57:53 <ivanm> so that strictness tricks evaluates everything, but because the actual value is False, it never returns undefined?
20:58:12 <fracture> hmm.. so in an imperative language, I could add some of these Boards to a map and look them up to see if I've called the function with exactly that before
20:58:15 <fracture> any similar trick in this?
20:58:17 <Berengal> ivanm: Well, as long as none of the arguments being forced are undefined
20:58:23 <fracture> or should I just pipe stderr to some file and use perl :)  (hah)
20:58:51 <fracture> (they are too large to really verify by hand)
20:59:29 <fracture> seems like that concept doesn't really carry over here...
20:59:37 <mauke> memoizing?
20:59:43 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
20:59:46 <mmorrow> ivanm: (undefined used to be undefined = undefined from what i understand..)
20:59:48 <dmwit> (@fracture)
20:59:56 <ivanm> mmorrow: *nod*
21:00:03 <ivanm> except then it would never return anything?
21:00:03 <fracture> well, except in this situation memoizing to aid debugging (hah)
21:00:10 <mmorrow> ivanm: heh, exactly
21:00:15 <ivanm> and would cause your program to loop rather than return an error?
21:00:20 <mmorrow> yup
21:00:21 <ivanm> s/return/throw/
21:00:26 <mmorrow> "instructive" ;)
21:00:34 <fracture> yeah
21:00:34 <mmorrow> (for some value thereof)
21:02:32 <Berengal> I used to find it more instructive that errors and infinite loops were the "same"
21:06:09 <mmorrow> i'd find it amusing maybe the first time, then just get pissed :)
21:06:23 <mmorrow> (if undefined = undefined)
21:11:11 <mauke> <<loop>>
21:11:37 <mauke> you know, I have this esoteric language with no errors
21:11:47 <mauke> any sequence of characters is a valid program
21:11:58 <ray> you mean godel numbering?
21:12:13 <mauke> nothing as fancy as that
21:12:34 <mauke> any runtime problems (such as a jump to a non-existing label) are "reported" by falling into an infinite loop
21:12:49 <ray> that's not so esoteric
21:13:08 <mauke> well, it's some kind of bottom, but I didn't know that when I "designed" it
21:13:37 <ray> i should say, it doesn't sound too esoteric for #haskell
21:13:44 <mauke> it used to do that simply because I did a linear search over all instruction, wrapping back to the beginning
21:13:53 <mauke> +s
21:14:13 <mauke> (oh, and it didn't even read the program into memory, so it was a fgets() loop + rewind())
21:15:06 <ray> sounds like the paradigm of the future
21:16:04 <mauke> the new (completely rewritten) interpreter does create an in-memory representation of the program and detects some infinite loops, optimizing them to sleep() calls
21:16:44 <whoppix> awesome.
21:20:18 <sm>  ack.. gf phone call + a plumbing emergency
21:20:28 <ray> @quote infinitely
21:20:28 <lambdabot> Berengal says: [On infinitely fast computers] The OS probably has a failsafe built in: If a program is  running it's in an infinite loop and needs to be killed...
21:21:21 <sm> don't these people understand I am *debugging*
21:23:43 <inimino> mauke: interesting idea, I was thinking about total parsing, where every string is a valid parse
21:24:15 <inimino> mauke: I guess you could write a language to make APL look verbose
21:24:46 <mauke> http://home.cs.tum.edu/~mai/ploki/ploki-0.6.4/examples/calc.pk
21:25:46 <mmorrow> mauke: yeah true, i guess that'd just die with a <<loop>>
21:26:16 <inimino> heh
21:26:37 <mriou> I'm looking for pointers to implement a binary tree efficiently (mostly, not recreate the whole tree to change one leaf)
21:27:21 <mriou> is there anything I should look at?
21:27:30 <mauke> data Tree a = Leaf | Node a (Tree a) (Tree a)
21:27:39 <mmorrow> mriou: if you just replace a node, the whole tree won't be copied
21:28:07 <sjanssen> mriou: I recommend Okasaki's data structures book if you can get it from your local library
21:28:13 <mmorrow> mriou: since haskell uses graph reduction that falls out for free
21:28:40 <mriou> mmorrow that's sweet, didn't know that :)
21:29:30 <mriou> mauke: the only difference is that my tree has no node value
21:29:34 <mriou> just leaf values
21:30:24 <mriou> thanks for the pointer sjanssen
21:31:18 <hatds> data CallStack a = Return a | Push (Env -> CallStack a)  with:  (>>=) (Push g) f = Push $ \e -> g e >>= f
21:31:32 <hatds> heh, what do we think? :)
21:34:03 <mmorrow> hatds: how will you unwind though?
21:34:30 <mmorrow> (and recover the Envs you pass in to the Push functions)
21:34:30 <hatds> hm
21:34:37 <Cale> Hmm, is that a monad?
21:34:40 <hatds> I'm assuming Env isn't changed
21:34:43 <hatds> yea, I think so
21:35:44 <hatds> I think one can write a function CallStack a -> a, yea?
21:36:06 <Cale> Env -> CallStack a -> a, certainly
21:36:57 <hatds> I wonder if it is efficient
21:37:10 <mmorrow> i've used (data Cxt a b = Top a | Loc b (b -> Cxt a b)) before
21:37:36 <mmorrow> it seems like something is inside-out about that CallStack though (i can't quite put my finger on it though)
21:38:39 <mmorrow> actually, Cxt a = Top a | Loc a (a -> Cxt a) is easier to deal with
21:39:04 <mmorrow> (and you'd need a (into :: a -> Cxt a))
21:39:36 <hatds> into = return for the Cxt monad?
21:39:43 <bitfish> hi, i'm always getting this error while trying to `run` the following file: http://paste.pocoo.org/show/phVbwbCUssN1GIKItI3x/
21:39:58 <mmorrow> hmm, it's not quite return.. it'd be dependent on your particular 'a'
21:40:07 <bitfish> and the error: foo.hs:2:0: parse error (possibly incorrect indentation)
21:40:09 <mauke> bitfish: yeah, you can't do that
21:40:14 <mmorrow> and there'd probably be more than one into
21:40:15 <bitfish> any ideas what i'm doing wrong?
21:40:23 <bitfish> mauke: what do you mean?
21:40:26 <mmorrow> data T a = Tip a | T (T a) (T a)
21:40:26 <Cale> bitfish: .hs files should consist of declarations
21:40:36 <mauke> bitfish: you can't just put some statements in a .hs file
21:40:47 <Cale> bitfish: write something like
21:40:48 <bitfish> mauke: i can't?
21:40:59 <Cale> hw = "Hello, World!"
21:41:05 <Cale> main = print hw
21:41:17 <bitfish> okay
21:41:18 <Cale> (or putStrLn instead of print)
21:41:21 <mmorrow> left (Loc (T l r) k) = Loc l (\l -> k (T l r))
21:41:25 <mmorrow> right = ...
21:41:39 <mauke> main = do { let hw = "Hello, world!\n"; putStr hw; }
21:41:41 <mauke> :-)
21:41:47 <hatds> what's the monad instance for Cxt?
21:41:56 <mmorrow> err, i messed up the description of into..
21:42:03 <mmorrow> hatds: there isn't one
21:42:10 <mmorrow> (maybe there is, not sure)
21:42:12 <hatds> that's no fun then
21:42:18 <mmorrow> heh
21:42:20 <wahjava> hi
21:42:23 <hatds> I wanted something where return was like the C keyword
21:42:38 <mmorrow> which one? return?
21:42:43 <ray> sounds hard
21:42:49 <bitfish> mauke: heh, well, i'm a bloody newb to haskell, not to programming at all. its fun to learn a new language ;)
21:42:52 <hatds> here's the whole thing
21:42:58 <hatds> data CallStack a = Return a | Push (Env -> CallStack a)
21:43:00 <hatds> instance Monad CallStack
21:43:01 <hatds> 	return a = Return a
21:43:03 <hatds> 	(>>=) (Return a) f = f a
21:43:05 <hatds> 	(>>=) (Push g) f = Push $ \e -> g e >>= f
21:43:21 <Cale> Note that (Push g) >>= f = Push (g >=> f)
21:43:31 <wahjava> is there any 'trim' function in haskell library ? 'trim' is supposed to remove continuous occurence of a specific character at the start and end of the string.
21:43:49 <mauke> dropWhile
21:43:49 <hatds> nice, Cale
21:44:17 <SamB> why does the kleisli arrow look like a fish ?
21:44:24 <Cale> bitfish: The basic idea is that declarations go in a file, you load that in ghci and you can type expressions to evaluate them.
21:44:38 <mmorrow> so you're really using Return as a way to _call_ a function, and Push as a way to (in a sense) return
21:44:51 <bitfish> Cale: that sounds rather irritating
21:44:54 <Cale> bitfish: In a compiled program, you define an IO action value which says what to do when the program runs.
21:44:59 <mmorrow> (Return a >>= f to call a function)
21:45:05 <hatds> bitfish: think of a .hs structured more like a C file rather than a list of statements for ghci
21:45:14 <Cale> bitfish: It's not bad. Just keep two terminal windows open, one with your editor, and one with ghci
21:45:28 <bitfish> okay
21:45:29 <Cale> bitfish: When you edit the file, typing :r in ghci will reload it.
21:45:45 <Cale> and you can continue to test things
21:45:48 <mmorrow> hatds: i dunno, do you have an example of CallStack being used?
21:46:17 <hatds> this is potentially part of my mini-GUI library design
21:46:18 <SamB> or you could use a text editor that actually runs natively under your window system, like emacs ;-)
21:46:24 <rzezeski> can someone look at this paste and tell me if I'm tracing functions correctly... http://paste.lisp.org/display/81003
21:46:38 <hatds> and Env = Event
21:46:48 <mmorrow> hatds: or maybe i should say, what is CallStack's purpose?
21:46:53 <mmorrow> hmm
21:46:54 <wahjava> mauke, > dropWhile Data.Char.isSpace "   wahjava   "
21:47:03 <bitfish> SamB: i always use the KDE Kate editor (under GNOME) to edit files
21:47:12 <Cale> rzezeski: I would if paste.lisp.org resolved for me...
21:47:15 <bitfish> SamB: i'll think about that :P
21:47:17 <Cale> oh, there we go
21:47:21 <wahjava> mauke, that only removes spaces at beginning, what about removal of spaces at the end ?
21:47:32 <rzezeski> Cale: thx for looking Cale
21:47:33 <hatds> mmorrow: a GUI is a lot like f : Event -> IO (), but maybe I have two such functions f1 and f2 and I want to "switch over" to f2 after this event
21:47:35 <mauke> wahjava: reverse . dropWhile _ . reverse
21:47:39 <SamB> bitfish: that obviously also runs natively under your window system
21:47:42 <SamB> ;-)
21:47:48 <bitfish> i know, heh
21:47:48 <wahjava> mauke, okay. thanks :)
21:48:24 <Cale> rzezeski: You're a little off, it should be   foldl step (step 0 '9') "85"
21:49:03 <Cale> rzezeski: Also, it's the outermost step which evaluates first
21:49:16 <sm> argh.. what function converts 'a' and 'b' to "ab" ?
21:49:26 <mauke> \a b -> [a, b]
21:49:42 <sm> phew, thank you
21:50:11 <rzezeski> Cale: when you say outtermost step, do you mean after the foldl is done doing its thing?
21:50:19 <hatds> I guess 'return ()' is like poping the stack
21:50:51 <Cale> yeah
21:50:57 <Cale> the outermost call to 'step'
21:51:08 <rzezeski> Cale: I think you can annotate my paste, if you want to be a super nice guy :)
21:51:41 <Cale> rzezeski: I'm writing out a trace already :)
21:51:52 <rzezeski> Cale: thx, you tha man!
21:53:14 <rzezeski> Cale: BTW, the reason I did the innermost first is because I thought parens took precedence over a function precedence...I'm sure your trace will clear it up for me
21:53:38 <mauke> precedence is not evaluation order
21:54:29 <rzezeski> mauke: so what is evaluate first in this contrived example: fn1 (fn2 somarg2) somearg1
21:54:51 <mauke> fn1
21:55:00 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5366#a5366
21:55:11 <rzezeski> ahh, and that's where I have gone astray it seems
21:55:27 <Cale> oops, I doubled a line there
21:56:17 <Cale> I'll show how it goes with foldl'
21:57:20 <rzezeski> Cale: I see what you mean now, I think I have to re-read the RWH section about evaluation, apparently I still have it wrong
21:57:49 <copumpkin> how long until someone on-ups bos' pidigits entry?
21:58:35 <dmwit> In Haskell or at all?
21:58:37 <rzezeski> BTW, I like hpaste, it doesn't blow up like paste.lisp when I tell it to colorize for Haskell
21:58:51 <bos> copumpkin: i'd be thrilled if someone did
21:59:04 <copumpkin> bos: I meant in c :(
21:59:09 <mauke> http://www.spoj.pl/ranks/PIVAL/ ?
21:59:09 <sm> uniquenames = map (λa→[a]) "abcdefghijklmnopqrstuvwxyz" ++ (zipWith (++) uniquenames uniquenames)
21:59:27 <copumpkin> I wonder how parallelizable it is... it feels pretty sequential to me
21:59:34 <bos> copumpkin: i think that's probably not possible.
21:59:41 <sm> would someone have a nicer implementation ? I'd like eg 1000 or 10000 readable randomish similarish-length unique strings
22:00:49 <mauke> :t showIntAtBase
22:00:50 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
22:01:00 <hatds> unique strings or just random-y?
22:01:16 <mauke> > map (\n -> showIntAtBase 26 (['a' .. 'z'] !!) n "") [0 ..]
22:01:18 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
22:01:20 <dmwit> uniquenames = [1..] >>= \n -> replicateM n ['a'..'z'] >>= id
22:01:22 <sm> hatds: unique.. they don't have to be random
22:01:34 <mauke> >>= id is join
22:01:38 <dmwit> > do { n <- [1..]; s <- replicateM n ['a'..'z']; s }
22:01:40 <lambdabot>   "abcdefghijklmnopqrstuvwxyzaaabacadaeafagahaiajakalamanaoapaqarasatauavawax...
22:01:58 <dmwit> mauke: I know.  But then I'd have to prefix that, and it breaks the beauty of it.  Plus it's wrong.
22:02:00 <hatds> sm: fromEnum :: Int -> Char, now just get random nums?
22:02:02 <dmwit> > do { n <- [1..]; s <- replicateM n ['a'..'z'] }
22:02:04 <lambdabot>   <no location info>:
22:02:04 <lambdabot>      The last statement in a 'do' construct must be an ...
22:02:04 <dmwit> bah
22:02:08 <dmwit> > do { n <- [1..]; replicateM n ['a'..'z'] }
22:02:10 <lambdabot>   ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s...
22:02:16 <Cale> rzezeski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5366#a5367
22:02:34 <dmwit> :t [1..] >>= flip replicateM ['a'..'z']
22:02:35 <lambdabot> [[Char]]
22:02:43 <copumpkin> bos: I'm curious how limiting gmp's function boundaries are for this (i.e., if we had a pure haskell multiprecision lib almost as fast as GMP and good ways of fusing adjacent operations, whether we could do better)
22:03:16 <Cale> rzezeski: While it may look like more steps, it's mostly because I included steps for trivial things which are not really steps, like substituting let-bound things into expressions.
22:03:44 <Cale> (and eliminating seq when the variable is evaluated)
22:03:46 <jfredett_> do there exist Object-relational model database libraries for haskell? HDBC and HaskellDB both appear to be SQL executors.
22:04:09 <bos> copumpkin: i don't know for sure, but i'm dubious.
22:04:19 <jfredett_> or will I need to build one? :)
22:04:39 <Cale> jfredett_: What would the interface look like?
22:05:06 <sm> jfredett_: I think you will need to build it
22:05:54 <jfredett_> Cale: I don't know- I suppose one could hijack Data.Map and just have the fields be a autogenerated datatype based on the table info...
22:06:03 <Cale> Has anyone here tried HaskellDB lately?
22:06:11 <Cale> Is it still cool? :)
22:06:49 <jfredett_> Reason being, I'm trying to write a binding to an API/Database for EVE online, and I wanted to provide a consistent, mostly pure interface to the database (which houses worldmap and item info).
22:07:08 <rzezeski> Cale: Thx, you've been a big help, again!
22:07:16 <Cale> rzezeski: No problem :)
22:07:17 <jfredett_> and I thought about building a big record, but it's a _big_ record for even one or two tables, and it's somewhat unwieldy looking
22:08:23 <Cale> jfredett: You might want to look at the way that HaskellDB does things for inspiration
22:08:39 <Cale> jfredett: It takes a more functional approach than an object oriented one though
22:08:45 <jfredett> interesting
22:09:00 <jfredett> I'll have to take a peek
22:10:32 <Cale> I wonder if there's a good tutorial lying around... things have gotten more elaborate than last time I looked at it :)
22:10:36 <jfredett> see- ideally, I'd like to take the table definition and have it roll some datatype defs and accessor-y database quereys.
22:10:50 <jfredett> HDBC is lovely, very no nonsense.
22:11:19 <jfredett> not super featureful, but nice for hacking.
22:11:45 <Cale> HaskellDB's approach is that it provides you operators for writing queries such that the type of the result can be inferred.
22:12:08 <jfredett> featureful in the sense of doing lots of fancy things, as opposed to actual useful properties, of which there are many.
22:13:18 <jfredett> Cale: see, thats what I would want- a powerfully-typed database. I'm not well-versed in database-fu, but it seems that stronger type information could be useful in databases...
22:13:48 <Cale> http://www.cs.chalmers.se/~bringert/publ/haskelldb/haskelldb-db-2005.pdf
22:13:56 <Cale> Some intro slides :)
22:14:02 <jfredett> excellent
22:14:20 <ivanm> Cale: but is there some conc slides as well? :p
22:14:23 * jfredett sends to his kindle
22:14:31 <jfredett> huzzah.
22:16:51 <Cale> jfredett: HaskellDB is less of an Object Relational Mapper and more of a Relation Relational Mapper :)
22:17:29 <jfredett> hehe
22:17:30 <Cale> (That is, it gives you operations for directly manipulating the relations expressed in the database, and constructing new ones (which correspond to queries)
22:17:42 <Cale> )
22:17:45 <Cale> hehe
22:17:46 <ivanm> jfredett: what, reading it on your computer not good enough for you?
22:17:47 <ivanm> ;-)
22:18:00 <jfredett> ivanm: well, I'm not on my computer 24/7
22:18:17 <jfredett> Cale: I definitely like the static checking of queries.
22:18:18 <ivanm> but you're on your kindle 24/7?
22:18:20 <ivanm> :p
22:18:43 <jfredett> ivanm: well, the set of times I'm on my computer union the set of times I have my kindle available = 24/7
22:18:51 <ivanm> heh
22:18:57 <ray> `union`
22:19:04 <ivanm> though my initial point was because I figured you'd just read it _now_...
22:19:22 <jfredett> ivanm: I'll scan it, but it'll be nice to have on my kindle as well
22:19:35 * ivanm ponders ways in which a kindle can not be functioning whilst jfredett isn't on his computer...
22:19:42 <ivanm> batteries, etc.
22:19:49 <ivanm> thereby not making the union == 24/7 :p
22:19:59 <jfredett> I tag it, it gets sorted with all the other haskell stuff I have on there
22:20:11 <Nafai> I think I'd like a kindle
22:20:53 * ivanm thinks he'd like the money for a kindle, and then spend it on something more worth-while
22:21:04 <jfredett> Nafai: wait for the new one thats coming out soon, it's gonna have a better pdf reader
22:21:08 <jfredett> it might even remember math
22:21:14 <jfredett> err- render *
22:21:17 <ivanm> heh
22:21:20 <jfredett> too many conversations.... :/
22:21:35 <Gracenotes> I can remember math. sort of.
22:21:42 <ivanm> I've pondered getting an XO for a while just because unlike other netbooks, you can use it as an ebook reader
22:21:46 <Cale> Odd... the documentation for 'divide' is "Not in SQL92."
22:22:07 <Cale> http://hackage.haskell.org/packages/archive/haskelldb/0.12/doc/html/Database-HaskellDB.html#v%3Adivide
22:22:14 <ivanm> Cale: as in the official documentation? or the hDB documentation?
22:22:17 <ivanm> ahhh, the latter
22:22:25 * p_l was thinking of gettin iLliad or similar, as they are simply PDA's with ePaper display :D
22:22:41 <ivanm> p_l: never heard of iLliad
22:22:52 <jfredett> Cale: I imagine that a kind of Object-Functional Relational Model could be concieved -- purity + ORM could make things very interesting.
22:23:03 <ivanm> what's the significance of the capital for the second letter? to iMitate aPple? :p
22:23:12 <jfredett> that and a strongly typed database could be very cool.
22:23:46 <Cale> Hey, this lecture was apparently given by nibro... he's been around lately hasn't he?
22:24:09 <p_l> ivanm: I don't know.
22:24:10 <ivanm> @seen nibro
22:24:10 <lambdabot> I saw nibro leaving #haskell 5h 49m 36s ago, and .
22:24:20 <ivanm> Cale: he was around...
22:24:28 <ivanm> s/was/_was_/ ;-)
22:25:02 <jfredett> partially though, I'm just afraid I'm going to fall down the, "This is such an awesome idea, I should totally do this project too" rabbit hole, and pop out the other side with 1500 projects all stealing my time. :/
22:25:48 <Cale> It's too bad that we don't have a proper record system in Haskell. If we did, HaskellDB could be a good deal prettier.
22:25:52 <jfredett> Thats the problem with haskell, it makes too many awesome ideas possible, so I get stuck with too many projects... :/
22:25:56 <jfredett> Cale: I agree.
22:26:13 <Cale> Currently it has to cheat and use typeclass trickery to simulate proper records
22:26:35 <jfredett> then again, I would have never had this question (or set thereof) if it did, so perhaps it's a good thing.
22:26:44 <jfredett> got me thinking about interesting database stuff.
22:27:24 <ivanm> Cale: what would you call a "proper record system"?
22:27:58 <ivanm> the only real problem I have with the current one is that it's annoying doing foo {bar = succ (bar foo)}
22:27:59 <ivanm> :s
22:28:24 <jfredett> ivanm: dunno what Cale would say, but some kind of namespacing so that I could have data Foo = Foo {bar :: Int} and data Fuz = Fuz {bar :: String}
22:28:31 <Cale> Well, the existing record syntax is a syntax for algebraic types which is different than what I'm thinking of
22:28:32 <jfredett> without having a type error...
22:28:53 <ivanm> jfredett: well, that can be argued both ways, since bar :: Foo -> Int and bar :: Fuz -> String
22:29:29 <Cale> What I'm thinking of is extensible records with named/typed fields that are part of the record type, along with row polymorphism, and various operations on row types
22:29:44 <ivanm> Cale: example?
22:29:52 <ivanm> (so I know wtf you mean :p )
22:30:44 <Cale> So you could have a function... raise :: Integer -> { 'salary :: Integer | row } -> { 'salary :: Integer | row }
22:31:03 <jfredett> ... wuuuuhhh?
22:31:04 <Cale> Which would operate on any record type having a 'salary field.
22:31:09 <jfredett> ooh
22:31:10 <Cale> (of type integer)
22:31:10 <jfredett> interesting.
22:31:31 <Cale> Regardless of what other fields were in there.
22:31:53 <ivanm> Cale: how does one define a 'salary field? the prime at the beginning denoting shared or something?
22:31:58 <ivanm> and what does | row mean?
22:32:14 <Cale> row is a variable representing the remainder of the fields in the record
22:32:26 <Cale> So this expresses that it doesn't affect those
22:32:49 <ivanm> and in the type sig, it means it's allowed to have other fields?
22:32:56 <Cale> yes
22:33:50 <Cale> These labels, distinguished by the fact that they start with ' and are not Char values, occur at both the value and type level.
22:33:53 <jfredett> why would you need the | row at all then? if you have a record with one field -- I mean, it just seems pointless... :/
22:34:01 <Cale> and there would be various operations...
22:34:22 <ivanm> Cale: "and are not Char values" <-- hmmm?
22:34:32 <Cale> get 'salary rec :: { 'salary :: t | row } -> t
22:34:43 <Cale> Well, 'a' :: Char
22:34:50 <ivanm> ahhh, no closing quote
22:34:52 <Cale> right
22:35:03 <ivanm> jfredett: I guess it's the same as having a catch-all _ case in pattern matching
22:35:33 <Cale> jfredett: In order to express where the rows move around when you have lots of records floating about
22:35:36 <jfredett> but- i guess I'm trying to say- is there ever a case where you _wouldn't have the remainder there?
22:35:51 <Cale> There would presumably be operations like record concatenation
22:35:59 <mmorrow> hatds: i was trying to figure out how to use CallStack and came up with this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5368#a5368
22:36:18 <Cale> jfredett: Yes, if you wanted to ensure there were no other fields.
22:36:18 <jfredett> sure- but the `| row` doesn't appear to indicate ordering at all.
22:36:44 <mmorrow> hatds: i'm still confused though about whether or not it's useful, because i can't figure out how to use it
22:36:46 <Cale> Only the fields with the same name and type have an ordering (and act like a stack)
22:36:54 <Cale> Otherwise, the fields are unordered.
22:37:28 <hatds> mmorrow: reading your hpaste... but yea I'm having trouble since the place I wanted to use it needs to be able to perform IO
22:37:45 <mmorrow> hatds: ooh, i was thinking about that, you could:
22:37:53 <Cale> The stacklike behaviour may seem strange, but it means that you never have to worry about whether a record already has a field which you want to extend it with
22:38:40 <Cale> (Some records systems require your types to contain predicates that some record lacks a given field, which seem more unnatural.)
22:38:58 <hatds> mmorrow: actually I think I can modify my example to not use IO and it would still be 'useful', I can hpaste that for you
22:39:14 <Cale> You'd have operations...
22:40:05 <Cale> get :: (l :: Label) -> { l :: t | r } -> t
22:40:15 <Cale> delete :: (l :: Label) -> { l :: t | r } -> { r }
22:40:40 <Cale> extend :: (l :: Label) -> t -> { r } -> { l :: t | r }
22:41:02 <mmorrow> hatds: arg, i was just trying to add a monad to it, but the Push (>>=) case is giving me trouble
22:41:16 <Cale> put :: (l :: Label) -> t -> { l :: t | r } -> { l :: t | r }
22:41:19 <mmorrow> hatds: cool, yeah
22:41:33 <jfredett> wouldn't it be just put :: Label -> blahblah...
22:41:38 <jfredett> rather than (l :: Label) ?
22:41:45 <Cale> Label is the *kind* of l
22:41:55 <jfredett> ...
22:42:19 <jfredett> so- thats kind of like... dependent types? Kindof?
22:42:24 <Cale> l is something at the type level, which is like a type having exactly one value with the same name, and you don't have to declare it
22:42:33 <jfredett> interesting.
22:42:41 <Cale> Similarly, the kind of r would be Row
22:42:58 <sjanssen> Cale: "l :: Label" is a bit confusing as far as syntax
22:43:02 <Cale> It wouldn't do for r to be something like Integer :)
22:43:19 <Cale> Well, the kind could be inferred there
22:43:28 <Cale> I was just being explicit
22:43:35 <sjanssen> oh, it's a kind annotation.  Makes a bit more sense when you think of that
22:43:47 <jfredett> Sure, but do you really need a full type? I imagine all of this -- all of it could sit at the type level...
22:43:56 <jfredett> I just don't see the need... :/
22:44:21 <Cale> Well, you have these things called labels which are like type-level values, so they should belong to a kind
22:44:25 <nimred> wich way can i uninstall a package using cabal ?
22:44:42 <Cale> You could just allow any type to act as a label, but that might be weird.
22:44:57 <sjanssen> nimred: you can't actually uninstall.  You can make GHC forget it exists with 'ghc-pkg unregister foo'
22:45:11 <Cale> and it would require you to declare all your label-types by hand
22:45:25 <Cale> (might be a good thing, but I think we can do without it)
22:45:37 <jfredett> no- I mean- maybe I'm thinking to lispily, but have a datatype "label" which is a wrapper on string
22:45:55 <jfredett> put (label "foo") ...
22:45:56 <Cale> Oh, but Strings aren't available at compile time.
22:46:03 <jfredett> ooh.
22:46:06 <Cale> This is still statically checked.
22:46:12 <jfredett> you are correct...
22:46:27 <nimred> sjanssen and what about reinstall ?
22:46:28 <sjanssen> Cale: the system you're describing is in some paper, who wrote it?
22:46:38 <jfredett> sjanssen: good point.
22:46:43 <sjanssen> nimred: reinstall is just installing it again
22:47:43 <Cale> sjanssen: It's roughly the system which Daan Leijen described, but with minor changes in syntax
22:48:45 <sjanssen> http://research.microsoft.com/en-us/um/people/daan/download/papers/scopedlabels.pdf
22:48:50 <Cale> yeah
22:49:16 <jfredett> excellent, more for the kindle. :)
22:49:31 <Cale> He actually describes two similar but subtly different record systems in his two papers, but I haven't really made up my mind which I like better.
22:50:04 <sjanssen> Cale: oh, interesting.  I don't remember which I read
22:50:35 <nimred> sjanssen ok thx
22:50:43 <Cale> Also, while I like my 'lens-like' syntax idea, it's possible that a more general syntax for constructing records all at once is needed.
22:50:58 <Cale> I really just don't like the use of . for field selection.
22:51:30 <sjanssen> yeah, . is already overoverloaded
22:51:52 <Cale> (If it had been me, we would have | for the module path separator)
22:53:08 <sjanssen> interesting, Leijen's system also gives us variants
22:53:13 <Cale> yes
22:55:50 <Cale> Oh, actually, his first paper uses lacks predicates, which I don't care for so much.
22:56:02 <hatds> mmorrow: hmm, I see a problem
22:56:27 <jfredett> which paper am I reading here, it's the one sjanssen linked.
22:56:36 <hatds> mmorrow: the way I intended to use this was with a function that takes an Event and runs the top thing on the call stack
22:56:41 <Cale> You're reading the one which is closer to what I like then :)
22:57:07 <cads> > :t curry
22:57:08 <hatds> mmorrow: but you can't turn a "Return a" into a new, pop'ed callstack
22:57:09 <lambdabot>   <no location info>: parse error on input `:'
22:57:19 <jfredett> okay, I'll happily follow along which your opinion, as it is most certainly better informed than mine. :)
22:57:29 <hatds> mmorrow: I'll hpaste this to show you how I was envisioning of using it
23:00:21 <sohum> so, I have a query. Could the compiler, when it notices that a function call doesn't typecheck, attempt to apply the appropriate liftM to the function, and accept that if it does typecheck?
23:00:52 <ivanm> I doubt it
23:00:56 <Cale> sohum: that would be confusing to do, but it could be done.
23:01:10 <Cale> I wouldn't want it :)
23:01:30 <ski> a type error isn't necessarily located to one place in the source
23:01:35 <sohum> no? it seems as if that would simplify but only to the level of sugar writing monadic code
23:03:08 <hatds> mmorrow: now if only I can get my hpaste to typecheck.. one sec :)
23:03:20 <Cale> Well, blurring the lines between lifted and unlifted operations might seem like it would be convenient, but I think it makes the cases where both versions would typecheck a good bit more confusing...
23:03:52 <Cale> You have to reason that something won't typecheck in order for the lifting to be there...
23:04:40 <sohum> are there cases where both versions would typecheck?
23:04:44 <Cale> yeah
23:05:08 <sohum> oh, hm, I suppose there could be through typeclasses and such
23:05:23 <Cale> > sequence [[[1,2,3], [4,5]], [[6,7,8], [9,10]]]
23:05:25 <lambdabot>   [[[1,2,3],[6,7,8]],[[1,2,3],[9,10]],[[4,5],[6,7,8]],[[4,5],[9,10]]]
23:05:30 <Cale> > liftM sequence [[[1,2,3], [4,5]], [[6,7,8], [9,10]]]
23:05:32 <lambdabot>   [[[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]],[[6,9],[6,10],[7,9],[7,10],[8,9],[8,...
23:06:07 <Cale> (perhaps not too realistic an example, but probably more common ones exist too :)
23:06:17 <Cale> Basically, anywhere that you have enough polymorphism
23:06:41 <sohum> right
23:06:45 <cads> for the type of curry, as defined by wikipedia :P, we have ::((A x B) -> C) -> (A -> (B -> C)). Knowing curry we see that that our curried function will take a value in A and return a partially applied function that takes a remaining value in C, and this is where I'm confused, the result seems to be a value in C, which doesn't give any insight into how curry worked for functions with more than two arguments
23:07:05 <Cale> in B
23:07:05 <cads> how do we write the type of the curry function in general?
23:07:19 <Cale> curry f x y = f (x,y)
23:07:28 <Cale> er
23:07:34 <Cale> the type of it?
23:07:38 <Cale> :t curry
23:07:40 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:07:55 <cads> cale, yeah, the first "in C" should be "in B"
23:08:19 <Cale> Currying functions of more arguments extends like...
23:08:27 <sohum> huh, the haskell curry function splits apart pairs
23:08:29 <sohum> cool.
23:08:33 <Cale> :t let curry3 f x y z = f (x,y,z) in curry3
23:08:34 <lambdabot> forall t t1 t2 t3. ((t, t1, t2) -> t3) -> t -> t1 -> t2 -> t3
23:08:51 <cads> > (curry (/ x y z q -> (sum x y z q))) 1 2 3)
23:08:53 <lambdabot>   <no location info>: parse error on input `->'
23:08:54 <cads> ack
23:09:01 <sohum> lisp!
23:09:04 <cads> > ((curry (/ x y z q -> (sum x y z q))) 1 2 3) 4)
23:09:05 <lambdabot>   <no location info>: parse error on input `->'
23:09:10 <Cale> \
23:09:17 <cads> noooo, I'm forgetting haskell!!!!!
23:09:24 <Cale> > ((curry (\x y z q -> (sum x y z q))) 1 2 3) 4)
23:09:25 <lambdabot>   <no location info>: parse error on input `)'
23:09:29 <cads> sohum, your accusation was right!
23:09:35 <cads> > ((curry (\ x y z q -> (sum x y z q))) 1 2 3) 4)
23:09:36 <cads> lemme
23:09:36 <lambdabot>   <no location info>: parse error on input `)'
23:09:44 <cads> > ((curry (\ x y z q -> (sum x y z q))) 1 2 3) 4
23:09:46 <lambdabot>   Couldn't match expected type `[a]' against inferred type `(a1, b)'
23:09:47 <sohum> twas not an accusation, my good man, but recognition!
23:09:47 <Cale> I don't know which bracketing you want :)
23:09:48 <hatds> mmorrow: okay http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5368#a5369
23:09:49 <dmwit> > curry (\x y z q -> sum [x, y, z, q]) (1, 2) 3 4
23:09:51 <lambdabot>   Overlapping instances for GHC.Show.Show
23:09:51 <lambdabot>                              (((t, ...
23:09:55 <dmwit> :t curry
23:09:57 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
23:10:10 <hatds> mmorrow: gonna go back to reading yours for the moment
23:10:11 <dmwit> > curry (\(x, y) z q -> sum [x, y, z, q]) 1 2 3 4
23:10:12 <lambdabot>   10
23:10:47 <Cale> > (curry . curry) (\((x,y),z) q -> sum [x,y,z,q]) 1 2 3 4
23:10:48 <lambdabot>   10
23:10:58 <Cale> > (curry . curry . curry) (\(((x,y),z),q) -> sum [x,y,z,q]) 1 2 3 4
23:11:00 <lambdabot>   10
23:11:12 <dmwit> Also, q?
23:11:18 <dmwit> How about w x y z instead. =P
23:11:31 <cads> hey man, it's late
23:11:46 <cads> this bugs me, I always thought curry could do
23:12:13 <cads> > (((curry (\ (x, y, z, q) -> sum [x y z q])) 1) 2 3) 4
23:12:14 <lambdabot>   Couldn't match expected type `(a, b)'
23:12:17 <Cale> nope
23:12:20 <dmwit> :t curry4
23:12:22 <lambdabot> Not in scope: `curry4'
23:12:28 <cads> haha
23:12:30 <cads> really?
23:12:33 <dmwit> nope
23:12:40 <Cale> @let curry4 f w x y z = f (w,x,y,z)
23:12:43 <lambdabot>  Defined.
23:12:55 <Cale> > curry4 (\ (x, y, z, q) -> sum [x y z q]) 1 2 3 4
23:12:57 <lambdabot>   Add a type signature
23:13:01 <dmwit> commas
23:13:15 <Cale> > curry4 (\ (x, y, z, q) -> sum [x, y, z, q]) 1 2 3 4
23:13:17 <lambdabot>   10
23:13:20 <dmwit> > curry4 (\(w, x, y, z) -> sum [w x y z]) id id id 4
23:13:22 <lambdabot>   4
23:13:26 <Cale> haha
23:13:37 <Cale> good call
23:13:41 <cads> aw well, they curry function I've been playing with in my head was a bit muddled because I didn't think about tuples
23:14:05 <Cale> Tuples are all separate types in Haskell, so there's no one curry function which will handle them all
23:14:25 <cads> I think it's stronger that normal curry, but its type depends on the function you give it
23:14:37 <Cale> normal curry?
23:14:50 <cads> yeah, that weak stuff you buy in packets
23:14:54 <Cale> hehe
23:15:00 <cads> this curry will blow your socks off
23:15:09 <Cale> and then there's uncurry
23:15:19 <Cale> uncurry is to pairs what foldr is to lists
23:15:32 <sohum> :t uncurry
23:15:33 <cads> :type uncurry
23:15:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
23:15:39 <Cale> > uncurry (\x y -> x + y) (3,5)
23:15:41 <lambdabot>   8
23:15:49 <cads> yeah, I like uncurry
23:16:15 <Cale> maybe is another one of this family of functions
23:16:18 <Cale> :t maybe
23:16:20 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:16:25 <cads> man, functional programming without the type system there to show you what you did is tough
23:16:36 <Cale> :t either
23:16:38 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
23:16:48 <Cale> :t foldr
23:16:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:17:16 <Cale> The similarity here is that they take a parameter which serves as a replacement for each of the constructors of the datatype
23:17:26 <Cale> and a value of that type
23:17:34 <Cale> and make the replacements throughout
23:17:53 <Gracenotes> lthough, list is a recursive datatype.
23:17:54 <Gracenotes> a
23:17:57 <Cale> right
23:18:02 <sohum> incidentally
23:18:07 <sohum> is there a List typeclass?
23:18:09 <Gracenotes> so why foldr and not foldl? Because foldr folds "along" a list?
23:18:23 <hatds> mmorrow: yea, I think it needs to be a list-like structure,  but maybe Push isn't the only cons operator, what if Return is also cons-like?
23:18:26 <sohum> that say : and the [x:xs] destructuring is defined in terms of?
23:18:34 <Gracenotes> whereas foldl just takes an accumulator as you go
23:19:00 <Cale> Gracenotes: foldl does a more complicated structural transformation
23:19:04 <Cale> I have some diagrams...
23:19:10 <Gracenotes> yeah :)
23:19:12 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
23:19:19 * Gracenotes has it bookmarked
23:19:26 <Gracenotes> I see
23:19:28 <ray> wikipedia has about half those diagrams
23:19:36 <ray> er, not half
23:19:48 <Cale> Right, I wrote 90% of the wikipedia article on folds
23:20:08 <ray> i figured you either wrote or rewrote it when i saw those
23:20:34 <Cale> Well, what was there before was almost complete garbage, so I rewrote it.
23:21:35 <sohum> hahaha, nice
23:21:40 <sohum> crowdsourcing fte)
23:21:44 <sohum> *ftw
23:21:48 <Gracenotes> it probably helps to have a CT understand of folds
23:22:07 <Gracenotes> they are everywhere. even in set theory, you have k-folds via union/intersection...
23:22:12 <cads> forgetting about laziness, there's a difference between a left and right fold only iff the function you're folding the list over does not commute, right?
23:22:24 <Cale> Oh, there's a new language comparison table there :)
23:22:44 <cads> Gracenotes: even a union is a fold?
23:23:02 <Gracenotes> I think you could consider a big union a fold of unions
23:23:13 <cads> certainly
23:23:17 <ray> they're different if it doesn't commute, but i'm not sure about iff
23:23:36 <cads> no it's not iff, sorry
23:24:00 <cads> they can be the same even if f doesn't commute in general
23:24:22 <Gracenotes> I'm pretty sure associative is required though, hmm?
23:24:42 <Gracenotes> I've wondered about the class of operators for which left fold == right fold...
23:24:51 <cads> it just has to have the right type
23:25:26 <Gracenotes> if foldl f z xs compiles, foldr (flip f) z xs will compile. so type isn't so hard...
23:26:03 <copumpkin> commutative?
23:26:13 <copumpkin> if you want foldl to equal foldr?
23:26:15 <dmwit> > foldr f z [x, y, z]
23:26:17 <lambdabot>   Ambiguous occurrence `f'
23:26:17 <lambdabot>  It could refer to either `L.f', defined at <local...
23:26:25 <dmwit> > foldr g z [x, y, z]
23:26:27 <lambdabot>   Ambiguous occurrence `g'
23:26:27 <lambdabot>  It could refer to either `L.g', defined at <local...
23:26:31 <dmwit> booo
23:26:36 <copumpkin> @undefine
23:26:41 <dmwit> > foldr f z [x, y, z]
23:26:43 <lambdabot>   f x (f y (f z z))
23:26:47 <dmwit> > foldl (flip f) z [x, y, z]
23:26:48 <lambdabot>   f z (f y (f x z))
23:26:59 <copumpkin> zomg noes
23:26:59 <Gracenotes> copumpkin: for all input, yes
23:27:03 <dmwit> Oh, let's try that again, with less z's this time.
23:27:07 <Gracenotes> finite input, let's say, to keep it simple
23:27:20 <dmwit> > (foldr f z [w, x, y], foldl (flip f) z [w, x, y])
23:27:22 <lambdabot>   (f w (f x (f y z)),f y (f x (f w z)))
23:27:30 <Gracenotes> works for (+) for instance
23:27:45 <dmwit> Looks like it has to be at least commutative.
23:28:04 <Gracenotes> there may be non-commutative though. I'm not quite sure :)
23:28:13 <copumpkin> well since it's going in the opposite "direction"
23:28:26 <copumpkin> it's going to take a lot of "commutation" to get it back into the right direction :)
23:28:31 <dmwit> > (foldr f z [x, y], foldl (flip f) [x, y])
23:28:33 <copumpkin> seems like that's all that's needed though
23:28:33 <lambdabot>   No instance for (SimpleReflect.FromExpr [SimpleReflect.Expr])
23:28:33 <lambdabot>    arising fr...
23:28:38 <cads> I think it needs to be associative as well. Given the commutativity, it seems like if foldl f a = foldr f a, f::a->a->a
23:28:38 <dmwit> > (foldr f z [x, y], foldl (flip f) z [x, y])
23:28:40 <lambdabot>   (f x (f y z),f y (f x z))
23:29:08 <copumpkin> oh yeah, I meant in addition to the associativity that Gracenotes mentioned earlier
23:29:14 <dmwit> Gracenotes: Well, if the function has any fixed-point, the above proves that it must also be commutative for left- and right-folds to be equal.
23:29:38 <Gracenotes> a fix-point? on two parameters?
23:29:50 <dmwit> duh, I mean identity
23:29:50 <copumpkin> > foldr (+) 0 (replicate 1000 0.01)
23:29:52 <lambdabot>   9.999999999999831
23:29:55 <copumpkin> > foldl (+) 0 (replicate 1000 0.01)
23:29:57 <lambdabot>   9.999999999999831
23:30:10 <copumpkin> not associative?
23:30:23 <Gracenotes> hm
23:30:31 <copumpkin> not sure that counts as a proof though ;)
23:30:34 <Gracenotes> someone needs to write a proof or something! not it.
23:30:56 <Gracenotes> I'll see if there's anything online...
23:31:10 <dmwit> copumpkin: If it's not commutative, there is x and y such that f x y /= f y x.  Taking z to be the identity, then f x (f y z) /= f y (f x z). QED
23:31:25 <copumpkin> hmm?
23:31:31 <copumpkin> I wasn't questioning the commutativity
23:31:34 <dmwit> oh
23:31:35 <dmwit> heh
23:31:39 <copumpkin> the associativity though?
23:32:00 <copumpkin> I don't think it needs it
23:32:04 <dmwit> Yeah, I'm not sure I see where associativity comes in, either.
23:32:47 <dmwit> Quick!  Somebody think of a function that's commutative but not associative.
23:32:57 <copumpkin> floating point addition :P
23:33:33 <dmwit> prove it
23:33:42 <dmwit> No, don't bother.
23:33:48 <dmwit> It's not helpful the way I thought it would be.
23:34:10 <Cale> Floating point addition is not associative
23:34:14 <dmwit> I know.
23:34:22 <Gracenotes> I saw this: http://portal.acm.org/citation.cfm?id=156301.156303
23:34:28 <dmwit> I was just asking for a specific example that shows off that fact. =)
23:34:31 <copumpkin> @check \x y z -> (x + y) + z == (x :: Float) + (y + z)
23:34:32 <Gracenotes> "when floating-point addition isn't commutative"
23:34:32 <lambdabot>   "Falsifiable, after 11 tests:\n-1.6\n1.8\n4.5\n"
23:34:53 <Gracenotes> unfortunately it's ACM, so... *arghhhhhhh darn you ACM*
23:35:05 <copumpkin> you don't have access?
23:35:08 <Cale> Oh, when foldr f z and foldl f z are equal? Well, a sufficient condition is for f and z to give a monoid.
23:35:24 <copumpkin> really?
23:35:26 <copumpkin> hmm
23:35:27 <Cale> yes
23:35:28 <Gracenotes> Cale: iff?
23:35:28 <dmwit> Yeah, but that's too much.
23:35:36 <dmwit> Because monoids are associative.
23:35:40 <Cale> Obviously it's not a necessary condition.
23:35:45 <dmwit> I don't think associativity is necessary.
23:35:48 <Cale> Associativity is important.
23:35:54 <dmwit> oh?
23:36:05 <Gracenotes> and there's also: foldr f z vs. foldl (flip f) z, which allows list type != accumulator type in comparison
23:36:06 <Cale> That's most of the difference between the two
23:36:21 <Cale> The only other difference is that they put the z on opposite ends
23:36:49 <dmwit> Wait, hold up a tick: are we comparing foldr f and foldl f, or foldr f and foldl (flip f)?
23:36:54 <Cale> But I don't think there's a nice necessary+sufficient condition.
23:37:02 <dmwit> For the former, I could believe associativity matters; for the latter, not so much.
23:37:12 <Cale> foldr f z and foldl f z
23:37:23 <Gracenotes> > (foldl (-) 0 [1..100], foldr subtract 0 [1..100])
23:37:25 <lambdabot>   (-5050,-5050)
23:37:28 <Cale> foldl (flip f) z is like foldr f z . reverse
23:37:47 <Gracenotes> Cale: yes...
23:38:09 <Gracenotes> hm. So if f is commutative, that might be an easier condition...
23:38:15 <Cale> wait...
23:38:23 <Cale> > foldl (flip f) z [1,2,3,4,5]
23:38:25 <lambdabot>   f 5 (f 4 (f 3 (f 2 (f 1 z))))
23:38:37 <Cale> right, yes
23:39:06 <Cale> But for the other way, f being commutative doesn't help.
23:39:24 <Cale> hmm
23:40:58 <mmorrow> , foldr (.) id [f,f,f,f] x
23:41:00 <lunabot>  f (f (f (f x)))
23:41:04 <mmorrow> , foldl (flip id) x [f,f,f,f]
23:41:06 <lunabot>  f (f (f (f x)))
23:41:19 <copumpkin> cheat0r
23:41:28 <mmorrow> z0mg
23:42:21 <dmwit> , foldr ($) x [f, f, f, f]
23:42:23 <lunabot>  f (f (f (f x)))
23:42:51 <dmwit> , iterate f x !! 4
23:42:54 <lunabot>  f (f (f (f x)))
23:43:18 <copumpkin> , f (f (f (f x)))
23:43:20 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
23:43:24 * copumpkin fails :)
23:43:29 <copumpkin> , f (f (f (f x))) :: Expr
23:43:31 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
23:43:38 * copumpkin fails again
23:43:56 <mmorrow> ah yeah, that's annoying
23:44:02 <mmorrow> , fix (h . g . f)
23:44:04 <lunabot>  luna: Ambiguous type variable `c' in the constraints:
23:44:09 <mmorrow> , fix ((h::Expr->Expr) . g . f)
23:44:10 <lunabot>  luna: Ambiguous type variable `b' in the constraints:
23:44:12 <copumpkin> failuna
23:44:15 <mmorrow> , fix ((h::Expr->Expr) . (g::Expr->Expr) . f)
23:44:17 <lunabot>  h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h (g (f (h...
23:44:36 <mmorrow> you can't have more than one 'f' (or whatever) "in a row"
23:44:41 <mmorrow> without an annotation
23:44:59 <Gracenotes> because FromExpr is just Expr a => (Expr -> a)
23:45:05 <mmorrow> i think it's for the same reason that (read . show) doesn't work
23:45:09 <mmorrow> yeah
23:45:18 <Gracenotes> er. s/Expr/FromExpr/g
23:45:40 <Gracenotes> actually, more general than I thought. (Show a, FromExpr b) => FromExpr (a -> b)
23:46:19 <mmorrow> @type [($),id]
23:46:20 <lambdabot> forall a b. [(a -> b) -> a -> b]
23:46:35 <Gracenotes> > f (Just "hello there") :: Expr
23:46:37 <lambdabot>   f (Just "hello there")
23:46:38 <mmorrow> foldr ($) === foldl (flip id)
23:47:01 <mmorrow> (at least wrt the result)
23:47:17 <mmorrow> err, s/result/type/
23:47:31 <cads> we have 1) (((a* + a) + b) + c).  I don't think we can we transform 2) ((a* + c) + b) + a) into 1) unless + is both assoc and commie. Using associativity lets us rewrite this as (a* + c + b + a). Using commutativity allows us to rewrite 2) to (a + (b + (a* + c))), but to break the a* out and bring it to the front, we need assoc
23:47:35 <mmorrow> (and foldr ($) = foldr id ;)
23:48:37 <mmorrow> the thing with fold direction too is (i've wondered how to say without hand-waving) that you usually (always?) want to fold in the direction of an op's fixity
23:48:50 <mmorrow> , src '(.)
23:48:53 <lunabot>  ) :: forall b c a . (b -> c) -> (a -> b) -> a -> c
23:48:53 <lunabot>  infixr 9 )
23:48:58 <mmorrow> :o
23:49:16 <Cale> > fix (\g -> (1:) . g) []
23:49:17 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:49:20 <mmorrow> infix infixr 5 ++
23:49:22 <Cale> > fix (\g -> g . (1:)) []
23:49:30 <lambdabot>   mueval-core: Prelude.read: no parse
23:49:30 <lambdabot>  mueval: ExitFailure 1
23:49:42 <dmwit> > fromExpr "hey" x
23:49:46 <lambdabot>   Not in scope: `fromExpr'
23:50:50 <mmorrow> hatds: hmm, i played with it a little more, but i feel like every time i write an expression that uses Push, the Pushes are just extraneous
23:50:52 <Cale> mmorrow: That's because people choose the fixity the same way they'd choose a fold, because a left fold produces a left-associated expression and a right fold produces a right associated one :)
23:51:01 <mmorrow> Cale: heh, good point
23:51:02 <cads> fixpoints are kind of ungodly powerful
23:51:15 <mmorrow> Cale: self-fulfilling prophecyish
23:52:21 <Gracenotes> > fun "Hello there" "person" :: Expr
23:52:23 <lambdabot>   Hello there "person"
23:52:37 <dmwit> cads: Yep, anything you can do with recursion...
23:53:59 <mmorrow> fix === a while(1), a single var, and the ability to break or continue..
23:55:14 <cads> dmwit, even elsewhere. For example the fixpoint theorem from metric spaces in analysis lets you do some sick stuff as far as proving the existance of solutions to some crazy integral equations and other things
23:55:30 <mmorrow> well, it's more i guess kinda
23:55:48 <mmorrow> , fix (\x -> Node () [x,x]) {- self-referent structures -}
23:55:49 <lunabot>  Node {rootLabel = (), subForest = [Node {rootLabel = (), subForest = [Nod...
23:56:20 <Gracenotes> mmorrow: hm... not so sure about that?
23:56:27 <mmorrow> void *xs[2]; xs[0] = xs; xs[1] = xs;
23:56:34 <cads> using fixed points and their properties we can write out a very nice computability theory, too
23:56:49 <mmorrow> Gracenotes: about what?
23:56:50 <Gracenotes> you can have recursive fib with fixpoint after all. It is really just recursion. not sure if it's general, but I woudln't be surprised...
23:58:49 <mmorrow> i don't understand
23:59:19 <mmorrow> int x[] = {0,1}; int tmp; while(1){printf("%d\n",x[0]); tmp = x[0]; x[0] = x[1]; x[1] += tmp;}
23:59:34 <mmorrow> , fix (\k m n -> m : k n (m+n)) 0 1
23:59:36 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
