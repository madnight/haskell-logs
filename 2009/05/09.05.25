00:01:18 <dmwit> Yes, I think there's a command to construct a minimal .cabal file.
00:01:19 <ski> @pl let i = id; k = return; s = ap in s (s (k s) (s (k k) (s (k s) (s (s (k s) (s (k k) i)) (k i))))) (k (s (s (k s) (s (k k) i)) (k i)))
00:01:22 <lambdabot> liftM2 ap (return `fmap` (ap `fmap` liftM2 ap (return `fmap` id) (return id))) (return (liftM2 ap (return `fmap` id) (return id)))
00:01:23 <dmwit> ...but I don't remember what it is.
00:01:50 <dmwit> :t liftM2 ap (return `fmap` (ap `fmap` liftM2 ap (return `fmap` id) (return id)))  (return (liftM2 ap (return `fmap` id) (return id)))
00:01:51 <lambdabot> forall b a b1. (a -> b1 -> b) -> (a -> b1) -> a -> b
00:01:54 <mmorrow> , randExp()
00:01:56 <lunabot>  luna: Not in scope: `randExp'
00:02:00 <mmorrow> , randE()
00:02:02 <lunabot>  x3 ((\ x26 (x10) (x6) (- 13) (11 :: (->)) _ -> x12) ([] :: ()))
00:02:05 <mmorrow> , randE()
00:02:08 <lunabot>  ()
00:02:09 <mmorrow> , randE()
00:02:12 <lunabot>  ()
00:02:13 <mmorrow> , randE()
00:02:16 <lunabot>  let { x0 (- 1) | "T" = x0} in x1
00:02:18 <mmorrow> wee
00:02:31 <ski> hehee
00:02:35 <ziman> haskell has deformed me; dividing a double by an int in Java feels weird now
00:02:40 <mmorrow> quickcheck + TH
00:02:52 <dmwit> ?pl \g f x -> g x (f x) -- ap?
00:02:52 <lambdabot> ap
00:03:06 <mmorrow> (stolen from andyjgill's hera pkg)
00:03:13 <dmwit> ski: Is that whole think just s?
00:03:20 <ski> dmwit : indeed :D
00:03:30 <dmwit> Nasty. =)
00:03:36 <ski> (it's the naive ski-conversion of `\f g x -> f x (g x)')
00:03:40 <mmorrow> @pl
00:03:41 <lambdabot> (line 1, column 1):
00:03:41 <lambdabot> unexpected end of input
00:03:41 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
00:03:55 <mmorrow> @pl \f g x -> f (g x) x
00:03:55 <lambdabot> flip flip id . liftM2
00:04:04 <mmorrow> S (?)
00:04:11 <mmorrow> iirc
00:04:22 <Peaker> @unpl flip flip id
00:04:22 <lambdabot> (\ c f -> c f (\ g -> g))
00:04:24 <ski> s . flip
00:04:27 <mmorrow> , [$ski|S[f][g][x]|]
00:04:30 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
00:04:37 <mmorrow> , [$ski|S[f][g][x]|] :: Expr
00:04:39 <lunabot>  luna: Ambiguous type variable `t' in the constraints:
00:04:57 <mmorrow> , [$ski|S[f::Expr->Expr->Expr][g::Expr->Expr][x::Expr]|]
00:05:00 <lunabot>  f x (g x)
00:05:02 <Gracenotes> eeks.
00:05:10 <mmorrow> ah, ap is S
00:05:27 <ski> @type [ap . flip,\f g x -> f (g x) x]
00:05:28 <lambdabot> forall a b b1. [(a -> b1 -> b) -> (b1 -> a) -> b1 -> b]
00:06:01 <dmwit> That doesn't mean they have the same type.
00:06:05 <dmwit> :t [($), id]
00:06:06 <ski> @type ap . flip
00:06:06 <lambdabot> forall a b. [(a -> b) -> a -> b]
00:06:07 <lambdabot> forall a b b1. (a -> b1 -> b) -> (b1 -> a) -> b1 -> b
00:06:10 <ski> @type \f g x -> f (g x) x
00:06:12 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
00:06:13 <Gracenotes> @type (=<<) `asTypeOf` (\f g x -> f (g x) x)
00:06:15 <lambdabot> forall a b t. (Monad ((->) t)) => (a -> t -> b) -> (t -> a) -> t -> b
00:06:23 <ski> dmwit : satisfied ?
00:06:24 <Gracenotes> (=<<)
00:06:24 <mmorrow> , [$ty| (\f g x -> [$ski|S[f][g][x]\|]) . flip |]
00:06:28 <lunabot>  forall a b c . (c -> b -> a) -> (b -> c) -> b -> a
00:06:34 <dmwit> ski: Oh, yeah.  I was satisfied before, too.
00:06:37 <Gracenotes> I consider =<< and ap opposites, in that sense
00:06:40 <dmwit> I was just being annoying. =)
00:07:27 <ski> (i figured since each type variable occured once covariantly, and once contravariantly (and there was no recursion involved), it'd be apparent that that was the most general type of both expressions)
00:07:30 <Gracenotes> although ap is rather theoretical, S, and =<< is just, hm, I guess ($) generalized to monads
00:07:55 <dmwit> ski: Ah, good point.  Cool!
00:08:50 <dmwit> Wait, no, that still doesn't mean anything, does it?
00:09:07 <dmwit> :t [ap . flip, undefined]
00:09:08 <lambdabot> forall a b b1. [(a -> b1 -> b) -> (b1 -> a) -> b1 -> b]
00:09:18 <ski> granted
00:09:36 <Gracenotes> >>=_>>=
00:10:51 <ski> @seen TheHunter
00:10:52 <lambdabot> I haven't seen TheHunter.
00:15:48 <dibblego> is there a toEnum that will return Maybe instead of error?
00:16:23 <Peaker> @type toEnum
00:16:24 <lambdabot> forall a. (Enum a) => Int -> a
00:16:28 <copumpkin> not that I know of
00:16:58 <copumpkin> those seem like cases where it should be safe to have an unsafePerformIO with something to catch the error
00:17:04 <Peaker> I wonder how Haskell would look if it actually had (/), head, and everything else that should be, inside a Maybe
00:17:08 <copumpkin> but in a recent discussion people said they weren't
00:17:24 <copumpkin> it seems odd to me
00:17:56 <Peaker> @type maxBound
00:17:58 <lambdabot> forall a. (Bounded a) => a
00:18:11 <Peaker> If you have (Bounded a, Enum a) you can test against fromEnum maxBound
00:18:12 <Gracenotes> at least the error-producing conditions for these functions are well known
00:18:43 <Gracenotes> should be the case for any error-producing functions, in theory
00:19:07 <copumpkin> someone could write their own Enum instance with invalid in-between cases :P
00:19:49 <Peaker> yay total languages
00:31:56 <Peaker> Is there a way to override: "Warning: The export item `module Text.Regex.DFA.String' exports nothing" in code (not compiler options)? Its used for instances only
00:33:24 <copumpkin> you stick () on its export list don't you?
00:33:28 <copumpkin> or is that only for imports
00:39:56 <Beelsebob1> I'm trying to get ghc-api to compile a module to a .o/.hi file given the module contents as a string (rather than the name of the file), anyone have any idea where I need to look in the docs?
00:41:06 <dmwit> Docs?  For GHC API?
00:41:27 <mmorrow> , flip (foldM (flip foldl)) [(*),(+)] 1 [1..4]
00:41:29 <lunabot>  34
00:41:32 <mmorrow> , flip (foldM (flip foldl)) [(+),(*)] 1 [1..4]
00:41:34 <lunabot>  264
00:42:11 <copumpkin> compileExpr :: GhcMonad m => String -> m HValue -- maybe?
00:42:16 <copumpkin> I have no clue, really :)
00:42:29 <copumpkin> that sounds kind of dynamic
00:43:01 <Beelsebob1> copumpkin: yeh, not quite right
00:43:05 <Beelsebob1> that compiles an expression
00:43:10 <copumpkin> oh, I see
00:43:16 <Beelsebob1> I need to compile a bunch of equations and some imports
00:43:19 <copumpkin> compileToCoreModule :: GhcMonad m => FilePath -> m CoreModule -- is the one you're talking about, along with compilecoretoObj ?
00:43:24 <copumpkin> that takes a filename
00:43:29 <mmorrow> Beelsebob: hmm, it's definitely doable, although i'm not sure how to do it using the ghc-api proper
00:43:42 <Beelsebob1> ohhhh... good call copumpkin â€“ the one that goes with that is usable
00:43:48 <Beelsebob1> I have an AST, not a string anyway
00:43:52 <Beelsebob1> so I can rewrite it into core
00:43:54 <copumpkin> that still takes a FilePath though
00:44:03 <Beelsebob1> and push it through compileCoreToObj
00:44:15 <copumpkin> ah, cool
00:44:19 <Beelsebob1> cheers muchly :D
00:44:42 * copumpkin is glad his cluelessness was helpful
00:45:45 <dmwit> Wow, the GHC API is big.
00:46:36 <cinimod> I've just install cabal head
00:46:49 <cinimod> dom@linux-6ofq:~/cabal_0> ghc-pkg list | grep abal
00:46:49 <cinimod>     Cabal-1.6.0.3, Cabal-1.7.0, HTTP-3001.1.5, HUnit-1.2.0.3,
00:47:07 <cinimod> I thought later versions of packages hid earlier versions
00:47:15 <dibblego> is Data.List.Split in the GHC stdlib?
00:47:17 <dmwit> Nope!
00:47:24 <copumpkin> dibblego: nope
00:47:31 <dibblego> ok
00:47:33 <copumpkin> I think it's byorgey's split package
00:47:35 <copumpkin> @hackage split
00:47:36 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
00:47:41 <dmwit> cinimod: Also, you can just "ghc-pkg list Cabal" in the future. ;-)
00:47:46 <dibblego> @hoogle [a] -> Int -> [[a]]
00:47:47 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
00:47:47 <lambdabot> Prelude drop :: Int -> [a] -> [a]
00:47:47 <lambdabot> Prelude take :: Int -> [a] -> [a]
00:48:42 <cinimod> dom@linux-6ofq:~/cabal_0> ghc-pkg latest Cabal
00:48:42 <cinimod> Cabal-1.7.0
00:49:03 <cinimod> dom@linux-6ofq:~/cabal_0> cabal --version
00:49:03 <cinimod> cabal-install version 0.6.1
00:49:03 <cinimod> using version 1.6.0.3 of the Cabal library
00:49:17 <paper_cc> cinimod: that's cabal-install, not Cabal
00:49:41 <paper_cc> cinimod: you probably want to rebuild cabal-install to use Cabal-1.7
00:49:43 <copumpkin> the naming for that is really unfortunate
00:49:46 <cinimod> I just realised that but it seems to use 1.6.0.3
00:49:53 <Saizan> cabal-install uses the stable version, i.e. 1.6.*
00:50:30 <copumpkin> I wonder if we'll still get people trying the netflix challenge now that it's been won
00:50:37 <Saizan> however in general you need to rebuild cabal-install if you want it to use a different Cabal version
00:51:06 <dmwit> copumpkin: It's been won?
00:51:17 <copumpkin> I thought it had
00:51:28 <dmwit> The leaderboard shows 9.71 improvement as the number one leader.
00:51:32 <copumpkin> oh I guess it hasn't
00:51:32 <dmwit> 9.71%, that is
00:51:38 <copumpkin> hmm, why did I think it had been won
00:51:50 <dmwit> You read that article about the guys who won the progress prize this year.
00:51:59 <copumpkin> probably :)
00:52:22 <copumpkin> anyway, I still wonder if anyone will keep playing with it after it's been won
00:52:51 <copumpkin> assuming it can be won
00:52:53 <copumpkin> :P
00:53:54 <cinimod> I did ghc-pkg hide Cabal-1.6.0.3
00:54:13 <cinimod> I'm sure Cabal used to hide old versions automatically
00:54:27 <Saizan> no, they were never hidden
00:54:51 <Saizan> but Cabal prefers the latest version of a package by default
00:54:53 * RayNbow wonders how hard it is to switch from community/xmonad to xmonad manually pulled from darcs...
00:55:04 <cinimod> Did the latest get used by default then?
00:55:18 <Saizan> it's still used by default.
00:55:31 <dmwit> RayNbow: There's xmonad-darcs in AUR.
00:55:33 <Saizan> unless there's a constraint saying otherwise
00:55:46 <Saizan> like in cabal-install's build-depends
00:56:34 <RayNbow> dmwit: I noticed... but I have no idea where yaourt would store the source files
00:57:16 <dmwit> RayNbow: yaourt is not the only way to use AUR. ;-)
00:57:48 <dmwit> RayNbow: (Anyway, yaourt stores them in /tmp/yaourt-RayNbow-somethingweirdhere/)
00:58:19 <dmwit> sorry, /tmp/yaourt-tmp-RayNbow
00:58:27 <dmwit> In any case, not somewhere permanent enough to be useful.
00:58:43 <RayNbow> /tmp is the most dangerous place on a computer :p
00:58:55 <RayNbow> I envy the courage of the bits that live there
00:59:41 <mmorrow> /dev/fb is worse
00:59:54 <RayNbow> :p
01:00:06 <dibblego> > "abc" `intersperse ' '` "def"
01:00:07 <lambdabot>   <no location info>: parse error on input `''
01:00:11 <dibblego> > "abc" `intersperse " "` "def"
01:00:12 <lambdabot>   <no location info>: parse error on input `"'
01:00:38 <dibblego> blah
01:01:02 <Neut> Can someone help me debug this please,
01:01:03 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2475#a2475
01:01:07 <dmwit> Only plain identifiers can go in backticks.
01:01:44 <Saizan> Neut: what's the problem?
01:01:47 <RayNbow> dmwit: but for development purposes, would you also recommend using AUR?
01:01:48 <dmwit> Neut: Topping is a type, not a value.
01:02:00 <dmwit> RayNbow: Sure, why not?
01:02:21 <Neut> dmwit: How do I overcome this?
01:02:57 <dmwit> Use an actual pattern instead of a type. ;-)
01:03:28 <Botje> Neut: don't use [Topping] to match topping
01:03:36 <dmwit> Also, your equations for "topping" have differing numbers of patterns, so I'm sure GHC is going to holler about that.
01:03:47 <Botje> do something like topping (Pizza toppings price) = toppings
01:04:05 <Botje> that way, the [Topping] part of Pizza is bound to toppings and the Price to price
01:04:15 <RayNbow> dmwit: I have no idea how :p
01:04:33 <dmwit> RayNbow: Ask in #archlinux, they'll tell you.
01:04:40 <dmwit> RayNbow: In short, "man abs". =)
01:04:51 <Botje> Neut: oh, and (== Pizza _ _) is wrong too
01:05:14 <Botje> I think you need to re-read the chapter on pattern matching
01:05:39 <Botje> and now i'm off to deliver some goodies! g'bye!
01:05:44 * Neut cries
01:06:51 <Neut> dmwit: what do you mean by use an actual pattern instead of a type?
01:07:02 <Botje> [Topping] is not a correct pattern
01:07:22 <Botje> [topping] is, but that only matches lists of one element
01:08:13 <Neut> oh kay
01:08:23 <Neut> why is ghci complaining about the _'s?
01:08:40 <Botje> the ones inside filter (== Pizza _ _) ?
01:08:54 <Botje> or the the in toppings?
01:09:00 <Neut> in the filter
01:09:10 <Botje> you can't use pattern matching like that :)
01:09:28 <Botje> write an isPizza function
01:09:30 <Peaker> if "type" in a class defines a "type family", what does a "data" define in a class?
01:09:42 <Botje> that uses pattern matching to check if something is a pizza
01:09:45 <dolio> data family.
01:09:55 <Neut> Botje: so this function would test if it was a pizza?
01:09:58 <Peaker> copumpkin: about the instances importing, its only for imports :(
01:10:26 <copumpkin> ah :/
01:10:48 <Peaker> copumpkin: hmm.. maybe the instances get re-exported anyway without having to explicitly export the modules
01:12:05 <Neut> Botje: I have made the function, how would I apply it in the isVegetarian function?
01:12:31 <Neut> fucntion is of type
01:12:33 <copumpkin> I think you can't avoid having instances exported
01:12:37 <Neut> isPizza :: Items -> Bool
01:12:38 <copumpkin> for sanity reasons
01:20:01 <Peaker> copumpkin: yeah, that's indeed the case, so its still a bug in the DFA regex package. I think I sent a patch long ago and it was ignored
01:20:27 <Peaker> SPJ/oleg/et al   suggest an Add class as an example of type families -- to coerce addition types
01:21:19 <Peaker> but this seems like a bad idea O(N^2) instances?
01:26:28 <Peaker> kudos to them for writing the paper with ASCII Haskell syntax and no fancy unicode
01:26:42 <dolio> Heh.
01:27:18 <ivanm> Peaker: awwwww
01:27:21 <copumpkin> I like fancy symbols
01:27:27 <ivanm> is TeX math symbols OK though?
01:27:28 <copumpkin> they make me feel learnÃ©d
01:28:00 <Neut> If I had a data type of the form Int [Int] Int, how would I do a list comprehension to extract only the list of ints?
01:28:18 <copumpkin> pattern match out the bit you want?
01:28:21 <Peaker> Whenever I read a paper that uses fancy symbols instead of <*> and whatnot, I want to kick someone for putting an unnecessary barrier to reading their paper.
01:28:54 <Berengal> Peaker: What about writing code with fancy symbols instead?
01:28:59 <ivanm> copumpkin: so not just "learned" but "learn-ED"? ;-)
01:29:00 <Neut> copumpkin> yes
01:29:20 <ivanm> Peaker: tbh, I find reading code with <*> and whatnot an unnecessary barrier
01:29:35 <copumpkin> ivanm: certainly! using words like learned makes me feel learned too
01:29:36 <Peaker> Berengal: please no :(
01:30:14 <Peaker> Berengal: that's going to put another huge barrier of entry on newbies (just configure one of the "approved editors" who can create fancy symbols) or duplicate many of the names for yet more confusion
01:30:42 <Neut> copumkin: any advice?
01:30:58 <chromakode> http://www.haskell.org/ghc/docs/6.10.1/html/libraries/ghc/StrictAnal.html
01:31:00 <chromakode> I lolled.
01:31:05 <copumpkin> Neut: oh, it was a questioning suggestion for your problem :)
01:31:17 <copumpkin> chromakode: I even submitted a trac ticket about that :P they voted to keep it
01:31:32 <copumpkin> in GHC, OccurAnal
01:31:34 <Neut> copumkin: so no answers :( lol
01:31:43 <ivanm> chromakode: so what you're saying is that you're immature?
01:31:43 <chromakode> haha copumpkin, you're now famous on reddit: http://www.reddit.com/r/programming/comments/8mxum/someone_had_to_have_thought_maybe_asstuple_and/c09stpd
01:31:46 <copumpkin> Neut: oh, I do have answers!
01:31:51 <Berengal> double âˆ·  (Num a) â‡’ [a] â†’  [a]; double = map (Î»n â†’  n*2)
01:31:52 <Neut> Can you please share?
01:31:54 <Neut> Im stumped :/
01:32:00 <copumpkin> lol
01:32:10 <copumpkin> Neut: what's the actual data declaration?
01:32:17 <ivanm> Berengal: no, you have to use the actual \times symbol rather than *
01:32:47 <Berengal> ivanm: I knew there was something I forgot
01:33:24 <Neut> (Int, [Int], Int) -> [Int]
01:34:03 <Peaker> Berengal: yuck ..
01:34:45 <Peaker> we should learn from the Chinese that having more symbols than you have keyboard keys is a bad idea... :P
01:34:55 <copumpkin> Neut: so you can do \(_, x, _) -> x
01:34:59 <Peaker> s/more/significantly more
01:35:24 <Neut> copumkin: No love for a list comprehension though?
01:35:33 <Peaker> @djinn-add data List a = Nil | Cons a (List a)
01:35:33 <lambdabot> Error: Recursive types are not allowed: List
01:35:36 <copumpkin> Neut: it wouldn't help you there
01:35:39 <outchanter> list comprehensions don't work on tuples
01:35:49 <copumpkin> Neut: you could make a really contrived one if you wanted
01:35:58 <Berengal> double âˆ·  (Num a) â‡’ [a] â†’  [a]; double = map (Î»n â†’  nâ‹…2)âˆ˜join (âŠ•)
01:36:06 <Berengal> ivanm: Happy?
01:36:20 * ivanm prefers \times to \cdot
01:36:35 <copumpkin> starting to look like agda :)
01:36:41 <copumpkin> (a good thing in my book)
01:36:50 <ivanm> copumpkin: s/agda/line noise/ ;-)
01:36:57 <Neut> hmm ok thanks
01:36:59 <copumpkin> but agda's so purty!
01:37:03 <Berengal> ivanm: Me too, but for some reason this is what my third level numpad got me. It doesn't even have proper division...
01:37:10 <ivanm> :(
01:37:14 <ivanm> @wn purty
01:37:17 <lambdabot> No match for "purty".
01:37:30 <copumpkin> I bet lambdabot would understand @purty if it had the correct word
01:37:48 <outchanter> Neut: there's a much bigger difference between Haskell's lists and tuples than there is between Python's
01:37:51 <ivanm> copumpkin: yes, but lambdabot is used to making sense of idiots :p
01:37:53 <ivanm> @botsnack
01:37:53 <lambdabot> :)
01:37:53 <lunabot>  :)
01:38:01 <copumpkin> @ivanmsmack
01:38:02 <lambdabot> Unknown command, try @list
01:38:04 <copumpkin> :(
01:38:19 <Neut> copumkin: so im learning
01:38:20 <copumpkin> @smack ivanm
01:38:20 * lambdabot moulds ivanm into a delicous cookie, and places it in her oven
01:38:25 <copumpkin> o.O
01:38:33 <copumpkin> that sounds rude somehow
01:38:35 <ivanm> mmmmm..... bikkies....
01:38:40 <copumpkin> Neut: great :)
01:38:59 * copumpkin gave up learning, it rots the mind
01:39:00 <Berengal> Sometimes... sometimes lambdabot freaks me out a little...
01:39:09 <copumpkin> you just gotta be opinionated about stuff on the internet
01:39:27 <Berengal> copumpkin: I see you've understood what it's all about
01:39:28 <copumpkin> the less you have to back up your opinions, and the stronger your language, the better
01:39:37 <mjrosenb> lambdabot's @smack is how i learned abouot the evil mangler
01:40:24 <fasta> Is CReal on Hackage? Or is there just the darcs repository?
01:40:29 <copumpkin> @hackage numbers
01:40:29 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
01:41:15 <fasta> Thanks
01:41:36 <copumpkin> :)
01:42:07 * Botje returns
01:42:28 <Peaker> looking at conal's old memoization blog post (similar example used in the paper about type families) -- and the comments about undefined-ness.. I think unamb between the memo lookup and the original function could resolve the problem -- anyone knows that post?
01:42:52 <Heffalump> the memoization done via type families?
01:48:36 <Pellwurst> how can i escape a $-char? i am working on a RegExp with a $ in it, but it doesn't like that char :/
01:49:17 <EvilTerran> Pellwurst, is this regexps expressed as Strings?
01:49:32 <EvilTerran> if so, i think that'll be \\$
01:49:46 <EvilTerran> or [$]
01:50:12 <EvilTerran> (either should work, \\$ is more conventional, but [$] is clearer, imo)
01:51:10 <Peaker> DAMN, the session type example in the type fun paper is cool!  Sounds like a practical approach for actual protocols!
01:51:13 <Pellwurst> EvilTerran: that works fine...thx. i just tried \$
01:51:46 <EvilTerran> Pellwurst, the trouble with that is that the \ would get interpreted as a string escape character, so wouldn't get as far as the regex engine
01:51:58 <EvilTerran> > "\$"
01:51:59 <lambdabot>   <no location info>:
01:51:59 <lambdabot>      lexical error in string/character literal at end o...
01:52:02 <Pellwurst> ahh ok
01:52:17 <EvilTerran> > text "\\$"
01:52:18 <lambdabot>   \$
01:52:37 <EvilTerran> so you have to escape the escape character, thus getting dangerously close to Leaning Toothpick Syndrome
01:53:53 <Pellwurst> :P
01:54:05 <Zao> EvilTerran: I managed to end up in a situation a few weeks ago where I needed eight \ to get a literal \.
01:55:57 <WorkyBob> with Ghc Core is the only way to simulate let (x,y) = f z essentially let x = case r of (a,b) -> a; y = case r of (a,b) -> b; r = f z?
01:56:43 <lvh> hello :-)
01:57:17 <yakov> hello
01:57:42 <yakov> could you help me with GADTs+IORefs here http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5207#a5207
01:58:08 <yakov> it seems to me like a rigidity problem :-/ but I can't figure out how to help GHCi type check it
01:58:29 <Peaker> WorkyBob: how are irrefutable patterns implemented in general?
01:59:09 <copumpkin> I thought it was just case f z of (x, y) -> (rest of code)
01:59:19 <WorkyBob> Peaker: I don't know â€“ but the only place I seem to get to specify a constructor is in a case expression
01:59:29 <Berengal> yakov: I'm guessing it's because you commented out 'deriving Show'
01:59:39 <WorkyBob> copumpkin: oh, sorry, I'm talking about a top level binding here
01:59:45 <WorkyBob> so it's one of many recursive bindings
02:00:01 <copumpkin> oh
02:00:04 <EvilTerran> Zao, ouch
02:00:16 <yakov> Berengal, it can't autoderive Show
02:00:32 <yakov> 'cause GADTs+records is not haskell'98
02:00:48 <Zao> EvilTerran: Let's just say that PHP regexen aren't exactly easy to use :)
02:00:59 <Berengal> yakov: Then you'll have to make it an instance yourself. It's the lacking instance it's complaining about
02:01:36 <Peaker> WorkyBob: do you not get to use fst/snd in Ghc Core?
02:01:41 <yakov> well, Show constraint is on `p' not on all ProgramState2!
02:01:57 <copumpkin> WorkyBob: how does GHC translate it?
02:01:58 <yakov> Show is example class, I have my own class in real code
02:02:21 <WorkyBob> Peaker: well you do - the question was really around do I have to create individual bindings for each variable in the irrifutable pattern, or is there a neater way?
02:02:29 <EvilTerran> Zao, s/regexen aren't/isn't/ :P
02:02:32 <WorkyBob> copumpkin: good question *checks*
02:02:43 <yakov> Berengal, anyway thx! i'll move my question to h-i-d
02:03:14 <Peaker> WorkyBob: intuition tells me that individual bindings are the only way to implement irrefutable patterns, and I think let pattern matches are all irrefutable
02:04:04 <fasta> I get No instance for (NearZero CReal), but there is a default implementation for NearZero (a type class in the Vec package) when "a" is in the Num class. CReal is in the Num class. Why doesn't it pick up the instance?
02:04:17 <WorkyBob> Peaker: cool, just as long as I'm not missing a trick :)
02:04:27 <Zao> EvilTerran: -en as in plural form, as there's half a dozen of them.
02:04:42 <Peaker> WorkyBob: I am just speculating here, though, I might be missing something too
02:04:47 <Peaker> yakov: why is ProgramState2 a GADT? just one constructor?
02:05:02 <yakov> Peaker, because of foo function
02:05:09 <yakov> it must have constraint on `p'
02:05:13 <yakov> particular class
02:06:33 <yakov> i.e. foo accepted `p' direcly in the past
02:06:38 <yakov> then i moved to record syntax
02:06:49 <yakov> and so i figured that i need GADT to constraint foo
02:07:49 <yakov> (when foo accepted `p' it has *this* constraint explicitly - foo::Show p => p -> ..)(
02:09:56 <Peaker> yakov: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5207#a5208
02:10:25 <Peaker> yakov: the forall has to be outside the PS2 constructor if you want it to be existential inside the constructor field
02:11:04 <blueonyx> hi, how to make functions of a class visible in 'instance'? http://www.moonpatio.com/fastcgi/hpaste.fcgi/view?id=2476#a2476
02:12:20 <ski> blueonyx : tried s/data/newtype/ plus `newtype'-deriving ?
02:12:57 <ski> (or export `empty',`isEmpty' together with `DynGraph' .. but presumably you don't have control over that (?))
02:13:23 <blueonyx> thought about that, but later i want to add other properties to Species :/
02:13:39 <Saizan> blueonyx: if you're using fgl, empty and isEmpty are methods of the class Graph, not DynGraph
02:13:45 <blueonyx> oh
02:14:23 <ski>   empty = S empty
02:14:24 <ski>   isEmpty = isEmpty . graph
02:14:36 <ski> presumably
02:15:49 <blueonyx> when i use Graph instead of DynGraph i get "Expected kind `* -> * -> *', but `Species' has kind `*'"
02:16:50 <yakov> Peaker, thx a lot!
02:16:58 <Saizan> yeah, the Graph class requires you to be polymorphic over the type of the labels
02:17:02 <ski> .. so `Graph' wants to provide its own arguments to the instancee
02:17:19 <ski> (Saizan : s/polymorphic/parametric/)
02:17:27 <blueonyx> mh
02:20:22 <yakov> Peaker, is it possible to do same quantification with GADTs?
02:20:39 <blueonyx> so then i make it instance Graph Spec and use type Species = Spec SNLabel SELabel, thanks you two!
02:20:49 <Peaker> yakov: sure
02:24:21 <dibblego> is data Digit = Zero | One | ... | Nine in the stdlib?
02:25:01 <ivanm> @hoogle Digit
02:25:01 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
02:25:01 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
02:25:01 <lambdabot> Data.Char digitToInt :: Char -> Int
02:25:17 <ivanm> dibblego: in what context?
02:25:25 <dibblego> just a type-safe digit
02:25:37 <dibblego> a data type with nullary constructors
02:25:42 <dibblego> *ten nullary constructor
02:28:26 <ivanm> never even heard of it
02:29:02 <copumpkin> there's D0-D9 in one of the type-level numbers packages
02:29:08 <Axman6> @hoogle showHex
02:29:08 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
02:29:15 <copumpkin> but I haven't seen them written out as words before
02:30:00 <dibblego> that'll do cheers
02:30:27 <copumpkin> http://hackage.haskell.org/packages/archive/type-level/0.2.2/doc/html/Data-TypeLevel-Num-Reps.html
02:31:19 <doserj> those are ten types, though, not a type with ten data constructors
02:31:27 <dibblego> oh
02:31:40 <copumpkin> oh true
02:32:23 <copumpkin> hmm, guess not then :)
02:38:35 <hackagebot> mohws 0.2.0.1
02:44:00 <ivanm> hackagebot is back! \o/
02:46:35 <willard> Greetings folks. I just started teaching a course on Haskell to first and second year undergraduates, and am currently looking around for IDEs for writing Haskell programs to recommend to my students. Besides Emacs (which I use) and VIm, which IDE would you recommend? I plan on having my students write many small programs, and one bigger program near the end of the course.
02:46:51 <mreh> yi
02:46:54 <dibblego> nice, which uni?
02:47:04 <Baughn> willard: It's May. Can I assume you won't really get started until fall?
02:47:08 <willard> Reykjavík University, Iceland
02:47:08 <mreh> I wish I had gone to that university
02:47:14 <dibblego> I'm giving a talk on Haskell tomorrow night (QuickCheck specifically) http://www.meetup.com/Brisbane-Functional-Programming-Group-BFG/calendar/10469028/
02:47:23 <ivanm> dibblego: oh?
02:47:25 <ivanm> where is it?
02:47:31 <dibblego> at QUT (Queensland University of Technology)
02:47:38 <Baughn> willard: EclipseFP exists, but is not quite done. It's still worth investigating, and there's currently a SoC project working to improve it.
02:47:38 <ivanm> gah
02:47:39 <willard> Baughn: This is a summer course, so no ;-)
02:47:43 <ivanm> the evil uni!
02:47:44 <ivanm> ;-)
02:47:54 <ivanm> dibblego: I saw the "Brisbane" in the URL, hence the query :p
02:47:57 <dibblego> why is it evil over others?
02:48:00 <Baughn> willard: Oh well. EclipseFP, anyway.
02:48:04 <ivanm> because I go to UQ? :p
02:48:10 <Baughn> (Personally I just use Emacs)
02:48:13 <dibblego> oh I applied for a job there the other day :)
02:48:38 <dibblego> ivanm, you should join the Brisbane Functional Programming Group
02:48:58 <ivanm> didn't know there was one
02:49:07 <mreh> has anyone else worked out how to make Graphics.SOE.Event work with Graphics.SOE.Key?
02:49:10 <ivanm> dibblego: don't you work at Danger Mouse/Working Mouse/whatever it's called?
02:49:11 <dibblego> there was, since a couple of weeks ago
02:49:18 <dibblego> Workingmouse, not any more
02:49:28 <ivanm> any particular reason for quitting?
02:49:36 <dibblego> the company closed
02:49:49 <ivanm> oh?
02:50:00 <mreh> bummer
02:50:20 <Peaker> re-exporting a module re-exports all of its namespace?
02:50:34 <dibblego> http://projects.tmorris.net/public/haskell-intro/artifacts/latest/chunk-html/index.html here are the slides for tomorrow night (don't everyone hit it at once please!)
02:51:09 <willard> Baughn: @ EclipseFP : Very nice. I'll point this out to my students.
02:51:23 <dibblego> willard, fwiw, I use kate, but it's just a text editor
02:51:42 <willard> Baughn: Have you by any chance tried out Leksah?
02:51:48 <Baughn> willard: Keep in mind that it's /not done/. There are bound to be holes and bugs.
02:51:58 <ivanm> dibblego: well, I'd come except that page says there's no spots left :s
02:52:19 <mreh> SOE seems to have been bundled with HGL, but I dont think they are even compatible
02:52:21 <Baughn> willard: Ah.. yeah. My first thought as a response was "Avoid", but that /was/ admittedly half a year ago. Still, it is if possible even less complete.
02:52:23 <dibblego> ivanm, yeah tis a bummer -- maybe someone will pull out
02:52:37 <dibblego> ivanm, sorry, should have told you earlier (only reached 20 this afternoon)
02:52:46 <Baughn> willard: Interesting place to visit, but I wouldn't want to live there.
02:52:54 <dibblego> ivanm, it will be very basic -- I don't expect the users to have used Haskell before
02:53:08 <ivanm> dibblego: if I pm you my mobile, could you give me a msg or ring before say 4:30 (because that's normally when I head off home) if a spot turns up?
02:53:13 <dibblego> sure
02:54:12 <ivanm> ta
02:54:19 <Baughn> willard: Really, the main issue I have with EclipseFP is that it's not emacs. No automatic column alignment, no keyboard macros, etc.
02:55:15 <ivanm> Baughn: \foo -> Really, the main issue I have with foo is that it's not emacs. No automatic column alignment, no keyboard macros, etc.
02:55:16 <ivanm> ;-)
02:55:41 <dibblego> ivanm, I just msged the organiser and he says "he should fit -- does he have a camera?" (since there are a *huge* number of requests to video it)
02:55:58 <ivanm> ummmm.... I have a camera...
02:56:04 <ivanm> but it's not "mine" (it's my dad's)
02:56:11 <ivanm> and I don't think I'll be able to bring it :(
02:56:21 <dibblego> ok
02:56:23 <Baughn> ivanm: Right. It seems to me that it'd be less work to complete Emacs' haskell support than it'd be to improve Eclipse's editing support.
02:56:23 <willard> dibblego: I haven't had any need for anything more than a text editor when writing Haskell code either. Sadly, there are computation science students which think that "programming occurs in a bloated IDE". I wish to make sure that if they insist on using one, they can ;-)
02:56:24 <dibblego> you're in anyway
02:56:35 <ivanm> thanks
02:56:55 <ivanm> willard: isn't *nix an IDE? :p
02:57:07 <dibblego> you'll want a copy of the slides -- since we're not sure we have a projector :)
02:57:29 <ivanm> lol
02:57:48 <ivanm> is this in a lecture theatre? or an office?
02:58:03 <dibblego> no idea -- a small room afaik
02:58:11 <willard> Baughn: @ Interesting place to live: I don't want to live here either given our current situation; that's why I'm moving to Gothemburg to work on my PhD this autumn :-P
02:58:17 <ivanm> I would have thought QUT would have projectors in most meeting rooms, etc.
02:58:18 <dibblego> Z413 at QUT Gardens Point
02:58:30 <ivanm> *nod*
02:58:40 <Baughn> willard: Oh yeah, Iceland. Hm, you wouldn't want to come here to Norway instead?
02:58:42 <ivanm> dibblego: maybe you should but the BFG onto haskell.org somewhere?
02:58:56 <willard> Baughn: I'm planning on showing my students what working with Emacs + a ghci buffer is like. Perhaps they will be inspired.
02:58:59 <Baughn> willard: ..we were actually considering annexation at one point. >_>
02:59:00 <dibblego> ivanm, good idea
02:59:23 <ivanm> willard: + hlint integration! ;-)
02:59:52 <ivanm> dibblego: right-o, this gives me a couple of hours after I officially stop getting paid to start hacking on something :p
02:59:53 <dibblego> ivanm, it will be very basic -- I hope you don't get bored -- maybe you can help others out since they will have their laptops and we will be writing QuickCheck tests
03:00:01 <ivanm> I've never used QC ;-)
03:00:22 <dibblego> ok, others will be held back by syntax though, but you can help out :)
03:00:36 <ivanm> so should I bring my laptop along? and RWH for the QC bit?
03:00:37 <willard> ivanm: *nix IDE: True; but the clutter is conveniently hidden away until you ask for it ;-)
03:00:42 <ivanm> heh
03:00:57 <dibblego> yes, bring laptop and RWH if you like -- the laptop is why we have limited places (hopefully we will all fit)
03:01:32 <ivanm> heh
03:02:49 <ivanm> dibblego: so how much room is there still? there might be some other people interested in coming if there's still room...
03:03:03 <willard> Baughn: @ Annexation: Haha :-) If offered at the right moment, Iceland just might have accepted. Iceland was even statistically ready to enter EU in October last year (but we all know how reliable those polls are...). In most cases, however, the offer would hurt Iceland's pride :-P
03:03:09 <dibblego> I have no idea to be honest -- but we better not get too many people
03:03:22 <ivanm> *nod*
03:03:26 <ivanm> OK, I'll leave it for now
03:03:29 <ivanm> maybe future meetings
03:03:49 <dibblego> yep -- we've only just started and depending on how tomorrow goes and how many people we get, we might need to organise better rooms
03:03:55 <willard> Baughn: You could let Iceland take on the Norwegian currency. I am sure there is plenty of mutual benefit... :-P
03:03:59 <ivanm> Baughn: since when was #haskell interested in annexing a country?
03:04:06 <ivanm> willard: lol
03:04:10 <Baughn> ivanm: Not #haskell, Norway.
03:04:18 <ivanm> I did realise that...
03:04:27 <ivanm> but the way you used "we"... :p
03:04:45 * p_l looks at torrent described as "want to invade a small country?"
03:05:35 <Baughn> Aand.. Pantheocide has started.
03:05:41 <Baughn> Book 2, that is. :D
03:05:54 * Baughn blinks
03:05:57 <ivanm> is that when you kill off a whole bunch of gods?
03:06:00 <Heffalump> we could annex Iceland and turn it into the Haskell country
03:06:02 <Baughn> p_l: Hey, no fair making me think I'm in #nanoha!
03:06:18 <fasta> Heffalump: Haskell has not got _that_ many users.
03:06:28 <ivanm> fasta: so let's get some more!
03:06:41 <p_l> Baughn: LOL
03:06:50 <Baughn> ivanm: It's when armageddon shows up, and realizes humanity is much more advanced than the gods.
03:07:08 <ivanm> Heffalump: then again, isn't Haskell stateless? isn't thus annexation an imperative thing? :p
03:07:15 <ivanm> Baughn: ahhh
03:07:28 <Baughn> annex :: Country -> IO Warzone
03:07:48 <ivanm> Baughn: not necessarily...
03:07:59 <ivanm> there are occasionally voluntary annexations IIRC
03:08:16 <Baughn> It's been known to happen, yes. That was the kind we were considering re: iceland.
03:08:43 <Baughn> But let's be honest, Iceland is basically a wholly-owned subsidiary of scandinavia already. :P
03:09:04 <ivanm> heh
03:09:08 <willard> Bah :-P
03:09:15 <ivanm> Baughn: except with its own dodgy currency?
03:09:53 <Peaker> heh, SPJ uses "design pattern" in the Haskell context in his paper
03:10:06 <ivanm> :o
03:10:26 <ivanm> I thought "Design patterns" was the OOP world's excuse for verboseness...
03:10:30 <ivanm> FactoryFactorFactory, etc.
03:10:50 <dibblego> ivanm, join the meetup list so you can get emails and so on and RSVP formally -- we are going to set the limit to 25 in a moment
03:11:03 <willard> Haskell programmers: Come to Iceland. We have cookies.
03:11:05 <ivanm> dibblego: I'm just waiting for the confirmation email to come through ;-)
03:11:11 <ivanm> willard: I prefer biscuits
03:11:19 <ivanm> seeing as how I'm not a yank and all...
03:11:20 <ivanm> ;-)
03:12:46 <ivanm> besides, isn't the traditional online bribe meant to be "caek"?
03:12:47 <dibblego> ivanm, let me know when it is in, since there are others waiting to take up those 5 spot
03:12:53 <ivanm> *nod*
03:13:50 <monadic_kid> he uses the word "design pattern" in context of monads
03:13:50 <ivanm> dibblego: done
03:14:00 <dibblego> ivanm, so you've joined BFG?
03:14:07 <ivanm> yup
03:14:15 * ivanm gave up on waiting for offlineimap to sync and just signed in to gmail
03:14:18 <dibblego> ok, we're working on it now
03:14:50 <dibblego> ivanm, go, it's set to 30
03:14:59 <ivanm> done! \o/
03:15:05 <dibblego> see you tomorrow :)
03:15:07 <dibblego> see you tomorrow :)
03:15:10 <dibblego> oop
03:15:14 <ivanm> heh
03:15:34 <monadic_kid> oop and OOP
03:15:50 <monadic_kid> they are fundamentally the same lol
03:16:54 <monadic_kid> didn't get the joke...
03:18:01 <ivanm> oh, wait, that was a _joke_? :o
03:18:03 <ski> (willard : what cookies ?)
03:18:50 <monadic_kid> ivanm: my rubbish joke
03:19:37 <willard> (ski: lambda-chip cookies :-P )
03:19:50 <ivanm> dibblego: "z413" means building z, room 413?
03:20:05 <dibblego> your guess is as good as mine, which is what my guess is also :)
03:20:22 <ivanm> heh
03:20:56 <Baughn> @seen conal
03:20:57 <lambdabot> I saw conal leaving #haskell and #ghc 4m 6d 5h 6m 46s ago, and .
03:21:02 <Peaker> ivanm: design patterns are just "documented solutions to common problems".. In Haskell there are plenty of them as well..
03:21:14 * Baughn threatens lambdabot with bodily harm
03:21:17 <ivanm> gah, translink doesn't want to tell me citycat times :@
03:21:44 <ivanm> Peaker: well, IIRC I failed the exam I had on design patterns...
03:21:49 <ivanm> didn't get them :s
03:22:35 <monadic_kid> Peaker: you left out *recurring* problems/solution.
03:22:49 <Peaker> monadic_kid: common kinda implies recurring
03:22:49 <monadic_kid> *re-ocurring
03:23:19 <monadic_kid> meh
03:23:22 <Peaker> the "strategy" pattern, for example, solves a common problem of how to control aspects of a behavior of a called function -- in both OOP and Haskell -- pass a function
03:23:55 <Baughn> So, "strategy" = "function"?
03:23:57 <Peaker> pass a function (or a func ptr, or delegate, or higher order function) or a function table (record of functions, type-class instance, etc)
03:24:04 <Baughn> ..right.
03:24:05 <ski>   newtype Strategy a b = S (a -> b)  -- ?
03:24:19 <Peaker> Baughn: "strategy" = "passing a function[s] as an argument in order to control aspects of its execution"
03:24:29 <Baughn> Peaker: Well, why /else/ would you pass a function?
03:24:39 <Peaker> Baughn: you might want to store the function inside the data structure
03:24:43 <ski> > const not False
03:24:45 <lambdabot>   Overlapping instances for GHC.Show.Show
03:24:45 <lambdabot>                              (GHC.B...
03:24:57 <ski> > const False not
03:24:58 <lambdabot>   False
03:25:00 <Baughn> Peaker: I suppose, but at some point it will be controlling aspects of some execution somewhere.
03:25:15 <Baughn> > const not False True
03:25:17 <lambdabot>   False
03:25:21 <Peaker> Baughn: if its directly called by the function stack you gave it to, then its a strategy
03:25:49 <Baughn> Peaker: I see. I suppose that's a useful definition, then.
03:25:59 <Peaker> I think people like to attack patterns because some were indeed language-specific and many were really workarounds for bad language features. But some patterns are just "good ways to utilize the language"
03:28:05 <ivanm> Peaker: aren't even most of the original GoF patterns hacks around C++/Java?
03:28:43 <chrisdone> so awesome! http://yaxu.org/haskell-hack/
03:28:45 <Peaker> ivanm: I don't have the statistics :)  But it does have the "Visitor pattern" which is really an ugly workaround for lack of multi-dispatch (which also does inversion of control at the same time!)
03:29:08 <ivanm> chrisdone: so slow!
03:29:17 <Baughn> chrisdone: So Slashdotted!
03:29:21 <Baughn> Is that #haskelldotted?
03:29:44 <ivanm> Baughn: I don't think we're _that_ fast!
03:29:45 <Peaker> ivanm: It has various factory patterns -- which are basically using higher-order functions to generate polymorphic results whose type you don't care about (including indeed language-specific implementation details of how to do this)
03:29:50 <ivanm> we're lazy, after all! :p
03:29:52 <chrisdone> you're welcome
03:29:56 <Peaker> ivanm: I don't remember all of the patterns it had
03:30:01 <ivanm> *nod*
03:30:22 <Peaker> my Flash is broken. Gnash only shows YouTube and non-free Flash works poorly on 64-bit, need to "set it up", yikes
03:30:37 <chrisdone> I usually keep links to myself in case people have already seen it, that way the most people get to see cool new projects
03:31:42 <Peaker> it downloads at ~15K/sec
03:39:14 <ivanm> dibblego: hmmm.... BFG doesn't seem to be listed here: http://www.meetup.com/cities/au/brisbane/groups/technology/?radius=25.0
03:43:49 <Neut> Can someone help me debug this
03:43:51 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2477#a2477
03:45:03 <ivanm> Neut: what's the error?
03:45:11 <ivanm> also, why are you using Float rather than Double?
03:45:25 <Neut> Type error,
03:45:42 <ivanm> where?
03:45:55 <Neut> couldnt match expected type Point against infered [Point]
03:45:56 <doserj> closed is the wrong way round. pathLength (x:y:xs) = distance x y + pathlength (y:xs)
03:46:38 <Neut> Oh derr!
03:46:41 <Neut> thanks doserj
03:46:46 * Neut goes to the corner
03:49:22 * ski hands Neut the "Ego Asinus Sum" cornet hat
03:51:01 <ivanm> ski: you mean a cornette? http://en.wikipedia.org/wiki/Cornette
03:51:12 <Neut> i think its German what he siad?
03:51:19 <Neut> or professor google told a fibsie
03:51:32 <Botje> latin, more like
03:51:48 <ivanm> Ego Asinus Sum: I think, therefore I'm an idiot?
03:52:06 <ivanm> but wikipedia doesn't seem to know anything about a cornet hat
03:52:19 <ivanm> unless he meant corner?
03:52:25 <outchanter> I like to think it's a hat with these sticking out? http://en.wikipedia.org/wiki/Cornett
03:52:30 <Botje> try "dunce cap" instead :P
03:52:39 <Botje> or dunce hat
03:52:48 <ski> ivanm : actually, it appears the correct english term is "dunce cap/hat" .. ty
03:53:08 <ivanm> ahhh
03:53:10 * ski was tranlating from non-english into "cornet hat"
03:53:41 <malcolmw> think ice-cream cornet
03:54:07 <ivanm> yeah, I get what he means now
03:54:19 <ivanm> it's not a very Australian thing, which is why I didn't think of it at first
03:54:52 <ski> (ivanm : "Ego Asinus Sum" would be more like "I'm an ass/idiot")
03:55:19 <ivanm> oh, I thought the English "Ego" came from Latin
03:55:21 <Saizan> Asinus = donkey
03:55:28 <Saizan> Ego = I
03:55:31 <ivanm> duh, Ego refers to self, not to thought processes
03:55:41 <ivanm> Saizan: I got the Asinus bit ;-)
03:56:00 <outchanter> doesn't ÎµÎ³Î¿ come from Greek?
03:56:12 <Gracenotes> it does now.
03:56:13 <wli> encoding...
03:56:26 <ivanm> heh
03:56:29 <wli> iago?
03:57:00 <Saizan> still ego
03:57:03 <ivanm> as in the aladdin parrot? :p
03:57:16 <outchanter> who was named after the villain in Othello
03:57:44 <wli> I thought that was how the Greek pronoun transliterated.
03:57:46 <dibblego> is there a function to split every n starting from the right?
03:57:54 <Neut> and to bring this conversation full circle, othello was the theme of my last assignment
03:58:30 <ivanm> dibblego: you mean foo :: Int -> [a] -> [[a]]
03:58:31 <ivanm> ?
03:58:40 <ivanm> not sure about "from the right" though... infinite lists!
03:58:42 <dibblego> ivanm, correct
03:58:52 <dibblego> yes, this will not be infinite
03:59:19 <ivanm> reverse, do recursive splitting, then map reverse?
03:59:31 <dibblego> I've thought of that
03:59:33 <ski> @type \n -> unfoldr (\as -> if null xs then Nothing else Just (splitAt n as))
03:59:34 <lambdabot> Not in scope: `xs'
03:59:37 <ivanm> I'm not sure you can do the splitting from the end, that's all
03:59:39 <ski> @type \n -> unfoldr (\as -> if null as then Nothing else Just (splitAt n as))
03:59:40 <lambdabot> forall a. Int -> [a] -> [[a]]
03:59:53 <ivanm> ski: he wants to do it from the _end_
03:59:54 <ski> > unfoldr (\as -> if null as then Nothing else Just (splitAt 4 as)) [0..]
03:59:55 <lambdabot>   [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23],...
04:00:07 <dibblego> > unfoldr (\as -> if null as then Nothing else Just (splitAt 4 as)) [0..5]
04:00:08 <lambdabot>   [[0,1,2,3],[4,5]]
04:00:15 <ski> ivanm,dibblego : sorry, missed that part
04:00:20 <dibblego> I want [[0, 1], [2, 3, 4, 5]]
04:00:27 <ski> i see
04:00:38 <ivanm> that bit I'm not sure if you can do
04:00:48 <ivanm> since you don't know how long the list is
04:01:01 <dibblego> I'm sure I can if I assume the list is finite
04:01:02 <ivanm> whereas splitting from the front, you can start counting straight away
04:01:15 <dibblego> i.e. reverse will terminate
04:10:15 <Neut> with this function
04:10:17 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2478#a2478
04:10:25 <Neut> why doesn't it like the yy
04:10:27 <Neut> or y:Y
04:10:29 <Neut> y:y
04:10:35 <Neut> by it, I mean ghci
04:10:46 <wjt> yy isn't defined
04:10:47 <outchanter> > let (f, l, n, rem) = (unfoldr (\as -> if null as then Nothing else Just (splitAt n as)), [0..10], 4, length l `mod` n) in (take rem l):(f (drop rem l))
04:10:49 <lambdabot>   [[0,1,2],[3,4,5,6],[7,8,9,10]]
04:11:15 <wjt> Neut: i think you mean y:y:stutter y xs
04:11:55 <Neut> thanks wjt
04:12:13 <wjt> Neut: where would "yy" come from?
04:12:23 <ivanm> wjt: thin ari
04:12:24 <ivanm> *air
04:12:26 <ivanm> duh :p
04:12:30 <Neut> Gah Im finding Haskell recursion difficult
04:13:00 <Neut> ivanm, fair go - this is a channel to learn haskell I believe
04:13:20 <ivanm> well, it's a channel to discuss haskell, which includes haskell help
04:13:24 <ski> dibblego : what do you want for `foo 4 [0..7]' ?
04:13:43 <ivanm> and I'm not making fun of you (I was making fun of wjt actually), just attempting (and obviously failing miserably) to be funny
04:14:00 <ski>   [[0,1,2,3],[4,5,6,7]]  -- yes ?
04:14:15 <dibblego> [[0, 1, 2, 3], [4, 5, 6, 7]]
04:14:19 <Neut> It's fine. I'm sure I would find my style of questions testing if I knew alot about Haskell as well..
04:22:45 <ski> @let foo n xs0 = ys0:yss0 where (_,ys0,yss0) = loop xs0; loop [] = (n,[],[]); loop (x:xs) = (pred j,x:zs,zss) where (i,ys,yss) = loop xs; (j,zs,zss) | i > 0 = (i,ys,yss) | otherwise = (n,[],ys:yss)
04:22:47 <lambdabot>  Defined.
04:22:49 <ski> > foo 4 [0..9]
04:22:52 <lambdabot>   [[0,1],[2,3,4,5],[6,7,8,9]]
04:22:53 <ski> > foo 4 [0..7]
04:22:55 <lambdabot>   [[0,1,2,3],[4,5,6,7]]
04:23:09 <ski> > foo 4 []
04:23:11 <lambdabot>   [[]]
04:23:16 <ski> hm
04:23:28 <ski> > foo 0 [0..7]
04:23:29 <lambdabot>   [[0],[1],[2],[3],[4],[5],[6],[7],[]]
04:23:55 <ski> i suppose positiveness of the size is a precondition
04:25:09 <Deewiant> > foo (-1) [1..10]
04:25:10 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[]]
04:26:24 <ski> @let outchanter size list = take rem l:f (drop rem l) where (f, l, n, rem) = (unfoldr (\as -> if null as then Nothing else Just (splitAt n as)), list, size, length l `mod` n)
04:26:25 <lambdabot>  Defined.
04:26:41 <ski> > outchanter 4 [0..7]
04:26:43 <lambdabot>   [[],[0,1,2,3],[4,5,6,7]]
04:27:04 <dibblego> I've already cheated using reverse
04:27:05 <ski> > outchanter 4 []
04:27:07 <lambdabot>   [[]]
04:29:38 <ski> > outchanter 0 [0..7]
04:29:39 <lambdabot>   [* Exception: divide by zero
04:39:30 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2479#a2479
04:39:39 <Neut> Can someone help me with the recursion in allColinear?
04:40:21 <Botje> how many arguments does allColinear take?
04:40:33 <Neut> allColinear :: [Point] -> Bool
04:40:37 <Neut> type Point = (Float, Float)
04:40:44 <Botje> allColinear x (y:xs)
04:40:54 <Botje> how many arguments are you calling it with? :)
04:41:49 <Neut> Botje: not really following you here,
04:42:43 <Deewiant> allColinear x (y:xs) calls the function allColinear, passing it the two arguments x and (y:xs)
04:42:49 <Philonous> allColinear (x:y)	= False  That matches all lists with at least one element
04:43:12 <Philonous> Maybe you meant [x,y] instead of (x:y)  ?
04:43:41 <Neut> oh yeah good catchm
04:43:43 <Axman6> Neut: g'day
04:43:45 <Philonous> ( [x,y] matches lists with exactly two elements)
04:43:49 <Neut> so what would the last line need to be?
04:43:51 <Axman6> you're at ANU apparently
04:43:57 <Neut> its true
04:44:01 <Neut> you too?
04:44:05 <Axman6> yep :)
04:44:12 <Neut> can you help me :D
04:44:26 <Axman6> heh, maybe.
04:44:32 <byorgey> Neut: allColinear takes only one argument, a list of Points, right?
04:44:41 <Neut> yeah thats right
04:44:49 <byorgey> Neut: so which list do you want to pass it in the recursive call?
04:44:56 <Deewiant> As pointed out above, you're passing it two arguments currently
04:45:10 <Neut> the first 3
04:45:13 <Neut> then the next 3
04:45:15 <Neut> and so on
04:46:05 <Neut> Deewiant: how can I pass it 3?
04:46:08 <Philonous> Neut: do you mean [1,2,3,4,5,6] -> [1,2,3],  [2,3,4] or rather [1,2,3] and [5,6,7]
04:46:11 <byorgey> right, so if you got (x:y:z:xs), that is, a list starting with x, y, z, and then a whole bunch of other stuff xs, what list do you want to pass to the recursive call?
04:46:26 <Philonous> [4,5,6]
04:46:27 <Neut> Philonous: the 2nd
04:46:35 <Deewiant> Neut: Since it only takes one argument, you should only passing it one, not more than that :-)
04:46:37 <Neut> [4,5,6]
04:46:39 <Philonous> then pass it only the tail of the list, i.e. xs
04:46:40 <Deewiant> +be
04:46:46 <dibblego> is fmap . fmap somewhere in the libraries?
04:46:56 <Deewiant> So "allColinear xs" instead of "allColinear x (y:xs)"
04:47:06 <Deewiant> dibblego: Not to my knowledge
04:47:33 <byorgey> Neut: also, + is only for numbers, so you'll need to replace that with some sort of Boolean operator
04:48:38 <Axman6> > let allColinear [] = True; allColinear ((x1,y1):xss@((x2,y2):(X3,y3):xs)) = (y2-y1)/(x2-x1) == (y3-y2)/(x3-x2) && allColinear xss in allColinear [(1,1),(2,2),(3,3)]
04:48:39 <lambdabot>   Not in scope: data constructor `X3'Not in scope: `x3'
04:48:51 <Philonous> Neut: btw. you can save yourself some lines if you match the case with at least 3 elements first and then all the other ones
04:48:53 <Axman6> > let allColinear [] = True; allColinear ((x1,y1):xss@((x2,y2):(x3,y3):xs)) = (y2-y1)/(x2-x1) == (y3-y2)/(x3-x2) && allColinear xss in allColinear [(1,1),(2,2),(3,3)]
04:48:54 <lambdabot>   * Exception: <interactive>:1:217-341: Non-exhaustive patterns in function a...
04:49:28 <Axman6> > let allColinear ((x1,y1):xss@((x2,y2):(x3,y3):xs)) = (y2-y1)/(x2-x1) == (y3-y2)/(x3-x2) && allColinear xss; allColinear _ = True in allColinear [(1,1),(2,2),(3,3)]
04:49:29 <lambdabot>   True
04:49:34 <Axman6> > let allColinear ((x1,y1):xss@((x2,y2):(x3,y3):xs)) = (y2-y1)/(x2-x1) == (y3-y2)/(x3-x2) && allColinear xss; allColinear _ = True in allColinear [(1,1),(2,2),(3,4)]
04:49:35 <lambdabot>   False
04:49:39 <Axman6> whoot
04:49:48 <Neut> allColinear x (y:xs)	= colinear x y z + allColinear x (y:xs)
04:50:06 <Axman6> where's the z come from?
04:50:22 <Botje> fairies!
04:50:23 <LeCamarade> Who can tell me how to hunt down a case where my GHC-compiled app quits with "thread blocked indefinitely".
04:50:27 <Axman6> and isn't the type of allColinear :: [Point] -> Bool?
04:50:32 <LeCamarade> I used no explicit locks, so ...
04:50:34 <LeCamarade> ?
04:50:46 <Neut> well I need to pass it three arguments.. but at the same time Id ont know
04:51:15 <Axman6> i think what you need is...
04:51:31 <Botje> Neut: no, your type says it only has one argument.
04:51:47 <Botje> you want it to pass a *list* of size at least three
04:51:49 <Neut> colinear :: Point -> Point -> Point -> Bool
04:51:57 <Axman6> allColinear (x:(xss@(y:z:xs)) = colinear x y z && allColinear xss; allColinear _ = True
04:52:22 <Axman6> Neut: which course are you doing btw?
04:52:30 <Neut> Fail 1100
04:52:38 <Axman6> heh, i loved 1100
04:52:44 <Axman6> i have a few friends doing it too
04:52:51 <Axman6> Clem's such a maddog
04:52:57 <Neut> do you do haskell in later courses?
04:53:05 <Axman6> yeah, a few
04:53:12 <Axman6> 2310 is one i think
04:53:12 <Neut> ~great~
04:53:21 <Axman6> no, that's the concurrent systems one
04:53:31 <Axman6> anyway, one of them i'm doing next semester uses it
04:53:48 <Axman6> Neut: if you need haskell help, i'd be happy to meet up with you in the labs and give you a hand :)
04:53:58 <Neut> are you a tutor?
04:54:19 <Axman6> nah, though i've been told i should be one by one of the other tutors for 1100
04:54:21 <Botje> worse, he'se an axeman ;)
04:54:38 <Axman6> :o
04:54:51 <Neut> Can Axman6: is it ok if I pm you for one moment?
04:54:56 <Axman6> sure
04:55:02 <Neut> also xD @ Botje
04:55:42 <Axman6> have you pm'd me yet? if you have, you're probably not registered, so i'm not getting it
04:55:48 <Axman6> or not, heh
05:00:35 <mgee> hey, how do I create a list with ascending numbers? like [0,1,2,3,4,5,6,7,8,...]
05:00:45 <mgee> ah iterate
05:00:46 <mgee> :D
05:00:47 <Botje> [0..]
05:00:59 <mgee> Botje: even nicer! :)
05:02:14 <Axman6> > [0..]
05:02:15 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:03:53 <Botje> > let i = 0 : map succ i in i
05:03:54 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:04:14 <Botje> > let i = fix ((0:) . map succ) in i
05:04:15 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
05:04:18 <Botje> whee!
05:04:21 <mgee> :D
05:04:37 <Botje> right
05:04:38 <Botje> TO BUSINESS
05:04:41 <Botje> <<
05:07:08 <WorkyBob> when I run this, ghc complains that the module Jam is not found, am I missing something about how to get it to realise that it's right there in the string buffer I hand it? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5212#a5212
05:11:25 <WorkyBob> ah, I see
05:11:28 <WorkyBob> the file has to exist
05:11:33 <WorkyBob> and be older than the time specified there
05:21:43 <endojelly> sometimes ghc, cabal and haskell-platform are rather bitchy during installation
05:23:51 <inbuninbu> maybe there's something i'm not getting (ok, obviously there is), hopefully somebody can help
05:24:25 <inbuninbu> so i have an IO action i want to write
05:24:32 <inbuninbu> that uses a file handle
05:24:56 <inbuninbu> so the type signature might be something like :: Handle -> IO ()
05:25:21 <inbuninbu> and i want to use functions like hPutStrLn
05:26:07 <inbuninbu> but I don't want to have to put the same handle each time i want to write IO to it, i want to make it implicit
05:26:32 <Botje> let write = hPutStrLn handle
05:26:41 <Botje> then just call write instead of hPutStrLn
05:26:42 <inbuninbu> ah!
05:26:45 <ski> in case of a lexical scope
05:27:26 <inbuninbu> however, i want to be able to handle it transparently in subfunctions
05:27:47 <Botje> ah. you're screwed then :]
05:27:53 <inbuninbu> monads?
05:28:10 <inbuninbu> i noticed in Data.Binary, you can run
05:28:39 <endojelly>     Could not find module `System.IO.UTF8':
05:28:39 <endojelly>       There are files missing in the `utf8-string-0.3.4' package,
05:28:39 <endojelly>       try running 'ghc-pkg check'.
05:28:39 <endojelly>       Use -v to see a list of the files searched for.
05:28:39 <endojelly> cabal: Error: some packages failed to install:
05:28:42 <endojelly> WHY
05:28:58 <dcoutts> endojelly: "There are files missing in the `utf8-string-0.3.4' package"
05:29:13 <inbuninbu> runPut PutMethod ouput
05:29:16 <inbuninbu> for example
05:29:35 <endojelly> dcoutts, yes but why. I did what I always do. installed latest stable ghc from a binary tar.bz2, installed haskell-plattform, cabal update. all in ~/local
05:29:35 <dcoutts> endojelly: because you probably deleted the files belonging to the package, but did not unregister the package
05:29:45 <inbuninbu> and in PutMethod you can just chain PutWord8, etc together to make a new functions
05:29:49 <endojelly> dcoutts, no I didn't, I did nothing, I just freshly installed ghc and haskell-platform
05:29:56 <inbuninbu> all combinator-like
05:30:00 <Botje> inbuninbu: you could use a readerT Handle IO
05:30:13 <endojelly> when I do "ghc-pkg check" there's tons of missing files
05:30:19 <endojelly> how could that happen!
05:30:22 <dcoutts> endojelly: then run ghc-pkg check utf8-string as it suggests, see what it finds to be missing
05:30:40 <dcoutts> endojelly: did you ever rm -rf ~/.cabal ?
05:31:19 <endojelly> dcoutts, no, it doesn't work like that. you don't get to specify a package name with ghc-pkg check. you just issue ghc-pkg check and then it tells you about tons of missing files and you're still wondering WHY it suddenly won't install correctly even though it said it did
05:31:33 <endojelly> dcoutts, yes, of course, right before trying to reinstall everything *again*.
05:31:44 <dcoutts> endojelly: ok, so that's why the files are all missing
05:31:58 <inbuninbu> Botje: thanks, i'll check that monad out
05:32:14 <endojelly> dcoutts, no. I did it before I reinstalled cabal. and ghc. and whole haskell-platform, which cabal is part of
05:32:15 <dcoutts> endojelly: the per-user ghc package database is in ~/.ghc/$version/
05:32:37 <endojelly> dcoutts, oooh. finally. that's helpful! I forgot to delete that one. thanks, it seems to work now
05:32:51 <endojelly> very good
05:33:11 <dcoutts> endojelly: so assuming you removed that file then you've got no per-user packages registered any more
05:33:14 <endojelly> happy now, will keep that in mind next time. thanks again dcoutts
05:33:42 <endojelly> dcoutts, yup I just removed ~/.ghc and now it's re-building everything that's missing, that's what I wanted
05:33:55 <endojelly> cabal install agda works now
05:34:04 <dcoutts> good good
05:46:18 <ski> (inbuninbu : "subfunctions" ?)
05:47:09 <inbuninbu> ski: think combinators, like in parsec, where you can write custom Parser actions
05:47:28 <inbuninbu> you can write a Parser that doesn't explicitly take it's input
05:47:30 <Absolute0> What's the difference between (*5) and (5*)?
05:47:41 <inbuninbu> i'm looking at how some other libraries do it now
05:48:06 <ski>   (* 5) x = x * 5
05:48:11 <ski>   (5 *) x = 5 * x
05:48:17 <Absolute0> ah
05:48:24 <Absolute0> thanks :)
05:48:35 <Absolute0> no wonder i was getting the same result
05:48:42 <ski> inbuninbu : ok .. probably monad or applicative, then
05:49:05 <ski> > (/ 5) 2
05:49:06 <lambdabot>   0.4
05:49:09 <ski> > (5 /) 2
05:49:10 <lambdabot>   2.5
05:49:14 <inbuninbu> ski: thanks, that's what i guess i'm having trouble figuring out, but looking at some other code is helping
05:49:18 <Absolute0> yeah
05:49:25 <ivanm> yay for fromIntegral!
05:49:37 <ski> fromIntegral++
05:49:48 <Axman6> @karma fromIntegral
05:49:49 <lambdabot> fromIntegral has a karma of 1
05:50:24 <ivanm> it's really annoying in languages like Python that don't do that
05:51:55 <ski> it might be nice if `IO' allowed change of `stdin',`stout',`stderr' environment in a local extent
05:52:22 <ski> (redirections from/to strings/et.c. could also be nice)
05:53:00 <fasta> ski: like the I/O system of C++?
05:53:12 <ski> maybe, i don't really know C++
05:53:22 <ivanm> ski: redirection in Haskell rather than in the shell?
05:56:08 <ski> i was thinking of `with-input-from-file',`with-output-to-file' of R5RS
05:56:26 <ski> (also often `with-input-from-string',`with-output-to-string')
05:57:23 <ski>   withInputFromFile,withOutputToFile :: FilePath -> IO a -> IO a
05:58:01 <ski>   withInputFromString :: String -> IO a -> IO a
05:58:17 <ski>   withOutputToString :: IO a -> IO (String,a)
05:59:23 <ski> (i suppose one might generalize on redirecting arbitrary handles .. hmm)
06:00:14 <ski> (.. or maybe it's better not to mutate the handles themselves, but just pointers to `stdin',`stdout',`stderr' handles)
06:00:30 <ivanm> dibblego: you still around?
06:00:54 * ski has a few times wanted
06:01:07 <monadic_kid> in common lisp you use dynamic scoping to "redirect" stdn/out/err
06:01:09 <ski>   cointeract :: IO a -> String -> IO (String,a)
06:01:27 <ski> (or something like that)
06:01:49 <Absolute0> how does forever (from Control.Monad) know when to stop?
06:01:56 <ski> yes, this would be dynamic scoping/environment/reader monad/implicit arguments, too
06:02:03 <ski> Absolute0 : no
06:02:09 <Absolute0> ?
06:02:16 <ski> it doesn't stop (by itself)
06:02:36 <monadic_kid> @src forever
06:02:36 <lambdabot> Source not found. Where did you learn to type?
06:02:42 <fasta> I get No instance for (NearZero CReal), but there is a default implementation for NearZero (a type class in the Vec package) when "a" is in the Num class. CReal is in the Num class. Why doesn't it pick up the instance?
06:02:42 <Absolute0> I am reading: http://learnyouahaskell.com/input-and-output#hello-world and the forever doesn't seem to stop in the code but it stops somehow..
06:02:45 <monadic_kid> @src Control.Monad.forever
06:02:45 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:03:14 <Botje> Absolute0: it only stops when you kill the program
06:03:19 <Absolute0> oh
06:03:27 <Absolute0> well thats useless.
06:03:43 <Absolute0> recursive main has more control..
06:03:45 <ski>   forever ma = mb
06:03:47 <Botje> you can also exit it by raising an exception and catching it
06:03:48 <ski>     where
06:03:50 <ski>     mb = do ma
06:03:51 <ski>             mb
06:03:58 <fasta> Absolute0: it has uses
06:04:13 * monadic_kid renames lambdabot to HAL 9000
06:04:15 <ski> Absolute0 : in monads with a notion a failure, it can terminate
06:05:20 <ski> (e.g. expression monads, `ListT m',`MaybeT m',`Either e',`ErrorT e m')
06:05:31 <Botje> don't forget ContT
06:05:54 <ski> i wouldn't exactly say that `ContT' has a notion of failure
06:06:02 <ski> (though it can be simulated, sure)
06:08:49 <PeakerWork> how can it be simulated?
06:09:03 <ski> discarding the current continuation
06:09:34 <ski> or, more generally, transfer control outside the `forever' loop (to maybe later resume inside the loop .. or maybe not)
06:10:41 <ski> every (computable) monad can be simulated in terms of composable continuations
06:11:09 <ski> (and composable continuations is implementable in terms of ordinary non-composable ones, plus a piece of state)
06:11:54 <Coko|Raptor> hey, can someone tell me what !! means.
06:12:01 <ski> look up Representing Monads, and Representing Layered Monads, by Andrzej Filinski
06:12:03 <Botje> :t (!!)
06:12:04 <lambdabot> forall a. [a] -> Int -> a
06:12:19 <Botje> Coko|Raptor: it takes the n-1'th element of a list.
06:12:23 <ski> (Andrzej Filinski's publications <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/>)
06:12:27 <Coko|Raptor> thanks
06:12:29 <fasta> Anyone who speaks Perl? What is a BOF?
06:12:35 <ski> > [0,1,2,3,4,5] !! 3
06:12:36 <lambdabot>   3
06:12:40 <ski> > "hello" !! 3
06:12:41 <lambdabot>   'l'
06:12:45 <Coko|Raptor> great cheers!
06:12:47 <ski> > "hello" !! 1
06:12:49 <lambdabot>   'e'
06:13:02 <Botje> fasta: "birds of a feather" it's a format where everyone brings  along a tiny presentation (15mins max)
06:13:15 <michael__> I have a program: > data Seq a = Emp | Cons a (Seq a) > sum1 Emp = 0 > sum1 (Cons x s) = x + sum1 s. Why does it give me a type error with this: sum1 Cons 5 (Cons 5 Emp)
06:13:33 <Heffalump> you're missing parens
06:13:39 <Heffalump> sum1 (Cons 5 (Cons 5 Emp))
06:14:00 <fasta> Botje: isn't that a horrible experience for both the presenter as the audience?
06:14:03 <michael__> OK cool. Thanks Heffalump
06:15:30 <PeakerWork> @type sum1
06:15:31 <lambdabot> Not in scope: `sum1'
06:15:50 <Axman6> michael__: in what you had, you were passing three arguments to sum1: Cons, x and s
06:16:19 <Axman6> uh, x = 5, s = (Cons 5 Emp)
06:17:27 <fasta> Botje: what kinds of things can you possibly say in 15 minutes? You could introduce some library or other "practical" stuff, but that's it, no?
06:23:53 <marcusb> hi, after I made a per-user installation of a cabal package into $HOME, do I have to run ghci with special flags to make it find the installed modules?
06:24:08 <Axman6> nope
06:24:45 <marcusb> mpfh, but I get a     Could not find module `Language.ASN1.BER'
06:25:47 <dcoutts> marcusb: check with ghc-pkg that the package is registered and what the module it exports is really called, ghc-pkg describe $name
06:26:15 <Botje> fasta: I only get 20 minutes to present my thesis
06:26:36 <marcusb> exposed-modules: Language.ASN1 Language.ASN1.BER (etc...)
06:26:37 <Botje> and 15 minutes is enough to explain the gist of it
06:27:04 <marcusb> (thanks for ghc-pkg, by the way, didn't know about it, "list" shows the package)
06:27:06 <Botje> BOFs  aren't meant to teach something, only to show off something cool you wrote or teach people how to use the Writer monad, for example.
06:27:18 <Botje> s/something/& extensively/
06:27:24 <fasta> Botje: at which university is that?
06:27:30 <marcusb> ah
06:27:33 <Botje> vub.ac.be
06:27:37 <marcusb> sorry, I should restart ghci in the emacs
06:28:07 <marcusb> import works now! (:m + at the command line is still fishy, I think)
06:28:17 <marcusb> ah no
06:28:19 <marcusb> everything good
06:28:22 <marcusb> strange
06:28:22 <Botje> fasta: if you search around for "bird feather presentation" i'm sure you'll find some stuff
06:28:31 <Botje> (or just bof presentation)
06:28:43 <Botje> fasta: did you ever go to FOSDEM?
06:28:52 <Botje> they have lightning talks which are also 15 mins each
06:29:22 <fasta> Botje: no, I am not really much of a conference visitor, but I might go when they would be really close.
06:29:25 <Botje> and 15 minutes is plenty of time for showing off what your project is, what's cool about it and even how it works
06:31:08 <fasta> Botje: yes, that's what I figured. Shiny pictures and people saying "oooh" ;)
06:31:56 <Botje> that's what it's all about
06:32:13 <Botje> and if you find it interesting enough  you strike up a conversation with the presenter later on
06:32:24 <Botje> or just ask a few questions at the end
06:32:32 <Botje> fun stuff, lightning talks :)
06:33:19 <fasta> I think I would enjoy one of Zed Shaw's (?) talk for the entertainment value ;)
06:38:12 <Botje> there's a lot of interesting talks on google video, if you want
06:38:33 <Botje> most of them are ~1hr though, so don't click open too much :P
06:39:17 <fasta> Botje: I watched a video about Qi yesterday, which was sort of interesting. Qi is interesting, because it already has or will have a formal semantics.
06:40:23 * Botje notes
06:40:33 <Botje> i'll take a look when i don't have a thesis due in less than a week ;)
06:41:28 <fasta> Botje: fun times ;)
06:52:18 <michael__> What is the difference between => and -> when writing function types?
06:53:43 <doserj> => has nothing to do with functions. it is just for type-class constraints
06:53:54 <michael__> ok thanks
06:54:16 <doserj> @type 0
06:54:17 <lambdabot> forall t. (Num t) => t
06:55:14 <michael__> just defines a constraint on that particular type then. Can you do (Num t) => (Num c) => t -> c?
06:55:39 <doserj> that would be written (Num t, Num c) => t -> c
06:55:39 <dev31212> Nah
06:55:52 <dev31212> (Num c, Num t )=>
06:55:56 <michael__> ok. thanks u guys
06:56:03 <michael__> and girls...
06:56:31 <dev31212> Sometimes it gets confusing what is a class, and what is an instance of a class
06:56:45 <dev31212> I wish that was a bit more straightforward
06:56:51 <dev31212> I guess you just have to memorize them all?
06:57:11 <michael__> Example?
06:57:24 <dev31212> Like remembering Fractional, Int, Num, etc
06:57:27 <dev31212> all the various classes
06:57:30 <dev31212> Its not a huge deal
06:57:33 <dev31212> I was thinking out loud :))
06:58:00 <dev31212> Like if classes all were prefixed with a _ or something
06:58:13 <dev31212> that would simplify it...but thats not going to happen..so not point in my talking about it
06:58:14 <doserj> dev31212: there is no syntactic distinction between type names and class names, yes, that's sometimes unfortunate
06:58:18 <walter_> how can I write something like this ?     filter ((<3)||(>5)) [1..10]  I dont know how to use || in filter, thanks
06:58:27 <michael__> does anyone know M.Mataric?
06:58:45 <zachk> walter_: do you know about lambdas?
06:58:51 <dev31212> yeah doser.
06:59:03 <walter_> zachk, yeah
06:59:24 <zachk> walter_: use a lambda or go pointfree but that is beyond me
06:59:47 <doserj> > filter (liftM2 (||) (<3) (>5)) [1..10] -- pointfree
06:59:49 <lambdabot>   [1,2,6,7,8,9,10]
07:00:13 <walter_> doserj, great!
07:00:48 <doserj> walter_: that needs the (->) r Monad instance, though, which is not quite standard
07:01:10 <dev31212> So anyone working on any cool projects?
07:01:15 <walter_> dosery, I see.
07:01:21 <dev31212> That they would like to talk about? brag about?
07:01:21 <dev31212> etc
07:05:12 <doserj> > filter (uncurry (||) . ((<3) &&& (>5))) [1..10] -- pointfree, using the -> arrow instead of the (->) r monad
07:05:13 <lambdabot>   [1,2,6,7,8,9,10]
07:10:38 <LeCamarade> I wonder how to deal with deadlocks that I see, yet I'm not taking any explicit locks.
07:10:50 <LeCamarade> I use only MVars and Chans and I get deadlocks.
07:15:15 <Saizan> a MVar is not that far from a lock
07:15:32 <Twey> And a Chan is a bunch of MVars
07:37:55 <LeCamarade> I think I have many MVars. I wonder how to chase up the cause of the deadlock exception.
07:38:25 <LeCamarade> I'll end up being mad: doing the same thing over and over, expecting different results. Heh. Threads.
07:41:17 <mmorrow> , ppDoc <$> (let a |>>=| (p,b) = [|$(return a) >>= $(LamE [p] <$> b)|]; undo (DoE ss) = go ss; go [] = [|return|]; go [NoBindS e] = return e; go (NoBindS e:ss) = e |>>=| (WildP, go ss); go (BindS p e:ss) = e |>>=| (p, go ss); go (LetS decs:ss) = LetE decs <$> go ss in undo =<< [|do (f,m) <- ask; a <- m; set (f a); join m|])
07:41:19 <lunabot>  ask >>= (\(f_0,
07:41:19 <lunabot>             m_1) -> m_1 >>= (\a_2 -> set (f_0 a_2) >>= (\_ -> join m_1)))
07:42:10 * mmorrow just had to write that and was surprised how (relatively) straightforward it was
07:43:22 <byorgey> mmorrow: nice =)
07:43:30 <mmorrow> and it's cool how you mirror the quoted syntax with the non-quoted (or whatever) syntax
07:44:24 <mmorrow> , src 'DoE
07:44:27 <lunabot>  data Exp = ... | DoE ([Stmt]) | ...
07:44:27 <lunabot>  infixl 9
07:44:29 <mmorrow> , src ''Stmt
07:44:32 <lunabot>  data Stmt = BindS Pat Exp
07:44:32 <lunabot>            | LetS ([Dec])
07:44:32 <lunabot>            | NoBindS Exp
07:46:18 <mmorrow> i've also broken down and started using <$>, and i like it :)
07:49:02 <mxc> mmorrow - i had the same experience..  wouldn't call it 'broken down' as mcuh as 'learned about applicative functors and monads and realized how dumb it was of me to not be using it
07:50:05 <mmorrow> mxc: i was mostly refusing because i didn't want to have to write the import in all my modules, and because the class name is long which annoys me :-)
07:50:09 <mmorrow> "call me crazy"
07:50:13 <mmorrow> ;)
07:50:32 <mmorrow> mxc: but really though, yeah they're nice
07:51:19 <mmorrow> i like the
07:51:40 <mmorrow> foo <$> a <*> b <*> .... <*> c
07:51:43 <mmorrow> pattern a lot
07:52:17 <mxc> it would be nice if you could sort of add a global import via ghc option
07:52:50 <mxc> so you could just set in your .cabal file a ghc option to implicitly import something to every file
07:53:43 <mmorrow> yeah that would be nice
07:53:50 <mmorrow> in ghci you can use your .ghci
07:53:59 <mmorrow> but not for loaded mods..
07:54:55 <mmorrow> typing "import Data.Map(Map)\nimport qualified Data.Map as M\nimport Data.IntMap(IntMap)\nimport qualified Data.IntMap as IM\nimport Data.Monoid(Monoid(..))"
07:55:00 <mmorrow> starts to get old quick
07:55:22 <mmorrow> even though you start to be able to type it /really/ fast
07:56:00 <mxc> i just add vim mappings
07:56:21 <mmorrow> good point
07:57:51 <gwern> @quote slow.*as
07:57:51 <lambdabot> shapr says: < shapr> the snow falls slowly / the lambdas are lifting - / weak head normal form.
07:57:57 <gwern> @quote slow.*as
07:57:57 <lambdabot> roconnor says: Damn it, I don't know how to make this as slow as python.
07:58:07 <gwern> @quote register.*it
07:58:07 <lambdabot> No quotes match. stty: unknown mode: doofus
07:58:10 <mxc> to automatically put in the module declaration, common imports etc
07:58:22 <gwern> @remember koeien Let's register it [monomorphismrestriction.com] to prevent it from being used ;)
07:58:22 <lambdabot> Nice!
07:58:31 <gwern> @quote air.*travel
07:58:31 <lambdabot> No quotes match. You type like i drive.
07:58:35 <mxc> also, haskell mode for vim has a shortcut to add the import statement for whatever is under the cursor - huge timesaver
07:58:41 <gwern> @remember Elly Rule 1 of malloc is the same as rule 1 of air travel: "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
07:58:41 <lambdabot> It is forever etched in my memory.
07:58:47 <gwern> @quote sensible
07:58:47 <lambdabot> augustss says: ghc had a bug once where it deleted the source file if it had a type error. Quite sensible, I think.
07:58:50 <FunctorSalad> isn't "import qualified Data.Map" a good case for abusing typeclasses for overloading?
07:58:50 <gwern> @quote sensible
07:58:51 <lambdabot> monochrom says: I was trying to design a sensible language... then I downloaded ghc.
07:59:02 <gwern> @quote Kleene
07:59:02 <lambdabot> conal says: The C ADT is implemented simply as String (or char *, for you type theorists, using a notation from Kleene)
07:59:12 <gwern> @quote suspicious
07:59:12 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
07:59:27 <gwern> @remember WillDonnelly monads are okay after a bit (though I'm still a little suspicious of them)
07:59:27 <lambdabot> I will remember.
07:59:30 <gwern> @flush
08:01:44 <mmorrow> mxc: i need to spend the time to get a bunch of common bits mapped to various various keys seqs in some organized manner
08:03:38 <FunctorSalad> mmorrow, do you use emacs? I found yasnippets nice
08:03:48 <mmorrow> vim
08:04:24 <mxc> mmorrow do you use haskellmode.vim?
08:04:27 <mxc> very very helpful
08:04:51 <mmorrow> mxc: i've played with it briefly for the first time the other week
08:05:26 <mmorrow> i should pick it up again
08:06:24 <mxc> you hsould
08:06:26 <mxc> its worth it
08:07:07 <mxc> here are some of my additiosn to .vimrc with htat though:
08:07:10 <mxc> map _m :wa\|:make!<CR>
08:07:19 <mxc> au Bufenter *.hs map _w :call setline(1,'module '.bufname("%").' where')\|1,1s/.hs//g\|1,1s#/#.#g<CR>
08:07:41 <mmorrow> cool
08:07:57 <mxc> in ghc.vim:
08:07:58 <mxc> au Bufenter *.hs map _w :call setline(1,'module '.bufname("%").' where')\|1,1s/.hs//g\|1,1s#/#.#g<CR>
08:08:00 <mxc> oops
08:08:06 <mxc> execute 'setlocal makeprg=' . g:runghc .'\ Setup.hs\ build'
08:08:15 <mxc> execute 'map _c :!' . g:runghc . ' Setup.hs configure --user;<CR>'
08:08:38 <mxc> so its all cabalized, and _c is a shortcut to run the configure phase
08:09:00 <mxc> just keep my working directory at the top level of the code
08:09:16 <shapr> @quote g.*h
08:09:16 <lambdabot> <luqui> says: sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
08:10:36 <mxc> hm
08:10:41 <mxc> is drift dead
08:11:15 <mxc> drift and derive, both dead...  one is slick with TH, the other is slick with having XmlContent built in..
08:11:40 <mxc> anyone have any best practices for semi-human-readable [de]serialization
08:11:41 <mxc> ?
08:11:49 <mxc> or just do it all by hand :(
08:12:06 <Absolute0> A b c d preferred over A {b = b', c = c', d = d'}?
08:12:09 <Twey> deriving (Show, Read)?
08:12:27 <Twey> Absolute0: Not really
08:12:28 <FunctorSalad> impossible for non-h98 :-(
08:13:00 <Absolute0> Twey the latter is better?
08:13:04 <Twey> Absolute0: If you mix and match the two styles, you're depending on the order of the record not changing
08:13:05 <FunctorSalad> Absolute0: -XNamedFieldPuns, A{b,c,d}
08:13:21 <FunctorSalad> (will use local variables called b,c,d)
08:13:26 <Twey> Oh, that's nice
08:13:29 <mxc> twey - IIRC thats not really robust though, not really guaranteed that show . read = id
08:13:46 <Twey> mxc: It is with the derived instances
08:13:51 <Twey> (AFAIK)
08:13:57 <Absolute0> FunctorSalad: huh?
08:13:59 <FunctorSalad> do you really need show . read = id? read . show = id, yes
08:14:12 * Twey nods.
08:14:15 <FunctorSalad> show . read should just be idempotent
08:14:42 <FunctorSalad> (which follows from read . show = id)
08:14:56 <Absolute0> is a list with key value records an effecient way of implementing hashmaps in haskell?
08:15:13 <Twey> No
08:15:18 <Absolute0> I retrieve values by iterating over the whole list until a key is matched.
08:15:21 <mxc> functorsalad - should, but i thought that using it for [de]serialization was explicitly discouraged
08:15:22 <Botje> Absolute0: that would be Data.Map :)
08:15:27 <Twey> It makes lookup O(n) worst-case
08:15:41 <Twey> Yeah, Data.Map is O(log n)
08:15:55 <Absolute0> Twey: lookup _is_ O(n) in my case
08:16:02 <Absolute0> oh nice
08:16:07 <FunctorSalad> mxc: I read that too, but I'm not sure why (except that it relies on the libraries you use having (read . show = id))
08:16:23 <Twey> Absolute0: Only if the item you want to look up is at the end of the list
08:17:12 <FunctorSalad> (maybe there should be one class for text [de]serialization, and one for nice debug output)
08:17:14 <mxc> the HXT library seems to have a very, very safe way of serializing to XML
08:17:38 <mxc> but, no derive/DriFT support
08:19:06 <mxc> started to look at adding a derive XmlPickler (from HXT) to Data.Derive, but gave up...
08:19:10 <FunctorSalad> mxc: you could consider using syb, but I don't know how viable this is
08:19:37 <mxc> Data.Derive is not the easiest thing to understand from the code..  ndm is kind of too clever, can be difficult to follow...
08:19:42 <FunctorSalad> (probably start with the code of the "gshow" function)
08:21:19 <Absolute0> Twey: is it worthwhile to use Data.Map when my map is at most of size 32?
08:21:41 <Twey> Absolute0: Probably not
08:21:47 <Absolute0> Twey: but I may have many of those maps of size 32 being compared in parallel :)
08:22:25 <Twey> But it might be if it's going to be used in a computationally-expensive environment.
08:22:36 <Absolute0> ^^
08:24:46 <Twey> It's not hard to switch later if you decide you need more performance.
08:25:26 <Absolute0> Instead of having a tuple of an id followed by values i now need a tupe of an id and a tuple of the rest
08:27:18 <Twey> What else would you have?
08:27:24 <Twey> :t lookup
08:27:25 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:27:57 <Absolute0> thanks anyways
08:28:06 <cogno> :t lookup1
08:28:07 <lambdabot> Not in scope: `lookup1'
08:28:26 <Absolute0> The way i was doing it is by comparing a value withing a tuple
08:28:40 <Absolute0> which is part of the tuple data structure
08:28:50 <Absolute0> repeating that in key does seem so nice
08:28:52 <saml> hey Absolute0
08:28:57 <Absolute0> hey
08:29:24 <saml> bloomberg doesn't care for haskell.
08:29:32 <Absolute0> ?
08:29:52 <Absolute0> bloomberg?
08:30:07 <ski> @google bloomberg doesn't care for haskell
08:30:09 <lambdabot> http://dyn.politico.com/blogs/dinnerdish/index.cfm/category/Thursday
08:30:09 <lambdabot> Title: Dinner Dish: Thursday - POLITICO.com
08:30:26 <ski> .. maybe not
08:39:03 <saml> > 00087
08:39:04 <lambdabot>   87
08:44:55 <walter_> I import Text.HTML.TagSoup but I find Text.HTML.TagSoup.Match wasn't imported, do I have to import Text.HTML.TagSoup.Match seperately?
08:48:20 <Saizan> walter_: there's no direct relation between the two
08:48:21 <MyCatVerbs> walter_: that should do it.
08:48:26 <Saizan> so yes
08:49:16 <walter_> but from hoogle, I find that Text.HTML.TagSoup.Match just indent under the Text.HTML.TagSoup
08:50:01 <walter_> Saizan, so I have to. Thanks.
08:57:22 <Eelis> do i understand correctly that the cabal-install command-line interface for Cabal isn't actually shipped with Cabal itself?
08:57:55 <Eelis> and in particular, that while Cabal itself is shipped with ghc, cabal-install isn't?
08:58:00 <dcoutts> Eelis: The package "Cabal" and the package "cabal-install" are separate.
08:58:06 <hackagebot> multirec-binary 0.0.1
08:58:12 <Eelis> dcoutts: ok, is there a specific reason for this?
08:58:31 <FunctorSalad> hello hackagebot
08:58:38 <dcoutts> Eelis: yes, they were developed at different times, have different levels of maturity and have different dependencies.
08:58:57 <hatds> @pl \x -> (x,x)
08:58:58 <lambdabot> join (,)
08:59:00 <Eelis> dcoutts: i see. has there been any work toward getting cabal-install shipped with ghc?
08:59:20 <dcoutts> Eelis: we call it the Haskell Platform, which includes ghc, cabal-install and various libs.
08:59:48 <Eelis> dcoutts: ah, ok. great, then i look forward to seeing that deployed widely :) thanks
09:00:11 <dcoutts> Eelis: the first version has been released, you can ask your distro to get on with it! :-)
09:00:45 <Eelis> dcoutts: i just might :)
09:03:50 <matrix> i have a mobile phone software box ,using that i cant install os to mobile phones
09:03:53 <mreh> can you take inverses of haskell functions?
09:03:58 <matrix> plz help me with this
09:04:07 <mreh> not unless their bijective i suppose
09:04:14 <mreh> they're
09:04:19 <Heffalump> matrix: running Haskell?
09:04:19 <bavardage> mreh: what, take inverses automatically?
09:04:37 <Heffalump> there's some work on automatically construction functions together with their inverses, IIRC
09:04:48 <DrSyzygy> mreh: What would you expect the inverse of head to be? The inverse of fst? The inverse of (^2) ?
09:04:56 <DrSyzygy> Heffalump: Sounds cool.
09:05:03 <bavardage> (^2) is easy :D
09:05:07 <mreh> DrSyzygy: well yes indeed
09:05:09 <DrSyzygy> bavardage: Is it?
09:05:10 <bavardage> the others, non
09:05:16 <mreh> inverse of ^2, lol
09:05:17 <bavardage> DrSyzygy: the standard sqrt?
09:05:23 <mreh> um... sqrt
09:05:26 <bavardage> yes I know the issues about +-
09:05:29 <DrSyzygy> bavardage: Why is that better than negative sqrt?
09:05:31 * FunctorSalad once coded a Data.Map that keeps track of preimages
09:05:32 <bavardage> but just constrain to +
09:05:35 <bavardage> as is the convention
09:05:50 <Gilly> So, I'd like to produce a lazy list of repeated IO Action. Any ideas how to accomplish this? (I'd need to be able to do something like res <- repeat (readLn :: Int) ; print $ take 5 res)
09:05:50 <bavardage> well, with the sqrt on my calculator, it doesn't ask me every time if positive or negative
09:05:53 <bavardage> same with sin^-1
09:06:04 <bavardage> it doesn't ask me which result I want
09:06:06 <Heffalump> http://www.st.cs.ru.nl/papers/2005/alia2005-biarrowsHaskellWorkshop.pdf
09:06:07 <bavardage> it gives me the principal
09:06:12 <mreh> inverse of sin, yeah, they aren't bijective functions
09:06:18 <DrSyzygy> The point here is that (^2) gives a double cover, and hence you cannot possibly get a sensible derivative without some arbitrary choice, and my question is for all of these why we expect Haskell to be able to do that.
09:06:36 <FunctorSalad> preimage maps are nice if you have labeled disjoint sets of stuff, and want to look up the set for a label quickly, and the label for an element :)
09:06:42 <DrSyzygy> We could make inverses for head and fst the same way - by picking, say, (:undefined) and (,undefined)
09:07:49 <DrSyzygy> But these are all not quite inverses, only almost. - one way around they do invert; for a restricted domain - but
09:08:04 <FunctorSalad> even if the function is bijective, inversion can be uncomputable...
09:08:12 <FunctorSalad> hmm or wait
09:08:16 <shapr> hej michi!
09:08:20 <DrSyzygy> yo shapr
09:08:21 <FunctorSalad> not if the function itself is computable
09:08:40 <FunctorSalad> but it can be arbitrarily complex, I guess
09:09:18 <NEEDMOAR> FunctorSalad: uhm. How do you see that?
09:09:38 <Gilly> hum, do i, perhaps, need unsafeInterleaveIO for this?
09:09:42 <NEEDMOAR> Uhm.
09:09:46 <NEEDMOAR> Yeah, nevermind.
09:09:55 <Philippa> Everybody: I just posted to haskell-cafe about getting an Anglohaskell run this year, can anyone interested take a look and respond please?
09:09:58 <DrSyzygy> bavardage: For arcsin the issue is even hairier. For sqrt, we can at least agree that we like for the principal answer to be within (0,inf). But which domain do you pick for the principal arcsin, and why? Is (0,2pi) better or worse than (-pi,pi) and why?
09:10:01 <FunctorSalad> NEEDMOAR: the first part? if it's bijective and computable (with r.e. domain), given an element of the codomain, just search through all elements of the domain
09:10:07 <NEEDMOAR> Yep.
09:10:14 <mreh> Cale: was it you who suggested to me a better GUI library?
09:10:18 <bavardage> DrSyzygy: I agree there are difficulties
09:10:20 <mreh> I think I want to change
09:10:30 <bavardage> DrSyzygy: but I'm saying in many cases one can just go with convention
09:10:33 <DrSyzygy> FunctorSalad: Doesn't that mean you need finite domains?
09:10:42 <mreh> @seen Cale
09:10:43 <lambdabot> Cale is in #haskell-in-depth, #ghc, #haskell-overflow and #haskell. I last heard Cale speak 7h 50m 9s ago.
09:10:51 <DrSyzygy> bavardage: And I'm saying that "Go with convention"  is an ill-defined concept, and therefore not something that one can easy build automation on.
09:10:58 <bavardage> yeah
09:11:00 <NEEDMOAR> FunctorSalad: do you have idea if primitive recursive functions (with no minimizer) have this property as well?
09:11:20 <roconnor> Is Alan Kay's "Worlds: Controlling the scope of side effects" paper worth reading?
09:11:25 <bavardage> I'd imagine automating the inverses of functions is pretty difficult anyway
09:11:40 <bavardage> I guess just restricting it to bijective functions would be easiest
09:11:45 <mwc> Anybody written a firefox bookmarklet to reference haddock documentation of all locally installed packages? ie, docs in /usr/share/doc, ~/.cabal/share/doc, etc
09:11:56 <bavardage> and so for things like sin, you'd create a bijective sin first and pass that
09:12:31 <DrSyzygy> bavardage: And then FunctorSalad's points of arbitrary complexity start becoming relevant...
09:12:39 <bavardage> yop
09:12:43 <duaneb> man
09:12:44 <NEEDMOAR> bavardage: if you construct the bijective functions by using composition of bijective functions, it would be easy.
09:12:48 <duaneb> optimizing haskell is hard :(
09:12:59 <bavardage> but then you have issues with infinite domains, surely?
09:13:12 <bavardage> which would be icky
09:13:35 <FunctorSalad_> <DrSyzygy> FunctorSalad: Doesn't that mean you need finite domains?<FunctorSalad> DrSyzygy: why? assuming the func. is bijective, you will eventually find the preimage
09:13:56 <DrSyzygy> FunctorSalad: What does _eventually_ even mean for infinite domains then?
09:14:18 <duaneb> can anyone help me optimize this function here?
09:14:19 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5215#a5215
09:14:22 <NEEDMOAR> FunctorSalad_: do you have idea if primitive recursive functions (with no minimizer) have this property as well?
09:14:31 <duaneb> it's eating up ~2/3rds of my entire program :|
09:15:48 <isaacd> duaneb: 1. call it less often?  2. what if Color has {-#UNPACK#-} before each of the !Doubles ?
09:16:33 <FunctorSalad_> DrSyzygy: I just mean that this algorithm for computing the inverse of f will be total, if f is total and bijective (surjective being enough, actually)
09:16:41 <FunctorSalad_> maybe my statement is too trivial :)
09:16:44 <DrSyzygy> Oh, okay...
09:16:50 <FunctorSalad_> it's just true by def of surjectivity
09:17:10 <duaneb> isaacd: doesn't make a difference
09:17:15 <mwc> duaneb: are you calling this function for every single pixel in a presumably large raster?
09:17:22 <duaneb> I use -funbox-strict-fields
09:17:26 <duaneb> mwc: yes
09:17:33 <mwc> what is the raster being stored as?
09:17:35 <duaneb> a few million times, actually
09:17:38 <mwc> figured
09:17:48 <duaneb> mwc: what do you mean?
09:17:55 <isaacd> how do you use the result tuple?
09:17:57 <mwc> [Pixel], Array, UArray?
09:17:59 <FunctorSalad_> NEEDMOAR: hmm, not sure I understand... which property? the searching algorithm clearly won't work unless the function is surjective
09:18:07 <duaneb> I store it into a file
09:18:09 <duaneb> hold on
09:18:23 <duaneb> this is the bad line: writeTarga (Targa width height $ map pixel $ map (\r -> raytrace r objects 1) (rays width height)) "foo.tga"
09:18:45 <mwc> Yeah, but what type is the image?
09:18:50 <duaneb> a Targa
09:18:53 <duaneb> I write it myself
09:18:55 <mwc> no, in haskell
09:19:05 <mwc> what do you have as your datatype for the image
09:19:12 <mwc> as in, what are you representing the raster with?
09:19:31 <thoughtpolice> copumpkin: ping
09:19:32 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5217#a5217
09:19:46 <mwc> I think your problem might be high overhead in that map
09:19:51 <duaneb> ahh
09:19:57 <roconnor> hmm
09:20:08 <roconnor> shouldn't duaneb's  list be deforested?
09:20:20 <mwc> it doesn't look to me like you could squeeze much more out of your pixel routine
09:20:21 <isaacd> not if it's in a 'data' ?
09:20:23 <mux> dcoutts: ping
09:20:30 <roconnor> maybe writeTarga needs to be inlined?
09:20:34 <dcoutts> mux: pong
09:21:02 <mux> dcoutts: the "workaround" I described at great length on haskell-cafe@ for building the docs like I wanted didn't work on hackage :-(
09:21:21 <dcoutts> mux: any clues from the build log?
09:21:42 <mux> dcoutts: nope, but it *seems* the sources aren't getting re-processed
09:21:48 <duaneb> I guess
09:22:00 <mux> dcoutts: I was considering adding debug output and upload a new version just to see what happened but I'd hate that...
09:22:04 <duaneb> the profile says that most of the program is spent IN pixel
09:22:15 <roconnor> duaneb: your use of min instead of max is bizarre
09:22:16 <duaneb> is this because it can't be inlined in map?
09:22:20 <dcoutts> mux: you could take this opportunity to ask Ross to post the code
09:22:28 <mux> dcoutts: right, good idea
09:22:29 <duaneb> roconnor: well, I want the min....
09:22:38 <thoughtpolice> dcoutts: maybe i should ask in #ghc but, can we expect full shared lib support in 6.12? i'm wondering because it's been a long time coming...
09:22:46 <FunctorSal> sorry guys, my connection is foiling this discussion again
09:22:56 <dcoutts> thoughtpolice: depends on what you mean by "full" :-)
09:22:57 <thoughtpolice> (full as in works on OS X, linux, windows etc.)
09:23:05 <dcoutts> thoughtpolice: oh, in that case no.
09:23:42 <thoughtpolice> dcoutts: ah, so linux only atm?
09:23:51 <duaneb> roconnor: if I don't use min, then the color will overflow and wrap around
09:24:03 <duaneb> i.e. a color that was 1.2 will become 0.2
09:24:06 <roconnor> duaneb: ah right.  Sorry. I'm dumb
09:24:13 * roconnor goes to eat
09:24:18 <isaacd> duaneb: the profiling might be "wrong" and include the ray computations (because pixel is strict?)
09:24:39 <isaacd> not sure
09:24:56 <isaacd> I've heard that profiling Haskell can be misleading
09:25:23 <duaneb> uhoh
09:25:30 <duaneb> that's NOT good :P
09:26:09 <mwc> Hmm, that's a good point. Could you manually add a cost center for pixel? would that help?
09:26:22 <jeffwheeler> Is it possible/acceptable to run a lambdabot off of c.h.o?
09:26:40 <thoughtpolice> dcoutts: if so, I think any good support (i.e. passes validate etc.) even if it's for only one platform is better than none
09:27:03 <dcoutts> thoughtpolice: yes, OSX is doable but someone has to do the remaining work.
09:27:03 <duaneb> mwc: that's what I'm doing right now
09:27:26 <dcoutts> thoughtpolice: and I expect you're also assuming some level of support from Cabal etc
09:27:30 <jeffwheeler> that is, community.haskell.org
09:27:46 <duaneb> wait, this is calculated lazily, right?
09:27:59 <dcoutts> thoughtpolice: current status is here: http://blog.well-typed.com/2009/05/buildings-plugins-as-haskell-shared-libs/
09:28:06 <duaneb> it computes the ray -> color -> pixel -> into the targa, and then goes onto the next ray
09:29:27 <duaneb> strange
09:29:32 <duaneb> mwc: with this paste http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5215#a5218
09:29:42 <duaneb> it's now 70% !r
09:30:17 <Stephan202> @pt every f xs = liftM (all id) $ sequence $ map f xs
09:30:17 <lambdabot> Maybe you meant: ft pl
09:30:21 <Stephan202> @pl every f xs = liftM (all id) $ sequence $ map f xs
09:30:21 <lambdabot> every = ((fmap and . sequence) .) . map
09:30:41 <mux> sometimes I feel I'm the only developer on earth to have never ever coded a raytracer
09:31:27 <duaneb> heh
09:32:41 <isaacd> duaneb: you could also have 'data ColorWord8' or such, instead of your tuple, so that the values wouldn't need to be re-boxed before being output
09:32:48 <mmorrow> what's the/an algo for all closed paths in a graph given a vertex?
09:32:57 <duaneb> isaacd: yea, that's what I suspect the problem is, actually
09:33:04 <mmorrow> so i guess "circuits" or i'm not sure the lingo
09:33:08 <duaneb> because pixel also has a large portion of the allocations
09:33:12 <SamB> mmorrow: those are countable ?
09:33:21 <mmorrow> SamB: they are in my graphs
09:33:45 <SamB> what about loops ???
09:33:50 <mmorrow> SamB: (dependency graphs of datatypes)
09:34:04 <PeakerWork> mux: I think you're right :)
09:34:16 <PeakerWork> mux: we were the last 2 but I wrote one about 8 months ago :)
09:34:18 <mmorrow> SamB: i've already got those, i need to know all possible (non-trivial) paths back to a vertex
09:34:30 <mux> PeakerWork: hehehe
09:35:07 <mmorrow> SamB: err, so i want to find all ways back to a *single* vertex starting from it
09:35:24 <mmorrow> (not all possible closed paths from every vertex back to itself)
09:36:21 <mmorrow> i guess it's just running a reachable and keeping track of the paths when you see the origin again..
09:36:21 <mmorrow> i feel like this one has a name though..
09:36:56 * duaneb notes that he actually is a graphics person
09:37:05 <DrSyzygy> mmorrow: Based loops?
09:37:30 <duaneb> I've written more reyes renderers
09:39:57 <mmorrow> DrSyzygy: hmm, i think so
09:40:24 <DrSyzygy> mmorrow: You're looking for cycles that are forced to contain one single vertex?
09:40:35 <DrSyzygy> one specific vertex
09:40:42 <mmorrow> this looks like it's a way NP complete problem in the general case from google, but my graphs are small and far from complete graphs on n-verts
09:41:25 <DrSyzygy> mmorrow: I would probably floodfill the graph from that vertex and keep track of paths and look for reoccurrences of the base vertex.
09:41:29 <mmorrow> DrSyzygy: ohhh, i see. so given a vertex, i want to find all paths back to that vertex
09:41:35 <DrSyzygy> But then I know almost nothign of algorithmics...
09:42:17 <mmorrow> DrSyzygy: that sounds reasonable to me, just find all reachable nodes, and during the process keep track of the paths so you can record them whenever you hit the origin
09:42:23 * mmorrow tries that
09:42:56 <byorgey> that sounds like it might miss some possible paths.
09:43:01 <byorgey> if you wanted to generate all of them.
09:43:32 <mmorrow> i want to /find/ all of them (is this different than generate?)
09:43:48 <mmorrow> hmm, how could it miss some? (i'm not sure)
09:44:08 <mmorrow> ooh, i think i see
09:44:43 <duaneb> you know what's really hard?
09:44:44 <duaneb> graphs
09:44:45 <duaneb> and haskell
09:44:45 <mmorrow> (a --> b), (b --> c), (b --> d), (d --> a), (a --> d)
09:44:47 <duaneb> together
09:44:58 <mmorrow> duaneb: no way, graphs are easy in haskell :)
09:45:05 <duaneb> nah
09:45:14 <duaneb> no way to do them efficiently without state
09:45:18 <duaneb> and state is not fun in haskell :P
09:45:25 <mmorrow> IntMap IntSet
09:46:13 <lament> The State Of Haskell
09:46:24 <lament> is eternal and immutable!! All hail the Monad!
09:46:41 <Beelsebob> mmorrow: how do you do union on that and retain the identifiers of the nodes?
09:46:49 <lament> We were always at war with the Land of Lisp!
09:47:20 <mmorrow> Beelsebob: it depends what you want to happen when you "union"
09:47:27 <DrSyzygy> mmorrow: Loops based in a? From a go to b and d, register [b],[d] respectively. Recurse. From b go to c, with [b,c], and to d with [b,d]. From d go to a with [d,a] and add this to your master list of loops. From c, return nothing. From d, go to a with [b,d,a] and return this.
09:47:50 <DrSyzygy> Now you've exhausted all recursions, and you're done with the complete list being [[d,a],[b,d,a]]
09:47:55 <Beelsebob> mmorrow: I want to retain all the important data and all the edges between them â€“ I'm assuming that the Int id is purely internal
09:48:05 <mmorrow> DrSyzygy: hmm, interesting
09:48:27 <dcoutts> @seen blackh
09:48:27 <lambdabot> blackh is in #haskell. I don't know when blackh last spoke.
09:48:37 <dcoutts> @localtime blackh
09:48:49 <mmorrow> Beelsebob: what is your desired result of (a --> {b,c}) `union` (a --> {c,d}) ?
09:48:57 <ski> lament :D
09:49:01 <DrSyzygy> mmorrow: The idea is to recurse down every arrow you can reach, logging as you go, and stopping your recursion when either outdegree=0 or the newly reached node is equal to the basepoint.
09:49:12 <Beelsebob> mmorrow: a --> {b,c,d}
09:49:15 <mmorrow> (mine is (a --> {b,c,d})
09:49:26 <mmorrow> Beelsebob: ok, then what's the problem? :)
09:49:45 <Beelsebob> mmorrow: the fact that you have to go comparing all the values in the IntMap to find the nodes that need to be merged
09:49:58 <Beelsebob> because after all, the Int ID is only an internal construct
09:50:06 <mmorrow> DrSyzygy: ooh, that sounds like it could work
09:50:13 <Beelsebob> bbiab... dinner's done
09:50:31 <DrSyzygy> mmorrow: What ELSE would anyone ever want to do to solve that problem? *mystified*
09:50:41 <ski> (DrSyzygy : that's loop-avoiding traversal, yes ?)
09:50:45 <mmorrow> Beelsebob: the Ints are uniquely associated with whatever you have at the nodes
09:50:51 <DrSyzygy> ski: Loop-avoiding??
09:51:05 <DrSyzygy> ski: This is an attempt to FIND loops...
09:51:07 <mmorrow> Beelsebob: if two nodes are equivalent, they have the same Int (and are the same node)
09:51:08 <DrSyzygy> Though ... wait ....
09:51:21 <Beelsebob> mmorrow: how do you maintain that across *all* graphs you create?
09:51:24 <DrSyzygy> ski has a point. This method needs some extra stuff to avoid running around OTHER loops eternally.
09:51:24 * ski hasn't followed the discussion from the beginning
09:51:49 <mmorrow> Beelsebob: i map the nodes to Ints :)
09:52:03 <mmorrow> Beelsebob: (i'm clearly not seeing the context you have in mind here..)
09:52:08 <ski> DrSyzygy : yeah, but you'd just check the incremental part of each path you've created, to see that the next node isn't already visited, no ?
09:52:15 <DrSyzygy> ski: Exactly.
09:52:22 <DrSyzygy> Unless you WANT those.
09:52:35 <Beelsebob> mmorrow: suppose I create one graph a --> {b,c} and you assign an 1 to a, 2 to b and 3 to c
09:52:43 <mmorrow> i think this calls for graphviz cgi ;)
09:52:49 <Beelsebob> now I create a second graph a --> {c, d}, how do you know you must use 1 for a?
09:52:49 <ski> (i suppose one could either build up the paths in an accumulator, or "top-down")
09:52:55 <DrSyzygy> So, based loops from b wiht the graph above would go to c and then terminate, and would go to d, and then start returning loops [d,a,b],[d,a,d,a,b],[d,a,d,a,d,a,b],....
09:52:56 <Beelsebob> 3 for c and something new for d?
09:53:01 <mmorrow> http://moonpatio.com/cgi-bin/graphedit.cgi
09:53:19 * mmorrow braces for teh server to be crushed :)
09:53:31 <duaneb> how can I combine typeclasses and datatypes?
09:53:40 <lament> into a what?
09:53:43 <DrSyzygy> duaneb: Bravely!
09:53:52 <duaneb> like, data NumTree = NumTree !(Num a => a)
09:53:53 <duaneb> or something
09:53:54 <ski> duaneb : data families ?
09:53:57 <mmorrow> Beelsebob: oh, well you don't create two graphs without knowledge of how you should assign Ints to "equivalent" nodes
09:54:06 <duaneb> ski: that sounds complicated
09:54:18 <Beelsebob> mmorrow: sounds a lot like state to me
09:54:20 <mmorrow> Beelsebob: if that ever is the case, then you need to use something else
09:54:23 <thoughtpolice> duaneb: data Numtree = Num a => Numtree
09:54:26 <thoughtpolice> duaneb: i think
09:54:29 <jmcarthur> duaneb: something like data NumTree = forall a . Num a => NumTree !a
09:54:34 <ski> duaneb : maybe you want an "existential datatype", i.e. `data NumTree = forall a. Num a => NumTree !a' ?
09:54:43 <mmorrow> Beelsebob: usually it's somthing like this (rather than IntSet):
09:54:48 <jmcarthur> -XExistentialQuantification
09:54:52 <mmorrow> IntMap (Foo a)
09:54:56 <mmorrow> where you have a
09:54:56 <thoughtpolice> yeah, you need the quantifier for existential quantification
09:54:59 <mmorrow> (a -> IntSet)
09:55:04 <duaneb> heh
09:55:13 <mmorrow> and possibly a root Int
09:55:15 <thoughtpolice> of course, the fact that Numtree has a num isn't indicated by its type, but you know so anyway
09:55:17 <ski> duaneb : that way each value of type `NumTree' contains a value of type `a', with `a' in `Num', for *some* type `a', possibly different for different values of `NumTree'
09:55:23 <jmcarthur> duaneb: using the EQ extension is like trying to put OO into your Haskell sometimes, but sometimes is exactly what the doctor ordered
09:55:23 <viraptor> > pl \f a b c -> c a b
09:55:24 <lambdabot>   <no location info>: parse error on input `\'
09:55:36 <ski> duaneb : and the only thing you can do with such a value is call `Num' methods on it
09:55:44 <viraptor> > pl f a b c -> c a b
09:55:46 <lambdabot>   <no location info>: parse error on input `->'
09:55:55 <duaneb> jmcarthur: I thought that was a joke
09:55:58 <duaneb> heh
09:55:59 <ski> @pl \f a b c -> c a b
09:55:59 <lambdabot> const (flip . flip id)
09:56:00 <mmorrow> you can always map Map a (Set a) <==> IntMap (Node a), where data Node a = Node a IntSet
09:56:17 <viraptor> ski: thanks :)
09:56:18 <mmorrow> (and IntMap is way faster structure than Map)
09:56:21 <ski> @pl f a b c = c a b
09:56:22 <lambdabot> f = flip . flip id
09:56:33 <ski> viraptor : not sure which of those two you were after
09:56:49 <jmcarthur> duaneb: heh
09:57:00 <Beelsebob> mmorrow: sure, there are alternatives, but I was mostly pointing out that it's not as simple as IntMap IntSet for all cases of graphs
09:57:13 <ski> jmcarthur : `EQ' being ?
09:57:22 <mmorrow> Beelsebob: oh sure, that was a simplification
09:57:46 <mmorrow> (==> the case where you have no extra data at nodes)
09:57:56 <mmorrow> and only have the graph structure
09:58:05 <Beelsebob> yep, that makes sense then
09:58:30 <jmcarthur> ExistentialQuantification
09:58:35 <ski> oh
09:59:06 * ski was thinking about the `a0 ~ a1' equality constraint (or however it was written)
09:59:50 <skorpan> â„µ
10:02:00 <flux>  OR
10:02:09 <jmcarthur>  AND
10:02:10 <flux> whops
10:02:17 <ski>  NOT
10:02:37 <skorpan> <<<
10:05:20 <FunctorSalad_> NIMPLIEDBY
10:07:29 <riddochc> Having problems wrapping my brain around functors. I've been reading RWH chapter 10, and it's just not helping. Anyone have recommendations on other reading material that would clarify things?
10:08:07 <jmcarthur> riddochc: the basic idea is that fmap transforms a function of type (a -> b) to a function of type (f a -> f b), for some Functor f
10:08:27 <jmcarthur> riddochc: it's an abstract enough concept that examples are the only way to really go into more detail
10:08:29 <hatds> the most common instances of functors are data structures
10:08:44 <mmorrow> DrSyzygy, ski: here's (3 versions of) one representative graph that this'll be run on: ==> (every edge present/nothing removed for the sake of viewability)  http://moonpatio.com/graphs/Exp_full.png
10:08:52 <hatds> fmap f datastruct is the analogue of map f xs for lists xs
10:09:00 <mmorrow> the same, but the transitive reduction: http://moonpatio.com/graphs/Exp.png
10:09:20 <yakov_> Peaker, FYI wrt GADTs+record syntax http://www.haskell.org/pipermail/cvs-ghc/2008-May/042421.html
10:09:26 <mmorrow> the transitive reduction of the SCC (+ directly reachable neighbors) http://moonpatio.com/graphs/Exp_SCC.png
10:09:48 <riddochc> So, any suggestions for good examples?
10:10:12 <DrSyzygy> mmorrow: So, what's the kind of questions you'd be asking of this graph?
10:10:51 <DrSyzygy> Also, when you say transitive reduction, what exactly do you mean?
10:11:12 <DrSyzygy> Wait ... nm the last question.
10:11:58 <riddochc> Is wikipedia's "Function object" page talking about the same concept?
10:12:09 <mmorrow> DrSyzygy: i'm trying to autogenerate a clump of mutually recursive class instances (or it's looking like i might not be able to use classes, but one way or another) so that you can, say for some Type T, get a function which'll give you *all* contained T's at any level of depth
10:12:47 <mmorrow> and then there's a datatype that lets you walk over each of these contexts, update them, then it re-assemble the T
10:13:25 <ski> riddochc : probably not
10:13:27 <mmorrow> so then you can do really fast manipulations of ASTs (and have the grunt work code autogen)
10:14:03 <bavardage> what is the limit on the size of haskell's integers?
10:14:06 <bavardage> is it memory-bound?
10:14:12 <bavardage> or implementation-bound
10:14:18 <ski> (riddochc : the name "functor" here comes from a part of math called Category Theory, but knowledge of it isn't required to understand what `fmap' and `Functor' in haskell is good for)
10:14:20 <bavardage> or compilation-parameters bound
10:14:29 <mmorrow> the relevant type is:
10:14:34 <mmorrow> data View a b
10:14:34 <mmorrow>   = Done a
10:14:34 <mmorrow>   | View b (Maybe b -> View a b)
10:14:50 <mmorrow> class Look a b where look :: a -> View a b
10:15:17 <jmcarthur> bavardage: i think it is _semantically_ unbounded
10:15:20 <jmcarthur> Integer, that is
10:15:28 <bavardage> kk
10:15:28 <DrSyzygy> mmorrow: Sorry, but I don't get it. What if you step back a step or two - higher abstraction?
10:15:29 <jmcarthur> Int is only required to be at least 30 bits
10:15:33 <mauke> bavardage: there is no explicit limit, which means it's probably your memory
10:15:39 <DrSyzygy> You want to find cycles in the Exp_SCC-graph?
10:15:40 <bavardage> right
10:15:54 <DrSyzygy> And you want to pick out all cycles that contain one single node?
10:15:57 <DrSyzygy> one specific node
10:16:13 <riddochc> ski: I thought not - I've run into functions as objects in a variety of other languages, and this just seemed different.
10:16:42 <mmorrow> DrSyzygy: (oh, i thought you meant what am i trying to do in particular)
10:16:53 <mauke> fmap is simply 'do this to each element of some container'
10:16:57 <Badger> Twey: ping
10:17:00 <DrSyzygy> mmorrow: Nah, I'm just interested in the graphtheory of it.
10:17:17 <DrSyzygy> mauke: Or for that matter "Translate this to whatever it should mean for the new context"
10:17:36 <DrSyzygy> There are non-container functors possible...
10:17:44 <mauke> bah, details
10:17:50 <jmcarthur> mauke: assuming containers
10:17:57 <mmorrow> DrSyzygy: ok, so given a type's Name, you have (Name -> [Type]), and you can get all enclosed types w/in a type (e.g. ["Maybe [Int]","[Int]","Int"])
10:18:22 <jmcarthur> (->) r is not a container (although i guess you could warp your thinking into viewing it as one)
10:18:26 <LeCamarade> How do I begin to track down a deadlock exception case?
10:18:32 <mauke> jmcarthur: it's a Map
10:18:56 <mmorrow> DrSyzygy: so the starting node is identified by a Name, which maps to [Type], which in turn maps to [([Type],Name)] (the last type in the list ("Int") is just a name)
10:19:03 <jmcarthur> mauke: -ish
10:20:09 <jmcarthur> a Map is a partial function, sure, but i wouldn't say that means all functions are containers
10:20:50 <jmcarthur> with a Map (Data.Map, at least), you can have a toList function. not really so with just any function
10:20:58 <mauke> bah, details
10:21:08 <jmcarthur> although i guess lack of Foldable also doesn't necessarily imply that it's not a function
10:21:15 <jmcarthur> err, container
10:21:50 <Twey> Badger: Pong
10:22:06 <mmorrow> DrSyzygy: (beyond that, i'm not sure what there is to say about the graph)
10:22:12 <Badger> Twey: d'you ever continue those SDL tutorials?
10:22:46 <DrSyzygy> mmorrow: Oh well... It's getting late and my brain is turning into mush....
10:22:47 <Twey> Nope
10:23:01 <Twey> Got carried away with other stuff, as usual
10:23:05 * mmorrow tries to implem the all-loops algo now
10:23:21 <Badger> A few more languages here and there? :P
10:23:31 <ski> mmorrow : istr you showing something like that `View' before
10:23:49 <Twey> Yeah, actually
10:23:55 <ski> probably when we were discussing lenses/functional references and/or zippers
10:24:09 <Badger> :o
10:24:33 <Badger> Fluent Finnish now then?
10:24:50 <Twey> Nay... couldn't find any more materials for it :(
10:25:10 <Badger> :/
10:25:44 <ski> mmorrow : care to compare with `data Lens a b = L (a -> (b,b -> a))' again ?
10:26:35 <mmorrow> DrSyzygy: i just realized that if you begin by following all *incoming* edges into the origin vertex, then walk the graph in reverse, you're guaranteed not to miss any nodes (i think)
10:26:53 <mmorrow> ski: ah yeah, i remember
10:26:56 <ski> mmorrow : btw, itym s/all-loops/all non-looping loops/ ?
10:27:16 * ski doesn't recall how mmorrow's "lens" variant worked
10:27:53 <mmorrow> oh, i see what you mean. i just need one cycle around every loop to get what i'm after
10:28:02 <ski> right
10:28:26 <ski> maybe one could call it "irreducible loops"
10:29:48 <ski>   modify :: (b -> b) -> (View a b -> View a b)  -- ?
10:29:59 <ski>   get :: View a b -> (a -> b)  -- ?
10:30:16 <ski> hm .. maybe not
10:31:11 <ski> mmorrow : i guess i'm not seeing why `Done :: a -> View a b' doesn't use `b'
10:36:27 <mmorrow> ski: ok, so here's what i have currently in the first paste http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2486
10:36:59 <mmorrow> ski: and the second paste has derived instance of Look for every type in Exp's and Type's SCC
10:37:10 <mmorrow> (where Exp,Type are the TH ones)
10:37:44 <raimo_> how do you organize quickcheck specifications so that you can easily run them all and inspect results?
10:37:46 <mmorrow> so i just need to figure out how to get *every* reachable expression from a given Exp, not just the one-level deep ones
10:38:04 <ski> mmorrow : was this `View' the one you had mentioned a while earlier .. or is this a fancier variant for this application ?
10:38:16 <mmorrow> ski: this is that same View
10:38:36 <mmorrow> (do you mean a while earlier as in 10 minutes, or as in a month or two?)
10:38:44 <ski> the latter :)
10:38:54 <mmorrow> oh, i think that was something like:
10:39:14 <mmorrow> data Cxt a b = Top a | Loc b (b -> Cxt a)
10:39:17 <mmorrow> iirc
10:39:25 <ski> yes, that seems to ring a bell
10:39:32 <mmorrow> hmm, so i guess it is pretty much the same
10:39:37 <ski> so `View' is same, except for the `Maybe' thrown in
10:39:41 <mmorrow> heh
10:39:52 <ski> i suppose that is for saying "nothing's changed" ?
10:40:51 <mmorrow> yes, and also (i can't recall the exact situation that made me add it initially, but there was a case where i didn't have anything to give the function in View (it was originally (b -> View a b))
10:41:00 <ski> in any case, this isn't an abstract point, like `head', but specific to a given piece of data
10:41:06 <ski> s/point/pointer/
10:42:00 <mmorrow> yes, what i'm currently doing is just having it provide you a way to map over all the 'b's in an 'a' in some (unspecified) order, so you can e.g. thread a state monad though it
10:43:07 <ski> so, if the `Cxt a b'/`View a b' is of `Top a'/`Done a' form, then there's no sub-structure marked
10:43:46 <mmorrow> yeah, that's actually one thing that's annoying that i want to fix
10:44:00 <mmorrow> (you can never change the top-level of the 'a')
10:44:08 <ski> but in the `Loc b (b -> Cxt a b)'/`View b (Maybe b -> View a b)', there is one sub-structure marked, and possibly more, (inside that ?)
10:45:41 * ski tries to remember the basic construction wholly
10:45:53 <mmorrow> exactly, you can recurse and keep on viewing. currently i'm having to do it manually, but i feel like the knot could be tied somehow... but it's looking more and more like typeclasses won't help here and you just have to compute all possible paths back to the 'a', and then generate code that reaches down them and pulls out all the 'b's
10:46:04 <ski> so why `b -> Cxt a b'/`Maybe b -> View a b' instead of just one marked sub-structure ?
10:46:32 <ski> is this to support "up" operations in more efficient (or even implementable) fashion ?
10:46:38 <mmorrow> oh, so say i'm writing an (Exp -> Exp)
10:47:01 <mmorrow> i usually want to do the action to all Exp's recursively, and also have a state monad or something
10:47:14 <ski> (also, is the "context levels" represented in "direct" or "reversed" order .. i can possibly figure that out by thinking about it)
10:47:39 <mmorrow> what do you mean "context levels"?
10:48:13 <mmorrow> err, what do ... by "direct" or "reversed"?
10:48:44 <ski> well, say `Node 1 (Node 2 Nil Nil) (Node 3 (Node 6 Nil (Node 13 Nil Nil)) Nil)'
10:49:02 <walter_> Is tagsoup outdated for web scraping on haskell ?
10:49:03 <ski> say i want to mark the `Node 13 Nil Nil' substructure
10:49:22 <mmorrow> ski: oh, i gotcha. so top-down vs. bottom up?
10:49:38 <mmorrow> i want to be able to do either
10:49:43 <ski> that means i have a sequence of "levels", `Node 1 (Node 2 Nil Nil) <>',`Node 3 <> Nil',`Node 6 Nil <>'
10:49:48 <mmorrow> viewTopDown, viewBottomUp
10:50:31 <ski> afaic, representing these levels from "inside-out" with the `Node 6 Nil <>' "directly" accessible, gives you O(1) local traversals
10:50:43 <ski> (s/afaic/afaicr/)
10:51:04 <mmorrow> hmm
10:51:11 <mmorrow> interesting
10:51:42 <ski> (it's basically the difference of either just removing a sub-structure .. or removing the sub-structure, then do pointer-reversal on all nodes from the hole up the path to the root)
10:52:00 <ski> (you could imagine keeping the levels as separate entities in a list too, i suppose)
10:52:27 <walter_> any advice on web scraping?
10:52:54 <ik> walter_: don't do it while hanging from your toenails above the grand canyon
10:53:01 <ik> that's generally considered unsafe
10:54:11 <walter_> ik, did you mean haskell is not good at web scraping ?
10:54:22 <mmorrow> ski: i think there's something to that. i'm gonna think about it.
10:54:43 <ski> (mmorrow : i can give concrete examples of direct vs. reversed contexts if you want)
10:54:45 <jaredj> unsafeWebScrapeHangingFromToenails
10:54:57 <mmorrow> ski: ooh, yes :)
10:55:03 <ski> ok, so we had
10:55:20 <ski>   data Tree a = Nil | Node a (Tree a) (Tree a)
10:55:21 <ik> walter_: no, I mean your question was very vague
10:55:34 <ski> well, we can say
10:55:54 <ski>   data Tree a = Nil | Node {element :: a , left :: Tree a , right :: Tree a}
10:56:02 <ski> for verbosity's sake
10:56:14 <sclv> walter_: tagsoup is great. dunno why you wouldn't want to use it.
10:56:29 <mmorrow> ski: you mean the diff between  [Int], and Zip a (Seq (Cxt a)), Cxt a = L (Tree a) | R (Tree a)   (or something) ?
10:57:02 <mmorrow> like (where [Int] represents a path)
10:57:05 <mmorrow> s/like//
10:57:22 <walter_> sclv, just because in #gentoo-haskell, someone said it is outdated, problably I misunderstood.
10:57:29 <ski> no, my "context level" is the `Cxt a', there
10:57:45 <sclv> in gentoo they probably just meant the package for gentoo needed to be upgraded.
10:57:50 <mmorrow> walter_: there's a ByteString version on hackage, and also one with an updated parser (maybe these are the same thing)
10:58:08 <copumpkin> has anyone seen the latest pidigits submission?
10:58:11 <ski> there's several variant ways to think about this, and i can't say i'm fully clear on it myself, yet
10:58:22 <copumpkin> it's tiny, clean, and is the fastest 32-bit entry on the shootout
10:58:26 <walter_> mmorrow, thanks , will look
10:58:34 <ski> maybe it's best if i explain what i meant, then you can compare
10:58:42 * mmorrow listens
10:58:45 <copumpkin> (http://shootout.alioth.debian.org/u32q/benchmark.php?test=pidigits&lang=all)
10:58:45 <ski> so
10:58:48 <ski>   data Tree a = Nil | Node {element :: a , left :: Tree a , right :: Tree a}
10:59:12 <ski> then, given values of type `Tree a' we can look at substructures of differing types
10:59:31 <ski> we might look at marking / removing an element `a'
10:59:42 <ski> or marking / removing a whole sub-tree `Tree a'
11:00:24 <ski> (that `Tree a' has `a' as parameter is irrelevant here .. we could just as well have `IntTree' with `Int' elements, or `Command' tree with `Expression' sub-structures)
11:00:26 <jmcarthur> copumpkin: wow that is impressive
11:00:35 <jmcarthur> and they say haskell is slow at arithmetic
11:00:55 <ski> anyway, either we may just *mark* an element/sub-structure (but keep it in-place)
11:01:14 <ski> or we may *remove* an element/sub-structure, so we get a hole in its place
11:01:19 <copumpkin> jmcarthur: yeah, I was surprised... it was a name I hadn't seen much on -cafe before, and he just randomly said "yo, I have a faster pidigits" and it's not just faster, it's the fastest! zomg
11:01:20 <copumpkin> :P
11:01:31 <jmcarthur> huh, it does much worse on 64 bit though
11:01:31 <copumpkin> it runs into the 6.10 inefficiency bug on 64-bit though
11:01:31 <ski> these are mostly similar, to i'll just talk about removing
11:01:35 <jmcarthur> oh
11:01:36 <ski> s/to/so/
11:01:43 <jmcarthur> i don't know about this bug
11:01:45 <mmorrow> ok
11:01:57 <copumpkin> jmcarthur: something about integers not getting freed correctly
11:02:03 <copumpkin> it's fixed in 6.10.2 I think
11:02:06 <ski> so, i've been calling what you get when you remove a part, a "context"
11:02:27 <jeffwheeler> I'm trying to understand the algorithm behind the pidigits implementation, but I can't seem to understand what it's doing (http://shootout.alioth.debian.org/u32q/benchmark.php?test=pidigits&lang=ghc&id=2).
11:02:37 <ski> so, the (direct) type of tree contexts with a single removed element is
11:02:46 <jeffwheeler> Is this some algorithm I can read about on Wikipedia, or something?
11:02:53 <jmcarthur> ah
11:03:30 <copumpkin> jeffwheeler: it almost seems too simple... I hope he followed the rules
11:03:43 <copumpkin> the pidigits rules want you to deliberately use a bad algorithm
11:03:43 <copumpkin> Programs should adapt the step-by-step algorithm given on pages 4,6 & 7 of Unbounded Spigot Algorithms for the Digits of Pi (156KB pdf). (Not the deliberately obscure version given on page 2.)(Not the Rabinowitz-Wagon algorithm.)
11:03:54 <copumpkin> http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf is the link
11:04:03 <jeffwheeler> copumpkin: thanks
11:04:10 * jeffwheeler goes to read that
11:04:12 <Cale> jeffwheeler: It looks like ... copumpkin answered before I could :)
11:04:25 <ski>   data TreeCxt a = Node {left :: Tree a,right :: Tree a}
11:04:30 <ski>                  | NodeL {element :: a,left :: CxtTree a,right :: Tree a}
11:04:31 <ski>                  | NodeR {element :: a,left :: Tree a , right :: TreeCxt a}
11:04:38 <copumpkin> I'm pretty impresed though if the new submission still follows the algorithm
11:04:53 <ski> (i'm just using field names to emphasize the roles of the arguments)
11:04:54 <copumpkin> it doesn't even have any strictness annotations in it
11:05:11 <ski> (well, rename `Node' here to `NodeHere', i suppose)
11:05:15 <ski> so for
11:05:32 <ski>   Node 1 (Node 2 Nil Nil) (Node 3 (Node 6 Nil (Node 13 Nil Nil)) Nil)
11:05:38 <ski> with the `6' marked, we get
11:05:52 <ski>   NodeR 1 (Node 2 Nil Nil) (NodeL 3 (NodeHere Nil (Node 13 Nil Nil)) Nil)
11:06:32 <ski> the corresponding type for tree contexts with a sub-*tree* removed is
11:06:49 <ski>   data TreeCxt a = Hole
11:06:53 <Cale> I wonder if it's really so impossible to parallelise. It does seem the sort of thing where there are lots of data dependencies...
11:07:12 <ski>                  | NodeL {element :: a,left :: TreeCxt a,right :: Tree a}
11:07:21 <ski>                  | NodeR {element :: a,left :: Tree a,right :: TreeCxt a}
11:07:23 <Cale> Hehe, whoever submitted the program has a poorly configured text editor :)
11:07:31 <copumpkin> which?
11:07:37 <Cale> pidigits
11:07:37 <ski> and if we remove the `Node 13 Nil Nil' sub-tree, we get
11:07:49 <copumpkin> oh I see :)
11:08:01 <ski>   NodeR 1 (Node 2 Nil Nil) (NodeL 3 (NodeR 6 Hole) Nil)
11:08:18 <ski> mmorrow : all this should be familiar, more or less
11:08:49 <mmorrow> ski: more or less, yes
11:09:10 <ski> now, the point here is that using this "direct" representation, `up' and `downLeft' and `downRight' operations are expensive
11:09:20 <ski> i.e. if we consider
11:09:24 <copumpkin> how hard is it to get the shootout people to upgrade their ghc version?
11:09:28 <ski>   (TreeCxt a,Tree a)
11:09:38 <BMeph> Do you guys think this (http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5168#a5221) is enough "evidence" to make a bug report?
11:09:46 <ski> a pair of a context and the substructure "in" that context
11:10:14 <jeffwheeler> copumpkin: they seem to be 6.10.2
11:10:23 <ski> (in the "marked" variant, the substructure resides inside the "context" datatype instead of in an external pair)
11:10:37 <copumpkin> jeffwheeler: oh it's 6.10.1 on the 64-bit one
11:10:41 <copumpkin> that's probably why it's so much slower
11:10:47 <ski> so, we do pointer-reversal on all references on the path from the root down to the "hole"
11:10:50 <ski> i.e.
11:11:04 <ski>   data TreeCxt a = Root
11:11:24 <ski>                  | NodeL {up :: TreeCxt a,element :: a,right :: Tree a}
11:11:34 <ski>                  | NodeR {up :: TreeCxt a,element :: a,left :: Tree a}
11:11:48 <ski> and then the tree context above gets turned inside-out into
11:13:03 <ski>   NodeR (NodeL (NodeR Root 1 (Node 2 Nil Nil)) 3 Nil) 6 Nil
11:13:15 <ski> and then the local traversals becomes O(1)
11:15:05 <ski> now, one may chop these two different conxtext types into a list of context levels
11:15:14 <ski> (s/list/sequence/)
11:16:04 <mmorrow> nice. hmm, i then that recursive (View a b)'s of a datatype could just be viewed as a rose tree, and then could put such a zipper on it to get O(1) update for each node
11:16:15 <mmorrow> oh proceed
11:16:28 <mmorrow> i'm interested in these levels
11:16:34 <ski> (there seems to be something interesting here wrt some BNF formulation and non-regular data types .. but i'll guess we can skip that for now)
11:17:02 <mmorrow> hmm, what do you mean by that
11:17:05 <mmorrow> :)
11:17:12 <ski> so i guess i was more or less wondering how (/if) your `View'/`Cxt' should/could be thought of as a sequence of these context levels
11:17:29 <mmorrow> ahhh, hmm
11:17:48 <ski> (mmorrow : just an interesting idea/connection i come up with a while ago, but haven't developed fully ;)
11:18:57 <ski> (btw, as i suppose you've heard, there's a relation between these contexts and the derivative of a parameterized datatype)
11:19:32 <mmorrow> my view of the (View a b) is that is lets you fmap(M) over a the (Tree b) that would exist if you were to recursively extract all of the 'b''s from the a
11:20:39 <ski> so if we consider a chain `(b,Maybe b -> (b,Maybe b -> ..(b,Maybe b -> a)..))', what are all the `b's here corresponding to
11:20:42 <ski> `a' is the root
11:20:47 <mmorrow> ski: yeah, i'm not very familiar with the derivative concept other than brief summaries here and there, but i'm not sure how i feel about it (from the little that i've read)
11:21:25 <mmorrow> oh, i'm getting the rose tree from the (particular) way i'm using to generate instance for a datatype
11:21:59 <mmorrow> instance Look (T a b c) a where
11:22:00 <mmorrow>   look (C a1 b1 a2 a3 b2 c1 a4) = accumView [a1,a2,a3,a4] (\[a1,a2,a3,a4] -> C a1 b1 a2 a3 b2 c1 a4)
11:22:17 <mmorrow> where accumView is in that paste
11:23:07 <mmorrow> so then if you were to recursively expand the 'b's, you'd get a rose tree (although the tree doesn't ever explicitly exist)
11:23:24 <mmorrow> (recursively expand them via other (View b c)
11:23:34 <mmorrow> 's, eventually coming back to 'a')
11:24:01 <ski> `accumView' is some sort of `unfoldr'-like thing for `View' ?
11:24:46 <mmorrow> yeah, something like that. if you have (data T a b c = C a b a a b c a) and you want (instance Look (T a b c) a), then
11:25:19 <mmorrow> you grab all the 'a's from the T, and walk the given function over them, and finally put them back in their places
11:25:30 * ski wonders how mmorrow's means to handle existentials
11:25:44 <mmorrow> heh, haven't thought of that
11:26:14 <mmorrow> they don't work with this system i don't think
11:29:08 <Heffalump> @src Control.Monad.foldM
11:29:08 <lambdabot> Source not found. I am sorry.
11:29:27 <Heffalump> @src foldM
11:29:28 <lambdabot> foldM _ a []     = return a
11:29:28 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:40:17 <walter_> Help! why I got Parse error in pattern? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5224#a5224
11:40:38 <mauke> missing parens
11:40:57 <walter_> dont understand
11:41:02 <Saizan> split (x:xs:xss) = ..
11:41:12 <Saizan> or
11:41:20 <Saizan> split ((x:xs):xss) = ..
11:41:38 <Saizan> probably
11:43:57 <walter_> Saizan, yeah, but still have other errors. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5224#a5225
11:45:25 <conal> Peaker: ping
11:45:25 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:45:34 <Saizan> walter_: you want my second suggestion, since (:) associates to the right
11:45:56 <Saizan> > let (x:xs:xss) = [1,2,3] in xs
11:45:58 <lambdabot>   2
11:46:17 <Saizan> > let ((x:xs):xss) = [[1,2],[3]] in xs
11:46:17 <wh1t3> when in doubt, add more ()'s
11:46:18 <lambdabot>   [2]
11:46:31 <Saizan> > let (x:xs:xss) = [[1,2],[3]] in xs -- for contrast
11:46:32 <lambdabot>   [3]
11:46:33 <ski> walter_ : your base case should probably look something like `split [        ] = (...,...)'
11:46:38 <PeakerWork> conal: hey
11:46:48 <conal> PeakerWork: hi
11:47:10 <ski> walter_ : or, hmm
11:47:15 <conal> PeakerWork: about unamb & memo, i think you're right.  i had the same realization a few months back and have been meaning to write a blog post for a while now.
11:47:33 <ski> walter_ : do you really mean to have `([String],[String])' as return type ?
11:47:40 <conal> PeakerWork: it's a nice application of unamb.
11:48:32 <conal> i'm slowly accumulating applications of unamb/lub.  any other ideas are very welcome.
11:49:14 <walter_> ski, yes. infact I want to convert ["a","b","c","d"] to [("a", "b"), ("c", "d")]
11:49:27 <copumpkin> is that the memoization application of unamb?
11:49:52 <ski> walter_ : then you should have a return type of `[(String,String)]', not `([String],[String])'
11:50:22 <conal> copumpkin: is *what* the memoization application of unamb?  (confused)
11:50:30 <walter_> ski, yep
11:50:38 <copumpkin> [14:47:40] <conal> PeakerWork: it's a nice application of unamb.
11:50:51 <copumpkin> but I just noticed your mention of memo right before that :)
11:50:57 <ski> walter_ : so write that then :)
11:51:00 <conal> copumpkin: k
11:51:12 <walter_> ski, thanks :)
11:51:28 <conal> i want to tie in with John Hughes's paper on lazy memo functions.
11:51:32 <PeakerWork> conal: ah, cool :)
11:51:44 <conal> John uses a very different implementation.
11:51:53 <PeakerWork> conal: I remembered your memo thing because a very close variant appears in the having fun with type families paper (SPJ, Oleg, ..)
11:52:00 <ski> walter_ : also, that `(x:xs:xss)' is probably wrong
11:52:11 <ski> try `((x:xs):xss)'
11:52:15 <ski> or maybe you just want
11:52:24 <ski>   split (xs:xss) = ...
11:52:50 <ski> (otherwise you have to consider what should happen in the `split ([]:xss)' case)
11:53:41 <walter_> ski, yeah, just as you and Saizan said. should be ((x:xs):xss)
11:55:13 <ski> mmorrow : got distracted awhile ..
11:56:10 <ski> mmorrow : your naming `a',`as' in `accumView' is slightly confusing .. i keep thinking those are elements of type `a',`[a]' (wrt the variables in the signature)
11:56:50 <ski> (well, not the `a' in the `go [] (Just a) k' case, i suppose)
11:57:03 <Baughn> conal: As experiments showed that unamb just plain wasn't working (for the case where a calculation is aborted), I wound up rewriting it. I think the version I've got now works fine.. hang on
11:57:34 <conal> Baughn: unamb broken with latest ghc and latest unamb?
11:57:38 <Baughn> Yes
11:57:44 <Baughn> Well
11:57:47 <Baughn> No, 10.3
11:58:07 <walter_> ski, still a problem
11:58:09 <walter_> >let ((x:xs):xss)=  ["a","b","c","d"]
11:58:16 <conal> Baughn: i thought it worked in 10.3.  hm.  i wonder if those ghc concurrency RTS fixes got in.
11:58:16 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5226#a5226 <-- This version works with 10.3. I suppose you should test it with HEAD too, but it seems cleaner this way too.
11:58:29 <walter_> let (x:xs:xss)=  ["a","b","c","d"]
11:58:37 <ski> mmorrow : `accumView' looks like it could be factored more .. also i was thinking before `Nothing' meant "not changing this value", but here it appears to mean "not changing any value at all, from here on"
11:58:53 <Baughn> conal: I've altered unamb, unambs (for efficiency), race and putCatch. Also the interface.
11:58:55 <ski> > let (x:xs:xss)=  ["a","b","c","d"] in (x,xs,xss)
11:58:56 <lambdabot>   ("a","b",["c","d"])
11:59:02 <ski> > let ((x:xs):xss) = ["a","b","c","d"] in (x,xs,xss)
11:59:03 <Baughn> conal: (By introducing a BothBottom exception)
11:59:04 <lambdabot>   ('a',"",["b","c","d"])
11:59:36 <walter_> ski, yeah, I need the first one. but if  (x:xs:xss) got error
11:59:55 <conal> Baughn: great.  i'd love for unamb to be simple and rock solid.  the current version is motivated by some subtleties i don't understand about resurrected thunks.
12:00:00 <conal> Baughn: would you send me test cases showing what's broken in my current unamb implementation?
12:00:01 <Baughn> conal: Using this, my reactive experiments now seem to be deterministic, at least. However, I'm still having some problems; so far, I've tracked it to a dodgy monad instance, in particular joinE.
12:00:33 <dons> conal: ping
12:00:38 <conal> dons: hi
12:00:45 <dons> conal: check your email :)
12:00:53 <ski> walter_ : why do you need the first one ?
12:00:57 * conal checks
12:01:09 <ski> @check email
12:01:10 <lambdabot>   Not in scope: `email'
12:01:19 <jmcarthur> Baughn: the Event monad doesn't obey the monad laws
12:01:23 <conal> Baughn: dodgy indeed.  even theoretically (not just the implementation).  you've put your finger on a sore spot in reactive.
12:01:42 <walter_> ski, want to covert ["a","b","c","d"] to [("a", "b"), ("c", "d")]
12:01:46 <PeakerWork> conal: oh - I forgot, do you remember why unamb tries to do a   killThread on its own thread id, and then immediately after, unblock $ recurse?  it will either block forever (because exception cannot be delivered) or kill itself before recursing?
12:01:51 <conal> dons: nothing is catching my eye in my email.
12:01:55 <PeakerWork> conal: talking about the race function
12:01:59 <walter_> ski, if the second I got [("a",""),("b",""),("c",""),("d","")]
12:02:08 <Baughn> jmcarthur: I noticed.
12:02:19 <dons> conal: privmsg
12:02:19 <Baughn> jmcarthur: It also deadlocks a lot.
12:02:24 <ski> walter_ : hm .. maybe you should name your pattern `x0:x1:xs', then ?
12:02:40 <Baughn> jmcarthur: And throws BothBottom exceptions when it ought to produce an Event with finite occurrences.
12:02:50 <walter_> ski, what difference?
12:02:56 <ski> (walter_ : `x',`xs',`xss' suggests `x' is somthing, `xs' a list of such somethings, and `xss' a list of list of such somethings)
12:03:00 <conal> PeakerWork: i can't explain it to you.  dark subtle stuff involving aborted thunks and concurrency.
12:03:05 <Baughn> conal: I'd love to just avoid it, but without joinE, justE won't work
12:03:18 <ski> walter_ : and then, i don't think you need `splitAt'
12:03:56 <Baughn> PeakerWork: Whenever unsafePerformIO code is aborted (due to exceptions or whatever), the RTS stores the current state of the IO code and restarts it from there if the unsafePerformIO thunk is ever reentered
12:04:06 <walter_> ski, ok, I will try
12:04:16 <PeakerWork> conal: Ah, do you remember why it is so?
12:04:28 <conal> PeakerWork: no
12:04:33 <conal> Baughn: sounds like what i heard also.
12:04:44 <conal> Baughn:  i built justE on joinE for elegance, but yeah, joinE is problematic.
12:04:45 <PeakerWork> Baughn: ah
12:05:05 <PeakerWork> conal: ah ok :-)  I'm pretty sure its a bit broken though -- I tested killThread on self-thread and I think it blocks forever
12:05:19 <conal> PeakerWork: what's broken?
12:05:31 <walter_> ski, still confuse, could u write the line for me? thanks
12:05:33 <PeakerWork> conal: the call to kill-self-thread
12:05:44 <Baughn> PeakerWork: The problem is that for unamb, that is /not/ the desired behavior; instead the evaluation needs to be started from scratch.
12:05:58 <ski> i could (but won't)
12:06:00 <walter_> it was split (x:xs:xss) = splitAt 1 (x:xs) : split (xss)
12:06:00 <Baughn> PeakerWork: Which is actually possible. See my earlier paste for what I like to think is the cleanest option. :P
12:06:27 <ski> walter_ : the problem is that with a pattern `x:xs:xss', then the `(x:xs)' later is nonsense
12:06:35 <ski> `x' there is a string, and `xs' is also a string
12:06:44 <ski> (see : confusing naming)
12:06:59 <Baughn> PeakerWork: And myThreadId >>= killThread ought to work to "pause" an unsafePerformIO computation. Doesn't it?
12:07:02 * Baughn tests
12:07:15 <ski> so `x : xs' would be the list whose first element is the string `x', and where the rest of the elements are the elements of `xs' (i.e. characters)
12:07:18 <Baughn> PeakerWork: ("myThreadId >>= flip throwTo e" certainly works)
12:07:25 <ski> this isn't possible, since all elements of a list has to have the same type
12:07:35 <ski> > let x = "foo"; xs = "bar" in x : xs
12:07:37 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:07:43 <PeakerWork> Baughn: maybe, I've tested a simple thread doing this out of the context of unsafePerformIO
12:07:53 <ski> > ["foo",'b','a','r']
12:07:55 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
12:08:13 <Baughn> PeakerWork: Right, it's specifically unsafePerformIO that does the magic.
12:08:16 <walter_> ski, but how to match the first two?
12:08:34 <ski> walter_ : well, you want to return a list of *pairs* (of strings), right ?
12:08:42 <Baughn> PeakerWork: Outside that I'd settle for throwIO ThreadKilled, but..
12:08:56 <walter_> ski, exactly
12:09:05 <ski> so
12:09:07 <ski>   split (x:xs:xss) = ... : split (xss)
12:09:09 <ski> looks right
12:09:25 <Baughn> PeakerWork: (If you use that inside unsafePerformIO, the same exception will get raised every time you try to re-evaluate the thunk. With throwTo, myThreadId only gets evaluated once so only the first thread to try it gets killed.)
12:09:32 <ski> because `split (xss)' will be the list of pairs from the tail list `xss'
12:09:46 <sshc> how much is Haskell used in the real world?
12:09:51 <ski> so `... : split (xss)' will be that list, with `...' added in front
12:10:05 <ski> what should `...' be ?
12:10:18 <ski> remember that it is the first element of the list here
12:10:20 <voker57_> sshc: i've discovered that hedgewars net server is written in haskell
12:10:28 <PeakerWork> Baughn: I'm not entirely up-to-speed about the details of threads vs. unsafePerformIO, hope you can re-explain it later when I'm home :)
12:10:41 <walter_> ski, :) let me try
12:11:11 <conal> PeakerWork & Baughn: if you two are up for it, i'd really like help getting unamb on solid ground.
12:12:03 <jmcarthur> sshc: http://haskell.org/haskellwiki/Haskell_in_industry
12:12:32 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5226#a5228 <-- Here's your test-case
12:12:40 <Cale> sshc: A somewhat small amount compared to many other languages, but it's increasing quickly.
12:12:51 <Baughn> conal: And I'd appreciate any test-cases you can find that breaks my code, since I haven't found one yet. ;)
12:12:56 <walter_> ski, yeah, GREAT! split (x:xs:xss) = (x,xs) : split (xss) works correct, THANK YOU!
12:13:14 <PeakerWork> it sucks that sleeps/etc are Integers and not some newtype around it.. how long is a sleep 1000000? :(
12:13:18 <ski> walter_ : ok .. now you might rename `x' and `xs' for readability
12:13:21 <Cale> sshc: Which is actually something I worry about, since I don't really care about popularity myself, and it tends to make changes in the language harder to make.
12:13:30 <conal> Baughn: great.  have you tried nested unamb uses yet?
12:13:36 <ski> walter_ : also try evaluating `split ["a","b","c"]'
12:13:40 <Baughn> conal: The test-case does just that
12:13:47 <conal> cool
12:13:58 <pumpkin> PeakerWork: I agree
12:14:04 <ski> walter_ : also, `split (xss)' is simpler written as just `split xss'
12:14:11 <walter_> ski, split ["a","b","c"]' Exception
12:14:15 <ski> right
12:14:23 <ski> because you haven't handled the case
12:14:28 <ski>   split (x:[]) = ...
12:14:34 <ski> this is the same as the case
12:14:39 <BMeph> Cale: Ah, a true-believer in "Avoid success at all costs"! :)
12:14:39 <ski>   split [x] = ...
12:14:41 <conal> PeakerWork: amen.  similarly for angles.  What's 'sin 1'?
12:14:45 <ski> i.e. a list of one string
12:14:46 <Cale> BMeph: yeah
12:14:54 <ski> (and via recursion, lists of odd numbers of strings)
12:14:54 <PeakerWork> conal: Yeah
12:14:56 <Baughn> conal: Now, now. Everyone /knows/ that's in radians.
12:15:04 <Cale> BMeph: I like teaching beginners though, which is somewhat counterproductive.
12:15:07 <walter_> ski, :) great!!!
12:15:11 <conal> Baughn: yeah. and sometimes everyone is wrong.
12:15:23 <Baughn> conal: Sometimes the implementor is wrong, you mean. :P
12:15:31 <Baughn> That's as close to a standard as anything I've seen
12:15:32 <conal> Baughn: hah.
12:15:37 <ski> walter_ : so either add a case for that .. or decide that you don't need/want to handle that case (and say so in the documentation of the function)
12:15:49 <conal> Baughn: it's definitely a standard.  so is degrees.  ;)
12:16:02 <PeakerWork> I dislike radians and degrees.. I wish 0..1 was a full circle
12:16:04 <Baughn> conal: Oh, and I'd like to point out that your latest reactive fails to build documentation on hackage
12:16:04 <walter_> ski, I see.
12:16:32 <conal> PeakerWork: yeah!  i'm with you there.  way more compelling than 360 or 2pi or 100
12:16:37 <Cale> PeakerWork: radians are the best :)
12:16:42 <conal> and numerically less problematic.
12:16:50 <BMeph> Cale: Well, that depends on whether you're teaching beginners to think, or just to cut -n- paste, and rename... ;)
12:16:56 <Elly> what's unamb?
12:17:06 <Baughn> conal: At any rate, I hope you agree with me that the exception-retry logic does not belong in race
12:17:18 <conal> Elly: unambiguous choice.  i have some related blog posts.
12:17:27 <Cale> The nice thing about radians is that if you use them, the length of an arc with radius r and angle t is just r*t.
12:17:36 <Baughn> Elly: unamb (last [1..]) 2 => 2
12:17:43 <PeakerWork> Cale: the length of the arc is so rarely interesting, though
12:17:51 <Cale> Huh?
12:17:53 <Elly> what's the type of unamb?
12:17:58 <Baughn> a -> a -> a
12:18:01 <conal> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/
12:18:01 <PeakerWork> Cale: at least whenever I used trig.
12:18:02 <Cale> It's often important.
12:18:06 <ski> the other nice thing about radians is the derivatives of the trigonometric functions
12:18:14 <conal> Elly: also, http://conal.net/blog/tag/unamb/
12:18:15 <Elly> um... so this is probably a dumb question, but unamb x _ = x?
12:18:16 <hatds> what is practical usage of unamb?
12:18:45 <Elly> oh, wait
12:18:51 <Elly> your first expression doesn't terminate, does it
12:18:53 <PeakerWork> hatds: example: symmetric && and || that can work when left-side is bottom
12:19:04 <Cale> hatds: Suppose you have two computations, a and b and they compute the same thing, but one of them is expensive and the other is cheap, but you can't tell which ahead of time.
12:19:13 <conal> hatds: another is functional data-driven programming, as in http://conal.net/papers/simply-reactive/
12:19:13 <Baughn> hatds: Or one works and the other doesn't
12:19:22 <Jedai> Elly: No, it's not that simple :)
12:19:30 <Baughn> hatds: Also, it's N, not just 2. :)
12:19:40 <Baughn> (Well, though that's just a fold)
12:19:40 <Cale> hatds: unamb will try them in parallel and whichever completes first wins.
12:19:49 <PeakerWork> conal: btw: What do you think about luqui's efforts to attack FRP in a dependent-type/total language?
12:20:16 <conal> PeakerWork: something recent (last few days)?
12:20:38 <Cale> What's the current problem with unamb?
12:21:01 <Cale> From playing around with it, it seemed to work as advertised... is it something subtle?
12:21:05 <Baughn> Cale: unsafePerformIO.
12:21:06 <walter_> ski, seems  split (x : []) = (x, []) doesnt work
12:21:15 <Cale> Baughn: Well... that's unavoidable isn't it?
12:21:22 <Baughn> Cale: Or, specifically.. let a = unamb .. .., b = unamb a ..
12:21:32 <BMeph> conal: I think Dana's been worked on for a few months, by now. :)
12:21:32 <Baughn> Cale: If you evaluate b, and it completes without picking a..
12:21:35 <ski> walter_ : where "doesnt work" means ?
12:21:38 <Baughn> Cale: Any later evaluations of a fail.
12:21:43 <Baughn> Cale: (But I just fixed this)
12:21:50 <ski> walter_ : oh, type error
12:21:58 <walter_> yeah, type error
12:22:00 <Cale> Baughn: Ah, okay
12:22:02 <ski> walter_ : remember that you should return a *list* of pairs
12:22:04 <ski> not just a pair
12:22:15 <ski> `(x, [])' is a pair, not a list of pairs
12:22:32 <Cale> Baughn: How'd you fix it? Is it something that a pragma could cure?
12:22:32 <Baughn> Cale: unsafePerformIO restarts aborted computations /from the point at which they failed/, but unamb needs to restart from the beginning. This took some work.
12:22:42 <Baughn> Cale: Not any pragmas I know about. :)
12:22:59 <Baughn> Cale: -- import FRP.Reactive
12:22:59 <Baughn> -- import FRP.Reactive.LegacyAdapters
12:22:59 <Baughn> -- import FRP.Reactive.PrimReactive
12:22:59 <Baughn> -- import FRP.Reactive.Internal.Reactive
12:22:59 <conal> BMeph: dana isn't particularly about frp is it?
12:23:02 <Baughn> ..oops
12:23:36 <walter_> ski, thanks , split (x:[])     = [(x,[])] is right
12:24:11 <Baughn> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5226#a5228 <-- As for the how, look closely at the exception-handling code in unamb, at the top there
12:24:21 <ski> "dana" ?
12:24:42 <ski> Dana Scott ?
12:25:10 <conal> yes
12:25:12 <Baughn> conal: That reminds me. Whether you merge my code or not, that NOINLINE pragma on unamb is critical.
12:25:15 <Cale> Baughn: Weird and subtle :)
12:25:47 <conal> Baughn: is it?
12:25:48 <Baughn> Cale: And probably not even /correct/
12:25:58 <Baughn> conal: Oh yes
12:26:11 <walter_> ski, thank you, have a good day!
12:26:25 <Baughn> Cale: I mean, I'm unblocking exceptions inside an exception handler. THere are a ton of reasons why this is a bad idea, but it's necessary so the throTO doesn't fail.
12:26:28 <PeakerWork> conal: nope, its a while back
12:26:49 <Baughn> Cale: ..or the retry
12:26:50 <PeakerWork> conal: he started out wanting to create an FRP environment (all the way down to the OS, I think) and decided that the proper first step was to create a dependent-type language
12:27:03 <PeakerWork> conal: I may be misrepresenting him, but that's what I understood
12:27:45 <conal> PeakerWork: i'm glad luqui is working on it.  he's very bright, and as uncompromising as i am about getting to rigor & semantic simplicity.
12:28:15 <conal> i enjoyed working with him in belgium last summer.
12:29:27 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5226#a5229 <-- And a race-condition fix
12:29:29 <conal> Baughn: i like your BothBottom exception.  something i meant to do but hadn't gotten worked out.
12:29:29 <PeakerWork> conal: cool :)  I think he had a blog post with something like "dependent types are easy! an implementation in <100 lines".
12:30:00 <BMeph> conal: Oh, while Dana isn't specifically about FRP, I'm pretty sure luqui's interested in it enough to make sure Dana's good at it. It was one of his motivations for making the language, from what I inferred.
12:30:15 <Baughn> conal: Well, at least I /hope/ it's a race-condition fix. Umh.. oh, and thanks. I see them a lot, so they're useful.
12:30:16 <conal> BMeph: probably so
12:31:00 <conal> Baughn: *race conditions* are useful?  (or something else?)
12:31:11 <Baughn> conal: BothBottom is useful, and I see it a lot. :P
12:31:20 <PeakerWork> conal, Baughn: maybe Baughn can take over the unamb library maintainance?
12:31:25 <conal> oh!  :)
12:31:27 <Baughn> conal: ..in trying to figure out joinE. Should I bother?
12:31:40 <PeakerWork> Baughn: do you have a hackage user?
12:31:47 <Baughn> PeakerWork: Well, yes
12:31:49 <Baughn> I think
12:31:57 <conal> Baughn: bother with joinE?
12:32:04 <BMeph> Cale: I recall you said that a "list" implies a countable number of elements. Does that hold for a "stack" as well? :)
12:32:10 <Baughn> conal: You mentioned something about it being semantically broken
12:32:27 <Cale> BMeph: Well, we don't normally discuss stacks in pure mathematics :)
12:32:41 <conal> Baughn: Event wants to be a monad.  but something isn't quite right.
12:32:57 <Baughn> conal: I can live without the monad instance, but the other functions /need/ to work
12:32:58 <Cale> BMeph: I suppose if you want, you could generalise the idea of a list to be a function from any ordinal, but that's unconventional. :)
12:33:11 <Baughn> conal: filterE, justE..
12:33:32 <BMeph> Cale: Also, what's the implications of a sequence that keeps going - or is a sequence semantically dif't from a list? :)
12:33:39 <conal> Baughn: yeah.  could just implement those functions directly, avoiding joinE
12:34:06 <Baughn> conal: That would be nice. Nicer would be if, next release, you mark all the monad-using functions as "broken". ;)
12:34:14 <Cale> BMeph: A sequence is a function specifically from the whole set of naturals
12:34:36 <conal> Baughn: the most telling symptom to me that something is semantically awry is that Event doesn't have a simple & compelling denotational model.  if it did, then the semantic function would be morphism w.r.t all of the classes it implements, and the class laws would have to hold.
12:34:39 <Baughn> conal: More annoying is that I could see joinE being very useful in the future, but I can wait for that.
12:34:50 <Cale> BMeph: Rather than from some initial segment.
12:34:52 <BMeph> Cale: So, a map is a generalization of a sequence (does that make sense)? :)
12:35:14 <Cale> A function in general is.
12:36:01 <conal> Baughn: in general, Reactive is living in neglect while i'm working out how to support myself, post economic meltdown.
12:36:02 <BMeph> Cale: function, vice map, or function vice sequence?
12:36:31 <Cale> I just mean that if by 'map' you mean a function, then yes, it's a generalisation of a sequence.
12:36:32 <Baughn> conal: I can see that. *makes fist in general direction of bank managers*
12:36:37 <Cale> In that all sequences are functions.
12:36:51 <Cale> (which happen to have domain the natural numbers)
12:37:12 <BMeph> Cale: Ah, check. THanks, that helps settle the junk in my head better. :)
12:37:12 <Cale> We tend to write them with different notation, but they're the same thing :)
12:37:13 <p_l> Baughn: Fist? I wouldn't go below a nuke.... (or well prepared torture)
12:37:23 <skorpan> does anyone know of a paper on difference lists?
12:37:37 <Baughn> conal: I'd be willing to adopt unamb if you don't have time for it, but I don't see much work being needed (assuming it's working now).
12:37:39 <conal> skorpan: hm.  john hughes has one.
12:37:45 <BMeph> skorpan: As in Golumb ruler-related? :)
12:37:47 <skorpan> conal: so i heard, but i can't seem to find it :/
12:37:51 <Cale> skorpan: What do you mean by difference lists?
12:37:54 <skorpan> BMeph: i have no idea what that means :P
12:38:05 <conal> skorpan: also something in gerard huet & bernard lang's paper on 2nd order patterns, iirc.
12:38:06 <skorpan> Cale: the hughes difference lists :P
12:38:12 <BMeph> skorpan: I guess that means "no". ;)
12:38:24 <Baughn> p_l: Well, maybe I could sit around one with some hammerers?
12:38:26 <Cale> skorpan: Do you mean the trick of using functions which add elements to the beginning of a list to get fast concatenation?
12:38:28 <skorpan> i mean difference lists in the Endo and appEndo sense ;P
12:38:33 <skorpan> Cale: exactly
12:38:44 <Cale> skorpan: I wouldn't expect that to require a whole paper :P
12:38:55 <skorpan> probably not, but i need some reference for my report
12:38:56 <conal> skorpan: maybe dons remembers
12:39:00 <ski> (`[x_0,x_1,x_2,..,x_{n-1}]' having no duplicates means that `i |-> x_i' is injective ..)
12:40:16 <conal> skorpan: i wonder if there's a reference in the icfp 2009 paper on free theorems for type constructor classes.
12:40:32 * ski thinks that could be a nice interpretation of `x_0 =/= x_1 =/= ... =/= x_{n-1}'
12:40:44 <Cale> I guess it's a special case of what's been called the Worker/Wrapper Transformation.
12:40:53 <conal> probably so
12:41:05 <conal> so maybe andy gill has a reference.
12:41:09 <conal> or graham hutton
12:41:18 <BMeph> p_l: I don't blame the bank managers - "You can't cheat an honest man," as they say. :\
12:41:53 <FunctorSalad_> the "synopsis" generated by haddock is quite confusing..
12:42:09 <p_l> BMeph: Depends exactly on *which* bank manager. Unfortunately, if the job title includes "manager", I tend to assume "mangler"
12:42:10 <FunctorSalad_> (since it ignores the sections and comments)
12:42:11 <BMeph> @seen andyjgill
12:42:11 <lambdabot> andyjgill is in #haskell and #ghc. I don't know when andyjgill last spoke.
12:42:27 <andyjgill> BMeph: hi
12:42:27 <lambdabot> andyjgill: You have 1 new message. '/msg lambdabot @messages' to read it.
12:42:33 <Cale> ... maybe
12:42:50 * BMeph imagines a news story about "the Boston Mangler"...
12:43:44 <BMeph> andyjgill: Hello. skorpan is looking for info on difference lists, which lead to talk of work/wrap transforms - and we all know who the resident expert on those are... ;)
12:44:20 <Cale> Ah, yeah, the first worker/wrapper paper here: http://www.workerwrapper.com/ seems to mention that case.
12:44:39 <andyjgill> What do you want to know? How can I help?
12:45:07 <ski> @quote mangler
12:45:08 <lambdabot> Pseudonym says: All hail the Evil Mangler!
12:45:11 <BMeph> skorpan: Care to ask "the Man" personally? :)
12:45:13 <skorpan> personally i just wanted a paper which discusses difference lists in haskell
12:45:15 <Cale> I think he just wants a bibliography entry for the trick where you replace lists by functions which add elements to lists.
12:45:20 <dons> skorpan: hmm.
12:45:24 <dons> it's a prolog thing
12:46:19 <Cale> It seems the sort of thing which is just folk knowledge that everyone picks up at some point while learning the language.
12:46:21 <conal> (difference lists) and i think in the huet & lang paper on program transformation via 2nd-order pattern matching and in a paper by john hughes.
12:46:41 <FunctorSalad_> like showS?
12:46:44 <Cale> Yeah.
12:46:47 <skorpan> yes
12:46:51 <conal> FunctorSalad_: yeah but more general
12:46:57 <Cale> I suppose if you wanted you could reference the Haskell Prelude. ;)
12:47:01 <dons> the haskell dlist impl. in the dlists package, while similar to shows, was i think developed independently by manuel chakravarty, who ported it from prolog.
12:47:03 <FunctorSalad_> I never got why that is faster than (++) :(
12:47:07 <dons> the comment in ctklight says "--  This module provides the functional equivalent of the difference lists
12:47:11 <dons> --  from logic programming.  They provide an O(1) append."
12:47:13 <conal> would be nice to replace showS with DList
12:47:13 <andyjgill> Thanks Conal. You might also want to look at a paper by Wadler, The Concatenate Vanishes.
12:47:22 <Cale> FunctorSalad_: (.) is constant time, obviously, right?
12:47:27 <roconnor> FunctorSalad_: because you don't stick in a [] that needs to be removed later.
12:47:32 <conal> andyjgill: thx.
12:47:33 <FunctorSalad_> Cale: yes
12:47:44 <conal> Cale: obvious, but misleading, i think.
12:47:50 <FunctorSalad_> but (++) gets turned into a stream as well, doesn't it?
12:47:51 <Cale> FunctorSalad_: Okay, but xs ++ ys will take time which is proportional to the length of xs
12:47:52 <skorpan> i guess i could just do what SPJ seems to like to do in his SYB papers, write "well-known folk lore"
12:47:57 <andyjgill> It would be better to write show, and get DList performance. That is what I want.
12:48:02 <Cale> FunctorSalad_: because look at the definition of (++)
12:48:05 <Cale> @src (++)
12:48:06 <lambdabot> []     ++ ys = ys
12:48:06 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
12:48:06 <lambdabot> -- OR
12:48:06 <lambdabot> xs ++ ys = foldr (:) ys xs
12:48:13 <ski> FunctorSalad_ : because of `n' left-associated calls to `(++)' being avoided
12:48:19 <FunctorSalad_> I'm aware that (++) is inefficient in eager languages...
12:48:25 <conal> andyjgill: indeed!  have you read the new free-theorems paper (icfp09)?
12:48:41 <ski> it isn't so much `(++)' that is inefficient as much as left associated calls to it
12:48:46 <Cale> Okay, so it's really min(k,length xs), where k is the number of elements of the resulting list you look at.
12:48:46 <andyjgill> No. (looking).
12:48:58 <ski>   (((as0 ++ a1) ++ a2) ++ a3) ++ a4
12:48:59 <Cale> FunctorSalad_: But it's still a constant cost *per element* of the list.
12:48:59 <BMeph> skorpan: I suspect that to use that phrase, you have to be a well-known lore master first. :)
12:49:01 <ski> is inefficient
12:49:08 <conal> i've been wondering about difference lists.  the usual data representation memoizes ("for free"), but not the function (difference list) representation.  right?
12:50:00 <skorpan> BMeph: that's what i'm afraid of :P
12:50:01 <Cale> FunctorSalad_: and so if you have something like ((([] ++ [x]) ++ [y]) ++ [z]) ++ [w], consider how many steps it will take to get the first element of that.
12:50:26 <FunctorSalad_> Cale: ok, so it's a matter of constant factors rather than complexity?
12:50:51 <dmwit> No.
12:50:54 <Cale> Well, the top-most context looks like (...) ++ [w], and (...) isn't of the form [] or (x:xs) yet, so we have to push this on the stack and evaluate the left arg.
12:51:01 <Cale> No, it's complexity.
12:51:24 <andyjgill> conal: Thank for the pointer; I can use this (I think) to help give semantics to my observable sharing work.
12:51:39 <Cale> and then we have (...) ++ [z] goes on the stack, and then (...) ++ [y], and then finally we find the reducible subexpression [] ++ [x]
12:51:47 <FunctorSalad_> I'd have to think about what exactly the left-associated expression does...
12:51:50 <conal> andyjgill: which pointer?
12:51:53 <Cale> which we reduce to [x] according to the first rule of ++
12:52:02 <andyjgill> conal: the new free-theorems paper (icfp09)?
12:52:05 <Cale> or (x:[]) if that's better
12:52:09 <conal> andyjgill: ah :)
12:52:15 <dmwit> FunctorSalad_: If you have a (fixed) upper bound on the number of (++) applications, then yes, it's only an effect on the constant factors.
12:52:19 <Jedai> FunctorSalad_: It's complexity, basically the difference isn't in the operator used (there's still a (++) at the end) but in the fact that using Difference list ensure that all (++) operation will be left-associated
12:52:33 <dmwit> FunctorSalad_: But usually the place this trick is used is for Show and friends, where the number of applications of (++) depends on the size of the argument.
12:52:34 <Cale> and then we pop the stack and get (x:[]) ++ [y]
12:52:42 <Cale> and we apply (++) again
12:52:56 <dmwit> FunctorSalad_: In that case, there's no fixed upper bound, and so we get something that delves into the world of complexity. =)
12:52:57 <Cale> and that goes to x : ([] ++ [y])
12:53:12 <Cale> and we're at a constructor, so we pop the stack again
12:53:24 <Cale> (x : ([] ++ [y])) ++ [z]
12:53:30 <Cale> and we apply the rule for (++)
12:53:43 <Cale> (does this seem like a constant time operation to you?)
12:53:46 <FunctorSalad_> hmm ok I'm starting to get it, thanks everyone :)
12:53:58 <FunctorSalad_> but why is (++) infixl then?
12:54:01 <ski> (this is btw similar to `Codensity'-wrapping a monad)
12:54:12 <Jedai> FunctorSalad_: well that's the correct associativity
12:54:12 <Cale> It's not?
12:54:18 <Cale> infixr 5 ++
12:54:24 <Cale> Of course it's infixr
12:54:43 <Jedai> FunctorSalad_: xs ++ (ys ++ zs) is less expensive than (xs ++ ys) ++ zs
12:55:07 <Jedai> Oh right, right associative is the less expensive choice
12:55:07 <dmwit> FunctorSalad_: A common pattern in Show instances is to do
12:55:10 <Cale> You always want to be doing short ++ long
12:55:29 <dmwit> show (Foo x y) = "(Foo" ++ show x ++ show y ++ ")"
12:55:48 <FunctorSalad_> Cale: I assumed infixl because left-associativity was mentioned as the problem
12:55:53 <dmwit> FunctorSalad_: ...in which case you can see we'll have (++)s associated both ways, since the recursive calls to show will also in general use (++)...
12:55:56 <hatds> I was convincing myself yesterday that this one occurrence of reallylonglist ++ [y] was okay
12:56:09 <Jedai> FunctorSalad_: Ok, (++) is (correctly) infixr but unfortunately that doesn't ensure that all application will be right-associated
12:56:12 <Cale> FunctorSalad_: The problem is when some recursive function builds a left-associated expression in terms of (++)
12:56:23 <PeakerWork> Jedai: DList helps with that
12:56:28 <Cale> Or when it doesn't avoid doing so
12:56:33 <Cale> For example, if we have
12:56:37 <Jedai> look at a case where we successively append an element at the end
12:56:47 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
12:56:52 <Jedai> PeakerWork: I know :) I'm trying to explain
12:56:58 <PeakerWork> ah ok :)
12:56:59 <Cale> We can write an inorder traversal like
12:57:03 <FunctorSalad_> ok, I see how you can get left association depending on the show instanec
12:57:05 <Cale> inorder Leaf = []
12:57:20 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
12:57:24 <Jedai> FunctorSalad_: the infixr only works if the (++) are in the same expression
12:57:31 <Cale> But this will be extremely slow for left-leaning trees.
12:57:41 <FunctorSalad_> *nod*
12:57:52 <Cale> On the other hand, we can transform it easily to get:
12:58:01 <Cale> inorder t = inorder' t []
12:58:07 <Cale> inorder' Leaf = id
12:58:20 <Cale> inorder' (Branch x l r) = inorder l . (x:) . inorder r
12:58:40 <Cale> and now all the concatenations have been replaced by compositions which are constant time
12:59:05 <ski> also, this is almost the same as writing it directly with an accumulator
12:59:14 <FunctorSalad_> my confusion was with the meaning of "constant time" here, since both (.) and (++) just make a thunk from one POV
12:59:42 <Cale> FunctorSalad_: Right, but assuming the result is completely evaluated (++) ends up contributing O(n) time.
12:59:53 <Cale> That is, deeply evaluated, not just WHNF
12:59:58 <Jedai> FunctorSalad_: Only the construction of the DList is constant time, at the end you still have a O(n) cost
13:00:03 <FunctorSalad_> ski: I find Cale's inorder' to look much nicer than an accumulator though :)
13:00:03 <PeakerWork> I get confused a lot about O() complexity analysis in the face of laziness
13:00:07 <ski> the efficiency of repeated concatenations here was wrt walking through the whole (or larger part of) the output list
13:00:21 <Cale> This gets even prettier if we have a fold over our tree available, since you can write:
13:00:37 <Jedai> FunctorSalad_: But using directly list and (++) we could easily have payed at least O(nÂ²) if not worse
13:00:47 <ski> FunctorSalad_ : yes .. also, it's more eager, traversing the tree before deciding what list to prepend to
13:00:59 <Cale> inorder t = foldTree id (\x l r -> l . (x:) . r) t []
13:01:19 <dmwit> Cale: That doesn't type-check, I think.
13:01:36 <Cale> Really?
13:01:37 <dmwit> inorder' = foldTree id (\x l r -> inorder' l . (x:) . inorder' r)
13:01:38 <ski> you can write a variant of `inorder' in CPS, too, that is quite similar to the accumulating version
13:01:43 <Cale> dmwit: no
13:01:53 <Cale> dmwit: You misunderstand the type of foldTree, I'm pretty sure :)
13:01:58 <ski>   inorderCPS :: Tree a -> ([a] -> o) -> o
13:01:59 <dmwit> Maybe so.
13:02:12 <Cale> foldTree e n = f
13:02:12 <Cale>   where f Empty        = e
13:02:12 <Cale>         f (Node x l r) = n x (f l) (f r)
13:02:28 <dmwit> Oh, okay.
13:02:28 <redbrain> hey guys been playing with haskell for a few days is there a nicer way of writing the code getting pretty frustated at indentation errors :(
13:02:31 <Cale> foldTree :: t -> (t1 -> t -> t -> t) -> Tree t1 -> t
13:02:42 <FunctorSalad_> hmm so both left-associated (++) and (.) make a sort of stream, but with (++) evaluating the first elem has complexity proportional to the number of nestings?
13:02:54 <dons> it seems somewhat wrong to have " 	To buy the full text of this article you pay:
13:02:58 <Cale> redbrain: First of all, make sure that your editor is configured to convert tabs into spaces.
13:02:59 <dons> Â£17.00 copyright fee + service charge (from Â£7.45) + VAT," -- for a paper I wrote.
13:03:17 <Jedai> redbrain: Use only spaces (no tabs) and always put a keyword introducing a block on a line by itself
13:03:19 <Cale> redbrain: It is crucial that tab characters don't end up in the file you're giving to the compiler.
13:03:20 <redbrain> cale: i am using haskell mode in emacs
13:03:32 <Cale> redbrain: Okay, so that should already be turned on.
13:03:49 <redbrain> ah i was copying and pasting some snippits i made a while back
13:03:52 <Jedai> redbrain: Normally haskell-mode handle the indentation quite well, what is your problem exactly
13:03:54 <redbrain> maby there are some tabs in there
13:03:56 <Cale> redbrain: The golden rule of indentation in Haskell is that things at the same level should start in the same column.
13:04:26 <Cale> redbrain: Yeah, if you show us some code which you're having trouble indenting, we can show you how to do it.
13:04:27 <redbrain> i just find if statements a little awkward to line up sometimes
13:04:43 <Cale> Oh, and second golden rule: things which are inside other things should be indented more
13:04:45 <Cale> if foo
13:04:48 <Cale>    then bar
13:04:51 <Cale>    else quux
13:04:57 <Cale> Is how you should always indent it.
13:05:26 <Cale> Note how the 'then' and 'else' are part of the 'if', so they start on a further column, and they are siblings, so they line up.
13:05:34 <Jedai> FunctorSalad_: The thing is that there is no difference between (f . g) . h and f . (g . h) whereas there is a difference between (xs ++ ys) ++ zs and xs ++ (ys ++ zs)
13:05:48 <Cale> You can also use:
13:05:52 <Cale> if foo then bar
13:05:57 <Cale>        else quux
13:06:08 <dmwit> redbrain: Take Cale's rules with a grain of salt. ;-)  That's his style, but it's not everybody's.  While you're new to the language, go ahead and follow them to avoid trouble, but when you get the hang of it, feel free to invent your own style.
13:06:22 <Cale> It's *almost* everyone's style.
13:06:24 <redbrain> then error $ "Failed to log in: " ++ show (respCurlCode r) ++ " -- " ++ respStatusLine r
13:06:29 <redbrain> i keep getting an error at this line
13:06:30 <redbrain> :S
13:06:32 <FunctorSalad_> Jedai: due to optimisations, or in general?
13:06:33 <olsner> oh, that pidigits thing is pretty nice, 10% over the next entry, and they're both just using gmp (unless that pure-haskell Integer implementation has suddenly materialized :P)
13:06:51 <BMeph> I sometimes wish that "the Committee" hadn't catered to the crowd of convention and hadn't thus put if-then-else into the language. :\
13:06:51 <Jedai> FunctorSalad_: in general
13:06:56 <Cale> redbrain: can you paste more context on hpaste.org?
13:06:58 <conal> Baughn: i like your idea of putting a Nothing to indicate thread death and then counting thread deaths.
13:07:05 <Cale> redbrain: did you forget the 'else'?
13:07:08 <FunctorSalad_> Jedai: (of course function compo is associative semantically, but don't you get differently nested lambdas?)
13:07:12 <redbrain> hmm looking
13:07:12 <FunctorSalad_> I'd have to write it down
13:08:33 <Jedai> FunctorSalad_: That's not important, the cost are no different and function will get executed in the same exact order
13:08:34 <Cale> FunctorSalad_: Evaluating each (.) is always a constant cost though.
13:09:00 <Cale> FunctorSalad_: If you have a right associated bunch of (.)'s it's still better, because you only have to evaluate one of them to get started with the rest of the work
13:09:24 <Cale> But even if they're left associated, you only pay that cost once at the beginning.
13:10:02 <Cale> (a cost proportional to the depth of nesting)
13:10:07 <PeakerWork> so rassoc (.)s are more lazy than lassoc (.)'s
13:10:08 <FunctorSalad_> hmm, in "f (g (h x))" we have the associativity in the syntax already
13:10:09 <PeakerWork> ?
13:10:13 <Cale> Yeah.
13:10:40 <Cale> (f . (g . h)) x is better for lazy evaluation than ((f . g) . h)
13:11:11 <Cale> Because in the latter, both of the (.)'s must be evaluated before f gets its turn
13:11:25 <Cale> While in the first, only the left (.) needs to be
13:11:47 <conal> Baughn: how about a foldr1 in unambs?
13:12:03 <Baughn> conal: Would make sense. Well, it's your code. :P
13:12:11 <Cale> (f . (g . h)) x --> f ((g . h) x) --> (evaluation now depends on f)
13:12:26 <Baughn> conal: Fixing that was really just a side-swipe anyway. It was too tempting not to.
13:12:41 <conal> Baughn: my code had only the one case.
13:12:56 <Cale> ((f . g) . h) x --> (f . g) (h x) --> f (g (h x)) --> (evaluation now depends on f)
13:13:01 <Baughn> conal: Which looked nice, but calling unamb is unfortunately /expensive/
13:13:22 <roconnor> exp(1) is Euler's constant, right?
13:13:23 <Cale> If the first thing f does is pattern match, it makes no difference though.
13:13:24 <conal> Baughn: i'm sympathetic.  could we make a more general improvement instead?
13:13:26 <Cale> roconnor: yes
13:13:29 <Cale> > exp(1)
13:13:31 <lambdabot>   2.718281828459045
13:13:52 <Cale> Well, it's not gamma, but e :)
13:13:53 <roconnor> good.  That's much shorter than base-of-the-natural-logarithm
13:14:00 <roconnor> oh
13:14:01 <conal> Baughn: i.e., simplify 'foo `unamb` undefined' more often
13:14:09 <roconnor> are there two Euler's constants?
13:14:27 <Baughn> conal: Presumably you wouldn't normally write code that does that
13:14:28 <Jedai> Cale: That's true, but irrelevant in the case of DList though, since we're looking at the complexity evaluating the whole list in the end, the cost will be exactly the same whatever the order the composition were done, there's a small cost equal to the number of composition
13:14:35 <Cale> Jedai: right
13:14:53 <Cale> Jedai: But it can mean things in terms of latency.
13:14:57 <Baughn> conal: But no, I can't see any way of doing it.
13:14:58 <conal> Baughn: not before inlining, but after.
13:15:02 <Jedai> Cale: Sure :)
13:15:04 <Baughn> conal: Well, a rewrite rule?
13:15:06 <Cale> Jedai: By which I mean the time to get the first element of the list.
13:15:10 <conal> Baughn: yeah!
13:15:15 <Baughn> conal: ..never used those
13:15:36 <conal> Baughn: also, we could perhaps check for whnf, to avoid forkIO'ing
13:15:42 <SamB> yeah, the nice thing about DList is that you don't have to wait for the whole list to be available to see the first element, on matter how the appends are ordered ...
13:15:43 <Cale> With left-associated (++), the time to get the first element is linear!
13:16:00 <Cale> and the same goes for left-associated (.)
13:16:02 <Baughn> conal: How?
13:16:07 <conal> Baughn: if we can get unamb solid and *efficient*, i think it could be very popular, as a functional/deterministic way to exploit concurency.
13:16:09 <Heffalump> conal: one of the Anygma guys suggested that on one of the mailing lists
13:16:16 <PeakerWork> conal: can you write a REWRITE rule for bottoms?
13:16:22 <Heffalump> an efficient unamb would be great
13:16:24 <Jedai> Cale: Linear in the number of lists involved, not in their length
13:16:34 <conal> Baughn: there used to be an isWhnf function somewhere.
13:16:39 <Cale> Jedai: right
13:16:43 <mjrosenb> unamb?
13:16:46 <Cale> And the cost for (.) you only pay once, so it doesn't end up being quadratic.
13:16:47 <Jedai> conal: I agree, the idea of unamb is truly elegant :)
13:16:49 <Baughn> conal: Ah. Well, if it's still around, that'd be great
13:16:55 <conal> Jedai: :) !
13:17:01 <Baughn> conal: It's deep GHC hacking, though. I'd suggest getting one of the GHC team members to help you.
13:17:15 <Heffalump> conal: really, where?
13:17:18 <Heffalump> (re isWhnf)
13:17:35 <Cale> Whereas each (++) in that linear cost except the one ([] ++ ...) case is going to put another (++) into the result expression when it evaluates
13:17:40 <conal> Heffalump: i've forgotten.   could even be a hugsism
13:17:43 <Baughn> Heffalump: http://www.haskell.org/pipermail/haskell-cafe/2007-September/032392.html
13:17:54 <conal> Baughn: now maybe something in vacuum could help.  someone suggested it, though i've forgotten who
13:18:06 <Jedai> Cale: Right and therein lies the beauty of difference lists ^^
13:18:18 <Baughn> conal: Now, there's an idea
13:18:35 <Baughn> conal: With all these dependencies, I feel like unamb should be part of GHC itself
13:19:06 <Baughn> conal: Ah, but yes, vacuum can do it. Check out Vacuum.ClosureType
13:19:14 <Baughn> closureType :: a -> IO ClosureType
13:19:17 <conal> Baughn: in GHC.  probably so.  they might not be interested until there's a demand.  which might not exist until there's a correct implementation and one that's reasonably efficient.
13:19:40 <Baughn> conal: I'll get a patch down. :)
13:19:57 <conal> Baughn: "a patch down"?
13:20:09 <skorpan> you're still on about difference lists? :P
13:20:42 <conal> i don't think i got any response about difference lists defeating list memoization
13:20:49 <Jedai> skorpan: There was a demand of an explanation on why they were efficient and since it is not that easy to explain :)
13:21:22 <SamB> they're efficient because they have an O(1) Monoid ;-P
13:21:47 <Baughn> conal: Looks like I can get this working using just Vacuum
13:21:53 <Heffalump> thread racing doesn't really seem like the right implementation if you can control GHC
13:21:55 <skorpan> i say they're efficient because they're hylomorphic to (->)!
13:21:56 <Baughn> conal: ..with very little code
13:22:02 <conal> Baughn: :) !
13:22:07 <Jedai> conal: Well they do, more or less
13:22:11 <Cale> But yeah, even difference lists prefer foldr to foldl is what I mean :)
13:22:20 <Baughn> conal: Heck, it's got an "isThunk" function
13:22:36 <PeakerWork> SamB: classes don't have O()'s :) mempty is O(1) either way
13:23:05 <SamB> well, okay, O(1) mappend
13:23:06 <Cale> PeakerWork: He's referring to the monoid operation which is mappend :)
13:23:36 <PeakerWork> Cale: Yeah, I know, I was nitpicking because I think its more productive to talk about concrete operations than abstract type-classes in this context :)
13:23:42 <olsner> mempty = MyType (fix (1:))
13:23:56 <Jedai> SamB: I would say that the important part is that their toList operation is in O(n)
13:24:14 <FunctorSalad_> @let foldrapp c n xs ys = case ys of { [] -> foldr c n xs; (y:ys1) -> foldrapp c (y `c` n) xs ys1 }
13:24:15 <lambdabot>  Defined.
13:24:16 * Cale notices that this is a good time to point out that zero and (++) would be much nicer names for the Monoid methods.
13:24:29 <conal> Cale: and how!
13:24:37 <SamB> Jedai: yeah, that's nice too. and the fact that it's incremental
13:24:42 * olsner suddenly agrees with Cale
13:24:57 <Jedai> Cale: I agree
13:25:26 <Cale> Monoid is fundamental. If all that other stuff gets to be in the Prelude, it should be as well.
13:25:57 <skorpan> no one seems to have caught me trolling for just a second there...
13:26:04 <Jedai> , sortBy (comparing head ++ comparing length) [[1],[2,3,4],[2,5]]
13:26:06 <lunabot>  luna: Not in scope: `comparing'
13:26:09 <PeakerWork> Should we have both a Monoid class and a separate ((*) and one) class (which is yet another Monoid, that may have a relationship to Monoid)?
13:26:23 <FunctorSalad_> PeakerWork: yes
13:26:23 <Jedai> , sortBy (compare `on` head ++ compare `on` length) [[1],[2,3,4],[2,5]]
13:26:24 <lunabot>  luna: Couldn't match expected type `[a]'
13:26:29 <olsner> at least the basic stuff should be in the prelude so that the fancy stuff in the prelude can reuse it
13:26:36 <Cale> Well, at some point we might go with separate Additive and Multiplicative classes
13:26:53 <PeakerWork> FunctorSalad_: in that case maybe instead of (++) and whatever it should just be (+) and (*) and the default instance for number monoids/whateveroids should be (+) and (*) ?
13:26:53 <Cale> and then a Num which ties them together when they have a distributive law.
13:27:00 <Jedai> , sortBy ((compare `on` head) ++ (compare `on` length)) [[1],[2,3,4],[2,5]]
13:27:01 <lunabot>  luna: Couldn't match expected type `[a]'
13:27:46 * Baughn desperately hopes vacuum works without change on 10.3
13:28:16 <FunctorSalad_> PeakerWork: default instance? it seems Addoid and Multoid should just be superclasses of Num in that case
13:28:47 * Heffalump objects to too much overloading
13:28:47 <Jedai> FunctorSalad_: We need typeclass alias !
13:28:56 <Cale> Actually, if we're going that way, I think multiplicative notation makes more sense for list concatenation.
13:29:00 <Heffalump> at least until we can figure out some way of having the overloaded and non-overloaded versions be the same function
13:29:06 <Cale> (+) makes one think that the operation is commutative
13:29:12 <FunctorSalad_> Cale: was going to say that
13:29:26 <wli> There is the problem of 0 being an annihilator.
13:29:48 <Cale> Well, for Multiplicative we'd have one instead of zero
13:29:52 <SamB> wli: you replace it with 1...
13:29:58 <Jedai> Cale: I would really prefer that we keep to zero and (++) for Monoid and create separate Additive and Multiplicative typeclass
13:30:09 <Cale> Jedai: yeah
13:30:32 <wli> The problem is that the additive and multiplicative interact via 0 being an annihilator in the multiplicative arena.
13:30:42 <wli> That is awkward to represent via typeclasses.
13:30:44 <Cale> The other trouble with splitting Additive and Multiplicative, is that one really nice thing about keeping them together is you can use fromInteger as a more efficient way to get 0 and 1
13:30:53 <FunctorSalad_>  > [1] ++ inv [1]
13:30:55 <FunctorSalad_> []
13:30:56 <Cale> (and other numeric constants derived from them)
13:31:05 <Jedai> wli: Because the current typeclass hierarchy is not awkward ?
13:31:14 <FunctorSalad_> I wonder whether that would have actual real-life uses
13:31:23 <Baughn> mmorrow: To a first approximation, vacuum seems to work on 6.10.3 as well as 10.2 and 10.1
13:31:30 <Cale> wli: Well, you'd have Num, for when there's distributivity.
13:31:32 <Jedai> There's plenty we don't know how to say in the typeclass frame
13:31:39 <Cale> wli: Which would be a subclass of both.
13:32:05 <wli> Yeah, but all it is is subclassing both and then hoping for a particular invariant.
13:32:08 <Heffalump> in what way does (*) seem less commutative than (+) ?
13:32:18 <hatds> Jedai: I would say the current one isn't for the most part
13:32:23 <Cale> wli: Actually, I think it might be good to have fromInteger in there too.
13:32:33 <Jedai> wli: Not much different from the current situation then
13:32:38 <Cale> Heffalump: It's a usual convention in mathematics.
13:32:40 <PeakerWork> Heffalump: its not cummutative on matrices and other stuff
13:32:45 <vininim> exit
13:33:15 <Jedai> hatds: Seriously ? It's not very nice : useful yes, but elegant or logic...
13:33:17 <Cale> Heffalump: For Abelian groups, for instance, we often use additive notation, but never for nonabelian ones.
13:33:47 <Cale> Heffalump: and yeah, noncommutative rings are still required to have a commutative (+)
13:34:11 <hatds> Jedai: It is elegant for what it was designed to do: numbers.
13:34:41 <hatds> for the most part
13:34:43 <hatds> :)
13:34:51 <Jedai> hatds: You would be one of the rare person to express this opinion in the Haskell world :)
13:34:54 <mmorrow> Baughn: oh nice, i should update the hackage pkg
13:35:02 <hatds> I actually just changed my mind about it recently
13:35:08 <Baughn> mmorrow: I'm confused about closureType, though
13:35:18 <mmorrow> Baughn: what about?
13:35:25 <Baughn> mmorrow: Near as I can tell, it always evaluates what you pass it..
13:35:27 <PeakerWork> hatds: the Num class is all wrong :(
13:35:32 <PeakerWork> @type abs
13:35:33 <lambdabot> forall a. (Num a) => a -> a
13:35:35 <hatds> PeakerWork: how so?
13:35:36 <Cale> Actually, I think the current numeric hierarchy is a lot better than we normally give it credit for as well. The *main* problems are the fact that Num has abs and signum and those superclass dependencies.
13:35:48 <PeakerWork> hatds: that abs is all wrong, for one
13:35:52 <mmorrow> Baughn: yes, or else the ClosureType is AP
13:36:02 <Cale> hatds: Most types of numbers don't have abs
13:36:07 <Baughn> mmorrow: So when does it return a thunk type?
13:36:15 <PeakerWork> hatds: you also have no way of writing general functions that operate on various stuff, vector spaces, matrices, with certain properties, either
13:36:17 <mmorrow> Baughn: never :(
13:36:21 <Cale> hatds: and even fewer have an abs which is again the same type of number
13:36:36 <mmorrow> Baughn: well, wait leme think here
13:36:37 <hatds> that's why it makes sense to look at the Num hierarchy as intended for complex numbers and subsets of them
13:36:59 <Baughn> mmorrow: Um. Some background - to make unamb more efficient, we (conal and me) would like some way of telling whether a given value is in weak-head normal form or not instead of just blindly forking a thread to evaluate it. Can you help?
13:37:01 <wli> Real numbers, complex have abs of different type.
13:37:21 <hatds> absolute value of a complex number is complex :)
13:37:24 <mmorrow> , let !x = 42 in closureType x {- this is a different closureType, just remembering -}
13:37:28 <lunabot>  Constr
13:37:36 <mmorrow> , let !x = 42 + 1 in closureType x {- this is a different closureType, just remembering -}
13:37:38 <lunabot>  Constr
13:37:42 <Baughn> _0_1
13:37:47 <mmorrow> , let !x = const 42 in closureType x {- this is a different closureType, just remembering -}
13:37:50 <lunabot>  PAP
13:38:09 <PeakerWork> hatds: its actually just one component of Complex, but of course by zeroizing the other you can coerce it into a complex, but you lose type information
13:38:12 <mmorrow> , isFullyEvaluated 42
13:38:14 <lunabot>  False
13:38:25 <hatds> :t abs
13:38:27 <lambdabot> forall a. (Num a) => a -> a
13:38:27 <mmorrow> Baughn: there's that function in RtClosureInspect
13:38:35 <olsner> , isFullyEvaluated $! 42
13:38:38 <lunabot>  True
13:38:45 <hatds> complex satisfies the type sig for abs imho
13:38:46 <Baughn> mmorrow: Where's that?
13:38:50 <mmorrow> Baughn: (but iirc it just cases on the ClosureType)
13:39:01 <mmorrow> Baughn: RtClosureInspect
13:39:10 <Cale> hatds: Without those silly Eq and Show constraints we could also make lifting Num instances for things like functions whose codomain is in Num.
13:39:21 <Cale> hatds: So you could write functions like  (sin + cos)
13:39:23 <mmorrow> ghci> :t RtClosureInspect.isFullyEvaluated
13:39:23 <mmorrow> RtClosureInspect.isFullyEvaluated :: forall a. a -> IO Bool
13:39:43 <Baughn> mmorrow: Ah, ghc-internal package..
13:40:07 <Jedai> hatds: Yes, but you lose information
13:40:25 <mmorrow> Baughn: hmm, if you are getting the ClosureType as a result of vacuum, then you'll also be forcing the value, but if you get it by other means you won't necessarily be forcing it
13:40:37 <hatds> Cale: I don't think it is so bad to design a typeclass around numbers and not expressions representing numbers or functions which return numbers
13:40:59 <hatds> Jedai: I'm probably missing something
13:41:02 <Cale> hatds: But those *are* numbers too.
13:41:07 <mmorrow> Baughn: i'll try to add something along those lines to vacuum when i update it for 6.10.3
13:41:10 <Cale> hatds: In that they form a ring.
13:41:13 <hatds> well, functions form a ring
13:41:14 <hatds> yea
13:41:20 <hatds> Num isn't called Ring
13:41:31 <Baughn> mmorrow: isFullyEvaluated appears to do a recursive check of evaluative-ness, so no go
13:41:36 <skorpan> what do you call it when functions are just like any other values?  "functions are first-order?"
13:41:45 <Heffalump> first-class
13:41:45 <dibblego> > let f = (join .) . zipWith (\a b -> [a, b]) in f [1..5] [6..10] -- is this function in the standard library?
13:41:46 <lambdabot>   [1,6,2,7,3,8,4,9,5,10]
13:41:47 <Cale> hatds: Nor should it be, since Float isn't a ring
13:41:50 <skorpan> first-class, thanks!
13:41:57 <Cale> hatds: But I think rings should be included.
13:41:57 <Baughn> mmorrow: (I'd need something for which "evaluate a >> isFullyEvaluated a" always returns true
13:42:04 <Cale> hatds: (all of them, not just some)
13:42:33 <Jedai> hatds: The result of abs on a complex is not only a complex, it's also a real, and this is not expressed in the signature of abs at all
13:42:44 <roconnor> > 2 - 1 :: Natural
13:42:45 <lambdabot>   1
13:42:50 <Cale> :t magnitude
13:42:51 <lambdabot> forall a. (RealFloat a) => Complex a -> a
13:42:53 <roconnor> > 1 - 2 :: Natural
13:42:54 <lambdabot>   * Exception: Natural: (-)
13:43:01 <Baughn> mmorrow: ..which this seems to do. Hm.
13:43:20 <FunctorSalad_> Jedai: fully taking that idea to its conclusion would require dependent types, though
13:43:21 <Baughn> Okay. It didn't work earlier, but now it does.
13:43:21 <hatds> I think the incongruity between the design and the current frustrations is because it was designed to nicely answer "how do I let the user define their own Int, Integer, Floatingpoints, etc?"
13:43:22 <Cale> roconnor: I think it ought to give 0 for that, just for agreement with lists :)
13:43:25 <Baughn> *shrugs*
13:43:30 <hatds> but people want to write Num instances for Rings, Monoids, etc.
13:43:33 <roconnor> Cale: it is unclear what is best
13:43:50 <Cale> roconnor: There was a very convincing paper about it a while back.
13:43:53 <FunctorSalad_> Jedai: like (*) for Int loses the info that negative * negative |-> positive etc
13:43:53 <hatds> Jedai: so what?
13:44:00 <Jedai> FunctorSalad_: Fully taking static typing to its conclusion require dependent types :)
13:44:03 <Cale> There are a lot of nice laws that it leads to.
13:44:28 <mmorrow> Baughn: oh huh, you're right (recursive check of evaluatedness). weird, i always thought it was checking whnf
13:44:42 <roconnor> Cale: I was reading that HOL defines the distance between 2 natural numbers to be (m - n) + (n - m)
13:44:51 <Jedai> FunctorSalad_: But if we can do better than the current state of thing without full dependent type why not do it ! ^^
13:44:55 <mmorrow> ghci> let foo = isFullyEvaluated <=< evaluate
13:45:02 <mmorrow> ghci> foo (1 + 1, 42 )
13:45:02 <mmorrow> False
13:45:06 <roconnor> HOL light
13:45:30 <mmorrow> (i dunno why)
13:45:34 <Baughn> mmorrow: Well, I can read its source..
13:45:35 <FunctorSalad_> roconnor: that seems evil to me ;)
13:45:48 <mmorrow> , let x = (1+1,42) in x `seq` isFullyEvaluated x
13:45:48 <roconnor> FunctorSalad_: not as evil as isFullyevaluated
13:45:51 <lunabot>  False
13:45:59 <mmorrow> , let x = (1+1,42) in x `seq` closureType x
13:46:02 <lunabot>  Constr
13:46:07 <Jedai> FunctorSalad_: if we just say that it's not worth it because we would need dependent type to fully exploit an idea we should just use dynamic typing and be done with all those questions :)
13:46:08 <mmorrow> , let x = 1 in x `seq` closureType x
13:46:10 <lunabot>  Constr
13:46:16 <mmorrow> , let x = 1 in x `seq` isFullyEvaluated x
13:46:18 <lunabot>  True
13:46:21 <mmorrow> oo
13:46:30 <roconnor> @src isFullyEvaluated
13:46:30 <lambdabot> Source not found. :(
13:46:59 <paper_cc> , let x = (1+1, 42) :: (# Int, Int #) in x `seq` isFullyEvaluated x
13:47:00 <lunabot>  luna: parse error on input `Int'
13:47:01 <FunctorSalad_> Jedai: I wasn't thinking that incomplete type-safety isn't worth it
13:47:04 <roconnor> is that function real?
13:47:09 <roconnor> @hoogle isFullyEvaluated
13:47:10 <lambdabot> No results found
13:47:18 <mmorrow> roconnor: it looks at the tag on the closure and based on it returns true or false
13:47:25 <paper_cc> ,src 'isFullyEvaluated
13:47:27 <lunabot>  isFullyEvaluated :: forall a . a -> Bool
13:47:38 <roconnor> mmorrow: is it safe?
13:47:39 <mmorrow> ghci> :i isFullyEvaluated
13:47:39 <mmorrow> isFullyEvaluated :: forall a. a -> IO Bool
13:47:39 <mmorrow>   	-- Defined in RtClosureInspect
13:47:50 <mmorrow> what does safe mean?
13:48:00 <Baughn> mmorrow: So I just need to use getCLosureData >>= tipe, and case for the things I consider to be whnf
13:48:06 <mmorrow> (it won't cause a segfault)
13:48:08 <roconnor> mmorrow: it seems like the type of operation that would destroy what little semantics we have for IO.
13:48:27 <Baughn> mmorrow: Hm. Oddly enough, it doesn't consider functions to be in normal form? o_O
13:48:29 <Jedai> FunctorSalad_: No, I understand, anyway abs fundamentally shouldn't be a -> a since it's a projection on a structured subset
13:48:41 <mmorrow> Baughn: yeah, you may want to write your own version
13:48:48 <paper_cc> , isFullyEvaluated id
13:48:50 <Baughn> mmorrow: Doing that. Thanks for the pointer!
13:48:50 <lunabot>  False
13:48:55 <mmorrow> Baughn: :)
13:49:02 <Baughn> mmorrow: Unamb, and reactive, will be even more awesome now.
13:49:06 <mmorrow> heh
13:49:31 <Jedai> FunctorSalad_: so it's current type is a little bit weak and besides as pointed it is not always very well defined for everything we would like to make a Num instance
13:50:17 <Baughn> mmorrow: ..awesomely complex, too. grovelling over closure data inside unsafePerformIO calls doing weird exception mangling to control the restart semantics...
13:50:34 <Jedai> FunctorSalad_: Not to say it's an absolutely horrific problem... But just to point one of the deficiencies of the current numeric hierarchy
13:50:41 <mmorrow> Baughn: yay fun!
13:51:27 <mmorrow> roconnor: what about (seeTheTruth =<< readFile "/dev/mem") ? ;)
13:51:28 <FunctorSalad> (possible double msg) Jedai: I wasn't thinking that incomplete type-safety isn't worth it
13:51:29 <Baughn> mmorrow: It's the sort of thing I think would make roconnor shiver in fear
13:51:34 <Baughn> Or possibly disgust
13:51:57 <Jedai> FunctorSalad: I saw this one, my answer was
13:52:02 <shutterbug> i knew a dude named haskel once
13:52:03 <Jedai> FunctorSalad_: No, I understand, anyway abs fundamentally shouldn't be a -> a since it's a projection on a structured subset
13:52:09 <Jedai> FunctorSalad_: so it's current type is a little bit weak and besides as pointed it is not always very well defined for everything we would like to make a Num instance
13:52:14 <Jedai> FunctorSalad_: so it's current type is a little bit weak and besides as pointed it is not always very well defined for everything we would like to make a Num instance
13:52:16 <Baughn> shutterbug: It /is/ named after a mathematician
13:52:41 <shutterbug> oh cool
13:52:50 <shutterbug> yeah he was good at math
13:52:51 <Baughn> Haskell Curry
13:52:54 <FunctorSalad> Jedai: I agree, mathematically it really belongs to a "normed vector space" class, where you couldn't have abs into the same type at all
13:52:55 <mmorrow> roconnor: i think it's separate from any abstract  treatment of IO, because it depends not only on a particular implementation, but also on whoever wrote it's idea of what closuretypes are fully evaluated
13:53:14 <FunctorSalad> Jedai: (and where the codomain is fixed to be the real numbers)
13:53:16 <Baughn> roconnor: Say, are you good at debugging weird IO code?
13:53:25 <olsner> , fix isFullyEvaluated
13:53:27 <lunabot>  False
13:53:37 <hatds> abs is somewhat weird for Num.   I agree that a complexabs function whose domain is only overloaded on complex numbers should have a different range
13:53:59 <mmorrow> , let implode f = let !x = f x in x in implode isFullyEvaluated
13:54:00 <lunabot>  luna: Recursive bang-pattern bindings aren't allowed: { !x = f x }
13:54:03 <mmorrow> awww
13:54:39 <Heffalump> well, duh :-)
13:54:51 <Heffalump> why not just write let !x = undefined and be done with it?
13:55:13 <roconnor> Baughn: nope
13:55:25 <mmorrow> Heffalump: :)
13:55:29 <roconnor> mmorrow: does it violate the monad laws?
13:55:39 <mmorrow> roconnor: does what?
13:55:50 <mmorrow> , [$ty| isFullyEvaluated |]
13:55:53 <lunabot>  forall a . a -> Bool
13:56:12 <roconnor> mmorrow: isFullyEvaluated?
13:56:16 <mmorrow> (unsafePerformIO . isFullyEvaluated) for teh bot
13:56:47 <mmorrow> roconnor: but i mean, how could/would it? (i can't think of why)
13:57:13 <roconnor> mmorrow: maybe associating bind one way returns True, and the other way returns False.
13:57:34 <BMeph> There's a woman named Haskell (last name, not complete name), who made a hole-in-one on her first go on a golf course. I've never heard of anyone named Java doing that. ;p
13:57:42 <roconnor> , fix isFullyEvaluated
13:57:43 <olsner> it breaks referential transparency, right? so I'd say all bets are off :)
13:57:44 <lunabot>  False
13:57:58 <mmorrow> well if someone defined a monad instance that way, that'd be no different than you just doing that explicitly
13:58:16 <roconnor> olsner: well, the unsafePerformIO one certainly does.
13:58:19 <olsner> , let x = 3 in (isFullyEvaluated x, isFullyEvaluated $! x)
13:58:21 <mmorrow> olsner: but since (not the bot's version) is in IO..
13:58:21 <lunabot>  (False,True)
13:58:22 <mmorrow> yeah
13:58:32 <mmorrow> the bot just need it since it can't do IO
13:58:54 <roconnor> mmorrow: usually people don't define monads that violate the monad laws.
13:58:59 <olsner> BMeph: :D
13:59:02 <mmorrow> roconnor: exactly! :)
13:59:16 <roconnor> ...
13:59:29 <mmorrow> i'm saying that i don't see how this would make it magically possible to do that by accident
13:59:55 <FunctorSal> the monad laws are there to keep the honest people out? ;)
14:00:03 <roconnor> mmorrow: maybe associating bind one way returns True, and the other way returns False.
14:00:14 <roconnor> mmorrow: or does that not happen.
14:00:20 <mmorrow> roconnor: i don't understand though what you mean
14:00:29 <Heffalump> isn't isFullyEvaluated in IO?
14:00:31 <mmorrow> what is changing bind here?
14:00:37 <mmorrow> Heffalump: yes
14:00:59 <roconnor> (f >=> g) >=> isFullyEvaluated  =?=  f >=> (g >=> isFullyEvaluated)
14:01:05 <Baughn> ..the heck is a "Thunk 22"?
14:01:21 <Heffalump> so who cares if you can distinguish two supposedly equal computations?
14:01:22 <mmorrow> roconnor: hah, oh i see what you're talking about
14:01:40 <olsner> Baughn: don't force it :)
14:02:04 <Baughn> olsner: I won't. It's undefined.
14:02:11 <mmorrow> roconnor: perhaps :)
14:02:17 <roconnor> :)
14:02:20 <roconnor> I demand proof!
14:02:24 <Baughn> olsner: But tell me, can I rely on undefined consistently showing up as a single Thunk type?
14:02:29 <roconnor> you
14:02:34 <olsner> roconnor: hmm, but isn't that decided by the fixity of the >=> operator?
14:02:36 <roconnor> you can't handle the proof!
14:02:37 <Heffalump> you could already use the stable names API to distinguish (let x = 1+1 in x) and (let y = 1+1 in y)
14:02:46 <roconnor> olsner: that is a monad law.
14:03:05 <Baughn> olsner: ..fair warning, if you say "Yes" I will add an unsafePerformIO to check the thunk type of undefined at.. some point, and check against those in unamb
14:03:07 <olsner> oh, nm, you can of course add parentheses yourself
14:03:13 <lyaunzbe> Hey guys. For Shell sort, is the worst-case O(n^2) and the best case O(n)?
14:03:21 <mmorrow> roconnor: hm, actually i'm not sure that it does violate that
14:03:28 <roconnor> I'm not sure
14:03:32 * mmorrow checks
14:03:46 <roconnor> @check \f g -> (f >=> g) >=> isFullyEvaluated  ==  f >=> (g >=> isFullyEvaluated)
14:03:47 <lambdabot>   Not in scope: `isFullyEvaluated'Not in scope: `isFullyEvaluated'
14:04:02 <mmorrow> the bot's one isn't in IO..
14:04:09 <roconnor> ,check \f g -> (f >=> g) >=> isFullyEvaluated  ==  f >=> (g >=> isFullyEvaluated)
14:04:10 <lunabot>  luna: parse error on input `\'
14:04:17 <olsner> couldn't you put something in the expression for f and g that, when forced, also forces something that is examined by isFullyEvaluated?
14:04:17 <mmorrow> no check :(
14:04:39 <mmorrow> hmm
14:04:48 * Heffalump still wants to know why anyone cares
14:05:01 <roconnor> Heffalump: about monad laws?
14:05:16 <Heffalump> no, about the fact that IO can observe differences in supposedly equal expressions
14:05:43 <Heffalump> isFullyEvaluated breaks much more than the monad laws, it's not referentially transparent at all
14:05:53 <roconnor> Heffalump: it makes the semantics of IO more tricky, and hence more difficult to reason about your code.
14:05:56 <Heffalump> if you don't have referential transparency, why would the monad laws matter?
14:06:08 <roconnor> Hmm
14:06:27 <Heffalump> sorry, I can see why you might be bothered that IO breaks things like that. I can't see why you care about the specific case of isFullyEvaluated and the monad laws.
14:07:03 <roconnor> Heffalump: you make a good point about referential transparency.  I wasn't really thinking about that.
14:07:09 <olsner> isn't IO supposed to be able to be referentially transparent about referential opacity?
14:08:05 * roconnor ponder's IO's ability to catch "error"s
14:08:08 <mmorrow> "* Heffalump still wants to know why anyone cares"
14:08:09 <mmorrow> lol
14:08:13 * Heffalump repeats his point about the stable names API too
14:08:15 <mmorrow> yeah, beats me :)
14:08:26 <mmorrow> Heffalump: ooh, that's handay
14:08:27 <Cale> , isFullyEvaluated (3 + 4)
14:08:30 <lunabot>  False
14:08:37 <Cale> :t isFullyEvaluated
14:08:38 <olsner> very #haskell to get into this kind of discussion <3
14:08:39 <lambdabot> Not in scope: `isFullyEvaluated'
14:08:40 <mmorrow> , isFullyEvaluated $! (3 + 4)
14:08:42 <lunabot>  True
14:08:51 <Heffalump> we just need conal to split IO up into semantically sane parts for us
14:08:59 <mmorrow> , let x = 1 + 1 in x `par` isFullyEvaluated x
14:09:02 <lunabot>  False
14:09:03 <mmorrow> , let x = 1 + 1 in x `par` isFullyEvaluated x
14:09:05 <Cale> mmorrow: Does the monad law even typecheck?
14:09:06 <lunabot>  False
14:09:21 <BMeph> @remember Heffalump * Heffalump still wants to know why anyone cares
14:09:22 <lambdabot> I will remember.
14:09:25 <mmorrow> Cale: hah, i dunno .. i couldn't think of anything to even test it against
14:09:34 <Heffalump> it'll typecheck on [Int]
14:09:36 <Heffalump> for example
14:09:48 <BMeph> Ah, quoting out-of-context, for the lulZ... ;p
14:09:51 <Heffalump> it won't typecheck on IO _
14:09:55 * mmorrow quit when he found himself defining let spork io = fix (\tid -> forkIO (io tid)) for no good reason..
14:09:58 <Cale> isFullyEvaluated produces a Bool though...
14:10:11 <Heffalump> it produces an IO Bool
14:10:18 <Cale> but...
14:10:20 <Cale> , isFullyEvaluated (3 + 4)
14:10:23 <lunabot>  False
14:10:25 <roconnor> mmorrow: shouldn't mfix be used there?
14:10:38 <Heffalump> , hPutStrLn "foo"
14:10:39 <lunabot>  luna: Not in scope: `hPutStrLn'
14:10:43 <Heffalump> , putStrLn "foo"
14:10:44 <lunabot>  luna: No instance for (GHC.Show.Show (GHC.IOBase.IO ()))
14:10:48 <Heffalump> oh
14:10:58 <Heffalump> umm, mmorrow was claiming you need to use it with unsafePerformIO above
14:11:06 <mmorrow> roconnor: in that case fix and mfix are two diff things
14:11:16 <Cale> I suppose that it's already got an unsafePerformIO inside it.
14:11:26 <Cale> I think it ought to satisfy the monad laws anyway...
14:11:38 <Cale> But I'd still like to check :)
14:11:42 <mmorrow> Cale: it's in IO, no unsafePerformIOs..
14:11:52 <Cale> mmorrow: Then what's going on up there?
14:11:59 <Cale> , isFullyEvaluated (3 + 4)
14:12:02 <lunabot>  False
14:12:07 <Cale> ^^ Clearly a Bool
14:12:31 <mmorrow> (in particular, it calls the primitive getClosureData#, that gives it the Ptr StgInfoTable, then it uses that Storable instance to peek out the closuretype, then cases on that to determine evaluatedness)
14:12:57 <mmorrow> oh, it's unsafePerformIO'ed in lunabot
14:13:10 <Cale> aha
14:13:25 <mmorrow> but not in RtClosureInspect
14:13:28 <Cale> Where can I get this package?
14:13:35 <mmorrow> it's in the ghc package
14:13:38 <Cale> ah, okay
14:13:40 <mmorrow> ghci -package ghc
14:13:44 <mmorrow> or unhide it
14:13:57 <mmorrow> Cale: it's fun
14:14:07 <Cale> Where is the function?
14:14:18 <mmorrow> RtClosureInspect.isFullyEvaluated
14:14:22 <Cale> ah, okay
14:14:55 <mmorrow> (it makes some odd choices though about what's evaluated, maybe vacuum should have an updated version)
14:15:14 <mmorrow> (odd to me, but maybe i'm wrong..)
14:16:30 <roconnor> Hmm, "Monads for functional programming" doesn't mention the reader monad
14:18:46 <Cale> I can't seem to come up with a case where it breaks the associativity law.
14:19:14 <Cale> I wouldn't expect it to break the IO monad law.
14:19:16 <roconnor> not in "Computational lambda-calculus and monads" either
14:19:51 <Cale> After all, randomIO :: IO Bool doesn't break the IO monad law.
14:20:02 <Cale> So I don't see how isFullyEvaluated would :)
14:20:43 <olsner> the thing is that randomIO wouldn't be affected by the evaluation order of whatever expression produces the randomIO
14:20:56 <olsner> whereas isFullyEvaluated would
14:21:05 <Cale> Not really though.
14:21:22 <Cale> isFullyEvaluated might as well produce a random result as far as the monad laws are concerned.
14:21:33 <Heffalump> how do laws make sense when duplicating an expression produces a different answer?
14:21:42 <Heffalump> you don't even have x == x in that situation
14:21:46 <Cale> (random results might as well depend on everything)
14:22:02 <mmorrow> heh, forkbomb
14:22:04 <Cale> Heffalump: It's the same IO action.
14:22:05 <mmorrow> let bomb = fix (\o -> forkIO (o >> o >> return ()))
14:22:22 <Heffalump> sure, but that's not useful since you can never duplicate the same RealWorld
14:22:23 <mmorrow> get you ^Z fingers ready
14:22:28 <Cale> But in fact, you get the same response anyway.
14:22:46 <Cale> There's no change between the two associations of the result of isFullyEvaluated.
14:22:49 <Heffalump> not if it takes a fraction of a second longer to get to that point (re randomIO) :-)
14:23:15 <roconnor> "Notions of computation and monads." doesn't talk about the reader monad either :(
14:23:19 <mmorrow> , let x = return 42 in x .==. x
14:23:20 <lunabot>  luna: Ambiguous type variable `m' in the constraint:
14:23:26 <mmorrow> , let x = return 42 :: IO Int in x .==. x
14:23:29 <lunabot>  True
14:24:07 <mmorrow> roconnor: you don't want to know what (.==.) is ;)
14:24:11 <Cale> roconnor: I'm fairly sure that some of the first papers on functional programming and monads mention the monad A |-> A^E, which is the same.
14:24:30 <roconnor> Cale: That's what I thought, until I tried to find it.
14:24:48 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5234#a5234 <-- Here's some code implementing whnf-detection.. you get the idea, but I'm not at all sure this is a good idea
14:25:09 * conal looks
14:25:10 <Baughn> conal: For one thing, it depends on GHC internals I don't understand, so I can't be sure of its correctness. For another, hello world is now 22MB.
14:25:20 <SamB> Baughn: isn't that, like, the epitome of a bad idea?
14:25:33 <Baughn> SamB: ..it's unamb. What's one more hack?
14:25:47 <Baughn> conal: The latter problem should be fixed with 6.12, I guess, with shared libraries
14:26:02 <Cale> roconnor: strange :)
14:26:09 <conal> how big was hello-world before?
14:26:14 <roconnor> Cale: did you look?
14:26:17 * Baughn checks
14:26:21 <redbrain> ah frustrated at lack of documenation for curl :(
14:26:34 <Baughn> conal: (I only noticed because linking took noticably longer, on the order of .5 seconds)
14:26:43 <mmorrow> Baughn: heh, ghc is a beast
14:27:25 <paper_cc> mmorrow: and its plural is ghcen?
14:27:42 <Cale> roconnor: yeah, I'm just looking at Moggi's papers, and he appears to have overlooked them
14:27:43 <Baughn> conal: Ah, from 776K to 22MB
14:27:47 <gwern> oh, so that's why pidigits uses Integer and not Int - Int overflows
14:27:51 <mmorrow> Baughn: hahah
14:27:56 <conal> Baughn: yow!  how?
14:28:02 <mmorrow> paper_cc: i like the ring of that
14:28:04 <Baughn> conal: It needs the ghc package
14:28:12 <Baughn> conal: ..meaning the entire compiler gets built in
14:28:14 <conal> Baughn: oh.  hm.
14:28:21 <Baughn> conal: As I said, shared libraries will help, so this isn't a show-stopper
14:28:39 <Baughn> conal: (But the internal-ness of the code might be)
14:28:54 <conal> Baughn: i wonder if we could rope in a ghc-internals expert.
14:28:59 <mmorrow> Baughn: i'll add that to vacuum (and i realized vacuum only is using its ghc dep for one or two constants, so i'm gonna try to rip that out too) when i update it
14:29:02 <Baughn> conal: I mean, I'm returning WHNF for Redirection. I have /no idea/ what Redirection even /means/
14:29:12 <conal> Baughn: yeah, i'm worried about that one.
14:29:25 <Cale> roconnor: He does mention the exponential a whole lot, but the fact that it is itself a monad doesn't come up.
14:29:28 <conal> Baughn: probably worth asking on #ghc
14:29:34 <Baughn> mmorrow: If you could use the interface for my isWHNF function, that'd be great. :)
14:29:41 <FunctorSal> how do you decouple the interfaces of threads who communicate via a chan?
14:29:46 <Baughn> conal: Or we could have mmorrow do our work for us. :P
14:29:57 <mmorrow> Baughn: yeah, the Redirection could be to anything
14:30:03 <conal> Baughn: let's!
14:30:13 <Baughn> mmorrow: So I guess it needs dereferencing, then
14:30:14 <FunctorSal> currently my program is kinda tightly coupled because everyone needs to have the environment holding the chans
14:30:30 <mmorrow> Baughn: if you're not in C, that means evaluating it
14:30:39 <Baughn> conal: Then, for the time being I'd say "use this unamb version, but leave isWHNF = return . const Undecided
14:30:42 <FunctorSal> (obviously I'm a concurrency newb)
14:30:54 <Baughn> mmorrow: Well, it has to be possible
14:30:59 <mmorrow> conal: :)
14:31:07 <mmorrow> Baughn: welcome to my nightmare :)
14:31:11 <conal> :)
14:31:13 <Jedai> FunctorSal: Couldn't you just pass the chan as parameters ?
14:31:18 <Baughn> mmorrow: Possibly we should have some GHC developers add the function? :P
14:31:38 <Cale> FunctorSal: That is sort of the trouble with such concurrency models. You can parametrise the construction of such a thread over its means of communication though...
14:31:45 <mmorrow> Baughn: which? isWHNF?
14:31:45 <FunctorSal> Jedai: I do, but still I somehow don't like this
14:31:50 <Baughn> mmorrow: Yes
14:31:50 <paper_cc> FunctorSal: so, everything is inside ReaderT ChanEnv. why not?
14:32:01 <Baughn> mmorrow: It'd be a generally useful function, if it was at all reliable
14:32:08 <mmorrow> Baughn: yes it would
14:32:10 <Cale> FunctorSal: Like have a  makeWorkerThread :: (Message -> IO ()) -> (IO Message) -> IO ThreadId
14:32:35 <Cale> FunctorSal: where you pass it its means of sending and receiving messages.
14:33:02 <roconnor> Cale: "Monad transformers and modular interpreters" is the best reference I can find.
14:33:14 <mmorrow> i have a hackish way to get it in C, but it's hackish because i'm using the (apparently outdated by a long time) functions in Printer.c as examples for how to pick closures apart, and Printer.c is beyond borked
14:33:15 <FunctorSal> Cale: good point about making the messages a type... currently the protocol is implicitly defined by how the thread function consumes the chan
14:33:48 <mmorrow> Baughn: and the big downside is that you need to make a StablePtr as an intermediate step
14:34:03 <Cale> roconnor: Of course it was known that the exponential is a monad since probably the first weeks of the concept being defined.
14:34:09 <roconnor> sure
14:34:22 <roconnor> I guess I could just not have a reference.
14:34:59 <Baughn> mmorrow: Yes, I think I'll punt it to #ghc for now, and we'll see what happens.
14:35:14 <SamB> Cale: which concept ?
14:35:24 <Cale> roconnor: The paper you just mentioned says "The environment monad is similar to the 'state reader' by Wadler [22]"
14:35:29 <Cale> SamB: Monad
14:35:34 <roconnor> oh
14:35:43 <Cale> [22] Philip L. Wadler. Comprehending monads.
14:35:51 <SamB> Cale: thought probably it was Monad, but I dunno what the exponential is really ...
14:36:02 <Cale> SamB: Function types
14:36:22 <Cale> A^E is how mathematicians often write the set of functions E -> A
14:36:34 <SamB> ah, I've seen that somewhere proofy before ...
14:36:46 <Cale> (and the early papers on monads in computer science share the notation -- it's actually quite elegant in some ways)
14:36:51 <roconnor> Cale: yes it is.
14:36:53 <roconnor> woot
14:37:00 <Baughn> conal: And while I was writing absurdly low-level haskell code, it'd never occurred to me to use case on a transient tuple before. I feel oddly lopsided.
14:37:20 <FunctorSal> Hask is sort of a special case because the "internal" function types (=exponentials) are just like the external ones...
14:37:42 <FunctorSal> (or are they?)
14:37:47 <SamB> Baughn: isn't that the only way Core can do it ?
14:37:55 <SamB> hmm ... well, maybe not only
14:37:59 <Cale> Well, we don't write everything in terms of composition, so yeah, the distinction is not important to us.
14:38:24 <SamB> Cale: we don't ?
14:38:26 <Baughn> SamB: What I mean is, I started doing a bizarre cascade of "case a of ... -> case b of ...; case b of ...".. etc.
14:38:41 <Baughn> SamB: As opposed to doing just "case (a,b) of ...". :P
14:38:51 <SamB> Baughn: oh, I might not think of that either ;-)
14:39:10 <Cale> SamB: We can write things like  map f [] = []; map f (x:xs) = f x : map f xs
14:39:30 <SamB> Cale: but we hates to have to
14:39:39 <SamB> it's not easy to read
14:40:48 <FunctorSal> (can't think of a good example now though)
14:40:53 <Cale> If all your values are functions 1 -> A, then you end up needing a way to go back and forth between 1 -> (A -> B) and A -> B
14:41:17 <Cale> which is more or less the same as going between 1 -> B^A and A -> B which is what the exponential lifting is all about
14:41:41 <Baughn> conal: ..also, the top-level comments in unamb.hs are /way/ off now.
14:42:03 <conal> Baughn: i bet!
14:42:50 <Cale> Or things like (A -> B, A) -> B
14:43:07 <Cale> Hard to write points-free without some primitives which do it for you :)
14:44:10 * monochrom kisses curry and uncurry, the exponential lifters and unlifters here. :)
14:44:52 <monochrom> It's also very pleasing that they fit the category-theory characterizations.
14:45:25 <Cale> Yeah, the natural isomorphism Hom(XÃ—Y,Z) -> Hom(X,Z^Y)
14:45:41 <Cale> :t curry
14:45:43 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
14:46:12 <monochrom> I am not a bigot about point-free but I find more opportunities of judicious point-free than most people want to believe.
14:46:30 <monochrom> (And you all know my sarcasm on this issue.)
14:47:12 <Cale> Oh, are you being sarcastic?
14:47:36 <Apocalisp> How do you pronounce >=> and <=< ?
14:47:51 <monochrom> I mean http://www.vex.net/~trebla/weblog/pointfree.html which you have seen.
14:47:54 <Apocalisp> "fish"
14:48:00 <jak> why are functions not showable?
14:48:01 <Cale> Apocalisp: Kleisli composition for <=< and flipped Kleisli composition for >=>
14:48:29 <Apocalisp> If you were reading (a >=> b >=> c) over the phone?
14:48:30 <Cale> monochrom: ah, hehe
14:48:39 <monochrom> People speak like no one uses pointfree, then they happily use shell pipelines in shell scripts.
14:48:44 <mmorrow> @let let x \-> f = f x
14:48:45 <lambdabot>   Parse error
14:48:47 <Cale> Apocalisp: hmm...
14:48:48 <Apocalisp> "a fish b fish c" :)
14:48:50 <mmorrow> @let x \-> f = f x
14:48:51 <lambdabot>  Defined.
14:48:54 <Cale> Apocalisp: perhaps :)
14:49:22 <monochrom> People like to believe that math is hard and useless. They create nice double-standards to sustain that belief.
14:50:59 <FunctorSal> true
14:51:47 <FunctorSal> admittedly some math may be useless, but people overreact ;)
14:51:50 <Cale> I'm so glad that <=< is finally in the libraries
14:52:00 <Cale> It's so much nicer to explain the monad laws in terms of it
14:52:10 <mauke> tee hee
14:52:16 <monadic_kid> thats got to be the funniest thing i've ever read: http://tech.slashdot.org/comments.pl?sid=1244601&cid=28085625
14:52:32 <mauke> just happened in #perl: <icke> eval: join '', grep /[[:punct:]]/, map chr, 0 .. 127   <buubot3> icke: !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
14:52:35 <monochrom> Is <=< just like the <<< of Arrow?
14:52:40 <mauke> nicely pointfree!
14:52:45 <BONUS> for the Kleisli arrow yeah
14:53:33 <monochrom> Yes, the associative law for >>= is a bit "not very obviously saying associative".
14:53:37 <mmorrow> > foldl (flip id) x [f,f,f,f,f]
14:53:38 <lambdabot>   f (f (f (f (f x))))
14:53:40 <mmorrow> > foldr (.) id [f,f,f,f,f] x
14:53:42 <lambdabot>   f (f (f (f (f x))))
14:53:48 * mmorrow thought that was cute
14:54:05 <Cale> and the identity laws even are obscured
14:55:52 <FunctorSal> monadic_kid: hmm?
14:58:58 <monadic_kid> i think he's challenge is funny
14:59:06 <monadic_kid> *his challenge
14:59:17 <Cale> I love the caveat.
14:59:42 <FunctorSal> I guess the answer is that you can't hand-optimise everything once the problem gets complex enough
15:00:09 <QP> isn't what he says true?
15:01:07 <Cale> Once the underlying architecture or the problem domain gets sophisticated enough, it gets easier for a machine to crush a human at hand-optimisation.
15:01:14 <monadic_kid> well considering one point some just made, why would intel bother with Ct if it was
15:02:35 <FunctorSal> http://tech.slashdot.org/comments.pl?sid=1244601&cid=28087189
15:03:36 <Cale> QP: Consider even simple examples like programs written using lazy bytestrings which can often beat similarly naively written C programs. In order to match the performance of the ByteString version in C, you often have to rip out all your calls to library functions and do a bunch of block-I/O inline.
15:04:41 <FunctorSal> bytestring is optimised at a below-C level?
15:04:47 <QP> so naive haskell beats naive C?
15:04:53 <Cale> QP: It can, yes.
15:05:02 <Baughn> QP: Naive haskell would tend to involve String. ;)
15:05:11 <QP> ok, makes sene
15:05:11 <Cale> Right, you can't be *too* naive.
15:05:20 <QP> *sense
15:05:22 <Cale> But you *can* make use of library functions.
15:05:26 <Baughn> FunctorSal: THe inlining and such help a lot
15:05:28 <Cale> Which is the important thing.
15:05:46 <QP> what is inlining?
15:06:16 <Cale> QP: copying the definition of a function in-place into another to compile them together. Usually it's followed by other optimisations.
15:06:31 <Baughn> QP: GHC is a lot smarter about optimizations (including that one) than most C compilers
15:06:36 <Cale> C compilers do it too.
15:06:49 <Baughn> Yes, but not usually for calls to shared library code. :P
15:06:55 <Cale> right
15:07:00 <FunctorSal> must be a nightmare to prove correctness of inlining if you don't have ref. transparency
15:07:11 <olsner> haskell is most powerful when you write it naively and let the compiler do the rest... but sometimes it takes a lot of effort to find the most elegantly naive solution
15:07:11 <Baughn> Inlining isn't a major problem
15:07:46 <Baughn> FunctorSal: I mean, you execute the same code either way, inlining just allows the compiler to remove a function call.. and then specialize the code to the particular call in question
15:07:54 <Cale> ByteString is almost cheating in that it includes a lot of rewrite rules for turning naively written compositions of library calls into something the optimiser will turn into very efficient code
15:08:09 <mmorrow> , foldr (foldr (\x k -> (x:) . k . (x:)) id) [] (repeat [0..3])
15:08:10 <lunabot>  [0,1,2,3,3,2,1,0,0,1,2,3,3,2,1,0,0,1,2,3,3,2,1,0,0,1,2,3,3,2,1,0,0,1,2,3,...
15:08:15 <dibblego> is there better than map return?
15:08:24 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/27c9696fddb31f1d  FPL performance has already beated C performance if you normalize your metric.
15:08:31 <olsner> Cale: optimizing == cheating?
15:08:31 <pumpkin> is there a nice way to iterate over a subrange of a Map?
15:08:37 <FunctorSal> Baughn: hmm ok, I was imagining something like "let x = ... side-effects ... in foo x x"
15:08:44 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a  C is fast but furious too.
15:08:50 <Cale> olsner: Well, it's something you can't usually tell a C compiler :)
15:08:54 <olsner> or do you mean that it's cheating because dons did it instead of ghc?
15:08:58 <mmorrow> pumpkin: you can split it (twice)
15:09:08 <mmorrow> pumpkin: so i guess answer == no
15:09:08 <pumpkin> that's efficient?
15:09:10 <Cale> olsner: Well, yeah, that's sort of the sense in which it's 'cheating'
15:09:27 <mmorrow> pumpkin: you'd be surprised with what's efficient with Maps
15:09:28 <pumpkin> seems like its api could be expanded to include some nice way to iterate over a subrange of it
15:09:29 <Cale> olsner: I don't think it's actually cheating, just that it's something that you wouldn't normally expect, perhaps.
15:09:45 <mmorrow> i M.fromList . some stuff . M.toList  constantly
15:09:54 <monochrom> You don't normally expect a C compiler to accept a bunch of rewrite rules.
15:09:57 <pumpkin> I bet you do
15:10:03 <mmorrow> heh
15:10:05 <Cale> and well, rewrite rules are not actually part of the language, though it's possible that they should be.
15:10:06 <pumpkin> :P
15:10:15 <Cale> (but defining their semantics clearly is hard)
15:10:43 <olsner> pumpkin: heh, I read that as a response to monochrom :)
15:10:53 <pumpkin> hah :)
15:10:56 <FunctorSal> Baughn: hmm it seems I was confusing different concepts
15:11:04 <mmorrow> pumpkin: you can mapWithKey and only update the the key is in the subrangew
15:11:29 <mmorrow> *..the val if the key ..
15:11:31 <monochrom> Haha
15:12:19 <olsner> it's a shame the original Haskellers created String as a concrete type rather than "something that's isomorphic to this thing" such that ByteString would be a transparent optimization
15:12:35 <pumpkin> mmorrow: hmm, or a fold I guess
15:12:50 <pumpkin> yeah, that would've been nice
15:12:53 <olsner> I often find haskell too concrete
15:13:02 <monochrom> We need a "Haskell Vista".
15:13:08 <pumpkin> you should fork off abstractHaskell
15:13:42 <FunctorSal> Habstractell
15:13:48 <monochrom> "Haskell Vista" has UAC which helps improve security. :)
15:14:01 <monochrom> Err that is not funny enough.
15:14:14 <FunctorSal> hmm.
15:14:15 <monochrom> "Haskell Vista" has UAC which helps improve abstraction. UAC = user abstraction control :)
15:14:27 <olsner> monochrom: "are you sure you want to break referential transparency?"
15:14:37 <monochrom> haha that's neat
15:15:01 <pumpkin> lol
15:15:13 <olsner> "unsafePerformIO is requesting access to your system ..."
15:15:15 <mmorrow> > (\p f -> uncurry M.union . first (M.map f) . M.partition p) (<3) (*20000) (M.fromList (zip [0..] [1..4]))
15:15:17 <lambdabot>   fromList [(0,20000),(1,40000),(2,3),(3,4)]
15:15:35 <mmorrow> partition though is O(n) i guess
15:15:41 <mmorrow> i'd split it if you can
15:15:48 <pumpkin> the new pidigits program makes me feel really good about haskell
15:15:58 <mmorrow> (if you 'p' is s.t. that is possible)
15:16:11 <olsner> "Habstractell: Type classes all the way down!"
15:16:25 <mmorrow> (and gmp at the bottom :)
15:16:44 <olsner> it probably would have to, at some point, involve a concrete syntax though :(
15:16:47 <Cale> olsner: Well, to be honest, I still find String really nice and convenient for programs which don't need to be efficient.
15:17:13 <aavogt> is there something like GtkDatabox for gtk2hs: http://www.eudoxos.net/gtk/gtkdatabox/screenshots/index.html
15:17:39 <olsner> yeah, it still should be easy, only abstracted a little bit so that -foptimize-strings can do the warm-and-fuzzy on them
15:17:57 <dcoutts> aavogt: there might be some code around to render plots using cairo
15:17:59 <Cale> aavogt: Well, it's a bit lower-level than that, but you could use Cairo.
15:18:11 <aavogt> or at least a simple way to be able to specify coordinates with the mouse
15:19:10 <aavogt> Cale, dcoutts, I'll take a look at cairo then. Thanks!
15:19:49 <olsner> like how std::string abstracts away the representation of a string, rather than being a typedef for list<char>
15:20:40 <mmorrow> ideally though you'd be able to pattern match on String as if it were a list of Chars regardless of the implem
15:20:53 <FunctorSal> view patterns?
15:21:13 <mmorrow> or else i don't see what you gain
15:21:39 <olsner> yeah, of course, you should also allow all sequence-like things to be patternmatched as lists
15:21:51 <mmorrow> that would rock
15:22:05 <olsner> abstraction ftw :)
15:22:15 <aavogt> like the interface to Data.Sequence?
15:22:30 <FunctorSal> Foldable.foldr is pretty much equivalent to list-pattern-matching, isn't it
15:22:47 <pumpkin> > 0 * (0 / 0)
15:22:48 <lambdabot>   NaN
15:23:15 <mmorrow> > show =<< repeat (0/0)
15:23:17 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa...
15:23:28 <sbahra> heh
15:23:57 <pumpkin> > show <=< repeat $ 0/0
15:23:58 <lambdabot>   "NaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNaNNa...
15:24:03 <pumpkin> mine is cooler
15:24:06 <sbahra> pumpkin, I've facebook stalked you
15:24:10 <pumpkin> sbahra: zomg
15:24:31 <pumpkin> counterstalked
15:24:55 <Axman6> orthogoal stalked!
15:24:59 <Axman6> n*
15:25:00 <olsner> aavogt: kind of... but what I want is rather that all code that is written as if it works on lists is just desugared into code that works on sequences
15:25:53 <BMeph> monochrom++
15:26:18 <monochrom> Eh? What good deed did I do? :)
15:26:33 <BMeph> "... the process of corrupting data, planting
15:26:33 <BMeph> backdoors, granting superuser access to everyone, and creating "buffer
15:26:33 <BMeph> overrun exploits" and "stack overrun vulnerabilities" entries on
15:26:33 <BMeph> Bugzilla proceeds at maximum speed permitted by today's technology.
15:26:33 <BMeph> In this sole and precise sense, C beats Haskell hands down."
15:26:41 <monochrom> Haha
15:27:01 <jak> why are functions not showable?
15:27:04 <Axman6> heh
15:27:20 <Axman6> o.O
15:27:21 <monochrom> Functions are not showable because it would take extra work.
15:27:25 <pumpkin> jak: haskell doesn't keep around the source code
15:27:38 <pumpkin> jak: and it would be a pain to show partially applied functions
15:27:52 <olsner> jak: there's a module that provides a Show instance for functions that simply prints the type
15:28:01 <Berengal> instance Show (a -> b) where show _ = "<<function>>"
15:28:01 <monochrom> I also mean extra work of low utility.
15:28:23 <monochrom> About the only reason to show functions is to help debugging.
15:28:34 <FunctorSal> olsner: how does it know?
15:28:35 <hatds> show is also thought of as "serialize" it seems
15:28:49 <pumpkin> maybe I'll write a GHC extension that makes functions showable! the most useful thing ever ;)
15:28:50 <olsner> of course it's not actually printing the *function*, but it's useful occasionally (but you might as well just use @type or :type)
15:28:52 <monochrom> Ah, I missed serialization.
15:29:43 * Axman6 thinks the topic is getting dated
15:29:49 <monochrom> Either way, it's a lot of work and we don't have enough resource.
15:29:49 <olsner> FunctorSal: type classes and magic I presume
15:29:52 <pumpkin> who's dating the topic?
15:30:35 <aavogt> is the magic Typeable/TypeRep?
15:31:42 <FunctorSal> with a Typeable constraint I can believe it ;)
15:31:55 <aavogt> > Data.Typeable.typeOf (+1)
15:31:57 <lambdabot>   Integer -> Integer
15:32:14 <pumpkin> :t Data.Typeable.typeOf
15:32:16 <lambdabot> forall a. (Typeable a) => a -> TypeRep
15:32:20 <pumpkin> that's nice
15:32:57 <olsner> I may have actually dreamt up this module, now I can only find evidence of Text.Show.Functions which simply prints "<function>"
15:33:02 <olsner> > show (+1)
15:33:04 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:33:04 <lambdabot>    arising from a use of `...
15:33:08 <vininim> > Data.Typeable.typeof (foldr (+1) >>=)
15:33:09 <lambdabot>   Not in scope: `Data.Typeable.typeof'
15:33:18 <vininim> > Data.Typeable.typeOf (foldr (+1) >>=)
15:33:19 <lambdabot>   No instance for (GHC.Num.Num (b -> b))
15:33:19 <lambdabot>    arising from the literal `1' at <...
15:33:44 <aavogt> > fix Data.Typeable.typeOf
15:33:45 <lambdabot>   TypeRep
15:33:50 <pumpkin> > Data.Typeable.typeof (loop (snd &&& fst))
15:33:51 <lambdabot>   Not in scope: `Data.Typeable.typeof'
15:33:58 <pumpkin> > Data.Typeable.typeOf (loop (snd &&& fst))
15:33:59 <lambdabot>   Add a type signature
15:34:06 <Berengal> @hoogle (MonadPlus m) => Bool -> m a -> m a
15:34:07 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
15:34:07 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
15:34:07 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
15:34:10 <Axman6> thats cheating!
15:34:29 <aavogt> TypeReps seem to be monomorphic
15:34:48 <FunctorSal> :t typeOf6
15:34:49 <lambdabot> forall (t :: * -> * -> * -> * -> * -> * -> *) a b c d e f. (Typeable6 t) => t a b c d e f -> TypeRep
15:34:59 <Berengal> Is there no (MonadPlus m) => Bool -> m a -> m a function anywhere?
15:35:19 <Berengal> @type let f b m = if b then m else mzero in f
15:35:20 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> m a -> m a
15:35:23 <gwern> hm. should there be any performance difference between '[next state | state â†  map snd digits]' and 'map (next . snd) digits'?
15:36:17 <FunctorSal> > typeOf1 ["foo"]
15:36:18 <lambdabot>   []
15:36:29 <FunctorSal> > typeOf1 undefined
15:36:30 <lambdabot>   Add a type signature
15:36:36 <Berengal> @type (\b m -> guard b >> m)
15:36:37 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
15:36:40 <FunctorSal> > typeOf1 [undefined]
15:36:41 <lambdabot>   []
15:36:50 <pumpkin> gwern: I think they should be identical
15:36:59 <monochrom> I think [next state | state â†  map snd digits] may be slower if the compiler is naive.
15:37:01 <pumpkin> gwern: due to rewrite rules merging adjacent maps
15:38:39 <gwern> pumpkin: I think there is a difference, looking at the core
15:38:51 <gwern> from a diff of ghc-core on the 2 versions:
15:38:53 <gwern> 18c17
15:38:54 <gwern> <     1 mapList
15:38:54 <gwern> ---
15:38:54 <gwern> >     2 mapList
15:38:56 <lambdabot>   Not in scope: `mapList'
15:39:04 <pumpkin> gwern: you compiling with -O2 ?
15:39:18 <gwern> does ghc-core take options like that?
15:39:31 <pumpkin> I think it compiles it with -O2 by default
15:39:33 <gwern> (doesn't seem to)
15:40:04 <pumpkin> "mapList"   [1]  forall f.      foldr (mapFB (:) f) []  = map f
15:40:10 <gwern> actually, this is very annoying - the identifiers differ between the two versions...
15:40:15 <pumpkin> I can't even find the rule for map f . map g = map (f . g)
15:40:19 <pumpkin> I was sure I'd seen one
15:40:42 <pumpkin> oh
15:40:42 <pumpkin> "mapFB"     forall c f g.       mapFB (mapFB c f) g     = mapFB c (f.g)
15:41:20 <jak> > map (<$> (+1) (+4)) [1,2,3]
15:41:21 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
15:41:22 <lambdabot>    arising from the literal `1' at <...
15:41:22 <pumpkin> it's made more obscure by the foldl/build fusion though
15:43:55 <pumpkin> Axman6: glsl?
15:44:22 <pumpkin> oh, I see
15:44:26 <Axman6> OpenGL for low powered devices
15:44:51 <FunctorSal> the usenet thread monochrom linked seems interesting, but 171 posts :(
15:45:05 <monochrom> haha
15:45:43 <FunctorSal> "Personally I never had much time for all that guff about polyphonic dependency, monodwarfism constrictions and wotnot. Who needs it?"
15:45:45 <FunctorSal> lol
15:46:15 <Baughn> monochrom: Link?
15:46:45 <CalJohn> what versions of GHC do different linux distributions use?  Debian provides only 6.8.2, which is quite old.  Is this just debian, or are lots of other distros behind?
15:46:55 <pumpkin> most of them are behind
15:47:00 <pumpkin> arch is very well supported though
15:47:41 <Axman6> thanks to dons
15:48:21 <pumpkin> yup :)
15:48:25 <monochrom> Everyone wants to read my words of wisdom!
15:49:06 <CalJohn> hmmm...I don't really want to switch distribution, i think i will just have to stay with this old ghc
15:49:31 <Baughn> CalJohn: Or you could download a binary and install it in /usr/local
15:49:35 <Baughn> THat's what most of us do, I think
15:49:46 <Berengal> Installing the binary isn't hard at all
15:49:48 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/27c9696fddb31f1d and http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
15:49:58 <mreh> does GHC do text preprocessing by default?
15:50:17 <CalJohn> Baughn: mmm, that is an idea
15:50:20 <pastorn> i read a few days ago about exporting haskell functions as C functions, anyone got that link? i can't find it on reddit :/
15:50:22 <mreh> or does it leave it for the c compiler
15:50:36 <pumpkin> mreh: you need to ask for CPP
15:50:43 <pumpkin> {-# LANGUAGE CPP #-} is one way
15:50:49 <monochrom> ghc lets cpp do preprocessing
15:51:01 <mreh> pumpkin, cpp = c++?
15:51:07 <pumpkin> c preprocessor
15:51:11 <mreh> righty
15:51:31 <mreh> that's what i was thinking of...
15:51:39 <mreh> thanks
15:52:12 <pumpkin> hah :) "This speeds up C, in that the process of corrupting data, planting backdoors, granting superuser access to everyone, and creating "buffer overrun exploits" and "stack overrun vulnerabilities" entries on Bugzilla proceeds at maximum speed permitted by today's technology. In this sole and precise sense, C beats Haskell hands down. "
15:52:16 <pumpkin> I like that
15:52:29 <mreh> can you write bits of low-level C in haskell?
15:52:43 <pumpkin> mreh: you can write them externally and link them in if you really want to
15:52:44 * mreh high five
15:52:59 <pumpkin> but usually there isn't much benefit to doing that
15:53:19 <mreh> what if I wanted to write something that manages memory?
15:53:27 <pumpkin> depends, how do you mean?
15:53:31 <mreh> something exciting like that
15:53:43 <mreh> if I want to access the system bus, something really low level
15:53:57 <gwern> pumpkin: but the core does seem to be different, if I've localized it right.  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5235
15:54:25 <pumpkin> mreh: you can do almost everything you'd do in c, in low-level haskell
15:54:28 <Baughn> mreh: You'd probably start by writing bindings to the inb/outb system calls (or whatnot), instead
15:55:00 <Philonous> pumpkin: Where does the quote come from?
15:55:02 <mreh> cool
15:55:12 <mreh> pumpkin: yes, where, it sounds interesting
15:55:12 <pumpkin> Philonous: monochrom's post I think
15:55:12 <Baughn> mreh: You can do anything you can do in C, in haskell, including calling C functions. The only thing you can't do is assembly, but you can't do that in C either. :P
15:55:28 <olivierp> hi, does anyone know if splices will be supported any time soon in [d| ... |] quotes in Template Haskell? I'm writing everything by hand now but it does get painful
15:55:32 <monochrom> the urls are in the scrollback buffer
15:55:49 <mreh> monochrom: how does one access this mythical realm
15:56:03 <gwern> olivierp: if you're waiting for TH bugfixes/features, you'll be waiting a long time
15:56:14 <monochrom> which mythical realm?
15:56:15 <Philonous> Thanks
15:56:22 <mreh> scrollback buffer
15:56:34 <olivierp> gwern: how come? nobody's interested?
15:56:38 <monochrom> I think it's the PgUp key
15:56:43 <gwern> that and it's complex
15:57:15 <mreh> incantations uncessary
15:57:38 <monochrom> I feel unethical to repeat urls in under 10 minutes.
15:57:47 <monochrom> But here it is:
15:57:50 <monochrom> http://groups.google.com/group/comp.lang.functional/msg/27c9696fddb31f1d and http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
15:58:10 <mreh> You get a summary execution on most channels for reposting URLs
15:58:20 <monochrom> Hell, the reptition will only get more and more people to enjoy my words of wisdom.
15:58:45 <Baughn> @thwap monochrom
15:58:46 <lambdabot> Unknown command, try @list
15:58:47 <olivierp> gwern: oh well. i'll just carry on doing things by hand here. do you know if there's something like -ddump-splices but that dumps the Q-monad-level code? so i can copy a version with no splices and work from there
15:58:54 * gwern shrugs
15:59:06 <gwern> pumpkin: any idea about the core? I'm wondering what to do with this observation
15:59:54 <pumpkin> gwern: that is odd... maybe run it through ghc -ddump-simpl and look at it at an early stage of simplification, to see how the list comprehension gets desugared
16:00:12 <mreh> suggestions for a simple GUI api for making games?
16:00:26 <mreh> with 2d and 3d graphics support
16:01:01 <gwern> sdl, I suppose
16:01:20 <mreh> with haskell?
16:01:33 <pumpkin> sure
16:01:38 <mreh> HSDL
16:02:11 <gwern> pumpkin: hm. I find that even less readable than ghc-core
16:02:50 <pumpkin> gwern: yeah :/ but it should resemble the original source a lot more near the top
16:02:58 <Baughn> monochrom: This "alien" fellow is a hoot
16:04:28 <monochrom> There is an alien fellow?
16:05:29 <gwern> @ask dons is there any way to pipe ghc -ddump-simpl foo.hs | ghc-core? doesn't seem to have an option for it
16:05:29 <lambdabot> Consider it noted.
16:05:46 <hatds> roll your own? :)
16:05:55 <hatds> er nvm
16:06:06 <gwern> pumpkin: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5235#a5236
16:06:07 <pumpkin> gwern: eventually when ghc plugins is ready there'll be a core prettyprinter
16:06:13 <FunctorSal> gwern: "ghc-core -- -ddump-simp" ?
16:06:46 <pumpkin> oh wait, I meant -ddump-simpl-iterations and --dump-simpl-phases
16:06:57 <pumpkin> gwern: that will show successive steps of the simplifier
16:07:07 <pastorn> @pl (\x -> (x,True))
16:07:07 <lambdabot> flip (,) True
16:07:12 <pumpkin> -ddump-simpl is the same output that ghc core is pretty printing for you
16:07:25 <monochrom> I see who's the alien fellow now.
16:07:36 <pumpkin> whoops, I meant -ddump-simpl-phases
16:07:37 <gwern> [07:07 PM] 1685Mb$ ghc-core pidigits.hs | wc 4282   12654  394254
16:07:38 <gwern> [07:07 PM] 1685Mb$ ghc-core -- -ddump-simpl pidigits.hs | wc 4282   12654  394254
16:08:01 <pumpkin> -ddump-simpl-iterations is the main one I wanted
16:08:10 <gwern> -_-
16:08:17 <pumpkin> sorry :(
16:08:23 <pumpkin> that'll give you way more lines
16:14:05 <gwern> pumpkin: ok, I've updated the paste
16:14:16 <gwern> I note that the second version, the double map, seems to much shorter
16:15:33 <pumpkin> yeah, that is odd
16:15:34 <gwern> (and it looks to be the same as if I look at ghc -O2 --dump-simpl-phases)
16:16:10 <pumpkin> maybe ask in #ghc ? I thought they should desugar and simplify to the same thing, but it definitely doesn't seem to be the case
16:16:16 <gwern> I guess I should
16:16:18 <pumpkin> might be some weird behavior with the foldr/build fusion
16:18:00 <pejo> gwern, it's easy to patch ghc-core if that's the particular one you want. You might be able to work around it by giving the option for ghc-core to find a ghc with "ghc -ddump-simpl".
16:20:52 <Philonous> It's a bit funny how people when confronted with modern programming languages tend to utter "but the speed" and get back at writing their number crunching application in PHP
16:21:46 <pumpkin> har har: http://www.reddit.com/r/haskell/comments/8n4s6/ghc_rises_to_top_of_pidigits_shootout_ranking/c09tbj6
16:22:28 <FunctorSal> aren't benchmarks kind-of a losing battle, assuming they're simple enough that you can hand-optimise the C?
16:22:45 <Asdfgh116> Hello
16:22:53 <Asdfgh116> Can anybody please help me
16:22:53 <FunctorSal> I find it credible that it would be faster if someone actually bothered to do that
16:23:06 <Zao> Asdfgh116: Actually asking a question helps.
16:23:10 <mreh> pumpkin: what's the difference between GHC and GHC #2
16:23:23 <pumpkin> mreh: just different versions
16:23:27 <Asdfgh116> its says patern match failure
16:23:28 <pumpkin> of the program
16:23:53 <Asdfgh116> i have this type L Char
16:23:54 <pejo> FunctorSal, people normally claim that you have more structure and know more things in higher level languages. And computers don't get sloppy or tired. We're still not faster than C on average though.
16:23:57 <vininim> FunctorSal: some aren't simple enough for hand optimization
16:24:22 <mreh> they have more eyes working on their compilers
16:26:33 <mreh> pumpkin: it still uses 5 times the memory though!
16:26:47 <pumpkin> seems reasonable
16:27:05 <pumpkin> we have an RTS
16:27:05 <pejo> mreh, wasn't that a bug that was fixed?
16:27:24 <pumpkin> the hundreds of megabytes of memory bug was :)
16:27:37 <mreh> pejo: yes, install more memory
16:28:11 <mreh> meh, what's 5mb of memory anyway
16:28:32 <pumpkin> mreh: look at the x64 benchmark and you'll see what bug he's talking about :P
16:30:27 <mreh> pumpkin: on pdigits?
16:30:39 <pumpkin> yeah
16:33:02 <mreh> by far the most readable of the contendors
16:35:30 <mreh> a real benchmark would include "hours taken off of your life from swearing at source code"
16:36:35 <pejo> mreh, that can easily be achieved in Haskell too.
16:37:12 <mreh> my main comment at my own haskell is along the lines of "holy shit it works"
16:37:41 <FunctorSal> unless the monodwarfism constriction kicks in.
16:37:42 <mreh> but i've yet to get serious about this
16:37:55 <Tobsan> I would probably rephrase that to "hours taken from swearing at type errors" ;-)
16:38:20 <mreh> but so many hours saved not debuggin
16:40:46 <jak> g <- runCommand "ninja.midi"
16:40:46 <jak> waitForProcess g
16:40:53 <jak> is the same as: runCommand "ninja.midi" >>= waitForProcess ; right?
16:41:23 <FunctorSal> yes
16:41:51 <monochrom> Most people who complain "not optimal performance" do not need optimal performance in their career. Who do they think are they speaking for?
16:42:42 <aavogt> because they don't have "optimal performance" if you know what I mean?
16:42:50 <monochrom> heh
16:44:04 <FunctorSal> monochrom: not sure I completely agree with extremistic "don't optimise"... it got us to apps being just as slow or slower than 10 years ago in spite of hundreds of times the resources...
16:44:28 <FunctorSal> at the risk of starting to sound like an old man ;)
16:44:40 <monochrom> Engineers know well that they don't deliver optimal performance. They deliver performance according to how much the client pays. If the client pays little, engineers know to deliver less performance. It's only common sense.
16:45:03 <p_l> monochrom: except that engineers are few and in-between, it seems
16:45:50 <FunctorSal> but they don't use 2000 tons of $resource if the problem can be solved with 2 ;)
16:46:04 <monochrom> I agree.
16:46:17 <SamB> monochrom: well, also, someone has to pay for components!
16:46:42 <FunctorSal> I totally agree that going for *optimal* performance is silly in most cases, but it should at least be sane...
16:46:52 <vininim> @src foldr1
16:46:52 <lambdabot> foldr1 _ [x]    = x
16:46:52 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
16:46:52 <lambdabot> foldr1 _ []     = undefined
16:47:33 <p_l> FunctorSal: When you start to think about boasting your capabilities on actually "optimizing" and "designing for perfomance" (meaning that the design isn't braind dead in terms of speed) on you job application, then something has gone wrong...
16:47:36 <SamB> yeah, if people say "non-optimal", they usually mean they believe it's not too hard to do substantially better ...
16:48:55 <vininim> @src foldl1
16:48:55 <lambdabot> foldl1 f (x:xs) = foldl f x xs
16:48:55 <lambdabot> foldl1 _ []     = undefined
16:48:56 <BMeph> THe main issue, is that "optimal" is always tempered by "with the given constraints." Many people are not skilled at balancing the constraints, usually because they cannot, or will not, accept that the constraints exist.
16:49:11 <vininim> wat
16:49:12 <FunctorSal> p_l: hmm not sure I'm following... you mean it's wrong that it needs to be mentioned?
16:49:40 <mmorrow> @remember BMeph THe main issue, is that "optimal" is always tempered by "with the given constraints." Many people are not skilled at balancing the constraints, usually because they cannot, or will not, accept that the constraints exist.
16:49:40 <lambdabot> Done.
16:49:43 <BMeph> (Full disclosure: I've been an engineering student for twenty-five years. I figure that in another five, I may even get a degree... ;)
16:49:55 <p_l> FunctorSal: I think it's wrong when it's so rare thing to actually *think* about performance (I mean in Web apps.)
16:50:02 <FunctorSal> I was understanding "optimal" in the simplest sense of "solve this program with least time and space use possible"
16:50:11 <FunctorSal> not thinking of development costs etc..
16:50:20 <Philonous> FunctorSal: I even believe that most of the increased speed in computing has less to do with faster processors than with better algorithms.
16:50:54 <FunctorSal> s/program/problem
16:51:39 <BMeph> FunctorSal: That's an easy one to solve: just tell the US Government to put the NSA's Signal Analysis computers at your command until the program runs - problem solved. ;p
16:52:18 <p_l> Philonous: Increased speed? Where? (except in game development and HPC) I see computers rivaling not so old Crays that feel slower in use than my 486@66MHz (with a whooping 16 megs of memory)
16:56:03 <mmorrow> olivierp: splices in [d||]'s would be absolutely fabulous. hopefully someone does this at some point.
16:57:13 <olivierp> mmorrow: yes, they'd make the thing usable without loss of hair, basically :) the docs are rather sparse as well...
17:12:27 <dibblego> why do I have Test.QuickCheck at ghci but it is missing if I try to create an executable with ghc?
17:15:32 <FunctorSal> are you using ghci-haskeline by chance?
17:15:50 <FunctorSal> it confused me by being still linked to an older ghc once :)
17:16:42 <dibblego> who?
17:16:57 <FunctorSal> you :)
17:17:24 <dibblego> I mean who is ghci-haskeline?
17:17:49 <FunctorSal> it's a ghci that uses haskeline
17:17:59 <FunctorSal> (I think ghc-6.10.3 does this by default now)
17:18:16 <dibblego> I'm using ghc 6.10.2
17:20:44 <dibblego> how can I determine if I am using ghci-haskeline?
17:20:50 <deech> Hi all, Is there anyway to embed an evaluation into Haddock documentation?
17:21:55 <dibblego> actually it's the linking where QuickCheck is missing
17:22:08 <dibblego> (.data+0x178): undefined reference to `QuickCheckzm1zi2zi0zi0_TestziQuickCheck_variant_closure'
17:25:56 <dibblego> I suppose CABAL would resolve this, but was hoping to avoid that
17:29:56 <Peaker> Cale: about removing Eq constraint from Num -- how do you pattern-match against numbers?  What's the type of   f 0 = 1 ; f n = n*f (n-1)   ?  Just (Eq a, Num a) => a -> a ?
17:30:59 <jmcarthur> i see nothing wrong with that
17:31:15 <FunctorSal> isn't that a pseudo-constructor match rather than an equality-guarded match?
17:31:32 <FunctorSal> (can you even match on arbitrary Nums?)
17:31:48 <jmcarthur> FunctorSal: a number literal is converted implicitly using fromIntegral
17:33:24 <jak> > foldl1 (+1) []
17:33:25 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
17:33:28 <jak> @src foldl
17:33:28 <lambdabot> foldl f z []     = z
17:33:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:33:35 <FunctorSal> jmcarthur: but you'd have to invert formIntegral unless I'm missing something
17:33:46 <jak> @src foldr
17:33:46 <lambdabot> foldr f z []     = z
17:33:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:33:49 <Cale> Peaker: Yeah, when you pattern match, you'll need Eq
17:34:39 <jmcarthur> :t fromIntegral
17:34:40 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:34:54 <jmcarthur> Num also requires Eq, right now
17:34:56 <Peaker> pattern-matches against numbers seem to be a special case in Haskell (as (==) . fromInteger  is applied)
17:35:14 <jak> > (+1) 3
17:35:15 <lambdabot>   4
17:35:18 <FunctorSal> "f @LITERAL = ..." <-> "f x | fromIntegral @LITERAL == x = ..." ?
17:35:19 <jak> > 3 (+1)
17:35:20 <lambdabot>   Add a type signature
17:35:25 <jmcarthur> :t fromInteger
17:35:26 <jak> > 3 (+1) ::Int
17:35:27 <lambdabot> forall a. (Num a) => Integer -> a
17:35:27 <lambdabot>   No instance for (GHC.Num.Num ((a -> a) -> GHC.Types.Int))
17:35:27 <lambdabot>    arising from t...
17:35:36 <jak> > (1+) 3
17:35:37 <lambdabot>   4
17:35:38 <jmcarthur> yeah, fromInteger, not fromIntegral, my bad
17:35:45 <jak> > 3 (1+)
17:35:46 <lambdabot>   Add a type signature
17:36:00 <jak> > (5-3*) 7
17:36:01 <lambdabot>   The operator `GHC.Num.*' [infixl 7] of a section
17:36:01 <lambdabot>      must have lower prece...
17:36:18 <jak> > ((5-3)*) 7
17:36:19 <lambdabot>   14
17:43:00 <Cale> dons: if you're around, you might find the discussion that gwern and I had comparing core between versions of the pidigits code somewhat interesting
17:43:28 <Cale> dons: It seems that there are some big differences between how 6.10.2 compiles list comprehensions to 6.10.3
17:44:59 <aavogt> :t ((?f .) .)
17:45:00 <lambdabot> forall b c a a1. (?f::b -> c) => (a1 -> a -> b) -> a1 -> a -> c
17:46:24 <Cale> :t fmap (fmap f)
17:46:25 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
17:46:30 <Cale> er
17:46:32 <Cale> :t fmap (fmap ?f)
17:46:33 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (?f::a -> b, Functor f, Functor f1) => f1 (f a) -> f1 (f b)
17:46:53 <Cale> That's how I like to think of it.
17:47:11 <Cale> (f .) is the same as fmap f for the (e ->) functor.
17:47:20 <dibblego> how can I get cabal to build an executable with the run target?
17:47:24 <dibblego> oops build target
17:50:14 <aavogt> @pl \x -> (+ map return x)
17:50:15 <lambdabot> (+) . map return
17:50:32 <aavogt> @pl \x -> (map return x +)
17:50:33 <lambdabot> (+) . map return
17:50:51 <aavogt> @pl \x y -> (map return x + y)
17:50:52 <lambdabot> (+) . map return
17:50:59 <aavogt> @pl \x y -> (y+map return x)
17:51:00 <lambdabot> (+) . map return
17:51:22 <aavogt> shouldn't there be a flip in there somewhere?
17:52:00 <aavogt> :t (+) . map return
17:52:01 <lambdabot> forall a (m :: * -> *). (Num [m a], Monad m) => [a] -> [m a] -> [m a]
17:52:08 <aavogt> :t flip (+) . map return
17:52:10 <lambdabot> forall a (m :: * -> *). (Num [m a], Monad m) => [a] -> [m a] -> [m a]
17:52:19 <dibblego> @pl \x y -> ((+) y (map return x))
17:52:20 <lambdabot> (+) . map return
17:52:41 <dibblego> @pl \x y -> (+) y (map return x)
17:52:42 <lambdabot> (+) . map return
17:52:55 <aavogt> going by the types, the flip does nothing
17:53:06 <Gracenotes> (+) is commutative
17:53:31 <Gracenotes> for Int and Integer, at least. Float+Double might have some corner cases
17:53:50 <aavogt> :t flip (.) (+) (map return)
17:53:51 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a1]'
17:53:52 <lambdabot>     In the third argument of `flip', namely `(map return)'
17:53:52 <lambdabot>     In the expression: flip (.) (+) (map return)
17:53:55 <Gracenotes> maybe pl knows this?
17:54:17 <aavogt> @pl flip . flip . flip
17:54:18 <lambdabot> flip
17:54:43 <aavogt> @pl flip (+)
17:54:43 <lambdabot> (+)
17:55:06 <aavogt> @pl flip (\x y -> (y,x)))
17:55:07 <lambdabot> (line 1, column 21):
17:55:07 <lambdabot> unexpected ")"
17:55:07 <lambdabot> expecting variable, "(", operator or end of input
17:55:11 <aavogt> @pl flip (\x y -> (y,x))
17:55:12 <lambdabot> (,)
17:56:10 <aavogt> @pl flip ((+) . map return)
17:56:11 <lambdabot> (. map return) . (+)
17:56:15 <Gracenotes> yes, it seems pl is allowed to flip those
17:56:20 <Gracenotes> commutativeOps = ["*", "+", "==", "/=", "max", "min"]
17:56:26 <Gracenotes> from the source code. it considers these commutative
17:57:09 <Gracenotes> x+y == y+x
17:57:17 <aavogt> yeah
17:57:40 <vininim_>  openFile: resource exhausted (Too many open files)
17:57:40 <roconnor> @type infinity
17:57:41 <lambdabot> Natural
17:57:41 <ziman> @pl flip (+)
17:57:42 <lambdabot> (+)
17:57:43 <vininim_> baaawwww
17:57:48 <roconnor> > 1 + infinity > 1
17:57:49 <lambdabot>   True
17:57:55 <roconnor> > infinity + 1> 1
17:57:56 <lambdabot>   True
17:58:35 <Gracenotes> Natural uses lazy comparisons and such
17:58:36 <jbauman> > 1 + infinity > infinity
17:58:41 <lambdabot>   mueval-core: Prelude.read: no parse
17:58:41 <lambdabot>  mueval: ExitFailure 1
17:59:00 <aavogt> @src infinity
17:59:00 <lambdabot> Source not found. You speak an infinite deal of nothing
17:59:00 <vininim_> why mapM readFile listOfFiles doesn't garbage collect file handles?
17:59:09 <Gracenotes> hm
17:59:09 <aavogt> mapM_
17:59:16 <Gracenotes> > genericLength [1..] > (5 :: Natural)
17:59:18 <lambdabot>   True
17:59:51 <aavogt> might be better, but I'd expect the handles to be thrown away in either case
18:00:12 <aavogt> plus, mapM_ readfile is quite pointless :)
18:00:44 <Gracenotes> vininim_: it should GC the file handles once they're out of scope
18:00:53 <Gracenotes> like most other languages
18:00:58 <Gracenotes> that GC
18:01:15 <Gracenotes> aavogt: oooooh. I see the issue. readFile is lazy.
18:02:08 <Gracenotes> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v:readFile
18:02:57 <aavogt> @type foldl' (\a x -> ?f x =<< a)
18:02:58 <lambdabot> forall b (m :: * -> *) b1. (?f::b -> b1 -> m b1, Monad m) => m b1 -> [b] -> m b1
18:03:23 <Asdfgh11> hello , how can i define a data type which can accept Char
18:03:34 <aavogt> @type foldl' (>>=)
18:03:36 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
18:04:06 <Gracenotes> too bad there isn't a non-lazy hGetContents
18:04:10 <Asdfgh11> i have done that
18:04:56 <Asdfgh11> example data K = And Int Int | Char .  i need the Char to be without a name
18:05:16 <aavogt> Gracenotes: so use a stricter sequence function?
18:05:21 <Berengal> Gracenotes: hGetContents >>= return . seq <$> last <*> id
18:05:42 <Gracenotes> Berengal: that don't look like a function to me
18:05:51 <Gracenotes> >_>
18:06:06 <Berengal> Gracenotes: foo handle = hGetContents handle >>= return . seq <$> last <*> id
18:06:13 <Asdfgh11> what is that
18:06:29 <Gracenotes> Asdfgh11: data types must have a constructor
18:06:42 <Asdfgh11> yh b but i have to do it
18:06:49 <aavogt> @type fmap (liftA2 seq last id) . hGetContents
18:06:51 <lambdabot> Not in scope: `hGetContents'
18:06:59 <aavogt> @type fmap (liftA2 seq last id) . const getContents
18:07:00 <Gracenotes> but you can have multiple constructors. So: data Foo = Bar Int Int | Baz Char
18:07:01 <lambdabot> forall a. a -> IO [Char]
18:07:01 <Asdfgh11> exmaple and(and 'a' 'b')
18:07:19 <Asdfgh11> and i will put the input as ture wro false
18:07:34 <roconnor> @bab nl en geweigerd
18:07:34 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
18:07:40 <Gracenotes> eek.
18:08:38 <Asdfgh11> i can not use the a constructer for the character
18:08:46 <Berengal> Asdfgh11: All values need a constructor, no exceptions
18:09:08 <Asdfgh11> what should i do ?
18:09:56 <Berengal> Give the constructor a name
18:10:15 <Asdfgh11>  (And( And 'a' 'b'))
18:10:47 <Berengal> Your And constructor takes two ints only...
18:11:13 <Asdfgh11> YH
18:11:46 <Asdfgh11> its going to be replace by a number given by the user
18:11:46 <Berengal> Because that's what you defined it to do
18:12:22 <Asdfgh11> i should replace the chars with ints
18:12:37 <Asdfgh11> thnak u for heloing
18:12:50 <Berengal> What exactly are you trying to do?
18:14:25 <Asdfgh11> Add( 'a' 'b') while a=2 and b=3
18:15:10 <Berengal> I assume you meant 'where' there...
18:15:36 <Asdfgh11> what does where do
18:15:49 <Berengal> > x + y where x = 2; y = 3
18:15:50 <lambdabot>   <no location info>: parse error on input `where'
18:16:13 <Berengal> lambdabot no do where? :(
18:16:27 <FunctorSal> oh dear. I just jumped to the beginning of the "Do we really need FPLs? We can do everything with the imperative languages. " comp.lang.functional thread we had earlier
18:16:41 <Berengal> Anyway, where is like let, except it comes after the expressions
18:17:21 <Cale> I find it interesting that the naive-looking Haskell pidigits on the shootout is beating the brutally unreadable C version.
18:17:22 <Berengal> 'while' generally doesn't make much sense in haskell
18:17:23 <jeffwheeler> I went to the UIL state meet (the primary academic competition in Texas), and there was a kid named Tsz Ling Kong from I guess the city of Haskell, Texas (or maybe Haskell high school?) in the Mathematics competition.
18:17:44 <Asdfgh11> evaluate (Add(Add('a' 'b') ('c' 'd')) 1 2 3 4
18:18:13 <Asdfgh11> 1 2 3 4 should replace the chars
18:18:43 <Berengal> Asdfgh11: That needs to look like 'evaluate (Add (Add 'a' 'b') (Add 'b' 'c'))) [1,2,3,4]'
18:18:44 <Cale> FunctorSal: That sounds like a waste of time thread.
18:19:15 <Berengal> Or 'evaluate (Add (Add 'a' 'b') (Add 'b' 'c'))) [('a',1),('b',2),('c',3),('d',4)]'
18:19:16 <FunctorSal> yes. must... resist...
18:19:49 <Asdfgh11> yes
18:19:54 <Asdfgh11> sry my mistake
18:20:12 <Asdfgh11> what shoudl i do
18:20:19 <Berengal> Asdfgh11: I assume the datatype you're looking for is something like 'data Expression = Add Expr Expr | Sub Expr Expr | Var Char | Val Int |...'
18:20:36 <Berengal> s/Expr/Expression
18:21:11 <Berengal> Then you could have have a function 'evaluate :: Expression -> [(Char, Int)] -> Int'
18:21:49 <Asdfgh11> var Char how will it work
18:22:19 <Berengal> And pattern match on the expression constructors, like 'evaluate (Add a b) env = evaluate a env + evaluate b env; evaluate (Var c) env = let Just val = lookup c env in val; ...'
18:22:44 <crutex> grill $ burgers :: Delicious
18:22:47 <Berengal> env is the "environment", or the bindings
18:23:44 <crutex> grill $ burgers :: Delicious Food
18:23:56 <Asdfgh11> if i created a var c i have to write in the expression var c
18:24:09 <Berengal> Asdfgh11: Yes
18:24:36 <Asdfgh11> but i cant , that problem
18:24:47 <crutex> guys is that proper syntax?
18:24:50 <Berengal> So you'd have 'Add (Var 'a') (Var 'b')'
18:25:17 <Berengal> Asdfgh11: In that case you need to write a parser or something
18:25:26 <Asdfgh11> i should have : Add ('a' 'b') [1 ,2]
18:25:43 <crutex> Asdfgh11 are you sure that's proper syntax?
18:25:48 <Asdfgh11> i should have : Add (var ' a' var 'b') [1
18:25:51 <Asdfgh11> yes i am
18:25:53 <crutex> ...
18:25:55 <crutex> i think it's not
18:25:57 <Berengal> Asdfgh11: You could do that if you wanted, but then you'd only be able to add variables
18:26:37 <Asdfgh11> what do u mean
18:26:41 <crutex> that's what i meant
18:26:55 <Berengal> Asdfgh11: Actually, you can't have the parenthesis there...
18:27:46 <crutex> it's elementary how could you f that up
18:27:53 <Asdfgh11> so it cant be done
18:28:08 <tompledger> Re Add 'a' 'b': Could you use a class to span both Char and the datatype with Add/Sub/etc?
18:28:20 <Berengal> Asdfgh11: ('a' 'b') means "apply the function 'a' to the value 'b'), which can't be done since 'a' isn't a function
18:28:23 <crutex> tompledger are you sure that's proper syntax?
18:28:45 <crutex> 99% of errors are syntax aerors.
18:29:07 <Asdfgh11> what do u mean by spanning
18:29:24 <crutex> <span> is like a div but with inline display by default
18:29:28 <tompledger> crutex: if Add is a data constructor taking 2 args, then yes
18:29:29 <crutex> it's just for partitioning content
18:29:47 <Berengal> tompledger: You could have a class Expr e where evaluate :: [...]
18:29:55 <crutex> Berengal are you sure that's proper syntax?
18:30:10 <Berengal> crutex: I'm sure it's not.
18:30:15 <crutex> that's what i thought
18:30:21 <tompledger> The [...] is metasyntax  ;-)
18:30:29 <crutex> i knew it looked strange
18:30:38 <Berengal> tompledger is right
18:30:47 <crutex> i'm new to this
18:30:57 <crutex> forgive if i ask too many questions
18:31:01 <Asdfgh11> can you tell me how to write a parser
18:31:14 <crutex> ehh maybe in a few years once i learn
18:31:23 <crutex> what are you trying to parse
18:31:26 <crutex> haskell grammar?
18:31:43 <Asdfgh11> i have expression wich i want to be accepted as char also
18:31:59 <crutex> hmm
18:32:15 <crutex> well what do you mean by "tell you how to write a parser"
18:32:45 <Asdfgh11> i want data Exp to accept chars
18:32:57 <Berengal> Asdfgh11: A parser takes a string as input. You can't use it directly in source, unless you put a string literal in there...
18:33:32 <Asdfgh11> berengal do understand my problem
18:33:47 <Berengal> Asdfgh11: Not completely, I'm afraid...
18:33:57 <gwern> 'Possibly it should use instead "validating constructors" that return a Maybe type. But note that some minutes have 61 seconds, and given that TimeOfDay might be local civil time (UTC + time zone offset), it can be any minute. So these must be allowed:'
18:34:02 <gwern> arrghhh
18:34:03 <crutex> gwern are you sure that's proper syntax?
18:34:21 * gwern hates units. units are insane! a minute has 60 seconds, end of discussion
18:34:30 <crutex> well technically not
18:34:30 <skorpan> what's wrong with ()
18:34:35 <crutex> leap seconds
18:34:50 <crutex> !google leap seconds
18:34:55 <Gracenotes> go!
18:35:01 <gwern> crutex: not listening!
18:35:08 <crutex> eh ?
18:35:10 <Gracenotes> hrm. I might have to use UUIDs to implement "listeners" here. Otherwise I can't remove listeners -- because functions are not Eq
18:35:20 <roconnor> bot: A leap second is a positive or negative one-second adjustment to the Coordinated Universal Time (UTC) time scale that keeps it close to mean solar time.
18:35:21 <Gracenotes> at least, not in a sane way
18:35:49 <Gracenotes> although there must be a better name than listeners. perhaps "hooks"
18:35:54 <roconnor> Gracenotes: why use UUIDs
18:36:04 <roconnor> just have the listener return the delistening function
18:36:12 <Berengal> Gracenotes: Put them in a structure, give them a name. Why UUID?
18:36:14 <Berengal> Or use slots...
18:36:19 <roconnor> the listener insertion function return the ...
18:36:24 <roconnor> you know what I mean
18:36:32 <Gracenotes> Berengal: well. a name would be an ID in this case :)
18:36:44 <Berengal> roconnor's idea is also sound
18:37:13 <Gracenotes> roconnor: well. a delistening function would have to identify the listener somehow
18:37:22 <Gracenotes> UUIDs aren't a bad way to do this, eh?
18:38:03 <roconnor> Gracenotes: sure, but that doesn't need a universally unique id.  Just a locally unique one.
18:38:24 <Gracenotes> roconnor: well. yes. perhaps I went too crazy with acronyms
18:38:26 <roconnor> there is probably a clever way that needs no ids at all
18:38:31 <Gracenotes> just some sort of counter
18:38:37 <crutex> are you sure that's proper syntax?
18:38:39 <Berengal> How are these listeners stored?
18:39:22 <Gracenotes> Berengal: data Listener s = forall a. Listener (MyEvent -> MyMonad s a)
18:39:22 <vininim_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5242#a5242
18:39:36 <crutex> oh Gracenotes you're such a dullard
18:39:46 <Gracenotes> I could easily add an Integer there
18:39:54 <roconnor> some sort of IORef ought to work as ID.
18:39:54 <Gracenotes> crutex dear, you know I can't help it!
18:39:56 <vininim_> previous paste gets a sleeping process with 0 seconds runtime
18:40:04 <roconnor> or MVar
18:40:07 <roconnor> or whatever
18:40:13 <Berengal> Gracenotes: I meant how are they stored after they're hooked in?
18:40:16 <Gracenotes> roconnor: and storing it in a [Listener s]
18:40:21 <crutex> how would you represent categorical hierarchy in a rdbms
18:40:33 <Gracenotes> er, @Berengal
18:41:09 <Gracenotes> adding an Integer would provide a way to use delete, which requires Eq, or even better -- a Set -- which requires Ord
18:41:33 <crutex> Gracenotes are you by chance a woman
18:41:46 <Gracenotes> and when an Event is received the idea is to cycle through 'em all
18:41:59 <crutex> that is not meant to sound passive aggressive
18:42:06 <crutex> pure inquery
18:42:19 <Gracenotes> crutex: isn't all gender by chance?
18:42:35 <crutex> at some level everything is by chance
18:42:45 <crutex> are you by chance /a woman/ though
18:42:54 <Gracenotes> no.
18:42:55 <Berengal> Gracenotes: Okay, go ahead, an id couldn't hurt
18:42:57 <vininim_> how dare you talk about chance on a pure fuctional language channel?
18:43:22 <crutex> Gracenotes are you denying that you are a woman because you are afraid of #haskell thinking less of you
18:43:24 <Gracenotes> vininim_: in a nondeterminism monad
18:43:26 * Berengal still wonders if there could be a functional answer
18:43:30 <crutex> you can answer me in PM if you want
18:43:44 <Gracenotes> I don't think this is the case
18:43:54 <crutex> ok
18:44:40 <crutex> sorry didn't mean for that to be awkward
18:44:57 <crutex> sooo
18:45:02 <crutex> how would you represent categorical hierarchy in a rdbms
18:45:34 <Gracenotes> Berengal: it all is very imperative, an IRC bot with a lot of functionality. I think FRP might provide a way to do it nicely, but I don't understand it very well, and I think most people  don't
18:46:35 <Cale> crutex: I don't understand your question? Is it in any way related to Haskell?
18:46:43 <crutex> cale not necessarily
18:46:45 <crutex> does it have to be
18:46:51 <crutex> to talk here
18:46:53 <Cale> crutex: Categorical hierarchy?
18:47:09 <crutex> eh yes like a hierarchy of categories is what i meant, not sure if my english was correct
18:47:30 <Cale> Well, in this channel when people use the word 'category', they tend to mean something other than the usual English meaning.
18:47:30 <Berengal> Gracenotes: If dropping into IO isn't too much a bother, [IORef (Maybe Listener)] ?
18:47:40 <Cale> (it has a mathematical definition)
18:47:44 <crutex> i see
18:48:11 <crutex> i meant a category as ... a category that items could belong to, and if you belong to a category you belong to all the parents of that category
18:48:21 <Gracenotes> Berengal: well.. the monad I'm using is a MonadIO.
18:48:25 <Cale> yeah
18:48:26 <Cale> okay
18:48:33 <Gracenotes> Berengal: what's the Maybe for?
18:48:57 <Gracenotes> hm.. removing references to Listeners?
18:49:03 <crutex> Cale surely a parent child column for each would not be an efficient way, at least the querying would be inefficient?
18:49:22 <Cale> Well, relational databases are supposed to make joins of that kind efficient.
18:50:09 <Cale> (If they didn't there wouldn't be much point in calling them relational)
18:50:13 <olivierp> is there anything that would prevent me from exporting a type constructor from a module? when I list the constructors in the where () clause of the module they're reported not to be in scope. The two constructors are for GADTs, maybe that's related? i can access them from the outside when exporting everything (no where clause) though.
18:50:35 <crutex> Cale i'm having a hard time visualizing what the table(s) would look like
18:50:38 <Berengal> Gracenotes: Right, so addListener :: Listener -> ListenerList -> IO (ListenerList, IO ()); addListener listener list = do ref <- newIORef (Just listener); let derefListener = writeIORef ref Nothing; return (ref:list, derefListener)
18:51:00 <crutex> i'm kind of nub @ it
18:51:29 <Gracenotes> hm
18:51:48 <p_l> crutex: It's quite easy to model a tree using tables. Define fields: ID and parent, and you can have it done.
18:51:58 <crutex> right
18:52:05 <crutex> but how would the queries look :X
18:52:36 <crutex> if the items are linked to only 1 category
18:53:06 <crutex> depending on the level of inheritence that would be a low of work for 1 query wouldn't it
18:53:10 <crutex> *lot
18:53:11 <hatds> constructors are exported as 'subordinate' names, could that be the problem?
18:53:18 <p_l> crutex: for finding all members of given category... SELECT * FROM table WHERE parent = (SELECT id FROM table WHERE name='name');
18:53:45 <hatds> i.e. you aren't accidentally exporting just the typename
18:53:59 <p_l> crutex: that however requires a serious RDBMS - I heard MySQL 5.x still fails performance hard with that kind of query
18:54:14 <crutex> p_l what if it is say 4 or 5 levels deep
18:54:29 <Cale> crutex: So you have a table of categories along with their parent, and then you have a table of items along with the smallest category in which they belong.
18:54:38 <crutex> yes cale
18:55:31 <p_l> crutex: that was if you know the node whose leafs you wanted, assuming your category was shaped into a tree
18:56:34 <Cale> Hmm, it seems that plain SQL isn't really good for taking transitive closures.
18:57:00 <Cale> I suppose you could just maintain another table with the transitive closure.
18:57:12 <Cale> But that's a bit ugly.
18:59:06 <p_l> crutex: you can maintain all links in one table, and various kinds of objects in other tables
18:59:53 <crutex> http://i39.tinypic.com/sxmbro.jpg
18:59:56 <crutex> here's a pic
19:01:11 <Cale> crutex: Right, you need a table which has two columns, parentID and childID, and which expresses not just the direct relationships between categories, but all of them. That is, it'll have an entry with parentID = 2 and childID = 7
19:01:30 <crutex> hehe, seriously
19:01:39 <crutex> all possible paths? O_O
19:01:42 <vininim_> ok, just completly ignore me
19:01:43 <Cale> yeah
19:01:48 <crutex> ok
19:01:53 <crutex> wasn't sure if there was a pretty way of doing this
19:01:53 <vininim_> my example expected the list from standard input heh
19:02:02 <hatds> how does the time/allocation report determine the number of entries of a cost center?  If you pass a function as a parameter and call it a zillion times at different arguments you won't get more than 1 'entry' ?
19:02:04 <vininim_> so of course it was sleeping
19:02:25 <Cale> crutex: There are various nonstandard ways of constructing the transitive closure automatically, but plain standard SQL doesn't have one.
19:03:04 <crutex> how would it be done then
19:03:28 <Cale> It can be constructed somewhat efficiently in stages, where you find all the new relationships you can at each stage, and insert them into the table until there's nothing more to add.
19:04:15 <crutex> it seems like this would be a fairly common problem
19:04:16 <crutex> is it?
19:04:47 <crutex> is mysql/postgre even a good solution for it
19:07:32 <grncdr> crutex: I didn't get your whole question but...
19:07:51 <grncdr> representing trees in a database is a fairly common problem/practice
19:08:09 <grncdr> and a relation database is in fact a terribly inelegant way to store a tree
19:08:14 <grncdr> *relational
19:08:59 <Cale> It's too bad that there isn't a good way to express the transitive closure in SQL.
19:09:23 <Cale> But if you have another language handy which you're manipulating your database with, it's fairly easy to construct.
19:09:26 <tompledger> Some SQL engines have it as an extension, don't they?
19:09:33 <Cale> tompledger: It seems so.
19:09:34 <crutex> cale what do you mean
19:09:38 <crutex> this is with postgre and php
19:14:34 <vininim_> uh.. I wonder why hmatrix doesn't export joinVert and joinHoriz
19:15:07 <tompledger> #type joinVert
19:15:19 <duaneb> hi people
19:15:24 <duaneb> I'm trying to have an instance of Read
19:15:29 <duaneb> and I'm not sure how to go about it
19:15:34 <Cale> crutex: Create a new table and start by copying into it the direct tree edges obtained from the other table. Then, insert into the new table (x,x) for each category ID (making it reflexively closed), and then repeatedly insert into it (x,z) where (x,y) and (y,z) are already in it, which is the same as inserting into it an inner join of it with itself where the appropriate columns match
19:15:38 <duaneb> I guess
19:15:40 <vininim_> joinVert :: Element t => [Matrix t] -> Matrix t
19:15:42 <duaneb> there's readsPrec
19:15:47 <duaneb> but It's not clear how that works
19:16:00 <olivierp> hatds: sorry, didn't notice your reply. both the data types and the constructors are exported, and they have different names
19:16:41 <hatds> olivierp: maybe hpaste it if you still have problems
19:16:45 <crutex> ok thank you a lot for your awesome input cale
19:17:12 <olivierp> hatds: hmm, it seems I only need to export the data types, and the constructors are exported automatically
19:17:46 <olivierp> hatds: it works fine if i just remove the constructors from the module where clause
19:17:53 <hatds> olivierp: that should only happen with Typename(..) syntax
19:18:09 <olivierp> hatds: do you know what the rules for this are?
19:18:18 <tompledger> vininim_: thanks, I haven't got the hang of lambdabot yet.  Perhaps joinVert is only for use by trusted callers within its module, because its return type doesn't cover the "Oi! Incompatible height/width" situation?
19:18:23 <duaneb> ahh, nm
19:18:25 <duaneb> I got it
19:18:27 <hatds> olivierp: http://www.haskell.org/onlinereport/modules.html
19:18:40 <hatds> probably the one place where the gory details of the haskell report are often needed
19:18:41 <olivierp> hatds: no i didn't use typename(..), but they're GADTs
19:18:47 <olivierp> thanks
19:18:54 <vininim_> tompledger: it does
19:19:05 <vininim_> joinVert ms = case common cols ms of Nothing -> error "joinVert on matrices with different number of columns" Just c  -> reshape c $ join (map flatten ms)
19:19:26 <tompledger> Oh, OK
19:19:56 <BMeph> Sounds like a snap to do in Q (the DB stuff). :)
19:20:03 <Cale> So it'd be like (untested, and I only infrequently use SQL),  INSERT INTO cats_tc SELECT tc1.parentID, tc2.childID FROM cats_tc AS tc1 INNER JOIN cats_tc AS tc2 ON tc1.childID=tc2.parentID
19:20:09 <vininim_> @type common
19:20:10 <lambdabot> Not in scope: `common'
19:20:25 <Cale> crutex: ^^ have a look at that and see if it works/makes sense :)
19:20:42 <crutex> yes cale i will have to digest it later :}
19:20:44 <olivierp> hatds: hmm ok got it. I think i don't actually need the constructors exported, they're only used in a Template Haskell splice that's defined in the same module (but used outside)
19:21:10 <duaneb> ahh, never mind
19:21:11 <duaneb> got it
19:21:20 <olivierp> hatds: i guess TH isn't quite the same as copy/pasting the code at the splice location
19:25:26 <kniu> :t (.) (.)
19:25:27 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
19:25:48 <crutex> Thanks again!
19:26:31 <vininim_> > foldl1 f [x y z w]
19:26:32 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
19:26:39 <Cale> It seems really silly that SQL, being based on relational algebra, would not include something such basic things as the transitive or reflexive closure of a relation...
19:26:45 <vininim_> > foldl1 f [x y z]
19:26:46 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr
19:26:57 <Cale> -something
19:27:04 <vininim_> > foldl1 f [x, y, z]
19:27:05 <lambdabot>   f (f x y) z
19:27:16 <vininim_> heh
19:31:22 <vininim_> tompledger: just in case you are interested <|> is joinH and <-> is joinV in hmatrix
19:32:21 <tompledger> A rows by any other name...
19:32:32 <duaneb> anyone know parsec?
19:32:38 <duaneb> I have this thing: liftM (Number . (read::String->Int)) (optional (oneOf "-+") >> many1 digit)
19:32:45 <duaneb> where data Number = Number Int
19:32:55 <kniu> so I'm trying to install reactive-glut.
19:33:04 <duaneb> and yet, (read::String->Number) "-89" leads to Number -89
19:33:08 <duaneb> err, Number 89
19:33:11 <kniu> one of the dependencies depends on two different versions of quickcheck.
19:33:21 <kniu> indirectly.
19:33:48 <Cale> duaneb: you appear to be discarding the sign
19:33:54 <kniu> how do I fix that?
19:34:14 <Cale> duaneb: remember that >> discards the result of its left parameter
19:34:15 <duaneb> Cale: I do indeed
19:34:32 <duaneb> Cale: yea, but doesn't '>>=' pass the result to the next function?
19:34:37 <Cale> kniu: Just install the deps one by one.
19:34:38 <duaneb> I'm not sure how to manage this....
19:34:52 <kniu> huh
19:34:58 <Cale> kniu: But it can be tricky, since the latest version of everything doesn't all work together.
19:35:10 <Cale> kniu: The dependencies for reactive are a mess right now.
19:35:11 <kniu> well then.
19:36:38 <Cale> duaneb: Oh, the other problem is that optional unconditionally discards the result of the parser you apply it to
19:36:47 <duaneb> great.
19:36:54 <Cale> You can use optionMaybe
19:37:12 * duaneb thinks this is too complicated
19:37:47 <duaneb> whatever, I'll just do it :P
19:37:48 <Gracenotes> hm. Is there an MVar with a timer?
19:37:55 <Cale> do sign <- optionMaybe (oneOf '+-'); rest <- many1 digit; return (Number (read (fromMaybe '+' sign : rest)))
19:38:02 <Gracenotes> well. "timeout", that is
19:38:08 <Cale> duaneb: ^^ how about that?
19:38:21 <duaneb> that's what I was writing
19:38:23 <duaneb> so
19:38:25 <duaneb> I agree!
19:38:31 <Gracenotes> ï¼ˆã€€â‰–â€¿â‰–ï¼‰
19:38:41 <duaneb> Gracenotes++
19:38:51 <Gracenotes> okay, so would it be possible to implement an MVar lookup with a timeout?
19:39:08 * Gracenotes doesn't see one in the docs
19:39:14 <Cale> Gracenotes: Like, try to take the MVar, and if it's empty, block for so long before giving up and returning Nothing?
19:39:24 <Gracenotes> yes
19:39:35 <Cale> You can do that with an extra thread...
19:39:38 <Gracenotes> it is somewhat important here
19:40:35 <Gracenotes> Cale: I think I may have threads being created left and right here :) At least Haskell threads a "green" so to say
19:40:37 <Gracenotes> are
19:40:52 <Cale> Hmm, there's also tryTakeMVar...
19:41:24 <Gracenotes> well. that would amount to crude sleeping blocks
19:42:02 <duaneb> Cale: works great
19:42:12 <SamB> yes, but you could use tryTakeMVar to avoid spawning the thread when you can just take the MVar right off ...
19:42:40 <Berengal> Isn't there a timeout :: Int -> IO a -> IO a somewhere?
19:43:13 <Gracenotes> SamB: this is very unlikely in my case
19:43:23 <Cale> yeah...
19:43:41 <Cale> System.Timeout might do it
19:43:48 <Cale> timeout :: Int -> IO a -> IO (Maybe a)
19:43:55 <SamB> so, why do you want to do that anyway ?
19:44:26 <Cale> The Int is in microseconds...
19:45:07 <Berengal> Cale: Looks like picoseconds or something to me...
19:45:23 <Cale> Multiply by 10^6...
19:45:39 <Gracenotes> SamB: an empty MVar is created, a listener is added to a list which only puts in the MVar if a particular event is received, and once the MVar is filled the idea is to remove the listener and yield the event
19:45:44 <Berengal> Ah, yes, micro..-
19:46:19 <Cale> Gracenotes: So, you should be able to  timeout (10^6) (takeMVar v)
19:47:13 <Gracenotes> Cale: hm, ingenious! Functional programming for the win.
19:47:19 <Gracenotes> except, it is the same as your previous idea
19:47:24 <Gracenotes> it creates a new "kill thread"
19:47:28 <Gracenotes> but at least it is in the stdlib
19:47:28 <Cale> yeah
19:47:37 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-Timeout.html#timeout
19:47:48 <Gracenotes> right
19:47:50 <hackagebot> MemoTrie 0.4.5
19:47:52 <Cale> The implementation is careful, but straightforward :)
19:48:36 <Cale> The behaviour for negative parameters seems out of place though.
19:48:40 <Gracenotes> it does seem limited though.
19:48:50 <Gracenotes> particularly with IO. As noted in the docs.
19:49:46 <Cale> It does the best that's reasonable for it to do.
19:49:55 <Gracenotes> overall, concurrency needs more fine-tuning, more concurrency primitives and concurrent data structures. but this'll do
19:50:00 <Gracenotes> :)
19:50:12 <dons> more concurrency primitives?
19:50:12 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
19:50:12 <Cale> C code doesn't have a notion of async exceptions which could be relied on.
19:50:23 <dons> more concurrent data structures? (mutable ones?)
19:50:26 <Cale> So FFI calls are always going to be strange...
19:50:43 <Cale> Actually, I think the comment in the docs is fairly positive about how well it works.
19:50:48 <dons> or you mean things like Chan et al? (concurrent queues)
19:51:41 <Gracenotes> by primitives: explicit locks, conditions, etc. Even if they are just wrappers around MVar, a clean interface is good.
19:52:01 <Cale> http://picturesforsadchildren.com/index.php?comicID=266
19:52:05 <dons> what kinds of locks and conditions are missing?
19:52:06 <Gracenotes> STM and TVar takes care of compare-and-swap-like operations nicely, which does put Haskell ahead of many things
19:52:15 <Cale> Gracenotes: locks are worse than MVar...
19:52:27 <Cale> Gracenotes: you can just use MVar ()
19:52:36 <Gracenotes> Cale: yes. But, as I said, a wrapper.
19:52:55 <Cale> Does something that simple really need a wrapper?
19:53:00 <dons> MVars and TVars will be the primitive thread-aware shared memory abstraction primitives for the next few years.
19:53:29 <Cale> Concurrency is important, but it's much less important than pure parallelism, I think.
19:53:30 <Gracenotes> Conditions, as in waiting and signalling.
19:53:31 <dons> there's fairly regular releases on hackage of things on top, though i'm hard pressed to find uses for some of them
19:53:41 <Gracenotes> Chan needs more control over blocking and whatnot.
19:53:52 <Cale> Gracenotes: There's an implementation of concurrent ML if you'd like :)
19:53:54 <jmcarthur> Cale: and much harder than pure parallelism, too
19:54:09 <Gracenotes> there aren't many ways to ensure atomic operations other than using an MVar ()
19:54:10 <jmcarthur> actually
19:54:14 <Berengal> It'd be nice to have a clean message-passing interface
19:54:17 <Gracenotes> for instance, you could run into race conditions with Chan functions
19:54:23 <jmcarthur> maybe the other way around, with STM :)
19:54:24 <dons> Berengal: tried the actors library?
19:54:31 <dons> pretty much identical syntactically to erlang.
19:54:42 <Berengal> dons: No I haven't. Thanks for the tip
19:54:44 <dons> Gracenotes: there's a bounded Chan on hackage.
19:55:02 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/BoundedChan
19:55:05 <dons> by a colleague of mine
19:55:14 <dons> actors, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/actor
19:55:43 <Gracenotes> still, no reason that regular ol' Chan shouldn't be able to support more fine-tuned blocking options.
19:55:44 <dons> actors compared w/ erlang, http://gist.github.com/111482
19:55:53 <dons> Gracenotes: what do you want to be able to do?
19:57:13 <Cale> dons: Does that come with an Erlang version?
19:58:01 <Gracenotes> essentially, act as a queue where you can poll, retrieve an element on top as a (Maybe a), etc.
19:58:07 <dons> yeah, on matthew's blog. http://codebetter.com/blogs/matthew.podwysocki/archive/2009/05/12/axum-introduction-and-ping-pong-example.aspx
19:58:29 <dons> Gracenotes: sounds like a different library. maybe upload it?
19:58:39 <Gracenotes> I think any linked blocking queue should be able to handle it
19:59:18 <Gracenotes> also... there's not much support for timeout operations. System.Timeout is neat, although I'm not sure it's the best general-purpose solution :/
19:59:27 <dons> you want to poll, rather than just sleeping until a value arrives (i.e. you want access to the top MVar's tryTake?
20:00:15 <Gracenotes> dons: yeah. I'm not sure why there isn't more MVar functionality exposed >_>
20:00:26 <dons> no one has needed it?
20:00:32 <pumpkin> Gracenotes: write it and expose it!
20:00:40 <pumpkin> it can be called Gracenotes' exposÃ©
20:00:43 <dons> or: it is trivial to roll your own, so people write that, and upload it.
20:00:48 <Gracenotes> pumpkin: but that would be indecent!
20:00:59 <dons> yay MVars. the great shared memory sync primitive
20:01:09 <Cale> Gracenotes: It's fairly trivial to write a function which races a number of IO actions concurrently and takes the result of the first one to complete as well.
20:01:16 <Gracenotes> at least I'm pretty happy with the MVar functionality.
20:01:42 * Gracenotes wonders if there have been any thread pools implemented, other than with the shootout
20:01:53 <pumpkin> I saw something recently on hackage
20:01:55 <gwern> Gracenotes: what, like the threadpool package on hackage?
20:02:03 <Gracenotes> @hackage threadpool
20:02:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/threadpool
20:02:03 <gwern> the 1000th package uploaded?
20:02:12 <dons> Gracenotes: on hackage.
20:02:15 <dons> gwern: months ago
20:02:23 <Gracenotes> ;_;
20:02:27 <gwern> Gracenotes: incidentally, that feature is just a concatenation - it doesn't actually tell you if it exists
20:02:30 <Cale> The cml library also has some very general operations for message protocols.
20:02:36 <dons> gwern: 1299 packages.
20:02:42 <gwern> the @hackage shortcut I've long felt is nonsense on stilts
20:02:56 <dons> commit the change you want to see :)
20:03:00 <gwern> dons: yeah, but the discuessions and cabalization of threadpool was months ago as well...
20:03:03 <sbahra> "threadPool: Runs other programs in the manner of a thread pool"
20:03:09 <sbahra> "Takes a single, optional argument which is the number of threads (the default is three). Give it the commands to run, one per line, through standard input. You may use blank lines to divide the commands into sections. The commands in a section will not be started until all the commands in previous sections are complete. "
20:03:11 <sbahra> ...
20:03:24 <Gracenotes> hrm
20:03:26 <gwern> dons: eh. can lb plugins do http lookups?
20:03:26 <dons> dph also has a worker pool at the bototm
20:03:30 <dons> sure
20:03:30 <Gracenotes> so the thread pool is fixed, too
20:03:33 <dons> ?google woot woot
20:03:34 <lambdabot> http://www.woot.com/
20:03:34 <lambdabot> Title: Woot : One Day, One Deal (SM)
20:03:34 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/Control-Concurrent-CML.html
20:03:37 <Gracenotes> no cached make-as-you-go thread pools
20:03:39 <monochrom> The two commands @hackage and @faq are supposed to teach you basic combinator programming, i.e., the I and K combinators.
20:03:51 <dons> Gracenotes: there's a lib for that. dph also has precisely that.
20:04:04 <pumpkin> <3 dph
20:04:09 <gwern> monochrom: I always saw @faq as a demonstration of 'const'
20:04:24 <monochrom> Yes that's K.
20:04:26 <Gracenotes> for now, though, I would just be happy if someone made timeout support built into MVars :)
20:04:37 <Cale> Gracenotes: why should it be built in?
20:04:45 * BMeph wonders how tough a Hoogle-like utility for Hackage packages would be...
20:04:52 <Gracenotes> why shouldn't it be? I would find it useful.
20:05:03 <Cale> Because System.Timeout does it perfectly
20:05:19 <Gracenotes> by creating a thread.
20:05:24 <pumpkin> a green thread
20:05:26 <Cale> Huh?
20:05:33 <Cale> Threads are like 24 bytes or something
20:05:34 <sbahra> Gracenotes, the package is pretty useless.
20:05:42 <Cale> It's not like it's expensive to make one :)
20:05:45 <Gracenotes> pumpkin: yes, a green thread, I realize, but one nonetheless
20:05:58 <Cale> Gracenotes: Threads are the natural way to do a timeout
20:06:05 <pumpkin> a green thread is probably cheaper than any code you could write that simulated it
20:06:06 <pumpkin>  :P
20:06:07 <Cale> Gracenotes: Even if it was built-in, it would use a thread.
20:06:12 <gwern> BMeph: what would a hoogle for hackage be besides hoogle itself?
20:06:32 <jinho> http://haskell.pastebin.com/m3973d6ff : can someone explain to me what's going on at line 21, specifically with (map renderJValue vs), thanks
20:07:05 <Cale> jinho: That applies the function renderJValue to each of the elements of the list vs giving a new list
20:07:36 <Cale> actually, that code seems excessive, doesn't it?
20:07:42 <Cale> > intercalate ", " []
20:07:44 <lambdabot>   ""
20:07:44 <pumpkin> :o http://blog.plt-scheme.org/2009/05/typed-scheme-20.html
20:07:48 <jinho> Cale: taken from "Real World Haskell"
20:07:57 <Cale> jinho: hmm, that's funny then :)
20:07:57 <jinho> Cale: maybe it's not so real world
20:07:59 <Cale> dons: !
20:08:00 <Cale> hehe
20:08:05 <Gracenotes> eh. It'd be nice if something were built straight into Control.Concurrent.MVar. For a concurrent primitive, it seems it should suppose timeouts
20:08:23 <monochrom> map renderJValue [x,y,z] = [renderJValue x, renderJValue y, renderJValue z]  if it helps.
20:08:23 <Gracenotes> *support
20:08:25 <pumpkin> Gracenotes: why build in special-case support when you have something more general?
20:08:31 <Cale> renderJValue (JArray a) = "[" ++ intercalate ", " (map renderJValue vs) ++ "]"
20:08:35 <Cale> would work just as well
20:08:40 <Gracenotes> pumpkin: because it's annoying to work with two interfaces at the same time?
20:08:53 <pumpkin> it shouldn't be :/ things are supposed to be composable
20:09:19 <pumpkin> <=< it!
20:09:22 <pumpkin> :P
20:09:24 <Gracenotes> >=>
20:09:26 <Gracenotes> <=<
20:09:29 <Cale> Gracenotes: Consider that System.Timeout works not only with MVars but also with Chans and every other blocking concurrency structure
20:09:46 <Cale> (including ones which have not yet been invented)
20:10:06 <jinho> Cale: can you tell me what's going on with the renderJValue (JObject o) part? I can't wrap my head around (map renderPair ps)
20:10:08 <Cale> As long as it's not making blocking FFI calls, it will work :)
20:10:14 * codebliss waits for the following to be legal.  (:=) = (=)
20:10:29 <Cale> jinho: Do you know what map is?
20:10:44 <Cale> > map show [1,2,3,4,5]
20:10:46 <lambdabot>   ["1","2","3","4","5"]
20:10:53 <jinho> right
20:11:05 <Cale> jinho: So, if ps is a list of pairs
20:11:08 <jinho> ok I'm an idiot
20:11:23 <Cale> jinho: map renderPairs ps is the list of results of applying renderPair to each of those
20:11:32 <jinho> Cale: I didn't realize a JSON object could hold a list of pairs
20:11:36 <Cale> ah, okay
20:12:13 <Gracenotes> well. I guess I still am a bit suspicious, and I'll see what I can do about Chan not refusing to expose (:O)
20:12:17 <Cale> It seems whoever wrote that code for RWH didn't realise that intercalate gives an empty string when given an empty list.
20:12:20 <mmorrow> Gracenotes: newtype MVarT a = MVarT (Mvar a); takeMVarT :: Int -> MVarT a -> IO (Maybe a); takeMVarT t (MVarT mv) = timeout t (takeMVar mv)
20:12:21 <jinho> Cale: thanks though
20:12:40 <pumpkin> Gracenotes: maybe it's a coverup!
20:12:47 <mmorrow> Gracenotes: Chans are borked
20:12:50 <mmorrow> Gracenotes: do:
20:12:57 <Cale> "not refusing to expose"?
20:13:02 <Gracenotes> sorry. cut out the "not"
20:13:19 <pumpkin> b0rked
20:13:33 <pumpkin> b0rk b0rk b0rk
20:13:35 <Gracenotes> I have a knack for the worst against-my-original-meaning typos
20:13:36 <Cale> mmorrow: Are they?
20:13:57 <mmorrow> ghci> ch :: Chan Int <- newChan
20:13:57 <mmorrow> ghci> forkIO (readChan ch >> return ())
20:13:57 <mmorrow> ghci> isEmptyChan ch
20:14:02 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/Control-Concurrent-CML.html -- I'd like someone to try this library and see how it is :)
20:14:03 <mmorrow> (it blocks!!)
20:14:15 <Cale> Oh, right. That is pretty dumb.
20:14:32 <pumpkin> :o
20:14:35 <mmorrow> and it's an artifact of the implem... so the only solution is a different one
20:14:40 <pumpkin> isEmptyCan can block?
20:14:44 <pumpkin> *Chan
20:14:46 <Cale> The equivalent written with TChan doesn't do that stupid thing though.
20:14:56 <Gracenotes> isEmptyChan is an invitation for race conditions
20:14:57 <pumpkin> isn't that just a bug that needs fixing?
20:15:04 <Cale> Yes, it's just a bug.
20:15:08 <mmorrow> (this is mine: http://moonpatio.com/repos/vacuum-gl/System/Vacuum/OpenGL/Q.hs)
20:15:21 <pumpkin> much cooler name
20:15:25 <mmorrow> pumpkin: the only way to fix it is a different implmentation though
20:15:27 <pumpkin> I want to use a Q
20:15:28 <Cale> and an easy workaround is just to use TChan with everything wrapped in atomically :)
20:15:37 <pumpkin> your Q feels more rational ;)
20:15:42 <monochrom> QChan?
20:15:54 <mmorrow> it has a non-blocking getChanContents too!
20:16:03 <Gracenotes> Q. Chan: sounds like an awesome name. for a person.
20:16:09 <pumpkin> Quentin Chan
20:16:14 <Gracenotes> make it so
20:16:15 <pumpkin> Quentin Charantino
20:16:23 <Cale> You should replace Chan with it...
20:16:23 * mmorrow was just thinking that
20:16:25 <monochrom> "QChan is a channel for requesting the Q community to do magic for you, for example change the user's input so it no longer triggers a bug in your program"
20:16:35 <mmorrow> (thinking Quentin Charantino)
20:16:40 <pumpkin> :D
20:17:44 <pumpkin> Cale: did lambdabot forget quotes recently?
20:17:56 <Gracenotes> hm. I suppose I can live with timeouts being inexact. after all, an amount like "10 seconds" is rather arbitrary in the scheme of things
20:17:58 <Cale> pumpkin: It is possible?
20:18:04 <monochrom> It forgets quotes every year.
20:19:45 <mmorrow> Gracenotes: at the second scale Control.timeout should be more than ok
20:19:55 <mmorrow> (or threadDelay for that matter)
20:21:23 <mmorrow> Cale: i was reading somewhere that STM updates are fundamentally O(n), where n is the size of the structure being updated
20:21:34 <mmorrow> (something about transaction logs or something)
20:21:52 <Cale> mmorrow: whaaat... that sounds implausible...
20:21:57 <mmorrow> or something to the effect that there's an inherent limitation
20:22:06 * mmorrow looks for quote
20:22:15 <mmorrow> i think it was in that new ghc-rts paper
20:22:56 <monochrom> If you keep running into contentions yes.
20:23:45 <QtPlaty[HireMe]> The "default" keyword is a ghc extention?
20:23:53 <Cale> mmorrow: Do you mean that every part of the structure is being updated?
20:24:00 <Cale> QtPlaty[HireMe]: no
20:24:06 <monochrom> The "default" keyword is in Haskell98.
20:24:40 <monochrom> http://www.haskell.org/onlinereport/decls.html#sect4.3.4
20:25:14 <roconnor> @roll 1300000d6
20:25:14 <lambdabot> Consider it noted.
20:25:18 <roconnor> damn it
20:25:20 <roconnor> I always do that
20:25:26 <mmorrow> hmm, not that one. i think i know which one exactly that quotes (or the quote i remembered incorrectly) is from
20:25:32 <monochrom> http://www.hck.sk/users/peter/HaskellEx.htm is a very useful page for looking up Haskell98 grammar and where to find details in the Haskell98 report.
20:25:48 <mmorrow> Cale: i'm not sure exactly what that remark meant in particular
20:26:24 <monochrom> @roll
20:26:25 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
20:26:29 <Cale> mmorrow: It certainly takes O(n) time to commit a transaction log which has n entries in it.
20:26:36 <monochrom> Oh, roll = tell
20:26:54 <Cale> @dice 1300000d6
20:26:55 <lambdabot> 1300000d6 => 4549630
20:27:00 <mmorrow> oh nice. this might be very interesting to anyone that wants to get up to speed with haskell concurrency stuff http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/AFP08-notes.pdf
20:27:50 <mmorrow> Cale: the context was comparing concurrent algo speed/complexity between implems using {IORef+atomicModifyIORef, MVar, STM}
20:28:12 <mmorrow> (can anyone think off-hand what paper that is?)
20:28:14 <pumpkin> @quote pumpkin
20:28:14 <lambdabot> pumpkin says: makes the next internet hit video, 2 natural transformations, 1 functor
20:28:29 <pumpkin> oh I guess lambdabot quotes are room-specific?
20:28:59 <mmorrow> Cale: found it
20:29:09 <mmorrow> www.haskell.org/~simonmar/papers/concurrent-data.pdf
20:31:53 <gwern> pumpkin: no, quotes are all from a single file
20:32:01 <gwern> which contains no info about origin
20:32:20 <vininim_> @src endBy
20:32:21 <lambdabot> Source not found. :(
20:32:29 <pumpkin> gwern: it's odd, someone did @quote pumpkin four times in a row, in #haskell-blah and got the same quote each time
20:32:38 <pumpkin> gwern: did you figure out your list comprehension thing by the way?
20:32:41 <gwern> that's randomness for you
20:33:13 <gwern> pumpkin: Cale figured that it was conflicting rules resulted in a call to a library map versus an inlined map, but he got different results on 6.10.3
20:33:16 <Twey> â€˜Nine... nine... nine... nine... nine... nine... nine... nine...â€™
20:34:03 <Cale> gwern: The results I got in 6.10.3 were similar enough not to worry about
20:34:17 <gwern> @qoute Hobbes
20:34:17 <lambdabot> Maybe you meant: quote vote
20:34:19 <Cale> gwern: But on 6.10.2 I can imagine those performing differently, do they?
20:34:30 <gwern> oh come on, that's obviously closer to quote than vote -_-
20:34:37 <gwern> @quote Hobbes
20:34:37 <lambdabot> thetallguy says: Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
20:34:40 <pumpkin> are there any things that need figuring out to replace foldr/build fusion with stream fusion in GHC?
20:34:52 <pumpkin> or does it just need someone to implement it?
20:35:31 <Cale> pumpkin: I thought it was implemented at least in part...
20:35:39 <pumpkin> well, as a library
20:35:52 <pumpkin> but there was talk of replacing existing fusion with the library
20:37:12 <mmorrow> what's the difference? (not rhetorical)
20:37:32 <pumpkin> stream fusion helps with many more operations, I think
20:37:42 <pumpkin> and seems simpler conceptually, to me at least
20:37:47 <mmorrow> is there a description of it somewhere?
20:37:52 <mmorrow> @type build
20:37:53 <lambdabot> Not in scope: `build'
20:37:54 <pumpkin> stream fusion?
20:37:58 <pumpkin> or foldr/build?
20:37:59 <mmorrow> , build
20:38:00 <lunabot>  luna: Not in scope: `build'
20:38:03 <mmorrow> stream
20:38:12 <dmwit> It's buildr.
20:38:20 <pumpkin> it is?
20:38:32 <pumpkin> mmorrow: http://www.cse.unsw.edu.au/~dons/papers/stream-fusion.pdf
20:38:41 <pumpkin> http://hackage.haskell.org/trac/ghc/ticket/915
20:39:53 <mmorrow> , [$ty| build |]
20:39:56 <lunabot>  forall a . (forall b . (a -> b -> b) -> b -> b) -> [] a
20:40:03 <pumpkin> see, that isn't a friendly function signature :P
20:40:10 <gwern> (wow, version changed from 6.4.2)
20:40:19 <pumpkin> stream fusion is a lot prettier in my opinion :)
20:40:21 <gwern> -> [] a
20:40:22 <gwern> ?
20:40:27 <pumpkin> [a]
20:40:31 <mmorrow> pumpkin: oh nice, i've actually looked at this paper when i first started with haskell
20:40:42 <pumpkin> it's a cool idea
20:41:07 <mmorrow> it should be interesting to go over it again
20:41:22 <pumpkin> "To replace GHC's existing list fusion, we'll need to work out how concatMap is optimised, and push the desugaring for list comprehensions into GHC."
20:41:34 <pumpkin> so I guess concatMap is the painful one
20:44:07 <Cale> pumpkin: I don't think that build is so bad...
20:44:17 <Cale> pumpkin: But stream fusion is indeed better.
20:45:02 <Cale> It might be even nicer to have some extremely general implementation of fusion as part of the compiler though, I think.
20:45:26 <mmorrow> ghc uses either build/foldr or this http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2260 method to desugar list comps
20:45:27 <Cale> (that works across all algebraic types, say)
20:45:36 <mmorrow> i don't think it actually uses concatMap
20:45:50 <pumpkin> wow
20:45:59 <mmorrow> that'd be pretty cool to have *-comprehensions
20:46:05 <mmorrow> (where * can be array, vector, whatever)
20:46:08 <pumpkin> Cale: I agree
20:49:50 <mmorrow> pumpkin: here's that listcomp desugaring code (here done on the TH ast) if you're interested http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2490#a2490
20:49:58 <mmorrow> this is the "classic" method apparently
20:50:06 <mmorrow> (the other being build/foldr)
20:51:07 <hackagebot> LslPlus 0.4.1.1
20:52:30 <pumpkin> cool :)
20:52:42 <mmorrow> pumpkin: i followed along with http://moonpatio.com/repos/LIBS/Language/ghc/compiler/deSugar/DsListComp.lhs for that algo
20:53:12 <mmorrow> i wish darcs.haskell.org sent .l?hs as text/plain
20:53:27 <pumpkin> I wish my browser wouldn't download the .gz patches
20:53:39 <mmorrow> heh, i actually like that "feature"
20:53:57 <mmorrow> err, you mean it doesn't decode them?
20:54:01 <pumpkin> yeah
20:54:04 <mmorrow> heh
20:54:10 <pumpkin> I'd love to see them in the browser without downloading and unpacking them
20:55:51 <mmorrow> still have to fill in the case for
20:55:54 <mmorrow> , 'LetS
20:55:55 <lunabot>  Language.Haskell.TH.Syntax.LetS
20:55:59 <mmorrow> now that i look at that
20:56:21 <mmorrow> (go e (LetS decs : ss) xs = error "don't do LetS")
20:56:23 <pumpkin> I wonder what projects people will work on at the hackathon
20:56:27 <pumpkin> there are so many things I want to work on
20:57:50 <pumpkin> is there a package out there that builds "tied knot" graphs?
20:57:56 <pumpkin> that seems like it would be pretty cool
20:58:41 <ray> hackathons are filled with boring people who disapprove of crashing drunkenness
20:58:46 <pumpkin> :o
20:58:51 <pumpkin> so I take it you won't be going to this one?
20:59:27 <ray> not unless there's an open bar
21:00:20 <mmorrow> ray: just bring a waterbottle
21:00:34 <ray> or a flask :)
21:00:55 <mmorrow> (i wasn't meaning to put water in the waterbottle ;)
21:01:26 <ray> naturally
21:01:32 <pumpkin> 151bottle
21:02:53 <pumpkin> @seen bsp
21:02:54 <lambdabot> I haven't seen bsp.
21:02:55 <SamB> ray: what, no alcohol-fueled coders attend hackathons, you say?
21:03:08 <pumpkin> does anyone know what his nick on IRC is, or if he just never comes online?
21:03:19 <shapr> who?
21:03:34 <pumpkin> max bolingbroke
21:03:46 <gwern> don't know of him on irc, sry
21:03:47 <shapr> I don't know if he shows up on irc.
21:03:59 <shapr> Not that I've been online much the past year.
21:05:54 <pumpkin> ah :)
21:08:08 <Gracenotes> hm.
21:08:13 <pumpkin> hm. indeed
21:08:39 <ray> philadelpha's not unreachable from here i guess
21:08:56 <pumpkin> you should go!
21:08:59 <ray> which is good, otherwise it'd be garbage collected
21:09:06 <pumpkin> geek.
21:09:16 <pumpkin> nerd?
21:09:18 <pumpkin> what's the difference
21:09:45 <ray> i'm not sure
21:09:51 <pumpkin> anyway, one of those
21:09:55 <Gracenotes> quizas
21:09:55 <ray> i'm not either, just the victim of an unfortunate series of events
21:10:23 <pumpkin> Gracenotes: zomg foreign languidge
21:10:53 <dmwit> ray: You should definitely come!
21:11:19 <dmwit> Also, geek is anyone obsessed with sci-fi or fantasy; nerd is anyone obsessed with technology.  You're welcome.
21:11:20 <ray> i'll certainly consider it, since it's not tomorrow or anything
21:11:22 <Gracenotes> ..
21:11:24 <Gracenotes> quiza
21:11:25 <Gracenotes> s
21:11:29 <pumpkin> Gracenotes will only go if we speak spanish there
21:11:32 <pumpkin> dmwit: thanks :)
21:12:10 <Gracenotes> dmwit: to the contrary. I think geek is someone obsessed with technology; nerd is obsessed with culture
21:12:25 <dmwit> Uh, culture?
21:12:29 <Gracenotes> my connotations vs. yours seem reversed >_>
21:12:39 <lament> so there's still no way to split a string given a separator? :(
21:12:41 <Gracenotes> dmwit: yes. e.g. Star Wars nerd, WoW nerd, etc.
21:12:45 <pumpkin> @hackage split
21:12:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/split
21:13:02 <dino-> lament: Funny you should mention, I was tinkering with something today..
21:13:05 <Gracenotes> vs. programming geek, rocket science geek
21:13:22 <dmwit> Well, for what it's worth, the dictionary says a geek is a person with an unusual or odd personality, and a nerd is a student who studies excessively.
21:13:34 * lament mumbles
21:13:57 <lament> pumpkin: :(
21:14:00 <dino-> If you have Parsec instanced into Applicative: p target = (,) <$> (manyTill anyChar $ try $ string target) <*> many anyChar
21:14:06 <pumpkin> lament: it's a nice package :)
21:14:17 <pumpkin> :o
21:14:28 <lament> pumpkin: splitting lists is not a package. It's not even a source file.
21:14:33 <dino-> You get the (before, after) pair without the target string
21:14:36 <lament> It's a couple functions and they should reside in Data.List
21:14:37 <pumpkin> lament: ?
21:14:43 <mmorrow> lament: i rewrite the it every day probably at least 3 times if that counts :/
21:14:44 <pumpkin> lament: look at the package I linked to
21:14:47 <mmorrow> s/the//
21:14:55 <lament> pumpkin: that's what i'm saying.
21:15:01 <lament> pumpkin: installing a whole package for this is crazy.
21:15:02 <pumpkin> lament: there are several different ways of doing it... it's not just a couple of functions
21:15:13 <Gracenotes> dmwit: mm. Well those are vague. I tend to view a nerd's obsessions as more popular-culture-y than a geek's. But you can only splice meaning so much... hm.
21:15:18 <mmorrow> (actually chunk is what i rewrite every day)
21:15:29 <pumpkin> do you keep the separators, discard them, do you split based on conditions or constants, or lengths
21:15:33 <ray> splitting combinators! =D
21:15:33 <pumpkin> things like that
21:15:36 <mmorrow> @let chunk _ [] = []; chunk n xs = let (ys,zs) = splitAt n xs in ys : chunk n zs
21:15:38 <lambdabot>  Defined.
21:15:39 <Gracenotes> they can't really be viewed as opposites.
21:15:42 <pumpkin> ray: that's what it is
21:15:46 <mmorrow> i can do that in mah sleep now
21:15:49 <lament> pumpkin: it's a single function in both Python and C#.
21:15:50 <Gracenotes> anyway. </personal connotations>
21:15:58 <pumpkin> lament: that isn't as flexible :D
21:16:11 <pumpkin> lament: and doesn't work on arbitrary lists
21:16:19 <mmorrow> > plit
21:16:19 <lament> :\
21:16:21 <lambdabot>   Not in scope: `plit'
21:16:21 <mmorrow> > split
21:16:23 <lambdabot>   Overlapping instances for GHC.Show.Show (g -> (g, g))
21:16:23 <lambdabot>    arising from a use...
21:16:46 <dmwit> > split (0, 0)
21:16:47 <lambdabot>   No instance for (System.Random.RandomGen (t, t1))
21:16:47 <lambdabot>    arising from a use of ...
21:17:03 <dmwit> :t mkStdGen
21:17:04 <lambdabot> Int -> StdGen
21:17:09 <dmwit> > split (mkStdGen 0)
21:17:09 <mmorrow> @let splat _ [] = []; splat p xs = case break p xs of ([],zs) = zs; (ys,zs) = ys : splat p zs
21:17:10 <lambdabot>   (2 40692,40014 2147483398)
21:17:10 <lambdabot>   Parse error
21:17:13 <lament> pumpkin: there's a kind of fine balance between flexibility and usability
21:17:18 <pumpkin> lament: split :: Splitter a -> [a] -> [[a]] is nice, I think
21:17:27 <mmorrow> @let splat _ [] = []; splat p xs = case break p xs of ([],zs) -> zs; (ys,zs) -> ys : splat p zs
21:17:28 <lambdabot>  <local>:13:80:
21:17:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a...
21:17:30 <dmwit> mmorrow: needs more {}
21:17:47 <dmwit> Oh, I guess not.
21:17:55 <pumpkin> lament: it's pretty usable :P but if you can decide on a single good meaning (with justification) of split to add to the std lib, maybe they'll add it?
21:18:01 <mmorrow> @let splat _ [] = []; splat p xs = case break p xs of ([],zs) -> [zs]; (ys,zs) -> ys : splat p zs
21:18:03 <lambdabot>  Defined.
21:18:12 <mmorrow> can haz cowbell?
21:18:30 <lament> > splat "," "hello,world"
21:18:31 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:18:38 <lament> er
21:18:41 <ray> i should write some mahjong combinators
21:18:43 <dmwit> mmorrow: I think it needs more drop now.
21:18:46 <pumpkin> GHC.Bool.Bool :o
21:18:47 <lament> > splat ',' "hello,world"
21:18:47 <mmorrow> > splat (==',') "hello,world"
21:18:49 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
21:18:50 <lambdabot>   ["hello",",world"]
21:18:50 <pumpkin> where did that come from?
21:18:54 <mmorrow> crapp
21:18:56 <dmwit> > splat (==',') "hello,bad,world"
21:18:58 <lambdabot>   ["hello",",bad,world"]
21:19:11 <mmorrow> @let splatter _ [] = []; splatter p xs = case break p xs of ([],zs) -> [zs]; (ys,zs) -> ys : drop 1 (splatter p zs)
21:19:12 <lambdabot>  Defined.
21:19:20 <pumpkin> you need a wrangle in there
21:19:21 <mmorrow> > splatter (==',') "hello,world"
21:19:22 <lambdabot>   ["hello"]
21:19:27 <mmorrow> gah!
21:19:31 <mmorrow> oh, n/m
21:19:31 <dmwit> hehehe
21:19:33 <mmorrow> that worked
21:19:39 <mmorrow> heh
21:19:51 <dmwit> > splatter (==',') "hello,good,world"
21:19:52 <lambdabot>   ["hello"]
21:19:58 <dmwit> fail
21:20:02 <mmorrow> the song rawhide plays in my head whenever i write a function named wrangle
21:20:05 * pumpkin wants to make a new SCM based on darcs
21:20:24 <mmorrow> grrr
21:20:30 <dmwit> mmorrow: splatter p (drop 1 zs) instead
21:20:39 <mmorrow> kill!
21:20:46 <mmorrow> im running out of names
21:20:49 <dmwit> And change the first branch of the case.
21:20:53 <dmwit> To be (zs, [])
21:20:56 <mmorrow> yeah, true
21:21:03 <mmorrow> guess it's time to pull out wrangle
21:21:08 <pumpkin> :D
21:21:15 <dmwit> :t splattest
21:21:16 <lambdabot> Not in scope: `splattest'
21:21:26 <pumpkin> wrangle always works
21:21:32 <lament> splat, splatter, splattest!
21:21:42 <mmorrow> @let wrangle _ [] = []; wrangle p xs = case break p xs of (ys,[]) -> [ys]; (ys,zs) -> ys : wrangle p (drop 1 zs)
21:21:44 <lambdabot>  Defined.
21:21:46 <mmorrow> wooo
21:21:48 * pumpkin grins
21:22:01 <Raynes> I can't believe I was just stupid enough to type init [1..10000000000] into GHCi. :|
21:22:02 <lament> > wrangle (== ',') "what,the , hell"
21:22:04 <lambdabot>   ["what","the "," hell"]
21:22:10 <lament> woo!
21:22:10 <pumpkin> Raynes: just ctrl+c it?
21:22:15 <dmwit> > wrangle isSpace "                   "
21:22:17 <lambdabot>   ["","","","","","","","","","","","","","","","","","",""]
21:22:30 <mmorrow> wrangle them isSpaces!
21:22:39 * mmorrow cues rawhide
21:22:40 <dmwit> ...rawhide?
21:22:45 <Raynes> pumpkin: By time I noticed my computer was freezing it was too late.
21:22:52 <pumpkin> > wrangle even [1..]
21:22:53 <lambdabot>   [[1],[3],[5],[7],[9],[11],[13],[15],[17],[19],[21],[23],[25],[27],[29],[31]...
21:22:55 <Raynes> Pop goes the weesle.
21:22:58 <dmwit> Raynes: ^z always works here
21:23:08 <dmwit> Raynes: ^zkill %1 is burned into my fingers
21:23:16 <dmwit> Which is bad, because it's not always %1. =/
21:24:04 <pumpkin> ray: http://www.haskell.org/haskellwiki/Hac_Ï†
21:24:46 <ray> ghci needs an option to only show a certain number of characters a la lambdabot
21:24:47 <Gracenotes> > wrangle even ([1..] >>= \x -> [x, x])
21:24:48 <lambdabot>   [[1,1],[],[3,3],[],[5,5],[],[7,7],[],[9,9],[],[11,11],[],[13,13],[],[15,15]...
21:24:55 <Gracenotes> o_O
21:24:59 <pumpkin> that's useful
21:25:20 <dmwit> > wrangle even ([1..] >>= join replicate)
21:25:22 <lambdabot>   [[1],[],[3,3,3],[],[],[],[5,5,5,5,5],[],[],[],[],[],[7,7,7,7,7,7,7],[],[],[...
21:25:33 <dmwit> YES!  I've always wanted that!
21:25:46 <Gracenotes> ever since I was a little girl!
21:26:13 <Gracenotes> er. boy. (as applicable)
21:26:52 <dino-> @paste
21:26:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
21:27:46 <dmwit> Alright... bed and a decent night's rest, or code and never sleep?
21:28:14 <dino-> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5244#a5244
21:28:38 <pumpkin> dmwit: I'd get some sleep
21:28:53 <dino-> substAll and splitAll, with applicative parsec. Have I mentioned how excited I am lately with applicative functors?
21:28:59 <dmwit> Yeah, that's definitely what I should do.
21:29:12 <pumpkin> I love applicative
21:29:13 <Gracenotes> dino-: they are very neat
21:29:21 <Gracenotes> @where applicativeparsec
21:29:21 <lambdabot> http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/ and http://book.realworldhaskell.org/read/using-parsec.html#id652399
21:29:23 <Gracenotes> ^ you've read?
21:29:35 <dino-> Gracenotes: No, thank you!
21:29:36 <mxc> applicative has been getting some love in this channel in the past few days..
21:29:55 <mxc> i wonder if 'learn you a haskell' adding a chapter on it helped
21:29:59 <pumpkin> but monoids for parsing also seems cool
21:30:02 <dino-> I only read The Paper, wikibook and parts of RWH a-la Applicoparsec
21:30:13 <pumpkin> I guess they aren't mutually exclusive :)
21:30:19 <pumpkin> and Alternative is just monoid
21:30:22 <Gracenotes> righto
21:31:12 <dino-> Also, I have a naggy feeling those split* functions should be folds.
21:31:19 <pumpkin> folds?
21:31:45 <pumpkin> oh in your paste?
21:31:52 <dino-> Instead of recursing until Left. yes
21:32:45 <Gracenotes>  dino-: hm. In general, one would use Parsec with one "parse" call for the whole expression, and everything else composed of smaller Parsers
21:32:48 <Gracenotes> a la combinators
21:33:05 <Gracenotes> and there are built-in Parsec fold combinators
21:33:10 <dino-> Gracenotes: I found the iterativeness of this difficult to do that way.
21:33:17 <tompledger> @type unfoldr
21:33:17 <dino-> But I could be Doing It Wrong, absolutely
21:33:18 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
21:33:34 <dino-> ah, parsec fold
21:33:38 <dino-> mm, must read
21:42:25 <roconnor> @free sortBy
21:42:26 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:42:35 <pastorn> what function does this?
21:42:37 <dino-> mm, unfold
21:42:38 <pastorn> f  "hhhheeello" == ["hhhh","eee","ll","o"]
21:42:44 <roconnor> group
21:42:50 <pastorn> thanks :)
21:42:54 <Cale> > group "mississippi"
21:42:56 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
21:43:07 <Cale> > group . sort $ "mississippi"
21:43:09 <lambdabot>   ["iiii","m","pp","ssss"]
21:43:10 <pumpkin> roconnor: what do the $ mean in @free output?
21:43:32 <pastorn> is there a more general version of group?
21:43:40 <pumpkin> groupBy?
21:43:45 <pastorn> one that might also take a function (a -> Eq b)
21:43:51 <pastorn> @type groupBy
21:43:52 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
21:44:01 <pastorn> cool, win
21:44:04 <roconnor> pumpkin: $map is the appropriate map for whatever datatype
21:44:06 <roconnor> I think
21:44:08 <pumpkin> ah
21:44:23 <pumpkin> seems like it would need to be list though
21:44:56 <dmwit> $map is Prelude.map, to avoid clashes with names you provide in lets.
21:45:03 <roconnor> g x y = h (f x) (f y) is probably a more clear hypothesis.
21:45:04 <pumpkin> ah :)
21:45:09 <dmwit> ?free let map = id in map
21:45:09 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
21:45:18 <dmwit> ...or something like that.
21:45:29 <roconnor> @free fst
21:45:30 <lambdabot> f . fst = fst . $map_Pair f g
21:45:41 <roconnor> dmwit: interesting
21:46:18 <roconnor> @free Left
21:46:18 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
21:46:24 <pumpkin> @free loop
21:46:25 <lambdabot> Expected variable or '.'
21:46:33 <dmwit> ?free map :: a -> a -> a
21:46:34 <lambdabot> f . map x = map (f x) . f
21:46:52 <dmwit> There, that shows how you might get a clash.
21:47:08 <dmwit> :t sortBy
21:47:10 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
21:47:18 <pumpkin> @free loop :: (a, b) -> (c, b) -> a -> c
21:47:19 <lambdabot> h . loop x y = loop ($map_Pair f g x) ($map_Pair h g y) . f
21:47:21 <dmwit> ?free map :: (a -> a -> Ordering) -> [a] -> [a]
21:47:21 <lambdabot> (forall x. g x = h (f x) . f) => $map f . map g = map h . $map f
21:47:26 <pumpkin> fun :)
21:47:56 <pastorn> @pl (\c0 c1 -> (xPos c0) == (xPos c1))
21:47:56 <lambdabot> (. xPos) . (==) . xPos
21:48:01 <pastorn> nah...
21:48:12 <dmwit> (==) `on` xPos
21:48:35 <dmwit> Though note that this has a more restrictive type than the lambda you wrote.
21:48:41 <dmwit> (very slightly more restrictive)
21:48:56 <pumpkin> it'd be nice if it were possible to write on that took typeclasses
21:49:11 <dmwit> yeah
21:50:49 <pastorn> dmwit: is that the reader monad?
21:50:53 <pastorn> @type on
21:50:54 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:51:00 <pumpkin> sort of similar
21:51:09 <dmwit> pastorn: No, there's no monad involved, but it does seem Reader-ish. =)
21:51:17 <pumpkin> :t liftM2 (==)
21:51:18 <pastorn> indeed it does
21:51:18 <lambdabot> forall a1 (m :: * -> *). (Eq a1, Monad m) => m a1 -> m a1 -> m Bool
21:51:30 <pastorn> gaddamn ((->) a)
21:51:34 <pumpkin> I love it :)
21:51:49 <pumpkin> could just be the reader applicative I guess
21:52:26 * pastorn is writing recursive list functions like it's 1998!
21:52:32 <vininim_>  hGetBufNonBlocking: illegal operation (handle is closed)
21:52:35 <vininim_> baaaawwww
21:53:33 <pumpkin> http://imgur.com/k27q8.jpg
21:54:37 <Gracenotes> er
21:54:47 <Gracenotes> subtraction. there is only addition and negation
21:55:19 <pumpkin> division. there is only multiplication and multiplicative inversion ?
21:55:29 <Gracenotes> I was about to say, yes :o
21:55:44 <pumpkin> it's a stupid question :P
21:56:34 <vininim_> Is there any alternative to bracket that is ByteString friendly?
21:57:09 <pumpkin> in the sense that it'll finalize the underlying buffer of the bytestring?
21:57:46 <vininim_> @type ($!)
21:57:48 <lambdabot> forall a b. (a -> b) -> a -> b
21:57:58 <vininim_> @src ($!)
21:57:59 <lambdabot> f $! x = x `seq` f x
21:58:44 <vininim_> pumpkin: something like that
22:00:00 <vininim_> uh.. it seems unrelated...
22:00:06 <pumpkin> ?
22:02:07 <vininim_> the problem is Data.ByteString.Lazy.Char8.hGetContents not liking bracket and seq
22:02:35 <Gracenotes> hm. it is lazy after all.
22:03:49 <mmorrow> vininim_: *GetContents puts the Handle in a "half-closed" state
22:04:19 <mmorrow> why are you bracketing?
22:05:21 <Cale> You should *never* call hClose on a handle which has already had hGetContents run on it.
22:06:00 <Cale> The handle will close automatically at some point after you're done with the string
22:06:36 <vininim_> that ``some point'' might lead to resource exhaustion, no?
22:06:41 <dmwit> Yes.
22:06:41 <Cale> yes
22:06:50 <dmwit> If you're worried about it, don't use hGetContents.
22:06:51 <Cale> So hGetContents is bad if you're opening many files
22:07:23 <vininim_> hm.. what is the recommended way?
22:08:02 <Cale> Well, actually you could use the strict bytestring library's version of it, which does completely read the file all at once.
22:08:45 <Cale> Or you can read a line or other chunk at a time with the other primitives, and close when you're done
22:08:46 <mmorrow> vininim_: or you can just not use hGetContents..
22:09:14 <BMeph> What's "$map_Pair"? Is it like "curry (map . uncurry (***))"?
22:09:23 <dmwit> vininim_: Are you actually opening lots of files?
22:09:28 <dmwit> (Like, thousands?)
22:10:04 <dmwit> $map_Pair f g (x, y) = (f x, g y)
22:10:09 <vininim_> yes, 8k
22:10:33 <dmwit> Okay, so yeah, you'll want to do your own handle management.
22:10:35 <dmwit> :t openFile
22:10:35 <BMeph> > curry (map . uncurry (***)) f g (x,y)
22:10:36 <lambdabot> Not in scope: `openFile'
22:10:36 <lambdabot>   Couldn't match expected type `(SimpleReflect.Expr,
22:10:48 <dmwit> BMeph: I don't think that type-checks.
22:11:02 <BMeph> @type curry (map . uncurry (***))
22:11:04 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> [(b, b')] -> [(c, c')]
22:11:28 <dmwit> BMeph: I think it's just (***)
22:11:37 <dmwit> $map_Pair = (***) -- I mean
22:11:40 <BMeph> Oh, never mind, the "map" is an analogy. Got it. :)
22:12:02 <BMeph> dmwit: Ah, right. Thanks. :)
22:12:41 <dmwit> ?hoogle FilePath -> IO Handle
22:12:41 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
22:12:41 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
22:12:41 <lambdabot> Distribution.Simple.Utils die :: String -> IO a
22:12:48 <dmwit> Oh, so I did get the name right.
22:12:58 <dmwit> I guess it makes sense not to import System.IO in \bot, though.
22:15:39 <walter_> Could someone give me the haskell paste URL, please?
22:15:44 <dmwit> ?hpaste
22:15:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:16:05 <walter_> thanks
22:16:10 <walter_> ?hpasete
22:16:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:16:45 <elbar> that looks like cheating ;)
22:18:08 <walter_> Why do I get "match(es) are overlapped"   http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5245#a5245
22:18:31 <dmwit> isTagText and isTagOpen both match any value.
22:18:42 <dmwit> They bind that value to the name isTagText and isTagOpen, respectively. =)
22:19:09 <dmwit> (i.e. these do not test whether x is text or open, as you seem to be expecting them to)
22:19:33 <mmorrow> vininim_: withFile = flip bracket hClose . flip openFile ReadWriteMode
22:19:39 <walter_> dmwit, thank you, then , How can I distict Tag and TagText?
22:20:03 <mmorrow> pattern matching
22:20:07 <jeff_s_> cast x of x | isTagText x ->
22:20:08 <jeff_s_> | isTagOpen x ->
22:20:19 <jeff_s_> er, case x of rather
22:20:45 <dmwit> walter_: case x of TagOpen tagName attributes -> ...; TagText text -> ...
22:20:59 <jeff_s_> nm
22:21:21 <dmwit> Guards also work, but it's a good idea to understand how to use patterns. ;-)
22:21:42 <dmwit> (jeff_s_'s suggestion would be the guards route; my suggestion would be the patterns route)
22:21:44 <walter_> dmwit, your are right.
22:23:34 <walter_> I dont really quite understand, thanks. will try both.
22:24:38 <jeff_s_> The guards way looks a little sloppy, I'd use pattern matching whenever possible
22:25:12 <jeff_s_> but I'm still used to thinking in terms of what looks good in ML. Haskell's been a challenge
22:25:14 <pastorn> @src unlines
22:25:14 <lambdabot> unlines = concatMap (++ "\n")
22:25:51 <Gracenotes> :O
22:25:57 <Cale> Haha, from an oldish Onion video: "New CIA intelligence indicates Al-Queda may be linked to Al-Qaida, Al-Qaeada"
22:30:22 <jeff_s_> @src lines
22:30:22 <lambdabot> Source not found. Are you on drugs?
22:30:28 <jeff_s_> haha
22:30:45 <jeff_s_> this lambdabot fellow is really smart, clever and resourceful. Oh and reliable
22:30:48 <jeff_s_> and dependable
22:31:15 <Cale> The source is more reliably linked from the documentation
22:31:37 <jeff_s_> ah, then I take back the resourceful part
22:31:57 <Cale> for example, from here, http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3Alines you can click the source link, and you'll get http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#lines
22:32:29 <Cale> I think lines was left out for being a little long for @src
22:33:03 <jeff_s_> I see
22:48:27 <jeff_s_> oh heh, the toplevel isn't very smart about things like cycle [1,2,3]
22:49:26 <vininim_> mmorrow: that's bracket point-free =P
22:49:58 <vininim_> except that bracket is not only about file input
22:51:27 <Vq^> jeff_s_: you're thinking about the memory usage?
22:51:52 <pumpkin> shouldn't cycle [1,2,3] run in constant memory?
22:51:56 <pumpkin> unless you build something else off it
22:53:11 <Vq^> pumpkin: if you assign it to a top-level name and try to evaluate a large chunk of it, it probably takes a lot of memory
22:53:27 <pumpkin> why?
22:53:37 <Vq^> not sure what jeff_s_ meant by toplevel thought
22:54:58 <Vq^> pumpkin: because it gets memoized, and the top-level name has to keep it alive
22:55:15 <pumpkin> nope?
22:55:33 <dmwit> Vq^: ...so?
22:56:06 <dmwit> The memory for memoizing "cycle [1,2,3]" is what, 50 bytes?  That's not exactly "a lot".
22:56:11 <pumpkin> Vq^: I just wrote a simple program... running in constant space
22:56:29 <Vq^> i guess im mistaken then
22:56:31 <pumpkin> Vq^: x = cycle [1,2,3] at top level, main = print . length $ x
22:56:42 <dmwit> I assume jeff_s_ meant that if you type it into ghci, it loops printing it.
22:57:09 <dmwit> Which is true, and I'd be sad if it did anything else. =)
22:57:09 <Vq^> or it's some optimization that kicks in for simple programs
22:58:03 <dmwit> Optimization?  Yes, there's a slight optimization in the source for cycle...
22:58:04 <dmwit> ?src cycle
22:58:04 <lambdabot> cycle [] = undefined
22:58:05 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
22:58:33 <dmwit> That extra name "xs'" is what makes the magic.
23:00:55 <Vq^> interesting, i thought x would be stored in pumpkins example, since it shouldn't be recomputed if it's needed again
23:01:03 <pumpkin> it is stored
23:01:06 <pumpkin> but it's a circular list
23:01:39 <pumpkin> now if you did cycle (cycle [1,2,3]) that might be a problem, I think
23:01:43 <pumpkin> actually, not even
23:01:56 <Vq^> no, that one is the same thing
23:02:10 <sjanssen> cycle on an infinite list will leak memory
23:02:24 <pumpkin> because the outer call doesn't see the structure of the inner one?
23:03:06 <dmwit> sjanssen: I think not this particular infinite list, right?
23:03:19 <dmwit> Usually it can leak because we're keeping a reference around to it.
23:03:22 <Vq^> i think i get it, it simply doesn't have to construct more data
23:03:24 <dmwit> i.e. to the beginning of it.
23:03:36 <dmwit> But here that's okay, because the whole damn list is only 50 bytes or so.
23:03:42 <sjanssen> dmwit: for any infinite list
23:03:52 <pumpkin> yup, definitely problematic :)
23:03:54 <pumpkin> I just tried it
23:04:02 <sjanssen> pumpkin: yes, the cycle knows nothing about its input
23:05:14 <dmwit> Yep, it does seem to be wreaking havoc here.
23:05:32 <dmwit> That's odd, and I don't understand it.
23:06:13 <sjanssen> dmwit: in "xs' = xs ++ xs'" the end of xs is never reached
23:06:17 <dmwit> aah, I do understand it
23:06:25 <dmwit> Yeah, that's bad.
23:06:54 <dmwit> Well, there's not much you can do about that, I suppose.
23:07:02 <sjanssen> right
23:10:26 * BMeph looks for an interesting article... on Real Anal. Exchange
23:12:51 <pumpkin> :o
23:14:49 <Gracenotes> BMeph: sorry, it may be too late to use craigslist for that
23:15:49 <Adamant> Gracenotes: I was gonna go with a joke about UCSF, but I figured it was borderline bigoted
23:18:12 <BMeph> Hmm, rather "Real Analysis Exchange"
23:47:31 <Baughn> > (fmap.fmap.fmap
23:47:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:48:34 <Baughn> > ((fmap.fmap.fmap) (+) [Just 4,Nothing,Just 5]) 3
23:48:35 <lambdabot>   Couldn't match expected type `t -> f (f1 a)'
23:58:58 <Baughn> > ((fmap.fmap.fmap) (+3) [Just (+4),Nothing,Just (*5)])
23:59:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
23:59:00 <lambdabot>    arising from a use of `...
23:59:18 <Baughn> > ((fmap.fmap.fmap) (+3) [Just (+4),Nothing,Just (*5)]) 10 -- Geez, thought it could show those
23:59:19 <lambdabot>   Couldn't match expected type `t -> f (f1 a)'
23:59:29 * Baughn groans
23:59:43 <Baughn> > ((fmap.fmap.fmap) ($3) [Just (+4),Nothing,Just (*5)])
23:59:44 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
23:59:45 <lambdabot>    arising from the literal `4' at <...
