00:00:41 <ivanm> bnijk_: you know, you're not doing a good job of spamming/trolling...
00:01:15 <bnijk_> who said i was trying to
00:01:41 <ivanm> you were trying to pressure people to listen to your CD
00:01:43 <Qork> hmm playing around with scala i notice in a much clearer how less composable object-oriented code is
00:01:48 <ivanm> sounds like spamming to me...
00:01:55 <bnijk_> i wasn't trying to pressure anybody
00:02:00 <bnijk_> just threatening them idly
00:04:53 <Qork> was compiler a hard concept to come up with?
00:05:26 <ivanm> Qork: well, they were doing everything in machine code to start with
00:06:00 <ivanm> so you could argue that the actual conceptual leap was that you _could_ use a simpler language, then they just made compilers to convert the language to machine code
00:06:06 <Berengal> A compiler seems natural to me. First there was machine code... well, first there were wires, but then we invented the turing machine...
00:06:14 <ivanm> Berengal: no we didn't
00:06:17 <ivanm> turing did! ;-)
00:06:32 <houeland> I'm writing a web proxy and sometimes it just suddenly quits, without any exceptions or anything. How can I figure out what's going on?
00:06:34 <Berengal> He's one of us, isn't he?
00:06:47 <bnijk_> compilers are just a neverending attempt to translate natural language into machine code
00:07:04 <Berengal> Anyway, machine code was complicated for all the wrong reasons. You had to update every absolute adress after an instruction should you insert an extra one
00:07:20 <ivanm> Berengal: so what are the _right_ reasons for complicated stuff?
00:07:34 <ksf> http://www.brics.dk/~hosc/local/LaSC-2-1-pp9-50.pdf
00:07:48 <Berengal> ivanm: Well, assembly is still complicated in its own way
00:07:52 <ksf> usually I don't hand out links to papers before I read them fully, but this is _way_ cool.
00:08:00 <ivanm> ksf: what is it on?
00:08:04 <Berengal> We still use absolute adressing, except we don't deal with the numbers anymore
00:08:14 <Berengal> The assembler keeps track of that for us, we just use labels
00:08:16 <ksf> partial evaluating a partial evaluator with itself to get a compiler
00:08:39 <ksf> futuram^H^H^H^H^H^H^H^H^Hfutamura stuff
00:08:51 <Gracenotes> hm. what's recursion called that jumps between two functions?
00:09:00 <Berengal> Anyway, assemblers got macros, and people recognized that certain things could be factored out of assembly, and we made higher order languages
00:09:02 <Feuerbach> mutual?
00:09:03 <ksf> mutual recursion?
00:09:04 <Gracenotes> or two data structures, or a function and a data structure
00:09:06 <Gracenotes> yeah, that's it
00:09:10 <Gracenotes> :)
00:09:45 <ksf> Berengal, tell that to my asm lecturer and the guys that wrote TASM.
00:09:51 <ksf> ...or MASM, even worse.
00:09:56 <ksf> gas isn't usable, either.
00:10:01 <Berengal> ksf: What, the factoring out bit?
00:10:14 <ivanm> ksf: sure it's usable... people burn it all the time for heat, motion, etc.!
00:10:16 <ksf> nah, the macro stuff.
00:10:36 <ksf> nasm has cool macros, way better than c.
00:10:43 <ksf> i.e. turing complete
00:10:49 <Berengal> ksf: You mean "assemblers go macros"?
00:11:31 <ksf> ...I just know that I don't know any assembly language with serious macro capabilities that's older than, say, COBOL.
00:12:14 <johnw> on the Internet, no one knows that you're not an assembler macro
00:12:17 <p_l> Natural Language?
00:12:23 * p_l takes cover
00:12:24 <Berengal> ksf: FORTRAN (I)
00:12:50 <Qork> an assembler is a program written in assembler
00:13:06 <Qork> it transforms macros to asm and asm to machien code and links it together?
00:13:10 <p_l> Berengal: AFAIK FORTRAN's lack of macros etc. was what caused RATFOR
00:13:20 <johnw> we should be calling executables "The Assembled"
00:13:49 <vixey> <bnijk_> compilers are just a neverending attempt to translate natural language into machine code
00:13:52 <ksf> we could start a secret society named "the assembled lambdas"
00:14:02 <vixey> bnijk_: I don't think so most languages are not natural languages
00:14:11 <Berengal> p_l: I meant FORTRAN as an assembler with (predefined) macros. Also, haha, only serious
00:14:35 <ivanm> vixey: I can't think of a single programming language that _is_ a natural language
00:14:41 <ksf> nah, that's java what you're talking about.
00:14:53 <p_l> Berengal: "serious macro capabilities" :)
00:15:29 <ksf> ...the only thing in jvm assembly that's not in java is goto, and the only things not in java that are in jvm assembly are loops and if.
00:15:35 <Berengal> p_l: Ah, that's right, fortran didn't have functions did it?
00:15:37 <bnijk_> ivanm: python's getting pretty close
00:15:43 <ksf> ...there's even two bleeding case-switch instructions.
00:15:44 <bnijk_> there will always be some shorthand, too
00:15:48 <p_l> I'm pretty sure COBOL macros appeared later than Lisp ones
00:15:50 <ivanm> bnijk_: I beg to differ
00:15:55 <ivanm> it's structured
00:16:00 <ivanm> unlike natural language
00:16:02 <bnijk_> mmnn
00:16:05 <bnijk_> natural language is structure
00:16:10 <bnijk_> not quite so strictly, albeit
00:16:19 <ksf> python isn't a language, it hasn't tail-calls.
00:16:31 <johnw> natural language uses implied context to carry a lot of its meaning too
00:16:31 <p_l> Berengal: I'm not sure about first FORTRAN systems, but I think that at least by FORTRAN H it had subroutines
00:16:38 <Twey> ksf: It can have!
00:16:44 <pumpkin_> applescript tries hard to sound like natural language
00:16:47 <pumpkin_> but it fails
00:17:01 <Berengal> People need to realize that you can't program in a natural language
00:17:01 <Twey> I think Perl and Ruby are both more naturaly-language-like than Python
00:17:08 <Twey> Not that that's a good thing
00:17:09 <Berengal> Even humans have trouble disambiguating
00:17:12 * p_l is too scary of booting MVS just to check if it will accept subroutines in FORTRAN H
00:17:17 <Twey> You can program in Lojban
00:17:33 <Twey> But I wouldn't
00:17:34 <p_l> Twey: They are similar to rather structured languages like English
00:17:47 <Twey> natural**
00:17:55 <bnijk_> eventually you will just be able to say things like
00:18:02 <bnijk_> 'turn these mp3s into oggs'
00:18:06 <Twey> p_l: Well, as structured goes English isn't a great example, but sure
00:18:15 <Ralith> bnijk_: well that's not actually very hard
00:18:20 <bnijk_> i know it's not
00:18:23 <bnijk_> thank god
00:18:24 <Twey> It is to do it comprehensively
00:18:25 <Ralith> like
00:18:30 <Berengal> bnijk_: You won't. What's "these"?
00:18:30 <p_l> Twey: As someone whose native language has free-form syntax, I call English structured :D
00:18:32 <Ralith> I bet I could do that much right now if I cared enough
00:18:33 <ksf> bnijk_, why should I, if I can say "toOgg . toMP3"?
00:18:36 <Twey> Any specific command is easy, of course
00:18:38 <Ralith> Berengal: the current directory
00:18:42 <bnijk_> Berengal: well, ./
00:18:48 <Twey> ksf: That would be fromMP3
00:18:49 <BMeph> I accidentally  the whole language. Is that dangerous? ;p
00:18:49 <Ralith> see? intuitive enough
00:18:56 <ksf> er, yes.
00:18:58 <Twey> p_l: Oh, Polish?
00:19:04 <p_l> Twey: yeah...
00:19:05 <Ralith> BMeph: very.
00:19:21 <Ralith> and you could also have a 'recursively' modifier
00:19:25 <Ralith> and tab completion all along
00:19:37 <Twey> p_l: It is very heavily structured, but it's irregularly so
00:19:50 <Twey> Chinese would have been a better example
00:20:02 <ksf> limiting ourselves to natural languages is a waste, anyway, none fully exploits our grammar processors.
00:20:07 <Twey> p_l: Have you seen http://www.csse.monash.edu.au/~damian/papers/HTML/Perligata.html?
00:20:14 <p_l> Twey: yes...
00:20:23 * Twey was very impressed
00:20:31 <Twey> It looks amazing :-P
00:20:59 <p_l> Twey: I was impressed and horrified at the same time. It's the kind of thing that you use as example of Crazy Awesome in programming, IMHO :P
00:21:10 <Twey> Haha, yeah
00:21:24 <Berengal> Crazy doesn't subtract anything from awesomeness
00:21:52 * p_l is big fan of Crazy Awesome things
00:22:10 * Twey agrees strongly.
00:22:21 <bnijk_> Twey: wtf is this shit
00:22:56 <Twey> bnijk_: Perligata est!
00:23:01 <bnijk_> this is fantastic shit
00:23:10 <bnijk_> what a waste of time though
00:23:40 <Twey> It's no more a waste of time than Compiz :-P
00:24:01 <Twey> i.e. sure it may not offer any significant improvements over the existing system, but it looks *awesome*
00:24:01 <Berengal> Compiz is only almost-crazy
00:24:03 * p_l agrees with Twey 
00:24:14 * Berengal loves his bling WM
00:24:29 <Berengal> I can set fire to my screen if I want to!
00:24:31 * p_l consider Compiz "nothing much"
00:24:54 * Twey has a pathological hatred for wobbly windows
00:25:04 <Berengal> I love wobbly windows...
00:25:20 <Twey> I don't like to get motion-sickness whenever I move a window around :-P
00:25:26 <Berengal> When I'm on a machine without wobbly windows it feels like windows 2.0...
00:25:50 <Berengal> wobblyness adds substance, I feel
00:26:03 <Twey> Someone never used Windows 2.0. :-P
00:26:06 <Twey> But it doesn't
00:26:08 <johnw> what are wobby windows?
00:26:14 <Twey> And it makes it hard to position them, too
00:26:18 <beelsebob> wobbly windows is one of the things to me that indicate the linux guys just don't get the point
00:26:32 <beelsebob> compositing engines are not there to add useless distracting effects
00:26:35 <Twey> You have to wait for them to stop DAMN WELL WOBBLING ARGH before you can see where they're actually going to be when you set them down
00:26:37 <Adamant> Twey: Perligata Delenda Est!!!!!
00:26:38 <beelsebob> they're there to let you do useful stuff
00:26:58 <Berengal> Twey: I use a grid for positioning. I should almost be running a tiling WM, but I'm just not quite there yet
00:27:35 <Twey> Adamant: Congruo :-P
00:27:42 <Twey> Berengal: I'm there :)
00:27:42 <Adamant> beelsebob: like what, besides transparency?
00:27:56 <beelsebob> Adamant: expose is a really good start
00:28:00 <Twey> Like live window previews
00:28:07 <beelsebob> and that too, yeh
00:28:13 <Twey> And advanced window placement
00:28:17 <Twey> Seen Metisse?
00:28:23 <ksf> I'd like some compiz-like stuff for xmonad, though. like smooth fading, probably sliding screens, and of course screen and window switchers with preview
00:28:23 <Adamant> beelsebob: I just use Spaces
00:28:31 <Adamant> Twey: Metisse?
00:28:42 <beelsebob> Adamant: another thing that uses compositing to show you the previews in a nice useful way
00:28:50 <Twey> Adamant: http://insitu.lri.fr/metisse/
00:29:10 <Twey> It lets you do things like peel corners of windows back to see what's underneath
00:29:16 <Berengal> Advanced window switchers are really nice
00:29:23 <Twey> Or make palettes out of sections of existing windows
00:29:33 <Berengal> Much better than just icons
00:30:23 <Twey> Adamant: http://insitu.lri.fr/metisse/facades/uifacades.gif
00:30:26 <p_l> Twey: Like LookingGlass? it let you place windows in 3 dimensions, rotate them, even make notes on the backs...
00:30:54 <Twey> p_l: Better
00:30:56 <p_l> And it worked before Compiz got announced
00:30:59 <Twey> Yeah
00:31:05 <Twey> It's not 3D, exactly
00:31:15 <Twey> It just lets you do loads more stuff with the windows
00:31:31 <bnijk_> oh sweet
00:31:34 <Twey> It's the same idea as 3D, but lighter on the eye-candy, and more useful, I think
00:31:36 <bnijk_> metisse is in the AUR :)
00:31:39 <Twey> Er, as LG3D
00:31:49 <Twey> I wonder if it works on x86_64 yet
00:32:08 * p_l doesn't use Desktop Metaphor at all and doubts he can make use of 3D windows
00:33:03 * bnijk_ installs it
00:33:18 <bnijk_> you doubt you can make use of 3d windows?
00:33:21 <bnijk_> well you're lacking in imagination!
00:33:48 <Twey> Heh
00:34:01 <ksf> 3d visualisation is overrated.
00:34:15 <Adamant> ksf: for desktops yes
00:34:22 <bnijk_> it's nice to have
00:34:25 <Adamant> for actual visualization
00:34:26 <bnijk_> not that great to use really
00:34:28 <Adamant> I'm not so sure
00:34:38 <beelsebob> I've met a lot of people claiming that people who don't see how 3D desktops would work lack imagination
00:34:40 <bnijk_> fun though
00:34:50 <bnijk_> i have xmonad anyway
00:34:51 <beelsebob> but I've not actually seen anyone produce a 3D desktop that does more than a 2D one
00:34:53 <bnijk_> it's nice and efficient
00:35:37 <Wraithan> Same I ahven'
00:35:56 <p_l> heh, I need every pixel to be useful for information, not fancy transformations on windows. If I want eye-candy, I'll add talking mascot controlled by AI to inform me of various events :D
00:35:56 <ksf> Visualising, I usually don't use a third spatial dimension. If there's more than two, they aren't space dimensions, or rather linked than displayed.
00:35:57 <Wraithan> Haven't seen any features of a 3d desktop that wouldn't slow things down compared to the 3d versions
00:36:08 <Adamant> some of them do
00:36:25 * vixey thinks 'garbage file'
00:36:26 <Wraithan> That wouldn't do more than slow things down...
00:36:36 <Adamant> like, that one that uses an actual desk metaphor
00:36:43 <Wraithan> I know how to articulate myself, I swear
00:37:12 <Adamant> it doesn't do things you can't do in 2D, but it makes it more intuitive and appealing
00:37:15 <beelsebob> p_l: I find it odd that people see "fancy transformations" not as info
00:37:38 <beelsebob> people keep calling OS X out on this, claiming it's all eye candy, and missing the fact that it's actually giving a considerable amount of info
00:37:49 <beelsebob> the dock minimisation effect shows you where the window went
00:37:53 <Twey> Adamant: The idea in that case was to ease operation using a pen
00:37:58 <Twey> It's called BumpTop
00:37:58 <beelsebob> expose shows you all your windows easily
00:38:07 <Berengal> beelsebob: I agree with you there. There are lots of window effects that give info on the status of the window
00:38:20 * vixey thinks windows and linux have both implemented expose now
00:38:24 <Berengal> Or the entire desktop
00:38:33 <Axman6> i have access tp the BumpTop beta
00:38:42 <p_l> beelsebob: if said "fancy transformations" are used as additional channel of information, sure thing - although I don't like the minimalization effects, expose or fade out are quite good things
00:38:46 <Axman6> vixey: not very well
00:38:54 <Twey> The idea is that rather than requiring all the features of a real machine, you can implement a whole desktop that uses an intuitive interface accessible just by shoving things around and making gestures
00:38:59 <p_l> the thing is, I found that I don't need any of them with XMonad :)
00:39:19 <beelsebob> p_l: true
00:39:28 <beelsebob> but that doesn't mean that they're not giving you info
00:39:34 <beelsebob> it's just giving you info in a different way
00:39:51 <Qork> Cale: what programs are you actually interested in writing?
00:40:43 <p_l> beelsebob: As I said, what I classify as "fancy transformations" is stuff like wobbly windows, rotating windows, flame, cube etc
00:40:55 <p_l> (well, cube has some usage)
00:41:05 <beelsebob> p_l: well yeh, but that's not an accurate term
00:41:16 <beelsebob> an accurate term would be "superfluous fancy effects"
00:41:27 <beelsebob> you can be a fancy effect without being superfluous
00:41:36 <bnijk_> who else likes xmonad ;)
00:41:47 <Berengal> I don't feel like wobbly windows are superfluous
00:41:48 <vixey> don't know how you can repeatedly spell 'yeah' as 'yeh' and call someone else out on accuracy..
00:42:11 <Axman6> Berengal: what do they add to the interface?
00:42:14 <Berengal> Sure, I can do without, but I do feel it adds substrance, like raised buttons that are visibly pressed when you press them
00:42:15 <beelsebob> Berengal: what extra info do they give you?
00:42:40 <p_l> bnijk_: count me in :D
00:43:14 <Berengal> Wobbly windows tell me the speed and direction of the movement
00:43:36 <beelsebob> and your hand on your mouse doesn't tell you that already?
00:43:48 <Berengal> beelsebob: It's not a very good visual aid, no
00:43:59 <beelsebob> my main complaint against wobbly windows is actually that they *take away* info I had previously
00:44:01 <Wraithan> wait, you move windows with a mouse?
00:44:08 <beelsebob> I can no longer tell accurately where I'm putting the window
00:44:14 <beelsebob> because it's wobbling around like jelly
00:44:24 <p_l> Wraithan: I heard that it's a common practice, these days
00:44:34 * ksf would be surprised if Berengal is capable of locating his own nose in the dark
00:44:34 <Wraithan> p_l: xmonad ftw.
00:44:41 <Twey> I already mentioned that one, beelsebob
00:44:44 <Wraithan> Even on windows I don't move my windows around with a mouse
00:44:47 <Wraithan> GridMove
00:44:58 <Berengal> beelsebob: I've got snapping windows as well
00:45:12 <beelsebob> Berengal: that's not the same as just being able to know where a window is going to go
00:45:12 <Berengal> And usually when I move a window it's not to put it somewhere but to remove it from somewhere
00:45:22 * bnijk_ is compiling metisse
00:45:23 <Berengal> If I want to put it somewhere I use the grid
00:45:29 <beelsebob> I mean... one of the *big* advantages you got from compositing engines was that you could see live where the contents of the window would go
00:45:30 <bnijk_> this had better be sweet
00:45:33 <beelsebob> not just where the window is
00:45:45 <beelsebob> but wobbly windows defeats that
00:46:14 <Wraithan> The only time I still use my mouse to move windows is when I get a new app and I am not sure where I want it to live.
00:46:45 <Berengal> beelsebob: I should perhaps also mention I've got the wobblyness turned down a bit
00:47:02 <beelsebob> that's another thing I don't get – an insistance that the keyboard is better than the mouse, but probably a discussion that's not worth getting into now
00:47:14 <Twey> Oh, and that's another thing
00:47:34 <ksf> it depends on what you're using at the moment.
00:47:34 <Twey> When it's wobbling around and the WM decides to snap it to something
00:47:59 <Twey> But the snapping is always based on its final position, which means there's not necessarily any visual indicator of why it snapped
00:48:09 <ksf> while coding, grabbing the mouse is way too slow. while browsing, reaching for the keyboard sucks.
00:48:12 <beelsebob> Twey: indeed, I've often found that very confusing
00:48:18 <p_l> beelsebob: less brainwork in case of keyboard, and possibly better hci metaphor
00:48:20 <Twey> ksf: You need to use Conkeror more :)
00:48:28 <beelsebob> ksf: while coding, I've found the mouse to be *way* faster than the keyboard for a lot of stuff
00:48:39 <Berengal> I often have one hand on the keyboard and one on the mouse
00:48:39 <beelsebob> when I'm coding, I'm spending a lot of time thinking, and very little time typing
00:48:42 <Twey> Mice truly are slow and uncomfortable to use
00:48:46 <beelsebob> so the mouse has ponalty
00:48:51 <beelsebob> penalty*
00:49:01 <Twey> The worst possible operation is a mouse drag
00:49:06 <beelsebob> Berengal: yeh, I'm usually in that situation too
00:49:12 <beelsebob> Twey: how is that?
00:49:13 <Twey> They take so much effort that often I don't even bother
00:49:28 <Twey> The position is incredibly awkward, and it tends to run the mouse off the edge of the desk
00:49:35 <Twey> Or outside my reachable area
00:49:37 <beelsebob> sounds like you just have a bad mouse
00:49:46 <Berengal> Twey: I agree with you there. Right hand on mouse, left hand on ctrl+{a,x,c,v}
00:49:47 <Twey> I have a very good mouse, actually
00:49:49 <ksf> to put it more precisely, switching to another shell has to be faster than typing :wq, and probably cd.
00:49:58 <Twey> IT's a Logitech G5
00:50:04 <beelsebob> tbf though, I actually find *mice* the worst pointing devices I could use
00:50:12 <Twey> I paid extortionate amounts for it when I was in an optimistic phase
00:50:14 <beelsebob> Graphics Tablet > Track Pad > Track Ball > mouse
00:50:22 <ksf> COPY AND PASTE IS MEANT TO BE DONE WITH THE MIDDLE MOUSE BUTTON
00:50:26 <Twey> A trackball is something I've been thinking about getting
00:50:50 <Twey> Trackpads are different to mice
00:50:52 <Berengal> ksf: No way, that's where the wheel is. The wheel is the worst possible button ever
00:50:56 <Twey> They're better for some things, and worse for others
00:51:04 <beelsebob> not sure about that
00:51:08 <beelsebob> depends on the track pad
00:51:17 <beelsebob> if apple made both hardware and drivers the track pad is way better than the mouse
00:51:22 <beelsebob> if not, the mouse is way better
00:51:24 <Twey> beelsebob: You ever tried dragging with a trackpad?  You have to use both hands
00:51:31 <beelsebob> Twey: not on an apple one
00:51:36 <Twey> Why's that?
00:51:37 <Berengal> I'm no fan of trackpads. I've used mice and pads about equally much the last few years and find mice superior in almost every context
00:51:39 <opqdonut> i like nipple mice
00:51:42 <beelsebob> double tap, and start dragging on the second tap Twey
00:51:52 <beelsebob> it then drags until you tap
00:51:56 <Berengal> pads are nice for when you need to switch to and from the keyboard alot
00:52:03 <johnw> is there a compiz addon that lets me "push away" a window?  For example, I'd like to hold shift and mouse up, and have it get smaller and smaller, as though it were receeding into the distance
00:52:04 <Twey> beelsebob: I see
00:52:06 <p_l> opqdonut: you mean trackpoint? ;D
00:52:10 <Twey> That sounds OK
00:52:22 <opqdonut> p_l: yeah (cue xkcd et al)
00:52:23 <Twey> What about scroll-wheel?
00:52:36 <beelsebob> Twey: two fingers on the track pad and drag
00:52:41 <Twey> opqdonut: *shudder* Clitmice are horrible
00:52:43 <beelsebob> I find that *way* better than any wheel
00:52:48 <Twey> So hard to position the cursor properly
00:52:50 <opqdonut> Twey: sorry, you
00:52:55 <opqdonut> 're wrong :)
00:53:06 <opqdonut> (damn keyboard and it's over-sensitive return ;)
00:53:07 <Berengal> Twey: I find them about as good as pads
00:53:09 <Twey> I mean, I like the positioning
00:53:28 <Twey> But you can never get them onto the right place on the first go
00:53:43 <opqdonut> Twey: it's perfect, you don't need to move your hands from typing position
00:53:46 <Twey> beelsebob: Sounds like it would be kind of prone to accidental activation
00:53:54 <beelsebob> Twey: yeh, clit mice suck massively for that
00:53:55 <Berengal> Is there something like a keyboard with a trackball just right of the return?
00:53:57 <Twey> (my issue with the whole edge-as-scrollbar thing)
00:54:02 <opqdonut> just move forefigner to the nipple and drop the thumb from the spacebar to the buttons
00:54:08 <bnijk_> twist it a little
00:54:09 <beelsebob> Twey: no, it's much less accident prone than the edge thing
00:54:13 <bnijk_> suck on it
00:54:15 <opqdonut> i have no problem with the positioning myself
00:54:17 <bnijk_> she'll like that
00:54:19 <beelsebob> I don't think I've ever activated it accidentally
00:54:42 <beelsebob> note Twey - it must be two distinct locations you fingers are at – one large blob doesn't work
00:54:59 <Twey> beelsebob: Doesn't that limit your range a bit?
00:55:11 <Twey> I guess it's OK for vertical scrolling
00:55:23 * Twey is experimenting with his touchpad
00:55:23 <beelsebob> for horizontal scrolling you put the fingers one above the other
00:55:32 <Twey> That's a really awkward position
00:55:38 <Twey> I have to move my whole arm
00:55:40 <beelsebob> but... bear in mind, apple track pads usually have 3-4 times the area of other ones
00:55:50 <Twey> Ah, cool
00:55:58 <beelsebob> in fact, the new ones probably more like 5-6
00:57:17 <Berengal> Heh, just noticed compiz has a plugin called "maximumize"
00:57:24 <p_l> ... good thing I'm not going to buy an apple... I'd run mad from all the accidential trackpad action
00:57:37 <Berengal> It "maximumizes" windows in various ways :P
00:58:13 <beelsebob> p_l: except that the OS has a ticky box for ignoring accidental track pad action
00:58:14 <beelsebob> ;)
00:58:39 <beelsebob> (roughly defined I think as touches in the upper corners while you're typing, but I'm not certain of the exact algorithm)
00:58:41 <p_l> beelsebob: Well, the OS would be the first thing to get kicked out, so it's moot point
00:58:49 <beelsebob> p_l: heh
00:59:03 <p_l> beelsebob: Also, I usually tended to hit all over the place :)
00:59:27 <beelsebob> I've never had an issue with accidental clicks on this one, but *shrug* we're all different
00:59:46 <Adamant> p_l: I actually have less trackpad problems on Macs when compared to PC's
00:59:51 <Adamant> with regards to accidental use
01:00:14 <Adamant> part of it is that there are nice big areas to rest your wrists on
01:00:22 <Adamant> at least on the MBP
01:00:37 <beelsebob> yeh, on all macs, but I'm not certain I know of PCs that dont have that
01:00:52 <Adamant> beelsebob: it was bad on my Dell
01:00:59 <Adamant> but it was a subnotebook dell
01:01:05 <beelsebob> ah, yeh
01:01:29 <beelsebob> I actually hate the miniature trackpads on netbooks more than I hate the miniature keyboards
01:02:27 <opqdonut> nipples don't take up any room :)
01:02:39 <beelsebob> yes, but they also fail at actually being possible to use
01:02:45 <Gracenotes> .
01:03:47 * p_l has nearly zero problems with his trackpoint
01:07:19 <Axman6> opqdonut: plus, you do get to say you have a clit mouse, so, it all balances out :P
01:08:40 <Twey> Haha
01:13:18 --- mode: ChanServ set -o dcoutts_
01:13:55 <BMeph> dcoutts: Is there a more recent tut for getting GTK2HS to run with 10.2? :)
01:14:11 <ivanm> BMeph: works here...
01:14:46 <Adamant> beelsebob: not even netbook-size
01:14:49 <Adamant> it was bigger
01:14:57 <BMeph> ivanm: Fine, mail you computer to San Diego, so I can see some vacuum stuff again... ;p
01:15:08 <ivanm> except for building docs...
01:15:14 <ivanm> I've built gtk2hs here
01:15:38 <Adamant> netbooks would be aggravating, but the biggest annoyance was the side buttons on the mice
01:15:44 <Adamant> err, trackpads
01:15:49 <Adamant> that was intolerable
01:16:00 <Adamant> on netbooks
01:23:33 <bljnik_> hey what was my username like, five minutes ago
01:23:36 <bljnik_> it looked like this one
01:23:44 <bljnik_> at about 4:00 EST i left
01:23:54 <bljnik_> and we were talking about window managers earlier...
01:25:37 <bljnik_> i just registered it, and i can't start evolution cause i'm not in X yet
01:26:24 <vixey> bljnik_: there's a link to IRC logs in topic
01:28:13 <bljnik_> much better
01:34:29 <Qork> haskell doesn't have tests and thus will DIIIIEEE!?
01:34:48 <Qork> everyone here verifies all their code in Coq right ?
01:35:11 <vixey> Qork do you
01:36:29 * p_l grabs first spotted TDD advocate and hangs him in legitimate reprisal
01:36:53 <Qork> vixey: ofc
01:37:07 <vixey> Qork -- do you have any examples online please?
01:37:53 <Qork> even when I write a script to pull some RSS feeds just one time
01:38:06 <Qork> i dont write haskell, i do recursive extraction in Coq
01:38:15 <Qork> and last week i killed a lion with my bare hands
01:38:39 <vixey> Qork, oh fuck you
01:38:50 <vixey> Qork, Can you stop changing nick it's impossible to /ignore you
01:39:10 <vixey> I wish #haskell would ban you like #lisp did
01:39:41 <vixey> Qork, could you do me a favour and just pick one nick and stick with it
01:39:51 <p_l> hmm? he got banned from #lisp?
01:40:13 <vixey> p_l: yeah it's because he's just talks crap and leeches/help vampires all the time
01:40:25 <vixey> #haskell is really friendly so he's not bannd but such a pest
01:42:25 <Gracenotes> don't worry, interesting people get their own quote commands one day
01:43:11 <FunctorSalad> btw haskell does have tests ;o
01:43:38 <Qork> can't we ban vixey she is so caring about things that doesn't matter
01:44:30 <vixey> Qork, please try to talk less bullshit basically is what I'm asking - go to #haskell-blah if you want to bicker
01:45:03 <vixey> Qork, (I don't think I'm being unfair but I do think I probably shouldn't have brought this up in the main channel)
01:45:20 <FunctorSalad> I guess Qork was making fun of that martin talk about smalltalk
01:46:53 <Gracenotes> heh. I just realized that the ambient forest sounds in the movie I was watching actually weren't in the movie, but outside my window
01:46:54 <Berengal> s/tests/types and it would've been more relevant to haskell
01:47:06 <Gracenotes> er </aside>
01:47:16 * Qork generally thinks people who don't get irony are a bit weird
01:47:56 <Gracenotes> I think people who like it are weird...
01:59:11 * ksf hands vixey a teddy to cuddle and Qork a pacifier to shut up
02:00:40 <solidsnack> That was really off color.
02:00:53 <solidsnack> That's not something we see on here very often.
02:01:57 <ksf> we don't see 4k of text about compiz here every day, either. deal with it.
02:03:05 <solidsnack> "deal with it" ?
02:03:51 <ksf> as in "even more annoying than annoying people are people annoying with talking about being annoyed"
02:03:53 <vixey> ksf, lol
02:05:06 <dobblego> come on guys put it to rest
02:05:29 <solidsnack> ksf: I'll get you next time.
02:17:44 <ivanm> I seem to recall a 3D-ish lambda associated with Haskell somewhere... anyone know where I can find it?
02:18:00 <ivanm> (it doesn't have to be related to Haskell, I just want a fancy looking lambda ;-)
02:20:19 <Twey> A 3D lambda?
02:20:25 <Twey> What's one of those when it's at home?
02:20:37 <Kvasir> hey Twey
02:20:43 <Twey> Oh hello :)
02:21:31 <ivanm> Twey: a lambda picture that looks 3D, silly
02:22:43 <Twey> Oh of course.
02:22:46 <Twey> I should have guessed.  :-P
02:24:10 <QtPlaty[HireMe]> ivanm: The symbol or the concept.
02:24:20 <ivanm> symbol
02:26:55 <monadic_kid> talking about the lambdacube?
02:28:39 <monadic_kid> http://www.rbjones.com/rbjpub/logic/cl/tlc001.htm
02:29:15 <monadic_kid> ivanm: is that what you meant?
02:35:20 <ivanm> monadic_kid: no, the lowercase lambda letter with 3D highlights, etc.
02:36:02 <ivanm> something like the lambda here: http://logo.cafepress.com/nocache/1/72791.jpg
02:37:11 <monadic_kid> okay :P
02:39:58 <Berengal> googling I found this: http://www.cs.uni.edu/~wallingf/blog-images/misc/lambda-man.jpg
02:40:05 <Berengal> (Wadler as lambda-man
02:40:07 <Berengal> )
02:40:21 <monadic_kid> heh
02:43:58 <tibbe> how do I define `lift m` in MonadTrans for a CPS implementation of the State monad?
02:47:29 <Twey> > [1, 2, 3] `flip elem` 1
02:47:30 <lambdabot>   <no location info>: parse error on input `elem'
02:47:39 <Twey> See, that seems weird to me
02:47:46 <Twey> We should be able to backtick arbitrary expressions
02:47:59 <Twey> After all, we can bracket them
02:48:02 <Berengal> `(+)`?
02:48:21 <Berengal> Bracketed expressions are different from bracketed operators
02:48:32 <dolio> foo `bar `baz` quux` quux
02:48:37 <controll> hi
02:48:53 <Berengal> Hello
02:48:55 <controll> anyone using gentoo? GHL wont install
02:49:38 <wh1t3> GHL?
02:50:07 <ivanm> controll: see #gentoo-haskell
02:50:09 <controll> the compiler
02:50:13 <wh1t3> do you mean GHC, or is there something called GHL I don't know about
02:50:33 <ivanm> controll: we have a dedicated channel in #gentoo-haskell
02:50:41 <controll> exactly ghc
02:50:43 <controll> ok
02:51:20 <f4hy> There must be a better way to do what I am trying to do. I want to find the index of the minimum value of a list of floats.
02:51:48 <Asztal> ?type elemIndex =<< minimum
02:51:49 <lambdabot> forall a. (Ord a) => [a] -> Maybe Int
02:52:50 <Asztal> returns Nothing if the list was empty, too, even though minimum errors in that case :)
02:53:12 <monadic_kid> it seems like ArchLinux is the best for haskell dev?
02:53:29 <monadic_kid> soo many supported packages for it
02:53:35 <f4hy> ay ok, now I have to figure out what =<< becuase wow did that work
02:53:48 <f4hy> :t (=<<)
02:53:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:53:49 <monadic_kid> f4hy: it's >>= but args reversed
02:54:09 <f4hy> :t (>>=)
02:54:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:54:33 <Asztal> :t (=<< minimum)
02:54:34 <lambdabot> forall b a. (Ord a) => (a -> [a] -> b) -> [a] -> b
02:55:59 <f4hy> Ya, I am confused, but thanks. Is there a name for the (>>=) operator?
02:56:00 <Berengal> Haha, oh, this is priceless: Someone posted to the cafe "Why doesn't Just 3 >>= (1+) work?" There's now sixteen replies all explaining the type error
02:56:34 <dolio> Yeah. A bit overboard.
02:57:35 <Berengal> 15 replies within 3 hours, then some guy going "wow, many replies"
02:58:10 <ivanm> Berengal: so why doesn't it? :p
02:58:35 <Berengal> ivanm: Apparantly because Maybe b isn't an instance of Num :P
02:59:06 <ivanm> I thought it was because (1+) doesn't return a monad... >_>
03:00:03 <Berengal> Well, there's several type errors in that expression, depending on how you try to unify them
03:00:05 <dolio> Yeah, but if Maybe b were an instance of Num, that could become "Just (Just 3) >>= (Just 1 +)".
03:03:50 <monadic_kid> couldn't use an applicative to achieve that?
03:04:10 <Berengal> Strangely enough, I don't think anyone suggested <$>
03:04:22 <Berengal> liftM and fmap, sure enough, but not <$>
03:04:47 <monadic_kid> > (1 + ) <$> Just 3
03:04:49 <lambdabot>   Just 4
03:04:57 <ksf> I suggested that, here.
03:05:05 <Berengal> > pure (+1) <*> Just 3
03:05:06 <lambdabot>       Ambiguous occurrence `pure'
03:05:06 <lambdabot>      It could refer to either `Control.Appl...
03:05:14 <Berengal> Meh
03:05:26 <ksf> didn't want to add to the cafe's avalanche.
03:09:07 <houeland> I'm writing a program using Network.HTTP and Network.Curl that sometimes suddenly dies without raising an exception, how can I figure out what's going on?
03:09:09 <f4hy> > fromJust Maybe 4
03:09:10 <lambdabot>   Not in scope: data constructor `Maybe'
03:09:26 <f4hy> > fromJust Just 4
03:09:27 <lambdabot>   Couldn't match expected type `Maybe a'
03:09:48 <ksf> houeland, Debug.Trace?
03:10:20 <fabjan_> > fromJust (Just 4)
03:10:22 <lambdabot>   4
03:10:38 <ksf> also, check whether ghc -O0, ghc -O2 and ghci yield the same results.
03:11:00 <ksf> ...while you're at it, also try -via-C
03:11:14 <f4hy> Ya, I really dont get this monad buisness yet
03:11:55 <ksf> Maybe may be a monad, but fromJust $ Just 4 doesn't involve a monad.
03:12:18 <houeland> I found that it reaches a point right before I close a handle and stops before printing anything after that, and stops somewhere else if I don't manually close the handle
03:12:48 <ksf> instance Maybe Monad Maybe where ...
03:12:49 <f4hy> Since I dont understand what I am doing.. is it ok to have a function that is: fromJust $ elemIndex <<= minimum
03:13:08 <f4hy> wait i mean =<<
03:13:35 <ksf> looks like messed up precedence, and an error if minimum isn't monadic.
03:13:48 <ksf> what's minimum's type?
03:13:53 <fabjan_> f4hy: the reason your fromJust didn't work is simply because of the associativity of function application.
03:14:15 <f4hy> fabjan_: I figured that out
03:14:28 <f4hy> elemIndex returns a Maybe
03:14:42 <ksf> :t elemIndex
03:14:43 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
03:14:58 <ksf> > elemIndex 10 [1..]
03:14:59 <lambdabot>   Just 9
03:15:06 <ksf> > fromJust $ elemIndex 10 [1..]
03:15:07 <lambdabot>   9
03:15:24 <f4hy> Why doesnt it just give me 9 in the first place?
03:15:34 <ksf> > fromJust $ elemIndex 10 [1..2]
03:15:35 <lambdabot>   * Exception: Maybe.fromJust: Nothing
03:15:39 <ksf> that's why.
03:15:42 <sohum> what does "Irrefutable pattern failed for pattern (fs, l : ls)" mean?
03:15:43 <ksf> > elemIndex 10 [1..2]
03:15:44 <lambdabot>   Nothing
03:15:55 <Twey> f4hy: fromJust isn't monadic...
03:16:06 <ksf> sohum, l was [].
03:16:25 <f4hy> Twey: If one has no idea what a monad it, it becomes impossible to recognize one ;-)
03:16:30 <Twey> Heh
03:16:32 <sohum> ksf: that's not possible, I'm running it on an infinite list
03:16:42 <Twey> A monad is something implementing >>= and return :)
03:17:02 <mercury^> sohum: either it's not a tuple or the second entry is not a cons
03:17:11 <Twey> You can recognise them by those functions, or a bunch of utility functions ending in M
03:17:18 <Twey> (liftM, mapM, ...)
03:17:44 <ksf> > (\(x, y) -> 1) 2
03:17:45 <lambdabot>       No instance for (Num (t, t1))
03:17:45 <lambdabot>        arising from the literal `2' at <i...
03:17:54 <f4hy> Well fromJust $ elemIndex =<< minimum is the thing I am dealing with. and (=<<) is some magic that I don't understand
03:17:58 <ksf> > (\(x, y) -> () ) ()
03:17:59 <lambdabot>   Couldn't match expected type `(t, t1)' against inferred type `()'
03:18:07 <ksf> sohum, nope, must have been the list.
03:18:31 <ksf> :t (=<<)
03:18:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:18:59 <Twey> f4hy: =<< is just >>= backwards
03:19:15 <f4hy> magic backwards is still magic
03:19:34 <Twey> In the list, x >>= f = map f x
03:19:59 <Twey> Or, wait
03:20:00 <ksf> f4hy, I don't think you want to use =<<, at all.
03:20:02 <Twey> Isn't it concatMap?
03:20:06 <ksf> it's concatMap
03:20:21 <Twey> :t elemIndex
03:20:22 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
03:20:23 <f4hy> ksf: I dont, but how do i get the index of the minimum of a list without it?
03:20:29 <ksf> otherwise you wouldn't have join included, which is concat.
03:20:33 <Twey> f4hy: minimum list
03:20:42 <Twey> ksf: *nods*
03:20:45 <sohum> ksf: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2385#a2385
03:20:47 <f4hy> Twey: the index of said list
03:20:54 <Twey> f4hy: The index of what?
03:20:55 <sohum> mercury^: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2385#a2385
03:21:09 <f4hy> [0.1,0.5,0.001,0.4] I want to get 3
03:21:14 <f4hy> or 2 rather
03:21:17 <Twey> f4hy: The minimum of a list and the index of a specific element in a list are two completely different things
03:21:20 <f4hy> the location of the minimum
03:21:23 <Twey> Why 2?
03:21:23 <Twey> Aha
03:21:27 <Twey> Then you'd want:
03:21:43 <f4hy> Well elemIndex =<< minimum  does exactly that
03:21:55 <Twey> > let lst = [0.1, 0.5, 0.001, 0.4] in elemIndex (minimum lst) lst
03:21:56 <lambdabot>   Just 2
03:21:59 <sohum> ksf, mercury^: oh, wait a sec
03:22:09 <ksf> > let foo l = elemIndex (minimum l) l in foo  [0.1, 0.5, 0.001, 0.4]
03:22:10 <lambdabot>   Just 2
03:22:12 <Twey> > let lst = [0.1, 0.5, 0.001, 0.4] in fromJust $ elemIndex (minimum lst) lst
03:22:13 <lambdabot>   2
03:22:20 <f4hy> > (elemIndex =<< minimum ) [0.1, 0.5, 0.001, 0.4]
03:22:22 <lambdabot>   Just 2
03:22:33 <mercury^> sohum: you know that first filtering the list saves you some work, right?
03:22:43 <Twey> f4hy: I think that's rather coincidental
03:22:58 <rwmjones> What do I do about: "Not in scope: `throwDyn'" ?
03:23:09 <sohum> mercury^: the filter function is expensive, so I'm cutting down on use of it
03:23:17 <Twey> rwmjones: import Control.Exception (throwDyn)
03:23:26 <sohum> mercury^: not in the example, but in findFirst
03:23:33 <rwmjones> so I need the parens there?  I'm already importing Control.Exception
03:23:43 <ksf> @pl let foo l = elemIndex (minimum l) l in foo  [0.1, 0.5, 0.001, 0.4]
03:23:43 <lambdabot> (elemIndex =<< minimum) [0 . 1, 0 . 5, 0 . 1, 0 . 4]
03:23:50 <ksf> bugger.
03:24:15 <ksf> but, see, pointless style is quite often obfuscated.
03:24:15 <rwmjones> Twey, now I get:     Module `Control.Exception' does not export `throwDyn'
03:24:33 <rwmjones> $ ghc --version
03:24:33 <rwmjones> The Glorious Glasgow Haskell Compilation System, version 6.10.1
03:25:01 <Twey> rwmjones: Oh, I'm sorry
03:25:04 <Twey> It's in Data.Typeable
03:25:32 <rwmjones> Twey, I'm already importing that one too ...
03:25:50 <longh> hi, is there any bindings generator (for C) which is actively developed or at least buildable
03:25:56 <mercury^> sohum: ah, findFirst assumes that the list is ordered with respect to the condition?
03:25:58 * ksf tries to wrap his head around the fact that f4hy came up with that code.
03:26:09 <sohum> mercury^: yep.
03:26:26 <ksf> :t minimum
03:26:27 <lambdabot> forall a. (Ord a) => [a] -> a
03:26:37 <Twey> rwmjones: I can't find it
03:26:38 <houeland> ksf: as far as I can tell they're all exactly the same, it quit out of ghci as well
03:26:41 <ksf> :t (elemIndex <<= minimum)
03:26:42 <lambdabot> Not in scope: `<<='
03:26:47 <ksf> :t (elemIndex =<< minimum)
03:26:48 <lambdabot> forall a. (Ord a) => [a] -> Maybe Int
03:26:50 <f4hy> ksf: I did not. I asked this channel on how to find the index of the minimum of a list, and it was given to me. Then I have been trying to decipher it, becuase I needed to know what to do with Just 9
03:27:05 <controll> which editor to use  with haskell?
03:27:10 <rwmjones> is there anything I can use instead of throwDyn?  I'm trying to implement #6 from http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
03:27:33 <Twey> controll: emacs
03:27:36 <fabjan_> > False < True
03:27:37 <lambdabot>   True
03:27:45 <f4hy> fabjan_: what!?
03:27:52 <ksf> > (elemIndex =<< minimum) []
03:27:53 <lambdabot>   Nothing
03:27:59 <ksf> > (elemIndex =<< minimum) [1,1]
03:28:00 <lambdabot>   Just 0
03:28:16 <Twey> o.@
03:28:18 <Twey> Ah
03:28:27 * Twey tries to figure this out
03:28:34 <f4hy> (elemIndex =<< minimum) [2,1,2,1]
03:28:36 <ksf> f4hy, promise me not to use fromJust if you aren't 110% sure you don't have an empty list.
03:28:45 <f4hy> > (elemIndex =<< minimum) [2,1,2,1]
03:28:46 <lambdabot>   Just 1
03:28:48 <ksf> > fromJust ((elemIndex =<< minimum) [1,1])
03:28:49 <lambdabot>   0
03:28:50 <Twey> OH
03:28:52 <ksf> > fromJust ((elemIndex =<< minimum) [])
03:28:53 <lambdabot>   * Exception: Maybe.fromJust: Nothing
03:28:59 <Twey> It's not the list monad, it's the function monad
03:29:04 <Twey> D'oh
03:29:23 <ksf> ...if in doubt, use parenthesis, $ can mess stuff up by being quite low-precedece.
03:29:33 <f4hy> ksf: it wouldnt have a minimum then would it
03:29:37 <mercury^> sohum: you call findFirst again on the first part of the list, which is finite. There the pattern is refuted eventually.
03:29:40 <f4hy> ksf: so I wouldnt want to find it
03:29:57 <Berengal> Twey: point-free + function monad = wtf
03:30:25 <Twey> Aye
03:30:35 <Berengal> @type minimum
03:30:36 <sohum> mercury^: aah, there we go. thankee
03:30:36 <lambdabot> forall a. (Ord a) => [a] -> a
03:30:40 <Berengal> > minimum []
03:30:41 <lambdabot>   * Exception: Prelude.minimum: empty list
03:30:45 <ksf> f4hy, and that's what Maybe can does for you: If minimum is Nothing, elemIndex won't be called.
03:30:45 <Twey> @src ((->) r) (>>=)
03:30:46 <lambdabot> Source not found. Where did you learn to type?
03:31:21 <Berengal> f >> g = \x -> g (f x) x
03:31:34 <f4hy> I understand why elemIndex needs to give Nothing, but it doesnt even matter because minium will fail on an empty list anyway. So I should be safe calling fromJust, becuase on an empty list minium will fail long before it gets to fromJust. right?
03:31:54 <mercury^> sohum: but that whole thing really only makes sense if the condition is *very* expensive to check.
03:31:59 <ksf> wtf, how does that work?
03:32:10 <Berengal> @src elemIndex
03:32:10 <lambdabot> elemIndex x     = findIndex (x==)
03:32:23 <Berengal> @src findIndex
03:32:23 <lambdabot> findIndex p     = listToMaybe . findIndices p
03:32:25 <f4hy> wait, there is a findIndex?
03:32:41 <f4hy> @src findIndicies
03:32:41 <ksf> > elemIndex undefined []
03:32:41 <lambdabot> Source not found. There are some things that I just don't know.
03:32:42 <Berengal> f4hy: My guess is elemIndex ignores x if the the list is empty
03:32:43 <lambdabot>   Nothing
03:32:43 <sohum> mercury^: the condition is about O(n), and furthermore doesn't change for large sections of the list
03:32:46 <ksf> that's why.
03:32:59 <ksf> elemIndex is lazy in its second argument.
03:33:06 <ksf> *first
03:33:06 <f4hy> @src findIndices
03:33:07 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
03:33:13 <houeland> ksf: anything else I can try?
03:33:30 <f4hy> ksf: ahh ok
03:33:35 <Berengal> f4hy: And if you think about it, the index of any element in an empty list must be Nothing
03:33:41 <Berengal> Even if the element is undefined
03:33:57 <Qork> are there any women programming haskell?
03:34:07 <ksf> houeland, tracking down the issue with Debug.Trace, doing a minimal test case, and filing a bug?
03:34:34 <ksf> @src elemIndex
03:34:35 <lambdabot> elemIndex x     = findIndex (x==)
03:34:43 <sohum> mercury^: ...ok, now I have non-exhaustive patterns. even though I have an otherwise. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2385#a2386
03:34:43 <f4hy> Alright. Thanks everyone.
03:34:45 <ksf> @src listToMaybe
03:34:45 <lambdabot> listToMaybe []        =  Nothing
03:34:45 <lambdabot> listToMaybe (a:_)     =  Just a
03:35:36 <ksf> sohum, x can be []
03:36:07 <sohum> ksf: oooh, nonexhaustive /there/
03:36:50 <jbjohns> @type ***
03:36:51 <lambdabot> parse error on input `***'
03:36:59 <jbjohns> > :t ***
03:37:00 <lambdabot>   <no location info>: parse error on input `:'
03:37:00 <ksf> I guess it's helper split fn [] = helper (2 * split) fn (tail ls)
03:37:45 <houeland> ksf: How do I track down the underlying issue based on hClose stopping the program? It also depends on both the responses received through curl and the incoming socket traffic, but I could try to simplify it a bit
03:38:20 <ksf> hClose shouldn't kill the program.
03:39:03 <sohum> ksf: yea. a quick hack that works is to make it fn ls at the end, but there's a better way to do it as that checks (head ls) twice
03:39:10 <houeland> well yeah, should I just report that, and try to find a deterministic test case to trigger it?
03:39:22 <ksf> sohum, also try -Wall .
03:39:36 <sohum> ksf: ooh shiny
03:41:15 <ksf> houeland, the only thing I know is that I don't think _I_ could track such a thing down if it's got something to do with the RTS.
03:48:01 <rwmjones> any FFI experts around?
03:48:04 <rwmjones> I have this function:
03:48:05 <rwmjones> foreign import ccall unsafe \"guestfs_last_error\" c_last_error
03:48:05 <rwmjones>   :: GuestfsP -> IO CString
03:48:15 <rwmjones> which could return nullPtr by the way
03:48:26 <rwmjones> I want to wrap it to make a 'nice' Haskell function
03:48:40 <rwmjones> something like this
03:48:42 <rwmjones> last_error :: GuestfsH -> IO String
03:48:42 <rwmjones> last_error h =
03:48:42 <rwmjones>   peekCString (withForeignPtr h (\\p -> c_last_error p))
03:48:45 <rwmjones> which doesn't actually work
03:49:08 <rwmjones> it's the returning part which doesn't work
03:49:14 <ksf> you need something like withCString
03:49:39 <ksf> forget what I said.
03:49:41 <rwmjones> I thought withCString was for converting arguments
03:49:58 <ksf> ...just bleeding use c2hs.
03:50:17 <rwmjones> what is c2hs?  I'm following these instructions which don't mention it:
03:50:29 <rwmjones> http://www.haskell.org/haskellwiki/FFI_Introduction
03:50:43 <ksf> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/c2hs-0.16.0
03:52:22 <ksf> you want last_error :: GuestfsH -> IO (Maybe String), btw.
03:56:01 <daxhuiberts> I'm reading learn you a haskell, but there's this one part I don't understand:
03:56:12 <daxhuiberts> "One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!"
03:56:28 <daxhuiberts> Can someone explain how that holds up?
03:56:32 <mreh> that's wrong
03:56:48 <daxhuiberts> alright
03:56:57 <mreh> hang on... let me think
03:57:17 <ksf> foldr works by replacing : with your function, and it terminates because it doesn't replace anything you don't force.
03:57:56 <ksf> foldr doesn't mean fold from right, but that the start value is on the right of the term.
03:58:02 <mreh> yes
03:58:36 <mreh> learn the definition of foldr and foldl if you want to understand them intuitively
03:58:53 <ksf> ...which, in scheme, means fold from right, but haskell doesn't imply that, at all, as it isn't call-by-value.
03:59:01 <rwmjones> c2hs isn't available here and I can't compile it & the dependencies either ... any idea how to define this function?
03:59:45 <mreh> you cant fold an infinite list anyway
03:59:49 <dolio> It's right-associated, too.
03:59:57 <ksf> well, that's true.
04:00:16 <Berengal> mreh: Sure you can. You just can't fold an entire infinite list
04:00:21 <f4hy> Success! I have finished my project!
04:00:23 <ksf> it works in constant space, though.
04:00:32 <dolio> foldr f z [1,2,3] = 1 `f` (2 `f` (3 `f` z)), foldl f z [1,2,3] = ((z `f` 1) `f` 2) `f` 3
04:00:36 <ksf> ...even with terabyte-lists.
04:01:02 <ksf> > foldr f d [x, y, z,]
04:01:03 <lambdabot>   <no location info>: parse error on input `]'
04:01:06 <ksf> > foldr f d [x, y, z]
04:01:07 <lambdabot>   f x (f y (f z d))
04:01:11 <ksf> > foldl f d [x, y, z]
04:01:12 <lambdabot>   f (f (f d x) y) z
04:01:15 <ksf> > foldl' f d [x, y, z]
04:01:16 <lambdabot>   f (f (f d x) y) z
04:01:49 <dolio> > foldl (+) z [a,b,c]
04:01:51 <lambdabot>   z + a + b + c
04:01:58 <dolio> Hmm, that didn't work well.
04:02:16 <ksf> foldl (:) z [a,b,c]
04:02:20 <ksf> > foldl (:) z [a,b,c]
04:02:21 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
04:02:21 <lambdabot>        Expect...
04:02:30 <mreh> if you can only partially evaluate the fold of an infinite list, what good is that?
04:02:55 <ksf> catamorphisms of infinite data are undefined.
04:03:04 <ksf> er, bottom.
04:03:37 <Berengal> mreh: Well, it means you can map it, for one thing...
04:03:38 <Twey> > foldr (\x y -> if y < 5 then x + y else x) 0 [1..]
04:03:39 <lambdabot>   * Exception: stack overflow
04:03:47 <Twey> mreh: No, it doesn't
04:03:53 <Twey> Er, Berengal
04:04:04 <Twey> A fold produces a single value from a whole list
04:04:09 <ksf> BONUS, SYN
04:04:10 <mreh> not a list
04:04:35 * Twey ponders.
04:04:39 <Berengal> > foldr (\e r -> e*2:r) [] [1..]
04:04:40 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
04:04:41 <mreh> what i get back from fold is a series of nested functions
04:04:42 <Twey> Mind you...
04:04:44 <Twey> Yeah
04:04:45 <Berengal> Tada, map!
04:04:46 <Twey> Laziness FTW
04:04:47 <ksf> @slap BONUS
04:04:47 * lambdabot throws some pointy lambdas at BONUS
04:05:14 <Berengal> Also, filter
04:05:36 <Berengal> > foldr (\e r -> if even e then e:r else r) [] [1..]
04:05:38 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
04:06:35 <daxhuiberts> Ah, I'm beginning to understand
04:07:00 <mreh> so if fold returns a list, then you can do operations on that
04:07:01 <Berengal> Lots of things you can do by folding from the right on infinite lists... maximum/minimum on bounded types...
04:07:13 <Twey> mreh: Not just lists
04:07:19 <Berengal> mreh: Any type
04:07:22 <sohum> ...why would replacing foldl for foldr be giving different answers?
04:07:32 <Twey> sohum: Because foldl is foldr backwards
04:07:33 <ksf> well, folding an infinite list makes sense if you can partly inspect the result.
04:07:34 <Berengal> > foldr const 0 [1..]
04:07:35 <lambdabot>   1
04:07:39 <mreh> Berengal: but the data struction must be recursive
04:07:45 <sohum> Twey: for a commutative operation?
04:07:47 <Berengal> Ints aren't recursive
04:07:53 <mreh> structure
04:08:00 <Twey> Probably not
04:08:02 <Twey> What's the case?
04:08:23 <mreh> foldl is not foldr backwards!
04:08:33 <ksf> ...more like inside-out.
04:08:43 <mreh> backwards with the terms reversed
04:08:48 <mreh> yeah, inside-out
04:08:50 <Berengal> > foldr (\e a -> if e == 5 then 0 else a+1) 0 [1..]
04:08:58 <lambdabot>   4
04:09:09 <mreh> @src const
04:09:10 <lambdabot> const x _ = x
04:09:13 <Berengal> ↑ find function
04:09:17 <sohum> Twey: fold (l/r) (\num acc -> if (x `mod` num == 0) then (acc + 1) else acc) list
04:09:40 <f4hy> > show 0.001
04:09:41 <lambdabot>   "1.0e-3"
04:09:57 <sohum> > foldl (\num acc -> if (x `mod` num == 0) then (acc + 1) else acc) 0 [2..50]
04:09:58 <lambdabot>   50
04:10:04 * mreh head asplodes
04:10:04 <ksf> usually, I just write down the first two cases with head and tail, then look at it to know whether I need foldr or foldl
04:10:10 <sohum> > foldr (\num acc -> if (x `mod` num == 0) then (acc + 1) else acc) 0 [2..50]
04:10:11 <lambdabot>   0
04:10:49 <sohum> oh wait
04:10:52 <sohum> I didn't define x
04:10:54 <Berengal> > x
04:10:55 <lambdabot>   x
04:10:59 <mreh> can you inspect the partial evaluation of a foldr
04:11:05 <sohum> > let x = 100 in foldl (\num acc -> if (x `mod` num == 0) then (acc + 1) else acc) 0 [2..50]
04:11:06 <lambdabot>   * Exception: divide by zero
04:11:23 <sohum> ...wut
04:11:35 <mreh> because what you get is a foldr z f [..] = foldr (f..()) f [..]
04:11:35 <Berengal> mixed your foldl and foldr there
04:11:39 <mreh> yeah
04:11:46 <sohum> > 100 `mod` 2
04:11:47 <lambdabot>   0
04:11:48 <mreh> s/foldr/foldl/
04:12:16 <mreh> how embarrasing!
04:12:20 <sohum> where exactly is num = 0?
04:12:29 <Berengal> sohum: You too, mixed foldl and foldr
04:12:41 <sohum> Berengal: why does it matter here?
04:12:43 <Berengal> > let x = 100 in foldr (\num acc -> if (x `mod` num == 0) then (acc + 1) else acc) 0 [2..50]
04:12:45 <lambdabot>   7
04:13:19 <Berengal> > let x = 100 in foldl (\acc num -> if (x `mod` acc == 0) then (num  + 1) else num ) 0 [2..50] -- this is what you wrote, except I switched acc and num around. The semantics are the same
04:13:21 <lambdabot>   * Exception: divide by zero
04:13:22 <agruman> How would i go to fix "data X = a | b c; data Y = d | e | f; data Z = X | Y | none;" where i have a func that takes X but i want to use it as Z? It complains about not being the expected/inferred type which is correct, but since X is a subtype of Z cant i use it like that?
04:13:44 <sohum> > :type foldl
04:13:45 <lambdabot>   <no location info>: parse error on input `:'
04:13:52 <Berengal> @type foldl
04:13:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:14:05 <sohum> oh ok
04:14:08 <sohum> still
04:14:10 <agruman> ie f :: X -> Z, how would i go to return the arg i got as a Z?
04:14:21 <Axman6>  is a
04:14:25 <Axman6> X is a Z*
04:14:31 <sohum> > let x = 100 in foldl (\acc num -> if (x `mod` num == 0) then (acc + 1) else acc) 0 [2..50] -- this still div0s, no?
04:14:33 <lambdabot>   7
04:14:33 <Axman6> the type of X is Z
04:14:36 <sohum> or not
04:15:03 <agruman> Axman6: well ghc complains
04:15:05 <sohum> ah, I see
04:15:20 <Berengal> sohum: foldl takes acc first, foldr takes acc second
04:15:45 <sohum> Berengal: yep, I was wondering why your expression div0d as well, then noticed you swapped everything around
04:16:03 <Axman6> agruman: well f :: X -> Z doesn't make any sense. X isn't a type, it's a data constructor
04:16:29 <Berengal> Axman6: It's also a type, but the constructors aren't valid haskell constructors :P
04:16:53 <Berengal> agruman: There is no subtyping in Haskell
04:17:19 <f4hy> I can not figure out how to print a float formated
04:17:31 <Berengal> agruman: What you have is a type 'X', a type 'Z' and a constructor confusingly named 'X' but is really a value of type 'Z
04:17:42 <f4hy> How do I get from 0.065 to "0.065"
04:17:59 <agruman> Berengal: ok, now i see a bit more clearly atleast :)
04:18:17 <Axman6> f4hy: show
04:18:24 <Axman6> > show 0.065
04:18:25 <f4hy> > show 0.065
04:18:25 <Berengal> > show 0.065
04:18:26 <lambdabot>   "6.5e-2"
04:18:27 <lambdabot>   "6.5e-2"
04:18:27 <Berengal> lol
04:18:27 <lambdabot>   "6.5e-2"
04:18:29 <agruman> Berengal: how would i go then if i want to use X in Z?
04:18:31 <f4hy> nope
04:18:35 <Axman6> hmm
04:18:48 <Berengal> agruman: Which X are we talking about?
04:19:00 <ksf> > showFFloat (Just 3) 0.2222222222 ""
04:19:01 <lambdabot>   "0.222"
04:19:10 <f4hy> ksf: magic!
04:19:15 <agruman> Berengal: the data type X
04:19:27 <Berengal> f4hy: I imagine you might find something in a pretty printer library
04:19:52 <agruman> Berengal: do i need some constructor, like "data Z = constrX X | constrY Y" ?
04:20:05 <Berengal> agruman: Yes, something like that
04:20:15 <FunctorSalad> btw, I often find that I'd like to type-safely specialise to a particular constructor... one way is to change "data Z = X ... | Y ..." to "data Z = ZX X | ZY Y; data X = ...; data Y = ..."
04:20:44 <FunctorSalad> though one could also use GADTs with a phantom type parameter
04:21:00 <FunctorSalad> that would avoid the wrapping and unwrapping...
04:21:05 <Berengal> FunctorSalad: I'd probably go for the GADT approach
04:21:14 <ksf> FunctorSalad, I like the idea of graphing stuff.
04:21:58 <mlesniak> Anyone knows how I can use hoogle to search the HOpenGL  documentation, i.e. how do I search for the documentation of postRedisplay? Using the websites delivers nothing
04:21:58 <Berengal> type X; type Y; data Z a where X :: X -> Z X; Y :: Y -> Z Y
04:22:00 <ksf> ...but I'm going to be lambdaslapped, again, for advocating schemish stuff.
04:22:09 <FunctorSalad> ksf: graphing?
04:22:31 <FunctorSalad> Berengal: exactly
04:22:53 <ksf> uhm... "seeing ADT definitions as a graph and not caring about syntax"
04:23:05 <ksf> dunno how that'd work on a syntactic level.
04:23:24 <Berengal> FunctorSalad: Arguably you could just use Either instead of Z and have separate datatypes for X and Y
04:23:57 <FunctorSalad> True... (that has the advantage that it comes with utilities like Data.Either.either)
04:24:02 <f4hy> Thanks for all your help everyone. I now have a haskell program to cryptanalyze the Vigenere cipher. :-)
04:24:04 <Berengal> Yeah
04:24:49 <Berengal> They're automatically separate, only requiring extra support when you need them to be the same type
04:24:56 <Berengal> Instead of the other way around
04:25:04 <Berengal> I guess it depends on the useage
04:25:25 <Berengal> And also how many different constructors you have. Using Either would become cumbersome if there's ever more than two
04:29:24 <agruman> Berengal and FunctorSalad: thanks for the help, works quite well now :) Will read up on GADT for future use :=)
04:29:51 <Berengal> agruman: No need to worry too much about GADTs. I usually don't use them at all...
04:30:03 <Berengal> They're nice to know in case you should need them though
04:30:24 <FunctorSalad> I haven't used them much either, but this phantom-type-tagging seems pretty neat
04:30:36 <FunctorSalad> I should start using them :)
04:30:42 <Berengal> Yeah, they're neat if you're doing type algebra
04:32:01 <Berengal> And while there's plenty that can be done in the type system, I'd say you'd be completely fine in regular HM + type classes over 90% of the time
04:32:28 <Berengal> Or whatever more articulate version of that expression you'd prefer
04:37:17 <FunctorSalad> the advantage seems to be that with GADTs you have less syntax overhead (comparing "newtype OrderedList" to "data Ordered; data Unordered; data List a tag where {Cons :: a -> List a tag -> List a Unordered; Nil :: List a tag; UnsafeAssertOrdered :: List a -> List Ordered }
04:37:39 <FunctorSalad> it seems the "Ordered" tag would propagate automatically
04:38:13 <FunctorSalad> sorry, should be UnsafeAssertOrdered :: List a tag -> List a Ordered
04:39:23 <Berengal> Mmm, I like it when functions start with capital letters, or have multi-line type signatures and undefined implementations...
04:40:30 <FunctorSalad> isn't that impossible? ;)
04:40:40 <FunctorSalad> (if it starts with a capital letter it's a constructor)
04:40:48 <Berengal> Constructors are functions
04:41:10 <Berengal> Also, type constructors can be seen as functions in the type system
04:41:11 <FunctorSalad> yes, but they can't have undefined implementations
04:41:24 <FunctorSalad> (constructors)
04:41:56 <Berengal> Yes, but you can have regular functions with type signatures manipulating types, but which are undefined for values
04:43:51 <FunctorSalad> you mean things such as typeOf?
04:43:58 <Berengal> For instance
04:44:55 <Berengal> I believe the wiki also has an example where they implement peano numbers and lists in the typesystem, then create a quicksort function...
04:47:11 <FunctorSalad> the "reflection" package even stores pointers and through that anything in types ;)
04:47:30 <FunctorSalad> it's quite incredible http://hackage.haskell.org/packages/archive/reflection/0.1.1/doc/html/Data-Reflection.html
04:48:56 <FunctorSalad> I first thought that nothing is won since you still have to pass the typed undefined value around, but apparently the idea is to use the data-storing type through a typeclass?
04:49:22 <Berengal> I haven't had a look at it yet, I'm afraid
04:49:39 <Berengal> Haven't really found any use for reflection in Haskell yet
04:49:42 <ivan-kan`> how would i catch this error I get when looking at a dangling symlink ?
04:49:44 <ivan-kan`> Prelude Control.Exception> fs <- System.Posix.Files.getFileStatus "bash_profile"
04:49:44 <ivan-kan`> *** Exception: bash_profile: getFileStatus: does not exist (No such file or directory)
04:49:44 <ivan-kan`>  
04:50:02 <FunctorSalad> it's not reflection in the sense of Java
04:50:04 <mauke> :t catch
04:50:05 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
04:50:19 <Berengal> @type Control.Exception.catch
04:50:20 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
04:50:27 <FunctorSalad> it just "reflects" values into types
04:50:42 <ivan-kan`> is it an IO.Error ?
04:52:10 <mauke> :t isDoesNotExistError
04:52:11 <lambdabot> Not in scope: `isDoesNotExistError'
04:52:44 <Berengal> IOError in the old system, IOException in the new, I believe
04:53:03 * Berengal haven't really looked at exceptions either...
04:53:19 <FunctorSalad> I think lambda is out of date there, the new catch uses the Exception class
04:54:08 <FunctorSalad> so you have to tell it somehow that your handler is specialised to type IOError -> IO Foo
04:54:33 <mauke> there are three versions of catch
04:54:45 <mauke> System.IO.Error, Control.OldException and Control.Exception
04:54:57 <FunctorSalad> IO has its own? oh
04:55:07 <FunctorSalad> the Prelude one?
04:56:11 <FunctorSalad> you're right Berengal, the thing that's an instance of Exception is called IOException
04:57:06 <FunctorSalad> @hoogle catchError
04:57:06 <lambdabot> Control.Monad.Error.Class catchError :: MonadError e m => m a -> (e -> m a) -> m a
04:57:26 <FunctorSalad> there's another one in MonadIOCatch ;)
04:57:51 <FunctorSalad> *MonadCatchIO
04:59:02 <Asztal> also http://okmij.org/ftp/Haskell/misc.html#catch-MonadIO
04:59:07 <ivan-kan`> i have ghc v 6.8.2
04:59:36 <Axman6> that's quite old ivan-kan`
04:59:41 <Berengal> I don't really get how SomeException works... A handler that catches SomeException catches all exceptions, but SomeException is a type, not a class...
04:59:52 <mauke> SomeException is an existential wrapper
05:00:23 <Berengal> mauke: Yes, I know. I assume it implements some magic in the Exception class...
05:00:24 <ivan-kan`> Axman6: that's what came with Ubuntu....
05:00:39 <Axman6> more ubuntu fail :(
05:00:56 <Berengal> ivan-kan`: go download ghc 6.10.3
05:01:06 <ivan-kan`> ok, will do
05:01:08 <mauke> why?
05:01:22 <mauke> exceptions work fine in ghc 6.8
05:01:29 <roadwarrior> when running ST Lazily is there a reason it jumps over fail ?
05:01:49 <FunctorSalad> Berengal: it seems that a handler of type SomeException -> IO Foo will catch any exception
05:02:12 <FunctorSalad> (which is anomalous since other handlers only catch if the type matches?)
05:02:33 <Berengal> FunctorSalad: Yes
05:03:10 <Berengal> No exception is of type SomeException unless cast to it using toException, so the type shouldn't match for anything
05:03:32 <Berengal> I'm assuming there's some magic in the Exception class...
05:03:55 <mauke> I'd call it "code", not "magic" :-)
05:04:04 <Berengal> mauke: There's a difference?
05:04:21 <mauke> btw, there's a paper about this new exception system that explains how it works
05:04:36 * EvilTerran notes "data SomeException = forall e . Exception e => SomeException e"
05:04:37 <Berengal> Yeah, I've been meaning to read it but haven't gotten around to it yet...
05:04:40 <Asztal> you wizards are so condescending :P
05:05:04 <mauke> any technology distinguishable from magic is insufficiently advanced
05:05:05 * Berengal looks guiltily at his ever-growing 'papers' directory...
05:05:09 * EvilTerran notes also that that should be the same as "data SomeException where SomeException :: Exception e => e -> SomeException"
05:06:03 <FunctorSalad> I guess it's implemented as "passExceptionToHandler ex handler = case cast ex of { (Just x) -> handler x;   Nothing -> case cast (fromException ex) of { Just y -> handler y; Nothing -> dont_handle }}
05:06:17 <FunctorSalad> where ex :: SomeException
05:06:22 <matthew-_> @seen bos
05:06:23 <lambdabot> bos is in #haskell-in-depth, #ghc and #haskell. I last heard bos speak 6h 36m 4s ago.
05:07:26 <FunctorSalad> or actually, the cast is already included in fromException, which has type Exception e => SomeException -> Maybe e
05:08:07 <cads> hey, maybe I'll ask this here
05:08:26 <cads> if I have a theorem from basic set theory, can I use it to construct a useful function on sets?
05:08:59 <FunctorSalad> Asztal: victimless condescension? ;)
05:09:09 <EvilTerran> depends on the theorem, i'd think
05:09:20 <FunctorSalad> (I didn't notice anyone was condescended upon in that conversation)
05:09:40 <EvilTerran> cads, if it's "forall x. exists y. ...", the constructive proof would correspond to a function from x to y, say.
05:09:55 <Asztal> FunctorSalad: just a bad joke about the code vs. magic thing.
05:10:02 <cads> its's a theorem stating that if we have a subset B of a set fulfilling the least upper bound property, S, then  inf B is in S
05:10:39 <Berengal> Hey, I've always found programmers and wizards to be two of a kind. That impression hasn't really changed since I became one myself
05:10:47 <FunctorSalad> hehe
05:10:53 <Berengal> (wizards in the fictional sense, obviously)
05:12:53 <bremner> Berengal: you became a fictional wizard?
05:13:03 <Berengal> Yes
05:13:17 * bremner trembles in fictional awe
05:13:19 <mauke> can you teach me how to become a bot?
05:13:22 <EvilTerran> cads, so... "forall s : lub-closed set, b : subset of s. exists x : s. x = inf b"?
05:13:33 <Berengal> coder = fictional wizard
05:13:52 <bremner> @faq can Haskell teach mauke to be a bot?
05:13:52 <lambdabot> The answer is: Yes! Haskell can do that.
05:14:05 <FunctorSalad> does lub-closed mean that lubs exist or only that it's closed under any existing lubs?
05:14:36 <EvilTerran> cads, there's not really much useful you could do with that in terms of constructing a program from it, seeing as the lub property's only really relevant for infinite sets, isn't it?
05:15:37 <cads> yeah, for the finite case it
05:15:43 <cads> s pretty trivial
05:15:44 <EvilTerran> cads, the program most relevant to that theorem would probably just be Prelude.maximum
05:16:54 <FunctorSalad> you could "construct" an infinite-set inf as a sequence converging to it
05:17:23 <FunctorSalad> but the theorem seems true by definition (I'm probably missing something)
05:17:48 <FunctorSalad> oh wait, lub=sup, but you want to calculate the inf?
05:18:40 <cads> it seems to say that a set with the least upper bound property has a greatest lower bound on each of its subsets
05:18:50 <Feuerbach> shouldn't "cabal info gtk" retrieve information about gtk from hackage?
05:19:08 <cads> wait wait
05:21:19 <Berengal> Feuerbach: Only if gtk is in hackage, which it isn't
05:21:36 <FunctorSalad> Feuerbach: I think cabal info requires an exact package name. to search for 'gtk' in descriptions you can do something like "cabal list | grep -i -C10 gtk"
05:22:34 <FunctorSalad> or actually cabal list doesn't dump the long descriptions, just the synopsis
05:22:45 <Berengal> Oh, and cabal works for installed packages as well, not just those on hackage
05:23:02 <Berengal> But gtk2hs isn't in hackage. You need to download and build it yourself
05:23:20 <Feuerbach> is there a reason gtk2hs isn't in hackage?
05:23:38 <Berengal> Yeah, you need to build it with gcc
05:23:48 <maltem> Feuerbach, it's not yet cabalized
05:23:51 <Berengal> Or something like that
05:24:03 <maltem> Feuerbach, but there are plans to do that, just nobody has done it yet AFAIK
05:24:12 <Feuerbach> okay, thanks
05:26:43 <cads> hrm, my theorem was wrong
05:27:00 <cads> b has to be bound from below as well or it doesn't make sense
05:30:35 <cads> Okay, here it is.  Theorem: forall S : lub-closed set, B : not empty subset of S, bound from below. exists L : set of lower bounds of B. exists a in S : sup L .  a = inf B. exists inf B in S
05:30:45 <cads> that's a mess :)
05:31:40 <cads> for infinite cases our inf isn't necessarily in B, which is wierd
05:32:05 <FunctorSalad> I think you take the sup of the complement then
05:32:16 <FunctorSalad> err, not the complement
05:32:22 <FunctorSalad> the set of elements below B
05:32:33 <cads> yeah
05:34:13 <FunctorSalad> (a special case is if inf B = inf S, so the set of elements below B is empty?)
05:35:38 <FunctorSalad> it seems that in that case you have to require that inf S \in S
05:36:11 <cads> well, B has the property requiring at least one lower bound to exist
05:36:14 <sadache> Does anyone here know of an approachable paper that explains arrows advantages?
05:36:31 <vixey> I don't think arrows have any advantages sadache
05:36:32 <FunctorSalad> that lower bound would have to be in S though
05:36:33 <sadache> and maybe contrast it with monads and applicative functors?
05:37:13 <sadache> @vixey :) then why are they being added to haskell`?
05:37:13 <lambdabot> church is my favourite computer scientist.
05:37:24 <EvilTerran> hehe
05:38:53 <cads> FunctorSalad: yes.. but it's also interesting that there's a greatest lower bound
05:39:08 <sadache> so noone know about a gentle paper that explains Arrows?
05:39:32 <cads> I have a few, but I don't know how gentle they are
05:40:30 <sadache> @cads I guess I understand monads fairly well, and I want to grasp Arrows and applicative functors as well
05:40:30 <lambdabot> Unknown command, try @list
05:42:17 <vixey> gotta catch em all
05:43:24 <cads> FunctorSalad:  let S = [0, 1],  B = intersection Q (0, 1). There's no element in B that's less than the rest, but then we see L = {0}, and know inf B = sup L = 0, even though 0 is not in B.
05:44:43 <FunctorSalad> what about S = B = (0,1)?
05:44:54 <FunctorSalad> (I'm a bit confused about your premises)
05:45:00 <romildo> Hi.
05:45:00 <romildo> Any alex user here?
05:45:02 <romildo> I would like to know if it is possible to easily detect EOF in an action in rule from the alex input file.
05:46:53 <cads> S has to have a least upper bound for each subset, and B must be bound from below in S
05:56:21 <cads> I think that by the least upper bound property, S will always be closed from above. I think the theorem can be interpreted to say that B, which bound from below, is either open from below, in which case its set L of lower bounds is closed from above and contains inf B = sup L = max L, or it's closed from below, where inf B = min B is in B.
05:58:06 * EvilTerran has a minor revelation about purity and information hiding that he can think of no good way of articulating
05:58:30 <EvilTerran> (beyond "oh hey, that works nicely")
06:06:14 <Twey> EvilTerran: IS GOOD?
06:07:09 <EvilTerran> Twey, IS.
06:08:36 <Berengal> EvilTerran: Something along the lines of state never being truly hidden?
06:10:07 <snoobino> try to give an example
06:11:47 <snoobino> it'd be cruel not to say it now
06:15:46 <cads> pastie the code :)
06:19:47 <EvilTerran> basically, the idea was that, as i have an abstract type Foo, which contains a value of type Bar, if the only access to that Bar is through a function of type (Bar -> Bar) -> Foo -> Foo, the value can't escape
06:20:41 <EvilTerran> or indeed (Bar -> m Bar) -> Foo -> m Foo, for appropriate choice of m.
06:21:15 <Berengal> Well, in the first case at least you might just as well get rid of the Bar altogether
06:21:38 <EvilTerran> this being kinda useful in this case, because each value of type Bar only makes sense in the context it's extracted from a Foo in
06:22:16 <Berengal> If that function truly is the only way to access it then the only thing you can do is modify it further, which is pointless in itself
06:22:33 <Berengal> For the second case... that's different
06:22:54 <EvilTerran> Berengal, the Bar is used when the Foo is translated into an action in a different monad
06:23:01 <EvilTerran> s/different//
06:23:15 <Berengal> Yeah, that's the second case. I was talking about the first
06:23:25 <EvilTerran> i mean, in either case
06:24:13 <Berengal> Explain how that works for the first?
06:24:37 <EvilTerran> in my current situation, a Foo is a more conrete representation of a variety of monadic action, which is then translated into the actual action by a function which has full access to Foo's internals
06:25:25 <Berengal> In that case you (Bar -> Bar) -> Foo -> Foo function doesn't provide the only access to Bar
06:25:31 <EvilTerran> pedant
06:25:39 <Berengal> The -> monad function also has access
06:25:48 <Berengal> No, this is important
06:26:29 <Berengal> But for different reasons than what you were trying to convey
06:26:35 <Berengal> So it's also irrelevant
06:26:48 <ivan-kan`> does anyone know why the emacs haskell mode is lining up if then else ?
06:38:39 <EvilTerran> Berengal, consider the case when the Foo is to be built into an IO action, that prints the value of the Bar to stderr as logging information; the (Bar -> Bar) -> Foo -> Foo is, then, the only way of accessing the Bar value, but the value's still relevant.
06:40:22 <Berengal> If the (Bar -> Bar) -> Foo -> Foo was the only way to access it, the IO action wouldn't have any way to access it...
06:40:45 <snoobino> your function looks a bit like fmap
06:40:54 <EvilTerran> snoobino, yeah, i noticed that
06:40:57 <mauke> Berengal: don't make me slap you
06:42:48 <Berengal> No, I'm sure I'm on to something here. I'm just not completely able to formulate it into coherent thoughts yet
06:42:55 <EvilTerran> Berengal, we seem to be using different meanings of "access"
06:43:17 <mauke> If the (Bar -> Bar) -> Foo -> Foo was the only way to access it, it wouldn't be Haskell
06:43:23 <EvilTerran> i mean "make the value available to user-written code"
06:43:35 <Berengal> EvilTerran: Yes, we probably are. I'm a little caught up in my own thing right now :P
06:43:42 <EvilTerran> not "make the value available to internal and/or user-written code"
06:44:01 <duckinator> hi
06:44:23 <Berengal> I'm thinking more along the lines of access might be limited, e.g. you can only print it to stderr
06:44:58 <Berengal> But there's still some kind of access going on.
06:45:16 <Berengal> The result of printing to stderr depends on the state of the Bar in the Foo
06:45:33 <snoobino> maybe it is like restricting the IO monad to only one effect
06:45:35 <mauke> ok, so what's your point?
06:45:47 <snoobino> since you can't compose two Foo's
06:46:32 <Berengal> Eh, my point was something along the lines of you can't hide state. If the state is completely invisible to an outside user then there's no state
06:47:19 * EvilTerran does something improbable with freopen or something and attaches stderr to stdin to get his data back :P
06:47:48 <mauke> depends on your point of view
06:48:02 <Berengal> mauke: Also sort of the point :P
06:48:31 <Berengal> Code operates on different levels. Some are stateful, some aren't
06:48:53 <Berengal> Take parsec for example. When you're in the parser monad you're in a stateful environment
06:49:07 <Berengal> However, once you drop out of the monad all state is lost
06:50:00 <EvilTerran> "abandon state, all ye who enter here"
06:50:33 <Berengal> the State monad might be an even better example... Inside the monad you've got state, but outside of it, once you runState, there's only immutable values
06:51:03 <Berengal> The only thing that remains is the relation between input and output
06:51:29 <EvilTerran> which is all state is, anyway
06:52:13 <snoobino> The only diffenrence between a Foo and a plain bar is that Foo add an effect, right ?
06:52:22 <Berengal> Eh, I define state as environment, of sorts. It affects the computation without being either input nor output
06:52:42 <EvilTerran> snoobino, well, in my case, Foo has a few other bits and pieces in there as well
06:53:37 <snoobino> EvilTerran, what do you mean ?
06:55:04 <EvilTerran> this originally started out as an idea for playing with syntax for first-order logic, although it's wandered away from that somewhere along the way
06:55:44 <EvilTerran> iirc, what got me on to thinking about this rather more general idea was thinking about how to deal with quantifiers
06:57:47 <snoobino> if f is your function (Bar -> Bar) -> (Foo -> Foo) does f g . f h = f (g . h) holds ?
06:58:14 <EvilTerran> or, analogously, how to deal with lambda abstractions when manipulating lambda calculus syntax
06:58:19 <snoobino> I'm thinking it may be a kind "specialised" fonctor
06:58:35 <EvilTerran> snoobino, yes, probably; this does feel vaguely functor-like
07:01:34 <FunctorSalad_> I'd call it "monoid homomorphism" ;)
07:07:26 * EvilTerran goes back to trying to get his head around http://lambda-the-ultimate.org/node/544
07:08:30 <jbjohns> hi
07:08:35 <jbjohns> I'm reading:  http://www.serpentine.com/blog/2008/02/06/the-basics-of-applicative-functors-put-to-practical-work/
07:09:21 <jbjohns> and the last comment says that you must use monad style in non-context-free grammers, and then goes on to produce a listing where you need the length of a string as well as the string itself.  Isn't there a way to do this in one call?  With arrows or something?
07:10:17 <jbjohns> i.e. given a function, wrap it in something that returns what it returned and the results of applying some function to what it returned
07:12:43 <EvilTerran> ?type ((,) <*>)
07:12:44 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
07:13:08 <Qork> how can I transform RGB to a single value?
07:13:16 <augur> I LOVE YOU ALL
07:13:21 <augur> i mean, hello.
07:14:42 <jbjohns> oh, what is that?
07:14:54 <jbjohns> looks like the right thing, how do you use it?
07:15:59 <EvilTerran> jbjohns, that's using <*> as the s-combinator, (\f g x -> f x (g x))
07:16:08 <Qork> how can I transform RGB to a single value?
07:16:31 <augur> qork: you mean three floats?
07:16:33 <jbjohns> so it's just something like:       (,) <*> length <*> makeString       ?
07:16:37 <EvilTerran> Qork, the last time you asked that is still visible on *everyone's* screens, i'd wager. even if they're using irssi on a phone or something.
07:16:45 <augur> transformRGB R G B = (R,G,B)
07:16:46 <augur> :P
07:16:51 <Stinger> lol
07:17:07 <ivan-kan`> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4764#a4764
07:17:07 <Stinger> I don't think he meant that somehow
07:17:15 <EvilTerran> jbjohns, not exactly
07:17:19 <augur> im sure, but thats the closest you can get
07:17:33 <ivan-kan`> how can i get past this error? I thought return () would placate the compiler
07:17:33 <augur> atleast for arbitrary RGB values
07:17:35 <Qork> toSingular :: (Int, Int, Int) -> Int
07:17:49 <EvilTerran> jbjohns, i think the comment about needing monad style is about a slightly subtle aspect of the difference between monads and applicatives
07:17:54 <augur> qork, what is the range of the values for toSingular?
07:18:00 <Qork> rep rgb value as just one int
07:18:09 <Qork> i ont know
07:18:14 <Qork> is there some other scheme
07:18:16 <augur> well its important that you do
07:18:20 <Qork> like convert rgb to soemthing else
07:18:22 <augur> if you have a fixed range, then its simple
07:18:23 <EvilTerran> jbjohns, namely, that the "shape of the side-effects", as it were, can depend on the result of earlier actions in the monadic style, but not in the applicative style
07:18:37 <Stinger> depends if you are 8 bpc or more/less
07:18:46 <Qork> augur: i want to do eigenfaces(face recognition) so I have a bunch of vectors
07:18:58 <Stinger> you can have 656 rgb encodings
07:19:04 <augur> toSingular :: (Int,Int,Int) -> Int can be defined like so:
07:19:06 <EvilTerran> jbjohns, however, i strongly suspect that some of parsec's built-in functions would be un-writable just using applicative style
07:19:08 <Stinger> er 565 even
07:19:42 <augur> toSingular (r,g,b) = r*65536 + g*256 + b
07:19:44 <jbjohns> evilTerran: Ah, so even if I can get the (many $ char 'a') to return both all the a's and the length of them I still can't affect other computations that follow?  Because in applicative, the applications run in isolation of each other?
07:20:05 <EvilTerran> ?type (>>=)
07:20:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:20:08 <Stinger> you probably want (r,g,b) -> 0x10000 * r + g*0x100 + b, which is what angur said :P
07:20:17 <augur> if your range of values is (0,255)
07:20:25 <Stinger> but thats assuming some things, and that your inputs are properly bounded
07:20:46 <EvilTerran> jbjohns, from the type of (>>=), you have a function which takes the result of an action, and returns an action; in this way, the returned action can depend on the result of the parameter action
07:20:50 <EvilTerran> ?type (<*>)
07:20:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:20:57 <augur> actually stinger
07:20:59 <augur> come to think of it
07:21:12 <jbjohns> EvilTerran:  Yea, I've read quite a lot about Monads, this is just the first thing I've read on applicative
07:21:17 <augur> it IS possible to do for arbitrary the value range (0,Infinity)
07:21:26 <augur> s/arbitrary//
07:21:49 <jbjohns> I mean, obviously I'm no guru, but I did at least know that that things further down the chain are affected by things that occurred earlier with Monads
07:21:59 <EvilTerran> jbjohns, and, from the type of (<*>), you have two actions, one which returns a function, and one which returns a value to pass to the function; there can be no information flow from the result of one action to the structure of another
07:22:02 <augur> N^3 is countable infinite, which means there's a diagonalization of N^3, and thus there must be a unique mapping of every triple in N^3 to N
07:22:20 <Stinger> yep
07:22:32 <Qork> and what is such a format called Stinger?
07:22:38 <augur> but doing that map is certainly a bit more complicated
07:22:58 <wli> augur: There is. If you have N^2 to N (which is not hard) you can just do N^3 -> N^2 -> N
07:23:20 <Stinger> hmm an 8:8:8 packed 24bit rgb value I suppose
07:23:22 <EvilTerran> jbjohns, sorry, that remark about (>>=) probably looked a bit patronising on its own; i was trying to draw up a constrast between the types of (>>=) and (<*>)
07:23:30 <Stinger> don't quote me on the exact terminology
07:23:42 <augur> wli: i suppose. im not so hot with math ;)
07:24:02 <jbjohns> EvilTerran:  I didn't take it badly, it's impossible to know what someone else' knowledge is without exploring it a bit. :)
07:24:31 <jbjohns> EvilTerran: ok, so a Monad is like steps and a Applicitive is like concurrent "procs" (in the Erlang sense)
07:24:34 <augur> qork, if you need arbitrary values of N, look for a diagonalization algo. if you need bounded values, just do the multiplication version.
07:24:35 <jbjohns> ?
07:24:46 <EvilTerran> jbjohns, well, i don't know anything about erlang...
07:25:15 <jbjohns> ah, no sharing of any kind between "processes" (which are otherwise what everyone else would call threads)
07:25:32 <EvilTerran> i was just trying to illustrate that you can see the more restricted structure of applicative actions (over monadic actions) from the types
07:25:46 <wli> ISTR one could derive a closed form formula for N^2 -> N but I don't remember it offhand. I'd have to re-derive it.
07:25:48 <jbjohns> ok, fair enough
07:26:21 <Stinger> hmm does Haskell have bitwise operators for integers?
07:26:30 <augur> im sure N^3 -> N is simple enough
07:26:38 <Stinger> or ints at least
07:27:13 <EvilTerran> Stinger, i suspect Data.Bits has what you need
07:27:32 <Stinger> hmm
07:28:03 <ivan-kan`> is ther something like map that does not return an array ?
07:28:40 <simon> ivan-kan`, foldl?
07:28:46 <augur> yes ivan-kan`, there is. what, specifically, depends on what you want to do with it!
07:29:30 <simon> ivan-kan`, in Standard ML there is app, but it operates on side effects, so I'm not sure what you'd want to be the result.
07:29:31 <ivan-kan`> well back to my paste above I am trying to recurse in DirTree an return the top ten biggest files
07:30:09 <wli> I'm at a loss to re-derive N^2 to N, never mind any direct formula for N^3 to N.
07:30:14 <augur> so you want the 10 largest files contained inside a dirtree?
07:31:04 <EvilTerran> wli, interleaving bits would work, surely?
07:31:07 <ivan-kan`> simon: foldl applies a function to each elements, i am looking for something that runs on each elem and returns nothing
07:31:29 <simon> ivan-kan`, you do want to return something: a list of the biggest files.
07:31:40 <wli> EvilTerran: I was trying to do a diagonalization -type thing but it would work.
07:31:42 <Qork> augur: are you talking about eigenfaces now?
07:31:47 <augur> ivan-kan`, if youre just trying to find the 10 largest files in a whole dirtree
07:32:29 <simon> ivan-kan`, have you considered sorting your files based on size?
07:32:30 <augur> you can do a simple recursive analysis. if the dirtree has nothing but files, just sort by size and take the first 10
07:32:42 <EvilTerran> wli, i find that, although diagonalisation is nice and clear visually, it's a bit of a pain to express algorithmically
07:32:59 <wli> EvilTerran: It ends up being a quadratic bivariate polynomial.
07:33:04 <augur> otherwise, you can combine the dirs files with the 10 largest of each subdir, and then sort and take 10
07:33:34 <augur> that would be an efficient way to do it, so you never build up a huge file list
07:33:54 <augur> the SIMPLEST way ofcourse is to just use the existing tree algorithms to find all leaf nods (the files) and sort then take 10
07:34:07 <augur> but that builds a huge list before doing any sorting, which is unnecessary
07:34:44 <EvilTerran> augur, they may work out to be remarkably similar, with enough laziness
07:35:13 <EvilTerran> like, iirc, head.sort is O(n) under ghc.
07:35:40 <augur> hm.
07:35:46 <augur> wait, an O(n) sort algo?
07:35:52 <EvilTerran> not quite
07:36:15 <EvilTerran> it's O(n.log n), but because of laziness, only O(n) operations are done if you only evaluate the list up to the first value
07:36:49 <augur> oh, i see what you mean
07:36:50 <augur> right
07:36:55 <augur> that makes sense
07:37:08 <augur> so then yeah, person who asked the question, just do that.
07:37:12 <EvilTerran> iirc, forcing the first k elements after sorting a list of n elements is O(n.log k) by that algorithm
07:38:12 <ivan-kan`> Aisling: ues. o
07:38:29 <mreh_> > foldl ((:) . flip) [] [1..10]
07:38:30 <lambdabot>   Couldn't match expected type `a -> b -> c'
07:38:34 <ivan-kan`> Aisling: yes, i'll make the ten a variable eventually
07:38:52 <augur> uh...
07:39:03 <ivan-kan`> augur: i meant that last remark to you
07:39:07 <mreh_> foldr (:) [] [1..10]
07:39:12 <augur> aisling is going to get a bunch of pings that wont make any sense to him. :3
07:39:20 <mreh_> > foldr (:) [] [1.10]
07:39:21 <lambdabot>   [1.1]
07:39:26 <mreh_> > foldr (:) [] [1..10]
07:39:27 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:39:41 <daf> if I have a [ErrorT e m a], what's a good way to turn it into an ErrorT e m [a], ignoring failures?
07:40:01 <mauke> :t msum
07:40:02 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:40:03 <jmcarthur> @check \xs -> id xs == foldr (:) [] xs
07:40:04 <lambdabot>   "OK, passed 500 tests."
07:40:38 <daf> mauke: that just returns the last success in ErrorT, AIUI
07:41:16 <jmcarthur> :t sequence
07:41:17 <augur> why are we hitting lambdabot so hard for something so silly?
07:41:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
07:41:59 <mreh_> foldl (++) [] [[1,2,3],[4,5],[6],[7,8,9]]
07:42:00 <daf> jmcarthur: that will just return a Left if any of the values evaluates to Left
07:42:04 <mreh_> > foldl (++) [] [[1,2,3],[4,5],[6],[7,8,9]]
07:42:05 <lambdabot>   [1,2,3,4,5,6,7,8,9]
07:42:11 <augur> ...
07:42:14 <mreh_> > foldr (++) [] [[1,2,3],[4,5],[6],[7,8,9]]
07:42:15 <lambdabot>   [1,2,3,4,5,6,7,8,9]
07:42:16 <augur> really, mreh_?
07:42:18 <wli> > let ilog :: Integer -> Int ; ilog x = length . takeWhile (/= 0) $ iterate (`div` 2) x ; f :: Integer -> Integer -> Integer ; f x y = foldr (.|.) 0 [let (q, r) = k `divMod` 2 in if r == 0 then (if testBit x q then bit k else 0) else (if testBit y q then bit k else 0) | k <- [0 .. 2 * max (ilog x) (ilog y)]] in flip showHex "" $ f 17 9
07:42:20 <lambdabot>   "183"
07:42:29 <augur> why dont you just get ghci
07:42:30 <jmcarthur> daf: oh, so you just want to completely omit all error information?
07:42:38 <daf> jmcarthur: right, I don't care about failures
07:42:46 <ivan-kan`> augur: i was thinking i don't need to go into a child dir if it's size is smaller thant the last 10
07:42:59 <jmcarthur> daf: you can't just use the inner monad instead of the entire ErrorT stack?
07:43:10 <augur> this is true ivan-kan`.
07:43:11 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#mergesort <- rather cunning algorithm, really
07:43:27 <EvilTerran> manages to do mergesort without a single (++)
07:43:28 <wli> The diagonalization thing for N^2 -> N is more interesting.
07:44:13 <jmcarthur> daf: that was actually just a question that _might_ be a suggestion, not really advice to change all your abstractions so that you can do that, btw
07:44:19 <daf> jmcarthur: hmm. I could.
07:44:20 <daf> mauke: heh, ok
07:44:25 <daf> er jmcarthur: ^^
07:44:37 <daf> it seems like there should be a nice way
07:45:28 <daf> the only one I can think of is to converto maybes with catchError and then do catMaybes
07:45:34 <wli> The diagonal it falls on can be numbered as (x - y) or some such.
07:46:01 <augur> this is true, wii
07:46:09 <augur> wli*
07:46:27 <wli> No, it's x + y, sorry.
07:46:38 <jmcarthur> daf: i think that sounds best, honestly. or perhaps create another function that just does that
07:46:41 <augur> that too.
07:46:59 <daf> jmcarthur: I'll have a stab at that
07:47:34 <Stinger> list comprehension, wooo
07:47:51 <wli> Then you have the sum of k from k = 0 to x + y, which is ((x + y)*(x + y + 1)) `div` 2 I think.
07:48:21 <wli> From there you can just add x.
07:48:30 <Stinger> wli, whats x,y sorry?
07:48:49 <wli> So f x y = (((x + y)*(x + y + 1)) `div` 2) + x
07:49:00 <wli> Stinger: The coordinates in N^2.
07:49:13 <weilawei> so I want to apply a list of functions to a list of some values to generate a list of lists of values.. something like [(a -> b)] -> [a] -> [[b]]. even something like [(a -> b)] -> a -> [b] would be a start. hoogle doesn't have quite what I want..
07:50:08 <mauke> do you want the results by function or by argument?
07:50:09 <EvilTerran> weilawei, so you want to map over a list of functions, mapping each one in turn over a list of inputs?
07:50:27 <thomastc> weilawei: sounds kind of like the cartesian product, but different :)
07:50:47 <weilawei> EvilTerran: right
07:50:53 <wli> The simplex numbers come up in each case of N^k -> N
07:51:05 <mauke> :t map . sequence
07:51:07 <lambdabot> forall a a1. [a -> a1] -> [a] -> [[a1]]
07:51:36 <weilawei> mauke: looks awesome :)
07:51:47 <wli> N^3 -> N I think involves choose (x + y + z + 2) 3 + choose (x + y + 1) 2 + x or something.
07:52:03 <EvilTerran> ?type \fs xs -> (<$> xs) <$> fs
07:52:04 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f a -> f1 (f b)
07:52:15 <EvilTerran> ?type \fs xs -> (<$> xs) <$> fs :: [a -> b] -> [a] -> [[b]]
07:52:16 <lambdabot>     Inferred type is less polymorphic than expected
07:52:16 <lambdabot>       Quantified type variable `b' is mentioned in the environment:
07:52:16 <lambdabot>         fs :: [a -> b] -> a1 -> [[b]] (bound at <interactive>:1:1)
07:52:47 <EvilTerran> > (\fs xs -> (<$> xs) <$> fs) [f,g,h] [x,y,z] :: [[Expr]]
07:52:48 <lambdabot>   [[f x,f y,f z],[g x,g y,g z],[h x,h y,h z]]
07:53:27 <mauke> > (map . sequence) [f,g,h] [x,y,z] :: [[Expr]]
07:53:29 <lambdabot>   [[f x,g x,h x],[f y,g y,h y],[f z,g z,h z]]
07:54:14 <EvilTerran> > (\fs xs -> [[f x | f <- fs] | x <- xs]) [f,g,h] [x,y,z] :: [[Expr]]
07:54:15 <lambdabot>   [[f x,g x,h x],[f y,g y,h y],[f z,g z,h z]]
07:54:24 <EvilTerran> the possibilities are endless! :P
07:57:53 <wli> It's not choose (x + y + z + 2) 3 + choose (x + y + 1) 2 + x but it involves simplex n d = choose (n + d - 1) d
07:58:00 <mauke> :t flip $ fmap fmap $ flip fmap
07:58:01 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => f (a -> b) -> f1 a -> f (f1 b)
07:58:25 <mauke> > (flip $ fmap fmap $ flip fmap) [f,g,h] [x,y,z] :: [[Expr]]
07:58:27 <lambdabot>   [[f x,f y,f z],[g x,g y,g z],[h x,h y,h z]]
07:58:59 <mauke> now I just need a way to write flip with fmap
07:59:52 <wli> The natural numbers x,y,z >= 0 such that x + y + z = n need to be counted better or something.
08:00:05 <wli> Or maybe x + y + z = n and x + y = k
08:01:19 <clug> @let clug = "clug"
08:01:20 <lambdabot>  Defined.
08:01:24 <clug> > clug
08:01:25 <lambdabot>   "clug"
08:01:48 <roconnor> > map pred clug
08:01:49 <lambdabot>   "bktf"
08:01:57 <roconnor> > map succ clug
08:01:58 <lambdabot>   "dmvh"
08:02:23 <clug> lol
08:02:42 <mauke> > (fmap flip `id` fmap fmap `id` flip fmap) [f,g,h] [x,y,z] :: [[Expr]]
08:02:43 <lambdabot>   [[f x,f y,f z],[g x,g y,g z],[h x,h y,h z]]
08:02:46 <mauke> BEAUTIFUL
08:02:51 <clug> > succ "roconnor"
08:02:52 <lambdabot>       No instance for (Enum [Char])
08:02:52 <lambdabot>        arising from a use of `succ' at <i...
08:02:58 <clug> > map succ "roconnor"
08:02:59 <lambdabot>   "spdpoops"
08:03:05 <clug> LOL
08:03:14 <clug> I need to look up what map dos
08:03:26 <EvilRanter> > (fmap fmap fmap flip fmap fmap `id` flip fmap) [f,g,h] [x,y,z] :: [[Expr]] -- ha!
08:03:28 <tombom> applies a function to every element in a sequence
08:03:28 <lambdabot>   [[f x,f y,f z],[g x,g y,g z],[h x,h y,h z]]
08:03:31 <mauke> > map f [x, y, z]
08:03:33 <lambdabot>   Add a type signature
08:03:48 <mauke> EvilRanter: I like my version better
08:03:56 <EvilRanter> mine has MOAR FMAP
08:03:58 <clug> oh, because haskell thinks strings are lists
08:04:04 <mauke> EvilRanter: yeah, but no symmetry
08:04:08 <EvilRanter> true =/
08:04:21 <roconnor> > head clug
08:04:22 <lambdabot>   'c'
08:04:27 <roconnor> > tail clug
08:04:28 <lambdabot>   "lug"
08:04:29 <clug> > init clug
08:04:31 <lambdabot>   "clu"
08:04:32 <EvilRanter> > "symmetry" > "fmap"
08:04:34 <lambdabot>   True
08:04:48 <roconnor> > "symmetry" >> "fmap"
08:04:49 <lambdabot>   "fmapfmapfmapfmapfmapfmapfmapfmap"
08:04:51 <psygnisfive> roconnor wtf are you doing
08:04:51 <p_l> EvilRanter: For a while there I thought I had seen "MOAR FAP"
08:05:04 <roconnor> psygnisfive: I'm teaching clug haskell
08:05:20 <psygnisfive> oh i see.
08:05:22 <clug> I wish I could search google for >
08:05:43 <roconnor> @instance [] (>)
08:05:43 <lambdabot> Maybe you meant: instances instances-importing
08:05:50 <roconnor> @src [] (>)
08:05:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:05:57 <clug> wat
08:06:01 <roconnor> @src (>) []
08:06:02 <lambdabot> Source not found. My brain just exploded
08:06:05 <clug> ...
08:06:05 <roconnor> bah
08:06:39 <wli> I think it's actually correct.
08:06:41 <wli> > let choose n k | k > n || k < 0 = 0 | 2 * k > n = choose n (n - k) | k == 0 = 1 | otherwise = (n * choose (n - 1) (k - 1)) `div` k ; simplex n d = choose (n + d - 1) d ; f x y z = simplex (x + y + z) 3 + simplex (x + y) 2 + x in [f 0 0 0, f 0 0 1, f 0 1 0, f 1 0 0, f 0 0 2, f 0 1 1, f 1 0 1, f 0 2 0, f 1 1 0, f 2 0 0]
08:06:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
08:08:20 <psygnisfive> :o
08:08:24 <psygnisfive> wli, did you do it?! :o
08:08:57 <clug> > map (chr, succ, ord) clug
08:08:58 <lambdabot>   Couldn't match expected type `a -> b'
08:09:06 <clug> > map (chr . succ . ord) clug
08:09:07 <lambdabot>   "dmvh"
08:10:04 <clug> > map (+ 3) [5]
08:10:06 <lambdabot>   [8]
08:10:12 <roconnor> map (chr . succ . ord) clug === map (succ . chr . ord) clug === map (succ . id) clug === map succ clug
08:10:36 <clug> > map (chr . succ . ord) clug === map (succ . chr . ord) clug === map (succ . id) clug === map succ clug
08:10:37 <lambdabot>   Not in scope: `==='Not in scope: `==='Not in scope: `==='
08:10:41 <roconnor> because (chr . succ) = (succ . chr)
08:10:53 <clug> > map (chr . succ . ord) clug == map (succ . chr . ord) clug == map (succ . id) clug == map succ clug
08:10:54 <lambdabot>       precedence parsing error
08:10:54 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
08:11:02 <clug> > map (chr . succ . ord) clug == (map (succ . chr . ord) clug == map (succ . id) clug == map succ clug)
08:11:03 <lambdabot>       precedence parsing error
08:11:04 <lambdabot>          cannot mix `(==)' [infix 4] and `(==)...
08:11:06 <roconnor> and (chr . ord) === id ... hmm, might be some conditions on that
08:11:13 <mauke> @check \x -> chr (succ x) == succ (chr x)
08:11:14 <lambdabot>   "* Exception: Prelude.chr: bad argument
08:11:24 <roconnor> and (f . id) === f
08:11:42 <mauke> @check \x -> x < 0 || chr (succ x) == succ (chr x)
08:11:43 <lambdabot>   "OK, passed 500 tests."
08:12:17 <roconnor> oh, there are hypothesis on that law too.
08:12:40 <roconnor> @check \x -> 0 <= x ==> (chr . succ) x == (succ . chr) x
08:12:41 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
08:12:41 <lambdabot>           ...
08:12:56 <roconnor> @check \x -> (0 <= x) ==> ((chr . succ) x == (succ . chr) x)
08:12:57 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
08:12:58 <lambdabot>           ...
08:13:03 <roconnor> hmm?
08:13:05 <clug> @let rot13 x = map (chr  . + 13 . ord) x
08:13:05 <lambdabot>   Parse error
08:13:12 <clug> hmm
08:13:23 <roconnor> @let rot13 x = map (chr  . (+ 13) . ord) x
08:13:24 <lambdabot>  Defined.
08:13:29 <roconnor> @let rot13 = map (chr  . (+ 13) . ord)
08:13:29 <lambdabot>  <local>:6:0:
08:13:30 <lambdabot>      Equations for `rot13' have different numbers of arguments
08:13:30 <lambdabot> ...
08:13:32 <clug> oh
08:13:42 <roconnor> @undefine
08:13:47 <roconnor> @let rot13 = map (chr  . (+ 13) . ord)
08:13:48 <lambdabot>  Defined.
08:14:02 <clug> @rot13 5
08:14:03 <lambdabot> Unknown command, try @list
08:14:07 <clug> > rot13 5
08:14:08 <lambdabot>       No instance for (Num [Char])
08:14:08 <lambdabot>        arising from the literal `5' at <in...
08:14:19 <flipflap> Dayum~
08:14:20 <roconnor> @type rot13
08:14:21 <lambdabot> [Char] -> [Char]
08:14:34 <flipflap> > rot13 "Haskell"
08:14:35 <lambdabot>   "Un\128xryy"
08:14:43 <mauke> preflex: rot13 Haskell
08:14:43 <preflex>  Unfxryy
08:14:48 <endofjelly> is there something shorter than [a*4 | a <- [1..]]?
08:14:51 <roconnor> mauke: why didn't my check work?
08:15:00 <wli> augur: Okay, I've got your mapping from N^3 to N.
08:15:05 <mauke> roconnor: ==> is broken in lambdabot (apparently)
08:15:12 <flipflap> @src rot13
08:15:12 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
08:15:16 <flipflap> @src rot13
08:15:16 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:15:18 <roconnor> that's really really terrible
08:15:36 <endofjelly> (map (* 4) [1..]) is even longer
08:15:36 <clug> > lambda 3 5
08:15:37 <lambdabot>   Not in scope: `lambda'
08:15:52 <clug> how long does it take for it to undefine stuff/
08:15:55 <clug> ?*
08:15:55 <lambdabot> Maybe you meant: . ? @ v
08:16:06 <mauke> clug: until someone says @undefine
08:16:08 <roconnor> endofjelly: [4,8..]
08:16:10 <clug> oh
08:16:15 <roconnor> > [4,8..]
08:16:16 <lambdabot>   [4,8,12,16,20,24,28,32,36,40,44,48,52,56,60,64,68,72,76,80,84,88,92,96,100,...
08:16:22 <endofjelly> no way, that works? wow.
08:16:44 <wli> augur: I think I've got a general form for N^k to N.
08:16:45 <clug> > [1.3, 1.6, 1.9..]
08:16:46 <lambdabot>   <no location info>: parse error on input `..'
08:16:52 <clug> > [1.3, 1.6..]
08:16:53 <lambdabot>   [1.3,1.6,1.9000000000000001,2.2,2.5,2.8,3.0999999999999996,3.39999999999999...
08:17:00 <clug> 0_o
08:17:16 * roconnor wishes that Floats were not instances of Enum.
08:17:29 <roconnor> > map fromRational [1.3, 1.6..]
08:17:30 <lambdabot>   [1.3,1.6,1.9,2.2,2.5,2.8,3.1,3.4,3.7,4.0,4.3,4.6,4.9,5.2,5.5,5.8,6.1,6.4,6....
08:17:42 <wli> augur: Specifically sum [simplex (sum (take d xs)) d | d <- [0 .. k]]
08:18:00 <mauke> preflex: calc '2 1.9
08:18:01 <preflex>  1.11100110011001100110011001100110011001100110011
08:18:44 <clug> > map ord [0, 50]
08:18:45 <lambdabot>       No instance for (Num Char)
08:18:45 <lambdabot>        arising from the literal `0' at <inte...
08:18:53 <clug> > map ord [0..50]
08:18:54 <lambdabot>       No instance for (Num Char)
08:18:54 <lambdabot>        arising from the literal `0' at <inte...
08:19:17 <clug> oops
08:19:20 <clug> silly of me
08:19:26 <clug> > map chr [0..50]
08:19:28 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
08:19:40 <roconnor> ['\NUL'..]
08:19:43 <roconnor> > ['\NUL'..]
08:19:44 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
08:20:23 <clug> > map chr [97..122]
08:20:24 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
08:21:22 <Stinger> does Haskell have binary literals?
08:21:27 <clug> @girl19
08:21:27 <mauke> no
08:21:27 <lambdabot> well.. I never hacked Russians
08:21:39 <Stinger> hmm
08:21:49 <clug> @girl19
08:21:49 <lambdabot> I have been into not actually hacking, but social engineering
08:22:22 <clug> @protontorpedo
08:22:22 <lambdabot> check otu squeak seems dope
08:22:43 <pejo> clug, lambdabot answers to private messages.
08:23:14 <clug> ok
08:23:42 <mercury^> Are the personalities modeled after anyone specific?
08:23:51 <mauke> those aren't personalities
08:24:10 <wli> What's more awkward is inverting the mapping from N^k -> N.
08:24:45 <kerlo> @keal
08:24:45 <lambdabot> i dont really eat vegetables unless cheese is a vegetable
08:30:52 <clug> @fact rofl
08:30:52 <lambdabot> rofl: lol
08:30:57 <clug> @fact lmao
08:30:57 <lambdabot> lmao: lol
08:31:25 <clug> @fact lol
08:31:25 <lambdabot> lol: DCC SEND lolololololololololololololololol
08:31:36 <clug> wtf?
08:32:55 <weilawei> clug: awesome. you caused a netsplit somehow =P\
08:33:22 <Saizan> that wasn't a netsplit
08:33:37 <weilawei> sure looked like one from my POV...  bunch of dropped connections..
08:33:37 <psygnisfive> clug: its called a netsplit
08:33:45 <mauke> THAT WAS NOT A NETSPLIT
08:33:53 <psygnisfive> looks like one to me!
08:34:00 <p_l> ... fuck this DCC SEND shit, how the hell people got disconnected from it in the first place??
08:34:09 <mauke> then why did it say [Read error: 54 (Connection reset by peer)]?
08:34:09 <weilawei> p_l: probably didnt
08:34:10 <Axman6> clug: stop being a dick
08:34:15 <psygnisfive> oh did the channel get spammed?
08:34:18 <Axman6> @ops
08:34:18 <lambdabot> Maybe you meant: docs oeis pl
08:34:21 * EvilRanter notes "connection reset by peer" being the reason, rather than the usual "this server" "that server" message
08:34:23 <Axman6> hmm
08:34:25 <koala_man> haha
08:34:29 <clug> I was just saying random facts to lambdabot...
08:34:30 <Asztal> that wasn't a netsplit, it's an exploit
08:34:30 <Axman6> @where ops
08:34:31 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
08:34:31 <lambdabot> mauke
08:34:59 * Axman6 points the ops at clug for abusing \bot
08:35:08 <psygnisfive> wtf just happened
08:35:08 <psygnisfive> lol
08:35:13 <clug> it's not my fault some idiot recorded an exploit in lambdabot
08:35:13 <psygnisfive> if that wasnt a netsplit..
08:35:29 --- mode: ChanServ set +o dcoutts
08:35:30 <psygnisfive> adimit
08:35:35 <koala_man> don't blame clug for playing with the bot. blame the lamers who haven't upgraded their clients
08:35:36 <Axman6> clug: except that it was probably you (considering you were doing the same shit earlier)
08:35:37 <dcoutts> can someone explain what's going on please?
08:35:42 <Saizan> in a netsplit the quits have the names of the servers in them.
08:35:49 <clug> I never did dcc send exploits
08:35:52 <psygnisfive> ADIMIT
08:35:56 <clug> I messed with the bot
08:36:03 <clug> but not other people
08:36:05 * EvilRanter prods equanimity
08:36:05 <weilawei> well mauke and saizan had it right.. wasn't a netsplit. users dropped, not servers..
08:36:14 <mauke> psygnisfive: what?
08:36:18 <weilawei> anyone want to try again and see if it IS the bot and not something else?
08:36:23 <psygnisfive> mauke: your name is not adimit
08:36:34 <Lemmih> ?fact lol
08:36:34 <lambdabot> I know nothing about lol
08:36:37 <Saizan> clug: in any case, messing with the bots for no purpouse is not something you should do here
08:36:46 <clug> ok
08:36:49 <Saizan> clug: we already have a lot of traffic
08:36:52 <roconnor> Hey you all are being way to harsh on clug
08:37:04 <psygnisfive> oh hoh, look at that, already fixed?
08:37:07 <Axman6> he was the one causing the 03:14 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
08:37:08 <clug> I'll pm stuff from now on, thats fine
08:37:08 <dcoutts> can we get rid of that recorded dcc send message from lambdabot
08:37:09 <koala_man> I agree with roconnor!
08:37:14 <Axman6> earlier today
08:37:17 <psygnisfive> how did that happen!
08:37:25 <Zao> Axman6: I got one of those too, quite annoying.
08:37:25 <clug> axman, that doesn't do anything
08:37:34 <clug> whatever, I'll leave for the day
08:37:36 <roconnor> clug seems new here, and was just messing around with lambdabot
08:37:37 <Zao> p_l: As a DCC is a client-to-client connection, the failing point is craptastic home routers.
08:37:38 <Axman6> that's beside the point
08:38:15 <Zao> p_l: They want to be "helpful" and parse the IRC stream, looking for DCC connection requests for which it will auto-forward ports so a client-client conversation can take place.
08:38:17 <roconnor> that's what new people do.  It is fairly natural.
08:38:17 <p_l> Zao: Yes, but I'm trying to understand why they fail even if the stuff is mentioned in normal text
08:38:27 <Zao> p_l: Unfortunately, they suck hard at implementing it.
08:38:28 <roconnor> ... poor clug
08:38:38 <Zao> p_l: And as no users never ever upgrade firmware...
08:38:52 <p_l> Zao: I heard it was due to various "malicious filters"
08:39:05 <mauke> the workaround is to use different port than 6667
08:39:14 <Zao> Or not use retarded routers.
08:39:55 --- mode: ChanServ set -o dcoutts
08:41:16 <roconnor> Axman6: how was clug supposed to know that @fact lol would cause lambdabot to send a DDC thing?
08:41:19 * EvilTerran notes the "home router" theory doesn't really make sense for at least the folks on .ac.uk hostnames
08:41:39 <Axman6> roconnor: because he was doing the same sort of thing earlier.
08:41:43 <EvilTerran> roconnor, clug was messing around with lambdabot + DCC things a day or two ago
08:41:43 <mauke> it's also some "personal firewalls"
08:41:46 <psygnisfive> so im watching http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads/
08:41:53 <Axman6> and got \bot to DCC everyone in the chan
08:41:55 <psygnisfive> and i really get the impression that beckman is mildly drunk e.e
08:42:11 <mauke> Axman6: so he stumbled on a bug in lambdabot
08:42:16 <Saizan> Axman6: how?
08:42:19 <roconnor> Hmm
08:42:32 * roconnor reviews the logs
08:42:34 <mauke> and no, he didn't DCC us
08:42:46 <Axman6> yes, he got lambdabot to
08:42:48 <mauke> no
08:43:02 <Axman6> how no?
08:43:11 <mauke> no, he didn't
08:43:11 <Zao> EvilTerran: Dorms?
08:43:28 <tibbe> I get a kind error when trying to write a MonadTrans instace. Could someone please have a look? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4765#a4765
08:43:37 <Zao> Axman6: 19:14 CET yesterday?
08:43:49 <Zao> 19:14 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
08:43:50 <EvilTerran> Zao, well, .ac.uk is british universities, so dorms, labs or similar
08:44:00 <Axman6> i have no idea when that was. but it was around 23 hours ago
08:44:04 <Axman6> 22.5ish
08:44:23 <cocon> How is Data.Derive.Binary.makeBinary supposed to be used?
08:44:32 <Zao> I was most definitely not playing with lambdabot then, so someone has gotten on her good side :)
08:44:49 <Saizan> tibbe: it looks like you miss a parameter to ResultT r in the definition of IterateeT
08:45:11 <mauke> @elite foo
08:45:22 <mauke> that's the bug
08:45:24 <tibbe> Saizan: that was it thanks
08:45:28 <roconnor> mauke: heh, the ops are going to ban you now.
08:45:39 <mauke> they should ban lambdabot instead
08:45:46 <roconnor> I agree
08:45:49 <Saizan> so, is he going to ban himself?:)
08:45:54 <dcoutts> heh
08:46:33 <mauke> note: this is just a simple text message; no dcc attempt or anything
08:46:48 <gwern> curious. we can't fix the problem that users can add arbitrary text into lb...
08:46:50 <Leftblank> Say I've got a data Tree defined as "data Tree = Empty | Node (String, Int) (Tree) (Tree)"; what would be the construct for this? I've been fiddling around with this for a little but cant seem to find the right way, tutorials I've found on the web only use trees with one property on the node, which is causing the trouble ;x
08:46:52 <cocon> what's dcc?
08:46:56 <EvilTerran> came up as a CTCP request here
08:47:02 <gwern> maybe we need to filter the string 'dcc'
08:47:12 <Zao> cocon: http://en.wikipedia.org/wiki/Direct_Client-to-Client
08:47:18 <dcoutts> gwern: or escape certain chars in lambdabot output?
08:47:20 <mauke> EvilTerran: yes
08:47:22 <Saizan> aren't DCC requests just CTCP requests? which in turn are just messages with ^A in them?
08:47:33 <EvilTerran> gwern, surely stripping out the non-printable characters would be the way to do it?
08:47:49 <gwern> dcoutts: my understanding of the dcc send exploit was that 'dcc send' + >10 or whatever characters alone was enough to trigger it
08:47:55 <Saizan> Leftblank: what do you mean by construct?
08:47:58 <gwern> just alphanums
08:48:15 <roconnor> no punctuation?
08:48:30 <EvilTerran> Leftblank, if you have your data definition in a .hs file, loading it in ghci and asking it ":t Empty" and ":t Node" may be informative
08:48:31 <mauke> well, that should be easy to test
08:48:35 <gwern> prett sure you don't need punctuation
08:48:45 <Leftblank> EvilTerran, thanks, will try that out
08:48:54 <roconnor> gwern: facts don't need punctuation?
08:49:10 <Leftblank> Saizan, I'll see if this helps, I meant the way to set up one of these objects though
08:49:33 <EvilTerran> Leftblank, note that constructors (like Empty and Node) are functions that return a value of the type they construct
08:49:50 <gwern> roconnor: do they? my point was that even if we strip special chars and punctuation, @fact could still be used for dcc send
08:49:54 <Saizan> Leftblank: e.g. Node ("foo",1) Empty (Node ("bar",2) Empty Empty) is one
08:50:06 <Leftblank> bingo, misconception on my side
08:50:11 <Leftblank> thanks a lot Saizan & EvilTerran
08:50:17 <Leftblank> this should get me going
08:50:19 <michaelcdever_> hey all, anyone know how to set up eclipseFP on OSX, using macports GHC??
08:50:29 <roconnor> gwern: don't you need control characters for dcc send?
08:50:36 * roconnor doesn't know much
08:50:40 <mauke> DCC SEND AAAAAAAAAAAAA
08:50:49 <juturnas> How can I load a binary file of floats generated by C?  I think I need to instance Binary CFloat, but I can't quite figure it out
08:50:58 <mauke> roconnor: we're not talking about actual DCC requests here
08:51:09 <Saizan> juturnas: i'd use Storable
08:51:14 <gwern> yeah, that's the really stupid part about the bugs
08:52:05 <juturnas> Saizan, thanks, checking that out now
08:53:07 <roconnor> mauke: why didn't your post hit the routers?
08:53:30 <gwern> 'The router exploit, in particular, may be triggered when the phrase 'DCC SEND ' followed by at least 11 characters without spaces or newlines appears anywhere in a TCP stream on port 6667, not just when an actual DCC SEND request has been made.
08:53:36 <mauke> again: DCC SEND AAAAAAAAAAAAA
08:54:11 <roconnor> Perhaps we should just filter capital C's from lambdabot :)
08:56:45 <Saizan> removing most "useless" commands like @elite would probably help by itself
08:56:47 <psygnisfive> lolwtf
08:56:59 <psygnisfive> yes well, adimit runs lambdabot doesnt he?
08:57:01 <gwern> Saizan: but people might complain!
08:57:14 <Saizan> psygnisfive: no
08:57:22 <mauke> who is adimit?
08:57:23 <psygnisfive> oh? i thought he did
08:57:27 <roconnor> mauke: I don't get why your plain text doesn't cause the problem.
08:57:41 <mauke> yet again: DCC SEND AAAAAAAAAAAAA
08:57:45 <mauke> there we go
08:57:48 <wh1t3> lol
08:57:51 <EvilTerran> seems to me you could post-process lambdabot's output for that particular exploit
08:57:55 <dcoutts> you can't take @yarr away from me, I'll be bereft!
08:58:00 <roconnor> mauke: right, why are the control characters needed?
08:58:18 <mauke> roconnor: because these routers/firewalls look for them, apparently
08:58:24 <Saizan> well, @yarr doesn't take user input :)
08:58:39 <Qork> @elite
08:58:40 <gwern> EvilTerran: I'd have to look at the source to see whether it's easier to filter 'DCC SEND' out in input or output
08:58:40 <lambdabot> Say again?
08:58:40 <roconnor> mauke: sounds like the wikipage isn't accuate
08:58:46 <dcoutts> Saizan: true true
08:59:12 <roconnor> gwern: doesn't mauke's experiments show that only control characters need to be filtered?
08:59:42 <gwern> I doubt it. I was banned from freenode for dcc send for 3 weeks, and I certainly used no control chars...
08:59:52 <mauke> equanimity, Twey, silentbob__, aweber, nA1828KcFz9q, Debugger, goomba, Cthulhon|, TehZorroness, telemachus, daxhuiberts, intrados: your internet connection suffers from the "DCC SEND" exploit. check your routers or firewalls
09:00:11 <mauke> maybe this is a new and "improved" hole
09:00:43 <roconnor> gwern: But look at mauke's experiments
09:00:44 <cocon> Can someone help me with using Data.Derive.Binary?
09:01:09 <roconnor> gwern: we can certainly see that filtering control characters all but eliminates the problem.
09:01:21 <roconnor> and should be relatively easy to implement.
09:01:21 <Zao> roconnor: Not enough glyphs, I believe.
09:01:27 <gwern> filtering 'DCC SEND' would eliminate the problem entirely
09:01:44 <mauke> no, because I don't need lambdabot to send arbitrary text to the channel
09:02:13 <Qork> anyoen used scala a lot?
09:21:24 --- topic: '["Real World Haskell: out now", "#haskell-in-depth launched!", "Haskell News:  http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste:  http://moonpatio.com", "Logs: http://tunes.org/~nef/logs/haskell/"]'
09:21:24 --- topic: set by glguy on [Sun Mar 01 16:39:50 2009]
09:21:30 <psygnisfive> which sort of threads the values through safe space
09:21:35 <bremner> p_l: also first
09:21:48 <psygnisfive> oh no clog is back D:
09:21:56 <psygnisfive> DONT YOU TOUCH LAMBDABOT D:
09:22:08 <wh1t3> mauke, that is just translation done by the compiler or libraries or whatever though
09:22:10 <Saizan> clog is the logging bot.
09:22:21 <wh1t3> i dont know much about C, but java does something similar
09:22:21 <mreh> no client side haskell?
09:22:26 <mauke> wh1t3: "just"?
09:22:28 <psygnisfive> oh. then it was .. clug earlier?
09:22:30 <psygnisfive> SHADY
09:22:40 <Saizan> mreh: yhc can compile to javascript
09:22:54 <mreh> ooh
09:23:05 <wh1t3> you can write it yourself, then you need to take the system used into account. If you use methods to write and read lines from the API, it will check the system type it is running on and the translate accordingly
09:23:18 <psygnisfive> saizan: compile to JS? i'd love to see some code thats produced by this process
09:23:37 <mreh> as long as it works
09:23:43 <mreh> who's bothered
09:24:52 <Saizan> i've personally never used it, but you can google for yhc javascript
09:25:09 <mauke> so my points are: '\n' is always a single character; "hex codes" don't make a difference; "\r" and "\n" don't make sense when talking about on-disk representations (or binary stuff)
09:26:22 <michaelcdever_> noone?
09:27:16 <Saizan> michaelcdever_: what was your question?
09:27:58 <michaelcdever_> im trying to get eclipseFP working on osx
09:28:26 <wh1t3> mauke, C does not specifically map \n and \r to LF and CR respectively. Other languages do. PHP/Java/Pyhon... all ensure \n and \r actually represent LF and CR. So I dont think its bad to use \r and \n in that sense
09:28:55 <wh1t3> although i agree LF and CR provide more clarity
09:28:55 <michaelcdever_> and its saying that there is "no compiler implemented", but if i click the FP button, it has detected it
09:29:05 <wh1t3> anyways, time for diner :)
09:29:31 <tibbe> I'm trying to lift a Cont to a ContT
09:29:35 <tibbe> is it possible?
09:30:10 <Saizan> you mean Cont r a -> ContT r m a ?
09:30:59 <Saizan> ?type let foo (Cont m) = ContT m in foo
09:31:00 <lambdabot> forall (m :: * -> *) r t. Cont (m r) t -> ContT r m t
09:31:30 <tibbe> Saizan: yes
09:31:48 <tibbe> Saizan: actually my monad is similar to Cont (the code I pasted before)
09:31:53 <mauke> wh1t3: does PHP even run on platforms where '\n' is not LF in C?
09:32:52 <tibbe> Saizan: hmm, I was trying to do something with return
09:32:57 <tibbe> Saizan: let me paste my code
09:33:55 <Saizan> k
09:36:20 <tibbe> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4766#a4766
09:36:46 <tibbe> Saizan: lifting might not be the right word, I want to run the side effect free Iteratee monad using the state form the IterateeT monad
09:37:57 <wli> What I'm using right now is this: let n = 100 ; chains = array (1, n) $ (1, Set.fromList [IntSet.singleton 1]) : [(k, Set.filter (\is -> IntSet.size is == bestSize) ps) | k <- [2 .. n], let ps = Set.fromList $ concat [[IntSet.insert k $ u `IntSet.union` v | u <- Set.toList $ chains ! i, v <- Set.toList $ chains ! j] | i <- [1 .. k - 1], let j = k - i, i >= j], let bestSize = Set.findMin $ Set.map IntSet.size ps] in mapM_ print . Set.toList $ chains ! n
09:39:17 <Saizan> tibbe: i think it's possible, let me try
09:39:27 <tibbe> Saizan: thanks :)
09:43:13 <Saizan> tibbe: uhm, the idea is to recursively unfold the Result while keeping the Stream -> m (ResultT m a) around to apply at the end
09:43:39 <tibbe> Saizan: hmm, sounds right
09:43:49 <tibbe> Saizan: but I didn't manage to get it right
09:44:00 <tibbe> Saizan: I ended up adding new returns all the time
09:44:11 <tibbe> Saizan: but I see what you mean
09:44:35 <mreh> could haskell compile to AS3?
09:44:41 <mreh> in theory
09:45:31 <badtruffle> you can pretty much compile it to anything, in theory
09:46:10 <Saizan> tibbe: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4766#a4767
09:46:22 <mreh> yeah, well you have callbacks in as3, it would make it a whole lot easier
09:46:44 <mreh> haskell syntax just makes things nicer
09:47:57 <mreh> as well as the other benefits
09:48:05 <tibbe> Saizan: looking
09:48:49 * wli wonders if the Set usage is hurting things.
09:50:26 <tibbe> Saizan: that works. Thanks again for the help
09:56:52 <Qork> woah all the small goodies in haskell that doesnt make a big difference by themseklves really make a huge one together
09:57:03 <Qork> and the typesystem really is insanely good
09:57:19 <Qork> trying another "good" language like scala makes me just apprciate haskell even more
09:59:56 <ziman> what's worse about scala? (i've never tried it, i'm just asking)
10:00:26 <Qork> typesystem does less inferecning and seems breakable
10:00:31 <Qork> more verbose
10:00:43 <Qork> restricted by the jvm probably
10:00:49 <copumpkin> it's not pure
10:00:51 <Qork> haskells concurrency seems more solid
10:00:56 <Qork> yeah not pure
10:01:32 <copumpkin> no TCO
10:02:59 <Saizan> type inference is much harder with subtyping
10:03:11 <Neophyte> Anyone have any recommendations (books, sites, pdfs) for beginning in haskell?
10:03:23 <Saizan> @where LYAH
10:03:23 <lambdabot> www.learnyouahaskell.com
10:03:30 <Neophyte> I never programmed, and want to basically self teach this to myself.
10:03:44 <Saizan> then LYAH looks like the right choice
10:03:49 <Neophyte> alright
10:03:50 <copumpkin> ooh, no prior imperative knowledge to pollute your preconceptions!
10:03:55 <Neophyte> thanks.
10:03:56 <hatds> I recommend watching "A taste of Haskell" -- gives a very good first pass of the unique things about  Haskell
10:04:01 <copumpkin> we'll be here to answer any questions :)
10:04:07 <Qork> copumpkin: sure it doesnt have TCO? i know you can do the typical wrap a function in a function to tco
10:04:35 <hatds> ^ maybe ignore my suggestion if you don't have prior programming expertise
10:04:49 <Neophyte>  "A taste of Haskell" - where can I view this?
10:04:59 <Neophyte> oh
10:05:04 <Saizan> Neophyte: this is also good: http://www.cs.nott.ac.uk/~gmh/book.html
10:05:08 <copumpkin> Qork: last I heard it ran into the same issue that prevented the lambdavm from being inefficient, an actual limitation of the jvm's instruciton set
10:05:18 <hatds> Neophyte: http://www.haskell.org/haskellwiki/Video_presentations
10:05:23 <copumpkin> *efficient
10:06:11 <Neophyte> ty
10:06:12 <copumpkin> http://wiki.brianweb.net/LambdaVM/Implementation talks about it a bit (in a haskell context) but it's an ugly hack
10:06:29 <Neophyte> well I do mess around in mathematical logic a lot
10:06:32 <Neophyte> i heard haskell helps
10:06:48 <Neophyte> (well I just began messing around in math logic, first order logic, predicate calculus, set theory)
10:06:51 * mux enjoys ghc 6.10.3
10:07:04 <mux> no more problems building with libedit/libreadline thanks to haskeline
10:07:06 <Neophyte> so I am excited to finally learn a computer programming language
10:07:26 <pejo> Saizan, it can be solved though, either you make the inference algorithm not complete, or live with wieldy types. :-)
10:08:07 <Qork> prevented from being inefficient? :P
10:08:57 <hatds> that's almost not a good thing!
10:09:30 <Saizan> Neophyte: cool :) if you also like category theory you'll have a lot in common with the community :)
10:10:24 <roconnor> are wieldy types related to wobbly types?
10:10:24 <copumpkin> Qork: I corrected myself :P
10:11:55 <pejo> roconnor, heh, I missed an "un" before that. I wasn't using it in any formal sense though, the inferred types just turn out to be very long for even simple functions.
10:12:26 <wli> Somehow I'm massacreing IntSet with using Integer as a bitmap.
10:13:06 <jethr0> Neophyte: you'll be surprised how much time one tends to spend on debugging and working out the own stupid mistakes ^_^
10:13:16 <copumpkin> wli: you mean your Integer is faster? I'd expect that
10:13:34 <wli> copumpkin: Well, built-in Integer used as a bitmap.
10:13:40 <copumpkin> yup
10:14:12 <copumpkin> makes sense
10:14:53 <Neophyte> heh.
10:15:17 <Neophyte> I'm sure I'll be debugging a lot due to my own stupidity
10:15:45 <wli> copumpkin: Why? IntSet sucks or something?
10:15:47 <Saizan> fortunately we've a type system that catches a lot of that
10:16:53 <copumpkin> wli: Integer is just a big chunk of memory, testing for membership should be as simple as dividing the query by 8, reading that byte in memory, and doing some simple bitmath
10:17:09 <copumpkin> however, it will use O(maxkey) space
10:17:21 <wli> Why aren't IntSets anywhere near as fast?
10:17:35 <copumpkin> they're tree-based, so involve a lot more jumping around, but are sparse
10:17:43 <copumpkin> you only use as much space as the elements you put in
10:17:57 <copumpkin> if I inserted 10000000 into an Integer-based set, it'd get quite big
10:18:42 <wli> It's possible to handle sparseness without quite that big a breakdown in time/space efficiency for dense sets, but anyway.
10:19:10 <copumpkin> you could make a bloomfilter or something
10:19:41 <Saizan> i guess IntMap makes more sense as a tree
10:19:45 <wli> I don't even know what a bloomfilter is.
10:20:10 <copumpkin> it's an efficient set that supports querying and adding (no removal), but you might get false positives :P
10:20:27 <copumpkin> it's a cute idea: http://en.wikipedia.org/wiki/Bloom_filter
10:21:51 <wli> I usually think of range trees with bitmaps sitting beneath the ranges for densely-populated sub-ranges.
10:22:27 <wli> (and just a bitflag for fully populated sub-ranges)
10:22:32 <copumpkin> you should make a hybrid IntSet and stick it on hackage! :)
10:22:52 <wli> If I could still code my way out of a wet paper bag I would.
10:23:16 <wli> I don't know that I'd call it a hybrid IntSet. I would literally think of that as just an IntSet.
10:23:37 <copumpkin> well, hybrid between bit array and treeset or something :P
10:24:02 <wli> My understanding of all this is that what I described is vaguely standard.
10:24:21 <wli> What's your definition of "treeset" BTW?
10:24:38 <wli> Range trees may not necessarily coincide with such.
10:24:48 <copumpkin> just some form of a balanced tree-based algorithm for implementing sets
10:24:59 <copumpkin> don't really have too specific an idea :) but I think range trees would fit
10:25:13 <wli> Range trees are balanced binary trees of disjoint closed intervals.
10:25:27 <Feuerbach> Is unzip for general functors defined somewhere?
10:25:37 <Feuerbach> unzip x = (fmap fst x, fmap snd x)
10:25:39 <copumpkin> yeah, I remember covering them in my algorithms course
10:26:00 <roconnor> funzip
10:26:02 --- mode: ChanServ set +o mauke
10:26:02 --- mode: mauke set +b *!*@dslb-084-056-108-092.pools.arcor-ip.net
10:26:04 <roconnor> unfzip
10:26:26 <Feuerbach> :t unfzip
10:26:27 <copumpkin> :o mauke
10:26:28 <lambdabot> Not in scope: `unfzip'
10:26:32 <Feuerbach> :t funzip
10:26:33 <lambdabot> Not in scope: `funzip'
10:26:45 <roconnor> I guess not
10:27:02 --- mode: mauke set -o mauke
10:27:20 <Saizan> there's one in category-extras i think
10:27:56 <roconnor> category-extras should be in the haskell platform. :P
10:28:01 <wli> The idea is that when you get adjacent ranges that are at the right distance (close enough?) and whatever enough that using a bitmap beneath a merged range would save memory you do it.
10:28:54 <Feuerbach> Saizan: thanks!
10:31:02 <a_guest> How do I remove a systemcabal package
10:31:28 <Saizan> define system cabal package
10:31:31 <a_guest> ...system-wide installed cabal package?
10:31:55 <Saizan> ah, ghc-pkg unregister $package
10:32:09 <Saizan> with sudo probably
10:34:13 <a_guest> 'ghc-pkg unregister ...' did not erase the newly installed files? Should it be done manually?
10:34:45 <copumpkin> bah, gtk2hs won't build
10:35:02 <Saizan> a_guest: yes
10:35:36 <algal> my newbie question: I'm using emacs with GHC. Can I configure my REPL to give me auto-complete of defined bindings etc.?
10:36:01 <mreh_> what char is left arrow?
10:36:45 <mreh_> as in pressing the left arrow in the keyboard
10:36:59 <bavardage> mreh_: in what form?
10:37:07 <bavardage> mreh_: it's not a character afaik
10:37:11 <bavardage> mreh_: rather a keycode
10:37:24 <bavardage> i.e. when doing xlib programming you get a left-arrow keycode
10:37:51 <bavardage> I think some terms do represent it as a character though
10:38:01 <bavardage> you can see the escape codes in some curses apps when things screw up
10:38:15 <pshc> Is there a nice way to write \(a, b, c, d, e) -> f a . f b . f c . f d . f e ? Is this Foldable or something?
10:38:53 <mreh_> apparently this method returns a char for a key press
10:39:00 <mreh_> i'll have to look at the implementation
10:39:07 <mreh_> in the SOE library
10:39:57 <bavardage> mreh_: can't you just try it out?
10:40:10 <mdmkolbe1> Haskeline is breaking for me.  The example program listed on http://hackage.haskell.org/packages/archive/haskeline/0.6.1.3/doc/html/System-Console-Haskeline.html won't accept any keys that start with ESC (e.g. left arrow).  Any ideas?
10:40:13 <bavardage> call the function, see what return value you get
10:40:24 <mreh_> i need to make a comparison, i need the literal for the left arrow, right arrow etc
10:40:28 <bavardage> oh kk
10:41:57 <bavardage> pfft the doc for that seems strangely lacking
10:42:20 <bavardage> all libraries like that that I've used usually define named constants for special keys like that
10:43:29 <mreh_> yeah SOE doc is invisible
10:44:29 <mdmkolbe1> I've checked System.???.Terminfo and the arrow keys are reporting correctly (^[[A, etc)
10:45:42 <mdmkolbe1> but with haskeline the arrow keys just beep and print [A
10:46:02 --- mode: ChanServ set +o mauke
10:46:02 --- mode: mauke set -b *!*@dslb-084-056-108-092.pools.arcor-ip.net
10:46:17 <mdmkolbe1> oddly pressing ESC and tryping the key in directly beeps at the ESC directly
10:47:02 --- mode: mauke set -o mauke
10:47:30 <mdmkolbe1> control keys that don't start with ESC seem to work fine
10:47:36 <mreh_> the ESC historically for escaping
10:49:09 <mdmkolbe1> but the ESC ascii char (not the keyboard button), is the start of the encoding for left-arrow
10:49:10 <mreh_> i've seen isLeftKey in some software, i'm trying to find where it is implemented
10:49:13 <mreh_> it's not in SOE
10:51:18 <mdmkolbe1> If Haskeline were doing timing based "ESC" detection, it might explain things, but I don't see that anywhere in the Haskeline docs.  (i.e. "ESC [ D" is treated as left arrow but "ESC (time delay) [ D" is not)
11:05:27 <skorpan> :t (=)
11:05:28 <lambdabot> parse error on input `='
11:08:27 <mdmkolbe1> :t (==)
11:08:28 <lambdabot> forall a. (Eq a) => a -> a -> Bool
11:13:38 <mreh_> is there a tool that can show me the context of a reference in my source
11:14:22 <mreh_> I'm still stuck developing on Windows
11:16:07 <Zao> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ floats my boat pretty well.
11:16:16 <Zao> Although that requires you to use, well, vim.
11:16:36 <Zao> I'm sure that Emacs has similiar tools.
11:46:42 <mreh_> I can't get it to work, waaaa
11:47:09 <mreh_> Key {char::Char, isDown::Boolean}
11:47:18 <mreh_> but how do i know if i've pressed the left arrow
11:48:04 <mreh_> i've seen people pass char to a mystery function
11:48:20 <mreh_> so left arrow must be character encoded
11:48:22 <mdmkolbe1> Is there a way to tell GHCi to load a module that is hidden?
11:49:50 <mreh_> haskell chars are 8bit ascii encoded right>
11:50:40 <mdmkolbe1> mreh_: I think they are more than 8 bit chars
11:50:58 <mreh_> oh, 16bit unicode
11:51:16 <mdmkolbe1> mreh_: try 32(21)
11:51:28 <trofi> >maxBound :: Char
11:51:29 <Zao> A Char is a proper codepoint.
11:51:31 <mdmkolbe1> that is to say that Haskell chars are Unicode code points
11:51:33 <trofi> > maxBound :: Char
11:51:35 <lambdabot>   '\1114111'
11:51:40 <Zao> All 21 glorious bits in a single value.
11:51:47 <trofi> > 01114111
11:51:48 <lambdabot>   1114111
11:52:03 <Zao> mreh_: The standard IO functions truncate to 8 bits though.
11:52:18 <Zao> Use something competent like utf8-string or the awesome Text module to do it right.
11:52:26 <trofi> > o1114111
11:52:27 <lambdabot>   Not in scope: `o1114111'
11:52:38 <trofi> > 0o1114111
11:52:40 <lambdabot>   301129
11:52:58 <mdmkolbe1> > 0x10FFFF
11:52:59 <lambdabot>   1114111
11:53:16 <mdmkolbe1> trofi: it's already in decimal
11:53:27 <trofi> heh
11:53:41 <Zao> 4, the third binary digit.
12:04:03 <syntaxfree> who runs comonad.com?
12:04:13 <Saizan> edwardk
12:04:28 <syntaxfree> it's down :(
12:04:33 <syntaxfree> I never really saw it.
12:05:03 <syntaxfree> @tell edwardk the idea of a "Comonad Reader" sounds really cool. comonad.com is down, though.
12:05:03 <lambdabot> Consider it noted.
12:06:07 <duaneb> > class Foo a b where (*.) :: a -> b -> a
12:06:08 <lambdabot>   <no location info>: parse error on input `class'
12:06:14 <duaneb> oh, right
12:06:57 <duaneb> why are multi-parameter classes not allowed?
12:07:55 <Saizan> duaneb: no definition is allowed
12:08:03 <mdmkolbe1> How do I comple an HSC file?
12:08:12 <Saizan> duaneb: it just evaluates expressions
12:08:17 <Saizan> mdmkolbe1: hsc2hs
12:08:33 <mdmkolbe1> Saizan: thanks.
12:08:41 * mdmkolbe1 wishes ghc would do that autmoatically
12:08:52 <duaneb> Saizan: yes, but that doesn't change my problem :P
12:09:11 <Saizan> duaneb: what's your problem?
12:09:31 <duaneb> multi-parameter classes
12:09:42 <duaneb> such as: class Foo a b where blah :: a -> b -> a
12:09:53 <Saizan> what about them?
12:10:02 <duaneb> they aren't allowed
12:10:07 <duaneb> and I don't quite understand why :/
12:10:21 <Saizan> you need {-# LANGUAGE MultiParamTypeclass #-} at the top of your file to enable them
12:10:26 <arjanb> syntaxfree: btw most code from edwardk's blog is in: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
12:11:05 <Saizan> MultiParamTypeclasses maybe
12:11:29 <duaneb> Saizan: thanks
12:36:59 <duaneb> is there a haskell-ish method of equivilant vs equal?
12:37:24 <skorpan> what does equivalent mean to you?
12:37:38 <duaneb> as in: my and my twin brother are equivalent but not equal
12:37:47 <duaneb> or rather, my twin brother and I
12:37:51 <Badger> 19:16:20 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
12:37:54 <Badger> erk?
12:38:07 <skorpan> duaneb: what properties to you and your brother have in common?
12:38:17 <Elly> test.hs:2:11: Pattern syntax in expression context: λ x -> x + 1
12:38:22 <Elly> this is the saddest thing :(
12:38:30 <duaneb> skorpan: In this case, our opcode :)
12:38:46 <skorpan> duaneb: ask what you want to ask, skip the metaphores :P
12:39:01 <duaneb> ok
12:39:16 <duaneb> let's look at associations for a dictionary
12:40:00 <duaneb> ("foo", 1) would have "foo" yield 1
12:40:19 <duaneb> I would declare ("foo", 1) and ("foo", 2") to be equivalent but NOT equal
12:40:54 <duaneb> is there a haskell-ish way to declare this?
12:41:18 <mauke> I don't get it
12:41:44 <Tobsan> Me neither
12:41:52 <Lemmih> duaneb: (==) `on` fst?
12:42:03 <duaneb> ok
12:42:05 <duaneb> umm
12:42:36 <duaneb> which method of comparing associations (i.e., by keys or by keys AND values) should I have (==) be?
12:42:52 <skorpan> keys and values
12:43:11 <duaneb> ok
12:45:21 <copumpkin> you could define ====
12:45:23 <roconnor> @hoogle equating
12:45:23 <lambdabot> Distribution.Simple.Utils equating :: Eq a => (b -> a) -> b -> b -> Bool
12:45:23 <copumpkin> or ===
12:50:12 <mux> @pl \x y -> f x (g y)
12:50:13 <lambdabot> (. g) . f
12:50:37 <skorpan> almost looked like S for a while
12:50:53 <mreh_> case statements, how can I make a default behaviour?
12:50:53 <mreh_> case Int of <- 1 -> do xyz; 2 -> abc; otherwise -> bleh;
12:50:53 <mreh_> that syntax is all wrong
12:51:06 <copumpkin> just use _
12:51:11 <copumpkin> or something else
12:51:12 <skorpan> mreh_: use _, but case Int of?
12:51:13 <copumpkin> put it last
12:51:32 <skorpan> all of that syntax is messed up
12:51:55 <copumpkin> calling it otherwise is fine, but it might indicate confusion on your part ;)
12:52:13 <mreh_> so it's a varible
12:52:17 <copumpkin> and if you want a guard there, it might get a little horny
12:52:20 <copumpkin> *thorny, lol
12:52:30 <mreh_> i used a type variable instead of a name
12:52:31 <mreh_> so SHOOT me!
12:52:38 <skorpan> that's not a type variable
12:52:50 * copumpkin shoots mreh_
12:52:59 <mreh_> (*) :: Int -> Int -> Int
12:53:08 <skorpan> those are types, not type variables
12:53:49 <mreh_> foldl :: (a -> a -> b) -> b -> [a] -> b
12:53:55 <mreh_> those are type variables
12:53:58 <copumpkin> yup
12:53:58 <skorpan> yes, those are
12:54:34 <mreh_> i have redeemed myself
12:54:56 <copumpkin> mreh_: only once you describe the dreaded loop function, are you fully redeemed!
12:55:08 <mreh_> i would like a haskell tool where i could just click on a name and get it's context
12:55:19 <copumpkin> yeah, me too
12:55:27 <skorpan> what do you guys mean?
12:55:35 <mreh_> ever used eclipse?
12:55:36 <copumpkin> well, I think I mean what mreh_ means
12:55:41 <skorpan> which names it can "reach"?
12:55:51 <mreh_> what name it is referring to
12:55:52 <copumpkin> I'd like to be able to click on a name and get its unified type
12:55:53 <copumpkin> oh
12:55:59 <mreh_> it searches your namespace
12:55:59 <skorpan> heh
12:56:15 <mreh_> and tells you what package it's from
12:56:29 <copumpkin> :i already does that in ghci, shouldn't be too hard to add
13:01:07 <mreh_> &c &c
13:01:07 <mreh_> then i have to compile the module each time
13:01:07 <mreh_> but, good call
13:01:07 <mreh_> IOExts, anyone heard of that?
13:01:08 <mreh_> oh, i spelt it wrong in google
13:02:32 <duaneb> is there a way to do ranges in haskell expressions?
13:02:37 <duaneb> like you can in c?
13:02:47 <duaneb> 1..5 doesn't work for me :/
13:02:51 <solrize> [1..5]
13:02:52 <LeoD> [1..5]
13:02:57 <solrize> > [1..5]
13:02:59 <lambdabot>   [1,2,3,4,5]
13:03:02 <copumpkin> ranges in c?
13:03:03 <duaneb> sorry, in case expressions
13:03:07 <duaneb> yea
13:03:18 <copumpkin> ?
13:03:44 <duaneb> switch(var){case 1 .. 3
13:03:48 <duaneb> : blah;}
13:03:57 <skorpan> you can't do that
13:04:12 <BMeph> You can do ranges in C? I thought that was just a Python thing. :)
13:04:14 <skorpan> use x -> if x `elem` [1..3] then...
13:04:20 <copumpkin> I've never seen that in c, ever
13:04:28 <copumpkin> is it a c99 thing?
13:04:41 <skorpan> BMeph: there are no switches in python afaik, but ruby has that kind of thing
13:05:21 <cocon> is there a security risk in calling decode on a BinaryString received by an untrusted client?
13:05:28 <copumpkin> decode?
13:05:38 <cocon> in the Binary typeclass
13:05:44 <duaneb> copumpkin: gcc extension, maybe
13:05:50 <solrize> cocon, there better not be
13:05:57 <duaneb> so, gnu99
13:06:00 <solrize> haskell doesn't have "eval" if that's what you're thinking
13:06:10 <BMeph> I know you can use multiple case labels for the same option, and you can do ranges in cases in OCaml - which I'd l;ike to see in Haskell, although I've never felt the need for it personally - but I never saw any ranged cases in C.
13:06:28 <cocon> solrize: yeah, I hade a vague fear of sth like that
13:06:43 <BMeph> skorpan: I meant the ranges thing, not specifically ranges of cases in a switch statement. :)
13:06:47 <duaneb> so
13:06:53 <duaneb> anyone know what to do?
13:06:59 <copumpkin> for a range?
13:07:00 <skorpan> BMeph: ah... well, ruby has ranges in switches ;)
13:07:06 <copumpkin> duaneb: just use a guard?
13:07:07 <duaneb> I mean, worst case in c, I do case 1: case 2: case 3: case 4: case 5:
13:07:20 <duaneb> and I can't even do that in haskell, I do think
13:07:25 <duaneb> copumpkin: what do you mean?
13:07:43 <solrize> cocon, hmm, maybe better check that there's no format like (length b1 b2 b3...) where you can get a bad result if length is set to something invalid
13:07:48 <copumpkin> -> x | x > 5 && x <= 10
13:08:00 <BMeph> skorpan: I've never used Ruby, so I know only what I've heard of it. Interesting, though. :)
13:08:07 <duaneb> copumpkin: huh.
13:08:55 <skorpan> BMeph: not to bore you with details, but i think you can use regexen in ruby switches for matching as well!
13:08:56 <cocon> solrize: sorry, I don't understand
13:09:00 <BMeph> copumpkin: or even  x | x`elem`[6..10] :)
13:09:04 <copumpkin> yeah, ruby uses === for switches
13:09:06 <pshc> Hmm, {-# LANGUAGE AllowOverlappingInstances #-} is giving me an unsupported extension error in ghc 6.10.2
13:09:11 <copumpkin> which means it's as slow as doing a bunch of comparisons
13:09:19 <copumpkin> BMeph: that'd be a bit slower though if the range is wide
13:09:27 <cocon> solrize: oh, lists are actually encoded that way
13:09:41 <copumpkin> pshc: I think it doesn't have Allow on the front
13:09:50 <solrize> cocon, yeah, i'm wondering what happens if you slip a bogus encoding in
13:10:09 <BMeph> copumpkin: Or I guess you can cheat and use the function from Ix, whose name escapes me now.... :)
13:10:20 <pshc> copumpkin: Ah, excellent, thanks!
13:10:35 <Gracenotes> hm. I had a weird dream last night I had to drop a class.
13:10:36 <mreh_> what is "]" short for in haskell speak?
13:10:36 <mreh_> use if statements
13:10:36 <mreh_> case 1, 2, 3, 4, 5
13:11:20 <BMeph> copumpkin: Oh, yeah, "inRange", it even sounds like a better fit. :)
13:12:45 <BMeph> x | (6,10)`inRange`x = ...
13:13:27 <copumpkin> that looks backwards
13:14:09 <cocon> solrize: it raises an exception
13:14:36 <BMeph> copumpkin: Yeah, that's what 	I thought. It isn't, though... :\
13:16:36 <solrize> cocon nice
13:17:03 <BMeph> mreh_: In what context, for "]"? The only meaning I know of is "the end of the list", otherwise. :)
13:18:03 <copumpkin> or a comprehension!
13:18:10 <copumpkin> or even more interesting, a character in a string!
13:18:38 <pshc> or [syntactic .. sugar]
13:19:26 <BMeph> pshc: Even there, it's still the end of the list. :)
13:19:33 <mauke> ] 2+2
13:19:35 <pshc> In the past day this module has grown from having two language extensions to 7...
13:19:37 <lunabot>  4
13:19:40 <pshc> hehe
13:20:16 <gwern> @seen mae
13:20:16 <lambdabot> Last time I saw mae was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #concatenative, #darcs, #dreamlinux-es, #friendly-coders, #functionaljava, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #
13:20:16 <lambdabot> haskell-blah, #haskell-books, #haskell-freebsd, #haskell-in-depth, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #
13:20:16 <lambdabot> haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #haskell.se, #haskell_ru, #jhc, #jtiger, #macosx, #macosxdev, #novalang, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling, #xmonad and #
13:20:16 <lambdabot> yi 10d 14h 25m 15s ago, and .
13:20:26 <gwern> @join #happs
13:21:53 <skorpan> @unpl ((<$>) Opt) . optional
13:21:53 <lambdabot> (\ c -> Opt <$> (optional c))
13:21:56 <mreh_> how do you put a smilie in parentheses?
13:22:19 <mreh_> (...:-)) looks weired, (...:-) so does that
13:22:38 <ordnungswidrig> is there a function to insert an element to a certain position in a list? insert :: Int -> a -> [a] -> [a]
13:22:56 <Zao> mreh_: (like this :D) (or this :P)
13:23:09 <Peaker> @hoogle Int -> a -> [a] -> [a]
13:23:09 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
13:23:09 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
13:23:09 <lambdabot> Distribution.ParseUtils IfBlock :: LineNo -> String -> [Field] -> [Field] -> Field
13:23:20 <Peaker> @hoogle insert
13:23:21 <lambdabot> Data.HashTable insert :: HashTable key val -> key -> val -> IO ()
13:23:21 <lambdabot> Data.IntMap insert :: Key -> a -> IntMap a -> IntMap a
13:23:21 <lambdabot> Data.IntSet insert :: Int -> IntSet -> IntSet
13:23:43 <Botje> ordnungswidrig: insert n el list = take n list ++ el : drop n list
13:24:01 <Peaker> Botje: better to use splitBy instead of both (take n) and (drop n)
13:24:10 <Botje> hmm
13:24:19 <BMeph> Peaker: Or splitAt, even. ;)
13:24:20 <ordnungswidrig> hmm, IntSet is not like a list.
13:24:29 <Peaker> oops, that's what I meant :)
13:24:34 <Botje> I was thinking about splitAt, but that's just uglier :p
13:24:57 <Botje> (let (pre,post) = splitAt n list in pre ++ n : post
13:25:12 <Peaker> ordnungswidrig: right, that's not what you need
13:25:27 <BMeph> insert n el list = uncurry (++) . second (el:) . splitAt n $ list
13:25:54 <copumpkin> purty
13:26:06 * BMeph takes a cyber-bow
13:26:40 <gwern> eh. pointless might've been prettier
13:26:52 <gwern> at least getting rid of the list varble
13:28:26 <ordnungswidrig> pffff
13:28:54 <ordnungswidrig> haskell is sometimes surprisingly weired
13:29:31 <BMeph> insert el n = uncurry (++) . second (el:) . splitAt n -- Better, gwern? ;p
13:29:44 <gwern> yes
13:29:56 <BMeph> @pl insert el n = uncurry (++) . second (el:) . splitAt n
13:29:56 <lambdabot> insert = ((uncurry (++) .) .) . (. splitAt) . (.) . second . (:)
13:30:25 <Gracenotes> meh. splices up the parameters too much
13:30:37 <gwern> that's why I said 'at least the list' and maybe not all of them :)
13:31:33 <BMeph> @pl \f g h x y -> f . g x . h y
13:31:33 <lambdabot> (. (flip . (((.) . (.)) .))) . (.) . (.) . (.) . (.)
13:32:38 <BMeph> Man, that's..."unaesthetic". ;p
13:33:19 <copumpkin> @pl \f g h x y -> f (g x (h y))
13:33:19 <lambdabot> (. (flip . ((.) .))) . (.) . (.) . (.)
13:33:32 <gwern> pointlessness is best applied as a spice, and not the entree
13:34:03 <BMeph> We need to raid Factor and K for better combinators! ;p
13:34:25 <copumpkin> I think we should use the letters a through z
13:34:29 <copumpkin> for a bunch of random combinators
13:34:34 <copumpkin> and feed them to @pl's recipes
13:35:45 <f4hy> with emacs haskell mode is there a way to automagically add a function's type signature?
13:36:35 <agilaz> hello
13:37:21 <TomMD> f4hy: f4hy: emacs has commands that will insert characters into the current buffer - by using these commands in the correct order you can add a type signature to your function.
13:37:57 <f4hy> "these commands" ?
13:37:59 <agilaz> is there any way to make a datatype an instance of show, if and only if it's content is an instance of show? E.g. I have a datatype "XList a", which I need to show only it's contents (and not all meta information like it's location etc)
13:38:08 <Zao> TomMD: I assume he wants something similiar to the _T of vim's haskellmode.
13:38:16 <flux> tommd, hm, would that also fall to the domain of 'automagical'?-)
13:38:20 <ordnungswidrig> thanks so far
13:39:45 <TomMD> agilaz: Deriving show does that already, but you can write your own instance that uses (Show a) => ...  where 'a' is the type parameter of your data type.
13:40:01 <Zao> f4hy: C-u C-c C-t
13:40:07 <Zao> f4hy: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Tips_and_use
13:41:19 <Zao> Now excuse me while I go smashing my head against a wall trying to erase emacs knowledge from my head.
13:41:19 <agilaz> TomMD, thanks... I stopped using "deriving" because of all the other data in the structure, which I don't need (of want) displayed... What is the correct syntax? "instance Show (Show a => XList a) where" is clearly not accepted..
13:41:39 <TomMD> agilaz: Is this for a course?
13:42:09 <mauke> agilaz: instance (Show a) => Show (Xlist a) where
13:42:14 <telemachus> :wq Zao
13:42:21 <telemachus> :)
13:42:42 <TomMD> agilaz: If so, I don't want to interfer with what the prof is trying to show, but the Haskell community generally feels (read . show = id) should hold.  So not showing all elements would break that.  To turn data into text that is pleasing to the eye use the Pretty class.
13:42:50 <Zao> «"Zao" E212: Can't open file for writing»
13:42:52 <agilaz> no.. I am trying to use Haskell to program a game, for fun and to gain a better understanding.. I needed a way to actually use the more abstract constructions in order to understand
13:43:23 <f4hy> Zao: that didnt seem to work..
13:44:01 <agilaz> thanks, I will look into the pretty class.. For now I just need to get a clear view in debugging my code in GHCi, and having each XList shown to 2 lines doesn't help :)
13:45:03 <Zao> f4hy: Ensure you have a new enough (2.2?) haskell-mode and suitable moon phase.
13:45:28 <f4hy> Zao: I have 2.4.something and it is day time, so I can not check
13:45:40 <agilaz> but the pretty class sounds pretty useful (no pun intended) for a later stage, when the datastructures and functions work and i need to start worrying about displaying it to a user
13:45:47 <agilaz> thanks all!
13:46:12 * telemachus smiles at moon phase...
13:46:44 <f4hy> Well.. how important is it to include type signatures on all functions? Is it normally done on just complex ones? or everything
13:47:49 <Zao> f4hy: I find it enlightening when reading the source.
13:47:52 <skorpan> f4hy: sometimes you *have* to, but mostly it's good manners
13:48:06 <Zao> f4hy: And it helps with restricting type errors.
13:49:03 <f4hy> Ya, I do not fully understand types, I know I should define some types in the program to better insure correctness, but I think that will have to come in 2.0
13:49:51 <f4hy> Also, is there a Lint like porgram? Or a flag I can give ghc to give me warnings?
13:49:56 <Zao> Yes.
13:50:20 <Zao> hlint
13:50:33 <f4hy> Zao: is it any good? you all use it?
13:50:46 <Zao> Never bothered as my code is flawless.
13:51:05 <Zao> <_<
13:51:12 <Zao> It seems decent enough.
13:51:36 <Zao> I see your precious haskell-mode has integration.
13:51:36 <Zao> http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs#Integration_with_HLint
13:52:02 <shapr> whee!
13:52:41 <Twey> mauke: Mine does?  Mine doesn't :-\
13:52:57 <Twey> I checked it a couple of months back
13:53:34 <f4hy> Zao: hlint requires hscolour == 1.10 and I have 1.12
13:53:37 <f4hy> :-(
13:54:17 <Zao> Relax it and see if it blows up? :)
13:54:30 <mauke> Twey: then why did you disconnect?
13:54:45 <f4hy> Zao: how do I make cabal relax something like that?
13:55:08 <Zao> cabal unpack, mutilate with editor, cabal install from dir?
13:55:13 <Twey> mauke: I don't know *scratches head*
13:55:18 <Twey> Maybe it was a coincidence?
13:55:26 <mauke> Twey: don't make me disconnect you again
13:55:34 <Twey> No, please, do
13:55:51 <Twey> I'm sure it didn't work last time I checked
13:56:38 <Twey> Hum
13:56:39 <mauke> welcome back
13:56:42 <Twey> Okay then
13:56:44 <Twey> Thanks :)
13:59:49 <Boopop> Hi all, can I have some help me revise for my haskell exam? >.<
13:59:57 <Boopop> oops..
14:00:07 <Boopop> *can someone help me revise for my haskell exam*
14:00:08 <Boopop> even
14:00:28 <Boopop> There a pretty basic question it's asking me that's winding me up
14:00:33 <mauke> just ask
14:00:49 <Twey> Boopop: Sure — I charge £15/h :-P
14:00:52 <Boopop> ""Use the function map to define a function that takes as arguments integer k and a list of integers and computes the list [k*x1, k*x2, etc]"
14:01:03 <Zao> Yes?
14:01:03 <Boopop> I've got the sig, multi :: Int -> [Int] -> [Int]
14:01:16 <Boopop> I just can't fathom out how to write the second line
14:01:26 <Zao> There's a lot of fun ways to do it.
14:01:40 <mauke> this problem is too easy for me :/
14:01:46 <Twey> Haha
14:01:49 <Twey> I kind of concur
14:02:01 <Zao> @type (?k*)
14:02:02 <lambdabot> forall a. (Num a, ?k::a) => a -> a
14:02:06 <Twey> It's about eighteen characters
14:02:46 <Zao> Boopop: So what does map do?
14:03:07 <Boopop> Applies a function to all the elements of a list
14:03:21 <Zao> So you need to find a suitable function to feed map then.
14:03:27 <Zao> @type map
14:03:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:03:56 <Twey> Oh, I've got the actual definition down to nine characters
14:04:09 <Boopop> go on...
14:04:33 <Twey> Boopop: It's not that I have a problem with helping with homework in general, but this does seem a bit *too* easy
14:04:36 <mauke> > length "?????/???![+]"
14:04:37 <lambdabot>   13
14:04:54 <Twey> Work it out in words
14:05:21 <Twey> For each element of the list, you want to multiply by k, right?
14:05:24 <Zao> Too bad you can't partially apply list comprehensions :)
14:05:32 <Boopop> Yes
14:05:46 <Twey> You've got the ‘for each element of the list’ bit with map
14:06:00 <Twey> So now you just need a function that multiplies its input by k
14:06:08 <BMeph> There's a second line? :)
14:06:10 <Twey> Do you know what a section is?
14:06:32 <Boopop> Don't think so
14:06:46 <Boopop> I know I need to use * if that's what you're getting to
14:07:04 <mauke> > (\x -> 2 * x) 7
14:07:05 <lambdabot>   14
14:07:13 <Twey> A section is a way of writing simple functions that take zero to one arguments
14:07:22 <Boopop> I see
14:07:26 <Twey> By simply omitting them from a call to an operator
14:07:33 <Boopop> ok
14:07:39 <BMeph> Twey: Seven chars. :)
14:07:41 <Twey> For example, instead of saying (\x -> 1 + x), you can say (+1)
14:07:45 <agilaz> > (*2) 5
14:07:46 <lambdabot>   10
14:08:02 <Twey> BMeph: Removing spaces doesn't count :<
14:08:05 <mauke> Twey: (1+)
14:08:14 <Twey> Or (1+), yes
14:08:33 <BMeph> Twey: You mean, add spaces, and count them. ;p
14:08:51 <Twey> Haha
14:09:10 <Twey> Boopop: So, you just have to put those two together.  Want to give it a go?
14:09:16 * BMeph goes back to trying to golf his sudoku solver to under 230 chars...
14:10:04 <Boopop> well I did have something like multi x = map (*x) [xs] as the definition
14:10:09 <Boopop> wait
14:10:16 <Boopop> multi x = map (x*) [xs] even
14:10:18 <mauke> that's almost correct
14:10:21 <Twey> Where did xs come from?
14:10:46 <Boopop> Well I'm not sure what else to put in the list part
14:10:54 <Boopop> [x]? []?
14:10:56 <Twey> [xs] in an expression or pattern means ‘a list containing a single element xs’
14:11:01 <Twey> No
14:11:07 <Twey> Look at the type signature you wrote earlier
14:11:09 <agilaz> what represents your list on the other side of the = ?
14:11:15 <dons> ?yow
14:11:15 <lambdabot> Well, here I am in AMERICA..  I LIKE it.  I HATE it.  I LIKE it.  I
14:11:15 <lambdabot> HATE it.  I LIKE it.  I HATE it.  I LIKE it.  I HATE it.  I LIKE ...
14:11:15 <lambdabot> EMOTIONS are SWEEPING over me!!
14:11:23 <dons> heh
14:11:43 <Boopop> Well my sig is "multi :: Int -> [Int] -> [Int]"
14:11:45 <Boopop> is that wrong?
14:11:55 <Twey> No, your sig is right
14:11:59 <Twey> But your function doesn't match it
14:12:01 <Boopop> oh good XD
14:12:10 <Twey> The function currently takes a single Int argument; that means that its type is Int -> something
14:12:16 <mauke> Boopop: 'multi x = ...' what happened to the second argument?
14:12:19 <Twey> Not Int -> [Int] -> something
14:12:42 <Boopop> aaah
14:12:45 <Boopop> "multi x [y] = map (*x) [y]"
14:12:45 <Boopop> ?
14:12:54 <Boopop> It's compiled anyway, lol
14:12:54 <mauke> that only works for lists of exactly one element
14:13:02 <Twey> [y], again, means a list of one element
14:13:14 <Boopop> [x:xs]?
14:13:18 <Boopop> well, y
14:13:19 <Twey> Much simpler
14:13:20 <chromakode> is there a "make clean" equivalent to ghc --make ?
14:13:23 <Twey> Right
14:13:26 <Twey> Just y
14:13:39 <mauke> Boopop: [x:xs] wouldn't even compile
14:13:51 <Twey> Could
14:13:53 <Boopop> so... "multi x y = map (*x) y"?
14:14:00 <mauke> Twey: not with that type signature :-)
14:14:01 <Twey> Boopop: Got it!
14:14:03 <Twey> \o/
14:14:05 <Boopop> Ok, thanks
14:14:22 <Twey> More tersely, you could also write multi = map . (*)
14:14:38 <Twey> (or map.(*) if you're BMeph :-P)
14:15:25 <Boopop> if it comes up in the exam
14:15:30 <Boopop> I'll use the second way then :P
14:15:39 <Twey> Well, don't use it unless you understand it
14:15:49 <Boopop> No I understand it
14:15:52 <Boopop> function composition
14:15:53 <Twey> Oh, good :)
14:17:36 <f4hy> Is there a celever function to find the mode of a list?
14:17:47 <Twey> f4hy: Mode?
14:17:51 <Twey> Oh, mathematically you mean?
14:17:54 <f4hy> yes
14:17:56 * Twey ponders.
14:17:59 <f4hy> no, not the mean ;-)
14:18:02 <Twey> I don't think so
14:18:10 <Twey> It's easy to write, though
14:18:11 <mauke> what's a mode?
14:18:20 <Zao> Middle element of a sorted list?
14:18:29 <Twey> Most common element in a list
14:18:30 <SubStack> most frequentist element
14:18:33 <Twey> Zao: That's a median
14:18:36 <f4hy> most frequent
14:18:46 <Zao> Nub, sort by length, take 1?
14:18:59 <f4hy> :t nub
14:19:00 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:19:02 <Zao> Erm, group.
14:19:07 <f4hy> ya ok group
14:19:08 <Twey> > head . maximumBy length $ group [1, 2, 3, 2, 4]
14:19:09 <lambdabot>   Couldn't match expected type `[a] -> Ordering'
14:19:13 <Twey> Hmph
14:19:19 <Twey> > head . maximumBy (comparing length) $ group [1, 2, 3, 2, 4]
14:19:21 <lambdabot>   4
14:19:22 <f4hy> sort by length $ group $ sort
14:19:24 <Twey> Damn
14:19:40 <f4hy> you have to sort it first
14:19:43 <Twey> Ah, yes
14:19:45 <mauke> > head . maximumBy (comparing length) . group . sort $ [1,2,3,2,4]
14:19:46 <lambdabot>   2
14:19:52 <Twey> > head . maximumBy (comparing length) . group $ sort [1, 2, 3, 2, 4]
14:19:53 <lambdabot>   2
14:19:59 <Boopop> Huzzah!
14:20:09 <Boopop> Your help let me do the next question =D
14:20:17 <Twey> @let mode = head . maximumBy (comparing length) . group . sort
14:20:18 <lambdabot>  Defined.
14:20:25 <Twey> Boopop: What was that?
14:20:38 <Twey> > mode [1, 1, 2, 2]
14:20:39 <lambdabot>       Ambiguous occurrence `mode'
14:20:39 <lambdabot>      It could refer to either `L.mode', def...
14:20:40 <Boopop> add :: [Int] -> [Int] -> [Int]           add x y = zipWith (+) x y
14:20:40 <f4hy> Wow thanks guys, I didnt know about the comparing function
14:20:43 <Twey> Damn
14:20:54 <Twey> Boopop: Ah, right :)
14:20:56 <mauke> @define
14:20:59 <Boopop> How would you do that using function composition?
14:21:04 <Twey> Boopop: You don't need to
14:21:07 <Boopop> I tried and failed to use function composition =/
14:21:09 <Twey> Boopop: add = zipWith (+)
14:21:19 <mauke> :t mode
14:21:20 <lambdabot> Style -> Mode
14:21:33 <Twey> It's already all right, you just need to remove the redundant arguments
14:21:42 <Boopop> Twey: Ah right, I used a .
14:21:47 <Boopop> I suppose that's why it wasn't working
14:21:49 <Peaker> Boopop: basically, a simple rule is that you can remove the last arg from both sides, if no $ or . is involved
14:22:03 <Twey> Any time you have a trailing string of arguments like that that matches on both sides, you can just cancel them out
14:22:06 <Twey> Like division :)
14:22:14 <Boopop> OK
14:22:18 <f4hy> Where does the comparing function live
14:22:24 <mauke> @index comparing
14:22:24 <lambdabot> bzzt
14:22:25 <Twey> f4hy: Data.Ord
14:22:44 <Twey> Boopop: You only have one function to call there, which is zipWith — . is for *joining* functions
14:23:06 <Boopop> yeah
14:23:06 <Peaker> @pl \x y -> blah $ x y
14:23:06 <lambdabot> (blah .)
14:23:31 <mauke> @pl \x y -> blah x $ y
14:23:31 <lambdabot> blah
14:23:53 <Twey> Peaker: Well, that's clearly two functions because of currying... :-P
14:25:53 <f4hy> my first haskell program! http://github.com/f4hy/Vigenery/tree/master
14:26:31 <Twey> Oh very nice :)
14:26:38 <Twey> Make it into a library and post it on Hackage!
14:27:19 <f4hy> Twey: I will when I get to 1.0
14:27:33 <f4hy> It still doesnt have all the error handleing it needs
14:27:44 <Twey> Ah, OK :)
14:27:45 <f4hy> if the user inputs an empty file, or other nonsense it just crashes
14:27:56 <f4hy> but it works pretty darm well on good input
14:28:52 * Twey nods.
14:28:55 <f4hy> I am happy with it. I did it for a school project which is due this week, but after I make it more robust I will put it up
14:29:05 <Twey> Cool :)
14:29:30 <f4hy> And this is proof, that you can make a working program with haskell without knowing anything about monads
14:30:18 <Twey> Hehe, aye
14:34:39 * BMeph thinks jdh is proof that you can make a living critizing something, without knowing anything about it. ;p
14:36:50 <Peaker> jdh?
14:37:09 <mauke> I bet the h stands for Harrop
14:39:13 <dons> i don't know if he's making a living.
14:39:26 <dons> scraping by, maybe.
14:40:21 * mauke ponders the difference between making a living and making a killing
14:40:43 <hatds> is there a word for something which may be a type or type constructor?
14:40:54 <mauke> type constructor
14:41:05 <dons> mm. well, you might think of a type as a saturated  type constructor
14:41:13 <dons> they're all types, some just have * -> * kinds (or more)
14:41:37 <hatds> yea, but I always see people say "type or type constructor"
14:41:37 <dons> so a type , i think as you're using it, is a type constructor of kind *
14:42:15 <Philippa_> dons: Conor McBride disagrees with you, btw :-) But it's pretty common to use 'type' for everything on the type level
14:42:26 <mauke> I'd just use type constructor everywhere
14:42:38 <Philippa_> I guess it's ambiguous as to whether it's analogous to value or term
14:42:48 <dons> Philippa_: si. had dinner with conor last week, and this very thing came up.
14:42:56 <dons> if only we could put his acetate slides online
14:43:00 <Philippa_> heh
14:43:19 <hatds> both "type" and "type constructor" seem valid umbrella terms depending on how you look at it
14:43:20 <Philippa_> yeah, I suspect we got the same talk at FitA. Blue Braces of Upward Mobility?
14:43:30 <dons> blue braces, yep
14:43:37 <dons> bifunctors et al
14:43:49 <Philippa_> bi to I, even
14:44:03 <dons> did he do his 'colon in the middle' thing?
14:44:28 <Philippa_> yeah. Was he wearing the orange trousers for yours?
14:45:59 <Philippa_> ...I'm guessing not :-)
14:47:06 <BMeph> dons: Wasn't his R* presentation on acetate? Or was that just some brilliant font? :)
14:47:32 <Neophyte> I am looking for a text editor to use for Haskell on Windows
14:47:35 <Neophyte> Any recommendations
14:47:49 <Peaker> Neophyte: emacs/vim?
14:47:54 <Peaker> Neophyte: maybe yi?
14:48:00 <BMeph> Neophyte: I like Notepad++. :)
14:48:03 <Philippa_> jedit, textpad
14:48:04 <Neophyte> Alright, thanks.
14:48:05 <Zao> vim w/ haskellmode, emacs w/ haskell-mode, eclipse w/ EclipseFP
14:48:22 <Philippa_> jedit's nice if you want something that can resemble an IDE but isn't emacs or vi
14:48:53 <BMeph> So, what's the Haskell "ripoff" of Eclipse gonna be called - Halo? ;p
14:50:05 <Twey> There's an Eclipse rip-off?
14:50:10 <Twey> Why would we want one?  :-P
14:50:12 <dons> leksah?
14:50:21 <Twey> Heh
14:50:43 * Cale upgrades to 6.10.3
14:50:53 <Zao> I'll run leksah after it stops eating my source :)
14:50:57 <Neophyte> BMeph what do you like about Notepad++ while programming in Haskell?
14:51:00 <Zao> Although I blame that on gtk2hs.
14:51:10 <mauke> om nom nom
14:51:17 <Cale> Mmmm... I'll finally have proper line editing again
14:52:04 <Zao> mauke: "Meh, I'll put the code into source control later"
14:56:23 <BMeph> Neophyte: Colored syntax, automatic indentation matching, changeable indexing without trying to "argue" out of it. :)
14:56:43 <BMeph> Er, s/indexing/indentation/
14:57:19 <Cale> BMeph: Do you mean it keeps do-blocks e.g. aligned when you change the indentation of the first line?
14:57:56 <Neophyte> Alright, thanks :)
14:57:59 <BMeph> Neophyte: Also, Find/Replace by either normal string or regex. Basically, it's SciTE with a lobotomy. It functions, but doesn't try to be more clever than you. :)
14:58:56 <Neophyte> I think i'll download it then, I was considering emacs with the haskell mode.
14:58:59 <BMeph> Cale: Yes.
14:59:03 <Neophyte> Bu notepad++ should be fine.
14:59:07 <Neophyte> s/Bu/But/
14:59:33 <Cale> BMeph: That's nice :)
15:00:05 <Cale> BMeph: Is it resilient when you, say, press enter when the cursor is just before the 'do'?
15:00:17 <Cale> I noticed that yi manages to get that wrong.
15:00:58 <BMeph> Neophyte: I'd still consider emacs or vi(m), though. One thing I miss from emacs is having a split window with GHCi running in it, loading your file, and being able to jump straight from the error message in one window, to the line/char position inthe other.
15:02:43 <Neophyte> alright then I'll download emacs
15:02:58 <Neophyte> It'll take a while to download, slow internet connection
15:03:11 <BMeph> Cale: Resilient, how? Do you mean, does it move the do (and presumably the code after the do) to the start of the line, and then ripple the code following? No, I don't think it does that. It might do it once you leave the line, but like I said, it's just SciTE with a lobotomy. :)
15:03:11 <Neophyte> When I want to start programming do I open emacs and start typing code?
15:03:48 <qwr> yeah. or vim.
15:04:00 <Neophyte> on learnyouahaskell.com it says open up your terminal, but would it be the same as me opening up emacs?
15:04:11 <Neophyte> would my "terminal" be my run cmd on windows?
15:04:58 <BMeph> Cale, Neophyte: Which reminds me of another thing I like about it - you can start a new file, without having to specify its name/directory. Emacs does that, but I don't think vim does. I've never used it, though. :)
15:05:14 <Cale> vim lets you do that
15:05:22 <Cale> But I never use it like that.
15:05:27 <qwr> Neophyte: yes. but emacs and vim don't need terminal.
15:05:35 <Cale> I always vim <something> from the command line.
15:05:36 * qwr uses vim in xterm
15:06:09 <Neophyte> qwr so do I open up run cmd and follow the tutorial on learnyouahaskell.com
15:06:18 <Neophyte> or open up emacs and say it as a file as run the code
15:06:28 <Neophyte> s/say/save/
15:07:33 * qwr . o O ( http://www.google.com/search?q=haskell+ide )
15:08:44 <Cale> I'm so happy to have a ghci where the delete key works properly again!
15:09:09 <mauke> that's what you get for not patching ghc :-)
15:10:09 <BMeph> Yeah, I'm so old, I quit using vi before vim came out. :)
15:10:40 <mauke> I'm so young my first OS was Win98
15:11:11 <BMeph> mauke: I think VMS was mine. :)
15:11:31 <monochrom> Apple DOS 3.3
15:11:40 <bremner_> Multics
15:11:42 <abbe> anyone has Emacs :p
15:12:02 <mauke> I beg to differ
15:12:40 <wy> What's the os of Apple II?
15:13:27 <wy> I heard multics is actually better than unix
15:13:27 <abbe> wy: some form of BASIC in Apple ][
15:13:39 <QP> mauke: Mine was Win98 too.
15:15:20 <bremner_> Wy yes and no
15:18:24 <wy> bremner: well, that's true, in some aspects
15:21:18 <wy> oh, who did I talk to about register allocation?
15:23:46 <copumpkin> mmorrow maybe?
15:24:31 <wy> right. It seems that he hasn't waken up yet ;)
15:25:19 * BMeph wonders if mmorrow will use the Dune quote when he comes on...
15:40:22 <Axman6> wy: benl23 might be interested (in #ghc), he's the one working on the SPARC backend at the moment, and i think that register allocation is a bit part of it
15:40:44 <Axman6> wy: i'd also be interested in talking about it, but i don't know anything about it :(
15:42:15 <wy> Axman6: Thanks. I'm still trying to figure out a neat way to do it. There seems to be one exist. http://www.pllab.riec.tohoku.ac.jp/~ohori/research/regalloc.pdf. I just wonder whether any compiler is using it
15:47:34 <adimit> psygnisfive: yes I do, why? Though I'm not currently keeping an instance running.
15:48:17 <bremner> wy: I was typing with one thumb while walking the dog, so not too verbose.  Multics had some great features, but it really relied on special hardware. In the long view, we wouldn't be able to play with Haskell if we had to buy mainframes from Honeywell et al.
15:49:01 <Baughn_> I'm wondering, has anyone tried using ICC for the -fvia-c backend?
15:50:42 <wy> bremner: It's great to hear that. Unfortunately I don't have any chance to try multics
15:51:28 <bremner> wy: well, the code is open source finally, so start porting :-)
15:51:37 <agruman> i have "data Value = I Integer | D Double" in one module and i import it with "import module (Value)", but when i try to use it ghc gives me "Not in scope: data constructor I" what am i doing wrong?
15:51:44 <Axman6> multics?
15:52:02 <Saizan> agruman: import module (Value(..))
15:52:37 <Cale> agruman: You've only imported the type and not its constructors.
15:52:43 <agruman> Saizan: thanks alot :)
15:53:10 <agruman> Cale: yeah figured that from Saizan's reply, thanks for the info!
15:53:13 <Cale> agruman: Normally I don't use explicit import lists unless there's a specific reason to do so (like overlapping names)
15:54:19 <agruman> Cale: well perhaps its a bit tedious, but its old practice on my end
15:54:49 <wy> bremner: wow. comments start with "&". Is this the B language?
15:55:26 <Axman6> heh
15:55:36 <gwern> multics wasn't written in asm?
15:59:02 <bremner> gwern: PL/1 mostly
16:01:28 <wy> bremner: Just read the wikipedia page. It looks that its compiler is using something like combinators
16:03:16 <idnar> BMeph: which Dune quote?
16:36:06 <Freidenker> I'm really interested in learning Haskell and using it for a large project for my thesis, but I need to be sure it's possible to write a GUI using Haskell, gkhs + cairo, and that I will be able to compile my program into nice executables for windows, mac and linux. I ask this because I don't know any windows program written with Haskell using Gtkhs and Cairo.
16:37:10 <BMeph> Freidenker: Of course you don't; you have not written it yet! :)
16:37:12 <solidsnack> Freidenker: I have some experience with compiling binaries for Linux, Windows and Mac. It couldn't be easier.
16:37:26 <solidsnack> Freidenker: They were all command line tools, though.
16:39:08 <Berengal> There's gtk2hs for windows, no?
16:39:39 <Freidenker> Yes, but Cairo ?
16:39:48 <Berengal> Eh, cairo I'm not too sure about...
16:41:45 <Freidenker> that's the problem, I need to use Cairo with gtk2hs, and I had some bad experiences with unix-centered languages (I'm on linux most of the time, but most people aren't)
16:42:08 <Saizan> i think the windows installer of gtk2hs has cairo too
16:42:38 <Freidenker> Well I guess I'll have to try
16:42:42 <Saizan> yeah
16:42:46 <Berengal> There were a few things that the windows version of gtk2hs didn't have, but they were mostly gnome things like gstreamer and vfs
16:52:17 <pimpkonFollower> So, is there a vim macro so that when you insert/append a '\', that it also appends a "->" for you afterwards? :)
16:52:54 <copumpkin> zomg pimpkon haz a followa?
16:53:16 <mauke> :inoremap \ \ -><ESC>hhi
16:53:19 <mauke> or something like that
16:53:22 <pimpkonFollower> Well, he sure doesn't have a Leader! ;p
16:53:36 <copumpkin> :o
16:53:50 <copumpkin> zomg http://twitter.com/mauke
16:53:52 <pimpkonFollower> mauke: Hmm, I'll try it - thanks! :)
16:54:01 <copumpkin> mauke: we know your real name now!
16:54:02 <copumpkin> ;)
17:00:24 <Peaker> mauke: is that really you?
17:00:32 <mauke> heh, no
17:10:42 <mauke> haskeline--  # you fail at combining characters
17:15:02 <flippo> preflex, be poppavic
17:15:02 <preflex>  no quotes found for poppavic
17:15:11 <flippo> Aww.
17:15:31 <mauke> haskeline--  # vi-style custom keybindings, no functionality
17:15:46 <j4cbo> does haskell (either directly or through some ghc extension) support higher order polymorphism?
17:16:17 <clug> http://en.wikibooks.org/wiki/Haskell/Polymorphism
17:16:32 <dons> j4cbo: yeah
17:16:47 <dons> j4cbo: look for "Rank N types"
17:17:31 <dons> j4cbo: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#universal-quantification
17:17:53 <j4cbo> neat.
17:19:19 <j4cbo> oh i see, they solved the undecidability thing by requiring annotations when you're doing that sort of thing
17:19:55 * j4cbo wants Successor ML already :/
17:23:35 * pimpkonFollower wants "Successor Haskell, with Batteries Included", already
17:24:06 <Twey> A.K.A. Haskell' with haskell-platform?
17:24:22 <Twey> Why doesn't haskell-platform get standardised in Haskell'?
17:24:23 <Cale> j4cbo: The direction of most of the type system research surrounding Haskell has been how to preserve the quality of type inference while allowing for fancy type features -- only requiring explicit types for the fancily-typed things.
17:24:31 <Twey> At least vaguely
17:24:59 <Twey> It could be mentioned as a series of optional addenda.
17:25:31 * j4cbo nod
17:25:41 <Cale> It annoys me enough that the Prelude is part of the standard, in some ways.
17:26:06 <Cale> Makes it really hard to change things.
17:26:22 <roconnor> god, I hope the mtl doesn't get standardized any further.
17:26:41 <j4cbo> i like a lot of the ideas in haskell, but i don't think i'll ever want to use a lazy language for real work, myself
17:27:02 <Cale> j4cbo: In my experience, laziness makes a good default.
17:27:15 <roconnor> laziness makes code modular
17:27:19 <roconnor> well
17:27:23 <roconnor> allows code to be modular
17:27:31 <Twey> I agree
17:27:43 <j4cbo> i was under the impression that even some of the authors/inventors of haskell have said that eagerness should have been the default?
17:27:48 <Twey> Although it would be nice if Haskell made strictness easier, too
17:27:48 <Cale> Yeah, it gives you more ways to break down problems if you have libraries with lots of lazy functions in them.
17:27:56 * j4cbo remembers this from a talk he went to a while ago
17:28:09 <Twey> j4cbo: I don't know, but clearly they were in a minority for a good reason :-P
17:28:13 <Cale> j4cbo: I think perhaps it was in order to emphasise how much *more* important purity is.
17:28:28 <Cale> But laziness actually is quite useful.
17:28:39 <j4cbo> in particular, it was one of the head Jane Street Capital guys talking about why they use ML rather than Haskell :P
17:28:53 <roconnor> heh, purity actually *makes* things modular, rather than simply allowing for it. :P
17:28:56 <j4cbo> laziness is really useful sometimes, sure
17:29:20 <j4cbo> i don't like how it makes it trickier to reason about what the code will *do*, though
17:29:20 <Cale> j4cbo: The trouble is that if you don't have it as a default, it's much less useful.
17:29:28 <Twey> Laziness is useful often enough that I would rather have it as the default
17:29:33 <Cale> Actually, I think it makes reasoning easier.
17:29:38 <roconnor> j4cbo: but it makes it easier to forget about what the code *does*
17:29:40 <Twey> Default strictness is premature optimisation, I think.
17:29:42 <roconnor> one less thing to worry about
17:29:56 <mauke> without default laziness Haskell wouldn't even exist
17:29:57 <Cale> If there's an order of evaluation which terminates, then lazy evaluation terminates. You can't say that about strict evaluation.
17:29:59 <roconnor> focusing on what the code *means*
17:30:19 <j4cbo> maybe it has to do with the application
17:30:36 <j4cbo> for me, knowing whether my code will use N mb of heap is more important than being able to represent an infinite list
17:30:47 <mauke> haskeline--  # it's not even programmable
17:31:08 <Cale> haskeline++  # it works the way I want it to by default
17:31:30 <Twey> Defaults are a luxury; flexibility is a necessity
17:32:10 <mauke> haskeline--  # duplicate history entries
17:32:16 <Cale> j4cbo: There are ways, of course, to limit the amount of resources which a computation will require
17:32:22 <mauke> what are the ghc developers smoking?
17:33:08 <Cale> j4cbo: It's just that "seeing" the resource usage of lazy programs takes some getting used to, and the intuition one has from strict programming doesn't apply.
17:33:25 <Saizan_> mauke: have you seen the documentation on the trac page?
17:33:31 <mauke> Saizan_: yes
17:34:17 <Cale> mauke: It's better than having  abc<del>d produce adb
17:34:37 <Cale> libedit sucked
17:34:49 <j4cbo> Cale: that's like saying that "seeing" the state-mutating effects of impure programs takes some getting used to, and the intuition one has from pure programming doesn't apply :P
17:34:59 <Cale> j4cbo: That is true.
17:35:01 <mauke> Cale: I know, but at least it pretended to be readline compatible so building ghci with readline support was trivial
17:35:01 <Cale> (as well)
17:35:14 <Cale> j4cbo: But it's not necessarily the case that it's hard.
17:35:55 <j4cbo> actually that reminds me
17:35:57 <Cale> j4cbo: When you programmed in your first programming language, you likely had to get a feel for resource usage.
17:36:13 <Cale> I'm just saying the experience is somewhat similar to that.
17:36:15 <mauke> if I don't find a way to link ghc-6.10.3 with readline, I'm not going to upgrade
17:36:44 <j4cbo> i remember seeing that GHC has some fancy optimizations such that a string isn't necessarily a bunch of cons cells of chars, but can be stored unboxed... is that the case?
17:37:02 <Cale> j4cbo: Hmm... you can use Data.ByteString
17:37:31 <j4cbo> oic
17:38:50 <dons> j4cbo: re. laziness, i gave a talk recently about haskell in the workplace, and experiences with laziness, might ease some of your concerns. http://www.galois.com/blog/2009/04/27/engineering-large-projects-in-haskell-a-decade-of-fp-at-galois/
17:39:00 <dons> re. unboxing, the 'adaptive' packages do this via associated type classes
17:39:14 <dons> where if you use particular element types, the representation changes to an unboxed form
17:39:36 <Cale> Data.ByteString comes in a strict flavour, which just consists internally of a pointer to a counted block of memory, and a lazy flavour, which is internally a lazy list of approximately-cache-sized strict bytestring chunks.
17:39:48 <j4cbo> *nod*
17:40:04 <dons> yeah, the libraries are full of strict, lazy, and mixed structures
17:40:09 <dons> lots of fun exploring that space
17:41:16 * cypher- alyways misses london hug talks and he's just few miles away
17:41:17 <cypher-> :S
17:41:50 * cypher- used to be at city uni
17:42:14 <Cale> j4cbo: The most useful piece of intuition for when you need strictness is that it should only be necessary when you have a large number of separately-evaluable pieces of data, and you're collapsing them down somehow to something which doesn't have a lot of separately-evaluable parts, and it's not simply by searching, but properly combining.
17:43:09 <cypher-> dons: is there / will be a video of the talk?
17:43:32 <Cale> This is because this is the only opportunity for unevaluated expressions to grow much larger than the data they evaluate to.
17:43:40 <Cale> The nice thing about this observation is that most of these cases are in fact folds of one variety or another.
17:44:12 <Cale> So you can take the explicit strictness annotations and wrap them up inside a strict fold function, and then just use that.
17:44:40 <j4cbo> dons: that's interesting... i find there's generally nowhere near enough information about actually using functional languages in the real world - deployment, FFI, that sort of thing.
17:45:32 <Cale> In fact, in my experience, it's almost always foldl' :)
17:45:41 <j4cbo> it's something implementers tend to not pay enough attention to either (*COUGH*smlnj*COUGH*)
17:45:59 <dons> j4cbo: yeah, that's the stuff I tried to talk about in the talk (e.g. Haskell's FFI removes a /lot/ of risk)
17:46:08 <dons> cypher-: there's no video.
17:48:45 <Adamant> Haskell and stuff like SPARK/Ada. is there any movement toward using Haskell in high-reliability systems?
17:49:08 <Adamant> I mean, for things that REALLY require reliability.
17:49:47 <dons> there's a couple of 'systems haskell' languages under development
17:49:52 <mikm> Like Telecos?
17:49:54 <dons> and a lot more stuff to do with theorem proving.
17:50:07 <p_l> mikm: like nuclear reactors, I think ;-)
17:50:41 <dons> i.e. galois has used haskell subsets, in conjunction with isabelle, aiming at top end assurance
17:50:55 <mauke> I'm tempted to file three bugs against 6.10.3 :-(
17:51:07 <dons> are they feature requests?
17:51:18 <p_l> I'm pretty sure GHC is good enough for telco-level stuff
17:51:20 <mauke> dons: no
17:51:48 <mikm> Really?
17:51:49 <mikm> Neat
17:52:08 <j4cbo> *erlang* is good enough for telcos; GHC had better be.
17:52:19 <mikm> Well, erlang was designed for telecos
17:52:23 <mikm> Or so I hear
17:52:36 <Berengal> It was also designed _by_ a teleco
17:52:42 <bremner> j4cbo: erlang does certain things pretty well
17:53:36 <j4cbo> duck-typing :(
17:53:48 <p_l> Erlang by itself is not enough, afaik the real strength is due to OTP...
17:53:52 <Berengal> Erlang is overall a nice language. Better suited to some tasks than others, but still general enough to not be useless outside its targeted areas
17:54:12 <Twey> j4cbo: You know what they say
17:54:28 <dons> yeah, typical non-life threatening stuff doesn't have a very high burden of evidence in our industry
17:54:31 <Twey> If it looks like a duck, and talks like a duck, it's probably a list [100,117,99,107]
17:54:32 <dons> a pity
17:55:11 <Berengal> > map chr [100,117,99,107]
17:55:12 <lambdabot>   "duck"
17:55:32 <j4cbo> or [110,117,99,107,nil]
17:55:49 <Berengal> There's already a nil at the end of [100,117,99,107]
17:56:09 <Twey> j4cbo: nuck\0?
17:56:25 <p_l> "what are those earth animals, small and go 'quack'?" "Cats?" "I'm nibbled to death by cats!"
17:56:29 <j4cbo> nil as in NULL, not the real nil :P
17:56:32 <mauke> ok, just two bugs. one of them was already in 6.8
17:56:57 <Twey> j4cbo: Erlang represents strings as lists of ints
17:57:12 <mmorrow> so does haskell (essentially)
17:57:12 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
17:57:14 <Twey> And guesses how to treat them based on the values of the ints
17:57:41 <Twey> I don't think a Char is an int
17:57:46 <Berengal> mmorrow: Depends how far down the turtle stack you go. Erlangs duck-typing is what's at issue here
17:57:48 <j4cbo> ah, i was attempting to poke fun at the whole anything-might-actually-be-null thing in most languages
17:57:50 <mmorrow> it's 4bytes
17:57:51 <Twey> Besides, Haskell has the types to tell them apart
17:58:05 <mmorrow> (ord,chr)
17:58:09 <Berengal> Also, my ints are 8 bytes
17:58:12 <Twey> Really?  It can't handle UTF-64?  :-P
17:58:16 <Adamant> Erlang currently holds all the records for uptime levels, so let's not go talking poo just yet.
17:58:33 <Adamant> Twey: they HAVE UTF-64 now?
17:58:37 <mmorrow> my ints are 4bytes in C, and i'm on x86_64 :)
17:58:39 <Adamant> 32 wasn't insane enough?
17:58:47 <mmorrow> my longs are 8bytes
17:58:54 <Twey> mmorrow: It's one thing to convert to and from ints.  It's another to *be* ints.
17:59:15 <j4cbo> mmorrow: i think Berengal uses Windows.
17:59:18 <mmorrow> hence the "essentially"
17:59:18 <Berengal> > chr (maxBound :: Int)
17:59:20 <lambdabot>   * Exception: Prelude.chr: bad argument
17:59:22 <Twey> Adamant: Not yet :-P
17:59:25 <j4cbo> wait, no
17:59:37 <mmorrow> Berengal: yeah, that's the hitch
17:59:53 <Adamant> anyway, instead of hating on Erlang, why not concentrate of stealing the cool Erlang features that Haskell doesn't have yet
17:59:58 <Adamant> like OTP
18:00:08 <mikm> Isn't UTF-32 just a different implementation of Unicode?
18:00:17 <mikm> I mean, it doesn't cover a wider space than UTF-16
18:00:22 <Berengal> I'd like variable unification...
18:00:30 <Adamant> mikm: no, it covers more.
18:00:32 <mikm> or -8
18:00:32 <Twey> Adamant: haskell-platform
18:00:37 <mikm> ah
18:00:39 <mmorrow> mikm: utf{32,16,8"} all cover the exact same thing
18:00:47 <mmorrow> s/"//
18:00:47 <mikm> mmorrow: That's what I thought
18:00:49 <Twey> mmorrow: What?  No they don't
18:00:51 <j4cbo> mikm: it covers a wider space than UCS-2
18:00:56 <Twey> Do they?
18:00:56 <mauke> Twey: what
18:01:03 <mmorrow> , utf8enc [maxBound::Char]
18:01:09 <lunabot>  "\244\143\191\191"
18:01:13 <Twey> UTF-16 and UTF-32 are both fixed-width
18:01:15 <Adamant> mmorrow: is right
18:01:17 <j4cbo> Twey: UTF-8 and UTF-16 are both variable length
18:01:21 <Twey> Oh
18:01:22 <Adamant> UTF can expand to 32 bits
18:01:28 <Twey> I thought UTF-16 was fixed
18:01:29 <Adamant> UTF-8
18:01:33 <Adamant> me too
18:01:37 <Adamant> guess not
18:01:45 <Twey> 'kay then
18:01:52 <j4cbo> UCS-2 is fixed two-byte
18:01:56 <p_l> UTF-16 afaik simply used 16bits as minimal size and had AFAIK slightly different rules...
18:01:59 <j4cbo> and can only do the BMP
18:02:01 <Twey> Yeah
18:02:09 <Twey> http://en.wikipedia.org/wiki/UTF-16
18:02:11 <mmorrow> j4cbo: are ints 8bytes on windows 64bit (C compilers) (or something)?
18:02:16 <p_l> j4cbo: UCS2 allows for surrogate pairs, didn't it?
18:02:19 <Adamant> you have to be able to use up to 32 bits to get the full Unicode standard
18:02:30 <mauke> 21
18:02:31 <mmorrow> j4cbo: (i didn't get your comment)
18:02:44 <j4cbo> p_l: UTF-16 does; UCS-2 does not
18:02:47 <Twey> Adamant: We could use Bloom filters :-P
18:02:47 <j4cbo> they're otherwise the same
18:02:50 <j4cbo> (i think...)
18:02:57 <p_l> ah, right. Just loaded wikipedia page
18:03:07 <j4cbo> mmorrow: it actually doesn't, but i thought it did
18:03:08 <Twey> Probabilistic text...
18:03:14 <mmorrow> j4cbo: ahh
18:03:21 <p_l> urk... UTF-EBCDIC
18:03:31 <mauke> UTF-9
18:03:31 <Adamant> Twey: I want to be able to play with the all-singing, all-dancing message passing crap of the world in all it's glory
18:03:48 <j4cbo> UTF-16 is hilarious.
18:04:01 <Twey> Adamant: You can do pretty much everything you can do in Erlang in Haskell
18:04:05 <Adamant> j4cbo: is it basically a compromise because of UCS-2?
18:04:07 <j4cbo> it's not "the same as ascii" for low characters, and it's still variable length.
18:04:08 <Twey> It's just not implicit
18:04:35 <Twey> j4cbo: Yeah, but it encodes a pretty damn big chunk of the BMP in two bytes instead of UTF-8's three
18:04:40 <Adamant> Twey: hmm. OTP good. want OTP on Haskell. should write code to that effect.
18:04:51 <Twey> Adamant: What about OTP, exactly?
18:05:06 <j4cbo> Twey: true
18:05:10 <Adamant> Twey: all the nice patterns for dealing with massive message passing network stuff
18:05:28 <Twey> I.E. it's more suitable for just about all Asian text
18:05:38 <Twey> Adamant: But doesn't Haskell basically do that anyway?
18:05:48 <Adamant> Twey: since when?
18:05:53 <Adamant> maybe I'm out of date
18:05:57 <Twey> Purely by virtue of its execution model(s) and Control.Concurrent
18:06:12 <Berengal> Twey: Haskell does not
18:06:19 <Berengal> Not yet
18:06:27 <Berengal> But it would be nice if it did
18:06:27 <Twey> What does OTP have over Haskell?
18:06:52 <Adamant> Twey: it's basically a platform for building really big parallel/concurrent systems with message passing
18:07:24 <Berengal> Things like links between threads, recovery, various services for distributing processes across nodes (with error recovery) etc.
18:07:42 <Twey> Berengal: Like throwTo?  :)
18:07:46 <Berengal> Basically, map withRecovery [all,things,otp]
18:07:55 <Twey> Okay, it doesn't do transparent distribution
18:08:18 <Twey> But throwTo and catch implement all the Erlang magic, pretty much
18:08:34 <Berengal> Twey: There's also a big lack of node support
18:08:39 <mmorrow> but you can't throwTo a thread on another continent
18:08:49 <Berengal> ↑ my point
18:08:57 <Twey> It should be fairly easily possible
18:09:21 <Twey> You'd have a proxy thread on the local machine that serialised everything passed to it and sent it on to the real node
18:09:38 <mmorrow> sure, but comparing the erlang rts and the haskell rts (as defined as the minimal rts to implement the language spec)
18:09:39 <Twey> Which would have a proxy thread to catch that and convert it into an exception which would then be thrown to the relevant thread
18:09:57 <Twey> Basically, all Erlang does is make it implicit
18:10:11 <mmorrow> exactly, via the rts
18:10:18 <j4cbo> ... which can be pretty powerful, really
18:10:27 <Twey> It has hidden network transfers, hidden channels, and hidden exception handlers
18:10:36 <Adamant> Twey: right
18:10:45 <Twey> It may be neat sometimes, but I don't know it's really Haskelly to hide all that stuff
18:10:46 <Adamant> which is why it is nice for what it does
18:10:53 <Adamant> Twey: why not?
18:10:59 <Cale> Berengal: How does the Erlang server for Haskell compare?
18:11:10 <Twey> Because ‘explicit is better than implicit’
18:11:21 <mmorrow> malloc?
18:11:26 <Twey> Ha
18:11:29 <mmorrow> ;)
18:11:30 <j4cbo> laziness? :P
18:11:33 <Adamant> Twey: he's got you :P
18:11:38 <Twey> No, explicit with regards to what you actually want to do
18:12:05 <Berengal> Cale: What?
18:12:06 <Twey> Explicit memory management has nothing to do with the task at hand
18:12:08 <Adamant> Twey: arguing that at a fine enough level has you coding in ASM :P
18:12:35 <bremner> Twey: but explicit laziness surely does
18:12:58 <Twey> bremner: Well, since Haskell is lazy by default, it's more a case of explicit strictness
18:13:06 <Cale> Oh, perhaps I've misunderstood a bit of the conversation, but you guys know about http://hackage.haskell.org/cgi-bin/hackage-scripts/package/erlang  yeah?
18:13:31 <Twey> Cale: Cool :-D
18:13:34 <Adamant> cool
18:13:42 <Adamant> it's a start
18:13:48 <duaneb> so
18:13:49 <Berengal> Cale: I think I've heard of it in passing only...
18:13:52 <duaneb> what's knew in Haskell?
18:13:55 <Berengal> Does seem interesting
18:14:09 <duaneb> so, why are types boxed by default?
18:14:10 <Adamant> maybe I should adopt rebuilding OTP in Haskell as a pet project :P
18:14:19 <duaneb> Doesn't strict typing allow for automatic unboxing?
18:14:28 <Cale> duaneb: Because polymorphism doesn't work without it.
18:14:28 <duaneb> or rather, automatic use of unboxed types?
18:14:44 <Cale> Well, polymorphism + separate compilation, anyway
18:14:44 <mmorrow> duaneb: ghc does this to the extent that it can
18:14:51 <duaneb> ah
18:14:59 <Cale> Think about the work that 'map' has to do.
18:15:23 <Cale> The only way it can possibly just be one function is if all data is of a single uniform representation.
18:16:10 <mmorrow> yeah, ghc can't unbox polymorphic types
18:16:19 <mmorrow> but it'll usually unbox an Int
18:16:27 <Cale> So if you started randomly unboxing things, you'd need to compile separate versions of map, and all the other polymorphic functions to deal with the difference in representation.
18:16:31 <duaneb> well, why not have multiple maps?
18:16:44 <duaneb> That's what I would do...
18:16:46 <Cale> Well, because map is in the Prelude, and it's already compiled.
18:17:15 <Cale> So it would have to have compiled versions of map for future unboxed types of data which it couldn't possibly know about.
18:17:32 <mmorrow> i think maps a slightly bad example here because map only deals with pointers any way you cut it
18:17:42 <Cale> Well, only because things are boxed.
18:17:48 <dons> well, it can, but you have to program the unboxing explicitly (via associated representation types).
18:18:06 <mmorrow> Cale: (i mean map over lists)
18:18:14 <Cale> If you start unboxing things and storing them directly in the list nodes, I mean.
18:18:22 <mmorrow> ah
18:18:44 <duaneb> well, ok
18:19:21 <Cale> It becomes a problem because the same code won't work, you need to keep compiling new versions of things. Seeing as almost every function we write is polymorphic in one way or another, that begins to get expensive too.
18:19:22 <dons> all statically typed FP languages with parametric polymorphism use a uniform representation, afaik.
18:19:45 <duaneb> well, consider +
18:19:53 <duaneb> (I really hope ghc optimizes the hell out of that)
18:19:56 <dons> oh, sure.
18:20:01 <dons> if the type is known statically, of course it is.
18:20:07 <duaneb> but (+) :: (Num a) => a -> a -> a
18:20:11 <Cale> It does *if it knows which type you've selected*
18:20:12 <dons> right.
18:20:18 <dons> it knows the type you use it at.
18:20:33 <dons> so then it replaces (+) with the , e.g. Int version
18:20:39 <Cale> But if you write and compile a polymorphic function, then perhaps not.
18:20:54 <Cale> (well, certainly not, if (+) is applied polymorphically)
18:20:54 <duaneb> isn'
18:20:58 <dons> right, then you might use INLINE or SPECIALIZE to ensure that it will propagate to a site where the type is known
18:21:02 <duaneb> Cale: ok, fair enough
18:21:08 <duaneb> huh
18:21:08 <duaneb> ok
18:21:14 <duaneb> new way of thinking about it
18:21:15 <duaneb> that's cool
18:21:31 <dons> ghc will very aggressively inline things, replacing general polymorphic code with specialized instances as it goes
18:21:43 <duaneb> ok, now switching gears completely
18:22:12 <gnuvince_> dons: I skimmed the GHC May09 report, and it did not mention stream fusion for lists in 6.12.  Is that still a go or has it been pushed back?
18:22:33 <dons> its not planned afaik. just use the library of stream-based lists.
18:22:58 <duaneb> (one second, preparing a paste)
18:23:22 <eck> hi all, i'm trying to write a library that uses the ffi, and i'm having difficulty figuring out how to convert an Int to a CSize. can anyone help me out?
18:23:22 <gnuvince_> dons: http://hackage.haskell.org/trac/ghc/ticket/915
18:23:27 <gnuvince_> dons: this isn't about that?
18:24:08 <dons> gnuvince_: yep
18:24:11 <duaneb> http://www.pasteall.org/5510/haskell
18:24:12 <mmorrow> hmm, consider: struct cons { struct cons *tail; char data[];}; you could have a polymorphic map over such a rep, *and* store the data in the list nodes
18:24:15 <dons> eck: fromIntegral
18:24:23 <eck> dons, thanks
18:24:25 <duaneb> Why does `(Vector2 1 2) *. 5` not work?
18:24:56 <hatds> :t fromIntegral
18:24:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
18:25:04 <hatds> does lots of different conversions too :)
18:26:10 <duaneb> I feel like I'm not doing the type class correctly or something....
18:27:07 <mmorrow> gc would be painful though with that rep..
18:27:28 <mmorrow> well, not painful per se, you'd just need to store extra info somewhere
18:27:42 <duaneb> huh
18:27:42 <duaneb> ok
18:28:05 <mmorrow> (err, i was talking about "struct cons...")
18:28:14 <duaneb> so I have an operator, (*.) :: (Vector a b) => a -> b -> a
18:28:15 <mmorrow> (in case that was ambiguous :)
18:28:44 <duaneb> it does not, however, allow: (Vector2 1 2) *. 2, because 2's type is unclear
18:28:56 <duaneb> how can I tell the compiler that '2' should be interpreted as a Double?
18:29:00 <duaneb> will 2::Double work?
18:29:02 <mauke> (2 :: Double)
18:29:08 <duaneb> > :t (2::Double)
18:29:09 <lambdabot>   <no location info>: parse error on input `:'
18:29:16 <duaneb> oh, damn
18:29:35 <mmorrow> @type 2 :: Double
18:29:36 <lambdabot> Double
18:29:44 <duaneb> used to ghci :/
18:29:51 <mauke> :t (2::Double)
18:29:52 <lambdabot> Double
18:29:53 <mmorrow> :t 2 :: Double
18:29:54 <lambdabot> Double
18:30:06 <mmorrow> :!sudo halt
18:30:54 <Cale> duaneb: btw, your convention is the opposite of most people's usual one -- it's common to put the . or ^ on the sides of the operator where the vector is :)
18:31:08 <duaneb> Cale: whoops
18:31:14 <duaneb> what's the reasoning for that?
18:31:32 <duaneb> I thought the point (i.e., '.') on the side of the floating *point* would make more sense
18:31:39 <Cale> Well, since you can't name vector addition + you have to use something like .+.
18:31:48 <hatds> if Vector2 is a Type Constructor that holds two values of the same type then you might consider making it an instance of functor
18:31:54 <Cale> and that has vectors on both sides
18:32:03 <duaneb> Cale: I just have vector as a number
18:32:09 <Cale> ah
18:32:11 <duaneb> it is, technically, a single number on multiple planes
18:32:37 <Cale> Yeah, you can write a Num instance I suppose, where multiplication is elementwise
18:32:41 <hatds> so both components are the same type?
18:32:45 <Cale> in that case it's fine :)
18:32:55 <davidL> in converting a context-free grammar to CNF, are you allowed to simplifiy the grammar during the step of removing unit rules?
18:33:22 <duaneb> ok, one last thing
18:33:32 <duaneb> how can I specify extensions in a file?/
18:33:41 <Berengal> {-# LANGUAGE
18:33:43 <duaneb> it's like {#MultiParamTypeClasses#} or something
18:33:58 <jfredett> I remember there was some way to do this- but how do I dynamically include the current version number / path information of a cabalized package within the program?
18:34:17 <jfredett> I think it was some kind of auto-generated import, but I can't find the info online.
18:34:21 <Saizan_> jfredett: import Paths_$pkgname
18:34:24 <hatds> {-# LANGUAGE ...stuff... #-}
18:34:44 <jfredett> awesome, is there a Doc that contains all that stuff, so I can bookmark it?
18:34:57 <hatds> format of 'stuff' is remove the "-X" from compiler flags, e.g. -XBangPatterns flag becomes BangPatterns
18:35:13 <Saizan_> have you looked at the documentation on haskell.org/cabal ?
18:35:36 <jfredett> I've looked through it, but theres a lot...
18:35:50 <jfredett> I'll check it again, now thatI know what I'm looking for.
18:36:07 <Saizan_> i'm not sure if it's actually there
18:36:27 <jfredett> hmm
18:38:08 <jfredett> aha! http://haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#paths-module
18:38:29 * jfredett would have never found that if he hadn't known what to look for.
18:38:32 <jfredett> Saizan_++
18:38:33 <jfredett> !
18:39:58 <sysadmin> is anyone using yi?
18:40:03 <Lemmih> I am.
18:40:14 <sysadmin> what platform?
18:40:38 <Lemmih> Linux, x86-64
18:40:41 <sysadmin> Man, it would be so great to have my editor all juiced up on haskell.
18:41:23 <naxa> hi
18:42:33 <naxa> I've got problems defining func. "multiplicity" in http://pastebin.com/m507ab7b1 how do I do a pattern match on my data?
18:42:39 <duaneb> yi have an osx frontend yet?
18:44:13 <mauke> naxa: multiplicity (Bag []) _ = 0; multiplicity (Bag ((xn,xp):xs)) szo
18:44:39 <naxa> mauke: oh i got it, thanks! :)
18:46:42 <naxa> mauke: oh. it says now that couldn't match expected type Bag against inferred type [Pair] :S what am i doing wrong?
18:47:34 <mauke> you're calling multiplicity on xs
18:47:37 <mauke> which is not a Bag
18:48:50 <duaneb> hey, is there any way to get Cabal to automatically add /opt/local/lib to the lib search path
18:50:32 <Saizan_> put extra-lib-dirs: /opt/local/lib into your ~/.cabal/config
18:50:41 <Saizan_> that'll work for cabal-install
18:51:14 <duaneb> ok
18:52:52 <naxa> mauke: oh, my, thanks :)
18:53:07 <tiglionabbit> does anyone here use facebook?
18:54:09 <naxa> mauke: why, now it works. thank you mauke, you've saved my life. :)
18:54:17 <sysadmin> I'm cabal installing yi righ tnow.
18:54:49 <gwern> and so begins sysadmin's descent into the 6th circle
18:55:05 <gwern> (hope he has a poet handy)
18:55:13 <duaneb> hah
18:55:22 <duaneb> haskell's of the literate type, I see :P
18:55:51 <gwern> how many languages support literate files natively, eh?
18:55:57 <gwern> (2 kinds to boot)
18:57:08 <gwern> sysadmin: but srsly, you'll want to keep the source handy, if only to look at the bundled configs
19:00:20 <duaneb> anyone know how functional the cocoa frontend for yi is?
19:03:23 <duaneb> hrm.
19:03:51 <duaneb> utility-ht-0.0.5 requires QuickCheck < 2, yet yi 0.6.2 requires QuickCheck >= 2
19:08:42 <dons> duaprob. ok...
19:35:31 <jfredett> hmm, so- that Paths_$pkgname is fantastic for when you're compiling, but how can I make it work when I have things loaded in the interpreter, and am just hacking on the code?
19:37:35 <Leo> Hi!!!
19:39:56 <sjanssen> jfredett: use -idist/build/blahblahblah
19:40:35 <jfredett> oh- duh, that makes sense.
19:43:15 <sysadmin> Hm.. What's alex?
19:43:35 <sysadmin> I read about that at http://blog.zacbrown.org/2009/04/03/installing-yi-on-mac-os-x/
19:43:55 <sysadmin> where it said that it wont' find alex if .cabal/bin is not in your path, but it is in my $PATH.
19:47:23 <Cale> alex is a lexer generator
19:47:47 <Cale> You also have to have alex installed of course...
19:48:04 <Cale> (It probably should have installed it on its own...)
19:48:39 <Cale> But if you don't have an alex executable in ~/.cabal/bin then you should cabal install alex
19:50:04 <mmorrow> does the cabal alex package already have the .x's processed?
19:50:17 <mmorrow> because if not, you need alex to build alex..
19:50:42 <mmorrow> (or just process the .x's on another machine or get the reuslting .hs from elsewhere)
19:50:46 <mmorrow> *resulting
19:51:16 <mmorrow> (same for happy)
19:53:56 <sysadmin> Okay.  I cabal installed alex.
19:54:02 <sysadmin> Now do I have to cabal install yi all over again?
19:55:22 <Cale> sysadmin: any work which was done when the previous cabal install of yi failed will have been preserved
19:55:40 <Cale> So yeah, just run that command again and it should continue
19:55:42 <sysadmin> cabal is great.
19:56:02 <mmorrow> this looks interesting http://hackage.haskell.org/cgi-bin/hackage-scripts/package/visual-graphrewrite
19:56:03 <Berengal> cabal is indeed awesome
19:57:49 <psygnisfive> there are graph rewriting steps in haskell?
19:57:59 <copumpkin> yup!
19:58:04 <psygnisfive> do tell!
19:58:14 <copumpkin> you can even write your own rewrite rules
20:00:28 <dons> mmorrow: have you worked out how to use it?
20:01:12 <mmorrow> psygnisfive: the "graph" is the graph formed by heap nodes, where edges are pointers (:: Ptr HeapNode) contained in HeapNodes. "Rewriting" is just transformation of the heap done as a result of executing a program's code (some/all of which might also be contained in the heap)
20:01:29 <mmorrow> dons: no, i just saw it in the "whatsnew" list
20:01:58 <mmorrow> sometimes i wish the whatsnew list was longer and/or searchable by date
20:01:59 <psygnisfive> interesting
20:12:10 <Cale> Well, in general, the evaluation steps of a functional language are graph rewrites.
20:12:33 <copumpkin> but we also have rewrites for the AST
20:12:39 <copumpkin> or do those not count?
20:13:38 <Cale> In normal order/lazy evaluation, you look at the top of the graph and you match it against the left hand side of a function definition, making a graph transformation according to the corresponding right hand side.
20:15:18 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
20:15:19 <Cale> :)
20:15:39 <copumpkin> that is awesome
20:15:52 <mmorrow> yeah, the rewriting can be thought of at 3 (my choice of #) different levels: (1) transformations of the AST representing an expression done in the abstract, (2) transformation of either the AST or a rep thereof in some abstract machine done by code which that abstract machine interprets, (3) same as in 2, but s/abstract machine/hardware/ ==> so code and data are the same thing and the line is blurred between what is operating on what
20:15:59 <Twey> Why don't we have an OS that uses Cabal for its package management system, already?
20:16:22 <Cale> Cabal is a little bit specialised toward Haskell code at the moment, I think.
20:17:01 <mmorrow> so in (3) there, the graph can be thought of as acting on itself (if code in also contained in heap nodes)
20:17:32 <mmorrow> well, s/thought of/it literally does this/
20:17:35 <Saizan_> Twey: first of all you should write a better dependency resolver for cabal-install :)
20:17:44 <Twey> Ah :-P
20:19:25 <mmorrow> Cale: whoa, just saw that link. very cool
20:19:52 <Saizan_> it commits early to any choice made right now, something based on constraint programming or a SAT solver would be more flexible
20:21:07 <Twey> It moves too fast — I can't read it :(
20:21:40 <mmorrow> if we can figure out (this might already be possible somehow, e.g. the debugger does this with breakpoints, and hpc with "ticks") to instrument code the run an IO action whenever an heapnode is evaluated, that IO action can be to send info to a viewer which updates the view of the vacuum-like graph ==> you can animate (low-level) evaluation
20:22:14 <mmorrow> that would be sweeet
20:22:38 <Twey> That would be very sweet
20:22:45 <Twey> It would look awesome, and also be a great debugging tool
20:22:52 <mmorrow> totally
20:23:16 <Twey> I would look into GHC-as-a-library: it sounds like it should be possible
20:23:28 <tiglionabbit> what's a good server to develop haskell web applications with?
20:23:40 * Saizan_ 'd like SCC names on that graph
20:23:44 <mmorrow> Twey: yeah, i think this can be piggybacked on either the debugger's code or hpc's
20:24:09 <Twey> tiglionabbit: lighttpd is popular
20:24:28 <Twey> Most web frameworks can use anything that supports FastCGI
20:24:28 <mmorrow> (the debugger only works for bytecode though, so it'd have to be piggybacked on hpc i guess (if piggybacking is possible)
20:24:50 <Saizan_> tiglionabbit: happstack has also a built-in server
20:24:59 <Twey> Yeah
20:25:33 <Twey> Frameworks with built-in servers aren't so good for playing nicely with existing setups, though
20:26:22 <tiglionabbit> yeah well I just wanted it for experimenting
20:26:30 <tiglionabbit> I could try installing lighty on my dev machine though...
20:27:18 <Twey> tiglionabbit: Yeah, but it's easier to experiment if you don't have to set up a whole new port for it.  IMO.
20:28:14 <mmorrow> you can always forward certain requests to another server, but this is painful (for me at least, since i don't know that much about it)
20:28:28 <andyjgill_> mmorrow: Have you seen http://movies.unsafeperformio.com/hpctpreview2.mov
20:28:41 <mmorrow> andyjgill_: ooh, no
20:28:45 * mmorrow looks
20:29:16 <mmorrow> andyjgill_: whoa, is that the ajax ui?
20:29:28 <mmorrow> i just saw that the other day on hackage but haven't checked it out yet
20:29:51 <andyjgill_> Yes. on top of hpc. About 18 months ago.
20:29:58 <mmorrow> heh
20:30:09 <DarKoBrA> hola, alguien habla espaol?
20:30:35 <mmorrow> andyjgill_: i've gotta learn more about hpc
20:30:56 <andyjgill_> Galois released it, so its public, and I'm rewriting it, piece by piece. I just need time to work on it, or help.
20:31:29 <andyjgill_> But if your trying to build something on top of hpc, i've trodden that path a few times now. Lots can be done.
20:31:30 <mmorrow> andyjgill_: in particular, do you think that "piggybacking on hpc's integrated code instrumenting by ghc" is possible to run an arbitrary IO action in place of/in addition to a tick?
20:31:39 <andyjgill_> Yes.
20:31:50 <mmorrow> andyjgill_: nice! exciting.
20:32:03 <pimpkonFollower> DarKoBrA: perhaps, try #haskell.es
20:32:04 <Twey> DarKoBrA: ¡Españoles son miticos!
20:33:03 <andyjgill_> I was running some C code at each tick at one point. Look through the GHC repo about Nov 2006.
20:33:20 <andyjgill_> boy time flies.
20:33:22 <mmorrow> nice, will do
20:33:23 <mmorrow> heh
20:33:27 <cads> andyjgill_: that video's nifty, who are those guys?
20:34:21 <andyjgill_> cads: ? It was an extension to hpc, a sign of things to come.
20:35:01 <kerlo> Qué son "miticos"?
20:36:09 <kerlo> Hmm, "mythical".
20:37:11 <mmorrow> andyjgill_: also, data-reify is interesting. i just yesterday used that idea (StableNames to break up a piece of data into a graph with sharing explicit) in some code to break up/put back together a rep of a C type so that it can be serialized in the first part of a binary stream, then decoded and reconstructed by the other end in order to figure out how the decode the rest
20:37:46 <mmorrow> so you can make circular descriptions of C data, and then be able to serialize them
20:38:04 <mmorrow> myRep = Struct [D, Struct [P myRep, I], ...]
20:38:21 <andyjgill_> mmorrow: Cool. Glad it was useful. I've got a new version 0.3 uploaded, and a paper written about it on my webpage.
20:38:54 <mmorrow> nice, yeah i just downloaded 0.3. didn't know about the paper, will check it out
20:38:55 <andyjgill_> mmorrow: There seems to be lots of uses for it, once you have it.
20:39:04 <mmorrow> andyjgill_: totally, i think so too
20:42:28 <mmorrow> heh, i also needed mdo for the first (non-gratuitous) time in the code to reconstruct the Rep from the RepGraph
20:50:44 <mmorrow> andyjgill_: ah yeah, i tried initially to access the paper from data-reify's hackage page, but the link is broken (http://ittc.ku.edu/~andygill/data-reify.php)
20:50:58 <mmorrow> (just found it though)
20:52:23 <andyjgill_> Yes. I've not written it (yet) it will point to the paper, and give a couple of examples. Perhaps tomorrow.
20:54:54 <mmorrow> oh, so you're writing a data-reify-specific one in addition to this http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09
20:55:48 <naxa> hi (it's me again:))! I have a data named Bag here: http://pastebin.com/m804b605 now I would like to write something to insert into Bag and delete into Bag but i can't figure out how to do this. it would also be so nice if I could see somehow what is in an instance of Bag but I didn't get how to do that showy thing yet
20:56:00 <naxa> *delete from
20:56:35 <naxa> someone has a hint how to do a working insert?
20:56:54 <andyjgill_> mmorrow: no, DSLExtract09 is the paper about data-reify.
20:57:26 <Berengal> naxa: insert is just (:)'
20:57:35 <mmorrow> andyjgill_: ah, gotcha..
20:57:49 <Berengal> > let insert = (:) in insert 5 [4,3,2,1]
20:57:50 <lambdabot>   [5,4,3,2,1]
20:57:56 <mmorrow> andyjgill_: "it will point to the paper, and give a couple of examples" :)
20:58:00 <mauke> data ... deriving (Show)
20:58:42 <Berengal> delete would be something like deleteBy (comparing fst)
20:59:13 <Berengal> > let delete = deleteBy (comparing fst) in delete 5 [5,4,3,2,1]
20:59:14 <lambdabot>   Couldn't match expected type `Bool'
20:59:23 <mauke> :t deleteBy
20:59:24 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
20:59:40 <mauke> > delete 5 [5,4,3,2,1]
20:59:41 <lambdabot>   [4,3,2,1]
20:59:41 <Berengal> > let delete = deleteBy ((==) `on` fst) in delete 5 [5,4,3,2,1]
20:59:42 <lambdabot>       No instance for (Num (a, b))
20:59:43 <lambdabot>        arising from the literal `5' at <in...
20:59:57 <Berengal> Bleh, I mess up again...
20:59:57 <naxa> Berengal: I have something like this ("apple",3) in an instance of bag. I would like to insert an apple. then I should have ("apple",4). I don't see how it is done with (:)
21:00:11 <Berengal> > let delete = deleteBy ((==) `on` fst) in delete 5 (join zip [5,4,3,2,1])
21:00:12 <lambdabot>       No instance for (Num (a, a))
21:00:12 <lambdabot>        arising from the literal `5' at <in...
21:00:23 <naxa> Berengal: also, I can do delete on a list but i don't know how to handle my data Bag
21:00:39 <naxa> Berengal: you see, i am a noob here and this is my homework.  :)
21:00:48 <Cale> naxa: deriving (Eq, Show)
21:00:54 <Berengal> naxa: Ah, okay
21:01:05 <naxa> Cale: thanks, I didn't get show was that simple... :)
21:01:12 <Berengal> Hmm, lists don't have insertWith?
21:01:47 <Cale> naxa: huh? You already have an insert function...
21:01:52 <Cale> Is it broken?
21:01:57 <naxa> Cale: wow, and I almos completed my own showBag function what does the same thing... :)
21:02:11 <naxa> Cale: this insert is not working for me
21:02:43 <naxa> Cale: the test case would be      insert surprise "peach"  ==  fromList [("apple",2),("strawberry",3),("peach",2)] ; this should be true, but it's false
21:03:40 <Cale> naxa: Ah right, you're not recursing along the list
21:04:38 <Cale> naxa: If the first element in the bag is "peach", then you want to increment its count. Otherwise, you want to add that element to the start of another bag which is formed by inserting peach into the remainder.
21:04:54 <naxa> Cale: that's right
21:05:16 <naxa> Cale: I think the problem is that after insterting peach it shows up as the first pair in the bag
21:05:24 <naxa> Cale: but originally it was the last
21:05:27 <Cale> yes.
21:05:30 <naxa> Cale: thus they're not equal
21:05:36 <Cale> So go with my method :)
21:06:12 <Cale> There's nowhere in your implementation of insert where you check to see if the thing to insert is equal to the value which is first in the bag.
21:06:48 <naxa> Cale: to be honest I am a bit lost with pattern matching and (:). this thing was my best guess. :)
21:07:06 <naxa> Cale: may I ask you to pastebin an example code for me with your way, maybe?
21:07:14 <Cale> Well, your function will look a lot like multiplicity, but it won't call multiplicity.
21:07:29 <naxa> Cale: let me see
21:08:22 <mauke> f x [] = [(x,1)]; f x ((k,v) : t) | x == k = (k, v+1) : t | otherwise = (k,v) : f x t
21:08:55 <naxa> Cale: hey, your way rocks. (sorry I haven't sleep today (coding various stuff..), so I only understood it now :D)
21:09:16 <naxa> Cale: now I try to implement this then
21:10:09 <mmorrow> andyjgill_: one thing i've been thinking about is using vacuum's/equivalent method to serialize, with sharing retained, the heapgraph of an arbitrarily-typed piece of data (and then be able to reify it later, but this direction would need rts code), similar to smlnj's ability.
21:10:17 <Berengal> Am I wrong it pointing out Data.Map?
21:10:30 <Cale> Berengal: Well, this is homework.
21:10:52 <Berengal> Cale: Yes, but we don't know the parameters
21:10:59 <Cale> Berengal: But normally, that would be a lot better than manipulating lists like this
21:11:04 <andyjgill_> mmorrow: I'd be delighted to help get something working.
21:11:07 <mmorrow> andyjgill_: unfortunately this has the current problem that ghc coerces unpointed closures to HValue, which it then proceeds to enter causes the prog to crash
21:11:07 <Cale> That's true
21:11:25 <Cale> If the homework is to implement a bag in any way possible, then Data.Map is the way to go.
21:11:50 <mmorrow> andyjgill_: cool. i'm gathering my ideas (for this and also the s/tick/IO ()/ stuff) currently, i'll let you know.
21:11:51 <Berengal> I'm a little surprised at the lack of support for assoclists actually...
21:12:20 <Cale> Association lists are generally one of the worst things for performance.
21:12:49 <Cale> (because people always want to use them to look stuff up)
21:13:09 <Berengal> Yeah, a Data.Map is just as easy to use
21:13:21 <andyjgill_> mmorrow: cheers!
21:13:27 <naxa> Cale, Berengal: well, may homework is to implement the "Bag" data structure what's like this [(string,int)]
21:13:41 <Berengal> naxa: Okay, so no Data.Map then :)
21:13:42 <naxa> Cale, Berengal and I should write some functions
21:13:43 <Cale> naxa: Right, so you don't have a choice :)
21:13:49 <naxa> I guess...
21:14:16 <Cale> naxa: But if you were allowed to use Map String Int  instead, your homework would be super-easy :)
21:14:34 <naxa> heehee
21:14:59 <naxa> so I hope it's really not just me. :P but the rules seem quite straightforward
21:15:06 <Cale> (because all the lookup, insertion, etc. would already be done for you)
21:15:14 <Berengal> It's not that hard to port the useful Map functions to assoc lists though...
21:15:23 <Berengal> But I guess that's the point of the homework anyway
21:15:37 <Cale> My guess is that doing so would not be in the spirit of the homework :)
21:16:01 <Berengal> Cale: I'm not talking about toList . foo . fromList functions
21:16:06 <Cale> Which is probably to get you comfortable with this sort of recursive idiom.
21:16:09 <Cale> oh
21:16:14 <Saizan_> Data.List.lookup is still useful
21:16:32 <Berengal> Saizan_: It's also about the only one we've got :P
21:18:15 <naxa> Cale: well, um. insert must be insert :: Bag -> String -> Bag ; now i don't see how to add the first element to the remainder if it's string part is not equal to the string what i want to insert, since i don't know how to add an element... it shouldn't be done with my insert function since then the int part of the originally first elemment would be lost... uh..
21:19:10 <naxa> but if I simply "repeat" my pattern then it will go nowhere... running forever...
21:19:28 <Berengal> naxa: Is insert supposed to insert a single item into the list?
21:19:55 <naxa> Berengal: let me say, yes. there is no way to tell it how much of that you want. it should insert only one
21:20:14 <Berengal> naxa: And if there is something there already, should it just add one?
21:20:30 <naxa> yeah
21:21:03 <naxa> yes
21:22:09 <QtPlaty[HireMe]> Is there a type function equiverlent to id?
21:22:10 <naxa> Cale, Berengal: oh... i think i see again... so sleepless... let me try again. :)
21:22:32 <mauke> @kind Identity
21:22:33 <lambdabot> * -> *
21:22:49 <QtPlaty[HireMe]> mauke: Thanks
21:22:51 * Berengal thinks an insertWith function for lists would be really handy in this case
21:23:34 <Berengal> insertWith :: (b -> b -> b) -> a -> b -> [(a, b)] -> [(a, b)]
21:24:06 <mauke> > let f x [] = [(x,1)]; f x ((k,v) : t) | x == k = (k, v+1) : t | otherwise = (k,v) : f x t in f "bar" [("foo",1), ("bar",2), ("baz",3)]
21:24:07 <lambdabot>   [("foo",1),("bar",3),("baz",3)]
21:24:59 <Saizan_> naxa: write an insert' :: Bag -> (String,Int) -> Bag, and then "insert b s = insert' b (s,1)"
21:25:44 <Berengal> insertWith f k v [] = [(k,v)]; insertWith f k v ((mk, mv):r) if mk == k then (mk, f mv v):r else (mk,mv):insertWith f k v r
21:25:52 <Saizan_> right, disregard my comment :)
21:26:07 <chromakode> hey all, what do you use to shuffle lists?
21:26:23 <mauke> I use oleg
21:27:09 <Saizan_> ?google oleg perfect shuffle
21:27:10 <lambdabot> http://okmij.org/ftp/Haskell/perfect-shuffle.txt
21:27:22 <chromakode> thanks mauke
21:27:41 <chromakode> nothing in the stdlib, I take it?
21:29:52 <naxa> Berengal: I'm affraid that's a bit too complex for me in my current state (..no..sleep..:)) but I'll try and, uh, do sg. :)
21:30:10 <dolio> @type insertWith
21:30:11 <lambdabot> Not in scope: `insertWith'
21:30:28 <dolio> @type insertBy
21:30:29 <lambdabot> forall a. (a -> a -> Ordering) -> a -> [a] -> [a]
21:30:31 <Berengal> naxa: It looks better if you put it in a text editor and format it properly and exchange the if with a guard
21:32:10 <Berengal> naxa: Basically: It takes a function (b -> b -> b), a key (a), a value (b) and a list of (a, b) ((key, value)). If the key isn't in the list, the key and value are added last. If the key is in the list already, the function is given the old value and the new value and the old value is replaced by that
21:33:13 <Berengal> > let insertWith f k v [] = [(k,v)]; insertWith f k v ((mk, mv):r) = if mk == k then (mk, f mv v):r else (mk,mv):insertWith f k v r in insertWith (+) "apple" 1 [("apple", 6)]
21:33:14 <lambdabot>   [("apple",7)]
21:33:20 <Berengal> > let insertWith f k v [] = [(k,v)]; insertWith f k v ((mk, mv):r) = if mk == k then (mk, f mv v):r else (mk,mv):insertWith f k v r in insertWith (+) "apple" 1 [("orange", 6)]
21:33:21 <lambdabot>   [("orange",6),("apple",1)]
21:34:04 <naxa> wow. how nice. :)
21:34:59 <wli> type MultiSet t = Map t Integer
21:36:24 <Berengal> I'm sure this could be done as a foldr...
21:37:39 <Berengal> As long as there's no duplicate keys at least
21:38:14 <mmorrow> @let histo = M.toList . (\m -> let n = (fromIntegral . sum) (M.elems m) in M.map (\x -> fromIntegral x / n) m) . foldl' (\m x -> M.insertWith' (+) x 1 m) mempty
21:38:15 <lambdabot>  Defined.
21:38:26 <naxa> Berengal: hey, now I see. :)) actually, I was just lost with my own try it's line "| otherwise = (Bag [((xn,xp)):(insert (Bag (xs)) szo)])" with some type errors... I'll try and reuse your great function in mine. :)
21:38:33 <mmorrow> > histo (take 1000000 . randomRs ('a','d') $ mkStdGen 0928094)
21:38:36 <lambdabot>   [('a',0.249969),('b',0.250017),('c',0.250311),('d',0.249703)]
21:38:47 <copumpkin> mm histo!
21:38:51 <mmorrow> weeee
21:39:05 <naxa> (if everything fails, I think I may just borrow it, since my time has grown very short lately. :))
21:39:53 <mmorrow> @let collect (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g b) m) mempty {- imo the most useful Map-related function evar -}
21:39:54 <lambdabot>  Defined.
21:40:28 <mmorrow> @let collect S.union fst (S.singleton . snd)
21:40:29 <lambdabot>   Parse error
21:40:36 <mmorrow> @type collect S.union fst (S.singleton . snd)
21:40:37 <lambdabot>     Ambiguous occurrence `collect'
21:40:37 <lambdabot>     It could refer to either `L.collect', defined at <local>:3:0
21:40:37 <lambdabot>                           or `Test.QuickCheck.collect', imported from Test.QuickCheck
21:40:40 <mmorrow> sigh
21:40:51 <mmorrow> @let wrangle (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g b) m) mempty {- imo the most useful Map-related function evar -}
21:40:52 <lambdabot>  Defined.
21:41:05 <mmorrow> @type wrangle S.union fst (S.singleton . snd)
21:41:06 <lambdabot>     Couldn't match expected type `Expr' against inferred type `(a, b)'
21:41:06 <lambdabot>       Expected type: Expr -> b1
21:41:06 <lambdabot>       Inferred type: (a, b) -> b
21:41:32 <mmorrow> crap
21:41:40 <mmorrow> @let wrangle' (<>) f g = foldl' (\m a -> M.insertWith' (<>) (f a) (g a) m) mempty {- imo the most useful Map-related function evar -}
21:41:40 <lambdabot>  Defined.
21:41:43 <mmorrow> @type wrangle S.union fst (S.singleton . snd)
21:41:44 <lambdabot>     Couldn't match expected type `Expr' against inferred type `(a, b)'
21:41:44 <lambdabot>       Expected type: Expr -> b1
21:41:44 <lambdabot>       Inferred type: (a, b) -> b
21:41:46 <mmorrow> @type wrangle' S.union fst (S.singleton . snd)
21:41:47 <lambdabot> forall a b. (Ord a, Ord b) => [(a, b)] -> M.Map a (S.Set b)
21:41:51 <mmorrow> </spam>
21:42:27 <mmorrow> @type \f -> wrangle' mappend fst (f . snd)
21:42:28 <lambdabot> forall a b c. (Ord a, Monoid c) => (b -> c) -> [(a, b)] -> M.Map a c
21:42:50 <mmorrow> @type \f -> wrangle' (+) id (const 1)
21:42:51 <lambdabot> forall t a b. (Ord b, Num a) => t -> [b] -> M.Map b a
21:42:53 <mmorrow> @type wrangle' (+) id (const 1)
21:42:54 <lambdabot> forall a b. (Ord b, Num a) => [b] -> M.Map b a
21:43:02 <mmorrow> etc
21:43:39 <Berengal> Yeah, map's nice
21:44:16 <mmorrow> i'd say i import (Int)Map into 80% of modules i write
21:45:06 <wli> Finished watching Memento? What's Memento?
21:45:17 <mmorrow> i don't remember
21:45:18 <copumpkin> IntMap is awesome
21:45:29 <mmorrow> copumpkin: yeah totally
21:45:43 * wli has had better luck using Integer as a bitmap.
21:45:45 <mmorrow> it's nice too because it's actually pretty easy to implement
21:45:55 <mmorrow> (IntMaps never have to be balanced)
21:45:56 <copumpkin> I think Map should be an associated type, with IntMap just being Map Int
21:45:58 * wli has mostly dense sets.
21:46:09 <copumpkin> well
21:46:12 <copumpkin> not "be an associated type"
21:46:14 <copumpkin> but you know what I mean
21:46:20 <mmorrow> copumpkin: yeah, that would be nice. the only thing that gets in the way is that you can't do:
21:46:29 <wli> Or dense enough sets that the bitmap wins.
21:46:37 <mmorrow> type family Map k v
21:46:51 <mmorrow> type instance Map Int v = IntMap v
21:46:59 <mmorrow> type instance Map k v = M.Map k v
21:47:31 <mmorrow> which is unfortunate
21:47:40 <copumpkin> it seems like the type system should allow that though
21:47:48 <copumpkin> even though it currently doesn't
21:48:03 <mmorrow> yeah, with classes too there's no concept of "everything except"
21:48:20 <mmorrow> instance Foo (everything but (Tree Int)) where ...
21:48:21 <copumpkin> yeah, seems like it wouldn't be too hard to tack on?
21:48:28 <naxa> Berengal: I have something like this: http://pastebin.com/m42cc0e82 and it's not working becouse either expected type is (String,Int) but inferred is Bag or i do (Bag (xs,xp)):instert... and then expected type is [Pair] but inferred is (String,Int).... uh... i can't see, why is that. why is that?
21:48:38 <mmorrow> copumpkin: i dunno, but it seems logical
21:48:51 <Saizan_> copumpkin: OverlappingInstances are already problematic, because of separate compilation
21:49:37 <copumpkin> yeah... but with type families I didn't think you could add stuff on later?
21:49:48 <Berengal> naxa: You need to pull the list out of the Bag, so a toList function is in order
21:50:03 <Saizan_> copumpkin: sure you can
21:50:10 <copumpkin> oh ok
21:50:49 <Saizan_> in fact, there's at least a paper mentioning closed type families, to allow overlapping patterns
21:50:56 <copumpkin> ah, interesting
21:51:50 <Berengal> naxa: It might be easier to just implement the insert and delete functions and so on on just lists, then wrap them in fromList . foo . toList to make them operate on bags
21:52:48 <Berengal> naxa: So make an insertList function, then just let your insert function take the bag, unwrap the list it contains, and call the insertList function
21:53:04 <Berengal> Anyway, work...
21:53:44 <roconnor> I'm not sure how to deal with my feelings of disdain for the Haskell Platform.
21:54:24 <mmorrow> copumpkin, Saizan_ : yeah, personally i would find type function that are more like functions to be more useful (i.e. you can't put a case for a function in another module, that would be crazy!! and also you can try matches in order)
21:54:31 <wli> The "Haskell Platform?"
21:54:48 <roconnor> wli: http://hackage.haskell.org/platform/
21:54:55 <mmorrow> typef F (Int,_) = Maybe [Double]
21:55:06 <mmorrow> typef F (Tree (Maybe _)) = ()
21:55:14 <mmorrow> typef F _ = [Int]
21:55:30 <mmorrow> or something
21:55:35 <wli> roconnor: No idea I've never seen it before.
21:55:43 <inimino> roconnor: the idea, or the execution?
21:56:08 <roconnor> inimino: good question.  I don't like the execution, because I don't like the choice of packages.
21:56:18 <roconnor> inimino: which makes me think that the whole idea is bad.
21:56:46 <jfredett> hmm, does ghci have an associated .ghcirc config thing? something to automatically set options (turn on timing, add default seach locations, etc?)
21:56:49 <roconnor> what really is upsetting is that I might not be upset if I liked the choice of packages.
21:57:28 <mmorrow> jfredett: .ghci
21:57:40 <mmorrow> jfredett: $HOME/.ghci
21:57:43 <inimino> roconnor: so perhaps it's too early for something so standardized
21:57:46 <jfredett> mmorrow: it will automatically load that on startup?
21:57:50 <mmorrow> jfredett: yes
21:57:54 <jfredett> awesome
21:58:00 <roconnor> inimino: perhaps
21:58:19 <Saizan_> roconnor: well, the list of packages is supposed to grow
21:58:22 <roconnor> inimino: but I kinda think if cabal gets better, then there is no need for standardization
21:58:29 <mmorrow> you can put on each line any valid single-line input to ghci
21:58:44 <roconnor> Saizan_: I want the mtl out. ... as is well know around this channel :)
21:58:46 <mmorrow> jfredett: so :set's, "let foo = .. "'s, etc
21:58:51 <roconnor> well known
21:58:52 <jfredett> awesome
21:58:55 <jfredett> awesome indeed.
21:59:03 <inimino> roconnor: well, I would very much like to see /that/ happen
21:59:14 <roconnor> inimino: see what happen?
21:59:29 <wli> roconnor: What's wrong with the mtl?
21:59:40 <roconnor> wli: I have a list of 3 things
21:59:43 <inimino> cabal get better
22:00:02 <pimpkonFollower> roconnor: Have you thought about a choice of packages that you wouldn't object to, or is the means used to pick the packages also objectionable to you? :)
22:00:31 <roconnor> one sec
22:00:58 <Saizan_> inimino: what in particular?
22:01:44 <Saizan_> the right question is "how", maybe
22:01:44 <inimino> roconnor: though until cabal gets better it would also be nice to have 'apt-get install haskell haskell-dev' and get "batteries included"
22:02:01 <roconnor> pimpkonFollower: I haven't thought too much, but I could.  However, clearly the platform shouldn't be what *I* want.  That woudl be ridiculous.
22:02:45 <roconnor> inimino: so by /that/ you meant "cabal becoming better?"
22:03:17 <roconnor> wli: 1) one of the cont/state instances that is wrong.
22:03:23 <BMeph> roconnor: Why is it ridiculous? It's only a problem if your reasons for your choices are so personal that they wouldn't apply to anyone else. If your objections are objectively valid, then they're relevant (er, by defn). :)
22:03:37 <wli> Okay
22:03:44 <inimino> Saizan_: mainly it's just frustration with upgrade issues between GHC, base libraries, etc
22:03:46 <inimino> roconnor: yes
22:03:49 <roconnor> wli: 2) pass shouldn't be in the writer class, and I'm suspicous of other methods too
22:04:31 <roconnor> wli: 3) I'm told the state/value pair is backwards.  I'm not sure why it is a problem, but lots of reputable people say it is.
22:04:54 <roconnor> BMeph: ah good point.
22:05:15 <mmorrow> roconnor: re: StateT (Cont), imo choosing/having just one of the two possible cases is wrong, both should be there (callCC1 and callCC2)
22:05:28 <roconnor> BMeph: so maybe I should cry out loudly, "replace the mtl with monadlib" to the Platform people?
22:05:42 <mmorrow> so both mtl *and* monadLib's instances are wrong, since neither has both :)
22:06:18 <BMeph> mmorrow: "Both" being 1) and 3)?
22:06:19 <roconnor> mmorrow: the modular monad transformer paper clearly picked out one.
22:06:49 <mmorrow> roconnor: picking on is like making an Either type, and then only exporting one of {Left,Right} constructors.
22:06:55 <mmorrow> *picking one ...
22:07:43 <mmorrow> BMeph: both being two callCC versions, one of which retains the state when the cont is called, and one that rolls it back when the cont is called
22:07:56 <mmorrow> mtl does the former, monadLib the latter
22:08:07 <roconnor> mmorrow: you can write both functions.  there is no problem, but it makes no sense to put two callCCs into the class definition.
22:08:32 <mmorrow> well, then the class is broken since it's unable to account for all possibilities :)
22:09:03 <roconnor> mmorrow: that's not what the class instance is for.
22:09:13 <mmorrow> also, you can't write both versions if you don't have access to the constructors of the newtype, which monadLib doesn't export (?)
22:09:31 <roconnor> mmorrow: when you have (MonatContT r m), you have no idea if m has State or not.
22:09:44 <mmorrow> roconnor: well, that's a problem here
22:09:51 <roconnor> mmorrow: go write your own (MonadContState) class
22:10:02 <mmorrow> i have and do whenever i need such a monad :)
22:10:06 <roconnor> just depend on monadLib instead of the mtl :)
22:10:13 <mmorrow> i depend on neither :)
22:10:18 <roconnor> even better
22:10:36 <roconnor> mmorrow: heck, you probably don't need classes at all
22:10:48 <mmorrow> heh, yeah i don't actually use classes with monads
22:11:16 * mmorrow has to take a break from irc and actually do what he's been trying to get done..
22:11:31 <dancor_> how do you determine if you want foldl or foldl'
22:11:40 <roconnor> mmorrow: what you were talking about had nothing to do with MonadCont
22:11:44 <naxa> Berengal: may I ask you to help me create something like this insertWith :: (b -> b-> b) -> a -> b -> (a,b) -> (a,b) ; (dunno how is it called, definition?) what works with my script? I'm sorry for asking such a lame thing but my time is too short and I am too sleepy
22:11:53 <mmorrow> roconnor: it does, but indirectly
22:12:04 <roconnor> dancor_: if you are producting a primitive type, you want foldl'
22:12:54 <dancor_> i have a list of chess moves that i'm folding over to generate the current board state of a chess game
22:13:06 <roconnor> mmorrow: the question is, if you have code that operates on a generic MonadCont, how do you want it to behave when applied to a ContT r (State s) monad?
22:13:43 <roconnor> and how do you want it to behave when applied to a StateT s (Cont r) monad?
22:14:21 <mmorrow> roconnor: so given that for certain values of MonadCont, there isn't one single canonical choice for callCC, my view is that having a MonadCont class at all becomes debatable
22:15:05 <mmorrow> (or rather, a MonadCont in its current form, but i can't really think of a solution though, so ...)
22:15:18 <wli> I got the right answer for addition chain multiplication but it took 10 hours.
22:15:20 <roconnor> mmorrow: there is a canonical choice.   See the modular monad transformer paper.
22:15:40 <mmorrow> roconnor: there is not a canonical choice for StateT Cont!! :)
22:15:52 <roconnor> paper!!!
22:15:55 <roconnor> :)
22:16:02 <mmorrow> we'll see.
22:16:15 <roconnor> we'll see?
22:16:32 <dolio> There's a right choice and a wrong choice for StateT Cont.
22:16:50 <roconnor> the canonical choice gives you operation that behave in a uniform way, just like all the other monad transformer operations.
22:16:53 <dolio> So whether there's a canonical choice is kind of irrelevant in that case. :)
22:17:24 <roconnor> and so you can reason about your code in a uniform way
22:17:45 <roconnor> things are less surprising and more maintainable
22:18:02 <Saizan_> that's a modular monad transformer paper?
22:18:15 <roconnor> @where mmtl
22:18:15 <lambdabot> I know nothing about mmtl.
22:18:18 <roconnor> @where mmt
22:18:18 <lambdabot> I know nothing about mmt.
22:18:20 <roconnor> hmm
22:18:24 <Saizan_> @hackage mmtl
22:18:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mmtl
22:19:57 <roconnor> http://www.cs.nott.ac.uk/~mjj/publications.html#mmt
22:20:32 <roconnor> ``in addition to the construction of a monad, the effect-manipulating operations need to be lifted to the resulting monad. The traditional approach for lifting operations is non-modular and ad-hoc. We solve this problem with a principled technique for lifting operations that makes monad transformers truly modular.
22:20:49 * roconnor <3 principled techniques
22:21:23 <Saizan_> thanks
22:22:14 <naxa> Berengal: may I ask you to help me create something like this insertWith :: (b -> b-> b) -> a -> b -> (a,b) -> (a,b) ; (dunno how is it called, definition?) what works with my script? I'm sorry for asking such a lame thing but my time is too short and I am too sleepy
22:22:32 <naxa> whoops... this wasn't on purpose
22:22:44 <naxa> anyway, if Berengal spots it I would be happy :)
22:23:08 <dolio> roconnor: Nice. Now I have mathematical weight for that version of callCC, rather than just noting that it's obviously the right one. :)
22:23:13 <roconnor> @where+ mmt http://www.cs.nott.ac.uk/~mjj/pubs/mmt/mmt.pdf
22:23:14 <lambdabot> It is forever etched in my memory.
22:24:51 <roconnor> BMeph: maybe I should air my concerns in a trac ticket.
22:25:48 <Saizan_> mmtl needs more advertising
22:26:04 <copumpkin> naxa: trying to figure out your type signature there
22:26:19 <roconnor> I think I still recommend monadLib over mmtl
22:26:25 <roconnor> but I'm not sure
22:26:26 <copumpkin> naxa: what does it do with one of the two as ?
22:28:50 <copumpkin> naxa: oh, I see, you want (Eq a) => (b -> b -> b) -> a -> b -> [(a, b)] -> [(a, b)] -- ?
22:28:53 <naxa> copumpkin: http://pastebin.com/d4c58e667 this is my code
22:29:03 <naxa> copumpkin: oh, let me see :)
22:29:03 <Twey> naxa: It's called a type
22:29:24 <naxa> ah, I didn't know where I put Eq a :)
22:29:30 <naxa> Twey: thanks
22:29:40 <copumpkin> well there's also the [(a, b)]
22:29:42 <copumpkin> right?
22:30:12 <dolio> roconnor: mmtl still has the run* functions in the inconvenient order.
22:31:09 <naxa> copumpkin: i don't know why it says parse error on => if I use your idea
22:31:16 <naxa> ???
22:31:35 <copumpkin> naxa: oh, I was just trying to understand what you were asking
22:31:38 <copumpkin> it's not a solution :)
22:32:00 <BMeph> roconnor: Have you already discussed it in -cafe? :)
22:32:05 <naxa> copumpkin: oh I see. :) well it's something like this but I'm affraid I won't be able to figure out that on my own in time (half an hour)
22:32:26 <dolio> copumpkin: I fixed my optimal sorts to be stable, by the way. It wasn't as bad as I had expected.
22:32:45 <copumpkin> dolio: oh cool, so your 100% coverage revealed no other bugs?
22:32:48 <dolio> copumpkin: I could still compare things in the same order, I just had to change tests for LT to tests for GT.
22:32:52 <naxa> copumpkin: with my code shown, my homework is to implement the "Bag" data structure with this insert function... now I use this insertWith  function thanks to the help here but I can't tell what it's type actually
22:32:59 <Twey> Eq k => (v -> v -> v) -> k -> v -> [(k, v)] -> [(k, v)]
22:33:08 <copumpkin> that's a lot more legible :P
22:33:27 <Twey> I agree
22:33:41 <Twey> Took me a moment and a look at Data.Map.insertWith to work out what that first one was supposed to do :-P
22:33:53 <naxa> Twey, copumpkin: well, it gives me the same "parse error on input =>"
22:34:01 <naxa> I wonder what this means??
22:34:10 <Twey> It means you did something wrong
22:34:18 <dolio> copumpkin: Well, my hpc says that my existing tests result in 100% of the code being run. But, of course, there could be bugs that I don't test for.
22:34:20 <naxa> Twey: yeah i guessed that. :)
22:34:33 <Twey> Well, maybe if you paste your code we can see what it was.
22:34:35 <copumpkin> dolio: makes sense
22:34:43 <BMeph> roconnor: Just curious, but have you tried the monatron lib?
22:35:07 <dolio> I had 100% code coverage before I figured out that merge sort wasn't stable (by way of the optimal sorts).
22:35:28 <naxa> Twey: it's here http://pastebin.com/d7a0f3972
22:36:05 <Twey> naxa: Yeah... you missed out the :: (‘has type’) sign
22:36:17 <naxa> oh whoops
22:36:19 <naxa> :D
22:36:36 <naxa> Twey: hey much better, thanks pal :)
22:37:49 <copumpkin> > let insertWith f k v xs = case lookup k xs of Nothing -> insert (k, v) xs; Just v' -> insert (k, f v' v) (deleteBy ((==) `on` fst) (k, undefined) xs) in insertWith (+) 1 5 [(0, 4), (1,3)]
22:37:50 <copumpkin> lol
22:37:50 <lambdabot>   [(0,4),(1,8)]
22:37:58 <copumpkin> world's ugliest insertWith
22:38:19 <copumpkin> oh, I could've just used a map
22:38:28 <copumpkin> ah well
22:38:47 <Twey> insertWith f k v old = case lookup k old of Nothing -> (k, v) : old; Just oldval -> (k, f oldval v) : old
22:39:02 <copumpkin> you want to maintain it in order though
22:39:19 <Twey> Oh, need to remove the old one, I guess
22:39:32 <copumpkin> that too
22:39:32 <Twey> copumpkin: No, you don't — not with [(k, v)]
22:39:39 <Twey> lookup only requires Eq, not Ord
22:39:39 <copumpkin> oh
22:39:44 <copumpkin> yeah, silly me :)
22:39:49 <Twey> :t Prelude.lookup
22:39:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
22:40:00 <copumpkin> but yeah, that ugly deleteBy was to get rid of the old one
22:40:14 <copumpkin> (k, undefined) ftw
22:41:27 <copumpkin> so I understand GADTs... but when people say they bring us closer to dependent types
22:41:38 <naxa> copumpkin, Twey: hey, could you help me to tweak this insertWith to leave out a key if it's value is 0? anyway, i have to use sg like this for my homework, cannot use Map
22:42:02 <Twey> copumpkin: It's not bad, but did you think of maybe just doing ‘deleteBy ((== k) `on` fst)’?  :-P
22:42:09 <naxa> also, I'm asking this becouse I'm affraid that I'm running out of time (18 minutes to go:)) and uh well.
22:42:25 <copumpkin> Twey: it wants an a, that's what I tried first
22:42:37 <Twey> Ah, OK
22:42:43 <Twey> :t deleteBy
22:42:44 <lambdabot> forall a. (a -> a -> Bool) -> a -> [a] -> [a]
22:42:47 <copumpkin> naxa: use filter (/= 0)
22:42:59 <Twey> Darn
22:43:23 <naxa> copumpkin: the problem is not logical, i am lost with where should i write what in haskell :)
22:43:43 <copumpkin> so the insertWith should be filtering the key out?
22:43:59 <naxa> copumpkin: yes, basically
22:44:25 <copumpkin> at the very simplest, you can do insertWith f k v xs | k == 0 = xs ; | otherwise = <the crap I wrote before>
22:44:34 <copumpkin> or even just a pattern match
22:45:01 <copumpkin> insertWith _ 0 _ xs = xs; insertWith f k v xs = <the crap from before>
22:45:15 <Twey> http://www.haskell.org/pipermail/haskell/2001-May/007382.html
22:45:18 <Twey> That's daft
22:45:35 <copumpkin> naxa: you should learn this stuff though, and don't leave it to the last minute in future :P it's so fun!
22:46:02 <dolio> copumpkin: GADTs are inductive families where the indices are restricted to being types.
22:46:05 <copumpkin> Twey: I agree, a lot of h98 seems rather daft
22:46:22 <naxa> copumpkin: sure it is, too bad I had to spend 3 days figuring out a perl script as another homework, just to ruin the whole experience in the end
22:46:32 <naxa> copumpkin: so basically i am out of time
22:46:39 <copumpkin> naxa: I can see that :)
22:47:28 <naxa> copumpkin: actually it would be appriciated if you could edit my pastebin since i am so tired that i think I'll hardly manage to do that filtering without knowing how to do it in the first place
22:47:30 <roconnor> BMeph: nope
22:47:53 <roconnor> BMeph: I have neither looked at that lib nor discussed anything -cafe
22:47:54 <naxa> well, at least in 13 minutes
22:47:58 <copumpkin> naxa: lol, this is getting a little too much, but if you insist... :P
22:48:10 <copumpkin> naxa: but you need to promise to hang out in #haskell more! and learn!!
22:48:11 <copumpkin> :P
22:48:16 <naxa> copumpkin: i am really sorry, but I'd be grateful if you could help out :)
22:48:23 <naxa> ok :)
22:49:02 <naxa> I enjoy doing haskell so it's actually a pain to ask such a thing
22:49:54 <copumpkin> naxa: http://pastebin.com/d420c56cf
22:50:07 <copumpkin> naxa: I haven't tested it, and the code probably doesn't look like you wrote it, with that undefined in there :P
22:50:16 <roconnor> dolio: are the ContT State and StateT Cont callCC functions (supposed to be) the two different ways that mmorrow talks about?
22:50:35 <naxa> copumpkin: it's just worth to see a working syntax for me. :)
22:50:43 <Renderwahn> how can I convert a float to string?
22:50:59 <copumpkin> show
22:51:05 <copumpkin> > show (0.2 :: Float)
22:51:06 <lambdabot>   "0.2"
22:51:26 <copumpkin> dolio: I'm ruminating on that :P
22:51:28 <dolio> roconnor: StateT Cont can either roll back the state or not. ContT State can't roll back the state (I think).
22:51:30 <Renderwahn> great \o/
22:52:18 <ski> @unmtl ContT o (State s) a
22:52:19 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
22:52:26 <ski> @unmtl StateT s (Cont o) a
22:52:26 <lambdabot> s -> (a -> s -> o) -> o
22:53:25 <ski> (roconnor : talks about where ?)
22:53:54 <mmorrow> roconnor: yeah, it's w/in StateT Cont that there are the two possibilities
22:54:10 <roconnor> talks about on #haskell a little less than 1 hour ago
22:54:12 <mmorrow> roconnor: (haven't looked at that paper yet, but will
22:54:19 <ski> ok
22:54:55 <copumpkin> dolio: okay, I don't really get inductive families, I guess :P
22:55:03 <copumpkin> I've seen a couple of agda examples
22:55:16 <roconnor> dolio: so the /right/ way makes it so that StateT Cont rolls back state and ContT State doesn't roll back state?
22:55:36 <dolio> Yes.
22:55:46 <roconnor> that does seem satisfying
22:56:16 <BMeph> roconnor: Not that I want to discourage you from Trac posting, but I'd imagine a little -cafe talk to be in order... :)
22:56:26 * ski is unsure about that ..
22:56:29 <naxa> copumpkin: ok. how do i add Eq b to the type signature of insertWith? :))
22:56:39 <copumpkin> it's already there isn't it ?
22:56:46 <dolio> That also matches with, for instance, StateT [] rolling back the state, where ListT State doesn't (or LogicT if you prefer).
22:56:46 <roconnor> BMeph: I'll think about that.  I kinda dislike -cafe a little bit.
22:56:48 <copumpkin> insertWith :: Eq k => ...
22:57:03 <naxa> copumpkin: insertWith :: (Eq a)=> (b -> b -> b) -> a -> b -> [(a, b)] -> [(a, b)]
22:57:09 <roconnor> BMeph: it's kinda a noisy cafe :P
22:57:26 <copumpkin> naxa: yup, that should work
22:57:28 <BMeph> roconnor: Sure. I don't dislike it, but I do notice that I tend not to follow it. :)
22:57:30 <roconnor> But yeah, maybe a -cafe post is a good place to start
22:57:33 <roconnor> get some ideas
22:57:51 <roconnor> right, maybe dislike was too strong
22:58:09 <ski> @unmtl StateT s [] a
22:58:09 <lambdabot> s -> [(a, s)]
22:58:11 <naxa> copumpkin: it's definietly not working with my somehow very ugly insertWith f k 0 xs = xs :)
22:58:22 <ski> how does that roll back the state ?
22:58:30 <ski> dolio : ^
22:58:36 <copumpkin> naxa: hmm, you have 0 for your value, not your key
22:58:38 <naxa> ay anyway i'm too stupid and sleepy, sorry, what a mess
22:58:56 <naxa> ah... :)
22:59:49 <Saizan_> > flip runStateT 0 $ (put 4 >> get) `mplus` get
22:59:50 <lambdabot>       No instance for (Show (m (s, s)))
22:59:50 <lambdabot>        arising from a use of `show' a...
22:59:59 <Saizan_> > flip runStateT 0 $ (put 4 >> get) `mplus` get :: [(Int,Int)]
23:00:00 <lambdabot>   [(4,4),(0,0)]
23:00:06 * roconnor sleeps
23:00:41 <dolio> ski: Conceptually, when you backtrack, state changes since the branch point are rolled back.
23:01:05 <ski> that's one way to *implement* it, in terms of mutable state, yes
23:01:43 <ski> similar to one way to *implement* a `local' combinator for environment is by storing old value on stack, and restoring when returning
23:02:00 <ski> i don't agree that it's fundamentally rolling back state, though
23:02:24 <Saizan_> ski: the point is that each path has its own state, while with LogicT State the same state survives across mplus
23:02:30 <ski> i rather view it as splitting (copying) the state, for each nondeterministic choice
23:02:48 <ski> *nod*
23:03:00 <dolio> callCC isn't "fundamentally" rolling back state, either. It's constructing a closure that passes the old state to a continuation.
23:03:29 <naxa> copumpkin: insertWith :: (Eq a, Num b) => ...  was what i was searching for! :D
23:03:31 <ski> `call-with-current-continuation' in Scheme sure is not rolling back any state at all
23:03:37 <copumpkin> naxa: ah, that makes sense
23:03:40 <Saizan_> well, considering that we often call [] the backtracking monad, and that the state follows the same pattern as the values..
23:03:48 <naxa> copumpkin: yeah. :D
23:04:07 <ski> (when you invoke a continuation captured with that, the state is not rolled back to what it was when the continuation was captured)
23:04:34 <dolio> We're not talking about scheme, we're talking about StateT Cont.
23:04:44 <ski> yes
23:05:05 <ski> i can see how one can implement the Scheme-like semantics with
23:05:07 <ski> @unmtl StateT s (Cont o) a
23:05:07 <lambdabot> s -> (a -> s -> o) -> o
23:05:17 <ski> but not with
23:05:18 <ski> @unmtl ContT o (State s) a
23:05:18 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
23:05:41 <mmorrow> roconnor, ski: here's a minimal presentation http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2387#a2387
23:05:45 <ski> so maybe there really is two different useful ways of handling the interaction of state and continuation in the first ?
23:05:48 <Gracenotes> hm? it unmtls StateT into continuations?
23:06:30 <mmorrow> this is flattened StateT Cont:
23:06:32 <mmorrow> newtype M r s a = M {unM :: (a -> s -> r) -> s -> r}
23:06:44 * ski nods
23:06:48 <dolio> > runState (runContT (callCC (\k -> put 2 >> k ())) id) 1
23:06:49 <lambdabot>   Couldn't match expected type `State s a' against inferred type `()'
23:07:01 <dolio> > runState (runContT (callCC (\k -> put 2 >> k ())) return) 1
23:07:02 <lambdabot>   ((),2)
23:10:36 <mmorrow> , flip runCont (flip runStateT (callCC (\k -> set 2 >> k ())) 1) id
23:10:37 <lunabot>  ((),1)
23:10:46 <mmorrow> > runCont (runStateT (callCC (\k -> put 2 >> k ())) 1) id
23:10:47 <lambdabot>   ((),2)
23:13:53 <naxa> copumpkin: hey it just worked out. thanks for help! And in the end i didn't need to steal your code. :) What a relief.
23:14:59 <ski> hmm
23:15:17 <naxa> copumpkin: too bad that I've got a message that the program is not ok in the end... however, since it does what it needs and also works with all the test cases, i don't know, how could this be the cage, I should consult my teacher i guess...
23:15:32 <naxa> *case
23:15:34 <naxa> :)
23:15:46 <naxa> copumpkin: in any case, thank you for your help!
23:15:54 <mmorrow> ski: i used the two diff callCCs to make a "transactional state monad" which came out pretty well, i use it all the time now (with a different name than that package though since "TxM" is ugly, gotta change that..)
23:16:01 <naxa> I shall lurk around here more from now on. :)
23:16:14 <mmorrow> oh, and also needed monadLib's "Label" idea too for that
23:16:36 <mmorrow> ski: http://hackage.haskell.org/packages/archive/monad-tx/0.0.1/doc/html/src/Control-Monad-Tx.html
23:18:11 <copumpkin> naxa: :)
23:24:47 <ski> hm, i think `callCC1 (=<< ma) = ma' fails
23:26:04 <ski> (mmorrow : btw, i admit that before i was thinking that the `(o,s)' in `ContT o (State s)' would make the continuations more like nqCPS rather than CPS .. but now i'm not sure)
23:26:22 <ksf> main: Prelude.(!!): index too large
23:26:27 <ksf> waaaagh
23:26:29 <ksf> I hate it.
23:26:37 * mmorrow googles nqCPS
23:26:44 <ski> not-quite-CPS
23:26:54 <copumpkin> my efforts to coax dependent types out of GADTs have (unsurprisingly) failed
23:26:55 <ski> i.e. things like composable continations
23:27:05 <ski> like CPS, but not all calls are tail-calls
23:27:14 <mmorrow> hmm, interesting
23:27:54 <ski> (there is a "Direct Style" transform that can translate code in nqCPS style to direct style, with a few calls to `shift' and `reset')
23:28:49 <dolio> copumpkin: What are you trying exactly? There's a pretty standard way of doing dependent-typing-like stuff with GADTs.
23:29:27 <dolio> copumpkin: Namely: 1) Make type-level analogues of your data "data Z ; data S n".
23:29:52 <copumpkin> yup, done that, I'm trying to write a meaningful Num instance
23:30:00 <dolio> copumpkin: 2) Make a GADT indexed by the type-level "data Nat n where Z :: Nat Z ; S :: Nat n -> Nat (S n)".
23:31:03 <dolio> 3 (maybe optional)) Wrap the GADT in an existential "data AnyNat = forall n. AnyNat (Nat n)".
23:31:10 <copumpkin> yeah, did that too
23:31:31 <copumpkin> I'm probably doing something silly, I'll try to figure it out
23:31:34 <Twey> Blargh
23:31:48 <BMeph> copumpkin: 3b) ????
23:32:03 <BMeph> copumpkin: ;)
23:32:07 <Twey> ‘The programming language that will be our tool for this is Haskell, a member of the Lisp family.’ — The Haskell Road to Logic, Math, and Programming, preface
23:32:08 <copumpkin> oh, I knew I was forgetting something
23:32:11 <copumpkin> the ???? and profit, silly me
23:32:20 <copumpkin> Twey: !
23:32:27 <copumpkin> maybe liskell?
23:32:49 * BMeph hopes the world will end when the crowd claims "C is a Lisp"... :p
23:32:55 <Twey> Ha
23:33:07 <dolio> Isn't it?
23:33:20 <mmorrow> What's C?
23:33:30 <mmorrow> :)
23:33:39 * mmorrow return to coding in C
23:33:43 <BMeph> mmorrow: It's a vitamin, found in chiles and citrus. ;p
23:33:53 <SubStack> I hear UNIX was written in c, which would account for a lot.
23:34:01 <mmorrow> BMeph: ooh, sounds delicicious
23:34:40 <BMeph> mmorrow: I like it, but my wife's allergic. Not to the chiles, though, just the vitamin. :)
23:35:15 <SubStack> does she have scurvy yet?
23:35:23 * mmorrow was just typing that
23:36:10 * SubStack discredits mmorrow's ideas by having them first
23:36:24 * mmorrow sulks, goes shopping
23:36:43 <ski>     callCC1 (=<< ma)
23:36:49 <ski>   = M (\k s -> unM (ma >>= \a -> M (\_ _ -> k a s)) k s)
23:36:51 <BMeph> Oh, no, she has much more to worry about than scurvy. For one thing, she's married to me! =8*O
23:36:51 <ski>   = M (\k s -> unM ma (\a _ -> k a s) s)
23:37:02 <ski> which is generally not the same as `ma'
23:37:36 * SubStack blinks a few times in rapid succession
23:37:58 <Twey> ‘As a functional programming language, Haskell is a member of the Lisp family.  Other family members are Scheme, ML, Occam, Clean.’
23:38:03 * Twey twitches.
23:38:38 <dolio> Occam, eh?
23:38:44 <Twey> The ignorance!  It burns!
23:38:46 * BMeph snickers at the concept of Occam being a Lisp
23:40:38 * BMeph thinks that preface sounds more like the preface to "The Haskell Road to Illogic and Insanity"
23:41:21 <ski> (mmorrow : any comment on that law failing ?)
23:42:56 <mmorrow> ski: hmm, /me thinks
23:43:11 <SubStack> Twey: the code on that site isn't very abstract either
23:43:17 <SubStack> lots of numbered variable names >_<
23:45:09 <SubStack> Twey: make sure to complain on its amazon page
23:45:26 <thoughtpolice> @seen dons
23:45:26 <lambdabot> dons is in #happs, #concatenative, #arch-haskell, #ghc, #yi, #xmonad, #darcs, #haskell-in-depth and #haskell. I last heard dons speak 3h 44m 59s ago.
23:45:41 <mmorrow> ski: ah, well sure. since callCC1 "rolls back" the state, the state will be unchanged
23:45:54 <ski> mmorrow : i don't recall laws that `callCC' would be supposed to satisfy .. but that one is one of the simplest reasonable laws
23:46:13 <mmorrow> ski: that doesn't sound reasonable to me actually :)
23:46:26 <ski> (of course, one can argue whether it is in fact reasonable in light of wanting things like this)
23:46:32 <ski> right
23:46:54 <mmorrow> callCC1 (=<< m) ==== do {s <- get; a <- m; set s; return a}
23:47:06 <ski> *nod*
23:47:20 <mmorrow> i didn't know callCC had any laws, does it?
23:47:39 <ski> well, surely we want that `callCC (const ma) = ma', no ?
23:47:51 <mmorrow> ah, yeah surely
23:50:09 <mmorrow> hmm, now that i think about it, WriterT Cont has two callCCs also, similar to StateT Cont
23:50:15 <ski> hm .. maybe also `callCC (\k0 -> callCC (\k1 -> f k0 k1)) = callCC (\k0 -> callCC (\k1 -> f k1 k0))' and similar laws
23:51:11 <ski> btw, this reminds me .. i've often wanted a `localState :: MonadState s m => (s -> s) -> (m a -> m a)'
23:52:14 <mmorrow> oh, n/m i don't think it does
23:52:40 <eck> i'm writing wrapper to a c library that exports some macros that are CPP macros (e.g. the c code is something like #define FLAG_FOO 8); how can I refer to these values in my haskell ffi wrapper?
23:52:41 <mmorrow> ski: totally! i literally use this "TxM" all the time
23:53:28 <mmorrow> ski: it handles errors (aborting/reporting) gracefully, lets you control what effects the state and how, and gives you a State monad, which subsumes Reader and Writer
23:53:52 <mmorrow> it's like a ReaderWriterStateErrorMaybe monad
23:54:02 <mmorrow> err, i meant
23:54:06 <mmorrow> it's like a ReaderWriterStateErrorMaybeCont monad
23:54:08 <mmorrow> ;)
23:54:25 <ski> well, `Writer' can function with infinite actions
23:54:37 <mmorrow> hmm
23:55:23 <mmorrow> true
23:55:47 <ski> > execWriter $ fix (tell "!" >>)
23:55:51 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
23:55:52 <ski> > (`execState` "") $ fix (modify ('!':) >>)
23:55:59 <lambdabot>   mueval: Prelude.read: no parse
23:56:00 <ski> > (`execState` "") $ fix (modify (++ "!") >>)
23:56:25 <lambdabot>   thread killed
23:56:40 <mmorrow> i wonder if this ability can be worked in somehow
23:56:44 * ski wonders what the error "Prelude.read: no parse" singifies, there ..
23:57:13 <mmorrow> i believe it's a rlimits "killed" that mueval tries to `read'
23:57:28 <mmorrow> (or whatever msg rlimits prints out)
23:57:48 <ski> ok
23:57:56 <ski> (it appears misleading ..)
23:58:03 <mmorrow> heh, very
23:58:23 <mmorrow> oh, mueval seems to handle "thread killed" ok
23:58:30 <mmorrow> it must be *no* output
23:58:37 <mmorrow> that mueval tries to `read'
23:58:42 <mmorrow> > read ""
23:58:46 <lambdabot>   * Exception: Prelude.read: no parse
23:58:49 <mmorrow> > read "" :: String
23:58:50 <lambdabot>   "* Exception: Prelude.read: no parse
23:59:57 <mmorrow> somone should spend the 8 seconds it'd take to fix that...
