00:15:03 <mmorrow> @type \ios -> do State f <- liftIO ios; StateT (return . f)
00:15:05 <lambdabot> forall t t1 (m :: * -> *). (MonadIO m) => IO (State t t1) -> StateT t m t1
00:15:49 <mmorrow> mykelyk: if the code for that interp isn't at-hand, you could do that to convert stuff
00:16:57 <mmorrow> (so unsafePerformIO isn't actually the only way after-all, but the fact that this is equivalent to unsafePerformIO'ing that stuff above shows that that use of unsafePerformIO was "safe")
00:17:18 <mmorrow> unsafePerformIO (return 42) == 42
00:17:47 <mykelyk> works like a charms thanks!!!
00:17:48 <mmorrow> liftM2 (==) (return (unsafePerformIO (return 42))) (return 42)
00:17:54 <mmorrow> mykelyk: cool :)
00:36:38 <dancor> how do you decide between (a, b) and State a b
00:39:48 <Cale> dancor: How do you mean?
00:40:06 <Cale> dancor: You mean between using the state monad, and parameter passing?
00:41:12 <dibblego> does anyone happen to know when GHC discontinued splitting into core and extra-libs?
00:41:51 <Cale> dibblego: hmm... well, there's the Haskell Platform thing now, yeah?
00:42:01 <dibblego> yeah
00:42:16 <dibblego> I'm just going to give a tutoral to about 20 people and I want to make sure they all have QC
00:43:14 <Cale> If they install it from Debian/Ubuntu, they'll have almost nothing, because the Debian guys split everything up on their own.
00:43:26 <dibblego> bugger
00:45:20 <Cale> Hmm, actually even the source for 6.10.3 comes in two packages.
00:45:42 <Cale> But the binaries provided seem to be the big package.
00:46:06 <Cale> Myself, I just install the binaries from the GHC website.
00:48:16 <twb> Actually just ghc6 in Debian is like 100MB of stuff
00:48:34 <Cale> hmm
00:48:57 <twb> Uncompressed Size: 130M
00:49:18 <twb> Make that 148 for 6.10.3
00:49:38 <twb> This is why I don't install GHC on my laptop; it only has 4GiB of storage.
00:50:06 <bnijk> how do i access system beep in haskell
00:50:18 <twb> bnijk: you could try echoing ^G to standard output
00:50:23 <Cale> hmm, it seems my current /usr/local/lib/ghc-6.10.3 is 347M
00:50:25 <bnijk> how do i do that :O
00:50:32 <bnijk> wait no
00:50:39 <bnijk> it needs to actually control the hz and duration
00:50:41 <Cale> and I only install packages as user
00:50:51 <bnijk> i already wrote a bash script to do this, to play a major scale and a chromatic scale on the system beep
00:51:11 <Cale> So that's all stuff which came with GHC for me.
00:51:26 <Cale> bnijk: hmm
00:51:32 <mmorrow> [m@monire ~]$ du -h /usr/local/ghc/ghc-6.10.1 | tail -1
00:51:32 <mmorrow> 981M	/usr/local/ghc/ghc-6.10.1
00:51:33 <mmorrow> :o
00:51:38 <dmwit> bnijk: Call out to your bash script. ;-)
00:51:56 <bnijk> that seems wasteful
00:52:02 <Cale> bnijk: What does the bash script do, I wonder?
00:52:12 <bnijk> well there's an accompanying c program
00:52:19 <bnijk> which does beep (hz) (duration)
00:52:38 <mmorrow> bnijk: i think it's a sysctl or something
00:52:41 <dmwit> bnijk: If I were you, I'd call the same functions in Haskell as I did in C.
00:52:55 <bnijk> let's see here
00:53:00 <mmorrow> there's a program that plays songs my messing with the sysbeep, maybe that'll help
00:53:00 <twb> mmorrow: -c (or -s?  I forget).
00:53:05 <Cale> I don't know of an existing Haskell API for that, but you can FFI import any C library calls you used.
00:53:11 <mmorrow> twb: i can't remember
00:53:19 <bnijk> int main(int argc, char *argv[]) {
00:53:19 <bnijk>             int fd = open("/dev/tty10", O_RDONLY);
00:53:19 <bnijk>                 if (fd == -1 || argc != 3) return -1;
00:53:19 <bnijk>                     return ioctl(fd, KDMKTONE, (atoi(argv[2])<<16)+(1193180/atoi(argv[1])));
00:53:20 <twb> I always use -sch, but it prints two lines
00:53:22 <bnijk> }
00:53:25 <bnijk> =-o
00:53:27 <bnijk> how do i do that in haskell
00:53:53 <dmwit> bnijk: Same way, call ioctl.
00:54:04 <bnijk> there's some strange monadic way of doing that i assume
00:54:06 <dmwit> ?where FFI
00:54:07 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:55:03 <xmonader> while installing hs-twitter i get this message http://pastebin.com/d222fb15a i tried to set json package to < 4 as Saizan said but still no good
00:55:37 <Cale> bnijk: Unless you mean the IO monad, no. (The fact that IO is a monad is irrelevant to this.)
00:56:44 <bnijk> haskell is hard
00:57:07 <twb> bnijk: if you try to write procedures in it, sure.
00:57:08 <dmwit> I still don't understand why you're not just calling out to that C program.
00:57:08 <Cale> ... I was just thinking that comprehending the meaning of that C program is pretty hard.
00:57:10 <xmonader> bnijk, not true it's simply different
00:57:25 <dmwit> It's the same thing you did with bash, why not do it with Haskell?
00:57:48 <dmwit> And yeah, I'm with Cale here.  That C doesn't look particularly easy to me.
00:58:17 <dmwit> (Did you write the C code, or grab it from somewhere else?)
00:58:21 <bnijk> (i grabbed it)
00:58:29 <twb> Cale: looks like it converts the first command-line argument into a very stange number, then sends an ioctl to /dev/tty10 with that number as the argument to the call "KDMKTONE".
00:58:38 <Cale> Why tty10?
00:58:38 <bnijk> hell if i know how to do things like that
00:58:48 <twb> Presumably because it's not allocated by default
00:59:12 <dmwit> bnijk: So, what you're saying is, it's hard to do something in Haskell that you don't understand how to do in any other language, either.
00:59:28 <dmwit> Forgive me if I'm not convinced of Haskell's shortcomings from that. =)
00:59:30 <bnijk> lol
00:59:35 <bnijk> i understand the c
00:59:41 <bnijk> i just really don't know how to do it in haskell
00:59:47 <twb> bnijk: then what is the purpose of the right shifting?
00:59:53 <twb> Sorry, left shifting
00:59:54 <bnijk> what?
01:00:08 <bnijk> > map (\x->440*2**(x/12)) [0..12]
01:00:08 <twb> bnijk: what is the purpose of the left shift used in that C code?
01:00:09 <lambdabot>   [440.0,466.1637615180899,493.8833012561241,523.2511306011972,554.3652619537...
01:00:16 <Cale> atoi(argv[2])<<16 -- why shift left by 16 bits?
01:00:43 <twb> bnijk: if you understand the C code, you should be able to explain it to us.
01:00:53 <Cale> (1193180/atoi(argv[1])) -- and wtf is this?
01:00:54 <bnijk> ah
01:01:04 <bnijk> well the second part isj ust translating the hz
01:01:11 <twb> Cale: I assume 11938180 is a frequency in Hz
01:01:14 <mmorrow> twb: http://www.frank-buss.de/beep/index.html
01:01:15 <bnijk> to what the beeping thing recognizes
01:01:20 <twb> Bleh, too many beers
01:01:22 <bnijk> whatever you call it
01:01:29 <Cale> mm...
01:01:34 <bnijk> and the first part...
01:01:41 <bnijk> well
01:01:47 <twb> mmorrow: yes, ^G is character 07 in ASCII
01:01:50 <bnijk> that i don't get
01:01:53 <yowgi> ‚ÄúKDMKTONE Generate tone of specified length. The lower 16 bits of argp specify the period in clock cycles, and the upper 16 bits give the duration in msec.‚Äù
01:02:05 <bnijk> ah
01:02:07 <twb> O dpm
01:02:15 <twb> I don't think tty10 is special
01:02:26 <twb> Other than being in /etc/securetty.
01:02:32 <yowgi> 1193180 = CLOCK_TICK_RATE
01:02:36 <dmwit> Ah, so the code is actually wrong.
01:02:48 <mmorrow> nice, http://tldp.org/LDP/lpg/node83.html
01:02:56 <twb> Runtime.getRuntime().exec("beep.exe 440 1000");
01:02:58 <dmwit> Although I suppose for something like this, sanitizing input is pretty low priority.
01:02:58 <twb> Ahahahaha
01:03:07 <bnijk> yes dmwit ;)
01:03:20 * mmorrow wraps messing with the pc speaker with the ffi
01:03:26 <twb> yowgi: surely the tick rate depends on the architecture and the kernel version?
01:03:34 <dmwit> Anyway, maybe we should be asking why you're not just using a real sound library.
01:03:45 <yowgi> twb, probably, yes.
01:03:46 <bnijk> dmwit: i wanted to do it with the system beep, of course
01:03:48 <twb> dmwit: because this is "easier" man!
01:03:53 <bnijk> anybody can write a PCM
01:04:12 * dmwit blinks
01:04:20 <dmwit> And not anybody can copy and paste code from the web?
01:04:34 <twb> Description: beep does what you'd expect: it beeps. But unlike printf "\a" beep allows you to control pitch, duration, and repetitions. Its job is to live inside shell/perl scripts and allow more granularity than one has otherwise. It is controlled completely through command line options. It's not supposed to be complex, and it isn't - but it makes system monitoring (or whatever else it gets hacked into) much more
01:04:35 <twb> Homepage: http://johnath.com/beep/
01:04:36 <bnijk> that code only does the beeping itself
01:04:43 <bnijk> how do i explain
01:05:15 <twb> Package: cw
01:05:15 <twb> Description: This package contains a simple command line client called cw, which sounds characters as Morse code on the console speaker. The included cwgen binary can generate groups of random characters for Morse code practice.[...]
01:05:27 <bnijk> i don'tw ant to manipulate timbre
01:05:38 <bnijk> if i wanted to do that i'd open up a whole wave to do it
01:05:43 <bnijk> just wanted the tones
01:06:58 <bnijk> speaking of which - how do i work in hex in haskell
01:07:07 <twb> I actually looked into using cw for a headless server SOE, so it could report panics to untrained end users
01:07:15 <dmwit> > 0x20 -- the usual way
01:07:17 <lambdabot>   32
01:07:19 <bnijk> k
01:07:38 <bnijk> so let's see here
01:07:39 <twb> dmwit: what, no DEFAULT-READ-BASE ? ;-)
01:08:16 <bnijk> a wav header would be formatted like...
01:08:16 <twb> (SETQ DEFAULT-WRITE-BASE 2 DEFAULT-READ-BASE 36) (PRINC aaz3) ;-)
01:08:35 <twb> ...not bothering to check CLHS, because I'm lazy.
01:09:28 <p_l> twb: why setq and not setf?
01:09:33 <dmwit> :t readIntAtBase
01:09:34 <lambdabot> Not in scope: `readIntAtBase'
01:09:35 <twb> p_l: haha
01:09:39 <dmwit> :t readInt
01:09:40 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
01:10:17 <bnijk> > 0x524946462408000057415645666d74201000000001000200 ++ sampleRate ++ byteRate ++ 0x0400 ++ bps ++ firstSubchunk ++ 0x000800000000 ++ wav
01:10:18 <lambdabot>   Not in scope: `sampleRate'Not in scope: `byteRate'Not in scope: `bps'Not in...
01:10:23 <bnijk> you're not in scope~!
01:10:27 * bnijk slaps lambdabot 
01:10:28 <dmwit> :t index
01:10:29 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
01:10:34 <dmwit> :t findIndex
01:10:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
01:10:49 <bnijk> although the > will turn it to int i assume
01:11:21 <bnijk> bah
01:11:45 <dmwit> > readInt 36 (const True) (\c -> fromJust $ lookup c (zip (['0'..'9'] ++ ['a'..'z']) [0..])) "aaz3"
01:11:47 <lambdabot>   [(480783,"")]
01:12:13 <bnijk> back to LYAH
01:12:40 <dmwit> bnijk: uh... (++) operates on String
01:12:47 <bnijk> meh
01:12:49 <bnijk> make those :'s
01:13:01 <bnijk> and then mush it all together
01:13:19 <bnijk> i don't remember
01:13:31 <dmwit> You have a bit to learn, yet, it seems. =)
01:13:40 <bnijk> i would imagine
01:13:53 <bnijk> so tell me then, how do i just mash together data
01:14:10 <dmwit> Also, what the hell am I thinking?  (++) works on [a] for any a, not just Char.
01:14:20 <dmwit> bnijk: You don't just mash together data.
01:14:25 <dmwit> That's the beauty of Haskell.
01:14:33 <Cale> Well, I wrote a program which I imagine does the same thing as your C code, but I have no idea how to test it.
01:14:36 <mmorrow> heh http://www.scylla-charybdis.com/tool.php/kdmktone
01:14:46 <mmorrow> for a in 1 2 3; do ./kdmktone 1000 1500 2000 0; done
01:15:12 <bnijk> what do you mean
01:15:17 <bnijk> @dmwit
01:15:18 <lambdabot> Unknown command, try @list
01:15:53 <Cale> actually it does seem to work.
01:16:14 * Cale goes to hpaste
01:16:23 <bnijk> if i'm trying to make a pcm wav, dmwit, they have to be aligned in that order
01:16:34 <bnijk> how else do you propose to do that
01:16:41 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5112#a5112
01:16:50 <Cale> bnijk: ^^
01:17:08 <bnijk> nifty
01:17:15 <dmwit> bnijk: We have Data.Word for that, but your first guy there will almost certainly overflow a Word.
01:17:21 <bnijk> so cale
01:17:23 <Cale> It doesn't work without root permissions on my machine.
01:17:34 <bnijk> plug in map (\x->440*2**(x/12)) [0..12] into that
01:17:40 <bnijk> and you have a chromatic scale :)
01:18:01 <Cale> Well, modulo the numeric conversion.
01:18:09 <bnijk> ah, yes
01:18:15 <bnijk> ...modulo?
01:18:21 <bnijk> 0.0
01:18:33 <Cale> I just mean, ignoring that
01:18:54 <bnijk> which part of your program is the frequency
01:19:05 <Cale> I just stole the two parameters from your program
01:19:23 * bnijk looks again
01:19:24 <bnijk> ok
01:19:29 <Cale> I think a is the frequency
01:19:35 <Cale> That's less convenient :)
01:19:54 * Cale swaps them
01:19:56 <danra> any recommendations for a package to translate a tree of strings into an image of tree of strings?
01:20:16 <dmwit> How about Data.Tree.showTree?
01:20:19 <dmwit> Or whatever that thing is called.
01:20:19 * bnijk frowns
01:20:20 <Cale> ah, it actually does beep, so it should probably just be called beep
01:20:37 <dmwit> drawTree
01:20:55 <danra> thanks dmwit, will look at that
01:21:03 <bnijk> dmwit: i wrote a program once in quasi-functional php+postgres that just compiled little bits of text people wrote
01:21:06 <bnijk> into a huge tree
01:21:12 <bnijk> the things that came out of the project
01:21:17 <bnijk> mmnph
01:22:20 <bnijk> i want a big poster of that...
01:22:24 * bnijk fiddles some more
01:24:02 <bnijk> cale you still there?
01:24:19 <Cale> yeah
01:24:36 <Cale> hmm, it doesn't seem to block until the beep is finished
01:24:56 <bnijk> can you explain this 'foreign...' line to me
01:25:44 <bnijk> or should i just look up these functions
01:25:47 <Cale> sure
01:25:54 <Cale> It's mostly special syntax.
01:26:29 <dmwit> foreign isn't a function, actually.
01:26:46 <bnijk> what is it then, a keyword
01:26:52 <dmwit> A foreign import provides a bridge from Haskell to other languages.
01:26:56 <Cale> yes
01:27:06 <dmwit> Yep, "foreign", "import", and "ccall" are all keywords there.
01:27:14 <bnijk> and these types
01:27:16 <Cale> ccall is the calling convention
01:27:20 <bnijk> Fd and CInt
01:27:20 <twb> dmwit: language*s*?  Other than C, what are they?
01:27:40 <dmwit> twb: I believe there's a spec for Java, at least, though I doubt anyone implements it.
01:27:43 <dmwit> ?where ffi
01:27:43 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
01:27:46 <twb> Or are we talking about Haskell rather than GHC now?
01:28:00 <dmwit> yep
01:28:08 <dmwit> err: yep, Haskell, not GHC
01:28:11 <twb> Righto
01:28:14 <Cale> and then "sys/ioctl.h ioctl" describes that the function we want is described in the header <sys/ioctl.h> and is called ioctl
01:28:22 <twb> I tend to conflate the two in implied contexts.
01:28:30 <Cale> Then it's followed by the name of the Haskell function to import it as
01:28:50 <Cale> and the Haskell type at which we want to import it... there has to be some agreement between this type and the C type
01:28:58 <Cale> (but there's a bit of flexibility)
01:29:00 <dmwit> twb: I guess "stdcall" is the only other required calling convention.
01:29:11 <quicksilver> twb: other than C, any other language which supports the C ABI :)
01:29:15 <dmwit> twb: (For win32 api calls.)
01:29:31 <bnijk> hmph
01:29:35 <bnijk> yours isn't in /usr/share?
01:29:44 <Cale> what?
01:29:46 <bnijk> er, /usr/include/sys/
01:29:50 <bnijk> ioctl.h
01:29:52 <Cale> It is.
01:30:30 <bnijk> ok so that reads in #define _SYS_IOCTL_H
01:30:41 <Cale> hmm?
01:30:45 <bnijk> in ioctl.h
01:30:55 <bnijk> or #ifndef
01:31:01 <Cale> Well, it reads the declaration of the ioctl function from there
01:31:20 <bnijk> how did you know what type ioctl had O.O
01:31:31 <Cale> I gave it by hand.
01:31:43 <Cale> (I looked it up in the manpage and looked at what you wrote)
01:31:47 <dmwit> From man ioctl
01:32:11 <Cale> ioctl normally takes an arbitrary number of parameters, so I imported it at one specific type
01:32:43 * bnijk nods
01:33:07 <Cale> The first parameter is a file descriptor, and the unix package for Haskell already has stuff for working with those
01:33:21 <Cale> So I imported System.Posix.Types and System.Posix.IO
01:33:29 <Cale> and used the Fd type defined there
01:33:41 <Cale> CInt as you'd imagine is just a C int
01:33:59 <bnijk> so those types are for the arguments passed to kdmktone
01:34:10 <Cale> to ioctl rather
01:34:14 <bnijk> er, yeah
01:34:23 <Cale> kdmktone is a particular CInt constant
01:34:24 <danra> any recommendations for a package to translate a tree of strings into an *pretty* image of tree of strings? (*not* Data.Tree.drawTree :-)
01:34:47 <bnijk> danra: GIMP
01:34:48 <dmwit> danra: As in, a non-text image?
01:34:53 <danra> yup
01:34:53 <Cale> by the way: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5112#a5113
01:34:58 <dmwit> danra: If so, you might be interested in the GraphViz library.
01:35:19 <danra> dmwit: Thanks again, will look at that
01:35:19 <bnijk> oo
01:35:27 <dmwit> Have you ever used GraphViz?
01:35:31 <danra> no
01:35:33 <Cale> oh, you also need to import Control.Concurent
01:35:38 <Cale> Concurrent*
01:35:51 <Cale> (for threadDelay)
01:35:59 <bnijk> wait what are the imports for the second one
01:36:07 * mmorrow just destroyed his eardrums with high pitched pure sinewaves of death
01:36:14 <Cale> I'll add a revision with the whole file :)
01:36:19 <dmwit> danra: Okay, well, there's lots of information on the web about it, anyway.
01:36:33 <dmwit> danra: The GraphViz library just produces input for the various graphviz executables.
01:36:55 <bnijk> and just out of curiosity (looking at haskell wiki) is there a haskell word processor?
01:37:04 <bnijk> or just IDEs and text editors
01:37:14 <dmwit> There's no word processor that I know of.
01:37:23 <dmwit> Are you going to make one?
01:37:35 <bnijk> i'm more eager about making my game, dmwit
01:37:42 <bnijk> but haskell + opengl is a goddamn nightmare
01:37:52 <dmwit> huh
01:38:08 <bnijk> imagine marcel duchamp + escape velocity
01:38:08 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5112#a5114
01:38:21 <bnijk> ah, ok
01:38:32 <Cale> bnijk: I even added a function to play the scale for you :)
01:38:42 * bnijk compiles
01:38:52 <Cale> I needed to run it as root.
01:39:02 <bnijk> yeah
01:39:22 <Cale> Oh, it doesn't have a main.
01:39:39 <Cale> main = playScale 300 440
01:39:41 <Cale> will do
01:40:04 <bnijk> how do you compile
01:40:06 <bnijk> ghc -S?
01:40:15 <bnijk> mmnn ok
01:40:26 <Cale> ghc --make beep
01:40:27 <bnijk> nope
01:40:53 <bnijk> nifty
01:41:02 <bnijk> now to make it play "three blind mice"...
01:42:01 <bnijk> wow that did not work quite right
01:42:06 <bnijk> forgot to use whole steps
01:42:22 <bnijk> screw this, it's gonna play 'smoke on the water'
01:42:26 <mmorrow> here's my Beep module http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5115#a5115
01:43:22 <mmorrow> gotta figure out now how to encode (Hz,Seconds) -> (?,?) that (ioctl_l 1 kDMKTONE) uses... then can make music
01:44:14 <bnijk> cale:  [floor (root * 2 ** (k/12)) | k <- [0,3,5,0,3,6,5,0,3,5,3,0]]
01:44:15 <Cale> It doesn't need any permissions if you use /dev/tty, but then it only works for me in a real linux terminal, and not in gnome-terminal. :)
01:44:26 <mmorrow> (warning: "toggle n", where n > ~70 or 80 is painful if the volume's up enough)
01:44:38 <bnijk> :D
01:45:02 <mmorrow> ah yeah, i had to switch to a no-X screen
01:45:04 <bnijk> i've been thinking a lot over the past few months of what you can do with haskell and pcm
01:45:16 <bnijk> i've been making music with granular synth for the past few years - but this has gotta be even better
01:45:18 <mmorrow> bnijk: probably cool stuff
01:45:40 <mmorrow> ooh, cool. yeah i bet haskell would be perfect
01:47:24 <mmorrow> Cale: ooh, awesome just saw your paste
01:47:40 <bnijk> oo even better
01:47:41 <bnijk> floor (root * 2 ** (k/12)) | k <- [0,2,4,0,0,2,4,0,4,5,7,4,5,7,7,9,7,5,4,0,7,9,7,5,4,0,0,-5,0,0,-5,0]]
01:47:54 <Cale> mmorrow: I just translated his C code
01:48:24 <mmorrow> Cale: what C code?
01:48:26 <mmorrow> oh, hah
01:48:35 <mmorrow> i should've looked more closely
01:49:10 <dmwit> Heh, I was wondering why I couldn't beep my speaker here, and then I remembered: I disabled those kernel modules. ^_^
01:49:17 <mmorrow> err, i think the timeval is supposed to be a CLong
01:49:25 <bnijk> holy crap look at all the midi programs in the AUR
01:49:48 <Cale> mmorrow: Quite possibly. I didn't think too hard about it.
01:50:06 <mmorrow> Cale: wouldn't that mess with the bit shifting though?
01:50:10 * mmorrow is confused
01:50:33 <Cale> Well, the shift is only 16 bits.
01:51:02 <Cale> So the resulting constant is only 32 bits anyway.
01:52:24 <Cale> mmorrow: How do I get your beep to work?
01:52:30 <mmorrow> Cale: ahhh. i just realized why my version was crushing my ears..
01:52:42 <mmorrow> Cale: i didn't get that far :)
01:52:54 <mmorrow> (although "toggle 50" e.g. works)
01:53:06 <mmorrow> (don't go above 70 !!@)
01:53:43 <bnijk> http://gimp.org/unix/howtos/gimp-midi.html :O :O :O
01:53:53 <bnijk> and people tell me photoshop is better
01:54:04 <mmorrow> Cale: oh, also it's outputing to stdout, so you need to be on a real tty
01:54:10 <Cale> mmorrow: Ah...
01:54:49 <dmwit> bnijk: Sounds... useful.
01:55:48 <bnijk> it's clearly not
01:55:51 <bnijk> what's important is that it's possible
01:55:55 <Cale> bnijk: More than midi, it would be fun to have something to control the brush parameters in realtime using, say, the average amplitude and pitch of whatever's coming in on the microphone :)
01:56:10 <bnijk> automatic livepainting cale :O
01:56:33 <bnijk> although i suppose there's already visualization programs
01:56:43 * bnijk leaves to go make eggs
01:56:44 <dmwit> There's tablets...
01:56:55 <bnijk> that's not the point dmwit ;)
01:57:04 * dmwit is always missing the point
01:57:25 <Cale> You could combine it with a tablet too :)
01:57:59 <Cale> Hehe, have the pitch mapped to hue, with an octave producing the same colour. :)
01:58:07 <Cale> (but maybe brighter? :)
01:58:14 <bnijk> that reminds me
01:58:19 <bnijk> i have to install that program...
01:58:19 <bnijk> max
01:58:20 <bnijk> !
01:59:57 <bnijk> or something like that - video + audio programming
02:01:19 <bnijk> as technology advances - imagine even thinking of this stuff a century ago
02:02:09 <xmonader> anyone got hs-twitter installed ?
02:02:19 <Axman6> ChilliX: you around?
02:02:46 <Cale> xmonader: Not me...
02:02:57 <xmonader> Cale :(
02:03:18 <xmonader> i reinstalled json, installed < 4 and still :@
02:07:29 * Axman6 thinks ChilliX should come down to canberra and give his data parallel haskell talk at ANU
02:09:28 <Cale> Áú†„ÅÑ„Çì„Åß„ÄÅ„Åä‰ºë„Åø„ÄÅ„Åø„Çì„Å™ÔºÅ
02:11:31 <xmonader> Cale, :S
02:23:31 <jn> does anyone have a more concise way of doing the following? http://paste.lisp.org/display/80642
02:25:58 <skorpan> jn: i don't know, but shouldn't maxBound for Hours be "Hours 23"?
02:26:07 <bnijk> yeah..and 0..59
02:26:29 <bnijk> while you're at it
02:26:38 * bnijk coughs
02:26:41 <jn> no.
02:26:49 <bnijk> lol
02:27:24 <jn> it's an inclusive/exclusive range
02:27:37 <quicksilver> jn: well, instead of "ranged 0 24 Hours" you could do "ranged minBound maxBound Hours"
02:28:03 <jn> aye, that removes the duplication, but it's still horribly long
02:28:17 <quicksilver> then you can give 'ranged minBound maxBound' a name
02:28:36 <jn> that's true
02:29:09 <quicksilver> you'd need to change stuff slightly - maxBound would be (Hours 24) not just 24.
02:29:42 <LeCamarade> What does it mean when a GHC program says "thread blocked indefinitely"?
02:29:47 <jn> yeah. just would've thought there'd be some more concise way of making a bounded integral type.
02:30:16 <skorpan> @hoogle a -> [a] -> [a]
02:30:17 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
02:30:17 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
02:30:17 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
02:30:21 <LeCamarade> I only use MVar, SampleVars, and Chan from Control.Concurrent
02:31:35 <quicksilver> LeCamarade: it means you have a deadlock.
02:31:51 <quicksilver> LeCamarade: no thread can proceed because they are all waiting on another thread
02:33:26 <LeCamarade> Hmm.
02:33:58 <LeCamarade> I thought I had architected it to prevent that. But threads make quantum mechanics look all too deterministic.
02:43:16 <ChilliX> Axman6: Hey
02:43:16 <lambdabot> ChilliX: You have 1 new message. '/msg lambdabot @messages' to read it.
02:51:08 <jn> http://paste.lisp.org/display/80643 think that's the best i can do
02:53:19 <ivanm> What's the difference between isNumber and isDigit
02:53:20 <ivanm> ?
02:53:29 <Beelsebob> @type isNumber
02:53:31 <lambdabot> Char -> Bool
02:53:37 <ivanm> they have the same type ;-)
02:53:41 <Beelsebob> > isNumber '.'
02:53:42 <lambdabot>   False
02:54:00 <Beelsebob> > isNumber '-'
02:54:02 <lambdabot>   False
02:54:03 <Beelsebob> no idea
02:54:07 <ivanm> duh, I should probably have a look at the docs rather than trying to get lambdabot to work it out for me...
02:54:17 <Beelsebob> what is the diff?
02:54:48 <ivanm> isNumber: "Selects Unicode numeric characters, including digits from various scripts, Roman numerals, etc. "
02:54:52 <ivanm> isDigit is for 0..9
02:55:05 <Beelsebob> oh, neat
02:55:20 <RayNbow> > isNumber 'V'
02:55:22 <lambdabot>   False
02:55:41 <ivanm> RayNbow: must be special unicode chars
02:55:48 <RayNbow> yeah, I figured :p
02:56:04 <Beelsebob> > isNumber '‚ûÅ'
02:56:05 <trofi^w> > isNumber "a number"
02:56:07 <lambdabot>   True
02:56:07 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
02:56:21 <Beelsebob> > isNumber '¬æ'
02:56:23 <lambdabot>   True
02:59:16 <ivanm> Beelsebob: heh
02:59:39 <dobblego> what is a good property for a beginner to automated testing to demonstrate ==> ?
02:59:44 <ivanm> Beelsebob: what char is the first one you tried (before trofi^w's attempt)?
03:00:11 <trofi^w> twho in a circle
03:00:19 <ivanm> ahhh
03:01:07 <lilac> > isNumber '¬≤'
03:01:08 <lambdabot>   True
03:03:02 <lilac> > isNumber '‚Å∞'
03:03:04 <lambdabot>   True
03:03:28 <lilac> > all isNumber "¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ‚Å∞"
03:03:30 <lambdabot>   True
03:05:18 <lilac> @hoogle isNumber
03:05:18 <lambdabot> Data.Char isNumber :: Char -> Bool
03:05:20 <lilac> @hoogle whichNumberIsItThough
03:05:21 <lambdabot> No results found
03:08:30 <Axman6> > filter isNumber [chr 0 ..]
03:08:31 <lambdabot>   "0123456789\178\179\185\188\189\190\1632\1633\1634\1635\1636\1637\1638\1639...
03:08:52 <Axman6> > text . drop 10 .  filter isNumber $ [chr 0 ..]
03:08:53 <lambdabot>   ¬≤¬≥¬π¬º¬Ω¬æŸ†Ÿ°Ÿ¢Ÿ£Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©€∞€±€≤€≥€¥€µ€∂€∑€∏€π‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•...
03:09:30 <RayNbow> that doesn't look quite right :p
03:09:37 <Axman6> no...
03:09:42 <Axman6> > text . drop 30 .  filter isNumber $ [chr 0 ..]
03:09:43 <lambdabot>   €¥€µ€∂€∑€∏€π‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡ß¶‡ßß‡ß®‡ß©‡ß™‡ß´‡ß¨‡ß≠‡ßÆ‡ßØ‡ß¥...
03:10:05 <Axman6> > text . drop 20 .  filter isNumber $ [chr 0 ..]
03:10:07 <lambdabot>   Ÿ§Ÿ•Ÿ¶ŸßŸ®Ÿ©€∞€±€≤€≥€¥€µ€∂€∑€∏€π‡•¶‡•ß‡•®‡•©‡•™‡•´‡•¨‡•≠‡•Æ‡•Ø‡ß¶‡ßß‡ß®‡ß©‡...
03:12:04 <int-e> > isNumber '¬æ'
03:12:05 <lambdabot>   True
03:15:19 <ivanm> int-e: Beelsebob beat you to it ;-)
03:15:50 <ivanm> Axman6: what does text do? display unicode chars?
03:15:54 <ivanm> @type text
03:15:55 <lambdabot> String -> Doc
03:16:00 <ivanm> ahhh
03:16:49 <skorpan> @pl (\x y -> x == 3)
03:16:49 <lambdabot> const . (3 ==)
03:17:13 <skorpan> isn't there any combinator for doing the same thing?
03:18:15 <Botje> :t curry (first (==3))
03:18:16 <lambdabot> forall a b. (Num a) => a -> b -> (Bool, b)
03:18:23 <skorpan> :t first
03:18:25 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
03:18:29 <Botje> hmm, nope
03:18:43 <Botje> fst . curry . first (==3) isn't really very readable :P
03:19:20 <lilac> @type curry ((==3) . fst)
03:19:21 <lambdabot> forall a b. (Num a) => a -> b -> Bool
03:29:13 <pao> hi all, what is the most efficient way to parse an iso format timestamp stored in a ByteString?
03:30:35 <opqdonut> write a state machine
03:32:44 <ivanm> if I want to span a String such that I take the first part is either numbers of '.' and at most one lower case letter on the end, what would be the best way of doing it (without regexes!)?
03:33:23 <dancor> is there an easy way to make (data MyData a = MyData {info :: [String], res :: Maybe a}) have a Monad instance that acts like (type MyData a = StateT [String] Maybe a)
03:33:25 <ivanm> span (\c -> isDIgit c || c == '.') str, and then check the first char of the second bit of the String to see if it's a lower case letter?
03:34:07 <mauke> @unmtl StateT [String] Maybe a
03:34:07 <lambdabot> [String] -> Maybe (a, [String])
03:34:39 <mauke> dancor: eh?
03:34:41 <dancor> hm
03:34:52 <pao> opqdonut: could you elaborate? :-)
03:34:54 <dancor> i guess i don't understand StateT
03:35:31 <dobblego> why do I get a warning and not an error for missing coarbitrary on Test.QuickCheck.Arbitrary instance declaration?
03:35:31 <dancor> my thing should be like ([String], Maybe a) and bind should just concat the Strings and fail on any Nothing
03:35:35 <dancor> i guess i have to write it out
03:36:10 <dancor> @mtl [String] -> Maybe (a, [String])
03:36:11 <lambdabot> Maybe you meant: ft map msg pl unmtl url
03:37:07 <Lemmih> ?unmtl MaybeT (Writer [String]) a
03:37:07 <lambdabot> (Maybe a, [String])
03:39:03 <lilac> ivanm: i got a parse error on your question :)
03:39:23 <mmorrow_> Cale: new and improved Beep: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5118#a5118
03:39:42 <mmorrow_> it's too bad you can only play one freq at a time..
03:40:11 <dancor> beepcluster
03:40:27 <mmorrow_> zomg
03:40:29 <ivanm> lilac: I need to parse something that is of the form [0-9]+(\.[0-9]+)* with an optional trailing lowercase letter
03:40:49 <ivanm> and I want to do so without regexes :( (since I want to have no deps apart from GHC and cabal)
03:43:05 <Botje> i thought Text.Regex was in base nowadays?
03:44:06 <dancor> {- verify possibleFinalLetter and put into your data structure -} where (mainThing, possibleFinalLetter) = span (\ x -> isDigit x || x == '.')    ?
03:44:26 <dancor> ivanm seems to be way ahead of me
03:44:56 <dancor> you don't want .. tho
03:45:14 <dancor> anyway it's easy to split on . and then work with the resulting list
03:45:24 <ivanm> recursively?
03:45:30 <ivanm> Botje: it isn't, AFAICT
03:45:44 <yowgi> ivanm, how about with pattern matching and Maybe?
03:45:50 <ivanm> Botje: in my 6.10.3 haddock page, there's no regex listed
03:45:56 <Botje> > fmap (head) $ listToMaybe (reads "12345.6789p") :: Maybe (Double, Char)
03:45:57 <lambdabot>   Couldn't match expected type `[a]'
03:46:03 <ivanm> yowgi: pattern matching? on each individual possible lowercase letter?
03:46:12 <yowgi> sorry i meant guards
03:47:00 <yowgi> parse (c:cs) | isNumber c = parseSecondPart cs c
03:47:11 <yowgi> parseSecondPart using the span
03:47:38 <yowgi> all other non-matching cases = Nothing
03:47:46 <Botje> > fmap (second (head)) $ listToMaybe $ reads "12345.6789p" :: Maybe (Double, Char)
03:47:48 <lambdabot>   Just (12345.6789,'p')
03:47:50 <ivanm> ummmmm.... that sounds kinda dodgy
03:47:54 <Botje> ivanm: ^^
03:48:15 <Botje> you probaby want to do something about the head and replace it with safehead, but that's one way.
03:48:22 <dancor> what about 1.1.1p
03:49:00 <BONUS> ?umtl WriterT w (ContT r []) a
03:49:00 <lambdabot> (a -> w -> [r]) -> [r]
03:49:07 <BONUS> uhh
03:49:11 <BONUS> is this correct?
03:50:08 <ivanm> > fmap (second (head)) $ listToMaybe $ reads "12345.6789pa" :: Maybe (Double, Char)
03:50:09 <lambdabot>   Just (12345.6789,'p')
03:50:18 <Botje> don't ask me, Cont* is scary voodoo magic
03:50:20 <ivanm> > fmap (second (head)) $ listToMaybe $ reads "12345.6789-pa" :: Maybe (Double, Char)
03:50:22 <lambdabot>   Just (12345.6789,'-')
03:50:32 <BONUS> isnt WriterT w (ContT r []) a supposed to be ((a,w) -> [r]) -> [r]
03:51:04 <ivanm> I'm already doing a case on span (can't use reads, as it might have more than one .num part)
03:51:14 <mauke> @unmtl ContT r (WriterT w []) a
03:51:14 <lambdabot> (a -> [(r, w)]) -> [(r, w)]
03:51:49 <BONUS> that one looks ok
03:51:52 <BONUS> but
03:51:59 <BONUS> @umtl WriterT w (ContT r []) a
03:51:59 <lambdabot> (a -> w -> [r]) -> [r]
03:52:07 <BONUS> this looks kinda wrong
03:52:56 <mauke> I have to agree
03:55:43 <BONUS> @umtl WriterT w (ListT Maybe) a
03:55:43 <lambdabot> Maybe [(a, w)]
03:56:17 <BONUS> this looks ok yeah but it screws it up for WriterT w (ContT r []) a
03:57:14 <BONUS> who could be notified of this bug, i wonder
03:57:31 * ivanm wonders if learning/using Text.ParserCombinators would be worth it...
03:57:54 <Botje> parsec is dead easy and dead sexy
04:00:29 <mxc> botje - it is sexy.
04:01:13 <lilac> ivanm: you want parse :: String -> ([Int], Maybe Char) ?
04:01:37 <ivanm> no, I want parse :: String -> Maybe (String, String)
04:01:54 <lilac> what are the two strings?
04:01:55 <ivanm> though it _could_ be using ([Int], Maybe Char) as the first STring...
04:02:01 <lilac> oh, ok :)
04:02:40 <ivanm> the second String is the rest of the initial String
04:03:06 <ivanm> so Reads String, but replacing [] with Maybe (well, I'm still using [] at the moment, but will probably switch)
04:09:24 <Baughn> @tell conal http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5121#a5121 <-- Here, have another bug. I'm going away for the weekend.
04:09:25 <lambdabot> Consider it noted.
04:09:59 <raji> how do we write the set of regular expression that doesn't contain 110 as substring , i know the answer as (0|10)*1* , how to derive the answer ?
04:10:47 <ivanm> Baughn: how considerate of you ;-)
04:11:33 <kau> hello! why join (++) $ "to" doesn't works?
04:11:55 <Baughn> > join (++) "to"
04:11:56 <mauke> > join (++) $ "to"
04:11:58 <lambdabot>   "toto"
04:11:58 <lambdabot>   "toto"
04:12:02 <kau> says me No instance for (Monad ((->) [Char]))
04:12:10 <mauke> kau: import Control.Monad.Instances
04:12:16 <kau> ok thanks!
04:13:52 <Baughn> ivanm: My motto is "To serve Man".
04:13:53 <kau> is there a function to upper case?
04:13:59 <nominolo> is there any way to wait on a file to be filled?  I only get eof exceptions
04:14:02 <dobblego> > toUpper 'a'
04:14:04 <lambdabot>   'A'
04:14:30 <mauke> nominolo: manually
04:14:32 <nominolo> without polling, of course
04:14:41 <nominolo> mauke: ?
04:14:44 <mauke> depends on the platform
04:14:48 <mauke> linux has inotify
04:14:49 <Baughn> nominolo: popen "tail -f" ..
04:14:53 <mauke> tail -f pools
04:14:55 <mauke> er, polls
04:15:06 <Baughn> Hm? That's..
04:15:22 <nominolo> all i want is to open a named pipe for clients to talk to my deamon
04:15:23 <mmorrow_> inotify is pretty nice
04:15:42 <Baughn> So it does. Huh, I figured it'd use whatever the OS had available.
04:15:45 <nominolo> (I hate Vim for not having process state)
04:15:46 <mauke> oh, so this is a pipe, not a normal file
04:15:52 <nominolo> mauke: right
04:16:16 <nominolo> mauke: though, that shouldn't make a difference for the client, does it?
04:16:30 <nominolo> (And I don't even use Vim!)
04:16:38 <mauke> opening a fifo blocks until the other end is opened
04:16:41 <nominolo> @seen MarcWeber
04:16:41 <lambdabot> I saw MarcWeber leaving #haskell 4m 4d 2h 3s ago, and .
04:16:59 <mauke> but what do you mean by "filled"?
04:17:00 <Baughn> *Closing* a FIFO produces sigpipe on the other end
04:17:15 <mauke> incomplete
04:17:31 <nominolo> Ok, let's start with the problem I'm trying to solve:
04:17:37 <mauke> closing the read end of a fifo produces SIGPIPE if someone tries to write to it
04:17:45 <lilac> > map reads ["123","123.","123.4"] :: [[(Int,String)]]
04:17:47 <lambdabot>   [[(123,"")],[(123,".")],[]]
04:17:47 <lilac> ^^ WTF?
04:18:10 <nominolo> I'm trying to get Vim to communicate with a Scion server (which needs to remember some state)
04:18:19 <lilac> is that really the correct behaviour for Read Int?
04:18:31 <nominolo> But Vim (without using Python) cannot keep a reference to a process
04:18:35 <mmorrow> nominolo: could you just use a tcp socket and listen on loopback?
04:18:52 <Baughn> nominolo: Or a unix domain socket
04:19:07 <dobblego> @type isPrefixOf
04:19:08 <nominolo> so I want to have a small script that connects to the server whenever the vim user wants to do something that needs communicating with the server
04:19:08 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
04:19:18 <lilac> > let parse xs = do (v, ys) <- reads xs; case ys of { '!':zs -> do { (vs,t,rest) <- parse zs; return (v:vs,t,rest) }; z:zs | isLower z -> return (v:[],Just z,zs); _ -> return (v:[],Nothing,ys) } in parse "123!4456lxyq" :: [([Int],Maybe Char,String)]
04:19:20 <lambdabot>   [([123,4456],Just 'l',"xyq")]
04:19:20 <nominolo> Baughn: right, domain sockets are secure
04:19:34 <nominolo> but I had some problems getting quick startup times on Windows at least
04:19:35 <Baughn> nominolo: ..well, depending on the OS
04:19:41 <nominolo> it should connect within milliseconds
04:19:46 <Baughn> nominolo: Domain sockets are *not* secure on all operating systems
04:20:00 <nominolo> Baughn: right, but BSD sockets are even less so
04:20:15 <Baughn> nominolo: Option 2: ~/.vim.cookie
04:20:19 <Eelis> is there a reason why top-level if-blocks aren't supported in a cabal file? i want to make an optional executable that's only built/installed if a flag was passed.
04:20:27 <nominolo> Baughn: hm, what is that?
04:20:40 <mmorrow> nominolo: graphviz comes with a little handy script that starts vim with the given file, and opens a viewer window, then uses inotify to wait for changes to the file, and every time it sees one it updates the view of the graph
04:20:43 <Baughn> nominolo: A bunch of random data your server writes that your client has to supply to be allowed in.
04:21:08 <ivanm> Baughn: lol
04:21:10 <lilac> @src Read Int
04:21:10 <lambdabot> Source not found. My mind is going. I can feel it.
04:21:24 <nominolo> Baughn: right, yeah, something like that.  some sort of shared secret
04:21:41 <nominolo> mmorrow: interesting.  have a link?
04:22:06 <nominolo> mmorrow: oh, inotify is Linux only?
04:22:16 <Baughn> ivanm: Ah, I was wondering if you understood.
04:22:25 <mmorrow> nominolo: the shell script is super simple (and you probably have it if you have graphviz), but it's http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5122#a5122
04:22:30 <mmorrow> "vimdot"
04:22:38 <mmorrow> nominolo: yeah, linux only unfortunately
04:23:38 <ivanm> Baughn: was afk for a bit
04:24:10 <ivanm> mmorrow: presumably it would work in BSD if the BSD kernel had support for it...
04:25:03 <nominolo> the other option is to require python support for Vim.  But already MacVim doesn't include a recent enough version... :/
04:25:58 <mauke> require perl support instead!!
04:27:16 <nominolo> mauke: is that more widespread?
04:27:36 <mauke> no (I just like perl better)
04:27:43 <nominolo> mauke: I know that in general perl is more widely available than python
04:27:53 <BONUS> ?umtl StateT s (WriterT w []) a
04:27:53 <lambdabot> s -> [(a, s, w)]
04:28:06 <BONUS> isnt this also supposed to be s -> [((a,s),w)]
04:28:18 <nominolo> BONUS: it's isomorphic
04:28:29 <BONUS> yeah that's true
04:28:36 <mmorrow> (modulo a few undefined's)
04:28:44 <nominolo> mmorrow: right, as always
04:28:55 <BONUS> ?umtl WriterT w (ContT r []) a
04:28:55 <lambdabot> (a -> w -> [r]) -> [r]
04:29:00 <BONUS> but is this isomorphic?
04:29:04 <mauke> yes
04:29:08 <BONUS> to ((a,w) -> [r]) -> [r]
04:29:09 <mauke> see uncurry
04:29:13 <BONUS> ah of course
04:29:17 <nominolo> BONUS: module strictness
04:29:26 <nominolo> modulo*
04:29:47 <Baughn> ivanm: But you caught the reference. One of the greatest works of anti-rationalist propaganda of all time..
04:30:11 <ivanm> Baughn: ummm.... you were quoting something?
04:30:19 <ivanm> if so, I didn't catch the reference...
04:30:24 <Baughn> ivanm: The silver chair
04:30:52 <ivanm> never heard of it
04:31:07 <Baughn> ivanm: "To serve man" is written above the main entrance to a giant's mansion. The punchline is, of course, "for dinner".
04:31:25 <ivanm> oh, right, Narnia
04:31:35 <ivanm> didn't recall it being that exact phrase...
04:32:32 <Baughn> I wonder how C.S. Lewis would handle being one of the most hated authors in europe?
04:32:51 <sioraiocht> Baughn: self-righteously?
04:32:59 <Baughn> sioraiocht: Ah. Probably.
04:36:32 <Adamant> who hates C.S. Lewis?
04:36:47 <ivanm> Adamant: atheists
04:36:59 <Baughn> Adamant: And rationalists
04:37:01 <ivanm> IIRC, the golden compass, etc. was written directly as an anti-Narnia series
04:37:10 <Adamant> ivanm: lol yeah
04:37:18 <Adamant> that's why I can't take it seriously
04:37:30 <Adamant> nobody even reads C.S. Lewis in the first place
04:37:46 <dolio> I read all but one.
04:37:49 <p_l> narnia isn't that bad, I guess it's more of the hype that surrounds it... hype turning a self-fueling hate machine...
04:37:54 <Adamant> to get fired up enough about his writing to make a series of crappy fantasy novels....
04:38:32 <dolio> That is, all but one Narnia book. I've never bothered reading his apologetics or anything, because I hear they're terrible.
04:39:11 * p_l hears about C.S.Lewis being so hated for the first time
04:39:22 <decaf> p_l: me too
04:39:31 <Baughn> Adamant: I read cs lewis. I didn't realize it was propaganda at the time, though. :P
04:39:43 <Adamant> Baughn: everything's propoganda
04:39:50 <Baughn> Adamant: That said, the golden compass is simply a lot better - as a book, not as propaganda. I think it fails in the latter sense..
04:39:56 <Adamant> people are trying to convince you of their view
04:40:12 <Adamant> Baughn: I don't like Narnia but Golden Compass is even worse
04:40:22 <Baughn> No. There are plenty of works of fiction that are nothing more than works of fiction, with no author tracts mixed in.
04:40:47 <Adamant> Baughn: name one. they're influenced by an author's beliefs and worldview
04:40:50 * p_l liked Narnia even more when he noticed parallels with Bible, having read Revelation quite a lot due to NGE...
04:41:19 <O_4> NGE?
04:41:24 <p_l> Baughn: They can still function as propaganda
04:41:28 <Baughn> Neon genesis evangelion
04:41:34 <O_4> Ah
04:42:04 <Baughn> p_l, adamant: I don't think a book like.. hm, let's say Horatio Hornblower
04:42:18 <Baughn> It's written to /entertain/, that's all
04:42:19 <p_l> Baughn: Oh, it works very very well as propaganda :D
04:42:20 <Adamant> Baughn: lol
04:42:29 <Adamant> as an American, bullshit
04:42:42 <decaf> a fairy tale with satirs is christian propaganda?
04:42:43 <Baughn> p_l: How's that, anti-oldtimes propaganda?
04:42:43 <Adamant> Horatio takes out a US ship during the War of 1812
04:42:53 <Baughn> decaf: Aslan = Jesus. Take it from there.
04:42:55 <p_l> Baughn: Actually books that aren't written directly as propaganda give me that effect the most :P
04:43:12 <decaf> Baughn: aslan means lion in turkish, take this one :)
04:43:13 <Adamant> in one of his books and it's portrayed as a good thing
04:43:28 <Baughn> decaf: That doesn't surprise me a bit
04:43:31 <p_l> Adamant: Of course it is :3
04:43:36 <Baughn> Adamant: He's /british/
04:43:54 <Adamant> Baughn: but it doesn't help your propoganda claim
04:44:03 <Adamant> in fact it reinforces min
04:44:04 <Adamant> e
04:44:05 <p_l> decaf: I'd say... just last book of Narnia
04:44:17 <Baughn> Adamant: Perhaps it'd work as propaganda if I were british myself
04:44:53 <Baughn> (But probably not. I'm.. not anti-nation, but at least rather neutral towards the concept.)
04:44:56 <p_l> Baughn: What about seeing the actions of characters and thinking to yourself "now that's something I'd like to see IRL"?
04:45:24 <Baughn> p_l: Then that isn't changing your ideas, it's just highlighting an existing one
04:46:00 <Baughn> decaf: Oh, and the silver chair - the book explicitly states hat wishful thinking is preferable to reality.
04:46:17 <p_l> Baughn: Or changing the bias... quite possibly you won't meet anything new...
04:48:35 <decaf> Baughn: I'm very sorry to tell this: if that tale is a christian propaganda, that proof that christians are as 'smart' as my people (muslum turks)
04:49:14 <Baughn> decaf: Mm. Hate to break it to you, but theists are equally irrational regardless of religion.
04:49:32 <Baughn> Some may make it more visible, but overall.. *pout*
04:49:44 <p_l> afaik narnia was written for tolkien... wasn't it some kind of wager, btw?
04:50:43 <Baughn> 'Tolkien disliked the first Narnia book, published in 1950, telling the author it had too many clashing elements and was pushing the Christianity "message" too far. He also apparently "hated" Lewis's allegorical fight between good and evil, with Jesus represented by Aslan the Lion.' <-- Not exactly.
04:51:17 <Baughn> And yet, Tolkien was the one who converted Lewis from atheist to christian. :/
04:51:35 <p_l> Baughn: Lewis writing it with Tolkien in mind doesn't clash with Tolkien not liking end result :P
04:51:35 <Baughn> Converts are always the most fervent, I guess
04:56:07 <Baughn> decaf: http://www.guardian.co.uk/books/2005/dec/05/cslewis.booksforchildrenandteenagers <-- Yeah, that about covers it.
04:58:05 <quicksilver> Baughn: ERROR : Article too long.
04:58:06 <quicksilver> :)
04:58:55 <decaf> Baughn: I didn't read anything about lewis until a few minutes ago.
05:03:41 <ivanm> quicksilver: you mean tl;dr ? :p
05:15:00 <FalconNL> Does anyone know a way to take the log of large numbers? logBase 10 (10^308) == 308.0, but logBase 10 (10^309) == Infinity
05:15:20 <Baughn> > 10^309
05:15:22 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
05:15:25 <Baughn> > 10^309 :: Double
05:15:27 <lambdabot>   Infinity
05:15:31 <mauke> > logBase 10 (10^309) :: CReal
05:15:32 <lambdabot>   309.0
05:15:50 <Baughn> > 10^309 :: CReal
05:15:51 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
05:16:05 <Baughn> ..what's going on here?
05:17:37 <ivanm> Baughn: what do you mean?
05:17:45 <ivanm> CReal is computable reals (by roconnor?)
05:17:50 <Baughn> Well, CReal shouldn't have greater range than..
05:18:00 <Baughn> Oh. So, not a Foreign.C type
05:18:05 <ivanm> no
05:18:31 <mauke> there is no 'real' type in C
05:18:36 <ivanm> is there any sample usages or tutorials on how to use Text.ParseCombinators.ReadP?
05:23:40 <augustss> CReal is based on David Lester's code.
05:27:43 <FalconNL> Hm. If I call intLength (10^20000), where intLength n = succ . floor . logBase 10 $ (fromIntegral n :: CReal), it takes 1.5 seconds. Surely CReal can't be that slow?
05:27:51 <ivanm> it is
05:27:53 <ivanm> it's all functions
05:28:02 <ivanm> rather than actually "storing" the number
05:28:24 <EvilTerran> > exp (sqrt (-1) * pi) :: Complex CReal -- it is pretty cool, tho, even if it is slow
05:28:25 <lambdabot>   (-1.0) :+ 0.0
05:28:50 <ivanm> > exp (sqrt (-1) * pi) :: Complex Double
05:28:52 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
05:28:54 <ivanm> heh
05:29:44 <FalconNL> Ok, let's try this another way then. What I'm trying to do is to determine the length of the decimal representation of a number in a faster way than length . show. Since the log-based approach doesn't seem to be working very well, does anyone know another way?
05:30:06 <ivanm> any particular reason why you want to do so?
05:30:32 <ivanm> and of what datatype are you finding said length?
05:30:40 <FalconNL> for an algorithm to work with palindrome numbers for http://programmingpraxis.wordpress.com/2009/05/22/the-next-palindrome/
05:30:45 <ivanm> (since for a CReal, you can have infinite length...)
05:30:51 <ivanm> > pi :: CReal
05:30:52 <lambdabot>   3.1415926535897932384626433832795028841972
05:31:01 <FalconNL> Since the algorithm needs to work up to 10^1000000, probably Integers
05:31:05 <ivanm> that's right... defaults to 20 decimal places or something...
05:31:33 <ivanm> FalconNL: so by "decimal", you didn't mean "number of places after the decimal point"?
05:31:51 <quicksilver> "decimal" means "representation in base 10" :P
05:32:05 <FalconNL> no, I meant the amount of digits when shown in base 10, so 1001 -> 4, 17 -> 2, etc.
05:32:05 <EvilTerran> FalconNL, binary search to find i such that 10^i <= x < 10^(i+1)?
05:32:18 <ivanm> quicksilver: true, but I'm so used to having it mean "decimal places" when dealing with students, that that's what I automatically assume
05:32:25 <ivanm> FalconNL: divide it by a really big number
05:32:28 <ivanm> then log it
05:32:44 <ivanm> something like that
05:32:50 <ivanm> (Basically, you scale it down)
05:33:02 <quicksilver> FalconNL: does (floor . logBase 10) for doubles not work well?
05:33:18 <quicksilver> oh, 10^(10^6)
05:33:23 <quicksilver> yeah that's too big for that :)
05:33:36 <EvilTerran> it seems ugly to get floating point involved in a problem on integers
05:33:39 <FalconNL> quicksilver: If you try it with doubles it fails at 10^309. It works fine for 10^308
05:33:59 <quicksilver> EvilTerran: it is ugly, but it's sometimes faster. In this case it simply fails.
05:34:06 <quicksilver> EvilTerran's binary search sounds good.
05:34:20 <quicksilver> writing a fast version of length . show is another possibility.
05:36:39 <EvilTerran> another possibility would be looking at the GHC internals of Integer
05:37:01 <EvilTerran> you might even be able to do it O(1) that way with a bit of fudging
05:37:27 <lilac> FalconNL: why not do it with a string?
05:37:35 <quicksilver> lilac: he said it was too slow.
05:38:15 <lilac> quicksilver: i meant do the whole problem in a String and never go to a number representation
05:38:16 <FalconNL> lilac: because length $ show $ 10^1000000 takes about 800 ms
05:39:14 <quicksilver> ah nod.
05:39:43 <Baughn> @tell conal I've isolated the bug in my previous paste to filterE. I will now proceed to pine for my laptop all weekend.
05:39:43 <lambdabot> Consider it noted.
05:50:51 * byorgey makes lambda-rhubarb muffins
05:51:04 <Badger> :)
05:51:06 <opqdonut> how about curry-howard muffins
05:51:18 <byorgey> those are good too
05:51:21 <Badger> curried howard?
05:51:36 <dev31212> hi quicksilver
05:51:37 <dev31212> hi all
05:51:53 <byorgey> hi dev31212
05:52:00 <dev31212> hy byorgey
05:52:03 <dev31212> how goes it
05:52:29 <byorgey> quite well, how are you?
05:52:55 <Baughn> @tell conal Compare the existing definition of filterE with this: "filterE p m = justE $ (\i -> if p i then Just i else Nothing) <$> m". Neither /works/, but this one works /better/ - I suppose some odd laziness issues there, since they look identical to me.
05:52:56 <lambdabot> Consider it noted.
05:52:59 <dev31212> Im good thanks...I negotiated an easier work load, so I have more time to devote to my haskell web project
05:53:06 <dev31212> less pay, but less stress and more time..so Im happuy
05:53:15 <gio123> is here any german speakers?
05:53:23 <dev31212> Im evaluating a framework called "Kibro" at the moment..
05:53:26 <dev31212> know anything about it?
05:53:56 <ivanm> gio123: I would say that Germany is full of German speakers
05:54:02 <ivanm> here, though, is a different story ;-)
05:54:05 <dev31212> hi ivanm
05:54:10 <quicksilver> Baughn: I discussed an alternative implementation of filterE with conal.
05:54:10 <ivanm> hey dev31212
05:54:20 <dev31212> Jr parle un pue de le feancais, si-tu-plait
05:54:23 <quicksilver> Baughn: it doesn't work for his implementation although it does for mine.
05:54:33 <quicksilver> Baughn: might be interesting to you.
05:54:35 <dev31212> je*
05:54:56 <dev31212> hayoo kibro
05:55:01 <dev31212> > hayoo kibro
05:55:02 <lambdabot>   Not in scope: `hayoo'Not in scope: `kibro'
05:55:15 <frwmanners> Baughn: so, I came to the conclusion that no version of filterE could work with reactive-10.5's structure of time
05:55:27 <opqdonut> @hackage kibro
05:55:27 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/kibro
05:55:32 <frwmanners> Baughn: as in, AddBounds (Improving Stuff)
05:55:32 <dev31212> Thanks :)
05:55:45 <opqdonut> :)
05:55:47 <dev31212> Anyone know about kibro? I cant find a web page or a tutorial for it
05:56:27 <dev31212> I am trying to avoid building my own web framework...but on the other hand that might be the best way for me to learn the language..
05:56:52 <dev31212> hmm
05:57:00 <dev31212> I think I just made an argument for making my own framework
05:57:37 <ivanm> so we get Yet Another Haskellian Web Framework?
05:57:45 <dev31212> Yeah :)
05:57:51 <dev31212> From a former PHP guy
05:57:57 <dev31212> well current...hope to be former one day
05:58:02 * mauke runs away
05:58:05 <EvilTerran> better write a monad tutorial (and library!) as well ;P
05:58:05 <dev31212> lol
05:58:18 <boml> mauke: what does this part do "use List::Util qw(reduce)"
05:58:41 <ivanm> EvilTerran: what kind of library?
05:58:48 <boml> he's gone. I'll just send it to everyone
05:58:57 <boml> what does this mean? use List::Util qw(reduce)
05:59:03 <quicksilver> Baughn: it's perl.
05:59:06 <quicksilver> oops
05:59:08 <quicksilver> boml: it's perl.
05:59:23 <boml> yepp
05:59:26 <ivanm> I know it's compulsory to write a monad tutorial (something I've been remiss in), but it's compulsory to write a library as well? :s
06:01:35 <EvilTerran> ivanm, well, judging by the number of 'em on hackage
06:01:52 <ivanm> aren't half of them by dons and mmorrow?
06:01:53 <ivanm> ;-)
06:02:04 <EvilTerran> "... Middleware (1), Monadic Regions (1), Monads (24), Music (11) ..."
06:03:07 <decaf> 'google suggest' helps to type "What the hell are monads?"
06:04:02 <ray> :t (>>=)
06:04:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:04:08 <ray> ^^ monad tutorial
06:04:26 <ivanm> @quote endofunctors
06:04:26 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
06:04:34 <ivanm> ^^ that's what monads are!
06:04:57 <EvilTerran> in terms of general monad libs, there's MonadLab, monadLib, and mtl, at least; not to mention category-extras & co's shennanigans
06:04:57 <ivanm> I was actually after the supposed wadler quote, but that'll do (since it's basically the same thing)
06:05:09 <ivanm> does that mean that psykotic came up with that first?
06:05:18 <mauke> @quote chocolate
06:05:18 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
06:05:37 <ivanm> EvilTerran: IIRC, don't most people adovcate using monadlab or monadlib rather than mtl as they're much better libraries?
06:05:56 <ivanm> and monad transformers are better defined/thought up nowadays than when mtl was written?
06:06:05 <ivanm> mauke: O...K... then...
06:07:10 <EvilTerran> ivanm, yeah, i think that's the case; not sure how m'lab and m'lib compare, tho
06:07:18 <jonte> Hello boys and girls! I have a problem. I have a function returning (Maybe a, Splay a),it's called 'insert', and I wish to assign this return value to two variables (pattern match). I'm doing this: where; (e, t) = insert elem tree. What am I doing wrong? :) Thanks!
06:07:53 <quicksilver> jonte: that's fine except for the ; after where
06:08:03 <mauke> jonte: what's the error message?
06:08:42 <EvilTerran> quicksilver, isn't a ; valid there if you're using explicit layout?
06:08:48 <jonte> quicksilver, That'‰s just for line breaking in the chat.. hmm.. The error I get is: Type error in right hand side, (Maybe c) doesn't match (a,b)
06:08:48 <quicksilver> I'm not sure.
06:09:03 <quicksilver> then your insert doesn't return (Maybe a,Splay a)
06:09:09 <quicksilver> even though you claim it does :P
06:09:14 <quicksilver> it returna (Maybe c)
06:09:23 <mauke> maybe it returns Maybe (a, Splay a)
06:09:31 <EvilTerran> > let { foo = bar where; bar = () } in foo
06:09:33 <lambdabot>   ()
06:09:35 <tetha> hehe, reasons to add explicit type signatures
06:10:01 <EvilTerran> ^ you're allowed blank lines in layout blocks, so it makes sense that that's valid, really.
06:10:05 <jonte> Hmm! I'll have to look in the library. it SHOULD return that. :)
06:10:35 <jonte> Oh. Darn. You're right. :P Sorry to bother you guys. :)
06:11:05 <EvilTerran> > () where {;;} -- listening to sad music in oversized headphones?
06:11:06 <lambdabot>   ()
06:11:38 <tetha> heh
06:11:56 <tetha> or cthuhlu with headphones
06:13:04 <Japsu> Every time you misspell fhtagn, Cthulhu eats a cultist.
06:13:12 <Japsu> Please, think about the cultists.
06:13:57 <ivanm> @type where
06:13:58 <lambdabot> parse error on input `where'
06:14:00 <tetha> since I like him and dislike cultists, I guess misspelling is a good thing
06:14:04 <ivanm> duh
06:18:28 <EvilTerran> @type () where {}
06:18:29 <lambdabot> parse error on input `where'
06:18:36 <EvilTerran> > () where {} -- rather
06:18:37 <lambdabot>   ()
06:19:50 <ray> > () where ()
06:19:52 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:20:02 <ray> therefore, haskell sucks
06:20:07 <ivanm> :o
06:20:09 <ivanm> @slap ray
06:20:09 * lambdabot beats up ray
06:20:12 <opqdonut> :D
06:20:23 <EvilTerran> > ({-) where (-})
06:20:24 <lambdabot>   ()
06:20:37 <ivanm> EvilTerran: heh
06:20:43 <mauke> > () where () = ()
06:20:44 <lambdabot>   ()
06:20:48 * ivanm has no idea wtf it's meant to do though...
06:21:03 <ivanm> mauke: you can set () to equal something? :o
06:21:06 <ivanm> > () where () = 1
06:21:07 <lambdabot>       No instance for (Num ())
06:21:07 <lambdabot>        arising from the literal `1' at <intera...
06:21:10 <mauke> > 1 where 2 = 3
06:21:10 <ivanm> heh
06:21:11 <lambdabot>   1
06:21:21 <kpreid> ivanm: no, it's a pattern match with no variables
06:21:21 <ray> making it symmetrical with comments is cheating
06:21:27 <ivanm> mauke: that works because 2 isn't evaluated/defined?
06:21:28 <mauke> > let 2 + 2 = 5 in 2 + 2
06:21:29 <lambdabot>   5
06:21:31 <ivanm> kpreid: oh, yeah
06:21:38 <ivanm> mauke: :o
06:21:42 <ivanm> and how does _that_ work?
06:21:50 <quicksilver> it redefines (+)
06:21:52 <ray> it's defining +
06:21:53 <kpreid> since it's not in a case or lambda, it doesn't even care if it matches
06:21:58 <quicksilver> > let 2 + 2 = 5 in 2 + 3
06:22:00 <lambdabot>   * Exception: /tmp/7791359399523594690:71:56-64: Non-exhaustive patterns in ...
06:22:00 <kpreid> > () where False = True
06:22:01 <lambdabot>   ()
06:22:15 <ivanm> quicksilver: you can do that? :o
06:22:18 <quicksilver> it's a bug in lambdabot that it accepts 'where' on a top level expression, by the way.
06:22:22 <Peaker> @type let 2+2=5 in (+)
06:22:23 <ivanm> @type let 2 + 2 = 5 in 2 + 2
06:22:23 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => t -> t1 -> t2
06:22:24 <lambdabot> forall t. (Num t) => t
06:22:31 <quicksilver> ivanm: you can define any operator. You can shadow any variable.
06:22:33 <kpreid> > let 2 + k = succ (succ k) in 2 + 2 + 2
06:22:35 <lambdabot>   * Exception: /tmp/7038665918903841508:71:52-72: Non-exhaustive patterns in ...
06:22:35 <quicksilver> ivanm: (+) is not magic.
06:22:41 <kpreid> > let 2 + k = succ (succ k) in 2 + (2 + 2)
06:22:43 <lambdabot>   6
06:22:48 <ivanm> quicksilver: yes, but it's already defined for the numeric types...
06:23:08 <EvilTerran> quicksilver, i thought it was a deliberate feature, tbh. it's kinda useful.
06:23:27 <ray> > let id _ = error "i shadowed id" in id ()
06:23:29 <lambdabot>   * Exception: i shadowed id
06:23:59 * ivanm didn't know you could override/shadow top-level values/functions...
06:24:07 <EvilTerran> and it would suggest a point to the "let v = ... in v" which has lead to shennanigans in the past
06:24:10 <EvilTerran> @v
06:24:10 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
06:24:47 <quicksilver> ivanm: you can override shadow anything.
06:25:10 <EvilTerran> well, apart from reserved words/symbols
06:25:35 <mauke> > let pi = text "œÄ" in pi
06:25:37 <lambdabot>   œÄ
06:25:52 <doserj> > let qualified = 3 in qualified
06:25:53 <lambdabot>   3
06:26:00 * doserj is cheating
06:26:34 * EvilTerran notes that the newbie error of "case ... of ...; otherwise -> ..." doesn't get caught because of this very shadowing
06:26:58 <ivanm> EvilTerran: because otherwise becomes a variable that matches anything?
06:27:02 <ivanm> rather than an alias for True?
06:27:04 <ivanm> > otherwise
06:27:05 <lambdabot>   True
06:27:11 <Badger> > let everything = 42 in everything
06:27:13 <lambdabot>   42
06:27:13 <ivanm> @index otherwise
06:27:13 <lambdabot> Data.Bool, Prelude
06:27:25 <EvilTerran> ivanm, exactly, and then things get very odd if you try to use it in a guard within that case branch
06:27:34 <ivanm> EvilTerran: heh
06:29:00 <EvilTerran> ?type \x -> case x of Nothing -> "foo"; otherwise | fromJust x == "bar" -> "baz" | otherwise -> "eek" -- silly contrived example
06:29:01 <lambdabot>     Couldn't match expected type `Bool'
06:29:01 <lambdabot>            against inferred type `Maybe [Char]'
06:29:01 <lambdabot>     In a stmt of a pattern guard for
06:30:04 <cnwdup> > let braces = between (string "{") (string "}"); expr = braces expr <|> many (noneOf "{}") in parse expr "" "parse me!"
06:30:05 <lambdabot>   Not in scope: `between'Not in scope: `string'Not in scope: `string'Not in s...
06:30:21 <cnwdup> Mh, parsec's not in scope? ):
06:30:26 <quicksilver> nope.
06:30:34 <cnwdup> Anyways, can anyone explain why this results in a stack overflow:
06:30:42 <cnwdup> let braces = between (string "{") (string "}"); expr = braces expr <|> many (noneOf "{}") in parse expr "" "{ }"
06:30:51 <cnwdup> I do not see why.
06:31:56 <quicksilver> cnwdup: it yields 'Right " "' for me.
06:32:25 <cnwdup> Ups. I meant parse (many expr "" "{ }".
06:32:42 <mauke> many/many
06:33:05 <quicksilver> (many expr)
06:33:06 <quicksilver> ?
06:33:06 <mauke> you now have an infinite sequence of zero-length matches
06:33:12 <cnwdup> Ah. Okay.
06:33:14 <EvilTerran> cnwdup, well, many can match the empty string
06:33:28 * EvilTerran pokes his lag-o-meter
06:33:31 * mauke recommends Mastering Regular Expressions :-)
06:33:47 <Berengal> Empty strings are evil
06:33:54 <Berengal> Don't match them
06:34:32 <maltem> mauke, sure, and then they're going to match expressions with matching braces
06:35:00 <mauke> not a problem
06:35:44 <EvilTerran> cnwdup, i would suggest braces = between (char '{') (char '}'); expr = braces expr <|> many1 (noneOf "{}")
06:35:48 <EvilTerran> (i think it's called many1)
06:36:22 <cnwdup> EvilTerran, yeah. I ended up with expr = braces (many1 expr) <|> many1 (noneOf "{}"). Thank you guys.
06:36:33 <rubendv> is it possible to implement fromIntegral in regular Haskell?
06:36:42 <mauke> many1/many1
06:36:53 <EvilTerran> mauke, ?
06:36:57 <mauke> infinite backtracking avoided thanks to parsec's early commit
06:36:58 <doserj> @src fromIntegral
06:36:58 <lambdabot> fromIntegral = fromInteger . toInteger
06:37:30 <EvilTerran> <mauke> many/many <mauke> many1/many1 <- IDGI
06:37:41 <rubendv> how about fromInteger and toInteger then?
06:37:56 <mauke> my $expr = qr/\{(?0)\}|[^{}]*/;
06:38:15 <EvilTerran> rubendv, if the type you're writing an instance for is in regular haskell, yes
06:38:18 <mauke> EvilTerran: "many applied to many applied to something"
06:38:24 <mauke> i.e. direct nesting
06:38:41 <rubendv> EvilTerran: so it is not possible for builtin types like Int
06:38:57 <EvilTerran> rubendv, well, seeing as they're not "regular haskell"...
06:39:09 <EvilTerran> although they could be defined as such, seeing as they're abstract
06:39:15 <rubendv> I see
06:39:29 <rubendv> I was just wondering about that, thank you.
06:40:33 <EvilTerran> ?src Bool
06:40:33 <lambdabot> data Bool = False | True deriving (Eq, Ord)
06:40:39 <EvilTerran> rubendv, note Bool is "regular haskell"
06:41:20 <EvilTerran> so not all Prelude types are "built in" by this definition
06:41:39 <ivanm> I notice here that regex-{base,posix,compat} are included in the ghc documentation: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
06:41:39 <maltem> mauke, humph. ok, if you read "regular expression" as "not-so-regular regular expression", then sure, no problem
06:41:50 <ivanm> is this part of extralibs or something, because on my local install they're not...
06:42:04 <rubendv> So fromInteger and toInteger are functions you have to define when making an Integral instance?
06:42:11 <mauke> maltem: pretty much all regexes are irregular
06:42:14 <ivanm> @src Integral
06:42:15 <lambdabot> class  (Real a, Enum a) => Integral a  where
06:42:15 <lambdabot>     quot, rem, div, mod :: a -> a -> a
06:42:15 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
06:42:15 <lambdabot>     toInteger           :: a -> Integer
06:42:23 <ivanm> rubendv: fromInteger is in Num
06:42:30 <ivanm> toInteger is in INtegral
06:43:03 <maltem> mauke, I hoped that if there were a place for straight terminology, it would be #haskell :))
06:43:22 <rubendv> I see
06:44:05 <rubendv> Makes sense :), thank you.
06:45:47 <Spockz|lap> test
06:46:29 <ivanm> sorry, but your test failed due to insufficient input
06:46:49 <Spockz|lap> darn, sorry. I thought it would only run on the active server.
06:48:08 <ivanm> heh
06:58:10 <lilac> FalconNL: how fast does this palindrome thing have to be?
06:59:00 <lilac> FalconNL: is 1.066s for 1000000 digits quick enough?
06:59:02 <ivanm> lilac: you do realise he was asking about 1.5 hrs ago, don't you?
06:59:13 <lilac> ivanm: yes, but i've been at lunch :)
06:59:17 <FalconNL> lilac: there's no real requirement, but the faster the better. I'm currently reworking my algorithm a bit to make it faster
06:59:18 <ivanm> lilac: IIRC, he was after 10^309 digits...
06:59:19 <ivanm> heh
07:01:50 <skorpan> can a logical predicate take two arguments?
07:01:57 <lilac> the universe doesn't have enough space to store a number with 10^309 digits...
07:01:58 <skorpan> e.g. P(x, y)
07:02:32 <FalconNL> I only need 10^6 digits, which is 10^(10^6). logBase fails at 10^309
07:03:50 <lilac> yep, my approach works for 10^6 digits
07:04:09 <opqdonut> skorpan: yes, usually
07:04:39 <skorpan> could this function be written any prettier?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5126#a5126
07:05:02 <skorpan> i tried to rewrite it using a fold, but failed
07:05:39 <opqdonut> skorpan: it's pretty nice as it is
07:06:05 <skorpan> i usually try to avoid helper functions like that one and it sure feels pretty foldy
07:06:05 <opqdonut> you could turn the case into guards for the duplicatesBy' definition
07:06:12 <FalconNL> liliac: would you mind showing your solution? Obviously you're doing something faster than I currently am
07:06:24 <Twey> skorpan: duplicatesBy f = groupBy f . sortBy (comparing f)
07:06:26 <opqdonut> if you wrote that as a fold, it'd have to be a fold over the tails of a list
07:06:27 <Twey> No?
07:06:46 <opqdonut> Twey: yeah but that needs an ordering
07:06:50 <Twey> Or, wait, probably not comparing f
07:06:56 <skorpan> Twey: comparing puts Ord
07:06:56 <Twey> Yeah
07:06:58 <skorpan> yeah
07:06:59 <skorpan> :)
07:07:09 <opqdonut> and it'd also need a (head . filter (\x -> length x >= 1))
07:07:34 <Twey> a.k.a. (head . filter (not . null))
07:07:56 <opqdonut> gah, i meant length x > 1
07:08:05 <Twey> Ah
07:08:06 <Twey> Yeah
07:08:13 <paper_cc> well... nubBy f xs = map fst $ filter (not . uncurry f) $ zip xs (tail xs), but it fails on xs == []
07:08:15 <skorpan> any other suggestions?
07:08:33 <opqdonut> hmm, duplicatesBy ys = [x | (x:xs) <- tails ys, isJust $ find (p x) xs]
07:08:37 <Twey> @index [a] -> [[a]]
07:08:37 <lambdabot> bzzt
07:08:38 <paper_cc> skorpan: ^^above
07:08:44 <Twey> @hoogle [a] -> [[a]]
07:08:44 <lambdabot> Data.List inits :: [a] -> [[a]]
07:08:45 <lambdabot> Data.List tails :: [a] -> [[a]]
07:08:45 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
07:08:57 <Twey> Hmm
07:09:01 <skorpan> > let duplicatesBy p ys = [x | (x:xs) <- tails ys, isJust $ find (p x) xs] in duplicatesBy (==) [1,2,3,1,2]
07:09:02 <lambdabot>   [1,2]
07:09:08 <skorpan> > let duplicatesBy p ys = [x | (x:xs) <- tails ys, isJust $ find (p x) xs] in duplicatesBy (==) [1,2,3,1,2,4,2]
07:09:09 <lambdabot>   [1,2,2]
07:09:18 <skorpan> hm, this is not right
07:09:35 <opqdonut> skorpan: same behaviour as your function
07:09:36 <skorpan> my original function does the wrong thing...
07:09:42 <opqdonut> multpile duplicates... yeah
07:09:54 <skorpan> no, my function doesn't give multiple duplicates
07:09:55 <paper_cc> @ty \f xs -> map fst $ filter (uncurry f) $ zip xs (tail xs) -- this is wrong the same way
07:09:57 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
07:10:02 <skorpan> the problem is that i want *all* duplicates!
07:10:06 <skorpan> and yours doesn't do that either :)
07:10:24 <skorpan> so dupsBy (==) [1,2,3,1,2] would give me [1,2,1,2]
07:10:29 <opqdonut> yeah
07:10:54 <skorpan> (this is for a little verifier returning any multiple function declarations)
07:11:24 <skorpan> so i need to be able to provide any predicate and have all the duplicates
07:11:38 <FalconNL> lilac: would you mind showing your solution? Obviously you're doing something faster than I currently am
07:12:36 <skorpan> i think another "case" does it
07:12:45 <skorpan> yes, it does.
07:13:00 <skorpan> updated ugly version: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5127#a5127
07:13:37 <paper_cc> > inits [1..5]
07:13:39 <lambdabot>   [[],[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5]]
07:13:40 <byorgey> skorpan: doesn't that return the duplicates in reverse order?
07:13:44 <byorgey> or maybe that doesn't matter
07:13:45 <paper_cc> > tails [1..5]
07:13:47 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
07:14:01 <skorpan> byorgey: doesn't really matter, but ideally i'd want them in the right order
07:14:06 <skorpan> i guess reverse would do that
07:14:14 <byorgey> yeah, just stick in a call to reverse
07:14:34 <rubendv> skorpan: looks like you could use the Maybe monad
07:14:42 <skorpan> rubendv: i thought so too, but can't figure out how
07:14:50 <skorpan> Nothing >>= _ = Nothing
07:14:56 <doserj> > let dupsBy p ys = [b | n <- [0..(length ys) -1], let (as,b:bs) = splitAt n ys, any (p b) (as++bs)] in dupsBy (==) [1,2,3,2,4,2,1]
07:14:58 <lambdabot>   [1,2,2,2,1]
07:15:09 <rubendv> you could redefine it perhaps?
07:15:23 <byorgey> off the top of my head, I don't think you can use the Maybe monad
07:15:23 <skorpan> rubendv: what do you mean?
07:15:31 <byorgey> because Nothing here doesn't indicate overall failure.
07:15:36 <skorpan> indeed
07:15:40 <rubendv> or is that something you can't do?
07:15:40 <byorgey> it just means that element isn't a duplicate.
07:16:23 <byorgey> rubendv: what, redefine >>= for Maybe?
07:16:30 <byorgey> you can't really do that
07:16:43 <paper_cc> > let splits xs = zipWith (++) (inits xs) (tail $ tails xs) in splits [1..4]
07:16:43 <byorgey> you wouldn't really want to, anyway
07:16:44 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
07:17:51 <rubendv> and what if you define >>= for a Maybe SomeDataType?
07:18:20 <skorpan> that doesn't make sense to me
07:18:46 <skorpan> this function is intended to be somewhat generic
07:18:55 <quicksilver> that is mplus
07:18:58 <quicksilver> in the Maybe monad
07:19:03 <quicksilver> > Nothing `mplus` Just 3
07:19:05 <lambdabot>   Just 3
07:19:08 <skorpan> ah
07:19:28 <doserj>  > let dupsBy p ys = [b | (as,b:bs) <- init $ zip (inits ys) (tails ys), any (p b) (as++bs)] in dupsBy (==) [1,2,3,2,4,3,2,1]
07:19:30 <doserj> > let dupsBy p ys = [b | (as,b:bs) <- init $ zip (inits ys) (tails ys), any (p b) (as++bs)] in dupsBy (==) [1,2,3,2,4,3,2,1]
07:19:32 <lambdabot>   [1,2,3,2,3,2,1]
07:19:50 <davidL> does this data surprise anyone? http://web.cecs.pdx.edu/~lazard/chart.png Why would I use one over another for dumping a [Word8] to a file?
07:20:21 <skorpan> > let dupsBy p ys = [b | (as,b:bs) <- init $ zip (inits ys) (tails ys), any (p b) (as++bs)] in dupsBy (==) []
07:20:22 <lambdabot>   []
07:20:26 <skorpan> > let dupsBy p ys = [b | (as,b:bs) <- init $ zip (inits ys) (tails ys), any (p b) (as++bs)] in dupsBy (==) [1,2,1]
07:20:27 <lambdabot>   [1,1]
07:20:30 <skorpan> interesting...
07:21:02 <quicksilver> but it's not obvoious the best way to write it
07:21:14 <skorpan> certainly not
07:21:21 <quicksilver> since in the case that you find it as "y", you use (x:found)
07:21:23 <quicksilver> not (z:found)
07:21:30 <quicksilver> so the two branches don't really have the same pattern
07:21:36 <skorpan> i'll try doing something with mplus...
07:22:18 <skorpan> i can't seem to find the definition of Maybe's mplus
07:22:29 <byorgey> @src Maybe mplus
07:22:30 <lambdabot> Nothing `mplus` ys = ys
07:22:30 <lambdabot> xs      `mplus` ys = xs
07:22:35 <skorpan> okay, found it :)
07:22:35 <opqdonut> skorpan: how about something like: dupsBy p xs = filter (\x -> count (p x) xs > 1) xs
07:22:40 <lilac> FalconNL: my solution is posted as a comment on that blog
07:22:50 <skorpan> let dupsBy p xs = filter (\x -> count (p x) xs > 1) xs in [1,2,1]
07:22:52 <skorpan> > let dupsBy p xs = filter (\x -> count (p x) xs > 1) xs in [1,2,1]
07:22:54 <lambdabot>   Not in scope: `count'
07:23:05 <skorpan> > let dupsBy p xs = filter (\x -> (length . filter) (p x) xs > 1) xs in [1,2,1]
07:23:07 <lambdabot>   Couldn't match expected type `[a]'
07:23:12 <skorpan> hurmm...
07:23:20 <doserj> > let dupsBy p ys = [b | (as,b:bs) <- init $zip (inits ys) (tails ys), any (p b) (as++bs)] in dupsBy ((==)`on`(`mod`10)) [1,11,21,2,12,3,4,5]
07:23:21 <lambdabot>   [1,11,21,2,12]
07:23:34 <byorgey> (length.) . filter  I think
07:23:42 <skorpan> > let dupsBy p xs = filter (\x -> ((length .) . filter) (p x) xs > 1) xs in [1,2,1]
07:23:44 <lambdabot>   [1,2,1]
07:23:50 <paper_cc> let splits xs = zipWith (++) (inits xs) (tail $ tails xs); dupsBy f xs = catMaybes $ zipWith (\x other -> find (f x) other)  xs (splits xs) in dupsBy (==) [1,2,3,1,2]
07:23:50 <skorpan> no cigar!
07:23:55 <paper_cc> oh
07:23:56 <paper_cc> > let splits xs = zipWith (++) (inits xs) (tail $ tails xs); dupsBy f xs = catMaybes $ zipWith (\x other -> find (f x) other)  xs (splits xs) in dupsBy (==) [1,2,3,1,2]
07:23:58 <lambdabot>   [1,2,1,2]
07:24:10 <byorgey> skorpan: um, look carefully at what you typed there =)
07:24:13 <davidL> > let dupsBy p xs = filter (\x -> length (filter p xs) > 1) xs in dupBy (==) [1,2,1]
07:24:14 <lambdabot>   Not in scope: `dupBy'
07:24:18 <davidL> > let dupsBy p xs = filter (\x -> length (filter p xs) > 1) xs in dupsBy (==) [1,2,1]
07:24:19 <lambdabot>   Couldn't match expected type `Bool'
07:24:28 <skorpan> oh byorgey :)
07:24:28 <wicket> I'm not entirely sure what kind of results you want from [1,2,3,1,2]
07:24:31 <opqdonut> davidL: (p x) ...
07:24:35 <skorpan> wicket: [1,2,1,2]
07:24:46 <davidL> > let dupsBy p xs = filter (\x -> length (filter (p x) xs) > 1) xs in dupsBy (==) [1,2,1]
07:24:47 <lambdabot>   [1,1]
07:25:00 <skorpan> > let dupsBy p xs = filter (\x -> length (filter (p x) xs) > 1) xs in dupsBy (==) [1,2,3,1,2]
07:25:01 <lambdabot>   [1,2,1,2]
07:25:05 <skorpan> this is beautiful
07:25:07 <byorgey> brilliant!
07:25:14 <opqdonut> thank you :)
07:25:16 <skorpan> thanks davidL, mind if i use this code in yi? :)
07:25:18 <byorgey> opqdonut++
07:25:23 <davidL> what
07:25:24 <skorpan> oh, what
07:25:27 <skorpan> was that opqdonut?
07:25:33 <opqdonut> sure, go ahead
07:25:44 <skorpan> thanks
07:25:48 <doserj> > let dupsBy p ys = [y | y <- ys, any (p y) (ys\\[y])] in dupsBy ((==)`on`(`mod`10)) [1,11,21,2,12,3,4,5] -- cheating a bit
07:25:49 <lambdabot>   [1,11,21,2,12]
07:26:05 <opqdonut> ys\\[y], hng
07:27:22 <paper_cc> ys \\ [y] requires Eq
07:27:22 <byorgey> doserj: I don't think that's quite the same, is it?
07:27:33 <skorpan> it's not
07:27:34 <doserj> the nested filters are nice
07:27:48 <doserj> I did say I cheated :)
07:27:52 <byorgey> hehe
07:28:05 <opqdonut> doserj: they capture the intent quite nicely, right
07:28:19 <opqdonut> i find the > 1 a bit ugly though
07:28:30 <byorgey> even better would be to make a function to test whether the length of a list is > 1
07:28:39 <byorgey> calling length and checking if its > 1 is not lazy enough
07:28:57 <mauke> not . null . drop 1
07:29:44 <opqdonut> mauke: better i guess
07:29:45 <gwern> @quote drug.*addict
07:29:45 <lambdabot> No quotes match. Just what do you think you're doing Dave?
07:29:54 <gwern> @remember seydar what's the nick of the drug addict who wrote learn you a haskell? and i mean that in the best possible way.
07:29:54 <lambdabot> I will remember.
07:30:09 <gwern> @quote String.*poor
07:30:09 <lambdabot> No quotes match.
07:30:22 <gwern> @remember roconnor String is kinda a poor data type for strings.
07:30:23 <lambdabot> I will remember.
07:30:33 <gwern> @quote beaten.*up
07:30:33 <lambdabot> No quotes match. There are some things that I just don't know.
07:30:44 <gwern> @remember kyevan I had a haskell-related dream last night. Sorta. I was beaten up by some kids because I tried to go somewhere my type didn't match, apparently.
07:30:44 <lambdabot> Done.
07:30:56 <gwern> @quote Windows.*98
07:30:56 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
07:31:05 <gwern> @remember edwardk Haskell 98 is the Windows 98 of standards ;)
07:31:05 <lambdabot> Okay.
07:31:12 <gwern> @quote endofunctor
07:31:12 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
07:31:16 <gwern> @quote endofunctor
07:31:16 <lambdabot> PhilipWadler says: I'm delighted to learn that "a monad is a monoid in the category of endofunctors"---anyone know where I can find a good tutorial?
07:31:32 <gwern> @quote play.*monads
07:31:32 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
07:31:41 <gwern> @remember DavidLeimbach Don't play with your monads... eventually you'll go bind.
07:31:42 <lambdabot> Okay.
07:31:45 <gwern> @flush
07:32:46 <weilawei> lambdabot is on the ball today ^__^
07:33:50 <opqdonut> @quote
07:33:51 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
07:34:17 <weilawei> @quote
07:34:17 <lambdabot> SamB_XP says: oh. does A/S/L mean Age/Sex/Programming Language?
07:34:24 <weilawei> xD i wish
07:36:22 <gnuvince> I have a dumb question: some programming languages (Smalltalk, Clojure, Factor) provide abstract interfaces to their collection types, making it easy to switch from one to another.  Haskell doesn't seem to have that, though I guess it could with a typeclass.  Is the reason for that purely historic, or am I missing an important technical point?
07:37:16 <opqdonut> i'd say historic
07:37:33 <solrize_> foldable ?
07:37:44 <byorgey> gnuvince: note this isn't about the languages themselves but about the standard libraries.
07:37:46 <opqdonut> Functor :)
07:38:26 <byorgey> gnuvince: I agree this is one area where the standard libraries could be improved somewhat.  Although there are libraries like Edison.
07:38:30 <opqdonut> gnuvince: a partial reason is that the usual kind of collection "interface" would require multi param typeclasses, fundeps and possibly associated types
07:38:30 <byorgey> dunno if that's still maintained.
07:39:11 <gwern> edison is maintained; just no one uses it
07:39:27 <opqdonut> a shame
07:40:28 <quicksilver> gnuvince: is it clear whether it's worth it?
07:40:40 <quicksilver> the difference between the collection types is normally such that if you need one, you need that one.
07:40:52 <quicksilver> the "lowest common denominator" of their interfaces is very small
07:41:00 <FalconNL_> I don't suppose there's a faster version of read? (read $ show $ 10^1000000 :: Integer) is very slow.
07:41:15 <quicksilver> whilst the corresponding upper bound contains all sorts of necessarily inefficient things.
07:41:21 <opqdonut> you're not really supposed to use read for anything real
07:41:36 <solrize_> ???
07:41:50 <FalconNL_> opqdonut: it's fast enough up to 10^10000 or so, but after that it becomes slow
07:41:58 <byorgey> FalconNL_: yeah, read is rather slow
07:42:05 <lilac> i wouldn't think of any situation where you have to read a million digit number as 'real' anyway...
07:42:11 <Berengal> Why would you want to read such a number?
07:42:14 <opqdonut> lilac: hehe
07:42:30 <byorgey> if you want something faster you can roll your own with a fold over a bytestring
07:42:37 <opqdonut> indeed
07:42:42 <solrize_> why don't they just fix read?
07:42:49 <pejo> lilac, read is slow for other things as well. D. Swierstra and some others had a paper at the haskell symposium last year on it.
07:42:51 <gwern> wonder if data.binary would read just Integers faster
07:43:28 <lilac> Berengal: FalconNL is attacking this: http://programmingpraxis.wordpress.com/2009/05/22/the-next-palindrome/
07:43:29 <byorgey> solrize_: I think part of the problem is that read is so general.  for reading any particular thing a custom solution is likely to be faster.
07:43:40 <Berengal> lilac: ah
07:43:48 <solrize_> i don't get it.  other languages have read-like functions that are fast.
07:44:16 <quicksilver> solrize_: part of the reason is the underlying slowness of String
07:44:18 <quicksilver> I suspect.
07:44:20 <lilac> FalconNL_: for what it's worth, i think you should consider solutions which don't involve converting your string to a number and back
07:44:22 <quicksilver> I don't know how much of it.
07:45:15 <byorgey> yeah, that's a fun problem
07:45:20 <FalconNL_> lilac: The speed difference between your and my version is in read. My Integer -> String algorithm runs slightly faster than yours. But ideally I'd like an Integer -> Integer algorithm ,since it's cleaner
07:45:24 <byorgey> I seem to recall solving it once upon a time =)
07:45:25 <mauke> hah
07:45:29 <quicksilver> solrize_: a 1-byte-per-character string rep is always going to be faster than a 24-byte-per-character string rep :)
07:45:31 <mauke> I solved PALIN in Perl
07:45:48 <byorgey> I think I solved it in C =)
07:45:59 <mauke> yeah, I also have a C solution
07:46:37 <pejo> quicksilver, read is sometimes exponential: http://portal.acm.org/citation.cfm?id=1411286.1411296
07:47:12 <lilac> FalconNL_: I think I'd do an Integer -> Integer algorithm somewhat differently (not via String)
07:47:59 <quicksilver> pejo: if you're going to paste a link, paste one that I can download from :P
07:48:31 <pejo> quicksilver, ok, let me retry.
07:48:36 <pejo> quicksilver, read is sometimes exponential.
07:48:45 <pejo> quicksilver, :P
07:49:00 <quicksilver> pejo: but, not in the case we are discussing.
07:49:26 <quicksilver> pejo: only in the case of infix constructors, as far as I can tell.
07:49:30 <quicksilver> so, not relevant here.
08:05:49 <mmorrow> i was just looking at the jhc-generated C code for
08:05:50 <mmorrow> fib :: Int -> Int -> [Int]; fib m n = m : fib n (m + n); main = (print . length) (fib 0 1)
08:06:03 <mmorrow> and it's first building the entire list
08:06:12 <mmorrow> then it runs over and finds the length
08:07:04 <mmorrow> (and also, even though it wouldn't matter here, there's no gc)
08:08:11 <mmorrow> and without something like this getting fused in some/any way, there can't be a gc
08:08:42 <mmorrow> (which was why i was looking at the C code in the first place :(
08:08:49 <copumpki> :o
08:11:31 <DarthMeh> given an expression (test1 == test 2),  if I want test1 and test2 to evaluate in parallel with par, how do I express this?
08:11:34 <mmorrow> well, actually i should make sure that it doesn't magically fuse if the list is finite
08:12:24 <koeien> DarthMeh: test1 `par` (test2 `pseq` (test1==test2)) iirc
08:12:38 <DarthMeh> thank you, koeien
08:12:45 <pumpkin> sounds like someone should define liftP2 (==) test1 test2 :P
08:13:01 <koeien> yeah, could be a nice function ;)
08:13:41 <pumpkin> (==) <$$> test1 <||> test2
08:14:02 <pumpkin> maybe?
08:14:04 * pumpkin shrugs
08:17:56 <mmorrow> it doesnt
08:18:02 <pumpkin> ?
08:18:06 <pumpkin> oh, JHC
08:18:10 <mmorrow> oh, about magically fusing
08:18:14 <mmorrow> yeah
08:18:30 <mmorrow> main = (print . length . maxBound) (fib 0 1) -- ;)
08:18:35 <mmorrow> err
08:18:39 <mmorrow> main = (print . length . take maxBound) (fib 0 1) -- ;)
08:20:33 <quicksilver> mmorrow: You lost me. jhc is or isn't fusing?
08:22:27 <b_jonas> hi
08:22:57 <pumpkin> hi indeed!
08:23:10 <b_jonas> can you use the data types a la carte thing to create a product type, say for a state so that you can read or alter any field without having to know what other fields there are?
08:23:14 <zsol> yo
08:23:35 <quicksilver> b_jonas: well it's not a magic solution.
08:23:44 <quicksilver> you can obviously write something which is polymorphic
08:23:50 <quicksilver> you could do that with a normal tuple too:
08:23:58 <quicksilver> (Int,a) -> ....
08:24:05 <quicksilver> ^^ ignores the "other field" a.
08:24:18 <quicksilver> but it remains sensitive to the orders of the fields and stuff.
08:25:08 <roconnor> quicksilver: does that solution use the class system for overloading?
08:25:22 <quicksilver> the solution I just sketched doesn't do any overloading.
08:25:28 <roconnor> ok
08:25:34 <quicksilver> to make something cleverer you would indeed have to use the class system.
08:26:07 <quicksilver> haskell's data types don't support this kind of extension, and data types a la carte isn't changing haskell in any way
08:26:12 <quicksilver> it's just a particular approach.
08:26:31 <quicksilver> (...don't support *polymorphism* over this kind of extension...) I should say
08:26:44 <quicksilver> you can hack up various kinds of extensible record stuffs with type classes
08:26:51 <paper_cc> is there a GMap library done with type families? (gmap-0.1 on Hackage uses FunDeps)
08:26:51 <quicksilver> some of it more clumsy looking than others.
08:27:24 <b_jonas> quicksilver: thanks
08:27:35 <b_jonas> I'll have to read the data types a la carte article again
08:27:45 <b_jonas> because I still don't really understand how it works
08:27:55 <b_jonas> I have another question though
08:28:17 <b_jonas> how do the extensible exceptions in ghc work? is it magic or is there an article about it somewhere?
08:29:14 <quicksilver> b_jonas: it's not magic.
08:29:34 <quicksilver> b_jonas: http://www.haskell.org/~simonmar/papers/ext-exceptions.pdf
08:30:00 <b_jonas> quicksilver: thanks for the link
08:31:37 <mmorrow> awesome. this however jhc runs in constant memory:
08:31:48 <mmorrow> fib m n x k = k x (m::Int) (\x -> fib (n::Int) (m + n) x k);   gogo acc _ k = let acc' = acc + (1::Int) in acc' `seq` k acc';  main = print (fib 0 1 (0::Int) gogo :: Int)
08:32:24 <mmorrow> so it looks like if you just pretend you're programming in a strict language, you're golden ;)
08:34:58 <mmorrow> quicksilver: i'm gonna make a short writeup paste, because that'll be infinitely more clear than me trying to describe the particulars
08:38:46 <quicksilver> mmorrow: OK :)
08:44:43 <mmorrow> hmm, i take back that it's running in constant space, since there doesn't seem to be any use of free() in the entire file, and it's malling malloc 4 times per loop...
08:45:05 <pumpkin> :o
08:45:17 <mmorrow> (i guess the massive eat-all-4GB-of-memory-in-under-a-second with the other program was from stack)
08:46:18 <FalconNL_> lilac: I've posted my solution as well
08:50:04 <Elly> mmorrow: rule 1 of malloc is the same as rule 1 of air travel
08:50:16 <Elly> "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
08:52:28 <weilawei> Elly: that's an awesome way to put it. never heard that analogy before
08:52:51 <Elly> heh, thanks :)
08:53:23 <pumpkin> @remember Elly Rule 1 of malloc is the same as rule 1 of air travel: "Attempt at all costs to keep your number of landings equal to your number of takeoffs."
08:53:23 <lambdabot> I will remember.
08:53:27 <FalconNL_> Alternatively you could say: If you don't land after taking off, you'll crash.
08:55:02 <dmwit> If you land twice after takeoff... you've definitely crashed.
08:58:52 <roconnor> I prefer to only let my planes take off throughout the day.  Then I go home at the end of the day.  In the morning, all my planes have been put back on the ground for me.
08:59:58 <maltem_> As long as you're not going for intercontinental flights.
09:00:27 <roconnor> I'm just running local flights on my laptop
09:03:13 <Gilly> Any particular reason to why Data.Time.Calendar.Day isn't a instance of Read?
09:03:19 <skorpan> i'm trying to write some sort of typechecker using the reader monad...  i've only done this using the state monad before, which apparently is supposed to be more "heavyweight" than necessary.  this is my question: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5128#a5128
09:04:35 <roconnor> skorpan: do you want to stop when you hit an error, or carry on?
09:04:41 <skorpan> roconnor: carry on
09:05:02 <roconnor> skorpan: maybe use Writer and tell the errors to it?
09:05:40 <skorpan> roconnor: that was the idea i had in the beginning, but friends of mine told me that Reader is more suiting for some reasons i don't remember and they're not accessible to ask right now
09:05:59 <skorpan> i think they said that "local" is awesome for some reason
09:06:25 <roconnor> do you need to know what the errors were as you go along?
09:06:35 <skorpan> nope, i don't care about existing errors
09:07:05 <quicksilver> Gilly: it is.
09:07:08 <roconnor> skorpan: definitely not Reader.  "local" will only add information locally.  After you leave the local block it will be gone.
09:07:26 <skorpan> yeah, i know!  i'm glad i'm not the only one not understanding what Reader would be good for :)
09:07:29 <quicksilver> Gilly: but the instance is perhaps not in one of the modules you important.
09:07:35 <quicksilver> Gilly: try Data.Time.Format
09:07:35 <roconnor> skorpan: local would be great if you needed the error report to carry on, but didn't want to report it in the end.
09:07:51 <roconnor> skorpan: but this is exactly the opposite of what you want.
09:08:13 <skorpan> i'll just go for writer and see if that makes my life difficult
09:08:17 <skorpan> thanks for your input
09:08:40 <roconnor> skorpan: use DList in Writer.
09:08:50 <skorpan> for speed?
09:08:52 <roconnor> or CPS your monad stack.
09:08:54 <roconnor> ya
09:09:00 <skorpan> CPS?
09:09:08 <roconnor> continuation passing style
09:09:16 <skorpan> ah, well, i'm not too familiar with that just yet
09:09:33 <roconnor> well
09:09:37 <Gilly> quicksilver: Ahh, thanks :)
09:09:42 <roconnor> you probably don't have too many errors
09:09:50 <roconnor> so maybe using DList isn't that important
09:09:55 <roconnor> you can probably start with list.
09:10:04 <roconnor> hmm
09:11:04 <Jedai> skorpan: local is nice to manage the environment in a functional language interpreter for instance
09:11:37 <skorpan> ah, right, one environment per block?
09:11:39 <mmorrow> quicksilver: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2462
09:11:59 <mmorrow> Elly: hehe
09:12:14 <Jedai> skorpan: Right, of course for your problematic I also fail to see why Reader would help, it seems a typical Writer task
09:26:29 <pumpkin> shh, I'm hunting bunny wabbits
09:27:43 <skorpan> if i'm using "DList a" as the "state" of my Writer, do i have to (tell . singleton) everytime?
09:30:56 <quicksilver> skorpan: yes.
09:31:08 <quicksilver> skorpan: you can give that a name if you like :)
09:31:14 <quicksilver> sktell = tell . singleton
09:31:21 <skorpan> say = tell . D.singleton
09:31:23 <skorpan> :)
09:36:21 <pumpkin> mmorrow: that little chunk of code you wrote for closures in c is like the adjustor in the ghc rts?
09:37:12 <skorpan> @type tell . Data.DList.singleton
09:37:14 <lambdabot> Couldn't find qualified module.
09:37:38 <skorpan> GHC only says it's a -> m () but that's not enough
09:37:43 <skorpan> i can't figure the type out!
09:38:11 <lilac> @index Data.DList
09:38:12 <lambdabot> bzzt
09:38:24 <quicksilver> why isn't that enough?
09:38:41 <quicksilver> singleton has type (a -> DList a)
09:38:56 <skorpan> tell is only for MonadWriter so i have to put that constraint somehow
09:39:11 <quicksilver> ghc should tell you it.
09:39:22 <skorpan> but it doesn't
09:39:29 <quicksilver> MonadWriter (DList a) m => a -> m ()
09:39:33 <quicksilver> skorpan: I don't believe you.
09:39:45 <skorpan> Warning: Definition but no type signature for `say'
09:39:45 <skorpan> Inferred type: say :: a -> m ()
09:39:52 <quicksilver> ask ghci.
09:40:16 <skorpan> that's inconvenient as hell because i haven't installed the package i'm writing this for
09:40:20 <dmwit> And file a RFE against GHC.
09:40:35 <quicksilver> you don't need that package
09:40:38 <quicksilver> you just need DList
09:40:43 <skorpan> hm, true
09:40:43 <dmwit> Wait, ghci does exactly the same things ghc does.
09:40:59 <dmwit> So if ghc can see whatever it is you're using, so can ghci.
09:41:08 <quicksilver> dmwit: it's only the warning message at fault.
09:41:15 <quicksilver> right.
09:41:24 <skorpan> ghci gives me the right result
09:41:26 <quicksilver> you can always run ghci up in the same context ghc is compilng from
09:41:47 <skorpan> listen i'm not *lying* so obviously something strange is going on
09:42:38 <skorpan> could it be that i'm already using the definition of "say" in other functions when i cabal build, which i don't when i check the type in ghci?
09:42:59 <roconnor> @hoogle say
09:43:00 <lambdabot> No results found
09:43:26 <roconnor> @where hayoo
09:43:26 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
09:43:36 <skorpan> say = tell . Data.DList.singleton
09:44:26 <mauke> I get No instance for (MonadWriter (DList a) m) for that line
09:44:55 <roconnor> DList a needs to be a Monoid.
09:45:07 <roconnor> if it isn't the package ought to be changed?
09:45:15 <mauke> it is
09:46:40 <mauke> compiles with FlexibleContexts and (MonadWriter (DList a) m) => a -> m ()
09:47:50 <roconnor> huh?
09:48:08 <roconnor> what about (MonadWriter [a] m) => a -> m ()
09:48:16 <roconnor> does that requires FlexibleContexts?
09:48:19 <mauke> oy
09:48:22 <mauke> owned by MR
09:48:29 <roconnor> that's what I figured
09:48:32 <roconnor> I should have said
09:49:04 <roconnor> monomoprhismRestriction--
09:50:12 <mauke> yes, [a] also requires flexible contexts
09:50:18 <koeien> too long :(
09:50:38 <mauke> MR--
09:51:22 <koeien> monomorphismrestriction.com is still free!
09:51:48 <mauke> preflex: karma MR
09:51:49 <preflex>  MR: -1
09:52:11 <bremner> mutability++
09:52:34 <pumpkin> :o
09:52:42 <roconnor> mauke: I assume that NoMonomoprhismRestriction works instead of FlexibleContexts?
09:52:52 <roconnor> mauke: or eta expending the definition of say.
09:53:10 <roconnor> @burnDown bremner
09:53:10 <lambdabot> Unknown command, try @list
09:53:15 <mauke> eta expanding works if I remove the type signature
09:53:55 <Twey> koeien: Quick!  Let's grab it!
09:53:58 <Twey> *cough*
09:55:21 <koeien> Twey: let's register it to prevent it from being used ;)
09:56:02 <b_jonas> monomorphismRestriction++ I for one like iy
09:56:37 <mauke> BURN HIM
09:59:39 <maltem_> @remember koeien Let's register it [monomorphismrestriction.com] to prevent it from being used ;)
09:59:39 <lambdabot> It is forever etched in my memory.
10:17:21 <mmorrow_> pumpkin: sort of.. it is like that in the sense that it could be used to give something a view as a function pointer, but that code doesn't take any args, but if it did it'd be exactly like that (in purpose, i'm not sure how exactly the adjustor works)
10:18:23 <mmorrow_> pumpkin: but on the other hand, it's pretty much exactly what a suspended function application is represented as by the rts
10:21:32 <skorpan> @pl not . null
10:21:33 <lambdabot> not . null
10:21:44 <skorpan> just checking if there is notNull :P
10:22:33 <pumpkin> @hoogle [a] -> Bool
10:22:34 <lambdabot> Prelude null :: [a] -> Bool
10:22:34 <lambdabot> Data.List null :: [a] -> Bool
10:22:34 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
10:22:42 <skorpan> @pl not . elem
10:22:43 <lambdabot> not . elem
10:22:49 <skorpan> hm...  i thought it was wiser
10:22:58 <Twey> That's already pointfree
10:23:30 <Twey> @pl \x y -> not (elem x y)
10:23:30 <lambdabot> (not .) . elem
10:23:42 <Twey> Hmn
10:24:01 <Twey> @unpl not . null
10:24:01 <lambdabot> (\ c -> not (null c))
10:24:06 <Twey> @unpl not . elem
10:24:06 <lambdabot> (\ c -> not (elem c))
10:24:18 <Twey> That's not very useful
10:24:22 <skorpan> nope!
10:25:40 <roconnor>  @pl just gets rid of lambdas
10:26:10 <roconnor> hmm, maybe that isn't true
10:26:13 <Elly> @pl \x -> x + x
10:26:13 <lambdabot> join (+)
10:26:18 <Elly> :t join
10:26:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:26:21 <roconnor> > flip (flip id)
10:26:22 <lambdabot>       Overlapping instances for Show ((a -> c) -> a -> c)
10:26:22 <lambdabot>        arising from...
10:26:25 <Twey> It does just get rid of lambdas
10:26:27 <roconnor> @pl flip (flip id)
10:26:27 <lambdabot> id
10:26:28 <Elly> what the heck is that
10:26:30 <Twey> But it has some neat tricks for doing so
10:26:38 <Twey> Elly: join on the function monad
10:26:47 <Elly> I didn't know there was a function monad
10:26:53 <Twey> Essentially, it just repeats the argument
10:27:09 <Twey> m here is (-> r)
10:27:16 <roconnor> @djinn (e -> e -> a) -> (e -> a)
10:27:17 <lambdabot> f a b = a b b
10:27:23 <Twey> So, it's :: (a -> a -> r) -> (a -> r)
10:27:33 <Elly> nice
10:27:43 <JuanDaugherty> googling "haskell calculator" returns a half million hits but they all seem to be half assed. Anybody know of a decent one with an X interface?
10:27:46 <Twey> Yeah, there's a function monad
10:28:06 <mauke> JuanDaugherty: why an X interface?
10:28:14 <mauke> I think ghci is an acceptable calculator
10:28:24 <roconnor> JuanDaugherty: half-assed calculators is typically a test case for new GUI development libs.
10:28:29 <Twey> > (length >>= (*2)) [1, 2, 3]
10:28:30 <lambdabot>   Couldn't match expected type `[a] -> b' against inferred type `Int'
10:28:32 <Twey> Boo
10:28:48 <Twey> I can never remember how to use it, but it exists :-P
10:28:58 <roconnor> @let loeb x = fmap ($ loeb x) x
10:28:58 <lambdabot>  Defined.
10:29:04 <Twey> > do { l <- length; return l } [1, 2, 3]
10:29:05 <mauke> needs more fix
10:29:06 <lambdabot>   <no location info>: parse error on input `['
10:29:11 * roconnor thinks ghci is also a fine spreadsheet
10:29:17 <roconnor> > loeb [ (!!5), const 3, liftM2 (+) (!!0) (!!1), (*2) . (!!2), length, const 17]
10:29:18 <lambdabot>   [17,3,20,40,6,17]
10:29:35 <JuanDaugherty> mauke: dunno of you are asking why a gui, or why that gui platform, but um, just because.
10:29:39 <JuanDaugherty> *if
10:29:41 <mauke> why a gui
10:29:55 <mauke> I haven't seen a calculator that was improved by having a GUI
10:30:02 <JuanDaugherty> for the reason gui exists
10:30:09 <Twey> I've never been able to find good information on the (-> r) monad
10:30:16 <Twey> Where does it lurk?
10:30:27 <roconnor> Control.Monad.Instances I beleive
10:30:37 <maltem_> Twey, btw it's ((->) r)
10:30:56 <Twey> roconnor: I meant the information, not the monad
10:31:15 <Twey> Oh, yeah
10:31:15 <roconnor> it's isomorphic to (Reader r)
10:31:18 <Twey> It's (r ->)
10:31:44 <Cale> Good information lurks in the minds of the people of this channel :)
10:32:02 <Cale> Also, it's a good exercise to try writing the instance yourself :)
10:32:23 <Cale> If you get the types to match, it is almost impossible to have the wrong thing.
10:32:24 <roconnor> Cale: actually everyone is a mindless zombie automoton, other than Twey.
10:32:43 <mauke> JuanDaugherty: gui exists to display graphical information and let me click on things
10:32:51 <JuanDaugherty> roconnor: Acknowledged, a decent one (as opposed to a half assed one) developed for that purpose would be fine.
10:33:02 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
10:33:03 <lambdabot>   ("Hello","olleH","HELLO")
10:33:04 <Twey> roconnor: I always knew it :-P
10:33:13 <JuanDaugherty> mauke: yeah that's the ticket, just lemme at it
10:33:15 <zachk> couldnt you use a map
10:33:16 <Twey> Ah, that's the way to do it, is it?
10:33:30 <zachk> omfg that was like 3 days ago forget i ever said that
10:33:31 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
10:33:33 <lambdabot>   [5,7,10,25,32]
10:33:38 <CalJohn> is it possible to parse an integer token with attoparsec?
10:33:39 <Twey> Hahaha, zachk
10:33:40 <b_jonas> I may be mindless but I'm not a zombie
10:33:59 <CalJohn> i'm learning parsec, but I'd like to use bytestrings
10:34:23 <Twey> CalJohn: Get Parsec 3, use Text.Parsec.ByteString
10:34:33 <roconnor> b_jonas: philosophical zombie, not hollywood zombie.
10:36:13 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ChristmasTree -- what a great contrived name for a package :)
10:36:30 <Twey> Hahahaha
10:36:31 <Twey> Nice!
10:37:20 <koeien> lol lol lol
10:37:22 <koeien> very nice
10:37:27 <b_jonas> yeah
10:37:38 <koeien> was that the utrecht thingy?
10:37:41 <koeien> sounds like it
10:37:51 <CalJohn> Twey: ah, wow, did not know
10:38:05 <koeien> home page is cs.uu.nl, yeah apparently :)
10:38:18 <gio123> please heeeeeeeeeeelp I need file amsmath.cls
10:38:27 <CalJohn> koeien: i am attending that utrecht thingy
10:38:41 <mmorrow_> pumpkin: this code though lets you make a closure of a C function and a value, then gives you back a function pointer which when called with another arg will call that original function with both saved arg and the new arg  http://moonpatio.com/repos/cclos.c
10:38:56 <Cale> gio123: That doesn't seem like a Haskell question... isn't that a LaTeX class file?
10:39:01 <b_jonas> it is
10:39:04 <koeien> CalJohn: i mean, i saw a presentation on that in Eindhoven by doaitse swierstra from Utrecht university
10:39:08 <mmorrow_> pumpkin: (only have x86_64 asm though for that thus far)
10:39:25 <koeien> gio123: try google.
10:39:26 <CalJohn> koeien: oh, i was mistaken
10:39:35 <mmorrow_> pumpkin: the thing that sucks about x86 is that you can't do pc-relative references easily
10:39:35 <gio123> Cale: yes
10:39:36 <gio123> :)
10:39:52 <Cale> gio123: I'm pretty sure that it comes with most of the popular distributions of LaTeX...
10:39:53 <koeien> CalJohn: the name (at least, the unabbreviated version) reminded me of that
10:39:58 <b_jonas> mmorrow_: that's not the only think that sucks about x86
10:40:06 <mmorrow_> b_jonas: heh
10:40:15 <b_jonas> I think I sound like a bot
10:40:27 <gio123> Cale: noo, I am compiling the documents and it gives me error that that file can not fond
10:40:28 <b_jonas> I make shallow comments like "yeah" and "um I don't think so" about whatever you say
10:40:43 <Cale> How did you install LaTeX?
10:40:52 <b_jonas> gio123: could you ask on another channel? like #haskell-blah ?
10:41:15 <gio123> Cale: pm
10:41:18 <b_jonas> (I must sound like that again)
10:41:38 <b_jonas> anyway, I decided the magic isn't in extendible exceptions but in Typeable that is uses
10:41:45 <b_jonas> so now I'll have to read how Typeable works
10:42:06 <skorpan> @pl \x y -> not (null x) && not (null y)
10:42:07 <lambdabot> (. (not . null)) . (&&) . not . null
10:42:12 <skorpan> ...right...
10:42:37 <mauke> :t (&&) `on` (not . null)
10:42:37 <kyagrd> Is there a (development) version of TH that can parse GADT declerations?
10:42:38 <lambdabot> forall a. [a] -> [a] -> Bool
10:43:07 <mauke> :t join (liftM2 (&&)) (not . null)
10:43:08 <lambdabot> forall a. [a] -> Bool
10:43:12 <mauke> d'oh
10:43:42 <mmorrow_> pumpkin: (and the best part of that cclos.c code is that it creates a new copy of the code for each closure, so you can have arbitrarily many of them and they won't interfere, no global vars used)
10:52:15 <mmorrow_> kyagrd: unfortunately no
10:56:12 <mxc> (a -> b -> c)
10:56:14 <mxc> oops
10:56:18 <mxc> oops
10:59:29 <lilac> mmorrow_: am i right in thinking that they added rip-relative addressing in x86_64?
11:00:16 <mmorrow_> lilac: yes, it's awesome
11:00:30 <lilac> i imagine it's especially awesome for the authors of virii and trojans
11:00:38 <mmorrow_>   label(%rip)
11:01:06 <lilac> what does the r stand for, anyway? ridiculously-big?
11:01:14 <mmorrow_> lilac: exactly!
11:01:21 <mmorrow_> i dunno
11:01:21 <mauke> VIRII IS NOT A WORD
11:01:49 <mmorrow_> is cactuses a word?
11:02:01 <mauke> it is acceptable
11:02:15 <lilac> > words "virii and trojans"
11:02:16 <lambdabot>   ["virii","and","trojans"]
11:02:22 <lilac> lambdabot disagrees
11:02:23 <deech> Hi all,
11:02:30 <mauke> lilac: no, I disagree!
11:02:43 <lilac> mauke: lambdabot says it's a word, though!
11:02:47 <lilac> > words "virii"
11:02:48 <lambdabot>   ["virii"]
11:03:02 <mauke> > words "`__)"
11:03:03 <lambdabot>   ["`__)"]
11:03:10 <mmorrow_> mauke: heh, i actually just had to lookup the plural of cactus and it's "cacti" with only one i (or cactuses)
11:03:10 <inimino> @faq can Haskell solve disputes over English?
11:03:11 <lambdabot> The answer is: Yes! Haskell can do that.
11:03:38 <inimino> good to know
11:03:39 <mauke> there is no "-ii" suffix in latin
11:03:41 <mmorrow_> mauke: so i guess it's different a thing altogether
11:03:45 <mmorrow_> oh
11:03:51 <mmorrow_> is there an -i ?
11:03:57 <mauke> yes, several
11:04:02 <lilac> @faq Can Haskell pose a polynomial-time-checkable problem so hard even Haskell cannot solve it in polynomial time?
11:04:03 <lambdabot> The answer is: Yes! Haskell can do that.
11:04:09 <deech> I'm trying to use Network.HTTP to browse a web address, but I want to handle the case when the network isn't available. I am currently getting a GHCI error in my handler function. The code is at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5129#a5129. Appreciate your input.
11:04:14 <lilac> wow. P != NP. you heard it here first.
11:04:24 <mauke> "sons" is filii because a single son is filius
11:05:11 <lilac> mauke: i envy how much you care about this :)
11:05:34 <mauke> guess what I have in my highlight list
11:05:46 <inimino> *ii ?
11:05:52 <mmorrow_> hahah
11:05:53 <mauke> no, "virii"
11:06:12 <mauke> but don't worry, it's not an automatic /kick
11:06:16 <mauke> (yet)
11:06:29 <lilac> mauke: was this whole response merely a script in your IRC client playing itself out?
11:06:31 <da-x> @faq Can Haskell explain what happens on Lost?
11:06:31 <lambdabot> The answer is: Yes! Haskell can do that.
11:06:38 * inimino is glad mauke is on the case
11:06:40 <inimino> some one has to defend Latin or it might die out!
11:06:41 <mauke> lilac: haha, no :-)
11:07:22 <lilac> inimino: latin is clearly actively maintained. iso latin15 didn't come out that long ago
11:08:16 <mmorrow_> i wonder if there's a -fii-suffixii-allowed flag
11:08:33 <lilac> sufficii, surely? ;-)
11:08:47 <mauke> suffixen
11:09:39 <lilac> mauke: hold on, you have virii in your highlight list? you're actively /hunting/ people who are wrong on the internets?
11:09:43 * inimino waits for someone to write Haskelligata, translating the entire type system into suffixes
11:09:59 <mauke> lilac: precisely
11:10:17 * lilac waits for someone to paste an xkcd link
11:10:37 <mauke> god help you if I catch you using "could care less"
11:11:29 <mmorrow_> ha
11:11:35 <Twey> ‚ÄòVirii‚Äô is a word ‚Äî it means ‚Äòmales‚Äô
11:11:44 <Twey> mauke: *shudder*
11:11:44 <lilac> mauke: i'm with you on that
11:11:51 <mauke> Twey: no, that's viri
11:11:58 <lilac> virii is the plural of virium
11:11:59 <mauke> men
11:11:59 <Twey> mauke: It's virƒ´
11:12:09 <lilac> which is a word i made up
11:12:13 <mauke> lilac: no, that would be viria
11:12:19 * JuanDaugherty concludes that the character set socalled "ISO-LATIN-15" has little or nothing to do with the Latin language (besides the obvious)
11:12:23 <lilac> mauke: virius?
11:12:27 <mauke> visum -> visa, etc
11:12:32 <mauke> lilac: yes
11:12:35 <Twey> The double-for-long-vowel convention was created by Accius
11:13:09 <Twey> JuanDaugherty: Yeah ‚Äî it has weird characters in it like ‚ÄòU‚Äô and ‚ÄòW‚Äô
11:13:57 <mauke> I thought it was called ISO 8859-15
11:14:21 <lilac> mauke: Virius was a Roman first name. When referring to multiple people with this first name, is 'Virii' not appropriate?
11:14:21 <JuanDaugherty> a "real" Latin set might have for example have had Claudius' characters
11:14:51 <mauke> lilac: do you have a reference for that?
11:15:30 <b_jonas> JuanDaugherty: is that the half H and turned C thing?
11:15:36 <JuanDaugherty> y
11:15:51 <centrinia> Which declension does "Virius" fall under?
11:16:00 <mauke> tee hee
11:16:06 <b_jonas> what I don't get is, why did they bother with introducing G as a variant form of C when they already had K and Q as extra letter Cs
11:16:07 <mauke> Viri≈´s
11:16:49 <b_jonas> I mean, the greeks used to have two letters for K as well, why do they have to repeat their mistake?
11:17:09 <mauke> what was the other greek K?
11:17:26 <b_jonas> English spelling still sucks because of the Latin's bad decisions
11:17:53 <centrinia> varkappa?
11:18:24 <b_jonas> no, Qoppa
11:18:43 <b_jonas> it fell into disuse because the greeks did realize it was redundant
11:18:49 <centrinia> That looks more like a 'Q'
11:19:08 * mauke faintly remembers things called "koppa" and "stigma"
11:19:58 <Twey> centrinia: ‚ÄòVirius‚Äô looks 2m
11:20:31 <centrinia> Second declension masculine?
11:20:42 <abbe> http://xkcd.com/587/
11:21:56 <Twey> centrinia: Yeah
11:22:49 <centrinia> That would look like Viriƒ´
11:23:14 <b_jonas> if we could get people to use a writing that corresponds to phonetic once, then maybe phonetics wouldn't change much after that and then we wouldn't have all the historical accidents that caused us to use writings deviating from phonetics in first place
11:23:37 <b_jonas> especially now in the age of global communication
11:23:43 <mauke> and next week: "i.e." vs. "e.g."
11:24:11 <b_jonas> because I can sort of understand how the geographic distances could have caused the problems in the ancient times
11:27:32 <Twey> centrinia: The Romans rarely marked long vowels
11:29:15 <centrinia> If zombies can only eat two brains and turn their victims into zombies; and you start out with one zombie, then shouldn't the n-th generation of brain eating victims have F_n members?
11:30:44 <b_jonas> no
11:31:04 <centrinia> Why not?
11:31:12 <lilac> mauke: virius lupus was some famous roman dude
11:31:14 <b_jonas> there'd be 2^n
11:31:21 <Cale> 2^n - 1
11:31:59 <b_jonas> Cale: no, "the n-th generation of brain eating victims" doesn't include earlier ones I think
11:32:15 <Cale> oh, if that's the case, then yes
11:32:29 <tromp> :t showOct
11:32:30 <lambdabot> forall a. (Integral a) => a -> String -> String
11:32:30 <b_jonas> well, either can be a plausible interpretation
11:32:37 <b_jonas> after all, zombies don't die
11:32:44 <b_jonas> they can only be destroyed
11:32:48 <tromp> > showOct  797 ""
11:32:49 <lambdabot>   "1435"
11:32:50 <Cale> I thought it was talking about the total zombie population :)
11:33:02 <centrinia> What if the zombie can only eat one brain during one generation?
11:33:26 <b_jonas> centrinia: that would be a strange definition of "generation"
11:33:29 <Cale> centrinia: But they keep earing?
11:33:32 <Cale> eat*
11:33:46 <centrinia> They go back to the grave after eating two brains.
11:34:08 <lizrail> Hi, can anybody explain, what's the reason for this error in ghci: Loading package HTTP-4000.0.6 ... linking ... <interactive>: /usr/lib64/http-4000.0.6/ghc-6.10.1/HSHTTP-4000.0.6.o: unknown symbol `networkzm2zi2zi1_NetworkziURI_uri_closure'
11:34:08 <lizrail> ghc: unable to load package `HTTP-4000.0.6'
11:34:51 <voker57_> version mismatch in network
11:35:06 <mauke> preflex: zdec networkzm2zi2zi1_NetworkziURI_uri_closure
11:35:06 <preflex>  network-2.2.1_Network.URI_uri_closure
11:35:07 <Cale> lizrail: hmm, my first thought was "you're not compiling with --make" but since you got it in GHCi, it's probably a version mismatch like voker57_ says :)
11:35:33 <lizrail> mismatch  between what and what? I tried rebuild network and http
11:35:55 <Cale> lizrail: hmm...
11:36:00 <centrinia> So zombie a_{0,0} eats the brain of zombie a_{1,0}; zombie a_{0,0} and zombie a_{1,0} eat the brains of zombies a_{2,0} and a_{2,1}; zombie a_{1,0}, zombie a_{2,0}, and zombie a_{2,1} eat the brains of zombie a_{3,0}, a_{3,1}, and a_{3,2}
11:37:18 <tromp> > showOct  410 ""
11:37:19 <lambdabot>   "632"
11:37:48 <lizrail> Cale, I get this when trying to compile: http://pastebin.com/m165ce497
11:37:53 <tromp> > showOct  1024 ""
11:37:55 <lambdabot>   "2000"
11:38:51 <Cale> lizrail: Yeah, it's got to be something strange with either network or http... I'm not sure what though, I've never run into that before.
11:40:11 <skorpan> @type when
11:40:12 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:40:19 <Cale> centrinia: The number of freshly bitten zombies on a given turn is the sum of the freshly bitten zombies from the previous two generations. So that's Fibonacci-ish...
11:41:10 <lizrail> Cale, what can be done to investigate the problem?
11:41:31 <tetha> mm, I remember that there is a simulator of a zombie outbreak in a building somewhere
11:43:30 <Cale> lizrail: Let's start with  ghc-pkg list network
11:44:03 <Cale> Is there more than one entry? You should have a network package that came with your ghc installation most likely.
11:44:13 <Cale> But there might also be a locally installed one?
11:44:35 <Cale> I'm running 6.10.3 at the moment, so I'm not sure what version is appropriate.
11:44:40 <lizrail> Cale, http://pastebin.com/d460e5836
11:45:07 <Cale> Oh, interesting, so there are two of them which are the same...
11:46:01 <Cale> Maybe try uninstalling that local version of network:  ghc-pkg --user unregister network
11:46:02 <lizrail> Cale, I believe it because at first I built one as user with cabal and later second was installed from haskell overlay
11:46:40 <lizrail> Cale, all fixed!
11:46:47 <lizrail> thanks
11:46:57 <Cale> Ah, that solved it? Nice :)
11:47:45 <lizrail> still I'm puzzled how to prevent similar issues in the future..
11:48:11 <lizrail> by not using --user with cabal?
11:48:13 <Cale> Well, a good rule of thumb is not to use cabal to install packages that normally come with ghc. It's not ideal...
11:48:35 <lizrail> Cale, but what if I want to update them?
11:48:57 <lizrail> or some other package wants more recent version?
11:49:19 <Cale> Usually if a package wants a newer version of one of those, it's meant to be built with a newer GHC anyway.
11:49:46 <lizrail> )
11:49:51 <Cale> I think that normally it's okay to have multiple versions of a package installed though
11:50:07 <Cale> I think it may have got confused by the fact that they were the same version.
11:50:53 <Cale> dcoutts would know more about this than I do
11:51:23 <Cale> (He wrote much of Cabal and is really familiar with the package system)
11:51:35 <eivuokko> It should be possible to link package with same name, but different versions, currently.
11:51:36 <lizrail> yes, though I remember I runned into troubles in the past then two versions of package was used by two different packages in one program
11:52:03 <eivuokko> The types between the different versions are never compatible in type system.
11:52:34 <Cale> We have some annoying dependency problems like that in some of the packages on Hackage. Particularly stupid issues like packages demanding different versions of QuickCheck.
11:52:42 <Cale> (Even though they only use it for testing)
11:53:10 <eivuokko> I think that is also related to how cabal tries to optimise the dependencies?
11:53:29 <Cale> Possibly. I seem to recall that installing them one by one separately helps.
11:54:11 <eivuokko> Yeah, basically Cabal optimises dependencies on general case (not ghc), which means you can't have Qc<2.0 and Qc>=2.0 at one time in dependency solver.
11:54:22 <eivuokko> Or did last I read it, but that's a while ago.
11:55:18 <lizrail> deleting .cabal and rebuilding nessesary packages helped me one time
11:55:26 <Cale> I've also had the dependency solver make bad decisions about which version to install, like it would inexplicably pick a really old version of something to download and install.
11:55:47 <Cale> But if you asked for the deps separately, it was fine.
11:55:53 <eivuokko> Hmmm.
11:56:02 <eivuokko> That sounds like a bug in SAT solver thingy...
11:56:17 <mreh> conal: is your webiste good material to read for game programing?
11:56:28 <mreh> "Simply efficiennt functional reactivity"
11:56:58 <Cale> mreh: Yes, but only if you're prepared to write your game in a new and somewhat experimental way :)
11:57:27 <Cale> mreh: After playing around with Reactive, I'm pretty convinced that something like it is the future of game programming.
11:57:37 <conal> mreh: i agree with Cale, though he may be being too generous.
11:57:37 <lambdabot> conal: You have 4 new messages. '/msg lambdabot @messages' to read them.
11:57:52 <conal> Cale:  :) !
11:57:57 <Cale> mreh: But the current implementation still has some bugs which make it a bit hard to use practically...
11:58:15 <conal> mreh: games definitely fit into what i want Reactive to support well.
11:58:31 <lizrail> Cale, please, give a link )
11:58:32 <conal> yeah.  what Cale said.
11:58:50 <conal> the programming model needs work, also.
12:00:02 <conal> so far, FRP doesn't handle input in a composable way.
12:00:03 <skorpan> if i have a bunch of type constructors for the same type, e.g. data A t = A t t | B t t t | C t, and i want to be able to access the first parameter for each constructor, is there any generic way of doing this?  i don't mind e.g. TH?
12:00:06 <Cale> lizrail: To conal's blog? http://conal.net/blog/
12:00:26 <FunctorSalad> skorpan: gmapQi
12:00:28 <Cale> lizrail: The best introductory articles are quite a ways back now though...
12:00:44 <skorpan> FunctorSalad: i for index?
12:00:46 <conal> the paper "genuinely functional user interfaces" set a direction for FRP with composable input, but it wasn't very much pursued.  yampa got to a bit of it.
12:00:49 <mreh> conal: i'll skip it
12:00:59 <mreh> but I am looking for interesting projects
12:01:19 <conal> mreh: sure.  it'll give you more enlightenment than anything at this point.
12:01:25 <FunctorSalad> skorpan: yes. head/gmapQ is fine too of course
12:01:57 <lizrail> Cale, thanks, lots of promising titles. I must go now. Bye.
12:01:59 <skorpan> i'd like some head...
12:02:16 <FunctorSalad> skorpan: although I'm not sure syb can deal with this kind of polymorphism :(
12:02:18 <mreh> im doing machine learning next year, FP should make it a whole lot easier
12:02:39 <FunctorSalad> you can make "A" an instance of Typeable1
12:02:50 <skorpan> this should be fairly easy with TH though, right?
12:03:04 <FunctorSalad> (but I'm not sure what the predicate to gmapQ should look like)
12:03:09 <skorpan> sad thing is i know virtually no TH myself
12:03:09 <FunctorSalad> skorpan: yeah, use "reify"
12:03:23 <FunctorSalad> then extract the constructors from the info
12:03:54 <skorpan> could you help me with that?  :/  sorry if i'm asking too much of you!
12:05:07 <mreh> I like conals
12:05:13 <mreh> 's website
12:05:24 <mreh> "The goal of my new research agenda is to give artists access to the expressive power of computers"
12:06:06 <conal> mreh: thx.  i better re-read that sentence regularly so i don't forget!
12:06:33 <conal> i still get regularly wrapped up in type theory, denotational semantics, etc.
12:08:16 <Cale> Did you ever figure out what was going on with the integral equation problem?
12:08:28 <solrize_> i really like .lhs.  i write much more heavily commented code just from not having to type "--" on every line.
12:09:44 <mreh> what dat?
12:10:26 <Cale> mreh: hm?
12:10:31 <Cale> lhs?
12:10:35 <b_jonas> {- haskell has long comments -}
12:10:38 <b_jonas> Cale: literal hs
12:10:44 <wli> What kind of integral equation?
12:10:48 <b_jonas> it has that file extension
12:10:55 <Cale> b_jonas: I know, I was asking what mreh was asking about.
12:10:57 <glguy> its a great way to fill your source code with pages of outdated comments :)
12:11:06 <mreh> Cale: I was asking what .lhs is
12:11:17 <b_jonas> oh
12:11:24 <solrize_> b_jonas yeah, but that still feels like writing comments that are interspersed into code.  .lhs feels like writing text with code interspersed into it.
12:11:38 <solrize_> and i want to start using lhs2latex
12:11:39 <glguy> mreh: instead of surrounding your comments with delimiters, you surround your code with them
12:11:45 <glguy> > code goes here
12:11:46 <lambdabot>   Not in scope: `code'Not in scope: `goes'Not in scope: `here'
12:11:49 <b_jonas> well I don't really like literate programming
12:12:01 <b_jonas> I don't write many comments either
12:12:07 <FunctorSalad> skorpan: rough outline... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5130#a5130
12:12:09 <b_jonas> sometimes I do write some comments of course
12:12:20 <burp_> wtf, > in front of each code line?
12:12:25 <burp_> how mad is that
12:12:27 <Cale> mreh: It's Literate Haskell. It makes commenting the default, and there are two styles of it. The first requires that each code line begins with "> " and the second puts code in between \begin{code} and \end{code}
12:12:32 <Vq^> burp_: thats the idea
12:12:45 <Cale> It's quite nice actually.
12:13:05 <FunctorSalad> skorpan: reference for the abstract syntax tree..... http://hackage.haskell.org/packages/archive/template-haskell/2.3.0.1/doc/html/Language-Haskell-TH-Syntax.html
12:13:12 <Cale> wli: Anything recursive.
12:13:25 <FunctorSalad> (there are lower-case versions of all these constructors, which operate on values in the Q monad)
12:13:25 <Vq^> burp_: consider the situation when you have a lot more documentation than actual sourcecode
12:13:46 <burp_> ok
12:13:49 <MyCatVerbs> The bird notation ("> " at the start of every line) is used on a lot of Haskell blogs so that one can just copy and paste their posts into a file, stick .lhs on the end of it and compile.
12:13:56 <Cale> wli: But in my case, it was the integral equations for describing the position of an object in terms of its acceleration and velocity, when it had a drag acceleration dependent on the velocity.
12:14:09 <b_jonas> Vq^: then I have some readme files or pod files or whatever files that only have docs, no code
12:14:13 <b_jonas> no problem
12:14:20 <Vq^> burp_: or when you want the .lhs file to be a valid file of some other ascii based format
12:14:32 <MyCatVerbs> The \begin{code} and \end{code} notation is for when you want to produce a single file which compiles both as a Haskell module and also as a TeX document. ^_^
12:14:50 <Vq^> b_jonas: but then if you want to show the sourcecode in those documents you will have to duplicate the information
12:15:18 <Vq^> b_jonas: which is a possible source of errors
12:16:11 <FunctorSalad> what if I have \end{code} in a literal?
12:16:36 <FunctorSalad> escaping is so evil
12:17:17 <MyCatVerbs> FunctorSalad: the parser's really conservative. It needs to be on a line by itself.
12:17:28 <FunctorSalad> :)
12:17:56 <Cale>     * Program code begins on the first line following a line that begins \begin{code}.
12:17:56 <Cale>     * Program code ends just before a subsequent line that begins \end{code} (ignoring string literals, of course).
12:19:48 <FunctorSalad> it just reminded me of one situation where apostrophes in comments in javascript in html made the rest of the file be interpreted as a string literal...
12:20:35 <FunctorSalad> (thought I could get away with just skipping the javascript by recognizing html comment tokens)
12:21:17 <decaf> a scripting language in a markup language. typing both in another language
12:21:33 <decaf> this is crazy. doesn't matter how many people does this
12:23:00 <Cale> The part about it being embedded is not nearly as bad as how poorly designed the standards surrounding web development are in the first place.
12:24:06 <Cale> I mean, just look at CSS. It's a gigantic, way over-complicated language with essentially no means of abstraction, and it's nearly impossible to implement correctly.
12:24:29 <SamB> Cale: bad as in there isn't enough (or equivalently there is too much) that's standard, or bad as in what's standard is bad ?
12:24:32 <Raevel> i agree with this statement
12:24:52 <SamB> oh, okay, what's standard is bad ...
12:24:54 <FunctorSalad> Cale: I mean, if it wasn't embedded you'd handle javascript comments. but if you just have an html parser with a longest-match lexer which recognizes single-quoted strings but not javascript comments...
12:24:59 <Cale> Or XML. Maybe the basic XML standard doesn't seem too complicated, but then you realise that it's just a syntax for trees.
12:25:02 <SamB> yeah, CSS really should have means of abstraction
12:25:22 <b_jonas> what? css lambdas?
12:25:24 <b_jonas> no way
12:25:26 <Cale> It should be *at most* one page of text.
12:25:38 <b_jonas> web should be just text with some italic and links
12:26:00 <FunctorSalad> css multiparamtypeclasses
12:26:06 <b_jonas> not this contentless stuff where people work much more on "design" than content
12:26:08 <MyCatVerbs> Cale: to be fair, a description of any sane DTD checker ought to be about two pages long.
12:26:19 <SamB> no, but being able to declare abbreviations for parts of CSS selectors ...
12:26:35 <SamB> Cale: even JSON isn't just 1 page of text ...
12:26:40 <MyCatVerbs> Cale: (or twenty lines, if your "specification" is actually a Prolog program. :)
12:26:41 <SamB> and that's short + sweet!
12:26:57 <SamB> (it might be 2 or 3, with the neato syntax diagrams ...)
12:26:58 <Cale> I think that CSS should have a simple set of composable primitives and a good enough means of abstraction that all the fancy stuff about padding and margins and so on are implementable in libraries.
12:27:09 <conal> if we started over with CSS, with the measuring-stick of simple, sufficient, & precise (denotational) semantics, i wonder what we could come up with.
12:27:26 <b_jonas> I disagree
12:27:33 <SamB> (or note that DSSSL actually HAS lambdas ;-P)
12:27:34 <conal> with looking or working like CSS being a complete non-goal
12:27:49 <SamB> Cale: that sounds kinda messed-up
12:27:52 <b_jonas> because the web designers shouldn't try to force that much precise semantics of showing to us
12:28:03 <conal> DSSSL was scheme-based but imperative, right?
12:28:07 <b_jonas> whereas giving just the primitives and implementing all stuff on that would mean that
12:28:12 <MyCatVerbs> SamB: JSON is five pages, of which only maybe three and a half are actual spec text.
12:28:15 <b_jonas> it would be just another postscript
12:28:25 <b_jonas> where the document's writer can embed fonts and stuff
12:28:25 <SamB> Cale: I don't think presentor authors would like your idea ...
12:28:52 <Cale> SamB: The idea being that the primitives are dead-simple to implement and so implementations wouldn't be so incompatible.
12:28:55 <MyCatVerbs> Cale: that sounds like LaTeX with hyperlinks.
12:29:06 <SamB> MyCatVerbs: you do mean the content of http://json.org/, yes ?
12:29:07 <b_jonas> Cale: but I'd like them to be incompatible
12:29:14 <b_jonas> MyCatVerbs: postscript, yeah
12:29:17 <FunctorSalad> I think there should be no way to have a column which just horizontally truncates the text if you use a larger font size.... ;o
12:29:18 <SamB> Cale: they aren't!
12:29:23 <b_jonas> Cale: I'd like to be able to just use a text browser
12:29:35 <b_jonas> I did actually use a text browser for quite a long time
12:29:38 <SamB> Cale: they can't be
12:29:40 <MyCatVerbs> SamB: http://www.ietf.org/rfc/rfc4627.txt <- ten page document, five pages of which are spec, three and a half of which are JSON's spec rather than just the MIME type and what have you.
12:29:54 <SamB> at least, not without far-overconstraining the front-ends
12:30:03 <SamB> MyCatVerbs: oh, I was talking about the front page
12:30:09 <SamB> MyCatVerbs: seemed spec enough for me
12:30:18 <skorpan> GHC sure knows how to utilise that RAM...
12:30:23 <b_jonas> plus, webpages should be easy to show
12:30:23 <conal> Cale: interested in redoing html & css iswim-style?
12:30:24 <Cale> SamB: They're drastically incompatible. There are things like some browsers treating some measurements as twice that of other browsers, and it requires lots of hackery to work around.
12:30:37 <b_jonas> I don't want everything to be rendered with seven layers of javascript
12:30:39 <SamB> Cale: yes, that's bad
12:30:50 <SamB> but you have to remember links
12:30:52 <b_jonas> I want to be able to view a webpage on a dead slow 386 with no memory
12:30:53 <conal> Cale: where iswim == haskell (without IO)
12:31:00 <SamB> that is, the browser named "links"
12:31:24 <MyCatVerbs> SamB: that *is* just one or two pages long, if you cut out the huge diagrams and put the EBNF in a margin on one side. ^^
12:31:39 <b_jonas> I hate the web
12:31:46 <SamB> MyCatVerbs: well, I did mention that the diagrams were part of that
12:31:49 <Cale> conal: Yeah. Actually I think for CSS, a declarative constraint-based system is probably the way to go.
12:32:02 <SamB> I was just arguing that Cale's "1 page" figure was far too low
12:32:05 <conal> Cale: sounds like a natural.
12:32:12 <Cale> SamB: for XML
12:32:31 <Cale> SamB: XML could be replaced with S-expressions for the most part.
12:32:44 <SamB> Cale: that's basically what JSON is ...
12:33:04 <SamB> So, I think "3 pages", or "10 pages for the official RFC" would be more reasonable
12:33:08 <Cale> I don't see what JSON has to do with it.
12:33:43 <SamB> Cale: it was the technology with the shortest spec that I could think of
12:33:56 <b_jonas> my problem with both json and xml and all the related stuff is that they don't have a way to represent embedded binary data. binary, not characters. all you can do is base64 encode or put it in as latin-1 text (that doesn't work in xml) or something like that.
12:34:19 <b_jonas> I want a serialization format that has both a byte strings and a character string data type.
12:34:40 <MyCatVerbs> SamB: no, JSON is specifying a serialisation format for hash tables or association lists from strings to JSON objects.
12:35:04 <MyCatVerbs> S-expressions are one notch simpler again. :)
12:35:10 <SamB> well, keeping in mind that XML is supposed to be something a bit like SGML ...
12:35:17 <b_jonas> s-expressions suck
12:35:18 <SamB> how short could the spec reasonably get ?
12:35:30 <MyCatVerbs> Yes. That's pretty much the problem.
12:35:32 <SamB> I mean, it could be a heck of a lot shorter then it IS
12:35:43 <MyCatVerbs> What on Earth was who thinking by starting out from SGML?
12:35:53 <p_l> b_jonas: EBML? Though it's binary format
12:35:54 <SamB> MyCatVerbs: good question
12:35:57 <conal> b_jonas: i'm with you about including binary data.  i'd like to make that change to haskell as well.
12:36:09 <conal> after all, haskell is a data serialization format.
12:36:11 <MyCatVerbs> Didn't the scarcity of fullblown SGML parsers tell them anything? oO
12:36:13 <SamB> but once they had people used to HTML ... what could they do ?
12:36:27 <skorpan> i did "darcs amend-record" and hit "y"...  i wanted to change the patch description, but now i can't seem to do that.  what now?
12:36:33 <SamB> MyCatVerbs: eventually!
12:36:46 <SamB> it eventually told them to simply it to XML ...
12:36:53 <MyCatVerbs> SamB: that's TBL's fault for making HTML an SGML grammar instead of something sane.
12:37:07 <SamB> s/simply/simplify/
12:37:57 <conal> in haskell, lack of binary literals is especially painful, since the usual alternative is to use IO.
12:38:13 <SamB> what would binary literals look like, though ?
12:38:29 <conal> SamB: yeah!  that's a great place to start.
12:39:09 <SamB> I don't see how binary literals are a good idea, because it seems to me that they would look extremely ugly in a text editor ...
12:39:10 <thetallguy1> conal: can't you get around that easily enough with TH?
12:39:13 <SamB> and also how would they end ?
12:39:27 <conal> thetallguy1: i don't know.  maybe so!
12:39:34 <p_l> For binary format, EBML looks nice - it's basically tagged binary data, so you can define tags for types and then just dump it :D
12:39:41 <b_jonas> SamB: I think they'd look like 3q/abc/ where q means "quote", followed by data between matching delimiter characters, and the number means to always interpret at least that many bytes literally, even if the delimiter occurs in there
12:39:43 <Cale> Mathematica has image and UI control literals :)
12:40:30 <conal> Cale: cool.  they're not afraid to move past old assumptions about terminal/ascii centered environments.
12:40:34 <SamB> Cale: hmm ... but you don't generally look at the mathematica files in a text editor
12:40:36 <thetallguy1> conal: that is, use an encoding of the data and a decoding function and run it at compile time.
12:40:41 <Cale> SamB: right.
12:40:45 <SamB> I mean, I've done it
12:40:51 <SamB> but it's not the usual way to edit them
12:40:54 <Cale> SamB: You use the notebook editor. :)
12:41:13 <conal> thetallguy1: it's a start.  then i'd want a modern editing interface, like mathematica's
12:41:24 <thetallguy1> conal: aye.
12:41:36 <SamB> and I don't even remember quite how it stores the data
12:41:44 <b_jonas> conal: I wouldn't
12:41:47 <thetallguy1> conal: oddly, I'm kind of working on that at the moment.
12:42:00 <SamB> mathematica's editing interface needs work :-(
12:42:04 <b_jonas> conal: I'd like to be able to use one single effing plain text editor of my choice to edit anything
12:42:05 <conal> thetallguy1: how long will language design cling to the teletype model?
12:42:07 <SamB> I wouldn't want to use that for actual programming
12:42:12 <b_jonas> including haskell or config files or whatever
12:42:21 <SamB> I mean, not for an extendend period of time
12:42:23 <b_jonas> okay, I guess you all want me to shut up now so I'll go
12:42:32 <thetallguy1> conal: probably until I write that blog entry...
12:42:38 <roconnor> Cale: can we remove teletype IO from hasCale?
12:42:39 <conal> b_jonas: cya
12:42:55 <SamB> > putStrLn "hi!"
12:42:56 <lambdabot>   <IO ()>
12:43:10 <SamB> roconnor: it doesn't seem to support teletype ... only IRC!
12:43:17 <roconnor> :D
12:43:36 <FunctorSalad> skorpan: hmm did my hpaste get through?
12:44:00 <skorpan> FunctorSalad: yes, sorry, i forgot to thank you
12:44:11 <skorpan> FunctorSalad: however, i think this is way over my head atm, but i really appreciate it
12:44:19 <SamB> Cale: so, are you going to show us your version of XML in 1 or 2 pages ?
12:44:24 <mreh> how do i set my classpath in ghc
12:44:32 <mreh> or for ghc
12:44:43 <skorpan> mreh: classpath?  you mean where it looks for modules?  "-i" i think
12:44:44 <mreh> not "in ghc", that's not what i want
12:44:53 <SamB> mreh: well, first you need Jyhc or something ...
12:44:59 <mreh> skorpan: yeah, good
12:45:06 <mreh> I'm not using Java
12:45:13 <conal> thetallguy1: the literal concrete syntax i have in mind is, e.g., images.  for numbers, we use a picture of numbers (i.e., numerals).  so the same for other data types.
12:45:21 <mreh> >:(
12:45:25 * SamB makes up a plausible-sounding name for a Java-"ehanced" Haskell compiler
12:45:30 <Cale> http://cale.yi.org/share/Screenshot-Mathematica.png -- :)
12:45:45 * SamB couldn't help but think of Jython when mreh mentioned classpath ...
12:45:59 <conal> Cale: yeah.  that's what i'm talking about!
12:46:04 <FunctorSalad> (sorry for possible double post) skorpan: hmm did my hpaste get through?
12:46:10 <skorpan> FunctorSalad: yes, sorry, i forgot to thank you
12:46:12 <byorgey> Cale: heh, awesome =)
12:46:12 <conal> Cale: that's so great!
12:46:12 <skorpan> FunctorSalad: however, i think this is way over my head atm, but i really appreciate it
12:46:29 <Cale> You can even rotate the cubes in-place. They're 3D.
12:46:51 <conal> Cale: can you use a *rotating* cube as a variable name?
12:47:03 <FunctorSalad> skorpan: I see. yeah it's a lot of types for the haskell AST, but they're pretty intuitive (they correspond to haskell syntax after all :))
12:47:07 <Cale> Hmm, good question. Probably.
12:47:12 <conal> Cale: in other words give syntax extents in time as well as in space.
12:47:35 <conal> now we're talking!  bye-bye 20th century.
12:47:39 <Cale> It's just applying algebraic rules, so I think any valid mathematica expression will work there in the same way.
12:47:46 <skorpan> FunctorSalad: when i asked about doing it with TH i would have expected something in the lines of $([t|something])...  (as i said, i don't know any TH...!)
12:48:05 * roconnor develops the 4-day simulatenous rotating time cube calculus
12:48:10 <Cale> However, this is also kind of silly in that it's very much untyped.
12:48:24 <conal> Cale: though could be.
12:48:32 <conal> Cale: could be typed, that is.
12:48:43 <mreh> what exactly does cabal do when I install a module?
12:48:59 <roconnor> mreh: runs ghc-pkg
12:49:14 <Cale> Yes, to a fair extent it could. You'd actually probably want to forbid this particular usage though.
12:49:16 <conal> we use a few standard glyphs in our math/programs.  but it turns out that math generalizes to differently-shaped glyphs as well.
12:49:47 <Cale> (but I'm not sure)
12:50:04 <Cale> It's not like they're variable names, they behave like constants.
12:50:26 <Cale> Or indeterminates.
12:50:30 <conal> Cale: i know.  mathematica is funny.
12:50:59 <conal> Cale: i'd only want to emulate *some* aspects of mathematica.
12:51:54 <b_jonas> rocconor: yeah, just append "calculus" to anything and it sounds much cooler than it is
12:52:15 <skorpan> lambda calculus calculus
12:52:39 <b_jonas> I think I'll invent cleaning calculus and thus get janitorial work more interesting
12:52:39 <FunctorSalad> b_jonas: it's especially odd considering "calculus" just means "little rock" iirc
12:52:44 * wli got stopped cold in his symbolic affairs by polynomial factorization (or otherwise simplifying nested radicals).
12:52:52 <FunctorSalad> (from little rocks used as calculation aids)
12:53:16 <Cale> calcium has the same root
12:53:22 <b_jonas> wli: I tried writing a haskell program to calculate with nested square roots
12:53:33 <b_jonas> not nested arbitary radicals thoughs
12:53:43 <conal> oh.  the conversation a few minutes ago about non-ascii (multi-media) literals and text editors reminds me of michael mossey's haskell-cafe thread on "design by negation".
12:53:56 <conal> http://www.nabble.com/the-problem-of-design-by-negation-td23645054.html
12:54:00 <SamB> conal: that sounds insane
12:54:27 <conal> insane works.
12:54:49 <conal> "And those who were seen dancing were thought to be insane by those who could not hear the music." - Nietzsche
12:55:06 <conal> maybe a little insane is necessary for progress.
12:55:34 <SamB> I meant "design by negation" conjured up insane-sounding ideas in my head
12:55:50 <conal> SamB: oh!  thx for clarifying.  i missed your meaning.
12:56:00 <Heffalump> SamB: involving continuations?
12:56:20 <wli> b_jonas: Basically you just need polynomial factorization over number fields (which exists, but is hard to write).
12:56:21 <SamB> Heffalump: well, involving hard and/or impossible proofs
12:56:32 <SamB> to do constructively, anyway
12:56:34 <conal> SamB: exactly!
12:56:55 <SamB> I guess that's related to continuations ?
12:57:01 <b_jonas> wli: yeah, and Mathematica supposedly handles rootof expressions quite generally
12:57:02 <wli> b_jonas: If you get a linear factor you're done.
12:57:04 <SubStack> enumerate over everything that doesn't work, and don't do that!
12:57:05 <conal> SamB: people make lots of claims about what's impossible.  very hard claims to back up.
12:57:18 <b_jonas> wli: but I think I have a simpler to implement method for just square roots
12:57:28 <SamB> conal: well, notice I said hard and/or impossible
12:57:33 <FunctorSalad> . o O ( indirect proof that a solution exists )
12:57:38 <SamB> it might be impossible to prove them impossible too ;-P
12:57:41 <b_jonas> wli: which I think I can't generalize for arbitary radicals (or even rootofs)
12:58:02 <b_jonas> wli: so that's why I tried to write tha
12:58:03 <conal> SamB: and claims of "necessary", "only", "best". are forms of "impossible"
12:58:30 <SamB> conal: hmm, true
12:58:37 <conal> SamB: oh!  i didn't mean to challenge *your* "impossible".
12:58:49 <conal> SamB: i was talking about design by negation!  :)
12:59:09 <b_jonas> wli: and I think you don't only need polynomial factorizatoin but other hard to write parts too
12:59:12 <conal> SamB: took me a bit to sort out your response.
12:59:24 <SamB> well, thinking in the context of proofs, there are definately going to be some "negative" constraints ...
12:59:27 <b_jonas> general magic with what's it called chains and stuff
12:59:36 <wli> b_jonas: You do, but I got stuck on polynomial factorization.
12:59:50 <b_jonas> wli: I see
13:00:19 <b_jonas> well it's definitely hard to write
13:00:23 <b_jonas> what made you start it?
13:00:45 <wli> b_jonas: Can your algorithm do ((2^(1/2)+2-2*(2^(1/2)+1)^(1/2))^(1/2)?
13:00:55 <b_jonas> wli: I said I started to write it
13:01:03 <b_jonas> wli: it didn't actually work
13:01:10 <b_jonas> wli: though I still think in abstract it can work
13:01:15 <b_jonas> wli: it doesn't do simplification
13:01:23 <b_jonas> simplification is impossible in general
13:01:26 <conal> off-topic question: is "on-boarding" a common term?  i got offered a job, and when the HR person used the word "on-boarding", i wanted to reject the offer right there.
13:01:27 <SamB> (just like any interesting theorem has some quantified variables ...)
13:01:28 <b_jonas> it only does comparision
13:01:44 <b_jonas> it can decide if any square root expression is less or equal or greater than zero
13:01:59 <b_jonas> and is guaranteed to terminate but can take lots of time
13:02:01 <SamB> conal: never heard of it!
13:03:12 <b_jonas> and the name I didn't remember is Sturm chains
13:03:14 <conal> there's even a wikipedia page.  breaks down on-boarding to more scary words: align, acquire, accommodate, assimilate, accelerate.  eek1
13:03:22 <b_jonas> but mine doesn't need that, it's simpler
13:03:26 <Heffalump> conal: yes, it's common.
13:03:39 <Heffalump> at least, I've heard of it in at least my current job and possibly my previous one
13:04:00 <conal> Heffalump: both british (or ex-british-empire) jobs?
13:04:40 <conal> brits also say "made redundant" for being fired, right?
13:04:51 <mreh> nope
13:05:00 <mreh> made redundant is being "laid off"
13:05:04 <mreh> you get money
13:05:08 <mreh> if you get fired, you dont get anything
13:05:27 <p_l> company usually doesn't need redundant workers, after all... ;P
13:05:33 <Heffalump> conal: yes
13:05:45 <conal> mreh: thx.  didn't realize it was specific to laid off.
13:06:08 <mreh> they liquidate them, turn them into soylent green
13:06:12 <Heffalump> Typically in UK english you use "made redundant" for white-collar workers and "laid off" for blue-collar workers.
13:06:19 <conal> mreh: lol
13:06:27 <mreh> Heffalump: haha
13:06:39 <Heffalump> well, it's true, made redundant sounds much more posh :-)
13:06:48 <Cale> wli: btw, Mathematica's RootReduce turns that into Root[Function[x,-2 + 4 x^2 + 4 x^3 + x^4], 2], and then ToRadicals turns it into -1 + Sqrt[1 + Sqrt[2]]
13:06:49 <p_l> is there somewhere where I can check all those <color>-collars names?
13:06:54 <bos> HR jargon always has a nasty doublespeak air to it because, well, it's nasty doublespeak.
13:06:57 <mreh> white-collar = middle class, blue-collar: poor people
13:07:01 <wli> Cale: Yep.
13:07:06 <SamB> Heffalump: what do you use for workers who wear t-shirts and jeans ?
13:07:17 <Heffalump> slobs
13:07:24 <conal> bos: yeah.  that's what gave me the creeps.  i hadn't hear HR-speak in a while.
13:07:29 <mreh> computer programmers
13:07:34 <bos> conal: it's universal, for better or worse.
13:07:35 <SamB> what! that stuff is comfy.
13:07:51 <mreh> SamB: low-level computer programmers
13:07:54 <SamB> It's only slobby because I've been wearing the same pair of jeans for ...
13:07:59 <Heffalump> on-boarding sounds ok to me, it's descriptive and not a euphemism
13:08:05 <SamB> well, I probably should change them if I can't remember ...
13:08:08 <wli> Cale: How does it do on (35*2^(4/5)+35*2^(3/5)+23*2^(2/5)+21*2^(1/5)+43)^(1/7)?
13:08:09 <FunctorSalad> for "hiring"?
13:08:23 <Heffalump> FunctorSalad: no, it's the induction process.
13:08:27 <Heffalump> so they could call it that.
13:08:28 <SamB> Heffalump: it sounds like a lamely-made-up word
13:08:32 * bos dusts off Data.Text for the first time in a few months
13:08:39 <Heffalump> well, all words have to start somewhere
13:08:45 <conal> it's grammatically odd.
13:08:51 <bos> i start them in the back of my throat.
13:08:53 <SamB> yeah, that's what I mean
13:09:00 <conal> reminds me of a ramp into a slaughterhouse
13:09:10 <FunctorSalad> also, there exists a coword that has to stop everywhere
13:09:10 <conal> bos: lol
13:09:19 <conal> FunctorSalad: :)
13:10:02 <mreh> Geometry.hs:5:3:
13:10:08 <mreh>     Warning: `polygon' is exported by `module SOE' and `polygon'
13:10:08 <mreh> ??!
13:10:09 <conal> instead of dinner, i'm going to an in-stomaching.
13:10:31 <FunctorSalad> hehe
13:11:06 <Heffalump> so are you going to overlook the corporate bullshit (which I can assure you will get much worse than a made-up word) and take the job? :-)
13:11:12 <wli> (I guess one might want to try the 7th root of ((2^(1/2)+1)^(1/5)+1)^7 too.)
13:11:54 <conal> Heffalump: i don't know.  work in progress.
13:12:26 <conal> i'm more excited about playing with functional GPU programming all summer
13:13:32 <bos> conal: who's the lucky employer?
13:13:42 <inimino> Cale: I'm fully in agreement about CSS, you're the only other person I've heard so far express that exact idea
13:13:53 <inimino> Cale: so do you have any plans to work on that? :-)
13:14:05 <conal> bos: standard chartered (where lennart works).  not a done deal by any means.
13:14:23 <bos> conal: ah, nice. they'd let you work from california?
13:14:50 <bos> or are you going to have to move from the sierra foothills to beautiful abandoned dubai?
13:14:51 <conal> bos: i think so, if i wanted.  or in london & singapore.
13:14:55 <Cale> inimino: It would be somewhat interesting, though my personal motivation is a bit weak, as I don't do a lot of web stuff as it is. I think a lot of ideas could be stolen from other typesetting engines...
13:15:23 <conal> bos: in the summer, the sierra foothills heat up, so leaving has some appeal.
13:15:26 <bos> conal: lobby him to start a standard chartered san francisco office, and i'll join you :-)
13:15:42 <inimino> Cale: ah, ok
13:15:42 <conal> bos: ooh!  sounds good to me.
13:16:07 <Heffalump> seems a bit unlikely given their markets :-)
13:16:33 <bos> but all they'd need is an office with two desks and two chairs!
13:16:34 <conal> bos: i may spend the summer in seattle.  family (three of my kids + one grand-daughter) and beautiful summers.
13:16:35 <Cale> inimino: But yeah, I'm pretty much unhappy with the state of all of the web standards, more or less.
13:16:42 <inimino> I would dearly love to someone write such a thing and get it in, say, Firefox, but I don't have time to consider trying it myself
13:16:59 <inimino> Cale: HTML5 is coming along nicely, and ES5 is a big improvement
13:17:10 <roconnor> what did Cale say about CSS?
13:17:13 <inimino> but CSS is ... ahem
13:17:30 <Cale> I don't really like HTML either.
13:17:52 * p_l sometimes dreams of HTML2.0 with CSS and few additions (div, span)
13:17:55 <conal> "improving CSS" reminds me of that awful joke about the kid falling down the outhouse hole.
13:18:01 <Cale> roconnor: That it's a gigantic nearly-unimplementable mess with basically no means of abstraction.
13:18:05 <inimino> roconnor: he was saying that it could be replaced with a simple language of positioning primitives and everything in it now could be implemented as libraries
13:18:19 <conal> and his dad said "it'd be easier to make a new one than to clean up this one."
13:18:56 <Raevel> dude
13:19:01 <inimino> yes, the current CSS needs to be nuked from orbit and then we can start over
13:19:19 <roconnor> Cale: that probably isn't in reference to CSS 1.
13:19:22 <conal> inimino: "nuked from orbit" lol
13:19:43 <inimino> (not necessarily in that order)
13:19:47 <Cale> roconnor: Even CSS 1.
13:19:52 <roconnor> Let's use DSSSL-online instead of CSS! \o/
13:19:55 <Twey> <div> and <span> are corruption
13:20:16 <roconnor> Cale: even CSS 1?  I thought it was fairly simple.
13:20:21 <Cale> roconnor: It's way, way more complicated than it needs to be, because it has no way to describe new concepts inside itself.
13:20:42 <inimino> <div> and <span> are the least of our worries ;-)
13:20:44 <inimino> roconnor: CSS 1 was too simple, it doesn't do things that should be trivial
13:20:50 <conal> almost everyone misses ISWIM !
13:20:53 <inimino> roconnor: it's fundamentally at odds with what people want to actually do on the Web
13:20:56 <Cale> CSS 1 still had all the stuff about margins and padding and so forth.
13:20:59 <roconnor> inimino: I probably agree, but what are you thinking of?
13:21:09 <Cale> (didn't it?)
13:21:12 <inimino> so you have things like float being abused for everything but
13:21:14 <roconnor> Cale: Yes
13:21:33 <conal> landin spelled it out in the 60s, and people still make things like xml, html, and css.
13:21:42 <inimino> yeah it had margins and padding
13:21:42 <roconnor> Cale: padding and margin collapse seem like pretty good layout ideas to me.  I'd be interested in better ones.
13:21:42 <bos> we should just be shipping giant clumps of S and K combinators over the wire
13:22:09 <inimino> roconnor: they're fine ideas, but the problem is that CSS is the wrong level of abstraction for the job
13:22:34 <conal> bos: something like that.  plus powerful static typing and supercombinators.
13:23:05 <roconnor> conal: how does landin say we should do layout?
13:23:10 <inimino> it needs to be dropped one level down, closer to actual browser layout engine constraints
13:23:14 <bos> if we reduce the web to something that can only be understood by 50 people, think of how much each of those 50 people will make!
13:23:35 <conal> oh -- i just noticed a footnote in "the next 700 program language": A not inappropriate title would have been "Church without lambda"
13:23:59 <maltem> inimino, you mean CSS should be higher-level (less precise)?
13:24:12 <inimino> maltem: no, precisely the opposite
13:24:14 <conal> roconnor: i forget.  looking right now.  istr that he invented the layout rule.
13:24:22 <conal> or another layout rule
13:24:49 <inimino> maltem: CSS should specify things actual constraints on where things can go on the page, at a lower level than things like "float: left"
13:24:54 <Cale> I think it should be possible inside the style language for someone to write something which takes the contents of an element and lays it out into as many columns as necessary which are at most x units tall (or relative to the browser window height). This wouldn't be a primitive, it should be something someone can distribute in a library.
13:25:03 <roconnor> I'd like to learn how to properly do layout and style cascading for a 2-d layout library for Haskell Charts.
13:25:23 <conal> the "next 700" (ISWIM) paper is so important!  what we do could be roughly summed up as ISWIM + laziness + sexy types
13:25:46 <roconnor> @where next700
13:25:46 <lambdabot> I know nothing about next700.
13:25:56 <roconnor> @where ISWIM
13:25:57 <lambdabot> I know nothing about iswim.
13:26:08 <inimino> essentially you should have as close as possible to an unrestricted function from (DOM, screen size) pairs to layouts
13:26:13 <conal> @go "the next 700 programming languages"
13:26:15 <lambdabot> http://ttic.uchicago.edu/~blume/classes/aut2008/proglang/papers/Landin-next-700.pdf
13:26:15 <lambdabot> Title: The Next 700 Programming Languages
13:26:18 <maltem> inimino, ok, and why would that be better? For better control for the layouter?
13:26:39 <conal> @where+ ISWIM http://ttic.uchicago.edu/~blume/classes/aut2008/proglang/papers/Landin-next-700.pdf
13:26:40 <lambdabot> Done.
13:26:48 <inimino> instead of what you have now which is a bunch of primitives like "padding" and "margin" that interact in confusing ways and don't allow basic things (like columns)
13:26:57 <conal> @where liberated
13:26:57 <lambdabot> http://www.stanford.edu/class/cs242/readings/backus.pdf
13:27:13 <Cale> maltem: With that greater generality, you could choose primitives which are simpler to implement consistently.
13:27:41 <Heffalump> inimino: I disagree, I'd like some assurances of monotonicity in relation to screen size
13:27:42 <inimino> maltem: better control, and a more practical language
13:27:42 <maltem> oh, so you don't mean lower-level, but more powerful?
13:27:47 <inimino> many people don't realize it, but CSS as it currently stands is a *very* difficult language to master
13:27:50 <conal> i recommend these to papers over all as describing what functional programming is about.  then john hughes's "why functional programming matters"
13:27:54 <Cale> maltem: To some extent both at the same time.
13:28:07 <Cale> maltem: With higher level stuff being done by standard libraries.
13:28:07 <maltem> ok I think I get you :)
13:28:08 <inimino> maltem: yes, both
13:28:20 <roconnor> DSSSL-online!
13:28:28 <conal> @where whyfp
13:28:28 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
13:29:11 <inimino> Heffalump: why do you need such a guarantee?
13:29:47 <Cale> conal: The trouble with whyfp I've found is that it is a wonderful paper to read if you're already on the verge of realising what it is that it is saying, but if not, then it doesn't seem to help.
13:29:59 <wy> I thought about a question. Is there a good way FP deal with the cache?
13:30:00 <maltem> I suppose that the difficulty of CSS lies in how it's not clear how CSS layouting interacts with the sequential nature of HTML documents
13:30:22 <Heffalump> inimino: so that people can't write stupid webpages that mess up in my browser
13:30:36 <conal> Cale: i believe it.  like many things.  if someone's ready a small tap will do, and if they're not then a canon blast won't help.
13:30:42 <inimino> maltem: well, that's part of it, CSS doesn't have the flexibility to reorder content
13:30:44 <inimino> Heffalump: too late, they can anyway
13:30:50 <inimino> Heffalump: but think about mobile devices, etc... the flexibility needs to be there
13:31:05 <Heffalump> I want them to work an all screen sizes.
13:31:46 <Cale> However, it does make a lovely argument for lazy evaluation and/or nonstrict semantics.
13:31:56 <inimino> Heffalump: then you want people to be able to specify different layouts depending on screen size
13:32:14 <b_jonas> so you want turing-complete css?
13:32:19 <conal> Cale: laziness is the heart of the paper.  "why laziness matters".
13:32:24 <Cale> Yeah
13:32:27 <maltem> inimino, a question is whether CSS gaining that that flexibility would make the CSS/HTML interaction clearer
13:32:36 <maltem> s/ that//
13:32:36 <wy> conal: bingo
13:32:42 <inimino> b_jonas: yes, or something as close as practical
13:32:56 <wy> anyone interested in my question about the cache?
13:33:00 <Heffalump> I think we need ways of specifying streaming behaviour in the type system
13:33:05 <inimino> b_jonas: I'd be OK with some constrants that might be needed for browser engine layout efficiency, if any
13:33:34 <Cale> wy: It seems to me to be more of a problem for *the compiler* of a functional programming language to worry about.
13:33:50 <Cale> wy: Rather than a concern which ought to be exposed to programmers.
13:33:52 <wy> Cale: right. any ideas?
13:34:09 <wy> or do we need to change the architecture at all?
13:34:37 <conal> bos: thx for the tweet.  hah!
13:34:40 <Cale> Well... naturally tricks like ByteStrings and the new parallel arrays help to some extent.
13:34:42 <inimino> maltem: it would finally allow the separation of layout and content that CSS supposedly promises today
13:35:04 <inimino> maltem: currently that is a lie since the possible layouts are (somewhat arbitrarily) restricted based on the order of content in the HTML
13:36:14 <Cale> wy: Concerns with cache locality only matter when you're doing something that pushes at the limits of how quickly things can be processed with the machine. Parts with lots of user-interaction clearly don't matter. So I think the answer is just to have collections datastructures which are sufficiently efficient on large collections of data.
13:36:30 <roconnor> wow, I'm totally not understanding Landin's paper.
13:36:48 <b_jonas> inimino: how about just javascript and dom?
13:37:10 <Cale> roconnor: It might help to understand that iswim was never completely formal.
13:37:10 <b_jonas> javascript can reorder stuff and change properties of stuff where by stuff I mean elements
13:37:13 <Heffalump> Cale: not true, you might have both user interaction and real-time computation
13:37:39 <pejo> The cache makes it much harder to reason about real-time though.
13:37:42 <inimino> b_jonas: well, the browser already has a layout engine
13:37:57 <inimino> b_jonas: are you saying replace CSS with JavaScript?
13:38:01 <roconnor> Cale: well, I'm sort of getting that.
13:38:02 <Cale> Heffalump: But if you have to wait for the user to input something, that's got to take a lot longer than the difference between accessing RAM and the L2 cache, say.
13:38:17 <b_jonas> no, I'm saying ditch all of that, and html and flash and all that stuff too
13:38:24 <roconnor> Cale: but it seems that ISWIM is completely informal or unformal even.
13:38:28 <b_jonas> just throw all the web and browsers out the window
13:38:29 <Cale> roconnor: yes
13:38:32 <Heffalump> Cale: sure, but you might simultaneously be waiting for the user to input something and doing some updates based on other external events
13:38:46 <b_jonas> and make something new that's just plain text with italics and hyperrefs
13:38:49 <Cale> roconnor: It's supposed to be a sort of general idea for the direction that programming languages would head in.
13:38:55 <wy> Cale: I think the concern is mostly about batch computation if we think about cache
13:38:55 <b_jonas> we could keep http if we really wanted to
13:38:58 <inimino> b_jonas: I'm not sure if you're being sarcastic or not :)
13:39:43 <Cale> Heffalump: Well, concurrently, but it ought to be a different part of the program, I would think.
13:39:55 <inimino> I don't think just plain text with italics and hyperlinks would displace the existing Web ;-)
13:40:15 <roconnor> Cale: this paper isn't going to teach me about cascading styles is it?
13:40:17 <Heffalump> Cale: but both parts will be competing for the cache
13:40:18 <wy> I was often asked about cache performance about FP. Have no ideas about that
13:40:22 <Cale> Stuff which has to happen quickly tends to be the stuff which acts uniformly on large amounts of data.
13:40:37 <Cale> Heffalump: Oh, actually, that's a good point about concurrency.
13:40:44 <wy> Will FP make cache performance any different?
13:40:51 <Cale> Heffalump: But... it can't really be helped can it?
13:40:56 <Heffalump> wy: yes, it'll typically make it worse
13:40:59 <maltem> inimino, I see what you wish for. Certainly, though, you would change not only CSS, but HTML too? (And drastically change the semantics of HTML, even if those are ignored for most HTML code.)
13:41:03 <Heffalump> Cale: quite possibly not, but it's definitely something to think about
13:41:15 <Heffalump> wy: more indirect jumps, in particular
13:41:20 <Heffalump> bad for the instruction cache
13:41:24 <conal> roconnor: for me the heart of next700 is the first paragraph (identify & disentangle the two aspects of programming languages) plus the insight of using a functional host language.
13:41:36 <wy> Heffalump: from closures?
13:41:43 <Heffalump> wy: yes
13:42:09 <wy> Heffalump: Has it something to do with allocation of objects, since we don't "reuse" objects
13:42:17 <inimino> maltem: I'm not sure what you mean about changing the semantics of HTML... I don't see any need to revise HTML for this to work
13:42:30 <conal> holy crap.  Landin says: The word "denotative" seems more appropriate than nonprocedural, declarative or functional.
13:42:33 <Cale> wy: One thing about most of our algebraic datastructures is that they are linked structures and are not usually stored in any one part of memory.
13:42:45 <inimino> maltem: of course if HTML was to be redesigned from scratch I don't think that we would do it the same way, but I also don't think that's practical
13:42:50 <pejo> Heffalump, isn't GHC pretty good at specializing things already?
13:43:07 <Heffalump> pejo: no doubt, but that's just removing some of the abstraction penalty
13:43:21 <maltem> inimino, well HTML is sequential
13:43:26 <Cale> wy: If we can deforest and remove the structures altogether, it doesn't matter though :)
13:43:42 <inimino> maltem: but I actually think replacing CSS wholesale with something better could be accomplished on the Web (of course CSS would still be supported for legacy reasons)
13:44:00 <roconnor> inimino: Question.  Let say we do replace CSS with a lower level interface.  We still want to write (possibly several) implementations of a CSS like language so we can write sane layouts.  My question is, given that you don't like CSS, what semantics do you want in a high-level interface?
13:44:01 <Cale> So to some extent, more aggressive deforestation is something we could do about performance in that regard.
13:44:35 <Cale> roconnor: The ability to equationally define constraints sounds nice to me.
13:44:37 <roconnor> inimino: because I want to write a Haskell lib for 2-D layout.
13:44:42 <inimino> maltem: yes it's sequential, but it doesn't mean you can't move things around without semantic loss
13:44:50 <wy> Cale: but linked structures are used in most languages even C
13:44:51 <Cale> roconnor: Usually I just want to say "I want this thing to be this much to the left of this other thing."
13:45:04 <inimino> roconnor: that's a harder question :)
13:45:12 <roconnor> inimino: indeed. :)
13:45:21 <roconnor> it is also the really interesting question.
13:45:36 <maltem> inimino, hm... maybe :)
13:45:36 <wy> so I guess it may only have something to do with the garbage collector
13:45:42 <inimino> roconnor: that's why I don't think CSS should be at that level, because you had a lot of experts already try to answer it and the result is, well, CSS
13:45:43 <roconnor> hard and interesting is probably corelated.
13:46:21 <Cale> roconnor: Or if you want to get fancier... "Try to fill this horizontal space uniformly with these things, but without overlapping them."
13:46:38 <wy> It may help us "reuse" ojbects. But I can't see why that help with cache since we need to initialize the structure.
13:46:42 <inimino> roconnor: that's why I think the only answer that makes sense for browsers is to go with something less "interesting" and more primitive, and then let the marketplace choose between higher-level layout abstractions
13:46:45 <inimino> whoops, he left
13:46:49 <conal> i just tweeted about the improve-or-replace css question.  perhaps too subtle.  we'll see.
13:46:52 <Cale> roconnor: Or if you want to get fancier... "Try to fill this horizontal space uniformly with these things, but without overlapping them."
13:47:00 <Cale> (repeat since you disconnected)
13:47:02 <inimino> roconnor: that's why I think the only answer that makes sense for browsers is to go with something less "interesting" and more primitive, and then let the marketplace choose between higher-level layout abstractions
13:47:17 <roconnor> damn non haskell IRC software :P
13:47:42 <inimino> haha
13:47:44 * inimino is happy with weechat
13:48:04 <conal> hm. negative design?
13:48:06 * wy found dumb xchat ok for him
13:48:11 * yaxu uploads a new haskell music screencast
13:48:15 <Cale> vacuum design? :)
13:48:33 <conal> Cale: yeah.
13:48:36 <Cale> Create a vacuum and let ideas naturally come in to fill it :)
13:48:46 <roconnor> Cale: sadly, throwing out little functions won't develop a general framework for doing 2-D layout. :)
13:49:09 <Cale> roconnor: I mean, those are the sorts of things one would like to be able to express at a higher level.
13:49:10 <conal> or look at a vacuum and declare that nothing could fill it.
13:49:15 <wy> Has anybody written a C++ or Python parser in haskell?
13:49:18 <roconnor> inimino, Cale:  Anyhow, I'm getting the impression that you don't know what the interface to a nice 2-D layout system is, which is fine.  Neither do I. :)
13:49:33 <byorgey> yaxu: nice, where?
13:49:34 <Cale> roconnor: So more generally, constraints on the positions of things or collections of things, relative to one another.
13:49:42 <inimino> roconnor: indeed I don't :-)
13:49:49 <Cale> roconnor: Which will be solved by the language/browser
13:49:49 <yaxu> http://blip.tv/file/2148049
13:50:04 <byorgey> a general 2D-positioning-via-constraint-solving library would be sweet.
13:50:09 <roconnor> Cale: (non-)linear optimization problem?
13:50:13 <Saizan> wy: see language-python on hackage
13:50:18 <conal> okay -- off to do outside work.  later, all.
13:50:27 <Cale> roconnor: Perhaps.
13:50:29 <byorgey> have fun conal
13:50:36 <roconnor> byorgey: it does sound inturging.
13:50:38 <Cale> roconnor: Though you might be able to get away with something even simpler.
13:50:42 <inimino> roconnor: I would look at something like SVG and traditional typesetting software for some ideas
13:51:08 <inimino> this kind of constraint-solving is what browser layout engines have to do already
13:51:25 <Cale> roconnor: Even just solving systems of equations without much of a concept for fitness would do for most things.
13:51:42 <inimino> we just don't have access to the raw constraint primitives, instead we have the kludge that is CSS
13:51:52 <wy> Saizan: thank. what about C++?
13:51:57 <Cale> But having a notion of the importance of various constraints would be really nice if you could get it.
13:52:24 <conal> byorgey: :)
13:52:47 <Cale> It really must be deterministic and simple to describe though.
13:52:54 <roconnor> after layout there is the issue of how to cascade colour and other attributes of lines and shapes.
13:53:14 <roconnor> I have some ideas about that, but the issue seems tricky.
13:53:42 <inimino> roconnor: actually, for things other than layout, I think CSS is OK
13:54:02 <roconnor> inimino: you mean the attribute cascade?
13:54:06 <inimino> it's only layout where CSS is a failure in my opinion; not to say that the rest couldn't do with a cleaner specification
13:54:18 <roconnor> inimino: interesting
13:54:44 <Cale> Then again, being able to write programs at that level to colour things would also be quite interesting.
13:55:05 <inimino> roconnor: yeah, the selector syntax, the cascade, and the non-layout formatting properties are all acceptable
13:55:45 <Cale> Has everyone here looked at flapjax at all?
13:56:12 <inimino> Cale: yes, if you're going to have a lower level it makes sense to give it more flexibility there too, I just think that for modern Web needs CSS is acceptable when it comes to most formatting tasks
13:56:26 <hatds> I thought I had a nice implementation of GUI layout abstractions.  type Dimensions = (Dimension,Dimension) representing width x height where data Dimension = Fixed Int | Variable Int
13:56:42 <inimino> (though if you try something like a syntax-highlighting text editor in CSS you hit limits there too)
13:56:58 <hatds> Fixed x means fixed width, Variable x means can be stretch to any width, but a minimum of x width is required
13:57:44 <inimino> Cale: I saw it a long time ago, but don't remember much
13:58:18 <gio123> is here anybody using winedit?
14:06:32 <byorgey> hatds: why not a maximum width too?
14:07:59 <hatds> byorgey: good question, I'm using this for things that sit inside an OS window, which might be changed to any size
14:08:50 <byorgey> but couldn't you just add padding to fill out any extra space?
14:08:53 <hatds> byorgey: if it is stretched below the minimum width you can simply clip things instead of trying to reflow to a smaller size, I suppose the fallback for stretching beyond the maximum size would be to fill it with a default color/background
14:09:00 <byorgey> right
14:10:55 <hatds> I'm using combinators not unlike the prettyPrint library.  So if you have GUI elements a, b, c and d you can put them in a 4x4 grid by saying  let r1 = a <> b <> hNil, r2 = c <> d <> hNil,  win = r1 $$ r2 $$ vNil
14:12:19 <hatds> the magic as I see it is that given the Dimensions of 'a' and 'b' there is a sensible aggregate Dimension for 'r1'
14:16:18 <roconnor> when a function is passed as a parameter to a function in ML, is it evaluated to WHNF, or anything like that?  Does my question even make sense?
14:17:35 <roconnor> like what happens if I do map (print "Hi"; (fun x => x)) [(),(),(),()]  in ML?
14:20:08 <pejo> roconnor, are you asking what a compiler will actually do, or what the formal semantics says?
14:20:25 <roconnor> I'm asking about the semantics
14:20:57 <roconnor> persumably Hi will be printed either once or four times.
14:21:13 <gio123> is here anybody using winedit?
14:21:17 <bos> roconnor: once.
14:21:35 <bos> roconnor: it's an eager language.
14:21:37 <roconnor> bos: ah, so it does reduce to WHNF, or something like it.
14:21:43 <bos> yes.
14:24:16 <xenoblitz> Hi people, quick question... I know that Haskell does static type checking... does it also perform runtime type checking (I apologize for my lack of knowledge on the subject forehand)
14:24:43 <bos> ML has a semantics somewhere.
14:25:14 <zachk> xenoblitz: there is no runtime type checking, because it is strongly typed and checked at compile time
14:25:27 <zachk> the runtime can give you errors though
14:25:33 <zachk> > head []
14:25:33 <xenoblitz> so none at all?
14:25:34 <lambdabot>   * Exception: Prelude.head: empty list
14:25:37 <roconnor> xenoblitz: that is a very deep question, but the short answer is that the Dyanmic type will give you runtime checking.
14:25:39 <zachk> like that
14:25:52 <roconnor> @hoogle fromDynamic
14:25:53 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
14:26:39 <bos> there is use of type information at runtime, but that's not the same thing as runtime type checking.
14:26:39 <zachk> @src concat
14:26:40 <lambdabot> concat = foldr (++) []
14:26:57 <xenoblitz> zachk, roconnor: thanks for the tips
14:26:58 <roconnor> xenoblitz: you lose karma each time you use Dynamic.
14:27:03 <xenoblitz> bos: can you give an example of that?
14:27:13 <pejo> roconnor, Robert Harper with coauthors has mechanized the semantics of ML, those sources might be available online if you don't want to read the report.
14:27:31 <roconnor> pejo: I'm pretty happy with bos's answer.
14:28:12 <xenoblitz> roconnor: I don't plan to use it :P I am just trying to understand how a DSEL can fail to do type checks at runtime in a static host language
14:28:37 <xenoblitz> roconnor: either that or I misunderstood my tutor
14:28:50 <roconnor> My advisor wants me to explain the standard trick of using (() -> Foo) to fake laziness in an eager language.
14:29:15 <roconnor> I don't suppose anyone has a decent reference I can add to my thesis?
14:29:25 <zachk> SICP?
14:29:27 <zachk> :-/
14:29:31 <xenoblitz> roconnor: no sorry :(
14:29:39 <roconnor> zachk: hmm
14:30:03 <roconnor> zachk: Ideally the reference would use some ML-like langauge, with types.
14:30:25 <zachk> no idea sicp is just the old mit scheme textbook i know it gets into laziness though
14:31:38 <zachk> @src (++)
14:31:38 <lambdabot> []     ++ ys = ys
14:31:38 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
14:31:38 <lambdabot> -- OR
14:31:38 <lambdabot> xs ++ ys = foldr (:) ys xs
14:31:52 <xenoblitz> roconnor: to be honest I have no idea if this is any related but the first part of the title looks promising http://portal.acm.org/citation.cfm?id=581690.581694
14:32:50 <xenoblitz> roconnor: wait its the other way round you want, nevermind me
14:33:26 <roconnor> Andrew W. Appel, Garbage collection can be faster than stack allocation
14:33:47 <roconnor> James S. Miller , Guillermo J. Rozas, Garbage Collection is Fast, but a Stack is Faster
14:33:58 <roconnor> :)
14:34:26 <xenoblitz> conflicting?
14:34:55 <roconnor> those were two citations in xenoblitz's linked article.
14:35:46 <xenoblitz> roconnor: oh xD btw are you the roconnor which wrote that article on circular programming in a monad.reader issue? :P
14:35:56 <roconnor> yes
14:35:58 <xenoblitz> *who sorry its 11.35 pm here
14:36:11 <xenoblitz> roconnor: I am using your article as an example of tying the knot :)
14:36:16 <roconnor> :)
14:36:18 <xenoblitz> roconnor: (with ref)
14:36:19 <xenoblitz>  :)
14:36:39 <roconnor> xenoblitz: http://r6.ca/blog/20081116T213644Z.html
14:36:48 <xenoblitz> roconnor: the idea of explaining it as sci-fi rocks :)
14:37:59 <xenoblitz> roconnor: lol :) I wish I could make use of it so quickly :)
14:38:23 <xenoblitz> haskell is amazing once you get the strict-rust out of the way
14:38:46 <roconnor> I don't use tying the knot very often, but I keep my eyes out for places I can use it.
14:38:59 <roconnor> It does pop up regularly.
14:39:11 <roconnor> oh there is another nice use for string matching
14:40:24 <roconnor> here: http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
14:40:45 <roconnor> that use still boggles my mind.
14:42:30 <xenoblitz> roconnor: amazing, if it boggles your mind I'm not gonna go there else i risk breaking space-time continuum
14:42:41 <xenoblitz> but it does look interesting (skimmed a bit through)
14:43:04 <xenoblitz> i'm mostly going to use it as a lazy dictionary with labels and values which gets populated as you traverse a program and then when all the labels are found the  ... well mostly like your example with the assembly language really
14:45:31 <xenoblitz> question: is it possible to type checking at  runtime... in the sense imagine I have a Wire which can carry and integer or a boolean and I wish to restrict it to a Boolean at a particular point... is it possible to check at runtime, through some sort of checking mechanism whether your wire is of Boolean type, without resorting to Phantom Types or GADTs?
14:46:09 <xenoblitz> to put it very very informally sort of reflexively check your type?
14:46:34 <roconnor> xenoblitz: use (Either Integer Bool) and pattern matching?
14:47:11 <thoughtpolice> copumpkin: http://www.haskell.org/ghc/dist/current/ports/ghc-6.11.20090521-x86_64-apple-dar
14:47:13 <roconnor> Phantom Types and GADTs would potentially let you do the checking at compile time instead of runtime.
14:47:14 <thoughtpolice> win.tar.bz2
14:47:36 <Japsu> lose.tar.Z
14:47:53 <xenoblitz> roconnor: hmmm so how is it runtime that's what is bothering me what is actually runtime... let me hpaste in case it helps...
14:51:41 <xenoblitz> roconnor: is this wrong because it compiles but if run it gives an error? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5132#a5132
14:52:12 <xenoblitz> well no it doesn't
14:52:22 <xenoblitz> am not restricting it in any way...
14:53:41 <roconnor> xenoblitz: when you interpret example, you will presumably get an pattern match failure because you won't have a pattern to handle that construction
14:54:03 <roconnor> xenoblitz: A pattern match failure for us is practically the same thing as a run time type error in dynamic languages.
14:54:47 <roconnor> xenoblitz: ideally you should have BoolWires and IntWires.
14:55:10 <roconnor> xenoblitz: and perhaps type Wire = Either BoolWire IntWire
14:55:15 <xenoblitz> or use phantom types or GADTs
14:55:30 <roconnor> yes, you could also use phantom types or GADTs
14:55:36 <xenoblitz> but for some reason I can't still understand how "A pattern match failure for us is practically the same thing as a run time type error in dynamic languages."
14:56:10 <monadic_kid> i wouldn't put it like that
14:56:15 <roconnor> xenoblitz: because "dynamic types" is really runtime tagging.  Datastructures are tagged with their types.
14:56:37 <roconnor> xenoblitz: in Haskell, data types are tagged by their constuctors.
14:56:58 <roconnor> xenoblitz: the point is both can be seen as tagging systems.
14:57:04 <xenoblitz> hmmm ok ok
14:57:35 <roconnor> xenoblitz: in a dynamic language, when an unexpected tag is encountered with no code to handle it, a "runtime type error" is thrown.
14:57:39 <xenoblitz> so I can basically say that since we are using pattern matching we are in essence checking at runtime?
14:58:00 <roconnor> xenoblitz: in Haskel, when an unexpected pattern is encountered with no code to handle it, a "pattern match failure" is thrown.
14:58:14 <roconnor> xenoblitz: That's what I'd say, yes.
14:58:28 <roconnor> others may disagree with me.
14:58:45 <xenoblitz> well I have a feeling that's how it can be seen when one talks about DSELs
14:59:05 <roconnor> probably
14:59:37 <roconnor> your DSEL don't have to be "dynamically typed"  Using GADTs they can often be properly typed in GHC.
14:59:56 <roconnor> and in very simple cases you can do in in Haskell '98 too.
15:00:05 <roconnor> In very complex cases, GADTs aren't even enough.
15:00:08 <xenoblitz> yes they sort of convert the runtime type checking into static checking
15:00:35 <xenoblitz> I'm very very unknowledgeable in this area... trying to fit bits and pieces together
15:00:42 <roconnor> :)
15:01:12 <xenoblitz> right now i am thinking of an example to use with the Wire data type in the hpaste to show how there is runtime checking
15:01:58 <roconnor> zachk: Apparently "Concepts in Programming Languages" by John C. Mitchell talks about how to write force and delay using unit -> foo.
15:02:03 <roconnor> thank you google books!
15:02:26 <roconnor> xenoblitz: you need to write an interpretation function of some sort that operates on Wire.
15:02:34 <xenoblitz> roconnor: thanks btw... and yeay for finding a reference :) one last thing...
15:02:50 <xenoblitz> roconnor: yes I was thinking about simulate for example... but I have no clue how I could write the patterns
15:03:02 <xenoblitz> sa in the cases
15:03:04 <xenoblitz> *as
15:03:13 <roconnor> keep at it!
15:03:13 <xenoblitz> to force the Add to integers for example
15:03:33 <xenoblitz> so you know of a way?
15:03:42 <xenoblitz> (not necessarily to tell me just to know if its possible)
15:27:20 <roconnor> xenoblitz: your simulation function probably should have type Wire -> Either Int Bool, if that helps.
15:28:22 <xenoblitz> roconnor: still I don't know how I would pattern match Add
15:28:24 <xenoblitz> I c
15:28:29 <xenoblitz> it could work somehow with that
15:28:38 <xenoblitz> and if not that's the runtime error we are refering to
15:30:06 <McManiaC> @pl \x -> foo bar x y z
15:30:06 <lambdabot> flip (flip (foo bar) y) z
15:34:00 <solrize_> is ghc 6.10.3 the best release to use these days?  i have 6.8.something and it's missing data.binary
15:35:26 <pumpkin> Data.Binary comes from hackage doesn't it?
15:36:01 <FunctorSalad> package "binary"
15:38:46 <hatds> is there a tool to give you the types of subexpressions inside the context of a larger expression?  Like if you had "(.) (.) map" it would tell you the types of each (.)
15:39:23 <mmorrow_> > ?g ?f map
15:39:24 <lambdabot>       Unbound implicit parameters (?g::t
15:39:24 <lambdabot>                                     ...
15:39:29 <mmorrow_> , ?g ?f map
15:39:32 <lunabot>  luna: Unbound implicit parameters (?f::t,
15:39:52 <mmorrow_> implicit params are nice for that
15:39:57 <hatds> ok
15:40:34 <skorpan> i don't get it
15:40:43 <skorpan> (.) (.) map...?
15:40:47 <mmorrow_> > (\k -> (`id` flip fix =<<) ?o)
15:40:48 <lambdabot>   <no location info>: parse error on input `)'
15:40:51 <FunctorSalad> @type ?g ?f map
15:40:52 <lambdabot> forall t t1 a b. (?f::t, ?g::t -> ((a -> b) -> [a] -> [b]) -> t1) => t1
15:41:08 <mmorrow_> there we go :)
15:41:23 <mmorrow_> @type (\k -> (flip fix =<<) ?o)
15:41:25 <lambdabot> forall t a c. (?o::((a -> c) -> a -> c) -> a) => t -> ((a -> c) -> a -> c) -> c
15:41:59 <skorpan> is (->) a monad?
15:42:06 <skorpan> or (-> a)
15:42:13 <mmorrow_> @src (->) (>>=)
15:42:13 <lambdabot> f >>= k = \ r -> k (f r) r
15:42:18 <solrize_> pumpkin i think it's in the stdlib now
15:42:21 <mmorrow_> @src (->) returnm
15:42:22 <lambdabot> Source not found. I feel much better now.
15:42:23 <mmorrow_> @src (->) return
15:42:23 <lambdabot> return = const
15:42:33 <skorpan> i was just about ot ask what >>= was for (->)
15:42:34 <skorpan> :)
15:42:36 <pumpkin> solrize_: hmm, I didn't think so
15:42:39 * pumpkin shrugs
15:42:42 <solrize_> hmm you're right
15:42:46 <solrize_> i switched computers a few days ago
15:42:55 <solrize_> still i wonder if i should upgrade to 6.10
15:43:03 <skorpan> could someone give me an example on how to use (>>=) for (->)
15:43:44 <pumpkin> @src ((->) a) (>>=)
15:43:44 <lambdabot> Source not found. You type like i drive.
15:43:49 <pumpkin> @src (->) (>>=)
15:43:49 <lambdabot> f >>= k = \ r -> k (f r) r
15:44:01 <skorpan> we've already established that :)
15:44:08 <pumpkin> oh :)
15:44:12 <mmorrow_> , (replicate >>= ($)) 4
15:44:13 <lunabot>  [4,4,4,4]
15:44:31 <mmorrow_> , ((,) >>= id) 4
15:44:32 <lunabot>  (4,4)
15:44:34 <pumpkin> > ((*) >>= id) 5
15:44:35 <lambdabot>   25
15:44:35 <pumpkin> boo
15:44:36 <mmorrow_> @src join
15:44:37 <lambdabot> join x =  x >>= id
15:44:38 <FunctorSalad> liftM2 for (->) is pretty intuitive. it applies the operator pointwisely to two functions
15:44:46 <skorpan> @src liftM2 (->)
15:44:46 <lambdabot> Source not found. My mind is going. I can feel it.
15:44:49 <skorpan> @src  (->) liftM2
15:44:50 <lambdabot> Source not found. There are some things that I just don't know.
15:44:53 <skorpan> O_o
15:44:55 <pumpkin> it's not a method
15:45:11 <pumpkin> > liftM2 (*) (+1) (subtract 3) 7
15:45:13 <lambdabot>   32
15:45:13 <skorpan> @src liftM2
15:45:14 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:45:29 <pumpkin> that's equivalent to (7 + 1) * (7 - 3)
15:45:39 <pumpkin> it's a bit like on, from Data.Function
15:45:50 <skorpan> yeah, on is awesome
15:45:57 <skorpan> i can see some resemblance :)
15:46:14 <solrize_> > (map (*) [1..5]) `liftM (->)` [10,20..50]
15:46:15 <lambdabot>   <no location info>: parse error on input `('
15:46:19 <FunctorSalad> on transforms the *domains* though, liftM2 op transforms codomains...
15:46:25 <pumpkin> yup :)
15:46:26 <mmorrow_> > mfix return :: a -> (b -> a)
15:46:28 <lambdabot>       Overlapping instances for Show (a -> b -> a)
15:46:28 <lambdabot>        arising from a use ...
15:46:31 <mmorrow_> nice
15:46:42 <solrize_> > liftM (->) (map (*) [1..5])  [10,20..50]
15:46:42 <lambdabot>   <no location info>: parse error on input `->'
15:46:45 <FunctorSalad> mfix is evil
15:46:45 <skorpan> :t liftM2
15:46:47 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:46:48 <skorpan> :t on
15:46:49 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:46:52 <solrize_> > liftM2 (->) (map (*) [1..5])  [10,20..50]
15:46:53 <lambdabot>   <no location info>: parse error on input `->'
15:46:59 <FunctorSalad> I thought you could use it to write an IO loop ;)
15:47:06 <FunctorSalad> but it does something much weirder
15:47:16 <yaxu> http://blip.tv/file/2148373 # more haskell music
15:48:35 <pumpkin> solrize: how would you use -> there? :o
15:50:44 <solrize_> well i was hoping i'd get [1*10. 2*20, ... ]
15:50:44 <mmorrow_> @src (->) mfix
15:50:45 <lambdabot> mfix f = \ r -> let a = f a r in a
15:50:51 <heatsink>  /quit
15:50:54 <heatsink>  /quit
15:50:57 <heatsink> what
15:51:04 <FunctorSalad> say... let loop x = do { c <- getChar; putStrLn (c:x); return (c:x) }
15:51:12 <heatsink> Sorry, not my usual irc client
15:51:27 <FunctorSalad> you would think that "mfix loop" repeatedly asks the user for a char and outputs the history of all chars
15:51:42 <FunctorSalad> but it just throws a "<<loop>>" exception ;)
15:53:54 <mmorrow_> @type fix (\k hist -> do l <- getLine; if l==":q" then return hist else (putStrLn l >> k (l:hist)))
15:53:56 <lambdabot> [String] -> IO [String]
15:54:10 <mmorrow_> instant-repl
15:55:09 <FunctorSalad> I mean, it do the expected: let reallyLoop x = loop x >>= reallyLoop in reallyLoop ""
15:55:30 <FunctorSalad> yeah, or that
15:56:03 <mmorrow_> but you can just type ":q" to stop
15:56:17 <lament> :wq
15:56:26 <FunctorSalad> I mean mfix for IO does something different altogether
15:56:40 <mmorrow_> lament: nice reflexes
15:57:15 <FunctorSalad> http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
15:57:19 <FunctorSalad> that is just scary
15:58:33 <FunctorSalad> (I'm sure there is some good reason why it's like that, it's just not what I naively expected from mfix :: (a -> IO a) -> IO a :))
16:00:40 <mmorrow_> , runST (mdo x <- newSTRef 0; k <- newSTRef (readSTRef x >>= \a -> writeSTRef x (a+3) >> if 10000 < a then return a else join (readSTRef k)); join (readSTRef k))
16:00:41 <lunabot>  10002
16:04:40 <mmorrow_> mdo {x1 <- f1 x1 .. xn; ...; xn <- fn x1 ... xn; return (g x1 ... xn)} <======> do {(x1,..,xn) <- mfix (\ ~(x1,..,xn) -> a1 <- f1 x1..xn; ...; an <- fn x1..xn; return (a1,..,an)); g x1 .. xn}
16:04:43 <mmorrow_> iirc
16:05:25 <erikc> oh, vs2010, i cant wait for you
16:17:40 <pumpkin> thoughtpolice: I'm struggling with it now :P
16:19:03 <Tobsan> @src on
16:19:03 <lambdabot> (*) `on` f = \x y -> f x * f y
16:19:37 <slava> dons: have you thought about using template haskell for adaptive-containers?
16:20:10 <pumpkin> slava: I think the problem is that TH doesn't support associated types in any released GHC
16:20:21 <slava> dons: seems that defining all the AdaptList (Pair X Y) for all X and Y is a chore
16:20:31 <pumpkin> HEAD has it as of a few weeks ago
16:21:13 <slava> dons: or at least C preprocessor :)
16:22:46 <Absolute1> Is it possible to define data definitions in ghci?
16:22:50 <Absolute1> let doesnt work
16:22:52 <pumpkin> no
16:23:24 <Absolute1> so you guys just use and editor and ghci for testing?
16:23:30 <pumpkin> yup
16:23:33 <Absolute1> ghci is sort of limited
16:23:34 <opqdonut> and quickcheck
16:23:40 <opqdonut> how is ghci limited?
16:23:45 <skorpan> and a whole lot of love
16:23:55 <Absolute1> you can't define data definitions
16:23:56 <opqdonut> well yeah, you can't define new datatypes but that's about the only thing
16:23:57 <Absolute1> :)
16:24:06 <pumpkin> and qualified imports
16:24:09 <pumpkin> which bugs me more
16:24:09 <Absolute1> and you need to add let infront of all bindings
16:24:15 <hatds> I don't think ghci can do FFI :)
16:24:21 <dobblego> Absolute1, a bit like you're in IO
16:24:21 <hatds> maybe I'm wrong though
16:24:23 <skorpan> ghci also can't do TH
16:24:25 <opqdonut> Absolute1: oh yeah, those four letters are horrible :
16:25:05 <ray> and you can't evaluate expressions in ghci either!
16:25:10 <ray> oh wait
16:25:13 <hatds> lol
16:25:37 <skorpan> can you do concurrency in ghci?
16:26:09 <hatds> I don't see why not
16:26:12 <Absolute1> how does haskell compare to F#?
16:26:16 <_JFT_> skorpan: you can run many ghci ;)
16:26:22 <hatds> Absolute1: greater than
16:26:23 <skorpan> hehe
16:26:40 <skorpan> hm, i just remembered i saw this video with someone making music in ghci
16:26:41 <Berengal> ghci is compiled with -threaded now?
16:26:48 <skorpan> so i guess you *can* do concurrency in ghci
16:27:09 <skorpan> [00:47] <yaxu> http://blip.tv/file/2148373 # more haskell music
16:27:10 <Berengal> ghci can do concurrency, but I'm not sure if it uses more than one OS thread
16:27:53 <danra> hello
16:28:06 <hatds> hi
16:29:07 <danra> anyone got to thinking about typeclasses *implementation* hierarchies?
16:29:28 <danra> if i have a type class with 6 functions, 2 of them defaultly implemented
16:29:32 <Absolute1> What does fff do in example2: http://www.zvon.org/other/haskell/Outputsyntax/data_reference.html ?
16:29:46 <pumpkin> danra: how do you mean?
16:29:47 <Absolute1> the type is AAA is that a type?
16:30:03 <danra> i would like to be able to "derive" a type class which defaultly implements another function
16:30:28 <mreh> i am trying to import a record type, am i doing something wrong if i just type the name of the type in the import declaration?
16:30:31 <danra> maybe even override the implementation of others
16:30:35 <pumpkin> danra: hmm, typeclasses already do that?
16:30:50 <danra> pumpkin: really? :)
16:31:01 <pumpkin> you can provide default implementations for any typeclass method
16:31:05 <danra> how can i define a derived typeclass?
16:31:11 <pumpkin> they can be mutually defined too
16:31:29 <pumpkin> you can't derive in the OO sense, but you can make one typeclass have constraints on other typeclasses
16:32:16 <danra> pumpkin: could you ref me to read about it somewhere?
16:32:46 <pumpkin> danra: look at how Eq is implemented: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Classes.html#Eq
16:33:19 <kynky> as in the default of what /= is ?
16:33:53 <gnuvince_> What would be a Haskellish implementation of this program: http://www.reddit.com/r/programming/comments/8mfh7/terrible_ironpython_20_and_pretty_good_jython_25/
16:34:45 <slava> gnuvince_: considering the result of constructing the tree is never used, I think the haskell equivalent would be an empty program
16:34:48 <danra> pumpkin: I don't see how Eq is a good example
16:35:06 <mreh> i've imported the data type succesfully, and GHC tells me the constructor ins't in scope
16:35:06 <mreh> it didn't complain when I did the import
16:35:28 <danra> pumpkin: I'm not just looking for default implementations
16:35:48 <mmorrow_> ghci does FFI, concurrency/parallelism, and TH :)
16:35:59 <pumpkin> danra: I guess I misunderstood though
16:36:01 <pumpkin> *then
16:36:12 <pumpkin> you can still put constraints on class definitions
16:36:21 <danra> pumpkin: I'm looking to be able to define a type class with some default implementations, then derive another type class with some more default implementations of the functions defined before in the derivee typeclass
16:36:28 <pumpkin> oh
16:36:31 <kynky> like abstract methods in java ?
16:36:35 <roconnor> gnuvince_: what does the program do?
16:36:37 <pumpkin> I don't think that's possible
16:36:48 <gnuvince_> roconnor: it shows that Python is doggone slow :)
16:36:59 <danra> I think it would be helpful
16:37:05 <slava> it doesn't do anything, which is why its a bad benchmark
16:37:13 <slava> a benchmark should compute a result, at least
16:37:17 <gnuvince_> roconnor: more seriously it constructs a binary tree of depth n (given at the command line) and returns the number of nodes.
16:37:32 <danra> kynky: don't know java very well, but I guess so. It's also like a (good part of) inheritance in C++
16:37:48 <EvilTerran> mreh, import Module (DataType (..)) to import all the constructors along with the type
16:37:53 <roconnor> gnuvince_: is that a global variable I see?
16:37:59 <danra> deriving type classes this way ensures you have an IS-A relationship
16:38:06 <mreh> EvilTerran: oh
16:38:11 <danra> when still getting the benefits of reusing code
16:38:14 <EvilTerran> mreh, you also have to export it like that for that to work
16:38:17 <gnuvince_> roconnor: pretty much, yeah.
16:38:26 <EvilTerran> mreh, and exporting it will make it imported by default, of course
16:38:48 <pumpkin> danra: can you give a concrete example? I can't think of a case where that would help, but I may be thinking of wrong still
16:38:59 <roconnor> gnuvince_: ugh.  Anyhow, I'll try to write the program in Haskell.
16:39:03 <mreh> EvilTerran: Export will make it imported, but from where?!
16:39:52 <EvilTerran> mreh, you can also write "module Module (DataType (Constructor1, Constructor2)) where" to only export certian constructors
16:40:10 <danra> pumpkin: let's say I want a hierarchy of type-class implementations for cars
16:40:26 <danra> there's a base type class for everything a car can do
16:40:35 <danra> which gives some default implementations
16:40:43 <pumpkin> but typeclasses don't really correspond to OO notions of inheritance
16:41:05 <pumpkin> interfaces are already a bit of a stretch
16:41:18 <danra> then ferraris and mercedeses all have the same exhaust system so we can have a default implemenation for the exhaust function
16:42:09 <danra> typeclasses are great for doing inheritance in a way that is sure to have an IS-A relationship, as opposed to C++ inheritance
16:42:26 <danra> don't know java interfaces so well so I shouldn't talk about them...
16:42:48 <slava> danra: a java interface is like a C++ class where all methods are pure virtual and there are no instance variables
16:43:03 <hatds> you can do any sort of inheritance in Haskell.  Don't think you have to hijack typeclasses to do it all though
16:43:16 <kynky> multiple inheritance ?
16:43:49 <danra> hatds: how can i have a hierarchy of inhereting classes in haskell?
16:43:57 <roconnor> @hoogle execWriter
16:43:57 <lambdabot> Control.Monad.Writer.Lazy execWriter :: Writer w a -> w
16:43:57 <lambdabot> Control.Monad.Writer.Strict execWriter :: Writer w a -> w
16:43:57 <lambdabot> Control.Monad.Writer.Lazy execWriterT :: Monad m => WriterT w m a -> m w
16:44:11 <roconnor> @hoogle getSum
16:44:12 <lambdabot> Data.Monoid getSum :: Sum a -> a
16:44:21 <danra> hatds: with deriving classes implementing base class functions?
16:44:22 <hatds> basically, use dictionaries like how typelcasses are implemented
16:44:33 <hatds> and choose to deviate from typeclasses however you want
16:44:54 <danra> hatds: example?
16:45:22 <hatds> http://www.haskell.org/haskellwiki/Video_presentations
16:45:23 <roconnor> gnuvince_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5139
16:45:27 <Cale> I'm not sure I understand that remark either...
16:45:48 <hatds> the slides for A taste of haskell explains the dictionary passing implementation
16:46:08 <Cale> danra: Haskell doesn't come with a notion of subtyping.
16:46:21 <solrize_> :t tell
16:46:22 <mreh> how can you export a datatype that doesn't have any definition
16:46:22 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
16:46:32 <solrize_> @help tell
16:46:32 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
16:46:32 <mreh> there is a comment next to in the source --abstract!
16:47:02 <Cale> danra: An important thing to notice is that the use of the words 'class' and 'instance' in Haskell are essentially unrelated to their uses in various OO languages.
16:47:12 <danra> Cale: but it seems to be able to do so very easily, by enhancing type classes slightly
16:47:43 <danra> Cale: By deriving type classes I just mean to be able to use the base type class's default implementations
16:47:51 <opqdonut> well "sub" interfaces can be defined like "instance Foo a => Bar a where", but this doesn't allow overriding
16:48:13 <opqdonut> i say interfaces because they are what haskell typeclasses correspond to most closely
16:48:31 <danra> opdoqonut: It also doesn't allow overriding of non-implemented functions
16:48:46 <Cale> danra: It might be easier to translate OO classes into Haskell datatypes, where you keep a record of the various methods available.
16:48:57 <FunctorSalad> overriding interfaces?
16:49:44 <Cale> danra: and then subclasses get translated into some combination of constructing a new larger datatype with more fields, and defining the methods differently
16:50:55 <danra> Cale: I guess there's a reason that data types can't be derived? Haven't thought about it thoroughly but with typeclasses it could be a mess
16:51:09 <danra> combined with type classes, that is
16:51:19 <Cale> derived?
16:51:46 <FunctorSalad> "class IsFoo a where get_Foo_vtable :: a -> Foo_vtable a"? ;o
16:51:47 <danra> sorry, subclassed
16:52:20 <pumpkin> FunctorSalad: that sounds like loadsa fun
16:52:30 <pumpkin> FunctorSalad: reminds me of agda a bit :P
16:52:34 <hatds> All these sorts of design question are less of a mess if you don't use any special vocabulary at all.  Everything like this in Haskell will be implemented (either explicitly by you or implicitly by Haskell) by passing functions as arguments
16:52:34 <Cale> danra: Subtyping is awkward to mix with type inference.
16:52:35 <pejo> danra, it's not trivial to put subtyping in a sensible way into GHC, but it can probably be done.
16:53:16 <Cale> It tends to drastically weaken the effectiveness of type inference, forcing the programmer to annotate many more types explicitly.
16:53:37 <danra> pejo: maybe subtyping in general isn't easy, but subtyping type classes implementations seems really easy to me
16:54:13 <pejo> Cale, what would those annotations be in general?
16:54:21 <FunctorSalad> hatds: yeah, it seems there are enough alternatives for code reuse in haskell that implementation inheritance isn't necessary
16:54:44 <hatds> yea
16:54:56 <pumpkin> it seems like instead of the type inference engine spitting out one constraint, it'd have to spit out all the superclasses of that constraint too, and make sure to always pick the most general of all the superclasses, given other constraints
16:55:08 <pumpkin> (to infer "subclasses")
16:55:29 <danra> pumpkin: yup :)
16:55:42 <danra> FunctorSalad, what alternatives?
16:55:47 <FunctorSalad> (one thing that's still missing though are superclass default for typeclasses...)
16:55:56 <Cale> pejo: hm? Type annotations as usual.
16:56:09 <Cale> pejo: Except that you're forced into actually typing them :)
16:56:49 <gnuvince_> @index tell
16:56:50 <lambdabot> Control.Monad.Writer, Control.Monad.RWS
16:56:52 <pejo> Cale, would it be the same annotations as normal GHC would infer most of the time?
16:57:01 <danra> FunctorSalad, what do you mean by superclass default for typeclasses?
16:57:32 <Cale> pejo: yeah
16:57:49 <pejo> Cale, so infer the Haskell types instead of the most general type then. :-)
16:58:01 <FunctorSalad> danra: I mean that you could have Functor a superclass of Monad, but don't require a Functor instance decl for a Monad, because fmap defaults to "fmap f x = x >>= return .f"
16:58:12 <gnuvince_> @index execWrite
16:58:12 <lambdabot> bzzt
16:58:13 <pumpkin> that'd be nice
16:58:28 <FunctorSalad> not a big deal for Functor/Monad, but it matters if you want to make very fine-grained class hierarchies...
16:59:59 <FunctorSalad> "<danra> FunctorSalad, what alternatives?" <-- was there some specific problem under discussion?
17:00:54 <danra> FunctorSalad, you're right, but why not *allow* to access the Functor instance?
17:02:06 <FunctorSalad> you could use the Functor instance in the Monad instance decl if Functor was a superclass of Monad...
17:02:22 <FunctorSalad> maybe you mean something else by 'access'?
17:02:40 <roconnor> gnuvince_ it was supposed to be execWriter
17:02:50 <danra> FunctorSalad, I do mean something else. I mean access from within the type class declaration
17:03:24 <gnuvince_> roconnor: yeah, I found it.  However, I cannot get the code to compile :(
17:03:38 <roconnor> gnuvince_: {- TODO imports -}
17:03:43 <roconnor> let's see
17:03:49 <roconnor> import Control.Applicative
17:03:49 <danra> That way an instance of Monad would use either Functor's default function implementations, *or* Functor's function implementations which are provided by the Monad type class
17:03:56 <schoenfinkel> danra: you want to override something in the definition of a Functor?
17:03:57 <roconnor> import Control.Monad.Writer
17:04:03 <danra> yes
17:04:09 <roconnor> import Data.Monoid ?
17:04:17 <roconnor> @index getSum
17:04:17 <lambdabot> bzzt
17:04:18 <danra> or maybe even just override non-implemented functions
17:04:19 <gnuvince_> roconnor: I mean, after that
17:04:22 <roconnor> @hoogle getSum
17:04:22 <lambdabot> Data.Monoid getSum :: Sum a -> a
17:04:23 <schoenfinkel> it would be madness in that case, of course.
17:04:26 <danra> which could be simpler
17:04:35 <roconnor> gnuvince_: oh what's the error?
17:04:59 <gnuvince_> roconnor: node expects a BTree, it's passed an m BTree
17:05:02 * MonadBaastad prefers "fmap f x = ap (return f) x" instead... ;p
17:05:55 <schoenfinkel> class Functor f where fmap :: (a -> b) -> f a -> fb
17:06:22 <roconnor> gnuvince_: hmm
17:06:56 <roconnor> ah
17:06:56 <schoenfinkel> danra: what am I going to over-ride?
17:07:21 <roconnor> gnuvince_: well, I found an error
17:07:28 <roconnor> gnuvince_: I think
17:07:45 <roconnor> > getSum (7 `mappend` 7)
17:07:47 <lambdabot>       No instance for (Num (Sum a))
17:07:47 <lambdabot>        arising from the literal `7' at <i...
17:08:07 <roconnor> gnuvince_: replace "tell 1" with incCounter, and ...
17:08:23 <roconnor> gnuvince_: "incCounter = tell (Sum 1)"
17:08:34 <roconnor> ... "tell (Sum 1)" has a nice ring to it.
17:08:44 <hatds> :)
17:08:44 <danra> shoenfinkel, Instead of List doing the instantiation for fmap, you could have a ListClass class type doing the instantiation
17:08:53 <danra> type class
17:08:55 <danra> sorry :()
17:09:06 <pumpkin> huh?
17:09:17 <Badger> goat
17:09:42 <gnuvince_> roconnor: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5142
17:10:01 <danra> Instead of List doing the instantiation for fmap, you could have a ListClass type class doing the instantiation, which would give a base for all sorts of list data types
17:10:17 <solrize_> my version uses State and is almost instant for n=10 and blows the stack for n=20
17:10:54 <solrize_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5143
17:11:06 <danra> ListFunctor will just be a specialized case of Functor
17:11:12 <roconnor> gnuvince_: ah I see.  oops
17:11:14 <solrize_> any idea how to fix it?
17:11:54 * MonadBaastad would, of course, write it as "fmap = ap . return"
17:12:13 <pumpkin> of course ;)
17:12:20 <roconnor> gnuvince_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5144
17:12:24 <roconnor> sorry for the error
17:12:31 <schoenfinkel> instead of instance Functor [] where fmap = map  we make a new class Functor a => ListClass a where listmap :: (a -> b) -> (fa -> fb)
17:12:36 <roconnor> good thing we have a type checker.
17:12:58 <pumpkin> o.O
17:13:03 <pumpkin> why?
17:13:11 <schoenfinkel> danra: then say instance ListClass [] where listmap = map
17:13:23 <pumpkin> that's the exact same type as the original fmap
17:13:29 <schoenfinkel> of course, in this case
17:13:51 * pumpkin is getting more and more confused by this talk
17:13:56 <roconnor> gnuvince_: oh the fact that my writer isn't strict will make my code slow for large input
17:13:58 <schoenfinkel> danra mentioned ListClass, I'm trying to figure out the idea
17:14:13 <danra> schoenfinkel, that would work, but *why* do you want to define another name?
17:14:30 * MonadBaastad prefers to wonder why we have a "Foldable" class, instead of "Data.Algebra"...
17:14:50 <gnuvince_> roconnor: starting the program with an argument of 0 causes a stack overflow
17:14:57 <danra> I want to be able to use the original fmap function from the Functor type class, but use the implementation which is defined in the ListFunctor type class
17:15:01 <roconnor> :(
17:15:01 <FunctorSalad> MonadBaastad: "Foldable" is specific for algebras of the list signature I think
17:15:04 <danra> ListClass = ListFunctor, my mistake
17:15:46 <schoenfinkel> what you want is something like, class Functor a => ListClass a   ... instance ListClass [] where I take it back about fmap
17:15:50 <FunctorSalad> MonadBaastad: there's support for general F-algebras in the multirec package
17:15:59 <danra> schoenfunkel: yes
17:16:07 <roconnor> gnuvince_: I guess you should use this code, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5143 , whoever wrote it.
17:16:11 <schoenfinkel> and say that in this case fmap is going to be something else
17:16:20 <schoenfinkel> but why say it's a functor is it isn't one?
17:16:22 <_JFT_> gnuvince, roconnor : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5145
17:16:28 <danra> it's just going to have a different default *implementation*
17:16:53 <Berengal> fmap doesn't have a default implementation...
17:17:09 <danra> it's just going to have *a* default *implementation*
17:17:09 <roconnor> _JFT_: I don't think that is a fair translation of the python.
17:17:13 <schoenfinkel> no, but we instanced listmaking as a functor
17:17:35 <schoenfinkel> so thats 'implementing' fmap in the case of [a]
17:17:35 <_JFT_> roconnor: well it does create a Tree ;)
17:17:36 <pumpkin> danra: = error "sorry no can haz fmap"
17:17:56 <gnuvince_> roconnor: it overflows as well.
17:17:56 <_JFT_> roconnor:  and it stays pure a little bit longer which is more idomatic of Haskell :D
17:18:13 <schoenfinkel> yes, this is a bad example, Functor is far too exalted to mess with anyway
17:18:16 <gnuvince_> I think I'll just abandon the idea of trying to make a Haskell version
17:18:21 <danra> schoenfinkel, yes, but i don't want to have the final data type of list
17:18:23 <roconnor> gnuvince_: really?
17:18:24 <roconnor> wow
17:18:38 * pumpkin is utterly confused by all this
17:18:38 <danra> i want to be able to reuse the listfunctor type class
17:18:41 <schoenfinkel> yes, I know it was something about cars
17:18:46 <danra> :)
17:19:03 <danra> just means I'm not good at explaining what's going on in my head :)
17:19:26 <gnuvince_> roconnor: Yeah, I had originally figured it would take 5-10 minutes to write a version and that it would totally kill the Python and Clojure versions
17:19:49 <_JFT_> roconnor: add strictness annoation to Node (!)
17:19:50 <gnuvince_> Over an hour later, and still no working program, I guess I'd better get back to preparing for my math exam tomorrow.
17:20:17 <roconnor> gnuvince_: doesn't stack overflow for me
17:20:17 <schoenfinkel> hmmm
17:20:23 <roconnor> gnuvince_: my code
17:20:57 <gnuvince_> roconnor: that's weird.  I'm on Arch Linux, 32 bit, GHC 6.10.3
17:21:27 <roconnor> The Glorious Glasgow Haskell Compilation System, version 6.8.2
17:21:35 <FunctorSalad> danra: I lost the thread too...
17:21:36 <roconnor> ghc --make -O2 -no-recomp Foo.hs
17:21:42 <_JFT_> roconnor, gnuvince : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5146
17:21:51 <pumpkin> -fforce-recomp ! :)
17:21:53 <roconnor> $ ./Foo 0
17:21:55 <roconnor> 1
17:22:12 <roconnor> gnuvince_: but I think my code needs to be optimized to work with larger inputs
17:23:05 <_JFT_> roconnor: just add strictness annotation to force the evaluation of the branches
17:23:51 <roconnor> _JFT_: the strictness annotation needs to go into the bind operation
17:24:03 <roconnor> @src Sum
17:24:03 <lambdabot> Source not found. Are you on drugs?
17:24:09 <roconnor> @src Data.Monoid.Sum
17:24:09 <lambdabot> Source not found. It can only be attributed to human error.
17:24:14 <roconnor> @hoogle runContT
17:24:14 <lambdabot> Control.Monad.Cont runContT :: ContT r m a -> (a -> m r) -> m r
17:24:18 <_JFT_> roconnor: which version are you working on? (on hpaste)
17:24:33 <roconnor> _JFT_: the writer monad one on hpaste
17:24:47 <EvilRanter> @slap EvilTerran
17:24:48 * lambdabot decomposes EvilTerran into several parts using the Banach-Tarski theorem and reassembles them to get two copies of EvilTerran!
17:25:10 <_JFT_> roconnor: then change "data BTree = Leaf | Node BTree BTree" to "data BTree = Leaf | Node !BTree !BTree"
17:25:26 <_JFT_> roconnor: your sub-trees are lazy right now
17:25:39 <roconnor> I don't care about the trees, they are not important.
17:25:50 <roconnor> the writer counter is what is important.
17:25:52 <_JFT_> maybe not but they are causing a space0-leak
17:26:02 <_JFT_> while the counter use them
17:26:27 <roconnor> The tree spaceleak is the same order as the size of the tree.
17:26:48 <roconnor> unless you cheat by sharing the binary tree to make it log-sized
17:26:50 <_JFT_> roconnor: true...
17:26:54 <roconnor> ... maybe that isn't cheating
17:30:48 <roconnor> gnuvince_:  importing Control.Monad.Writer.Strict makes my code 1000x faster
17:31:04 <roconnor> no change in the code.
17:31:19 <roconnor> @karma+ modules
17:31:20 <lambdabot> modules's karma raised to 1.
17:31:35 <_JFT_> roconnor: you were right the "strictness annotation didn't change a thing. My bad for insisting :(
17:31:48 <roconnor> now we know
17:32:47 <roconnor> $ time ./Foo 23
17:32:48 <roconnor> 16777215
17:32:49 <roconnor> real    0m0.005s
17:33:01 <roconnor> I think that blows python away?
17:33:22 <roconnor> and my laptop is 4 or 5 years old
17:33:23 <Taggnostr> what's that?
17:34:52 <roconnor> Taggnostr: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5147
17:35:17 <pumpkin> nice :)
17:35:18 <roconnor> Taggnostr: vs http://www.smallshire.org.uk/sufficientlysmall/2009/05/22/ironpython-2-0-and-jython-2-5-performance-compared-to-python-2-5/
17:35:47 <roconnor> @hoogle (a -> b -> m c) -> m a -> m b -> m c
17:35:48 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
17:35:48 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
17:35:48 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
17:36:09 <mmorrow_> @let mkT = fix (\k !n i f -> if i==(1::Int) then f(n::Int)(Node()[]) else k(n+1)(i-1)(\n t -> k(n+1)(i-1)(\n s -> f(n)(Node()[t,s])))) 0
17:36:09 <lambdabot>   Parse error
17:36:30 <Ycros> roconnor: it'll be interesting to re-do those once Google's unladen-swallow project is completed
17:36:35 <mmorrow_> @let mkT = fix (\k n i f -> n `seq` if i==(1::Int) then f(n::Int)(Node()[]) else k(n+1)(i-1)(\n t -> k(n+1)(i-1)(\n s -> f(n)(Node()[t,s])))) 0
17:36:37 <lambdabot>  Defined.
17:36:45 <mmorrow_> > mkT 15 const
17:36:47 <lambdabot>       Ambiguous occurrence `mkT'
17:36:47 <lambdabot>      It could refer to either `L.mkT', defin...
17:36:48 <pumpkin> that's pretty dense code
17:36:55 <roconnor> I am tempted by the idea of defining data Tree = Tree [Tree].  It's hard to tell what data type the Python really wants to be working with.
17:36:56 <mmorrow_> @let mkTree = fix (\k n i f -> n `seq` if i==(1::Int) then f(n::Int)(Node()[]) else k(n+1)(i-1)(\n t -> k(n+1)(i-1)(\n s -> f(n)(Node()[t,s])))) 0
17:36:57 <lambdabot>  Defined.
17:37:02 <mmorrow_> > mkTree 15 const
17:37:04 <lambdabot>   32766
17:37:14 <erikc> "I suppose if nothing else we have demonstrated in passing that Java can be faster than C for some non-trivial programs (like a Python interpreter) running a trivial program, like this benchmark." ? jython doesnt generate + jit bytecode?
17:37:17 <roconnor> Ycros: what Google project?
17:37:19 <mmorrow_> that one counts i think
17:37:28 <pumpkin> > mkTree 23 const
17:37:46 <nathanic> does anyone know of a super simple function like (parseInt :: String -> Maybe Int)?  Hoogle finds Distribution.Text.simpleParse, but that seems like lot of dependency for not a lot of functionality
17:38:07 <pumpkin> :t reads
17:38:17 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:38:31 <pumpkin> :t listToMaybe . reads :: String -> Maybe Int
17:38:39 <lambdabot>     Couldn't match expected type `Int'
17:38:45 <lambdabot>            against inferred type `(a, String)'
17:38:59 <pumpkin> :t fmap fst . listToMaybe . reads :: String -> Maybe Int
17:39:05 <lambdabot> String -> Maybe Int
17:39:16 <nathanic> pumpkin: thanks!
17:39:24 <pumpkin> :)
17:39:35 <solrize_> is the State version reasonable and is there a way to get rid of the stack overflow?
17:41:19 <MonadBaastad> :t (join .) . liftM2
17:41:20 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
17:41:20 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
17:41:20 <lambdabot>     In the second argument of `(.)', namely `liftM2'
17:41:34 <MonadBaastad> Meh.
17:42:33 <pumpkin> aw
17:43:02 <Ycros> roconnor: http://code.google.com/p/unladen-swallow/wiki/ProjectPlan
17:44:49 <ray> oh my, the type checker has probable cause
17:45:16 <mmorrow_> pumpkin:
17:45:19 <mmorrow_> [m@monire t]$ time ./T 23
17:45:20 <mmorrow_> 8388606
17:45:20 <mmorrow_> real	0m3.490s
17:45:34 <pumpkin> different answer from roconnor's one :o
17:45:49 <pumpkin> > 2 * 8388606
17:45:52 <lambdabot>   16777212
17:46:06 <pumpkin> almost!
17:46:36 <roconnor> pumpkin: see, when you don't follow the python code, you get the wrong answer.
17:46:49 * roconnor hopes his answer is the same as python's.
17:47:26 * pumpkin pokes thoughtpolice
17:47:30 <pumpkin> ping me when you come back :)
17:47:39 <mmorrow_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5148#a5148
17:47:59 <davidL>  is there a fast way to check if a float is even? taking its floor is expensive
17:48:53 <MonadBaastad> davidL: Maybe you shouldn't be using Floats. :)
17:49:28 * MonadBaastad only uses Floats if there's a "Root Beer" in front of it.
17:49:47 <kynky> dont floats wobble?
17:50:19 <mmorrow_> i followed that javascript code in the comment, which bails at 1, not 0
17:50:20 <bnijk> MonadBaastad: i'm confused
17:50:30 <pumpkin> the lack of associativity is painful
17:50:40 <mmorrow_> (i bailed at 0 first too, giving me (2*) like yours)
17:50:49 <pumpkin> 2 * x + 3?
17:51:07 <mmorrow_> the python code bails at 1 too
17:51:21 <ray> data Beer; data Root a b
17:52:06 <ray> {-# LANGUAGE EmptyDataDecls #-} too
17:52:22 <roconnor> {-# LANGUAGE EmptyBeerDecls #-}
17:52:39 <ray> that's an extension i could do without
17:52:47 * pumpkin isn't a big fan of beer
17:53:12 <pastorn> roconnor: what cool features does that give you?
17:53:19 <ray> once you define a full pint of beer, it's immutable
17:53:21 <centrinia> Well, if u, v :: Float; then (((u+v)-v)+v)-v == (u+v)-v
17:53:33 <roconnor> pastorn: it drinks all the beer in your fridge.
17:53:56 <pastorn> ray: that sounds totally awesome
17:54:08 <pastorn> roconnor: i hope it drinks it into your belly
17:54:12 <roconnor> nope
17:54:54 <roconnor> your program drinks it, then segfaults.
17:55:40 <ray> pumpkin: i'm too much of a drunkard for something as wimpy as beer, usually
17:55:42 <pastorn> doesn't sound very useful, wouldn't it be better with... hmm... say
17:55:56 <pumpkin> ray: yeah, I only drink 151, no water for me
17:56:02 <pastorn> instance Monad BallmersPeakM where ...
17:56:33 <codolio> You need to upgrade your beer.
17:57:01 <pumpkin> I threw a beer event this afternoon
17:57:05 <pumpkin> didn't drink any of it :/
17:57:31 <centrinia> Why wasn't I invited?
17:57:38 * MonadBaastad is just glad pumpkin didn't "throw *UP* a beer..." ;p
17:57:50 <pumpkin> centrinia: I think it'd take you a while to get here :)
17:57:51 <mmorrow_> dolio: when you're codolio it's even more co because you're alway green as dolio, yet your alter ego is blue
17:58:20 <dolio> Is blue the opposite of green?
17:58:20 <centrinia> If there is free beer, then distance is no object.
17:58:24 <MonadBaastad> Codolio? Who's that - the Coolio of Code? ;p
17:58:33 <dolio> I thought orange was the opposite of blue, and red was the opposite of green.
17:58:37 <pumpkin> it's dolio's dual
17:58:40 <pumpkin> dualio
17:58:54 <mle> yellow
17:58:59 <centrinia> Red is the opposite of cyan.
17:59:07 <pumpkin> depends whether you're in additive color
17:59:11 <mle> purple is the opposite of green
17:59:12 <ray> what's the identity color
17:59:15 <mle> we're in additive color.
17:59:21 <mmorrow_> dolio: not that they're opposites per se, just that i just realized i associate names with the color xchat happens to give them, and you looked weird wearing blue
17:59:40 <pumpkin> http://en.wikipedia.org/wiki/Subtractive_color vs. http://en.wikipedia.org/wiki/Additive_color
17:59:46 <pumpkin> (for anyone not aware)
17:59:46 * mmorrow_ wonders how xchat decides
17:59:52 <mmorrow_> pumpkin is blue
17:59:59 <pumpkin> I'm orange on my client
18:00:00 <ray> shouldn't it be additive color and multiplicative color?
18:00:02 <pumpkin> seems appropriate
18:00:08 <pumpkin> ray: guess not
18:00:18 * mmorrow wonder what color he is now
18:00:25 <pumpkin> still blue over here
18:00:26 <roconnor> subtractive colour should be multipicative colour.
18:00:35 <dolio> Konversation retains colors when people change nicknames. So sometimes I have to wait until I restart for people to have the right color.
18:00:44 <pumpkin> ugh, KDE
18:00:49 <pumpkin> :)
18:01:05 <kynky> lol
18:01:09 <mmorrow> i'm making a note to look how xchat assigns colors
18:01:27 <Gracenotes> YOU ARE ALL WHITE
18:01:32 <Gracenotes> to me
18:01:36 <pumpkin> Gracenotes: :o
18:01:38 <pumpkin> racist!
18:01:41 <Berengal> Gracenotes: Rather racist, isn't it?
18:01:45 <kynky> be good if it was open source :P
18:01:52 <Gracenotes> it's okay, the background is black
18:01:56 <ray> so is white the identiy color under addition?
18:02:04 <ray> i don't understand that color stuff at all
18:02:12 <ray> wait, i think it's black
18:02:18 <Berengal> Has to be black
18:02:19 <kynky> colour!!
18:02:32 <pumpkin> u is the identity infix
18:02:52 <Berengal> I don't understand that python tree code...
18:02:56 <Berengal> It makes no sense
18:02:59 <Gracenotes> actually it's "color". moran
18:03:22 <kynky> thats not what my mum says
18:03:30 <defun> Assuming that I had a text file with arbitrary data, and then I had a segment of haskell code (distinguished from the arbitrary data), how would I execute RunGHC on that code?
18:03:33 <ray> so i guess white is the identity under "subtraction", which i have renamed to multiplication
18:03:37 <Gracenotes> :o
18:03:39 <centrinia> You people are too limited by your perception of the electromagnetic spectrum. I can see any form of radiation from light-year-long radio waves to Planck energy photons.
18:03:46 <pumpkin> lol
18:04:08 <pumpkin> centrinia: so why didn't you sense my beer event? I made sure to send out a huge EM pulse just before it
18:04:27 <mmorrow> what color is AM radion 590 ?
18:04:29 * roconnor can't tell the difference between Planck energy photons and pairs of tiny blackholes.
18:04:32 <mmorrow> *radio
18:04:54 <centrinia> Well, it is a little noisy. :(
18:05:13 <Gracenotes> color, the topic of so much philosophical talk
18:05:16 <centrinia> All I see is white. :O
18:05:22 <ray> radio is red
18:05:30 <pumpkin> really dark red
18:05:31 <AMradion590> mmorrow:
18:05:43 <centrinia> Radio is more infrared than infrared.
18:05:51 <kynky> sureoly white is just seeing all the colours
18:06:21 <mmorrow> i picture it as the same color as a tv with just static on it
18:07:22 <Gracenotes> what's the phrase for the philosophical concept that considers why certain colors tend to incite certain emotional responses?
18:07:39 <kynky> l
18:07:42 <ray> berkelian idealism
18:07:43 <Gracenotes> "red" the commonly used example
18:07:46 <kynky> lsd
18:07:57 <Gracenotes> no... it's rather generic.
18:08:27 <mmorrow> red frequency is more visible to the human eye, than green or blue
18:08:32 <defun> anybody?
18:08:44 <mmorrow> it's both why it is, and why poisonous stuff is red
18:09:40 * FunctorSalad likes colors
18:09:40 <pumpkin> nah, green is most visible
18:09:45 <FunctorSalad> pumpkin: yep
18:10:04 <kynky> bt in uk did a study years ago in what would be most identifiable colour for theor fellt of cars and vans, they used to be yellow, but the study found that grey was, so they changed the fleet to grey
18:10:05 <mmorrow> no way jose
18:10:06 <FunctorSalad> http://en.wikipedia.org/wiki/File:Luminosity.png
18:10:19 <pumpkin> our sun is green
18:10:28 <Gracenotes> I FOUND IT! http://en.wikipedia.org/wiki/Qualia
18:10:54 <dolio> Qualia isn't about colors inciting emotional responses.
18:11:03 <Gracenotes> fine. close enough.
18:11:19 <dolio> It's about philosphers sitting around considering the 'essence of redness' and stuff like that.
18:11:23 <Cale> http://www.youtube.com/watch?v=yL_-1d9OSdk -- this is old, but it's still funny :)
18:11:26 <FunctorSalad> if it has any effect, it isn't qualia ;)
18:11:26 <pumpkin> lol
18:11:44 <centrinia> What is the 'essence of Qualia"?
18:12:02 <Gracenotes> dolio: it is very related
18:12:24 <Gracenotes> and by "emotional response" I don't mean getting all flustered or something; I mean essentially connotations
18:12:37 <roconnor> Does qualia presuppose dualism?
18:13:05 <roconnor> IIRC qualia isn't even connotations.  It is sensations.
18:13:15 <MonadBaastad> I thought yellow was the most visible color?
18:13:32 <kynky> blood = red = danger, then are the stop signs on vulcan green?
18:13:45 <FunctorSalad> roconnor: sensations as far as they don't have any physical consequences...
18:13:56 <FunctorSalad> including neuron activity and stuff
18:14:00 <FunctorSalad> but IANAP
18:14:13 <MonadBaastad> kynky: Thanks to the 'Trek reboot, there *are* no stop signs on Vulcan... ;p
18:14:37 <roconnor> FunctorSalad: well, I guess you might argue that the sentions give rise to free will then choosing some action which has a physical consequence.
18:14:42 <dolio> Were there before the reboot?
18:14:51 <roconnor> but I don't even believe in Qualia.
18:14:53 <kynky> MonadBaastad, only in that specific parallel universe
18:15:04 <roconnor> as such
18:15:56 <Gracenotes> qualia constitute a theory which relate to inexplicable associations of color. I don't see many of theories trying to deal with associations of color >_>
18:16:00 <Gracenotes> *other
18:16:37 <roconnor> ... maybe there is some definition of qualia that I'm not familiar with
18:17:42 <mmorrow> you're right, it is green
18:18:01 <Gracenotes> well, I recall understanding them when I learned about them. But it is a not-so-coherent concept.. perhaps I'm trying to fit what I'm thinking about onto them
18:18:02 <mmorrow> i coulda sworn i knew it was read for some reason
18:18:09 <dolio> I'm not sure why you'd ask a philosopher why we have certain automatic associations between emotions and colors.
18:18:10 <FunctorSalad> red destructinates night vision least, I think
18:18:12 <roconnor> Gracenotes: I think qualia isn't the word you are looking for.
18:18:32 <Gracenotes> how would you describe qualia?
18:19:26 <roconnor> Gracenotes: quale is a conscious sensation of something.
18:19:46 <roconnor> a quale is a conscious sensation of something.
18:20:04 <kynky> the concous snsaion of the mf bs ?
18:20:18 <aavogt> quails are another matter
18:20:24 <Gracenotes> r f lckng vwls?
18:20:31 <FunctorSalad> are you using the more moderate definition where it's left open whether "conscious" can be a functional thing?
18:20:47 <Cale> Chicken chicken chicken, chicken chicken chicken, chicken chicken. Chicken: chicken chicken.
18:20:49 <kynky> like the conscius sensation of the smell of bs ?
18:20:57 <Gracenotes> roconnor: and color used an example refers to..?
18:21:02 <roconnor> FunctorSalad: possibly.
18:21:06 <FunctorSalad> the more "extreme" definition would be that it is the aspect of conscious sensation seperate from any functional aspects
18:21:39 <roconnor> Gracenotes: a "red quale" is the sensation you experience when seeing red.
18:22:00 <roconnor> Gracenotes: a "bass quale" is the sensation you experience when hearing to a low pitch.
18:22:08 <roconnor> or eating a tasty fish.
18:22:10 <Gracenotes> I think this is what I'm referring to.
18:22:16 <MonadBaastad> defun: Is the means of distinguishing the Haskell equally arbitrary, or is there a pre-determined form. If you can choose it, you could just pretend it's Literate Haskell. :)
18:22:18 <Gracenotes> I'm just explaining it badly.
18:22:23 <roconnor> Gracenotes: ok
18:23:01 <Gracenotes> and I'm sure the concept is useless as a theory :) But the idea of associations with color, inverse spectrums, are still interesting
18:23:08 <roconnor> it is possible to experience colour quale of "imaginary colours" by direct stimulation of the brain.
18:23:38 <roconnor> or probably just the optic nerve.
18:23:48 <Berengal> roconnor: That's a very reductionist comment. Sure you're not just experiencing the "people prodding your brain" quale?
18:24:13 <Berengal> I also doubt the brain can see colours it can't...
18:24:35 <roconnor> Berengal: I'm not sure.  It is hard for me to describe quale since I don't really believe in it.
18:24:38 <MonadBaastad> Could we shuffle off the "SesquipeQualia" over to -blah, already? :)
18:24:42 <Berengal> Especially not by stimulating the optical nerves
18:25:07 <Berengal> roconnor: I'm sure there's some definition of it you'll believe
18:25:13 <roconnor> Berengal: you doubt that the brain can see colours that it can't see?
18:25:31 <roconnor> Berengal: I'm using "imaginary colours" as a technical term here.
18:25:38 <roconnor> ... I guess the quotes were unclear.
18:25:54 <roconnor> http://en.wikipedia.org/wiki/Imaginary_color
18:25:56 <Berengal> roconnor: colour is just a function of eletrical impulses interpreted by the brain
18:26:03 <Berengal> Ah
18:26:09 <MonadBaastad> defun: Are you familiar with Literate Haskell?
18:26:09 <roconnor> ``Non-physical, unrealizable, or imaginary colors are combinations of cone cell responses that cannot be produced by any physical light source.
18:27:04 <Gracenotes> hm. And suppose you manually prodded the cones..?
18:27:45 <Berengal> roconnor: Yeah, I get what you mean now. However, I don't think the adult brain will be able to see colours it hasn't seen yet
18:29:06 <roconnor> Berengal: I think it will have little problem with imaginary colours.  You will be like, whoa, that is really saturated green.
18:29:13 <roconnor> It's like being on LSD.
18:29:56 <Saizan> that's why LSD is so fun
18:30:05 <Berengal> roconnor: Not that I've ever been on LSD, but I can imagine that being true.
18:30:20 <kynky> well its just a wavelength at the end of the day, the term green just a qualatative term
18:31:07 <PetRat> I have a simple parser and would like to check if it is idiomatic and efficient. (I already checked that it works.) Description here: http://www.mibbit.com/pb/1Wy7Kw
18:31:31 <kynky> unit test ?
18:32:10 <PetRat> LSD didn't do a lot for me except give me "insights" which I wrote down, then read the next morning and threw away.
18:32:15 <PetRat> :)
18:32:27 <roconnor> Berengal: anyhow, ya there is might be some definition of qualia that I like.
18:32:55 <Berengal> roconnor: Let me know if you find one, since it'd probably solve the mind-body problem...
18:33:28 <FunctorSalad> PetRat: imho there are some actual insights with it...
18:33:33 <kynky> they used lsd in the fringe to see into parallel universes
18:33:50 <roconnor> Berengal: I wouldn't be too surprised if it actually something like a collection of connotations. :)
18:34:15 <Berengal> roconnor: Sort of like a category? :P
18:34:15 <roconnor> kynky: does that really work?
18:34:35 <PetRat> roconnor: as far as defining qualia, it would make sense to investigate it... that is, to investigate one's personal experience with a kind of detail and objectivity. Turns out that's what mindfulness meditation is.
18:36:04 <PetRat> Buddhists have been doing mindfulness meditation for a while, but there are a number of modern teachers and scientists who teach it as a skill separate from religion. imho a lot of the confusion over philosophy gets cleared up by an actual, detailed investigation of experience.
18:36:49 <roconnor> PetRat: I wish I learned more about that from Dr. Barendregt before I left the Netherlands.
18:36:56 <PetRat> FunctorSalad: I agree with you. I just meant to say it didn't do much for me.
18:37:10 <PetRat> I don't know Dr. Barendregt... what does he teach?
18:37:27 <roconnor> PetRat: he wrote the bible on the lambda calculus
18:37:53 <roconnor> He teaches Comp Sci. in theory.  Although I don't know if he teaches anymore.
18:38:09 <FunctorSalad> PetRat: I'm thinking of more "pre-lingual" things, not "facts" as such (like meditation in that regard)
18:38:09 <gwern> @src sum
18:38:10 <lambdabot> sum = foldl (+) 0
18:38:19 <roconnor> http://en.wikipedia.org/wiki/Hendrik_Pieter_Barendregt
18:38:31 <gwern> huh. isn't that grotestquely inefficient a definition for sum?
18:38:49 <roconnor> hm, that page isn't very detailed.
18:38:56 <gwern> but it's general. that's good
18:39:06 <Berengal> gwern: The thing is, (+) is a class function...
18:39:07 <PetRat> roconnor: it sounds like you are saying he talked about meditation as well?
18:39:44 * gwern is just pondering how you can sum [n..m] by doing (n+m)*(length [n..m])
18:39:48 <roconnor> PetRat: nowadays he studies consciousness.
18:40:05 <roconnor> http://www.fnds.cs.ru.nl/fndswiki/Mind-Brain-Mindfulness
18:40:11 <idnar> uh
18:40:15 <roconnor> ``The objective of the Mind-Brain and Mindfulness Meditation Research Team at the Faculty of Science and the University Medical Center, Radboud University (Nijmegen, The Netherlands), is to contribute to the development of models of the mind that originate from the bridging of the scientific knowledge and research with the phenomenological and psychological knowledge derived from the contemplative traditions.
18:40:18 <Berengal> gwern: Isn't length [n..m] = m - n?
18:40:31 <gwern> Berengal: yeah, probably
18:40:35 <PetRat> roconnor: interesting stuff.
18:40:47 <idnar> > (sum [5..42], (5 + 42) * (length [5..42]))
18:40:48 <lambdabot>   (893,1786)
18:41:20 <MonadBaastad> Berengal, gwern: Plus one. :)
18:41:42 <gwern> oh sorry, length/2
18:41:59 <Berengal> Uh, yeah...
18:42:03 <dino-> I was reading this recently http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#type-class-misuse ..
18:42:04 <PetRat> I know that several philosophers have said it more elegantly than me, but I've always considered that how the brain works should be studied by combining science (outside, objective) and personal experience (inside, subjective).
18:42:19 <idnar> > (sum [5..42], (5 + 42) * (length [5..42] / 2))
18:42:20 <lambdabot>       No instance for (Fractional Int)
18:42:20 <lambdabot>        arising from a use of `/' at <i...
18:42:24 * gwern is suffering from badly from some sort of cold or allergies and so is not thinking all that straight
18:42:25 <dino-> And something is said in there about using existentials to support more than one Show behavior for something.
18:42:26 <idnar> > (sum [5..42], (5 + 42) * (length [5..42] `div` 2))
18:42:27 <lambdabot>   (893,893)
18:42:38 <dino-> "I do my best to avoid type classes, but I'm in the minority. In the long run, I think it's better to use existentials, as they let you define multiple instances for the same type. This usually makes more sense. For example, Show: why support only one, global way of printing things? I often need multiple ones."
18:42:51 <PetRat> As an example of what can go wrong when you don't consider both: many meditation studies give the following instructions to their subjects: "wait for me to attach the probes, then start meditating.".. but...
18:42:53 <dino-> I'm having a tough time trying to figure out what that would look like.
18:43:42 <gwern> #check \x y -> (sum [x..y], (x + y) * (length [x..y] `div` 2))
18:43:44 <gwern> @check \x y -> (sum [x..y], (x + y) * (length [x..y] `div` 2))
18:43:45 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
18:43:45 <lambdabot>           ...
18:43:46 <dino-> I wrote some code but it's clearly barking up the wrong tree.
18:43:56 <dino-> Does anyone here have an idea what that means above?
18:43:57 <gwern> hm
18:43:57 <PetRat> ..but.. for many meditation teachers, meditation is considered such a natural part of consciousness that after some practice you are meditating all the time. There really isn't such as thing as "the meditating brain" and the "non-meditating brain" And yet so many studies take that as a point of assumption.
18:44:03 <idnar> gwern: I think you want an ==
18:44:19 <gwern> @check \x y -> sum [x..y] == ((x + y) * (length [x..y] `div` 2))
18:44:19 <idnar> @check \x y -> sum [x..y] == (x + y) * (length [x..y] `div` 2)
18:44:20 <lambdabot>   "Falsifiable, after 4 tests:\n1\n1\n"
18:44:21 <lambdabot>   "Falsifiable, after 1 tests:\n-1\n-1\n"
18:44:28 <roconnor> PetRat: sounds like something he'd say
18:44:29 <idnar> heh
18:44:48 <idnar> > [1..1]
18:44:50 <lambdabot>   [1]
18:44:55 <aavogt> > [ 10..0]
18:44:57 <lambdabot>   []
18:45:01 <PetRat> roconnor: sounds interesting.
18:45:02 <gwern> > length [1..1] `div` 2
18:45:02 <idnar> oh
18:45:03 <lambdabot>   0
18:45:11 <gwern> there we go. it's div that is the issue
18:45:17 <idnar> @check \x y -> sum [x..y] == (x + y) * length [x..y]) `div` 2
18:45:17 <lambdabot>  Unbalanced parentheses
18:45:22 <idnar> @check \x y -> sum [x..y] == ((x + y) * length [x..y]) `div` 2
18:45:23 <lambdabot>   "OK, passed 500 tests."
18:45:51 <sclv> dino-: not sure if i'd agree wit what you pasted
18:45:55 <FunctorSalad> gwern: ghc -O2 produces this core in the int case: Data.List.$wsum' (eftInt 0 y_aTz) 0
18:45:56 <aavogt> > sum []
18:45:58 <lambdabot>   0
18:46:12 <FunctorSalad> not that I knew what "$wsum" and "eftInt" are
18:46:18 <dino-> sclv: The "I do my best.." is actually the page I was puzzling over, not understanding.
18:46:19 <centrinia> > product []
18:46:20 <lambdabot>   1
18:46:20 <FunctorSalad> (the y_aTz is the upper bound)
18:46:43 <Berengal> I assume $wsum' is strict sum?
18:47:06 <Berengal> eftInt = enumFromToInt
18:47:13 <FunctorSalad> right
18:47:22 <gwern> > (\x y -> ((x + y) * (x-y)) `div` 2) 1 10
18:47:23 <lambdabot>   -50
18:47:25 <sclv> I'd guess they meant that you pack the show function with the thing to be shown in an adt.
18:47:27 <Berengal> Again, assumption
18:47:32 <gwern> > (\x y -> ((x + y) * (y-x)) `div` 2) 1 10
18:47:33 <aavogt> @check \x y -> sum [x..y] == ((x + y) * length [x..y :: Double]) `div` 2
18:47:34 <lambdabot>   49
18:47:34 <lambdabot>   Couldn't match expected type `Double' against inferred type `Int'
18:47:37 <dino-> @paste
18:47:37 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:47:42 <gwern> > sum [1..10]
18:47:43 <lambdabot>   55
18:47:49 <FunctorSalad> (the input was: main = do { x::Int <- getArgs;  print $! sum [0..x] } )
18:47:53 <FunctorSalad> using System.SimpleArgs
18:47:58 <gwern> > (\x y -> (((x + y) * (y-x))) `div` 2) 1 10
18:48:00 <lambdabot>   49
18:48:11 <gwern> > (\x y -> ((x + y) * (y-x))) 1 10
18:48:13 <lambdabot>   99
18:48:16 <Berengal> showList :: [forall a. ((a -> String), a)] ?
18:48:31 <centrinia> > (\x y -> y^2-x^2) 1 10
18:48:32 <lambdabot>   99
18:48:39 <sclv> but... that doesn't actually use existentials. hmm.
18:48:51 <dino-> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5152#a5152
18:49:21 <Berengal> sclv: It does. You can't write that type without existentials
18:49:22 <dino-> But that code will not compile.
18:49:29 <dino-> That I pasted.
18:49:40 <Berengal> sclv: But you need to wrap it in a newtype as well for ghc to accept it
18:49:41 <bnijk> > 99
18:49:43 <lambdabot>   99
18:49:44 <bnijk> much faster ;)
18:50:16 <sclv> Berengal: you can just do this though: DataType a = Constr a (a-> String)
18:50:16 <kniu> So I came upon the paper "Types are Calling Conventions" on reddit.
18:50:18 <Berengal> newtype ShowPair = forall a. ShowPair (a -> String) a
18:50:20 <sclv> no existentials needed!
18:50:28 <sclv> you only need them if you want to hide the a.
18:50:39 <sclv> at which point you might as well just store the string itself...
18:51:08 <sclv> existentials are rarely really useful, but when they are, they really are.
18:51:11 <Berengal> sclv: Yeah, true. I don't really get this myself, I'm just trying to figure out how it works :)
18:51:14 <kniu> The writers, early on, hinted at a possible language feature where the calling convention is denoted in the type system.
18:51:24 <gwern> @check \x y -> length [x..y] == ((max x y) - (min x y))
18:51:25 <kniu> What's up with that?
18:51:26 <lambdabot>   "Falsifiable, after 0 tests:\n0\n0\n"
18:52:07 <Berengal> @check \x y -> length [x..y] == ((max x y) - (min x y)) + 1
18:52:08 <lambdabot>   "Falsifiable, after 5 tests:\n-4\n-5\n"
18:52:08 <kniu> If that were implemented, would it be possible to infer the correct or most efficient calling convention from the type?
18:52:26 <gwern> > sum [0..0]
18:52:27 <lambdabot>   0
18:52:41 <dolio> Doesn't jhc do that?
18:52:46 <thoughtpolice> @seen pumpkin
18:52:46 <lambdabot> I saw pumpkin leaving #haskell-blah, #haskell-in-depth, #darcs, #ghc and #haskell 37m 52s ago, and .
18:52:48 <centrinia> @check \x -> sum [-x..x] == 0
18:52:49 <lambdabot>   "OK, passed 500 tests."
18:52:49 <copumpkin> ohai :)
18:52:50 <thoughtpolice> @seen copumpkin
18:52:50 <lambdabot> copumpkin is in #haskell-blah, #haskell-in-depth, #concatenative, #darcs, #ghc and #haskell. I last heard copumpkin speak just now.
18:52:54 <dolio> It tracks whether things are evaluated or not in its intermediate type system.
18:53:02 <thoughtpolice> copumpkin: struggling with what?
18:53:04 <dolio> And such.
18:53:16 <gwern> @check \x y -> sum [x..y] == (x + y) * (((max x y) - (min x y)) `div` 2)
18:53:17 <lambdabot>   "Falsifiable, after 0 tests:\n1\n-2\n"
18:53:28 <bnijk> :t zip
18:53:29 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
18:53:38 <copumpkin> thoughtpolice: an apparent bug in GHC that has been left undisturbed for 3 years! due to it being preprocessor'ed out until x86_64 and darwin occurred together :P
18:53:51 <gwern> @check \x y -> sum [x..y] == (x + y) * (((max x y) - (min x y)) `div` 2)
18:53:52 <lambdabot>   "Falsifiable, after 2 tests:\n1\n-2\n"
18:53:59 <thoughtpolice> dolio: yeah, apparently john played with the idea of having jhc be an SML compiler too, so a rich intermediate language was designed
18:54:00 <dolio> Maybe I'm a bit fuzzy on what exactly the "calling convention" part is, though.
18:54:03 * dolio hasn't read the paper.
18:54:08 <bnijk> > map (\x y -> x^y^x^y) zip [1..20] [21..40]
18:54:09 <lambdabot>   Couldn't match expected type `[a]'
18:54:11 <gwern> > (\ x y -> (x + y) * (((max x y) - (min x y)) `div` 2)) 1 10
18:54:12 <lambdabot>   44
18:54:12 <thoughtpolice> copumpkin: ah :)
18:54:15 <bnijk> ^ how do i jam a list of tuples into a lambda x y
18:54:19 <gwern> 44? rats
18:54:20 <thoughtpolice> copumpkin: attempting to get a registered port?
18:54:25 <copumpkin> thoughtpolice: damn right!
18:54:31 <kniu> dolio, jhc compiles haskell, right?
18:54:36 <dolio> Yes.
18:54:38 <copumpkin> thoughtpolice: from igloo's tarball
18:54:44 <bnijk> 2-tuples
18:54:49 <kniu> I kind of meant annotations in the source language.
18:54:54 <bnijk> whatever they're called in haskell
18:55:00 <Berengal> > map (\(x, y) -> x^y^x^y) zip [1..20] [21..40]
18:55:00 <dolio> Oh.
18:55:01 <lambdabot>   Couldn't match expected type `[(t, t1)]'
18:55:14 <Berengal> > map (\(x, y) -> x^y^x^y) $ zip [1..20] [21..40]
18:55:21 <copumpkin> that looks intense
18:55:22 <bnijk> O.O
18:55:29 <lambdabot>   thread killed
18:55:43 <dolio> Well, it seems obvious to me that anything that's done in the intermediate language could be extended to let you give hints to the compiler in the source language.
18:55:46 <thoughtpolice> copumpkin: ah
18:55:55 <thoughtpolice> copumpkin: yeah, the RTS needs to be fixed in order to support a registered build
18:55:59 <copumpkin> thoughtpolice: but I'll need to rebuild that bit without this buggy thing
18:56:00 <Berengal> > map (uncurry (\x y -> x^y^x^y)) $ zip [1..20] [21..40]
18:56:14 <copumpkin> thoughtpolice: I don't think much (if anything) will need changing in the RTS, but I could be wrong :)
18:56:15 <lambdabot>   thread killed
18:56:15 <thoughtpolice> copumpkin: i've finally beaten killzone, so I'm darcs pulling my GHC updates now :)
18:56:19 <copumpkin> lol
18:56:23 <gwern> > (\y -> (1 + y) * (y `div` 2)) 10
18:56:25 <lambdabot>   55
18:56:36 <thoughtpolice> copumpkin: from what I've heard of ChilliX, there are some things that need to be taken care of
18:56:47 <copumpkin> thoughtpolice: hmm
18:56:53 <dolio> Having the compiler figure it out sufficiently itself would be the nice part.
18:57:39 <thoughtpolice> copumpkin: but I don't think it's anything major
18:58:00 <thoughtpolice> copumpkin: in particular, Adjustor.c will probably need to be modified, but you can use libffi as a stop-gap measure for that IIRC
18:58:12 <dolio> Of course, having a richer set of strictness controls in the source language would probably be nice, too, since you might never get a sufficiently smart compiler.
18:58:16 <thoughtpolice> (it's only slightly slower)
18:58:28 <copumpkin> thoughtpolice: why would it need to be changed though? can't we just steal the x86_64 from linux?
18:58:33 <copumpkin> (adjustor code)
18:59:27 <gwern> huh. I guess the equivalent of div in scheme is /. this seems to work: '(define quick-sum (lambda (n) (* (+ 1 n) (/ n 2))))'
18:59:32 <thoughtpolice> copumpkin: that would be the best case scenario, but throughout the RTS there is a bit of OS X strangeness that needs to be dealt with sometimes
18:59:40 <thoughtpolice> copumpkin: but it'll probably mostly be stolen, yes :)
18:59:41 <copumpkin> hmm, ok
19:00:02 <Berengal> gwern: scheme has rational numbers
19:00:15 <gwern> ?
19:00:22 <thoughtpolice> copumpkin: k, downloading the unregistered x86_64 bindist; hacking shall commence :)
19:00:25 <Berengal> Try (/ 3 2)
19:00:27 <thoughtpolice> copumpkin: what's your bug, btw?
19:00:28 <dino-> Thanks for poking at that existential thing.
19:00:49 <copumpkin> thoughtpolice: pprDynamicLinkerAsmLabel
19:00:52 <copumpkin> it's a GHC panic :)
19:00:59 <dino-> I still don't really get it, or what is desireable to achieve with it.
19:01:29 <thoughtpolice> copumpkin: building HEAD with the unregistered bindist fails with that?
19:01:31 <gwern> Berengal: 1.5
19:01:34 <mmorrow> copumpkin: is it assuming elf or something?
19:01:42 <Berengal> gwern: Right, so it's not div
19:02:03 <copumpkin> thoughtpolice: no, but the preprocessor stuff in that part of ghc (igloo's binary build) is messed up
19:02:03 <gwern> but my code seems to pass all the test cases. maybe div wasn't necessary
19:02:23 <Berengal> gwern: How does it handle (/ 1 3) by the way?
19:02:25 <copumpkin> thoughtpolice: I'll dig up the actual source file soon
19:02:29 <Jedai> dino-: ?
19:02:38 <gwern> Berengal: 0.3
19:02:53 <Berengal> gwern: No 0.3... or 1/3?
19:03:01 <Berengal> Just 0.3?
19:03:26 <gwern> just that
19:03:29 <dino-> Jedai: This: http://www.ninebynine.org/Software/Learning-Haskell-Notes.html#type-class-misuse  In particular the blue box.
19:03:44 <thoughtpolice> copumpkin: seems to be in ./compiler/cmm/CLabel.hs
19:03:50 <copumpkin> yeah, that's the one
19:03:56 <copumpkin> it doesn't have enough cases in that function
19:04:01 <thoughtpolice> copumpkin: ah
19:04:02 <copumpkin> and it fails on the catch-all with a panic
19:04:04 <roconnor> emacs's undo buffer drives me bonkers!
19:04:09 <thoughtpolice> copumpkin: so we'll need to fix that and make another bindist
19:04:23 <copumpkin> thoughtpolice: yeah, I'm doing that now on my mac pro
19:04:39 <dolio> Yeah. Worst undo system ever.
19:05:01 <thoughtpolice> copumpkin: k, tell me when the build is done and put it somewhere if you can
19:05:07 <copumpkin> sure
19:05:20 <thoughtpolice> copumpkin: you might also want to send a message to g-h-u in reply to Igloo about the bug and a fix
19:05:27 <thoughtpolice> (with the patch, of course)
19:05:29 <copumpkin> I've been chatting to him in #ghc :)
19:05:34 <copumpkin> but yeah, I'll submit a patch if it works
19:06:10 <Jedai> dino-: It's not really clear, also I disagree on the general usefulness of typeclass
19:06:23 <mwc> anybody built ghc6 on linux-ppc without encountering an R_PPC_REL24 relocation-truncated-to-fix error?
19:06:38 <mwc> building unregisterized
19:06:52 <dino-> roconnor, dolio: What does emacs do with undo? In Vim u rolls back through the undo stack and ^r goes the other way. How is this mess-upable?
19:07:10 <Jedai> dino-: Besides his complaint on the list of type of the same typeclass isn't really true, it's pretty easy to use an existential datatype to do that
19:07:26 <Jedai> dino-: Look at Layout in XMonad for instance
19:07:35 <roconnor> dino-: after typing stuff after undoing, then further undos will undo the undos that you have done.
19:07:49 <dolio> dino-: If you accidentally type something in the middle of a series of undos, you have to undo all of your undos, and then undo all of the un-undos before you can undo stuff from before you started.
19:07:55 <dino-> roconnor: oh boy, the undocursion
19:08:29 <dolio> Plus, C-x u is the shortcut, which is easy to screw up.
19:09:12 <Jedai> dolio: I use C-x _
19:09:28 <dolio> I'm not sure I see how that's better.
19:09:58 <dolio> The problem I have is having to change what modifier key I'm pressing, which results in mistakes.
19:10:31 <jeffz`> I think it's C-_ not C-x _
19:10:38 <jeffz`> C-_ is easier than C-x u
19:10:43 <Jedai> jeffz`: Right, sorry
19:10:45 <jeffz`> :)
19:10:48 <dolio> Oh, that would be better.
19:11:06 <copumpkin> bos: zomg lazy text!
19:11:21 <bos> yeppo!
19:11:22 <copumpkin> nice :)
19:12:03 <copumpkin> thoughtpolice: want to try building the unregistered one yourself?
19:13:28 <mmorrow> copumpkin: looking more at Adjustor.c/Asm.S, yeah it's essentially the same idea as that other code
19:13:34 <copumpkin> cool :)
19:13:35 <dino-> Jedai: I'm getting that that part of that page is 'eh, move along folks', which is fine. I wasn't sure what it was saying.
19:13:45 <copumpkin> mmorradjustor
19:13:55 <mmorrow> :)
19:15:58 <mmorrow> oh sweet, you can do a jmp foo(%rip) directly instead of mov'ing the address to an intermediate reg first (for some reason i just assumed you couldn't)
19:16:45 <copumpkin> :)
19:16:47 <Jedai> dino-: I think he says that typeclass are use too easily by beginners in Haskell, even for tasks for which they aren't really suited which is true, though he seems to push to far in the opposite direction
19:16:54 <dino-> I see, in vim, once you undo, then do something not undo-ish, the redo gets blown away. And it all seems to make sense. At least this many years down the road it does.
19:17:50 <idnar> dino-: you can move backwards and forwards between branches of history, though
19:17:59 <idnar> (in vim)
19:18:03 <dino-> Jedai: Absolutely, I've had that happen. Expecting them to be like OO interfaces or abstracts.
19:18:10 <dmead> hello channel
19:18:17 <dmead> @seen dmwit
19:18:17 <lambdabot> dmwit is in #haskell-in-depth, #xmonad and #haskell. I don't know when dmwit last spoke.
19:18:36 <dino-> idnar: You know, I don't think I have that much vimfu.. yet
19:19:07 <idnar> :undolist shows the leaves, g- goes backwards, g+ goes forwards
19:20:53 <copumpkin> ChanSevr: trying to harvest passwords?
19:20:54 <dino-> idnar: Oh there's a lot of stuff in :help undo
19:20:57 <dino-> I had no idea
19:21:15 <idnar> dino-: yeah, it's fun
19:21:22 <ChanSevr> no copumpkin trying to get freenode to block this account
19:21:38 <dino-> Ok, thanks again for the typeclass and existential talk.
19:22:05 <ChanSevr> figured if I joined the 15 largest channels on freenode it might create enough noise in #freenode that someone would fixed the banned nicks mask
19:22:23 <dolio> Wow, this is in the top 15?
19:22:38 <ChanSevr> according to searchirc.com
19:22:48 <copumpkin> we're often top 10 I think
19:22:51 <ChanSevr> http://searchirc.com/search.php?SCHANS=1&SSORT=SIZE&N=freenode
19:22:54 <copumpkin> depending on time of day
19:23:49 <ChanSevr> feel free to complain in #freenode ;)
19:24:43 <idnar> Chan Sever
19:33:23 <FunctorSalad> what about all the other misspelings?
19:38:26 <Jedai> FunctorSalad: I guess the idea is to alert about misspellings in general, not just this one
19:38:51 <FunctorSalad> ok
19:44:24 <hydo> Apparently, I have some sort of weird assumption of how takeWhile works.  If map fn list returns a list of [True,False,False,... ] then, logic has suggested to me, takeWhile fn list should return the elements for which fn evaluates to True... But I'm getting an empty list every time.  Might someone enlighten me?
19:44:48 <SamB_XP> hydo: you're thinking filter
19:45:01 <hydo> ah, ok... that makes sense.
19:45:04 <SamB_XP> hydo: takeWhile stops at the first False
19:45:09 <dolio> takeWhile (<5) [1,2,3,10,4,5,6]
19:45:12 <Jedai> hydo: takeWhile take only until the first False
19:45:13 <dolio> > takeWhile (<5) [1,2,3,10,4,5,6]
19:45:14 <hydo> ah ha ha
19:45:14 <lambdabot>   [1,2,3]
19:45:26 <hydo> Important distinction!
19:45:30 <hydo> Thanks a lot!
19:47:52 <roconnor> > 2^23
19:47:53 <lambdabot>   8388608
19:47:56 <roconnor> > 2^24
19:47:57 <lambdabot>   16777216
19:49:08 <solrize_> hydo you want filter, not takewhile
19:49:17 <solrize_> > filter odd [1..10]
19:49:18 <lambdabot>   [1,3,5,7,9]
19:49:48 <solrize_> anyone here use sqlite?
19:54:58 <Gracenotes> hm. Haskell doesn't have much dynamic loading, does it?
19:55:09 <copumpkin> depends
19:55:11 <copumpkin> hs-plugins
19:55:20 <Gracenotes> @hackage hs-plugins
19:55:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hs-plugins
19:55:25 <copumpkin> you could probably ffi to dlopen/dlsym quite easily :P
19:55:32 <Gracenotes> if you're just expecting an instance of the typeclass
19:55:34 <Gracenotes> for instance
19:55:56 <Gracenotes> ah, no hackage
19:56:31 <gwern> hs-plugins is deprecated
19:56:39 <Gracenotes> awz.
19:56:58 <dmwit> GHC API is the new hs-plugins.
19:57:15 <SamB_XP> I thought hs-plugins was, in fact, dead?
19:57:16 <copumpkin> ooh
20:00:38 <aavogt> @hackage plugins
20:00:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
20:01:17 <Jedai> Gracenotes: The next GHC will have shared library, it may become more interesting to do dynamic loading (currently, this is pretty heavy)
20:01:47 <Jedai> The RTS will be shared
20:01:59 <Gracenotes> ah.
20:02:40 * MonadBaastad was hoping to here that "The RTS will be televised." Ah, wel...
20:03:18 <gwern> MonadBaastad: I can tell you, however, that the revolution will not be telegraphed.
20:12:59 <Alpounet> @hackage stats
20:13:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/stats
20:13:33 <Alpounet> @hackage statistics
20:13:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/statistics
20:13:49 <Alpounet> @hoogle statistics
20:13:50 <lambdabot> No results found
20:15:54 <copumpkin> hstats
20:43:06 <roconnor> > logBase 2 1000000
20:43:07 <lambdabot>   19.931568569324174
20:43:16 <roconnor> > logBase 2 1000000000
20:43:17 <lambdabot>   29.897352853986263
20:48:01 <djd74> > logBase 2 1000
20:48:02 <lambdabot>   9.965784284662087
20:48:14 <djd74> > logBase 2 512
20:48:15 <lambdabot>   9.0
20:50:55 <roconnor> gnuvince_: heh, my Writer.Strict code takes 1 minute for depth 20000.
20:51:36 <roconnor> that's about 2^20000 nodes, which is a number so big that it would fill the entire size of the python chart.
20:51:46 <roconnor> > 2^20001
20:51:48 <lambdabot>   796055368067593318470861441238240490740954556098485187742685373130477271949...
20:51:59 <copumpkin> > length . show $ 2 ^ 20001
20:52:01 <lambdabot>   6021
20:52:38 <roconnor> > (length . show $ 2 ^ 20001) `div` 80
20:52:39 <lambdabot>   75
20:53:00 <Berengal> roconnor: Was this using the weird python definition of a binary tree?
20:53:18 <roconnor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5139#a5156
20:53:24 * dmwit is so lost right now
20:53:34 <roconnor> that is my current version I'm using.
20:55:15 <copumpkin> dmwit: ?
20:55:32 <roconnor> dmwit: gnuvince_ wanted a Haskell version of this python code: http://www.smallshire.org.uk/sufficientlysmall/2009/05/22/ironpython-2-0-and-jython-2-5-performance-compared-to-python-2-5/
20:55:46 <dmwit> roconnor: Thanks, that was the context I was hoping for. =)
20:56:01 <Berengal> roconnor: Unless there's something I'm not getting, you're saying your machine counted that high in a minute?
20:56:05 <roconnor> even though that code uses a global variable.
20:56:27 <roconnor> Berengal: hmm
20:56:47 <roconnor> It does seem like that, and also that seems impossible.
20:57:01 <roconnor> I wonder if there is too much sharing going on.
20:57:07 <Berengal> Yes, it seems very impossible
20:57:19 <Berengal> At least in this day and age
20:57:33 <Berengal> There has to be something else going on here
20:57:35 <roconnor> damn, I might have accidentally made my program run in logarithmic time
20:57:50 <Berengal> Hehehe
20:58:56 <roconnor> okay, I removed the replicateM
20:58:59 <roconnor> and used
20:59:12 <roconnor> make depth = do
20:59:13 <roconnor>  t1 <-(make (depth -1))
20:59:15 <roconnor>  t2 <-(make (depth -1))
20:59:16 <roconnor>  node [t1,t2]
20:59:20 <roconnor> But now it runs twice as fast ...
20:59:24 <roconnor> :^)
20:59:37 <roconnor> damn it
20:59:46 <roconnor> I don't know how to make this as slow as python.
20:59:47 <copumpkin> roconnor has discovered sub-constant time
21:00:02 <copumpkin> everything he adds to his code makes it faster!
21:00:49 <Berengal> I'd really like to know what's going on here...
21:00:52 <roconnor> Is GHC really constant lifting thingy my code?
21:01:05 <roconnor> I thought GHC almost never does that.
21:01:18 <Berengal> Perhaps it's time to dump core?
21:02:18 <roconnor> without -O2, it the parameter 17 takes 1 second.
21:02:32 <roconnor> WTF is -O2 doing?
21:02:58 <dolio> -O is that much slower than -O2?
21:03:17 <roconnor> oh I turned off O completely
21:03:20 <roconnor> :)
21:03:37 <roconnor> does any one use -O ?
21:03:57 <roconnor> okay -O is still exponentially faster.
21:04:06 <copumpkin> o.O
21:04:07 <Axman6> @remember roconnor Damn it, I don't know how to make this as slow as python.
21:04:07 <lambdabot> It is forever etched in my memory.
21:04:16 <dolio> I don't. But I almost never use -O0, either.
21:04:48 <roconnor> -O0 is not exponentially faster.
21:04:50 <dmwit> Is there a different number in each leaf node?
21:04:52 <hatds> is -O = -O1?
21:04:58 <dmwit> That seems like a really easy thing to check for small trees.
21:05:12 <hatds> and is -O0 = default?
21:05:16 <thoughtpolice> hatds: yeah
21:05:21 <roconnor> -O1 is exponentially faster, an I assume it is the same as -O
21:05:34 <Berengal> I don't notice any difference between -O0, -O and -O2...
21:05:39 <thoughtpolice> -O just implies -O1; -O should turn on most of your optimizations
21:05:44 <thoughtpolice> -O2 turns on some other ones
21:05:48 <roconnor> dmwit: there is actually nothing stored in the tree
21:05:52 <Berengal> Well, a slight difference, but it's within uncertainty
21:06:02 <roconnor> dmwit: we just do tell (Sum 1) and spit out the counter at the end.
21:11:31 <Berengal> How does one dump core again?
21:11:36 <Berengal> I forgot :/
21:12:23 <dolio> -ddump-simpl?
21:12:32 <dolio> Just install ghc-core.
21:15:06 <twb> Can I say something like #if GHC_VERSION > 6.6 ?
21:15:40 <roconnor> http://www.reddit.com/r/programming/comments/8mmam/i_tried_to_translated_the_ironpython_code_to/
21:15:51 <roconnor> fuck
21:15:55 <twb> I used Data.Function.on, but apparently this is not available for GHC 6.6 users.  Thus, I want to say "#if foo import Data.Function (on) #else on f g = ... #endif"
21:15:56 * roconnor fixes the title
21:16:26 <copumpkin> roconnor: is the answer correct?
21:16:37 <copumpkin> for counter
21:16:38 <Berengal> I like the title...
21:16:40 <roconnor> yes I beleive so.
21:16:44 <copumpkin> wow :)
21:17:33 <copumpkin> so Writer relies on Monoid, right?
21:17:39 <roconnor> http://www.reddit.com/r/programming/comments/8mmc7/i_tried_to_translate_the_ironpython_code_to/
21:17:40 <roconnor> better
21:17:42 <copumpkin> I've never actually used Writer explicitly
21:17:59 <copumpkin> speed?
21:17:59 <roconnor> copumpkin: sure
21:18:10 <copumpkin> sped maybe?
21:18:12 <thoughtpolice> twb: use __GLASGOW_HASKELL
21:18:16 <thoughtpolice> twb: er
21:18:18 <BMeph> twb: So, where do you want to say this funny-looking C macro of yours? ;)
21:18:18 <thoughtpolice> twb: use __GLASGOW_HASKELL__
21:18:21 <roconnor> copumpkin: speed?
21:18:27 <thoughtpolice> e.g. #if __GLASGOW_HASKELL__ >= 606
21:18:31 <copumpkin> roconnor: "I tried to translate the IronPython code to Haskell, but GHC exponentially speed up my code."
21:18:38 <twb> Thanks.
21:18:43 <roconnor> damn
21:18:45 <roconnor> I suck
21:18:56 <copumpkin> :)
21:19:16 <copumpkin> how long till the haskell haters come along for the party?
21:19:19 <roconnor> why do I do all my interesting haskell past midnight
21:19:36 <dolio> roconnor: It's possible make is subject to CSE.
21:19:58 <BMeph> roconnor: "I baked a slow-down brick in Haskell, but it eated it"? ;)
21:20:10 <roconnor> copumpkin: sped right?
21:20:13 <Asztal> does your Haskell code keep the binary tree in memory, or dispose of it as it's created (since it uses execWriter)?
21:20:14 <copumpkin> yup
21:20:17 <dolio> That's about all I've got.
21:20:36 <roconnor> http://www.reddit.com/r/programming/comments/8mmcu/i_tried_to_translate_the_ironpython_code_to/
21:20:58 <roconnor> Asztal: who knows.  Presumably it is tossed out as it is made.
21:21:43 <roconnor> dolio: I thought nothing was subject to CSE, but it is the only explaination that I can think of.
21:22:07 <roconnor> dolio: if CSE is happening my respect for GHC has actually gone up for once.
21:22:21 <roconnor> usually GHC is full of disappointment
21:22:25 <Berengal> Ugh, reading core is hard :(
21:22:25 <roconnor> but not this time.
21:22:56 <copumpkin> Berengal: using ghc-core?
21:23:02 <Berengal> copumpkin: Yes
21:23:13 <copumpkin> Berengal: what we need is ghc-plugins and bsp's awesome core visualizer plugin!
21:24:03 <copumpkin> Berengal: http://www.omega-prime.co.uk/files/GHC-Core-HTML.html is what I'm talking about :)
21:24:08 <Berengal> copumpkin: Would still feel like reading disassembly I believe, but with pretty colours, perhaps some jazz music?
21:24:19 <dolio> roconnor: If you munge the code for that down enough, it might turn into something like "let x = make (depth - 1) ; y = make (depth - 1) in ..." which might follow the very strict rules for when it does do CSE.
21:24:31 <roconnor> ooh
21:24:33 <copumpkin> Berengal: it's not that bad :) and I don't mind reading assembly anway
21:24:51 <roconnor> Lo-Lo-LoopBreaker
21:25:20 <Berengal> copumpkin: I do. I'm addicted to proper code, with nice variable names and cute abstractions
21:25:40 <copumpkin> Berengal: you can hire me to read your disassemblies if you want ;)
21:26:04 <Berengal> copumpkin: do you take cheetos? ;)
21:26:15 <copumpkin> lol, only the giant balls
21:26:26 <dolio> roconnor: 'let x = e in ... e ...' is the specific case for which it does do CSE. Might apply to 'case e of x -> ... e ...' as well.
21:26:53 <Berengal> copumpkin: I'm afraid we can't do business then. I'm not giving my balls away
21:27:04 <copumpkin> lol, I meant cheetos balls
21:27:09 <roconnor> BMeph: mmm, slow-down brick.
21:27:11 <Berengal> ;P
21:27:19 <copumpkin> http://www.taquitos.net/cheese_puffs/Giant_Cheetos
21:28:10 <roconnor> dolio: I'm still feeling kinda stunned right now.
21:28:52 <roconnor> I think dons will get a kick out of this.
21:29:26 <dolio> roconnor: You could try adding a parameter that it never uses, just to make the recursive calls look different, although I can't guarantee ghc won't get rid of those.
21:29:33 <copumpkin> it'd be nice to be able to tell GHC when to do CSE
21:29:38 <copumpkin> sometimes we can see it, if it's obvious
21:29:44 <copumpkin> but after a dozen transformations, GHC may see things we don't
21:30:27 <roconnor> dolio: this probably wouldn't work with the state monad would it?
21:30:48 <dmwit> copumpkin: Isn't that what let and where bindings are for?
21:31:10 <copumpkin> yes, but that's what I was saying... sometimes it may be obvious enough for us to make a let and factor common things out
21:31:21 <dolio> roconnor: That seems like it'd be less likely to do CSE, yes.
21:31:31 <roconnor> hmm
21:31:34 <copumpkin> and others it may not, depending on how much the code gets transformed by the simplifier
21:31:54 <dmwit> so... you want the compilation process to do IO?
21:32:02 <dolio> Or, that is, the kind of CSE that gives you exponentially better behavior here.
21:32:03 * dmwit does not wish for the same things copumpkin wishes for
21:32:26 <roconnor> dolio: damn, I was just being a bit too clever.  I thought I'd try out this niffty Writer thingy, and GHC exponentially implodes on me.
21:32:34 <copumpkin> dmwit: maybe through a pragma for each function or expression that we think may work
21:32:52 <copumpkin> dmwit: not necessarily an interactive compiler, although people don't seem to have that much of a problem with similar approaches in darcs
21:33:38 <copumpkin> I dunno, just categorically not doing it (except for very restricted cases) as happens now doesn't seem ideal
21:33:47 <roconnor> @type execState
21:33:48 <lambdabot> forall s a. State s a -> s -> s
21:34:45 <roconnor> Strict state is closer to the desired behaviour.
21:34:54 <roconnor> $ time ./Foo 20
21:34:55 <roconnor> Stack space overflow: current size 8388608 bytes.
21:37:59 <roconnor> @quote exponential
21:37:59 <lambdabot> ddarius says: Alternatively, it could be arrived at from the continuity properties of exponentials.
21:43:52 <Cale> Why is that a quote?
21:44:06 <roconnor> okay, I put in a seq
21:44:21 <roconnor> no more stack overflow with state
21:44:30 <roconnor> and no more exponential implosion.
21:45:49 <dolio> One can only wonder how GHC manages to do that CSE since Haskell isn't a pure language. :)
21:46:44 <roconnor> dolio: what is that a reference to?
21:47:11 <dolio> Reddit people.
21:47:34 <roconnor> reddit thinks that Haskell isn't a pure language?
21:47:42 <dolio> Certain people there do.
21:48:00 <roconnor> ./Foo 19  runs in less than 1 second.
21:48:08 <roconnor> that has 1048575 calls to node
21:48:19 <roconnor> still faster than the python numbers
21:48:36 <roconnor> gnuvince_ would be happy
21:48:58 <roconnor> although I still prefer the code with the unreasonable exponential implosion.
21:49:45 <dolio> That is a nice find, although it's not really something you could rely on.
21:49:59 <roconnor> no, I guess not
21:50:14 <Berengal> Yeah, once you wanted to do something else with the tree the implosion would probably explode back out again...
21:50:28 <roconnor> I was thinking, "I'll make it asymetric by writing "t1 <- inc >> (make (depth -1))"
21:50:37 <roconnor> but then I realized that that wouldn't work.
21:50:45 <roconnor> :(
21:50:56 * roconnor tries it anyways
21:51:32 <roconnor> yep
21:51:34 <roconnor> still too fast.
21:52:09 <roconnor> I guess there is a lesson in here about microbenchmarks.
21:52:52 <roconnor> hmm
21:53:04 <roconnor> I made a modification that causes a stack overflow
21:53:06 <roconnor> ...
21:53:20 <roconnor> No wonder gnuvince_ was getting a stack overflow
21:53:26 <roconnor> GHC 6.10 isn't doing this CSE!
21:53:46 <roconnor> Yes!  I *can* continue to be disappointed in GHC.
21:53:55 <dolio> :)
21:54:44 <roconnor> phew
21:54:57 <Berengal> I made a O(2^n) algorithm as well, but it doesn't produce the same answer as the python one: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5149
21:54:58 <roconnor> my lack of faith in GHC was shaken.
21:55:08 <roconnor> but now has thankfully returned.
21:55:33 <Berengal> roconnor: What do you mean 6.10 doesn't do the CSE?
21:55:42 <voker57_> what is CSE?
21:55:47 <roconnor> gnuvince_ said that when he tried my code he got a stack overflow
21:56:12 <Berengal> roconnor: Which version are you compiling with?
21:56:23 <roconnor> 6.8.2
21:56:48 <Berengal> I'm on 6.10.3, and it works just fine
21:56:54 <Berengal> Exponential implosion and all
21:57:11 <roconnor> oh
21:57:19 <roconnor> lemme check what gnuvince_ was using
21:57:31 <Berengal> time @ 20000 -> real	0m0.285s
21:58:07 <roconnor> voker57_: Common Subexpression Elimination
21:58:16 <Berengal> roconnor: That's without optimizations by the way
21:58:36 <dolio> Without any optimizations?
21:58:44 <roconnor> 17:20:57 <gnuvince_> roconnor: that's weird.  I'm on Arch Linux, 32 bit, GHC 6.10.3
21:59:00 <roconnor> noo
21:59:06 <roconnor> my lack of faith is being shaken again.
21:59:11 <Berengal> [berengal@superabacus ~/dev/haskell]$ ghc --make -O0 -fforce-recomp tree2.hs
21:59:11 <Berengal> [1 of 1] Compiling Main             ( tree2.hs, tree2.o )
21:59:11 <Berengal> Linking tree2 ...
21:59:11 <Berengal> [berengal@superabacus ~/dev/haskell]$ time ./tree2 20000 >/dev/null
21:59:11 <Berengal> real	0m0.315s
21:59:27 <roconnor> oh
21:59:38 <roconnor> but gnuvince_ never tried out my Writer.Strict version.
21:59:47 <roconnor> that would probably explain it.
22:00:04 <Jedai> Berengal: And with optimization ?
22:00:10 <roconnor> Berengal: that is ... kinda disturbing
22:00:18 <Berengal> Jedai: About the same, few microseconds faster
22:00:38 <Berengal> Berengal: time @ 20000 -> real	0m0.285s
22:00:48 <voker57_> what's wrong about it?
22:01:48 <roconnor> voker57_: GHC almost never does CSE because it can often lead to space leaks.
22:02:50 <roconnor> So when it actually does CSE in code write ... and causes an exponential implosion in runtime ... it is quite surprising.
22:02:57 <roconnor> in code I write ...
22:03:28 <Berengal> roconnor: It's sort of like writing a prolog program that finishes this side of the big bang...
22:03:39 <Berengal> *the next big bang
22:03:59 <roconnor> Berengal: heh, I don't write much prolog, but I believe that.
22:04:11 <roconnor> It is probably really easy to write exponential time code in Prolog.
22:04:26 <Berengal> roconnor: About as easy as writing it in the list monad :)
22:04:30 <roconnor> right
22:05:06 <roconnor> for the ICFP 2006 adventure game I solved all the puzzles but one.
22:05:29 <roconnor> I needed to add a sort function to my list monad code to get the last one.
22:05:52 <roconnor> ... I wonder if that can easily be done in prolog.
22:08:09 <Berengal> sort(List, List) :- isSorted(List).
22:08:10 <Berengal> sort(List, Out) :- select(List, Elem, Remaining), insert(Elem, Remaining, HopefullySortedList), sort(HopefullySortedList, Out).
22:08:34 <roconnor> Berengal: sounds easy enough.
22:08:44 <Berengal> roconnor: Yeah, that's basically bogosort
22:09:12 <Berengal> I probably got it wrong somewhere, but the gist of it should be right
22:09:14 <roconnor> The sort command is just to make it try what I considered more fruitful search paths first.
22:09:38 <grncdr> Hey so I'm still just getting started with haskell, mostly going through stuff on learnyouahaskell, and I'm wondering if anybody has any recommendations on small but "real" programs to look at for an idea of design patterns etc.
22:09:39 <Berengal> Doesn't that require you to drop out of the list monad for a spell though
22:10:06 <Berengal> grncdr: Take a look at Real World Haskell as well
22:10:09 <roconnor> grncdr: lost of people work on the Euler problems.
22:10:24 <roconnor> grncdr: oops, you want to look at code.
22:10:46 <Berengal> @where RWH
22:10:46 <lambdabot> is http://www.realworldhaskell.org/blog/
22:10:54 <roconnor> Berengal: nope instead of x <- blah, I write x <- sortBy foo blah
22:11:09 <roconnor> Berengal: the change was disturbingly trivial.
22:11:22 <Berengal> roconnor: Ah, like that
22:11:24 <grncdr> thx Berengal & roconnor
22:11:31 <roconnor> I like how just little tweeks of Haskell code can have mind blowing performance gains.
22:11:41 <roconnor> actually maybe I don't like that, but still.
22:11:45 <roconnor> it is neat.
22:11:45 <Berengal> For some reason I always consider things to the right of <- to be "outside" the monad...
22:12:12 <roconnor> Berengal: that's fair, but not what I think
22:12:34 <Berengal> roconnor: Also, if you have blah <- earlier, the sort wouldn't go past that point...
22:13:07 <roconnor> Berengal: that is a type error.
22:13:29 <Berengal> roconnor: Doesn't have to be
22:13:37 <Berengal> blah <- map return foo
22:13:45 <roconnor> oh
22:13:59 <roconnor> in that case I'm simply confused by what you mean.
22:14:32 <paulrd> ApplicativeParsec.hs from RWH Chapter 16 appears to work usibg Parsec 2.1, but not using Parsec 3.0.
22:14:34 <paulrd> <snip>
22:14:36 <paulrd> GHCi, version 6.10.2: http://www.haskell.org/ghc/  :? for help
22:14:38 <paulrd> Loading package ghc-prim ... linking ... done.
22:14:40 <paulrd> Loading package integer ... linking ... done.
22:14:42 <paulrd> Loading package base ... linking ... done.
22:14:44 <paulrd> [1 of 1] Compiling ApplicativeParsec ( Y:\examples\ch16\Applic
22:14:46 <paulrd> ativeParsec.hs, interpreted )
22:14:47 <roconnor> @paste
22:14:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:14:48 <paulrd> Y\examples\ch16\ApplicativeParsec.hs:15:0:
22:14:50 <paulrd> Illegal instance declaration for `Applicative (GenParser s a)'
22:14:52 <paulrd> (All instance types must be of the form (T t1 ... tn)
22:14:54 <paulrd> where T is not a synonym.
22:14:56 <paulrd> Use -XTypeSynonymInstances if you want to disable this.)
22:14:58 <paulrd> In the instance declaration for `Applicative (GenParser s a)'
22:15:00 <paulrd> Y'\examples\ch16\ApplicativeParsec.hs:20:0:
22:15:02 <paulrd> Illegal instance declaration for `Alternative (GenParser s a)'
22:15:04 <paulrd> (All instance types must be of the form (T t1 ... tn)
22:15:06 <paulrd> where T is not a synonym.
22:15:08 <paulrd> Use -XTypeSynonymInstances if you want to disable this.)
22:15:10 <paulrd> In the instance declaration for `Alternative (GenParser s a)'
22:15:12 <paulrd> Failed, modules loaded: none.
22:15:14 <paulrd> Prelude>
22:15:16 <paulrd> </snip>
22:15:18 <paulrd> Is it possible to modify the ApplicativeParsec.hs so that it works for both versions of Parsec?  (For example,using some form of conditional import.)  Thanks for any help.
22:15:21 <roconnor> @paste
22:15:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:15:52 <Berengal> roconnor: If you did something like do {blah <- iterate tail foo; x <- sortBy cmp blah} the sortBy wouldn't sort the iterate tail foo part
22:16:06 <roconnor> ah no
22:16:09 <Berengal> Which wouldn't work anyway, but might be what you ultimately wanted
22:16:32 <roconnor> but blah <- sort foo $ iterate tail foo -- this would
22:16:35 <roconnor> basically
22:16:48 <roconnor> x <- blah -- this does nondeterministic choice
22:17:03 <roconnor> but the order of the elements in blah determines the backtracking search order
22:17:17 <roconnor> since semantically we don't care about the search order (for finite lists)
22:17:32 <roconnor> we can safely rearrange the list anyway we chose
22:17:38 <Berengal> Yeah
22:17:40 <roconnor> x <- sort foo blah
22:17:50 <roconnor> which is niffty
22:18:04 <Berengal> I like the list monad...
22:18:08 <Berengal> And the reader monad
22:18:15 <Berengal> Okay, I like monads
22:18:18 <roconnor> I can make a clearly safe minor change, and tweek my performance.
22:18:29 <Berengal> They're a wonderful piece of abstract nonsense
22:19:04 <Berengal> roconnor: As long as it typechecks you're 50% golden. It's what I love about haskell
22:21:13 <roconnor> What I like about haskell is what augustss said:
22:21:40 <roconnor> ‚ÄúFor me, a large part of the fantastic expressiveness of
22:21:41 <roconnor> Haskell comes from the fact that you can combine
22:21:43 <roconnor> different [abstractions] and they actually work
22:21:45 <roconnor> together with very few surprises.‚Äù
22:22:30 <Berengal> Yeah, that's what purity gets you
22:22:46 <Gracenotes> a white wedding dress?
22:22:48 <Berengal> It's essentially the same as the type checking
22:23:11 <Berengal> Without purity the type checking wouldn't work nice either
22:24:06 <Berengal> But because of purity, as long as the types are right (you combined the abstractions in a way that makes sense), it works, with very few surprises
22:29:45 <Axman6> gahh, if only java had a nice sortBy (comparing snd) >_<
22:31:52 <Apocalisp> Axman6: Noted. I'll add fj.pre.Ord.comparing.
22:32:54 * Axman6 is trying to write a wordcount routine, and is needing to use about 4 different datatypes to get the most and least common words
22:33:10 <Apocalisp> Why come?
22:35:43 <roconnor> Apocalisp: (head &&& last) (sortBy frequency words)
22:36:03 <roconnor> with laziness, the sort probably won't even finish.
22:36:12 <roconnor> well, might not finish
22:36:53 <roconnor> better be safe
22:37:12 <roconnor> (minimumBy frequency words, maximumBy frequency words)
22:37:51 <Apocalisp> nice
22:38:46 <roconnor> it only looks nice because I haven't implemented frequency or words.
22:38:51 <roconnor> the devil is in the details.
22:41:13 <Axman6> frigging hell java is a pain in the arse
22:41:23 <Apocalisp> It is that.
22:45:53 <Apocalisp> Axman6: Are you using the standard libraries?
22:46:06 <Axman6> yeah
22:46:12 <Apocalisp> there's your problem right there
22:46:48 <Apocalisp> It's not so much java (OK, yes it is) as it is the libraries.
22:46:48 <Axman6> i've got the words and their counts in a hasktable, and not i need to get them out, and sort them based on the frequency. i found how to do it recently, but can't find the article again
22:46:59 <Axman6> yeah
22:47:17 <Gracenotes> Axman6: the idea is to not use a hashtable, perhaps
22:47:29 <Axman6> how a batter idea?
22:47:31 <Axman6> better too
22:47:35 <Axman6> though batter's sweet
22:47:46 <Apocalisp> A batter idea: cake!
22:47:57 <Apocalisp> Programming is hard. Let's go baking.
22:50:12 <Apocalisp> I don't think I would use a hashtable for counting words.
22:50:22 <dobblego> according to Neal Gafter, you've just improved its usefulness, by using it
22:50:24 <Gracenotes> Axman6: well, the way to do it with the standard libraries anyway is by getting the entry set and sorting it
22:50:45 <Axman6> well, that's what i've got, but i can't remember how to sort it
22:50:58 <dobblego> java.util.Collections.sort
22:51:08 <Axman6> i've made the comparator and everything, but collections.sort is whinging
22:51:24 <roconnor> This exponential implosion still has me in a little shock.  If the python code had not used mutable variables for their counter, they could have stumbled upon the same sharing themselves.  If their code was suitably restructured to be immutable, there would even be a tiny tiny possibility that their compiler could have found the sharing too.
22:51:53 <Gracenotes> well. Since this is notoriously known as a Java support channel.
22:51:59 <Gracenotes> ArrayList<Map.Entry<Blah, Integer>> blahs = new ArrayList<Map.Entry<Blah, Integer>>(blahmap.entrySet());
22:52:01 <Gracenotes> Collections.sort(blahs, new Comparator<Map.Entry<Blah, Integer>>() { public int compare(Map.Entry<Blah, Integer> o1, Map.Entry<Blah, Integer> o2) { return o2.getValue().compareTo(o1.getValue()); } });
22:52:10 <Gracenotes> (shield your eyes!)
22:52:15 <Axman6> ah ha
22:52:23 <Axman6> arraylist, sounds good
22:52:37 <Apocalisp> The pointy brackets... they pierce our chi
22:52:55 <Boney> why not use a binary tree when collecting the items? then they're already sorted.
22:53:08 <Gracenotes> Boney: by the key, yes
22:53:12 <Boney> ah,
22:53:21 <Boney> sorry,  you want to sort by the frequency.
22:53:22 <Gracenotes> I was about to suggest that, but reality dawned ;_;
22:53:55 <Gracenotes> now, for your enjoyment: sort (comparing snd) . Map.toList
22:53:57 * Boney goes back to something he can give his full attention to.
22:54:26 <Boney> Gracenotes: awesome.
22:55:29 <Gracenotes> sort has its own sloow limitations, but, regardless.
22:56:38 <Gracenotes> holds up surprisingly well
22:58:01 <inbuninbu> any experts on Data.Binary around?
22:58:05 <Berengal> I've found sort to be reasonably quick
22:58:21 <Berengal> Bearing in mind it's sorting a singly linked list
23:05:22 <Axman6> thanks heaps Gracenotes
23:05:32 <Gracenotes> np
23:05:46 * Axman6 gives Gracenotes a brand new shiny heaps to store his objects in
23:05:48 <Axman6> -s
23:06:13 <Gracenotes> MONADIC STACK OVERFLOW
23:06:36 <Apocalisp> http://code.google.com/p/functionaljava/issues/detail?id=6
23:57:55 <zachk> why does something i consider difficult only take 45 lines of haskell :-D
23:58:50 <Axman6> because you have high expectations
23:58:52 <jbjohns> Haskell does the easy things for your, makes the hard things easy and the impossible possible
