00:02:28 * Gracenotes compresses random data in Haskell
00:04:54 <Cale> zachk: 45 lines of Haskell can take quite a lot of thought
00:05:04 <zachk> yea took me on and off all day
00:05:21 <zachk> problem 11 of project euler, but now euler is down :-/
00:06:03 <zachk> i feel like such a newb
00:17:00 <mxc> to paraphrase xkcd, i can make a random number generator in one like:
00:17:36 <mxc> randomNumberGen = 4 {- chosen by a roll of the dice, garaunteed to be random -}
00:19:22 <Gilly> what book/tutorial would you recommend for a friend of mine who has a long background in imperative programming but who could be converted (or at least introduced) to functional programming?
00:19:35 <Gilly> real world haskell?
00:19:47 <zachk> "Programming in Haskell" by Graham Hutton if he wants to learn haskell
00:20:08 <Gilly> it should be something available online I think
00:20:24 <zachk> shell out some $$$ for pih its worth it
00:21:00 <Gilly> well - i think since he doesn't know anything at all about the subject it would be hard for me to convince him to buy it
00:21:17 <SubStack> learn you a haskell is fun times
00:21:38 <SubStack> there's also real world haskell which you can read online
00:21:50 <Gilly> okies, thanks :)
00:21:52 <SubStack> and also buy
00:21:56 <Gilly> yea
00:56:59 <mxc> gilly - second that..  RWH is great.  can check it out online too
01:22:24 <ManateeLazyCat> Have a function's type signature is "[a] -> (a -> c) -> (a -> b) -> [c, b]" ?
01:22:30 <ManateeLazyCat> Thanks
01:23:05 <thoughtpolice> what does [c,b] mean?
01:23:21 <ManateeLazyCat> is [(c, b)]
01:23:47 <ManateeLazyCat> [a] -> (a -> b) -> (a -> c) -> [(b, c)]
01:23:54 <ManateeLazyCat> typo
01:26:05 <ManateeLazyCat> Have a exist function wit type "[a] -> (a -> b) -> (a -> c) -> [(b, c)]"?
01:26:25 <kniu> Does oatmeal cause gas?
01:27:16 <Gilly> ManateeLazyCat: f as b c = zip (map b as) (map c as)
01:27:24 <opqdonut> :t \xs f g -> map (f &&& g) xs
01:27:25 <lambdabot> forall a c c'. [a] -> (a -> c) -> (a -> c') -> [(c, c')]
01:27:32 <ManateeLazyCat> Gilly: Thanks! :)
01:27:34 <opqdonut> that for a more combinatorial version
01:27:59 <ManateeLazyCat> opqdonut: Thanks
01:28:07 <opqdonut> np
01:28:12 <Gilly> what does &&& mean?
01:28:17 <opqdonut> :t (&&&)
01:28:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:28:24 <opqdonut> it's an arrow combinator
01:28:30 <opqdonut> (->) is one example of an arrow
01:28:44 <opqdonut> > ((+1) &&& id) 1
01:28:45 <lambdabot>   (2,1)
01:29:12 <tetha> hm, so on a function levle, &&& is like factors bi?
01:29:33 <Axman6> eh?
01:29:34 <Gilly> ah... so (f &&& g) = \xs -> (f xs, g xs) ?  constructs pairs of
01:29:43 <Gilly> forget the rest of the line, was going to say something else :D
01:29:44 * Axman6 parse fail on that sentense
01:30:18 <opqdonut> Gilly: yeah, in the function arrow, yes
01:30:20 <opqdonut> otoh
01:30:26 <dobblego> @type (&&&) :: (b -> c) -> (b -> c') -> b -> (c, c')
01:30:28 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
01:30:32 <opqdonut> > ((1,2) &&& (3,4))
01:30:33 <lambdabot>       No instance for (Arrow (,))
01:30:34 <lambdabot>        arising from a use of `&&&' at <inte...
01:30:42 <opqdonut> huh?, thought they were
01:30:45 <tetha> Axman6: bi is a combinator in factor, a stack-based language. it applies the topmost element on the stack and the second topmost element on the stack to the third element on the stack and pushes both results in order
01:30:53 <dobblego> (,) is not an Arrow
01:31:00 <opqdonut> yeah, no arr
01:31:02 <opqdonut> misremembered
01:31:10 <dobblego> Bifunctor perhaps
01:31:23 <Gilly> these arrows look scary :)
01:31:45 <opqdonut> (,) was a category tho, (a,b) . (b,c) = (a,c)
01:34:39 <Cale> opqdonut: What's id though?
01:37:17 <opqdonut> Cale: (a,a) ?-)
01:38:58 <opqdonut> Control.Category.Discrete is basically (,)
01:41:20 <Cale> opqdonut: er, that would be the type.
01:41:53 <ManateeLazyCat> opqdonut: How to write function with "[a] -> (a -> IO b) -> (a -> IO c) -> [(b, c)]"?
01:42:05 <Cale> If one exists. But the trouble is that you need id . (x,y) = (x,y)
01:42:39 <opqdonut> ah, yeah
01:42:44 <Cale> ManateeLazyCat: Not possible unless you fit another IO into that type
01:42:46 <DrSyzygy> ManateeLazyCat: You won't do that without getting somehtingn  like IO d -> d, which isn't supposed to happen.
01:43:35 <opqdonut> ManateeLazyCat: but a function [a] -> (a -> IO b) -> (a -> IO c) -> IO [(b, c)] is very possible
01:44:07 <ManateeLazyCat> opqdonut: "[a] -> (a -> IO b) -> (a -> IO c) -> IO [(b, c)]" is okay, how to implement it?
01:44:42 <dobblego> (a -> IO b) is also an arrow (Kleisli)
01:44:50 <Haplo> http://netia.mybrute.com
01:45:24 <Cale> :t \f g -> mapM (liftM2 (liftM2 (,)) f g)
01:45:26 <lambdabot> forall a1 a2 (m :: * -> *) a. (Monad m) => (a -> m a1) -> (a -> m a2) -> [a] -> m [(a1, a2)]
01:49:49 --- mode: ChanServ set +o Heffalump
01:50:06 --- kick: Haplo was kicked by Heffalump (spamming)
01:53:05 <Cale> ManateeLazyCat: Or perhaps more straightforwardly:
01:53:13 <Cale> :t \xs f g -> forM xs $ \x -> do u <- f x; v <- g x; return (u,v)
01:53:14 <lambdabot> forall a (m :: * -> *) t t1. (Monad m) => [a] -> (a -> m t) -> (a -> m t1) -> m [(t, t1)]
01:53:44 <Cale> This is assuming that you want the effects to happen in that particular order.
01:53:55 <Cale> You could also do something like...
01:54:31 <Cale> :t \xs f g -> do us <- forM xs f; vs <- forM xs g; return (zip us vs)
01:54:32 <lambdabot> forall a (t :: * -> *) b b1. (Monad t) => [a] -> (a -> t b) -> (a -> t b1) -> t [(b, b1)]
01:54:40 <Cale> Which is quite different.
01:56:04 <ManateeLazyCat> Cale: That's cool, thanks!
02:07:08 <ManateeLazyCat> Cale: "\xs f g -> forM xs $ \x -> do u <- f x; v <- g x; return (u,v)" is more efficient, "\xs f g -> do us <- forM xs f; vs <- forM xs g; return (zip us vs)" loop *twice*.
02:20:19 <RayNbow> sigfpe's trace diagrams blog post is mind blowing (if you try to evaluate the expressions in one's head)
02:22:45 <zachk> RayNbow: could you post the url
02:23:17 <RayNbow> zachk: http://blog.sigfpe.com/2009/05/trace-diagrams-with-monads.html :)
02:23:24 <zachk> danke
02:24:19 <RayNbow> I've read the article up to cupcap last night (after which I was too tired to continue :p)
02:24:23 <opqdonut> heh, almost like penrose notation
02:25:28 <RayNbow> @go penrose notation
02:25:29 <lambdabot> http://en.wikipedia.org/wiki/Penrose_graphical_notation
02:25:47 <zachk> he makes it look easy
02:26:01 <opqdonut> oh, that is penrose notation i guess
02:26:26 <opqdonut> i first thought the post was about monads generally and not vector spaces
02:27:42 * RayNbow doesn't get the Penrose wiki page... (but then again, I'm not familiar with tensors :p)
02:49:45 <mxc> nice error message GHC:  "error:  My brain just exploded. I can't handle pattern bindings for existentially-quantified constructors."
02:50:41 <opqdonut> wow
02:52:18 <tetha> heh
02:54:56 <Heffalump> sounds like it blew up JaffaCake too
03:06:52 <mxc> hm
03:07:20 <mxc> i have a record with an existentially scoped list, can't seem to get to that list
03:07:26 <mxc> wondering if i'm doing something i shouldn't be
03:07:49 <mxc> data MessageClient  = forall mq. MessageQueue mq => MC_
03:07:49 <mxc>   { associatedQueues :: IORef [mq] ,...}
03:24:28 <mib_dv5tdpto> hey ppl
03:39:30 <Nereid> @pl \x -> m x y
03:39:30 <lambdabot> flip m y
03:39:41 <Nereid> of course
03:41:45 <jbjohns> @pl
03:41:45 <lambdabot> (line 1, column 1):
03:41:45 <lambdabot> unexpected end of input
03:41:45 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
03:42:01 <jbjohns> @pl \x -> m x
03:42:01 <lambdabot> m
03:42:10 <jbjohns> @help
03:42:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:42:22 <jbjohns> @help pl
03:42:22 <lambdabot> pointless <expr>. Play with pointfree code.
03:42:28 <Nereid> http://www.haskell.org/haskellwiki/Pointfree
03:42:49 <jbjohns> I see now
03:42:59 <Nereid> :)
03:43:05 <jbjohns> :)
03:43:54 <Nereid> @help unpl
03:43:54 <lambdabot> pointful <expr>. Make code pointier.
03:44:04 <Nereid> @unpl flip m y
03:44:05 <lambdabot> (\ c -> m c y)
03:44:34 <Nereid> @unpl ((.)$(.))
03:44:34 <lambdabot> (\ b c e f -> b c (e f))
03:44:38 <Taejo> I thought the point of unpl was to make code uglier
03:44:42 <Nereid> @unpl ((.).(.))
03:44:42 <lambdabot> (\ i b c f -> i (b c f))
03:44:44 <Nereid> hooray
03:44:47 <Nereid> anyway
03:44:50 <Nereid> bedtime
03:46:50 <Taejo> Can anybody think of a better/shorter program to generate all binary trees with leaves from a given list, than http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5161#a5161
03:49:09 <SubStack> just explicit recursion?
03:53:02 <SubStack> Taejo: propagate a found status up to the parents instead of generating a list of all the nodes perhaps?
04:01:41 <Taejo> SubStack: I'm not sure what you mean
04:07:05 <EvilTerran> allTrees [] = mzero; allTrees [x] = return (Tip x); allTrees xs = Branch (allTrees ls) (allTrees rs) where (ls, rs) = partitionM (const [False, True]) xs; partitionM = {- compare filterM, partition -}
04:08:48 <EvilTerran> > filterM (const [False,True]) [1,2,3]
04:08:49 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
04:11:03 <Axman6> @src filterM
04:11:03 <lambdabot> Source not found. There are some things that I just don't know.
04:11:18 <EvilTerran> (i guess partitionM :: Monad m => (a -> m Bool) -> [a] -> m ([a], [a]))
04:12:35 <EvilTerran> filterM _ [] = return []
04:12:35 <EvilTerran> ; filterM p (x:xs) = do flg <- p x; ys <- filterM p xs; return (if flg then x:ys else ys)
04:15:01 <EvilTerran> ?src partition
04:15:01 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
04:15:02 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
04:15:02 <lambdabot>                               | otherwise = (ts, x:fs)
04:15:56 <EvilTerran> anyway, the idea being that partitionM (const [True, False]) xs will give you, by virtue of the list monad, a list of all partitionings of xs
04:16:21 <dmwit> s/partitionM/filterM/
04:16:50 <EvilTerran> dmwit, ?
04:17:26 <dmwit> > filterM (const [True, False]) [3..5]
04:17:27 <lambdabot>   [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
04:17:38 <EvilTerran> dmwit, gives you a list of all sublists, not all partitionings
04:17:45 <dmwit> errm
04:17:47 <dmwit> quite
04:17:48 <EvilTerran> you want the complement lists as well
04:18:05 <EvilTerran> hence, you want something you could call partitionM
04:22:46 <zachk> @type any
04:22:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
04:22:59 <zachk> @src any
04:22:59 <lambdabot> any p =  or . map p
04:23:58 <Bacta> @faq can Haskell solve world hunger?
04:23:58 <lambdabot> The answer is: Yes! Haskell can do that.
04:24:32 <skorpan> @faq can haskell do a giraffe?
04:24:33 <lambdabot> The answer is: Yes! Haskell can do that.
04:25:36 <mm_freak_> hashUnique just returns numbers from [1..] in order for each newUnique invocation, which is good, but can i rely on that?  not on the ordering, but that collisions are very unlikely in practice
04:27:08 <mm_freak_> i'm asking because IntMap Something is probably faster than Map Unique Something
04:28:18 <sayyestolife> Is there a haskell-for-beginners IRC channel?
04:28:55 <mauke> no, but there's #haskell-in-depth
04:28:56 <dmwit> sayyestolife: You're in it.
04:29:00 <mauke> which is sort of the opposite
04:29:06 <sayyestolife> dmwit, awesome!
04:29:38 <dmwit> mm_freak_: You haven't given enough information about when collisions happen, but let me point you at Wikipedia's page on the Birthday Paradox just in case you didn't know about it.
04:29:44 <sayyestolife> So.. I'm trying to get a grip on monads and their use. I
04:29:56 <sayyestolife> I'm trying to do a little text-based version of hangman
04:30:19 <sayyestolife> and I'm wondering if the "current status" so to speak, should be represented as a monad?
04:30:21 <mm_freak_> dmwit: the birthday paradox doesn't apply to hashUnique, because its output is not random at all
04:30:30 <mm_freak_> dmwit: i think it's not supposed to be random anyway
04:30:45 <dmwit> mm_freak_: So what do you mean by collisions?
04:30:53 <mauke> sayyestolife: I don't know if it should be, but it's definitely possible
04:31:05 <dmwit> sayyestolife: The current status should almost certainly be represented simply as a value.
04:31:06 <wh1t3> hmmm, im getting an error i dont understand
04:31:21 <dmwit> sayyestolife: However, you can use a monad to thread that value through your computations, if you like.
04:31:39 <sayyestolife> mkay
04:31:45 <wh1t3> No instance for (Floating Int) arising from a use of `sqrt
04:32:05 <dmwit> Specifically, the State monad seems like one possibility.
04:32:13 <mm_freak_> dmwit: the documentation states that two Unique values may hash to the same Int, but this is "unlikely" to happen in practice…  if the birthday paradox would apply, that would be extremely bad, but it doesn't apply, since hashUnique really returns numbers 1, 2, 3, 4, … for the corresponding invocations of newUnique
04:32:20 <mm_freak_> dmwit: my question is:  can i rely on that?
04:32:21 <wh1t3> in: sqrt (fromIntegral (dx^2 + dy^2)) where dx and dy are Int
04:33:01 <mauke> wh1t3: what are you doing with the result of sqrt?
04:33:06 <dmwit> mm_freak_: You can rely on newUnique returning unique numbers, and maybe even on it returning unique, increasing numbers.
04:33:22 <dmwit> mm_freak_: But you cannot rely on the birthday paradox not applying, because hashing rarely uses the identity function.
04:33:34 <wh1t3> multiplying it with an Int mauke
04:33:49 <mauke> wh1t3: yeah, that won't work
04:34:02 <wh1t3> how to make it work then?
04:34:12 <wh1t3> all these different numerical types are making me kind of crazy
04:34:14 <mm_freak_> currently i'm always using one of two approaches:  either Map Unique Something or an own id generator like this:  forkIO $ mapM_ (putMVar nextID) [0..]
04:34:20 <mauke> wh1t3: (*) takes two arguments of the same type. if one of them is an Int, the result of sqrt has to be too
04:34:28 <mauke> wh1t3: and you can't sqrt an Int
04:34:47 <Nereid> let's say n is an Int and you're trying to find sqrt x * n
04:34:55 <Nereid> that would fail, but you could do sqrt x * fromIntegral n
04:35:09 <mauke> wh1t3: you have to turn the result of sqrt in an Int; do you want to round it up or down or to nearest?
04:35:18 <dmwit> mm_freak_: You do know that Map doesn't do any hashing, right?
04:35:28 <wh1t3> mauke, nearest
04:35:30 <Nereid> mauke: I think he's taking the sqrt of a Floating and then multiplying the result by an Int
04:35:47 <mauke> wh1t3: hmm, or do you want the result to be a fractional number?
04:35:49 <wh1t3> i am indeed Nereid, but mauke already figured that out
04:36:03 <wh1t3> mauke. no an Int, since i need to pass it into a function that takes ints
04:36:04 <dmwit> mm_freak_: Oh, I see, there's no other way to use a Unique than via hashUnique, huh?
04:36:07 <mauke> wh1t3: round (sqrt (...))
04:36:13 <Nereid> ah, ok then.
04:36:15 <wh1t3> cheers, let me give that a go :)
04:37:18 <Nereid> if you wanted the nearest integer to sqrt x * n then I'm guessing you'd have to do something like round (sqrt x * fromIntegral n)
04:37:22 <wh1t3> ah yes, that works :)
04:37:28 <wh1t3> thanks mauke
04:37:56 <mm_freak_> dmwit: no, you can use Unique with Map, but i'd like to use IntMap, which is faster
04:38:12 <mm_freak_> so in that case i need to use hashUnique or implement my own generator
04:38:44 <mm_freak_> hashUnique should be less abstract IMO, because 'hashing' to Int is almost useless in practice
05:13:09 <man> @lambdabot
05:13:09 <lambdabot> Unknown command, try @list
05:13:38 <dmwit> @bot
05:13:39 <lambdabot> :)
05:13:39 <lunabot>  :)
05:25:56 <pe> Hi. I'm trying to use the FFI : I have a C struct representing a rational (two ints). How comes when I try to define instance Storable (Ratio a), trying to peek loops infinitely ?
05:26:32 <mauke> apparently you did it wrong
05:26:55 <dmwit> Oh, boy, I never did get a straight answer about accessing C structs from Haskell.
05:27:04 <mauke> really?
05:27:11 <dmwit> I think there's tools to help you, like c2hs or so.
05:27:19 <mauke> I found it relatively straightforward
05:27:35 <dmwit> Well, there's nothing in the FFI spec about it.
05:28:06 <pe> in fact, I'm using hsc2hs that converts #{peek c_struct, c_field} into peekByteOff
05:28:12 <mauke> well, you have to know the offsets of struct members, which requires help from the C compiler
05:28:21 <dmwit> right
05:28:25 <pe> yeah. That's what I did
05:28:43 <dmwit> pe: It might help to paste some code.
05:28:44 <dmwit> ?hpaste
05:28:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:28:48 <pe> I don't understand why peekByteOff does a recursive call to the peek I'm defining
05:29:53 <dmwit> yoink!
05:30:51 <pe> Here : http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5162#a5162
05:31:17 <mauke> that doesn't look valid
05:31:23 <mauke> what is AVRational?
05:31:31 <pe> I paste it now
05:32:03 <mauke> and it's recursive because avnum :: Ratio a
05:32:16 <pe> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5162#a5163
05:32:55 <pe> ah ok
05:33:07 <mauke> I wouldn't use that to represent Ratio a
05:33:23 <pe> you mean in the C side ?
05:33:24 <mauke> I'd make a new type data AVRational = AVR { num, den :: CInt }
05:34:16 <pe> that's what I did, in fact. I was just surprised that this could loop
05:34:30 <mauke> and your alignment is wrong
05:34:39 <pe> does it matter ?
05:34:42 <mauke> yes
05:34:45 <mauke> well, (/) :: a -> a -> a
05:34:50 <mauke> so that's why it loops
05:35:04 <mauke> bogus alignment means it can crash on some platforms
05:35:12 <mauke> on x86 it just might be slow
05:35:40 <pe> so my alignment should be the size in bytes of the smallest field in the struct, right ?
05:35:50 <mauke> no
05:36:23 <pe> ok, the gcd of all fields ?
05:36:30 <mauke> um, no?
05:36:40 <mauke> consider {int; char}
05:38:29 <RayNbow> @. pl undo \v w -> do { i <- v ; j <- w ; cup i j }
05:38:30 <lambdabot> (. ((. cup) . (>>=))) . (>>=)
05:38:36 <RayNbow> @. pl undo \v w -> do { i <- v ; j <- w ; cup (i, j) }
05:38:36 <lambdabot> (. ((. ((cup .) . (,))) . (>>=))) . (>>=)
05:38:41 <RayNbow> hmm...
05:40:40 <mauke> pe: http://rafb.net/p/LPOjRY85.html (untested)
05:41:02 <mauke> untested indeed; it's also broken :-)
05:41:18 <mauke> line 13 should be return AVR{ num = n, den = d }
05:42:06 <pe> ok, thanks, but what use is the alignment ?
05:42:28 <pe> how do you find your #let alignment ... ?
05:42:45 <pe> and what does it mean ?
05:43:46 <mauke> certain types of objects have to be placed at addresses that are divisible by some number (the "alignment")
05:43:59 <mauke> e.g. it's not uncommon for ints to have an alignment of 4
05:45:00 <mauke> so if you define a type like struct { short a; int b; }, it's very likely that the compiler will insert padding after 'a' to make the position of 'b' divisible by 4
05:46:09 <mauke> my alignment trick uses the standard C macro to get the offset of a struct member in a type of the form struct { char dummy; T x; }
05:46:18 <mauke> er, "the standard C macro offsetof"
05:46:32 <pe> ok, thanks !
05:46:44 <mauke> if T has no special alignment constraints, it's placed immediately after 'dummy', giving an alignment of 1
05:47:39 <mauke> but if the compiler inserts three bytes of padding (likely for int), the offset will be 4
05:51:08 <Peaker> @src liftM2
05:51:08 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:52:31 <Peaker> when were monad comprehensions first introduced?  They're not that much shorter than do notation - what was their rationale?
05:53:41 <Botje> somebody forgot to restrict list comprehensions to the list monad? :)
05:54:36 <Peaker> I heard that list comprehensions started out as general monad comprehensions
05:56:48 <dolio> They were still list comprehensions in 1.3.
05:57:07 <dolio> Gofer probably had them first, and then they got added to 1.4.
05:57:10 <dolio> And removed in 98.
05:57:47 <Taejo> dolio: so they were list, then monad, then list comprehensions?
05:58:16 <dolio> Yeah.
05:58:56 <dolio> Miranda (at least) had list comprehension, I think, so they predate Haskell altogether.
05:59:16 <Peaker> do { x <- [1..3] ; y <- "abc" ; return (x,y) } -- not that much longer than [(x,y) | x <- [1..3], y <- "abc"]
05:59:17 <mauke> everyone knows python invented list comprehensions
05:59:35 <Peaker> mauke: Python mentioned Haskell when they first added it, iirc
06:00:23 <dolio> Wikipedia says SETL had something like them in the 1960s.
06:01:09 <Ferdirand> but return is waaay too long a symbol
06:01:43 <Taejo> Ferdirand: I agree. η is much shorter
06:02:03 <mauke> > let η = return in η 42 :: Maybe Int
06:02:04 <lambdabot>   Just 42
06:02:27 <Taejo> then of course we'd want:
06:02:44 * maltem would also like a prettier symbol for (>>=)
06:03:17 <Taejo> > let µ = join in µ (η (η 42))
06:03:18 <lambdabot>   <no location info>: parse error on input `µ'
06:03:38 <Taejo> > let μ = join in μ (η (η 42))
06:03:39 <lambdabot>   Not in scope: `η'Not in scope: `η'
06:03:47 <mauke> > let μ = join in μ ["hello", "world"]
06:03:48 <lambdabot>   "helloworld"
06:04:07 <Taejo> mauke: right
06:04:28 <RayNbow> are there any memnonics or something to remember mu=join and eta=unit?
06:05:13 <dolio> mu and multiplication begin with the same letter.
06:05:19 <Taejo> RayNbow: well, eta is used more generally for natural transformations; return and join are both natural, but I think return is the more natural of the two
06:05:20 <dolio> Same two, actually.
06:05:55 <Taejo> > let ∅ = Data.Set.empty in ∅
06:05:56 <lambdabot>   <no location info>: parse error on input `∅'
06:06:18 <maltem> The Danish empty set? :)
06:06:28 <Taejo> > let (∅) = Data.Set.empty in (∅)
06:06:30 <lambdabot>   /tmp/7702976657628257688:70:42: Not in scope: `Data.Set.empty'
06:06:49 <Taejo> maltem: it's an empty set symbol... unfortunately, it's a symbol, so Haskell wants it to be infix
06:07:23 <mauke> > let ø = [] in ø
06:07:24 <lambdabot>   []
06:08:16 <trofi> > [].to_set
06:08:17 <lambdabot>   Not in scope: `to_set'
06:09:03 <paper_cc> > let ∅ = [] in ∅
06:09:04 <lambdabot>   <no location info>: parse error on input `∅'
06:09:15 <paper_cc> two different symbols?
06:10:15 <mauke> U+00F8 (c3 b8): LATIN SMALL LETTER O WITH STROKE [ø]; U+2298 (e2 8a 98): CIRCLED DIVISION SLASH [⊘]
06:10:19 <tetha> did you tell the compulter you want to use utf8?
06:10:23 <mauke> U+2205 (e2 88 85): EMPTY SET [∅]
06:10:25 <tetha> eh, compiler
06:10:43 <maltem> Taejo, oh, it looked too small in my font. Whatever...
06:10:51 <int-e> > map generalCategory "ø∅"
06:10:52 <lambdabot>   [LowercaseLetter,MathSymbol]
06:11:11 <maltem> right
06:11:14 <paper_cc> why is MathSymbol considered a symbol and not a letter?
06:11:28 <paper_cc> *considered by GHC
06:11:32 <int-e> > let a ∅ b = [] in 1 ∅ 2
06:11:33 <lambdabot>   []
06:12:07 <int-e> many of them are used as infix operators.
06:12:21 <int-e> > generalCategory '⊕'
06:12:22 <lambdabot>   MathSymbol
06:13:01 <mauke> > let ø = []; _ ⊘ ø = ø in ø ⊘ ø
06:13:02 <lambdabot>   []
06:13:19 <paper_cc> oh
06:13:36 * paper_cc wants a good built-in category map in GHC
06:14:53 <dolio> > generalCategory '+'
06:14:54 <lambdabot>   MathSymbol
06:17:42 <ray> > let ∅ = Data.Set.empty in ∅
06:17:43 <lambdabot>   <no location info>: parse error on input `∅'
06:18:12 <mauke> you are now failing manually
06:18:24 <ray> :(
06:18:47 <ray> ☹
06:18:57 <mauke> ツ
06:19:25 <ray> シ
06:21:24 <Peaker> @src permutations
06:21:24 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
06:21:26 <Peaker> @src perms
06:21:26 <lambdabot> Source not found. Where did you learn to type?
06:23:13 <EvilTerran> > let (∅) = Set.empty in (∅)
06:23:14 <lambdabot>   fromList []
06:24:43 <ray> > generalCategory '☹'
06:24:44 <lambdabot>   OtherSymbol
06:25:17 <dolio> > let a ☹ b = a + b in 1 ☹ 2
06:25:19 <lambdabot>   3
06:25:25 * EvilTerran doesn't actually have most of these symbols in the font he's using, so they're mostly coming up as boxes
06:25:44 <dolio> That was an unhappy face.
06:49:40 <Peaker> > cycle "ppyHa"
06:49:41 <lambdabot>   "ppyHappyHappyHappyHappyHappyHappyHappyHappyHappyHappyHappyHappyHappyHappyH...
07:20:36 <Peaker> so, why is roconnor's example (rewritten here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5164#a5164 )
07:20:40 <Peaker> so fast on writer and so slow on state?
07:21:08 <Peaker> I went a step further to show its not a simple CSE on GHC's side (both are CSE's manually)
08:38:16 <gio123> http://rapidshare.com/files/236364849/ssssss.pdf.html
08:38:25 <hatds> ?
08:38:58 <gio123> can you tell me please what font it is?
08:39:07 <EvilTerran> gio123, what's that about?
08:39:09 <gio123> it is georgian letter
08:39:23 <gio123> but I can not recognize font to type
08:39:27 <Botje> gio123: you're best off asking whatthefont or somesuch.
08:39:33 <Botje> this is not the channel for that.
08:39:35 <gio123> the letters are georgian,
08:39:38 <gio123> ok
08:39:39 <gio123> sorry
08:39:50 <EvilTerran> ... and what does that have to do with Haskell?
08:39:57 <Botje> haskell uses letters too! see!
08:41:35 <hatds> ...I get it
08:42:12 <gio123> EvilTerran: haskel has relation with everything
08:46:19 <Absolute0> Is it bad style to define the following function: x % y = x `mod` y ?
08:46:56 <Twey> Absolute0: Well, ‘(%) = mod’ is easier
08:46:59 <Twey> But no, not really
08:47:06 <Twey> I don't think % is used for anything else
08:47:08 <Absolute0> hmm cool :)
08:47:14 <kpreid> @hoogle %
08:47:14 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
08:47:15 <Absolute0> Twey its not defined
08:47:19 <Twey> Ah, there we are
08:47:36 <Twey> The Haskell folks just didn't think it was useful enough to merit its own operator
08:47:38 <Absolute0> maybe it's in some library
08:47:39 <Twey> I agree
08:47:55 <Twey> Absolute0: It's the ratio-making symbol
08:48:03 <kpreid> I would recommend against using % for `mod` since Data.Ratio uses it for something entirely different
08:48:03 <Twey> > 3 % 1
08:48:04 <lambdabot>   3%1
08:48:12 <kpreid> > 5%10
08:48:14 <lambdabot>   1%2
08:48:21 <Absolute0> <interactive>:1:2: Not in scope: `%'
08:48:30 <kpreid> It's in the Data.Ratio module
08:49:06 <Absolute0> 5 % 6 returns 5 % 6
08:49:10 <Absolute0> is it a constructor?
08:50:09 <EvilTerran> no
08:50:19 <EvilTerran> infix constructors always start with a :
08:50:38 <EvilTerran> however, the Ratio datatype has a non-derived Show instance
08:50:45 <Absolute0> ah
08:51:21 <Twey> @let (⅟) = (1%)
08:51:21 <lambdabot>   Illegal character ''\8543''
08:51:22 <Absolute0> anyways what is wrong with this definition: data Position = (X Char, Y Num)
08:51:24 <Twey> :(
08:51:32 <Twey> Absolute0: Lacks a constructor
08:51:58 <Absolute0> data Position = Position (X Char, Y Num) ?
08:52:07 <Twey> (and X and Y are undefined, obviously)
08:52:18 <Twey> Sure
08:52:26 <Absolute0> I was hoping x and Y would be the constructors
08:52:28 <Absolute0> weird
08:52:29 <Absolute0> :)
08:52:35 <Twey> That makes Position :: (X Char, Y Num) -> Position
08:52:40 <Twey> No
08:52:55 <Twey> That would be data Position = X Char | Y Num
08:53:01 <Twey> Although Num is a class and not a type
08:53:12 <Twey> So that probably won't work anyway, unless you've defined some type Num
08:53:17 <Absolute0> Twey I want a tuple data type with a char and a Num
08:53:33 <walter__> In "type  State st a = st -> (st, a) " , is type defined a parameterized synonym?
08:53:34 <Absolute0> A value would be ('a', 5)
08:53:58 <EvilTerran> ?type ('a', 5)
08:53:59 <lambdabot> forall t. (Num t) => (Char, t)
08:54:05 <EvilTerran> ?type ('a', 5 :: Int)
08:54:06 <lambdabot> (Char, Int)
08:54:20 <Twey> Absolute0: Sounds like you want a synonym, then, not a datatype at all
08:54:33 <Absolute0> oh type
08:54:34 <Twey> Absolute0: type Position = Num n => (Char, n)
08:54:34 <Absolute0> i guess
08:54:58 <Absolute0> why do you do Num n but not Char c ?
08:55:00 <Absolute0> or both
08:55:29 <Twey> Because Num is a typeclass and Char is a type.
08:55:31 <EvilTerran> Absolute0, Char is a type; as is Int, Double, etc
08:55:31 <int-e> Char is a type. Num is a type class (instances are Integer, Rational, Double, Rational, and many more)
08:55:43 <Absolute0> oh gotcha
08:55:47 <Absolute0> i'll use int instead
08:55:50 <walter__> what is the "->" m means in "type  State st a = st -> (st, a) "
08:55:53 <int-e> (don't ask me why I had Rational twice :-) )
08:56:04 <Twey> Absolute0: Unless you have a good reason, it's often wise to default to Integer
08:56:05 <Saizan> walter__: it's the type constructors for functions
08:56:08 <Twey> Integers don't overflow
08:56:19 <Saizan> walter__: A -> B is the type of functions from A to B
08:58:54 <walter__> Saizan: I still confused, is "st" a construction or a general function?
08:59:13 <EvilTerran> walter__, no.
08:59:25 <EvilTerran> walter__, "st" is a type variable, introduced by "type State st a = ..."
08:59:59 <EvilTerran> walter__, "type State st a = ..." would introduce a type synonym "State", that takes two types as parameters
09:00:23 <Absolute0> type signatures can only use classes?
09:00:36 <Absolute0> executeMove :: (Position p, Move m) => p -> m -> m throws an error
09:01:18 <Twey> Absolute0: Because Position isn't a class
09:01:25 <Twey> And presumably Move isn't, either.
09:01:36 <Absolute0> one is a type the other a data
09:01:45 <Twey> They're both types.
09:01:48 <Absolute0> right
09:01:52 <walter__> EvilTerran, thanks, then  what is "st -> (st, a)" means, it looks like a funtion defination
09:01:59 <Absolute0> ehh
09:02:23 <Absolute0> How do I specify that a function can only accept a certain type, do I have to uses classes?
09:02:35 <thoughtpolice> Absolute0: no, just give it a type signature
09:02:47 <Absolute0> isn't that what i did?
09:02:49 <EvilTerran> Absolute0, have a look at http://book.realworldhaskell.org/read/types-and-functions.html
09:02:56 <EvilTerran> walter__, no, it's a type
09:03:29 <thoughtpolice> Absolute0: yes, but Position and Move aren't type classes.
09:03:30 <EvilTerran> walter__, specifically, it's the type of functions taking a value of type "st" as a parameter, and returning a pair of an "st" and an "a"
09:03:57 <int-e> walter__: functions are first class. A function of type st -> (st, a) is a value of that type. You could pass it as an argument to a function of type (st -> (st, a)) -> st -> a.
09:04:03 <EvilTerran> walter__, the actual types referred to by "st" and "a" being set by what parameters you provided to State
09:04:54 <EvilTerran> for instance, (\s -> (s,s)) :: t -> (t, t), so you could substitute in that type synonym, and write (\s -> (s,s)) :: State t t
09:05:07 <Jedai> Absolute0: You probably want something like "executeMove :: Position -> Move -> Move"
09:05:11 <int-e> walter__: and in that regard, (->) works just like other type constructors, except that you can write it as an infix "operator".
09:05:21 <Absolute0> Jedai: probably
09:05:31 <walter__> EvilTerran, understand, thank you
09:05:35 <int-e> > (id :: (->) Int Int) 3
09:05:36 <lambdabot>   3
09:05:49 <int-e> > (id :: Int -> Int) 3
09:05:50 <lambdabot>   3
09:06:19 <Twey> -> is magic in that it's an infix constructor that doesn't require a :
09:07:05 <Jedai> Absolute0: Also, when you're not sure of a type, you can write the function without a type signature and use :type in GHCi to determine the most general type of your function, then you eventually restrict it and you use it for your signature
09:07:16 <RayNbow> @quote knuth literate programming
09:07:16 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
09:07:18 <RayNbow> hmm...
09:07:33 <Absolute0> Jedai: Well i know the type just don't know how to phrase it yet. :)
09:09:35 <walter__> int-e, can u explain in more detail?
09:09:58 <int-e> Twey: infix type constructors are a language extension, btw.
09:10:01 <Absolute0> does haskell allow indexing on a tuple?
09:10:10 <hatds> no
09:10:24 <Absolute0> so how do I read the elements of a tuple?
09:10:26 <Absolute0> or process them
09:10:31 <hatds> pattern matching
09:10:40 <Berengal> Absolute0: Only on pairs, and only if you consider fst and snd to be indexing...
09:10:48 <Absolute0> ah
09:11:10 <byorgey> > let f (x,y) = x + 2 * y  in f (2,3)
09:11:11 <lambdabot>   8
09:11:30 <byorgey> f is defined on tuples by pattern-matching.
09:12:57 <int-e> walter__: I'm not sure. I meant to demonstrate that (->) A B and A -> B mean exactly the same thing in type signatures (namely the type of functions from A to B).
09:13:22 <walter__> int-e, I see, thanks
09:13:43 <Jedai> It wouldn't be very hard to write index function for the small tuples, it's just not the way tuples are used in Haskell
09:30:04 <sm> morning all
09:31:03 <sm> what's the best monad to use if I want to a "done" flag to bubble up out of some deep function calls, along with the data ?
09:31:25 <Berengal> Cont?
09:31:29 <sm> or should I just make an exception ?
09:32:23 <sm> Cont looks a little more than I need
09:32:57 <twanvl> Does the computation proceed as normal when the flag is set?
09:33:50 <sm> yes it does, I'd like to process the last data read from stdin and then terminate (because it was terminated with ctl-d)
09:34:51 <twanvl> You could try a Writer monad, that just adds an extra bit of output
09:37:14 <sm> hmm isn't there a tour of the monads somewhere ? I'm not seeing it
09:37:19 <BMeph> Is GHC "smart" enough to deal with a list that "builds" itself using inits? :)
09:37:45 <sm> the haddock gives me no clue what Writer does
09:38:27 <Berengal> Writer is like a limited State monad. You can't read the state, only write it
09:38:42 <sm> that sounds just right.. and aha, http://www.haskell.org/all_about_monads/html/index.html
09:38:58 <sm> but wait, I need to read it at the top surely
09:38:58 <gwern> Reader + Writer = State, as I understand
09:40:30 * sm reads this rather good reference doc
09:43:27 <dons> BMeph: if you have to ask that question, the answer is probably 'no'.
09:43:42 <dons> assuming you mean 'does it have any special rules?'
09:45:06 <pejo> dons, (returning to the catch discussion); did you have any examples of characterizations of what failures some analysis handled?
09:45:34 <BMeph> dons: I don't need any special rules, I'm just trying to make a function that takes a list, and builds a new list from it that depends on convoluting the inout with the prior elements of the "output", if that makes any sense. :)
09:47:43 <Jedai> @src inits
09:47:43 <lambdabot> inits []     =  [[]]
09:47:43 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
09:50:20 <jeff_s_>  testing :)
09:50:22 <jeff_s_> ah, good
09:58:04 <burp_> > [0.400,0.401..1]
09:58:05 <lambdabot>   [0.4,0.401,0.402,0.403,0.404,0.405,0.406,0.40700000000000003,0.408000000000...
09:58:12 <burp_> ugly :|
09:58:48 <byorgey> burp_: use Rational.
09:58:49 <burp_> >map (/1000) [400..1000]
09:58:52 <burp_> > map (/1000) [400..1000]
09:58:54 <lambdabot>   [0.4,0.401,0.402,0.403,0.404,0.405,0.406,0.407,0.408,0.409,0.41,0.411,0.412...
09:59:04 <burp_> I need them in double anyway
09:59:24 <paper_cc> has anyone here tried to build Leksah?
09:59:32 <paper_cc> it fails for me
09:59:33 <Beelsebob> paper_cc: yep
09:59:36 <Beelsebob> tried many times
09:59:41 <Beelsebob> failed in a different way every time
09:59:46 <Berengal> paper_cc: Tried and succeeded
09:59:54 <Renderwahn> managed to install it with the haskell gentoo overlay
10:00:07 <monadic_kid> cabal install leksah in fedora 10
10:00:30 <Berengal> I had to darcs get it and munge the cabal file some
10:00:47 <paper_cc> monadic_kid: src/IDE/Completion.hs: (...)Not in scope: sourceLanguageManagerGuessLanguage
10:00:51 <Jedai> paper_cc: Tried and succeded
10:01:23 * paper_cc couldn't find definitions for "sourceLanguageManager<Whatever>" in the sources
10:01:47 <monadic_kid> paper_cc: what are you doing? are using cabal install? is this under fedora 10?
10:02:08 <Jedai> paper_cc: Version 0.4.4.1, compiled on Ubuntu 9.04 with GHC 6.10.2
10:02:33 <Jedai> Using Cabal install, worked perfectly
10:02:50 <paper_cc> monadic_kid, Jedai: this is under Ubuntu Hardy 8.04, ghc 6.10.1, gtk2hs from darcs - both hackage and darcs version fail the same way
10:02:56 <Jedai> (of course the "hard" bit is beforehand when you have to install Gtk2Hs
10:03:00 <paper_cc> *versions
10:03:22 <Jedai> I used a release for Gtk2Hs, 10.1
10:04:13 <Jedai> Ooops, no it's 0.10.0
10:04:30 <monadic_kid> paper_cc: i'm using .10.1 trying using cabal install
10:04:43 <Jedai> May explain the difference of results with you (also I managed to install almost all Gtk2Hs)
10:04:54 <monadic_kid> paper_cc: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:06:20 <paper_cc> ah, the sourceLanguageManagerStuff is from GtkSourceView...
10:07:11 <paper_cc> (while release notes recommend to use the development version of Gtk2Hs)
10:07:59 * thoughtpolice is tired of fucking around with gtk2hs on OS X
10:09:04 <thoughtpolice> having gtk2hs use x11 sucks, but building it on the gtk framework at www.gtk-osx.org basically gives you, like, gtk, glib, and maybe 2 other libs and that's it
10:09:07 <thoughtpolice> which kinda sucks
10:09:30 <dcoutts> thoughtpolice: latest gtk includes gtkbuilder, the replacement for glade
10:09:41 <thoughtpolice> dcoutts: 0.10.1 ?
10:09:51 <dcoutts> thoughtpolice: shouldn't be more than an hours work for you to bind gtkbuilder and send in the patches
10:10:03 <dcoutts> it's a simple port of the libglade api binding
10:10:28 <thoughtpolice> dcoutts: currently trying to get a registered GHC HEAD build for osx-x86_64, but I might try it sometime...
10:10:31 <dcoutts> and the latest glade program can generate both, gtkbuilder is the way to go
10:10:35 <thoughtpolice> (debugging compilers is fun!)
10:10:43 <dcoutts> gnome 2.28 deprecates libglade even
10:10:55 <dcoutts> thoughtpolice: :-)
10:11:21 <paper_cc> where has sourceLanguageManagerGuessLanguage gone in the darcs version??
10:11:24 <thoughtpolice> it's when you don't have stack traces that things get a little hairy :)
10:11:27 <paper_cc> *of gtk2Hs
10:12:13 <Le-Chuck_ITA> Hi there. I am wondering a basic question about alpha-conversion. If there are better channels to talk about that just tell me, I thought that the "lambda" in the haskell logo speaks for itself :)
10:12:43 <Le-Chuck_ITA> The question is: the standard definition of alpha conversion is not expressed in equational logic, because of the side conditions on freshness
10:13:05 <thoughtpolice> dcoutts: but that's good to hear. it would be uber awesome to have a mac installer for gtk2hs that installed all the necessary stuff along with the libraries... maybe something to work on after I fix this build and whatnot (however long that may take)
10:13:29 <Le-Chuck_ITA> but if I just take the syntax of the lambda calculus and use as axioms all the pairs <t1,t2> whre t1 and t2 are alpha convertible... I just gave an equational definition of alpha conversion!
10:14:01 <Le-Chuck_ITA> not definition, but axiomatisation at least
10:14:01 <dcoutts> thoughtpolice: yes, the main thing holding back osx support is someone with access to osx to do the work there.
10:14:46 <pejo> dcoutts, doesn't Well-typed have a mac for other purposes? (Not suggesting that you should do all the work though).
10:15:26 <dcoutts> pejo: nope, I've got XP in a VM, but no OSX. They don't sell it without the hardware, and with the hardware it's pretty expensive, ~£500 for a mac mini.
10:15:55 <dcoutts> pejo: MSR loan Igloo a mac laptop for ghc development
10:17:04 <EvilTerran> Le-Chuck_ITA, an infinite axiomatisation, though
10:17:27 <dcoutts> pejo: course if someone wants to pay for better gtk2hs support on osx, windows, whatever then we'd be happy to discuss it with them :-)
10:17:45 <Le-Chuck_ITA> EvilTerran: I see, but: is this the only problem? If so, there are many languages (e.g. the pi-calculus) whose set of axioms is infinite
10:18:14 <Le-Chuck_ITA> EvilTerran: I wonder this because I want to understand the true motivation in seeking more advanced models for the syntax, e.g. presheaves
10:18:22 <EvilTerran> Le-Chuck_ITA, i think you'll find expressing "all the pairs <t1,t2> whre t1 and t2 are alpha convertible" rigorously is going to be pretty fiddly
10:18:40 <Le-Chuck_ITA> EvilTerran: no I would use the "external" non-equational definition for that
10:18:41 <pejo> dcoutts, well, I think you have to go to someone else than students to find the funding. :-)
10:19:03 <dcoutts> pejo: yes, of course
10:22:40 <pe> Hi. In the FFI, if I use a record to marshal to/from a C struct, how do I tell it to free the C struct whenever the record is GCed ?
10:23:55 <Lemmih> malosh: Attach a finalizer. ForeignPtr have good support for doing exactly that.
10:24:20 <pejo> dcoutts, regarding my question the other day about compiler support for cabal: do you happen to know offhand if it would be much more work to make it work for a different language? (Not using hackage, but the infrastructure in general).
10:24:29 <malosh> Lemmih : yes, but I want to be able to use my record like a haskell record, not like a ForeignPtr
10:25:10 <dcoutts> pejo: I expect you could copy a lot of code, concepts and organisation but I fear there's a lot that's specific to Haskell and the individual compilers
10:25:39 <dcoutts> pejo: it wasn't exactly designed as an ideal abstraction I'm afraid, more to get working quick
10:26:00 <Lemmih> malosh: If you don't have any pointers to the struct then why do you care when it is freed?
10:27:22 <pejo> dcoutts, would you be interested in abstraction patches, assuming those would somehow magically appear?
10:27:23 <malosh> Actually I have a pointer : I call a C function that mallocs a struct and give me a pointer, then I marshal it to a record, and when the record is not referenced anymore, I'd like the pointer to be freed
10:27:41 <dcoutts> pejo: absolutely, if I had more time I'd be working on it myself :-)
10:28:06 <dcoutts> pejo: if you have spare time then I'd be happy to share my ideas about structural improvements
10:28:30 <Lemmih> malosh: Why not free it after you've marshalled the structure?
10:29:58 <malosh> cause it is a heavy structure and I don't want to marshal in both directions again and again all the time
10:30:24 <malosh> each time it costs a malloc + xx bytes of copy + a free
10:31:42 <Lemmih> I'm not following. You want to move from C to Haskell and then back to C?
10:31:57 <malosh> yes
10:32:09 <malosh> I'm calling a C function on the structure
10:32:31 <malosh> my current solution is to include a ForeignPtr in the record
10:32:31 <Lemmih> Right, I'm with you so far.
10:33:00 <malosh> but it results in double frees
10:33:25 <Lemmih> That should be correctable.
11:01:55 <roconnor> @seen ski
11:01:55 <lambdabot> Last time I saw ski was when I left ##freebsd, ##hrg, ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #
11:01:55 <lambdabot> haskell-hac07, #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr, #haskell.it, #haskell.jp, #haskell.no, #haskell.ru, #
11:01:55 <lambdabot> haskell.se, #haskell_ru, #jhc, #jtiger, #perl6, #rosettacode, #scala, #scannedinavian, #unicycling and #xmonad 7m 21d 3h 33m 28s ago, and .
11:02:20 <roconnor> @seen ski_
11:02:20 <lambdabot> ski_ is in #haskell.se, #haskell.hr, #haskell-in-depth, ##logic and #haskell. I don't know when ski_ last spoke.
11:04:27 <jberryman> I think after running 'cabal upgrade' I now have different, newer versions of a lot of the standard libraries installed as user, and GHC is getting confused. not even sure where they are stored. easiest way to fix that?
11:05:12 <dcoutts> jberryman: first, upgrade your cabal-install version, the newer version disables 'cabal upgrade' so you can't shoot yourself in the foot again
11:05:41 <dcoutts> jberryman: basically you want to unregister the user versions of the core libs and then rebuild as appropriate to fix things
11:06:18 <dcoutts> jberryman: use ghc-pkg list to see the versions you've got, ghc-pkg unregister --user $name and ghc-pkg check
11:09:04 <jberryman> dcoutts: thanks a lot. I just discovered the user libs installed with cabal are found in ~/.cabal of course
11:28:41 <eli> Does anybody know template haskell?
11:31:27 <copumpkin> our resident template haskell fan is out right now :/
11:32:06 <eli> Who is he?
11:32:42 <copumpkin> mmorrow enjoys TH a lot
11:32:57 <copumpkin> ChilliX is also gone, and he wrote a lot of the TH code in GHC
11:33:35 <eli> OK, hopefully I'll remember the names...
11:34:12 <eli> Although I suspect that just a shallow knowledge of the thing is enough for answering my question.
11:34:37 <copumpkin> try asking, maybe someone else will know :)
11:35:12 <eli> The question is whether TH is hygienic or not.
11:35:50 <eli> If it is -- then to what degree (for example, does it work with modules, is there any concept of phases etc),
11:36:20 <eli> and if it isn't, then are there common workarounds (eg, some gensym-like tool).
11:36:24 <copumpkin> as defined on http://community.schemewiki.org/?scheme-faq-macros ?
11:36:31 <copumpkin> (hygiene)
11:37:02 <Heffalump> it does have a gensym
11:37:34 <eli> copumpkin: Yes, sort of -- having modules makes it one level deeper.
11:37:46 <eli> Heffalump: So that means that it is not hygienic?
11:38:03 <eli> (it = TH)
11:38:13 <Heffalump> well, sort of
11:38:28 <Heffalump> it works directly on the underlying AST, with the fresh names
11:38:57 <eli> ...and the gensym-like tool is a way to get a fresh identifier?
11:39:13 <Heffalump> yes (it's one of the things the Q monad gives you)
11:39:43 <eli> OK, thanks.  -- IIUC, this sounds much like camlp4.
11:39:56 <Heffalump> yes, it's much closer to that than to scheme macros
11:40:30 <sm> isn't (m a, m b) -> m (a, b) a reasonable hoogle search expression ? I find nothing
11:40:41 <Heffalump> I think you'd find it hard to accidentally introduce name capture, btw
11:40:54 <Heffalump> though I haven't used it enough recently to have a confident opinion on that
11:41:14 <copumpkin> sm: I don't know of any such function... is it like a sequence for tuples? and what'
11:41:15 <Heffalump> but most stuff you can do constructs new expressions within Q
11:41:16 <ray> @hoggle m a -> m b -> m (a, b)
11:41:17 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
11:41:17 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
11:41:17 <lambdabot> Language.Haskell.TH strictType :: Q Strict -> TypeQ -> StrictTypeQ
11:41:24 <Heffalump> s/expressions/ASTs/
11:41:40 <Heffalump> but it certainly lets you *deliberately* capture names if you want to
11:41:56 <Heffalump> @type liftM2 (,)
11:41:57 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:42:10 <eli> Heffalump: Thanks again.
11:42:17 <Heffalump> eli: also, there's no explicit concept of phases
11:42:18 <Cale> Wow, gapminder.org has gotten a lot more interesting to play with since I last looked at it.
11:42:20 <ray> :t uncurry $ liftM2 (,)
11:42:22 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
11:42:22 <Heffalump> but you could structure your code to use one
11:42:27 <ray> tada!
11:42:46 <Heffalump> and finally, it doesn't let you generate entirely new modules or even import statements for existing ones (IIRC)
11:43:02 <copumpkin> yeah :/
11:43:07 <eli> Heffalump: Thanks^3.  That's defintely enough information for what I need.
11:43:16 * sm bookmarks that
11:44:05 <Heffalump> another interesting point is that it interacts badly with the dependency analysis done before HM type inference
11:46:02 <Heffalump> actually, on the subject of phases, if you want Meta-OCaml style phasing where you can generate code that then generates more code, I don't think you can do that (though since it's not type-safe in the sense of checking that your TH code can't generate bad code before it actually runs it, I don't know why anyone would care about that feature)
11:46:55 <copumpkin> eli *poof*ed, but I'll highlight him so he can see the past couple of messages you sent :P
12:05:39 <dons> ?yow
12:05:40 <lambdabot> Now I'm having INSIPID THOUGHTS about the beatiful, round wives of
12:05:40 <lambdabot> HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS and being approached
12:05:40 <lambdabot> by SMALL BOYS selling FRUIT ...
12:05:45 <dons> yikes
12:05:59 <inimino> lol
12:06:43 <inimino> what goes on in the mind of the lambdabot, nobody knows
12:06:56 <dons> it's a dark mystery
12:07:48 <Vq^> thats one of my favourite zippy quotes :)
12:10:44 <Peaker> I analyzed roconnor's writer monad implosion of complexity and now I know why it happens -- simply ghc's lack of memoizing of function results (hidden behind the state binds)
12:11:28 <Heffalump> actually GHC is memoizing function results in the Writer case
12:11:34 <Heffalump> (locally, by doing CSE)
12:11:47 <Heffalump> in the State case memoization wouldn't apply, because the inc will have a new input each time
12:14:28 <BMeph> This is "kind-of" what I'm trying to do, but I don't see quite how to express it in a "tie-the-knot" fashion: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5168#a5169
12:14:47 <BMeph> Anyone care to take a crack at it? :)
12:15:34 <Heffalump> I don't understand the spec
12:15:58 <dons> it's just CSE, isn't it?
12:16:11 <Heffalump> dons: which, the implosion of complexity?
12:16:25 <dons> the optimization ghc's applying in the writer case
12:16:28 <Heffalump> yes
12:16:33 <dons> good for GHC.
12:16:35 <Heffalump> the reddit thread confirms it
12:16:38 <Heffalump> someone looked at the core
12:16:44 <dons> yay!
12:16:59 <roconnor> > (13983815/13983816)^36000000
12:17:01 <lambdabot>   7.619917265611743e-2
12:17:16 <roconnor> hmm 7.6%
12:17:24 <dons> pure functional programming: don't do the same thing twice and expect different answers.
12:17:53 <dons> i guess it is a surprising complexity-changing accident
12:17:56 <dons> those are always fun
12:17:56 <roconnor> programming insanity is calling the same function twice with the same parameters and expecting different results.
12:18:04 <dons> :)
12:18:20 <dons> we should have that on stickers to hand out at ICFP
12:18:34 <roconnor> it's a nice one
12:19:20 <Igloo> Surely you need to hand that out at OOPSLA, not ICFP
12:19:27 <dons> i'm thinking of bringing a box of haskell logo badges to give away at ICFP/HW. fun little bit of community branding
12:19:32 <dons> Igloo: true
12:20:02 <roconnor> > 100-7.6
12:20:04 <lambdabot>   92.4
12:20:48 <roconnor> where is ICFP this year?
12:20:49 <Heffalump> Igloo: well, at the ML/Scheme/Erlang workshops too..
12:20:52 <Heffalump> roconnor: Edinburgh
12:20:55 <roconnor> ah
12:21:02 <Igloo> True
12:21:47 * roconnor doesn't like it when conferences are held in the US, UK, or North Korea.
12:21:57 <BMeph> I think the best way to express it is that Writer is memoizable inherently, whereas the State version is so only due to the way it's being used. Does that make sense?
12:22:29 <Heffalump> roconnor: you could try to persuade the Scots to declare independence beforehand
12:23:15 <roconnor> What I find interesting is that edwardk's CPS monad stack transformation normally speeds up monadic code, but would destroy the CSE in this case.
12:23:43 <roconnor> Heffalump: Do you think they would have more reasonable visa entry requirements?
12:24:21 <roconnor> Heffalump: I will pen a letter to my Queen ... who also happens to be your Queen.
12:24:47 <dons> roconnor: good plan.
12:24:50 <dons> i wish that worked :/
12:24:51 <Heffalump> roconnor: errm, what nationality are you?
12:24:56 <roconnor> Canadian
12:24:56 <Igloo> roconnor: Am I right in thinking you're Canadian?
12:24:59 <p_l> roconnor: heh, at least EU laws relieve me of VISA requirements for UK... (but they still managed to get "interesting" work laws)
12:25:02 * dons is frustrated at the zero-benefits of being a commonwealth citizen
12:25:06 <dons> stupid empire
12:25:06 <Heffalump> can't you just show up and say "I'm one of the good guys, let me in"?
12:25:10 <Heffalump> I'm sure dons did that..
12:25:14 <dons> :D
12:25:19 <Heffalump> (and the immigration officers actually fell for it, too)
12:25:25 <dons> ssssh!
12:25:26 <roconnor> Heffalump: ya, but my Iranian born friend cannot.
12:25:31 <Igloo> Ah, OK
12:25:33 <Heffalump> roconnor: ah, right
12:25:42 <dons> yes, it's probably a rubber stamp for .ca , .au . maybe .nz too ;)
12:25:44 <p_l> Heffalump: No, the only option in US is to say that you are a terrorist (there's a checkbox on VISA application, afaik) :P
12:25:58 <Heffalump> p_l: or that you took part in WWII Nazi atrocities
12:26:05 <Heffalump> p_l: what nationality are you, then?
12:26:16 <p_l> Heffalump: Polish, studying in UK
12:26:24 <Heffalump> I thought Poles had full work rights?
12:26:25 <copumpkin> isn't there a checkbox saying you intend to assassinate the president?
12:26:25 <roconnor> dons: are you still Austrailian?
12:26:31 <dons> I am.
12:26:32 <Heffalump> It was Romanians and Bulgarians that didn't get them
12:26:41 <copumpkin> in the US
12:26:45 <dons> roconnor: dual-citizenship takes a /long/ time.
12:26:51 <dons> i've only been away 2 years.
12:27:14 <roconnor> dons: in 2001 I got into Zimbabwe without a visa because I was from a commonwealth country.
12:27:17 <p_l> Heffalump: That's what they want you to think
12:27:22 <roconnor> dons: ... then they were booted out of the commonwealth.
12:27:27 <Igloo> dons: Right, you need to stay there long enough that you start refering to it as "here" rather than "away"  :-)
12:27:43 <Heffalump> p_l: so what did they do?
12:27:43 <dons> roconnor: interesting. maybe the real empire nations have some commonwealth anacronisms
12:28:06 <roconnor> dons: I think you may find that to be the case.
12:28:17 <BMeph> dons: I thought you had to be born a dual citizen, and that naturalization means giving up citizenship with any other states.
12:28:20 <dons> Igloo: yeah :) i'm in a mixed state atm. half my words have changed, some of my accent. give it another 3 years and the conversion will be complete.
12:28:59 <roconnor> BMeph: you have to tell the US that you gave up your citizenship; however often your country of origin won't recoginize that rejection.
12:29:15 <dons> and you /don't/ have to surrender your passport
12:29:27 <p_l> Heffalump: "Worker Registration Scheme" - to work over 30 days you have to send your ID/passport to Home Office together with £90 (together with a letter from your employer, *after* you signed contract)
12:29:34 <Heffalump> roconnor: the US doesn't actually view that statement as giving up your citizenship either, they just include it in the oath
12:29:50 <roconnor> Heffalump: oh.
12:30:02 <BMeph> roconnor: Ah, so, a typical US arrangement - if you pretend to obey, they pretend to accept it. ;p
12:30:28 <Heffalump> p_l: oh, I see. Does it actually matter in practice, apart from them fleecing you for the 90 quid?
12:30:54 <p_l> Heffalump: After 12 months of *constant* (i.e., you can't be without work for more than 30 days), you can apply to get residency. You have also to notify them everytime you change jobs
12:31:10 <p_l> Heffalump: Yes, because without WRS, you're illegal worker
12:31:20 <wli> Last I checked there are no known cases of anyone successfully repudiating US citizenship.
12:31:35 <Heffalump> p_l: sure, but it's just paperwork, they can't stop you working if you jump through their hoops
12:31:50 <copumpkin> wli: it isn't hard, but it certainly helps to have another citizenship to back you up
12:32:11 <BMeph> dons: So, why not become a Canadian citizen? BC's a day-trip away from PDX, and that "half my words have changed" bit sounds about right for Canadian English... ;)
12:32:33 <p_l> Heffalump: The great idea is that officially it's the employer's obligation, but it's the worker who has to send it. and it's very easy to be not employed for >30days...
12:32:33 <Heffalump> BMeph: because that's not where he's living..?
12:33:17 <Heffalump> p_l: I don't follow. Get job, fill in form, send in your money, and you're done, surely?
12:33:20 <p_l> Heffalump: Also, it prohibits you from getting any kind of benefits if you end up without a job in shitty situation
12:33:25 <Heffalump> (and send in new form if you change jobs)
12:33:44 <Heffalump> p_l: sure, but that's nothing to do with employment rights
12:34:14 <p_l> Heffalump: Let's say that it's not so nice in practice...
12:34:14 <Heffalump> The "pay us 90 because we want to keep track of you" is pretty annoying though
12:34:28 <Heffalump> because of an employer, or because of the Home Office?
12:34:33 <p_l> Heffalump: Especially when you're penniless student
12:35:06 <p_l> Heffalump: Because of Home Office. The funny thing, they even got UN questioning them... and decided to extend it for another 2~3 years (it was supposed to end this year)
12:37:33 <p_l> in practice it's not so nice
12:38:04 <Heffalump> it's not even like they can screw up your right to work by not sending the card/certificate, if you applied with in the 30 days
12:38:47 <p_l> Heffalump: If they don't send, you can't work
12:39:36 <p_l> what is really annoying is that they managed to extend it quite nicely outside of work...
12:39:57 <Heffalump> that's not what the Home Office guidanance says: the employer just has to keep a copy of the application form to not get in trouble
12:40:35 <p_l> Heffalump: You get a confirmance letter, at least that was it when I was still battling with it
12:40:53 <Heffalump> yes, but until that turns up they just have to keep the copy of the application and they're fine
12:40:58 <Heffalump> and you are allowed to start working immediately
12:41:27 <Heffalump> page 65 of http://www.ukba.homeoffice.gov.uk/sitecontent/documents/employersandsponsors/preventingillegalworking/currentguidanceandcodes/comprehensiveguidancefeb08.pdf?view=Binary
12:41:33 <BMeph> So, anyone in the mood to help me with my Haskell-related issue? :)
12:41:37 * p_l managed to fuckup his job thanks to WRS
12:41:42 <Heffalump> BMeph: I still don't understand it :-p
12:41:56 <byorgey> BMeph: what's your Haskell-related issue?
12:42:28 <RayNbow> @faq Can Haskell distract you from boring work?
12:42:28 <lambdabot> The answer is: Yes! Haskell can do that.
12:42:34 <RayNbow> damn you, Haskell! :p
12:42:43 * Heffalump spent all of Friday refactoring a really grungy bit of Haskell
12:42:54 <BMeph> This is "kind-of" what I'm trying to do, but I don't see quite how to express it in a "tie-the-knot" fashion: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5168#a5170
12:42:55 * RayNbow looks at the unfinished work that's been piling up :p
12:43:11 <roconnor> Heffalump: is it beautiful now?
12:43:17 <Heffalump> BMeph: I don't understand the problem though
12:43:22 <Heffalump> roconnor: it's better. Still needs some work.
12:43:26 <Heffalump> But I did delete quite a lot of stuff.
12:43:48 <p_l> Heffalump: What is really annoying is that feeling that they will keep it indefinitely (as well as whatever they passed for Romanians and Bulgarians). Just a feeling of disgruntled student ;-)
12:44:05 <Heffalump> p_l: yeah, sounds like a nice little earner for them
12:44:40 <p_l> Heffalump: Another thing that annoys me is the hypocrisy behind the law concerning it
12:45:15 * roconnor looks at his unfinished thesis laying there.
12:45:18 <Heffalump> I'm not saying I agree with the situation, just that it doesn't really seem that bad if you're not from Romania or Bulgaria
12:45:27 <BMeph> Heffalump: The function is a sort of self-consuming convolution. I'm trying to express it that way, but in a way that GHC will 1) compile; and 2) give an answer. :)
12:45:55 <p_l> Heffalump: I'd be much less angry about it if they simply named it "work permit" like it is and admitted that its goal is to make UK job market less interesting...
12:46:08 <Heffalump> so you want to flip-flop between invert and invertI?
12:46:17 <Heffalump> p_l: but it's a work permit they have to give you
12:46:25 <p_l> Heffalump: They can refuse
12:46:29 <Heffalump> on what grounds?
12:46:36 <p_l> Heffalump: On whatever they fancy
12:46:44 <Heffalump> I don't believe that
12:47:03 <BMeph> Heffalump: No, I want to find a less "kludgy" way of expressing the functions, that works. (That is, it gives the right answer.)
12:47:52 <p_l> Heffalump: In my case my employer terminated my contract waiting for Home Office decision, so the decision ended being "you're not employed so you don't get registered, we'll send you a refund in snail mail with a snail cheque" ;-/
12:48:15 <Heffalump> p_l: terminated your contract because you didn't get the card, or for other reasons?
12:48:47 <p_l> Heffalump: Because the whole thing was taking ages (I had to first return to Poland for additional documents, cause I couldn't part with my national id)
12:49:20 <Heffalump> p_l: but your employer could have just kept the application and kept employing you, if it was sent in time (and yes, having to give them your documents sucks)
12:49:38 <Heffalump> BMeph: I still don't understand what the functions are actually doing
12:49:39 <BMeph> RayNbow: I'd be cautious around Haskell - it seems especially distracting to Dutch programmers. ;)
12:49:43 <gwern> 'The original Copycat was written in Common Lisp and relies on now-outdated graphics libraries; however, a modern Java port exists.' <-- ouch
12:49:58 <p_l> Heffalump: The funny thing is, that getting a work permit in Norway would take me... <1day
12:50:01 <b_jonas> BMeph: wtf?
12:50:29 <BMeph> gwern: ROFL!
12:50:50 <p_l> gwern: I'd take the Common Lisp version :D
12:52:54 <BMeph> Heffalump: Let's see... let's say bs = invert as. Then bs!!0 = as!!0, and bs!!i = as!!i + sum (zipWith (*) as (reverse (take i bs))).
12:53:09 <BMeph> (If that's any clearer than mud... ;p
12:53:12 <BMeph> )
12:54:11 <Heffalump> ok, I sort of see
12:54:12 <RayNbow> BMeph: if only the project I have to work on was written in Haskell... I would probably be less distracted :p
12:54:32 <BMeph> Heffalump: Where the sum (zipWith...) part is the convolution.
12:55:07 <BMeph> RayNbow: Yes, that's how it starts... ;)
12:55:16 <Heffalump> so does the code you pasted work?
12:57:36 <BMeph> Heffalump: I doubt it. I tried a version where I didn't have the as-pattern and such, but that one wouldn't give an answer. I'm trying to get this version to compile now. :)
12:59:18 <dons> shapr: coming to Hac Phi?
13:00:35 <byorgey> he better be =)
13:00:48 <byorgey> but he doesn't seem to be on IRC atm
13:01:09 <Philippa> p_l: public sector admin's appallingly slow in the UK generally :-( And they do lots of things they "shouldn't" because it takes a lot of know-how and energy to fight it and the individuals involved aren't trained well enough to not do it
13:01:33 <dons> byorgey: thinking i might cash in some frequent flyer miles if you hold it in july
13:01:44 <byorgey> dons: that would be awesome!
13:01:52 <byorgey> dons: it's definitly going to be in July
13:01:59 <Heffalump> it depends on whether you actually need them to do something or not; since in this case you just need to have put the application in, it shouldn't really matter if they screw up or not
13:02:02 <dons> sweet. ok. i'll be there.
13:02:04 <byorgey> not a single person has expressed a preference for June =)
13:02:10 <BMeph> Does anyone know zipWith's strictness characteristics?
13:02:20 <dons> byorgey: i can prob. help with organization support too, passing on ideas from the euro hacs
13:02:38 <Heffalump> BMeph: they shouldn't be relevant since your lists are infinite, right?
13:02:39 <sbahra> yo whats up dawg
13:02:49 <Heffalump> oh, but it might not see that immediately, hmm
13:02:54 <byorgey> dons: that would be great, actually, we were planning on asking for some ideas/advice from people who have organized one before
13:02:59 <dons> great.
13:03:03 <copumpkin> sbahra: go to hac phi!
13:03:14 <sbahra> I need to work on Haskell for that.
13:03:22 <dons> you can ping the 'steering comittee' of euro hac. dcoutts, Heffalump, kosmikus,  me (bringert and igloo also have a lot of experience)
13:03:31 <sbahra> I'm finally going to get back to my web server, now that I have dedicated server that supports GHC.
13:03:38 * Cale writes a long reply to http://www.reddit.com/r/compsci/comments/8mpma/ask_compsci_where_are_the_special_numbers/c09rs2a
13:03:54 <yaxu1> hoo, i'm top on haskell reddit, thanks dons :)
13:03:54 <byorgey> dons: cool, thanks, will do so soon!
13:03:59 <b_jonas> we could have a separate type for definitely infinite lists that only has one constructor
13:04:12 <dons> byorgey: and feel free to grab the "branding" on the other hac sites on the wiki
13:04:15 <BMeph> Heffalump: Not necessarily. They can be infinite, and I tried to write the functions in a way that could acomodate it, but they don't have to be.
13:04:24 <dons> the logo, links to previous hacs, structure for registration et al
13:04:35 <b_jonas> @src zipWith
13:04:35 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
13:04:35 <lambdabot> zipWith _ _      _      = []
13:04:36 <byorgey> right, ok
13:04:38 <jberryman> b_jonas: that is defined in the 'streams' lib I believe
13:04:44 <dons> its a grassroots thing, so anyone can use the resources
13:04:51 <Heffalump> ok, so it's strict in both arguments
13:04:56 <b_jonas> streams... /me looks
13:04:57 <chrisdone> does anyone have a link about how an infix-left ($) could be useful?
13:04:59 <byorgey> yep
13:05:04 <BMeph> *accommodate
13:05:18 <b_jonas> "hinze-streams library: Streams and Unique Fixed Points" -- is this it?
13:05:24 <copumpkin> > map fst $ zip [0..] (repeat undefined)
13:05:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:05:37 <Cale> chrisdone: It would be much more useful than the current one... it doesn't take a page to explain :)
13:05:51 <aconbere> anyone spent any time in hopengl?
13:06:07 <Cale> chrisdone: Consider trying to remove the parens from  f (g x y) (h y z) (k x z)
13:06:09 * BMeph is going with Cale on that.
13:06:14 <sbahra> copumpkin, I also need to get on the FreeBSD haskell project, as soon as possible.
13:06:24 <jberryman> b_jonas: sorry, http://hackage.haskell.org/packages/archive/Stream/0.3.1/doc/html/Data-Stream.html#v%3A%3C%3A%3E
13:06:28 <sbahra> Creating ports becomes boring, quickly.
13:06:48 <b_jonas> jberryman: thanks
13:06:50 * BMeph almost asked Cale if that should've been (k z x)
13:06:55 <Cale> heh
13:07:10 <Cale> chrisdone: If $ were left associative, we could write f $ g x y $ h y z $ k x z
13:07:25 <Berengal> Man, I'm having the dumb today. I can't even get a simple fixed point function right...
13:07:46 <Cale> Whereas currently, that means the same thing as f . g x y . h y z $ k x z
13:08:07 <Heffalump> I think Cale just wants to help the next IOHCC along.
13:08:11 <Cale> which is f (g x y (h y z (k x z)))
13:08:50 <Cale> Heffalump: Sorry about the one-letter variable names, I just can't be bothered to come up with real examples :)
13:09:07 <Heffalump> I meant with the lack of brackets too
13:09:22 <Cale> brb
13:09:41 <lament> so i have a program, it like, does some actual work
13:09:49 <Cale> Heffalump: I can imagine it would often help with clarity.
13:09:57 <Heffalump> lament: it can't be written in Haskell then </jdh30>
13:10:14 <b_jonas> oh, I just wrote a program that's really ugly because almost all of its variables are one letter long
13:10:14 <chrisdone> cale: is `f (g x y) (h y z) (k x z)' the same as `f (g x y (h y z (k x z)))'?
13:10:15 <lament> but on profiling, this function is 7% of the time spent:
13:10:16 <lament> boardInProgress (MIP board _ _ _) = board
13:10:21 <lament> ??? come on Haskell
13:10:44 <lament> this is after i inlined it, before it was 10%
13:10:53 <Heffalump> lament: the profiler might be confused
13:11:07 <Heffalump> is MIP strict in board?
13:11:12 <Heffalump> and if not can it be?
13:11:18 <b_jonas> this one: http://erxz.com/pb/17772
13:11:27 <lament> i haven't tried that
13:11:32 * lament does
13:12:27 <b_jonas> I mean, I always use lots of short variable names in my code but this is crazy even compared to my usual style
13:12:36 <aconbere> oooo
13:12:40 <lament> Heffalump: you're right, it's 4% now
13:12:43 <aconbere> reshape s@(Size w h) = do
13:12:47 <aconbere> does that @ syntax
13:12:53 <aconbere> mean bind the input to s
13:12:54 <lament> Heffalump: this means that the program isn't any faster, the time is just reported elsewhere?
13:12:59 <EvilTerran> > let x@(y,z) = (1,2) in (x,y,z) -- aconbere
13:13:01 <lambdabot>   ((1,2),1,2)
13:13:01 <aconbere> and pattern match the data structure?
13:13:07 <Twey> Yes.
13:13:10 <aconbere> awesome
13:13:11 <Heffalump> lament: well, you've just removed some closures that aren't necessary, so it might be a bit faster
13:13:12 <EvilTerran> (i think that's a yes)
13:13:15 <aconbere> I was wonering how to do that the other day
13:13:17 <aconbere> :)
13:13:24 <Heffalump> 4% is still quite a lot, how many times is the function entered?
13:13:30 <Heffalump> and how much absolute time does it take
13:13:40 <EvilTerran> aconbere, intuitively enough, they're called "at-patterns"
13:13:43 <b_jonas> I wish mathematicians used multi-letter variables because when I wrote my thesis I had to do lots of shuffling around to not have conflicting variable names
13:13:48 <aconbere> hahaha
13:14:09 <Twey> b_jonas: The general Haskell style is ‘if you need more than one letter to make it clear, your function is too complicated’ ;)
13:14:20 <lament> Heffalump: about 7 million, about tenth of a second
13:14:21 <aconbere> b_jonas: we use not's a lot, (x0, y0, z0 etc)
13:14:31 <chrisdone> Cale: I've got, for example: lift $ forkIO $ (evalStateT . irc_Monad) handler undefined. the problem with ($) occurs when one needs to provide more than one argument, you have to revert back to parentheses
13:14:35 <aconbere> there's a pretty strong precident for variable suffixes
13:14:56 <b_jonas> Twey: sure, the gnu coding style recommends that a function should usually be at most two pages long (which means 50 lines) and have at most 7 local variables, and I fully support that
13:15:01 <b_jonas> lots of small functions
13:15:07 <EvilTerran> aconbere, it sounds like you might be at the right level haskell-wise to find reading the Report insightful
13:15:16 <EvilTerran> aconbere, in a "oh hey, i didn't know i could do that!" sort of way
13:15:26 <aconbere> "the Report"?
13:15:27 <aconbere> :)
13:15:28 <Heffalump> lament: so it's spending about 14ns on each one?
13:15:33 <b_jonas> that doesn't really work in a mathematical paper though, because of the language it uses
13:15:34 <Twey> b_jonas: 50LoC is wayyyy too big for a function.
13:15:35 <EvilTerran> @where report
13:15:36 <lambdabot> http://www.haskell.org/onlinereport/
13:15:42 <b_jonas> Twey: it's a maximum
13:15:55 <b_jonas> Twey: and it's for C, haskell is more vertically concise
13:15:56 <Twey> It's an over-large maximum
13:16:02 <EvilTerran> aconbere, ^ it's the Haskell standard. it's remarkably short.
13:16:04 <Twey> For any decent language
13:16:08 <b_jonas> no, not for C
13:16:18 <aconbere> awesom :)
13:16:18 <chrisdone> b_jonas: 50 lines and how many columns?
13:16:34 <b_jonas> chrisdone: doesn't matter, I code the same no matter how many columns
13:16:41 <b_jonas> (I use 100 columns on screen)
13:16:49 <chrisdone> reading horizontally is a pain ..
13:16:58 <lament> Heffalump: I made all the other elements of the MIP constructor strict and now it's 2% :)
13:17:02 * EvilTerran sticks to 80 columns
13:17:10 <chrisdone> 80 is good
13:17:21 <Heffalump> lament: ok, but if your numbers and my calculations are correct, I don't think you actually have anything to complain about.
13:17:33 <idnar> I usually wrap at 80 columns, but my screen is a lot wider than that :P
13:17:34 <Heffalump> Even something simple needs a few CPU cycles!
13:17:35 <Cale> chrisdone: no, it's not the same
13:17:39 <lament> Heffalump: yeah, i guess not. It does seem like it gets called too often, too.
13:17:41 <Cale> (I had to get up for a moment)
13:17:48 <idnar> it lets me put code side by side easily, though, and longer lines are a lot harder to read
13:18:19 <BMeph> I use 80 cols, but only because printing it out on paper looks better. :)
13:18:28 <EvilTerran> idnar, if my screen was wide enough for 160+ columns, i'd do the same
13:18:33 <tetha> I am not sure if I want to understand a 200-column-wide line
13:18:40 <EvilTerran> 1024x768 D:
13:18:42 <aconbere> EvilTerran: I really don't know where I am in the haskell sense. It's been a fun experience though. I wrote some very straight forward code that parsed and manipulated some large simple files. And recently went to use it to play with openGL and that's caused some leaps in understanding.
13:19:05 <aconbere> but I'm down to read the standard
13:19:05 <Cale> chrisdone: I normally recommend against using multiple $'s in a chain with the current associativity, since all but the last can always be replaced with (.)
13:19:11 <aconbere> I suspect there might be some gems in there
13:19:15 <idnar> EvilTerran: I've got 1680x1050 currently, but my next monitor will probably be 1920x1080
13:19:17 <b_jonas> chrisdone, EvilTerran: it doesn't really matter, how I wrap code isn't really changed by how many columns I view the code with
13:19:21 <aconbere> :)
13:19:30 <idnar> EvilTerran: I need more monitors and a bigger desk :P
13:19:40 <Cale> chrisdone: (.) has nicer properties as an operator (it is associative, for one), and so it makes things easier to manipulate when you use it.
13:20:01 <lament> looks like there's no choice, i will have to optimize my algorithm :( :( :(
13:20:34 <Cale> Heffalump: I envision an idiom for cases where you have a function with several arguments that are fairly complex, where you vertically align the $'s for each parameter.
13:20:40 <hamishmack> paper_cc: You need to make sure gtksourceview2 development packages are installed before you run gtk2hs ./configure
13:21:21 <b_jonas> Cale: if you put each parameter in a separate line, then wouldn't you use parenthesis anyway?
13:21:40 <ray> only if you're unduly attached to lisp
13:21:40 <Cale> b_jonas: You wouldn't have to if $ had the opposite associativity.
13:21:41 * Heffalump doesn't care about the $ argument any more since it's clearly never going to happen
13:22:17 <b_jonas> Cale: I mean, I'm not a big fan of dollar signs, but maybe they can help if you're on one line and it's difficult to match parens by just looking, but if they're on separate lines then $ can't be cleaner
13:22:20 <Cale> I think we should just change it and break everything, and then fix those cases when things fail to compile. It would probably only take a couple weeks of adjustment.
13:22:30 <b_jonas> I usually just use parenthesis anyway
13:22:34 <ray> infixl $ makes more sense anyway since regular function application is already left-associative
13:22:51 <Cale> b_jonas: I think separate lines are exactly the case where removing parens is better.
13:23:05 <b_jonas> Cale: why?
13:23:12 <Cale> b_jonas: matching becomes more difficult if you have to look a few lines down to find the closing paren
13:23:19 <ray> cale's idiom is just a useful side-effect of making things more consistent
13:23:26 <paper_cc> harmishmack: I know. The problem was that gtksourceview-2.2 (from Hardy repositories) is too old. Leksah does build with the latest gtksourceview-2.6 (with Gtk2Hs rebuilt to use it)
13:23:38 <b_jonas> Cale: but if every line is a separate argument, then the matching paren is not a few lines down but at the end of that line
13:23:42 <b_jonas> so it's basically invisible to you
13:23:55 <Cale> b_jonas: What if some of the arguments are multiple lines in themselves?
13:23:58 <Heffalump> (one reason I don't like left-associative $ is that it breaks refactorings that currently work on the right-hand side of a $)
13:24:01 <Cale> Here, I'll construct an example...
13:24:18 <hamishmack> paper_cc: cool
13:24:22 <b_jonas> Cale: they're indented
13:24:33 <Cale> Heffalump: Using multiple $'s in the first place breaks more refactorings.
13:24:43 <Heffalump> I don't care about that though.
13:24:52 <b_jonas> well I must admit I'm not always consistent in my punctuation style either
13:24:55 <Heffalump> I can change $ into . as a separate pass.
13:25:10 <b_jonas> I try but sometimes I'm not sure what the best is
13:25:25 <Heffalump> But when I have foo $ bar, it's more useful to me to be able to change bar into baz $ blat than it is to be able to change foo.
13:25:27 <Cale> I just always use composition where it's appropriate to use it in the first place.
13:25:40 <hamishmack> thoughtpolice: Have you tried using macports to install gtk and gtk2hs?
13:26:01 <shapr> dons: I think it's likely I will be at Hac phi, yes.
13:26:03 <Heffalump> no doubt if $ had been left-associative from the start I'd be used to it and would think differently, but it's not
13:26:08 <Cale> I would change it to foo . baz $ blat
13:26:22 <mbr> hi! Can anyone help with gtk2hs textView? Can I get a String out of textViewBuffer?
13:26:26 <Heffalump> I don't want to touch anything outside bar.
13:26:33 <Heffalump> the refactoring is bar = baz $ blat
13:30:30 <roconnor> @remember sheep1e The fourth character presumably represents both "runtime" and "Writer monad", a kind of Haskell pun in Japanese.
13:30:30 <lambdabot> Okay.
13:31:00 <Cale> If we define an effective subexpression of a string of Haskell code as a well-typed contiguous substring, then the number of effective subexpressions of f_1 . f_2 . ... . f_n $ x grows quadratically with n, while the number of effective subexpressions of f_1 $ f_2 $ ... $ f_n $ x grows only linearly with n.
13:31:42 <Cale> This is, I think, why I really prefer the former. Not just for the convenience in editing, but in the change in thinking that it also brings about.
13:32:06 * Heffalump has been trying that style since his last argument with Cale on the subject and agrees it's nicer
13:32:21 <EvilTerran> Cale, i'd require more than "well typed", but i see where you're coming from
13:32:36 <Heffalump> EvilTerran: well typed and meaningful
13:33:11 <EvilTerran> "meaningful", eh. ooh, you're on shakey philosophical ground there :P
13:33:13 <byorgey> well typed, and 'able to be anti-substituted for'?
13:33:28 <Cale> yeah
13:33:32 <Heffalump> EvilTerran: :-p
13:33:37 <byorgey> i.e. you can rip it out, define a new variable to be the subexpression and replace the subexpression with the variable
13:33:52 <Cale> That's a good refinement of it :)
13:34:07 <EvilTerran> i guess the intuitive definition would be that you can wrap it in parens without changing the meaning
13:34:08 <Heffalump> I find it mostly useful when I change some types and can just put a map or something around such a sub-expression.
13:34:31 <Cale> The thing is, even if you don't make such substitutions in the code, you can think about the code as being broken down in all those different ways.
13:34:57 <chrisdone> anyone see a way to remove the parens? lift . forkIO $ (evalStateT . irc_Monad) handler undefined
13:35:59 * EvilTerran would probably write lift . forkIO $ evalStateT (irc_Monad handler) undefined
13:36:16 * chrisdone cries
13:36:19 <copumpkin> @src IO
13:36:20 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:36:42 <b_jonas> chrisdone: just remove it
13:36:47 <roconnor> let x = irc_Monad handler in lift . forkIO $ evalStateT x undefined
13:36:52 <b_jonas> chrisdone: (.) has a higher precedence than ($)
13:37:17 <hamishmack> mbr: textBufferGetBounds and textBufferGetText
13:37:26 <roconnor> b_jonas: but not higher than whitespace.
13:37:39 <chrisdone> b_jonas: but then function application creeps in
13:38:15 <b_jonas> chrisdone: oh, sorryu
13:38:19 <roconnor> irc_Monad handler in lift . forkIO $ flip evalStateT undefined $ irc_Monad handler
13:38:22 <roconnor> er
13:38:26 <b_jonas> chrisdone: didn't notice it continused on the next screen line
13:38:26 <roconnor> lift . forkIO $ flip evalStateT undefined $ irc_Monad handler
13:38:35 <b_jonas> sorry
13:38:57 <roconnor> actually all the parameters for  eval, exec stuff in the mtl are the wrong way around.
13:39:05 <roconnor> yet another reason to stop using the mtl.
13:39:06 <chrisdone> yeah I agree
13:39:20 <chrisdone> the number of times I've used flip run*
13:39:24 <Heffalump> <aol>
13:39:27 <Heffalump> but just make some wrappers!
13:39:47 <b_jonas> well I now know how to write those monads myself so in theory I can write my monads instead of using mtls
13:39:57 <roconnor> or use monadLib
13:40:04 <b_jonas> but then I won't make less mistakes than mtl did
13:40:19 <roconnor> which fixes like 80% of the problems with the mtl, 99% as measured by seriousness.
13:40:36 <b_jonas> monadLib? let me look at that
13:40:52 <chrisdone> lambdabot: tell me information about monadlib using hackage and clever haskell magic
13:41:00 <roconnor> @hackage monadLib
13:41:00 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monadLib
13:41:11 * chrisdone beams
13:41:33 <shapr> Ok so, what existing Haskell applications would be good to tune for 4 and 8 cores?
13:41:52 <EvilTerran> ... darcs?
13:41:55 <mbr> @hamishmack thanks, I have found them, but how do I use them? its type is (TextBufferClass self) =>  self -> TextIter -> TextIter -> Bool -> IO String and I know nothing about TextIters
13:41:56 <lambdabot> Unknown command, try @list
13:42:01 <Heffalump> the darcs test suite
13:42:20 <copumpkin> shapr: GHC ;)
13:42:42 <mbr> hamishmack: thanks, I have found them, but how do I use them? its type is (TextBufferClass self) =>  self -> TextIter -> TextIter -> Bool -> IO String and I know nothing about TextIters
13:42:48 <shapr> copumpkin: GHC sounds like a longer term goal, I want to start small :-)
13:42:52 <copumpkin> :)
13:43:04 <shapr> Heffalump: That's a good idea, I'll look into that. Any other suggestions?
13:46:15 <timmaxw> hello, i'm getting an error installing the "mtl" package - can anybody help me?
13:46:35 <b_jonas> timmaxw: how are you trying to install it and what error?
13:46:41 <EvilTerran> ... that should come with ghc
13:46:48 <b_jonas> in the extralibs
13:46:53 <timmaxw> i downloaded "mtl" from http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/mtl-1.1.0.2.tar.gz
13:46:56 <timmaxw> built Setup.hs
13:47:03 <timmaxw> but when I run "sudo ./Setup install"
13:47:04 <timmaxw> i get:
13:47:08 <timmaxw> Installing library in /usr/local/lib/mtl-1.1.0.2/ghc-6.10.3
13:47:08 <timmaxw> Setup: Error: Could not find module: Control.Monad.Cont with any suffix:
13:47:08 <timmaxw> ["hi"]
13:47:25 <b_jonas> timmaxw: did you built it first?
13:47:48 <timmaxw> yes, i did run ./Setup build
13:48:08 <BMeph> Did you configure it before you built it? ;p
13:48:12 <timmaxw> of course
13:48:37 <timmaxw> EvilTerran: how would i figure out if it's already installed and Haskell just isn't finding it?
13:48:40 <litb> does haskell have much to do with type theory?
13:48:57 <BMeph> timmaxw: Dir you try "sudo make me a sandwich" when you got hungry? ;)
13:49:04 <BMeph> *Did
13:49:11 <timmaxw> no, i got up and ate lunch :D
13:49:27 <Heffalump> shapr: someone is already working on something to do with that, btw, but someone else complained it actually went slower, which was why I mentioned it - check the darcs-users list
13:49:28 <EvilTerran> litb, well, it's got a hindly-milner based type system, so in that way type theory is relevant
13:49:30 <BMeph> timmaxw: A-HA! There's the bug! ;p
13:49:39 <litb> EvilTerran: oh
13:49:59 <EvilTerran> litb, and writing typecheckers/inferrers is rather nicer, IMO, in haskell than in imperative languages
13:50:02 <litb> will understanding type theory help doing CS?
13:50:30 <EvilTerran> (having tried and failed at both, i got a lot further in haskell than in C :P)
13:50:48 <litb> oh ok
13:51:55 <EvilTerran> well, i find knowing a bit of type theory makes me think more rigorously whenever i'm tinkering with a programming language and/or algebra
13:52:38 <EvilTerran> even if that language lacks a static type system, i often find it helps to think about what type something would be "if only this had a type system"
13:53:56 <mreh> what's the scalar equiv of velocity?
13:54:00 <b_jonas> mreh: speed
13:54:02 <zakwilson> The documentation for WxHaskell suggests that Wx apps on Mac OS link readline. Does that mean that all WxHaskell apps on Mac OS must be GPL?
13:54:10 <mreh> is there another word
13:54:17 <mreh> non momentum
13:54:18 <mreh> not*
13:54:22 <EvilTerran> mreh, er, speed?
13:54:44 <mreh> is rotational speed logical?
13:55:10 <mreh> in radians per second
13:56:17 <dec142> angular velocity
13:57:23 <mreh> bingo
13:57:25 <dec142> http://en.wikipedia.org/wiki/Angular_velocity
13:57:26 <dec142> np
13:57:39 <ray> that's not a scalar
13:57:40 <roconnor> mmm, Lie algebras
13:58:07 <dec142> http://en.wikipedia.org/wiki/Angular_speed
13:58:21 <mreh> ray: nuh uh
13:58:23 <roconnor> ray, in 2D it is.
13:58:38 <ray> we're not in 2D, are we?
13:58:47 <mreh> i am
13:58:50 <dec142> ooo
13:58:52 <ray> you're lucky
13:59:02 <ray> for one, you can't have a digestive system
13:59:07 <mreh> everyone can see though my clothes
13:59:12 <ray> those things are so ridiculous
13:59:22 <mreh> and my penis is infinetly thin
13:59:25 <roconnor> ray, maybe you are right.  It is proabably a pseduoscalar.
13:59:51 <roconnor> ya it is.
14:00:02 <roconnor> mreh: be sure to use a different type for pseduoscalars. :)
14:00:12 <mreh> ray: I remember someone arguing life could exist in two dimentions
14:00:16 <mreh> dimension
14:00:21 <ray> was it stephen wolfram?
14:00:58 <mreh> roconnor: infinitely thing asteroids in space dont need to bother with that malarkey
14:01:05 <mreh> ray: no, someone on a forum
14:01:22 <mreh> does wolfram think otherwise too
14:01:34 <ray> well, wolfram's obsessed with cellular automata, many of which are 2D
14:01:35 <roconnor> mreh: fine. Don't come crying to #haskell when a parity inversion comes along and breaks all your code.
14:01:52 <ray> and i mean both 1D+time and 2D+time
14:01:54 <lament> the first question is whether reasonable chemistry could exist in 2D
14:03:16 <mreh> cellular automata...
14:03:24 <b_jonas> lament: I think chemistry would be no problem, physics would be though
14:03:28 <tetha> now you made me think about cellular automatas in spacetime 6
14:03:28 <b_jonas> in the macro size
14:03:49 <lament> b_jonas: why? same laws
14:03:54 <jberryman> what library should I use to generate a random stream from elements chosen from a list?
14:03:59 <lament> b_jonas: er, same laws for gravity
14:04:15 <lament> b_jonas: electromagnetism is tricky
14:04:20 <mreh> eletric force
14:04:21 <mreh> yeah
14:04:27 <mreh> that's all 3 dimensional
14:04:38 <mreh> maxwell would be rotating in his grave
14:04:47 <lament> but he can't, because it's 2D!
14:04:50 <mreh> at a stead frequency of 40Hz
14:04:54 <mreh> steady
14:04:57 <b_jonas> yup, he couldn't be rotating
14:05:01 <b_jonas> that's the main problem
14:05:06 <b_jonas> people couldn't eat
14:05:15 <b_jonas> you couldn't embed most graphs to 3d
14:05:17 <lament> amoebas eat
14:05:24 <ray> amoebas are 3D
14:05:28 <b_jonas> whereas you can embed any graph to 3d
14:05:31 <b_jonas> you can't have crossings
14:05:34 <mreh> but they would fall apart at the boundary of their digestive system
14:05:36 <b_jonas> that limits circuits a lot
14:05:40 <lament> i don't see the problem with eating
14:05:45 <b_jonas> of course, there might be a way to have crossings in 2d
14:05:52 <lament> you surround an object and then digest it, there's no crossing
14:05:55 <b_jonas> some cellular automata get away with it
14:06:02 <timmaxw> you could use other forces to hold an amoeba together... make one half positively charged, other half negatively charged
14:06:22 <mreh> this is goooood haskell
14:06:28 <b_jonas> there's this proof of sokoban being computationally complete in some sense
14:06:33 <b_jonas> it involves soko circuits
14:06:42 <b_jonas> it requires a bridge (crossing)
14:06:47 <b_jonas> it is possible but quite complicated
14:06:51 <ray> just be careful not to push anything into a corner while you're computing
14:06:53 <b_jonas> I can't imagine it working in reality
14:07:02 <b_jonas> but then earth's life is a wonder too so who knows
14:07:40 <tetha> all those turing complete puzzles turn into a horrible nightmare if they are supposed to compute 1+1. way worse than any movie I ever saw
14:08:14 <aconbere> ahhh the age old IO Monad problem
14:08:15 * aconbere sighs
14:08:24 <b_jonas> tetha: maybe you get good advice about which movies to watch
14:08:25 <aconbere> so I've got some Random number generation I want to do
14:08:31 <aconbere> as far as I can tell
14:08:36 <aconbere> the right way to do this is RandomIO
14:08:39 <ray> haskell complete
14:08:58 <aconbere> this screws with a bunch of otherwise non-IO functions
14:10:04 <roconnor> use MonadRandom
14:10:42 <roconnor> b_jonas: I read an article detailing an imagined species living in a 2-D world.
14:10:51 <roconnor> It was probably over 10 years ago, and I can't find it now.
14:10:54 <roconnor> it was really cool.
14:10:56 <tetha> b_jonas: I am not too sure about that :)
14:11:00 <b_jonas> roconnor: there is even some fiction about it
14:11:05 <b_jonas> I mean serious science fiction
14:11:36 <aconbere> flatland?
14:11:40 <aconbere> what?
14:11:41 <aconbere> :)
14:11:52 <ray> flatland doesn't do biology
14:11:56 <aconbere> ahh
14:11:58 <b_jonas> aconbere: something like that and more
14:12:04 <b_jonas> there are multiple of them
14:12:13 <b_jonas> I haven't read any so I can't really know which one is good
14:12:29 <lament> flatland has some seriously different physics (no gravity)
14:12:41 <lament> flatland is like view "from above"
14:12:55 <lament> a more reasonable 2d environment would have gravity so it would be like a view "from the side"
14:13:20 <b_jonas> yep, there's one like that too
14:13:36 <b_jonas> why's the one with gravity more reasonable though?
14:13:41 <roconnor> apparently orbits in 2d are stable, just not elipical.
14:13:45 <jberryman> are there any packages that provide useful functions for random data, beyond the bare essentials? for example, do any libraries provide a function to pick a random element from a list?
14:14:03 <dons> Lemmih: read the 'types are calling conventions' paper?
14:14:07 <jberryman> I know quickcheck has some nice functions like that internally
14:14:09 <dons> would be cool to do a comparison with LHC
14:14:32 <lament> b_jonas: hard to imagine enough organization for life to come about in a world with no gravity
14:14:38 <lament> b_jonas: what's holding all these things together?
14:14:48 <b_jonas> lament: some atomic forces stuff?
14:15:00 <b_jonas> lament: like, matter is dense enough in the whole world
14:15:04 <roconnor> jberryman: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.3/doc/html/Control-Monad-Random.html#v%3AfromList
14:15:08 <b_jonas> so no need to hold things together in large scale
14:15:09 <lament> i suppose they have friction of the ether
14:15:21 <lament> to allow movement
14:15:31 <b_jonas> of the ether? no, there's air or something
14:15:41 <b_jonas> why couldn't they just swim in it?
14:15:44 <lament> why is the air not flying away?
14:15:50 <lament> the entire universe contains air?
14:15:55 <b_jonas> lament: yup
14:16:05 <tetha> the problem about gravity or no gravity is that you can raise implications at most
14:16:38 <b_jonas> lament: either the universe is of finite volume or just equally full of air everywhere and the boundary conditions in infinite is such that air doesn't escape to infinity
14:16:41 <tetha> if there is some force that forces everything apart, then there must be something to hold everything together, or all thinking things (if they exist) must be atomic
14:17:14 <b_jonas> tetha: but isn't it enough to have that on small scale, like in atomic sizes?
14:17:18 <RayNbow> @hoogle regexp
14:17:18 <lambdabot> package regexpr
14:17:26 <b_jonas> tetha: like the electromagnetics that hold us together
14:18:00 <tetha> b_jonas: I am not entirely sure, but I think, the electromagnetism could work as some sort of gravity
14:18:15 <b_jonas> maybe
14:18:16 <b_jonas> dunno
14:18:19 <lament> well
14:18:28 <lament> the question is how do they manage without planets or stars
14:18:32 <tetha> b_jonas: because basically, the em-force will work in a certain radius around an atom, and thus, it will pull different atoms (even of different moleculs together)
14:18:35 <lament> they're just floating in "space"
14:18:46 <b_jonas> lament: why would they need stars or planets?
14:18:57 <lament> i suppose planets are not essential. Where do they get energy from?
14:18:58 <b_jonas> they're floating in, say, water with planktons and minerals, not just space
14:19:32 <b_jonas> but they might even have stars even if not planets
14:19:45 <lament> stars are certainly held together by gravity
14:19:49 <b_jonas> yeah, here
14:20:08 <b_jonas> but why couldn't they be neutron stars held together by nuclear or electromagnetic forces?
14:20:16 <b_jonas> though there's the question how those are created, yeah
14:20:18 <b_jonas> that doesn't work
14:20:27 <b_jonas> sorry
14:20:41 <b_jonas> dunno then
14:20:53 <wli> AIUI there are no credible theories unifying gravity with any other major forces.
14:20:54 <lament> maybe they have atomic stars, or just energy spontaneously appearing in the ether.
14:20:57 <b_jonas> yeah, good point about the stars
14:21:05 <b_jonas> lament: that doesn't work
14:21:11 <lament> you don't need stars when you have hydrothermal vents.
14:21:27 <b_jonas> lament: gravity is what makes that energy concentrate in one point so you can have cooler and warmer places
14:21:37 <b_jonas> you can't have thermodynamics as we know it without that
14:21:52 <lament> no...
14:21:53 <tetha> I like the idea of very large, lazy entities just sitting around, waiting for energy to appear in them
14:22:02 <lament> thermodynamics doesn't deal with gravity much
14:22:12 <b_jonas> lament: but gravity made us the stars
14:22:27 <b_jonas> lament: that's what caused there to be stars and cool empty space with planets here
14:22:35 <lament> right, so they must have a mechanism other than stars that produces energy
14:22:36 <b_jonas> we couldn't live without those
14:22:46 <b_jonas> lament: right, but what concentrates that to one place?
14:22:50 <lament> since the air in which they swim is homogenous across the universe, perhaps so is the energy
14:23:06 <lament> and uhh
14:23:06 <b_jonas> lament: just having the energy or heat everywhere is not enough I think
14:23:26 <b_jonas> so what if they have gravity and stars but no planets?
14:23:38 <lament> they fall onto a star and burn?
14:23:53 <lament> if they have gravity, they will certainly have planets
14:23:55 <b_jonas> maybe there's some wind away from the star which the star itself generates so they don't fall in it? and they're orbitting it anyway so there's a turbulence?
14:23:58 <lament> all this "air" will accumulate around stars
14:24:02 <Apocalisp> What evidence is there that gravity produced the stars?
14:24:06 <Apocalisp> It's conjecture.
14:24:14 <b_jonas> lament: right, but not planets they live on
14:24:29 <lament> Apocalisp: it's not really disputed by anybody.
14:24:36 <Apocalisp> It's a popular conjecture.
14:24:40 <lament> Apocalisp: there's a lot of evidence of stars in various stages of formation.
14:24:43 <b_jonas> Apocalisp: well that's what holds them together at least
14:24:44 <Absolute0> How do I create an instance of Eq using my own type definition, copying the code from the Prelude doesn't seem to do the trick: http://rafb.net/p/I88pwp22.html
14:24:46 <tetha> just wondering, how do you define gravity, if the universe is an infinite twodimensional tape of random bits with nonterminating turing heads moving around on it?
14:24:53 <b_jonas> Apocalisp: it doesn't really matter if that's what formed them in first place
14:24:56 <lament> Apocalisp: and we have pretty good theories that explain all that evidence.
14:25:07 <b_jonas> Apocalisp: they'd fall apart without gravity
14:25:10 <lament> Apocalisp: this is not something that's disputed at all.
14:25:38 <lament> you'd be disputing gravity to dispute that.
14:25:57 <Absolute0> tetha: by using vectors of speed or pull with the given gravity velocity.
14:26:01 <Apocalisp> Well, it's a bit vacuous since we don't know what gravity is.
14:26:25 <b_jonas> Apocalisp: is Move an Enum?
14:26:34 <b_jonas> sorry that's for Absolute0
14:26:38 <Absolute0> Apocalisp: its defined in the paste
14:26:38 <Apocalisp> heh
14:26:50 <b_jonas> Absolute0: but you're using Enum methods
14:26:55 <Absolute0> b_jonas: is that an enum?
14:27:07 <b_jonas> Absolute0: fromEnum is an Enum method
14:27:10 <lament> Apocalisp: i'm not sure "we don't know what it is" is at all meaningful. We know quite well how gravity behaves.
14:27:12 <Absolute0> how do i equate Left | Right | Up ...
14:27:12 <Absolute0> ?
14:27:23 <b_jonas> Absolute0: derive the Eq instance?
14:27:28 <Jedai> Absolute0: You don't need to write them yourselves
14:27:33 <Absolute0> oh
14:27:34 <Absolute0> :)
14:27:50 <Absolute0> Jedai: ghc told me that I should :)
14:27:57 <Jedai> Absolute0: just add " deriving (Eq)" at the end of your type declaration
14:28:05 <Jedai> Ok, good :)
14:28:06 <Apocalisp> lament: We know that it does and how, but not why. "Gravity holds the stars together" isn't much more meaningful than saying "the stars are held together"
14:28:30 <Jedai> If you had to write it by hand for any reason, you would use pattern matching
14:28:32 <lament> Apocalisp: then why did you ask <Apocalisp> What evidence is there that gravity produced the stars?
14:28:43 <Jedai> Left == Left = True
14:28:57 <Jedai> Right == Right = True yadayada
14:29:07 <b_jonas> Absolute0: what Jedai says
14:29:08 <Jedai> then _ == _ = False
14:29:14 <Absolute0> yeah that helped
14:29:22 <lament> Apocalisp: there's certainly plenty of evidence that gravity produced the stars, regardless of "why" it produced them.
14:29:28 <Apocalisp> lament: Because it's just an assumption. It's assumed that stars are produced by gravitational collapse because nothing else could.
14:29:41 <b_jonas> Apocalisp: well, as I've said, that's not relevant for my argument
14:29:42 <Absolute0> um if i define a function x + y is y+x implied?
14:29:54 <b_jonas> Absolute0: you can but the syntax is tricky
14:30:02 <lament> Apocalisp: you're wrong.
14:30:04 <b_jonas> Absolute0: I think you have to write the definition as (+) x y =
14:30:06 <Absolute0> i mean the order matters
14:30:10 <lament> Apocalisp: i'm not sure how this argument can continue :)
14:30:14 <b_jonas> the order does matter
14:30:22 <Apocalisp> lament: Yes, I know. Orthodoxy cannot be argued with.
14:30:22 <Jedai> b_jonas: Nope7
14:30:22 <Nereid> b_jonas: x + y = ... should work too
14:30:25 <Absolute0> so if given y + x I want to actually call x + y
14:30:39 <Nereid> Absolute0: I don't think that would work. what would x + y be?
14:30:44 <Nereid> x + y would call y + x, etc
14:30:49 <b_jonas> really? let me try
14:30:56 <lament> Apocalisp: you have nothing other than the standard philosophical "we can't know anything for certain".
14:30:58 <Jedai> b_jonas: If you define an infix operator, you can use the infix syntax on the left side of the = too
14:31:10 <b_jonas> I thoguht it would conflict with n+k patterns notation
14:31:12 <lament> Apocalisp: to the extent we can be certain about anything, we're certain gravity produced the stars.
14:31:14 <Absolute0> http://pastebin.com/f742890b6
14:31:23 <Jedai> Absolute0: What you ask for doesn't really make sense
14:31:30 <Absolute0> as you can see +  accepts position move
14:31:36 <Apocalisp> lament: I'm not offering that at all. I maintain that certainty is possible.
14:31:39 <Absolute0> what if I did + move position ?
14:31:53 <lament> Apocalisp: then we know that for certain.
14:32:00 <b_jonas> hmm, you're right, you don't need it indeed
14:32:08 <b_jonas> sorry then
14:32:29 <Jedai> Absolute0: First you shouldn't use (+), it's a Num operator
14:32:41 <Absolute0> yeah i am getting conflicts everywhere :)
14:32:45 <opqdonut> Absolute0: just add "| otherwise = (+) move position"
14:32:50 <b_jonas> Absolute0: use a different name maybe?
14:33:00 <Jedai> Absolute0: Use something like (^+) or whatever
14:33:02 <opqdonut> Absolute0: that is, if none of the cases match, try it with different argument order
14:33:03 <Nereid> Absolute0: I wouldn't use (+), but you'd basically end up with both (+) :: Position -> Move -> Position and (+) :: Move -> Position -> Position
14:33:24 <opqdonut> Absolute0: of course, the types of the two arguments should match...
14:33:32 <Nereid> but simply doing something like
14:33:37 <Nereid> move + position = position + move
14:33:42 <Nereid> would be ambiguous
14:33:44 <Nereid> and probably fail
14:33:46 <Jedai> Absolute0: And as Nereid just pointed, a same function/operator (they're the same really) can't have two types at once
14:33:53 <Absolute0> I at first named the function executeMove but + seemed a lot nicer.
14:33:55 <opqdonut> you could do this all by doing a new typeclass that defines + for the relevant types
14:33:59 <b_jonas> so what's the advantage of this MonadLib over mtl?
14:34:37 <Jedai> Absolute0: Using typeclass could work but would be pretty ugly and frankly do you really care enough about allowing both orders ?
14:34:48 <Nereid> Absolute0: do you really need to allow positions and moves to be combined in either order?
14:35:06 <Nereid> yeah
14:36:23 <Absolute0> Nereid: following the fact that addition is commutative i thought it would be logical to do so.
14:36:32 <Jedai> Besides, you moves from a position (Position + Move -> Move) you don't position from a move
14:36:35 <Nereid> but what you're doing isn't really addition
14:36:55 <Jedai> Absolute0: Addition is, but this isn't addition... You don't even have the same types on both sides
14:37:07 <Absolute0> :)
14:37:20 <Absolute0> they are somewhat the same
14:37:27 <Absolute0> like 1.5 + 2
14:37:40 <Absolute0> the Int part plus the Move
14:37:49 <Absolute0> oh well
14:37:50 <Nereid> I think what you're doing is closer to what (:) does with lists
14:37:54 <tetha> you are adding two rational numbers there
14:37:55 <Nereid> for example
14:38:37 <fracture> I want a function like map that returns the whole list N times with single elements changed...  (guessing this might be quick for someone here)
14:39:07 <Nereid> what do you mean, single elements changed?
14:39:12 <fracture> so like ... mapish (2*) [1,2,3] would give [[2,2,3], [1,4,3], [1,2,6]]
14:39:18 <Twey> That doesn't make sense, fracture
14:39:19 <Nereid> ah
14:39:22 <Twey> Think of the types
14:39:30 <fracture> (sorry, was typing example)
14:39:36 <Jedai> Twey: Why ?
14:39:38 <Nereid> Twey: well the function would have to be a -> a
14:39:44 <Nereid> but otherwise it's fine
14:40:02 <fracture> I can think of a way to do this using length and split and shit, but it seems way too imperative style
14:40:17 <gwern> so I've been looking at GADTs, and it doesn't seem to be goign well: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5172#a5173 I'm sure I'm misunderstanding something, but what?
14:40:25 <Twey> Hmm
14:40:55 <BMeph> fracture: I think "the Haskell way" would use inits and tails for that. :)
14:41:11 <Apocalisp> lament: I've yet to see a simple and concise explanation of how we've come to know that stars are formed by gravitational collapse. As in "here's how this was discovered and this is why it can't be wrong". Know of anything like that?
14:41:11 <b_jonas> let me try to write that
14:41:12 <Twey> Well, but then you've got to add them onto the original list
14:41:15 <Twey> I would go with splitAt
14:41:35 <hatds> I think there is a way to use the list monad perhaps/
14:41:36 <hatds> ?
14:41:49 <lament> Apocalisp: observational evidence. It's no different from seeing objects fall.
14:41:58 <b_jonas> > let { m f [] = []; m f (p : r) = (f p : r) : map (p :) (m f r); } in m (10*) [1, 2, 3]
14:41:59 <lambdabot>   [[10,2,3],[1,20,3],[1,2,30]]
14:42:03 <b_jonas> -> fracture
14:42:08 <fracture> also... it would be even cooler if it worked with infinite guys (thinking maybe a splitAt way can't do that, since I'd need length)
14:42:08 <Jedai> > let halves xs = zip (inits xs) (tails xs) in halves [1..4]
14:42:09 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
14:42:10 <Heffalump> Apocalisp: science doesn't do "it can't be wrong"
14:42:13 <fracture> ah
14:42:25 <lament> Apocalisp: we have a pretty good theory explaining why objects fall, and the same theory happens to correctly describe star formation, and we can look at the sky and check that it's correct.
14:42:26 <Jedai> > let halves xs = init . zip (inits xs) (tails xs) in halves [1..4]
14:42:28 <lambdabot>   Couldn't match expected type `a -> [a1]'
14:42:30 <Absolute0> Is haskell a good language to implement a chess engine with? Or should I stick with Java?
14:42:34 <Heffalump> gwern: how could that type signature for eval be right?
14:42:34 <Jedai> > let halves xs = init $ zip (inits xs) (tails xs) in halves [1..4]
14:42:35 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4])]
14:42:41 <hatds> haskell is good for everything :)
14:42:42 <Twey> Jedai: Nice
14:42:45 <lament> Apocalisp: s/why/how
14:42:49 <Apocalisp> lament: The events in question are long ago and far away. We don't actually see them form.
14:42:49 <gwern> Heffalump: I know it isn't right, but I don't know what right would look like
14:42:55 <b_jonas> @faq Is haskell a good language to implement a chess engine with? Or should I stick with Java?
14:42:56 <lambdabot> The answer is: Yes! Haskell can do that.
14:43:10 <Absolute0> :)
14:43:11 <Nereid> gwern: you have N :: Term' (Int) but you say eval (N x) = x
14:43:17 <lament> Apocalisp: well, there's the assumption that the laws of physics don't change much over time.
14:43:21 <Heffalump> I don't think your types do what you intend
14:43:26 <b_jonas> > let { m f [] = []; m f (p : r) = (f p : r) : map (p :) (m f r); } in map (take 6) (m (10*) [1..])
14:43:27 <lambdabot>   [[10,2,3,4,5,6],[1,20,3,4,5,6],[1,2,30,4,5,6],[1,2,3,40,5,6],[1,2,3,4,50,6]...
14:43:29 <Nereid> eval should return a Bool but if you have N x then x is an Int
14:43:29 <Heffalump> you have three nullary constructors, E N and Q
14:43:33 <b_jonas> works for infinites too
14:43:38 <lament> Apocalisp: but star formation happens not *that* far away
14:43:38 <opqdonut> gwern: you need an explicit type sig for eval
14:43:40 <Heffalump> so your syntax is wrong too
14:43:46 <opqdonut> gwern: something like eval :: Term' x -> x i guess
14:43:55 <fracture> thanks b_jonas, digesting it now
14:44:08 <opqdonut> gwern: and what Heffalump said
14:44:09 <Jedai> > let halves xs = init $ zip (inits xs) (tails xs); mapish = map (\(pre, p:post) -> pre ++ f p : post) . halves in mapish (*2) [1..4]
14:44:10 <lambdabot>       The section `(* 2)' takes one argument,
14:44:10 <lambdabot>      but its type `[a]' has none
14:44:20 <lament> Apocalisp: the milky way is only 100,000 light years in diameter.
14:44:22 <Cale> Absolute0: I doubt that Haskell would have any disadvantages over Java for a chess engine. Some chess engines are designed at a really low level to get the most out of every instruction, and that's something which I think Haskell and Java would struggle equally with, except that Haskell is particularly good at metaprogramming for low-level things.
14:44:25 <Jedai> > let halves xs = init $ zip (inits xs) (tails xs); mapish f = map (\(pre, p:post) -> pre ++ f p : post) . halves in mapish (*2) [1..4]
14:44:26 <lambdabot>   [[2,2,3,4],[1,4,3,4],[1,2,6,4],[1,2,3,8]]
14:45:14 <Jedai> bjonas solution is better though
14:45:16 <Cale> ... where'd he go?
14:45:19 <Cale> Oh well.
14:45:22 <gwern> but the problem is how do I have N take an argument?  'N :: forall a. Term' (a)' doesn't seem to work and doesn't specify ints either
14:45:33 <Heffalump> N :: a -> Term' a
14:45:43 <b_jonas> Cale: dunno
14:45:45 <Heffalump> you give the signature you want the constructor to have
14:46:05 <Heffalump> so if it should take k arguments then give a function signature with k arguments and a result of type Term' something
14:46:40 <b_jonas> let me try to ask this again
14:46:43 <b_jonas> so what's the advantage of this MonadLib over mtl?
14:46:52 <fracture> cool, I think I understand it now jonas; nice and elegant :)
14:47:16 <b_jonas> MonadLib::lift :: Monad m => m a -> t m a
14:47:17 <b_jonas> funny
14:47:21 <Jedai> b_jonas: You should use transformers and monad-tf anyway !!
14:47:30 <Heffalump> Jedai: that's basically mtl though
14:47:35 <Heffalump> monadLib is a significant change
14:47:40 <lament> Apocalisp: for an example, http://en.wikipedia.org/wiki/Orion_Nebula
14:48:02 <b_jonas> lament: sorry, I took part in starting the flame
14:48:04 <Twey> Jedai: mapish f = map (second $ map f) . halves
14:48:07 <b_jonas> lament: I shouldn't have answered
14:48:09 <Jedai> Heffalump: I must admit that the differences between the approach and why some are better than others are a nebulous for me
14:49:00 <Heffalump> for me the biggest downside of monadLib is that the author isn't interested in aligning with mtl where possible, just in terms of having the same types
14:49:03 <roconnor> Jedai: monad-tf has most of the same problems that the mtl has.
14:49:18 <Jedai> Heffalump: I once read something that I half understood but I forgot everything since :)
14:49:30 <roconnor> for me the biggest upside of monadLib is that the author isn't interested in aligning with mtl where possible
14:49:56 <Twey> Hahaha
14:49:59 <ray> if only less haskell people cared about compatibility
14:50:02 <b_jonas> okay, at least it has a proper EitherT (not called that but still), not this riddiculous ErrorT
14:50:03 <Twey> MonadLib is good?
14:50:07 <ray> we'd have left-associative $ by now
14:50:12 <ray> and better typeclasses
14:50:17 <ray> and if'
14:50:20 <b_jonas> eek
14:50:24 <Twey> ray: We generally do it in extensions
14:50:26 <idnar> how does if' break compatibility?
14:50:27 <Twey> Nobody wants if'
14:50:32 <b_jonas> I do
14:50:32 <Twey> (??) all the way
14:50:34 <b_jonas> but call it bool
14:50:40 * roconnor kinda wants if'
14:50:41 <idnar> anyhow, if haskell people cared about compatibility, we wouldn't have had the whole exceptions-revamp debacle
14:50:43 <Heffalump> ray: and fewer users
14:50:44 <idnar> :P
14:50:51 <hydo> Hrm... I think I just invented Monads... or something like them... or something completely different that is a bastardization of the term 'monad'.  http://gist.github.com/116787
14:51:02 <b_jonas> I also want standard names for the Void type, and standard names for (flip const) and for (flip id)
14:51:05 <Cale> I think if' or something like it ought to be in the Prelude or at least Data.Bool
14:51:05 <roconnor> @google "you could have invented monads"
14:51:06 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:51:06 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:51:19 <b_jonas> and one more, which one was it...
14:51:30 <MyCatVerbs> hydo: hrmn? How so?
14:51:35 <b_jonas> bool, flipconst, flipid, what was the fourth?
14:51:36 <ray> the Void type being the type that contains only _|_?
14:51:41 <b_jonas> ray: yes
14:51:43 <Cale> hydo: Where's the monad?
14:51:51 <ray> yeah, we could use that
14:52:06 <b_jonas> defined as data Void where {}; or as newtype Void = Void Void;
14:52:09 <idnar> @type flip const
14:52:10 <lambdabot> forall a b. b -> a -> a
14:52:26 <b_jonas> but then sometimes it's better to use an unbound type variable instead of void
14:52:30 <Berengal> if' and fi ftw
14:52:30 <idnar> @type const id
14:52:30 <b_jonas> like in forever and stuff
14:52:31 <lambdabot> forall a b. b -> a -> a
14:52:39 <roconnor> b_jonas: oh nice definition of Void.
14:52:39 <hydo> MyCatVerbs: well, using the getE method in that gist to pull out successive layers of data.  It suddenly seemed monadish.  That's probably because I still have only a rudimentary knowledge of them.
14:52:41 <b_jonas> in some way that's better because it can be used in more places
14:52:45 <b_jonas> roconnor: not my invention
14:52:51 <roconnor> void_rec x = void_rec x
14:52:52 <b_jonas> roconnor: and I prefer the former
14:52:53 <idnar> > \x -> (flip const) x == (const id) x
14:52:54 <lambdabot>       Overlapping instances for Show (b -> Bool)
14:52:54 <lambdabot>        arising from a use of...
14:52:56 <idnar> er
14:52:57 <roconnor> er
14:53:00 <idnar> @quickcheck \x -> (flip const) x == (const id) x
14:53:00 <lambdabot> Unknown command, try @list
14:53:03 <idnar> @check \x -> (flip const) x == (const id) x
14:53:04 <roconnor> void_rec (Void x) = void_rec x
14:53:04 <lambdabot>       No instance for (Eq (a -> a))
14:53:04 <lambdabot>        arising from a use of `==' at <int...
14:53:18 <idnar> @check \x y -> (flip const) x y == (const id) x y
14:53:19 <lambdabot>   "OK, passed 500 tests."
14:53:28 <idnar> actually, I guess that probably didn't check anything useful
14:53:54 <Jedai> @check \x y -> (flip const) x y == (const id) (x :: Int) (y :: Int)
14:53:56 <lambdabot>   "OK, passed 500 tests."
14:54:04 <Jedai> There
14:54:05 <roconnor> @check \x y -> x == y
14:54:06 <lambdabot>   "OK, passed 500 tests."
14:54:20 <MyCatVerbs> hydo: it looks like you've reinvented Maybe. data Value = Nothing | Object (M.Map String somethingorother) -- ?
14:54:37 <ray> @check (x :: Int) == (y :: Int)
14:54:39 <lambdabot>   Couldn't match expected type `Int' against inferred type `Expr'
14:54:44 <roconnor> \x y
14:54:50 <MyCatVerbs> hydo: or, more to the point, you're doing something by hand that you could probably translate into the Maybe monad fairly straightforwardly.
14:54:54 <hydo> I just need to find a smart student in the seattle area that knows haskell really well and pay him for tutoring.  Or maybe I was spoiled when I was learning Perl by having schwern just down the street and knowing Randal Schwartz and thus having them critique my code ad nauseam.
14:54:57 <ray> \x y indeed
14:55:00 <Jedai> idnar: That is trivially true but it's good to see that quickcheck agree with me
14:55:38 <fracture> is there a Data.List (or elsewhere) function like C++ std::unique (or unix uniq... removes adjacent duplicates)?
14:55:51 <hydo> talk about ramming a language into your brain all "Matrix" style...
14:55:56 <Jedai> fracture: map head . group
14:56:12 <ray> haskell is easy
14:56:32 <Berengal> ray: Which part of it?
14:56:41 <Jedai> Berengal: The small
14:56:44 <hydo> parts of haskell are easy.
14:56:47 <bogner> what does "constraint is no smaller than the instance head" mean?
14:56:47 <fracture> ah cool, thanks jedai
14:57:06 <ray> haskell is easy, let's stop shopping
14:57:09 <thirsteh> it should be renamed cakewalk, really
14:57:17 <hatds> bogner: it means it isn't obvious that typechecking will terminate
14:57:21 <mauke_> bogner: it means it can't prove that your type relation terminates
14:57:23 <MyCatVerbs> hydo: yeah, that does sound a bit spoiling, heh. :)
14:57:29 <Jedai> bogner: That means you have an instance that doesn't respect some of the constraint Haskell98 impose so that typechecking terminate
14:57:36 <tetha> well, cakewalk with a gigantic trench in the middle of it, called monads. but yes, cakewalk
14:57:40 <MyCatVerbs> hydo: just hang around on IRC with Cale long enough, you'll pick it all up by osmosis. ;)
14:57:44 <lament> monads are easy
14:57:47 <ray> monads are one of the easier parts of haskell
14:57:54 <Berengal> Monads are like cars. Cars are easy.
14:57:57 <lament> actually writing stuff is hard
14:58:12 <b_jonas> no, cars are not easy
14:58:15 <Jedai> bogner: If you can prove it by yourself, you're ok (you'll have to enable some extensions though)
14:58:34 <Cale> You could pay me to tutor you if you want, though I'm likely to help out randomly anyway.
14:58:38 <thirsteh> monads the strawberries that weren't quite ready
14:58:42 <inimino> cars never say no?
14:59:05 <Berengal> inimino: Have you ever heard a car say no?
14:59:07 <b_jonas> inimino: not true for these mondern cars
14:59:12 <b_jonas> Berengal: I have
14:59:16 <thirsteh> tetha, an excillerating, almost euphoric -- yet lethal cakewalk, although I guess, at the end of the day, you're still going to land in cake if you fall
14:59:29 <MyCatVerbs> Where did cake come into this, anyway?
14:59:36 <ray> haskell is like a cake
14:59:39 <bogner> Jedai: well, i don't think i should need to, I must be doing it wrong. I want to declare an instance like `instance Integral a => Foo a where`...
14:59:40 <Berengal> b_jonas: Psh, you must be driving one of the newfangled electromatic wagons
14:59:43 <thirsteh> It's certainly not a lie
14:59:45 <inimino> Berengal: no I never have
14:59:46 <riddochc> Cars are a little easier than they should be, imo.  Too many people don't respect the fact that they're flinging themselves at high velocities taking a lot of mass with them.  ;)
14:59:47 <b_jonas> MyCatVerbs: well everyone likes a cake
14:59:56 <bogner> Jedai: ie, if it's an integral, it's also my class
15:00:01 <inimino> riddochc: it's driving that's hard
15:00:06 <mauke_> bogner: that doesn't necessarily terminate because someone else could define instance Foo a => Integral a
15:00:10 <MyCatVerbs> b_jonas: I can one up that. I have cake, too.
15:00:21 <b_jonas> oh, happy birthday!
15:00:29 <bogner> mauke_: I suppose that's fair, but what if someone... doesn't do that?
15:00:39 <hatds> then everything will be a-ok
15:00:42 <Jedai> bogner: Of course you're probably pretty sure that nobody would do that, so enable some extensions
15:00:46 <inimino> @faq can Haskell have your cake and eat it too?
15:00:46 <lambdabot> The answer is: Yes! Haskell can do that.
15:01:11 <Jedai> You have a list and explanation somewhere in the GHC manual
15:01:25 <Apocalisp> lament: http://www.electric-cosmos.org/indexOLD.htm Old but made me curious.
15:01:38 <thirsteh> Cakes, cars and Haskell -- what more do you need.
15:01:57 <inimino> there's your new Monad tutorial title
15:02:04 <riddochc> I wasn't aware of the 'group' function.  Potentially quite useful.
15:02:05 <bogner> oh, okay, I get it, that's why it's saying it's no smaller than the instance head
15:02:12 <thirsteh> inimino, hah, indeed
15:02:15 <lament> Apocalisp: ok
15:02:38 <ray> you can have your cake and eat it too with functional programming in general
15:03:11 <lament> functional programming ate my babysitter
15:03:13 <ray> but with haskell, you can eat each of an infinite number of cakes an infinite number of times and not get a stomachache
15:03:19 <Jedai> bogner: You could try FlexibleInstances but I think it's not enough
15:03:23 <mauke_> it's a bit like functions at the type level, only the syntax is 'instance BODY => FUNCTION PATTERN' instead of 'FUNCTION PATTERN = BODY'
15:03:48 <bogner> Jedai: it's not, that's already enabled. i think i need UndecidableInstances
15:03:51 <thirsteh> ray, I'd read your tutorial
15:04:02 <hatds> that's a good explanation, mauke
15:04:06 <Jedai> bogner: Yeah, I believe so too
15:04:08 <ray> unfortunately, i think haskell is too easy to need tutorials
15:04:08 <hatds> I like it )
15:04:12 <hatds> :)
15:04:13 <tetha> ray: now define bind in terms of cake :)
15:04:37 <Berengal> cake >>= eat = eat cake
15:04:49 <ray> that's when you take a cake and a function from some frosting to a cake, and put the frosting on the cake
15:05:07 <thirsteh> ray: Obviously, I would merely be reading it for the cake metaphores
15:05:35 <Berengal> Is there anything that isn't a monad analogy?
15:05:53 <ray> monads are like monad tutorials
15:05:56 <Cale> There are a lot of things which are really bad monad analogies.
15:05:56 <tetha> mh. arrows?
15:06:03 <Apocalisp> lament: ... because electricity I get but gravity I don't. The engineer in me does not want to believe in black holes. :)
15:06:13 <mauke_> @quote chocolate
15:06:14 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
15:06:17 <Berengal> Cale: "Really bad" is not "not"
15:06:19 <mauke_> hmm, not that one
15:06:38 <Cale> But I suppose anything is an analogy for anything else. It's just a matter of quality.
15:06:57 <ray> monad transformers are like monad tutorial transformers
15:07:09 <Berengal> Quality is in the eye of the beholder. I, for example, think the unicorn analogy is of good quality
15:07:16 <lament> Apocalisp: hehe
15:07:29 <b_jonas> Berengal: what color of unicorn?
15:07:52 <Berengal> b_jonas: All colours. IO is invisible pink
15:07:53 <Cale> "Monads are like the Japanese word 物"
15:08:06 <riddochc> All words are idioms.
15:08:06 <tetha> Berengal: now I had to think of unicorns poking other unicorns as the binding operator.
15:08:38 <b_jonas> tetha: eek
15:08:41 <mauke_> CJK UNIFIED IDEOGRAPH-7269 [物]. how helpful.
15:08:45 <inimino> haha
15:08:45 <Berengal> tetha: That is the basic part
15:08:49 * inimino vows to say no more about the unicorn thing
15:08:54 <Cale> 物 [もの] /(n) (1) thing/object/
15:08:56 <hatds> monads are like C++'s empty base class optimization
15:09:02 <b_jonas> tetha: why not extend one of the lambda calculus analogies, like crocodiles or singing birds?
15:09:03 <ray> mauke_: wiktionary helps
15:09:16 <b_jonas> hatds: what?
15:09:24 <hatds> b_jonas: exactly.
15:09:49 <Cale> It's often used as a nominaliser, to take some verb and turn it into the thing of that.
15:10:02 <tetha> b_jonas: I am trying hard to get that image of poking unicorns out of my head, stop stopping me
15:10:13 <ray> nouning verbs is even cooler than verbing nouns
15:10:17 <mle> e.g. tabe (eat) mono (thing) -> tabemono (foodstuffs)
15:11:05 <BMeph> This place seems more like "Functional Programming stole my Adderall", today. ;p
15:11:27 <mauke> @quote chocolate.robot
15:11:27 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
15:11:37 <b_jonas> monads are like ooh, chocolate
15:11:48 <Berengal> Mmm, reverse state monad
15:12:31 <b_jonas> monads are like
15:12:35 <b_jonas> monads are like
15:12:54 <b_jonas> I guess
15:12:57 <bremner> monads are like monads
15:12:59 <Cale> "Monads are like expressing what monads are like." <-- not a very good analogy.
15:13:00 <Berengal> > fix ("monads are "++)
15:13:01 <bo0ts__> Hi, I'm jsut learning haskell and got a little confused. What's the difference between putStr show 3 and putStr (show 3)? The later works.
15:13:01 <lambdabot>   "monads are monads are monads are monads are monads are monads are monads a...
15:13:10 <b_jonas> monads are like twice "monads are like twice "
15:13:11 <tetha> monads are like things that are not like monads
15:13:23 <Cale> bo0ts__: The first is the same as (putStr show) 3
15:13:39 <Cale> bo0ts__: and is like giving both parameters to putStr
15:13:58 <mle> logical quine for the lose.
15:14:00 <b_jonas> monads are like that distance giant in Ende's book who seems larger if you view him from farther unlike normal objects that seem smaller when viewed from farther
15:14:16 <bo0ts__> Cale: I see. Just didn't expect it to act that way. Is there any reason for this?
15:14:25 <Cale> bo0ts__: Plenty of good reasons.
15:14:29 <tetha> mm, jim knopf (at least in german). that was a good book
15:14:35 <ray> yeah, and whenever someone figures out monads they think "oh, this is boring, let's install category-extras"
15:14:53 <Cale> bo0ts__: Firstly, all functions in Haskell really take exactly one parameter.
15:15:05 <Cale> bo0ts__: Those which appear to take more just return other functions.
15:15:16 <cads> b_jonas: cool reference
15:15:24 <b_jonas> so putStr show 3 means (putStr show) 3
15:15:24 <bo0ts__> Cale: Is this by convention?
15:15:41 <Cale> bo0ts__: More than just convention, it's supported by the syntax of the language.
15:16:01 <Cale> This is convenient because it makes it easy to get hold of functions which are specialisations of other functions where some of the first parameters are filled in already.
15:16:06 <Cale> For example...
15:16:16 <Cale> > map (map (+1)) [[1,2,3],[4,5]]
15:16:18 <lambdabot>   [[2,3,4],[5,6]]
15:16:51 <Cale> When you write an expression like f x y z it really means ((f x) y) z
15:17:14 <Cale> That is, f is applied to x, then the result is applied to y, and the result of that is finally applied to z
15:17:32 <Cale> But you can also regard it as just passing three parameters to f. It's the same thing.
15:17:40 <Cale> Similarly, when you write a function like:
15:17:59 <Cale> f x y z = x^2 + x*z + y^2*z
15:18:06 <bo0ts__> Cale: I thought it would be more like f(g(x)). Those are evaluated from the inside.
15:18:14 <Cale> bo0ts__: It's the opposite.
15:18:29 <cads> does the haskell standard have a super concise syntax notation for haskell?
15:18:45 <b_jonas> bo0ts__: that's because syntax works like that in some programming langauges (smalltalk, apl, perl, ruby)
15:18:45 <Cale> If you want to apply multiple functions to a parameter, you can use the composition function:
15:18:52 <Cale> (f . g) x
15:18:55 <Cale> Or:
15:18:59 <Cale> f . g $ x
15:19:02 <b_jonas> or just f (g c)
15:19:06 <Cale> Right.
15:19:09 <b_jonas> f (g x) I mean
15:19:12 <cads> I remember there were some haskell railroad diagrams somewhere showing haskell syntax in a graphical way
15:19:13 <b_jonas> and it's f $ g x
15:19:20 <b_jonas> though sure, f . g $ x works too
15:19:24 <bo0ts__> Cale: Thanks, feels better now.
15:19:33 <Cale> @src (.)
15:19:34 <lambdabot> (f . g) x = f (g x)
15:19:34 <bo0ts__> Just haven't got to these yet.
15:19:39 <cads> even if they were not in english, they were useful
15:19:48 <b_jonas> bo0ts__: sure, just understand the f (g x) one first
15:19:54 <b_jonas> bo0ts__: and what f x y means
15:20:02 <b_jonas> bo0ts__: try this for example
15:20:08 <b_jonas> > (+) 3 8
15:20:09 <lambdabot>   11
15:20:16 <b_jonas> (+) is the addittion function and it takes two arguments
15:20:24 <b_jonas> > ((+) 3) 8
15:20:25 <lambdabot>   11
15:20:27 <Cale> > let addThree = (+) 3 in addThree 8
15:20:29 <lambdabot>   11
15:20:58 <b_jonas> that does not work in most langauges because unlike haskell they don't have curried functions (standard ml is about the only other one)
15:21:24 <b_jonas> there are arguments for non-curried too of course, like easier catching of errors (especially with a weak type system) or vararg functions
15:21:37 <b_jonas> (or the apl syntax)
15:23:00 <b_jonas> heh, MonadLib uses completely different names from mtl
15:23:02 <Cale> But in general, this one works out really nicely for functional programming, because it cuts down on the number of lambdas needed, and can also allow for some optimisations which would otherwise require a variation in syntax.
15:23:05 <b_jonas> say is called put, and put is called set
15:23:13 <Cale> For example, suppose you have a function:
15:23:25 <Cale> regexMatch :: Regex -> String -> Bool
15:23:47 <Cale> Which takes a regular expression and then a String, and decides if the regular expression matches.
15:27:13 <Cale> Sorry, distractions.
15:27:31 <fracture> ugh, haskell-mode for emacs seems to do indentation badly :(
15:27:43 <Cale> Anyway, you could optimise such a function so that after receiving its first parameter, it compiles the regular expression into an efficient String -> Bool function.
15:28:10 <Cale> So that the cost of compiling that regular expression will be paid only once if you map it over a list, say.
15:28:55 <Cale> Regex -> String -> Bool is the same as Regex -> (String -> Bool)
15:29:31 <roconnor> > 100-7.6
15:29:32 <lambdabot>   92.4
15:29:40 <Cale> and so that's an optimisation which is available to a library developer without changing the exposed API, even if an unoptimised version has been in use by other programs.
15:29:44 <bo0ts__> fracture: There are two modes (or three?). Try another one.
15:29:45 <jmcarthur> fracture: a lot of people complain about that, but i've not had any problems with it besides ifelse
15:30:04 <b_jonas> I don't use magical indenters
15:30:19 <Cale> fracture: The annoying thing is that to get it to indent properly, you sometimes have to start typing the beginning of a line, and then hit tab
15:30:30 <fracture> most of that stuff seems ok so far
15:30:32 <Cale> Which I personally find really super-unnatural, so I don't use it
15:30:33 <b_jonas> I only use autoindent in as much that it has to start the next line where the previous line was indented, and tab and backspace should indent or dedent one step
15:30:40 <fracture> but module declarations and data declarations seem totally messed up
15:30:43 <b_jonas> I don't like these smart editor features
15:30:59 <fracture> module Foo (
15:30:59 <fracture>             Bar(..)
15:30:59 <fracture>            , Baz(..)
15:30:59 <fracture>            ) where
15:31:03 <fracture> is what it produces
15:31:04 <jeff_s_> I thought I should let you guys know, haskell is pretty cool.
15:31:09 <fracture> for a module export lit
15:31:11 <fracture> list
15:31:20 <Cale> What I really want more than auto-indentation is something which understands the block-structure of Haskell code properly, and keeps things aligned consistently with layout keywords.
15:31:46 <Cale> (so if you make an edit which pushes do/let/of/where onto a new line, say, the rest of the block goes with it)
15:32:01 <Berengal> Cale: I saw something like that demoed for yi
15:32:13 <Cale> I tried it, but it really seems fragile.
15:32:14 <b_jonas> I don't get this, if you're using layout so the compiler can't know where a block ends without seeing your indentation, then how do you suppose the editor should figure out the indents for you?
15:32:21 <b_jonas> it too can't know where a block ends
15:32:34 <b_jonas> if you use braces, that's different
15:32:35 <Cale> It's okay if you change the indentation of the keyword on one line, but it breaks the moment you press enter.
15:32:37 <roderyk> what's the best way to check if code is running on a Windows or Unix OS? (so I can run some specific setting for each)
15:33:09 <Cale> b_jonas: It can know where the block currently ends.
15:33:20 <Cale> b_jonas: When you're editing above it.
15:33:24 * pumpkin stars at thoughtpolice
15:33:28 <pumpkin> *stares
15:33:29 <Cale> roderyk: hmm
15:33:47 * ray costars at pumpkin
15:33:50 <b_jonas> Cale: so basically you have to tell it where a block ends when you first write it?
15:33:54 <Cale> System.Info.os
15:34:01 <Cale> ^^ roderyk
15:34:11 <Cale> b_jonas: What?
15:34:12 <roderyk> Cale: thanks, will check the api! :)
15:34:18 <b_jonas> Cale: in which case all the magic indenter does is add a level of indent after of/where/let automatically?
15:34:24 <Cale> b_jonas: I mean that if you write a block, and then move the cursor before the 'do'
15:34:34 <Cale> and start editing, it will push the rest of the block around
15:34:36 <b_jonas> "do" too, sorry
15:34:43 <b_jonas> Cale: I see
15:34:55 <b_jonas> Cale: but it can understand that without knowing haskell, can't it?
15:35:05 <Cale> It needs to be Haskell-specific, yes.
15:35:13 <hydo> Any of you using leksah day to day?
15:35:17 <b_jonas> I mean it doesn't need to know haskell
15:35:20 <ray> it doesn't need to know haskell, just the haskell layout rule
15:35:22 <Cale> It just has to know the Haskell layout keywords, mostly.
15:35:28 <b_jonas> because it can just take the indented lines after a line
15:35:35 <b_jonas> it can  be completely unspecific
15:35:37 <b_jonas> can't it?
15:35:39 <Cale> mm...
15:35:45 <Berengal> It needs to know keywords
15:35:47 <ray> i think it's a good idea if it works across lines
15:36:00 <b_jonas> the block ends before the next line that's not indented more than the line after which it starts
15:36:03 <b_jonas> um yeah
15:36:06 <roderyk> before I reboot, is there someone on a Windows box who can tell me what string "System.Info.os" returns?
15:36:10 <ray> as in, you move the magic first non-whitespace thing after the keyword from line to line, and it still works
15:36:16 <b_jonas> maybe it has to know a bit about haskell
15:36:17 <Cale> I'm pretty sure that it needs to know what the four layout keywords are, so that it knows where the block actually begins and can keep things aligned with that.
15:36:18 <roderyk> on linux, its a nice, simple "linux" :)
15:36:18 <b_jonas> like
15:36:34 <b_jonas> in C the next one line (where the closing brace is) might be part of the block
15:36:36 <pumpkin> we all need to go to http://www.haskell.edu/
15:36:37 <b_jonas> maybe
15:36:40 <b_jonas> I'm not sure really
15:36:46 <b_jonas> anyway, I don't like this kind of magic in the editor
15:36:53 <b_jonas> I prefer to do all that by hand
15:37:10 <ray> roderyk: mine says, er, mingw32
15:37:17 <fracture> I'd normally agree with you jonas (at least, in a language like C or C++)
15:37:26 <fracture> in lisp though, not having auto-indent is a nightmare
15:37:26 <Cale> I wonder if that university uses Haskell for their computer science courses. :)
15:37:27 <roderyk> ray: WinXP ?
15:37:31 <fracture> seems like it'd be similar for haskell
15:37:35 <ray> yeah
15:37:40 <roderyk> ray: thanks
15:38:03 <Berengal> Indenting yourself isn't that bad in haskell
15:38:09 <pumpkin> Cale: they'd better!
15:38:15 <b_jonas> fracture: what? wouldn't autoindent in lisp mean that if you forget a paren, your whole code indentation is messed up and then you can't figure out what it's supposed to do?
15:38:31 <ray> lisp editors remember the parens for you
15:38:33 <b_jonas> fracture: isn't it better to do the indents by hand so you at least know what you wanted to say and fix the parens from it?
15:38:40 <ray> sorta
15:38:53 <tetha> b_jonas: there is the danger of indenting how it should be instead of indenting how it is
15:38:53 <hydo> wow, that college has been around for 125 years... nice.
15:38:58 <hatds> if you want the editor to preserve the current block structures would it cause problems when you want to tear apart a block or move some lines out of it?
15:38:59 <Berengal> b_jonas: It's really easy to notice the missing parens exactly because the indentation would break
15:39:11 <fracture> I haven't experienced it that way... I think usually it gets the same indentation with or without the parens on the end
15:39:13 <pumpkin> Cale: doesn't look like they have CS courses :(
15:39:16 <Cale> Berengal: The only mildly annoying thing about indenting on your own is if you want to add stuff before the beginning of a block, you have to indent the following lines (there are ways to avoid that, but it makes the code not quite as pretty)
15:39:20 <thirsteh> roderyk, mingw32 (Windows 7)
15:39:30 <fracture> but if you go to the last paren in the block it'll highlight the matching one in emacs
15:39:33 <ray> well, we can offer to start a CS department
15:39:34 <b_jonas> dunno
15:39:43 <fracture> the next function will be fucked up if you forgot a ) also
15:39:49 <fracture> (fucked up == indented wrong)
15:39:59 <b_jonas> oh, I know what the fourth was
15:40:21 <fracture> is there a haskell code style guide somewhere online?
15:40:23 <b_jonas> I'd like a one-tuple that's not only a monad like Identity is, but also inherits eq, ord, show, read, etc
15:40:29 <Berengal> Cale: Yeah, I would like a proper auto-indenter. As it is, I prettify my code after I'm done writing it, if I bother at all
15:40:30 <roderyk> thirsteh: much appreciated. (and here I was afraid of having to parse 30 different versions of `uname`, much like browser tags)
15:40:38 <fracture> if I switch to manually indenting, it'd be nice to not to invent all my indentation rules
15:40:51 <bo0ts__> hydo: Mine is around for 600 years and I can tell you: It means nothing ;>
15:40:57 <b_jonas> roderyk: you just have to check for win32, don't you?
15:41:00 <Cale> fracture: yes
15:41:02 <jmcarthur> fracture: there is one somewhere, but i'd say it's mostly subjective
15:41:04 <b_jonas> roderyk: or maybe it's Win32?
15:41:06 <b_jonas> something like that
15:41:13 <Cale> http://urchin.earth.li/~ian/style/haskell.html
15:41:20 <fracture> thanks cale
15:41:20 <hydo> bo0ts__: yea, it's a novelty though here in 'murka...
15:41:21 <b_jonas> check for windows, never for unix
15:41:22 <roderyk> b_jonas: seems to be "mingw32"
15:41:23 <b_jonas> unix is the default
15:41:27 <b_jonas> and there are many unices
15:41:29 <b_jonas> roderyk: eek
15:41:35 <jmcarthur> typically there are a lot of exceptional cases as far as style is concerned in most of the haskell code i've seen
15:41:37 <b_jonas> I dunno then
15:41:56 <roderyk> b_jonas: but yes, I need to make exceptions for Win32, so I should be fine
15:42:04 <Cale> The most important rules are: 1) Don't use tabs. 2) Make stuff line up.
15:42:22 <thirsteh> roderyk, indeed. 'XP', 'Vista', 'post2008Server', ugh.
15:42:29 <roderyk> Cale: I read... The most important rules are; ... 2) Make stuff up.
15:42:33 <Cale> hehe
15:42:54 <thirsteh> make it look pretty
15:42:56 <hatds> I like tabs for this reason: I only have to press backspace once to unindent
15:43:06 <hatds> but I don't always use tabs for indents
15:43:07 <Cale> Another, somewhat less important rule is that almost everyone uses camelCase, so probably you should too :)
15:43:19 <fracture> hatds: you can configure an editor to do the same with spaces (I do in emacs, for C and C++)
15:43:22 <hydo> I've been using emacs + haskell-mode and the tabs are starting to get annoying...  is that what the majority of you use?
15:43:25 <thirsteh> hatds, get an editor that understands that? :-)
15:43:26 <Cale> hatds: You can configure your editor to eat multiple spaces like they were a tab.
15:43:29 <b_jonas> hatds: an editor can help you make the tab key indent one level and backspace dedent one level
15:43:31 <fracture> tabs in source files is annoying in any language
15:43:32 <jmcarthur> hatds: in one of the emacs modes you only have to press tab to unindent ;)
15:43:35 <b_jonas> mine does
15:43:36 <thirsteh> consider hatds advised
15:43:38 <b_jonas> but I use tabs
15:43:42 <jmcarthur> to some level
15:43:44 <b_jonas> I like tabs
15:43:50 <b_jonas> but I'm not really against spaces either
15:43:53 <b_jonas> I like both
15:43:57 <Nereid> I never use tabs
15:44:00 <hatds> my editor doesn't :P
15:44:07 <Cale> hatds: The important thing is just that the tab characters don't end up in the actual file.
15:44:12 <b_jonas> hatds: get a proper editor and a proper font?
15:44:12 <fracture> you need a better editor :)
15:44:22 <hatds> I'm writing one
15:44:24 <hatds> :)
15:44:25 <Asztal> my editor does, but it's often annoying when it does, because I don't always align to multiples of 4 :(
15:44:33 * jmcarthur leaves the editor war to get back to coding
15:44:54 * hatds leaves his tabs in his files...
15:45:03 <Berengal> I've found the auto-indenting in emacs to be okay, but it makes for ugly code...
15:45:10 <Cale> I usually smash tab a few times to get enough spaces to make it close and then use backspace/space to put it exactly where I want it.
15:45:33 <Cale> and then my editor will align following lines to that amount, so I don't have to keep doing it.
15:45:36 <hatds> using tabs forces you to learn how to write tab insensitive layout (because displaying your tabs with 8 space width is ridiculous)
15:45:42 <b_jonas> Cale: and what do you use to dedent?
15:45:49 <b_jonas> Cale: I mean, if backspace deletes just one char?
15:46:04 <Cale> It's not so common that I want to do a lot of that.
15:46:05 <Asztal> shift-tab, maybe?
15:46:30 <Berengal> b_jonas: ctrl-shift-home, delete, tab :)
15:46:30 <Cale> though actually, backspace deletes I think 4... I'd have to try it.
15:46:31 <b_jonas> (also, that's ugly. I prefer indents of the same size, whatever their size is, except in assembler where you can be using columns of different size)
15:46:53 <bo0ts__> b_jonas: Hm, ctrl-shit-home right delete xD
15:46:55 <b_jonas> I use backspace to delete one indent
15:46:56 <Cale> ah, just 2
15:46:59 <hatds> I like 1 space indents for if -> then/else
15:47:07 <Cale> tab indents by 2, backspace goes back 2
15:47:18 <hatds> and tab spaced indents for function pat1 pat2 = -> function body
15:47:36 <Cale> for if/then/else, I make the 'then' and 'else' line up with the condition
15:47:39 <Cale> if foo
15:47:42 <Cale>    then bar
15:47:45 <Cale>    else quux
15:48:06 <Gracenotes> if/then/else is sort of annoying for parts in monads where you might not want computation to continue
15:48:13 <Cale> hm?
15:48:24 <nominolo> anyone know what's going wrong here?:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5174#a5174
15:48:25 <pumpkin> :t when
15:48:27 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:48:27 <Cale> You can enclose the rest of the block in when/unless
15:48:32 <pumpkin> :t guard
15:48:33 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:48:34 <nominolo> I did a normal ghc --make
15:48:42 <Berengal> if-then-else is the hardest to indent... I can never decide to do 'if p then\n...\nelse...' or 'if p\nthen...'
15:48:55 <Gracenotes> no, not really
15:48:56 <Cale> Berengal: always always the second
15:49:01 <Gracenotes> none of those work very well.
15:49:08 <Gracenotes> best, I've found, is:
15:49:12 <hatds> I always do 3 lines for if/then/else unless they nicely fit in one line
15:49:19 <Berengal> Cale: That doesn't work so good in do
15:49:22 <Gracenotes> do foo
15:49:25 <Gracenotes>    if cond then bar else do
15:49:27 <Gracenotes>    baz
15:49:31 <Gracenotes> and so on
15:49:32 <Cale> Berengal: Oh, you didn't have extra space there.
15:49:38 <Cale> Berengal: Do it like I showed.
15:49:47 <Cale> Gracenotes: ew...
15:49:59 <Berengal> Cale: The emacs autoindenter doesn't like that...
15:50:06 <Cale> really?
15:50:12 <Cale> Noo...
15:50:16 <Gracenotes> Cale: the only pther alternative is to add yet another level of indentation
15:50:18 <Gracenotes> o
15:50:36 <b_jonas> Berengal: so you let a default editor setting force something on you?
15:50:39 <Cale> Gracenotes: That indentation is good!
15:50:55 <Cale> Gracenotes: It helps understand the control flow of the block.
15:51:18 <Gracenotes> Cale: meh. It is annoying when the cond is only a small case, and there are plenty of more important indentations going on in the whole block
15:51:22 <Berengal> To be honest, I don't use if-then-else very often...
15:51:24 <Cale> Gracenotes: The nice thing about do-blocks is that unless an exception occurs in the monad, when a do-block executes, each line in it executes.
15:51:30 <Cale> There's no jumping out of the middle.
15:52:03 <Berengal> Cale: Cont :P
15:52:10 <Gracenotes> indeed. But sometimes code ends up off-the-page otherwise -- there are many preconditions to check
15:52:23 <Cale> Well, yes, I suppose that falls under what I consider an exception :)
15:52:30 <Berengal> Fair enough
15:52:34 <Gracenotes> I don't mind it personally
15:52:34 <Cale> Gracenotes: refactor! :)
15:52:51 <Gracenotes> Cale: implementing a mathematical algorithm, there's not much you can do manytimes
15:52:56 <Cale> If there are so many nested conditions, there's something strange about the way the code is structured, I think :)
15:53:03 <fracture> where do you guys usually put the "deriving" in a data declaration?
15:53:11 <fracture> in a multiline one I mean
15:53:15 <Cale> fracture: On the following line, indented a bit.
15:53:21 <Cale> Oh, indented 2 spaces
15:53:35 <Cale> data Foo = Bar
15:53:37 <Gracenotes> Cale: if there are many places an algorithm can fail, for instance (a probabilistic algorithm in IO, may or may not yield a result depending on the seed)
15:53:40 <Cale>          | Baz
15:53:44 <Cale>   deriving (Show)
15:53:55 <fracture> what about for a record-ish one
15:53:58 <fracture> like
15:54:01 <fracture> data Foo = Asd {
15:54:01 <fracture>       name :: String
15:54:01 <fracture>     } deriving (Show)
15:54:04 <Berengal> I usually put the deriving dedented two spaces
15:54:06 <fracture> same line as the } ?
15:54:07 <Gracenotes> perhaps using an Exception is best there, but even so, you do have to explicitly catch it in IO
15:54:15 <fracture> and... } in column 0 or indented?
15:54:20 <Cale> fracture: I usually close the brace on the line above.
15:54:24 <fracture> ah
15:54:33 <Cale> data Foo = Asd { name :: String,
15:54:51 <Cale>                  age :: Integer }
15:54:58 <Cale>   deriving (Eq, Ord, Show)
15:55:05 <Gracenotes> which seems a bit of a 'smell' to me, especially when most of the algorithm doesn't even involve IO
15:55:13 <hatds> mm.. I don't know.  If you are building an IO () action sometimes you want to just bail out without throwing an error
15:55:15 <fracture> thanks Cale
15:55:25 <Cale> Gracenotes: Hmm, or a different monad.
15:55:54 <Cale> Gracenotes: Or you need to write a function which captures the particular kind of escaping which you're doing.
15:55:55 <DrSyzygy> data Foo = ASL { age :: Integer, sexIsFemale :: Bool, location :: (Float, Float) } deriving (Show)
15:56:10 <DrSyzygy> We are, after all, on IRC.
15:56:19 <Cale> I suppose I'd need to see an example to show how to do it.
15:56:35 <Cale> I think if a function starts getting nested really deeply, it's time to break it up though.
15:56:37 <Gracenotes> Cale: the kind of escaping is just, if this number is odd or if three numbers are not pairwise coprime, abort
15:56:50 <Cale> Functions which are long and complicated are hard to comprehend and debug.
15:57:03 <Cale> Gracenotes: Then why not put them into one condition?
15:57:17 <Berengal> Gracenotes: Maybe and guard?
15:57:21 <Gracenotes> it happens at different stages of computation
15:57:35 <Gracenotes> I'm talking about my implementation of Shor's algorithm, incidentally
15:57:43 <Cale> Do you have the code for that?
15:58:28 <Cale> nominolo: Oh, btw, that looks like you have an incompatible version of SDL to me. At least, that's my first guess.
15:58:55 <Cale> nominolo: That is, an incompatible version of the C library compared to what the binding is expecting.
15:59:08 <Gracenotes> the type was incidentally, shor :: Int -> IO (Either String (Int, Int))
15:59:27 <nominolo> Cale: hm, I have several installed
15:59:37 <Cale> Gracenotes: Hmm, is there a good reason for IO?
15:59:51 <Gracenotes> Cale: randomness
15:59:57 <Gracenotes> required at several points
16:00:01 <Cale> Oh, I wouldn't have chosen IO for that...
16:00:02 <pumpkin> MonadRandom?
16:00:18 <Gracenotes> perhaps, but same problem with block structure
16:00:41 <ray> pass in a StdGen? (note: i don't know how haskell randomness works)
16:00:53 <Cale> ray: Exactly my second suggestion.
16:00:54 <Gracenotes> and perhaps the more "logical" approach would be IO (Int, Int), and just throwing an exception when something happens, and using try
16:01:02 <Cale> (after using a Rand monad)
16:01:15 <Cale> That would be something you can do since you're in IO
16:01:22 <nominolo> Cale: also, haskell's SDL lib isn't very specific about which version it expects
16:01:26 <Gracenotes> again, I consider that a bit smell-ish
16:01:29 <Cale> nominolo: yeah...
16:01:31 <Gracenotes> well, the stdgen would need to be used twice
16:01:40 <Gracenotes> and again, the block structure problem still exists :)
16:02:10 <Gracenotes> anyway. Where did this start? >_>
16:02:14 <Cale> It's possible to split a StdGen if you have something doubly/multiply recursive.
16:02:28 <hatds> basically you want the C equivalent of break;/return;  ?
16:02:32 <Cale> I'd be curious to see this code.
16:02:42 <Cale> Chances are, I would just do it the way I described.
16:05:05 <Berengal> RandT Maybe?
16:08:44 <BMeph> Cale: Think you could suggest a way to get my functions working? My latest attempt is at: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5168#a5171
16:09:57 <DrSyzygy> *snerk* >>> I use emacs, which might be thought of as a thermonuclear word processor. . .
16:10:45 <ray> emphasis on the thermo
16:11:55 <BMeph> ray: I'd put the emphasis on "nuclear," myself. ;p
16:12:10 <pumpkin> *nukular
16:12:17 <ray> if it were just nuclear, it'd be clean and efficient
16:12:34 <ray> thermonuclear implies boooooooooooooooooooooooooooooooooooooooooooooooooooooooooom
16:12:37 <BMeph> ray: ... uh, sure it would. ;)
16:14:35 <BMeph> Emacs: The thermonuclear word processor. For when you *Never Want to See your Documents Ever Again!*
16:15:32 <tetha> hehe. "Emacs: horribly mutates your documents, and you dont even have to mash weird key combinations to make it do so, because its nuclear!"
16:15:35 <BMeph> Cale: When I get this thing up and running, I'll likely spend an hour on trying to write a good explanation on how it works... ;p
16:23:18 <FunctorSalad> <3 emacs viper-mode
16:23:30 <LeoD> <3 vim normal mode
16:24:16 <tetha> <3 any editor I can forget while using it
16:24:23 <FunctorSalad> but emacs has more stuff ;o
16:24:29 <Raynes> <3 emacs in general.
16:24:55 <tetha> but in fact, I am kind of switching back and forth.. going to vim if the urge for vim's easier interface is there, and switching back to emacs if the stronger auto-indent calls
16:25:02 <BMeph> <3 Everything not Komodo... ;p
16:25:25 <hydo> BMeph: agreed.
16:27:48 * Raynes is a lightweight. Anticipating EclipseFP's renovations.
16:28:58 <Gracenotes> well, that was some delicious dinner
16:33:29 <Raynes> I smell of Axe Vice and Monads.
16:34:45 <Badger> heh
16:35:47 <BMeph> Raynes: Axe Vice? Is that what hoplds the head in place while you sharpen it? ;p
16:35:53 <BMeph> *holds
16:36:16 <Raynes> BMeph: The body spray. But close enough.
16:36:18 <Raynes> ._.
16:36:23 <hatds> hmm.. should 'up' in a text editor move you up a logical line or a word wrapped line?
16:37:44 <FunctorSal> hatds: you remind me I need to set this to "wrapped line"
16:38:08 <hydo> Ack... I've been trying to use textmate and it's nice, but emacs + haskell-mode + flymake keeps me coming back every time.
16:38:23 <hatds> FunctorSal: are you saying you prefer the later?
16:39:00 <FunctorSal> hatds: yes, I always get lost in wrapped lines with my emacs's current setting, which is the former :-(
16:41:20 <Axman6> i don't have any issues with textmate and haskell
16:41:22 <FunctorSal> global-visual-line-mode, it seems
16:42:55 <hydo> I don't have issues per se, it's just that flymake is really nice.  Though it was a pain in the sack-region to configure.
17:07:28 <dagnachew> anyone installed leksah on archlinux ?
17:08:10 <hydo> dagnachew: I did a while back from darcs source.
17:08:30 <dagnachew> hydo, what distro you use ?
17:08:40 <hydo> dagnachew: arch
17:08:41 <dagnachew> it complains about cabal 1.6
17:09:30 <Berengal> dagnachew: You need to fix the cabal file to accept Cabal >= 1.6.something instead of ==
17:09:54 <hydo> dagnachew: I'm trying to remember what I did... I think I fiddled with the cabal file.
17:11:31 <hydo> Is there a way to get the type of a variable?  I'm probably trying to do something impossible, but I'm trying to make a generic parser using guards defined as func :: String -> [a] ... and I would like to use guards against the type of a rather than case.
17:11:48 <hydo> than a case.
17:12:11 <dibblego> a will always be the same type
17:12:27 <mauke> func :: String -> [a] looks useless
17:12:29 <hydo> ah!  another of my assumptions blown apart.
17:12:52 <MyCatVerbs> hydo: No, types have to be fixed at run time. You can use algebraic data types to have a single type that can include several others as alternatives, though.
17:13:26 <Axman6> > read "123 vghfg" :: Integer
17:13:27 <lambdabot>   * Exception: Prelude.read: no parse
17:13:28 <dagnachew> hydo,
17:13:39 <dagnachew> hydo, http://aur.archlinux.org/packages.php?ID=23335
17:13:42 <MyCatVerbs> e.g. data Foo = Bar Int | Baz String -- now if you pattern match on (Bar a), then you know that a :: Int. Or if you pattern match on (Baz a), you'll know that a :: String.
17:14:24 <hydo> makes sense.  Thanks, MyCatVerbs!
17:15:28 <MyCatVerbs> Welcome. ^^
17:15:45 <dagnachew> Berengal, http://aur.archlinux.org/packages.php?ID=23335
17:17:08 * pumpkin replaces roconnor's Sum 1 with Product 1 and optimizes the entire program to O(1) time
17:18:35 <ray> pumpkin: my prelude has a Magma class :P
17:18:46 <pumpkin> ray: yay, that makes me happy
17:19:11 <ray> i couldn't justify anything lower (or think of anything lower)
17:19:23 <pumpkin> I've never heard of anything lower, but who knows
17:19:33 <MyCatVerbs> There *is* nothing lower with any actual operations, surely?
17:19:33 <pumpkin> a "closed" unary operator? :P
17:20:00 <ray> i don't know, but i'm going to have a partial ordering class in addition to ord
17:20:44 <MyCatVerbs> I mean you could define, class AFunctionExists a b c where f :: a -> b -> c, and then instance (AFunctionExists a a a) => Magma a -- if it weren't for the fact that the inevitable overlapping instances would kill you. ;P
17:21:14 <pumpkin> how about BinaryRelation ?
17:21:22 <pumpkin> we could do with one of those
17:21:34 <MyCatVerbs> pumpkin: isn't that just a magma, if it's closed?
17:21:45 <ray> yeah, but what if it's open?
17:22:46 <pumpkin> MyCatVerbs: I thought that assumed you had a function and not a general relation?
17:22:54 <pumpkin> MyCatVerbs: but my algebra sucks, so I may be wrong :)
17:23:37 * MyCatVerbs checks something.
17:24:02 <MyCatVerbs> Oh, no, I have the wrong end of the stick.
17:24:27 <MyCatVerbs> BinaryRelation a b would be either (a -> b -> Bool) or just (a -> b).
17:24:59 <mauke> class Relation a b
17:25:17 <MyCatVerbs> (Depending on which of the (AFAIK isomorphic only on finite sets) ways of defining a binary relation you use.)
17:26:10 <mauke> > 1/.5
17:26:11 <lambdabot>   Not in scope: `/.'
17:26:39 <bogner> is there any way to write different instances of a class for type synonyms?
17:26:53 <mauke> bogner: I hope not
17:27:10 <MyCatVerbs> bogner: no. You need to use newtypes if you want two identically-shaped types to have differing instances.
17:27:13 <ray> you probably want newtypes
17:27:31 <hatds> newtypes for typeclass instances are a pain
17:27:34 <bogner> well, the types are in libraries
17:27:48 <hatds> there should be a way to pass instances as arguments
17:27:55 <bogner> and they have different meanings, but they're both ints
17:28:19 <MyCatVerbs> hatds: there is. Use existentials. :)
17:28:24 <Cale> hatds: But that wouldn't really be any more convenient, would it?
17:28:44 <Cale> I suppose you could avoid unwrapping.
17:28:59 <hatds> Cale: if you are passing many lists into a function it would be easier to pass one "ZipList" dictionary than wrap/unwrap every list
17:29:01 <Cale> But the semantics of it are perhaps a bit tricky...
17:29:30 <MyCatVerbs> hatds: more concretely, you're right, specifying behavoir using newtypes kind of sucks because it gets so verbose so fast. When you want to construct HOFs that take in something akin to the relevant typeclass methods as parameters, so that you can parameterise them easily, then you can construct those types using rank-2 types.
17:29:55 <pumpkin> I really really like this proposal: http://blog.omega-prime.co.uk/?p=61
17:30:01 <MyCatVerbs> (nb: by "verbose" I mean "verbose by Haskell standards". Your average Java hacker probably would not even blink. ^_^)
17:31:10 <ray> pumpkin: me too
17:31:26 <hatds> do you really need rank-2 types? a particular Num dictionary is not universally quantified
17:31:38 <ray> except i care less about breaking existing stuff than most people seem to
17:31:49 <MyCatVerbs> hatds: not always, but for many types you do.
17:31:55 <hatds> I see
17:32:03 <pumpkin> ray: same here :P
17:33:06 <ray> i'd like a syntax for writing instance Num a where... except Num is just an alias for a whole tower of classes, but i can implement all their methods inside one where
17:33:07 <MyCatVerbs> hatds: I think if you wanted to pass in, say, a Monad instance, you'd have to, because return :: forall a. a -> m a. (>>=) has foralls in it too.
17:33:18 <hatds> ah, right
17:33:37 <ray> but i'm not so interested in a way to stay compatible with code that uses the current Num
17:33:47 <ray> compatibility is only for wimps
17:34:37 <hatds> rank-N isn't very nice
17:34:45 <hatds> beyond 2
17:34:52 <hatds> would that ever be a problem?
17:35:42 <MyCatVerbs> hatds: from the compiler's POV, rank-N is no harder than rank-2. Meh.
17:36:15 <pumpkin> I guess we're keeping around the Rank2Types just for backward-compatibility?
17:36:34 <ray> or even something crazy like.. if you have class Functor; class Functor p => Pointed p; class Pointed f => Applicative f; class Applicative m => Monad m
17:36:51 <ray> you can define fmap et al inside an instance Monad...
17:36:52 <pumpkin> call it Pointy
17:36:54 <pumpkin> sounds cuter
17:36:58 <ray> i wonder if that breaks things
17:37:00 <hatds> what's the big to-do with higher rank types again?  is it loss of type inference?
17:37:03 <ray> i don't see how
17:37:34 <MyCatVerbs> pumpkin: AIUI, the story went something like, "We need rank-2 types." *rank-2 types added to GHC* "Uh, y'know, it wouldn't actually be any harder to support rank-n types than it already is to support rank-2 types." "Cool!" *GHC hackers add rank-n*
17:37:43 <pumpkin> lol
17:37:58 <pumpkin> but meanwhile people had already started writing LANGUAGE Rank2Types so we kept that around too?
17:38:00 <MyCatVerbs> hatds: yes, it's the loss of type inference.
17:38:03 <Zao> "wouldn't it be cool if...", the bane of sanity.
17:38:16 <MyCatVerbs> pumpkin: I don't know, I wasn't around for it. :3
17:38:19 <ray> haven't they ever heard of that 0, 1, or n rule?
17:38:34 <pumpkin> I like the type function interpretation of associated types as presented in that recent paper
17:38:38 <MyCatVerbs> Zao: and good, too! Sanity has no place in interesting times. :)
17:38:41 <pumpkin> but it'd be nice if we could write type functions more explicitly
17:39:08 <pumpkin> ray: rank-0 types!
17:39:25 <MyCatVerbs> ray: well, this *is* the 0, 1 or n rule. 0 are monomorphic, 1 are H98 polymorphism, n is what we get after the whole song and dance has been resolved. :)
17:39:36 <MyCatVerbs> pumpkin: rank-0 are just monomorphic types.
17:39:46 <pumpkin> I guess :)
17:40:08 <pumpkin> not as fun as calling them rank-0 though
17:40:14 <pumpkin> you sound more edumacated
17:40:17 <hatds> I find it annoy sometimes that I can't to the equivalent of (flip f) for type constructors
17:40:28 <ray> i think "monomorphic" is word salad outside haskell channels
17:40:32 <Gracenotes> rank-0 probably has a different meaning somewhere else
17:40:35 <pumpkin> me too! I want to write contrafunctor instances without a newtype
17:40:42 <Gracenotes> erm. Well, to think of one, matrices
17:41:06 <ray> which is the extension that allows infix operators besides -> in types again?
17:41:16 <pumpkin> TypeOperators ?
17:41:21 <pumpkin> for things like :*:
17:41:27 <Gracenotes> ja
17:41:29 <pumpkin> and ~> for arrows
17:41:30 <MyCatVerbs> hatds: you can define it as a newtype. newtype Flip f a b = f b a -- and it pretty much Just Works.
17:41:59 <ray> yeah, makes sense
17:42:00 <MyCatVerbs> Or even as a type synonym? I'm not sure if you can do that. *checks*
17:42:03 <ray> i was thinking it had a crazy name
17:42:06 <pumpkin> I thought newtype only wanted one type parameter
17:43:06 <Gracenotes> hm?
17:43:19 <Gracenotes> well, MyCatVerbs, you do need a constructor though
17:43:22 <pumpkin> maybe not :) I thought the restrictions on newtype were one type parameter and one constructor
17:43:25 <MyCatVerbs> Yes, you want to do it with a type synonym, not a newtype.
17:43:33 <MyCatVerbs> pumpkin: you're right, my bad.
17:43:47 <Gracenotes> type synonyms and instances, though... tricky business...
17:44:09 <Gracenotes> o_o
17:44:29 <Gracenotes> o_O
17:44:30 <MyCatVerbs> { type Flip f a b = f b a; type OntoInt x = Flip (->) Int x; foo :: OntoInt [a]; foo = length; } -- Just Works, for everything you could want it to. ^_^
17:44:50 <pumpkin> MyCatVerbs: so I could define a ContraFunctor instance with that?
17:44:55 <MyCatVerbs> Well, I don't think you can curry them so well, but whatever.
17:45:15 <pumpkin> :P
17:45:27 <MyCatVerbs> instance ContraFunctor (Flip (->) x) where cofmap f g = g . f -- ?
17:45:42 * pumpkin tries it out
17:45:47 <ray> if only you could section (->)
17:46:12 <MyCatVerbs> ray: yeah. Wasn't there a proposal for type sections at one point? Ah well, flip works too.
17:46:47 <ray> yeah, i was looking up the type operators thing just now to see if there was any reason it didn't let you section (->)
17:46:50 <ray> or other things
17:47:06 <defun> what does the following ghc error message mean: "Could not find module `Control.Monad.Writer': it was found in multiple packages: monads-fd-0.0.0.0 mtl-1.1.0.2"
17:47:29 <MyCatVerbs> Oh damn, you're not allowed to use type synonyms in instance declarations by default.
17:47:32 <ray> hmm, i don't think that error message should start "could not find"
17:48:33 <ray> besides that, it means the module Control.Monad.Writer is defined in both of those packages
17:48:34 <MyCatVerbs> You've got two different modules calling themselves "Control.Monad.Writer" simultaneously, and they're fighting like cats in a trash compacto.r
17:48:35 <defun> How could it not be found, if it says that it has been found?
17:48:43 <defun> oh
17:48:48 <pejo> defun, neither of the packages are listed in the dependences in the .cabal? (or you're not using --make).
17:48:49 <ray> well, ghc sucks at error messages
17:49:00 <ray> look at all that "possible fix: add an instance for..." stuff
17:49:25 <defun> I used --make
17:49:31 <defun> from ghc cli
17:49:43 <defun> can i remove one of those packages?
17:49:49 <defun> safely?
17:50:12 <pumpkin> category-extras makes me feel so extreme
17:50:32 <MyCatVerbs> ghc-pkg hide monads-fd # is probably what you want to do.
17:50:33 <pumpkin> importing any of its modules into one of mine automatically adds a +5 l33tness score
17:51:19 <MyCatVerbs> pumpkin: I'm confused. Are you is or are you ain't the same person as copumpkin?
17:51:24 <pumpkin> I am :P
17:51:28 <MyCatVerbs> Or should one of you have a goatee and the other not or something?
17:51:30 <pumpkin> I have two computers that I use regularly
17:51:32 <defun> MyCatVerbs: is that a ghc cli option?
17:51:43 <pumpkin> and sometimes they're connected to IRC at the same time, so I alternate a lot
17:51:48 <pumpkin> I can try to avoid it if it's too annoying
17:51:55 <ray> coannoying
17:52:31 <pumpkin> I wonder how hard it would be to add currying to type synonyms
17:52:36 <ray> category-extras is like the giant present under the christmas tree
17:53:49 <MyCatVerbs> defun: hrmn? That's one of the commands that's packaged with ghc.
17:54:00 <MyCatVerbs> defun: you might have to supply --user to that, though.
17:54:41 <MyCatVerbs> Oh hang on, that doesn't do what I was after. *grumbles*
17:55:07 <MyCatVerbs> Anyways, you can use ghc-pkg to temporarily hide troublesome packages so that they won't be visible to the compiler any more.
17:55:19 <defun> cool
17:55:27 <defun> thanks
17:56:14 <MyCatVerbs> And you can undo that change with ghc-pkg expose <packagename>, if you ever do want to.
18:20:01 <ManateeLazyCat> I saw Yi source code write like this: [key ?>>! command] , what's the `?>>!` ?
18:20:15 <Gruppetto> someone's idea of a good operator name
18:21:19 <MyCatVerbs> It's the "ARGH sequencing" operator.
18:21:27 <idnar> hahaha
18:22:19 <Nereid> ManateeLazyCat: it's defined in Keymap/Keys.hs
18:22:42 <Nereid> line 72 in yi 0.6.0
18:22:43 <ManateeLazyCat> Nereid: Thanks
18:23:15 <ManateeLazyCat> Nereid: Yep, i have found it. :)
18:26:22 * sm pushes the release button and thinks, hey, how about a hackage release bot ?
18:27:00 <pumpkin> it's already on twitter!
18:27:01 <pumpkin> ;)
18:27:18 <sm> bah, twitter :)
18:27:49 <Nereid> well if RSS makes its way into lambdabot, there's http://hackage.haskell.org/packages/archive/recent.rss
18:28:34 <sm> for now, here we go:
18:28:44 <Nereid> lol
18:29:32 * BMeph will be duly impressed when a user with a fresh Platform install will be able to "cabal install yi" successfully.
18:29:53 <sm> (if it causes trouble, please ping me)
18:42:25 <gwern> Nereid: no point in putting rss in lb; the codebase is unmaintainable as it is. and we already have rss bots
18:50:37 <pumpkin> @hoogle a -> [a]
18:50:38 <lambdabot> Prelude repeat :: a -> [a]
18:50:38 <lambdabot> Data.List repeat :: a -> [a]
18:50:38 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
18:53:38 <pumpkin> > replicate 3 <=< iterate (+1) $ 2
18:53:40 <lambdabot>   [2,2,2,3,3,3,4,4,4,5,5,5,6,6,6,7,7,7,8,8,8,9,9,9,10,10,10,11,11,11,12,12,12...
18:54:05 <pumpkin> pretty useful! ;)
18:55:26 <chromakode> hey guys, ST noob question: how would I define a "Show" instance for a mutable array in the ST monad? would an unsafeFreeze be ideal in this situation?
18:55:29 <Taggnostr> <=<?
18:56:53 <pumpkin> :t (<=<)
18:56:55 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
18:57:07 <dolio> unsafeFreeze still wouldn't get your show function out of ST, if you want it to work on mutable arrays.
18:57:28 <chromakode> dolio: so I couldn't (and wouldn't want to) make it a Show instance then?
18:57:32 <twb> How do I say ∀ in a type signature?
18:57:37 <pumpkin> forall
18:57:38 <chromakode> twb: forall
18:57:46 <dolio> No, there's no way to make a show of the right type.
18:57:46 <pumpkin> forall a b. a -> b
18:58:00 <chromakode> dolio: darn, thanks
18:58:13 <twb> Illegal operator `.' in type `forall t t1 t2 . (t -> t1 -> t2 -> Distribution.Verbosity.Verbosity -> InstallDirs FilePath -> IO ())'
18:58:28 <chromakode> I've been wrestling conceptually with the choice to use MArrays in my project -- it seems like I lose a lot by making that compromise
18:58:42 <pumpkin> twb: maybe it doesn't like your qualified type?
18:58:59 <pumpkin> chromakode: compared to what?
18:59:05 <chromakode> pumpkin: IArrays
18:59:20 <twb> pumpkin: I guess I need to pass an option to ghc –make to tell it to use them
18:59:21 <chromakode> I'm writing a chess player in Haskell for a class on combinatoric search
18:59:40 <pumpkin> twb: I thought it was fine with them in general, but it doesn't look like it in your case?
18:59:45 <chromakode> to speed it up, I'm working on moving from an IArray board representation to an MArray in ST
18:59:55 <idnar> pumpkin: isn't it an extension?
19:00:05 <pumpkin> yeah, but I thought GHC enabled it by default all the time
19:00:11 <pumpkin> since all the base modules use it
19:00:25 <pumpkin> with some simple encoding involving lots of zis ?
19:00:46 <pumpkin> preflex: zenc Control.Monad.moo
19:00:47 <preflex>  ControlziMonadzimoo
19:02:03 <Twey> Oh, nice
19:02:23 <Twey> Is there an inverse of zenc?
19:02:27 <pumpkin> zdec
19:02:38 <Twey> preflex: zdec zz
19:02:38 <preflex>  z
19:02:40 <pumpkin> preflex: zdec ControlziMonadzimoozizizizizizi
19:02:40 <preflex>  Control.Monad.moo......
19:02:43 <Twey> Oho!
19:03:01 <chromakode> Twey: that was interesting
19:03:15 <Twey> chromakode: What's that?
19:03:28 <chromakode> Twey: the response from zdec
19:03:48 <Twey> GHC uses the z character for encoding of odd characters internally
19:03:57 <Twey> zz is like \\, I guess.
19:04:15 <chromakode> curious.
19:04:16 <inimino> well that's ... unusual
19:04:16 <twb> Why is it "Executable x" and not "Executable: x" in foo.cabal?
19:04:21 <pumpkin> I remember a page with a list of the two or three things that get mangled, but I can't find it now
19:04:54 <Twey> preflex: zenc Zoo.Zum.Zelzebar
19:04:54 <preflex>  ZZooziZZumziZZelzzebar
19:05:02 <pumpkin> http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html
19:05:10 <Twey> preflex: zdec Zz
19:05:10 <preflex>  Zz
19:05:17 <Twey> preflex: zdec ZI
19:05:17 <preflex>  ZI
19:05:23 <Twey> Hm.
19:05:32 <inimino> preflex: zenc Zz
19:05:33 <preflex>  ZZzz
19:05:37 <pumpkin> preflex: zdec zd
19:05:38 <preflex>  $
19:05:45 <pumpkin> that list seems wrong
19:06:02 <inimino> preflex: zenc !$@#%^&*(){}
19:06:03 <preflex>  znzdz40UzhzvzczaztZLZRz7bUz7dU
19:06:23 <Twey> Where did the zi come from, then?
19:06:31 <Twey> preflex: zdec zd
19:06:31 <preflex>  $
19:06:41 <Twey> preflex disagrees with the list.
19:06:58 <inimino> preflex: zdec zi
19:06:58 <preflex>  .
19:07:04 <Neut> hello
19:07:42 <Neut> If I have something, and a list of something. How can I return the number of those somethings in that list of something?
19:07:58 <inimino> preflex: zdec z61U
19:07:58 <preflex>  a
19:08:02 <inimino> ha
19:08:22 <inimino> preflex: zdec z2192U
19:08:23 <preflex>  →
19:08:26 <inimino> nice
19:09:12 <Twey> @hoogle a -> [a] -> Int
19:09:12 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
19:09:12 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
19:09:12 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
19:09:32 <Neut> like type, count :: a -> [a] -> Int
19:09:34 <Twey> Neut: length (elemIndices something somethings)
19:09:48 <Twey> Yes
19:10:03 <Twey> count = (length .) . elemIndices
19:10:12 <Neut> whats elemIndicies?
19:10:21 <inimino> or filter
19:10:23 <Twey> Finds every index of an element in a list
19:10:28 <inimino> @ty filter
19:10:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
19:10:42 <Twey> Yeah, could do a filter on == too
19:10:44 <hatds> I prefer filter:  length . (filter (==x))
19:10:52 <Neut> kk tx
19:11:11 <Twey> > elemIndices 3 [1, 2, 3, 4, 5, 3, 6, 7, 3, 8]
19:11:12 <lambdabot>   [2,5,8]
19:13:34 <Teja> hi
19:14:06 <Teja> can somebody please direct me a best internet resource to learn some useful haskell
19:14:35 <shachaf> Well, "best" is a bit of a difficult word.
19:14:38 <shachaf> @where rwh
19:14:38 <lambdabot> is http://www.realworldhaskell.org/blog/
19:14:41 <Teja> I had some exp with functional programming and already went through realworld haskell
19:14:44 <shachaf> There's that.
19:14:45 <shachaf> Ah.
19:14:47 <Neut> count hand rank = length.(filter(==rank))
19:14:54 <Neut> where does that take the hand argument though?
19:15:24 <shachaf> Well, what do you mean by "useful"?
19:15:28 <Teja> i want to know how haskell is being used in realworld scenarios
19:15:51 <shachaf> The wiki has some things related to that.
19:16:00 <gwern> Teja: do you mean you browsed through RWH or actually did the exercises and everything?
19:16:03 <Teja> want to see how a simple library is being implemented in haskell.... lets say a simple xml parser
19:16:30 <Teja> @gwern : Yes, most part of it..
19:16:30 <lambdabot> Unknown command, try @list
19:16:35 <dmwit> Teja: Check out Hackage.  There's hundreds of packages there for you to peruse.
19:16:52 <gwern> yah. can't complain about having no real world code to look at it
19:16:56 <dmwit> Teja: You could also check out the source of xmonad; it's nice and short and quite readable.
19:17:05 <Neut> nvm I got it
19:17:21 <dmwit> It's also done by some excellent Haskell coders, so it's a great place to learn by example.
19:17:22 <idnar> @type count x xs = length (filter (==x) xs)
19:17:23 <lambdabot> parse error on input `='
19:17:25 <gwern> (I didn't bust my butt cabalizing hundreds of things to see people just ignore hackage)
19:17:29 <Teja> thanks dmwit... but is there any step by step approach
19:17:30 <idnar> @type \x xs = length (filter (==x) xs)
19:17:31 <lambdabot> parse error on input `='
19:17:33 <idnar> ugh
19:17:36 <idnar> @type \x xs -> length (filter (==x) xs)
19:17:37 <lambdabot> forall a. (Eq a) => a -> [a] -> Int
19:17:50 <gwern> Teja: look at dons blog; the zipper post is particularly good
19:18:08 <Teja> dons blog?
19:18:13 <dmwit> ?go dons blog
19:18:14 <lambdabot> No Result Found.
19:18:18 <dmwit> eh?
19:18:24 <gwern> yes, he used to have a blog, though I haven't see any updates in ages
19:18:33 <Teja> url please
19:19:02 * gwern has given you enough keywords to google for
19:19:30 <Teja> got it thanks
19:20:38 <Teja> looks pretty interesting... thanks again gwern
19:20:40 <gwern> there are some fascinating things on the old haskell wiki
19:20:42 <gwern> like http://web.archive.org/web/20060304045429/www.haskell.org/hawiki/RunTimeCompilation
19:20:53 <copumpkin> don't we have any backups other than archive.org?
19:21:03 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2465#a2465
19:21:06 <gwern> they apparently disapeared
19:21:08 <Neut> Can someone help me with that please.
19:21:12 <copumpkin> that sucks
19:21:24 <copumpkin> Neut: what's wrong?
19:21:42 <Neut> Getting a type error
19:21:44 <Neut> and Im not sure why
19:21:52 <copumpkin> can you show it to us? :P
19:22:56 <Neut> yeah i updated it
19:22:57 <MyCatVerbs> @where hpaste
19:22:57 <lambdabot> http://hpaste.org/
19:23:07 <MyCatVerbs> Oh, moonpatio. Feh.
19:23:19 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2465#a2466
19:23:25 <copumpkin> :t countRank hand rank = length.(filter(==rank).hand)
19:23:26 <lambdabot> parse error on input `='
19:23:31 <dolio> You're saying "hand" has type Hand, and then you're composing it with "filter (== rank)".
19:23:32 <copumpkin> :t let countRank hand rank = length.(filter(==rank).hand) in countRank
19:23:33 <lambdabot> forall a a1. (Eq a1) => (a -> [a1]) -> a1 -> a -> Int
19:23:53 <BMeph> countRank hand rank = length(filter(==rank) hand)
19:24:24 <copumpkin> wonderful whitespace why have you forsaken me
19:24:31 <BMeph> Neut: I.e., those little dots do not mean what you think they mean. ;)
19:24:58 <Neut> Hmm,
19:25:04 <Neut> so what do I need to change to fix it?
19:25:09 <copumpkin> take the dots out
19:25:14 <copumpkin> and use more whitespace
19:25:32 <Neut> Still get a type error
19:25:38 <copumpkin> :t let countRank hand rank = length (filter (== rank) hand) in countRank
19:25:40 <lambdabot> forall a. (Eq a) => [a] -> a -> Int
19:26:06 <copumpkin> oh
19:26:13 <copumpkin> you're asking for hand to be a list of Ranks
19:26:18 <copumpkin> but also expect it to be a list of Card
19:26:40 <BMeph> countRank hand = length . filter ((==rank) . fst) -- note the addition to the filter predicate
19:27:11 <twb> Can someone confirm that Cabal is horribly broken?
19:27:11 <twb> darcs get http://twb.ath.cx/tmp/tinc && darcs check --repo tinc --test
19:27:48 <BMeph> countRank hand rank = length (filter ((==rank) . fst) hand) -- My bad, didn't notice your argument order
19:27:49 <copumpkin> that url is a 404 here
19:27:52 <twb> Attempting to ./Setup copy --destdir=/tmp, I get
19:27:56 <twb> "Creating /usr/local/share/doc/foo-1/man1 (and its parents)"
19:28:04 <twb> ...which is utterly ridiculous.
19:28:15 <Neut> :BMeph thankyou Haskell gods
19:32:31 <wli> What's "rank?"
19:32:57 <copumpkin> maximal number of linearly independent cards
19:32:58 <copumpkin> oh wait ;)
19:33:00 <Zao> In cards, it's the value.
19:33:13 <wli> Never mind.
19:33:21 <Neut> On the paste I copied the type/data over'
19:33:24 <Zao> I keep getting confused when rank is used in here.
19:33:31 <Zao> I map it to type ranks.
19:33:42 <BMeph> wli: Your garbage, after a weekend in the Florida sun? ;p
19:34:28 <MyCatVerbs> wli: contra-thingumminess of foralls in type signatures.
19:34:34 <Neut> Later guys
19:37:24 * BMeph thinks of extents
19:38:46 <copumpkin> I'm gonna make a mirror of the archive.org hawiki
19:38:52 <copumpkin> do you think that's safe?
19:38:56 <copumpkin> (license-wise)
19:42:05 <ray> well, who will sue you, and can you ask them not to
19:42:15 <inimino> if it's already on archive.org...
19:42:32 <twb> http://hackage.haskell.org/trac/hackage/ticket/555
19:42:37 <copumpkin> archive.org is slow as hell
19:42:39 <MyCatVerbs> copumpkin: isn't the whole of the Haskell wiki marked with "blah blah blah under a simple permissive license"?
19:43:01 <MyCatVerbs> So you shouldn't have any legal troubles anyways.
19:43:10 <copumpkin> not sure if the old wiki was marked that way, but maybe
19:43:42 <MyCatVerbs> The current one sure is.
19:43:49 <copumpkin> yeah
19:54:57 <inimino> as long as you're archiving it (and not basing something new on it) I don't see how you possibly could have a problem
19:55:00 <inimino> copumpkin
19:57:26 <Vorschlagsnoten> what could possibly go wrong
19:58:08 <roconnor> darcs get foo doesn't actually access foo
19:58:22 <roconnor> woah
19:58:23 <roconnor> sorry
19:58:32 <roconnor> apparently I was scrolled back
19:59:49 <copumpkin> :)
20:00:47 <SamB> roconnor: you mean it goes straight to foo/_darcs ?
20:02:19 <SamB> (or foo/.git ;-P)
20:02:56 <copumpkin> I wish that were .darcs instead of _darcs
20:04:02 <Berengal> Coding is fun
20:04:40 <copumpkin> is arithmetic coding still patented?
20:05:00 <wli> What's wikipedia say?
20:05:07 <copumpkin> just looking ow
20:05:08 <copumpkin> now
20:05:37 <copumpkin> most of them say "now expired"
20:05:37 <dolio> @yow!
20:05:37 <lambdabot> Hand me a pair of leather pants and a CASIO keyboard -- I'm living for today!
20:05:49 <copumpkin> but a couple might still be going
20:05:59 <wli> http://en.wikipedia.org/wiki/Arithmetic_coding#US_patents_on_arithmetic_coding
20:06:16 <copumpkin> yup
20:09:23 <Cale> Arithmetic coding seems like something which if I were working for the patent office, I would not issue a patent for on the grounds that it is too obvious.
20:11:25 <erikc> that's sadly true of the vast majority of software patents
20:11:38 <copumpkin> yup
20:11:48 <Cale> "Hey guys, let's encode messages as real numbers in the interval [0,1]" "Okay, how should we do it?" "Well, we could assign each initial prefix of the message an interval corresponding to its probability of occurrence." "Oh yeah."
20:11:54 <wli> Quite true.
20:14:43 <copumpkin> even better, "When implemented in the manner described in G N N Martin's 1979 paper, range encoders are free from patents relating to arithmetic coding, even though they're the same thing in practice."
20:15:06 <copumpkin> two people should implement provably equivalent algorithms and submit patents for both at the same time
20:16:07 <wli> Computers won't matter to enough people for long enough to matter.
20:17:05 <Cale> huh?
20:26:04 <Cale> wli: Because the Butlerian Jihad is coming anyhow?
20:26:44 <wli> I would not characterize the anticipated disruption as that.
20:27:05 <SamB_XP> Cale: is that where Jeeves comes back to life and kills EVERYONE ?
20:27:33 <SamB_XP> (though I guess he usually acts as a valet ...)
20:30:14 <dolio> If it leads to anti-gravity belts so we no longer have to worry about getting fat and exercising while still being able to move, I'm all for it.
20:32:21 * BMeph measures dolio's neck for an arterial plug
20:33:41 * p_l would prefer nanotech-based full cyborgisation
20:33:53 <Cale> I wonder if the Butlerian Jihad was caused by one too many spam headers saying "ENH4NCE YOUR PRESCIENCE, PUT SPICE INTO YOUR S.3.X LIFE, 100% NATURAL"
20:34:53 <dolio> H0T B3N3 G3SSER1T TEENS READY TO SATSIFY YOUR NEEDS!
20:35:01 <p_l> Cale: Or maybe it was spammers noticing that AIs started to overcome their schemes? :P
20:36:36 <SamB_XP> dolio: isn't that bad for your ... uh, cardiac functions ?
20:37:20 <dolio> Whatever.
20:37:43 * copumpkin is finally getting around to adding the modexp primop for Integer
20:38:49 <dolio> It's about time! :)
20:39:10 <dolio> Are there any others that are suitable for inclusion?
20:39:16 <copumpkin> I might just go through the exported api for GMP's mpz and add corresponding to any functions that look interesting
20:39:31 <copumpkin> these look nice http://gmplib.org/manual/Number-Theoretic-Functions.html#Number-Theoretic-Functions
20:39:33 <dolio> I can't really recal what all is in there.
20:39:52 <copumpkin> they'd help us do very fast euler problems ;)
20:40:03 <copumpkin> http://gmplib.org/manual/Integer-Roots.html#Integer-Roots might also be handy
20:40:13 <dolio> Well, probab_prime_p would have to be in IO.
20:40:23 <copumpkin> yeah :)
20:40:23 <dolio> As would nextprime, technically.
20:41:06 <copumpkin> that wouldn't stop them from being useful though would it?
20:41:15 <dolio> No.
20:41:21 <dolio> @src gcd
20:41:21 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
20:41:21 <lambdabot> gcd x y = gcd' (abs x) (abs y)
20:41:21 <lambdabot>    where gcd' a 0  =  a
20:41:21 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
20:41:43 <dolio> I wonder how much faster the gcd stuff is.
20:42:06 <copumpkin> I'll stick it in and test it... if it's much faster I'll leave it in, otherwise I might as well not pollute with excessive primops
20:42:28 <copumpkin> I wonder where I'd put a user-level API for it though
20:43:02 <dolio> I'd go with Data.Integer, probably.
20:44:02 <dolio> Does the integer package work cross-compiler?
20:44:21 <copumpkin> how do you mean?
20:44:50 <dolio> They split a fair bit of the integer stuff out of base.
20:45:05 <dolio> It's just GHC.Integer(.*), though.
20:45:25 <dblazakis> i've got a Data.Binary instance (Foo) and a ByteString -- what is a good way to wrte a function f :: Get [Foo] to keep grabbing Foos from the ByteString until an exception occurs?
20:45:26 <copumpkin> oh I see
20:45:33 <copumpkin> I was only looking at GHC.Prim so far
20:45:46 <copumpkin> I guess I'll put the user-level interface in GHC.Integer for no
20:48:18 <copumpkin> now I need to figure out how to write cmm :)
20:48:24 <copumpkin> the existing macros don't help for modexp
20:49:22 <copumpkin> lol
20:49:29 <copumpkin>  /* ToDo: this is shockingly inefficient */
20:50:04 <dolio> What's that from?
20:50:13 <copumpkin> the primops.cmm
20:50:27 <copumpkin> something to do with the threaded rts, didn't look too carefully :)
20:52:07 <Vorschlagsnoten> whar
20:54:47 <dolio> While you're in there, you should figure out how to determine when integer values won't be used again, and thus can be reused by gmp, instead of always allocating new ones. :)
20:55:16 <copumpkin> ack, I'm a noob!
20:55:17 <copumpkin> :P
20:55:23 <copumpkin> I'll look though
20:55:28 <dmwit> grep, I'm a noob, too!
20:55:43 <copumpkin> looks like someone's already prepared for that
20:55:48 <copumpkin> #define FETCH_MP_TEMP(X) \
20:55:58 <Vorschlagsnoten> $ ack-grep --thpppt
20:56:28 <BMeph> who sed that ?
20:56:45 <dolio> That wasn't a serious suggestion. You couldn't do it without uniqueness typing or some kind of analysis of the intermediate code. :)
20:57:13 <copumpkin> oh :(
20:57:29 <copumpkin> well, I just proved my statement, at least :)
20:57:33 <Vorschlagsnoten> BMeph: a tr-icky decision
20:58:13 <Lemmih> @tell dons. Yes, I read it. It is a subset of closed world grin. It seems to be half way between the implicit laziness of core and explicit thunk layout of grin.
20:58:14 <lambdabot> Consider it noted.
20:58:50 <dolio> Well, I suppose you could also have some kind of pool of integers or something, and only allocate them when everythign in the pool is being used, but that isn't easy either.
20:59:58 <copumpkin> I'm trying to figure out how cmm deals with args for now
21:00:13 <copumpkin> none of the existing gmp functions need as many args as modexp
21:00:36 <copumpkin> I figure it's probably just the next register along
21:00:43 <copumpkin> but I don't really know
21:00:46 <dolio> Arguments are implicit in ghc cmm, I think.
21:00:53 <copumpkin> yeah, they aren't explicitly listed
21:00:59 <dolio> Unlike real cmm.
21:00:59 <copumpkin> but the function I'm writing grabs them somehow
21:01:05 <Lemmih> @tell dons It'll undoubtly be an improvement for GHC. For LHC there isn't much to come after, though.
21:01:06 <lambdabot> Consider it noted.
21:01:28 <copumpkin> there are four register arguments for the two Integers and I need a fifth for the actual exponent
21:01:57 <copumpkin> not sure if ghc keeps passing args in registers for 5 args though
21:07:08 * copumpkin is trying to figure out the calling convention in GHC :P
21:07:43 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/CallingConvention
21:07:46 <copumpkin> what is N? :P
21:08:22 <dolio> Heh.
21:08:56 <copumpkin> I'd imagine it would differ from platform to platform (how many registers were available)
21:09:12 <copumpkin> but I'm not sure how that is reflected in cmm
21:09:21 <copumpkin> anyway, I'll idle in #ghc
21:09:31 <dolio> Doesn't every Integer in a primop correspond to two arguments?
21:09:41 <dolio> An Int# and a ByteArray#.
21:10:05 <copumpkin> eah
21:10:33 <copumpkin> but for modExp I need two Int#/ByteArray# pairs (for base and modulo) and an Int# for the exponent
21:10:49 <copumpkin> and no primop function I can find has 5 arguments
21:11:12 <copumpkin> the first four are definitely in R1-R4
21:11:14 <dolio> Oh. You're doing that modexp.
21:11:38 <copumpkin> yeah, that looked like the hardest one :P I'll move to the other simple additions in a bit
21:12:20 <dolio> Well, the other one requires you to find out if it passes 6 arguments in registers, doesn't it? :)
21:12:52 <copumpkin> which one? I was going to start with the nice integer root functions :P
21:13:30 <dolio> Wasn't there an 'b^e mod k' all Integers? Or was I seeing things.
21:14:09 <copumpkin> oh, you're right :)
21:14:22 <copumpkin> I missed that one
21:16:22 <SamB_XP> copumpkin: I don't see where ELSE arguments could be passed ...
21:16:29 <copumpkin> on the stack?
21:16:37 <SamB_XP> the what now ?
21:16:48 <copumpkin> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution/CallingConvention
21:16:53 <copumpkin> don't ask me, ask them :P
21:17:00 <dolio> Do cmm registers correspond to real registers in a way you have to worry about them?
21:17:13 <copumpkin> I'm starting to think they don't
21:17:19 <SamB_XP> not really, know
21:17:29 <copumpkin> if I can refer to R4 and this code might run on i386
21:17:32 <SamB_XP> er. s/know/no/
21:17:37 <copumpkin> that's already a good indication that it's an abstraction, I guess
21:18:53 <copumpkin> I'll try with R5 and R6 and see if it eventually crashes on me
21:22:04 <SamB_XP> seen http://hackage.haskell.org/trac/ghc/wiki/AddingNewPrimitiveOperations ?
21:22:14 <SamB_XP> there's something quite odd about the example ...
21:23:04 <SamB_XP> copumpkin: don't you think so ?
21:23:41 <copumpkin> hah :)
21:23:43 <dolio> Did pumpking write this? :)
21:23:47 <dolio> Or maybe it was me?
21:23:47 <copumpkin> lol, no
21:24:04 <SamB_XP> copumpkin: I guess you agree!
21:24:09 <copumpkin> I didn't come across that page, I was looking at another page about primops
21:24:32 <SamB_XP> since the example seems to be just what you are doing ;-P
21:24:34 <copumpkin> but it's almost exactly what I wrote so far
21:24:36 <copumpkin> lol
21:24:56 <SamB_XP> one wonders why it didn't make it upstream ?
21:25:15 <copumpkin> who knows
21:25:38 <copumpkin> the only difference is that I called it modExp
21:25:49 <copumpkin> I guess I should call it powmod?
21:26:26 <dolio> You should probably put 'integer' in the name somewhere.
21:26:29 <copumpkin> I've always thought of it as modular exponentiation
21:26:30 <SamB_XP> dunno!
21:26:31 <copumpkin> oh I already have
21:26:41 <copumpkin> modExpIntegerInt# and modExpInteger#
21:27:11 <copumpkin> I'll leave it like this and see if anyone complains
21:27:43 <dolio> modExp is fine for my money.
21:27:50 <SamB_XP> yeah
21:27:58 <SamB_XP> or expMod, whatever
21:28:26 <SamB_XP> we aren't going to expect it to give e^n % m
21:28:51 <SamB_XP> (does that even mean something ?)
21:29:02 * SamB_XP goes to bed
21:32:28 <haskellnewb> any way to make "newtype" or "data" declaration work in ghci ?
21:32:40 <dolio> Nope.
21:34:02 <haskellnewb> dolio thanks. so you just define all types in a file and load in ghci?
21:34:53 <dolio> Yeah, unfortunately.
21:41:47 <roconnor> with (,) Either () and Mu, who needs any other types? :P
21:42:21 <roconnor> oh and (->)
21:42:22 <ivanm> what's Mu?
21:42:28 <roconnor> @src Mu
21:42:28 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
21:42:36 <roconnor> ... that doesn't come in the Prelude. :(
21:42:40 <ivanm> wtf?
21:42:44 <ivanm> what does it do?
21:42:50 <roconnor> @kind Mu
21:42:51 <lambdabot> (* -> *) -> *
21:42:58 <dolio> Fixed point.
21:42:59 <inimino> hehe
21:42:59 <roconnor> makes a fixedpoint type
21:43:06 <ivanm> yeah, was thinking that
21:43:22 <sayyestolife> when I used Common Lisp, there was a trace function who could easily trace and show different function calls (in a nice readable manner) does something similar exist for Haskell?
21:43:25 <ivanm> roconnor: well, some actual numeric types might be helpful for efficiency purposes...
21:43:55 <roconnor> ivanm: bah.  Mu (Either ()) is good enough for anyone :P
21:44:11 <ivanm> heh
21:44:15 <roconnor> no one will ever need more than 640
21:44:54 <ivanm> roconnor: so what's the fixed point of Mu (Either ()) ? AFAICT, it's infinite... >_>
21:45:07 <dolio> Natural numbers.
21:45:25 <ivanm> is it?
21:45:30 <dolio> Left (), Right (Left ()), Right (Right (Left ())), ...
21:45:42 <dolio> Plus some Mu noise.
21:45:47 <ivanm> oh, duh, because of how Either works
21:45:51 <roconnor> ivanm: It could be In (Left ())  or In (Right (In (Left ())) or In (Right (In Right ...
21:45:56 <ivanm> with Left () == zero?
21:45:57 <inimino> march!
21:46:04 <ivanm> inimino: lol
21:46:09 <roconnor> ivanm: sure, why not.
21:46:20 <roconnor> ivanm: depends on how you want to define +
21:46:28 <dolio> My natural numbers start at 2!
21:46:40 <ivanm> dolio: oh?
21:46:50 <ivanm> so you don't have any identities for addition or multiplication?
21:46:56 <roconnor> fine, if you want to be efficent:  Mu (Either (Either () ()))
21:47:00 <copumpkin> dolio: finished making my changes and writing an accessor in GHC.Integer
21:47:06 * copumpkin tries compiling :)
21:47:09 <dolio> Does it work?
21:47:30 <copumpkin> I'll tell you in a day when GHC finishes compiling :P
21:47:36 <copumpkin> actually with -j5 it shouldn't take long
21:47:46 <dolio> Yeah, that's the pain of doing that kind of work.
21:47:49 <dmwit> sayyestolife: We're getting it soon!
21:47:58 <copumpkin> dolio: going to hac phi?
21:48:01 <dolio> roconnor: What's that? An extra value for infinity or something?
21:48:01 <dmwit> sayyestolife: If you happen to be using GHC HEAD, you can probably get it today.
21:48:10 <dolio> Wasn't planning on it.
21:48:30 <roconnor> Either () () is Bool
21:48:37 <dolio> Oh, right.
21:48:53 <dmwit> sayyestolife: Well, we're getting stack traces soon, anyway; not sure if that's what you were actually asking for.
21:49:26 <dmwit> sayyestolife: In the meantime, you can use Debug.Trace.trace to print debug messages, but it's usually considered a little bit dirty.
21:49:40 <roconnor> hmm
21:49:41 <ivanm> @src trace
21:49:41 <lambdabot> trace string expr = unsafePerformIO $ do
21:49:42 <lambdabot>     hPutStrLn stderr string
21:49:42 <lambdabot>     return expr
21:50:01 <ivanm> dmwit: I'd say more than just a "little bit" ;-)
21:50:09 <dmwit> Not really.
21:50:30 <dmwit> You'd have to do some pointer munging or something to rise above "a little bit dirty." =)
21:50:47 <roconnor> dolio: am I missing the S and K type combinators?
21:51:14 <dolio> Possibly.
21:51:29 <roconnor> I don't think I can't make data Dom = Dom (Dom -> Dom)
21:51:30 <ivanm> dmwit: heh
21:52:02 <dmwit> newtype Join f a = f a a
21:52:14 <dmwit> Dom = Mu (Join (->))
21:52:22 <roconnor> now do Const
21:52:39 <copumpkin> isn't Const a phantom type?
21:52:49 <roconnor> ya
21:52:55 <copumpkin> oh, I guess you can't get rid of it?
21:53:19 <Berengal> What, are we implementing LC in the type system now?
21:53:32 <roconnor> and then do flip
21:53:47 <roconnor> Berengal: we need to.
21:54:05 <dolio> Well, if you want to have type combinators for all the stuff you can write with haskell data declarations, you pretty much need LC.
21:54:07 <roconnor> Berengal: so we can get all our types in ghci.
21:54:27 <roconnor> but I wonder if we can just define one Dom type
21:54:51 <roconnor> and then some how program in an untyped manner
21:54:52 <Berengal> roconnor: So we're doing this to overcome the lack of type definitions in ghci?
21:54:55 <dolio> (), (,), Either, Mu and (->) is only enough for simple types, I think.
21:55:10 <roconnor> Berengal: yep
21:55:15 <Berengal> I love this channel...
21:55:27 <ivanm> ahhh.... that makes more sense then
21:55:40 <ivanm> then again... why do you want to be able to define types in ghci?
21:56:23 <dolio> Strictly speaking it isn't even enough for some simple types, I guess.
21:56:44 <ivanm> roconnor: hmmm... with your quote in HWN, why did you want to make something as slow as Python?
21:57:06 <dmwit> > ( )
21:57:07 <lambdabot>   ()
21:57:08 <dolio> 'newtype Foo = Foo (Maybe (Maybe Foo))' needs composition for 'Mu (Maybe :. Maybe)'.
21:59:00 <roconnor> ivanm: http://www.reddit.com/r/programming/comments/8mmcu/i_tried_to_translate_the_ironpython_code_to/
21:59:15 <copumpkin> I'm still tempted to try to add inline primops for all the SSEn instructions (with suitable changes to the x86(_64) codegen
21:59:36 <dolio> Also, Mu (Either (Either () ())) isn't binary naturals.
21:59:40 <copumpkin> although maybe it would be better to try to abstract it to different simd archs
22:00:06 <roconnor> dolio: huh?
22:00:16 <dolio> Mu (Either () :. (,) (Either () ())) is.
22:00:26 <roconnor> oh
22:00:33 <copumpkin> what's :. ?
22:00:37 <dolio> Composition.
22:00:50 <copumpkin> is it possible to write that?
22:00:52 <roconnor> aww
22:00:57 <roconnor> we need a compose combinator too
22:01:03 <roconnor> I was afraid of that
22:01:07 <dolio> Yeah.
22:02:21 <roconnor> can we encode everything in data Dom = Dom (Dom -> Dom) ?
22:02:34 <roconnor> Does Dana Scott have something to say about this?
22:02:43 <copumpkin> is that fix in typeland?
22:02:57 <dmwit> No, it's "Dynamic" in typeland.
22:02:57 <roconnor> copumpkin: no Mu is fix in typeland
22:03:11 <dmwit> Not sure what all this Dom naming is about. =P
22:03:11 <copumpkin> hmm, Dynamic?
22:03:19 <roconnor> Domain
22:03:40 <dmwit> copumpkin: It's the type of an untyped lambda-calculus term.
22:03:47 <copumpkin> ah
22:04:07 <copumpkin> so we'd be able to write loop in terms of it?
22:04:09 <roconnor> ah right
22:04:36 <roconnor> \a b. a becomes Dom (\a -> Dom (\b -> a))
22:05:22 <ivanm> roconnor: so was that yet another case of ghc turning horribly inefficient code into rather efficient code?
22:05:24 <hatds> wow guys, I'm lol'ing
22:05:30 <hatds> gnight
22:06:04 <dmwit> Dom (\f -> Dom (\x -> (unDom ((unDom f) (unDom x x)) ((unDom f) (unDom x x))))) -- omega! O_o
22:06:09 <roconnor> ivanm: yep.  I tried, I really tried.
22:06:12 <copumpkin> nice :)
22:06:23 <roconnor> dmwit: sorry, that is the y combinator
22:06:28 <ivanm> roconnor: heh
22:06:29 <ivanm> harrop's comment was a bit weird though...
22:06:30 <roconnor> omega is Y id.
22:06:31 <dmwit> ultra fail
22:06:40 <dmwit> And I call my self a PL guy.
22:06:50 <copumpkin> aw
22:06:56 <roconnor> ivanm: oh?
22:07:14 <roconnor> jdh30?
22:07:16 <copumpkin> yup
22:07:21 <ivanm> roconnor: yup
22:07:28 <roconnor> I think it was a fair comment.
22:07:35 <roconnor> I neither voted it up nor down
22:07:57 <SubStack> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2469#a2469
22:08:00 <copumpkin> it was strange in that it wasn't unpleasant :P
22:08:04 <copumpkin> very uncharacteristic of him
22:08:08 <roconnor> ah
22:08:09 <ivanm> copumpkin: yeah
22:08:24 <ivanm> he wasn't actually bashing anyone
22:08:34 <copumpkin> I mean he did say the famous "real software" thing
22:08:35 <ivanm> just the pseudo-benchmark being used
22:08:36 <copumpkin> but that's about it
22:09:14 <roconnor> ivanm: I really thought I was doing a fair translation to Haskell, but then GHC had to go screw it up by making it exponentially more efficient.
22:09:20 <copumpkin> I think thoughtpolice was so terrified by trying to get a registered x86_64 osx build that he ran away
22:09:22 <SubStack> it seems like there's some higher-level function I should be familiar with there
22:09:23 <roconnor> my fault for using the Writer Monad.
22:09:25 <ivanm> roconnor: lol
22:09:28 <roconnor> first time.
22:09:31 <SubStack> or pattern or what-have-you
22:10:14 * copumpkin urges his GHC build to finish
22:11:22 <copumpkin> omg it's me
22:11:46 <ivanm> *sigh*
22:11:54 * SubStack boggles at the multi-pumpkins
22:12:02 * copumpkin hides from ivanm
22:12:04 <dmwit> And with the same netmask, too!
22:12:27 <roconnor>  /join #cohaskell
22:12:36 <dolio> flip (-) = subtract
22:12:43 <ivanm> copumpkin: don't worry, I'm not a big fan of pumpkins
22:12:49 <ivanm> *of eating pumpkins
22:13:09 <dolio> > map length ["flip (-)", "subtract"]
22:13:10 <lambdabot>   [8,8]
22:13:13 <ivanm> and I'm not from North America, so I don't butcher them near the end of october either
22:13:27 <roconnor> @src subtract
22:13:27 <lambdabot> subtract x y = y - x
22:13:28 <copumpkin> I don't either!
22:13:47 <SubStack> pumpkins don't even exist!
22:14:01 <roconnor> > length . ["flip (-)", "subtract"]
22:14:03 <lambdabot>   Couldn't match expected type `a -> [a1]'
22:14:20 <SubStack> nifty @ subtract
22:14:44 <SubStack> I think I've heard that before even
22:14:48 <dmwit> > map length ["map (flip (-))", "map subtract"]
22:14:49 <lambdabot>   [14,12]
22:15:22 <dmwit> (So "subtract" can still be shorter in some cases, even though on its own it is as long as "flip (-)".)
22:15:47 <dolio> It can?
22:15:51 <roconnor> > map length ["map$flip (-)", "map subtract"]
22:15:52 <dolio> Oh, right.
22:15:53 <lambdabot>   [12,12]
22:16:11 <roconnor> > map length ["map$flip(-)", "map subtract"]
22:16:12 <lambdabot>   [11,12]
22:16:32 <dmwit> > map length ["map (flip (-)) xs", "map subtract xs"]
22:16:33 <lambdabot>   [17,15]
22:16:36 <Berengal> Not to mention no parenthesis in subtract
22:16:40 <dolio> map subtract isn't the type of thing you're likely to see.
22:16:44 <dmwit> > map length ["map(flip(-))xs", "map subtract xs"]
22:16:45 <lambdabot>   [14,15]
22:17:00 <dolio> More likely "map (subtract 1)".
22:17:17 * dmwit posits that " subtract " is nevertheless more readable than "(flip(-))", and that any sane person would be putting the spaces in anyway
22:17:28 <dmwit> dolio: true
22:17:39 <dolio> It is more readable, though.
22:17:50 <Berengal> What annoys me is that you can't map (-1)
22:18:02 <dmwit> Yep, that was probably one of the less good decisions.
22:18:16 <dmwit> (And is the direct motivation for defining subtract.)
22:18:24 <Berengal> I would've gone for ~1 had I been designing the language, but that might be just me
22:18:32 <dmwit> ~1 is a pattern
22:18:35 <dolio> Coming up with an alternate negative number notation would probably be good.
22:18:45 <dolio> Although the current negative is pretty magic.
22:18:45 <dmwit> > let ~1 = 1 in 32
22:18:47 <lambdabot>   32
22:18:50 <Berengal> _1 then
22:18:50 <ivanm> Berengal: map pred ;-)
22:18:53 <dolio> > let n = 52 in -n
22:18:55 <lambdabot>   -52
22:19:11 <ivanm> Berengal: so you want to re-define mathematics then? :o
22:19:12 <ivanm> ;-)
22:19:23 <copumpkin> > map (+(-1)) [1..10]
22:19:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
22:19:25 <outchanter> map (-1+)
22:19:38 <copumpkin> nicer :)
22:19:39 <dolio> Also, I frequently got bit by the fact that "-n `mod` k" parses as "-(n `mod` k)" in the past.
22:19:41 <dmwit> > map (+ -1) [1..10] -- hmmm
22:19:42 <lambdabot>       The operator `+' [infixl 6] of a section
22:19:42 <lambdabot>          must have lower prece...
22:19:48 <Berengal> ivanm: Mathematics got it wrong when they chose the same symbol for negation and subtraction
22:19:55 <copumpkin> implicit 0!
22:20:04 <ivanm> exactly
22:20:12 <roconnor> I would just redesign the language not to have numbers.  They are stupid and evil anyways.
22:20:27 <dmwit> > let (+-) = (-) in map (+-1) [1..10]
22:20:28 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
22:20:29 <ivanm> also, physics got it wrong when it said that electricity was the flow of positive charges...
22:20:32 <Berengal> roconnor: Who needs numbers when you've got lambdas?
22:20:34 <outchanter> > map (-1+) [1..10]
22:20:35 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
22:20:57 <dmwit> outchanter: Mine is more ridiculous. ;-)
22:21:12 <inimino> lambdas can be used to implement numerals, they'll have to go too.
22:21:34 <roconnor> Berengal: more that programing is mainly about manipulating other structures, like lists and such.
22:21:56 <Berengal> inimino: Let's replace them with lambadas!
22:22:29 <inimino> actually defining a language where constants are not allowed, and have to provided as a table at runtime would be pretty interesting
22:23:09 <Berengal> inimino: Implicit top-level reader monad?
22:23:12 <dolio> Lambda expressions are constants (so to speak).
22:23:31 <inimino> Berengal: heh, something like that
22:23:33 <dolio> As much as numerals.
22:23:55 <Berengal> dolio: A only if it doesn't contain bound variables, no?
22:23:59 <inimino> maybe with names though
22:24:12 <dolio> Well, yes. 'Literal' is probably a better word.
22:24:27 <dmwit> inimino: I don't think there's anything particularly interesting in going down that path.  Everything sort of "just works."
22:24:32 <copumpkin> boo, of course it isn't as simple as it should be
22:24:57 <inimino> dolio: yes, but I meant specifically numbers and strings
22:25:06 <dmwit> inimino: It's actually the model that many languages use... including Haskell, if you think of the Prelude as that top-level lookup table (with names ;-).
22:25:09 <inimino> dmwit: yeah, it just works
22:25:41 <Berengal> dmwit: Number literals aren't defined in the Prelude, are they?
22:25:52 <dmwit> No, I suppose not.
22:25:57 <inimino> dmwit: but if you think about things like localization its just a slightly different perspective
22:26:06 <dolio> GHC actually gives names to various literals you might have in your code.
22:26:15 <roconnor> Berengal: for example consider my original code:
22:26:17 <roconnor> [ map fst y i <- [0..], y <- replicateM i menu, sum (map snd y) == 1505 ]
22:26:21 <inimino> the Prelude actually isn't passed in at runtime, so it's not quite like that
22:26:31 <dolio> If you have something like "foo = bar 0" it might translate that into "z = 0 ; foo = bar z".
22:26:37 <roconnor> Much better written as:
22:26:39 <roconnor> [ map fst y | y <- concat (iterate (liftM2 (:) menu) [[]]), sum (map snd y) == 1505]
22:26:46 <roconnor> And the numbers are gone!
22:26:59 <roconnor> except for sum and 1505
22:27:07 <roconnor> but those are still dumb.
22:27:12 <dmwit> menu?
22:27:15 <dmwit> oh
22:27:34 <roconnor> menu :: [(String,Integer)]
22:27:41 * copumpkin hopes he made all the necessary changes and that the new build system has its dependencies right :P
22:27:58 <Berengal> Ah, xkcd'
22:28:11 <roconnor> http://www.haskell.org/pipermail/haskell-cafe/2007-July/028262.html
22:28:19 <roconnor> ``Shouldn't we stay away from integer indices on lists?''
22:28:36 <roconnor> Henning is absolutely right.
22:28:50 <roconnor> Integers have corrupted my programming style.
22:28:57 <inimino> against "!!"?
22:28:58 <copumpkin> Integers are awesome
22:29:29 <copumpkin> lol, segfault in ghc build
22:29:33 <dolio> dons' code doesn't use integer indices on lists.
22:29:35 <ivanm> heh
22:29:51 <roconnor> copumpkin: Integers are not lazy, and they are always leaving large piles of unevaluted thunks laying around.
22:29:58 <ManateeLazyCat> How to element of list with given `index`?
22:30:14 <copumpkin> roconnor: unevaluated thunks? why?
22:30:31 <ivanm> roconnor: but if it used Ints it would be OK?
22:30:33 <roconnor> ManateeLazyCat: your question suggests you are looking at your problem wrong. :)
22:30:43 <roconnor> ivanm: Ints are even worse
22:30:47 <ivanm> :o
22:30:55 <roconnor> @src length
22:30:56 <lambdabot> Source not found. That's something I cannot allow to happen.
22:30:58 * copumpkin sighs and makes GHC from scratch
22:31:00 <ivanm> I thought Int# was the non-lazy one...
22:31:09 <roconnor> huh?
22:31:16 <roconnor> @src head
22:31:16 <lambdabot> head (x:_) = x
22:31:16 <lambdabot> head []    = undefined
22:31:22 <roconnor> @src length
22:31:22 <lambdabot> Source not found. You type like i drive.
22:31:33 <Berengal> @src genericLength
22:31:33 <lambdabot> genericLength []    = 0
22:31:33 <lambdabot> genericLength (_:l) = 1 + genericLength l
22:31:44 <Berengal> length = genericLength + MR
22:31:46 <copumpkin> you mean lazy in the (length [0..]) > 3 == True ?
22:31:53 <roconnor> copumpkin: ^^ example of thunks laying around.
22:31:54 <copumpkin> genericLength I meant
22:32:01 <copumpkin> hmm
22:32:16 <ivanm> roconnor: because it isn't forced you mean?
22:32:27 <copumpkin> @src length
22:32:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:32:32 <roconnor> ivanm: or because they are not lazy
22:32:34 <ManateeLazyCat> roconnor: I can use `drop` and `head` get element value, but i find exist function do this work.
22:32:41 <Berengal> or length = foldl (const . (+1)) 0
22:32:42 <copumpkin> roconnor: how does Int do better?
22:32:47 <roconnor> > (length [0..]) > (3::Nat)
22:32:48 <copumpkin> foldl' would be better?
22:32:48 <lambdabot>   Not in scope: type constructor or class `Nat'
22:32:52 <roconnor> > (length [0..]) > (3::Natural)
22:32:53 <lambdabot>   Couldn't match expected type `Int' against inferred type `Natural'
22:32:56 <ivanm> copumpkin: he said they weren't...
22:33:01 <roconnor> > (genericLength [0..]) > (3::Natural)
22:33:01 <dmwit> ManateeLazyCat: (!!) will do it, but you should really think hard before you use it
22:33:02 <lambdabot>   True
22:33:08 <roconnor> see, much better
22:33:11 <copumpkin> yeah :)
22:33:12 <copumpkin> but much slower
22:33:15 <dmwit> ManateeLazyCat: Using (!!) is a code smell.
22:33:26 <copumpkin> for most finite situations :P
22:33:35 <roconnor> copumpkin: Haskell has no time for your operational semantics nonsense.
22:33:39 <copumpkin> lol
22:33:47 <copumpkin> and integers will have fast modular exponentiation soon!
22:33:51 <dmwit> > zip [0..] [0..2] == [0..3] -- equivalent
22:33:52 <lambdabot>       No instance for (Enum (t, t1))
22:33:52 <lambdabot>        arising from the arithmetic seque...
22:34:06 <dmwit> > zipWith const [0..3] [0..] == [0..3] -- equivalent
22:34:07 <lambdabot>   True
22:34:17 <ManateeLazyCat> dmwit: Thanks, (!!) is i want.
22:34:24 <copumpkin> ManateeLazyCat: probably not, though
22:34:35 <ManateeLazyCat> copumpkin: ?
22:34:54 <dmwit> ManateeLazyCat: As several of us have said: if you are using (!!), you are probably making a mistake.
22:34:55 <roconnor> ManateeLazyCat: I'm not sure I understood your `drop` and `head` comment.
22:35:11 <Berengal> (!!) = (head.).drop
22:35:40 <roconnor> ManateeLazyCat: oh were you asking a question about finding an index?  I thought you were making a comment about my comments.
22:36:00 <ManateeLazyCat> roconnor: Yep,
22:36:22 <copumpkin> there isn't a modExp for Int in the standard library anywhere is there?
22:36:23 <ManateeLazyCat> dmwit: I think not, i just give index value from list.
22:36:25 <copumpkin> @src Integer
22:36:25 <lambdabot> data Integer = S# Int#
22:36:25 <lambdabot>              | J# Int# ByteArray#
22:36:28 <dmwit> > let minLength n xs = let ys = replicate n () in zipWith const ys xs == ys in minLength 2 [0..]
22:36:30 <lambdabot>   True
22:36:30 <Gracenotes> Berengal: except it's safer
22:36:44 <Berengal> Gracenotes: Safer how?
22:36:57 <Gracenotes> well. I guess the head actually takes care of that
22:37:04 <copumpkin> takes care of making it unsafe? :P
22:37:09 <Gracenotes> quite
22:37:13 <copumpkin> :)
22:37:30 <Gracenotes> but drop is pretty safe, by itself certainly
22:37:35 <roconnor> > [0..]!!(-1)
22:37:36 <lambdabot>   * Exception: Prelude.(!!): negative index
22:37:44 <Gracenotes> sort of a cautious way to check out indexing
22:37:49 <copumpkin> if I had an army of willing haskell codemonkies, I'd get them to get GHC to build with no warnings... it's quite distressing currently
22:37:50 <Gracenotes> oh. hm.
22:37:54 <roconnor> > ((head.).drop)(-1)[0..]
22:37:55 <lambdabot>   0
22:38:01 <roconnor> meh
22:38:03 <roconnor> close enough
22:38:11 <ManateeLazyCat> (!!) not check list length and index before get value
22:38:19 <copumpkin> I should hope not
22:38:20 <roconnor> drop (-1) should probably fail anyways.
22:38:33 <Gracenotes> or get the last element of the list :P
22:38:38 <roconnor> oh god
22:38:39 <dmwit> roconnor: No, it should add an element to the list!
22:38:40 <copumpkin> ooh, ruby style
22:38:59 <roconnor> drop (-1) [0..] == [(-1)..]
22:38:59 <dmwit> drop (-2) [0..] = [-2..]
22:39:02 <dmwit> yep
22:39:12 <ManateeLazyCat> Have a function that type is "[a] -> Int -> Maybe a"?
22:39:22 <roconnor> @hoogle [a] -> Int -> Maybe a
22:39:22 <lambdabot> Prelude (!!) :: [a] -> Int -> a
22:39:23 <lambdabot> Data.List (!!) :: [a] -> Int -> a
22:39:23 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
22:39:26 <Gracenotes> it would probably be made of drop, though
22:39:26 <dmwit> :t \n -> take 1 . drop n
22:39:28 <lambdabot> forall a. Int -> [a] -> [a]
22:39:35 <copumpkin> you'd want a listToMaybe
22:39:39 <dmwit> :t \n -> listToMaybe . drop n
22:39:41 <lambdabot> forall a. Int -> [a] -> Maybe a
22:39:53 <roconnor> @hoogle+
22:39:53 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
22:39:53 <lambdabot> Prelude const :: a -> b -> a
22:39:53 <lambdabot> Data.Function const :: a -> b -> a
22:39:54 <Gracenotes> even simple: case drop n xs of { [] -> Nothing; (x:_) -> Just x }
22:40:04 <roconnor> hmm
22:40:08 <roconnor> I guess there isn't one
22:40:12 <dmwit> Gracenotes: Boo, use the existing listToMaybe for that.
22:40:34 <Gracenotes> and import a module??? ARE YOU CRAZY? Nobody imports modules!!
22:40:54 * dmwit usually has 15-20 lines in his boilerplate {{{ }}} section
22:41:13 <dmwit> Sometimes as much as a third of my program! O_o
22:41:17 <roconnor> ManateeLazyCat: ``stay away from integer indices on lists
22:41:28 <Berengal> Actually, I've been finding it kind of freaky that the import declarations in haskell aren't too far off from enterprise java...
22:41:40 <Gracenotes> although again, the above doesn't make much sense for negative indices
22:42:03 <Gracenotes> quizas, quizas, quizas
22:42:18 <dmwit> mInd n xs | n < 0 = Nothing | otherwise = listToMaybe . drop n $ xs
22:42:36 <jeffwheeler> Berengal: it's the cases where there's repeated imports, one qualified, and one unqualified but restricted to only certain identifiers, that makes me worry about the import design
22:42:43 <copumpkin> Return non-zero if op is a perfect power, i.e., if there exist integers a and b, with b>1, such that op equals a raised to the power b.
22:42:53 <dmwit> fRacturedmInd n xs | even n = n `div` 2 | otherwise = 3 * n + 1
22:43:06 <roconnor> jeffwheeler: I do that a quite a bit
22:43:08 <Gracenotes> c-c-c-c-collatz breaker
22:43:26 <jeffwheeler> roconnor: yeah, it seems very strange to me
22:43:42 <roconnor> I like my operators unqualified.
22:43:45 <ManateeLazyCat> roconnor: In factr, i want find some element form `Data.Set`, so i use `toList` transform `Set` to `List`, then find index.
22:43:57 <dmwit> eh?
22:44:12 <dmwit> :t Data.Set.member
22:44:13 <lambdabot> forall a. (Ord a) => a -> S.Set a -> Bool
22:44:15 <jeffwheeler> Also commonly used, stuff from Data.List and similar is often re-exported.
22:44:53 <roconnor> jeffwheeler: oh?
22:44:56 <dmwit> :t (filter .) . Data.Set.toList
22:44:58 <Berengal> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ const 0:const 1:[(+1).(!!(if even n then div n 2 else n*3+1)) | n <- [2..]]
22:45:02 <lambdabot>     Couldn't match expected type `a1 -> a -> Bool'
22:45:04 <lambdabot>            against inferred type `[a2]'
22:45:06 <lambdabot>     Probable cause: `S.toList' is applied to too many arguments
22:45:08 <lambdabot>   [0,1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,1...
22:45:15 <jeffwheeler> Is it just me, or does the linking stage take up a _lot_ of memory, compared to the rest of the compilation process?
22:45:15 <dmwit> :t \f -> filter f . Data.Set.toList
22:45:16 <lambdabot> forall a. (a -> Bool) -> S.Set a -> [a]
22:45:36 <copumpkin> @pl \f -> filter f . Data.Set.toList
22:45:36 <lambdabot> (. Data.Set.toList) . filter
22:45:39 <jeffwheeler> I can usually tell when a compilation gets to linking, because my system slows down and my music pauses a few times.
22:45:51 <jeffwheeler> (Granted, I'm on a fairly old P4, but still . . .)
22:46:19 <copumpkin> jeffwheeler: yeah, it takes a lot of memory
22:46:26 <copumpkin> it's not just ghc
22:55:07 <mhaggag> Hello, a hopefully quick question: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2470#a2470
22:55:17 <mhaggag> This is from CH05 in "Real World Haskell"
22:55:42 <mhaggag> So far I like adding my function types as a form of documentation, and to help myself learn faster as well
22:56:10 <mhaggag> If you scroll down to the getobject/getArray functions, I first wrote down their types as returning "Maybe JObject/JArray"
22:56:21 <copumpkin> I wonder how that http://hackage.haskell.org/trac/ghc/wiki/AddingNewPrimitiveOperations page worked, as there's definitely something missing from it
22:56:22 <mhaggag> Which the compiler complained about, since neither JObject nor JArray is a type constructor
22:56:29 <copumpkin> unless something has changed since it was written
22:56:33 <dmwit> mhaggag: Yep, this trips up new people all the time.
22:56:38 <Lemmih> mhaggag: JObject and JArray aren't types. They're like True and False.
22:56:52 <mhaggag> Right, they're value constructors. So my question is:
22:56:56 <dmwit> mhaggag: There are two namespaces here: *type* constructors (like JValue) and *value* constructors (like JObject and JArray).
22:57:14 <dmwit> Oh, you knew that bit. =)
22:57:35 <mhaggag> Is there away to avoid duplicating the parameters of the value constructors when writing down the function type?
22:57:44 <mhaggag> Say I later change the way a JObject is stored
22:57:51 <mhaggag> I don't want to have to change the function types to follow suit
22:58:06 <dmwit> I'm afraid you'll have to.
22:58:10 <Lemmih> mhaggag: You could use type synonyms.
22:58:11 <dmwit> However, you can declare a new name for a type.
22:58:26 <dmwit> Then use that name everywhere; then you only have to change it one place.
22:58:28 <dmwit> So:
22:58:36 <dmwit> type JObjectType = [(String, Value)]
22:58:51 <Lemmih> type JArray = [JValue]; data JValue = ... | JArray JArray
22:59:04 <dmwit> then data JValue = ... | JObject JObjectType | ... and getObject :: JValue -> Maybe JObjectType
22:59:38 <dmwit> (Of course you can  just call it "JObjectType", too, I just named it that way to help disambiguate the two.)
22:59:51 * copumpkin really looks forward to having a GHC on the iphone
22:59:52 <dmwit> err... can just call "JObjectType" as "JObject", I mean
23:00:50 <mhaggag> Hold on...you're saying I can define it as: "type JObject = [(String, Value)]" and that wouldn't clash with the value constructor JObject, because it's a value constructor, not a type constructor. right?
23:01:40 <dmwit> Right!
23:01:50 <Berengal> Right. Type names and constructors live in two different namespaces
23:01:53 <copumpkin> dolio: compile is done :)
23:02:01 <dolio> Nice.
23:02:03 <mhaggag> Awesomesauce. I just tried, and it does work. Thanks a lot! :)
23:02:22 <copumpkin> dolio: know of a way to run ghci from the source tree without making a bindist?
23:02:37 <dolio> Not really sure.
23:05:25 <Lemmih> copumpkin: './srcpath/ghc --interactive' doesn't work?
23:05:46 <copumpkin> Lemmih: I don't know where the final ghc gets put
23:05:51 <copumpkin> but I'll see if I can find it
23:09:45 <copumpkin> I can do inplace/ghc-stage2 --interactive
23:09:50 <copumpkin> is that equivalent?
23:10:01 <Lemmih> Yes, I think so.
23:12:20 <ManateeLazyCat> dmwit: I use `Data.Set.findMin` and `Data.Set.filter` solve my problem, and function "mInd n xs | n < 0 = Nothing | otherwise = listToMaybe . drop n $ xs" is safer function, thanks!
23:12:38 <copumpkin> :o
23:14:20 <dancor_> i was using hdbc-postgresql, but i want to be able to get the value of an auto-incrementing column as i do an insert.  what should i do?
23:22:37 <copumpkin> I wish GHC already had a nice way to do natural-parametrized types (without the ugly type-level integer things)
23:22:52 <copumpkin> I could then make a really nice interface to the gmp arbitrary precision floats
23:26:36 <copumpkin> dolio: bah, the build system doesn't like me :/
23:27:18 <copumpkin> I built the whole thing and it worked, but I forgot to add my new function to the export list of GHC.Integer, so I added it
23:27:32 <copumpkin> and now I get epic linker errors from a whole bunch of unrelated things
23:28:10 * copumpkin sighs and runs make clean... again
23:33:08 <dancor_> oh i can just make use of postgres's currval('my_seq') looks like
23:40:48 <Gilly> dancor_: "INSERT ... RETURNING id" worked for me but I'm using Takusen
23:41:33 <chadnickbok> Hi
23:42:02 <dancor_> Gilly: ah thanks.  maybe i'll try Takusen
23:44:53 <Gilly> dancor_: I used doQuery when doing the insert so I could get the return value. Seemed to work.
23:51:49 <copumpkin> aha, the final word on the Z-encoding: http://darcs.haskell.org/ghc/compiler/utils/Encoding.hs
23:59:41 <Neut> Can I get some help with the recursion in the courPoints function?
23:59:43 <Neut> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2471#a2471
