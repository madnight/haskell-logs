00:01:08 <tiglionabbit_> so, because two users playing the same game would not likely have access to the same game in memory...  perhaps it is not a good idea to keep the games in memory
00:05:02 <solidsnack> tiglionabbit_: I don't see how the database makes any difference.
00:05:28 <solidsnack> tiglionabbit_: Presumably, it stores the log of moves; but you'd still want a game tree somewhere.
00:06:15 <tiglionabbit_> solidsnack: I know, but do you store this game in memory indefinitely, in case a player comes back to some long-forgotten game?  Some time you might have to reconstruct a game from the database
00:07:09 <solidsnack> tiglionabbit_: Well, it's easy to do that, right? You just init a fresh session and walk all the way back down the game tree.
00:07:27 <tiglionabbit_> I guess so
00:08:01 <solidsnack> You can reasonably segregate, I think, the log and the "lookahead cache".
00:08:38 <solidsnack> The latter has no durability requirement (in part because it is a constant).
00:11:14 <tiglionabbit_> I guess it's a form of caching that I'd keep this game object around waiting for the player to come back, but...
00:11:25 <tiglionabbit_> can I use the same game object for multiple players?
00:11:43 <tiglionabbit_> er, same instance
00:11:53 <tiglionabbit_> thingy
00:12:02 <tiglionabbit_> value, I guess?
00:12:21 <vixey> yeah not really  objects/instances  in haskell
00:12:31 <solidsnack> tiglionabbit_: Well, it would stand to reason that you can -- however I fear you have a lot of intermediate nodes you want to throw away.
00:13:04 <tiglionabbit_> yeah but two players on the same game would see the same pruned version of it
00:13:04 <solidsnack> Say you had a top level binding that was all the Fibonacci numbers, for example.
00:13:12 <tiglionabbit_> I mean if they were playing this game together
00:13:36 <Saizan> well for players playing together i think you should use the same tree
00:13:36 <solidsnack> tiglionabbit_: Well, then you maybe have two -- white side and black side?
00:14:07 <tiglionabbit_> sure
00:14:16 <Saizan> tiglionabbit_: i think you should try implementing the actual structure to get a more concrete idea of what it looks like
00:14:49 <Saizan> tiglionabbit_: there's an example for tic-tac-toe in the "Why FP Matters" paper
00:14:55 <Saizan> ?where whyfp
00:14:55 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
00:16:06 <tiglionabbit_> what's a good way to implement the structure?  Imagine a game on a 2D board like chess.  Should game state be a list of pieces with locations, or spaces with pieces on them?  And I guess the child game states of this would be a list of game states representing every possible move for the current player...
00:16:34 <tiglionabbit_> oh thanks *reads*
00:16:58 <quicksilver> I would use a map from locations to pieces
00:17:12 <quicksilver> with the convention that, by implication, if a key doesn't appear in the map, that location is empty
00:18:25 <tiglionabbit_> it's a 2d board though, so locations are what, tuples like (1,5), chess space names like "B4", or is the 2D-ness represented some other way
00:18:38 <quicksilver> that was my suggest, yes
00:18:43 <quicksilver> Map (Int,Int) Piece
00:19:42 <tiglionabbit_> okay
00:20:39 <tiglionabbit_> heh, I just implemented the game of life in javascript using a map to represent 2d locations.  Javascript hashes [1,2] as "1,2"
00:21:01 <tiglionabbit_> http://nickretallack.com/lifegame/
00:21:02 <horms> *win*
00:21:02 <solidsnack> scary
00:21:49 <tiglionabbit_> yeah it was a little bothersome that my keys didn't preserve their types.  I just wrote an "unhash_point" function though, that splits it up again =]
00:28:45 <solidsnack> I've written a fair amount of JavaScript in the past couple of months; I liked it as first (handling the DOM and such) but whenever I have process text I fall back to hating it.
00:29:05 <solidsnack> Making and managing intermediate structures is such a hassle in dynamic languages.
00:30:57 <quicksilver> yes
00:31:05 <quicksilver> for all structures except Map String String
00:31:11 <quicksilver> so one just uses that for everything
00:31:14 <quicksilver> and suffers.
00:31:50 <solidsnack> As I am now :)
00:31:52 <solidsnack> :/
00:31:57 <solidsnack> :;
00:32:04 <solidsnack> er
00:32:08 <solidsnack> ;_;
00:32:56 <quicksilver> (incidentally, one probably shouldn't call javascript objects 'hashes')
00:36:31 <solidsnack> I mean, who writes a language with join but not map?
00:36:41 <solidsnack> What was the thinking that went on here?
00:36:48 <vixey> what
00:36:55 <solidsnack> JavaScript
00:37:39 <quicksilver> yeah, the absence of map in javascript is pretty weird.
00:37:49 <quicksilver> jquery ftw.
00:37:54 <solidsnack> yeah
00:38:08 <Raevel> js 1.6 has map!
00:38:21 <solidsnack> Raevel: Yes, but you can't use it in practice.
00:38:45 <solidsnack> If I was going to write for a custom platform, I sure as heck wouldn't use JavaScript :)
00:39:07 <Raevel> Array.prototype.map = ...
00:39:48 <quicksilver> javascript's sufficiently malleable that you can cope with it.
00:40:19 <quicksilver> any language with overridable prototypes and reasonable syntax for structured literals is bearable.
00:40:35 <quicksilver> that's what I really hate about C / C++ - lack of structured literals.
00:40:46 <solidsnack> Structured literals?
00:40:55 <solidsnack> Oh, like arrays of arrays and such.
00:41:01 <solidsnack> Yeah, that's pretty insane.
00:42:20 <rieux_> the right people on the committee have their way, the next javascript could be pretty nice.  they have some functional programmers who understand types, too.
00:42:25 <luqui> heh... haskell doesn't have anything but structured literals :-)
00:42:32 <rieux_> if
00:42:49 <solidsnack> rieux_: I believe the next JavaScript was killed.
00:42:58 <solidsnack> MSFT pulled out of the committee.
00:43:01 <luqui> solidsnack, what do you mean by "join" in "join but not map"
00:43:05 <luqui> concat?
00:43:20 <solidsnack> ["a", "b"].join(" : ")
00:43:27 <luqui> oh intercalate...
00:43:34 <rieux_> solidsnack: really?  i remember back in september they were talking about something like that, but i didnt believe it would happen
00:43:36 <solidsnack> yeah
00:43:38 <luqui> (i like join as a name for that)
00:44:20 <solidsnack> luqui: Haskell has certainly changed my sensibilities about how things should be named :)
00:44:41 <luqui> > let (.) = flip ($) in ["a", "b"].intercalate(" : ")
00:44:43 <lambdabot>   "a : b"
00:45:03 <solidsnack> oh good lord
00:45:07 <luqui> ;-)
00:45:26 <luqui> perl programmers aren't the only ones who get to play tricks on our eyes
00:45:35 <luqui> though.. they're the only ones who want to
00:46:21 <solidsnack> luqui: I fear that accommodations like that would only delay the OMGWTFBBQ moment for new Haskell programmers.
00:47:06 <luqui> yeah, not to mention attracting countless inane questions on our mailing lists
00:47:43 <solidsnack> I do remember a mailing list post where some guy had figured that out and was trying to get everyone to switch.
00:47:45 <luqui> As different as haskell is, you'd think we'd get more "why can't I" questions than we already do...
00:47:58 <opqdonut> indeed
00:47:58 <solidsnack> hash tables have shown up a lot
00:48:06 <Cale> Plus it takes that away from function composition which is by far the most important infix operator.
00:48:27 <luqui> if i had a unicode keyboard then we could reclaim dot
00:48:28 <luqui> for... something
00:48:39 <luqui> i'd probably put it after the lambda instead of ->
00:48:44 <luqui> but.. that's just e
00:48:45 <luqui> me
00:48:47 <Cale> Only if it had a whole key for it...
00:49:10 <luqui> maybe we should go the way of the concatenative folks and make composition juxtaposition
00:49:19 <Cale> I can type в€ but it's a few annoying keystrokes :)
00:49:28 <luqui> i only know the vim digraph...
00:49:36 <luqui> so i open vim, type it, copy, and paste :-)
00:50:56 <luqui> I'm having a lot of trouble imagining what application would look like if juxtaposition were composition
00:51:05 <luqui> probably a category theorist would be able to tell me
00:51:27 <quicksilver> f g h @ 1
00:51:28 <quicksilver> ?
00:51:41 <luqui> that would be f . g . h . (@) . 1
00:51:49 <luqui> and i don't know if such an @ exists
00:52:24 <luqui> (at least, that's what it would mean as related to the question i'm asking)
00:52:56 <quicksilver> well I think you can have juxtaposition as composition and still have binary operators
00:52:59 <quicksilver> if you choose to.
00:53:10 <luqui> yeah true
00:53:52 <quicksilver> if the only thing you have is composition, then everything is a function.
00:53:52 <luqui> so I have f : a -> (b -> c),   x : (1 -> a),  how do I get g : (b -> c) ?
00:54:02 <quicksilver> so you'd need to represent literals as functions
00:54:07 <quicksilver> constant functions, perhaps.
00:54:17 <luqui> functions from unit
00:54:22 <Cale> luqui: well, you could make application into composition as well
00:54:41 <luqui> Cale, yes, that's probably what i'm asking.  what do you mean by that?
00:55:24 <Cale> ah, yeah, you do need the exponential unlifting which is inconvenient
00:55:38 <rieux_> i'm trying to think how APL does it
00:56:04 <Cale> That is, a way to take an element of (b -> c), which is 1 -> (b -> c), and turn it into a function b -> c
00:56:05 <rieux_> but it doesn't seem to translate
00:57:19 <luqui> 1 -> (b -> c)   =uncurry=>   (1,b) -> c   =(. snd)=>   b->c
00:57:36 <Cale> It's possible that it wouldn't be too much of a pain if we had a suitably comfortable name for (1 -> (a -> b)) -> a -> b
00:57:39 <luqui> but uncurry is still a functor that needs to be *applied*, no?
00:57:50 <Cale> Let's call it @
00:57:54 <luqui> lol
00:58:20 <Cale> (or it could be new $ ;)
00:58:40 <luqui> so from above, it would be:  @ f x   ?
00:58:42 <yitz> what's wrong with the constant function, like quicksilver said?
00:59:15 <Cale> You represent literals as functions from 1
00:59:27 <dmwit> yitz: You get out another constant function. =/
00:59:34 <dmwit> yitz: When what you really want is the actual function.
00:59:52 <Cale> But there's the problem of turning a function 1 -> (a -> b) into a proper function a -> b
01:00:13 <dmwit> yitz: i.e. f : a -> b -> c, x : 1 -> a; then f x : 1 -> b -> c instead of f x : b -> c like you want.
01:00:16 <heltav> anyone compiled gsl? it ran the whole night for me then finally hang up and never finished
01:00:39 <heltav> unless the solve quadratic takes hours and hours to compile
01:00:41 <luqui> you would need a name for that though, because we want a CCC
01:00:50 <Cale> In category theory notation, this is associating an element of B^A (which is an arrow 1 -> B^A) with an arrow A -> B
01:00:52 <solidsnack> heltav: Compile on what?
01:01:47 <luqui> how do you get back?
01:01:55 <luqui> from (a -> b)  to 1 -> (a -> b) ?
01:01:57 <Cale> There's that too
01:02:04 <luqui> that seems harder
01:02:05 <rieux_> are we limited to changing syntax?  why not just allow the two types to unify?  they're isomorphic already (in haskell)
01:02:06 <Cale> You'd need both directions, I suppose
01:02:16 <Cale> But const does that currently
01:02:20 <luqui> because if you compose, you only have the a or the b to work with
01:02:30 <luqui> yeah, but as an *application*, not as a composition
01:02:48 <luqui> ohoh but we could use our new @ operator :-)
01:02:57 <Cale> rieux_: I wonder... however, the interactions with that and type inference will be interesting.
01:03:08 <rieux_> Cale: yeah, i'm not sure where it breaks
01:03:13 <ziman> :t (. const id)
01:03:14 <lambdabot> forall c a a1. ((a -> a) -> c) -> a1 -> c
01:03:37 <luqui> :t (. const)
01:03:38 <lambdabot> forall c a b. ((b -> a) -> c) -> a -> c
01:03:51 <luqui> this is hard on my brain
01:03:53 <ziman> hm, this is not wha i wanted...
01:04:05 <rieux_> Cale: well i supppose if you try to unify (a -> b) with c, you don't know whether you should let a be 1 and unify b with c or not
01:04:09 <rieux_> ick
01:04:16 <yitz> dmwit?
01:05:28 <dmwit> er, yes?
01:06:04 <luqui> i'm stumped.  what do you compose with a -> b to get to 1 -> (a -> b)
01:06:09 <luqui> is that even possible?
01:06:23 <solidsnack> Would it be compose?
01:06:30 <solidsnack> Wouldn't you wrap it?
01:06:32 <luqui> it would have to be, that's all we have
01:06:37 <solidsnack> Oh, right.
01:06:43 <yitz> dmwit: -> #xmonad
01:07:10 <quicksilver> luqui: well, if you precompose you get something ->b , and if you postcompose something a ->
01:07:26 <luqui> yeah it would have to be both sides, if it exists
01:07:40 <quicksilver> I don't think it does
01:07:54 <luqui> i mean, that makes sense, because composition has less structure than application
01:07:59 <rieux_> before: 1 -> a.  after: b -> (a -> b)
01:08:00 <luqui> so you'd need to encode it somehow
01:08:03 <luqui> but you're probably right
01:08:05 <rieux_> highly magical
01:08:23 <quicksilver> 1 -> a requires choosing an elemetn of a
01:08:27 <quicksilver> that seems unlikely.
01:08:40 <ziman> but you ave f :: a
01:08:51 <ziman> the `f' is what you may choose
01:08:56 <rieux_> that's why it's magical
01:09:23 <RayNbow> :t undefined -- ?
01:09:24 <lambdabot> forall a. a
01:09:26 <luqui> oh it's a pair
01:09:27 <luqui> i see
01:09:40 <luqui> that's no good, they are working together...
01:09:42 <luqui> :-(
01:09:50 <luqui> and... you're right, they would have to
01:10:06 <luqui> there would be a different pair of morphisms for every f
01:10:25 <rieux_> you can do it in an impure language with call/cc
01:11:05 <luqui> (a -> b) -> b   ~~ 1 -a
01:11:07 <luqui> oops
01:12:10 <rieux_> though you have to allocate a cell every time you want a before/fater pair
01:14:27 <heltav> is caml not used anymore?
01:14:47 <quicksilver> sure.
01:14:50 <quicksilver> it's widely used.
01:18:12 <solidsnack> What is meant by "composition has less structure than application" ?
01:18:53 <solidsnack> Oh, heck; luqui left.
01:19:33 <solidsnack> @tell luqui  What does it mean that "composition has less structure than application" ?
01:19:33 <lambdabot> Consider it noted.
01:21:09 <dolio> I don't know, but you have to be careful when comparing haskell types to category theory types.
01:21:27 <dolio> Like, in "1 -> (a -> b)", the two arrows are different.
01:23:07 <dolio> If you're working with application-is-composition, you represent values of a type T as arrows 1 -> T.
01:23:30 <vixey> sure elements 1 -> T generalized elements X -> T
01:24:07 <dolio> Then if you have an arrow f : T -> U, and x : 1 -> T, then f x : 1 -> U is an element of U.
01:24:20 <dolio> Where juxtaposition means composition.
01:25:05 <dolio> But, if you want higher order functions, it doesn't make sense to talk about applying a function to the above function f.
01:25:35 <dolio> You need some way to denote the corresponding element of the exponential object: f' : 1 -> U^T, or some such.
01:26:01 <heltav> quick I meant is ocaml used instead?
01:26:02 <dolio> Then you can write g f' : V, where g : U^T -> V.
01:26:33 <dolio> Yeah, I don't think there's much use of the predecessors of OCaml.
01:26:41 <dolio> If there is, I'm not aware of it.
01:27:39 <dolio> Oh, aside from ML and suchlike.
01:27:56 <ski> (itym SML)
01:27:58 <dolio> Previous Caml stuff.
01:28:25 <dolio> Lisp is still in use, too. :)
01:28:30 <ziman> you'd need a way to convert functions (T -> U) <-> (1 -> U^T), too, wouldn't you?
01:28:57 <ski> dolio : 1.5 ? :)
01:30:54 <quicksilver> heltav: ocaml is caml.
01:30:54 <dolio> ziman: Yeah, in essence you'd need some separate-from-composition method of going between functions as arrows and functions as elements of an exponential object.
01:31:07 <quicksilver> heltav: ocaml is an implementation of caml - the most popular one by far.
01:31:34 <dolio> You could say if f : (1x)T -> U, then curry_f : 1 -> U^T.
01:32:22 <ziman> currying cannot be accomplished using composition, can it?
01:33:32 <dolio> Well, you can have a related curry arrow, curry : C^(AxB) -> (C^B)^A.
01:34:06 <dolio> And then curry_curry : 1 -> (C^B^A)^(C^(AxB))...
01:35:20 <dolio> But in category theory, things like curry_f are defined using existence/uniqueness properties in diagrams involving f.
01:35:32 <dolio> So they don't have to do with composing arrows per se.
01:38:51 <dolio> Maybe you could try saying that whether 'f' means an arrow or the corresonding element of an exponential object depends on context, but that seems like it'd be too tricky.
01:41:08 <dolio> Or work just with exponential objects in conjunction with an arrow apply : (B^A x A) -> B.
01:42:59 <dolio> Then f applied to x looks like: apply <f, x>, where g : A -> B, h : A -> C means <g, h> : A -> B x C.
01:44:44 <dolio> Then f : 1 -> B^A, x : 1 -> A, so <f, x> : 1 -> (B^A x A), and apply <f, x> : 1 -> B. But then you're probably better off writing "apply <f, x>" as "f x", and you're back at juxtaposition as application.
01:53:59 <mux> dons: hey
01:58:51 <fasta> When I run a test using a.o. monadicIO (from QuickCheck-2) in ghci it is working as it should, but when I run the same program in compiled state, it just seems to hang (without using CPU). Does this behavior ring any bells?
02:04:09 <scriptdevil> Tackling the Awkward Squad is seriously one of the best reads :D
02:04:10 <scriptdevil> I finally started understanding what being functional actually means...
02:04:10 <scriptdevil> (Purely)
02:04:11 <quicksilver> fasta: threaded RTS required?
02:04:11 <fasta> quicksilver: yes, maybe. But I don't know, I do know that it is horrible that interpretation semantics != compilation semantics.
02:11:31 <quicksilver> fasta: well it would be interesting to know if it is -threaded or not.
02:11:41 <quicksilver> fasta: it is no surprised that -threaded has different semantics.
02:11:49 <quicksilver> if it's something else - well, maybe it's a bug.
02:12:25 <fasta> quicksilver: yes, it was. It was my first thought too, but since unsafePerformIO is used in monadicIO I thought it might be something else, like an inline bug in quickCheck.
02:13:24 <fasta> quicksilver: why is there a threaded and a non-threaded RTS? Better performance for non-threaded applications?
02:14:09 <Botje> no scheduler for non-threaded RTS
02:14:24 <Botje> so single-threaded apps don't need to be interrupted by the scheduler
02:14:58 <fasta> Then I think the threaded RTS should be the default, since it is something which at least always works. People who care for performance should use the short term hack.
02:15:04 <quicksilver> fasta: initially, conservatism, I think, keeping the old non-threaded RTS when the threaded one was new.
02:15:11 <quicksilver> I would support -threaded being default.
02:15:47 <Botje> wouldn't a single-threaded app still benefit from concurrent GC?
02:16:04 <fasta> Botje: probably program dependent.
02:18:14 <Ferdirand> hello #haskell
02:18:24 <heltav> anyone know the LOC of House? im downloading it now but....
02:18:31 <heltav> hello Ferdirand
02:20:19 <heltav> so to write a kernel in ghc you need to bootstrap right, you compile it in a standard OS then boot of the binary?
02:22:48 <Ferdirand> does it make sense to define: data (Monad m1, Monad m2) => DM m1 m2 a = DM (m1 a, m2 a)
02:23:09 <Ferdirand> and instance (Monad m1, Monad m2) => Monad (DM m1 m2) ?
02:23:55 <Ferdirand> or does this matches an Arrow definition already ?
02:25:46 <quicksilver> Ferdirand: hmm. I've never wanted that.
02:25:48 <quicksilver> what do you want it for?
02:26:51 <Botje> i don't think you can combine two monads that easilyy
02:26:58 * glguy wonders how bind would be implemented
02:27:08 <Ferdirand> i have an implementation that compiles
02:27:40 <Ferdirand> I have monadic code that can be used in two different monads to give different results
02:28:03 <Ferdirand> for now, these functions use a typeclass whose my two monadic types are also member
02:28:25 <Ferdirand> i wondered if i could get rid of the typeclass by exploiting lazyness with this device
02:29:02 <Ferdirand> i don't even know if it is really a good idea to do so
02:29:27 <glguy> it is much more common to put your operations in a typeclass and write generic functions on those typeclasses
02:29:33 <quicksilver> glguy: pointwise.
02:29:39 <quicksilver> oh
02:29:45 <glguy> like monadstate
02:29:50 <quicksilver> hmm yes
02:29:53 <quicksilver> you're right, bind doesn't work :)
02:30:04 <heltav> so you can't build House on windows?
02:30:11 <glguy> well, he is just binding the two separately
02:30:13 <glguy> and picking one later
02:30:20 <glguy> dragging the unneeded one along for the ride
02:30:51 <Ferdirand> i haven't checked if it obeys the monad laws
02:31:11 <Ferdirand> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4639#a4639
02:31:45 <glguy> using a typeclass for your common operations is a better solution than performing all of the binds you might ever want every time
02:31:56 <Krintus> на форум http://forum.forok.ru требуются admin и модераторы разделов. Все кто заинтересован пишите в личку
02:32:01 --- mode: ChanServ set +o glguy
02:32:03 --- mode: glguy set +b *!*@195.85.238.205
02:32:03 --- mode: ChanServ set +o quicksilver
02:32:05 --- mode: quicksilver set +b *!*n=Krintus@195.85.238.*
02:32:05 --- kick: Krintus was kicked by quicksilver (quicksilver)
02:32:15 <quicksilver> hah. two barrels.
02:32:31 <Ferdirand> well, a few people here tend to bash on typeclass overuse i think :)
02:32:56 <scriptdevil>  /leave
02:32:58 <glguy> Ferdirand, well, in your case you actually have a good case for them
02:33:10 <glguy> Ferdirand, I suspect people are more likely bashing gratuitous use
02:33:22 <quicksilver> it's mainly me that bashes typeclass overuse, in my experience
02:33:30 --- mode: glguy set -o glguy
02:33:34 <quicksilver> however your use case sounds like exactly what they are correctly used for :)
02:33:40 --- mode: quicksilver set -o quicksilver
02:33:46 <Ferdirand> ah, good :)
02:34:05 <Ferdirand> now for the second weird idea i had during sleeping
02:34:41 <Ferdirand> on the well-known problem of restricted monads
02:35:11 <Ferdirand> i was trying to build something like pfp (weighted list monad), but backed by a map instead of a tuple list
02:35:27 <Ferdirand> of course this does not work, as map requires Ord
02:37:57 <Ferdirand> so, is there a way to build a Map k a where k is not in Ord, by providing a function (k -> Ordering) at build time only ?
02:38:12 <glguy> You can always use the rebindable syntax to define your own Monad class
02:38:21 <glguy> one that let's you add the constraints you want
02:38:26 <Ferdirand> right
02:38:28 <quicksilver> Ferdirand: only by creating a newtype
02:38:34 <quicksilver> or a data
02:38:43 <Ferdirand> but then, if i use rebindable
02:38:46 <ski> (hm .. i think Ferdirand's `Dual' reminds somewhat of a monad construction i did ..)
02:38:48 <quicksilver> data Ordered k = Ordered !k (k -> Ordering)
02:39:00 <Ferdirand> i have to give up on applicative notation to compose my monad
02:39:06 <quicksilver> instance Ord (Ordered k) where compare (Ordered k f) = f k
02:39:18 <Ferdirand> so i wanted to avoid using a restricted monad
02:39:35 <quicksilver> that's not entirely right.
02:39:42 <quicksilver> and it's potentialy unsafe, but that's the idea
02:40:25 <Ferdirand> quicksilver: ah, yes, makes sense
02:41:42 <Ferdirand> but <$> and <*> are nice... I don't want to give them up :(
02:48:20 <heltav> applicatives right
02:48:25 <heltav> @type <$>
02:48:26 <lambdabot> parse error on input `<$>'
02:48:30 <heltav> @type <*>
02:48:31 <lambdabot> parse error on input `<*>'
02:48:37 <heltav> is <$> == $ ?
02:48:40 <Ferdirand> no
02:48:44 <Ferdirand> <$> is fmap
02:48:44 <heltav> function applciation?
02:48:47 <mux> @type (<$>)
02:48:48 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:48:53 <heltav> exactly fmap?
02:48:55 <mux> @type (<*>)
02:48:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
02:49:20 <heltav> > <$> (+1) (Just 5)
02:49:21 <lambdabot>   <no location info>: parse error on input `<$>'
02:49:31 <heltav> > (+1) <$> (Just 5)
02:49:32 <lambdabot>   Just 6
02:49:35 <mux> > (+1) <$> Just 5
02:49:37 <lambdabot>   Just 6
02:49:38 <heltav> > (+1) <*> (Just 5)
02:49:39 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
02:49:44 <heltav> > (+) <*> (Just 5)
02:49:45 <Ferdirand> > (*) <$> [1,2] <*> [1,3]
02:49:45 <lambdabot>   Couldn't match expected type `a -> a'
02:49:46 <lambdabot>   [1,3,2,6]
02:49:49 <heltav> > (+) <*> (Just 5) (Just 6)
02:49:50 <lambdabot>   Couldn't match expected type `t -> a -> a'
02:50:09 <Ferdirand> > (+) <$> Just 5 <*> Just 6
02:50:11 <lambdabot>   Just 11
02:50:21 <burp_> why use this instead of fmap? :>
02:50:26 <mux> > Just [+1) <*> Just 3
02:50:27 <lambdabot>   <no location info>: parse error on input `)'
02:50:36 <mux> > Just (+1) <*> Just 3
02:50:38 <lambdabot>   Just 4
02:51:06 <Ferdirand> because it's prettier
02:51:21 <Ferdirand> but the point is that i want my monad to work with partially applied functions
02:51:37 <Ferdirand> so a restricted monad on ord won't cut it
02:51:54 <heltav> i think fmap is cleaner
02:52:03 <heltav> idotn want haskell to look like Perl
02:52:31 <mux> > getZipList $ (\x y z = x + y + z) <$> ZipList [1..3] <*> ZipList [2..5] <*> ZipList [1..]
02:52:32 <lambdabot>   <no location info>: parse error on input `='
02:52:33 <burp_> lol
02:52:34 <burp_> same
02:52:41 * ski . o O ( type Foo m n a = (m a,Either (m a) (n a)) )
02:52:44 <mux> > getZipList $ (\x y z -> x + y + z) <$> ZipList [1..3] <*> ZipList [2..5] <*> ZipList [1..]
02:52:46 <lambdabot>   [4,7,10]
02:55:26 * araujo fighting with compota
02:55:53 <roadwarrior> hm has ghc become more lazy since 6.8? :p
02:56:33 <roadwarrior> something works in 6.8 but not in 6.10 when tryin to do thing lazy
02:57:51 <quicksilver> you may need to give more details, roadwarrior
02:57:54 <quicksilver> what kind of thing
03:02:37 <roadwarrior> well its this snippet of code: http://www.haskell.org/pipermail/haskell-cafe/2009-May/061010.html
03:03:00 <roadwarrior> why has the behavior changed since 6.8 ?
03:04:56 <quicksilver> well, judging by the email thread it looks like a bug.
03:04:58 <fasta> If I set +RTS -N4 -RTS the program hangs. Without any RTS options with a threaded RTS, it does work. Great...
03:05:52 <roadwarrior> :/
03:06:15 <quicksilver> roadwarrior: you are given some incorrect advice in that thread, though
03:06:39 <quicksilver> the strict and lazy variants of ST have identical semantics except where they trip over 'error' values
03:07:10 <quicksilver> if a program runs under strict and doesn't throw an exception, it should run under lazy with the same semantics.
03:07:39 <trez> in 6.8 it doest that, but not in 6.10 :(
03:07:58 <quicksilver> you should file a bug on GHC.
03:09:39 <zcvvc> ghci 6.10.2 after pressing ctrl-c gives segfault. ctrl-d quits normally. Possible causes? I'm running ubuntu 9.04
03:10:26 <yitz> zcvvc: ghc 6.10.3 is now being release just to fix that bug
03:10:41 <yitz> it was introduced only in that version of ghc
03:10:49 <zcvvc> thanks
03:14:42 <roadwarrior> I see, thanks quicksilver
03:23:09 <RayNbow> hmm
03:23:37 <RayNbow> anyone tried installing the Haskell platform in Arch?
03:25:06 <quicksilver> you would imagine that dons has
03:26:35 <RayNbow> on my Arch machine, it cannot find haskell-cabal on AUR :p
03:26:51 <Alpounet> RayNbow, it has worked for dons and some others.
03:31:31 <RayNbow> @seen dons
03:31:31 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 3h 10m 6s ago.
03:48:09 <mreh> with this data type for example: Nats = Zero | Suc Nats, how could I quickly nest constructors to make arbitary size data structures
03:49:04 <mreh> foldl? with a list [1..n]
03:49:24 <Botje> iterate Suc Zero !! n
03:49:36 <mreh> :t !!
03:49:37 <lambdabot> parse error on input `!!'
03:49:41 <RayNbow> :t (!!)
03:49:42 <mornfall> :t (!!)
03:49:43 <lambdabot> forall a. [a] -> Int -> a
03:49:43 <lambdabot> forall a. [a] -> Int -> a
03:50:13 <mreh> mmmmm functional programming
03:51:11 <mreh> @src iterate
03:51:11 <lambdabot> iterate f x =  x : iterate f (f x)
03:52:12 <mreh> iterate Maybe "hello" !! 3
03:52:19 <mreh> > iterate Maybe "Hello" !! 3
03:52:20 <lambdabot>   Not in scope: data constructor `Maybe'
03:52:24 <RayNbow> Just
03:52:29 <mreh> > iterate Just "Hello" !! 3
03:52:30 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
03:52:30 <lambdabot>        Ex...
03:52:54 <heltav> > (Just 5) (+) <*> (Just 3)
03:52:56 <lambdabot>   Couldn't match expected type `t -> f (a -> b)'
03:52:58 <heltav> > (Just 5) (+1) <*> (Just 3)
03:52:59 <lambdabot>   Couldn't match expected type `t -> f (a -> b)'
03:53:01 <RayNbow> the problem is that the type of Just x is different from the type of Just (Just x)
03:53:11 <mreh> yeah
03:53:21 <mreh> ill do it on my own computer :)
03:53:33 <heltav> > (Just +5) <*> (Just 3)
03:53:34 <lambdabot>   Couldn't match expected type `a -> b'
03:53:40 <heltav> > (Just + 5) <*> (Just 3)
03:53:41 <lambdabot>   Couldn't match expected type `a -> b'
03:53:54 <mreh> how does one upload a file to lamdabot?
03:54:00 <heltav> > Just (+ 5) <*> (Just 3)
03:54:02 <lambdabot>   Just 8
03:54:13 <heltav> > Just (+ 5) <$> (Just 3)
03:54:14 <lambdabot>   Couldn't match expected type `a -> b'
03:54:20 <heltav> > (Just 5) <$> (Just 3)
03:54:21 <lambdabot>   Couldn't match expected type `a -> b'
03:54:24 <RayNbow> :t let ntimes n f = foldl (.) id (replicate n f) in ntimes
03:54:25 <heltav> > (+) (Just 5) <$> (Just 3)
03:54:26 <lambdabot> forall a. Int -> (a -> a) -> a -> a
03:54:26 <lambdabot>       No instance for (Num (Maybe t))
03:54:26 <lambdabot>        arising from a use of `+' at <in...
03:54:47 <heltav> > (+5) <$> (Just 3)
03:54:48 <lambdabot>   Just 8
03:54:52 <RayNbow> *Main> ntimes 3 Succ Zero
03:54:52 <RayNbow> Succ (Succ (Succ Zero))
03:55:00 <RayNbow> ^ from a local ghci session
03:56:49 <dabbler> how can i specify my own function for showing lists of lists?
03:57:58 <mux> dabbler: either write a custom function, or use a newtype for your list of lists type and write a Show instance for it
03:59:41 <dabbler> mux: so if i use a newtype, can i still use:  list !! index ?
03:59:46 <mreh> :t foldl
03:59:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:59:59 <mux> dabbler: nope, unfortunately you can't
04:00:34 <mux> thanks to generalized newtype deriving, you can get class instances for free, but since (!!) is a function only operating on [a] types, it won't work for your type
04:00:49 <mux> however, it's just a matter of unwrapping the newtype and then calling (!!) on the list
04:01:06 <mux> which should have 0 performance impact in the generated code
04:01:37 <dabbler> oh, how do you unwrap a newtype?
04:02:31 <mux> by pattern matching on it
04:02:41 <mux> like if you have newtype Foo = Bar Int
04:02:56 <mux> you'd write: f (Bar x) = someotherfunction x
04:03:34 <mux> or, to stick to your case more closely, if you have newtype Foo = Bar [Int]
04:04:00 <mux> you can write myShow (Bar xs) = ...
04:04:07 <mux> and since xs is a list here, you can use (!!) on it
04:04:08 <mreh> You remember what I was doing with Nats = Zero | Suc Nats... I came up with this makeN n = foldr (\a b -> Suc b) Zero [1..n]
04:04:21 <mreh> that's more idiomatic to me
04:04:25 <quicksilver> dabbler: but that's a whole lot of work just to write a different show-like function.
04:04:32 * mux nods at quicksilver 
04:04:33 <quicksilver> dabbler: simpler just to write a function with a different name
04:04:35 <quicksilver> 'myShow'
04:04:38 <quicksilver> 'prettyPrint'
04:04:48 <quicksilver> the show instance for lists of lists is the 'Right' one anyway.
04:04:49 <mux> an ad-hoc function sounds more appropriate here
04:05:03 <dabbler> man, i'm confused
04:05:07 <mreh> :D
04:05:10 <mux> just like there is showap and showTree
04:05:23 <mux> dabbler: good, haskell is getting into you :-)
04:05:31 <Alpounet> :-)
04:05:41 <dabbler> well, i wrote a general nxnxn Rubik's cube program
04:05:47 <mreh>  makeN n = foldr (\a b -> Suc b) Zero [1..n] <- is this good Haskell?
04:06:03 <Alpounet> btw, what's the usual way to use Either ? How do we know when to use Left or Right ?
04:06:04 <dabbler> but i'm starting to think getting it to display prettily is going to be harder than programming the cube and the moves
04:06:23 <mux> mreh: it's nice
04:06:26 <Deewiant> Alpounet: Generally, Right is for the 'right' result ;-)
04:06:27 <Alpounet> dabbler, it won't, don't worry.
04:06:33 <Deewiant> With Left being used for error values
04:06:51 <Alpounet> Ok, is it really the "standard" way ?
04:06:58 <quicksilver> dabbler: no, that's fine.
04:07:01 <quicksilver> dabbler: just don't use 'show'
04:07:04 <quicksilver> that's not what it's for
04:07:05 <mreh> mux: could do better?
04:07:08 <quicksilver> show is not intended to be pretty.
04:07:11 <mux> mreh: however you don't really needs the numbers here
04:07:16 <quicksilver> use prettyDisplayRubiksCube
04:07:23 <quicksilver> or whatever name you favour
04:07:37 <litb> oh
04:07:38 <dabbler> can i get that to fire whenever a function returning a cube is called?
04:07:40 <mux> mreh: you'd write (\_ b -> Suc b) thus; it tells the compiler you don't use the first variable
04:07:57 <Deewiant> Alpounet: Yes, it's quite standard: the Error instance for Either, for instance, considers Left an error
04:08:06 <mux> mreh: so actually you don't need a fold
04:08:14 <mux> mreh: you need the nth element of an iterate call
04:08:23 <dabbler> quicksilver: in the interpreter i mean
04:08:25 <mux> makeN n = iterate Suc Zero !! n
04:08:31 <Alpounet> Deewiant, ok, thanks.
04:08:46 <mux> mreh: that should work too and is nicer
04:08:53 <quicksilver> dabbler: No.
04:08:58 <mreh> mux: can you put some brackets around that, i cant parse it
04:09:08 <quicksilver> dabbler: but it's not hard to put "pp (...)" around your expressions.
04:09:18 <mux> mreh: makeN n = (iterate Suc Zero) !! n
04:09:19 <quicksilver> which is what I generally call a pretty print function.
04:09:20 <mux> mreh: better?
04:09:29 <mreh> mux: yes, thanks
04:09:38 <mreh> !! is infix
04:09:47 <dabbler> quicksilver: oh, that makes sense i guess, and i'm glad i dont have to mess around with show
04:11:31 <mux> mreh: remember that function application binds tightest than anything else
04:11:32 <mreh> hehe, Germans pronounce "Nats" like "Nuts"
04:11:50 <mreh> mux: i need to brush up on my fixity
04:12:01 <mreh> $ is the lowest is it not?
04:12:27 <quicksilver> yes, it is the lowest
04:12:32 <mux> $ associates to the right and has lowest fixity
04:12:35 <quicksilver> although you can define other things with the same, lowest
04:12:41 <quicksilver> "precedence" is the word, not fixity.
04:12:45 <mux> right
04:12:48 <quicksilver> fixity is {left,right,neither
04:12:50 <quicksilver> }
04:13:07 <mreh> how do you define precedence in haskell?
04:13:11 <yitz> hmm macports can't build ghc 6.10.2 - it fails to download a patch it thinks it needs
04:13:26 <mux> mreh: with the infix, infixr and infixl keywords
04:13:28 <yitz> a patch having to do with the testsuite no less
04:16:57 <mreh> java generics is parametric polymorphism?
04:17:13 <mreh> no...
04:17:18 <mreh> overloading
04:17:39 <mux> it's parametric polymorphism I think, except it's explicit
04:17:54 <mux> haskell figures types out alone, which is nice
04:18:07 <mux> at least most of the time anyway :)
04:18:09 <yitz> yeah, the patch it's looking for doesn't exist on macports.org.
04:18:23 <mreh> im having one of those days where I can concentrate
04:18:27 <mreh> cant
04:18:32 <mreh> CANT CONCENTRATE
04:20:21 <Alpounet> mreh, Java generics is very very very restricted parametric polymorphism
04:20:27 <Alpounet> C++'s is better
04:20:36 <Alpounet> and Haskell's is two times better :p
04:22:18 <ibid> C++'s are more powerful
04:22:30 <ibid> whether that's better is a different qusestion :)
04:22:35 <Asztal> the thing with C++'s is that a template can't be type-checked until it is instantiated, which can lead to fun things
04:22:56 <ibid> i understand C++0x is planning to change that
04:25:12 <mreh> c++ is ******* **** anyway
04:27:09 * ibid is currently writing a large thingy in C++
04:27:29 <mreh> how large is your thingy
04:27:49 <dabbler> @quote C++
04:27:49 <lambdabot> glguy says: run-time really is the best time to find out about scope problems
04:27:50 <ibid> not large yet
04:28:03 <Alpounet> hmm
04:28:23 <ibid> but probably going to grow to multi-dozen kilolines
04:28:28 <ibid> eventually :)
04:28:29 <mreh> has anyone investigated the speed and efficiency of haskell against others
04:28:39 <ibid> yes
04:28:45 <Alpounet> ibid, I've done a lot of metaprogramming in C++, I've played quite much with C++'s templates. I really appreciate them, but Haskell and OCaml's parametric polymorphism is smarter IMO.
04:28:51 <ibid> for some values of "investigated"
04:28:57 <ibid> Alpounet: agreed
04:29:16 <mornfall> mreh: If you are in for semi-meaningless benchmarks, try http://shootout.alioth.debian.org/
04:29:19 <litb> hmm
04:29:28 <litb> i felt like in ##c++ for half a second
04:29:46 <ibid> how does it feel like in there?
04:29:51 <litb> until i saw them prising ocaml and haskell oO
04:30:16 <Asztal> lambdabot << 2 << 3+4;
04:30:42 <mreh> actions speak louder than words
04:30:42 <litb> ibid: feels fresh
04:30:42 <Alpounet> ibid, C++'s templates do things we can't do in Haskell exactly because Haskell's parametric polymorphism and more generally Haskell's type system is better. Defining types / data structures in Haskell is more practical than the C++ way, and templates had to deal with that.
04:31:09 <Alpounet> That's my poitn of view. (I've been a C++ developer before discovering FP's magic)
04:31:13 <litb> c++ templates rocks all
04:31:21 <yitz> urgh. haskell.org down? anyone getting responses?
04:31:31 <mreh> Alpounet: actions speak louder than words?
04:31:31 <ibid> Alpounet: agreed. why are you telling me this? :)
04:31:46 <Alpounet> mreh, hmm ?
04:31:56 <mreh> nothing
04:32:30 <Alpounet> ibid, I was answering to "C++'s are more powerful"
04:32:44 <Alpounet> yitz, down for me too :/
04:33:13 <Alpounet> not down anymore.
04:33:53 <ibid> Alpounet: and did you see 14:22  <ibid> whether that's better is a different qusestion :)
04:33:56 <ibid> ?
04:33:58 <ibid> :)
04:33:59 <mreh> are there any serious game devs using haskell
04:34:16 <ibid> Alpounet: nevermind
04:34:48 <Alpounet> ibid, oh... So I've lost something like 30secs of my life.
04:36:06 <ibid> Alpounet: a tragedy, that
04:36:35 <ibid> Alpounet: i agree with you on the matter, i was just confused as to whether i had miscommunicated my position
04:41:54 <Bacta> How is babby formed?
04:42:39 <yitz> anyone else notice that Peaker (PeakerWork)'s MList is just ListTDoneRight?
04:43:01 <EvilTerran> ... it is?
04:43:14 <yitz> i believe so
04:44:40 <yitz> data Monad m => MListItem m a = MNil | MCons a (MList m a)
04:44:47 <yitz> newtype Monad m => MList m a = MList { unMList :: m (MListItem m a) }
04:45:12 * EvilTerran thought the first "m" in "m (MListItem m a)" made for something different
04:45:24 <Ferdirand> is there a significant difference between using RWS with R == (), and stacking a WriterT and a State ?
04:45:37 <EvilTerran> no.
04:45:38 <yitz> no you need that in ListTDoneRight also, that's actually the whole point
04:46:20 <EvilTerran> ... so ListT can't actually be written in terms of []?
04:46:31 <EvilTerran> (when dun right)
04:46:41 <yitz> not if you want it to satisfy the  monad laws
04:46:48 <yitz> and hence work right
04:46:58 <quicksilver> ListTDoneRight is a slightly odd monad though
04:47:02 * EvilTerran enlightenment
04:47:10 <quicksilver> arguably LogicT is a better kind of ListT done right.
04:47:28 <yitz> I hate LogicT, it's CPS
04:47:45 <yitz> that makes it a lot odder
04:48:25 <Bacta> How is babby formed?
04:48:35 <yitz> @ops
04:48:36 <lambdabot> Maybe you meant: docs oeis pl
04:48:42 <yitz> @where ops
04:48:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
04:48:42 <lambdabot> mauke
04:48:47 <wli> LogicT CPS how?
04:48:51 <QtPlaty[HireMe]> expn cps
04:48:58 --- mode: ChanServ set +o dcoutts_
04:49:25 <Bacta> How is babby formed???
04:49:32 <dcoutts_> Bacta: please stop
04:49:47 <Bacta> o = k
04:49:56 <dcoutts_> thanks
04:50:25 * wli vaguely wonders why this one thing isn't running in constant space.
04:50:56 <heltav> how do you et into contact with a channel admin?
04:51:23 <heltav> mreh: you heard of Frag? it is a game written by someone as a thesis. dont know of anything more than that,.
04:51:33 <mreh> heltav: year
04:51:40 <Bacta> People ... write games in Haskell? :x
04:51:48 <Alpounet> yeah
04:51:57 <mreh> @faq Can I write gamez in Haskell?
04:51:57 <lambdabot> The answer is: Yes! Haskell can do that.
04:52:11 <Bacta> masochists
04:52:20 <mreh> hmm
04:53:06 <heltav> http://www.youtube.com/watch?v=0jYdu2u8gAU
04:53:14 <mreh> frag is pretty impressive
04:53:22 <Bacta> Yeah was just working
04:53:24 <wli> It seems to need a lot of stack space.
04:53:25 <Bacta> *watching
04:53:33 <mreh> all game do
04:53:37 <mreh> all games do*
04:53:46 <Bacta> but seriously ... just because you can do something doesn't mean you should
04:53:53 <Bacta> right tool for the right job
04:54:00 <mreh> Bacta: what is your objection exactly
04:54:03 <araujo> mreh, interesting in gaming on haskell?
04:54:09 <araujo> er, interested
04:54:11 <mreh> arajo: aye
04:54:23 <Bacta> mreh: It must be painful
04:54:24 <tombom> @faq can I kill babies in haskell?
04:54:24 <lambdabot> The answer is: Yes! Haskell can do that.
04:54:26 <quicksilver> haskell's a great tool for game writing in many ways.
04:54:34 <quicksilver> there are shortcomings, of course.
04:54:48 <mreh> araujo: yes
04:54:50 <quicksilver> but it's very efficient in terms of getting complex stuff written quickly + correctly.
04:54:58 <araujo> mreh, nice, we need more of those :)
04:55:04 <mreh> and the ability to write your own languages
04:55:12 * araujo fears dcoutts_ with the @
04:55:20 <dabbler> and its so much more fun
04:55:21 --- mode: ChanServ set -o dcoutts_
04:55:22 <kosmikus> araujo!!!!!
04:55:26 <araujo> kosmikus!!!!
04:55:28 <araujo> hah
04:55:32 <araujo> kosmikus, how are you?
04:55:35 <araujo> long time
04:55:37 <araujo> :)
04:55:38 <kosmikus> indeed
04:55:44 <kosmikus> I'm fine, hope you are too
04:55:49 <mreh> get a room
04:55:57 <araujo> kosmikus, yeah, I am fine, thanks ... :)
04:56:12 <kosmikus> araujo: I'm currently co-writing a game in Haskell
04:56:20 <kosmikus> araujo: but it's not yet released
04:56:29 <mreh> kosmikus: can we see?
04:56:43 <Bacta> @faq can I use Haskell to commit a felony?
04:56:43 <lambdabot> The answer is: Yes! Haskell can do that.
04:56:48 <araujo> kosmikus, wow
04:56:51 <araujo> kosmikus, really???
04:56:59 <wli> kosmikus: What kind of game?
04:57:00 <kosmikus> soon, soon. nothing really special though, 2D space shooter
04:57:08 <araujo> kosmikus, not even a link briefly explaining what it is about? :)
04:57:18 <kosmikus> using OpenGL/SDL
04:57:18 <araujo> kosmikus, 2D space shooter ++
04:57:20 <mreh> kosmikus: haskell is space?
04:57:22 <Bacta> @faq can Haskell get me a hooker?
04:57:22 <lambdabot> The answer is: Yes! Haskell can do that.
04:57:38 <mreh> i think you're worked out how it works Bacta
04:57:47 <araujo> kosmikus, I would definitely be interested on playing with that :)
04:57:52 <mreh> @faq I can Haskell Cheezburger?
04:57:52 <lambdabot> The answer is: Yes! Haskell can do that.
04:58:01 <Bacta> @faq can Haskell get me ops in this channel?
04:58:01 <lambdabot> The answer is: Yes! Haskell can do that.
04:58:07 <araujo> kosmikus, let us know as soon as you have something up!
04:58:29 <kosmikus> araujo: will do. it will be on Hackage ultimately.
04:58:45 <dabbler> can Haskell fail?
04:58:54 <dabbler> @faq can Haskell fail?
04:58:54 <lambdabot> The answer is: Yes! Haskell can do that.
04:58:59 <Bacta> @fag can Haskell fail?
04:59:00 <lambdabot> The answer is: Yes! Haskell can do that.
04:59:02 <araujo> kosmikus, great :)
04:59:12 <Bacta> @fag works
04:59:12 <lambdabot> The answer is: Yes! Haskell can do that.
04:59:20 <Alpounet> a chapter in RWH about "Writing a game in Haskell" would have been fine.
04:59:21 <Bacta> @dyke
04:59:21 <lambdabot> Maybe you meant: dice type
04:59:29 <araujo> kosmikus, is this an academic project or for industry ? , if i may know
04:59:41 <heltav> how you list admins for a channel?
05:00:06 <araujo> something like, /msg chanserv #channel access list
05:00:07 <araujo> i think
05:00:23 * yitz is impressed that quicksilver withstood the temptation to answer my troll about CPS.
05:00:26 <dabbler> @faq can haskell make iphone apps?
05:00:27 <lambdabot> The answer is: Yes! Haskell can do that.
05:00:35 <dcoutts_> heltav: I've no idea, is there something in particular you'd like to discuss with them?
05:00:40 <heltav> yes
05:00:42 <earthy> kosmikus is not in industry afaik
05:01:02 <wli> There's a tremendous amount of graphic design in games.
05:01:03 <Bacta> @faq Blah'); drop table students; --
05:01:03 <lambdabot> The answer is: Yes! Haskell can do that.
05:01:37 <mreh> was that an SQL injection?
05:01:51 <Bacta> ;)
05:02:19 <kosmikus> araujo: it's a hobby project
05:02:31 <araujo> kosmikus, cool :)
05:02:41 <mreh> in any normal channel Bacta would have been kicked age ago
05:02:43 <araujo> kosmikus, we definitely need more games in haskell :P
05:02:50 <yitz> good thing freenode isn't using SQL.
05:02:57 <Bacta> Yeah you guys are fairly tolerant of me :)
05:03:16 <mreh> that would have been the optimum moment for a kick
05:03:18 <Bacta> It's not my fault I'm Jewish but you guys have been really good to me about it
05:03:38 * araujo looking forward for that game 
05:04:30 <mreh> haskell in space is a good place to start if you want to do gamez
05:04:46 <mreh> it's a paper by c luth
05:06:48 <Alpounet> http://alexicalmistake.com/2008/10/haskell-and-game-development/
05:06:51 <Alpounet> interesting
05:06:57 <Alpounet> (particularly the comments)
05:07:21 <mreh> read that
05:07:27 <mreh> worth reading
05:08:05 <mreh> how NOT to write a game in haskell
05:10:26 <Bacta> LETS GET PHYSICAL! PHYSICAL!
05:11:02 <mreh> he'll get tired soon
05:11:15 <Bacta> yeah I'm about to goto bed actually
05:11:15 <mreh> im just going to stop paying attention to him
05:12:06 <dabbler> @quote troll
05:12:06 <lambdabot> qwe1234 says: stfu, troll.
05:12:39 <Bacta> I am not a troll (done in his best Nixon voice)
05:12:50 * osfameron hugs irssi
05:14:53 <Asztal> I can't find anything about ListTDoneRight, except for links to a long-gone haskell wiki page :(
05:15:22 <dabbler> @quote listdoneright
05:15:22 <lambdabot> No quotes match.
05:18:39 <mreh> how does one get a quote?
05:18:43 <mreh> @quote mreh
05:18:43 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
05:18:46 <mreh> :(
05:19:02 <EvilTerran> @help remember
05:19:02 <lambdabot> quote <nick>
05:19:02 <lambdabot> remember <nick> <quote>
05:19:02 <lambdabot> Quote somebody, a random person, or save a memorable quote
05:19:12 <EvilTerran> @quote EvilTerran
05:19:12 <lambdabot> EvilTerran says: Hylo morphism batman!
05:19:37 <EvilTerran> Asztal, http://www.haskell.org/haskellwiki/ListT_done_right should have it, although it doesn't seem to be working for me at the moment
05:19:54 <mreh> @quote trippy
05:19:54 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
05:20:09 <arjanb> haskell.org seems very slow atm
05:20:29 <Asztal> EvilTerran: ah, thanks. Yeah, I heard someone say haskell.org wasn't responding before
05:20:56 <mreh> @quote l33t_h4x0r
05:20:57 <lambdabot> l33t_h4x0r says: maybe if uve had some professor teach u bullshit in uni yea \n i learned on my own.. k.. i dun give a shit bout terms :p i just code
05:21:10 <Workybob> is it just me or is h.o down?
05:21:25 <EvilTerran> Asztal, http://www.google.com/search?q=cache:www.haskell.org/haskellwiki/ListT_done_right
05:21:41 <mreh> @quote lol
05:21:41 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
05:21:53 <mreh> @quote lolol
05:21:53 <lambdabot> No quotes match. My pet ferret can type better than you!
05:23:32 <litb> where can i ask about bottom type?
05:23:49 <litb> i wonder what "void" is? bottom type or unit type? is it the right channel?
05:23:57 <dabbler> @remember dabbler @quote dabbler
05:23:57 <lambdabot> It is forever etched in my memory.
05:24:08 <EvilTerran> litb, well, C etc's "void" is analogous to (), the unit type, in haskell
05:24:14 <mreh> @quote  dabbler
05:24:14 <lambdabot> dabbler says: @quote dabbler
05:24:20 <Tobsan> w 20
05:24:22 <Tobsan> oops
05:24:32 <litb> EvilTerran: i wonder since in the Standard, it says a value of type void does not exist
05:24:39 <litb> but wikipedia says a unit type has exactly one value
05:24:49 <Asztal> Unit is a type with one value, Void is the type with no values
05:24:55 <EvilTerran> void isn't exactly a type in C, it's a bit weird
05:25:07 <Botje> data Unit = Unit vs data Void
05:25:15 <Botje> Unit has Unit and _|_
05:25:21 <EvilTerran> but you return void in C when you'd return () in haskell
05:25:23 <Botje> Void can only have _|_
05:25:31 <EvilTerran> by the conventional ordering of types, the "bottom type" in haskell would be (forall a. a)
05:25:32 <litb> Asztal: but wikipedia says void is unit type with one value. but the c++ standard says a void value does not exist
05:25:39 <litb> so im confused
05:25:44 <EvilTerran> litb, that's because C is silly.
05:25:51 <EvilTerran> or indeed c++.
05:25:59 <Alpounet> EvilTerran, the second use vase in C is void*... Not used anymore in C++ (except by beginners or bad C++ developers)
05:26:26 <EvilTerran> Alpounet, yeah, well, void* is a type, but void isn't really, as i see it.
05:26:42 <Alpounet> EvilTerran, yes, void* is totally apart of the void type.
05:26:53 <litb> EvilTerran: void is a void-type, of course
05:26:56 <Alpounet> They just saved time to find a new keyword...
05:27:10 <EvilTerran> C's type system predates modern programming language theory, so it inevitably looks incoherent when you try to mesh the two
05:27:48 <quicksilver> if there's only one value, it might as well not exist
05:27:52 <quicksilver> form the point of view of a C programmer
05:28:00 <litb> hmm
05:28:02 <quicksilver> there's really no difference between () and Void
05:28:13 <quicksilver> (...from the point of view of a C programmer, that is)
05:28:15 <EvilTerran> litb, taking the usual ordering of types (s >= t iff (x :: t) => (x :: s)), the bottom type in haskell would be (forall a. a)
05:28:52 <EvilTerran> the only value that's an inhabitant of all types is _|_, so that's the only value in (forall a. a)
05:28:55 <Botje> C pretty much predates modern everything >:)
05:29:21 <litb> where (forall a. a) are all values?
05:29:29 <Asztal> Fun fact: "A program can convert a pointer to any type of data to a pointer to void and back to the original type without losing information" isn't true in C++. Pointer-to-member functions don't necessarily fit in a void*.
05:29:40 <EvilTerran> litb, no, (forall a. a) is the type that only contains values that can be in any type.
05:29:46 <litb> oh ok
05:30:05 <wjt> Asztal: rly
05:30:09 <EvilTerran> "x :: forall a. a" means "for all types a, x is of type a"
05:30:09 <EvilTerran> so x = _|_
05:30:33 <mreh> i feel like i've missed something, i'm 22, and all I've learned is alot of Java, and some C
05:30:41 <mreh> and now I'm on to Haskell
05:30:46 <EvilTerran> (ignoring any dubious semantics-breaking involving unsafeCoerce and seq)
05:30:49 <litb> EvilTerran: oh
05:32:42 <EvilTerran> litb, the "top" type, as it were, would be "exists a. a" (if "exists" were actually a keyword)
05:33:15 <Deewiant> It is in UHC
05:33:17 <EvilTerran> because "x :: exists a. a" would mean "there exists a type 'a' such that x is of type a", which clearly applies to all well-typed values.
05:34:05 <Asztal> can you actually do anything useful with that, though?
05:34:25 <EvilTerran> Asztal, not with (exists a. a), no, because you don't actually know anything about a value of that type
05:34:54 <kalven> Asztal: you can put a pointer-to-pointer-to-member function in a void* though :)
05:35:22 <EvilTerran> Asztal, but you could use the methods of Foo on a value of type (exists a. Foo a => a), for instance
05:35:25 <Asztal> I supposes there's exists a. Num a => a
05:35:55 <litb> kalven: you can't reliably. trying it will result in undefined behavior. so better don'T do it ahaha
05:35:57 <Asztal> actually, I want that now :)
05:36:23 <EvilTerran> Asztal, and you could apply the fst to the snd of a value of type (exists a. (a -> Foo, a))
05:36:42 <kalven> litb: says who?
05:37:22 <litb> kalven: i've kept the standard open all times on my desk. so it's easy to prove ppl wrong :D
05:37:48 <heltav> is it possible to download a ghc binary for linux to windows, store it on USB and then install it on linux?
05:38:03 <mathijs> heltav, sure you can
05:38:03 <EvilTerran> heltav, i don't see why not.
05:38:41 <kalven> litb: give me a section then :)
05:39:04 <mathijs> heltav: But it's generally easier just to get it from your OS package system
05:39:18 <mathijs> if you don't need the latest and greatest
05:39:20 <heltav> not without internet
05:39:25 <mathijs> aha
05:40:17 <mathijs> In that case, make sure you grab all the required libs too and put them on the same usb disk ;)
05:42:01 <litb> kalven: first 5.2.10 terms any other cast not explicitly listed done using reinterpret_cast ill-formed. so you would need to type-pun an lvalue of type void* to an lvalue of type ptr-member-function-pointer and write. but that yields to UB according to 3.10/15.
05:43:04 <litb> kalven: so you are out of luck, until you write a wrapper function and get a pointer-to-function and write that to a void*. but that's equally not allowed in c++03, and only conditionally supported in c++1x, so you either get a diagnostic, or you get what you want. not good :(
05:43:14 <litb> ahaha, but i guess this is offtopic in here
05:43:25 <kalven> yeah, let's take it to ##c++
05:45:36 <litb> just to let all know i was wrong. it's a pointer to it, so it can be stored in void* of course :D
05:50:05 <heltav> uh, is .tar.bz2 (70 MB) a binary or not?
05:51:29 * EvilTerran tries to work out how to do unification of terms expressed in the I Am Not A Number paper style
05:52:44 <EvilTerran> (http://portal.acm.org/citation.cfm?id=1017477)
05:53:27 <pozic> How can I see which module imports a certain identifier?
05:53:46 <EvilTerran> pozic, :i(nfo) at the ghci prompt should do it
05:53:56 <pozic> EvilTerran: that only shows where the function is defined.
05:54:12 <pozic> EvilTerran: not which import module statement imports it.
05:55:13 <davidL> do all the haskore modules need to be imported individually? "import Haskore" doesn't work
05:55:55 <quicksilver> pozic: you can't.
05:56:05 <quicksilver> pozic: you could be getting it from more than one source.
05:56:08 <quicksilver> annoying.
05:57:06 <BONUS> i was thinking. should Data.Monoid have KleisliEndo?
05:57:14 <BONUS> a -> m a
05:57:37 <BONUS> it's useful for making a foldM that works on any Foldable
05:57:58 <Axman6> BONUS: i was in the comp labs at uni yesterday, and one of the tutors for a course i did last year in haskell was reading lyah. he said the applicative functor chapter was really good
05:58:06 <pozic> quicksilver: how could it be coming from multiple sources?
05:58:09 <quicksilver> indeed, it could be WrappedArrowEndo, couldn't it?
05:58:19 <BONUS> really? wow, that's pretty awesome to hear
05:58:20 * Axman6 though he should mention it while you were around
05:58:35 <quicksilver> pozic: modules A and B could both import foo and re-export it
05:58:47 <quicksilver> pozic: then you are getting 'foo' from both "import A" and "import M"
05:58:57 <pozic> quicksilver: but those are not understood to be the same foo by GHC.
05:59:01 <quicksilver> yes they are.
05:59:10 <quicksilver> as long as they are, in fact, the same foo.
05:59:16 <BONUS> WrappedArrowEndo huh? what would be the declaration for that
05:59:46 <quicksilver> BONUS: newtype WrappedArrowEndo arr a = WrappedArrowEndo (arr a a)
06:00:06 <pozic> quicksilver: in my experience that doesn't work; you get at the very least that you are importing foo two times.
06:00:12 <BONUS> ah so you could then use Kliessli m b as arr
06:00:14 <quicksilver> pozic: no, you don't.
06:00:27 <quicksilver> pozic: for example, if you use Data.List, you are getting 'map' form Prelude and Data.List
06:00:45 <quicksilver> pozic: if you import Control.Monad and Control.Monad.State, you are getting e.g. mapM_ from both those places
06:01:44 <quicksilver> instance Arrow arr => Monoid (WrappedArrowEndo arr) where mempty = WrappedArrowEndo (pure id); mappend (WAE a) (WAE b) = WAE (a >>> b)
06:01:55 <quicksilver> I got bored of typing the long constructor name :P
06:02:04 <BONUS> haha
06:02:33 <quicksilver> BONUS: still, "yes, it would be useful"
06:02:39 <quicksilver> I bet edwardk already has it.
06:02:47 <quicksilver> although it probalby has an absurd name :)
06:03:14 <pozic> quicksilver: in the simple example I tried, you are right, but in more complicated situations I really seem to recall that GHC gave this warning.
06:03:38 <BONUS> haha, i'll have to ask him. and yeah, his CT names own
06:04:37 <quicksilver> pozic: if it somehow can't tell they are the same foo
06:04:48 <quicksilver> pozic: but, afaik, that would only be the case if they were actually different.
06:04:53 <dmorti> newbie question: in ghci, how does one define a datatype?
06:05:02 <quicksilver> (like the same named functions in bytestring and bytestring.lazy which actually *are* different)
06:05:11 <BONUS> dmorti: you don't, define it in a .hs file and then :load that file in
06:05:16 <EvilTerran> dmorti, by putting it in a file and loading that file
06:05:20 <dmorti> cheers.  thought that might be the case
06:05:24 <pozic> quicksilver: yes, I understand what it is supposed to do.
06:05:28 <quicksilver> pozic: I think if you find a case, you have found a ghc bug, at least :)
06:06:54 <McManiaC> hey, whats that error?
06:07:00 <McManiaC> [ 5 of 21] Compiling System.Posix.Process.Internals ( System/Posix/Process/Internals.hs, dist/build/System/Posix/Process/Internals.o )
06:07:04 <McManiaC> System/Posix/Process/Internals.hs:10:17: Module `GHC.Conc' does not export `Signal'
06:07:07 <McManiaC> cabal: Error: some packages failed to install:
06:07:08 <McManiaC> [list of packages]
06:07:22 <McManiaC> im running debian lenny with ghc 6.10.1
06:09:10 * EvilTerran blinks
06:09:12 <quicksilver> taht version of System.Posix must be incomptaible with your version of GHC.Conc
06:09:15 <quicksilver> I suppose.
06:09:30 <EvilTerran> I Am Not A Number, I Am A Free Variable mentions Huet's zippers...
06:10:03 <EvilTerran> ... and a cursory googling for "higher-order unification" turns up a paper by Huet. i wonder if that'll work.
06:10:04 <McManiaC> quicksilver: so what can i do?
06:10:14 <quicksilver> McManiaC: why are you trying to compile system.posix anyway?
06:10:17 <quicksilver> what problem are you trying to solve here
06:10:46 <McManiaC> "cabal update postmaster" wants to do that
06:10:48 <McManiaC> not me :)
06:10:59 <dcoutts_> McManiaC: try install instead of update
06:11:03 <McManiaC> upgrade
06:11:16 <McManiaC> ok
06:11:33 <dcoutts_> McManiaC: and use --dry-run to see what it'll install
06:11:41 <quicksilver> cabal update tries to update all depended packages.
06:11:42 <McManiaC> and this package seems to be missing a library to register - is this the devs fault?
06:11:45 <quicksilver> This is actually not a good idea :(
06:13:51 * EvilTerran notes that he doesn't seem to be going for higher-order unification proper, which is just as well, seeing as that's undecidable
06:14:26 <Alpounet> any impl. of Huet's Zipper in Haskell ?
06:14:57 <Axman6> there's zipper's, not sure if they the same thing
06:15:44 <EvilTerran> http://www.haskell.org/haskellwiki/Zipper
06:16:07 <EvilTerran> mentions Huet's paper under "further reading"
06:16:58 <lukeo05> Hi, real basic problem.. I can't figure out the simplest IO... Why can't I use multiple putStr's in a function?!
06:19:22 <Jedai> lukeo05: You can, you have to use operators to combine IO actions though
06:19:51 <Jedai> lukeo05: myIOAction = putStr "hello " >> putStrLn "world !"
06:20:25 <Jedai> lukeo05: myEcho = getLine >>= (\line -> putStr line)
06:21:16 <Jedai> lukeo05: This use the IO Monad, since monads are used everywhere in Haskell, the language has syntax sugar for this : the do-notation
06:21:38 <Jedai> lukeo05: do { putStr "hello "; putStrLn "world !"
06:21:43 <Jedai> }
06:21:45 <EvilTerran> lukeo05, I found http://blog.sigfpe.com/2007/11/io-monad-for-people-who-simply-dont.html very useful when i was just getting started and didn't want to have to think about all this "monads" stuff
06:22:20 <Jedai> lukeo05: myEcho = do { line <- getLine; putStr line }
06:22:55 <Jedai> lukeo05: And of course you can use layout instead of explicit {} and ;
06:23:00 <lukeo05> Thanks a lot :) Are the braces and colon whats needed? Cause my lecture notes don't have that!
06:23:09 <lukeo05> oh... hmm
06:23:21 <Jedai> myEcho = do
06:23:21 <Jedai>   line <- getLine
06:23:21 <Jedai>   putStr line
06:24:00 <EvilTerran> lukeo05, the braces and semicolons can be inferred from indentation and newlines according to the so-called "layout rules", or you can put them in explicitly if you want
06:24:44 <edwardk2> lukeo05: haskell has this nice rule called 'layout' which says that after a 'do, let, of, or where' you can omit the curly brace and it'll implicitly put ;'s as long as you keep indenting to the same level after that
06:24:57 <edwardk2> lukeo05: outdenting will end the layout rule.
06:25:24 <lukeo05> ahah, yeah it looks like there is something wrong with my layout... it works with braces and semi colon. Though the layout looks fine... I must have done something wrong!
06:25:55 <edwardk2> lukeo05: remove tabs and make sure line <- getLine and putStr line are lined up on the same column
06:26:11 <edwardk2> tabs are always worth 8 spaces
06:26:30 <edwardk2> er is it they align to 8 columns, i can never remember which language does which
06:26:50 <lukeo05> does do have to be on its own line? That fixed it for me...
06:28:06 <edwardk2> lukeo05: you can put stuff after the do on the same line: i.e. do foo\n... and then indent to where the _foo_ is, and continue
06:28:27 <ManateeLazyCat> How to customize GTK widget with Haskell? (I mean in gtk2hs). Thanks
06:28:44 <Jedai> lukeo05: Nope, do don't have to be on its own line but it's a good rule to respect since it avoids lots of easy mistake if you use tabs and space (I strongly recommend you just use space)
06:28:48 <edwardk2> lukeo05: personally i find that putting do, let, of or where on their own line makes my spacing less 'brittle'
06:29:25 <BONUS> hey edwardk, we were just wondering if one of your libraries already has WrappedArrowEndo arr a = WrappedArrowEndo (arr a a). cause you can then make that a monoid with arrow composition and then with that and Kleisli you can make a foldM that works on all foldables
06:29:31 <BONUS> *inhales*
06:29:32 <edwardk2> i.e. if i change the text on the line containing the do, i no longer have to respace everything below it
06:29:47 <edwardk2> bonus: its in monoids =)
06:29:54 <lukeo05> Right, will do. Thanks a lot man. I think it was space/tab errors.
06:30:02 <BONUS> haha
06:30:03 <edwardk2> Data.Monoid.Categorical iirc
06:30:34 <edwardk2> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Categorical.html
06:30:36 <edwardk2> GEndo
06:30:39 <quicksilver> edwardk2: the kleisli version, or the arrow one?
06:30:40 <BONUS> ah, you called it GEndo
06:30:52 * quicksilver nods
06:30:56 <quicksilver> the arrow one, essentially
06:31:06 <quicksilver> edwardk2: do you have a list of the major enhancements / bug fixes?
06:31:18 <edwardk2> bug fixes?
06:31:25 <edwardk2> as in what monoids does?
06:31:35 <quicksilver> edwardk2: between edwardk and edwardk2
06:31:49 <Badger> what do monoids do? :P
06:31:56 <edwardk2> oh the old me is a ghost so he's clearly inferior =)
06:31:59 <quicksilver> associate.
06:32:21 <fasta> Alpounet: the wiki page has some information about Zippers, the xml package also contains zippers, xmonad contains a zipper. I can continue, but I have yet to find an actual application of zippers, since the last time I thought I needed them, it turned out that the functional solution was a factor log n too slow. There are no 'zippers' with an unbounded number of holes, AFAIK.
06:32:36 <edwardk> quicksilver: they also have a nice unit... er wait that sounds dirty
06:32:37 <BONUS> monoids are basically like socks, you have two of them and then suddenly there's only one
06:33:26 <osfameron> can you mix and match monoids like socks?
06:33:38 <dcoutts_> only socks of the same type
06:33:44 <osfameron> "Ah, that monoid is roughly the same colour and material as the other one... it'll do" ?
06:33:56 <edwardk> bonus: anyways the foldM like thing is already there its called mapM_ but it doesn't work quite like you think
06:34:24 <Badger> BONUS: that needs to go in lyah :P
06:34:43 <BONUS> haha. edwardk you mean the regular mapM_?
06:34:43 <edwardk> as for the monoid for (>>) thats also in monoids
06:34:43 <quicksilver> edwardk: do you mean it's there as runStateT . mapM_ . StateT \s -> ?
06:35:05 <quicksilver> (with a relaxed interpretation of what '.' means)
06:35:36 <edwardk> http://comonad.com/haskell/monoids/dist/doc/html/monoids/Data-Monoid-Monad.html describes the 'Action' monoid
06:36:16 <edwardk> where is also the 'Mon' monoid which wraps a monoid in a monad
06:36:37 <Alpounet> fasta, thanks.
06:37:38 <fasta> Alpounet: a zipper really is just remembering the path it followed when it zips open and unzips again when you go up.
06:38:15 <edwardk> so it seems my parser combinator set can recognize TIGs
06:38:34 <edwardk> which places its asymptotics around O(n^4) worst case
06:39:21 <fasta> edwardk: and what are TIGs?
06:39:24 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.7116
06:39:37 <edwardk> TIGs are TAGs limited to CFG stuff basically
06:39:42 <edwardk> how is that for vague ;)
06:40:22 <edwardk> and the parsing algorithm i'm using is basically equivalent to one of the TAG algorithms restricted to the TIG case which speeds it up from O(n^6) to O(n^4)
06:41:47 <fasta> edwardk: I know the Chomsky hierarchy. You can parse CFGs in O(n^3), so I don't really see why you would settle for O(n^4) for some limited CFG.
06:41:53 <edwardk> what i'm looking to do is decide whether i should use the smart left to right version or the general version based on the generator being used
06:42:43 <wli> GLR is pretty nasty to implement.
06:42:55 <edwardk> fasta: TAGs subsume CFGs, TIGs are weakly equivalent, but have a algorithms for solving that O(n^4) in parallel
06:43:46 <edwardk> er TIGs are weakly equivalent to CFGs, you can parse a TIG in O(n^3) using a earley-style parser
06:44:18 <edwardk> fasta: so i trade off some worst case performance for the ability to throw more hardware at the problem
06:44:42 <fasta> edwardk: and what is a TAG?
06:45:02 <edwardk> TAG = tree adjoining grammar, its a slightly context-sensitive grammar type
06:45:36 <fasta> Never heard of it. Congratulations :)
06:45:52 <edwardk> general TAG parsing is O(n^6) or somewhere between n and n^9 depending on the algorithm used
06:46:03 <edwardk> fasta neither had I until I reinvented it
06:46:11 <Deewiant> That's quite a between :-P
06:46:21 <Deewiant> n to n^9
06:46:24 <edwardk> er depending on the grammar i mean
06:46:31 <Deewiant> Thought so ;-)
06:47:04 <edwardk> its a nL^2 where L specifies the presence of a certain kind of dependencies and can be up to n^4
06:47:37 <edwardk> but many grammars have a very small L, so that algorithm can be more efficient for those
06:47:43 <Igloo> So where did n^6 come from?
06:48:15 <ManateeLazyCat> If i want to customize widget in gtk2hs, i need implement in C then export with Haskell? Or just implement Haskell?
06:48:32 <dcoutts_> ManateeLazyCat: depends what you want exactly
06:48:45 <edwardk> igloo: there is an algorithm for parsing TAGs in O(n^6) from the original paper
06:49:01 <dcoutts_> ManateeLazyCat: it's possible to implement completely custom widgets by drawing them yourself
06:49:30 <edwardk> it was a later improvement to find the O(nL^2) algorithm which is a huge win for some grammars
06:49:55 <fasta> edwardk: what applications does it have?
06:49:58 <ManateeLazyCat> dcoutts_: Example, in gtk2hs have textbuffer for text edit, but i want implement synchronous buffers, if i type somet text in one buffer, others buffer will synchronous this buffer content.
06:50:06 <edwardk> fasta: NLP folks like it
06:50:15 <fasta> edwardk: I don't really believe in NPL with a static grammar.
06:50:20 <heltav> bah! linux slinux
06:50:21 <fasta> er NLP*
06:50:25 <edwardk> fasta: me neither
06:50:41 <ManateeLazyCat> dcoutts_: And now i use textBufferGetText get text and textBufferSetText with other buffers.
06:50:47 <edwardk> fasta: my main use for it is that its a larger set of grammars i could extend my parser combinator set to cover ;)
06:51:02 <ManateeLazyCat> dcoutts_: But it's ineffective and slow if buffer's content is huge.
06:51:24 <fasta> edwardk: bragging rights is a good reason :P
06:51:28 <edwardk> i had noticed i could fit certain kinds of context sensitivity, the TAG stuff provides me with a body of knowledge as to how sensitive i can be
06:51:46 <RayNbow`> @seen dons
06:51:47 <lambdabot> dons is in #haskell-soc, #haskell-in-depth, #gentoo-haskell, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 5s ago.
06:52:49 <ManateeLazyCat> dcoutts_: So i want those synchronous buffers just contain *one* text object, i just modified this text object whatever i type string in any buffers, then those buffers just show it, and not copy content with `afterBufferChanged`
06:53:08 <dcoutts_> ManateeLazyCat: you can have multiple views share the same buffer
06:53:24 <dcoutts_> ManateeLazyCat: and you do not need to copy and set the entire buffer at once
06:53:58 <edwardk> hrmm http://www.aclweb.org/anthology-new/J/J94/J94-2002.pdf provides a nice reductio on what improvements in general purpose tag parsing would entail for boolean matrix multiplication, which you could work backwards to get a pretty good practical floor on the complexity of TAG parsing
06:54:43 <ManateeLazyCat> dcoutts_: multiple views share the same buffer? Can you more details?
06:56:22 <dcoutts_> ManateeLazyCat: set the views to use the same buffer object, it's designed to work that way
06:57:21 <ManateeLazyCat> dcoutts_: Thanks, i will try it.
06:58:01 <edwardk> hrmm working that backwards you'd probably get something like O(5.61 log^14 n) for general TAG as a practical floor using those silly fast boolean matrix multipliers but have ridiculous constants
06:58:19 <edwardk> er O(n^5.61 log^14 n)
06:58:38 <ManateeLazyCat> dcoutts_: Can you describe "depends what you want exactly"? Such as example, when time implement in C, and when time just implement in Haskell? Thanks
06:58:38 <Axman6> not log_14 n?
06:59:08 <edwardk> nope
06:59:21 * Axman6 has never seen a log to a power :o
06:59:42 <dcoutts_> ManateeLazyCat: well for example if you were asking how to set the general theme for the widgets then you'd do that completely differently from say just setting the background of a text field to be green.
06:59:54 <dcoutts_> ManateeLazyCat: I wasn't really sure what question you were asking initially.
07:00:23 <Deewiant> The AKS primality test is O(log^12 n) IIRC
07:00:52 <paolino> could someone show me the translation from existentials to rank2 of http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4647#a4647, please
07:01:42 <edwardk> in any event: Г•(n^5.61)
07:02:11 <heltav> bah being on windows makes me wanna killmyself
07:02:14 <fasta> paolino: data R = R (forall a. a -> Int)  (+ context)
07:02:22 <heltav> but getting onto linux wants to killmyself eve n more
07:02:34 <heltav> maybe i should just bu a computer wiht linux installed already
07:02:48 <ManateeLazyCat> dcoutts_: Example, i want implement a new Paned that support vertically and horizontally split both, and not HPaned, VPaned. So i can just implement this customize widget in Haskell *completely*?
07:02:49 <Axman6> you get a mac and stop messing around ;)
07:02:50 <edwardk> axman: it usually means you had to appeal to some polylogarithmic algorithm in the process: http://en.wikipedia.org/wiki/Polylogarithmic
07:02:59 <Axman6> uh, s/you/or
07:03:08 <dcoutts_> ManateeLazyCat: in theory, yes.
07:03:52 <Axman6> edwardk: i'm sure what you just said was very interesting, but i'm so sleep deprived at the moment i can't keep track of sentenses, let alone thing about their meanings atm :(
07:04:04 <paolino> fasta, I'm not smart enogh :) to appreciate
07:05:03 <fasta> paolino: existentials have forall before the constructor. Rank2 and higher have them inside the fields of the constructor.
07:05:12 <paolino> and I thought R was disappearing actually
07:05:46 <ManateeLazyCat> dcoutts_: That's perfect if i can use Haskell implement customize widget base on gtk2hs libraries, it's trouble that i need code in C and binding in Haskell again.
07:06:12 <ManateeLazyCat> dcoutts_: in theory? Have you do those work before?
07:07:15 <ManateeLazyCat> dcoutts_: Or still need use C sometimes?
07:07:18 <dcoutts_> ManateeLazyCat: people have implemented custom widgets, though not so many that look like standard widgets, you may find you need a couple more C functions to be bound
07:08:07 <paolino> fasta, is there something I can read about rank2 ?
07:08:27 <fasta> dcoutts_: I thought you had a compiler to compile the C version automatically to Haskell?
07:08:47 <fasta> dcoutts_: (+ some hand work)
07:08:49 <dcoutts_> fasta: semi-automatically, yes. That doesn't mean everything is bound.
07:09:46 <fasta> paolino: the standard paper is the arbitrary rank polymorphism paper, which is "tutorial style", which you should read.
07:09:56 <fasta> paolino: after that it is just getting used to them.
07:10:09 <ManateeLazyCat> dcoutts_: Can you give me some link that use Haskell customize widget? I haven't found those in "Gtk2hs Tutorial". Thanks
07:11:00 <dcoutts_> ManateeLazyCat: at the simplest level it's just about using a draw window and connecting to specific events like keyboard entry or mouse events.
07:11:14 <dcoutts_> ManateeLazyCat: see the demos that use a draw window
07:11:23 <ManateeLazyCat> dcoutts_: Thanks
07:11:32 <paolino> fasta: the paper from spj on research.microsoft.com ?
07:11:49 <fasta> Haskell is starting to look like C++ more by the day... I got a segmentation fault, OTOH, it is probably from a binding.
07:11:56 <feinaa> te kaads no LV? :D
07:12:07 <fasta> paolino: yes
07:13:03 <fasta> Is there any way to debug core dumps? I never actually needed to do that.
07:13:09 <wjt> dcoutts_: but ISTR you can't make new GObject classes with gtk2hs, righT/
07:13:28 <dcoutts_> wjt: right, but that's not strictly necessary
07:13:34 <wjt> dcoutts_: oh, sure
07:13:46 <fasta> I guess gdb could work, but I am not sure whether my program would still be recognizable.
07:14:02 <ManateeLazyCat> dcoutts_: Can you compare "gtk2hs" and "X11" with Haskell? "Gtk2hs" is advanced but more limit, "X11" is lower but less limit....
07:14:15 <paolino> mhh, research.microsoft.com is down from here
07:15:12 <dcoutts_> ManateeLazyCat: yep that's a reasonable way of putting it.
07:15:57 <dcoutts_> ManateeLazyCat: building something equivalent to Gtk+ on top of X11 would take you many man years but you'd have the opportunity to make different design decisions.
07:17:10 <paolino> and make haskell famous
07:18:08 <Baughn> ..I never thought I'd go "squee" over a CS paper, but the Sinfonia one just did it. Must.. implement...
07:18:29 <Jebdm> Baughn: link?
07:18:48 <ManateeLazyCat> dcoutts_: Now i'm developing Haskell editor or web-browser, i have use gtk2hs some weeks. I found gtk2hs have more limit, such as C implement style, binding IO-action with some function.... So i think whether implement Graphics Userface base on X11....
07:18:50 <Baughn> Jebdm: gogle.scholar://sinfonia
07:19:19 <dcoutts_> ManateeLazyCat: that'd be a lot of work. You might start with Cairo however.
07:20:01 <fasta> ManateeLazyCat: Slava Pestov did that for Factor.
07:20:13 <Jebdm> this one? http://portal.acm.org/citation.cfm?id=1323293.1294278
07:20:40 <ManateeLazyCat> dcoutts_: You mean it's will save much time if i base on Cairo?
07:21:00 <dcoutts_> ManateeLazyCat: yep
07:21:21 <ManateeLazyCat> dcoutts_: Thanks for your suggestions, i will look it. :)
07:21:44 <dcoutts_> ManateeLazyCat: you might want to use it with gtk2hs anyway
07:21:47 <wjt> i think you'd save even more time by writing a more functional layer around gtk2hs
07:22:04 <Baughn> Jebdm: Yes. There are non-acm pdfs around, mind you.
07:22:11 <Baughn> Jebdm: Google should give you a bunch
07:22:32 <Baughn> ..it just tends to default to acm.. but click the princeton.edu link next to it
07:22:42 <Jebdm> Ah, it's no problem though, I can access it.
07:23:49 <ManateeLazyCat> dcoutts_: It's unavoidable that use IORef with gtk2hs? Such as `onKeyPress` function..
07:24:02 <quicksilver> ManateeLazyCat: sure, but it's not hard to hide that.
07:24:11 <quicksilver> ManateeLazyCat: you will find X11 much much worse
07:24:12 <quicksilver> not better.
07:25:14 <ManateeLazyCat> quicksilver: Yep, i have read many resource about X11, and i find X11 have much disadvantage, such as too long function parameter...
07:25:32 <dmorti> Can anyone explain to me why:  > do {n <- readLn ; print (n^2)} works, but >do {n <- readLn; print n} throws the error (Prelude.readIO: no parse) ?
07:26:19 <dmorti> (or point me to a reference explaining it to dummies! :)  )
07:26:32 <EvilTerran> dmorti, i suspect type defaulting may be at fault; try adding an explicit type signature somewhere that'll fix the type of n
07:26:42 <paolino> n is less typed than n^2
07:26:45 <dmorti> ahh ok.
07:26:55 <Axman6> :t (n)
07:26:57 <lambdabot> Expr
07:26:58 <dmorti> so n^2 allows ghc to infer that n is Numeric?
07:26:59 <EvilTerran> do { n <- readLn; print (n :: Integer) }, say
07:27:03 <dmorti> cheers
07:27:03 <Deewiant> > n < n^2
07:27:04 <Axman6> :t (?n)^2
07:27:06 <lambdabot> forall a. (Num a, ?n::a) => a
07:27:07 <lambdabot>   True
07:28:37 <ManateeLazyCat> Anyway, i found gtk2hs is easiest way to build Haskell GUI program. Thanks all for help! :)
07:28:39 <BONUS> hmm. which extensions could we use to make Show a => (a -> r) -> r an instance of Show
07:29:41 <paolino> TypeInstances  ?
07:30:03 <paolino> TypeSynonymInstances
07:30:29 <EvilTerran> BONUS, how would you show a value of that type?
07:30:31 <BONUS> still you get bitten by the lack of generality
07:30:52 <BONUS> showCPStransformed a = a show
07:32:43 <edwardk> bonus: actually you need a function of (a -> r) to apply that type
07:33:00 <edwardk> bonus: i think you mean forall r. (a -> r) -> r
07:33:13 <BONUS> ah. right
07:33:25 <edwardk> bonus: then you can feed it an id
07:34:21 <edwardk> basically all that is saying is that you can derive an instance Show (f a) => Show (Yoneda f a) -- which iirc i've actually got implemented somewhere ;)
07:34:42 <BONUS> haha awesome
07:35:07 <bastl> hiho. Can I somehow simplify the predicate in " listify (\a -> (typeOf (undefined::MethodBody))==(typeOf a)) ast " ?
07:35:23 <bastl> @h listify
07:35:24 <lambdabot> Maybe you meant: hackage help hitchcock hoogle hoogle+ . ? @ v
07:35:33 <bastl> @hoogle listify
07:35:33 <lambdabot> Data.Generics.Schemes listify :: Typeable r => (r -> Bool) -> GenericQ [r]
07:35:43 <ManateeLazyCat> fasta: "Slava Pestov did that for Factor"? Factor is Haskell Graphics Toolkit base on X11?
07:36:21 <edwardk> hrmm: I don't have the generic one on Yoneda, just  instance Show a => Show (Ran Identity a) where showsPrec d (Ran f) = showParen (d > 10) $ showString "return " . showsPrec 11 (runIdentity (f Identity))
07:36:36 <edwardk> i'll add it
07:36:43 <fasta> ManateeLazyCat: no, he wrote a GUI using Factor (another programming language) based on a binding to some X11 library.
07:36:44 <BONUS> where do you have that
07:36:49 <edwardk> monad-ran
07:37:13 <edwardk> http://comonad.com/haskell/monad-ran/dist/doc/html/monad-ran/
07:37:29 <edwardk> its buried in the monolithic module that makes up that lib
07:37:41 <BONUS> ooh, cool
07:38:03 <edwardk> i think I want to rename Ran in there to 'CPS' or something
07:38:12 <edwardk> since the notation is wrong slightly
07:38:36 <ManateeLazyCat> fasta: And?
07:39:01 <ManateeLazyCat> fasta: I never heard Factor.
07:39:05 <ManateeLazyCat> fasta: :)
07:39:42 <ManateeLazyCat> http://factorcode.org/ ?
07:41:11 <edwardk> bonus: i'll add the Show instance for Yoneda and Codensity in there. i have ones or Ran Maybe, Ran (Either e), etc.
07:42:37 <BONUS> cool. looking at the source atm, nice stuff
07:44:49 <adrian___> hello
07:45:11 <adrian___> I'm trying to prove the fusion law for unfold, but I'm stuck
07:45:20 <adrian___> can anybody help me a bit?
07:45:20 <edwardk> @hpaste
07:45:21 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:46:05 <edwardk> BONUS: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4648#a4648
07:47:00 <fasta> Can I build a cabal package containing a binding to a C library with all debugging symbols still there?
07:47:25 <dcoutts_> fasta: hmm, try --gcc-options=-g
07:47:51 <dcoutts_> fasta: I mean when you do cabal configure
07:48:23 <BONUS> aah, i sort of get it :) nice
07:49:01 <mxc> i love this channel:  proving the fusion law followed by GCC options
07:49:11 <quicksilver> dcoutts_: you're spreading misinformation about hdbc and utf8 :P
07:49:18 <heltav> @type (->)
07:49:19 <lambdabot> parse error on input `->'
07:49:27 <dcoutts_> quicksilver: am I?
07:49:27 <heltav> @type (>>>)
07:49:29 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
07:49:32 <mxc> adrian__ sorry, as much as I respect type theory, category theory, etc.. i wont be much help
07:49:33 <fasta> dcoutts_: it's not in .cabal/config. Can I also put it there?
07:49:48 <quicksilver> dcoutts_: you're right that a UTF8 .hs file will get you a proper unicode String with an umlaut in it
07:49:51 <dcoutts_> fasta: um, no, not yet.
07:49:53 <quicksilver> dcoutts_: but that's not what HDBC wants/expects.
07:49:57 <heltav> > (1+) <$> Just 5
07:49:58 <lambdabot>   Just 6
07:50:03 <dcoutts_> quicksilver: John said it was.
07:50:03 <heltav> > (3*) <$> Just 5
07:50:04 <quicksilver> dcoutts_: HDBC is wanting a UTF8-where-Chars-are-really-Word8s
07:50:05 <lambdabot>   Just 15
07:50:11 <heltav> > (3*) <*> Just 5
07:50:13 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
07:50:15 <quicksilver> dcoutts_: HDBC doesn't encode Char to UTF8.
07:50:21 <mxc> so, whats the current state of affair for marshalling/demarshalling values?
07:50:26 <heltav> > <*> (+3) (Just 6) (Just 5)
07:50:27 <lambdabot>   <no location info>: parse error on input `<*>'
07:50:28 <quicksilver> dcoutts_: it expects them to be pre-encoded, i.e. really Word8s
07:50:38 <heltav> > <*> (+3) (Just 6)
07:50:39 <lambdabot>   <no location info>: parse error on input `<*>'
07:50:44 <dcoutts_> quicksilver: oh so HDBC is wrong then
07:50:45 <quicksilver> dcoutts_: it comes from a terrible old world before utf8-string was on hackage :)
07:50:48 <heltav> @type <$>
07:50:49 <fasta> dcoutts_: what would also be nice is to have the concept of "debug-builds" and "release-builds".
07:50:49 <lambdabot> parse error on input `<$>'
07:50:53 <heltav> @type (<$>)
07:50:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:50:56 <dcoutts_> quicksilver: that's not at all what I gathered from what John said
07:50:57 <quicksilver> dcoutts_: yes, it predates the existence of good encoding libraries. I think.
07:50:58 <heltav> @type (<*>)
07:50:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:51:05 <Jebdm> Perhaps less channel spam?
07:51:10 <heltav> > (3*) <*> Just 5
07:51:11 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
07:51:17 <quicksilver> dcoutts_: the possibility remains that my interpretation is wrong and yours is right ;)
07:51:20 <Ferdirand> heltav: lambdabot answers in private if you want
07:51:26 <dcoutts_> fasta: we can make configure -O0 also mean -g for C code
07:51:28 <heltav> > (1+) <$> Just 5
07:51:30 <lambdabot>   Just 6
07:51:40 <heltav> > (3*) <$> Just 5
07:51:41 <lambdabot>   Just 15
07:51:44 <quicksilver> dcoutts_: John said "Then you will get a String which is supposed to have decoded Unicode data, instead having encoded UTF-8 data.
07:52:11 <heltav> > (<$> (+1) (Just 5)
07:52:13 <lambdabot>   <no location info>: parse error on input `;'
07:52:16 <edwardk> heltav: /msg lambdabot > (1+) <$> Just 5 -- is your friend ;)
07:52:17 <heltav> > <*> (+1) (Just 5)
07:52:18 <lambdabot>   <no location info>: parse error on input `<*>'
07:52:19 <dcoutts_> quicksilver: right, I interpret that to mean String as a proper Unicode string.
07:52:26 <quicksilver> dcoutts_: and I interpret that to mean, he's expecting the String to be treated as [Word8] with UTF8 pre-encoded. Which is consistent with my belief that HDBC predates us getting sensible answers to all this encoding lark.
07:52:28 <heltav> > <*> (+) Nothing (Just 5)
07:52:29 <lambdabot>   <no location info>: parse error on input `<*>'
07:52:37 <heltav> > (+) <*> Nothing (Just 5)
07:52:38 <lambdabot>   Couldn't match expected type `Maybe t -> a -> a'
07:52:40 <dcoutts_> quicksilver: "encoded UTF-8 data" would be using [Char] as [Word8]
07:52:46 <heltav> > Nothing (+) <*> (Just 5)
07:52:47 <lambdabot>   Couldn't match expected type `(a1 -> a1 -> a1) -> f (a -> b)'
07:52:55 <heltav> > Nothing <*> (+) (Just 5)
07:52:56 <lambdabot>   Couldn't match expected type `Maybe a'
07:52:59 <heltav> ?
07:53:00 <edwardk> > (+) <$> Nothing <*> (Just 5)
07:53:02 <lambdabot>   Nothing
07:53:05 <dcoutts_> quicksilver: we've managed to read the same text is exactly the opposite ways :-)
07:53:08 <dcoutts_> is/in
07:53:08 <quicksilver> dcoutts_: yes, and that's what HDBC wants. Well, that's how I read him.
07:53:11 <quicksilver> dcoutts_: agreed ;)
07:53:26 <heltav> > (+) <$> Nothing (Just 5)
07:53:27 <lambdabot>   Couldn't match expected type `Maybe t -> f a'
07:53:34 <heltav> > (+) <$> Nothing <*> (Just 5)
07:53:36 <lambdabot>   Nothing
07:53:37 <edwardk> ^- that is the er 'idiom' i think you were looking for
07:53:42 <heltav> > (+) <$> (Just 2) <*> (Just 5)
07:53:44 <lambdabot>   Just 7
07:53:49 <heltav> > (+) <$> (Just 2) <*> Nothing
07:53:50 <lambdabot>   Nothing
07:53:56 <heltav> why Nothing?
07:53:56 <dcoutts_> quicksilver: which just goes to show how confusing this thing is, that we can't even describe it properly
07:53:58 <edwardk> no need for the parentheses in there on (Just 2)
07:54:10 <quicksilver> dcoutts_: Hmm. His later message suggests your version. In which case sorry for my confusion ;)
07:54:18 <quicksilver> "the SqlByteString is assumed to be in UTF-8, and
07:54:19 <quicksilver> is decoded when converted to a String"
07:54:35 <edwardk> because Nothing `ap` x = Nothing. and x `ap` Nothing = Nothing
07:54:55 <edwardk> Nothing is mzero, mzero laws kick in basically
07:55:29 <edwardk> or in applicative terms Nothing = empty for the Maybe Alternative.
07:56:17 <edwardk> > ((+) <$> pure 12 <*> empty) :: Maybe Int
07:56:18 <lambdabot>       Ambiguous occurrence `pure'
07:56:18 <lambdabot>      It could refer to either `Control.Appl...
07:56:35 <edwardk> > ((+) <$> Control.Applicative.pure 12 <*> empty) :: Maybe Int
07:56:36 <lambdabot>       Ambiguous occurrence `empty'
07:56:37 <lambdabot>      It could refer to either `Text.Pretty...
07:56:41 <edwardk> suck
07:56:50 <edwardk> > ((+) <$> Control.Applicative.pure 12 <*> Control.Applicative.empty) :: Maybe Int
07:56:51 <lambdabot>   Nothing
07:56:56 <edwardk> better =)
08:04:51 <heltav> damn i still love coding but computer games dont really interest me anymore. music does but there already is last.fm and winamp. i love photography but there already is Flickr.
08:05:01 <heltav> what the hell should I program? im tyring to come up with somethin cool
08:05:15 <heltav> what kind of cell-phone app would you peoplelike?
08:05:35 <edwardk> heltav: a lambdabot iphone plugin =)
08:05:43 <leadnose> one that makes farting noises
08:06:07 <The-Kenny> leadnose: That exists already :D
08:06:09 <DBAlex> askell
08:06:13 <DBAlex> oops
08:06:23 <DBAlex> how can I define this using map: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4649#a4649
08:06:35 <quicksilver> DBAlex: you can't.
08:06:38 <leadnose> The-Kenny, I know :(
08:06:56 <DBAlex> yeah
08:06:57 <edwardk> dbalex: you can't
08:06:57 <quicksilver> it takes a list of length 10 to a list of length 5, for example
08:07:03 <quicksilver> map always preserves length.
08:07:14 <DBAlex> can I use foldl ?
08:07:16 <DBAlex> or something else
08:07:21 <edwardk> dbalex: you can make it into a fold if you want to turn your brain inside out
08:07:25 <edwardk> i'd recommend foldr
08:07:29 <The-Kenny> An application to talk to other people would be really cool, I really miss that ;) :p You could assign every client a special number, which you have to type in to talk to this person.
08:07:30 <EvilTerran> or an unfold
08:07:30 <DBAlex> ok
08:07:33 <The-Kenny> ;)
08:07:39 <DBAlex> is it easier just to leave it as it is?
08:07:43 <edwardk> an unfold is easier
08:07:46 <quicksilver> it's not worth turning it into a fold except for the intellectual exercise.
08:08:01 <edwardk> yeah
08:08:03 <quicksilver> hint - there are two possible states, starting a new pair and finishing the last pair
08:08:08 <quicksilver> yoru fold has to flip-flop between them
08:08:09 <edwardk> though you're partial
08:08:19 <sm> ooh! Platform release!
08:08:19 <edwardk> what do you do with ltotable [x] ?
08:08:45 <DBAlex> edwardk: eturn $ ltotable $ lines f
08:08:50 <DBAlex> edwardk: return $ ltotable $ lines f
08:09:11 <DBAlex> f is something like "Coffee\n1.00\nTea\n2.00" etc
08:09:21 <DBAlex> > lines  "Coffee\n1.00\nTea\n2.00"
08:09:23 <lambdabot>   ["Coffee","1.00","Tea","2.00"]
08:09:30 <DBAlex> yup :)
08:09:34 <edwardk> dbalex: i'm just poinging out that you get screwed if you have:
08:09:41 <edwardk> > lines  "Coffee\n1.00\nTea\n2.00\n"
08:09:43 <lambdabot>   ["Coffee","1.00","Tea","2.00"]
08:09:53 <edwardk> > lines  "Coffee\n1.00\nTea\n2.00\n "
08:09:54 <lambdabot>   ["Coffee","1.00","Tea","2.00"," "]
08:09:59 <edwardk> there =)
08:10:03 <DBAlex> yeah but it won't happen
08:10:09 <DBAlex> unless someone messes with the database file... ;P
08:10:15 <DBAlex> then thats there issue ;)
08:10:32 <edwardk> dbalex: just pointing out that your method was partial is all
08:10:38 <DBAlex> yup
08:10:51 <DBAlex> I don't think I have to do extensive error checking
08:11:21 <DBAlex> so yeah, is it not easy to define that using fold?
08:11:35 <edwardk> nope, unfold is easy, fold is hard
08:11:43 <edwardk> fold can only see a level at a time basically
08:12:22 <david_> I'm doing a problem on projecteuler and I've tried running my solution for about 7 hours now and it hasn't completed yet. Is there a way of "profiling" my code (see for example what Ordo it is)?
08:13:17 <edwardk> dbalex: there is a way to encode it as a nice futumorphism, but that is a lesson for another day ;)
08:13:29 <DBAlex> ok
08:13:42 <byorgey> david_: there are ways to do profiling, but that's more for fine-tuning performance.  I'd suggest just coming up with a more efficient algorithm.
08:13:46 <DBAlex> just seems silly, I thought it would be easy to wrap that up in a nice map or fold
08:13:47 <DBAlex> :'(
08:14:02 <Berengal> > let itotable = uncurry zip . (map snd***map snd) . partition (odd.fst) . zip [1..] in itotable [1..10]
08:14:03 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10)]
08:14:16 <byorgey> david_: you probably won't be able to get more than, say, a 2x or 3x speedup from taking advantage of the profiling info.
08:14:36 <david_> byorgey: mkay
08:15:24 <dbueno> byorgey: if there are several algorithms involved, it might help pinpoint the one which ought to be made asymptotically faster, though.
08:15:38 <edwardk> > let f (x:y:ys) = Just ((x,y),ys); f _ = Nothing in unfoldr f [1,2,3,4]
08:15:39 <lambdabot>   [(1,2),(3,4)]
08:15:57 <byorgey> dbueno: well, I suppose that's true.
08:16:32 <byorgey> hmm, is haskell.org down?
08:16:41 <quicksilver> david_: the basic point of project euler is that you need a little mathematical thought ot think of a slightly cleverer way to do it.
08:16:56 <byorgey> I guess it's just really slow.
08:16:59 <wli> I'm still bombing problem #216.
08:17:00 <quicksilver> david_: if your program takes longer than a few seconds, then you have missed a better way.
08:17:03 <Zao> byorgey: Seems somewhat unresponsive.
08:17:19 <edwardk> > unfoldr (\x -> do (x:y:ys) <- return x; return ((x,y),ys)) [1,2,3,4]
08:17:20 <lambdabot>   [(1,2),(3,4)]
08:17:30 <edwardk> yay obfuscation
08:21:12 <edwardk> , unfoldr (\(return -> f) -> do (x:y:ys) <- f; return ((x,y),ys)) [1,2,3,4] -- worse with view patterns
08:21:13 <lunabot>  luna: parse error (possibly incorrect indentation)
08:21:43 <edwardk> , unfoldr (\(return -> f) -> do (x:y:ys) <- f; return ((x,y),ys)) [1,2,3,4]
08:21:44 <lunabot>  [(1,2),(3,4)]
08:22:26 <Berengal> luna doesn't handle comments?
08:22:32 <edwardk> apparently
08:22:40 <edwardk> , 1 -- why luna?
08:22:41 <lunabot>  luna: parse error (possibly incorrect indentation)
08:23:25 <EvilTerran> , () {- but this should work -}
08:23:26 <lunabot>  ()
08:24:43 <lukeo05> Is there an opposite to show. As in, once I have called show on an expression, can I "unshow" the string to get the expression back?
08:24:59 <edwardk> so i just need to make my parenthetical asides more parenthetica
08:25:05 <Berengal> lukeo05: read
08:25:07 <edwardk> > read "12" :: Int
08:25:08 <lambdabot>   12
08:25:24 <DBAlex> by the way, with something like this: x /= Nothing = snd $ fromJust $ x
08:25:31 <edwardk> i always thought the inverse of show would be something more like "hide" =)
08:25:32 <DBAlex> why do I have to use $ instead of . ?
08:25:53 <edwardk> x /= Nothing = snd . fromJust $ x -- will work
08:26:06 <edwardk> x is an argument, not a function in the chain
08:26:07 <lukeo05> Berengal: Nice one. Will this work with more complicated types like a list of tuples?
08:26:34 <edwardk> but there you could simplify that down since the last $ is silly
08:26:36 <DBAlex> ok
08:26:37 <Berengal> lukeo05: It should, but not all types. It depends on how they've defined read and show
08:26:37 <edwardk> x /= Nothing = snd $ fromJust x
08:26:42 <david_> quicksilver: easier said than done :)
08:26:44 <zcvvc> > read "(2,3)" :: (int, Int)
08:26:45 <lambdabot>       Could not deduce (Read int) from the context ()
08:26:45 <lambdabot>        arising from a u...
08:26:49 <zcvvc> > read "(2,3)" :: (Int, Int)
08:26:50 <lambdabot>   (2,3)
08:27:16 <lukeo05> Excellent. Thanks!
08:27:43 <Berengal> > read.show $ [1..10] :: [Int]
08:27:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
08:27:59 <edwardk> lukeo05: this leads to an important rule, when defining your instances of Show, they should (almost) always generate haskell source, so that you could generate a version of Read for them to match
08:28:47 <edwardk> some instances violate this guideline, i.e. ParseError in Parsec, etc. but think hard before you do
08:28:51 <Berengal> deriving (Show, Read) always produces compatible instances, no?
08:28:58 <edwardk> Berengal: yeah
08:31:15 <Jebdm> Is there a version of filter in the standard library/prelude that returns a pair of lists (a, b) where a is the list of those that matched the predicate and b is the list of those which didn't?
08:31:36 <EvilTerran> ?hoogle partition
08:31:36 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
08:31:37 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
08:31:37 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
08:31:39 <edwardk> > partition (>4) [1,5,12,2]
08:31:40 <lambdabot>   ([5,12],[1,2])
08:31:49 <Berengal> @type partition
08:31:50 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:32:03 <Jebdm> ah, thanks.
08:32:41 <edwardk> this channel is funny, ask a question, get 3 answers each covering the type, a use case and other functions like it ;)
08:33:24 <Jebdm> Where's the generic one defined?
08:33:27 <fasta> edwardk: ok, let's test that.
08:33:33 <fasta> What's omega for Haskell?
08:33:34 <edwardk> Data.List
08:33:45 <Jebdm> Danke schГ¶n
08:33:55 <Berengal> They're all equally generic...
08:34:18 <Berengal> Well, IntMap is anyway
08:35:02 <edwardk> fasta: clearly http://hackage.haskell.org/packages/archive/control-monad-omega/0.3/doc/html/Control-Monad-Omega.html
08:35:04 <edwardk> =)
08:38:06 <Neun>  /msg lambdabot @type all
08:49:58 <billls> If anyone would be kind enough to take a look at my code and throw me some pointers, i'd be very greatful. Highlighted parts don't work/don't work properly http://foxyurl.com/1Gg
08:52:40 <mxc> billls  - get my msgs?
08:52:47 <billls> nope
08:52:56 <neurocyte> can anyone explain to me why this is true: show (fromJulian 2009 01 01) == "2009-01-14"
08:53:44 <beelsebob> because julian dates are 13 days out of sync with gregorian?
08:53:51 <billls> mxc:  no. just now or yesterday ?
08:54:03 <mxc> just resent
08:54:04 <Jebdm> neeurocyte: http://en.wikipedia.org/wiki/Julian_calendar#From_Julian_to_Gregorian
08:54:20 <Jebdm> "During this time the Julian calendar continued to diverge from the Gregorian. In 1700 the difference became 11 days; in 1800, 12; and in 1900, 13, where it will stay until 2100."
08:54:51 <beelsebob> the julian calendar gets leap years wrong neurocyte
08:54:58 <beelsebob> this causes it to drift a day every hundred years
08:55:09 <Deewiant> Except every 400 years
08:55:13 <beelsebob> yep
08:55:42 <quicksilver> @hoogle fromJulian
08:55:43 <lambdabot> Data.Time.Calendar.Julian fromJulian :: Integer -> Int -> Int -> Day
08:55:43 <lambdabot> Data.Time.Calendar.Julian fromJulianYearAndDay :: Integer -> Int -> Day
08:58:42 <int-e> what's up with code.haskell.org?
09:01:14 <ScriptDevil> Is it recommended to name the constructor of a data type with only one member like data Foo = Foo String ?
09:01:31 <Jebdm> yup
09:02:11 <EvilTerran> well, it's a matter of personal style, context, etc
09:02:23 <quicksilver> some people opt for data Foo = MkFoo String
09:02:39 <Jebdm> at the very least, it's very common.
09:02:40 <EvilTerran> if you think it makes sense in your situation, go for it, we're not gonna lynch you for it or anything ;)
09:02:50 <quicksilver> but I would say "most" people use data Foo = Foo String
09:03:31 <paolino> uhm question was data Foo = Foo String | Base , i think
09:03:40 <saml> can i write a function f that takes a function g and converts g so that it'll be evaluated eagerly?
09:03:57 <saml> let f g = f $! g   only does eager evaluation on 1st argument
09:04:09 <leimy> > cycle [1,2,3]
09:04:11 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
09:04:19 <EvilTerran> saml, why do you want this?
09:04:35 <quicksilver> saml: "so g will be evaluated eagerly" ?
09:04:39 <quicksilver> saml: what does this mean, exactly.
09:04:42 <saml> EvilTerran, for fun
09:04:49 <quicksilver> saml: functions are in WHNF as long as they have a visible lambda
09:04:50 <QP> hey Evil
09:04:56 <quicksilver> so functions are generally evaluated.
09:05:01 <EvilTerran> Control.Parallel.Strategies has some cunning trickery for forcing things in various way
09:05:03 <EvilTerran> s
09:05:05 <EvilTerran> o hai QP
09:05:11 <saml> let g a b c = ...;    (f g) should be eager version of g
09:05:20 <quicksilver> saml: No.
09:05:51 <quicksilver> although if you fix the number of parameters, you could say
09:05:57 <QP> general question: what graphics packages would people recommend for ghc with the ubuntu linux distribution?
09:06:05 <quicksilver> f g a b c = a `seq` b `seq` c `seq` g a b c
09:06:46 <ScriptDevil> QP: you mean like hopengl?
09:06:57 <ScriptDevil> or is it hgl?.. :-/
09:07:18 <saml> :t sqe
09:07:19 <lambdabot> Not in scope: `sqe'
09:07:30 <ScriptDevil> :t seq
09:07:31 <lambdabot> forall a t. a -> t -> t
09:07:36 <QP> i just switched from windows. I was using opengl and GLUT
09:07:39 <quicksilver> but that only reduces a b and c to WHNF
09:07:46 <quicksilver> and really, I don't know what you meant by 'eager'
09:08:10 <ScriptDevil> quicksilver: !lazy ;)
09:08:43 <quicksilver> that's not very meaningful.
09:08:52 <EvilTerran> ScriptDevil, eh, there's a universe of evaluation semantics that're neither strict nor lazy, iirc
09:09:02 <quicksilver> if my program crashes every time wiht (error "my hovercraft is full of eels")
09:09:09 <quicksilver> then that is certainly *not* lazy evaluation.
09:09:15 <quicksilver> however, I don't that's what saml meant.
09:09:27 <fasta> saml: rnf is probably what you want.
09:09:53 <EvilTerran> QP, well, you can def keep using openGL. i don't know if GLUT'll still work, although it probably will
09:10:31 <roconnor> > error "my hovercraft is full of eels"
09:10:31 <EvilTerran> IIRC, glut isn't really being developed any more; you can use gtk (via gtk2hs) to make a window to put your openGL graphics in, though
09:10:32 <lambdabot>   * Exception: my hovercraft is full of eels
09:11:46 <dbueno> question: is there any way to use the latest QuickCheck (2) to run tests without printing all that junk on stdout?
09:12:02 <quicksilver> glut works fine under linux.
09:12:54 <QP> well, I haven't been able to get glut to work so far...
09:13:24 <quicksilver> what problem have you had?
09:13:30 <quicksilver> probably you just need to install it :P
09:13:35 <quicksilver> freeglut3-dev
09:13:39 <quicksilver> or some similar package name.
09:14:07 <heltav> no cool software is needed anymore :(
09:14:26 <saml> > fix ($!) 1
09:14:29 <QP> i don't recall needing to install it for windows... sorry I'm not very good with graphics stuff.
09:14:41 <lambdabot>   thread killed
09:15:05 <quicksilver> QP: it might have been bundled with your windows installer.
09:15:09 <QP> em, it sounds like gtk+ is the standard GUI interface type thing for linux?
09:15:24 <quicksilver> QP: whether you can install a package or not has nothing to do with whether you are good with graphics stuff.
09:15:37 <quicksilver> however, I woudl say, you are not going to manage to do anything at all with linux
09:15:41 <quicksilver> if you don't know how to install packages.
09:15:45 <ScriptDevil> Is there any way of declaring variables in ghci without lets.... and can one declare data types there at all?
09:15:48 <QP> yes, but knowing which package it is is
09:15:51 <quicksilver> ScriptDevil: no.
09:15:57 <quicksilver> QP: freeglut3-dev maybe.
09:16:11 <quicksilver> alternatively, use your distributions search tool to search for pacakges with glut in the name.
09:16:14 <quicksilver> which distribution is it?
09:17:18 <QP> i told you, ubuntu... anyway the reason i'm asking what people recommend is because i don't want to install glut if there is an option that works better with linux
09:17:51 <saml> glwf?
09:17:56 <quicksilver> QP: glut is a good option.
09:18:05 <quicksilver> QP: especially if you have already used it in windows.
09:18:07 <quicksilver> you will know what you're doing.
09:18:17 <QP> in a manner of speaking..
09:18:26 <QP> :-)
09:18:46 <quicksilver> under ubuntu you shoul dbe able to just install libghc6-glut-dev
09:18:52 <quicksilver> and that will pull in the dependencies for you
09:22:15 <ScriptDevil> ScriptDevil: Cant one declare a new data type in ghci? I am sorry I am re-asking. But I am unsure if the no was for both the questions or only the first one
09:24:46 <saml> > data X = X
09:24:47 <lambdabot>   <no location info>: parse error on input `data'
09:24:56 <saml> it doesn't work yet
09:25:40 <Saizan> ScriptDevil: ghci doesn't accept declarations, you've to put those in a file
09:25:59 <Saizan> ScriptDevil: you can use :r to reload the loaded files if you modify them
09:29:26 <ScriptDevil> Saizan: Ok :)
09:36:45 <edwardk> i think i have a selling point for the TIG parser
09:38:02 <edwardk> it should do reparsing after local updates in a fingertree in O (log (nL^2)) where L is between n and n^4 -- but regardless thats O(log n)
09:38:47 <edwardk> hrmm, that should probably be bigger, thats strange
09:39:15 <edwardk> ugh it may be O (L^2 log n) n/m =)
09:39:56 <edwardk> but that does mean for some grammars it can reparse after local update in O(n log n)
09:40:31 <roconnor> is this for yi?
09:40:53 <edwardk> and that L can be pretty small for practical grammars since its proportional to the 'if you started at a random point in the file, what states could you be in now'
09:41:07 <edwardk> nah, its for my parsing lib
09:41:49 <edwardk> whoa big split
09:42:21 <ScriptDevil> edwardk: yeah, I thought I was kicked
09:43:17 <edwardk> roconnor: basically i've got a parser combinator set for recognizing CFGs/TIGs that could be extended to a parser combinator set for TAGs
09:44:16 <Berengal> @users
09:44:16 <lambdabot> Maximum users seen in #haskell: 658, currently: 386 (58.7%), active: 9 (2.3%)
09:44:37 <mornfall> Berengal: Freenode fell apart.
09:44:45 <Berengal> I noticed...
09:44:47 <edwardk> man, haskell is really losing popularity these days. It must be Harrop.
09:45:08 <mornfall> (Like, totally. At least 3 servers lost connectivity to main network, it seems...)
09:46:08 <nominolo> @seen swiert
09:46:08 <lambdabot> I saw swiert leaving #haskell 3m 16d 1h 19m 49s ago, and .
09:46:18 <nominolo> hm...
09:47:01 <edwardk> hrmm. never saw this one before http://portal.acm.org/citation.cfm?id=991794
09:47:05 --- mode: irc.freenode.net set +o ChanServ
09:48:00 <edwardk> oh nevermind: Our parsing scheme can handle the most general class of context free grammars except cyclic grammars -- nevermind
09:52:43 * ksf wants better errors on nearly-correctly spealed identifiers
09:53:00 <copumpkin> eww: http://www.justsoftwaresolutions.co.uk/files/designing_mt_programs.pdf
09:56:32 <ksf> Error: Could not locate module "Control.applicativ". Did you mean "import Control.Applicative"?
09:58:21 <ksf> once in a century i want to open a ghc ticket, and ever single time trac is so sluggish it could as well be down.
09:59:02 <omnihil> every single time? how many centuries have you been using ghc now?
09:59:29 <ik> That means if it takes less than a hundred years to load, it's workable :)
10:02:02 <GoodBye> Hello DCC SEND "0101010101010101" 0 0 0
10:04:05 <Zao> ?where ops
10:04:06 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Phillipa bos arjanb psnl lispy xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver
10:04:06 <lambdabot> mauke
10:04:12 <ksf> code.haskell.org seems down, too.
10:04:29 --- mode: ChanServ set +o glguy
10:04:30 --- mode: ChanServ set +o allbery_b
10:04:31 --- mode: glguy set +b *!*@85.249.223.13
10:04:42 --- mode: glguy set -o glguy
10:04:52 --- mode: allbery_b set -o allbery_b
10:06:28 --- mode: ChanServ set +o glguy
10:06:30 --- mode: glguy set -b *!*@85.249.223.13
10:06:33 --- mode: glguy set -o glguy
10:16:09 <DBAlex> lol
10:16:18 * DBAlex looks at scrollback
10:16:24 <DBAlex> freenode borked?
10:18:11 <edwardk> hrmm
10:18:34 <edwardk> playing with how my parser combinators work if i limited myself to LL(k)
10:18:45 <gio123> does this snetence wrt english looks OK?
10:18:55 <gio123> where $t2$ is a term without variables (ground term)
10:19:19 <gio123> ... where $t2$ is a term without variables (ground term)...
10:19:50 <edwardk> gio123: that sentence fragment is fine, though perhaps replacing without with 'that does not contain'
10:20:44 <DBAlex> btw
10:20:50 <DBAlex> has anyone here played with F#?
10:21:01 <DBAlex> looks to me just like a diluted version of haskell
10:21:14 <orbitz> DBAlex: dilued Ocaml
10:21:20 <DBAlex> ah ok
10:21:25 <DBAlex> and that list formatting is odd :S
10:21:25 <glguy> as FP languages go, it is nothing like Haskell
10:21:31 <orbitz> neil mitchel has soem decent posts about ti
10:21:42 <orbitz> ask Jon Harrop about it
10:21:42 <DBAlex> does he have a blog or something?
10:21:44 <orbitz> :)
10:21:46 <DBAlex> :P
10:21:48 <orbitz> yes
10:22:06 <DBAlex> I heard Jon Harrop doesn't care much for haskell ;P
10:22:21 <dons> he doesn't care much for your language :)
10:22:24 <orbitz> I don't nkow his complete opinion, last i heard he found it lackign in areas he was interested in
10:22:28 <edwardk> f# is basically ML without modules bolted onto .NET. its great if thats what you're looking for.
10:22:29 <DBAlex> well from his stack overflow postsings anyways ;)
10:22:33 <DBAlex> *postings
10:22:43 <edwardk> the 'without modules' makes it a bit of a non-starter for me though
10:23:03 <DBAlex> ok
10:23:13 <orbitz> edwardk: so no Functors?
10:23:15 <DBAlex> does it have nice intergration with e.g. WinForms etc?
10:23:25 <DBAlex> do you think it would be easy to pick up if I only know haskell?
10:23:28 <DBAlex> and worth it...?
10:23:28 <edwardk> orbitz: nada
10:23:37 <orbitz> DBAlex: the chagnes they have made to Ocaml facilitate integrating with teh rest of teh CLR or wahtever easily
10:23:52 <DBAlex> ok
10:24:05 <orbitz> F# reminds meof Scala, in the senseof: if you are stuck on tha tplatform, it's probably better than your alternatives, but i probably wouldn't write my own projects in it
10:24:07 <edwardk> dbalex: its good if you want to do .net things like write a desktop app or build a asp.net web page, etc. and you really really want a language with pattern matching
10:24:15 <heltav> intellectual honesty:
10:24:15 <heltav> <honest discussion is here> <here be middle> <here be liars,lawyers and other scum> <here be jon harrop>
10:24:25 <orbitz> heltav: haha
10:24:39 <DBAlex> edwardk: ok
10:24:46 <edwardk> heltav nice map. i notice you drew it on a log scale ;)
10:24:50 <DBAlex> edwardk: but haskell has modules for most things
10:24:50 <orbitz> is harrop known for being dishonest?  he always just struck me as incredibly pedantic to the poitn of imrpacticality
10:24:55 <DBAlex> just I can't get them working! :P
10:24:59 <DBAlex> (wxWidgets)
10:25:16 <edwardk> DBAlex:haskell modules are not modules, they are basically a namespacing convention. ML modules are what ML uses to get 'typeclass' like stuff
10:25:32 <DBAlex> ok
10:26:05 <edwardk> DBAlex: F# modules are as crippled as Haskell modules, but without ML modules to reclaim the missing power of typeclasses its a painful loss
10:26:08 <DBAlex> so is ML a lot different to haskell?
10:26:24 <DBAlex> does ML use lazy evaluation?
10:26:25 <orbitz> which ML?
10:26:35 <DBAlex> oh :(
10:26:36 <orbitz> all of teh ML's i have used are strict
10:26:37 <edwardk> dbalex: ML is defined by strict semantics usually
10:26:40 <orbitz> and allow side effects
10:26:46 <Berengal> sml has lazy structures last I checked
10:26:55 <edwardk> DBAlex: there are of course toy researchy lazy ml's out there
10:27:00 <DBAlex> ok
10:27:05 <Berengal> Well, lazy if you declare them as such
10:27:18 <edwardk> Berengal: having a delay and force around isn't really 'lazy' as haskellers would think it
10:27:20 <rieux_> beregnal: SML/NJ has lazy datatypes.  SML just has force and delay
10:27:21 <lament> toy researchy lazy ml's, like haskell ;)
10:27:23 <leadnose> what would be the main differences between lazy ML and Haskell?
10:27:43 <DBAlex> btw
10:27:44 <edwardk> leadnose: elegance
10:27:50 <DBAlex> if a language isn't lazy
10:27:56 <saml> ghc can't compile ml
10:28:02 <DBAlex> does that mean you can't have (potentially) infinite lists?
10:28:07 <edwardk> leadnose: ml has a ton of distinctions like fun vs. val that aren't needed once you are lazy
10:28:20 <DBAlex> and isn't that a pain
10:28:22 <edwardk> DBAlex: not without using a lazy data type or an explicit delay/force
10:28:41 <DBAlex> :(
10:28:46 <edwardk> DBAlex: people lived with it for decades before the learned haskell ;)
10:28:51 <edwardk> er they
10:28:53 <orbitz> DBAlex: most langauges aren't lazy
10:29:01 <Berengal> You could always code the lazyness explicitly...
10:29:03 <DBAlex> I know ;P
10:29:21 <edwardk> Berengal: and i could always write everything in assembly =)
10:29:25 <rieux_> edwardk: in SML/NJ you can actually declare you constructors to be lazy, so you then don't need force/delay: http://www.cs.cmu.edu/~rwh/introsml/core/lazydata.htm
10:29:31 <Berengal> For some reason strict functional languages irk me somewhat
10:29:31 <saml> > [1 ..] ! 2381923749781238946134891736412789346981784195423142
10:29:31 <lambdabot>   Couldn't match expected type `Array i e'
10:29:38 <Berengal> edwardk: People used to do that, you know...
10:29:45 <edwardk> rieux_: yeah hence my 'or' in that statement =)
10:29:54 <edwardk> Berengal: yeah i was one of them, i grew up
10:30:10 <rieux_> edwardk: missed that
10:31:08 <DBAlex> some guy I know still writes x86 assembly...
10:31:28 <DBAlex> although i'm starting to wonder whether he just doesn't trust compilers for some odd reason
10:32:11 <wli> Eh? Kernel hackers have to write asm all the time.
10:32:15 <leadnose> I'm k
10:32:22 <leadnose> oops
10:32:24 <rieux_> and compiler back-end writers
10:32:38 <DBAlex> yeah but he's neither
10:32:39 <Deewiant> I guess it was more about writing "everything" in assembly
10:32:48 <TomMD> Does HUnit have no test vector generation capability (like QuickCheck Arbitrary)
10:32:48 <Deewiant> Than just the bits that need to be :-)
10:32:58 <wli> Compilers don't emit privileged instructions (and nothing corresponds to them in most/all programming languages, too).
10:33:12 <p_l> Well, I heard that some projects profit heavily from hand-optimized assembly
10:33:35 <DBAlex> whats the point in writing a compiler tho, probably easier to translate to asm then let something like gas do the compilation
10:34:07 <pejo> (General comment about infinite lists, etc) Many of the strict fp's have extensions that give some of the power of laziness.
10:34:14 <rieux_> DBAlex: that's called a compiler
10:34:24 <dev312> can anyone recommend a good learning resource, tutorial, ebook on HDBC?
10:34:26 <DBAlex> rieux_: ? really
10:34:36 <edwardk> The Koan of Lazy Evaluation: Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced вЂњTodayвЂ™s lecture will be about Lazy EvaluationвЂќ, he paused for a moment then concluded with, вЂњAre there any questions?вЂќ
10:34:46 <DBAlex> rieux_: I thought real compilers did the last bit too
10:35:11 <DBAlex> hehe
10:35:23 <mle> DBAlex: compilers only transform from one language to another.  Though obviously that last step can be integrated.
10:35:25 <dev312> hello :)
10:35:32 <saml> hi dev312
10:35:37 <dev312> hi saml
10:35:46 <wli> DBAlex: It depends. A fair number just invoke assemblers through a pipe, though.
10:35:50 <rieux_> DBAlex: no, i don't think anyone cares whether your compiler uses an assembler or not.  real compilers today often use someone else's intermediate language, but they're still compilers.
10:36:15 <DBAlex> mle: yup...
10:36:26 <DBAlex> wli: ah... see this was bugging me for a while
10:36:27 <dev312> saml, know much about HDBC?
10:36:33 <DBAlex> I didn't realise that compilers cheated too then
10:36:37 <saml> dev312, just googling it up.
10:36:42 <saml> http://software.complete.org/software/wiki/hdbc/ ?
10:36:45 <elias`> edwardk: Philip Wadler actually begins his lectures that way (at least tends to), just doesn't conclude them like that
10:37:07 <DBAlex> rieux_: aren't those more like languages that use the jvm or clr though?
10:37:25 <DBAlex> like boo, groovy etc
10:37:30 <wli> DBAlex: Some of them (MIPSpro IIRC) even separate out phases of translation/compilation into different programs that pass data to each other over pipes.
10:37:48 <rieux_> DBAlex: there are those, sure.  but also, you could compile to an intermediate language like LLVM or Cmm, which you immediately translate to native code
10:37:53 <dev312> sam, yeah thats it
10:37:56 <rieux_> DBAlex: or C, for that matter
10:38:19 <DBAlex> ok
10:38:24 <DBAlex> see I want to write a compiler
10:38:29 <DBAlex> maybe for my 3rd year project?
10:38:30 <ksf> oh, the joy. Error 500.
10:38:32 <dev312> ahh they have some example source code
10:38:36 <dev312> I think ill browse that
10:38:36 <dev312> thanks
10:38:37 <rieux_> have you written a compiler before?
10:38:41 <DBAlex> I don't know whether thats too ambitious
10:38:51 <DBAlex> I've written a logo interpreter
10:38:52 * ksf thinks trac should be scrapped and replaced with a haskell solution
10:38:53 <DBAlex> thats about it
10:39:03 <DBAlex> and a semi-complete basic interpreter
10:39:03 <rieux_> i don't know how long you have to spend on it, but it really depends on what kind of language you want to handle, and how well you want to do it
10:39:21 <ksf> DBAlex, c to redcode compiler?
10:39:31 <ksf> ...people would hate you, it'll be fun.
10:39:43 <DBAlex> heh
10:39:59 <edwardk> ksf: there is already a forth one iirc
10:39:59 <ksf> do we have a redcode backend for haskell?
10:40:02 <DBAlex> I was thinking more a subset of python compiler or something
10:40:15 <DBAlex> or create a simple language of my own then create a compiler
10:40:21 <rieux_> you could do that.
10:40:28 <p_l> hmm.. here, a compiler writing course is 3rd year thing
10:40:33 <ksf> you could add some jitting to an existing bytecode interpreter.
10:40:33 <edwardk> python is annoying to compile because too much is dynamic
10:40:54 <DBAlex> p_l: yeah we have something like it in the 2nd year, but it uses haskell...
10:40:58 <edwardk> i agree with ksf, jitting has a lot of the same flavor and is more immediately rewarding
10:41:14 <edwardk> look at the work on tracing jits, they are fun
10:41:18 <DBAlex> maybe haskell is good for writing compilers though
10:41:18 <mauke> the only compiler I've written translates brainfuck to OISC :/
10:41:21 <DBAlex> just seems daunting hehe
10:41:21 <edwardk> and they are straightforward to implement
10:41:27 <rieux_> DBAlex: it certainly is
10:41:30 <edwardk> and you only ever have to deal with a single superblock when compiling
10:41:37 <DBAlex> rieux_: even more so in haskell though
10:41:45 <DBAlex> i'd prefer to write mine in c
10:41:54 <ksf> you could work on lhc's grin backends.
10:42:03 <p_l> DBAlex: The most important thing is the theoretical part - you can write compiler in any language you want after you learn how to write them at all
10:42:28 <ksf> ...which basically means "write a quine generator, then get started"
10:42:30 <pejo> DBAlex, haskell is very nice for writing compilers. I don't understand why you want to write it in C though.
10:42:33 <rieux_> edwardk: do you mean writing a source language to bytecode compiler, or writing the JIT compiler?  the latter leaves out a lot of the fun stuff, IMO
10:42:43 <edwardk> ksf: heh, i took a look at it then realized i'd be better off trying to jit ghc's bytecode than to start over with lhc's grin
10:42:50 <DBAlex> pejo: because i'm crap at haskell...
10:43:17 <ksf> well, from all i could tell skimming the stuff, grin's a really fine thing to deal with.
10:43:18 <DBAlex> haskell takes me way longer to write than c etc
10:43:25 <edwardk> rieux_: yes but it lets you start generating results you can execute immediately which provides a nice feedback loop
10:43:30 <rieux_> DBAlex: that means you need practice
10:43:43 <ksf> as in no higher-order functions.
10:43:54 <mauke> just learn how to write C in Haskell :-)
10:44:09 <edwardk> ksf: unfortunately the STG-like calls are actually one of my best optimizations when doing a tracing jit ;)
10:44:11 <DBAlex> lol
10:44:19 <mauke> it's not that complicated, actually
10:44:24 <DBAlex> rieux_: yes, but where do I get the practice?
10:44:26 <edwardk> ksf: so grin defunctionalizing them removes a lot of the benefit i can provide
10:44:30 <ksf> DBAlex, you could also do me a favour and replace trac.haskell.org with a tracker implemented in haskell.
10:44:32 <rieux_> DBAlex: by writing a compiler
10:44:36 <DBAlex> are there any open source haskell projects that need helpers?
10:44:53 <DBAlex> they don't need to be compilers... i'm willing to work on anything... I have about 3 months off in the summer...
10:44:59 <edwardk> at the cost of closing the world, which i don't need. one nice thing about a jit is it helps iteratively approximate a 'closed world' compilation in an open world setting
10:45:09 <ksf> DBAlex, yi, leksah?
10:45:12 <DBAlex> maybe I could just do some of my own projects maybe
10:45:20 <DBAlex> ksf: leksah?
10:45:23 <ksf> or, preferrably, both, that is include yi into leksah
10:45:25 <ksf> haskell ide.
10:45:40 <ksf> then, get hare working again.
10:45:50 <DBAlex> ksf: hmmm ok
10:45:55 <c_wraith> you could make gtk2hs easy to install.  That would be astounding
10:45:56 <pejo> DBAlex, all haskell projects need helpers, basically. I think there's a lot of open improvement requests for cabal for example, or cabal-install.
10:46:10 <rieux_> edwardk: closed world?
10:46:13 <ksf> gtk2hs is easy to install, if you happen to be using gentoo.
10:46:26 <DBAlex> pejo: ok
10:46:35 <pejo> edwardk, you mean by specializing things that are known?
10:46:45 <DBAlex> pejo: would the code be understandable to someone who's only been programming haskell for about 2 months?
10:46:57 <edwardk> rieux_: grin requires that every function that can exist is known so it can define a closed 'eval' function
10:47:22 <rieux_> oh, okay.  i thought you were speaking more generally.
10:47:28 <pejo> DBAlex, the project euler problems are popular for practice I think. I really don't know how much one learns in 2 months.
10:47:52 <dev312> leksah is nice
10:47:54 <DBAlex> pejo: ok
10:47:54 <edwardk> rieux_: basically it just defines a huge case over all of the thunk types in the world and specializes it. this is great -- if it can show that only certain kinds of thunks can flow into certain situations the eval is just a quick case discriminating a much smaller set of cases
10:48:05 <dev312> learning haskell would be slower for me without it
10:48:12 <c_wraith> You can learn a lot of haskell in 2 months.  But project euler isn't good for much beyond wrapping your head around the syntax.
10:48:28 <DBAlex> maybe I should buy real world haskell
10:48:28 <c_wraith> Working on a real live system, which is what you're asking about, is a lot better.
10:48:31 <rieux_> edwardk: does it do CFA for that?   (i can't find what grin is)
10:48:43 <rieux_> found
10:48:46 <DBAlex> if I do all of the projects in there it could help with next years compilers stuff
10:48:52 <edwardk> rieux_: look up Urban Boquist's thesis
10:49:17 <DBAlex> ah leksah
10:49:19 <edwardk> rieux_: GRIN is a first order monadic language used behind LHC, UHC, and JHC.
10:49:23 <DBAlex> didn't know haskell had an IDE :)
10:49:49 <dev312> best thing about leksah is the library browser and automatic cabal managment
10:49:54 <dev312> Well not automatic
10:49:59 <dev312> but simplified
10:50:01 <DBAlex> did anyone here work on it then?
10:50:11 <wli> I have a lot of trouble with the Project Euler problems.
10:50:25 <edwardk> basically it can use 0-CFA type analysis to specialize cases, its nice in that it can do a LOT of optimizations because the world is closed
10:50:39 <mauke> I only solve the euler problems that can be brute forced
10:50:59 <arjanb> edwardk: you could also use a grin variant that has a builtin eval and apply so you don't need a closed world
10:51:03 <edwardk> its bad because its flipping expensive because its doing those optimizations everywhere AND it needs the whole world to do it
10:51:16 <edwardk> arjanb: actually i did for a while
10:51:30 <edwardk> arjanb: but without the primitive eval/apply it doesn't have much to do
10:51:41 <edwardk> arjanb: its just c-- with another syntax
10:51:44 <heltav> ksf: i could do that
10:51:47 <wli> I can't even get through a fair number of the brute-forcible ones.
10:51:47 <heltav> is that wanted?
10:51:52 <heltav> what does the tracker do?
10:52:19 <edwardk> arjanb: the reason why i like a tracing jit for haskell like languages is you can 'build' your eval up at runtime as local polyinline caches
10:52:20 <ksf> atm, nothing, it errors out with a 500.
10:52:40 <edwardk> arjanb: and get the general efficiency of grin style evaluation with a fast compile and an open world
10:52:41 <ksf> in general, tracking bugs and providing per-project wikis, roadmaps etc.
10:52:45 <Lemmih> arjanb: JHC does that.
10:53:02 <ksf> I don't even know who administers it.
10:53:49 <edwardk> i've been poking around with mmorrow trying to see if i can drop in a version of my tracing jit to replace ghc's bytecode interpreter.
10:54:13 <demolithion> ls
10:54:14 <ksf> you could probably just hack up gitit with some scripting and be done.
10:54:16 <demolithion> ups
10:56:59 <heltav> ksf: ok but is it a desired project or "just" you who have a little problemr ight now?
10:57:37 <ksf> I'd be surprised if it only errors out for me... but no, there hasn't yet been a general outrage.
10:57:39 <ivan-kanis> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4657
10:58:02 <ivan-kanis> i can't understand why I am getting a compile error when lining up if then else
10:58:25 <mauke> ivan-kanis: because there's a ';' before the 'then'
10:58:38 <mauke> 'if ... ; then' is a syntax error
10:59:26 <ivan-kanis> mauke: i don't see a ; ...
10:59:43 <mauke> it's invisible
10:59:51 <ivan-kanis> ah ok
10:59:53 <mauke> but that's how layout works
11:00:00 <ksf> no long-time imperative coders see the ;'s.
11:00:08 <mauke> if you start a new line and it's indented more, nothing happens
11:00:09 <ksf> they train you to ignore them.
11:00:17 <mauke> if it's indented the same, a ';' is inserted
11:00:23 <heltav> http://en.wikipedia.org/wiki/Trac
11:00:26 <mauke> if it's indented less, a '}' is inserted
11:00:29 <ksf> ...in a do block, that is.
11:00:31 <heltav> but hmm seems hard to compete with...
11:01:38 <arjanb> edwardk: i have experimented with translating grin to the jvm using methods for eval and apply, but many other jvm limitations made it very slow..
11:01:43 <mauke> ivan-kanis: your logic is broken
11:02:02 <edwardk> hahah old parser paper on parallel LR using Haskell =) http://www.aclweb.org/anthology-new/C/C90/C90-2053.pdf
11:02:32 <ivan-kanis> mauke: i am doing my best...
11:02:49 <ksf> heltav, it seems to be easy to compete with it performance-wise.
11:03:18 <ksf> and we already got templating and wiki.
11:03:57 <edwardk> although they only parallelize shift reduce conflicts
11:04:28 <ivan-kanis> ok, i have most examples of if then else all lined up, it shouldn't work?
11:05:31 <heltav> ksf: we do?
11:05:41 <ksf> we do.
11:05:47 <heltav> on hackage?
11:06:05 <ksf> gitit, and the happs-tutorial uses some sort of templating.
11:06:17 <ksf> gitit is pandoc-based.
11:07:22 <augustss> arjanb: I'm pretty sure you can do well with Haskell on the JVM, but I think requires getting rid of almost all h.o. functions.
11:07:58 <mauke> ivan-kanis: what do you think about http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4657#a4659 ?
11:08:16 <leadnose> getting rid of hof:s in haskell is not doing it well
11:08:24 <Elrood> does anybody know if there are binary versions of leksah available somewhere (win32) ?
11:08:36 <rieux_> edwardk: okay, this is cool.  it's sort of like 0CFA but it doesn't treat the heap as a free-for-all like shivers does.
11:08:48 <edwardk> rieux_: yeah
11:09:00 <augustss> leadnose: it's doable using whole program optimization (which I'm not a fan of)
11:09:29 <pejo> augustss, because of compilation times?
11:09:44 <augustss> pejo: yes
11:10:27 <rieux_> edwardk: is there any work on opening the world a little bit?  i can't see how you'd do that without kind of breaking the whole thing.
11:10:41 <xUSR> hello
11:10:45 <pejo> augustss, even if that's only necessary for the final binary?
11:10:50 <edwardk> i wish there was a nice monoid for control flow analysis. i.e., given this closed world and that closed world here is the smallest closed world containing them but i think the result would be too approximate
11:11:03 <wli> augustss: Lambda lifting?
11:11:19 <edwardk> rieux_: thats basically why i like the model of just working with a raw 'open world' and then jitting to close it back down
11:11:28 <xUSR> hey every one, I am using streamreader to read lines of a text file to a list box. the only problem is it's returning null characters to the listbox before each line. any suggestions?
11:12:04 <edwardk> rieux_: where a polyinline cache gets inserted for each eval and expands itself as it accumulates traces once its hot enough to deserve tracing
11:12:51 <dcoutts_> pejo: there was someone at FITA yesterday describing their whole-program ada compiler. It can currently cope with programs up to about 50kloc. Bigger and you run out of memory. While you could improve the factors there it's going to be a limitation for any whole program compiler.
11:13:06 <xUSR> hey every one, I am using streamreader to read lines of a text file to a list box. the only problem is it's returning null characters to the listbox before each line. any suggestions?
11:13:06 <rieux_> edwardk: is that the self stuff?
11:13:10 <mauke> xUSR: ECONTEXT
11:13:21 <xUSR> whats econtext?
11:13:21 <edwardk> rieux_: thats where it originated
11:13:24 <arjanb> augustss: getting rid of hofs isn't enough, updating, tail recursion and slow object creation are still a problem
11:13:29 <pejo> dcoutts, MLTon claimed to work for 100kloc programs in 2006 (ML workshop, invited talk by Stephen Weeks, but I didn't see the talk).
11:13:38 <edwardk> rieux_: but basically the idea comes into its own in a tracing jit
11:13:38 <mauke> xUSR: you have provided no context / this is a haskell channel. what are you talking about?
11:13:54 <xUSR> oh i thought this was a programming channel, im sorry
11:13:54 <dcoutts_> pejo: that's probably a lot better, ml programs tend to be shorter than ada ones :-)
11:14:09 <pejo> dcoutts, how many Haskell programs do we have that are a factor 4 larger than what the ada compiler could cope with?
11:14:16 <mauke> xUSR: haskell is a programming language
11:14:27 <edwardk> xUSR: it is, but its about programming in the Haskell language ;)
11:14:37 <augustss> arjanb: tail recursion can be mostly eliminated, I'm not sure why updating has to be a problem, but the slow object creation is a problem
11:14:37 <xUSR> oh i am sorry i did not realize
11:14:39 <dcoutts_> pejo: well, at least ghc and whatever it is that augustss hacks on
11:14:55 <edwardk> xUSR: no problem, common mistake
11:15:06 <xUSR> i am trying to complete a project in 2 hours and i cannot find a resolution to my issue so i was looking for real time chats
11:15:16 <pejo> augustss, hm, have you already gotten to >200kloc?
11:15:30 <Berengal> xUSR: You could just try dropping the null characters...
11:15:46 <xUSR> how so? i am using visual studio
11:15:55 <augustss> pejo: not at the new place.  but we had about 200kloc at the Credit Suisse before I left.
11:16:13 <pejo> dcoutts, I agree that long compilation times are a killer though, I was mainly trying to highlight that most of our programs are rather small.
11:16:14 <dcoutts_> pejo: also, dons talk the other day gave some figures for galois
11:16:24 <arjanb> augustss: updating is a problem because you need extra indirection and the gc can't remove it
11:16:28 <dcoutts_> pejo: only when you don't count the base libs :-)
11:16:36 <edwardk> rieux_: basically the trace records a path that has been taken through the code that starts and ends at the same instruction, which is basically a superblock. then you optimize just that path, pushing everything off onto side exits that you can. whenever it took an indirect jump you can back up and figure out where it loaded that jump from
11:16:57 <edwardk> rieux_: and case on the target using a polyinline cache, falling back on starting another trace from this point
11:17:02 <augustss> arjanb: hbc does updating without indirections
11:17:20 <edwardk> rieux_: and as it runs you iteratively turn your 'open world' into an 'all but closed world'
11:17:35 <edwardk> rieux_: at least for the paths that are hot enough to care about
11:17:39 <arjanb> augustss: you can't overwrite object reference in the jvm
11:18:07 <rieux_> edwardk: thanks . . . rereading.
11:18:12 <dcoutts_> arjanb: how do fields work then? arn't they object references?
11:18:20 <pejo> dcoutts, well, I don't have any measurements. Maybe you're right. I hope you're wrong though. :-)
11:18:22 <augustss> arjanb: huh?
11:18:59 <dcoutts_> pejo: it's probably doable for most progs and systems, just not the big ones
11:19:00 <arjanb> dcoutts: you can update fields but you need a wrapper object to create an updatable thunk
11:19:06 <augustss> arjanb: I'm not sure you can play the tricks necessary for updating objects in the jvm.  not having any control over the gc is a nuisance
11:19:23 <edwardk> rieux_: with enough information about thunks in the trace it can do more, i.e. if the thunk is always evaluated on the trace you can evalute it earlier, if no reference escapes the trace you can unbox it into registers
11:19:47 <dcoutts_> arjanb: I see
11:20:01 <edwardk> rieux_: but without the combinatorial explosion of trying to figure out WHERE to do that at compile time
11:20:15 <jeffersonheard> are non power-of-two textures supported in HOpenGL?
11:21:11 <ksf> my crystal ball saiz: depends on your gl drivers.
11:22:02 <rieux_> edwardk: this sounds like several of the standard static analyses, but done on-line.
11:22:14 <edwardk> rieux_: exactly =)
11:22:39 <edwardk> rieux_: its just a nice form for figuring out where they should be applied
11:22:50 <rieux_> edwardk: like, where they might matter.
11:23:37 <rieux_> edwardk: who's using this?
11:23:50 <edwardk> rieux_: erm, just me at the moment
11:24:33 <edwardk> rieux_: my tracing jit for my kata compiler uses, i'm trying to figure out the right way to hook in to do the same thing to ghc's bytecode directly
11:24:41 <edwardk> but i haven't pushed too hard at it yet
11:25:12 <rieux_> edwardk: kata?
11:25:37 <edwardk> to get good results out of ghc i'll probably have to transcode my tracing x86-64 jit so it can trace through native thunks as well
11:26:10 <augustss> edwardk: you can speed up native code by jitting too
11:26:14 <edwardk> rieux_: 'toy untyped haskell with other language features'
11:26:35 <edwardk> augustss: yeah. thats what i use it for in kata, i can trace right through glibc, etc.
11:27:34 <edwardk> augustss: it just has to be sound with respect to the semantics of what it traces, not complete. if it doesn't understand something it can always abort the trace.
11:27:37 <augustss> so tracing is probably one of those things where a little hardware support would be good
11:28:34 <augustss> edwardk: but completeness is only a matter of hard work
11:28:34 <edwardk> augustss: yeah. i do deep magic to start the trace and to result on an arbitrary instruction boundary when i fail to understand an opcode or the trace runs too long
11:28:44 <edwardk> augustss: yeah
11:28:47 <edwardk> augustss: well
11:29:09 <edwardk> augustss: i rely on certain properties of the ABI to do some practical optimizations that aren't even technically sound. ;)
11:29:27 <augustss> tsk, tsk :)
11:29:54 <edwardk> based on common layout of variables that would be written to the stack, the fact that array accesses are not likely to acces sboth an element in a bounded stack frame and something in another frame, etc.
11:30:03 <edwardk> otherwise i'd have to materialize every stack effect
11:30:55 <edwardk> without that i can feel free to just place the stuff on the stack during side exit to recover the system to a state that it expects, and i can feel free to shuffle basically anything in the meantime
11:31:33 <edwardk> the need for precise control over the stack usage, knowledge of exactly what gets pushed and popped when and where is what basically keeps me from using llvm in the jit
11:32:42 <edwardk> i can get some of that out of the 'red zone' used by the x86-64 abi, but its so big that i'd need a really long trace to discover that something really really isn't used
11:33:38 <edwardk> nicely since its an 'opt-in' jit that requires a little bit of code insertion to fire off, i get some things for free. i get some registers i know are mine at least  at the start of the trace bcause you called a function to start the trace
11:34:00 <edwardk> and i get the ability to pass options to this particular jit point. like how paranoid to be ;)
11:35:05 <edwardk> it does do some marvellous trace compression on standard library calls though
11:36:31 <vixey> @pl (\input -> f input `mplus` g input)
11:36:32 <lambdabot> liftM2 mplus f g
11:36:53 <edwardk> though, it currently it has a faulty model of what is 'constant' because it can only see the layout of the current process's memory map, it doesn't have a model that someone else can modify the data contained in an area that has been mapped read only into this process, but read/write in another
11:36:57 <vixey> @pl on (\input -> (un f) input `mplus` (un g) input)
11:36:57 <lambdabot> on (ap (mplus . un f) (un g))
11:37:01 <conal> vixey: maybe even just mplus.
11:37:07 <edwardk> otoh, if you need that, throw it a flag not to constant fold
11:37:22 <conal> @src IO MonadPlus
11:37:23 <lambdabot> Source not found. There are some things that I just don't know.
11:37:23 <rieux_> seems like you'd know
11:37:25 <conal> @src MonadPlus IO
11:37:25 <lambdabot> Source not found. Maybe you made a typo?
11:37:34 <vixey> @src mplus (->)
11:37:34 <lambdabot> Source not found. Just try something else.
11:37:39 <vixey> @src (->) mplus
11:37:39 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:37:55 <roconnor> @src mplus []
11:37:55 <lambdabot> Source not found. Take a stress pill and think things over.
11:38:00 <roconnor> @src [] mplus
11:38:00 <conal> oh -- silly me.  (IO wtf?)
11:38:01 <lambdabot> mplus = (++)
11:38:16 <vixey> @src ((->)e) mplus
11:38:16 <edwardk> mplus there is m `mplus` n = m `catch` \_ -> n
11:38:16 <lambdabot> Source not found. My mind is going. I can feel it.
11:38:24 <vixey> @src -> mplus
11:38:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:38:37 <roconnor> @instances MonadPlus
11:38:38 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
11:38:46 <roconnor> no (->)
11:38:53 <edwardk> with mzero = throw (userError "mempty") -- iirc
11:39:04 <vixey> Conal has a point though, what about   MonadPlus a => MonadPlus (b -> a)
11:39:23 <edwardk> vixey: that should be in Data.Monad.Instances
11:39:28 <edwardk> isn't it?
11:39:33 <edwardk> er
11:39:37 <edwardk> Control.Monad.Instances
11:39:56 <edwardk> ah whoa, its not
11:40:01 <conal> oops.
11:40:16 <vixey> I think that is a valid monad plus though
11:40:47 <edwardk> hrmm, wait
11:40:50 <edwardk> what is it?
11:40:56 <edwardk> i don't see it
11:41:08 <vixey> f `mplus` g = \i -> f i `mplus` g i
11:41:11 <Twey> @src (->) mplus
11:41:11 <edwardk> i don't think it exists
11:41:12 <lambdabot> Source not found. Wrong!  You cheating scum!
11:41:12 <vixey> mzero = const mzero
11:41:16 <Twey> Hmnhmn
11:41:23 <edwardk> thats for ReaderT
11:41:58 <edwardk> that requires the thing on the right hand side of (->) to be a MonadPlus, but the anonymous reader just knows its a value
11:42:25 <edwardk> instance MonadPlus ((->)e) where mzero = ?!
11:42:47 <vixey> mzero = const mzero ..
11:43:01 <mauke> wrong type
11:43:02 <sinelaw> @seen Peaker
11:43:02 <lambdabot> I saw Peaker leaving #haskell-blah, #haskell-overflow and #haskell 3m 15d 13h 13m 1s ago, and .
11:43:05 <edwardk> and it gets the fact that (e -> a) -- that a is a monadplus how?
11:43:10 <vixey> :t const mzero
11:43:11 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => b -> m a
11:43:17 <sinelaw> @seen PeakerWork
11:43:17 <lambdabot> PeakerWork is in #haskell-blah, #haskell-in-depth and #haskell. I don't know when PeakerWork last spoke.
11:43:23 <edwardk> @src ReaderT mplus
11:43:23 <lambdabot> Source not found.
11:43:36 <vixey> oh yeah thanks mauke
11:44:36 <roconnor> I think what you want is to use e -> MonadPlusAsMonoid m a
11:45:05 <edwardk> or just wrap in a ReaderT
11:45:36 <edwardk> ReaderT (f :: e -> m a) should work just fine
11:45:43 <roconnor> do we have a way of wrapping a MonadPlus and a type into a monoid?
11:45:55 <edwardk> roconnor: Data.Monoid.Monad.MonadSum
11:46:34 <roconnor> @indexData.Monoid.Monad.MonadSum
11:46:34 <lambdabot> Unknown command, try @list
11:46:38 <roconnor> @index Data.Monoid.Monad.MonadSum
11:46:39 <lambdabot> bzzt
11:46:46 <roconnor> @docs Data.Monoid.Monad.MonadSum
11:46:46 <lambdabot> Data.Monoid.Monad.MonadSum not available
11:46:54 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.33/doc/html/Data-Monoid-Monad.html
11:47:36 <edwardk> er http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Monoid-Monad.html even
11:48:03 <edwardk> there is a similar one for Alternatives in Data.Monoid.Applicative
11:57:33 <gOcOOl> does anyone know if the 'haskell-platform' package is available on Ubuntu yet?
11:58:03 <ksf> any vim gurus around?
11:58:12 <ksf> _si is working, but _t and _T ain't.
11:58:49 <wahjava> ksf: Emacs priest around...;)
11:59:27 <ksf> types were the reasons why i finally installed the whole haskellmode...
12:00:26 <Zao> ksf: "Double type not known" when _T on a :: Double
12:00:33 <Zao> ksf: What's _t and _T supposed to do?
12:01:18 <ksf> lookup the type of the expression under the cursor.
12:01:26 <ksf> ...resp. insert it.
12:02:53 <Zao> It seems to kind of work here.
12:03:32 <Zao> Seems to need :make to update cached info, but otherwise it seems to work.
12:03:52 <Zao> (vim x64 7.2, Haskell Platform 2009.2.0)
12:04:30 <zloog> Hi, I'm getting an uncaught exception in gtk2hs and haven't worked with exceptions before. I'm trying to write and handler and my code snippet is http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4663#a4663 and I was wondering if anyone knew why I was getting an ambiguous type variable error. Thanks
12:05:09 <nathanic> ksf: the _t script seems to break for `infix` definitions for me
12:05:46 <dcoutts_> zloog: because given that code, there's no way to know which types of exceptions you're trying to catch
12:06:18 <dcoutts_> zloog: you need to fix a type of exception you're trying to catch
12:06:56 <zloog> dcoutts: Well I just want to see if the exception is happening in haskell so I wanted to try and catch all haskell exceptions and just print out that there was one. Otherwise, is there a way for me to inspect what kind of exception this is?
12:07:40 <dcoutts_> zloog: ah, then you need a slightly different handler if you want to catch every exception without knowing the type of the exception you're getting
12:08:02 <zloog> dcoutts: And I realize that  6.10's exceptions are different from the exceptions described in RWH but they have generica handlers in the book
12:08:03 <dcoutts_> zloog: take a look at the other functions in Control.Exception, it's a variant on handle
12:08:21 <zloog> dcoutts: Thanks for the tip
12:08:26 <dcoutts_> np
12:08:30 * dcoutts_ disappears
12:26:33 <azathoth99> hasekll for system administration bad idea?
12:26:57 <inimino> yes
12:27:50 <inimino> azathoth99
12:28:24 <roconnor> azathoth99: see nix for an example of a non-haskell but haskelly package manager
12:28:25 <Cale> azathoth99: hmm, I don't think it's a bad idea.
12:28:25 <Nafai> azathoth99: what do you mean?  for scripting and such?
12:28:37 <roconnor> @where nix
12:28:37 <lambdabot> I know nothing about nix.
12:28:55 <roconnor> @where+ nix http://nixos.org/
12:28:56 <lambdabot> I will never forget.
12:28:58 <roconnor> @where nix
12:28:59 <lambdabot> http://nixos.org/
12:30:12 <roconnor> Oh wow, they have a new continuous build system
12:30:19 <cypher-> nix is a nice idea
12:30:58 <roconnor> I should download it and use it sometime
12:31:03 <cypher-> I have tested it long time ago
12:31:11 <mauke> oh, a new one
12:31:19 <roconnor> ``Nix is a useful system administration tool for heterogeneous environments and developers who write software supported on different libraries, compilers, or interpreters.
12:31:20 <cypher-> didn't push gentoo out of my laptop, but I liked it
12:31:28 <cypher-> these day's I'm a mac guy
12:31:29 --- mode: ChanServ set +o mauke
12:31:29 --- mode: mauke set +b *!i=d01415be@gateway/web/ajax/mibbit.com/x-da2393f60c623d17
12:31:36 <cypher-> hmm.. maybe I'll try to build it on os x
12:31:54 <roconnor> mauke: ?
12:32:06 <mauke> roconnor: gavino/protontorpedo
12:32:29 --- mode: mauke set -o mauke
12:32:35 <roconnor> @protontorpedo
12:32:35 <lambdabot> I hear from an essay by E raymod that perl is shitty for large projects
12:32:53 <vixey> mauke you can't just ban someone liek that
12:32:58 <mauke> yes, I can
12:33:15 <vixey> mauke I'm speaking english not klingon
12:33:19 <vixey> mauke it means: You shouldn't have
12:33:23 <mauke> why not?
12:33:51 <vixey> I meant vulcan not klingon
12:33:56 <roconnor> take it to #haskell-ops
12:33:59 <mauke> heh
12:34:05 <demolithion> sk questions not only about the orientation of a sphere, but also about the rate of change of its orientation. So SO(3) is a differentiable group. The usual name for these is Lie groups, after the mathematician Sophus Lie.
12:34:12 <demolithion> ups -.-
12:34:14 <demolithion> sry
12:34:15 <roconnor> oh wait
12:34:18 <endojelly> Map.find: element not in the map
12:34:22 <roconnor> vixey isn't an op
12:34:25 <endojelly> how can I find out again where that exception is thrown?
12:34:33 <roconnor> I take that back, plz continue the discussion
12:35:43 <Twey> 21:34:10 < vixey> mauke you can't just ban someone liek that
12:35:47 <Twey> No, you can't
12:36:01 <Twey> mauke: That was a Mibbit client ID you banned
12:36:20 <mauke> Twey: that's a good thing, no?
12:36:22 <Twey> If you want to ban the person, /whois them to get their host, then use +d to ban by name
12:36:26 <mauke> ah
12:36:32 <endojelly> knowing where uncatched exceptions that fell through the runtime originated... how?
12:36:45 <Twey> Since Mibbit sets the realname to the person's host
12:36:57 <flipflap> Why does haskell still hate me so much? :
12:36:59 <flipflap> :((
12:37:01 * roconnor doesn't know how to find runtime exceptions either.
12:37:14 <flipflap> It just won't let me use "floor"
12:37:15 <Twey> flipflap: *grins* It just has to get to know you
12:37:17 <augustss> endojelly: you can't, unless it's thrown with that information baked in
12:37:25 <Twey> On what datum?
12:37:29 <endojelly> augustss, huh. that strikes me as odd.
12:37:30 --- mode: ChanServ set +o mauke
12:37:31 --- mode: mauke set -b+d *!i=d01415be@gateway/web/ajax/mibbit.com/x-da2393f60c623d17 208.20.21.190
12:37:32 <roconnor> flipflap: you need to understand the type of floor
12:37:38 <scriptdevil> flipflap... Show haskell some love... Do things right
12:37:40 <roconnor> @type floor :: Double -> Integer
12:37:42 <lambdabot> Double -> Integer
12:37:42 <flipflap> crates    = floor (x / 11) :: Double -> Int
12:37:48 <Twey> mauke: *nods* That's it
12:37:56 <endojelly> augustss, well can I make ghc bake in that information?
12:38:01 <roconnor> flipflap:  haskell is just trying to save you from yourself.
12:38:01 <Twey> :t floor
12:38:03 <scriptdevil> flipflap: :t x
12:38:03 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
12:38:08 <augustss> endojelly: It can be annoying
12:38:15 <Twey> Looks OK to me
12:38:18 <Twey> What's the error?
12:38:27 <flipflap> Couldn't match expected type `Int'
12:38:27 <flipflap>            against inferred type `Double -> Int'
12:38:29 <augustss> endojelly: Only by using CPP and some macro magic
12:38:32 --- mode: mauke set -o mauke
12:38:33 <Saizan> flipflap: you missed the argument
12:38:41 <scriptdevil> flipflap: What is the type of x?
12:38:41 <Twey> Ah, yes
12:38:42 <DBAlex> once you get the types right in haskell everything pretty much works :)
12:38:42 <endojelly> augustss, wtf
12:38:44 <flipflap> Int
12:38:46 <Twey> You need to mention x
12:38:49 <Saizan> flipflap: crates x = floor (x / 11) :: Double -> Int
12:38:50 <DBAlex> the beauty of no side effects eh.. :D
12:38:50 <roconnor> flipflap: it is floor that is a Double -> Int, you are claiming "floor (x / 11)" is a Double -> Int
12:38:58 <endojelly> augustss, so finding out where that error originated will be hard :( well, I could do some profiling, I guess...
12:39:01 <Saizan> orr wait
12:39:02 <Twey> When in fact it's just an Int (for example)
12:39:02 <scriptdevil> flipflap: x/11 is not double
12:39:06 <endojelly> at least then I know where to look for.
12:39:09 <Saizan> flipflap: crates x = floor (x / 11)  Int
12:39:14 <endojelly> or better, where not to look for
12:39:24 <roconnor> crates :: Double -> Int
12:39:30 <flipflap> No instance for (RealFrac Int) now
12:39:31 <roconnor> crates x = floor (x / 11)
12:39:37 <flipflap> Wait..
12:39:45 <augustss> endojelly: if you compile for profiling and run with -x you get some information
12:39:56 <Twey> That means that x is an Int, and you need to convert it to something that can be divided with /
12:40:04 <Twey> Like a Float or a Double
12:40:05 <augustss> endojelly: ghci also keeps some history if you run in ghci
12:40:20 <endojelly> augustss, oh? how do I access that history? haven't found a lot
12:40:25 <flipflap> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2348#a2348
12:40:34 <flipflap> I wanted to code.. something.. practical.
12:40:49 <wh1t3> thats odd cases :/
12:40:51 <roconnor> flipflap: ah
12:41:00 <roconnor> flipflap: x `div` ``
12:41:00 <augustss> endojelly: I don't remember.  I hardly ever use it
12:41:01 <roconnor> er
12:41:03 <roconnor> flipflap: x `div` 11
12:41:13 <roconnor> > 24 `div` 11
12:41:15 <lambdabot>   2
12:41:21 <roconnor> > (-24) `div` 11
12:41:23 <lambdabot>   -3
12:41:25 <povman> flipflap: Have you scheduled a release date for your application? I'd like to buy it!
12:41:34 <Berengal> div automatically floors
12:41:44 <flipflap> But I want to manually floor :(
12:41:45 <Berengal> Or rounds to zero, I forget...
12:41:46 <Twey> :t divMod
12:41:47 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
12:41:49 <flipflap> More to learn for me
12:41:52 <kpreid> > (-1) `div` 2
12:41:53 <lambdabot>   -1
12:42:05 <kpreid> > (-100) `div` 101
12:42:06 <lambdabot>   -1
12:42:07 <augustss> endojelly: it's not easy to find where an exception is thrown.  furthermore, I'm not even sure what it means
12:42:09 <roconnor> > floor (toRational x / 11)
12:42:10 <lambdabot>   * Exception: not a number
12:42:11 <kpreid> that's floor
12:42:23 <mauke> flipflap: floor (fromIntegral x / 11)
12:42:28 <Twey> flipflap: cratesOfBeer x = x `divMod` 11
12:42:37 <flipflap> Works even
12:42:42 <roconnor> flipflap: I strongly recommend div in this case
12:42:42 <flipflap> Thankies!
12:42:52 <flipflap> :/
12:42:57 <Twey> cratesOfBeer = (`divMod` 11)
12:42:58 <wh1t3> why are you dividing by 11? :/
12:43:04 <Berengal> > (-1) `quot` 2
12:43:05 <lambdabot>   0
12:43:07 <flipflap> 11 bottles in a crate
12:43:09 <roconnor> flipflap: div and mod go together like bacon and eggs
12:43:12 <flipflap> In my case
12:43:14 <futurestack> it's a drinker's dozen
12:43:19 <Twey> Hehe, aye
12:43:24 <wh1t3> hmmm, we get 24 in a crate
12:43:31 <flipflap> I wanna move there
12:43:34 <wh1t3> :P
12:43:34 <roconnor> @hoogle divMod
12:43:34 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
12:43:34 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
12:43:36 <scriptdevil> Do named records use destructive updating? :o Or do they use references
12:43:44 <roconnor> oh, there is a divMod
12:43:45 <povman> wh1t3: he drinks 13 of them on the way home
12:43:48 <Twey> scriptdevil: No, it's non-destructive
12:43:52 <Twey> roconnor: Yes.  :-P
12:43:57 <roconnor> 23 `divMod` 11
12:44:00 <flipflap> It works, yay
12:44:00 <roconnor> > 23 `divMod` 11
12:44:01 <Twey> 21:44:13 < Twey> cratesOfBeer = (`divMod` 11)
12:44:02 <lambdabot>   (2,1)
12:44:02 <endojelly> hmm.
12:44:12 <endojelly> how do I use cabal to install a version of mtl with profiling enabled?
12:44:13 <scriptdevil> Twey: But then x changes
12:44:20 <Twey> scriptdevil: It doesn't вЂchangeвЂ™ per se
12:44:33 <scriptdevil> endojelly: Use Setup.hs options
12:44:33 <Twey> It returns a new record with the specified fields different from the original
12:44:38 <roconnor> Twey: ah right, divMod is going to be faster than div and mod
12:44:44 <Twey> roconnor: *nod*
12:44:44 <flipflap> @src divMod
12:44:44 <augustss> and quotRem
12:44:44 <lambdabot> Source not found. Where did you learn to type?
12:44:49 * flipflap slaps lambdabot around a bit with a large trout
12:44:51 <Twey> Also neater :)
12:45:19 <endojelly> scriptdevil, which Setup.hs? without profiling I just do "cabal install mtl"
12:45:28 <augustss> And quotRem is going to be even faster
12:45:31 <endojelly> and now I additionally want mtl with profiling
12:45:44 <Saizan> endojelly: cabal install mtl -p --reinstall
12:46:03 <endojelly> Saizan, that doesn't fuck up the existing mtl package?
12:46:07 <roconnor> quotRem is faster than divMod?
12:46:10 <Twey> augustss, what is quot?
12:46:15 <Twey> Oh, quotient
12:46:22 <Twey> :t quot
12:46:23 <lambdabot> forall a. (Integral a) => a -> a -> a
12:46:35 <Saizan> endojelly: it'll rebuild and reinstall it
12:46:44 <endojelly> Saizan, thx!
12:46:49 <wh1t3> > quot 3 4
12:46:51 <lambdabot>   0
12:46:52 <Saizan> endojelly: whih might break packages that depend on mtl
12:46:57 <Twey> What's the difference between quot and div?
12:47:01 <xenoblitz> Hi people. I am using the graphics library HGL. For some reason on one machine I am getting "Could not find module `Graphics.HGL' " while on another I don't have this problem. I am using Windows... any ideas on what might be going on?
12:47:06 <augustss> Twey: different behaviour for signed numbers
12:47:08 <Saizan> endojelly: however, how did you get the mtl package in the first place?
12:47:11 <Twey> Ah
12:47:19 <augustss> or negative, i should say
12:47:30 <Twey> div rounds towards zero?
12:47:36 <endojelly> Saizan, haskell-platform
12:47:38 <wh1t3> quot is truncated
12:47:43 <wh1t3> div is to negative infinity
12:47:44 <endojelly> Saizan, (so via cabal)
12:47:51 <Twey> > -7 `div` 2
12:47:52 <lambdabot>   -3
12:47:58 <Twey> To zero
12:48:00 <augustss> Twey: quot behaves like the hardware does on almost all machines
12:48:10 <Twey> > -7 `quot` 2
12:48:11 <wh1t3> quot is truncated to zero, div towards negative infinity
12:48:12 <lambdabot>   -3
12:48:13 <augustss> > (-7) `div` 2
12:48:14 <lambdabot>   -4
12:48:16 <Twey> Huh
12:48:18 <roconnor> why is hardware so broken?
12:48:26 <Twey> Oh
12:48:28 <Twey> Duh
12:48:30 <Twey> I hate that
12:48:34 <Twey> roconnor: *laughs*
12:48:38 <Twey> Yeah
12:48:38 <Saizan> endojelly: it's stange that it doesn't also install the profiling libraries, but i've not used it yet
12:48:44 <augustss> Twey: you need (-7)
12:48:48 * Twey nods.
12:48:52 <endojelly> Saizan, well it seemed to work... almost:
12:48:53 <Twey> Still catches me out
12:48:55 <Deewiant> > (-7) `quot` 2
12:48:56 <lambdabot>   -3
12:48:58 <endojelly> /usr/bin/ld: cannot find -lHSrts_debug_p
12:49:03 <augustss> roconnor: it's not broken, it's different. :)
12:49:06 <Twey> (more proof that we need whitespace-sensitivity on operators!)
12:49:12 <Saizan> xenoblitz: ghc-pkg list HGL reports anything on that machine?
12:49:23 <wh1t3> in this case it will ofcourse never matter...
12:49:30 <augustss> roconnor: NS32K is the only hardware I know of that provided both modes.
12:49:58 <xenoblitz> Saizan: let me try
12:49:59 <roconnor> bah, the Haskell Platform has the mtl.
12:50:27 <Twey> Why is that worthy of a вЂbahвЂ™?
12:51:10 <endojelly> Saizan, so now I compiled my project with profiling but without debug. I guess that's enough.
12:51:20 <edwardk> roconnor hates the MonadState instance for ContT
12:51:28 <Twey> Ah
12:51:37 <heltav> hmm anyone want OpenCV bindings?
12:51:49 <xenoblitz> Saizan: it reports just: C:/Compilers/GHC/ghc-6.10.1\package.conf: and nothing else ... is that ok?
12:51:50 <heltav> facedetect :: Image -> Maybe Face
12:52:04 <Saizan> xenoblitz: no, that means the HGL lib is not installed there
12:52:23 <xenoblitz> does HGL come with GHC and/or Hugs?
12:52:29 <roconnor> Twey: that and the class members appear to be arbitrary, stupid, and in some cases broken.
12:52:36 <endojelly>   -xc      Show current cost centre stack on raising an exception
12:52:36 <Saizan> no, you've to install it from hackage
12:52:39 <endojelly> that sounds good
12:52:48 <edwardk> roconnor: which other ones are broken?
12:52:51 <heltav> hmm anyone want OpenCV(open computer vision) bindings?
12:53:01 <roconnor> I applaud the mtl for getting monad transformers rolling, but we need to move on.
12:53:11 <xenoblitz> Saizan: would installing it via the HGL website be ok?
12:53:12 <roconnor> edwardk: let me check
12:53:45 <Twey> Never heard of it
12:53:58 <augustss> roconnor: so make something better so we can move on
12:54:00 <Saizan> xenoblitz: i'd install it from the tarball here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL
12:54:08 <Twey> heltav: That looks cool
12:54:09 <roconnor> edwardk: I'm deeply suspicious of pass
12:54:20 <roconnor> augustss: I suggest using monadLib
12:54:45 <roconnor> but I haven't looked at all of the offerings on hackage yet.
12:55:12 <augustss> roconnor: maybe I'll give it a try
12:55:36 <roconnor> the mmtl is another potential candidate
12:55:37 <xenoblitz> Saizan: its a bit problematic to tell 1st year students to install it via cabal on a windows system (I'm TA-ing)
12:55:42 <roconnor> I haven't looked at it much though
12:56:16 <Twey> xenoblitz: *shrug* Apply a batch file
12:56:19 <roconnor> there is also monad-ran, hot off the presses
12:56:34 <xenoblitz> Twey: yeah probably the way to go at this point. Thanks guys
12:56:36 <Saizan> xenoblitz: since yesterday you can point them to the haskell platform installer :)
12:56:39 <augustss> roconnor: you can't just say that something is bad without giving us an alternative.  that will never make people switch
12:56:41 <roconnor> oh wait, monad-ran isn't a monad library
12:56:43 <Saizan> xenoblitz: which comes with cabal-install
12:56:55 <edwardk> roconnor: pass clearly separates two monadic layers
12:56:56 <xenoblitz> Saizan: Hmmm I'll look it up :) Thanks guys.
12:57:07 <roconnor> augustss: okay.  monadLib then.
12:57:21 <edwardk> roconnor: monad-ran intentionally duplicates the MTL operations and requires the MTL ;)
12:57:25 <ksf> http://pastebin.com/m5be82c98
12:57:27 <roconnor> If I must decide right now.
12:57:40 * ksf would open a beer if he didn't have to go outside to fetch one to do that.
12:57:44 <roconnor> <edwardk> roconnor: pass clearly separates two monadic layers -- what does this mean?
12:58:05 <edwardk> @type pass
12:58:06 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
12:58:57 <edwardk> pass takes a monad and generates another, there is containment there. it shouldn't be _necessary_ to be a writer to have pass but its convenient
12:59:21 <edwardk> er i mean it shouldn't be necessary to have pass to be a writer
13:00:24 <edwardk> so i agree that pass should be split out into its own class. i'm not a big fan of having the modify and rerun Foo like methods like local, etc. baked into the class for having the property
13:01:25 <roconnor> edwardk: there is no MonadWriter w (ContT r m) instance because of pass, IIRC
13:01:33 <edwardk> yeah
13:01:51 <roconnor> hence my dislike of pass being a member of the class.
13:02:09 * copumpkin slaps pass
13:02:16 <edwardk> a valid complaint. i'd like to see the class split, but there is the whole installed base thing
13:02:38 <edwardk> my problem with mmtl etc is they are incompatible with the MTL's existence
13:02:42 <edwardk> monadLib i like
13:02:49 <augustss> I've never used pass.  It seems wrong, somehow.
13:03:03 <Saizan> ?type listen
13:03:04 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m a -> m (a, w)
13:03:12 <edwardk> it doesn't try to use the same module names and force the dilemma on the user of using any module that uses the MTL or using nicer monads
13:03:33 <edwardk> listen is also problematic
13:03:59 <Saizan> i end up using both most of the times i use Writer though
13:04:06 <edwardk> pretty much any method of the m a -> m b -- form in a MonadFoo is doing something wrong =)
13:04:26 <Saizan> to extract the slice of monoid produced by a particular region
13:04:27 <edwardk> saizan: sure, but they should be factored out into another class that way more things can use tell
13:04:30 <heltav> to use BLAS do i need both fortran and c bindings?
13:04:31 <Gracenotes> well, w tends be a monoid implicitly
13:04:49 <Gracenotes> not required though, and some cases not implicit.
13:05:54 <Saizan> it is required
13:06:29 <edwardk> sure, you can roll your own MonadWriter forall o. (a -> w -> o) -> w -> o and plumb in a starting state and _any_ binary operation and still be legal
13:06:55 <edwardk> thats because the CPS'd writer will reassociate all of your binds to make it legal ;)
13:06:56 <Gracenotes> o nos :O fundep
13:07:21 <vixey> btw you are using CBV CPS this whole time right?
13:07:26 <vixey> What about CBN CPS?
13:08:25 <edwardk> vixey: just a swapping of order in all the instances
13:09:00 <roconnor> vixey: you need to teach me what this CBV and CBN CPS stuff is.  heck I don't even formally understand CPS.  I just know it when I see it.
13:09:04 <edwardk> i suppose i could go through monad-ran and rename Ran to CBN or CBV and make the opposite set of instances to go along with it, but man thats a lot of work =)
13:09:28 <Saizan> how would one look like?
13:09:40 <vixey> roconnor: I only know little bites about CBV CPS, but in-depth talked about CBN CPS and I can't stop thinking about it
13:10:04 <ivan-kanis> mauke: thanks for the paste, i was away
13:10:21 <vixey> roconnor: I learned about CPS for how to compile scheme (and how to get CWCC) -- there's a talk/slides if you want about that
13:10:23 * Saizan feels guilty for spreading CBN
13:16:01 <Twey> Saizan: What is CBN?
13:16:28 <edwardk> Twey: call by name
13:16:34 <Twey> Ohh
13:16:41 <Twey> Not call-by-need?
13:16:45 <Saizan> i was referring to the CPS transformation in particular
13:16:49 <Twey> We have call-by-name in Haskell?
13:16:50 <vixey> what the hell
13:17:00 <Saizan> for call-by-need you also need some form of heap
13:17:39 <edwardk> Cont f <*> Cont x = Cont (\k -> f (\g -> g x k)) -- should do the trick for CBN applicative. not sure on bind never wrote one.
13:17:57 <augustss> Twey: Haskell has CBN semantics, but not necessarily implementation.
13:19:24 <Saizan> ?type let Cont f <*> Cont x = Cont (\k -> f (\g -> g x k)) in (<*>)
13:19:26 <lambdabot> forall r t t1 a. Cont r (((t -> t1) -> t1) -> (a -> r) -> r) -> Cont t1 t -> Cont r a
13:20:42 <edwardk> CBN CPS is ugly iirc
13:21:19 <Saizan> yeah, that types is like Cont r (Cont r a -> Cont r b) -> Cont r a -> Cont r b
13:22:09 <edwardk> i may have missed a few 'strip the cont constructors' from that
13:22:41 <Saizan> ?type let Cont f <*> x = Cont (\k -> f (\g -> runCont (g x) k)) in (<*>)
13:22:42 <lambdabot> forall r t a. Cont r (t -> Cont r a) -> t -> Cont r a
13:23:23 <edwardk> ?type let cbn f x k = f (\g -> g x k)) in cbn
13:23:24 <lambdabot> parse error on input `)'
13:23:35 <edwardk> ?type let cbn f x k = f (\g -> g x k) in cbn
13:23:36 <lambdabot> forall t t1 t2 t3. (((t -> t1 -> t2) -> t2) -> t3) -> t -> t1 -> t3
13:25:34 <edwardk> http://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf had both cbn and cbv cps transforms in it iirc
13:27:04 <cypher-> is it possible to produce a thread-safe lock-less queue?
13:27:55 <Botje> sure, check out mozart's implementation
13:28:05 <cypher-> or more general question: is there a short guide for the dummies (i.e. people like me) to lockless data structures?
13:28:12 <cypher-> Botje: where do I find it?
13:30:02 <Botje> cypher-: http://www.mozart-oz.org/documentation/tutorial/node9.html#section.stateful.clientserver
13:30:26 <cypher-> Botje: thanks!
13:31:18 <roconnor> @hoogle unS
13:31:18 <lambdabot> module Data.ByteString.Unsafe
13:31:19 <lambdabot> module System.IO.Unsafe
13:31:19 <lambdabot> Language.Haskell.TH Unsafe :: Safety
13:32:58 <roconnor> http://lhc-compiler.blogspot.com/2009/05/constructor-specialization-and-laziness.html
13:33:00 <edwardk> ?type let Cont f <*> x = Cont (\k -> f (\g -> k (g x))) in (<*>)
13:33:02 <lambdabot> forall r t a. Cont r (t -> a) -> t -> Cont r a
13:33:05 <roconnor> ^^ can someone explain this post to me?
13:33:07 <edwardk> ah woops
13:36:05 <edwardk> ?type let Cont f <*> Cont x = Cont (\k -> f (\f' -> x (\x' -> k (f' x')))) in (<*>)
13:36:06 <lambdabot> forall r t a. Cont r (t -> a) -> Cont r t -> Cont r a
13:36:15 <edwardk> yay
13:36:38 <leimy> Continuations in haskell, I'm just not sure I've found the right way to apply them usefully.  I've made code very ugly trying to use them :-)
13:36:48 <edwardk> leimy: likewise
13:37:13 <roconnor> leimy: laziness negates many uses of continuations
13:37:13 <leimy> also, lazy evaluation, seems to allow for some form of automagic continuation behavior.
13:37:21 <leimy> roconnor: yep :-)
13:37:43 <roconnor> I've used Codensity Monad transformations to make my code faster.
13:38:13 <dolio> edwardk: That's regular Cont, no?
13:38:33 <edwardk> ?type let test1 f x = Cont (\k -> runCont f (\f' -> runCont x (\x' -> k (f' x')))); test2 f x = Cont (\k -> runCont x (\x' -> runCont f (\f' -> k (f' x')))) in (<*>)
13:38:33 <roconnor> I think that is all that I've used continuations for so far.
13:38:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:38:53 <edwardk> ?type let test1 f x = Cont (\k -> runCont f (\f' -> runCont x (\x' -> k (f' x')))); test2 f x = Cont (\k -> runCont x (\x' -> runCont f (\f' -> k (f' x')))) in (test1, test2)
13:38:54 <lambdabot> forall r a a1 r1 a2 a3. (Cont r (a -> a1) -> Cont r a -> Cont r a1, Cont r1 (a2 -> a3) -> Cont r1 a2 -> Cont r1 a3)
13:39:08 <heltav> Ill ask again
13:39:11 <heltav> hmm anyone want OpenCV(open computer vision) bindings?
13:39:12 <edwardk> there are the two cases
13:39:16 <edwardk> and yeah it was
13:39:22 <olsner> hehe, "I like languages which say, вЂњNo, you don't want to write it the way youвЂ™re thinking. ThereвЂ™s a vastly better way to solve this whole class of problems.вЂќ Me: brain explodes"
13:40:05 <leimy> olsner: languages don't say that... :-)
13:40:26 <olsner> I think it's a metaphor :-)
13:40:48 <edwardk> leimy: are you sure? i thought i heard ghc talking to me on at least one occasion
13:40:56 <leimy> heh
13:41:00 <edwardk> oh wait. its usually GHC that says "my brain exploded" =)
13:41:04 <leimy> right
13:41:09 <edwardk> i got that backwards
13:41:26 <dolio> @quote exploded
13:41:27 <lambdabot> ghc says: My brain just exploded.
13:41:33 <edwardk> i used to love that error message, does it still happen?
13:41:56 <dolio> I think so. Isn't it for using 'let' with existential types?
13:42:05 <edwardk> ah
13:42:27 <leimy> Aren't existential types those people who can't figure out their purpose?
13:42:36 <edwardk> yeah
13:42:41 <yitz> ghc -e 'System.Cmd.system "say The impossible just happened."'
13:43:03 <leimy> on a mac...
13:43:09 <yitz> yep
13:43:19 <dolio> Yep, checked. It still says that.
13:43:24 <yitz> use festival on linux if you'd like.
13:43:35 <edwardk> the problem with them, like all existentials is you really don't know what to do with them once you have them. you can't get them to do anything
13:44:05 <edwardk> you can force them, and pass them on to someone that will accept them but thats about it.
13:44:34 <[1]dan> did anyone notice that YAHT is wrong about the combination of regexps and guards?
13:45:00 <yitz> regexps and guards?
13:45:11 <vixey> [1]dan I think it's just outdated
13:45:42 <Cale> [1]dan: What do you mean about regexps?
13:46:06 <[1]dan> sorry meant patterns, not regexps. if you have multiple patterns, and the guards are exhausted on the one pattern, then the next patterns ARE attempted as a match
13:46:22 <[1]dan> this is against what is written there
13:46:30 <[1]dan> (page 94)
13:46:49 <Cale> ah
13:46:58 <Cale> @where yaht
13:46:59 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:47:03 <saml> > let f x | x == 1 = 2 | otherwise = 3 in f 1
13:47:05 <lambdabot>   2
13:47:41 <Cale>     Guards are applied in conjunction with pattern matching. When a pattern matches,
13:47:41 <Cale> all of its guards are tried, consecutively, until one matches. If none match, then pattern
13:47:41 <Cale> matching continues with the next pattern.
13:47:53 <quicksilver> "If none match, then pattern
13:47:55 <quicksilver> matching continues with the next pattern"
13:48:02 <quicksilver> that's right
13:48:46 <saml> > let f x | x == 1 = 2 | x == 2 = 3; f 3 = 4; f x = x + 1 in f 3
13:48:48 <lambdabot>   4
13:48:54 <[1]dan> this is the text i have:
13:48:55 <[1]dan> One thing to note about guards is that they are tested after pattern matching, not in
13:48:55 <[1]dan> conjunction with pattern matching. This means that once a pattern matches, if none of
13:48:55 <[1]dan> the guards succeed, further pattern matches will not be attempted.
13:49:06 <[1]dan> i guess im looking at an outdated version? :)
13:49:12 <Cale> yeah
13:49:30 <Cale> I don't think that was ever true.
13:49:36 <Cale> But I might be wrong.
13:49:57 <edwardk> yeah it shouldn't have ever held
13:50:27 <Cale> In some sense the whole point of having guards is to make it easy for pattern matching to continue if they fail.
13:50:43 <[1]dan> i looked at the version which is the first match in google for "yet another haskell tutorial", which is at
13:50:44 <[1]dan> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
13:51:31 <[1]dan> so I'm guessing I'm not the only one looking at an outdated version
13:52:11 <tchakkazulu> ?hoogle (Ix i, Array a e) => (i,i) -> (i -> e) -> a i e
13:52:11 <lambdabot> Warning: Unknown class Array
13:52:11 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
13:52:11 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
13:52:18 <tchakkazulu> ?hoogle (Ix i, IArray a e) => (i,i) -> (i -> e) -> a i e
13:52:18 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
13:52:18 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
13:52:18 <lambdabot> Data.Array.Base amap :: (IArray a e', IArray a e, Ix i) => (e' -> e) -> a i e' -> a i e
13:52:19 <Cale> It's interesting that he provides a concrete example of that failing.
13:52:27 <[1]dan> yup
13:52:57 <[1]dan> mm, i guess someone should tell the host to update their version
13:53:32 <Cale> Both hugs and ghci fall through, and the standard I'm pretty sure says that they should as well.
13:56:33 <Cale> yes... "If all the guards evaluate to False, matching continues with the next alternative." -- Haskell Report
13:57:08 <povman> Hi all - I have some interesting behaviour with Reactive!
13:57:10 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2349#a2349
13:58:08 * Cale looks
13:58:28 <Cale> Oh, you're working on an SDL interface?
13:58:46 <povman> Is there anything obviously wrong with what I'm doing there? In particular, the program just prints "0.0" at what seems to be arbitrary times, regardless of me pressing keyboard keys
13:58:50 <povman> Cale: yes!
13:59:02 <Cale> Did you not want to include the rest of your file?
13:59:16 <povman> It's split into separate files
13:59:28 <povman> that's all i really have at the moment though
13:59:47 <Cale> I suppose I can try to guess the imports
13:59:52 <povman> ah fine
14:00:21 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2349#a2350
14:00:29 <Cale> Thanks :)
14:01:08 <[1]dan> well, i sent the author an email so hopefully he updates the version on his site
14:01:27 <[1]dan> so more people can enjoy learning haskell as correctly as possible ;)
14:01:41 <povman> If I make 'updater' to print the value of boxAccel, it prints -1 and 1 when i press a and s
14:02:04 <povman> but with boxVelocity, it randomly prints 0.0
14:03:19 <Phyx-> I'm having a little problem, when i try to use a function that has a certain type signature, it tells me, i'm missing an instance, but it's there. if i add a new one, it tells me error on overlapping instances :S
14:03:39 <Twey> Perhaps you're not using the instance you think you're using.
14:03:42 <Botje> can you put your code somewhere?
14:03:52 <Cale> Well, I'm not sure, but you're calling updater on every time through the quitLoop...
14:04:02 <povman> is this bad?
14:04:22 <Cale> povman: I'm not sure, but it seems like it might be responsible for that printing?
14:04:22 <ManateeLazyCat> Phyx-: Paste your code and error, then people can help you.
14:05:11 <povman> The behaviour I expect is that it repeatedly prints decreasing values when i press a
14:05:17 <Phyx-> ManateeLazyCat: which is a full page full of instances that need eachother
14:05:45 <povman> Phyx-: http://moonpatio.com
14:06:05 <Leftblank> Say I want to sort a list of custom data in a non-standard way; I understand I'll probably need to write my own instance Ord - but where do I find a tutorial/manpage to get started with that?
14:06:34 <Berengal> @type sortBy
14:06:36 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:06:41 <Berengal> Leftblank: ^^
14:06:52 <povman> Cale: is that how you would have written boxVelocity?
14:07:17 <Twey> Leftblank: You don't have to
14:07:27 <Twey> Leftblank: You can use sortBy, for example
14:08:04 <Leftblank> thanks Twey & Berengal, but I can't seem to find a way to combine that with my custom fields and the getter-like methods Haskell generates
14:08:17 <Twey> > sortBy (comparing snd) [('a', 2), ('c', 3), ('b', 1)]
14:08:19 <lambdabot>   [('b',1),('a',2),('c',3)]
14:08:37 <Twey> Replace snd with the function of your choice to retrieve the value you want to compare
14:08:41 <Leftblank> bingo, thanks Twey
14:08:52 <Cale> comparing is defined in Data.Ord
14:08:58 <lament> :t comparing
14:08:59 <Cale> and sortBy is in Data.List
14:08:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:09:20 <Twey> Only use Ord for the main way you'd expect your datatype to be compared
14:09:26 <mauke> and if you have multiple sort criteria, see mappend
14:09:33 <Leftblank> mk, thanks
14:09:37 <Leftblank> I'll dive into that
14:09:43 <heltav> so if I do a binding to the OpenComputerVision project via FFI how do I publish it on Hackage?
14:09:51 <Cale> povman: It's not far off, but I've only used higher-level interfaces to Reactive without looking at how they're implemented.
14:09:58 <Phyx-> where can i find out what "IncoherentInstances" does? the ghc manual only mentions it, doesn't explain it
14:10:07 <ManateeLazyCat> How long hpaste.org contain paste?
14:10:21 <heltav> just the FFI and OpenCV has to be downloaded separately?
14:11:53 <povman> Cale: I haven't tried the other adapters yet - I presume the equivalent of my boxVelocity would work fine on them?
14:12:17 <povman> (In which case it is my adapter which is broken, and not reactive)
14:12:25 <Cale> Phyx-: it does explain it in the section about overlapping instances
14:12:32 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
14:13:31 <heltav> is Reative = event driven programming?
14:13:31 <heltav> for GUIs?
14:13:52 <Phyx-> Cale: ah, right, thanks, i was looking in the language extensions part
14:14:23 <Twey> Not just for GUIs
14:14:25 <Cale> povman: yeah...
14:14:40 <Cale> povman: Somehow I'd never run into stepper before, but it seems fine
14:15:20 <ManateeLazyCat> Bye all, good night!
14:15:25 <Cale> heltav: It's more like a combination of event driven and signal processing.
14:16:07 <Cale> heltav: You have events, which are like discrete sequences of time/value pairs, and then there are behaviours which are like functions of time.
14:16:35 <Cale> Things like mouse clicks are events, things like the location of the mouse are behaviours.
14:18:37 <monadic_kid> basically some values are really functions of time, thats what behaviours are
14:19:15 <heltav> ok cool
14:19:38 <heltav> and it works good?
14:19:46 <monadic_kid> they mimick what the actual maths says. We are functional programmers, we program with functions as values, why shouldn't this be the case for values that really are functions!
14:20:04 <heltav> for an mp3player this might be good? you could setup a behaviour for songFinished etc
14:20:51 <Cale> There might be a behaviour for the time in the track which is currently playing, and an event for when the song finishes.
14:21:28 <Cale> Behaviours have a value all the time, and you can always observe it. Events just happen sometimes.
14:21:42 <monadic_kid> heltav:when you start to think this "varible" is really a function of time then the most obvious *varibles* are things like displacement, velocity, acceleration
14:21:58 <monadic_kid> *variables
14:22:04 * monadic_kid shots himself
14:22:30 <Cale> The idea behind FRP is to allow you to express the output of your program directly in terms of these behaviours and events, and allow the library to handle the task of keeping everything up to date.
14:22:52 <Cale> Generally the output of your program is another bunch of behaviours and events.
14:23:03 <Berengal> Speaking of reactive, I'm having some trouble cabal-installing it
14:23:29 <ksf> has it bit-rotted, by now?
14:23:33 <Cale> Berengal: It can be tricky at the moment, the current versions of everything don't agree, you have to take older versions of some things
14:23:50 <Berengal> Cale: Yeah, I figured. Stream seems like a likely candidate
14:24:23 <monadic_kid> is it a build issue? because all you need to do is get the older version of a particular package then install Stream and then you can update and install the rest
14:24:35 <Berengal> Of course, if someone has another suggestion for a good FRP library I could check out, that'd be fine too
14:24:35 <monadic_kid> thats what i had to do
14:24:38 <Cale> Berengal: I'll make you a paste of what versions of everything I have installed
14:24:47 <ksf> Berengal, elerea
14:24:53 <Cale> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2351#a2351
14:24:54 <ksf> it's the newest of the bunch.
14:25:05 <ksf> yampa is the most stable
14:25:12 <monadic_kid> Cale: i did it recently, it's an issues with the various dependancies and the version of QuickCheck they & reactive depend on
14:25:22 <Berengal> Cale: Thanks
14:26:08 <Cale> iirc, it's important that it's vector-space-0.5
14:26:10 <Berengal> ksf: I'll check them out
14:26:28 <ksf> packages should be somehow free not to depend on quickcheck if you don't want to test stuff.
14:26:29 <Jedai> Berengal: just add -constraint=Stream <= 0.3 or whatever
14:26:42 <Cale> and I think the first time I tried to install it, Cabal picked this really old version of reactive-glut to try to install
14:26:46 <Cale> So watch out for that
14:26:49 <Phyx-> ok, i got my problem worded a better way http://hpaste.org/fastcgi/hpaste.fcgi/save
14:26:50 <Berengal> Jedai: Ah, thanks. Looks like it should work.
14:26:52 <Phyx-> err
14:27:05 <Berengal> i've been given choices now though, so my problem has been replaced by an even bigger one
14:27:17 <Phyx-> ok, i got my problem worded a better way http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4668
14:27:20 <monadic_kid> Yampa is stable but it takes the elegance out of FRP
14:27:27 <Phyx-> I don't know what might be cauzing that
14:27:29 <monadic_kid> it looks brain damaged
14:27:49 <Cale> Arrows tend not to be very elegant.
14:28:42 <Cale> Phyx-: The problem is that it can't tell that 42 is an Int
14:28:52 <Cale> Phyx-: For all it knows, it might be a Double or something else
14:29:09 <Cale> Phyx-: Try adding an explicit type signature to the 42
14:29:14 <povman> Berengal: I like Reactive :D
14:29:16 <comex> if I have, e.g., 'data SomeType = A Bool | B Int', is there a function that can tell me whether a SomeType is an A or a B?
14:29:29 <comex> say, I want to filter out all As
14:29:37 <mauke> comex: no, but you can write it yourself
14:29:43 <monadic_kid> comex: you can make a function that pattern matches that yourself
14:29:47 <comex> okay
14:29:57 <heltav> it failed for me to weird dependecnes
14:29:58 <Phyx-> Cale: looks like i've been bitten by ghci again :P
14:29:58 <ksf> ..or you can just use Either Bool Int
14:30:15 <Cale> comex: [x | A x <- myList]
14:30:19 <Phyx-> completely forgot that it doesn't type 42 to an Int but a Num
14:30:21 <Cale> Is a handy way to do that filtering
14:30:45 <monadic_kid> comex: isA (A _ ) = True; isA (B _ ) = False
14:31:01 <Cale> Phyx-: It's not just ghci
14:31:01 <Lemmih> isA A{} = True; isA _ = False
14:31:18 <comex> yeah, I just wanted to avoid a pointless function
14:31:35 <Cale> comex: You can do my list comprehension
14:31:36 <comex> Cale: thanks
14:31:40 <monadic_kid> comex: Lemmih's version is better
14:31:40 <Phyx-> Cale: wouldn't ghc normal detect in this case that it should be an Int?
14:32:25 <tiglionabbit> for my first ever haskell web application, would you recommend I use happs or something else?
14:32:53 <Cale> Phyx-: Only if there's a type signature somewhere.
14:33:22 <Cale> Phyx-: And it usually wouldn't default to Int, but Integer, though it doesn't do defaulting when there are non-Prelude typeclasses present.
14:33:27 <heltav> why does htis work
14:33:30 <povman> tiglionabbit: I could NOT understand happs. The documentation is lacking. IMO you're better off getting a cgi library and doing it yourself
14:33:45 <heltav> > [x | Just x <- [Just 5, Just 7, Nothing]]
14:33:47 <lambdabot>   [5,7]
14:33:53 <heltav> > [x | x <- [Just 5, Just 7, Nothing]]
14:33:55 <lambdabot>   [Just 5,Just 7,Nothing]
14:33:56 <povman> (unless it's been given some love in the last year)
14:34:07 <skorpan> > map fromMaybe [Just 4, Just 3]
14:34:08 <lambdabot>       Overlapping instances for Show (Maybe (Maybe t) -> Maybe t)
14:34:08 <lambdabot>        aris...
14:34:10 <heltav> > [x | Nothing <- [Just 5, Just 7, Nothing,Nothing]]
14:34:10 <skorpan> darn it
14:34:11 <lambdabot>   [x,x]
14:34:14 <skorpan> :t fromMaybe
14:34:15 <lambdabot> forall a. a -> Maybe a -> a
14:34:18 <skorpan> :t fromJust
14:34:19 <lambdabot> forall a. Maybe a -> a
14:34:21 <heltav> > [x | Nothing <- [Just 5, Just 7, Nothing,Nothing]]
14:34:23 <lambdabot>   [x,x]
14:34:25 <skorpan> > map fromJust [Just 4, Just 3]
14:34:26 <lambdabot>   [4,3]
14:34:29 <heltav> eh, x,x?
14:34:37 <Phyx-> Cale: yeah, I know it would default to Integer, but didn't know it won't do that when non prelude typeclasses are present. Also good to know, thanks
14:34:42 <skorpan> heltav: Nothing matches twice
14:34:50 <Cale> heltav: It's the simplereflect package ;)
14:34:50 <heltav> yes but x
14:34:54 <mauke> > x
14:34:55 <lambdabot>   x
14:34:57 <vixey> > y
14:34:59 <lambdabot>   y
14:35:01 <Cale> > foldr f z [a,b,c]
14:35:03 <lambdabot>   f a (f b (f c z))
14:35:03 <heltav> shouldnt it cimplan x doesnt exist?
14:35:10 <skorpan> heltav: lambdabot "knows" about it
14:35:11 <mauke> heltav: yes, but x actually exists here
14:35:12 <skorpan> :t x
14:35:12 <heltav> > x
14:35:12 <heltav> > x+1
14:35:12 <saml> > let isJust Just{} = True; isJust _ = False in isJust (Just 1)
14:35:14 <lambdabot> Expr
14:35:15 <lambdabot>   x + 1
14:35:15 <lambdabot>   True
14:35:16 <lambdabot>   x
14:35:20 <Cale> heltav: All the single letter variables are defined as things which print as themselves
14:35:24 <saml> what is Just{} ?
14:35:31 <vixey> (Just _)
14:35:33 <saml> is it same as (Just _) ?
14:35:54 <Cale> saml: It's similar, but robust in the face of changes to the number of parameters to Just
14:36:03 <Cale> (not that that would ever happen in that case)
14:36:40 <Cale> (A {}) works even when A is not defined to use the record syntax
14:36:58 <skorpan> that's the best feature ever...
14:37:04 <Cale> and matches anything constructed with A without implying anything about the number of parameters
14:38:17 <saml> that could be useful for cases where you dont' have to unpack data elements
14:42:58 <Phyx-> I have a nother question http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4669 <-- explained more there with the code
14:45:25 <Cale> Phyx-: Well, enabling IncoherentInstances is rarely the right answer...
14:45:31 <Cale> Phyx-: But I don't know.
14:46:40 <Phyx-> Cale: yeah, i don't want to enable it since it could hide possble problems that might come up once i keep adding instances
14:47:44 <Cale> What is the idea behind these typeclasses?
14:49:29 <Phyx-> Well, this is mostly a uni assignment, why i'm not asking answers but just general ideas. But basically EMGM, where Logic is some kind of fixed point datatype. which is why i need to define (a (Logic a)) aswell when trying to define (Logic a)
14:52:31 <heltav> what should FFIs link to? object files?
14:54:08 <badtruffle> huh?
14:56:32 <heltav> if a C function does side-effects like printing, how does that work with haskell? are all FFI calls in the IO Monad?
14:56:53 <heltav> or is it your responsibility to intriduce them correctly to haskell?
14:57:12 <heltav> ie can FFI poison the typesystem?
14:57:18 <heltav> as in break referential transparency
14:57:36 <glguy> ffi calls are in IO if you say they are
14:57:40 <glguy> and you should say they are if they are :)
14:58:29 <mauke> heltav: yes, FFI can break your program
15:16:34 <heltav> why isnt all FFI callsforced into the IO monad?
15:16:43 <heltav> convenience?
15:16:50 <mauke> some functions are pure
15:16:52 <Twey> Because many of them are pure
15:17:01 <Twey> That's what unsafePerformIO is for
15:17:21 <Twey> It allows the developer to decide what's pure and what isn't, since Haskell obviously can't type-check other languages
15:17:57 <heltav> when you malloc and free inside a function do you do them in the io monad then? nothing special else?
15:18:39 <Cale> They should be in the IO monad if they have side effects.
15:19:06 <Cale> Basically, it's only okay to unsafePerformIO things which compute proper mathematical functions whose results only depend on their inputs.
15:20:19 <heltav> yes but mallocing and freeing is no problem?
15:20:22 <mux> Cale: even then, I find it more satisfying to use the ST monad and runST if possible
15:20:38 <Cale> heltav: if the same function does both.
15:20:59 <Cale> heltav: I suppose it's also possible to put the free into a finaliser
15:21:49 <Cale> heltav: so you create an opaque value returned from the FFI wrapper which contains the pointer to the allocated memory, and which when garbage collected will call free.
15:21:56 <ksf> if someone needs a program to work on, the unix world could use a new xkeycaps.
15:22:02 <Twey> heltav: So long as it's semantically pure
15:22:21 <Twey> ksf: *nods* I thought of that myself.  I don't need it that badly, though.
15:22:39 <Twey> heltav: Basically, if the calling code isn't affected by the side effects, they can be ignored
15:23:38 <heltav> so I tried to se what happens if I make a pure function do sideeffects
15:23:43 <heltav> it seems they were just ignored...
15:24:18 <nominolo> @seen ndm
15:24:19 <lambdabot> I haven't seen ndm.
15:24:36 <Twey> heltav: They'll be performed if you force evaluation, but not otherwise
15:25:20 <HeavensRevenge> hello
15:25:55 <HeavensRevenge> how can i use a result of a function as the next argument of an itertion...
15:26:19 <monadic_kid> HeavensRevenge: accumlator style function i think you want
15:26:33 <HeavensRevenge> something like... [x*x | x <- [2,x..]]
15:27:01 <HeavensRevenge> im havin a hard time tryin to think this out
15:27:03 <pshc> This is weird... I've got myList :: [(String, MyParser ())] in my module which works fine, but when I try to do map fst myList, ghc complains about illegal overloaded type signatures in a binding group that falls under the monomorphism restriction (gasp!)
15:27:14 <Twey> HeavensRevenge: Define вЂiterationвЂ™
15:27:24 <Twey> Also see iterate
15:27:26 <Twey> :t iterate
15:27:27 <lambdabot> forall a. (a -> a) -> a -> [a]
15:27:29 <pshc> How is it that only asking for the String parts causes this error :(
15:27:30 <Twey> e.g.
15:27:36 <Twey> > iterate (*2) 1
15:27:37 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
15:27:50 <HeavensRevenge> hmm
15:28:00 <Berengal> There's also until
15:28:06 <Berengal> > until (==10) (+1) 0
15:28:07 <lambdabot>   10
15:28:15 <Twey> Aye
15:28:55 <Berengal> > until ((>20).length) show ""
15:28:56 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
15:29:07 <HeavensRevenge> ok, but use the result as the argument, damn close tho!!!
15:29:11 <monadic_kid> HeavensRevenge: if you want to know how to write such functions you want read abouve accumlative functions
15:29:36 <Twey> HeavensRevenge: Both those functions use the result of the function as the argument to the function to generate the next one
15:29:40 <HeavensRevenge> its more of a recursive replacement
15:29:57 <HeavensRevenge> every time its recursed, replace the arguments with the result..
15:30:10 <HeavensRevenge> if that makes more sense
15:30:17 <Twey> Not much
15:30:29 <Twey> Write us some pseudo-code
15:30:44 <monadic_kid> i'm sure he just means accumlators
15:30:46 <HeavensRevenge> take 4 iterate (*2) 1
15:30:54 <HeavensRevenge> > take 4 iterate (*2) 1
15:30:55 <lambdabot>   Couldn't match expected type `[a]'
15:31:00 <Twey> > take 4 (iterate (*2) 1)
15:31:02 <lambdabot>   [1,2,4,8]
15:31:11 <Twey> > take 4 $ iterate (*2) 1 -- a.k.a.
15:31:12 <lambdabot>   [1,2,4,8]
15:31:27 <HeavensRevenge> ok that should be [1,2,4,16,256..]
15:31:46 <HeavensRevenge> except no 1 at the beginning
15:31:47 <mauke> > iterate (^2) 2
15:31:48 <HeavensRevenge> start from 2
15:31:48 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
15:32:38 <HeavensRevenge> aha!! ok geez...
15:32:43 <Twey> The second argument of iterate is an initial value
15:32:52 <HeavensRevenge> awesome :P
15:34:53 <HeavensRevenge> thank you Twey
15:35:36 <Twey> No problem
15:35:39 <Twey> Don't forget mauke :-P
15:37:32 <Berengal> > iterate (uncurry (*) . join (,)) 2
15:37:33 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
15:38:16 <HeavensRevenge> haha awesome mauke and Berengal
15:38:24 <Twey> Heh
15:38:37 <hatds> man I just realized that my school has a pretty cool programming language research group
15:38:50 <Berengal> Actually
15:38:51 <mauke> > iterate (join (*)) 2
15:38:52 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
15:38:56 <Berengal> > iterat...
15:38:58 <lambdabot>   <no location info>: parse error on input `;'
15:39:00 <Berengal> I was about to do that
15:39:44 <hatds> only downside is that I'm not in the CS department, so I don't have easy ways to mingle
15:39:49 <Berengal> (->) r monad is awesome...
15:40:04 <Zao> hatds: Determine when they drink coffee, stealth in.
15:40:11 <hatds> hehe
15:40:27 <hatds> "how about that Haskell' prime guys?"
15:40:36 <Zao> "Hello there. I am here to steal all your ideas for my own papers."
15:40:40 <Berengal> Haskell' prime is a bit redundant
15:40:40 * Twey laughs.
15:40:47 <SubStack> haskell double prime!
15:40:50 <Twey> redundantly redundant.
15:40:52 <Zao> Haskell Bis.
15:40:53 <Berengal> Haskell" ?
15:40:55 <hatds> how about them boxy types?
15:41:12 <Berengal> hatds: Why not just ask to be able to join them?
15:41:32 <SubStack> chime in with "sup dawg, I heard you like referential transparency"
15:41:39 <hatds> Berengal: well, I'm not sure what I can do or where I would go with it
15:41:44 <Zao> Cross-departmental participation is probably not a bad thing.
15:42:39 <Berengal> hatds: Just say you're interested then
15:42:40 <hatds> I'm sure I could sit in on classes, and obviously seminars are publicly open to begin with
15:43:56 <hatds> Berengal: I guess, maybe I will try that.  It'd be nice to be able to say something beyond "I'm interested" though
15:44:39 <Twey> Design a hugely popular programming language and join them as a guest speaker.
15:44:40 * cypher- likes the idea that at his university a student can attend any lecture he wishes, except very small subset of courses (some medicine-related stuff)
15:45:09 <hatds> Twey: I'll wear my SPJ disguise then
15:45:14 * Twey grins.
15:45:24 <ksf> I seriously doubt I would be kicked out of any lecture, even though I'm not rolled in, any more.
15:45:38 <Berengal> ksf: "any more"?
15:46:05 <ksf> as in "there might be strange stories still being told"
15:46:22 <Berengal> Not in here they aren't
15:46:25 <kerlo> cypher-: they're not generally allowed to attend those courses?
15:46:35 <hatds> I think that's standard really
15:46:57 <hatds> *that you can attend any course
15:47:31 <pastorn> i will have to do submissions for a summer course in a month or so in C#
15:47:49 <pastorn> is it possible to implement monads in C#?
15:47:54 <kerlo> At Grand Valley, you're apparently allowed to audit a course, which apparently means that you're simply allowed to show up; you get neither a grade nor credit. The price is the same.
15:48:07 <pastorn> (with the new lambda expression addition, or otherwise)
15:48:16 <curiousfocus> kerlo: Michigan?
15:48:19 <kerlo> Yes.
15:48:30 <curiousfocus> kerlo: I goto Central
15:49:09 <curiousfocus> cypher-: There were several classes this year that I rarely attended
15:49:45 <kerlo> I wonder how expensive it would be to audit every course.
15:49:57 <curiousfocus> man, it sucks, but the paper is all that matters
15:50:26 <hatds> it is not free?
15:51:09 <kerlo> I think it says it's not free.
15:51:41 <Berengal> Man, I'm glad I live in a country where higher education is free
15:52:18 * curiousfocus drools
15:52:40 <curiousfocus> I've heard stuff about 'unofficially' auditing courses
15:52:41 * Twey considers moving to Norway
15:52:47 <curiousfocus> you just need to arrange it with the prof
15:52:52 <hatds> I think I'd be covered anyway since all my normal grad tuition is paid for
15:53:24 <kerlo> Yeah, tuition for auditing is the same as for credit.
15:53:48 <curiousfocus> yeah, if you have a prof that really likes you though, I'm sure *in some cases* you could do it 'unofficially'
15:53:52 <kerlo> I want to live in a country where higher education is free.
15:54:08 <curiousfocus> kerlo: how much is a credit hour at GV?
15:58:11 <hatds> no one here would happen to be faculty at upenn would they? :)
16:03:18 <heltav> 2type (~~>)
16:03:34 <heltav> @type (~~>)
16:03:35 <lambdabot> Not in scope: `~~>'
16:04:29 <kerlo> A credit hour at GVSU is $256 to $373.
16:04:39 <kerlo> For undergrads, that is.
16:04:40 <heltav> @type (~)
16:04:41 <lambdabot> parse error on input `)'
16:05:01 <kerlo> And assuming you're a resident of Michigan. I am.
16:08:45 <hatds> thing is that the programming language group looks like a small offshot of the greater CS department, there is only maybe 1 course a semester with relevant theory
16:08:58 <pshc> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2352#a2353 Combinator library vs. monomorphism restriction... I'm not really sure how the restriction applies or if it's causing this error, though... Thoughts?
16:08:59 <hatds> and I think several of the books I've already read
16:12:20 <pastorn> @can i use haskell code in my c# project?
16:12:21 <lambdabot> Maybe you meant: faq map run wn
16:12:28 <pastorn> @faq can i use haskell code in my c# project?
16:12:28 <lambdabot> The answer is: Yes! Haskell can do that.
16:12:58 <lament> in comments.
16:13:17 <mauke> .oO( http://mauke.ath.cx/stuff/poly.poly )
16:15:31 <monadic_kid> pastorn: you can write monads in irtually any programming language (that doesn't necessarily mean it will be nice to do it though). All you need to do is define 2 functins bind and return that obey some axioms and your good to go
16:20:38 <pshc> ... anyone? anyone?
16:20:53 <Saizan> pshc: those definitions are mutually recursive
16:21:28 <pshc> hmm
16:21:41 <Saizan> pshc: so they are typechecked together, and the Monomorphism Restriction applies to the ones without a type signature, since they don't take any parameter
16:22:03 <Saizan> so the fact that one of those has a polymorphic signature is causing problems
16:22:07 <pshc> ok
16:22:15 <Saizan> you should give it to all of them
16:22:20 <pshc> So either I need to break the cycle or specify types for all eh
16:22:27 <Saizan> or use NoMonomoprhimRestriction
16:22:31 <pshc> oshi--!
16:22:49 <pshc> Great, thanks
16:22:54 <Saizan> like {-# LANGUAGE NoMonomorphismRestriction #-} on top of your file
16:22:59 <pshc> yeah
16:23:02 <Twey> Or add an argument
16:23:12 <pshc> ?
16:23:14 <Saizan> (it's the first time i see that error btw)
16:23:24 <Saizan> adding an argument doesn't make sense there
16:24:30 <Saizan> pshc: Twey is referring to the fact that e.g. if you defined reserved as reserved () = P.reserved lexer then the MR wouldn't apply to it
16:25:04 <Saizan> but then you'd have to supply that argument when you want to use it
16:25:09 <pastorn> monadic_kid: you don't know about any implementation in C#?
16:25:13 <pshc> Hoho.
16:25:39 <pshc> interesting, guess I'd better learn about the restriction in more depth
16:25:49 <pshc> I guess NoMonomorphismRestriction has its downsides too eh
16:25:52 <Saizan> the best description is from the haskell report
16:26:06 <Saizan> the worst that can happen is that you lose some sharing
16:27:56 <Saizan> which is exactly what happens when you add an useless argument
16:28:23 <Saizan> then in each place you use (reserved ()) you'll compute a different value for it
16:28:30 <pshc> Ah yeah hehe
16:28:53 <Saizan> but in this case it won't matter, i think
16:29:46 <Saizan> the MR is there so that people don't get surprised by lost sharing due to typeclass polymorphism
16:30:33 <Saizan> but it drives mad  everyone that indeed want that polymorphism :)
16:30:53 <monadic_kid> pastorn: LINQ
16:31:26 <Twey> See also http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hs-dotnet
16:32:02 <monadic_kid> pastorn: but seriously i'm sure you can easilly find some on the net
16:35:11 <pastorn> monadic_kid: thanks :)
16:42:30 <monadic_kid> pastorn: the best thing to do is understand that "bind" is kind of composition operator for "actions" and "return" takes some pure value and puts injects into the level of actions
16:43:25 <dibblego> pastorn, in C# there is also a semi-colon ;
16:44:11 <monadic_kid> haskell has semi-colons too ;)
16:44:20 <mauke> В·
16:44:51 <HeavensRevenge> hello
16:44:53 <roconnor> but haskell's semi-colons are basically sugar for bind
16:44:55 <dibblego> I mean, as a monad implementation
16:45:11 <pastorn> monadic_kid: i know how monads work, i just wondered if there exists an implementation in c#
16:45:15 <monadic_kid> roconnor: nothing to do with do notion
16:45:17 <hatds> nah, they are a sugar for layout :)
16:45:22 <hatds> or vice versa maybe
16:45:40 <HeavensRevenge> Twey is there a way.. to allow a 3rd in this-
16:45:46 <roconnor> well, semi-colans are used for layout, and the layout in do notation is sugar for bind
16:45:53 <HeavensRevenge> iterate (^2) 2
16:45:55 <marcusb> hi, I did a little bit with haskell in 2004, but I am basically a newbie.  I have extensive CS and programming background, though.  does it matter if I start with hugs or ghc?  do I start with the "Learning" section on haskell.org?
16:46:07 <roconnor> 3rd?
16:46:09 <dibblego> pastorn, the general monad abstraction cannot be written in C#'s type system, but there are many implementations -- see SelectMany from LINQ, there is also the semi-colon and exceptions
16:46:37 <dibblego> marcusb, it is strongly recommended to start with GHC
16:46:53 <dibblego> marcusb, if you get stuck on anything please feel free to ask for help here
16:46:57 <ksf> marcusb, use ghc, and forget everything you know about programming.
16:46:58 <marcusb> ok, great
16:47:04 <Twey> HeavensRevenge: вЂA thirdвЂ™?
16:47:15 <marcusb> ksf: I am familiar with functional programming concepts
16:47:24 <HeavensRevenge> like... foldl  (2+..) (iterate (^2) 2)
16:47:28 <ksf> ...so i thought, too, coming from scheme...
16:47:37 <roconnor> marcusb: forget half of what you know about functional programming :)
16:47:37 <dibblego> ksf, :)
16:47:38 <Twey> foldl?
16:47:39 <marcusb> ksf: but I don't know the syntax and I don't know programming concepts for bigger programs.
16:47:39 <Twey> map?
16:47:40 <pastorn> dibblego: semi-colon and exceptions?
16:47:44 <HeavensRevenge> or a+a^a
16:47:44 <marcusb> roconnor: ok :)
16:47:49 <roconnor> marcusb: in particular forget about tail recuursion
16:47:55 <pastorn> dibblego: like java exceptions?
16:47:58 <Twey> > map (+2) $ iterate (^2) 2
16:47:59 <lambdabot>   [4,6,18,258,65538,4294967298,18446744073709551618,3402823669209384634633746...
16:48:08 <ksf> anyway, the royal road de jour to haskell is learn you a haskell -> real world haskell -> typeclassopedia
16:48:08 <marcusb> roconnor: hey, that *is* about half I know about it :)
16:48:13 <Berengal> > iterate ((+2).(^2)) 2 -- like this?
16:48:14 <lambdabot>   [2,6,38,1446,2090918,4371938082726,19113842599189892819591078,3653389789066...
16:48:19 <HeavensRevenge> or a double iterate?
16:48:22 <roconnor> marcusb: I think the remaining half is fine.
16:48:30 <HeavensRevenge> lol
16:48:34 <dibblego> pastorn, sure, but C# exceptions are unchecked -- notice that the "potential failure" sequences through callers -- like the Either monad (where Left is failure)
16:48:35 <hatds> watch "A taste of Haskell" with accompany slides: http://www.haskell.org/haskellwiki/Video_presentations    pause the video so you can parse everything that's said and written
16:48:36 <Twey> Which do you want?
16:48:56 <hatds> that's the best way to grok the basics of do notation and typeclasses
16:48:58 <ksf> us haz video?
16:49:04 <pastorn> dibblego: oh, cool
16:49:24 <pastorn> dibblego: but what does that have to do with semicolon?
16:49:27 <marcusb> hatds: a video is a nice introduction to get motivated, thanks
16:49:35 <dibblego> pastorn, that's another monad implementation: IO
16:49:36 <HeavensRevenge> cool... multiple pipe like arguments inside the operator through an iteration
16:50:02 <pastorn> dibblego: ok
16:50:17 <ksf> "this guy is really strenuous. From the first minute I had an headake.... oh my god he should'n present anything... not even tv weather...."
16:50:20 <ksf> he.
16:50:22 <dibblego> pastorn, http://blog.tmorris.net/controlling-effects-with-flatmap/ might help (it's slightly Scala oriented, but mentions >>=)
16:50:24 <ksf> that's about spj.
16:50:26 <mauke> > iterate (\n -> 3 * n + 1) 1
16:50:28 <lambdabot>   [1,4,13,40,121,364,1093,3280,9841,29524,88573,265720,797161,2391484,7174453...
16:50:38 <pastorn> dibblego: cool, thanks :)
16:50:41 <Berengal> HeavensRevenge: It's called function composition
16:50:42 <monadic_kid> pastorn: if i remember correctly I saw some blogs using query keywords, it looks butt ugly though
16:50:44 <marcusb> ksf: me thinks somebody doesn't like the british accent.  but it's like monty python!
16:50:58 <roconnor> > iterate (\n -> if odd n then 3*n+1 else n `div` 2) 1
16:51:00 <lambdabot>   [1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,4,2,1,...
16:51:09 <hatds> I'm surprised I can't find any SPJ fansites on google :)
16:51:14 <mauke> > iterate (\n -> if odd n then 3*n+1 else n `div` 2) 9
16:51:15 <lambdabot>   [9,28,14,7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2,1,4,2,1,4,2,1,4,2,1,4,2...
16:51:19 <marcusb> > 1
16:51:21 <lambdabot>   1
16:51:23 <ksf> it's the second best english accent there is, just after scandinavian.
16:51:26 <Twey> Not just British, but Essex :-P
16:51:27 <marcusb> sorry, cnr :)
16:51:46 <dibblego> marcusb, a pure lazy language is significantly different to a language like Scheme, more significantly different than Scheme is to traditional imperative languages
16:51:50 <Twey> вЂBritishвЂ™ isn't an accent
16:51:54 <HeavensRevenge> lol dude spj is one crazy awesome brit!
16:51:56 <Twey> Listen to RP, then listen to Glaswegian
16:51:57 <Twey> :-P
16:52:10 <heltav> > [[Just x | Left 5 <- [Left 5, Right 7, Left 8]]
16:52:11 <lambdabot>   <no location info>: parse error on input `;'
16:52:15 <heltav> > [[Just x | Left x <- [Left 5, Right 7, Left 8]]
16:52:16 <lambdabot>   <no location info>: parse error on input `;'
16:52:17 <HeavensRevenge> lol the xmonad example vid was wonderin what would happen if he decided to jump infront of a bus
16:52:24 <heltav> > [Just x | Left x <- [Left 5, Right 7, Left 8]]
16:52:26 <lambdabot>   [Just 5,Just 8]
16:52:26 <marcusb> dibblego: wow, I wouldn't expect that.
16:52:49 <heltav> > fmap (+1) $ [Just x | Left x <- [Left 5, Right 7, Left 8]]
16:52:52 <dibblego> marcusb, yeah not many people expect that, which is why you're receiving these type of comments :)
16:52:55 <lambdabot>       No instance for (Num (Maybe t))
16:52:57 <lambdabot>        arising from the literal `1' at ...
16:53:01 <heltav> > (fmap . fmap) (+1) $ [Just x | Left x <- [Left 5, Right 7, Left 8]]
16:53:03 <lambdabot>   [Just 6,Just 9]
16:53:07 <Berengal> > let loeb x = fmap (\a -> a (loeb x)) x in loeb $ const 0:const 1:[(+1).(!!(if odd n then 3*n+1 else div n 2)) | n <- [2..]]
16:53:12 <monadic_kid> pastorn: http://blogs.msdn.com/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx
16:53:15 <davidL> > [[Just x | Left x <- [Left 5, Right 7, Left 8]]]
16:53:17 <marcusb> dibblego: and that's why ghc and not hugs, I guess (I just read in google that hugs is not lazy?)
16:53:18 <lambdabot>   [0,1,2,8,3,6,9,17,4,20,7,15,10,10,18,18,5,13,21,21,8,8,16,16,11,24,11,112,1...
16:53:20 <lambdabot>   [[Just 5,Just 8]]
16:53:25 <mauke> Berengal: needs more fix
16:53:25 <heltav> > [Just (x+1) | Left x <- [Left 5, Right 7, Left 8]]
16:53:27 <lambdabot>   [Just 6,Just 9]
16:53:45 <dibblego> marcusb, no GHC is just more mature and well supported -- when you have questions, ask here and most people will be using GHC
16:53:47 <Gracenotes> hm. Thanks to Haskell I'm fully spelling out all of my decimal literals in other languages :) 0.5 instead of .5
16:53:58 <Twey> :t fromLeft
16:54:00 <lambdabot> Not in scope: `fromLeft'
16:54:02 <marcusb> dibblego: ah ok
16:54:05 <heltav> @type catMaybe
16:54:06 <lambdabot> Not in scope: `catMaybe'
16:54:07 <Twey> @hoogle fromLeft
16:54:07 <lambdabot> No results found
16:54:20 <Berengal> Gracenotes: Thanks to haskell I tend to write my floats without decimals...
16:54:23 <Gracenotes> Twey: used to be in the library, apparently, but taken out and not missed
16:54:26 <pastorn> Twey: use the function "either"
16:54:38 <Berengal> mauke: Please feel free to golf that ;)
16:54:42 <Twey> I'd prefer вЂleftsвЂ™ here
16:54:42 <pastorn> @type either
16:54:43 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
16:54:52 <Gracenotes> lefts is nice
16:55:01 <dibblego> @djinn Either a b -> a -> a
16:55:02 <lambdabot> f a b =
16:55:02 <lambdabot>     case a of
16:55:02 <lambdabot>     Left c -> c
16:55:02 <lambdabot>     Right _ -> b
16:55:11 <Gracenotes> Berengal: :) yeah, that too...
16:55:14 <Twey> > lefts [Left 5, Right 7, Left 8] >>= return . (+1)
16:55:15 <lambdabot>   Not in scope: `lefts'
16:55:18 <Gracenotes> so much coercion elsewhere
16:55:19 <Twey> Bah
16:55:28 <Gracenotes> lefts is not in scope. nor is the amazing function partitionEithers
16:55:50 <hatds> sunglass face operator, I've been saying we need to allow infix emoticons
16:56:13 <pastorn> @let fromLeft (Left x) = x
16:56:14 <lambdabot>  Defined.
16:56:16 <Berengal> isLeft Left{} = True; isLeft _ = False; partitionEithers = partition isLeft
16:57:09 <pastorn> Berengal: what notation is "Left{}"?
16:57:14 <Twey> Record notation
16:57:30 <pastorn> why not "Left _"?
16:57:31 <heltav> Ёp
16:57:38 <Twey> *shrugs* Shorter, I guess
16:57:46 <Berengal> > let foo Left{} = True in [foo (Left 1), foo (Right "hello")]
16:57:48 <lambdabot>   [True,* Exception: /tmp/7412987797104020017:71:40-56: Non-exhaustive patter...
16:57:52 <Twey> Hehe
16:58:12 <Berengal> Left{} matches Left no matter how many arguments it takes
16:58:20 <Berengal> Left _ only matches Left if it takes one argument
16:58:26 <Berengal> Should the definition of Left ever change...
16:58:32 <Twey> Oh don't be daft
16:58:44 <Berengal> Also, no need for parenthesis
16:59:12 <pastorn> "* Exception: /tmp/7412987797104020017:71:40-56: Non-exhaustive patter..." <-- kinda cool
16:59:43 <dibblego> @type either id . const
16:59:44 <lambdabot> forall b a. a -> Either a b -> a
16:59:51 <pastorn> > 1/0
16:59:53 <lambdabot>   Infinity
17:00:05 <Berengal> > (-1)/0
17:00:05 <pastorn> awww... i wanted an exception :/
17:00:06 <lambdabot>   -Infinity
17:00:10 <Berengal> div 1 0
17:00:13 <Berengal> > div 1 0
17:00:14 <lambdabot>   * Exception: divide by zero
17:00:18 <Twey> @let lefts xs = do { (Left x) <- xs; return x }
17:00:19 <lambdabot>  Defined.
17:00:30 <Twey> > lefts [Left 1, Right 2, Left 3]
17:00:30 <pastorn> > fromLeft (Right undefined)
17:00:31 <lambdabot>   [1,3]
17:00:32 <lambdabot>   * Exception: <local>:18:0-20: Non-exhaustive patterns in function fromLeft
17:00:41 <Twey> List monad FTW
17:00:54 <mauke> > let lefts xs = [x | Left x <- xs] in lefts [Left 1, Right 2, Left 3]
17:00:56 <lambdabot>   [1,3]
17:01:36 <Twey> That works
17:01:48 <Twey> @let lefts xs = [x | Left x <- xs]
17:01:48 <mauke> mmh, uniplate
17:01:49 <lambdabot>  <local>:19:0:
17:01:49 <lambdabot>      Warning: Pattern match(es) are overlapped
17:01:49 <lambdabot>               I...
17:01:54 <Twey> @forget lefts
17:01:54 <lambdabot> Incorrect arguments to quote
17:02:01 <Twey> @unlet lefts
17:02:02 <lambdabot>   Parse error
17:02:09 <Twey> Dammit, I can never remember how to do this
17:02:26 <mauke> you can't
17:02:29 <roconnor> @type lefts
17:02:30 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (Either t1 t2) -> t t1
17:02:49 <Twey> That seems annoying
17:02:56 <roconnor> @undefine
17:03:04 <roconnor> @type lefts
17:03:05 <lambdabot> Not in scope: `lefts'
17:03:10 <roconnor> @hoogle lefts
17:03:10 <lambdabot> Language.Haskell.Lexer LeftSquare :: Token
17:03:10 <lambdabot> Language.Haskell.Syntax HsLeftSection :: HsExp -> HsQOp -> HsExp
17:03:38 <dsfox> Does anyone know of a Haskell library that allows you to to open a window and draw simple graphics on a Mac?  Preferably system indepenent...
17:04:08 <Berengal> > left (Just (Right 1) :: Maybe (Either String Int))
17:04:09 <lambdabot>   Couldn't match expected type `a b' against inferred type `Maybe'
17:04:29 <Berengal> > lefts (Just (Right 1) :: Maybe (Either String Int))
17:04:29 <lambdabot>   Not in scope: `lefts'
17:05:02 <Berengal> >let lefts xs = do { (Left x) <- xs; return x } in lefts (Just (Right 1) :: Maybe (Either String Int))
17:05:09 <Berengal> Argh!
17:05:16 <Berengal> > let lefts xs = do { (Left x) <- xs; return x } in lefts (Just (Right 1) :: Maybe (Either String Int))
17:05:17 <lambdabot>   Nothing
17:05:19 <Berengal> Yay!
17:06:16 <simpletext> anybody teaching haskell today?
17:06:46 <Berengal> simpletext: As in at a university, or just in this channel?
17:07:29 <simpletext> i mean right here
17:08:03 <davidL> anyone here familiar with haskore?
17:08:27 <Berengal> simpletext: We're not holding lectures or anything...
17:10:46 <simpletext> i guess i'll think of a question
17:11:46 <marcusb> would it be a terrible mistake to think about a "type Stack w" as a template a la template<class w> Stack ?
17:12:02 <Twey> Pretty terrible
17:12:04 <roconnor> @where learnyouahaskell
17:12:05 <mauke> no
17:12:05 <lambdabot> I know nothing about learnyouahaskell.
17:12:06 <marcusb> :)
17:12:12 <mauke> but it's a template typedef
17:12:34 <Gracenotes> except without all the weirdness of typedef vs. typename.
17:12:38 <simpletext> does haskell have primitive types?
17:12:45 <Gracenotes> yes
17:12:50 <marcusb> mauke: ah ok
17:12:52 <Gracenotes> well, GHC does.
17:12:53 <Twey> Define вЂprimitive typesвЂ™
17:13:01 <Twey> GHC has unboxed types
17:13:01 <augustss> marcusb: they are similar
17:13:03 <hatds> it's like templates, but much nicer as you'll see
17:13:14 <Twey> And there are plenty of types that don't take arguments
17:13:26 <mauke> marcusb: type is typedef, data is struct/union/enum
17:13:27 <Saizan> ?where LYAH
17:13:27 <lambdabot> www.learnyouahaskell.com
17:13:45 <marcusb> what I mean is it serves a similar purpose of generalizing the code
17:13:56 <augustss> yes
17:14:00 <Gracenotes> GHC has unboxed types that are for the most part 'primitive', but it doesn't normally expose them. They essentially compile straight down to 'primitive' types in assembly, etc.
17:14:00 <augustss> it can
17:14:13 <simpletext> primitive types like char, int  or list,tuple
17:14:22 <mauke> define "primitive"
17:14:43 <Gracenotes> hm. :\ you mean built-in...
17:14:46 <Gracenotes> :?
17:14:51 <Berengal> [] really isn't different from "List a = Nil | Cons a (List a)"
17:14:58 <simpletext> i dont know ive seen both terms used
17:15:14 <simpletext> i guess a char in C is more primitive than a list in python
17:15:20 <simpletext> but yeah built in
17:15:31 <Twey> It has lots of built-in types
17:15:31 <Gracenotes> the base libraries of Haskell are, in fact, written entirely in Haskell
17:15:34 <augustss> Lists, tuples, booleans, etc are not what I'd call primitive
17:15:42 <Twey> Int, Integer, Boolean, &c.
17:16:02 <Berengal> simpletext: If you're thinking of primitive vs non-primitive as the divide that exists in Java between primitive types like int, char etc. and classes, then no
17:16:05 <mauke> Char, [], [Char], Integer, Ratio Integer have special syntax
17:16:07 <mauke> and tuples
17:16:12 <Gracenotes> simpletext: these are the only things that Haskell can't do: http://www.haskell.org/ghc/docs/6.10-latest/html/libraries/ghc-prim/GHC-Prim.html
17:16:20 <dibblego> if by primitive, you mean language syntactic support, then [] and Monad, Char, Integer
17:16:22 <simpletext> lets call it primordeal types then
17:16:27 <simpletext> or built in
17:16:32 <simpletext> lol
17:16:35 <Gracenotes> in terms of functionality. Everything else based on it can be implemented in Haskell
17:16:37 <Berengal> mauke: Ratio Integer has special syntax now?
17:16:44 <mauke> Berengal: 12.345
17:16:59 <Berengal> > 12.345 :: Ratio Integer
17:17:00 <lambdabot>   2469%200
17:17:02 <Berengal> Wow
17:17:14 <Twey> Hehe
17:17:16 <hatds> :t 12.345
17:17:17 <lambdabot> forall t. (Fractional t) => t
17:17:24 <Gracenotes> @src Fractional
17:17:24 <lambdabot> class  (Num a) => Fractional a  where
17:17:24 <lambdabot>     (/)             :: a -> a -> a
17:17:24 <lambdabot>     recip           :: a -> a
17:17:24 <lambdabot>     fromRational    :: Rational -> a
17:17:28 <Berengal> Ah
17:17:32 <Berengal> So no then ;)
17:17:45 <augustss> It's defined by fromRational applied to the Rational constant
17:17:46 <Berengal> (Not more than other numeric literals anyway)
17:18:01 <Saizan> a bit more in some sense
17:18:02 <Twey> Why is Firefox such a BRPoC lately *grumbles*
17:18:05 <Gracenotes> (12 + (345%1000))
17:18:12 <Saizan> since all other types go through a Rational
17:18:37 <augustss> Haskell numeric literals are really either Integer or Rational
17:18:49 <marcusb> it may become clearer later, but I see "swap :: Stack w -> Stack w" as a declaration and an equation like "swap [] = []" as part of the implementation/definition.  Does the implementation need to follow the declaration (and come before the next declaration), or is such scoping not required?  the lack of syntactical boundaries seem to suggest the latter.
17:18:57 <augustss> And then an implicit fromInteger or fromRational
17:19:05 <Berengal> It's not hard to define read :: String -> Integer (or Rational) though
17:19:16 <hatds> what do you mean follow the declaration?
17:19:36 <augustss> marcusb: the type signature can be anywhere.  Or omitted.
17:19:36 <hatds> oh yes, it has to come directly underneath
17:19:38 <marcusb> hatds: would it be valid to put "swap [] = []" before "swap :: ..." ?
17:19:41 <marcusb> ah ok
17:19:43 <hatds> er
17:19:46 <Gracenotes> simpletext: so ja. If you mean syntax, there is some built-in support, but most stuff (including the core libraries) can be re-implemented in Haskell, if at the forfeit of some syntactic sugar
17:19:48 <hatds> maybe I'm mistaken :(
17:19:56 <marcusb> he, I could just try it out I guess
17:20:07 <hatds> you can't split up the equations, they have to come together... maybe the type signature can be separated though
17:20:16 <augustss> it can
17:20:17 <monochrom> marcusb: Yes you can re-order.
17:20:27 <Saizan> > let f :: a -> a; g x = x; g :: a -> a; f x = x in f (g 1)
17:20:28 <lambdabot>   1
17:20:47 <monochrom> Spread them out all over the file in random places.
17:20:47 <gwern> @remember bos The last couple of times I've wanted a book like that, I wrote the book myself. It's a very effective way to get the book you want, compared to wishing.
17:20:48 <lambdabot> Good to know.
17:20:59 <gwern> he is a cruel man
17:21:16 <monochrom> he is a make-things-happen man.
17:21:19 <hatds> man I'm way off :)
17:21:22 <marcusb> mmh, ghc doesn't accept any of these lines.  do I need a preambel?  I get parse error on =, not in scope "swap", parse error on "type" etc.
17:21:40 <marcusb> ghci
17:21:47 <monochrom> Put them in a file.
17:21:48 <Saizan> you need to put those in a file
17:22:03 <marcusb> argh, why is that?
17:22:03 <simpletext> ok thanks for the info
17:22:16 <mauke> because ghci evaluates expressions (mostly)
17:22:21 <augustss> marcusb: because ghci is severly misdesigned
17:22:26 <Berengal> ghci is speshul
17:22:31 <marcusb> a type definition is not an expression?
17:22:33 <gwern> monochrom: it's cruel to tell someone saying it'd be nice to have an effective haskell book that 'you should do what I did and write the book'
17:22:33 <Saizan> "let f :: a -> a; g x = x; g :: a -> a; f x = x" also works in ghci, but not for type/data/class/instance/..
17:22:37 <mauke> marcusb: right
17:22:40 <gwern> if he could write the book, he wouldn't need it...
17:22:46 <marcusb> oook
17:22:52 * gwern could find my glasses, if only I could see
17:23:02 <marcusb> so, this is not like lisp
17:23:18 <mauke> it's only an expression if it can be evaluated :-)
17:23:43 <hatds> ghci is a very handy interpreter, but haskell is a compiled language
17:23:44 <augustss> gwern: I bet bos didn't know everything before writing RWH.  you learn as you write
17:23:52 <mauke> hatds: hahaha
17:23:53 <marcusb> hatds: I didn't realize that.
17:24:00 <mauke> marcusb: (it isn't)
17:24:22 <augustss> Haskell (the language) has no opinion about being compiled or not.
17:24:25 <marcusb> hey, I didn't want to start a fight :)
17:24:28 <gwern> @quote narwhal
17:24:28 <lambdabot> No quotes match. I feel much better now.
17:24:28 <monochrom> I see. I agree that it is cruel to impose it on other people. I disagree that if one could write the book one wouldn't need it.
17:24:32 <Berengal> Haskell is a language. Some implementations interpret, some compile
17:24:42 <marcusb> ok
17:24:53 <hatds> "most of the time you write stuff in text files and tell ghc to compile them"
17:24:55 * marcusb adjusts expectations
17:24:57 <simpletext> does that both interprete any ghci command you type here?
17:24:59 <Berengal> Some do both, but treat the language differently...
17:25:14 <hatds> well whatever :)
17:25:26 <simpletext> i meant to type bot
17:25:36 <monochrom> I have finite memory. A reason I may want to write a book is to use it as a Turing tape to extend my memory.
17:25:41 <Saizan> simpletext: if you prefix the expression with "> "
17:25:43 <Berengal> simpletext: In a way. It's slightly different, but it's mostly true
17:25:51 <augustss> marcusb: ghci is handy for testing things that you have already put in a file.  you just tell ghci to load it and then you can evaluate expressions.
17:26:01 <Twey> monochrom: Well, that's debatable
17:26:14 <Twey> The limit of human long-term memory has never been found
17:26:27 <monochrom> Therefore you are cruel too. You have infinite memory, and you tell me if you could write a book you wouldn't need it, and you impose your superiority upon me, too, and you're cruel.
17:26:52 <ksf> it's kinda holographic.
17:27:01 <Berengal> Writing a book means you won't forget, but it doesn't mean you'll have to read the book to remember either...
17:27:27 <monochrom> All of you are cruel.
17:27:28 <marcusb> ok, I think I made a mistake of not forgetting enough :)
17:27:43 <Berengal> I, at least, find I tend to remember things much better once I've written it down. It doesn't mean I have to re-read my writings (thankfully)
17:27:52 <dolio> Maybe monochrom has Vancian computer sience knowledge.
17:28:03 <hatds> Berengal: I think most people are like that
17:28:18 <mauke> @quote DukeDave
17:28:19 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:28:47 <hatds> why would you want to unlearn Haskell?
17:28:53 <ksf> you have to remember the correct angle to peek at the hologram source, too.
17:28:59 <Berengal> @quote learning.*curve
17:28:59 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:29:04 <Berengal> @quote learning.*curve
17:29:04 <lambdabot> DukeDave says: Haskell has the greatest unlearning curve
17:29:07 <Berengal> Bah
17:29:09 <monochrom> No, it means unlearning other things when you learn haskell.
17:29:20 <monadic_kid> hatds:  that didn't imply unlearning haskell
17:29:39 <monochrom> Learning is unlearning.
17:29:41 <bos> hey, i think it would be great if jason wrote a book. my tongue wasn't in my cheek even a weensy bit when i chided him.
17:30:03 <hatds> need better delivery on my jokes
17:30:07 <mauke> @quote 's.lear
17:30:07 <lambdabot> lilac says: haskell's learning curve is like this: |
17:30:12 <hatds> lol
17:30:16 <monochrom> Learning is unlearning. Intuition is experience. Understanding is feeling.
17:30:28 <Berengal> monochrom: It also works the other way: It's much harder to "unlearn" the awesome stuff in haskell when going back to a lesser featured language
17:31:01 <Twey> вЂWar is peace.  Freedom is slavery.  Ignorance is strength.вЂ™ :-P
17:31:11 <Berengal> @quote learning.*steeper
17:31:11 <lambdabot> joelr says: the learning curve is far steeper with Haskell but it is far more elegant and readable
17:31:21 <monochrom> Programs are predicates. Programming is proving. Termination is timing.
17:33:04 <shepheb> @quote vending.machine
17:33:04 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
17:33:04 <lambdabot> of insight hits and it all makes sense.
17:33:30 <marcusb> spj says the compiler could warn if there is a missing case in the pattern list for a function, for example if you remove "swap (w : []) = w : []"  is that actually implemented?
17:33:40 <monochrom> Another possibility: bam! suddenly you die.
17:33:42 <sjanssen> marcusb: yes
17:33:43 <hatds> I think you have to use a flag
17:33:46 <marcusb> I tried running ghc on it without the line and don't get anything
17:33:59 <sjanssen> marcusb: try turning on -Wall
17:34:08 <Jebdm> It's a flag.  If it actually comes up at runtime, it'll throw an exception.
17:34:15 <marcusb> I only get missing main
17:34:25 <ksf> @remember monochrom Learning is unlearning. Intuition is experience. Understanding is feeling.
17:34:25 <lambdabot> Nice!
17:34:45 <tiglionabbit> I'm still having trouble thinking about a few things in haskell.  First, how does groupBy work?  Is there an easy way to check the source of it?
17:34:45 <hatds> put a "main = return ()" somewhere in your file
17:34:56 <ksf> @src groupBy
17:34:56 <lambdabot> groupBy _  []       =  []
17:34:56 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
17:34:56 <lambdabot>     where (ys,zs) = span (eq x) xs
17:35:07 <sjanssen> marcusb: or just 'ghci -Wall myfile.hs'
17:35:08 <ksf> @src span
17:35:08 <lambdabot> Source not found. Where did you learn to type?
17:35:14 <ksf> jikes
17:35:26 <hatds> :t span
17:35:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:35:35 <Berengal> @src break
17:35:35 <lambdabot> break p =  span (not . p)
17:35:43 <Berengal> Helpfull В¬_В¬
17:35:46 <marcusb> hatds: thanks that works
17:35:54 <marcusb> impressive
17:35:58 <marcusb> does this even work for custom types?
17:36:05 <sjanssen> marcusb: yes
17:36:23 <Berengal> marcusb: It breaks on more advanced patterns (like view patterns)
17:36:26 <marcusb> I wonder if you could make the compiler work really hard on finding these issues with complicated rules
17:36:51 <marcusb> sounds like an opportunity to run this part of the compiler as an interpreter :)
17:36:59 <monochrom> This much is not hard to a computer.
17:37:03 <hatds> he'll say more about pattern matching and covering all the cases as you go on in the video
17:37:08 <marcusb> ok
17:37:24 <marcusb> I guess it depends on how complicated the patterns are allowed to be
17:37:58 <hatds> man I can almost recite A taste of Haskell from memory :)
17:38:00 <Saizan> there is in fact a project on this called catch
17:38:06 <monochrom> Patterns are not hard. Here is why: "f x x = ..." is forbidden. That makes the whole thing easy.
17:38:12 <marcusb> I see
17:38:40 <Twey> > let f x x = x in f 5 5
17:38:41 <lambdabot>       Conflicting definitions for `x'
17:38:41 <lambdabot>      In the definition of `f'
17:38:48 <Twey> Hmnhmn
17:38:50 <Twey> Odd
17:39:16 <hatds> that error message could be better
17:39:30 <Twey> No, it makes sense
17:39:42 <tiglionabbit> man, groupby has such a weird behavior and implementation.  I've seen it used to split a string on capital letters
17:39:53 <Berengal> , let firstAndLast xs  = (head xs, last xs); addFirstAndLast (firstAndLast -> (h,t)) = h + t in addFirstAndLast [1..10]
17:39:54 <lunabot>  11
17:40:00 <hatds> yea, true but that error message makes me think of let's
17:40:02 <Twey> But it seems odd that it shouldn't simply require the two arguments to be the same
17:40:06 <Twey> I suppose that only works for Eq
17:40:08 <Berengal> The above definition for addFirstAndLast gives a warning about overlapping patterns
17:40:18 <Twey> hatds: lets don't conflict: they shadow
17:40:22 <marcusb> strange, in the type definition, [w] means list of w's, and in the pattern [w] means list with a single element.
17:40:43 <hatds> Twey: in the same let block too?
17:40:46 <Twey> marcusb: It's a bit inconsistent, I guess
17:40:47 <byorgey> marcusb: true, it's a slight abuse of notation.
17:40:49 <Twey> hatds: Yes
17:40:57 <Berengal> marcusb: It's because [] has two different (but similar) meanings
17:40:59 <byorgey> you'll get used to it pretty quickly I think.
17:40:59 <hatds> hmm, didn't know that :)
17:41:02 <Twey> > let a = 5; a = 6 in a
17:41:03 <lambdabot>       Conflicting definitions for `a'
17:41:04 <lambdabot>      In the binding group for: a, a
17:41:07 <Twey> Oh, I'm wrong
17:41:19 <sjanssen> Berengal: it does?  I only see one pattern
17:41:22 <tiglionabbit> > groupBy (>) [1,2,3,2,1,2,3,4,3]
17:41:23 <hatds> ah ok :)
17:41:24 <lambdabot>   [[1],[2],[3,2,1,2],[3],[4,3]]
17:41:30 <EvilTerran> > [] :: [] Int -- another double meaning
17:41:31 <lambdabot>   []
17:41:35 <Berengal> sjanssen: Exactly. It's a bug
17:41:53 <tiglionabbit> this just seems so weird to me.  It's remembering that 3 from way back there, so it groups the 2 after the 1 in that long middle list
17:42:01 <Berengal> sjanssen: Try it out. I at least get warnings...
17:42:08 <sjanssen> Berengal: yeah, GHC has a few of them in the pattern checker, none of them seem difficult to fix
17:42:16 <sjanssen> n+k patterns have trouble as well
17:42:38 <hatds> accepted for removal right?
17:42:48 <hatds> *n+k pats
17:43:42 <Twey> Yeah
17:43:44 <Twey> :(
17:44:00 <Berengal> sjanssen: It seems a little hard to check view patterns though. The compiler needs to know if the view function is total
17:44:43 <Berengal> sjanssen: I mean, it's probably not too hard to remove the warning about overlapping patterns, but it's hard to make sure patterns are total
17:44:51 <sjanssen> Berengal: they're not any more difficult than guards
17:45:09 <sjanssen> IMO, it'd be okay if they just punted on totality
17:45:51 <Berengal> Yeah, me too I guess
17:46:51 <bd_> @hoogle [a] -> a -> Int
17:46:51 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
17:46:51 <lambdabot> Data.List elemIndices :: Eq a => a -> [a] -> [Int]
17:46:51 <lambdabot> Prelude (!!) :: [a] -> Int -> a
17:46:53 <Berengal> I'd be okay knowing my patterns might be partial. It's more useful to know if they're conflicting or overlapping
17:47:17 <EvilTerran> i'd tend to write view patterns after the non-view patterns, anyway
17:47:29 <EvilTerran> (in a series of options)
17:47:34 <hatds> an equation line in a function definition for f :: a -> b can be thought of as a value of type a -> Maybe b, and multiple equations are just `mplus`ed together
17:48:14 <hatds> thinking this way you can implement even more ambitious things than view patterns using the maybe monad if you like
17:48:18 <hatds> like IO a -> Maybe b
17:48:57 <hatds> (random thoughts from last week)
17:53:34 <simpletext> i saw something in 'haskell in 5 steps' and i dont know what it means entirely
17:54:26 <simpletext> ack 0 n = n+1
17:55:08 <hatds> that it?
17:55:15 <hatds> defines a function 'ack'
17:55:19 <Berengal> simpletext: What exactly confuses you?
17:55:29 <simpletext> the text explained you cand efine a function, it explained regex parameter m,atching, then it has this with two arguments?
17:55:35 <monochrom> You can write a literal number as part of a pattern. Just like "swap [] = whatever".
17:55:38 <monadic_kid> simpletext: the first argument pattern matches against the value of zero, this definition will be called to match the value of 0
17:55:51 <monochrom> Yes they are two arguments.
17:56:15 <monadic_kid> simpletext: i mean will be called when the value is 0
17:56:45 <simpletext> ok i didnt know if it meant 'when the value is zero' or 'when the value is zero followed by something'
17:57:06 <Berengal> Functions always take the same number of parameters
17:57:24 <monadic_kid> simpletext: the second argument is a "match all values and bind to n"
17:57:39 <marcusb> all operators are infix?
17:58:01 <monochrom> Yes.
17:58:03 <Berengal> marcusb: yes. (But there's an extension to allow postfix operators)
17:58:10 <marcusb> ok
17:58:11 <simpletext> match all value includes no value ?
17:58:15 <physique> what about prefix?
17:58:21 <hatds> and you can always write is as (+) to use an operator as prefix
17:58:29 <hatds> > (+) 1 1
17:58:30 <lambdabot>   2
17:58:32 <marcusb> hatds: ah ok.
17:58:34 <monochrom> alphabetic function names are prefix
17:58:36 <dolio> Postfix operators aren't all that great.
17:58:45 <marcusb> so () makes it an alphabetic name
17:58:52 <physique> thats blasphemous
17:59:02 <hatds> yea
17:59:03 <dolio> It's just that per H98 (I believe), all operators are typed as having two arguments.
17:59:06 <Berengal> simpletext: no, you have to give it some value
17:59:09 <ksf> > 4 `div` 2
17:59:11 <lambdabot>   2
17:59:21 <hatds> marcusb: and backquotes do the reverse to alphabetic functions
17:59:32 <dolio> So postfix operators lets (n!) have type Integer instead of being a function.
17:59:35 <simpletext> so ack 0  isnt legal?
17:59:47 <monadic_kid> simpletext: if you only apply one argument you will get a function back that takes one arg, it's valid
17:59:52 <Berengal> dolio: Can't you define operators like (a + b) c = a * b - c ?
18:00:04 <mauke> shoryuken
18:00:05 <marcusb> hatds: that seems mostly useful for obfuscated haskell though :)
18:00:17 <marcusb> > (div) 4 2
18:00:18 <lambdabot>   2
18:00:19 <dolio> Yes. I "at least two arguments" would probably be more correct.
18:00:20 <Berengal> simpletext: It's legal, but it'll return a function wanting the last value :)
18:00:26 <monochrom> How is 4 `div` 2 obfuscated?
18:00:30 <hatds> > 10 `elem` [2,4, ..]
18:00:31 <Twey> hatds: No
18:00:31 <lambdabot>   <no location info>: parse error on input `..'
18:00:36 <marcusb> monochrom: ok, got me
18:00:40 <hatds> > 10 `elem` [2,4 ..]
18:00:41 <lambdabot>   True
18:00:44 <Twey> hatds: It's commonly used for functions like div, quot, elem, &c.
18:00:44 <simpletext> ack 0 returns the function n = n + 1?
18:00:53 <marcusb> ah, cute
18:00:55 <mauke> simpletext: yes
18:00:55 <monadic_kid> simpletext: yep
18:00:59 <marcusb> true, I take it back
18:00:59 <Twey> Er, marcusb**
18:01:00 <mauke> except it's \n -> n + 1
18:01:06 <simpletext> does ack 0 1 return 2?
18:01:17 <monadic_kid> simpletext: indeed
18:01:21 <marcusb> there's plenty of reasons to have more (alphabetical) infix functions than just operators
18:01:21 <Twey> :t ack
18:01:22 <lambdabot> Not in scope: `ack'
18:01:24 <mauke> > let ack 0 1 = n+1 in ack 0 1
18:01:25 <lambdabot>   n + 1
18:01:26 <Twey> What is ack?
18:01:27 <Berengal> > let ack 0 n = n + 1 in ack 0 1
18:01:29 <lambdabot>   2
18:01:40 <marcusb> you convinced me
18:02:11 <marcusb> > div 4
18:02:11 <dolio> Berengal: Without the extension, (n!) gets seen as a section that requires an extra argument, regardless of what the actual type of (!) is.
18:02:12 <simpletext> i dont know what it means twey its just an example froma  webpage
18:02:12 <lambdabot>       Overlapping instances for Show (t -> t)
18:02:12 <lambdabot>        arising from a use of `s...
18:02:28 <hatds> :t div 4
18:02:29 <lambdabot> forall t. (Integral t) => t -> t
18:02:34 <hatds> :t div
18:02:35 <lambdabot> forall a. (Integral a) => a -> a -> a
18:02:42 <marcusb> hatds: thanks
18:02:48 <Twey> Oh, is that the Ackermann function?
18:02:57 <mauke> :t const '!'
18:02:58 <dolio> So if you write (!) n = product [1..n], then (5!) :: (Num (t -> t1), Enum (t -> t1)) => t -> t1.
18:02:59 <lambdabot> forall b. b -> Char
18:03:03 <monadic_kid> Twey: i'm guessing ackermann
18:03:04 <Berengal> dolio: Oh well, I've never seen the need for postfix operators anyway. I'm mostly a prefix person ...
18:03:15 <Twey> Ah, OK
18:03:18 <Twey> Yeah
18:03:55 <dolio> Berengal: I don't use them either. Having to have parentheses around them makes them a bit less appealing.
18:04:29 <Berengal> dolio: Yes, it sort of defeats the point
18:04:31 <dolio> Also, if you write "(!) :: Integer -> Integer ; (!) n = product [1..n]", then (5!) is a type error without the extension.
18:04:44 <hatds> postfix operators...well, um they make for interesting questions in GDC programmer challenges?   http://www.gamasutra.com/php-bin/news_index.php?story=13371
18:04:49 <Twey> ack 0 n = n + 1; ack m 0 = ack (m - 1) 1; ack m n = ack (m - 1) $ ack m (n - 1)
18:05:23 <Twey> It's not invalid, it's just defined as such
18:05:34 <Berengal> What would be nice would be to be able to apply functions to arguments in a different order than specified
18:05:42 <Twey> Yeah
18:05:47 <Twey> Explicit free arguments
18:05:49 <mauke> see oleg
18:05:58 <Berengal> something like "let foo a b c = b a c in (foo _ (+) 0)"
18:05:59 <Twey> Someone suggested that for Haskell'
18:06:15 <mauke> http://okmij.org/ftp/Haskell/types.html#keyword-args
18:06:28 <Twey> That's not it
18:06:57 <sjanssen> I don't particularly like the idea
18:07:21 <tiglionabbit> Why is this definition invalid?  firstWord [] = ""; firstword = head . words;  Both patterns generate a function with the same prototype, but it complains that there is a different number of arguments stated
18:07:39 <sjanssen> so (foo x _ z) is pretty reasonable, what about ((foo x) _ z)?
18:07:48 <Twey> Here:
18:07:50 <Twey> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexiblePartialApplication
18:07:58 <sjanssen> tiglionabbit: functions must have the same number of arguments
18:08:14 <tiglionabbit> sjanssen: but it does.  The other argument is implicit though
18:08:17 <HeavensRevenge> io
18:08:17 <tiglionabbit> er, the argument
18:08:20 <sjanssen> tiglionabbit: change the latter to firstword xs = head . words $ xs
18:08:25 <Draconx> tiglionabbit, right, you can't do that.
18:08:27 <HeavensRevenge> oops... wrong chan :)
18:08:37 <Twey> Heh
18:08:38 <Draconx> tiglionabbit, every equation must have the same number of patterns.
18:09:13 <tiglionabbit> I'm just curious why this is.  It seems superficial
18:09:20 <Berengal> sjanssen: There's probably a straightforward translation to flip* (.)* for such applications
18:09:26 <Berengal> sjanssen: At the very least a simple lambda
18:09:26 <tiglionabbit> like nothing would break if it wasn't a requirement
18:10:26 <sjanssen> tiglionabbit: the translation becomes somewhat more complicated
18:11:41 <Berengal> ((foo x) _ z) = (\y -> (foo x) y z)
18:13:04 <Berengal> or more general, (foo _1 _2 x y _3 z) -> (\_1 _2 _3 -> foo _1 _2 x y _3 z)
18:13:55 <marcusb> there is a bit of handwaving in the talk when it comes to discussion of efficiency :)
18:14:18 <Twey> Why's that?
18:14:21 <Berengal> @faq Can Haskell make fast code?
18:14:22 <lambdabot> The answer is: Yes! Haskell can do that.
18:14:28 <marcusb> i know, i know
18:14:33 <Berengal> :P
18:14:47 <marcusb> but you need some advanced techniques, I suppose
18:14:54 <Twey> Not really
18:15:12 <Twey> In most cases just writing idiomatic Haskell code will do you fine
18:15:19 <Berengal> You need to understand the evaluation model, but that's true for all languages
18:15:26 <marcusb> Twey: in that case the advanced techniques are in the compiler
18:15:27 <Twey> It's not much slower than C++ вЂ” a bit faster in some cases
18:15:32 <Twey> Pretty much, yes
18:15:53 <Twey> If you need MEGASPEED you might need to do some deep magic, of course
18:16:11 <Berengal> Twey: That's also true for all languages
18:16:15 <Twey> Aye
18:16:24 <Twey> But yeah, idiomatic code and bytestrings will see you through almost anything
18:16:34 <marcusb> the example in the talk is list append.  I understand how my implementation of lists performs almost down to the cycle, I think it would need me a while to figure out how it performs when compiled with hgc.
18:17:06 <marcusb> but well, megaspeed in C also requires deep magic (understanding of caches)
18:17:10 <Twey> In terms of big-O, everything pretty much behaves as you'd expect
18:17:20 <marcusb> Twey: that's nice to know
18:17:33 <Twey> Except for specific-case optimisations
18:17:35 <Berengal> Lazy evaluation has the effect of bringing down big-O in some cases, actually
18:17:41 <Twey> Yeah
18:17:45 <Berengal> Often more cases than you'd expect
18:17:54 <marcusb> I am totally paranoid about switching from C.  I can not imagine to ever learn another tool chain as well as I know gcc - libc - kernel
18:18:08 <Twey> E.G. Supero will actually remove intermediate structures altogether
18:18:12 <hatds> honestly, you will be using lists to control data flow, not as arrays to store global state
18:18:16 <mauke> fortunately it's easy to write C in Haskell :-)
18:18:18 <sjanssen> marcusb: what sort of applications do you write?
18:18:37 <mauke> you can call C functions, use raw pointers, call malloc/free, etc.
18:19:01 <Berengal> I've found the haskell toolchain to be much better than the c one
18:19:20 <Berengal> It includes an interpreter, which beats much anything else a toolchain could contain
18:19:25 <marcusb> sjanssen: well, professionally, I work on gpg related software (from gpgme to gpa).  my history is with the hurd (os and microkernel).  currently I am looking at a dissassembler that's written in haskell for a bytecode language.
18:19:27 <Berengal> Also, cabal/hackage
18:20:27 <marcusb> sjanssen: I know that seL4 (a microkernel) is modelled in haskell, for validation purposes, and its a cool project (well worth to check out for haskell fans I guess, even if you are not into microkernels)
18:20:50 <hatds> it's often said Haskell is the world's finest imperative language (or something to that effect)
18:20:55 <marcusb> Berengal: that's worth a lot
18:21:39 <Twey> Berengal: Well, Ch exists too
18:22:50 <Berengal> marcusb: You should note I'm a bit of an evangelist though :P
18:22:54 <dolio> > let foldN s z 0 = z ; foldN s z n = s (foldN s z (n-1)) ; ack = foldN (\f -> foldN f (f 1)) (+1) in [ (m,n,ack m n) | m <- [0..3], n <- [0..4] ]
18:22:55 <lambdabot>   [(0,0,1),(0,1,2),(0,2,3),(0,3,4),(0,4,5),(1,0,2),(1,1,3),(1,2,4),(1,3,5),(1...
18:23:16 <marcusb> Berengal: i wouldn't be here if I don't think there is a lot of value into higher level languages, and haskell in particular ;)
18:23:31 <marcusb> Berengal: my paranoia is by definition not grounded in rationale arguments.
18:23:43 <Berengal> Hehe
18:24:35 <Berengal> marcusb: If you want to check some stats about speed, there's the language shootout. Haskell ranks pretty high
18:24:38 <Berengal> @where shootout
18:24:38 <lambdabot> http://shootout.alioth.debian.org/
18:24:41 <marcusb> I guess I just feel most comfortable in that area where I understand most
18:24:46 <Berengal> We all do
18:24:58 <marcusb> I am not really worried about speed, more about understanding wtf is going on
18:25:28 <marcusb> (everytime g++ throws an error at me I could smash the screen with a big heavy object)
18:25:34 <rawrsy> Hello all
18:25:51 <Berengal> marcusb: Understand types quickly, or you'll want to kill ghc as well :P
18:25:56 <marcusb> :)
18:26:36 <SubStack> type errors are what ghc does best
18:26:37 <rawrsy> was wondering if you could point me to the best possible place to begin learning Haskell/FP
18:26:50 <mauke> @where lyah
18:26:50 <lambdabot> www.learnyouahaskell.com
18:26:58 <marcusb> rawrsy: join the club
18:27:04 <SubStack> pretty pictures!
18:27:10 <rawrsy> marcusb: you should join mine instead :P
18:27:12 <Cale> rawrsy: Yeah, lyah is good, also, stick around here and ask questions :)
18:27:25 <marcusb> rawrsy: hey, I'm 48m in the video presentation :)
18:27:30 <rawrsy> Cale: Thanks for the offer :)
18:27:31 <dolio> LYAH has more pictures of whales than other Haskell tutorials.
18:27:39 <rawrsy> marcusb: mmk, I'll join yours I suppose
18:27:52 <marcusb> i've got a head start hehe
18:28:07 <Twey> SubStack: That's as may be, but it almost always works the first time after it compiles properly
18:28:10 <Berengal> We're good at answering questions
18:28:10 <rawrsy> I was recommended to read 'Purely Functional Data Structures' earlier today
18:28:15 <Twey> Which is a lot more than I can say for other languages :-P
18:28:21 <hatds> for me "A Taste of Haskell" was just the start of losing a month of my life to reading and understanding everything about it :)
18:28:30 <rawrsy> figured I'd better have a good base before jumping into that...
18:28:34 <Berengal> @where RWH
18:28:34 <lambdabot> is http://www.realworldhaskell.org/blog/
18:28:49 <Berengal> в†‘в†‘ also good
18:28:57 * Twey prefers RWH
18:29:06 <rawrsy> Twey: to lyah?
18:29:31 <marcusb> actually, you are excellent at answering questions, let me say a big thank you here already to all of you, you are incredibly helpful and welcoming
18:29:38 <SubStack> Twey: if only that were so ;)
18:29:46 <SubStack> but the trend is certainly in that direction anyways
18:30:00 <Berengal> RWH isn't entirely for newbiew though. It assumes you know the basics of programming, and might be somewhat quick on the trigger if you're completely green. It is, however, very good if you've got a basic understanding of what's going on
18:30:07 <Berengal> newbies*
18:30:49 <rawrsy> naw, I know c java perl
18:30:54 <SubStack> tutorials should have more koalas
18:31:01 <SubStack> as a rule
18:31:03 <rawrsy> fp interests me now though
18:31:10 <SubStack> also http://www.haskell.org/pipermail/haskell/2009-April/021173.html
18:31:36 <Twey> That's true
18:31:46 <Twey> Yeah, if you know other languages, go with RWH
18:32:02 <Twey> Aye, to LYAH
18:32:33 <rawrsy> lyah = free, rwh = $?
18:32:38 <Berengal> @quote Learning.is
18:32:39 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
18:32:42 <SubStack> both free as in freedom
18:32:58 <SubStack> for various definitions of freedom
18:33:20 <rawrsy> SubStack: hah, thanks :)
18:33:20 <Berengal> rwh :: Maybe $ -> Either (Digital Paper)
18:34:06 <Lemmih> Berengal: Kind error?
18:34:40 <marcusb> this may be the wrong question to ask: do all functions take exactly one argument?
18:34:46 <hatds> at some point I found just reading the haskell report was the quickest way to go from advanced newbie to confident programmer
18:34:52 <marcusb> (and evaluate possibly to functions taking an argument etc)
18:34:57 <hatds> no
18:34:58 <Berengal> Lemmih: What? How? *these are not the parenthesis you are looking for*
18:34:58 <Saizan> marcusb: essentially yes
18:35:09 <hatds> well "yes and no"
18:35:16 <marcusb> let me tell you why I ask
18:35:38 <marcusb> the definition of . is  "(f . g) x = f (g x)
18:35:44 <SubStack> hatds: I tried that when I was learning it, not so successful
18:35:45 <marcusb> and I was wondering if/why this covers all possible cases
18:35:51 <Berengal> marcusb: Yes, and function application is left-associative. "foo a b c d" = "(((foo a) b) c) d"
18:35:54 <Saizan> because of currying then every N argument function is really an 1-argument function that returns an (N-1)-argument one
18:36:03 <Berengal> @type (.)
18:36:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:36:18 <eyeris> I've just install GHC 6.10.2, then the Haskell Platform 2009.2.0. This is on Windows. I did this using an Administrator account. Now I am trying to install gtk2hs 0.10.0 and it says "Setup found what appears to be a non-working installation of GHC in the folder C:\Program Files\Haskell Platform\2009.2.0\ghc-6.10.2"
18:36:25 <hatds> subStack: maybe it's more of a way to cement everything you already seen in a gentler context, and less of a way to learn something new
18:36:35 <SubStack> it makes more sense now anyways
18:36:52 <hatds> remember "a variable matches anything at all"
18:36:59 <marcusb> :t f . g
18:37:00 <lambdabot>     Ambiguous type variable `b' in the constraints:
18:37:00 <lambdabot>       `SimpleReflect.FromExpr b'
18:37:00 <lambdabot>         arising from a use of `g' at <interactive>:1:4
18:37:04 <marcusb> mmmh
18:37:16 <Saizan> marcusb: yes, in the sense that you can e.g. have ((\f -> f 3) . (*)) 4
18:37:27 <SubStack> ghc even runs on windows? fascinating.
18:37:27 <eyeris> For all of your talk of building more reliable software, the Haskell community sure does produce horrible-to-use software
18:37:28 <Saizan> > ((\f -> f 3) . (*)) 4
18:37:29 <lambdabot>   12
18:37:32 <marcusb> sure
18:37:33 <Twey> marcusb: Depends on the types of f and g
18:37:41 <marcusb> but I can write "f = g . h", too
18:37:48 <marcusb> and what is the right hand side in that case?
18:38:04 <marcusb> it's not evaluated yet?
18:38:04 <Berengal> eyeris: The HP is still in beta. It was released yesterday for testing
18:38:14 <hatds> :t (.)
18:38:15 <marcusb> is this where laziness comes in?
18:38:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:38:31 <hatds> every function has the type b -> c if that is what you are getting at
18:38:42 <Saizan> marcusb: not really
18:39:00 <Berengal> eyeris: http://trac.haskell.org/haskell-platform/newticket and submit a bug-report if you think you've found a bug please
18:39:01 <Saizan> marcusb: it just defines f to be the composition of g and h, i.e. still a function
18:39:02 <Twey> If f :: b -> c, and g :: a -> b, then f . g :: a -> c
18:39:21 <Twey> (f . g) h = f (g h)
18:39:22 <eyeris> Berengal: All I can put in the report is "it does't work because gtk2hs 0.10 says it doesn't"
18:39:23 <marcusb> I find it hard to phrase my question
18:39:33 <Twey> That's the definition of ., and also the clearest explanation :-P
18:39:35 <hatds> :t (+)
18:39:36 <marcusb> when the compiler sees f . g on the right hand, what does it do with it?
18:39:36 <lambdabot> forall a. (Num a) => a -> a -> a
18:39:42 <hatds> :t (+) (1::Int)
18:39:43 <lambdabot> Int -> Int
18:39:45 <marcusb> just tucks it away for later?
18:39:45 <Saizan> marcusb: f = g . h is the same as f x = (g . h) x
18:39:48 <Berengal> eyeris: Have you tried with a normal ghc install?
18:39:55 <marcusb> Saizan: ah
18:39:56 <eyeris> It IS a normal GHC install
18:40:00 <eyeris> Read what I typed.
18:40:11 <marcusb> Saizan: that would answer my question :)
18:40:11 <Berengal> eyeris: You said you installed it from the Haskell Platform
18:40:12 <eyeris> I installed GHC, then the platform, which requires GHC.
18:40:16 <Berengal> Ah
18:40:29 <Berengal> did you try to install gtk2hs without installing the platform?
18:40:37 <Saizan> marcusb: well, operationally it might be different
18:40:43 <eyeris> That's my point Berengal
18:40:54 <eyeris> I shouldn't have to.
18:41:10 <Twey> marcusb: You can literally take (f . g) h and replace it with f (g h), for any f, g, and h, and get the same semantics
18:41:15 <eyeris> and, yes, I have tried that. I've tried it multiple times over the last year.;
18:41:43 <marcusb> Twey: right, I think I am trying to figure out how this is actually implemented, maybe I should just wait until I understand more
18:41:45 <Berengal> eyeris: I'm just trying to figure out where the bug might be
18:41:56 <Twey> marcusb: It's implemented as you see it
18:42:05 <Twey> (f . g) h = f (g h)
18:42:12 <Berengal> eyeris: This never worked you say?
18:42:13 <Twey> That's the actual implementation, at least in GHC
18:42:20 <Saizan> i think he means at the lower level
18:42:25 <eyeris> Berengal Have fun. I don't have time to track down bugs in a language I barely understand.
18:42:30 <Saizan> e.g. with pointers and closures
18:42:34 <marcusb> yeah ,lower level and for "f . g" where no x is following (yet)
18:42:45 <hatds> getting at the lower level than that isn't something you should worry about when you are just starting off
18:42:47 <marcusb> as there is no equation that matches "f . g" without an x following
18:42:54 <eyeris> I want to learn Haskell, yet I can't get past example programs because writing any real software is impossible due to library incompatibilities, etc.
18:42:56 <marcusb> hatds: I agree
18:43:22 <Twey> marcusb: There doesn't have to be вЂ” computation is simply postponed until it's available
18:43:27 <eyeris> The Haskell ecosystem, from a newcomer's POV, is horribly uninviting.
18:43:34 <Berengal> eyeris: Most people have had no problems with this
18:43:46 <marcusb> Twey: ok, thanks
18:43:48 <Twey> eyeris: You haven't tried CL lately, have you :-P
18:43:53 <eyeris> Then perhaps they can speak up and tell me what I did wrong.
18:43:58 <hatds> marcusb: but when you do want to follow the rabbit hole all the way down, SPJ's book "implementation of functional programming languages" is good if you've never seen how functional programs are implemented
18:44:07 <eyeris> Twey: They also suck. That's no excuse.
18:44:10 <Twey> (in fact it's postponed longer than that вЂ” as with most expressions, computation is postponed until the value is needed)
18:44:15 <Saizan> eyeris: i think the gtk2hs installer is for ghc-6.10.1 but the haskell platform comes with 6.10.2
18:44:28 <eyeris> Saizan Yeah, exactly.
18:44:32 <Twey> I found Haskell pretty friendly and easy to get into, personally
18:44:41 <Twey> CL scared the life out of me
18:44:57 <hatds> what is CL?
18:44:58 <Saizan> eyeris: so, tried with 6.10.1?
18:45:03 <Twey> You're expected to install packages from the REPL and stuff... it's terrifying
18:45:16 <Twey> hatds: Common Lisp
18:45:17 <eyeris> Saizan 6.10.1 doesn't work with other libraries I need.
18:45:26 <roconnor> @hoogle md5
18:45:26 <lambdabot> package nano-md5
18:45:27 <lambdabot> package pureMD5
18:45:33 <Berengal> Twey: I found CL easy to get into. At least sbcl+slime
18:45:35 <marcusb> hatds: I've seen one implementation in a very old (80s, I guess) book on compiler construction, which had a chapter on prolog I think
18:45:46 <Twey> Berengal: I take it you didn't get to ASDF, then?  :-P
18:45:54 <Saizan> eyeris: then i guess you might try to compile gtk2hs from source, maybe with some help from its mailing list
18:46:02 <marcusb> hatds: but yes, this is definitely stuff for later
18:46:07 <Berengal> Twey: Not as such, no, and now I don't want to... Thanks very much;)
18:46:20 * Twey laughs.
18:46:33 <kiba> hello
18:46:53 <kiba> Prelude> boomBangs xs = [ if x < 10 then "BOOM!" else "BANG!" | x <- xs, odd x]
18:46:53 <eyeris> Saizan Again, that's my point.
18:46:53 <kiba> <interactive>:1:13: parse error on input `='
18:46:54 <Twey> The scariness for me arose from the practice of treating the REPL as an operating system
18:47:01 <kiba> why is it getting me this error?
18:47:03 <eyeris> Saizan the ecosystem is horrible unreliable.
18:47:04 <hatds> marcusb: the implementation stuff can be deferred indefinitely really, the execution model of "evaluating expressions" is what's important.  I think SPJ does one example like that in the video
18:47:08 <kiba> I faithfully replicate the tutorial!
18:47:20 <Twey> You can almost believe that CL folks work their computers by using the REPL as a shell
18:47:34 <Saizan> eyeris: i'm not arguing on that point, i'm just pointing out a viable path :)
18:47:36 <eyeris> Saizan 6.10.2 should contain just bugfixes over 6.10.1, so why can't gtk2hs work with 6.10.x?
18:47:36 <Twey> kiba: You need a вЂletвЂ™ in front if you're defining stuff in GHCi
18:47:47 <Twey> kiba: The tutorial code was designed to be saved to a file and then loaded
18:47:48 <Berengal> eyeris: I don't remember for certain, but I believe there were some issues with 6.10.2 and gtk2hs which prevented it from working properly on windows. it should be fixed come 6.10.3. Don't quote me on it however
18:47:53 <Twey> (or compiled, perhaps)
18:48:00 <kiba> oh
18:48:00 <Saizan> eyeris: all ghc versions are binary incompatible with each other
18:48:12 <Saizan> eyeris: so it's a matter of rebuilding the lib
18:48:31 <eyeris> Seriously?
18:48:46 <eyeris> Libraries compiled with 6.10.1 can't be consumed by 6.10.2?
18:48:53 <Saizan> exactly
18:48:55 <eyeris> Sad
18:50:06 <eyeris> So a bugfix compiler upgrade causes me to cabal upgrade, which itself warns me is likely to break my libraries.
18:50:07 <Saizan> ghc sticks the version number in the .hi files and won't accept any that are from a different version
18:50:26 <kiba> oh dear
18:50:29 <Saizan> you don't really cabal upgrade there
18:50:34 <kiba> I am starting to run into trouble
18:50:37 <Saizan> you reinstall from scratch
18:50:47 <kiba> never mind
18:50:51 <eyeris> Saizan to get a BUGFIX? my god!
18:50:58 <eyeris> Are there plans to change this?
18:51:29 <kiba> [x | x <= [10..20], x /= 13, x /= 15, x /= 19]
18:51:31 <kiba> whoops
18:51:43 <roconnor> how do we sortBy length again?
18:51:56 <Saizan> maybe, related on the support for shared objects
18:51:57 <roconnor> or right comparing
18:51:57 <Berengal> roconnor: sortBy (comparing length)
18:52:14 <Berengal> roconnor: You might also want to take a look at the 'on' function
18:52:15 <Berengal> @type on
18:52:16 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:52:36 <Berengal> @type comparing
18:52:36 <kiba> hmm
18:52:37 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
18:52:41 <kiba> Haskell is cool
18:52:43 <Berengal> @type (compare `on`)
18:52:45 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
18:52:56 <kiba> I don't understand the benefit now though
18:53:08 <hatds> kiba: of?
18:53:11 <kiba> Haskell
18:53:37 <hatds> :) well we are all going to be biased here
18:53:55 <kiba> I am going to write a game in Haskell as an exercise to get a feel
18:53:57 <Berengal> kiba: I wrote a sexp to xml converter in 30 lines. to me being able to do that is a benefit
18:54:04 <kiba> it is a very interesting programming language
18:54:05 <roconnor> @type maximizeBy (comparing length)
18:54:06 <lambdabot> Not in scope: `maximizeBy'
18:54:16 <roconnor> @type maximumBy (comparing length)
18:54:17 <lambdabot> forall a. [[a]] -> [a]
18:54:17 <hatds> pure expressions seem to the real good thing, very easy to reason about
18:54:44 <Berengal> hatds: Also the ability to make abstractions
18:54:52 <hatds> oh yes, right
18:55:00 <roconnor> @hoogle intersect
18:55:00 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
18:55:00 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
18:55:00 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
18:55:05 <hatds> that's what struck me first about Haskell actually
18:55:08 <Berengal> Note how we can do without if expressions and exceptions if we wanted :)
18:55:22 <saml> StateT String (StateT String Identity) a     how can I get inner State ?
18:55:26 <saml> lift get ?
18:56:12 <Berengal> saml: I believe so. Does it work?
18:56:18 <kiba> hatds: the very interesting part?
18:56:29 <saml> Berengal, i get type errors. let me write a testcase
18:57:17 <hatds> kiba: sorry what? :)
18:57:29 <kiba> never mind
18:57:49 <hatds> I was saying Haskell's ability to make abstractions is what I first really noticed
18:58:06 <byorgey_> saml: you should be able to make that work.  But it's probably easier to do  StateT (String,String) Identity a ...
18:59:05 <saml> hah just about to ask if it's better to do StateT (String,STring)
19:00:26 <hatds> kiba: there's been a few examples of games in Haskell.  I'm not sure if people think making the code completely "functional" is the best way to go.  Certainly just embracing IORefs and making sure the code stays otherwise beautiful will still give you really nice code
19:00:51 <Twey> The IORefs are rarely the way to go
19:01:18 <hatds> like I said :)
19:01:20 <Twey> Often a better abstraction is in order, like Reactive
19:02:01 <Berengal> I haven't found a good tutorial for Reactive yet...
19:02:07 <Berengal> I probably just don't know where to look
19:02:08 <hatds> I was just going to say that I would rather use IORefs at the moment instead of FRP since I haven't been convinced of the latter
19:05:00 <Zao> Elerea seems kind of nice at first glance.
19:05:25 <Zao> I can't say I grok the differences between the different FRP packages yet and which ones still work/are maintained.
19:05:34 <saml> i do cons to a list l. the result is l'. how can I get what i cons-ed? should I keep track of number of elements i cons and use take?
19:06:10 <Pseudonym> FRP library is the new monad tutorial.
19:07:06 <Berengal> saml: You mean how you can get the first element back?
19:07:35 <saml> Berengal, yes. first elements that i cons-ed. i'm not keeping how many elements i cons-ed now.
19:07:53 <saml> > "hello" \\ "llo"  -- works
19:07:54 <lambdabot>   "he"
19:07:58 <Berengal> saml: Use pattern matching, like "let (first:rest) = l' in..."
19:08:37 <Berengal> Pseudonym: Speaking of pattern matching, a friend who just started on haskell said to me: "Do you have a link somewhere that has a coherent explanation of monads? I tried to read about it, but it was like the author had a stroke mid-article, and started rambling about nuclear waste and whatnot and then there was some sort of strange formal mathematics and words that didn't seem to form any real sentences.."
19:08:42 <saml> > "hello" \\ "lloe" -- well i guess it doesn't matter because i'm sure i'm only cons-sing. this won't happen
19:08:43 <lambdabot>   "h"
19:09:08 <Berengal> > head "hello"
19:09:09 <lambdabot>   'h'
19:09:12 <Berengal> > tail "hello"
19:09:13 <Pseudonym> Obviously didn't get to the section on burritos.
19:09:13 <lambdabot>   "ello"
19:09:27 <adamvo> > "olleh" \\ "hello"
19:09:28 <lambdabot>   ""
19:09:34 <Berengal> Wow, did I really say pattern matching?
19:09:42 <Berengal> I must be getting tired. Meant monad tutorials..
19:09:55 <Pseudonym> Yes, but I glorked the flutzpah from the context.
19:10:06 <Berengal> So it would seem
19:10:49 <adamvo> defining monads seems to require pattern matching
19:11:41 <purplefistmixer> someone linked me to this tutorial earlier: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
19:11:44 <purplefistmixer> re: monads
19:11:55 <Berengal> What makes monads hard is that monads are easy: There's so little of them to understand that people get confused
19:12:21 <Pseudonym> Kinda.
19:12:25 <Berengal> If you know the monad laws you know what a monad is. You might not _grok_ it, but you _know_ it
19:12:32 <Pseudonym> They're a very small amount of information, but with no really good intuition.
19:12:44 <Pseudonym> The problem is that it's abstract information.
19:12:52 <hatds> sigfpe as always is golden :)
19:13:34 <Berengal> Pseudonym: Indeed. It took me a while before I groked them at least. Funnily enough, it happend just a few days after I had given up on trying to understand them
19:14:00 <rawrsy> I just looked up grok, must be a Haskell thing huh?
19:14:01 <hatds> maybe you lowered your expectations that there was something deeper to them ? :)
19:14:11 <adamvo> @hoogle grok
19:14:11 <Berengal> rawrsy: No, it's a hacker thingy
19:14:12 <lambdabot> No results found
19:14:15 <hatds> I thought 'grok' was programmeresque
19:14:21 <rawrsy> man, never heard it before =/
19:14:30 <Pseudonym> @jargon grok
19:14:33 <lambdabot> *** "grok" jargon "Jargon File (4.3.1, 29 Jun 2001)"
19:14:34 <lambdabot> grok /grok/, var. /grok/ vt. [common; from the novel "Stranger in a
19:14:34 <lambdabot>    Strange Land", by Robert A. Heinlein, where it is a Martian word meaning
19:14:34 <lambdabot>    literally `to drink' and metaphorically `to be one with'] The emphatic
19:14:34 <lambdabot>    form is `grok in fullness'. 1. To understand. Connotes intimate and
19:14:35 <rawrsy> you guys are teaching me all kindsa stuff :P
19:14:35 <lambdabot> [12 @more lines]
19:14:58 <Berengal> hatds: I had a Keanu-moment with functors, and monads sort of came at the same time (but not as profound at first)
19:15:04 <Pseudonym> If you don't want to learn anything, this is definitely the wrong place.
19:15:09 <hatds> heh, I bet the word 'grok' is disproportionally appearing before the word 'Haskell' a lot lately
19:15:37 <rawrsy> Pseudonym: definately not the case
19:16:16 <adamvo> @check \x -> x == not (not x)
19:16:18 <lambdabot>   "OK, passed 500 tests."
19:16:29 <hatds> Berengal: I had this weird moment with type constructors = functors, polymorphic functions = natural transformations.  It suddenly made me really appreciate knowing category theory
19:16:40 * edwardk2 waves hello.
19:17:29 <sjanssen> @djinn Not (Not x) -> x
19:17:29 <lambdabot> -- f cannot be realized.
19:17:45 <hatds> @djinn [a] -> [a]
19:17:45 <lambdabot> Error: Undefined type []
19:17:55 <Berengal> edwardk: I swear you must 'grep Category*Theory | sed -re 's/./\a/' | cat'
19:17:55 <hatds> how does this work?
19:18:03 <Berengal> On the channel logs
19:18:12 <saml> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4674#a4674  I'm not sure why type checker can't match String and [a]
19:18:39 <Berengal> hatds: djinn doesn't know about lists
19:18:41 <sjanssen> saml: error message please
19:19:18 <hatds> @djinn a->(a->b)->b
19:19:18 <lambdabot> f a b = b a
19:19:24 <Saizan> saml: the problem is that restore :: m [a] is promising to be able to return a list of _any_ 'a' that the caller wants, not just a particular type of its own choice
19:19:25 <hatds> neat
19:19:30 <saml>  Couldn't match expected type `a' against inferred type `Char' `a' is a rigid type variable bound by   Expected type: ([a], NumberOfPushed)  Inferred type: (String, NumberOfPushed)
19:19:35 <sjanssen> saml: so your class definition says that restore is defined for lists of *every* type, your instance is only defined for lists of Char
19:20:36 <saml> so i should replace a with Char? that's a bit restricting
19:20:41 <Saizan> it looks like you want a multiparameter typeclass there
19:21:11 <Saizan> class Monad m => MonadFoo a m where .. restore :: m [a] ...
19:21:32 <Saizan> so you can write instance Monad m => MonadFoo Char (FooT m) where
19:21:51 <saml> ah thanks. i should read up on multiparameter typeclass
19:22:06 <edwardk> berengal: hah
19:22:15 <edwardk> Berengal: nah, i just never leave =)
19:22:21 <hatds> how do people feel on functional dependencies vs type families?
19:22:53 <edwardk> and its #haskell, usually _someone_ is talking about category theory.. or you can just appeal to the curry-howard-lambek correspondence and turn anything they are talking about INTO category theory ;)
19:23:02 <hatds> lol
19:24:09 <dolio> Type families are good.
19:24:25 <edwardk> hatds: That they are complementary tools and both worth having in my toolbox
19:24:33 <dolio> Functional dependency notation is better sometimes, so it should be implemented on top of type families. :)
19:24:49 <Berengal> edwardk: "Why do I get this segfault?" "The Catamorphism on this Functor yields a nice Foldeable instance" "How relevant and informative! My code is surely to work now!"
19:25:03 <Saizan> with OverlappingInstances i'm not convinced type families subsume fundeps
19:25:23 <Berengal> Must be getting late. Typos about!
19:25:26 <edwardk> yeah, but i like to pretend that overlapping instances don't exist ;)
19:25:41 <hatds> maybe it would be more informative if you could translate segfaults into category theory
19:25:57 <Saizan> they are what make typeclass hackery fun though!
19:26:02 <edwardk> hatds: "Does not commute" =)
19:26:43 <edwardk> hrmm
19:26:49 <edwardk> has anyone seen this before? http://www.ling.gu.se/~peb/software/functional-parsing/
19:27:07 <edwardk> i tripped over this library of parsers when i was looking into stuff for parsimony
19:28:58 <ik> JESUS CHRIST IT'S A LOLI GET IN THE CAR
19:29:00 <marcusb> what significance does whitespace have in haskell source code?  is this correct: indentation is ignored, newlines are relevant
19:29:08 <ManateeLazyCat> Have any tool or tip that can generate "build-depends" information for .cabal file?
19:29:22 <Zao> marcusb: Indentation levels matter.
19:29:23 <marcusb> can I separate two statements(?) on the same line?
19:29:32 <Zao> do { foo ; bar ; baz }
19:29:48 <marcusb> ok
19:29:57 <marcusb> and indentation is for modules ... where ?
19:30:10 <adamvo> @where report
19:30:11 <lambdabot> http://www.haskell.org/onlinereport/
19:30:40 <adamvo> marcusb: indentation for the keywords  where, do, of
19:31:13 <adamvo> otherwise it doesn't matter
19:31:19 <marcusb> ok, thx
19:31:27 <Berengal> and let
19:31:39 <adamvo> yep
19:32:47 <Saizan> ManateeLazyCat: i've one in an alpha stage, darcs get http://code.haskell.org/~Saizan/hbuild
19:32:57 <Berengal> edwardk: I have a question regarding sets and functors
19:33:01 <ManateeLazyCat> Saizan: Thanks
19:33:25 <roconnor> what is the purpose of the haskell platform?
19:33:26 <Saizan> ManateeLazyCat: it's used like hbuild --infer -i sourcedir First.Module Second.Module ...
19:33:31 <Berengal> edwardk: I've read that sets are functors (just not in haskell), but how does this hold for e.g. fmap (const 5) ?
19:33:53 <Saizan> ManateeLazyCat: listing all the exposed modules in your library
19:35:12 <ManateeLazyCat> Saizan: It list module that i actually use in code, or `import` in code?
19:35:37 <Saizan> ManateeLazyCat: you need to list the modules you're defining
19:36:06 <roconnor> Oh I see, ``The platform prevents from picking and choosing the best Haskell libraries and tools to use for a task''
19:36:15 <roconnor> ``The platform prevents you from picking and choosing the best Haskell libraries and tools to use for a task''
19:36:19 <roconnor> :)
19:36:23 <Saizan> ManateeLazyCat: suppose your library defines the module Lib.A Lib.B and Lib.C, and you export Lib.A and Lib.B then you should call hbuild with Lib.A Lib.B
19:36:33 <adamvo> Berengal: presumably you end up with the singleton set of 5, afaict that follows the functor laws
19:37:22 <Saizan> roconnor: does it really say prevents?
19:37:48 <ManateeLazyCat> Saizan: Thanks, i try.
19:37:52 <edwardk> Berengal: Set can't be represented directly in Haskell as a 'Functor' merely as a 'functor' -- its not an implementation of the Haskell concept because you need a notion of equality to get something out of the set.
19:37:58 <edwardk> Berengal: there are ways to work around this
19:38:08 <roconnor> Saizan: I took some liberties
19:38:45 <edwardk> Berengal: you could define newtype Set a = Set [a] -- and not expose anyway to get the value _out_ of the Set except by a 'toList :: Ord a => Set a -> [a]
19:38:54 <edwardk> then you can deal nicely with a 'Set' of functions, etc.
19:39:02 <dolio> Is there an overlapping instances example that works with fundeps and not with type families?
19:39:17 <edwardk> but you can only extract once you've placed an honest to goodness order on things
19:41:25 <edwardk> Berengal: so that version can be made into a Functor, at least up to the correctness of your implementation of Ord, by requiring that Ord instance really be structural
19:42:10 <byorgey_> edwardk: but that version might be quite inefficient if you generated a bunch of things that were equivalent and didn't collapse them all until the end.
19:42:22 <edwardk> byorgey_: i didn't say it was efficient =)
19:43:29 <byorgey_> =)
19:43:30 <Berengal> Hmmm
19:43:43 <edwardk> byorgey_: you might be able to go a step farther and define a merge operation using makeStableName but the very idea makes me throw up in my mouth a little
19:43:52 <byorgey_> ewwwwwwwwwwwwwww
19:43:57 <edwardk> byorgey_: it'd at least enforce the 'structural equality' aspect =)
19:44:05 <byorgey_> (referring to both the idea and the image)
19:45:15 <edwardk> its the only notion of equality on functions that you've got ;)
19:45:35 <byorgey_> Berengal: as an example, in math-land  fmap (`div` 2) {1,2,3,4,5}  would be  {0,1,2}
19:45:35 <edwardk> at least that you can enforce
19:45:53 <Twey> @index makeStableName
19:45:54 <lambdabot> System.Mem.StableName
19:45:59 <Twey> Oh
19:46:02 <Twey> Ew
19:46:41 <edwardk> i'm abusing that nowadays. i'm not proud ;)
19:46:47 <dolio> I guess I figured one out without too much trouble.
19:46:47 <Twey> How?
19:46:51 <Berengal> I guess I don't really have a good idea about what the structure of a set looks like
19:46:51 <edwardk> its at least better than a StablePtr
19:46:53 <dolio> Not sure what I'd use it for.
19:47:03 <edwardk> twey: to recover sharing in an applicative grammar
19:47:20 <edwardk> twey: it lets me spot cycles in the grammar and share identical leaves
19:47:52 <Berengal> fmap is supposed to preserve structure, but it seems the size of a set isn't part of that structure, only that none of the elements are the same
19:48:32 <edwardk> Berengal: depends on how much you like Species ;)
19:48:40 <Twey> Berengal: data Set a = Set [a]; add x s@(Set xs) | elem x xs = s | otherwise = Set (x : xs); contains x (Set xs) = elem x xs
19:49:01 <Twey> s/lists/better-suited datatype/
19:49:21 <Twey> edwardk: Ah, I see
19:49:23 <hatds> is this related to trying to realize quotients in Haskell?
19:49:50 <edwardk> hatds: yeah the lack of quotient types is basically what its about
19:49:51 <Twey> Well, so long as it's for deep performance magic and the user doesn't have to know about it, I guess that's appropriate :-P
19:49:53 <Berengal> I thought about something like data Set a = Set (a -> a -> Equality) [a]
19:50:06 <Twey> Berengal: Nah
19:50:09 <Berengal> where Equality = Boolean
19:50:11 <Twey> That's what Eq is for
19:50:22 <Berengal> Yeah, but this is more general :)
19:50:23 <edwardk> twey: well, they have to know that the resulting grammar must be finite, but other than that nothing
19:50:27 <saml> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4674#a4675   my brain explodes
19:50:36 <Berengal> You could have a Set (comparing length)
19:50:37 <Twey> It is, but whether it's adviseable is debatable
19:50:54 <Berengal> Yeah, it was just a random thought
19:51:09 <saml> I have an instance, MonadFoo Char (FooT m) . and Foo derives MonadFoo Char
19:51:12 <hatds> you could do different equality functions with newtypes...
19:51:15 <edwardk> i.e. it unfortunately means there is a non trivial difference between many p = (:) <$> p <*> many p <|> pure [] -- and many p = ps where ps = (:) <$> p <*> ps <|> pure []
19:51:37 <blubo> hi all
19:52:01 <saml> hi blubo
19:52:15 <blubo> so you all here are programers?
19:52:32 <edwardk> blubo: nope
19:52:38 <edwardk> blubo
19:53:04 <edwardk> @quote Cale.*logic
19:53:04 <lambdabot> No quotes match. I feel much better now.
19:53:08 <edwardk> aww
19:53:20 <dolio> @quote intuitionistic
19:53:21 <lambdabot> No quotes match. Where did you learn to type?
19:53:34 <dolio> @quote trivial.theorems
19:53:34 <lambdabot> Cale says: But in another sense, functional programmers are applied logicians who spend all their time proving trivial theorems in interesting ways in an inconsistent intuitionist logic.
19:53:44 <blubo> can any one help me make database with registering users login logout etc?
19:54:25 <Twey> I think it's important to note that that definition kind of applies to all programmers
19:54:29 <edwardk> blubo: this channel is about programming in Haskell. If you are interested in learning how to program in Haskell in order to accomplish this task, it would be a reasonable long term objective. ;)
19:55:21 <Berengal> Twey: Perhaps, but most who know this are functional programmers
19:55:33 <Twey> Truly :)
19:55:47 <blubo> ops sorry i'm new inj all this things i know only html and i try just find some help:(
19:56:15 <hatds> 'applied logicians' makes me smile all by itself
19:56:25 <edwardk> blubo: not a problem
19:56:40 <cmoore> nick hydo
19:56:46 <cmoore> oops
20:00:21 <edwardk> hrmm. i think i'm actually going to rename what i'm currently calling a Parser in parsimony to a Grammar, that way i can write different Parsers for the same Grammar.
20:01:12 <hatds> is it useful to have different Parser for the same Grammar?
20:01:18 <hatds> *Parsers
20:01:28 <Saizan> uh, there's no Return in uu-parsinglib, just lazyness
20:01:50 <edwardk> hatds: yeah, for instance i can parse it using Parsec, using a CYK algorithm, uu-parsinglib, using my monoidal TIG parser, etc.
20:02:01 <edwardk> Saizan: ?
20:03:28 <edwardk> hatds: the monoidal version works well if you plan to keep reparsing after local changes. i can bake it into a fingertree, the parsec one works well if you've mostly left factored the grammar, etc.
20:03:34 <Saizan> edwardk: the Steps gadt doesn't have a place to store the final result, but you emulate that with Apply (const result) fail
20:04:01 <edwardk> Saizan: yeah the paper talks about how you can kill the 'Done' node once you've made 'Apply'
20:04:42 <Saizan> edwardk: i must have missed that
20:06:20 * Saizan is trying to shoehorn other kinds of repairings into it
20:06:49 <Saizan> e.g. swapping two tokens instead of deleting and reinserting
20:07:03 <hydo> ugh!  Working in erlang now after several weeks of using haskell is frustrating.  I'm having a hard time adjusting to code compiling just fine... and then blowing up in my face like a  bad science experiment.
20:07:10 <Saizan> but the lookahead is a bit problematic
20:07:48 <Twey> hydo: *chuckles*
20:07:56 <edwardk> saizan: yeah
20:08:04 <Twey> Erlang вЂstringsвЂ™ make me wince
20:08:19 <edwardk> Saizan: basically what you need is a sort of smart edit distance to a value that would be accepted by the parser
20:08:24 <hydo> twey:
20:08:47 <hydo> twey: my kingdom for erlang-like message passing and concurrency in Haskell...
20:08:57 <hydo> Or... dast I dream?  Is there something like that?
20:09:02 <hydo> I'm not talking about threads.
20:09:09 <Twey> It's not that hard to rig up
20:09:24 <edwardk> Saizan: viewing the 'open parser steps' as a trie should give you a way to compute that as a dynamic programming problem ala a standard levenshtein distance rather than the simpler metric used in the lib
20:09:32 <Twey> Erlang basically just passes a Chan implicitly to every function
20:10:00 <ManateeLazyCat> Saizan: I use command "hbuild -i ./ --infer Manatee.Buffer Manatee.Event Manatee.Key Manatee.Pane Manatee.Statusbar Manatee.Utils Manatee.Window Manatee.WindowList", but nothing output at `build-depends:`.
20:10:05 <hydo> twey: Forgive my ignorance but, define Chan?
20:10:16 <Twey> spawn f = newChan >>= forkIO . f
20:10:21 <Twey> Or rather
20:10:23 <edwardk> Saizan: one interesting thought would be to store the grammar instead as a PCFG that way you could use the probabilities to improve the analysis of the plausability of a parse
20:10:36 <edwardk> and to improve the prioritization in 'best'
20:10:40 <Twey> spawn f = do ch <- newChan; forkIO $ f ch; return ch
20:10:50 <Twey> hydo: A Chan is a thread-safe queue
20:10:50 * dolio fully supports including Manatee as a new top level module name in the next revision of the haskell libraries.
20:10:58 <Twey> You can use it for message-passing between threads
20:11:08 <Twey> (like in Erlang)
20:11:11 <Berengal> dolio: Is this a movement?
20:11:24 <edwardk> dolio: are you sure? someone might mistake it for Mermaid
20:11:24 <dolio> It is now.
20:11:30 * Berengal usually does message passing when doing concurrency
20:11:38 <ManateeLazyCat> Saizan: Just create ./_hbuild/cache file.
20:11:40 <Berengal> dolio: What's supposed to go in it?
20:11:45 <hydo> twey: Thank you for that!  I'm going to start reading up on it now.
20:11:47 <Twey> It's not built in, so the implementation's not quite as neat, but it's pretty easy to translate an Erlang idiom to Haskell
20:11:56 <roconnor> Saizan: presumably if we had a (more) proper package system, then the haskell platform wouldn't be needed.
20:11:57 <dolio> I don't know. Looks like GUI stuff.
20:12:03 <kerlo> So, it seems that the generic zipper just linearizes a datatype and then says "hey, use delimited continuations now".
20:12:06 <Twey> (and Haskell handles concurrency better than Erlang in terms of performance, according to the shootout :-P)
20:12:14 * hydo braces for a rewrite of $web_app
20:12:18 <Twey> Hehe
20:12:19 <physique> haskell is too cryptic
20:12:36 <dolio> Maybe we could just change Numeric to Manatee.
20:12:38 <Twey> physique: Your face is too cryptic
20:12:39 <Cale> physique: Is there something in particular you're confused about?
20:12:39 <Berengal> You could do something like "type Process = ReaderT Chan IO"
20:12:41 <Berengal> ish
20:12:50 <Cale> physique: I can try to explain :)
20:12:55 <SamB> physique: Haskell expects you to do a lot of reading
20:13:06 <SamB> that's why Adobe invented PostScript, you know
20:13:09 <Twey> Cale, you're far too helpful for this early in the morning
20:13:09 <physique> cool cale, nice to know someone is here to help, thank you
20:13:14 <Twey> What did they slip into your coffee?  :-P
20:13:18 <Saizan> ManateeLazyCat: does it output anything?
20:13:27 <Twey> physique: We'll all help if you present an actual question.  :)
20:13:32 <SamB> Twey: actually it's getting kind of late at night
20:13:35 <Cale> I haven't had coffee today, actually I'm almost ready to go to bed :P
20:13:46 <SamB> @localtime
20:13:47 <lambdabot> Local time for SamB is Wed May  6 23:13:47
20:13:51 <SamB> @localtime Cale
20:13:52 <lambdabot> Local time for Cale is Wed May  6 23:13:51
20:13:52 <Twey> @localtime
20:13:54 <lambdabot> Local time for Twey is Thu May  7 05:15:09 2009
20:14:01 <physique> i prefer to read a little more to figure it out on my own
20:14:04 <hydo> Berengal: You wouldn't happen to have an example of doing this would you?  Even a paste posting or something.  I'd love to see how it's done.
20:14:05 <Twey> Are you in Canada, SamB?
20:14:16 <SamB> Twey: no, US
20:14:20 <Twey> Ah
20:14:20 * ManateeLazyCat pasted "hbuild" at http://paste2.org/get/199851
20:14:21 <ManateeLazyCat> Saizan: See above
20:14:29 <ManateeLazyCat> Saizan: http://paste2.org/get/199851
20:14:30 <Cale> I woke up around 2 in the afternoon, but we were out of coffee, so I'm already tired :P
20:14:40 <Twey> Hehe, I know the feeling
20:14:42 <Berengal> hydo: I'm afraid not. It's not something I've implemented yet. I've just passed the chans around explicitly
20:14:56 <Gracenotes> faaaiiiiillliiiiinnnnggg
20:15:00 <ManateeLazyCat> Saizan: hbuild support recursive file search?
20:15:08 <ManateeLazyCat> recursive directory file search
20:15:21 <hydo> Berengal: no problem, I'm assuming if I ask google correctly, it will reveal it's Chan secrets...
20:15:36 <hydo> today is apparently "Comma Day" for me.
20:15:37 <SamB> @index Chan
20:15:38 <lambdabot> Control.Concurrent.Chan, Control.Concurrent
20:15:46 <SamB> @doc Control.Concurrent.Chan
20:15:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
20:15:50 <Berengal> Also TChan
20:15:53 <hydo> SamB: well, there ya go.  Thanks :)
20:15:58 <Twey> Yeah
20:16:06 <ManateeLazyCat> Saizan: Have lunch, back soon. :)
20:16:09 <SamB> hydo: yeah, I didn't think google was going to go for just "Chan" too well
20:16:14 * Berengal uses TChans for ideological reasons
20:16:17 <SamB> though I guess maybe this would have worked
20:16:17 <Twey> There are equivalents in Control.Concurrent.STM that provide considerably more control
20:16:22 <Twey> But they're much slower
20:16:22 <SamB> @google Chan haddock
20:16:23 <lambdabot> No Result Found.
20:16:24 <Saizan> ManateeLazyCat: it'll report an error if it can't find a module
20:16:35 <Saizan> ManateeLazyCat: there might be a bug in parsing the imports though
20:16:36 <SamB> hmm. apparantly not for lambdabot :-(
20:16:46 <Saizan> ManateeLazyCat: or in dealing with ghc-pkg
20:17:01 <Saizan> ManateeLazyCat: do you have the code up somewhere?
20:19:11 <Saizan> edwardk: i actually just need to parse a phrase into [(Lemma,Whitespace)] where the forms of lemmas are taken from a dictionary
20:19:38 <Saizan> edwardk: maybe using a "real" parser is not the best route
20:31:00 <jfoutz> how do i use Control.Exception.bracket with a readerT that wraps IO? it seems like there's some lift i'm missing.
20:31:33 <SamB> jfoutz: I think you can't exactly
20:31:58 <SamB> you would have to write your own bracket
20:32:30 <jfoutz> hrm. any advice for catching socket errors in that case? block and unblock and catch and all that stuff seem to depend on naked IO.
20:32:40 <SamB> I mean, wrapper around that one
20:33:25 <SamB> that deals with passing the readerT stuff across Control.Exception.bracket
20:34:41 <SamB> I think bracket ought to have a typeclass of it's own, personally ...
20:35:32 <jfoutz> hmm. i think i see what you're saying.
20:36:39 <roconnor> @where LOLITA
20:36:40 <lambdabot> I know nothing about lolita.
20:37:38 <jfoutz> i *think* you're saying i need to handle each possible exception right where it could happen, and propigate the errors on my own, like with MaybeT or EitherT
20:38:20 <edwardk> saizan: around?
20:38:24 <jfoutz> or some other local variable... or whatever.
20:38:47 <jinho> hey guys, I'm having difficulty understanding how to write a "step" function when using "foldl" or "foldr"- does anyone know where they might point me to to learn more about this (I've already done a google search)- Thanks!
20:39:20 <jfoutz> SamB: well, that's not what i wanted to hear :) but that makes a lot of sense based on what's provided.
20:39:22 <Jebdm> What do you mean by a "step" function?
20:39:33 <edwardk> jinho: do you have an example of something you'd like to use it for?
20:39:45 <edwardk> Jebdm: the (a -> b -> b) for the fold, etc.
20:39:57 <edwardk> @type foldr
20:39:58 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:40:32 <Jebdm> Is that the terminology usually associated with it?
20:40:34 <jfoutz> > foldr (\x y -> x + y) 0 [1..3]
20:40:36 <lambdabot>   6
20:40:43 <edwardk> jinho: think of foldr as replacing each (:) with a call to your binary step function, and the [] with the value you supply for b.
20:40:51 <edwardk> Jebdm: its not entirely uncommon
20:40:55 <jfoutz> > foldr (+) 0 [1..3]
20:40:56 <lambdabot>   6
20:41:01 <jinho> edwardk: sure- I'm trying to do the exercise in "Real World Haskell," where I'm supposed to implement an "asInt" function, using foldr to convert a String of numbers into it's respective Int
20:41:08 <Twey> jinho: What is a вЂstepвЂ™ function?
20:41:08 <Jebdm> Makes sense, I suppose.
20:41:12 <Saizan> edwardk: yep
20:41:12 <Twey> Oh
20:41:22 * Twey ponders.
20:41:49 <edwardk> jinho: ok, well, ok, so what is your base case? you want to deal with the empty string, it needs to be a number, so 'b' there is easy. you're writing foldr f 0 -- for some f =)
20:41:50 <Twey> Well, you'd want to maintain a current total and a current digit position
20:42:06 <Jebdm> Think about it this way: you've got a series of digits, and you want to interleave a function: 5 fn 4 fn 3 fn 2 fn 1
20:42:31 <edwardk> jinho: after that you have 'the result of reducing all of the #'s to the right of you in the second argument and the character representing the current digit
20:42:34 <Jebdm> Then you have to figure out how you want it to associate
20:43:02 <jinho> ok so then if I write, "fn," what are the arguments?
20:43:06 <Jebdm> ((((5 fn 4) fn 3) fn 2) fn 1), or (5 fn (4 fn (3 fn (2 fn 1))))
20:43:09 <edwardk> so you need the value of the current digit, and to do something with the result
20:43:12 <roconnor> > 2^16
20:43:13 <Jebdm> fn should take two arguments.
20:43:13 <lambdabot>   65536
20:43:19 <jinho> Jebdm: always?
20:43:25 <Jebdm> For a fold, yeah.
20:43:37 <jfoutz> perhaps a deal-breaking hint, but you can use Data.Char.ord to convert a single letter to a numeric value
20:43:44 <jfoutz> > ord 'a'
20:43:46 <lambdabot>   97
20:43:52 <Jebdm> (Where I used fn up there was meant to be infix notation, I should've written `fn`)
20:44:02 <Berengal> > digitToInt '1'
20:44:03 <lambdabot>   1
20:44:27 <jinho> fn a b --> a = penultimate item in list, b = end item in the list?
20:44:27 <Jebdm> In this case, you probably want the first one, which is left associating, so you should use a foldl.
20:44:39 <edwardk> so basically what you're looking for is something like: let f digit resultSoFar = (do something with digit) + resultSoFar * 10
20:44:43 <Saizan> (two or more arguments, actually :)
20:44:45 <Jebdm> And all your function should do is multiply the left argument by 10, and add that to the right.
20:44:52 <edwardk> fn a b -> b
20:44:59 <edwardk> jinho: your base case is the empty list
20:45:10 <edwardk> Jebdm: i'd strongly recommend against using a foldl here
20:45:25 <Berengal> edwardk: What's wrong with foldl?
20:45:25 <Jebdm> Why?
20:45:28 <edwardk> i guess you could do it but i don't want to think about it
20:45:29 <edwardk> =)
20:45:42 <Berengal> Well, I'd use foldl', but anyway...
20:45:48 <Saizan> well, it depends on endianess
20:45:53 <Twey> edwardk: Er, I think it's the main digit you want to multiply by 10^$digit_position, unless my arithmetic is way off
20:46:02 <jinho> edwardk: so then fn a b -> b means that you're applying fn to types "a" and "b", and getting back type "b"?
20:46:06 <Saizan> (if i understood the exercise correctly)
20:46:30 <edwardk> twey: ok, so maybe the foldl will be clearer =)
20:46:48 * Twey nods.
20:47:13 <Twey> But that means you have to keep a tuple, I'm pretty sure
20:47:15 * Twey ponders.
20:47:21 <Berengal> No need for tuples
20:47:27 <Twey> Actually, it would be possible to extract that from the current total, wouldn't it
20:47:32 <Twey> Yeah
20:47:42 <edwardk> twey nah, no tuple needed. i've got the code but am trying to avoid giving it away while he still is trying to figure it out himself
20:47:43 <Jebdm> , let fn a b = a * 10 + b
20:47:44 <lunabot>  luna: parse error on input `)'
20:48:03 <Jebdm> foldl fn 0 [1, 2, 3]
20:48:13 <Jebdm> yields 123.
20:48:31 <Jebdm> You'd have to read the characters in as ints, of course.
20:48:35 <edwardk> > foldl (\v c -> v * 10 + ord c - ord '0') "1234"
20:48:36 <Jebdm> But that's the general gist.
20:48:36 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
20:48:51 <edwardk> > foldl (\v c -> v * 10 + fromEnum c - fromEnum '0') "1234"
20:48:52 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
20:48:56 <Jebdm> > let fn a b = a * 10 + b
20:48:57 <edwardk> wow i suck
20:48:58 <lambdabot>   <no location info>: parse error on input `;'
20:49:07 * Jebdm doesn't know how to use lambdabot.
20:49:08 <Berengal> edwardk: Need base value
20:49:13 * copumpkin just finished explaining monads to his friend
20:49:15 <edwardk> hah
20:49:15 <edwardk> of course
20:49:20 <edwardk> > foldl (\v c -> v * 10 + fromEnum c - fromEnum '0') 0 "1234"
20:49:22 <lambdabot>   1234
20:49:27 <Saizan> Jebdm: @let
20:49:29 <Berengal> > foldl' ((+).(*10)) 0 . map digitToInt $ "1234567890"
20:49:30 <lambdabot>   1234567890
20:49:30 <Jebdm> foldl (\ a b -> a*10 + b) 0 [1,2,3]
20:49:37 <jfoutz> copumpkin: only 5-10 more times and you're good.
20:49:39 <Jebdm> > foldl (\ a b -> a*10 + b) 0 [1,2,3]
20:49:40 <lambdabot>   123
20:49:52 <copumpkin> jfoutz: I compared monads to unicorns ;)
20:49:59 <ManateeLazyCat> Saizan: I put source code under sub-directory ./Manatee, when i change "./" to "./Manate", and output is same, haven't any information after "build-depends".
20:49:59 <Berengal> > foldl' ((+).(*10).digitToInt) 0 $ "1234567890"
20:50:00 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
20:50:06 <edwardk> copumpkin: i would compliment you but i see you're already complemented
20:50:12 <copumpkin> lol
20:50:20 <copumpkin> a monad is like a unicorn
20:50:20 <copumpkin> you can stick things in its butt
20:50:21 <copumpkin> I won't go on
20:50:26 <jfoutz> copumpkin: well you can save space suits and nuclear storage for the next few times.
20:50:34 <Saizan> ManateeLazyCat: yeah, i was asking if your code is available somewhere so i could test it too
20:50:54 <Saizan> ManateeLazyCat: otherwise i don't know :)
20:50:58 <Berengal> Monads are like cars
20:51:13 <copumpkin> I prefer my unicorn analogy
20:51:16 <copumpkin> it works pretty well
20:51:22 <jfoutz> copumpkin: no, i see. they all chain together. *shiver*
20:51:27 <copumpkin> :P
20:51:39 <copumpkin> you can also come up with the "join" interpretation, which I won't expand upon
20:51:52 <ManateeLazyCat> Saizan: Oh, now i'm developing and haven't release it.
20:51:54 <Cale> http://www.research.att.com/~njas/sequences/A130826 -- ahaha
20:52:13 <Berengal> monads = unicorns.burritos.cars.ocean.box of apples.nuclear waste
20:52:17 <edwardk> cale: hahaha
20:52:35 <copumpkin> I always wondered where the numbers came from
20:52:37 <ManateeLazyCat> Saizan: If you like, i will send all my source code to you.
20:52:54 <jinho> ok so I'm still confused: If I have foldl fn 0 xs
20:53:01 <Cale> It's pretty unlikely that they came from that ;)
20:53:09 <jinho> where xs is of type String
20:53:09 <edwardk> copumpkin: i think this was retroactively found ;)
20:53:16 <jinho> then when I write
20:53:17 <jinho> fn a b
20:53:24 <copumpkin> edwardk: :(
20:53:24 <jinho> what are teh types of a and b?
20:53:27 <ManateeLazyCat> Saizan: 20k
20:53:31 <Cale> Then a must be a number, and b must be a Char
20:53:36 * BMeph imagines a one-horned burrito, with a (co)pumpkin up its "butt"...
20:53:43 <Cale> er
20:53:44 <Saizan> ManateeLazyCat: see query
20:53:46 <BMeph> Hey, all. :)
20:53:49 <jinho> Cale: thanks
20:54:00 <Cale> No, actually, I'm smoking crack :)
20:54:11 <Cale> :t foldl
20:54:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:54:31 <Cale> no, no, I'm right :)
20:54:34 <Cale> hehe
20:54:36 <BMeph> Cale: DAAAAAAAAAMN, Smokey! ;p
20:54:51 <jinho> Cale: how would I read (a -> b -> a) -> a -> [b] -> a?
20:54:53 <Cale> let's construct an example...
20:55:23 <Cale> jinho: If a and b are any types, then it takes a function of type (a -> b -> a) and a value of type a, and a list of b's, and produces an a
20:55:53 <Cale> > foldl (\x y -> x + ord y) 0 "hello"
20:55:55 <lambdabot>   532
20:56:29 <jfoutz> a function taking stuff and things. give that function a base stuff, and a list of things. for each element turn one thing into a stuff, and glue it onto the stuff i've accumulated so far. when you run out of things, gimmie the accumulated stuff.
20:56:33 <Cale> > foldl (\x y -> y : x) "" "hello"
20:56:34 <lambdabot>   "olleh"
20:56:36 <ManateeLazyCat> Saizan: I have send it to you.
20:56:45 <Cale> > foldl (\x y -> y : x) "." "hello"
20:56:46 <lambdabot>   "olleh."
20:56:54 <Saizan> ManateeLazyCat: testing
20:57:23 <Cale> > foldl (flip (:)) [] [1,2,3,4,5]
20:57:24 <lambdabot>   [5,4,3,2,1]
20:57:33 * BMeph finds it unfair that foldl's type structure is more "symmetrical than foldr
20:57:39 <Cale> huh?
20:57:49 <Cale> Oh, I see
20:57:54 <Axman6> heh
20:57:55 <Cale> I suppose it is, sort of.
20:59:40 <jinho> ok so If I write: foldl (\ a b -> a * 10 + (digitToInt b)) 0 "12345"
21:00:25 <jfoutz> BMeph: but foldl' gets to be tail recursive. i guess foldl does to... just with thunky stack consumption.
21:00:25 <jinho> but this: http://pastebin.com/m4117b0cf
21:00:28 <jinho> doesnt work
21:00:50 <Berengal> > foldl (\ a b -> a * 10 + (digitToInt b)) 0 "12345"
21:00:51 <lambdabot>   12345
21:00:56 <PetRat> I have a Parsec question: http://www.mibbit.com/pb/cRhVs4
21:01:33 <PetRat> In essence I'm using manyTill x (try y) and finding that this consumes y
21:01:37 <jinho> foldl (\ a b -> a * 10 + (digitToInt b)) 0 "10001000"
21:01:49 <jinho> > foldl (\ a b -> a * 10 + (digitToInt b)) 0 "10001000"
21:01:52 <Berengal> PetRat: try only backtracks on failure
21:01:52 <lambdabot>   10001000
21:02:06 <Berengal> At least I believe that's true
21:02:14 <PetRat> Berengal: that would make some sense.
21:02:44 <PetRat> Is there a way to use manyTill and NOT consume the parser that represents the terminating condition?
21:02:46 <BMeph> jinho: Reverse the order of the equations. Haskell doesn't play around when we say it's Lazy. ;)
21:03:06 <Jebdm> jinho: Pattern matching stops at the first chance it gets.
21:03:09 <jfoutz> PetRat: won't anychar grab the whole input?
21:03:28 <jinho> hold up- none of that made sense
21:03:30 <jinho> T_T
21:03:33 <Jebdm> by putting myAsInt _ = 0, you've guaranteed that it'll never get to the second case.
21:03:37 <Berengal> PetRat: This requires some boolean algebra hackery in the parser. I recently did something like it, but can't remember how right now...
21:03:38 <jfoutz> PetRat: oh, sorry nvm.
21:03:40 <PetRat> jfoutz: empirically it doesn't work that way... it checks the terminating parser first.
21:03:47 <jinho> jebdm: oh....
21:03:56 <jfoutz> PetRat: just read the docs :)
21:03:57 <Jebdm> just switch them
21:04:33 <Jebdm> Actually, just get rid of it, I think.
21:04:40 <PetRat> I guess nothing is wrong then.
21:05:19 <jinho> ah haha
21:05:32 <jinho> ok...veeerrrry interesting...
21:05:39 <PetRat> Is there some way to do this with lookahead?
21:05:44 <jinho> i think i just blew out 5 screws w/ that problem
21:05:49 <Cale> jinho: http://cale.yi.org/index.php/Fold_Diagrams
21:06:07 <Cale> jinho: (hopefully that's reachable -- I'm on a torrent which sometimes causes my router to act up)
21:06:22 <jinho> Cale: It's beautiful
21:06:52 <BMeph> jinho, Cale: I prefer "CrazySexyCool," but maybe that's me... ;)
21:07:08 <Cale> BMeph: huh?
21:07:26 <BMeph>  Cale: As opposed to "merely" beautiful. :)
21:07:28 <jinho> BMeph: I think I'll stick to beautiful- haha
21:07:33 <PetRat> I remember now what someone showed me:   manyTill anyChar (lookAhead termination)
21:07:33 <Cale> BMeph: ah!
21:07:36 <Cale> hehe
21:08:22 <Twey> > foldl (\a b -> a * 10 + digitToInt b) 0 "12345"
21:08:23 <lambdabot>   12345
21:08:45 <Twey> OK, somebody's going to have to explain to me how that wвЂ” ohhh, I get it...
21:09:03 <Twey> D'oh.  I never even considered that approach.
21:09:19 <jfoutz> PetRat: i don't see a lookahead combinator, BUT! you probably want to use that string, why not just use the "next" parser right there instead of the feedback parser?
21:09:34 <Jebdm> Twey: what would you have done?
21:10:33 <Cale> foldr f z . reverse = foldl (flip f) z
21:10:37 <Twey> Jebdm: I was considering working from the units leftward, keeping track of my place in the string and multiplying each digit by 10 ^ $digit_place
21:10:43 <Twey> This way's much better
21:10:48 <jfoutz> PetRat: or, lookahead. parses p without consiming any input.
21:11:04 <jfoutz> <-- reading slow tonight.
21:12:29 <Cale> > sum . map (\(k,d) -> d * 10^k) . zip [0..] . reverse . map digitToInt $ "12345"
21:12:30 <lambdabot>   12345
21:12:57 <Twey> Yeah, that's the idea
21:13:12 <Jebdm> Yeek.
21:13:16 <Twey> Horrible eh
21:13:33 <Twey> Except I was trying to do it all in one foldr.
21:18:33 * mmorrow is reading logs
21:18:35 <mmorrow> <tiglionabbit_> http://nickretallack.com/lifegame/
21:18:38 <mmorrow> this is awesome!
21:19:26 <mmorrow> (it looks nice, works well, and *doesn't crush your cpu*)
21:19:57 <jfoutz> mmorrow: have you ever read the old dr. dobbs about hashlife?
21:20:03 <dancor_> @pl onLeft f (Left a) = Left (f a)
21:20:03 <lambdabot> (line 1, column 19):
21:20:03 <lambdabot> unexpected "="
21:20:03 <lambdabot> expecting variable, "(", operator or end of input
21:20:15 <dancor_> anyway, is that anything?  onRight is fmap
21:20:18 <mmorrow> i haven't, but someone mentioned hashlife to me at one point
21:20:29 <mmorrow> jfoutz: link? :)
21:20:32 <jfoutz> http://www.ddj.com/hpc-high-performance-computing/184406478
21:20:36 <jfoutz> it's swell.
21:20:40 <Cale> golly!
21:20:54 <jfoutz> really changed a lot of my thinking about programming... a long time ago.
21:21:03 <dmwit> mmorrow: Plus it's synchronized with my music!
21:21:07 <dmwit> How rad is that??
21:21:15 <mmorrow> heh
21:21:24 <mmorrow> jfoutz: nice, thx
21:21:32 <Cale> (no really, golly, it's a fast life implementation)
21:21:48 <mmorrow> Cale: and it's in js :)
21:22:07 * mmorrow looks at the code
21:22:24 <Cale> http://golly.sourceforge.net/
21:22:45 <mmorrow> oh
21:22:56 <mmorrow> oh sweet
21:23:06 <mmorrow> i like "lucidlife"
21:23:39 <maxote> ~golly
21:24:47 <Cale> The lovely thing about hashlife is that it can abstract away most patterns in order to keep running faster and faster.
21:25:43 <Cale> So things like life-in-life can run at a reasonable speed :)
21:25:46 <ManateeLazyCat> Saizan: Now hbuild depend fgl, and fgl depart pcre library, user will failed to install hbuild if user haven't install pcre library. I install libpcre3-deve in Debain. So i think it's will be better if you write this notes in document.
21:26:02 <jinho> why can't you do something like (xs:x) in pattern matching? Does this have to do w/ infinite lists?
21:26:25 <jfoutz> Cale: yeah, hashlife is probably the pinnacle of memoization's effectiveness. it makes me happy just thinking about it.
21:26:31 <ManateeLazyCat> is libpcre3-dev
21:26:51 <Cale> jinho: It has to do with the way that lists are fundamentally constructed
21:27:00 <Saizan> ManateeLazyCat: fgl uses pcre?
21:27:12 <Cale> jinho: also, you can do that, but xs will match the first element of the list and x the tail
21:27:24 <jinho> Cale: right...
21:27:59 <Cale> jinho: Lists are built so that lists having the same tail can physically share the same memory.
21:28:29 <Cale> jinho: and optimise for the case of going through the list from the start to the end
21:28:47 <jinho> gotcha
21:29:01 <Cale> (and updates near the beginning -- somewhat like stacks in that regard)
21:29:14 <Cale> If you need random access, or access to both ends, then you should use Data.Sequence
21:29:40 <copumpkin> I wonder if it's possible to make matrix algorithms in haskell elegant
21:29:46 <Cale> It can't be infinite, but it has log time concatenation and splitting, and O(1) access to both ends
21:30:00 <Cale> copumpkin: Which ones in particular?
21:30:10 <copumpkin> the hmatrix-static stuff is getting closer
21:30:20 <copumpkin> I dunno, say I want to do cholesky decomposition of a matrix
21:30:36 <copumpkin> do it in a nice idiomatic manner but efficiently
21:30:42 <copumpkin> that'd be nice :)
21:31:31 <copumpkin> the algorithm is recursive, but there aren't nice ways of "filtering" or "zipping" matrices
21:31:36 <copumpkin> to do what we'd normally do with lists
21:32:06 <ManateeLazyCat> Saizan: yep, When i build hbuild, fgl failed, and fgl said it can't find pcre library, so i install `libpcre3-dev` and problem fix.
21:32:27 <jfoutz> copumpkin: i think that's a long way off. but i'm sure patches are welcom ;)
21:32:33 <Cale> Well, you'd want operations for splitting and merging blocks.
21:32:45 <copumpkin> Cale: yeah, but I'm trying to think of a nice way of doing it
21:33:06 <Cale> Hmm...
21:33:19 <copumpkin> but I admit I'm being pretty vague :P
21:33:33 <copumpkin> it'd just be nice to do algorithms on matrices with the same elgance we get with lists
21:35:31 <mmorrow> write a datatype, and some functions to build it up in certain ways, then have a function that "compiles" a value of this datatype to efficient code (in some manner)?
21:35:37 <copumpkin> hmm
21:35:40 <Cale> I somehow feel like the ideal notation would involve a new binding form.
21:35:47 <copumpkin> Cale: how so?
21:35:54 <copumpkin> mmorrow: the functions to build it up in certain ways are what puzzle me
21:35:56 <Cale> Matrix pattern matching
21:36:05 <copumpkin> lists are easy cause they're "1d"
21:36:11 <Cale> (by block decomposition)
21:36:20 <copumpkin> hmm, that would be nice
21:36:40 <copumpkin> could we do it with a fancy type constructor?
21:36:51 <mmorrow> copumpkin: zipMat :: MatAlg -> MatAlg -> MatAlg; zipMap a b = Zip a b
21:37:02 <mmorrow> s/zipMap/zipMat/
21:37:09 <copumpkin> oh yeah, zipping matrices makes sense
21:37:23 <copumpkin> but I'm talking about the "break it into rectangular areas" kind of thing
21:37:31 <copumpkin> or pattern match on the diagonal or something
21:37:32 <ManateeLazyCat> Saizan: Expect you release new version of hbuild. :)
21:37:38 <mmorrow> or something.. the point being you build a *representation* of the algorithm consisting of data, then you compile that
21:37:56 <mmorrow> you could compile it to anything too
21:38:10 <mmorrow> haskell, C, asm, machine code, LOLCODE, ...
21:38:13 <copumpkin> :)
21:38:20 <SamB> mmorrow: you don't need indices in those types ?
21:38:23 * mmorrow votes for LOLCODE
21:38:33 <copumpkin> doing it fast is a concern
21:38:41 <mmorrow> SamB: i dunno the details yet
21:38:48 <copumpkin> bu I'm mostly trying to think of what would be the most elegant to represent a "Chain" of functions as you'd normally do in haskell
21:38:57 <SamB> specificly, sizes
21:39:00 <copumpkin> that would allow you to do typical matrix operations nicely
21:39:08 <copumpkin> SamB: hmatrix-static does that
21:39:08 <ManateeLazyCat> Saizan: I also expect GHC remove .hs-boot file someday.
21:39:19 <copumpkin> ManateeLazyCat: the ticket is in _|_ iirc
21:39:29 <SamB> copumpkin: doesn't mean much
21:39:38 <ManateeLazyCat> copumpkin: _|_ ?
21:39:38 <copumpkin> I've been playing with hmatrix recently
21:39:43 <SamB> just means they dunno when, if ever, they'll get around to it
21:39:51 <SamB> but there are a lot of tickets there
21:39:52 <copumpkin> ManateeLazyCat: the bugs they acknowledge but don't intend to fix in the near future
21:39:57 <copumpkin> SamB: I know :P
21:40:35 <SamB> and some of those could, who knows, maybe even be fixed in the next release if someone bothered to do the work
21:40:42 <copumpkin> yup :)
21:40:47 <SamB> (depending on whether they involve incompatabilities and so forth)
21:41:04 <SamB> (and whether anyone remembers to merge them before the release ;-)
21:41:56 <SamB> though hs-boot going away is obviously not one of the trivial ones
21:42:10 <ManateeLazyCat> copumpkin: Is develop no time or they think it's just little problem?
21:42:19 <SamB> well, obvious if you've ever used lhc anyway ;-)
21:42:22 <ManateeLazyCat> s/develop/developer
21:42:22 <copumpkin> ManateeLazyCat: they don't think it's that big a deal, although the situation isn't ideal
21:42:59 <ManateeLazyCat> copumpkin: Yep, not a big deal, but troublesome and waste programmer time.
21:43:22 <copumpkin> more time is wasted by the crappy numeric typeclasses :P
21:45:03 * Saizan wonders if he should continue parsing modules or delegate to ghc -M and parse the Makefile
21:46:06 <Saizan> ok, i can't do the latter since some modules might not be there in time
21:46:16 <copumpkin> another nice thing could be to have infinite matrices
21:48:16 <mgsloan1> you can have infinite lists of infinite lists
21:48:25 <copumpkin> yeah, but that's not as cool
21:48:42 <mmorrow> Saizan: ghc's parser has an entrypoint that parses only the module header, and won't error out if there's an error at, say, line 4000.
21:48:59 <mmorrow> (uses a happy feature that does this)
21:49:31 <Saizan> mmorrow: module header and imports?
21:50:10 <mmorrow> yes
21:50:59 <Saizan> mmorrow: where should i look for this? :)
21:51:08 <mmorrow> Saizan: i'm not sure the particulars of using it from the ghc-api directly, but i've got it in luna http://moonpatio.com/repos/luna/haddocks/src/Luna-Parser.html#myParseHdr
21:51:34 <mmorrow> Saizan: you could probably use that code to figure out how to get at it (i don't recall exactly)
21:51:46 <mmorrow> (or you could use the luna code directly too)
21:52:33 <mmorrow> (i don't even recall if that functionality is exported by the ghc-api)
21:53:43 <Saizan> thanks
21:53:53 <mmorrow> np
21:55:28 <mmorrow> Saizan: speaking of ghc/luna, i've been messing with some code to disassemble bytecode and do various things with it (not sure exactly what yet). here's a sample http://moonpatio.com/repos/bc_eg.txt
21:55:30 <mmorrow> weee
21:56:25 <mmorrow> (well, this realy has nothing to do with luna other than that i'm using that package to collect any random ghc-hackery-related code i have)
21:57:06 <rawrsy> Half way through Chap 2 of RWH
21:57:19 * Saizan has no idea of what he's looking at
21:57:40 <mmorrow> Saizan: it's the disassembled bytecode + the infotables for the "A" datatype from:
21:57:48 <mmorrow> "data A a = A a | B deriving (Show)\nfix f = let x = f x in x"
21:58:36 <mmorrow> the very top level of "fix" is:
21:58:45 <mmorrow> [(BCI_ALLOC_AP, [2]), (BCI_PUSH_LL, [0, 1]), (BCI_PUSH_G, [0]),(BCI_MKAP, [3, 2]), (BCI_PUSH_L, [0]), (BCI_SLIDE, [1, 2]),(BCI_ENTER, [])]
21:59:10 <mmorrow> :: [(ByteCodeOp, [ImmediateArg])]
21:59:17 <mmorrow> (made those names up)
21:59:19 <wli> Whose bytecode is that?
21:59:22 <Saizan> that's the part where i'm lost :)
21:59:23 <mmorrow> ghci's
21:59:50 <mmorrow> (the names's i made up are "ByteCodeOp" and "ImmediateArg", they really are:
22:00:08 <mmorrow> BCI (i defined this type, it's just an Enum for the diff bytecodes)
22:00:10 <mmorrow> and Word16
22:00:50 <mmorrow> and that gets slurped from a ByteArray# --> Ptr Word16
22:02:43 <mib_ecglf337> > 2 + 3
22:02:45 <lambdabot>   5
22:02:58 <mib_ecglf337> @vixen
22:02:58 <lambdabot> Any way you want it, baby!
22:03:11 <mib_ecglf337> hmm I still miss the old vixen
22:03:22 <mmorrow> "allocate an application node of arity 2, push two literals 0 and 1, push the ptr at index 0 in this bytecodeobject, fill in the earlier allocated ap node with two vals from the stack, push the literal 0, slide out two vals from the stack starting at depth 1, enter the node pointed to by the ptr on top of the stack"
22:08:30 <mib_ecglf337> > let isNotPrime primes x = any (p -> x `mod` p == 0) $ takeWhile (p -> p * p < x) primes in let primes = filter (not . isNotPrime) [2..]
22:08:31 <lambdabot>   <no location info>: parse error on input `->'
22:08:49 <mib_ecglf337> > let isNotPrime primes x = any (\p -> x `mod` p == 0) $ takeWhile (\p -> p * p < x) primes in let primes = filter (not . isNotPrime) [2..]
22:08:50 <lambdabot>   <no location info>: parse error on input `;'
22:27:39 <ssf> can anyone explain why this doesn't work, and how to fix it?
22:27:44 <ssf> triangle =
22:27:44 <ssf> {
22:27:44 <ssf> [[75],
22:27:44 <ssf> [95, 64],
22:27:44 <ssf> [17, 47, 82],
22:27:45 <ssf> [18, 35, 87, 10],
22:27:47 <ssf> [20, 04, 82, 47, 65],
22:27:51 <ssf> [19, 01, 23, 75, 03, 34],
22:27:53 <ssf> [88, 02, 77, 73, 07, 63, 67],
22:27:55 <ssf> [99, 65, 04, 28, 06, 16, 70, 92],
22:27:57 <ssf> [41, 41, 26, 56, 83, 40, 80, 70, 33],
22:27:59 <ssf> [41, 48, 72, 33, 47, 32, 37, 16, 94, 29],
22:28:01 <ssf> [53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14],
22:28:03 <ssf> [70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57],
22:28:05 <ssf> [91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48],
22:28:07 <Cale> ssf:
22:28:07 <ssf> [63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31],
22:28:09 <ssf> [04, 62, 98, 27, 23, 09, 70, 98, 73, 93, 38, 53, 60, 04, 23]]
22:28:11 <ssf> }
22:28:21 <Cale> ssf: You should paste things on hpaste
22:28:21 <ssf> I have it in a .hs file, it gives me parse errors.
22:28:30 <Cale> The parse error is from the { and }
22:28:34 <Cale> which are unnecessary
22:28:37 <ssf> Cale:sorry
22:28:56 <ssf> don't I need indentation then? I want to be able to avoid using indentation.
22:29:04 <copumpkin> :o
22:29:21 <Cale> Must you avoid it?
22:29:32 <ssf> it is annoying. ;)
22:29:58 <copumpkin> you should learn the haskell way!
22:30:05 <ssf> anyway, i should be able to do this with braces instead of indentation. Right?
22:30:18 * copumpkin reluctantly nods
22:30:48 <ssf> i use indentation normally. just for certain cases i want to be able to use braces.
22:31:15 <ssf> if i have a block of data, for instance, i'd rather leave it unindented.
22:31:23 <ssf> so can it be done?
22:31:26 <Twey> I don't think you need the braces there
22:31:39 <Twey> The data are already inside a pair of square brackets
22:31:39 <Cale> I don't think you can break lines without using indentation.
22:31:47 <Twey> They couldn't be considered top-level definitions
22:32:05 <Cale> So it's either put it all on one line, or lay it out properly.
22:32:05 <ssf> well no, i still get parse errors without the brackets.
22:32:28 <Cale> You need at least one space of indentation to continue the expression to the next line
22:32:43 <ssf> i thought braces made everything as if it were on a single line.
22:33:40 <ssf> or do i misunderstand braces?
22:33:43 <Cale> I suppose that's a possible use of indentation which they don't cover. They're part of the syntax of do, where, let and case ... of
22:34:03 <Cale> and using indentation automatically adds them in those cases where they're required
22:34:21 <Cale> But there's no rule about continuing expressions onto multiple lines which involves braces, as far as I know.
22:34:25 <ssf> hmm
22:35:16 <Cale> hmm
22:35:22 <Cale> You can do something ugly...
22:35:30 <Cale> triangle = let { x =
22:35:35 <Cale> [[75],
22:35:35 <Cale> ...
22:35:52 <Cale> [...]] } in x
22:35:59 <ssf> heh, just figured that out myself...
22:36:13 <ssf> I think it's beautiful... :P
22:36:22 <Cale> But don't. Unless you're blind or something, just learn to use indentation.
22:36:37 <Gracenotes> in some editor you can indent an entire block with Select+Tab
22:36:39 <Gracenotes> s
22:36:50 <ssf> well, i realize i can just indent all those lines of data. but I wanted to know how to do it without indentation.
22:37:27 <Cale> ssf: Also, make sure to configure your editor such that it doesn't stick tab characters into files. It should generate spaces when you hit tab
22:37:52 <mmorrow> ssf: also, you can use {} and ; to put you entire module on a single line, which imo is awesomer ;)
22:37:55 * SubStack thinks \t is quite pesky
22:38:02 <ssf> i'm using emacs (but I'm not tremendously experienced with it)
22:38:21 * Gracenotes makes his editors use soft tabs
22:38:38 <ssf> if i use the default indent mode and try to indent it goes insane.
22:38:39 <Gracenotes> er... or whatever auto-spaced tabs are called
22:38:50 <Gracenotes> apparently "soft tab" has to do with ED
22:39:05 <ssf> i think if I switch the mode, it works okay though.
22:39:33 <Cale> ssf: The funny thing about the "smart" Haskell indent mode is that it sometimes requires you to type the first couple characters of the line before it can figure out how to properly indent it.
22:39:49 <ssf> right.
22:39:54 * SubStack set expandtab
22:40:45 <Cale> I think haskell-mode already flips whatever option it is that replaces tabs with spaces.
22:44:24 <ssf> thanks guys.
22:47:52 <dmwit> SubStack: Yep, and every time I ":set ai" I feel like I'm starting skynet. =P
22:51:41 <mmorrow> dmwit: don't do it!
22:52:02 <dmwit> But it's so convenient!
22:52:11 <dmwit> All my enemies dissolve into puddles of blood!
22:52:20 <dmwit> (Also, my lines get indented nicely. =)
22:52:27 <SubStack> sw=4 and tabstop=4 too
22:54:34 <mmorrow> dmwit: ok fine, just as long as all the T1000's look like that actor in terminator 2
22:54:46 <mmorrow> (and are wearing LAPD uniforms)
22:56:35 * mmorrow uses  set tabstop=2   set shiftwidth=2
22:56:53 <mmorrow> and set textwidth=78 !!!!
22:57:13 * SubStack thinks 2 is too little but isn't as bad as 3
22:57:25 * SubStack hates 3 because it's too indistinguishable from 4
22:58:09 <mmorrow> also, colorscheme desert is essential :)
22:59:30 <SubStack> :set background=dark
23:03:36 <Craig`> hey
23:08:35 <Craig`> I did: cd "\users\alan\code\haskell"
23:08:44 <Craig`> then type ghci, yet it doesnt work
23:08:46 <Craig`> it used too?
23:08:52 <Craig`> *to
23:20:07 <ski> Craig` : are you sure you shouldn't use `/' instead of `\' ? .. are you on windows ? a unixoid system ?
23:20:14 <ski> is `ghci' in the path ?
23:21:39 * wli ponders World3.
23:24:18 <JoshTriplett> I have some code which currently has to do this: do mode <- gets fooMode ; case mode of ModeA -> x ; ModeB -> x ; _ -> y
23:24:32 <JoshTriplett> Does any way exist to write the two common cases more concisely?
23:24:34 <Craig`> sorry about the delay, I need \s for windows, and I used to do it this way, yet now it doesnt work
23:24:51 <JoshTriplett> And does any way exist to write the gets followed by case more concisely?
23:25:14 <Craig`> 'ghci' is not recognized as an internal or external command,
23:25:15 <Craig`> operable program or batch file.
23:25:35 <quicksilver> JoshTriplett: not really no.
23:25:46 <dblick1> has anyone had success building shared libraries with haskell code?  i'd like to use the haskell ffi and python c api to build frontends for my code, but building shared libraries with GHC seemed like a dead end for now
23:25:53 <quicksilver> JoshTriplett: gets fooMode >>= \mode -> case mode of ....
23:25:56 <ski> JoshTriplett : unfortunately, haskell doesn't have disjunctive patterns
23:25:57 <quicksilver> JoshTriplett: is not really any better :)
23:26:19 <quicksilver> JoshTriplett: it is occasionally suggested to have a special form of 'case' where for this
23:26:36 <quicksilver> gets fooMode >>= \case of ..... (or something like that)
23:27:01 <JoshTriplett> quicksilver: That sounds fairly appealing, yeah. :)
23:27:20 <ski> (Craig` : are you using Cygwin (or maybe Mingw) ?)
23:27:23 * wli ponders the fewest number of multiplications to raise a number to a power, too.
23:27:53 <mauke> case mode of _ | isModeAorB mode -> x
23:28:05 <Craig`> i don't know tbh :/
23:28:19 <JoshTriplett> mauke: Heh.
23:28:24 <ski> mauke : use `if' instead, then ?
23:30:29 <ski> Craig` : try writing `path' as a command
23:31:16 <mmorrow> quicksilver: how's the sse nativegen coming?
23:31:31 <wli> What are disjunctive patterns?
23:31:39 <Craig`> sorry gtg
23:32:28 <mmorrow> wli: i think something like being able to match one of n patterns for a particular match
23:32:43 <ski> wli : Disjunctive patterns <http://successor-ml.org/index.php?title=Disjunctive_patterns>
23:32:51 <mmorrow> foo ([x] | [x,y,z]) =
23:32:53 <mmorrow> ?
23:33:35 <mmorrow> i guess you wouldn't be allowed to use different vars though in the different possibilities
23:33:37 <ski> not quite
23:33:47 <ski>   foo ([x] | [x,_,_]) = ..
23:33:49 <ski> would be ok
23:34:04 <mmorrow> ah
23:34:13 <ski> .. though i suppose one could simply take the intersection, instead of requiring that all patterns bind the same variables
23:34:23 <mmorrow> true
23:34:40 <mmorrow> foo ([x] | [x,y,z]) = x -- ok
23:34:45 <mmorrow> foo ([x] | [x,y,z]) = y -- error
23:34:48 <mmorrow> or something
23:34:58 <ski> (this might perhaps be useful in conjunction with view patterns or similar, where local bindings in a pattern can be used locally for deciding whether something matches)
23:35:06 <ski> yea
23:35:49 <ski>   foo ([x] | [x,y,(== y) -> True]) = x
23:35:54 <ski> something like that
23:36:07 <mmorrow> ???
23:36:33 <JoshTriplett> I suppose I could do something crazy like case mode of ((`elem` [ModeA, ModeB]) -> True) -> x
23:36:36 <mmorrow> ski: i don't understand your notation
23:36:43 <mmorrow> ski: what is that suppose to mean?
23:36:51 <dolio> It's view patterns.
23:37:17 <mmorrow> but the (==y) -> True is in the list?
23:37:24 <dolio> f -> p matches a value x if f x matches p.
23:37:39 <mmorrow> ohhhh
23:37:42 <mmorrow> ok, i see it now
23:37:48 <ski> , [$ty| let f (x,(== x) -> True) = Just x; f _ = Nothing in f |]
23:37:50 <lunabot>  forall a . Eq a => (a, a) -> Maybe a
23:38:03 <dolio> [x,y,(== y) -> True] is equivalent to [x,y,y] if you have unification.
23:38:10 <mmorrow> f (x,y) | y==x = Just x ...
23:38:28 <ski> yea, this was just a simple example
23:38:40 <dolio> At least, assuming your unification goes through (==).
23:38:51 <mmorrow> oh, i was just writing out an equivalent to make sure i'm understanding
23:39:27 <mmorrow> (wasn't saying "what's the point if you can just do it this way" ;)
23:39:51 <ski> JoshTriplett : seems easier to use `if' then, imo
23:40:07 <JoshTriplett> ski: Yeah.
23:40:43 <JoshTriplett> ski: Except that some of the modes have a boolean parameter.
23:40:53 <JoshTriplett> ski: And sometimes I don't care about the parameter.
23:41:07 <JoshTriplett> ski: So the ability to write case mode of ModeC _ -> ... proves useful.
23:41:13 <ski> *nod*
23:41:54 <dolio> > let map f [] = [] ; map f ((f -> y):(map f -> ys)) = y:ys in map succ [1..20]
23:41:55 <lambdabot>   <no location info>: parse error on input `->'
23:42:37 <dolio> , let map f [] = [] ; map f ((f -> y):(map f -> ys)) = y:ys in map succ [1..20]
23:42:38 <lunabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
23:42:39 <mmorrow> , let map f [] = [] ; map f ((f -> y):(map f -> ys)) = y:ys in map succ [1..20]
23:42:40 <lunabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]
23:42:41 <mmorrow> heh
23:43:25 <mmorrow> cool
23:44:02 <dolio> , let zipWith f ((f -> g):(zipWith f -> h)) ((g -> y):(h -> ys)) = y:ys in zipWith (+) [1..10] [11..20]
23:44:04 <lunabot>  luna: <interactive>:1:54-118: Non-exhaustive patterns in function zipWith
23:44:22 <dolio> , let zipWith _ [] _ = [] ; zipWith _ _ [] = [] ; zipWith f ((f -> g):(zipWith f -> h)) ((g -> y):(h -> ys)) = y:ys in zipWith (+) [1..10] [11..20]
23:44:23 <lunabot>  [12,14,16,18,20,22,24,26,28,30]
23:44:36 <mmorrow> , let foo (fix -> x:xs) = x:xs in foo (0:)
23:44:38 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:45:01 <mmorrow> , let foo (fix -> x:_) = x in foo (0:)
23:45:03 <lunabot>  0
23:46:38 <mmorrow> , let foo ((\f -> foo f) -> x) = x in foo (0:)
23:46:44 <lunabot>  Killed.
23:47:12 <mmorrow> , let foo ((\f -> f (foo f)) -> x) = x in foo (0:)
23:47:13 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:47:15 <mmorrow> heh
23:47:22 <dolio> , let fix (ap id fix -> f) = f in fix (0:)
23:47:23 <lunabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
23:48:18 <mmorrow> , let foo (($ 42) -> 84) = "omg" in foo (*2)
23:48:19 <lunabot>  "omg"
23:48:40 <mmorrow> hmm
23:49:36 <mmorrow> , let foo (random -> (x,g)) = (x::Int) : foo g in foo (mkStdGen 8279847)
23:49:37 <lunabot>  [-445889225,-1536475274,563301184,-1171071119,-35635344,1255721134,186598...
23:49:43 <mmorrow> handay
23:49:54 <trofi^w> , [$ty| id |]
23:49:57 <lunabot>  forall a . a -> a
23:50:33 <mmorrow> , let chunk _ [] = []; chunk n (splitAt n -> (xs,ys)) = xs : chunk n ys in chunk 4 [0..]
23:50:34 <lunabot>  [[0,1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20,21,22,23...
23:50:39 <JoshTriplett> , [$ty [$ty| id |] |]
23:50:40 <lunabot>  luna: parse error on input `|]'
23:51:00 <mmorrow> cool! you can use other matches in the args to supply to the function in the view pattern
23:51:21 <trofi^w> , [$ty| let f :: (id -> 1) -> Int in f |]
23:51:23 <lunabot>  luna: Exception when trying to run compile-time code:
23:51:33 <mmorrow> , let f :: (id -> 1) -> Int in
23:51:34 <lunabot>  luna: parse error on input `)'
23:51:35 <mmorrow> , let f :: (id -> 1) -> Int in f
23:51:36 <lunabot>  luna: The type signature for `f' lacks an accompanying binding
23:51:50 <mmorrow> , [$ty| let f :: (id -> 1) -> Int; f = undefined in f |]
23:51:52 <lunabot>  forall a . (a -> Unit) -> Int
23:51:59 * trofi^w 've just read about ViewPatterns on ghc wiki :]
23:52:11 * mmorrow does the same
23:52:25 <JoshTriplett> Wait, why do "id" and "1" work in a type signature there? :)
23:52:28 <trofi^w> there was an example with list length
23:52:34 <trofi^w> is that example correct?
23:53:09 <mmorrow> JoshTriplett: 'id' is just a typevar that happens to have the same name as a common function, and '1' is generics notation for "Unit" (i believe)
23:53:11 <trofi^w> Josh because i made a stupid thing :]
23:53:31 <JoshTriplett> , let len [] = 0 ; len (_:len -> l) = 1 + l in len "hello"
23:53:32 <lunabot>  luna: Pattern syntax in expression context: _
23:53:42 <JoshTriplett> , let len [] = 0 ; len (_:(len -> l)) = 1 + l in len "hello"
23:53:43 <lunabot>  5
23:54:16 <mmorrow> , [$ty [$ty| id \|] |]
23:54:17 <lunabot>  luna: parse error on input `)'
23:54:23 <mmorrow> , [$ty| [$ty| id \|] |]
23:54:26 <lunabot>  Doc
23:54:40 <JoshTriplett> Fascinating.  "parse error on input `)'" when you have no ) in your input. :)
23:54:43 <mmorrow> unfortunately QQ syntax is done in ghc's lexer..
23:54:59 <JoshTriplett> , let len [] = 0 ; len (tail -> len -> l) = 1 + l in len "hello"
23:55:00 <lunabot>  luna: parse error on input `->'
23:55:05 <mmorrow> JoshTriplett: lunabot wraps everything in "show ("++e++")" for convenience
23:55:05 <JoshTriplett> , let len [] = 0 ; len (tail -> (len -> l)) = 1 + l in len "hello"
23:55:07 <lunabot>  5
23:55:14 <ski> > let (f x) y = x == y in f 2 3
23:55:16 <lambdabot>   False
23:55:50 <mmorrow> (but you can't inject code, since it's just compiling a single expression to a Dynamic, then it does fromDynamic result :: Maybe String, so unless sthe result is a String, nothing comes back
23:55:52 <mmorrow> )
23:56:46 <trofi^w> , [$ty| let len [] = 0 ; len (tail -> (len -> l)) = 1 + l in len |]
23:56:49 <lunabot>  forall a b . Num a => [] b -> a
23:56:50 <mmorrow> , )++show(
23:56:52 <lunabot>  ()()
23:57:05 <trofi^w> :]
23:57:25 <trofi^w> , 2,3
23:57:26 <lunabot>  (2,3)
23:57:28 <JoshTriplett> , ) `const` (undefined
23:57:29 <lunabot>  ()
23:57:32 <mmorrow> hehe
23:58:02 <trofi^w> , ) `seq` 1 `seq` (
23:58:45 <mmorrow> , fromDynamic (toDyn ()) :: Maybe String
23:58:46 <lunabot>  Nothing
23:58:49 <JoshTriplett> , `seq`) (\() -> "hello") (
23:58:50 <lunabot>  luna: parse error on input `)'
23:58:53 <ski> , )(
23:58:54 <lunabot>  luna: Couldn't match expected type `() -> a'
23:59:02 <trofi^w> ,
23:59:02 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
23:59:13 <trofi^w> , ()
23:59:14 <lunabot>  ()
23:59:39 <JoshTriplett> , ) `seq` (\() -> "hello") (
23:59:41 <lunabot>  hello
23:59:50 <JoshTriplett> , ) `seq` (\() -> putStr "hello") (
