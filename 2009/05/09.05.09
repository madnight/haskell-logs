00:05:06 <dolio> Oh man...
00:05:34 <Jig_> Oh dolio
00:06:22 <dan> ksf: haven't used it myself, try tortoiseDarcs
00:07:09 <pumpkin_> dolio: ?
00:07:26 <dolio> I added a stability test to my suite.
00:07:29 <dolio> Merge sort failed.
00:07:34 <pumpkin_> :o
00:07:41 <ksf> argh, windoze-only?
00:07:43 <dolio> The reason: my size-4 optimal sort isn't stable.
00:07:57 <dan> not sure
00:08:00 <pumpkin_> how easily fixable is it?
00:08:00 <dolio> That 40-line function consisting entirely of case statements.
00:08:03 <dan> maybe
00:08:04 <solrize_> @seen snoyberg
00:08:05 <lambdabot> I haven't seen snoyberg.
00:08:05 <pumpkin_> yeah, I remember that
00:08:08 <pumpkin_> :/
00:08:25 <pumpkin_> how did you figure those small optimal sorts out?
00:08:31 <dan> how can i see a list of commands to the lambdabot?
00:08:39 <dolio> I ported them from a C implementation I found.
00:09:13 <ksf> dan, by looking at the current source.
00:12:05 <dan> @slap
00:12:05 <lambdabot> go slap  yourself
00:12:07 <ski> mauke : `showsPrec'
00:12:21 <dan> @slap lambdabot
00:12:21 * lambdabot slaps lambdabot
00:12:26 <pumpkin_> @help
00:12:26 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:12:26 <ski> @src Show
00:12:27 <lambdabot> class  Show a  where
00:12:27 <lambdabot>     showsPrec :: Int -> a -> ShowS
00:12:29 <lambdabot>     show      :: a   -> String
00:12:29 <pumpkin_> @list
00:12:31 <lambdabot>     showList  :: [a] -> ShowS
00:12:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:13:00 <dan> @src Show
00:13:00 <lambdabot> class  Show a  where
00:13:00 <lambdabot>     showsPrec :: Int -> a -> ShowS
00:13:00 <lambdabot>     show      :: a   -> String
00:13:00 <lambdabot>     showList  :: [a] -> ShowS
00:13:34 <dan> @list
00:13:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
00:14:44 <dan> thanks all
00:15:21 <Jig_> what is hte better approach in haskell. lets say you index a matrix like: get (i,j) m and it is out of bounds, throweing an exception si correct here right? rather than using maybe?
00:15:29 <Jig_> since it is an error not a failed lookup
00:16:23 <dan> maybe you can return a datatype which is similar to Maybe: Has Just, Nothing and OutOfBounds constructor
00:16:43 <dan> or Just, EmptyCell and OutOfBounds constructors
00:17:57 <ski> why would a cell be empty ?
00:18:14 <ski> (unless you're storing values of type `Maybe Foo' in the cells ..)
00:18:30 <dan> nm, i just meant you can give back all sorts of exceptions, functionally
00:22:10 <ski> @let at :: Ix i => Array i a -> i -> Maybe a; arr `at` ix | bounds arr `inRange` ix = Just (arr ! ix) | otherwise = Nothing
00:22:11 <lambdabot>  Defined.
00:25:42 <pumpkin_> seems like there should be a way to avoid checking the range twice
00:25:50 <ski> @let graph :: (a -> b) -> (a -> (a,b)); graph f = id &&& f
00:25:52 <lambdabot>  Defined.
00:26:09 <ski> @let cograph :: (a -> b) -> (Either a b -> b); cograph f = f ||| id
00:26:10 <lambdabot>  Defined.
00:26:16 <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ran f = array ran [f `graph` i | i <- range ran]
00:26:17 <lambdabot>  Defined.
00:26:40 <ski> > tabulate (-3,3) even
00:26:41 <lambdabot>   array (-3,3) [(-3,False),(-2,True),(-1,False),(0,True),(1,False),(2,True),(...
00:26:54 <ski> > tabulate (-3,3) even `at` 2
00:26:55 <lambdabot>   Just True
00:26:57 <ski> > tabulate (-3,3) even `at` 3
00:26:59 <lambdabot>   Just False
00:27:00 <ski> > tabulate (-3,3) even `at` 4
00:27:02 <lambdabot>   Nothing
00:27:41 <pumpkin_> what's the role of cograph?
00:27:47 <ski> it's the dual of `graph'
00:28:08 <ski> i'm still looking for a use for it :)
00:28:41 <ski> (there might be a use when one has either an input or a cached output ..)
00:46:42 <ivanm> ski: what's graph meant to be doing?
00:46:47 <ivanm> creating a graph? or reading a graph?
00:49:51 <ski> creating the graph of a function
00:50:15 <ski> the graph of a function from `a' to `b' is a relation between `a' and `b'
00:50:38 <ski> here that relation is rendered as a subset of the product type of `a' and `b'
00:51:00 <ski> and that subset is represented by an inclusion from some other object (here `a')
00:51:02 <ivanm> ski: considering a discrete subset of the domain?
00:51:10 <ski> consider
00:51:15 <ski>   f : A >-> B
00:51:22 <ski> then we want
00:51:41 <ski>   graph f : A >-Rel-> B
00:51:44 <ski> or
00:51:58 <ski>   graph f  =<  A * B
00:52:07 <ski> where `=<' is subset and `*' is cartesian product
00:52:12 <ski> also we could write
00:52:18 <ski>   graph f  :  P (A * B)
00:52:23 <ski> where `P' is powerset
00:52:56 <ski> one can represent a subset of `A * B' as a map from `A * B' to `Bool'
00:53:22 <ski> or as an inclusion function from the "actual subset" into the universe `A * B'
00:53:36 <ski> i.e. the type `a -> (a,b)' in the haskell above
00:53:53 <ski> ivanm : does that explain anything at all ?
00:54:06 <ivanm> heh, was called away so haven't read it
00:54:27 <ivanm> but yes
00:54:40 <ivanm> you're not trying to turn the entire domain/range into the graph ;-)
00:57:00 <ksf> you know you're in trouble when you use block comments to get rid of a type sig.
00:58:01 <ski> how much bigger than the code is your type signature ?
00:59:03 <ski> ivanm : btw, another word for `cograph' is `(function value) table'
00:59:25 <ivanm> heh
01:00:28 <ski> the `Either a b -> b' can be thought of as inducing an equivalence class structure over `Either a b'
01:01:03 <ski> two elements of `Either a b' are in the same equivalence class if the function to `b' maps them to the same element in `b'
01:02:10 <ski> so you can join every element of `a' (included through `Left') to the `b' (included through `Right') that it maps to
01:02:41 <ski> (join by a line/edge, i mean)
01:02:43 <ski> then two elements of `Either a b' are in the same equivalence class iff there is a path from one to the other
01:03:42 <ski> if you line up the elements of `a' in one column and the elements of `b' in another column, then you can draw corresponding lines/edges between the two columns, to indicate how the function maps inputs to outputs
01:04:20 <ski> now it should be apparent that this is not very far from lining up the elements of `a' in one column, and then next to each element, the corresponding element of `b' (i.e. a function value table)
01:05:20 <mmorrow> <pumpkin_> hmm, can I not use bang patterns in lambdas?
01:05:33 <mmorrow> pumpkin_: you can, but you need a space since the parser fails
01:05:42 <pumpkin_> oh
01:05:43 <mmorrow> , (\!x -> x) 42
01:05:44 <lunabot>  luna: parse error on input `->'
01:05:45 <mmorrow> , (\ !x -> x) 42
01:05:46 <lunabot>  42
01:05:50 <pumpkin_> aha, thanks :)
01:05:51 <mmorrow> heh
01:05:54 <mmorrow> :)
01:06:15 <mmorrow> i dunno what it thinks that is..
01:07:44 <ski> , (\(\!)x -> x \! x) (+) 2
01:07:45 <lunabot>  4
01:08:06 <Berengal> > let (\!) x y = x + y in 5 \! 6
01:08:07 <lambdabot>   11
01:09:12 <Berengal> \ is only lambda if it isn't followed by another operator character
01:09:49 * dolio fixes size-3 sort.
01:10:13 <monadic_kid> ! <-- cillit bang
01:11:34 * ski wonders why there doesn't seem to be something like `tabulate' in the array modules
01:12:27 <Berengal> "tabulate"?
01:12:33 <ski> <ski> @let tabulate :: Ix i => (i,i) -> (i -> e) -> Array i e; tabulate ran f = array ran [f `graph` i | i <- range ran]
01:13:05 <ski> > tabulate (-2,2) $ \x -> x*x + 1
01:13:06 <lambdabot>   array (-2,2) [(-2,5),(-1,2),(0,1),(1,2),(2,5)]
01:13:16 <dolio> Yeah, it seems like an obvious function.
01:13:31 <Berengal> Ah, yes
01:13:44 <ski> it's basically an array lambda
01:13:58 <ski> (in the same sense that `(!)' is array application)
01:15:37 <ski> sml :
01:15:38 <ski> - Vector.tabulate;
01:15:38 <ski> val it = fn : int * (int -> 'a) -> 'a vector
01:15:38 <ski> - Array.tabulate;
01:15:38 <ski> val it = fn : int * (int -> 'a) -> 'a array
01:15:47 <ski> ocaml :
01:15:48 <ski> # Array.init;;
01:15:48 <ski> - : int -> (int -> 'a) -> 'a array = <fun>
01:16:03 <ski> (that's where i got the name `tabulate' from)
01:16:22 <Berengal> @type \f -> ap zip (map f) . range
01:16:23 <lambdabot> forall b a. (Ix a) => (a -> b) -> (a, a) -> [(a, b)]
01:18:57 <Berengal> @type \f -> ap array (ap zip (map f) . range)
01:18:59 <lambdabot> forall a b. (Ix a) => (a -> b) -> (a, a) -> Array a b
01:19:11 <Berengal> @pl \f -> ap array (ap zip (map f) . range)
01:19:12 <lambdabot> ap array . (. range) . ap zip . map
01:19:37 <Berengal> @pl flip \f -> ap array (ap zip (map f) . range)
01:19:38 <lambdabot> (line 1, column 6):
01:19:38 <lambdabot> unexpected "\\"
01:19:38 <lambdabot> expecting variable, "(", operator or end of input
01:19:49 <Berengal> @pl flip (\f -> ap array (ap zip (map f) . range))
01:19:50 <lambdabot> flip (ap array . (. range) . ap zip . map)
01:20:00 <Berengal> bah
01:20:45 <Berengal> @pl (\i f -> array i (zip (range i) (map f (range i))))
01:20:45 <lambdabot> liftM2 (.) array (ap ((.) . zip . range) (flip map . range))
01:21:33 <Berengal> Sometimes @pl is not as good as it could've been...
01:22:00 <pumpkin_> quite often :P
01:49:19 <ziman> edwardk, btw, in haskell.vim, around line 69, there should be `silent %s/âˆ§/\&\&/eg' (the ampersands escaped), because an ampersand means `whole match', which doubles âˆ§'s with each save instead of converting them to &&.
01:55:42 <damkor> hi
01:56:17 <Berengal> Hello
01:56:25 <damkor> does anyone have any experience accessing dbus from haskell?
01:56:47 <damkor> I'm using dbus-haskell, but I can't see any changes to the library in the last 18 months
01:57:18 <damkor> plus, I'm having some problems understanding how it is supposed to be used (it lacks proper documentation, AFAIK)
02:00:34 <ksf> does <|> favour its rhs or its lhs, in general? and why is it neither mentioned in Alternative's doc nor in Maybe's?
02:01:06 <Berengal> Isn't <|> associative?
02:01:09 <ksf> (and please, please don't tell me it's undefined. I shall despair.)
02:01:26 <ksf> well, it can't yield two Justs, so no.
02:01:40 <ksf> wait.
02:01:48 <ksf> it _is_ undefined?
02:02:01 <Berengal> (a <|> b) <|> c = a <|> (b <|> c), no?
02:02:47 <zakwilson> If I want to store a http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Integer in a file and speed matters, how should I do it?
02:02:50 <ksf> yes, but I'm asking whether Just a <|> Just b = Just a or Just b
02:02:55 <zakwilson> Hmm... that's not what I wanted
02:03:02 <zakwilson> silly IRC client
02:03:19 <zakwilson> I have a list of lists of Integer that I want to store.
02:03:20 <Berengal> > Just 1 <|> Just 2
02:03:21 <lambdabot>   Just 1
02:03:25 <ksf> just use Integer's binary instance
02:03:45 <ksf> ...now we're getting to the rhetoric part of my question.
02:04:56 <Berengal> Aren't there some Alternative laws?
02:05:44 <zakwilson> Sorry, extreme newbie here. What documentation should I read to make sense of that?
02:07:38 <damkor> zakwilson, I relaly do not see any problem. Here's what I would use unless speed really really mattered a lot: the function show is defined for Integer, and so it is for [Integer] (since if is defined for [a] as long as show is defined for "a")
02:07:55 <damkor> so, by doing something like "putstrLn (show myList)"
02:08:01 <damkor> you would be printing it
02:08:24 <Berengal> ksf: Alternative = Monoid for Applicatives, which means <|> = mappend
02:08:31 <zakwilson> Speed is pretty important. I can already write it to a file that way. I'm looking for something faster.
02:08:38 <damkor> I see
02:08:42 <Berengal> At least that's what I can find by doing a quick search
02:10:34 <Berengal> ksf: Anyway, empty <|> x = x, x <|> empty = x
02:11:03 <zakwilson> Size also matters. A binary file format would be smaller.
02:13:21 <ksf> yes, but I want a guarantee that the lhs is preferred over the rhs, otherwise my semantics are messed up.
02:13:39 <Berengal> Isn't that such a guarantee?
02:14:04 <ksf> the uttermost I have seen right now is
02:14:11 <ksf> > Just 1 <|> Just 2
02:14:12 <lambdabot>   Just 1
02:14:45 <ksf> ...and I dunno if it always works like that.
02:15:13 <Berengal> Why exactly would this mess up your semantics?
02:16:00 <ksf> zakwilson, have a look at Data.Binary. It comes shipped with Integer and List instances.
02:16:22 <ksf> because I have to prefer the value I read from file over its default.
02:19:40 <ski> @src print
02:19:40 <lambdabot> print x = putStrLn (show x)
02:20:19 <Berengal> ksf: Actually, I don't think it is defined at all... The First and Last newtypes over Maybe act completely opposite, which is their point
02:20:34 <zakwilson> ksf: already found it. Thanks.
02:20:45 <monadic_kid> interview with Paul Hudak: http://www.infoq.com/interviews/paul-hudak-haskell-Qcon-SF-08
02:23:29 <ksf> > getLast $ Just 1 <|> Just 2
02:23:30 <lambdabot>   Couldn't match expected type `Last a'
02:23:56 <ksf> > getLast $ (Last $Just 1) <|> (Last $ Just) 2
02:23:57 <lambdabot>   Couldn't match expected type `Maybe a'
02:24:13 <ksf> > getLast $Last$ Just 1 <|> Just 2
02:24:14 <lambdabot>   Just 1
02:24:20 <ksf> > getFirst $Last$ Just 1 <|> Just 2
02:24:21 <lambdabot>   Couldn't match expected type `First a'
02:24:26 <ksf> > getFirst $First$ Just 1 <|> Just 2
02:24:27 <lambdabot>   Just 1
02:24:54 <ksf> ugh. nope, of course not.
02:25:08 <ksf> I don't want to influence the flow behaviour, I want to choose between two.
02:27:58 <ski> what's `First' and `Last' an instance of ?
02:30:00 <ksf> monoid
02:31:17 <ski> > getFirst $ First (Just 1) `mappend` First (Just 2)
02:31:18 <ski> > getLast $ Last (Just 1) `mappend` Last (Just 2)
02:31:18 <lambdabot>   Just 1
02:31:19 <lambdabot>   Just 2
02:31:54 <monadic_kid> :t getFirst
02:31:55 <lambdabot> forall a. First a -> Maybe a
02:32:27 <Berengal> They're not instances of Alternative, but they can be
02:32:42 <ski> so one wonders if `First' vs. `Last' there can be overloaded ..
02:33:06 <ski> @instances-importing Control.Applicative Data.Monoid Applicative
02:33:06 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
02:33:09 <ski> @instances-importing Control.Applicative Data.Monoid Alternative
02:33:10 <lambdabot> Maybe, WrappedMonad m, []
02:33:14 <ski> @instances-importing Control.Applicative Data.Monoid Monoid
02:33:15 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:33:54 <KingKong> http://cacm.acm.org/blogs/blog-cacm/25872-high-performance-computing-whered-the-abstractions-go/fulltext/
02:33:58 <KingKong> que?
02:34:05 <ski> (for just `Monoid' one could use `Dual')
02:34:15 <KingKong> is that guy just blabbering?
02:34:21 <KingKong> we neeed an erlang?
02:34:44 <KingKong> erlang already is a langauge for concurrent programmung using exactly what he complains about, message passing
02:34:54 <monadic_kid> lol
02:35:39 <KingKong> anyway do you think there is a place for soemthing like ruby on rails for parrallel/ distributed coputing?
02:35:51 <KingKong> well i guess so but isnt that what mapreduce,couch db etc tries to do?
02:37:29 <KingKong> Haskell Hellfire - distributed computing for the masses
02:37:44 <KingKong> isnt the monoid lib a good start for this?
02:38:46 <Twey> A Ruby on Rails for parallel/distributed computing... I am imagining a huge application full of magic that runs 4x slower than competitors and scales to a whole three systems
02:38:57 <KingKong> lol
02:39:28 <Cale> But if all you mean by it is a framework for writing distributed applications, then sure, library support is helpful.
02:40:13 <Twey> http://www.google.co.uk/search?q=haskell+distributed
02:40:15 <Cale> However, I think in the longer run, there will be compiler support for distributed data parallelism.
02:40:37 <Cale> At least, that's a really promising sort of idea to try.
02:40:55 <Cale> Currently, they're working on getting it to work nicely for SMP applications.
02:41:37 <Cale> Distributed applications are necessarily harder, because latency becomes a much larger issue.
02:41:45 <mmorrow> <ski> , (\(\!)x -> x \! x) (+) 2
02:41:48 <mmorrow> :o
02:42:06 <Cale> \! reminds me of TeX
02:42:08 <mmorrow> ah yeah, i guess i did know that '\' was a valid symbol char
02:42:26 <mmorrow> (\/) and (/\) for union/intersection i've used
02:42:42 <mmorrow> i just never thought of it as the same char used for a lambda :)
02:46:27 <mmorrow> , let (\!) x y = "\\_ -> " ++ show (x .-> y); infixr 0 \!; (.->) = (+); x = 41 in  (\!x .-> 1) 2
02:46:28 <lunabot>  "\\_ -> 44"
02:46:31 <mmorrow> hah
02:46:57 <mmorrow> , let (\!) x y = x .-> y; infixr 0 \!; (.->) = (+); x = 41 in  (\!x .-> 1) 2
02:46:59 <lunabot>  44
02:47:30 <mmorrow> @let (\!) x y = x .-> y; infixr 0 \!; (.->) = (+)
02:47:31 <lambdabot>  Defined.
02:47:37 <mmorrow> > (.->) 1 1
02:47:38 <lambdabot>   2
02:47:57 <mmorrow> > let x = 0 in (\!x .-> 1) 2
02:47:58 <lambdabot>   3
02:48:25 <mmorrow> > (\x -> (\!x .-> 1)) 2
02:48:26 <lambdabot>       Overlapping instances for Show (a -> a)
02:48:27 <lambdabot>        arising from a use of `s...
02:48:34 <mmorrow> > (\x -> (\!x .-> 1) 2) 3
02:48:35 <lambdabot>   6
02:49:55 <mmorrow> @type (\x -> ((\!x ).->))
02:49:56 <lambdabot> forall a. (Num (a -> a), Num a) => a -> (a -> a) -> a -> a
02:50:26 <mmorrow> @type (\x -> (\!x ) . (.->))
02:50:28 <lambdabot> forall a. (Num a, Num (a -> a)) => (a -> a) -> a -> a -> a
02:53:09 <KingKong> > let (\/) a b = all (== True) [a,b] in (\/) True False
02:53:10 <lambdabot>   False
02:53:15 <KingKong> > let (\/) a b = all (== True) [a,b] in (\/) True True
02:53:16 <lambdabot>   True
02:53:34 <Axman6> @src and
02:53:34 <lambdabot> and   =  foldr (&&) True
02:53:54 <Axman6> hmm
02:57:24 <KingKong> > let (\/) a b = all (== True) [a,b] in True \/ True
02:57:25 <lambdabot>   True
02:57:29 <KingKong> > let (\/) a b = all (== True) [a,b] in True (\/) True
02:57:30 <lambdabot>   Couldn't match expected type `(Bool -> Bool -> Bool) -> Bool -> t'
02:57:36 <KingKong> > let (\/) a b = all (== True) [a,b] in True `(\/)` True
02:57:37 <lambdabot>   <no location info>: parse error on input `('
02:57:41 <KingKong> > let (\/) a b = all (== True) [a,b] in True \/ True
02:57:43 <lambdabot>   True
02:57:47 <KingKong> > let (\/) a b = all (== True) [a,b] in True \/ False
02:57:49 <lambdabot>   False
03:04:30 <KingKong> tuples arent buildable in any way?
03:04:33 <KingKong> how are they defined?
03:05:54 <MyCatVerbs> Not recursively. In GHC, IIRC there's just a big old list of definitions typed out for 2-tuples through 63-tuples or something crazy like that.
03:12:09 <Axman6> oh damn, he left. well anyway, MyCatVerbs http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/src/GHC-Tuple.html#%28%2C%29
03:13:12 <KongKing> im amazed if "Dr" Jon Harrop hasn't mentioned that already?
03:13:16 <Axman6> KongKing: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim/src/GHC-Tuple.html#%28%2C%29
03:13:41 <KongKing> wow thats truly horrible
03:14:27 <KongKing> is it impossible to do with the current typesystem?
03:14:40 <ndm> no, its trivial
03:14:40 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
03:14:46 <ndm> @messages
03:14:47 <lambdabot> gwern asked 1m 2d 12h 42m 3s ago: so I was reading your supero paper and you mentioned ghc's isSpace function had a performance bug. was that ever fixed?
03:15:12 <ndm> KongKing: you define (a,b,c) to be syntactic sugar for (a,(b,c))
03:15:24 <KongKing> like with a list?
03:15:27 <KongKing> cons nil
03:15:29 <KongKing> ?
03:15:31 <ndm> Slightly, but statically
03:15:38 <KongKing> but how do they hold different types?
03:15:45 <KongKing> > (1,2,"3)
03:15:46 <lambdabot>   <no location info>:
03:15:46 <lambdabot>      lexical error in string/character literal at chara...
03:15:48 <ndm> i.e. the type allows a list to be 0..n, a tuple doesn't
03:15:48 <KongKing> > (1,2,"3")
03:15:49 <lambdabot>   (1,2,"3")
03:16:12 <ndm> they already do, you need to be able to define the Two tuple (which we can already do easily), and then it's just syntax sugar
03:16:25 <ndm> it's not a reverse compatible change, but it would have been easy to do at the start
03:16:40 <ndm> plus with current compiler technology, it would be slower
03:17:17 <Berengal> We already have HList
03:18:07 <KongKing> cons t ts = (t,ts)
03:18:08 <KongKing> car (t,ts) = t
03:18:08 <KongKing> cdr (t,ts) = ts
03:18:08 <KongKing> ?
03:18:21 <Berengal> Basically
03:19:30 <KongKing> > let cons t ts = (t,ts); car (t,ts) = t; cdr (t,ts) = ts in car $ cdr $ cons 5 $ cons "4" $ cons 1 ()
03:19:31 <lambdabot>   "4"
03:19:56 <KongKing> > let cons t ts = (t,ts); car (t,ts) = t; cdr (t,ts) = cons 5 $ cons "4" $ cons 1 ()
03:19:57 <lambdabot>   <no location info>: parse error on input `;'
03:20:10 <KongKing> > let cons t ts = (t,ts); car (t,ts) = t; cdr (t,ts) = ts in cons 5 $ cons "4" $ cons 1 ()
03:20:11 <lambdabot>   (5,("4",(1,())))
03:20:56 <KongKing> and a lib for this isn't desirable?
03:21:07 <Berengal> There is one, HList
03:21:10 <KongKing> why does a tuple allow different types but a list doesnt?
03:21:27 <KongKing> on cabal?
03:21:38 <Twey> Because tuples are fixed-size and lists are not
03:21:43 <Pellwurst> hey there... i know that it is possible to list all the functions, that shall be visible, after the name of the module (e.q. module Test(func1, func2) where ...). Is there an equivalent way to list the functions, that shall be hidden?
03:22:00 <Twey> Which allows (in fact, requires) the types of each individual elements in the type of the whole
03:22:00 <Berengal> Pellwurst: import Foo hiding (...)
03:22:31 <Twey> That's an Num n => (n, (String, (n, ()))), for example
03:22:56 <Pellwurst> Berengal: i want to specify the functions within the module itself, not in the module where i import that module (hope you understand :D)
03:22:56 <Twey> This sort of specification can't be done with lists, which are variable-length and to which a new element can be added at any time
03:23:00 <Twey> It's not type-safe
03:23:22 <Berengal> Pellwurst: In that case, simply not list them
03:23:51 <Berengal> Twey: I'm sure induction has something to do with this
03:24:31 <Pellwurst> Berengal: lets say i have got 20 functions in that module and i just want to hide one of them....that means, i have to list all the other 19 functions?
03:24:36 <Twey> Berengal: That's so
03:25:07 <Berengal> Pellwurst: Yes, I'm afraid so
03:25:21 <Pellwurst> Berengal: ok, thx
03:25:50 <Berengal> Pellwurst: however, I'm thinking that once you care enough about which functions you export or not, you care enough to document the module's interface properly by providing an export list
03:26:02 <Berengal> Twey: I wish I knew how...
03:26:20 <KongKing> is it not possible to define nth on a tuple?
03:26:56 <Berengal> KongKing: You could do it in TH, but not otherwise
03:27:23 <Twey> Berengal: Because a list [a] is defined as data [a] = [] | a : [a]
03:27:43 <Twey> The definition is intrinsically inductive
03:28:13 <Berengal> Twey: I'm overcomplicating things in my mind... I should probably go to bed :P
03:28:16 <Twey> And therefore it does not make sense to have more than one type contained within the list unless each new type can somehow be induced from the previous type
03:28:19 <Twey> Heh
03:30:20 <twb> I have a regex question.
03:30:32 <twb> This doesn't compile: mkRegex "^\\\\(input|darcs(?:Command|Environment))\\{(.+)\\}$"
03:31:06 <twb> I want the second (inner) parens to be a grouping operation, but not creating a match thingy.
03:31:41 <twb> I'm guessing I simply can't have this, so need to add _, into my pattern matching of the result of matchRegex.
03:31:54 <twb> (This is Text.Regex, BTW.)
03:33:47 <dan> after finishing reading learn you a haskell and yet another haskell tutorial - how do you recommend i proceed in learning more advanced topics?
03:33:52 <tibbe> @tell dons How efficient is ByteString's uncons. It introduces a Maybe and a pair for every unconsed Word8. I'm using it in a parser that unconses a byte at the time
03:33:53 <lambdabot> Consider it noted.
03:36:18 <KongKing> dan: by writing code
03:41:22 <Twey> twb: That's a Perl extension
03:41:32 <Twey> You can probably do it with Text.Regex.PCRE
03:41:53 <Twey> But it doesn't offer any performance advantages over a match, so you might as well just use _
03:50:26 <Cale> dan: Also, there are many good papers to read about various things, many of which are from Simon Peyton Jones
03:50:35 <twb> Twey: yeah, it was merely for aesthetic reasons I didn't want to generate a match
03:50:41 <twb> i.e. lots of extra ,_'s are ugly
03:50:52 <twb> I'll put up with it, since PCRE is overkill
03:51:03 <Twey> Yeah
03:51:17 <Twey> You can probably do... stuff
03:51:30 <twb> FWIW, I think ?: is implemented in other regex dialects, but not regex(7)
03:51:37 <twb> Other than just PCRE, I mean
03:52:10 <Cale> dan: I suppose it really depends on what aspects you're most interested in learning about after that.
03:52:21 <Twey> ignore 0 = id; ignore n = const . ignore (n - 1)
03:54:27 <twb> Given [x, y, ... z1, z], what's the best way to "chop off" the z, so that I keep *both* pieces?
03:54:57 <twb> i.e. [x, y,..., z] --> ([x, y, ...], z)
03:55:04 <Twey> Oh
03:55:12 <Twey> splitAt (length list - 1)
03:55:13 <Deewiant> init &&& last
03:55:20 <Twey> That works too
03:55:25 <Deewiant> Both traverse the list twice
03:55:27 <EvilRanter> twb, work from the other end of the list, if you can?
03:55:34 <Twey> Twice?
03:55:37 <Twey> splitAt?
03:55:40 <Cale> yeah
03:55:42 <EvilRanter> ?src splitAt
03:55:43 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
03:55:43 <Twey> Oh, for length
03:55:43 <Deewiant> Twey: splitAt once, length once.
03:55:47 <Twey> *nods*
03:55:55 <Twey> I kind of overlooked length for some reason
03:55:55 <twb> I'm writing an NLG function to turn a list of strings into a human-readable version
03:55:57 <Cale> That's not splitAt's real source
03:55:59 <twb> or ["foo", "bar", "baz"] == "foo, bar or baz"
03:56:02 <Deewiant> And if splitAt were implemented like that it'd do it thrice. :-P
03:56:26 <Twey> You can probably do something clever with call-by-need
03:56:29 <KongKing> but i dont get why it isnt possible to implement nth with cdr
03:56:32 <KongKing> cdrs
03:56:35 <Twey> To do it in one pass
03:56:40 <Cale> twb: If the lists are not very long, you don't have to do anything clever, (init xs, last xs) will work.
03:56:50 <KongKing> splitAt isnt so efficient...?
03:57:13 <twb> Cale: I suppose that's the clearest, and clarity is significant.  And the lists are indeed short.
03:57:52 <Cale> It is a little unfortunate that initLast isn't in the List library.
03:58:02 <Twey> IMO â€˜init &&& last $ xsâ€™ is perfectly readable
03:58:15 <Cale> Yeah
03:58:19 <KongKing> how do I get the tyoe of
03:58:20 <KongKing> (f *** g) ~(a, b) = (f a, g b)
03:58:21 <KongKing> ?
03:58:28 <EvilRanter> Cale, but that would encourage people to use more O(n) operations than strictly necessary
03:58:40 <Cale> :t let (f *** g) ~(a, b) = (f a, g b) in (***)
03:58:42 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t, t2) -> (t1, t3)
03:58:49 <Cale> KongKing: ^^ like that
03:58:54 <EvilRanter> ?type let (f *** g) ~(a, b) = (f a, g b) in (***)
03:58:55 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t, t2) -> (t1, t3)
03:59:11 <EvilRanter> glorious stereo!
03:59:14 <Cale> EvilRanter: It's okay, it's already O(n)
03:59:25 <Daimonic> hey everyone
03:59:27 <Cale> ;)
03:59:33 <Cale> Daimonic: hello
04:00:06 <Cale> EvilRanter: Oh, you mean adding that function?
04:01:24 <Cale> Possibly, though there's a more efficient implementation than a separate init and last. So if you really have to do that, it's nice to have it.
04:01:38 <twb> or xs = concat (intersperse ", " (init xs)) ++ " or " ++ last xs
04:01:41 <twb> (plus the base cases)
04:02:14 <EvilRanter> if you're doing init and last a lot, you should switch to Data.Sequence, mind
04:03:26 <Cale> For his purposes, it doesn't even matter. Lists which are human-readably long, you shouldn't have to worry so much about efficiency.
04:03:36 <EvilRanter> true
04:03:37 <twb> Right.
04:04:21 <ski> @let initLast [] = Nothing; initLast (a:as) = Just . swap . runWriter $ loop a as where loop a [] = return a; loop a0 (a1:as) = tell [a0] >> loop a1 as; swap = snd &&& fst
04:04:22 <lambdabot>  Defined.
04:06:14 <ski> @type Writer
04:06:15 <lambdabot> forall a w. (a, w) -> Writer w a
04:06:17 <ski> @type State
04:06:18 <lambdabot> forall s a. (s -> (a, s)) -> State s a
04:06:38 * ski possibly would prefer the `a' to be the right component of the pairs, there
04:06:51 * EvilRanter too
04:07:23 <KongKing> not a type i can annotate wuh
04:07:37 <KongKing> @type let (f *** g) ~(a, b) = (f a, g b)
04:07:38 <lambdabot> <no location info>:
04:07:39 <lambdabot>     not an expression: `let (f *** g) ~(a, b) = (f a, g b)'
04:07:43 <KongKing> ?type let (f *** g) ~(a, b) = (f a, g b)
04:07:44 <lambdabot> <no location info>:
04:07:44 <lambdabot>     not an expression: `let (f *** g) ~(a, b) = (f a, g b)'
04:07:50 <ski> @type let (f *** g) ~(a, b) = (f a, g b) in (***)
04:07:51 <lambdabot> forall t t1 t2 t3. (t -> t1) -> (t2 -> t3) -> (t, t2) -> (t1, t3)
04:08:02 <EvilRanter> KongKing, ?type and @type are exactly the same; you left off the "in (***)"
04:20:50 <ulfdoz> morschn
04:21:09 <KingKong> @type fliå
04:21:10 <lambdabot> lexical error (UTF-8 decoding error)
04:21:11 <KingKong> @type flip
04:21:12 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
04:21:28 <KingKong> @type updateWith
04:21:29 <lambdabot> Not in scope: `updateWith'
04:21:32 <KingKong> @type union
04:21:33 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
04:21:42 <KingKong> > union [1..10] [5..15]
04:21:44 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
04:22:02 <dan> Cale: Thanks!
04:22:49 <Cale> dan: You can find many of his papers linked from his website.
04:22:54 <Cale> http://research.microsoft.com/en-us/people/simonpj/
04:24:20 <KingKong> > let U a b = union a b in [1..10] `U` [5..15]
04:24:21 <lambdabot>   Not in scope: data constructor `U'Not in scope: data constructor `U'
04:24:29 <KingKong> > let u a b = union a b in [1..10] `u` [5..15]
04:24:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
04:28:11 <jpcooper> @hoogle (: [])
04:28:12 <lambdabot> Parse error:
04:28:12 <lambdabot>   --count=20 "(: [])"
04:28:12 <lambdabot>               ^
04:28:17 <jpcooper> @pt (: [])
04:28:17 <lambdabot> Maybe you meant: ft pl
04:28:22 <jpcooper> @pl (: [])
04:28:22 <lambdabot> return
04:28:40 <KingKong> > : []
04:28:41 <lambdabot>   <no location info>: parse error on input `:'
04:28:44 <KingKong> > 1 : []
04:28:46 <lambdabot>   [1]
04:28:53 <KingKong> > (1,) : []
04:28:54 <lambdabot>   <no location info>: parse error on input `)'
04:28:56 <KingKong> > (1,2) : []
04:28:58 <lambdabot>   [(1,2)]
04:29:28 <jpcooper> @pl maybe [] return undefined
04:29:28 <lambdabot> maybe [] return undefined
04:29:34 <jpcooper> @pl maybe [] return (Just 2)
04:29:35 <lambdabot> maybe [] return (Just 2)
04:31:37 <KingKong> > (1,2) : [(3,4)]
04:31:38 <lambdabot>   [(1,2),(3,4)]
04:33:36 <QtPlaty[HireMe]> @type maybe [] return (Just 2)
04:33:37 <lambdabot> forall a. (Num a) => [a]
04:34:06 * QtPlaty[HireMe] looks puzzeled
04:34:43 <jpcooper> @pl unzip . concatMap assocs undefined
04:34:43 <lambdabot> unzip . (assocs =<< undefined)
04:34:48 <Axman6> > maybe [] return (Just 2)
04:34:50 <QtPlaty[HireMe]> oh the maybe monad
04:34:50 <lambdabot>   [2]
04:34:55 <Axman6> > maybe [] return (Nothing)
04:34:55 <KingKong> > (1,2) : [Just (3,4)]
04:34:57 <lambdabot>   Couldn't match expected type `(t, t1)'
04:34:57 <lambdabot>   []
04:35:03 <KingKong> > (Just (1,2)) : [Just (3,4)]
04:35:04 <lambdabot>   [Just (1,2),Just (3,4)]
04:35:13 <KingKong> > catMaybe $ (Just (1,2)) : [Just (3,4)]
04:35:14 <lambdabot>   Not in scope: `catMaybe'
04:35:25 <KingKong> > (Just (1,2)) : [Just (3,4)]
04:35:26 <lambdabot>   [Just (1,2),Just (3,4)]
04:36:29 <KingKong> > (Just (1,2)) : [Just (3,4)]
04:36:31 <lambdabot>   [Just (1,2),Just (3,4)]
04:36:42 <KingKong> > Nothing : [Just (3,4)]
04:36:43 <lambdabot>   [Nothing,Just (3,4)]
04:38:38 <KingKong> how can i pmatch an empty tuple
04:39:09 <monadic_kid> ()
04:48:19 <pastorn> what does the '~' in f ~x = ... mean?
04:48:36 <pastorn> forced strictness is '!', right?
04:48:53 <QtPlaty[HireMe]> pastorn: forced lazyness (iirc)
04:48:58 <pastorn> cool
04:50:04 <ski> `f ~x = ...' is the same as `f x = ...'
04:50:30 <ski> `f ~(x,y) = ...', however, is the same as `f p = ... where (x,y) = p'
04:52:06 <byorgey_> > let  f (x:xs) = x + 3; f [] = 5  in  f []
04:52:07 <lambdabot>   5
04:52:11 <byorgey_> > let  f ~(x:xs) = x + 3; f [] = 5  in  f []
04:52:12 <lambdabot>   mueval: Prelude.read: no parse
04:52:12 <lambdabot>  mueval: UnknownError "GHC reported errors a...
04:52:39 <byorgey_> never mind then...
04:54:24 <ski> , let  f ~(x:xs) = x + 3; f [] = 5  in  f []
04:54:25 <lunabot>  luna: <interactive>:1:54-80: Irrefutable pattern failed for pattern (x : xs)
04:59:41 <KongKing> so what about Factor?
04:59:47 <KongKing> stackbased languages?
05:01:17 <KongKing> isnt that making it easy for the compiler writer rather than theprogrammer?
05:01:55 <KongKing> i guiess there some advantage to that though but factor doesnt seem to be about proofs or static typechecking etc at all, what is the real advantage?
05:03:07 <byorgey> KongKing: no idea, I think you're asking in the wrong channel =)
05:04:07 <pastorn> KongKing: REVERSE POLISH NOTATION
05:04:22 <pastorn> it's the awesomest
05:04:59 <pastorn> or maybe factor doesn't work like that... well, forth does :)
05:06:15 <dolio> @yow!
05:06:15 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU ...
05:06:24 <KongKing> @yow!
05:06:24 <lambdabot> This PIZZA symbolizes my COMPLETE EMOTIONAL RECOVERY!!
05:11:33 <Twey> KongKing: Stack-based languages have a different kind of elegance
05:12:05 <Twey> They're simple for the developer as well as the compiler, and there are certain tasks that look a lot like English in them :-P
05:12:34 <Twey> They offer the same sort of power and expressiveness as Lisps do, although in a completely different way
05:14:32 <KongKing> yeah more naturla to write operator after as you speak
05:14:42 <KongKing> string split count
05:15:32 <Twey> Well, the quintessential example is quantifiers
05:17:12 <Twey> If : seconds 1 * ; : minutes 60 seconds * ; then 5 minutes 30 seconds is equal to 330 seconds is equal to 5.5 minutes
05:17:31 <Twey> (and â€˜5 minutes 30 secondsâ€™ is valid code)
05:18:34 <Nermal> hello, I have basic question. why it's important to write type declaration for functions ?
05:18:58 <Twey> Nermal: It's not, necessarily
05:19:17 <Twey> The compiler can work out the type signatures for almost all functions
05:19:50 <Twey> But type signatures serve as documentation, as well as making error messages more accurate, as a type mismatch will be picked up sooner rather than later
05:20:09 <Nermal> so it changes nothing in my program ?
05:20:46 <Twey> It can do, in some cases
05:20:58 <Twey> But probably not in most
05:21:27 <Twey> Since the types you'd annotate it with are almost certainly the types the compiler will pick up anyway, so long as your program's bug-free
05:21:53 <Saizan> things like "Integral t => t will default to Integer"
05:22:03 <Nermal> should I use it anyway ?
05:22:11 <Twey> Saizan: Did you misplace a quote?  :-P
05:22:22 <Twey> Nermal: Generally, yes, at least for top-level functions
05:22:39 <Twey> It's good style.
05:22:44 <Nermal> ok thanks :)
05:22:59 <Saizan> Nermal: i usually first write the function, load it in ghci and then copy/paste the inferred type above it
05:23:22 <Saizan> which is C-u C-c C-t in emacs' haskell-mode
05:23:22 <Twey> Some people like to do that; others prefer to write the types first
05:23:56 <Twey> You can sketch an outline of your program with only types, using undefined for the functions, and use the compiler to check it makes sense
05:24:03 <Twey> Then fill in the actual implementation details later
05:24:33 <Twey> I don't know if you've ever used UML or a similar system, but I like to think of it as Haskell's equivalent :)
05:25:13 <Nermal> thanks for advice :)
05:27:54 <pastorn> i get this when i try to install Scrap your boilerplate with "cabal install"
05:27:55 <pastorn> Data/Generics.hs:50:7:
05:27:57 <pastorn>     Could not find module `Data.Data':
05:28:32 <pastorn> anyone have any clue as to what i am missing?
05:30:00 <Saizan> pastorn: you're missing a more recent ghc :)
05:30:07 <pastorn> oh shit
05:30:08 <mopped> Ok, I'm trying to download and install a module via Darcs, I've darcs get'd the module, and theres now a folder with the module name - where do I go from here :E
05:30:09 <Saizan> oh, or maybe not
05:30:19 <Saizan> pastorn: which version do you have?
05:30:22 <pastorn> Saizan: i have 6.8.2
05:30:34 <pastorn> why doesn't the latest ubuntu come with 6.10
05:30:42 <pastorn> that's just plain naughty
05:31:02 <Saizan> then yes, the "syb" package is for 6.10+
05:31:30 <Saizan> however its functionality was included in base in earlier versions
05:31:45 <Saizan> mopped: is there a .cabal file?
05:33:41 <mopped> Yeah, I just looked that up and did runhaskell Setup configure, build and install
05:33:57 <mopped> but I still cant Import Text.HTML.Download, even after reopenning ghci - do I need to do anything else?
05:34:39 <Saizan> mopped: move to another directory
05:34:42 <pastorn> Saizan: i wanted to install the array package, but ah, well
05:34:59 <mopped> doh
05:35:00 <mopped> thanks
05:38:25 <mopped> @find liftM
05:38:26 <lambdabot> Not in scope: type variable `liftM'
05:39:30 <ski> @index liftM
05:39:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:42:24 <mopped> Hmm 'There are files missing in the tagsou-0.8 package, try running ghc-pkg check', my package is in that check alright - but how do I fix it? :P
05:46:18 <Saizan> mopped: if files are missing then i think you've to reinstall it
05:46:46 <mopped> Well, There was a problem with rts, so I followed http://www.nabble.com/ghc-pkg-check-problem-in-6.10.2-td22846037.html and now I have no error with ghc-pkg check, but ghci still complains and still reccomends using ghc-pkg check
05:48:56 <Saizan> mopped: ghc-pkg field tagsoup import-dirs will give you a directory
05:49:04 <Saizan> mopped: check that the .hi files are there
05:49:24 <Saizan> mopped: and both an .a and an .o file
05:50:02 <mopped> Nope, only a directiory, an .a and a .o
05:50:39 <Saizan> the .hi files will be in the same position as .hs files in the source tree
05:52:32 <mopped> I moved Setup.hi into there, but now luck - do I have to rename it?
06:02:06 <Saizan> mopped: no, Setup.hi doesn't belong there, however i'd simply try reinstalling tagsoup
06:02:21 <mopped>  yeah I'm trying thatn ow
06:02:26 <Saizan> mopped: pasting the full ghci error might help too
06:04:16 <mopped> http://pastie.org/472976 - same problem after reinstalling
06:06:30 <Saizan> so, is there a Text/HTML/TagSoup/Parser2.hi in the above directory?
06:07:17 <mopped> nope, only a Parser.hi
06:08:55 <Saizan> that's the problem :)
06:09:11 <mopped> aha
06:09:11 <Saizan> is that module listed in the .cabal file? (i'd think so)
06:10:05 <Saizan> ah, no, it isn't
06:10:30 <Saizan> so, if you want to use that module you need to add it to the exposed-modules: section in the .cabal file
06:11:00 <mopped> thanks
06:12:01 <Saizan> mopped: which version of ghc are you using?
06:12:11 <Saizan> that's a quite confusing error message..
06:12:34 <Saizan> ah, 6.10.2
06:13:04 <mopped> What's the latest ghc?
06:13:31 <mopped> mine comes purely from repos, no idea how new it is
06:14:04 <Saizan> well there are the stable and head branches
06:14:14 <Saizan> in the stable they are going to release 6.10.3 soon
06:14:58 <mopped> Unable to load package `bytestring-0.9.1.4`
06:14:59 <Saizan> i wonder how can your ghci connect that module to the tagsoup package though..
06:15:04 <mopped> another one I have to darcs get, i assume
06:15:59 <Saizan> btw, why are you installing everything from repos?
06:16:37 <mopped> laziness I guess? When I first installed my distro I just did pacman -S ghc, although its probably not worth it whe ntrying to fix this stuff
06:16:54 <mopped> http://www.cse.unsw.edu.au/~dons/fps.html no .1.4 here, I wonder what I've done to mess up like this ;S
06:17:06 <Saizan> well, the tarballs from hackage are better in general
06:17:28 <Saizan> however, can you paste the whole error message about bytestring?
06:17:33 <mopped> sure
06:18:32 <Saizan> in general released tarballs are easier to build
06:18:44 <mopped> http://pastie.org/472984 running the same command twice results in two different errors :x
06:19:13 <mopped> Worth uninstalling ghc then? Getting a later version and installing modules via tarballs? or is the GHC stuff not needed
06:21:26 <Saizan> yeah, i wouldn't use a ghc from the repos unless you want to hack on it
06:21:37 <Saizan> get one here: http://www.haskell.org/ghc/download_ghc_6_10_2.html
06:21:43 <rororo> is there any way to generate pretty printers from data definitions?
06:22:09 <Saizan> mopped: oh, wait, by "repos" you meant your distro repos?
06:22:10 <rororo> I'm not sure whether DrIFT can do that from a quick glance on its website
06:22:23 <Saizan> mopped: i understood the developement ones, sorry
06:23:35 <mopped> yeah, distro repos
06:25:01 <Saizan> i don't understand why it errors out on bytestring there, since the symbol seems to come from tagsoup, and bytestring shouldn't depend on it
06:25:27 <Saizan> maybe you've some stale .hi files in your source tree
06:28:57 <mopped> Running it in GHC produces a different error (a lot of them..) http://pastie.org/472989
06:29:13 <dancor_> network uses parsec2.  if i want to use network and parsec3, i should just ignore the build warnings about different versions of parsec?
06:29:27 <mopped> Perhaps it would be best to look for another HTML parser/scraper? Any reccomendations?
06:30:13 <Baughn_> mopped: Tagsoup should be fine, even if your setup apparently is not
06:30:24 <Baughn_> mopped: But you should at least pass ghc --make
06:31:16 <mopped> Indeed that works, wierd, thanks!
06:31:45 <Baughn_> mopped: Not weird at all. You forgot to tell ghc to link in the packages it needs.
06:31:56 <Baughn_> mopped: Same as for getting -lfoo for gcc
06:31:59 <mopped> how do I do that?
06:32:15 <Baughn_> mopped: Cabal likes to pick them manually with -package whatever, but when you're compiling manually you should just use --make
06:32:58 <Baughn_> Which'll look up packages based on what modules you use. Well, it's possible for multiple packages to use the same module names, which would break --make, but I haven't seen it happen yet.
06:33:55 <dancor_> what is the correct way to cabal-install a package which depends on network and parsec3?
06:34:12 <Baughn_> cabal install doesn't work?
06:34:24 <dancor_> it attempts to rebuild network with parsec3
06:34:28 <dancor_> which fails
06:34:53 <Baughn_> I see. You should ask -cafe, I think.
06:35:10 <dcoutts> dancor_: there is no way using the cabal command line tool
06:35:38 <Saizan> compiling network against parsec 3 used to work..
06:35:41 <dcoutts> dancor_: it specifically tries to avoid constructing install plans that use multiple versions of the same package
06:36:19 <dancor_> Saizan: but even darcs version of network imports Text.ParserCombinators.Parsec
06:36:40 <dcoutts> if it were possible to say that network does not expose any of the parsec API then cabal would know enough to know that it's ok to have two versions of parsec in that situation
06:37:04 <mopped> running ghc --make ~/tsr.hs causes it to spout loads of errors the second time Baughn_, any ideas?
06:37:17 <Saizan> dancor_: but parsec3 exports that module http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
06:37:19 <Baughn_> mopped: I'd have to see the errors
06:37:36 <dancor_> Saizan: oh i thought it only did Text.Parsec
06:37:58 <mopped> http://pastie.org/472998
06:38:12 <dancor_> looks like you are right on http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsec
06:40:35 <Saizan> mopped: so you've rm'ed the .hi files in your directory? in that case it looks like there's still something wrong with tagsoup's installation
06:40:39 <dancor_> reinstalling parsec3 solved my problem.  perhaps i had a post-3.0.0 version or something wack
06:40:56 <ldlework> What does the & operator do?
06:41:42 <mopped> Yep, I rm'd the .hi files
06:41:43 <EvilTerran> ldlework, i don't think there is one in the standard libraries, so it'll depend on which module you import it from
06:41:46 <dancor_> ldlework: i only know about (&&), (.&.), (&&&)
06:42:26 <EvilTerran> > let (&) = (,) in 1 & 2 -- seeing as you can define your own operators in haskell
06:42:30 <lambdabot>   (1,2)
06:42:37 <ldlework> oops I'm sorry
06:42:43 <ldlework> I mean the $
06:42:50 <EvilTerran> ah
06:42:52 <EvilTerran> ?src ($)
06:42:52 <lambdabot> f $ x = f x
06:42:53 <ldlework> Actually now that I've got it right
06:42:59 <ldlework> I should probably be able to google it
06:43:07 <ldlework> googling "haskell &" wasn't very usefull
06:43:26 <EvilTerran> google doesn't really do well with punctuation
06:43:38 <mopped> Saizan: How could I install it via Cabal -package or something?
06:43:46 <ldlework> So what does f $ x = f x mean?
06:43:48 <ldlework> :)
06:44:01 <Baughn_> ldlework: It's function applciation, same as ' '
06:44:23 <johh1> it applies f to x
06:44:24 <EvilTerran> ldlework, see http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v%3A%24
06:44:25 <ldlework> I see.
06:44:30 <Baughn_> idnar: Well, with the difference that it's very low precedecce and can be used as a function in itself
06:44:33 <johh1> with $ you need less ( and )
06:44:38 <Baughn_> > map ($ 3) [(+1),(*3)]
06:44:39 <lambdabot>   [4,9]
06:44:52 <Saizan> mopped: well, you'd install cabal-install and then "cabal install tagsoup"
06:44:55 <Baughn_> > map (`id` 3) [(+1),(*3)]
06:44:56 <lambdabot>   [4,9]
06:45:09 <vixey> Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
06:45:38 * bremner has a weird feeling of deja vu
06:45:54 <ldlework> Baughn_, EvilTerran : I come from Python and C#; I'm trying to learn haskell simply so I can configure xmonad!
06:46:05 <ldlework> But haskell is so foreign, I can't simply, fudge it.
06:46:10 <Saizan> that quote looks quite out of character
06:46:17 <Baughn_> ldlework: foo $ bar bar baz = foo (bar bar baz)
06:46:43 <Baughn_> ldlework: You can think of it as inserting parantheses from the $ to the end of the expression
06:47:07 <ldlework> http://ldlework.pastebin.com/m48607053
06:47:50 <ldlework> Thats, xmonad(withUrgencyHook, stdOutUrgencyHook(gnomeConfig))
06:47:50 <ldlework> ?
06:48:21 <ldlework> s/gnomeConfig/gnomeConfig(...)
06:48:38 <johh1> yo don't seperate options in haskell with a ,
06:49:11 <ldlework> johh1, I can assure you I haven't done anything in haskell
06:49:21 <edwardk> @seen ziman
06:49:21 <lambdabot> ziman is in #haskell.cz, #haskell-blah, #haskell-in-depth and #haskell. I last heard ziman speak 5h 1s ago.
06:49:31 <ziman> i'm here :)
06:49:55 <edwardk> ziman: thats one of the reasons why I disabled those rules.
06:50:21 <edwardk> that and typing `intersection` in insert mode before the imap rule fails was silly ;)
06:50:36 <ziman> :)
06:51:06 <ziman> maybe the imap rule could be `isect' :) or you could simply add a âˆ© to the keyboard layout
06:51:32 <mopped> When i've done that, and I'm still getting the same errors Saizan - any more ideas?
06:52:30 <EvilTerran> ldlework, that's "xmonad (withUrgencyHook StdoutUrgencyHook) (gnomeConfig { ... })"
06:52:56 <EvilTerran> ldlework, so withUrgencyHook is getting a single parameter, StdoutUrgencyHook
06:53:21 <ldlework> is gnomeConfig a function being passed those parameters?
06:53:27 <EvilTerran> ldlework, and xmonad is getting two parameters, the result of (withUrgencyHook StdoutUrgencyHook), and the record gnomeConfig with the changes described in the {...}s
06:53:42 <ldlework> I see.
06:53:47 <EvilTerran> gnomeConfig's a record
06:54:14 <ldlework> Why doesn't the second $ work the same as the first?
06:54:22 <EvilTerran> it does
06:54:26 <ldlework> IE pass gnomeRecord to StdoutUrgencyHook
06:54:39 <ldlework> Or pass gnomeRecord to (withUrgencyHook StdoutUrgencyHook)
06:54:51 <Saizan> mopped: you also need to sudo ghc-pkg unregister tagsoup-0.7
06:55:08 <EvilTerran> ah, you're right, sorry
06:55:24 <EvilTerran> ldlework, my bad, it's "xmonad (withUrgencyHook StdoutUrgencyHook (gnomeConfig { ... }))"
06:55:49 <EvilTerran> so withUrgencyHook is getting *two* parameters, StdoutUrgencyHook, and the modified gnomeConfig record
06:56:11 <EvilTerran> and the result of withUrgencyHook is the lone parameter to xmonad
06:56:20 <ldlework> o.o
06:56:40 <mopped> Saizan: How can I specify cabal to install the extra modules, like Parser2?
06:56:46 <EvilTerran> ldlework, "foo $ bar $ baz" = "foo $ (bar $ baz)" = "foo (bar baz)"
06:56:55 <EvilTerran> because $ is right-associative
06:57:09 <Saizan> mopped: you can't, you've to edit the .cabal file like before
06:57:17 <mopped> aha
06:57:47 <Saizan> but Parser2 won't be in the tarball, probably
06:57:53 <mib_9wrv6ri5> How do you print to output from within an "inner" function? Like this: http://www.mibbit.com/pb/HxobuJ   I think it must have to do with monad transformers or some such.
06:58:27 <ldlework> so are you sure its not xmonad(withUrgencyHook, StdoutUrgencyHook(gnomeConfig{...}))
06:58:40 <Saizan> PetRat: you can't do that
06:58:51 <EvilTerran> ldlework, yes
06:58:55 <PetRat> Saizan: what do you do instead?
06:58:56 <ldlework> Alright
06:59:26 <Saizan> PetRat: either you make computation return type IO Int instead of Int and use do-notation in it too
06:59:35 <PetRat> I mean if you discover in the middle of writing code that you would like an "inner" function to print or log something?
06:59:44 <EvilTerran> ldlework, function application is usually left-associative (ie, foo bar baz = (foo bar) baz), and tighter binding than any operator (ie, foo bar $ baz eek = (foo bar) $ (baz eek))
06:59:51 <PetRat> ah IO Int
07:00:19 <ldlework> "so withUrgencyHook is getting *two* parameters, StdoutUrgencyHook, and the modified gnomeConfig record" isn't that xmonad $ withUrgencyHook $ StdoutUrgencyHook gnomeConfig
07:00:35 * ldlework 's mind melts.
07:00:38 <MyCatVerbs> @index unsafeCoerce
07:00:38 <lambdabot> bzzt
07:00:53 <Saizan> PetRat: you could just return what to log and let the caller print it
07:01:31 <Saizan> ldlework: no, that gives an argument to StdoutUrgencyHook
07:01:44 <EvilTerran> ldlework, no, that'd be equivalent to "xmonad (withUrgencyHook (StdoutUrgencyHook gnomeConfig{...}))", so you'd be trying to pass the modified gnomeConfig to StdoutUrgencyHook
07:04:31 <PetRat> Saizan: this seems to work (the second option) http://www.mibbit.com/pb/S2qa9M
07:05:17 <ldlework> its like to do f(f(f(f(f())))))) you have to alternate between '$' and ' ' for function calling because of how they work
07:05:32 <Saizan> PetRat: it works but it's bad style to mix computations with Input/Output
07:05:47 <Saizan> PetRat: if it's just for debugging you can use Debug.Trace
07:06:14 <Saizan> ldlework: you don't have to
07:06:20 <EvilTerran> ldlework, no, you could write that as "f $ f $ f $ f $ f $ ()" if you wanted
07:06:46 <ldlework> ah because its right associative?
07:06:51 <PetRat> Saizan: is the documentation for Debug.Trace self-evident?
07:06:54 <ldlework> the f $ () happens first
07:06:59 <EvilTerran> yes
07:07:08 * SamB would suggest ntimes 5 f
07:07:19 <SamB> or something like that ...
07:07:27 <SamB> maybe ntimes f 5
07:07:52 <EvilTerran> ldlework, well, in terms of parsing, yes
07:08:17 <Saizan> PetRat: maybe http://haskell.org/ghc/docs/latest/html/libraries/base/Debug-Trace.html , ask here if it's not :)
07:09:20 <SamB> of course, that's kinda useless if the arg is ()
07:10:05 <ldlework> SamB, I'm more trying to parse the language
07:10:07 <ldlework> than write it
07:10:08 <ldlework> heh
07:10:21 <EvilTerran> SamB, while "f $ f $ f $ f $ f $ ()" etc could be useful if f is suitably polymorphic
07:10:48 <ski> > f $ f $ f $ f $ f $ () where f = (:[])
07:10:50 <lambdabot>   [[[[[()]]]]]
07:10:52 <SamB> EvilTerran: indeed
07:11:08 <SamB> that's what I meant
07:11:18 <PetRat> Saizan: yup, seems pretty obvious; this works: \http://www.mibbit.com/pb/Rt0P0t
07:11:54 <mopped> ok, I have a list coming back [TagText "blah", TagOpen "br", TagClose "br", TagText "foo"..], how can I extract all TagTexts? filter (\TagText x -> x)?
07:12:05 <SamB> ... since when can you lambda-bind with a URL as the variable name?
07:12:45 <Saizan> mopped: [t | t@TagText{} <- yourlist]
07:13:03 <EvilTerran> mopped, [x | TagText x <- yourList] would do it if you just want their contents
07:13:04 <Saizan> or [text | TagText text <- yourlist]
07:13:37 <mopped> cheers
07:14:47 <EvilTerran> ldlework, the other thing relevant there is the record syntax; "foo { bar = baz, ... }" means "the record 'foo', except with the field 'bar' set to the value 'baz', etc"
07:15:21 <EvilTerran> ldlework, and, confusingly, "foo bar { ... }" parses as "foo (bar {...})", even though "foo bar baz" would parse as "(foo bar) baz"
07:15:34 <edwardk> In many ways I think haskell succeeds because its crappy record support has forced everyone to use the rest of the language ;)
07:16:15 <SamB> edwardk: lol
07:16:19 <EvilTerran> ldlework, ie, the record update syntax binds tighter than function application
07:17:42 <Saizan> eh, yeah, those ocaml kids spoiled by their rows! get off my lawn!
07:17:55 <ldlework> Saizan, that was the theme of the last Pyweek
07:17:59 <ldlework> 'get off my lawn'
07:19:05 <ski> > (,) 17 Node {rootLabel = 42, subForest = []}
07:19:06 <lambdabot>   (17,Node {rootLabel = 42, subForest = []})
07:19:16 <mopped> @src split 'b' "abcbdbebf"
07:19:17 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:19:41 <mopped> How can you split in haskell ;x
07:20:17 <mopped> @src sections
07:20:17 <lambdabot> Source not found. You speak an infinite deal of nothing
07:20:28 <johh1> http://hackage.haskell.org/packages/archive/split/0.1.1/doc/html/Data-List-Split.html
07:20:36 <Saizan> mopped: for such queries it's better to use hoogle or hayoo
07:20:39 <mopped> > split 'b' "abcdbebfb"
07:20:40 <lambdabot>   Couldn't match expected type `[Char] -> t'
07:20:44 <mopped> ok
07:20:47 <EvilTerran> mopped, span (or break) and recursion is the usual way of doing it
07:20:50 * ski hadn't noticed that precedence detail ..
07:21:02 <Saizan> but yeah, see johh1 link
07:21:05 <EvilTerran> or the Data.List.Split module on hackage
07:26:27 <carl_> has anyone here worked with HDBC?
07:32:13 <EvilTerran> it seems not
07:34:11 <gwern> @hoogle Maybe a -> (a -> a) -> a
07:34:12 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
07:34:12 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
07:34:12 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
07:34:41 <gwern> > maybe "" (\a -> " " ++ a ++ " ") (Just "%")
07:34:42 <lambdabot>   " % "
07:34:51 <gwern> > maybe "" (\a -> " " ++ a ++ " ") (Nothing)
07:34:52 <lambdabot>   ""
07:34:52 <EvilTerran> gwern, er, how would a function of that type work?
07:35:19 <mopped> I've got Data.String, but I don't have Data.String.Utils - is that something I have to cabal install
07:35:23 <EvilTerran> if the Maybe a is Nothing, you don't have any (:: a)s to work with
07:35:42 <gwern> EvilTerran: the idea is, given a Maybe a, fallthrough to some constant value if Nothing, else run some function on the a inside the Just
07:35:52 <gwern> the type sig was incomplete so I could see what else there was
07:36:27 <EvilTerran> ah. yeah, that's maybe
07:36:45 <gwern> 'maybe' certainly does seem to work for my need
07:37:42 <gwern> strange that it's in prelude though
07:37:49 <gwern> you'd think it'd be in Data.Maybe
07:37:50 <twb> Doesn't _|_ mean "impossible, abort, explode"?
07:37:59 <twb> ghc tells me it's a parse error.
07:38:09 <EvilTerran> twb, it's not haskell syntax, it's pseudocode
07:38:19 <twb> Bah.
07:38:28 <twb> Is there a real equivalent?
07:38:28 <EvilTerran> the haskell syntax equivalent is either (undefined) or (error "some descriptive text")
07:38:31 <gwern> you want 'undefined'
07:38:34 <twb> Righto
07:38:46 <EvilTerran> > error "I accidentally the whole expression."
07:38:47 <lambdabot>   * Exception: I accidentally the whole expression.
07:39:15 <twb> Strictly speaking the error is "this case is impossible; it exists to keep the type checker quiet"
07:40:13 <EvilTerran> error "The impossible happened!"
07:40:13 <EvilTerran> :P
07:40:20 <EvilTerran> ?quote ghc impossible
07:40:21 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
07:41:06 <wjt> @ty \x f -> case x of { Just y -> f y; Nothing -> fix f }
07:41:07 <lambdabot> forall t. Maybe t -> (t -> t) -> t
07:45:29 <pastorn> how good is haskell support under free bsd?
07:45:39 <pastorn> better/worse than ubuntu/
07:45:41 <pastorn> ?
07:45:50 <Zao> Quite fine, last I used it.
07:45:53 <Zao> Ran xmonad at least :)
07:45:56 * pastorn just broke APT in a bad way and is about to migrate
07:46:06 <Zao> Was in the 6.8.1 days though.
07:46:23 <pastorn> Zao: cool, thanks
07:48:25 <Zao> pastorn: Judging by the makefile in ports, it's only for arches i386/amd64, and is 6.8.3 on this box.
07:48:43 <Zao> You can of course install that and most probably build a current yourself.
07:48:58 <pastorn> Zao: yeah
07:50:03 <Zao> Bah, old ports tree.
07:50:52 <carl_> join postgresql
07:50:54 <sayyestolife> hey
07:50:58 <carl_> lol whoops
07:51:46 <sayyestolife> I'm reading a book here and I can't seem to understand the difference between iterative processsolving and recurse processsolving (loosely translated from swedish to english)
07:51:54 <sayyestolife> recursive*
07:52:00 <twb> pastorn: if you want help unbreaking apt, you should talk to your vendor
07:52:18 <twb> Certainly on Debian it's very difficult to irrevocably break apt.
07:52:39 <pastorn> twb: ubuntu 9.04 upgraded from 8.10
07:52:50 <wh1t3> sayyestolife, iterative would be a loop or something, recursively would be a function calling itself
07:52:58 <pastorn> twb: seriously, this is the fifth time i broke apt when using ubuntu
07:53:10 <pastorn> so FUK DIZ SHIT
07:53:14 <jnj> Hello. Can someone either explain to me what <+> does (assuming it's a standard Haskell thing) or point me to where I might read about it? Thanks.
07:53:20 * pastorn is defecting
07:53:27 <Botje> jnj: in what context?
07:53:27 <sayyestolife> wh1t3: hmm, this book is about common lisp and as far as I know there are no loops there?
07:53:37 <wh1t3> i sont know lisp :)
07:53:39 <Botje> @hoogle (<+>)
07:53:40 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
07:53:40 <lambdabot> Text.PrettyPrint.HughesPJ (<+>) :: Doc -> Doc -> Doc
07:53:40 <lambdabot> Language.Haskell.TH.PprLib (<+>) :: Doc -> Doc -> Doc
07:53:50 <wh1t3> s/sont/dont
07:53:50 <Botje> there's a number of different interpretations for <+>
07:53:53 <Axman6> jnj: what's the context?
07:53:57 <twb> pastorn: I was simply pointing out that if you wanted to, you could probably fix your system.  I'm not going to try to convince you that this is a productive use of your time.
07:54:07 <Botje> if it's in a prettyprinter: it seperates two things with a space
07:54:26 <jnj> Aha, well it's used in my xmonad config file, which is Haskell. The actual line is "myManageHook = manageDocks <+> manageHook defaultConfig". But I cannot say what the different variables are.
07:54:42 <twb> sayyestolife: Common Lisp has more loops than any other language: LOOP, ITERATE, DOLOOP, MAPC, MAPCAR, and a few others that I have forgotten.
07:54:43 <wjt> <+> is defined by xmonad
07:55:04 <Botje> twb: DOTIMES :)
07:55:18 <twb> sayyestolife: plus, of course, recursive invocation coupled with implied tail-call optimization (TCO), but IIRC CL implementations are not *required* to TCO :-)
07:55:35 <Axman6> lord help you if you want do do any parsing in your Xmonad config... >_>
07:55:36 <jnj> Ah, thanks wjt. I will look at xmonad's docs then. I assumed it was a standard Haskell thing. Thanks.
07:56:01 <sayyestolife> twb ahh.. I believe that is it! (The recursive invocation with TCO)
07:56:03 <pastorn> twb: thank you for not doing that :) i'm getting tired of breaking APT...
07:56:15 <twb> sayyestolife: it is very easy to get a... skewed impression of Lisp from an academic textbook, because they are teaching language design or algorithm design, rather than teaching Lisp itself.
07:57:06 <twb> jnj: you could open a ghci, import the xmonad module(s) then interrogate the interpreter as to what <+> does.
07:57:09 <sayyestolife> twb I guess so
07:57:45 <twb> sayyestolife: incidentally, #scheme is a very good channel if you are actually studying Scheme (which is sometimes referred to as "a Lisp", to be confusing :-)
07:58:09 <twb> Rather, using Scheme while studying computer science.
07:59:27 <twb> jnj: I also recently discovered "cabal-install hoogle; hoogle [--info] foo", which is Super Nice, if only for getting the URL of the haddock docs.
08:00:39 <jnj> twb: Thanks for the help, seems it's "mappend".
08:01:07 <sayyestolife> twb well, I'm only actually preparing for a course I'm taking this autumn
08:01:52 <SamB> jnj: I'm always getting that mixed with mplus
08:02:34 <twb> We should have a seminar on how to not choose stupid names for your Haskell functions.
08:03:12 <twb> Within "mangleArgs" I have a "cmp", "xor" and "gank".
08:03:25 <lightstep> how can i install ghc 6.10 on ubuntu 9.04? the version of ghc6 here is 6.8.2
08:03:56 <twb> lightstep: I doubt Ubuntu supports GHC at all, i.e. "you get what you're given".
08:03:59 <wh1t3> download the source and compile?
08:04:04 <jbjohns> I'm trying to install the Happs tutorial on windows via cabal but it bombs on a dependency on the unix module.
08:04:08 <twb> http://packages.ubuntu.com/search?keywords=ghc6
08:04:36 <jbjohns> Anyone seen this?  I was looking into Haskell because I was expecting it to be pretty platform independent
08:04:38 <twb> Oh, it appears that GHC 6.10 is already available in karmic (jaunty+1).
08:05:16 <lightstep> so is compiling the only option? probably the debian package won't work
08:05:30 <ski> sayyestolife : yes, if you do tail-recursive calls, then that's an example of an iterative process. if you still need to do something after the recursive call, though, then it's not an iterative (but a recursive) process
08:05:40 <twb> lightstep: you either need to run the work-in-progress next release of Ubuntu, or talk to the Ubuntu people about how best to backport ghc 6.10 from karmic.  Or, as wh1t3 says, you can just compile the whole thing yourself, and forego all Ubuntu integration.
08:05:45 <pejo> jbjohns, many packages depend on the unix package. Not sure how many of them that are actual dependencies.
08:05:58 <ski> (sayyestolife : but see lazy productive functions, too)
08:06:11 <pejo> jbjohns, are you installing whatever they renamed Happs to?
08:06:17 <jbjohns> pejo: It fails on using RunProcess
08:06:17 <twb> Ubuntu packages in the universe category generally *are* the Debian packages, just recompiled, or with minor changes.
08:06:42 <twb> But you certainly shouldn't just install Debian binary packages on an Ubuntu system, or vice versa.
08:07:56 <Zao> Installing packages from another distro or release without knowing exactly what you're doing has awesome results.
08:07:58 <lightstep> i'm fine with compiling 6.10.3, but i don't want to compile all the following versions. oh well, sucks for me
08:08:08 <Zao> Like say, replacing your libc, boot gunk and toolchains :)
08:08:35 <twb> Zao: even if you *do* know what you're doing, it's easy to cock up.
08:09:02 <wh1t3> you can simply use alien to port deb packages, can you not? :/
08:09:25 <twb> wh1t3: only if you want the absolute worst case
08:09:30 <wh1t3> port is probably a poort choice of words
08:09:37 <wh1t3> hmmm, never had any problems with it
08:09:42 * EvilRanter stabs EvilTerran
08:09:43 <wh1t3> then again, hardly ever use it
08:09:44 <twb> wh1t3: for packaging, alien is like type coercion.
08:10:04 <Zao> alien can't rebuild the binaries in the package to fit your particular ecosystem.
08:10:17 <Zao> libc, editline, bazillion library versions, whatnot.
08:10:28 <wh1t3> hmmm, that makes sense
08:10:29 <twb> lightstep: the, uh, good news is that if you're using cabal-install, that will fight with any Haskell packages you install via apt-get anyway (due to stuff like parsec 3 being in Ubuntu).  Sigh.
08:11:06 <lightstep> twb, i didn't plan on installing anything except for ghc6
08:11:10 <twb> alien is really only intended as a last resort when dealing with jackasses proprietary vendors that only provide RHEL2 binary RPMs.
08:11:18 <twb> lightstep: righto.
08:11:50 <wh1t3> normally i compile from source before resorting to alien
08:12:17 <lightstep> so, should i take the version with or without libtinfo.so? (or what is that?)
08:12:56 <twb> I would normally just roll a stub .deb package.
08:13:04 <twb> Assuming that I actually *had* access to the source.
08:13:32 <twb> dh(1) in debhelper 7 -- much love, Joey!
08:14:57 <KingKong> so are arrows a concept in category theory or "just" some operators defined for haskell?
08:15:23 <KingKong> cna they be mapped to some concept in category theory?
08:15:24 <ski> both
08:16:08 <ski> it's meant to correpond to morphisms in a category with some not clearly (beforehand) specified structure
08:16:57 <ski> istr people then identified what structure corresponded to the axioms stated for arrows (plus ones inherent from using haskell)
08:17:08 <ski> (but i don't recall what that structure was)
08:17:33 <KingKong> is (->) an arrow
08:17:41 <KingKong> (->) means imples normally?
08:17:59 <ski> the type constructor `(->)' in haskell forms a haskell arrow, yes
08:18:00 <EvilTerran> it's an instance of Arrow
08:18:30 <EvilTerran> in haskell, it doesn't normally mean "implies"; "to" would be closer
08:18:51 <EvilTerran> f :: a -> b -- f has type "a to b"
08:19:16 <ski> @djinn (a0 -> a1,b0 -> b1) -> ((a0,b0) -> (a1,b1))
08:19:16 <lambdabot> f (a, b) (c, d) = (a c, b d)
08:19:20 <EvilTerran> (\x -> ...) -- "function from x to ..."
08:19:40 <twb> -> in Haskell is \mapsto, IMO
08:19:59 <ski> you can read it as "implies" using the Curry-Howard(-Lambek) correspondence
08:20:22 <ski> (twb : the one in `\x -> ...', sure)
08:24:03 <EvilTerran> KingKong, the haskell Arrow class basically covers types which include functions, but may have other values in them as well
08:24:13 <EvilTerran> so (->) is one
08:24:36 <damkor> hi
08:24:47 <damkor> does anyone have any experience playing with dbus and haskell?
08:24:56 <EvilTerran> newtype Kleisli m a b = Kleisli (a -> m b) -- Monad m => Kleisli m would be another
08:25:11 <kerlo> ski: I don't suppose "Curry-Howard-Lambek" means now there's a third thing they're isomorphic to.
08:25:31 <ski> s/=> Kleisli m/=> Arrow (Kleisli m)/
08:25:51 <ski> kerlo : cartesian closed categories, how did you guess ?
08:26:45 <kerlo> ski: I'm a fan of saying that programs are "the Curry side" and logic is "the Howard side". (Or was it the other way around?)
08:26:46 <EvilTerran> ski, ah, true, i fudged the syntax a bit there
08:27:10 <kerlo> Adding another name would break that unless you also had a third isomorphic.
08:27:14 <EvilTerran> i guess that makes CCCs the "lambek side"
08:29:50 <RLa> i defined new data type and made it instance of Monad class and implemented required methods, how do i test my data type and those methods?
08:30:20 <monadic_kid> RLa: see if they follow the axiomatic definitions of bind and return
08:30:31 <monadic_kid> RLa: see if the rules adhere
08:30:32 <RLa> see?
08:30:51 <monadic_kid> RLa: like a test case, see if the monads hold
08:30:51 <RLa> it's easy to verify them, but i actually want to run the damn code
08:31:06 <monadic_kid> *monad rules
08:31:26 <kerlo> Generally, you test something by writing something that uses every feature and seeing whether it behaves as expected.
08:31:29 <idnar> quickcheck can be helpful for that kind of testing
08:32:02 <RLa> i want to run code in ghci
08:32:16 <RLa> i haven't programmed haskell before
08:32:39 <kerlo> Well then, save your code into a .hs file and open it in GHCi.
08:33:02 <monadic_kid> RLa: make up some atomic example and see if your implementation successed the laws http://www.haskell.org/haskellwiki/Monad_Laws
08:33:32 <RLa> ok, i figured it out
08:33:49 <RLa> (return 3) :: (MyTypeName Int)
08:34:21 <RLa> this will actually use return function of my monad type
08:34:22 <ski> yes (the brackets there are not needed)
08:34:28 <monadic_kid> RLa: return a >>= f == f a
08:34:44 <monadic_kid> RLa: m >>= return == m
08:35:03 <RLa> i do not understand why each tutorial fails to point out how to run code at all
08:35:26 <EvilTerran> RLa, that's usually assumed knowledge by the time you get on to monads
08:35:43 <RLa> that's very bad assumption
08:35:46 <EvilTerran> as it tends to be covered by the more basic tutorials
08:35:59 <NEEDMOAR> Is there something like an untyped haskell?
08:36:00 <EvilTerran> the ones that'd generally be helpful in understanding monads
08:36:04 <RLa> well, more basic tutorials do not cover monads
08:36:30 <Axman6> RLa: read lyah:
08:36:34 <Axman6> @where lyah
08:36:34 <lambdabot> www.learnyouahaskell.com
08:36:37 <Axman6> ^^
08:36:38 <monadic_kid> RLa: did you say you made your own type that is a monad instance?
08:36:47 <EvilTerran> RLa, indeed not. that's because an understanding of some other parts of haskell would make learning about monads a lot easier.
08:36:48 <RLa> yes
08:37:15 <monadic_kid> RLa: you have written monadic code before doing this?
08:37:36 <RLa> i haven't read anything about type classes in haskell, that's what i'm probably missing
08:37:40 <RLa> monadic_kid, no
08:38:01 <EvilTerran> RLa, yes, an understanding of typeclasses would help. and would tend to be covered in the same sort of tutorial that deals with things like running code.
08:38:50 <monadic_kid> if you're monads don't obey the monad laws given, (you can write this as a test case) then they are not really monads at all
08:38:53 <RLa> well, i have used monadic constructs (do) but i haven't written any monad before
08:39:35 <monadic_kid> RLa: as long as your monads follow the monad rules it should eb no difference in using them explicitly or with do, thats kind of the point
08:40:20 <RLa> i prefer >>= over do notations, it's too confusing
08:40:36 <beelsebob> I prever =<< over do notation
08:40:46 <monadic_kid> i prefer >>=/>> when I don want to deal with free varibles
08:40:53 <monadic_kid> *when i don't want to deal
08:42:34 <RLa> =<< is just >>= with aguments swapped?
08:42:41 <monadic_kid> yeah
08:43:01 <monadic_kid> instead of f of g its g of f
08:43:20 <ski> NEEDMOAR : Writing a pure functional lazy call-by-name compiler <http://blog.sigfpe.com/2006/05/writing-pure-functional-lazy-call-by.html>,Monads Without Types <http://blog.sigfpe.com/2006/05/monads-without-types.html>
08:43:52 <monadic_kid> :t (=<<)
08:43:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:45:46 <monadic_kid> :t (>=>)
08:45:47 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:46:08 <monadic_kid> :t (<=<)
08:46:09 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
08:47:31 <NEEDMOAR> ski: thank you, let's see.
08:48:21 <adityam> @pl f a b c = s b c a
08:48:21 <lambdabot> f = flip (flip . s)
08:49:07 <adityam> @pl foldr . (\a b c -> s b c a)
08:49:07 <lambdabot> foldr . flip (flip . s)
08:52:24 <younder> Why does "break odd [1..10]" return ([], [1,2..10]) instead of ([2,4..],[1,3..])?
08:53:06 <younder> @break odd [1..10]
08:53:06 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
08:53:48 <monadic_kid> > break odd [1..10]
08:53:49 <Lemmih> > partition odd [1..10]
08:53:50 <lambdabot>   ([],[1,2,3,4,5,6,7,8,9,10])
08:53:50 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
08:54:12 <Lemmih> > break isSpace "Hello world"
08:54:13 <lambdabot>   ("Hello"," world")
08:55:08 <Jedai> younder: Because break split a list in two _sequential_ part at the first point where the predicate is true...
08:55:30 <Jedai> younder: As Lemmih showed, you want partition, not break
08:55:46 <younder> Jedai: In what module?
08:56:12 <Jedai> younder: partition is in Data.List
08:56:23 <younder> thanks.
08:56:34 * monadic_kid is going crazy with the birls hooting all day today
08:57:10 <Jedai> younder: You should use hoogle for those kind of questions
08:57:16 <Jedai> @hoogle partition
08:57:17 <lambdabot> Data.ByteString partition :: (Word8 -> Bool) -> ByteString -> (ByteString, ByteString)
08:57:17 <lambdabot> Data.IntMap partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
08:57:17 <lambdabot> Data.IntSet partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
08:57:32 <Jedai> @more
08:57:48 <Jedai> Ok, the webpage hoogle...
09:01:24 <adityam> @pl f s l = g s (h l)
09:01:24 <lambdabot> f = (. h) . g
09:03:30 <dan> recommendation: Read the article about type classes in the last issue of "The Monad.Reader". It's great.
09:04:47 <adityam> @pl (\s n -> addSchedule s (addVisit n))
09:04:48 <lambdabot> (. addVisit) . addSchedule
09:04:58 <vixey> don't use @pl
09:05:02 <vixey> it makes code a lot wors
09:05:31 <adityam> I know, I am just trying to understand if there are simple patterns that I am missing :-)
09:08:54 <jbjohns> dan: issues 13?
09:11:04 <ski> > f Node {rootLabel = 42, subForest = []}  where f Node {rootLabel = x, subForest = xs} = (x,xs)
09:11:06 <lambdabot>   (42,[])
09:11:49 <ski> (.. and here i've always bracketed such argument patterns ..)
09:12:03 <pumpkin_> wow, happy produces a lot of warnings when I compile it
09:12:14 <monadic_kid> jbjohns: i'm guessing he/she means the typeclassopedia so yeah
09:12:40 <monadic_kid> which is awesome
09:12:49 <monadic_kid> resource
09:13:36 <Boxo> why is (/) of type (Fractional a) => a -> a-> a instead of (Num a, Fractional b) => a -> a -> b ?
09:13:53 <EvilTerran> > (\(,,) {} -> "another interesting trick involving record syntax") (1,2,3)
09:13:54 <lambdabot>   "another interesting trick involving record syntax"
09:14:27 <jmcarthur> EvilTerran: what the heck?!
09:14:35 <EvilTerran> the pattern Constructor{} matches that constructor with the appropriate number of arguments, regardless of whether it was defined in record syntax
09:14:38 <ski> > f Node {rootLabel = 42, subForest = []}  where f ~ t @ Node {rootLabel = x, subForest = xs} = t {subForest = [t {rootLabel = 17}]}
09:14:40 <lambdabot>   Node {rootLabel = 42, subForest = [Node {rootLabel = 17, subForest = []}]}
09:14:42 <ski> hehe
09:14:58 <jmcarthur> oh, right, doing that with tuples just looked funny
09:15:26 <eu-prleu-peupeu> haskleee!
09:15:34 * pumpkin_ facepalms
09:15:54 <EvilTerran> > case Just 1 of Nothing{} -> "foo"; Just{} -> "bar"
09:15:56 <lambdabot>   "bar"
09:15:56 <hatds> Boxo: hmmm ... Ratio requires Integral right?
09:16:00 <pumpkin_> yeah
09:16:40 <hatds> ah nvm I'm confusing Fractional with Ratio
09:16:41 <EvilTerran> Boxo, i don't think you can convert a Num to a Fractional in general
09:16:44 <Boxo> hatds: I dont understand
09:16:51 <Boxo> oh
09:16:53 <pumpkin_> Boxo: because in general it's convenient to have the operators take the same parameter on both sides
09:17:34 <Boxo> I just think it makes sense to do (1::Int)/(2::Int)
09:17:48 <Boxo> but you cant
09:18:15 <adamvo> > 1 `div` 2
09:18:17 <lambdabot>   0
09:18:17 <idnar> EvilTerran: what's with the {} ?
09:18:34 <idnar> oh, I see
09:18:34 <EvilTerran> idnar, it's a quirk of the record pattern syntax
09:18:42 <idnar> fun stuff
09:19:02 <pumpkin_> does the Nothing need the {} too?
09:19:05 <Boxo> I just think it makes sense to have something that does (1::Int)/(2::Int) = 0.5
09:19:23 <adamvo> @type (/)
09:19:24 <lambdabot> forall a. (Fractional a) => a -> a -> a
09:20:23 <hatds> problem is that 'Num' doesn't mean you are a subset of integers, reals or even complex
09:20:40 <adamvo> @type (/) `on` fromIntegral
09:20:41 <lambdabot> forall b a. (Integral a, Fractional b) => a -> a -> b
09:21:07 <hatds> if 'a' and 'b' are matrices, what would a/b :: Rational be?
09:21:31 <pumpkin_> yeah, the main problem is that Num sucks
09:21:47 <hatds> not that bad
09:21:52 <pumpkin_> I hate it :P
09:22:20 <Boxo> didn't know that, but is there some way to do (1::Int)/(2::Int) = 0.5
09:22:33 <pumpkin_> you use `div` instead
09:22:40 <opqdonut> that doesn't give 0.5
09:22:42 <adamvo> > fromIntegral 1 / fromIntegral 2
09:22:44 <hatds> div = integer division
09:22:44 <lambdabot>   0.5
09:22:44 <pumpkin_> oh, yeah
09:22:45 <opqdonut> Boxo: use fromIntegral
09:22:46 <EvilTerran> pumpkin_, no, it's something you can do in any pattern individually
09:23:03 <adamvo> > 1 % 2 -- why not this?
09:23:04 <lambdabot>   1%2
09:23:20 <rwmjones> does anyone know if there is _in Fedora_ an emacs mode for editing haskell?
09:23:25 <Boxo> how about if you want to accept both Fractionals and Integrals for (/)
09:23:27 <Boxo> wait...
09:23:45 <opqdonut> Fractional is the type class that contains (/)
09:24:05 <hatds> remember, fractional doesn't mean real or complex
09:24:32 <Boxo> <Boxo> wait... - nevermind
09:26:22 <adamvo> Boxo: Fractional is a single parameter typeclass, so you can't coerce any values with (/), since the results must also be Integers  (or whatever)
09:26:49 <opqdonut> :t (%)
09:26:50 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:27:20 <opqdonut> its usefulness is limited as rational % rational doesn't work
09:27:39 <Boxo> so there is no dividing function such that "divide x 2" is ok both when x is Integral and when x is Fractional
09:28:33 <cypher-> is the simply-typed lambda calculus with type T = int | T1 -> T2 and fixed point combinator as a syntactic form Turing-complete?
09:28:45 <Boxo> But now that i know that Num doesn't just mean real numbers that makes some sense
09:29:53 <vixey> cypher-: what do you mean syntactic form?
09:30:12 <vixey> cypher-: Btw you should be thinking about mu-recursive, not turing complete
09:30:50 <monadic_kid> rwmjones: well i'm using eclipsefp in fedora
09:31:22 <cypher-> I define semantics  of "fix" as fix (\x:T.e) -> [fix (\x:T.e) / x]e
09:31:26 <cypher-> vixey: mu-recursive?
09:31:34 <cypher-> vixey: as in partial recursive?
09:31:44 <EvilTerran> http://en.wikipedia.org/wiki/Mu-recursive_function
09:32:12 <cypher-> yeah, partial-recursive
09:32:37 <cypher-> that's how I planned to argue that the language is Turing-complete
09:32:47 <vixey> forget turing complete, just cover mu-recursive
09:32:49 <EvilTerran> cypher-, but the answer you are looking for comes from a (iirc) fairly straightforward mapping between STLC+fix and untyped LC
09:33:27 <cypher-> EvilTerran: all I have to do really is to write a minimisatin operator
09:33:38 <cypher-> but I have a problem getting it well-typed under the type system I am given
09:33:44 <cypher-> otherwse it is rather straightforward
09:34:46 <cypher-> in particular, I'd like to write iszero = \n.n (\m.false) true
09:35:26 <vixey> If you're talking about lambda calculus or functional programming "turing complete" shouldn't come up ever
09:35:51 <cypher-> vixey: it's the same thing anyway by Church's thesis ;-)
09:35:53 <vixey> (And if you're talking about unit testing .. godels incompleteness theorem is not relevant)
09:35:59 <cypher-> vixey: I need sort of sloppy argument
09:36:00 <vixey> It's not the same thing though
09:36:30 <cypher-> well, the question reads "how would you prove that L (the language) is T-c"
09:36:53 <cypher-> and partial-recursion and Turing-completeness are equivalent
09:42:00 <vixey> cypher-: church-turing doesn't seem relevant to me, It's much more direct to implement a turing machine interpreter in STLC
09:42:24 <hdevalence> So I want to learn haskell, and also I want to draw geometrical patterns. I thought I might try doing it in Haskell instead of C++ for a change. What kind of libraries are there for making images in Haskell?
09:42:56 <vixey> hdevalence: You could use SVG instead of Haskell
09:43:00 <monadic_kid> hdevalence: you know about hackage?
09:43:04 <cypher-> hdevalence: I don't know any libraries but there is a good book about learning haskell and doing graphics
09:43:08 <cypher-> hdevalence: google it up
09:43:43 <monadic_kid> thats not very nice answer
09:44:10 * cypher- can't remember the title :(
09:44:29 <vixey> monadic_kid: I don't think there was anything not-nice about it
09:45:04 <monadic_kid> hdevalence: what exactly do you have in mind anyways?
09:46:05 <hdevalence> monadic_kid: well, stuff like drawing simple fractals
09:46:38 <monadic_kid> omg xchat is gone into retard mode not letting me copy&paste
09:47:05 <hdevalence> vixey: you mean write a haskell program to generate an SVG file?
09:47:22 <vixey> hdevalence: well there is that or just writing the SVG by hand
09:47:38 <monadic_kid> hdevalence: well if i could get copy & paste working again i'd give you a link
09:47:43 <monadic_kid> brb
09:48:51 <monadic_kid> omg wtfl
09:50:16 <hdevalence> vixey: that seems rather impractical for something like a fractal
09:51:03 <Gilly> hdevalence: I used those gd bindings for heuklid (A geometrical constructions drawing package)
09:51:21 <Gilly> No wait.. I didn't, I wrote my own PS printter.
09:51:28 <Gilly> But I used those gd bindings for something - that's sure :)
09:51:35 <Gilly> *printer
09:52:04 <hdevalence> hmm
09:54:02 <sgwizdak> hdevalence, new to haskell myself, but I did find this one blog post
09:54:05 <sgwizdak> hdevalence, http://www.kennknowles.com/blog/2008/04/16/drawing-fractals-in-haskell-with-a-cursor-graphics-dsel-and-a-cute-list-representation/#more-42
09:54:55 <hdevalence> thanks for all the advice
09:55:07 <sgwizdak> hdevalence, aditionally, the ppm file format is super simple
09:55:19 <sgwizdak> hdevalence, though it has the disadvantage of being huge for large images
09:55:35 <sgwizdak> hdevalence, but most other graphic packages can easily convert it into a more compressed format
09:55:55 <clug> does lambdabot have a feature to decode base64?
09:56:36 <RLa> what does ~ do in 'do ~(a,b,c) <- something' ?
09:56:46 <sgwizdak> hdevalence, so look at http://www.ryanlothian.com/articles/haskell-raytracer
09:58:27 <Lemmih> RLa: It means: 'do t <- something; let (a,b,c) = t; ...'
09:58:43 <RLa> oh
09:58:59 <RLa> thanks
09:59:29 <pejo> Lemmih, is the ~ different when on the LHS of a <- than in a let-statement?
10:00:11 <Lemmih> pejo: Say again?
10:00:28 <trofi> laziness
10:00:56 <pejo> Lemmih, he asked what the tilde was, but your answer didn't have any tilde in the pattern match.
10:01:17 <trofi> > let (a,b) = 1 in 2
10:01:18 <lambdabot>       No instance for (Num (t, t1))
10:01:18 <lambdabot>        arising from the literal `1' at <i...
10:01:24 <trofi> > let ~(a,b) = 1 in 2
10:01:25 <lambdabot>       No instance for (Num (t, t1))
10:01:25 <lambdabot>        arising from the literal `1' at <i...
10:01:31 <Lemmih> > case undefined of (x,y) -> ()
10:01:33 <lambdabot>   * Exception: Prelude.undefined
10:01:34 <Lemmih> > case undefined of ~(x,y) -> ()
10:01:36 <lambdabot>   ()
10:02:08 <Lemmih> pejo: Right, that was the point. I showed what his code was equivalent to.
10:02:48 <pumpkin_> > let (a, b) = undefined in 2
10:02:50 <lambdabot>   2
10:02:54 <pumpkin_> > let ~(a, b) = undefined in 2
10:02:56 <lambdabot>   2
10:02:59 <pumpkin_> the ~ does nothing on lets
10:03:19 <trofi> only pattern match?
10:03:29 <Jedai> pejo: The ~ makes the pattern match lazy
10:03:37 <Lemmih> pumpkin_: Well, if it did you could never tell.
10:03:51 <Jedai> it only happens if it's needed
10:04:12 <monadic_kid> hdevalence: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:graphics
10:04:21 <Jedai> All pattern match in a let are lazy, so the ~ don't do anything
10:04:48 <trofi> > let !(a,b) = 1 in 2
10:04:49 <lambdabot>       No instance for (Num (t, t1))
10:04:49 <lambdabot>        arising from the literal `1' at <i...
10:04:56 <trofi> > let !(a,b) = undefined in 2
10:04:57 <lambdabot>   * Exception: Prelude.undefined
10:05:16 <pumpkin_> > let !~(a,b) = undefined in 2
10:05:17 <lambdabot>   <no location info>: parse error on input `!~'
10:05:18 <pumpkin_> :P
10:06:28 <adamvo> > let ~ p@(a,b) = undefined in 2
10:06:30 <lambdabot>   2
10:07:02 <adamvo> > let ~ (!p)@(a,b) = undefined in 2
10:07:03 <lambdabot>   <no location info>: parse error on input `@'
10:07:04 <clug> > let ~(a,b) 50050909203 in 93018401982409
10:07:05 <lambdabot>   <no location info>: parse error on input `in'
10:08:53 <trofi> :t it
10:08:54 <lambdabot> Not in scope: `it'
10:08:57 <trofi> > it
10:08:58 <lambdabot>   Not in scope: `it'
10:09:00 <trofi> , it
10:09:01 <lunabot>  luna: Not in scope: `it'
10:09:11 <clug> > let 1
10:09:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:09:20 <clug> > let 1 = 5
10:09:21 <lambdabot>   <no location info>: parse error on input `;'
10:09:29 <clug> > let a = 5
10:09:30 <lambdabot>   <no location info>: parse error on input `;'
10:09:38 <clug> I didn't even give it a ;
10:09:41 <trofi> add an 'in' part
10:09:54 <clug> > let a = 5 in lol
10:09:55 <lambdabot>   Not in scope: `lol'
10:10:10 <clug> what language is this anyway
10:10:14 <clug> it doesn't look like php
10:10:15 <pumpkin_> o.O
10:10:18 <trofi> :]
10:10:29 <pumpkin_> clug: how did you get here?
10:10:32 <trofi> > let it = 0xBE in "PHP"
10:10:34 <lambdabot>   "PHP"
10:10:53 <clug> I have to learn haskell so I can hack this irc bot
10:10:58 <trofi> , [$ty| id |]
10:11:01 <lunabot>  forall a . a -> a
10:11:03 <pumpkin_> "hack"?
10:11:11 <clug> or try at least
10:11:15 <trofi> @elite hack me
10:11:15 <lambdabot> HAxx m3
10:11:54 <clug> @elite VERSION
10:12:04 <clug> LOL
10:12:09 <clug> lambdabot just version everyone
10:12:10 <trofi> :]
10:12:19 <pumpkin_> it did?
10:12:22 <clug> yes
10:12:28 <trofi> 20:12:24 lambdabot [n=lambdabo@animaforge.net] requested unknown CTCP V3R5IoN from #haskell:
10:12:30 <BCoppens> it did not
10:12:34 <pumpkin_> it didn't do it to me
10:12:38 <clug> wait wat
10:12:47 <wli> *** CTCP VERSION from clug to #haskell
10:12:47 <joga> does your client show unknown ctcp requests?
10:12:48 <joga> :)
10:12:49 <clug> why did it change it to v3r5ion?
10:12:57 <vegai> it did a V3R5IoN, not VERSION
10:13:01 <trofi> it's an elite :]
10:13:03 <BCoppens> because you @elited it, duh? =)
10:13:03 <pumpkin_> yeah :P
10:13:13 <clug> wli, that's because because your irc client sucks and doesn't implement ctcp correctly
10:13:20 <trofi> @elite speech yoda of kind
10:13:20 <lambdabot> 5P3ECH yoDa oF xInd
10:13:48 <pumpkin_> clug: aren't there better things you could be "hacking"?
10:13:51 <clug> lol
10:14:28 <clug> @elite dcc send aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
10:14:29 <lambdabot> DCC zEnd AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA
10:14:31 <clug> lol
10:14:36 --- mode: ChanServ set +o monochrom
10:14:40 <wli> clug: I doubt it quite highly.
10:14:42 <Elly> what
10:14:58 <clug> sorry, I'll stop
10:15:06 --- mode: monochrom set -o monochrom
10:15:42 <Gabbie> 18:14:19 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
10:17:43 <Baughn_> Yep, I got the exact same thing. What's with that?
10:17:45 <clug> it should probably filter \01
10:17:57 <clug> when it responds to @elite
10:18:33 <trofi> it's not a disaster
10:18:47 <opqdonut> 2014.29 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
10:18:50 <opqdonut> hmm?
10:19:00 <trofi> she was confused
10:19:03 <opqdonut> ah, clug i guess
10:19:08 <Gilly> opqdonut: right
10:21:36 <csko> Hi, I have a text file, which has multiple lines. In Haskell, what would be the easiest way to get the string in the last line? Also, what would be the easiest way to get all the lines except the last two?
10:21:59 <opqdonut> csko: watch
10:22:01 <opqdonut> :t lines
10:22:02 <lambdabot> String -> [String]
10:22:03 <Baughn_> last.lines and reverse.tail.reverse.lines, respectively
10:22:22 <Baughn_> No comment on the efficiency of that last one. ;)
10:22:37 <trofi> :t init
10:22:38 <lambdabot> forall a. [a] -> [a]
10:22:45 <pumpkin_> why not init
10:22:47 <pumpkin_> ah yeah
10:22:48 <csko> opqdonut: I have figured out I need "lines".
10:22:51 <Baughn_> @src init
10:22:51 <lambdabot> init [x]    = []
10:22:51 <lambdabot> init (x:xs) = x : init xs
10:22:51 <lambdabot> init []     = undefined
10:22:55 <opqdonut> > init.init $ [1..10]
10:22:56 <lambdabot>   [1,2,3,4,5,6,7,8]
10:23:02 <opqdonut> that gives all but the last two
10:23:13 <Baughn_> Hum. Well, because I never noticed init, I guess..
10:23:21 <trofi> :t inits
10:23:22 <lambdabot> forall a. [a] -> [[a]]
10:24:00 <trofi> :t \(_:_:xs) -> xs
10:24:00 <csko> oh, thanks
10:24:01 <lambdabot> forall t. [t] -> [t]
10:27:15 <Elly> mmm, conjunctive normal form
10:33:09 <overl0d> hi all!
10:41:38 <Valodim> 19:14 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
10:41:42 <Valodim> ..what the hell?
10:42:05 <monochrom> someone played a trick and tricked lambdabot
10:42:11 <Valodim> that was the @elite thing
10:42:37 <vixey> @elite thing
10:42:37 <lambdabot> +|-|iNg
10:43:20 <Valodim> duh
10:44:01 <monochrom> Plus the use of '\01' which means dcc/ctcp to IRC clients.
10:48:20 <skorpan> slightly OT:  does python have anything like haskell's fold[rl]?
10:48:32 <Zao> reduce?
10:48:32 <davidL> reduce
10:48:47 <skorpan> i'll check it out
10:48:50 <rwmjones> is anyone here knowlegable about the FFI?
10:49:02 <rwmjones> I'd like to know how to pass in a CString that can be NULL
10:49:09 <dan> anyone knows if there is a way to tell ghci to look at the haskell library sources?
10:49:23 <dan> if i do :info on my own symbol, i get a reference to a file
10:49:39 <dan> but if i do it on Data.Set for example, ghci just tells me it's from Data.Set...
10:49:58 <Lemmih> rwmjones: From C to Haskell or Haskell to C?
10:50:09 <rwmjones> Lemmih, in this case, from Haskell to C
10:50:14 <rwmjones> ie. my C function is like:
10:50:17 <rwmjones> f (char *foo)
10:50:27 <rwmjones> where the C function is expecting foo to be either a string or NULL
10:50:59 <Lemmih> rwmjones: Should an empty string be NULL?
10:51:17 <rwmjones> Lemmih, no, "" would be different from NULL
10:51:22 <Lemmih> Oh, you want 'Maybe String', I see.
10:51:34 <rwmjones> yes, in Haskelll it's be Maybe String
10:51:40 <rwmjones> but when I do that, I et:
10:51:41 <rwmjones> get:
10:51:53 <rwmjones>     Unacceptable argument type in foreign declaration: Maybe CString
10:52:38 <Lemmih> rwmjones: Check out 'maybeWith withCString'.
10:52:50 <rwmjones> ah ok
10:52:52 * rwmjones looks
10:53:13 <Lemmih> @type Foreign.maybeWith Foreign.C.withCString
10:53:14 <lambdabot> forall a. Maybe String -> (GHC.Ptr.Ptr Foreign.C.Types.CChar -> IO a) -> IO a
10:53:56 <Lemmih> So: maybeWith withCString yourStringHere $ \this_is_the_c_string -> ...
10:55:05 <Lemmih> Keep in mind that the string will be deallocated after the call.
10:55:21 <mornfall> What's up with lambdabot DCCing me some nonsense?
10:55:32 <rwmjones> deallocation is good in this case
10:55:34 <rwmjones> thanks
10:58:19 <EvilTerran> mornfall, someone was tricking lambdabot into doing things it wasn't designed to do
10:59:27 <qazxsw> Can I ask a probably dumb question about why my simple 2 line function seems to be accumulating stack despite my numerous increasingly desperate efforts to mke it strict?
11:00:32 <dan> anyone knows how i can generically *find* the definition of a name from within ghci?
11:00:40 <dan> that is, which file it is in
11:00:42 <qazxsw> the func in question being: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4749#a4749
11:01:41 <Lemmih> qazxsw: And newGen?
11:01:47 <snoobino> what 's this Lift typeclass thing in template haskell ?
11:02:01 <longh_> dan, it can be done via :info or :i
11:02:14 <dan> for standard things i don't get the file name
11:02:35 <qazxsw> that is just a stub just now lemmih, atm it just returns the line back mor or less (it actually does map (1*) list on list passed in)
11:03:00 <mornfall> EvilTerran: Ah, ok. Thanks.
11:03:01 <Lemmih> qazxsw: 'go' is fine. 'newGen' is the problem.
11:03:18 <qazxsw> is newGen being thunked somehow?
11:03:26 <longh_> dan: maybe because ghc doesn't recompile every standard module each time they are needed?
11:03:57 <Lemmih> qazxsw: You're only forcing the first element in the 'line' list.
11:03:59 <dan> but i *would* like it to give me a reference to the file name, assuming i have the sources in some dir
11:04:06 <pshc> Hmm... is there anyway to simplify this: myFunc >>= (\f -> f someConst)
11:04:12 <pshc> not sure if I can do that with join...?
11:04:28 <Lemmih> qazxsw: Er, the first spine segment, rather.
11:04:35 <burp_> @pl \f -> f someConst
11:04:35 <lambdabot> ($ someConst)
11:04:42 <burp_> myFunc >>= ($ someConst)
11:04:42 <pshc> oho
11:04:42 <EvilTerran> pshc, myFunc >>= ($ someConst)
11:04:44 <burp_> like this?
11:04:55 <pshc> Cool, thanks
11:04:57 <qazxsw> lemmih that makes sense, it will stack overflow in the middle of printing
11:05:00 <Lemmih> qazxsw: You don't force the complete spine nor do you force the list elements.
11:05:04 <rwmjones> Lemmih, that worked great, thanks ... now I have a harder question, I think: another C function is expecting char ** as a parameter, where that is a NULL-terminated list of strings (environ-style).  How can I convert [String] into that?
11:05:18 <longh_> dan: doesn't the modulename equal the file name anyway?
11:05:20 <qazxsw> Can I ask, how I would go about doing that?
11:07:06 <Lemmih> rwmjones: withArray0 will do that for you.
11:07:27 <rwmjones> ah ha ... Lemmih this is very useful, where do I find a list of such functions?
11:07:33 <rwmjones> I'm currently reading
11:07:42 <rwmjones> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise5.html#x8-330005.8
11:07:43 <Lemmih> rwmjones: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Marshal-Array.html
11:07:45 <rwmjones> but it's fairly useless
11:07:47 <rwmjones> ok thanks
11:08:05 <Lemmih> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-C-String.html
11:08:54 <ik> 13:14:29 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
11:09:33 <Lemmih> rwmjones: Peek in mind that it should be an array of CStrings.
11:09:55 <dan> longh_: No, not trivially.
11:10:08 <dan> longh_ For example the source of base.hs is:
11:10:58 <dan> longh_: Actually, maybe you're right
11:11:01 <dan> :)
11:11:18 <Lemmih> rwmjones: withMany withCString listOfStrings (\ls -> withArray0 nullPtr (\arr -> ...))
11:12:43 <pumpkin_> I wonder how many more people are going to ask about the DCC
11:13:24 <rwmjones> ah
11:14:22 <monochrom> There is an exponential probability distribution governing it.
11:17:36 <rwmjones> Lemmih, sorry, my haskell is useless.  Is that 'listOfString' or 'listOfStrings'?  it can't seem to find that symbol
11:17:43 <rwmjones> either symbol in fact
11:18:29 <SamB> rwmjones: I think you were just to write some expression there ?
11:18:31 <Lemmih> rwmjones: It's a placeholder. Replace it with your own data.
11:18:39 <SamB> think "foo"
11:18:57 <rwmjones> ah, right I see
11:18:58 <SamB> or rather, foo :: [String]
11:19:13 <rwmjones> obvious really :-)
11:19:26 <Lemmih> rwmjones: Then press the any key twice.
11:19:44 <rwmjones> I did wonder why withMany had an extra argument ...
11:21:41 <rwmjones> excellent, that works now, thanks
11:28:24 <qazxsw> Lemmih, is there an easy way to make that newGen call evaluate fully? is the fix within newGen?
11:29:17 <EvilTerran> there's no "deep evaluation" primative in haskell
11:29:49 <qazxsw> hmmn I see
11:29:50 <Lemmih> qazxsw: You could use 'rnf' from Control.Parallel.Strategies
11:29:55 <EvilTerran> you *can* achieve a similar result with Control.Paralllel.Strategies, but, if you're just using that to force things fully, you're fighting haskell, not working with it
11:30:46 <qazxsw> I will have a look at that, all I am doing is trying out writing a little cellular automaton - like the game of life, except on 1D lines
11:30:55 <EvilTerran> ahhh
11:31:07 <EvilTerran> in that case, you probably want arrays
11:31:16 <qazxsw> hence I wrote a "go" function that is intended to apply repeatedly a "nextGeneration" function to an initial input line
11:31:31 <qazxsw> so the problem is really at root my choise of data structure?
11:32:02 <ldlework> mm I can't wait til I understand enough Haskell to write a CA
11:32:07 <ldlework> Its my hello world
11:32:34 <EvilTerran> qazxsw, well, not as such, but they probably will be substantially more efficient
11:32:59 <qazxsw> that is very useful anyway thanks, I will have a look at the arrays stuff and the RNF
11:33:13 <qazxsw> ldlework, mine too! hence my crappy questions
11:33:31 <dons> Cale: someone should really have done this in haskell, http://pyevolve.sourceforge.net/wordpress/?p=527
11:33:45 <dons> we can't lose more math terrain to python's ubiquity :/
11:33:56 <ldlework> qazxsw, use ubuntu?
11:34:03 <dons> in fact, do it and upload to hackage :)
11:34:24 <ldlework> Python is my language of choice
11:34:53 <dons> why's that, do you think?
11:37:00 <mkaemmer> I was looking at an old assignment from a University Utrecht class taught in Haskell...
11:37:13 <mercury^> Funny that he says the sieve is very fast, when it is 8 times slower than the architecture unspecific one I have here.
11:37:47 <mkaemmer> and one of their problems claims that it is possible to write a function 'count' that makes this expression well typed:
11:38:29 <mkaemmer> test = [count, count 1 2 3, count "" [True, False] id (+)]
11:39:04 <EvilTerran> i'm guessing a typeclass is involved
11:39:05 <tomh-> ah i did that
11:39:14 <mkaemmer> http://www.cs.uu.nl/wiki/pub/Afp/Assignments/Assign7.pdf
11:39:16 <mercury^> mkaemmer: the function is called "undefined"
11:39:20 <vixey> :t let count = count in [count, count 1 2 3, count "" [True, False] id (+)]
11:39:21 <lambdabot> forall t. [t]
11:39:23 <ldlework> dons, because its easy to understand, easy to write, there's most everything I've ever needed in its Stdlib and where its not in the stdlib, there's a thirdparty somewhere, also the community support at least on freenode is as good as it gets. Python its well suited for games, web programming, system administration, processing and lots of other stuff. When I need it to work and I don't need to push the metal to its performance li
11:39:23 <ldlework> mits, Python is the obvious choice for me.
11:39:24 <tomh-> mkaemmer: i did it last semester :P
11:40:23 <leadnose> is a non-empty list of type [t] considered "well typed"?
11:40:40 <vixey> leadnose: no type errors -- it's well typed
11:40:42 <mkaemmer> tomh-: hm... you don't suppose you could explain the second part of it (i.e. write count such that it counts the number of arguments)?
11:40:58 <tomh-> what do you mean
11:41:12 <mercury^> mkaemmer: that's not possible.
11:41:15 <EvilTerran> mkaemmer, i think you're going to need a typeclass
11:41:19 <tomh-> it is possible
11:41:23 <tomh-> i solved it
11:41:30 <EvilTerran> mercury^, i think i can see a way of doing it
11:41:38 <mercury^> It needs to return 1 after it gets one argument.
11:41:42 <vixey> if you want [0,3,4] then yeah -- but you can make it well typed without any classes
11:42:00 <tomh-> you need two instances
11:42:02 <tomh-> to solve it
11:42:04 <EvilTerran> vixey, <mkaemmer> ... write count such that it counts the number of arguments ...
11:42:05 <vixey> getting [0,3,4] is clearly different from just getting it to typecheck
11:42:15 <dons> ldlework: so libraries are a big part, by the sounds of it.
11:42:26 <tomh-> vixey: that was the second part
11:42:28 <dons> easy to understand is interesting.
11:42:29 <mkaemmer> vixey: yeah... thats the hard part, but it's supposedly possible
11:42:29 <vixey> EvilTerran:
11:42:30 <vixey> <mkaemmer> and one of their problems claims that it is possible to write a function 'count' that makes this expression well typed:
11:42:30 <vixey> <mkaemmer> test = [count, count 1 2 3, count "" [True, False] id (+)]
11:42:35 <vixey> it's not hard
11:42:54 <mercury^> I would like to see the solution to it also giving the counts.
11:43:06 <tomh-> i dont have it here unfortunately
11:43:13 <tomh-> or maybe i got let me see
11:43:34 <vixey> mercury with test :: [Integer] you get the first count :: Integer, the second count :: Int -> Int -> Int -> Integer
11:43:54 <ldlework> dons, if you're asking me in the context of haskell, you have to understand, haskell isn't natural. At least not to most people. Haskell can pretend that purely-functional is like walking, but its more like cryptic kung-foo that you have to master. You do that to reap the benefits haskell offers by doing that. But coming from Python and reading the literature "Haskell is fun!" etc puts me off.
11:44:02 <hatds> count a = \x -> (+) 1 count x
11:44:03 <hatds> ?
11:44:15 <vixey> hatds: no chance of that working
11:44:24 <hatds> heh
11:44:46 <vixey> you need an accumulator
11:45:07 <ldlework> I want a haskell text that says "Okay, Haskell is flipping tough. Grab some coffee and some chips and let me explain something to you."
11:45:10 <dons> ldlework: interesting. what specifically? you mean just having to separate effects from pure code? or lack of mutable objects?
11:45:18 <tomh-> vixey, it has to be for any type you put in
11:45:29 <vixey> tomh-: and?
11:45:40 <dons> ldlework: there's a school of thought that asserts pure fp is actually intuitive, and that its OO / imperative training that makes it hard.
11:45:49 <dons> hence it is taught happily to new programmers, who don't panic.
11:46:01 <dons> not that that helps you, but it is a view point.
11:46:03 <EvilTerran> tomh-, ok, count :: a -> b -> ... -> Integer
11:46:40 <ldlework> dons, precisely. Not particularly what you said but how you said it. Haskell can't be the journeyman's language. Its too acedemic and too much focus is put on computational theory. To me I try to pick up as much of that along the way, but it isn't useful to me in the sense ..
11:47:04 <vixey> ldlework: "Its too acedemic and too much focus is put on computational theory" is just nonsense though
11:47:08 <dons> it's the journeyman's language for a lot of people here though.
11:47:23 <dons> yes, "too academic" doesn't actually say anything. though its a common refrain.
11:48:14 <tomh-> I don't got the solution here unfortunately
11:48:14 * dons recommends RWH for "journeyman-style"
11:48:28 <dons> along with things you wouldn't attempt in python ;)
11:48:44 <tomh-> but i remember it was a class with 2 instances
11:48:57 <tomh-> one accumelator and one that just adds up the number of args
11:49:09 <mkaemmer> tomh-: thanks. That helps a little
11:49:23 <ldlework> dons, the reality is not everyone who wants to be a programmer comes from a scholarly background where they've gone through their paces. I'm just noting a language like Haskell has a lot of upfront to deal with for people like that.
11:49:34 <ldlework> Not that those people are the normal and programming must cater to those people :)
11:50:30 <ldlework> If I had gone through a computer science degree and they made me learn to optimize lisp compilers, I'd probably be able to pick up haskell a lot easier.
11:50:32 <dons> haskell has a lot of stuff.
11:50:58 <tomh-> i code haskell for like a year straight in my master but i still dont have a clue how it works :p
11:51:01 <hatds> I'm neither CS or nor a programmer, but I think I self taught myself everything in a month.  I had a lot of self motivation though
11:51:02 <vixey> ldlework :/
11:51:13 <vixey> ldlework that's pretty condensding btw (for those of us that use haskell)
11:51:15 <dons> its interesting how people can be happy with languages with rough corners, and ad hoc implementations of well understood concepts.
11:51:18 <dons> i'm fascinated by that.
11:51:33 <ldlework> I'm not putting haskell down
11:51:40 <skorpan> hatds: that's a bold statement
11:51:42 <ldlework> I'm simply giving you insight into the troubles I'm having with it
11:51:46 <dons> ldlework: yeah, re condescending, i think your _impression_ of the community might not match reality.
11:51:47 <ldlework> Coming from the language you mentioned
11:51:49 <vixey> ldlework: yeah not what you said about haskell, what you said about the peopl ethat use it
11:51:51 <ldlework> That it was competing with
11:51:52 <dons> impressions are interesting
11:52:15 <ldlework> dons, vixey simply that haskell makes me feel as though I wish I *had* gone through my paces
11:52:30 <ldlework> I don't mean or see how my sentiments are putting anyone but myself down
11:52:32 <ldlework> But I appologize
11:52:35 <daf> kolmodin: around?
11:52:36 <vixey> ldlework if you have any concrete problems people here will love to help you
11:52:44 <dons> interesting. and do you think that feeling limits how far you can progress with the language?
11:52:46 <ldlework> Heh, that's good to know
11:52:49 <vixey> ldlework, if you're just gonna keep with the vague complaining -- I think I'll ignore
11:52:55 <ldlework> dons, no simply that more time must be spent
11:53:02 <dons> hmm.
11:53:06 <ldlework> vixey, I wasn't complaining sorry
11:53:14 <dons> have you read "real world haskell"?
11:53:18 <dons> (its online)
11:53:19 <mkaemmer> one of the sad truths is that most serious programmers will stick with their mainstay language no matter how much you show them something better exists
11:53:33 <ldlework> He noted some competition with Python. Coming from Python I was just sharing my initial experiences.
11:53:50 <ldlework> mkaemmer, and its funny because Python programmers hold that same position about the rest of the languages
11:53:50 <mkaemmer> I think thats part of the reason people insist that haskell is "too academic"
11:53:59 <dons> i'd say RWH directly tries to address the impression ldlework cites.
11:54:03 <ldlework> mkaemmer, no
11:54:13 <vixey> yeah that's true mkaemmer
11:54:16 <vegai> python still does have excellent library sets
11:54:16 <ldlework> Haskell isn't too academic
11:54:17 <vixey> especially with C
11:54:22 <ldlework> Haskell, IS academic
11:54:27 <vegai> frankly, I haven't seen better libs anywhere
11:54:40 <solrize> @pl (\x->x+x)
11:54:40 <lambdabot> join (+)
11:54:55 <EvilTerran> solrize, i suggest (*2)
11:55:00 <ldlework> That's its background. It purposely drops run-in paradigms to use things we now know about program design.
11:55:18 <hatds> run-in?
11:55:23 <dons> that's not "academic" though, that's revolutionary
11:55:24 <ldlework> Like...
11:55:26 <solrize> evilterran yeah i was wondering the more general way to make a pointfree lambda
11:55:33 <dons> its unclear what you mean by "academic"
11:55:36 <ldlework> Programming paradigms that are used, just because their traditional
11:55:39 <ldlework> C-Like languages
11:55:45 <dons> right. so its revolutionary
11:55:50 <dons> it rejects the old order
11:55:59 <ldlework> So, I'm not saying that's bad
11:56:02 <dons> and tries to rebuild a new programming model from scratch
11:56:03 <ldlework> Simply that its difficult
11:56:04 <ldlework> That's it
11:56:12 <ldlework> Haskell is definately interesting.
11:56:13 <dons> right, i don't think "academic" is the word here though.
11:56:33 <mkaemmer> Its kind of nice that haskell has that reputation
11:56:45 <ldlework> Err okay. Designing a language from the ground up based on computer science principles we've learned over the decades of study of the subject, isn't academic
11:56:51 <ldlework> I think you're being offended where you shouldn't be.
11:57:04 <dons> i'm still not clear what "academic" is supposed to mean here.
11:57:10 <dons> rigorous?
11:57:19 <dons> foundational?
11:57:21 <ldlework> Simply that the langauge has constructs that enforce concepts you could ignore before
11:57:31 <dons> so strict/rigorous/precise
11:57:34 <AndyP> hi folks, know any haskell tutorials/articles on the web which cover threading? or perhaps just point me in the direction of enlightenment on the subject :)
11:57:46 <dons> AndyP: yes, there are two great online tutorials
11:57:48 <ldlework> Like concepts that are considered "good practice" in traditional languages, Haskell enforces in its design.
11:58:07 <wli> Usually it means impractical and pedantic.
11:58:07 <dons> ldlework: "next generation"?
11:58:21 <wli> I hope that's not what's intended here.
11:58:51 <ldlework> dons, are you looking for a different word that can fulfill this needed impression of haskell by newcommers that you can use to replace with?
11:59:12 <dons> i don't think "academic" is a good word, and certainly not one anyone involved with the language uses.
11:59:16 <AndyP> dons: ok good, so err, what are they?
11:59:23 <dons> AndyP: looking...
11:59:30 <hatds> I think the issue here is that C is to Haskell as Turning Machines are to Lambda Calculus... and if you were like me coming from C you aren't able to guess how Haskell is implemented under the hood
11:59:37 <AndyP> dons: cheers
11:59:47 <dons> ldlework: after all, you pretty much described it the way we do. "an elegant, revolutionary attack at the very nature of programming"
12:00:02 <dons> AndyP: http://research.microsoft.com/~simonpj/papers/parallel/index.htm
12:00:14 <dons> and the other resource is real world haskell's several concurrency and parallelism chapters
12:00:28 <dons> hatds: that's definitely part of it
12:00:35 <AndyP> great stuff, much obliged
12:00:57 <dons> but then, no one knows how python or ruby or php are implemented under the hood -- they guess though, even if its wrong. i find that interesting
12:01:13 <dons> while in haskell you can actually get onto the bare metal, so its an interesting dissonance
12:01:32 <pejo> hatds, I still don't know that.
12:01:42 <hatds> is the mental model for python much different than C though? (I don't know python)
12:02:19 <skorpan> hatds: i think it is
12:02:27 <solrize> python is a pretty straightforward interpreted OO/imperative language, looking at the implementation (i've done that) doesn't give many surprises
12:02:31 <hatds> pejo: the analogy part?
12:02:34 <skorpan> there are maps and folds (apparently reduce)
12:02:41 <mkaemmer> well... one of the things I thought was weird coming to FP from imperative was that debugging is not straight forward
12:02:44 <solrize> but i never would have figured out graph reduction
12:02:48 <skorpan> solrize: it's functional as well
12:02:59 <skorpan> mkaemmer: Debug.Trace.trace ;)
12:03:04 <pejo> hatds, how Haskell is implemented under the hood
12:03:20 <mkaemmer> skorpan: yeah... my first FP language was SML NJ though
12:03:38 <pejo> mkaemmer, did you find debugging awkward in SML?
12:04:17 <hatds> pejo: SPJ has an old book on implementation.  That's what I read when I really wanted to understand laziness   http://research.microsoft.com/en-us/um/people/simonpj/papers/papers.html
12:04:20 <mkaemmer> pejo: Sort of... I used alot of "print _;"
12:04:29 <mkaemmer> pejo: which is not functionally pure
12:05:08 <pejo> mkaemmer, I don't think anyone here would object to defining ML as a functional language.
12:05:17 <daf> hatds: I think your emphasis on the programming understanding how the implementation works is misplaced
12:05:23 <daf> * the programmer
12:05:29 <dons> the programmer only needs a model
12:05:34 <dons> as all the interpreted/scripting languages show
12:06:06 <hatds> dag: I agree in a sense, and I knew that I didn't need to know it to use the language
12:06:18 <hatds> er daf:
12:07:47 <hatds> but having a vague idea of what the real implementation is like can be more comforting than having an unsure idea of what the correct user model is
12:07:57 <hatds> well they complement each other
12:07:58 <edwardk> When I read SPJ's book I kept thinking of Miranda rights. "You have the right to remain lazy. You have the right to a type checker. If you cannot afford a typechecker, one will be appointed to you by Microsoft Research Cambridge. Anything you do in IO, can and will be used against you..."
12:08:32 <daf> edwardk: haha
12:08:53 <clug> How do you define functions to lambdabot
12:09:06 <daf> @let f x = x + 3
12:09:07 <lambdabot>  Defined.
12:09:10 <clug> ty
12:09:12 <daf> > f 2
12:09:13 <lambdabot>       Ambiguous occurrence `f'
12:09:13 <lambdabot>      It could refer to either `L.f', defined a...
12:09:16 <clug> lol
12:09:18 <daf> heh
12:09:25 <edwardk> @undefine f
12:09:27 <clug> namespaces?
12:09:29 <edwardk> > f x
12:09:30 <lambdabot>   Add a type signature
12:09:39 <clug> I c
12:09:43 <edwardk> > foldr f z [a,b,c]
12:09:44 <daf> well, you get the idea
12:09:45 <lambdabot>   f a (f b (f c z))
12:09:54 <edwardk> -- the single char ones are already defined so that that works
12:10:25 <clug> >pizza 5
12:10:29 <clug> > pizza 5
12:10:31 <lambdabot>   "pizza"
12:10:36 <clug> > pizza 59259348509
12:10:37 <lambdabot>   "pizza"
12:12:12 <Elly> pizza!?
12:12:57 <kolmodin> daf: I'll be available before noon a couple of hours tomorrow
12:13:04 <kolmodin> daf: likely...
12:13:39 <hatds> hmmm.. looking back, I think I saw understanding the implementation as a "last thing left to conquer" sort of thing when I was learning the language
12:14:10 <hatds> but I think it turned out to be useful
12:14:43 <solrize> yeah, that was repetae's approach to haskell
12:14:54 <solrize> he decided to implement haskell as a way of learning it
12:15:52 <snoobino_> Is there an example of how to Lift (in the template haskell sens) a type ?
12:15:58 <clug> > [0..]
12:16:00 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:16:05 <daf> kolmodin: ok. I essentially wanted to say that: my preferred approach would be to selectively merge your code into ours, given that I think our code is less buggy but that yours is more elegant. we're thinking of applying a BSD licence and uploading to hackage as pure-dbus or similar.
12:16:40 <snoobino_> I found a piece of code that does it automatically, but I can't understand it
12:16:54 <hatds> snoobino_: what does it do?
12:17:16 <snoobino_> hatds : derives Lift instances
12:17:26 <clug> The best way to learn something is to try to hack it
12:17:39 <hatds> as in... GHC?
12:17:55 <snoobino_> hatds: yeah, template haskell
12:18:16 <hatds> scratch what I said the above... hacking GHC is unconquered and probably will be for some time :)
12:18:17 <daf> the best way to learn something is to explain it, and implementing it is just explaining it to the computer in exhaustive detail
12:18:48 <daf> hatds: I certainly agree that the implementations are interesting
12:18:49 <hatds> whoops, that was to clug :)
12:19:12 <clug> Meh, I learn better when I try to break it or break an implementation of it or break a program written in it
12:21:32 <desp> 19:14 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]
12:21:36 <desp> Interesting.
12:22:08 <p_l> lambdabot might have seen something scary, to scream like that ;-)
12:22:18 * EvilTerran notes the accuracy of monochrom's exponential decay theory
12:22:33 <hatds> speaking of exhaustive detail.. the Haskell Report is an excellent learning resource
12:22:48 <monochrom> hehehe
12:25:01 <clug> > [500, 499..0]
12:25:02 <lambdabot>   [500,499,498,497,496,495,494,493,492,491,490,489,488,487,486,485,484,483,48...
12:25:29 <trofi> > [False, False ..]
12:25:30 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,False,False,Fa...
12:25:43 <bavardage> > [False, True, ..]
12:25:44 <lambdabot>   <no location info>: parse error on input `..'
12:25:52 <bavardage> > [False, True ..]
12:25:53 <lambdabot>   [False,True]
12:25:53 <hatds>  > [False ..]
12:26:28 <MyCatVerbs> > maxBound :: Bool
12:26:30 <lambdabot>   True
12:27:10 <will> I'm trying to install xmonad.  However, when I try to configure Setup.lhs, it says that I haven't specified as build-type.
12:27:13 <will> What does this mean?
12:27:15 <solrize> > [False, True, True .. ]
12:27:16 <lambdabot>   <no location info>: parse error on input `..'
12:27:48 <trofi> arith progressions are defined with 2 sequential elements :p
12:27:52 * SubStack turned in a literate haskell program and document for his stat 300 project
12:28:27 <SubStack> on the fitness of estimators for context weighted trees
12:28:36 <solrize> cool
12:28:37 <SubStack> totally more interesting than whatever other people submitted I bet
12:28:48 <solrize> did you use lhslatex ?
12:29:17 <SubStack> lhs2TeX, I used
12:29:22 <clug> > [sqrt x | x <- [0..], x % 597 == 0]
12:29:23 <lambdabot>   Add a type signature
12:29:26 <SubStack> probably that would have been easier though
12:29:33 <clug> huh? whats a type signature?
12:29:47 <clug> What was wring with that?
12:29:54 <clug> wrong*
12:30:04 <clug> It should sqrt all multiples of 597
12:30:13 <clug> very inefficiently
12:30:13 <trofi> :t sqrt
12:30:14 <lambdabot> forall a. (Floating a) => a -> a
12:30:16 <EvilTerran> ?type (%)
12:30:17 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:30:18 <mauke> clug: % takes two integers, sqrt takes a float
12:30:21 <EvilTerran> clug, i think you meant
12:30:23 <EvilTerran> ?type mod
12:30:23 <clug> oh
12:30:24 <lambdabot> forall a. (Integral a) => a -> a -> a
12:30:27 <SubStack> > [ sqrt $ fromIntegral x | x <- [0..], x `mod` 597 == 0 ]
12:30:28 <lambdabot>   [0.0,24.43358344574123,34.55430508634199,42.320207938997655,48.867166891482...
12:30:47 <SubStack> where is % defined at?
12:30:52 <trofi> Ratio
12:30:52 <EvilTerran> > [ sqrt $ fromInteger x | x <- [0, 597 ..]]
12:30:53 <mauke> > map sqrt . iterate (597 +) $ 0
12:30:53 <lambdabot>   [0.0,24.43358344574123,34.55430508634199,42.320207938997655,48.867166891482...
12:30:54 <lightstep> clug, [0,597..] is more efficient
12:30:54 <lambdabot>   [0.0,24.43358344574123,34.55430508634199,42.320207938997655,48.867166891482...
12:30:56 <SubStack> nifty
12:31:09 <trofi> :t (%)
12:31:10 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
12:31:21 <EvilTerran> > 4 % 12
12:31:22 <lambdabot>   1%3
12:31:31 <trofi> > (1 :+ 3)
12:31:32 <lambdabot>   1.0 :+ 3.0
12:31:49 <clug> > [sqrt x | x <- [6..], x == 5]
12:32:01 <EvilTerran> yeah, that's _|_
12:32:04 <lambdabot>   thread killed
12:32:09 <clug> lol
12:32:26 <clug> it took a while to kill that... hmm
12:32:36 <lightstep> i bootstrapped cabal-install, and it didn't produce ~/.cabal/config. where can i get this file? i don't find it in the darcs tree anywhere.
12:32:37 <monadic_kid> she's not dead
12:32:40 <monochrom> Haskell is academic and Haskell is practical. There is no conflict in that. FYI the while-loop was academic (and "not practical") in ancient times, and OOP was once academic (and "not practical") in ancient times.
12:32:41 <EvilTerran> the list and predicate are abstract to the compiler - it has no way of telling that no item in the list will ever satisfy the predicate
12:32:48 <mauke> lightstep: try running cabal update
12:33:01 <clug> > 5
12:33:12 <trofi> , 5
12:33:13 <lunabot>  5
12:33:14 <dcoutts> lightstep: it's created the first time you run any interesting command, eg update as mauke says
12:33:22 <EvilTerran> ?bot
12:33:34 <mkaemmer> monochrom: the unfortunate part is that some things take nearly forever to become "practical"
12:33:39 <monadic_kid> :t id
12:33:45 <lambdabot>   thread killed
12:33:49 <mkaemmer> lisp had garbage collection back in the 60s
12:33:49 <lambdabot> :)
12:33:57 <monadic_kid> @botsnack
12:33:57 <lunabot>  :)
12:33:59 <monadic_kid> @botsnack
12:33:59 <lunabot>  :)
12:34:06 <trofi> > 1
12:34:33 <trofi> @tell lambdabot i miss you
12:34:57 <lightstep> mauke, dcoutts: thanks
12:35:41 <monadic_kid> what waste of a day trying to hack a bot in a langauge you haven't even heard of before
12:36:01 <lightstep> so the last lines of the bootstrap script should be changed. it suggests adding a directive to the config file, and if you create it with just that line, update doesn't work
12:36:58 <trofi> there _must_ be buffer overrun
12:37:13 <monadic_kid> @botsnack
12:37:13 <lunabot>  :)
12:37:16 <monadic_kid> @botsnack
12:37:17 <lunabot>  :)
12:37:26 <chromakode> hey all, how would I force evaluation of the values inside a tuple?
12:37:45 <trofi> a `seq` b `seq` (a, b)
12:38:41 <chromakode> trofi: I have a function that returns a tuple, and want to return a tuple... should I just strictly pull the values out of it, and stick them in a new tuple?
12:39:34 <trofi> i think it depends on semantics of your program
12:39:56 <mauke> monadic_kid: ?
12:40:22 <chromakode> trofi: hm.
12:40:44 <trofi> , let { l1 = length [1..]; l2 = length [1..]} in length [l1, l2]
12:40:46 <lunabot>  2
12:40:59 <trofi> , let { l1 = length [1..]; l2 = length [1..]} in l1 `seq` l2 `seq` length [l1, l2]
12:41:01 <lunabot>  luna: out of memory (requested 1048576 bytes)
12:41:35 <trofi> , let { l1 = id $ length [1..]; l2 = id $ length [1..]} in l1 `seq` l2 `seq` length [l1, l2]
12:41:42 <lunabot>  Killed.
12:41:44 <trofi> , let { l1 = id $ length [1..]; l2 = id $ length [1..]} in l1 `seq` l2 `seq` length [l1, l2]
12:41:47 <monadic_kid> mauke: most of you didn't see this guy come here earlier on with the intention of breaking lambdabot and even thought this was some kind of PHP thread
12:41:50 <lunabot>  Killed.
12:42:03 <chromakode> thanks trofii.
12:42:08 <monadic_kid> mauke: i mean PHP chatroom
12:42:57 <monadic_kid> mauke: you notice lambdabot is dead right
12:43:05 <mauke> yes?
12:43:43 <EvilTerran> lambdabot is managed by Cale, isn't it?
12:43:44 <adamvo> @seen lambdabot
12:44:11 <wh1t3> thats a lamdabot feature i take it :P
12:44:14 <EvilTerran> adamvo, i detect a problem with this strategy
12:44:48 <monadic_kid> mauke: this guy didn't even know haskell existed when she came here
12:44:54 <monochrom> I can't detect the problem. It's undecidable.
12:45:24 <mauke> monadic_kid: so why do you keep saying "@botsnack"?
12:45:25 <ksf> preflex, seen lambdabot
12:45:26 <preflex>  lambdabot was last seen on #haskell 11 minutes and 36 seconds ago, saying: :)
12:45:36 <adamvo> <monadic_kid> ... this guy ... she came
12:45:49 <monadic_kid> adamvo: yes I'm not going to feed her ego
12:46:03 <monadic_kid> adamvo: hence i'm coming her she from now on
12:46:05 <monochrom> That's one of the strategies to evade being called sexist.
12:46:21 <monadic_kid> adamvo: i mean calling her a she
12:46:30 <trofi> :]
12:46:40 <monochrom> She is an animal. Monkey. It.
12:47:14 <monadic_kid> check the logs from earlier on today, she been at it most of the day
12:47:27 <monadic_kid> or it has even
12:47:33 <monadic_kid> yeah thats better
12:48:31 <adamvo> makes you sound confused (or whatever you're talking about is ...)
12:49:19 <monochrom> English has too few pronouns.
12:49:25 <monadic_kid> *it* came here earlier on today with know clue of haskell's existance we with the sole purpose of hacking/breaking bots
12:50:04 <monadic_kid> *with no clue of haskell's existance with the sole purpose
12:50:15 <mauke> *existence
12:50:59 <monadic_kid> that guy just left now
12:51:01 <monadic_kid> clug
12:51:12 <monadic_kid> *it*, clug
12:52:06 <monadic_kid> that was pathetic and immature
12:52:16 <monadic_kid> :t id
12:52:33 <adamvo> monadic_kid: why discuss intentions now: clug can check the public logs as easily as you can, you know
12:52:45 <monadic_kid> adamvo: i dont care
12:53:24 <monadic_kid> adamvo: you really think that *it* is gonna bother coming back
12:53:39 <monadic_kid> adamvo: *it* never came her about haskell to begin with
12:53:53 <monochrom> If it doesn't read, cool. If it reads, cool.
12:54:05 <monochrom> (May I use the LEM now? :) )
12:54:08 <Saizan_> anyhow, no point in having this discussion in channel
12:54:38 <monochrom> Hmm they're living in the same domain?
12:54:53 <Saizan_> same machine
12:54:59 <monadic_kid> @botsnack
12:54:59 <lunabot>  :)
12:55:03 <monadic_kid> oh well
12:55:04 <lambdabot> :)
12:55:07 <monadic_kid> ah
12:55:31 * monadic_kid says "come here you a little minx" to lambdabot
13:00:23 <clug> Hi I am new to haskell
13:00:29 <trofi> not really
13:00:46 <clug> Well I just read the tutorial an hour ago
13:01:00 <clug> > 5
13:01:03 <lambdabot>   5
13:01:07 <clug> ooh it's back
13:01:08 <clug> yay
13:01:49 <vixey> clug: what liscence are you putting that program under? GPL? BSD? WTF?
13:01:58 <clug> lol
13:02:19 <vixey> I am thinking about using '5' in a program but I don't want to get sued
13:02:24 <trofi> MS EULA
13:03:06 <adamvo> > pred 5
13:03:08 <lambdabot>   4
13:03:15 <kerlo> > pred 0
13:03:16 <lambdabot>   -1
13:03:23 <kerlo> The great mystery is answered.
13:03:27 <vixey> > pred 0 :: Natural
13:03:28 <lambdabot>   * Exception: Natural: fromInteger
13:03:33 <adamvo> > fix pred 5
13:03:34 <lambdabot>       No instance for (Enum (t -> a))
13:03:34 <lambdabot>        arising from a use of `pred' at ...
13:03:40 <adamvo> > fix pred
13:03:42 <lambdabot>   * Exception: Prelude.Enum.().pred: bad argument
13:03:55 <mauke> > pred minBound :: Int
13:03:57 <lambdabot>   * Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
13:04:23 <trofi> @src pred
13:04:24 <lambdabot> Source not found. Wrong!  You cheating scum!
13:04:36 <ksf> does anybody know what i need to put into my vimrc to use http://web.archive.org/web/20071014055340/robotics.eecs.berkeley.edu/~srinath/darcs/darcs/darcs.vim?
13:04:45 <Cale> Welcome clug! :)
13:05:08 <clug> ty, sorry for crashing lambdabot
13:05:09 <kerlo> > 5 :: Natural
13:05:10 <lambdabot>   5
13:05:16 <Cale> clug: Make sure to ask if you have any questions about the language. There are lots of people who like to help.
13:05:16 <vixey> clug: I think only one person actually cares
13:05:19 <kerlo> > pred (0 :: Natural)
13:05:20 <lambdabot>   * Exception: Natural: fromInteger
13:05:24 <vixey> hi jkff
13:05:31 <jkff> vixey: Hi
13:06:18 <vixey> hows it going
13:06:20 <Cale> I'm not sure if it was your fault... I think lispy's machine rebooted.
13:06:33 <Cale> Or... reconnected to the internet anyway
13:06:44 <kerlo> Anyway, everyone knows that the predecessor of 1 is actually 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758.
13:07:03 <monadic_kid> vixey: well if you read what he/she wrote origionally you'd probably understand
13:07:10 <vixey> > iterate ((`mod `2).(`div`2)) 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:07:11 <clug> > 0 / 0
13:07:11 <lambdabot>   [26062623684139844921529879266674432197085925380486406416164785191859999628...
13:07:12 <lambdabot>   NaN
13:07:16 <jkff> Well, as for the free theorems, I haven't done anything since our last talk, but now I have taken a 2 week break at my job, devoted specifically to dealing with the thesis (and to 2 other less major writings).
13:07:17 <clug> 0_o
13:07:38 <vixey> > map (`mod`2) $ iterate (div`2) 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:07:39 <lambdabot>   <no location info>: parse error on input `2'
13:07:40 <clug> oh, the first reply was to vixey
13:07:51 <vixey> > map (`mod` 2) . iterate (`div` 2) $ 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:07:53 <lambdabot>   [0,1,1,1,1,0,0,1,1,1,1,1,1,1,0,0,1,1,1,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,1,0,...
13:08:15 <kerlo> vixey: any particular reason you want to know what that is in binary?
13:09:09 <ksf> > showIntAtBase 2 digitOfInt $  26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:09:10 <lambdabot>   Not in scope: `digitOfInt'
13:09:21 <ksf> > showIntAtBase 2 charOfInt $  26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:09:22 <lambdabot>   Not in scope: `charOfInt'
13:09:24 <ksf> argh
13:09:47 <vixey> @hoogle digit
13:09:48 <lambdabot> Text.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
13:09:48 <lambdabot> Text.ParserCombinators.Parsec.Char digit :: Stream s m Char => ParsecT s u m Char
13:09:48 <lambdabot> Data.Char digitToInt :: Char -> Int
13:09:51 <ksf> > showIntAtBase 2 intToDigit $  26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:09:52 <lambdabot>       Overlapping instances for Show (String -> String)
13:09:52 <lambdabot>        arising from a...
13:09:59 <vixey> :t intToDigit
13:10:01 <trofi> cute programs
13:10:01 <lambdabot> Int -> Char
13:10:02 <ksf> > showIntAtBase 2 intToDigit $  26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758 ""
13:10:03 <lambdabot>       Overlapping instances for Show (String -> String)
13:10:03 <lambdabot>        arising from a...
13:10:05 <mauke> now would be a good time to stop failing
13:10:09 <vixey> :t showIntAtBase
13:10:10 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
13:10:31 <vixey> > flip (showIntAtBase 2 intToDigit) "" 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:10:32 <lambdabot>   "11011100111111010010101100110101000001010111100000111111000100010110110001...
13:10:37 <trofi> make a @let of this shit please
13:10:47 <vixey> @let of this shit = flip (showIntAtBase 2 intToDigit) ""
13:10:47 <lambdabot>   Parse error
13:11:05 <kerlo> @let rsa170 = 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:11:06 <lambdabot>  Defined.
13:11:13 <vixey> what's rsa170?
13:11:28 <mauke> >rsa170
13:11:31 <jkff> It's 26062623684139844921529879266674432197085925380486406416164785191859999628542069361450283931914514618683512198164805919882053057222974116478065095809832377336510711545758
13:11:40 <kerlo> http://en.wikipedia.org/wiki/RSA_numbers
13:11:40 <trofi> obviously
13:11:44 <vixey> oh right
13:11:48 <kerlo> It's actually ...759. I made a mistake.
13:11:49 <vixey> it's a number that's not been factored
13:12:21 <vixey> RSA-170 has a length of 170 decimal digits and has not been factored so far.
13:12:34 <vixey> > sqrt rsa170
13:12:36 <lambdabot>   5.105156577827936e84
13:12:37 <jkff> kerlo: Did you type it by heart, then?
13:12:44 <vixey> ok maybe it can be thta hard to factor..
13:12:58 <vixey> "This challenge is no longer active"
13:13:16 <vixey> http://www.rsa.com/rsalabs/node.asp?id=2092
13:13:20 <SamB> vixey: was it proved prime ?
13:13:35 <vixey> The RSA challenge officially ended in 2007 but people can still attempt to find the factorizations. According to RSA Laboratories, "Now that the industry has a considerably more advanced understanding of the cryptanalytic strength of common symmetric-key and public-key algorithms, these challenges are no longer active."[
13:13:41 <vixey> SamB, that's why
13:13:42 <kerlo> jkff: of course.
13:14:07 <kerlo> SamB: if it's prime, then RSA Labs is lying to us.
13:14:12 <SamB> kerlo: oh
13:14:13 <jkff> kerlo: I guess you learnt it to mentally factor it in your free time? :)
13:14:22 <SamB> they made it themselves from factors?
13:14:25 <kerlo> jkff: yep. I factor it on a regular basis.
13:14:31 <SamB> how would you prove a number that big prime, anyway ?
13:14:45 <jkff> SamB: I'd ask kerlo
13:15:07 <SamB> jkff: but he IS lying to us!
13:15:12 <trofi> > rsa170 `mod` 2
13:15:13 <lambdabot>   0
13:15:14 <vixey> jkff I think the theorems aren't provable without eta and taking that as an axiom breaks the applicability of reflexive proofs
13:15:35 <clug> lambdabot now has the lambda function!
13:15:39 <wli> Deterministic Rabin-Miller needs only O((lg(n))^2) witnesses.
13:15:41 <clug> > lambda 2 3
13:15:43 <lambdabot>   16
13:15:46 <clug> > lambda 2 4
13:15:47 <lambdabot>   256
13:15:53 <clug> > lambda 3 2
13:15:54 <lambdabot>   27
13:15:59 <vixey> > iterate (lambda 3) 5
13:16:07 <vixey> > iterate (lambda 2) 2
13:16:14 <lambdabot>   thread killed
13:16:23 <lambdabot>   thread killed
13:16:31 <vixey> > iterate (lambda 1.03) 1.2
13:16:34 <lambdabot>   Add a type signature
13:16:39 <clug> I think I did it right: @let lambda x b = x ^ (x ^ (b - 1))
13:16:40 <SamB> > take 5 (iterate (lambda 3) 5)
13:16:50 <mauke> > lambda x y
13:16:55 <jkff> vixey: Ehm, I forgot what reflexive proofs are, and (iirc you told me that) my history is on a formatted hard drive
13:16:56 <lambdabot>   thread killed
13:17:00 <SamB> > take 2 (iterate (lambda 3) 5)
13:17:09 <lambdabot>   [5,443426488243037769948249630619149892803]
13:17:25 <SamB> jkff: you mean you reformatted it ?
13:17:30 <jkff> Yes
13:17:37 <SamB> without making backups ?
13:17:40 <jkff> However the theorems don't look like they are something that needs extensionality anywhere
13:17:44 <jkff> I made backups, but not of the history
13:17:54 <SamB> that was smart!
13:18:08 <jkff> vixey: Why do you think extensionality is needed, and where exactly?
13:18:23 <wli> Deterministic Rabin-Miller says that RSA170 is not prime.
13:18:29 <vixey> @free flip
13:18:32 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
13:18:38 <vixey> stuff like this I think
13:18:53 <mkaemmer> willb1: really?  Do you know a witness?
13:19:00 <vixey> or maybe it was the way I wanted to do syntax with binding
13:19:03 <jkff> Ah. You're right: extensionality is absolutely needed.
13:19:10 <rwmjones> gaaa .. what is the indentation of let statements in haskell?
13:19:14 <jkff> But what about the reflexive proofs then, what are they?
13:19:16 <rwmjones> let r = (
13:19:18 <rwmjones>   ...
13:19:19 <rwmjones>   ...
13:19:20 <rwmjones> )
13:19:26 <rwmjones> keeps giving me syntax errors
13:19:31 <lightstep> checking primality is fast: http://primes.utm.edu/prove/prove4_3.html
13:19:48 <wli> Deterministic Rabin-Miller is not swift and still works.
13:19:55 * rwmjones has tried everything, with and without parens, indentation levels etc
13:19:57 <mauke> rwmjones: try 'let {r = ...}', then indentation doesn't matter
13:20:10 <rwmjones> ok
13:20:13 * rwmjones tries
13:20:51 <monadic_kid> rwmjones: you know about where clasues, just say cause I know you're coming from an ocaml world
13:21:08 <rwmjones> indeed I am ..
13:21:43 <clug> > [[x * y | x <- [1..10]] | y <- [1..10]]
13:21:45 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[2,4,6,8,10,12,14,16,18,20],[3,6,9,12,15,18,21,24,2...
13:21:46 <monadic_kid> rwmjones: many a let/let rec in ocaml/f# ;)
13:21:55 <clug> > [[x * y | x <- [1..3]] | y <- [1..3]]
13:21:57 <lambdabot>   [[1,2,3],[2,4,6],[3,6,9]]
13:21:57 <rwmjones> monadic_kid, thanks for your previous answer, but I really don't want to use eclipse, I really want to use emacs
13:22:22 <monadic_kid> rwmjones: sure
13:23:00 <vixey> section 4/page 12 of ftp://ftp.cs.kun.nl/pub/CompMath.Found/wiley.pdf
13:23:11 <monadic_kid> rwmjones: ocaml batteries has syntax extensions for where clauses in ocaml
13:24:23 <clug> What religion is haskell affiliated with?
13:24:31 <monadic_kid> i don't know if they behaviour exactly the same as haskell's where clasues
13:24:55 <mauke> clug: SICP
13:24:59 <vixey> @go if programming languages were programming languages
13:25:00 <lambdabot> http://www.cs.caltech.edu/~mvanier/hacking/rants/cars.html
13:25:01 <lambdabot> Title: Mike Vanier: opinions
13:25:29 <monadic_kid> clug: ultra strong, statically typed
13:25:47 <mauke> the church of the lambda calculus
13:26:26 <jkff> vixey: Ah, I see. And so, eta breaks the Poincare principle?
13:26:37 <vixey> jkff: no it shouldn't
13:27:10 <jkff> What does it break, then?
13:28:05 <jkff> (Reflection looks a pretty cool thing, btw; need to re-read the section on it in "Interactive theorem proving and program development")
13:29:07 <jkff> And as a completely offtopic fact, I've been enlightened with the link between polymorphic expressions required to be pure and the well-known OOP problem of whether Square IS-A Rectangle.
13:29:41 <wli> A square is a rectangle. Why has OOP got a problem with it?
13:30:07 <jkff> Because a Rectangle supports setWidth and setHeight operations, whereas Square breaks their contract or doesn't support them at all
13:30:26 <jkff> (That all, of course, in the brain-dead model where Rectangle *supports* .setWidth/setHeight)
13:30:44 <wli> Well, the mutability is an issue there.
13:30:46 <jkff> (However, despite the silly example, that sheds light on the very problem)
13:31:14 <jkff> Yes, that's what I'm talking about :) The reason for this issue is the same as the reason that requires polymorphic expressions to be pure.
13:31:19 <monochrom> It is a problem because they don't have theorem-proving.
13:31:30 <hatds> what's the polymorphic side?
13:31:40 <jkff> hatds: what do you mean?
13:31:45 <wli> BTW RSA170 nonprimality verification took only 0.03s here with the O((lg(n))^2) deterministic Rabin-Miller.
13:31:58 <hatds> nvm, I see your last comment
13:32:18 <wli> (It's probably even worse than O((lg(n))^2) actually.)
13:32:44 <monochrom> 0.03s is fast.
13:32:47 <clug> waitabitandthensaythreadkilled 5
13:32:50 <clug> > waitabitandthensaythreadkilled 5
13:32:52 <lambdabot>   [0.0,1.0,1.4142135623730951,1.7320508075688772,2.0,2.23606797749979,2.44948...
13:32:55 <clug> aww wat
13:32:57 <clug> nvm
13:33:11 <pumpkin_> lol, there are easier ways of doing that
13:33:13 <pumpkin_> > fix id
13:33:14 <lambdabot>   * Exception: stack overflow
13:33:26 <pumpkin_> > length [1..]
13:33:33 <vixey> @let threadKilled = iterate (lambda 5) 2
13:33:37 <lambdabot>   mueval: Prelude.read: no parse
13:33:38 <jkff> > foldl' (+) [1..]
13:33:39 <lambdabot>  <local>:1:24: Not in scope: `lambda'
13:33:41 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
13:33:41 <lambdabot>        arising from a use...
13:33:45 <vixey> @let threadKilled = iterate (5^) 2
13:33:46 <lambdabot>  Defined.
13:33:46 <vixey> > threadKilled
13:33:55 --- mode: ChanServ set +o monochrom
13:33:56 --- mode: monochrom set +b *!*@cpe-066-057-078-104.nc.res.rr.com
13:34:01 <lambdabot>   thread killed
13:34:11 --- mode: monochrom set -o monochrom
13:34:31 <ryanakca> Ummm... What's this: ``13:14:29 DCC unknown ctcp zEnd from lambdabot [AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA]'' ?
13:34:46 <monadic_kid> asd
13:34:48 <vixey> lol
13:34:52 <rwmjones> another stupid question here, what is the opposite of fromIntegral, ie. CInt -> Int ?
13:34:52 <wli> monochrom: It's not even probabilistic; it's deterministic. One could do it probabilistically and obtain counterexamples to its primality even more quickly.
13:34:57 <DrSyzygyIE> ryanakca: lambdabot just hacked you. :-)
13:35:27 <ryanakca> DrSyzygyIE: Of course it did :P Can whoever runs the bot try to keep under control please :)
13:35:39 <monochrom> fromIntegral coverts CInt to Int too. It's polymorphic.
13:35:42 <wli> monochrom: Though it may be the case that the deterministic algorithm short-circuits as soon as it finds a counterexample to primality.
13:36:02 <ryanakca> I don't think you'd want be to join my bot to #haskell and have it send unknown DCC commands to people :)
13:36:23 <monadic_kid> i told you that guy has no real interesting in haskell other than to break lambdabot
13:36:30 <monadic_kid> *no real interest in haskell
13:36:37 <maltem> rwmjones, both types are in Integral, so that's symmetric
13:37:06 <ryanakca> monadic_kid: ah :)
13:37:42 <wli> I'm up to 43.5M/50M on Project Euler #216. My laptop may actually be staying up long enough to finish the calculation.
13:37:47 <monadic_kid> ryanakca: he/she been trying to hack it all day
13:37:51 <DrSyzygyIE> *snerk*
13:37:59 <DrSyzygyIE> >>> Haskell   is an incredibly elegantly-designed and beautiful car, which is rumored to be able to drive over extremely strange terrain. The one time you tried to drive it, it didn't actually drive along the road; instead, it made copies of itself and the road, with each successive copy of the road having the car a little further along. It's supposed to be possible to drive it in a more conventional way, but you don't know enough math 
13:38:00 <monadic_kid> ryanakca: killed lambdabot once already
13:38:21 <wli> It's been running for over 7 days.
13:38:24 <ryanakca> monadic_kid: and no !op / ``Grow up or we'll k/b you?''
13:38:53 <idnar> wli: it's over 9000?
13:39:07 <pumpkin_> lol
13:39:15 <wli> idnar: I think so. Almost 50% of the numbers are prime.
13:39:15 <monochrom> For the complete story you have to read the complete channel log.
13:39:25 <monadic_kid> ryanakca: no he just encuraged  lol
13:39:56 <ryanakca> heh
13:39:59 <ryanakca> Lovely :)
13:40:02 <wli> idnar: Okay, maybe not 50%. I have 4.78M primes among the 43.5M I've checked thus far.
13:40:15 <wli> idnar: So around 10%.
13:40:55 <wli> idnar: I'm also using some Eratosthenes -like sieving, albeit not to the maximum extent possible.
13:42:42 <wli> idnar: I basically found that the sieving process slowed things down considerably when its internal data structures got too big, and required a bit too much work to build up the data structures when factoring was undertaken/etc.
13:43:15 <idnar> wli: fun stuff
13:47:40 <wli> idnar: I could probably reduce things to ca. 16% of the search space by setting up a sieve with the first 10000 primes congruent to +/- 1 mod 8.
13:48:12 <RLa> in state monad what is difference between state and value and why they both are needed
13:48:25 <vixey> RLa: what is 'value'?
13:48:34 <vixey> RLa: such as  return 3  ,, 3 is the value?
13:48:54 <vixey> :t (execState,evalState,runState)
13:48:56 <monadic_kid> vixey: i think he means the two type variables
13:48:56 <lambdabot> forall s a s1 a1 s2 a2. (State s a -> s -> s, State s1 a1 -> s1 -> a1, State s2 a2 -> s2 -> (a2, s2))
13:49:14 <monadic_kid> vixey: the first one being the state type vaiaible
13:49:25 <monadic_kid> *variable
13:49:32 <roconnor> RLa: all monads have a type variable for intermediate computations
13:49:40 <RLa> monadic_kid, vixey, yes why are there two type variables
13:50:10 <monadic_kid> RLa: if you look at the definition of the state type, it becomes more clear
13:50:14 <wli> idnar: It's not able to do a whole lot because one can only eliminate the inverses of the square roots of 2 mod p for each p, and the restriction to p = +/- 1 mod 8 really kills the thinning of the search space.
13:50:32 <RLa> ok, one is for state, but can't state considered to be a value?
13:50:32 <RLa> why the heck make things so complicated
13:50:39 <vixey> RLa: where?
13:50:47 <roconnor> @type get
13:50:48 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
13:50:49 <monadic_kid> :t State
13:50:50 <lambdabot> forall s a. (s -> (a, s)) -> State s a
13:51:00 <vixey> monadic_kid: please don't
13:51:00 <RLa> i have been looking hours at it and it makes no sense
13:51:06 <roconnor> @type get :: State s s
13:51:07 <lambdabot> forall s. State s s
13:51:12 <monadic_kid> vixey:?
13:51:12 <vixey> RLa: exactly what are you referring to ?
13:51:16 <roconnor> @type put :: State s ()
13:51:18 <lambdabot>     Couldn't match expected type `State s ()'
13:51:18 <lambdabot>            against inferred type `s1 -> m ()'
13:51:29 <RLa> s -> (a, s) <-
13:51:32 <pumpkin_> runState gives you both the outputs of execState and evalState ?
13:51:49 <roconnor> RLa: the monadic type variable allows you to compose new values without altering the state
13:51:50 <monadic_kid> vixey: please don't what?
13:52:05 <vixey> RLa: so we have like   newtype State s a = State (s -> (a, s))
13:52:11 <idnar> wli: isn't your solution supposed to run in under a minute or something? :P
13:52:12 <roconnor> @type get >>= toLower
13:52:13 <lambdabot>     Couldn't match expected type `m b' against inferred type `Char'
13:52:14 <lambdabot>       Expected type: Char -> m b
13:52:14 <lambdabot>       Inferred type: Char -> Char
13:52:19 <roconnor> @type get >>= chr
13:52:20 <lambdabot>     Couldn't match expected type `m b' against inferred type `Char'
13:52:21 <lambdabot>       Expected type: Int -> m b
13:52:21 <lambdabot>       Inferred type: Int -> Char
13:52:30 <roconnor> @type get `fmap` chr
13:52:31 <lambdabot> forall b. (MonadState b ((->) Char)) => Int -> b
13:52:37 <wli> idnar: Yeah. I can't get it to run that fast (yet, though I expect I never will).
13:52:38 <roconnor> ugh, I suck
13:52:43 <RLa> vixey, yes, but why do i have to keep value and "state" separately
13:52:47 <roconnor> @type chr `fmap` get
13:52:48 <lambdabot> forall (f :: * -> *). (Functor f, MonadState Int f) => f Char
13:52:50 <vixey> RLa: and so   program :: State s a   means this program has a state variable of type 's' (which it might read, or write, ..modify) and then 'a' which is the value the program returns
13:53:01 <roconnor> @type chr `fmap` get :: MonadState Int Char
13:53:02 <lambdabot>     Class `MonadState' used as a type
13:53:03 <lambdabot>     In the type `MonadState Int Char'
13:53:03 <lambdabot>     In an expression type signature:
13:53:09 <roconnor> @type chr `fmap` get :: State Int Char
13:53:10 <vixey> RLa: for example we can write a program that increments the state and returns "foo" every time
13:53:11 <lambdabot> State Int Char
13:53:13 <monadic_kid> vixey: you still haven't told me what you want me to stop doing?
13:53:14 <RLa> oh, a is not supposed to be modified?
13:53:22 <vixey> @let foo = modify (+1) >> return "foo"
13:53:24 <lambdabot>  Defined.
13:53:34 <vixey> RLa, then for example, we could have 'foo' run 3 times in a row
13:53:41 <vixey> it'll increment the state by 3
13:53:48 <RLa> so
13:53:49 <hatds> a is the output
13:53:50 <roconnor> RLa: for exampel do {x <- get; return (chr x)} gets the state integer and turns in into a character without changing the state integer.
13:54:58 <hatds> if you've ever visualized IO String as a function TheWorld -> (TheWorld , String) then it is the same idea
13:55:02 <Cale> RLa: The point is that during a big compound state computation, you will have one type 's', which is the type of the state as it is updated over time, but many different types 'a', which are the types of the results of subcomputations.
13:55:02 <RLa> vixey, but what should be *value* after 3 increments?
13:55:02 <monadic_kid> vixey: thats not very nice of you tell me to stop doing something and not even tell me what it is
13:55:10 <vixey> RLa: it will be "foo"
13:55:21 <kerlo> I came across a weird monad today: the (,) (Blah -> Blah) monad.
13:55:45 <vixey> kerlo, isn't that just state monad?
13:55:51 <vixey> or it is slightly different..
13:55:59 <kerlo> It is different.
13:56:06 <lightstep> 4
13:56:16 <kerlo> And not just cosmetically.
13:56:19 <roconnor> kerlo:  writer monad with the endo monoid?
13:56:57 <kerlo> I don't know.
13:57:24 <roconnor> @unmlt (Writer (Endo b) a)
13:57:25 <lambdabot> Maybe you meant: unmtl unpl
13:57:31 <roconnor> @unmtl (Writer (Endo b) a)
13:57:31 <lambdabot> (a, Endo b)
13:57:52 <kfranke> anyone know what "data Char = C# Char#" in GHC.Types means?
13:58:12 <kfranke> what's with the #s?
13:58:13 <EvilTerran> Writer (Endo b) a ~~ (b -> b, a)
13:58:15 <hatds> Char#  is an 'unboxed' char
13:58:22 <pumpkin_> kfranke: C# is the box
13:58:31 <roconnor> ans Writer (Endo b) ~~ (,) (b -> b)
13:58:33 <roconnor> and
13:58:53 <EvilTerran> kfranke, the source of GHC.Types is weird internals stuff
13:58:57 <monochrom> # is another letter in names.
13:59:46 <pumpkin_> you need LANGUAGE MagicHash to make GHC let you use the hash
13:59:55 <rwmjones> gaaa ... how do I get a list of functions and modules that they come from?  I can't fix the error "Not in scope: `throwDyn'"
13:59:56 <mle> kfranke: it's warning you that unboxed types are involved.
14:00:16 <vixey> @hoogle throwDyn
14:00:16 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
14:00:17 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
14:00:38 <hatds> hoogle, also ghc's webpage has an index of the libraries
14:00:38 <rwmjones> so import Control.Execption?
14:00:46 <vixey> yes
14:01:02 <rwmjones> ok thanks/me tries it
14:01:05 * rwmjones tries it
14:01:06 <duaneb> hi people
14:01:06 <rwmjones> even
14:01:13 <duaneb> anyone know a guide for haskell optimization?
14:01:31 <duaneb> s/haskell/ghc/
14:02:03 <rwmjones> hmm that didn't seem to work?
14:02:14 <EvilTerran> duaneb, "understand strictness".
14:02:30 <sjanssen> duaneb: there's a guide on haskellwiki
14:02:43 <sjanssen> http://www.haskell.org/haskellwiki/Performance/GHC
14:02:53 <kfranke> thanks. so... I'll just pretend I didn't see it for now.
14:02:55 <duaneb> sjanssen: ahh, that's precisely what I was looking for
14:03:37 <EvilTerran> duaneb, some other sections under /haskellwiki/Performance may also be relevant
14:04:57 <necroforest> duaneb, rewrite it in C
14:05:37 <hatds> that'd take too long...  write a haskell program to rewrite it in C
14:05:51 <necroforest> haha
14:06:09 <necroforest> why don't you skip the middle man and write a haskell program that just outputs machine code?
14:06:12 <necroforest> you could call it GHC
14:07:48 <duaneb> EvilTerran: yea, exploring them now
14:08:05 <duaneb> necroforest: I'm not looking for insane stuff, I just want to know how to make my existing code faster
14:08:08 <duaneb> just general performance tips
14:09:09 <necroforest> i was just being sarcastic
14:09:13 <necroforest> disregard anything i said
14:12:15 --- mode: ChanServ set +o mauke
14:12:15 --- mode: mauke set -b *!*@129.174.73.75
14:12:31 <RLa> vixey, may i pm you?
14:13:15 --- mode: mauke set -o mauke
14:18:31 <RLa> when implementing my own state monad do i have to implement evalState and other from MonadState class or just get/set functions?
14:19:07 <roconnor> RLa: you will probably want to write an evalState, but it isn't needed to be an instance of MonadState
14:19:10 <Saizan_> the MonadState class has only put and get
14:19:26 <RLa> hm
14:19:40 <roconnor> not all instances of MonadState have an evalState as such
14:19:47 <roconnor> but they usually have something like it.
14:21:39 <RLa> ok, i think i'm starting to get it
14:21:44 <roconnor> :)
14:21:52 <roconnor> @quote MonadState
14:21:52 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
14:22:22 <RLa> btw, is it usual that value part gets lost or overwritten with state part?
14:22:59 <roconnor> it usually isn't really lost
14:23:42 <RLa> put s = State $ \_ -> ((), s) <- doesn't it get overwritten with ()?
14:23:52 <roconnor> do { x <- foo; put x; return x} -- notice that is still accessable even though put "loses the value"
14:25:15 <EvilTerran> RLa, nothing is overwritten, in any case; haskell is a pure language, remember.
14:25:57 <Cale> I pasted an example the other day...
14:25:58 <EvilTerran> while the State monad is akin to having a mutable cell "running alongside" your code, it's faked by a series of immutable cells
14:26:17 <Cale> I think in order to understand the State monad, it can help to understand how to write things without it.
14:26:25 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4735
14:26:32 <EvilTerran> ?go you could have invented monads
14:26:33 <lambdabot> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
14:26:33 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
14:26:38 <Cale> this shows the same algorithm implemented with and without the State monad
14:26:44 <RLa> i have written all my previous haskell programs without any monad
14:26:53 <EvilTerran> ^ i like that one as an example of working without the state monad
14:26:55 <Cale> RLa: Perhaps before you look at that...
14:27:03 <Cale> RLa: Consider this tree type:
14:27:05 <pumpkin_> you can do everything but IO without touching monads, but it may be more painful than it needs to be
14:27:13 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a) deriving Show
14:27:17 <EvilTerran> well, working without a monad, identifying the implicit monadic structure, then abstracting it out
14:27:18 <RLa> yes
14:27:41 <pumpkin_> yeah :)
14:27:42 <Cale> Write a function which takes a tree of this type, and relabels it from left to right with the numbers 0 and up.
14:27:46 <RLa> i have used to threat the state through extra arguments
14:27:54 <Cale> RLa: right.
14:28:08 <Cale> RLa: and you return the next value as part of a pair, right?
14:28:36 <Cale> Because the label you want to apply to the root of the tree depends on how many labels get used up in the left subtree
14:28:47 <Cale> So you have to do that first, and see how many labels are used up.
14:29:44 <RLa> yes, therefore i use extra parameter to indicate starting value of label and after labelling subtree i use return value to see what was last label
14:29:45 <EvilTerran> me notes that, with lazy peano numerals, it wouldn't actually be happening "first" (but that's purely incidental)
14:29:52 <Cale> RLa: right
14:29:52 <EvilTerran> er, /me ...
14:30:24 <Cale> So your helper function looks like, perhaps,  Tree a -> (Integer -> (Integer, Tree Integer))
14:30:35 <Cale> yeah?
14:30:38 <RLa> yes
14:31:02 <Cale> and of course, we know that  Integer -> (Integer, Tree Integer)  is basically the same as  State Integer (Tree Integer)
14:31:15 <mauke> unmtl!
14:31:20 <Cale> So this is exactly the sort of pattern which the State monad abstracts.
14:31:48 <Cale> @unmtl State Integer (Tree Integer)
14:31:49 <lambdabot> Integer -> (Tree Integer, Integer)
14:32:08 <hatds> what is unmtl?
14:32:11 <Cale> Okay, the mtl puts the state and result in the wrong order ;)
14:32:30 <mauke> @help unmtl
14:32:31 <lambdabot> unroll mtl monads
14:32:32 <Cale> hatds: It unravels the monad transformer library type definitions
14:32:36 <roconnor> another problem with the mtl
14:32:36 <duaneb> who maintains Haskell's programs in the shootout?
14:32:44 * roconnor glares at the haskell platform.
14:32:48 <Cale> duaneb: The community as a whole
14:33:27 <hatds> (awe.. group hug guys!)
14:33:31 <duaneb> Are the programs a good reference for speed?
14:34:00 <Cale> duaneb: They're exaggerated.
14:34:14 <RLa> ok, i'm going to try to use my state monad for that tree example
14:34:16 <Cale> duaneb: Normally, you don't have to be nearly so severe.
14:35:43 <Cale> The two most important points about understanding and improving the performance of Haskell code, I would say, are 1) Use the profiler to find out what is taking the most time/doing the most allocation, and 2) Learn how lazy evaluation works.
14:36:42 <Cale> The best way to get a feel for lazy evaluation is probably to do a bit of it by hand, step by step, to reduce expressions.
14:36:46 <roconnor> 3) apply a Codensity Monad transform. :)
14:37:13 <Cale> You get a sense of the memory that a program will use by the size of the expressions you get while evaluating, and you get a sense of the time just from the number of steps.
14:37:23 <duaneb> Well, I already understand lazy evaluation
14:37:50 <zakwilson> Are there plans to make programs compiled with GHC detect the number of available cores automagically so they don't need a command-line argument telling them how many to use?
14:38:24 <Cale> So, once you know how lazy evaluation works, you can get good at spotting problems like large expressions getting built up in the parameter to some recursive function, and know where to apply strictness annotations to fix things.
14:39:13 <duaneb> Like, here is my current program: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4751#a4751
14:39:13 <Cale> zakwilson: Well, that might be nice. I actually think there should be an API for it, so the program itself can determine the number of cores and tell its own RTS how many to use.
14:39:21 <RLa> Cale, that tree labelling should label tree by depth-first travel, e.g 0 should appear in leftmost leaf?
14:39:28 <Cale> RLa: yeah
14:39:28 <duaneb> It's just something I wrote a little while back that happens to run slowly :P
14:39:56 <duaneb> Cale: how would you speed that up?
14:40:22 <hatds> always use fold' (+) 0 instead of sum
14:40:26 <thoughtpolice> zakwilson: yes, it already does so
14:40:26 <hatds> well, almost always :)
14:40:31 <hatds> foldl' I mean
14:40:32 <thoughtpolice> zakwilson: well, the HEAD branch does anyway
14:40:48 <Cale> duaneb: can you give me some args to run it with?
14:41:13 <thoughtpolice> zakwilson: it can detect the number of cores automatically if you pass your executable just the '-N' rts flag, e.g. './foo 1 2 3 +RTS -N' will automatically use whatever cores you have available
14:41:20 <pejo> zakwilson, there's a getNumberofProcessors() in HEAD in the RTS. I think it's used.
14:41:25 <Cale> oh
14:41:28 <Cale> it's just a number :)
14:41:32 <duaneb> yep :)
14:41:55 <thoughtpolice> zakwilson: GHC also has runtime system hooks, so you can build your executable and specify that it should 1. be built with -threaded and 2. build the rts '-N' option into the executable
14:42:08 <duaneb> oh my :|
14:42:13 <duaneb> I just looked at the generated assembly :|
14:42:23 <thoughtpolice> zakwilson: see http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
14:42:36 <zakwilson> thoughtpolice: that seems to answer my question.
14:42:50 <Cale> duaneb: well... I think the problem is possibly algorithmic
14:43:01 <Cale> duaneb: It appears you're searching through all subsets of a set?
14:43:09 <duaneb> yes
14:43:09 <Cale> That's necessarily exponential...
14:43:49 <duaneb> It is
14:43:56 <duaneb> but it still runs ~2x slower than java
14:43:59 <thoughtpolice> zakwilson: but yeah, that feature is only in HEAD. when 6.12 is out though you can just build your executables like that with cabal or whatever and build the -N option into the rts and you're done
14:44:13 <thoughtpolice> which is pretty nifty, really
14:44:26 <RLa> wow it works
14:44:32 <rawrsy> :ba
14:44:34 <Cale> duaneb: You are of course compiling with -O2...
14:45:42 <duaneb> I am.
14:46:00 <duaneb> my flags: ghc subsets.hs -o subsets -L/opt/local/lib -O2 -funfolding-use-threshold=16 -fexcess-precision -optc-O3 -optc-ffast-math
14:46:56 <duaneb> I feel like I should try using something like unboxed types, but I have no idea where to start :P
14:46:57 <kerlo> Did someone say "use foldl' (+) 0 instead of sum"?
14:47:10 <RLa> Cale, value part is used for tree and state part for current label?
14:47:17 <RLa> (in that tree example)
14:47:18 <Cale> RLa: yes
14:47:41 <Cale> duaneb: Okay, so about half the time is spent in sumFaces, and about half in subsets
14:47:54 <pumpkin_> kerlo: yup
14:47:55 <RLa> hm, i would pick version without monads any time
14:48:18 <Cale> duaneb: Of course, you're recomputing sqrt of the numbers over and over
14:48:21 <kerlo> Don't tell me the default implementation under GHC is slower than that.
14:48:38 <pumpkin_> kerlo: it's h98's fault!
14:48:39 <pumpkin_> ;)
14:48:46 <kerlo> @src sum
14:48:46 <lambdabot> sum = foldl (+) 0
14:48:55 <kerlo> sum doesn't actually have to be implemented that way, does it?
14:49:02 <pumpkin_> according to the standard, yeah
14:49:18 <Cale> RLa: This case is rather simple, but the problem with the version without the state monad is that you can mess up the wiring of the extra parameters.
14:49:18 <gwern> so I have this shell command, 'ls | /usr/bin/ghc -e 'interact $ unlines . sortBy (\a b -> if length a >= length b then LT else GT) . lines'', but I'm a little dissatisfied. isn't there an easier way to sort a list of String by size?
14:49:23 <vixey> the standard is outdated
14:49:37 <vixey> :t comparing length
14:49:38 <lambdabot> forall a. [a] -> [a] -> Ordering
14:49:45 <vixey> :t (\a b -> if length a >= length b then LT else GT)
14:49:46 <pumpkin_> sortBy (comparing length)
14:49:46 <lambdabot> forall a a1. [a] -> [a1] -> Ordering
14:49:53 <Cale> duaneb: So let's start by avoiding the recomputation of the sqrts over and over.
14:50:14 <vixey> @let onLines f = unlines . f . lines
14:50:15 <lambdabot>  Defined.
14:50:19 <gwern> comparing?
14:50:20 <gwern> @hoogle comparing
14:50:20 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:50:21 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
14:50:27 <duaneb> Cale: you mean caching?
14:50:34 <mauke> perl -e 'print sort {length $b <=> length $a} <>'
14:50:38 <pumpkin_> comparing is pretty similar to on
14:50:45 <gwern> > comparing (>) 5 6
14:50:46 <lambdabot>       No instance for (Ord (b -> Bool))
14:50:47 <lambdabot>        arising from a use of `compari...
14:50:48 <Cale> duaneb: Well, we can zip nums with the sqrts, and operate on that list.
14:50:53 <duaneb> Cale: oh, right
14:50:57 <pumpkin_> :t on
14:50:58 <gwern> @src comparing
14:50:58 <lambdabot> Source not found. Wrong!  You cheating scum!
14:50:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:51:00 <pumpkin_> :t comparing
14:51:01 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:51:03 <vixey> mauke wins
14:51:30 <gwern> vixey: the point wasn't to do it in perl! I'm sure there's some option to gnu sort or ls or something that'd do it as well
14:51:54 <EvilTerran> ... ls?!
14:51:57 <pumpkin_> interact $ unlines . sortBy (comparing length) . lines
14:52:10 <mauke> possibly flip comparing
14:52:12 <EvilTerran> pumpkin_, that wouldn't work in ghci -e, though =/
14:52:27 <EvilTerran> ?index sortBy
14:52:28 <lambdabot> Data.List
14:52:33 <EvilTerran> ?index comparing
14:52:33 <lambdabot> bzzt
14:52:40 <pumpkin_> he was using it before though
14:52:41 <pumpkin_> hmm
14:52:46 <pumpkin_> that's in Data.Ord
14:52:55 <pumpkin_> and on is in Data.Function :/
14:53:11 <MarkT-> I have two vectors v1 and v2 that are not parallel to eachother, and points P and Q that lie somewhere on a plane that is parallel to both vectors. Is there a way to find real values s and t such that Q=P+s*v1+t*v2?
14:53:14 <pumpkin_> both should be moved to Prelude :P
14:54:36 <vixey> MarkT-: probaby use math or something
14:59:04 <idnar> @type (compare `on`)
14:59:05 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
14:59:11 <mreh_> what is this doing: sethAcc a s = s{ship= (ship s){hAcc= a}}
14:59:12 <idnar> @type comparing
14:59:14 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:59:57 <lightstep> mreh_, it modifies that hAcc component of the ship component of `s' to `a'
14:59:59 <idnar> mreh_: making my head hurt, and modifying some nested record value
15:00:26 <mreh_> it looks like retreiving a ship record from within a ship record
15:00:29 <mreh_> it's horrible isnt it
15:01:45 <Cale> ... where did duaneb go?
15:01:46 <mreh_> (ship s) gets the ship record, {hAcc = a} updates the record
15:01:59 <mreh_> so why the need for the outer s{...}
15:02:09 <Cale> I made his program run over 10 times faster...
15:02:33 <mauke> quit 6 minutes ago
15:02:37 <Cale> yeah
15:02:38 <mreh_> his computer overheated
15:02:42 <Cale> heh
15:02:45 <pshc> Is there any way to write something like "showCtors :: Show a => String"? Do I have to pass in a dummy value with something like (showCtors :: Show a => a -> String) always or is there a way to parameterize explicitly with a type?
15:02:55 <yitz> mreh_: the ship s inside of s {ship=...} is a standard update idiom. The fact that ship s is itself a record makes it look messier.
15:03:25 <Cale> pshc: We don't have explicit type application like that, so yeah, you have to take a dummy parameter to select the instance.
15:03:25 <mreh_> it's f*****g horrib;e
15:03:40 <pshc> OK, thanks
15:04:03 <Cale> pshc: It's common to pass (undefined :: TheTypeThatIWant)
15:04:11 <pshc> Ah hehe
15:04:14 <pshc> Sounds good
15:04:39 <mreh_> s{ship= ... } i can't really understand how that works
15:04:56 <mreh_> ship is the function...
15:05:13 <Cale> mreh_: Looks like record update syntax
15:05:25 <mreh_> really? okay
15:05:31 <yitz> mreh_: the name of a record component can be used as a function outside of the record notation. Kind of neat actually.
15:05:37 <Cale> mreh_: That defines a value whose fields are the same as s, but in which ship is different
15:05:47 <Cale> mreh_: It just copies of course.
15:05:56 <yitz> mreh_: the record system has its problems, but that actually is one of its good points.
15:06:07 <Cale> mreh_: But since the fields are all pointers to values, that copy is cheap :)
15:07:11 <Cale> @tell duaneb Replace your subsets function with subsequences from Data.List
15:07:12 <lambdabot> Consider it noted.
15:07:29 <mreh_> so i could write: s{foo=...}
15:07:48 <pshc> on that topic, I don't suppose there's a neater way to write "r { field = updateSomehow (field r) }"?
15:08:08 <yitz> pshc: that's how you'd usually write it
15:08:10 <Cale> pshc: no, though there is record punning which can help
15:08:11 * hatds avoids records except as convenient newtype wrappers
15:08:19 <EvilTerran> pshc, sadly not, because haskell's record syntax is a bit rubbish
15:08:30 <Cale> pshc: When you pattern match the record, you can write something like...
15:09:36 <Cale> foo (r@Rec{..}) = ...
15:09:56 <Cale> and that will make the fields of that record available as their own names
15:09:59 <mreh_> is that an actual 'as' pattern
15:10:02 <Cale> So you don't have to apply them.
15:10:17 <Cale> Er, actually, skip the as
15:10:20 <pshc> Oh, so "{..}" is an actual syntax fragment?
15:10:21 <Cale> foo (Rec{..}) = ...
15:10:23 <Cale> yes
15:10:23 <pshc> Nice
15:10:31 <Cale> but the ... obviously is not ;)
15:10:45 <pshc> (...) = dwim
15:10:46 <thoughtpolice> well, it can be!
15:10:56 <thoughtpolice> RecordWildCards extension :)
15:11:11 <monadic_kid> mreh_: yeah @ are as patterns
15:11:16 <Cale> {-# LANGUAGE NamedFieldPuns, RecordWildCards #-}
15:11:41 <Cale> actually, it's the latter which you're using here, but the former is handy too
15:11:44 <mreh_> i just wondered if it meant something else in this context
15:12:07 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#sect7.3.12
15:12:31 <Cale> Those two sections document it.
15:12:34 <idnar> pshc: what is the type of dwim? :)
15:13:26 <pshc> MagicHappensHere a => a
15:13:58 * Axman6 senses some unsafePerformIO nonsense...
15:16:11 <idnar> dwim :: Brain -> IO ()
15:16:25 <idnar> unsafeDwim :: forall a. a
15:17:44 <mauke> wtf :: Untypeable a => a
15:18:57 <idnar> this :: Untouchable a => a
15:19:55 <daf> idnar: break down!
15:20:07 <Axman6> believe :: NotButter a => Butter -> a
15:20:31 <hatds> lol
15:20:49 <idnar> daf: stop >> (collaborate . listen)
15:21:32 <Gracenotes> believing a = a >> believing a
15:21:47 <Axman6> heh
15:22:29 <inetic> hi there, is here someone who has played with haskell-sdl? I can not find a function for per pixel operations on a surface in the documentation.
15:23:41 <monadic_kid> inetic: surfaceGetPixels
15:24:30 <monadic_kid> inetic: did you just want to get access?
15:25:25 <inetic> monadic_kit: thanks for response, I would like to draw some primitives onto the surface
15:25:28 <Gracenotes> in C, you access a surface's->pixels to get a modify for the purpose of modification, so that makes sense
15:25:36 <Gracenotes> *to get a pointer
15:27:24 <inetic> aha, I see, I'm a haskell and sdl beginner, but I think I can google from now on, thanks!
15:30:46 <MrMTDew> I am completely new at haskell and I am working on a programming assignment...can somebody please help
15:31:32 <vixey> MrMTDew: with what?
15:31:48 <MrMTDew> I am trying to write a function called insertInAll
15:32:10 * EvilTerran would propose foo { bar <- ... } for "foo { bar = (...) (bar foo) }"
15:32:10 <MrMTDew> it takes an int and a list of list and it is to insert that int in all of the sub lists
15:32:22 <MrMTDew> I have it working for the most part but I can work this one issue out
15:32:40 <MrMTDew> This is the compile error I am getting
15:32:49 <vixey> all of the sublists?
15:32:52 <MrMTDew> *Main> :load "project3.hs"
15:32:53 <MrMTDew> [1 of 1] Compiling Main             ( project3.hs, interpreted )
15:32:53 <MrMTDew> project3.hs:6:20:
15:32:53 <MrMTDew>     Couldn't match expected type `Int' against inferred type `[Int]'
15:32:53 <MrMTDew>     In the expression: (a : head b)
15:32:53 <MrMTDew>     In the first argument of `(:)', namely `[(a : head b)]'
15:32:55 <MrMTDew>     In the expression: [(a : head b)] : [(insertInAll a (tail b))]
15:32:57 <MrMTDew> Failed, modules loaded: none.
15:33:01 <vixey> MrMTDew: Do you have a function thta computes all of the sublists?
15:33:14 <MrMTDew> yeah all of the sublists
15:33:23 <vixey> what's the function called?
15:33:41 <MrMTDew> Here is my function
15:33:41 <MrMTDew> insertInAll :: Int -> [[Int]] -> [[Int]]
15:33:41 <MrMTDew> insertInAll _ [] = []
15:33:41 <MrMTDew> insertInAll a b = [(a:head b)]:[(insertInAll a (tail b))]
15:33:44 <wh1t3> a:head b will evaluate into a list
15:33:52 <wh1t3> which u cannot cons onto another list
15:33:52 <Gracenotes> @type (:)
15:33:53 <lambdabot> forall a. a -> [a] -> [a]
15:33:55 <vixey> MrMtDew: try to answer the questions I asked you
15:34:12 <MrMTDew> a function that computes all of the sublists?
15:34:16 <MrMTDew> that question
15:34:16 <vixey> yes
15:34:39 <wh1t3> he has a list of lists, those inner lists are the sublists he is referring to i imagine
15:34:47 <MrMTDew> I don't think I do but the way my professor described it I dont need to do that
15:34:52 <MrMTDew> unless I am mistaken
15:35:08 <MrMTDew> yeah that is it whlt3
15:35:40 <MrMTDew> I am not looking for the answer explicitly...I am looking for what I am doing wrong in the last insertInAll function
15:35:57 <wh1t3> u are using : on two lists
15:36:02 <roconnor> @hoogle PartitionEithers
15:36:02 <lambdabot> No results found
15:36:05 <wh1t3> instead of on an element and a list
15:36:09 <MrMTDew> because if I do
15:36:09 <MrMTDew> insertInAll a b = [a:head b]
15:36:09 <MrMTDew> it works fine
15:36:25 <monadic_kid> MrMTDew: by the way there is lambdabot here that will evalute haskell expressions so that migiht help you a bit ;)
15:36:29 <wh1t3> sure, a is an element and head b returns a list
15:36:38 <roconnor> @hoogle partitionEithers
15:36:38 <lambdabot> No results found
15:37:00 <pumpkin_> , [$ty| partitionEithers |]
15:37:00 <MrMTDew> I am not sure what a lambdabot is :/
15:37:00 <mauke> MrMTDew: as far as I can see the problem is the [ ] [ ] around the arguments to (:)
15:37:06 <lunabot>  forall a b . [] (Either b a) -> ([] b, [] a)
15:37:24 <monadic_kid> MrMTDew: irc bot
15:37:48 <MrMTDew> I never actually used IRC before...I have just known about IRC
15:38:00 <monadic_kid> > print "hello world"
15:38:01 <lambdabot>   <IO ()>
15:38:02 <MrMTDew> so not sure what the bot will do for me
15:38:30 <hatds> > reverse "Hello"
15:38:32 <lambdabot>   "olleH"
15:39:02 <wh1t3> a:(head b) will evaluate into a list
15:39:05 <monadic_kid> MrMTDew: give it haskell expressions to evalute and tell you the type of expressions among many other things, its useful when you wanna talk about code in here
15:39:25 <wh1t3> so if u go ahead and cons that to the recursive evaluation of the rest of the lists, it will give you an error
15:39:40 <mauke> it's spelled "you"
15:40:02 <MrMTDew> ok...it compiled fine when I removed the [][] around the arguments
15:40:07 <wh1t3> i realised that haflway throught the sentence as you can see :)
15:40:09 <MrMTDew> let me see if this works
15:40:33 <mauke> wh1t3: heh
15:41:16 <mauke> :t map . (:)
15:41:17 <lambdabot> forall a. a -> [[a]] -> [[a]]
15:41:24 <MrMTDew> ok it is working now...so what was the [][] around the arguments doing?
15:41:50 <mauke> MrMTDew: [x] is a list of length 1, containing x
15:41:58 <MrMTDew> yup
15:42:09 <mauke> so it wrapped those values in lists
15:42:54 <MrMTDew> so I was trying to return [[[s]]]
15:42:59 <MrMTDew> something of that nature
15:43:10 <mauke> something like f x = [f ...] can never compile
15:43:39 <vixey> :t \f x -> [f]
15:43:40 <lambdabot> forall t t1. t1 -> t -> [t1]
15:43:56 <mauke> if you try to compute the return type from that, you get something like "list of list of list of list of ..."
15:44:22 <mauke> > let f x = [f (x + 1)] in f
15:44:23 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
15:44:23 <lambdabot>        Expect...
15:45:10 <MrMTDew> ok...I think I see what you are saying
15:45:53 <monadic_kid> MrMTDew: you see lambdabot now ;)
15:46:19 <Gracenotes> or "emily"
15:46:27 <monadic_kid> @botsnack
15:46:27 <lunabot>  :)
15:46:27 <lambdabot> :)
15:46:28 <mauke> I don't know how to explain this in an obvious way; I've gotten so used to type inference that I just "see" the types flow through the expressions
15:46:32 <mauke> :/
15:46:33 <MrMTDew> yeah...somewhat
15:46:47 <MrMTDew> that is fine mauke
15:46:52 <MrMTDew> you have been a huge help
15:47:20 <MrMTDew> again I am seeing functional languages for the first time in my life 6 weeks ago and Haskell just this week
15:47:26 <vixey> "blond, brunette, redhead, implicit coercian from Int to Integer"
15:47:32 <MrMTDew> so I have quite the huge learning curve
15:48:02 <mauke> oh, what language did you start with?
15:48:07 <MrMTDew> lisp
15:48:19 <MrMTDew> then prolog <---totally lost on this one too
15:48:29 <MrMTDew> lisp I found easy
15:48:34 <LeoD> which lisp? :)
15:49:06 <vixey> yeah lots of people don't get prolog
15:49:13 <MrMTDew> not sure leoD
15:49:23 <mauke> did it contain "defun"?
15:49:33 <MrMTDew> yeah mauke
15:49:34 <ksf> referential transparency is just a hack around schroedinger's cat.
15:49:43 <burp_> lol
15:50:12 <mauke> hmm. any "funcall" or "#'"?
15:50:17 <ksf> instead of facing reality, we claim that a thunk can't be bottom and not bottom at the same time, until we look at it.
15:50:28 <LeoD> hahaha
15:50:36 <MrMTDew> I thank you all for your help..I will likely be back for help on some of these other elementary functions
15:50:54 <Gracenotes> >:3
15:51:04 <mauke> MrMTDew: btw, your function can be shortened to insertInAll = map . (:)
15:51:19 <mauke> >:)
15:51:23 <MrMTDew> we used gcl
15:51:29 <LeoD> now you're scaring him :p
15:51:36 <MrMTDew> therefor common lisp
15:52:04 <MrMTDew> yeah...I will try that....someday
15:52:05 <MrMTDew> lol
15:52:31 <MrMTDew> thanks people...back later I am sure
15:52:50 <mauke> (defun insert-in-all (x &rest xss) (mapcar (lambda (xs) (cons x xs)) xss))
15:53:09 <ksf> this, of course, brings up the question whether or not the universe is referentially transparent.
15:53:31 <yitz> > let insertInAll = map . (:) in insertInAll "mauke is " ["awesome", "helpful", "cool"]
15:53:32 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
15:53:37 <yitz> heh
15:53:37 <RLa> is that true that haddock does not support unicode?
15:53:49 <f4hy> > show 0.000005
15:53:50 <lambdabot>   "5.0e-6"
15:54:04 <yitz> > let insertInAll = map . (:) in insertInAll "mauke is " [["awesome"], ["helpful"], ["cool"]]
15:54:05 <lambdabot>   [["mauke is ","awesome"],["mauke is ","helpful"],["mauke is ","cool"]]
15:54:14 <f4hy> Alright so how to I print floats without scientific notation
15:54:18 <vixey> lol
15:54:28 <vixey> mauke uber alles
15:54:36 <MrMTDew> lol
15:54:47 <ksf> f4hy, have a look at Data.Numeric
15:54:57 <f4hy> ksf: thanks
15:54:57 <mauke> > showFFloat Nothing 0.000005 ""
15:54:59 <lambdabot>   "0.000005"
15:55:24 <pumpkin_> I wonder how many more people will tell the Just 3 >>= (1+) guy the same thing
15:55:53 <vixey> > Just 3 >>= (1+)
15:55:54 <lambdabot>       No instance for (Num (Maybe b))
15:55:54 <lambdabot>        arising from the literal `3' at ...
15:56:11 <pumpkin_> (on haskell-cafe)
15:56:19 <yitz> f4hy: Numeric
15:56:38 <yitz> @type Data.Numeric.showFFloat
15:56:39 <lambdabot> Couldn't find qualified module.
15:56:44 <yitz> @type Numeric.showFFloat
15:56:45 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
15:57:11 <yitz> probably should have been Data.Numeric though.
15:57:21 <ksf> ...yet another reason for http://hackage.haskell.org/trac/ghc/ticket/3209
15:59:01 <yitz> ksf: would levenshtein have caught that one?
15:59:17 <Gracenotes> or even just case-insensitive search.
15:59:28 <Gracenotes> in that case
15:59:30 <ksf> depends on how it's used, it's only the basis on which you build involved heuristics.
15:59:41 <Gracenotes> sometimes capitals are inconsistent-ish in libraries
16:00:08 <ksf> another idea is to levenshtein over type signatures.
16:00:11 <Gracenotes> or should I say... MAJUSCULE </awesome>
16:00:19 <yitz> "Stack overflow. Did you mean foldl'?"
16:00:27 <ksf> lol
16:00:38 <solrize> > Just 3 >>= (return . (1+))
16:00:39 <lambdabot>   Just 4
16:00:52 <ksf> > (1+) <$> Just 3
16:00:53 <lambdabot>   Just 4
16:00:54 <Gracenotes> yeah, static analysis and a good text editor is important. No need tacking too many features on to GHC, more like an interface to GHC other apps can use
16:02:35 <pumpkin_> what the hell is going on on haskell-cafe
16:02:54 <pumpkin_> we now have 12 responses to a simple question, all pretty much saying the same thing
16:03:24 <RLa> anyone here using haddock, how to make non-ascii chars display correctly?
16:03:52 <adekoba> why does ghci's global random number generator only return as 1?
16:04:00 <ksf> it's the "I grokz monad0rz too" effect.
16:04:25 <pumpkin_> ksf: I would hope that most of these people don't need to prove that anymore :P
16:04:27 <yitz> pumpkin_: sounds like #haskell
16:04:39 <pumpkin_> yitz: this is the most extreme case I've seen so far though :P
16:04:46 <pumpkin_> someone asked the question, I answered it a few minutes later
16:04:54 <pumpkin_> and now, several hours later, people are still saying the same thing I said :P
16:05:29 <pumpkin_> granted, I may not have been super clear, so maybe a clarification or two was warranted, but another 11 restatements?
16:05:31 <pumpkin_> :P
16:05:42 * pumpkin_ shrugs
16:07:52 <yitz> pumpkin_: the real answer is: pay attention to what the type checker is saying.
16:09:41 <yitz> hey, there's an idea. a ghc extension that automatically mails every type error to haskell-cafe.
16:10:35 <idnar> ahaha
16:10:43 <telemachus> ghc 6.10.3 + haskell-platform = no joy
16:10:52 <telemachus> which I'm guessing has to do with no more editline
16:10:57 <telemachus> yup...
16:11:00 <yitz> telemachus: really? what went wrong?
16:11:35 <telemachus> The build tells me that I don't have editline and that it should have been included with 6.10.2
16:11:53 <telemachus> which seems true, looking at the release notes to 6.10.3
16:12:03 <telemachus> GHCi uses Haskeline, rather than editline, for line editing. This fixes a crash when pressing control-C on some platforms, removes a C library dependency, and provides a better user interface.
16:12:45 <yitz> yeah, I think most people will be happy to see editline go.
16:13:15 <mauke> is Haskeline better than readline?
16:13:24 <telemachus> yitz: fair enough, but is the bailout in the build process simply due to a dependency check or is it a _real_ dependency of haskell-platform?
16:13:25 <yitz> Igloo, telemachus just complained that HP fails on 6.10.3 because of missing editline.
16:13:49 <yitz> mauke: I haven't tried it, but it would take very much.
16:13:51 <telemachus> yitz: see, that makes me sound like a complainer - I hate sounding like a complainer :)
16:14:01 <magthe> dons: from my POV it isn't so harmless that the upgrade of haskell-time doesn't recompile its dependants
16:14:10 <yitz> telemachus: sorry, that's not what I meant. :)
16:14:23 <telemachus> yitz: I know - was kidding - no worries
16:14:48 <telemachus> I've been unable to build haskell-platform on OS X, and I was hoping that the upgrade of GHC would help
16:14:48 <yitz> @seen dons
16:14:49 <lambdabot> dons is in #haskell-in-depth, #concatenative, #arch-haskell, #darcs, #yi, #xmonad, #ghc and #haskell. I last heard dons speak 1h 18s ago.
16:14:49 <pejo> mauke, it has a better license.
16:15:00 <mauke> pejo: irrelevant to me
16:15:14 <mauke> I don't distribute ghci, I only want to use it
16:15:23 <telemachus> but now actually, haskell-platform won't even build on Debian
16:15:28 <telemachus> so frying pan -> fire
16:15:44 <yitz> telemachus: it's a minor but embarassing problem.
16:16:37 <telemachus> yitz: No worries. I knew I was taking a chance installing the latest shiny toy instantly
16:17:10 <mauke> pejo: the important things are line editing, unicode (utf-8) awareness, and history-search-{backward,forward}
16:17:37 <telemachus> pejo: what is the new license?
16:17:57 <telemachus> (nothing about that in the release notes...)
16:18:39 <telemachus> ah, wait - you mean Haskeline vs. editline
16:18:57 <telemachus> I was thinking ghc itself changed license - dumb of me
16:19:50 <yitz> mauke: editline introduced line editing weirdness for me. I hope haskelline fixes it.
16:20:32 <mauke> I tried editline back when 6.10.1 came out
16:20:37 <ksf> finally the fsf won't hover over it like damocles sword, threatening to gpl ghc because it _is able to_ interface with readline.
16:20:47 <mauke> it made ghci hang on startup; I haven't used it since
16:21:17 <mauke> (also, the fsf can't gpl ghc)
16:21:40 <yitz> mauke: that's kind of a problem in all three of the areas you mentioned.
16:21:49 <dons> the haskell wikipedia page is pretty crummy :/
16:22:04 <dons> i feel kinda depressed every time I see it
16:22:12 <ksf> nah, but they could claim that every code that is able to link to readline may only be linked with gpl-compatible stuff, that's what i meant with gpl'ing.
16:22:12 <yitz> dons: HP won't compile with 6.10.3, complains about editline.
16:23:07 <dons> yitz: indeed. http://trac.haskell.org/haskell-platform/ticket/44
16:23:10 <yitz> dons: (reported by telemachus, here on the line)
16:23:16 <dons> :)
16:23:18 <mauke> well, ghc can still link to readline
16:23:20 <dons> weeee're on it.
16:23:33 <yitz> ok, tnx
16:27:15 <yitz> telemachus: so try cabal install editline, then try haskell platform again.
16:29:17 <dons> telemachus: right.
16:29:47 <telemachus> yitz: cool, will do
16:30:02 <dons> but using 6.10.3 isn't officially supported yet (though prob. you'll be fine)
16:31:26 <magthe> dons: I found your comment on the issue with `time` to be less than helpful :(  I ended up having to re-compile all packages that depend on it (especially MissingH)
16:32:05 <magthe> dons: is there some easy way of doing it, rather than the song and dance I just performed with yaourt?
16:32:12 <dons> magthe: not that I know of.
16:32:18 <dons> yaourt isn't as smart as cabal-install
16:32:23 <dons> but also: was it actually going to break anything?
16:32:26 <Elly> yaourt? :O
16:32:35 <telemachus> dons and yitz: after install editline, HP builds just fine
16:32:36 <telemachus> thanks
16:32:42 <dons> btw, anyone know how to use this ? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/visual-graphrewrite-0.3.2
16:32:46 <dons> looks intriguing
16:32:50 <telemachus> (on Debian - now to try OS X)
16:33:28 <magthe> dons, yes it did... well it didn't break any app I had, but it did break libs (MissingH in my case)
16:33:49 <f4hy> Is there a built in function to take the average of a list?
16:34:02 <mauke> no
16:34:10 <magthe> dons, updating removed the old one (1.1.2.3) from disk, but didn't remove it from GHC's POV
16:34:23 <telemachus> (pretty easy to make one though)
16:34:50 <zakwilson> should the parser (many1 alphaNum `sepEndBy` (satisfy (not . isAlphaNum))) be slower than O(n)?
16:35:10 <magthe> dons, see my comment on the post for the errors, I believe they say it best :)   http://therning.org/magnus/archives/599#comment-178421
16:36:13 <dons> magthe: ah yes.
16:36:19 <dons> you upgraded ghc did you?
16:36:19 <magthe> dons :)
16:36:27 <magthe> dons: nope
16:36:38 <magthe> just time
16:37:27 <telemachus> would it just be annoying to complain that HP says this after it configures: "Now do "make" followed by "sudo make install""
16:37:33 <telemachus> Are we assuming Ubuntu?
16:38:48 <ksf> more importantly, why should I do a local install with sudo?
16:39:04 <telemachus> ksf: heh, well, right
16:39:27 <magthe> I print an IOException that I get from `createSymbolicLink` only prints the source, can I get hold of the target somehow?
16:39:40 <telemachus> I guess my point is that it should recommend elevating privileges for a global install, but it's up to the user to know how to get elevated privileges (su or sudo)
16:39:42 <zakwilson> Tests confirm it's much slower than O(n), probably O(n^2). I'm seeking a faster way to extract words from words+garbage.
16:40:10 * ksf thinks access denied errors are enough to hint at that.
16:40:34 <ksf> there's no need to foster unix illiteracy.
16:41:22 <telemachus> Is it possible to foster a near-universal condition?
16:41:29 <telemachus> Seems sort of redundant
16:41:52 <telemachus> And after the build finishes, there it is again:  Now do "sudo make install"
16:42:08 <telemachus> No, damn it, I won't do _sudo_ anything
16:42:45 <FunctorSalad> su -c "make install" should be fairly portable, no
16:43:12 <Boney> just say "For a system-wide install run 'make install' as the root user"
16:43:15 <telemachus> FunctorSalad: well, yes and no - Ubuntu cripples su
16:43:22 <telemachus> so _there_ it wouldn't work
16:43:29 * BMeph thinks it should say, "followed by 'sudo make me a sandwich'"
16:43:34 <Boney> "otherwise run make install".
16:43:36 <FunctorSalad> telemachus: oh
16:43:37 <telemachus> so yes, Boney and I are as one...
16:44:03 <Boney> that is if you want to say anything.
16:44:14 <ksf> gosh, just say "now do "make install"" and have the user figure out the rest.
16:44:58 <telemachus> FunctorSalad: in an effort to make Linux more Joe Sixpack friendly, they make sudo the new su (so to speak). The root user is disabled, and instead you are supposed to use sudo to get root privileges
16:44:58 <Boney> if I get a rendom package, I read INSTALL and if it says "these are generic installation instructions" then I know the incantation.  if it doesn't say that I read on.
16:45:09 <ksf> the point of the message is to make clear that the proper make target is called "install", not "lib-install" or something. It's not the place to elaborate about multi-user issues.
16:45:29 <Raevel> why isn't the rename performed when i type this into ghci? map (uncurry renameFile) [("a","a1")] >> return ()
16:45:44 <telemachus> Boney: I agree, but I'm talking about a message that both ./configure and make print out to my terminal
16:46:13 <telemachus> anyhow, I'll probably file a wishlist bug against it. I guess I'm feeling cranky
16:46:15 <Berengal> Raevel: The result of that is a list, not an IO action
16:46:19 <Boney> why would I type lib-install.  it's not a common target that I'm farmiliar with.
16:46:44 <ksf> well, but it's the topic of the message.
16:46:48 <Boney> also, if this is your issue. the message could say "use the install make target to install (don't use lib-install)"
16:46:56 <ksf> linux says "now do make bzImage, make modules_install"
16:47:00 <FunctorSalad> Raevel: you want "mapM" (or even shorter, zipWithM)
16:47:02 <Berengal> > map (+1) [1..10] >> return ()
16:47:04 <lambdabot>   [(),(),(),(),(),(),(),(),(),()]
16:47:13 <ksf> ...I guess the bzImage is gone by now, which just proves my point.
16:47:24 <Raevel> aha
16:47:29 <Berengal> > map putchar ['a'..'z'] >> return ()
16:47:30 <lambdabot>   Not in scope: `putchar'
16:47:43 <Berengal> > map putChar ['a'..'z'] >> return ()
16:47:45 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
16:47:48 <Berengal> There we go
16:48:46 <Berengal> In addition to mapM and zipWithM there's also sequence
16:48:50 <Berengal> @type sequence
16:48:51 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
16:49:30 <Raevel> does sequence perform the io actions in that case?
16:49:46 <EvilTerran> ?src sequence
16:49:46 <lambdabot> sequence []     = return []
16:49:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:49:47 <lambdabot> --OR
16:49:47 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
16:49:55 <Berengal> Raevel: Yes.
16:50:09 <Cale> Raevel: Well, it's more like it produces an action which will.
16:50:12 <Berengal> Raevel: so sequence (map foo [bars])
16:50:20 <Berengal> Raevel: But this is what mapM does already
16:50:46 <Berengal> Raevel: There's also underscore variations of most of these
16:50:52 <Berengal> @type mapM_
16:50:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:50:56 <Cale> Raevel: While it's common to blur the lines a bit and say that sequence itself runs them, what we really mean is that sequence produces an action which when run, will run them.
16:51:25 <Raevel> alright
16:51:26 <Berengal> Cale is right, and it's in fact exactly what happens in your map
16:52:48 <Raevel> now i'm mostly confused as to how i managed to have working code earlier
16:52:52 <Berengal> The mapping function returns an action. Usually when you call that function it's in the context of a sequence of actions (such as in a do block), so the action is run. When you map it however they're put in a list
16:53:06 <Berengal> s/mapping/mapped/
16:53:14 <ksf> Raevel, you did have type-correct code, and most of it got ignored.
16:53:59 <Raevel> that's not what i meant but n/m :-)
16:54:11 <ksf> the list version of >> was used, you never had a look of what's inside the list, and you got a list of ()'s of the right length.
16:54:50 <ksf> ...you could have mapped a non-terminating function over your list, the result would have been the same.
16:54:59 <Berengal> Raevel: The thing to understand is that there's one a single thread of execution, starting at main. Anything that is to be performed needs to be chained together in a single thread of >> or >>=
16:55:25 <thoughtpolice> pumpkin_: ping
16:55:28 <Berengal> My typing today sucks...
16:55:30 <pumpkin_> pong!
16:56:20 <ksf> for reference, >>= for lists is concatMap
16:56:24 <ksf> :t concatMap
16:56:25 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
16:56:28 <pumpkin_> thoughtpolice: ?
16:56:47 <Berengal> return for lists is (:[])
17:00:59 <thoughtpolice> pumpkin_: can you test something for me?
17:02:20 <pumpkin_> thoughtpolice: depends on how complicated it'll be :P
17:03:04 <cypher-> @src product
17:03:05 <lambdabot> product = foldl (*) 1
17:03:59 <thoughtpolice> pumpkin_: the llvm bindings on hackage fail miserably on OS X.
17:04:06 <thoughtpolice> pumpkin_: I want to make sure it's not just *my* macbook :)
17:04:08 <pumpkin_> aha
17:04:12 <pumpkin_> so just cabal install llvm?
17:04:17 <thoughtpolice> pumpkin_: yeah
17:04:22 <thoughtpolice> pumpkin_: the latest bindings are for llvm 2.5
17:04:27 <pumpkin_> even I may be able to do that
17:04:36 <pumpkin_> should I port install llvm first?
17:04:42 <pumpkin_> I already have extra include dirs and lib dirs
17:04:54 <thoughtpolice> yeah
17:04:58 <thoughtpolice> gah
17:05:08 * thoughtpolice actually might reinstall OS X now that he has an external hdd...
17:05:15 <pumpkin_> ack, why?
17:05:19 <thoughtpolice> i've borked up way too much stuff.
17:05:22 <pumpkin_> lol
17:05:50 <thoughtpolice> hdd is big enough for a 'cp ~/ /Volumes/...' anyway, so that's all I really care for.
17:06:26 <thoughtpolice> pumpkin_: as an example i no longer have macports because somehow libedit.2.dynlib got fucked up, but you need macports to get that specific version of libedit, and on top of that I had some weird tcl-related issues
17:06:31 <thoughtpolice> which totally sucks
17:06:33 <pumpkin_> lol
17:06:34 <pumpkin_> nice
17:06:36 <Raevel> my os x installation is borked also
17:07:09 <Raevel> every time i start a terminal there are random characters that the terminal can't render :-)
17:07:20 <thoughtpolice> hehe
17:07:27 <pumpkin_> thoughtpolice: building llvm (the non-haskell one) now
17:07:37 <pumpkin_> not sure how long it'll take, I should've told port to build parallel
17:07:44 <thoughtpolice> pumpkin_: anyway, on my box the LLVM bindings fail miserably when trying to write bitcode to files etc.
17:08:01 <thoughtpolice> pumpkin_: anything that *doesn't* use the bitcode-file-writing-interface works perfectly fine
17:08:08 <pumpkin_> I thought augustss used a mac though?
17:08:12 <thoughtpolice> but the haskell llvm bindings use those a lot behind the scenes
17:08:13 <pumpkin_> maybe not
17:08:20 <thoughtpolice> afaik they were developed on linux
17:09:15 <thoughtpolice> pumpkin_: so, after you get the llvm bindings for ghc, do a 'cabal unpack llvm' and go into the llvm-0.6.5.0/examples directory, then 'make' and try to run all the examples
17:09:33 <pumpkin_> ok
17:09:33 <thoughtpolice> pumpkin_: the ones that don't need to write .bc files work fine, but those are all the interesting non-trivial ones it seems :)
17:09:53 <thoughtpolice> er, the ones that do write .bc files are the interesting ones
17:09:58 <thoughtpolice> e.g. the Arith example etc.
17:10:34 <thoughtpolice> pumpkin_: it *could* be an error on the llvm side of things, but I'm not so sure first
17:13:47 <david__> yi will not build out of cabal because it cannot install utility-ht-0.0.5, any ideas?
17:15:17 <pumpkin_> thoughtpolice: it's still compiling, I'll check back in a few
17:15:30 <thoughtpolice> pumpkin_: k
17:15:53 <thoughtpolice> dmajnemer: utility-ht installs fine for me; 'cabal install utility-ht' ?
17:16:02 <pumpkin_> onoes, not utility-ht
17:17:40 <dmajnemer> thoughtpolice: http://pastebin.com/m5f5f5bde is what I get
17:18:55 <dmajnemer> I have tried this on my mac and on my debian box
17:19:06 <Cale> dmajnemer: Try installing the previous version instead
17:19:16 <Cale> utility-ht-0.0.4
17:19:20 <Cale> iirc
17:20:19 <dmajnemer> Cale: anger is all I get back from cabal, same error
17:20:59 <skorpan> dmajnemer: you have to specify that you want utility-ht-0.0.4 when you cabal install yi
17:21:05 <skorpan> i can't remember the exact syntax
17:21:20 <Cale> dmajnemer: Is utility-ht-0.0.5 already installed?
17:21:25 <dmajnemer> Cale: yes
17:21:37 <Cale> ghc-pkg remove utility-ht-0.0.5
17:21:49 <Cale> (the cheap solution :P)
17:22:01 <pumpkin_> ooh, does remove actually delete it?
17:22:05 <Cale> no
17:22:07 <pumpkin_> I've been using unregister, which is a pain
17:22:09 <pumpkin_> oh
17:22:14 <Cale> er, oh, unregister
17:22:17 <Cale> yes
17:22:19 <pumpkin_> oh :(
17:22:20 <skorpan> oh!
17:22:21 <pumpkin_> boo :P
17:22:38 <dmajnemer> yay, thanks!
17:24:20 <BMeph> Cale: Have you tried compiling MaybeT lately?
17:24:27 <Cale> No
17:24:36 <Cale> Is there a problem with it/
17:24:37 <Cale> ?
17:25:33 <BMeph> Well, I just tried it (in the process of trying out pqueue-mtl), and it bombed out on compiling MaybeT. :\
17:25:55 <BMeph> Cale: with: "Control\Monad\Array\MArray.hs:19:130:
17:25:55 <BMeph>     Can't make a derived instance of `MonadST (MArrayM a e m)'
17:25:55 <BMeph>       (even with cunning newtype deriving:
17:25:55 <BMeph>        the class has associated types)
17:25:55 <BMeph>     In the newtype declaration for `MArrayM'"
17:26:12 <BMeph> Ugh, sorry for the multi-line spam, all. :(
17:27:32 <Cale> Just so you know, I didn't write it.
17:27:58 <Cale> I suppose I can have a look at it.
17:28:06 <BMeph> Cale: Right, but you uploaded it, so "Pikachu, I blame YOU!" ;p
17:28:25 <Cale> Oh? Maybe I patched it before.
17:28:40 <thoughtpolice> dmajnemer: that's a very annoying problem :(
17:28:52 <thoughtpolice> it happens with reactive too
17:29:18 <Cale> Packages should not depend on QuickCheck if they're only using it to run their tests.
17:29:35 <Cale> BMeph: MaybeT installs fine for me.
17:29:44 <thoughtpolice> Cale: agreed
17:30:43 <FunctorSalad> it can't do newtype deriving if the derived class has associated types...
17:31:05 <FunctorSalad> (maybe because it'd have to invent a name for the constructor, in the case of data families)
17:31:40 <FunctorSalad> maybe one of the classes that is being newtype-derived has switched to using associated types, BMeph
17:32:03 <FunctorSalad> (I'm not famliar with MArray :()
17:32:08 <hatds> isn't newtype deriving supposed to mimic the newtype'd instances?
17:32:26 <hatds> so shouldn't it just use the same associated type?
17:33:03 <FunctorSalad> hatds: with associated type synonyms, that'd be possible. but associated data types must be injective (different for every instance)
17:33:31 <hatds> ah right, can't apply Const to a if a is wrapped
17:33:54 <BMeph> Cale: Hmm, I'll see if there's something simple, yet stupid that I should be including. Thanks for looking at it. :)
17:34:04 <hatds> nvm
17:34:15 <dolio> > (logBase 2 $ product [1..4], (5*16 + 4*8)/24)
17:34:17 <lambdabot>   (4.584962500721157,4.666666666666667)
17:37:01 <vixey> > ord '\ESC'
17:37:03 <lambdabot>   27
17:37:05 <vixey> > chr 1
17:37:06 <lambdabot>   '\SOH'
17:37:17 <vixey> what is SOH short for?
17:37:25 <pumpkin_> thoughtpolice: okay, I have llvm and have made the examples, which ones should I run
17:37:46 <p_l> vixey: Start Of Header
17:37:54 <pumpkin_> thoughtpolice: I got a segfault on Vector
17:38:13 <vixey> thank you p_l
17:38:35 <p_l> vixey: There's also Start Of Text etc.
17:39:07 <pumpkin_> thoughtpolice: Vector is the only one that segfaulted... the other ones seem to run fine, except that the Array one doesn't produce any output (not sure if that's normal)
17:39:34 <thoughtpolice> pumpkin_: hm
17:54:03 <BMeph> Cale: Oh, sorry to bug you, it's another pkg that pqueu-mtl depends on (one that is for some reason hard-encoded in the .cabal file...). Thanks for looking at a perfectly good package, and thank you for uploading it, too! :)
17:56:23 <Qork> would a haskell-machine be super expensive even if mass-produced?
17:56:33 <vixey> Haskell-on-Hardware
17:56:48 <Qork> is it still better to do von neumann architecture and then optimize on that?
17:56:49 <dcoutts> FPGAs!
17:58:45 <p_l> Qork: There was already a haskell-optimized machine before
17:59:03 <p_l> Though probably not to the extend of, for example, Symbolics systems
18:01:06 <roconnor> are we talking about a graph reduction machine?
18:01:26 * bremner wonders about hardware support for garbage collection
18:01:48 * roconnor wonders about hardware support for call stacks
18:02:44 <bremner> register windows!
18:03:00 * Qork wonders about people's contempt for Erlang syntax. would they dislike haskell's as well? but it is so clear!
18:03:05 <dcoutts> traditional hardware does have support for call stacks, push, pop etc
18:03:52 <p_l> Symbolics' machines had hw GC support
18:04:12 <p_l> coupled with swap
18:05:43 <Berengal> Symbolics' machines also had hw support for cons
18:06:08 <Berengal> They were in essence still von-neumann machines though
18:06:39 <roconnor> Qork: lots of people appear to have contempt for Haskell syntax
18:06:47 <pumpkin_> too little noise
18:06:48 <vixey> And Monads
18:06:48 <roconnor> I didn't know they did for Erlang as well.
18:06:52 <vixey> And Monoids
18:07:03 <SubStack> what about functors?
18:07:06 <pumpkin_> all four different kinds of monoids we have!
18:07:08 <roconnor> vixey: Monad syntax or Monads?
18:07:13 <Apocalisp> Monads are just monoids in the category of endofunctors!
18:07:19 <vixey> Monad in general
18:07:20 <Berengal> roconnor: Really? I can't say I've more than the odd fellow complaining...
18:07:49 <vixey> the thing is erlang syntax really does suck
18:07:51 <roconnor> Berengal: that's the impression I get from the blogsphere, but that is a sphere that is hard to get objective impressions from.
18:08:01 <vixey> they basically took Prolog and removed the good bits
18:08:28 <Berengal> roconnor: I see people hating on Java or Python syntax more
18:08:44 <Berengal> Of course, Haskell isn't as mainstream as those yet
18:09:06 <SubStack> too many parens, those two
18:10:13 <roconnor> People hate Python syntax?
18:10:33 <Berengal> The generall impression I've gotten is that it's either "Eh, don't know haskell except by name" or "I really love {Java/C/C++,python} syntax and really hate {python,Java/C/C++} syntax, but haskell syntax is okay"
18:10:34 <roconnor> Berengal: we must live in different blogspheres
18:11:10 <Berengal> roconnor: I didn't say it's the general opinion
18:11:27 <roconnor> :)
18:11:43 * cypher- likes the syntax of brainfuck
18:11:45 <Gracenotes> I've heard rom the blagowebs...
18:11:47 <Gracenotes> f
18:11:49 <cypher-> I can remember all of it!
18:12:00 <cypher-> ><.,[]+-
18:12:03 <cypher-> here you go!
18:12:07 <cypher-> ;)
18:12:13 <Berengal> cypher-: Don't forget comments
18:12:18 <cypher-> ah, yes
18:13:27 * bremner finds the haskell comment syntax faintly irritating
18:13:35 <bremner> the space thing
18:14:00 <Berengal> bremner: Eh, it allows -- in operators. I like that
18:14:19 <bremner> hence only faintly irritated, rather than postal
18:20:10 <Cale> bremner: It doesn't require a space after -- just a non-symbol character
18:21:55 <zakwilson> I'm trying to extract words from files that contain words and non-word characters. (many1 alphaNum `endBy1` (satisfy (not . isAlphaNum))) does this, but is very slow on long inputs. Is there a faster way?
18:22:08 <zakwilson> (using Parsec currently, but not attached to it.)
18:23:09 <Cale> Are you using bytestrings?
18:23:31 <zakwilson> No. Normal strings.
18:24:31 <bremner> Cale: ah, ok. Yeah, it hit me trying to do "special comments"  like --@{  which of course looks like an operator
18:24:47 <zakwilson> An earlier version that used the same parser on a bunch of short inputs was fast, but it's slow on one long input.
18:28:25 <Cale> zakwilson: You might try the lazy bytestring parsec
18:28:46 <Cale> zakwilson: But I'm not sure why that parser would be particularly slow.
18:29:27 <Berengal> zakwilson: How are you reading the file?
18:30:03 <zakwilson> Cale - I'll take a look at that. It's not that it's *slow* - it's that it's O(n^2). Breaking up the inputs makes it fast.
18:30:43 <zakwilson> I'm reading the file with readFile
18:35:30 <duaneb> hi people
18:35:30 <lambdabot> duaneb: You have 1 new message. '/msg lambdabot @messages' to read it.
18:35:54 <duaneb> thank you, lambdabot
18:36:19 <duaneb> so
18:36:23 <Cale> oh, hi duaneb
18:36:31 <duaneb> I want to define a vector as an unboxed tuple of unboxed doubles
18:36:33 <duaneb> is this possible?
18:37:13 <Cale> hmm
18:37:24 <Cale> Probably with -funbox-strict-fields
18:37:40 <Cale> and  data Vec = V !Double !Double !Double
18:37:43 <Cale> Or so
18:38:18 <duaneb> ahh
18:38:51 <Cale> Did you try that suggestion I sent?
18:38:57 <duaneb> yes
18:39:06 <duaneb> it is faster, thank you :)
18:39:07 <Cale> I found that it runs quite a lot faster
18:39:17 <Qork__> anyone have any cool practical ideas for the use of computer visionf or every day use?
18:39:32 <Cale> I also managed to avoid recomputing sqrt, but it made less of a difference
18:40:13 <Qork__> Cale what does !Double do?
18:40:35 <Qork__> and were you serious about Haskell on the iphone? (or was that dons?)
18:40:51 <Cale> I didn't say anything about Haskell on the iPhone
18:41:18 <Cale> Qork__: The ! makes the field strict, so that before any pattern matching happens, it ensures the field has been evaluated to a value
18:41:23 <dolio> zakwilson: That doesn't seem to be O(n^2) here.
18:41:41 <Qork__> Cale: hmm?
18:42:11 <Qork__> so instead of evaling when the pmatching is done it is done when the value is created or changed?
18:42:12 <Cale> Qork__: Normally at runtime, values of type Double are either actual Double-precision floating point numbers, or they are expressions which evaluate to such.
18:42:33 <duaneb> woah
18:42:47 <duaneb> Cale: where might I find the source for Data.List.subsequences?
18:42:52 <Cale> Qork__: Making the field strict more or less means that when a value of type Vec is constructed, it's not allowed to put expressions in that field, it must evaluate them first
18:43:02 <Cale> duaneb: I think it's linked from the documentation
18:43:04 <zakwilson> dolio: How big was the input?
18:43:12 * Cale checks
18:43:25 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#subsequences
18:43:37 <Qork__> Cale: and for datastructures like trees, is that standard?
18:43:39 <duaneb> yea, just found that :P
18:43:44 <dolio> zakwilson: I kept doubling it, up to 1.1 MB. Runtime doubled each time.
18:43:46 <Qork__> doesnt that defeat laziness?
18:44:20 <zakwilson> dolio: what version of Parsec are you using?
18:44:24 <Twey> Why did I get CTCP zEnd AAA4A4aaaAa44AAaa4aAAA4Aa4aaAaA4a4aAAA4aA from Î»b?
18:44:35 <Cale> Qork__: It does defeat laziness. You normally only do it for datastructures which are holding on to things like numbers, to prevent the program from carrying around large memory-consuming expressions by accident.
18:44:53 <Qork__> ok i see then
18:44:56 <Cale> Twey: that's quite a good question :)
18:45:00 <dolio> 3.0.0, I think.
18:45:09 <Axman6> Twey: some idiot was screwing with it
18:45:31 <Twey> How did they manage to get her to do that?  o.@
18:45:43 <zakwilson> I'm on 2.1. cabal upgrade parsec is not upgrading it, though cabal info parsec shows 3.0 being available.
18:45:59 <Twey> Ah
18:46:00 <Axman6> by getting \bot to print control sequences
18:46:12 <Axman6> or something
18:46:18 <vixey> more amusing the unicode char someone pasted that made the entire IRC log go backwards
18:46:30 <Axman6> o.O
18:46:30 <Twey> \01 acts as a message separator?
18:46:44 <dolio> zakwilson: Try just cabal install. 2.1 probably came with GHC. I'm not sure whether cabal upgrades such packages.
18:46:49 <Twey> vixey: Hahaha
18:48:14 <duaneb> Â¿É¹ÇÊ‡É”ÉÉ¹ÉÉ¥É” sÄ±É¥Ê‡ uÉÇÉ¯ noÊŽ
18:51:13 <ManateeLazyCat> Function `onKeyPress` is "WidgetClass w => w -> (Event -> IO Bool) -> IO (ConnectId w)", function `test` is "test :: E.Event -> ReaderT (IORef ViewList) IO Bool", how to make expression "liftIO $ onKeyPress window $ \event -> test event" pass? Thanks!
18:51:14 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
18:53:59 <andyjgill> Does anyone has experience with Graph (nodes & edges) packages in Haskell? What would people recommend?
18:54:09 <zakwilson> dolio: I've figured out why it works for you. I posted slightly different code trying to make it a one-liner.
18:54:30 <dolio> Ah.
18:54:35 <zakwilson> The actual parser is (many1 alphaNum `endBy1` many1 (satisfy (not . isAlphaNum)))
18:54:38 <Qork__> andyjgill: there is shippin with ghc, Data.Graph
18:54:42 <Qork__> i made my own
18:55:02 <zakwilson> and the many1 in the second arg to endBy1 is what's causing the problem.
18:55:25 <andyjgill> I'm looking at Data.Graph, but its a bit unorthogonal.
18:55:48 <andyjgill> More a collection of graph related functions.
18:56:10 <povman> Has anyone watched Robert Martin's talk on the death of smalltalk?
18:56:26 <povman> He could just as easily be talking about Haskell
18:56:32 <FunctorSalad> hahaha (from -cafe) "fromInteger _ = unsafePerformIO $ randomRIO (False,True)    looks safer to me"
18:56:33 <Qork__> link?
18:56:37 <povman> http://blip.tv/file/2089545
18:56:43 <povman> warning: 1.25 hours
18:57:01 <idnar> unsafeFromInteger?
18:57:11 <duaneb> could someone explaining `derives` to me?
18:57:11 <duaneb> http://www.haskell.org/ghc/dist/current/docs/users_guide/type-extensions.html#stand-alone-deriving
18:57:37 <FunctorSalad> idnar: the discussion was about Num Bool
18:57:50 <Cale> duaneb: hm?
18:57:51 <idnar> FunctorSalad: I figured
18:58:09 <ManateeLazyCat> Saizan: I have test darcs version, works fine. Thanks! :)
18:58:12 <duaneb> Cale: I just don't understand what `derives` does
18:58:14 <Cale> duaneb: It's similar to the meaning of data Foo = Bar Int | Baz String deriving Eq
18:58:24 <Cale> duaneb: "derives"?
18:58:24 <duaneb> ok, what does `deriving` do? :P
18:58:37 <Cale> It writes an instance of that class automatically.
18:58:43 <Cale> Based on the structure of the type
18:59:17 <Cale> There are a few prelude classes for which this is possible, and for newtypes, with an extension, a much wider range of classes are derivable
18:59:18 <duaneb> ahh, ok
18:59:20 <duaneb> that makes sense
19:00:15 <Cale> (basically, if the original type has an instance, the newtype-deriving extension will use the same implementation for the newtype, because at runtime, they're the same thing
19:00:16 <Cale> )
19:01:17 <duaneb> yea
19:01:18 <duaneb> makes sense
19:03:20 <dolio> zakwilson: I don't know. That's still not O(n^2) here. And I wouldn't expect it to be, given how parsec works.
19:03:32 <dolio> I wouldn't expect there to be problems unless you're using 'try'.
19:05:49 <Saizan> ManateeLazyCat: nice :)
19:12:54 <duaneb> Cale: I have a type (Vector), and I want to be able to multiply it with a scalar (Double)
19:12:56 <duaneb> how can I do this?
19:13:06 <Cale> Write a function...
19:13:08 <duaneb> e.g. (*) :: Vector -> Double -> Vector
19:13:18 <duaneb> yes, but doesn't it require a typeclass or something?
19:13:32 <Cale> s *^ (Vec x y z) = Vec (s*x) (s*y) (s*z)
19:14:05 <duaneb> yes, but that's not * :P
19:14:08 <Cale> You just can't call it *
19:14:13 <duaneb> I have an instance of num here
19:14:15 <Qork__> duaneb: class Num
19:14:16 <duaneb> oh :/
19:14:19 <Cale> It doesn't have the right type
19:14:22 <duaneb> yea, but that complains
19:14:22 <Cale> :t (*)
19:14:23 <lambdabot> forall a. (Num a) => a -> a -> a
19:14:36 <Cale> The parameters to (*) must have the same type
19:14:59 <duaneb> dammit
19:15:05 <Qork__> duaneb: i didnt implement Num for my vector module
19:15:11 * Axman6 quite likes using *. and .*. with the .'s indicating where the vector is
19:15:37 <ManateeLazyCat> Which character i should add after `ViewList`? In "type ViewListR = IORef ViewList", `ViewListR` is `IORef` style?
19:15:38 <Qork__> just Functor and Foldable
19:15:40 <zakwilson> dolio: I'm not using try.
19:16:21 <kpreid> ManateeLazyCat: that type synonym doesn't seem to add much
19:16:33 <duaneb> Qork__: what did you do, then?
19:16:54 <kpreid> you could of course write instance Num VectorOrScalar where (*) = ...
19:17:22 <duaneb> could I do something like class Multiply a b where (*) :: a -> b -> a ?
19:17:28 <duaneb> yea... :/
19:17:38 <duaneb> but then I run into the scalar * vector thing
19:17:42 <Cale> Or you could define vector multiplication componentwise and write a fromInteger/fromRational which produce however many copies of that number
19:18:08 <kpreid> Cale: that seems hazardous...
19:18:10 <ManateeLazyCat> kpreid: I saw many haskell code write SomeM, SomeT, SomeR, i can't understand `M` `T` `R`, `SomeM` mean "Some Monad"? `SomeT` mean `Some Transformer`?
19:18:14 <duaneb> I could
19:18:14 <Cale> But it's more trouble than it's worth to use classes where (*) is more polymorphic
19:18:29 <Cale> kpreid: Not that hazardous
19:18:36 <Cale> kpreid: It's still a ring after all
19:18:44 <duaneb> there a good Vector class somewhere?
19:18:55 <duaneb> I feel like I'm reinventing the wheel here
19:18:57 <Cale> duaneb: There are a number of packages on Hackage.
19:19:08 <Cale> Which are suited to various uses.
19:19:17 <kpreid> ManateeLazyCat: fooM (lowercase) usually means a version of the function foo which has a monad added to its type
19:19:19 <kpreid> e.g. map, mapM
19:19:33 <Qork> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4755#a4755
19:19:37 <Qork> ^^ my vecotr
19:19:39 <kpreid> FooT, a type, is a monad transformer which is like the Foo monad
19:19:40 <ManateeLazyCat> kpreid: fooR?
19:19:43 <Qork> actually i did use Num but didnt implement (*)
19:19:48 <kpreid> R doesnt mean anything in general that I know of
19:20:07 <ManateeLazyCat> kpreid: I see, thanks.
19:20:26 <kpreid> ManateeLazyCat: but my point was, I think you would be better off not making that type synonym at all
19:20:53 <ManateeLazyCat> kpreid: Yep, IORef foo is clearer.
19:21:17 <ManateeLazyCat> kpreid: Just curious. :)
19:21:54 <duaneb> Qork: it yells at me if I don't implement *
19:22:13 <Qork> duaneb: try hmatrix if you want a serious lib
19:22:22 <zakwilson> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4756
19:23:23 <duaneb> yea
19:23:39 <duaneb> and how fast are these?
19:24:09 <wli> up to 44.5M
19:24:12 * ManateeLazyCat pasted "my code" at http://paste2.org/get/204173
19:24:13 <ManateeLazyCat> Above code is *good* style? I mean i add `IORef` for every fucntion.
19:25:11 <kpreid> no
19:25:29 <ManateeLazyCat> kpreid: Any suggestion?
19:25:31 <kpreid> write (\x -> x {viewListCounter = viewListCounter x + 1}) as a separate function
19:25:46 <kpreid> try to keep the IORefs out of as many sub-functions as you can
19:25:55 <wli> The IORefs aren't a great idea.
19:26:08 <ManateeLazyCat> wli: Yep, but gtk2hs need IORef
19:26:28 <ManateeLazyCat> wli: I haven't choose, i can't use some gtk2hs function if i don't use IORef
19:28:09 <ManateeLazyCat> kpreid: Thanks for your suggestion.
19:32:16 <dolio> zakwilson: 'main = interact $ show . parse document ""' still works fine here.
19:39:08 <aconbere> I'm still learning Haskell and one aspect I haven't quite figured out yet is related to imports. In particular if I'm defining new data structures whose names conflict with others.
19:39:31 <aconbere> in this case I'm trying to define Left
19:39:38 <aconbere> but that's defined in Prelude
19:39:52 <aconbere> (I'm not importing Prelude, but it appears to conflict)
19:40:18 <dolio> Prelude is automatically imported unless you pass some flags, or write your own Prelude import statement.
19:40:45 <aconbere> so if I wrote my own import for Prelude
19:40:48 <dolio> If you don't want some of it, you can write 'import Prelude hiding (Either(..) ...)'
19:40:50 <aconbere> and said don't import "Left and Right"
19:40:52 <aconbere> I would be fine
19:40:57 * aconbere nods
19:41:20 <aconbere> thanks :)
19:41:28 <dolio> No problem.
19:41:44 <aconbere> and in other modules if I want to use these other "left" and "right" data structures, I should use their qualified names?
19:41:51 <aconbere> Angle.Left and Angle.Right for instance
19:41:52 <aconbere> ?
19:41:59 <dolio> Yes.
19:42:10 <aconbere> great
19:42:12 <aconbere> :)
19:48:42 <Qork> >>= =<<
19:49:18 <Axman6> @src (=<<)
19:49:18 <lambdabot> f =<< x = x >>= f
19:49:27 <vixey> :t (>>=) (=<<)
19:49:28 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => ((m a -> m b) -> (a -> m b) -> b1) -> (a -> m b) -> b1
19:49:29 <Axman6> best definition ever
19:49:34 <vixey> :t (>>= (=<<))
19:49:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (m a -> a -> m b) -> m a -> m b
20:06:10 <Qork> could you have algebraic datastructures in a non-GCed language?
20:06:38 <vixey> yes
20:06:49 <Qork> in C?
20:07:27 <Berengal> struct = product, union = sum
20:07:55 <vixey> void *
20:07:57 <vixey> = arrow :p
20:08:05 <vininim> lol
20:11:25 <vixey> "Both possibilities are feasible -- i.e., neither accepting nor rejecting AC yields a contradiction;"
20:11:38 <vixey> Shouldn't it say "neither accepting nor accepthing the negation of ..."?
20:12:00 <Gracenotes> well, tagged unions are more sum-ish
20:12:12 <Gracenotes> if you're dealing with something like C....
20:13:31 <vixey> "Zorn's Lemma is so complicated that most mathematicians are not able to form any intuitive opinion about it." -- well that sound like nonsense but it's vaguely reassuring
20:17:40 <vixey> I never know what extensional equality means now
20:18:02 <vixey> everyone calls eta ext, but nobody calls ext eta
20:21:47 <twb> vixey: perhaps that is a consequence of the original work being written in latin or a romance language.
20:22:10 <vixey> twb, yeah that could well be the root of it
20:24:33 <dolio> I read that blog post, by the way.
20:24:49 <dolio> About proof irrelevance and the excluded middle and such.
20:25:12 <vixey> dolio, yeah it' svery interesting stuff
20:25:33 <vixey> just thinking about how it related to OTT
20:27:53 <dolio> I wonder if a less type-based approach to irrelevance would allow you to include disjunction more easily.
20:28:49 <roconnor> vixey: extensional equality means that functions are equal when extensionally equal inputs imply extensionally equal output
20:29:03 * vixey sighs and installs agda for the 1000th time
20:29:14 <roconnor> vixey: and extensional equality on inductive types is the same as intensional equality
20:29:32 <vixey> roconnor: that's the same definition *I* use but other folk mix it up
20:30:21 <roconnor> presumably extensional equality implies eta equality, but certainly no the other way around.
20:30:50 <roconnor> and extensional equality doesn't really have anything to do with notion of convertability.
20:31:10 <roconnor> and, I assume, when people are talking about eta, they are talking about eta-convertability.
20:31:49 <roconnor> I think some people use a different word for convertability
20:36:17 <roconnor> @what CLOS
20:36:17 <lambdabot> I know nothing about clos.
20:36:57 <Axman6> @what love
20:36:57 <lambdabot> http://en.wikipedia.org/wiki/Where_Is_Love%3F
20:37:08 <Axman6> aww, i didn't expect that to work :(
20:37:11 <vixey> :/
20:37:52 <roconnor> oh CLOS is lisp
20:38:09 <roconnor> oh
20:38:15 <roconnor> It's object oriented lisp
20:38:35 <vixey> roconnor: There's a great book about it
20:38:40 <QtPlaty[HireMe]> Common lisp object system.
20:38:52 <roconnor> vixey: I find that surprising
20:39:05 <vixey> roconnor: It's called Art of the Metaobject Protocol
20:39:34 <roconnor> That sounds like the book Synek really liked
20:39:57 <roconnor> ya, that looks like the one
20:40:04 <twb> Ask specbot or fsbot about CLOS.
20:40:23 <roconnor> specbot: @what CLOS
20:40:26 <roconnor> fsbot: @what CLOS
20:40:37 <roconnor> oh I'm supposed to msg
20:40:38 <twb> roconnor: they aren't here.
20:40:40 <vixey> they aren't in this channel :p
20:40:49 <twb> roconnor: /msg specbot clhs clos
20:40:51 <twb> roconnor: /msg fsbot clos
20:41:23 <roconnor> <specbot> Sorry, I couldn't find anything for clos.
20:42:04 <twb> Ah, well. Wikipedia, then.
20:42:06 <Qork> lisp is dead
20:42:06 <Qork> long live clojure
20:42:06 <Qork> clojure is dead
20:42:06 <Qork> long live haskell
20:42:13 <twb> It will link to the same content.
20:42:20 <Axman6> haskell is dead
20:42:24 <Axman6> long live haskell'
20:42:28 <twb> Clojure always stuck me as a massive wankfest.
20:42:33 * Axman6 sees the future
20:43:09 <roconnor> long live Epigram!
20:43:13 <twb> A "modern" dialect my arse.
20:45:01 <vixey> there's got to be a way to .. cabal install dependencies ?
20:45:16 <vixey> twb: yeah it's just annoying so many people actually buy into this crap
20:45:28 <twb> I think newlisp is even funnier
20:45:42 <roconnor> what crap?  I want some!
20:45:47 <roconnor> I have money!
20:45:48 <twb> a.k.a. "I didn't understand lexical scoping, so I made a lisp without it"
20:45:54 <vixey> :(
20:46:04 <vixey> does anyone know if cabal has this or not?
20:46:12 <twb> roconnor: he's talking about ideological "buy in", not venture capital
20:46:14 <vixey> I do configure and it wants a hundred deps .. how do you install al these deps?
20:46:14 <roconnor> which one is lexical scoping?
20:46:32 <vixey> roconnor: the good one :p
20:46:41 <roconnor> ugh
20:46:44 <vixey> lambda is lexical scoping
20:46:46 <twb> lexical scoping is what Scheme has, CL uses by default (except for e.g. DEFVAR) and what elisp sucks royally at
20:46:53 <twb> vixey: that depends on the dialect ;-)
20:47:02 <Qork> twb: yeah the java interop is ok but haskell ffi to c beats that
20:47:02 <Qork> the concurrency constructs are ok, but haskells is much better
20:47:02 <Qork> i tried scala once before trying it again now
20:47:02 <Qork> used java for some imageprocessing wehich made me want to blow my head off
20:47:02 <Qork> twb: omfg it uses dynamic scoping?
20:47:03 <roconnor> vixey: doesn't cabal install automatically install all hackage dependencies?
20:47:10 <twb> With dynamic scoping, you can "steal" other function's internal variables.
20:47:16 <vixey> % cabal configure
20:47:17 <vixey> Resolving dependencies...
20:47:17 <vixey> Configuring Agda-2.2.3...
20:47:17 <vixey> cabal: At least the following dependencies are missing:
20:47:17 <vixey> QuickCheck ==2.1.0.1,
20:47:17 <vixey> binary >=0.4.4 && <0.6,
20:47:19 <vixey> haskeline >=0.3 && <0.7,
20:47:21 <vixey> utf8-string ==0.3.* && ==0.3.*
20:47:23 <vixey> that's what happens
20:47:31 <twb> vixey: cabal install --dry-run
20:47:50 <twb> vixey: actually, just "cabal install", but this will also install the current package
20:48:15 <vixey> ohhh
20:48:18 <vixey> thank you twb!
20:50:39 <vixey> what the hell is this :/ Setup.lhs:30:43: Not in scope: `buildVerbose'
20:51:14 <twb> vixey: a cabal build mismatch
20:51:20 <twb> vixey: or, a mistake in Setup.lhs
20:51:27 <vixey> I really don't get this stuff
20:52:09 <twb> A nontrivial Setup.hs is a bit like a nontrivial configure.ac or wscript... you need a few beers before it seems to make sense
20:52:20 <vixey> heh
20:57:53 <twb> A couple of times I've wanted to throttle the designer of the hooks
20:58:29 <pumpkin_> can agda compile to haskell?
21:00:39 <vixey> pumpkin_: I think so but I don't see the point
21:01:07 <pumpkin_> nice optimization
21:01:12 <vixey> dependently typed programs are generally not typeable as haskell and you lose all the optimization opportunities at the same time
21:01:24 <pumpkin_> hmm
21:01:24 <vixey> so it's pretty much lose-lose
21:01:34 <roconnor> optimization opportunites?
21:01:43 <pumpkin_> having a nice fast dependently typed language would be nice
21:01:45 <vixey> thing is, trying to write an optimizing compiler for a dependently typed langauge isn't .. easy
21:01:58 <vixey> Idris looks like the cutting edge there
21:02:11 <f4hy> GHC --make is pretty cool, is there something similar like ghc --make-clean ?
21:02:26 <roconnor> GHC --make --no-recomp  ?
21:02:28 <pumpkin_> -fforce-recomp might get you close
21:02:37 <pumpkin_> I think no-recomp is deprecated
21:02:39 <vixey> (It's just a shame I never managed to actually compile the thing..)
21:02:51 <f4hy> What if I want it to remove the files crated by the make though
21:02:54 <roconnor> pumpkin_: what am I supposed to do?
21:03:02 <pumpkin_> -fforce-recomp is the replacement I think
21:03:03 <pumpkin_> bbl :)
21:03:23 <roconnor> pumpkin_: that's much more intuative than no-recomp
21:03:53 <roconnor> I always remembered no-recomp as "no-recomplie" and that it does the opposite.
21:04:16 <roconnor> no-recompile
21:04:36 <f4hy> ghc --make -fforce-recomp just recompiles everything, but imagine I want to remove all files crated by ghc --make, such a feature doesnt exist I bet?
21:05:08 <roconnor> sounds like a fair bet
21:05:44 <twb> f4hy: I would approximate it with find \( -name \*.hi -o -name \*.o \) -delete
21:05:59 <twb> f4hy: of course cabal users can rm -rf dist
21:06:45 <f4hy> twb: Ya I knew I could do it by just a find and delete, but haskell constantly surprizes me with magic features so if there was a ghc --unmake I wouldnt be completely shocked
21:08:15 <f4hy> I am almost done with my first haskell program. :-)
21:08:35 <f4hy> (excluding hello world and a few project eulers)
21:08:45 <twb> f4hy: reading RWH?
21:09:06 <f4hy> twb: nope. Well I read a few chapters of it. I will plan on reading the whole thing
21:09:24 <f4hy> But I decided to do my final project in a cryptography class using haskell
21:10:04 <f4hy> Almost done, just trying to figure out GetOpt
21:10:32 * QtPlaty[HireMe] did his cryto class using scheme mostly because of the numbertower.
21:11:15 * wli is struggling with a Project Euler problem (#216).
21:12:20 <twb> I love the numeric tower
21:12:56 <twb> Mainly because I suck at numeric analysis.
21:13:07 <Axman6> umeric tower?
21:13:09 <Axman6> n*
21:15:17 <roconnor> class tower?
21:28:50 <Qork> povman: why could it happen to haskell too?
21:28:59 <Qork> wre not even popular yet :P
21:29:57 <Neutralise> hey guys
21:30:16 <Axman6> o/
21:32:18 <Twey> twb: A non-lexically-scoped Lisp?
21:32:27 <Twey> Please tell me it's not dynamically-scoped
21:33:49 <Wraithan1> http://urchin.earth.li/~ian/style/haskell.html < That a pretty good universal style guide for Haskell? Looking for a pretty good one as there have been a couple times in the past I learned languages from tutorials or books that were not really normal styling
21:34:47 <Twey> Â« In fact, rumour has it that the GHC optimiser analyses programs it is asked to compile and, if it finds it aesthetically pleasing, will work harder to make your program run faster. Â» â€” hahaha
21:36:06 <Wraithan1> Also if I use spaces instead of tabs, will I be confined to using at least 8 space indentation, cause I hate that. lol
21:37:25 <Wraithan1> Reading "Haskell defines tabs to align to the next column that is divisible by 8 characters - informally refered to as "8 space tabs". It is this definition that is used by the layout rule." as part of that layout/style guide is what led me to believe that, though I prefer 4space tabs, unless those would not work (guess I can just try it and see)
21:37:44 <f4hy> Twey: wait what?
21:37:52 <mmorrow_> i use 2space tabs
21:38:14 <Wraithan1> mmorrow_: But do you use spaces or tabs?
21:38:15 <Twey> I too
21:38:21 <mmorrow_> Wraithan1: spaces
21:38:23 <Twey> Wraithan1: It looks incomplete
21:38:24 <jekor> Can someone point me to an example of using Text.Formlets with files? Specifically I'm wondering how to go about building a File using Network.CGI.
21:38:30 <Wraithan> Ah ok
21:38:36 <Twey> All it says is true, but it misses some important conventions
21:38:53 <Wraithan> Twey: Is there a better style guide you could point me to?
21:39:06 <Wraithan> Rather just learn it right the first time lol
21:39:13 <Twey> Not really, I'm afraid.
21:39:20 <mmorrow_> the column of the first token after a {do,let,module,where,(maybe another that i can't think of)} sets the layout for the remainder of that layout context
21:39:24 <Twey> Style is Haskell is highly context-dependent
21:39:58 <mmorrow_> so it doesn't matter what you use, but once you use it you have to keep on doing it :)
21:40:15 <Wraithan> I know consistancy is the most important part
21:40:46 <vixey> dolio, hey are you around?
21:41:01 <mmorrow_> (well, in this case inconsistency (w/in a single layout context) is an error ..)
21:41:11 <mmorrow_> but yeah
21:41:59 <dolio> I am.
21:42:15 <vixey> dolio, I proved false based on scm's axioms
21:42:36 <vixey> do you think that is supposed to be possible or that is not?
21:42:47 <roconnor> @what scm
21:42:47 <lambdabot> I know nothing about scm.
21:42:51 <dolio> I'm not sure. Possibly.
21:43:01 <vixey> roconnor: Shin-Cheng Mu http://www.iis.sinica.edu.tw/~scm/2009/proof-irrelevance-extensional-equality-and-the-excluded-middle/
21:43:49 <roconnor> vixey: doesn't he derive false himself in that post?
21:43:56 <Lemmih> ?tell thoughtpolice I've pushed the HPT analysis. There should only be a few more minor obstacles for the LLVM backend.
21:43:56 <lambdabot> Consider it noted.
21:43:58 <vixey> wheer?
21:45:07 <vixey> he proved decidable equality of types -- which is something I think you expect from ext
21:45:18 <vixey> although it seems to need pi. too, not sure why
21:46:06 <roconnor> vixey: the conclusion is a = b for any type A
21:46:22 <vixey> eq_dec : {A : Set} â†’ (a b : A) â†’ âŒˆ (a â‰ b) âˆ¨ (ï¿¢ (a â‰ b)) âŒ‰
21:46:23 <vixey> that?
21:47:37 <roconnor> hmm
21:47:43 <roconnor> maybe I need to read this more carefully
21:48:16 <dolio> I don't think decidable equality for all types is expected given extensional equality.
21:48:26 <dolio> Considering he needs bad proof irrelevance to make it work.
21:48:30 <Wraithan> Is there a better place to ask really noobish questions as I am learning the language (and functional programming?)
21:48:39 <vixey> Wraithan here is fine
21:48:46 <roconnor> vixey: but I'm not surprised you get an contradicion
21:49:27 <vixey> roconnor: I think if it was _really_ prop, you couldn't eliminate out into Set then it would be consistent
21:49:45 <roconnor> yes
21:50:07 <vixey> so maybe the deal is -- just look really really carefully through the entire proof to make sure prop is used correctly :/
21:50:15 <roconnor> I think that is his (or rather Conor's) point about or
21:50:53 <roconnor> âŒˆ P âˆ¨ Q âŒ‰ = âŒˆ P âŒ‰ âŠŽ âŒˆ Q âŒ‰  is the fatal flaw
21:51:06 <vixey> looks ok to me
21:51:08 <roconnor> where "Prop" is extracted to "set"
21:51:25 <vixey> postulate irr : âˆ€ {A} (P Q : â€  A) â†’ (p : âŒˆ P âŒ‰)(q : âŒˆ Q âŒ‰) â†’ (P â‰¡ Q) â†’ p â‰… q -- is the bit I don't like
21:51:26 <dolio> His decidable equality doesn't use extensional equality anyway, now that I look.
21:51:35 <Twey> Wraithan: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=2384#a2384 â€” my preferred layout style
21:52:09 <roconnor> vixey: postuatle irr would be fine if he didn't have or in his logic language, or defined the mapping for or in the right way
21:52:11 <dolio> He doesn't introduce it until the excluded middle section.
21:52:15 <vixey> I guess if you removed âŒˆ P âˆ¨ Q âŒ‰ = âŒˆ P âŒ‰ âŠŽ âŒˆ Q âŒ‰ then irr would be fine
21:52:19 <Elly> huh, my font can't handle some of your symbols
21:52:38 <roconnor> âŒˆ P âˆ¨ Q âŒ‰ is supposed to have only one proof, that is what irr says
21:53:03 <roconnor> but âŒˆ P âŒ‰ âŠŽ âŒˆ Q âŒ‰ gives you constructive information
21:53:13 <pumpkin_> http://hackage.haskell.org/packages/archive/haskell-src-meta/0.0.3.1/doc/html/Language-Haskell-Meta-QQ-Vixey.html is really descriptive
21:53:17 <pumpkin_> vixey: what does it do? :P
21:53:44 <Apocalisp> Can zip be defined in terms of fold?
21:53:50 * vixey sighs Agdas Prop doesn't work
21:53:55 <roconnor> they are right about Haskell docs. :)
21:54:00 <pumpkin_> Apocalisp: sort of, yeah
21:54:03 <dolio> What doesn't work about it?
21:54:12 <pumpkin_> Apocalisp: actually, maybe not
21:54:14 <Apocalisp> pumpkin_: I'd be surprised if it can't.
21:54:20 <dolio> Yes, it can.
21:54:29 <vixey> data Ch : Prop where A : Ch ; B : Ch
21:54:30 <vixey> data Eq : Ch -> Ch -> Prop where Refl : {c : Ch} -> Eq c c
21:54:30 <vixey> ex : Eq A B
21:54:30 <vixey> ex = Refl
21:54:33 <vixey> doesn't typecheck
21:54:42 <pumpkin_> oh, I see, but it's pretty ugly?
21:54:43 <vixey> because 'A doesn't equal B' apparently
21:55:26 <dolio> Of course not. They're two different constructors.
21:55:28 <roconnor> is agda supposed to be proof irrelevent?
21:55:54 <dolio> You need to pass a flag to enable proof irrelevance for Prop.
21:55:58 <vixey> roconnor: I don't know why it has a Prop sort if not
21:55:59 <dolio> And then it'll complain about Ch.
21:56:07 <vixey> ugh Agda sucks
21:56:38 <vixey> It's only the programs written it in that are good
21:57:08 <roconnor> claiming âŒˆ P âˆ¨ Q âŒ‰ is proof irrelevent and also given that âŒˆ P âˆ¨ Q âŒ‰ = âŒˆ P âŒ‰ âŠŽ âŒˆ Q âŒ‰ means that âŒˆ P âŒ‰ âŠŽ âŒˆ Q âŒ‰ is proof irrelevent
21:57:27 <roconnor> in paritcular âŒˆ TT âŒ‰ âŠŽ âŒˆ TT âŒ‰ is proof irrelevent
21:57:54 <roconnor> which is the same as saying âŠ¤ âŠŽ âŠ¤ is proof irrelevent
21:58:04 <vixey> roconnor: yeah that's exactly what I did
21:58:11 <roconnor> which is the same (or equvalent) to saying booleans are proof irrelevent
21:58:18 <roconnor> which means true = false
21:59:43 <dolio> :t (\f as bs -> foldr (\a babs bs -> foldr (\b _ -> f a b : babs (tail bs)) [] bs) (const []) as bs)
21:59:44 <lambdabot> forall a a1 a2. (a -> a1 -> a2) -> [a] -> [a1] -> [a2]
21:59:56 <dolio> :t (\f as bs -> foldr (\a babs bs -> foldr (\b _ -> f a b : babs (tail bs)) [] bs) (const []) as bs) (+) [1..10] [11..20]
21:59:57 <lambdabot> forall a. (Enum a, Num a) => [a]
22:00:03 <dolio> > (\f as bs -> foldr (\a babs bs -> foldr (\b _ -> f a b : babs (tail bs)) [] bs) (const []) as bs) (+) [1..10] [11..20]
22:00:03 <roconnor> vixey: it does suggest his blog proof is rather roundabout
22:00:04 <lambdabot>   [12,14,16,18,20,22,24,26,28,30]
22:00:16 <vixey> roconnor: yeah I proved dec too much shorter :p
22:00:53 <roconnor> vixey: does the proof of false use the ac function?
22:00:58 <vixey> I think we should bootstrap agda
22:01:04 <vixey> roconnor: no
22:01:10 <vixey> nor ext
22:01:11 <roconnor> hmm
22:01:26 <roconnor> kinda destroys his whole point
22:01:51 <Apocalisp> dolio: Awesome.
22:02:10 <dolio> ski has another way that involves newtypes.
22:02:30 <roconnor> oh ac isn't an axiom
22:02:31 <dolio> And thinks the above way is cheating. :)
22:03:03 <dolio> Theorem of choice.
22:03:07 <Apocalisp> how is it cheating?
22:03:07 <roconnor> vixey: ya, this article makes no sense anymore
22:03:19 <roconnor> vixey: he proves that proof irrelevence gives excluded middle
22:03:29 <roconnor> but his proof irrelevence gives false
22:03:49 <roconnor> so the fact that it also gives excluded middle isn't very surprising.
22:03:57 * vixey nod
22:04:18 <vixey>  hehe 'theorem of choice'
22:04:19 <roconnor> there is a relationship between AC, EXT and EM, but I think he misimplements it here.
22:04:34 <vixey> It tottally shocked me when I read martin lofs 'forward chaining' proof of AC
22:04:43 <dolio> Apocalisp: He doesn't like using foldr as essentially a case statement, and using tail there (which you can define with foldr as well, but only by duplicating the list).
22:05:10 <vixey> these guys in this WF paper are like 'oh this backward chaining proof is so much easier to read' but it doesn't have that startling shock value :p
22:05:11 <roconnor> ah
22:05:20 <roconnor> EM + EXT- + ACint is Equivalent to ACext
22:05:33 <roconnor> http://www2.math.su.se/~jesper/research/emac/
22:05:48 * vixey hadn't heard of ACext yet
22:06:03 <Wraithan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4757 - I have tried to find the why in the book I am reading but I seem to keep missing it, why do I have to use a let for retVal but not for acFile?
22:06:09 <Apocalisp> dolio: Hah. What does tail look like in terms of fold?
22:07:06 <dolio> > (snd . foldr (\e (t,_) -> (e:t,t)) ([],error "tail of empty list")) [1..10]
22:07:07 <lambdabot>   [2,3,4,5,6,7,8,9,10]
22:07:12 <dolio> > (snd . foldr (\e (t,_) -> (e:t,t)) ([],error "tail of empty list")) []
22:07:13 <lambdabot>   * Exception: tail of empty list
22:07:17 <roconnor> vixey: it is the same thing as ACint, but adds that if the relation respects a certain setoid equality, then so will the choice function.
22:07:37 <Apocalisp> dolio: Awesome.
22:07:48 <jekor> I've never seen a type like this. What does the f mean? Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString' against inferred type `f Data.ByteString.Lazy.Internal.ByteString'
22:08:10 <roconnor> "respects a given setoid equality" I should say
22:08:24 <vixey> I see very interesting
22:08:26 <Saizan> jekor: the 'f' there is a type variable
22:08:27 <Cale> jekor: f is some type constructor
22:08:38 <Cale> (a variable type constructor, yeah)
22:08:43 <roconnor> vixey: http://r6.ca/blog/20050604T143800Z.html
22:08:50 <Berengal> jekor: Could we see some code?
22:08:53 <Saizan> jekor: it could be e.g. Maybe or [] or anything that takes a type parameter
22:09:01 <roconnor> ``Type theory gives me the axiom of choice, but by throwing away the ability to make quotient types, the axiom of choice doesnâ€™t produce the pathologies that it produces in set theory.
22:09:02 <Saizan> (of kind *)
22:09:04 <dolio> Apocalisp: Certainly, defining zip like that (with a foldr tail and all) is very inefficient. unfoldr is a better fit.
22:09:06 <jekor> Let me get a paste ready.
22:09:23 <roconnor> I should have said "theorem of choice"
22:10:10 <vixey> it's ok to say axiom of choice :)
22:10:14 <vixey> theroem of choice just sound silly
22:10:14 <jekor> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4758#a4758
22:10:19 <roconnor> :)
22:10:34 <vixey> you really have that on a t-shirt!?
22:10:49 <Apocalisp> dolio: I like it. Shows that lists are essentially folds.
22:11:10 <Cale> What pathologies?
22:11:14 <roconnor> vixey: we made them in the Pure Math Club
22:11:20 <juhp_> why are OpenGL and GLUT in haskell-platform?
22:11:20 <vixey> hehe
22:11:21 <roconnor> vixey: ask Cale
22:11:26 <dolio> I didn't come up with that incidentally. I got it from oleg.
22:11:30 <vixey> you go to the same uni as cale?
22:11:32 <Apocalisp> I wonder if that's generally true, that datastructures can be defined in terms of catamorphisms.
22:11:39 <roconnor> vixey: ya, but I never met Cale.
22:11:46 <Cale> vixey: We both went to Waterloo, but at different times.
22:11:55 <vixey> so I should go to Waterloo
22:12:09 <vixey> if it turns out mathematicians/logicians like you guys :p
22:12:16 <dolio> Apocalisp: Yes, it is, more or less.
22:12:29 <Wraithan> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4757 - I have tried to find the why in the book I am reading but I seem to keep missing it, why do I have to use a let for retVal but not for acFile?
22:12:46 <Cale> I don't see how well ordering the real numbers is unfortunate.
22:12:51 <Cale> Isn't that nice?
22:12:56 <dolio> You can represent inductive types as their fold, and coinductive types as their unfold, essentially.
22:13:12 <Cale> You can do induction on the reals that way, it's good.
22:13:17 <vixey> I find universal well order a bit weird because there is no ordinal of all ordinals
22:13:27 <roconnor> vixey: haven't you graduated already?
22:13:27 <Axman6> Wraithan: you want to write return isInfixOf "on-line" acFile?
22:13:34 <vixey> if every set is well ordered what's it well ordered by ..
22:13:38 <jekor> Wraithan: To introduce a name for a value within do notation you need the let. Guess it's just syntax.
22:13:41 <Berengal> Wraithan: acFile is a value that exists inside a monad. The arrow "extracts" it. The let simply states that retVal is equal to the lhs
22:13:42 <vixey> roconnor, no
22:13:44 <Axman6> Wraithan: return (isInfixOf "on-line" acFile) or even return $ isInfixOf "on-line" acFile work
22:13:52 <Cale> vixey: Well, it's only because ordinals don't form a set.
22:13:53 <roconnor> vixey: have you entered university?
22:14:00 <vixey> roconnor: yes
22:14:03 <vixey> (huge mistake)
22:14:06 <Wraithan> Ah ok, thank you guys
22:14:08 <roconnor> :/
22:14:09 <dolio> Apocalisp: The Church encoding of data types is representing them as their catamorphism, assuming you've heard of it.
22:14:23 <Axman6> vixey: how so?
22:14:45 * Axman6 is loving uni
22:14:46 <vixey> Axman6, just not my scene
22:14:47 <roconnor> Cale: oh come on.  have you ever seen a well-ordering of the reals?  Didn't think so. :)
22:14:59 <Wraithan> Axman6: is one of those the perferred syntax for that, or both pretty much equal
22:15:02 <Cale> roconnor: Sure, the axiom of choice has given me such an object many times.
22:15:03 <dolio> Bool = forall r. r -> r -> r, Nat = forall r. (r -> r) -> r -> r, ...
22:15:10 <vixey> Axman6, don't like drinking or church so I don't make much friends
22:15:17 <Axman6> Wraithan: using $ saves you typing
22:15:20 <roconnor> vixey: you might have been happier at Waterloo, but moving to Canada might be tough.
22:15:38 <Axman6> vixey: i don't like either, but i've got plenty of friends here. maybe you should move to australia ;)
22:15:56 * Cale is willing to trust in the existence of any object whose existence follows from the axioms.
22:16:16 <vixey> Cale, but ordinals are sets
22:16:20 <roconnor> Cale: you are crazy
22:16:20 <Cale> vixey: Right.
22:16:24 <vixey> Are they correspond to well orderings
22:16:34 <vixey> but.. not every well ordered set has a well ordering :p
22:16:51 <Cale> vixey: what?
22:16:52 <vixey> (I know I am being vague, but the truth is this isn't a *paradox* it's just something a bit wobbly)
22:17:05 <Cale> vixey: Not every well-ordered proper class is a set, you mean.
22:17:33 <vixey> Cale, - what is was really was I was trying to define a measure value for every object in type theory
22:17:39 <roconnor> anyhow, Cale and I have different understanding of the word "exists"
22:17:43 <jekor> OK, that was a dumb error. I was try to use a monadic operation inside of the data constructor.
22:17:43 <vixey> so like  size [] = 0 ; size (x:xs) = 1 + size xs
22:17:46 <Cale> Proper classes need their own definition of well-ordered, I think.
22:17:47 <vixey> but I had to add in limit ordinals
22:17:53 <bnijk_> hey where is the function ord
22:17:56 <vixey> but it turns out limit ordinals aren't enough
22:18:02 <Cale> bnijk_: Data.Char
22:18:13 <vixey> in fact you can't make a size measure for _everything_ because russels paradox comes up
22:18:26 <bnijk_> > map ord [60..90]
22:18:26 <vixey> it's similar in set theory
22:18:27 <lambdabot>       No instance for (Num Char)
22:18:27 <lambdabot>        arising from the literal `60' at <int...
22:18:33 <bnijk_> hmph...how do i do this again
22:18:40 <Cale> > map ord "hello"
22:18:42 <lambdabot>   [104,101,108,108,111]
22:18:47 <bnijk_> oh, ok it was backwards :O
22:18:52 <Cale> > map chr [60..90]
22:18:53 <lambdabot>   "<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
22:19:14 <Cale> You can also use toEnum/fromEnum, which are in the Prelude.
22:19:17 <Axman6> > map chr [60..90]
22:19:18 <lambdabot>   "<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
22:19:23 <Axman6> > map chr [65..90]
22:19:24 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
22:19:24 <Axman6> even
22:19:25 <Cale> > toEnum [60..90] :: String
22:19:26 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
22:19:28 <Cale> > map toEnum [60..90] :: String
22:19:28 <Berengal> > ['A' .. 'z']
22:19:30 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz"
22:19:30 <lambdabot>   "<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
22:19:36 <roconnor> > ['<'..'Z']
22:19:37 <lambdabot>   "<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ"
22:19:45 <bnijk_> is there a date or roman numeral function
22:19:46 <bnijk_> like in lisp
22:19:56 <vixey> Cale -- I didn't make sense?
22:20:03 <Cale> There are lots of functions for manipulating dates...
22:20:13 <bnijk_> where are they
22:20:20 <Berengal> Data.Time
22:20:29 <Berengal> And family
22:20:49 <bnijk_> and how do i list the functions inside a module
22:20:58 <Berengal> you can use :browse in ghci
22:21:06 <Axman6> you could always look at the documentation
22:21:11 <Cale> But it's probably better just to look up the haddock documentation
22:21:14 <bnijk_> mmnn ok
22:21:28 <bnijk_> haskell rocks!
22:21:35 <Axman6> yup
22:21:41 <Berengal> I like :browse for small modules, when I only need a quick reminder
22:21:45 <Axman6> wish i had more time for it these days
22:21:48 <Qork> > let (*.) = sum $ zipWith (*) in (*.) [1..3] [4..6]
22:21:49 <lambdabot>   Couldn't match expected type `[a]'
22:21:50 <Berengal> Not so good for root modules of large libraries
22:21:54 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Format.html -- this has functions for parsing and formatting times and dates.
22:22:11 * Berengal once did :browse on Graphics.UI.Gtk and had to kill the terminal
22:22:23 <Cale> vixey: I might know what you're talking about, I'm not sure
22:22:32 <Cale> Berengal: haha
22:22:52 <Qork> > let (*.) a b= sum $ zipWith (*) a b in (*.) [1..3] [4..6]
22:22:53 <lambdabot>   32
22:23:06 <bnijk_> what happens if you do map reverse....
22:23:09 <vixey> oh sorry
22:23:09 <bnijk_> > map reverse "hello"
22:23:10 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
22:23:14 <vixey> it's not called russels paradox
22:23:16 <bnijk_> mmn...
22:23:19 <Cale> > map reverse ["hello", "there"]
22:23:19 <vixey> it's beuril-forti or somethinga
22:23:20 <lambdabot>   ["olleh","ereht"]
22:23:25 <vixey> anyway pretty much the same deal
22:23:26 <bnijk_> that sucks Cale
22:23:34 <bnijk_> i want it to do reverse for each string
22:23:36 <Cale> bnijk_: What did you expect?
22:23:39 <bnijk_> breaking off the first character each time
22:23:42 <Cale> bnijk_: That's what it does?
22:23:43 <bnijk_> now that would be cool
22:23:49 <Cale> Huh?
22:23:56 <Cale> Breaking off the first character?
22:23:59 <bnijk_> yeah...
22:24:04 <Axman6> hello -> ello?
22:24:05 <bnijk_> how would i do that
22:24:08 <bnijk_> yes Axman6
22:24:11 <Twey> > tail "Hello"
22:24:12 <lambdabot>   "ello"
22:24:12 <Cale> åˆ†ã‹ã‚‰ãªã„
22:24:13 <bnijk_> i throw a push in there or something
22:24:14 <Axman6> or hello -> olle?
22:24:18 <bnijk_> or a tail
22:24:23 <bnijk_> > map tail "hello"
22:24:24 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
22:24:27 <bnijk_> o>o_@
22:24:39 <Twey> bnijk_: "hello" = ['h', 'e', 'l', 'l', 'o']
22:24:39 <Gracenotes> ole ole, ole ole
22:24:41 <Cale> map sends functions (a -> b) to functions ([a] -> [b])
22:24:41 <Axman6> > iterate (drop 1) "hello"
22:24:42 <lambdabot>   ["hello","ello","llo","lo","o","","","","","","","","","","","","","","",""...
22:24:47 <bnijk_> nifty
22:24:56 <Twey> bnijk_: tail [1, 2, 3] = [2, 3]
22:24:58 <Cale> So if you want to map a function over a string, it has to be a Char -> t function for some t
22:25:03 <Axman6> > takeWhile (not . null) . iterate (drop 1) $ "hello"
22:25:03 <bnijk_> > iterate (reverse . drop 1) "hello"
22:25:04 <lambdabot>   ["hello","ello","llo","lo","o"]
22:25:05 <lambdabot>   ["hello","olle","ell","ll","l","","","","","","","","","","","","","","",""...
22:25:11 <Gracenotes> ['h', 'e', 'l', 'l', 'o'] = 'h':'e':'l':'l':'o':[] :)
22:25:12 <bnijk_> > iterate (reverse . drop 1 . reverse) "hello"
22:25:13 <lambdabot>   ["hello","hell","hel","he","h","","","","","","","","","","","","","","",""...
22:25:18 <bnijk_> that's even worse
22:25:19 <Twey> > map Data.Char.toUpper "hello"
22:25:20 <lambdabot>   "HELLO"
22:25:27 <bnijk_> thank you Twey :)
22:25:35 <Cale> > map reverse . tails $ "hello"
22:25:37 <lambdabot>   ["olleh","olle","oll","ol","o",""]
22:25:48 <Cale> Is that perhaps what you were looking for?
22:25:57 <bnijk_> kind of
22:26:02 <bnijk_> but each item should be the reverse of the last
22:26:10 <bnijk_> minus one character
22:26:12 <Twey> Hmn hmn
22:26:13 <bnijk_> it doesn't matter which one
22:26:14 <Twey> I see
22:26:15 <Cale> oh, so you really did want the iterate
22:26:26 <Twey> > iterate (reverse . tail) "Hello"
22:26:27 <lambdabot>   ["Hello","olle","ell","ll","l","","* Exception: Prelude.tail: empty list
22:26:44 <Cale> > takeWhile (not . null) . iterate (reverse . tail) $ "hello"
22:26:46 <lambdabot>   ["hello","olle","ell","ll","l"]
22:26:53 <Twey> 's the one :)
22:27:01 <bnijk_> interesting
22:27:08 <Berengal> Yay, ghc 6.10.3
22:27:15 <Twey> > takeWhile (not . null) $ iterate (reverse . tail) "Hello"
22:27:16 <lambdabot>   ["Hello","olle","ell","ll","l"]
22:27:19 <bnijk_> > takeWhile (not . null) . iterate (reverse . tail) $ "hello Cale how are you today"
22:27:21 <lambdabot>   ["hello Cale how are you today","yadot uoy era woh elaC olle","ello Cale ho...
22:27:22 <Berengal> Now with working delete key
22:27:26 <bnijk_> oh stupid lambdabot
22:27:28 <bnijk_> show me the whole thing
22:27:38 <Twey> It works, \b just doesn't want to spam the channel :-P
22:27:38 <Cale> Well, it is kind of long.
22:27:49 <dolio> So, is haskeline ghci worth the upgrade?
22:28:00 <Twey> Ooo
22:28:02 <Twey> New GHCi
22:28:05 <Twey> Haskeline?  Cool
22:28:14 <bnijk_> i was making a rpresent for my girlfriend
22:28:16 <bnijk_> ;)
22:28:17 <Berengal> dolio: I haven't really checked it out properly, but delete key now works, and so does emacs
22:28:20 <Jedai> dolio: Not really, especially given that you can install it on older release
22:28:22 <Cale> dolio: If your current ghci crashes when you ctrl-c it probably is.
22:28:30 <Berengal> (without the cat | ghci hack)
22:28:30 * Twey chuckles.
22:28:40 <Twey> Mine just prints â€˜^Câ€™
22:28:46 <Berengal> I got ~
22:28:58 <dolio> I don't think mine crashes. But I don't ^C much.
22:29:00 <Jedai> But it's good to have it works correctly for new installations
22:29:09 <Cale> When I tried the haskeline ghci, it did nothing when I hit ^C
22:29:28 <Berengal> However, C-up now gives me 1;5A instead of just ;5A :P
22:29:29 <Cale> But that wasn't the new version of GHC one, it was just haskeline-ghci from hackage.
22:29:53 <dolio> ^C just doesn't do anything on 6.10.2 for me.
22:29:54 <Berengal> Cale: ^C works here
22:30:00 <Berengal> Better than it used to even
22:30:03 <Cale> Berengal: that's good
22:30:08 <Cale> libedit is absolutely terrible too, so good riddance.
22:30:17 <Berengal> Also, I now get "Leaving GHCi" on its own line
22:30:18 <bos> no kidding.
22:30:40 <bnijk_> haskell rocks!
22:30:45 <Cale> I had to switch back to 6.10.1, since 6.10.2 was riddled with problems caused by libedit
22:30:58 <Berengal> I almost got rid of libedit to replace it with readline, but I didn't feel like mucking about with the system libraries
22:31:04 <Cale> But if 6.10.3 is out, I'll get it.
22:31:21 <bnijk_> is anybody else done with that stuffy academic mindset of haskell
22:31:23 <bnijk_> and just think it rocks
22:31:46 <Cale> The stuffy academic mindset is why I like it.
22:31:53 <Berengal> The little testing I did proved to work though. delete key worked just fine with cp libread.so libedit.so
22:31:56 <Cale> If it loses that, I'm gone :)
22:31:59 <bnijk_> power is power Cale
22:32:00 <Jedai> Yep, and while readline was more mature than haskeline, it's more satisfying to use an Haskell library for something like this :)
22:32:31 <Berengal> Jedai: Everything written in Haskell is better, even when it isn't :P
22:32:51 <Jedai> Berengal: Fanatic !!
22:32:55 <Cale> I'm not actually so much interested in really programming as understanding interesting techniques for programs to be written and structured.
22:33:13 <vixey> monads :p
22:33:22 <bnijk_> MONADS!
22:33:35 <Berengal> Hehe. "C++'s default state is 'broken'. Haskell's default state is 'not broken'. Well, actually, it's 'not compiling, type errors about"
22:33:39 <Jedai> The "stuffy" academic mindset of Haskell is the reason we've got such an awesome language in the first place...
22:34:09 <Cale> Jedai: I agree.
22:34:09 <Jedai> I really don't see why we should be done with it
22:34:14 <bnijk_> surely you know what i mean jedai
22:34:22 <bnijk_> utility is one thing
22:34:26 <bnijk_> but you guys take yourselves too seriously!
22:35:04 <Berengal> Some day in the future, monoids in the category of endofunctors is the first things aspiring programmers will have to grok
22:35:06 <Jedai> bnijk_: Why exactly shouldn't we take ourselves seriously ?
22:35:20 <Cale> Do we really take ourselves all that seriously?
22:35:24 <bnijk_> because we are just talking monkeys who figured out how to make electrons float around, and translate between date formats!
22:35:36 <bnijk_> sure, it's great and all
22:35:36 <vixey> I actually have no clue what people mean when they talk about academica
22:35:51 * Berengal thinks translating between date formats is the most impressive of those
22:36:24 <Berengal> I think it was dons who said something like "we've been building this ivory tower for 15 years now. It's time we started throwing rocks at others from the top"
22:36:24 <bnijk_> i made some good bread today - garlic, rosemary, olive oil, some really fresh mozzerella melted into it
22:36:42 <vixey> If some researcher implemented a quantum IO monad and did shor algorithm in it -- Does that make it harder for me to write a 'webapp'?
22:36:57 <Twey> Heh
22:37:13 <Twey> Berengal: That's awesome
22:37:19 <Twey> @quote ivory tower
22:37:20 <lambdabot> No quotes for this person. Are you on drugs?
22:37:23 <Twey> :<
22:37:26 <Berengal> @quote ivory.tower
22:37:27 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
22:37:29 <bnijk_> @quote dons
22:37:30 <lambdabot> dons says: ihope reaches level 4 hacker
22:37:30 <Berengal> @quote ivory.tower
22:37:31 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
22:37:36 <Berengal> @quote ivory.tower
22:37:37 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
22:37:40 <Cale> ...
22:37:46 <Berengal> lambdabot: dons says: we had 15 years building ivory towers - time to throw rocks from the top!
22:37:55 <Berengal> I got it in /msg
22:38:09 <Cale> @keal
22:38:09 <lambdabot> what is the max amount of operands haskell can handle in a single expression?
22:38:11 <Cale> @keal
22:38:12 <lambdabot> bot defective
22:38:13 <Cale> @keal
22:38:14 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
22:38:18 <Cale> @keal
22:38:18 <lambdabot> haskell always said undefined
22:38:30 <Cale> aw, where's the crazy ones
22:38:31 <bnijk_> @faq can somebody make a haskell module to make ghci udnerstand spanish
22:38:31 <lambdabot> The answer is: Yes! Haskell can do that.
22:38:37 <bnijk_> that's not what i asked!
22:38:39 <Cale> Those are too protontorpedo-y
22:38:40 * bnijk_ kicks lambdabot
22:38:51 <Cale> @keal
22:38:51 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
22:38:54 <Cale> bah
22:39:18 <Twey> > []
22:39:21 <lambdabot>   []
22:39:26 <Twey> Well, that was three
22:39:34 <Twey> > return []
22:39:37 <lambdabot>       No instance for (Show (m [a]))
22:39:41 <lambdabot>        arising from a use of `show' at <...
22:39:47 <Twey> Oh my
22:39:51 <Cale> I wanted the ones like "nsa prevent me from returning to math on efnet"
22:39:53 <Twey> Well, that could be counted as seven
22:40:09 <Twey> Cale: o.@
22:40:18 <Cale> and "i show how spell triangle in less than three corners using darkmanifold"
22:40:26 <Berengal> @keal
22:40:26 <lambdabot> i aint running that on my puter
22:40:45 <Cale> @keal
22:40:46 <lambdabot> i have basically written a proof that shows an assumption is wrong
22:40:55 <bnijk_> umm
22:40:56 <Berengal> @keal
22:40:56 <lambdabot> it is very easy to go off topic
22:41:25 <Cale> This is what we do to trolls in #haskell
22:41:40 <bnijk_> what's a troll
22:41:43 <bnijk_> am i a troll???
22:41:46 <Cale> No
22:41:51 <bnijk_> good
22:41:56 <Berengal> Cale: What, give them their own quote command?
22:42:22 <dolio> @protontorpedo
22:42:22 <lambdabot> ok is haskell a type of lisp?
22:42:23 <Cale> A troll is someone who just posts inflammatory messages or nonsense to try to get people to respond without caring about the responses.
22:42:31 <mmorrow_> @nixon
22:42:31 <lambdabot> Scrubbing floors and emptying bedpans has as much dignity as the Presidency.
22:42:39 <dolio> @palomer
22:42:39 <lambdabot> (_|_)
22:42:44 <vixey> @farmer
22:42:44 <lambdabot> I have my oars in too many boats.
22:42:45 <mmorrow_> @. elite nixon
22:42:45 <lambdabot> 4 pUb|IC /\/\4n Mu$T N3VeR foRg37 T|-|a7 H3 l0SEz0rz HIz Us3FULNE$5 WH3N |-|E az0rz 4n indI\/IdU4L, rATH3r +H4N hIs po|Icy, 8eCoM3s thE i55ue.
22:42:49 <bnijk_> finally, somebdoy who knows the definition of troll
22:42:52 <vixey> @farmer
22:42:53 <lambdabot> My head is twice its size.
22:42:53 <mmorrow_> @. vixen . elite nixon
22:42:54 <lambdabot> i drive a pickup truck
22:42:55 <bnijk_> @. elite Caleb
22:42:55 <lambdabot> Plugin `compose' failed with: Unknown command: "Caleb"
22:42:58 <bnijk_> @. elite Cale
22:42:58 <lambdabot> Plugin `compose' failed with: Unknown command: "Cale"
22:43:02 <bnijk_> mmnn
22:43:07 <bnijk_> @. elite "hello"
22:43:07 <lambdabot> Plugin `compose' failed with: Unknown command: "\"hello\""
22:43:10 <vixey> @farmer
22:43:10 <lambdabot> Their attitude is to let lying dogs sleep.
22:43:13 <bnijk_> fuck it
22:43:19 <Cale> @yow
22:43:19 <lambdabot> Someone in DAYTON, Ohio is selling USED CARPETS to a SERBO-CROATIAN
22:43:28 <mmorrow_> preflex: nickometer bnijk_
22:43:29 <preflex>  bnijk_ is 14% lame
22:43:33 <mmorrow_> not bad
22:43:35 <bnijk_> i get those all the time in my fortune Cale
22:43:44 <bnijk_> those messages with one or two words all in caps
22:43:52 <Adamant> preflex: nickometer Adamant
22:43:53 <bnijk_> zippy the pinhead or something
22:43:53 <preflex>  Adamant is 0% lame
22:43:54 <Cale> They're quotes from Zippy the Pinhead
22:43:57 <Cale> yeah
22:44:04 <bnijk_> Rember, in 2039, MOOSE and PASTA will ONLY be available by PRESCRIPTION!
22:44:07 <bnijk_> i just got that one
22:44:25 <mmorrow_> @yow
22:44:25 <lambdabot> I wish I was a sex-starved manicurist found dead in the Bronx!!
22:44:29 <bnijk_> @yow
22:44:30 <lambdabot> People humiliating a salami!
22:44:36 <bnijk_> what a weird comic
22:45:04 <Cale> http://picturesforsadchildren.com/
22:45:06 <Berengal> \b is awesome...
22:45:32 <Berengal> (In both ways)
22:45:37 <bnijk_> /b/???
22:45:43 * bnijk_ puts Berengal on the sex offenders list
22:45:51 <dolio> backspace.
22:45:58 <Cale> bnijk_: \b = lambdabot
22:46:02 <bnijk_> no, i'm joking dolio
22:46:16 <dolio> > "abc\bdefg"
22:46:18 <lambdabot>   "abc\bdefg"
22:46:18 <mmorrow_> @vixen really?
22:46:19 <lambdabot> yup, really
22:46:41 <Berengal> \b, aka. Î»b or lambdabot
22:46:45 <bnijk_> this is good Cale
22:47:06 <mmorrow_> , "Î»"
22:47:10 <Axman6> @vixen do tell
22:47:10 <lambdabot> Are you adopted by trolls?
22:47:10 <lunabot>  "\955"
22:47:17 <Axman6> @vixen no?
22:47:18 <lambdabot> why don't you guess?
22:47:24 <Axman6> :(
22:47:26 <Berengal> , text "Î»"
22:47:27 <lunabot>  
22:48:16 * Axman6 is a little upset that Î» is not one of the characters Apple choose to out on their keyboards along with all the other extended ones, like ï£¿
22:48:58 * drhodes is upset those LCD keyed keyboards aren't mainstream, everyone has em for ten bucks.
22:48:58 <Berengal> On one hand I want to completely redo my third-level, but on the other hand I'm lazy...
22:51:13 <Twey> What on Earth is ï£¿?
22:51:23 <Twey> I need to make myself a third-level
22:51:36 <Cale> It's katakana ã?
22:51:39 <vixey> what's a third level?
22:52:23 <Twey> Cale: Huh?  That's ã‚­
22:52:27 <Twey> Looks nothing like it
22:52:32 <Cale> whaaa?
22:52:39 <Cale> They look identical in my font.
22:52:42 <Twey> o.@
22:52:43 <Cale> er
22:52:43 <Axman6> heh
22:52:53 <Cale> ï£¿ã‚­
22:52:55 <Axman6> Twey: the apple logo, on macs at least
22:53:01 <Twey> Cale: *screenshot*
22:53:04 * Cale studies the pixels.
22:53:13 <bnijk_> > iterate (++ "na") "na"
22:53:14 <lambdabot>   ["na","nana","nanana","nananana","nanananana","nananananana","nanananananan...
22:53:47 <bnijk_> how do i do it so that it does it in powers of two
22:54:01 <bnijk_> ["na","nana","nananana",...]
22:54:09 <mmorrow_> , (text . utf8enc) "\x2200"
22:54:10 <lunabot>  âˆ€
22:54:14 <vixey> > iterate (*2) 1
22:54:16 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
22:54:24 <bnijk_> no, i mean
22:54:24 <vixey> > concatMp (flip replicate "na) . iterate (*2) 1
22:54:25 <lambdabot>   <no location info>:
22:54:26 <mmorrow_> , (text . utf8enc . take 10) ['\x2200'..]
22:54:26 <lambdabot>      lexical error in string/character literal at chara...
22:54:27 <lunabot>  âˆ€âˆâˆ‚âˆƒâˆ„âˆ…âˆ†âˆ‡âˆˆâˆ‰
22:54:27 <bnijk_> with "na"
22:54:37 <vixey> âˆ€âˆâˆ‚âˆƒâˆ„âˆ…âˆ†âˆ‡âˆˆâˆ‰ nice
22:54:41 <bnijk_> oh wait
22:54:58 <mmorrow_> \x2200 is the start of the math symbols block
22:55:08 * bnijk_ thinks
22:55:14 <vixey> (^âˆ€^;) (;^A^)
22:55:35 <bnijk_> no, i have no idea
22:55:37 <bnijk_> somebody help :O
22:55:43 <Cale> Twey: http://cale.yi.org/share/Screenshot-ki.png
22:55:51 <bnijk_> all i can think of is turning [1,2,4...] into 'put this many na's in'
22:55:57 <bnijk_> there has to be a better way
22:55:57 <Twey> Cale: http://i39.tinypic.com/2hmhmax.jpg
22:55:57 <Gracenotes> > text ['\9059'..]
22:55:59 <lambdabot>   â£â¤â¥â¦â§â¨â©âªâ«â¬â­â®â¯â°â±â²â³â´âµâ¶â·â¸â¹âºâ»...
22:56:03 <Berengal> > iterate (join (++)) "na"
22:56:05 <lambdabot>   ["na","nana","nananana","nananananananana","nananananananananananananananan...
22:56:12 <bnijk_> ah ok
22:56:18 <Cale> Twey: Interesting.
22:56:21 <Twey> Indeed
22:56:35 <Twey> Seems it's an undefined character
22:56:42 <Twey> Fonts just add in whatever they feel like
22:56:48 <Cale> ah, that would explain it
22:57:09 <Cale> MS Gothic is my first substitute font.
22:57:10 <bnijk_> Twey: ?
22:57:13 <Gracenotes> â¥
22:57:32 <Berengal> Ã–
22:57:42 <bnijk_> i must have a thousand fonts on here
22:57:52 <Twey> âˆµ
22:57:53 <Gracenotes> Ã–
22:57:56 <bnijk_> i'm thinking of configuring fluxbox to have a font made entirely out of traffic signs for the window headers
22:58:03 <Twey> bnijk_: o.@
22:58:05 <bnijk_> mmnnn...that would be sweet
22:58:05 <Twey> Ew
22:58:09 <Gracenotes> Ó¦
22:58:19 <bnijk_> i don't even have window headers right now Twey i have dwm and xmonad
22:58:20 <Gracenotes> oh, so you had the cyrillic one
22:58:34 <Cale> ê™®_ê™® Bzzzz!
22:58:40 <Twey> Cale: I haven't a clue what my first substitute font is.  How may I tell?
22:58:42 <drhodes> æ™®é€šè¯ï¼
22:58:45 <Axman6> âˆš2
22:58:46 <Twey> Haha, nice
22:59:18 <Berengal> Unicode is fun
22:59:44 <bnijk_> are there any decent FRP games yet
22:59:49 <Gracenotes> ã‚·
23:00:01 <mmorrow_> sweeet, there are pullback and pushout unicode syms
23:00:15 <Qork> lol Java feels so primitive to program now
23:00:36 <vixey> I like primitive
23:00:38 <Gracenotes> áš˜áš˜áš˜
23:00:39 * Axman6 likes programming with primitive haskell
23:00:47 <vixey> Qork: In terms of programming we are like cavemen
23:00:48 <mmorrow_> , uncurry (<+>) (text "pullback", (text . utf8enc) "âŸ“")
23:00:49 <lunabot>  pullback âŸ“
23:00:49 <Qork> Cale: but how does one get interested in program structure and correctness if not interested in programming from the start?
23:00:51 <Cale> Twey: Look in ~/.fonts.conf or /etc/fonts/fonts.conf for something which looks like <alias> <family>sans-serif</family> <prefer> <family>...</family> ...
23:00:51 <Berengal> Ð°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ²Ð²Ñ…Ñ‹Ð·
23:00:58 <mmorrow_> , uncurry (<+>) (text "pushout", (text . utf8enc) "âŸ”")
23:01:00 <lunabot>  pushout âŸ”
23:01:28 <Cale> Qork: Well, I mean that there aren't really many programs which I'd like to actually write myself.
23:01:40 <Gracenotes> à²°_à²°
23:01:48 <vixey> Cale, you could write a program that computes factorial :D
23:01:49 <Twey> Cale: I don't have any <alias> elements in my /etc/fonts/fonts.conf
23:01:50 <Axman6> mmorrow_: what are those for?
23:01:56 <Gracenotes> à³ 
23:02:10 <Cale> Qork: But the matter of writing programs, I find intrinsically interesting.
23:02:14 <Cale> vixey: I could.
23:02:17 <Gracenotes> or even à²Šà²‰à²Šà²‰à²Šà²‰à²Šà²‰à²Šà²‰à²Šà²‰ .. okay, enough :)
23:02:33 <vixey> Gracenotes looks really nice
23:02:36 <Twey> Can't see any of those
23:02:42 <vixey> I think I saw a bible written in that text once
23:02:54 <Twey> Oh, I can on the desktop
23:03:01 <Twey> They kind of overlap one another, though
23:03:20 <Axman6> woah... are those supposed to have text around the outside Gracenotes?
23:03:36 <Cale> Twey: Actually, now that I look at it, Verdana is my first sans-serif font, followed by ï¼­ï¼³ ã‚´ã‚·ãƒƒã‚¯
23:03:38 <Gracenotes> don't think so...
23:03:41 <Twey> Kannada huh
23:03:47 <Twey> That's pretty stylish
23:03:58 * Twey adds it to his list of languages to learn
23:04:01 <Cale> and then Meiryo, DejaVu Sans, IPAPGothic, and a bunch of others
23:04:20 <Axman6> Gracenotes: sec, i'll upload a pic of what i mean
23:04:23 <wy> hello, anyone with compilers here?
23:04:33 <Twey> I have a compiler!
23:04:38 * Axman6 has lots of compilers
23:04:39 <Berengal> I have tons of compilers
23:04:43 <Twey> Several, actually
23:04:44 <Berengal> A whole collection of them
23:04:50 <pumpkin_> > let seconds x = show x ++ " seconds" in 5 `seconds` -- boo :(
23:04:51 <lambdabot>   <no location info>: parse error on input `;'
23:04:56 <drhodes> I only have a parser :<
23:05:17 <Cale> Aw, you have a parser? I only have a register allocator :(
23:05:30 <wy> I mean compiler writing...
23:05:31 <drhodes> when I was kid, we didn't have switches.
23:06:34 <Axman6> Gracenotes: http://twitpic.com/4wl8c
23:07:45 <Gracenotes> oh, that's interesting
23:08:03 <Gracenotes> looks like this for me: http://i124.photobucket.com/albums/p28/Grac3not3s/chain.png
23:08:36 <Gracenotes> it's possible your client renders it that way because it can't otherwise?
23:08:58 <Axman6> my terminal supports UTF-8 just fine
23:09:22 <mle> that doesn't mean it understand how to render everything, or has the fonts.
23:09:30 <Gracenotes> yes. but it might not be able to render that specific character
23:09:32 <mmorrow_> , let sp n = replicate n ' ' in vcat . fmap (text . utf8enc) $ ["âŸ“"++sp(2)++"â†’"++sp(2)++"a","â†“"++sp(6)++"â†“","b"++sp(1)++"â†’"++sp(2)++"c"]
23:09:33 <lunabot>  âŸ“  â†’  a
23:09:33 <lunabot>  â†“      â†“
23:09:33 <lunabot>  b â†’  c
23:09:52 <Gracenotes> I don't know of any complete Unicode font
23:10:18 <mmorrow_> , let sp n = replicate n ' ' in vcat . fmap (text . utf8enc) $ ["a"++sp(2)++"â†’"++sp(2)++"b","â†“"++sp(6)++"â†“","c"++sp(1)++"â†’"++sp(2)++"âŸ”"]
23:10:19 <lunabot>  a  â†’  b
23:10:19 <lunabot>  â†“      â†“
23:10:19 <lunabot>  c â†’  âŸ”
23:10:22 <Gracenotes> for example, I can't render á±±. It's supposed to look like http://www.fileformat.info/info/unicode/char/1c71/ol_chiki_letter_en.png
23:10:31 <mmorrow_> grr, so hard to get unicode spacing right
23:10:38 <vixey> haha
23:10:48 <Gracenotes> use a monospaced font!
23:10:58 <mmorrow_> heh, good idea
23:11:08 <mmorrow_> are there monospaced unicode fonts?
23:12:26 <Gracenotes> well, uh, ChatZilla with the generic Ubuntu 8.04 "monospace" font seems to display them well enough
23:12:47 <pumpkin_> hmm, I need to make a really simple GUI for something
23:13:01 <pumpkin_> what's the quickest path from nothing to GUI in haskell?
23:13:08 <mmorrow_> Axman6: a product is a pullback s.t.:
23:13:24 <Gracenotes> glade?
23:13:33 <mmorrow_> , let sp n = replicate n ' ' in vcat . fmap (text . utf8enc) $ ["a><b"++sp(2)++"â†’"++sp(2)++"a","â†“"++sp(6)++"â†“","b"++sp(1)++"â†’"++sp(2)++"terminal"]
23:13:35 <lunabot>  a><b  â†’  a
23:13:35 <lunabot>  â†“      â†“
23:13:35 <lunabot>  b â†’  terminal
23:13:50 <mmorrow_> and a coproduct is a pushout from the initial object
23:14:08 <mmorrow_> so products and coproducts are special cases of pullbacks and pushouts
23:14:26 <mmorrow_> which are in turn special cases of limits, which are in turn ...
23:14:34 <mmorrow_> (co)limits
23:14:41 <mmorrow_> , ..
23:14:42 <lunabot>  luna: parse error on input `..'
23:15:37 <Gracenotes> voodoo, man
23:15:52 <mmorrow_> and a product that's a pullback from a non-terminal object is a `fibered-product'
23:16:12 <TomMD> pumpkin_: I've had good luck with gtk2hs, but be sure to get the exact version of GHC the gtk2hs site specifies!
23:16:36 <pumpkin_> GTK feels too imperative though :(
23:16:44 <wy> okay. Let me try again. Anybody interested in discussing about register allocation and move biasing in compilers?
23:18:10 <Axman6> wy: might find some willing ears in #ghc
23:18:35 <wy> Axman6: good idea. I will try
23:18:54 <TomMD> pumpkin_: Sure does - if someone knows of one thats more declaritive and ready for real use then I'm all ears.
23:19:08 <pumpkin_> :)
23:19:17 <pumpkin_> eww, why is gtk2hs on sourceforge?
23:19:19 <Gracenotes> hm. is event-based not that declarative?
23:20:13 <TomMD> pumpkin_: Yeah, it isn't exactly friendly to install.  Even once you get it installed it might bite you, so be careful.
23:20:27 <mmorrow_> wy: i've been looking at these recently http://www.cs.tufts.edu/~nr/pubs/gcra-abstract.html   http://www.cs.tufts.edu/~nr/pubs/staged-abstract.html  www.cs.utexas.edu/users/pingali/CS380C/2007fa/papers/p66-chaitin.pdf
23:20:42 <mmorrow_> but i    must   sleeep
23:20:46 <mmorrow_> :)
23:21:55 <wy> similar to me though
23:22:05 <wy> thanks for the link
23:22:16 <mmorrow_> np
23:24:15 <wy> anyway, I found as if graph coloring is not the right formulation for register allocation. Maybe we can discuss about that later
23:24:41 <vixey> wy I saw some sequent calculus for register allocation
23:27:46 <PetRat> In this example from RWH--> http://www.mibbit.com/pb/gNEJut  they use mapM_ to map an action (putStrLn) from within the IO monad. Can I do this generally inside any do-notation? Is there a restriction on the types of the function and data involved?
23:28:25 <leadnose> see the type of mapM_
23:28:32 <leadnose> @ty mapM_
23:28:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:29:56 <mmorrow_> wy: cool, that sounds interesting, i'll catch you later
23:30:08 <leadnose> so yes, it can be used elsewhere, when you want to return () at the end
23:30:21 <PetRat> I see. Why is the last monad on type () rather than m b?
23:30:40 <PetRat> Oh.. I know why.. because you are implicitly sequencing them?
23:30:54 <mmorrow_> so nothing has to be held onto
23:30:55 <PetRat> You can't sequence a bunch of m b and get m b, or something like that?
23:31:03 <leadnose> mapM_ throws the results away, mapM doesn't
23:31:12 <leadnose> @ty mapM
23:31:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:31:27 <PetRat> I see...
23:31:57 <PetRat> thanks
23:32:01 <PetRat> leadnose++
23:38:14 <leadnose> lambdabot++
23:38:55 <beelsebob> @ty sequence
23:38:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:39:00 <beelsebob> PetRat: that more specifically
23:48:03 <jbjohns>  @search StateT
23:48:12 <jbjohns> @haddock StateT
23:48:13 <lambdabot> Unknown command, try @list
23:48:16 <jbjohns> @list
23:48:16 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:48:32 <ivanm> @index StateT
23:48:32 <lambdabot> Control.Monad.State, Control.Monad.RWS, Control.Monad.State, Control.Monad.RWS
23:48:35 <ivanm> @hoogle StateT
23:48:36 <lambdabot> Control.Monad.State.Lazy newtype StateT s m a
23:48:36 <lambdabot> Control.Monad.State.Lazy StateT :: s -> m (a, s) -> StateT s m a
23:48:36 <lambdabot> Control.Monad.State.Strict newtype StateT s m a
23:48:45 <jbjohns> ah, thanks
23:49:41 <bnijk_> listen to my cd http://www.zshare.net/download/59367817ecf88809/
23:49:44 <bnijk_> or i'll kill you
23:53:13 <pumpkin_> anyone done the hough transform in haskell?
23:57:13 <ivanm> bnijk_: you'll have to find me first...
23:57:29 <bnijk_> i don't care
23:58:11 <ivanm> *shrug* suit yourself
23:58:18 <ivanm> I'm not doing anything that important
23:58:54 * bnijk_ rolls a cigarette
23:59:24 <NEEDMOAR> Sweet?
