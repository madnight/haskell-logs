00:10:08 <Sentinel34> what does the $ do in listArray?
00:10:10 <Sentinel34> listArray (1,42) $ repeat Blank
00:11:07 <johnw> f $ x y = f (x y)
00:11:52 <Sentinel34> so repeat Blank is evaluated, then listArray?
00:11:52 <johnw> it's just a low-associativity function application operator, as opposed to "space" which is high-associativity
00:12:02 <cnwdup> dcoutts, are you there?
00:12:03 <johnw> the result of repeat Blank is the second argument
00:12:28 <johnw> you can't say that it's evaulated though
00:12:29 <Cale> Or precedence rather than associativity, but that's perhaps being too pedantic :)
00:12:53 <johnw> it's possible it may never be evaluated, it's depends on listArray and the user of its result value
00:13:16 <johnw> Cale: ah, right, precedence then
00:15:06 <Cale> Yeah, in fact, if it's lazy evaluation, which is outermost-first, ($) will get evaluated, then listArray, and then potentially the parameters (1,42) and (repeat Blank), depending on how listArray makes use of them.
00:15:36 <Sentinel34> oh ok, so instead of making a list of [Blank, Blank, ... ] 42 times and saying listArray (1,42) [Blank, Blank, ...]. its efficient to do listArray (1,42) $ repeat Blank
00:16:04 <beelsebob> well, it's not more efficient
00:16:06 <Cale> Well, yes, even though that repeat Blank is an infinite list
00:16:07 <beelsebob> but at least as
00:16:14 <beelsebob> actually, maybe it is more efficient
00:16:17 <beelsebob> constant memory use
00:16:46 <Sentinel34> yeah, but because I have (1,42), listArray function will stop at the 42nd Blank
00:16:58 <Cale> Only the part of that infinite list which the listArray uses will be constructed (and in fact, it'll look like a 1-element cycle in memory, so very efficient in that sense)
00:17:23 <Cale> @src repeat
00:17:24 <lambdabot> repeat x = xs where xs = x : xs
00:17:54 <Athas> If I read the contents of a file as a lazy list, then pass that list to some pure function, but access to the file is disrupted during execution of that function, what will happen?
00:17:56 <Cale> Those xs will all reference the same location in memory
00:18:11 <Athas> Actually, I know that depends on the function constructing the list, but how is stuff like this handled in normal Haskell programs?
00:18:14 <Cale> Athas: Typically the list will end.
00:18:47 <Cale> (abruptly, in a somewhat hard to predict way)
00:19:02 <Athas> It seems like a somewhat thorny issue.
00:19:12 <Cale> Basically, don't use lazy IO if there's a possibility of the file going away
00:19:49 <Cale> Lazy I/O (getContents/readFile/etc.) is wonderful for small applications but it's not very robust
00:20:15 <Athas> Are there any articles written on robust file handling?
00:20:32 <Cale> Well, there's the documentation for System.IO
00:20:39 <Athas> I know I can just load the entire contents of the file into memory, but maybe someone figured out a more clever way.
00:21:14 <Cale> Basically, it works similarly to most imperative languages -- openFile will get you a file handle, then you'll use things like hGetLine to read lines from your file, and you can catch exceptions which are thrown.
00:21:36 <Cale> Oh, if you just want strict IO which is still coarse grained
00:21:44 <Athas> I suppose that is the most reasonable way.
00:21:45 <Cale> You can use Data.ByteString.Char8
00:22:04 <Cale> Its version of getContents is strict and will slurp the entire file at once.
00:22:14 <Athas> I suppose that this is not actually worse than normal languages, just not as good as Haskell usually is.  Ah well, the trials of the real world...
00:24:27 <Athas> How stable are the GHC extensions?  And I'm not just thinking implementation maturity, but also whether their semantics will change in the future.
00:28:04 <Cale> It varies... some of them are simple enough that they're unlikely to change very much.
00:28:48 <Cale> Actually for most of them, it's fairly likely that they'll end up standardised themselves.
00:29:13 <Athas> I mostly use type system extensions, like ExistentialQuantification, RankNTypes, FunctionalDependencies and MultiParamTypeClasses.
00:29:53 <Cale> FDs and MPTCs are unlikely to be dropped any time too soon, but there are some other extensions which are competing.
00:30:48 <Cale> (specifically TypeFamilies)
00:33:02 <Cale> But the specification of those probably won't change much. Well, I think I have heard of subtle changes to the way functional dependencies work from time to time, but I seem to recall they were things which would be hard to notice unless you're doing lots of tricky type-level computation.
00:34:40 <Athas> I'm not really doing that (yet!).  I just think Haskell 98 is unnecessarily restrictive.
00:34:59 <Athas> GHC with type system extensions is more like how I expect a powerful static type system to feel.
00:37:48 <Cale> Well, yeah, everyone uses them.
00:39:18 <twb> Why does the Prelude have >>, >>= and =<< but not <<?
00:42:10 <matthew-_> @tell ivanm I have a polyparse parser that parses dot format
00:42:10 <lambdabot> Consider it noted.
00:43:38 <matthew-_> huh, the graphviz package already does that...
00:43:52 <jre2> is there a builtin for:  foldr ($) x [f,g,h]  ? effectively composition of a list of functions? apparently hoogle doesn't like searching for "[(a->a)]"
00:45:00 <matthew-_> ivanm: ahh I see, yeah, my current code for parsing back in dot files is a bit more robust than is in the graphviz package
00:45:42 <da-x> wli: thanks
00:46:10 <Berengal> > foldr (.) id [(+1), (*3), abs] (-15)
00:46:11 <lambdabot>   46
00:47:15 <Berengal> Hmmm
00:47:25 <Berengal> > foldl (.) id [(+1), (*3), abs] (-15)
00:47:27 <lambdabot>   46
00:52:13 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2285#a2285
00:53:24 <povman> If I change the 'a' to 'forever a' it does things. But I believe it should at least just print "ping" once the way it is there...
01:02:56 <beelsebob> povman: immediately after the do: hSetBuffering stdout NoBuffering
01:03:08 <beelsebob> (and import System.IO)
01:07:22 <dcoutts> cnwdup: pong
01:11:53 <cnwdup> dcoutts, could you assist me with the function void gdk_property_change(GdkWindow *window, GdkAtom property, GdkAtom type, gint format, GdkPropMode mode, const guchar *data, gint nelements);? I cannot get the types for the first argument to behave correctly. http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2286#a2286
01:13:59 <dcoutts> cnwdup: you need to {# import #} the .chs module that defines the mappings bettween the C types and Haskell types, ie the mapping between GdkWindow * and Window
01:16:17 <cnwdup> dcoutts, that'd be Graphics.UI.Gtk.Types, right?
01:16:39 <dcoutts> cnwdup: I think so, yes
01:16:49 <cnwdup> dcoutts, they are imported using {#import ...#}.
01:18:06 <cnwdup> dcoutts, I already tried the foreign import call using Window instead of Ptr (), but it says Window isn't usable or something. I can post the exact error if needed.
01:20:26 <dcoutts> cnwdup: if the mapping between the types is in scope then c2hs will import it at the right type, ie Window or Ptr Window
01:22:37 <cnwdup> dcoutts, what do you mean by mapping? Is it the toWindow or the Window newtype declaration?
01:24:17 <dcoutts> cnwdup: it's a c2hs {# pointer #} directive in the Types module which you get when you {# import #} it. (Not the same as ordinary import)
01:26:22 <cnwdup> I have imported Graphics.UI.Gtk.Types and Graphics.UI.Gtk.Genereal.DNDTypes that way. So is DrawWindow actually the right type which is being inferred or am I missing the right module? I experience almost the same problem for the Atom type.
01:28:36 <dcoutts> cnwdup: ah yes, I misread. GtkWindow* is Window but GdkWindow* is DrawWindow
01:29:12 <cnwdup> dcoutts, ah. My bad.
01:48:25 <cristi_ceata> hello! what functions can I use to get the minimum and maximum values of Int, Double, Char?
01:49:03 <Deewiant> > minBound :: Int
01:49:04 <lambdabot>   -9223372036854775808
01:49:07 <Deewiant> > maxBound :: Char
01:49:08 <lambdabot>   '\1114111'
01:49:10 <cristi_ceata> which encoding does Char use? ASCII? UTF?
01:49:22 <Deewiant> It's a Unicode codepoint
01:49:24 <Deewiant> So essentially UTF-32
01:49:38 <cristi_ceata> ok. thanks
01:50:03 <quicksilver> cristi_ceata: Char isn't encoded.
01:50:06 <quicksilver> it just is. :)
01:50:13 <Sentinel34> is the // operator the same as \\? I can't seem to find a reference to it in the Real World Haskell book
01:50:22 <quicksilver> Sentinel34: similar. One is for lists and one is for arrays.
01:50:24 <Deewiant> ?ty (//)
01:50:25 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
01:50:26 <Deewiant> ?ty (\\)
01:50:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
01:50:39 <Sentinel34> ohh
01:51:51 <cristi_ceata> > minBound :: Double
01:51:52 <lambdabot>       No instance for (Bounded Double)
01:51:52 <lambdabot>        arising from a use of `minBound...
01:52:09 <Deewiant> Floating point goes to infinity
01:52:18 <cristi_ceata> really?
01:52:23 <Deewiant> > -1/0 :: Double
01:52:25 <lambdabot>   -Infinity
01:53:59 <p_l> > 0/0 :: Double
01:54:00 <lambdabot>   NaN
01:54:23 <quicksilver> well, there is of course a smallest finite value in Double
01:54:31 <p_l> hmmm
01:54:36 <quicksilver> but it's possibly not a very useful instance for Bounded.
01:54:57 <p_l> > (1/0)/(-1/0) :: Double
01:54:58 <lambdabot>   NaN
01:55:02 <p_l> ^^;
01:56:30 <cristi_ceata> the what is the difference  between Haskell and C concerning Double?
01:56:43 <cristi_ceata> s/the/then
01:56:49 <mmorrow> quicksilver: if you recall the short discussion about seeing a tree of the modules in a package.conf yesterday, i made a quick prog to (package.conf -stdin-stdout-> html)
01:57:02 <wli> infinite values aren't very small
01:57:07 <mmorrow> quicksilver: http://moonpatio.com/repos/PackageTree.hs
01:58:02 <mmorrow> quicksilver: one nice thing is that since package.conf is a valid haskell expression, you can just parse it as such and extract info that way
01:58:11 <ivanm> matthew-_: _now_ you tell me?!?!?!?!?!? :@
02:01:41 <ivanm> matthew-_: have you released said code yet?
02:01:57 <quicksilver> mmorrow: Hmm, nice.
02:02:18 <quicksilver> mmorrow: haddock doesn't produce something like this automatically? where do the index pages on haskell.org come from?
02:02:33 <mmorrow> quicksilver: (in case you're wondering about that sledgehammer-killing-a-fly trie code, i just had that "laying around")
02:03:01 <mmorrow> quicksilver: the thing this does that haddock doesn't is this shows you a tree of *all* modules in a package.conf
02:03:16 <mmorrow> so the global namespace available on a machine
02:03:28 <mmorrow> (well, for a particular package.conf)
02:03:35 <quicksilver> ah, I see.
02:08:03 <Berengal> Nice mmorrow
02:08:23 <mmorrow> Berengal: ahh yeah, it was you that was talking about this, right?
02:08:47 <Berengal> Yeah, I seem to remember asking if there was such a tool at least
02:09:00 <earthy> um. dang. the .hi files are binary these days, right?
02:09:01 <mmorrow> Berengal: cool. yeah, i like this idea
02:09:15 <Berengal> Does this take multiple package.confs, or only a single one?
02:09:22 <quicksilver> I suppose it woudl be most elegant to have this as a haddock feature though
02:09:23 <earthy> and the ghc user's guide says 'go look at the interface file to find out what the compiler thinks about a function's strictness'
02:09:29 <quicksilver> so it integrates with the rest of the doc.
02:09:38 <earthy> so, is there a tool to display the .hi files?
02:09:42 <mmorrow> Berengal: single one. that could easily be changed though (that's a good idea)
02:10:36 <ivanm> earthy: I would think you'd look at the core output to see about strictness, rather than the .hi files...
02:10:44 <earthy> that's not what the docs say. :)
02:10:51 <earthy> but yeah.
02:11:01 <ivanm> IIRC, that's what RWH says ;-)
02:11:37 <Berengal> mmorrow: yeah, it'd be nice to be able to get the set of all modules on a system, not just a single package.conf. (I at least got packages both in the global and user package.confs)
02:11:45 <earthy> I don't have RWH handy
02:11:58 <earthy> maybe I should go buy a copy :)
02:12:30 <ivanm> @where RWH
02:12:30 <lambdabot> is http://www.realworldhaskell.org/blog/
02:12:32 <ivanm> earthy: ^^
02:13:11 <earthy> yah, doesn't do much for me in a train :)
02:13:16 <ivanm> heh
02:13:25 <ivanm> well, if you're able to talk on IRC on the train...
02:13:46 <earthy> yah. ofcourse, I've read parts of rwh online before it was published
02:13:53 <earthy> but I never got 'round to reading the whole thing
02:14:01 <dmead> ?src filter
02:14:01 <lambdabot> filter _ []     = []
02:14:01 <lambdabot> filter p (x:xs)
02:14:01 <lambdabot>     | p x       = x : filter p xs
02:14:01 <lambdabot>     | otherwise = filter p xs
02:14:27 * ivanm wonders if its efficiency, etc. would be any different as a foldr...
02:15:03 <ivanm> i.e. filter p = foldr (\x ys -> if (p x) then x:ys else ys) []
02:17:32 <earthy>   %GC time      68.9%  (69.2% elapsed)
02:17:41 <earthy> hm. that's a good hint as to 'oops'
02:17:45 <quicksilver> earthy: ghc --show-iface
02:17:52 <quicksilver> earthy: or -ddump-simpl
02:17:52 <earthy> quicksilver: thanks!
02:18:03 * ivanm wishes ghc had a man page
02:18:11 <quicksilver> and, yes, go buy a copy of RWH.
02:18:16 <quicksilver> it's good for the soul
02:18:20 <ivanm> just for all the command-line options
02:18:23 <earthy> it is indeed :)
02:18:27 <earthy> ivanm: write it! :P
02:18:46 <ivanm> quicksilver: and for authors' back pockets? :p
02:18:52 <ivanm> earthy: heh
02:19:30 <quicksilver> yes, probably.
02:19:39 <quicksilver> although I doubt they're swanning off to a desert island.
02:19:53 <ivanm> yeah
02:20:08 <ivanm> the internet there probably wouldn't be fast enough ;-)
02:20:45 <ivanm> (how else are they going to be able to get the latest version of haskell packages, etc., let alone what I'm sure is the copious amounts of fan mail they get... :p )
02:22:44 <mmorrow> Berengal: it now takes any number of concatenated package.confs on stdin http://moonpatio.com/repos/PackageTree.hs
02:23:54 <povman> beelsebob: whoa, sorry for leaving - the hSetBuffering didn't fix it
02:24:04 * earthy prefers reading from dead trees
02:24:29 <earthy> a kindle would probably be nice as well , but somewhat unavailable in .nl
02:24:40 <earthy> and the iliad ereader is Way Too Expensive
02:24:46 <Sentinel34> is this legal haskell code? if (True && True) blah else blah
02:25:02 <earthy> > if (True && True) then 1 else 2
02:25:04 <lambdabot>   1
02:25:08 <earthy> you missed a then
02:25:14 <Sentinel34> oh ok
02:26:12 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2285#a2287
02:26:43 * ManateeLazyCat pasted "my code" at http://paste2.org/get/195619
02:26:50 <ManateeLazyCat> Can make above code more simpler?
02:27:12 <povman> It seems to be that it's starting a _thread_, then quitting before it gets a chance to run.
02:27:34 <quicksilver> earthy: kindle is so last-year. For reading ebooks, you want a macbook touch : http://www.yankodesign.com/2009/04/29/macbook-touch-maybe-just-maybe/
02:28:11 <quicksilver> povman: probably, yes. I think there is some reactive 'main loop' you're supposed to run.
02:28:44 <povman> quicksilver: It works if i exchange the last line for 'forever a'
02:28:56 * quicksilver nods
02:29:10 <quicksilver> I'm not familiar with how you're supposed to run the FRP.Reactive main loop :)
02:30:06 <ivanm> quicksilver: I thought the next thing was VR via implants... >_>
02:30:12 <earthy> quicksilver: I have a new macbook white
02:30:24 <ivanm> earthy: what does the colour have to do with it?
02:30:34 <earthy> oled's and lcd's are *not* epaper
02:30:46 <Berengal> mmorrow: It works for a single package.conf, but when I cat two I get an empty file, no error messages...
02:31:04 <Berengal> mmorrow: Well, empty except <ul></ul>
02:31:29 <mmorrow> Berengal: hmm
02:31:35 <mmorrow> did you do it like:
02:31:37 <Berengal> $ cat .ghc/x86_64-linux-6.10.2/package.conf /usr/local/lib/ghc-6.10.2/package.conf | ./PackageTree >tree.html
02:31:48 <mmorrow> crap, ok a sec
02:31:49 <Berengal> (from home dir)
02:34:14 <mmorrow> Berengal: hmm, i can't seem to get it to fail. could you paste those package.confs?
02:34:44 <Berengal> mmorrow: Sure, hang on
02:34:45 <Gracenotes> hm. how is 'totient' pronounced?
02:34:54 <Gracenotes> toe-shent.. toe-tee-ent..
02:34:58 <quicksilver> to rhyme with quotient
02:35:19 <quicksilver> "toe-shee-ent" or simply "toe-shent"
02:35:23 <Gracenotes> great. as suspected :D
02:35:25 <quicksilver> depending on style.
02:36:10 <povman> Hm. I don't believe in the "Reactive Main Loop"!
02:36:40 <povman> The GLUT adapter puts an 'updater' into the glut main loop
02:38:35 <Berengal> mmorrow: http://codepad.org/Wgunvlm0 <- as outputted by cat
02:38:51 <mmorrow> Berengal: perfect, thx
02:39:55 <mmorrow> Berengal: it looks like codepad truncated your paste
02:40:02 <Berengal> Bah!
02:40:15 <Berengal> At least hpaste told me there was too many characters...
02:40:27 <mmorrow> try moonpatio.com, iirc it has a larger limit than hpaste.org set
02:41:12 <Berengal> mmorrow: Not large enough :/
02:41:13 <quicksilver> surely hpaste *is* moonpatio.com now ?
02:41:45 <quicksilver> oh, it's not.
02:41:47 <quicksilver> that confused me!
02:42:00 <mmorrow> quicksilver: heh, i merged them initially, but then just never ended up taking moonpatio.com's hpaste down
02:42:14 <quicksilver> was there not a period of time when hpaste.org redirected to moonpatio?
02:42:41 <mmorrow> err, so hpaste.org points to one hosted server that i have, and moonpatio.com points to another
02:43:16 <Berengal> mmorrow: I could just email it to you...
02:44:32 <mmorrow> quicksilver: oh yeah, i think hpaste.org did shortly point to moonpatio.co
02:44:34 <mmorrow> m
02:45:09 <Berengal> Sent
02:45:25 <mmorrow> cool
02:48:00 <mmorrow> Berengal: odd, it parses ok for me. what version of haskell-src-exts do you have?
02:48:04 <mmorrow> i have haskell-src-exts-0.4.8
02:48:31 <Berengal> 0.4.8 ... :/
02:48:34 <mmorrow> (although i'd expect any version of haskell-src-exts to handle this..)
02:51:00 <mmorrow> Berengal: what happens if you try this in ghci?
02:51:12 <mmorrow> ghci> print . parseHsExp =<< readFile "berengal.conf" {- whatever the filename is -}
02:51:21 <mmorrow> (ghci> :m + Language.Haskell.Meta)
02:51:30 <Berengal> mmorrow: I was just about to try that :)
02:52:31 <Berengal> I get a bunch of stuff printed, so that works...
02:54:51 <mmorrow> Berengal: weird, i wonder what's happening
02:55:59 <mmorrow> what about:
02:56:02 <mmorrow> ghci> print . pipeline . mergeListApps . (\(Right e)->e) . parseHsExp =<< readFile "berengal.conf" {- whatever the filename is -}
02:56:16 <dobblego> why when I bootstrap cabal-install do I get Could not find module `Codec.Compression.GZip': ?
02:56:39 <mmorrow> if that works then i can't imagine what could be happening
02:57:25 <mmorrow> dobblego: looks like you need the zlib pkg
02:58:02 <jkff> dobblego: Also, if you're on linux, do you have the native zlib package?
02:58:26 <Berengal> mmorrow: No mergeListApps (working in PackageTree.hs)
02:59:00 <mmorrow> Berengal: what do you mean? it didn't work or it's not in there?
02:59:05 <Berengal> Not in scope
02:59:10 <mmorrow> ahhhh, ok. :)
02:59:16 <mmorrow> so you have the old version
02:59:26 <mmorrow> i updated it http://moonpatio.com/repos/PackageTree.hs
02:59:53 <Berengal> It would seem my copy-paste skills are sub-average :(
03:00:01 <mmorrow> heh
03:01:44 <dobblego> mmorrow, do you know the debian/ubuntu package name for that?
03:02:05 <mmorrow> dobblego: i don't
03:02:12 <mmorrow> with yum i'd just do
03:02:17 <mmorrow> sudo yum list *zlib*
03:02:38 <quicksilver> zlib1g-dev, dobblego
03:02:38 * ivanm would just do "eix zlib"
03:02:41 <mmorrow> dobblego: oh, you mean the _haskell_ zlib pkg?
03:02:41 <quicksilver> or something similar.
03:03:00 <ivanm> mmorrow: you need to sudo to just _list_ packages? :/
03:03:02 <Berengal> mmorrow: Works beautifully
03:03:12 <mmorrow> Berengal: sweet!
03:03:20 <ivanm> mmorrow: I take it the PackageTree is fhr ghc package.conf files?
03:03:21 <mmorrow> ivanm: i don't know
03:03:32 <ivanm> well, it's your code!
03:03:35 <ivanm> :p
03:03:40 <mmorrow> ivanm: yes, although ModuleTree would be a better name for it
03:03:52 <dobblego> zlib1g-dev is already installed
03:03:56 <mmorrow> ivanm: (i meant i don't know if i need to sudo for yum list :)
03:04:01 <dobblego> mmorrow, I'm just trying to get cabal install going
03:04:03 <ivanm> mmorrow: heh, I guessed that
03:04:23 <ivanm> it was just funny seeing you say "i don't know" after I ask you about your code ;-)
03:06:37 <mmorrow> dobblego: one thing you can do that'll definitely work is to wget the zlib tarball from hackage, unpack, and build it with (ghc --make Setup.*hs && ./Setup configure && ./Setup build && sudo ./Setup install)
03:07:16 <mmorrow> ivanm: perfect timing
03:07:24 <ivanm> yup
03:20:27 <twb> Prelude Text.PrettyPrint.HughesPJ> quotes $ text "Foo" ==> 'Foo'
03:20:47 <twb> Can I get it to give me the "raw" version, i.e. deriving Show?
03:21:11 <ivanm> twb: I don't think so..
03:21:15 <ivanm> IIRC, they've hidden that
03:23:00 * quicksilver hates libraries which do that.
03:23:14 <quicksilver> a standard show instance makes it so much easier to explore unfamiliar code.
03:23:25 <quicksilver> that's one of my few differences with malcolmw's design decisions ;)
03:23:35 <twb> What's the difference between $+$ and $$?
03:24:08 <malcolmw> quicksilver: noted
03:24:30 <quicksilver> malcolmw: well I think I mentioned it to you yonks ago, the first time I tried to use haxml :)
03:25:59 <malcolmw> quicksilver: OK, will fix
03:26:10 <twb> Grr.  The difference is that Darcs' crack-addled in-house copy of HughsePJ doesn't have a $+$
03:27:50 * EmielRegis http://www.collegehumor.com/article:1775019
03:28:04 <Twey> quicksilver: Agreed
03:51:37 <dmead> ski++
03:51:52 <dmead> ?seen lambdabot
03:51:52 <lambdabot> Yes, I'm here. I'm in #not-math, ##hrg, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosxdev, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
03:51:52 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-books, #haskell-blah, #haskell-in-depth, #haskell-freebsd, #macosx, ##
03:51:52 <lambdabot> freebsd, #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #concatenative, #arch-haskell, #functionaljava, #novalang, #darcs, #yi, #xmonad, #ghc, ##logic, #haskell-overflow and #
03:51:53 <lambdabot> haskell
03:52:05 <dmead> ski_, ++
03:52:08 <dmead> ++ski
03:54:23 <eu-prleu-peupeu> hello
03:59:22 <Athas> Does Cabal have any facilities for dealing with mutually recursive/dependent modules?
03:59:28 <Athas> I know GHC supports it through some magic files.
03:59:49 <dcoutts> Athas: if you do the ghc magic it'll work with Cabal
03:59:58 <Athas> Oh, neat.
04:00:09 <dcoutts> it's not really magic, it's just writing interface files separately from implementation files
04:00:36 <Athas> Neat, thanks.
04:02:09 <twb> GHC can have a cycle in module imports?
04:02:27 <twb> This is good news for me, since Darcs.Commands.Help has an ugly kludge to avoid that.
04:02:34 <iago_> twb, if you provide a hs-boot file yes
04:02:37 <iago_> automatically no
04:03:02 <Athas> Do I have to write anything special in my cabal file?
04:03:56 <twb> iago_: where can I learn how to do this?
04:04:09 <dcoutts> Athas: nope
04:04:11 <iago_> ghc documentation
04:04:15 <iago_> www.haskell.org/ghc
04:04:17 <twb> (I don't have time tonight, but I'll read up on it tomorrow.)
04:04:23 <iago_> it's easy
04:04:30 <Athas> This sounds excellent, I will try it out.
04:05:47 <twb> iago_: is it portable back to at least 6.8 (preferably 6.6)?
04:05:58 <eu-prleu-peupeu> i love you all
04:09:50 <iago_> twb, I think yes, I don't know any recently changes in the hs-boot mechanism in 6.x branch
04:09:56 <neoswish> how to simply write UTF string in stdout using utf8-string?
04:10:16 <twb> iago_: great, thanks
04:10:31 <iago_> np
04:11:28 <matthew-_> ivanm: no, not yet
04:11:28 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:11:38 <matthew-_> but it might come out this wkend
04:14:38 <blackh> neoswish: Codec.Binary.UTF8.String.encodeString
04:15:11 <blackh> neoswish: That is, putStr . encodeString
04:16:10 <blackh> neoswish: I really like using Data.Text (from the 'text' package) because it's fast and it encodes / decodes UTF-8 in a sensible way
04:31:29 <haskellnoob> I want to sort a huge list of elements, using a certain comparison operator. I guess List.sortBy is the function to use. I have two doubts: 1) How exactly is List.sortBy used? Could you point me to some examples? 2) If I want a very fast sort, and am not bothered about memory, is List.sortBy the best sort available (for code compiled using ghc)?
04:32:08 <EvilTerran> ?type sortBy
04:32:09 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:32:25 <EvilTerran> ?type compare
04:32:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
04:32:41 <ski> 9~
04:32:41 <BONUS> > sortBy (comparing fst) [(1,2),(2,1),(4,3),(5,3)]
04:32:43 <lambdabot>   [(1,2),(2,1),(4,3),(5,3)]
04:32:45 <ski> er
04:32:59 <EvilTerran> haskellnoob, the first parameter to sortBy should "act like" compare
04:33:11 <ski> @type comparingBy
04:33:12 <BONUS> so yeah sortBy takes a function that atkes two things and returns an Ordering
04:33:12 <lambdabot> Not in scope: `comparingBy'
04:33:14 <ski> @type compareBy
04:33:16 <lambdabot> Not in scope: `compareBy'
04:33:20 <haskellnoob> @type comparing
04:33:21 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:33:21 <ski> @type comparing
04:33:22 <BONUS> an ordering is either LT, EQ or GT
04:33:22 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:33:28 <EvilTerran> > sortBy (\(x,_) (y,_) -> y `compare` x) [(1,2),(2,1),(4,3),(5,3)]
04:33:29 <lambdabot>   [(5,3),(4,3),(2,1),(1,2)]
04:33:46 <BONUS> as for the fastest sort, well, try it out and see if it's fast enough, otherwise there's probably stuff with mutable arrays that's faster
04:33:55 <rpglover64> So I know this is a silly question, but I'm curious:  How would I write an iterator in haskell?  I was thinking something with the state monad, but I can't quite figure that out.  I'm trying to make a program output to a sequence of files whose names can be determined easily by a function.  Help anyone?
04:34:39 <haskellnoob> BONUS: where can I find out more about available sorting methods? short of grepping through ghc's documentation?
04:34:39 <ski> @let comparingBy :: (b -> a) -> (a -> a -> Ordering) -> (b -> b -> Ordering); comparingBy f cmp x0 x1 = cmp (f x0) (f x1)
04:34:41 <lambdabot>  Defined.
04:34:41 <DrSyzygyBE> mapM
04:35:16 <DrSyzygyBE> Define a new function that takes as input a filename, and wirte the stuff that needs to be written.
04:35:31 <DrSyzygyBE> Then map this monad action over the list of filenames...
04:35:39 <ski> @let oppositeOrdering :: Ordering -> Ordering; oppositeOrdering o = case o of LT -> GT; EQ -> EQ; GT -> LT
04:35:41 <lambdabot>  Defined.
04:36:19 <mauke> > [minBound .. maxBound] :: Ordering
04:36:20 <lambdabot>   Couldn't match expected type `Ordering' against inferred type `[a]'
04:36:23 <mauke> > [minBound .. maxBound] :: [Ordering]
04:36:25 <lambdabot>   [LT,EQ,GT]
04:36:52 <mauke> > map (compare EQ) [minBound .. maxBound]
04:36:53 <lambdabot>   [GT,EQ,LT]
04:36:58 <ski> @let oppositeComparision :: (a -> a -> Ordering) -> (a -> a -> Ordering); oppositeComparision cmp x0 x1 = oppositeOrdering (cmp x0 x1)
04:37:00 <lambdabot>  Defined.
04:37:19 <ski> > sortBy (comparingBy fst (oppositeComparision compare)) [(1,2),(2,1),(4,3),(5,3)]
04:37:21 <lambdabot>   [(5,3),(4,3),(2,1),(1,2)]
04:37:32 <mauke> oppositeOrdering = compare EQ; oppositeComparison = flip
04:37:41 <rpglover64> don't think that will work... the monad action writes to several files, and uses computations from before each write in the computation of the next write.
04:37:42 <wli> @type comparing
04:37:43 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:38:08 <rpglover64> Also, doing this would be a good test of my comprehension of the state monad (or a good crash course).
04:38:19 <BONUS> @type iterateM
04:38:20 <lambdabot> Not in scope: `iterateM'
04:38:21 <rpglover64> Which is what I'm more interested in.
04:38:26 <wli> > sortBy (flip $ comparing fst) [(1,2),(2,1),(4,3),(5,3)]
04:38:27 <lambdabot>   [(5,3),(4,3),(2,1),(1,2)]
04:38:33 <ski> mauke : yes .. if the given comparision is actually asymmetric
04:42:01 <Igloo> mmorrow: No camp-view for darcs, sorry. And it needs a better algorithm to be useful for large repos anyway. It's just a prototype currently.
04:42:11 <povman> @seen conal
04:42:11 <lambdabot> I saw conal leaving #haskell, #ghc and #haskell-in-depth 14h 11m 4s ago, and .
04:42:47 <povman> Does anyone understand how Reactive is intended to be used?
04:43:20 <povman> It seems to me that it runs in a separate thread and does things whenever it wants to
04:43:39 <quicksilver> beelsebob might do.
04:44:54 <povman> I'm emphatuated with the idea but I can't understand how it's meant to go in terms of IO.
04:46:59 <mmorrow> Igloo: cool. viewing repos graphically would be pretty cool. do you think graphviz would be a good viewer for the graphs you'd encounter from a darcs repo, and if so is there any easy way to dump some sort of (simple) graph rep?
04:47:36 <Igloo> mmorrow: I don't think graphviz is useful for viewing non-trivial graphs
04:47:58 <mmorrow> Igloo: non-trivial in what sense?
04:47:59 <Igloo> There is a perl script for making dot graphs of a darcs repo somewhere, I think
04:48:09 <Igloo> Large
04:48:41 <mmorrow> Igloo: yeah, unfortunately i agree (in most cases)
04:48:51 <Igloo> At least, not the dot output. If you place things manually then you could do better, but that's hard
04:51:05 <mmorrow> Igloo: i guess if the graphs are really too much to handle, you could always pull out subgraphs based on whatever so you're only rendering the the particular subgraph of interest
04:52:31 <Igloo> I think the right thing to do is to just get a better algorithm for camp-view
04:53:01 <Igloo> That also means you could make it interactive, e.g. click on a patch to view what it does
04:53:45 <mmorrow> ooh, yeah having an interactive ui for the graphs would definitely be nicer than graphviz
04:54:20 <mmorrow> Igloo: have you released any code for camp-view?
04:54:35 <dolio> @check \x -> (x + minBound :: Int) == (x `xor` minBound)
04:54:36 <lambdabot>   "OK, passed 500 tests."
04:55:25 <mauke> > abs minBound :: Int
04:55:26 <lambdabot>   -9223372036854775808
04:55:53 <mmorrow> Igloo: got it
04:56:22 <|Jedai|> mauke: ooops... There goes our invariant \x -> abs x >= 0
04:57:05 <mauke> > -1 `div` minBound
04:57:06 <lambdabot>   Add a type signature
04:57:09 <mauke> > -1 `div` minBound :: Int
04:57:10 <lambdabot>   1
05:03:37 <dolio> > complementBit 0 63 :: Int
05:03:38 <lambdabot>   -9223372036854775808
05:05:23 <dolio> Any bets on which of (`complementBit` 63), (`xor` minBound) and (+ minBound) are fastest?
05:18:24 <guenni> how can I create a "System.CalendarTime" by hand?
05:20:06 <quicksilver> guenni: deprecated.
05:20:08 <quicksilver> Use Data.Time.
05:20:30 <quicksilver> dolio: (+minBound) is likely to be at least equal fastest, surely?
05:20:37 <quicksilver> word addition is one cycle?
05:20:50 <dolio> Seems not.
05:20:50 <guenni> quicksilver: thx, I know it's deprecated, but I'm using haskelldb which uses CalendarTime
05:21:03 <dolio> complementBit is slowest, xor is fastest.
05:22:23 <dolio> xor isn't a whole lot faster than +, though.
05:25:50 <JuanDaugherty> the Haskell wiki doesn't have a lost password function. Am I jaded to not be surprised at this?
05:26:31 <JuanDaugherty> jaded/jaundiced/whatever
05:31:45 <maltem> JuanDaugherty, afaics it does have?
05:32:15 <maltem> (new accout creation -> mail me a new password)
05:34:07 <quicksilver> dolio: interesting. If you can be bothered, compare the machine code and find out why ;)
05:38:29 <da-x> is there a nice graph somewhere that shows the dependencies between the extensions to haskell 98?
05:38:49 <quicksilver> not that I've seen
05:40:54 <dolio> quicksilver: Re-testing now, I'm not seeing a difference. Must have been a fluke.
05:41:23 <blackh> dolio: I can recommend Microbench if you can ignore the fact that the time units are wrong on the output.
05:44:21 <dolio> If there were a difference, I wouldn't be able to explain it. The loops look identical, except for the add instruction vs. the xor instruction.
05:46:07 <quicksilver> add and xor are both 1 clock cycle, if they are reg,reg
05:48:32 <Invisible> anybody alive here?
05:48:39 * ivanm isn't
05:48:44 * Berengal is a zombie
05:48:58 <zbrown> no one here but us chickecs.
05:49:07 <ivanm> zbrown: "chickecs"?
05:49:09 <Invisible> oh, well, maybe the undead know more about this than me... ;)
05:49:14 <ivanm> wtf is a "chickec"?
05:49:19 <zbrown> ivanm: hrm chickens
05:49:26 <zbrown> typing one handed due to coffee :-|
05:49:27 <dolio> You know he's a chicken, because chickens are notoriously bad spellers.
05:49:29 * earthy hugs Haskell
05:49:39 <earthy> factoring a problem into nice parts makes the code run faster!
05:49:43 * zbrown gives Haskell an awkward man hug.
05:49:47 <Invisible> I have an IOUArray Int Double. What's the most efficient way to dump it into a file / load it back later?
05:49:59 <zbrown> earthy: thats true of most languages, not just haskell ;)
05:50:09 <zbrown> unless they're incredibly inefficient at code gen
05:50:12 <earthy> zbrown: it's not quite as pronounced in e.g. C
05:50:24 <zbrown> true, C does pretty decent optimization on its own
05:50:33 <zbrown> it doesn't need your help :-P
05:50:54 * zbrown goes back to hacking lisp and C
05:51:48 <Invisible> ...IOUArray...?
05:52:05 <ivanm> Invisible: so what is your actual question?
05:52:07 <Berengal> Invisible: No idea. Data.Binary maybe?
05:52:18 <ivanm> oh, wait, missed it
05:52:30 <ivanm> Invisible: how big is it?
05:52:50 <Invisible> ivanm: a few thousand elements, maybe a million or two.
05:53:02 <ivanm> OK, so show/read are out then :p
05:53:15 <zbrown> 1
05:53:17 <zbrown> doh
05:53:38 * Invisible counts them
05:53:52 <Invisible> 1228800
05:54:16 <ivanm> or you could do: succ . uncurry subtract . bounds ...
05:54:28 <ivanm> rather than actually counting them by hand ;-)
05:54:35 <Invisible> ...so there isn't any way I can just found out which area of RAM contains the array and how big it is, and just directly dump that chunk of RAM into a file?
05:54:46 <quicksilver> Invisible: hPutArray
05:54:52 <ivanm> Invisible: I doubt it
05:55:14 <Invisible> quicksilver: works ONLY with IOUArray Int Word8
05:55:17 <quicksilver> yup
05:55:19 <quicksilver> so cheat.
05:55:26 <quicksilver> @hoogle castIOUArray
05:55:27 <lambdabot> Data.Array.IO castIOUArray :: IOUArray ix a -> IO (IOUArray ix b)
05:55:35 <quicksilver> cast your array to word8s.
05:55:38 <Invisible> quicksilver: I tried castIOUArray, but it doesn't appare to work
05:55:44 <quicksilver> really?
05:55:52 <quicksilver> in what fashion?
05:55:56 <makubex1111> let's fight! http://chucknorrrris.mybrute.com
05:55:59 <Invisible> quicksilver: you must tell hPutArray how many bytes
05:56:06 <quicksilver> yes.
05:56:08 --- mode: ChanServ set +o quicksilver
05:56:11 --- mode: quicksilver set +b *!*n=makubex@77.90.75.*
05:56:11 --- kick: makubex1111 was kicked by quicksilver (quicksilver)
05:56:15 <Invisible> quicksilver: but it claims that array size * 8 is too large.
05:56:34 --- mode: quicksilver set -o quicksilver
05:56:38 <quicksilver> Invisible: hmm. That's odd.
05:56:59 <quicksilver> are you sure you didn't have an off-by-one error on the size, or something?
05:57:34 <Invisible> quicksilver: hmm, maybe...
05:58:05 <Invisible> RenderSystem1: {handle: Frame0001.dat}: hPutArray: invalid argument (illegal buffer size 9830400)
05:58:12 <Invisible> where did it get *that* size from?! o_O
05:58:29 <ivanm> magic! :p
05:58:58 <Invisible> ...wait, I misread the extra zero. yeah, that should be the correct size.
05:59:10 <Invisible> 640*2 * 480*2 * 8 = yeah
05:59:30 <Invisible> quicksilver: does it keep the array indicies and bounds the same?
05:59:51 <dolio> > 1228800*8 :: Int32
05:59:53 <lambdabot>   9830400
05:59:56 <quicksilver> dunno, look at the source.
06:00:01 * quicksilver follows his own advice.
06:00:10 <Invisible> quicksilver: oh, sure, like I can do that :P
06:00:46 <Invisible> quicksilver: I just notice that the index _type_ stays the same, so......
06:00:54 <quicksilver> castSTUArray (STUArray l u n marr#) = return (STUArray l u n marr#)
06:01:06 <quicksilver> Invisible: you can't follow a link labelled 'source' on the RHS of a web page?
06:01:12 <quicksilver> Invisible: I bet you can ;)
06:01:19 <Invisible> quicksilver: usually it doesn't work.
06:01:25 <Invisible> quicksilver: I guess I could try online...
06:01:26 <dolio> Yeah, that ain't right.
06:01:28 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/array/Data-Array-ST.html#v%3AcastSTUArray
06:01:38 <quicksilver> but yes, it appears to keep the bounds the same
06:01:40 <dolio> You can only usably cast to equally sized values that way.
06:01:44 <quicksilver> this appears to make this less useful.
06:02:03 <Invisible> quicksilver: so you can only cast to another type if sizeof(x) == sizeof(y)
06:02:16 <quicksilver> only usefully, yes ;)
06:02:18 <quicksilver> that sucks.
06:02:31 <dolio> Write your own castSTUArray! :)
06:02:32 <quicksilver> I've had better luck using Ptrs than arrays, for what you're trying to do.
06:02:48 <quicksilver> they seem to be a more flexible interface to chunks of RAM>
06:03:03 <Invisible> quicksilver: *sigh*... ok, where do I find that?
06:03:42 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Foreign-Ptr.html
06:03:47 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Foreign-Marshal-Alloc.html
06:04:13 <Invisible> quicksilver: right. So Foreign.Ptr and Foreign.Marshal.Alloc?
06:04:15 <quicksilver> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Foreign-Marshal-Array.html
06:04:21 <quicksilver> those are probably the most ionteresting.
06:04:27 <quicksilver> but glance around the nearby hierarchy
06:06:32 <Invisible> quicksilver: OK, I think I see how to allocate a chunk of RAM, put data into it, and get it out again, but... how do I write it to disk?
06:06:49 <quicksilver> hPutBuf
06:06:59 <quicksilver> @hoogle hPutBuf
06:07:00 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
06:07:00 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
06:07:22 <quicksilver> there are some decisions about how the deallocation happens.
06:07:36 <quicksilver> You can have block-scoped allocation, manual deallocation, or GC-based (finaliser based) deallocation.
06:07:52 <edwardk> @seen saizan
06:07:53 <lambdabot> I saw saizan leaving #haskell-in-depth, #ghc, #haskell-soc, #haskell-blah, #haskell-overflow, #haskell.it and #haskell 5h 29s ago, and .
06:08:21 <Invisible> quicksilver: ah, finally I found it. it's right at the bottom...
06:08:43 <Invisible> quicksilver: yeah, well, the array is allocated at the start of the program, and deallocated at the end, so that's fairly easy.
06:11:27 <Invisible> ok guys, I'm going to go off now and try to implement this craziness....
06:11:54 <kadaver> http://www.imagemagick.org/script/binary-releases.php#windows
06:12:05 <kadaver> dll or static, what is the difference?
06:12:29 * edwardk is trying to figure out if the finally tagless approach from cc shan and oleg can be applied to eliminate the GADT in a parser combinator library like uu-parsinglib
06:12:47 <edwardk> you'd lose applicative though
06:12:53 <quicksilver> Invisible: JaffaCake points out that you *can* actually use Data.Array.IO.Internals to expose the representation as STUArray, and then Data.Array.Base to expose the internals of STUArray and change the bounds yourself.
06:12:58 <quicksilver> Invisible: not ideal though.
06:13:12 <edwardk> but you'd get the ability to partially evaluate parsers, etc.
06:13:29 <Invisible> quicksilver: it looks like Data.Array.Storable will easily give me a Ptr to work on.
06:13:38 <edwardk> and perhaps the applicative part can be retained as a 'dynamic' portion
06:14:06 <quicksilver> that's also true
06:14:14 <Invisible> quicksilver: yet it otherwise presents the same interface as IOUArray
06:14:34 <Invisible> quicksilver: so that looks like the least code modification required.
06:14:43 <Invisible> (and the least chance of screwing it up somewhere...)
06:19:58 <Invisible> wooo! it works! :D
06:20:05 <Invisible> 40 MB of data dumped in a split second.
06:20:07 * Invisible dances
06:20:22 <Invisible> now, I wonder if it can be loaded back in... heh.
06:23:22 <Berengal> Man, there's so much of Haskell I've yet to learn
06:23:45 <Invisible> join the club
06:23:49 <Invisible> or the IRC channel...
06:24:43 <Berengal> It would be nice to have some sort of graph of the order topics should be learned in
06:25:07 <quicksilver> Invisible: glad it works :)
06:25:22 <Invisible> I tried to build that graph... it was cyclic! o_O
06:25:40 <Invisible> "recursive learning for a recursive language", as some guy quipped.
06:26:07 <Berengal> Cyclic just means it's a loop
06:26:08 <Invisible> quicksilver: well, it writes *something* to disk. how I gotta write the other half of the program to see if it's loadable ;)
06:26:33 <Berengal> You need to spin around a couple of times
06:26:41 <Invisible> indeed. in order to understand topic X, you need to know topic Y, but that requires topic Z, which requires you to know typic X first :D
06:27:36 <blackh> I have a cabal question... I have a 119 modules, with two executables - each using the same 119 modules but with a different main program. I defined these in my .cabal file. Is there a way to stop it building all 119 modules *three times* ?
06:27:46 <Berengal> The first steps in haskell are much like that... You need to know the syntax to be able to try it out for yourself, but to know the syntax you need to know what the basic elements of the langauge are at least, but to do that you pretty much need to be able to mess around with it, which requires knowing the syntax...
06:28:03 <dcoutts> blackh: you can reduce it to just 2 times if you don't need the library too
06:28:07 <Twey> Haskell doesn't have a lot of syntax
06:28:22 <Berengal> Twey: It has enough when you don't know it at all
06:28:32 <Twey> Berengal: Well, it's easy to start of with simple stuff
06:28:34 <Berengal> Twey: It's not like lisp, where I was hacking away in the interpreter after five minutes...
06:28:43 <Invisible> Twey: it has enough that even now, 5 years later, I'm still learning new stuff
06:28:43 <Twey> main = print 5
06:28:43 <blackh> dcoutts: How would I do that?
06:28:45 <Berengal> Haskell took the better part of a day
06:28:48 <Twey> main = print (3 + 5)
06:28:52 <dcoutts> blackh: otherwise there are two solutions, one is to make the exe into separate .cabal files which depend on the lib, or to help implement the cabal ticket that would allow the exe to depend on the lib within the same package.
06:28:53 <Invisible> BTW... n+1 patterns. WTH?
06:28:57 <Twey> main = print $ 3 + 5
06:28:59 <Twey> &c.
06:29:05 <EvilTerran> Invisible, yeah.
06:29:15 <dcoutts> blackh: presumably you've got a library section and two executable sections, right?
06:29:23 <blackh> dcoutts: I can see why it's doing it. I am interested in helping implement the cabal ticket.
06:29:43 <dcoutts> blackh: each specifies the modules separately, so get built separately (in general they can use different flags etc)
06:30:02 <Twey> off**
06:30:41 <dcoutts> blackh: http://hackage.haskell.org/trac/hackage/ticket/89
06:30:46 <blackh> dcoutts: Yes, that's right. It'd be great if it acted exactly as if it were another library.  I tried adding the library as a dependency, but (of course) it said it was a cyclic dependency.
06:31:08 <Invisible> quicksilver: yay! I loaded the data back in, and it's not gibberish! :D
06:31:22 <ivanm> Invisible: yes, but is it the data you expect? :p
06:31:30 <dcoutts> blackh: so the idea is we extend things to allow components with a single package to depend on each other, via build-depends and build-tools
06:31:39 <ivanm> it's no good writing the bible, and reading back in a porn novel! :p
06:31:49 <dcoutts> blackh: in particular build-depends to let the exe specify a dep on the lib
06:32:01 <EvilTerran> ivanm, that sounds like an excellent result, imo :P
06:32:11 <ivanm> heh, each to their own
06:32:15 <blackh> dcoutts: I will read all the text on that ticket.. Now that almost answers the question I was about to ask:
06:32:17 <Invisible> ivanm: looks like it, yeah.
06:32:26 <ivanm> EvilTerran: but would you appreciate it working the other way round? ;-)
06:32:45 <EvilTerran> point.
06:32:45 <dcoutts> blackh: so what we need to do in that case is analyse the graph of intra-package deps (check they're not cyclic) and then build them in that order (currently we build all libs then all exes).
06:32:48 <JoelMcCracken> is there a haskell function like flatmap from sicp?
06:32:55 <ivanm> JoelMcCracken: what does it do?
06:32:58 <EvilTerran> JoelMcCracken, what does flatmap do?
06:32:59 <Invisible> Haskelll... porn... you'd think they'd be quite unrelated, eh? :|
06:33:00 <ivanm> it _sounds_ like concatMap
06:33:01 <blackh> dcoutts: If we made it so that saying "build-depends: <package name>", then that would act as if the library had already been installed... Would that be a sensible way to do it?
06:33:03 <ivanm> @type concatMap
06:33:04 <Berengal> @type concat
06:33:05 <dcoutts> blackh: and we also need to register the lib into a ./dist/package.conf.inplace
06:33:06 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:33:07 <lambdabot> forall a. [[a]] -> [a]
06:33:46 <blackh> dcoutts: I have been making cabal cross compile for a company, so I am familiar with some of cabal already.
06:33:57 <kadaver> dll or static, what is the difference?
06:33:58 <dcoutts> blackh: well in a sense the library is named, it's shares the name of the package. If we allow private convenience libs then they'd have to be named.
06:34:01 <JoelMcCracken> yep looks like concatmap was right =) thanks
06:34:06 <dcoutts> blackh: oh, nice
06:34:13 <kadaver> so should I make an FFI for imagemagick and put it on hackage?
06:34:21 <dcoutts> blackh: I'd be interested to know more, if you're ok to talk about it
06:34:29 <kadaver> > concatMap (+) [1..10]
06:34:31 <lambdabot>   Couldn't match expected type `[b]' against inferred type `a -> a'
06:34:39 <kadaver> > concatMap (+) [[1],[2]]
06:34:40 <lambdabot>   Couldn't match expected type `[b]' against inferred type `a -> a'
06:34:43 <blackh> dcoutts: Sure - I can say some more:
06:34:44 <quicksilver> Invisible: was it gibberish to start with?
06:34:50 <kadaver> > concatMap (++) [[1],[2]]
06:34:51 <lambdabot>   Couldn't match expected type `[b]'
06:34:52 <quicksilver> Invisible: if so, that's pretty slever.
06:34:55 <kadaver> @src concatMap
06:34:55 <lambdabot> concatMap f = foldr ((++) . f) []
06:35:01 <kadaver> @type concatMap
06:35:03 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
06:35:09 <Invisible> quicksilver: meh, well... numerical integration ;)
06:35:12 <quicksilver> ;)
06:35:22 <Berengal> > concatMap (flip replicate ()) [1..5]
06:35:24 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),()]
06:35:26 <kadaver> > concatMap (\x ->[x+1]) [[1],[2]]
06:35:27 <Invisible> two programs - one does the integration, the other turns it into a pretty picture
06:35:27 <lambdabot>       No instance for (Num [t])
06:35:28 <lambdabot>        arising from the literal `1' at <inter...
06:35:38 <Invisible> means I can change the graphics colouring algorithm without reintegrating
06:35:50 <Invisible> also resume the integration without starting from the beginning, etc.
06:36:03 <kadaver> > concatMap (\x ->[x+1]) [[1],[2]]
06:36:04 <lambdabot>       No instance for (Num [t])
06:36:04 <lambdabot>        arising from the literal `1' at <inter...
06:36:23 <kadaver> how to use concatMap?
06:36:41 <ivanm> if happy is required, does hackage list it?
06:36:42 <Saizan> > concatMap (\x ->[x+1]) [1,2]
06:36:43 <lambdabot>   [2,3]
06:36:43 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
06:37:19 <Berengal> > concatMap (\x -> [x+1, x+2]) [1,3]
06:37:21 <lambdabot>   [2,3,4,5]
06:37:32 <kadaver> same asmap
06:37:44 <Berengal> same as (concat.) . map
06:38:01 <Twey> concat .: map
06:38:51 <ziman> @pl \x y -> f $ g x y
06:38:52 <lambdabot> (f .) . g
06:38:56 <ziman> @pl \x y -> f x $ g y
06:38:56 <lambdabot> (. g) . f
06:39:31 <Berengal> Twey: fmap . fmap operator?
06:39:37 <kadaver> it would make sese if it was
06:39:58 <kadaver> concatMap (+1) [[1,2,3]]-> [2,3,4]
06:40:00 <Twey> Berengal: In a manner of speaking
06:40:25 <Berengal> Twey: Do explain
06:40:45 <Twey> It's (usually) defined as (.:) = (.) . (.)
06:40:54 <Berengal> Ah
06:41:05 <Twey> (.) isn't defined as fmap by default, but it can be (I believe it is in lambdabot)
06:41:08 <ziman> @pl \f g -> (f .) . g
06:41:08 <lambdabot> (.) . (.)
06:41:12 <edwardk> twey: i always liked fmap fmap fmap =)
06:41:16 <ziman> @pl \f g -> (. g) . f
06:41:16 <lambdabot> flip ((.) . flip (.))
06:41:21 <Twey> edwardk: *chuckles*
06:41:25 <edwardk> @type fmap fmap fmap
06:41:27 <haskellnoob> What does Data.ByteString.Char8.getLine return and/or do when there is nothing left in the input? The ghc library documentation doesn't say anything about this.
06:41:27 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
06:41:29 <Berengal> I usually work using (.) = fmap
06:41:34 <Athas> Can a typeclass define default implementations of methods defined by its superclasses?
06:41:35 <kadaver> is it impossible because of the typesystem to wirte a function : makeDeep n xs = makeDeep (n-1) [xs];mkaeDeep 0 xs = xs
06:41:36 <kadaver> ?
06:41:47 <edwardk> Berengal: i use Control.Category too much, i can't
06:42:04 <edwardk> and the Category interpretation of (.) is more interesting to me
06:42:13 <Berengal> edwardk: Yeah, you told me about the conflicts with Category.. earlier some day
06:42:16 <Twey> Athas: Typeclasses don't have superclasses
06:42:24 <edwardk> ah wasn't sure if it was you
06:42:34 <Twey> (unless you're talking about some sort of extension I don't know)
06:42:44 <Athas> Well, the classes they extend, in that case.
06:42:49 <edwardk> athas: unfortunately no
06:42:50 <Twey> They don't
06:42:51 <quicksilver> haskellnoob: throw an EOFException, I suspect.
06:42:56 <byorgey> kadaver: it's impossible with lists.  But you can come up with a type that makes it possible.
06:43:01 <Athas> Not sure about the terminology, but I vaguely recall GHC yelling at me about superclasses in an error message.
06:43:05 <Athas> And damn.
06:43:06 <edwardk> tewy: class Foo a => Bar a -- consider Foo to be a superclass of Bar
06:43:17 <quicksilver> haskellnoob: this is documented for the 'main' hGetLine
06:43:20 <quicksilver> in System.IO
06:43:25 <haskellnoob> quicksilver: ok. thanks.
06:43:26 <Twey> edwardk: I'm not sure I'd count that
06:43:39 <quicksilver> Twey: well that's what the standard calls it ;)
06:43:40 <edwardk> twey: its common terminology, and its used throughout ghc. =)
06:44:03 <quicksilver> arguably it's a por choice of name, serving to lure OOP people into thinking it's like OOP.
06:44:07 <Twey> Hmn, OK
06:44:08 <byorgey> kadaver: see http://byorgey.wordpress.com/2007/10/01/higher-dimensional-enumeration/
06:44:09 <edwardk> anyways, pedanticness aside, athas, unfortunately you can't define default implementations for your superclasses.
06:44:09 <quicksilver> but nonetheless it is the name.
06:44:17 <Twey> pedantry**
06:44:20 <Twey> :-P
06:44:23 <edwardk> athas: this is sort of the pedantry tax imposed by haskell
06:45:13 <edwardk> athas: if you get overly specific in your classes you make every library implementor who implements them implement the whole tower above them. its one of the 'justifications' of why Monad isn't a subclass of Functor
06:45:33 <edwardk> they didn't want to make everyone say 'instance Functor MyMonad where fmap = liftM
06:45:44 <Twey> Ych
06:45:56 <Twey> Are we ever going to be able to?
06:46:01 <edwardk> athas: the best you can do is define nice defaults like Data.Traversable.fmapDefault
06:46:03 <Twey> I can see why that would be a good thing.
06:46:12 <edwardk> athas: and encourage their use whenever they are implied
06:47:04 <earthy> *hm*. 'memory allocation failed' from a program running in GHC
06:47:15 <edwardk> athas: the justification is that if you implemented two classes that 'subclassed' a superclass which default gets picked? if you have a class Foo a, Foo b => Bar a b where ... and you defaulted a method from Foo, which Foo are you defining?
06:47:15 <earthy> s/in GHC/compiled by GHC/
06:47:52 <earthy> I wouldn't think it'd fill the 4G mem in this laptop, going from the 87M input file.
06:48:01 <edwardk> athas: so subclasses defining superclass methods is somewhat poorly framed in the absence of named instances and a defaulting/override mechanism, etc. so it just requires enough machinery, that like polymorphic records it never seems to get done
06:48:03 <earthy> methinks I'm building up too many thunks
06:48:21 <edwardk> earthy: $! and rnf are your friends ;)
06:48:27 <earthy> yah
06:48:28 <Twey> rnf?
06:48:32 <Twey> :t rnf
06:48:33 <lambdabot> forall a. (NFData a) => a -> Done
06:48:34 <earthy> Twey: root normal form
06:48:40 <Twey> .ue
06:48:47 <Twey> What is this?
06:48:47 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html
06:48:50 <Twey> I have never seen it before.
06:48:55 <Twey> Oho
06:49:08 <Twey> Haha, type Done = ()
06:49:12 <edwardk> foo `using` rnf -- reduces foo to normal form throughout. its basically a deepSeq
06:49:45 <edwardk> > [1,2,3] `using` rnf
06:49:47 <lambdabot>   [1,2,3]
06:49:49 <earthy> it's jus that I don't quite see *where* I'm building up the thunks and not evaluating
06:49:56 <edwardk> > [1,2,undefined] `using` rnf
06:49:58 <lambdabot>   * Exception: Prelude.undefined
06:50:18 * quicksilver though the r was for recursive.
06:50:21 <quicksilver> or reduce.
06:50:33 <edwardk> > [1..] `using` rnf
06:50:49 <earthy> hm. could also be
06:50:55 <lambdabot>   thread killed
06:51:02 <edwardk> 'reduce to normal form'
06:51:14 <edwardk> er (head) normal anyways
06:52:16 <byorgey> > let x = [1,2,undefined] `using` rnf in length x
06:52:19 <lambdabot>   * Exception: Prelude.undefined
06:52:51 <edwardk> rnf is nice if you want to clear out environments to keep them from holding onto huge things for small answers
06:53:17 <earthy> unfortunately I'm building a huge answer as well...
06:53:52 <edwardk> well, rnf the pieces as you inject them when it makes sense, and consider replacing strings with bytestrings, etc.
06:56:53 <birkenfeld> is there a prettier way of spelling (concatMap . concatMap) ?
06:58:11 <EvilTerran> ?type concatMap . concatMap
06:58:14 <lambdabot> forall a b. (a -> [b]) -> [[a]] -> [b]
06:58:23 <edwardk> (=<<) . (=<<) -- is decorative at least =)
06:59:02 <edwardk> @type join . (=<<)
06:59:03 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
06:59:03 <lambdabot>     Probable cause: `=<<' is applied to too many arguments
06:59:03 <lambdabot>     In the second argument of `(.)', namely `(=<<)'
06:59:14 <Deewiant> @ty (join .) . (=<<)
06:59:16 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m (m a)) -> m a1 -> m a
06:59:22 <edwardk> @type fmap join . (=<<)
06:59:23 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m (m a)) -> m a1 -> m a
07:02:45 <mdmkolbe> Which Haskell implementations (i.e. Hugs, YHC, etc.) support (1) existential types and/or (2) rank-2 types?
07:03:05 <mdmkolbe> Would it be fair to call those extensions "commonly supported"?
07:03:45 <edwardk> mdmkolbe: UHC and GHC spring to mind
07:03:56 <edwardk> i don't know most of the others well enough to comment
07:10:40 <eden_> Hi, I'm trying to use Parsec to parse a sequence of (SourcePos, Char) pairs. Does anyone have any pointers to tutorials or the like on how to do this?
07:15:40 <byorgey> eden_: have you looked at the Parsec documentation?
07:17:20 <eden_> byorgey: Yes. It only seems to deal with Char parsers.
07:17:47 <byorgey> ok, I couldn't remember if it included more general information.
07:20:38 <eden_> In fact, it's not really much more than an out of date version of the the function list.
07:22:01 <quicksilver> it's only out of date if you're looking at the wrong version :P
07:22:21 <eden_> so where is the version I should be looking at then?
07:22:28 <quicksilver> as for being Char only
07:22:36 <quicksilver> well the versions in .Char are char only it's true
07:22:49 <quicksilver> but ost of the other modules have fully polymorphic things
07:23:18 <quicksilver> which one should you be looking at? well that depends which version of parsec you're using.
07:24:04 <eden_> The latest on hackage, 3.0.0.
07:24:54 <edwardk> eden: where did the SourcePos values come from, a hand tokenizer?
07:25:31 <quicksilver> eden_: then either the docs it installed on your system, or the docs on haddock.
07:25:48 <quicksilver> e.g. http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Combinator.html
07:26:53 <eden_> They've come from a preprocessor I've already written in parsec, so not quite, but close enough.
07:28:33 <edwardk> eden: ok, then what i would say is that you want those to be seen as the 'source position' for any errors in your new parsec, so the parser is tricky =)
07:28:55 <edwardk> also having those on every char is probably pretty expensive
07:29:17 <eden_> quicksilver: Those docs are fine as a reference when you already know how to do things, but not when you're learning
07:29:51 <quicksilver> eden_: they're not really docs, no. But their types tell a store.
07:30:12 <quicksilver> I mean basically parsing (Char,Foo) pairs is no different from parsing Chars.
07:30:48 <Saizan> eden_: in Stream s m t, 't' is the type of tokens, so you can use Char or (Char,Foo) or whaterver for it
07:30:56 <eden_> edwardk: It is expensive, It's a first cut, and will will probably turn into (SourcePos, [Char]) pairs once I've got to grips with more complicated things.
07:31:44 <edwardk> eden: at that point what i'd do is use the setSourcePos combinator or whatever it is to inject your source position and parse the char stream from there. checking
07:31:54 <eden_> ... or maybe even (SourcePos, ByteString)...
07:32:45 <edwardk> setPosition
07:33:38 <edwardk> so it appears you'd need a custom Stream type, and then to make custom combinators using tokens that extract and use your SourcePos info
07:35:22 <edwardk> your Stream can uncons to tokens of type (SourcePos, Char) -- and then your combinators using tokens can extract the source position from the token to update parsec's state
07:36:08 <edwardk> if your preprocessor is just emitting the equivalent of #line directives, it may be better to leave those 'in band' and extend your parser with rules for them
07:36:49 <JoelMcCracken> take 1 $ foldl1 intersect $ map (\x -> [x,x+x..]) [1..20]    will this run forever? am I doing anything wrong?
07:37:22 <JoelMcCracken> actually nvm, at least one thing is wrong
07:37:22 <edwardk> > map (\x -> [x,x+x..]) [1..20]
07:37:23 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
07:37:56 <JoelMcCracken> erm I take that back, it should be fine keeping the 1 in the [1..20]
07:39:22 <edwardk> i think you need knowledge of the monotonicity of your lists to get that to ever return
07:39:27 <Saizan> > intersect [1..] [1..]
07:39:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:39:41 <edwardk> @type intersect
07:39:42 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
07:39:49 <edwardk> @src intersect
07:39:49 <lambdabot> intersect = intersectBy (==)
07:39:53 <JoelMcCracken> dunno what you mean
07:39:58 <JoelMcCracken> by monotonicity =(
07:40:10 <Gilly> > map (\x -> [x,x+x..]) [1..5] !! 2
07:40:11 <lambdabot>   [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
07:40:21 <Gilly> go laziness :=)
07:40:25 <galdor> hi; I'm trying to setup QuickCheck on a small project, but I can see how to setup a simple test suite
07:40:35 <galdor> I'd like each module to export a list of properties
07:40:35 <Saizan> > intersect [1..] [2,4 ..]
07:40:36 <p_l> monotonicity... high school math?
07:40:40 <p_l> ;-)
07:40:46 <eden_> Okay. What it's acually doing is converting \uXXXX sequences into the actual character, like the Java source preprocessor. I'm trying to make the error reports refer to the orginal source file.
07:40:46 <galdor> and one module run the aggregation of all these lists
07:40:51 <lambdabot>   thread killed
07:41:24 <galdor> but since properties haven't a common signature, I can't see how to do it (haskell novice inside)
07:41:46 <JoelMcCracken> huh
07:41:46 <Saizan> JoelMcCracken: inteserct (1:_) xs will look into xs until the end of it to find an '1' to decide if 1 is in both lists or not, but xs is infinite, so it can never come to a conclusion
07:41:48 <JoelMcCracken> interesting
07:41:53 <galdor> I peeked at XMonad but it's really complicated
07:41:54 * p_l lost half a year trying to pass the exam on functions and their properties...
07:42:06 <edwardk> p_l: monotonicity is a useful property well beyond highschool. =)
07:42:22 <JoelMcCracken> ah
07:42:24 <JoelMcCracken> I see
07:42:29 <p_l> edwardk: yeah. After taking the same exam >4 times, I remember it :D
07:42:33 <JoelMcCracken> right, that makes sense
07:42:47 <edwardk> you use it all the time in haskell. you just don't think about it. all of your functions are 'monotone' with respect to the partial order of definedness in haskell.
07:43:51 <edwardk> JoelMcCracken: hence why you need something that tells it that if its seen a value greater than what it is looking for, that what it is looking for isn't in the list. hence the monotonicity condition
07:44:38 <earthy> hm. why doesn't fgl like graphs with a couple of hundred nodes?
07:44:47 <earthy> s/hundred/million/
07:45:47 <earthy> oh well. I'll look into that after the weekend :)
07:45:51 <byorgey> earthy: how much memory do you have?
07:46:00 <earthy> byorgey: 4G
07:46:03 <earthy> in this machien
07:46:10 <earthy> I can run it on a machine with 128G
07:46:27 <earthy> I would like not having to though
07:46:33 <byorgey> I don't know what the constant overhead is for fgl graphs, but seems like 4G should be enough...
07:46:46 <earthy> yes, it would. :)
07:47:33 <earthy> I mean, the graph is described in path-prefix notation in an 87M input file...
07:47:56 <marcot> Good morning.
07:48:14 <earthy> I can understand blowing that up by a factor of 10
07:48:15 <burp_> is there any detailed documentation for parsec?
07:48:19 <earthy> but not by a factor of 100
07:48:24 <burp_> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Char.html <- this is just crap, not a single comment
07:48:52 <burp_> well, there is not much to understand but there: http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec-Combinator.html
07:49:07 <earthy> hm. interesting. it can *deal* with graphs this big, but does not seem to like it.
07:49:24 <earthy> okay, time to head for my train and see if I can build the graph differently.
07:49:55 <marcot> Is there a way to define more than one option for commentStart in Text.Parsec.Token.GenLanguageDef?
07:51:38 <JoelMcCracken> edwardk, are you sure about it taking each item in the first list then searching the second list?
07:53:51 <Saizan> ?src intersectBy
07:53:51 <lambdabot> intersectBy eq xs ys = [x | x <- xs, any (eq x) ys]
07:55:45 <JoelMcCracken> ah
07:55:53 <JoelMcCracken> any is probably my problem
07:56:49 <Saizan> yeah, you want a condition that takes the monotonicity into consideration
08:03:28 <JoelMcCracken> well, made one
08:03:34 <JoelMcCracken> cool
08:05:06 <solistic> anyone arround who knows how to find out what libraries the boot-package of ghc includes, http://hackage.haskell.org/trac/ghc/wiki/Commentary/CodingStyle seems to be outdated
08:05:36 <solistic> and I somehow can't figure it out with find and grep
08:07:05 <Saizan> solistic: they are under libraries
08:08:42 <edwardk> JoelMcCracken: note you can basically implement the monotone intersection as a merge operation just by looking at the least elements of each list in turn
08:09:11 <JoelMcCracken> i modified some earlier code I had used
08:09:25 <JoelMcCracken> from http://en.literateprograms.org/Sieve_of_Eratosthenes_(Haskell)
08:10:23 <JoelMcCracken> just becomes this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4449#a4449
08:10:46 <edwardk> yep
08:10:54 <edwardk> btw, no need for the paranoid parens in EQ
08:11:22 <edwardk> juxtaposition binds tighter than anything but @
08:12:00 <JoelMcCracken> ah, k
08:12:17 <edwardk> heh, if you want to be pedantic you can drop then around the Ord a too  ;)
08:13:54 <JoelMcCracken> ahh I'll keep them in
08:14:04 <solistic> Saizan, everything in there, ok, thx
08:14:06 <JoelMcCracken> for now... I'll learn my random precedence rules as time passes
08:14:20 <JoelMcCracken> gah, this solution is taking a long time to execute
08:14:23 <ski> (edwardk : and `~', and `!')
08:15:08 <edwardk> JoelMcCracken: you might want the lintersect _ _ = [] -- case in case you ever use this on finite lists as well
08:15:46 <edwardk> heya saizan; did you check out the uuparsing stuff yet?
08:15:51 <JoelMcCracken> oh yeah, forgot, I have that, just didn't paste it
08:19:44 <Saizan> edwardk: not yet, i'm awaiting to be fuller awake for that ;)
08:20:13 <edwardk> saizan: heh, it cleaned up reasonably well. there was nothing to the Control.Applicative doesn't fit claim in the end
08:22:36 <Saizan> edwardk: nice, i actually need to write a non-det parser that lazily returns a stream of (Result,CorrespondingInput), i wonder if it'll fit
08:23:42 <edwardk> saizan: it seems particularly well suited to grammars that only admit a couple of alternative parses at a time, since it applies them all in a breadth first fashion
08:23:56 <edwardk> saizan: so if its heavily ambiguous you may have some expensive parsing
08:24:55 <Saizan> edwardk: i see, like in ReadP
08:24:59 <edwardk> what i'm looking into now is replacing the GADT machinery with a tagless interpreter
08:25:23 <edwardk> saizan: yeah but with sort of a 'progress guarantee' from the applicative nature of the future parsers, etc.
08:28:42 <Saizan> edwardk: hah, it's funny how we go to the term representation to optimize the combinators and then use a tagless interpreter to strip them away again :D
08:28:55 <edwardk> heh
08:29:30 <quicksilver> well I don't think it's funny. I think it's damn clever.
08:29:45 <edwardk> my biggest problem is the rep used by the library has a ton of invariants that aren't expressed in the types
08:30:29 <Saizan> quicksilver: yeah, that sort of evil cleverness is amusing to me :)
08:30:54 <edwardk> in general this is a better fit for my monoidal parsing framework than parsec because it can dispose of the start of the input easier
08:31:22 <edwardk> and it has clearly defined applicative fragments
08:31:57 <edwardk> the tagless stuff would just make clearly defined constant foldable fragments and permit things like compiling the static parts of the parser
08:32:09 <edwardk> basically right now its just a tagged interpreter
08:32:22 <edwardk> what does one do with interpreters but replace them with compilers?
08:32:57 <quicksilver> make tense hollywood action thrillers about them?
08:33:03 <Saizan> serialize code :)
08:34:20 <Taejo> is there a tutorial or some kind of birds-eye view documentation for Atom somewhere? it looks really cool, but I'm struggling to figure it
08:34:30 <Taejo> *figure it out
08:56:58 <Philonous> What happens when I use readChan on an empty Chan from Control.Concurrent.Chan? Does it block until an element is put into the chan? Does it raise an exception?
08:57:04 <quicksilver> it blocks.
08:57:05 <Gracenotes> block
08:57:10 <Gracenotes> :(
08:57:12 <Philonous> Thanks
08:57:21 * quicksilver wins race condition.
08:57:27 <Gracenotes> my crypto presentation was cut short, didn't have enough time to finish. got 3/4 through
08:57:32 <Philonous> I think it should be mentioned in the documentation
08:57:36 <Gracenotes> which I suppose is still good
08:57:56 <Gracenotes> but, aww :( disappointment. And after the 600 lines of beamer latex
08:58:07 <earthy> see, I *knew* this should fit on this machen
08:58:11 <quicksilver> Philonous: well, it would be mentioned if it threw an exception.
08:58:17 <quicksilver> Philonous: exceptions are, well, the exception ;)
08:58:18 <earthy> now it reads things in machine
08:58:29 <earthy> 1776030 nodes, read in 100s.
08:59:31 <Philonous> They arguably should be. Some people use them as expections, though. And you never know what ideas smart people come up with.
09:00:51 <Philonous> (The docu even mentions exceptions as a nifty way of inter-process communication...)
09:01:29 <Twey> Philonous: The way it's used is such that blocking is the obvious behaviour
09:01:48 <Twey> That's maybe not so useful for beginners, but I do see why they'd omit to mention it
09:03:12 <Saizan> it could be more explicit
09:04:25 <quicksilver> it certainly could.
09:04:29 <Saizan> the problem is that such documentation doesn't get much debugging wrt other people that are not the author
09:05:29 <Saizan> (and exceptions should probably be in the type anyway)
09:06:40 <Twey> Well, you can put them in the type by simply using the return value instead of using IO magic
09:07:05 <quicksilver> the exceptions are in the type ;)
09:07:07 <Twey> readChan :: Chan a -> IO (ChanReadResult, Maybe a)
09:07:09 <quicksilver> that's what IO says.
09:07:14 <quicksilver> it's just not very explicit.
09:07:29 <Saizan> i think you know what i meant :)
09:07:30 <Twey> quicksilver: Yeah, but it covers a huge range of exceptions and doesn't make it clear which apply.
09:07:51 <quicksilver> unfortunately we don't distinguish the types of excpetions
09:08:02 <quicksilver> and asyncrhonous ones can occur anywhere, that being their nautre.
09:08:34 <Saizan> well, since base-4 we do
09:08:42 <Twey> We do?
09:08:43 <Twey> How?
09:08:57 <Saizan> they are structured as a hierarchy of types now
09:09:04 <Saizan> rather than a big sum type
09:09:08 <Twey> Where can I read about this?
09:09:35 <quicksilver> Saizan: I meant, in particular, we don't distinguish between asynchronous + synchronous in any deep way.
09:09:52 <Saizan> you can look at the Control.Exception module or read the extensible exceptions paper
09:09:57 <quicksilver> Saizan: you can throwTo any exception to any thread, and thus make anything asynchronous
09:10:01 <quicksilver> (can't you?)
09:10:14 <Saizan> quicksilver: you can
09:10:24 <quicksilver> yeah, that's the point I was making. clumsily.
09:10:42 <quicksilver> Supose you have a system for declaring exceptions in the type.
09:10:52 <quicksilver> You obviously can't use that for the async sort since they can happen literally anywhere.
09:11:04 <quicksilver> But, our system doesn't have a deep division betwee teh async sort and the other sort.
09:11:21 <Saizan> well, you could just have the async ones everywhere :)
09:11:39 <Saizan> but i agree that a more structured way is probably nicer
09:12:05 <quicksilver> btu they're all potentially async
09:12:17 <quicksilver> since they can all be thrown by throwTo.
09:12:39 <Saizan> uhm, that's true
09:12:59 <Saizan> so we do need a separation
09:13:09 <quicksilver> Good :)
09:13:13 <quicksilver> that's the only point I was making.
09:13:17 <quicksilver> Sorry it took me 15 lines to make it.
09:13:38 <Saizan> sorry if it took 15 lines to understand it :)
09:15:36 <Saizan> though having separate types for each particular exception, e.g. ErrorCall vs. IOException is a already a big step towards that
09:19:53 <quicksilver> yup.
09:20:05 <quicksilver> I use IO exceptions so rarely it doesn't really bother me.
09:20:17 <quicksilver> I use them (a) occasionally for asynchronous thread communication
09:20:29 <quicksilver> (b) occasionally when using System.IO
09:22:34 <centrinia> > snd $ hanoi 3 0 2 1
09:22:35 <lambdabot>       No instance for (MonadWriter [[Char]] ((,) a))
09:22:35 <lambdabot>        arising from a us...
09:23:07 <centrinia> > snd . runWriter $ hanoi 3 0 2 1
09:23:09 <lambdabot>   ["Move the plate from peg 0 to peg 2","Move the plate from peg 0 to peg 1",...
09:29:58 <quicksilver> cute use of writer.
10:00:04 <Renderwahn> besides emacs or vi, are there any editors you could recommend for haskell?
10:00:12 <roconnor> yi ?
10:00:16 * roconnor has never used it
10:00:34 <dolio> Liskeh seems to be gradually accumulating users.
10:00:55 <marcot> roconnor: is it mature enough to replace emacs or vi?
10:01:06 <Renderwahn> I'll give yi and liskeh a try
10:01:07 <roconnor> I have never used it
10:01:36 <marcot> dolio: You mean Leksah?
10:01:49 <dolio> That's the one.
10:01:59 <dolio> Apparently my brain was mixing it with liskell.
10:02:44 <marcot> dolio: I thought about that..
10:03:09 <ehamberg> how is leksah's editor? does it use yi?
10:03:29 <dons> leksah?
10:03:47 <dons> i'd seriously look at leksah, if you're into IDEs
10:04:20 <marcot> Is Leksah good as a general editor, or is it just for editing Haskell code?
10:04:40 <int10h_> Hi all, sorry to bother you all on here, but I
10:04:49 <int10h_> am working through YAHT, and have a problem.
10:04:49 <dons> it's a haskell IDE
10:05:19 <Renderwahn> great, that is exactly what I was looking for
10:05:54 <int10h_> It's probably a very simple mistake, I was wondering if someone could look at it and tell me where I'm going wrong as it's doing my nut in.
10:05:55 <ski> int10h_ : no need to be sorry
10:06:18 <ski> just tell or show what your problem is
10:07:20 <int10h_> Okay, I'm taking input from the console, if it's 0, I quit, if it's a number higher than that, it's added to a list. Recursive function.
10:07:28 <Renderwahn> oh boy, haskell school of expression is so much fun
10:07:35 <int10h_> So
10:08:33 <int10h_> one sec, just copying from another machine
10:09:03 <dons> ?users
10:09:04 <lambdabot> Maximum users seen in #haskell: 658, currently: 635 (96.5%), active: 9 (1.4%)
10:09:06 <dons> ?uptime
10:09:07 <lambdabot> uptime: 1d 11h 14m 10s, longest uptime: 1m 10d 23h 44m 29s
10:09:47 <int10h_> askfornum = do
10:09:47 <int10h_> 	putStrLn "Enter a number (or 0 to stop): "
10:09:47 <int10h_> 	inputstring <- getLine
10:09:47 <int10h_> 	let inputnum = read inputstring
10:09:47 <int10h_> 	if inputnum == 0
10:09:48 <int10h_> 		then return []
10:09:50 <int10h_> 		else do
10:09:52 <int10h_> 			rest <- askfornum		
10:09:54 <int10h_> 			let numlist = (inputnum : rest)
10:09:54 <dons> yikes.
10:09:56 <int10h_> 			return numlist
10:09:58 <dons> use hpaste.org
10:10:43 <int10h_> Sorry - so - I can't seem to use foldr on the returned value, it says it's IO.
10:12:08 <ski> you need to show how you call `askfornum'
10:12:28 <int10h_> Okay: foldr (+) 0 askfornum
10:12:39 <ski> that won't do
10:12:43 <ski> try something like
10:12:46 <Philonous> askfornum >>= (\num -> foldr ... num)
10:13:14 <Philonous> Or you can use do-notation: num <- askfornum ; foldr ... num
10:13:17 <ski>   do xs <- askfornum
10:13:21 <ski>      let y = foldr (+) 0 xs
10:13:21 <ski>      ..y..
10:14:00 <ski> the `<-' there "converts" the `askfornum :: Num a => IO [a]' to a `x :: Num a => a'
10:14:37 <int10h_> Is it not possible to do something like return (foldr (+) 0 askfornum) at the end of the function to sum them up?
10:14:51 <ski> no, because `askfornum' is not a list
10:14:51 <Zao> ski: => [a], surely?
10:14:52 <Twey> ski: Er, [a]
10:15:08 <ski> Zao,Twey : sorry, you're both right
10:15:21 <Twey> Zao: Great minds ;)
10:15:25 <int10h_> Ah, this is my problem, I thought it was a list.
10:15:30 <ski> `askfornum' is an *action* that when *run* will return a list
10:15:52 <ski> you can "run" it by putting it "inside" a `do'-block like above
10:15:58 <int10h_> Ahhhhhhhhhhhhh
10:16:07 <int10h_> Okay, got you.
10:16:15 <Zao> Or by having it on the left hand side of a >>= or >>
10:16:24 <Zao> (or right hand side of a =<< :)
10:16:45 <int10h_> Okay, and >>= is equivalent to do, right?
10:16:50 * Twey nods.
10:17:00 <Twey> do notation desugars to a combination of >>= and >>
10:17:14 <int10h_> Okay, great, I'll try that. Thanks very much all.
10:19:17 <eden_> More about my Parsec issue. It appears that some combination of Stream.uncons and Prim,oken is what I need to use. Needless to say, there are no examples to help enlighten the uninitiated.  Does anybody have any?
10:19:42 <eden_> Well, Print.token anyway
10:20:12 <eden_> try that again.. Prim.token
10:31:36 <eden_> Ahem. Ecuse me for being so rude and demanding. The frustration is beginning to show. Sorry.
10:33:17 <c_wraith> eden_: I don't know parsec, so I can't be much use anyway...  But generally you get better suggestions by outlining your goal, rather than the tools you're trying to use to do it.
10:35:22 <TomMD> eden_: Stating your goal and pasting a small code fragment that is giving you trouble usually results in some good help.
10:36:53 <eden_> c_wraith, TomMD: For sure. I was making the rather dim assumption that those who made the suggestions to research these things were still around.
10:37:32 <Phyx-> I'm trying to implement a fix point datatype as a representation in LIGD. but the kind of it is (*->*)->* and the kind of the LIGD datatype is *, how can i do this? I thought using a Rank2 type but i still seem to get the kind error
10:37:34 <c_wraith> eden_: Ah.  No offense intended.  Apologies if I came off as a jerk.
10:37:49 <igor_> hey
10:37:57 <igor_> anyone here good with wxwidgets?
10:38:05 <igor_> i am confused about what dc is
10:38:31 <Twey> dc?
10:38:42 <eden_> None taken, after all, it was me being the petulant jerk.
10:39:11 <Twey> Ah, I see it
10:39:41 <Twey> igor_: http://docs.wxwidgets.org/2.6/wx_wxdc.html
10:39:51 <Twey> Fine manual, there.  :)
10:40:16 <igor_> i got the concept but not how I use it
10:40:29 <igor_> for example i want to use the function
10:40:37 <igor_> getTextExtent :: DC a -> String -> IO Size
10:40:39 <igor_> Gets the dimensions of the string using the currently selected font.
10:40:45 <Twey> Well, here's an example: http://wiki.wxwidgets.org/Drawing_on_a_panel_with_a_DC
10:40:53 <Twey> Right
10:41:12 <Twey> It seems to be passed as an argument to the render callback
10:41:26 <Twey> So you just need to pass it in
10:41:58 <igor_> so how do I get it, I mean in haskell wx?
10:42:06 <Twey> E.G. setRenderCallback (\dc -> print $ getTextExtent dc "Foo")
10:42:23 <Twey> Assuming setRenderCallback is the function to set the render callback.  I don't actually know wxHaskell.
10:43:49 <igor_> its not
10:43:57 <igor_> the wxHaskell docs are not too good
10:43:57 <Twey> Oh, right: it goes: set yourFrame [on render := \dc -> print $ getTextExtent dc "Foo"]
10:44:30 <Twey> They're practically non-existent.  In fairness, that's because, apart from a few things like this, they'd be almost identical to the wx docs.
10:44:38 <Twey> It's a pretty faithful binding.
10:45:26 <edwardk> eden_: basically look at the Char combinators they use the Prim.token
10:46:32 <Twey> igor_: There's a relevant example here: http://haskell.org/haskellwiki/WxHaskell/Quick_start
10:46:41 <Twey> The bouncing balls one
10:47:21 <igor_> i looked at it thats what confused me
10:47:22 <igor_> because
10:47:42 <igor_>     paintBalls :: Var [[Point]] -> DC a -> Rect -> IO ()
10:48:13 <Twey> That first argument is what gets passed in originally
10:48:17 <igor_> but than its called with only one argument
10:48:20 <igor_>   p <- panel f [on paint := paintBalls vballs]
10:48:22 <edwardk> eden_: basically all you want to do is replace the second function passed to token by the char combinators with one that just updates the source position by taking it from the stream directly (and maybe adding the current element being parsed)
10:48:23 <Twey> Yeah
10:48:30 <Twey> That's the magic of currying, igor_
10:48:49 <eden_> edwardk: Cheers. I hope the documentation is at least somewhat existent...
10:48:51 <igor_> i understand currying in basic examples
10:49:02 <Twey> a -> b -> c -> d means a function that takes a and yields a function that takes b and yields a function that takes c and yields d
10:49:20 <igor_> i understand currying
10:49:28 <edwardk> eden_: Text.Parsec.Prim is pretty straight forward and Text.Parsec.Char makes pretty good use of the basic Prim operations. just look at the interconnections between the two
10:49:40 <edwardk> the tedious part is having to reimplement all the Char combinators but
10:49:46 <ski>   p <- panel f [on paint := \dc rect -> paintBalls vballs dc rect]
10:50:00 <ski> is the same as above, only eta-expanded
10:50:08 <edwardk> you should be able to basically take Text.Parsec.Char as a template and just look for the few 'satisfy' like calls that hook in and call 'token'
10:50:36 <Twey> igor_: Well, that's all that's happening
10:50:57 <Twey> We're passing a single argument to get a function that takes the two remaining arguments
10:51:08 <Twey> Which the framework passes in when it calls the callback
10:51:10 <igor_> but dc isnt defined in the ballsFrame
10:51:20 <burp_> how can I open an existing file and replace some specific part, without deleting the whole file in WriteMode?
10:51:26 <Twey> igor_: That's an argument
10:51:36 <burp_> in AppendMode the handle is not seekable
10:51:36 <edwardk> igor: the result is a function that will take DC and the other arg later
10:51:53 <igor_> so to keep it simple
10:51:55 <Twey> The framework provides the DC and the viewable area
10:52:03 <igor_> if i wanted to get the size of a string
10:52:08 <igor_> what would i write?
10:52:21 <Twey> It's not that simple, I'm afraid
10:52:37 <Twey> You can't just get the size of a string, you have to get the size of a string in a particular drawing context
10:52:48 <Twey> (since it might have things like fonts specified that would affect the result)
10:52:52 <igor_> so yeah
10:52:56 <igor_> i wanna specify font
10:53:05 <igor_> and get the size of the string
10:53:09 <igor_> i only have one display
10:53:14 <igor_> no crazy stuff
10:53:30 <Twey> Well, you can create your own DC
10:53:49 <igor_> so I want to call dcSetFontStyle :: DC a -> FontStyle -> IO ()
10:54:03 <igor_> and than get the size
10:54:59 <igor_> nothing really complex
10:55:24 <Twey> Hang on
10:55:27 <igor_> thanks
10:55:48 <Twey> I'm searching for the DC-creating action :)
10:56:13 <igor_> thats exactly what I was searching for
11:00:44 <burp_> hm
11:00:57 <Cale> If you can't find one, look for something which takes a function which takes a DC
11:01:31 <Twey> Cale: We've got one of those
11:01:54 <igor_> yeah, two of those I want to use both take a DC
11:01:59 <Twey> But I think igor_ wants to be able to get the size of a string without having to use any particular existing DC
11:02:16 <igor_> if there is one automatically created i can use that one
11:02:23 <igor_> i am manually positioning words
11:02:26 <Cale> There's probably a function which creates a DC and passes it to the function you supply, running the resulting action, and then frees the DC afterward.
11:02:27 <igor_> and want to know how big they are
11:02:43 <Twey> igor_: There is: it's passed into the paint callback
11:02:54 <Twey> (see above)
11:04:12 <igor_> so how would it work? dcSetFontStyle FontStyle
11:04:54 <Twey> The ability to Hoogle wxHaskell docs would be very useful.
11:05:09 <igor_> and then size <- getTextExtent "String"
11:05:14 <igor_> ?
11:05:14 <Cale> There's an index
11:05:32 <Twey> igor_: What's the type of that?
11:05:33 <Cale> withClientDC and withPaintDC look suspicious :)
11:06:24 <Twey> I don't know... they provide a ClientDC and a PaintDC, respectively
11:06:35 <Twey> Will that work instead of a DC?
11:06:50 <Cale> I don't know... but they seem related...
11:07:19 <Twey> They do...
11:07:27 <Twey> But I don't think it'll work
11:08:18 <Twey> Hmm
11:08:31 <edwardk> hrmm is there an Earley style parser combinator library or something for Haskell?
11:09:16 <Twey> Cale: type DC a = WxObject (CDC a), but type PaintDC a = WindowDC (CPaintDC a)
11:09:25 <Cale> yeah
11:09:27 <Twey> Doesn't look like they're type-compatible
11:10:23 <Cale> But they're all type aliases...
11:10:29 <Cale> Do the types match anyway?
11:10:39 <glguy> Anyone remember any documentation about how it is more expensive to switch to the main thread than other forkIO generated ones?
11:11:04 <Cale> WxObject a = Object (CWxObject a)
11:11:09 <Twey> Cale: CDC is a marshalled type
11:11:16 <Twey> I think CPaintDC is too
11:11:52 <dolio> glguy: I don't know if there's any documentation, per se, but it's a known phenomenon.
11:11:54 <Twey> data CPaintDC a  Abstract type of the PaintDC class.
11:11:56 <int-e> glguy: forkIO generates unbound threads; the main thread is a bound thread.
11:12:03 <Cale> So DC a = WxObject (CDC a) = Object (CWxObject (CDC a))
11:12:37 <glguy> does this matter when not using the threaded runtime?
11:12:38 <Cale> WindowDC (CPaintDC a) = DC (CWindowDC a) = WxObject (CDC )
11:12:39 <Cale> er
11:12:45 <Twey> Oho!
11:12:45 <Cale> WindowDC (CPaintDC a) = DC (CWindowDC a) = WxObject (CDC (CWindowDC a))
11:12:53 <int-e> (and that must be documented somewhere, as well as the fact that switching to bound threads is more expensive. but where?)
11:12:54 <Twey> type WindowDC a = DC (CWindowDC a)
11:12:56 <Twey> Yeah
11:12:59 <Twey> So it should work?
11:13:14 <Cale> It's so hard to tell. There are so many damn type synonyma
11:13:18 <Cale> synonyms*
11:13:29 <Cale> I don't have wxhaskell installed.
11:13:30 <Twey> What's the difference between a ClientDC and a PaintDC?
11:13:31 <Twey> Yeah, heh
11:13:44 <Twey> I'm trying to install it, but it doesn't like me
11:13:53 <Twey> wxcore-0.11.0: file Graphics/UI/WXCore.hi is missing (use --force to override)
11:13:57 <Twey> (&c.)
11:14:47 <Cale> I'll give it a shot.
11:17:41 <Cale> I unpacked the .zip for the source and then did a cabal install from there, and it's compiling at least...
11:20:29 <igor_> thanks for helping me
11:20:38 <igor_> this whole OO to haskell thing is really confusing
11:21:08 <Twey> Yeah, it doesn't translate all that well
11:22:01 <gcollins_> does anyone know about debugging performance issues re: concurrency? I have a server program that runs 10x faster on my macbook then it does on a much faster quad-core linux box
11:25:23 <dons> bos is giving a talk at the erlang factory today. sick it to 'em, bos!
11:25:55 <Cale> gcollins_: That's interesting.
11:26:11 <Cale> gcollins_: Are they compiled the same way?
11:26:13 <gcollins_> Cale: it's killing me, it's for work :(
11:26:29 <Cale> gcollins_: How well does it make use of the 4 cores?
11:26:37 <gcollins_> That's the thing, terribly
11:26:55 <gcollins_> on OSX I'm getting about 130% cpu usage (dual core), on linux 25%
11:26:57 <Cale> I heard there is a bug in the linux scheduler which creates problems with using the last core.
11:27:12 <Cale> hmm, but that sounds much more severe
11:27:13 <dolio> 25%?
11:27:21 <Cale> How are you compiling it?
11:27:24 <gcollins_> it's gotta be some kind of locking issue
11:27:41 <gcollins_> with cabal, flags are "-Wall -funbox-strict-fields -fglasgow-exts -O2 -fvia-C -optc-O3 -threaded"
11:28:14 <gcollins_> the linux machine is 64-bit and i think ghc on osx is 32-bit, that might account for it also
11:28:39 <dons> gcollins_: well, 64 bit only accounts for GC issues (primarily)
11:28:45 <dons> check the output of +RTS -sstderr
11:28:50 <gcollins_> good idea
11:28:52 <dons> GC shouldn't be too high , i hope.
11:29:03 <dons> and check what the parallel GC is doing.
11:29:12 <gcollins_> dons: i'd expect cpu usage to be higher if that was the case
11:29:33 <dons> yes
11:30:39 <gcollins_> the test program i'm running is generating a lot of random numbers, the library isn't doing anything silly like using the linux system RNG is it?
11:30:58 <gcollins_> if it's blocked waiting for the entropy pool that might account for this
11:31:12 <Gracenotes> what's -optc-O3 and -fvia-C? todo with compilation via C?
11:31:13 <dons> using mersenne-random (package on hackage) might help.
11:31:24 <gcollins_> %GC time is 33.3%
11:31:25 * Cale grumbles. Why is wxHaskell trying to install itself globally when I issue cabal install?
11:31:48 <gcollins_> dons: I looked at that but didn't think i'd be able to get it to play nice w/ quickcheck
11:31:49 <dons> gcollins_: ok, so a bit high. not killer though. trying increasing tthe default heap size. +RTS -H500M
11:31:55 <dons> gcollins_: right.
11:32:24 <Berengal> Does anyone else experience that their functions tend to become longer and more complicated the longer the coding session lasts?
11:32:27 <gcollins_> the app is a happstack http server sitting in front of a processing backend
11:32:51 <gcollins_> the processing backend alone is performing okay but once i connect over http it goes to pot
11:33:18 <gcollins_> dons: -H500M = no change
11:33:52 <int-e> Gracenotes: -fvia-C is compilation via C; -optc-O3 passes -O3 to the C compiler.
11:34:35 <Gracenotes> okay. my option-parsing module is pretty accurate then
11:34:36 <user317> is it possible to use the Continuation monad to do this:  traverse a tree until i hit some value, then block on that branch and continue on another branch i hit another value, then continue on the original branch
11:34:43 <Gracenotes> the one in my head, that is
11:35:04 <Twey> Berengal: No
11:35:24 <ski> user317 : possibly
11:35:30 <Twey> I consider a function greater than ten lines a Smell :)
11:35:30 <Berengal> Twey: No?
11:35:46 <Gracenotes> user317: if you use a list as a the continuation value, perhaps
11:35:46 <Berengal> So do I, but my sense of smell seems to decrease over time
11:35:48 <Twey> Rare exceptions made for big chunks of IO
11:35:51 <Gracenotes> -a
11:35:54 <user317> is it possible to do this with the continuation monad, lets say i am traversing a tree, and i hit some value A, i want to yeild, and start on a different branch until i hit A on that branch then restart the original
11:35:59 <Twey> Oho
11:36:15 <Twey> Perhaps you should try doing it backwards, then
11:36:26 <Gracenotes> user317: the state monad and continuation monad are rather similar
11:36:27 * gcollins_ grumbles and breaks out "strace"
11:36:31 <Twey> Label every little thing with a new function, and only combine them when you're done with the session
11:36:39 <user317> i am not sure which branch will hit which value
11:36:52 <Gracenotes> use back-tracing
11:37:01 <Cale> Twey and igor_: I got wxHaskell to install. It seems that ClientDC and PaintDC don't unify with DC
11:37:03 <Gracenotes> backtracking
11:37:09 <Twey> Cale: :(
11:37:11 <user317> Gracenotes, that would be slow, although it would be cheaper in memory
11:37:13 <Berengal> In the beginning of a session, I'll often outsource even small snippets to their own functions. At the end I'll be all like "oh, just a simple foldl, I'll fmap it a couple of times and I should be golden"
11:37:19 <Twey> Perhaps you *can't* create a DC, then
11:37:29 <Twey> Perhaps you just have to do it in the paint handler.
11:37:35 <gcollins_> dons: it's spending 99.81% of its time inside "futex"
11:37:41 <Cale> Oh, does the paint handler give you one?
11:37:48 <ski> user317 : you can use the continuation monad to implement cooperative multitasking .. so you can for each node in the tree spawn a task for each subtree, then use a `yield' operation when you encounter an `A' to make that task go to sleep
11:37:49 <Gracenotes> user317: you're trying to avoid loops in a derivation tree, or something?
11:37:52 <Twey> Berengal: *laughs*
11:37:53 <Twey> Cale: Yes
11:38:06 <Twey> That and a rectangle representing the visible area
11:38:14 <ski> Gracenotes : i'm not sure backtracking would be that helpful, in this case
11:38:23 <Berengal> Twey: Haskell does help to remedy this somewhat by giving me 50 line type errors..
11:38:28 <igor_> I will work with that then
11:38:31 * Twey laughs.
11:38:40 <igor_> i spent a week trying to get a simple thing
11:38:43 <Twey> Yeah  and more code equals less types
11:38:43 <Cale> Because there's perhaps dcEncapsulate if you don't really want to draw...
11:38:52 <igor_> showing a stylized word and getting it size to work
11:38:56 <dons> gcollins_: ok. so now you know what to look at :)
11:38:57 <Twey> dcEncapsulate?  *finds*
11:39:00 <user317> Gracenotes: basically i am parsing a syntax tree, i need to make sure that when i hit a reference that i can find the declaration of that reference somwhere, which can be anywhere down the tree...  backtracking could work, i could basically do iterative dfs until all the declarations are found
11:39:13 <Twey> Oh right
11:39:20 * gcollins_ nods, ruefully
11:39:33 <Gracenotes> oh. so you're dealing with a recognized grammar, rather than a generated one
11:39:47 <Berengal> Type errors have the ability to manifest themselves a long way from the cause if you don't split your code up
11:39:52 <Gracenotes> okay. /me assumed too much :3
11:39:53 <Twey> Aye
11:40:16 <Cale> user317: Well, you can call the search for the other branch with your current continuation after finding the first thing you were looking for
11:40:37 <Cale> user317: Then it just has to call the computation it's handed to pass control back.
11:40:57 <user317> Cale: thats what i was thinking, but i am unfamilair with Cont, cool, so it seems like it should work how i expect it too
11:41:24 <Cale> But Cont isn't something I'd usually leap to using if I could find another way.
11:41:29 <user317> Cale: is there any way to know if a branch ends up unsatisfied?
11:41:44 <mmorrow> (obvious-after-the-fact-but-(at-least-i)-didn't-think-to-do-it-until-now): $ ghci +RTS -N2 -RTS
11:41:44 <Cale> It's very easy to write extremely confusing programs with Cont
11:41:52 <mmorrow> or -Nwhatever
11:41:52 <Twey> *grins*
11:41:53 <dons> mmorrow: does that even work?
11:41:56 <Twey> I thought that was why it was fun
11:41:57 <mmorrow> oh yesh
11:42:03 <dons> ghci doesn't use the threaded rts does it?
11:42:09 <mmorrow> dons:it does
11:42:11 <dons> huh
11:42:21 <dons> so ghc's built against the threaded rts?
11:42:27 <vixey> Cont is very strange.. wty is that+
11:42:28 <ski> user317 : i did a simple implementation of cooperative threads in `ContT', for a turtle graphics laboration .. i think it should be possible to add synchronization points and inter-thread communication to something like that
11:42:29 <vixey> ?
11:42:45 <mmorrow> dons: the thing is though, i'm not sure if the +RTS -RTS is affecting ghci itself, or both ghci and the code it runs
11:43:05 <vixey> what are the pre and post conditions on bind of the Cont monad?
11:43:25 <ski> are there any ?
11:43:27 <Cale> vixey: Um, just what's apparent in the type?
11:43:30 <mmorrow> they're in the same address space i guess, and if ghci exported global vars, interpreted code could play with the interp
11:44:03 <ski> (`Cont' is no stranger than proofs using classical logic)
11:44:05 <Cale> vixey: Well, and the monad laws...
11:44:33 <Cale> ski: While that's in one sense true, it's also not.
11:44:49 <mmorrow> dons: i just confirmed that it _is_ working for the interpreted code
11:44:53 <ski> Cale : elaborate ?
11:44:58 <vixey> does Cont monad give CBN shift/reset?
11:45:04 <mmorrow> (working like you'd think)
11:45:38 <ski> vixey : i think the "natural" way to work in the `Cont' monad corresponds to a CBV CPS translation
11:45:40 <Cale> ski: The details of how things are expressed, and what you're actually expressing are wildly different.
11:46:40 <Cale> There's a certain isomorphism, but it doesn't preserve ease of comprehension :)
11:48:32 <Cale> In applying classical logic normally, Peirce's law is not something you tend to apply directly.
11:48:48 <mmorrow> dons: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2292
11:49:15 <mmorrow> dons: yeah, built against the threaded rts
11:49:16 <Cale> (whereas it's essentially all that the Cont library provides :)
11:50:42 <Cale> In fact, if you were to ask most mathematicians if they knew what Peirce's law is, I'd bet most of them have no idea, and if you were to write it down and ask them if it's true, they'd usually have to think a moment.
11:51:41 --- mode: irc.freenode.net set +o dibblego
11:52:38 <Cale> In fact, when confronted with something like that (if I didn't already know the answer), I think my first repsonse would be to start turning implications into 'or' and 'not'
11:52:41 <Renderwahn> anyone here managed to install leksah on gentoo amd64?
11:53:04 <tomh> mm i have a lib which has a datatype which not derives show, is it possible to derive it in my own code somehow?
11:53:05 <ski> (Cale : something like what ?)
11:53:18 * mmorrow aliases ghci to ghci +RTS -N2 -RTS
11:53:18 <Cale> ski: Like ((P -> Q) -> P) -> P
11:53:48 <mmorrow> Tomas: use standalone deriving
11:53:49 <opqdonut> Cale: mine too
11:53:51 <Phyx-> can you actually compare an adt such as "data Fix f = In (f (Fix f ))" for equality? given that f is of kind *->* ?
11:53:53 <mmorrow> err, @tomh
11:54:00 <tomh> standalone deriving?
11:54:02 <mmorrow> deriving instance Show Foo
11:54:08 <tomh> ah ok thanks
11:54:33 <ski> Phyx- : yes, if you can define `instance Eq a => Eq (f a)' for the particular `f' in question
11:55:13 <ski> if it was allowed, one would write an `instance (forall a. Eq a => Eq (f a)) => Eq (Fix f) where ...' once and for all
11:55:20 <byorgey> but you might have to write something like   instance (Eq (f (Fix f))) => Eq (Fix f) where ...
11:55:20 <mmorrow> , muT [0..3]
11:55:23 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
11:55:24 <vixey> Cale, but Pierce is equiv. to LEM I think ?
11:55:26 <Cale> ... ((Q or not P) -> P) -> P  ... (P or not (Q or not P)) -> P ... (P or (not Q and P)) -> P ... yes, that's true.
11:55:29 <Cale> vixey: It is.
11:55:45 <ski> Phyx- : since that's not currently allowed, there is a workaround (or maybe more than one)
11:55:59 <Phyx-> ski: can you direct me to one?
11:56:37 <byorgey> Phyx-: does what I wrote above work?
11:56:52 <Cale> vixey: My point is that most users of classical logic are completely unaware of that, and never apply Peirce's law directly.
11:57:00 <ski> Phyx- : wait a little while. i'll make a paste of the idea, ok ?
11:57:43 <Cale> vixey: Not only that, but when confronted with something of that sort, the first impulse is to turn it into something easier to read.
11:57:45 <ski> byorgey : i seem to recall GHC does not like that because of termination problems in the class constraint solver
11:57:46 * vixey allegric to "___ is true"
11:57:55 <Phyx-> byorgey: i haven't tried that yet, my actuall problem is a bit different, but instead of asking the solution to it, i generalized it and asked the generalized version
11:58:07 <Phyx-> so i can attempt to solve the real one i'm having afterwards
11:58:17 <byorgey> ski: hmm... I've definitely done things like that to define a Show instance for Fix
11:58:30 <byorgey> oh, well, you may have to turn on UndecidableInstances
11:58:34 <byorgey> so yeah
12:00:16 <Cale> vixey: If you missed the start of the conversation, ski was saying that reading/writing code written in Cont is equivalent to reading/writing proofs in classical logic. I think this is only true in a formal sense which is irrelevant to concerns regarding usability :)
12:01:27 <vixey> I am not sure sure Cale, When you talk about a proof in classical logic - is that a derivation tree, because outside of studying logic itsself I think these are so rare
12:02:13 <Cale> I'm talking about something written using natural deduction.
12:03:01 <vixey> I think there is a 1-1 relation of lambda terms and natural deduction tree
12:03:15 <opqdonut> programs are proofs etc
12:03:42 <Cale> There is, but it's an awkward enough isomorphism that when you're talking about how readable or how easy to write something is, it's somewhat meaningless.
12:04:19 <Cale> Converting applications of LEM into applications of Peirce's law is really really awkward.
12:04:58 <Cale> The fact that it can be done has nothing to say about how easy it is to read the result :)
12:05:02 <mmorrow> Phyx-: here's Mu with instances of Eq,Ord,Read.Show: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2293
12:05:24 <mmorrow> yeah, you need UndecidableInstances
12:05:31 <vixey> Cale, I think you can have a closed term of P/\~P assumping Pierce and vice versa though
12:05:43 <vixey> so you can just look at them both as opaque 'axioms'
12:05:51 <vixey> (even though one was a derived from)
12:06:00 <Phyx-> mmorrow: ah, ok, cool thanks, that helps me out alot
12:07:58 <Cale> vixey: Surely you mean P \/ ~P :)
12:08:29 <Cale> Even then, I think you'd have to build up a lot more than this...
12:09:14 <Cale> and you'd end up with a library of named terms all of which correspond to transformations that ordinarily would go by wordlessly in a normal proof.
12:09:20 <roconnor> @djinn ((a -> b) -> a) -> a) -> (Either a (Not a))
12:09:21 <lambdabot> Cannot parse command
12:09:27 <Cale> ...
12:09:32 <roconnor> @djinn (((a -> b) -> a) -> a) -> (Either a (Not a))
12:09:32 <lambdabot> -- f cannot be realized.
12:09:36 <Cale> ah
12:09:39 <vixey> @djinn (((Not a) -> a) -> a) -> (Either a (Not a))
12:09:39 <lambdabot> -- f cannot be realized.
12:09:48 <roconnor> hmm
12:09:55 <vixey> djinn can't handle forall is the problem ?
12:10:11 <roconnor> perhaps we need different instances of pierce
12:10:13 <Phyx-> mmorrow: thanks again :) i was able to figure out what i was doing wrong :)
12:10:18 <vixey> @djinn (Not (Not a) -> a) -> (Either a (Not a))
12:10:18 <lambdabot> -- f cannot be realized.
12:10:30 <mmorrow> Phyx-: no problem, glad it helped :)
12:10:36 <vixey> @djinn (Not (Not (Either a (Not a))))
12:10:36 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
12:10:59 <vixey> @djinn (Not (Not (Either a (Not a))) -> (Either a (Not a))) -> (Either a (Not a))
12:10:59 <lambdabot> f a =
12:10:59 <lambdabot>     case a (\ b -> void (b (Right (\ c -> b (Left c))))) of
12:10:59 <lambdabot>     Left d -> Left d
12:10:59 <lambdabot>     Right e -> Right e
12:11:14 <vixey> yaeh if you pre-instantiate it a few times maybe it will find the proof
12:12:10 <vixey> Cale, why do we take P \/ ~P as the axiom though
12:12:59 <Cale> vixey: Because it's the easiest to imagine the meaning of.
12:13:18 <Cale> ((P -> Q) -> P) -> P  takes a lot of work to unravel
12:13:18 <mmorrow> is P an open set here? so P \/ ~P is all of the space?
12:13:34 * mmorrow is joking, but not really
12:14:01 --- mode: irc.freenode.net set +o ChanServ
12:14:32 <dolio> @djinn ((Not (Either a (Not a)) -> Either a (Not a)) -> Either a (Not a)) -> Either a (Not a)
12:14:33 <lambdabot> f a =
12:14:33 <lambdabot>     case a (\ b -> Right (\ c -> b (Left c))) of
12:14:33 <lambdabot>     Left d -> Left d
12:14:33 <lambdabot>     Right e -> Right e
12:14:52 <Cale> @djinn Cont b (Either a (a -> b))
12:14:52 <lambdabot> f a = a (Right (\ b -> a (Left b)))
12:15:11 <vixey> @src Cont
12:15:11 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
12:15:20 <Cale> Not in this case
12:15:25 <vixey> @src Not
12:15:25 <lambdabot> Source not found.
12:15:33 <vixey> ?djinn Env
12:15:33 <lambdabot> Error: Undefined type Env
12:15:34 <Cale> I just defined  type Cont r a = (a -> r) -> r
12:15:36 <vixey> ?djinn-env
12:15:37 <lambdabot> data () = ()
12:15:37 <lambdabot> data Either a b = Left a | Right b
12:15:37 <lambdabot> data Maybe a = Nothing | Just a
12:15:37 <lambdabot> data Bool = False | True
12:15:37 <lambdabot> data Void
12:15:39 <lambdabot> type Not x = x -> Void
12:15:41 <lambdabot> class Eq a where (==) :: a -> a -> Bool
12:15:43 <lambdabot> type Cont r a = (a -> r) -> r
12:15:43 <vixey> Cont Void P is ~~P?
12:15:49 <Cale> yeah
12:16:07 <Cale> @djinn Cont Void (Either a (Not a))
12:16:08 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
12:16:13 <vixey> ?djinn Cont Void (Either a (Not a))
12:16:14 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
12:16:20 <dolio> @type callCC (\k -> return (Right (\c -> k (Left c))))
12:16:22 <lambdabot> forall (m :: * -> *) b a. (MonadCont m) => m (Either a (a -> m b))
12:16:43 <mmorrow> @djinn ((a -> Cont o b) -> Cont o a) -> Cont o a
12:16:44 <lambdabot> f a b = a (\ c _ -> b c) b
12:16:45 <Cale> hmm, that's a little different
12:16:57 <Cale> er
12:18:33 <dolio> a -> m b is the type of an a continuation in the relevant monad, though.
12:18:51 <vixey> maybe Epigram 2 will be programming in natural deduction
12:19:06 <mmorrow> @djinn ((a -> Cont s r) -> Cont r r) -> Cont r a
12:19:06 <lambdabot> f a b = a (\ c d -> d (b c)) (\ e -> e)
12:19:09 <mmorrow> shift
12:19:33 <mmorrow> @djinn Cont a a -> Cont r a
12:19:34 <lambdabot> f a b = b (a (\ c -> c))
12:19:36 <mmorrow> reset
12:20:16 <Cale> I think it's perhaps the case that natural deduction is better if you're concerned primarily with what theorems are true, and not exactly which proofs you have.
12:20:22 <edwardk> mmorrow: you have to see this one =)
12:20:23 <edwardk> @hpaste
12:20:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:20:33 <mmorrow> ooh
12:21:33 <Cale> Natural deduction obscures somewhat the tree structure of the proof, which is obviously relevant when you're thinking of the proof as a program.
12:21:37 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4458#a4458
12:21:46 <edwardk> i unboxed the right kan extension based state monad
12:22:03 <edwardk> its 40% faster than your S monad on your state-bench.
12:22:19 <dolio> With rank-2 callCC, you could make 'newtype Not m a = Not (forall b. a -> m b)' and then turn that into 'm (Either a (Not m a))' I think.
12:22:35 <mmorrow> edwardk: zomg sweet
12:22:39 <edwardk> the data family instance being used is the instance for AdaptState (Int,Int)
12:23:44 <edwardk> mmorrow: if i'm sufficiently masochistic i could automatically generate a ton of these using the right-kan extension stuff and it should basically let you work with mostly unboxed cps transformed monad transformers
12:23:48 <dolio> GHC doesn't successfuly unbox the Ints itself?
12:23:54 <dolio> Or is it only with pairs that it doesn't?
12:24:00 <edwardk> but it runs your bench in 0.16 seconds compared to ~ 0.75 using MTL.
12:24:26 <edwardk> and .23 or so using the cps transformed state monad
12:24:48 <dolio> Maybe it figuring that out itself is wishful thinking on my part.
12:24:58 <edwardk> dolio: its just not that smart. this has some other advantages, by cps transforming in this style, the ints don't even move on the stack
12:25:13 <mmorrow> awesome. and that cps state monad was twice as fast as unboxed-tuple state, which was in turn faster that Control.Monad.State(.Strict)
12:25:17 <edwardk> because most fmaps, etc. and even binds live further up the stack due to partial application
12:25:45 <dolio> Right, I meant in comparison to just CPSing.
12:25:46 <mmorrow> interesting
12:25:48 <ilseman2> @pl d6 n = n `d` 6
12:25:48 <lambdabot> d6 = (`d` 6)
12:26:12 <edwardk> mmorrow: and the approach generalizes to any of the right kan extension transformers, so i should be able to make it work for most any transformer
12:26:35 <edwardk> dolio: i think you're way hopeful to think it'd unbox across a bunch of calls to get/put. etc.
12:26:43 <dolio> :)
12:27:02 <mmorrow> edwardk: very nice
12:27:09 <dolio> You'd probably have to agressively INLINE at least.
12:27:34 <edwardk> i tried basically INLINE'ing and SPECIALIZE INLINE'ing everything i could
12:27:57 <edwardk> even copied the MTL out and tried dropping them into there
12:28:11 <edwardk> (for the basic version) and specialized the cps transformed version as well
12:28:41 * mmorrow can't wait til 6.12 when TH has INLINE, UNPACK, and type families..
12:28:57 <edwardk> mmorrow: yeah
12:28:57 <dolio> I suppose strictness analysis is unlikely to figure that all out in any case.
12:29:57 <dolio> Since put isn't expected to blow up the entire computation if you pass it a bottom.
12:30:19 <ski> Phyx- : (forall a. Eq a => Eq (f a)) => Eq (Fix f) <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4459>
12:31:06 <dolio> Clearly that's why a partiality monad is necessary. Then you can assume all pure values are well defined and optimize accordingly. :)
12:31:42 <vixey> does partiality monad use massive amounts of memory
12:34:10 <ski> mmorrow : have you tested those instances for `Mu' ?
12:34:31 <fadec> Quick question. Haskell has "conjunctive" typeclasses, where a subclass must be a member of all parent classes. Is there such a thing as a disjunctive or exclusive typeclass?
12:35:01 <fadec> I don't think there is and I don't know what it would entail, bad or good.
12:35:47 <edwardk> mmorrow: i figure State and Reader would be nice to optimize like this for adaptive-containers, even if i use the crappy 'at-most-pairs' version of the packing
12:36:30 <edwardk> i'm also tempted to expose a slightly more obviously unboxed runUState that runs it as an unboxed tuple
12:36:35 <mmorrow> edwardk: yeah, State and Reader would be perfect. i wonder about writer?
12:36:39 <Cale> fadec: It doesn't make much sense conceptually. You would need a value-level construct to go along with it, like typeclass-case
12:36:45 <mmorrow> ski: yes, they work
12:37:05 <edwardk> mmorrow: well, i need 'unboxed monoids' for that, which ties to the better packer
12:37:18 <edwardk> because that will work for things like 'Sum Int' ,etc
12:37:25 <edwardk> without instance explosion
12:37:59 <Cale> fadec: The purpose of typeclasses is to restrict the types over which type variables range to those which support a given interface. If you only know that some type supports one of two interfaces, but you can't tell which, it's kind of useless.
12:38:36 <fadec> Cale: I figure it couldn't go very far. I was just wondering if the idea had been explored. Can't find much on it with google.
12:39:05 <ski> Cale : actually, i didn't say it was equivalent :) .. i said it was "no stranger than" .. i'm open to the possibility that proofs in classical logic can be stranger (at least if you accept the general axiom of choice)
12:39:16 <ski> Cale : "Natural deduction obscures somewhat the tree structure of the proof" - elaborate ?
12:39:42 <Cale> ski: It gives you one topological sort of the tree.
12:39:55 <ski> Cale : not if you write it as a tree
12:40:16 <jackrr> Where does cabal install get its proxy configuration?
12:40:39 <Cale> Well, when I think of natural deduction, I think of a proof as a sequence, rather than a tree, of statements, where each consecutive statement follows in some fashion from the previous ones.
12:41:19 <ski> fadec : well, i think of "subclass" in haskell as just a precondition of being an instance of a class. so e.g. `Eq a' and `Show a' are both preconditions of having a `Num a' instance .. iow, we have declared that the latter must imply the conjunction of the former
12:41:50 <mmorrow> , muT [0..3]
12:41:52 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
12:41:55 <Cale> ski: Classical logic can also be much less strange.
12:41:56 <mmorrow> , muT [0..3] == muT [0..3]
12:41:58 <lunabot>  True
12:42:02 <edwardk> i'm just really really pleased that the unboxed cps version actually worked =)
12:42:02 <ski> fadec : one could possibly imagine things like declaring that a type being a member of some class must imply a disjunction of other such class memberships .. but haskell doesn't have that, no
12:42:05 <mmorrow> , muT [0..3] < muT [0..2]
12:42:07 <lunabot>  False
12:42:09 <Cale> ski: (which was my original point)
12:42:34 <ski> Cale : (i'm not sure i doubt that but) can you give an example of what you mean ?
12:42:37 <mmorrow> , read (show (muT [0..3])) :: Mu (T Int)
12:42:39 <lunabot>  Mu (T (Mu (T (Mu (Tip 0)) (Mu (Tip 1)))) (Mu (T (Mu (Tip 2)) (Mu (Tip 3)))))
12:42:55 <mmorrow> , src ''T
12:42:58 <lunabot>  data T a b = Nil | Tip a | T b b
12:42:59 <gwern> ski: maybe we could have turing-complete class constraints!
12:43:06 <gwern> that'd answer them critics
12:43:12 <ski> mmorrow : ok. then i assume that it must be the old GHC here that doesn't like `instance Eq (f (Fix f)) => Eq (Fix f)'
12:43:22 <edwardk> gwern: you can
12:43:25 <Cale> ski: Well, callCC is comparatively a very awkward means of expression for the sorts of applications of LEM which are common in proofs in classical logic
12:43:32 <gwern> -_-
12:43:32 <mmorrow> ski: hmm, did you turn UndecidableInstances on?
12:43:54 <edwardk> ski: that is flagged as undecidable these days
12:44:09 <fadec> ski: yea, it would be saying that something is either e.g. mailable or fedexable or both or either at the type level. Like Cale said though, it would probably require a case expression in the typeclass.
12:44:26 <ski> mmorrow : since i tried some minutes ago with `-fallow-undecidable-instances' and hit the depth-limit (see "(forall a. Eq a => Eq (f a)) => Eq (Fix f)" <http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4459>)
12:44:43 <mmorrow> ski: which ghc are you using?
12:44:54 <ski> edwardk : unboxed cps where ?
12:45:15 <ski> mmorrow : 6.2.2 here (yes i know, really old :)
12:45:18 <edwardk> ski: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4458#a4458
12:45:21 <mmorrow> ski: hahah
12:45:29 <mmorrow> ski: :)
12:45:38 <edwardk> ski: the continuing saga of adaptive-containers
12:45:42 <edwardk> ski: now with monads
12:46:26 <edwardk> ski: mmorrow has a nice little state benchmark using fib and a two integer state
12:46:44 <ski> fadec : it might be interesting to develop the idea ..
12:46:49 <Cale> fadec: It would require a syntax like  (\x -> typeCase x :: a of Fedexable a -> fedex x; Mailable a -> mail x) :: (Fedexable a /\ Mailable a) => a -> IO ()
12:47:16 <mmorrow> ski: this is the original version, without edwardk's improvemnts: http://moonpatio.com/repos/MISC/state-bench/
12:47:29 <Phyx-> ski: ah cool, thanks for the step by step, it clarified why the way mmorrow gave me (and my fix) worked :)
12:47:57 <ski> Cale : how is that an example of classical logic being less strange (than some constructive logic, presumably) ?
12:48:08 <ski> Cale : both `callCC' and `lem' are classical
12:48:24 <mmorrow> it looks like in 6.2.2 the target instance isn't added to the graph before the constraint is, resulting in looping
12:48:30 <Cale> ski: But nobody actually uses callCC to write classical logic proofs.
12:48:36 <ski> so ?
12:48:52 <roconnor> mmorrow: P is an open set but ~P is the interior of the complement of P
12:49:03 <Cale> ski: I'm comparing classical logic and Cont
12:49:04 <ski> i don't see the relevance of that to your point "<Cale> ski: Classical logic can also be much less strange."
12:49:06 <mmorrow> roconnor: nice catch :)
12:49:07 <roconnor> thus P \/ ~P isn't necessarily the whole space
12:49:39 <roconnor> http://r6.ca/blog/20060315T094400Z.html
12:49:48 <roconnor> ``Putting the Logical in Topological''
12:49:53 <Cale> ski: It's usually the case that it's easier to understand proofs in natural deduction style than their equivalent versions in terms of Cont, I'm willing to bet :)
12:49:58 <McManiaC> is there a way to "show" an int with a leading 0? so i get a string of length 2, 3, w/e, even for the number 1 to 9 etc?
12:50:21 <ski> Cale : ok .. i thought you were comparing classical logic and a constructive logic .. imo, there's not much difference between classical logic and `Cont'-side-effects .. which of `callCC' and `lem' you choose as primitive doesn't matter when you have defined the other in terms of it and can use whichever you like
12:50:29 <mmorrow> roconnor: you should read about the basic ideas in algebraic geometry. i think you'd find it interesting
12:51:12 * roconnor prefers geometric algebra
12:51:17 <Cale> ski: I agree that on some technical level they're the same, but I disagree that there's anything like a relationship between the usability of Cont and the usability of classical logic in natural deduction style.
12:51:26 <ski> Phyx- : note that apparently mmorrow's version works in more recent GHCs, contrary to what that paste implies
12:51:31 <mmorrow> roconnor: basically, it's just a a pair of adjoint functors between the category of commutative rings and top spaces
12:51:35 <Cale> ski: Because the translation is so awkward in either direction.
12:51:59 <wli> I'm hoping I can figure out how to solve systems of polynomial equations by transforming them into eigensystems.
12:52:13 <Phyx-> ski: yeah, I'm using 6.10.1 and it worked
12:52:44 <Cale> mmorrow: Which pair of adjoint functors are you referring to?
12:53:11 <Cale> The one involving the coordinate ring?
12:53:14 <mmorrow> roconnor: prime ideals map to closed and irreducible algebraic varieties, so then you just forget about the elements of the ring and only consider the collection of prime ideals.. then you can work over Z for instance instead of some (algebraically closed) field
12:54:54 <fadec> Cale: That looks right. I think it might be synonymous with creating a sum type data constructor and then wrapping it up in a typeclass. The data constructor is needed for the case statement anyway.
12:55:24 <Cale> Oh, you could do it with GADTs, yeah
12:55:49 <ski> > let n = 5 in (reverse . take n . (++ replicate (n-1) '0') . reverse . show) 945  -- McManiaC
12:55:51 <lambdabot>   "00945"
12:55:56 <Cale> Roughly, anyway
12:56:04 <mmorrow> Cale: "ideals <-> varieties" i guess. hmm, i dont know how to say it precisely.
12:56:36 <Cale> mmorrow: I suppose it is an adjunction, but normally it's thought of as a Galois connection
12:56:37 <McManiaC> ski: ok, so "no"
12:56:38 <McManiaC> ^^
12:57:13 <mmorrow> Cale: that's so old school though :)
12:57:28 <ski> Cale : i'm more or less claiming that to understand how to reason and evaluate classical proofs, you need something similar to an understanding to how actions in `Cont' execute
12:57:43 <deech> Hi all, Can I ask for help about happstack here?
12:57:45 <Cale> ski: I don't think that's really true.
12:58:04 <ski> Cale : of course, usually mathematicians are not at all reasoning about and evaluating classical proofs *themselves* as objects
12:58:35 <Cale> ski: Right.
12:58:50 <ski> they are simply using proofs as a tool for ensuring truth of propositions about objects which they may care about evaluating, in some cases
12:58:52 <Cale> ski: Ordinarily, classical logic proofs have no semantics at all.
12:59:12 <mmorrow> ski: creating
12:59:18 <ski> Cale : did i make myself clear about what i meant, now ?
12:59:24 <Cale> ski: Somewhat. :)
12:59:27 <roconnor> did Cale say that he thinks natural deduction is a sequence of statements?
12:59:53 <Cale> roconnor: I did say that. If someone says "natural deduction" it's normally what I think.
13:00:09 <roconnor> I've never seen natural deduction presented that way
13:00:13 <Cale> roconnor: Of course there's a related tree, but that's not the usual syntax.
13:00:13 <roconnor> http://upload.wikimedia.org/math/6/b/2/6b295391629fdde6bb87309dd476ea71.png
13:00:17 <roconnor> no
13:00:22 <roconnor> the above png is the typical syntax
13:00:34 <Cale> If you're a logician, perhaps.
13:00:35 <roconnor> and is very tree like
13:00:51 <roconnor> who do you think studies natural deduction?
13:01:34 <Cale> But even logicians will write proofs about natural deduction in the style of natural deduction where you just have a sequence of statements.
13:01:58 <Cale> (and write the proofs that they're studying as objects using the tree syntax)
13:02:16 <roconnor> I have no idea what you mean by ``style of natural deduction where you just have a sequence of statements.''
13:02:24 <roconnor> I've never seen that, and it makes no sense
13:02:32 <roconnor> someone has corrupted you
13:02:40 <Cale> roconnor: I mean the sort of proof that you see in 99% of all mathematics courses.
13:02:44 * wli still does not understand how the algorithms to find solutions of systems of polynomial equations by transforming them into eigensystems works.
13:02:55 <roconnor> Cale: you mean informal Eenglish proofs?
13:03:09 <Cale> roconnor: Well, the thing which the informal English proofs are a thin layer over.
13:03:27 <ski> one can write natural deduction proofs as blocks of text with indented subblocks for subgoals for each inference rule
13:03:43 <Cale> roconnor: A proof is a sequence of statements where each consecutive statement follows according to some rule from those which occur before it in the sequence.
13:03:45 <ski> for large proofs, this is more manageble, because it doesn't get as wide
13:03:50 <wli> ski: Prolog programs? ;)
13:03:52 <ski> also, obviously one uses lemma
13:03:53 <roconnor> ski: are you talking about flag deduction?
13:03:55 <ski> lemmas
13:04:13 <ski> roconnor : i'm talking about natural deduction
13:04:18 <Cale> It's equivalent to writing a topological sort of the proof tree.
13:04:27 <ski> * B because
13:04:34 <ski>   * A -> B because
13:04:36 <ski>     ...
13:04:36 <roconnor> but any formal rule system can be written in a sequence
13:04:38 <Cale> (which is all you need in order to verify the proof is correct)
13:04:41 <ski>   * A because
13:04:43 <ski>     ...
13:04:47 <ski> in that style
13:04:51 <ski> (that's modus ponens)
13:05:09 <roconnor> ski: wait, how do you close off hypothesis if you are writing things in a sequential style?
13:05:22 <ski> * A -> B because
13:05:26 <ski>   + assume A
13:05:29 <ski>   ...
13:05:34 <ski>   * B
13:05:41 <ski> something like that
13:05:52 <ski> `A' is only available in that indented subblock
13:06:01 <Cale> Right.
13:06:13 <roconnor> ski: that sounds like Fitch flag style
13:06:14 <wli> Cox, Little, & O'Shea describe an algorithm to transform systems of polynomial equations into eigensystems but I'm having a tremendous amount of trouble understanding it.
13:06:24 <wli> (Using Algebraic Geometry)
13:06:27 <Cale> (Or, if you're just writing for a human being and not a machine, you can leave out the indentation, because it's easily inferred.
13:06:28 <Cale> )
13:06:43 <roconnor> ski: hmm, interesting.  Apparently Fitch flag style is also called natural deduction
13:06:43 <ski> wli : well, in Prolog one writes formulae, not proofs .. the system (implicitly) searches for proofs when executing the program
13:07:06 <Cale> Indeed, A implies B, since if A then ..., and we obtain B.
13:07:12 <wli> ski: Point. Maybe some dependently-typed language or something, then.
13:07:20 <ski> wli : in Twelf (a logic programming language / proof construction language), one can write proofs, and in some cases infer them by search
13:07:45 <ski> (Twelf is a dependent logic programming language, yes)
13:08:47 <mmorrow> wli: i have this book somewhere or another on computational algebraic geometry, but i haven't ever looked at it yet. i looked briefly over it and can't seem to see what the point of it all is, as in what are the applications?
13:08:50 <ski> roconnor : yes, i've heard the name `Fitch' as well .. in any case, if the only difference is the "concrete syntax", i consider this as basically the same as natural deduction
13:09:01 <roconnor> ok okay
13:09:24 <roconnor> I'm not sure
13:09:31 <mmorrow> it seems uninteresting to me to compute things about it, because i just don't understand why you'd want to
13:09:33 <roconnor> I haven't really studied Fitch style
13:09:44 <roconnor> I could believe it is isomorphic
13:09:47 <RayNbow> Fitch style proofs?
13:09:52 <Cale> mmorrow: It could be useful for gaining intuition?
13:10:19 <RayNbow> http://www.phil.cam.ac.uk/teaching_staff/Smith/LaTeX/resources/fitch.gif <-- are we talking about this?
13:10:28 <ski> (Cale : btw, i have written proofs on math exams in that style :)
13:10:42 <roconnor> RayNbow: that's what I'm talking about.  Not sure if it is what ski is talking about.
13:11:09 * RayNbow was taught the Fitch style notation for proofs
13:11:19 <Cale> ski: I tend to prefer not being so formal about it. I usually want to minimise the number of symbols in my proofs as well.
13:11:20 <mmorrow> Cale: possibly
13:11:30 <f4hy> I think I am finally getting a hang of haskell, but too often I run into problems that I have no idea how to solve functionally
13:11:34 <ski> roconnor : yes, something like that .. the important part is that you somehow indent or mark subblocks that correspond to subtrees in the other concrete syntax
13:11:43 <Cale> (That is, get away with English as far as it is readable to do so)
13:11:48 <RayNbow> I find Fitch-style easier to read than the following style: http://www.phil.cam.ac.uk/teaching_staff/Smith/LaTeX/resources/buss01.gif
13:12:11 <ski> mmorrow : "<mmorrow> ski: creating" ?
13:12:39 <roconnor> RayNbow: that is sequent style, which isn't (?) considered natural deduction
13:12:44 <a-a-h> \quit
13:12:53 <Cale> But yeah, if that's what Fitch-style is, it's probably the closest formal reflection of what I'm actually thinking while proving something.
13:12:55 * wli wonders if he can get someone to look at the description of the algorithm to see if they can figure it out any better than he.
13:12:56 <roconnor> RayNbow: http://upload.wikimedia.org/math/6/b/2/6b295391629fdde6bb87309dd476ea71.png
13:13:02 <mmorrow> ski: "using proofs as a tool for ensuring truth of propositions about objects which they may care about evaluating..."
13:13:04 <roconnor> that's what I think of when I think of natural deduction style
13:13:11 <f4hy> How would I take a list "abcdefg" and produce ("aceg","bdf")
13:13:19 <mmorrow> "...about objects which they may care about _creating_..." ;)
13:13:44 <gio123> ski:hi
13:13:50 <RayNbow> roconnor: what's the difference between the two pictures?
13:13:51 * roconnor tries to remember the solution to f4hy's question
13:14:04 <roconnor> RayNbow: the turnstile
13:14:19 <ski> roconnor : well, sequent style with (right-)introduction and (right-)elimination rules are sometimes called "natural deduction", and isn't that far from it .. the difference being that you note clearer exactly which free assumptions you have available in which subtree (instead of using `[A]' notation for "discharching" the assumption `A')
13:14:28 <RayNbow> roconnor: turnstile? \vdash?
13:14:40 <f4hy> roconnor: thanks. I hate how I keep getting stuck trying to solve these small little problems of list comprehensions and such.
13:14:53 <Cale> roconnor: The thing which really makes natural deduction what it is, I think, is the ability to create a context where the antecedent of an implication is simply regarded as true and prove that the consequent holds in order to show that the implication as a whole is true.
13:15:04 <roconnor> f4hy: I had a solution, but I remember someone else had a nicer solution last time it was asked.
13:15:20 <ski> Cale : i tend to prefer being both formal and brief, if possible
13:15:21 <Cale> roconnor: Any system which makes that easy can probably be regarded as natural deduction.
13:15:42 <roconnor> Cale: it is pretty natural to do that
13:16:00 <f4hy> roconnor: all I need is a push in the right direction I think.
13:16:09 <roconnor> Cale: but I think the key to natural deduction is to have Introduction/Elimination rules for each connective
13:16:24 <roconnor> Cale: rather than muddling them all together in arbitrary axioms
13:16:30 <ski> Cale : that's why when i see a useful proof pattern in informal proofs, i try to design a way to use the same idea in formal proofs as well, to achieve similar economy of expression
13:16:50 <ski> (Cale : e.g. the expression "it can be assumed without loss of generality that")
13:16:52 <Cale> I don't really care for excessive formality.
13:16:57 <mmorrow> wlog
13:17:25 <ski> if my expressions are formal, then i can use formal manipulation of them without constantly having to think about the intended semantics
13:17:34 <roconnor> f4hy: something like foo (a:as) = let (reca, recb) = foo as in (a:recb,reca)
13:17:46 <ski> i can think of it as an algebra manipulation, to massage the formula to the wanted form
13:18:09 <Cale> ski: But I'm usually only thinking of the intended semantics, and trying to write something down which conveys it.
13:18:45 <Cale> Rigourisability is a preferable substitute for actual rigour, but it's a concept that varies depending on one's audience.
13:18:58 <Cale> The smarter you can assume your audience to be, the less you have to write :)
13:18:59 <ski> mmorrow : ok .. but after they have created them, they may care about evaluating expressions that evaluate to such objects .. at least once in a while ;)
13:19:20 * roconnor is usually trying to convince a computer what he claims is true
13:19:28 <mmorrow> ski: what are expressions?
13:19:58 <Cale> Yeah, if you spend all your time convincing computers, humans will typically find your proofs obnoxious, I think :)
13:20:33 <vixey> It is great fun doing formal proofs
13:20:47 <vixey> mathematics in the normal sense is a completely different thing though, that is true
13:21:00 <ski> (Cale : but yes, those exam proofs were not formal. just closer to formal than what one might typically expect)
13:21:05 <Cale> yeah
13:21:23 <roconnor> humans are too easy to convince
13:22:18 <Cale> One thing that I try to avoid is giving names to more things than absolutely necessary. Some people tend to introduce a variable to refer to an object the moment it is mentioned, regardless of whether they ever refer to it again.
13:23:09 <ski> (mmorrow : syntactical descriptions that may be interpreted, given intepretations of "free variables")
13:24:08 <Cale> roconnor: Well, I tend to think that mathematicians have a pretty good ability to check that things are true. It's just that *communicating* formality is tiresome. People construct it in their heads in one way or another as it pleases them.
13:24:50 <ski> (Cale : i symphatize with wanting to write less when you (or the audience) are more familiar. my response to that is to try to design derived modes of expression that has similar economy)
13:25:07 <roconnor> The nice thing about writing it down formally in a computer is that then you can actually do stuff with it.
13:25:10 <Cale> ski: It's an interesting idea, if it can be made to work.
13:25:56 <mjrosenb> hey, anyone know about cross-compiling ghc?
13:25:56 <ski> (Cale : yes, giving names to things you don't need to use is irritating)
13:26:02 <vixey> what stuff roconnor?
13:26:50 <roconnor> vixey: currently, the primary use is to verify software.  But I hope there will be more interesting proof mining applications in the future.
13:27:21 <f4hy> Alright group, how would one write a function like magicfunction 2  gives (a,b) but magicfunction 3 gives (a,b,c)
13:27:37 <f4hy> since the types would be different
13:27:41 <roconnor> f4hy: that cannot be done in Haskell
13:27:42 <f4hy> is that not possible
13:27:47 <f4hy> roconnor: :-(
13:28:28 <Cale> f4hy: Think about what its type would be
13:28:36 <roconnor> f4hy: you can write a magic function that returns Either (a,b) (a,b,c)
13:28:38 <f4hy> Cale: magic type
13:28:42 <Cale> f4hy: hehe
13:29:03 <f4hy> I was just wondering if there was some deeper magic in haskell that would do that, that I simply have not learned yet
13:29:06 <ski> f4hy : what you want can be done in dependently typed systems. but haskell is not such a one
13:29:23 <Cale> You can approximate this with type level naturals and some typeclasses
13:29:28 <roconnor> Cale: forall n. rec n with 0 -> () | S m -> a*() end
13:29:39 <roconnor> well, even that isn't quite right
13:29:46 <ski> s/a/m/ ?
13:30:17 <f4hy> Alright so could the behvaior I siad be equivilent to [[a],[b]] and then [[a],[b],[c]] and then a seperate function to conver that to tuples or something?
13:30:28 <roconnor> ski: my magicfunction 2 returns an (a,a)  and magicfunction 3 returns an (a,a,a)
13:30:39 <vixey> well you can define
13:30:46 <vixey> data Binary where
13:30:50 <vixey> oops
13:30:52 <vixey> data Binary t where
13:30:57 <vixey>  Zero :: Binary (a,b)
13:31:01 <vixey>  One :: Binary (a,b,c)
13:31:12 <vixey> this is approximating a function
13:31:17 <vixey> tup 0 = (a,b)
13:31:20 <vixey> tup 1 = (a,b,c)
13:31:32 <mmorrow> you'll have to duplicate everything at the type-level
13:31:37 <vixey> so rather than writing magic : (n:N) -> tup n
13:31:44 <vixey> you write   magic :: Binary t -> t
13:31:51 <f4hy> hmm...
13:32:00 <vixey> the way that GADTs built up and get teared down can approximate type level computations
13:32:04 <ski> (Cale : btw, ideally there should exists a decidable procedure of checking that the use of these derived modes of expression is correct, as well as infer various parts that were not mentioned (like simple arithmetical manipulations, implicit arguments to functions, et.c. ..))
13:32:04 <f4hy> i think i sorta get what you mean
13:32:26 <roconnor> f4hy:  you may not want to involve yourself with GADTs just yet
13:32:50 <f4hy> roconnor: alright thanks for warning me!
13:33:07 <Cale> f4hy: Let me paste something :)
13:33:21 <f4hy> I tihnk I will just have my function give me [[a],[b]] or [[a],[b],[c]]... that works right?
13:33:26 <Cale> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4461#a4461
13:33:36 <Cale> This is not how you would normally want to do it :P
13:33:38 <roconnor> [[a],[b]] isn't a type
13:33:39 <f4hy> Tuples just seem too dificult in haskell
13:33:40 <ski> f4hy : by `[[a],[b]]' do you mean a type or an expression ?
13:33:41 <vixey> so GADTs don't in any way give you 'dependent types' or 'dependentl typed programming' like a lot of people have written online...
13:33:47 <f4hy> expressoin
13:33:52 <vixey> But they do give a (crap) way to do simple type level computations
13:34:08 <f4hy> The type would then be [[a]], yes?
13:34:14 <roconnor> vixey: well, the do give you types that depend on values
13:34:17 <roconnor> they do
13:34:30 <Cale> f4hy: Tuples are for when you have a fixed number of elements of possibly differing types. Also, in real Haskell programs it's typically considered bad style to use tuples that are larger than 3 elements.
13:34:32 <ski> f4hy : yes, if the type of `a',`b' and `c' is `a'
13:34:40 <Cale> (some would argue that pairs are all you should need)
13:34:54 <vixey> roconnor: I don't think they do -- all the type level computation happens only because of types
13:34:55 <ski> f4hy : but why not just use the expression `[a,b,c]' instead of `[[a],[b],[c]]' ?
13:35:34 <Cale> f4hy: If your tuples have more than a tiny number of components, you should be defining a new datatype instead.
13:36:12 <f4hy> ski: well ultimatly I am trying to get a function that does the following: foo 3 "ABCDEG" produces ["AD",BE","CG"]
13:36:25 <vixey> > transpose ["AD",BE","CG"]
13:36:26 <lambdabot>   <no location info>:
13:36:26 <lambdabot>      lexical error in string/character literal at chara...
13:36:26 <byorgey> where tiny = 2
13:36:31 <vixey> > transpose ["AD","BE","CG"]
13:36:32 <lambdabot>   ["ABC","DEG"]
13:36:37 <Cale> byorgey: Sometimes I don't mind 3 ;)
13:36:39 <vixey> > transpose ["ABC","DEG"]
13:36:41 <lambdabot>   ["AD","BE","CG"]
13:36:47 <vixey> f4hy there's something you can use
13:36:57 <vixey> transpose the problem into something easier
13:37:03 <byorgey> Cale: ok, fine.  But 4 is Right Out.
13:37:11 <roconnor> vixey: branches in a case expression have different types.  This is one of the essential properties of dependently typed programming
13:37:15 <f4hy> vixey: wait.. what does traspose do
13:37:24 <f4hy> @src transpose
13:37:24 <lambdabot> transpose []             = []
13:37:24 <lambdabot> transpose ([]   : xss)   = transpose xss
13:37:24 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
13:37:43 <Cale> f4hy: It's like a matrix transpose.
13:37:49 <byorgey> f4hy: if you think of a list of lists as a 2D matrix, it 'flips' the matrix
13:37:56 <Cale> > transpose [[1,2,3],[4,5,6],[7,8,9]]
13:37:57 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
13:38:12 <roconnor> > foldr (\(a,b) c -> (c:b,a)) ([],[]) "abcdefg"
13:38:12 <byorgey> f4hy: the source is not particularly enlightening, I'm afraid.
13:38:12 <lambdabot>       Occurs check: cannot construct the infinite type: b = ([b], t)
13:38:12 <lambdabot>        E...
13:38:15 <f4hy> Cale: well then for my magic function, if i say foo 7 "abcdefghijkl" transpose wone help
13:38:22 <Cale> f4hy: why?
13:38:24 <roconnor> @type foldr
13:38:26 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:38:30 <Cale> f4hy: What's it supposed to produce
13:38:31 <Cale> ?
13:38:33 <roconnor> > foldr (\c (a,b) -> (c:b,a)) ([],[]) "abcdefg"
13:38:34 <lambdabot>   ("aceg","bdf")
13:38:38 <roconnor> > foldr (\c (a,b) -> (c:b,a)) ([],[]) "abcdefgh"
13:38:39 <lambdabot>   ("aceg","bdfh")
13:38:48 <roconnor> @pl (\c (a,b) -> (c:b,a))
13:38:48 <lambdabot> (`ap` snd) . (. fst) . flip . ((,) .) . (:)
13:38:52 <roconnor> ugh
13:38:53 <f4hy> Cale: produce 7 lists
13:38:56 <Cale> > transpose ["abcdefg", "hijkl"]
13:38:57 <lambdabot>   ["ah","bi","cj","dk","el","f","g"]
13:39:03 <f4hy> each with 7 elements appart
13:39:18 <f4hy> wait so you break it into groups of 7 and then tranpose... awesome
13:39:18 <vixey> and 7 handbags with 7 spiders in each one
13:39:25 <vixey> and each spider with 7 legs
13:40:06 <ski> > transpose' [[1,2,3],[4,5,6],[7,8,9]]  where transpose' = foldr (zipWith (:)) (repeat [])
13:40:07 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
13:40:08 <roconnor> http://www.worleygig.com/wp-content/uploads/2008/11/spider.jpg
13:40:25 <vixey> roconnor: Yeah I see what you mean there each case branch having a different type -- then again each branch really has the same type just a different equality proof is being destructed in each branch
13:40:26 <byorgey> @type let swap (x,y) = (y,x) in swap . second . (:)
13:40:27 <lambdabot>     Couldn't match expected type `(,)' against inferred type `(->)'
13:40:27 <lambdabot>     Probable cause: `.' is applied to too few arguments
13:40:27 <lambdabot>     In the second argument of `(.)', namely `second . (:)'
13:40:32 <Cale> It troubles me that 'where' works there.
13:40:40 <vixey> did you draw this :p
13:40:59 <Cale> vixey: No, that's famous :)
13:40:59 <roconnor> it's a "famous" internet drawing
13:41:07 <f4hy> The 7-spider is famous indeed
13:41:26 <ski> Cale : i find it nice to first give the main expression, and after that the details, when explaining something to someone
13:41:28 <f4hy> spiders are ofcourse indexed by number of legs, so you can have an n-spider
13:41:43 <vixey> Cale, oh yeah, these type families also let you do type level computations
13:41:57 <roconnor> vixey: I'm not sure what you mean by same type but different equality proof.  They seemed like different types when I last used GADTs for this purpose.
13:41:57 <Cale> http://www.27bslash6.com/overdue.html
13:42:23 <Cale> ski: Yes, but 'where' is not part of the expression syntax
13:42:30 <ski> right
13:42:33 <Cale> ski: So the fact that the bot accepts it worries me.
13:42:34 <vixey> roconnor: I mean both branch are  Binary n  but in the left you have {n = Z} and in the right you have {n = S Z} for example
13:43:10 <ski> Cale : probably the bot evaluates something like `do let {it = <expression>}; printIt it' ..
13:43:40 <Cale> ski: Yeah, so is an injection attack possible? :)
13:43:54 <f4hy> Transpose in a very smart solution to my problem, thanks everyone. Never thoght of it in that light
13:44:20 <roconnor> vixey: okay
13:44:39 <Cale> "Thankyou for contacting me. I am currently away on leave, traveling through time and will be returning last week."
13:44:46 <ski> Cale : it used to be the case that `where' worked like this in lambdabot. then after some change someone did, it didn't (sadly :) work anymore. then later apparently after a new change, it works again
13:47:17 <monadic_kid> @botsnack
13:47:17 <lambdabot> :)
13:47:17 <lunabot>  :)
13:48:29 <ski> @unmtl ContT o (State s) a
13:48:29 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
13:48:30 <ski> @unmtl StateT s (Cont o) a
13:48:30 <lambdabot> s -> (a -> s -> o) -> o
13:49:11 <ski> user317 : i believe it's the latter variant there you'd want, when combining continuations with state
13:51:11 <McManiaC> @pl \x -> "foo" ++ show x
13:51:11 <lambdabot> ("foo" ++) . show
13:52:32 <da-x> anyone got a link to a good paper that shows how type inference in haskell works?
13:53:50 <mjrosenb> da-x: look for hindley-milner and unification
13:54:06 <da-x> mjrosenb: okay thanks
13:54:28 <mjrosenb> either of those really will probably give a good overview
13:56:01 <vixey> type inference in haskell is so complex nobody knows how it works
13:56:44 <mjrosenb> vixey: i came up with an awesome type inference algorithm
13:56:57 <mjrosenb> for every variable that you bind
13:57:06 <mjrosenb> choose a random type
13:57:10 <vixey> lol
13:57:14 <mjrosenb> if it typechecks
13:57:14 <mjrosenb> YAY
13:57:17 <mjrosenb> if it doesn't
13:57:22 <mjrosenb> destroy the universe
13:57:23 <vixey> GOTO BEGINNING
13:58:10 <mjrosenb> this has the side-effect that it it *impossible* to write a program that does not typecheck
13:59:16 <Asztal> it could do an A* search based on how many type checking errors are generated :)
13:59:49 <mjrosenb> right, but then you can have programs that don't typecheck
14:00:11 <mmorrow> > let x = 5 in (main,(x,y)) where y = 10; main = 42
14:00:12 <lambdabot>   (42,(5,10))
14:00:38 <vixey> > let in x where x = 3
14:00:39 <lambdabot>   3
14:00:43 <vixey> > x where x = 3
14:00:44 <lambdabot>   3
14:00:58 <vixey> > x where x = let in 3
14:01:00 <lambdabot>   3
14:01:15 <liyang> Better still, make use of a million monkeys on a million typewriters, and somehow involve multiple best-of-breed OCR solutions too.
14:01:17 <Asztal> > let in Nothing
14:01:18 <lambdabot>   Nothing
14:02:22 <ski> > () where
14:02:23 <lambdabot>   ()
14:02:49 <vixey> hehe
14:03:02 <vixey> > () where where where
14:03:02 <lambdabot>   <no location info>: parse error on input `where'
14:05:10 <mmorrow> > case let in () of _ -> () where
14:05:11 <lambdabot>   ()
14:06:39 <Peaker> > case
14:06:40 <lambdabot>   <no location info>: parse error on input `;'
14:06:49 <Peaker> > case undefined of
14:06:49 <lambdabot>   <no location info>: parse error on input `}'
14:08:41 <vixey> > mysterious case of the _ where
14:08:42 <lambdabot>   <no location info>: parse error on input `case'
14:10:10 <wli> mmorrow: The applications of solving systems of polynomial equations are enormous.
14:11:29 <wli> mmorrow: The conditions for C^d continuity for piecewise rational functions give quadratic equations for the coefficients.
14:12:29 <mmorrow> wli: how much overlap between linalg and algeom is there in application areas?
14:13:03 <mmorrow> wli: hmm
14:13:05 <wli> mmorrow: No idea. I'm just trying to solve systems of equations I get from various places.
14:13:34 <da-x> hey Peaker, wli
14:14:13 <wli> da-x: http://wli.pastebin.com/m2401575d
14:14:35 <da-x> wli: yes, I've seen this, thanks
14:14:59 <wli> da-x: Is/was that a helpful demonstration of StateT?
14:15:14 <da-x> wli: not only StateT
14:15:40 <wli> da-x: As long as it was helpful.
14:15:48 <Peaker> da-x, hey
14:16:27 <wli> mmorrow: The main reason is to get decent numerical accuracy when solving large systems of polynomial equations.
14:16:39 <da-x> wli: I remember you were into linux kernel hacking awhile back. are you concentrating mostly on haskell these days?
14:17:02 <wli> da-x: Linux kernel hacking is still my day job.
14:17:12 <mjrosenb> wli: where do you work?
14:17:26 <wli> mjrosenb: Oracle
14:17:59 * mjrosenb did not apply for oracle
14:18:13 * mjrosenb did not know that oracle had people hacking on linux
14:18:25 <mjrosenb> *now* i know about ocfs + others
14:21:07 <Peaker> wli, is Oracle any good?
14:22:37 <da-x> Peaker: wli used to work in IBM, so he can compare :)
14:22:49 <da-x> (da-x and Peaker work in IBM)
14:27:26 * mjrosenb *did* apply for a job at ibm
14:27:47 * Phyx- hasn't had time to apply for anything yet
14:29:46 * bos31337 had a whole lot of fun speaking to Erlang people about Haskell this morning
14:31:04 <Peaker> wli, so how do Oracle and IBM compare? :)
14:31:30 <juturnas> If you have a function using do notation with a let binding in the middle of it, how would you change it to use the >> and >>= operators?
14:32:52 <Saizan> @undo do a <- x; let foo = a; y
14:32:52 <lambdabot>  Parse error at end of input
14:33:02 <Saizan> @undo do a <- x; let {foo = a}; y
14:33:02 <lambdabot> x >>= \ a -> let { foo = a} in y
14:36:05 <juturnas> I'm just trying out parsec, doing a tutorial.. trying to parse a quoted string: parseString = (char '"') >> many (noneOf "\"") >>= (\x -> (char '"') >> return x)
14:36:13 <juturnas> would that work?
14:37:07 <Saizan> yup
14:37:22 <Saizan> well for some definition of quoted string
14:37:22 <da-x> Peaker: I downloaded some books
14:37:27 <Berengal> Why not just try it out?
14:37:41 <Saizan> i.e. "foo\"bar" will fail, even if that's usually valid
14:37:55 <da-x> Peaker: namely - Implementing Functional Languages - a tutorial (296 pages)
14:38:11 <Saizan> or better, it'll parse foo\
14:38:24 <juturnas> Ya, thanks
14:39:08 <juturnas> I'm not too worried about that now, just trying this out.  I was more concerned with parseString passing on the result of the "many (noneOf "\"")" expression
14:40:22 <Peaker> da-x, cool
14:40:42 <Peaker> da-x, I made some progress on MList but I have so little time to work on interesting stuff :(
14:41:31 <leimy> @users
14:41:31 <lambdabot> Maximum users seen in #haskell: 658, currently: 626 (95.1%), active: 20 (3.2%)
14:41:54 <RayNbow> hmm, is there an easy way to transform (StateT s m a) into (StateT (t,s) m a)?
14:43:36 <vixey> :t fmap :: (a -> b) -> (StateT s m a) -> (StateT s m b)
14:43:37 <lambdabot>     Could not deduce (Monad m) from the context ()
14:43:37 <lambdabot>       arising from a use of `fmap' at <interactive>:1:0-3
14:43:37 <lambdabot>     Possible fix:
14:44:51 <luite>  RayNbow: what should the put and get functions do?
14:44:58 <Saizan> ?mapState
14:44:58 <lambdabot> Unknown command, try @list
14:45:05 <Saizan> ?type mapState
14:45:05 <lambdabot> forall a s b. ((a, s) -> (b, s)) -> State s a -> State s b
14:45:13 <Saizan> mh, no
14:45:34 <roconnor> RayNbow: http://hackage.haskell.org/packages/archive/data-accessor/0.2.0.2/doc/html/Data-Accessor-MonadState.html#v%3AliftT
14:45:36 <roconnor> there you go
14:45:46 <roconnor> liftT :: Monad m => T r s -> StateT s m a -> StateT r m a
14:46:19 <roconnor> T is their type of accessor functions or Lenses
14:46:29 <luite> hm, interesting
14:46:52 <Saizan> ?type \m -> do (t,s) <- get; (a,s') <- runStateT m s; put (t,s'); return a
14:46:53 <lambdabot> forall (t :: * -> *) t1 s a. (MonadState (t1, s) t) => StateT s t a -> t a
14:46:57 <Apocalisp> Trying to make sense of this http://okmij.org/ftp/Haskell/ShiftResetGenuine.hs
14:46:57 <roconnor> You will want one of these instances: http://hackage.haskell.org/packages/archive/data-accessor/0.2.0.2/doc/html/Data-Accessor-Tuple.html
14:47:08 <Saizan> or use that function ^^^
14:47:12 <roconnor> first or second
14:47:34 <Apocalisp> Oleg's solution seems much simpler than http://cpansearch.perl.org/src/AUDREYT/Perl6-Pugs-6.2.13/src/Pugs/Cont/CC_2CPST.hs
14:47:39 <RayNbow> :t Data.Accessor.MonadState.liftT Data.Accessor.Tuple.first
14:47:39 <lambdabot> Couldn't find qualified module.
14:48:06 <Saizan> Apocalisp: they are not equivalent
14:48:09 <Peaker> Data.Accessor should have been an arrow..
14:48:22 <roconnor> Peaker: it still can be?
14:48:22 <Saizan> Apocalisp: the latter provides multiple prompts
14:48:35 <Peaker> roconnor, yeah :)
14:48:39 <Apocalisp> Saizan: can newPrompt be written for ShiftResetGenuine?
14:49:09 <Saizan> Apocalisp: no, afaik
14:49:47 <Apocalisp> Saizan: OK, thanks a bunch.
14:49:48 <roconnor> Peaker: Actually, I don't think there is a pure function
14:50:01 <roconnor> Peaker: Data.Accessor is just a catagory
14:50:14 <Apocalisp> Saizan: Do you know if there's a generic zipper library that doesn't rely on template haskell?
14:50:21 <Peaker> roconnor, Almost nothing of interest is an arrow that has "pure"..
14:50:36 <roconnor> that's why Arrows are the dumb
14:50:54 <Peaker> roconnor, functions, that single parser example, and Yampa are the only things I'm aware of (I think Yampa might have trouble with it as well)
14:51:18 <roconnor> Peaker: Kleisli and CoKleisli
14:51:18 <Saizan> Apocalisp: i'm not aware of one, even using TH
14:51:20 <Peaker> Instead of "pure", arrows could have "swap" and "fst" and "snd"
14:51:32 <Peaker> roconnor, What's CoKleiskli?
14:51:40 <roconnor> w a -> b
14:51:42 <roconnor> for a comonad w
14:51:45 <Peaker> ah
14:51:58 <Apocalisp> Saizan: There's http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zipper
14:52:03 <Peaker> if arrows had swap/fst/snd instead of "pure" - I think that could work?
14:52:28 <roconnor> Peaker: all this is available in category-extras
14:52:39 <Saizan> Apocalisp: ah, nice
14:52:53 <Apocalisp> multirec uses TH though
14:53:12 <mreh> So has anyone come down with swine flu yet?
14:53:20 <vixey> haskell-blah
14:53:29 <astrolabe> When I use read file, I'm getting GHC.IOBase.IOException (GHC.IOBase.IOError Nothing GHC.IOBase.EOF ....).  Is that correct behaviour? and how do I stop it?
14:53:39 <Apocalisp> mreh: Some swine flew past my window just now.
14:54:04 <astrolabe> er readFile
14:54:10 <mreh> it has mutated
14:54:20 <Peaker> mreh, #haskell-blah channel
14:54:30 <monadic_kid> you guys read that the swine flu virus has mutated right? http://bouncewith.me.uk/europe/8027043.htm
14:55:01 <roconnor> monadic_kid: take it to #haskell-zombies
14:55:13 <mreh> :D
14:59:40 <mreh> what "other" type of polymorphism is there?
14:59:51 <mreh> parametric and...
15:00:03 <dolio> Subtype, ad-hoc...
15:00:08 <mreh> right
15:00:23 <mreh> i haven't done type classes yet
15:00:34 <mreh> deriving Blah, etc, non?
15:01:50 <monadic_kid> what's the question?
15:02:27 <mreh> inheritence in Haskell is done using "deriving"
15:02:46 <mreh> is it not
15:02:53 <RayNbow> hmm, is there a difference between Control.Monad.State.StateT and Control.Monad.Trans.State.Lazy.StateT?
15:03:11 <skorpan> mreh: the notion of inheritance from OO doesn't really exist in haskell
15:03:16 <dolio> deriving is for having the compiler automatically generate instances of certain type classes in particularly easy cases.
15:03:31 <monadic_kid> mreh: no the keywword deriving gives you automatic type class instances for data types
15:03:46 <monadic_kid> mreh: not for all of them just a small set
15:04:08 <skorpan> "deriving Show" after your data type Hello gives you a default function show :: Hello -> String
15:04:52 <monadic_kid> mreh: type classes where originally devised to solve the zombification process induced from type inferred overloadding
15:05:23 <mreh> zombification?
15:05:32 <monadic_kid> just kidding
15:05:36 <mreh> of the programmer?
15:05:43 <persica> Howdy, just saw #haskell mentioned in Bryan's Haskell slides.  Remembered I should connect. :D
15:06:00 <Berengal> Haskell has the zombie flu now?
15:06:01 <mreh> abon all hope ye who enter here
15:06:19 <persica> haskell gives me hope that there is something better out there.
15:06:29 <monadic_kid> of the unification algorithm for type  inference
15:06:46 <Berengal> GUI programming is still tedious in any language, even haskell...
15:06:47 <roconnor> RayNbow: apparently not
15:06:53 <roconnor> RayNbow: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
15:07:01 <Twey> Berengal: Glade FTW
15:07:10 <skorpan> if i have "data A = A Int String" and "xs :: [A]" and i want to find all elements in "xs" which share the Int with some other element in that list, how would i do that?
15:07:19 <persica> Berengal: Cross-platform gui program even more so.
15:07:41 <vixey> skorpan does not make sense
15:07:48 <Berengal> Twey: Yeah, that's my last hope. I'm still recovering from my last GUI venture so it might be some time until I dare try.
15:07:53 <monadic_kid> mreh: basically type-classes provide ad-hoc polymorphism in a type infered language in a less ad-hoc manner
15:07:58 <persica> vixey: He wants to search for duplicates of the int inside a data structure
15:08:03 <Twey> Glade's not that scary
15:08:15 <mreh> Java swing is alright
15:08:16 <skorpan> persica: yes, and i want a list of those elements which have duplicates
15:08:33 <Twey> :t intersect
15:08:34 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:08:35 <Twey> :t intersectBy
15:08:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a] -> [a]
15:08:42 <skorpan> Twey: thanks, i'll look into those
15:08:50 <vixey> > "foobarr" `intersect` nub "foobarr"
15:08:51 <lambdabot>   "foobarr"
15:08:59 <vixey> lol
15:08:59 <skorpan> yes, like that :)
15:09:09 <Twey> intersectBy (comparing `on` \(A a b) -> a) lst lst
15:09:09 <skorpan> uh what
15:09:10 <vixey> > "foobarr" \\ nub "foobarr"
15:09:11 <lambdabot>   "or"
15:09:23 <persica> It's going to be O(n^2) though, yeah? Or is there a better trick?
15:09:23 <skorpan> vixey: thanks :)
15:09:26 <skorpan> :t (\\)
15:09:27 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:09:34 <Saizan> equating, rather than comparing
15:09:40 <vixey> youneed a liar of an Eq instance
15:09:41 <skorpan> persica: doesn't matter for this application, but if there's a better way...
15:09:53 <vixey> instance "Eq" A where
15:09:54 <skorpan> vixey: yes, i have that readily available :)
15:10:01 <vixey>  A i _ == A j _ = i == j
15:10:01 <Saizan> you could construct a Map Int [A] to get better asymptotics probably
15:10:17 <RayNbow> roconnor: I have an expression that according to the type checker has type C.M.T.S.L.StateT a b c, but when I use the type annotation StateT a b c, it complains
15:10:26 <persica> skorpan: I don't know off the top of my head.  And it's always a tradeoff between simplicity of execution verses simplicity of code.
15:10:41 <Berengal> Or a Map A Bool, if A is in Ord
15:11:08 <Berengal> Then you could foldr insertWith something or other
15:11:15 <ErhardtMundt> hello
15:11:16 <Saizan> ?type M.toList . M.fromListWith (++) . map (\a@(A i _) -> (i,[a]))
15:11:17 <lambdabot> Not in scope: data constructor `A'
15:11:28 <ErhardtMundt> Saizan: prot
15:11:38 <Saizan> hi
15:11:57 <RayNbow> ah wait, roconnor... Accessor seems to use http://hackage.haskell.org/packages/archive/transformers/0.1.4.0/doc/html/Control-Monad-Trans-State-Lazy.html#t%3AStateT
15:12:12 <ErhardtMundt> i'm looking for documentation about xmonad/xmobar
15:12:23 <ErhardtMundt> wikis are not so verbose
15:12:48 <Saizan> for xmonad you can look at the haddock documentation, it has a lot of content
15:16:17 <mreh> do i need to learn the theory of languages to really program?
15:16:25 <vixey> yes
15:16:33 <monadic_kid> lol
15:16:44 <mreh> i seem to be communicating quite well now
15:16:54 <Peaker> mreh, no, you can program (badly) without knowing much theory
15:17:06 <mreh> :(
15:17:12 <mreh> well how much are we talking
15:17:15 <vixey> I don't now what is "theory of languages" :p
15:17:22 <vixey> It just sounds liek you want to learn it but you need a nudge
15:17:42 <monadic_kid> well the closet that would be is the theory of computation
15:17:43 <persica> mreh: it's not so much knowing the "theory of languages" as having the experience to develop an intuition about how they work.
15:17:55 <mreh> well, it gets thrown into interesting conversations as topics
15:17:59 <vixey> theory of computation like finding intersection of REGEX?
15:18:07 <persica> It's all about experience.  "knowing the theory" just means you've been exposed to more stuff.
15:18:37 <Olathe> Are there any easy ways to get [0, 0, 0, 0], [0, 0, 0, 1], ... [1, 1, 1, 1] from [0, 1] ?
15:18:45 <persica> Heck, I didn't realize strong typing was such a good thing until I ran into Haskell.  I always thought it was a necessary evil.
15:18:55 <vixey> Olathe: well what do you get from [0,1,2]?
15:19:08 <Olathe> The same thing in ternary.
15:19:09 <dolio> Also, what comes after [0, 0, 0, 1]?
15:19:14 <vixey> the same thing ??
15:19:26 <Olathe> It's basically the binary digits for everything from 0 to 15.
15:19:37 <vixey> Umm..
15:19:43 <vixey> why do they have length 4?
15:19:49 <vixey> it's hard coded in?
15:19:58 <dolio> > replicateM 4 [0,1]
15:19:59 <lambdabot>   [[0,0,0,0],[0,0,0,1],[0,0,1,0],[0,0,1,1],[0,1,0,0],[0,1,0,1],[0,1,1,0],[0,1...
15:20:01 <Olathe> I want to test a sorting algorithm.
15:20:05 <Olathe> Ahh, thanks :)
15:21:15 <Baughn> Is it at all safe for me to /catch/ pattern-match failures?
15:22:44 <Baughn> (And if so, could I possibly catch /just/ pattern-match failures?)
15:23:36 <monadic_kid> is this in a monadic expression?
15:23:45 <dolio> The new exception library can catch just pattern match failures.
15:24:34 <dolio> Whether that's "safe" is a contested issue.
15:25:00 <Baughn> Oh, I missed the PatternMatchFail type
15:25:34 <Baughn> Don't suppose you could direct me to discussions on the point? (Well, checking the cafe archives now)
15:26:03 <roconnor> RayNbow: ya, there is a proliferation of Monad Libraries causing interoperability issues. :(
15:26:04 <Peaker> Baughn, Why not use explicit error types like Either or ErrorT?
15:26:23 <Baughn> Peaker: That probably /would/ be the best idea
15:26:25 <dolio> Well, a naive semantics of such exceptions leads you to conclude that you're writing non-monotonic functions.
15:26:52 <Baughn> It's just, I'm trying to implement something like the erlang IPC system
15:26:55 <dolio> And you can observe evaluation order.
15:27:17 <Baughn> Where users can specify any number of patterns, and incoming messages are matched against them in turn, being discarded if none match
15:28:01 <Baughn> Hm. I suppose I could.. in monads, fail is called if they fail to match, right?
15:28:14 <Peaker> Baughn, in do blocks specifically, I think
15:28:42 <Baughn> Sure, but then I could at least provide that
15:29:16 <dolio> But, as I understand it, the paper introduction the exceptions has a more complex semantics in mind, such that the argument that they are "impure" no longer necessarily holds.
15:29:38 <dolio> But that's all technical stuff. If you're asking if bad things will happen, the answer is probably "no."
15:30:32 <mreh> why the need separate types from type synnonyms in the grammar?
15:31:08 <mreh> too many Ns
15:31:37 <lament> cause they're different?..
15:32:02 <mreh> isn't a synonym a type constructor of arity 0
15:32:12 <vixey> no
15:32:21 <Baughn> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4463#a4463 <-- This is the sort of code I'd /like/ to write. How close do you think I can get?
15:33:38 <dolio> Oh, you're not talking about failures in pure code.
15:34:21 <vixey> Baughn: maybe that could be done with a different implementation of fai
15:34:23 <vixey> fail*
15:34:29 <Baughn> dolio: Well, no. recv is normally a network operation, so it's inherently impure anyway
15:34:39 <Baughn> @type fail
15:34:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
15:35:11 <vixey> that would be a pretty awful way to do it though..a
15:35:30 <Baughn> So I'd be building on top of IO.. the one weirdness, I suppose, is that this particular variant of fail should (in /some/ cases, namely when it's caused by a recv) restart the recv instead of throwing any exceptions or quitting it
15:36:27 <Baughn> The alternative is to use explicit key/value messaging, but this is so much /nicer/
15:36:31 <dolio> It might have to be something more like "restart $ do Foo 2 x <- recv ..."
15:36:50 <Baughn> I can live with that
15:36:59 <dolio> Don't you send to pids in Erlang?
15:37:03 <Baughn> more like runRestartableThingy
15:37:24 <Baughn> ..probably
15:37:59 <daf> hmm. I want to chain together IO Either actions. how should I do this?
15:37:59 <Baughn> @instances Monad
15:37:59 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:38:04 <Baughn> @instances MonadIO
15:38:05 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
15:38:06 <daf> essentially, I want the Either monad, but with IO
15:38:21 <Baughn> Hm. I thought there was an EitherT..
15:38:25 <Saizan> Baughn: if you can't work it out with some monadic magic there's always QuasiQuoting to introduce arbitrary syntax
15:38:30 <daf> there is, in category-extras
15:38:36 <Saizan> Baughn: it's ErrorT
15:38:41 <daf> but it doesn't seem to work how I'd expect
15:39:00 <Saizan> ?unmtl ErrorT e IO a
15:39:00 <lambdabot> IO (Either e a)
15:39:06 <Saizan> though you need Error e =>
15:39:19 <ski> yes .. very irritating
15:39:23 <daf> well, it's Either String for now
15:39:30 <daf> so that's not a problem
15:39:49 <ski> (not a problem for *you* you mean ..)
15:40:00 <daf> yes
15:40:18 <daf> I'm happy to let someone else solve the general case :)
15:42:23 <daf> ErrorT seems to be for translating fail to Left
15:43:18 <Saizan> if you mean the Error e => constraint then yes
15:43:29 <roconnor> there are other ErrroTs out there
15:45:31 <daf> is the answer to "I want to compose IO Either" "don't"?
15:45:43 <daf> or "write your own monad (transformer)"?
15:49:30 <astrolabe> In the ghc manual, it says that :trace remembers 50 steps, but it only seems to remember 20 for me.  Can I fix this?
15:50:01 <edwardk> hrmm. I think I might actually have a nice way to build a parallel applicative earley-like parser
15:52:54 <Saizan> daf: what's the problem with ErrorT e IO ?
15:57:04 <ehird> what's the unicode for _|_?
15:59:07 <daf> Saizan: the problem is that I was using it wrong :)
15:59:08 <Twey> U+22A5 UP TACK
15:59:19 <Twey> 
15:59:21 <ehird> thanks
15:59:27 <Twey> Welcome
16:00:49 <McManiaC> @pl \x -> foo (Bar n x)
16:00:49 <lambdabot> foo . Bar n
16:01:27 <mk15> Hi I have a problem with HOpenGL where i'm using an instance of type Name (should be a number) and need to cast it to an integer. "fromIntegral" does not work
16:02:58 <jeffwheeler> Defining weird instances of Num, e.g. instance Num [Integer], can do weird things . . .
16:03:02 <jeffwheeler> E.g., segmentation fault
16:03:27 <Saizan> i don't think that's supposed to happen, jeffwheeler
16:03:45 <jeffwheeler> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4464#a4464
16:04:04 <jeffwheeler> Err, the second half of that should have been the ghci, one second
16:04:15 <Saizan> mk15: does :info Name shows an instance of Integral ?
16:04:24 <jeffwheeler> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4464#a4465
16:04:54 <jeffwheeler> I know it's a very wonky thing to do, but it's sometimes fun to try weird things
16:05:41 <Saizan> jeffwheeler: ah, that's not because of your instance, but of ^C
16:05:51 <jeffwheeler> Err, yeah.
16:06:03 <mk15> Saizan: it shows "newtype Name = Name GLuint", however :info GLuint shows "type GLuint = GHC.Word.Word32"
16:06:33 <Saizan> there's a bug with editline and the new signal handling code
16:06:53 <jeffwheeler> Oh, I see. Well, then it's that problem combined with the fact that this code never finishes.
16:07:12 <Saizan> mk15: so i think you're supposed to pattern match on the Name constructor and then use fromIntegral on the content
16:08:09 <edwardk> jeffwheeler: Num a => Num [a] isn't weird its a common way to implement polynomials
16:08:48 <jeffwheeler> edwardk: ah, neat; I've done Num String in the past to support "1" + 2, just for the fun of it, before, which surely is wonky
16:09:06 <FliPPeZ> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2294#a2294
16:09:09 <Twey> What would you folks consider a good solution for a non-pure function to generate unique IDs?
16:09:11 <FliPPeZ> Would that be a good solution?
16:09:15 <mk15> Saizan: thanks
16:09:29 <Twey> I'm thinking just an incrementing IOVar
16:09:45 <Twey> But I'm always hesitant to use them :-P
16:09:53 <edwardk> Twey: fresh = do x <- get; put (x + 1); return x
16:10:05 <kpreid> Twey: do the IDs need to be numbers? Data.Unique
16:10:08 <edwardk> and then hide the details of your state
16:10:36 <FliPPeh> Once I implement those functions, will that be a good way to build up that arithmetic type? http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2294#a2294
16:10:37 <Saizan> FliPPeh: i'd probably use a parser library to define parseIrcLine, however have you looked at the irc package on hackage?
16:10:39 <FliPPeh> Oh
16:10:39 <Twey> edwardk: Wouldn't that mean that the user would need to runState for all new instances?
16:10:41 <edwardk> i'm also particularly fond of control.comonad.supply
16:10:47 <FliPPeh> Thought my last message didn't arrive
16:11:07 <kpreid> Twey: Data.Unique needs no IORef and no extra monad
16:11:09 <FliPPeh> Saizan: I sadly don't like using any packages or pre-made libraries :/
16:11:19 <FliPPeh> It feels awkward using code I don't know about
16:11:25 <FliPPeh> DIY.
16:11:27 <Twey> kpreid: Looks nice
16:11:34 <Twey> I'm not quite sure how to use it, though
16:11:35 <Saizan> you can read it and then know about it :)
16:11:48 <Saizan> it's pretty short anyway
16:11:51 <FliPPeh> I've always written my own IRC Line parsing and all other managment
16:11:52 <edwardk> twey: well you already asked for non-pure, so just starting up the supply in an StateT Int IO .. - is a reasonably pure approach. Data.Unique exists but its a terrible hack
16:11:54 <FliPPeh> In any language :)
16:11:56 <c_wraith> FliPPeh: How do you use computers, then?  Did you fab your own hardware from your own designs, and write your own OS to run on it?
16:11:56 <vixey> Data.Unique uses an IORef internally doesn't it
16:11:58 <FliPPeh> Now I want it in Haskell
16:12:12 <Saizan> FliPPeh: well, you can take inspiration from it anyway
16:12:16 <FliPPeh> Actually I built up my own linux once
16:12:20 <FliPPeh> :/
16:12:49 <Twey> edwardk: Yes, but that means that the user has to bother with StateT, rather than just hiding it in the function
16:12:49 <Saizan> however i'd work with ByteString, use attoparsec, and the write something like:
16:12:54 <edwardk> c_wraith: "never again" =)
16:13:07 <edwardk> twey: then Data.Unique is the canonical solution
16:13:17 <FliPPeh> Also I'm learning Haskell, and don't really know much about it
16:13:20 <Saizan> parse (IRCLine <$> getFrom <*> getCommand <*> getParams <*> getMessage) s
16:13:29 <FliPPeh> I found that writing some parser in a language really helps me getting the grasp of it
16:14:07 <edwardk> twey: or you can do the 'make up a caf with an unsafePerformIO $ newIORef ...' and then make an IO function that keeps updating it using the atomic io ref stuff
16:14:08 <RayNbow> @where hpaste
16:14:08 <lambdabot> http://hpaste.org/
16:14:08 <Twey> edwardk: Looks good, thanks
16:14:24 <vixey> @hackage Data.Unique
16:14:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.Unique
16:14:25 <edwardk> but thats easy to screw up as well
16:15:10 <Twey> FliPPeh: For pedagogic purposes, OK... but Network.IRC really isn't scary.  It's only three files, and they're pretty short  you can get a good grasp of them quickly.
16:15:27 <FliPPeh> Alright, I'll have a look at it
16:15:47 <RayNbow> luite, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4467 <-- feel free to improve :p
16:16:29 <FliPPeh> @where Network.IRC
16:16:29 <lambdabot> I know nothing about network.irc.
16:16:31 <FliPPeh> Too bad
16:17:05 <RayNbow> roconnor: thanks for showing liftT btw :)
16:17:07 <FliPPeh> kay found it
16:17:33 <eu-prleu-peupeu> hi
16:17:51 <roconnor> RayNbow: how are you dealing with the incompatible Monad libs?
16:18:32 <RayNbow> roconnor: by using the one that Accessor is using :p
16:19:22 <yav> do we have any darcs-to-git experts here?
16:19:51 <hs2m> Hi.. anyone help me with tagsoup?
16:20:29 <roconnor> RayNbow: fair choice
16:20:58 <hs2m> basically i have a tag like this [TagOpen "img" [("id","image"),("class","image"),("src","http://imageurl.png"),("title","image title "),("alt","")]] how do i just extract the src as a string?
16:21:02 <RayNbow> oh roconnor... perhaps I should have used http://hackage.haskell.org/cgi-bin/hackage-scripts/package/data-accessor-mtl instead?
16:21:26 <FliPPeh> Haskell is about describing what stuff is, and not how to make it, right?
16:21:49 <roconnor> RayNbow: oh, I forgot about that
16:22:05 <FliPPeh> So instead of going on and building up an object step by step like you could do in an imperative language, I have to build up a data type in one line?
16:22:22 <roconnor> RayNbow: switching monad lib's is probably best if you don't really care which one you are using
16:24:55 <RayNbow> roconnor: ah ok
16:25:23 <RayNbow> but now I'm going to get some sleep... gotta get up early the next morning :p
16:25:26 <RayNbow> g'night :)
16:25:33 <mmorrow> FliPPeh: imagine a rubix-cube crossed with a slinky. so you can rotate it rotate it around, or stretch it, then rotate, then contract. fmap, zip, zipWith, unzip, foldl, foldr, fst, snd, uncurry, curry
16:25:58 <roconnor> one of mtl's ContT instances is broken, so I actively discourage using it
16:26:08 <mmorrow> roconnor: which?
16:27:41 <user317> how do i yeild using Monad.Cont?
16:28:25 <wli> mmorrow: Want to see what I'm working off of for solving systems of polynomial equations?
16:28:35 <edwardk> roconnor: whether callCC in mtl is broken is a matter of perspective ;)
16:28:56 <user317> oh i think i see
16:28:57 <hs2m>  i have a tag like this [TagOpen "img" [("id","image"),("class","image"),("src","http://imageurl.png"),("title","image title "),("alt","")]] how do i just extract the src as a string?
16:29:36 <povman> @seen conal
16:29:36 <lambdabot> I saw conal leaving #haskell and #ghc 3m 10d 18h 15m 40s ago, and .
16:30:40 <Saizan> hs2m: let [TagOpen _ attrs] = .. in lookup "src" attrs
16:30:50 <mmorrow> roconnor: (if you're talking about StateT s (Cont r) a, mtl's callCC corresponds to aborting and keeping a dirty state, and monadLib's callCC for the same is abort with state rollback. make both available and you have a transactional state monad where you can do `elem` [abort + rollback state, abort + dirty state, return result + rollback state, return result + commit state]
16:30:50 <eu-prleu-peupeu> lambdabot is on acid
16:30:54 <roconnor> edwardk: yep.  There is the right perspective, and the wrong prespective. :)
16:31:01 <Saizan> hs2m: there might be a nicer combinator in the library though
16:31:02 <edwardk> roconnor: hah
16:31:15 <mmorrow> wli: yes
16:31:17 <roconnor> mmorrow: IIRC it is the MonadState instance of ContT
16:31:25 <hs2m> Saizan: Thanks, i'll try
16:31:28 <roconnor> mmorrow: but it might be the MonadCont instance of StateT
16:31:30 <edwardk> roconnor: i'd rather have access to both to be honest. i think perhaps the right answer is to define a second MonadCont like class or to give the two different names
16:31:49 <edwardk> er give the two implementations of callCC
16:31:51 <wli> mmorrow: It's a 4.5MB file; how should I send it?
16:32:09 <edwardk> but one of MonadState over MonadCont or MonadCont over MonadState _should_ discard the state
16:32:28 <mmorrow> roconnor: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/monad-tx
16:33:17 <hs2m> Saizan: Thanks a lot that worked
16:33:40 <FliPPeh> > 'a' `isPrefixOf` "alabama"
16:33:41 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Char'
16:33:44 <FliPPeh> :S
16:33:47 <FliPPeh> > "a" `isPrefixOf` "alabama"
16:33:48 <lambdabot>   True
16:33:50 <FliPPeh> Whut.
16:33:57 <ehird> FliPPeh: 'a' is a Char
16:34:00 <ehird> "a" is a String = [Char]
16:35:14 <FliPPeh> Man
16:35:19 <FliPPeh> This is going to take a while
16:35:26 <QP> > ['H','e','l','l','o']
16:35:27 <lambdabot>   "Hello"
16:35:29 <edwardk> ah neat, i just found a use for a two-hole context in a context-free grammar!
16:36:17 <daf> Smokey`: hmm, I'm stil confused
16:36:26 <daf> er Saizan ^^
16:36:56 <edwardk> hrmm, not quite. its a different derivative
16:37:25 <daf> why is return (Left "foo") >> return (Right "bar") => Right "bar" in ErrorT?
16:38:12 <Cale> daf: Because return x is always a computation which does absolutely nothing except to result in x, and u >> v ignores the result of u
16:38:21 <edwardk> daf: because return just wraps up anything. return a >> return b = return b
16:38:28 <Cale> So  return x >> v  is always the same as  v
16:38:35 <edwardk> > Left "foo" >> Right "bar"
16:38:37 <lambdabot>   Left "foo"
16:38:47 <edwardk> > return (Left "foo") >> Right "bar"
16:38:48 <lambdabot>   Add a type signature
16:38:53 <Cale> So return (Left "foo") >> return (Right "bar") is the same as return (Right "bar")
16:39:15 <daf> hmm, what am I missing?
16:39:37 <Cale> daf: Since you're using ErrorT, perhaps you want throwError?
16:39:43 <edwardk> daf: think of 'return' as wrapping up a value in the monad. you have a Right (Left "foo") -- after the first operation.
16:40:09 <daf> I have functions of type IO (Either String a)
16:40:14 <daf> I want to compose them
16:40:28 <daf> In what I hope is the obvious way
16:40:44 <edwardk> what is the obvious way to you? that if either is Left you get the first String?
16:40:55 <daf> right
16:41:31 <edwardk> daf: what you have isn't quite the type you want to do that as easily as possible. a slightly better tool woudl be ErrorT String IO a
16:41:41 <Cale> daf: Are they really functions, or just actions? What would you like to do with the result?
16:42:27 <edwardk> then its explicit that you are working with an 'IO (Either String ...)' as if it were a monad its own right rather than a monad that just happens at this moment to contain a value that is an Either String a
16:42:30 <daf> functions returning actions, I suppose
16:42:50 <Berengal> Doesn't an EitherT exist?
16:43:02 <edwardk> Berengal: ErrorT
16:43:04 <Cale> Berengal: It's called ErrorT
16:43:14 <Berengal> Oh, so they're the same?
16:43:14 <edwardk> Berengal: with the annoying Error e => ... context
16:43:16 <Cale> (at least in mtl)
16:43:32 <Olathe> @index second
16:43:32 <lambdabot> Control.Arrow
16:43:52 <daf> so Lefts are always introduced in ErrorT using fail or throw?
16:44:38 <FliPPeh> Man
16:44:43 <FliPPeh> I will never make this
16:44:46 <Saizan> daf: you can use ErrorT (return (Left "foo")) but that's not nice
16:44:50 <edwardk> if you have x, y :: IO (Either String a) -- then runErrorT (ErrorT x >> ErrorT y) -- will glue the two functions together, returning the first error, or the result of the second.
16:44:54 <FliPPeh> Where can I find a good parsec tutorial?
16:45:08 <edwardk> daf: not always, but its the general idiom
16:45:09 <juturnas> http://en.wikibooks.org/wiki/Haskell/Practical_monads
16:45:17 <juturnas> I'm looking at parsec on that page right now
16:45:25 <juturnas> just scroll down to the parsec part, has a nice introduction
16:45:31 <Cale> http://www.cs.uu.nl/~daan/download/parsec/parsec.html
16:45:48 <Cale> That's aging a bit, but it's still decent.
16:45:55 <daf> Saizan: aha
16:46:20 <daf> that is ugly, indeed
16:48:03 <Cale> If you're using ErrorT anyway, you should use throwError instead of Left
16:48:47 <daf> yeah?
16:49:59 <Berengal> What is required of a monad to be able to make a transformer out of it?
16:50:38 <chessguy> @src MonadTran
16:50:38 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
16:50:45 <chessguy> @src MonadTrans
16:50:45 <lambdabot> Source not found. Do you think like you type?
16:50:51 <edwardk> berengal: a distributive law over any monad
16:50:56 <daf> I think it doesn't matter as long as the monal laws are preserved
16:51:36 <daf> edwardk, Cale, Saizan: thanks for explanations and advice. I thikn I'll come back to it after some sleep.
16:51:55 <Berengal> edwardk: A distributive law being what?
16:52:19 <edwardk> Berengal: you either need to be able to move it out over any monad. i.e. Reader, or you have to be able to move your monad 'into' any other monad, like ErrorT does.
16:52:49 <Berengal> edwardk: Ah, so "invert" them in a way
16:52:52 <edwardk> berengal: type Dist f g = forall a. f (g a) -> g (f a) -- =)
16:53:17 <Saizan> uhm, does that fit StateT?
16:53:20 <Berengal> Yeah, I think I see
16:53:35 <edwardk> there are technically 3 different laws that are commonly used. but not every monad transformer works in this fashion
16:53:44 <edwardk> saizan: nope =)
16:54:46 <edwardk> the easiest condition to spot is the one i mentioned there, you can also make a monad out of any monad and a pointed functor if you have a law of the form m (n (m a)) -> n (m a)   or m (n (m a)) -> m (n a) for the two
16:55:20 <edwardk> and there are other constructions, for instance, any two ideal monads have a coproduct that is also a monad, etc.
16:55:43 <edwardk> and of course StateT kind of sandwiches the monad in the middle
16:56:36 <Saizan> ideal monad?
16:56:37 * wli tries to think of how to find the square root of 2 mod p when it exists.
16:56:55 <edwardk> http://comonad.com/haskell/category-extras/src/Control/Functor/Extras.hs has several different compositions of two functors
16:57:36 <wli> (or maybe even the square root of (p+1)/2)
16:58:25 <edwardk> hrmm, i had thought that i had the pointed/monad transformers in category-extras, i must have never committed them
16:58:34 <roconnor> mmorrow: why did you show me monad-tx?
16:58:38 <edwardk> mark jones did a write up back forever ago using them
16:58:49 <edwardk> roconnor: it uses both implementations of callCC
16:59:03 <Saizan> another interesting question is if there are monads for which you can't write the transformer version
16:59:05 <edwardk> roconnor: mtl is withRollback, monadLib's for withCommit
16:59:48 <roconnor> I don't see such functions
16:59:59 <edwardk> roconnor: maybe they aren't in that version, hrmm
17:00:37 <edwardk> they are, view source
17:01:10 <andresj> @hoogle windowNew
17:01:10 <lambdabot> No results found
17:01:22 <andresj> argh, how do i search gtk2hs in hoogle?
17:02:08 <dcoutts> andresj: I'm not sure if it's in the new hoogle 4, but it's in hoogle 3: http://haskell.org/hoogle/3/?package=gtk&q=foo
17:03:16 <andresj> dcoutts: thank you! it gives me old results, tho. from 0.9.10 when current is 0.10.0
17:03:30 <hs2m> anyone know how to convert a Maybe String to String
17:03:47 <dcoutts> andresj: hopefully there's not too much changed
17:04:32 <andresj> dcoutts: haha yes, well i found that the Events module is depracted now in favor of EventM, but appart from that i dont see much else :)
17:04:34 <roconnor> @unmtl ContT r (State s a)
17:04:35 <lambdabot> err: `ContT r (s -> (a, s))' is not applied to enough arguments.
17:04:42 <roconnor> @unmtl ContT r (State s) a
17:04:42 <lambdabot> (a -> s -> (r, s)) -> s -> (r, s)
17:04:55 <roconnor> @unmtl StateT s (Cont r) a
17:04:56 <lambdabot> s -> (a -> s -> r) -> r
17:05:01 <Botje> hs2m: you don't convert it, you use pattern matching and explicitly take care of the Nothing alternative
17:05:40 <hs2m> Botje: basically I have a url inside a Maybe, i just want the url as a string any ideas how to do that?
17:05:48 <Botje> use pattern matching
17:05:59 <Botje> case bleh of Just url -> (use url here); Nothing -> panic
17:06:19 <hs2m> Botje: like function Just a = a
17:06:20 <hs2m> ?
17:06:22 <araujo> let maybeToStr Nothing = [] ; maybeToStr (Just str) = str
17:06:26 <araujo> something like that
17:06:32 <hs2m> thanks a lot!
17:06:41 <Botje> you could just use fromJust, yes.
17:06:53 <Botje> but the whole point of Maybe a is that you handle the Nothing case..
17:08:09 <Botje> maybe id (error "No url found!") is another good way of handling it
17:08:14 <Botje> :type maybe
17:08:21 <Botje> :t maybe
17:08:21 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:08:25 <Botje> bloddy lambdabot
17:08:26 <gwern> andresj: I think you have to use gtk2hs's hoogle installation
17:08:36 <Botje> maybe (error "No url found!") id.
17:08:47 <Ralith> wouldn't that have to be
17:08:52 <Ralith> (\x -> error "No url found!")
17:09:12 <andresj> gwern: do they have another one? i just know bout http://haskell.org/hoogle/3/?package=gtk, which is outdated, and http://haskell.org/hoogle/package=gtk ,which does not work properly.
17:09:26 <gwern> andresj: isn't it on the gtk2hs site?
17:09:36 <Botje> Ralith: nah, look at the type
17:09:52 <Botje> logically, if the Maybe value is Nothing you don't have any data to go on ;)
17:09:58 <andresj> well http://www.haskell.org/gtk2hs/documentation/ links to the second url
17:10:17 <Ralith> Botje: orite
17:12:15 <gwern> andresj: in that case, dunno
17:12:39 <gwern> this seems to work http://haskell.org/hoogle/3/?package=gtk&q=init but you say it's outdated
17:13:45 <andresj> haha yes, it works, but on gtk2hs-0.9.10
17:13:51 <andresj> plus it doesnt support operators
17:14:00 <eu-prleu-peupeu> is there any way to code assembly in haskell ?
17:14:37 <FliPPeh> Probably, VERY PROBABLY not
17:14:48 <Saizan> well, there's harpy
17:14:55 <andresj> eu-prleu-peupeu: C bindings?
17:15:03 <FliPPeh> Assembler is the complete opposite of Haskell
17:15:11 <dcoutts> eu-prleu-peupeu: you can compile Haskell and assembly to separate .o files and link them together and using the FFI you can have them call each other
17:15:18 <FliPPeh> Extremely low level and imperative
17:15:36 <eu-prleu-peupeu> hmm ok
17:15:37 <eu-prleu-peupeu> i see
17:15:48 <dcoutts> C + Haskell is a good combo, assembler is probably going unnecessarily low
17:15:53 <gwern> andresj: operators?
17:16:25 <andresj> gwern: searching operators, that is. like (:=) although i already found it in System.Glib.Attributes :P
17:17:16 <andresj> btw, this keeps popping up in code i write; how do u import a data constructor? always ghc says that the module doesnt export it.
17:17:19 <thoughtpolice> you fools!
17:17:23 <thoughtpolice> we have DSLs for this!
17:17:24 <thoughtpolice> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/harpy
17:17:30 <thoughtpolice> ^ x86 asm inside haskell :)
17:17:31 <edwardk> FliPPeh: bah you might argue that its the closest thing to haskell =)
17:17:45 <FliPPeh> Both are hard to learn, so yea.
17:17:48 <edwardk> FliPPeh: after all look at all of the out of order instruction evaluation they have going on under the hood =)
17:17:58 <povman> What's an example of a Poset which is not a Lattice?
17:18:06 <andresj> i mean, when importing it by name; when i import the whole module ghc doesnt complain
17:18:12 <gwern> andresj: 'import Foo.Bar (Baz(Quux, Urk))' or import Foo.bar (Baz(..))
17:18:18 <edwardk> povman: give it two bottoms
17:18:36 <edwardk> or 'draw a heart' =)
17:18:37 <andresj> oooooh!!! lol, thank you gwern!! i guess i never read that part of real world haskell :P
17:18:49 <povman> Such imagery!
17:19:45 <edwardk> gotta run
17:20:04 <povman> (thanks)
17:24:07 <povman> By the way, I've figured out why http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2285 doesn't work!
17:49:35 <rabideejit> > fmap (+4) $ pure 6
17:49:35 <lambdabot>       Ambiguous occurrence `pure'
17:49:35 <lambdabot>      It could refer to either `Control.Appl...
17:50:42 <rabideejit> > head $ concat $ fmap fmap ( pure (+4) ) <*> pure ( pure 6 )
17:50:43 <lambdabot>       Ambiguous occurrence `pure'
17:50:43 <lambdabot>      It could refer to either `Control.Appl...
17:51:02 <rabideejit> head $ concat $ fmap fmap ( pure (+4) ) <*> Control.Applicative.pure ( Control.Applicative.pure 6 )
17:51:16 <rabideejit> > head $ concat $ fmap fmap ( pure (+4) ) <*> Control.Applicative.pure ( Control.Applicative.pure 6 )
17:51:17 <lambdabot>       Ambiguous occurrence `pure'
17:51:17 <lambdabot>      It could refer to either `Control.Appl...
17:51:54 <rabideejit> yes, I'm spamming #haskell at 1:51 am with pointless fmaps
17:52:02 <rabideejit> > head $ concat $ fmap fmap ( Control.Applicative.pure (+4) ) <*> Control.Applicative.pure ( Control.Applicative.pure 6 )
17:52:03 <lambdabot>   10
17:52:05 <rabideejit> yay
17:52:33 <zoheb> do we have a tail function that returns newtail [] = []
17:52:42 <zoheb> or similar
17:53:11 <Berengal> > drop 1 []
17:53:12 <lambdabot>   []
17:53:29 <zoheb> oh yes, :) thx
17:53:32 <zoheb> berengal
17:54:05 <zoheb> I am trying to write an inverse of concat
17:54:34 <zoheb> very often we want to split up a list into a list of lists
17:54:51 <rabideejit> zoheb:  like a function which takes an int  'n' say and a list, and splits the list into sublists of length n?
17:54:58 <zoheb> so, something general like foldr for use in such situations
17:55:10 <zoheb> that could be one use
17:55:37 <lispy> unfoldr?
17:55:39 <lispy> :t unfoldr
17:55:40 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
17:55:43 <zoheb> here is my first attempt http://mibbit.com/pb/VjsIGq
17:55:57 <zoheb> oh there is one already?
17:56:12 <lispy> Maybe. I doubt I full understand what you're after
17:56:36 <lispy> unfoldr takes a generator, a seed, and returns a list
17:56:58 <zoheb> that isn't what I had in mind
17:57:05 <adamvo> @type map (:[])
17:57:06 <lambdabot> forall a. [a] -> [[a]]
17:57:07 <Berengal> > takeWhile (not.null) . map (take 2) . iterate (drop 2) $ [1..20]
17:57:08 <lambdabot>   [[1,2],[3,4],[5,6],[7,8],[9,10],[11,12],[13,14],[15,16],[17,18],[19,20]]
17:57:14 <lispy> > unfoldr (\x -> Just (x,x)) 1
17:57:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:57:28 <zoheb> I am thinking of a fn that can be useful for writing fns like words or lines
17:57:46 <rabideejit> your definition there looks like you want g to return ( a , b ) where a is a of type A and b is of type [ A ], bu you only add k to the end of the list.
17:57:46 <lispy> you want to group things?
17:58:19 <lispy> > groupBy (<) [1, 2, 3, 4, 1, 0, 3, 5, 7]
17:58:20 <lambdabot>   [[1,2,3,4],[1],[0,3,5,7]]
17:58:28 <Berengal> > span isDigit "12345432asdffgwds"
17:58:29 <lambdabot>   ("12345432","asdffgwds")
17:58:29 <lispy> (oh the weirdness of groupBy
17:58:42 <lispy> :t break
17:58:43 <idnar> why is that weird?
17:58:43 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:58:56 <lispy> idnar: I always have to restudy it to make sense of it :)
17:58:58 <zoheb> actuually I havent found a better value for k than []
17:59:21 <ManateeLazyCat> Hi, guys. How do you use QuickCheck to test program? Any document and suggestion? Thanks.
17:59:32 <zoheb> here is a sample use of the function  foldrs (fmap (drop 1).span isDigit) [] "1234,5678,90"
17:59:45 <zoheb> ["1234","5678","90"]
17:59:54 <lispy> idnar: I just feel, groupBy can be very counter intuitive, and it is also a leaky abstraction.  The exact way that your binary funtion works isn't enough to determin the behavior...if you give it the right ops and inputs you can reverse engineer groupBy
18:00:36 <zoheb> or foldrs (splitAt 4) [] "1234,5678,90" = ["1234",",567","8,90"]
18:01:04 <lispy> I'd start with the type...
18:01:14 <lispy> That tends to be very telling
18:01:21 <Berengal> > takeWhile (not.null) $ unfoldr (\l -> Just $ second (drop 1) . span (/=' ') $ l) "hello world how are you?"
18:01:23 <lambdabot>   ["hello","world","how","are","you?"]
18:01:35 <rabideejit> I get foldrs :: ([t] -> (t1, [t])) -> [t1] -> [t] -> [t1]
18:01:43 <Berengal> @type unfoldr
18:01:44 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:01:53 <lispy> I knew it!
18:01:56 <zoheb> yes, I was trying to simplify code like that Berengal
18:02:07 <Berengal> "foldrs" seems eerily similar to unfoldr
18:02:21 <zoheb> I haven't looked at unfoldr
18:02:25 <zoheb> I will take a look
18:02:28 <lispy> Yeah, but the type rabideejit gave is not isomorphic to unfoldr
18:02:47 <rabideejit> there's a bit of a difference.
18:02:53 <zoheb> I used a pair object because span, break, splitAt all return pairs
18:02:59 <lispy> Specifically, Maybe (a, b) vs. (t1, [t]) and [t1]
18:03:07 <skorpan> :t unfoldr
18:03:08 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:03:15 <rabideejit> exactly.
18:03:32 <rabideejit> But I think unfoldr is nearer the mark, unles zoheb, you really have a use for the list of [t1]
18:03:35 <zoheb> I need to look at unfoldr
18:03:59 <lispy> ?src unfoldr
18:03:59 <lambdabot> unfoldr f b  = case f b of
18:03:59 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
18:03:59 <lambdabot>    Nothing        -> []
18:04:05 <lispy> we can all look at it :)
18:04:33 <Berengal> unfoldr is a generalized list-builder
18:05:10 <dolio> @type \f -> foldr (((f . Just) .) . (,)) (f Nothing)
18:05:11 <lambdabot> forall c a. (Maybe (a, c) -> c) -> [a] -> c
18:05:11 <Berengal> It's like iterate, except it can stop by itself, and the iterated value can be separate from the collected value
18:05:39 <lispy> Yes, very clever
18:06:27 <zoheb> > takeWhile (not.null) $ unfoldr (\l -> Just $ second (drop 1) . span (/=' ') $ l) "hello world how are you?"
18:06:28 <lambdabot>   ["hello","world","how","are","you?"]
18:06:36 <lispy> dolio: heh, Cool, foldr is a generalized unfolder
18:06:38 <dolio> @type \f -> foldr (curry $ f . Just) (f Nothing)
18:06:39 <lambdabot> forall a c. (Maybe (a, c) -> c) -> [a] -> c
18:06:40 <zoheb> > unfoldr (\l -> Just $ second (drop 1) . span (/=' ') $ l) "hello world how are you?"
18:06:41 <lambdabot>   ["hello","world","how","are","you?","","","","","","","","","","","","","",...
18:07:03 <dolio> Huh? foldr is a folder, not an unfolder.
18:07:14 <dolio> @type unfoldr
18:07:15 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:07:21 <dolio> Goes in the opposite direction.
18:07:39 <Berengal> Can't foldr without a list...
18:08:15 <rabideejit> ( or at least a foldable if you're wanting smart alec type answers )
18:08:16 <Berengal> You might be able to foldr over a repeat () list to unfold though...
18:09:15 <lispy> dolio: but, you made unfoldr from foldr, therefore, foldr generalizes unfoldr ;)
18:09:15 <Berengal> Actually, probably not
18:09:43 <dolio> I made foldr use a Maybe (a, b). It's still foldr.
18:09:51 <Berengal> lispy: That wasn't unfoldr
18:09:58 <Berengal> @type \f -> foldr (((f . Just) .) . (,)) (f Nothing)
18:09:59 <lambdabot> forall c a. (Maybe (a, c) -> c) -> [a] -> c
18:10:02 <Berengal> @type unfoldr
18:10:02 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:10:34 <lispy> Oh
18:10:41 <lispy> I misread it
18:10:42 <Berengal> They're basically inverses
18:11:13 <lispy> Right, I just...ooops.  I thought it might be possible to implement unfoldr interms of foldr but maybe that is silly.
18:12:06 <Berengal> At this point someone will probably mention ana- and katamorphisms. I'm not sure, but I believe they're relevant...
18:12:38 <lispy> In deed
18:13:17 <lispy> I'm not category theory expert, but my understand was that foldr/unfoldr are the generic implementations of those concepts for the list functor
18:13:30 <lispy> (I also can't seem to type worth a damn)
18:13:40 <lispy> (what's new, right?)
18:13:48 <EvilTerran> lispy, i'm guessing cata/anamorphisms?
18:14:08 <lispy> EvilTerran: hi!  How is code?
18:14:28 <lispy> What do people work on here these days?  I'm *here* and the loop is over *there*
18:15:06 <gwern> lispy: monads today, monads yesterday, and blimey if it don't look like monads tomorrer too!
18:15:14 <gwern> what I wouldn't give for a little manflesh
18:16:04 * lispy raises an eyebrow at the "manflesh" bit, and wonders if that should continue in #haskell-blah
18:16:09 <lispy> gwern: hi!
18:16:18 <lispy> gwern: I see you working on Darcs these days, that's good.
18:16:20 <gwern> lispy: _Hobbit_ joke, but I guess that's too obscure
18:16:40 <gwern> lispy: mostly gitit/filestore akually, but since the bottleneck there is darcs...
18:16:42 <lispy> gwern: Bilbo!  The bravest hobbit ever known...Bilbo!  (another obscure hobbit ref)
18:17:14 * gwern tries again. 'Gee dons what are we going to do tonight?' 'the same thing we do every night lispy - try to figure out monads!'
18:17:24 <lispy> heh
18:17:53 <gwern> (I would've gone with 'monad transformers', but I need 5 syllables - 'take over the world' is 5 and so is 'figure out monads')
18:17:56 <lispy> Quiz: What is the Mother of All monads?  e.g., which existing Monad instance is it?
18:18:05 <gwern> er. Id?
18:18:09 <lispy> nein
18:18:17 <gwern> zut alors
18:18:23 <lispy> sigfpe has a blog about it
18:18:23 <gwern> Functor then?
18:18:28 <lispy> That's where I learned it
18:18:32 <lispy> sigfpe++
18:18:45 <lispy> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
18:19:06 <MyCatVerbs> lispy: Cont?
18:19:17 <gwern> hm. the mother of all things is the Tao, and monads are things; so therefore instance Tao Monad?
18:19:20 <lispy> MyCatVerbs: correct
18:19:41 <lispy> MyCatVerbs: now the more interesting bit is *why*
18:19:50 <MyCatVerbs> Guess who else reads sigfpe's blog. ;P
18:20:10 <gwern> lispy: maybe continuations are so powerful they can do just about anything even monads?
18:20:15 <MyCatVerbs> Can't remember. Possibly because you can implement all functional languages in CPS?
18:20:15 <lispy> hehe, I learn so much in an hour of reading his blog that I can't look at it often.  My head would explode
18:20:23 <gwern> someone once told me that continuations are like principaled GOTOs
18:20:40 <gwern> (which certainly sounds general & powerful)
18:20:58 <lispy> gwern: yes, and iirc it was Backus(sp?) that first pointed that out publicly
18:21:13 <lispy> Or maybe he was talking about lambdas
18:21:16 <lispy> Gosh, I can't recall
18:21:24 <gwern> perhaps he meant post machines
18:21:26 <dolio> People say tail recursion is like goto, as well.
18:21:42 <lispy> dolio: I'd like to see how that works, care to elaborate?
18:21:55 <lispy> tail recursion *uses* goto
18:21:57 <Berengal> TR is _a_ goto, but not _all_ gotos
18:22:09 <dolio> Functions are labels. Tail calls are goto.
18:22:14 <gwern> Berengal: there are no beginnings nor ends to the goto of time
18:22:31 * ivanm thinks it would be cool to have bindings to this: http://tulip.labri.fr/
18:22:35 <lispy> I liked what roconnor said about State yesterday
18:22:44 <dolio> I should have said tail calls in general, not tail recursion.
18:22:53 <lispy> dolio: ah
18:23:11 <dolio> I'd say they're more principled than goto, but I'm not sure I can justify that. :)
18:23:13 <lispy> ?users
18:23:13 <lambdabot> Maximum users seen in #haskell: 658, currently: 595 (90.4%), active: 16 (2.7%)
18:23:22 <lispy> wow, over 600
18:23:23 <MyCatVerbs> dolio: tail calls to constructors don't really behave like gotos. :)
18:23:56 <gwern> (one of the nice things of WoT is that some of its writing is so unique that it's almost trivial to pardy - 'a stack frame arose and blew over the CPU. it was *a* tail recursive goto, but not *the* goto. there are no beginnings or ends to the goto of time.')
18:23:58 <Berengal> dolio: More principled in that the can only goto the beginning of a function, perhaps?
18:24:11 <dolio> Yeah. And only from the end of a function.
18:24:29 <dolio> I don't know. It just seems like they're less spaghetti enabling. But maybe I'm wrong.
18:24:42 <MyCatVerbs> I'd say that in Haskell, CPS is trivially a little more pricipled than raw goto, just because you have to continue through something which has the correct output type.
18:24:48 <Berengal> So TCs have one entry point and one exit point
18:25:04 <Berengal> Well, possibly several exit points, but they all exist in different branches
18:25:21 <MyCatVerbs> Berengal: hrmn? No, many e... yes, many exit points, but always as the last thing done.
18:25:55 <Berengal> ergo different branches
18:26:35 <Berengal> And since all functions have to return a value (or you'd have bottom), the "last thing done" can't be in the middle of an expression.
18:27:35 <ivanm> gwern: "WoT"?
18:27:41 <gwern> ivanm: wheel of time
18:27:53 <ivanm> oh, that never-ending series of fantasy novels?
18:28:23 <Berengal> Well, the guy's dead now...
18:28:35 <ivanm> Berengal: :o
18:28:42 <ivanm> I guess it ended then... >_>
18:29:26 <gwern> no. sanderson is writing the next 3
18:30:41 <lispy> MyCatVerbs: also, the CPS in the Cont monad is delimited
18:30:57 <lispy> MyCatVerbs: eventually you are delimited by runCont
18:31:06 <MyCatVerbs> lispy: I am entirely unclear on the semantics of delimited continuations.
18:31:40 <gwern> http://www.modernperlbooks.com/mt/2009/04/the-why-of-perl-roles.html <-- did - did perl 6 just reinvent type classes?
18:31:48 <ivanm> gwern: OK, as I said, never-ending
18:31:50 <lispy> MyCatVerbs: me too, but my vague understanding is that the delimitation is the universe that the current continuation can access.  So when you delimited a continuation you cut down on the universe
18:32:03 <gwern> ivanm: no, sanderson swears 3 books and that's it! :)
18:32:11 <dolio> Anyhow, continuations are like goto where you can pass around which label to go to, and you don't just go to a line in the program, you go to a time.
18:32:16 <Berengal> How do I get a FileChooserButton thingy out of a glade file in gtk2hs?
18:32:17 <ivanm> gwern: and then someone _else_ will do 3 books! :p
18:32:47 <MyCatVerbs> lispy: I've nosed around Oleg's stuff and a few other places, but haven't spotted anything that looked like an introduction rather than a "today we're going to implement delimited continuations using $atrocious_hack allowing us to embed the idea in a language that doesn't natively support it">
18:33:11 <lispy> MyCatVerbs: hehe.  I bet we can find a good definition if we look
18:33:19 <rabideejit> also, why is the evilmangler written in perl?
18:33:34 <lispy> MyCatVerbs: oh hai: http://en.wikipedia.org/wiki/Delimited_continuation
18:33:49 <rabideejit> is it to emphasize its evil alignment?
18:34:06 <lispy> rabideejit: because perl is good at munging, I think
18:34:14 <gwern> rabideejit: no one cares enough to write it in haskell, and it's doomed anyway
18:34:15 <lispy> rabideejit: and portable...
18:34:45 <ivanm> lispy: well, if someone wanted to I'm sure they could use haskell regex libraries to do so
18:34:54 <ivanm> but that will involve work, and possibly extra deps :s
18:35:13 <lispy> ivanm: then it would be the pure mangler or something...really, much less drama and less motivation to axe it for good :)
18:35:18 <rabideejit> write it in befunge and be done with it.
18:35:21 <gwern> not to mention no one probably understands it by this point
18:35:26 <ivanm> lispy: heh
18:35:40 <ivanm> rabideejit: so you want to replace perl with yet another language? :s
18:35:43 <ivanm> how does that help?
18:36:11 <lispy> ivanm: it can help...in darcs we have an issue with running the test suite on windows because it is written in sh
18:36:24 <lispy> ivanm: if we rewrote the tests in haskell then it would run wherever darcs runs :)
18:36:33 <gwern> we can fix that! we have the shsh technology!
18:36:37 <ivanm> lispy: \o.
18:36:41 <ivanm> * \o/
18:36:41 <dolio> MyCatVerbs: Oleg's paper on using delimited continuations in modeling operating systems is good.
18:36:42 <rabideejit> ivanm: I'm kind of joking.  I don't think anyone really writes in befunge ( other than people on #esoteric )
18:36:46 <lispy> gwern: the thing from Stephen Hicks?
18:36:55 <ivanm> lispy: I assume that you don't want to require cygwin or something on windows?
18:37:00 <rabideejit> anyway, byebye :)
18:37:03 <lispy> ivanm: right
18:37:04 <gwern> dunno. last I looked mostly roundy seemed to be hacking on shsh
18:37:14 <lispy> ivanm: cygwin/msys are bad dependencies to have
18:37:21 <ivanm> lispy: *nod*
18:37:27 <lispy> gwern: ah, does that mean it uses franchise?
18:37:32 <ivanm> is msys that bad though, since it's pretty small (compared to cygwin)?
18:37:37 <gwern> er... probably
18:37:42 <lispy> ivanm: I like neither :)
18:37:50 <ivanm> franchise: because the haskell community needs to be divided even further! :s
18:37:59 <lispy> gwern: oof.  Well, that's a turn off for me...back to my own pet projects
18:38:11 <gwern> how hard could it be to cabalize?
18:38:24 * lispy wants to write a *real* type checked for annotated subsets of normal python
18:38:31 <lispy> checker*
18:38:37 <dolio> MyCatVerbs: http://www.cs.rutgers.edu/~ccshan/zipper/context2007.pdf
18:38:48 <gwern> just maintain a careful branch; I mean, roundy cabalized franchise for hackage...
18:38:51 <gwern> the irony I know
18:39:06 <lispy> gwern: wow yeah, the irony of that one hurts
18:39:09 <ivanm> gwern: heh
18:39:23 <gwern> he's not stupid; just opinionated
18:39:38 <ivanm> gwern: have you seen roundy's and arrosatto's xmonad fork?
18:39:41 <lispy> he's very intelligent, but he got burt out and started resisting everything
18:39:43 <gwern> like FLOSS projects supporting windows.
18:39:48 <MyCatVerbs> dolio: thanks. I was going through the "Beyond Continuations" paper when you linked that. :)
18:39:58 <gwern> ivanm: sure have. sent it to the xmonad ml, though I didn't look too hard at the changes
18:40:12 <lispy> His code can be hard to maintain too.
18:40:12 <ivanm> oh, that was you that sent it?
18:40:15 <gwern> (they look hard to bring back to the mainline)
18:40:17 * ivanm thought it was someone else
18:40:20 <gwern> ivanm: small world
18:40:33 <ivanm> yup
18:44:50 * wli takes a stab at PE#216.
18:45:00 <ivanm> wli: hmmm?
18:45:07 <Zao> Project Euler, I suppose.
18:45:13 <ivanm> ahhh
18:45:15 <wli> Yeah.
18:45:28 * ivanm thought it was "Please Explain" or something...
18:45:47 <ivanm> http://en.wikipedia.org/wiki/Pauline_Hanson <-- ;-)
18:45:50 <Zao> http://projecteuler.net/index.php?section=problems&id=216
18:45:54 <wli> I'm getting right answers but it's a bit slow.
18:48:08 <ivanm> "It turns out that only 49 = 7*7 and 161 = 7*23 are not prime." <-- wtf?
18:48:47 <lispy> ivanm: must be in a special subset?
18:48:55 <ivanm> wli: the way I'd try it is get a wheel-based sieve of erasthotenes (however you spell it), add all those primes to a Set or something, then generate all t(n) and filter if they're in the set
18:48:58 <lispy> Obviously those are not the only compsoites
18:49:08 <ivanm> lispy: yeah, it is... they just don't say so explicitly
18:49:15 <wli> 2*n*n-1 for n = 5 and n = 9.
18:49:24 <ivanm> so at first glanced, I didn't get the next sentence ;-)
18:49:48 <ivanm> IIRC, there's a primes package on hackage...
18:49:51 <gwern> ivanm: please explain?
18:50:01 <ivanm> gwern: which bit? ;-)
18:50:13 <gwern> the relevance of hanson, I suppose
18:50:26 <lispy> > map (\n -> 2*n*n-1) [1..10]
18:50:27 <lambdabot>   [1,7,17,31,49,71,97,127,161,199]
18:50:35 <ivanm> gwern: wli said "PE", and the first meaning of PE I thought of was "Please Explain" ;-)
18:50:41 <gwern> ah
18:50:43 <wli> ivanm: Right now I'm factoring 2*n*n-1, and if it's prime I tell [n], and in either case, I add n mod p and (-n) mod p to the queue.
18:51:00 <ivanm> wli: hmmm.... factoring is probably rather expensive
18:51:05 <wli> ivanm: For all prime divisors of 2*n*n-1
18:51:11 <lispy> I bet you only have to cehck for 7
18:51:18 <ivanm> lispy: heh
18:51:40 <ivanm> lispy: http://www.maths.uwa.edu.au/~berwin/humour/invalid.proofs.html#1.1Proofbyexample
18:52:00 <lispy> ivanm: :)
18:52:20 <lispy> ivanm: it's a conjecture worth trying to prove or find a counter example of though, as it would give a nice speed up :)
18:52:30 <ivanm> lispy: yeah
18:52:37 <wli> http://wli.pastebin.com/md9cfabe
18:52:41 <ivanm> proving it might be a little difficult
18:53:08 <wli> They're actually such small numbers that more advanced factoring algorithms should make short work of them.
18:53:13 <ivanm> wli: well, I suppose it's less dense than your usual examples... :p
18:53:22 <ivanm> wli: but as I said, I wouldn't bother
18:53:36 <gwern> "To see that infinite-dimensional colored cycle stripping is decidable, we reduce it to the halting problem." <-- ok, I like that
18:53:40 <ivanm> get something to generate primes, and use that
18:53:46 <lispy> > filter (==0) (map (`mod` 7) (map (\n -> 2*n*n-1) [1..100]))
18:53:47 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]
18:53:48 <ivanm> gwern: lol
18:53:57 <lispy> > filter (/=0) (map (`mod` 7) (map (\n -> 2*n*n-1) [1..100]))
18:53:58 <wli> This is already a bit too slow.
18:53:58 <lambdabot>   [1,3,3,1,6,1,3,3,1,6,1,3,3,1,6,1,3,3,1,6,1,3,3,1,6,1,3,3,1,6,1,3,3,1,6,1,3,...
18:53:59 <ivanm> lispy: heh
18:54:01 <gwern> @remember BerwinTurlach To see that infinite-dimensional colored cycle stripping is decidable, we reduce it to the halting problem.
18:54:01 <lambdabot> Okay.
18:54:14 <lispy> that pattern of mods is a bit telling
18:54:52 <ivanm> > filter (==0 . fst) (map (`mod` 7 . fst) (map (\n -> (2*n*n-1,n)) [1..100]))
18:54:52 <lambdabot>   Couldn't match expected type `(a, b) -> c'
18:54:56 <ivanm> gah
18:55:00 <wli> Well, if p|(2*n*n-1) then if m = n mod p then p|(2*m*m-1)
18:55:01 <dolio> Perhaps he has a perspex machine.
18:55:42 <wli> Furthermore if p|(2*n*n-1) then p|(2*(p-n)*(p-n)-1)
18:56:03 <wli> That's where I use the queue.
18:56:42 <lispy> > (map (`mod` 7) (map (\n -> 2*n*n-1) [1..100]))
18:56:43 <lambdabot>   [1,0,3,3,0,1,6,1,0,3,3,0,1,6,1,0,3,3,0,1,6,1,0,3,3,0,1,6,1,0,3,3,0,1,6,1,0,...
18:57:06 <lispy> I wish lambdabot had an isPrime
18:57:37 <lispy> I would like to map it on the result of dividing those that give 0 by 7 (repeatedly) then running isPrime
18:57:53 <lispy> anyway, I have to go
18:57:54 <lispy> good luck
19:03:08 <wli> The trick is that I don't have a good way to skip over stretches of numbers.
19:04:32 <wli> (in fact it doesn't appear that I actually can)
19:05:18 <wli> So basically faster factoring and/or primality testing is about the only obvious way I can think of to speed it up.
19:07:28 <wli> You could do something like a wheel but it's a bit hard to get much mileage out of it because you only knock out two residue classes for each prime.
19:16:31 <wli> I wonder how many duplicate prime factors I'm getting.
19:16:58 <wli> I just realized I don't have anything to prevent duplicates from arising.
19:17:45 <wli> I probably also need the smallest number congruent to something mod p >= some lower bound.
19:19:00 <ivanm> > length . filter ((/=) 0 . flip mod 7) $ map (\n -> 2*n*n - 1) [2..9]
19:19:01 <lambdabot>   5
19:19:07 <ivanm> so that fails...
19:20:26 <ivanm> > filter ((/=) 0 . flip mod 7) $ map (\n -> 2*n*n - 1) [2..9]
19:20:27 <lambdabot>   [17,31,71,97,127]
19:21:10 <ivanm> oh, duh, that _is_ the prime ones (excluding 7)
19:21:17 <ivanm> > succ . filter ((/=) 0 . flip mod 7) $ map (\n -> 2*n*n - 1) [3..9]
19:21:18 <lambdabot>       No instance for (Enum [a])
19:21:18 <lambdabot>        arising from a use of `succ' at <inte...
19:21:36 <ivanm> > succ . length . filter ((/=) 0 . flip mod 7) $ map (\n -> 2*n*n - 1) [3..10000]
19:21:37 <lambdabot>   7143
19:21:46 <ivanm> heh, this is definitely wrong
19:22:32 <ivanm> @tell lispy for that project euler problem, we can't just assume factors of 7 :(
19:22:32 <lambdabot> Consider it noted.
19:26:06 <Olathe> Is there a shortcut for liftM2 id ?
19:26:56 <necroforest> Is there a standard notation for the "set of all primes", like how the integers are Z, rationals are Q, etc?
19:27:03 <Saizan> Olathe: ap
19:27:15 <necroforest> or \mathbb{Z}, \mathbb{Q}
19:27:25 <vixey> necroforest: not that I know of
19:27:42 <necroforest> well i shall start one then
19:27:59 <necroforest> let \mathbb{P} be the set of all primes
19:35:03 <kadaver_> how can you let 2 things in a lambdabot expr?
19:36:52 <ivanm> > let x = 1; y = 2 in x + y
19:36:53 <lambdabot>   3
19:36:57 <ivanm> kadaver_: ^^
19:43:17 <HairyDude> hmm, it would appear -XOverlappingInstances doesn't affect type families.
19:44:36 <monochrom> If you are paranoid, let {x=1;y=2} in x+y
19:44:55 <monochrom> (necessary if you have that inside a do-block)
19:45:54 <HairyDude> oh... looking at the manual, apparently you can overlap, but not in the way I'm doing it.
19:48:04 <ivanm> monochrom: well, in a do-block do you actually use "in"?
19:48:54 <dolio> Overlapping is unsound for type families, unless you declare all the instances in one place and resolve them a certain way, which isn't implemented yet.
19:49:12 <ivanm> does anyone know if it's possible to have hlint not comment on redundant bracketing?  I often put in extra brackets because IMHO, "(f x) > (g y)" looks nicer than "f x > g y" :s
19:52:45 <monochrom> No, in a do-block we don't use "in", but we need { }.
19:53:26 <ivanm> monochrom: or indenting?
19:53:48 <monochrom> Yes but we are also talking about talking to lambdabot.
19:53:49 <ivanm> you're scaring me here, making me think I've programmed everything wrong up until now! ;-)
19:53:54 <ivanm> monochrom: ahhh, true
20:00:48 <HairyDude> I was hoping to define an extensible class of set types, dispatching on the element type. so Set Int is Data.IntSet.IntSet and Ord a => Set a is Data.Set.Set
20:01:16 <HairyDude> err, Data.Set.Set a of course
20:03:49 * Smokey` wonders why ghc packages are > 500mb
20:05:56 <HairyDude> do they come bundled with lots of libraries?
20:07:36 <defun> why does this form (somefunction >>= (return . otherfunction)) work, but this does not this form (somefunction >>= (return $ otherfunction))? Code snips here: (http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4475#a4475).
20:07:43 <HairyDude> dolio: can you point me towards a demonstration that overlapping type instances isn't sound? all I can find is assertions
20:08:40 <Olathe> defun: Because a $ b is the same as a b.
20:09:19 <defun> And a . b can be thought of as... ?
20:09:28 <Olathe> It means to do b, then a.
20:09:30 <dolio> HairyDude: Suppose you have "type instance Foo a = Double" in one file, and in that file "foo :: Foo Int ; foo = 1.0". Then, in another file you have "type instance Foo Int = Int", and "bar :: Foo Int -> Int ; bar i = i".
20:09:41 <defun> I see.
20:09:50 <defun> Is this operator monadic in nature?
20:10:02 <Olathe> Not really.
20:10:11 <defun> I see.
20:10:22 <defun> thanks.
20:10:25 <Olathe> > ((+3) . (*2)) 5
20:10:27 <lambdabot>   13
20:10:29 <Olathe> You're welcome.
20:10:42 <Olathe> > ((+b) . (*a)) 5
20:10:43 <lambdabot>   5 * a + b
20:10:48 <dolio> HairyDude: If you import both and call "bar foo" then it types fine, because foo :: Foo Int, and bar :: Foo Int -> Int, but that does the equivalent of "unsafeCoerce (1.0 :: Double) :: Int".
20:11:04 <defun> :t (.)
20:11:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:12:24 <HairyDude> dolio: can't it check that some instance is already being used for Foo Int? in which case it would reject the second file's instance
20:13:16 <dolio> Which one is it supposed to reject?
20:14:21 <davidL> @pl \x -> (return $ boolStrToData)
20:14:21 <lambdabot> const (return boolStrToData)
20:14:35 <davidL> @pl \x -> (return $ boolStrToData x)
20:14:35 <lambdabot> return . boolStrToData
20:14:42 <vixey> @w80 chrestomathy
20:14:42 <HairyDude> the first file declares "type instance Foo a = Double" then "foo :: Foo Int; foo = 1.0". now implicitly there is an instance Foo Int = Double. if the second file tries to declare "type instance Foo Int = Int" it should fail
20:14:44 <lambdabot> No match for "chrestomathy".
20:15:08 <dolio> Yes, but that's what disallowing overlapping instances means.
20:16:03 <HairyDude> well not quite, because if you omit the definition of foo, there's still the possibility of a more specific instance for Foo Int. with it there, it's already been pinned down
20:16:07 <SamB> @w80 chrestomancy
20:16:07 <lambdabot> No match for "chrestomancy".
20:16:12 <SamB> @google chrestomancy
20:16:13 <lambdabot> No Result Found.
20:16:46 <dolio> Oh, you mean overlapping should only fail if the more general instance is used somewhere?
20:16:54 <SamB> @google chrestomanci
20:16:55 <lambdabot> http://en.wikipedia.org/wiki/Chrestomanci
20:16:55 <lambdabot> Title: Chrestomanci - Wikipedia, the free encyclopedia
20:17:00 <SamB> there we go!
20:17:03 <dolio> That might be fine, but it's a lot more work.
20:17:40 <HairyDude> I can certainly understand it not working now, because it's still an experimental feature anyway :)
20:18:14 <dolio> I mean, in that case, you could have one module declare the "Foo a" instance, and a second declare the "Foo Int" instance.
20:18:23 <dolio> Importing both and using them in a third module would work fine.
20:18:45 <dolio> But then if you import a fourth module that uses the "Foo a" instance at Int, it would cause your program to fail to compile.
20:19:42 <dolio> So it makes things somewhat more fragile.
20:19:46 <HairyDude> how does this work with ordinary classes? do you get the same kind of equivocation?
20:19:51 <vixey> that's not it SamB :p
20:19:59 <HairyDude> though not quite as critical since it's type safe
20:20:09 <dolio> With normal classes, you just get inconsistent behavior. It doesn't defeat the type system.
20:20:14 <HairyDude> right
20:20:52 <dolio> Although overlapping instances there have their own oddities.
20:20:59 <HairyDude> with overlapping type instances you get inconsistent behaviour at the type level, which is a Bad Thing. :)
20:21:39 <SamB> vixey: well, that's what *I* was googling for
20:21:56 <SamB> vixey: I thought maybe chrestomathy was a parody of that
20:22:14 * HairyDude wishes Haskell had ML's module system :)
20:22:17 <dolio> Like, I think you can write "instance C a where foo = ..." "instance C Int where foo = ..." and then "bar :: a -> whatever ; bar a = foo a" and if you call foo with an Int, it will use the "C a" istance.
20:22:36 <dolio> Because it's universally quantified, not constrained.
20:23:44 <HairyDude> if you want the specific instance there you'd declare it "bar :: C a => a -> whatever" I suppose
20:23:54 <HairyDude> cos then you get the dictionary
20:25:04 <dmead> > let add a b = a + b in add == add
20:25:04 <lambdabot>       No instance for (Eq (a -> a -> a))
20:25:04 <lambdabot>        arising from a use of `==' at...
20:25:10 <dolio> Hmm, doesn't seem to be working. Maybe you need existential types.
20:25:20 <dolio> It definitely works with those.
20:25:21 <dmead> can you test functions for equality, ever?
20:25:28 <vixey> dmead: yeah sure
20:25:34 <dmead> like how
20:25:43 <vixey> say we have f, g : Bool -> Bool
20:25:54 <dmead> k
20:26:22 <dmead> > foldr == foldr
20:26:23 <lambdabot>       No instance for (Eq ((a -> b -> b) -> b -> [a] -> b))
20:26:23 <lambdabot>        arising fr...
20:26:36 <Cale> dmead: There's no instance of Eq, of course.
20:26:52 <dmead> i guess you couldn't really make one either
20:26:53 <dmead> woops
20:26:57 <Cale> dmead: But for functions with specific domains and codomains we can construct equality tests
20:27:04 <dmead> right
20:27:28 <blackh> m forgiving you. Please go and play club penguin with your sister. Please. I'm begging you! I wiill go and do that right now, don't youm worry. You have
20:27:51 <HairyDude> instance Eq (Bool -> Bool) where f == g = (f True == g True) && (f False == g False)
20:27:58 <roconnor> or functions of type (Nat -> Bool) -> Integer
20:28:01 <Cale> Surprisingly, there are infinite types T for which functions of type T -> X can be compared for equality (provided we can assume they are total functions)
20:28:11 <roconnor> or really any functions whose domain is compact.
20:28:11 <dmead> hmm!
20:28:22 <HairyDude> in fact instance Eq b => Eq (Bool -> b) where <same as above>
20:29:57 <roconnor> instance Eq b => Eq (Nat -> Bool) -> b where <complex instance>
20:30:14 <HairyDude> that would be an inductive proof?
20:30:33 <dmead> doesn't have to be
20:30:43 <roconnor> equal :: Eq y => (Cantor -> y) -> (Cantor -> y) -> Bool
20:30:45 <dolio> Anyhow, OverlappingInstances + ExistentialQuantification = IncoherentInstances, more or less.
20:30:50 <roconnor> equal f g = forevery(\a -> f a == g a)
20:31:04 <roconnor> forevery p = not(forsome(\a -> not(p a)))
20:31:11 <roconnor> forsome p = p(find(\a -> p a))
20:32:00 <roconnor> > find_i :: (Cantor -> Bool) -> Cantor
20:32:01 <lambdabot>   Not in scope: `find_i'    Not in scope: type constructor or class `Cantor' ...
20:32:01 <roconnor> > find_i p = if forsome(\a -> p(Zero # a))
20:32:02 <lambdabot>   <no location info>: parse error on input `='
20:32:03 <roconnor> >            then Zero # find_i(\a -> p(Zero # a))
20:32:04 <lambdabot>   <no location info>: parse error on input `then'
20:32:04 <roconnor> >            else One  # find_i(\a -> p(One  # a))
20:32:05 <lambdabot>   <no location info>: parse error on input `else'
20:32:10 <roconnor> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/
20:33:24 <vixey> that forevery p = not(forsome(\a -> not(p a)))
20:33:28 <vixey> is soooo clevel :)
20:41:05 <HairyDude> oh great, libghc6-fgl-doc depends on strictly older versions of ghc6-doc than are available in the repos.
20:42:03 <jackdaw> i had something like that on arch for ab it
20:42:17 <HairyDude> ab it?
20:42:47 <HairyDude> it doesn't help that the paper describing fgl is hopelessly out of date.
20:43:59 <jackdaw> a bit
20:44:14 <HairyDude> oh, I see. it uses the name "Gr" instead of "Graph"
20:44:16 <jackdaw> i'm trying to go from three to four finger touch typing
20:46:28 <Cale> HairyDude: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
20:46:53 <Cale> (docs are linked from there)
20:47:25 <HairyDude> yes, I know. but haddock docs aren't that helpful in understanding how it works
20:47:25 <Cale> Generally I prefer to cabal-install all the Haskell libraries I'm using, as the debian/ubuntu packages are always hopelessly out of date.
20:47:40 <Cale> hmm
20:47:58 <Cale> What are you wondering about how to do?
20:48:10 <vixey> jackdaw change your keyboard layout
20:51:35 <gwern> @quote phantom
20:51:35 <lambdabot> DavidRoundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
20:53:03 <vixey> hey gwern
20:53:29 <vixey> gwern, chrestomathy
20:54:57 <kadaver> are arrays really O(1)?
20:55:03 <kadaver> haskell arrays
20:55:13 <HairyDude> also, hoogle doesn't know about fgl.
20:55:17 <HairyDude> kadaver: yes
20:55:47 <HairyDude> kadaver: lists aren't, though
20:56:09 <roconnor> kadaver: not really, but neither are C arrays
20:56:22 <roconnor> kadaver: they are limited to less than 2^64 entries
20:56:26 <HairyDude> how do I tell my local hoogle about fgl?
20:56:43 <HairyDude> roconnor: in what sense are they not O(1)?
20:57:30 <roconnor> HairyDude: they can't grow arbitrarily large, so the whole O notation makes no sense for it
20:57:34 <kmeyer> anyone familiar with the "Visitor" model? I feel like this ties into monads or monoids or functors somehow, but I'm not exactly sure...
20:57:39 <Cale> There's no way to have an indexed datastructure where lookup is better than O(log n) -- it takes at least O(log n) time just to examine all the bits of the index.
20:57:41 <roconnor> if they could grow arbitrarily large, they would no longer be O(1)
20:57:42 <HairyDude> ah, right
20:58:12 <andresj> so i am using a do block on the EventM monad (gtk2hs); I have (do canvas <- eventWindow; window <- widgetGetDrawWindow canvas; otherStatements; return True) I know the second statement is wrong (ill say the types in a bit) but I don't know how to fix it.
20:58:31 <andresj> eventWindow :: EventM any DrawWindow
20:58:38 <Axman6> kmeyer: i am, sort of. i couldn't see any relation though :\
20:58:52 <Axman6> seems a very strongly object oriented model to me
20:58:52 <andresj> widgetGetDrawWindow :: (WidgetClass widget) => widget -> IO DrawWindow
20:58:57 <HairyDude> I imagine kadaver meant "constant time lookup" which I think they are.
20:59:06 <Cale> Try   window <- lift (widgetGetDrawWindow canvas)
20:59:10 <Cale> or...
20:59:13 <Cale> Try   window <- liftIO (widgetGetDrawWindow canvas)
20:59:34 <kmeyer> Axman6: well, the concept of applying a function to every node in a data type without caring about the structure of the data type
20:59:40 <kadaver> ok but static arrays are O(1)
20:59:48 <kmeyer> fmap or something
20:59:54 <Cale> kadaver: If you ignore the log factor, yes :)
20:59:55 <Axman6> kmeyer: sounds like Functor then
21:00:04 <kmeyer> ok :)
21:00:32 <Cale> kadaver: Or if you assume they're bounded in size.
21:00:45 <Axman6> when we were learnig about visitors at uni this semester, i was trying to relate them to haskell, and couldn't see an easy way of doing it
21:00:47 <Cale> (which kind of makes asymptotic questions meaningles)
21:00:52 <Cale> meaningless*
21:01:05 <HairyDude> "do something" doesn't particularly make sense in a functional context
21:01:17 <Cale> Axman6: maybe Data.Traversable is what you're looking for?
21:01:28 <andresj> Cale: thank you, but i still get errors:     No instance for (Graphics.UI.Gtk.Types.WidgetClass Graphics.UI.Gtk.Types.DrawWindow)      arising from a use of `widgetGetDrawWindow' at Main.hs:29:54-79
21:01:29 <Axman6> Cale: you mean kmeyer?
21:01:37 <gwern> vixey: 'a collection of choice literary passages, used especially as an aid in learning a foreign language.'
21:01:53 <Cale> Axman6: Well, I just read your comment about not being able to relate visitor patterns to Haskell.
21:01:54 <Axman6> but yeah, sounds about right, i don't know much (or anything really) about Data.Traversable
21:02:07 <HairyDude> "applying a function" implies the question "what happens to the result?"
21:02:11 <andresj> Cale: or maybe im just using the library wrong and the error has nothing to do with the Monad complexities...
21:02:17 <jackdaw> i was kind of hoping that the tunes.org link was a haskell themed webradio station :(
21:02:19 <andresj> i mean, this new one
21:02:21 <Cale> :t Data.Traversable.for
21:02:22 <lambdabot> forall (t :: * -> *) a (f :: * -> *) b. (Applicative f, Data.Traversable.Traversable t) => t a -> (a -> f b) -> f (t b)
21:02:40 <HairyDude> ah, I haven't looked at Traversable
21:02:45 <HairyDude> there's Foldable as well
21:03:45 <kmeyer> HairyDude: right, I'm assuming it's functional and the result is just a new data type of the resultant type, but with the same structure
21:03:55 <HairyDude> correct
21:03:55 <Cale> andresj: I think it's complaining that the DrawWindow isn't a Widget?
21:04:10 <HairyDude> in fact, that's what the functor laws mean.
21:04:16 <andresj> Cale:  yes, but im pretty sure it is...
21:04:22 <Cale> hmm
21:05:02 <andresj> although the docs http://haskell.org/gtk2hs/docs/devel/Graphics-UI-Gtk-Gdk-DrawWindow.html doesnt hint at it, so maybe im wrong
21:05:59 <Cale> andresj: If you load the relevant modules up in GHCi and :info Graphics.UI.Gtk.Types.WidgetClass  you should get a list of instances...
21:06:25 <andresj> oh really? thank you Cale! I never knew that, haha
21:06:27 <kmeyer> HairyDude: see, that's why I thought of #haskell :)
21:06:37 <HairyDude> :)
21:06:37 <kmeyer> my memory of typeclassopaedia isn't as sharp as it should be
21:06:49 <Cale> andresj: You can also :info Graphics.UI.Gtk.Types.DrawWindow
21:06:58 <povman> @hoogle (Monad m) => m a -> m ()
21:06:58 <lambdabot> Control.Monad forever :: Monad m => m a -> m ()
21:06:58 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
21:06:58 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
21:07:24 <HairyDude> #haskell is nice, because it's a collection of people who are ready to have their brains picked :)
21:07:37 <Cale> andresj: Oh! The canvas *already* is a DrawWindow
21:07:54 <Cale> andresj: So you don't have to use widgetGetDrawWindow at all.
21:08:23 <andresj> hum, apparently its a DrawableClass, and alol whatoh really? wow, i thought of that@the beginning but then i passed it out, lol; thank you, ill try that :)
21:08:55 * wli is running out of 32-bit address space.
21:09:09 <glguy> someone should invent a processor with more address space
21:09:24 <HairyDude> like a 64 bit one?
21:09:43 <wli> It's preventing my Project Euler solution from running overnight.
21:09:59 <glguy> the project euler rules prevent your solution from running overnight :)
21:10:12 <wli> Yes, better hardware would let it complete.
21:10:30 <andresj> WOW!! It worked! hahaha thank you Cale! much appreciate help :)
21:10:39 <Cale> andresj: no problem :)
21:10:50 <HairyDude> anyone know how to tell my local copy of hoogle about fgl?
21:10:52 <wli> I don't have better hardware and it's not proper to let it run so long anyway.
21:10:58 <glguy> wli, what problem?
21:11:05 <wli> #216
21:11:39 <wli> I'm sieving vaguely Eratosthenes -style but it's still not quite fast enough.
21:18:47 <HairyDude> > let primes = 2 : filter (\n -> all (\p -> n `mod` p /= 0) (takeWhile (<= (n `div` 2)) primes)) [3..] in primes
21:18:48 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
21:19:26 <dufflebunk> wli: No project euler problem should need to run for more than a few minutes... all the ones I've done have taken less than a few minutes
21:19:57 <wli> dufflebunk: Yes. That's part of why I'm not done.
21:22:27 <wli> http://wli.pastebin.com/m69277a6a <-- what I've got thus far
21:23:18 <kadaver> haskell is dead! long live ocaml!
21:25:42 <Eridius> o_O
21:26:59 <necroforest> haskell isn't dead
21:27:02 <necroforest> it just smells funny
21:32:32 <kadaver> who works on ML?
21:33:41 <dufflebunk> willb: wouldn't it be better to go the other way around? Find all primes < the limit, then see which satisfy the other condition?
21:33:44 <kadaver> python!
21:33:57 <clug> @echo testing
21:33:57 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "clug!n=a98sd@cpe-066-057-078-104.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo testing"]}
21:33:57 <lambdabot>  rest:"testing"
21:37:37 <clug> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me....
21:37:37 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "clug!n=a98sd@cpe-066-057-078-104.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\\
21:37:37 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me...."]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!
21:37:37 <lambdabot> ops please ban me...."
21:37:40 <clug> @echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me.....
21:37:40 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "clug!n=a98sd@cpe-066-057-078-104.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \\\\\\\\\\
21:37:40 <lambdabot> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\!ops please ban me....."]} rest:"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
21:37:42 <lambdabot> !ops please ban me....."
21:39:15 <vixey> clug that's interesting
21:39:29 <vixey> how does that work?
21:39:49 <vixey> oh I see it always does that
21:41:59 <scutigera> read doesn't parse .918, suggestions on a real parser ?
21:43:27 <MyCatVerbs> If you want to special-case just that one issue, )read . (\s -> case s of ('.' : rest) -> '0' : '.' : rest; _ -> s))
21:44:05 <MyCatVerbs> Otherwise, Parsec is pretty civilised.
21:44:22 <scutigera> good suggestion. I'd like to leave writing a parser combinator for sometime in the future - e.g. after I understand how IO works...
21:45:14 <roconnor> > .918
21:45:15 <lambdabot>   <no location info>: parse error on input `.'
21:47:46 <scutigera> strangely, it seems that I am _always_ writing a float parser for one reason or another.
21:47:52 <MyCatVerbs> scutigera: the other suggestion would be to not accept .918 as a valid number, since no language other than BASIC actually accepts that. ;)
21:48:55 <roconnor> > readFloat ".918"
21:49:00 <lambdabot>   []
21:49:08 <roconnor> @type readFloat
21:49:17 <scutigera> MyCatVerbs: well, that's why I'm always writing float parsers, to handle strange input of some sort.
21:49:18 <lambdabot> forall a. (RealFrac a) => String -> [(a, String)]
21:49:25 <roconnor> > readFloat "0.918"
21:49:28 <lambdabot>   [(0.918,"")]
21:49:44 <MyCatVerbs> Okay, I'm wrong there. Both Python and dc accept .918, so I suppose Perl and a few others must too.
21:49:49 <scutigera> roconnor: ding-ding-ding, we have a winner !
21:49:57 <MyCatVerbs> Notably C doesn't, but whatever.
21:50:53 <MyCatVerbs> scutigera: I'd just take the lazy route and special case it.
21:51:19 <scutigera>  Real.fromString(".918") -> SOME 0.918 : real option   SML likes it too, but ML also prints negative numbers with ~, which is _very_ annoying
21:51:36 <roconnor> > lexDigits ".918"
21:51:40 <lambdabot>   []
21:51:43 <scutigera> MyCatVerbs: special casing in progress
21:52:49 <MyCatVerbs> > let { readUglyFloat s@('.':_) = read $ '0' : s; readUglyFloat s@('-':'.':more) = read $ '-':'0':'.':more' readUglyFloat s = read s; } in map readUglyFloat ["0.9",".9","-0.9","-.9"]
21:52:50 <lambdabot>   <no location info>: parse error on input `='
21:53:02 <MyCatVerbs>  a
21:53:04 <clug> @echo lol
21:53:04 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "clug!n=a98sd@cpe-066-057-078-104.nc.res.rr.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo \SOH\SOH\
21:53:04 <lambdabot> SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOHlol"]} rest:
21:53:04 <lambdabot> "\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\SOH\
21:53:04 <lambdabot> SOHlol"
21:53:06 <clug> wth?
21:53:10 <MyCatVerbs> Tarnation on a stick.
21:53:14 <vixey> lol
21:53:28 <vixey> SOH is the code for the last ascii char I think
21:53:28 <scutigera> attack of the paste key ?
21:53:33 <vixey> > ord '\SOH'
21:53:34 <lambdabot>   1
21:53:37 <MyCatVerbs> > let { readUglyFloat s@('.':_) = read $ '0' : s; readUglyFloat s@('-':'.':more) = read $ '-':'0':'.':more; readUglyFloat s = read s; } in map readUglyFloat ["0.9",".9","-0.9","-.9"]
21:53:38 <lambdabot>   [* Exception: Prelude.read: no parse
21:53:41 <vixey> oh the first.. not the last
21:53:57 <MyCatVerbs> > let { readUglyFloat s@('.':_) = read $ '0' : s; readUglyFloat s@('-':'.':more) = read $ '-':'0':'.':more; readUglyFloat s = read s; } in map readUglyFloat ["0.9",".9","-0.9","-.9"] :: [Float]
21:53:58 <lambdabot>   [0.9,0.9,-0.9,-0.9]
21:54:22 <roconnor>  let { readUglyFloat s@('.':_) = read $ '0' : s; readUglyFloat s@('-':'.':more) = read $ '-':'0':'.':more; readUglyFloat s = read s; } in map readUglyFloat ["0.9",".9","-0.9","-.9","Infinity","NaN"] :: [Float]
21:54:32 <scutigera> MyCatVerbs: that's easy for you to type ;-)
21:54:35 <roconnor> > let { readUglyFloat s@('.':_) = read $ '0' : s; readUglyFloat s@('-':'.':more) = read $ '-':'0':'.':more; readUglyFloat s = read s; } in map readUglyFloat ["0.9",".9","-0.9","-.9","Infinity","NaN"] :: [Float]
21:54:36 <lambdabot>   [0.9,0.9,-0.9,-0.9,Infinity,NaN]
21:55:33 <MyCatVerbs> scutigera: well, it doesn't have to be typed more than once. ;P
21:55:56 <scutigera> what's '$' for ? I was trying to find that the other day...
21:56:12 <roconnor> > readFloat "-1"
21:56:14 <lambdabot>   []
21:56:17 <roconnor> > readFloat "1"
21:56:18 <lambdabot>   [(1.0,"")]
21:56:21 <roconnor> pfft
21:56:24 <MyCatVerbs> scutigera: (f $ a) = f a.
21:56:25 <roconnor> readFloat is crap
21:56:39 <MyCatVerbs> scutigera: it just has a really low precedence, so that it tends to split expressions up.
21:57:19 <MyCatVerbs> It's just to save on brackets. For example, (show $ '0':more) is the same as (show ('0':more)).
21:57:41 <scutigera> MyCatVerbs: ohhh, so read $ '0' : s written as read '0' : s would evaluate read '0' first ?
21:57:43 <MyCatVerbs> Er, parens, not brackets, sorry.
21:58:23 <scutigera> mmmm...yummy syntactic sugar
21:58:33 <dropdrive> I have a (very large) text file, with each line containing 6 integers.  I want to read this file, and output the second and fourth columns as 4-bit integers.  I want to do this as fast as possible; can anyone suggest packages for me to look at?
21:58:40 <MyCatVerbs> scutigera: yes, function application binds really tightly, so (read '0' : more) gets parsed as ((read '0') : more), which is just a big pile of type mismatch fail. :)
21:58:51 <dropdrive> Ack, as 32-bit integers (i.e. in binary).
21:59:15 <MyCatVerbs> dropdrive: Data.ByteString and Data.Binary.
21:59:32 <scutigera> MyCatVerbs: big, _steaming_ pile of type mismatch fail ! LOL
22:00:10 <dropdrive> MyCatVerbs: Ah, that's what I'm looking at now.  Thanks.  And do you think something like this can be parallelized well to > 1 core?
22:00:46 <clug> why doesn't lambdabot support any ctcp?
22:00:55 <clug> You can't even version it
22:02:07 <MyCatVerbs> dropdrive: I don't think so, no.
22:02:29 <MyCatVerbs> Well actually you could, quite happily enough.
22:03:07 <MyCatVerbs> It's trivial if the lines are all of fixed length, a little awkward if they're of variable length, and impossible if you don't have random access to the file.
22:04:11 <MyCatVerbs> Plus it's very, very unlikely to gain anything from being done in parallel if the file is really large, as the processing time will be miniscule compared to how long it'll take to read the text off disk platters.
22:06:06 <scutigera> dropdrive: any chance the data can be generated as a binary file ?
22:06:08 <dropdrive> Okay, that makes sense.  Ultimately, I want to write something that is customizable from the command line, e.g. ignore 1,2,3 columns, convert 4th column to 64-bit floats, and 10'th column to a 5-byte string, etc.
22:06:18 <dropdrive> scutigera: No, it's legacy crap :)
22:08:28 <scutigera> MyCatVerbs: special case successul, luckily there weren't any other "special" floats.
22:09:42 <HairyDude> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4478
22:10:44 <Cale> clug: It's a bot, and it doesn't have any code to respond to CTCP.
22:11:28 * HairyDude wonders what clug is up to
22:11:47 <clug> Oh, I was trying to mess with the bot but it appears to ignore itself
22:12:01 <clug> I did get it to call !ops though
22:12:44 <HairyDude> ignoring itself would be a very sensible thing for it to do :)
22:13:04 <Cale> http://picturesforsadchildren.com/ -- hehe
22:13:19 <HairyDude> yeah, that's a good one
22:14:14 <HairyDude> oh, you mean that specific strip. I meant the comic in general
22:17:53 <MyCatVerbs> scutigera: eeeexcellent.
22:18:22 <dropdrive> Is it easy to install Data.Binary in archlinux?  Do I need to install from AUR, or is there an easier way?
22:19:07 <MyCatVerbs> dropdrive: pacman -S cabal-install, and then just cabal install things by their names on hackage.
22:19:32 <dropdrive> Thanks!
22:19:58 <HairyDude> ah, I see, you have to insert the vertices first
22:28:18 <araujo> no more firefox !
22:28:22 <araujo> http://haskell.org/~luisfaraujo/haskell_browser.png
22:28:24 <araujo> :)
22:28:50 <Cale> araujo: fun :)
22:28:57 <araujo> Cale, :)
22:29:10 <araujo> just a few extra handy options , a nice way to extend it, and done :P
22:29:41 <wks> What is the advantage over firefox?
22:29:58 <araujo> wks, i hope ... that i get less crashes
22:30:02 <araujo> mainly
22:30:15 <araujo> plus ... haskell as the extension language
22:30:47 <dolio> You can have both memory leaks *and* space leaks.
22:32:14 <araujo> the simpler, the better .... and not many of those problems
22:32:21 <scutigera> dolio: I've been trying to figure out space leaks, after all haskell has GC.  Lazy causes many bytes of "promises" to be saved on the heap ?
22:32:39 <araujo> i don't want to have a complete suite for my browser
22:32:48 <araujo> i just usually check very simple pages
22:33:08 <dolio> Space leak is usually meant as your algorithm taking more memory than expected.
22:33:26 <jeffwheeler> I'm trying to collapse a [String -> Maybe Integer], but I'm running into problems; there seems to be a conflicting instance of Monoid, (Monoid b) => Monoid (a -> b).
22:33:27 <dolio> In long running programs, though, you can leak memory by building up unevaluated stuff, yes.
22:33:35 <jeffwheeler> Here's the code that's causing the problems: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4479#a4479
22:33:52 <jeffwheeler> I know that mappend is very ugly right now, but I'm trying to get it to compile, first.
22:34:05 <jeffwheeler> The verbosity makes it easier for me to understand until I can get it working.
22:34:06 <scutigera> dolio: so strict languages (with gc) can have space leaks, but not as (potentially) as bad as lazy ?
22:34:16 <Cale> jeffwheeler: Define a newtype, perhaps.
22:35:02 <dolio> People usually have better intuition about how much memory an algorithm in a strict language will use, so they tend not to be surprised.
22:35:36 <dolio> Like, if you compute a powerset (with lists) in a strict language, people expect it to use lots of memory.
22:36:21 <dolio> However, in Haskell, you can write a powerset function that, when printed (say) the overall program should run in O(1) space.
22:36:39 <dolio> However, a small tweak will make it eat memory instead.
22:37:15 <dolio> Which would likely be described as a space leak. However, most people wouldn't describe the strict program as a space leak, since everyone expects it to eat memory.
22:39:31 <dolio> It is, of course, possible to write code that leaks space in a lazy language beyond that which would be used in a strict language, of course.
22:40:08 <dolio> Building up thunks is a potential cause.
22:40:51 <scutigera> I get a little worried when I see things like "don't use foldl, use foldl', because foldl causes space leaks".  Seem like a nasty problem, although RWH says not so much in practical terms.
22:41:16 <scutigera> Meanwhile I'm using foldl :-)
22:43:57 <dolio> I think the usual problem with foldl is stack overflows.
22:44:11 <dolio> I guess if you have a big enough list, it could start to become a memory issue.
22:44:35 <edwardk> scutigera: in general if you know you have 'productive corecursion' in your fold you can use foldr, then you don't have the stack worries, etc.
22:45:37 <edwardk> foldl' has its place, but mostly when you fold with arithmetic operators. foldr is typically much better when the output is a data structure, especially if you'll only partially traverse it
22:47:00 <Peaker> @src foldl'
22:47:00 <lambdabot> foldl' f a []     = a
22:47:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:47:52 <Peaker> will this be right?  seq x y = const y $! x ?
22:48:34 <scutigera> Hah : $! ?
22:48:43 <dolio> const y $! x = x `seq` const y x = x `seq` y
22:52:43 <jeffwheeler> Cale: Using newtype seems to have worked, thanks; however, it seems to have complicated the code a lot, adding many Bars, etc. -- http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4479#a4480
22:53:26 <jeffwheeler> And I'm not quite sure how to clean up mappend; I would expect to be able to do something like: = Bar $ \s -> (f s) `mappend` (g s), but Monoid Integer doesn't exist . . .
22:53:51 <jeffwheeler> Why does Maybe's Monoid instance need the Maybe's type variable to be an instance of Monoid?
22:54:17 <Peaker> @pl \s -> (f s) `mappend` (g s)
22:54:17 <lambdabot> liftM2 mappend f g
22:54:47 <jeffwheeler> Peaker: unfortunately, the original doesn't work like I want
22:55:25 <Peaker> > Just 5 `mplus` Just 6
22:55:26 <lambdabot>   Just 5
22:55:31 <Peaker> > Nothing `mplus` Just 6
22:55:32 <lambdabot>   Just 6
22:55:52 <Peaker> @src (->) mappend
22:55:52 <lambdabot> Source not found. My brain just exploded
22:56:51 <Peaker> jeffwheeler: you could define an instance of MonadPlus (->)
22:57:05 <Peaker> jeffwheeler: cause MonadPlus (Maybe a) seems to do what you'd like?
22:57:29 <jeffwheeler> Peaker: MonadPlus is exactly what I wanted, and the Maybe instance works just like I'd like. I needn't implement my own.
22:57:32 <jeffwheeler> Peaker: thanks :)
22:58:09 <Peaker> jeffwheeler: but I don't think there's a (->) MonadPlus. You can of course use the function applicative to mplus the maybes
22:58:13 <jeffwheeler> So, I suppose mappend tries to combine the values within two "Just"s, while mplus just gets the first one.
22:58:24 <Peaker> jeffwheeler: yep
23:00:34 <MyCatVerbs> > mappend (Nothing) (Nothing) :: Maybe (Sum Int)
23:00:35 <lambdabot>   Nothing
23:01:04 <MyCatVerbs> > mconcat [Just (Sum 5),Nothing,Nothing,Just (Sum 11),Nothing] :: Maybe (Sum Int)
23:01:05 <lambdabot>   Just (Sum {getSum = 16})
23:01:37 <Peaker> > msum [Just (Sum 5),Nothing,Nothing,Just (Sum 11),Nothing] :: Maybe (Sum Int)
23:01:38 <lambdabot>   Just (Sum {getSum = 5})
23:03:54 <mreh> what type constructors other than (->), [] and (type1, ... typen) that are parameterised are there?
23:04:03 <mreh> can I make my own?
23:04:10 <vixey> yes you can
23:04:12 <mreh> Maybe....
23:04:15 <mreh> that's one isnt it
23:04:31 <vixey> data Tree a = Leaf a | Branch (Tree a) (Tree a)
23:04:35 <vixey> for example now there is a new one
23:04:43 <mreh> so, type variables are always lowercase
23:06:05 <Peaker> mreh: yeah
23:06:14 <Peaker> mreh: their first letter, anyway
23:06:14 <mreh> i remember in miranda, you use strings of asterisks
23:06:21 <mreh> uuuugly
23:06:29 <mreh> unary alphabet
23:06:42 <Peaker> mreh: how old are you?
23:06:47 <scutigera> I think I like the ML convention of type variables : 'a.  The code is a little harder to read in haskell, thought not too bad.
23:06:48 <mreh> 22
23:06:52 <Peaker> Miranda is like ancient? :)
23:07:05 <mreh> my fp tutor is anchient
23:07:15 <Peaker> scutigera: I think its a little easier, but matter of taste, probably
23:08:02 <scutigera> Peaker: I'm getting used to it faster than I thought I would.
23:08:27 <mreh> i think the makers of Haskell parted ways with Miranda's
23:08:31 <mreh> at some point
23:09:17 <edwardk> mreh: well, the miranda guy wouldn't let them make his language a standard basically
23:09:43 <edwardk> mreh: so the haskell folks used it as a starting point for design, but had to make it deliberately different enough that folks wouldn't be confused at his request
23:10:06 <mreh> there isnt alot different
23:10:12 <Peaker> was Miranda a language by one guy?
23:10:35 <edwardk> http://en.wikipedia.org/wiki/Miranda_(programming_language)
23:10:37 <mreh> * ** *** **** ***** etc for type variables is the only difference I'm aware of
23:10:44 <mreh> oh, and comments you use ||
23:11:04 <edwardk> david turner had a little company selling miranda to corporate users at the time haskell was getting started
23:11:04 <Peaker> Cale: do you remember the mfoldr/append MList problem?
23:11:21 <Peaker> mreh: type-classes didn't exist in Miranda, I'm pretty sure
23:11:50 <mreh> oh yes, that's true also
23:11:56 <edwardk> typeclasses were a "wadlerism", created for haskell
23:12:03 <Cale> Peaker: Yeah, I was really tired at the time though.
23:12:06 <mreh> 0.o
23:12:15 <mreh> Wadlerism
23:13:24 <Cale> There's a fair amount of difference, especially by this point... though Haskell was designed as an open version of what Miranda was.
23:13:35 <Peaker> list comprehensions originated in Miranda?
23:13:36 * edwardk is looking for a good name for a zipper which has a big consecutive gap rather than a single value hole. right now i'm just referring to it as a 'gapped' structure
23:14:00 <mreh> value-hole
23:14:05 <mreh> is that a technical tern
23:14:08 <mreh> term*
23:14:15 <edwardk> single-value hole
23:14:20 <vixey> "two zippers"
23:14:25 <edwardk> one-hole context.
23:14:54 <Peaker> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4481#a4481 -- do you think it is possible to define append in terms of mfoldr rather than mfoldr', or possible to define either of mfoldr/mfoldr' in terms of the other?
23:15:25 <edwardk> vixey: well, its the left fox derivative of a right fox derivative (or vice versa) so the zippers aren't in general position
23:16:49 <edwardk> vixey: and its over a GADT based applicative, where i basically simplify everything to 'pure' functions in the gap, yielding a monoid, that knows how to sew up the edges of those fox holes.
23:16:52 <mreh> do  type constructors have the same precendence as function application?
23:17:08 <vixey> Call it a warren!
23:17:13 <Cale> mreh: yes
23:17:13 <edwardk> vixey: hahahaha
23:17:51 <Cale> Peaker: hmm, that seems like a tricky question. When I tried it, it seemed that the order of execution was hard to get right.
23:18:04 <edwardk> i suppose 'fox hole' isn't even that bad ;)
23:18:08 <mreh> how do i do local type definitions with lambdabot
23:18:42 <mreh> > data MyInt = Zero | Suc MyInt
23:18:43 <lambdabot>   <no location info>: parse error on input `data'
23:18:52 <Cale> mreh: You put them in a file and load it.
23:19:00 <Peaker> Cale: yeah - I accidentally make the whole thing "strict" (in the sense of executing all of the mlist actions before getting any given action done)
23:19:57 <Cale> Peaker: I think because mfoldr doesn't necessarily produce an MList, it's impossible to avoid running those actions prematurely.
23:20:48 <mreh> > Maybe Maybe Maybe "Hello"
23:20:49 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe...
23:21:49 <Peaker> Cale: if the consFunc executes the rhs arg before executing its own thing - it will execute the whole mlist
23:25:39 <wks> > Just "Hello"
23:25:40 <lambdabot>   Just "Hello"
23:26:14 <Peaker> Cale: so if I use the (m b) in consFunc to be sort of an accumulator -- then it forces me to execute it first, which forces the whole mlist
23:26:17 <mreh> > Just Just Just "Hello"
23:26:17 <lambdabot>   Couldn't match expected type `(a -> Maybe a) -> [Char] -> t'
23:26:34 <jeffwheeler> > Just $ Just $ Just "Hello"
23:26:34 <mreh> 0.o
23:26:35 <lambdabot>   Just (Just (Just "Hello"))
23:26:39 <vixey> > iterate Just "Hello"
23:26:40 <mreh> right
23:26:40 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
23:26:40 <lambdabot>        Ex...
23:26:49 <jeffwheeler> > fix Just
23:26:50 <lambdabot>       Occurs check: cannot construct the infinite type: a = Maybe a
23:26:50 <lambdabot>        Ex...
23:27:15 <Cale> > Just . Just . Just $ "Hello"
23:27:17 <lambdabot>   Just (Just (Just "Hello"))
23:27:38 <mreh> I like Cale's better
23:27:53 <jeffwheeler> Mine's shorter, though. ;)
23:28:17 <mreh> but it's smelly
23:28:22 <jeffwheeler> Indeed.
23:28:43 <jeffwheeler> I like Yi's unicode for composition; it has a middle dot character.
23:28:48 <mreh> code smell is obviously an expression of a programmers inability to express themselves
23:29:08 <mreh> OH RLY?!
23:29:15 <jeffwheeler> Mhmm. It's purty.
23:29:23 * vixey uses that too
23:29:43 <jeffwheeler> > Just  Just  Just $ "Hello"
23:29:43 <lambdabot>   Not in scope: `'Not in scope: `'
23:29:47 <jeffwheeler> :(
23:30:12 <jeffwheeler> I thought GHC accepted the Unicode ones . . .
23:30:47 <wli> I'm seeing almost none of the primes' residues collide, so my queue is getting huge as things progress.
23:30:48 <mreh> how does it know you're typing a . instead of a middle dot
23:30:52 <Cale> jeffwheeler: It allows unicode names, it doesn't mean that they're defined in the Prelude...
23:31:18 <mreh> put . = 
23:31:20 <jeffwheeler> Cale: yeah; some of the common things are defined as Unicode, though, right? I think -> is
23:31:34 <mreh> is there a unicode lambda?
23:31:42 <Cale> Oh, if it accepts that, it would be because -> is not the name of a function.
23:31:51 <vixey> mreh, There is the WHOLE greek alphabets
23:32:03 <jeffwheeler> mreh: yep: s   s ++ "test"
23:32:03 <vixey> And it's got phi twice
23:32:25 <Cale> I'm not sure we'd want to steal it for that... what if people want to use Greek identifiers?
23:32:59 <Cale> Hmm, but if there's a special magic lambda somewhere...
23:33:56 <mreh> do you memorise the unicodes for those characters?
23:34:01 <Cale> 
23:34:07 <Peaker> I wish people wouldn't be able to start using foreign languages and symbols in their code..
23:34:15 <jeffwheeler> mreh: Yi automatically renders the Unicode versions
23:34:18 <Peaker> I like my ASCII, thank you
23:34:19 <Cale> No, I have an IME which lets me type them.
23:34:34 <RayNbow> 7 bits ought to be enough for everyone, Peaker? :p
23:34:53 <Cale> We could use the lambda I just provided, which is U+1D706 Mathematical Italic Small Lamda
23:35:15 <MyCatVerbs> Cale: what font are you using that includes that codepoint?
23:35:19 <Peaker> RayNbow: 7 bits per symbol ought to be enough for programmers writing code that English speakers understand..
23:35:40 <Cale> MyCatVerbs: I don't know. I have pretty good unicode coverage provided by dozens of fonts...
23:35:57 <wli> 1.3 billion Chinese programmers can't be wrong. ;)
23:36:16 <MyCatVerbs> 1.3 billion ANYTHING can be very wrong indeed.
23:36:35 <vixey> I would love to get an insight into programming in other cultures
23:36:54 <MyCatVerbs> But I wouldn't argue with 1.3 gigaprogrammers at once. Discretion the better part of valour, etc.
23:37:31 <Cale> I don't know about Chinese programmers, but I've been told Japanese programmers usually use (perhaps badly chosen) English identifiers.
23:37:44 <RayNbow> > let lb x = fmap (\a -> a (lb x)) x    in    lb [length, \x->x!!0+x!!2, const 3]
23:37:45 <lambdabot>   [3,6,3]
23:37:55 <vixey> yeah pretty much all the japanese code I saw is like that' with lots of japanese text in comments
23:38:08 <wli> 22655 singletons, 387 pairs, 27 triples, and 1 quadruple.
23:38:10 <horms> map (\x -> "Wrong") [ 1 .. 13000000000 ]
23:38:31 <jeffwheeler> > map (\x -> "Wrong") [ 1 .. 13000000000 ]
23:38:32 <lambdabot>   ["Wrong","Wrong","Wrong","Wrong","Wrong","Wrong","Wrong","Wrong","Wrong","W...
23:38:48 <mreh> haha
23:38:49 <Cale> There are some issues with using Chinese characters... in particular, there are some different characters which look identical or almost identical, and character conversion can happen differently on different systems possibly creating problems.
23:39:08 <mreh> everyone in China looks the same
23:39:14 <RayNbow> you should see the code of Dutch programmers... many beginners mix English and Dutch in some way :p
23:39:26 <horms> there is also an issue of some codepoints mapping to different characters, depending on the dialect of Chinese in use (iirc)
23:39:40 <wli> This suggests the queue is getting freaking huge. There may be a data structure problem.
23:39:42 <CESSMASTER> jeffwheeler: are you sure you're using the right unicode symbol?
23:39:42 <CESSMASTER> yeah i'm impressed, it doesn't show here
23:39:53 <jeffwheeler> CESSMASTER: Which?
23:40:15 <Cale> Though, you could get away with using kana.
23:40:16 <CESSMASTER> jeffwheeler: composition
23:40:43 <jeffwheeler> CESSMASTER: I copied/pasted from my terminal, so it's what Yi uses; I think it's the standard middle dot character
23:40:50 <Peaker> Cale: Success! :-) http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4483#a4483
23:40:51 <Cale> GHC should treat Katakana as uppercase, and Hiragana as lowercase for the purposes of identifiers. That would be nice :)
23:40:54 <horms> surely the biggest problem with, for instance using the unicode lambda charcater, is people being able to type it in - i'm not sure how many people are set up to do that
23:41:23 <Peaker> Cale: the secret was in "consFunc x rest = return . cons x . mmerge $ rest" -- weird that it works up simple, eventually
23:41:36 <Cale> Peaker: hmmm...
23:41:46 <Cale> Peaker: ah, interesting.
23:41:51 <horms> eh, mixing katakana and hirugana like that would be very weird imho
23:41:55 <wli> That's also a lot of distinct prime divisors.
23:41:55 <Peaker> Cale: instead of executing the rhs arg of consFunc to give it to cons (thus executing the entire list) I embed the rhs action into the mlist's next with mmerge
23:42:09 <horms> there isn't realy a concept of case in japanese, and thats a bizarre way to try and get around it
23:42:12 <Cale> horms: Well, likely you'd just name dataconstructors entirely in katakana
23:42:24 <horms> that would make more sense
23:42:25 <Cale> horms: and variables in hiragana
23:42:41 <horms> but it would still be a little wierd
23:43:15 <Cale> I'm not sure it's any more strange than what we do with uppercase/lowercase distinction
23:44:05 <horms> i'm prepared to buy that argument, though i don't agree
23:44:55 <Cale> horms: Hmm...
23:45:24 <horms> actually its kind of an interesting discussion
23:45:30 <horms> but thinking about it
23:45:52 <horms> the only times i have had trouble with regards to people being pedantic about using katakana
23:45:57 <horms> is when dealing with the city office
23:46:16 <horms> and thats tedium that is probably best not brought into this discussion
23:46:19 <Cale> hehe
23:47:06 <Cale> I'm curious what it was -- something about filling out forms?
23:47:26 <horms> yes
23:47:32 <horms> to cut a long story short
23:47:43 <horms> if you have a name in romaji
23:47:52 <horms> then legally it has to be written in katakana sometimes
23:47:56 <horms> not hirugana
23:47:58 <horms> or kanji
23:48:02 <horms> or even romaji for that matter
23:48:04 <Cale> Interesting.
23:48:15 <horms> for instance
23:48:20 <horms> when i got married
23:48:26 <horms> and my wife took my surname
23:48:32 <horms> her new name had to be in katakana
23:48:50 <horms> (or we could go through a longer process of changing it to something else - though not something else in romaji)
23:49:13 <horms> so you can say, my name is Mr. Fu
23:49:52 <horms> and you may even choose to write that as 
23:49:53 <Cale> By romaji in this case, you mean anything written with roman letters, and not specifically a transliteration of something in Japanese.
23:50:20 <horms> but you'll need to write it as  on some forms
23:50:32 <horms> and other times Fu
23:50:40 <horms> sorry
23:50:44 <Cale> Heh, I hope the forms specify :)
23:50:50 <horms> by romaji i meant the English alphabet
23:51:02 <Cale> I figured as much :)
23:51:27 <horms> or specifically
23:51:38 <horms> not katakana, hirugana or kanji
23:52:10 <horms> actually, i didn't see that form
23:52:26 <horms> but usually they do
23:52:47 <horms> so in some legal sense hirugana and katakana are not interchanagble
23:53:02 <horms> but that probably isn't relevant
23:53:42 <Cale> Yeah, I've seen them used interchangeably in a lot of places just to make things stand out.
23:53:43 <horms> to having type  with constructor 
23:53:51 <wli> Let's see how many distinct primes there are in 50K iterations.
23:54:02 <horms> you have a point there
23:54:27 <wli> 11757 primes... interesting
