00:00:32 <copumpkin> what's wrong with that?
00:00:38 <copumpkin> > read "\"\"" :: String
00:00:40 <lambdabot>   ""
00:01:48 <ksf> dammit. I manage to get data out of my function iff I leave out the recursive call. It returns an empty list otherwise, that is.
00:02:19 <mmorrow> > foldr (.) id (repeat read) (fix show)
00:02:22 <lambdabot>   "* Exception: stack overflow
00:02:30 <mmorrow> , foldr (.) id (repeat read) (fix show)
00:02:34 <lunabot>  Stack space overflow: current size 8388608 bytes.
00:02:34 <lunabot>  Use `+RTS -Ksize' to increase it.
00:02:48 <mmorrow> > foldl (.) id (repeat read) (fix show)
00:03:01 <lambdabot>   mueval: Prelude.read: no parse
00:03:17 <ski> dolio : i have another way of doing what, which doesn't involve newtypes ?
00:03:35 <dolio> What?
00:03:42 <ski> (er, s/doesn't involve/involves/)
00:03:51 <ski> <dolio> ski has another way that involves newtypes.
00:03:58 <ski> from yesterday
00:04:22 <dolio> Oh. Writing zip(With) in terms of foldr.
00:04:23 <ski> (i can look up the logs .. just wondered if you still recalled what that was regarding)
00:04:52 <ski> ok
00:10:29 <ski> Apocalisp : if you're interested, here's my way of implementing `zipWith' in terms of `foldr' (not cheating via implementing `null',`head',`tail' (or similar) in terms of `foldr') <http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs>
00:26:05 <Qork>  why would you ever add GC to C++? isn't the whole point of using C++ that you have manual memeory management? If ou want GC why not just choose a GCed language like Java, Scala or haskell?
00:35:44 <JuanDaugherty> Qork, you had to be there. You're confusing C with C++, today they are seen by relative newcomers as the same but originally they were quite distinct.
00:36:36 <leadnose> and still are
00:37:14 <JuanDaugherty> so while when I wrote that I forgot that C++ doesn't have GC, certainly adding it would be consistent with what C++ is, namely an attempt to get a "better" C.
00:38:02 <JuanDaugherty> also memory leaks are probably the single biggest complaint about C and especially C++ programs
00:38:28 <johnw> and newbies don't blow stack constantly in Haskell?
00:38:34 <PetRat> Anyone know how to define 'init' in terms of foldr? It's question 9.13 in S. Thompson's book and I'm stumped.
00:40:24 <JuanDaugherty> C++ really since its an ugly OO developed on C and aggravates memory mgt by not providing GC as part of the language like most OO langs do.
00:40:27 <opqdonut> > foldr f [x,y,z,w]
00:40:28 <lambdabot>       Overlapping instances for Show ([a] -> [Expr])
00:40:28 <lambdabot>        arising from a us...
00:40:34 <opqdonut> ah
00:40:42 <opqdonut> > foldr f nil [x,y,z,w]
00:40:43 <lambdabot>   Not in scope: `nil'
00:40:46 <JuanDaugherty> *it's
00:40:49 <opqdonut> > foldr f n [x,y,z,w]
00:40:50 <lambdabot>   f x (f y (f z (f w n)))
00:40:52 <opqdonut> (sorry)
00:41:34 <opqdonut> PetRat: so, f needs to be some sort of conditional cons right?
00:41:56 <opqdonut> we want every f except the last one to turn into a (:)
00:42:00 <PetRat> opqdonut: I assume so.
00:42:09 <opqdonut> and the last one should be something like (\_ _ -> [])
00:42:22 <opqdonut> so how does the last invocation of f differ?
00:42:32 <PetRat> Yes, so how do you "know" that you are at the last one?
00:42:40 <PetRat> It is invoked on n.
00:43:26 <PetRat> :t init
00:43:28 <lambdabot> forall a. [a] -> [a]
00:44:11 * rwmjones can't subscribe to haskell-cafe
00:44:18 <PetRat> The initial value has to have type [a]
00:44:19 <rwmjones> when I put email addr etc into http://www.haskell.org/mailman/listinfo/haskell-cafe
00:44:26 <rwmjones> it just says "bug in mailman"
00:44:28 <PetRat> And be different that the empty list.
00:44:38 <opqdonut> PetRat: and n is something you give
00:44:43 <Qork> @src init
00:44:43 <lambdabot> init [x]    = []
00:44:43 <lambdabot> init (x:xs) = x : init xs
00:44:43 <lambdabot> init []     = undefined
00:45:05 <Qork> how the hell with foldr?
00:45:20 <dolio> It doesn't have to have type [a]. You can use foldr to produce something else, and then do a little post-processing.
00:45:30 <opqdonut> that too
00:45:48 <PetRat> So it could have type (Int, [a])
00:46:42 <Qork> but am i allowed to do length frst?
00:46:57 <Qork> i dont get it it seems i nee dmore info than foldr gives
00:46:57 <PetRat> Look like  init xs = foldr f (0,[]) xs where f a (0,_) = (1,[])   f a (1,as) = (1,a:as)
00:47:28 <PetRat> Seems awkward. I wonder why .Thompsom put in this exercise.
00:47:36 <Qork> wait i can pop
00:47:53 <mauke> > foldr (\x (k,z) -> (True, (if k then (x:) else id) z)) (False,[]) "asdf"
00:47:54 <lambdabot>   (True,"asd")
00:48:14 <copumpkin> can it be done with no post procesing?
00:48:19 <copumpkin> *processing
00:48:19 <dolio> > foldr (\x (k,z) -> (True, (if k then (x:) else id) z)) (False,[]) [1..]
00:48:21 <lambdabot>   * Exception: stack overflow
00:48:28 <shachaf> > foldr (\a b -> case b of Nothing -> Just []; Just x -> Just (a : x)) Nothing [1,2,3]
00:48:29 <lambdabot>   Just [1,2]
00:48:33 <shachaf> > foldr (\a b -> case b of Nothing -> Just []; Just x -> Just (a : x)) Nothing []
00:48:34 <lambdabot>   Nothing
00:49:05 <PetRat> Thompson hasn't introduced algebraic types yet, though.
00:50:23 <dolio> > snd $ foldr (\e p -> (e:fst p, fst p)) ([], error "init: empty list") []
00:50:24 <lambdabot>   * Exception: init: empty list
00:50:30 <dolio> > snd $ foldr (\e p -> (e:fst p, fst p)) ([], error "init: empty list") [1,2,3]
00:50:31 <lambdabot>   [2,3]
00:50:36 <dolio> Oops.
00:50:39 <dolio> That's tail.
00:51:14 <copumpkin> I don't think it can be done without post-processing
00:51:47 <dolio> Not all functions 'g' are expressible as 'g l = foldr f z l'.
00:52:13 <dolio> But they're all expressible as something like '(g l, something-else) = foldr f z l'.
00:52:26 <copumpkin> yeah, makes sense
00:52:39 <dolio> Or, primitive recursive functions 'g'.
00:52:41 <copumpkin> since you can keep pretty much anything in the something-else
00:52:45 <dancor_> i get the error "<command line>: unknown package: gtk-0.10.1" late in the build process of gtk2hs
00:52:48 <dancor_> any ideas?
00:53:07 <copumpkin> dancor_: I got same error, I just gave up :P
00:53:11 <copumpkin> I'm on mac os fwiw
00:53:17 <dancor_> i'm on debian
00:53:30 <blackh> dancor_: It works for me on Ubuntu using ghc-6.10.2
00:53:33 <dolio> Obviously there are general recursive functions that aren't reasonably expressible using foldr no matter what you do.
00:53:44 <copumpkin> yeah
00:53:48 <dancor_> hm. i'm using 6.10.1
00:53:55 <blackh> Maybe it worked because I already had it installed!
00:54:07 <dancor_> hah possibly
00:54:28 <copumpkin> anyway, bedtime
00:54:29 <blackh> That is, I was upgrading from 0.10.0
00:55:37 <Qork> damn Thompson!
00:55:56 <dancor_> dolio: is it obvious?
00:56:07 <PetRat> http://www.mibbit.com/pb/3vf2zx  I might have a solution that needs no post-processing. The key is to use the entire list as the initial value and detect it's length as the special condition.
00:56:41 <dolio> dancor_: Relatively. I can write foldr in a language without general recursion.
00:58:13 <dobblego> you could do it with para
00:58:31 <PetRat> Use a list of any length >= the original list as the "special condition". It will never accumulate to that size during the fold so the initial condition is detected only once.
00:58:35 <dolio> That too.
01:00:31 <jelly12g1n> hi i am trying to sort an list of tuples by using sortBy , i want to compare the second entry wich i have an getter for
01:00:48 <jelly12g1n> but using sortBy (compare Getvalue ) list doesnt work
01:00:56 <mauke> comparing
01:00:57 <Botje> yeah.
01:01:09 <Botje> you want compare `on` getValue
01:01:14 <Botje> or comparing getValue
01:01:22 <jelly12g1n> comparing  retunrs the following error not in scope
01:01:33 <jelly12g1n> do i need to import something for this ?
01:01:44 <mauke> @hoogle comparing
01:01:44 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:01:44 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
01:01:48 <mauke> Data.Ord
01:01:49 <Botje> comparing is in Data.Ord
01:01:56 <Botje> and `on` is in Data.Function
01:02:37 <jelly12g1n> well thanks , i can fix it from here
01:03:02 <Botje> have fun!
01:04:57 <dancor_> copumpkin: when i started over and used "./configure --with-hcflags=-O0 --disable-split-objs" from the start, it did work
01:05:06 <dancor_> blackh: ^^^
01:05:17 <dancor_> so idk
01:06:42 <blackh> Weird - I didn't give any arguments to ./configure
01:07:57 <dancor_> oh maybe that would have worked as well :)
01:08:22 <jelly12g1n> Botje: mauke thanks i fixed it , i did some IO thing  , took some time to understand IO in haskell
01:08:28 <jelly12g1n> just so different thinking
01:08:53 <Botje> yup :)
01:08:55 <Botje> did you like it?
01:09:11 <jelly12g1n> well i had to do it for Uni , but i still like it
01:09:25 <jelly12g1n> just using a couple of small functions to do big things
01:09:50 <jelly12g1n> you also need to look at the types you are dealing with
01:10:51 <jelly12g1n> if i would code this in java i would just read an txt file write it in an array and then do stuff with it , in haskell i read it put it in the right form , then sort / do something an put it in an output form
01:11:18 <Botje> yup
01:11:32 <Botje> but pure code is easier to debug, no? :)
01:11:37 <jelly12g1n> do you know any good reference for binary tree's in haskell ?
01:11:38 <Botje> no silly off-by-one errors
01:11:53 <jelly12g1n> Botje: debuggin is a bit hard , but i only get typ erorrs
01:12:14 <Botje> after a while the type errors go away :)
01:12:29 <jelly12g1n> wow , that reminds me of java , in java i didn't more none thinking coding ,
01:12:46 <Botje> that didn't quite make sense :)
01:12:54 <jelly12g1n> http://learnyouahaskell.com/chapters
01:12:57 <jelly12g1n> i like that site
01:13:03 * wunki 2
01:13:08 <Botje> thank BONUS for that
01:13:32 <jelly12g1n> it's good written , easy to read an enough examples
01:13:49 <jelly12g1n> i still need some info about binary tree's in haskell  it isnt in that site :(
01:14:18 <Botje> you don't really need info to get started
01:14:31 <Botje> once you work out the data definition you can fill in the rest
01:14:47 <jelly12g1n> ok , i have an haskell book will do some reading :P
01:15:34 <jelly12g1n> i also love my WM wich is also written in haskell :P
01:15:40 <Botje> :)
01:15:46 <Botje> which haskell book are you reading?
01:15:52 <Botje> real world haskell?
01:16:07 <jelly12g1n> the craft of functional programming
01:16:30 <Botje> ah
01:16:36 <Botje> haven't read that one :)
01:16:41 <jelly12g1n> ok
01:16:49 <jelly12g1n> well i am off reading  thanks anyway
01:16:55 <wunki> gl hf
01:17:16 <Botje> have fun
01:22:27 <QtPlaty[HireMe]> :info Identity
02:02:46 <solrize> some prob with sequence.complete.org?
02:02:58 <solrize> @seen byorgey
02:02:58 <lambdabot> I saw byorgey leaving #haskell-blah, #haskell-in-depth, #xmonad, #haskell-overflow and #haskell 8h 21m 39s ago, and .
02:03:01 <solrize> @seen byorgey_
02:03:01 <lambdabot> byorgey_ is in #haskell-overflow, #haskell-in-depth, #haskell-blah, #xmonad and #haskell. I don't know when byorgey_ last spoke.
02:09:12 <djsiegel> Can anyone tell me where Haskell Platform packages for Ubuntu might live?
02:11:17 <dcoutts> djsiegel: ask on the haskell debian mailing list
02:11:25 <djsiegel> dcoutts: thank you
02:11:35 <dcoutts> djsiegel: I'm not sure if they're all done yet
02:11:56 <djsiegel> dcoutts: ok, cool, at least I will have a place to check on the progress
02:42:18 <dobblego> @users
02:42:18 <lambdabot> Maximum users seen in #haskell: 658, currently: 579 (88.0%), active: 6 (1.0%)
02:43:37 <horms> thats a lot of people idling
02:43:43 <tombom> sorry!
02:43:46 <tombom> @users
02:43:47 <lambdabot> Maximum users seen in #haskell: 658, currently: 579 (88.0%), active: 7 (1.2%)
02:43:49 * glguy reduces the numbe
02:44:12 <Berengal> I'd think the real idlers were the ones who were active here...
02:44:21 <horms> lol
02:44:29 <horms> idle is in the eye of the beholder
02:44:50 <Berengal> If the beholder is your boss
02:45:23 * ziman pretends activity
02:45:27 <ziman> @users
02:45:27 <lambdabot> Maximum users seen in #haskell: 658, currently: 578 (87.8%), active: 8 (1.4%)
02:46:57 <boegel> should I be surprised if I run into a "Illegal instruction" error message when running a Haskell app compiled with GHC on a minimac with a PowerPC G4 processor?
02:47:32 * boegel boings
02:47:34 <boegel> @users
02:47:34 <lambdabot> Maximum users seen in #haskell: 658, currently: 579 (88.0%), active: 8 (1.4%)
02:48:11 <Itkovian> boegel: that would be a mac mini
02:48:35 <boegel> Itkovian: err, yeah :)
02:48:40 <boegel> Itkovian: whatever :)
02:48:49 <boegel> a Mac Mini running Linux, that is, not OS X :)
02:55:28 <pjolk> haskell has defineately made a static dude
02:56:12 <boegel> pjolk: ?
02:57:18 <ksf> I want to generate the same kind of code at both compile as well as runtime, should I use TH?
02:57:30 <voker57__> @hoogle a -> a
02:57:30 <lambdabot> Prelude id :: a -> a
02:57:31 <lambdabot> Data.Function id :: a -> a
02:57:31 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
02:59:09 <pjolk> boegel: i used to love python and lisp but I see their flaws clearly now
02:59:24 <pjolk> do you people write unittests?
02:59:30 <ivanm> yes, they're not called "haskell" ;-)
02:59:35 <ivanm> pjolk: some people do
02:59:39 <PeakerWork> what's everywhere?
02:59:40 <ivanm> there's also QuickCheck
02:59:52 <ivanm> then there's the lazy bastards like myself that don't do any tests! :p
03:00:08 <pjolk> I don't generally in any language, I usually write a module, make sure it works, then move on to the next, then I have a small mainprogram that binds it all togethe
03:00:08 <ivanm> @hoogle everywhere
03:00:09 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
03:00:09 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
03:00:09 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
03:00:15 <ivanm> PeakerWork: ^^ you mean this?
03:00:21 <pjolk> but i have never coded alrge projects with a big amount of people
03:00:25 <PeakerWork> ivanm: yeah
03:00:38 <ksf> pjolk, depends on the code.
03:00:39 <ivanm> *shrug* I have never used any generics stuff
03:00:55 <PeakerWork> ivanm: seems like it could only mean re-apply stuff N times? (a -> a) -> a -> a  seems to be equivalent to an Int
03:01:18 <ivanm> sure looks like a church numeral
03:01:28 <dolio> That type looks suspicious.
03:01:29 <ivanm> @src everywhere
03:01:29 <lambdabot> Source not found. :(
03:01:41 <dolio> @hoogle get
03:01:41 <lambdabot> Text.ParserCombinators.ReadP get :: ReadP Char
03:01:42 <lambdabot> Text.ParserCombinators.ReadPrec get :: ReadPrec Char
03:01:42 <lambdabot> Control.Monad.State.Class get :: MonadState s m => m s
03:02:03 <ivanm> PeakerWork: which generics lib is it from?
03:02:15 <PeakerWork> ivanm: I donno, I just saw it above when hoogled for a->a
03:02:20 <PeakerWork> ivanm: and got curious :)
03:02:25 <ivanm> heh
03:02:29 <dolio> I think it's from SYB.
03:02:53 <ivanm> ahhh, syb
03:03:10 <ivanm> "Apply a transformation everywhere in bottom-up manner "
03:03:11 <dolio> The real type is: (forall a. Data a => a -> a) -> forall a. Data a => a -> a
03:03:19 <ivanm> it's an existential :s
03:03:38 <ivanm> everywhere f = f . gmapT (everywhere f) <-- whatever this means...
03:03:50 <ivanm> @hoogle gmapT
03:03:50 <lambdabot> Data.Generics.Basics gmapT :: Data a => (b -> b) -> a -> a
03:04:24 <ivanm> "A generic transformation that maps over the immediate subterms " <-- docs for gmapT
03:04:33 <ivanm> and hoogle was wrong, it's in Data.Data in base :s
03:11:18 <PeakerWork> dolio: why is the same "a" used in both sides?
03:11:46 <PeakerWork> why the same name, that is -- its unnecessarily confusing
03:12:54 <dolio> I don't know.
03:12:57 <ivanm> PeakerWork: just to confuse you
03:12:58 <ivanm> ;-)
03:30:58 <guinea__> Anyone have an idea why HOpenGL demos cause the screen to go completely black whenever they have focus, but work normally when they don't have focus? I'm using Ubuntu. Is it some weird window manager interaction?
03:32:05 <voker57__> @hoogle a -> b -> a
03:32:05 <lambdabot> Prelude const :: a -> b -> a
03:32:06 <lambdabot> Data.Function const :: a -> b -> a
03:32:06 <lambdabot> Control.Parallel par :: a -> b -> b
03:32:26 <voker57__> @src const
03:32:26 <lambdabot> const x _ = x
03:38:15 <guinea__> I tried running some HOpenGL demos under xmonad and they run fine. So it's something to do with the window manager.
03:39:02 <voker57__> @hoogle try
03:39:02 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
03:39:03 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
03:39:03 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
03:39:33 <quicksilver> guinea__: something to do with compositing wms I bet
03:39:42 <quicksilver> guinea__: compositing wms use opengl themselves
03:42:27 <pjolk> so am I right, dependant types are for incorporating sturcture-specific type-safety ?
03:42:51 <pjolk> like if I have an array or list and the nbr of elems have to be perfectly divisible with x
03:42:56 <pjolk> so i cna write
03:43:49 <pjolk> blah :: [a] := div (length) 3 = 0 -> [a]
03:43:53 <pjolk> or soemthing like that?
03:43:59 <quicksilver> that's an example of the kind of thing you can use dependent types for, yes.
03:46:13 <pjolk> and if you have a Matrix type you might want to check thta all rows are the same length and the cols are the same length. but wont that be very innefficient? youd need some sort of scheme to avoid rechecking it every time right?
03:46:53 <zachk> pjolk: you can use arrays
03:47:11 <pjolk> sure im just taking an example
03:47:26 <voker57__> how to catch read's errors?
03:47:39 <dolio> In general, types are propositions that the compiler verifies before building your program. So dependent types let you make the compiler prove things about values in your program.
03:47:43 <pjolk> actually yeah wouldn't you use arrays normally for things that ned boundschecking?
03:47:48 <Saizan_> well, you don't check it everytime, you usually carry around a proof of that property
03:47:54 <pjolk> ok
03:47:56 <Saizan_> which might be the length number itself
03:49:18 <quicksilver> pjolk: hopefully you check it at compile time; that's the idea of types.
03:49:23 <Saizan_> then as an optimization proof objects that don't contribute to the computational result can be removed at compile time in some systems
03:49:35 <liyang> irrelevant!
03:52:36 <pjolk> what is irrelevant?
03:53:03 <pjolk> hmm haskell and functional programming really is interesting
03:53:27 <pjolk> there is a lot more to it than you think at first. and very practical to, not just academic theory
03:56:02 <dolio> pjolk: "Proof irrelevance" is the term for identifying various proofs as unnecessary for the actual computation, and erasing them at compile time (so that your code is just as efficient as code that doesn't bother doing the proofs).
04:01:37 <liyang> pjolk: You are. Plus, what dolio said.
04:01:57 <quicksilver>  'Amazon.co.uk recommends "Programming in Haskell" and more'
04:02:07 * EvilTerran is
04:02:20 <EvilTerran> > sort "evilterran" == sort "irrelevant"
04:02:21 <lambdabot>   True
04:02:46 <dolio> Is that how you got your nick?
04:03:10 <EvilTerran> pretty much, yeah
04:03:11 <boegel> heh
04:03:33 <boegel> so, evilterran is sort of irrelevant? :) cool
04:03:37 <pjolk> liyang: I am irrelevant? why?
04:03:50 <EvilTerran> boegel, not only am i irrelevant, but i'm in the wrong order, too :P
04:03:59 <boegel> EvilTerran: heh
04:04:15 <liyang> pjolk: ignore me. I haven't taken my meds today yet.
04:04:58 <liyang> pjolk: but you probably are, in the grand scheme of the Universe.
04:07:49 <zachk> does the universe even have a grand scheme liyang(and i just took my meds :-)
04:07:57 <ivanm> EvilTerran: not to mention being an evil ranter?
04:09:38 <pjolk> liyang: well probably you are too
04:10:33 <pjolk> liyang = vixey?
04:11:13 <liyang> pjolk: no, liyang == http://liyang.hu/
04:15:28 <mpj> hi, I'm trying to install the Yi editor from Hackage using cabal. I've just built cabal using the instructions on http://hackage.haskell.org/trac/hackage/wiki/CabalInstall , and when running cabal install yi, i get the result:cabal: cannot configure yi-0.6.0. It requires base >=4, base-4.0.0.0 was excluded because of the top level dependency base -any  and the same for base-4.1.0.0. I'm a complete noob and am not sure how to proceed, any thoughts?
04:19:47 <doserj> mpj: do you have an older ghc? then try to install yi-0.5.2
04:20:01 <millz> lmao, I scored Philip Wadler in 'what kind of informatics student are you?' test
04:20:41 <mpj> doserj: I seem to be running ghci 6.8.2.
04:20:55 <mpj> Is that old?
04:21:27 <doserj> current is 6.10.x
04:21:54 <mpj> Ok, thank you very much for taking the time. Seems to be building now
04:27:09 <liyang> millz: URL?
04:27:38 <pjolk> Turing's statement that programming should never be boring because all the repetitive stuff could be put in the hardware seems to ring truer for functional languages than imperative. Or nowadays it would be "programming should never be boring because all the repetitive stuff could be put in the compiler"
04:27:53 <pjolk> or not quite but a little bit like that
04:29:24 <millz> liyang, facebook...
04:29:51 <millz> pjolk, whether its boring depends on your motivation imo
04:30:04 <millz> when i code some, even most boring stuff, for my game, i do it with pleasure
04:30:15 <millz> but when i have to code some really boring stuff for uni, its annoying
04:31:06 <Berengal> To me boring just means I'm not thinking abstract enough
04:42:28 <akamaus> Hi anyone
04:42:37 <akamaus> I'm having troubles with installing encoding-0.5.1 package with cabal
04:42:54 <liyang> millz: can't find it. D: Nevermind.
04:43:05 <akamaus> compilation starts, but after a while seems to run into an infinite loop on [43 of 47] Compiling Data.Encoding.JISX0208 ( Data/Encoding/JISX0208.hs, dist/build/Data/Encoding/JISX0208.o )
04:43:44 <akamaus> I use ghc-6.10.1 gcc-4.2.4  under gentoo
04:51:45 <akamaus> I looked into sources, table in JIS0208.TXT seems to be 30x larger than for other encodings. So I guess I just have to wait a little more )
04:53:49 <mlesniak> I can't find the function for determing the number of cores; it was something with "num" and "capabilites", but hoogle did not really help
04:55:08 <mlesniak> ...GHC.Conc.numCapabilities :-|
04:59:29 <mreh> > [x|x <- [1..5], y <- [1,2]]
04:59:30 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
04:59:35 <mreh> braaap
05:00:14 <pjolk> how does structural sharing work when using FFI? if I use hmatrix, does assigning to the matrix happen in the IO monad? if not, does it create a whole new matrix or does it share structure with the old unmodified one?
05:00:34 <DrSyzygyIE> > [y|x <- [1..5], y <- [1,2]]
05:00:35 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
05:00:48 <DrSyzygyIE> > [x | y <- [1,2], x <- [1..5]]
05:00:49 <lambdabot>   [1,2,3,4,5,1,2,3,4,5]
05:00:59 <mauke> > [1,2] >> [1..5]
05:01:00 <lambdabot>   [1,2,3,4,5,1,2,3,4,5]
05:01:42 <Berengal> > concatMap (\x -> concatMap (\y -> [y]) [1,2]) [1..5]
05:01:43 <DrSyzygyIE> > [1..5] >> [1,2]
05:01:43 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
05:01:44 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
05:02:20 <mreh> i've just been reading the definition of the list comprehension
05:02:23 <mreh> using map
05:02:40 <HugoDaniel> hi
05:02:46 <mreh> hello
05:02:47 <Berengal> mreh: concatMap would be more correct
05:03:35 <Berengal> > do x <- [1..5]; y <- [1,2]; return y
05:03:36 <lambdabot>   [1,2,1,2,1,2,1,2,1,2]
05:03:53 <mreh> so many different ways
05:04:07 <mreh> haskell is starting to resemble perl
05:04:08 <Berengal> Which all boil down to the same thing
05:04:19 <mreh> okay, not like perl
05:04:53 <ksf> any tips on how to best implement a code gen that should work at both compile- and runtime?
05:05:43 <mreh> DrSyzygyIE: I didn't think the order would matter
05:05:56 <mreh> of the definition of the variables, but now i see why
05:06:37 <mreh> :t concatMap
05:06:39 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
05:07:49 <Berengal> @src [] (>>=)
05:07:49 <lambdabot> xs >>= f     = concatMap f xs
05:08:10 <mreh> @src >>
05:08:11 <lambdabot> m >> k      = m >>= \_ -> k
05:08:34 <mreh> > [1..5] >> "hello"
05:08:36 <lambdabot>   "hellohellohellohellohello"
05:08:43 <mreh> ?!?!
05:08:51 <mreh> shouldnt that be a list of lists
05:08:58 <Berengal> @type map
05:08:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:09:00 <EvilTerran> mreh, no, >>= is concatMap, not map
05:09:00 <Berengal> @type concat
05:09:01 <lambdabot> forall a. [[a]] -> [a]
05:09:02 <Berengal> @type concatMap
05:09:03 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
05:09:11 * mreh brane asplode
05:09:20 <Berengal> @src concatMap
05:09:20 <lambdabot> concatMap f = foldr ((++) . f) []
05:09:35 <Berengal> (or (concat.).map)
05:09:48 <Berengal> aka \f -> concat . map f
05:09:49 <EvilTerran> > [1..5] >> [10,20,30]
05:09:50 <lambdabot>   [10,20,30,10,20,30,10,20,30,10,20,30,10,20,30]
05:10:01 <EvilTerran> > concatMap (const [10,20,30]) [1..5]
05:10:03 <lambdabot>   [10,20,30,10,20,30,10,20,30,10,20,30,10,20,30]
05:10:03 <mreh> to think we evolved just to make stone tools, and now all these bloody confusing things
05:10:15 <mreh> amazing
05:10:22 <Berengal> map (const [10,20,30]) [1..5]
05:10:31 <Berengal> > map (const [10,20,30]) [1..5]
05:10:32 <lambdabot>   [[10,20,30],[10,20,30],[10,20,30],[10,20,30],[10,20,30]]
05:11:18 <Berengal> I still have trouble with the list monad from time to time
05:11:23 <Berengal> It helps if you know prolog...
05:11:48 <mreh> i used to know prolog
05:11:52 <mreh> atleast i think i did
05:12:23 <mreh> it's hard to know when you only did it for six months when the university just decided to crowbar it in at the last moment
05:12:31 <zachk> i know the IO, Maybe, and List monad
05:13:16 <mreh> im doing alright
05:13:39 <ksf> mreh, the very essence of a monad is to flatten stuff.
05:13:41 <ksf> :t join
05:13:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:13:50 <Berengal> Okay, so the basic thought behind the list monad is that "do x <- xs; ..." runs the "xs" computation, yielding a result "x". That computation may however return more than one result, just like in prolog when it does it's magic backtracking thing
05:13:59 <zachk> > [1..3]>>[1..3]
05:14:00 <lambdabot>   [1,2,3,1,2,3,1,2,3]
05:14:11 <pastorn> mreh: when you do >> or >>= in the list monad, think "for every"
05:14:30 <ksf> without that flattening, you couldn't sequence things.
05:15:02 <zachk> > [1..3]>>=[1..3]
05:15:03 <lambdabot>   Couldn't match expected type `t -> [b]' against inferred type `[a]'
05:15:45 <Berengal> ksf: join is useless without fmap
05:16:27 <zachk> :t join
05:16:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:16:42 <zachk> :t fmap
05:16:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:16:52 <PeakerWork> when a thread has async. exceptions blocked, and someone tries to throw at him, what happens?
05:17:20 <Berengal> @type join . fmap ?f
05:17:21 <lambdabot> forall a a1 (f :: * -> *). (Functor f, ?f::a1 -> f a, Monad f) => f a1 -> f a
05:17:44 <mreh_> i'll worry about all this more when i get to monads, i've only just done list comprehensions
05:17:44 <mreh_> but i'm sure i'll have to revist them, like i did foldl and foldr atleast twice
05:18:36 <Berengal> mreh_: list comprehensions can actually be a nice gateway to monads.
05:18:58 <wli> Monad comprehensions would be nice to have back.
05:19:13 <wli> I tried to do it for ghc and failed.
05:20:08 <wli> Several times, even.
05:24:27 <zachk> if i cabal install something where do the source files go
05:25:33 <trofi^w> ~/.cabal/packages/
05:28:29 <mxc> good evening #haskell
05:28:34 <iesahin> Hello all, what's the problem that I can't see in this simple program: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2390#a2391
05:28:44 <mxc> whats the current least awful way of integrating java and haskell code?
05:28:51 <mxc> saw some conflicting info on the wiki
05:29:27 <vegai> how about a way of the Borg
05:29:38 <vegai> first, make the different pieces talk through a simple interface such as a pipe
05:29:44 <vegai> and little by little, fade away the Java code
05:29:58 <vegai> finally, assimilation will be complete
05:30:27 <mxc> vegai - thats my current wort case solution..  there isn't any java code yet, but I have a priject that I'd like to do in a proper language but which requires using java API
05:30:49 <HugoDaniel> i just installed python on my windows box, and the installer didn't set the path :/
05:30:55 <HugoDaniel> why didn't it set the path ?
05:31:22 <Berengal> HugoDaniel: You might try asking in #python
05:32:22 <HugoDaniel> sorry, wrong #
05:32:25 <HugoDaniel> :(
05:32:43 <HugoDaniel> its my first try out in mirc, sorry there :/
05:32:51 <Berengal> That's okay :)
05:33:12 <mxc> iesahin - how do your princeton profs feel about posting raw code here and asking for help?
05:33:17 <trofi^w> or might try to install haskell
05:33:27 <iesahin> which princeton profs?
05:33:34 <HugoDaniel> trofi^w, haskell is already installed :) and working good
05:33:41 <mxc> did a google search on cs461 haskell and took a guess :)
05:33:54 <trofi^w> ah, ok :]
05:34:08 <mxc> :t unfoldr
05:34:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:34:13 <HugoDaniel> i miss cabal in python :(
05:34:23 <iesahin> mxc: haha, but wrong guess, i'm the ta and try to produce random test data for pruning homework
05:34:37 <mxc> haha
05:34:39 <Berengal> I miss Haskell in Python...
05:35:01 <iesahin> mxc: if you like i can send you homeworks in java to grade
05:35:02 <iesahin> :)
05:35:07 <mxc> haha
05:35:13 <mxc> my TA days are over
05:35:33 <iesahin> but that unfoldr should work, doesn't it?
05:36:15 <HugoDaniel> when coding in python i realise that haskell really is years ahead of this "generation" of programming languages
05:37:52 <Berengal> @type randoms
05:37:53 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
05:37:58 <Berengal> iesahin: ↑
05:38:35 <pjolk> is it correct to say that Arrow is a family of operators?
05:38:39 <iesahin> i want to produce list of random *primes*
05:38:42 <mxc> iesahin: brb
05:39:08 <iesahin> mxc: ?
05:39:08 <horms> iesahin: i think wli is doing some work on primes
05:39:27 <mxc> be right back, going to take a look
05:39:33 <pjolk> how does structural sharing work when using FFI? if I use hmatrix, does assigning to the matrix happen in the IO monad? if not, does it create a whole new matrix or does it share structure with the old unmodified one?
05:40:02 <pjolk> HugoDaniel: yeah I agree
05:40:13 <pjolk> OO is a dead end
05:40:19 <Berengal> iesahin: Ah, sorry, wasn't paying attention to the code :P
05:40:56 <iesahin> Berengal: :)
05:40:58 <Berengal> You might try not mapping fst over an int...
05:41:01 <quicksilver> pjolk: I've not used hmatrix, but generally the choices are (a) put it in the IO monad (b) treat it immutably and create new copies.
05:41:13 <Berengal> Well, list of ints...
05:41:17 <quicksilver> pjolk: It's not easy to make C libraries interoperate with clever sharing strategies.
05:41:39 <pjolk> quicksilver: but then new copies dont share structure like in a normal haskell-program?
05:42:10 <pjolk> because ghc must know something about the representation of the matrices to be able to do that right?
05:42:22 <quicksilver> yes.
05:42:27 <iesahin> Berengal: You're right
05:42:43 <iesahin> That's a silly error
05:42:46 <mxc> back, sry
05:42:54 <iesahin> Thanks for your attention
05:43:07 <Berengal> iesahin: What little of it was there :P
05:43:09 <mxc> drop the map fst i think
05:43:16 <mxc> oh, oops, someone beat me too it
05:43:39 <iesahin> Berengal, mxc: Thanks
05:47:01 <HugoDaniel> is there an easy way to check how many packages hackagedb has ?
05:47:54 <earthy> 'ask dons' ? :)
05:47:58 <HugoDaniel> :D
05:49:25 <Elly> that's the answer to a lot of questions in haskell
05:49:28 <Elly> "ask $person"
05:50:29 <HugoDaniel> seems we are all inside a reader monad :P
05:53:22 <burp_> @faq can haskell tell HugoDaniel if there is an easy way  to check how many packages hackagedb has?
05:53:22 <lambdabot> The answer is: Yes! Haskell can do that.
05:54:56 <benny99> @faq can haskell do something it's not able to do ?
05:54:56 <lambdabot> The answer is: Yes! Haskell can do that.
05:55:13 <Asztal> cabal list --simple | wc -l, maybe?
05:56:36 <doserj> $ cabal list --simple | awk '{print $1}' | uniq | wc -l
05:56:40 <doserj> 1280
05:59:56 <xter_> Headache!
06:10:05 <Berengal> Is haddock supposed to take forever?
06:12:00 <tromp> no, only half that long
06:14:29 <ksf> why doesn't :: * -> * syntax work with gadts?
06:14:37 <vixey> I think that it does ksf
06:14:51 <vixey> (maybe you have to turn on KindSignatures)
06:15:04 <ksf> error: parse error on input `*'
06:15:37 <ksf> yeah, that's it.
06:16:40 * ksf thinks binding a type var and never using it is utterly confusing.
06:16:52 <ksf> pointless points flying aroud.
06:26:58 <ivanm> is it possible to define the actual lambda-calculus Y combinator in Haskell?  It fails to typecheck for me when I try :s
06:27:10 <ivanm> (wikipedia says that Data.Function.fix is equivalent though..._
06:27:22 <ivanm> @type \ g -> (\ x -> g (x x)) (\ x -> g (x x))
06:27:24 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
06:27:24 <lambdabot>     Probable cause: `x' is applied to too many arguments
06:27:24 <lambdabot>     In the first argument of `g', namely `(x x)'
06:33:12 <chessguy_work> ivanm i seem to remember it's not possible
06:33:27 <chessguy_work> oh, too late
06:36:39 <pjolk> hmm, does Haskell use a lot more memory than Java/Scala? or is thta only if you do it wrong? or maybe I should ask does it takemore effort to keepmemory down?
06:37:00 <opqdonut> it sometimes takes quite a bit of effort
06:37:09 <opqdonut> but haskell isn't that memory-hungry as such
06:37:33 <quicksilver> pjolk: too much of a generalisation to give an easy answer to.
06:37:42 <quicksilver> certainly haskell churns more memory than java.
06:37:49 <quicksilver> since it creates many small heap objects.
06:37:56 <quicksilver> that doesn't necessarily matter, though.
06:39:24 <pjolk> churns as in allocates and discards? not holding at the same time?
06:40:41 <FunctorSalad> greetings. A basic STM question... does reading an empty TChan cause retry? Can I do a non-blocking read with "(Just <$> readTChan c) `orElse` Nothing"?
06:41:02 <lenni_-_> i have a question about miranda which is similar to haskell. i was asked to rewrite the function member using foldr or foldl. I have: fold_member list elm = foldr (((=)1.\/)) False list
06:41:13 <lenni_-_> but that gives a type error
06:41:43 <FunctorSalad> I guess "non-blocking" isn't quite applicable here...
06:41:54 <chessguy_work> @type foldr (((=)1.\/)) False ?list
06:41:56 <lambdabot> parse error on input `='
06:42:02 <FunctorSalad> I mean "try to read from the chan, but if there's nothing, continue the transaction anyway"
06:42:03 <chessguy_work> @type foldr (((==)1.\/)) False ?list
06:42:05 <lambdabot> Not in scope: `.\/'
06:42:38 <chessguy_work> @hoogle (\/)
06:42:38 <lambdabot> No results found
06:42:55 <chessguy_work> @type foldr (((==)1.(||))) False ?list
06:42:57 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `Bool'
06:42:57 <lambdabot>     Probable cause: `.' is applied to too many arguments
06:42:57 <lambdabot>     In the first argument of `foldr', namely `(((==) 1 . (||)))'
06:43:34 <chessguy_work> @type (==)1.(||)
06:43:35 <lambdabot>     No instance for (Num (Bool -> Bool))
06:43:35 <lambdabot>       arising from the literal `1' at <interactive>:1:4
06:43:35 <lambdabot>     Possible fix: add an instance declaration for (Num (Bool -> Bool))
06:43:46 <chessguy_work> @type ((==)1).(||)
06:43:47 <lambdabot>     No instance for (Num (Bool -> Bool))
06:43:47 <lambdabot>       arising from the literal `1' at <interactive>:1:5
06:43:47 <lambdabot>     Possible fix: add an instance declaration for (Num (Bool -> Bool))
06:44:05 <quicksilver> FunctorSalad: I would have thought that reading an empty TChan causes blocking.
06:44:19 <quicksilver> FunctorSalad: you then get a retry later if things turn out to be inconsistent.
06:44:22 <quicksilver> FunctorSalad: but not if they don't.
06:44:27 <quicksilver> FunctorSalad: STM is optimistic.
06:44:43 <Berengal> reading an empty TChan causing retry is only logical
06:44:51 <Berengal> I've relied on it in the past
06:45:03 <quicksilver> why is that more logical than blocking?
06:45:11 <Berengal> as in "read this `orElse` read that"
06:45:23 <Berengal> quicksilver: It allows you to orElse on it
06:45:25 <quicksilver> hmm.
06:45:31 <quicksilver> yes, fair enough.
06:45:32 <lenni_-_> chessguy_work: thanks for trying; i can't get it working either
06:45:34 <FunctorSalad> quicksilver: the readTChan source does mention retry, but I don't know whether the internal stuff blocks anyway
06:45:46 <FunctorSalad> http://hackage.haskell.org/packages/archive/stm/2.1.1.2/doc/html/src/Control-Concurrent-STM-TChan.html#readTChan
06:45:47 <chessguy_work> @type foldr
06:45:48 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:45:48 <quicksilver> lenni_-_: your question made absolutely no sense.
06:45:58 <quicksilver> lenni_-_: (=) isn't a haskell operator and neither is \/
06:46:20 <ivanm> I asked before (about 20 min ago) about implementing the Y combinator... did anyone answer, as X decided it didn't like me around that time :s
06:46:22 <lenni_-_> quicksilver: i'm learning miranda
06:46:30 <lenni_-_> quicksilver: which is similar to haskell
06:46:34 <chessguy_work> @type \x y -> y || (x == 1)
06:46:35 <lambdabot> forall a. (Num a) => a -> Bool -> Bool
06:46:37 <quicksilver> oh, I see.
06:46:43 <quicksilver> I misread your question.
06:46:46 <chessguy_work> @pl \x y -> y || (x == 1)
06:46:47 <lambdabot> flip (||) . (1 ==)
06:46:47 <ivanm> lenni_-_: I thought miranda was dead :s
06:47:05 <pjolk> are ocaml and haskell the only practical functional languages? ML, Miranda, Cayene, etc are research languages?
06:47:07 <lenni_-_> ivanm: it is! my prof isn't quite with the time
06:47:09 <chessguy_work> @type foldr (flip (||).(1==)) False
06:47:10 <lambdabot> forall t. (Num t) => [t] -> Bool
06:47:14 <opqdonut> ivanm: yeah it's possible, but you need a newtype
06:47:14 <ivanm> lenni_-_: lol
06:47:15 <FunctorSalad> actually I'm trying to do a very simple thing, have one-way communication from one thread to another, but with non-blocking reads. so far I did this with a plain Chan and isEmptyChan, but someone on ghc-users said that isEmptyChan has issues
06:47:16 <chessguy_work> lenni_-_, there you go
06:47:18 <opqdonut> ivanm: to break the infinite type
06:47:21 <ivanm> opqdonut: :(
06:47:28 <ksf> I thought you had to say that it was trademarked by someone every time you mentioned the m-word.
06:47:37 <opqdonut> ivanm: actually, wait a sec
06:48:51 <chessguy_work> lenni_-_, did you see my solution?
06:48:55 <Berengal> ivanm: untyped lambda calculus is inconsistent. Y relies on this inconsistency (infinite type)
06:48:55 <lenni_-_> chessguy_work: so I need to flip the two operators?
06:49:11 <ivanm> Berengal: *nod*
06:49:24 <chessguy_work> lenni_-_, flip the or operator
06:49:41 <quicksilver> pjolk: ML is a family. it has various practical implementations.
06:49:48 <quicksilver> pjolk: ocaml and sml are the more famous
06:49:57 <FunctorSalad> Berengal: what does "inconsistent" mean in this context?
06:49:59 <lenni_-_> chessguy_work: hmm, why is that?
06:50:04 <opqdonut> ivanm: there was a way to type Y with some forall-trickery
06:50:08 <opqdonut> (higher order types)
06:50:15 <ksf> pjolk, instead of cayenne, have a look at agda
06:50:19 <FunctorSalad> (curry-howard for untyped lamba calculus?)
06:50:19 <chessguy_work> lenni_-_, because of the type of foldr
06:50:29 <chessguy_work> @type foldr
06:50:31 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
06:50:31 <ivanm> quicksilver: and F#?
06:50:33 <Berengal> FunctorSalad: You can make nonsensical statements, such as x = ¬x
06:50:48 <lenni_-_> chessguy_work: aha, cheers!
06:50:49 <quicksilver> ivanm: I'm not sure if F# is exactly an ML, but yes.
06:50:53 <ivanm> Berengal: you mean it doesn't? :o
06:50:55 <ivanm> ;-)
06:51:11 <FunctorSalad> Berengal: I mean, I don't see how to curry-howard untyped lamba calculus, since it has only a single type, right?
06:51:13 <Berengal> ivanm: I know! Math is so unintuitive at times :P
06:51:31 <FunctorSalad> so only a single proposition
06:52:20 <lenni_-_> chessguy_work: flip takes 3 arguments and returns the 2dn and 3 in reverse order? like swap?
06:52:28 <bastl> hi i try to compile haXml 1.19.6, but it complains that some module is missing which is in polyparse-1.1 which is hidden. How can i unhide it ?
06:52:33 <ksf> :t flip
06:52:34 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:52:53 <Berengal> FunctorSalad: Eh, I'm not quite up to speed on the theory yet :/ I think the best way to show the inconsistency is to show how it doesn't work in a typed system
06:52:54 <ksf> it flips the first two, which are "all".
06:53:41 <FunctorSalad> is it any more inconsistent than fix in haskell? (which is false in propositional logic as well)
06:53:42 <chessguy_work> lenni_-_, no, flip takes a function of 2 parameters, and returns a new function that takes the two parameters in the opposite order, but does the same thing
06:54:58 <ivanm> Berengal: do you know if it's possible to define say the factorial function using church numerals?
06:55:14 <quicksilver> ivanm: yes, certainly.
06:55:21 <Berengal> ivanm: I can't see why not, though I don't know how
06:55:27 <quicksilver> ivanm: untyped lambda calculus is turing complete
06:55:30 <ivanm> easily? :p
06:55:34 <quicksilver> ivanm: you can do everything with church numerals.
06:55:42 <ivanm> quicksilver: even bake a caek? :p
06:55:46 <sbahra> everything?
06:55:48 <sbahra> ;p
06:55:55 <ksf> ivanm, * isn't too hard to do in church.
06:56:03 <quicksilver> @faq can a haskell implementation of untyped LC bake a caek?
06:56:04 <lambdabot> The answer is: Yes! Haskell can do that.
06:56:11 <quicksilver> pretty good. I don't even know what a caek is :P
06:56:39 <malcolmw> bastl: try installing polyparse-1.2 + HaXml-1.19.7 instead?
06:56:42 <Berengal> By the way, since we're on the topic, what does succ look like in SKI combinator calculus?
06:56:57 <Berengal> zero = KI, succ = ???
06:57:09 <vixey> Berengal: why is KI zero?
06:57:34 <Berengal> zero = flip const
06:57:40 <vixey> yeah why
06:58:14 <Berengal> it applies its first argument to its second zero times
06:58:45 <ivanm> OK, I'll just use the "let's add numbers to lambda calculus" version of factorial as an example then
06:58:52 <vixey> so you have the lambda term and you ant to produce the combinator version?
06:58:53 <ivanm> if I can make sense of the one on wikipedia
06:59:33 <ksf> ivanm, http://homepages.cwi.nl/~tromp/cl/lazy-k.html , go for it.
06:59:47 <Berengal> yeah, I believe succ was somethingl like \n f x. f (n f x)
06:59:50 <FunctorSalad> so, would this be a reasonable way to read everything available from a TChan without retry? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4786#a4786
07:00:21 <dolio> vixey: How new is your agda?
07:00:38 <vixey> I just installed it yesterday
07:00:41 <bastl> malcolmw: good, it compiles
07:00:44 <vixey> from darcs
07:01:09 <vixey> @pl\n f x -> f (n f x)
07:01:09 <lambdabot> (line 1, column 5):
07:01:09 <lambdabot> unexpected ">" or "-"
07:01:09 <lambdabot> expecting variable, "(", operator or end of input
07:01:14 <ivanm> ksf: what's K?
07:01:33 <ksf> the k combinator
07:01:38 <Berengal> FunctorSalad: Looks okay to me, assuming it works
07:01:47 <FunctorSalad> :)
07:02:31 <Berengal> K = \x y . x
07:02:35 <Berengal> aka const
07:03:24 <vixey> dolio, why?
07:03:32 <dolio> vixey: Does this work for you: http://hpaste.org:80/fastcgi/hpaste.fcgi/view?id=4787#a4787
07:03:55 <quicksilver> FunctorSalad: putting "atomically" inside your combinators considered harmful.
07:04:06 <vixey> yes that works
07:04:46 <vixey> nice proof btw
07:05:03 <dolio> Nice proof that all functions are injective?
07:05:06 <vixey> yes
07:05:11 <vixey> your version of agda doesn't typecheck that?
07:05:18 <dolio> No, it does.
07:05:33 <FunctorSalad> quicksilver: "combinator" as in combining STM actions here? the function is supposed to be called from outside STM, but I guess you mean the atomically should be in the user?
07:06:01 <dolio> I thought it shouldn't.
07:06:23 <dolio> Maybe that's a bad definition of injectivity, though.
07:06:41 <bastl> malcolmw: how should i fix this? http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=4788
07:07:30 <bastl> the <p> tag from xhtml collides with some type from haxml
07:07:52 <malcolmw> bastl: import Text.XML.HaXml.XmlContent hiding (P)
07:08:09 <bastl> yeah, i expected somethign simple like that. thanks!
07:08:57 <malcolmw> bastl: although the fact that a line number is 4522 suggests your module is machine-generated
07:09:36 <bastl> im using DtdtoHaskell on xhtml1-strct.dtd
07:10:43 <vixey> dolio http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4787#a4789
07:10:46 <vixey> that's why I like your proof
07:10:50 <malcolmw> bastl: yeah, so hiding P in the generated module might not work, if other things in it use that P
07:11:21 <vixey> so Agda is inconsistent
07:11:25 <bastl> it worked anyway ..
07:11:29 <dolio> Right. Okay. So it's not just me.
07:11:34 <vixey> :D
07:11:35 <malcolmw> bastl: but you might be fine - I can't remember whether DtdToHaskell-generated code needs P or not (P is the constructor for parsers)
07:11:38 <dolio> I thought I was missing something.
07:12:13 <quicksilver> FunctorSalad: yes, that's "the point" of STM, that its composable
07:12:17 <dolio> Time to send some mail.
07:12:23 <quicksilver> FunctorSalad: so the atomically goes at the outermost level.
07:12:25 <malcolmw> bastl: OK, great.  maybe I should make DtdToHaskell be more explicit about the imports required in the generated code.
07:12:36 <quicksilver> FunctorSalad: you don't know if your user might want ot use that as part of a larger transaction...
07:12:45 <vixey> time for a metacircular implementation of Agda that satisfies de bruijn criteria
07:12:58 <FunctorSalad> quicksilver: good point :)
07:13:44 <quicksilver> FunctorSalad: e.g. they might want to read everything from two chans
07:13:56 <chessguy_work> vixey, can i get some fries with that?
07:13:57 <quicksilver> FunctorSalad: then, your little combinator would be ideal :) if only it didn't bundle its own atomically.
07:14:16 <quicksilver> yuck, fries with de bruijn criteria?
07:14:24 <quicksilver> that's like mustard with cake.
07:14:40 <quicksilver> de bruijn criteria should be enjoyed with a good whisky. Or doughnuts.
07:15:23 <EvilTerran> ... what're de Bruijn criteria?
07:16:08 <vixey> EvilTerran: it means don't write a whopping great million line type checker
07:16:39 <SamB> vixey: how does it mean that?
07:16:41 <vixey> if you have a small typechecker then complicated  stuff like pattern matching (which appears to make agda inconsistent) is justified in terms of that
07:17:02 <vixey> this is the fundamental design flaw of Agda imo
07:17:29 <vixey> SamB: (should it mean something a bit different?)
07:17:40 <dolio> Metacircular implementation? Hah.
07:18:05 <vixey> dolio, I think that is what James Chapman is going for
07:18:28 <swiert> vixey: so why does pattern matching make agda inconsistent?
07:18:43 <vixey> sweirt: dolio just pasted this http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4787#a4789
07:19:02 <vixey> I annotated with the obvious proof of false
07:19:52 <FunctorSalad> :O
07:22:30 <FunctorSalad> vixey, I'm not familiar with Agda... the point is that you can pattern match on (f a)?
07:23:46 <SamB> vixey: I did always think they had too nebulous a typechecker ...
07:36:30 <bastl> why is Data.Typeable restricted to Typeable7 ? Could i extend that easily ?
07:37:43 <doserj> bastl: http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#deriving-typeable
07:37:52 <dolio> You really have a type parameterized by 8 or more other types?
07:39:16 <vixey> dolio, how did you come by that injectivity stuff though?
07:39:45 * edwardk waves hello.
07:39:46 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:40:11 <dolio> vixey: I was looking at SCM's latest blog post, but thought that his defining it in terms of relations was overkill...
07:40:34 <dolio> vixey: So I defined it for functions, and started to see if I could prove surjective f -> injective f.
07:40:54 <dolio> Then I did C-c C-c on the fx=fy proof, and noticed that I didn't need surjectivity at all.
07:40:58 <Athas> How do I calculate 2**n-1, where n is an Integer, as an Integer value?
07:41:08 <vixey> ahh
07:41:20 <vixey> > 2**3+1
07:41:21 <dolio> And it generalized to non-endomorphisms.
07:41:21 <lambdabot>   9.0
07:41:25 <vixey> > 2^3+1
07:41:27 <lambdabot>   9
07:41:37 <Athas> Ah, thanks.
07:41:49 <EvilTerran> ?type (^)
07:41:51 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
07:41:52 <EvilTerran> ?type (^^)
07:41:54 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
07:41:55 <EvilTerran> ?type (**)
07:41:56 <lambdabot> forall a. (Floating a) => a -> a -> a
07:42:26 <kosmikus> dolio, vixey: the Agda injectivity thing is fixed or about to be fixed, afaik
07:42:53 <vixey> kosmikus: I'm sure it will be, but I'm very curious to see /how/ they fix it
07:42:54 <dolio> Oh, this is a known problem? Now I feel less special.
07:43:16 <vixey> i.e. do they just change one line of code and go:  Right now Agda is working again
07:44:27 <kosmikus> dolio: well, we found this today, curiously
07:44:34 <dolio> Heh.
07:44:36 <kosmikus> dolio: issue 160 on the Agda bug tracker
07:44:45 <kosmikus> dolio: marked as fixed now
07:44:53 <vixey> kosmikus: oh you are actually one of the implementers?
07:44:57 <kosmikus> no,
07:45:04 <kosmikus> but I'm visiting Chalmers this week
07:45:07 <vixey> oh good I can still complain :p
07:45:29 <dolio> I should find the tracker and bookmark it...
07:45:34 <mattam> kosmikus: it was treating f as a type constructor?
07:45:49 <kosmikus> mattam: yes, more or less
07:46:16 <mattam> This injectivity of type constructors always bugged me but maybe it's still sound.
07:46:22 <kosmikus> dolio: code.google
07:46:55 <edwardk> dolio: heh, i actually had a need for a 'higher order' cofree comonad with three parameters the other day.
07:47:16 <EvilTerran> ... how can something be co-free?
07:47:33 <edwardk> EvilTerran: its admittedly a pretty bad term
07:47:41 <EvilTerran> i've seen the term used a few times in here, but it only just struck me that it makes no intuitive sense
07:48:46 <edwardk> EvilTerran: the problem is iirc, there is both a comonad and a monad for the prod-type construction, and the comonad is the construction that is dual to the free monad
07:49:16 <vixey> it should be some where on here? http://code.google.com/p/agda/issues/list?can=1&q=&colspec=ID+Type+Status+Priority+Milestone+Owner+Summary&cells=tiles
07:49:35 <dolio> Freeness is defined by adjointness to a forgetful functor, right?
07:50:02 <dolio> Are cofree things at least adjoint on the opposite side?
07:50:30 <kosmikus> vixey: number 160
07:50:33 <edwardk> good question
07:50:43 <kosmikus> it's no longer open
07:50:48 <vixey>  thanks
07:50:57 * EvilTerran will get back to you in a couple of terms, when he's done CT
07:50:59 <edwardk> well, it is a comonad, so the adjunction running the other way makes sense
07:51:30 <EvilTerran> s/CT/an introduction to CT/
07:51:40 <vixey> :/
07:51:46 <vixey> it says "status: fixed" but it doesn't show you the fix
07:51:50 <MyCatVerbs> EvilTerran: I think I need an introduction to CT introductions.
07:51:57 <edwardk> @hpaste
07:51:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:51:58 <dolio> Time to recompile. :)
07:52:48 <dolio> I guess that means I no longer have any incentive not to install GHC 6.10.3.
07:53:19 <EvilTerran> MyCatVerbs, heh; i'm hoping getting lectured on it will make things easier.
07:53:29 <edwardk> dolio: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4794#a4794
07:53:57 <edwardk> dolio: needed a higher order zipper for walking down a grammar which is parameterized on its token type
07:54:46 <EvilTerran> ... that URL could really use some rewriting
07:56:06 <dolio> edwardk: Anyhow, this is still less than 8 parameters, if that's what this is about. :)
07:56:16 <edwardk> the 'punchline' there is the Leaf data type at the bottom which is a zipper through a Grammar with token type t to a leaf parser which recognizes a single character basically when its all sewed up it defines all possible paths
07:56:30 <edwardk> dolio: 8 parameters?
07:56:48 <EvilTerran> edwardk, someone was bemoaning the lack of Typeable8 earlier
07:56:49 <dolio> I guess not. Someone above was asking why Typeable only goes up to Typeable7.
07:56:55 <edwardk> hah
07:57:14 <edwardk> dolio: nah, this was just that i was suffering internet withdrawal over the weekend, and wanted to show off my shiny new toy ;)
07:57:44 <dolio> Well, this looks like something, but I think I'm too sleepy to understand it now.
07:58:16 <edwardk> dolio: basically the nifty part is the fact that it zippers into an applicative, which i'd never seen before
07:58:41 <edwardk> the worst is yet to come because there is a version that uses all the StableName craziness to regain sharing from cyclic grammars
07:59:12 <edwardk> and that lets me build PEGs, TIGs, etc. from a common grammar format, so i can try out different parallel parser types
07:59:49 <edwardk> @hpaste
07:59:49 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:00:37 <edwardk> and the grammars feel very much like parsec/uu-parsinglib/polyparse
08:00:38 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4795#a4795
08:01:26 <edwardk> for instance that link above replaces this mess: http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/src/Data-Monoid-Lexical-UTF8-Decoder.html
08:02:06 <edwardk> and can still be run in parallel and generates the result in an arbitrary Char Reducer, which can include another parser.
08:02:47 <dolio> Wow.
08:02:50 <malcolmw> edwardk: very beautiful
08:04:03 <edwardk> i'm still limited to applicative parsers, so mostly context-free affix/attribute grammars
08:04:18 <quicksilver> edwardk: but you can layer it, right?
08:04:23 <edwardk> but since i can synthesize higher order attributes, i can deal with inherited attributes
08:04:33 <edwardk> quicksilver: yeah
08:04:43 <quicksilver> edwardk: and most practical context dependent grammars can be factored as two or three stage context-free ones
08:04:48 <quicksilver> at least, that's my informal experience
08:05:16 <edwardk> quicksilver: note the generalized signature of utf8Chars, 'many' reduces in an arbitrary Reducer rather than [a] -- the parallel parsers work as reducers.
08:05:25 <quicksilver> yes
08:05:31 <quicksilver> I did indeed note that :)
08:05:46 <edwardk> quicksilver: so yeah, layering is what its all about =)
08:06:35 <edwardk> quicksilver: i'm hoping to allow a mixture of packrat, monoidal, lalr, whatever makes sense from the grammar by sharing a grammar format to as large a degree as possible
08:06:53 <edwardk> quicksilver: but i want the monoidal parsing because it works really well when i build partial parses in a fingertree.
08:07:08 <edwardk> then i can do incremental reparsing fast
08:07:20 <quicksilver> incremental reparsing is better than doughnuts!
08:07:55 <xenoblitz> hi people got a small problem with IORefs... can someone help please? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4796#a4796 thanks
08:08:53 <quicksilver> xenoblitz: because unsafePerformIO is unsafe.
08:08:56 <quicksilver> Don't do what you're doing.
08:08:59 <vixey> lol
08:09:13 <vixey> yeah the unsafePerformIO stuff might have something to do with
08:09:35 <quicksilver> xenoblitz: the 'IORef' at top level hack depends criticially on the compiler not inlining or duplicating the newIORef
08:09:39 <xenoblitz> quicksilver, vixey: that module is not mine... its one of the best ways to detect sharing and loops in DSELs... that's why I am trying to fully understand it
08:09:39 <vixey> xenoblitz: what are you actually trying to implement?
08:09:43 <malcolmw> edwardk: of course the UTF8 grammar is really lexing, not parsing
08:09:48 <vixey> oh right sharing stuff
08:10:07 <vixey> don't hav emuch to say about that -- some programs that try and make use of it don't even compile
08:10:13 <swiert> Aha. ICFP list of accepted papers is up: http://web.cecs.pdx.edu/~apt/icfp09_accepted_papers/accepted.html
08:10:16 <edwardk> malcolmw: sure, it was just a toy grammar
08:10:32 <quicksilver> xenoblitz: OK. I don't understand GHC semantics well enough to know how I'd expect that code to behave.
08:10:46 <xenoblitz> quicksilver, vixey: can you explain a bit why the first one behaves that way in simple for-silly-people english
08:10:51 <edwardk> malcolmw: most of the interesting grammars need my horrible stable map machinery to recover sharing information so they can be run bottom up
08:11:03 <doserj> well, low is shared because it is named,
08:11:03 <quicksilver> xenoblitz: it depends criticall how often the newIORef actually gets called.
08:11:08 <vixey> xenoblitz: I don't know why -  I don't spend any time thinking about how unsafePerformIO works
08:11:28 <malcolmw> edwardk: eek!
08:11:31 <xenoblitz> quicksilver: so its a question of when low is called... I guess low is being reused
08:11:52 <xenoblitz> vixey: i don't like to work with this stuff either but I have to learn about it for my work unfortunately
08:12:01 <vixey> sorry that I can't help
08:12:04 <edwardk> malcolmw: the original version had two modules where almost every definition was unsafeCoerce ;)
08:12:07 <pejo> swiert, congrats!
08:12:07 <vixey> I'm sure there is a better solution that this rubbish btw
08:12:17 <xenoblitz> quicksilver, vixey: thanks all the same
08:12:23 <swiert> pejo: thanks.
08:12:31 <edwardk> malcolmw: i'm a bit nicer to the type checker nowadays at least
08:12:33 <xenoblitz> vixey: hehe there are other techniques but they are messy for use in DSELs
08:12:35 <swiert> (though the main credit goes to Marcos and Doaitse)
08:12:36 * vixey is just reading the list for puns
08:13:16 <vixey> not as my as I hope :(
08:13:20 <vixey> many*
08:13:33 <xenoblitz> vixey: like forcing people to use a label each time, or using sequential labels via monads but its ugly for a non-experienced user to use
08:13:44 <xenoblitz> if anyone knows of any more recently found solutions pls let me know!
08:13:44 <edwardk> malcolmw: i did figure out that i can run my 'recognizing' parsers in an arbitrary right-seminearring though, so you can extract more than just 'did it match' you can extract a parse trie or count of possible parses without doing all of the parse combinations
08:14:16 <edwardk> malcolmw: its funny how many ways all the monoids machinery is finding itself useful now that i have a coherent framework for it
08:15:23 <vixey> xenoblitz: like  low = Wire <$> ref Low  rather than  low = Wire $ ref Low  ?
08:15:37 <vixey> it's not /that/ bad
08:15:40 <edwardk> swiert: seeing you here reminds me i need to send some uu-parsinglib patches to doaitse
08:16:06 <xenoblitz> vixey: what's <$> ?
08:16:09 <swiert> edwark: cool. I'm sure he'll be interested.
08:16:16 <edwardk> xenoblitz: fmap
08:16:30 <vixey> xenoblitz: but 'ref' would be  newSTRef  or something
08:16:38 <edwardk> swiert: mostly patching it up so it can use the standard Control.Applicative, and getting rid of some bad instance heads
08:16:46 <malcolmw> edwardk: yes, the new slogan "but you don't need a full monad for that" applies in many new and surprising places :-)
08:18:27 <xenoblitz> vixey, edwardk: sorry for this question - its mostly due to my lack of knowledge - how can fmap help me?
08:18:40 <vixey> xenoblitz: maybe it can't
08:18:47 <edwardk> malcolmw: heh, basically all my 'recognizing parsers' are is just using the right-seminearring that underlies every instance of Alternative, and abusing the fact that there are more redundancies possible there than in the Applicative.
08:19:00 <edwardk> xenoblitz: your question was why you returned false when you compared refs right?
08:19:19 <edwardk> xenoblitz: thats because each one is a 'different ref', if you set one it doesn't change the other
08:19:28 <edwardk> so Eq is doing the right thing and telling you they are different!
08:19:50 <xenoblitz> edwardk: yeah i get the second case ... its more the first one i can't understand!
08:20:07 <jmcarthur> wait, there's an Eq instance for IORef?
08:20:15 <jmcarthur> hmm, actually, i have some deja vu now
08:20:32 <xenoblitz> edwardk: since low = Wire $ ref Low shouldn't both cases be the same?
08:20:43 <vixey> :t newSTRef
08:20:44 <lambdabot> forall a s. a -> ST s (STRef s a)
08:20:51 <vixey> :t Just <$> newSTRef 3
08:20:52 <lambdabot> forall t s. (Num t) => ST s (Maybe (STRef s t))
08:21:03 <vixey> :t Just $ newSTRef 3
08:21:05 <lambdabot> forall t s. (Num t) => Maybe (ST s (STRef s t))
08:21:16 <vixey> xenoblitz: (maybe that explains why)
08:21:27 <edwardk> xenoblitz: no, because you are looking at the 'same reference' in memory. low is a CAF each 'low' is the same thunk.
08:21:54 <vixey> xenoblitz: if you hate monadic style and want to write everything directly you can do this stuff in Scheme
08:22:12 <edwardk> this is why its dangerous to play with unsafePerformIO because now sharing which was previously invisible to you becomes visible to your program
08:22:20 <xenoblitz> vixey: i don't hate monadic style vixey, it requires many combinators to be introduced for looping which are not user friendly
08:22:35 <xenoblitz> edwardk: CAF?
08:22:38 <vixey> programming isn't user friendly
08:22:51 <xenoblitz> vixey: DSELS are supposed to be :)
08:22:55 <edwardk> i'll have to let someone take that, i have to run =)
08:23:07 <vixey> I guess that's why they're the new buzzword
08:23:09 <xenoblitz> edwardk: thanks all the same
08:23:13 <edwardk> xenoblitz: you just need more combinators for your DSEL.
08:23:15 <xenoblitz> vixey: not really that new
08:23:23 <jmcarthur> i think combinators are perfectly user friendly
08:23:56 <xenoblitz> jmcarthur: yeah but you need to introduce a huge number for loops when writing circuits...
08:24:10 <jmcarthur> loops?
08:24:17 <vixey> xenoblitz: there's a chapter about circuitry in CTM
08:24:21 <xenoblitz> xenoblitz: i'm quoting Claessen :) feedback loops like in latches
08:24:29 <xenoblitz> lol
08:24:40 <xenoblitz> jmcarthur: i'm quoting Claessen :) feedback loops like in latches
08:26:05 <jmcarthur> i am unfamiliar with Claessen's papers
08:26:35 <xenoblitz> jmcarthur: I'm mostly reading his stuff about his HDL in Haskell called Lava
08:28:25 <jmcarthur> eh, getting too domain specific for me to be helpful. generally, i don't think a combinator explosion is really necessary if you are choosing appropriate abstractions, but there could be some corner cases for which i am wrong
08:29:36 <xenoblitz> jmcarthur: i just wish to understand how ghc works in the cases shown in the hpaste that's all... why two cases which seem the same to me are now different all of a sudden
08:30:03 <quicksilver> xenoblitz: because unsafePerformIO performs a side-effecting operation, and you don't know when.
08:30:17 <quicksilver> xenoblitz: you have no way of knowing if GHC will perform it once or twice, in the second case.
08:30:27 <quicksilver> in the first case you might have a strong suspicion it will only do it once
08:30:31 <quicksilver> but even that is not guaranteed.
08:31:20 <xenoblitz> quicksilver: to be honest I understand the second case more than the first... to me there are two separate calls to low but apparently ghc sees the "low" and instead of evaluating it twice it evaluates it only once
08:31:39 <xenoblitz> quicksilver: for lack of a better term instead of evaluating
08:32:06 <quicksilver> let a = 3+4
08:32:09 <quicksilver> (a == a)
08:32:20 <quicksilver> would you expect GHC to do the calculation 3+4 twice?
08:32:49 <xenoblitz> quicksilver: no you are right... i guess i have remnants of OOP still running in my head
08:33:25 <pjolk> is the Halting problem really much of a problem?
08:33:29 <xenoblitz> quicksilver: it does make sense , from what you said :)
08:33:31 <vixey> pjolk: lol
08:33:44 <quicksilver> of course, your example demonstrates exactly why we hate unsafePerformIO
08:33:55 <quicksilver> since what you've shown is a violation of referential transparency
08:34:01 <pjolk> I should say , is it of much practical importance for proving programs?
08:34:03 <quicksilver> and referential transparency is great.
08:34:14 <EvilTerran> pjolk, its ramifications are, yes
08:34:36 <vixey> xenoblitz: your approach would work in ocaml
08:34:51 <pjolk> I mean that you can't prove ALL programs doesn't matter much if you cna prove 99.99%
08:34:52 <vixey> pjolk: no
08:35:13 <EvilTerran> pjolk, for instance, it tells us that it's impossible to create a church-turing-complete programming language with infallible proof of termination
08:35:17 <pjolk> is there a special set of problems that aren't provable?
08:35:20 <xenoblitz> quicksilver: yes i love it... but sometimes I need otherwise
08:35:20 <xenoblitz> vixey: ocaml is not referentially transparent then?
08:35:22 <vixey> pjolk: 99.99% of correctness proofs about programs -- halting doesn't matter
08:35:32 <quicksilver> xenoblitz: actually you are mistaken.
08:35:39 <quicksilver> xenoblitz: you never need referential transparency to fail.
08:35:42 <quicksilver> you never will, either.
08:35:44 <quicksilver> no one needs that :)
08:35:54 <vixey> xenoblitz: it's got mutable refs and most importantly it's applicative order -- which is why you can write in direct style with effects
08:35:56 <xenoblitz> quicksilver: ehhh try refering to two AND gates in a circuit
08:36:18 <quicksilver> You might possibly *want* it. But my own opinion is that actually you would be misguided then.
08:36:34 <xenoblitz> vixey: that's a bit off my head but I'll keep a mental note of that :)
08:36:34 <quicksilver> (a `AND` b) `XOR` (a `AND` c)
08:36:42 <quicksilver> omg! a circuit with two and gates!
08:36:52 <quicksilver> your contradiction needs a *lot* more context.
08:36:56 <vixey> xenoblitz: just goes with what quicksilver said, haskell being lazy is why your method doesn't work
08:37:17 <quicksilver> it's not remotely clear why a circuit having two and gates would require violations of r.t.
08:37:17 <xenoblitz> quicksilver: imagine you want to interpret a circuit with a loop to see how many gates it has... in haskell you end up with an infinite tree
08:37:18 * EvilTerran would be tempted to assign unique identities to wires
08:37:42 <vixey> xenoblitz: but if your library has CTM check it out
08:37:45 <xenoblitz> evilterran: it has been done by O'Donnell but its a bit messy
08:37:52 <xenoblitz> xenoblitz: I will :)
08:37:55 <vixey> lol
08:37:57 <xenoblitz> vixey: dammit
08:37:58 <xenoblitz> lol
08:37:59 <quicksilver> xenoblitz: what we are discussing now is *very* messy :P
08:38:02 <xenoblitz> i get confused
08:38:03 <xenoblitz> lol
08:38:05 <pozic> I use runInteractiveProcess and then waitForProcess it, but still the Haskell program terminates while the process I am running never terminates, as a result of the Haskell program dying, the started process also dies.
08:38:06 <EvilTerran> xenoblitz, so don't represent your system as a recursive data structure directly
08:38:08 <quicksilver> so "a bit" messy sounds better to me.
08:38:55 <EvilTerran> xenoblitz, like you can describe a graph in haskell as a Map NodeId (Set NodeId)
08:39:01 <xenoblitz> guys i agree with you totally... but it is a bit messy trust me to use a function to give a name every time... imagine you want to compose circuits together... you need a way of generating fresh labels yadayadayada
08:39:24 <EvilTerran> that'll be a unique supply monad, then
08:39:39 <jmcarthur> (or comonad)
08:39:39 <xenoblitz> evilterran: a monad to supply a label?
08:39:40 <quicksilver> xenoblitz: that's exactly the kind of thing haskell is good at.
08:39:51 <quicksilver> composable abstractions which supply, for example, unique names.
08:39:56 <quicksilver> although that's not the only way to do this.
08:40:04 <EvilTerran> xenoblitz, the next label to use could be considered a piece of state
08:40:15 <quicksilver> you can just shift all the names of the second circuit up by 'n' - the name of names in the first circuit.
08:40:38 <EvilTerran> xenoblitz, so you could work in a wrapped State monad to store the name supply
08:40:43 <quicksilver> a `alongSide` b = a ++ [b `renameLabelsBy` (highestLabel a)]
08:40:52 <quicksilver> there are loads of different solutions to this problem.
08:41:09 <xenoblitz> yes yes monads can be used I created a small implementation using the statemonad but then you can't really create circular circuit definitions
08:41:15 <quicksilver> you could read some papers on de bruijn indices
08:41:16 <xenoblitz> you then need loop combinators and stuch
08:41:17 <jmcarthur> why not?
08:41:20 <pozic> xenoblitz: there is mdo for that
08:41:26 <quicksilver> which solve the related problem - unique variable names for bound terms
08:41:36 <quicksilver> in the context of term languages.
08:41:37 <xenoblitz> mdo yes :) that's what the looping combinator does
08:41:38 <pozic> xenoblitz: which translates to mfix
08:42:36 <EvilTerran> MonadFix needn't even be necessary, depending on what the monad does
08:42:48 <xenoblitz> hehe look guys if you want to see what i mean best solution is to read: http://www.cs.chalmers.se/~koen/pubs/entry-lic00-thesis.html
08:42:57 <xenoblitz> but i know you can't waste your time reading that :P
08:43:24 <quicksilver> xenoblitz: but if *you* want to understand it - which is why you came here asking questions
08:43:30 <quicksilver> then you better be able to rebut our objections.
08:43:33 <xenoblitz> that's why Claessen suggested this solution... its not nice granted... but its A solution... i just wanted to understand how things work a bit more before I write anything down :)
08:43:42 <quicksilver> it's not a solution
08:43:44 <jmcarthur> it just sounds to me like you are stuck on one particular design strategy
08:43:47 <quicksilver> insofar as it doesn't work
08:43:50 * EvilTerran thinks "andGate, orGate, xorGate {-, ... -} :: M (Wire, Wire, Wire); connect :: Wire -> Wire -> M ()"
08:43:53 <quicksilver> because it depends on details of the GHC implementation
08:43:57 <quicksilver> which is undocumented
08:44:11 <quicksilver> and not even fully understood by the vaunted members of this IRC channel :)
08:44:28 <jmcarthur> EvilTerran, i can see an Arrow lurking somewhere
08:44:36 <xenoblitz> quicksilver: the solutions being suggested here have all been discussed in that thesis
08:44:37 <quicksilver> did you know, for example, that under some rare circumstances, 'low' might get evaluated in two different threads?
08:44:46 <xenoblitz> quicksilver: yes
08:44:48 <quicksilver> which can give two different refs.
08:45:11 <Zao> Great fun.
08:45:13 <xenoblitz> quicksilver: Claessen proves something about it in one of the chapters in there
08:45:14 <xenoblitz> hehe
08:45:56 <EvilTerran> jmcarthur, yeah, ArrowLoop would be another way of doing it
08:46:43 <pozic> Why doesn't waitForProcess do what it is supposed to do which would be waiting for the process to end?
08:48:35 <quicksilver> pozic: what made your haskell process die?
08:48:37 <xenoblitz> anyways people, thanks for the discussion :) at least I can see that I'm not the only one who doesn't like the solution :P
08:48:58 <pozic> quicksilver: it seems it just runs off the main thread.
08:49:13 <quicksilver> waitForProcess is not in the main thread?
08:49:25 <pozic> quicksilver: it is.
08:49:45 <quicksilver> so waitForProcess is returning too early?
08:49:48 <pozic> quicksilver: yes
08:50:37 <quicksilver> what does it return?
08:52:17 <pozic> quicksilver: hmm, ExitFailure 1.
08:52:54 <pozic> quicksilver: if I run the exact same on the shell, it doesn't exit.
08:53:11 <quicksilver> lots of things are different about shells
08:53:14 <quicksilver> buffering, ttys, etc
08:53:23 <EvilTerran> ... grr. neither of the bots have "instance Show (f (Mu f)) => Show (Mu f)"? =/
08:53:24 <quicksilver> maybe the program behaves differently called non-interactively.
08:54:17 <pozic> quicksilver: in ghci it works
08:55:04 <vixey> , src 'Fix
08:55:05 <pozic> quicksilver: which PATH is runInteractiveProcess using by default?
08:55:05 <lunabot>  luna: Not in scope: data constructor `Fix'
08:55:06 <vixey> , src ''Fix
08:55:09 <lunabot>  newtype Fix s a = InB {outB :: (s a (Fix s a))}
08:55:19 <vixey> , InB Nothing
08:55:20 <lunabot>  luna: Couldn't match expected type `s a (Control.Functor.Fix.Fix s a)'
08:55:33 <EvilTerran> ,src ''FixF -- is lunabot's equivalent to lambdabot's Fix
08:55:34 <lunabot>  luna: parse error (possibly incorrect indentation)
08:55:43 <EvilTerran> ,src ''FixF {- >.< -}
08:55:45 <lunabot>  newtype FixF f = InF {outF :: (f (FixF f))}
08:55:53 <vixey> , InF Nothing
08:55:54 <lunabot>  luna: No instance for (GHC.Show.Show
08:55:56 <vixey> gr
08:55:58 <EvilTerran> ?src Fix
08:55:58 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:56:13 <pozic> quicksilver: never mind, that's not it either.
08:56:20 <EvilTerran> ?? In :: (?type In); out :: (?type out)
08:56:22 <lambdabot>  In :: forall (f :: * -> *). f (Mu f) -> Mu f; out :: forall (f :: * -> *). Mu f -> f (Mu f)
08:57:26 <EvilTerran> anyway, from idle ponderings, i've devised "cata :: Functor f => (f a -> a) -> Mu f -> a; cata f = f . fmap (cata f) . out; ana :: Functor f => (a -> f a) -> a -> Mu f; ana f = In . fmap (ana f) . f" - is that about right?
09:00:24 <quicksilver> conal: congrats on icfp acceptance
09:00:57 <conal> quicksilver: thx :)
09:09:30 <pozic> quicksilver: the semantics depends on whether or not you actually read stdout/stderr.
09:09:44 <pozic> quicksilver: in other words, a huge f*ck up :(
09:09:56 <quicksilver> that's not very surprising.
09:10:16 <quicksilver> please learn how unix programs behave before trying to blame your problems on haskell standard libraries.
09:10:20 <quicksilver> kthxbye.
09:10:52 * Zao hugs his favourite non-unix platform.
09:11:06 * EvilTerran becomes utterly distracted from what he was meant to be doing by the tricks possible with Functor f => ... Mu f ...
09:12:12 <chessguy_work> conal, which paper?
09:12:32 <quicksilver> beautiful differentiation
09:12:40 <quicksilver> http://web.cecs.pdx.edu/~apt/icfp09_accepted_papers/accepted.html
09:13:16 <chessguy_work> nice
09:14:14 <conal> i'm pretty happy with how that work came out.  the idea took me quite a few passes, each time getting more to the essential simplicity.
09:15:33 <conal> (of automatic differentiation)
09:16:04 <jpcooper> hello
09:16:32 <jpcooper> I've imported Data.IntSet as qualified. How do I use IntSet in type definitions?
09:17:01 <quicksilver> Data.IntSet.IntSet
09:20:23 <jpcooper> thanks
09:22:15 <EvilTerran> jpcooper, i'd suggest "import qualified Data.IntSet as IS" (or some other shorter name); then you could write IS.IntSet etc instead
09:22:21 <Vq^> jpcooper: in case you missed it, the module documentation has a recommended way to import it
09:22:40 <jpcooper> thanks EvilTerran
09:30:05 <voker57> how to delete a file / perform other non-basic operations with filesystem?
09:30:15 <pjolk> can you have recursive lambdas?
09:30:47 <mauke> @hoogle remove
09:30:47 <lambdabot> System.Directory removeDirectory :: FilePath -> IO ()
09:30:47 <lambdabot> System.Directory removeDirectoryRecursive :: FilePath -> IO ()
09:30:47 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
09:30:47 <Botje> pjolk: sure, just give them a name
09:30:58 <ulfdoz> pjolk: not directly. fix points are defined therefore, iirc.
09:31:00 <Botje> OR use the fix function :)
09:31:15 <ulfdoz> fix point operator more precisely.
09:31:24 <Botje> myfac = fix (\fac n -> ... fac ... )
09:31:37 <pjolk> > map fac [1..10]
09:31:38 <lambdabot>   Not in scope: `fac'
09:31:41 <EvilTerran> pjolk, i tend to write "(let f ... = ... in f)" instead of (\ ... -> ...) if i want a recursive function inline in an expression
09:32:07 <EvilTerran> > map (product . enumFromTo 1) [1..10]
09:32:08 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
09:32:26 <EvilTerran> > scanl (*) 1 [1..10]
09:32:27 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800]
09:32:59 <pjolk> > map (fix (\fac n -> if n < 1 then 1 else n * fac (n-1))) [1..10]
09:33:01 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800]
09:33:14 <pjolk> > map (fix (\fac n -> if n < 1 then 1 else n * fac (n-1))) [1..5]
09:33:16 <lambdabot>   [1,2,6,24,120]
09:35:15 <mm_freak> > map product . inits $ [2..5]
09:35:16 <lambdabot>   [1,2,6,24,120]
09:35:34 <zachk> how do i get my cabal install of hoogle to return the same results as the web hoogle
09:35:54 <zachk> permutations from Data.List is missing in my hoogle
09:35:55 <Botje> threaten it wit hviolence
09:36:17 <zachk> i tried an electromagnetic, it didnt even shiver
09:36:40 <Saizan_> zachk: you need to generate your own index
09:36:55 <zachk> Saizan_: how do i do that
09:37:04 <Saizan_> zachk: in the hoogle repo there are scripts to help with that
09:37:17 <zachk> do i need darcs?
09:37:39 <mm_freak> zachk: permutations is quite new
09:37:47 <Saizan_> zachk: but in general you use cabal haddock --hoogle on a library to create the .txt database and then hoogle --convert to get the binary one
09:37:48 <jpcooper> say I have a list of things which I would like to show. How do I have to do each one separately?
09:37:55 <jpcooper> as in, write [show x, show y, show z]
09:38:15 <Saizan_> zachk: you can also browse the repo online i guess
09:38:23 <zachk> im offline alot
09:38:32 <zachk> i find hoogle very helpful
09:38:51 <Saizan_> i meant the hoogle repo to get the scripts
09:39:10 <zachk> how do i access the repo
09:39:11 <jmcarthur> jpcooper, something like (map show [x, y, z])?
09:39:18 <zmyrgel> Is there some info available how to organize / design haskell app? I
09:39:18 <zmyrgel>           mean Java has design patterns, MVC etc. How to convert these to
09:39:18 <zmyrgel>           Haskell?
09:39:29 <quicksilver> jpcooper: also, consider "show [x,y,z]"
09:39:35 <quicksilver> depends what you want to do, of course.
09:39:39 <Saizan_> zachk: http://community.haskell.org/~ndm/hoogle/
09:39:42 <jpcooper> x, y and z are of different types
09:39:47 <jmcarthur> > map show [1,2,3]
09:39:48 <Berengal> map show doesn't work for heterogenous lists
09:39:49 <lambdabot>   ["1","2","3"]
09:39:52 <jmcarthur> > show [1,2,3]
09:39:52 <jpcooper> I would like a string representation of all of them
09:39:53 <lambdabot>   "[1,2,3]"
09:40:05 <Berengal> > map show [1, "Hello", Just 5]
09:40:07 <lambdabot>   Couldn't match expected type `[Char]'
09:40:14 <Zao> > fmap show [1,2,3]
09:40:15 <lambdabot>   ["1","2","3"]
09:40:21 <skorpan> Berengal: that's interesting, why did it expect [Char]?
09:40:29 <Zao> Berengal: Last I checked, lists were homogeneous.
09:40:34 <Zao> Otherwise it wouldn't be a list.
09:40:48 <jpcooper> but 1 is not a Char
09:40:54 <doserj> jpcooper: it could be
09:40:57 <jmcarthur> yeah the map show part has nothing to do with that type error
09:41:03 <jmcarthur> > [1, "Hello", Just 5]
09:41:04 <lambdabot>   Couldn't match expected type `[Char]'
09:41:11 <doserj> well, it could be a String here
09:41:33 <Berengal> skorpan: My guess is [1::Num String => String, "Hello" :: String, Just 5 :: Maybe a]
09:41:49 <skorpan> Berengal: Num String?
09:41:53 <jpcooper> so there is no other way to show a set of things of different type other than doing it manually?
09:42:01 <quicksilver> well there is show (x,y,z)
09:42:06 <quicksilver> what are you *actually* trying to do?
09:42:11 <Zao> jpcooper: You could probably sneak up some magical instance of something for tuples.
09:42:14 <Berengal> skorpan: Yeah, it decides String has to be a member of Num, then bails on Maybe a before it checks membership
09:42:15 <quicksilver> your question doesn't contain quite enough context.
09:42:41 <skorpan> Berengal: *is* String a Num?
09:42:46 <Berengal> quicksilver: I recently ran into this problem doing toSql on a bunch of things
09:42:47 <quicksilver> if you can find a context in which the types make sense, there is probably an answer which makes sense.
09:42:58 <Zao> A tuple is an ordered sequence of finite length with heterogeneous element types.
09:42:58 <quicksilver> Berengal: sure; I'm familiar with that problem.
09:43:11 <Zao> A list is an ordered sequence of possibly infinite length with homogeneous element types.
09:43:12 <quicksilver> Berengal: I'm just not sure, yet, that that is the problem jpcooper has ;)
09:43:13 <Berengal> skorpan: No, it isn't, but it might be as far as the typechecker is concerned. It just doesn't get to the point where it checks if it's true
09:43:23 <skorpan> Berengal: interesting thought
09:43:43 <skorpan> @src Num
09:43:43 <lambdabot> class  (Eq a, Show a) => Num a  where
09:43:44 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:43:44 <lambdabot>     negate, abs, signum     :: a -> a
09:43:44 <lambdabot>     fromInteger             :: Integer -> a
09:43:56 <Berengal> @type map show [1, "Hello"]
09:43:57 <lambdabot>     No instance for (Num [Char])
09:43:57 <lambdabot>       arising from the literal `1' at <interactive>:1:10
09:43:57 <lambdabot>     Possible fix: add an instance declaration for (Num [Char])
09:44:02 <quicksilver> there is an 'abstraction failure' which says that you can't shorten [show x,show y,show z] to map show [x,y,z]
09:44:11 <quicksilver> arguably this is because haskell doesn't have first-class existentials
09:44:18 <Berengal> Yeah, it first assumes String is a Num, then figures it out later
09:44:19 <quicksilver> although thre are other ways of framing the problem.
09:44:20 <jpcooper> Zao, I'm trying to write an instance of show for one of my data-types, and I'm lazy
09:44:22 <jmcarthur> jpcooper, "a set of things of different type" is where i would like more information
09:44:38 <quicksilver> jpcooper: just derive it? ;)
09:45:00 <jpcooper> quicksilver, I only want to string representation of its fields
09:45:03 <jpcooper> the*
09:45:12 <jpcooper> I could derive, do words and drop the first word, actually
09:45:18 <Berengal> I assume you could do something with TH and tuples...
09:45:25 <quicksilver> jpcooper: you want the wrong thing.
09:45:31 <quicksilver> jpcooper: the derived show instance is the correct show instance.
09:45:32 <EvilTerran> jpcooper, that sounds like it shouldn't really be a show instance
09:45:36 <quicksilver> jpcooper: don't want something else ;)
09:45:42 <jpcooper> okay then
09:45:48 <jpcooper> I'd like to represent my data-type nicely
09:45:58 <jpcooper> I would also like to eat, so I'll be off
09:46:07 <EvilTerran> although the same problem stands regardless of whether you call your function "show" or not
09:46:09 <quicksilver> eating is good.
09:46:12 <Berengal> jpcooper: that's a job for pretty printers. Show's job is to make haskell code
09:46:13 <zachk> saizan: <no location info>: module `Array' is a package module
09:46:13 <zachk>  
09:46:38 <jpcooper> Berengal, I'd like an easier way in which to do that, then
09:46:39 <quicksilver> jpcooper: show (x,y,z) is a conveniewnt hack for debugging code
09:46:43 <quicksilver> I use that quite often.
09:46:51 * edwardk contemplates building a treap off of hashStableName but feels dirty for even thinking it
09:47:10 <zachk> edwardwk: whats a treap?
09:47:11 <quicksilver> edwardk: you're already a bad man. Will this really make you any worse?
09:47:19 <Berengal> jpcooper: Yeah, I get what you're trying to do. I'd like a good solution as well
09:47:22 <brian6> if a program p uses forkpty and gets a fd it can use to communicate with a child process, can i duplicate fd over p's stdin and stdout so someone who calls p can interact with the child process through p's stdin and stdout? or does p have to do bidirectional proxying?
09:47:42 * EvilTerran tries to work out what CINNI does with free variables
09:47:49 <edwardk> treap = hash the node's contents, and maintain the heap property on the hash while maintaining the normal properties of a binary tree on the value.
09:48:09 <edwardk> zachk: you get a 'randomized' binary tree without all the shuffling if you have a good hash function
09:48:35 <edwardk> quicksilver: probably not =)
09:49:20 * EvilTerran keeps reading "the name sort" as "the same sort". dammit, i know it's more accurate use of terminology to say "sort", but "type" reads so much less confusingly
09:52:20 <Taejo> :t uncurry . uncurry
09:52:22 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
09:54:52 <edwardk> oh alright, benchmarking it devil's advocate purposes
09:55:52 <vixey> EvilTerran: maybe it's different in that context but usually if I have  v :: t :: s  I say v has type t, v has sort s
10:00:14 <EvilTerran> vixey, er, do you mean "t has sort s"?
10:00:20 <vixey> no
10:01:08 <EvilTerran> so "sort" implies skipping a level of the heirarchy, as it were?
10:01:24 <vixey> the way I use it, maybe I am the only one that says this
10:02:36 <EvilTerran> here, they're just using "name sort", "term sort", etc to talk about various syntactic categories
10:03:52 <EvilTerran> "[_]_ binds argument 0 (of name sort) in argument 1 (of term sort)"
10:04:58 <endofjelly> so what's a sort, if it's not a type or a kind?
10:05:03 <endofjelly> what kind of type is a sort? %)
10:05:12 <vixey> sorts and kind are the same thing basically
10:05:36 <endofjelly> so a sort is some sort or kind of kind.
10:05:38 <EvilTerran> i've previously heard "sort" use to mean any one of the heirarchy "value :: type :: kind :: ..."
10:07:24 <marcot> Good afternoon.
10:07:38 <marcot> Is there a way to tell alex that the language I want to parse is not case sensitive?
10:10:48 <endofjelly> EvilTerran, so its value lies in specifying some kind of sort for values, sorts and kinds?
10:11:56 <edwardk> endofjelly: sorts give you a classification scheme to which everything can belong. have you looked at pure type systems? they define a small set of sorts, a set of axioms, and a set of rules, where the axioms are relationships between sorts and rules define which Pi types you can define
10:12:32 <endofjelly> okay so my puns are really horrible and nobody gets them, I got it thanks ;)
10:12:35 <edwardk> endofjelly: vixey's definition works pretty well in most PTSs as an intuition for what a sort is
10:14:20 <EvilTerran> marcot, it shouldn't matter to the lexer, anyway
10:14:21 <endofjelly> thanks for explaining anyway, I really didn't know there were "sorts" and it sounds useful.
10:15:59 <edwardk> endofjelly: http://people.cs.uu.nl/johanj/MSc/jwroorda/ has a pretty good overview of the ideas of a pure type system and includes enough detail to get down to how to implement languages with case, etc. in it
10:16:48 <endofjelly> edwardk, I think I might like the idea of a pure type system. I'm currently playing with my implementation of a very small functional language, maybe I can play around with that. thanks!
10:17:38 <edwardk> endofjelly: lemme know if you have any questions, its a really interesting way to build a type system and a hell of a lot cleaner than say system F.
10:18:25 <endofjelly> edwardk, ah. as far as I know my project adviser at uni does a lot with system F. but I will let you know if something comes up
10:19:31 <endofjelly> edwardk, is henk 2000 implemented in haskell?
10:20:03 <endofjelly> "The concepts of ... `dependent types' arise naturally in functional programming languages based on the systems in this hierarchy."
10:20:06 <endofjelly> oh
10:21:12 <endofjelly> edwardk, never mind, just read that it's using parsec and JH's pretty printing library
10:22:28 <skorpan> @hoogle (a -> b) -> (Maybe a) -> b
10:22:28 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
10:22:28 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
10:22:28 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
10:23:12 <endofjelly> @t ap
10:23:12 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:23:15 <endofjelly> :t ap
10:23:16 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:23:25 <endofjelly> :t fmap
10:23:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:23:50 <endofjelly> :t lift
10:23:50 <EvilTerran> marcot, sorry, reviewing the docs, am i right in thinking the problem is distinguishing case-insensitive keywords?
10:23:51 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
10:24:02 <endofjelly> :t liftM
10:24:04 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:24:11 <EvilTerran> oh, he's gone. nvm. =/
10:34:23 <lukeo05> Anyone know a place I can get some good, simple exercises to give me practice doing basic stuff for my Introduction To FP exam?
10:35:25 <Jaydon_> hi, I am trying to write a simple haskell code to output latex text, but am a little confused about how haskell handles special characters such as "\" and "&"
10:35:49 <leadnose> lukeo05, this might be of interest: http://www.ic.unicamp.br/~meidanis/courses/mc336/2006s2/funcional/L-99_Ninety-Nine_Lisp_Problems.html
10:36:13 <Lemmih> Jaydon_: '&' is not a special character.
10:36:29 <lukeo05> leadnose: thanks a lot. that looks useful :)
10:36:53 <leadnose> beware that you can't flatten arbitrary lists in haskell :)
10:37:01 <leadnose> arbitrarily nested
10:37:33 <Jaydon_> let test = "\ "
10:37:33 <Jaydon_> <interactive>:1:15: lexical error in string/character literal at end of input
10:37:48 <Lemmih> Jaydon_: "\\ "
10:38:07 <Jaydon_> Prelude Char Data.Char> let test = "\\ "
10:38:08 <Jaydon_> Prelude Char Data.Char> test
10:38:08 <Jaydon_> "\\ "
10:38:11 <Jaydon_> I only want one backslash
10:38:21 <Lemmih> Jaydon_: You only got one.
10:38:38 <Jaydon_> hmm..
10:38:41 <Lemmih> Jaydon_: It's being escaped. Have a look at the length.
10:38:50 <jmcarthur> Jaydon_, if you were to putStrLn that string you would have one
10:39:18 <Jaydon_> ah!
10:39:22 <Jaydon_> thankyou muchly!
10:40:45 <younder> Haskel uses the same abbrevs as in C that is \r \n \b etc. so to get a \ you write \\..
10:41:23 <younder> Haskell
10:41:33 <zachk> anyone: how do i make a database of package modules (Array) using hoogle
10:44:36 <C-Keen> I need to parse a stream of bytes/bits, what should I use to do that?
10:59:59 <edwardk> @hpaste
11:00:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:01:01 <edwardk> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4798#a4798 has my first cut at a cheesy StableName based treap.
11:01:29 <edwardk> now i just need something to benchmark it with
11:01:50 <edwardk> ideas?
11:02:08 <voker57> @hoogle [a] -> [ [a] -> [a] ] -> [a]
11:02:08 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
11:02:17 <voker57> @hoogle [ [a] -> [a] ] -> [a] -> [a]
11:02:17 <lambdabot> Data.Generics.Aliases ext1T :: (Data d, Typeable1 t) => (d -> d) -> (t d -> t d) -> d -> d
11:10:01 <benbread> Here be witchcraft
11:13:28 <Lemmih> benbread: Hey, long time no see. (:
11:18:56 <pjolk> so my teacher told me I'm a Functor in the category of idiots, what did he mean?
11:19:21 <pjolk> @type (>>>)
11:19:22 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
11:19:36 <pjolk> > (***) (+1) (3,4)
11:19:37 <lambdabot>   Couldn't match expected type `b' -> c''
11:19:46 <pjolk> > (***) (+1) (+4) (3,4)
11:19:47 <lambdabot>   (4,8)
11:20:01 <pjolk> > (+1) *** (+4) (3,4)
11:20:02 <lambdabot>   Couldn't match expected type `b' -> c''
11:20:05 <pjolk> > (+1) *** (+4) $ (3,4)
11:20:07 <lambdabot>   (4,8)
11:20:24 <pjolk> > (&&&) (+4) $ (3,4)
11:20:25 <lambdabot>   Couldn't match expected type `b -> c''
11:20:29 <pjolk> > (&&&) (+4) (3,4)
11:20:30 <lambdabot>   Couldn't match expected type `b -> c''
11:20:33 <centrinia> You map idiot objects to objects of some other category, map mappings between idiot objects to mappings between objects of another category, maintain the associative property, and preserves the identity map from the idiot category to the other category.
11:22:38 <pjolk> so in short, I make people stupid?
11:22:52 <pjolk> @type (&&&)
11:22:53 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:23:07 <pjolk> i dont get &&&
11:23:37 <centrinia> No, that would be what a contravariant functor in the category of idiots is.
11:23:42 <pjolk> > (&&&) (+3) (3,4)
11:23:43 <lambdabot>   Couldn't match expected type `b -> c''
11:23:56 <pjolk> > (+3) (&&&) (3,4)
11:23:57 <lambdabot>       Overlapping instances for Show ((b, c') -> (b, (c, c')))
11:23:57 <lambdabot>        arising...
11:24:54 <pjolk> > (+3) &&& (3,4)
11:24:55 <lambdabot>   Couldn't match expected type `b -> c''
11:25:11 <pjolk> > (&&&) (+) (3,4)
11:25:12 <lambdabot>   Couldn't match expected type `a -> c''
11:25:18 <pjolk> > (&&&) (+) 1 (3,4)
11:25:19 <lambdabot>       Overlapping instances for Show ((t, t1) -> (t, t1))
11:25:20 <lambdabot>        arising from...
11:25:29 <centrinia> @type (&&&) (+)
11:25:30 <lambdabot> forall a c'. (Num a) => (a -> c') -> a -> (a -> a, c')
11:25:41 <centrinia> @type (&&&) (+) (*)
11:25:42 <lambdabot> forall a. (Num a) => a -> (a -> a, a -> a)
11:25:56 <edwardk> centrinia: well, he did say in the category of idiots, that would seem to indicate that each idiot is an object, and that since he is a functor _in_ the category of idiots, probably that each idiot is a category unto itself
11:25:57 <pjolk> > (&&&) (+) (*) (3,4)
11:25:58 <lambdabot>       Overlapping instances for Show ((t, t1) -> (t, t1))
11:25:58 <lambdabot>        arising from...
11:26:03 <pjolk> > (&&&) (+1) (*3) (3,4)
11:26:04 <lambdabot>       No instance for (Num (t, t1))
11:26:04 <lambdabot>        arising from the literal `1' at <i...
11:26:13 <pjolk> > (&&&) (+1) (*3) 3
11:26:14 <lambdabot>   (4,9)
11:26:17 <pjolk> ah!
11:26:26 <pjolk> > (+1) &&& (*3) $ 3
11:26:27 <lambdabot>   (4,9)
11:26:28 <centrinia> edwardk, good point.
11:26:34 <pjolk> so arrows are awesome-tuplers
11:27:20 <centrinia> Maybe the category of idiots is a category of functors as well.
11:27:33 <centrinia> Can you have a category whose objects are sometimes functors?
11:27:45 <edwardk> if he was an endofunctor on the category of idiots he'd swap idiots around, as it is, he probably just mixes up while leaving connected diagrams of some idiot when mapping it onto another idiot.
11:28:09 <edwardk> centrinia: well, the category of idiots would clearly be some subcategory of Cat. perhaps the category of idiots is Lolcat.
11:28:58 <voker57> @sr flip
11:28:58 <lambdabot> flip f x y = f y x
11:29:18 <centrinia> @sr flip . flip
11:29:18 <lambdabot> Source not found. My pet ferret can type better than you!
11:29:39 <skorpan> is there anything nice for automagically prettyprinting/treeifying a datastructure?
11:29:45 <jmcarthur> :t flip . flip
11:29:46 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
11:29:55 <pjolk> > fmap (\_-> 1 . flip) [((+) 2)]
11:29:56 <lambdabot>       Overlapping instances for Show ((a -> b -> c1) -> c)
11:29:56 <lambdabot>        arising fro...
11:30:05 <pjolk> > fmap (1 . flip) [((+) 2)]
11:30:06 <lambdabot>       No instance for (Num ((b -> (b -> c1) -> c1) -> c))
11:30:06 <lambdabot>        arising from...
11:30:16 <centrinia> @type 1 . flip
11:30:17 <lambdabot> forall c a b c1. (Num ((b -> a -> c1) -> c)) => (a -> b -> c1) -> c
11:30:23 <centrinia> Uh, yeah...
11:30:31 <pjolk> > fmap ((flip) 1) [((+) 2)]
11:30:32 <lambdabot>       Overlapping instances for Show (a -> c)
11:30:33 <lambdabot>        arising from a use of `s...
11:30:41 <pjolk> > fmap (\x -> (flip x) 1) [((+) 2)]
11:30:42 <lambdabot>       Overlapping instances for Show ((b -> c) -> c)
11:30:42 <edwardk> skorpan: look up vacuum
11:30:42 <lambdabot>        arising from a us...
11:30:58 <juturnas> How would you load binary data from a file?  I have a file of floats written in C that I want to load in haskell.  I think I need to use the Foreign module and Storable, but I can't quite put it all together
11:31:11 <edwardk> skorpan: it shows you how data is shared in the underlying data structure and can output graphviz or be used as a back end to ubigraph, etc.
11:31:34 <skorpan> edwardk: i just want something simple generic thing which prettyprints it to my terminal
11:31:45 <edwardk> juturnas: be warned the format of Binary/Storable for floats and doubles isn't an ieee floating point, irc.
11:31:46 <skorpan> well, not necessarily printing it, but serializing it
11:32:00 <bavardage> deriving Show :P?
11:32:08 <skorpan> bavardage: that's not pretty :P
11:32:19 <bavardage> yeah, but it serialises :D
11:32:26 <bavardage> I didn't realise you were going to be *fussy*
11:32:27 <bavardage> ^^
11:32:30 <skorpan> :)
11:32:37 <juturnas> edwardk, thanks. I was afraid of something like that
11:32:46 <athos> @src (<+>)
11:32:46 <lambdabot> Source not found. There are some things that I just don't know.
11:33:01 <juturnas> but is there not a way to convert it from Foregin.C.Types CFloat to a haskell value?
11:33:06 <edwardk> juturnas: you can do something with Foreign.* to do it, but, blech.
11:33:27 <edwardk> juturnas: thats the way to do it, iirc. CFloat/CDouble are just newtype wrappers
11:33:46 <juturnas> I'll just check out the sources later then.  thanks edwardk
11:34:37 <mm_freak> i'm having DNS issues for hackage.haskell.org
11:34:43 <mm_freak> anyone else?
11:35:03 <mm_freak> % host hackage.haskell.org
11:35:03 <mm_freak> ;; connection timed out; no servers could be reached
11:35:17 <Liskni_si> juturnas: you can use fromRational . toRational (that's the way to convert between floating types, iirc)
11:35:58 <Asztal> mm_freak: works for me: A       69.30.63.197
11:36:53 <mm_freak> ah, now it works
11:36:57 <mm_freak> thanks
11:37:36 <skorpan> i can't seem to find any *generic* prettyprinting library for showing tree-like datastructures... anyone?
11:40:03 <tomh> anyone tested haskell on windows7?
11:40:06 <Botje> always used Text.PrettyPrint
11:40:36 <skorpan> Botje: it's not generic though, right?
11:55:39 <duckinator> hi
12:01:09 <Botje> not really :)
12:09:38 <edwardk> cute. found a haskell hashlife implementation while hunting for users of stablename: http://dotat.at/prog/life/hslife.hs
12:11:07 <mm_freak> haskell's RTS detects when an MVar operation blocks forever and throws an exception
12:11:10 <mm_freak> can i rely on this?
12:11:30 <mm_freak> or does this fail sometimes?  i'd think that it's related to the halting problem
12:12:30 <edwardk> mm_freak i think its related to the way ghc finds <<loop>> -- i.e. it only finds easy cases
12:13:24 <Cale> hmm, I believe it happens during GC if there are no references to that MVar held by other threads.
12:14:04 <edwardk> hence if you have a reference being held but which cannot be reached, it won't save you from yourself
12:14:43 <mm_freak> yeah, that makes sense
12:15:51 <mm_freak> now suppose i have a reader and a potential writer…  how can i kill both safely, such that killing one doesn't throw an exception in the other?
12:16:15 <ehird> Are there any XML libraries for Haskell that verify the validity of the generated document in the type system? OCaml has one of thos.
12:16:17 <ehird> *those
12:17:25 <edwardk> gah simon, simon and elliott's original paper on StableNames mention an Ord instance for StableName that seems to have vanished. =/ and it was flagged as wontfix in the trac.
12:17:33 <edwardk> i realize why, but still its irksome
12:17:59 <edwardk> er simon simon and conal
12:21:35 <andyjgill> You can use the hashStableName, to get Ord, or at least an approximation of it.
12:22:08 <andyjgill> IntMap [(StableName a,b)] works, where the Int is the result of the hashStableName.
12:22:49 <edwardk> andyjgill: yeah thats what i've been using
12:23:09 <edwardk> andyjgill: i understand why, since the Eq isn't really Eq since the Ints might outlive the slot
12:23:31 <edwardk> er the equal case
12:23:47 <andyjgill> Yes. But they work well, otherwise.
12:23:56 <wli> type TreeHash t t' = IntMap (Map t t') where the IntMap index is a hash function of the key?
12:25:22 <edwardk> andyjgill: i'm somewhat surprised that 'hashStableName' doesn't really distribute well across the integers though, since they are just consecutive slot #s, so if you carry around the hashes much longer than the names themselves you can accrete a lot of cruft in the same buckets.
12:26:18 <andyjgill> It worked fine for my application, observing graphs, and turning them into explicit graphs.
12:26:53 * wli guesses Array Int (Map t t') might be a better idea.
12:26:56 <edwardk> andyjgill: yeah i'm using it for detecting sharing in a set of parser combinators. it works wonderfully there
12:27:57 <edwardk> i was just experimenting to see if i could use it, hackishly as a fast(ish) priority for a treap implementation, but the general monotonicity of hashStableName means its too biased to be used for that
12:28:03 <andyjgill> Cool. have you a reference or a writeup?
12:28:49 <edwardk> andyjgill: i'm still putting the library together. i'd point you to the current docs on comonad.com but my server is apparently offline at the moment. =/ i have some hpasted fragments from today though, one sec
12:28:52 <wli> For tree hashing? It's just the usual hashing by separate chaining with balanced binary search trees for collision chains.
12:30:38 <edwardk> andyjgill: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4794 has the gist of how i invert an applicative parser using a higher kinded zipper without sharing.
12:31:46 <andyjgill> Looks interesting. Have you seen my data-reify library?
12:32:18 <edwardk> andyjgill: and then i go through http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4800#a4800 to do the stable map
12:32:31 <PetRat> Are the mailing lists down right Now?
12:32:32 <wli> Never heard of it.
12:32:32 <edwardk> no, have you seen my reflection library? =)
12:32:36 <edwardk> checking =)
12:33:01 <edwardk> oh nice
12:33:26 <andyjgill> Looks related! There is a paper http://www.ittc.ku.edu/~andygill/paper.php?label=DSLExtract09
12:33:43 <edwardk> very nice
12:34:15 <pumpkin_> is something wrong with my email or did haskell-cafe go really quiet?
12:34:22 <andyjgill> We should compare notes (offline), and see if we can combine. I'm especially pleased with the ability to reify functions in data-reify.
12:34:30 <PetRat> pumpkin_ that's what I'm asking too
12:34:38 <edwardk> basically what i'm doing is inverting the parser by finding sharing of base parsers and then using a series of bottom up parsers from my monoidal lib
12:34:48 <pumpkin_> PetRat: I'd guess that means the traffic just died down :P
12:34:54 <PetRat> My post to haskell-beginners did not appear in 12 hours. Another post was rejected.
12:35:05 <PetRat> Rejected with the message "disk full"
12:35:09 <pumpkin_> PetRat: oh, you think it's the list server that's died?
12:35:13 <pumpkin_> ah :/
12:35:28 <andyjgill> edwardk: Ahh. Nice. So you can get LR style parser ideas in there?
12:35:33 <PetRat> I suspect the list server has died, yes.
12:36:20 <edwardk> andyjgill: yeah, that and i've been looking at various ways to do parsing monoidally, so i can run LR or PEG style grammars by chunking the input and parsing chunks in parallel to recombine
12:36:24 <PetRat> Last post I got from haskell-cafe was 17 hours ago. Considering the average traffic is several posts per hour, this is a strong symptom.
12:36:31 <edwardk> and for that i really need the bottom up perspective on the grammar
12:36:42 <pumpkin_> I wonder who runs it then
12:37:03 <andyjgill> which needs observable sharing. I think I understand what you are doing.
12:37:10 <apostlion> hai guys!
12:37:18 <apostlion> welcome a fresh haskellero in your ranks
12:37:57 <jmcarthur> welcome
12:38:07 <edwardk> andyjgill: think of it as a 'two finger' version of the usual bottom up kilbury style parser. it parses reasonably efficient left to right or right to left and can merge chunks as needed
12:38:23 <apostlion> how's it going?
12:38:26 <edwardk> andyjgill: which puts it in the same class as all of the 'Reducers' in my monoids lib
12:39:07 <andyjgill> I think observable sharing is about to make a comeback! I've talked to two people in two days about it.
12:39:08 <thoughtpolice> pumpkin_: boo!
12:39:26 <jmcarthur> observable sharing?
12:39:52 <apostlion> A question as to best practices / overall style guidelines
12:40:01 <apostlion> —as to latter, are there any in Haskell community?
12:40:04 <edwardk> andyjgill: i'm half tempted to allow two forms of construction, one using observable sharing and the other using explicit 'safe' sharing through mfix in a builder monad.
12:40:11 <edwardk> ala frisby
12:40:22 <apostlion> I see that source mainly uses camelCase, but that's pretty much it
12:40:37 <apostlion> say, what is more acceptable — where or let?
12:40:54 <edwardk> apostlion: use where when you can let when you must ;)
12:41:13 <andyjgill> I'm thinking of two compatible versions of Lava with the same pair of API's, OS, and mfix.
12:41:19 <edwardk> apostlion: there is a style guideline doc somewhere but i can never remember where it is
12:41:31 <andyjgill> What have you seen from frisby?
12:41:37 <pumpkin_> oleg uses underscores for some reason
12:42:02 <apostlion> What is worse—
12:42:10 <edwardk> andyjgill: meacham used a little builder monad that let you define rules and mfix to use them backwards and forwards through the grammar
12:42:20 <gwern> andyjgill: wait, how can you reify functions? doesn't that violate some rule or other?
12:42:21 <apostlion> —having a huge routine in a where condition for a tiny algo, or an unneeded “public” function?
12:42:25 <apostlion> *top-level
12:42:59 <edwardk> andyjgill: all packrat-style memoized recursion had to be done through an explicit invocation of newRule and had to go through mfix
12:43:05 <edwardk> its a bit heavy handed for me
12:43:06 <andyjgill> gwern I make it IO, and wave a wand.
12:43:23 <edwardk> gwern: unsafePerformScary ;)
12:43:48 <gwern> andyjgill: how powerful is this reification? could one define some random very complex function in ghci, serialize to disk, start up another ghci and load it in?
12:44:02 <vixey> unsafePerformOcaml
12:44:06 <andyjgill> Ultimately, I want an observation monad.
12:44:25 <andyjgill> No, its can only be done on specific functions, aka the ideas from Pan.
12:44:40 <edwardk> andyjgill: what i've been looking for with mmorrow is a way for vacuum to intelligently handle ghc thunks without forcing them.
12:45:04 <gwern> andyjgill: hm. I'm not familiar with what functions pan can handle
12:45:12 <edwardk> so you can get a more properly indicative graph showing what uses what in memory and how things share environments
12:45:29 <pumpkin_> edwardk: what'd be fun would be an interactive view, where clicking on a thunk would "expand" (evaluate) it :P
12:45:31 <andyjgill> Its about reifying a (Float,Float) -> Color function.
12:45:37 <edwardk> pumpkin_: exactly!
12:45:44 <cypher-> what's the best way to do something like: compile some c, load the object code dynamically and execute it from haskell program?
12:45:49 <pumpkin_> but then you get into GUI issues
12:45:51 <jmcarthur> apostlion, that is really personal preference, but a not on your use of the word "public": you can have top-level functions without exporting them from the module, so there is not really any harm in having more than necessary
12:46:00 <jmcarthur> *a note
12:46:06 <andyjgill> Hmm, perhaps a thread management system, where you could limit a thread to single stepping?
12:46:08 <apostlion> oh, that's actually nice
12:46:09 <duaneb> dons: what was that binary i/o library you showed me?
12:46:21 <apostlion> I'm working over Real World Haskell now, and didn't got yet to modules and stuff
12:46:22 <edwardk> pumpkin_: thats exactly the sort of thing that ubigraph is designed to handle, dynamically updated graphs like that
12:46:36 <pumpkin_> edwardk: oh, cool... I've never played with ubigraph
12:46:38 <apostlion> so if you can have a top-level function that's not exported, that's really nice
12:46:51 <apostlion> One other question — are there any Haskell code analysis tools?
12:46:52 <jmcarthur> apostlion, module ModuleName (exportedFunction, ExportedType (ConstructorA, ConstructorB), ExportedTypeWithAllConstructors (..)) where
12:46:53 <pumpkin_> oh wow, sounds awesome
12:47:04 <jmcarthur> apostlion, look for hlint
12:47:28 <apostlion> wow!
12:47:33 <apostlion> a lint for Haskell!
12:47:34 <byorgey_> @seen solrize
12:47:34 <lambdabot> solrize is in #haskell. I last heard solrize speak 10h 44m 32s ago.
12:47:43 <jmcarthur> apostlion, it's fairly new, but nice
12:47:46 <apostlion> I knew that switching to a compiled language with less metamagic than Ruby will do wonders :)
12:47:50 <EvilTerran> apostlion, i only tend to put things in a function's where{} clause if they need the parameters of the function to be in scope
12:47:54 <gwern> andyjgill: interesting. so it works only on pure functions? string -> io () wouldn't work?
12:47:55 <EvilTerran> otherwise, i tend to make them top-level
12:48:23 <jmcarthur> my preference is typically just for the more readable, when i can help it
12:48:46 <apostlion> Also, is Darcs kind of a scm standard in the community?
12:49:04 <jmcarthur> apostlion, de facto, but git seems to be gaining some traction here as well
12:49:05 <edwardk> apostlion: yeah
12:49:15 <duaneb> HG ftw!
12:49:17 <gwern> eh. some traction, but not a whole lot
12:49:20 <duaneb> well, look at gitit
12:49:32 <gwern> duaneb: which also uses darcs
12:49:35 * gwern bows
12:49:50 <duaneb> dammit
12:49:51 <jmcarthur> apostlion, darcs is very nice though, for the record, and i'm coming from a longer git background
12:50:01 <duaneb> ehh, I hate darcs's branching
12:50:08 <jmcarthur> i agree with that
12:50:12 <gwern> duaneb: we call it 'darcsit' when you use gitit with a darcs backend
12:50:14 <jmcarthur> in-place branching is much nicer
12:50:25 <jmcarthur> darcs essentially has no "branching" per se, though
12:50:37 <jmcarthur> it's not really a part of its model, like it is in git's
12:50:47 <gwern> in-place branching confuses me. I don't mind cding to ../ and doing a get
12:51:03 <pumpkin_> bbl :)
12:51:11 <duaneb> I like mercurial's the best
12:51:24 <jmcarthur> darcs is patch management, git is state management. very different ideas, and they can clash if you call darcs repositories "branches"
12:51:43 <duaneb> wait, is List linked?
12:51:53 <duaneb> i.e. is (!!) constant or linear?
12:51:58 <jmcarthur> duaneb, linear
12:52:01 <EvilTerran> ?src []
12:52:01 <lambdabot> data [] a = [] | a : [a]
12:52:04 <duaneb> ahh
12:52:19 <EvilTerran> ^ pseudocode, not real haskell
12:52:25 <duaneb> dammit
12:52:33 <duaneb> I was just getting ideas of defining new syntax :P
12:52:39 <EvilTerran> think "data List a = Nil | a `Cons` List a"
12:52:51 <Zao> A rather narrow tree :)
12:52:55 <duaneb> @info List
12:52:55 <lambdabot> List
12:53:00 <duaneb> :/
12:53:02 <gwern> > [0 .. ] !! 10000000000
12:53:13 <EvilTerran> duaneb, @info gets spelling-corrected to @undo
12:53:17 <lambdabot>   mueval: Prelude.read: no parse
12:53:27 <EvilTerran> @info do x <- foo; return (x,x)
12:53:27 <lambdabot> foo >>= \ x -> return (x, x)
12:53:28 <gwern> hm
12:53:31 <duaneb> gwern: though, to be fair, it also has to generate those numbers first
12:53:53 <EvilTerran> > repeat () !! 10^9
12:53:56 <lambdabot>       No instance for (Num ())
12:53:57 <lambdabot>        arising from a use of `^' at <interacti...
12:54:06 <EvilTerran> > repeat () !! (10^9) -- ?
12:54:11 <lambdabot>   ()
12:54:12 <leadnose> > let x = x in length [x,x,x,x,x]
12:54:14 <lambdabot>   5
12:54:25 <jmcarthur> duaneb, it will actually do that simultaneously as it traverses the list, and garbage collect behind it if nothing else holds the head of the list
12:54:34 <jmcarthur> so it can theoretically be done in constant space
12:55:09 <duaneb> jmcarthur: my point was, even if !! were constant, [1 .. ] !! 1000000000 would still be linear
12:55:16 <duaneb> at least
12:55:21 <jmcarthur> ah, yes, that is true
12:55:25 <EvilTerran> duaneb, but (repeat () !!) would be constant
12:55:36 <gwern> constant space, but not time?
12:55:38 <apostlion> Meh, it's either Cabal that's lame or me that's dumb
12:55:39 <duaneb> EvilTerran: yes, that's true.
12:55:44 <duaneb> gwern: indeed
12:55:49 <duaneb> assuming garbage collection
12:55:50 <apostlion> cabal: happy version >=1.17 is required but it could not be found.
12:55:50 <apostlion> cabal: Error: some packages failed to install:
12:55:50 <apostlion> haskell-src-exts-0.4.8 failed during the configure step. The exception was:
12:55:51 <apostlion> exit: ExitFailure 1
12:56:03 <dcoutts> apostlion: cabal install happy
12:56:08 <apostlion> well, I just did :)
12:56:14 <apostlion> Moreover, it even managed to install after all
12:56:17 <dcoutts> then it's not on the $PATH
12:56:24 <gwern> yah
12:56:25 <apostlion> happy or cabal?
12:56:28 <dcoutts> happy
12:56:56 <gwern> dcoutts: maybe we could hardcode a check into cabal to look in ~/.cabal/bin and print out a message 'hey happy's there, but not in your $path; maybe you should fix this man'
12:57:23 <dcoutts> gwern: aye, put the target bindir on the program search path
12:57:32 <apostlion> woo, works this way!
12:57:33 <apostlion> yay yay ya
12:57:44 <dcoutts> gwern: unfortunately it's a bit tricky to do, given the current code structure
12:57:54 <gwern> dcoutts: hm. that's different though; that would let users install and build with tools that they can't access
12:58:02 <gwern> a message could help them fix the problem at the root
12:58:18 <duaneb> cabal: cannot configure utility-ht-0.0.5. It requires QuickCheck >=1.1 && <2
12:58:22 <dcoutts> gwern: I don't see that's a problem
12:58:23 <duaneb> gah
12:58:46 <gwern> 'where's happy? you say I should have it because of yi, but yi built and I don't have happy? wtf'
12:58:47 <vixey> happy and alex are so so horrible I wish people wouldn't use them
12:59:01 <duaneb> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4801#a4801
12:59:15 <duaneb> could someone resolve that dependency problem? :P
12:59:28 <dcoutts> gwern: the time to warn is during configure or install when we notice that the proposed bindir is not on the path
12:59:29 <gwern> vixey: I'd put more weight on that comment if I hadn't heard some haskeller or other hate on each and every feature of haskell and every thing written in haskell
13:00:48 <dcoutts> duaneb: the package you're trying to install depends on other packages and they depend on different versions of QC
13:01:14 <duaneb> dcoutts: yes, I see that
13:01:17 <duaneb> but how do I friggin fix it?!
13:01:22 <dcoutts> duaneb: that or you're installing several things in one go
13:01:30 <duaneb> `cabal install yi`
13:01:36 <dcoutts> ah
13:01:41 <gwern> (call in st. dogbert to expel the minions of phil, prince of insufficient light?)
13:02:09 <mm_freak> how does hGetLine decide, where a line ends?
13:02:22 <dcoutts> duaneb: look for the package that requires <2, it'll probably be listed earlier in that -v output log
13:03:03 <dcoutts> duaneb: or ask the yi devs, someone must be able to install it
13:05:18 <vegai> whoa
13:05:18 <gwern> or first, get from darcs, try, and then ask us
13:05:27 <gwern> vegai: it's full of stars!
13:05:31 <vegai> :)
13:05:41 <vegai> I was just amazed about haskeline in ghci-6.10.3
13:06:05 <vegai> everything is instantenous
13:06:47 <vegai> yes, I'm impressed easily sometimes.
13:07:30 <Gracenotes> :;o
13:07:42 <Gracenotes>  . . . . . . > > >> > > >>>>>>:3
13:12:15 <mreh> > [ x | x <- [1..2], y <- [1..5]]
13:12:17 <lambdabot>   [1,1,1,1,1,2,2,2,2,2]
13:13:16 <mm_freak> hmm…  i'm in a StateT s IO monad and i'd like to catch an exception there…  is this somehow possible?
13:13:25 <mm_freak> reason is:  if i catch it in IO, i lose the state
13:14:26 <jmcarthur> liftIO?
13:15:04 <mm_freak> jmcarthur: a liftIO'ed computation can't modify the state
13:15:16 <mreh> how come computer science doesn't have it's own radical branch of intellectuals who think all things can be explained by turing machines?
13:15:19 <vixey> @unmtl StateT s IO
13:15:20 <lambdabot> err: `StateT s IO' is not applied to enough arguments, giving `/\A. s -> IO (A, s)'
13:15:25 <mm_freak> i thought of ContT, but i'm sure that there is a better method
13:15:29 <vixey> mreh lol
13:15:32 <jmcarthur> but couldn't you just use liftIO to get the value into your StateT?
13:15:43 <vixey> @unmtl StateT s IO a
13:15:43 <lambdabot> s -> IO (a, s)
13:15:57 <mm_freak> mreh: because everything can be explained as a lambda expression
13:16:13 <mreh> you haven't read the church turing thesis
13:16:14 <vixey> mm_freak: why not write the catch thing in terms of that
13:16:30 <Botje> hmm
13:16:34 <mm_freak> vixey: is it 'okay' to touch the internals of StateT?
13:16:39 <vixey> I'm ok with it :)
13:16:48 * mreh is a turing machine
13:17:16 <mm_freak> in other words:  am i going fine with standards when i use StateT constructors?
13:17:23 <Botje> i'm looking for the source on a quote re garbage collection : "lisp hackers hacked all day and went home when the garbage collector kicked in, because it usually ran all night"
13:17:36 <vixey> It's GHC stds and expect your code to break every 4 months
13:18:24 <mm_freak> hmm, ok
13:19:39 <gwern> mreh: I think CS needs a branch of intellectuals that thinks computers are powered by imprisoned devils
13:19:54 <gwern> so we have an ethical obligation to make as many and as fast computers as we can
13:19:58 <vixey> gwern that does explain a lot ...
13:20:12 <vixey> like why nothing bloody works
13:20:20 <koala_man> suddenly it all makes sense
13:20:33 <gwern> they spite us
13:22:35 <Gracenotes> ;_;
13:23:26 <Gracenotes> > "hello there" >> "?"
13:23:27 <lambdabot>   "???????????"
13:23:31 <edwardk> ok, the treap fails to be useful, stablename is too simple of a hashing function
13:23:45 <ehird> Are there any XML libraries for Haskell that verify the validity of the generated document in the type system? OCaml has one of those.
13:24:06 <jmcarthur> :t (*>)
13:24:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:24:22 <jmcarthur> > "hello there" *> "?"
13:24:23 <lambdabot>   "???????????"
13:24:37 <vixey> > "hello there" >>= const "?"
13:24:38 <lambdabot>   "???????????"
13:24:47 <vixey> oh we already had that..
13:24:56 <benny99> gwern, also explains the freebsd logo
13:25:05 <gwern> they're the only honest ones
13:26:24 * benny99 better shuts his machine down
13:26:38 <pjolk> @type splitAt
13:26:40 <lambdabot> forall a. Int -> [a] -> ([a], [a])
13:26:44 <Gracenotes> also, if we define an instance Num (a -> Char), we can have map (ord '?') "hello there"
13:27:02 <edwardk> @tell andyjgill you may also want to look at lennart's Debug.Traced writeup from his blog a while back its very similar to your Exp type
13:27:03 <lambdabot> Consider it noted.
13:27:10 <Gracenotes> er. hmm. no, it'd have to be the literal (ord '?')
13:27:27 <pk> can >>= be implemented from >> ?
13:27:30 <pjolk> @type (>>=)
13:27:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:27:37 <opqdonut> pk: no
13:27:38 <pjolk> @type (=<<)
13:27:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:28:04 <pjolk> > Just 5 -> \r $ return r + 6
13:28:05 <lambdabot>   <no location info>: parse error on input `->'
13:28:10 <JamesR> Arg
13:28:16 <JamesR> This language really is the bane of my degree
13:28:24 <pjolk> > Just 5 >>= \r $ return r + 6
13:28:25 <lambdabot>   <no location info>: parse error on input `$'
13:28:27 <pjolk> bane?
13:28:30 <ehird> JamesR: We do not apologize whatsoever. :-)
13:28:32 <pk> opqdnut: Even if we use applicative functors operations ?
13:28:35 <JamesR> :>
13:28:46 <beelsebob> pjolk: (+6) <$> (Just 5) -- this?
13:28:51 <pjolk> > Just 5 >>= \r -> return $ r + 6
13:28:52 <opqdonut> pk: yes, even then
13:28:52 <lambdabot>   Just 11
13:29:01 <agib> does aynone have any recommendations for interacting with mysql on os x?
13:29:02 <beelsebob> > (+6) <$> (Just 5)
13:29:04 <lambdabot>   Just 11
13:29:11 <jmcarthur> :t ($>)
13:29:12 <Gracenotes> hm.....................................
13:29:13 <lambdabot> Not in scope: `$>'
13:29:17 <jmcarthur> :t (<$)
13:29:18 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
13:29:28 <jmcarthur> > '?' <$ "hello there"
13:29:30 <lambdabot>   "???????????"
13:29:30 <pjolk> > (<$>) (6+) Nothing
13:29:31 <lambdabot>   Nothing
13:29:37 <pjolk> > (<$>) (6+) (Just 2)
13:29:38 <lambdabot>   Just 8
13:29:41 <beelsebob> pjolk: aka fmap
13:30:05 <opqdonut> pk: >> is the same as Applicative's *>
13:30:11 <monadic_kid> > (+) <$> Just 6 <*> Just 2
13:30:12 <pjolk> > fmap (+6) (Just 5)
13:30:13 <lambdabot>   Just 8
13:30:13 <lambdabot>   Just 11
13:30:27 <pk> @src *>
13:30:27 <lambdabot> (*>) = liftA2 (const id)
13:30:30 <pjolk> > (Just 7) `fmap` (+6) `fmap`(Just 5)
13:30:31 <lambdabot>   Couldn't match expected type `a -> b'
13:30:37 <pjolk> > (Just 7) `fmap` (+6) `fmap`(Just 5)
13:30:38 <lambdabot>   Couldn't match expected type `a -> b'
13:30:42 <beelsebob> pjolk: you need to use <*> for that
13:30:45 <monadic_kid> > (+) <$> Just 6 <*> Just 2
13:30:47 <lambdabot>   Just 8
13:30:58 <pjolk> > (Just 7) `fmap` (+6) `fmap` (Just 5)
13:30:59 <lambdabot>   Couldn't match expected type `a -> b'
13:31:01 <beelsebob> (Just (+)) <*> (Just 2) <*> (Just 6)
13:31:07 <beelsebob> > (Just (+)) <*> (Just 2) <*> (Just 6)
13:31:09 <lambdabot>   Just 8
13:31:16 <pk> opqdonut: thx
13:31:21 <pjolk> > fmap (7+) (fmap (6+) (Just 5))
13:31:23 <lambdabot>   Just 18
13:31:41 <JamesR> Ahhh, that's why I'm having so many issues! I forgot to enable replace tab w/ spaces in Notepad++ ;p
13:31:47 <jmcarthur> > (+) <$> pure 2 <*> pure 6 :: Maybe Int
13:31:48 <lambdabot>       Ambiguous occurrence `pure'
13:31:48 <lambdabot>      It could refer to either `Control.Appl...
13:32:03 <jmcarthur> > (+) <$> Just 2 <*> Just 6
13:32:04 <lambdabot>   Just 8
13:32:10 <monadic_kid> > (\x y z ->x + y + z) <$> Just 6 <*> Just 2 <*> Just 6
13:32:11 <lambdabot>   Just 14
13:32:29 <monadic_kid> > (\x y z w ->x + y + z + w) <$> Just 6 <*> Just 2 <*> Just 6 <*> Just 12
13:32:31 <lambdabot>   Just 26
13:32:50 <vixey> > liftM sum [ Just 6, Just 2, Just 6 ]
13:32:51 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Maybe t'
13:33:00 <vixey> >  sum <*> [ Just 6, Just 2, Just 6 ]
13:33:01 <lambdabot>   Couldn't match expected type `[a -> b] -> a'
13:33:10 <vixey> >  sum . sequence $ [ Just 6, Just 2, Just 6 ]
13:33:11 <lambdabot>   Couldn't match expected type `[]' against inferred type `Maybe'
13:33:16 <vixey> >  fmp sum . sequence $ [ Just 6, Just 2, Just 6 ]
13:33:17 <lambdabot>   Not in scope: `fmp'
13:33:53 <jmcarthur> sum <$> sequence [Just 6, Just 2, Just 6]
13:33:59 <jmcarthur> > sum <$> sequence [Just 6, Just 2, Just 6]
13:34:00 <lambdabot>   Just 14
13:34:14 * jmcarthur feels kind of bad for stealing all of vixey's work there ;)
13:34:32 * JamesR wishes he hadn't left this till the last minute
13:34:42 <pjolk>  > map (1+) [1..10]
13:34:46 <pjolk>  > map (+1) [1..10]
13:34:55 <beelsebob> @botsnack
13:34:55 <lambdabot> :)
13:34:55 <lunabot>  :)
13:34:59 <beelsebob> odd
13:35:00 <jmcarthur> pjb3, no spaces before >
13:35:06 <pjolk> > map (+1) [1..10]
13:35:07 <jmcarthur> err, pjolk ^^
13:35:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:35:11 <apostlion> Oh, and btw
13:35:11 <pjolk> > map (11) [1..10]
13:35:12 <lambdabot>       No instance for (Num (a -> b))
13:35:13 <lambdabot>        arising from the literal `11' at ...
13:35:16 <pjolk> > map (1+) [1..10]
13:35:17 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
13:35:25 <apostlion> Do non-lame Haskell IDEs exist?
13:35:34 <apostlion> Or, is it all vim, emacs and TextMate?
13:35:41 <beelsebob> apostlion: depends on your definition of lame
13:35:41 <vixey> apostlion: still not sure what IDE means
13:35:47 <jmcarthur> apostlion, there is one in development called leksah
13:35:48 <beelsebob> but given TextMate in that list, I'd say no
13:35:56 <pjolk> apostlion: leksah
13:35:59 <beelsebob> leksah is lame... if you're an a mac
13:36:06 <jmcarthur> apostlion, we mostly just use text editors and shells, though, i think
13:36:06 <beelsebob> :(
13:36:09 <pjolk> but i dont think it is ready yet
13:36:16 <monadic_kid> apostlion: Leksah (haven't tried it), Eclipse with EclipseFP plugin
13:36:20 <cypher-> apostlion: there's a plugin for vs2005
13:36:22 <apostlion> well, static nature would yield nicely for an IDE
13:36:25 <jmcarthur> beelsebob, leksah is pretty lame regardless, so far, in my opinion. getting better though
13:36:30 <cypher-> apostlion: but sadly does not work with vs2008 AFAIK
13:36:31 <apostlion> but TextMate is niceish for me yet
13:36:36 <beelsebob> apostlion: I use SEE
13:36:40 <cypher-> also there used to be a plugin for XCode
13:36:43 <apostlion> SEE?
13:36:44 <beelsebob> it's haskell mode is much better than TM's
13:36:45 <jmcarthur> there was a haskell plugin for xcode at some point, don't know what its status is
13:36:48 <beelsebob> SubEthaEdit apostlion
13:36:49 <cypher-> and TextMate is very good
13:36:53 <pjolk> Eclipse is a perfect example of Java software. Bloated,slow,memoryhog
13:36:57 <apostlion> oh yes
13:37:03 <apostlion> SEE is nice
13:37:07 * cypher- wishes someone fixed xcode plugin
13:37:08 <apostlion> And Eclipse is an abomination
13:37:18 <cypher-> SEE?
13:37:19 <jmcarthur> i think the haskell-mode for emacs is the nicest haskell mode of any text editor, personally
13:37:23 <jmcarthur> if only for the smart tabs
13:37:25 <opqdonut> same here
13:37:25 <beelsebob> apostlion: try it for Haskell then, it's Haskell mode is *much* better than TextMate's
13:37:35 <apostlion> I will
13:37:37 <beelsebob> cypher-: SubEthaEdit
13:37:40 * p_l uses NetBeans (and lately ViM) for java. quite nice, Emacs still pwns :P
13:37:46 <cypher-> jmcarthur: maybe that's true, but emacs is an abomination ;-)
13:37:59 <skorpan> ViM?
13:38:12 <apostlion> Emacs have broken me once, but after being brainswitched by Haskell, I think I'll be able to manage
13:38:15 <jmcarthur> cypher-, emacs is a bloated piece of crap with a few awesome modes, which are enough to sway me into using it as my main editor
13:38:19 <jmcarthur> for coding, anyway
13:38:31 <monadic_kid> gedit has sexy monospace fonts and haskell highlighting
13:38:31 <pjolk> it is great
13:38:47 <cypher-> SEE looks weird
13:38:50 <vixey> jmcarthur: emacs is a bloated piece of crap -- btw does it's being 'bloated' ever cause a problem for you?
13:39:01 <cypher-> collaborative text editing hmm..
13:39:17 <jmcarthur> vixey, never, and that's why i only bother to acknowledge it, because otherwise people will assume that i am somehow fooling myself
13:39:19 <beelsebob> cypher-: it's an excellent Text Editor just on it's own
13:39:28 <beelsebob> and the collaborative thing makes it... complete win
13:39:29 <cypher-> beelsebob: better than textmate?
13:39:32 <beelsebob> yes, and no
13:39:34 <pjolk> in emacs you can runa  repl
13:39:36 <beelsebob> depends on the language
13:39:40 <beelsebob> for Haskell, yes, easily
13:39:46 <vixey> jmcarthur: I think some programs are huge and it doesn't matter, but other programs are huge and it just makes them useless
13:39:53 <jmcarthur> vixey, agreed
13:39:57 <araujo> http://www.haskell.org/~luisfaraujo/compota.png
13:39:59 <araujo> :P
13:40:00 <vixey> hard to say what reasons are -- it just kind of happens
13:40:02 <cypher-> beelsebob: I like textmate because it's one of the most universal editors I've seen
13:40:10 <cypher-> except vim, which I use most of the time
13:40:11 <jmcarthur> i don't think emacs is among the ones that are crippled due to sheer bloat
13:40:12 <beelsebob> cypher-: yep, SEE has more modes than TM
13:40:20 <beelsebob> but TM has the killer tab-completion feature
13:40:24 <vixey> araujo but you didn't write HTML rendering yourself?
13:40:29 <beelsebob> I did talk with the TM devs about trying to write a Haskell mode for it
13:40:30 <jmcarthur> emacs has other warts (hence the "piece of crap" remark), but the size is not the reason
13:40:41 <beelsebob> but it's text system just doesn't support Haskell's layout rules in any sane way
13:40:48 <araujo> vixey, right, it is just a front-end for gecko
13:40:56 <apostlion> well
13:41:01 <apostlion> TM -has- a Haskell mode
13:41:04 <cypher-> O_o that looks nice
13:41:04 <apostlion> it's in the repository
13:41:07 <apostlion> I'm using it
13:41:09 <beelsebob> apostlion: yeh, but it's not good
13:41:10 <apostlion> Smart tabs
13:41:13 <apostlion> highlighting
13:41:14 <apostlion> yeah
13:41:19 <apostlion> compared to, say, Ruby, it's lame
13:41:23 <beelsebob> the smart tabs fail
13:41:24 <jmcarthur> TM's haskell mode is pretty much just highlighting
13:41:26 <apostlion> but better than nothing, obviously
13:41:28 <beelsebob> because they get indentation wrong
13:41:39 <beelsebob> they actually generate invalid Haskell most of the time
13:42:04 <beelsebob> admitedly though ... SEE just doesn't have that feature
13:42:05 <apostlion> well, I manually indent even Ruby code, so don't really stumble over it
13:42:09 <beelsebob> but the highlighting is better
13:42:10 <apostlion> but… still :)
13:42:24 <brian6> did you just put some crazy ... character in my irc?
13:42:32 <beelsebob> – ?
13:42:37 <jmcarthur> brian6, an ellipsis?
13:42:45 <apostlion> Yeah
13:42:47 <apostlion> …
13:42:48 <apostlion> ellipsis
13:42:48 <cypher-> beelsebob: I'll check it out at some point
13:42:49 <apostlion> “
13:42:53 <apostlion> Opening quote
13:42:53 <beelsebob> oh... *wonders if OS X converted . . . into an ellipsis*
13:42:53 <jmcarthur> on macs, option-;
13:42:54 <apostlion> ”
13:42:56 <apostlion> closing quote
13:42:57 <apostlion> —
13:42:58 <brian6> more like bloody lipses.
13:43:00 <apostlion> proper dash
13:43:01 <JamesR> Arg, I don't even know where to start ¬¬
13:43:10 <beelsebob> æ≤≥π¥ƒ©ç®¬÷≠+ here?
13:43:12 <apostlion> I love my typography to be proper, y'know
13:43:16 <jmcarthur> one of the things i miss from os x having switched mostly to linux
13:43:21 <apostlion> œ∑´®†¥ˆøπ“‘
13:43:37 <beelsebob> jmcarthur: interesting... how come?
13:44:05 <jmcarthur> beelsebob, linux has just been far more friendly to my usual tasks, is all
13:44:15 <cads> have you guys seen http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/ ?
13:44:15 <beelsebob> which tasks?
13:44:19 <mm_freak> hmm…  i type unicode stuff all the time…
13:44:20 <beelsebob> (just asking)
13:44:51 <jmcarthur> programming of all forms
13:44:58 <apostlion> holy shit, I switched from Linux to Mac and never ever looked back
13:45:08 <apostlion> Reverse converting sends shivers down my spine
13:45:10 <jmcarthur> i use mac for my photography mainly
13:45:14 <apostlion> body's aching all the time
13:45:20 <apostlion> sorry, drifting off in random lyrics
13:45:20 <beelsebob> apostlion: ditto
13:45:29 <beelsebob> programming of all forms is actually what I found OS X great for
13:45:32 <beelsebob> way way way better than linux
13:45:44 <duaneb> Nothing really matters...
13:45:51 <mm_freak> however…  what's the preferred way to parse Word8-based ByteStrings?  how is the performance of just extracting a [Word8] and passing it to a GenParser Word8?
13:46:11 <jmcarthur> i found that on os x i kept switching to tools that were ported over from linux, gradually finding myself trying to turn my os x box into a linux box anyway, so i just went ahead and switched
13:46:12 <beelsebob> mm_freak: that'll be *slow*
13:46:14 * cypher- really likes os x
13:46:18 <jmcarthur> been far easier from that point on
13:46:31 <mm_freak> beelsebob: alternatives?
13:46:31 <duaneb> I love osx, however, the cocoa bindings (i.e. HOC) are awkward
13:46:36 <cypher-> I used lots of stuff so far, from various flavours of linux to z/os at times and os x kicks ass ;-)
13:46:43 <beelsebob> mm_freak: Data.Binary and manual parsing :(
13:46:52 <mm_freak> hmm, ok
13:46:52 <beelsebob> mm_freak: lists are slow... parsec is *really* slow
13:46:53 <cypher-> +prefix portage fills some gaps
13:47:01 <apostlion> well, what are the tools ported from -linux-?
13:47:06 <ehird> Are there any XML libraries for Haskell that verify the validity of the generated document in the type system? OCaml has one of those. I suppose not
13:47:07 <apostlion> There is a lot of *nix stuff
13:47:13 <apostlion> well, OS X -is- a *nix machine
13:47:18 <apostlion> with a weird GUI
13:47:22 <monochrom> I build a shell (a layer of abstraction) in my mind so that all you Windows, Linux, Mac make no difference to my core mind.
13:47:36 <jeffersonheard> so...  I just did a cabal install and a cabal install --global, and then runhaskell Setup.lhs configure still fails saying that dependencies are missing
13:47:39 <jeffersonheard> anybody know why?
13:47:40 <cypher-> monochrom: that's only partially possible
13:47:55 <cypher-> monochrom: some of the tools that I'm used to are a pain to use in windows
13:48:00 <dcoutts> jeffersonheard: use cabal instead of runhaskell Setup.lhs
13:48:04 <jmcarthur> i found myself using tons and tons of command line tools, plus aquamacs, and that was about it. i rarely used anything specific to os x. plus i was sick of aqua since i had already tasted tiling window managers, and i wanted to use something like xmonad
13:48:12 <cypher-> well.. at the end of the day os does not matter, but surely some are more comfortable than others
13:48:12 <dcoutts> jeffersonheard: or if you must use runhaskell Setup.lhs then you need configure --user
13:48:12 <jeffersonheard> dcoutts, I would, but this is leksah
13:48:15 <jeffersonheard> not me
13:48:39 <dcoutts> jeffersonheard: ok, then it has to use configure --user
13:48:43 <apostlion> guys
13:48:51 <apostlion> I want to do a specific substraction
13:48:56 <duaneb> what's the best way to have a mutable array?/
13:48:57 <apostlion> Want to do an infix operator
13:48:59 <duaneb> that is, with constant access
13:49:06 <apostlion> what are the characters I can safely use?
13:49:10 <jmcarthur> i would make a full switch if linux had some decent photo editing software, RAW workflow, etc., but that not being the case i have kept my imac around for aperture and photoshop
13:49:12 <___> > (subtract 2) 5
13:49:14 <lambdabot>   3
13:49:15 <dcoutts> duaneb: see the MArray instances
13:49:20 <jmcarthur> plus i do like using cocoa sometimes
13:49:28 <apostlion> wanted to do `&-`, but since TextMate highlighted it weirdly, I somehow doubt it's a good idea
13:49:49 <jmcarthur> i think &- should be fine. textmate is just freaking out
13:49:56 <duaneb> ok, I guess: MArray vs STArray?
13:50:03 <dcoutts> apostlion: textmate probably doesn't grok Haskell operator lexical syntax
13:50:06 <duaneb> err, IO vs State
13:50:07 <jmcarthur> > let a &- b = a - b in 5 &- 3
13:50:09 <lambdabot>   2
13:50:14 <monochrom> Yes of course, there are "abstraction leaks" in my mind shell, too.
13:50:17 <duaneb> IOArray vs STArray
13:50:26 <apostlion> dcoutts: woo cool!
13:50:34 <dcoutts> duaneb: right, ST(U)Array and IO(U)Array are instances of the MArray class
13:51:01 <___> > let x @^#$#& y = x - y in 5 @^#$#& 3
13:51:02 <lambdabot>   2
13:51:17 <jmcarthur> that coming from somebody whose nick is ___
13:51:25 <___> :)
13:51:46 <burp_> .oO( perl )
13:52:17 <burp_> perl emulation ;)
13:52:35 <apostlion> Once Larry Wall fell asleep on a keyboard
13:52:48 <jmcarthur> > let (~!@#$%^&*) = (+) in 10 ~!@#$%^&* 5
13:52:49 <lambdabot>   15
13:52:51 <apostlion> Woken up, he realized that random characters in his editor are not just random characters
13:53:00 <___> gotta love a language that lets you define names that look like swearwords.
13:53:12 <apostlion> but a sample in a programming language God has planned his prophet Larry to design
13:53:26 <burp_> > let (|========|:::::::>) = (+) in 10 |========|:::::::> 5
13:53:27 <lambdabot>   15
13:53:33 <burp_> anyone can make a better sword? ;)
13:53:35 <opqdonut> > let (***) = const 1 in f***
13:53:36 <lambdabot>   <no location info>: parse error on input `;'
13:53:49 <opqdonut> > let (***) = const 1 in (f***)
13:53:50 <jmcarthur> > let f'ck = ("hello " ++) in f'ck "you"
13:53:50 <lambdabot>   Add a type signature
13:53:51 <lambdabot>   "hello you"
13:54:33 <apostlion> > let (=====) = (++) in "8"====="D"
13:54:34 <lambdabot>   "8D"
13:54:43 <duaneb> HAH
13:54:46 <apostlion> anyone can make a better penis?
13:54:49 <___> > cycle "lo"
13:54:49 <duaneb> that one was great
13:54:50 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
13:55:04 <apostlion> > cycle "ckfu"
13:55:05 <lambdabot>   "ckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuckfuck...
13:55:11 <jmcarthur> > let (===========) = (++) in "8"==========="D" -- better penis
13:55:12 <lambdabot>   "8D"
13:55:14 <vixey> lol
13:55:18 <vixey> kids
13:55:36 <vixey> (this is my one chance to pretend im not immature)
13:55:44 <duaneb> heh
13:56:16 <duaneb> > show $ "." ++ (cycle "142857")
13:56:18 <lambdabot>   "\".14285714285714285714285714285714285714285714285714285714285714285714285...
13:56:22 <Botje> ack! invasion of the penii!
13:56:26 <duaneb> heh
13:56:56 <duaneb> Actually, the appropriate plural would be "penes"
13:57:09 <copumpkin> omg a latin scholar
13:57:11 <JamesR> The night before a deadline == Worst possible time to forget how to work something :D
13:57:16 <copumpkin> 3rd declension penis!
13:57:18 <apostlion> Lolcats attack!
13:57:34 <apostlion> > show $"OM " ++ cycle " NOM"
13:57:34 <duaneb> wait a second
13:57:35 <lambdabot>   "\"OM  NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM ...
13:57:38 * duaneb whips out his latin dictionary
13:57:43 <jmcarthur> > '8':repeat '='++"D" -- best possible penis
13:57:44 <lambdabot>   "8=========================================================================...
13:57:49 <copumpkin> duaneb: you're right, it is
13:58:12 <duaneb> penises
13:58:15 <duaneb> there you go
13:58:20 <duaneb> vaginae, however, is correct
13:58:22 <Apocalisp> > cycle "OM N"
13:58:23 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
13:58:47 <glguy> ok ok, we get it, you know how to use lambdabot
13:59:21 <duaneb> copumpkin: yes, it is penes
13:59:21 <duaneb> :D
13:59:28 <copumpkin> yup, I wasn't denying it :)
13:59:31 <duaneb> I feel like my latin education is actually worth something now
13:59:36 <apostlion> #happs is kinda dead
13:59:41 <duaneb> all for this one moment....
13:59:48 <duaneb> anyone use turbadino?
13:59:52 <jmcarthur> apostlion, depends on the time
13:59:55 <apostlion> we need some Danish dork to build some lame PM tool in happstack for it to kick off
13:59:57 <jmcarthur> sometimes quite active
14:00:10 <Apocalisp> What's the plural of equus?
14:00:22 <monochrom> equi
14:00:22 <apostlion> eqii?
14:00:26 <apostlion> *equii?
14:00:57 <duaneb> equi or equūs
14:01:01 <duaneb> depending on the declension
14:01:06 <Adamant> horses?
14:01:24 <apostlion> but you know what's the plural of clitoris?
14:01:28 <monochrom> singular/plural is such a scam.
14:02:18 <skorpan> apostlion: clitoris?
14:02:28 <apostlion> skorpan: clitorides!
14:02:42 <skorpan> no way
14:02:47 <medfly> clitorises
14:02:52 <copumpkin> yeah, clitorides
14:02:56 <vixey> Haskell is a terse, elegant lambda calculus that has proper tail recursion, has call/cc with a monad (which lets you look at the mathematical workings), has raw data and polymorphism and pattern matching which lisp hasn't. It scales up to heavy mathematical concepts and down to something like a dynamic language. It's great for studying concurrency. It has a clear path to proof tools like Coq. About the only Schemish thing it lacks is macros.
14:03:17 <vixey> So buy now, and I'll throw this best-of-1980s love songs for free!
14:03:17 <skorpan> does anyone have a source on that statement?
14:03:19 <skorpan> [source needed]
14:03:55 <vixey> Haskell can clean off permanent marker stains before you eyes, it's not magic its science!
14:03:58 <mreh> This article makes reference to no sources
14:03:58 <apostlion> mine or vixey's?
14:04:03 <apostlion> :D
14:04:12 <skorpan> apostlion: yours
14:04:18 <mreh> New Haskell, BANG! And the dirt is gone.
14:04:30 <apostlion> http://en.wiktionary.org/wiki/clitorides
14:04:37 <apostlion> skorpan: will this do?
14:04:40 <skorpan> apostlion: any *real* source?
14:04:42 <monadic_kid> mreh: ! <--  is the cilit bang operator
14:04:42 <skorpan> :)
14:04:44 <beelsebob> yes, but it's rather strict on how you use it mreh
14:04:44 <___> If you thought that was cool, you're gonna love my nuts.
14:04:55 <skorpan> i only trust wikipedia if the article states *real* sources :)
14:05:01 <medfly> http://en.wiktionary.org/wiki/clitorises
14:05:04 <medfly> it's more obvious :)
14:05:25 <apostlion> I've seen it somewhere
14:05:27 <apostlion> Let me fetch it
14:06:07 <skorpan> i tried dictionary.com but couldn't find it
14:06:08 <apostlion> http://www.yaelf.com/aueFAQ/mifplrlsltngrkwrds.shtml
14:06:31 <skorpan> apostlion: so you're saying penes is the correct pluralization of penis?
14:06:37 <apostlion> in Latin, yes
14:06:41 <apostlion> in English, it's penises
14:06:48 <monochrom> pene alfredo
14:06:57 <skorpan> so what's the plural of clitoris in *english*?
14:07:10 <medfly> clitorises or clitorides
14:07:18 <copumpkin> I'd definitely go with clitorides
14:07:20 <copumpkin> ;)
14:07:30 <monochrom> sodium hypochloride
14:07:33 <skorpan> i go for "pussy", easy in both singular and plural
14:07:35 <___> this sure is some interesting haskell
14:07:46 <___> :P
14:07:48 <medfly> it's English, it doesn't have a body regulating it, preferring one form over the other
14:08:09 <mreh> we frequently go off topic, we can handle it
14:08:53 <mreh> dirt ! Bary Stott
14:09:06 <mreh> > dirt ! Barry Stott
14:09:07 <lambdabot>   Not in scope: `dirt'Not in scope: data constructor `Barry'Not in scope: dat...
14:09:24 <mreh> :t !
14:09:25 <PetRat> Remind me how to import data with all its constructors.
14:09:25 <lambdabot> parse error (possibly incorrect indentation)
14:09:28 <mreh> :t (!)
14:09:30 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
14:09:30 <mcnster> @hoogle seq
14:09:30 <lambdabot> Data.Sequence data Seq a
14:09:31 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
14:09:31 <lambdabot> Control.Parallel.Strategies seqList :: Strategy a -> Strategy [a]
14:09:43 <byorgey> PetRat: Foo(..)
14:09:50 <PetRat> Thanks
14:10:51 <mreh> Peter Serafinowicz's "kitchen gun" is excellent, i think it's worth checking out
14:13:25 <___> @quote
14:13:25 <lambdabot> wchogg says: We don't say "moan-oid" or "moan-o-morphism" or any other such silliness.
14:13:53 <opqdonut> @quote
14:13:53 <lambdabot> Excedrin says: the Budweiser-Miller type inference algorithm; I'm drinking beer and inferring that it might be water
14:14:01 <apostlion> @quote
14:14:01 <lambdabot> Alanna says: Saying that Java is nice because it works on all OS's is like saying that anal sex is nice because it works on all genders.
14:14:03 <___> I did think it strange the first time I heard "moan-ad"
14:14:12 * JamesR fails degree
14:14:17 <apostlion> @quote
14:14:17 <lambdabot> Duqicnk says: a monad is like a train that runs backwards in time, which is made of tiny chocolate robots
14:14:38 <apostlion> All Haskell humor is about monads. I guess someone needs to do a stand-up routine about them
14:14:44 <mreh> pm lambdabot if you like
14:17:31 <walterkronkite> is haskell pure?
14:17:50 <monochrom> Yes
14:18:11 <walterkronkite> is f# pure?
14:18:20 <tromp> nope
14:18:29 <walterkronkite> so haskelll is better?
14:18:33 <vixey> yes
14:18:35 <tromp> different
14:18:41 <vixey> better
14:18:53 <tromp> ok, better:)
14:18:53 <___> pure gives you some cool things.  It's no silver bullet.
14:19:23 <monochrom> It is silver platter.
14:19:34 <JamesR> Who wants to build me a simple database system? :P I'll pay you in hugs
14:19:35 <thoughtpolice> i'd say purity is one of the more critical things, personally.
14:19:37 <monochrom> You can serve web pages on a silver platter.
14:19:58 <mreh> JamesR, can it use only relation calculus?
14:20:01 <walterkronkite> what?
14:20:02 <mreh> relational
14:20:06 <walterkronkite> pruity is critiacal?
14:20:37 <___> important, central to the haskell philosophy.
14:20:45 <JamesR> mreh, You just spoke a different language to me :P
14:20:52 <copumpkin> walterkronkite: it makes it harder for people who aren't used to it
14:20:53 <walterkronkite> i heard haskell is very expressive
14:21:33 <apostlion> cursing is very expressive
14:21:46 <apostlion> as for programming languages, I think “terse” or “elegant” is the word
14:22:41 <___> It is.  But you'll definitely need time to unlearn imperative programming prejudices before you can express yourself in it, if that's what you're used to.
14:23:21 <monochrom> Don't take mibbit users too seriously.
14:23:38 * ___ is a mibbit user :)
14:24:15 <ray> don't take people who don't have any alphanumerics in their nicks seriously at all
14:24:29 <___> :B
14:24:38 <apostlion1234> ray: lol
14:24:58 <underscores> aw, this one's registered
14:27:07 <apostlion> ___: try 'u':'n':'d':'e':'r':'s':'c':'o':'r':'e':'s':[]
14:27:20 <monochrom> hahahah
14:27:28 <___> uh, no thanks.  :P
14:30:16 <JamesR> Im looking to dig up some old snippets I wrote about a year ago, I posted them up on a Haskell Code upload site, anyone have any idea what I mean? :P
14:30:44 <copumpkin> hpaste ?
14:30:59 <JamesR> Spot on :) Cheers
14:31:05 <copumpkin> it's probably gone though
14:31:09 <copumpkin> hpaste has changed
14:31:11 <PetRat> Does the fact that Python provides some functional concepts (list comprehensions, some maps and folds, higher-order functions) make it possible to "program functionally" in Python?
14:31:20 <copumpkin> PetRat: mostly not
14:31:43 <mm_freak> is parsec lazy?
14:31:52 <copumpkin> mm_freak: don't think so, but there's another one that is
14:32:02 <mm_freak> copumpkin: where do i find it?
14:32:08 <PetRat> copumpkin: where is Python most lacking, in your opinion?
14:32:17 <apostlion> Guys
14:32:24 <copumpkin> PetRat: no TCO and limited lambdas
14:32:29 <apostlion> Does anybody here -intuitively understand- Church numerals?
14:32:34 <PetRat> TCO?
14:32:44 <copumpkin> apostlion: what do you mean intuitively?
14:32:48 <thoughtpolice> tail-call-optimization
14:32:49 <copumpkin> PetRat: tail-call optimization
14:33:07 <apostlion> I mean, I just can't wrap my head around them
14:33:09 <PetRat> ah...
14:33:12 <mm_freak> PetRat: serious functional programming is difficult in python
14:33:20 <mm_freak> it's not a functional language after all
14:33:23 <vixey> PetRat: Scheme is good
14:33:26 <thoughtpolice> mm_freak: you may want 'polyparse' which isn't parsec but it is lazy
14:33:38 <___> 1 f = f, 2 f = f . f, 3 f = f . f . f
14:33:41 <mm_freak> thoughtpolice: thanks
14:33:48 <copumpkin> mm_freak: I think edwardk's new parsing stuff can also be lazy
14:34:11 <PetRat> Python has this concept "generators". Is that borrowed from another language?
14:34:12 <apostlion> ___:  well, that's easy
14:34:24 <PetRat> I think that generators provide a type of laziness.
14:34:31 <apostlion> when it gets to arithmetic operations and booleans though...
14:34:37 <mm_freak> PetRat: generators just emulate laziness
14:34:50 <jmcarthur> apostlion, to be honest, i never saw the value in learning church numerals
14:34:52 <centrinia> @let (^^) f n = if n == 0 then id else f . (f ^^ (n-1))
14:34:53 <lambdabot>  <local>:6:41:
14:34:53 <lambdabot>      Ambiguous occurrence `^^'
14:34:53 <lambdabot>      It could refer to either `...
14:35:06 <centrinia> @let f ^^^ n = if n == 0 then id else f . (f ^^^ (n-1))
14:35:07 <lambdabot>  Defined.
14:35:10 <jmcarthur> as it pertains to actually programming with haskell or something, that is
14:35:11 <mm_freak> generators are like a VERY simplified variant of MVars
14:35:20 <centrinia> > (+1) ^^^ 50 $ 0
14:35:22 <lambdabot>   50
14:35:22 <PetRat> What are MVars?
14:35:24 <apostlion> jmcarthur: It just seems to me to be the real foundation of all lambda calculus
14:35:28 <apostlion> something raw and real
14:35:38 <jmcarthur> apostlion, i never use church numerals in haskell
14:35:47 <jmcarthur> peano numerals, maybe
14:35:50 <apostlion> jmcarthur: Well, I don't speak of Haskell
14:35:52 <mm_freak> PetRat: MVars are thread-synchronized variables, which allow easy inter-thread messaging
14:35:57 <apostlion> But of the Higher Truth
14:36:06 <mm_freak> PetRat: one thread waits for an MVar to become full, another thread fills it
14:36:22 <copumpkin> apostlion: which parts do you specifically not understand? I don't think they're particularly useful as more than an intellectual exercise though
14:36:38 <jmcarthur> it seems to me that church numerals are only that useful in the absence of types, and even then "useful" is used loosely
14:37:00 <mm_freak> MVars are one concept, which i really miss in all other languages…  haskell makes thread synch and messaging incredibly easy
14:37:10 <apostlion> K guys
14:37:13 <apostlion> I'm off to sleep
14:37:23 <apostlion> Trying not to frak up my sleeping patterns again
14:37:31 <PetRat> Here is an article about the evilness of threads: http://www.eecs.berkeley.edu/Pubs/TechRpts/2006/EECS-2006-1.pdf Anyone familiar with this, and does Haskell address some of the evils?
14:37:41 <mm_freak> PetRat: btw, if you're interested, i've written a church list implementation in python
14:38:01 <PetRat> I don't know what a church list is.
14:38:01 <mm_freak> http://ertes.de/python/fun/chlists.py
14:38:08 <mm_freak> lists in pure lambda calculus
14:38:23 <blackh> PetRat: I should be able to answer this question.  The short answer is that Haskell definitely addresses many of the evils of threads.
14:38:33 <monochrom> A church list is the list of songs you sing during a Sunday service.
14:38:51 <PetRat> I guess I don't know enough about lambda calculus to get this concept.
14:39:30 <mm_freak> PetRat: that article aims at imperative languages or at least strict languages in general
14:39:42 <monochrom> Threads are not evil. Shared variables are.
14:39:44 <mm_freak> in haskell threading is as easy as list folding
14:41:05 <mm_freak> PetRat: read the first sentence of the conclusion chapter
14:41:26 <idnar> you might as well call them processes if there's no mutable shared state
14:41:32 <thoughtpolice> PetRat: purity by itself solves a lot of the problem. if you can't update values, then you don't need locks, so a lot of hassle goes away already just with that
14:41:53 <mm_freak> PetRat: "However, much of this difﬁculty is a consequence of the abstractions for concurrency that we have chosen to use."
14:42:06 <c_wraith> there is mutable shared state.  things like MVars are mutable shared state.  They're just abstracted.
14:42:19 <jmcarthur> STM tackles shared state fairly well
14:42:21 <PetRat> I forget the URL, but I saw another article about how any Haskell program can run on multiple cores through a scheme in which the cores divide up the waiting thunks. they used this system on the GHC compiler and got a significant speed increase---despite the fact GHC was not conceived as a parallel program.
14:42:27 <idnar> c_wraith: MVars are "evil" :P
14:43:03 <idnar> c_wraith: but okay, at least you have a lot more explicit control over MVars
14:43:17 <thoughtpolice> PetRat: that is no longer the case - for a little sliver of time they did have a version of GHC that built stuff in parallel (using multiple cores,) but it turned out to be very fragile
14:43:19 <gwern> ok, anyone want to browse test.darcs.net for me?
14:43:36 <mm_freak> PetRat: this doesn't work well for practical code, so GHC doesn't do this automatically, but you can designate areas of your code, which should run in parallel
14:43:37 <jmcarthur> we do have par, for cases where you only care about the parallelism and not the concurrency
14:43:38 <gwern> i'd appreciate going to all pages and clicking on a few dozen pages :)
14:43:46 <thoughtpolice> PetRat: but it's still pretty easy to write parallel code
14:43:51 <jmcarthur> and nested data parallelism, too
14:43:52 <mm_freak> however, that's trivial parallelism
14:43:57 <thoughtpolice> PetRat: with parallel strategies, you can get 'almost implicit' parallelism
14:44:05 <mm_freak> nontrivial parallelism starts where the threads need to communicate
14:44:19 <gwern> http://test.darcs.net/ <-- visit! browse! give me some benchmarking! see a darcsit in action!
14:44:19 <thoughtpolice> PetRat: Data parallel haskell essentially aims to give you automagic parallelism
14:44:50 <jmcarthur> i still would like to try implementing my parallel annotations idea to GHC some time, but i need to work several other things out first before i can settle down with something like that
14:44:50 <thoughtpolice> gwern: seems to work good
14:45:36 <PetRat> mm_freak: "Concurrency in software is difficult"?
14:45:49 <jmcarthur> basically a parallel annotation is like a strictness annotation, except it has non-strict semantics but sparks a thread upon construction
14:45:52 <mm_freak> PetRat: the first and second sentences, sorry =)
14:46:12 <jmcarthur> *a computation
14:46:15 <jmcarthur> not a thread
14:46:18 <endofjelly> @hoogle m a -> m b -> m (a -> b)
14:46:18 <lambdabot> No results found
14:46:23 <thoughtpolice> jmcarthur: wouldn't that just be syntactic sugar for e.g. parallel strategies?
14:46:28 <gwern> thlt
14:46:31 <gwern> bleh
14:46:57 <thoughtpolice> strategies get you most of the way there fairly implicitly (although there might be a few gotchas)
14:47:01 <PetRat> I work for NASA, and someone in another division sent an email out saying they were moving to Haskell for all multiple-core programs.
14:47:11 <jmcarthur> no, parallel strategies take the form of functions and such, this is an annotation for the data type definitions themselves, and only would evaluate to weak head normal form
14:47:17 <vixey> PetRat I don't believe it
14:47:23 <mm_freak> those parallel strategies didn't work well for me…  i always got much better performance through explicit threading through concurrency
14:47:34 <vixey> PetRat: Is there any news about it on nasa site or what?
14:47:49 <jmcarthur> PetRat, if that's true then i shall apply to NASA immediately, but i don't think it's true
14:47:54 <vixey> lol
14:47:58 <PetRat> vixey: probably not.
14:48:20 <PetRat> I would have to find the email... let me look...
14:48:22 <thoughtpolice> mm_freak: well, sometimes the cost of sparking stuff with strategies outweights its actual computational price
14:48:29 <mm_freak> it would be a big improvement, but NASA is not ready for haskell =)
14:48:49 <mm_freak> thoughtpolice: it did even for long-running computations
14:49:13 <endofjelly> @hoogle [Maybe a] -> [a]
14:49:14 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
14:49:14 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
14:49:14 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:49:20 <thoughtpolice> what computations are we talking about exactly?
14:49:44 <ray> if nasa adopts haskell, haskell will be ruined! ruined!
14:49:48 <endofjelly> @hoogle [f (m a)] -> [f a]
14:49:49 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
14:49:49 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
14:49:49 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
14:50:19 <___> > catMaybes [Just 1, Nothing, Just 2, Just 3, Nothing]
14:50:20 <lambdabot>   [1,2,3]
14:50:28 <thoughtpolice> mm_freak: on that note it's worth mentioning, GHC HEAD has a bunch of improvements to parallel code that should help e.g. strategies a lot
14:50:33 <PetRat> Can't find the email---I guess it's just a rumor.
14:50:38 <mm_freak> thoughtpolice: factoring a number using trial division…  one thread tried the numbers [2,4..], the other one tried [3,5..]
14:50:46 <thoughtpolice> mm_freak: simon m. has been doing this by killing as many RTS bottlenecks as possible
14:51:01 <thoughtpolice> including stuff like work-stealing parallelism etc.
14:51:21 <mm_freak> i'll give it another try as soon as those improvements make it into a release =)
14:51:26 <PetRat> Note that most software in NASA is not "flight software"---we are not talking about stuff that controls spacecraft. Most software processes telemetry data, tracking data, scientific data.
14:51:48 <PetRat> Some software is used for requirements tracking for both hardware and software development.
14:51:57 <jmcarthur> data ParMaybe a = Nothing | Just @a -- trivial example of a parallel annotation. same semantics as Maybe, but optimistically evaluates the value if it exists
14:52:14 <alexsuraci> What's the proper way to import data and its constructors?
14:52:58 <PetRat> Mission designers---the people who figure out a good way to get gravity assists for deep-space spacecraft---run huge search spaces on parallel computers.
14:53:08 <ray> you mean like import Module(Type(..))
14:53:11 <mm_freak> import Data.Maybe (Maybe(..))
14:53:12 <jmcarthur> data ParStrictList a = Nil | Cons @a !(ParStrictList a) -- list with strict spine and parallel elements (closest to a typical parallel strategy with lists, i think?)
14:53:26 <alexsuraci> ray: mm_freak: that must be it, thanks
14:53:32 <PetRat> To estimate fuel usage for a deep-space spacecraft, huge Monte Carlo simulations are run.
14:54:13 <jmcarthur> that sounds like something more appropriate for distributed computation than parallel computation
14:54:15 <monadic_kid> PetRat: http://noordering.wordpress.com/2009/02/01/simulating-n-bodies-and-functional-programmingre/
14:54:29 <PetRat> Most of it is embarassingly parallel.
14:55:32 <PetRat> monadic_kid: nice
14:56:07 <beelsebob> >.>
14:56:17 <beelsebob> didn't expect that one to be popular
14:56:29 <beelsebob> shame reactive isn't stable enough to make it actually work
14:56:30 <beelsebob> :(
14:56:55 <monadic_kid> beelsebob: that's yours?
14:56:58 <beelsebob> yep
14:57:09 <monadic_kid> beelsebob: i made it popular ;)
14:57:11 <jmcarthur> data ParList a = Nil | Cons !a @(ParList a) -- list that is evaluated from head to tail in order in another thread
14:57:15 <beelsebob> sweet :)
14:57:35 <jmcarthur> in *other threads*, i mean
14:57:59 <monadic_kid> beelsebob: http://www.reddit.com/r/haskell/comments/7u0mu/simulating_nbodies_and_functional_programming/
14:58:33 <beelsebob> elsuive_snk_kid: neat
14:59:51 <beelsebob> I need to poke work and see if I can post about my guis in haskell stuff
15:02:30 <endofjelly> @hoogle (a -> b -> c) -> [(a,b)] -> [c]
15:02:30 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
15:02:30 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> (a, b) -> c
15:03:15 <skorpan> is there anything in haskell such as: power n f = f . power (n-1) f
15:04:05 <___> you could iterate and (!!)
15:04:10 <jmcarthur> :t \power n f -> f . power (n-1) f
15:04:12 <lambdabot> forall b c a a1. (Num a) => (a -> (b -> c) -> a1 -> b) -> a -> (b -> c) -> a1 -> c
15:04:22 <jmcarthur> i don't think that's what you want ;)
15:04:32 <dafis> :t curry uncurry
15:04:33 <lambdabot>     Couldn't match expected type `(a, b)'
15:04:34 <lambdabot>            against inferred type `a1 -> b1 -> c'
15:04:34 <lambdabot>     Probable cause: `uncurry' is applied to too few arguments
15:04:52 <jmcarthur> :t curry . uncurry
15:04:53 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:05:16 <Philonous> :t curry
15:05:18 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:05:32 <skorpan> ___: how would i use (!!)?  is this Prelude.!!?
15:05:51 <c_wraith> > [1..] !! 55
15:05:52 <lambdabot>   56
15:06:08 <skorpan> c_wraith: right, but how would that be used for me?
15:06:16 <skorpan> :t (!!)
15:06:17 <lambdabot> forall a. [a] -> Int -> a
15:06:22 <skorpan> :t iterate
15:06:23 <lambdabot> forall a. (a -> a) -> a -> [a]
15:07:08 <___> > (iterate ((+1).) id) !! 10 $ 5
15:07:09 <lambdabot>   15
15:07:30 <___> (+1) is your f.
15:07:44 <skorpan> i see
15:07:49 <skorpan> and this is lazy right?
15:08:06 <c_wraith> iterate has to be lazy.  otherwise it'd never return. :)
15:08:11 <___> ought to be.
15:08:13 <skorpan> heh, true :)
15:08:19 <vixey> Haskell is lazy
15:08:22 <jmcarthur> :t \f -> (iterate (f .) !!)
15:08:23 <lambdabot>     Couldn't match expected type `[a]'
15:08:23 <lambdabot>            against inferred type `(a1 -> c) -> [a1 -> c]'
15:08:23 <lambdabot>     In the first argument of `(!!)', namely `iterate ((f .))'
15:08:25 <___> I believe it'll allocate the list spine, though.
15:08:32 <jmcarthur> :t \f -> (iterate f !!)
15:08:33 <lambdabot>     Couldn't match expected type `[a]'
15:08:33 <lambdabot>            against inferred type `a1 -> [a1]'
15:08:33 <lambdabot>     In the first argument of `(!!)', namely `iterate f'
15:08:38 <jmcarthur> oh i'm dumb
15:08:42 <jmcarthur> back to work
15:08:44 <ray> haskell is lazy unless it's strict
15:08:54 <ray> lazily strict
15:09:02 * monadic_kid is lazy unless you kick him
15:09:02 <skorpan> strictly lazy
15:09:05 <jmcarthur> :t \f -> (iterate f id !!)
15:09:05 <___> :t \f n -> (iterate (f.) id !! n)
15:09:06 <lambdabot> forall a. ((a -> a) -> a -> a) -> Int -> a -> a
15:09:07 <lambdabot> forall a. (a -> a) -> Int -> a -> a
15:09:18 <jmcarthur> :t \f -> (iterate (f.) id !!)
15:09:19 <lambdabot> forall a. (a -> a) -> Int -> a -> a
15:09:32 <jmcarthur> @pl \f -> (iterate (f.) id !!)
15:09:32 <lambdabot> (!!) . flip iterate id . (.)
15:09:38 <jmcarthur> eh, not so good
15:09:41 <___> oh right, the (.) is wrong.
15:09:54 <___> nvm
15:10:58 <endofjelly> @hoogle (a,b,c) -> a -> b -> c
15:10:58 <lambdabot> No results found
15:11:10 <endofjelly> @hoogle ((a,b,c) -> d) -> a -> b -> c -> d
15:11:10 <lambdabot> No results found
15:11:36 <dobblego> @pl ((a,b,c) -> d) -> a -> b -> c -> d
15:11:36 <lambdabot> (line 1, column 10):
15:11:36 <lambdabot> unexpected ">"
15:11:36 <lambdabot> expecting variable, "(", operator or ")"
15:11:38 <___> whatcha looking for, endofjelly
15:11:47 <endofjelly> ___, "uncurry3" 8)
15:12:06 <endofjelly> or "curry3", respectively
15:12:13 <___> @type (\f (a,b,c) -> f a b c)
15:12:14 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2 -> t3) -> (t, t1, t2) -> t3
15:12:33 <endofjelly> ___, yup, just wanted to see if it's already there
15:12:37 <endofjelly> like that one:
15:12:43 <endofjelly> @type uncurry
15:12:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:13:10 <jmcarthur> :t curry3
15:13:11 <lambdabot> Not in scope: `curry3'
15:13:44 * edwardk waves hello.
15:13:56 <vixey> hi edwardk
15:14:03 <jmcarthur> endofjelly, http://hackage.haskell.org/packages/archive/utility-ht/0.0.5/doc/html/Data-Tuple-HT.html
15:14:23 <endofjelly> jmcarthur, nice, thanks
15:14:26 <edwardk> i wonder if rephrasing my grammar combinators in terms of grammar algebras might scare too many people off.
15:14:52 <edwardk> pros: easy memoization of partial folds of information from the grammar
15:14:58 <edwardk> cons: scary names ;)
15:15:17 <edwardk> and uglier types
15:16:01 <jmcarthur> people are too easily scared by names. i say use scary names all you want. types, on the other hand, get confusing when they get ugly, in my opinion
15:17:03 <gwern> @quote scary
15:17:03 <lambdabot> swix says: seriously though, this thing is too concise, it's scary, given what it does
15:17:15 <gwern> @quote scary
15:17:16 <lambdabot> swix says: seriously though, this thing is too concise, it's scary, given what it does
15:17:24 <vixey> edwardk: you can searh and replace evyrthing later, just write teh good program :p
15:17:41 <jmcarthur> use words like "warm" and "fuzzy" ;)
15:17:45 <edwardk> right now constructors for paths through the grammar look like: PathAppR :: Grammar t (a → b) → p t r b → Path p t r a -- where 'p' takes the place of Path p whenever it recurses into itself
15:18:01 <gwern> perhaps we could rename monads fuzzads and monoids fuzzoids
15:18:15 <gwern> applicative could become 'pettable'
15:18:35 <edwardk> the refactoring would change that to something where Grammar t (a -> b) -- becomes g t (a -> b) inside of all of the grammar constructors, and you use smart constructors like i do internally with paths
15:18:53 <gwern> (we could rename the foldable type class kissable, because the diagram might look like people kissing)
15:20:04 <edwardk> to get them to fit into the same type, i'd probably need to refactor the Path to take a 'PathTraits' data type as its first argument to cut it down to two arguments, the same as the grammar, but this gives an avenue for expansion as well
15:20:28 <FunctorSalad> is an mvar lock an acceptable way to share a socket among several threads?
15:20:32 <FunctorSalad> (shared writing)
15:20:47 <FunctorSalad> (my program deadlocks and I think it's that part)
15:21:41 <FunctorSalad> I guess I could make a single writer thread that aggregates stuff from the other threads
15:21:42 <edwardk> If a packet hits a pocket on a socket on a port, and the MVar is intercepted before its very last report...
15:21:59 <cypher-> guys, how could I generate, compile, load and execute C at runtime from a haskell program?
15:22:06 <FunctorSalad> edwardk: a pocket?
15:22:07 <cypher-> what would be the best way to attack this?
15:22:15 <blackh> FunctorSalad: If you do that with a Chan or something, that would be safe
15:22:17 <edwardk> cypher-: erm, use ffi to fire off a connection to perl to use Inline.C? =)
15:22:30 <c_wraith> cypher-: nuclear warheads, full spread, simultaneous detonation.
15:22:31 <edwardk> FunctorSalad: just an homage to an old dr. seuss programming meme
15:23:10 <FunctorSalad> edwardk: hehe. thought it was some weird part under the hood of sockets ;)
15:23:12 <edwardk> http://kreiger.linuxgods.com/kiki/?If+a+packet+hits+a+pocket+on+a+socket+on+a+port
15:23:34 <cypher-> edwardk: not sure if this is what I would like ;-)
15:24:12 <edwardk> cypher-: in general compiling c is a nasty platform specific thing. haskell provides you no additional machinery really to make that any easier
15:24:24 <FunctorSalad> hmm, wait! I have seperate locks for reading and writing for the same socket
15:24:29 <edwardk> cypher-: you could perhaps use ghc-as-a-library which offers some support for wrapping gcc, iirc.
15:24:37 <FunctorSalad> and one thread does a blocking read on the socket
15:24:51 <FunctorSalad> I guess that blocks the writers
15:25:22 <FunctorSalad> (obviously I know nothing about the low-level underlyings :-( )
15:26:07 <cypher-> edwardk: I'll check it out, thanks
15:26:13 <edwardk> vixey: ok, sucking it up, and refactoring into a common abstraction
15:48:29 <mreh> Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire, Are they serious?
15:49:04 <vixey> yes
15:49:31 <mreh> i'm not much one to consider something worth reading by it's grandeous title
15:49:52 <shapr> mreh: It's a nifty paper.
15:49:57 <Apocalisp> (|Bananas|)
15:50:03 <monadic_kid> and lots of cats
15:50:05 <vixey> shapr exists!!
15:50:11 <shapr> hiya vixey!
15:50:13 * shapr hugs vixey 
15:50:27 <mreh> there aren't any women here are there?
15:50:44 <shapr> Nope, none...
15:50:49 <shapr> There are Haskellers though.
15:50:53 <shapr> There aren't any males either.
15:50:57 <SubStack> koalas
15:50:57 <monochrom> shapr is proof that non-academic, non-CS-grad can appreciate Haskell.
15:51:02 <SubStack> lots and lots of koalas
15:51:06 <SubStack> lazy and slow
15:51:13 <shapr> I am not a koala!
15:51:23 <shapr> monochrom: Hey, who says I'm not academic?
15:51:30 <vixey> Am I academic?
15:51:32 <mreh> @quote 1337
15:51:33 <lambdabot> No quotes match. I've seen penguins that can type better than that.
15:51:34 * JamesR proves that you can be an academic CS-undergrad and be baffled by Haskell
15:51:42 * SubStack is one of those!
15:51:43 <vixey> haha
15:51:47 <mreh> @quote 1337_h4x0r
15:51:48 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
15:51:58 <mreh> hrmm
15:52:02 <monochrom> I guess you are academic now.
15:52:06 <shapr> vixey: I dunno... I just like playing with cool toys, and Haskell is a very cool toy.
15:52:22 <Adamant> @quote meh
15:52:22 <lambdabot> Cale says: I know I always have trouble explaining what the weather is like without involving foldr somehow.
15:52:50 * SubStack uses haskell for experimental mathematical models and opengl programming
15:53:00 <monochrom> Anyway someone yesterday was mything "haskell looks academic and you need CS PhD" again.
15:53:02 <SubStack> plus it's excellent for tackling project euler
15:53:11 <Cale> Wait, whaaaat? Did I say that?
15:53:25 <SubStack> you need tenure actually
15:53:29 * Cale has no memory of that quote.
15:53:32 <SubStack> phd is insufficient
15:53:50 <bremner> tenure might be necessary, but not sufficient
15:54:11 <Adamant> if your name is Simon, that helps.
15:54:27 <mreh> does he hang here?
15:54:31 <vixey> I don't have a CS PhD
15:54:33 <monochrom> No.
15:54:40 <gwern> Cale: you usually remember each and every thing you say in #haskell?
15:54:56 <mreh> I only have Bachellors D:
15:55:26 <Apocalisp> I've seen the inside of a university twice.
15:55:33 <Hunner> You don't need a bachellors to do haskell either
15:55:34 <shapr> @quote Apocalisp
15:55:34 <lambdabot> No quotes match. Maybe you made a typo?
15:55:37 <shapr> aww
15:55:41 <monochrom> I've seen the outside twice. XD
15:56:00 <mreh> universities are just people going in and out of rooms
15:56:01 <Apocalisp> oh drat, must think of something quoteworthy to say
15:56:11 <Axman6> mreh: says you
15:56:13 <mreh> i've stoled education
15:56:20 <mreh> it's easy
15:56:31 <JamesR> mreh: To be fair most students don't even manage that
15:56:32 <shapr> mreh: That's what I'm here for too... I'm getting an education!
15:56:44 <shapr> Let's see, today someone was filling my head full of treap info...
15:56:44 <Hunner> @quote shapr
15:56:45 <lambdabot> shapr says: <shapr> Yeah, it does require more than an oleg of type-hackery. <poetix> oleg's now a unit? <autrijus> is oleg an unit now? <shapr> Yup, a rather large unit of type-hackery too.
15:56:49 <shapr> and then went on into tripes?
15:56:54 <vixey> shapr I wonder who... :p
15:56:54 <Cale> gwern: Well, usually I have a sense of the sort of thing I might say, at least. I suppose I could have said that, but...
15:56:56 <shapr> hiya Hunner!
15:56:57 <Botje> Cale: you said it on Nov 16 2006
15:57:02 <shapr> vixey: Yeah, you know who :-)
15:57:03 <Cale> Botje: interesting
15:57:06 <Botje> around 22h30 CET :o)
15:57:13 <shapr> @quote Botje
15:57:13 <lambdabot> Botje says: #haskell: parallellising your homework answers!
15:58:04 <Botje> it was in response to Binkley saying "well, I always end up explaining what foldr is in my interviews
15:58:07 <Botje> anyway"
15:58:17 * Botje disengages creepy stalker mode
15:58:20 <monochrom> That's evil because the hardest part is serialising all the things you heard from this channel into a coherent submission.
15:58:55 * Botje is sad the haskell lessons are over
15:59:01 <Botje> now i have to pay attention because it's erlang :p
15:59:49 <shapr> Has anyone built GHC for the ARM recently?
16:00:00 <shapr> I have two ARM linux devices, and I'd like to run GHC on them.
16:00:29 <bremner> shapr: did you check debian?
16:00:57 <shapr> No, but that's a good idea, thanks.
16:04:02 <FunctorSalad> what do you do if a library type lacks some instance decl? I'm afraid that if the library gets updated, my program will fail to build due to overlap... use -XIncoherentInstances?
16:05:26 <Cale> FunctorSalad: If the library is open source, you could contribute the instance to it.
16:05:50 <FunctorSalad> good point :)
16:06:12 <JamesR> Im having a great deal of trouble with something very basic, anyone interested in trouble shooting it for me?
16:06:28 <FunctorSalad> though that'd feel a bit silly if it's just a "deriving instance Show" ;)
16:07:15 <JamesR> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4804#a4804
16:07:20 <JamesR> I'm still in Python mode
16:07:30 <JamesR> So don't grab your torches yet :P
16:08:09 <c_wraith> JamesR: the last line should be ... = x:xs
16:08:18 <c_wraith> :t (:)
16:08:19 <lambdabot> forall a. a -> [a] -> [a]
16:08:42 <c_wraith> well.  It needs more than that
16:08:43 <monadic_kid> ffs with the accidently smiley faces
16:08:45 <c_wraith> But that's the idea
16:09:00 <c_wraith> You'll also need to pattern match to deconstruct the data types
16:09:02 <monadic_kid> *accidental
16:09:09 <JamesR> Ah, fair enough
16:09:15 <c_wraith> and to use data constructors to rebuild them
16:09:28 <JamesR> I'm still foolishly trying to inherit ;)
16:13:12 <JamesR> Man, I totally don't get Haskell sometimes
16:14:28 <vixey> same
16:14:57 <JamesR> My algebraic type is a list of another Algebraic type but yet calling it as (xs) gives a type error on the grounds that it doesn't match [a]? O.o
16:15:38 <c_wraith> well, it's not a list
16:15:45 <c_wraith> it's something that contains a list
16:16:01 <c_wraith> You need to pattern match to extract the list from it
16:16:03 <monochrom> I don't understand English.
16:17:10 <lament> Englisch
16:17:19 <badtruffle> 'twas designed to be incomprehensible
16:18:14 <JamesR> On the grounds that this assigment doesn't specify the database needs to be a type ... *Removes*
16:18:28 <JamesR> Mmmm bypassing problems
16:18:36 <JamesR> How very Microsoft of me
16:18:49 <monochrom> Anyway, I mean I don't understand the question. But supposedly how you write pattern matching is derived mechanically from how you defined your data type. You don't go through an "English description" first.
16:22:07 <Cale> JamesR: Can I see what you've written? Perhaps I can explain what's going on. There's no requirement for a variable named xs to refer to a list.
16:22:30 <Cale> JamesR: However if you treat it like a list, it might have to be.
16:22:40 <Cale> (like, say, applying map, filter, etc to it)
16:23:03 <c_wraith> Cale, it's that case.  He was treating it as a list, but it was a Blah [Foo]
16:25:23 <JamesR> ;)
16:25:43 <glguy> Is this a correct way to use the parallel strategies stuff?   case rnf a >|| rnf b of () | sometest on a -> ... | sometest on b ->...
16:25:44 <glguy> ?
16:28:57 <persica> Whoa, I think reading this chapter on Monads just blew my mind.  I wish I'd learned some functional programming earlier.
16:29:28 <SubStack> \o/
16:29:41 <persica> It's like "oooh! That's what I was trying to do earlier."
16:29:44 <SubStack> mind explosions galore in haskell land
16:29:47 <JamesR> I literally just slapped myself in the face for being so stupid...
16:30:04 <persica> I like my head asploded sometimes.
16:30:08 <JamesR> All along I was assuming that (xs) was inheriting the algebraic type "Just cuz"
16:30:32 <JamesR> And only now, have I realised that I needed to put (Dbase xs)
16:30:41 * JamesR facepalms himself
16:30:45 <c_wraith> yes.  That's 50% of what you needed
16:30:45 <persica> heh.
16:30:49 <JamesR> Python spoiled me wrotten
16:31:00 <c_wraith> the other 50% is using the Dbase constructor in the right-hand side, too
16:31:01 <c_wraith> :)
16:31:02 <JamesR> So rotten I can't spell it anymore
16:35:14 <JamesR> Arg!
16:35:28 <JamesR> Why am I writing things like: (Type a,b,c,d) >_<
16:35:36 <JamesR> *Shakes fist at Python*
16:35:48 <persica> Unlearning is the hard part.
16:35:55 <persica> I'm still a bit mad at "return"
16:36:00 <JamesR> :P
16:36:16 <lament> whoever came up with that name
16:36:18 <JamesR> I spent about 9 hours today working on Python and the weekend on C# ... so this is a lot of work for me :D
16:36:32 <lament> ...could have come up with a better name
16:36:45 <persica> Oh yeah, I'm sort of lucky I spend most of my day in psudocode and system configuration.
16:36:57 <persica> Makes playing with pet languages easier.
16:39:10 <SubStack> return is a fine name
16:39:18 <SubStack> it's just not for flow control is all
16:39:52 <persica> It's just an overloaded word if you use more Haskell and any other language.
16:40:04 <persica> And we all know that overloaded functions can be a pain to debug. :P
16:42:05 * SubStack remembers reading some best practices thing about only putting returns at the end of subroutines in imperative code at some point
16:42:49 <pumpkin_> so much snake oil floating around in hardware/OS help IRC channels
16:43:44 <persica> I don't know if it's snake oil so much as stylistic differences.
16:43:54 <persica> er, wait.
16:44:00 <persica> I thought we were talking about programming still.
16:44:06 <persica> What do you mean, pumpkin_? Example?
16:44:39 <pumpkin_> like the "repair permissions" crap that everyone tells you to do if anything is wrong with mac os, or reset your pram, or defragment, etc.
16:44:51 <lament> SubStack: i don't like 'return' as a description of what it does
16:45:14 <FunctorSalad> @let devour=return
16:45:15 <lambdabot>  Defined.
16:45:50 <persica> pumpkin_: oh, yeah, I hate that.  The first thing a mac person seems to suggest when you have a problem is to repair permissions.  I don't think I've ever actually found a problem where that was the solution.
16:45:57 <Gracenotes> :o
16:46:06 <lament> SubStack: especially since haskell is a functional language, where actual functions actually return stuff all the time
16:46:33 <SubStack> haskell is linguistically powerful enough live up to return values as the last statement fortunately
16:46:52 <vixey> SubStack :what o_o
16:46:59 <persica> Well, since it's a functional language they don't actually return anything.  They're much closer to statements of equality and transformations.
16:47:04 <pumpkin_> @hackage visual-graphrewrite
16:47:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/visual-graphrewrite
16:47:05 <pumpkin_> ooh
16:47:11 <vixey> persica nicely put
16:47:15 <persica> (at least that's what I see)
16:47:18 <pumpkin_> zsol: that looks cool, any screen shots?
16:47:21 <SubStack> vixey: writing that way in langauges like c is icky
16:47:38 <pumpkin_> haskell-cafe is still dead :/
16:47:38 <SubStack> of course, so is everything
16:47:50 <JamesR> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4804#a4805    <--- My slightly less Fubar work :P
16:48:21 <persica> JamesR: You're pretty new to Haskell?
16:48:31 <lament> persica: function return values.
16:48:39 <FunctorSalad> lament: an advantage of "return" over "unit" is less concept clashing... (since the other mathematical senses of "unit" are closer to monadic unit than "return" is to monadic unit)
16:48:41 <lament> persica: that's how English works :)
16:48:44 <JamesR> Well ... Technically no but realistically yes :P
16:49:01 <persica> lament: You mean functions are mappings from one set to another?
16:49:24 <lament> persica: no, i mean in English, when talking about a function, you talk about it returning a value.
16:49:52 <lament> persica: so using "return" in any other sense is confusing and contradictory.
16:49:54 <persica> lament: We only do that because of how we're used to thinking about programming.  In mathematics I think you talk more about the result of a function than its return value.
16:50:15 <lament> [[Function (mathematics)]] for example says "A function ƒ takes an input, x, and returns an output ƒ(x)."
16:50:32 <persica> Okay, got me there.
16:50:37 <FunctorSalad> well, that's a wikipedia attempt at accessiblity
16:50:44 <vixey> lament: you want to be arguing with the C designers I think
16:50:46 * EvilTerran would've called "return" something like "embed"
16:50:54 <FunctorSalad> I agree that in math it's not so common to talk about return values
16:50:59 <persica> I don't remember using "return" in my math classes back in college, but that was a long time ago.
16:51:00 <skorpan> EvilTerran: "wrap"
16:51:05 * vixey would call it eta
16:51:05 <centrinia> It is called "pure"
16:51:11 <Pseudonym> Or "unit".
16:51:18 * EvilTerran would happily call it wrap, eta, or pure
16:51:21 <monadic_kid> you can also view a function as special kind of set that defines a *mapping* between sets
16:51:37 <lament> monadic_kid: i'm not talking about how you view it, only about terminology people use
16:51:41 <centrinia> Relations are sets.
16:51:42 <ErhardtMundt> lament: how do you type that calligraphic 'f'?
16:51:44 <EvilTerran> they're already called Monads, calling it eta wouldn't be making things much worse ;)
16:51:52 <lament> ErhardtMundt: no clue :)
16:51:58 <monadic_kid> lament: that is also terminology
16:52:20 <Pseudonym> Of course, Gofer had "box".
16:52:22 <lament> monadic_kid: i'm not sure what your point is.
16:52:25 <centrinia> Why doesn't Monad require only pure and join?
16:52:26 <ErhardtMundt> lament: :)
16:52:29 <lament> Pseudonym: i prefer that by far.
16:52:34 <lament> it's even shorter!
16:52:51 <monadic_kid> functions, relations, sequences, sets they are all related
16:52:59 <Pseudonym> box == robot ninja monkey operator
16:53:06 <lament> Pseudonym: did it have something like unsafeUnbox? :)
16:53:09 <FunctorSalad> centrinia: you don't get liftM/fmap that way
16:53:17 <Pseudonym> lament: Yes.  "head"
16:53:23 <centrinia> class Monad m where { pure :: a -> m a; join :: m (m a) -> m a; }
16:53:24 <lament> what
16:53:26 <FunctorSalad> both pure and join ignore the function arrow structure
16:53:42 <lament> head :: (Monad m) => m a -> a -- ?
16:53:43 <centrinia> class (Functor m) => Monad m where { pure :: a -> m a; join :: m (m a) -> m a; }
16:53:52 <Pseudonym> box :: a -> [a]
16:54:00 <lament> Pseudonym: oh.
16:54:03 <centrinia> return :: a -> [a]
16:54:15 <skorpan> @src Functor
16:54:15 <lambdabot> class  Functor f  where
16:54:15 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
16:54:17 <Pseudonym> But there's no reason why you couldn't have made it work on any Monad.
16:54:30 <FunctorSalad> (nevermind that last part... no real argument)
16:54:31 <Pseudonym> I like return, actually.
16:54:42 <monadic_kid> :t pure
16:54:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:54:44 <lament> it does confuse people, and has no additional merits
16:54:46 <skorpan> i don't get it... how could "pure" and "join" be used to define (>>=)?
16:54:46 <Pseudonym> Because I can tell people that return in Haskell is implemented as a user function.
16:54:56 <lament> heh.
16:54:59 <Pseudonym> skorpan: You also need fmap.
16:55:00 <monadic_kid> i prefer pure over return
16:55:06 <Pseudonym> m >>= k = join (fmap k m)
16:55:07 <monadic_kid> pure makes more sense
16:55:11 <skorpan> aha
16:55:20 <skorpan> monadic_kid: pure was already taken though
16:55:35 <FunctorSalad> isn't applicative younger?
16:55:40 <centrinia> @src Applicative
16:55:40 <lambdabot> class Functor f => Applicative f where
16:55:40 <lambdabot>     pure  :: a -> f a
16:55:40 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:55:41 <skorpan> is it?
16:55:50 <FunctorSalad> not sure
16:56:00 <monadic_kid> :t return
16:56:01 <shepheb> Applicative is way newer
16:56:01 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:56:05 <monadic_kid> :t pure
16:56:06 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:56:10 <skorpan> when was applicative added?
16:56:13 <skorpan> and when was monad?
16:56:15 <FunctorSalad> but I think if it wasn't younger then it'd be a superclass of monad
16:56:16 <skorpan> roughly
16:56:19 <monadic_kid> :t (<$>)
16:56:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:56:20 <Pseudonym> Monad was added in about 1992.
16:56:21 <vixey> In a programming context it's better to define >>=
16:56:22 <monadic_kid> :t fmap
16:56:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:56:24 <Pseudonym> Maybe 1994.
16:56:28 <vixey> in general that iss more efficient
16:56:32 <Pseudonym> It was borrowed from Gofer, anyway.
16:56:37 <Pseudonym> Applicative was about... 2001?
16:57:00 <skorpan> so i was way off
16:57:08 <skorpan> so which is the "newest" addition?
16:57:30 <Pseudonym> skorpan: STM
16:57:37 <Pseudonym> No, actually, type families.
16:57:46 <skorpan> type families?
16:57:47 <FunctorSalad> monads in math are way older still, but I guess they didn't use 'return'
16:57:58 <Pseudonym> No, they used eta.
16:58:07 <centrinia> And join.
16:58:12 <Pseudonym> skorpan: So new you haven't heard of them, apparently.
16:58:12 <FunctorSalad> that's mu :)
16:58:24 <Pseudonym> Right.
16:58:46 <skorpan> Pseudonym: i have heard of them, but thought it was some general concept
16:58:47 <necroforest> Hmm.. Looks like bash doesn't do lazy evaluation
16:58:56 <necroforest> for i in `yes`; do echo $i; done
16:59:16 <FunctorSalad> pipes are more or less lazy I think
16:59:25 <Pseudonym> skorpan: Type families are a language extension.
16:59:55 <FunctorSalad> yes | cat? ;)
17:00:23 <centrinia> What is fmap called in category theory?
17:00:40 <monadic_kid> functor isn't, general transformation
17:00:46 <FunctorSalad> it's written as NameOfFunctor(f)
17:02:07 <JamesR> O.o I didn't know Guido Rossum worked for Google
17:02:14 <JamesR> Well ... That explains a few things :P
17:02:53 <FunctorSalad> (... yes, that last statement wasn't completely accurate since a functor doesn't intrinsically have a name ...)
17:03:12 <skorpan> JamesR: what do you mean?
17:03:14 <FunctorSalad> centrinia: so I mean fmap is just written as function application of the functor :)
17:04:27 <JamesR> It explains a few things about why Google back python so strongly
17:04:39 <JamesR> Well maybe not explains but certainly helps to illustrate how
17:05:07 <glguy> The probably hired him because they back it rather htan back it because they hired him
17:05:22 <FunctorSalad> uh wouldn't it only be a conspiracy if *python* somehow became partial for google?
17:05:25 <pumpkin_> anyone know the status on the listserv?
17:05:55 <JamesR> Considering that he's "Benevolant Overlord for Life" ... How can Python not be partial now? :P
17:06:00 <FunctorSalad> pumpkin_: I was just going to ask why I fail at sending to -cafe...
17:06:13 <pumpkin_> FunctorSalad: the disk filled up, and that was supposedly fixed a few hours ago
17:06:24 <pumpkin_> but I still haven't seen anything from the list since yesterday
17:08:03 <FunctorSalad> wow. someone else actually wrote a module splitter and put in on hackage (I wrote one too but wasn't sure if it was of general interest)
17:08:32 <FunctorSalad> :)
17:09:53 <monadic_kid> it will be interesting when Ct comes some time this year
17:10:18 <FunctorSalad> Ct?
17:11:57 <monadic_kid> Intel Ct, for C/C++ compilers, it's an implementation of nested-data parallelism and will be released around when larrabee  is released. It's part of the tea-scale research
17:12:08 <monadic_kid> *tera-scale
17:13:56 <monadic_kid> I mean the interesting thing about is the nested-data parallelism
17:14:45 <monadic_kid> cause thats what some the GHC guys are working on and i'm guessing the Intel guys having been following there progress too
17:14:58 <monadic_kid> *their progress
17:20:42 <monadic_kid> oh well
17:22:27 <JamesR> Hmmms
17:22:30 <JamesR> Pattern Match error
17:22:36 <JamesR> failure*
17:23:42 <monadic_kid> is it a list pattern?
17:24:21 <Adamant> JamesR: they backed Python long before they snagged GvR
17:24:40 <skorpan> JamesR: maybe they hired guido because they like python?
17:24:46 <Adamant> GvR snagging was probably a result, not a cause
17:24:58 <JamesR> Very true
17:25:09 <JamesR> monadic_kid: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4804#a4806
17:25:23 <Adamant> they also have a policy against "advanced/obscure" languages
17:25:33 <JamesR> Like Haskell? :)
17:25:33 <Adamant> for instance Lisps and Smalltalk are both verboten
17:25:42 <pumpkin_> lol
17:25:46 <lament> they use java a lot
17:25:51 <Adamant> JamesR: Haskell wasn't on the list then but I wouldn't be surprised if it was now
17:26:11 <skorpan> guido actually mentions haskell in a comment on his own TRE blog post
17:26:17 <lament> link?
17:26:33 <skorpan> http://neopythonic.blogspot.com/2009/04/tail-recursion-elimination.html
17:26:38 <Adamant> yeah Guido has been looking at Haskell
17:27:36 <BMeph> Adamant: ...and crying, I bet. ;p
17:27:50 <Adamant> BMeph: probably, he hates anything advanced
17:28:28 <Adamant> he was pissing off all the Lispers stuck with Python at work by removing things like map and such from Python
17:28:28 <skorpan> you make it sound like haskell is advanced
17:28:38 <Adamant> skorpan: it is, relatively
17:28:43 <skorpan> i was kidding
17:28:49 <skorpan> i'm the noobmeister with haskell
17:29:04 <malouin> Anyone written anything relating to go in haskell?
17:29:04 <skorpan> seriously though, did he remove map from python? :P
17:29:07 <Adamant> skorpan: obviously it's not Agda or Epigram or dependent typed language of the week
17:29:22 <lament> "I don't think the benefits of enforcing side-effect-free code (even optionally) make up for the many work-arounds you have to use to get anything done in the real world. (Not even in Haskell, FWIW. :-)"
17:29:25 <skorpan> i think very little of agda
17:29:26 <BMeph> Adamant: Ah, I take it you read the post where he says that Py3K will have every reduce("fold")-derived function, but will toss out reduce itself... ;p
17:29:27 <Adamant> skorpan: they ended up not doing
17:29:32 <vixey> heh of the week ?
17:29:37 <lament> malouin: i'm seriously considering it
17:29:41 <lament> malouin: others have, too :)
17:30:06 <malouin> lament: I was thinking about writing just a board module, for learning
17:30:11 <lament> malouin: tromp wrote the rules quite nicely: http://homepages.cwi.nl/~tromp/go/SimpleGo.hs
17:30:11 <Adamant> BMeph: no, I dislike Python and I hope all their hype is sucked up by Ruby
17:30:32 <lament> Adamant: ouch.
17:30:38 <skorpan> Adamant: you're out of luck, ruby seems to be crashing since everyone got tired of the poignant guide
17:31:06 <BMeph> Adamant: I don't dislike Python. I just wasn't impressed enough to keep up with it once WoW made Lua ridiculously popular. :)
17:31:17 <Adamant> BMeph: Lua and Ruby are OK
17:31:24 <vixey> I dislike python but I am trying to be less of a bigot about programming languages
17:31:28 <lament> BMeph: lua and python don't seem very similar to me
17:31:34 <agib> has anyone seen this when trying to use the HDBC-mysql: "Loading package HDBC-mysql-0.5 ... can't load .so/.DLL for: mysqlclient (dlopen(libmysqlclient.dylib, 10): image not found)"
17:31:40 <lament> lua is much lower level and less pretentious
17:31:46 <Adamant> vixey: Python is the only language I'm really a bigot about. I dislike Java but I don't get worked up about it
17:32:13 <malouin> lament: yes, that's the module I was thinking about writing :)
17:32:14 <Cale> agib: It seems like it expects you to have a C library installed which you don't have.
17:32:28 <centrinia> I'm bigoted towards Visual Basic.
17:32:56 <vixey> yeah lots of us are PL bigots -- it is probably something to realize and correct
17:32:59 <Cale> agib: Since it's an FFI binding and not an implementation of a full mysql client, you'll need that library. I don't know about the Mac-specific details of how to get it myself though.
17:33:26 <Gracenotes> idiots. [not-a-language-I-like] is such a Blub language.
17:33:35 <JamesR> Thats the third time winHugs has crashed on me ¬¬
17:33:42 <vixey> I like the blub term though :)
17:33:52 <BMeph> Cale: "Friends don't let Friends code in C". ;) -- s/C/Python/ for you, Adamant. ;p
17:33:54 <vixey> this concept is fn
17:33:55 <centrinia> I'm bigoted towards bigotry. :(
17:33:58 <vixey> this concept is fun*
17:34:09 <lament> Haskell is Blub.
17:34:33 <centrinia> @faq Can Haskell Blub?
17:34:33 <lambdabot> The answer is: Yes! Haskell can do that.
17:34:36 <BMeph> vixey: I'm a bigot, but I'm not a snob. ;)
17:34:44 <Cale> Lambda the Ultimate Blub
17:34:45 <Adamant> BMeph: I run the Playa Hata's Ball, bish :P
17:34:54 <vixey> I'm probably a snob but haven't realized yet
17:35:01 <Gracenotes> Cale: yes! let it be!
17:35:28 <Cale> JamesR: Get GHCi :)
17:35:55 <agib> Cale: ah thank you
17:35:55 <JamesR> Cale: I might well do that :)
17:36:12 <agib> Cale: I thought I had the mysqlclient library though
17:36:33 <agib> how'd you know I'm mac? :)
17:36:38 <lament> malouin: why don't you write a .sgf parser instead :)
17:36:40 <Cale> agib: dylib
17:36:48 <agib> ahh
17:37:29 <agib> is there any other way to interact with mysql with haskell?
17:37:58 <malouin> lament: good idea
17:39:19 <FunctorSalad> "I don't think the benefits of enforcing side-effect-free code (even optionally) make up for the many work-arounds you have to use to get anything done in the real world. (Not even in Haskell, FWIW. :-)"
17:39:31 <FunctorSalad> (from the linked blog post)
17:39:41 <Cale> agib: There are a few other bindings... I'm not sure that you wouldn't have exactly the same problem.
17:40:05 <Cale> agib: Perhaps try searching for that file on your system, if it's there, then the problem is likely one of which paths it's looking in.
17:41:47 <FunctorSalad> I just don't get it... what is the problem with writing everything in IO if you really don't see any other way?
17:42:22 <FunctorSalad> you still get the advantage of *guaranteedly* pure subprograms for everything that doesn't need the IO
17:43:35 <JamesR> Can someone tell me where I'm going wrong with this pattern match?
17:43:49 <JamesR> returnFans (Film a b c [User[d]])
17:43:50 <Cale> FunctorSalad: right, give people a better option and all of a sudden they can't be satisfied with what they were doing in other languages.
17:44:10 <JamesR> testItem = (Film "Test" "Test2" 2000 [(User "Test")])
17:44:12 <Cale> JamesR: It looks valid, though questionable
17:44:32 <Cale> it doesn't match because "Test" is not a one-character string
17:44:46 <Cale> [d] only matches a list of length 1
17:45:06 <Cale> If you want to match any string, remove the brackets
17:46:16 <travisbrady> FunctorSalad: my impression when i came to Haskell (from Python) was that IO is really a special purpose thing that should only be used when necessary.  so i think people end up thinking "oh IO is weird, i can't just write all my code in it, it's wrong, it's not the haskell way, etc" there is also the still pervasive idea that IO in haskell is hard
17:47:40 <agib> Cale: ah, it seems like os x uses .a extensions, not .so
17:47:54 <FunctorSalad> travisbrady: I'd agree that it should be a last resort
17:49:00 <travisbrady> i agree, but i think the straitjacket can be put on one bit at a time
17:49:17 <FunctorSalad> :)
18:01:52 <Maxetime> Hi
18:03:48 <malouin> How do people translate haskell code to the pretty typeset version seen in textbooks?
18:04:29 <bremner> malouin: lhs2TeX does a decent job
18:04:39 <malouin> great!
18:05:15 * SubStack used that last week!
18:08:53 <byorgey> @remember jfredett My haskell-spider senses were tingling, I just overshot RT and went for the Halting Problem.
18:08:54 <lambdabot> It is stored.
18:13:42 <necroforest> I used lstlisting for a course where i was printing out Haskell source
18:13:47 <necroforest> (latex package)
18:13:51 <JamesR> Hmms, got another Type Error I can't resolve
18:15:47 <JamesR> Any Ideas? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4804#a4807
18:18:28 <necroforest> Hmm
18:18:32 <necroforest> you could try like
18:18:38 <necroforest> (Dbase x) y
18:18:43 <necroforest> and use (head x)
18:19:34 <necroforest> although I just copy/pasted that code and it loads into GHCI for me..
18:21:12 <JamesR> :/
18:21:46 <JamesR> Kinda sucks that my lecturer is probably going to mark using WinHugs ...
18:22:01 <necroforest> and it works with the last line changed to:
18:22:03 <necroforest>     | otherwise               = filterYear (Dbase (xs)) y
18:22:09 <necroforest> you have a class on Haskell ? o.O
18:22:22 <JamesR> Programming Languages - Concepts and Paradigms
18:22:24 <JamesR> I do indeedy
18:22:27 <necroforest> Ohhhh
18:22:34 <necroforest> My version of that was done with ML
18:24:58 <Gracenotes> I shall use ML in my course
18:25:11 <Gracenotes> when I take it in approximately a year
18:25:39 <necroforest> I had a crappy teacher for it
18:25:45 <necroforest> but the ML assignments were fun
18:27:48 <edwardk> @seen vixey
18:27:49 <lambdabot> I saw vixey leaving #scala, #haskell, #haskell-in-depth and ##logic 26m 49s ago, and .
18:28:21 <MasochisticLibra> I realize that I'm asking a (maybe) biased audience, but is Haskell a good first language for someone with limited programming experience?
18:28:27 <JamesR> Can somebody explain why I'm getting a type mismatch? I don't understand where winHugs thinks it's getting [a] From (This'll go a long way to unconfusifying me)
18:28:31 <JamesR> Nooooo
18:28:37 <necroforest> I'd go with no
18:29:16 <MasochisticLibra> Python? :/
18:29:20 <edwardk> gah, oh well, the grand refactoring thing didn't work out so well, shifting Grammar and Path to both be folded bifunctors and replacing all references to Grammar with grammar algebras caused an unfortunate side effect -- the leaf level combinators for char, tab, space, etc. ceased to be monomorphic, and so i lost sharing... and sharing was the whole point of the library!
18:29:28 <necroforest> Python is a good language
18:29:45 <byorgey> MasochisticLibra: I'd say it depends on your mathematical background.
18:29:49 <edwardk> necroforest: *arches eyebrow*
18:30:02 <byorgey> someone with a strong mathematical background but limited programming experience should have a great time with Haskell.
18:30:14 <JamesR> I'm with necroforest ... but I suck at Haskell :)
18:30:20 <necroforest> depends on how you define a strong mathematical background
18:30:42 <byorgey> JamesR: the problem is that you are trying to use  (:)  (cons) to put together two Dbases
18:30:44 <necroforest> If you have a strong enought background, you probably have been exposed to programming already ;)
18:30:50 <MasochisticLibra> I'm sixteen.  I've only taken Alg 1 / 2 and Geometry. Going to take precalc during the summer :/
18:30:51 <byorgey> but (:) only works on lists (that's the [a])
18:31:15 <JamesR> Mmmm
18:31:20 <necroforest> >:t (:)
18:31:25 <byorgey> MasochisticLibra: I'd say, give it a try.  You'll definitely learn something =)
18:31:27 <necroforest> > :t (:)
18:31:28 <lambdabot>   <no location info>: parse error on input `:'
18:31:34 <necroforest> blah stupid bot
18:32:02 <MasochisticLibra> Thanks (:. I've tried a few languages over a few years but I haven't really stuck with one
18:32:03 <byorgey> JamesR: it's a little awkward having the Dbase constructor everywhere.
18:32:07 <bremner> MasochisticLibra: look at Learnyouahaskell   (ask google) and see if it appeals
18:32:22 <byorgey> JamesR: if I were you I would first write a function  filterYear :: [Film] -> Int -> [Film]
18:32:37 <JamesR> byorgey The second you mentioned it I realised :P
18:32:43 <copumpkin> byorgey: when does HWN normally come out?
18:32:46 <MasochisticLibra> Thanks Bremner
18:33:04 <byorgey> and then if you want to make a version  Dbase -> Int -> Dbase, you can just write  filterYearDbase (Dbase films) year = Dbase (filterYear films year)
18:33:35 <byorgey> copumpkin: normally on Saturday, but I was at my little sister's college graduation this weekend
18:33:36 <JamesR> byorgey That is definitely a much better solution, Thanks!
18:33:40 <byorgey> sure!
18:35:30 <byorgey> okay people, I need some quotes for the HWN
18:35:53 <byorgey> anyone heard any good haskell-related quotes lately?  none seem to be have been saved with @remember over the past week
18:36:03 <byorgey> slackers
18:37:53 <copumpkin> :o
18:38:06 <copumpkin> someone definitely @remembered something ridiculous I said
18:38:13 <copumpkin> not sure it's HWN-worthy though
18:40:19 <byorgey> oh, wait, I found some @remembered quotes after all
18:40:35 <byorgey> I was confused since someone recently re-@remembered the quotes from last week's HWN
18:40:44 <JamesR> byorgey That solution was brilliant :) Worked like a charm first time
18:40:52 <byorgey> JamesR: great!
18:44:02 <andrep> how i can difference 01 of 1?
18:50:21 <Twey> andrep: How are they different?
18:51:00 <andrep> zero
18:51:10 <andrep> i need say 01 is diferente de 1
18:51:15 <Twey> But they are the same number.
18:51:16 <andrep> because 01 contain zero
18:51:22 <andrep> i know...
18:51:24 <Twey> Unless you mean in string form
18:51:31 <Twey> > "01" /= "1"
18:51:32 <lambdabot>   True
18:51:39 <dons> > 01 /= 1
18:51:41 <lambdabot>   False
18:51:52 <Twey> 01 is not different to 1.
18:51:56 <dons> and so it should be.
18:52:02 <Twey> "01" is different to "1".
18:52:10 <Twey> Indeed.
18:52:11 <dons> despite what PHP says
18:52:27 <andrep> humm
18:52:28 <Twey> I don't think that 01 is different to 1 even in PHP, is it?
18:52:28 <andrep> ok
18:52:37 <andrep> no
18:52:41 <andrep> in haskell
18:52:55 <dons> http://www.syntaxpolice.org/index.php/?q=node/419
18:53:08 <Twey> Yes, 01 === 1 in PHP
18:53:19 <dons> 01 == 1 ?
18:53:24 <dons> "01" == "1" ?
18:53:24 <Twey> Yeah
18:53:26 <Twey> Oh
18:53:46 <dons> "1" == 1
18:53:46 <Twey> Ah, aye.
18:53:51 <andrep> humm
18:53:52 <Twey> That's what you meant, huh.
18:54:00 <dons> :)
18:54:06 <dons> don't listen to PHP!
18:54:09 <dons> they're crazy people
18:54:58 <Twey> That they are :-P
18:55:55 <Twey> Wait, this post is arguing that PHP's craziness with types is a *good* thing
18:56:37 * Twey boggles.
18:59:53 <monochrom> You have to understand that some people think that unrestricted flexibility is a good thing. "I know what I'm doing", "keep the human in the loop", all that crap.
19:00:12 <Twey> And I agree with them, to an extent
19:00:22 <dons> Twey: no, it's not arguing that. (the guy's the author of Cabal)
19:00:25 <inforichland> Anytime you hear anyone say "I know what I"m doing," you should immediately 1) turn around, and 2) run like the dickens.
19:00:35 <inforichland> especially in regards to software ;)
19:00:50 <dons> monochrom: its weird though. its not unrestricted flexibility. its a set of ad hoc choices for the runtime behaviour chosen by the implementors
19:01:01 <c_wraith> inforichland: software second.  most especially for explosives
19:01:12 <inforichland> c_wraith: ah, touche`
19:01:12 <Twey> But the post is pointing out all the hideous weirdnesses and inconsistencies in what PHP does, even going so far as to mention a chart some programmer had to use to keep track of it, and then turns around at the end and says ‘hey, we should be able to do this in Haskell’
19:02:27 <Twey> I agree completely with the readMaybe proposal, but the author claims that's not good enough — i.e. that we should have implicit type-conversion
19:04:05 <copumpkin> implicit type conversion
19:04:07 <copumpkin> ?
19:04:57 <bremner> > 3.0 +1
19:04:58 <lambdabot>   4.0
19:06:27 <Cale> Twey: I think perhaps he means to the extent that it can be done, there should exist a library to do it?
19:07:16 <dons> copumpkin: overloaded literals are kinda fun, and an interesting point in the design space
19:07:23 <dons> few (?) languages have them. just haskell?
19:07:34 <copumpkin> ah, I see :)
19:07:45 <copumpkin> I haven't come across others
19:07:58 <monochrom> scheme too
19:09:04 <monochrom> Oh, is HWN out?
19:09:22 <copumpkin> I dunno, the lists are still down I think
19:09:22 <monochrom> No.
19:09:36 <Cale> Personally, I don't see what the big deal is about doing an explicit conversion/parsing here or there.
19:09:46 <monochrom> The web page still has May 2nd as the latest issue.
19:09:59 <Twey> Cale: But he has just shown adequately that it is inconsistent and unintuitive as all hell
19:10:10 <Cale> Yeah. It is.
19:11:12 <Twey> So I don't see why we can't have a integralToString :: Integral a => Base -> a -> String, and leave it at that
19:11:42 <monochrom> You have to understand that some "real" programmers go out of their way to saving typing. If they dare to shorten := to = what other ridiculously things will they not do?
19:12:13 <codolio> @type showIntAtBase
19:12:14 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
19:12:30 <Twey> monochrom: It is not an operation that is performed often enough to require optimisation
19:12:41 <Twey> codolio: *nods* Like that, but simpler
19:12:46 <Cale> I think if I was going to design an imperative language, I'd go with <- for assignment.
19:13:15 <Cale> Some sort of arrow-like device anyway.
19:13:29 <jml> set!
19:13:39 <Twey> I think I would take the Perligata way and use DARE :-P
19:13:51 <jml> (maybe with two exclamation marks for the really crazy stuff)
19:13:57 <Twey> Hahaha
19:14:14 <monochrom> performIO!!!
19:15:04 <Twey> We could do that if we had significant whitespace around operators... :-P
19:15:38 <Cale> (!!!) = id
19:15:39 <dons> people don't use IsString and Num enough, together...
19:15:48 <Twey> Cale: x.x
19:16:24 <Twey> dons: Probably because they have incompatible naming conventions :-P
19:17:02 <dons> i'd like my types to be both literals strings, or literal numbers, depending on my mood
19:17:12 <dons> obfuscation ftw
19:17:27 <monochrom> 1 ++ 2 + 3
19:17:50 <sjanssen> monochrom: 1 ++ "2" + 3 -- better
19:18:10 <monochrom> The point is to be worse, not better, of course.
19:18:15 <sjanssen> right
19:18:24 <Twey> What's that meant to be?  123?
19:18:27 * Twey shudders.
19:18:32 <Twey> Or "123"?
19:18:39 <sjanssen> no, "banana"
19:18:47 <monochrom> It is meant to be sarcasm.
19:18:54 <Twey> Heh
19:19:06 <monochrom> Or a hoax, if you will.
19:19:16 <c_wraith> I'd evaluate that to 15, myself
19:19:26 <monochrom> Someone should implement 1++2+3 in Haskell for the next April Fool.
19:19:28 <Twey> o.x
19:20:11 <monochrom> "Language.Mimic.PHP"
19:20:26 <Twey> Hahaha
19:20:56 <dolio> 1++2+3 has already been done, effectively, but either as [4,5] or [1,5] depending on precedence.
19:21:15 <Twey> And magic to make $ the only character considered lowercase for identifiers
19:22:58 <mauke> you all know how to define === in haskell, right?
19:23:13 <Twey> (===) = (==)
19:23:21 <Twey> :þ
19:23:43 <mauke> @let a === b = cast a == Just b
19:23:44 <lambdabot>  Defined.
19:23:50 <mauke> > "foo" === "foo"
19:23:51 <lambdabot>   True
19:23:53 <mauke> > "foo" === ()
19:23:54 <lambdabot>   False
19:24:49 <Twey> :t cast
19:24:50 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
19:25:00 <Twey> mauke: That's backwards to PHP, you know
19:25:07 <mauke> not really
19:25:08 <Twey> > "5" === 5
19:25:09 <lambdabot>   False
19:25:19 <Twey> Hum
19:25:36 <Twey> PHP's === is Haskell's == (i.e. it heeds types)
19:25:50 <mauke> Haskell's == does not exist in PHP
19:26:23 <Twey> Oh, you just mean it can compile daft checks?
19:26:28 <Twey> Fair enough
19:29:21 <kerlo> > id === id
19:29:22 <lambdabot>       No instance for (Eq (a -> a))
19:29:22 <lambdabot>        arising from a use of `===' at <in...
19:29:30 <kerlo> Grumble grumble.
19:29:44 <kerlo> > cast id === cast id
19:29:45 <lambdabot>   Add a type signature
19:29:46 <mauke> > id === 42
19:29:47 <lambdabot>   Add a type signature
19:29:51 <kerlo> Further grumble.
19:29:52 <mauke> > id === 'x'
19:29:53 <lambdabot>   Add a type signature
19:29:56 <mauke> aw
19:30:02 <kerlo> Mm.
19:30:23 <mauke> > (id :: Double -> Double) === 'x'
19:30:23 <kerlo> > cast ('5':) == cast('5':)
19:30:24 <lambdabot>   False
19:30:25 <lambdabot>   True
19:30:35 <PetRat> How often do you use "sub-parsers" within parsers? For instance, I have a situation where it helps me to think of using one parser to divide up a file by larger, simpler features, then create "sub-parsers" that take each chunk separately.
19:30:36 <kerlo> I'm guessing I'm getting Nothing here.
19:31:02 <kerlo> PetRat: use a different sub-parser for each section of the file?
19:31:04 <PetRat> Should I try to enlarge my thinking to do it all in a single pass? Or is this commonly a helpful way of organizing it?
19:31:16 <PetRat> kerlo: something like that
19:31:29 <kerlo> I think it's a perfectly canonical and idiomatic way of doing things, if the syntax is different for each section.
19:31:48 <kerlo> If there are any similarities, I guess you could run a pre-parser over the whole file before using your sub-parsers.
19:32:41 <PetRat> kerlo: there are common features to the larger chunks, -- they start and end with the same keywords.
19:32:53 <dmwit> ?hpaste
19:32:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:33:05 <PetRat> I guess I will proceed then.
19:33:38 <kerlo> PetRat: is that the only common feature?
19:35:42 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4808#a4808
19:40:14 <dmwit> Here's further evidence of this oddity.  Is this a GHC bug?
19:40:32 <dmwit> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4808#a4809
19:41:11 <sbahra> :t cast
19:41:12 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
19:41:13 <dmwit> It's easy to work around, just... very strange.
19:44:37 <mauke> yes, that is weird
19:46:41 <vixey> > cast ('5':) == cast('5':)
19:46:42 <lambdabot>   True
19:46:51 <vixey> > cast ('5':)
19:46:53 <lambdabot>   Nothing
19:47:36 <dmwit> > cast ()
19:47:37 <lambdabot>   Just ()
19:51:40 <kerlo> @type cast ()
19:51:41 <lambdabot> forall b. (Typeable b) => Maybe b
19:51:46 <kerlo> @type cast 5
19:51:47 <lambdabot> forall b. (Typeable b) => Maybe b
19:51:49 <dolio> dmwit: I wouldn't be prepared to say it isn't odd that the OpenLeft version works, rather than that the OpenRight version doesn't.
19:51:50 <kerlo> > cast ()
19:51:51 <lambdabot>   Just ()
19:51:53 <kerlo> > cast 5
19:51:54 <lambdabot>   Nothing
19:51:58 <kerlo> Whew.
19:52:12 <tiglionabbit> I was reading the "Why Functional Programming Matters" and saw the tic tac toe example, but it didn't explain the "moves" function -- I'm having an awkward time using 2D arrays in haskell.  How would you represent tic tac toe, and how would you generate a list of possible moves?
19:52:15 <dmwit> dolio: Me neither.
19:52:27 <dolio> It's definitely weird that they don't match, though.
19:52:30 <dmwit> dolio: When I glanced at the error, my impression was that all the cases would fail.
19:52:46 <dmwit> dolio: Then, when I looked harder, and saw that only one case failed... =P
19:53:03 <dolio> Yeah. I could see it maybe figuring out that when you apply the transformation to all the fields it works.
19:53:22 <monochrom> I would use a 2D array. 2D array is easy in Haskell. Just use an array with index type (Int,Int).
19:53:45 <dolio> But just one or the other I'd think it'd be less likely to figure out.
19:54:03 <dmwit> Well, I am filling in all the fields. ;-)
19:54:34 <dolio> Yeah, but it has to maintain its knowledge of what i is from the match to see that.
19:54:56 <dmwit> right
19:55:00 <mauke> it depends on the names (the failure, I mean)
19:55:19 <mauke> if you rename Closed.begin, it works
19:55:31 <dmwit> Yeah, I'm sure the punning here isn't helping things.
19:55:33 <tiglionabbit> monochrom: what do you mean by index type?
19:56:02 <monochrom> The type of the array indexes. Is there any other way to say it?
19:56:32 <monochrom> Gosh it's such a challenge to talk to this type-unaware, sick, bent world.
19:56:36 <mauke> dmwit: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4808#a4810
19:56:42 <mauke> I think it's a bug
19:57:02 <dmwit> I agree.
19:57:19 <dmwit> Either foo should be more general, or bar should be less general; I'm not sure which. =)
19:57:26 <mauke> foo should be more general
19:58:00 <tiglionabbit> monochrom: oh, arrays are different from lists.  I didn't realize
19:58:14 <monochrom> Well, I guess the solution is to talk about sample values rather than types. 2D array in Haskell is just an array with indexes like (0,0), (0,1), (1,0).
19:58:42 <tiglionabbit> okay
19:59:06 <tiglionabbit> I shall read about arrays.  But I'm still trying to think how one would enumerate possible tic tac toe moves..
19:59:06 <dmwit> Okay, I'll file a bug with the GHC folks.
19:59:08 <dmwit> Thanks, guys.
20:03:03 <tiglionabbit> an array is just a map with a specific implementation, right?
20:03:59 <monochrom> Generate the whole list of all moves (or all next states if you want instead). To do this, first generate the list of all indexes (there are only 9). Then filter out those indexes corresponding to non-empty positions in the array (look up in the array). Then you get valid places to place your next X or O.
20:04:02 <monochrom> Yes.
20:04:05 <dmwit> tiglionabbit: yes
20:05:31 <monochrom> filter (\i -> board ! i == ' ') [ (x,y) | x<-[0,1,2], y<-[0,1,2] ]   I guess.
20:06:09 <monochrom> I guess I should write board ! i as board!i
20:06:24 <chessguy> why?
20:06:37 <monochrom> use spacing to suggest to human how to parse
20:07:01 <chessguy> seems pretty obvious to me
20:07:08 <chessguy> and more readable with whitespace
20:14:16 <Twey> I agree with chessguy
20:14:32 <Twey> If you like, you could write it (\i -> board ! i  ==  ' ')
20:14:50 <Twey> Or (\i -> (board ! i) == ' ')
20:15:11 <Twey> Or ((' ' ==) . (board !))
20:15:13 <dmwit> (' ' ==) . (board !) -- maximal clarity
20:15:17 <Twey> Heh, aye
20:15:46 <dolio> That assumes commutativity of (==)!
20:16:05 <dmwit> Yes, but when it's true, it's slightly easier to optimize!
20:16:22 <chessguy> when would (==) not be commutative?
20:16:37 <dolio> When I want it to be!
20:16:58 <dmwit> In an obfuscated code contest!
20:17:06 <dmwit> Which is exactly where this kind of change would be made!
20:17:14 <blackdog> so some things are more equal than others?
20:17:19 <Twey> Hahaha
20:17:27 <Twey> Nonsense, dmwit
20:17:40 <Twey> I would use ((' ' ==) . (board !)) happily
20:17:45 <Twey> It's shorter and, yes, clearer
20:17:59 <dmwit> > length "((' ' ==) . (board !))"
20:18:00 <lambdabot>   22
20:18:09 <dmwit> > length "\\i -> board ! i == ' '"
20:18:10 <lambdabot>   22
20:18:18 <dmwit> WRONG
20:18:34 <adamvo> the lambda needs more parentheses
20:18:34 <dmwit> But I would use it, too. =)
20:18:37 <dons> sjanssen: pity ("42" ++ "7") + 7 doesn't work for tedious reasons. ah well, i can be happy with: main = print $ "7" == 7
20:18:54 <Twey> dmwit: You missed the brackets
20:19:00 * Twey nods.
20:19:11 <dmwit> yeah
20:19:44 <dmwit> There's quite a few places where there is a readable, point-free version that is nonetheless longer than the explicitly pointed version.
20:19:53 <dmwit> But this isn't one of them. =)
20:20:14 <Twey> Yes
20:20:25 <monochrom> Why are you optimizing my very basic code.
20:20:36 <dmwit> Slow night?
20:20:47 <Twey> On the other hand, the point-free version just requires reading backwards (or not even that if you use >>>) whereas the pointed version creates a bunch of new symbols and scatters them around the code for you to pick out :-P
20:22:13 <mauke> hmm
20:22:23 <mauke> ("42" ++ "7") + 7 == ";9>" apparently
20:22:34 <monochrom> call it a feature. :)
20:22:55 <dmwit> What the deuce are you guys talking about?
20:23:34 <vixey> mauke illogical captain
20:23:46 <mauke> *> "42" + ("7" + 7)
20:23:46 <mauke> "rp"
20:24:37 <mauke> hmm, makes sense
20:26:45 <copumpkin> lol
20:26:51 <copumpkin> the matlab way
20:27:11 <monochrom> Mimicking PHP so you mix numbers and strings together.
20:27:48 <monochrom> Like "7"+7 should "make sense" and "7"++7 should also "make sense" and you randomly decide what it means.
20:28:38 <mauke> "7"+7 is ">"
20:28:52 <monochrom> Yes that's one good way.
20:29:32 <dmwit> And ">"+7 is a backwards "L".
20:29:33 <dmwit> ;-)
20:29:35 <monochrom> The important part is don't be logical or general. Just ask yourself what's your first instinct. Like in those psychological tests, don't think, just feel.
20:29:41 <mauke> no, "E"
20:29:50 <monochrom> (The very definition of "intuition"!)
20:30:03 <mauke> *> "xyz" - "abc"
20:30:03 <mauke> "\ETB\SYN\NAK\CAN\ETB\SYN\EM\CAN\ETB"
20:36:22 <dons> mauke: oh, you did an instance Num String?
20:36:38 <dons> while instance String Integer is more sensible, but less fun :)
20:36:57 <dons> the  String class needs more fun ops
20:37:01 <mauke> well, (Num a, Applicative f) => Num (f a)
20:37:04 <mauke> and Num Char
20:37:21 <Twey> There's a String class?
20:37:23 <Twey> Since when?
20:37:24 <dons> oh boy
20:37:45 <dons> Num (f a) is kinda wild.
20:37:50 <Twey> Haha
20:38:11 <dons> i hesitate to recommend hackage
20:38:28 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs
20:38:29 <Twey> f a + f b = f (a + b)?
20:39:00 <dons> very nice
20:39:50 <mauke> and this is basically why Eq and Show should not be superclasses of Num
20:39:57 <Twey> Heh
20:40:02 <dmwit> > foldr (.) id (replicate 7 succ) '>'
20:40:04 <lambdabot>   'E'
20:40:11 <dmwit> Oh, you have got to be kidding me. =P
20:40:20 * Twey laughs.
20:40:21 <dmwit> > foldr (.) id (replicate 7 succ) '7' -- '>'
20:40:22 <lambdabot>   '>'
20:40:29 <dmwit> yuck =)
20:40:51 <Twey> Hey — that's awesome :-P
20:41:03 <Twey> Folding over functions gets immediate cool-points.
20:41:07 <vixey> @let 0 `times` f = id ; n `times` f = f . (n-1) `times` f
20:41:08 <lambdabot>  <local>:11:33:
20:41:08 <lambdabot>      precedence parsing error
20:41:08 <lambdabot>          cannot mix `(.)' [infi...
20:41:21 <vixey> lambdabot-- should support n+k patterns
20:41:45 <copumpkin> it doesn't?
20:42:06 <copumpkin> > let f (x+1) = x in f 5
20:42:07 <lambdabot>   4
20:42:26 <vixey> hm
20:43:23 <dmwit> ?let 0 `times` f = id; n `times` f = f . ((n-1) `times` f)
20:43:24 <lambdabot>  Defined.
20:43:47 <dmwit> Okay, now go, vixey. =)
20:49:02 <Twey> Hmm
20:49:08 <dmwit> indeed
20:49:23 <dons> mauke: i'm starting to think you should put this on hackage.
20:49:26 <dons> as a warning to others
20:49:47 <Twey> What's the function for getting the digits of an integer?  Something like digits = takeWhile (not . null) . map (`mod` base) . iterate (`div` base) ?
20:50:04 <dmwit> > show 1234576
20:50:06 <lambdabot>   "1234576"
20:50:10 <Twey> I can't remember how to deal with the infinite zeroes
20:50:15 <dmwit> > map digitToInt . show $ 1234567
20:50:16 <lambdabot>   [1,2,3,4,5,6,7]
20:50:25 <Twey> Yeah, I know there's that
20:50:29 <mauke> :t unfoldr
20:50:30 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:50:33 <Twey> But there's a mathematical way using iterate
20:50:54 <ksf> @src showIntAtBase
20:50:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:51:06 <copumpkin> unfold using divmod sounds good?
20:51:17 <dmwit> yep
20:51:40 <tgdavies> What's a collective term for >> and >>= ?
20:51:52 <copumpkin> bondage
20:51:54 <copumpkin> *bindage
20:52:05 <Twey> Heh
20:52:06 <mauke> > unfoldr (\n -> if n == 0 then Nothing else let (d,m) = n `divMod` 10 in Just (m, d)) 12345
20:52:07 <lambdabot>   [5,4,3,2,1]
20:52:14 <dmwit> :t let ensure p x = guard (p x) >> return x in unfoldr (ensure ((>0) . snd) . (`divMod` 10))
20:52:15 <lambdabot> forall b. (Integral b) => b -> [b]
20:52:22 <mauke> but that fails for 0
20:52:24 <Twey> > unfoldr (\n -> if n == 0 then Nothing else let (d,m) = n `divMod` 10 in Just (m, d)) 120345
20:52:26 <lambdabot>   [5,4,3,0,2,1]
20:52:33 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4812#a4812 , just with another base.
20:52:36 <Twey> Hmn
20:52:39 <Twey> There's an easier way
20:52:47 <Twey> Someone showed me it before — monochrom I think?
20:52:56 <Twey> It involves an iterate, a div, and a mod
20:53:01 <copumpkin> hrm
20:53:24 <monochrom> I don't know. I'm now a big fan of never reinvent the code. Just call existing library functions.
20:53:32 <dmwit> > map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) $ 123456
20:53:33 <lambdabot>   [6,5,4,3,2,1]
20:53:48 <ksf> doesn't use divmod.
20:54:08 <monochrom> > map (`mod` 10) . takeWhile (>0) . iterate (`div` 10) $ 0
20:54:10 <lambdabot>   []
20:54:25 <Twey> monochrom: That's lovely, except that they're not applicable in my case :-P
20:54:32 <Twey> Oh, that could be it!
20:54:50 <dmwit> Can you be a bit more specific about just what your case is?
20:55:41 <Twey> reverse . map (`mod` base) . takeWhile (/= 0) . iterate (`div` base)
20:55:42 <Twey> I think
20:55:56 <mauke> map digitToInt . show
20:56:08 <dmwit> Yeah, I'm with mauke here.
20:56:26 <Twey> dmwit: showIntAtBase, but the appropriate function is (Int -> String) rather than (Int -> Char)
20:56:28 <monochrom> To continue beating the dead horse, or dead Zune: The recent Zune hanging is due to reinvenint the calendar. If they used existing libraries it would not break.
20:56:35 <Twey> I guess a concat/digitToInt/show would work, too
20:56:43 <Twey> Replacing digitToInt, of course
20:56:46 <Twey> But I was curious
20:57:01 <Twey> ‘Recent’ Zune hanging?
20:57:06 <Twey> Wasn't that months ago?
20:57:12 <Twey> Or was there another one?
20:59:12 <Twey> @index digitToInt
20:59:12 <lambdabot> Data.Char
21:00:34 <monochrom> Just the past New Year Eve.
21:00:57 <Twey> So about five months ago :-P
21:01:54 <monochrom> Byron Cook is lecturing at Berkeley on automated termination/non-termination detection just last month and he used the Zune example too.
21:02:43 <monochrom> Anyway even something happened a hundred years ago is also recent.
21:03:45 <vixey> automatic termination checking is quite interesting
21:05:19 <dmwit> newtype Time = Time { unTime :: Rational } deriving (Everything, Please)
21:17:45 --- mode: irc.freenode.net set +o ChanServ
21:18:49 <vixey> irritated
21:31:02 <dmwit> :t msum
21:31:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
21:31:11 <dmwit> hmph
21:31:16 <dmwit> :t mappend
21:31:18 <lambdabot> forall a. (Monoid a) => a -> a -> a
21:31:51 <dmwit> > mconcat [Just 3, Just 4]
21:31:52 <lambdabot>   Add a type signature
21:31:59 <dmwit> > mconcat [Just 3, Just 4] :: Maybe [Int]
21:32:00 <lambdabot>       No instance for (Num [Int])
21:32:00 <lambdabot>        arising from the literal `3' at <int...
21:32:12 <dmwit> > mconcat [Just [3], Just [4]]
21:32:13 <lambdabot>   Just [3,4]
21:34:02 <dmwit> :t \b e -> fmap minimum . mconcat . map (fmap return) $ [b, e]
21:34:08 <lambdabot> forall a (f :: * -> *). (Monoid (f [a]), Functor f, Ord a) => f a -> f a -> f a
21:34:23 <dmwit> yuck
21:34:47 <dmwit> Can anyone do better?  The polymorphism isn't important, just the behavior for when f is instantiated as Maybe there.
21:35:31 <vixey> :t mconcat . map (fmap return)
21:35:32 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m, Monoid (f (m a))) => [f a] -> f (m a)
21:35:57 <vixey> :t return . fmap minimum
21:35:58 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Ord a, Monad m) => f [a] -> m (f a)
21:36:18 <Saizan_> ?type liftM2 min
21:36:19 <lambdabot> forall a1 (m :: * -> *). (Monad m, Ord a1) => m a1 -> m a1 -> m a1
21:36:20 <dmwit> mconcat . map (fmap return) -- takes a list of Maybes to a Maybe of the list of Justs
21:36:41 <dmwit> Saizan_: Not quite; that will return Nothing if either argument is nothing.
21:37:23 <mauke> wait, what are you trying to do?
21:37:50 <Saizan_> return the minimum or either of them, i guess
21:37:55 <dmwit> yep
21:38:13 <vixey> write it using pattern matching
21:39:08 <dmwit> I much prefer my unreadable but clever method. ;-)
21:39:30 <vixey> it's not really clever
21:39:53 <dmwit> Perhaps not.  But it's less repetitive than writing out all four cases.
21:40:05 <vixey> k whatever
21:40:23 <dolio> @type \a b -> min <$> a <*> b
21:40:24 <lambdabot> forall a (f :: * -> *). (Applicative f, Ord a) => f a -> f a -> f a
21:40:30 <Saizan_> well, there's catMaybe at least
21:40:38 <Saizan_> ?type catMaybes
21:40:39 <lambdabot> forall a. [Maybe a] -> [a]
21:40:44 <dmwit> > min <$> Nothing <*> Just 3
21:40:46 <lambdabot>   Nothing
21:41:03 <dmwit> > fmap minimum . mconcat . map (fmap return) $ [Nothing, Just 3]
21:41:05 <lambdabot>   Just 3
21:41:20 <dmwit> Saizan_: Sure, and then what?
21:42:13 <Saizan_> > fmap return . listToMaybe . catMaybes $ [Nothing, Just 3]
21:42:14 <lambdabot>       No instance for (Show (m a))
21:42:14 <lambdabot>        arising from a use of `show' at <in...
21:42:23 <Saizan_> > fmap minimum . listToMaybe . catMaybes $ [Nothing, Just 3]
21:42:24 <lambdabot>       No instance for (Num [a])
21:42:24 <lambdabot>        arising from the literal `3' at <inter...
21:42:40 <dmwit> That listToMaybe is going to throw away a value if they're both Just.
21:43:00 <Saizan_> right
21:43:17 <Saizan_> bah, minimum should be made total
21:43:31 <dmwit> =)
21:43:33 <vixey> why & how?
21:43:42 <dmwit> minimum :: [a] -> Maybe a
21:44:04 <dmwit> And because it would be helpful in my current case.
21:44:08 <mauke> minima :: [a] -> [a]
21:44:09 <ray> i agree
21:44:19 <ray> minima = id>
21:44:21 <ray> minima = id?
21:44:24 <vixey> I don't agree
21:45:26 <dmwit> You can get back your partial function via "fromJust . minimum'", but there's no way to recover a total function from a partial one.
21:45:55 <mauke> in this case it's easy, though
21:46:08 <dmwit> yep
21:46:10 <ray> i think all the standard functions should be total
21:46:17 <dmwit> I'm with ray.
21:46:17 <vixey> ray, that's silly
21:46:26 <vixey> this is haskell not some research tool
21:46:35 <Saizan_> some of them don't make sense as total
21:46:55 <mauke> fix :: (a -> a) -> Maybe a
21:47:08 <dmwit> Yeah, fix is harder.  I'll grant you that one. =P
21:47:27 <ray> most of the standard functions, then
21:47:27 <bd_> fix is a total function. It just happens to have bottom in its range :)
21:47:55 <dmwit> Bah, if you allow bottom to be in the range of total functions, the word "total" loses its meaning.
21:48:07 <dolio> If fix is total, then all the functions people are complaining about are also total.
21:48:08 * dmwit feels grumpy, obviously
21:48:08 <ray> it becomes just a cereal
21:48:48 <mmorrow> count chockula?
21:49:01 * mmorrow thinks he speled that wrong
21:49:25 <mmorrow> chocula!
21:50:39 <dmwit> mmorrow: I think you missed the joke on that one. =P
21:51:11 <dmwit> ?go total cereal
21:51:26 <lambdabot> Plugin `search' failed with: thread killed
21:51:40 <ray> so much for total
21:52:00 <mmorrow> thread serial killed!
21:52:14 <dmwit> Oh!  Is there a Min monoid for Bounded types?
21:52:21 <dmwit> Because that would totally take care of this.
21:52:44 <BMeph> mmorrow: Yeah, you spelt it wrong. ;)
21:52:49 <dmwit> Bounded, Ord types, I guess.
21:52:50 <mmorrow> heh
21:53:17 <dolio> I think edwardk put one in his monoid package, at least.
21:54:02 * BMeph wonders what the co-version of Reducer should be named...
21:54:12 <dmwit> Oxidizer?
21:54:15 <Saizan_> Generator?
21:55:31 <mauke> Producer
21:56:12 <mmorrow> , (text . reverse) "?reduceR"
21:56:16 <lunabot>  Recuder?
21:56:24 <dmwit> nooot quite
21:56:45 <dmwit> oh
21:56:46 <dmwit> I get it.
21:56:52 <dmwit> It was my turn to miss the joke. =P
21:56:53 <pjolk> http://research.microsoft.com/en-us/um/people/lamport/pubs/future-of-computing.pdf
21:57:03 <ray> hey, reduce is an anagram for itself backwards!
21:57:21 <pjolk> ^^ so program verification and the halting problem doesnt really clash that much?
21:57:24 <ray> i'm joking, but for a second there i was thinking that
21:57:32 <pjolk> verification is mostly impractical,not impossible
21:57:37 <mauke> you should slap your brain for that
21:57:43 <Twey> forall word. Hey, word is an anagram for itself backwards!
21:57:53 <ray> i did
22:03:05 <malouin> what is @?
22:03:13 <Twey> ‘as’
22:03:25 <dmwit> It allows two patterns to match the same argument.
22:03:35 <malouin> interesting
22:03:44 <tsLight> if I have a function that returns a type (IO (), String), how can I show the first component in the screen?
22:03:48 <dmwit> Actually, that makes me wonder whether it allows an arbitrary number of patterns.
22:03:51 * dmwit tests
22:04:05 <malouin> where do its docs live?
22:04:08 <Twey> > let f l@(x:xs) = l ++ x : xs in f [1, 2, 3]
22:04:09 <lambdabot>   [1,2,3,1,2,3]
22:04:16 <dmwit> malouin: It's syntax, not a function.
22:04:19 <Twey> > let f l@(x:xs) = x : l ++ xs in f [1, 2, 3]
22:04:20 <lambdabot>   [1,1,2,3,2,3]
22:04:22 <dmwit> malouin: So, the Report are the docs.
22:04:27 <malouin> ok.
22:04:49 <Twey> > let f (_:y:_)@(x:xs) = x : y2 ++ xs in f [1, 2, 3]
22:04:50 <lambdabot>   <no location info>: parse error on input `@'
22:04:53 <Twey> Aw.
22:05:00 <Twey> I wondered if that would work.
22:05:04 <dmwit> > let f x@(y:ys)@(_:z:zs) = (x, y, ys, z, zs) in f [3..5]
22:05:06 <lambdabot>   <no location info>: parse error on input `@'
22:05:26 <dmwit> > let f x@y@z = (x, y, z) in f 5
22:05:27 <lambdabot>   (5,5,5)
22:05:33 <Twey> > let x@y@z = x ++ y ++ z in ... oh
22:05:34 <lambdabot>   <no location info>: parse error on input `...'
22:05:43 <dmwit> odd
22:06:02 <dmwit> > let f (x@(y:ys)@(_:z:zs)) = (x, y, ys, z, zs) in f [3..5]
22:06:03 <lambdabot>   <no location info>: parse error on input `@'
22:06:05 <mauke> variable@pattern
22:06:10 <dmwit> ah
22:06:15 <Twey> But!
22:06:27 <Twey> a@b@c is pattern@pattern for either of the @s
22:06:35 <mauke> pattern = variable@pattern
22:06:37 <Twey> They must have implemented a special case for that
22:06:43 <dmwit> > let f x@(y:ys@(z:zs)) = (x, y, ys, z, zs) in f [3..5]
22:06:44 <lambdabot>   ([3,4,5],3,[4,5],4,[5])
22:06:45 <Twey> Oh, right
22:07:09 <dmwit> Yep, that's a totally reasonable restriction.  Neat!
22:08:17 <pjolk> mauke:?
22:08:24 <mauke> pjolk: yes?
22:08:25 <pjolk> @slap pjolk
22:08:25 * lambdabot smacks pjolk about with a large trout
22:08:35 <pjolk> @slap mauke
22:08:35 * lambdabot throws some pointy lambdas at mauke
22:08:54 <pjolk> i should slap my brain for that? or you were talking to someone else?
22:09:11 <dmwit> He was talking to ray.
22:09:43 <pjolk> @slap dmwit
22:09:43 * lambdabot jabs dmwit with a C pointer
22:09:49 <pjolk> @slap lambdabot
22:09:49 * lambdabot locks up lambdabot in a Monad
22:09:51 <malouin> dmwit,Twey ok, with those exampls, now it makes sense.  Thanks!
22:12:21 <BMeph> That paper reminds me of "Uncle" BobMartin's RailsConf talk about "What killed Smalltalk, and could it kill Ruby, too?" or something like that.
22:12:39 <vixey> Although this mainly represents a potential improvement in GHC’s internals, where I’d really like to go with this is to push the ability to make a distinction between strict and lazy data into the type system of Haskell itself. This would mean that you could, for example, write functions that produce element-strict lists, and document some of the strictness properties of your functions in their types.
22:12:51 <vixey> old hat :p
22:13:52 <blackdog> vixey: didn't max bolingbroke and simonpj just write a paper on that?
22:14:01 <vixey> that what I just quoted
22:14:09 <blackdog> oh
22:14:12 <blackdog> oops *blush*
22:14:19 <vixey> I'm just being smug because I thought of this a while back
22:15:03 <blackdog> could you do it in such a way that you could write code that accepted both strict and lazy lists, though?
22:15:08 <Twey> vixey: Who said that?
22:15:27 <vixey> http://blog.omega-prime.co.uk/?p=56
22:15:52 <BMeph> vixey: If you were smug-worthy, Max and Simon would be quoting *your* paper, not the other way around. ;p
22:16:51 <BMeph> @wiki DDC
22:16:51 <lambdabot> http://www.haskell.org/haskellwiki/DDC
22:16:59 <BMeph> blackdog: ^^
22:18:55 <blackdog> BMeph: oh, duh. i talked to Ben about that at FP-Sydney
22:19:04 <blackdog> no brain good today
22:23:01 <pjolk> > (+11) <$> (Just 5)
22:23:02 <lambdabot>   Just 16
22:23:36 <pjolk> @type (<$>)
22:23:36 <pjolk> @type (<*>)
22:23:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:23:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:24:07 <pjolk> > (+1) <*> (Just 5)
22:24:08 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
22:24:33 <pjolk> > (<*>) (+) (Just 3) (Just 5)
22:24:34 <lambdabot>   Couldn't match expected type `a -> a'
22:24:37 <pjolk> ?
22:27:19 <dancor_> Data.Binary uses lazy bytestrings, and Data.Digest.OpenSSL.MD5 uses strict ones.  what should i do?
22:27:48 <dancor_> i'm hashing a large number of chess positions to make a chess opening explorer
22:28:15 <dancor_> (hashing the binary encode of them)
22:28:48 <harovali> dancor_: how about making a tree of the possible positions ?
22:29:02 <dancor_> harovali: i want to consider transpositions equal
22:29:35 <harovali> dancor_: do you need that ?
22:29:50 <dancor_> harovali: i want it yes :)
22:30:03 <wli> For feasibility purposes one does.
22:30:08 <harovali> dancor_: then go ahead
22:30:53 <dancor_> i think most opening explorers don't do it but i want to know the actually most common moves in openings with lots of transpositions
22:31:07 <wli> Encoding as a sort of "hash function" which honors the symmetries might help.
22:31:20 <harovali> dancor_: i think that can be accomplished anyhow, by reordering the position set to a canonical order , in the hash function say
22:31:20 <pjolk> i dont get the type of <$> and *** etc
22:31:29 <pjolk> they are hard to understand from reading
22:31:35 <mauke> <$> is just fmap
22:31:35 <dancor_> harovali: i suppose that is true
22:31:47 <wli> One thing to start from is positions as vertices and moves as edges.
22:32:26 <dancor_> are you guys saying that haskell is not well suited to a simple hash approach?
22:32:27 <wli> So you can essentially share the position nodes when sequences of moves yield equal positions.
22:32:51 <harovali> wli: that's exactly my idea
22:33:14 <pjolk_> <*>
22:33:40 <pjolk_> @src (<*>)
22:33:40 <lambdabot> Source not found. Sorry.
22:33:45 <pjolk_> @type (<*>)
22:33:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:34:33 <dancor_> the hash approach seems more general to me (doesn't rely on the fact that all or almost all games happen to be independent of move order in chess).  i believe go is a counter example because of ko fights
22:35:15 <dancor_> but i suppose it will be a lot slower
22:36:06 <wli> data Position = Position { posDesc :: PosDesc, inMoves, outMoves :: IntSet } ; data Move = Move { srcPos, dstPos :: Int, desc :: MoveDesc } ; data GameGraph = GameGraph { moves :: IntMap Move, positions :: IntMap Position }
22:37:53 <wli> That's one possibility for what a move graph would look like.
22:38:06 <dancor_> even in chess the same position can be gotten to with completely different moves (knight using a different intermediate square)
22:38:45 <dancor_> if i was willing to make a bunch of probably-negliglible correctness trade-offs for efficiency, i wouldn't have used haskell to begin with :)
22:38:50 <wli> dancor: See the graph I mentioned.
22:39:18 <dancor_> wli: i haven't figured out how the graph helps with my problem yet :/
22:39:59 <wli> dancor: In the graph the positions can be reached by different edges/moves etc.
22:40:08 <dancor_> or changes it.  i'm still going to be hashing to determine if a move from one position goes to a new node or a pre-existing one
22:40:18 <dmwit> pjolk: The Arrow functions are easier to understand if you write the Arrow instance infix.
22:40:22 <dmwit> pjolk: Check it:
22:40:24 <dmwit> :t (***)
22:40:25 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:40:26 <dancor_> or using a sort-the-moves-and-hope-its-good-enough hack
22:40:49 <dmwit> (***) :: Arrow (~>) => (b ~> c) -> (b' ~> c') -> ((b, b') ~> (c, c'))
22:40:58 <wli> dancor: If you're worried about overflowing Int then use IntMap as a hashtable and Map as collision chains.
22:41:14 <dmwit> pjolk: When you factor in the idea that Arrow instances are somehow a "generalization" of functions, that type should be quite readable.
22:41:34 <dmwit> pjolk: Similarly...
22:41:35 <dmwit> :t (&&&)
22:41:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:41:51 <dmwit> (&&&) :: Arrow (~>) => (b ~> c) -> (b ~> c') -> (b ~> (c, c'))
22:44:03 <wli> dancor: Transpositions in the graph representation just end up being different paths to the same vertex.
22:44:26 <dancor_> wli: so you think that format will be faster than just hashing positions to the moves that occurred at those positions
22:44:44 <dancor_> even tho i think i will have to still do the hashes to create that format
22:44:59 <wli> dancor: I don't know what your description means. Hashing positions to *what*??
22:45:15 <dancor_> md5 of the Binary representation of the position
22:45:36 <dancor_> maybe the binary is small enough to just use that directly..
22:46:10 <wli> dancor: Positions consist of piece positions, who's to move, who has already castled, who has already moved rooks, and how many repetitions there have been.
22:46:14 <harovali> dancor_: why not just explore what it leads you to ?
22:46:19 <dancor_> wli: correct
22:46:30 * dancor_ sets off to explore
22:46:34 <wli> Ergh, which rooks and kings have already moved.
22:46:51 <wli> And something else for en passant.
22:47:06 <harovali> chess has state !
22:47:08 <wli> I guess the last pawn move.
22:47:26 <wli> You need the last pawn move for 50 move rules anyway.
22:47:43 <wli> En passant wants it, too.
22:47:58 <dancor_> well it's hard to overlap those bits of state i think
22:48:16 <dancor_> since en passant only cares about a _double_ pawn advance on the _last_ move
22:48:51 <dancor_> i think ppl usually store Maybe (square a pawn just double-jumped thru)
22:49:27 <dancor_> and then just a count (since last pawn advance or capture)
22:49:34 <wli> You can split it out to how many moves ago the last pawn move was and that en passant state.
22:49:46 <dancor_> the capture thing complicates
22:50:20 <wli> Yeah, it has to be the last pawn move or capture, sorry.
22:51:33 <wli> Anyway, once you've gotten that far, all you need to do is record moves as arcs between positions.
22:51:39 <dancor_> i guess you can always overlap the representations of overlapping data, it just gets masochistic at a point
22:53:21 <tsLight> is there a function to split a list in some element, such as returning a triple (before, elem, after) that receives some function a->Bool that elem has to make true?
22:53:35 <wli> When it's a graph like that, transpositions are trivial. You just end up at the same vertex as a result of following a different sequence of vertices and edges.
22:54:09 <wli> The real evil is when there are symmetries to exploit.
22:54:29 <Gracenotes> :o
22:55:05 <wli> BTW the graph is necessarily acyclic.
22:55:21 <wli> dancor: Do you see how this graph affair deals with transpositions?
22:56:49 <mmorrow> , span (<4) [0..]
22:56:50 <lunabot>  ([0,1,2,3],[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,2...
22:57:01 <mmorrow> @src break
22:57:02 <lambdabot> break p =  span (not . p)
22:57:07 <mmorrow> tsLight:
22:57:10 <wli> dancor: Are you there?
22:57:28 <tsLight> ah, thanks :P
22:57:37 <wli> 49.78M/50M on Project Euler #216
22:58:09 <tsLight> , span (=='a') "hitoall"
22:58:10 <lunabot>  ("","hitoall")
22:58:11 <wli> It's been running for 10 days.
22:58:20 <tsLight> that one doesnt work like i want :P
22:58:39 <vixey> , span (/='a') "hitoall"
22:58:40 <lunabot>  ("hito","all")
22:58:48 <tsLight> ah
22:58:49 <tsLight> dumb me
22:58:50 <tsLight> lol
22:59:09 <wli> 49.79M now even.
22:59:41 <mmorrow> wli: :o
22:59:52 * mmorrow googles for what Project Euler #216 is
22:59:52 <wli> It'll probably finish by the time I wake up in the morning.
23:00:22 <dancor_> wli: no i don't see how it prevents me from having to do a similar thing (hash or just Binary.encode) anyway to determine where to draw the edges
23:00:29 <dancor_> but i'm still thinking about it :)
23:01:09 <wli> dancor: It doesn't prevent you from needing to search for preexisting positions.
23:02:44 <wli> dancor: It addresses transpositions.
23:03:12 <vegai> http://tutorial.happstack.com/src/StateTExample.hs
23:03:30 <vegai> nice code comments there :P
23:06:25 <dancor_> lol
23:06:26 <weilawei> okay.. so.. too many different ways to say too many different things. xD i want to make something like an enum, but really more like a mapping.. say SomeConstructor always gives you the value "blah." Do I want an ADT, a typeclass and instance functions or.. ?
23:07:13 <dancor_> happs is *almost* crazy enough that purely-code-restating comments help..
23:08:16 <dancor_> it took me a while to realize the comments didn't say anything anyway ;)
23:08:38 <dmwit> weilawei: How about a value?
23:08:44 <dmwit> someConstructor = "blah."
23:08:45 <Saizan_> weilawei: an ADT and a function?
23:11:34 * dancor_ wouldn't have thought of trying a StringLiteralable class
23:11:48 <badtruffle> IsString ?
23:11:48 <weilawei> Saizan_: probably
23:13:27 <dancor_> i think you would only use classes when you are going to have a bunch of data types that are all going to produce strings in some same niche way.  (disclaimer: no idea what i'm talking about)
23:14:11 <copumpkin> hmm, /me missed the context
23:17:33 <wli> mmorrow: I bombed the addition chain multiplication problem, too. My code took 10 hours for that one. :(
23:17:50 <mmorrow> heh
23:18:29 * mmorrow sidetracked to looking for riemann zeta function code
23:18:47 <mmorrow> this page is interesting (nice graphs) http://web.mit.edu/kenta/www/six/parallel/2-Final-Report.html
23:19:05 <mmorrow> in particular, this one http://web.mit.edu/kenta/www/six/parallel/other-files/four2.gif
23:19:26 <copumpkin> just find the function implemented in a dependently typed language, and then you can prove the riemann hypothesis! ;)
23:21:23 <mmorrow> copumpkin: unfortunately i won't be able to to type the closing bracket, as it won't allow me to type the opening on in the first place since checking if there's a closing one might make the universe loop so that's out
23:21:37 <copumpkin> oh no
23:21:48 <mmorrow> wow, that was very "ranty" :)
23:23:07 <Twey> Well you wouldn't want the universe to loop, now would you?
23:23:09 <Twey> That would be bad.
23:23:21 <dancor_> this all seems familiar
23:23:30 <copumpkin> this all seems familiar
23:23:30 <vixey> dancor yeah I noticed that a while ago
23:23:51 <dancor_> codancor
23:25:28 <copumpkin>  danr?
23:25:59 <dancor_> <<lol>>
23:26:07 <mmorrow> <<loop>>
23:26:46 * dancor_ wonders when like SDL will be ported to agda
23:26:56 <dancor_> err i mean when there will be bindings
23:27:14 <copumpkin> I really want a fast cool language like agda to have a fast codegen
23:27:16 <mmorrow> @let help = text "<<loop>*** ExcepSegmentaion fault"
23:27:17 <lambdabot>  Defined.
23:27:20 <mmorrow> > help
23:27:22 <lambdabot>   <<loop>*** ExcepSegmentaion fault
23:27:22 <copumpkin> lol
23:27:28 <mmorrow> hehe
23:27:32 * mmorrow is laughing
23:27:46 <copumpkin> me too
23:27:48 <mmorrow> that would be probably the best error ever
23:27:57 <dancor_> but someone proved that XCB is correct, so maybe SDL will be written in agda some day
23:29:20 <copumpkin> mmorrow: at the risk of ruining the joke, you could maybe slap a Kernel Panic onto the end of that segmentation fau
23:29:28 <copumpkin> but that may be taking it a bit far
23:29:39 <copumpkin> especially given that most OSes wouldn't send that to your terminal :(
23:29:41 * copumpkin fails
23:29:42 * wli already has enough bugs to deal with.
23:29:48 * Twey laughs.
23:30:02 <Twey> Wait, ‘Segmentaion fault’?
23:30:15 <wli> And believe me, just about anything will send people running to claim it's the kernel's fault and not theirs.
23:30:20 <mmorrow> copumpkin: and a few byte of random garbage at the end for flair
23:30:24 <copumpkin> :P
23:30:26 <wli> Including nothing at all.
23:30:31 <copumpkin> wli: it's always the kernel's fault!
23:30:54 <tsLight> is there a way to know if a type is Nothing or Just, with an 'if' check?
23:31:07 <tsLight> I mean a value, not a type
23:31:09 <copumpkin> tsLight: yup, but there are even better ways without an if
23:31:10 <Adamant> blame KernelDevs
23:31:22 <copumpkin> :t isNothing
23:31:23 <lambdabot> forall a. Maybe a -> Bool
23:31:24 <mmorrow> Twey: computers can mispel stuff two
23:31:25 <copumpkin> :t isJust
23:31:25 <quicksilver> > if isJust (Just 3) then "yes" else "no"
23:31:26 <lambdabot> forall a. Maybe a -> Bool
23:31:27 <lambdabot>   "yes"
23:31:50 <Twey> > Just 3 >> Just "yes"
23:31:51 <lambdabot>   Just "yes"
23:31:57 <Twey> > Nothing >> Just "yes"
23:31:58 <lambdabot>   Nothing
23:32:12 <copumpkin> tsLight: you can also do a case match, use the maybe function, the fromMaybe function, and the functor/applicative/monad/monadplus instances of Maybe
23:32:13 <coCocoa> Rule 1: The user (app) is Always Right. ;p
23:32:15 <mmorrow> > Nothing >> undefined
23:32:16 <lambdabot>   Nothing
23:32:30 <tsLight> copumpkin, thanks
23:32:37 <mmorrow> > forever Nothing
23:32:39 <lambdabot>   Nothing
23:32:56 <copumpkin> > forever [1]
23:32:58 <lambdabot>   * Exception: stack overflow
23:33:03 <copumpkin> :(
23:33:17 <mmorrow> > forever (1:) []
23:33:18 <Twey> What, no partial printin'?
23:33:22 <dancor_> copumpkin: what do you mean a fast codegen
23:33:23 <dmwit> > forever []
23:33:25 <lambdabot>   []
23:33:28 <Hunner> > forever [dukenukem]
23:33:30 <lambdabot>   Not in scope: `dukenukem'
23:33:32 <lambdabot>   thread killed
23:33:33 <Twey> Hehe
23:33:50 <copumpkin> dancor_: I want to compile agda like any other language to machine code, with good optimizations etc. :P
23:33:53 <Hunner> at least lambdabot knows when to kill it...
23:34:01 <mmorrow> i always want a forever' that uses (>>=) instead of >>
23:34:03 <Twey> :-D
23:34:05 <dancor_> copumpkin: oh, i didn't know you couldn't
23:34:09 <dmwit> mmorrow:
23:34:11 <dmwit> :t mfix
23:34:12 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
23:34:27 <mmorrow> true
23:34:49 <copumpkin> > mfix (1:)
23:34:51 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
23:34:51 <lambdabot>        Expect...
23:35:02 <copumpkin> whoops
23:35:09 <copumpkin> > mfix (:[])
23:35:11 <lambdabot>   [* Exception: stack overflow
23:35:18 <copumpkin> that's more like it
23:35:32 <opqdonut> > mfix (\x -> [1:x])
23:35:34 <lambdabot>   [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:35:37 <mmorrow> > flip runCont id (callCC (\k -> mfix (\x if 100 < x then k x else return (x+3))))
23:35:39 <lambdabot>   <no location info>: parse error on input `if'
23:35:47 <mmorrow> > flip runCont id (callCC (\k -> mfix (\x -> if 100 < x then k x else return (x+3))))
23:35:49 <lambdabot>       No instance for (MonadFix (Cont b))
23:35:49 <lambdabot>        arising from a use of `mfix'...
23:35:53 <copumpkin> aw
23:35:56 <mmorrow> wuh
23:36:28 <mmorrow> hmm
23:36:51 <mmorrow> @let forever' m = forever' m <=< m
23:36:53 <lambdabot>  Defined.
23:37:10 <Twey> :t (<=<)
23:37:11 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
23:37:30 <mmorrow> > flip runCont id (callCC (\k -> forever' (\x -> if 100 < x then k x else return (x+3)) 7))
23:37:32 <lambdabot>   103
23:37:38 <opqdonut> ?src mfix
23:37:38 <lambdabot> Source not found.
23:37:40 <copumpkin> har
23:37:46 <dmwit> opqdonut: It's a class function.
23:37:50 <dmwit> ?src MonadFix
23:37:50 <lambdabot> class (Monad m) => MonadFix m where
23:37:50 <lambdabot>     mfix :: (a -> m a) -> m a
23:37:53 <opqdonut> thought as much
23:38:04 <opqdonut> ?src mfix []
23:38:04 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:38:09 <opqdonut> ?src [] mfix
23:38:10 <lambdabot> mfix f = case fix (f . head) of
23:38:10 <lambdabot>            []    -> []
23:38:10 <lambdabot>            (x:_) -> x : mfix (tail . f)
23:38:21 <copumpkin> is mfix on ((->) a) just fix?
23:38:30 <mmorrow> @src (->) mfix
23:38:30 <lambdabot> mfix f = \ r -> let a = f a r in a
23:38:31 <opqdonut> ?src (->) mfix
23:38:31 <lambdabot> mfix f = \ r -> let a = f a r in a
23:38:43 <opqdonut> with an additional parameter, yeah~
23:39:28 <mmorrow> @pl \ r -> let a = f a r in a
23:39:29 <lambdabot> fix . flip f
23:39:36 <mmorrow> so much prettier
23:39:46 <Twey> Concur
23:39:53 <copumpkin> @pl mfix f = \ r -> let a = f a r in a
23:39:53 <lambdabot> mfix = (fix .) . flip
23:40:09 <Twey> Less pretty.
23:40:15 <copumpkin> :P
23:40:23 <Twey> fix .: flip is OK though
23:40:32 <mmorrow> @src IO mfix
23:40:32 <lambdabot> mfix = fixIO
23:40:37 <mmorrow> @src fixIO
23:40:37 <lambdabot> Source not found.
23:40:43 * coCocoa is strangely hungry for hot cereal now...
23:41:03 <copumpkin> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
23:41:12 <copumpkin> IO gets its own fix :(
23:42:47 <mmorrow> if it ain't broke..
23:43:13 <copumpkin> anyway, I prefer loop
23:43:24 <copumpkin> more considerate language
23:43:48 <mmorrow> loop is a nice name
23:44:26 <copumpkin> I'd sort of expect it to be some sort of imperative construct though
23:45:17 <copumpkin> @hoogle Monad m => (a -> Bool) -> m a
23:45:17 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
23:45:18 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
23:45:18 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
23:45:20 <copumpkin> or something like that
23:45:32 <copumpkin> maybe that should be called while
23:51:35 <copumpkin> maybe that should be (a -> Bool) -> a -> m a too
23:51:52 <copumpkin> would make more sense :P
23:53:44 <copumpkin> even that doesn't make any sense, I'm silly
23:54:29 <copumpkin> Monad m => (a -> Bool) -> (a -> m a) -> m a -- is this what I'm looking for? :P
23:55:30 <weilawei> so if i have an IO String and I need it to become a CGI CGIResult?
23:55:54 <copumpkin> CGI CGIResult from where?
23:56:17 <weilawei> Network.CGI, reimport from Network.FastCGI
23:57:18 <copumpkin> >>= output ?
23:58:17 <copumpkin> that will give you an IO (CGI CGIResult) which makes sense, as you can't escape IO
23:58:47 <opqdonut> copumpkin: unless CGI really is IO ;)
23:58:52 <copumpkin> is it?
23:59:01 <copumpkin> in that case, it'll be good
23:59:13 <copumpkin> aha, CGIT IO
