00:21:58 <_vikrant_> sum
00:22:07 <juhp> is http://code.haskell.org down?
00:23:00 <_vikrant_> looks like
00:23:14 <_vikrant_> me too... unable to open
00:23:37 <_vikrant_> map
00:23:55 <_vikrant_> :t map
00:23:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:26:15 <mathijs> small question: I'm playing around with the FFI with help of RWH. this describes how to use c library functions from haskell. Is there some tutorial/info available on doing it the other way around? (using a haskell library from C)?
00:26:37 <mathijs> or is this problematic because of the RTS needing to be loaded?
00:27:10 <Gracenotes> iirc, two-way communication is possible
00:27:48 <mathijs> ok, I hoped so, but I couldn't find a nice example of it.
00:27:49 <Gracenotes> as far as I know Haskell "initiates" the communication with ccall declarations, though.
00:28:29 <Gracenotes> I think the guide might be most useful: http://www.cse.unsw.edu.au/~chak/haskell/ffi/
00:28:36 <Gracenotes> or other guides, if any exist. hm...
00:29:05 <Gracenotes> these are some blog articles, anyway. http://www.haskell.org/haskellwiki/Blog_articles/FFI
00:29:12 <Gracenotes> not sure if they contain this info.
00:29:16 <mathijs> ok, so if haskell initiates everything, it has to be the main binary right? I would like to just have some header file and .o object file to link against
00:30:56 <Gracenotes> the first guide is, rather, the spec
00:31:35 <mathijs> yeah I figured :)  I'm not good at specs, ofcourse I can read them and find the info I need in the end, but I prefer a more basic example :)
00:32:11 <Gracenotes> .nod.
00:32:30 <mathijs> anyway, thanks for helping. I'll dig through it :)
00:52:43 <copumpkin> Heffalump: I managed to get a free account with ARM :D
00:56:41 <myname> exit
01:15:40 <hydo> Looking at http://snurl.com/i922z  , that's just crazypants use of . and not some sort of objective haskell mutant syntax, right?
01:17:20 <copumpkin> > let f = \n m -> length . concat . (replicateM n >=> replicateM m) $ [undefined] in f 5 6
01:17:21 <lambdabot>   93750
01:17:24 <opqdonut> hydo: well the first . is looking up a name from the S namespace
01:17:26 <copumpkin> > let f = \n m -> length . concat . (replicateM n >=> replicateM m) $ [undefined] in f 6 6
01:17:28 <lambdabot>   279936
01:17:32 <opqdonut> the second is just normal composition
01:17:42 <copumpkin> > let f = \n m -> length . concat . (replicateM n >=> replicateM m) $ [undefined] in f 6 7
01:17:44 <lambdabot>   1959552
01:17:57 <copumpkin> that's pretty fast growth
01:18:36 <hydo> copumpkin: right... it's just the same old . that I've come to know and love... just making sure.  I've had to work with ruby lately so it was a bit of a shock to see it used that way at first.  Just making sure that the world is still round, the sky is up, etc.
01:18:46 <copumpkin> ?
01:18:53 <hydo> oops
01:19:03 <copumpkin> oh :)
01:19:17 <hydo> s/ copumpkin / opqdonut / :)
01:19:30 <opqdonut> :)
01:19:47 <Apocalisp> irc is hard
01:19:50 <opqdonut> the letters are like right nexto to eachother
01:20:04 <opqdonut> -o
01:50:45 <fasta> Why can't cabal simply work? Or, please give me a reason to still use cabal install... http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4980#a4980
01:53:15 <opqdonut> hehe
01:53:58 <wjt> what notation for versioned dependencies does the cabal that shipped with ghc 6.8 support? i want to explicitly depend on base 3, but apparently the bundled cabal in ghc 6.8 chokes on 'base == 3.* '
01:56:16 <Axman6> hmm, so i'm reading http://www.cs.umd.edu/~avik/projects/cmllch/... does anyone understand what Concurrent ML does that's so special? i can't seem to understand what's actually happening, or why you would do it/want to
01:59:02 <quicksilver> wjt: try base < 4 ?
01:59:16 <fasta> Axman6: Didn't they have rendez-vous concurrency?
01:59:23 <pejo> Axman6, Concurrent ML is rather old, and as you've figured out based on ML.
01:59:37 <fasta> Axman6: I never used it, but Scheme 48 copied it, AFAIK.
02:00:09 <wjt> quicksilver: lessee...
02:00:28 <Axman6> either of you have a (hopefully not too long) explanation of what it's supposed to do? like how you'd use/what it does when used?
02:00:50 * wjt roundtrips to the bug reporter...
02:05:05 <pejo> Axman6, CML extends SML with synchronous message passing (typed channels). CML has been around since atleast 1991, so it's probably older than any message passing toolkits for Haskell.
02:05:27 <xenoblitz> Hi people, some a simple question: Does anyone know of a document which compares Phantom types and GADTs?
02:05:35 <xenoblitz> * remove some
02:05:46 <ejt> does anyone have an alternative link for Simons 'Fun with Type Functions' paper, microsofts seem to be having trouble with their webserver ?
02:06:50 <xenoblitz> ejt: I managed to download hit here :/
02:06:56 <xenoblitz> *it
02:07:16 <ejt> xenoblitz: I've been trying for the last hour, no luck
02:07:39 <ejt> and there's a comment on reddit from a couple of days ago saying the website is donw
02:07:45 <ejt> s/donw/down/
02:08:09 <xenoblitz> ejt: this one right? http://haskell.org/haskellwiki/Simonpj/Talk:FunWithTypeFuns
02:08:21 <ejt> y
02:08:56 <xenoblitz> weird I clicked the link and it downloaded :S
02:09:00 <quicksilver> xenoblitz: it would be strange to compare them.
02:09:01 <ejt> oh
02:09:04 <quicksilver> xenoblitz: they are isomorphic.
02:09:08 <quicksilver> xenoblitz: erm. wrong word.
02:09:12 <quicksilver> xenoblitz: they are orthogonal!
02:09:24 <quicksilver> xenoblitz: you can use phantom types and gadts separately, you can use them together
02:09:34 <quicksilver> they're not alternatives.
02:09:40 <xenoblitz> quicksilver: so you are basically saying they are used for different things?
02:10:04 <xenoblitz> quicksilver: unfortunately I don't know what orthogonal means :(
02:10:18 <xenoblitz> ejt: want me to email it to you somehow?
02:10:26 <ray> at right angles
02:11:03 <xenoblitz> ray: so different areas of applications?
02:11:53 <quicksilver> xenoblitz: it means more or less what I followed up by saying.
02:12:00 <quicksilver> They are independent - you can use one or the other or both.
02:12:13 <quicksilver> I'm not sure how you'd compare & contrast them
02:12:56 <quicksilver> a phantom type is a type you use "only" for type checking, but don't expect to have real members.
02:13:12 <quicksilver> a GADT is an extension to an ADT which lets your constructors be less than fully polymorphic.
02:14:44 <Workybob> I hate object oriented programming
02:14:58 <Workybob> to define this data type I need more Objective-C files than I need lines in Haskell >.<
02:15:18 <quicksilver> haha.
02:16:49 <quicksilver> Workybob: I'm contributing to a C++ project where the author splits his class hierarchy into class CFoo : class IFoo, where IFoo is a pure virtual interface class. It's quite a sensible way to get real abstraction into C++ but OMG! the boilerplate
02:17:10 <Workybob> hehe
02:18:06 <ivanm> quicksilver: lol
02:18:41 <quicksilver> three files for each new data type - interface/foo.h, foo/foo.h and foo/foo.c++
02:18:51 <quicksilver> makes me want an IDE :)
02:19:22 * ivanm assumes the .c++ file actually contains the code
02:19:34 <xenoblitz> quicksilver: thanks for your pointers :) somehow they clarified things a bit
02:20:02 <quicksilver> xenoblitz: good :)
02:27:33 <ivanm> http://downforeveryoneorjustme.com/code.haskell.org :(
02:28:38 <thoughtpolice> ivanm: yeah, it's really annoying
02:29:38 <ivanm> who runs that server?
02:30:39 <thoughtpolice> i think it's run out of galois or something
02:30:51 <thoughtpolice> couldn't be sure though
02:32:20 <ivanm> http://haskell.org/haskellwiki/Haskell.org_domain
02:32:30 <ivanm> doesn't say who runs it...
02:33:24 <ivanm> "hosted commercially"
02:33:29 <ivanm> http://www.haskell.org/pipermail/haskell-cafe/2008-January/038759.html
02:33:40 <ivanm> methinks a new host is needed...
02:34:58 <ivanm> IIRC, planet.h wasn't loading about 8 hours ago...
02:35:02 <ivanm> and still isn't :(
03:13:47 <Xen0x> Can someone explain the need for all the # signs in the GHC Prim.hs (libraries/GHC-prim/GHC/Prim.hs)?
03:14:08 <quicksilver> "need" ?
03:14:10 <fasta> Is there anyone here with inside knowledge on the xml package? There seems to be some weird choices in it.
03:14:16 <quicksilver> they're a convenitoin, that's all, xenoblitz
03:14:21 <fasta> Xen0x: it's for extra 1337 points.
03:14:22 <quicksilver> Xen0, sorry.
03:14:34 <quicksilver> they conventionally denote compiler internals or compiler primitives
03:14:43 <quicksilver> which should not, for example, appear in public APis.
03:14:48 <fasta> Xen0x: ____INTERNAL___ is old, # is the new thing.
03:15:15 <fasta> Xen0x: or you know what quicksilver says, but I think by explanation is more fun.
03:15:16 <Xen0x> Ahh ok. I thought it was some kind of compiler optimization or something :)
03:15:22 <Baughn> Xen0x: Of course, some of them end up exported anyway, but if you see # you know it's too low-level to use
03:16:16 <Xen0x> Ok. I just bummed into it, because i'm looking into the whole foreign pointer thing and especially the stablePointer
03:28:42 <fasta> What should this do according to you?  takeUntil isNothing [Nothing]
03:29:28 <Baughn>  I'd say.. return nothing.
03:29:37 <Peaker> > takeUntil isNothing [Nothing]
03:29:37 <Baughn> > takeUntil isNothing [Nothing]
03:29:38 <lambdabot>   Not in scope: `takeUntil'
03:29:38 <lambdabot>   Not in scope: `takeUntil'
03:29:52 <fasta> Baughn: if by that you mean [], then I agree.
03:29:52 <Baughn> > takeWhile (not.isNothing) [Nothing]
03:29:53 <lambdabot>   []
03:30:15 <fasta> Baughn: unfortunately, that's not what the people writing Gofer thought...
03:30:23 <Baughn> fasta: Eh?
03:30:33 <fasta> Baughn:  http://hackage.haskell.org/packages/archive/gofer-prelude/2.30.2/doc/html/src/Prelude-Gofer.html#takeUntil
03:30:46 <Baughn> Oh dear
03:31:23 <fasta> They managed to define takeUntil as takeUntilAndIncludeTheElementForWhichTestTestSucceeds
03:31:34 <fasta> The*
03:31:46 <fasta> Most people think until means <
03:31:49 <fasta> Not <=
03:32:20 <yitz> Why do "magic hashes" parse at all? It seems according to the Report that the hash should begin a new lexeme.
03:32:35 <quicksilver> yitz: it would.
03:32:44 <quicksilver> yitz: that's why there is a MagicHash extension.
03:32:53 <doserj> take n xs ++ drop n xs == xs, so I would suggest takeUntil p xs ++ dropWhile p xs == xs
03:33:01 <yitz> kind of ugly actually
03:33:12 <quicksilver> yitz: (this makes it impossible for haskell98 code to 'accidentally' use a foo# identifier, so they are safe)
03:33:25 <quicksilver> I would compare it to the why LaTex uses illegal @-identifiers internally
03:33:39 <quicksilver> and redefines the catcode of @ for internal files.
03:33:40 <doserj> erm,
03:33:52 <doserj> ignore me
03:35:14 <doserj> takeUntil p = takeWhile (not.p) and takeWhile p xs ++ dropWhile p xs == xs
03:38:21 <povman> Who here actually uses list comprehension syntax?
03:38:49 <horms> i do sometimes - though i don't code that much haskell
03:39:09 <Baughn> I just list /monad/ syntax on occasion; anything small enough to be a comprehension tends to end up not being one
03:40:11 <povman> It seems a bit useless to me.
03:40:51 <Baughn> It's convenient if you're coming to haskell from other languages with list comprehensions
03:41:07 <Baughn> And it's just a simplified version of monad syntax anyway. It doesn't get in the way.
03:41:08 <yitz> povman: I use them all the time and I love them.
03:41:52 <quicksilver> I find it occasionally convenient
03:41:56 <povman> yitz: That's good to hear :D I feel bad about not using them (silly huh)
03:42:02 <yitz> heheh
03:42:11 <quicksilver> especially for what would in C be two nested looks
03:42:21 <Ferdirand> sometimes I wish it would work on any MonadPlus, not just on lists
03:42:35 <quicksilver> sequence_ [ drawPrettyThing a b | a <- [1..10], b <- [5,10..100] ]
03:43:03 <yitz> They are really just a kind of specialized do notation that often (but not always) makes list monad expressions more human readable.
03:43:17 <yitz> I like human readable code.
03:44:57 <quicksilver> Ferdirand: I don't believe the desugaring of list comps ever uses (++) or mplus - no MonadPlus required?
03:45:16 <Ferdirand> quicksilver: for conditions ?
03:45:38 <quicksilver> oh, guard.
03:45:46 <quicksilver> guard shouldn't be in MonadPlus, but it is, you're right.
03:45:54 <Saizan_> MonadZero :)
03:52:57 <opqdonut> hrmm, i do :back and get Exception: Prelude.undefined
03:53:20 <opqdonut> the break was triggered by an undefined, and i can do one :back but the second fails
03:54:43 <opqdonut> when i change the undefined into an error, :back works
03:56:01 <fasta> dons: I am not sure whether loch was intended as a toy or not, but rewrite :: (TokenType,String) -> (TokenType,String) is too simplistic to work on real Haskell code. For toy examples it works fine, however. An example of something which does not work: export lists.
03:57:39 <Peaker> fasta: well, if takeUntil includes that last element, it is more useful than if it is just takeUntil = takeWhile . not
03:58:21 <fasta> Peaker: it might be more useful, but it's not what the name says.
03:58:46 <Peaker> fasta: what name would say that?
03:58:50 <fasta> Peaker: I.e. "take" something _until_ some condition. Not until and also include that element.
03:58:53 <Peaker> (reasonable name :-)
03:59:17 <fasta> Peaker: it would probably be a horrible name, but that's besides the point.
04:00:13 <Peaker> fasta: I agree the name kind-of-implies that the last element is not included, but it does not equivocally say so
04:00:30 <Peaker> unequivocally, that is
04:01:00 <Peaker> @unpl takeUntil = takeWhile . not
04:01:00 <lambdabot> takeUntil c = takeWhile (not c)
04:02:47 <int-e> @unpl ap const id
04:02:47 <lambdabot> ((\ a _ -> a) >>= \ d -> (\ b -> b) >>= \ c -> return (d c))
04:09:13 <jelly12gen> @info show
04:09:13 <lambdabot> show
04:09:24 <jelly12gen> @show
04:09:24 <lambdabot> ""
04:12:52 <mgsloan> some #math people are dicks.  I suppose it'd be bad to ask a totally unhaskell question here, even though there are some awesome math people here?
04:14:03 <quicksilver> mgsloan: well, depends what it is. If it's a part of maths which is related to haskell like CPOs or categories, then they are sometimes discussed here
04:14:14 <quicksilver> mgsloan: otherwise there is always #haskell-blah
04:14:46 <mgsloan> yeah, true. Ah, good idea.  I'm afraid it's related to number theory rather than modern algebra
04:15:21 <Peaker> #haskell has 590 people, and #-blah has 64, though
04:15:31 <burp_> @users
04:15:31 <lambdabot> Maximum users seen in #haskell: 658, currently: 591 (89.8%), active: 14 (2.4%)
04:15:35 <Peaker> mgsloan: are you talking about that TRWBN or what's his name? :)
04:15:55 <Peaker> mgsloan: a friend told me that #mathematics (I think that was the name) is better than #math
04:16:19 <poucet> alias
04:16:56 <mgsloan> Peaker - Jafet, actually, but #math certainly has its collection of oddities
04:17:07 <Twey> 12:16:56 *** #mathematics 40 This channel is for seminars. Go to #math for math help.
04:20:41 <ivanm> mgsloan: IIRC, roconnor or Cale have given seminars in #mathematics before...
04:20:53 <ivanm> s/mgsloan/Twey/
04:20:59 <mgsloan> yeah, I know Cale is a math guru
04:21:12 <mgsloan> read his treatsie on the whole nullity thing haha
04:21:28 <Twey> ivanm: Hmn, might be worth hanging around in there, then
04:21:29 <Peaker> fasta: inspired by the last discussion, I wrote a little something that lets you: main = print . take (more 1 $ listPred (<3)) $ [1..10]   -- results in [1,2,3]
04:21:49 <Peaker> fasta: no need for the "more useful" takeUntil that way
04:22:11 <Peaker> list split predicates: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4985#a4985
04:28:59 <Peaker> What interesting class instances can this have? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4985#a4987
04:29:40 <Peaker> hmm.. ListPred is probably a bad name, because it specifically splits lists, not filters them, etc
04:34:02 <Peaker> Maybe the Data.Split module should have something like this?  Its nice to be able to apply transformations to a split (such as take-some-more, etc)
04:34:48 <Peaker> it does mean that building the thing by which you split is separate from applying it (an extra function application to use splitters) but it allows for more interesting combinations of splitting
04:36:06 <Axman6> Tip: Excel absolutely sucks for statistical analysis, even for basic things like linear regression
04:36:22 <Axman6> resist the urge!
04:36:49 <Peaker> Excel is nice for being a "live" functional language, even if a weak one with really bad numeric types
04:37:34 <Botje> can Excel have bottom?
04:37:45 <Axman6> it is bottom
04:37:47 <Axman6> rock bottom
04:37:51 <Botje> :)
04:37:52 <thomastc> it can kiss mine
04:38:04 <yitz> Peaker: ghci is also live. The advantage of Excel is that it gives you typesetting much more conveniently than, say Cairo, at the moment.
04:38:09 <Axman6> as much as MATLAB is a pain, it does shit right!
04:38:58 <yitz> Botje: as in Haskell, Excel has several forms of bottom. For example, there is this blue screen...
04:39:10 <thomastc> there is also the flight simulator
04:39:11 <Peaker> yitz: maybe "live" was the wrong word. Excel is nice for allowing you to update the code and automatically get all of the data-dependencies updated automatically
04:39:14 <thomastc> which is its best feature
04:39:32 <thomastc> and it also has a bottom
04:40:00 <Botje> :]
04:40:02 <yitz> Peaker, yeah, but you can do that in ghci also.
04:40:35 <Peaker> yitz: how?
04:43:00 <yitz> Peaker: you define functions in terms of other variables using let. if you redefine a variable, you then up arrow to the function you want the current value of and hit enter.
04:45:16 <Peaker> yitz: that means you manually update the dependencies
04:45:57 <Peaker> yitz: the interesting thing in Excel is that it finds all the dependencies automatically, updates them, and dependencies can be interesting charts too
04:46:22 <Peaker> Ok, now I have:  (take . more 1 . splitBy $ (<"haha")) ["arc", "hello", "world"] == ["arc","hello"]
04:48:52 <povman> I have nested 'withXXXX'. This is not the first time that has happened. The code looks remarkably like do notation.
04:49:43 <povman> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2440#a2440
04:50:03 <quicksilver> yup.
04:50:07 <quicksilver> common pattern.
04:50:24 <povman> I keep getting a hunch that it's a monad of some sort but I don't think it is
04:51:05 <lilac> povman: looks like a simple form of a continuation monad?
04:51:32 <lilac> although i'd be concerned about the associativity of bind
04:52:49 <quicksilver> @hoogle withArgs
04:52:49 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
04:53:06 <MyCatVerbs> lilac: bind's right-associative, and monad laws mean that the associativity of it doesn't actually matter, no?
04:53:14 <quicksilver> it's like a delimited bind.
04:53:29 <quicksilver> I'm not sure if it relates to a monad
04:53:32 <quicksilver> except by analogy
04:53:36 <lilac> MyCatVerbs: i meant, i'm not sure that the bind of this "monad" is associative
04:54:14 <povman> also, return is hard to define (if not impossible)
04:55:53 <MyCatVerbs> lilac: oh, I thought you meant (>>=). My bad.
04:56:13 <povman> I once read that if I have something that is like a monad but isn't, then it might be an Arrow
04:57:38 <Peaker> povman: I think its better to try to come up with your own combinators and then later see if they match some existing type-class
04:57:55 <povman> ah, good idea
04:59:03 <Peaker> povman: where's withArgs from?
04:59:12 <povman> System.Environment
04:59:25 <povman> @src withArgs
04:59:25 <lambdabot> Source not found. You speak an infinite deal of nothing
04:59:41 <Peaker> withArgs :: [String] -> IO a -> IO a  ?
04:59:52 <Peaker> @type System.IO.withArgs
04:59:53 <lambdabot> Not in scope: `System.IO.withArgs'
05:00:00 <povman> ah yeah, my paste totally doesn't compile
05:00:00 <Peaker> @type System.Environment.withArgs
05:00:01 <lambdabot> forall a. [String] -> IO a -> IO a
05:03:01 <povman> and i completely didn't read the type of 'withArgs' before i used it
05:06:19 <Saizan_> povman: for with* functions nested like that you can use the ContT IO monad to get do-notation
05:06:21 <lilac> povman: withArgs temporarily /sets/ the args
05:06:47 <povman> lilac: I realise this now :D
05:06:57 <lilac> povman: you probably just want do { args <- getArgs; ... }
05:07:16 <povman> lilac: I was getting carried away with the nesting
05:07:28 <povman> lilac: and turned my getArgs into a withArgs
05:07:30 <Saizan_> ?type ContT withFile "foo" ReadMode
05:07:31 <lambdabot> Not in scope: `withFile'
05:07:31 <lambdabot> Not in scope: data constructor `ReadMode'
05:07:48 <povman> Saizan_: That's very interesting. I'll investigate
05:08:26 <Saizan_> you then wrap the whole thing in "runContT return"
05:08:41 <povman> oh of course!!!
05:15:01 <lilac> @type do ss <- ContT (Foreign.withMany Foreign.C.withCString ["hello", "world"]); (n, xs) <- ContT $ Foreign.withArrayLen ss . curry; return $ ?c_main (toEnum n :: Foreign.C.CInt) xs
05:15:02 <lambdabot> forall r a. (?c_main::Foreign.C.Types.CInt -> GHC.Ptr.Ptr Foreign.C.String.CString -> a) => ContT r IO a
05:15:13 <Peaker> povman: I also tried creating a newtype to describe those "with"s and I get:
05:15:14 <Peaker> newtype Bracket m i o = Bracket { unBracket :: (i -> m o) -> m o }
05:15:14 <Peaker> combine :: Monad m => Bracket m i1 o1 -> Bracket m i2 o2 -> Bracket m (i1, i2) (o1, o2)
05:15:36 <Peaker> povman: so it might also be seen as a kind of arrow, maybe
05:16:49 <lilac> @type flip runContT return $ do ss <- ContT (Foreign.withMany Foreign.C.withCString ["hello", "world"]); (n, xs) <- ContT $ Foreign.withArrayLen ss . curry; return $ ?c_main (toEnum n :: Foreign.C.CInt) xs
05:16:50 <lambdabot> forall a. (?c_main::Foreign.C.Types.CInt -> GHC.Ptr.Ptr Foreign.C.String.CString -> a) => IO a
05:17:11 <lilac> that look about right?
05:18:50 <povman> All those ContT make my eyes fall out
05:20:02 <povman> what the
05:20:14 <Peaker> @type map ?f
05:20:15 <lambdabot> forall a b. (?f::a -> b) => [a] -> [b]
05:20:18 <povman> @t (+1) >>> (*2)
05:20:18 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
05:20:34 <povman> @type (+1) >>> (*2)
05:20:34 <lambdabot> forall b. (Num b) => b -> b
05:20:50 <povman> ((+1) >>> (*2)) 3
05:20:57 <povman> > ((+1) >>> (*2)) 3
05:20:58 <lambdabot>   8
05:21:03 <povman> <3
05:22:00 <Peaker> how do implicit args work? how do you give them to functions?  Don't they essentially add multi-arg functions to Haskell and ruin composability of functions?
05:22:59 <quicksilver> they ruin everything.
05:23:16 <quicksilver> let ?foo = 5 in {- expression including functions with implicit foo arg -}
05:23:21 <quicksilver> is how you use them.
05:28:31 <Peaker> @type filter isNull . map ?f
05:28:32 <lambdabot> Not in scope: `isNull'
05:28:36 <Peaker> @type filter null . map ?f
05:28:37 <lambdabot> forall a a1. (?f::a1 -> [a]) => [a1] -> [[a]]
05:28:47 <Peaker> quicksilver: seems like they're still composable
05:29:28 <Peaker> @type (.)
05:29:29 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:29:33 <qaz> I've realized
05:30:04 <quicksilver> Peaker: yes, you can still (.) compose them
05:30:04 <qaz> it is dynamic languages that are restrictive, not static ones
05:30:09 <quicksilver> Peaker: they don't ruin *everything*
05:30:12 <Peaker> quicksilver: what compositions are destroyed?
05:30:12 <quicksilver> Peaker: just, most things.
05:30:38 <quicksilver> various natural code restructurings
05:31:46 <fasta> How can I disable recursive expand for whatever is interpreting CPP? I thought the default was not to do recursively expand.
05:32:13 <Peaker> quicksilver: sounds like they might be nice in the sense of having "keyword args"?
05:32:37 <Peaker> though propagating them up automatically into random contexts where their names are meaningless is probably a bad idea
05:34:51 <Twey> Peaker: There are better ways to get keyword arguments
05:35:02 <augustss_> qaz: yes! :)
05:35:08 <Twey> Oleg has a nice implementation
05:35:46 <fasta> Twey: did you ever use his implementation?
05:37:32 <lilac> Peaker: implicit args basically implicitly thread a reader monad through code which uses them
05:38:00 <povman> qaz: I don't really understand that. Remember, there is no spoon!
05:38:35 <Peaker> are they so much easier to implement than class aliases?
05:38:38 <lilac> Peaker: viewing them as syntactic sugar for reader monads certainly helped me...
05:39:11 * boegel presses send on his large message to haskell-cafe, and wonders what will result from it
05:39:15 <lilac> also, they're pretty similar to type class passing, in a vague way
05:39:32 <Peaker> lilac: restriction accumulation on the type
05:39:33 <lilac> (except more powerful since you can have multiple distinct and distinguishable instances)
05:40:25 <fasta> boegel: maximum message size reached ;)
05:40:29 <lilac> Peaker: i've failed to extract any semantics from that :-(
05:41:48 <Peaker> lilac: composing two types that have restrictions results in a type that has the restrictions of both, but maybe that's not entirely accurate
05:41:51 <boegel> fasta: eh?
05:42:06 <boegel> fasta: oh
05:42:09 <fasta> boegel: :)
05:42:11 <boegel> fasta: well, might be close
05:42:23 <boegel> fasta: has 9.7KB in attachments, and quite a bit of text
05:42:57 <boegel> I hope some will take the time to read it
05:45:15 <povman> Can I use cabal to generate and use the *_stub.? files used by FFI?
05:45:40 <povman> cabal seems to like C being called from Haskell, but not the other way around :(
06:02:15 <kacper_> how to proof reverse = rev ----- rev = aux [] where aux xs [] = xs aux xs (y:ys) = aux (y:xs) ys
06:04:20 <lilac> @type let a = length ?foo; b = return 'x' `asTypeOf` ?foo in   (let ?foo = mempty in ?foo, let ?foo = mempty in a `seq` ?foo, let ?foo = mempty in b `seq` ?foo, let ?foo = mempty in a `seq` b `seq` ?foo)
06:04:21 <EvilTerran> kacper_, well, that depends on the definition of "reverse"
06:04:21 <lambdabot> forall a a1 (m :: * -> *). (Monoid (m Char), Monoid a, Monad m) => (a, [a1], m Char, [Char])
06:04:42 <lilac> @src reverse
06:04:42 <lambdabot> reverse = foldl (flip (:)) []
06:04:46 <lilac> kacper_: ^^ that reverse?
06:05:05 <EvilTerran> kacper_, unless you mean "how to prove {rev = aux [] where aux xs [] = xs aux xs (y:ys) = aux (y:xs) ys} has the property {rev . rev = id}"?
06:05:26 <EvilTerran> or whatever
06:05:36 <EvilTerran> (insert other suitable properties as appropriate)
06:05:50 <EvilTerran> (and note that one only works for finite lists)
06:08:09 <ivanm> EvilTerran: only because if you want to reverse an infinite list, you'll be waiting for quite a while? :p
06:09:10 * EvilTerran supposes "rev . rev \refinesTo id" might be a better way of writing it
06:09:28 <EvilTerran> although you'd probably want some kind of upper bound on the refinement, too
06:11:53 <ivanm> with reads, why does it return a list?  as a substitute for Maybe?
06:12:37 <EvilTerran> ivanm, in case the parse is ambiguous, i believe
06:12:52 <ivanm> EvilTerran: so it returns multiple possible parses?
06:13:03 <EvilTerran> in theory, it can, yeah
06:13:04 <ivanm> > reads "112" :: [(Int,String)]
06:13:05 <lambdabot>   [(112,"")]
06:13:08 <ivanm> hmmm...
06:13:09 <EvilTerran> although derived instances will never do that
06:13:13 <EvilTerran> AFAIK
06:13:14 <ivanm> can you think of an example?
06:13:18 <ivanm> @src reads
06:13:18 <lambdabot> reads = readsPrec minPrec
06:13:25 <ivanm> @src readsPrec
06:13:25 <lambdabot> Source not found. Where did you learn to type?
06:13:30 <ivanm> @hoogle readsPrec
06:13:30 <lambdabot> Prelude readsPrec :: Read a => Int -> ReadS a
06:13:30 <lambdabot> Text.Read readsPrec :: Read a => Int -> ReadS a
06:13:59 <ivanm> @src minPrec
06:14:00 <lambdabot> Source not found. That's something I cannot allow to happen.
06:14:02 <EvilTerran> because of the maximum munch meta-rule in the haskell grammar, derived instances will always be unambiguous
06:14:23 <ivanm> derived as in "make one up"?  or "deriving (Read)" ?
06:14:28 <Saizan> but you can use `mplus`
06:14:56 <EvilTerran> as in "deriving"
06:14:56 <ivanm> Saizan: surely that came about after reads was implemented?
06:15:01 <ivanm> EvilTerran: *nod*
06:15:12 <ivanm> so it might be for custom types return multiple instances?
06:15:42 <Saizan> ivanm: not sure, but i think the idea of using StateT [s] [] a as the simplest type for parsers is quite old
06:15:49 <EvilTerran> for hand-written instances, the ambiguty might be useful, i guess.
06:15:58 <ivanm> Saizan: *nod*
06:16:30 <EvilTerran> ?unmtl StateT [s] [] a
06:16:30 <lambdabot> [s] -> [(a, [s])]
06:16:42 <EvilTerran> ?type reads
06:16:43 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:16:51 <Peaker> @src ReadS
06:16:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:16:54 <Peaker> @info ReadS
06:16:54 <lambdabot> ReadS
06:17:06 <ivanm> heh
06:17:11 <EvilTerran> @info \is -> "@undo"
06:17:11 <lambdabot> \ is -> "@undo"
06:17:23 <Peaker> @info sucks
06:17:23 <lambdabot> sucks
06:17:23 <ivanm> what a remarkably useful plugin...
06:17:37 <EvilTerran> @info do x <- foo; y <- bar; return (x,y)
06:17:38 <lambdabot> foo >>= \ x -> bar >>= \ y -> return (x, y)
06:17:46 <EvilTerran> it's lambdabot's spelling correction at work :)
06:18:25 <EvilTerran> ,src ''ReadS
06:18:32 <lunabot>  type ReadS a = String -> [(a, String)]
06:18:52 <Peaker> Why '' ?
06:18:53 <ivanm> so how is reads any different from applying ReadS?
06:19:05 <ivanm> Peaker: that is the required magic voodoo incantation?
06:19:08 <ivanm> *shrug*
06:19:17 <EvilTerran> Peaker, ' quotes a value-level name, and '' a type-level name
06:19:25 <ivanm> EvilTerran: so what is @info turning into?  @undo?
06:19:25 <EvilTerran> because that's how TH works
06:19:38 <EvilTerran> ivanm, yeah, exactly
06:19:40 <Peaker> EvilTerran: what do names without either ' or '' refer to?
06:19:49 <kacper_> I found http://209.85.229.132/search?q=cache:JueXExHs2gEJ:www.haskell.org/soe/PPTSlides/Ch14.ppt+infinite+lists+haskell+induction&cd=6&hl=pl&ct=clnk&client=opera
06:19:56 <EvilTerran> Peaker, er, the usual haskell meaning of the name?
06:20:11 <kacper_> at the bootm is way to proof for infinite lists
06:20:18 <Peaker> EvilTerran: meaning either value or type depending on context?
06:20:55 <EvilTerran> Peaker, map is a function; 'map is its name
06:22:00 <ivanm> EvilTerran: is that quoting in the same way lisps quote lists, etc.?
06:22:13 <EvilTerran> , [$ty| map |]
06:22:16 <lunabot>  forall a b . (b -> a) -> [] b -> [] a
06:22:18 <EvilTerran> , [$ty| 'map |]
06:22:20 <lunabot>  Name
06:23:10 <EvilTerran> ivanm, it's related, yeah
06:23:16 <Peaker> I hate TH syntax
06:23:20 <EvilTerran> although it only applies to names, not arbitrary expressions
06:23:33 <EvilTerran> ivanm, a closer analogy to (quote ...) would be [|...|] and friends
06:23:52 <ivanm> and I (thankfully, methinks) have no idea what they do ;-)
06:24:03 <EvilTerran> , [| 1 + 2 |]
06:24:05 <lunabot>  InfixE (Just (LitE (IntegerL 1))) (VarE +) (Just (LitE (IntegerL 2)))
06:24:15 <ivanm> gah!
06:24:34 <ivanm> is that expanding it out into it's behind-the-scenes representation?
06:24:50 <EvilTerran> well, its TH-datatypes representation
06:24:59 <ivanm> I take it the Maybe values are because you might not have values on either side of an operator?
06:25:07 <ivanm> > [| (+2) |]
06:25:08 <lambdabot>   <no location info>: parse error on input `|'
06:25:12 <ivanm> heh
06:25:17 <ivanm> , [| (+2) |]
06:25:19 <lunabot>  InfixE Nothing (VarE +) (Just (LitE (IntegerL 2)))
06:25:22 <EvilTerran> [|...|] is the syntax tree of (...)
06:25:53 <ivanm> *nod*
06:27:02 <kacper_> is filter f (xs++ys) = filter f xs ++ filter f ys for infinite lists?
06:27:18 <ivanm> I would think so...
06:27:25 <ivanm> why wouldn't it be?
06:27:37 <kacper_> its only question
06:28:08 <mreh> i've just been shown the hamming list in haskell
06:28:26 <kacper_> and reverse xs = foldl ( flip(:) ) [] xs ?
06:28:27 <ivanm> kacper_: I'm not trying to accuse your or anything
06:28:35 <ivanm> @src reverse
06:28:35 <lambdabot> reverse = foldl (flip (:)) []
06:28:48 <mreh> is the derivation of things such as circular definitions optimised
06:29:02 <mreh> i've just answered my own question
06:29:52 <Peaker> Will this be a circular structure:   map id (cycle "hello")  ?
06:30:07 <ivanm> Peaker: internally you mean?
06:30:09 <mreh> > let reverse xs = foldl (flip (:)) [] xs in reverse [1..10]
06:30:10 <Peaker> yeah
06:30:11 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
06:30:26 <ivanm> AFAIK, cycle doesn't have to return an infinite list, ghc just returns it that way...
06:30:28 <mreh> @src reverse
06:30:28 <lambdabot> reverse = foldl (flip (:)) []
06:30:38 <Peaker> ivanm: O(1) space
06:30:45 <ivanm> Peaker: yeah
06:30:47 <Peaker> or O(N) (N=cycle length)
06:30:56 <mreh> :t flip
06:30:57 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
06:30:58 <ivanm> s/cycle/list/
06:31:21 <ivanm> Peaker: but IIRC, there's no haskellian reason for it to be circular
06:31:36 <Peaker> ivanm: I guess I'm asking about ghc specifically
06:31:44 <mreh> isn't cycle "hello" also a circular structure?
06:31:49 <Peaker> I wonder if there's a good way to retain the nice space properties of cycle for functions of cycle too
06:31:51 <ivanm> mreh: it is in ghc
06:32:13 <ivanm> Peaker: is asking if map f . cycle also represented internally by ghc as a circular structure
06:32:29 <mreh> let cycle x = x : cycle x in cycle "lo"
06:32:35 <mreh> > let cycle x = x : cycle x in cycle "lo"
06:32:37 <lambdabot>   ["lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo"...
06:32:54 <Peaker> that's repeat
06:32:58 <Peaker> > repeat "lo"
06:32:59 <lambdabot>   ["lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo","lo"...
06:33:11 <mreh> > let cycle x = concat ( x : cycle x in cycle "lo" )
06:33:12 <lambdabot>   <no location info>: parse error on input `in'
06:33:30 <mreh> > let cycle x = concat ( x : cycle "lo" ) in cycle "lo"
06:33:31 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
06:33:34 <Peaker> > let cycle xs = xs' ; xs' = xs ++ xs' in cycle "lo"
06:33:35 <lambdabot>   Not in scope: `xs'
06:33:43 <Peaker> > let cycle xs = xs' where xs' = xs ++ xs' in cycle "lo"
06:33:44 <lambdabot>   "lololololololololololololololololololololololololololololololololololololo...
06:33:47 <mreh> > let cycle x = concat ( x : cycle x ) in cycle "lo"
06:33:48 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
06:33:48 <lambdabot>        Expect...
06:33:56 <yowgi> @src cycle
06:33:56 <lambdabot> cycle [] = undefined
06:33:56 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
06:34:17 <mreh> i didnt know there was an undefined keyword
06:34:23 <Peaker> @src undefined
06:34:23 <lambdabot> undefined =  error "Prelude.undefined"
06:34:23 <mreh> isn't error used for partial functions?
06:34:27 <mreh> :D
06:35:33 <mreh> my definition of cycle required an infinite list to be calculated
06:35:38 <mreh> it wouldn't terminate
06:35:56 <mreh> in fact, it's just plain wrong
06:36:30 <mreh> i just did hamming lists, :(, my brane hurt
06:36:44 <mreh> does anyone know the definition?
06:37:15 <Peaker> mreh: its allowed to not terminate if it can generate some data constructors in finite time
06:37:28 <Jedai> mreh: The definition of what ?
06:37:42 <mreh> i take it that the circular defintion of the hamming list makes it a linear algorithm
06:38:01 <mreh> if it were really recursive, it would take infinite time
06:38:14 <yairchu> Jedai: Peaker gave the defintion you can guess the question now :)
06:38:25 <Peaker> yairchu: hey!
06:38:59 <yairchu> Peaker: Yoyo
06:39:10 <Peaker> yairchu: you abandoned bigorilla?
06:39:16 <mreh> @src merge
06:39:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:39:20 <mreh> @src mer
06:39:20 <lambdabot> Source not found. Where did you learn to type?
06:39:38 <yairchu> Peaker: No I use it to sign lolcats
06:39:40 <Jedai> @hoogle merge
06:39:41 <lambdabot> Distribution.Simple.PackageIndex merge :: Package pkg => PackageIndex pkg -> PackageIndex pkg -> PackageIndex pkg
06:39:41 <lambdabot> Text.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
06:39:41 <lambdabot> Text.ParserCombinators.Parsec.Error mergeError :: ParseError -> ParseError -> ParseError
06:39:55 <mreh> thanks
06:40:02 <Jedai> mreh: If I remember correctly, merge was defined locally anyway
06:40:18 <Jedai> mreh: You're talking about Hamming list, no ?
06:40:21 <mreh> i'll paste some code in a sec, and you can explain to me how it works
06:40:28 <mreh> Jedai: yes
06:41:00 <mreh> i'm a little confused about how it works in linear time, but i am under the impression that it does work because it is represented as a circular structure
06:41:35 <Jedai> mreh: it works the same way than "fibs = 0 : 1 : zipWith (+) fibs (tail fibs)", and no it's not circular at all
06:41:54 <Berengal> The definition is circular...
06:41:59 <Berengal> But that's not too unusual
06:42:07 <Jedai> mreh: It's lazy
06:42:10 <mreh> it doesn't recalculate the whole fibs
06:42:20 <mreh> it just uses what it has already worked out in that definition above
06:42:42 <Jedai> Berengal: circular in this sense right, but not in the same sense as the result of cycle is circular
06:43:00 <Berengal> Jedai: No, indeed not
06:43:02 <mreh> is that right? what I have just said?
06:43:23 <Jedai> mreh: Right
06:43:52 <wli> > let merge3 ~(x:xs) ~(y:ys) ~(z:zs) | x < y && x < z = x : merge3 xs (y:ys) (z:zs) | y < x && y < z = y : merge3 (x:xs) ys (z:zs) | z < x && z < y = z : merge3 (x:xs) (y:ys) zs | x == y && x < z = x : merge3 xs ys (z:zs) | x == z && x < y = x : merge3 xs (y:ys) zs | y == z && y < x = y : merge3 (x:xs) ys zs | otherwise = x : merge3 xs ys zs ; hams = 1 : merge3 (map (2*) hams) (map (3*) hams) (map (5*) hams) in take 10 $ drop 10 hams
06:43:53 <lambdabot>   [15,16,18,20,24,25,27,30,32,36]
06:43:53 <mreh> so as it goes about it's evaluation, it saves alot of time
06:44:31 <mreh> wli has got it
06:44:55 <mreh> :t merge3
06:44:56 <lambdabot> Not in scope: `merge3'
06:45:04 <Jedai> mreh: So hams is the same as fibs
06:45:06 <mreh> does lambdabot not remember things
06:45:20 <wli> @type let merge3 ~(x:xs) ~(y:ys) ~(z:zs) | x < y && x < z = x : merge3 xs (y:ys) (z:zs) | y < x && y < z = y : merge3 (x:xs) ys (z:zs) | z < x && z < y = z : merge3 (x:xs) (y:ys) zs | x == y && x < z = x : merge3 xs ys (z:zs) | x == z && x < y = x : merge3 xs (y:ys) zs | y == z && y < x = y : merge3 (x:xs) ys zs | otherwise = x : merge3 xs ys zs in merge3
06:45:21 <lambdabot> forall t. (Ord t) => [t] -> [t] -> [t] -> [t]
06:45:31 <mreh> she's clever isnt h
06:45:31 <Peaker> I dislike your function, wli :(
06:45:32 <mreh> she
06:45:36 <Jedai> mreh: merge3 was defined locally, it's not destined to be remembered
06:45:39 <wli> Peaker: Why?
06:45:48 <mreh> wli: just nest two merges
06:45:54 <Peaker> wli: its repetative, there's probably a nicer way
06:45:57 <mreh> merge one (merge two three)
06:46:03 <Jedai> mreh: You can add a function to lambdabot with @let so that it will remember it
06:46:15 <Berengal> mergeMany = foldl merge [] ?
06:46:24 <kacper_> > reverse [1..]
06:47:10 <kacper_> > reverse [1..]
06:47:15 <mreh> what Berengal said
06:47:32 <Jedai> kacper_: Could you stop asking impossible thing from lambdabot ?
06:47:42 <mreh> haha
06:47:59 <mreh> @faq Can Haskell reverse infinite lists?
06:48:07 <mreh> she's thinking...
06:48:08 <lambdabot> The answer is: Yes! Haskell can do that.
06:48:35 <Jedai> mreh: Of course it takes infinite time and infinite memory but still... ^^
06:48:44 <kacper_> ;)
06:49:33 <Berengal> > let merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) = if x < y then x:merge xs (y:ys) else if x == y then x:merge xs ys else y:merge (x:xs) ys in foldl' merge [] [sort [1,5,4,6,7,4,5,6,7], sort [3,5,6,8,9,54,4,23,4,6,76,4,5,6,6], sort [5,6,3,4,6,78,8,6,4,5,6,6,78]]
06:49:42 <lambdabot>   [1,3,4,4,4,5,5,6,6,6,6,6,7,7,8,9,23,54,76,78,78]
06:49:59 <mreh> if they are equal Berengal, you need to discard one
06:50:10 <mreh> it's a speshul merge
06:50:29 <Berengal> I thought I did...
06:50:34 <mreh> yeah...
06:50:35 <mreh> funny
06:50:47 <Berengal> Ah,
06:50:56 <Berengal> > let merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) = if x < y then x:merge xs (y:ys) else if x == y then x:merge xs ys else y:merge (x:xs) ys in foldl' merge [] $ map nub [sort [1,5,4,6,7,4,5,6,7], sort [3,5,6,8,9,54,4,23,4,6,76,4,5,6,6], sort [5,6,3,4,6,78,8,6,4,5,6,6,78]]
06:50:58 <lambdabot>   [1,3,4,5,6,7,8,9,23,54,76,78]
06:51:12 <Berengal> merge doesn't handle repeats in the same list well
06:51:27 <Berengal> It requires sorted sets
06:51:48 <mreh> why foldl'
06:51:52 <Berengal> Why not?
06:52:19 <ahamay42> To category experts: What is the difference between Haskell arrows and the morphisms of a category with Haskell types as Obejcts?
06:52:42 <ahamay42> I always thought it's the same, but now I read it's something else
06:57:09 <hellige> ahamay42: you mean haskell functions, or haskell arrows?
06:57:42 <mreh> how can a brother make some dough fast with Haskell?
06:58:03 <lilac> > let merge xs@(x:xt) ys@(y:yt) = case x `compare` y of { LT -> x:merge xt ys; EQ -> x:merge xt yt; GT -> y:merge xs yt }; merge xs ys = xs ++ ys in foldl' merge [] $ map (nub . sort) [[1,5,4,6,7,4,5,6,7],[3,5,6,8,9,54,4,23,4,6,76,4,5,6,6],[5,6,3,4,6,78,8,6,4,5,6,6,78]]
06:58:04 <lambdabot>   [1,3,4,5,6,7,8,9,23,54,76,78]
06:58:46 <lilac> mreh: start with flour, butter, milk and yeast
06:59:29 <mreh> Curry flavoured?
06:59:49 <ahamay42> @hellige I mean arrows
06:59:49 <lambdabot> Unknown command, try @list
07:00:13 <mreh> any haskell game devs on?
07:00:15 <Elly> we do not believe in your twitterisms here
07:00:22 <mreh> i'm looking to get some experience
07:00:41 <hydo> @Elly what's a twitterism?
07:00:42 <lambdabot> Unknown command, try @list
07:00:45 <hydo> (lawl)
07:01:32 <fasta> mreh: you probably have more luck if you ask an actual question.
07:02:10 <mreh> doesn anyone need any help on their haskell? :D
07:02:24 <hydo> Why is it that you never realize that you aren't going to be funny until -after- you hit enter?
07:02:56 <mreh> double negative
07:03:06 <hydo> yep
07:03:20 <Twey> I don't
07:03:21 <Twey> :-P
07:03:28 <Berengal> How is that a double negative?
07:03:36 <Elly> sometimes double negatives are meaningfully distinct from positives, like in that case :P
07:03:36 <Twey> Berengal: Never + aren't
07:03:41 <Twey> Yeah
07:03:42 <hydo> never ... aren't?  or am I really more tired than I thought?
07:03:47 <Berengal> Twey: They apply to two different things...
07:03:52 <opqdonut> yeah
07:03:54 <Twey> There's nothing logically wrong with that
07:03:57 <opqdonut> never realize and are not
07:04:02 * Twey nods.
07:04:03 <povman> Elly: non-negative is a prime example
07:04:24 <Elly> povman: indeed :)
07:04:35 <Elly> (if your definition of "negative" is "not positive or zero")
07:04:38 <mreh> but if you un-negate (!) both of the negatives, you get a sentance that means something else
07:04:44 <hydo> sentence
07:04:46 <hydo> haw haw!
07:04:49 <hydo> :)
07:05:17 <ahamay42> I just stumbled across http://chris.chris-lotte.net/publications/2006/arrows/arrows.pdf and was wondering why Arrows should be such a complicated thing instead of just Morphisms
07:05:55 <mreh> damn
07:05:59 <ahamay42> and as I'm using Arrows in my master thesis, the answer is quite important to me :)
07:07:19 <opqdonut> what do you mean by "such a complicated thing instead of just Morphism"
07:08:31 <mreh> Does not compute
07:10:04 <mreh> I can't stand half educated half wits like stephen fry and douglas adams whittering on about apple macs
07:10:08 <ahamay42> opqdonut: well, they state "Hughes' arrow" corresponds to to monoids in a suitable subcategory etc."
07:10:54 <ahamay42> but I always thought haskell arrows are just corresponding to the morphisms of a category
07:11:09 <ahamay42> even it's a special one
07:11:44 <Saizan> it's true that the class Arrow doesn't have a very good name
07:12:01 <Saizan> it's a bit like taking only the first 100 primes and calling them Primes
07:12:25 <quicksilver> they're something like morphisms in a CCC which admits a functor from Hask, aren't they?
07:12:33 <quicksilver> (a CC-functor)
07:13:05 <ahamay42> quicksilver: I'd agree
07:13:25 <lilac> mreh: i think it's unfair to call stephen fry a half educated half wit, just because you disagree with his opinion...
07:13:45 <Saizan> you should be able to write curry if that's true, right?
07:14:03 <Saizan> and uncurry
07:14:18 <povman> @seen Lemmih
07:14:18 <lambdabot> Lemmih is in #haskell. I don't know when Lemmih last spoke.
07:14:41 <Saizan> but a ~> (b ~> c) -> (a,b) ~> c needs ArrowApply i think
07:14:59 <quicksilver> hmm, not CC-functors, then
07:15:04 <quicksilver> just C-functors.
07:15:13 <quicksilver> that is, they are required to preserve product but not apply
07:15:23 <quicksilver> not sure why that particular setup was chosen as the default
07:15:32 <ahamay42> so that means they are just the morphisms, but of a somewhat haskell-specific category?
07:16:12 <ahamay42> I could live with that, I was just feeling bad to sell something to people as category which isn't, in fact :)
07:16:25 <Saizan> each instance of Arrow creates a subcategory of Hask, i guess
07:17:01 <Saizan> (and by "i guess" i mean, afaiu CT, which is not that much)
07:17:33 <hatds> does every arrow instance have an identity?
07:17:48 <hatds> arr id I guess :)
07:17:56 <Saizan> where Hask is the category with types as objects and monomorphic functions as morphisms
07:18:57 <ahamay42> why do they need to be monomorphic?
07:19:52 <hatds> well, polymorphic functions are handled by treating them as natural transformations
07:19:56 <ahamay42> hatds: exactly, but you have to give id explicitly when defining an Arrow instance as Arrow is a subclass of Category
07:21:08 <ahamay42> ah you mean monomorphic in a sence that it's not polymorphic - I was thinking of injective functions
07:21:35 <hatds> heh, no relationship between the two in this case
07:21:57 <ahamay42> :)
07:22:51 <codebliss> Does anyone see an error in my code?  http://haskell.pastebin.com/mf33b59b
07:23:05 <codebliss> I have the failed output in the pastebin, it's one I've never seen
07:23:15 <hatds> then b -> then [b]
07:23:26 <codebliss> Hm?
07:23:41 <hatds> codebliss: line 3
07:23:43 <ahamay42> -> = replace by
07:23:55 <codebliss> I'm expecting the following.  clean [1,3,3,5,6,4,6,6,7] = [1,3,5,6,4,6,7]
07:23:58 <codebliss> Alright
07:24:10 <codebliss> Not nub, just two consecutive
07:24:25 <mreh> easy
07:24:26 <hatds> if the typechecker complains about constructing an infinite type with lists, then it is probably just a "single element list versus single element" mix up
07:24:30 <mreh> oh... hang on
07:24:32 <mreh> not easy
07:24:41 <codebliss> Ah, alright
07:25:12 <TonyTheTiger> hi guys, for one of my exercise tasks it asks us to write a function which combines a list of lists into a single list, concat' :: [[a]] -> [a]
07:25:34 <TonyTheTiger> mreh:  is that to me?
07:25:46 <mreh> nup
07:26:00 <mreh> that's an easy one
07:26:03 <Berengal> concat' = concat :P
07:26:12 <mreh> heehee
07:26:14 <Ferdirand> concat' = join
07:26:17 <codebliss> I gotta go to class in 5, anyone got any ideas?  I'm missing something basic I assume
07:26:20 <TonyTheTiger> Berengal: that defies the point of learning to do it myself
07:26:27 <Berengal> Ferdirand: join = concat already
07:26:36 <mreh> @src concat
07:26:36 <lambdabot> concat = foldr (++) []
07:26:40 <hatds> boo
07:26:49 <ahamay42> I guess you're supposed to write a recursive one
07:26:51 <Ferdirand> Berengal: i know :)
07:26:56 <codebliss> Points-Free = life
07:26:57 <TonyTheTiger> yeah its a recursive task
07:27:05 <TonyTheTiger> i tried a few things and its just error galore
07:27:15 <ahamay42> then paste your attempts
07:27:29 <Saizan> codebliss: use group
07:27:43 <Saizan> > group [1,3,3,5,6,4,6,6,7]
07:27:44 <lambdabot>   [[1],[3,3],[5],[6],[4],[6,6],[7]]
07:27:45 <doserj> codebliss, hint: the error is in the "then" branch here: clean (a:b:[]) = if a == b then b else a:b:[]
07:27:54 <codebliss> I see, i already hoogled
07:27:54 <TonyTheTiger> i tried concat' (x:xs) = concat' x ++ concat' xs but realised thats sooo wrong
07:28:08 <mreh> just decompose a fold
07:28:23 <mreh> fold is a generalisation of a recursive function application
07:28:29 <hatds> the subexpression "concat' x" won't typecheck
07:28:37 <Berengal> TonyTheTiger: concat' (x:xs) = x ++ concat' xs works
07:28:40 <Ferdirand> but it's almost correct !
07:28:40 <TonyTheTiger> ahamay42: Although you can believe im lieying I work in one file which i kept deleting code, trial and error basis
07:29:01 <TonyTheTiger> Berengal: I tried that but that gives an error
07:29:08 <mreh> trial error gets you nowhere
07:29:24 <TonyTheTiger> because x might be a list itself
07:29:26 <hatds> trial error is good if you are thinking about your mistakes
07:29:37 <Berengal> > let concat' [] = []; concat' (x:xs) = x ++ concat' xs in concat [[1..10],[11..20],[21..30]]
07:29:39 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:29:39 <TonyTheTiger> and the idea is to flatten the list from a [[a]] to [a]
07:30:00 <TonyTheTiger> what the heck why does that work here
07:30:07 <TonyTheTiger> gonna go test that again brb
07:30:18 <Berengal> TonyTheTiger: x _is_ a list. You want to prepend it to the result of concating the rest of the list
07:30:30 <Berengal> Remember, the input is of type [[a]]
07:30:32 <TonyTheTiger> ahh but what if x isnt a list?
07:30:34 <TonyTheTiger> then what?
07:30:51 <Berengal> x has to be a list, because the input is of type [[a]] :P
07:30:52 <hatds> ask yourself what's the type of concat'
07:31:02 <hatds> ^^ that
07:31:03 <ahamay42> the first element of a list of lists is a list :)
07:31:09 <Jedai> TonyTheTiger: x is a elem of [[a]], it _has_ to be a list
07:31:16 <TonyTheTiger> ooh ok thats where i screwed up
07:31:22 <codebliss> let clean xs = map head $ group xs
07:31:26 <codebliss> Thanks guys =)
07:31:30 <Berengal> Yeah, nested types can get messy at first...
07:31:35 <TonyTheTiger> i kept thinking a [[a]] could be [a,[]]
07:31:54 <ahamay42> so it was good you stated your guess :)
07:31:56 <TonyTheTiger> now it becomes easier
07:32:09 <ahamay42> no, every element in a list needs to have the same type
07:32:16 <Jedai> TonyTheTiger: Haskell is not Lisp
07:32:22 <TonyTheTiger> ok so a list is a "type" then?
07:32:28 <Jedai> TonyTheTiger: nor a dynamic language
07:32:32 <TonyTheTiger> Jedai: I dont know about lisp :(
07:32:51 <ahamay42> "a list of ..." is a type, like list of integers e.g.
07:32:52 <Jedai> TonyTheTiger: [Int] is a type
07:32:55 <Berengal> TonyTheTiger: A list is a type constructor
07:33:00 <Jedai> TonyTheTiger: it's a list of Int
07:33:03 <Berengal> That is, [] is a type constructor
07:33:18 <Jedai> TonyTheTiger: [[Int]] is also a type, it's a list of lists of Int
07:33:25 <Berengal> [] Int, or [Int] (they are the same), are lists of Ints
07:33:41 <TonyTheTiger> ok so i cant have.... [[1,2,3],[1,2],5] but can have [[1,2],[3],[4,5]]
07:33:44 <Berengal> Note that [] the value is an element of all lists
07:33:56 <Berengal> > 3:[]
07:33:57 <lambdabot>   [3]
07:33:59 <Berengal> > [3]:[]
07:34:00 <lambdabot>   [[3]]
07:34:04 <Jedai> TonyTheTiger: Right, the list are homogenous (every element is of the same type)
07:34:19 <TonyTheTiger> ok, thanks guys that really cleared that up
07:34:38 <TonyTheTiger> i was thinking of various ways to validate if x was a list or a single element
07:34:55 <Berengal> > concat [[[1],[2]],[[3],[4]]]
07:34:56 <lambdabot>   [[1],[2],[3],[4]]
07:35:04 <Jedai> TonyTheTiger: That's not to say you can't do heterogenous lists (containing elements of miscellaneous types) in Haskell, but [] is not it
07:35:51 <Berengal> > (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) (:[]) 5
07:35:52 <lambdabot>   Couldn't match expected type `t1
07:35:57 <Berengal> :/
07:36:24 <ahamay42> I've got another categorial question: Hughes "generalizing monads to arrows" paper introduces a maybe functor - but I don't believe it really is a functor
07:36:27 <Jedai> Berengal: forgot the (.)
07:36:43 <Berengal> Jedai: Yeah, I sort of noticed...
07:36:53 <mreh> desktop gaming is almost history, is there a haskell for web project?
07:37:00 <Jedai> ahamay42: Why ?
07:37:11 <ahamay42> I mean instead of A -f-> B, you now have A -f-> Maybe B
07:38:07 <ahamay42> but when you have B -g-> C as well, then there's no clear mapping for the object B
07:38:13 <Jedai> mreh: You mean a "Haskell on Rail" ? There are several, Happstack is probably one of the nicer and most complete (and most Haskellite)
07:38:26 <ahamay42> as for f, B is mapped to B again
07:38:39 <adityam> is there a higher order function that captures if (something) then [] else [a complicated list]?
07:38:39 <ahamay42> but for g, B is mapped to Maybe B
07:38:48 <ahamay42> I mean it the other way around
07:39:01 <ahamay42> f and g swapped
07:40:12 <ahamay42> so to make it a functor, I guess it should be like Maybe A -f-> Maybe B, analogueous to fmap in Haskell's Functor class
07:40:22 <Jedai> adityam: guard ?
07:40:37 <quicksilver> what are you talking ahamay42 ? :) Insufficient context.
07:40:44 <quicksilver> A -> Maybe B is an arrow
07:40:52 <quicksilver> it's the kleisli arrow of the maybe monad
07:40:56 <quicksilver> is that what you mean?
07:41:19 <ahamay42> not necessairy kleisli, but yes
07:41:55 <ahamay42> I mean the idea is to have an arrow of type A -> B which in reality maps to an underlying arrow of type A -Y Maybe B
07:42:21 <quicksilver> you're still not making sense.
07:42:24 <quicksilver> (sorry)
07:42:33 <ahamay42> no I am sorry :)
07:42:40 <quicksilver> data MyArrow a b = a -> Maybe b
07:42:45 <quicksilver> ^^ this is, indeed, an arrow
07:42:51 <quicksilver> as it would be for any other monad instead of Maybe
07:42:55 <adityam> Jedai: guard has a return type m (), I need a return [a] (or m a)
07:43:02 <quicksilver> kleisli composition induces and arrow for all monads.
07:43:09 <endojelly> hmm, so let me get synthesize in Data.Generics right...
07:43:16 <endojelly> why is the following not working:
07:43:20 <endojelly> linearizeStmt :: Code -> [Code] -> [Code]
07:43:22 <lilac> ahamay42: Maybe is itself a functor. it maps the type X to the type Maybe X, and arrows (functions) X -> Y to arrows Maybe X -> Maybe Y
07:43:34 <endojelly> oh wait a minute.
07:43:39 <hatds> adityam: if/then/else
07:43:39 <ahamay42> yeah but I'm not interested in Kleisli an Monads, just arrows in general
07:43:43 <ahamay42> like in Hughes' paper
07:43:52 <lilac> ahamay42: like all correct instances of the Functor typeclass, Maybe is a covariant endofunctor on Hask.
07:43:57 <Jedai> adityam: guard False >> ['a'..'e']
07:44:03 <endojelly> no it doesn't work.
07:44:03 <endojelly> so:
07:44:03 <Jedai> > guard False >> ['a'..'e']
07:44:04 <hatds> adityam: or something like  liftM3 if'
07:44:05 <lambdabot>   ""
07:44:09 <endojelly> linearizeStmt :: Code -> [Code] -> [Code]
07:44:12 <Jedai> > guard True >> ['a'..'e']
07:44:14 <lambdabot>   "abcde"
07:44:14 <endojelly> linearize code = synthesize [] (++) (mkQ [] linearizeStmt)
07:44:24 <endojelly> that's obviously wrong
07:44:26 <endojelly> but... hm, why?
07:44:30 <endojelly> :t synthesize
07:44:31 <lambdabot> forall s t a. (Data a) => s -> (t -> s -> s) -> GenericQ (s -> t) -> a -> t
07:44:34 <adityam> hatds: I wan to avoid if then else because the if condition is empty
07:44:51 <endojelly> so the third argument should be of type (Data a => a -> s -> t), no?
07:44:56 <adityam> Jedai: Thanks
07:44:57 <endojelly> s and t are the same for me, both [Code]
07:44:59 <hatds> adityam: then a guard is not what you maybe
07:45:05 <hatds> adityam: *not what you want
07:45:06 <ahamay42> I'm talking about the Arrow class and functors in a categorial sense (not the functor class which is just for functions)
07:45:08 <Ferdirand> adityam: filterM perhaps ?
07:45:08 <endojelly> so it should have type a -> [Code] -> [Code]
07:45:12 <Jedai> hatds: guard works perfectly
07:45:39 <endojelly> wouldn't (mkQ [] linearizeStmt) result in a function of type a -> [Code] -> [Code], given a function of type Code -> [Code] -> [Code]?
07:45:42 <endojelly> :t mkQ
07:45:43 <lambdabot> forall r b a. (Typeable b, Typeable a) => r -> (b -> r) -> a -> r
07:46:28 <endojelly> so, for me, that's [Code] -> (Code -> [Code] -> [Code]) -> a -> [Code] -> [Code], no?
07:46:49 <lilac> > let f x = guard (x > 1) >> [0..x]  in  (f 0, f 1, f 2, f 3)
07:46:51 <lambdabot>   ([],[],[0,1,2],[0,1,2,3])
07:47:04 <Jedai> ahamay42: The functor class is not "just for function", it corresponds to a Functor in the CT sense
07:47:06 <ahamay42> so to be more precise: My remark is about http://www.cs.chalmers.se/~rjmh/Papers/arrows.pdf page 26
07:47:31 <ttmrichter> Are there any GHC porting experts available at the moment?
07:47:47 <ahamay42> Jedai, yes it does but still it is limited to inputs od type a -> b instead of (Arrow ar) => ar a b
07:47:55 <ahamay42> *of
07:48:34 <lilac> ahamay42: the Functor class is for covariant endofunctors on Hask.
07:48:36 <Jedai> ahamay42: Ok, in that sense I agree, it's just restricted to a certain category (Hask) where arrows are functions
07:48:47 <ahamay42> yes
07:48:49 <lilac> the arrows of Hask are functions, so in that sense you're right :)
07:49:41 <ahamay42> I was just wondering about Hughes' introducing his MaybeFunctor as (mathematical functor, which doesn't make sense to me
07:50:05 <ahamay42> as I don't find a mapping between the two involved categories
07:50:11 <lilac> ahamay42: every Functor instance is a (mathematical) functor, but the converse is not true
07:50:55 <ahamay42> lilac: yes, I agree, but I'm absolutely not talking about the Functor class, so let's forget about this for now :)
07:51:31 <lilac> sounds like i should read the paper in question then :-)
07:51:55 <Cale> ahamay42: hmm...
07:52:00 <lilac> from which category is Hughes' MaybeFunctor a functor?
07:52:13 <ahamay42> I hoped someone here had already read this :)
07:53:36 <ahamay42> he doesn't state, but I guess it must be a mapping between the category with a (an Arrow instance) as morphisms and the one with MaybeFunctor a as morphisms
07:53:42 <hatds> ahamay42: MaybeFunctor is a functor on Hask
07:53:50 <ahamay42> though I'm not sure about the direction
07:53:55 <Cale> ahamay42: hmm... well, this is a functor in a number of ways, but not the obvious way you'd expect.
07:54:22 <ahamay42> how can it be a functor in Hask if the definition is an generic arrows and not functions?
07:54:54 <ahamay42> cale: sounds interesting :)
07:56:07 <Cale> If you think of the collection, for all types b and c of arrows a b c as a category under <<< and arr id, then you'd normally expect a functor F to send each object t to an object F t, and an arrow a b c to an arrow a (F b) (F c). But that's not what this does.
07:56:53 <ahamay42> yes, I can follow until here :)
07:57:10 <endojelly> ooh, I got it.
07:57:52 <endojelly> @hoogle a -> [a]
07:57:53 <lambdabot> Prelude repeat :: a -> [a]
07:57:53 <lambdabot> Data.List repeat :: a -> [a]
07:57:53 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
07:58:07 <endojelly> come on, there's got to be a singleton function for lists
07:58:14 <Cale> (:[])
07:58:21 <doserj> or return
07:58:24 <quicksilver> fear the monkey.
07:58:30 <endojelly> Cale, yes I know that one but that's not nice
07:58:32 <endojelly> doserj, oooh.
07:58:35 <endojelly> of course
07:58:40 <Cale> endojelly: What's not nice about it?
07:58:43 <Jedai> endojelly: You have pure too
07:58:44 <quicksilver> how can you say the monkey isn't nice?
07:58:50 <quicksilver> That's a pretty dangerous comment.
07:58:58 <Jedai> > pure 5 :: [Int]
07:59:00 <lambdabot>       Ambiguous occurrence `pure'
07:59:00 <lambdabot>      It could refer to either `Control.Appl...
07:59:04 <quicksilver> (:[ {- I've seen it eat young children whole -} ])
07:59:15 <Jedai> > Control.Applicative.pure 5 :: [Int]
07:59:17 <lambdabot>   [5]
07:59:26 <endojelly> Cale, because just "singleton" would be nicer, instead of combining two constructors
07:59:29 <Cale> There is at least one sense in which it is a functor: if c is any type, MaybeFunctor a b can be applied to it, and if f: c -> c' is any function, then we get a corresponding function MaybeFunctor a b c -> MaybeFunctor a b c'
08:00:00 <Cale> endojelly: "singleton" is way more typing for less clarity about what it does ;)
08:01:21 <doserj> I bet there is a singleton::Collection c e => e -> c e somewhere
08:01:26 <ahamay42> Cale: that sounds reasonable - but do you think this is what Hughes meant when he called if fucntor instead of say arrow transformer?
08:01:35 <Cale> ahamay42: I don't think so.
08:01:44 <hellige> is there an easy way to build profiling-supporting libraries without rebuilding all of ghc?
08:02:06 <Cale> ahamay42: oh, wait, I see
08:02:15 <hellige> i need ghc6-prof for 6.10.1 on ubuntu, and there's no package for it. :(
08:02:21 <Cale> ahamay42: It's a functor, but not an endofunctor.
08:02:44 <Jedai> hellige: If you build GHC yourselve and didn't build profiling... I don't think so. On the other hand, the binary package comes with profiled libraries
08:02:50 <ahamay42> between which categories?
08:03:09 <Cale> ahamay42: It goes from the category Hask to the Kleisli category for Maybe
08:03:27 <Cale> well...
08:03:29 <hellige> Jedai: no, it doesn't... not on ubuntu... :(
08:03:45 <ahamay42> okay, so you're still with the same functor
08:03:47 <hellige> Jedai: someone build a 6.10.1 binary package, but the profiling support is separate.
08:04:04 <Cale> The subcategory of Hask constructed by Hughes arrows a to ...
08:04:04 <hellige> and no one built it yet, i guess. so if i want a binary package with profiling, i have to go back to 6.8.2. :(
08:04:22 <Jedai> hellige: I use the binary package from GHC webpage myself
08:04:23 <ahamay42> maybe I should email him and ask whether this is what he meant :)
08:04:43 <hellige> Jedai: ah, yeah, forgot they had one. i'll give that a shot, maybe. thanks for the reminder.
08:04:59 <Jedai> hellige: it contains profiled version of the libraries IIRC
08:05:22 <Cale> Okay, I think I can formalise this in a way which probably agrees with him.
08:05:31 <Jedai> hellige: Don't forget to configure your cabal to gets profiled version of the package you install with it
08:06:15 <hellige> Jedai: yeah, i know i'll have to rebuild some cabal stuff. but that won't take too long.
08:06:19 <hellige> Jedai: thanks!
08:06:34 <Cale> Fix the Hughes arrow a, and let Hask_a be the category whose objects are the objects of Hask, and whose arrows f: b -> c are the values of type a b c, with composition <<<
08:08:46 <Cale> Let Hask_a^Maybe be the category whose objects are the objects of Hask_a (which are the objects of Hask), and whose arrows f: b -> c are the arrows in Hask_a, f: b -> Maybe c, but then these are the values of type a b c in Hask
08:08:54 <Cale> er
08:09:02 <Cale> values of type a b (Maybe c) rather
08:09:16 <ahamay42> Cale: sorry, I've got to leave now - are you still with c->c' to MaybeFunctor a b c -> MaybeFunctor a b c' ? Or some new start and target categories?
08:09:24 <Cale> ahamay42: New ones
08:09:41 <Cale> Then MaybeFunctor a is a functor Hask_a -> Hask_a^Maybe
08:09:59 <ahamay42> yeah, but I don't believe it really is a functor
08:10:05 <Cale> We can check :)
08:10:09 <ahamay42> maybe we can finish this diskussion another time
08:10:33 <ahamay42> or mail me to bsteuber@gmail.com - this would be great :)
08:10:37 <Cale> liftMaybe is the actual functor
08:10:44 <ahamay42> hm ok
08:11:22 <Cale> MaybeFunctor implements the type level machinery for it, and liftMaybe actually transforms the arrows as needed
08:12:16 <Cale> In any event, this is more or less just the Kleisli category embedding. Maybe is also a monad on the category Hask_a
08:13:15 <ahamay42> ok thanks for your help - I'll think it over
08:13:39 <ahamay42> I'll go now - bye
08:15:58 <Cale> Amazing the amount of discussion that 3 lines of code can generate ;)
08:17:40 <endojelly> I don't think I really "get" synthesize yet %)
08:18:09 <endojelly> "2nd argument o is for reduction of results from subterms"
08:21:34 <Cale> Which synthesize?
08:21:53 <endojelly> Data.Generics.Synthesize
08:21:57 <Cale> Sounds like something from Generic... yes
08:24:17 <Cale> hmm
08:24:21 <Cale> synthesize z o f x = f x (foldr o z (gmapQ (synthesize z o f) x))
08:25:32 <Cale> or...
08:25:45 <qaz_> to delete from a BST do you really need 9 cases or should 3be enough?
08:26:21 <Cale> qaz_: What does your BST type look like?
08:28:05 <endojelly> nevermind. apparently, I want "everything" instead of "synthesize" anyway.
08:28:19 <qaz_> Cale: data BinarySearchTree a =
08:28:20 <qaz_>     Leaf | Node a (BinarySearchTree a) (BinarySearchTree a)
08:28:20 <qaz_>     deriving(Show)
08:28:34 <Tobsan> qaz_: three cases should be enough
08:28:53 <Cale> I can't imagine what the 9 cases would even be ;)
08:29:00 <qaz_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4992#a4992
08:29:03 <qaz_> ^^ those
08:31:10 <Tobsan> meh
08:31:14 <qaz_> 10 caes actually
08:31:17 <Tobsan> oh
08:32:17 <Cale> Let me give it a shot.
08:33:12 <gnuvince_> @src ((->) a) mappend
08:33:12 <lambdabot> Source not found.
08:33:16 <gnuvince_> @src mappend ((->) a)
08:33:16 <lambdabot> Source not found. That's something I cannot allow to happen.
08:33:24 <gnuvince_> gah, I never can do this right
08:33:52 <quicksilver> it's not a monoid, anyway.
08:34:01 <quicksilver> it has the wrong kind - it still has a parameter.
08:34:07 <quicksilver> Monoids have to have no parameter.
08:34:36 <quicksilver> you could write a Monoid instance for Monoid m => Monoid (a -> m) but I don't think that's in the libs anywhere.
08:34:43 <MyCatVerbs> I need a better model of GHC's type system. Some of the things it lets me get away with are just heinous, and yet at the same time relatively innocuous looking stuff fails. :)
08:35:02 <endojelly> :t runWriter
08:35:03 <lambdabot> forall w a. Writer w a -> (a, w)
08:35:48 <gnuvince_> quicksilver: I'm trying to wrap my head around Monoids over functions, but I'm not sure I understand the intuition behind them
08:35:58 <gnuvince_> > (1:) `mappend` (2:) $ [3]
08:35:59 <lambdabot>   [1,3,2,3]
08:36:26 <quicksilver> that must be the instance I'm talking about
08:36:39 <quicksilver> (f `mappend` g) x = f x `mappend` g x
08:36:42 <quicksilver> pointwise mappend
08:36:46 <Cale> qaz_: Well, in the interests of not keeping you too long, let's start here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4992#a4993
08:36:47 <Xen0x> If you have defined a monad "QMonad a = ReaderT (Int) IO a" could you get the value out of the monad, just like using unsafePerforIO?
08:36:49 <quicksilver> I'm pretty sure that's not in the standard libs though
08:37:00 <quicksilver> must be a lambdabot extension
08:37:06 <Cale> qaz_: Of course, the EQ case is going to be the most interesting.
08:37:12 <dschoepe> gnuvince_: mappend for functions is composition
08:37:23 <doserj> quicksilver: it is defined in Data.Monoid
08:37:27 <jmcarthur> > (1:) . (2:) $ [3]
08:37:29 <lambdabot>   [1,2,3]
08:37:35 <jmcarthur> ^^ is different from the above
08:37:37 <qaz_> hmm yea i must be able to simplify that
08:37:44 <vixey> Xen0x, It would not be anything like unsafePerformIO
08:37:58 <MyCatVerbs> :t runReaderT
08:37:59 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
08:38:10 <MyCatVerbs> Xen0x: you can get from the ReaderT Int (IO a) to (IO a) with runReaderT.
08:38:19 <Cale> qaz_: Now, the trouble just becomes selection of a new root and an element to delete from either the left or right subtree.
08:38:24 <MyCatVerbs> Xen0x: from there, you could use unsafePerformIO, but actually you probably don't want to.
08:38:41 <dons> this needs help from a haskell person, http://stackoverflow.com/questions/876948/higher-kinded-generics-in-java
08:38:47 <MyCatVerbs> Er, should not have put parens around the first (IO a) there.
08:38:54 <MyCatVerbs> dons: oh DEAR me.
08:39:00 <Xen0x> but with runReaderT, you don't lose the value carried around within the monad?
08:39:25 <dons> quicksilver, Cale you guys should comment :)
08:40:06 <MyCatVerbs> Xen0x: no? You have to *supply* that value in order to use runReaderT, so the value will still be in scope somewhere where you can use it.
08:40:09 <Cale> qaz_: There are three cases, but they chain nicely. Either we find an element in the left subtree, delete it from there, and make that our new root, or we find an element in the right subtree, delete it from there, and make that our new root, or we fail to find an element in either, in which case we're left with a Leaf
08:40:54 <Cale> qaz_: Maybe has useful functions for chaining things together in this way.
08:41:08 <TonyTheTiger> how can i take a list and return the list but split into 2?
08:41:43 <jmcarthur> :t \(x:xs) -> (x,xs) -- cheating
08:41:44 <lambdabot> forall t. [t] -> (t, [t])
08:41:45 <Xen0x> MyCats; maybe I don't understand, but how can I use the runReaderT then, to get the IO a?. Just use runReaderT monad?
08:41:58 <jmcarthur> :t \(x:xs) -> ([x],xs) -- slightly more correct cheating
08:41:59 <lambdabot> forall t. [t] -> ([t], [t])
08:41:59 <Xen0x> where monad is of type; ;QMonad a
08:42:03 <MyCatVerbs> Xen0x: runReaderT environment monad
08:42:04 <mmorrow> splitAt, span, break
08:42:19 <TonyTheTiger> how can i take a list and return the list but split into 2??
08:42:20 <mmorrow> @type splitAt 1
08:42:21 <lambdabot> forall a. [a] -> ([a], [a])
08:42:37 <MyCatVerbs> Xen0x: e.g. you have type QMonad a = ReaderT Int IO a.
08:42:38 <jmcarthur> TonyTheTiger, mmorrow is helping you
08:42:46 <jmcarthur> i was pretending to
08:42:54 <TonyTheTiger> jmcarthur: yeah i just realised, gonna go test.
08:42:55 <TonyTheTiger> sorry
08:43:07 <mmorrow> TonyTheTiger: how do you want to determine _where_ to split it?
08:43:18 <MyCatVerbs> Xen0x: when you make use of that, the types will work out like: (runReaderT (foo :: Int) (monad :: QMonad a)) :: IO a
08:43:21 <TonyTheTiger> mmorrow: has to be in the middle
08:43:34 <MyCatVerbs> (Unless I made a mistake, which happens ~_^)
08:43:37 <TonyTheTiger> mmorrow: so it can only be on lists of equal length
08:43:37 <mmorrow> ah, \xs -> splitAt (length xs `div` 2) xs
08:43:41 <mmorrow> or something then
08:44:00 <TonyTheTiger> what would happen if a list that wasnt even is input?
08:44:07 <TonyTheTiger> if using an if case appropriate?
08:44:09 <mmorrow> , 5 `div` 2
08:44:11 <lunabot>  2
08:44:31 <MyCatVerbs> TonyTheTiger: with mmorrow's solution there, if you give an odd-length input then the second list will be one element longer than the first list.
08:45:09 <mmorrow> jmcarthur: did you ever attempt a gcc compile of a /dict/words switch trie?
08:45:16 <Xen0x> MyCatVerbs; I get the picture now. I was only thinking about the passing around of the carried value, but when I use runReaderT I probably don't want that value to be in the Monad (QMonad) anymore, so I don;t need the carried values anymore
08:45:22 <qaz_> Cale: the problem is the base case
08:45:24 <qaz_> s
08:45:26 <TonyTheTiger> MyCatVerbs: yeah im not allowed that, but methinks an if can fix it, but not sure if thats the "correct" way
08:45:30 <jmcarthur> mmorrow, no i never got a chance this weekend
08:45:36 <jmcarthur> mmorrow, i still plan to
08:45:45 <TonyTheTiger> but thanks i didnt know of the split At functions
08:46:24 <mmorrow> jmcarthur: cool, i'm gonna try to remember to leave it running next time i'm away from the computer too
08:46:28 <MyCatVerbs> TonyTheTiger: well, where *do* you want the odd element to go if the list's length isn't even?
08:46:54 <Cale> qaz_: I think it helps to have a function findDeleteMin :: BST a -> Maybe (a,BST a), and similar for max
08:46:58 <TonyTheTiger> MyCatVerbs: its an exam question that im practicing, so that doesnt really matter
08:47:47 <MyCatVerbs> TonyTheTiger: if it doesn't specify what to do with lists of odd lengths then your exam question doesn't contain enough information to determine the solution. :P
08:48:22 <Peaker> in which case you can write all the solutions!
08:48:24 <TonyTheTiger> MyCatVerbs: yeah i wouldnt be surprised. The questions I keep seeing everyone round here keeps saying how they are "bad" questions :(
08:48:34 <tetha> I vote to read two lists from the user and return those if the input length is odd
08:48:46 <tetha> I once did something like that and hilarious things happened later on
08:49:07 <roconnor> @src ReaderT
08:49:07 <lambdabot> Source not found. Where did you learn to type?
08:49:10 <jmcarthur> TonyTheTiger, i would solve it for even lists and write your assumptions about what the question really wants
08:49:22 <roconnor> @unmtl ReaderT r m a
08:49:23 <lambdabot> r -> m a
08:49:29 <roconnor> @unmtl Reader r (m a)
08:49:29 <lambdabot> r -> m a
08:49:47 <jonathanturner> trying to wrap my head around type inference.  "let a x = \x -> x + x" works with a 10, but doesn't with a 10.4.
08:49:48 <jmcarthur> well, and obviously have it do *something* with odd lengths, but i just mean make sure that there was ambiguity about what the question was asking
08:50:04 <mmorrow> ,
08:50:05 <jmcarthur> > let a x = \x -> x + x in a 10
08:50:05 <lunabot>  luna: <stdin>: Data.ByteString.hGetLine: end of file
08:50:06 <lambdabot>       Overlapping instances for Show (a -> a)
08:50:06 <lambdabot>        arising from a use of `s...
08:50:07 <roconnor> @unmtl WriterT w m a
08:50:07 <lambdabot> m (a, w)
08:50:08 <jmcarthur> > let a x = \x -> x + x in a 10 10
08:50:10 <lambdabot>   20
08:50:13 <jmcarthur> > let a x = \x -> x + x in a 10 10.4
08:50:14 <lambdabot>   20.8
08:50:23 <roconnor> @unmtl m (Writer w a)
08:50:23 <lambdabot> m (a, w)
08:50:48 <mmorrow> @type \xs -> let n = length xs `div` 2 in if even n then [splitAt n xs] else [splitAt n xs, splitAt (n+1) xs]
08:50:49 <lambdabot> forall a. [a] -> [([a], [a])]
08:51:05 <MyCatVerbs> jonathanturner: if you type "let a = \x -> x + x" at GHCi's prompt, then it'll infer a monomorphic type for a.
08:51:05 <jmcarthur> jonathanturner, you must be doing something different than i
08:51:18 <jmcarthur> oh, yeah, ghci would do that
08:51:52 <MyCatVerbs> jonathanturner: you've run into the monomorphism restriction. GHCi is defaulting to a :: (Integer -> Integer).
08:52:18 <MyCatVerbs> If you define it by, let a x = x + x -- instead, then it will infer the correct type, (Num a) => a -> a.
08:52:23 <jonathanturner> MyCatVerbs: I thought that might be the case, but "let b = \x -> x ++ x" works with both b [1]  and b["bob"]
08:53:02 <MyCatVerbs> jonathanturner: that's because b is being inferred as [a] -> [a], and there are no constraints at all on a.
08:53:23 <MyCatVerbs> The monomorphism restriction only kicks in when there are typeclass constraints present.
08:53:44 <jonathanturner> MyCatVerbs: that makes sense
08:54:02 <MyCatVerbs> It's an artifact of a minor worry about efficiency that the Haskell98 committee had about polymorphic types and sharing.
08:54:04 <jonathanturner> MyCatVerbs: still very much wrapping my head around this stuff
08:54:18 <jonathanturner> MyCatVerbs: is it getting fixed in Haskell'?
08:54:48 <MyCatVerbs> jonathanturner: yep. And it'll be turned off by default anyway in GHC 6.12 and up, AFAIK.
08:54:55 <Cale> qaz: Oops! Those recursive cases are actually wrong in an obvious way ;)
08:54:59 <MyCatVerbs> jonathanturner: long story short, it annoys the people who work on GHC itself too. :)
08:55:02 <jonathanturner> MyCatVerbs: cool, not that it's bad or anything, just confusing
08:55:35 <Cale> qaz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4992#a4994
08:56:31 <MyCatVerbs> jonathanturner: it *is* bad enough that the people who hack on GHC for fun and profit hate it and want to make it go away. :)
08:57:00 <jonathanturner> MyCatVerbs: you said they had monomorphic restrictions because of efficiency concerns?  do you know if there is an implementation discussion about that?  I'm learning Haskell, but also interested in the implementation side as wel
08:57:47 <MyCatVerbs> The wiki page, http://www.haskell.org/haskellwiki/Monomorphism_restriction explains it better than I could.
08:57:49 <endojelly> :t runWriter
08:57:50 <lambdabot> forall w a. Writer w a -> (a, w)
08:58:18 <Cale> jonathanturner: Basically, the concern is that when you have a value like  (Num a) => a  it is implemented internally by a (non-memoised) function from a Num dictionary to an appropriate value of the right type.
08:58:28 <Cale> jonathanturner: That is, as a function  Num a -> a
08:58:55 <Cale> jonathanturner: So, things which look like constants can actually end up being functions, and being recomputed each time they are used.
08:59:47 <Saizan> (the haskell report actually explains it best, imo)
08:59:59 <MyCatVerbs> Except that it never actually comes up in practice any more. For starters, the optimiser's gotten cleverer. For seconds, it never came up that often anyway.
09:00:05 <Cale> jonathanturner: The MR is just a terrible solution to this problem. It says that if you have a pattern binding (something which looks like a constant definition), it can't be typeclass polymorphic unless it has an explicit type signature.
09:00:59 <Cale> So basically, what should have been a warning at best, is now an error.
09:02:00 <Cale> I think it's safe to say, given the last 10 years or so of everyone having to deal with it, that it's a flaw in the standard.
09:02:02 <MyCatVerbs> Haskell lets me make up type-level lists. oO
09:02:27 <Peaker> I think the concept of compiler warnings is a bad/silly one.  If you don't want to fix it -- you can't just leave it there as noise -- you'll miss the warnings you do want to fix. So it might as well be an "overridable error" that you can override with some pragma or such
09:02:53 <MyCatVerbs> Peaker: oh hey, that gets subsumed by LANGUAGE pragmas.
09:02:55 <Cale> MyCatVerbs: That comment earlier about Haskell's type system letting you get away with things you expected not to, what was that about?
09:03:06 <MyCatVerbs> Cale: that. ^^
09:03:07 <jonathanturner> Peaker: that's not a bad idea, but it would slow new programmers down considerably
09:03:16 <Cale> MyCatVerbs: Type level lists?
09:03:16 <Peaker> MyCatVerbs: I'd rather these overrides were on a per-case basis, rather than a per-error-type basis
09:03:33 <Saizan> you can already override MR by giving a type signature
09:03:37 <MyCatVerbs> Peaker: to some extent, we already do this with things like -XOverlappingInstances.
09:03:42 <Cale> Peaker: But it should never prevent a program from compiling.
09:03:56 <Saizan> but still, it's awful to have to explain such a quirk to beginners
09:04:01 <hatds> I think Peaker is talking about the notion of compiler warnings in general
09:04:10 <Cale> We shouldn't prevent programs from compiling over minor potential performance problems.
09:04:11 <MyCatVerbs> Overlapping instances are an error in H98, but asking for -XOverlappingInstances turns the check off.
09:04:20 <Peaker> Cale: I think it should -- because mtime-based checking means that you're going to accidentally ignore all warnings if it did compile
09:04:34 <Cale> mtime?
09:04:43 <Peaker> Cale: its not preventing compilation, its just delaying it/requiring that you add an override
09:04:47 <roconnor> Saizan: I believe that there are some obtuse cases were you cannot simply add a type signature.
09:04:52 <MyCatVerbs> So there's no reason you couldn't stick lots of extra warnings in as LANGUAGE features. :)
09:05:08 <Cale> Peaker: Well, in that case, we should remove it altogether.
09:05:10 <Peaker> Cale: modification times on files is the common system that is unfortunately used to determine whether to recompile -- and any warnings that were issued before are not re-issued
09:05:11 <roconnor> Saizan: thing of the MR applied in a where clause to something that contains type variables from the main function.
09:05:14 <roconnor> think
09:05:21 <Cale> Peaker: huh?
09:05:24 <Cale> Peaker: Since when?
09:05:42 <Cale> Peaker: I expect my compiler to report the exact same thing when given the same inputs.
09:05:45 <MyCatVerbs> Cale: if I have F.hs and G.hs, compile both, F emits warnings.
09:06:00 <Cale> Does GHC actually do that?
09:06:05 <MyCatVerbs> Cale: and then modify G and recompile, where G depends on F... I won't get the warnings from F repeated to me.
09:06:13 <endojelly> :t everywhere'
09:06:14 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
09:06:16 <endojelly> :t everywhereM'
09:06:17 <lambdabot> Not in scope: `everywhereM''
09:06:18 <endojelly> :t everywhereM
09:06:19 <lambdabot> forall (m :: * -> *) a. (Monad m, Data a) => GenericM m -> a -> m a
09:06:24 <Cale> MyCatVerbs: Oh, because F is already compiled, sure.
09:06:30 <hatds> MyCatVerbs: well, that's what separate compilation should do, no?
09:06:51 <MyCatVerbs> hatds: well, I assume it ought to, but then I've never actually tried the alternative.
09:06:54 <Cale> If there's an F.o and F.hs doesn't need to be compiled, then of course you won't see the warnings again.
09:07:02 <Peaker> Cale: the prevalent build systems in use do not re-report warnings, which is another reason to not create the final output if there are warnings
09:07:13 <Cale> Peaker: You mean cabal?
09:07:15 <Peaker> Cale: its too easy to miss warnings by accident
09:07:18 <Cale> Peaker: or GHC?
09:07:20 <Peaker> Cale: cabal, ghc, make
09:07:25 <Cale> Interesting.
09:07:39 <endojelly> :t gmapT
09:07:39 <MyCatVerbs> Peaker: no it isn't? Cabal's normal compilation output is *really* terse, one line per file.
09:07:40 <lambdabot> forall a. (Data a) => (forall b. (Data b) => b -> b) -> a -> a
09:07:41 <endojelly> :t gmapM
09:07:42 <lambdabot> forall (m :: * -> *) a. (Monad m, Data a) => (forall a1. (Data a1) => a1 -> m a1) -> a -> m a
09:07:49 <MyCatVerbs> Peaker: source warnings show up like glowy beacons in the middle of it.
09:07:50 <Cale> I'm going to have to try this.
09:07:52 <quicksilver> I don't find it easy to miss warnings by accident.
09:08:01 <Peaker> MyCatVerbs: but then when you recompile, you don't get the warnings again
09:08:03 <Saizan> roconnor: with the constraint on some other variable, yeah, but it's not so common i'd think
09:08:06 <Cale> Somehow I can't believe that it would be the case.
09:08:37 <Peaker> quicksilver: I just saw some mention of accidentally ignored warnings on Haskell blogs -- and it has bitten me before too
09:08:46 <Peaker> quicksilver: its another thing I have to keep in mind when compiling
09:08:51 <MyCatVerbs> Peaker: The only time you do seperate recompilation is when you're modifying the package yourself. Otherwise you're building the whole thing from scratch from Hackage, most likely.
09:09:05 <Peaker> MyCatVerbs: right, and warnings are less interesting in that scenario
09:09:08 <MyCatVerbs> Peaker: and if you're working on it yourself, then you just turn -Werror on if you care about warnings.
09:09:16 <roconnor> Saizan: and it also cuts both ways.  You cannot monomorphically restrict with the MR off by adding a signature. ... I guess the real problem is not being able to give signatures to any subexpression.
09:09:21 <Cale> Peaker: It's a lie. GHC reports warnings every time a module is compiled.
09:09:22 <Peaker> MyCatVerbs: Right, I suggest -Werror as a default
09:09:25 <MyCatVerbs> (And runhaskell Setup clean, too.)
09:09:31 <Peaker> Cale: but it doesn't recompile if a final output was produced
09:09:46 <Saizan> roconnor: there's always `asTypeOf`
09:09:56 <Peaker> Cale: if you were fixing some errors you got from a compilation, and then re-issue a recompile expecting to fix the remaining errors, you're going to ignore the warnings that you didn't fix
09:10:02 <Peaker> Cale: (in files that had only warnings)
09:10:15 <MyCatVerbs> Peaker: that won't help much. It'll break a whole pile of existing code for exceedingly little benefit. It's not like you can't put Werror in the .cabal file yourself, so having it not be the default doesn't prevent you from doing anything.
09:10:25 <Cale> You'll get all the warnings for the module you just modified.
09:10:42 <Peaker> MyCatVerbs: It might not be the best thing to do now, but I think it would be far better if it was that way in the first place
09:10:56 <Cale> There's an easy solution though. rm *.o
09:10:59 <Peaker> Cale: right, and you'll accidentally ignore all the warnings in modules that "successfully" compiled
09:11:05 <Peaker> Cale: indeed, and -Werror too
09:11:11 <MyCatVerbs> Peaker: and I do hope we can skip the "but undisciplined programmers will just ignore warnings", because IMHO undisciplined programmers will write crap code anyway no matter how fussy you make the compiler.
09:11:16 <Peaker> Cale: IMO it should be a default
09:11:23 <Cale> Peaker: But the warnings are not that important anyway
09:11:31 <roconnor> Saizan: that requires writing an expression with the same type as thing thing you are trying to type, which can be diffcult, and I'm not convinced it is always possible.  But it is probably always possible.
09:11:42 <Cale> Actually, I never use -Wall
09:11:56 <Peaker> Cale: Non-exhaustive pattern matches are a horrible thing to catch at runtime, IMO
09:12:16 <Cale> Well, sure, but they're something I essentially just never write.
09:12:16 <hatds> sometimes your function is supposed to be partial :)
09:12:22 <Peaker> Cale: Fixing warnings costs nearly nothing, not fixing them has a non-negligent chance of being an actual bug
09:12:53 <Peaker> Cale: If you're careful enough, of course you don't need the warnings. -Wall frees you from having to be careful about several things
09:13:12 <quicksilver> -Wall gives warnings about various kinds of perfectly valid code
09:13:13 <Saizan> roconnor: it's generally easy if you define an appropriately typed function using undefined as body
09:13:15 <quicksilver> I do not find it useful.
09:13:17 <Cale> I suppose. But quite often I actually don't want to write type signatures on things.
09:13:36 <Peaker> quicksilver: type signatures on top-level names are nice, IMO,  what else does it have that shows up often?
09:13:37 <roconnor> Saizan: ya
09:13:45 <quicksilver> -Wall frees you from having valuable free time, but forcing you to spend time fixing things that don't need fixing.
09:13:46 <Cale> (In the case that they are noisy and unhelpful)
09:13:59 <MyCatVerbs> Cale: I don't know about you, but without at least type declarations, I sometimes forget what entire chunks of code were for. ;)
09:14:10 <quicksilver> Peaker: type-level signatures on top-level names, incomplete patterns, I don't remember what else.
09:14:14 <Peaker> quicksilver: I think that it is a negligible proportion of the time you spend coding it..
09:14:21 <quicksilver> Peaker: I tried it once, thought "This is stupid" and have never used it since.
09:14:23 <Peaker> quicksilver: incomplete patterns are never bugs?
09:14:26 <Cale> MyCatVerbs: For some types of code they are very useful, for other types of code they are not.
09:14:29 <Peaker> quicksilver: (in your code/
09:14:30 <quicksilver> Peaker: all kinds of things are bugs.
09:14:38 <quicksilver> Peaker: when I write an incomplete pattern, I know what I have done.
09:14:40 <Saizan> warning about name shadowing gets annoying most of the time, it should only warn about a really small surrounding scope
09:14:48 <quicksilver> it is no more likely to be a bug than any other thing I write.
09:15:38 <Peaker> quicksilver: I find it hard to believe that inexhaustive-pattern-matches are no more likely to be bugs than other things
09:15:39 <Cale> That's the nice thing about algebraic types, it's really hard to write incomplete pattern matches in the first place.
09:15:44 <quicksilver> yeah, the shadowing warning is another unhelpful one.
09:16:03 <Peaker> quicksilver: When it is unambiguous (type-wise), sure. When its ambiguous? It's saved me before
09:16:19 <hatds> stuff about patterns (overlapping, non-exhaustive) would be more useful to be told about while you are in the text editor
09:16:38 <Cale> hatds: I agree.
09:16:40 <Peaker> hatds: in a non-textual code editor it would be much easier :)
09:16:54 <TonyTheTiger> how can I do the same thing as zip but on a list using list comprehension?
09:16:58 <Peaker> Indeed a non-textual code editor would make most of these points completely moot, and you'd get type-inference "on-the-fly"
09:17:04 <Cale> The compiler should certainly be able to tell me, on command, when pattern matches are incomplete.
09:17:05 <quicksilver> Peaker: almost every haskell program I have ever written has at least one correct inexhaustive pattern
09:17:12 <Berengal> TonyTheTiger: Explain
09:17:17 <Saizan> it's easy in a textual editor too, see eclipse and the other ides :)
09:17:23 <quicksilver> Peaker: adding a warning to all that code would be a misfeature.
09:17:23 <Cale> quicksilver: Which wasn't a call to a library function?
09:17:29 <MyCatVerbs> Cale: the other nice thing about algebraic types is that it's always possible to detect incomplete pattern matches when you do make 'em. ;)
09:17:33 <quicksilver> Cale: some are, some aren't.
09:17:37 <Peaker> quicksilver: I dislike that in programs, I try to refactor it into not having the impossible constructors in the first place.. do you have examples?
09:17:39 <roconnor> TonyTheTiger: there is an extension called parallel list comprehensions
09:17:46 <TonyTheTiger> Berengal: e.g [1,2,3] [4,5,6] becomes [1,4,2,5,3,6]
09:17:54 <Peaker> quicksilver: is it really that painful to explicitly handle the   _ -> ... case?
09:17:55 <Cale> MyCatVerbs: Of course, once you add guards into the mix, things are more complicated
09:17:56 <quicksilver> Peaker: suppose you make a pass over an AST which removes variables.
09:17:58 <roconnor> > [(x,y) | x <- [1..] | y <- [2,4..10]]
09:17:59 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10)]
09:18:15 <quicksilver> Peaker: after that you have an AST which never uses the 'Var' constructor.
09:18:21 <MyCatVerbs> Cale: you would bring Turing-complete predicates into it, wouldn't you? Feh.
09:18:26 <quicksilver> when you operate on that, you don't want ot handly the useless case.
09:18:49 <quicksilver> but it's a huge amount of boilerplate to define a fresh data type for that
09:18:54 <Peaker> quicksilver: Why not put it under an anything-else -> error "Broken assumptions"?
09:18:59 <quicksilver> especially if there are multiple such intermediate steps.
09:19:06 <quicksilver> Peaker: because the compiler does that for me, for free!
09:19:09 <Saizan> but then you don't get to write amusing errors like "the impossible happened!"
09:19:19 <quicksilver> with a _ -> error "inexhaustive patterns"
09:19:20 <Berengal> > concatMap (\(a,b) -> [a,b]) . zip $ [1,2,3] [4,5,6]
09:19:20 <hatds> lol
09:19:21 <lambdabot>   Couldn't match expected type `[(t, t)]'
09:19:22 <Peaker> quicksilver: its not free -- it costs you missing out on the cases where you did forget
09:19:29 <quicksilver> which, IIRC, is actually *better* than an error message I can write
09:19:37 <quicksilver> since it contains a function name and even line number?
09:19:40 <Berengal> > concatMap (\(a,b) -> [a,b]) . zip [1,2,3] $ [4,5,6]
09:19:42 <lambdabot>   [1,4,2,5,3,6]
09:19:42 <Saizan> yup
09:19:51 <Saizan> even the column!
09:19:55 * quicksilver nods
09:20:00 <Peaker> hmm.. there should be an "error" that does that too
09:20:09 <hatds> yea, that's what I've been saying
09:20:20 <quicksilver> that would certainly help.
09:20:27 <Berengal> How come I always get the first expression given to lambdabot wrong when I'm in a public channel?
09:20:32 <quicksilver> But I have a labouring suspicion you're solving a non-problem :)
09:20:56 <quicksilver> because I honestly can't think of a single case where the non-exhaustive pattern match warning has helped me :)
09:20:59 <Peaker> quicksilver: Its not a problem for me most of the time, because I use -Werror -Wall anyhow.. But I do forget to enable them both on new files I compile sometimes
09:21:00 <hatds> there is an "assert" function for ghc which will spew out the line number
09:21:02 <quicksilver> not even in ML, where it's on by default IIRC.
09:21:09 <TonyTheTiger> Berengal: What you wrote is that usin a list comprehension?
09:21:52 <Peaker> quicksilver: well, I heard once that "recursion is the assembly of FP" -- and in a sense I think pattern-matching is too.  I don't find myself using it all that often. When I did use it more, it did catch bugs
09:21:55 <Berengal> TonyTheTiger: No, I don't think it's possible in just a list comprehension...
09:22:28 <TonyTheTiger> Berengal: Are you sure? my practice exam asks me to do it using a list comprehension
09:22:48 <Cale> Berengal: I don't understand that question...
09:23:00 <Cale> Berengal: Oh, I missed the word "wrong"
09:23:44 <Jedai> TonyTheTiger: That would be really weird and stupid
09:24:00 <Berengal> TonyTheTiger: A list comprehension always constructs single elements of a list. You want to create two and two elements, which means you need to do something else
09:24:10 <Cale> huh?
09:24:32 <Jedai> TonyTheTiger: I think the best way is probably to use explicit recursion in this case, it's probably the clearest you can do :
09:24:34 <Cale> If you're doing a concatMap anyway, you might as well write a list comprehension
09:24:38 <quicksilver> Peaker: sure. You use pattern matching for the basic operations which apply to a type, normaly.
09:24:51 <endojelly> :t mapAndUnzip
09:24:52 <lambdabot> Not in scope: `mapAndUnzip'
09:24:57 <endojelly> :t unzipWith
09:24:58 <lambdabot> Not in scope: `unzipWith'
09:24:59 <Berengal> > [[a,b] | a <- [1,2,3] | b <- [4,5,6]]
09:25:01 <lambdabot>   [[1,4],[2,5],[3,6]]
09:25:06 <Saizan> > [x | (a,b) <- zip [1..3] [4..6], x <- [a,b]]
09:25:07 <lambdabot>   [1,4,2,5,3,6]
09:25:09 <Jedai> interleave (x:xs) (y:ys) = x : y : interleave xs ys
09:25:09 <Jedai> interleave _ _ = []
09:25:15 <Saizan> not that hard :)
09:25:21 <vixey> Saizan very nice
09:25:29 <quicksilver> Peaker: then you write more sophisticated claculations in terms of those simple ones.
09:25:40 <hatds> matching on a tuple or a product type and binding each component to a variable is not really pattern matching
09:25:42 <Cale> Saizan wrote the code I was about to write too :)
09:25:43 <Jedai> Saizan: Pretty nice :)
09:25:49 <Berengal> Saizan: I keep forgetting that list comprehensions are sugar for the list monad... very nice
09:25:55 <roconnor> > tan (10^100) :: CReal
09:25:56 <lambdabot>   0.4012319619908143541857543436532949583239
09:25:58 * vixey didn't figure out what Saizan wrote
09:26:01 <hatds> well it is, but it is rare that matching will fail
09:26:03 <quicksilver> Peaker: that means you don't pattern match very often, which makes it even more likely you don't make non-exhaustive pattern errors :)
09:26:11 <roconnor> > tan (10^100)
09:26:11 <lambdabot>   -3.302509482989562e-2
09:26:55 <ziman> > (sin (10^100) :: Double, sin (10^100) :: CReal)
09:26:56 <lambdabot>   (3.30071000245921e-2,-0.3723761236612766882620866955531642957197)
09:28:09 <Cale> http://www.smbc-comics.com/ -- ahaha
09:28:49 <TonyTheTiger> Berengal: turns out this was the answer, I understand it (somewhat) but didnt know haskell could use comprehensions like this
09:28:50 <TonyTheTiger> concat [[x,y]|(x,y) <- zip xs ys]
09:29:23 <Cale> TonyTheTiger: Well, you can even move the concat inside the comprehension as Saizan showed, by adding another generator
09:29:24 <Berengal> TonyTheTiger: That was basically what my concatMap did above. Also, Saizan did it using just a comprehension
09:29:26 <Jedai> TonyTheTiger: There is a concat, so it's not exactly a "pure" list comprehension
09:29:38 <Cale> [z | (x,y) <- zip xs ys, z <- [x,y]]
09:30:13 <TonyTheTiger> ohh sorry must have missed the answers posted above
09:30:21 <Berengal> > do (a,b) <- zip [1,2,3] [4,5,6]; x <- [a,b]; return x
09:30:22 <lambdabot>   [1,4,2,5,3,6]
09:30:30 <TonyTheTiger> [z | (x,y) <- zip xs ys, z <- [x,y]] <- this is a "pure" list comprehension then?
09:30:31 <Jedai> TonyTheTiger: there is a zip too... I would argue that the question is pretty bad, it should not say that you have to use list comprehension
09:31:32 <Jedai> TonyTheTiger: more or less pure, there is a zip inside, but it could be argued that the outermost expression is a list comprehension
09:31:38 <Cale> I think it's a good exercise in making use of list comprehensions
09:32:01 <ziman> how efficient is concat [[x,y]
09:32:03 <Berengal> List comprehensions are good for understanding monads, but not much else
09:32:05 <ziman> how efficient is concat [[x,y] | ... ?
09:32:09 <Berengal> In my opinion, of course
09:32:14 <Cale> ziman: Just as efficient as the other way
09:32:21 <lilac> > (\xs ys -> [if n `mod` 2 == 0 then xs !! fromIntegral (n `div` 2) else ys !! fromIntegral (n `div` 2) | n <- [0..min (genericLength xs) (genericLength ys :: Natural) * 2 - 1]]) [1,2,3] [4,5,6]
09:32:22 <lambdabot>   [1,4,2,5,3,6]
09:32:25 <lilac> there we go
09:32:35 <Jedai> Cale: Right, but in this case the answer should be entirely formulated in term of list comprehension
09:32:55 <ziman> Cale, "the other way" being your [z | ...] or the explicit recursive version?
09:33:10 <Jedai> lilac: Wow !! ^^
09:33:30 <qaz> how would you handle timeouts in Haskell? like the Erlang runtime has built-in support for handling stuff that takes to long
09:33:32 <lilac> > (\xs ys -> [[xs !! fromIntegral (n `div` 2), ys !! fromIntegral (n `div` 2)] !! fromIntegral (n `mod` 2) | n <- [0..min (genericLength xs) (genericLength ys :: Natural) * 2 - 1]]) [1,2,3] [4,5,6]
09:33:33 <lambdabot>   [1,4,2,5,3,6]
09:33:36 <lilac> better :)
09:33:41 <ziman> > zipWith id (cycle [const, const id]) [1, 2, 3] [4, 5, 6]
09:33:42 <lambdabot>   Couldn't match expected type `[t1] -> t'
09:33:47 <Jedai> Cale: I think it's probably less efficient than the explicit recursive version, no ? And less clear too
09:34:43 <ziman> > (\xs ys -> zipWith id (cycle [uncurry const, uncurry $ const id]) (zip xs ys)) [1,2,3] [4,5,6]
09:34:45 <lambdabot>   [1,5,3]
09:34:46 <Berengal> > zip [1,2,3] [4,5,6] >>= (\(a,b) -> [a,b])
09:34:48 <lambdabot>   [1,4,2,5,3,6]
09:34:53 <ziman> ah. :)
09:35:17 <Jedai> > let (x:xs) /\/ (y:ys) = x : y : (xs /\/ ys); _ /\/ _ = [] in [1..4] /\/ [5..8]
09:35:19 <lambdabot>   [1,5,2,6,3,7,4,8]
09:35:26 <lilac> > [0 .. genericLength [0..] :: Natural]
09:35:31 <lambdabot>   * Exception: stack overflow
09:35:33 <lilac> :(
09:35:41 <lilac> broken enumFrom for Natural?
09:36:09 <roconnor> @src genericLength
09:36:12 <lambdabot> genericLength []    = 0
09:36:14 <lambdabot> genericLength (_:l) = 1 + genericLength l
09:36:32 <lilac> > enumFromTo 0 (fix (1+)) :: [Natural]
09:36:34 <lambdabot>   * Exception: stack overflow
09:36:43 <qaz> hmm the whole Maybe and Monad stuff works a lot neater with a language that has pattenrmatching right?
09:36:47 <lilac> > min (fix (1+)) 42 :: Natural
09:36:48 <lambdabot>   42
09:36:48 <roconnor> lilac: seems like it
09:36:57 <qaz> my erlang-Maybe was a lot nicer than my Clojure one
09:37:15 <lilac> hmm. that's unfortunate. so my solution is incorrect by extension then ;-(
09:37:43 <Jedai> qaz: pzttern matching is nice for a lot of things, though you don't need it to make Maybe nice to use, maybe is enough
09:37:49 <Jedai> @type maybe
09:37:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:38:12 <lilac> Jedai: "pzttern": pattern match failure
09:38:20 <Twey> Hahaha
09:39:13 <vixey> > enumFromTo 0 infinity
09:39:14 <lambdabot>   * Exception: stack overflow
09:39:22 <vixey> > enumFrom
09:39:23 <lambdabot>       Overlapping instances for Show (a -> [a])
09:39:24 <lambdabot>        arising from a use of ...
09:39:26 <vixey> > enumFrom :: [Natural]
09:39:28 <lambdabot>   Couldn't match expected type `[Natural]'
09:39:32 <Jedai> > head (enumFrom 0)
09:39:34 <lambdabot>   0
09:39:42 <Jedai> > head (enumFrom 0 :: [Natural])
09:39:42 <roconnor> lilac: enumFromTo x y   =  map toEnum [fromEnum x .. fromEnum y]
09:39:44 <lambdabot>   0
09:39:50 <roconnor> lilac: those defaults really need to be overridden
09:40:16 <Jedai> > genericLength (enumFrom 0) :: Natural > 5
09:40:17 <lambdabot>   Only unit numeric type pattern is valid
09:40:20 <roconnor> -- NOTE: these default methods only make sense for types
09:40:22 <roconnor> --   that map injectively into Int using fromEnum
09:40:24 <Jedai> > (genericLength (enumFrom 0) :: Natural) > 5
09:40:26 <lambdabot>   True
09:40:30 <roconnor> which is not the case for Nat
09:41:09 <vixey> qaz: Can't you add pattern matching to clojure?
09:43:07 <vixey> > (genericLength (enumFrom 0) :: Natural)
09:43:11 <lambdabot>   * Exception: stack overflow
09:43:43 <Jedai> vixey: This one makes sense
09:43:45 <vixey> > let _ + _ = error "stack overflow" in    1 + 1
09:43:47 <lambdabot>   * Exception: stack overflow
09:44:42 <Eelis> the lhs2tex manual doesn't mention coloured syntax highlighting. is this not supported?
09:44:46 <qaz> lol dont realize how good monads are until you try a functional language without them :P
09:44:57 <roconnor> lilac: source: http://hackage.haskell.org/packages/archive/numbers/2008.4.20.1/doc/html/src/Data-Number-Natural.html
09:45:14 <roconnor> lilac: it should be easy to patch.
09:45:42 <roconnor> lilac: then you can upload a new version to hackage and Cale can recompile lambdabot.
09:45:51 <roconnor> lilac: oh an then tell augustss_ too
09:47:43 <Eelis> can hscolour be used with lhs2tex, perhaps?
09:47:55 <kyevan> BEEP
09:50:06 <malcolmw> Eelis: my guess would be that hscolour and lhs2tex are either/or.  But you could try it and see what happens (both ways round)
09:50:44 <Eelis> malcolmw: well, i run lhs2tex on literate haskell, so i'm not sure how i could squeeze hscolour in there. but i'll have a look
09:50:51 <vixey> http://www.loper-os.org/?p=41
09:51:03 <vixey> it says 'can we instead build on the idea that a computer program is a mathematical object that can be understood through logic'
09:51:13 * kyevan glares at ghc
09:51:24 <kyevan> manpages, damnit!
09:52:30 <Apocalisp> > length $ tails [1..26] >>= inits
09:52:32 <lambdabot>   378
09:56:13 <malcolmw> Eelis: looking at the lhs2tex manual, I see that you can substitute different formatting for almost any element, e.g. keyword, conid, pragma
09:56:24 <bremner> kyevan: man pages exist, at least on Debian.
09:56:43 <malcolmw> Eelis: see Table 3 on page 36, wrt the %subst directive
09:56:46 <kyevan> Not here, though... >_>
09:57:20 <bremner> complain to your linux distro, unless your linux distro is VMS or Windows or something...
09:57:38 <kyevan> Somehow I doubt Apple cares :P
09:57:44 <bremner> or you didn't install the distro ghc, which I guess is pretty likely
09:57:54 <bremner> ah, VMS with bling :-)
09:58:06 <kyevan> Well. I suppose macports is the pokereyd person, not Apple.
09:58:23 * adamvo wonders where the Functor ((,) t) instance has gone
09:58:24 <roconnor> vixey: I always thought the future of computing was biology, not logic;  I will now read lamport's article.
09:59:01 <vixey> roconnor: well some sya that logic is completely based on biology
09:59:02 <MyCatVerbs> adamvo: Control.Monad.Instances.
09:59:12 <Eelis> malcolmw: yes, but i'm reluctant to take that route. i also think there's more to syntax highlighting than just replacing keywords. i would also want highlighting for things like literals, punctuation, and different kinds of identifiers (ones that start with a capital, and ones that don't, for example)
09:59:14 <kyevan> Also, Debian creates their own manpages if upstream lacks them... :J
09:59:36 <adamvo> MyCatVerbs: thanks
09:59:44 <bremner> kyevan: sure, but they are always freely usable
09:59:58 <malcolmw> Eelis: well, that is exactly the categorisation that lhs2tex (and hscolour) give you
10:00:35 <Eelis> malcolmw: oh, i see. interesting
10:00:51 <kyevan> Yeah, Debian's manpages are Debian-made :J
10:00:55 <roconnor> vixey: but I mean, I expect computer programs will be "grown" using genetic algorithms and in an "environment" of test harnesses that will mould the program into the desired functionality.
10:01:10 <MyCatVerbs> roconnor: oi, genetic *programming*. :)
10:01:22 <qaz> how would you handle timeouts in Haskell? like the Erlang runtime has built-in support for handling stuff that takes to long
10:01:25 <malcolmw> Eelis: oh, actually, now I look closely at the lhs2tex table, it does look more specific - categorisation plus more info, like the first character of a conid (upper-case identifier)
10:01:34 <vixey> roconnor, hat sounds cool :) I think it's one of many paradaigms
10:01:36 <kyevan> So, my glaring still stands, since the main GHC distribution lacks them, so...
10:01:38 <MyCatVerbs> roconnor: GAs are a slightly wider field, including some strictly less powerful things too. :)
10:01:54 <Eelis> malcolmw: i'll certainly play around with those, then. thanks!
10:02:01 <jmcarthur> qaz, depends what you are timing. pure computation? IO?
10:02:11 <jmcarthur> any way you look at it, you need IO to get the times
10:02:18 <roconnor> MyCatVerbs: fair
10:02:45 <jmcarthur> but if it's pure, it helps to have some abstraction that allows you to pause and resume the computation so you can go to IO to check the time and stuff
10:02:56 <malcolmw> Eelis: anyway, the default definitions are in lhs2TeX.fmt, so you could just try adding some colours in there
10:02:58 <jmcarthur> or perhaps use threads to do something similar
10:03:24 <MyCatVerbs> qaz: there's a Hackage package for things like this (attempting possibly-nonterminating pure computations with timeouts and other such safeties, all in IO of course), but I can't remember what it's called.
10:04:05 <MyCatVerbs> qaz: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ChasingBottoms
10:06:48 <MyCatVerbs> qaz: I suppose it's overkill for the purposes of just trying to evaluate things with timeouts, but still. It might come in handy to have the extra firepower if you want to go debugging really huge expressions =)
10:09:00 <cedricshock> I was looking at a simple http server, and it inspired a question about IO. Let's say I have an interactive process that does something like looking up a reverse DNS request to write to the log. I want to serve the page as fast as possible, but don't want to do the DNS request again to put in the data given to the page handler, which is pure.
10:10:26 <cedricshock> How could I accomplish this? forkIO the DNS request (and the log writing) with an STM variable that gets passed into the page handler? Is it impossible for the page handler to be pure and lazy in IO (my guess)?
10:12:50 <mmorrow> qaz: System.Timeout
10:13:22 <kyevan> Hmm. Has anyone used TextWrangler on the mac with Haskell?
10:13:36 <MyCatVerbs> cedricshock: the easy way is to just forkIO the whole (lookupDNS >>= logToDisk) action.
10:13:42 <kyevan> I'm trying to get it to let me easily load the current file in ghci >_>
10:14:06 <cedricshock> When you bind a in f :: a -> b, does the sequence generating a necessarily get executed. I don't think so, so then the pure f a->b can have some wonderful uglies in its a (which may not be an a yet). Then it would need to be guaranteed that the DNS lookup would succeed eventually or never terminate, which would just mean the type for it would need to be some kind of Maybe.
10:14:40 <MyCatVerbs> cedricshock: personally, I'd write one thread permanently listened on a Chan String (or Chan ByteString) and wrote whatever got written to that channel to disk, and then logToDisk s = putChan toDiskLogger s;
10:15:16 <cedricshock> MyCatVerbs: Yeah, but can I lazily get the dns lookup out of lookupDNS into the page request info for the handler without waiting on it succeeding so it only waits on handlers that need it?
10:15:19 <MyCatVerbs> cedricshock: just do DNS lookup in the IO monad and multithread it. This is not a good place to use lazy IO.
10:16:26 <cedricshock> No. I want the DNS lookup to be eager, but share the lookup with the page handler that will only wait for it to be done when it needs it.
10:16:35 <MyCatVerbs> cedricshock: you could do let dnsresult = (unsafePerformIO lookupDNS), which would then defer the DNS lookup until it's needed, but I suspect you wouldn't gain anything interesting by doing that.
10:17:32 <MyCatVerbs> Ah, right. Hrmn. I suspect that the best answer is to never write page handlers that make use of reverse DNS. (They'll always have crap latency anyway, no matter what the environment or how they're written.)
10:17:45 <MyCatVerbs> If you really did want to do that, just memoize lookupDNS.
10:17:59 <lysgaard> Anyone have a good example of how to make the (+) function work for my datatype. Trying to make a algebraic math datatype/class?
10:18:11 <MyCatVerbs> lysgaard: hpaste what you have so far, please?
10:18:16 <MyCatVerbs> @where hpaste
10:18:16 <lambdabot> http://hpaste.org/
10:18:54 <cedricshock> lysguard: instance (The class plus is defined in) (Your class) where:
10:19:04 <mmorrow> cedricshock: um, i don't understand your question. so you want to (do dns <- lookupDNS; send (reponse dns); log dns; return ()) ?
10:19:57 <MyCatVerbs> mmorrow: I think he wants to always use lookupDNS in the logging function, and only sometimes use lookupDNS in the page handler; and if it is used in both, then only make one DNS request.
10:20:27 <lysgaard> MyCatVerbs: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4997#a4997
10:20:29 <mmorrow> it's only ever used once in that pseudo-code
10:20:34 <MyCatVerbs> For which the easiest solution is to write a caching version of lookupDNS. But either way, making your pages depend on reverse DNS will suck for performance.
10:20:49 <mmorrow> \req -> do dns <- lookupDNS req; send (reponse dns); log dns; return ()
10:21:12 <mmorrow> lookupDNS doesn't have to actually do it, it can be an arbitrary function
10:21:36 <MyCatVerbs> lysgaard: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4997#a4998
10:23:15 <skorpan> what's the haddock syntax for code blocks in comments?
10:23:19 <lysgaard> MyCatVerbs: Ah! Of course, thanks :)
10:24:25 <doserj> skorpan: http://www.haskell.org/haddock/doc/html/ch03s08.html#id289905
10:24:44 <skorpan> thanks!
10:24:44 <lysgaard> MyCatVerbs: Coming from the imperative world haskell is so elegant. Totally different way to think
10:24:57 <cedricshock> More genrally: I want to share a result of IO() with two functions, without the sequence to generate it necessarily occuring unless one of the two needs it. I still want to restrict the type of the functions it's used in as much as possible so there aren't arbitrary side-effects. In my specific example one of the two threads is always going to use it.
10:25:16 <MyCatVerbs> lysgaard: you will most likely end up needing to add Mul, Add, etc, to Algebra, in order to represent things like Variables being added to one another. :)
10:25:53 <MyCatVerbs> cedricshock: same way you'd achieve that in imperative-land. (Not a coincidence, since you're working in IO.) Memoize the IO action.
10:26:48 <cedricshock> And then it doesn't get done until either thread has output dependent on it. That's too simple and beautiful.
10:26:57 <lysgaard> MyCatVerbs: Yeah, i realised that now, how do i proceed?
10:27:14 <mmorrow> cedricshock: ok, so if one always needs it, then just generate it once, and pass it to both. if one doesn't need it, it just ignores it.
10:27:34 <lysgaard> MyCatVerbs: Eg if i add a number and a variable, will i need a new datatype?
10:27:46 <MyCatVerbs> lysgaard: if you're attempting to do what I think you are attempting to do, add a constructor to represent addition, another one to represent multiplication...
10:28:01 <MyCatVerbs> lysgaard: no, just more alternative constructors for the Algebra type.
10:28:16 <lysgaard> MyCatVerbs: Oh, I'll try it out ;)
10:29:26 <mmorrow> cedricshock: or something like: type MaybeINeedIt req res = req -> Either (DNS -> res) res
10:30:04 <cedricshock> So something like STM is only ever needed when the method of definition is decided upon in one of the threads, like threads competing to find minimas but sharing their best minimas for heuristics.
10:30:45 <mmorrow> cedricshock: i don't see how STM fits in here
10:30:48 <Cale> qaz: See also http://www.haskell.org/haskellwiki/Timing_out_computations
10:31:10 <kyevan> UGHAREWAREAARAYHWATWER
10:31:17 <kyevan> KYEVAN SMASH
10:31:34 <kyevan> WHY do all text editors suck so much!?
10:31:35 <cedricshock> mmorrow: Yeah, STM is overkill.
10:31:37 <Cale> Whaaaat
10:31:44 <zachk> kyevan: are you sure you arent Tarzan?
10:31:49 <bremner> kyevan: we already had this discussion
10:32:08 <kyevan> bremner: It was rhetorical.
10:32:17 <kyevan> I'm just expressing frustration, not seeking answers :J
10:32:31 <Cale> vim is okay
10:32:36 <TomMD> M-c Its because you're used to solutions with more flexibility perhaps?  Solutions like MS Pen and Paper?  C-x-s
10:32:55 <zachk> kyevan: pick vim or bigeemacs
10:33:12 <kyevan> Cale: Vim is too cryptic for my tastes...
10:33:23 <kyevan> And emacs is moreso :P
10:33:31 <zachk> kyevan: try nano then
10:33:37 <zachk> or pico
10:33:44 <kyevan> Nano doesn't do what I need >_>
10:33:49 <TomMD> kyevan: I've used vim for many years and probably don't know more than 5 commands - not a good thing, but it doesn't have to be cryptic if you don't let it.
10:33:50 <thomastc> what do you need?
10:34:16 <zachk> kyevan: kevin i use vim and i know like 3 commands
10:34:24 <kyevan> Well. What I'm currently using is textwrangler, and it works, except there's no way to run a random unix command on the thing.
10:34:34 <Apocalisp> vim is not cryptic at all once you get past the idea that edit mode is not the default.
10:34:40 <kyevan> zachk: I knoawrgh can I finish my thinkings? >_>
10:34:41 <MyCatVerbs> Cale: vim's syntax highlighting sucks, for one thing.
10:34:57 <MyCatVerbs> Cale: most of the rest of it is good, though. :)
10:35:11 <Cale> It doesn't suck enough to bug me.
10:35:11 <Philonous> :t cond
10:35:12 <qaz> whats that word for eterniy_machine?
10:35:13 <lambdabot> Not in scope: `cond'
10:35:14 <kyevan> And having to go to terminal, navigate to the right folder, and run ghci with the right file manually is a pain in the arse
10:35:19 <qaz> ah wait, perpetual?
10:35:19 <MyCatVerbs> And not many text editors have interestingly better highlighting than vim.
10:35:23 <Twey> Apocalisp: Which of course makes perfect sense in an editor.
10:35:37 <cedricshock> I think memoizing it would actually do the following: Open the DNS socket, wait for it to open, Send the request, (not try to read it until the letted variable is read)
10:35:45 <Cale> kyevan: You should always have a terminal window open with ghci already ;)
10:35:52 <roderyk> does anyone have some code/links demonstrating gtk2hs and TreeModel. I have code working based on the gtk demos, but I can't successfully update the Data.Tree stored as my model after the initial init.
10:36:03 <MyCatVerbs> Cale: the default mode for Haskell curls up into a ball and cries like a little baby if you nest {- -} comments, and occasionally it ditzes out over pathentheses. Otherwise fine.
10:36:16 <kyevan> *sigh* I *do*
10:36:16 <TomMD> Good work style: XMonad with 9 desktops and 2-8 terminals open on each desktop.
10:36:28 <thomastc> I like kate for these kind of things
10:36:31 <Cale> Well, yeah, anything which uses regular expressions to deal with comments will have trouble.
10:36:33 <kyevan> But I don't want to mess with that session, to load the other thing...
10:36:42 <thomastc> you can get a terminal window right inside your editor
10:36:48 <thomastc> it highlights and does regex search
10:36:51 <thomastc> and indents
10:37:11 <kyevan> thedward: Yeah, but I don't want to install KDE just to use a text editor, and Apple's x11 implementation sucks horribly anyway.
10:37:20 <Cale> Haskell's comments can't be matched by regular expressions, because they rely on nesting depth.
10:37:32 <Apocalisp> Try yi
10:38:00 <kyevan> No.
10:38:10 <kyevan> We've been through this before >_>
10:38:24 <MyCatVerbs> Cale: and yet it gets parentheses matching (mostly) right. :/
10:38:28 <kyevan> I was just expressing frustration, anyway, and I've already said that, so <_<
10:38:36 <Apocalisp> Well, maybe write us all a good text editor then.
10:39:02 <kyevan> Apocalisp: >_> I'm not talented enough.
10:39:19 <TomMD> lyatefgg == Learn you a text editor for great good
10:39:29 <Apocalisp> Nobody's talented enough to make a text editor to satisfy everybody.
10:40:59 <Berengal> We need a text editor everyone's talented enough to make good enough to satisfy themselves
10:41:17 <Berengal> Problem solved
10:41:54 <TomMD> What if we overestimate the minimum talent of a potential user?
10:42:20 <Philonous> Berengal: You mean like Emacs, but with VBS instead of Lisp?
10:42:23 <Berengal> TomMD: We redefine them as users
10:42:29 <Berengal> lusers*
10:42:30 <Berengal> :/
10:42:54 <Berengal> Philonous: No, I mean like Word but with Lisp instead of VBS
10:43:02 <Berengal> By which I mean emacs
10:43:29 * Berengal feels he isn't making much sense
10:45:09 <copumpki> :o
10:45:42 <endojelly> :t runRWS
10:45:43 <lambdabot> forall r w s a. RWS r w s a -> r -> s -> (a, s, w)
10:45:58 <opqdonut> :kind RWST
10:46:11 <vixey> :k RWST
10:46:13 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:46:54 <User2185> http://www.Marie-gets-Deflowered.com/?id=576098f2
10:47:14 <copumpki> uh
10:47:49 <lukeo05> Does anyone know any good pieces for learning about proving properties of haskell programs with structural induction?
10:49:05 <Twey> lukeo05: I think SICP covers it
10:49:26 <Twey> The Haskell Road to Logic, Maths, and Programming does too
10:50:08 <vixey> what does it cover?
10:50:40 <Twey> vixey: Inductive proofs
10:50:44 * copumpki is frustrated at his lack of organization
10:51:02 <vixey> Twey, but I mean what does it prove
10:51:02 <vixey> ?
10:51:21 <Twey> Correctness, I suppose.  For a certain value of correctness.
10:51:41 <lukeo05> Ah, thank you Twey.
10:52:03 <vixey> :S
10:52:08 <vixey> but like of what
10:54:05 <Taejo> why are Haskeller's constantly inventing their own `data Failable a = Success a | Failure b`? What's wrong with Either String (or a type synonym for it)?
10:54:22 <pumpkin> Left and Right aren't particularly descriptive
10:54:27 <Taejo> *Haskellers
10:54:34 <Cale> I like Either
10:54:41 <pumpkin> apart from historical prejudice, nothing in "left" makes it inherently less good than "right" :P
10:54:55 <pumpkin> I propose data Either a b = Sinister a | Dexter b
10:55:03 <Twey> Ooh, I like that
10:55:05 <Cale> One good reason I can imagine is that Either has a stupid instance of Monad in mtl
10:55:08 <Twey> It has class
10:55:09 <Taejo> pumpkin: Right is the right constructor, Left is the wrong one
10:55:22 <pumpkin> Taejo: if you need a mnemonic, that might be a bad sign :P
10:55:23 <Twey> We need more Latin in our language
10:55:31 <Twey> Haskelligata
10:55:34 <pumpkin> :P
10:55:42 * pumpkin is a leftie
10:56:21 <Taejo> pumpkin: it's not that I think Either is good... I just resent having to write my own functor instances, versions of fromRight, etc. when the stdlibs have perfectly good ones
10:56:30 <pumpkin> yeah, that is annoying
10:56:32 <mmorrow> either Right Left
10:56:57 <Taejo> mmorrow: if that's what I think it is, then you are evil
10:57:03 <Taejo> :t either
10:57:05 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
10:57:06 <pumpkin> Taejo: but Either feels more general than error conditions, and having the monad instance make fail = left is ugly
10:57:08 <Cale> data Either a b =  a |  b
10:57:13 <mmorrow> Taejo: heh
10:57:23 <pumpkin> Cale: is that allowed?
10:57:25 <pumpkin> that'd be cute
10:57:38 <mmorrow> data Either a b = (:) a | (:) b
10:57:48 <Cale> yeah, probably needs the :
10:58:05 <pumpkin> data Either a b =  a
10:58:23 <mmorrow> , isSymbol ''
10:58:23 <pumpkin> blah, damn enter key :P
10:58:23 <Asztal> operator constructors don't have to be binary?
10:58:24 <lunabot>  False
10:58:25 <pumpkin> or  b
10:58:32 <mmorrow> , isAlpha ''
10:58:33 <lunabot>  True
10:58:38 <mmorrow> , isUpper ''
10:58:39 <lunabot>  False
10:58:42 <pumpkin> that's lame
10:58:48 <mmorrow> heh
10:58:57 <pumpkin> are there any CJK characters that are uppercase?
10:59:13 <pumpkin> (CJKV)
10:59:15 <Taejo> pumpkin: the CJK "copies" of latin letters?
10:59:26 <bd_> uppercase isn't really meaningful for CJK
10:59:27 <pumpkin> I guess :)
10:59:34 <Cale> I don't think so, but I think katakana ought to be in terms of GHC's rules about constructors.
10:59:47 <Taejo> pumpkin: if you include Vietnamese, then every uppercase vietnamese letter :)
11:00:12 <pumpkin> lol
11:00:18 <pumpkin> by the V, I meant han nom
11:00:20 <Cale> , isUpper ''
11:00:22 <lunabot>  True
11:00:31 <pumpkin> with the appropriate diacritics on it
11:00:33 <bd_> Things are hard to read if you put them in the wrong kind of kana :) It's not really like english where you can change the case of the first letter with no problem...
11:00:53 <Cale> bd_: You often see signs where katakana is used for emphasis.
11:01:06 <pumpkin> Taejo: http://en.wikipedia.org/wiki/Ch_Nm
11:01:25 <Taejo> how about making the circled Han characters uppercase?
11:01:33 <bd_> Cale: I suppose, but in computing a lot of your terms are going to be katakana /anyway/...
11:01:34 <pumpkin> a significant portion of the han-based characters in unicode are from vietnam
11:01:35 <Taejo> for the purpose of Haskell identifiers
11:01:56 <pumpkin> Taejo: that'd be kind of ugly :/
11:02:04 <Cale> bd_: I suppose that is true.
11:02:27 <pumpkin> we should sample unicode space and count what percentage of isAlpha characters satisfies isUpper
11:03:02 <pumpkin> > length (filter isAlpha [minBound..maxBound] :: [Char])
11:03:04 <lambdabot>   90547
11:03:10 <pumpkin> > length (filter isUpper [minBound..maxBound] :: [Char])
11:03:12 <lambdabot>   1221
11:03:17 <pumpkin> prejudice!
11:03:33 <bd_> > length (filter (\c -> not isAlpha c && isUpper c) [minBound..maxBound] :: [Char])
11:03:34 <lambdabot>   Couldn't match expected type `Bool'
11:03:36 <Cale> > length (filter isLower [minBound..maxBound] :: [Char])
11:03:37 <lambdabot>   1415
11:03:43 <bd_> > length (filter (\c -> (not $ isAlpha c) && isUpper c) [minBound..maxBound] :: [Char])
11:03:44 <Cale> Most are neither.
11:03:45 <lambdabot>   0
11:03:47 <mmorrow> > length (filter (c -> isAlpha c && isUpper c) [minBound..maxBound] :: [Char]) {- just checking -}
11:03:47 <pumpkin> oh
11:03:47 <lambdabot>   <no location info>: parse error on input `->'
11:03:51 <Asztal> > drop 200 (filter isUpper [minBound..maxBound] :: [Char])
11:03:52 <lambdabot>   "\538\540\542\544\546\548\550\552\554\556\558\560\562\902\904\905\906\908\9...
11:04:06 <mmorrow> > length (filter (\c -> isAlpha c && isUpper c) [minBound..maxBound] :: [Char]) {- just checking -}
11:04:08 <lambdabot>   1221
11:04:28 <pumpkin> :t isLower
11:04:29 <lambdabot> Char -> Bool
11:04:35 <pumpkin> aha, that way we can get "neither
11:04:53 <pumpkin> > isUpper &&& isLower $ ''
11:04:55 <lambdabot>   (False,False)
11:05:04 <Cale> > length (filter (\c -> isAlpha c && not (isLower c || isUpper c)) [minBound..maxBound] :: [Char])
11:05:05 <lambdabot>   87911
11:05:10 <cedricshock> I have reached a new conclusion. Haskell needs an impure, side-effect free type and a single-valued, impure, side-effect free type. These might be Monads, but I think can have fewer laws.
11:05:27 <mmorrow> @let isNeither c = not (isUpper c || isLower c)
11:05:28 <pumpkin> cedricshock: why?
11:05:28 <lambdabot>  Defined.
11:05:37 <Cale> cedricshock: What do you mean by that? Something like ST?
11:05:47 <mmorrow> crap, shoulda included isAlpha in there..
11:05:55 <Cale> Maybe an implementation of IVars in ST?
11:06:11 <Gracenotes> cedricshock: you might be interested in something called effectful types, which are sort of an annotation on functions indicating their effect. You can also have an Identity effect, meaning pure
11:06:12 <bd_> > length (filter (\c -> isAlpha c && isNeither c) [minBound..maxBound] :: [Char])
11:06:14 <lambdabot>   87911
11:06:24 <pumpkin> I'd like a more  la carte IO
11:06:28 <Gracenotes> cedricshock: however, there aren't many languages today with 'em. Monads are Haskell's way.
11:07:02 <Gracenotes> and they were mainly intended to *sequence* events in a lazy language, something mere annotations can't do
11:07:46 <Apocalisp> Java has monads.
11:07:50 <Apocalisp> ;)
11:07:55 <Gracenotes> another alternative to monads, just to mention them, uniqueness types
11:08:47 <vixey> Apocalisp what does that mean
11:08:49 <vixey> 'has monads'
11:08:51 <cedricshock> To separate sensors that necessarily change the outside world to look at it, affectors that execute decisions, and decision  making agents that must not, but can use up-to-date outside information
11:09:03 <Apocalisp> ; is >>= in the Java monad.
11:09:12 <pumpkin> cedricshock: an  la carte IO could do that
11:09:21 <Gracenotes> Apocalisp: perhaps >> ...
11:10:01 <pumpkin> cedricshock: http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
11:10:04 <Gracenotes> cedricshock: hrm. That's a logical separation that doesn't sound like it has much to do with purity.
11:10:58 <Gracenotes> and might be difficult to enforce in a type system, although effect types again provide a way to do this. And possibly specific monads.
11:11:05 <cedricshock> It doesn't actually need the second, it can be made with a simple let binding of the first.
11:11:08 <Apocalisp> int x = 1; x = x + 1;  =>  \f -> return 1 >>= \x -> x + 1 >>= \y -> f x
11:11:19 <Apocalisp> something to that effect
11:12:12 <lysgaard> MyCatVerbs: Hi, still there? I've made a good bit of progess, but now I want to make a divide function, without rationale numbers: Explenation here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4997#a4999
11:13:31 <Gracenotes> Apocalisp: Perhaps.. more like newIORef 1 >>= \x -> modifyIORef x (1+)
11:14:05 <Apocalisp> Gracenotes: Why IORef?
11:14:07 * lilac has fixed the Natural bug
11:14:21 <Gracenotes> Apocalisp: that's what variables in imperative languages are, aren't they?
11:14:21 <lilac> anyone here who has / can grant me a hackage user account?
11:14:35 <cedricshock> pumpkin: That
11:14:38 <Apocalisp> Gracenotes: No, int x = 1; x = x + 1; is pure
11:14:40 <Gracenotes> x would probably be stored somewhat readily available (a register, possibly?), but still, this is just a behind-the-scenes optimization
11:14:45 <cedricshock> 's a great article, thanks.
11:15:01 <pumpkin> cedricshock: it moves to something you're describing near the end :)
11:15:11 <lilac> roconnor: if you want to upload, the fixed version is here: http://metafoo.co.uk/downloads/numbers-2009.5.18.1.tar.gz
11:15:18 <cedricshock> It'
11:15:37 <Gracenotes> Apocalisp: declaring an int and modifying it is more than just changing what it's binded to
11:15:44 <cedricshock> s going to make a new monad with only some of the state transitions of the IO monad (my guess).
11:15:55 <hatds> Apocalisp: what's so bad about just doing that in Haskell and giving x+1 a new name?
11:15:58 <afedorov> Is there a standard Haskell datatype for Haskell's AST?
11:15:59 <Gracenotes> you're modifying the memory location. But... this can at least be simulated by monads in a pure way
11:16:01 <lilac> Gracenotes: that depends on whether it's forced to memory (whether its address is taken, basically), right?
11:16:08 <cedricshock> I need to learn not to hit the enter key with shift.
11:16:13 <lilac> otherwise it may as well be pure
11:17:00 <Gracenotes> lilac: what do you mean?
11:17:08 <mmorrow> pumpkin: we can just use (data A; newtype IOA a = IOA (ST A a) to get different IO's
11:17:18 * lilac notes that we were talking about Java...
11:17:25 <mmorrow> no one has done this, but it would work nicely
11:17:47 <pumpkin> mmorrow: wouldn't we need to change the type of ST to get that?
11:17:54 <mmorrow> pumpkin: no
11:18:05 <afedorov> is there an "official" haskell parser in haskell?
11:18:08 <Gracenotes> I do like Apocalisp's example much better in terms of readability, and it helps shed light on a simple Java monad would be... not sure if it's entirely accurate :)
11:18:13 <Apocalisp> Gracenotes: You're not modifying the int. int is immutable. Nothing wrong with doing that in Haskell.
11:18:30 <lilac> Gracenotes: well, consider the program converted to SSA form. at that point, everything except memory reads and writes and calls to externals is pure
11:18:30 <pumpkin> mmorrow: how would you say that "this function modifies files AND talks to the network"?
11:18:33 <dcoutts_> afedorov: yes, but it's not as good as the unofficial one :-)
11:18:34 <mmorrow> pumpkin: (you'd just need to use unsafeCoerce a bunch of places in your implem)
11:18:49 <Apocalisp> there was a paper...
11:18:55 <mmorrow> pumpkin: you'd do that by only writing functions for IOA that do those things
11:19:08 <Apocalisp> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.3.1523
11:19:08 <afedorov> dcoutts_: here, I'm just looking to see if there's anything like a standard for the Haskell AST
11:19:09 <pumpkin> so you'd need an A for each conjunction of "features"?
11:19:10 <d3mn0id> Ahh, intelligent lifeforms, run!
11:19:15 <afedorov> ~hehe
11:19:15 <dcoutts_> afedorov: see the packages haskell-src and haskell-src-exts but also the ghc api, which you should choose depends on your application
11:19:21 <mmorrow> pumpkin: well, it would probably be simpler to just use:
11:19:22 <Baughn> Not to be a bother, but is it currently possible at all to install reactive with cabal-install?
11:19:27 <Gracenotes> lilac: yes. memory reads and writes aren't pure though.
11:19:30 <Baughn> I'm getting conflicting QuickCheck versions
11:19:43 <mmorrow> pumpkin: newtype IOA a = IOA (IO a)
11:19:45 <dcoutts_> afedorov: in that case also consider TemplateHaskell, it also has an AST
11:19:48 <afedorov> dcoutts_: thanks :)
11:19:57 <Gracenotes> ST handles them, but ST is also impossible to implement in plain Haskell
11:20:05 <afedorov> dcoutts_: do they all use different AST's?
11:20:10 <lilac> Gracenotes: int in Java is unboxed, so an int 'on the stack' is never required to be written to memory. in that sense, all int operations are pure.
11:20:11 <FliPPeh> I feel like abusing Haskell :(
11:20:17 <mmorrow> pumpkin: but if you want a function like: runIOA :: IOA a -> a, then you'd want to use (ST A a)
11:20:21 <pumpkin> FliPPeh: that's fun!
11:20:24 <dcoutts_> afedorov: there is no official AST, because there are different language extensions, and how you design the AST depends on what you're actually interested in doing
11:20:25 <afedorov> dcoutts_: or, rather, different datatypes to represent it?
11:20:25 <FliPPeh> I keep writing functions for commonly used calculations of my homework
11:20:27 <pumpkin> mmorrow: hmm
11:20:34 <FliPPeh> And use it just to solve my homework!
11:20:37 <dcoutts_> afedorov: yes, all 4 are different
11:20:40 <mmorrow> pumpkin: and you'd write it like:
11:20:43 <afedorov> dcoutts_: eek
11:20:57 <afedorov> dcoutts_: sounds good, I'll take a look, thanks for the pointers :)
11:20:59 <mmorrow> pumpkin: runIOA (IOA staa) = runST (unsafeCoerce staa)
11:21:02 <Gracenotes> lilac: althogh, implementation detail
11:21:15 <Apocalisp> Gracenotes: Also, there's nothing stopping you in Java writing an immutable List with fmap and bind, giving you a list monad.
11:21:31 <Gracenotes> Apocalisp: of course... why would there be...?
11:21:36 <dcoutts_> afedorov: the haskell-src ast covers Haskell 98, the others cover Haskell 98 + many extensions. The ghc ast includes line numbers and documentation comments.
11:21:55 <afedorov> dcoutts_: gotcha
11:22:00 <Apocalisp> Gracenotes: Just saying... Monads are not just a Haskell thing. They're fundamental to programming.
11:22:15 <Gracenotes> lilac: if you want to deal with both primitives and non-, you may find yourself dealing with messy abstractions when implementing via monads
11:22:43 <pumpkin> mmorrow: I don't understand how you would mix these things, without having to write a different A each time
11:22:46 <Gracenotes> Apocalisp: yeah, just like anamorphisms, catamorphisms, and a thousand other category structures :P
11:23:02 <lilac> Apocalisp: there's a big difference between 'you can do monads here' (true of scala, Java and C++) and 'you can usefully and easily do monads here' (true of haskell)
11:23:03 <mmorrow> pumpkin: you'd have a different A for every different IO_ monad you want
11:23:20 <mmorrow> pumpkin: and that different A is what keeps them separate
11:23:24 <pumpkin> yeah
11:23:29 <lilac> Apocalisp: where by 'do monads' i mean define and use custom monads
11:23:48 <lilac> if you're in the IO monad or similar anyway, then monads as a programming technique lose a lot of value
11:23:56 <Gracenotes> I once wrote a monad in Java. Really abused is generics.
11:24:01 <Gracenotes> its
11:24:32 <mmorrow> pumpkin: hmm, ok a better way to phrase this i think is to ditch the newtype, and just use  (ST <my-phantom-type> a) directly
11:25:29 <Gracenotes> or effect types >_>
11:25:50 <monadic_kid> :t StateT Int IO a
11:25:51 <lambdabot> Not in scope: data constructor `Int'
11:25:51 <lambdabot> Not in scope: data constructor `IO'
11:26:03 <pumpkin> http://okmij.org/ftp/Computation/Subtyping/ (what's up with him mentioning Haskell as a language with "a native or emulated OO system"?)
11:26:03 <hatds> is there a way to view source code in ghci?
11:26:14 <roconnor> :k StateT Int IO a
11:26:15 <lambdabot> Not in scope: type variable `a'
11:26:25 <pejo> pumpkin, see OOHaskell
11:26:45 <vixey> :k a -> a
11:26:46 <lambdabot> Not in scope: type variable `a'
11:26:46 <lambdabot> Not in scope: type variable `a'
11:26:46 <pumpkin> pejo: yeah, I've seen that, but didn't think it was widespread enough to be mentioned as "a haskell"
11:26:59 <pumpkin> maybe if he'd said OOHaskell :P
11:27:03 <monadic_kid> anyways from what I just glanced from the discussion above, why not use a state transformer?
11:27:14 <Gracenotes> :k Int -> Int
11:27:16 <lambdabot> *
11:27:17 <Gracenotes> hrm.
11:27:22 <Apocalisp> lilac: The big win with Haskell is that you can define Monad in general.
11:27:29 <mmorrow> :k forall a. a -> a
11:27:30 <lambdabot> *
11:27:31 <pumpkin> mmorrow: hrm :P
11:27:35 <Gracenotes> ooh.
11:27:48 <byorgey> Gracenotes: any type that actually classifies values has kind *.
11:27:56 <byorgey> so that includes any function type.
11:27:56 <Apocalisp> lilac: Not just this monad or that monad, but "every m such that... is a monad"
11:27:58 <monadic_kid> did someone say they want a state and IO monad?
11:28:02 <lysgaard> Having some type problems. I want to make an instance of the (%) function, but i can't find what class it belongs to.. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4997#a4999
11:28:04 <Gracenotes> byorgey: of course. I'm just wondering why a -> a didn't work
11:28:11 <Gracenotes> but it seems an explicit forall was needed
11:28:15 <byorgey> oh, I see
11:28:26 <Gracenotes> does seem a bit odd, though, right?
11:28:37 <byorgey> lysgaard: % isn't a class method, it's the constructor for values of type Ratio
11:29:00 <mauke> pumpkin: huh? it's just a library. why "a haskell"?
11:29:05 <Gracenotes> you don't need ExistentialQuantification on, too
11:29:20 <byorgey> lysgaard: do you really mean (%) or do you mean mod?
11:29:22 <lysgaard> Darn, hmm, ok but i still wan't it to act as (+) (-) and (*) does, how?
11:29:47 <pumpkin> mauke: well, citing haskell as an OO language because someone built an OO simulator library for it seems odd, unless that simulated OO is very widespread (which I thought it wasn't)
11:29:50 <pejo> pumpkin, that's Oleg's homepage, and he's one of the authors of OOHaskell.
11:29:50 <Gracenotes> Apocalisp: I tend to like typeclasses over inheritance for open polymorphism, but still it is limited sometimes
11:29:56 <Gracenotes> they are.
11:30:08 <pumpkin> pejo: oh, I wasn't aware that he was one of the authors, that makes more sense then
11:30:26 <lysgaard> byorgey: I mean division like in (/), just that i want it to be lazy. I'm trying to make a little algebra datatype that i can explore
11:30:45 <byorgey> lysgaard: how would division work?  what should  (Number 3) / (Number 5) be?
11:31:23 <lysgaard> byorgey: it should be Divide 3 5
11:31:45 <byorgey> lysgaard: ah, ok.  that should work fine.  Just make Algebra an instance of Fractional.
11:31:48 <d3mn0id> http://haskell.org/haskellwiki/Introduction does a very good job of showing you the code line number benefits of Haskell.
11:32:00 <byorgey> lysgaard: Fractional has (/), recip, and fromRational
11:32:11 <mauke> > 3 / 5 :: Expr
11:32:12 <lambdabot>   3 / 5
11:32:21 <vixey> lysgaard: not  Divide (Number 3) (Number 5)?
11:32:43 <mmorrow> pumpkin: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2445#a2445
11:32:52 <lysgaard> vixey: oh, yeah, Divide (Numbe... is correct
11:33:30 <pumpkin> mmorrow: I understood that bit, but I was wondering how you'd compose those things elegantly
11:33:38 <mmorrow> pumpkin: compose what?
11:33:48 <pumpkin> say you have an RNet for network access
11:33:49 <pumpkin> and an RFile
11:33:52 <pumpkin> they're fine on their own
11:33:54 <lysgaard> byorgey: isn't fractional a lossy datatype?
11:34:09 <pumpkin> say you wanted to write a simple webserver, that needs file access and network access
11:34:12 <byorgey> lysgaard: Fractional isn't a data type.
11:34:15 <mmorrow> pumpkin: well, you'd need a monad that has both capabilities
11:34:26 <byorgey> it's a type class that specifies certain functions that should be available.
11:34:34 <mmorrow> pumpkin: then rfileToRFileAndRNet and rnetToRFileAndRNet
11:34:38 <lysgaard> byorgey: I mean is 10/3 = 3.333 or 10/3 = 10/3?
11:34:49 <byorgey> lysgaard: it depends on the type.
11:34:52 <pumpkin> mmorrow: ah, so you'd make an RFileAndRNet type
11:35:00 <mmorrow> pumpkin: :: RFile a -> RFileAndRNet a, RNet a -> RFileAndRNet a
11:35:06 <byorgey> lysgaard: Double is an instance of Fractional; it is lossy.  Rational is also an instance of Fractional; it is not lossy.
11:35:06 <mmorrow> pumpkin: something like that
11:35:09 <mm_freak> doWhatIMean :: IO ()
11:35:09 <pumpkin> that feels cumbersome :/
11:35:32 <byorgey> lysgaard: Fractional is completely agnostic about how (/) actually works for each particular type.  that is up to the instance.
11:35:33 <mm_freak> whatIMean :: a
11:35:34 <mmorrow> pumpkin: i bet there's a more elegant way to express a monad's capabiltiies thgouh
11:35:38 <frwmanne1s> > (10/3) :: Double
11:35:39 <lambdabot>   3.3333333333333335
11:35:45 <byorgey> lysgaard: for your Algebra type, it looks like it will not be lossy.
11:35:47 <mm_freak> > whatIMean
11:35:48 <lambdabot>   Not in scope: `whatIMean'
11:35:48 <mmorrow> pumpkin: (than simply making an entirely new type)
11:35:49 <pumpkin> mmorrow: that  la carte paper seemed pretty nice
11:35:49 <lysgaard> byorgey: Oh!
11:35:50 <mm_freak> =/
11:35:52 <Eelis> is there a cabal-specific channel?
11:35:57 <mmorrow> pumpkin: i haven't read it
11:36:05 <mmorrow> pumpkin: link?
11:36:08 <mmorrow> :)
11:36:14 <pumpkin> mmorrow: that's what got me interested in doing this, it's pretty neat :) http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
11:36:15 <thoughtpolice> @go data types a la carte
11:36:17 <lambdabot> http://lambda-the-ultimate.org/node/2700
11:36:17 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
11:36:30 <pumpkin> mmorrow: specifically, near the end, but the whole paper is pretty awesome
11:37:13 <mmorrow> pumpkin: oh yeah, i've seen that stuff
11:37:13 <mauke> Eelis: signs point to "no"
11:37:20 <Eelis> mauke: ok
11:37:32 <[bjoern]> I am looking for a more elegant way to do   map (\p -> if p == 5 then 2 else p) [0..9]   - where the list and integers are variable of course
11:37:44 <lysgaard> byorgey: Ok, i think i understand, i'll try it =)
11:37:50 <mmorrow> pumpkin: have you looked at the code to IOSpec?
11:37:56 <mmorrow> (it's on hackage)
11:38:00 <pumpkin> mmorrow: a little
11:38:30 <mmorrow> it's neat
11:38:41 <pumpkin> I'll take a closer look
11:38:55 <pumpkin> gotta run :)
11:38:57 <mmorrow> ooh, nice. i just saw this bit:
11:39:10 <mmorrow> FilePath  Term (Teletype :+: FileSystem) ()
11:39:13 <pumpkin> yeah :)
11:39:16 <Eelis> cabal's "setup configure" can run a user-supplied configure script. when it does, it passes it a bunch of options including --prefix, if the user specified those. however, when the user didn't, nothing is passed. is the default prefix completely fixed, or does it differ from platform to platform?
11:39:27 <pumpkin> mmorrow: that's really attractive to me :P but unfortunately haskell can't infer that type
11:39:30 <mmorrow> pumpkin: so you just do  ST (Teletype :+: FileSystem) a
11:39:35 <pumpkin> so you need to annotate it explicitly
11:39:37 <mmorrow> et voila
11:39:51 <mmorrow> hrm
11:40:00 <dcoutts_> Eelis: yeah, that's not good really, it should always specify all the vars explicitly to configure. Feel free to file a ticket.
11:40:12 <Eelis> dcoutts_: alright, i will.
11:40:23 <pumpkin> mmorrow: I'll be back in a bit :)
11:40:27 <dcoutts_> Eelis: thanks
11:40:27 <mmorrow> cool
11:41:24 <dcoutts_> Eelis: in practise it's not been a problem because haskell packages with configure scripts are not usually generating anything that embeds paths, usually just checking prerequisites and generating flags for include dirs etc
11:41:40 <lysgaard> byorgey: How do i find out what class an function is from eg: (^)
11:41:47 <vixey> :t (^)
11:41:48 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
11:41:59 <vixey> it's got to be either in Integral or Num or neither
11:42:09 <Eelis> dcoutts_: yeah, i can imagine. unfortunately, i've run into a case where i really do need to know the prefix in the configure script (because i have some post-cabal installation steps)
11:42:14 <vixey> or actually it could be in any other class I guess
11:42:23 <lysgaard> vixey: How can it be in neither?
11:42:29 <byorgey> actually, (^) isn't in a class
11:42:31 <vixey> @src (^)
11:42:31 <lambdabot> x ^ 0            =  1
11:42:32 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
11:42:32 <lambdabot>   where f _ 0 y = y
11:42:32 <lambdabot>         f x n y = g x n
11:42:32 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
11:42:33 <lambdabot>                       | otherwise = f x (n-1) (x*y)
11:42:35 <vixey> like that ^
11:42:35 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
11:42:53 <byorgey> lysgaard: it is just implemented in terms of methods in the Integral and Num classes
11:43:02 <dcoutts_> Eelis: right, it's always possible to override the code that calls configure and you can call it yourself.
11:43:27 <byorgey> lysgaard: but in general, you want to use ghci (or lambdabot) to look at the type
11:43:41 <byorgey> then look at any classes you see in its type
11:43:41 <Eelis> dcoutts_: interesting. override where? in Setup.hs? guess i should read the cabal manual again :)
11:43:43 <lysgaard> i use ghci all the time
11:43:51 <byorgey> you can get more info about a class using :info
11:43:54 <byorgey> like :info Integral
11:43:56 <dcoutts_> Eelis: yes, using the hooks in Setup.hs
11:44:05 <Eelis> dcoutts_: ok, i will look at those. thanks!
11:44:09 <byorgey> will show you all the methods in the Integral class.
11:44:17 <Berengal> lysgaard: or just ':info (^)'
11:44:27 <Berengal> Prelude> :info (+) <\n> class (Eq a, Show a) => Num a where<\n>  (+) :: a -> a -> a
11:44:35 <dcoutts_> Eelis: see autoconfUserHooks in Distribution.Simple
11:44:36 <Berengal>  What I get from ghci
11:44:42 <lysgaard> but say i want to make a (^) function for my algebra, how do i do thot then, when it's in no class?
11:44:58 <byorgey> ah, right, at first I thought :info for (^) didn't work since it didn't show me a class... but that's because (^) isn't in a type class =)
11:45:25 <byorgey> lysgaard: the type of (^) says it works for any arguments whose types are instances of Num and Integral
11:45:40 <byorgey> so if your algebra type is an instance of those classes, (^) will automatically work for it
11:45:47 <Berengal> (^) is defined in terms of the class functions. If you want it to work for your type you need to implement the class functions such that they provide the answers (^) expect of them
11:47:26 <lysgaard> well, my algebra type includes variables, so it can't be a member of Integral or Num, but it includes the type Number, wich is an Integral. look here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=4997#a5001
11:47:47 <vixey> lysgaard: here's what I do
11:47:52 <vixey> import Prelude
11:48:04 <vixey> Number x + Number y = ...
11:48:13 <vixey> define (+) yourself and forget about the normal definition
11:50:07 <vixey> btw putting | at the end of all the lines except one is ugly
11:50:11 <vixey> you can write
11:50:15 <vixey> data X = ...
11:50:20 <vixey>        | ...
11:50:22 <vixey>        | ...
11:50:23 <vixey> instead
11:50:46 <vixey> also    (Number a) == (Number b) = a == b   can be    Number a == Number b = a == b
11:51:37 <frwmanners> lysgaard: something along the lines of (Raise a b) * (Raise c d) | a == c = Raise a (b + d) might get the standard (^) to work
11:51:38 <lysgaard> vixey: Thanks, i love syntax tips, they always make the code cleaner
11:52:45 <frwmanners> lysgaard: btw, is (Add (Variable "x") (Variable "y")) not equal to itself?
11:55:08 <lysgaard> frwmanners: Well, i don't know how to express two variables, who in practise can be any number you want, in any more sensibel way
11:55:49 <frwmanners> lysgaard: sure
11:56:13 <frwmanners> lysgaard: but if == is really ===, then you could get away with Add a b == Add c d = a == c && b == d
11:56:30 <copumpkin> :o
11:56:32 <frwmanners> lysgaard: or
11:56:42 <frwmanners> lysgaard: with the arguments flipped or something
11:56:44 * copumpkin is back!
11:57:41 <SubStack> finally!
11:58:13 <dolio> @yow! The volcano taco is back!
11:58:13 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
11:58:22 <lysgaard> frwmanners: One more time, i think you're at a wery important point, but i didn't understan how you meant i should implement it?
11:59:46 <frwmanners> lysgaard: instance Eq Algebra where Number a == Number b = a == b; Variable a == Variable b = a == b; Add a b == Add c d = (a == c && b == d) || (a == d && b == c)
12:00:10 <frwmanners> lysgaard: with some more cases for multiplication &c
12:00:40 <d3mn0id> I'll come back when I know some Haskell.
12:00:49 <frwmanners> lysgaard: assuming your algebraic expressions are finite, eventually you'll bottom out into one of those
12:01:03 <frwmanners> lysgaard: and then a massive a == b = False at the end
12:01:18 <lysgaard> frwmanners: They are finite, that's for shure
12:01:57 <frwmanners> lysgaard: so right, a recursive definition of equality is probably the way to go
12:02:30 <lysgaard> Yeah, i got your point now, genious :D
12:04:43 <lysgaard> But to be even more general, this Eq, the one for add is also true for Multiply. And for subtraction, and division, it's true, but not the arguments flipped. Is there a way to make the algebra type so that it can figure out this?
12:06:31 <frwmanners> lysgaard: data Algebra ... deriving Eq would be nearly there, but you'd lose the argument flipping I guess
12:06:57 <lysgaard> frwmanners: What if i made an opperator type or something?
12:07:38 <lysgaard> frwmanners: Or isn't that the way to go?
12:07:48 <frwmanners> lysgaard: could work
12:07:54 <frwmanners> lysgaard: up to you I guess
12:08:32 <frwmanners> lysgaard: data BinOp = CommutativeOperator String | NonCommutativeOperator String would not be unsensible
12:08:49 <vixey> I'd rather
12:09:00 <vixey> data CommutativeOp = Add | Multiply
12:09:03 <vixey> than 'String'
12:09:13 <frwmanners> sure
12:09:35 <frwmanners> depends how many exotic operators you're likely to dream up I suppose
12:09:37 <lysgaard> Ok, what does that mean :P
12:10:10 <vixey> anyway having == for syntactic equality, but then a different equality test for semantic equality is a good idea
12:10:15 <vixey> so deriving Eq is cool
12:10:51 <frwmanners> so an === operator or something?
12:10:57 <lysgaard> Hehe, I'm doing this mostly as an exersise to get to know the typesystem of haskell. Therefore I'd like to get as complicated as i can understand
12:11:24 <frwmanners> lysgaard: so, if you make CommutativeOp = Add | Multiply
12:12:06 <frwmanners> lysgaard: you can then have data Algebra = Number Integer | ... | CommOp CommutativeOp Algebra Algebra
12:12:36 <frwmanners> lysgaard: | NonCommOp NonCommutativeOp Algebra Algebra
12:12:59 <frwmanners> where you've also got data NonCommutativeOp = Sub | Div
12:13:01 * Baughn finally got reactive working (work on that dependency algorithm..), and is now in the process of blowing up his head. Thanks, guys.
12:13:05 <Eelis> dcoutts_: (fyi, reported: http://hackage.haskell.org/trac/hackage/ticket/553 )
12:13:13 <dcoutts_> Eelis: thanks
12:14:03 <Baughn> Using reactive-glut to make a mini-GUI toolkit.. I can't quite understand things yet, but it looks very, very sweet.
12:14:16 <frwmanners> lysgaard: So ``x + y'' becomes CommOp Plus (Variable "x") (Variable "y")
12:14:30 <frwmanners> lysgaard: &c.
12:14:46 <Baughn> Now if only I could figure out the Show instance for Event. It doesn't do what I expected (eg. let me print events as they happen).
12:14:53 <lysgaard> frwmanners: Yeah, i think i've got it
12:14:59 <frwmanners> lysgaard: cool
12:15:04 <hatds> I'm making my own mini-GUI toolkit, what do you see useful about reactive?
12:15:58 <Baughn> hatds: The sheer functionalness, basically; they've figured out a way to let me write imperative code declaratively, in a much nicer fashion than I've ever seen before
12:16:11 <roconnor> hatds: have I told you about GuiTV before?
12:16:18 <Baughn> hatds: ..I can't be much more specific than that, since I only just got started
12:16:19 <hatds> roconnor: yea
12:16:26 <roconnor> hatds: ok
12:16:36 <roconnor> carry on then :)
12:16:39 <hatds> roconnor: I've read a bit about it, is there something particular about that one versus the others?
12:17:06 <Baughn> hatds: But it takes care of all the usual machinery (event handlers, callbacks, etc.) under the covers, in a way that I don't even need to know they're there
12:17:07 <roconnor> hatds: I'm not sure.  GuiTV is the only Gui system I've ever used in haskell.
12:18:12 <hatds> my GUI system is tick-based and not event-driven, the outer system has to call app_draw and app_main
12:18:23 <hatds> but I've been thinking about whether that could be better
12:18:31 <endojelly> why are there bottom-up and top-down versions of everywhere (everywhere and everywhere', respectively), but only a top-down version of everywhereM in the standard library? I had to define everywhereM' myself...
12:18:54 <frwmanners> Baughn: do you want to print Events when they happen or when they become defined?
12:19:22 <copumpkin> omg there are
12:19:23 <pumpkin> two of me
12:19:56 <Baughn> frwmanners: I'm afraid I don't understand the difference. If you wouldn't mind? ;)
12:20:02 <lysgaard> frwmanners: Think I've got it, but i'll need to add algebra to Show :S  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5005#a5005
12:20:34 <pumpkin> Algebra is an odd name
12:21:06 <roconnor> newtype Algebra f a b = Algebra (f a -> b)
12:21:06 <Baughn> frwmanners: I mean, I'd like to print them when they happen - just to make sure this is working - but I'd like to know what "defined" means in terms of reactive
12:21:08 <frwmanners> Baughn: So, as I understand it, something like atTimes [0..] is defined from the word go, even though things only happen at times 0, 1, 2 ...
12:21:17 <pumpkin> roconnor: that's what I normally think of
12:21:20 <lysgaard> pumpkin: Yeah, you have any better, i don't like it either, but i'm not to good in math phrasology
12:21:39 <Baughn> frwmanners: Makes sense
12:21:44 <pumpkin> lysgaard: you can ask haskell to derive Show for you, too
12:21:49 <Baughn> frwmanners: It'd just block until time reaches those.. times, I suppose
12:22:03 <frwmanners> Baughn: ok
12:22:10 <Baughn> frwmanners: Incidentally, what I've got right now is "sink UI{..} = pure (print 42 >> print leftButtonPressed)", which prints 42 and then 'thread blocked indefinitely'
12:22:27 <TonyTheTiger> hiya how do i write a type signature for somthing like... twice f x = f (f x)
12:22:28 <Baughn> frwmanners: Oh, I think I just figured it out myself..
12:22:51 <roconnor> twice :: (a -> a) -> a -> a
12:22:52 <Baughn> frwmanners: pure (Behavior) describes it at time -infinity, /once/.. right?
12:22:58 <Baughn> But mostly at time -infinity
12:23:25 <pumpkin> TonyTheTiger: by the way, twice = join
12:23:27 <Baughn> So of course the keys never get pressed, as far as that behavior is concerned
12:23:40 <frwmanners> a pure Behaviour should take the same value at all time
12:23:42 <TonyTheTiger> roconnor: but its a function that it takes,
12:23:46 <roconnor> pumpkin: in what monad?
12:23:51 <TonyTheTiger> roconnor: does that not matter?
12:23:57 <roconnor> TonyTheTiger: (a -> a) is a function
12:24:03 <pumpkin> roconnor: oh wait, that makes no sense, sorry :)
12:24:09 <frwmanners> a pure event happens once at (-infinity)
12:24:12 <patch-tag> hey is there a haskell package or "style" that can be used to program simple command line stuf that's okay on both unix and dows? like, really simple, just cd here and there, and then run ghc commands. hsh is really nice but seems to be unix only
12:24:25 <Baughn> frwmanners: Right you are
12:24:36 <Baughn> frwmanners: And my behavior is not supposed to be pure, so I shouldn't be using it. :)
12:24:39 <pumpkin> roconnor: it could be join (.) though
12:24:55 <Baughn> ..nice choice of function name, there
12:24:56 <pumpkin> since it's really twice f x = ((.) f f) x
12:25:04 <TonyTheTiger> roconnor: ohh ok, and would i need to do this too... twice :: (Num a) => (a -> a) -> a -> a?
12:25:09 <TonyTheTiger> would that be correct?
12:25:11 <hatds> I was almost going to do a reactive approach when I started, but I didn't know of reactive back then
12:25:31 <hatds> the best I could come up with was like an infinite stream of inputs with unsafeInterleaveIO
12:25:39 <roconnor> TonyTheTiger: well, you don't really need the Num constraint since the function has nothing to do with numbers, but adding the constraint doesn't really hurt much.
12:26:20 <TonyTheTiger> roconnor: oh yeah the "function" that im calling will handle that, thanks i understand now.
12:26:54 <hatds> having imperative push-based events does not rule out declarativeness though
12:28:03 <roconnor> > myThreadID
12:28:04 <lambdabot>   Not in scope: `myThreadID'
12:28:06 <roconnor> > myThreadId
12:28:06 <lambdabot>   Not in scope: `myThreadId'
12:28:22 <roconnor> @hoogle mythreadid
12:28:23 <lambdabot> Control.Concurrent myThreadId :: IO ThreadId
12:53:59 <Baughn> conal: Would you accept a reactive-glut patch to add leftButton/rightButton Behavior Bools and equivalent keyboard behavior? (I'm very new to this whole "reactive" thing, but.. kinda need those)
12:54:25 <lysgaard> I've gotten a bit furter, but now i have some problems with a simplyfy function. I think i've missunderstood the typesystem or something :S http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5005#a5006
12:54:39 <TonyTheTiger> hi guys can explain to me how you use null and where it would be appropriate?
12:55:53 <lysgaard> TonyTheTiger: What do you want to do?
12:56:17 <Berengal> TonyTheTiger: We don't have null, only nil and Nothing
12:56:21 <lysgaard> TonyTheTiger: Null like in imperative languages (c, python ...) does not exist
12:56:23 <pejo> TonyTheTiger, whenever you want to know if a list is empty or not.
12:56:49 <lysgaard> TonyTheTiger: All functions in haskell has to return someting
12:56:55 <adamvo> > null []
12:56:56 <lambdabot>   True
12:57:09 <lysgaard> What you need is I guess is Maybe
12:57:24 <Baughn> conal: ..make that Set Key for the keyboard
12:57:32 <pejo> TonyTheTiger, (but pattern matching might be more clear in a recursive function, for example).
12:58:10 <vixey> > null null
12:58:12 <lambdabot>   Couldn't match expected type `[a]'
12:58:25 <vixey> null is pretty much useless
12:58:33 <vixey> I guess there are sometimes you can use it
12:58:46 <Berengal> vixey: I use if null foo then ... often enough
12:58:57 <roconnor> @type let foo 7 = () in foo
12:58:58 <lambdabot> forall t. (Num t) => t -> ()
12:59:05 <vixey> lysgaard: You need to write:
12:59:07 <pumpkin> > null [null]
12:59:09 <lambdabot>   False
12:59:12 <FunctorSalad> hehe
12:59:12 <vixey>     CommOpp (Add a b) = ...
12:59:13 <pumpkin> > null [null [null]]
12:59:14 <vixey> it can't be
12:59:15 <lambdabot>   False
12:59:17 <vixey>     CommOpp Add a b = ...
12:59:22 <pumpkin> > null [null [null [null]]]
12:59:24 <lambdabot>   False
12:59:25 <vixey> the reason is because 'CommOpp' isn't an operator
12:59:34 <FunctorSalad> > fix (\x -> null [x])
12:59:35 <lambdabot>   False
12:59:37 <FunctorSalad> :o
12:59:37 <ziman> > fix (nul . (:[]))
12:59:38 <lambdabot>   Not in scope: `nul'
12:59:44 <TonyTheTiger> guys can you explain to me how null works and applying it?
12:59:45 <ziman> > fix (null . (:[]))
12:59:46 <lambdabot>   False
12:59:47 <FunctorSalad> ziman :)
12:59:54 <ziman> FunctorSalad, you got it right ;)
13:00:00 <Berengal> @type null
13:00:02 <lambdabot> forall a. [a] -> Bool
13:00:12 <lysgaard> vixey: CommOpp is an constructor?
13:00:22 <adamvo> @src null
13:00:22 <lambdabot> null []     = True
13:00:22 <lambdabot> null (_:_)  = False
13:00:29 <vixey> fus
13:00:32 <vixey> yes*
13:00:36 <Berengal> map null $ iterate (():) []
13:00:53 <Berengal> > map null $ iterate (():) []
13:00:55 <lambdabot>   [True,False,False,False,False,False,False,False,False,False,False,False,Fal...
13:00:57 <TonyTheTiger> huh, its alot more simple than i thought about
13:01:00 <TonyTheTiger> cheers
13:01:46 <lysgaard> vixey: Yay! I think i'm getting the hang of this
13:01:52 <vixey> :)
13:02:14 <lysgaard> vixey: But how can i do the patternmatching then?
13:02:15 <FunctorSalad> ISTR there's a rewrite rule that replaces stuff like (x==[]) with a pattern match
13:02:24 <vixey> lysgaard pattern matching of what?
13:02:29 <FunctorSalad> or a different ghc optimization
13:02:40 <copumpkin> people talk about all haskell data being codata
13:02:44 <lysgaard> vixey: Eg:  | a == - b = Number 0 for Add
13:02:45 <copumpkin> or am I misremembering?
13:02:48 <adamvo> @type (==[])
13:02:50 <lambdabot> forall a. (Eq a) => [a] -> Bool
13:03:03 <FunctorSalad> copumpkin: :O I considered asking this several minutes ago.
13:03:04 <vixey> adamvo: yeah null has to be pattern matching
13:03:15 <osfameron> copumpkin: coremembering?
13:03:36 <FunctorSalad> copumpkin: I wonder what the full story behind this "ADTs are both initial algebras and final coalgebras" thing is
13:03:39 <FunctorSalad> :)
13:03:54 <sjanssen> FunctorSalad: I don't think there is a rewrite rule for that, it is invalid
13:04:09 <copumpkin> FunctorSalad: hah :P I got tired of wondering what coinduction was so I looked it up, and it mentioned that codata was coninductively defined data, and was typically infinite... then I remembered someone saying that all haskell data was codata so now I'm confused :P
13:04:33 <FunctorSalad> sjanssen: not a rewrite rule I guess, but I remember seeing compiler output like "replacing (==) with pattern match"?
13:04:44 <conal> Baughn: i like the Bool & Set suggestions.  perhaps both could implemented on top of current interface plus button release events.
13:04:45 <roconnor> copumpkin: I think I said all data in Haskell is codata
13:04:51 <copumpkin> aha :)
13:04:55 <roconnor> copumpkin: but It's not entirely true I guess
13:04:58 <copumpkin> could you elaborate on that? I'm clueless
13:04:59 <copumpkin> oh
13:05:06 <dolio> In a complete partial order category, which is where Haskell gets its semantics, all initial algebras are final coalgebras and vice versa.
13:05:08 <Peaker> Baughn: I wrote a Set Key thing myself for Reactive
13:05:12 <roconnor> cause data Foo = Foo (Foo -> Bool) can be done in haskell
13:05:18 <roconnor> and who know WTF that is.
13:05:42 <roconnor> maybe dolio knows what it is.
13:06:14 <dolio> I've never been able to find a category theoretic proof of it, but the fact that you can define both fold and unfold for every suitable datatype using general recursion pretty much demonstrates it.
13:06:39 <Peaker> Baughn: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5007#a5007
13:06:40 <dolio> Considering only strictly positive types, and not the weird ones like roconnor just mentioned.
13:06:44 <vixey> dolio: can't it always be done by single step structural recursion?
13:06:56 <copumpkin> hmm
13:07:01 <Baughn> conal: That's fine. I need button release events to implement them anyway, so might as well export them
13:07:06 <Baughn> conal: I'll get you a patch soonish, then
13:07:08 <copumpkin> what would codolio say though?
13:07:34 <Peaker> conal: ah, you're here, here's a Behavior (Set Key) implementation on top of existing keyAction:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5007#a5007
13:08:11 <Baughn> conal, Peaker: Thanks, I'll just include that one then. :)
13:08:16 <FunctorSalad> dolio: the thing I find slightly confusing is that "infinite lists over A" is not an initial \X -> X * (A -> X -> X) algebra in Set
13:08:54 <Peaker> Baughn: note that Behavior loses the discrete nature of the events, though. Maybe its better to use accumE and get an event, instead
13:09:09 <mreh> how can i determine what GHC a certain library was distributed with?
13:09:31 <FunctorSalad> err wait that functor is wrong
13:09:37 <Baughn> Peaker: We're getting leftButtonReleased too, as per conal's request
13:09:44 <dolio> F X = A * X you mean?
13:09:49 <FunctorSalad> \X -> 1 + A*X
13:09:58 <dolio> Oh.
13:10:00 <Baughn> Peaker: So you can use eitherE
13:11:11 <FunctorSalad> I guess thinking about it in terms of sets is totally misleading
13:11:29 <vixey> yeah down with sets!!
13:12:03 * mmorrow gets his pitchfork and riot shoes on
13:12:37 <dolio> Well, to be honest, I'm not too familiar with that area of discussion, either. I'd have to think about it a bit.
13:13:09 <roconnor> start with Cale!  he is a set sympathizer!
13:13:15 <FunctorSalad> =)
13:13:18 <dolio> However, the initial algebra in Set would have to be such that for any other algebra, there's a total function to it from the initial algebra.
13:13:36 <FunctorSalad> dolio: yep, in Set the intial algebra is just the finite lists
13:14:07 <FunctorSalad> the infinite risks aren't "reached" by specifying an algebra
13:14:16 <FunctorSalad> so they could map to anything, hence no unique morphism
13:14:26 <FunctorSalad> *infinite lists
13:14:28 <dolio> And there's probably not always a total function from the set of possibly infinite lists to other appropraite sets, so that's why it isn't initial.
13:15:06 <dolio> Like, for instance, foldr (+) 0 :: [Natural] -> Natural.
13:15:13 <roconnor> I wish I knew what the semantics for data types in haskell were.
13:15:43 <roconnor> @type foldr (+) 0 :: [Natural] -> Natural.
13:15:44 <lambdabot> parse error on input `.'
13:15:46 <FunctorSalad> dolio: there exist plenty of total functions, but you have to arbitrarily choose the image of infinite lists
13:15:47 <roconnor> @type foldr (+) 0 :: [Natural] -> Natural
13:15:48 <lambdabot> [Natural] -> Natural
13:16:05 <roconnor> dolio: Haskell's Natural contains infinity
13:16:09 <roconnor> @type infinity
13:16:11 <lambdabot> Natural
13:16:16 <Beelsebob> wow, Haskell is green today
13:16:28 <FunctorSalad> (or rather, you get to make a choice for every equivalence class of infinite lists, where two lists are equivalent if they have the same tail eventually)
13:16:29 <dolio> FunctorSalad: Well, yes, but they have to satisfy certain laws to qualify as algebra homomorphisms.
13:17:14 <dolio> roconnor: Yes, but we're talking about Set, not Hask.
13:17:19 <TonyTheTiger> is this stuff true about haskell?
13:17:20 <TonyTheTiger> http://uncyclopedia.wikia.com/wiki/Haskell
13:17:43 <pumpkin> lol
13:17:50 <roconnor> dolio: didn't you see the pitchforks?
13:17:54 <FunctorSalad> dolio: hmm right, if the algebra we map to has operations nil and cons, then we need f [] = nil and f (x:xs) = cons x (f xs)
13:18:08 <pumpkin> TonyTheTiger: "Uncyclopedia, the content-free encyclopedia"
13:18:11 <FunctorSalad> dolio: so I think you're right that morphisms may not exist (not sure)
13:18:19 <nagnatron> lmao
13:18:29 <dolio> roconnor: We're throwing out Set? Then I guess we won't giving semantics to our total languages. :)
13:18:50 <pumpkin> > fix$(<$>)<$>(:)<*>((<$>((:[{- OH MY GOD IT'S A COMMENT!!! -}])<$>))(=<<)<$>(*)<$>(*2))$1
13:18:53 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
13:18:56 <pumpkin> lol
13:18:58 <roconnor> dolio: not using Set we won't.
13:19:20 <SamB> dolio: Total langauges don't use *that* Set
13:19:41 <TonyTheTiger> pumpkin: funny. :)
13:19:46 <roconnor> dolio: we use type theory for our semantics.
13:19:49 <dolio> What Set do they use, other than the category of sets and total functions?
13:19:56 <roconnor> dolio: which is great because we are defining type theory.
13:20:02 <roconnor> dolio: makes it much easier.
13:20:05 <[bjoern]> I had trouble coming up with the right signature for this function (or have some other problem i have yet to debug...)
13:20:06 <[bjoern]> basically i want f(List of triples of X, list of X, list of triples of X) maps to a list of triples of X  (X in this case is Int)
13:20:07 <SamB> dolio: they don't use sets from set theory!
13:20:21 <dolio> That doesn't answer my question.
13:20:36 <[bjoern]> I get "Occurs check: cannot construct the infinite type: x = [x]"
13:20:51 <FunctorSalad> dolio: you're right, "foldr (+) []" with domain the infinite lists doesn't exist in Set. if x = cycle [1], then we have 1:x == x, but there's no natural fx such that 1+fx==fx
13:20:54 <SamB> they use more constructive things
13:20:58 <roconnor> [(x,x,x)] -> [x] -> [(x,x,x)] -> [(x,x,x)]
13:21:07 * [bjoern] tries
13:21:27 <sjanssen> [bjoern]: the error probably means there is an error with your code, not the signature
13:21:40 <FunctorSalad> btw guys I really didn't mean to start a Set vs. Type Theory war ;)
13:21:41 <pumpkin> that's an odd signature
13:21:41 <pumpkin> what does it do?
13:21:42 <[bjoern]> Yeah, ideas how to debug that?
13:21:55 <roconnor> [bjoern]: I'm assuming that you rewrite your function in the usual curried style.
13:21:59 <dolio> FunctorSalad: Right. So I think that shows that the initial algebra of 1 + A*X in Set doesn't have infinite lists.
13:22:13 <mreh> are they going to bundle cabal with GHC soon?
13:22:22 * roconnor bets [bjoern] is dealing with colour.
13:22:29 <pumpkin> mreh: nope, cabal-install comes with the platform though
13:22:36 <dolio> SamB: What category would you use if you want to talk about the initial algebra semantics of a total functional programming language?
13:22:39 <FunctorSalad> *"foldr (+) 0" actually
13:22:39 <dcoutts_> mreh: that's what the platform does
13:22:42 <pumpkin> mreh: the cabal infrastructure already comes with ghc
13:22:42 <[bjoern]> no, the triples are weighted edges in a graph
13:22:47 <Berengal> System.IO.Unsafe.Really.IMeanIt.reallyReallyAbsurdlyUnsafePerformIOShameOnYou
13:22:47 <roconnor> damn
13:22:47 <vixey> FunctorSalad: was there a war and I missed it?
13:22:54 <SamB> dolio: dunno!
13:22:55 <mreh> pumpkin: but i still need the other three packages
13:23:02 <dolio> The one I've typically seen is Set.
13:23:05 <roconnor> [bjoern]: you should paste your code
13:23:07 <roconnor> @paste
13:23:07 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:23:10 <mreh> i'm trying to build cabal myself
13:23:10 <SamB> I didn't haven't even failed category theory yet!
13:23:31 <lysgaard> vixey: If you look at the bottom of the hpaste, "instance Calculate" you see that i try to find special cases for the expressions eg: a * 1 = a. How do i make that part work
13:23:32 <SamB> I have yet to discover where I might be able to attempt this feat
13:23:34 <pumpkin> mreh: the bootstrap script doesn't work?
13:23:35 <dcoutts_> mreh: you can use the bootstrap script to automate that
13:23:44 <mreh> okay
13:23:55 <dcoutts_> @quote stereo
13:23:55 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
13:23:59 <dcoutts_> bah
13:24:04 <vixey> lysgaard: to write something like this I would use a fold
13:24:04 <FunctorSalad> vixey: seemed like it was about to start, people already had their riot shoes out
13:24:16 <SamB> dcoutts: ooh, I like it!
13:24:17 <SamB> variety
13:24:20 <mreh> pumpkin, dcoutts_: i have 6.8.3, and i've been told that i have to do it manually
13:24:29 <hydo> Does the gitit author happen to hang out here by chance?  I thought I'd ask before I sent him email.
13:24:44 <SamB> hydo: would that be gwern?
13:24:48 <dcoutts_> mreh: the bootstrap script will work fine with 6.8.x
13:24:48 <mreh> atleast that's what RHW says
13:24:51 <Heffalump> SamB: no
13:24:57 <mreh> RWH
13:25:01 <mmorrow> the gitit guy is a philosophy professor :)
13:25:06 <hydo> SamB: jmacfarlane
13:25:10 <SamB> oh.
13:25:10 <lysgaard> Would you mind explaining please?
13:25:10 <FunctorSalad> SamB: of course Set would be unnecessarily large because countable sets should suffice for the semantics of a programming language?
13:25:17 <hydo> ah, so probably doesn't hang out on irc. hehe
13:25:20 <dcoutts_> mreh: right, RWH was published before the bootstrap script
13:25:20 <SamB> does gwern at least hack on gitit a lot ?
13:25:22 <FunctorSalad> but I don't see why you couldn't use it
13:25:32 <Heffalump> SamB: yes, or at least on filestore which is closely related
13:25:33 <SamB> hydo: uh, but that sounded like an IRC nick to me!
13:25:52 <hydo> SamB: I was abbreviating his name... for reasons still unkown to me.
13:25:56 <SamB> so ... since when do philosophy professors know how to program ?
13:26:09 <lysgaard> vixey: You mean like folding over the expression?
13:26:10 <ent20py1> since prolog :P
13:26:14 <SamB> much less in Haskell!
13:26:26 <Eelis> is there a way to get cabal to copy a directory in whole when installing? i tried putting "data-files: thedir" in my .cabal, but this produces "Setup.hs: thedir: copyFile: inappropriate type (is a directory)"
13:27:00 <FunctorSalad> roconnor: are you saying that the problem with "data Foo = Foo (Foo -> Bool)" is that the functor is contravariant? hmm
13:27:07 <Baughn> conal: Probably a reactive issue; it occurs to me that flipFlop should not generate a new (internal) event when it does not, in fact, flop
13:27:22 <dcoutts_> Eelis: you can use a limited form of wildcard in Cabal 1.6 and later
13:27:34 <Eelis> dcoutts_: yes, i noticed, but that would actually be very painful for my case
13:27:47 <dcoutts_> Eelis: but there's deliberately no recursive directory copy
13:27:55 <Eelis> dcoutts_: what's the rationale?
13:27:58 <Eelis> annoying people?
13:28:08 <dcoutts_> Eelis: accidentally picking up too many files
13:28:10 <Baughn> conal: Anyway. Patch: http://brage.info/~svein/reactive-glut.patch
13:28:12 <Heffalump> debris
13:28:27 <Eelis> dcoutts_: sigh.
13:28:35 <conal> Baughn: "internal" event?
13:28:58 <[bjoern]> Okay, figured it out. needed to replace a 'a:b' by '(a:b)'
13:29:00 <Baughn> conal: Whatever causes the action to be re-executed (well, "change") in action <$> behaviour
13:29:06 <Eelis> dcoutts_: i guess i'll have to override some more hooks then. but seriously, this is plain stupid
13:29:16 <roconnor> [bjoern]: a common error
13:29:34 <dcoutts_> Eelis: if you can think of a better balance in expressiveness vs safety then do say so
13:29:59 <Baughn> conal: You'll see what I mean if you try adaptSimple "" (print <$> keyboard)
13:30:04 <Peaker> Baughn: wouldn't it be nicer to define those events in terms of the GLUT events, rather than have many events created with legacy adapters?
13:30:09 <Eelis> dcoutts_: well, personally i think the current solution is completely unbalanced. it should just copy the directory. making life miserable for people who actually have a need for the functionality, just to protect those that don't, is silly
13:30:15 <FunctorSalad> roconnor: how about F: Endo(Hask * Hask^op),    F(X,Y) = (Y -> Bool, X -> Bool)? but that's absolutely ad-hoc ;)
13:30:40 <lukeo05> [bjoern]: i have done that a ridiculous amount of times, and still keep doing it. the error message is always never helpful to realize the stupid error.
13:31:06 <Peaker> > (maxBound :: Int) + 1
13:31:10 <lambdabot>   -9223372036854775808
13:31:16 <Peaker> yairchu: here's an overflow
13:31:16 <dcoutts_> Eelis: suppose we added "data-files: dir/" should it include hidden files etc too?
13:31:29 <conal> Baughn: maybe you mean that stepper isn't optimized for event occurrences that switch from a value to the same value.
13:31:38 <mreh> so am i bootstrapping cabal, or cabal-install?
13:31:38 <Baughn> Peaker: Probably, yes. Might be nice to have the callbacks stuff their events directly into an FRP Event
13:31:39 <Eelis> dcoutts_: yes, the whole thing. i like the idea with the trailing / !
13:31:59 <Baughn> conal: I might. I didn't check to see how flipFlop is implemented. ;)
13:32:22 <Peaker> > 600851475143::Int
13:32:24 <lambdabot>   600851475143
13:32:52 <dcoutts_> Eelis: and we'd have to check for symlinks (and not follow them, or at least check for no cycles) etc etc
13:33:01 <Peaker> > showHex 600851475143 ""
13:33:03 <lambdabot>   "8be589eac7"
13:33:06 <conal> Baughn: FRP isn't really meant to be used with IO (e.g., print).  i regrettably took a short-cut and exposed and IO interface, but i really mean something more like O.
13:33:26 <dcoutts_> Eelis: which is the other problem, safe recursive dir traversal is not trivial or portable
13:33:28 <Eelis> dcoutts_: yes, some work would be involved. i never said it would be free
13:33:35 <conal> Baughn: in other words, it's my inteface-bad that allows you to notice the missing optimization.
13:33:42 <dcoutts_> Eelis: feel free to file a feature request :-)
13:33:44 <Heffalump> conal: wouldn't print be O?
13:33:48 <Eelis> dcoutts_: alright, i will
13:33:48 <conal> i'll remove the IO stuff at some point.
13:34:08 <Baughn> conal: How's that going to work? Wrapping every function in the opengl library? -_-
13:34:33 <conal> Heffalump: not in the sense i mean.  more like idempotent actions.  though that's probably not quite it either.
13:34:49 <Baughn> Besides, I might genuinely want to do IO when a user presses some button in my ui
13:34:50 <Peaker> a "denotational debugger" for Haskell could be useful, an "operational debugger" could be difficult (hard to debug lazy code as execution jumps all over the place), but if you just debug the values, and not how they're computed, its easy and useful
13:34:56 <conal> an example is updating a visual display, such as a gui widget.
13:35:02 <skorpan> what does this mean in a type signature?  (Tok Token ~ Element syntax) => ..
13:35:13 <Heffalump> conal: so O within the scope of the reactive thing
13:35:22 <conal> Baughn: a semantic mis-fit for behaviors, then.
13:35:22 <Heffalump> skorpan: type equality
13:35:26 <Heffalump> it's a new type families thing
13:35:43 <skorpan> Heffalump: so it means kind of like Tok Token = Element?
13:35:47 <Heffalump> yes
13:35:52 <Baughn> conal: Well, of course I'll make my IO idempotent too
13:36:04 <Heffalump> well, Tok Token = Element syntax in the case you quoted
13:36:09 <mreh> oh, can't I bootstrap on Windows?
13:36:18 <Heffalump> one of Tok or Element would have to be a type function for it to be satisfiable
13:36:23 <Baughn> conal: But.. right, I see what you mean. I did mention I'm not experienced with FRP. :)
13:36:26 <conal> Baughn: oh.  what'll your idempotent IO be like?
13:36:34 <Baughn> conal: Reading files?
13:38:21 <conal> Baughn: oh, hm.  i guess you'd have to figure out how you want to relate file-reading to the *semantic* framework of FRP.  For instance, files as (immutable) behaviors or events.
13:38:35 <conal> Baughn: that's what i'd do.
13:38:55 <Baughn> conal: I'm still trying to work out how to actually do opengl output. :/
13:39:31 <Baughn> I certainly don't want to re-render a frame every time the user does any input whatsoever
13:39:49 <dolio> FunctorSalad: I've read my fair share of papers on categorical semantics, and have another share of papers I haven't yet figured out. But I've never seen a single one that specifically treats types like 'data Foo a = Foo (Foo a -> a)'.
13:40:29 <Baughn> conal: Use input events/behaviors to alter a global state structure and hook framePass? ..that sounds remarkably yucky
13:40:31 <FunctorSalad> dolio: interesting
13:40:32 <dolio> FunctorSalad: All the ones on total type theories simply disallow it, because it introduces bottom.
13:40:54 <vixey> what do you want to know about Foo = Foo -> a?
13:40:56 <conal> Baughn: me neither.  reactive tracks all changes to the ultimate output.  you wouldn't get new output until there was a *relevant* input event.
13:41:09 <vixey> L = L -> L is pretty well studied (lambda calculus)
13:41:19 <conal> Baughn: yucky indeed
13:41:23 <FunctorSalad> dolio: the polymorphism in a isn't the problem, is it?
13:41:25 <dolio> But they also disallow 'data Foo a = Foo ((Foo a -> a) -> a)', even though I've never seen that lead to a proof of false (it's positive, but not strictly positive).
13:41:39 <dolio> FunctorSalad: No, the Foo in the negative position is the problem.
13:42:00 <Baughn> conal: My main problem is that, as far as I can tell, that ultimate output is hidden inside adaptSimple somewhere
13:42:20 <vixey> proof theoretic strength of strictly positive is equiv. to that of positive/monotone I think
13:42:41 <vixey> doesn't mean you don't have to bend over backwards sometimes to encode things, but still
13:43:27 <vixey> what is the question about Foo though?
13:43:28 <dolio> FunctorSalad: The problem is that Foo lets you type the Y combinator.
13:43:39 <Baughn> conal: Well, you wrote it. How do you do it?
13:43:44 <dolio> vixey: What is its semantic basis in Haskell? :)
13:44:01 <FunctorSalad> *nod*
13:44:25 <vixey> dolio, I'm not sure what that means exactly (kinda vauge), you can justify its existence in terms of lambda calculus though
13:44:32 <conal> Baughn: have you read "simply efficient functional reactivity"?
13:45:07 <tibbe> can CPS transformations be done mechanically for any function? I'm trying to CPS a state like monad but I'm having difficulties
13:45:15 <vixey> tibbe, yes
13:45:17 <dolio> vixey: Well, Haskell semantics are typically given in terms of initial algebras of certain kinds of functors. But I think Foo corresonds to the wrong kind of functor.
13:45:30 <dolio> Continuous functors, maybe?
13:45:47 <Baughn> conal: Not thoroughly. The implementation parts, not at all.
13:45:51 <FunctorSalad> it's not an endofunctor so you can't have algebras for it ;)
13:46:09 <FunctorSalad> I made up an endofunctor for it above, but don't know whether that's the right one
13:46:15 <roconnor> tibbe: edwardk's Ran package will automagically CPS transform anything for you.
13:46:35 <tibbe> roconnor: I'm brain is too small for that library
13:46:35 <vixey> dolio, I guess that's going beyond what I know -- don't know how initial algebra semantics work for non-positive typess
13:47:04 <roconnor> tibbe:  automagic
13:47:06 <FunctorSalad> reminds me of the complex numbers somehow
13:47:15 <tibbe> roconnor: if I gave you two possible definitions of the same data type and the definition of a function that works for the non-CPS version could you write a CPS version?
13:47:23 <roconnor> tibbe: just do Ran (StateT whatever)
13:47:28 <roconnor> and it goes
13:47:30 <roconnor> ... in theory
13:47:31 <tibbe> roconnor: I still would like to understand what I'm doing
13:47:35 <roconnor> Never tried it myself :P
13:47:40 <conal> Baughn: it's in there.  can be hard to find, as the paper is pretty dense.  see Section 8 (Monotonic sampling).
13:47:41 <tibbe> roconnor: it's not actually the state monad
13:47:54 <roconnor> sure sure, any monad built from transformers
13:49:18 <lukeo05> What is the mathmatical property called when an operator is spread across other operators. like when 3*(2+4) = 3*2 + 3*4
13:49:21 <mmorrow> tibbe: roughly, you just take your monad, make it a FooT, then
13:49:25 <mmorrow> @unmtl StateT s (Cont o) a
13:49:25 <lambdabot> s -> (a -> s -> o) -> o
13:49:31 <mmorrow> and forll o. the 'o'
13:49:31 <roconnor> lukeo05: distributivity
13:49:35 <mmorrow> *forall
13:49:42 <lukeo05> roconnor: cheers! massive mind blank! :)
13:50:06 <mmorrow> newtype S s a = S (forall o. s -> (a -> s -> o) -> o)
13:50:10 <conal> Baughn: about your patch, would you do me a favor and add a Reactive trac entry with a description and either the patch or a URL for it?  this week i'm doing paper reviews and sorting out my summer plans (possible employment), and i'd like to make sure your patch doesn't fall through my mental cracks.
13:50:10 <dolio> FunctorSalad: This might have the answer: http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
13:50:23 <mmorrow> (the param order of (s -> a -> o) -> s -> o is nicer though)
13:50:29 <Baughn> conal: I can do that.
13:50:34 <dolio> FunctorSalad: Looks pretty heavy, though.
13:50:36 <conal> Baughn: thx :)
13:50:47 <Baughn> conal: No, thank you. :P
13:50:52 <FunctorSalad> *looks*
13:51:03 <Baughn> conal: This.. reactive is the sort of thing that should be a killer app for haskell
13:51:13 <conal> Baughn: :)
13:51:26 <tibbe> mmorrow: I'd like to understand how the function would be defined in "direct" style though
13:51:32 <dolio> FunctorSalad: That even appears to have a proof sketch that initial algebras are final coalgebras in the relevant category. :)
13:51:35 <mmorrow> tibbe: what function?
13:51:36 <tibbe> mmorrow: without using the automagic library
13:51:46 <mmorrow> tibbe: oh, that's how you'd do it
13:51:53 <dolio> But I've got places to be.
13:51:57 <tibbe> mmorrow: I'm trying to convert a function "take" to CPS sty;e
13:51:58 <mmorrow> tibbe: what is the def of your monad type?
13:52:10 <FunctorSalad> dolio: ok, cya
13:52:11 <tibbe> mmorrow: sec, preparing a paste
13:52:12 <mmorrow> (the not-yet-cps def)
13:52:13 <vixey> tibe do you have a definition of CPS?
13:52:14 <mmorrow> cool
13:53:35 <mmorrow> vixey: if you have a monad Foo, imagine that you make it a FooT foo m a , then flatten FooT foo (Cont o) a, and finally forall the 'o' inside the newtype
13:53:45 <vixey> huh?
13:53:50 <conal> Baughn: i've been hoping to find a commercial sponsor for Reactive after my unexpectedly disappeared last Fall.  also, i got burnt out on debugging some subtle laziness issues (always hard for me in haskell), and am hoping to get some help & motivating camaraderie.  when the market plunged, having or preparing for some income suddenly became an important to me.
13:53:51 <mmorrow> that is the def of "CPS" here
13:54:06 <mmorrow> State s a = State (a -> (a, s))
13:54:14 <mmorrow> StateT s s a = StateT (a -> m (a, s))
13:54:19 <mmorrow> @unmtl StateT s (Cont o) a
13:54:19 <lambdabot> s -> (a -> s -> o) -> o
13:54:21 <tibbe> newtype Iteratee a = Iteratee
13:54:21 <tibbe>     { unIteratee :: forall r. (a -> Stream -> Result r) -> Stream -> Result r }
13:54:25 <mmorrow> newtype S s a = S (forall o. s -> (a -> s -> o) -> o)
13:54:53 <mmorrow> ah, ok. so that's essentially state
13:54:56 <Peaker> does @unmtl know some specific MT's?
13:55:04 <mmorrow> maybe do
13:55:15 <mmorrow> newtype Iteratee a = Iteratee { unIteratee :: forall r. (a -> Stream -> r) -> Stream -> r
13:55:16 <mmorrow> and then
13:55:17 <roconnor> @unmtl ContT o (State s) a
13:55:17 <lambdabot> (a -> s -> (o, s)) -> s -> (o, s)
13:55:20 <roconnor> :/
13:56:22 <mmorrow> runIteratee :: Iteratee a -> (a -> Stream -> Result o) -> a -> Stream -> Result o
13:56:28 <mmorrow> or, provide a default
13:56:32 <mmorrow> (a -> Stream -> Result o)
13:58:26 <mmorrow> err, did you mean
13:58:49 <mmorrow> newtype Iteratee a = Iteratee { unIteratee :: forall r. (a -> Stream -> Result r) -> a -> Stream -> Result r }
13:58:50 <mmorrow> ?
13:59:08 <mmorrow> oh no, n/m
13:59:21 * mmorrow just confused himself for a second there
14:00:36 <mmorrow> runIteratee :: Iteratee a -> (a -> Stream -> Result o) -> Stream -> Result o; runIteratee (Iteratee m) k = m k
14:00:48 <Baughn> conal: Can I assume that the way I've defined these behaviors makes them reactive values?
14:01:07 <mmorrow> get :: Iteratee Stream; get = Iteratee (\k s -> k s s)
14:01:35 <mmorrow> etc
14:02:38 <conal> Baughn: i don't understand your question.  which behaviors?  and if you mean "reactive values" in the sense of my paper and implementation, then behavior & reactive value are two different (but very related) types.
14:02:43 <tibbe> mmorrow: yes essentially State
14:03:37 <tibbe> mmorrow: I'm trying to write a nesting of Iteratee's
14:04:07 <mmorrow> tibbe: here's the def of State i use http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2446#a2446
14:04:16 <Baughn> conal: The mouse/keyboard behaviors.. hm, right you are. I really need to read the module lists more closely.
14:04:32 <mmorrow> tibbe: i think your iteratee would just be the specialization of that S
14:04:38 <mmorrow> tibbe: oh? how do you mean?
14:04:54 <tibbe> mmorrow: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5008#a5009
14:05:00 <Baughn> conal: Okay. I guess I'm asking whether, if I create a behavior via flipFlop, it's optimized to work as a reactive value
14:05:02 * mmorrow looks
14:05:09 <tibbe> mmorrow: I can write most combinators I need but "take" is wrong
14:05:16 <tibbe> mmorrow: it makes my head spin a bit
14:05:57 <tibbe> mmorrow: (the definition you see there uses a non-CPS definition of Iteratee, let me include that as well)
14:06:29 <mmorrow> hmm, wrong because it doesn't do what you want correctly, or because you want an Iteratee a instead of an Iteratee (Iteratee a)?
14:06:36 <mmorrow> (if the latter, you can just join)
14:07:33 <vixey> Iteratee is a monad?!
14:07:42 <conal> Baughn: flipFlop has a very simple definition in terms of stepper.  and stepper always creates behaviors that propagate only when the event occurs.  however, there is no implementation that restricts propagation to event occurrences that actually *change* the value.  and flipFlop suffers particularly, simply because it's boolean and so many occurrences are non-changes.
14:08:07 <augustss_> @seen dcoutts
14:08:08 <lambdabot> dcoutts is in #haskell-soc, #haskell, #ghc, #gentoo-haskell, #haskell-overflow, #darcs and #haskell-in-depth. I don't know when dcoutts last spoke.
14:08:18 <dcoutts_> hia augustss_
14:08:30 <augustss_> Hi!
14:08:48 <copumpkin> mmorrow: I got me official access to the ARM documentation btw! now I just need some time
14:08:52 <augustss_> dcoutts_: Are there any instructions on how to build gtk2hs on windows?
14:08:55 <conal> Baughn: oops -- not boolean, but rather is often be used in a two-valued way.
14:08:57 <mmorrow> copumpkin: ooh, cool
14:09:43 <Gracenotes> @djinn Either () ()
14:09:43 <conal> Baughn: i don't know how make reactivity in general do that change-only optimization, without restricting to Eq types.
14:09:44 <lambdabot> f = Left ()
14:10:02 <dcoutts_> augustss_: yes...
14:10:16 <augustss_> dcoutts_: on the web site?
14:10:29 <tibbe> mmorrow: I want Iteratee (Iteratee a)
14:10:32 <dcoutts_> augustss_: http://haskell.org/gtk2hs/archives/2005/06/24/building-from-source-on-windows/
14:11:16 <tibbe> mmorrow: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5008#a5010 <-- Added my previous definition of Iteratee which I used for "take"
14:11:41 <dcoutts_> augustss_: it's a similar kind of procedure to building ghc on windows, using msys etc
14:11:59 <p_l> copumpkin: working on GHC for ARM?
14:12:01 <augustss_> dcoutts_: i'll give it a try
14:12:20 <copumpkin> p_l: nope, just a library for working with it (a bit like harpy)
14:12:20 <dcoutts_> augustss_: the thing to watch out for is that we typically do not run make install, rather we generate a relocatable install image and use that as the basis for the installer. So make install directly probably does not work.
14:12:29 <copumpkin> p_l: maybe someday :)
14:13:12 <dcoutts_> augustss_: generating the installer is not especially tricky, but needs innosetup (another free download). There are scripts in the gtk2hs darcs repo to automate the whole lot.
14:13:16 <augustss_> dcoutts_: ok.  do the finalizers work with 6.10.2?
14:13:20 <Heffalump> what do harpy and libraries like it have over LLVM?
14:13:25 <dcoutts_> augustss_: that's my understanding, yes
14:13:32 <Heffalump> well, apart from precise control over the instructions
14:13:40 <augustss_> Heffalump: light weight
14:14:45 <p_l> copumpkin: Well, I was thinking of helping to port SBCL to ARM ("ARM System Architecture" laying near me :D)
14:14:52 <tibbe> mmorrow: I owe you a better example
14:14:57 <copumpkin> p_l: sbcl?
14:15:03 <copumpkin> oh, a lisp?
14:15:06 <p_l> copumpkin: Steel Bank Common Lisp
14:15:14 <adamvo> any technical reason harpy doesn't work on x86_64 (last time I looked at it)?
14:15:24 <tibbe> mmorrow: I'm trying to put together two minimal implementation, one with the old definition of Iteratee and one with the new one
14:15:29 <Baughn> @index (:+->)
14:15:30 <lambdabot> bzzt
14:15:52 <augustss_> adamvo: you probably need to switch the CPU to 32 bit mode
14:15:55 <p_l> Baughn: ... biribiri? (Couldn't help it)
14:16:12 <tibbe> mmorrow: I was hoping that given IterateeOld, takeOld, and IterateeNew coming up with the definition of takeNew shouldn't be too difficult
14:16:49 <mmorrow> tibbe: just realized why it's broken (tried to load in ghci). i'll play around with it
14:16:54 <Baughn> p_l: Not yet, to my great annoyance
14:17:04 <tibbe> mmorrow: thanks
14:17:06 <tibbe> mmorrow: I
14:17:18 <tibbe> mmorrow: I'm working on those minimal examples in the mean time
14:25:45 * Baughn rewrites a network server using reactive in half the lines
14:26:00 <copumpkin> :o
14:26:05 <copumpkin> what does it do?
14:26:16 <Baughn> Streams fanfiction. ^^;
14:26:24 <copumpkin> sounds fun
14:26:26 <Baughn> Well, it was a class exercise
14:26:28 <copumpkin> making it public?
14:26:29 <copumpkin> ah
14:29:07 <tibbe> mmorrow: got both definitions
14:29:09 <tibbe> mmorrow: pasting
14:31:00 <TonyTheTiger> if I wanted to take an input before a function and after a function how would i do it? e.g 1 addn 2
14:31:10 <vixey> 1 `addn` 2
14:31:14 <tibbe> mmorrow: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5008#a5011
14:31:31 <TonyTheTiger> how would i do the type signature and define the actual funtion?
14:31:47 <vixey> x `addn` y = 3
14:31:51 <TonyTheTiger> vixey: would that be... 1 `addn` 2 = 3
14:32:00 <TonyTheTiger> oh ok was too slow :(
14:34:48 <TonyTheTiger> im trying what you said, however i get an error
14:34:56 <TonyTheTiger> here is my type signature and actual code
14:34:58 <TonyTheTiger> v' :: Bool -> Bool -> Bool True `v'` False = True
14:35:08 <TonyTheTiger> v' :: Bool -> Bool -> Bool
14:35:13 <TonyTheTiger> True `v'` False = True
14:35:24 <TonyTheTiger> ignore the first line
14:36:42 <TonyTheTiger> anyone?
14:37:31 <c_wraith> What's the error?
14:37:55 <gnuvince_> @index ensure
14:37:56 <lambdabot> bzzt
14:37:58 <gnuvince_> @index check
14:37:58 <lambdabot> Control.Concurrent.STM, Test.QuickCheck, Debug.QuickCheck
14:38:43 <Shurique> I'm trying to install reactive-fieldtrip, but cabal just exits with this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5012#a5012 -- any ideas?
14:40:03 <Gracenotes> :>
14:40:04 <Peaker> Shurique: its a bug in the reactive related .cabal files. Add "stream<=0.3.0" to the install command line
14:40:20 <Peaker> Shurique: though I think fieldtrip fails to compile on ghc>=6.10.2 anyway
14:40:29 <Gracenotes> <:>_<:>
14:41:02 <monadic_kid> you'll get that error message from reactive package, you can constrrain the version
14:43:01 <monadic_kid> Shurique: just to cabal install "--constraint=<packacge-name-version-number>"
14:43:22 <Peaker> or "cabal install reactive-fieldtrip stream<=0.3.0" should work, iirc
14:43:33 <Apocalisp> Good lord http://www.haskell.org/haskellwiki/Yhc_web_service
14:43:47 <tibbe> mmorrow: still having a look?
14:44:08 <Shurique> yeah, I did what Peaker suggested
14:44:12 <Shurique> and fieldtrip did fail to build
14:44:30 <Shurique> maybe I'll revert to 6.10.1 then
14:44:49 <Peaker> Shurique: 6.10.1 has some killer bugs w.r.t Reactive itself
14:45:11 <TonyTheTiger> hi get this error, ERROR file:.\hugs.hs:40 - Syntax error in declaration (unexpected `::') for trying to do... (v') :: Bool -> Bool -> Bool
14:45:12 <Shurique> hm :/
14:45:22 <TonyTheTiger> im trying to create a disjunction operator
14:45:31 <Peaker> Shurique: I think that non-fieldtrip reactive stuff do work with newer ghc's
14:46:32 <tibbe> TonyTheTiger: use http://www.hpaste.org to paste your code and error message. That will help people help you
14:47:44 <TonyTheTiger> tibbe: there is no need to pastebin as the code is 3 line
14:47:46 <TonyTheTiger> lines*
14:47:56 <Shurique> well... are these packages maintained actively? i.e. can we expect fixes in the near future? :)
14:48:44 <TonyTheTiger> tibbe: but here is the paste just incase
14:48:45 <TonyTheTiger> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5013#a5013
14:49:45 <tibbe> TonyTheTiger: never hurst
14:49:47 <tibbe> hurts
14:49:52 <tibbe> bed time for me
14:49:53 <tibbe> gnight
14:51:26 <TonyTheTiger> anyone please help?
14:54:07 <vixey> with what?
14:54:20 <mmorrow> tibbe: i'm not sure if the 'take' that you're after can be written with that particular combo of Stream/Result/Iteratee. i'm not positive what combo you'd need to do it either.
14:54:34 <mmorrow> :(
14:54:40 <tibbe> mmorrow: ok, thanks anyway
14:54:51 <tibbe> mmorrow: I'll try to see if what Oleg had in mind
14:54:53 <tibbe> mmorrow: gnight
14:55:04 <mmorrow> i can't seem to be able to write the case where you need another Stream in order to take a certain amount
14:55:29 <olsner> hmm, how do you express type inequality?
14:55:39 <Apocalisp> TonyTheTiger: v' is not infox
14:55:40 <olsner> I'm trying to make a parametric monad where certain operations make the out-state type different from the in-state such that some operations will be forbidden
14:55:41 <Apocalisp> infix
14:55:46 <mmorrow> (in fact, i tried to solve this exact problem myself at one point, and never came up with a solution. i think you need a real Cont monad layered in somewhere or something)
14:55:57 <TonyTheTiger> Apocalisp: what is infix?
14:56:07 <Apocalisp> @let True v' True = True
14:56:09 <lambdabot>  <local>:3:0:
14:56:09 <lambdabot>      Constructor `True' should have no arguments, but has been ...
14:56:11 <dqd> TonyTheTiger: Add the backtics around the function name
14:56:22 <Apocalisp> @let v' True True = True
14:56:23 <lambdabot>  Defined.
14:56:26 <Apocalisp> see?
14:56:29 <dqd> > let
14:56:29 <dqd> > let True v' True = True
14:56:30 <lambdabot>   <no location info>: parse error on input `}'
14:56:31 <lambdabot>   <no location info>: parse error on input `;'
14:56:32 <dqd> Blah.
14:56:55 <dqd> > let True `v'` True = True in True `v'` True
14:56:56 <lambdabot>   True
14:56:59 <TonyTheTiger> im sorry i dont quite understand
14:57:03 <TonyTheTiger> im pretty new to haskell
14:57:26 <aleperalta> TonyTheTiger: add the backquotes
14:57:31 <aleperalta> TonyTheTiger: http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=5013#a5014
14:57:38 <Elly> mmm, infix operators
14:57:44 <TonyTheTiger> I was using backquotes before
14:57:46 <Apocalisp> @let True `v'` True = True
14:57:46 <aleperalta> also remove ()
14:57:47 <lambdabot>  <local>:3:0:
14:57:47 <lambdabot>      Warning: Pattern match(es) are overlapped
14:57:47 <lambdabot>               In...
14:57:54 <Apocalisp> betterer
14:58:18 <aleperalta> TonyTheTiger: not in the paste I saw... maybe old
14:58:34 <TonyTheTiger> says i have a problem with my declaration type
14:58:36 <jad4> is there some,  applyN :: Int -> (b -> b) -> b -> b
14:58:45 <jad4> applyN n f a =  foldr ($) a (replicate n f)
14:59:00 <Apocalisp> TonyTheTiger: Yes, you have two problems. First, the parentheses around (v') in the type declaration. Second, the pattern matches use v' infix (in between terms). You can use functions infix by surrounding them with backticks though.
14:59:02 <jad4> was looking at prelude and can't find it :S
14:59:06 <TonyTheTiger> aleperalta: yeah thats just where i had was in my trial and error process
14:59:10 <jad4> my haskell knowledge is becoming rusty
14:59:14 <Peaker> @type let applyN n f a =  foldr ($) a (replicate n f) in applyN
14:59:15 <lambdabot> forall b. Int -> (b -> b) -> b -> b
14:59:33 <Apocalisp> > div 4 2
14:59:35 <lambdabot>   2
14:59:39 <Apocalisp> > 4 `div` 2
14:59:41 <lambdabot>   2
14:59:46 <Apocalisp> > 4 div 2
14:59:47 <TonyTheTiger> Apocalisp: so how would i do the type signature?
14:59:47 <lambdabot>       No instance for (Num ((a -> a -> a) -> t -> a1))
14:59:48 <lambdabot>        arising from th...
14:59:48 <Peaker> @type let applyN n f a =  iterate f a !! n in applyN
14:59:49 <lambdabot> forall a. Int -> (a -> a) -> a -> a
14:59:56 <FunctorSalad> jad4: isn't the RHS you gave perfectly fine? (don't think there's a library function for it)
15:00:02 <Apocalisp> TonyTheTiger: Remove the parens.
15:00:10 <jad4> FunctorSalad, yes it's perfectly fine
15:00:10 <mmorrow> @type \n -> foldr (.) id . replicate n
15:00:11 <lambdabot> forall a. Int -> (a -> a) -> a -> a
15:00:18 <TonyTheTiger> Apocalisp: would that also require the backticks??
15:00:26 <jad4> FunctorSalad, but I was almost sure it was provided
15:00:35 <FunctorSalad> > iterate (*2) 1 !! 7
15:00:36 <lambdabot>   128
15:00:42 <FunctorSalad> slightly shorter I guess
15:00:46 <Apocalisp> TonyTheTiger: Just put v' prefix.
15:01:23 <jad4> yes I guess iterate is a bit nicer
15:02:07 <TonyTheTiger> Apocalisp: It works, however im having to put backticks even in hugs when using it, e.g True `v'` False, is there a way i can have it so its just True v' False?
15:02:33 <Peaker> @type iterate
15:02:35 <lambdabot> forall a. (a -> a) -> a -> [a]
15:02:44 <Peaker> jad4: iterate is almost the type you need already, yeah :)
15:03:13 <mmorrow> with this one you don't need to build the list:
15:03:14 <mmorrow> @type \n -> foldr (.) id . replicate n
15:03:15 <Apocalisp> TonyTheTiger: You can use either (v True False) or (True `v'` False)
15:03:15 <lambdabot> forall a. Int -> (a -> a) -> a -> a
15:03:35 <TonyTheTiger> Apocalisp: and there is no way around this?
15:03:44 <Apocalisp> TonyTheTiger: If you rename v' to have only non-alphanumeric characters, you don't need the backticks.
15:04:03 <Apocalisp> > 4 / 2
15:04:04 <lambdabot>   2.0
15:04:14 <Apocalisp> @type /
15:04:15 <lambdabot> parse error on input `/'
15:04:15 <Apocalisp> @type div
15:04:17 <lambdabot> forall a. (Integral a) => a -> a -> a
15:04:20 <Apocalisp> @type (/)
15:04:22 <lambdabot> forall a. (Fractional a) => a -> a -> a
15:11:03 <Powerfool> hi
15:11:11 <agruman> i have "let sum = foldr + 0 h" where h is a list of Int, and then do "return sum" in a monadic function returning Int, why does ghc give me: "Couldn't match expected type `Int'      against inferred type `(a -> b -> b) -> b -> [a] -> b'"?
15:11:34 <vixey> agruman that's  (foldr) + (0 h) but you should hae foldr (+) 0 h
15:11:35 <Powerfool> I'm looking for the Haskell equivalent of the Stream library in Ocaml.
15:11:59 <poucet> Powerfool: what does it do?
15:12:07 <Powerfool> I've seen John Hughes' arrows paper, but also the Data.List.Stream module ...
15:12:16 <poucet> Powerfool: Maybe describe the features and we can point you inthe right direction?
15:12:35 <Powerfool> poucet: it's a generic library for streams
15:12:42 <poucet> Powerfool: what is a 'stream'?
15:12:44 <poucet> You mean a lazy list?
15:12:55 <poucet> something like
15:13:02 <Powerfool> something like that
15:13:02 <poucet> > let ones = 1 : ones in take 10 ones
15:13:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
15:13:04 <agruman> vixey: thanks alot, is it because of the function binding priorities that it gets that way?
15:13:12 <olsner> urgh, this is ugly, I can make it generate a distinct type by using a "data Break a"... so my "marker function" get the type break :: MyM s (Break s) ()
15:13:16 <poucet> Powerfool: due to laziness, lists are like streams
15:13:21 <vixey> it's because + is infix
15:13:22 <poucet> Powerfool: so perhaps you coudl be more specific?
15:13:28 <Powerfool> I see.
15:13:34 <agruman> vixey: ah ok
15:13:46 <Powerfool> I'm trying to write a stream filter in Haskell.
15:13:46 <augustss_> Powerfool: try using lists
15:14:33 <Powerfool> Basically, given an input stream, I want to find parts of the signal that cross a threshold level.
15:15:05 <Powerfool> The threshold level itself is variable in the sense that it is shifted by a delta upon such a crossing.
15:15:56 <olsner> look at that, it actually seems to work... it's some kind of type representation of a generation number, which you can use to mark data such that it can only be used within one generation
15:16:17 <olsner> I'd be much more impressed if I knew what I was doing though
15:16:38 <poucet> Powerfool: hmm, something like
15:17:02 <mle> Powerfool: deleting parts of the stream that don't qualify, or returning some sort of stream of booleans, or list of ranges?
15:17:05 <Powerfool> I'm not sure what the best way to write this is in Haskell. I need "state" (the threshold level), and the incoming data is "infinite". Can I do this recursively?
15:17:30 <poucet> let squares = repeat (\x -> x*x) [1..] in takeWhile (< 50) $ zip (subtract) squares (drop 1 squares)
15:17:37 <poucet> > let squares = repeat (\x -> x*x) [1..] in takeWhile (< 50) $ zip (subtract) squares (drop 1 squares)
15:17:38 <lambdabot>   Couldn't match expected type `[t1] -> t'
15:17:39 <Powerfool> mle: I'm basically only interested in the parts of the signal that exceed the threshold.
15:17:41 <vixey> Powerfool: Can't you just close over the threshold value?
15:17:58 <vixey> > cycle [1..10]
15:17:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6,7,8,9,10,1,2,3,4,5,6...
15:18:12 <vixey> > let threshold = 5 in filter (> threshhold) $ cycle [1..10]
15:18:13 <lambdabot>   Not in scope: `threshhold'
15:18:17 <poucet> > let squares = repeat (\x -> x*x) [1..] in takeWhile (< 50) $ zipWith (subtract) squares (drop 1 squares)
15:18:18 <vixey> > let threshold = 5 in filter (> threshold) $ cycle [1..10]
15:18:18 <lambdabot>   Couldn't match expected type `[t1] -> t'
15:18:19 <lambdabot>   [6,7,8,9,10,6,7,8,9,10,6,7,8,9,10,6,7,8,9,10,6,7,8,9,10,6,7,8,9,10,6,7,8,9,...
15:18:22 <vixey> like that ^
15:19:04 <Powerfool> vixey: the threshold is no cyclic. Maybe I misunderstand ...
15:19:05 <mle> vixey: he needs to consider multiple values at once though
15:19:11 <mle> a sliding window of some sort, perhaps
15:19:14 <poucet> mle: stick them all in a list
15:19:23 <poucet> and you acn easily make sliding indows
15:19:26 <vixey> the threshold is no cyclic.
15:19:30 <vixey> doesn't make sense
15:19:32 <mle> poucet: yep
15:19:49 <mle> Powerfool: cycle there is just used to generate data for you to see that it handles infinite lists....
15:19:49 <augustss_> Powerfool: just write a recursive function (over a list) that holds the state.  When you have that, you can ask again and people will be happy to show you how to do it without explicit recursion.
15:20:03 <poucet> > let slide n l = (take n l) : (slide n (drop 1 l)) in slide 5 [1..]
15:20:04 <lambdabot>   [[1,2,3,4,5],[2,3,4,5,6],[3,4,5,6,7],[4,5,6,7,8],[5,6,7,8,9],[6,7,8,9,10],[...
15:20:15 <Powerfool> an example: the incoming data is [1, 2, 5, 3, 6, 7, 4, 10], the initial threshold is [1-5, 1+5] (1 being the initial value, 5 the threshold distance)
15:20:35 <vixey>  [1, 2, 5, 3, 6, 7, 4, 10] isn't infinite
15:21:16 <Powerfool> then the first trigger occurs for the 7, and the threshold would be taken wrt the new "base" 7, i.e., [7-5, 7+5]
15:22:04 <poucet> ah
15:22:10 <poucet> so whenever you go outside the range, you get a new seed?
15:22:18 <Powerfool> augustss_: fair enough.
15:22:31 <Powerfool> poucet: that's right.
15:22:48 <poucet> Powerfool: recurseive function over an infinite list :)
15:23:52 <poucet> > let foo b (a:l) = if a < b - 5 then (a,b):foo a l else if a > b + 5 then (a,b):foo a l else (a,b):foo b l
15:23:53 <lambdabot>   <no location info>: parse error on input `;'
15:23:56 <Powerfool> BTW, I'm now trying to do any homework -- two friends and I are evaluating different functional languages for a project, and I got to pick Haskell. :)
15:24:01 <poucet> > let foo b (a:l) = if a < b - 5 then (a,b):foo a l else if a > b + 5 then (a,b):foo a l else (a,b):foo b l in foo 5 [1..10]
15:24:02 <lambdabot>   [(1,5),(2,5),(3,5),(4,5),(5,5),(6,5),(7,5),(8,5),(9,5),(10,5)* Exception: /...
15:24:09 <poucet> obviously you need a case for empty list
15:24:16 <poucet> > let foo b (a:l) = if a < b - 5 then (a,b):foo a l else if a > b + 5 then (a,b):foo a l else (a,b):foo b l in foo 5 [1,2,5,3,6,7,4,10]
15:24:18 <lambdabot>   [(1,5),(2,5),(5,5),(3,5),(6,5),(7,5),(4,5),(10,5)* Exception: /tmp/21466609...
15:24:32 <poucet> oh right, you start with the first element of the list
15:24:38 <poucet> wll easily to adapt
15:25:01 <Powerfool> poucet: thanks, that gives me a good start to play with.
15:25:36 <poucet> Powerfool: anyways, lists are like streams
15:26:33 <Powerfool> Good, back to coding and reading YAHT ... thanks everybody!
15:43:07 <jad4>  is there a way of searching functions by type?
15:43:24 <Cale> There's Hoogle
15:43:30 <Cale> @hoogle (a -> b) -> [a] -> [b]
15:43:31 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
15:43:31 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
15:43:31 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
15:43:42 <jad4> nice
15:43:51 <Cale> @where hoogle
15:43:52 <lambdabot> http://haskell.org/hoogle
15:44:24 <jad4> thanks Cale!
15:44:46 <Cale> No problem :)
15:45:29 * jad4 is out
15:59:48 <Philonous> How expensive are MVars / is it sensible to literally use millions of them for process communication?
16:01:51 <mle> Doesn't one of the haskell benchmark programs for the shootout do roughly that, on a smaller scale?
16:02:13 <Philonous> It spawns threads, but doesn't use MVars if I'm not mistaken
16:02:39 <mle> http://shootout.alioth.debian.org/u64q/benchmark.php?test=threadring&lang=ghc&id=2
16:02:59 <Axman6> Philonous: they're really fast
16:03:05 <Philonous> Ah ok, thanks
16:03:07 <Axman6> mle: that's my submission :)
16:03:44 <mle> Axman6: hehe, cool
16:04:16 <Axman6> Philonous: there are some good reasons why MVars are extremely fast, mostly because the RTS looks after all the syncronisation of threads putting and getting from them
16:04:27 <Philonous> That's great, because that means I don't have to scratch my head about how to properly parallelie. I'l' just throw a heap of threads and MVars at it :D
16:05:09 <Axman6> yep :)
16:05:26 <Cale> It's interesting, some people did an implementation of the concurrent ML primitives in terms of MVars and a bunch of benchmark programs ended up running faster than the O'Caml programs which had native support for those primitives.
16:05:55 <monochrom> haha
16:06:20 <Axman6> i read a lot of that paper, and couldn't figure out wtf was the point of it all
16:06:52 <Cale> http://www.cs.umd.edu/~avik/projects/cmllch/
16:07:00 <Philonous> I always thought it was funny how haskell endet up being faster on the shootout than O'caml where one of (or maybe the one) selling point of o'caml was speed
16:07:29 <mle> hm, that's using 6.8.1 too
16:07:46 <Cale> To be honest, I'm not sure I completely understand the intention of the CML primitives either.
16:07:53 <pejo> Philonous, I think another selling point of O'caml is that it isn't lazy.
16:08:16 <michaelgg> Hey there
16:08:25 <Cale> michaelgg: hi
16:08:27 <michaelgg> why would anyone use T1 T2 T3 for type parameters instead of a b c?
16:08:43 <Botje> at some point you run out of letters
16:08:48 <mle> michaelgg: machine generated code?
16:08:49 <Botje> other than that, no reason
16:08:56 <Cale> michaelgg: If they start with an uppercase letter, then they are type constructors...
16:08:57 <michaelgg> sigh
16:08:58 <monochrom> CML is a process algebra, isn't it?
16:09:02 <michaelgg> no i dont mean in haskell
16:09:06 <michaelgg> i mean in type systems in general
16:09:16 <michaelgg> like C# uses T because ... its lame
16:09:38 <monochrom> a b c is as lame as t1 t2 t3.
16:09:44 <Botje> because T is what they're used to from C++.
16:09:49 <monochrom> Besides, you should begin with t0.
16:09:50 <Cale> michaelgg: I don't see a particularly good reason not to allow at least somewhat unrestricted names.
16:09:58 <Botje> give the poor C++, C# and java programmers a rest! :)
16:10:06 <michaelgg> but for an OCaml derived language
16:10:10 <Cale> Unless you're doing something like formal logic, and you want to keep your alphabet small
16:10:12 <Philonous> Why t0 and not t(-inf) ;)?
16:10:16 <michaelgg> 'T1 'T2 'T3 makes no sense?
16:10:19 <Botje> t0.5
16:10:25 <Cale> But in that case, why not just make it t, t', t'', t''', ...
16:10:52 <Botje> michaelgg: C++ used T in templates and it stuck. (and I think T stands for typename)
16:10:53 <Philonous> Cale t''''' and t'''''' get rather hard to distinguish
16:10:56 <monochrom> t(-inf) will be supported in the next version.
16:11:03 <Cale> Philonous: Indeed, but the formal system won't care ;)
16:11:05 <Botje> Philonous: get the rainbow-quotes extension :)
16:11:46 <Botje> emacs has a feature where nestings of ( get a different colour
16:11:54 <Botje> no reason you couldn't apply that there
16:12:01 <Cale> Philonous: what's the next one after t(-inf)?
16:12:11 <michaelgg> thanks guys
16:12:25 <Philonous> Cale: t(-inf+1)
16:12:34 <Cale> :)
16:18:36 <Philonous> Botje: Would you mind to elaborate? The rainbow quotes extension to what?
16:20:24 <Botje> Philonous: http://lemonodor.com/images/pkhuong-sexpr-highlighting.jpg
16:20:31 <Botje> something like that, but applied to quotes ;)
16:22:18 * kyevan pasted http://pastie.textmate.org/private/k7qelcnmxystbzol294iaq
16:22:29 <kyevan> Oh hey, that works. :P
16:23:02 <kyevan> (Ignore that. It's just some code I was thinking about (and reading helps me think) when I noticed an option on textmate :P)
16:23:03 <joga> ooh
16:23:28 <EvilTerran> > uncurry (/) . (sum &&& fromIntegral.length) $ [x,y,z]
16:23:29 <lambdabot>   (0 + x + y + z) / 3
16:24:21 <kyevan> I wonder if I could alter that to use a different pastebin... one with haskell highlighting support, maybe :J
16:25:44 <vixey> > liftA2 (/) sum genericLength [x,y,z]
16:25:46 <lambdabot>   (0 + x + y + z) / (1 + (1 + (1 + 0)))
16:25:55 <Cale> kyevan: It appears to highlight it...
16:26:28 <Cale> kyevan: In listMeanHelp, you may want to strictify the s and n parameters, since they're going to accumulate large expressions.
16:26:53 <kyevan> I have no clue what you just said
16:27:12 <Cale> listMeanHelp [1,2,3] 0 0
16:27:20 <kyevan> And that's an old version anyway, from before I figured out how to get the first to work. I just hang onto it to remind me :J
16:27:24 <Cale> -> listMeanHelp [2,3] (0+1) (0+1)
16:27:36 <Cale> -> listMeanHelp [3] ((0+1)+2) ((0+1)+1)
16:27:50 <Cale> -> listMeanHelp [] (((0+1)+2)+3) (((0+1)+1)+1)
16:27:56 <kyevan> Well, no, I get that, I just don't get "strictify" :P
16:28:33 <kyevan> Oh. Hey, it does highlight it
16:28:37 <Baughn> @undo do cmd <- commands; return cmd
16:28:37 <lambdabot> commands >>= \ cmd -> return cmd
16:28:41 <kyevan> It does it client side in javascript >_>
16:28:43 <Baughn> @. pl undo do cmd <- commands; return cmd
16:28:44 <Cale> Well, either add  s `seq` n `seq` before the recursive call to listMeanHelp, or use the bang patterns extension and stick !'s in front of the s and n parameters on the lhs
16:28:44 <lambdabot> commands
16:29:21 <kyevan> Cale: Uh.... >_>
16:30:00 <Cale> This will ensure that s and n get evaluated before the recursive call.
16:30:26 <kyevan> I'll... keep that in mind for if I have to do something like that in the future, I guess. :P
16:30:27 <Cale> So you don't end up with big expressions like (((0+1)+1)+1) building up
16:31:11 <Cale> > let f n [] = n; f n (x:xs) = f (n+1) xs in f 0 [1..1000000]
16:31:13 <lambdabot>   * Exception: stack overflow
16:31:33 <Cale> ^^ this can result when the resulting large expression ends up trying to evaluate
16:31:48 <roconnor> @djinn (a,b) -> (b,a)
16:31:49 <lambdabot> f (a, b) = (b, a)
16:32:11 <Cale> > let f n [] = n; f !n (x:xs) = f (n+1) xs in f 0 [1..1000000]
16:32:12 <lambdabot>   <no location info>: Parse error in pattern
16:32:21 <Cale> ah, no bang patterns
16:32:27 <Cale> > let f n [] = n; f n (x:xs) = n `seq` f (n+1) xs in f 0 [1..1000000]
16:32:29 <lambdabot>   1000000
16:32:30 <kyevan> And that's soo much better :P *teases*
16:32:30 <hatds> @djinn (a,a)->(a,a)
16:32:31 <lambdabot> f a = a
16:32:48 <Cale> But with the seq you don't need any extensions :)
16:32:52 <kyevan> But yeah. :J
16:33:04 <c_wraith> djinn doesn't always return the most interesting implementation. :)
16:33:19 <c_wraith> @djinn (a, b) -> (b, a)
16:33:19 <lambdabot> f (a, b) = (b, a)
16:33:40 <kyevan> @djinn [a] -> a
16:33:40 <lambdabot> Error: Undefined type []
16:33:46 <kyevan> Bah :P
16:34:01 <Cale> djinn can't handle recursion
16:34:05 <hatds> what's the formal notion of equivalence behind djinn saying all functions (a,a)->(a,a) are equivalent to id?
16:34:14 <kyevan> Of course, that type *is* impossible to do something complete for...
16:34:18 <Cale> hatds: Huh? It didn't say that.
16:34:27 <hatds> okay then I didn't understand it :)
16:34:32 <hatds> what does it say?
16:34:32 <Baughn> > do a <- [1..5]; return a
16:34:33 <lambdabot>   [1,2,3,4,5]
16:34:36 <kyevan> ([] likes to break things sometimes :J)
16:34:39 <Cale> hatds: All that it does is try to find a function which satisfies the type
16:34:49 <hatds> alright
16:35:04 <Cale> (and which is total)
16:35:06 <Philonous1> hatds: djinn delivers a proof for that type, i.e. it shows a function of that type is implementable
16:35:12 <vixey> @djinn (a,a)->(a,a)
16:35:13 <lambdabot> f a = a
16:35:32 <vixey> that's odd
16:35:41 <c_wraith> There are two non-bottom implementations for that signature, I think..  identity, and swap.
16:35:47 <Cale> I suppose if you want the notion of equivalence it's using is equivalence up to type. :P
16:35:52 <kyevan> Baughn: Um, how is that different than [1..5]?
16:36:12 <Cale> c_wraith: there are a couple more too
16:36:17 <c_wraith> Oh, right.
16:36:22 <c_wraith> copy the first, copy the second
16:36:23 <Philonous1> c_wraith: \(a,b) -> (a,a) and \(a,b) -> (b,b)
16:36:24 <Cale> c_wraith: f (x,y) = (x,x) and f (x,y) = (y,y)
16:36:40 <Baughn> kyevan: It isn't
16:36:48 <kyevan> Oh. :3
16:36:54 <Baughn> kyevan: I'm trying to figure out why reactive's Event breaks the monad laws. :/
16:37:33 * kyevan is going to just smile and nod at that
16:37:35 <Cale> Baughn: hmm...
16:38:13 <kyevan> Monad laws are outside my jurisdiction. </badpun>
16:38:30 <Baughn> Cale: Let me write a test-case
16:38:50 <c_wraith> @djinn Int -> Int -> Int
16:38:50 <lambdabot> Error: Undefined type Int
16:39:05 <c_wraith> hehe.  Djinn only uses tuples and variables?
16:39:24 <kyevan> Yeah. Once you use specific types, it can't know. :J
16:39:37 <kyevan> I suppose it could reduce that to a -> a -> a
16:40:00 <Cale> @djinn-env
16:40:00 <lambdabot> data () = ()
16:40:00 <lambdabot> data Either a b = Left a | Right b
16:40:00 <lambdabot> data Maybe a = Nothing | Just a
16:40:00 <lambdabot> data Bool = False | True
16:40:00 <lambdabot> data Void
16:40:02 <lambdabot> type Not x = x -> Void
16:40:04 <lambdabot> class Eq a where (==) :: a -> a -> Bool
16:40:05 <vixey> @djinn int -> int -> int
16:40:06 <lambdabot> f _ a = a
16:40:25 <michaelgg> what is the list "foldBack" function
16:40:27 <michaelgg> is that just a left fold?
16:40:44 <michaelgg> cant find it on google
16:40:52 <Cale> @djinn Either a b -> (a -> Maybe b) -> Maybe b
16:40:52 <lambdabot> f a b =
16:40:53 <lambdabot>     case a of
16:40:53 <lambdabot>     Left c -> b c
16:40:53 <lambdabot>     Right d -> Just d
16:41:30 <Cale> michaelgg: What library is it defined in?
16:41:36 <michaelgg> F#
16:41:44 <michaelgg> just wondering if anyone heard of it
16:41:50 <Cale> I've never heard of it.
16:41:52 <michaelgg> it has List.fold and List.foldBack
16:42:03 <Cale> Maybe one is a right and one is a left fold
16:42:13 <michaelgg> thats a wierd name
16:42:28 <Cale> I would hope that fold is the right fold.
16:42:54 <kyevan> F# is the .NET-targeting ML, isn't it?
16:43:14 <Cale> Though, F# is strict, so probably they don't like right folds as much.
16:43:41 <Philonous1> michaelgg: Maybe they can help you in #fsharp
16:43:58 <michaelgg> yea ones a right and ones a left
16:43:59 <michaelgg> wow
16:44:01 <michaelgg> thats.... wierd.
16:44:11 <michaelgg> Philonous1, yea :)
16:44:17 <michaelgg> i just was wondering in general if thats a normal name
16:44:37 <Cale> It's not, but I suppose it's not so terrible either
16:44:38 <michaelgg> i can figure out F# -- just curious as to what the normal names are
16:45:33 <Cale> > foldr (\x y -> concat ["(f ",show x," ",y,")"]) "z" [1,2,3,4,5]
16:45:34 <lambdabot>   "(f 1 (f 2 (f 3 (f 4 (f 5 z)))))"
16:45:52 <Cale> > foldl (\x y -> concat ["(f ",x," ",show y,")"]) "z" [1,2,3,4,5]
16:45:53 <lambdabot>   "(f (f (f (f (f z 1) 2) 3) 4) 5)"
16:46:07 <Cale> You could translate those to figure out what it's giving you :)
16:46:24 <pejo> michaelgg, I don't think Haskell is any more normal than ML, and considering its heritage you have to judge whether F# is normal by the ML standards.
16:46:48 <roconnor> @ask augustss_ Why were function types part of the Eval class in Haskell 1.4 and Haskell 1.3?  Why not exclude them?
16:46:48 <lambdabot> Consider it noted.
16:46:50 <michaelgg> pejo well i dont see it in ML either. but figured haskellers know everything anyways.
16:47:01 <Cale> Haskell is more normal because it uses something which is closer to normal-order evaluation ;)
16:47:07 <Baughn> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5018#a5018
16:47:10 <kyevan> What's "normal" is generally "what early Lisps called it" :J
16:48:38 <Philonous1> @hoogle a -> IO b -> [a] -> MVar [b]
16:48:38 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
16:48:47 <Baughn> Cale: Actually, the testcase works for about a second or two, before GHC kills it. Hm..
16:49:45 <Baughn> Cale: Huh. I think it's a GHC bug.
16:49:58 <Baughn> Cale: If I run it with +RTS -I0, it works perfectly.. well, presumably up to the first GC
16:50:01 * Baughn tests
16:50:04 <Cale> Baughn: hmm
16:50:14 <Cale> Baughn: I'll give it a try
16:50:39 <Cale> Could not find module `FRP.Reactive.LegacyAdapters'
16:51:00 <Cale> er
16:51:13 <Cale> I should make sure reactive is still installed properly...
16:51:25 <Baughn> Cale: In fact, -I0 cures it even when GCs run. It's specifically the idle GC that kills it. o_O
16:51:30 * kyevan pasted http://pastie.textmate.org/private/bqeklpelu7tcaj8q6ikp6a
16:51:33 <Baughn> ..time for me to install 10.3
16:51:34 <Cale> ah, right, everything was blown away when I upgraded :P
16:51:39 <kyevan> :/ Anyone know why that doesn't work?
16:52:09 <kyevan> I don't *see* any typos... and I don't actually understand the code, I'm typing it straight from the book as a tool to use while working on other things.
16:52:37 <kyevan> ((Er, for reference, GHC gives me InteractWith.hs:11:28: Empty 'do' construct))
16:52:37 <hatds> what's the error?
16:52:40 <hatds> nvm
16:52:45 <Baughn> Cale: I'd be /very/ interested to hear how that works for you
16:52:46 <hatds> layout error probably
16:53:32 <kyevan> Where? >_>
16:53:32 <c_wraith> Yeah, sounds like ghc isn't happy with your indentation.  (haskell's indentation rules are arcane for no obvious reason)
16:54:42 <kyevan> I'm doing two-spaces-per-indent, is that wrong?
16:55:00 <Hunner> That's what I do
16:55:29 <c_wraith> clearly, it's not associating line 12 with line 11
16:55:32 <hatds> try moving the 'where' to the previous line
16:55:38 <Philonous1> Cale: In the paper you posted earlier choose looks a little bit like unamb (or rather: amb), and sync like a takeMVar. Am I completely off the track with that assessment?
16:55:49 <hatds> also move "myFunction = id" to the left
16:55:55 <kyevan> c_wraith: That;s not terribly clear >_>
16:56:01 <kyevan> At least, not to me :P
16:56:18 <Cale> Philonous1: That's not far off. I think the haddock documentation is possibly clearer about what things do
16:56:24 <c_wraith> Well, the error message says line 11, and the do on line 11 goes with the block starting on line 12
16:56:28 <c_wraith> So it's not connecting them
16:56:34 <Cale> http://hackage.haskell.org/packages/archive/cml/0.1.1/doc/html/Control-Concurrent-CML.html
16:56:35 <c_wraith> I'd lay that out with the where on one line
16:56:39 <c_wraith> by itself
16:56:52 <c_wraith> and the additional functions on subsequent lines, indented further than the where
16:57:11 <Cale> It's unfortunate that it's missing so many obvious instances, like the easy Monad instance for Event
16:57:15 <kyevan> Wait... there's another layer of indent there in the book, I think?
16:57:17 <TonyTheTiger> how can i turn a list of tuples into a list of elements?
16:57:22 * kyevan tries that
16:57:28 <Philonous1> Cale: Oh, I missed the fact that it has actually been implemented. Thanks.
16:57:35 <kyevan> Nope :(
16:57:49 <TonyTheTiger> e.g [(1,2,3),(4,5,6)] = [1,2,3,4,5,6]
16:57:53 <Cale> Philonous1: yeah, the code in the paper doesn't actually look like Haskell code :P
16:58:03 <c_wraith> kyevan: There's a real problem with the layout as it stands, though
16:58:17 <kyevan> What is it?
16:58:27 <c_wraith> kyevan: Since myFunction needs to be parallel to mainWith
16:58:47 <kyevan> Um?
16:58:48 <c_wraith> kyevan: Which means that they need to be defined at the same level
16:58:56 <kyevan> *confused*...
16:59:10 <TonyTheTiger> anyone?
16:59:14 <kyevan> I'm just typing what it says in the book! *cries*
16:59:17 <Philonous1> Cale: I didn't get that far yet. I just wanted to understand CML before I head on
16:59:22 <c_wraith> kyevan: That "where" block contains two function definitions
16:59:33 <Ralith> TonyTheTiger: there's no way to handle arbitrary length tuples afaik, unfortunately
16:59:41 <c_wraith> kyevan: They need to be lined up with each other....  Oh, that's the problem.
16:59:46 <Ralith> if you know your tuples will only be three elems long you could do
17:00:07 <c_wraith> kyevan: It's not associating line 12 with the do because line 12 isn't indented further than the function name
17:00:14 <Ralith> f [] = [] f ((a,b,c):xs) = a:b:c:(f xs)
17:00:22 <pejo> This question with using tuples the same way as lists has come up several times in my limited time here for the last day. Where does the idea come from?
17:00:24 <Ralith> er, stick a semicolon after second []
17:00:54 <Jedai> TonyTheTiger: Normally you know the length of your tuple beforehand (since Haskell is a statically typed language), so you can use an explicit recursion or a concatMap
17:01:00 <c_wraith> kyevan: So it's assuming line 12 is another function declaration in the where block, hence the "do" has an empty body
17:01:07 <Cale> [u | (x,y,z) <- xs, u <- [x,y,z]] or  concatMap (\(x,y,z) -> [x,y,z]) xs
17:01:19 <TonyTheTiger> Jedai: I know my tuples are doubles
17:01:40 <kyevan> c_wraith: I have no clue what's going on. Is the fix to insert six more spaces on each of the lines 12 and after?
17:01:42 <Jedai> TonyTheTiger: We already answered this question earlier then...
17:02:09 <TonyTheTiger> Cale: is what your wrote for me?
17:02:15 <c_wraith> kyevan: But not lines 17 and 18, since those aren't part of the body of the do block
17:02:18 <Cale> TonyTheTiger: yeah
17:02:32 <kyevan> Uh... okay...
17:03:31 <lament> the idea of using tuples the same way as lists probably comes from python :)
17:03:55 <kyevan> Now I get InteractWith.hs:12:7: The last statement in a 'do' construct must be an expression
17:04:23 <kyevan> 12:7 is a random space in the middle of nowhere... what the...?
17:04:48 <persica> kyevan: sounds like you didn't end the do block properly so it doesn't know what to return?
17:05:13 <kyevan> persica: How do I fix it!?
17:05:18 <persica> kyevan: Going through RWH?
17:05:23 <kyevan> Yes :(
17:05:35 <persica> what chapter is this again?
17:05:45 <kyevan> Chapter four, the very start.
17:06:09 <kyevan> Argh...
17:06:21 <kyevan> The book is wrong, and layout in print is impossible to read to begin with >_>
17:06:27 <c_wraith> kyevan: The layout makes a lot more sense if you put the "where" on a line by itself
17:06:35 <c_wraith> And indent another level past that
17:06:44 <kyevan> c_wraith: Wha?
17:06:47 <c_wraith> Then you can just indent two spaces on every line
17:07:02 <kyevan> Tell me where to put the cursor and what buttons to push! *confused as hell*
17:07:03 <c_wraith> make line 11 *just* "  where"
17:07:11 <Cale> Baughn: it works
17:07:20 * Hunner spent 3 days trying to track down bugs in his code only to find out that quickcheck 2.1 was the problem :(
17:07:20 <Cale> Baughn: in 6.10.3
17:07:32 <c_wraith> make line 12 start "    mainWith function = do"
17:07:39 <c_wraith> And then indent as appropriate below that
17:07:54 <persica> Basically he's saying you can make the where be on its own line.
17:07:56 <Baughn> Cale: So I guess that's one of the things under "misc. bugfixes"
17:08:01 <persica> Haskell is sensitive to indentation.
17:08:02 <Cale> kyevan: Is your code pasted somewhere? I will indent it correctly for you, if you like.
17:08:12 <Baughn> Cale: Good thing, too. I was afraid I'd have to delve into slimy guts.
17:08:17 <persica> I just copied an pasted from the online version and it works fine...
17:08:38 <kyevan> cale: http://pastie.textmate.org/private/bqeklpelu7tcaj8q6ikp6a
17:08:44 <kyevan> There's an online version?
17:09:00 <persica> http://book.realworldhaskell.org/read/
17:09:08 <pejo> Cale/Baughn, wasn't this the finalizer change with some things that was necessary for unamb? I think Conal was mentioned by one mail from Simon Marlow
17:09:11 <persica> has comments too, if you have javascript enabled.
17:09:23 <Baughn> Cale: ..way to go getting my hopes up. It only works without -threaded. ;_;
17:09:38 <Baughn> That /definitely/ makes it a ghc bug, though
17:09:42 <persica> kyevan: looks like myFunction is on the same line as "args" and "case"
17:09:51 <Cale> kyevan: the problem is the contents of your do-block are outside the 'where'
17:10:01 <TonyTheTiger> Type error in generator <-- im getting this error
17:10:06 <persica> kyevan: technically myFunction is part of the "where" while "args" and "case" are in the do block.
17:10:07 <kyevan> How am I supposed to know that!?!?
17:10:14 <kyevan> I'm just retyping from a book
17:10:20 <kyevan> I don't know how any of this works
17:10:44 <persica> kyevan: You read compiler warnings... lots of compiler warnings.  I personally don't like that example either.  Why not just make "main = do..."
17:10:53 <kyevan> I'm only just not crying right now... ARGH, this is really not reflecting well on haskell.
17:10:56 <Cale> kyevan: The first non-whitespace character after the 'where' keyword determines the column that things have to line up with in order to be inside the 'where'
17:11:18 <Cale> kyevan: if any line is indented less than that, the 'where' ends.
17:11:34 <kyevan> o...kay...?
17:11:43 <blackh> kyevan: Learn the indenting rule and all your problems will disappear.
17:11:44 <Cale> I'll give you a version with how I'd indent it.
17:11:56 <persica> Cale: technically the next non-whitespace character on a line after the where assuming it is not earlier in the line than the where itself.  Correct?
17:11:59 <kyevan> blackh: TGHREIPASO'tyug78 9zxxeruilsbxwegd6rtuc[jzxuivntpszv4890eb5ytvlsnbe479tonlerzxcb8yh0lzr89tcnl\
17:12:06 <c_wraith> It's probably simplest to just use a text editor that at least tries to indent correctly.
17:12:43 <TonyTheTiger> kyevan: these guys are the most helpful amongst irc forums, be patient and you will understand eventually.
17:12:52 <kyevan> blackh: I'M JUST TRYING TO COPY FROM A BOOK!
17:12:54 <hatds> persica: yes, that's right.  There are always two columns you have to keep in mind when parsing your layout
17:13:01 <ray> i don't like hanging 'do's
17:13:02 <Cale> http://pastie.textmate.org/482253
17:13:11 <kyevan> It says "just copy this for now and we'll explain later"
17:13:11 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5018#a5018 <-- This code fails completely on 6.10.2. On 10.3, it works without -threaded but not with. (Ideas?)
17:13:19 <kyevan> Why is this all so confusing? :(
17:13:23 <blackh> kyevan: The four magic keywords are: do, let, where and of
17:13:53 <persica> kyevan: Because learning how to program with awesome requires you unlearn all you knew about lameness.
17:14:00 <hatds> I think the fact that you have to consider both the enclosing layout width and the new width is what trips people up
17:14:17 <blackh> kyevan: The indenting level of the first non-whitespace character after any of these keyword is the important thing.
17:14:47 <hatds> also 'do' has a little more relaxed layout rule, iirc
17:14:54 <kyevan> persica: But then, why doesn't it explain this before you have to use it... and... but... wha... za... hug
17:14:56 <kyevan> >_<
17:15:00 <blackh> kyevan: Everything that lines up with that character is in that keyword's block.
17:15:27 <kyevan> I don't even know what two of those four do. >_>
17:15:28 <hatds> are there programs which parse layout in a visual way for people to learn from?
17:15:28 <persica> kyevan: RWH does sort of dump a lot on you at the start, but that's so you can start with examples of stuff that actually works right away.
17:15:57 <kyevan> persica: Dumping is fine, but can't it *tell you* what it's dumping on you, instead of saying t
17:16:01 <monadic_kid> hatds: there is blog with coloring for tabs and spaces
17:16:03 <bremner> hatds: yes, by kyevan hates emacs
17:16:04 <kyevan> "Type this, and pray a lot!"?
17:16:20 <persica> kyevan: I really like RWH as a way to learn.  If it's confusing, refer to the comments in the online version. :D
17:16:36 <blackh> kyevan: We'll help as much as we can.
17:17:19 <blackh> kyevan: You really have to know the indenting rule, though, otherwise you'll go nuts.
17:17:24 <kyevan> What online version, persica?
17:17:30 <ray> my theory is that layout gets confusing when any of the whitespace characters before that first magic non-whitespace character are newlines
17:18:10 <hatds> ha, I don't think I've ever used layout with extra newlines
17:18:17 <kyevan> But, yeah. For reference, what's going through my head right now is basically "And I thought PYTHON was bad."
17:18:34 <persica> kyevan: I thought I linked. http://book.realworldhaskell.org/read/functional-programming.html
17:19:08 <kyevan> persica: I must have missed it
17:19:18 <ray> there's this irrational prejudice against meaningful whitespace too, but i think haskell layout when people stick those extra newlines in there is actually confusing
17:19:27 <persica> hatds: I seem to be using a lot of newlines after '=' and "do" just to keep things from going off the right side of my editor. :D
17:19:29 <hatds> I think it is best to just read formal rules in the Haskell report on layout
17:19:48 <ray> sure, if you read formal rules
17:20:00 <ray> i do, but i had to learn to be able to read them first
17:20:04 <c_wraith> Or you could just use explicit { ; } syntax.
17:20:21 <c_wraith> It's not as pretty, but it doesn't have any confusing rules
17:20:31 <monadic_kid> i found it, this has visual representation of using tabs and spaces: http://urchin.earth.li/~ian/style/haskell.html
17:20:35 <TonyTheTiger> hi i am getting an error "Type error in generator" here is my code http://pastebin.com/dc177a0 can someone help please?
17:20:52 <hatds> persica: I was thinking of putting *extra* newlines beyond what's necessary to avoid word wrap.  I usually leave "do" by itself at the end of the line.  For '=' I just give names to sub expressions instead.
17:21:14 <blackh> kyevan: With Haskell, you'll get a very sore head at first, but it becomes *very* pleasant later, when you realize that the compiler has taken a lot of the annoying work (such as debugging) away from you.
17:21:15 <monadic_kid> kyevan: http://urchin.earth.li/~ian/style/haskell.html
17:21:17 <hatds> persica: admittedly you could put filler lines though, which I find amusing
17:21:53 <persica> hatds: Yeah, that sounds odd.  I feel like all parts of the function should be on consecutive newlines.
17:21:53 <kyevan> blackh: And instead given me an utterly insane set of layout rules that aren't yet explained but I'm expected to know :P
17:22:12 <kyevan> The two seem rather unrelated... so yeah >_>
17:22:27 * kyevan has a working copy of the black box now, though, so yay :J
17:22:45 <monadic_kid> what are you using to code in anyways?
17:22:48 <blackh> kyevan: The author of the book is here, so your comments will be acted on, I'm sure. I personally think you absolutely must teach the indenting rule - it's impossible to write Haskell if you don't know it.
17:23:06 <blackh> kyevan: I can summarize it again if you want me to.
17:23:18 <monadic_kid> blackh: IDE/editors make you pretty ignorant of it
17:23:52 <hatds> that's not my experience, but I'm using notepad
17:23:54 <hatds> :)
17:24:01 <ray> i never found it hard, and i never left keywords hanging like lots of people do either
17:24:03 <kyevan> blackh: Well, it says "We'll talk about it more in chapter 7". So It'll get there eventually, but... >_>
17:24:10 <TonyTheTiger> I am getting an error "Type error in generator" here is my code http://pastebin.com/dc177a0 can someone help please?
17:24:13 <c_wraith> monadic_kid: That page seems broken. Shouldn't it have tabs colored differently than spaces?  It doesn't appear to on my browser.
17:24:35 <kyevan> Why are Haskell's rules for indents so weird, though?
17:24:42 <hatds> they aren't, really
17:24:45 <monadic_kid> c_wraith: it should do, i'm using firefox
17:24:49 <ray> your browser is broken
17:24:59 <ray> monadic_kid: so is your browser ;)
17:24:59 <hatds> but teachers overestimate how simple they are
17:25:00 <blackh> kyevan: There is a madness to the method! It's all to do with keeping the code free of 'cruft' like { ; }
17:25:07 <hatds> er not simple
17:25:08 <persica> kyevan: Does the section "The offside rule and white space in an expression" in Ch3 answer your questions about layout?
17:25:19 <kyevan> blackh: Have you ever played with Python?
17:25:21 <c_wraith> monadic_kid: I'm on firefox 3.0.10 on OSX, and seeing no background colors whatsoever on that page
17:25:26 <blackh> kyevan: Yes, lots
17:25:36 <kyevan> If not, I'm going to ignore that line as moronic. You don't have to have weird rules to do that.
17:25:51 <c_wraith> monadic_kid: Seems I failed to load a stylesheet.  Wonder why.
17:26:04 <kyevan> Python's are trivial. To go 'in' a block, indent to the right. To go up, go back to the left. Done.
17:26:31 <blackh> kyevan: I think Haskell's rule was invented before Python's so Haskell couldn't base it on 'common practice'
17:27:01 <persica> kyevan: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.offside
17:27:03 <Jedai> kyevan: rules in Haskell aren't much more complicated than Python
17:27:05 <c_wraith> kyevan: That's not *quite* as clear in haskell, because there's no clear rule about what starts a block
17:27:10 <kyevan> Sure it could, that style of indent has been common practice for justabout ever :P
17:27:12 <monadic_kid> i've never had issues with layout rules in haskell
17:27:27 <ray> i think :s start a block in python, which is the *real* ugly part
17:27:28 <c_wraith> You don't get python's clean "if the line ends with ':', indent further the next line" rule
17:27:36 <Jedai> kyevan: I never had any problem whith layout in Haskell
17:27:39 <ray> there's nothing ugly about indentation
17:27:56 <c_wraith> Really, just use an editor that knows something about haskell layout, and you won't have issues.
17:27:57 <kyevan> Sure, but those four keywords, you indent further on the next line.
17:27:59 <kyevan> That would work >_>
17:27:59 <FunctorSalad> the last statement in a do expression must be a value....
17:28:04 <blackh> kyevan: Even if Haskell's rule is ill-conceived, the good things in Haskell hugely outweigh it. :)
17:28:07 <kyevan> c_wraith: I'm using textmate. >_>
17:28:15 <FunctorSalad> (that one seems to be a common bogus error msg with layout)
17:28:33 <ray> haskell is good at bogus error messages
17:28:43 <Jedai> blackh: I like those rules, they're pretty simple in my opinion and allow for more flexibility than Python
17:28:55 <c_wraith> monadic_kid: that page totally fails at loading the stylesheet for me, and I have no clue why
17:29:08 <Cale> kyevan: I basically follow a much stronger rule than the real one, which is that the inside of a let, do, where, or of must be indented more than that keyword.
17:29:19 <monadic_kid> c_wraith: yes I saw message the first time, i don't know what to say it's not my webpage
17:29:42 <c_wraith> strange.  I can't even debug it.  I'm sure it's a problem on my end, given that.
17:29:42 <kyevan> Okay... I still think it could be simplified >_>
17:29:52 <rzezeski> Haskell's "broken" indentation scheme would be like a broken window on a 5 million dollar home.  Sure, it's a friggen' sore, but no need to throw the baby out w/ the bath water :)
17:30:13 <Cale> I don't think Haskell's indentation rule is broken.
17:30:15 <ray> i think your alleged broken window is actually a stained glass window
17:30:20 <Cale> But it allows more than it should.
17:30:23 <Jedai> rzezeski: I don't find the indentation scheme broken... I like it very much
17:30:31 <monadic_kid> kyevan: does textmate actually suport haskell? just syntax highlighting?
17:30:50 <Jedai> rzezeski: And I never had any problem with it
17:30:59 <Cale> For example, I think it should be extended to apply to if, forcing 'then' and 'else' to be indented by the same amount if they occur on separate lines.
17:31:08 <persica> The indentation rules make perfect sense.  They're a shortcut you can use instead ofusing {} and ;.  And the have the benefit of (generally) making code more legible.
17:31:10 <Cale> (and more than the 'if' itself)
17:31:13 <rzezeski> guys, I put "broken" in quotes, I'm trying to make an analogy that w/ patience kyevan will overlook his worries about the indentation
17:31:15 <ray> cale: i do the opposite and follow the degenerate layout rule of "make stuff line up"
17:31:18 <blackh> kyevan: If you consider the identing design bad, it's not a sign of a bad design: Haskell is probably one of the cleanest, simplest and most consistently designed languages.
17:31:23 <ray> but i don't encounter problems
17:31:32 <kyevan> rzezeski: So, it';s something that should be replaced ASAP. Haskell's been around *how* long? :P
17:31:34 <Cale> ray: Yes, I make stuff line up too ;)
17:31:44 <persica> ray: I would even go as far to say I just "make stuff pretty." which just happens to include lining up.
17:31:52 <Jedai> kyevan: No, the indentation scheme is perfectly fine...
17:31:56 <blackh> kyevan: Strangely one thing I don't like about Python is the fact that 'print' doesn't require parentheses for its argument but every other function does.  Haskell doesn't have any inconsistencies like that.
17:31:57 <kyevan> persica: I'm not saying meaningful indentation is bad...
17:32:08 <kyevan> I'm saying *haskell's implementation* is :P
17:32:17 <kyevan> blackh: Python 3.0 changes that
17:32:26 <Jedai> kyevan: You're unfamiliar with it, that's all
17:32:35 <ray> the real ugly part about python is the :s at the end of some stuff
17:32:51 <Cale> I always put the first line of a 'do', 'let', or 'of' on the same line as that keyword, and this is usually the case with 'where' as well.
17:32:52 <ray> it could be triggered by keywords like haskell
17:32:57 <Jedai> kyevan: And nobody explained it to you clearly, it's not the fault of the layout
17:33:02 <rzezeski> kyevan, there are warts in every language, and different for every person, all I'm saying is don't let it dissuade you
17:33:06 <ray> cale: my theory is that that avoids problems
17:33:08 <persica> kyevan: I don't see how it's bad.  It could be simply stated as "anything that woudl be inside a {} needs to be indented more than the line containing the { and all lines in the same {} need to have the same indentation.
17:33:34 <kyevan> persica: No it couldn't
17:33:43 <kyevan> Mine obeyed those rules and didn't work
17:34:15 <kyevan> (Ignoring the thing that was indented in the text and wasn't supposed to be, that's *not* my fault in even the vaugest sense)
17:34:19 <blackh> kyevan: Like rzezeski said, don't let it dissuade you or you would be missing out on something wonderful.
17:34:23 <persica> kyevan: I think your problem is that program that has that line which is actually part of the where-block but is easy to confuse as being in the do-block.
17:34:31 <Jedai> kyevan: I doubt that... Could you post your code ?
17:34:53 <Cale> kyevan: If you follow the rule that if something is to be the child of something else then it should be indented more, and if they are siblings, they should start in the same column, then you should have no issues.
17:35:04 <persica> Jedai: he posted http://pastie.textmate.org/482253 before.
17:35:26 <Cale> That looks like my paste
17:35:30 <kyevan> Third time: http://pastie.textmate.org/private/bqeklpelu7tcaj8q6ikp6a
17:35:36 <persica> yeah, must have had the wrong one.
17:36:06 <persica> See, all he did was accidentally put the "myFunction = id" line from the where statement on the same indentation as the do block.
17:36:07 <Cale> Yeah, in kyevan's, the problem is that args <- getArgs starts on a shallower column than mainWith function = ...
17:36:19 <kyevan> No it doesn't.
17:36:24 <kyevan> It's indented more than that line.
17:36:25 <Cale> Yes it does.
17:36:36 <Cale> It's not the *line's* indentation that matters
17:36:37 <rzezeski> kyevan, you using hard tabs?
17:36:42 <Cale> It's the column that it starts on
17:36:43 <blackh> kyevan: the first non-whitespace character after "where" is 'm'.  Things inside the where block can't be indented less than the 'm'
17:36:49 <kyevan> rzezeski: No, I don't?
17:36:54 <Jedai> kyevan: Right, so your code didn't respect the rules given by persica...
17:37:16 <monadic_kid> does anyone know what are those fonts being used in pastie.tetmate.org?
17:37:18 <Cale> kyevan: The definition starts "mainWith function = "
17:37:24 <kyevan> Persica said: I don't see how it's bad.  It could be simply stated as "anything that woudl be inside a {} needs to be indented more than the line containing the { and all lines in the same {} need to have the same indentation.
17:37:30 <kyevan> The line is indented 0 spaces
17:37:35 <kyevan> I indented two spaces.
17:37:39 <monadic_kid> they look like gedit fonts, i love them. I wish i knew what there exact name was
17:37:53 <Jedai> kyevan: You accidentaly thought that myFunction was part of the do block, that was the problem, not the indentation scheme itself
17:37:57 <kyevan> Haskell doesn't redefine less than and greater than, does it?
17:37:59 <Cale> kyevan: Lines that are part of that definition have to start on a column which is past the "m" in "mainWith"
17:38:07 <kyevan> Jedai: THAT was already covered
17:38:15 <kyevan> Even fixing that it doesn't change it.
17:38:15 <Cale> kyevan: Does that make sense?
17:38:20 <Cale> (are you reading what I wrote?)
17:38:36 <kyevan> Cale: YES I KNOW I'M SAYING THAT PERSICA'S SIMPLIFICATION WAS INCORRECT!
17:38:47 <Cale> My simplification though is correct.
17:38:55 <kyevan> Are you Persica?
17:39:02 <Jedai> kyevan: The second part of the rule given by persica cover that : myFunction and mainWith being part of the same {} should have the same indentation
17:39:21 <kyevan> Yes, I KNOW
17:39:22 <persica> kyevan: You're right, I'm wrong about that.
17:39:39 <kyevan> That was an error in the book, and I ALREADY SAID that even correcting that it was still broken
17:39:42 <persica> Guess it just doesn't come up for me with the way I usually do it. :D
17:39:56 <persica> When I copy-and-pasted straight from the book it worked fine. :D
17:40:06 <kyevan> You can't copy and paste from paper
17:40:07 <persica> Though it was probably updated.
17:40:20 <persica> From the online version I can.
17:40:32 <kyevan> Which I didn't know about so wasn't using.
17:40:42 <kyevan> Are you TRYING to make me look like an idiot!?
17:41:00 <kyevan> "HURR I DON'T LIKE THIS LET'S CHANGE IT" wasn't what I did >_>
17:42:01 <Cale> kyevan: It's okay, really ;)
17:42:04 <monadic_kid> does textmate actually have a haskell mode or is just syntax highlighting, even if you just use tabes only it should still be fine
17:42:21 <blackh> kyevan: The printed book is actually correct, but of course it won't work unless the indenting is exactly as printed.  You can't expect anyone to do that without knowing the indenting rule.
17:42:29 <jinho> if I have a function description like: String -> (Int -> Int) -> Int, does this mean that the function takes a String and a function (which takes an Int and gives back an Int) and gives back an Int?
17:42:38 <persica> kyevan: Ah, perhaps I was trying to defend my action the same way you seem to be defending yours?  Don't take it personally.
17:42:44 <Cale> jinho: yes
17:42:49 <monadic_kid> jinho: ja
17:42:54 <jinho> it all makes sense now
17:42:55 <jinho> thanks
17:42:56 <kyevan> monadic_kid: I don't thing the bundle includes layout rules.
17:43:13 <kyevan> It does include a bit more than "just highlighting" though :J
17:43:17 <monadic_kid> jinho: but you know the arrow operator is right associative ;)
17:43:31 <kyevan> Also, this was originally written in another editor. :J
17:43:55 <jinho> monadic_kid: can you explain the ramifications of that?
17:44:03 <monadic_kid> jinho: so it's really String > ((Int -> Int) -> Int)
17:44:39 <jinho> monadic_kid: am I still trying to read this left to right? (just like I would a math expression?)
17:45:19 <kyevan> The currying-before-display is annoying... >_>
17:45:39 <monadic_kid> jinho: all functions are functions of one argument, when you write a function with multiple parameters it's just syntatic sugar, it's really a function with one argument and returns a function
17:45:44 <Cale> jinho: Well, it just means that it's *also* a function which takes a String and produces: a function which takes a function (Int -> Int) and produces an Int
17:46:16 <Cale> jinho: When you write something like  f x y z  in Haskell, you're actually writing  ((f x) y) z
17:46:23 <monadic_kid> jinho: haskell functions are curried
17:47:23 <Cale> This is cool, because it makes it easy to get another function by applying a function to just the first few of its parameters
17:47:38 <Cale> > map (map (*2)) [[1,2,3],[4,5],[6,7,8]]
17:47:39 <lambdabot>   [[2,4,6],[8,10],[12,14,16]]
17:47:52 <Cale> Which is very useful for higher-order functions.
17:48:08 <kyevan> Yeah, what
17:48:10 <kyevan> er
17:48:26 <kyevan> What TextMate does is it follows the indent rules for other languages.
17:48:58 <kyevan> (IE, after a line including do, let, or where, indent one tab(which I have set to two-space soft tabs))
17:49:26 <jinho> monadic_kid: but then a function f, which has been described as String -> (Int -> Int) -> Int is really only going to take a String and (Int -> Int) as arguments right?
17:49:37 <Jedai> kyevan: You mean it doesn't understand that do/let/where/of introduce a new block and so it doesn't use the right indentation ?
17:50:18 <kyevan> No, it undestands that, and it indents.
17:50:33 <kyevan> It doesn't do Haskell's weird indent-more-than-once.
17:50:37 <shachaf> jinho: It "really" only takes a String as an argument, since all functions have one argument.
17:50:47 <jinho> shachaf: right
17:50:49 <kyevan> (This is with the Haskell bundle, of course)
17:51:11 <Jedai> kyevan: What are you calling indent-more-than-once ?
17:51:12 <shachaf> jinho: Haskell's syntax happens to make it look like it can take two arguments at once. :-)
17:51:35 <monadic_kid> jinho: what do you mean by really? String -> ((Int -> Int) -> Int), it's a function of argument reutrning a function that takes a function as a parameter, so when apply the function once and apply the function which gets return it's the same as multiple parameters being applied. Syntatic sugar
17:51:47 <kyevan> Indenting once:
17:51:48 <kyevan>   where mainWith function = do
17:51:48 <kyevan>     args <- getArgs
17:51:48 <kyevan> Indenting more than once:
17:51:49 <kyevan>   where mainWith function = do
17:51:49 <kyevan>           args <- getArgs
17:52:03 <jinho> monadic_kid: I guess I'm still hung on you saying that the "->" is right associative
17:52:11 <monadic_kid> jinho: it is!
17:52:26 <jinho> monadic_kid: oh I'm not saying I don't believe it- I'm saying I don't see it
17:52:27 <Jedai> kyevan: Ok... So it indents incorrectly, doesn't it ?
17:52:32 <blackh> kyevan: No - you need to indent once more! 'a' is still left of 'm'
17:52:39 <persica> jinho: if you have "f a b", where f is of type a -> b -> c.  It will first evaluate "f a" and produce a new function g, of type b -> c.  Then it will be left with "g b".
17:52:46 <c_wraith> jinho: a -> b -> c is the same as a -> (b -> c)
17:52:47 <jinho> my faith is better than my understanding at this point =)
17:52:50 <kyevan> blackh: Er, what?
17:53:02 <persica> oh, di dI get it the wrong way around?
17:53:16 <Jedai> kyevan: I wonder if that's an inherent weakness of Textmate or just a lack of work on the Haskell bundle...
17:53:36 <Jedai> kyevan: I don't have a Mac so I can't check it
17:53:44 <blackh> kyevan: Well, I could have it wrong myself, I don't know.  See if the compiler likes it.  You also want 'myFunction' to line up with 'mainWith'
17:53:49 <shachaf> jinho: "f x y = x + y" === "f = (\x -> (\y -> (x + y))"
17:54:10 <jinho> ah - so when you say right associative, you're really saying I should be thinking of this in terms of currying
17:54:21 <monadic_kid> jinho: ja
17:54:23 <kyevan> blackh: Do you mean the first is wrong, or the second? If it's the second, you're using a non-monospace font :P
17:54:35 <monadic_kid> jinho: but the arrow operator really is right associtive
17:54:41 <kyevan> The first, *I KNOW* is wrong :P
17:54:42 <blackh> kyevan: Ah, that's what it'll be - of course.
17:54:43 <jinho> monadic_kid: gotcha
17:54:55 <jinho> monadic_kid: whereas $ is left-associative?
17:54:58 <Cale> jinho: Rather, you may think of that way at any point that it suits you :)
17:55:00 <monadic_kid> jinho: yep
17:55:14 <kyevan> Actually, that's another problem with Haskell's way. >_>
17:55:14 <jinho> Cale: will do
17:55:18 <Cale> $ *ought* to be left associative, but it is not.
17:55:25 <kyevan> It's *impossible* to use layout with a proportional font
17:55:28 <jinho> oh brother...
17:55:33 <Cale> But plain function application is left associative.
17:55:42 <monadic_kid> ah yes
17:55:46 <monadic_kid> then it all fits
17:56:19 <Jedai> kyevan: Well I don't know many programmer that use a proportional font, whatever the language : it always mess up the indentation, even if it is not meaningful
17:56:23 <Pseudonym> So who's working on a better MTL?
17:56:32 <Cale> It's really unfortunate, but whoever decided which way around the associativity of the $ operator would go, apparently didn't realise that we have (.) for function composition
17:56:39 <kyevan> How does it mess up the indentation? >_> But anyway...
17:56:48 <Cale> and so decided to make it right associative so you can write f $ g $ h $ x
17:56:57 <kyevan> I know one. She wouldn't use Haskell if her life depended on it, though.
17:56:59 <Cale> but it's usually better to write f . g . h $ x for that
17:57:02 <hatds> stroustroup doesn't use monospaced fonts supposedly
17:57:10 <hatds> (random trivia)
17:57:17 <magical_pony> huh.
17:57:32 <kyevan> (She's very picky and wrote 90% of the tools she uses herself to deal with that :P)
17:57:33 * mmorrow uses wingdings font. always.
17:57:51 <monadic_kid> so anyone wanna tell me what kind of monospace fonts the paste it site uses or gedit? I wanna use it in visual studio
17:58:21 <nanotech008> they're 'Bitstream Vera Sans Mono', Monaco, 'Courier New', monospace in the css
17:58:42 <hatds> Bitstream is a nice font
17:58:59 <monadic_kid> i tried Bitstream Vera Sans Mono in VS before but it didn't look the same at all
17:59:19 * Cale 
17:59:32 <Cale> ;)
18:00:16 <lament> eek
18:00:17 <kyevan> Cale: Heh... I actually had rigged something to de-fullwidth stuff, for a while.
18:00:23 <rzezeski> real programmers use butterflies :)
18:00:29 <mmorrow> , ""
18:00:32 <lunabot>  "\65345"
18:00:40 <mmorrow> , "a"
18:00:41 <lunabot>  "a"
18:00:45 <mmorrow> heh
18:00:46 <persica> I've been happy with Consolas recently.
18:00:49 <mmorrow> , ord 'a'
18:00:49 <kyevan> rzezeski: Real programmers alter the fundemental constants of the universe to make it do what they want.
18:00:50 <lunabot>  97
18:01:10 <monadic_kid> I like Consolas
18:01:25 <monadic_kid> but i really want the one that gedit uses
18:01:30 <rzezeski> touche
18:01:47 <mmorrow> , let defull = fmap (chr . subtract (65345-97) . ord) in defull ""
18:01:48 <lunabot>  luna: Prelude.chr: bad argument
18:01:54 <mmorrow> sigh
18:02:05 <mmorrow> , chr 256
18:02:06 <lunabot>  '\256'
18:02:08 <kyevan> I think gedit uses bitstream.
18:02:17 <mmorrow> , subtract 10 5
18:02:18 <lunabot>  -5
18:02:22 <kyevan> , chr 1000
18:02:24 <lunabot>  '\1000'
18:02:31 <mmorrow> um, what happened
18:02:31 <blackh> http://blacksapphire.com/~blackh/StephensCrystal.ttf  <-- I made my own by hacking one called Crytstal
18:02:39 <mmorrow> oh
18:03:32 <blackh> ^ Anyone who's sick of all the programming fonts they've got might want to try it
18:03:43 <Associat0r> andale mono
18:04:03 <Associat0r> blackh : did you try that?
18:04:15 <mmorrow> , let defull = fmap (chr . (\x -> if x >= 65345 then x - (65345-97) else x) . ord) in (text . utf8enc . defull) ""
18:04:17 <lunabot>  alwaysusesfullwidthcharacters
18:04:53 <mmorrow> even have unicode spaces in there..
18:04:55 <blackh> Associat0r: Is the link not working?
18:05:01 <mmorrow> , ""
18:05:02 <lunabot>  "\12288"
18:05:19 <kyevan> That's rather broken in the general sense, though, what about characters that aren't fullwidth but have greater codepoints?
18:05:34 <Associat0r> blackh : I mean did you try andale mono
18:05:53 <mmorrow> kyevan: clearly that one-liner isn't a general solution :)
18:06:03 <kyevan> Heh :P
18:06:05 <blackh> Associat0r: Will try
18:06:56 <FunctorSalad> @let () x = x > 3
18:06:57 <lambdabot>  Defined.
18:07:18 <mmorrow> shouldn't it be (<3) ?
18:07:31 <FunctorSalad> there doesn't seem to be a mirrored one
18:07:38 <NEEDMOAR> :-(
18:07:59 <Jedai> > (5)
18:08:00 <lambdabot>   True
18:10:08 <aavogt> @seen dcoutts dcoutts_
18:10:09 <lambdabot> dcoutts is in #haskell-soc, #haskell, #ghc, #gentoo-haskell, #haskell-overflow, #darcs and #haskell-in-depth. I don't know when dcoutts last spoke.
18:10:10 <kyevan> @let () x = 3 > x
18:10:10 <lambdabot>  <local>:4:0:
18:10:11 <lambdabot>      Warning: Pattern match(es) are overlapped
18:10:11 <lambdabot>               In...
18:10:18 <kyevan> Er, right...
18:10:23 <kyevan> Or even
18:10:42 <kyevan> @let (<) x y = y > x
18:10:43 <lambdabot>  Defined.
18:11:02 <kyevan> There you go. Now there's a <
18:11:12 <Jedai> @undefine ()
18:11:26 <Jedai> @let () x = 3 > x
18:11:28 <lambdabot>  Defined.
18:11:36 <blackh> kyevan: if we put that definition into the compiler, it might fix the indentation rule.
18:11:52 <kyevan> blackh: Er, what definition?
18:12:09 <blackh> kyevan: I'm joking, because earlier you asked if Haskell re-defines greater than.
18:12:10 <kyevan> @undefine ()
18:12:17 <kyevan> blackh: Oh, hehe :P
18:12:30 <kyevan> @let () x = x < 3
18:12:31 <lambdabot>  Defined.
18:12:36 <Lemonator> how do I signal the end of a hex code in a string?
18:12:40 <kyevan> See? :J
18:12:51 <Lemonator> for example, when I'm supplying numbers to IRC color control codes,
18:13:00 <Jedai> Lemonator: \&
18:13:09 <Jedai> Lemonator: I think
18:13:20 <Baughn> Cale: Since you apparently have some experience with FRP, I'm wondering if you can tell me what I'm doing wrong with http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5020#a5020
18:13:35 <Lemonator> so it's "\x03\&4,9..." for "..."
18:13:41 <Lemonator> ?
18:14:04 <Baughn> Cale: It's behaving erratically - the output is mostly what I'd expect, but it seems to get "stuck" sometimes, buffering output until it's had some more input..
18:14:11 <Jedai> Lemonator: Right
18:14:26 <Lemonator> thanks
18:14:40 <Jedai> Lemonator: \& is the "empty escape" which is used for stuff like that
18:14:55 <aavogt> @tell dcoutts cabal was not helpful it told me to reconfigure because the .cabal file had a timestamp in the future. A warning, or maybe fixing the timestamp is sane in that case?
18:14:56 <lambdabot> Consider it noted.
18:15:02 <Baughn> Cale: ..sometimes it skips/duplicates numbers, too, but I suppose that's fine in a way
18:15:36 <Macb0t> macb0t macbutt china
18:15:44 <copumpkin> ahem
18:15:50 <macbutt> hey, sup
18:16:31 <Cale> Baughn: hmm, it doesn't skip or duplicate numbers for me, but the I/O is indeed sort of erratic...
18:16:32 <Macb0t> *** you need a MIDI I/O is required for people as i've tried with that?
18:16:48 <Baughn> Cale: Try holding in enter
18:16:52 <Cale> Baughn: yes
18:16:52 <Macb0t> Baughn: hmm, i see you naked at the hawtest porn of many fingers you can see that
18:18:04 <Cale> Baughn: how fast is that clock supposed to tick?
18:18:16 <Baughn> Cale: ..clock?
18:18:28 <Cale> clock <- makeClock
18:18:33 <Baughn> Cale: Oh. I don't think it "ticks", as such.
18:18:54 <Baughn> Cale: Seems to be a vector clock thing
18:19:42 <Baughn> Cale: Er.. never mind that. But it does gettimeofday whenever an event is forced into a sink.
18:20:15 <Cale> ah
18:21:18 <Cale> Interesting, with -threaded I do get skips and duplicates
18:21:41 <Baughn> conal: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5020#a5020 <-- here's another for you to look at; behaves erratically with or without -threaded
18:21:49 <Cale> I've never used the low-level part of reactive before
18:21:51 <Baughn> Cale: *Without* -threaded I rarely get anything at all
18:22:00 <Cale> I was just running it from ghci
18:26:11 <Baughn> Cale: And hang on, if you weren't using adaptE.. all your event sources were pure functions?
18:26:40 <Cale> Baughn: The library I was using used adaptE probably.
18:27:00 <Lemonator> how do I manually generate a parse error in Parsec?
18:27:17 <Baughn> fail
18:27:23 <Cale> noooo...
18:27:27 <Cale> :)
18:27:43 <ray> anything but fail
18:27:56 <romildo> Hi.
18:27:58 <Cale> parserFail :: Monad m => String -> ParsecT s u m a
18:28:32 <Cale> Lemonator: But you might also want to notice <?> which tags parsers so as to give them better names in error messages.
18:28:41 <Cale> (when parsec reports what it expected)
18:28:52 <Lemonator> thanks
18:29:35 <romildo> I have written a class declaration    class ToTree a where ...        Why cannot I declare String as an instance of this class?
18:29:56 <Cale> romildo: Because you don't have the FlexibleInstances extension turned on.
18:30:14 <Baughn> romildo: Because String is [Char], not a type in itself
18:30:38 <Cale> and Haskell 98 was super super picky about what it allowed instances to look like
18:30:46 <romildo> Baughn, ghc does not accepts    instance ToTree [Char]        too.
18:30:54 <Baughn> romildo: Same thing
18:31:12 <Cale> They had to be like  T a b c where T is some type constructor, and the a,b,c are variables
18:31:17 <Baughn> romildo: But you could write one for ToTre a => [a] and Char, or just [a], or..
18:31:24 <Baughn> ..or use FlexibleInstances
18:32:20 <ray> [] Char
18:32:41 <romildo> Baughn, I want to keep the code compatible to Haskell 98.
18:32:55 <Baughn> romildo: Why?
18:33:15 <Cale> Almost no Haskell code these days is Haskell 98 compatible
18:33:44 <copumpkin> drop the dotted module names!
18:33:45 <Cale> I wonder how many of the packages on Hackage are.
18:33:50 <FunctorSalad> I read on hwn that "Haskell98 is the windows98 of standards"
18:33:52 <Cale> It would be interesting to know.
18:33:55 <FunctorSalad> is this bad?
18:34:04 <copumpkin> I thought pretty much all packages had dotted module names
18:34:10 <Baughn> FunctorSalad: Nah, it's newer than that
18:34:13 <romildo> Baughn, to keep it compatible with other compilers, and keep it simple to my students.
18:34:17 <Baughn> FunctorSalad: I'd call it the Windows ME of standards. ;)
18:34:17 <ray> copumpkin: certainly a ton
18:34:21 <Cale> FunctorSalad: I was meaner... I'd said that it was the Windows ME of standards.
18:34:28 <FunctorSalad> =)
18:34:37 <Baughn> romildo: The other compilers support FlexibleInstances too
18:34:52 <ray> i didn't even know h98 didn't allow those until recently
18:34:59 <Baughn> romildo: The rules that extension relax are just plain silly..
18:35:12 <realtime> romildo: for curiosity sake (i'm brazilian too) where do you teach?^
18:35:27 <ray> is instance Class [] Char where... not h98?
18:35:32 <Cale> To be fair, the dotted module names are defined in an official approved extension to H98.
18:35:51 <romildo> realtime, I am at Universidade Federal de Ouro Preto, in Minas Gerais.
18:35:51 <Cale> ray: multiparameter type classes?
18:35:59 <Cale> ray: They're not in H98
18:36:07 <realtime> romildo: how nice :]
18:36:40 <Cale> But even  instance MyClass ([] Char) where ...  isn't accepted, because Char is not a variable
18:36:47 <romildo> realtime, I am teaching "Compiler Construction" to undergraduates and this semester (for the first time) I decided to use Haskell as the implementation language of the compiler.
18:37:00 <Cale> Haskell 98 only did instance selection based on the *topmost* type constructor in the type
18:37:08 <ray> so you have to do either [a] or not at all? :(
18:37:08 <FunctorSalad> do you guys use -fglasgow-exts or single extensions? not sure the clutter is worth it, since all the glasgow-exts seem to be pretty unproblematic..
18:37:19 <ray> freakin' h98
18:37:19 <Cale> Which is basically the very simplest kind of instance selection you can have.
18:37:36 <FunctorSalad> (in source)
18:37:47 <Cale> Typeclasses were still considered kind of new when H98 was written, and they didn't really know how much they wanted to standardise.
18:38:12 <Cale> FunctorSalad: I use LANGUAGE pragmas usually.
18:38:22 <ray> it's hard for me to imagine haskell without typeclasses
18:38:38 <Cale> Since then I don't have to give extra args on the commandline each time.
18:38:50 <romildo> Baughn, what is the syntax to turn FlexibleInstances in the source code?
18:39:02 <FunctorSalad> Cale: ? you can set {-# OPTIONS -fglasgow-exts #-} in source
18:39:12 <ray> {-# LANGUAGE FlexibleInstances #-}
18:39:13 <Baughn> romildo: {-# LANGUAGE FlexibleInstances #-} above the module line
18:39:27 <Cale> FunctorSalad: Well, yes you can do that too
18:39:46 <ray> if you use language pragmas, you know which glasgow extensions you're using
18:40:10 <ray> i'd forget fast if i used -fglasgow-exts
18:41:21 * monadic_kid still can not find the same fonts as gedit
18:42:06 <monadic_kid> or they just dont look the same in VS
18:42:40 <romildo> Baughn, thanks for the clues. I had also to use {-# LANGUAGE TypeSynonymInstances #-} in order to instantiate the String type.
18:43:30 <Baughn> romildo: Mm. You could instance [Char] to avoid that one.
18:43:44 <nanotech008> monadic_kid: if you mean gedit on linux, and visual studio on windows, then it's the font rendering that's different between the OSes
18:44:02 <romildo> Baughn, yes.
18:44:54 <ray> you can put multiple extensions in the same language pragma separated by commas
18:50:20 <Trowalts> can someone help me out with my type decliration, it seems to be a bit off
18:50:21 <Trowalts> http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=2447#a2447
18:51:21 <Trowalts> I get this error message
18:51:22 <Trowalts> Instance of Num Bool required for definition of isPrime
18:51:39 <aavogt> Trowalts: (z+1)?
18:51:55 <lepassive> is there a package for Haskell platform for debian ?
18:51:56 <aavogt> missing parentheses there at least
18:52:16 <Trowalts> heh
18:52:24 <Trowalts> thanks aavogt
18:52:48 <Absolute01> Since haskell uses recursion for looping which generally generate long lists, doesn't this make the stack run out of memory?
18:53:05 <Absolute01> where as for i=0....i<n only update i n times
18:54:07 <Cale> Absolute01: Haskell evaluation doesn't even use a stack for the same purpose as you're used to.
18:54:43 <Absolute01> for example fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
18:54:44 <SamB> which is why it's so hard to get a decent backtrace ...
18:54:48 <Cale> (it does involve a stack for keeping track of which case expressions are still waiting for things to be evaluated enough to do a pattern match)
18:54:59 <Absolute01> using C/C++ you would have a and b and just update them in a loop
18:54:59 <conal> Baughn: i think you've stumbled on the tricky laziness bug i mentioned.  easy to trigger.  hard to debug.  :(  sry.
18:55:06 <Absolute01> but here the list keeps growing
18:55:09 <Absolute01> is this effecient?
18:55:12 <Cale> Absolute01: Printing that list runs in constant space though.
18:55:32 <Cale> Absolute01: Because elements of the list which have been printed can be discarded right away
18:55:45 <Cale> Absolute01: (assuming the list isn't needed thereafter)
18:55:55 <Absolute01> Cale: so indexing fibs !! 1000 doesnt store the previous 999 values in memory?
18:55:59 <SamB> Cale: well not right away
18:56:13 <SamB> after the next couple of elements have been printed
18:56:18 <Cale> Absolute01: if there's no other pointers to them, they'll be GC'd.
18:56:25 <aavogt> Trowalts: you might also want to avoid using tabs (or tell your editor to expand them into spaces), since your guards don't line up when displayed 8 spaces wide (which the compiler will). With guards it doesn't matter, but it could bite you with do notation.
18:56:27 <Cale> SamB: right
18:56:27 <Absolute01> thats cool
18:56:59 <Absolute01> I guess leading to my second question, results don't get cached.
18:57:01 <monadic_kid> Absolute01: read what Cale is saying, also  if you have a tail recursive call and the compiler supports tail-call optimizations then it can be just as efficent as an imperative loop. Some C/C++ compilers support tail-call optimizations but it's not standardized in C/C++ which typically is the case for functional langauges
18:57:12 * SubStack is an anagram for tabs suck
18:57:13 * SamB wonders how you write fibs so that it doesn't allocate ANYTHING
18:57:17 <Cale> Absolute01: But if you define something like fibs = ... at the top level of your program and reference it from multiple places, the list will be kept so long as it might be needed later.
18:57:46 <Cale> Yeah, but tail-call optimisation doesn't really make sense in the usual way for Haskell evaluation.
18:58:05 <blackh> Absolute01: Have a play with 'Debug.Trace.trace' and you can find out when things are getting evaluated - it can be very useful for helping understand what's going on.
18:58:14 <Trowalts> aavogt: I'll see if I can change my spacing settings then, been using notepad++, ty again
18:58:17 <monadic_kid> Cale: that wasn't really haskell specific
18:58:23 <Absolute01> so if there is a reference to N elements of fibs and fibs is invoked again then the values which are in memory are returned?
18:58:33 <Absolute01> not GC'ed yet that is...
18:58:36 <Cale> Absolute01: yeah
18:58:42 <Absolute01> sweet :)
18:59:10 <Cale> Absolute01: So it won't throw away work that it may need again. You can construct space leaks this way if you're not careful too, but mostly it's pretty convenient.
19:00:08 <jinho> what exactly are the indentation rules for "do" (or any other keyword)?
19:00:42 <SamB> @where report
19:00:42 <lambdabot> http://www.haskell.org/onlinereport/
19:00:51 <SamB> jinho: they're in there somewhere ...
19:00:53 <ray> section 9.2
19:01:06 <ManateeLazyCat> I saw some code write like this: "something :: !Int", what's mean of `!` after `::`?
19:01:09 <blackh> Absolute01: Another interesting things about Haskell is that if you run a list through several lazy functions, the compiler can often "fuse" them together and eliminate the memory allocation in between.  So it leads to quite a different way of writing code, but yet it's just as efficient as a loop in an imperative language.
19:01:16 <ray> hmm, 9.3
19:01:24 <SamB> ManateeLazyCat: a strictness annotation
19:01:43 <Cale> jinho: Basically, the first non-whitespace character after "do", "let", "of", or "where" sets the indentation level for the block. All the lines should line up with that column.
19:01:45 * SamB forgets what extension gives you those ..
19:01:55 <SamB> or, wait, that's record syntax
19:02:08 <Cale> jinho: The block ends when a line is indented less than that column.
19:02:16 <FunctorSalad> record syntax allows strict fields too SamB
19:02:27 <Cale> jinho: and a single line of the block is continued to the next line if it is indented more
19:02:30 <SamB> FunctorSalad: I think I was confusing that with bang patterns ;-)
19:02:35 <Cale> jinho: Make sense?
19:02:36 <ManateeLazyCat> SamB: like `=>`? Just syntax character?
19:03:04 <Cale> jinho: The golden rule of Haskell indentation is to line things up when they are siblings, and indent children more than parents.
19:03:15 <jinho> Cale: so if I have my first line as "do\t"
19:03:23 <Baughn> conal: I see. Any advise on how to avoid it, or is that unfeasible?
19:03:37 <Cale> jinho: It's very important that you not put hard tab characters into your source files
19:03:38 <jinho> Cale: subsequent lines should have only 2 spaces rather than 2 spaces and a "\t" ?
19:03:48 <ray> also don't have trailing whitespace
19:04:00 <Cale> jinho: \t will be interpreted by the compiler as aligning to the next 8-space boundary
19:04:03 <jinho> Cale: I have Vim convert tabs to spaces
19:04:03 <FunctorSalad> ManateeLazyCat: data Foo = Foo !Int !Int means that whenever a Foo constructor gets evaluated, it's args get evaluated too
19:04:12 <Cale> jinho: Okay, that's good.
19:04:29 <ray> also consider putting the first line of your do block right after do, but that's just a suggestion from ray and carries less force
19:04:32 <ManateeLazyCat> FunctorSalad: So not lazy?
19:04:34 <Cale> jinho: So you just have to make things on subsequent lines line up with the first non-whitespace character
19:04:37 <FunctorSalad> ManateeLazyCat: right
19:04:38 <jinho> Cale: and when I look at the file everything after "do    " is lined up at the end of that 4th space after "do"
19:04:43 <Cale> yes
19:04:43 <ManateeLazyCat> FunctorSalad: I see, thanks!
19:04:51 <blackh> Absolute01: Lazy evaluation is an ingenious and powerful tool, but it comes with its own learning curve.
19:04:56 <jinho> Cale: still getting problems though
19:05:02 <Absolute01> can a random function be called from a non-monadic context?
19:05:08 <FunctorSalad> ManateeLazyCat: it is usually more efficient if you're certain that the components eventually get evaluated anyway
19:05:09 <Cale> jinho: Can you make a paste on hpaste.org?
19:05:23 <Cale> Absolute01: you mean one which generates random numbers?
19:05:31 <blackh> Absolute01: Not without unsafePerformIO, and you should only do this in low-level libraries where you have good reason to do it.
19:05:40 <Absolute01> Cale: yes
19:05:41 <Cale> blackh: Don't even suggest that.
19:05:53 <ManateeLazyCat> FunctorSalad: Like `*let` in elisp, evaluation argument anyway.
19:05:58 <blackh> Cale: OK, I won't!
19:06:02 <Cale> Absolute01: Usually we pass around the state of the RNG explicitly :)
19:06:09 <Lemonator> so I downloaded some packages off hackage.
19:06:23 <blackh> Absolute01: I use the Random monad from the MonadRandom package - it makes the code much nicer.
19:06:28 <Absolute01> so a qsort function with randomized partition needs to jump into monads? :(
19:06:28 <Lemonator> how do I use them without performing the "runhaskell Setup.hs install" step?
19:06:30 <Cale> Absolute01: Or, yes, use a specialised monad to keep track of that
19:06:32 * FunctorSalad didn't know normal let was lazy in elisp
19:06:48 <jinho> Cale: http://pastebin.com/d2403f984
19:06:48 <ray> by "non-monadic", do you mean "not in IO"?
19:06:50 <Cale> Absolute01: Not necessarily, but it may need to take a random generator as a parameter.
19:06:57 <Lemonator> that is, how do I point other packages to use them as dependencies without having to put them somewhere other than my home folder?
19:07:22 <jinho> Cale: line 41 gives me problems
19:07:23 <ray> people write their randomness-using functions to take generators
19:07:26 * kyevan wishes someone would write a decent text editor in elisp
19:07:38 <Cale> jinho: did you read the error?
19:07:47 <Cale> 41:8: Not in scope: `putStrln'
19:07:52 <blackh> Absolute01: There's another good way to do it - pass an infinite list of random numbers to your function.
19:07:53 <FunctorSalad> Lemonator: cabal install --prefix=.../some/local/dir
19:07:55 <Cale> Needs to be putStrLn
19:08:00 * SubStack wishes someone would write a decent text editor for emacs
19:08:01 <jinho> Cale: It says "Not in scope: putStrLn"
19:08:01 <Absolute01> kyevan: why do you care what language your editor was written in?
19:08:13 <jinho> Cale: my god im an idiot
19:08:13 <jinho> haha
19:08:16 <Lemonator> oh, thanks.
19:08:20 <Absolute01> blackh: yeah thats how the wiki does it: http://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
19:08:22 <kyevan> Absolute01: That was just a dig at emacs :P
19:08:58 <SubStack> emacs is such an easy target
19:08:59 <FunctorSalad> Lemonator: I think this will register the packages in the global ghc-pkg, but I'm not sure
19:09:15 <Absolute01> stupid windows won't let me paste normally into ghci in dos
19:09:15 <blackh> SubStack: It's certainly a large target. :)
19:09:17 <Absolute01> :(
19:09:19 <ManateeLazyCat> kyevan: elisp is bad language to write Emacs.
19:09:21 <jinho> Cale: for what it's worth- thanks
19:09:33 <Absolute01> i only get the first char when pasting into ghci
19:09:33 <SubStack> hard to miss it!
19:09:34 <Absolute01> wtf?
19:10:08 <coCoconut> Absolute01: Then "ur doin it rong". ;p
19:10:23 <FunctorSalad> Lemonator: hmm think I misunderstood your question
19:10:39 <ManateeLazyCat> Guys, how do you use GADTs in practice programming?
19:10:49 <Lemonator> have other packages use not-globally-installed dependencies?
19:11:03 <Absolute01> coCoconut: not it's DOS
19:11:13 <Absolute01> coCoconut: I exited GHCi and pasting works just fine
19:11:40 <Lemonator> don't matter
19:11:42 <Lemonator> it works now.
19:12:12 <ManateeLazyCat> I mean, GADTs use "data SomeType a where" with some Type construction, so what's the generic rule to write those type construction, how to use those type construction? Thanks t!
19:12:44 <ManateeLazyCat> I want use GADTs instead Data.Dynamic in my code.
19:13:31 <Absolute01> bye all
19:13:36 <blackh> See ya
19:15:12 <ManateeLazyCat> GADTs looks like logic programming, then give it some instance to run.
19:15:36 <eck> is there a b-tree module in the stdlib or on hackage? Data.Map implements one, but doesn't expose it
19:16:03 <Lemonator> another problem:
19:16:17 * SamB thought B-tree was usually used to refer to a way of storing stuff in a file ...
19:16:21 <Lemonator> I'm trying to build the time-1.1.2.4
19:16:35 <conal> Baughn: i don't have any advice right now.  reactive needs some serious tlc to get past these issues.
19:16:45 <Lemonator> when I try to runhaskell Setup.hs --configure,
19:16:56 <eck> i just mean a balanced tree
19:17:03 <Lemonator> it tells me: Setup.hs:16:21: Not in scope: `autoconfUserHooks'
19:17:08 <Lemonator> how do I fix that?
19:17:42 <blackh> Lemonator: (Guessing slightly) you might need to upgrade Cabal.
19:17:46 <Lemonator> hm
19:18:15 <blackh> Lemonator: Check your cabal version (ghc-pkg list) against what time.cabal wants
19:18:36 <Lemonator> cabal 1.2.3.0
19:18:38 <Lemonator> hm
19:18:41 <blackh> That's really old
19:18:47 <Lemonator> dang it, ubuntu.
19:18:58 <gwern> ubuntu/debian is old as dirt
19:19:11 <lepassive> is there ghc6.10 deb package ?
19:19:14 <SamB> gwern: I think Debian does a bit better in Haskell ?
19:19:16 <gwern> e
19:19:20 <gwern> not reallyt
19:19:42 <gwern> debian does better only in virtue of the fact that ubuntu might not pick up debian packages instantly
19:19:45 <ManateeLazyCat> lepassive: unstable sources.
19:19:52 <blackh> You can upgrade it easily enough, though.  'cabal-install' is highly recommended
19:20:00 <ManateeLazyCat> lepassive: Install with binary package, that's easiest way.
19:20:18 <lepassive> ManateeLazyCat, humm what should i do then? i want to install haskell platform and it requires ghc6.10
19:20:45 <ManateeLazyCat> lepassive: I have install ghc-6.10.2 in Debian and Ubuntu, use binary package.
19:21:17 <ManateeLazyCat> lepassive: Wait.
19:21:24 <lepassive> ghc-6.10.3-i386-unknown-linux-n.tar.bz2 (74 MB) ?
19:22:46 <ManateeLazyCat> lepassive: Yep.
19:23:03 <gwern> lepassive: the ghc page says you want 1 of 2 packages, because debian/redhatalikes differ in the location of a few libraries; just follow its directions
19:23:41 <lepassive> ManateeLazyCat, there are 2 binaries for linux http://haskell.org/ghc/download_ghc_6_10_3.html#x86linux and both are the same size hmmm
19:24:04 <dons> gwern, Cale http://www.polyomino.f2s.com/haskellformathsv2/HaskellForMathsv2.html
19:24:41 <gwern> lepassive: as I say, they're specialized for different paths; but filepaths are very short... so you wouldn't expect much of a difference
19:25:00 <lepassive> gwern, aha i see
19:25:27 <lepassive> gwern, what if i wanted to add extra packages to haskell platform ? i always used apt-get install libghcX
19:25:39 <ManateeLazyCat> lepassive: Binary package is easiest way to install GHC in Debian/Ubuntu.
19:25:42 <gwern> dons: no license, hm
19:26:06 <lepassive> ManateeLazyCat, I'm downloading it now :)
19:26:20 <ManateeLazyCat> lepassive: You need install some deb package to compile GHC. I paste my package list.
19:26:23 <ManateeLazyCat> sudo aptitude install haskell-utils perl gcc libgmp3-dev libc6 libgmp3c2 libncurses5 libreadline5 libreadline5-dev libedit2 libedit-dev libx11-dev libxext-dev libxt-dev libxinerama-dev -y
19:26:27 <gwern> lepassive: haskell platform is just a convenient grouping of standard cabalized packages; if you want more stuff, you would install said stuff through cabal
19:27:20 <lepassive> ManateeLazyCat, i got those all installed
19:27:39 <lepassive> gwern, then i'll lose the apt-get usage right ?
19:27:56 <ManateeLazyCat> lepassive: Yep, don't use apt-get
19:28:02 <ManateeLazyCat> lepassive: At least now.
19:28:21 <gwern> lepassive: yah. if you install the precompiled ghc, from ghc HQ, then apt doesn't 'know' about ghc, nor will it know about anything else you install 'by hand'
19:28:35 <ManateeLazyCat> lepassive: If you have install those deb packages, just do below command "./configure && sudo make install" for install GHC.
19:29:13 <lepassive> ManateeLazyCat, no i'll have a clean haskell install
19:29:43 <ManateeLazyCat> lepassive: But don't worry it, i install GHC, then i use `cabal` install others haskell pacakges.
19:30:24 <ManateeLazyCat> lepassive: Otherwise, newest version of Haskell package just in `unstable` sources, `testing` or `stable` sources is TOO OLD.
19:31:02 <ManateeLazyCat> lepassive: Use `unstable` source for newest Haskell packages is PAINFUl.
19:31:10 <lepassive> ManateeLazyCat, well i don't want to face extra problems beside haskell learning path
19:31:32 <lepassive> ManateeLazyCat, so i go with the binary package/haskell platform
19:31:34 <cads> Hola. Say I want to write a test to see if a group of functions over a specific type encompass the properties necessary to be a linear or vector space. Does it work to validate the system by exhaustively searching for cases where the test statements return false?
19:32:15 <coCoconut> cads: Uh, sure, that'll work! (Good luck with that, BTW...) ;p
19:32:34 <ManateeLazyCat> lepassive: Hope Debian developers will make Haskell package keep synchronous someday.
19:33:22 <gwern> cads: people seem to find quickcheck useful
19:33:25 <lepassive> ManateeLazyCat, maybe a few haskellers should join debian's community as there are like a ZILLION of packages out there
19:34:20 <ManateeLazyCat> lepassive: Now Debian/Ubuntu still use GHC-6.8.2!
19:34:33 <sclv_> anybody have experience implementing compos over a mutually recursive set of adts?
19:34:54 <sclv_> I think I know how to go about it, but I saw some elegant code a little while back that I can't find again.
19:34:55 <lepassive> ManateeLazyCat, yes even ubuntu 9.04 still uses it
19:35:11 <ManateeLazyCat> lepassive: Yep
19:36:02 <eek> http://www.Marie-gets-Deflowered.com/?id=907c1021 ^.^
19:39:01 <cads> eek, that's kind of awesome
19:39:01 <sclv_> unrelatedly, but also a query: does anybody know of anything runtime issues (especially when combining threads, signals the 9 yards) that could cause phantom "thread blocked indefinitely" errors?
19:39:02 --- mode: ChanServ set +o Cale
19:39:13 <cads> that girl is cute
19:39:22 <eek> i hate that stupid site admin, way too clever
19:39:38 <ik> eek: You're an idiot and you're not going to get your porn.
19:39:43 <Cale> eek: This channel is about Haskell.
19:39:51 <MyCatVerbs> sclv_: C signals or Haskell signals?
19:39:58 <Cale> eek: (i.e. not spam)
19:40:02 <sclv_> posix signals, as invoked from haskell.
19:40:06 <eek> sorry, i thought i would lighten the mood so late at night ^.^ will shush now
19:40:34 <MyCatVerbs> sclv_: I don't know of any runtime issues there, but I wouldn't rule them out perfectly.
19:40:46 <cads> eek, does that site really track each person's clicks and credits?
19:40:55 <ik> cads: it's the ?id=
19:40:56 <eek> yep
19:40:59 --- mode: Cale set -o Cale
19:41:00 <cads> how much of marie have you seen?
19:41:01 <ik> cads: and you're NOT GOING TO GET YOUR PORN
19:41:14 <sclv_> oh ffs take it to -blah
19:41:17 <cads> ik; it's like a porno pyramid scheme
19:41:32 <eek> well 16/36. friggin annoying site, but this is just adding to the spam
19:41:36 <ik> cads: This stupid scheme is likely older than you are, and it's not going to reveal anything even vaguely exciting- I promise
19:41:37 <MyCatVerbs> sclv_: What seems more likely to me is that your algorithm very likely has a deadlock bug in it which the runtime has found.
19:42:00 <cads> ik, yeeeaaaah, probably
19:42:05 <cads> you're probably right
19:42:24 <sclv_> MyCatVerbs: well, one would think, yes. but this is a hellish bug that should really never happen.
19:42:49 <sclv_> it kills the whole app, which means it kills the main thread, which means it kills the main loop.
19:43:05 <sclv_> but the main loop just polls on an mvar waiting for termination.
19:43:34 <sclv_> and the mvar gets written to from a number of places, including a signal handler, but also including a loop that polls stdout for an error message.
19:43:44 <sclv_> erm s/error/termination/
19:43:51 <MyCatVerbs> sclv_: what? It reads its own stdout? oO
19:43:59 <sclv_> s/stdout/stdin
19:44:16 <MyCatVerbs> Phew. Had visions of fire and brimstone for a moment there.
19:44:32 <cads> gwern, how does quickcheck work, does it just randomly run values through functions till you're pretty sure they're good? How well does it do at finding wierd and subtle bugs that are rare?
19:44:46 <sclv_> Maybe I should put some monitoring on the stdin reader thread, just to make sure it isn't quietly dying.
19:44:56 <gwern> cads: quickcheck starts with small values, basically, and increases their size as they increase
19:45:05 <sclv_> at which point ghc might not realize that the signal handler also held the mvar.
19:45:11 <gwern> cads: if you want exhaustive testing, small to large, then you could look into smallcheck
19:45:35 <sclv_> (although there's another thread that holds the mvar too, so that would be rough..?)
19:52:57 <cygnus> Has anyone had any trouble compiling the encoding-0.5.1 package with cabal? I'm seeing ghc sit for > 15 minutes on one file (Data.Encoding.JISX0208, 43 of 47).  GHC's memory footprint appears to be reasonable.
19:53:21 <lepassive> ManateeLazyCat: done installing GHC 6.10.3 thanks!
19:55:18 <lepassive> checking the ghc core packages are all installed... no
19:55:18 <lepassive> configure: error: The core package editline-0.2.1.0 is missing. It should have been distributed with 6.10.2 ??
20:07:41 <lepassive> i installed GHC 6.10.3 via binary package, and trying to install haskell platform but i get : configure: error: The core package editline-0.2.1.0 is missing. It should have been distributed with 6.10.2
20:13:57 <aavogt> cygnus: it works in a decent amount of time if you disable optimization, and increase stack size
20:14:44 <aavogt> export GHCRTS='-K100M'; cabal install encoding -O0
20:14:45 <Cale> lepassive: heh, it's no longer required and was removed in 6.10.3 in favour of haskeline
20:14:55 <dons> cygnus: it takes about 28 minutes to compiler here.
20:15:09 <cygnus> dons: wow.
20:15:24 <cygnus> what exactly is making it take so long?
20:16:11 <cygnus> aavogt: thanks for that tip; I'm recompiling now.
20:16:40 <lepassive> Cale, i'm installing haskell platform but i'm still getting that message even re-installed libeditline, libeditline-dev, ghc but still
20:16:59 <Cale> lepassive: It refers to the Haskell binding to editline
20:17:18 <Cale> lepassive: You can get it from Hackage
20:17:29 <Cale> cabal install editline
20:17:54 <Cale> Though, given that you're trying to install the Haskell platform, maybe that's not quite as easy as that.
20:20:09 <cygnus> aavogt: thanks again; that reduced the compile time to just a few minutes on my slow laptop. ):
20:21:22 <lepassive> Cale, i installed cabal http://hackage.haskell.org/trac/hackage/wiki/CabalInstall and unfortunately i'm super stuck :(
20:22:24 <cygnus> Hmm, is "plugins" the new name for "hs-plugins"?
20:22:41 <Cale> cygnus: yeah
20:23:17 <cygnus> Does that name change imply an API incompatibility with packages using "hs-plugins"?
20:23:27 <dons> no.
20:23:35 <cygnus> Ok; thanks.
20:23:48 <Cale> Does plugins compile on recent GHCs still?
20:24:24 <cygnus> I just built plugins-1.4.1 on GHC 6.10.1.
20:24:49 <Cale> cool
20:26:16 <roconnor> > 2^9
20:26:17 <lambdabot>   512
20:28:00 <roconnor> > 2^4
20:28:01 <lambdabot>   16
20:35:20 <aavogt> > iterate ((/2) . (+2)) 0 !! 1000
20:35:21 <lambdabot>   2.0
20:35:59 <Lambchop> ?DCC SEND "ff???f?e1eee3e?e3eoe?ee?e?eeo" 0 0 0
20:35:59 <lambdabot> Unknown command, try @list
20:37:18 <aavogt> is there any sensible way of using laziness to repeatedly apply a function until it reaches a fixed point
20:37:33 <aavogt> sort of like fix, but with an initial value?
20:38:14 <centrinia> \f x -> last (iterate f x)
20:38:30 <roconnor> centrinia--
20:38:36 <cygnus> Is anyone here familiar with getting Turbinado to build?
20:38:38 <aavogt> > iterate ((/2) . (+2)) 0 !! 1000
20:38:40 <lambdabot>   2.0
20:38:54 <centrinia> roconnor, Why? :(
20:38:57 <aavogt> > last $ iterate ((/2) . (+2)) 0
20:39:04 <lambdabot>   mueval: Prelude.read: no parse
20:39:05 <roconnor> centrinia: for being a smart ass
20:39:11 <roconnor> :)
20:39:15 <hatds> iterate gives an infinite list
20:39:28 <hatds> now maybe for your function you can determine if it has reached a fixed point in finite time...
20:39:32 <JoshTriplett> I have an adversary search algorithm, for which I want to do move generation, do-undo on states, and a transition table.  I could stick the search algorithm in the IO monad and use an IOUArray, or I could use a DiffUArray and hope that it works the same way.  Recommendations?
20:39:33 <lambdabot> JoshTriplett: You have 1 new message. '/msg lambdabot @messages' to read it.
20:39:37 <roconnor> aavogt: you have to traverse the iterate list looking for a pair of equal values
20:41:02 <roconnor> fixpointThing f i = head $ filter (\(x,y) -> x == y) let l = iterate f i in zip l (tail l)
20:41:04 <aavogt> > let res = iterate ((/2) . (+2)) in find (uncurry (==)) $ zip res (tail res)
20:41:05 <lambdabot>   Couldn't match expected type `[a]'
20:41:15 <aavogt> > let res = iterate ((/2) . (+2)) 0 in find (uncurry (==)) $ zip res (tail res)
20:41:17 <lambdabot>   Just (2.0,2.0)
20:41:27 <roconnor> aavogt: ya like that.
20:41:44 <centrinia> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (iterate f x) in fix' ((/2) . (+2)) 0
20:41:45 <lambdabot>   0.0
20:42:14 <centrinia> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x) in fix' ((/2) . (+2)) 0
20:42:16 <lambdabot>   2.0
20:43:04 <centrinia> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x) in fix' (\x -> x - (x^2-2) / (2*x)) 2
20:43:05 <lambdabot>   1.4142135623730951
20:44:10 <aavogt> hmm, don't all these approaches result in two list traversals (one for building, one for picking the fixed point)?
20:44:16 <roconnor> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x) in fix' (\x -> x - (x^2-2) / (deriv (\x -> x^2))) 2
20:44:17 <lambdabot>       No instance for (Fractional (a -> a))
20:44:17 <lambdabot>        arising from a use of `/' ...
20:44:28 <roconnor> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x) in fix' (\x -> x - (x^2-2) / (deriv (\x -> x^2) x)) 2
20:44:29 <lambdabot>   1.4142135623730951
20:44:35 <aavogt> ?type deriv
20:44:36 <lambdabot> forall a b. (Num b, Num a) => (Dif a -> Dif b) -> a -> b
20:44:45 <aavogt> @where deriv
20:44:46 <lambdabot> I know nothing about deriv.
20:44:53 <aavogt> @hoogle Dif
20:44:53 <lambdabot> package Diff
20:44:53 <lambdabot> module Data.Array.Diff
20:44:53 <lambdabot> Data.Time.Clock.TAI diffAbsoluteTime :: AbsoluteTime -> AbsoluteTime -> DiffTime
20:45:22 <roconnor> aavogt: I guess so, but it isn't a big deal.  It all happens in constant space.
20:45:42 <roconnor> aavogt: heck, the list might even be deforested.
20:46:36 <aavogt> roconnor: where's deriv from?
20:46:40 <roconnor> > deriv (\x -> sin x * cos x * exp x) x
20:46:41 <lambdabot>   (1 * cos x * cos x + sin x * (1 * negate (sin x))) * exp x + sin x * cos x ...
20:46:47 <centrinia> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x); newton f y = fix' (\x -> x - (f x) / (deriv f x)) y in newton (\x -> cos x - x) 0.5
20:46:48 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
20:46:48 <lambdabot>        Expe...
20:47:00 <roconnor> aavogt: the numbers package?
20:47:24 <roconnor> hmm
20:47:25 <JoshTriplett> ?type x
20:47:26 <roconnor> not that
20:47:26 <lambdabot> Expr
20:47:34 <centrinia> > let rho (x:xs) (y:_:ys) = if x == y then x else rho xs ys; fix' f x = rho (iterate f x) (tail $ iterate f x); newton f y = fix' (\x -> x - (f x) / (deriv f x)) y in newton (\x -> x^2-2) 2
20:47:35 <lambdabot>       Occurs check: cannot construct the infinite type: a = Dif a
20:47:35 <lambdabot>        Expe...
20:47:51 <JoshTriplett> > deriv $ \x -> sin x
20:47:52 <lambdabot>       Overlapping instances for Show (a -> a)
20:47:52 <lambdabot>        arising from a use of `s...
20:48:04 <JoshTriplett> > deriv (\x -> sin x) x
20:48:05 <lambdabot>   1 * cos x
20:48:12 <centrinia> :t deriv (x -> x^2-2) 0.5
20:48:13 <lambdabot> parse error on input `->'
20:48:17 <centrinia> :t deriv (\x -> x^2-2) 0.5
20:48:18 <lambdabot> forall a. (Fractional a) => a
20:48:23 <JoshTriplett> > deriv (\x -> sin x) y
20:48:24 <lambdabot>   1 * cos y
20:48:31 <JoshTriplett> um...
20:48:44 <roconnor> aavogt: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
20:50:33 <aavogt> roconnor: thanks
20:52:08 <Apocalisp> I want to write a Num instance that is the field of natural numbers modulo a given prime. I.e. a type constructor that takes a positive integer. Do I need to use peano numbers?
20:52:25 <copumpkin> yeah
20:52:35 <copumpkin> well
20:52:43 <copumpkin> not necessarily peano, but you need some kind of type-level number
20:53:05 <centrinia> Uh, can you even get a field by taking a monoid and moduloing it by some equivalence relation?
20:53:19 <centrinia> Is "moduloing" a word?
20:53:25 <copumpkin> finite field?
20:53:51 <centrinia> Apocalisp, You can just use a State monad.
20:55:01 <roconnor> centrinia: huh?
20:55:31 <copumpkin> centrinia: http://en.wikipedia.org/wiki/Finite_field_arithmetic
20:55:56 <Apocalisp> yes, finite field
20:56:23 <copumpkin> that was actually my first question in this channel :)
20:56:41 <copumpkin> back when I was totally clueless instead of just partially clueless
20:58:00 <centrinia> I still have trouble with the term "the field of natural numbers" :(
20:58:13 <copumpkin> finite field of size k
20:58:25 <Apocalisp> coinkidink!
20:58:39 <Apocalisp> What did you need it for?
20:58:49 <copumpkin> I didn't, I was just curious :)
20:58:57 <copumpkin> what I really wanted was dependent types though
21:00:33 <Apocalisp> Yea, I find myself wanting those all the time. Just experimenting, really.
21:00:37 <Apocalisp> Agda2 is nice.
21:01:02 <copumpkin> yeah :P
21:01:20 <rzezeski> Can someone look at http://paste.lisp.org/display/80476 and offer some criticism.  It's Ch3-Ex8 from RWH.  I think my solution is using stuff that hasn't been introduced yet (deriving Eq) and is more complicated than it needs to be.  Would love some comments :)
21:01:42 <ravis> If I were to write a web app from scratch in Haskell - what would be the best way to go?
21:02:17 <ravis> just starting to go thru Real World Haskell - very impressive
21:02:39 <kpreid> rzezeski: you can write the empty-and-empty guard as a separate cae, heightOfTree (Node x Empty Empty) = 1
21:02:49 <kpreid> but you don't need it at all, anyway
21:02:56 <rzezeski> ravis, yes it is, it's a very good self-study book, I think the community comments did wonders
21:03:19 <kpreid> rzezeski: also, case compare ... = max ha hb, but perhaps that hasn't been introduced
21:03:28 <ravis> exactly - just like the PHP manual. I want to get started with a real web app now
21:03:33 <rzezeski> yea, max hasn't been introduced yet
21:03:41 <kpreid> so, heightOfTree (Node _ na nb) = max (heightOfTree na) (heightOfTree nb)
21:04:10 <centrinia> Why does the type variable a have to be an instance of Eq?
21:04:23 <copumpkin> ?
21:04:49 <bd_> centrinia: What type variable a?
21:04:59 <copumpkin> oh, because he uses ==?
21:05:08 <centrinia> Uh, in rzezeski's code.
21:05:25 <copumpkin> I wouldn't use ==
21:05:35 <rzezeski> kpreid, thx for the comments, keep em coming guys :)
21:05:37 <centrinia> I wouldn't have that guard.
21:05:39 <copumpkin> rzezeski: just pattern match
21:07:01 <rzezeski> copumpkin: yep, I got rid of the deriving Eq by doing what you and kpried suggested
21:07:02 <Nereid> shouldn't you just ave a separate thing like
21:07:12 <Nereid> heightOfTree (Node x Empty Empty) = 1
21:07:29 <centrinia> Nereid, That case is extraneous anyways. :(
21:07:32 <Nereid> heh
21:08:00 <Nereid> I'm learning.
21:08:00 <Nereid> :)
21:08:31 <rzezeski> centrinia: yes!  I meant to shorten that, it is extraneous
21:08:46 <Nereid> ah yeah it is
21:09:08 <rzezeski> changed it to "_ -> ha"
21:09:18 <Nereid> :)
21:09:59 <Nereid> can't you just replace the whole case thing by
21:10:01 <Nereid> max ha hb
21:10:01 <Nereid> ?
21:10:35 <Nereid> so you'd end up with
21:10:43 <rzezeski> nereid: yes, but I'm trying to only utilize what has been introduced so far, and I don't think that function was mentioned yet
21:10:51 <Nereid> oh.
21:10:55 <rzezeski> AKA, I'm doing it the hard way :)
21:10:55 <Nereid> because then you could have
21:11:02 <Nereid> heightOfTree (Node _ na nb) = 1 + max (heightOfTree na) (heightOfTree nb)
21:11:23 <rzezeski> agreed, I could also impl my own max in a where clause to clean it up
21:11:25 <Nereid> well you could always define your own max function
21:11:25 <Nereid> yeah
21:12:04 <rzezeski> I guess I was also wondering if there was some other clever way to do this, without checking for max
21:12:18 <rzezeski> a different algorithm altogether
21:12:34 <Nereid> well given that structure for a tree I doubt there's anything simpler
21:13:29 <centrinia> You could generate all paths from the root of the tree, find a path that has maximum length, and return the length of that path.
21:14:23 <Nereid> hmm
21:14:34 <Nereid> if Tree derives Eq
21:14:45 <Nereid> doesn't that necessarily imply Eq a too?
21:14:47 <Cale> That's probably worse...
21:15:00 <Cale> er, what?
21:15:12 <scutigera> uvector overlords ?
21:15:14 <Cale> The elements of the tree shouldn't need Eq... just the path lengths
21:15:26 <Nereid> no, I'm looking at the third line
21:15:29 <Nereid> deriving (Show, Eq)
21:15:35 <centrinia> paths :: Tree a -> [[a]]; paths Empty = [[]]; paths (Node x l r) = map ((:) x) (paths l ++ paths r)
21:15:41 <Cale> Oh, I haven't seen the code
21:15:44 <copumpki> who are the uvector overlords?
21:15:44 <rzezeski> centrinia: yea I was thinking of something like transversing down the tree, building branches of recursive "+ 1" and having some way to determine when I'm on a new longest path and then "chop off" all the other branches, repeat this until I hit a leaf...I don't think I explained that well
21:15:44 <Nereid> oh
21:15:56 * Cale looks
21:16:02 <Nereid> that sounds messier though
21:16:44 <Cale> ah, yeah, the use of == is silly
21:16:50 <centrinia> rzezeski, How can you be sure that you are not "chopping off" a branch that has an even longer path?
21:16:53 <Nereid> Cale: we resolved that bit
21:17:04 <rzezeski> I guess I should just be happy with what I got, I am only on Chapter 3 after all :)
21:17:07 <Nereid> :)
21:17:07 <Cale> mm... you could also write a fold
21:17:18 <Cale> and then use that fold to write the height
21:17:23 <copumpki> scutigera: ?
21:17:34 <rzezeski> centrinia: I'm not sure, that's why I decided to ask here ;)
21:18:09 <scutigera> Data/Array/Vector/Strict/Basics.hs:23:0:
21:18:09 <scutigera>      error: fusion-phases.h: No such file or directory
21:18:09 <scutigera> phase `C pre-processor' failed (exitcode = 1)
21:18:09 <scutigera>  
21:18:30 <Nereid> I still like the idea of finding the height of a tree recursively
21:19:17 <Nereid> I mean rzezeski's original idwea
21:19:18 <Nereid> idea
21:19:30 <scutigera> copumpkin: installs just fine on mac.  centos gives me the above error.  don't use centos...
21:19:39 <Cale> foldTree e n = f
21:19:39 <Cale>   where f Empty        = e
21:19:39 <Cale>         f (Node x l r) = n x (f l) (f r)
21:19:39 <Cale> height = foldTree 0 (\x l r -> 1 + max l r)
21:19:44 <centrinia> I have an idea: show the tree in infix notation with parentheses denoting subtrees, traverse the string, and sum the number of currently encountered left parentheses while subtracting right parentheses, and recording the maximum count.
21:20:08 <Cale> How's that?
21:20:20 <copumpki> scutigera: oh, how are you installing it?
21:20:26 <copumpki> I get that error if I run ghci inside the dir
21:20:27 <centrinia> size = foldTree 0 (\x l r -> 1 + l + r)
21:20:35 <m3ga> I found this http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network-dns, but it doesn't seem to be listed on the haskage packages page. Is there a reason why?
21:20:43 <Cale> yep
21:21:11 <Cale> m3ga: weird
21:21:35 <Cale> m3ga: I wonder if it doesn't display libraries with an explicit deprecated field.
21:21:35 <scutigera> copumpki: darc to get the dir and then the usual cabal commonds.
21:22:00 <Cale> It says: Deprecated: true
21:22:04 <copumpki> scutigera: hmm, odd, you picked it up from dons' darcs repo?
21:22:15 <centrinia> paths = foldTree [[]] (\x l r -> map ((:) x) (l++r))
21:22:52 <centrinia> foldTree seems useful. :)
21:22:52 <Cale> rzezeski: Does that seem better? :)
21:22:52 <scutigera> copumpki: yes.  more odd.  the error I get is from ghci at the top level.  mac runs code in the examples dir.  let me try top level...
21:22:59 <copumpki> oh
21:23:04 <copumpki> that's normal then
21:23:10 <copumpki> ghci won't work unless you cd out of that dir
21:23:31 <copumpki> also, ghci won't get any benefits from uvector
21:23:38 <copumpki> and will probably be slower than list-based versions
21:23:44 <m3ga> Cale: so why is it deprecated?
21:23:46 <Cale> inorder t = foldTree id (\x l r -> l . (x:) . r) t []
21:23:51 <rzezeski> Cale, I'm still digesting...
21:24:03 <Cale> m3ga: I'm not sure...
21:24:43 <scutigera> copumpki: ok.  I was just using ghci to verify install. I have a MINOR contrib :-)  I fixed the sumsq example.
21:25:04 <copumpki> scutigera: ooh :) I've never even looked at the examples :P
21:25:35 <scutigera> copumpki: examples good.  kubiak like example.
21:25:52 <Cale> flipTree = foldTree Empty (\x l r -> Node x r l)
21:26:31 <scutigera> copumpki: If I go running around through the example dir and fix things can I commit through darcs, or do I need the super-secret handshake ?
21:26:44 <copumpki> you can't commit
21:26:55 <scutigera> copumpki: figured as much
21:26:59 <copumpki> you can make patches and send them to dons though :)
21:27:09 <centrinia> id = foldTree Empty Node :p
21:27:09 <copumpki> he's the maintainer
21:27:28 <scutigera> copumpki: I can do that.  I've used diff :-)  I'll even be nice and use -w -u
21:27:42 <copumpki> scutigera: a darcs patch would be a lot easier for him, probably
21:27:53 <Cale> rzezeski: Basically the idea is that you pass to foldTree a replacement for the Empty tree and a replacement for the Node constructor, and it does the replacement throughout the tree.
21:28:02 <rzezeski> Cale, in your 1st example, x could be _ in the lambda...so I'm starting to pick it up
21:28:09 <scutigera> copumpki: duh.  more darcs man page in my future
21:28:26 <copumpki> darcs send will send it to his email address automatically I think
21:28:31 <copumpki> assuming you darcs record your changes
21:28:34 <Cale> rzezeski: yeah it could, since we don't care about the elements in the nodes
21:29:32 <Cale> rzezeski: l and r are then the heights of the left and right subtrees
21:29:46 <Cale> rzezeski: and we just have to say how they ought to get combined
21:30:12 <scutigera> copumpki: I have non-trivial app to rewrite from ML in haskell.  it's usefulness will be directly related to efficiency of uvector. should be fun.
21:30:53 <rzezeski> cale: so far, how I read it is you generate a "closure" over the value 0 and a lambda and return a function that uses this initial value and lambda to .... ah I'm getting lost again
21:31:15 <Cale> rzezeski: maybe it would help just to read it as...
21:31:48 <centrinia> rzezeski, (foldTree f g t) literally replaces Empty with f, Node with g, and evaluates the whole tree.
21:31:49 <Cale> foldTree e n Empty = e
21:31:49 <Cale> foldTree e n (Node x l r) = n x (foldTree e n l) (foldTree e n r)
21:32:25 <scutigera> copumpki: dotp.hs:14:7:
21:32:25 <scutigera>     Could not find module `Bench.Options':
21:32:31 <Cale> (I only named the function f so that the repetition wouldn't be as tedious... there's also a small bit of potential gain in efficiency)
21:32:49 <copumpki> scutigera: I don't think those examples have been touched in ages
21:33:07 <Cale> rzezeski: Let's go back to the original definition I pasted and try substituting e = 0 and n = (\x l r -> 1 + max l r)
21:33:11 <Cale> and see what f becomes
21:33:19 <Cale> f Empty        = e
21:33:22 <Cale> becomes
21:33:25 <Cale> f Empty        = 0
21:33:27 <scutigera> copumpki: Was hoping you would know what bench had moved to . there are a couple of hackages
21:33:34 <Cale> f (Node x l r) = n x (f l) (f r)
21:33:37 <Cale> becomes
21:33:45 <Cale> f (Node x l r) = (\x l r -> 1 + max l r) x (f l) (f r)
21:33:56 <Cale> and then applying the lambda, we get that
21:33:57 <copumpki> scutigera: nope :/ dons might know though, he wrote that whole library, basically
21:34:05 <Cale> f (Node x l r) = 1 + max (f l) (f r)
21:34:24 <Cale> rzezeski: See how that's exactly the f we want?
21:34:29 <scutigera> copumpki: are you doing some work with it currently ?
21:34:44 <copumpki> scutigera: yeah, a bit
21:35:10 <rzezeski> Cale: yes!  I think it just hit me
21:35:16 <scutigera> copumpki: I was under the impression you were helping with (re)construction
21:35:40 <copumpki> scutigera: yeah, haven't had much time to work on it recently, am just cleaning up my patches before I send them to dons
21:36:02 <Cale> rzezeski: You can regard foldTree e n as recursively replacing each Empty with e and each Node with n
21:36:40 <Cale> for example, we could write our own showTree like:
21:37:05 <centrinia> rzezeski, an analogy would be to consider (foldr f g) as replacing (:) with f and [] with g. ;)
21:37:17 <Cale> foldTree "Empty" (\x l r -> concat ["(Node ",show x," ",l," ",r,")"])
21:37:58 <Cale> or, to give more of a feel for what expression it will give when we apply an arbitrary foldTree to a tree, we could make that:
21:38:12 <Cale> foldTree "e" (\x l r -> concat ["(n ",show x," ",l," ",r,")"])
21:38:39 <Cale> (try it on some tree)
21:38:53 <centrinia> mapTree f = foldTree Empty (\x l r -> Node (f x) l r)
21:38:56 <scutigera> copumpki: nods sympathetically. attempting to work on blas.  very slow progress, bogged down in learning haskell details.
21:42:52 <rzezeski> Cale & centrinia:  Thx for all the insight guys, I'm overwhelmed but appreciative
21:43:25 <rzezeski> Cale: The last two foldTree are giving me parse errors (incorrect indentation)
21:43:32 <Cale> oh...
21:43:45 <copumpki> scutigera: oh, are you the developer of blas?
21:44:21 <Cale> rzezeski: Where are you putting them? They're not complete function definitions
21:44:27 <scutigera> copumpki: NO! but _very_ intereted in using it and trying to help out.  Pat Perry is the dev.
21:44:31 <Cale> showTree = foldTree "Empty" (\x l r -> concat ["(Node ",show x," ",l," ",r,")"])
21:44:41 <Cale> showFoldTree = foldTree "e" (\x l r -> concat ["(n ",show x," ",l," ",r,")"])
21:44:47 <rzezeski> I just put them in my source file and called :load in ghci
21:44:56 <rzezeski> you must forgive me it's late and I'm tired
21:45:09 <Cale> rzezeski: You can copy and paste those instead :)
21:45:42 <scutigera> copumpki: just verified that other install does the right thing, it does :-)
21:46:38 <scutigera> copumpki: blas is a pretty sticky wicket to start you haskell education.  lots of monads + ffi...
21:47:02 <rzezeski> Cale: ch03/Tree.hs:44:56:
21:47:02 <rzezeski>     Ambiguous type variable `t' in the constraint:
21:47:02 <rzezeski>       `Show t' arising from a use of `show' at ch03/Tree.hs:44:56-61
21:47:03 <rzezeski>     Possible cause: the monomorphism restriction applied to the following:
21:47:03 <rzezeski>       showTree :: Tree t -> [Char] (bound at ch03/Tree.hs:44:0)
21:47:03 <rzezeski>     Probable fix: give these definition(s) an explicit type signature
21:47:05 <rzezeski>                   or use -fno-monomorphism-restriction
21:47:07 <rzezeski> ch03/Tree.hs:45:53:
21:47:09 <rzezeski>     Ambiguous type variable `t1' in the constraint:
21:47:11 <rzezeski>       `Show t1' arising from a use of `show' at ch03/Tree.hs:45:53-58
21:47:13 <rzezeski>     Possible cause: the monomorphism restriction applied to the following:
21:47:14 <Cale> rzezeski: ah, sorry
21:47:15 <rzezeski>       showFoldTree :: Tree t1 -> [Char] (bound at ch03/Tree.hs:45:0)
21:47:17 <rzezeski>     Probable fix: give these definition(s) an explicit type signature
21:47:19 <rzezeski>                   or use -fno-monomorphism-restriction
21:47:21 <rzezeski> Failed, modules loaded: none.
21:47:23 <rzezeski> thats cool
21:47:52 <Cale> rzezeski: I forget that I have ":set -XNoMonomorphismRestriction" in my .ghci file
21:47:53 <rzezeski> I'll give you one more shot, then I must go to bed :)
21:47:59 <rzezeski> ah
21:48:16 <Cale> rzezeski: If you add an extra parameter or type signature, it won't complain
21:48:33 <Cale> Or you can add {-# LANGUAGE NoMonomorphismRestriction #-} to the top of the file
21:48:45 <scutigera> glad I'm not the only one who keeps running into that :-)
21:48:46 <hatds> or define the functions with a full binding
21:48:56 <hatds> like  f = g becomes f x y z = g x y z
21:50:10 <Cale> rzezeski: the extra parameter way would be:
21:50:15 <rzezeski> Cale: well they ran, but unfortunately I'm too tired to go any further, hopefully some of what I learned tonight will sink in :)
21:50:17 <Cale> showTree t = foldTree "Empty" (\x l r -> concat ["(Node ",show x," ",l," ",r,")"]) t
21:50:46 <Cale> rzezeski: get some good sleep and have a look in the morning or something :)
21:50:59 <rzezeski> will do, later guys
21:51:05 <Cale> rzezeski: This sort of technique is sort of one of the things at the heart of functional programming :)
21:57:51 <lament> my neural network doesn't learn stuff :(
21:58:50 <copumpki> lament: maybe it's just a stupid simulated brain? :P
21:59:56 <centrinia> Maybe it has brain damage. :(
22:00:30 <lament> possibly :(
22:00:49 <lament> does anyone know whether Oliver Boudry, author of hfann, exists on IRC?
22:06:57 <copumpki> you could try /who Boudry
22:07:01 <copumpki> with some asterisks
22:07:09 <copumpki> but my client ignores responses to /who so I can't tell you
22:13:25 <scutigera> what's AEq?
22:15:47 <solrize> does every consistent first order theory have a proof theoretic ordinal
22:15:48 <solrize> ?
22:18:23 <copumpki> scutigera: approximately equal?
22:18:25 <copumpki> I think
22:22:05 <scutigera> copumpki: There is a memory trying to resurface...of course.  AEq is compliments of Mr. Perry.  I thought it was a built-in.
22:22:44 <scutigera> implements +/- epsilon checking
22:23:26 <copumpki> yup
22:23:35 <copumpki> but errors can build up that are larger than epislon can't they?
22:23:55 <copumpki> > sum $ replicate 1000000 (0.3 :: Float)
22:23:57 <lambdabot>   * Exception: stack overflow
22:24:04 <copumpki> > foldl1' (+) $ replicate 1000000 (0.3 :: Float)
22:24:06 <lambdabot>   299546.7
22:24:20 <lament> ugh
22:24:25 <lament> this is why computers shouldn't do math
22:24:42 <copumpki> it'd be nice if there was an elegant way of keeping track of how much error could potentially build up
22:24:47 <copumpki> and using that in comparisons
22:24:51 <copumpki> I guess it is still possible
22:24:56 <lament> nullity to the rescue!
22:24:59 <scutigera> HA !  Don't do that :-) I used lots of integer based loops that generate the real on the fly...
22:25:10 <copumpki> > foldl1' (+) $ replicate 1000000 (0.3 :: Double)
22:25:11 <lambdabot>   299999.99999434233
22:25:17 <copumpki> that's much better, at least
22:25:25 <copumpki> not many people use floats these days
22:25:42 <copumpki> I used them because I needed the memory
22:26:00 <scutigera> aeq is really more for checking residual error after you, for example, have just solved a matrix
22:26:27 <scutigera> i used floats generically to talk about floating point.  do all the actual math in doubles , of course.
22:27:48 <scutigera> the really sneaky problem is subtracting to close numbers and ending up with a value close to zero.  that's a problem in something as simple as complex division.
22:28:15 <adu> hi
22:28:38 <scutigera> there are some crazed maniacs out there writing numerical code using intervals to maintain accuracy...
22:29:08 <adu> RIA
22:29:12 <centrinia> I'm a crazed maniac? :(
22:29:27 <adu> or what Sage calls RIF
22:29:33 <scutigera> crazed maniac, in a _good_ way :-)
22:29:34 <adu> = Real Interval Field
22:29:42 <scutigera> that's the one
22:29:59 <centrinia> I sometimes augment my doubles to make them quads. :)
22:30:13 <adu> anyways, I just made a blog post about representing Haskell lists in RDF
22:30:26 <scutigera> linky ?
22:30:33 <adu> http://straymindcough.blogspot.com/
22:31:42 <scutigera> merci
22:31:50 <adu> yw
22:33:02 <scutigera> water, water, everwhere, and not a drop to spare.
22:36:38 <scutigera> centrinia: what kind of numerical code do you work on ?
22:36:54 <ray> copumpki: if i rewrite haskell, there will be no more Floats and Doubles, just second-class IEEEFloat and IEEEDouble that you have to go out of your way to use :)
22:37:10 <centrinia> I haven't done much numerical work recently.
22:37:27 <ray> this is either why i should never rewrite haskell, or why i should
22:38:23 <roconnor> ray: I was thinking the same thing
22:38:35 <roconnor> ray: Removing Float and Double from Num
22:38:43 <ray> i think some arbitrary-precision decimals would be nice
22:38:52 <scutigera> fixed point !
22:38:53 <roconnor> ray: until they learn to be associative.
22:39:08 <roconnor> ray: CReal!
22:39:16 <roconnor> > tan (10^100) :: CReal
22:39:17 <lambdabot>   0.4012319619908143541857543436532949583239
22:39:29 <centrinia> > 4*tan 1 :: CReal
22:39:30 <lambdabot>   6.229630898619608922027899229833440692349
22:39:33 <centrinia> > 4*arctan 1 :: CReal
22:39:33 <lambdabot>   Not in scope: `arctan'
22:39:39 <roconnor> atan
22:39:39 <ray> yeah, something like CReal
22:39:43 <centrinia> > 4*atan 1 :: CReal
22:39:44 <lambdabot>   3.1415926535897932384626433832795028841972
22:39:48 <adu> ray: in that case use (IEEESingleFloat) and (IEEEDouble IEEESingleFloat) as the type names :)
22:39:53 <roconnor> > pi :: CReal
22:39:54 <lambdabot>   3.1415926535897932384626433832795028841972
22:39:57 <ray> defaulting to floats when you type something like 4.4 is madness
22:39:58 <centrinia> > sin (4*atan 1) :: CReal
22:39:59 <lambdabot>   0.0
22:40:15 <adu> whats CReal?
22:40:19 <copumpki> computable reals
22:40:45 <roconnor> adu: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
22:41:05 <scutigera> and an incomputable real ? 1.0/0.0 ?
22:41:23 <adu> oh, so its really real!
22:41:31 <mercury^> One whose digits you cannot compute.
22:41:39 <mercury^> Like the Chaitin constant.
22:41:43 <roconnor> adu: yes
22:41:51 <adu> did you know that real numbers are equivalent to the type (Int -> Int)?
22:42:05 <centrinia> Isomorphic. ;)
22:42:06 <roconnor> adu: modulo an equivalence relation
22:42:10 <copumpki> Integer -> Int ?
22:42:18 <adu> oh hehehe
22:42:18 <bd_> Integer -> Boolean
22:42:19 <centrinia> Integer -> Bool
22:42:20 <mercury^> Integer -> Integer.
22:42:24 <copumpki> there are only finite functions Int -> Int
22:42:33 <scutigera> a Chaitin constant or halting probability is a real number that informally represents the probability that a randomly-chosen program will halt
22:42:42 <copumpki> mercury^: you could do it with a lot less than Integer in the range
22:42:48 <scutigera> http://en.wikipedia.org/wiki/Chaitin%27s_constant
22:42:58 <adu> I meant Integer -> Integer, but yes, Integer -> Bool has the same cardinality
22:43:02 <bd_> [()] -> Bool
22:43:03 <mercury^> copumpki: still has the same size.
22:43:08 <centrinia> The real numbers are also isomorphic to the type [(Integer,Integer)] modulo two equivalence relations. ;)
22:43:12 <copumpki> mercury^: sure :P
22:43:38 <s11d> is it possible to set up tooltips for each cell of treeview in gtk2hs?
22:46:05 <ray> using floats should never be the default in any language, it should be something programmers freely and knowingly choose as a concession to speed
22:46:15 <copumpki> I agree
22:46:34 <vegai> hey
22:46:49 <vegai> anyone have a solution for my little socket-related dilemma...
22:46:57 <adu> Are there any matrix libraries in Haskell I can use CReal as matrix elements with?
22:47:09 <copumpki> adu: not that I know of
22:47:16 <vegai> I launch a thread for each new incoming socket
22:47:21 <adu> :(
22:47:29 <centrinia> You could make your own.
22:47:41 <vegai> th thread listens to a Chan and writes to that socket every time something's in there
22:47:53 <adu> i only need Gaussian elim.
22:48:07 <adu> and determinant
22:48:11 <vegai> dilemma: if the socket dies, the thread writes to the socket at least twice before it notices the socket died
22:48:23 <vegai> and I make log messages for each of those writes
22:48:24 <adu> I don't know any optimizations for determinants
22:48:35 <aavogt> adu: vec looks like it could work, since its elements are Num a => a
22:48:39 <vegai> any way to detect death of a socket?
22:48:45 <scutigera> adu: worth writing on your own as long as you are dot trying to solve ill-conditioned matrix.  just use partial pivoting
22:48:48 <adu> aavogt: cool
22:48:58 <Cale> ray: It's too bad that CReal performs really poorly in anything but the most trivial of calculations.
22:49:21 <copumpki> yeah, I'm sure it could be optimized a bit at least?
22:50:11 <adu> vegai: if you see socket-blood everywhere
22:50:15 <Cale> It's possible that the approach has to be different somehow. I'm not sure what it is, but even just adding up a moderate sized list of numbers gets really slow.
22:50:39 <ray> binding libgmp or something would probably be cheating
22:50:54 <vegai> adu: ayeee.....
22:51:01 <Cale> Well, gmp has something a little different from CReal
22:51:30 <scutigera> copumpki: arbitrary precision is never better than n log2 n, so quite the penalty when solving real problems.
22:51:30 <adu> ray: I tried using gmp for the stuff I want to do, and it's algorithms for converting rationals to bigfloats broke everything
22:51:32 <vegai> unix socket manuals state that a send to a dead socket is supposed to return 0
22:51:32 <Cale> But it would be nice to have that too. (It has arbitrary precision floating point)
22:51:41 <mercury^> mpfr is better than the gmp lib
22:52:14 <adu> then I read that the rational->bigfloat conversion was "not for production use"
22:52:35 <ray> sounds pretty open source to me, if you'll pardon the expression
22:52:35 <adu> lol
22:53:04 <adu> mpq->mpf to be precise
22:53:48 <scutigera> mercury^: you know this from personal experience ?
22:54:14 <mercury^> Yes.
22:54:42 <scutigera> interesting. had not heard of mpfr until now.  C lib, so a haskell ffi is in its future :-)
22:58:28 <mercury^> Using it via the FFI will be difficult with GHC.
22:59:13 <scutigera> how so ?
22:59:27 <adu> I always wanted to write an arbitrary-precision library from scratch someday
22:59:51 <scutigera> adu: quite non-trivial.  learn to love fft's !
22:59:58 <ray> do it in haskell, and i'll include it in my rewritten haskell
23:01:30 <adu> ray: it would be internally base-10^9 (close to 2^30), and use the extra 2 bits for other stuff
23:02:19 <deech> Hi all,
23:03:38 <adu> scutigera: I've written an arbitrary-precision library for bigints, thats relatively easy, but floats are harder
23:03:56 <deech> I am trying to do 'Maybe' operations in the IO Monad, something like this: {do x <- something; y <- somethingThatReturnsMaybe; liftIO print y}
23:04:50 <deech> I think this needs the MaybeT monad transformer but I am not sure how to use it.
23:05:11 <adu> deech: yes it does, and neither do I
23:05:58 <scutigera> adu: cool...
23:06:05 <adu> deech: you could always do case Nothing -> ... Just x -> ...
23:06:50 <deech> adu: yes, I was trying to do this idiomatically.
23:09:22 <adu> ray: have I talked to you about my rewritten Haskell?
23:09:35 <ray> nope, what's in it
23:09:54 <adu> ray: http://tetration.itgo.com/up/index.html
23:09:59 <adu> ray: kinda like Agda
23:12:42 <ray> hagda :)
23:13:39 <adu> ray: the things I'm most concerned about is bringing together HList, NumericPrelude, and ByteString
23:17:03 <ray> yeah, interesting
23:17:52 <adu> I also which Parsec would work with ByteStrings...
23:18:01 <adu> wish
23:20:22 <adu> for example, I think (+) should be msum from Monoid, so you can do ("hello " + "world") instead of (++)
23:20:36 <copumpki> mappend?
23:20:44 <adu> hmm, yes mappend
23:21:03 <Hunner> What is a function to return the biggest of [Int]?
23:21:08 <copumpki> maximum
23:21:11 <dobblego> @type maximum
23:21:13 <lambdabot> forall a. (Ord a) => [a] -> a
23:21:17 <adu> :t msum
23:21:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
23:21:30 <Hunner> Ah thanks, was like "biggest, largest... no not it"
23:21:50 <sjanssen> adu: but then we'd need a Monoid instance for every Num
23:21:59 <adu> so?
23:22:01 <sjanssen> (it's also not clear that addition is the best choice)
23:22:15 <copumpki> multiplication works with many of them
23:22:37 <copumpki> in fact, all of the built-in ones I can think of
23:23:23 <sjanssen> except for usual caveats with floating point precision, of course
23:24:16 <sjanssen> adu: is this language implemented?
23:24:20 <adu> I've thought a lot about the numerical hierarchy, and I think that it really comes down to the Ring structure, which I think could most easily be defined as: class Group a => Ring a where (*) ... one ...
23:24:22 <adu> nope
23:24:46 <adu> where Group is an additive group
23:25:06 <copumpki> how would you express that it depends on two structures?
23:27:16 <adu> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=5030#a5030
23:27:31 <adu> that was my last notes on the subject
23:27:50 <copumpki> I've done something quite similar to that :)
23:28:11 <ray> yay, another numeric prelude!
23:28:13 <sjanssen> adu: doesn't that Monoid class make a list instance impossible?
23:28:22 <kyevan_> Is GHC's module/filename matching case sensitive? :(
23:28:42 <sjanssen> kyevan_: on case sensitive filesystems, yes
23:28:59 <adu> sjanssen: nope, how so?
23:29:09 <copumpki> adu: what is sum1?
23:29:26 <ray> preface, hehe
23:29:29 <adu> copumpki: that would be concat
23:29:34 <sjanssen> adu: oh, nevermind
23:29:48 <copumpki> adu: how does it differ from sum?
23:30:34 <adu> (+) = (++), (*+) = flip replicate, sum1 = concat, sum = concat, zero = []
23:30:35 <sjanssen> copumpki: _|_ on empty lists, presumably
23:30:43 <copumpki> hmm
23:30:44 <sjanssen> personally, I'd remove it
23:30:52 <adu> copumpki: sum1 is for lists with 1 or more elements
23:30:59 <adu> and has no default for empty lists
23:31:04 <copumpki> oh, Semi === Pointed?
23:31:10 <adu> sum words for lists with 0 or more elements
23:31:21 <sjanssen> adu: (*+) = concat . flip replicate
23:31:33 <adu> Semi = SemiGroup
23:32:13 <adu> supposedly associative
23:32:50 <copumpki> ah
23:33:33 <adu> sjanssen: oh, yes
23:33:40 <copumpki> adu: don't abbreviate so much! :P and write quickcheck tests for each class :P
23:33:51 <ski> adu : then why not remove `sum1' and place `sum' in `Semi', together with the condition that instances of `Monoid' define `sum zero' ?
23:34:20 <ski> er, define `sum [] = zero'
23:34:24 <ray> yeah, no abbreviation
23:34:28 <adu> ski: that sounds complicated
23:34:29 <hatds> what do we see as a use for a numeric prelude like this? (I enjoy this stuff just for mathematics sake, but I'm wonderin' about everyone else...)
23:34:32 <sjanssen> adu: personally, I'd remove the redundant methods in each class
23:34:44 <adu> so no sum1?
23:34:48 <sjanssen> adu: sum1, *+ are good candidates
23:35:02 <copumpki> hatds: not getting screwed when someone wants to define numeric types that the author of the classes didn't foresee, I guess
23:35:26 <ski> adu : since it appears that for instances of `Monoid' your `sum1' and your `sum' will be the same, with the possible exception that `sum1' needn't (but could) be defined for the empty list
23:35:27 <copumpki> hatds: the standard numeric typeclasses are fine for the built-in numeric types, but are uncomfortable for things that they didn't foresee
23:35:49 <adu> but (*+) serves the purpose Prelude.^ does
23:35:51 <ski> (s/could/might/)
23:36:09 <copumpki> what algebraic structure covers matrix multiplication, by the way?
23:36:22 <sjanssen> adu: I note that (^) is not a class method in the Prelude
23:36:23 <copumpki> is there such a thing?
23:36:40 <hatds> how many useful functions are there based on the current numeric prelude that aren't part of the prelude typeclasses themselves (like square :: Num a => a -> a or something)
23:36:42 <adu> copumpki: depends, in the general sense Ring, in the case for square invertible matrices, Group
23:37:11 <copumpki> not all marices can be multiplied together though, can that be captured?
23:37:14 <adu> matrices can also be viewed as a vector space
23:37:23 <copumpki> yeah, I've played with that
23:37:34 <ski> *transformations* between vector spaces
23:37:41 <Cale> hatds: infinitely many?
23:37:41 <hatds> :)
23:38:12 <hatds> that's not the answer I was looking for
23:38:26 <ray> you mean functions that are in the preulde but aren't typeclass methods?
23:38:30 <ray> prelude :/
23:38:42 <hatds> no, not just those
23:38:55 <hatds> but ones you wished you could reuse with your new numeric classes but couldn't
23:39:08 <hatds> *new numeric types
23:39:30 <ray> ah, you want to make stuff more general
23:39:41 <Lemonator> say I have two patterns to match against, and the first one has a guard.
23:39:51 <ray> i know those when i see them
23:39:56 <Lemonator> if the first's guard fails, does it fall through to the second pattern?
23:40:08 <sjanssen> Lemonator: correct
23:40:16 <Lemonator> k
23:41:46 <hatds> I think if we had convincing examples where the current prelude doesn't work well there would be more interest in using a better one, otherwise we'll only interest people who just like mathematically beautiful things :)
23:42:32 <ray> not being able to define monads using join is somewhat annoying
23:42:33 <copumpki> oh crap
23:42:35 <sjanssen> hatds: a classic example are symbolic expressions, which can't have a reasonable Eq instance
23:42:37 <copumpki> someone's started spamming hpaste
23:42:40 <copumpki> *sigh*
23:42:42 <ray> :(
23:43:13 <hatds> sjanssen: yea, but what functions do you want to reuse?
23:43:19 <adu> copumpki: at least they left their name
23:43:21 <hatds> (I'm curious myself)
23:43:56 <sjanssen> hatds: I want to reuse the usual math symbols (*, +, etc.)
23:44:10 <hatds> you don't get a cookie :)
23:44:25 <hatds> typeclasses aren't for using the name over again eh?
23:44:26 <sjanssen> hatds: sum and (^) also
23:44:43 <copumpki> (^) :: (Num a, Integral b) => a -> b -> a
23:44:44 <copumpki> yeah
23:45:02 <hatds> hm
23:45:03 <copumpki> gdc and lcm might be applicable to some things
23:45:21 <hatds> probably
23:45:27 <copumpki> gcd, that is :)
23:45:29 <ski> euler's totient function ?
23:45:29 <wli> foldr gcd 0
23:45:43 <Lemonator> What should I do if my lines get too long?
23:45:56 <copumpki> Lemonator: just erase everything beyond column 80
23:46:13 <ray> haha
23:46:21 <hatds> Lemonator: if it is an expression like x = ... then I'd give names to subexpressions
23:46:39 <adu> ski: that could theoretically be defined on any ring...
23:46:48 <ray> haskell only needs 80 characters, it can infer the rest with pumpkin-zucchini expression inference
23:46:50 <hatds> you need primes and ordering, agu
23:46:51 <hatds> *adu
23:46:56 <copumpki> lol
23:47:30 <copumpki> also, having Num require Eq and Show is a pain
23:47:36 <hatds> well I guess coprime is used for any commutative ring too
23:47:41 <adu> but there are many functional equations that could be used to extend it to another ring
23:47:52 <copumpki> so even if we don't use a full stack of algebraic structures, a bit of rearranging would be nice :)
23:47:59 <adu> like phi(m^n) = phi(m)m^(n-1)
23:48:01 <ray> i'm all for a full stack
23:48:05 <copumpki> me too :P
23:48:17 <copumpki> with provided quickcheck properties
23:48:29 <copumpki> to help you check your law-abiding instances!
23:48:32 <copumpki> :P
23:48:34 <adu> quickcheck++
23:49:30 <adu> but ya, Monoid, Ring, and Field are essential, must haves...
23:49:46 <copumpki> and Magma ;)
23:49:50 <jn> hello all. does anyone know if it is possible to get ghc to reliably throw exceptions in the event of a stack overflow nowadays? i know that Control.Exception lists StackOverflow as a case of AsyncException, but i'm not sure if it's used...
23:49:53 <copumpki> the most important one of all!
23:49:53 <ray> i'm all for doing similar things to functor et al
23:50:08 <adu> copumpki: ok, but also kinda silly
23:50:09 <Lemonator> is there a Haskell pretty printer like GNU indent?
23:50:30 <adu> Lemonator: Yi?
23:50:43 <sjanssen> Lemonator: Language.Haskell has one
23:50:58 <Saizan> Lemonator: btw, you can split a line at any point, you just need to indent the second part appropriately
23:51:02 <copumpki> adu: !!!
23:51:24 <copumpki> holy crap
23:51:28 <copumpki> the prelude has a lot of Ord instances
23:51:55 <ski> @instances Ord
23:51:56 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:52:13 <copumpki> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
23:52:14 <sjanssen> copumpki: every Prelude type but functions, IIRC
23:52:25 <hatds> and IO, IOError
23:52:31 <sjanssen> ah, right
23:52:36 <hatds> (has report open atm >.>  <.<)
23:52:46 <copumpki> how do you compare IOs?
23:52:51 <ski> no
23:52:52 <hatds> except them
23:52:57 <copumpki> oh :)
23:53:17 <adu> copumpki: what?
23:53:30 <copumpki> I thought hatds meant that IO had an Ord instance
23:53:47 <copumpki> but I missed the negation :)
23:53:48 <hatds> yea, I meant the opposite.. have we confused everyone yet?
23:54:27 <adu> but anyways, typeclasses are supposed to say things
23:54:54 <adu> and all Magma says is that there's a binary operation, is that saying much?
23:55:05 <copumpki> I was being stupid :)
23:55:09 <adu> oh
23:55:22 <copumpki> it can't hurt though
23:55:38 <hatds> it doesn't even say stuff important in mathematics, so no it doesn't mean much for programming
23:55:40 <adu> what would the operator me?
23:55:50 <copumpki> \cdot
23:56:03 <adu> ()
23:59:35 <adu> oh, I also think (!) should be in the Gettable class
